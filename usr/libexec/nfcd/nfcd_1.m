void sub_1000CDC10(uint64_t a1)
{
  void *v2;
  NSObject *v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  NSObject *v7;
  void *v8;
  NFContactlessPaymentStartEvent *v9;
  void *v10;
  uint64_t v11;
  void (*v12)(uint64_t, const char *, ...);
  objc_class *v13;
  _BOOL4 v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  NSObject *v18;
  objc_class *v19;
  int v20;
  const char *v21;
  const char *v22;
  NSMutableDictionary *v23;
  void *v24;
  id WeakRetained;
  void *specific;
  uint64_t Logger;
  void (*v28)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  objc_class *v35;
  int v36;
  const char *v37;
  const char *v38;
  void *v39;
  uint64_t v40;
  void (*v41)(uint64_t, const char *, ...);
  objc_class *v42;
  _BOOL4 v43;
  const char *v44;
  uint64_t v45;
  void *v46;
  uint64_t v47;
  objc_class *v48;
  int v49;
  const char *v50;
  const char *v51;
  void *v52;
  uint64_t v53;
  void (*v54)(uint64_t, const char *, ...);
  objc_class *v55;
  _BOOL4 v56;
  const char *v57;
  uint64_t v58;
  void *v59;
  uint64_t v60;
  objc_class *v61;
  int v62;
  const char *v63;
  const char *v64;
  void *v65;
  uint64_t v66;
  void (*v67)(uint64_t, const char *, ...);
  objc_class *v68;
  _BOOL4 v69;
  const char *v70;
  uint64_t v71;
  void *v72;
  uint64_t v73;
  objc_class *v74;
  int v75;
  const char *v76;
  const char *v77;
  const char *v78;
  NSObject *p_super;
  uint32_t v80;
  void *v81;
  uint64_t v82;
  void (*v83)(uint64_t, const char *, ...);
  objc_class *v84;
  _BOOL4 v85;
  uint64_t v86;
  void *v87;
  uint64_t v88;
  NSObject *v89;
  objc_class *v90;
  int v91;
  const char *v92;
  const char *v93;
  NSMutableDictionary *v94;
  void *v95;
  uint64_t v96;
  void (*v97)(uint64_t, const char *, ...);
  objc_class *v98;
  _BOOL4 v99;
  uint64_t v100;
  void *v101;
  uint64_t v102;
  objc_class *v103;
  int v104;
  const char *v105;
  const char *v106;
  const char *v107;
  const char *v108;
  const char *v109;
  const char *v110;
  const char *Name;
  const char *v112;
  const char *v113;
  const char *v114;
  const char *v115;
  const char *v116;
  uint8_t buf[4];
  int v118;
  __int16 v119;
  const char *v120;
  __int16 v121;
  const char *v122;
  __int16 v123;
  int v124;
  __int16 v125;
  NFContactlessPaymentStartEvent *v126;

  v2 = *(void **)(a1 + 32);
  if (v2)
  {
    v3 = objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "objectForKeyedSubscript:", CFSTR("EventType")));
    if (!v3 || (v4 = objc_opt_class(NSString), (objc_opt_isKindOfClass(v3, v4) & 1) == 0))
    {
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v28 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(*(id *)(a1 + 40));
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(*(id *)(a1 + 40));
        Name = sel_getName(*(SEL *)(a1 + 48));
        v32 = 45;
        if (isMetaClass)
          v32 = 43;
        v28(3, "%c[%{public}s %{public}s]:%i EventType missing or not NSString!!", v32, ClassName, Name, 80);
      }
      v33 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v34 = NFSharedLogGetLogger(v33);
      v5 = objc_claimAutoreleasedReturnValue(v34);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        v35 = object_getClass(*(id *)(a1 + 40));
        if (class_isMetaClass(v35))
          v36 = 43;
        else
          v36 = 45;
        v37 = object_getClassName(*(id *)(a1 + 40));
        v38 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)buf = 67109890;
        v118 = v36;
        v119 = 2082;
        v120 = v37;
        v121 = 2082;
        v122 = v38;
        v123 = 1024;
        v124 = 80;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i EventType missing or not NSString!!", buf, 0x22u);
      }
      goto LABEL_80;
    }
    v5 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "objectForKeyedSubscript:", CFSTR("appletIdentifier")));
    if (!v5 || (v6 = objc_opt_class(NSString), (objc_opt_isKindOfClass(v5, v6) & 1) == 0))
    {
      v52 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v53 = NFLogGetLogger(v52);
      if (v53)
      {
        v54 = (void (*)(uint64_t, const char *, ...))v53;
        v55 = object_getClass(*(id *)(a1 + 40));
        v56 = class_isMetaClass(v55);
        v57 = object_getClassName(*(id *)(a1 + 40));
        v113 = sel_getName(*(SEL *)(a1 + 48));
        v58 = 45;
        if (v56)
          v58 = 43;
        v54(3, "%c[%{public}s %{public}s]:%i appletIdentifier missing or not NSString!!", v58, v57, v113, 86);
      }
      v59 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v60 = NFSharedLogGetLogger(v59);
      v7 = objc_claimAutoreleasedReturnValue(v60);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        v61 = object_getClass(*(id *)(a1 + 40));
        if (class_isMetaClass(v61))
          v62 = 43;
        else
          v62 = 45;
        v63 = object_getClassName(*(id *)(a1 + 40));
        v64 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)buf = 67109890;
        v118 = v62;
        v119 = 2082;
        v120 = v63;
        v121 = 2082;
        v122 = v64;
        v123 = 1024;
        v124 = 86;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i appletIdentifier missing or not NSString!!", buf, 0x22u);
      }
      goto LABEL_79;
    }
    v7 = v3;
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSData NF_dataWithHexString:](NSData, "NF_dataWithHexString:", v5));
    if (v8)
    {
      if (-[NSObject isEqualToString:](v7, "isEqualToString:", CFSTR("StartEvent")))
      {
        v9 = -[NFContactlessPaymentStartEvent initWithDictionary:]([NFContactlessPaymentStartEvent alloc], "initWithDictionary:", *(_QWORD *)(a1 + 32));
        if (v9)
        {
          v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v11 = NFLogGetLogger(v10);
          if (v11)
          {
            v12 = (void (*)(uint64_t, const char *, ...))v11;
            v13 = object_getClass(*(id *)(a1 + 40));
            v14 = class_isMetaClass(v13);
            v107 = object_getClassName(*(id *)(a1 + 40));
            v110 = sel_getName(*(SEL *)(a1 + 48));
            v15 = 45;
            if (v14)
              v15 = 43;
            v12(6, "%c[%{public}s %{public}s]:%i %@", v15, v107, v110, 103, v9);
          }
          v16 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v17 = NFSharedLogGetLogger(v16);
          v18 = objc_claimAutoreleasedReturnValue(v17);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
          {
            v19 = object_getClass(*(id *)(a1 + 40));
            if (class_isMetaClass(v19))
              v20 = 43;
            else
              v20 = 45;
            v21 = object_getClassName(*(id *)(a1 + 40));
            v22 = sel_getName(*(SEL *)(a1 + 48));
            *(_DWORD *)buf = 67110146;
            v118 = v20;
            v119 = 2082;
            v120 = v21;
            v121 = 2082;
            v122 = v22;
            v123 = 1024;
            v124 = 103;
            v125 = 2112;
            v126 = v9;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %@", buf, 0x2Cu);
          }

          v23 = sub_1000CE5D8(*(void **)(a1 + 40), v8, *(void **)(a1 + 32), v9);
          v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
          WeakRetained = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 40) + 40));
          objc_msgSend(WeakRetained, "handleTransactionStartEvent:atlData:caData:", v9, *(_QWORD *)(a1 + 32), v24);
LABEL_67:

          goto LABEL_78;
        }
        goto LABEL_78;
      }
      if (-[NSObject isEqualToString:](v7, "isEqualToString:", CFSTR("EndEvent")))
      {
        v9 = -[NFContactlessPaymentEndEvent initWithDictionary:]([NFContactlessPaymentEndEvent alloc], "initWithDictionary:", *(_QWORD *)(a1 + 32));
        if (v9)
        {
          v81 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v82 = NFLogGetLogger(v81);
          if (v82)
          {
            v83 = (void (*)(uint64_t, const char *, ...))v82;
            v84 = object_getClass(*(id *)(a1 + 40));
            v85 = class_isMetaClass(v84);
            v108 = object_getClassName(*(id *)(a1 + 40));
            v115 = sel_getName(*(SEL *)(a1 + 48));
            v86 = 45;
            if (v85)
              v86 = 43;
            v83(6, "%c[%{public}s %{public}s]:%i %@", v86, v108, v115, 114, v9);
          }
          v87 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v88 = NFSharedLogGetLogger(v87);
          v89 = objc_claimAutoreleasedReturnValue(v88);
          if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
          {
            v90 = object_getClass(*(id *)(a1 + 40));
            if (class_isMetaClass(v90))
              v91 = 43;
            else
              v91 = 45;
            v92 = object_getClassName(*(id *)(a1 + 40));
            v93 = sel_getName(*(SEL *)(a1 + 48));
            *(_DWORD *)buf = 67110146;
            v118 = v91;
            v119 = 2082;
            v120 = v92;
            v121 = 2082;
            v122 = v93;
            v123 = 1024;
            v124 = 114;
            v125 = 2112;
            v126 = v9;
            _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %@", buf, 0x2Cu);
          }

          v94 = sub_1000CEA1C(*(_QWORD *)(a1 + 40), v8, *(void **)(a1 + 32), v9);
          v24 = (void *)objc_claimAutoreleasedReturnValue(v94);
          WeakRetained = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 40) + 40));
          objc_msgSend(WeakRetained, "handleTransactionEndEvent:atlData:caData:", v9, *(_QWORD *)(a1 + 32), v24);
          goto LABEL_67;
        }
LABEL_78:

LABEL_79:
LABEL_80:

        goto LABEL_81;
      }
      v95 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v96 = NFLogGetLogger(v95);
      if (v96)
      {
        v97 = (void (*)(uint64_t, const char *, ...))v96;
        v98 = object_getClass(*(id *)(a1 + 40));
        v99 = class_isMetaClass(v98);
        v109 = object_getClassName(*(id *)(a1 + 40));
        v116 = sel_getName(*(SEL *)(a1 + 48));
        v100 = 45;
        if (v99)
          v100 = 43;
        v97(3, "%c[%{public}s %{public}s]:%i Unexpected event: %@", v100, v109, v116, 121, v7);
      }
      v101 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v102 = NFSharedLogGetLogger(v101);
      v9 = (NFContactlessPaymentStartEvent *)objc_claimAutoreleasedReturnValue(v102);
      if (!os_log_type_enabled(&v9->super, OS_LOG_TYPE_ERROR))
        goto LABEL_78;
      v103 = object_getClass(*(id *)(a1 + 40));
      if (class_isMetaClass(v103))
        v104 = 43;
      else
        v104 = 45;
      v105 = object_getClassName(*(id *)(a1 + 40));
      v106 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)buf = 67110146;
      v118 = v104;
      v119 = 2082;
      v120 = v105;
      v121 = 2082;
      v122 = v106;
      v123 = 1024;
      v124 = 121;
      v125 = 2112;
      v126 = (NFContactlessPaymentStartEvent *)v7;
      v78 = "%c[%{public}s %{public}s]:%i Unexpected event: %@";
      p_super = &v9->super;
      v80 = 44;
    }
    else
    {
      v65 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v66 = NFLogGetLogger(v65);
      if (v66)
      {
        v67 = (void (*)(uint64_t, const char *, ...))v66;
        v68 = object_getClass(*(id *)(a1 + 40));
        v69 = class_isMetaClass(v68);
        v70 = object_getClassName(*(id *)(a1 + 40));
        v114 = sel_getName(*(SEL *)(a1 + 48));
        v71 = 45;
        if (v69)
          v71 = 43;
        v67(3, "%c[%{public}s %{public}s]:%i Failed to convert appletIdentifier to NSData!!", v71, v70, v114, 95);
      }
      v72 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v73 = NFSharedLogGetLogger(v72);
      v9 = (NFContactlessPaymentStartEvent *)objc_claimAutoreleasedReturnValue(v73);
      if (!os_log_type_enabled(&v9->super, OS_LOG_TYPE_ERROR))
        goto LABEL_78;
      v74 = object_getClass(*(id *)(a1 + 40));
      if (class_isMetaClass(v74))
        v75 = 43;
      else
        v75 = 45;
      v76 = object_getClassName(*(id *)(a1 + 40));
      v77 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)buf = 67109890;
      v118 = v75;
      v119 = 2082;
      v120 = v76;
      v121 = 2082;
      v122 = v77;
      v123 = 1024;
      v124 = 95;
      v78 = "%c[%{public}s %{public}s]:%i Failed to convert appletIdentifier to NSData!!";
      p_super = &v9->super;
      v80 = 34;
    }
    _os_log_impl((void *)&_mh_execute_header, p_super, OS_LOG_TYPE_ERROR, v78, buf, v80);
    goto LABEL_78;
  }
  v39 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v40 = NFLogGetLogger(v39);
  if (v40)
  {
    v41 = (void (*)(uint64_t, const char *, ...))v40;
    v42 = object_getClass(*(id *)(a1 + 40));
    v43 = class_isMetaClass(v42);
    v44 = object_getClassName(*(id *)(a1 + 40));
    v112 = sel_getName(*(SEL *)(a1 + 48));
    v45 = 45;
    if (v43)
      v45 = 43;
    v41(3, "%c[%{public}s %{public}s]:%i Event is nil!", v45, v44, v112, 73);
  }
  v46 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v47 = NFSharedLogGetLogger(v46);
  v3 = objc_claimAutoreleasedReturnValue(v47);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    v48 = object_getClass(*(id *)(a1 + 40));
    if (class_isMetaClass(v48))
      v49 = 43;
    else
      v49 = 45;
    v50 = object_getClassName(*(id *)(a1 + 40));
    v51 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)buf = 67109890;
    v118 = v49;
    v119 = 2082;
    v120 = v50;
    v121 = 2082;
    v122 = v51;
    v123 = 1024;
    v124 = 73;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Event is nil!", buf, 0x22u);
  }
LABEL_81:

}

NSMutableDictionary *sub_1000CE5D8(void *a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  NSMutableDictionary *v10;
  id v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  id v16;
  void *v17;
  id v18;
  void *v19;
  id v20;
  void *v21;
  void *v22;
  unsigned int v23;
  unsigned __int16 *v24;
  void *v25;
  unsigned int v26;
  void *v27;
  unsigned int v28;
  void *v29;
  id v30;
  void *v31;
  unsigned int v32;
  void *v33;
  id v34;
  void *v35;
  unsigned int v36;
  void *v37;
  void *v38;
  unsigned int v39;
  void *v40;
  void *v41;
  void *v43;
  uint64_t v44;
  int isKindOfClass;
  void *v46;
  void *v47;
  uint64_t v48;

  v7 = a3;
  if (!a1)
  {
    v10 = 0;
    goto LABEL_14;
  }
  v48 = 0;
  v8 = a4;
  v9 = a2;
  v10 = objc_opt_new(NSMutableDictionary);
  v11 = objc_msgSend(v8, "selectStatus");

  v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", v11));
  -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v12, CFSTR("commandResult"));

  v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "delegate"));
  v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "NF_asHexString"));

  v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "appletForIdentifier:filtered:", v14, 1));
  v16 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_100269D1B, 10);
  v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "NF_asHexString"));

  v18 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_100269D25, 8);
  v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "NF_asHexString"));

  v20 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_100269D2D, 16);
  v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "NF_asHexString"));

  v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "moduleIdentifier"));
  v23 = objc_msgSend(v22, "isEqualToString:", v17);

  if (v23)
  {
    v24 = (unsigned __int16 *)&unk_100269D3E;
    v25 = v7;
    v26 = 57;
LABEL_12:
    sub_1000CFE04(v25, v24, v26, (unsigned int *)&v48 + 1, (unsigned int *)&v48);
    goto LABEL_13;
  }
  v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "moduleIdentifier"));
  v28 = objc_msgSend(v27, "isEqualToString:", v19);

  if (v28)
  {
    v24 = (unsigned __int16 *)&unk_100269F06;
    v25 = v7;
    v26 = 53;
    goto LABEL_12;
  }
  v47 = v7;
  v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "moduleIdentifier"));
  v30 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A0AE, 12);
  v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "NF_asHexString"));
  v32 = objc_msgSend(v29, "isEqualToString:", v31);

  if (v32)
  {
    v24 = (unsigned __int16 *)&unk_10026A0BA;
    v7 = v47;
    v25 = v47;
    v26 = 45;
    goto LABEL_12;
  }
  v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "moduleIdentifier"));
  v34 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A3A4, 16);
  v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v34, "NF_asHexString"));
  v36 = objc_msgSend(v33, "isEqualToString:", v35);

  if (!v36)
  {
    v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "moduleIdentifier"));
    v39 = objc_msgSend(v38, "isEqualToString:", v21);

    if (!v39)
    {
      v7 = v47;
      v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v47, "objectForKeyedSubscript:", CFSTR("command")));
      v44 = objc_opt_class(NSNumber);
      isKindOfClass = objc_opt_isKindOfClass(v43, v44);

      if ((isKindOfClass & 1) != 0)
      {
        v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v47, "objectForKeyedSubscript:", CFSTR("command")));
        HIDWORD(v48) = objc_msgSend(v46, "intValue");

      }
      LODWORD(v48) = 0;
      goto LABEL_13;
    }
    v24 = (unsigned __int16 *)&unk_10026A3B4;
    v7 = v47;
    v25 = v47;
    v26 = 6;
    goto LABEL_12;
  }
  v7 = v47;
  v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v47, "objectForKeyedSubscript:", CFSTR("command")));
  HIDWORD(v48) = objc_msgSend(v37, "intValue");

  LODWORD(v48) = 0;
LABEL_13:
  v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", HIDWORD(v48)));
  -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v40, CFSTR("command"));

  v41 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v48));
  -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v41, CFSTR("commandParam1"));

LABEL_14:
  return v10;
}

NSMutableDictionary *sub_1000CEA1C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  NSMutableDictionary *v10;
  void *v11;
  void *v12;
  void *v13;
  id v14;
  uint64_t v15;
  id v16;
  uint64_t v17;
  id v18;
  void *v19;
  unsigned __int16 *v20;
  void *v21;
  unsigned int v22;
  void *v23;
  unsigned int v24;
  void *v25;
  id v26;
  void *v27;
  unsigned int v28;
  void *v29;
  id v30;
  void *v31;
  unsigned int v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  void *v46;
  void *v47;
  void *v48;
  void *v49;
  void *v50;
  void *v51;
  void *v52;
  void *v53;
  void *v54;
  void *v55;
  void *v56;
  void *v57;
  void *v58;
  void *v59;
  void *v60;
  void *v61;
  void *v62;
  void *v63;
  void *v64;
  void *v65;
  uint64_t v66;
  void *v67;
  void *v68;
  uint64_t v69;
  char v70;
  void *v71;
  void *v72;
  id v73;
  id v74;
  unsigned __int8 *v75;
  void *v76;
  void *v77;
  void *v78;
  void *v79;
  void *v80;
  void *v81;
  void *v82;
  void *v83;
  void *v84;
  void *v85;
  void *v86;
  void *v88;
  id v89;
  void *v90;
  unsigned int v91;
  void *v92;
  void *v93;
  unsigned int v94;
  void *v95;
  unsigned int v96;
  id v97;
  void *v98;
  id v99;
  void *v100;
  void *v101;
  void *v102;
  void *v103;
  uint64_t v104;
  int isKindOfClass;
  uint64_t v106;
  void *v107;
  void *v108;
  void *v109;
  void *v110;
  int v111;
  uint64_t v112;

  v7 = a3;
  v8 = a4;
  if (!a1)
  {
    v10 = 0;
    goto LABEL_44;
  }
  v112 = 0;
  v9 = a2;
  v10 = objc_opt_new(NSMutableDictionary);
  v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "delegate"));
  v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "NF_asHexString"));

  v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "appletForIdentifier:filtered:", v12, 1));
  v14 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_100269D1B, 10);
  v15 = objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "NF_asHexString"));

  v16 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_100269D25, 8);
  v17 = objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "NF_asHexString"));

  v18 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_100269D2D, 16);
  v110 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "NF_asHexString"));

  v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "moduleIdentifier"));
  LODWORD(v12) = objc_msgSend(v19, "isEqualToString:", v15);

  v106 = v17;
  v108 = (void *)v15;
  if ((_DWORD)v12)
  {
    v20 = (unsigned __int16 *)&unk_100269D3E;
    v21 = v7;
    v22 = 57;
LABEL_10:
    sub_1000CFE04(v21, v20, v22, (unsigned int *)&v112 + 1, (unsigned int *)&v112);
    goto LABEL_11;
  }
  v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "moduleIdentifier", v17, v15));
  v24 = objc_msgSend(v23, "isEqualToString:", v17);

  if (v24)
  {
    v20 = (unsigned __int16 *)&unk_100269F06;
    v21 = v7;
    v22 = 53;
    goto LABEL_10;
  }
  v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "moduleIdentifier"));
  v26 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A0AE, 12);
  v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v26, "NF_asHexString"));
  v28 = objc_msgSend(v25, "isEqualToString:", v27);

  if (v28)
  {
    v20 = (unsigned __int16 *)&unk_10026A0BA;
    v21 = v7;
    v22 = 45;
    goto LABEL_10;
  }
  v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "moduleIdentifier"));
  v30 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A222, 10);
  v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "NF_asHexString"));
  v32 = objc_msgSend(v29, "isEqualToString:", v31);

  if (v32)
  {
    v20 = (unsigned __int16 *)&unk_10026A22C;
    v21 = v7;
    v22 = 47;
    goto LABEL_10;
  }
  v88 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "moduleIdentifier"));
  v89 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A3A4, 16);
  v90 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v89, "NF_asHexString"));
  v91 = objc_msgSend(v88, "isEqualToString:", v90);

  if (v91)
    goto LABEL_46;
  v93 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "moduleIdentifier"));
  v94 = objc_msgSend(v93, "isEqualToString:", v110);

  if (v94)
  {
    v95 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "moduleIdentifier"));
    v96 = objc_msgSend(v95, "isEqualToString:", v110);

    if (v96)
      sub_1000CFE04(v7, word_10026A3B4, 6u, (unsigned int *)&v112 + 1, (unsigned int *)&v112);
    v111 = 0;
    v97 = sub_1001FBCC0(*(_QWORD *)(a1 + 32));
    v98 = (void *)objc_claimAutoreleasedReturnValue(v97);
    if (objc_msgSend(v98, "notificationType") == (id)3)
    {
      v99 = v98;
      v100 = (void *)objc_claimAutoreleasedReturnValue(+[NFCALogger sharedCALogger](NFCALogger, "sharedCALogger"));
      v101 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v99, "tciArray"));
      objc_msgSend(v100, "getCAUniversityCode:universityCodes:", v101, &v111);

      if (v111)
      {
        v102 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:"));
        -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v102, CFSTR("accessUniversityCode"));

      }
    }

    goto LABEL_11;
  }
  v103 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", CFSTR("command")));
  v104 = objc_opt_class(NSNumber);
  isKindOfClass = objc_opt_isKindOfClass(v103, v104);

  if ((isKindOfClass & 1) != 0)
  {
LABEL_46:
    v92 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", CFSTR("command")));
    HIDWORD(v112) = objc_msgSend(v92, "intValue");

  }
  LODWORD(v112) = 0;
LABEL_11:
  -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", &off_1002FECD0, CFSTR("version"), v106);
  v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", objc_msgSend(v8, "status")));
  -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v33, CFSTR("status"));

  v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", HIDWORD(v112)));
  -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v34, CFSTR("command"));

  v35 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v112));
  -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v35, CFSTR("commandParam1"));

  v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", objc_msgSend(v8, "result")));
  -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v36, CFSTR("result"));

  v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", objc_msgSend(v8, "informative")));
  -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v37, CFSTR("informative"));

  v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "appletIdentifier"));
  v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSData NF_dataWithHexString:](NSData, "NF_dataWithHexString:", v38));

  if (v39)
    -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v39, CFSTR("aid"));
  v109 = v13;
  v40 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "transactionIdentifier"));
  v41 = (void *)objc_claimAutoreleasedReturnValue(+[NSData NF_dataWithHexString:](NSData, "NF_dataWithHexString:", v40));

  if (v41)
    -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v41, CFSTR("transactionId"));
  v42 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 8)));
  -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v42, CFSTR("totalRSSISamples"));

  v43 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 12)));
  -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v43, CFSTR("avgRSSIValue"));

  v44 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 16)));
  -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v44, CFSTR("maxRSSIValue"));

  v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 20)));
  -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v45, CFSTR("minRSSIValue"));

  v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "parsedInfo"));
  v47 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v46, "objectForKeyedSubscript:", CFSTR("Transaction")));

  v48 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "parsedInfo"));
  v49 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v48, "objectForKeyedSubscript:", CFSTR("State")));

  v50 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v49, "objectForKeyedSubscript:", CFSTR("SPRaw")));
  if (v50)
  {
    v51 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v49, "objectForKeyedSubscript:", CFSTR("SPRaw")));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v51, CFSTR("SPRaw"));

  }
  v52 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v49, "objectForKeyedSubscript:", CFSTR("CardDenyListed")));

  if (v52)
  {
    v53 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v49, "objectForKeyedSubscript:", CFSTR("CardDenyListed")));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v53, CFSTR("CardBlacklisted"));

  }
  v54 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v49, "objectForKeyedSubscript:", CFSTR("CardExpirationDate")));

  if (v54)
  {
    v55 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v49, "objectForKeyedSubscript:", CFSTR("CardExpirationDate")));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v55, CFSTR("CardExpirationDate"));

  }
  v56 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v49, "objectForKeyedSubscript:", CFSTR("TransactionInProgress")));

  if (v56)
  {
    v57 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v49, "objectForKeyedSubscript:", CFSTR("TransactionInProgress")));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v57, CFSTR("TransactionInProgress"));

  }
  v58 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v49, "objectForKeyedSubscript:", CFSTR("CardCurrencyCode")));

  if (v58)
  {
    v59 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v49, "objectForKeyedSubscript:", CFSTR("CardCurrencyCode")));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v59, CFSTR("CardCurrencyCode"));

  }
  v60 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v47, "objectForKeyedSubscript:", CFSTR("StartStation")));

  if (v60)
  {
    v61 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v47, "objectForKeyedSubscript:", CFSTR("StartStation")));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v61, CFSTR("StartStation"));

  }
  v62 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v47, "objectForKeyedSubscript:", CFSTR("EndStation")));

  if (v62)
  {
    v63 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v47, "objectForKeyedSubscript:", CFSTR("EndStation")));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v63, CFSTR("EndStation"));

  }
  v64 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v47, "objectForKeyedSubscript:", CFSTR("TerminalIdentifier")));

  if (v64)
  {
    v65 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v47, "objectForKeyedSubscript:", CFSTR("TerminalIdentifier")));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v65, CFSTR("TerminalIdentifier"));

  }
  v66 = objc_claimAutoreleasedReturnValue(objc_msgSend(v47, "objectForKeyedSubscript:", CFSTR("TypeDetailRaw")));
  if (v66)
  {
    v67 = (void *)v66;
    v68 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v47, "objectForKeyedSubscript:", CFSTR("TypeDetailRaw")));
    v69 = objc_opt_class(NSData);
    v70 = objc_opt_isKindOfClass(v68, v69);

    if ((v70 & 1) != 0)
    {
      v71 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v47, "objectForKeyedSubscript:", CFSTR("TypeDetailRaw")));
      -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v71, CFSTR("transactionTypeRaw"));

      v72 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v47, "objectForKeyedSubscript:", CFSTR("TypeDetailRaw")));
      v73 = objc_msgSend(v72, "length");

      if ((unint64_t)v73 >= 3)
      {
        v74 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(v47, "objectForKeyedSubscript:", CFSTR("TypeDetailRaw"))));
        v75 = (unsigned __int8 *)objc_msgSend(v74, "bytes");

        v76 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", *v75));
        -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v76, CFSTR("transactionCategory"));

        v77 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", v75[1]));
        -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v77, CFSTR("transactionType"));

        v78 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", v75[2]));
        -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v78, CFSTR("transactionExtension"));

      }
    }
  }
  v79 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v49, "objectForKeyedSubscript:", CFSTR("SPRaw")));

  if (v79)
  {
    v80 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v49, "objectForKeyedSubscript:", CFSTR("SPRaw")));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v80, CFSTR("issuerCityCode"));

  }
  v81 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", CFSTR("interface")));

  if (v81)
  {
    v82 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", CFSTR("interface")));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v82, CFSTR("interface"));

  }
  v83 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", CFSTR("ReadOperationInfo")));

  if (v83)
  {
    v84 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", CFSTR("ReadOperationInfo")));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v84, CFSTR("ReadOperationInfo"));

  }
  v85 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", CFSTR("WriteOperationInfo")));

  if (v85)
  {
    v86 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", CFSTR("WriteOperationInfo")));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v86, CFSTR("WriteOperationInfo"));

  }
LABEL_44:

  return v10;
}

void sub_1000CF870(_QWORD *a1, void *a2)
{
  id v3;
  void *v4;
  id v5;
  char *v6;
  void *v7;
  uint64_t v8;
  void (*v9)(uint64_t, const char *, ...);
  objc_class *v10;
  _BOOL4 v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  NSObject *v15;
  objc_class *v16;
  int v17;
  uint64_t v18;
  id v19;
  id v20;
  uint64_t v21;
  void *i;
  void *v23;
  void *specific;
  uint64_t Logger;
  void (*v26)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  NSObject *v35;
  objc_class *v36;
  int v37;
  const char *v38;
  const char *v39;
  void *v40;
  void *v41;
  uint64_t v42;
  void (*v43)(uint64_t, const char *, ...);
  objc_class *v44;
  NSObject *v45;
  _BOOL4 v46;
  BOOL v47;
  uint64_t v48;
  void *v49;
  uint64_t v50;
  NSObject *v51;
  objc_class *v52;
  int v53;
  const char *v54;
  const char *v55;
  const char *v56;
  const char *v57;
  const char *v58;
  const char *v59;
  NSObject *v60;
  void *v61;
  id obj;
  void *v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  uint8_t buf[4];
  int v69;
  __int16 v70;
  const char *v71;
  __int16 v72;
  const char *v73;
  __int16 v74;
  int v75;
  __int16 v76;
  id v77;
  __int16 v78;
  void *v79;
  _BYTE v80[128];

  v3 = a2;
  v4 = v3;
  if (a1)
  {
    v5 = objc_retainAutorelease(v3);
    v6 = (char *)objc_msgSend(v5, "bytes");
    if ((unint64_t)objc_msgSend(v5, "length") > 2)
    {
      v15 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", v6 + 2, (char *)objc_msgSend(v5, "length") - 2);
      v63 = (void *)objc_claimAutoreleasedReturnValue(+[NFFelicaStateEvent decodeLogEvent:](NFFelicaStateEvent, "decodeLogEvent:", v15));
      v18 = a1[4];
      if (v18 && (*(_QWORD *)(v18 + 272) & 0x203) != 0)
      {
        v60 = v15;
        v61 = v4;
        v66 = 0u;
        v67 = 0u;
        v64 = 0u;
        v65 = 0u;
        obj = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v63, "allKeys"));
        v19 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v64, v80, 16);
        if (v19)
        {
          v20 = v19;
          v21 = *(_QWORD *)v65;
          do
          {
            for (i = 0; i != v20; i = (char *)i + 1)
            {
              if (*(_QWORD *)v65 != v21)
                objc_enumerationMutation(obj);
              v23 = *(void **)(*((_QWORD *)&v64 + 1) + 8 * (_QWORD)i);
              specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              Logger = NFLogGetLogger(specific);
              if (Logger)
              {
                v26 = (void (*)(uint64_t, const char *, ...))Logger;
                Class = object_getClass(a1);
                isMetaClass = class_isMetaClass(Class);
                ClassName = object_getClassName(a1);
                Name = sel_getName("_decodeFelicaLoggingEvent:");
                v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v63, "objectForKeyedSubscript:", v23));
                v32 = 45;
                if (isMetaClass)
                  v32 = 43;
                v26(5, "%c[%{public}s %{public}s]:%i [L-ICF] %{public}@ = %{public}@", v32, ClassName, Name, 234, v23, v31);

              }
              v33 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v34 = NFSharedLogGetLogger(v33);
              v35 = objc_claimAutoreleasedReturnValue(v34);
              if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
              {
                v36 = object_getClass(a1);
                if (class_isMetaClass(v36))
                  v37 = 43;
                else
                  v37 = 45;
                v38 = object_getClassName(a1);
                v39 = sel_getName("_decodeFelicaLoggingEvent:");
                v40 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v63, "objectForKeyedSubscript:", v23));
                *(_DWORD *)buf = 67110402;
                v69 = v37;
                v70 = 2082;
                v71 = v38;
                v72 = 2082;
                v73 = v39;
                v74 = 1024;
                v75 = 234;
                v76 = 2114;
                v77 = v23;
                v78 = 2114;
                v79 = v40;
                _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i [L-ICF] %{public}@ = %{public}@", buf, 0x36u);

              }
            }
            v20 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v64, v80, 16);
          }
          while (v20);
        }

        v15 = v60;
        v4 = v61;
      }
      v41 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v42 = NFLogGetLogger(v41);
      if (v42)
      {
        v43 = (void (*)(uint64_t, const char *, ...))v42;
        v44 = object_getClass(a1);
        v45 = v15;
        v46 = class_isMetaClass(v44);
        v57 = object_getClassName(a1);
        v59 = sel_getName("_decodeFelicaLoggingEvent:");
        v47 = !v46;
        v15 = v45;
        v48 = 45;
        if (!v47)
          v48 = 43;
        v43(6, "%c[%{public}s %{public}s]:%i %{public}@", v48, v57, v59, 237, v63);
      }
      v49 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v50 = NFSharedLogGetLogger(v49);
      v51 = objc_claimAutoreleasedReturnValue(v50);
      if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
      {
        v52 = object_getClass(a1);
        if (class_isMetaClass(v52))
          v53 = 43;
        else
          v53 = 45;
        v54 = object_getClassName(a1);
        v55 = sel_getName("_decodeFelicaLoggingEvent:");
        *(_DWORD *)buf = 67110146;
        v69 = v53;
        v70 = 2082;
        v71 = v54;
        v72 = 2082;
        v73 = v55;
        v74 = 1024;
        v75 = 237;
        v76 = 2114;
        v77 = v63;
        _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
      }

    }
    else
    {
      v7 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v8 = NFLogGetLogger(v7);
      if (v8)
      {
        v9 = (void (*)(uint64_t, const char *, ...))v8;
        v10 = object_getClass(a1);
        v11 = class_isMetaClass(v10);
        v56 = object_getClassName(a1);
        v58 = sel_getName("_decodeFelicaLoggingEvent:");
        v12 = 45;
        if (v11)
          v12 = 43;
        v9(3, "%c[%{public}s %{public}s]:%i Unexpected HCI event: %{public}@", v12, v56, v58, 226, v5);
      }
      v13 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v14 = NFSharedLogGetLogger(v13);
      v15 = objc_claimAutoreleasedReturnValue(v14);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        v16 = object_getClass(a1);
        if (class_isMetaClass(v16))
          v17 = 43;
        else
          v17 = 45;
        *(_DWORD *)buf = 67110146;
        v69 = v17;
        v70 = 2082;
        v71 = object_getClassName(a1);
        v72 = 2082;
        v73 = sel_getName("_decodeFelicaLoggingEvent:");
        v74 = 1024;
        v75 = 226;
        v76 = 2114;
        v77 = v5;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unexpected HCI event: %{public}@", buf, 0x2Cu);
      }
    }

  }
}

uint64_t sub_1000CFE04(void *a1, unsigned __int16 *a2, unsigned int a3, unsigned int *a4, unsigned int *a5)
{
  id v9;
  void *v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  int v16;
  int v18;
  uint64_t v20;

  v9 = a1;
  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("command")));
  v11 = objc_msgSend(v10, "intValue");

  v12 = 0;
  v13 = HIWORD(v11);
  *a4 = v11;
  *a5 = v11;
  v14 = v11 >> 8;
  do
  {
    if (v13 == *a2)
    {
      if (v12 < a3)
      {
        while (v13 == *a2)
        {
          v15 = a2[1];
          if (v15 == 0xFFFF)
          {
            v18 = a2[2];
            if (v18 == 0xFFFF || v11 == v18)
            {
              *a4 = *((unsigned __int8 *)a2 + 6);
              switch(*((_BYTE *)a2 + 7))
              {
                case 1:
                case 3:
LABEL_24:
                  LOBYTE(v14) = v11;
                  break;
                case 2:
                case 4:
                  goto LABEL_26;
                default:
LABEL_25:
                  LOBYTE(v14) = 0;
                  break;
              }
              goto LABEL_26;
            }
          }
          else if (BYTE1(v11) == v15)
          {
            v16 = a2[2];
            if (v16 == 0xFFFF || v11 == v16)
            {
              *a4 = *((unsigned __int8 *)a2 + 6);
              switch(*((_BYTE *)a2 + 7))
              {
                case 1:
                case 3:
                  goto LABEL_24;
                case 2:
                case 4:
                  break;
                default:
                  goto LABEL_25;
              }
LABEL_26:
              *a5 = v14;
              v20 = 1;
              goto LABEL_27;
            }
          }
          ++v12;
          a2 += 4;
          if (v12 >= a3)
            goto LABEL_21;
        }
      }
    }
    else
    {
      ++v12;
      a2 += 4;
    }
  }
  while (v12 < a3);
LABEL_21:
  v20 = 0;
LABEL_27:

  return v20;
}

NSMutableDictionary *sub_1000CFF90(void *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  void *v7;
  void *v8;
  void *v9;
  id v10;
  void *v11;
  id v12;
  void *v13;
  void *v14;
  unsigned int v15;
  void *specific;
  uint64_t Logger;
  void (*v18)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  NSObject *v25;
  objc_class *v26;
  int v27;
  const char *v28;
  const char *v29;
  void *v30;
  unsigned int v31;
  void *v32;
  uint64_t v33;
  void (*v34)(uint64_t, const char *, ...);
  objc_class *v35;
  _BOOL4 v36;
  const char *v37;
  uint64_t v38;
  void *v39;
  uint64_t v40;
  objc_class *v41;
  int v42;
  const char *v43;
  const char *v44;
  NSMutableDictionary *v45;
  void *v46;
  void *v47;
  void *v48;
  void *v49;
  void *v50;
  void *v51;
  void *v52;
  void *v53;
  const char *Name;
  const char *v56;
  uint64_t v57;
  uint8_t buf[4];
  int v59;
  __int16 v60;
  const char *v61;
  __int16 v62;
  const char *v63;
  __int16 v64;
  int v65;

  v5 = a3;
  v57 = 0;
  v6 = a2;
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "delegate"));
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "NF_asHexString"));

  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "appletForIdentifier:filtered:", v8, 1));
  v10 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_100269D1B, 10);
  v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "NF_asHexString"));

  v12 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_100269D25, 8);
  v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "NF_asHexString"));

  v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "moduleIdentifier"));
  v15 = objc_msgSend(v14, "isEqualToString:", v11);

  if (v15)
  {
    if ((sub_1000CFE04(v5, word_100269D3E, 0x39u, (unsigned int *)&v57 + 1, (unsigned int *)&v57) & 1) == 0)
    {
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v18 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(a1);
        Name = sel_getName("_caHCIActivityTimeoutEvent:parsedEvent:");
        v22 = 45;
        if (isMetaClass)
          v22 = 43;
        v18(6, "%c[%{public}s %{public}s]:%i Could not find Enum. Defaulting to CLA_INS_P1_P2 format ", v22, ClassName, Name, 509);
      }
      v23 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v24 = NFSharedLogGetLogger(v23);
      v25 = objc_claimAutoreleasedReturnValue(v24);
      if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        goto LABEL_24;
      v26 = object_getClass(a1);
      if (class_isMetaClass(v26))
        v27 = 43;
      else
        v27 = 45;
      v28 = object_getClassName(a1);
      v29 = sel_getName("_caHCIActivityTimeoutEvent:parsedEvent:");
      *(_DWORD *)buf = 67109890;
      v59 = v27;
      v60 = 2082;
      v61 = v28;
      v62 = 2082;
      v63 = v29;
      v64 = 1024;
      v65 = 509;
LABEL_23:
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Could not find Enum. Defaulting to CLA_INS_P1_P2 format ", buf, 0x22u);
LABEL_24:

    }
  }
  else
  {
    v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "moduleIdentifier"));
    v31 = objc_msgSend(v30, "isEqualToString:", v13);

    if (v31 && (sub_1000CFE04(v5, word_100269F06, 0x35u, (unsigned int *)&v57 + 1, (unsigned int *)&v57) & 1) == 0)
    {
      v32 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v33 = NFLogGetLogger(v32);
      if (v33)
      {
        v34 = (void (*)(uint64_t, const char *, ...))v33;
        v35 = object_getClass(a1);
        v36 = class_isMetaClass(v35);
        v37 = object_getClassName(a1);
        v56 = sel_getName("_caHCIActivityTimeoutEvent:parsedEvent:");
        v38 = 45;
        if (v36)
          v38 = 43;
        v34(6, "%c[%{public}s %{public}s]:%i Could not find Enum. Defaulting to CLA_INS_P1_P2 format ", v38, v37, v56, 518);
      }
      v39 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v40 = NFSharedLogGetLogger(v39);
      v25 = objc_claimAutoreleasedReturnValue(v40);
      if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        goto LABEL_24;
      v41 = object_getClass(a1);
      if (class_isMetaClass(v41))
        v42 = 43;
      else
        v42 = 45;
      v43 = object_getClassName(a1);
      v44 = sel_getName("_caHCIActivityTimeoutEvent:parsedEvent:");
      *(_DWORD *)buf = 67109890;
      v59 = v42;
      v60 = 2082;
      v61 = v43;
      v62 = 2082;
      v63 = v44;
      v64 = 1024;
      v65 = 518;
      goto LABEL_23;
    }
  }
  v45 = objc_opt_new(NSMutableDictionary);
  v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("spid")));
  v47 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", objc_msgSend(v46, "intValue")));
  -[NSMutableDictionary setObject:forKeyedSubscript:](v45, "setObject:forKeyedSubscript:", v47, CFSTR("spid"));

  v48 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("commandResult")));
  v49 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", objc_msgSend(v48, "intValue")));
  -[NSMutableDictionary setObject:forKeyedSubscript:](v45, "setObject:forKeyedSubscript:", v49, CFSTR("commandResult"));

  v50 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", HIDWORD(v57)));
  -[NSMutableDictionary setObject:forKeyedSubscript:](v45, "setObject:forKeyedSubscript:", v50, CFSTR("command"));

  v51 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v57));
  -[NSMutableDictionary setObject:forKeyedSubscript:](v45, "setObject:forKeyedSubscript:", v51, CFSTR("commandParam1"));

  v52 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("timeoutValue")));
  v53 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", objc_msgSend(v52, "intValue")));
  -[NSMutableDictionary setObject:forKeyedSubscript:](v45, "setObject:forKeyedSubscript:", v53, CFSTR("timeoutValue"));

  return v45;
}

uint64_t sub_1000D04D4(void *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id v7;
  void *v8;
  id v9;
  void *v10;
  unsigned __int8 v11;
  void *v12;
  id v13;
  void *v14;
  void *v15;
  id v16;
  void *v17;
  void *v18;
  void *v19;
  unsigned __int8 v20;
  void *v21;
  id v22;
  void *v23;
  void *v24;
  id v25;
  void *v26;
  unsigned int v27;
  void *v28;
  id v29;
  void *v30;
  void *v31;
  id v32;
  void *v33;
  unsigned int v34;
  void *v35;
  id v36;
  void *v37;
  unsigned int v38;
  uint64_t v39;
  void *v41;
  id v42;
  void *v43;
  unsigned int v44;
  void *v45;
  unsigned __int8 v46;
  id v47;

  v5 = a1;
  v6 = a2;
  v7 = a3;
  if (!objc_msgSend(v6, "didError"))
    goto LABEL_22;
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "moduleIdentifier"));
  v9 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A3E4, 10);
  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "NF_asHexString"));
  v11 = objc_msgSend(v8, "isEqualToString:", v10);

  if ((v11 & 1) != 0)
    goto LABEL_22;
  v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "moduleIdentifier"));
  v13 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A3A4, 16);
  v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "NF_asHexString"));
  if ((objc_msgSend(v12, "isEqualToString:", v14) & 1) != 0)
    goto LABEL_6;
  v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "moduleIdentifier"));
  v16 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A3EE, 16);
  v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "NF_asHexString"));
  if ((objc_msgSend(v15, "isEqualToString:", v17) & 1) != 0)
  {

LABEL_6:
    goto LABEL_7;
  }
  v47 = v7;
  v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "moduleIdentifier"));
  v22 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A3FE, 16);
  v45 = v15;
  v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "NF_asHexString"));
  v46 = objc_msgSend(v21, "isEqualToString:", v23);

  v7 = v47;
  if ((v46 & 1) == 0)
    goto LABEL_12;
LABEL_7:
  v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", objc_msgSend(v6, "informative")));
  if (!objc_msgSend(&off_100305DE8, "containsObject:", v18))
  {
    v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", objc_msgSend(v6, "result")));
    v20 = objc_msgSend(&off_100305DD0, "containsObject:", v19);

    if ((v20 & 1) != 0)
      goto LABEL_22;
LABEL_12:
    v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "moduleIdentifier"));
    v25 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_100269D25, 8);
    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v25, "NF_asHexString"));
    if (objc_msgSend(v24, "isEqualToString:", v26))
    {
      v27 = objc_msgSend(v6, "result");

      if (v27 == 64)
        goto LABEL_22;
    }
    else
    {

    }
    v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "moduleIdentifier"));
    v29 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_100269D1B, 10);
    v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v29, "NF_asHexString"));
    if (objc_msgSend(v28, "isEqualToString:", v30))
    {

    }
    else
    {
      v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "moduleIdentifier"));
      v32 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_100269D25, 8);
      v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v32, "NF_asHexString"));
      v34 = objc_msgSend(v31, "isEqualToString:", v33);

      if (!v34)
        goto LABEL_20;
    }
    if (objc_msgSend(v6, "result") == 61444)
      goto LABEL_22;
LABEL_20:
    v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "moduleIdentifier"));
    v36 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A40E, 16);
    v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v36, "NF_asHexString"));
    if (objc_msgSend(v35, "isEqualToString:", v37))
    {
      v38 = objc_msgSend(v6, "result");

      if (v38 == 61440)
        goto LABEL_22;
    }
    else
    {

    }
    v41 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "moduleIdentifier"));
    v42 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A41E, 10);
    v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v42, "NF_asHexString"));
    v44 = objc_msgSend(v41, "isEqualToString:", v43);

    v39 = v44 ^ 1;
    goto LABEL_23;
  }

LABEL_22:
  v39 = 0;
LABEL_23:

  return v39;
}

void sub_1000D0980(void *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  void *v7;
  void *v8;
  void *v9;
  void **v10;
  const __CFString **v11;
  void *v12;
  const __CFString *v13;
  void *v14;
  const __CFString *v15;
  void *v16;

  v5 = a2;
  v6 = a3;
  if (v5)
  {
    v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("appletIdentifier")));

    if (v7)
    {
      v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("appletIdentifier")));
      if (objc_msgSend(a1, "isUnifiedAccess:", v8))
      {
        if (objc_msgSend(v6, "isEqualToString:", CFSTR("StartEvent")))
        {
          v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate now](NSDate, "now"));
          v15 = CFSTR("startEventStartTime");
          v16 = v9;
          v10 = &v16;
          v11 = &v15;
LABEL_8:
          v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v10, v11, 1));
          sub_1000A78F0((uint64_t)NFUnifiedAccessTransactionCALogger, v12, 1);

          goto LABEL_9;
        }
        if (objc_msgSend(v6, "isEqualToString:", CFSTR("StepUpRequested")))
        {
          v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate now](NSDate, "now"));
          v13 = CFSTR("stepUpEventStartTime");
          v14 = v9;
          v10 = &v14;
          v11 = &v13;
          goto LABEL_8;
        }
      }
LABEL_9:

    }
  }

}

void sub_1000D0BB0(uint64_t a1)
{
  uint64_t v2;
  void *specific;
  uint64_t Logger;
  void (*v5)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  void (*v22)(uint64_t, const char *, ...);
  objc_class *v23;
  _BOOL4 v24;
  const char *v25;
  const char *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  NSObject *v30;
  objc_class *v31;
  int v32;
  const char *v33;
  const char *v34;
  uint64_t v35;
  const char *v36;
  NSObject *v37;
  uint32_t v38;
  uint64_t v39;
  void *v40;
  id v41;
  void *v42;
  void *v43;
  __CFString *v44;
  uint64_t v45;
  void *v46;
  uint64_t v47;
  void *v48;
  void *v49;
  void *v50;
  void *v51;
  void *v52;
  char *v53;
  NSObject *v54;
  void *v55;
  uint64_t v56;
  void (*v57)(uint64_t, const char *, ...);
  objc_class *v58;
  _BOOL4 v59;
  uint64_t v60;
  void *v61;
  uint64_t v62;
  NSObject *v63;
  objc_class *v64;
  int v65;
  const char *v66;
  const char *v67;
  void *v68;
  uint64_t v69;
  void (*v70)(uint64_t, const char *, ...);
  objc_class *v71;
  _BOOL4 v72;
  uint64_t v73;
  void *v74;
  uint64_t v75;
  objc_class *v76;
  int v77;
  const char *v78;
  const char *v79;
  const char *v80;
  void *v81;
  uint64_t v82;
  void (*v83)(uint64_t, const char *, ...);
  objc_class *v84;
  _BOOL4 v85;
  uint64_t v86;
  void *v87;
  uint64_t v88;
  objc_class *v89;
  int v90;
  const char *v91;
  const char *v92;
  uint64_t v93;
  unsigned __int8 *v94;
  uint64_t v95;
  uint64_t v96;
  void *v97;
  unsigned __int8 *v98;
  BOOL v99;
  id v100;
  void *v101;
  id v102;
  void *v103;
  void *v104;
  uint64_t v105;
  void (*v106)(uint64_t, const char *, ...);
  objc_class *v107;
  _BOOL4 v108;
  uint64_t v109;
  void *v110;
  uint64_t v111;
  NSObject *v112;
  objc_class *v113;
  int v114;
  const char *v115;
  const char *v116;
  NSMutableArray *v117;
  void *v118;
  uint64_t v119;
  void (*v120)(uint64_t, const char *, ...);
  objc_class *v121;
  _BOOL4 v122;
  const char *v123;
  const char *v124;
  uint64_t v125;
  void *v126;
  uint64_t v127;
  objc_class *v128;
  int v129;
  const char *v130;
  const char *v131;
  uint64_t v132;
  uint64_t v133;
  _QWORD *v134;
  id v135;
  NSMutableArray *v136;
  char *v137;
  NSMutableArray *v138;
  void *v139;
  uint64_t v140;
  void (*v141)(uint64_t, const char *, ...);
  objc_class *v142;
  _BOOL4 v143;
  uint64_t v144;
  void *v145;
  uint64_t v146;
  NSObject *v147;
  objc_class *v148;
  int v149;
  const char *v150;
  const char *v151;
  void *v152;
  uint64_t v153;
  void (*v154)(uint64_t, const char *, ...);
  objc_class *v155;
  _BOOL4 v156;
  uint64_t v157;
  void *v158;
  uint64_t v159;
  objc_class *v160;
  int v161;
  const char *v162;
  const char *v163;
  void *v164;
  uint64_t v165;
  void (*v166)(uint64_t, const char *, ...);
  objc_class *v167;
  _BOOL4 v168;
  uint64_t v169;
  void *v170;
  uint64_t v171;
  NSObject *v172;
  objc_class *v173;
  int v174;
  const char *v175;
  const char *v176;
  void *v177;
  uint64_t v178;
  void (*v179)(uint64_t, const char *, ...);
  objc_class *v180;
  _BOOL4 v181;
  const char *v182;
  uint64_t v183;
  void *v184;
  uint64_t v185;
  NSObject *v186;
  objc_class *v187;
  int v188;
  const char *v189;
  const char *v190;
  uint64_t v191;
  void *v192;
  uint64_t v193;
  void (*v194)(uint64_t, const char *, ...);
  objc_class *v195;
  _BOOL4 v196;
  const char *v197;
  uint64_t v198;
  void *v199;
  uint64_t v200;
  NSObject *v201;
  objc_class *v202;
  int v203;
  const char *v204;
  const char *v205;
  id v206;
  id v207;
  uint64_t v208;
  void *j;
  NSMutableArray *v210;
  void *v211;
  uint64_t v212;
  void (*v213)(uint64_t, const char *, ...);
  objc_class *v214;
  _BOOL4 v215;
  const char *v216;
  const char *v217;
  void *v218;
  uint64_t v219;
  void *v220;
  uint64_t v221;
  NSObject *v222;
  objc_class *v223;
  int v224;
  const char *v225;
  const char *v226;
  void *v227;
  void *v228;
  uint64_t v229;
  void (*v230)(uint64_t, const char *, ...);
  objc_class *v231;
  _BOOL4 v232;
  uint64_t v233;
  void *v234;
  uint64_t v235;
  NSObject *v236;
  objc_class *v237;
  int v238;
  const char *v239;
  const char *v240;
  void *v241;
  id v242;
  char *v243;
  void *v244;
  void *v245;
  uint64_t v246;
  void (*v247)(uint64_t, const char *, ...);
  objc_class *v248;
  _BOOL4 v249;
  id v250;
  const char *v251;
  uint64_t v252;
  void *v253;
  uint64_t v254;
  NSObject *v255;
  objc_class *v256;
  int v257;
  const char *v258;
  const char *v259;
  void *v260;
  id v261;
  id v262;
  uint64_t v263;
  void *i;
  void *v265;
  void *v266;
  void *v267;
  uint64_t v268;
  void (*v269)(uint64_t, const char *, ...);
  objc_class *v270;
  _BOOL4 v271;
  uint64_t v272;
  void *v273;
  uint64_t v274;
  NSObject *v275;
  objc_class *v276;
  int v277;
  const char *v278;
  const char *v279;
  void *v280;
  uint64_t v281;
  void (*v282)(uint64_t, const char *, ...);
  objc_class *v283;
  _BOOL4 v284;
  const char *v285;
  const char *v286;
  uint64_t v287;
  void *v288;
  uint64_t v289;
  NSObject *v290;
  objc_class *v291;
  int v292;
  const char *v293;
  const char *v294;
  uint64_t v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  NSObject *v299;
  uint64_t v300;
  void *v301;
  uint64_t v302;
  id v303;
  uint64_t v304;
  NSObject *v305;
  uint64_t v306;
  uint64_t v307;
  NFContactlessPaymentStartEvent *v308;
  void *v309;
  uint64_t v310;
  void (*v311)(uint64_t, const char *, ...);
  objc_class *v312;
  _BOOL4 v313;
  const char *v314;
  uint64_t v315;
  void *v316;
  uint64_t v317;
  NSObject *v318;
  objc_class *v319;
  int v320;
  const char *v321;
  const char *v322;
  NSMutableDictionary *v323;
  void *v324;
  id WeakRetained;
  char v326;
  uint64_t v327;
  uint64_t v328;
  NSObject *v329;
  void *v330;
  uint64_t v331;
  void (*v332)(uint64_t, const char *, ...);
  objc_class *v333;
  _BOOL4 v334;
  uint64_t v335;
  void *v336;
  uint64_t v337;
  NSObject *v338;
  objc_class *v339;
  int v340;
  const char *v341;
  const char *v342;
  id v343;
  void *v344;
  uint64_t v345;
  void (*v346)(uint64_t, const char *, ...);
  objc_class *v347;
  _BOOL4 v348;
  const char *v349;
  uint64_t v350;
  void *v351;
  uint64_t v352;
  NSObject *v353;
  objc_class *v354;
  int v355;
  const char *v356;
  const char *v357;
  void *v358;
  uint64_t v359;
  void (*v360)(uint64_t, const char *, ...);
  objc_class *v361;
  _BOOL4 v362;
  uint64_t v363;
  void *v364;
  uint64_t v365;
  NSObject *v366;
  objc_class *v367;
  int v368;
  const char *v369;
  const char *v370;
  const char *v371;
  NSObject *v372;
  os_log_type_t v373;
  id v374;
  uint64_t v375;
  NSObject *v376;
  void *v377;
  uint64_t v378;
  void (*v379)(uint64_t, const char *, ...);
  objc_class *v380;
  _BOOL4 v381;
  uint64_t v382;
  void *v383;
  uint64_t v384;
  NSObject *v385;
  objc_class *v386;
  int v387;
  const char *v388;
  const char *v389;
  NSMutableDictionary *v390;
  void *v391;
  id v392;
  void *v393;
  uint64_t v394;
  void (*v395)(uint64_t, const char *, ...);
  objc_class *v396;
  _BOOL4 v397;
  uint64_t v398;
  void *v399;
  uint64_t v400;
  NSObject *v401;
  objc_class *v402;
  int v403;
  const char *v404;
  const char *v405;
  void *v406;
  void *v407;
  void *v408;
  void *v409;
  void *v410;
  void *v411;
  id v412;
  uint64_t v413;
  NSObject *v414;
  void *v415;
  uint64_t v416;
  void (*v417)(uint64_t, const char *, ...);
  objc_class *v418;
  _BOOL4 v419;
  const char *v420;
  uint64_t v421;
  void *v422;
  uint64_t v423;
  NSObject *v424;
  objc_class *v425;
  int v426;
  const char *v427;
  const char *v428;
  void *v429;
  void *v430;
  NSMutableDictionary *v431;
  void *v432;
  id v433;
  uint64_t v434;
  uint64_t v435;
  NSObject *v436;
  id v437;
  uint64_t v438;
  NSObject *v439;
  void *v440;
  uint64_t v441;
  void (*v442)(uint64_t, const char *, ...);
  objc_class *v443;
  _BOOL4 v444;
  const char *v445;
  uint64_t v446;
  void *v447;
  uint64_t v448;
  NSObject *v449;
  objc_class *v450;
  int v451;
  const char *v452;
  const char *v453;
  id v454;
  unsigned int v455;
  void *v456;
  uint64_t v457;
  void (*v458)(uint64_t, const char *, ...);
  objc_class *v459;
  _BOOL4 v460;
  const char *v461;
  uint64_t v462;
  void *v463;
  uint64_t v464;
  NSObject *v465;
  objc_class *v466;
  int v467;
  const char *v468;
  const char *v469;
  objc_class *v470;
  _BOOL4 v471;
  uint64_t v472;
  void *v473;
  uint64_t v474;
  objc_class *v475;
  int v476;
  const char *v477;
  const char *v478;
  const char *v479;
  const char *v480;
  const char *v481;
  const char *v482;
  const char *v483;
  const char *v484;
  const char *v485;
  const char *v486;
  const char *v487;
  const char *v488;
  const char *v489;
  const char *v490;
  const char *v491;
  const char *v492;
  const char *v493;
  const char *v494;
  const char *v495;
  const char *v496;
  const char *v497;
  const char *v498;
  const char *v499;
  const char *v500;
  const char *v501;
  const char *v502;
  const char *v503;
  const char *v504;
  const char *v505;
  const char *v506;
  const char *v507;
  const char *v508;
  const char *v509;
  const char *v510;
  const char *v511;
  const char *v512;
  const char *v513;
  const char *v514;
  const char *v515;
  NSObject *v516;
  NSMutableArray *v517;
  void *v518;
  uint64_t v519;
  id v520;
  void *v521;
  id obj;
  id obja;
  NFContactlessPaymentEndEvent *objb;
  NSObject *v525;
  void *v526;
  void *v527;
  char *sel;
  char *sela;
  id v530;
  _QWORD v531[2];
  _QWORD v532[2];
  uint8_t v533[8];
  _BYTE v534[20];
  __int16 v535;
  int v536;
  __int16 v537;
  NSMutableArray *v538;
  __int16 v539;
  void *v540;
  uint8_t buf[4];
  int v542;
  __int16 v543;
  const char *v544;
  __int16 v545;
  const char *v546;
  __int16 v547;
  int v548;
  __int16 v549;
  _BYTE v550[24];
  __int128 v551;
  __int128 v552;
  __int128 v553;
  __int128 v554;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 32);
  if (v2 && (*(_QWORD *)(v2 + 272) & 0x200) != 0)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      v10 = 45;
      if (isMetaClass)
        v10 = 43;
      v5(6, "%c[%{public}s %{public}s]:%i app=%{public}@ event=%{public}@", v10, ClassName, Name, 885, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48));
    }
    v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v12 = NFSharedLogGetLogger(v11);
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      v14 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v14))
        v15 = 43;
      else
        v15 = 45;
      v16 = object_getClassName(*(id *)(a1 + 32));
      v17 = sel_getName(*(SEL *)(a1 + 56));
      v18 = *(_QWORD *)(a1 + 40);
      v19 = *(_QWORD *)(a1 + 48);
      *(_DWORD *)buf = 67110402;
      v542 = v15;
      v543 = 2082;
      v544 = v16;
      v545 = 2082;
      v546 = v17;
      v547 = 1024;
      v548 = 885;
      v549 = 2114;
      *(_QWORD *)v550 = v18;
      *(_WORD *)&v550[8] = 2114;
      *(_QWORD *)&v550[10] = v19;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i app=%{public}@ event=%{public}@", buf, 0x36u);
    }

  }
  if ((unint64_t)objc_msgSend(*(id *)(a1 + 48), "length") <= 1)
  {
    v20 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v21 = NFLogGetLogger(v20);
    if (v21)
    {
      v22 = (void (*)(uint64_t, const char *, ...))v21;
      v23 = object_getClass(*(id *)(a1 + 32));
      v24 = class_isMetaClass(v23);
      v25 = object_getClassName(*(id *)(a1 + 32));
      v26 = sel_getName(*(SEL *)(a1 + 56));
      v27 = 45;
      if (v24)
        v27 = 43;
      v22(3, "%c[%{public}s %{public}s]:%i Invalid length: %{public}@", v27, v25, v26, 890, *(_QWORD *)(a1 + 48));
    }
    v28 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v29 = NFSharedLogGetLogger(v28);
    v30 = objc_claimAutoreleasedReturnValue(v29);
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      goto LABEL_100;
    v31 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v31))
      v32 = 43;
    else
      v32 = 45;
    v33 = object_getClassName(*(id *)(a1 + 32));
    v34 = sel_getName(*(SEL *)(a1 + 56));
    v35 = *(_QWORD *)(a1 + 48);
    *(_DWORD *)buf = 67110146;
    v542 = v32;
    v543 = 2082;
    v544 = v33;
    v545 = 2082;
    v546 = v34;
    v547 = 1024;
    v548 = 890;
    v549 = 2114;
    *(_QWORD *)v550 = v35;
    v36 = "%c[%{public}s %{public}s]:%i Invalid length: %{public}@";
    v37 = v30;
    v38 = 44;
    goto LABEL_99;
  }
  v39 = *(_QWORD *)(a1 + 32);
  v519 = a1;
  v40 = *(void **)(a1 + 48);
  v30 = *(id *)(a1 + 40);
  v41 = v40;
  if (!v39)
    goto LABEL_63;
  v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v39, "delegate"));
  v43 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject NF_asHexString](v30, "NF_asHexString"));
  v44 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(v42, "appletForIdentifier:filtered:", v43, 0));

  if (!v41 || !v44)
  {
    v68 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v69 = NFLogGetLogger(v68);
    if (v69)
    {
      v70 = (void (*)(uint64_t, const char *, ...))v69;
      v71 = object_getClass((id)v39);
      v72 = class_isMetaClass(v71);
      v480 = object_getClassName((id)v39);
      v495 = sel_getName("parseWithATLLib:event:");
      v73 = 45;
      if (v72)
        v73 = 43;
      v70(6, "%c[%{public}s %{public}s]:%i Failed to get applet from event %{public}@", v73, v480, v495, 721, v41);
    }
    v74 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v75 = NFSharedLogGetLogger(v74);
    v54 = objc_claimAutoreleasedReturnValue(v75);
    if (!os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
      goto LABEL_62;
    v76 = object_getClass((id)v39);
    if (class_isMetaClass(v76))
      v77 = 43;
    else
      v77 = 45;
    v78 = object_getClassName((id)v39);
    v79 = sel_getName("parseWithATLLib:event:");
    *(_DWORD *)buf = 67110146;
    v542 = v77;
    v543 = 2082;
    v544 = v78;
    v545 = 2082;
    v546 = v79;
    v547 = 1024;
    v548 = 721;
    v549 = 2114;
    *(_QWORD *)v550 = v41;
    v80 = "%c[%{public}s %{public}s]:%i Failed to get applet from event %{public}@";
LABEL_61:
    _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, v80, buf, 0x2Cu);
LABEL_62:

LABEL_63:
    v93 = v519;
    goto LABEL_64;
  }
  v45 = objc_claimAutoreleasedReturnValue(-[__CFString identifier](v44, "identifier"));
  if (!v45)
    goto LABEL_52;
  v46 = (void *)v45;
  v47 = objc_claimAutoreleasedReturnValue(-[__CFString packageIdentifier](v44, "packageIdentifier"));
  if (!v47)
  {

    goto LABEL_52;
  }
  v48 = (void *)v47;
  v49 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString moduleIdentifier](v44, "moduleIdentifier"));

  if (!v49)
  {
LABEL_52:
    v81 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v82 = NFLogGetLogger(v81);
    if (v82)
    {
      v83 = (void (*)(uint64_t, const char *, ...))v82;
      v84 = object_getClass((id)v39);
      v85 = class_isMetaClass(v84);
      v481 = object_getClassName((id)v39);
      v496 = sel_getName("parseWithATLLib:event:");
      v86 = 45;
      if (v85)
        v86 = 43;
      v83(6, "%c[%{public}s %{public}s]:%i Failed to get applet information from applet %{public}@", v86, v481, v496, 725, v44);
    }
    v87 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v88 = NFSharedLogGetLogger(v87);
    v54 = objc_claimAutoreleasedReturnValue(v88);
    if (!os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
      goto LABEL_62;
    v89 = object_getClass((id)v39);
    if (class_isMetaClass(v89))
      v90 = 43;
    else
      v90 = 45;
    v91 = object_getClassName((id)v39);
    v92 = sel_getName("parseWithATLLib:event:");
    *(_DWORD *)buf = 67110146;
    v542 = v90;
    v543 = 2082;
    v544 = v91;
    v545 = 2082;
    v546 = v92;
    v547 = 1024;
    v548 = 725;
    v549 = 2114;
    *(_QWORD *)v550 = v44;
    v80 = "%c[%{public}s %{public}s]:%i Failed to get applet information from applet %{public}@";
    goto LABEL_61;
  }
  v50 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString identifier](v44, "identifier"));
  v51 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString packageIdentifier](v44, "packageIdentifier"));
  v52 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString moduleIdentifier](v44, "moduleIdentifier"));
  v530 = 0;
  v53 = (char *)objc_claimAutoreleasedReturnValue(+[AppletTranslator parseHCIEvent:withApplet:withPackage:withModule:withTransceiver:withError:](AppletTranslator, "parseHCIEvent:withApplet:withPackage:withModule:withTransceiver:withError:", v41, v50, v51, v52, 0, &v530));
  v54 = v530;

  if (v53 || !v54)
  {
    if (!v54)
      goto LABEL_234;
  }
  else if (-[NSObject code](v54, "code") == (id)2)
  {
    v55 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v56 = NFLogGetLogger(v55);
    if (v56)
    {
      v57 = (void (*)(uint64_t, const char *, ...))v56;
      v58 = object_getClass((id)v39);
      v59 = class_isMetaClass(v58);
      v479 = object_getClassName((id)v39);
      v494 = sel_getName("parseWithATLLib:event:");
      v60 = 45;
      if (v59)
        v60 = 43;
      v57(6, "%c[%{public}s %{public}s]:%i Applet not supported by the ATL : %{public}@", v60, v479, v494, 737, v54);
    }
    v61 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v62 = NFSharedLogGetLogger(v61);
    v63 = objc_claimAutoreleasedReturnValue(v62);
    if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
    {
      v64 = object_getClass((id)v39);
      if (class_isMetaClass(v64))
        v65 = 43;
      else
        v65 = 45;
      v66 = object_getClassName((id)v39);
      v67 = sel_getName("parseWithATLLib:event:");
      *(_DWORD *)buf = 67110146;
      v542 = v65;
      v543 = 2082;
      v544 = v66;
      v545 = 2082;
      v546 = v67;
      v547 = 1024;
      v548 = 737;
      v549 = 2114;
      *(_QWORD *)v550 = v54;
      _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Applet not supported by the ATL : %{public}@", buf, 0x2Cu);
    }

    goto LABEL_62;
  }
  if (-[NSObject code](v54, "code") == (id)1
    || -[NSObject code](v54, "code") == (id)4
    || -[NSObject code](v54, "code") == (id)5)
  {
    sel = v53;
    v164 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v165 = NFLogGetLogger(v164);
    if (v165)
    {
      v166 = (void (*)(uint64_t, const char *, ...))v165;
      v167 = object_getClass((id)v39);
      v168 = class_isMetaClass(v167);
      v485 = object_getClassName((id)v39);
      v500 = sel_getName("parseWithATLLib:event:");
      v169 = 45;
      if (v168)
        v169 = 43;
      v166(6, "%c[%{public}s %{public}s]:%i Error : failed to get more info : %{public}@", v169, v485, v500, 746, v54);
    }
    v170 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v171 = NFSharedLogGetLogger(v170);
    v172 = objc_claimAutoreleasedReturnValue(v171);
    if (os_log_type_enabled(v172, OS_LOG_TYPE_DEFAULT))
    {
      v173 = object_getClass((id)v39);
      if (class_isMetaClass(v173))
        v174 = 43;
      else
        v174 = 45;
      v175 = object_getClassName((id)v39);
      v176 = sel_getName("parseWithATLLib:event:");
      *(_DWORD *)buf = 67110146;
      v542 = v174;
      v543 = 2082;
      v544 = v175;
      v545 = 2082;
      v546 = v176;
      v547 = 1024;
      v548 = 746;
      v549 = 2114;
      *(_QWORD *)v550 = v54;
      _os_log_impl((void *)&_mh_execute_header, v172, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Error : failed to get more info : %{public}@", buf, 0x2Cu);
    }

    goto LABEL_268;
  }
LABEL_234:
  v300 = objc_claimAutoreleasedReturnValue(objc_msgSend(v53, "objectForKeyedSubscript:", CFSTR("EventType")));
  v527 = (void *)v300;
  sela = v53;
  if (!v300)
  {
    v344 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v345 = NFLogGetLogger(v344);
    if (v345)
    {
      v346 = (void (*)(uint64_t, const char *, ...))v345;
      v347 = object_getClass((id)v39);
      v348 = class_isMetaClass(v347);
      v349 = object_getClassName((id)v39);
      v508 = sel_getName("parseWithATLLib:event:");
      v350 = 45;
      if (v348)
        v350 = 43;
      v346(6, "%c[%{public}s %{public}s]:%i No event from ATL, HCI didn't contain a relevant message", v350, v349, v508, 754);
    }
    v351 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v352 = NFSharedLogGetLogger(v351);
    v353 = objc_claimAutoreleasedReturnValue(v352);
    if (os_log_type_enabled(v353, OS_LOG_TYPE_DEFAULT))
    {
      v354 = object_getClass((id)v39);
      if (class_isMetaClass(v354))
        v355 = 43;
      else
        v355 = 45;
      v356 = object_getClassName((id)v39);
      v357 = sel_getName("parseWithATLLib:event:");
      *(_DWORD *)buf = 67109890;
      v542 = v355;
      v543 = 2082;
      v544 = v356;
      v545 = 2082;
      v546 = v357;
      v547 = 1024;
      v548 = 754;
      _os_log_impl((void *)&_mh_execute_header, v353, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i No event from ATL, HCI didn't contain a relevant message", buf, 0x22u);
    }

    goto LABEL_279;
  }
  v301 = (void *)v300;
  v302 = objc_opt_class(NSString);
  if ((objc_opt_isKindOfClass(v301, v302) & 1) == 0)
  {
    v358 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v359 = NFLogGetLogger(v358);
    if (v359)
    {
      v360 = (void (*)(uint64_t, const char *, ...))v359;
      v361 = object_getClass((id)v39);
      v362 = class_isMetaClass(v361);
      v490 = object_getClassName((id)v39);
      v509 = sel_getName("parseWithATLLib:event:");
      v363 = 45;
      if (v362)
        v363 = 43;
      v360(6, "%c[%{public}s %{public}s]:%i Error : invalid event class : %{public}@", v363, v490, v509, 758, v527);
    }
    v364 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v365 = NFSharedLogGetLogger(v364);
    v366 = objc_claimAutoreleasedReturnValue(v365);
    if (!os_log_type_enabled(v366, OS_LOG_TYPE_DEFAULT))
      goto LABEL_290;
    v367 = object_getClass((id)v39);
    if (class_isMetaClass(v367))
      v368 = 43;
    else
      v368 = 45;
    v369 = object_getClassName((id)v39);
    v370 = sel_getName("parseWithATLLib:event:");
    *(_DWORD *)buf = 67110146;
    v542 = v368;
    v543 = 2082;
    v544 = v369;
    v545 = 2082;
    v546 = v370;
    v547 = 1024;
    v548 = 758;
    v549 = 2114;
    *(_QWORD *)v550 = v527;
    v371 = "%c[%{public}s %{public}s]:%i Error : invalid event class : %{public}@";
    v372 = v366;
    v373 = OS_LOG_TYPE_DEFAULT;
    goto LABEL_289;
  }
  v303 = objc_msgSend(v301, "isEqualToString:", CFSTR("StartEvent"));
  if ((_DWORD)v303)
  {
    v304 = NFSharedSignpostLog(v303);
    v305 = objc_claimAutoreleasedReturnValue(v304);
    if (os_signpost_enabled(v305))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v305, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "AtlEvent", "AtlStartEvent", buf, 2u);
    }

    sub_1000D0980((void *)v39, sela, v301);
    v306 = *(_QWORD *)(v39 + 32);
    if (v306)
    {
      *(_BYTE *)(v306 + 216) = 0;
      v307 = *(_QWORD *)(v39 + 32);
      if (v307)
        *(_BYTE *)(v307 + 217) = 0;
    }
    v308 = -[NFContactlessPaymentStartEvent initWithDictionary:]([NFContactlessPaymentStartEvent alloc], "initWithDictionary:", sela);
    if (v308)
    {
      v309 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v310 = NFLogGetLogger(v309);
      if (v310)
      {
        v311 = (void (*)(uint64_t, const char *, ...))v310;
        v312 = object_getClass((id)v39);
        v313 = class_isMetaClass(v312);
        v314 = object_getClassName((id)v39);
        v506 = sel_getName("parseWithATLLib:event:");
        v315 = 45;
        if (v313)
          v315 = 43;
        v311(6, "%c[%{public}s %{public}s]:%i %{public}@", v315, v314, v506, 774, v308);
      }
      v316 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v317 = NFSharedLogGetLogger(v316);
      v318 = objc_claimAutoreleasedReturnValue(v317);
      if (os_log_type_enabled(v318, OS_LOG_TYPE_DEFAULT))
      {
        v319 = object_getClass((id)v39);
        if (class_isMetaClass(v319))
          v320 = 43;
        else
          v320 = 45;
        v321 = object_getClassName((id)v39);
        v322 = sel_getName("parseWithATLLib:event:");
        *(_DWORD *)buf = 67110146;
        v542 = v320;
        v543 = 2082;
        v544 = v321;
        v545 = 2082;
        v546 = v322;
        v547 = 1024;
        v548 = 774;
        v549 = 2114;
        *(_QWORD *)v550 = v308;
        _os_log_impl((void *)&_mh_execute_header, v318, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
      }

      v323 = sub_1000CE5D8((void *)v39, v30, sela, v308);
      v324 = (void *)objc_claimAutoreleasedReturnValue(v323);
      WeakRetained = objc_loadWeakRetained((id *)(v39 + 40));
      objc_msgSend(WeakRetained, "handleTransactionStartEvent:atlData:caData:", v308, sela, v324);

    }
    v326 = 1;
    goto LABEL_291;
  }
  v374 = objc_msgSend(v301, "isEqualToString:", CFSTR("EndEvent"));
  if ((_DWORD)v374)
  {
    v375 = NFSharedSignpostLog(v374);
    v376 = objc_claimAutoreleasedReturnValue(v375);
    if (os_signpost_enabled(v376))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v376, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "AtlEndEventEnter", "", buf, 2u);
    }

    objb = -[NFContactlessPaymentEndEvent initWithDictionary:]([NFContactlessPaymentEndEvent alloc], "initWithDictionary:", sela);
    if (objb)
    {
      v377 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v378 = NFLogGetLogger(v377);
      if (v378)
      {
        v379 = (void (*)(uint64_t, const char *, ...))v378;
        v380 = object_getClass((id)v39);
        v381 = class_isMetaClass(v380);
        v491 = object_getClassName((id)v39);
        v510 = sel_getName("parseWithATLLib:event:");
        v382 = 45;
        if (v381)
          v382 = 43;
        v379(6, "%c[%{public}s %{public}s]:%i %{public}@", v382, v491, v510, 786, objb);
      }
      v383 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v384 = NFSharedLogGetLogger(v383);
      v385 = objc_claimAutoreleasedReturnValue(v384);
      if (os_log_type_enabled(v385, OS_LOG_TYPE_DEFAULT))
      {
        v386 = object_getClass((id)v39);
        if (class_isMetaClass(v386))
          v387 = 43;
        else
          v387 = 45;
        v388 = object_getClassName((id)v39);
        v389 = sel_getName("parseWithATLLib:event:");
        *(_DWORD *)buf = 67110146;
        v542 = v387;
        v543 = 2082;
        v544 = v388;
        v545 = 2082;
        v546 = v389;
        v547 = 1024;
        v548 = 786;
        v549 = 2114;
        *(_QWORD *)v550 = objb;
        _os_log_impl((void *)&_mh_execute_header, v385, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
      }

      v390 = sub_1000CEA1C(v39, v30, sela, objb);
      v391 = (void *)objc_claimAutoreleasedReturnValue(v390);
      v392 = objc_loadWeakRetained((id *)(v39 + 40));
      objc_msgSend(v392, "handleTransactionEndEvent:atlData:caData:", objb, sela, v391);

      v521 = v391;
      if (sub_1000D04D4(v44, objb, v391))
      {
        v393 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v394 = NFLogGetLogger(v393);
        if (v394)
        {
          v395 = (void (*)(uint64_t, const char *, ...))v394;
          v396 = object_getClass((id)v39);
          v397 = class_isMetaClass(v396);
          v492 = object_getClassName((id)v39);
          v511 = sel_getName("parseWithATLLib:event:");
          v398 = 45;
          if (v397)
            v398 = 43;
          v395(6, "%c[%{public}s %{public}s]:%i atEvent = %{public}@", v398, v492, v511, 796, sela);
        }
        v399 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v400 = NFSharedLogGetLogger(v399);
        v401 = objc_claimAutoreleasedReturnValue(v400);
        if (os_log_type_enabled(v401, OS_LOG_TYPE_DEFAULT))
        {
          v402 = object_getClass((id)v39);
          if (class_isMetaClass(v402))
            v403 = 43;
          else
            v403 = 45;
          v404 = object_getClassName((id)v39);
          v405 = sel_getName("parseWithATLLib:event:");
          *(_DWORD *)buf = 67110146;
          v542 = v403;
          v543 = 2082;
          v544 = v404;
          v545 = 2082;
          v546 = v405;
          v547 = 1024;
          v548 = 796;
          v549 = 2114;
          *(_QWORD *)v550 = sela;
          _os_log_impl((void *)&_mh_execute_header, v401, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i atEvent = %{public}@", buf, 0x2Cu);
        }

        v518 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString identifier](v44, "identifier"));
        v406 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString identifier](v44, "identifier"));
        v407 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v518, "substringToIndex:", (char *)objc_msgSend(v406, "length") - 2));
        v408 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(sela, "valueForKey:", CFSTR("result")));
        v409 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Applet AID: %@, Error: %@"), v407, v408));
        *(_QWORD *)v533 = CFSTR("Applet Identifier");
        v410 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString identifier](v44, "identifier"));
        *(_QWORD *)&v551 = v410;
        *((_QWORD *)&v551 + 1) = CFSTR("Other Bug");
        *(_QWORD *)v534 = CFSTR("Classification");
        *(_QWORD *)&v534[8] = CFSTR("FailureKey");
        *(_QWORD *)&v552 = CFSTR("ttrTransaction");
        v411 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v551, v533, 3));
        sub_100187BAC((uint64_t)NFBugCapture, CFSTR("Transaction Failed "), v409, v411);

      }
      v301 = v527;
    }

    v326 = 1;
    goto LABEL_292;
  }
  v412 = objc_msgSend(v301, "isEqualToString:", CFSTR("ActivityTimeout"));
  if ((_DWORD)v412)
  {
    v413 = NFSharedSignpostLog(v412);
    v414 = objc_claimAutoreleasedReturnValue(v413);
    if (os_signpost_enabled(v414))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v414, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "AtlActivityTimeoutEvent", "", buf, 2u);
    }

    v415 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v416 = NFLogGetLogger(v415);
    if (v416)
    {
      v417 = (void (*)(uint64_t, const char *, ...))v416;
      v418 = object_getClass((id)v39);
      v419 = class_isMetaClass(v418);
      v420 = object_getClassName((id)v39);
      v512 = sel_getName("parseWithATLLib:event:");
      v421 = 45;
      if (v419)
        v421 = 43;
      v417(6, "%c[%{public}s %{public}s]:%i Got activity timeout", v421, v420, v512, 806);
    }
    v422 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v423 = NFSharedLogGetLogger(v422);
    v424 = objc_claimAutoreleasedReturnValue(v423);
    if (os_log_type_enabled(v424, OS_LOG_TYPE_DEFAULT))
    {
      v425 = object_getClass((id)v39);
      if (class_isMetaClass(v425))
        v426 = 43;
      else
        v426 = 45;
      v427 = object_getClassName((id)v39);
      v428 = sel_getName("parseWithATLLib:event:");
      *(_DWORD *)buf = 67109890;
      v542 = v426;
      v543 = 2082;
      v544 = v427;
      v545 = 2082;
      v546 = v428;
      v547 = 1024;
      v548 = 806;
      _os_log_impl((void *)&_mh_execute_header, v424, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Got activity timeout", buf, 0x22u);
    }

    v429 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(sela, "valueForKey:", CFSTR("Result")));
    v531[0] = CFSTR("result");
    v531[1] = CFSTR("applet");
    v532[0] = v429;
    v532[1] = v44;
    v430 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v532, v531, 2));
    v431 = sub_1000CFF90((void *)v39, v30, sela);
    v432 = (void *)objc_claimAutoreleasedReturnValue(v431);
    v433 = objc_loadWeakRetained((id *)(v39 + 40));
    objc_msgSend(v433, "handleAppletInactivityTimeout:atlData:caData:", v430, sela, v432);

    v435 = NFSharedSignpostLog(v434);
    v436 = objc_claimAutoreleasedReturnValue(v435);
    if (os_signpost_enabled(v436))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v436, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "AtlEvent", "AtlActivityTimeoutEvent", buf, 2u);
    }

LABEL_279:
    v326 = 1;
LABEL_291:
    v301 = v527;
    goto LABEL_292;
  }
  v437 = objc_msgSend(v301, "isEqualToString:", CFSTR("StepUpRequested"));
  if (!(_DWORD)v437)
  {
    v455 = objc_msgSend(v301, "isEqualToString:", CFSTR("UnavailableCertEvent"));
    v456 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v457 = NFLogGetLogger(v456);
    v458 = (void (*)(uint64_t, const char *, ...))v457;
    if (v455)
    {
      if (v457)
      {
        v459 = object_getClass((id)v39);
        v460 = class_isMetaClass(v459);
        v461 = object_getClassName((id)v39);
        v514 = sel_getName("parseWithATLLib:event:");
        v462 = 45;
        if (v460)
          v462 = 43;
        v458(6, "%c[%{public}s %{public}s]:%i UnavailableCert Event", v462, v461, v514, 830);
      }
      v463 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v464 = NFSharedLogGetLogger(v463);
      v465 = objc_claimAutoreleasedReturnValue(v464);
      if (os_log_type_enabled(v465, OS_LOG_TYPE_DEFAULT))
      {
        v466 = object_getClass((id)v39);
        if (class_isMetaClass(v466))
          v467 = 43;
        else
          v467 = 45;
        v468 = object_getClassName((id)v39);
        v469 = sel_getName("parseWithATLLib:event:");
        *(_DWORD *)buf = 67109890;
        v542 = v467;
        v543 = 2082;
        v544 = v468;
        v545 = 2082;
        v546 = v469;
        v547 = 1024;
        v548 = 830;
        _os_log_impl((void *)&_mh_execute_header, v465, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i UnavailableCert Event", buf, 0x22u);
      }

      sub_100228D64((uint64_t)NFHciTransactionEventCALogger, sela);
      goto LABEL_279;
    }
    if (v457)
    {
      v470 = object_getClass((id)v39);
      v471 = class_isMetaClass(v470);
      v493 = object_getClassName((id)v39);
      v515 = sel_getName("parseWithATLLib:event:");
      v472 = 45;
      if (v471)
        v472 = 43;
      v458(3, "%c[%{public}s %{public}s]:%i Unknown event type : %{public}@", v472, v493, v515, 834, v527);
    }
    v473 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v474 = NFSharedLogGetLogger(v473);
    v366 = objc_claimAutoreleasedReturnValue(v474);
    if (!os_log_type_enabled(v366, OS_LOG_TYPE_ERROR))
    {
LABEL_290:

      v326 = 0;
      goto LABEL_291;
    }
    v475 = object_getClass((id)v39);
    if (class_isMetaClass(v475))
      v476 = 43;
    else
      v476 = 45;
    v477 = object_getClassName((id)v39);
    v478 = sel_getName("parseWithATLLib:event:");
    *(_DWORD *)buf = 67110146;
    v542 = v476;
    v543 = 2082;
    v544 = v477;
    v545 = 2082;
    v546 = v478;
    v547 = 1024;
    v548 = 834;
    v549 = 2114;
    *(_QWORD *)v550 = v527;
    v371 = "%c[%{public}s %{public}s]:%i Unknown event type : %{public}@";
    v372 = v366;
    v373 = OS_LOG_TYPE_ERROR;
LABEL_289:
    _os_log_impl((void *)&_mh_execute_header, v372, v373, v371, buf, 0x2Cu);
    goto LABEL_290;
  }
  v438 = NFSharedSignpostLog(v437);
  v439 = objc_claimAutoreleasedReturnValue(v438);
  if (os_signpost_enabled(v439))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v439, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "AtlStepUpEventEnter", "", buf, 2u);
  }

  v440 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v441 = NFLogGetLogger(v440);
  if (v441)
  {
    v442 = (void (*)(uint64_t, const char *, ...))v441;
    v443 = object_getClass((id)v39);
    v444 = class_isMetaClass(v443);
    v445 = object_getClassName((id)v39);
    v513 = sel_getName("parseWithATLLib:event:");
    v446 = 45;
    if (v444)
      v446 = 43;
    v442(6, "%c[%{public}s %{public}s]:%i StepUp Event", v446, v445, v513, 820);
  }
  v447 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v448 = NFSharedLogGetLogger(v447);
  v449 = objc_claimAutoreleasedReturnValue(v448);
  if (os_log_type_enabled(v449, OS_LOG_TYPE_DEFAULT))
  {
    v450 = object_getClass((id)v39);
    if (class_isMetaClass(v450))
      v451 = 43;
    else
      v451 = 45;
    v452 = object_getClassName((id)v39);
    v453 = sel_getName("parseWithATLLib:event:");
    *(_DWORD *)buf = 67109890;
    v542 = v451;
    v543 = 2082;
    v544 = v452;
    v545 = 2082;
    v546 = v453;
    v547 = 1024;
    v548 = 820;
    _os_log_impl((void *)&_mh_execute_header, v449, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i StepUp Event", buf, 0x22u);
  }

  v301 = v527;
  sub_1000D0980((void *)v39, sela, v527);
  v454 = objc_loadWeakRetained((id *)(v39 + 40));
  objc_msgSend(v454, "handleStepUpEvent:forApplet:", sela, v44);

  v326 = 1;
LABEL_292:

  v93 = v519;
  if ((v326 & 1) != 0)
    return;
LABEL_64:
  v94 = (unsigned __int8 *)objc_msgSend(objc_retainAutorelease(*(id *)(v93 + 48)), "bytes");
  v95 = *v94;
  v96 = v94[1];
  if (objc_msgSend(*(id *)(v93 + 40), "length") != (id)8
    || *(_QWORD *)objc_msgSend(objc_retainAutorelease(*(id *)(v93 + 40)), "bytes") != 0x51010000A0
    || objc_msgSend(*(id *)(v93 + 48), "length") != (id)8
    || *(_QWORD *)v94 != 0x5A5A5A5AA5A5A5A5)
  {
    if ((_DWORD)v96 != 1)
    {
      v118 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v119 = NFLogGetLogger(v118);
      if (v119)
      {
        v120 = (void (*)(uint64_t, const char *, ...))v119;
        v121 = object_getClass(*(id *)(v93 + 32));
        v122 = class_isMetaClass(v121);
        v123 = object_getClassName(*(id *)(v93 + 32));
        v124 = sel_getName(*(SEL *)(v93 + 56));
        v125 = 43;
        if (!v122)
          v125 = 45;
        v120(4, "%c[%{public}s %{public}s]:%i Unsupport version %d: %{public}@ - %{public}@", v125, v123, v124, 911, v96, *(_QWORD *)(v93 + 40), *(_QWORD *)(v93 + 48));
      }
      v126 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v127 = NFSharedLogGetLogger(v126);
      v30 = objc_claimAutoreleasedReturnValue(v127);
      if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        goto LABEL_100;
      v128 = object_getClass(*(id *)(v93 + 32));
      if (class_isMetaClass(v128))
        v129 = 43;
      else
        v129 = 45;
      v130 = object_getClassName(*(id *)(v93 + 32));
      v131 = sel_getName(*(SEL *)(v93 + 56));
      v132 = *(_QWORD *)(v93 + 40);
      v133 = *(_QWORD *)(v93 + 48);
      *(_DWORD *)buf = 67110658;
      v542 = v129;
      v543 = 2082;
      v544 = v130;
      v545 = 2082;
      v546 = v131;
      v547 = 1024;
      v548 = 911;
      v549 = 1024;
      *(_DWORD *)v550 = v96;
      *(_WORD *)&v550[4] = 2114;
      *(_QWORD *)&v550[6] = v132;
      *(_WORD *)&v550[14] = 2114;
      *(_QWORD *)&v550[16] = v133;
      v36 = "%c[%{public}s %{public}s]:%i Unsupport version %d: %{public}@ - %{public}@";
      v37 = v30;
      v38 = 60;
      goto LABEL_99;
    }
    v97 = *(void **)(v93 + 40);
    if (v97
      && objc_msgSend(v97, "length") == 5
      && ((v98 = (unsigned __int8 *)objc_msgSend(objc_retainAutorelease(*(id *)(v93 + 40)), "bytes"),
           *(_DWORD *)v98 == -1)
        ? (v99 = v98[4] == 255)
        : (v99 = 0),
          v99))
    {
      v177 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v178 = NFLogGetLogger(v177);
      if (v178)
      {
        v179 = (void (*)(uint64_t, const char *, ...))v178;
        v180 = object_getClass(*(id *)(v93 + 32));
        v181 = class_isMetaClass(v180);
        v182 = object_getClassName(*(id *)(v93 + 32));
        v501 = sel_getName(*(SEL *)(v93 + 56));
        v183 = 45;
        if (v181)
          v183 = 43;
        v179(6, "%c[%{public}s %{public}s]:%i SEOS routing handler logging event", v183, v182, v501, 918);
      }
      v184 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v185 = NFSharedLogGetLogger(v184);
      v186 = objc_claimAutoreleasedReturnValue(v185);
      if (os_log_type_enabled(v186, OS_LOG_TYPE_DEFAULT))
      {
        v187 = object_getClass(*(id *)(v93 + 32));
        if (class_isMetaClass(v187))
          v188 = 43;
        else
          v188 = 45;
        v189 = object_getClassName(*(id *)(v93 + 32));
        v190 = sel_getName(*(SEL *)(v93 + 56));
        *(_DWORD *)buf = 67109890;
        v542 = v188;
        v543 = 2082;
        v544 = v189;
        v545 = 2082;
        v546 = v190;
        v547 = 1024;
        v548 = 918;
        _os_log_impl((void *)&_mh_execute_header, v186, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i SEOS routing handler logging event", buf, 0x22u);
      }

    }
    else if ((_DWORD)v95 != 32)
    {
      if ((_DWORD)v95 != 16)
      {
        if ((_DWORD)v95 == 4)
        {
          v100 = objc_loadWeakRetained((id *)(*(_QWORD *)(v93 + 32) + 40));
          v101 = *(void **)(v93 + 32);
          v102 = *(id *)(v93 + 48);
          v103 = v102;
          if (v101)
          {
            if ((unint64_t)objc_msgSend(v102, "length") > 3)
            {
              v242 = objc_retainAutorelease(v103);
              v243 = (char *)objc_msgSend(v242, "bytes");
              v117 = objc_opt_new(NSMutableArray);
              v112 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_100269D0D, 14);
              if ((unint64_t)objc_msgSend(v242, "length") >= 5)
              {
                v520 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", v243 + 4, (char *)objc_msgSend(v242, "length") - 4);
                v244 = (void *)objc_claimAutoreleasedReturnValue(+[NFTLV TLVWithTag:fromData:](NFTLV, "TLVWithTag:fromData:", 225));
                v526 = v244;
                if (!v244)
                {
                  v245 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  v246 = NFLogGetLogger(v245);
                  if (v246)
                  {
                    v247 = (void (*)(uint64_t, const char *, ...))v246;
                    v248 = object_getClass(v101);
                    v249 = class_isMetaClass(v248);
                    v250 = v100;
                    v251 = object_getClassName(v101);
                    v504 = sel_getName("_decodeCRSAuthTimerExpiredEvent:status:");
                    v252 = 45;
                    if (v249)
                      v252 = 43;
                    v487 = v251;
                    v100 = v250;
                    v247(3, "%c[%{public}s %{public}s]:%i Invalid TLV", v252, v487, v504, 185);
                  }
                  v253 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  v254 = NFSharedLogGetLogger(v253);
                  v255 = objc_claimAutoreleasedReturnValue(v254);
                  if (os_log_type_enabled(v255, OS_LOG_TYPE_ERROR))
                  {
                    v256 = object_getClass(v101);
                    if (class_isMetaClass(v256))
                      v257 = 43;
                    else
                      v257 = 45;
                    v258 = object_getClassName(v101);
                    v259 = sel_getName("_decodeCRSAuthTimerExpiredEvent:status:");
                    *(_DWORD *)buf = 67109890;
                    v542 = v257;
                    v543 = 2082;
                    v544 = v258;
                    v545 = 2082;
                    v546 = v259;
                    v547 = 1024;
                    v548 = 185;
                    _os_log_impl((void *)&_mh_execute_header, v255, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid TLV", buf, 0x22u);
                  }

                  v244 = 0;
                }
                obja = v100;
                v553 = 0u;
                v554 = 0u;
                v551 = 0u;
                v552 = 0u;
                v260 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v244, "childrenWithTag:", 79));
                v261 = objc_msgSend(v260, "countByEnumeratingWithState:objects:count:", &v551, buf, 16);
                if (v261)
                {
                  v262 = v261;
                  v263 = *(_QWORD *)v552;
                  do
                  {
                    for (i = 0; i != v262; i = (char *)i + 1)
                    {
                      if (*(_QWORD *)v552 != v263)
                        objc_enumerationMutation(v260);
                      v265 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*((_QWORD *)&v551 + 1)
                                                                                          + 8 * (_QWORD)i), "value"));
                      if ((objc_msgSend(v265, "isEqualToData:", v112) & 1) == 0)
                      {
                        v266 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v265, "NF_asHexString"));
                        -[NSMutableArray addObject:](v117, "addObject:", v266);

                      }
                    }
                    v262 = objc_msgSend(v260, "countByEnumeratingWithState:objects:count:", &v551, buf, 16);
                  }
                  while (v262);
                }

                v100 = obja;
              }
              v267 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v268 = NFLogGetLogger(v267);
              if (v268)
              {
                v269 = (void (*)(uint64_t, const char *, ...))v268;
                v270 = object_getClass(v101);
                v271 = class_isMetaClass(v270);
                v488 = object_getClassName(v101);
                v505 = sel_getName("_decodeCRSAuthTimerExpiredEvent:status:");
                v272 = 45;
                if (v271)
                  v272 = 43;
                v269(6, "%c[%{public}s %{public}s]:%i %{public}@", v272, v488, v505, 196, v117);
              }
              v273 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v274 = NFSharedLogGetLogger(v273);
              v275 = objc_claimAutoreleasedReturnValue(v274);
              if (os_log_type_enabled(v275, OS_LOG_TYPE_DEFAULT))
              {
                v276 = object_getClass(v101);
                if (class_isMetaClass(v276))
                  v277 = 43;
                else
                  v277 = 45;
                v278 = object_getClassName(v101);
                v279 = sel_getName("_decodeCRSAuthTimerExpiredEvent:status:");
                *(_DWORD *)v533 = 67110146;
                *(_DWORD *)&v533[4] = v277;
                *(_WORD *)v534 = 2082;
                *(_QWORD *)&v534[2] = v278;
                *(_WORD *)&v534[10] = 2082;
                *(_QWORD *)&v534[12] = v279;
                v535 = 1024;
                v536 = 196;
                v537 = 2114;
                v538 = v117;
                _os_log_impl((void *)&_mh_execute_header, v275, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", v533, 0x2Cu);
              }

            }
            else
            {
              v104 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v105 = NFLogGetLogger(v104);
              if (v105)
              {
                v106 = (void (*)(uint64_t, const char *, ...))v105;
                v107 = object_getClass(v101);
                v108 = class_isMetaClass(v107);
                v482 = object_getClassName(v101);
                v497 = sel_getName("_decodeCRSAuthTimerExpiredEvent:status:");
                v109 = 45;
                if (v108)
                  v109 = 43;
                v106(3, "%c[%{public}s %{public}s]:%i Unexpected HCI event: %{public}@", v109, v482, v497, 169, v103);
              }
              v110 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v111 = NFSharedLogGetLogger(v110);
              v112 = objc_claimAutoreleasedReturnValue(v111);
              if (os_log_type_enabled(v112, OS_LOG_TYPE_ERROR))
              {
                v113 = object_getClass(v101);
                if (class_isMetaClass(v113))
                  v114 = 43;
                else
                  v114 = 45;
                v115 = object_getClassName(v101);
                v116 = sel_getName("_decodeCRSAuthTimerExpiredEvent:status:");
                *(_DWORD *)buf = 67110146;
                v542 = v114;
                v543 = 2082;
                v544 = v115;
                v545 = 2082;
                v546 = v116;
                v547 = 1024;
                v548 = 169;
                v549 = 2114;
                *(_QWORD *)v550 = v103;
                _os_log_impl((void *)&_mh_execute_header, v112, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unexpected HCI event: %{public}@", buf, 0x2Cu);
              }
              v117 = 0;
            }

          }
          else
          {
            v117 = 0;
          }

          objc_msgSend(v100, "handleTimerExpiredEvent:", v117);
          +[NFGeneralStatisticsCALogger updateAnalyticsGeneralTransactionStatistics:](NFGeneralStatisticsCALogger, "updateAnalyticsGeneralTransactionStatistics:", &off_100306588);
          return;
        }
        v152 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v153 = NFLogGetLogger(v152);
        if (v153)
        {
          v154 = (void (*)(uint64_t, const char *, ...))v153;
          v155 = object_getClass(*(id *)(v93 + 32));
          v156 = class_isMetaClass(v155);
          v484 = object_getClassName(*(id *)(v93 + 32));
          v499 = sel_getName(*(SEL *)(v93 + 56));
          v157 = 45;
          if (v156)
            v157 = 43;
          v154(3, "%c[%{public}s %{public}s]:%i Unknown type: %d", v157, v484, v499, 955, v95);
        }
        v158 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v159 = NFSharedLogGetLogger(v158);
        v30 = objc_claimAutoreleasedReturnValue(v159);
        if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
          goto LABEL_100;
        v160 = object_getClass(*(id *)(v93 + 32));
        if (class_isMetaClass(v160))
          v161 = 43;
        else
          v161 = 45;
        v162 = object_getClassName(*(id *)(v93 + 32));
        v163 = sel_getName(*(SEL *)(v93 + 56));
        *(_DWORD *)buf = 67110146;
        v542 = v161;
        v543 = 2082;
        v544 = v162;
        v545 = 2082;
        v546 = v163;
        v547 = 1024;
        v548 = 955;
        v549 = 1024;
        *(_DWORD *)v550 = v95;
        v36 = "%c[%{public}s %{public}s]:%i Unknown type: %d";
        v37 = v30;
        v38 = 40;
LABEL_99:
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, v36, buf, v38);
LABEL_100:

        return;
      }
      v134 = *(_QWORD **)(v93 + 32);
      v135 = *(id *)(v93 + 48);
      if (!v134)
      {

        v30 = 0;
        goto LABEL_100;
      }
      v136 = (NSMutableArray *)objc_retainAutorelease(v135);
      v137 = (char *)-[NSMutableArray bytes](v136, "bytes");
      if ((unint64_t)-[NSMutableArray length](v136, "length") > 2)
      {
        v517 = v136;
        v516 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", v137 + 2, (char *)-[NSMutableArray length](v136, "length") - 2);
        v525 = objc_claimAutoreleasedReturnValue(+[NFFelicaStateEvent decodeEvent:reverse:](NFFelicaStateEvent, "decodeEvent:reverse:"));
        v191 = v134[4];
        if (v191 && (*(_QWORD *)(v191 + 272) & 0x203) != 0)
        {
          v192 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v193 = NFLogGetLogger(v192);
          if (v193)
          {
            v194 = (void (*)(uint64_t, const char *, ...))v193;
            v195 = object_getClass(v134);
            v196 = class_isMetaClass(v195);
            v197 = object_getClassName(v134);
            v502 = sel_getName("_decodeFelicaStateEvent:");
            v198 = 45;
            if (v196)
              v198 = 43;
            v194(5, "%c[%{public}s %{public}s]:%i [L-ICF] HCI State event", v198, v197, v502, 212);
          }
          v199 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v200 = NFSharedLogGetLogger(v199);
          v201 = objc_claimAutoreleasedReturnValue(v200);
          if (os_log_type_enabled(v201, OS_LOG_TYPE_DEFAULT))
          {
            v202 = object_getClass(v134);
            if (class_isMetaClass(v202))
              v203 = 43;
            else
              v203 = 45;
            v204 = object_getClassName(v134);
            v205 = sel_getName("_decodeFelicaStateEvent:");
            *(_DWORD *)v533 = 67109890;
            *(_DWORD *)&v533[4] = v203;
            *(_WORD *)v534 = 2082;
            *(_QWORD *)&v534[2] = v204;
            *(_WORD *)&v534[10] = 2082;
            *(_QWORD *)&v534[12] = v205;
            v535 = 1024;
            v536 = 212;
            _os_log_impl((void *)&_mh_execute_header, v201, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i [L-ICF] HCI State event", v533, 0x22u);
          }

          v553 = 0u;
          v554 = 0u;
          v551 = 0u;
          v552 = 0u;
          obj = (id)objc_claimAutoreleasedReturnValue(-[NSObject allKeys](v525, "allKeys"));
          v206 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v551, buf, 16);
          if (v206)
          {
            v207 = v206;
            v208 = *(_QWORD *)v552;
            do
            {
              for (j = 0; j != v207; j = (char *)j + 1)
              {
                if (*(_QWORD *)v552 != v208)
                  objc_enumerationMutation(obj);
                v210 = *(NSMutableArray **)(*((_QWORD *)&v551 + 1) + 8 * (_QWORD)j);
                v211 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                v212 = NFLogGetLogger(v211);
                if (v212)
                {
                  v213 = (void (*)(uint64_t, const char *, ...))v212;
                  v214 = object_getClass(v134);
                  v215 = class_isMetaClass(v214);
                  v216 = object_getClassName(v134);
                  v217 = sel_getName("_decodeFelicaStateEvent:");
                  v218 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject objectForKeyedSubscript:](v525, "objectForKeyedSubscript:", v210));
                  v219 = 45;
                  if (v215)
                    v219 = 43;
                  v213(5, "%c[%{public}s %{public}s]:%i [L-ICF] %{public}@ = %{public}@", v219, v216, v217, 214, v210, v218);

                }
                v220 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                v221 = NFSharedLogGetLogger(v220);
                v222 = objc_claimAutoreleasedReturnValue(v221);
                if (os_log_type_enabled(v222, OS_LOG_TYPE_DEFAULT))
                {
                  v223 = object_getClass(v134);
                  if (class_isMetaClass(v223))
                    v224 = 43;
                  else
                    v224 = 45;
                  v225 = object_getClassName(v134);
                  v226 = sel_getName("_decodeFelicaStateEvent:");
                  v227 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject objectForKeyedSubscript:](v525, "objectForKeyedSubscript:", v210));
                  *(_DWORD *)v533 = 67110402;
                  *(_DWORD *)&v533[4] = v224;
                  *(_WORD *)v534 = 2082;
                  *(_QWORD *)&v534[2] = v225;
                  *(_WORD *)&v534[10] = 2082;
                  *(_QWORD *)&v534[12] = v226;
                  v535 = 1024;
                  v536 = 214;
                  v537 = 2114;
                  v538 = v210;
                  v539 = 2114;
                  v540 = v227;
                  _os_log_impl((void *)&_mh_execute_header, v222, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i [L-ICF] %{public}@ = %{public}@", v533, 0x36u);

                }
              }
              v207 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v551, buf, 16);
            }
            while (v207);
          }

          v93 = v519;
        }
        v228 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v229 = NFLogGetLogger(v228);
        if (v229)
        {
          v230 = (void (*)(uint64_t, const char *, ...))v229;
          v231 = object_getClass(v134);
          v232 = class_isMetaClass(v231);
          v486 = object_getClassName(v134);
          v503 = sel_getName("_decodeFelicaStateEvent:");
          v233 = 45;
          if (v232)
            v233 = 43;
          v230(6, "%c[%{public}s %{public}s]:%i %{public}@", v233, v486, v503, 217, v517);
        }
        v234 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v235 = NFSharedLogGetLogger(v234);
        v236 = objc_claimAutoreleasedReturnValue(v235);
        v138 = v517;
        if (os_log_type_enabled(v236, OS_LOG_TYPE_DEFAULT))
        {
          v237 = object_getClass(v134);
          if (class_isMetaClass(v237))
            v238 = 43;
          else
            v238 = 45;
          v239 = object_getClassName(v134);
          v240 = sel_getName("_decodeFelicaStateEvent:");
          *(_DWORD *)v533 = 67110146;
          *(_DWORD *)&v533[4] = v238;
          *(_WORD *)v534 = 2082;
          *(_QWORD *)&v534[2] = v239;
          *(_WORD *)&v534[10] = 2082;
          *(_QWORD *)&v534[12] = v240;
          v535 = 1024;
          v536 = 217;
          v537 = 2114;
          v538 = v517;
          _os_log_impl((void *)&_mh_execute_header, v236, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", v533, 0x2Cu);
        }

        v30 = v525;
        v147 = v516;
      }
      else
      {
        v138 = v136;
        v139 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v140 = NFLogGetLogger(v139);
        if (v140)
        {
          v141 = (void (*)(uint64_t, const char *, ...))v140;
          v142 = object_getClass(v134);
          v143 = class_isMetaClass(v142);
          v483 = object_getClassName(v134);
          v498 = sel_getName("_decodeFelicaStateEvent:");
          v144 = 45;
          if (v143)
            v144 = 43;
          v141(3, "%c[%{public}s %{public}s]:%i Unexpected HCI event: %{public}@", v144, v483, v498, 205, v136);
        }
        v145 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v146 = NFSharedLogGetLogger(v145);
        v147 = objc_claimAutoreleasedReturnValue(v146);
        if (os_log_type_enabled(v147, OS_LOG_TYPE_ERROR))
        {
          v148 = object_getClass(v134);
          if (class_isMetaClass(v148))
            v149 = 43;
          else
            v149 = 45;
          v150 = object_getClassName(v134);
          v151 = sel_getName("_decodeFelicaStateEvent:");
          *(_DWORD *)v533 = 67110146;
          *(_DWORD *)&v533[4] = v149;
          *(_WORD *)v534 = 2082;
          *(_QWORD *)&v534[2] = v150;
          *(_WORD *)&v534[10] = 2082;
          *(_QWORD *)&v534[12] = v151;
          v535 = 1024;
          v536 = 205;
          v537 = 2114;
          v538 = v138;
          _os_log_impl((void *)&_mh_execute_header, v147, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unexpected HCI event: %{public}@", v533, 0x2Cu);
        }
        v30 = 0;
      }

      if (!v30)
        goto LABEL_100;
      v41 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithDictionary:", v30);
      v241 = *(void **)(v93 + 40);
      if (v241)
        v44 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(v241, "NF_asHexString"));
      else
        v44 = &stru_1002ED8A8;
      objc_msgSend(v41, "setObject:forKey:", v44, CFSTR("NFAppletAID"));
      v327 = *(_QWORD *)(v93 + 32);
      v328 = *(_QWORD *)(v327 + 32);
      if (v328 && (*(_QWORD *)(v328 + 272) & 0x200) != 0)
      {
        v329 = v30;
        v330 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v331 = NFLogGetLogger(v330);
        if (v331)
        {
          v332 = (void (*)(uint64_t, const char *, ...))v331;
          v333 = object_getClass(*(id *)(v93 + 32));
          v334 = class_isMetaClass(v333);
          v489 = object_getClassName(*(id *)(v93 + 32));
          v507 = sel_getName(*(SEL *)(v93 + 56));
          v335 = 45;
          if (v334)
            v335 = 43;
          v332(6, "%c[%{public}s %{public}s]:%i stateInfo: %{public}@", v335, v489, v507, 941, v41);
        }
        v336 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v337 = NFSharedLogGetLogger(v336);
        v338 = objc_claimAutoreleasedReturnValue(v337);
        if (os_log_type_enabled(v338, OS_LOG_TYPE_DEFAULT))
        {
          v339 = object_getClass(*(id *)(v93 + 32));
          if (class_isMetaClass(v339))
            v340 = 43;
          else
            v340 = 45;
          v341 = object_getClassName(*(id *)(v93 + 32));
          v342 = sel_getName(*(SEL *)(v93 + 56));
          *(_DWORD *)buf = 67110146;
          v542 = v340;
          v543 = 2082;
          v544 = v341;
          v545 = 2082;
          v546 = v342;
          v547 = 1024;
          v548 = 941;
          v549 = 2114;
          *(_QWORD *)v550 = v41;
          _os_log_impl((void *)&_mh_execute_header, v338, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i stateInfo: %{public}@", buf, 0x2Cu);
        }

        v327 = *(_QWORD *)(v93 + 32);
        v30 = v329;
      }
      v343 = objc_loadWeakRetained((id *)(v327 + 40));
      objc_msgSend(v343, "handleFelicaStateEvent:appletAID:", v41, v44);

LABEL_268:
      goto LABEL_100;
    }
    sub_1000CF870(*(_QWORD **)(v93 + 32), *(void **)(v93 + 48));
    return;
  }
  v280 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v281 = NFLogGetLogger(v280);
  if (v281)
  {
    v282 = (void (*)(uint64_t, const char *, ...))v281;
    v283 = object_getClass(*(id *)(v93 + 32));
    v284 = class_isMetaClass(v283);
    v285 = object_getClassName(*(id *)(v93 + 32));
    v286 = sel_getName(*(SEL *)(v93 + 56));
    v287 = 45;
    if (v284)
      v287 = 43;
    v282(4, "%c[%{public}s %{public}s]:%i SE reset : %{public}@ - %{public}@", v287, v285, v286, 905, *(_QWORD *)(v93 + 40), *(_QWORD *)(v93 + 48));
  }
  v288 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v289 = NFSharedLogGetLogger(v288);
  v290 = objc_claimAutoreleasedReturnValue(v289);
  if (os_log_type_enabled(v290, OS_LOG_TYPE_ERROR))
  {
    v291 = object_getClass(*(id *)(v93 + 32));
    if (class_isMetaClass(v291))
      v292 = 43;
    else
      v292 = 45;
    v293 = object_getClassName(*(id *)(v93 + 32));
    v294 = sel_getName(*(SEL *)(v93 + 56));
    v295 = *(_QWORD *)(v93 + 40);
    v296 = *(_QWORD *)(v93 + 48);
    *(_DWORD *)buf = 67110402;
    v542 = v292;
    v543 = 2082;
    v544 = v293;
    v545 = 2082;
    v546 = v294;
    v547 = 1024;
    v548 = 905;
    v549 = 2114;
    *(_QWORD *)v550 = v295;
    *(_WORD *)&v550[8] = 2114;
    *(_QWORD *)&v550[10] = v296;
    _os_log_impl((void *)&_mh_execute_header, v290, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i SE reset : %{public}@ - %{public}@", buf, 0x36u);
  }

  v298 = NFSharedSignpostLog(v297);
  v299 = objc_claimAutoreleasedReturnValue(v298);
  if (os_signpost_enabled(v299))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v299, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "HCI SE Reset", "", buf, 2u);
  }

}

void sub_1000D38FC(uint64_t a1)
{
  id obj;

  obj = *(id *)(a1 + 32);
  objc_sync_enter(obj);
  *(_DWORD *)(*(_QWORD *)(a1 + 32) + 8) = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(*(_QWORD *)(a1 + 32) + 12) = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(*(_QWORD *)(a1 + 32) + 16) = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(*(_QWORD *)(a1 + 32) + 20) = *(_DWORD *)(a1 + 52);
  objc_sync_exit(obj);

}

void sub_1000D3FA4(void *a1)
{
  void *v2;
  id v3;
  NSHashTable *v4;
  void *v5;
  id v6;
  id v7;
  uint64_t v8;
  void *v9;
  void *v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  _BYTE v15[128];

  if (a1)
  {
    v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "fieldDetectSessions"));
    v3 = objc_msgSend(v2, "count");

    if (v3)
    {
      v4 = objc_opt_new(NSHashTable);
      v11 = 0u;
      v12 = 0u;
      v13 = 0u;
      v14 = 0u;
      v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "fieldDetectSessions", 0));
      v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
      if (v6)
      {
        v7 = v6;
        v8 = *(_QWORD *)v12;
        do
        {
          v9 = 0;
          do
          {
            if (*(_QWORD *)v12 != v8)
              objc_enumerationMutation(v5);
            if (!*(_QWORD *)(*((_QWORD *)&v11 + 1) + 8 * (_QWORD)v9))
              -[NSHashTable addObject:](v4, "addObject:", 0);
            v9 = (char *)v9 + 1;
          }
          while (v7 != v9);
          v7 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
        }
        while (v7);
      }

      v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "fieldDetectSessions"));
      objc_msgSend(v10, "minusHashTable:", v4);

    }
  }
}

id sub_1000D452C(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "maybeStartNextSession");
}

id sub_1000D46A4(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "maybeStartNextSession");
}

id sub_1000D60B8(uint64_t a1)
{
  id v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  id v14;
  id v15;
  id v16;
  uint64_t v17;
  id v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  id v30;
  id v32;
  void *v33;
  void *v34;
  id v35;
  id v36;
  id v37;
  id v38;
  id v39;

  objc_opt_self(a1);
  v1 = objc_alloc((Class)NSSet);
  v2 = objc_opt_class(NSArray);
  v3 = objc_opt_class(NSMutableArray);
  v39 = objc_msgSend(v1, "initWithObjects:", v2, v3, objc_opt_class(NFApplet), 0);
  v37 = objc_alloc((Class)NSSet);
  v4 = objc_opt_class(NSString);
  v5 = objc_opt_class(NSMutableString);
  v6 = objc_opt_class(NSNumber);
  v7 = objc_opt_class(NSDate);
  v8 = objc_opt_class(NSDateComponents);
  v9 = objc_opt_class(NSData);
  v10 = objc_opt_class(NSMutableData);
  v11 = objc_opt_class(NSArray);
  v12 = objc_opt_class(NSMutableArray);
  v13 = objc_opt_class(NSDictionary);
  v14 = objc_msgSend(v37, "initWithObjects:", v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, objc_opt_class(NSMutableDictionary), 0);
  v15 = objc_msgSend(objc_alloc((Class)NSSet), "initWithObjects:", objc_opt_class(NFApplet), 0);
  v16 = objc_alloc((Class)NSSet);
  v17 = objc_opt_class(NSDictionary);
  v38 = objc_msgSend(v16, "initWithObjects:", v17, objc_opt_class(NSString), 0);
  v36 = objc_msgSend(objc_alloc((Class)NSSet), "initWithObjects:", objc_opt_class(NSData), 0);
  v18 = objc_alloc((Class)NSSet);
  v19 = objc_opt_class(NSSet);
  v35 = objc_msgSend(v18, "initWithObjects:", v19, objc_opt_class(NSString), 0);
  v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSXPCInterface interfaceWithProtocol:](NSXPCInterface, "interfaceWithProtocol:", &OBJC_PROTOCOL___NFContactlessPaymentSessionInterface));
  objc_msgSend(v20, "setClasses:forSelector:argumentIndex:ofReply:", v15, "setActivePaymentApplet:keys:authorization:completion:", 0, 0);
  objc_msgSend(v20, "setClasses:forSelector:argumentIndex:ofReply:", v15, "setActivePaymentApplet:keys:authorization:completion:", 0, 1);
  objc_msgSend(v20, "setClasses:forSelector:argumentIndex:ofReply:", v38, "setActivePaymentApplets:authorization:completion:", 0, 0);
  objc_msgSend(v20, "setClasses:forSelector:argumentIndex:ofReply:", v36, "setActivePaymentApplets:authorization:completion:", 1, 0);
  v34 = v15;
  objc_msgSend(v20, "setClasses:forSelector:argumentIndex:ofReply:", v15, "setActivePaymentApplets:authorization:completion:", 0, 1);
  objc_msgSend(v20, "setClasses:forSelector:argumentIndex:ofReply:", v35, "setActivePaymentApplets:authorization:completion:", 1, 1);
  objc_msgSend(v20, "setClasses:forSelector:argumentIndex:ofReply:", v39, "getAppletsWithCompletion:", 0, 1);
  objc_msgSend(v20, "setClasses:forSelector:argumentIndex:ofReply:", v15, "getAppletsWithCompletion:", 1, 1);
  objc_msgSend(v20, "setClasses:forSelector:argumentIndex:ofReply:", v39, "getFelicaAppletState:completion:", 0, 0);
  v33 = v14;
  objc_msgSend(v20, "setClasses:forSelector:argumentIndex:ofReply:", v14, "getFelicaAppletState:completion:", 0, 1);
  objc_msgSend(v20, "setClasses:forSelector:argumentIndex:ofReply:", v39, "getTransitAppletState:completion:", 0, 0);
  objc_msgSend(v20, "setClasses:forSelector:argumentIndex:ofReply:", v14, "getTransitAppletState:completion:", 0, 1);
  v32 = objc_alloc((Class)NSSet);
  v21 = objc_opt_class(NSArray);
  v22 = objc_opt_class(NSMutableArray);
  v23 = objc_opt_class(NSData);
  v24 = objc_opt_class(NSMutableData);
  v25 = objc_opt_class(NSDictionary);
  v26 = objc_opt_class(NSMutableDictionary);
  v27 = objc_opt_class(NSString);
  v28 = objc_opt_class(NSMutableString);
  v29 = objc_opt_class(NSNumber);
  v30 = objc_msgSend(v32, "initWithObjects:", v21, v22, v23, v24, v25, v26, v27, v28, v29, objc_opt_class(NFValueAddedServiceCard), 0);
  objc_msgSend(v20, "setClasses:forSelector:argumentIndex:ofReply:", v30, "setHostCards:", 0, 0);

  return v20;
}

id sub_1000D6594(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  id v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  id v20;
  uint64_t v22;
  uint64_t v23;
  id v24;
  id v25;
  void *v26;

  objc_opt_self(a1);
  v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSXPCInterface interfaceWithProtocol:](NSXPCInterface, "interfaceWithProtocol:", &OBJC_PROTOCOL___NFContactlessPaymentSessionCallbacks));
  v24 = objc_alloc((Class)NSSet);
  v22 = objc_opt_class(NSArray);
  v1 = objc_opt_class(NSMutableArray);
  v2 = objc_opt_class(NSData);
  v3 = objc_opt_class(NSMutableData);
  v4 = objc_opt_class(NSDictionary);
  v5 = objc_opt_class(NSMutableDictionary);
  v6 = objc_opt_class(NSString);
  v7 = objc_opt_class(NSMutableString);
  v8 = objc_opt_class(NSNumber);
  v9 = objc_opt_class(NSError);
  v10 = objc_msgSend(v24, "initWithObjects:", v22, v1, v2, v3, v4, v5, v6, v7, v8, v9, objc_opt_class(NFValueAddedServiceTransaction), 0);
  objc_msgSend(v26, "setClasses:forSelector:argumentIndex:ofReply:", v10, "didPerformValueAddedServiceTransactions:", 0, 0);
  v25 = objc_alloc((Class)NSSet);
  v23 = objc_opt_class(NSString);
  v11 = objc_opt_class(NSMutableString);
  v12 = objc_opt_class(NSNumber);
  v13 = objc_opt_class(NSDate);
  v14 = objc_opt_class(NSDateComponents);
  v15 = objc_opt_class(NSData);
  v16 = objc_opt_class(NSMutableData);
  v17 = objc_opt_class(NSArray);
  v18 = objc_opt_class(NSMutableArray);
  v19 = objc_opt_class(NSDictionary);
  v20 = objc_msgSend(v25, "initWithObjects:", v23, v11, v12, v13, v14, v15, v16, v17, v18, v19, objc_opt_class(NSMutableDictionary), 0);
  objc_msgSend(v26, "setClasses:forSelector:argumentIndex:ofReply:", v20, "didFelicaStateChange:", 0, 0);

  return v26;
}

void sub_1000D6F10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000D6F24(uint64_t a1)
{
  id WeakRetained;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  void *v7;
  void *specific;
  uint64_t Logger;
  void (*v10)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  NSObject *v19;
  objc_class *v20;
  int v21;
  const char *v22;
  const char *v23;
  void *v24;
  void *v25;
  void *v26;
  id v27;
  uint64_t v28;
  void (*v29)(uint64_t, const char *, ...);
  objc_class *v30;
  _BOOL4 v31;
  const char *v32;
  const char *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  NSObject *v37;
  objc_class *v38;
  int v39;
  const char *v40;
  const char *v41;
  void *v42;
  uint8_t buf[4];
  _BYTE v44[14];
  __int16 v45;
  const char *v46;
  __int16 v47;
  int v48;
  __int16 v49;
  void *v50;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v3 = WeakRetained;
  if (WeakRetained && (objc_msgSend(WeakRetained, "didEnd") & 1) == 0)
  {
    v4 = kdebug_trace(724566224, 0, 0, 0, 0);
    v5 = NFSharedSignpostLog(v4);
    v6 = objc_claimAutoreleasedReturnValue(v5);
    if (os_signpost_enabled(v6))
    {
      v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "clientName"));
      *(_DWORD *)buf = 138412290;
      *(_QWORD *)v44 = v7;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v6, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "TAG_SESSION_START_EMULATION", "starting Tag Emulation session for client %@", buf, 0xCu);

    }
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v10 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "clientName"));
      v16 = 45;
      if (isMetaClass)
        v16 = 43;
      v10(6, "%c[%{public}s %{public}s]:%i %{public}@", v16, ClassName, Name, 95, v15);

    }
    v17 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v18 = NFSharedLogGetLogger(v17);
    v19 = objc_claimAutoreleasedReturnValue(v18);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      v20 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v20))
        v21 = 43;
      else
        v21 = 45;
      v22 = object_getClassName(*(id *)(a1 + 32));
      v23 = sel_getName(*(SEL *)(a1 + 48));
      v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "clientName"));
      *(_DWORD *)buf = 67110146;
      *(_DWORD *)v44 = v21;
      *(_WORD *)&v44[4] = 2082;
      *(_QWORD *)&v44[6] = v22;
      v45 = 2082;
      v46 = v23;
      v47 = 1024;
      v48 = 95;
      v49 = 2114;
      v50 = v24;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);

    }
    v25 = (void *)objc_claimAutoreleasedReturnValue(+[_NFHardwareManager sharedHardwareManager](_NFHardwareManager, "sharedHardwareManager"));
    v26 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig hostCardEmulation](NFRoutingConfig, "hostCardEmulation"));
    v27 = objc_msgSend(v25, "setRoutingConfig:", v26);

    v28 = NFLogGetLogger(2);
    if (v28)
    {
      v29 = (void (*)(uint64_t, const char *, ...))v28;
      v30 = object_getClass(*(id *)(a1 + 32));
      v31 = class_isMetaClass(v30);
      v32 = object_getClassName(*(id *)(a1 + 32));
      v33 = sel_getName(*(SEL *)(a1 + 48));
      v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "clientName"));
      v35 = 45;
      if (v31)
        v35 = 43;
      v29(6, "%c[%{public}s %{public}s]:%i NFC emulation mode activated: %@", v35, v32, v33, 98, v34);

    }
    v36 = NFSharedLogGetLogger(2);
    v37 = objc_claimAutoreleasedReturnValue(v36);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      v38 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v38))
        v39 = 43;
      else
        v39 = 45;
      v40 = object_getClassName(*(id *)(a1 + 32));
      v41 = sel_getName(*(SEL *)(a1 + 48));
      v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "clientName"));
      *(_DWORD *)buf = 67110146;
      *(_DWORD *)v44 = v39;
      *(_WORD *)&v44[4] = 2082;
      *(_QWORD *)&v44[6] = v40;
      v45 = 2082;
      v46 = v41;
      v47 = 1024;
      v48 = 98;
      v49 = 2112;
      v50 = v42;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i NFC emulation mode activated: %@", buf, 0x2Cu);

    }
  }

}

void sub_1000D8C28(_Unwind_Exception *a1)
{
  uint64_t v1;

  objc_destroyWeak((id *)(v1 - 176));
  _Unwind_Resume(a1);
}

void sub_1000D8C44(uint64_t a1)
{
  id WeakRetained;
  id v3;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    v3 = WeakRetained;
    objc_msgSend(WeakRetained, "_handleOneAPDU:", *(_QWORD *)(a1 + 32));
    WeakRetained = v3;
  }

}

void sub_1000D8DE4(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  void *specific;
  uint64_t Logger;
  void (*v7)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  NSObject *v16;
  objc_class *v17;
  int v18;
  const char *v19;
  const char *v20;
  void *v21;
  void *v22;
  uint64_t v23;
  void (*v24)(uint64_t, const char *, ...);
  objc_class *v25;
  _BOOL4 v26;
  const char *v27;
  const char *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  NSObject *v33;
  objc_class *v34;
  int v35;
  const char *v36;
  const char *v37;
  void *v38;
  uint64_t v39;
  id v40;
  NSObject *v41;
  void *v42;
  void *v43;
  id v44;
  void *v45;
  void *v46;
  void *v47;
  id v48;
  uint64_t v49;
  void (*v50)(uint64_t, const char *, ...);
  objc_class *v51;
  _BOOL4 v52;
  const char *v53;
  const char *v54;
  void *v55;
  uint64_t v56;
  uint64_t v57;
  NSObject *v58;
  objc_class *v59;
  int v60;
  const char *v61;
  const char *v62;
  void *v63;
  uint64_t v64;
  id v65;
  void *v66;
  void *v67;
  id v68;
  uint64_t v69;
  uint64_t v70;
  NSErrorUserInfoKey v71;
  void *v72;
  NSErrorUserInfoKey v73;
  void *v74;
  uint8_t buf[4];
  int v76;
  __int16 v77;
  const char *v78;
  __int16 v79;
  const char *v80;
  __int16 v81;
  int v82;
  __int16 v83;
  void *v84;

  v2 = kdebug_trace(724566224, 0, 0, 0, 0);
  v3 = NFSharedSignpostLog(v2);
  v4 = objc_claimAutoreleasedReturnValue(v3);
  if (os_signpost_enabled(v4))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "TAG_SESSION_START_EMULATION", "begin", buf, 2u);
  }

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v7 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v13 = 45;
    if (isMetaClass)
      v13 = 43;
    v7(6, "%c[%{public}s %{public}s]:%i %{public}@", v13, ClassName, Name, 276, v12);

  }
  v14 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v15 = NFSharedLogGetLogger(v14);
  v16 = objc_claimAutoreleasedReturnValue(v15);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    v17 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v17))
      v18 = 43;
    else
      v18 = 45;
    v19 = object_getClassName(*(id *)(a1 + 32));
    v20 = sel_getName(*(SEL *)(a1 + 56));
    v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    *(_DWORD *)buf = 67110146;
    v76 = v18;
    v77 = 2082;
    v78 = v19;
    v79 = 2082;
    v80 = v20;
    v81 = 1024;
    v82 = 276;
    v83 = 2114;
    v84 = v21;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);

  }
  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v45 = *(void **)(a1 + 40);
    if (v45)
    {
      sub_1000A9E0C(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 168), v45);
      v46 = (void *)objc_claimAutoreleasedReturnValue(+[_NFHardwareManager sharedHardwareManager](_NFHardwareManager, "sharedHardwareManager"));
      v47 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig hostCardEmulation](NFRoutingConfig, "hostCardEmulation"));
      v48 = objc_msgSend(v46, "setRoutingConfig:", v47);

      (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
      v49 = NFLogGetLogger(2);
      if (v49)
      {
        v50 = (void (*)(uint64_t, const char *, ...))v49;
        v51 = object_getClass(*(id *)(a1 + 32));
        v52 = class_isMetaClass(v51);
        v53 = object_getClassName(*(id *)(a1 + 32));
        v54 = sel_getName(*(SEL *)(a1 + 56));
        v55 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
        v56 = 45;
        if (v52)
          v56 = 43;
        v50(6, "%c[%{public}s %{public}s]:%i NFC emulation mode activated: %@", v56, v53, v54, 290, v55);

      }
      v57 = NFSharedLogGetLogger(2);
      v58 = objc_claimAutoreleasedReturnValue(v57);
      if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
      {
        v59 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v59))
          v60 = 43;
        else
          v60 = 45;
        v61 = object_getClassName(*(id *)(a1 + 32));
        v62 = sel_getName(*(SEL *)(a1 + 56));
        v63 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
        *(_DWORD *)buf = 67110146;
        v76 = v60;
        v77 = 2082;
        v78 = v61;
        v79 = 2082;
        v80 = v62;
        v81 = 1024;
        v82 = 290;
        v83 = 2112;
        v84 = v63;
        _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i NFC emulation mode activated: %@", buf, 0x2Cu);

      }
    }
    else
    {
      v64 = *(_QWORD *)(a1 + 48);
      v65 = objc_alloc((Class)NSError);
      v58 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v71 = NSLocalizedDescriptionKey;
      v66 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid Parameter"));
      v72 = v66;
      v67 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v72, &v71, 1));
      v68 = objc_msgSend(v65, "initWithDomain:code:userInfo:", v58, 10, v67);
      (*(void (**)(uint64_t, id))(v64 + 16))(v64, v68);

    }
    v69 = kdebug_trace(724566224, 0, 0, 0, 0);
    v70 = NFSharedSignpostLog(v69);
    v41 = objc_claimAutoreleasedReturnValue(v70);
    if (os_signpost_enabled(v41))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v41, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "TAG_SESSION_START_EMULATION", "end", buf, 2u);
    }
    goto LABEL_26;
  }
  v22 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v23 = NFLogGetLogger(v22);
  if (v23)
  {
    v24 = (void (*)(uint64_t, const char *, ...))v23;
    v25 = object_getClass(*(id *)(a1 + 32));
    v26 = class_isMetaClass(v25);
    v27 = object_getClassName(*(id *)(a1 + 32));
    v28 = sel_getName(*(SEL *)(a1 + 56));
    v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v30 = 45;
    if (v26)
      v30 = 43;
    v24(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v30, v27, v28, 278, v29);

  }
  v31 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v32 = NFSharedLogGetLogger(v31);
  v33 = objc_claimAutoreleasedReturnValue(v32);
  if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
  {
    v34 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v34))
      v35 = 43;
    else
      v35 = 45;
    v36 = object_getClassName(*(id *)(a1 + 32));
    v37 = sel_getName(*(SEL *)(a1 + 56));
    v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v76 = v35;
    v77 = 2082;
    v78 = v36;
    v79 = 2082;
    v80 = v37;
    v81 = 1024;
    v82 = 278;
    v83 = 2114;
    v84 = v38;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v39 = *(_QWORD *)(a1 + 48);
  if (v39)
  {
    v40 = objc_alloc((Class)NSError);
    v41 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v73 = NSLocalizedDescriptionKey;
    v42 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v74 = v42;
    v43 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v74, &v73, 1));
    v44 = objc_msgSend(v40, "initWithDomain:code:userInfo:", v41, 54, v43);
    (*(void (**)(uint64_t, id))(v39 + 16))(v39, v44);

LABEL_26:
  }
}

void sub_1000D95D0(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  void *v19;
  uint64_t v20;
  void (*v21)(uint64_t, const char *, ...);
  objc_class *v22;
  _BOOL4 v23;
  const char *v24;
  const char *v25;
  void *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  NSObject *v30;
  objc_class *v31;
  int v32;
  const char *v33;
  const char *v34;
  void *v35;
  uint64_t v36;
  id v37;
  NSObject *v38;
  void *v39;
  void *v40;
  id v41;
  void *v42;
  void *v43;
  id v44;
  uint64_t v45;
  void (*v46)(uint64_t, const char *, ...);
  objc_class *v47;
  _BOOL4 v48;
  const char *v49;
  const char *v50;
  void *v51;
  uint64_t v52;
  uint64_t v53;
  objc_class *v54;
  int v55;
  const char *v56;
  const char *v57;
  void *v58;
  NSErrorUserInfoKey v59;
  void *v60;
  uint8_t buf[4];
  int v62;
  __int16 v63;
  const char *v64;
  __int16 v65;
  const char *v66;
  __int16 v67;
  int v68;
  __int16 v69;
  void *v70;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v10 = 45;
    if (isMetaClass)
      v10 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@", v10, ClassName, Name, 300, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 48));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    *(_DWORD *)buf = 67110146;
    v62 = v15;
    v63 = 2082;
    v64 = v16;
    v65 = 2082;
    v66 = v17;
    v67 = 1024;
    v68 = 300;
    v69 = 2114;
    v70 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);

  }
  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v42 = (void *)objc_claimAutoreleasedReturnValue(+[_NFHardwareManager sharedHardwareManager](_NFHardwareManager, "sharedHardwareManager"));
    v43 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig routingOff](NFRoutingConfig, "routingOff"));
    v44 = objc_msgSend(v42, "setRoutingConfig:", v43);

    (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
    v45 = NFLogGetLogger(2);
    if (v45)
    {
      v46 = (void (*)(uint64_t, const char *, ...))v45;
      v47 = object_getClass(*(id *)(a1 + 32));
      v48 = class_isMetaClass(v47);
      v49 = object_getClassName(*(id *)(a1 + 32));
      v50 = sel_getName(*(SEL *)(a1 + 48));
      v51 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
      v52 = 45;
      if (v48)
        v52 = 43;
      v46(6, "%c[%{public}s %{public}s]:%i NFC emulation mode terminated: %@", v52, v49, v50, 307, v51);

    }
    v53 = NFSharedLogGetLogger(2);
    v38 = objc_claimAutoreleasedReturnValue(v53);
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
    {
      v54 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v54))
        v55 = 43;
      else
        v55 = 45;
      v56 = object_getClassName(*(id *)(a1 + 32));
      v57 = sel_getName(*(SEL *)(a1 + 48));
      v58 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
      *(_DWORD *)buf = 67110146;
      v62 = v55;
      v63 = 2082;
      v64 = v56;
      v65 = 2082;
      v66 = v57;
      v67 = 1024;
      v68 = 307;
      v69 = 2112;
      v70 = v58;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i NFC emulation mode terminated: %@", buf, 0x2Cu);

    }
    goto LABEL_24;
  }
  v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v20 = NFLogGetLogger(v19);
  if (v20)
  {
    v21 = (void (*)(uint64_t, const char *, ...))v20;
    v22 = object_getClass(*(id *)(a1 + 32));
    v23 = class_isMetaClass(v22);
    v24 = object_getClassName(*(id *)(a1 + 32));
    v25 = sel_getName(*(SEL *)(a1 + 48));
    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v27 = 45;
    if (v23)
      v27 = 43;
    v21(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v27, v24, v25, 301, v26);

  }
  v28 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v29 = NFSharedLogGetLogger(v28);
  v30 = objc_claimAutoreleasedReturnValue(v29);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
  {
    v31 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v31))
      v32 = 43;
    else
      v32 = 45;
    v33 = object_getClassName(*(id *)(a1 + 32));
    v34 = sel_getName(*(SEL *)(a1 + 48));
    v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v62 = v32;
    v63 = 2082;
    v64 = v33;
    v65 = 2082;
    v66 = v34;
    v67 = 1024;
    v68 = 301;
    v69 = 2114;
    v70 = v35;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v36 = *(_QWORD *)(a1 + 40);
  if (v36)
  {
    v37 = objc_alloc((Class)NSError);
    v38 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v59 = NSLocalizedDescriptionKey;
    v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v60 = v39;
    v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v60, &v59, 1));
    v41 = objc_msgSend(v37, "initWithDomain:code:userInfo:", v38, 54, v40);
    (*(void (**)(uint64_t, id))(v36 + 16))(v36, v41);

LABEL_24:
  }
}

void sub_1000D9C34(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  void *v19;
  uint64_t v20;
  void (*v21)(uint64_t, const char *, ...);
  objc_class *v22;
  _BOOL4 v23;
  const char *v24;
  const char *v25;
  void *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  NSObject *v30;
  objc_class *v31;
  int v32;
  const char *v33;
  const char *v34;
  void *v35;
  uint64_t v36;
  id v37;
  void *v38;
  void *v39;
  void *v40;
  id v41;
  NSErrorUserInfoKey v42;
  void *v43;
  uint8_t buf[4];
  int v45;
  __int16 v46;
  const char *v47;
  __int16 v48;
  const char *v49;
  __int16 v50;
  int v51;
  __int16 v52;
  void *v53;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v10 = 45;
    if (isMetaClass)
      v10 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@", v10, ClassName, Name, 314, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 56));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    *(_DWORD *)buf = 67110146;
    v45 = v15;
    v46 = 2082;
    v47 = v16;
    v48 = 2082;
    v49 = v17;
    v50 = 1024;
    v51 = 314;
    v52 = 2114;
    v53 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);

  }
  if (!objc_msgSend(*(id *)(a1 + 32), "didStart")
    || (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) != 0
    || objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v20 = NFLogGetLogger(v19);
    if (v20)
    {
      v21 = (void (*)(uint64_t, const char *, ...))v20;
      v22 = object_getClass(*(id *)(a1 + 32));
      v23 = class_isMetaClass(v22);
      v24 = object_getClassName(*(id *)(a1 + 32));
      v25 = sel_getName(*(SEL *)(a1 + 56));
      v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      v27 = 45;
      if (v23)
        v27 = 43;
      v21(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v27, v24, v25, 315, v26);

    }
    v28 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v29 = NFSharedLogGetLogger(v28);
    v30 = objc_claimAutoreleasedReturnValue(v29);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      v31 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v31))
        v32 = 43;
      else
        v32 = 45;
      v33 = object_getClassName(*(id *)(a1 + 32));
      v34 = sel_getName(*(SEL *)(a1 + 56));
      v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      *(_DWORD *)buf = 67110146;
      v45 = v32;
      v46 = 2082;
      v47 = v33;
      v48 = 2082;
      v49 = v34;
      v50 = 1024;
      v51 = 315;
      v52 = 2114;
      v53 = v35;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

    }
    v36 = *(_QWORD *)(a1 + 48);
    if (v36)
    {
      v37 = objc_alloc((Class)NSError);
      v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v42 = NSLocalizedDescriptionKey;
      v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
      v43 = v39;
      v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v43, &v42, 1));
      v41 = objc_msgSend(v37, "initWithDomain:code:userInfo:", v38, 54, v40);
      (*(void (**)(uint64_t, id))(v36 + 16))(v36, v41);

    }
  }
  else
  {
    sub_1000A9E0C(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 168), *(void **)(a1 + 40));
    (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
  }
}

void sub_1000DA0FC(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  void *v19;
  uint64_t v20;
  void (*v21)(uint64_t, const char *, ...);
  objc_class *v22;
  _BOOL4 v23;
  const char *v24;
  const char *v25;
  void *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  NSObject *v30;
  objc_class *v31;
  int v32;
  const char *v33;
  const char *v34;
  void *v35;
  uint64_t v36;
  id v37;
  void *v38;
  void *v39;
  void *v40;
  id v41;
  uint64_t v42;
  NSData *v43;
  NSErrorUserInfoKey v44;
  void *v45;
  uint8_t buf[4];
  int v47;
  __int16 v48;
  const char *v49;
  __int16 v50;
  const char *v51;
  __int16 v52;
  int v53;
  __int16 v54;
  void *v55;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v10 = 45;
    if (isMetaClass)
      v10 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@", v10, ClassName, Name, 326, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 48));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    *(_DWORD *)buf = 67110146;
    v47 = v15;
    v48 = 2082;
    v49 = v16;
    v50 = 2082;
    v51 = v17;
    v52 = 1024;
    v53 = 326;
    v54 = 2114;
    v55 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);

  }
  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v42 = *(_QWORD *)(a1 + 40);
    v43 = sub_1000AA15C(*(id **)(*(_QWORD *)(a1 + 32) + 168));
    v38 = (void *)objc_claimAutoreleasedReturnValue(v43);
    (*(void (**)(uint64_t, void *, _QWORD))(v42 + 16))(v42, v38, 0);
    goto LABEL_24;
  }
  v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v20 = NFLogGetLogger(v19);
  if (v20)
  {
    v21 = (void (*)(uint64_t, const char *, ...))v20;
    v22 = object_getClass(*(id *)(a1 + 32));
    v23 = class_isMetaClass(v22);
    v24 = object_getClassName(*(id *)(a1 + 32));
    v25 = sel_getName(*(SEL *)(a1 + 48));
    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v27 = 45;
    if (v23)
      v27 = 43;
    v21(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v27, v24, v25, 327, v26);

  }
  v28 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v29 = NFSharedLogGetLogger(v28);
  v30 = objc_claimAutoreleasedReturnValue(v29);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
  {
    v31 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v31))
      v32 = 43;
    else
      v32 = 45;
    v33 = object_getClassName(*(id *)(a1 + 32));
    v34 = sel_getName(*(SEL *)(a1 + 48));
    v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v47 = v32;
    v48 = 2082;
    v49 = v33;
    v50 = 2082;
    v51 = v34;
    v52 = 1024;
    v53 = 327;
    v54 = 2114;
    v55 = v35;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v36 = *(_QWORD *)(a1 + 40);
  if (v36)
  {
    v37 = objc_alloc((Class)NSError);
    v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v44 = NSLocalizedDescriptionKey;
    v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v45 = v39;
    v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v45, &v44, 1));
    v41 = objc_msgSend(v37, "initWithDomain:code:userInfo:", v38, 54, v40);
    (*(void (**)(uint64_t, _QWORD, id))(v36 + 16))(v36, 0, v41);

LABEL_24:
  }
}

void sub_1000DA5E4(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  void *v19;
  uint64_t v20;
  void (*v21)(uint64_t, const char *, ...);
  objc_class *v22;
  _BOOL4 v23;
  const char *v24;
  const char *v25;
  void *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  NSObject *v30;
  objc_class *v31;
  int v32;
  const char *v33;
  const char *v34;
  void *v35;
  uint64_t v36;
  id v37;
  void *v38;
  void *v39;
  void *v40;
  id v41;
  uint64_t v42;
  NSErrorUserInfoKey v43;
  void *v44;
  uint8_t buf[4];
  int v46;
  __int16 v47;
  const char *v48;
  __int16 v49;
  const char *v50;
  __int16 v51;
  int v52;
  __int16 v53;
  void *v54;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v10 = 45;
    if (isMetaClass)
      v10 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@", v10, ClassName, Name, 336, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 48));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    *(_DWORD *)buf = 67110146;
    v46 = v15;
    v47 = 2082;
    v48 = v16;
    v49 = 2082;
    v50 = v17;
    v51 = 1024;
    v52 = 336;
    v53 = 2114;
    v54 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);

  }
  if (!objc_msgSend(*(id *)(a1 + 32), "didStart")
    || (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) != 0
    || objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v20 = NFLogGetLogger(v19);
    if (v20)
    {
      v21 = (void (*)(uint64_t, const char *, ...))v20;
      v22 = object_getClass(*(id *)(a1 + 32));
      v23 = class_isMetaClass(v22);
      v24 = object_getClassName(*(id *)(a1 + 32));
      v25 = sel_getName(*(SEL *)(a1 + 48));
      v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      v27 = 45;
      if (v23)
        v27 = 43;
      v21(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v27, v24, v25, 337, v26);

    }
    v28 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v29 = NFSharedLogGetLogger(v28);
    v30 = objc_claimAutoreleasedReturnValue(v29);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      v31 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v31))
        v32 = 43;
      else
        v32 = 45;
      v33 = object_getClassName(*(id *)(a1 + 32));
      v34 = sel_getName(*(SEL *)(a1 + 48));
      v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      *(_DWORD *)buf = 67110146;
      v46 = v32;
      v47 = 2082;
      v48 = v33;
      v49 = 2082;
      v50 = v34;
      v51 = 1024;
      v52 = 337;
      v53 = 2114;
      v54 = v35;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

    }
    v36 = *(_QWORD *)(a1 + 40);
    if (v36)
    {
      v37 = objc_alloc((Class)NSError);
      v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v43 = NSLocalizedDescriptionKey;
      v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
      v44 = v39;
      v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v44, &v43, 1));
      v41 = objc_msgSend(v37, "initWithDomain:code:userInfo:", v38, 54, v40);
      (*(void (**)(uint64_t, id))(v36 + 16))(v36, v41);

    }
  }
  else
  {
    v42 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 168);
    if (v42)
    {
      *(_BYTE *)(v42 + 29) = *(_BYTE *)(a1 + 56);
      sub_1000A8E6C(v42);
    }
    (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
  }
}

void sub_1000DAA84(id a1)
{
  _NFHardwareManager *v1;
  void *v2;

  v1 = objc_alloc_init(_NFHardwareManager);
  v2 = (void *)qword_10032A9D8;
  qword_10032A9D8 = (uint64_t)v1;

}

void sub_1000DAFA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id location)
{
  id *v22;

  objc_destroyWeak(v22);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000DAFE8(uint64_t a1)
{
  NSObject *v2;
  void **WeakRetained;
  double v4;
  id v5;
  void *v6;
  void *specific;
  uint64_t Logger;
  void (*v9)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  NSObject *v15;
  objc_class *v16;
  int v17;
  const char *v18;
  const char *v19;
  _QWORD *v20;
  char v21;
  void *v22;
  uint64_t v23;
  void (*v24)(uint64_t, const char *, ...);
  objc_class *v25;
  _BOOL4 v26;
  const char *v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  NSObject *v31;
  objc_class *v32;
  int v33;
  const char *v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  NSObject *v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  void *v42;
  id v43;
  uint64_t v44;
  void *v45;
  void *v46;
  id v47;
  void *v48;
  void *v49;
  uint64_t v50;
  void (*v51)(uint64_t, const char *, ...);
  objc_class *v52;
  _BOOL4 v53;
  const char *v54;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  NSObject *v58;
  objc_class *v59;
  int v60;
  const char *v61;
  const char *v62;
  uint64_t v63;
  NSObject *v64;
  const char *ClassName;
  const char *Name;
  const char *v67;
  const char *v68;
  void **state;
  _BYTE state_8[40];

  v2 = _os_activity_create((void *)&_mh_execute_header, "com.apple.nfcd.hw.postStartupTimer", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  state = 0;
  *(_QWORD *)state_8 = 0;
  os_activity_scope_enter(v2, (os_activity_scope_state_t)&state);
  os_activity_scope_leave((os_activity_scope_state_t)&state);

  WeakRetained = (void **)objc_loadWeakRetained((id *)(a1 + 40));
  v4 = sub_1000DB680((uint64_t)WeakRetained);
  if (v4 > 0.0)
    goto LABEL_40;
  v5 = sub_1001F84C8(WeakRetained[46], CFSTR("runPostStartupWork"), 1uLL);
  v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
  if (v6)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v9 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      v12 = 45;
      if (isMetaClass)
        v12 = 43;
      v9(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v12, ClassName, Name, 397, v6);
    }
    v13 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v14 = NFSharedLogGetLogger(v13);
    v15 = objc_claimAutoreleasedReturnValue(v14);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      v16 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v16))
        v17 = 43;
      else
        v17 = 45;
      v18 = object_getClassName(*(id *)(a1 + 32));
      v19 = sel_getName(*(SEL *)(a1 + 48));
      LODWORD(state) = 67110146;
      HIDWORD(state) = v17;
      *(_WORD *)state_8 = 2082;
      *(_QWORD *)&state_8[2] = v18;
      *(_WORD *)&state_8[10] = 2082;
      *(_QWORD *)&state_8[12] = v19;
      *(_WORD *)&state_8[20] = 1024;
      *(_DWORD *)&state_8[22] = 397;
      *(_WORD *)&state_8[26] = 2112;
      *(_QWORD *)&state_8[28] = v6;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", (uint8_t *)&state, 0x2Cu);
    }

  }
  v20 = WeakRetained[46];
  if (v20)
  {
    switch(v20[37])
    {
      case 1:
        if (!WeakRetained[16])
          goto LABEL_37;
        v22 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v23 = NFLogGetLogger(v22);
        if (v23)
        {
          v24 = (void (*)(uint64_t, const char *, ...))v23;
          v25 = object_getClass(WeakRetained);
          v26 = class_isMetaClass(v25);
          v27 = object_getClassName(WeakRetained);
          v67 = sel_getName("doPostStartupWork");
          v28 = 45;
          if (v26)
            v28 = 43;
          v24(6, "%c[%{public}s %{public}s]:%i Running post stack bootup work", v28, v27, v67, 732);
        }
        v29 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v30 = NFSharedLogGetLogger(v29);
        v31 = objc_claimAutoreleasedReturnValue(v30);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
        {
          v32 = object_getClass(WeakRetained);
          if (class_isMetaClass(v32))
            v33 = 43;
          else
            v33 = 45;
          v34 = object_getClassName(WeakRetained);
          v35 = sel_getName("doPostStartupWork");
          LODWORD(state) = 67109890;
          HIDWORD(state) = v33;
          *(_WORD *)state_8 = 2082;
          *(_QWORD *)&state_8[2] = v34;
          *(_WORD *)&state_8[10] = 2082;
          *(_QWORD *)&state_8[12] = v35;
          *(_WORD *)&state_8[20] = 1024;
          *(_DWORD *)&state_8[22] = 732;
          _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Running post stack bootup work", (uint8_t *)&state, 0x22u);
        }

        v37 = NFSharedSignpostLog(v36);
        v38 = objc_claimAutoreleasedReturnValue(v37);
        if (os_signpost_enabled(v38))
        {
          LOWORD(state) = 0;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v38, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "DUMP_LOGS_BOOTUP", "", (uint8_t *)&state, 2u);
        }

        v40 = NFIsInternalBuild(v39);
        if ((v40 & 1) != 0 || *((_BYTE *)WeakRetained + 350))
        {
          v41 = WeakRetained[29];
          v42 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig embeddedWiredMode](NFRoutingConfig, "embeddedWiredMode"));
          state = _NSConcreteStackBlock;
          *(_QWORD *)state_8 = 3221225472;
          *(_QWORD *)&state_8[8] = sub_1000E7DBC;
          *(_QWORD *)&state_8[16] = &unk_1002E5C30;
          *(_QWORD *)&state_8[24] = WeakRetained;
          *(_QWORD *)&state_8[32] = "dumpLPEMAppletLogs";
          v43 = +[_NFBuiltinSession createSessionWithWorkQueue:routing:sessionQueuer:didStartWork:](_NFBuiltinSession, "createSessionWithWorkQueue:routing:sessionQueuer:didStartWork:", v41, v42, WeakRetained, &state);

        }
        else
        {
          v63 = NFSharedSignpostLog(v40);
          v64 = objc_claimAutoreleasedReturnValue(v63);
          if (os_signpost_enabled(v64))
          {
            LOWORD(state) = 0;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v64, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "DUMP_LOGS_BOOTUP", "", (uint8_t *)&state, 2u);
          }

        }
        if (NFIsInternalBuild(v44))
        {
          v45 = WeakRetained[29];
          v46 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig embeddedWiredMode](NFRoutingConfig, "embeddedWiredMode"));
          state = _NSConcreteStackBlock;
          *(_QWORD *)state_8 = 3221225472;
          *(_QWORD *)&state_8[8] = sub_1000DFD10;
          *(_QWORD *)&state_8[16] = &unk_1002E5C30;
          *(_QWORD *)&state_8[24] = WeakRetained;
          *(_QWORD *)&state_8[32] = "cacheSeMemory";
          v47 = +[_NFBuiltinSession createSessionWithWorkQueue:routing:sessionQueuer:didStartWork:](_NFBuiltinSession, "createSessionWithWorkQueue:routing:sessionQueuer:didStartWork:", v45, v46, WeakRetained, &state);

        }
LABEL_36:
        v48 = WeakRetained[16];
        WeakRetained[16] = 0;

LABEL_37:
        v21 = 1;
        if (!v6)
          goto LABEL_38;
        goto LABEL_39;
      case 2:
      case 4:
        v21 = 0;
        v4 = 60.0;
        if (!v6)
          goto LABEL_38;
        goto LABEL_39;
      case 3:
        goto LABEL_36;
      default:
        break;
    }
  }
  v21 = 0;
  if (!v6)
LABEL_38:
    sub_1001FABB8(WeakRetained[46], CFSTR("runPostStartupWork"));
LABEL_39:

  if ((v21 & 1) == 0)
  {
LABEL_40:
    v49 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v50 = NFLogGetLogger(v49);
    if (v50)
    {
      v51 = (void (*)(uint64_t, const char *, ...))v50;
      v52 = object_getClass(WeakRetained);
      v53 = class_isMetaClass(v52);
      v54 = object_getClassName(WeakRetained);
      v68 = sel_getName(*(SEL *)(a1 + 48));
      v55 = 45;
      if (v53)
        v55 = 43;
      v51(6, "%c[%{public}s %{public}s]:%i Delaying post stack bootup work by %f seconds", v55, v54, v68, 417, *(_QWORD *)&v4);
    }
    v56 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v57 = NFSharedLogGetLogger(v56);
    v58 = objc_claimAutoreleasedReturnValue(v57);
    if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
    {
      v59 = object_getClass(WeakRetained);
      if (class_isMetaClass(v59))
        v60 = 43;
      else
        v60 = 45;
      v61 = object_getClassName(WeakRetained);
      v62 = sel_getName(*(SEL *)(a1 + 48));
      LODWORD(state) = 67110146;
      HIDWORD(state) = v60;
      *(_WORD *)state_8 = 2082;
      *(_QWORD *)&state_8[2] = v61;
      *(_WORD *)&state_8[10] = 2082;
      *(_QWORD *)&state_8[12] = v62;
      *(_WORD *)&state_8[20] = 1024;
      *(_DWORD *)&state_8[22] = 417;
      *(_WORD *)&state_8[26] = 2048;
      *(double *)&state_8[28] = v4;
      _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Delaying post stack bootup work by %f seconds", (uint8_t *)&state, 0x2Cu);
    }

    objc_msgSend(WeakRetained[16], "startTimer:", v4);
  }

}

double sub_1000DB680(uint64_t a1)
{
  double v1;
  uint64_t v3;

  v1 = 0.0;
  if (a1 && *(_QWORD *)(a1 + 128))
  {
    if (sub_10000993C(*(void **)(a1 + 88)))
    {
      v1 = 20.0;
      if (!*(_QWORD *)(a1 + 112) && !objc_msgSend(*(id *)(a1 + 184), "count"))
      {
        v3 = *(_QWORD *)(a1 + 24);
        if (!v3 || !*(_BYTE *)(v3 + 172))
        {
          if (*(_BYTE *)(a1 + 346))
            return 20.0;
          else
            return 0.0;
        }
      }
    }
    else
    {
      return 60.0;
    }
  }
  return v1;
}

void sub_1000DBB00(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000DBB28(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  uint64_t v3;
  _QWORD v5[6];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2020000000;
  v9 = 0;
  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(NSObject **)(v1 + 232);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_1000DBBB8;
  v5[3] = &unk_1002E5EA8;
  v5[4] = v1;
  v5[5] = &v6;
  dispatch_async_and_wait(v2, v5);
  v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_1000DBBB8(uint64_t a1)
{
  _DWORD *v2;
  NSMutableDictionary *v3;
  void *v4;
  void *v5;
  id v6;
  void *specific;
  uint64_t Logger;
  void (*v9)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  NSObject *v15;
  objc_class *v16;
  int v17;
  const char *v18;
  const char *v19;
  id v20;
  id v21;
  const char *ClassName;
  const char *Name;
  id v24;
  uint8_t buf[4];
  int v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  int v32;
  __int16 v33;
  id v34;

  v2 = *(_DWORD **)(a1 + 32);
  if (v2)
  {
    v3 = sub_1000EF900(*(_QWORD *)(a1 + 32));
    v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
    v24 = 0;
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSPropertyListSerialization dataWithPropertyList:format:options:error:](NSPropertyListSerialization, "dataWithPropertyList:format:options:error:", v4, 200, 0, &v24));
    v6 = v24;

    if (v6)
    {
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v9 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(v2);
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(v2);
        Name = sel_getName("dumpState");
        v12 = 45;
        if (isMetaClass)
          v12 = 43;
        v9(3, "%c[%{public}s %{public}s]:%i Failed to serialize state dump: %{public}@", v12, ClassName, Name, 8765, v6);
      }
      v13 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v14 = NFSharedLogGetLogger(v13);
      v15 = objc_claimAutoreleasedReturnValue(v14);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        v16 = object_getClass(v2);
        if (class_isMetaClass(v16))
          v17 = 43;
        else
          v17 = 45;
        v18 = object_getClassName(v2);
        v19 = sel_getName("dumpState");
        *(_DWORD *)buf = 67110146;
        v26 = v17;
        v27 = 2082;
        v28 = v18;
        v29 = 2082;
        v30 = v19;
        v31 = 1024;
        v32 = 8765;
        v33 = 2114;
        v34 = v6;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to serialize state dump: %{public}@", buf, 0x2Cu);
      }

    }
    v20 = objc_msgSend(v5, "length");
    v2 = malloc_type_calloc(1uLL, (size_t)v20 + 200, 0xBCAD8F46uLL);
    *v2 = 1;
    v2[1] = (_DWORD)v20;
    __strlcpy_chk(v2 + 34, "nfcd state", 64, 64);
    v21 = objc_retainAutorelease(v5);
    memcpy(v2 + 50, objc_msgSend(v21, "bytes"), (size_t)v20);

  }
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = v2;
}

void sub_1000DBE28(void *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  void *specific;
  uint64_t Logger;
  void (*v8)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  objc_class *v15;
  int v16;
  const char *v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  void (*v23)(uint64_t, const char *, ...);
  objc_class *v24;
  _BOOL4 v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  NSObject *v29;
  objc_class *v30;
  int v31;
  const char *v32;
  const char *v33;
  const char *v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;
  uint64_t v38;
  void (*v39)(uint64_t, const char *, ...);
  objc_class *v40;
  _BOOL4 v41;
  uint64_t v42;
  void *v43;
  uint64_t v44;
  objc_class *v45;
  int v46;
  const char *v47;
  const char *v48;
  void *v49;
  void *v50;
  void *v51;
  const char *ClassName;
  const char *v53;
  const char *v54;
  const char *Name;
  const char *v56;
  const char *v57;
  int out_token;
  uint8_t buf[4];
  int v60;
  __int16 v61;
  const char *v62;
  __int16 v63;
  const char *v64;
  __int16 v65;
  int v66;
  __int16 v67;
  int v68;

  if (a1 && dword_100329778 != (_DWORD)a2)
  {
    dword_100329778 = a2;
    out_token = 0;
    v4 = notify_register_check("com.apple.stockholm.sessions.active", &out_token);
    if ((_DWORD)v4)
    {
      v5 = v4;
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v8 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(a1);
        Name = sel_getName("_postActiveSessionsNotification:");
        v11 = 45;
        if (isMetaClass)
          v11 = 43;
        v8(3, "%c[%{public}s %{public}s]:%i Failed to notify register check : %d", v11, ClassName, Name, 1300, v5);
      }
      v12 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v13 = NFSharedLogGetLogger(v12);
      v14 = objc_claimAutoreleasedReturnValue(v13);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        v15 = object_getClass(a1);
        if (class_isMetaClass(v15))
          v16 = 43;
        else
          v16 = 45;
        v17 = object_getClassName(a1);
        v18 = sel_getName("_postActiveSessionsNotification:");
        *(_DWORD *)buf = 67110146;
        v60 = v16;
        v61 = 2082;
        v62 = v17;
        v63 = 2082;
        v64 = v18;
        v65 = 1024;
        v66 = 1300;
        v67 = 1024;
        v68 = v5;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to notify register check : %d", buf, 0x28u);
      }

      goto LABEL_37;
    }
    v19 = notify_set_state(out_token, dword_100329778);
    if ((_DWORD)v19)
    {
      v20 = v19;
      v21 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v22 = NFLogGetLogger(v21);
      if (v22)
      {
        v23 = (void (*)(uint64_t, const char *, ...))v22;
        v24 = object_getClass(a1);
        v25 = class_isMetaClass(v24);
        v53 = object_getClassName(a1);
        v56 = sel_getName("_postActiveSessionsNotification:");
        v26 = 45;
        if (v25)
          v26 = 43;
        v23(3, "%c[%{public}s %{public}s]:%i Failed to notify set state : %d", v26, v53, v56, 1294, v20);
      }
      v27 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v28 = NFSharedLogGetLogger(v27);
      v29 = objc_claimAutoreleasedReturnValue(v28);
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        goto LABEL_35;
      v30 = object_getClass(a1);
      if (class_isMetaClass(v30))
        v31 = 43;
      else
        v31 = 45;
      v32 = object_getClassName(a1);
      v33 = sel_getName("_postActiveSessionsNotification:");
      *(_DWORD *)buf = 67110146;
      v60 = v31;
      v61 = 2082;
      v62 = v32;
      v63 = 2082;
      v64 = v33;
      v65 = 1024;
      v66 = 1294;
      v67 = 1024;
      v68 = v20;
      v34 = "%c[%{public}s %{public}s]:%i Failed to notify set state : %d";
    }
    else
    {
      v35 = notify_post("com.apple.stockholm.sessions.active");
      if (!(_DWORD)v35)
      {
LABEL_36:
        notify_cancel(out_token);
LABEL_37:
        v49 = (void *)objc_claimAutoreleasedReturnValue(+[NFSecureXPCEventPublisherManager sharedManager](NFSecureXPCEventPublisherManager, "sharedManager"));
        v50 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v49, "wallet"));
        v51 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", a2));
        objc_msgSend(v50, "sendSimpleEvent:objectNumber:", CFSTR("com.apple.stockholm.sessions.active"), v51);

        return;
      }
      v36 = v35;
      v37 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v38 = NFLogGetLogger(v37);
      if (v38)
      {
        v39 = (void (*)(uint64_t, const char *, ...))v38;
        v40 = object_getClass(a1);
        v41 = class_isMetaClass(v40);
        v54 = object_getClassName(a1);
        v57 = sel_getName("_postActiveSessionsNotification:");
        v42 = 45;
        if (v41)
          v42 = 43;
        v39(3, "%c[%{public}s %{public}s]:%i Failed to notify : %d", v42, v54, v57, 1290, v36);
      }
      v43 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v44 = NFSharedLogGetLogger(v43);
      v29 = objc_claimAutoreleasedReturnValue(v44);
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
LABEL_35:

        goto LABEL_36;
      }
      v45 = object_getClass(a1);
      if (class_isMetaClass(v45))
        v46 = 43;
      else
        v46 = 45;
      v47 = object_getClassName(a1);
      v48 = sel_getName("_postActiveSessionsNotification:");
      *(_DWORD *)buf = 67110146;
      v60 = v46;
      v61 = 2082;
      v62 = v47;
      v63 = 2082;
      v64 = v48;
      v65 = 1024;
      v66 = 1290;
      v67 = 1024;
      v68 = v36;
      v34 = "%c[%{public}s %{public}s]:%i Failed to notify : %d";
    }
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, v34, buf, 0x28u);
    goto LABEL_35;
  }
}

void sub_1000DC2B4(uint64_t a1)
{
  uint64_t *v2;
  id v3;
  BOOL v4;
  uint64_t v5;
  int v6;
  void *specific;
  void (*Logger)(uint64_t, const char *, ...);
  objc_class *Class;
  uint64_t v11;
  const char *ClassName;
  const char *Name;
  void *v14;
  uint64_t v15;
  NSObject *v16;
  objc_class *v17;
  int v18;
  const char *v19;
  const char *v20;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  void *v26;
  _QWORD v27[7];
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  int v31;
  uint8_t buf[4];
  int v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  const char *v37;
  __int16 v38;
  int v39;

  v2 = (uint64_t *)(a1 + 32);
  sub_1000DC5B0(*(NSMutableDictionary **)(a1 + 32), 0);
  v28 = 0;
  v29 = &v28;
  v30 = 0x2020000000;
  v31 = 0;
  v31 = -[_NFHardwareManager getPrimaryHardwareState]_0(*v2);
  sub_1000DE4E0((id *)*v2, *((unsigned int *)v29 + 6));
  v3 = *(id *)(a1 + 32);
  objc_sync_enter(v3);
  v4 = *(_BYTE *)(*(_QWORD *)(a1 + 32) + 337) == 0;
  objc_sync_exit(v3);

  if (!v4)
  {
    v6 = *((_DWORD *)v29 + 6);
    if (v6 == 2 || v6 == 4)
    {
      sub_1000DF168(*(_QWORD **)(a1 + 32));
    }
    else if (*(_BYTE *)(*(_QWORD *)(a1 + 32) + 354))
    {
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(specific);
      if (Logger)
      {
        Class = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(Class))
          v11 = 43;
        else
          v11 = 45;
        ClassName = object_getClassName(*(id *)(a1 + 32));
        Name = sel_getName(*(SEL *)(a1 + 40));
        Logger(4, "%c[%{public}s %{public}s]:%i FailForward disabled - skipping HW recovery", v11, ClassName, Name, 498);
      }
      v14 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v15 = NFSharedLogGetLogger(v14);
      v16 = objc_claimAutoreleasedReturnValue(v15);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        v17 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v17))
          v18 = 43;
        else
          v18 = 45;
        v19 = object_getClassName(*(id *)(a1 + 32));
        v20 = sel_getName(*(SEL *)(a1 + 40));
        *(_DWORD *)buf = 67109890;
        v33 = v18;
        v34 = 2082;
        v35 = v19;
        v36 = 2082;
        v37 = v20;
        v38 = 1024;
        v39 = 498;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i FailForward disabled - skipping HW recovery", buf, 0x22u);
      }

    }
    else
    {
      v21 = NFSharedSignpostLog(v5);
      v22 = objc_claimAutoreleasedReturnValue(v21);
      if (os_signpost_enabled(v22))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v22, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "HWRecovery", "begin", buf, 2u);
      }

      v23 = *(_QWORD *)(a1 + 32);
      v24 = *(_QWORD *)(a1 + 40);
      v25 = *(_QWORD **)(v23 + 368);
      v26 = *(void **)(v23 + 232);
      v27[0] = _NSConcreteStackBlock;
      v27[1] = 3221225472;
      v27[2] = sub_1000DE724;
      v27[3] = &unk_1002E7F00;
      v27[4] = v23;
      v27[5] = &v28;
      v27[6] = v24;
      sub_10014C1E4(v25, v26, v27);
    }
  }
  _Block_object_dispose(&v28, 8);
}

void sub_1000DC580(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000DC5B0(NSMutableDictionary *a1, int a2)
{
  _UNKNOWN **v4;
  void *v5;
  id *v6;
  Class isa;
  uint64_t v8;
  NSMutableDictionary *v9;
  void *v10;
  Class v11;
  void *specific;
  uint64_t Logger;
  void (*v14)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  NSObject *v21;
  objc_class *v22;
  int v23;
  unsigned int v24;
  NSMutableDictionary *v25;
  int v26;
  void *v27;
  uint64_t v28;
  void (*v29)(uint64_t, const char *, ...);
  objc_class *v30;
  _BOOL4 v31;
  const char *v32;
  uint64_t v33;
  void *v34;
  uint64_t v35;
  NSObject *v36;
  objc_class *v37;
  int v38;
  const char *v39;
  const char *v40;
  uint64_t v41;
  uint64_t v42;
  NSMutableDictionary *v43;
  void *v44;
  uint64_t v45;
  void (*v46)(uint64_t, const char *, ...);
  objc_class *v47;
  _BOOL4 v48;
  unsigned int v49;
  const char *v50;
  uint64_t v51;
  void *v52;
  uint64_t v53;
  NSObject *v54;
  objc_class *v55;
  int v56;
  const char *v57;
  const char *v58;
  dispatch_queue_global_t global_queue;
  id v60;
  uint64_t v61;
  id v62;
  void *v63;
  uint64_t v64;
  void (*v65)(uint64_t, const char *, ...);
  objc_class *v66;
  _BOOL4 v67;
  uint64_t v68;
  void *v69;
  uint64_t v70;
  NSObject *v71;
  objc_class *v72;
  int v73;
  const char *v74;
  const char *v75;
  id v76;
  void *v77;
  id v78;
  uint64_t v79;
  void *v80;
  void *v81;
  uint64_t v82;
  void (*v83)(uint64_t, const char *, ...);
  objc_class *v84;
  _BOOL4 v85;
  uint64_t v86;
  void *v87;
  uint64_t v88;
  NSObject *v89;
  objc_class *v90;
  int v91;
  const char *v92;
  const char *v93;
  void *v94;
  void *v95;
  id v96;
  void *v97;
  const char *v98;
  uint64_t v99;
  void *v100;
  id v101;
  id v102;
  void *v103;
  id v104;
  id v105;
  void *v106;
  id v107;
  id v108;
  void *v109;
  void *v110;
  uint64_t v111;
  void (*v112)(uint64_t, const char *, ...);
  objc_class *v113;
  _BOOL4 v114;
  const char *v115;
  uint64_t v116;
  void *v117;
  uint64_t v118;
  NSObject *v119;
  objc_class *v120;
  int v121;
  const char *v122;
  const char *v123;
  id v124;
  void *v125;
  void *v126;
  id v127;
  id v128;
  void *v129;
  void *v130;
  uint64_t v131;
  void (*v132)(uint64_t, const char *, ...);
  objc_class *v133;
  _BOOL4 v134;
  const char *v135;
  uint64_t v136;
  void *v137;
  uint64_t v138;
  objc_class *v139;
  int v140;
  const char *v141;
  const char *v142;
  Class v143;
  Class v144;
  uint64_t v145;
  void *v146;
  unsigned __int16 *v147;
  id v148;
  void *v149;
  void *v150;
  void (*v151)(uint64_t, const char *, ...);
  void *v152;
  uint64_t v153;
  NSObject *v154;
  int v155;
  id *p_isa;
  NFSecureElementHandle *v157;
  NFSecureElementWrapper *v158;
  Class v159;
  void *v160;
  uint64_t v161;
  void (*v162)(uint64_t, const char *, ...);
  objc_class *v163;
  _BOOL4 v164;
  const char *v165;
  const char *v166;
  uint64_t v167;
  void *v168;
  uint64_t v169;
  NSObject *v170;
  objc_class *v171;
  int v172;
  const char *v173;
  const char *v174;
  unsigned int v175;
  void *v176;
  void *v177;
  uint64_t v178;
  void (*v179)(uint64_t, const char *, ...);
  objc_class *v180;
  _BOOL4 v181;
  uint64_t v182;
  void *v183;
  uint64_t v184;
  NSObject *v185;
  objc_class *v186;
  int v187;
  const char *v188;
  const char *v189;
  Class v190;
  char v191;
  id v192;
  void *v193;
  uint64_t v194;
  void (*v195)(uint64_t, const char *, ...);
  objc_class *v196;
  _BOOL4 v197;
  const char *v198;
  uint64_t v199;
  void *v200;
  uint64_t v201;
  NSObject *v202;
  objc_class *v203;
  int v204;
  const char *v205;
  const char *v206;
  void *v207;
  uint64_t v208;
  void (*v209)(uint64_t, const char *, ...);
  objc_class *v210;
  _BOOL4 v211;
  const char *v212;
  const char *v213;
  uint64_t v214;
  void *v215;
  uint64_t v216;
  NSObject *v217;
  objc_class *v218;
  int v219;
  const char *v220;
  const char *v221;
  unsigned int v222;
  unsigned int v223;
  id v224;
  NSString *v225;
  void *v226;
  id v227;
  void *v228;
  unsigned __int8 v229;
  void *v230;
  unsigned int v231;
  void *v232;
  uint64_t v233;
  NSMutableArray *v234;
  NSMutableArray *v235;
  id v236;
  void *v237;
  uint64_t v238;
  void (*v239)(uint64_t, const char *, ...);
  objc_class *v240;
  _BOOL4 v241;
  uint64_t v242;
  void *v243;
  uint64_t v244;
  NSObject *v245;
  objc_class *v246;
  int v247;
  const char *v248;
  const char *v249;
  void *v250;
  NSMutableArray *v251;
  NSMutableArray *v252;
  void *v253;
  void *v254;
  void *v255;
  id v256;
  void *v257;
  void *v258;
  void *v259;
  void *v260;
  id v261;
  id v262;
  void *v263;
  id v264;
  void *v265;
  void *v266;
  uint64_t v267;
  void (*v268)(uint64_t, const char *, ...);
  objc_class *v269;
  _BOOL4 v270;
  uint64_t v271;
  void *v272;
  uint64_t v273;
  NSObject *v274;
  objc_class *v275;
  int v276;
  const char *v277;
  const char *v278;
  void *v279;
  uint64_t v280;
  void (*v281)(uint64_t, const char *, ...);
  objc_class *v282;
  _BOOL4 v283;
  const char *v284;
  uint64_t v285;
  void *v286;
  uint64_t v287;
  NSObject *v288;
  objc_class *v289;
  int v290;
  const char *v291;
  const char *v292;
  NFKeyBag *v293;
  Class v294;
  Class v295;
  Class v296;
  void *v297;
  const char *v298;
  const char *v299;
  const char *v300;
  const char *v301;
  const char *v302;
  const char *v303;
  const char *Name;
  const char *v305;
  const char *v306;
  const char *v307;
  const char *v308;
  const char *v309;
  const char *v310;
  const char *v311;
  const char *v312;
  const char *v313;
  const char *v314;
  const char *v315;
  id v316;
  id v317;
  id v318;
  void *v319;
  id v320;
  NFSecureElementHandle *v321;
  unsigned int v322;
  SEL sel;
  _QWORD v324[5];
  _BYTE buf[48];
  const char *v326;
  uint8_t v327[8];
  _BYTE v328[26];
  uint8_t v329[8];
  _BYTE v330[32];

  if (!a1)
    return;
  v4 = &AMFDRSealingMapCopyLocalData_ptr;
  v5 = (void *)objc_claimAutoreleasedReturnValue(+[NFPowerAssertion sharedPowerAssertion](NFPowerAssertion, "sharedPowerAssertion"));
  objc_msgSend(v5, "holdPowerAssertion:", CFSTR("Load Stack"));

  if (!a1[10].super.super.isa)
  {
    v6 = sub_100218344((id *)[NFManagedConfigMonitor alloc], a1[29].super.super.isa, a1);
    isa = a1[10].super.super.isa;
    a1[10].super.super.isa = (Class)v6;

  }
  v8 = (uint64_t)a1[46].super.super.isa;
  v9 = sub_1000E194C(a1);
  v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
  sub_1001FB714(v8, v10);

  v11 = a1[46].super.super.isa;
  if (!v11 || (*((_BYTE *)v11 + 218) & 1) == 0)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v14 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("_loadDriverConfigsFromDisk");
      v18 = 45;
      if (isMetaClass)
        v18 = 43;
      v14(6, "%c[%{public}s %{public}s]:%i clearing persistent field detect, device does not have antenna", v18, ClassName, Name, 922);
    }
    v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v20 = NFSharedLogGetLogger(v19);
    v21 = objc_claimAutoreleasedReturnValue(v20);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      v22 = object_getClass(a1);
      if (class_isMetaClass(v22))
        v23 = 43;
      else
        v23 = 45;
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)&buf[4] = v23;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = object_getClassName(a1);
      *(_WORD *)&buf[18] = 2082;
      *(_QWORD *)&buf[20] = sel_getName("_loadDriverConfigsFromDisk");
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 922;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i clearing persistent field detect, device does not have antenna", buf, 0x22u);
    }

    -[objc_class removeAllPersistentFieldObservers](a1[2].super.super.isa, "removeAllPersistentFieldObservers");
  }
  sub_1000DE88C((void **)&a1->super.super.isa, CFSTR("Load HW"));
  v24 = -[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)a1);
  v25 = a1;
  objc_sync_enter(v25);
  v26 = BYTE1(v25[42].super.super.isa);
  objc_sync_exit(v25);

  if (v24 == 4)
  {
    v27 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v28 = NFLogGetLogger(v27);
    if (v28)
    {
      v29 = (void (*)(uint64_t, const char *, ...))v28;
      v30 = object_getClass(v25);
      v31 = class_isMetaClass(v30);
      v32 = object_getClassName(v25);
      v305 = sel_getName("_updateSystemHealth:reportFailure:");
      v33 = 45;
      if (v31)
        v33 = 43;
      v29(5, "%c[%{public}s %{public}s]:%i NFC/SE not supported on this device", v33, v32, v305, 967);
    }
    v34 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v35 = NFSharedLogGetLogger(v34);
    v36 = objc_claimAutoreleasedReturnValue(v35);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
    {
      v37 = object_getClass(v25);
      if (class_isMetaClass(v37))
        v38 = 43;
      else
        v38 = 45;
      v39 = object_getClassName(v25);
      v40 = sel_getName("_updateSystemHealth:reportFailure:");
      *(_DWORD *)v329 = 67109890;
      *(_DWORD *)&v329[4] = v38;
      *(_WORD *)v330 = 2082;
      *(_QWORD *)&v330[2] = v39;
      *(_WORD *)&v330[10] = 2082;
      *(_QWORD *)&v330[12] = v40;
      *(_WORD *)&v330[20] = 1024;
      *(_DWORD *)&v330[22] = 967;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i NFC/SE not supported on this device", v329, 0x22u);
    }

    goto LABEL_61;
  }
  v41 = sub_10011B964(0);
  if (!v26 || !v41)
  {
    v44 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v45 = NFLogGetLogger(v44);
    if (v45)
    {
      v46 = (void (*)(uint64_t, const char *, ...))v45;
      v47 = object_getClass(v25);
      v48 = class_isMetaClass(v47);
      v49 = v24;
      v50 = object_getClassName(v25);
      v306 = sel_getName("_updateSystemHealth:reportFailure:");
      v51 = 45;
      if (v48)
        v51 = 43;
      v298 = v50;
      v24 = v49;
      v46(4, "%c[%{public}s %{public}s]:%i missing system health library", v51, v298, v306, 1012);
    }
    v52 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v53 = NFSharedLogGetLogger(v52);
    v54 = objc_claimAutoreleasedReturnValue(v53);
    if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
    {
      v55 = object_getClass(v25);
      if (class_isMetaClass(v55))
        v56 = 43;
      else
        v56 = 45;
      v57 = object_getClassName(v25);
      v58 = sel_getName("_updateSystemHealth:reportFailure:");
      *(_DWORD *)v329 = 67109890;
      *(_DWORD *)&v329[4] = v56;
      *(_WORD *)v330 = 2082;
      *(_QWORD *)&v330[2] = v57;
      *(_WORD *)&v330[10] = 2082;
      *(_QWORD *)&v330[12] = v58;
      *(_WORD *)&v330[20] = 1024;
      *(_DWORD *)&v330[22] = 1012;
      _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i missing system health library", v329, 0x22u);
    }
    goto LABEL_46;
  }
  if (v24 == 2)
    v42 = 1;
  else
    v42 = 2;
  v43 = v25;
  objc_sync_enter(v43);
  if (v42 == qword_100329770)
  {
    objc_sync_exit(v43);

    goto LABEL_47;
  }
  objc_sync_exit(v43);

  if (v24 == 2 || a2)
  {
    global_queue = dispatch_get_global_queue(17, 0);
    v54 = objc_claimAutoreleasedReturnValue(global_queue);
    *(_QWORD *)buf = _NSConcreteStackBlock;
    *(_QWORD *)&buf[8] = 3221225472;
    *(_QWORD *)&buf[16] = sub_1000E32B0;
    *(_QWORD *)&buf[24] = &unk_1002E7DD8;
    *(_QWORD *)&buf[32] = v43;
    *(_QWORD *)&buf[40] = v42;
    v326 = "_updateSystemHealth:reportFailure:";
    dispatch_async(v54, buf);
LABEL_46:

  }
LABEL_47:
  if (v24 != 2 && v24 != 5)
  {
LABEL_61:
    v80 = (void *)objc_claimAutoreleasedReturnValue(+[NFPowerAssertion sharedPowerAssertion](NFPowerAssertion, "sharedPowerAssertion"));
    objc_msgSend(v80, "releasePowerAssertion:", CFSTR("Load Stack"));

    v81 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v82 = NFLogGetLogger(v81);
    if (v82)
    {
      v83 = (void (*)(uint64_t, const char *, ...))v82;
      v84 = object_getClass(v25);
      v85 = class_isMetaClass(v84);
      v300 = object_getClassName(v25);
      v308 = sel_getName("_initializeHardwareAndReportFailure:");
      v86 = 45;
      if (v85)
        v86 = 43;
      v83(4, "%c[%{public}s %{public}s]:%i Hardware not available : %lu", v86, v300, v308, 857, v24);
    }
    v87 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v88 = NFSharedLogGetLogger(v87);
    v89 = objc_claimAutoreleasedReturnValue(v88);
    if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
    {
      v90 = object_getClass(v25);
      if (class_isMetaClass(v90))
        v91 = 43;
      else
        v91 = 45;
      v92 = object_getClassName(v25);
      v93 = sel_getName("_initializeHardwareAndReportFailure:");
      *(_DWORD *)buf = 67110146;
      *(_DWORD *)&buf[4] = v91;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = v92;
      *(_WORD *)&buf[18] = 2082;
      *(_QWORD *)&buf[20] = v93;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 857;
      *(_WORD *)&buf[34] = 2048;
      *(_QWORD *)&buf[36] = v24;
      _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Hardware not available : %lu", buf, 0x2Cu);
    }

    return;
  }
  v322 = v24;
  v60 = sub_1001F84C8(a1[46].super.super.isa, CFSTR("Load HW Info"), 0);
  v61 = objc_claimAutoreleasedReturnValue(v60);
  if (v61)
  {
    v62 = (id)v61;
    v63 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v64 = NFLogGetLogger(v63);
    if (v64)
    {
      v65 = (void (*)(uint64_t, const char *, ...))v64;
      v66 = object_getClass(v25);
      v67 = class_isMetaClass(v66);
      v299 = object_getClassName(v25);
      v307 = sel_getName("_initializeSecureElementInfo");
      v68 = 45;
      if (v67)
        v68 = 43;
      v65(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v68, v299, v307, 1153, v62);
    }
    v69 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v70 = NFSharedLogGetLogger(v69);
    v71 = objc_claimAutoreleasedReturnValue(v70);
    if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
    {
      v72 = object_getClass(v25);
      if (class_isMetaClass(v72))
        v73 = 43;
      else
        v73 = 45;
      v74 = object_getClassName(v25);
      v75 = sel_getName("_initializeSecureElementInfo");
      *(_DWORD *)buf = 67110146;
      *(_DWORD *)&buf[4] = v73;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = v74;
      *(_WORD *)&buf[18] = 2082;
      *(_QWORD *)&buf[20] = v75;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 1153;
      *(_WORD *)&buf[34] = 2112;
      *(_QWORD *)&buf[36] = v62;
      _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
    }

    v76 = objc_alloc((Class)NSError);
    v77 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v78 = objc_msgSend(v62, "code");
    *(_QWORD *)v329 = NSLocalizedDescriptionKey;
    if ((uint64_t)objc_msgSend(v62, "code") > 70)
      v79 = 71;
    else
      v79 = (uint64_t)objc_msgSend(v62, "code");
    v100 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E7F70[v79]));
    *(_QWORD *)buf = v100;
    *(_QWORD *)&buf[8] = v62;
    *(_QWORD *)v330 = NSUnderlyingErrorKey;
    *(_QWORD *)&v330[8] = CFSTR("Line");
    *(_QWORD *)&buf[16] = &off_1002FEDF0;
    *(_QWORD *)&v330[16] = CFSTR("Method");
    v101 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_initializeSecureElementInfo"));
    *(_QWORD *)&buf[24] = v101;
    *(_QWORD *)&v330[24] = NSDebugDescriptionErrorKey;
    v102 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_initializeSecureElementInfo"), 1154);
    *(_QWORD *)&buf[32] = v102;
    v103 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, v329, 5));
    v104 = objc_msgSend(v76, "initWithDomain:code:userInfo:", v77, v78, v103);

    v4 = &AMFDRSealingMapCopyLocalData_ptr;
    goto LABEL_101;
  }
  v94 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig embeddedWiredModeWithFD:](NFRoutingConfig, "embeddedWiredModeWithFD:", 0));
  v95 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary setRoutingConfig:](v25, "setRoutingConfig:", v94));

  if (v95)
  {
    v96 = objc_alloc((Class)NSError);
    v97 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v98 = (const char *)objc_msgSend(v95, "code");
    *(_QWORD *)v329 = NSLocalizedDescriptionKey;
    sel = v98;
    if ((uint64_t)objc_msgSend(v95, "code") > 70)
      v99 = 71;
    else
      v99 = (uint64_t)objc_msgSend(v95, "code");
    v106 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E7F70[v99]));
    *(_QWORD *)buf = v106;
    *(_QWORD *)&buf[8] = v95;
    *(_QWORD *)v330 = NSUnderlyingErrorKey;
    *(_QWORD *)&v330[8] = CFSTR("Line");
    *(_QWORD *)&buf[16] = &off_1002FEE08;
    *(_QWORD *)&v330[16] = CFSTR("Method");
    v107 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_initializeSecureElementInfo"));
    *(_QWORD *)&buf[24] = v107;
    *(_QWORD *)&v330[24] = NSDebugDescriptionErrorKey;
    v108 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_initializeSecureElementInfo"), 1160);
    *(_QWORD *)&buf[32] = v108;
    v109 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, v329, 5));
    v105 = objc_msgSend(v96, "initWithDomain:code:userInfo:", v97, sel, v109);

    v110 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v111 = NFLogGetLogger(v110);
    if (v111)
    {
      v112 = (void (*)(uint64_t, const char *, ...))v111;
      v113 = object_getClass(v25);
      v114 = class_isMetaClass(v113);
      v115 = object_getClassName(v25);
      v309 = sel_getName("_initializeSecureElementInfo");
      v116 = 45;
      if (v114)
        v116 = 43;
      v112(3, "%c[%{public}s %{public}s]:%i Failed to set routing mode", v116, v115, v309, 1161);
    }
    v117 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v118 = NFSharedLogGetLogger(v117);
    v119 = objc_claimAutoreleasedReturnValue(v118);
    if (os_log_type_enabled(v119, OS_LOG_TYPE_ERROR))
    {
      v120 = object_getClass(v25);
      if (class_isMetaClass(v120))
        v121 = 43;
      else
        v121 = 45;
      v122 = object_getClassName(v25);
      v123 = sel_getName("_initializeSecureElementInfo");
      *(_DWORD *)v327 = 67109890;
      *(_DWORD *)&v327[4] = v121;
      *(_WORD *)v328 = 2082;
      *(_QWORD *)&v328[2] = v122;
      *(_WORD *)&v328[10] = 2082;
      *(_QWORD *)&v328[12] = v123;
      *(_WORD *)&v328[20] = 1024;
      *(_DWORD *)&v328[22] = 1161;
      _os_log_impl((void *)&_mh_execute_header, v119, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to set routing mode", v327, 0x22u);
    }
    v4 = &AMFDRSealingMapCopyLocalData_ptr;
LABEL_98:

    sub_1001FABB8(a1[46].super.super.isa, CFSTR("Load HW Info"));
    if (v105)
    {
      v143 = v25[48].super.super.isa;
      v25[48].super.super.isa = 0;

      v144 = v25[5].super.super.isa;
      v25[5].super.super.isa = 0;

    }
    goto LABEL_100;
  }
  if (!-[NSMutableDictionary refreshSecureElementInfo](v25, "refreshSecureElementInfo"))
  {
    v124 = objc_alloc((Class)NSError);
    v125 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    *(_QWORD *)v327 = NSLocalizedDescriptionKey;
    v126 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
    *(_QWORD *)v329 = v126;
    *(_QWORD *)v330 = &off_1002FEE20;
    *(_QWORD *)v328 = CFSTR("Line");
    *(_QWORD *)&v328[8] = CFSTR("Method");
    v127 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_initializeSecureElementInfo"));
    *(_QWORD *)&v330[8] = v127;
    *(_QWORD *)&v328[16] = NSDebugDescriptionErrorKey;
    v128 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_initializeSecureElementInfo"), 1166);
    *(_QWORD *)&v330[16] = v128;
    v129 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v329, v327, 4));
    v105 = objc_msgSend(v124, "initWithDomain:code:userInfo:", v125, 15, v129);

    v130 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v131 = NFLogGetLogger(v130);
    if (v131)
    {
      v132 = (void (*)(uint64_t, const char *, ...))v131;
      v133 = object_getClass(v25);
      v134 = class_isMetaClass(v133);
      v135 = object_getClassName(v25);
      v310 = sel_getName("_initializeSecureElementInfo");
      v136 = 45;
      if (v134)
        v136 = 43;
      v132(3, "%c[%{public}s %{public}s]:%i Failed to get embedded SE info", v136, v135, v310, 1167);
    }
    v137 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v138 = NFSharedLogGetLogger(v137);
    v119 = objc_claimAutoreleasedReturnValue(v138);
    if (os_log_type_enabled(v119, OS_LOG_TYPE_ERROR))
    {
      v139 = object_getClass(v25);
      if (class_isMetaClass(v139))
        v140 = 43;
      else
        v140 = 45;
      v141 = object_getClassName(v25);
      v142 = sel_getName("_initializeSecureElementInfo");
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)&buf[4] = v140;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = v141;
      *(_WORD *)&buf[18] = 2082;
      *(_QWORD *)&buf[20] = v142;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 1167;
      _os_log_impl((void *)&_mh_execute_header, v119, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get embedded SE info", buf, 0x22u);
    }
    goto LABEL_98;
  }
  sub_1001FABB8(a1[46].super.super.isa, CFSTR("Load HW Info"));
  v105 = 0;
LABEL_100:
  v62 = v105;
  v104 = v62;
LABEL_101:

  if (v104)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_fault_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_FAULT, "Failed to get SE info but stack is up...", buf, 2u);
    }
    sub_1000E1058(v25, 2);
    v146 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4[214], "sharedPowerAssertion"));
    objc_msgSend(v146, "releasePowerAssertion:", CFSTR("Load Stack"));

    sub_1001FABB8(a1[46].super.super.isa, CFSTR("Load HW"));
  }
  else
  {
    if (NFIsInternalBuild(v145))
    {
      if ((unint64_t)-[objc_class siliconName](v25[48].super.super.isa, "siliconName") >= 0xE)
      {
        v147 = (unsigned __int16 *)&v25[41].super.super.isa + 2;
        v148 = sub_1001D6C40(a1[46].super.super.isa, (uint64_t)&v25[41].super.super.isa + 4);
        v149 = (void *)objc_claimAutoreleasedReturnValue(v148);

        if (!v149)
        {
          v150 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v151 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v150);
          if (v151)
            v151(6, "%s:%i ATE Trim version = %d (%x)", "-[_NFHardwareManager _dumpATETrim]", 1022, *v147, *v147);
          v152 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v153 = NFSharedLogGetLogger(v152);
          v154 = objc_claimAutoreleasedReturnValue(v153);
          if (os_log_type_enabled(v154, OS_LOG_TYPE_DEFAULT))
          {
            v155 = *v147;
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "-[_NFHardwareManager _dumpATETrim]";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 1022;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v155;
            *(_WORD *)&buf[24] = 1024;
            *(_DWORD *)&buf[26] = v155;
            _os_log_impl((void *)&_mh_execute_header, v154, OS_LOG_TYPE_DEFAULT, "%{public}s:%i ATE Trim version = %d (%x)", buf, 0x1Eu);
          }

        }
      }
    }
    p_isa = (id *)&v25[5].super.super.isa;
    v157 = -[NFSecureElementHandle initWithID:driverWrapper:seInfo:]([NFSecureElementHandle alloc], "initWithID:driverWrapper:seInfo:", 1, a1[46].super.super.isa, v25[5].super.super.isa);
    v158 = -[NFSecureElementWrapper initWithHandle:]([NFSecureElementWrapper alloc], "initWithHandle:", v157);
    v159 = v25[47].super.super.isa;
    v25[47].super.super.isa = (Class)v158;

    -[objc_class setDelegate:](v25[47].super.super.isa, "setDelegate:", v25);
    v321 = v157;
    if (-[objc_class migrationContext](v25[5].super.super.isa, "migrationContext") == (id)4
      || objc_msgSend(*p_isa, "migrationContext") == (id)5)
    {
      v160 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v161 = NFLogGetLogger(v160);
      if (v161)
      {
        v162 = (void (*)(uint64_t, const char *, ...))v161;
        v163 = object_getClass(v25);
        v164 = class_isMetaClass(v163);
        v165 = object_getClassName(v25);
        v166 = sel_getName("_loadEmbeddedSecureElement");
        v316 = -[objc_class migrationContext](v25[5].super.super.isa, "migrationContext");
        v167 = 45;
        if (v164)
          v167 = 43;
        v162(4, "%c[%{public}s %{public}s]:%i Detected a torn SLAM migration state! %d", v167, v165, v166, 1390, v316);
      }
      v168 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v169 = NFSharedLogGetLogger(v168);
      v170 = objc_claimAutoreleasedReturnValue(v169);
      if (os_log_type_enabled(v170, OS_LOG_TYPE_ERROR))
      {
        v171 = object_getClass(v25);
        if (class_isMetaClass(v171))
          v172 = 43;
        else
          v172 = 45;
        v173 = object_getClassName(v25);
        v174 = sel_getName("_loadEmbeddedSecureElement");
        v175 = -[objc_class migrationContext](v25[5].super.super.isa, "migrationContext");
        *(_DWORD *)buf = 67110146;
        *(_DWORD *)&buf[4] = v172;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = v173;
        *(_WORD *)&buf[18] = 2082;
        *(_QWORD *)&buf[20] = v174;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 1390;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v175;
        _os_log_impl((void *)&_mh_execute_header, v170, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Detected a torn SLAM migration state! %d", buf, 0x28u);
      }

      v176 = (void *)objc_claimAutoreleasedReturnValue(-[objc_class recoverSLAM](v25[47].super.super.isa, "recoverSLAM"));
      if (v176)
      {
        v177 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v178 = NFLogGetLogger(v177);
        if (v178)
        {
          v179 = (void (*)(uint64_t, const char *, ...))v178;
          v180 = object_getClass(v25);
          v181 = class_isMetaClass(v180);
          v301 = object_getClassName(v25);
          v311 = sel_getName("_loadEmbeddedSecureElement");
          v182 = 45;
          if (v181)
            v182 = 43;
          v179(3, "%c[%{public}s %{public}s]:%i Failed to recover SLAM? %{public}@", v182, v301, v311, 1393, v176);
        }
        v183 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v184 = NFSharedLogGetLogger(v183);
        v185 = objc_claimAutoreleasedReturnValue(v184);
        if (os_log_type_enabled(v185, OS_LOG_TYPE_ERROR))
        {
          v186 = object_getClass(v25);
          if (class_isMetaClass(v186))
            v187 = 43;
          else
            v187 = 45;
          v188 = object_getClassName(v25);
          v189 = sel_getName("_loadEmbeddedSecureElement");
          *(_DWORD *)buf = 67110146;
          *(_DWORD *)&buf[4] = v187;
          *(_WORD *)&buf[8] = 2082;
          *(_QWORD *)&buf[10] = v188;
          *(_WORD *)&buf[18] = 2082;
          *(_QWORD *)&buf[20] = v189;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = 1393;
          *(_WORD *)&buf[34] = 2114;
          *(_QWORD *)&buf[36] = v176;
          _os_log_impl((void *)&_mh_execute_header, v185, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to recover SLAM? %{public}@", buf, 0x2Cu);
        }

      }
      v190 = a1[46].super.super.isa;
      *(_QWORD *)v329 = 0;
      v191 = sub_100026500(v190, 1, v329);
      v192 = *(id *)v329;
      v320 = *(id *)v329;
      if ((v191 & 1) == 0)
      {
        v193 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v194 = NFLogGetLogger(v193);
        if (v194)
        {
          v195 = (void (*)(uint64_t, const char *, ...))v194;
          v196 = object_getClass(v25);
          v197 = class_isMetaClass(v196);
          v198 = object_getClassName(v25);
          v312 = sel_getName("_loadEmbeddedSecureElement");
          v199 = 45;
          if (v197)
            v199 = 43;
          v195(3, "%c[%{public}s %{public}s]:%i Failed to get embedded SE info", v199, v198, v312, 1398);
        }
        v200 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v201 = NFSharedLogGetLogger(v200);
        v202 = objc_claimAutoreleasedReturnValue(v201);
        if (os_log_type_enabled(v202, OS_LOG_TYPE_ERROR))
        {
          v203 = object_getClass(v25);
          if (class_isMetaClass(v203))
            v204 = 43;
          else
            v204 = 45;
          v205 = object_getClassName(v25);
          v206 = sel_getName("_loadEmbeddedSecureElement");
          *(_DWORD *)buf = 67109890;
          *(_DWORD *)&buf[4] = v204;
          *(_WORD *)&buf[8] = 2082;
          *(_QWORD *)&buf[10] = v205;
          *(_WORD *)&buf[18] = 2082;
          *(_QWORD *)&buf[20] = v206;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = 1398;
          _os_log_impl((void *)&_mh_execute_header, v202, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get embedded SE info", buf, 0x22u);
        }

      }
      objc_storeStrong((id *)&v25[5].super.super.isa, v192);
      v207 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v208 = NFLogGetLogger(v207);
      if (v208)
      {
        v209 = (void (*)(uint64_t, const char *, ...))v208;
        v210 = object_getClass(v25);
        v211 = class_isMetaClass(v210);
        v212 = object_getClassName(v25);
        v213 = sel_getName("_loadEmbeddedSecureElement");
        v317 = -[objc_class migrationContext](v25[5].super.super.isa, "migrationContext");
        v318 = -[objc_class migrationState](v25[5].super.super.isa, "migrationState");
        v214 = 45;
        if (v211)
          v214 = 43;
        v209(6, "%c[%{public}s %{public}s]:%i After SLAM recovery, ctx %d state %d", v214, v212, v213, 1402, v317, v318);
      }
      v215 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v216 = NFSharedLogGetLogger(v215);
      v217 = objc_claimAutoreleasedReturnValue(v216);
      if (os_log_type_enabled(v217, OS_LOG_TYPE_DEFAULT))
      {
        v218 = object_getClass(v25);
        if (class_isMetaClass(v218))
          v219 = 43;
        else
          v219 = 45;
        v220 = object_getClassName(v25);
        v221 = sel_getName("_loadEmbeddedSecureElement");
        v222 = -[objc_class migrationContext](v25[5].super.super.isa, "migrationContext");
        v223 = -[objc_class migrationState](v25[5].super.super.isa, "migrationState");
        *(_DWORD *)buf = 67110402;
        *(_DWORD *)&buf[4] = v219;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = v220;
        *(_WORD *)&buf[18] = 2082;
        *(_QWORD *)&buf[20] = v221;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 1402;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v222;
        *(_WORD *)&buf[40] = 1024;
        *(_DWORD *)&buf[42] = v223;
        _os_log_impl((void *)&_mh_execute_header, v217, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i After SLAM recovery, ctx %d state %d", buf, 0x2Eu);
      }

      v4 = &AMFDRSealingMapCopyLocalData_ptr;
    }
    else
    {
      v320 = 0;
    }
    v224 = objc_alloc((Class)NSString);
    v225 = NSTemporaryDirectory();
    v226 = (void *)objc_claimAutoreleasedReturnValue(v225);
    v227 = objc_msgSend(v224, "initWithFormat:", CFSTR("%@/%@"), v226, CFSTR("nfcd.firstlaunch"));

    if (*p_isa)
    {
      v228 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](NSFileManager, "defaultManager"));
      v229 = objc_msgSend(v228, "fileExistsAtPath:", v227);

      if ((v229 & 1) == 0)
      {
        v230 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](NSFileManager, "defaultManager"));
        v231 = objc_msgSend(v230, "createFileAtPath:contents:attributes:", v227, 0, 0);

        if (v231)
        {
          v232 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"));
          v233 = objc_claimAutoreleasedReturnValue(objc_msgSend(v232, "arrayForKey:", CFSTR("BootHistory")));

          v319 = (void *)v233;
          if (v233)
            v234 = (NSMutableArray *)objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithArray:", v233);
          else
            v234 = objc_opt_new(NSMutableArray);
          v235 = v234;
          v236 = objc_msgSend(*p_isa, "restrictedMode");
          v237 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v238 = NFLogGetLogger(v237);
          if (v238)
          {
            v239 = (void (*)(uint64_t, const char *, ...))v238;
            v240 = object_getClass(v25);
            v241 = class_isMetaClass(v240);
            v302 = object_getClassName(v25);
            v313 = sel_getName("_initializeSecureElementBootHistory");
            v242 = 45;
            if (v241)
              v242 = 43;
            v239(6, "%c[%{public}s %{public}s]:%i Boot SE state: %d", v242, v302, v313, 1042, v236);
          }
          v243 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v244 = NFSharedLogGetLogger(v243);
          v245 = objc_claimAutoreleasedReturnValue(v244);
          if (os_log_type_enabled(v245, OS_LOG_TYPE_DEFAULT))
          {
            v246 = object_getClass(v25);
            if (class_isMetaClass(v246))
              v247 = 43;
            else
              v247 = 45;
            v248 = object_getClassName(v25);
            v249 = sel_getName("_initializeSecureElementBootHistory");
            *(_DWORD *)buf = 67110146;
            *(_DWORD *)&buf[4] = v247;
            *(_WORD *)&buf[8] = 2082;
            *(_QWORD *)&buf[10] = v248;
            *(_WORD *)&buf[18] = 2082;
            *(_QWORD *)&buf[20] = v249;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = 1042;
            *(_WORD *)&buf[34] = 1024;
            *(_DWORD *)&buf[36] = (_DWORD)v236;
            _os_log_impl((void *)&_mh_execute_header, v245, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Boot SE state: %d", buf, 0x28u);
          }

          v250 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v236));
          -[NSMutableArray addObject:](v235, "addObject:", v250);

          v251 = v235;
          v252 = v251;
          if ((unint64_t)-[NSMutableArray count](v251, "count") >= 0x1F)
          {
            v252 = (NSMutableArray *)objc_claimAutoreleasedReturnValue(-[NSMutableArray subarrayWithRange:](v251, "subarrayWithRange:", 1, 30));

          }
          v253 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"));
          objc_msgSend(v253, "removeObjectForKey:", CFSTR("lowTemperatureCount"));

          v254 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"));
          objc_msgSend(v254, "setObject:forKey:", v252, CFSTR("BootHistory"));

          v255 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"));
          objc_msgSend(v255, "synchronize");

          v4 = &AMFDRSealingMapCopyLocalData_ptr;
        }
      }
      v256 = *p_isa;
      if (*p_isa)
      {
        v257 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"));
        v258 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v257, "arrayForKey:", CFSTR("BootHistory")));
        objc_msgSend(v256, "setBootHistory:", v258);

      }
    }

    v259 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig embeddedWiredModeWithFD:](NFRoutingConfig, "embeddedWiredModeWithFD:", 0));
    v260 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary setRoutingConfig:](v25, "setRoutingConfig:", v259));

    if (!v260)
    {
      v261 = sub_10022DCC4(v25[47].super.super.isa);
      v262 = sub_1002390B4(v25[47].super.super.isa);
      v263 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"));
      objc_msgSend(v263, "removeObjectForKey:", CFSTR("SecureElementSequenceCounter"));

      *(_QWORD *)v327 = 0;
      v264 = sub_1000A3258(v25[47].super.super.isa, v327);
      v265 = (void *)objc_claimAutoreleasedReturnValue(v264);
      if (v265)
      {
        v266 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v267 = NFLogGetLogger(v266);
        if (v267)
        {
          v268 = (void (*)(uint64_t, const char *, ...))v267;
          v269 = object_getClass(v25);
          v270 = class_isMetaClass(v269);
          v303 = object_getClassName(v25);
          v314 = sel_getName("_loadEmbeddedSecureElement");
          v271 = 45;
          if (v270)
            v271 = 43;
          v268(3, "%c[%{public}s %{public}s]:%i Failed to get LPEMCounter: %{public}@", v271, v303, v314, 1426, v265);
        }
        v272 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v273 = NFSharedLogGetLogger(v272);
        v274 = objc_claimAutoreleasedReturnValue(v273);
        if (os_log_type_enabled(v274, OS_LOG_TYPE_ERROR))
        {
          v275 = object_getClass(v25);
          if (class_isMetaClass(v275))
            v276 = 43;
          else
            v276 = 45;
          v277 = object_getClassName(v25);
          v278 = sel_getName("_loadEmbeddedSecureElement");
          *(_DWORD *)buf = 67110146;
          *(_DWORD *)&buf[4] = v276;
          *(_WORD *)&buf[8] = 2082;
          *(_QWORD *)&buf[10] = v277;
          *(_WORD *)&buf[18] = 2082;
          *(_QWORD *)&buf[20] = v278;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = 1426;
          *(_WORD *)&buf[34] = 2114;
          *(_QWORD *)&buf[36] = v265;
          _os_log_impl((void *)&_mh_execute_header, v274, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get LPEMCounter: %{public}@", buf, 0x2Cu);
        }

      }
    }

    if ((-[objc_class registerForEvents](v25[7].super.super.isa, "registerForEvents") & 1) == 0)
    {
      v279 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v280 = NFLogGetLogger(v279);
      if (v280)
      {
        v281 = (void (*)(uint64_t, const char *, ...))v280;
        v282 = object_getClass(v25);
        v283 = class_isMetaClass(v282);
        v284 = object_getClassName(v25);
        v315 = sel_getName("_initializeHardwareAndReportFailure:");
        v285 = 45;
        if (v283)
          v285 = 43;
        v281(3, "%c[%{public}s %{public}s]:%i Failed to register for power events", v285, v284, v315, 879);
      }
      v286 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v287 = NFSharedLogGetLogger(v286);
      v288 = objc_claimAutoreleasedReturnValue(v287);
      if (os_log_type_enabled(v288, OS_LOG_TYPE_ERROR))
      {
        v289 = object_getClass(v25);
        if (class_isMetaClass(v289))
          v290 = 43;
        else
          v290 = 45;
        v291 = object_getClassName(v25);
        v292 = sel_getName("_initializeHardwareAndReportFailure:");
        *(_DWORD *)buf = 67109890;
        *(_DWORD *)&buf[4] = v290;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = v291;
        *(_WORD *)&buf[18] = 2082;
        *(_QWORD *)&buf[20] = v292;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 879;
        _os_log_impl((void *)&_mh_execute_header, v288, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to register for power events", buf, 0x22u);
      }

    }
    v293 = objc_opt_new(NFKeyBag);
    v294 = v25[11].super.super.isa;
    v25[11].super.super.isa = (Class)v293;

    v295 = v25[11].super.super.isa;
    v296 = v25[29].super.super.isa;
    v324[0] = _NSConcreteStackBlock;
    v324[1] = 3221225472;
    v324[2] = sub_1000E12D8;
    v324[3] = &unk_1002E7F28;
    v324[4] = v25;
    sub_1001EB334(v295, v296, v324);
    if (v322 == 2)
      sub_1000DEC00((uint64_t)v25);
    -[NSMutableDictionary maybeStartNextSession](v25, "maybeStartNextSession");
    sub_1001FABB8(a1[46].super.super.isa, CFSTR("Load HW"));
    v297 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4[214], "sharedPowerAssertion"));
    objc_msgSend(v297, "releasePowerAssertion:", CFSTR("Load Stack"));

    sub_1000DFFD0((id *)&v25->super.super.isa, 60.0);
    notify_post("com.apple.nfcd.started");
  }
}

void sub_1000DE4E0(id *a1, uint64_t a2)
{
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  id *v16;
  void *v17;
  void *v18;
  id v19;
  id v20;
  uint64_t v21;
  void *i;
  const char *Name;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint8_t v28[128];
  uint8_t buf[4];
  int v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  int v36;

  if (a1)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("notifyOfHwStateChanged:");
      v10 = 45;
      if (isMetaClass)
        v10 = 43;
      v6(6, "%c[%{public}s %{public}s]:%i Notifying client of state update.", v10, ClassName, Name, 564);
    }
    v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v12 = NFSharedLogGetLogger(v11);
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      v14 = object_getClass(a1);
      if (class_isMetaClass(v14))
        v15 = 43;
      else
        v15 = 45;
      *(_DWORD *)buf = 67109890;
      v30 = v15;
      v31 = 2082;
      v32 = object_getClassName(a1);
      v33 = 2082;
      v34 = sel_getName("notifyOfHwStateChanged:");
      v35 = 1024;
      v36 = 564;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Notifying client of state update.", buf, 0x22u);
    }

    v16 = sub_100007A04(a1);
    v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
    v24 = 0u;
    v25 = 0u;
    v26 = 0u;
    v27 = 0u;
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "allValues"));
    v19 = objc_msgSend(v18, "countByEnumeratingWithState:objects:count:", &v24, v28, 16);
    if (v19)
    {
      v20 = v19;
      v21 = *(_QWORD *)v25;
      do
      {
        for (i = 0; i != v20; i = (char *)i + 1)
        {
          if (*(_QWORD *)v25 != v21)
            objc_enumerationMutation(v18);
          objc_msgSend(*(id *)(*((_QWORD *)&v24 + 1) + 8 * (_QWORD)i), "hwStateDidChange:", a2);
        }
        v20 = objc_msgSend(v18, "countByEnumeratingWithState:objects:count:", &v24, v28, 16);
      }
      while (v20);
    }

    objc_msgSend(a1[21], "hwStateDidChange:", a2);
  }
}

BOOL sub_1000DE724(uint64_t a1)
{
  int v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  NSObject *v6;
  void *v8;
  uint8_t buf[16];

  v2 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  if (v2 == 5)
  {
    sub_1000DE88C(*(void ***)(a1 + 32), CFSTR("Recovery"));
    sub_1000DEC00(*(_QWORD *)(a1 + 32));
    sub_1001FABB8(*(void **)(*(_QWORD *)(a1 + 32) + 368), CFSTR("Recovery"));
  }
  else
  {
    if (v2 != 3)
    {
      v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
      objc_msgSend(v8, "handleFailureInMethod:object:file:lineNumber:description:", *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 32), CFSTR("_NFHardwareManager.m"), 512, CFSTR("Unexpected state %u"), *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));

    }
    sub_1000DC5B0(*(NSMutableDictionary **)(a1 + 32), 1);
  }
  v3 = -[_NFHardwareManager getPrimaryHardwareState]_0(*(_QWORD *)(a1 + 32));
  if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) != (_DWORD)v3)
  {
    sub_1000DE4E0(*(id **)(a1 + 32), v3);
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = v3;
  }
  if ((_DWORD)v3 == 2)
  {
    v4 = sub_1000DF168(*(_QWORD **)(a1 + 32));
    v5 = NFSharedSignpostLog(v4);
    v6 = objc_claimAutoreleasedReturnValue(v5);
    if (os_signpost_enabled(v6))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v6, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "HWRecovery", "end", buf, 2u);
    }

  }
  return (_DWORD)v3 == 2;
}

void sub_1000DE88C(void **a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  _QWORD *v6;
  uint64_t v7;
  void *specific;
  uint64_t Logger;
  void (*v10)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  NSObject *v17;
  objc_class *v18;
  int v19;
  id v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  void (*v24)(uint64_t, const char *, ...);
  objc_class *v25;
  _BOOL4 v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  NSObject *v30;
  objc_class *v31;
  int v32;
  const char *v33;
  const char *Name;
  const char *v35;
  uint8_t buf[4];
  int v37;
  __int16 v38;
  const char *v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  int v43;
  __int16 v44;
  void *v45;
  __int16 v46;
  uint64_t v47;

  v3 = a2;
  if (a1)
  {
    if (NFProductIsVM())
    {
      sub_1000E1058(a1, 3);
    }
    else
    {
      v4 = sub_1001F84C8(a1[46], v3, 0);
      v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      v6 = a1[46];
      if (v6)
        v7 = v6[37];
      else
        v7 = 0;
      sub_1000E1058(a1, v7);
      if (v5)
      {
        specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        Logger = NFLogGetLogger(specific);
        if (Logger)
        {
          v10 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(a1);
          isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(a1);
          Name = sel_getName("_bootHardwareForSession:");
          v14 = 45;
          if (isMetaClass)
            v14 = 43;
          v10(4, "%c[%{public}s %{public}s]:%i Failed to open session : %@. State is %lu", v14, ClassName, Name, 943, v5, v7);
        }
        v15 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v16 = NFSharedLogGetLogger(v15);
        v17 = objc_claimAutoreleasedReturnValue(v16);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          v18 = object_getClass(a1);
          if (class_isMetaClass(v18))
            v19 = 43;
          else
            v19 = 45;
          *(_DWORD *)buf = 67110402;
          v37 = v19;
          v38 = 2082;
          v39 = object_getClassName(a1);
          v40 = 2082;
          v41 = sel_getName("_bootHardwareForSession:");
          v42 = 1024;
          v43 = 943;
          v44 = 2112;
          v45 = v5;
          v46 = 2048;
          v47 = v7;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@. State is %lu", buf, 0x36u);
        }

      }
      else
      {
        v20 = sub_1001F84C8(a1[46], CFSTR("Check RF Session Allowed"), 1uLL);
        v21 = objc_claimAutoreleasedReturnValue(v20);
        if (!v21)
        {
          sub_1001FABB8(a1[46], CFSTR("Check RF Session Allowed"));
          goto LABEL_29;
        }
        v5 = (void *)v21;
        v22 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v23 = NFLogGetLogger(v22);
        if (v23)
        {
          v24 = (void (*)(uint64_t, const char *, ...))v23;
          v25 = object_getClass(a1);
          v26 = class_isMetaClass(v25);
          v33 = object_getClassName(a1);
          v35 = sel_getName("_bootHardwareForSession:");
          v27 = 45;
          if (v26)
            v27 = 43;
          v24(3, "%c[%{public}s %{public}s]:%i RF sessions NOT allowed : %@", v27, v33, v35, 947, v5);
        }
        v28 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v29 = NFSharedLogGetLogger(v28);
        v30 = objc_claimAutoreleasedReturnValue(v29);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        {
          v31 = object_getClass(a1);
          if (class_isMetaClass(v31))
            v32 = 43;
          else
            v32 = 45;
          *(_DWORD *)buf = 67110146;
          v37 = v32;
          v38 = 2082;
          v39 = object_getClassName(a1);
          v40 = 2082;
          v41 = sel_getName("_bootHardwareForSession:");
          v42 = 1024;
          v43 = 947;
          v44 = 2112;
          v45 = v5;
          _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i RF sessions NOT allowed : %@", buf, 0x2Cu);
        }

      }
    }
  }
LABEL_29:

}

void sub_1000DEC00(uint64_t a1)
{
  id v2;
  void *v3;
  uint64_t v4;
  id v5;
  void *v6;
  id v7;
  void *v8;
  void *v9;
  id v10;
  id v11;
  void *v12;
  id v13;
  id v14;
  _QWORD *v15;
  unint64_t v16;
  void *specific;
  uint64_t Logger;
  void (*v19)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  NSObject *v26;
  objc_class *v27;
  int v28;
  void *v29;
  uint64_t v30;
  void (*v31)(uint64_t, const char *, ...);
  objc_class *v32;
  _BOOL4 v33;
  const char *v34;
  uint64_t v35;
  void *v36;
  uint64_t v37;
  NSObject *v38;
  objc_class *v39;
  int v40;
  const char *v41;
  const char *v42;
  void *v43;
  id v44;
  NFBackgroundTagReadingManager *v45;
  void *v46;
  const char *Name;
  const char *v48;
  uint8_t buf[8];
  _BYTE v50[26];
  _QWORD v51[4];

  if (!a1)
    return;
  if (-[_NFHardwareManager getPrimaryHardwareState]_0(a1) != 2)
  {
    v7 = objc_alloc((Class)NSError);
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v51[0] = NSLocalizedDescriptionKey;
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
    *(_QWORD *)buf = v9;
    *(_QWORD *)v50 = &off_1002FEDD8;
    v51[1] = CFSTR("Line");
    v51[2] = CFSTR("Method");
    v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_initializeExpressMode"));
    *(_QWORD *)&v50[8] = v10;
    v51[3] = NSDebugDescriptionErrorKey;
    v11 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_initializeExpressMode"), 1069);
    *(_QWORD *)&v50[16] = v11;
    v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, v51, 4));
    v13 = objc_msgSend(v7, "initWithDomain:code:userInfo:", v8, 58, v12);

    v6 = 0;
    goto LABEL_38;
  }
  v2 = sub_10003DAF4([NFExpressModeManager alloc], (void *)a1, *(void **)(a1 + 368), *(void **)(a1 + 8), *(void **)(a1 + 232));
  v3 = *(void **)(a1 + 24);
  *(_QWORD *)(a1 + 24) = v2;

  v4 = *(_QWORD *)(a1 + 24);
  if (!v4 || *(_QWORD *)(v4 + 136) != 1 && !*(_BYTE *)(v4 + 170))
  {
    if (objc_msgSend(*(id *)(a1 + 384), "hasLPEMSupport"))
    {
      v14 = sub_100203984((uint64_t)NFHeadlessModeController);
      v15 = (_QWORD *)objc_claimAutoreleasedReturnValue(v14);
      if (v15)
      {
        v16 = v15[4];

        if (v16)
        {
          if ((v16 & 1) != 0)
          {
            specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            Logger = NFLogGetLogger(specific);
            if (Logger)
            {
              v19 = (void (*)(uint64_t, const char *, ...))Logger;
              Class = object_getClass((id)a1);
              isMetaClass = class_isMetaClass(Class);
              ClassName = object_getClassName((id)a1);
              Name = sel_getName("_initializeExpressMode");
              v23 = 45;
              if (isMetaClass)
                v23 = 43;
              v19(3, "%c[%{public}s %{public}s]:%i ERROR : NFC headless mode is enabled but express is not.", v23, ClassName, Name, 1093);
            }
            v24 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v25 = NFSharedLogGetLogger(v24);
            v26 = objc_claimAutoreleasedReturnValue(v25);
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
            {
              v27 = object_getClass((id)a1);
              if (class_isMetaClass(v27))
                v28 = 43;
              else
                v28 = 45;
              *(_DWORD *)buf = 67109890;
              *(_DWORD *)&buf[4] = v28;
              *(_WORD *)v50 = 2082;
              *(_QWORD *)&v50[2] = object_getClassName((id)a1);
              *(_WORD *)&v50[10] = 2082;
              *(_QWORD *)&v50[12] = sel_getName("_initializeExpressMode");
              *(_WORD *)&v50[20] = 1024;
              *(_DWORD *)&v50[22] = 1093;
              _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i ERROR : NFC headless mode is enabled but express is not.", buf, 0x22u);
            }

          }
          if (v16 >= 2)
          {
            v29 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v30 = NFLogGetLogger(v29);
            if (v30)
            {
              v31 = (void (*)(uint64_t, const char *, ...))v30;
              v32 = object_getClass((id)a1);
              v33 = class_isMetaClass(v32);
              v34 = object_getClassName((id)a1);
              v48 = sel_getName("_initializeExpressMode");
              v35 = 45;
              if (v33)
                v35 = 43;
              v31(6, "%c[%{public}s %{public}s]:%i Headless mode is enabled but express is not. Taking session", v35, v34, v48, 1098);
            }
            v36 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v37 = NFSharedLogGetLogger(v36);
            v38 = objc_claimAutoreleasedReturnValue(v37);
            if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
            {
              v39 = object_getClass((id)a1);
              if (class_isMetaClass(v39))
                v40 = 43;
              else
                v40 = 45;
              v41 = object_getClassName((id)a1);
              v42 = sel_getName("_initializeExpressMode");
              *(_DWORD *)buf = 67109890;
              *(_DWORD *)&buf[4] = v40;
              *(_WORD *)v50 = 2082;
              *(_QWORD *)&v50[2] = v41;
              *(_WORD *)&v50[10] = 2082;
              *(_QWORD *)&v50[12] = v42;
              *(_WORD *)&v50[20] = 1024;
              *(_DWORD *)&v50[22] = 1098;
              _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Headless mode is enabled but express is not. Taking session", buf, 0x22u);
            }

            sub_100189F0C((void *)a1);
          }
        }
      }
    }
    goto LABEL_36;
  }
  v5 = sub_1001F84C8(*(void **)(a1 + 368), CFSTR("Enable Express"), 1uLL);
  v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
  if (!v6)
  {
    if (objc_msgSend(*(id *)(a1 + 384), "hasLPEMSupport")
      && sub_1001979A4(*(_QWORD *)(a1 + 368), 1))
    {
      sub_100197C58(*(void **)(a1 + 368), 1);
    }
LABEL_36:
    v6 = 0;
  }
  v13 = 0;
LABEL_38:

  sub_1001CB940(*(void **)(a1 + 368), 0, 3u);
  v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "defaultRoutingConfig:", 1));
  v44 = objc_msgSend((id)a1, "setRoutingConfig:", v43);

  if ((NFProductIsDevBoard() & 1) == 0 && (NFProductIsNED() & 1) == 0)
  {
    v45 = -[NFBackgroundTagReadingManager initWithQueue:driverWrapper:]([NFBackgroundTagReadingManager alloc], "initWithQueue:driverWrapper:", *(_QWORD *)(a1 + 232), *(_QWORD *)(a1 + 368));
    v46 = *(void **)(a1 + 408);
    *(_QWORD *)(a1 + 408) = v45;

  }
}

_QWORD *sub_1000DF168(_QWORD *result)
{
  _QWORD *v1;
  id v2;
  void *v3;
  void *v4;
  _QWORD v5[6];

  if (result)
  {
    v1 = result;
    v2 = objc_msgSend(objc_alloc((Class)NFBackgroundActivityScheduler), "initWithQueue:", result[29]);
    v3 = (void *)v1[12];
    v1[12] = v2;

    v4 = (void *)v1[12];
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    v5[2] = sub_1000DF1FC;
    v5[3] = &unk_1002E5F60;
    v5[4] = v1;
    v5[5] = "_scheduleDailyAnalytics";
    return objc_msgSend(v4, "schedulePreRegisteredActivity:callback:", CFSTR("com.apple.nfcd.coreanalytics.event"), v5);
  }
  return result;
}

void sub_1000DF1FC(uint64_t a1, void *a2)
{
  id v3;
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  uint64_t v19;
  void (*v20)(uint64_t, const char *, ...);
  objc_class *v21;
  _BOOL4 v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  NSObject *v26;
  objc_class *v27;
  int v28;
  const char *v29;
  const char *v30;
  uint64_t v31;
  NSObject *v32;
  const char *v33;
  const char *Name;
  const char *v35;
  uint8_t buf[8];
  _BYTE v37[40];

  v3 = a2;
  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v6 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 40));
    v10 = 45;
    if (isMetaClass)
      v10 = 43;
    v6(6, "%c[%{public}s %{public}s]:%i Stats scheduler invoked", v10, ClassName, Name, 543);
  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)buf = 67109890;
    *(_DWORD *)&buf[4] = v15;
    *(_WORD *)v37 = 2082;
    *(_QWORD *)&v37[2] = v16;
    *(_WORD *)&v37[10] = 2082;
    *(_QWORD *)&v37[12] = v17;
    *(_WORD *)&v37[20] = 1024;
    *(_DWORD *)&v37[22] = 543;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Stats scheduler invoked", buf, 0x22u);
  }

  if (v3)
  {
    v18 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v19 = NFLogGetLogger(v18);
    if (v19)
    {
      v20 = (void (*)(uint64_t, const char *, ...))v19;
      v21 = object_getClass(*(id *)(a1 + 32));
      v22 = class_isMetaClass(v21);
      v33 = object_getClassName(*(id *)(a1 + 32));
      v35 = sel_getName(*(SEL *)(a1 + 40));
      v23 = 45;
      if (v22)
        v23 = 43;
      v20(3, "%c[%{public}s %{public}s]:%i %{public}@", v23, v33, v35, 546, v3);
    }
    v24 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v25 = NFSharedLogGetLogger(v24);
    v26 = objc_claimAutoreleasedReturnValue(v25);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      v27 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v27))
        v28 = 43;
      else
        v28 = 45;
      v29 = object_getClassName(*(id *)(a1 + 32));
      v30 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)buf = 67110146;
      *(_DWORD *)&buf[4] = v28;
      *(_WORD *)v37 = 2082;
      *(_QWORD *)&v37[2] = v29;
      *(_WORD *)&v37[10] = 2082;
      *(_QWORD *)&v37[12] = v30;
      *(_WORD *)&v37[20] = 1024;
      *(_DWORD *)&v37[22] = 546;
      *(_WORD *)&v37[26] = 2114;
      *(_QWORD *)&v37[28] = v3;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
    }

  }
  else
  {
    v31 = *(_QWORD *)(a1 + 32);
    if (v31)
    {
      v32 = *(NSObject **)(v31 + 232);
      *(_QWORD *)buf = _NSConcreteStackBlock;
      *(_QWORD *)v37 = 3221225472;
      *(_QWORD *)&v37[8] = sub_1000E0180;
      *(_QWORD *)&v37[16] = &unk_1002E5C30;
      *(_QWORD *)&v37[24] = v31;
      *(_QWORD *)&v37[32] = "triggerDailyStats";
      dispatch_async(v32, buf);
    }
  }

}

void sub_1000DF9FC(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

BOOL sub_1000DFA18(void **a1, uint64_t a2)
{
  void *v4;
  id v5;
  void *specific;
  uint64_t Logger;
  void (*v9)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  NSObject *v16;
  objc_class *v17;
  int v18;
  const char *Name;
  uint8_t buf[4];
  int v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  const char *v25;
  __int16 v26;
  int v27;

  if (a1)
  {
    v4 = a1[47];
    v5 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A46A, 12);
    LODWORD(v4) = objc_msgSend(v4, "select:error:", v5, 0);

    if ((_DWORD)v4)
      return sub_1000974B8(a1[47], a2);
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v9 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("_getSEMemoryInfo:result:");
      v13 = 45;
      if (isMetaClass)
        v13 = 43;
      v9(3, "%c[%{public}s %{public}s]:%i Failed to select CASD", v13, ClassName, Name, 1142);
    }
    v14 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v15 = NFSharedLogGetLogger(v14);
    v16 = objc_claimAutoreleasedReturnValue(v15);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      v17 = object_getClass(a1);
      if (class_isMetaClass(v17))
        v18 = 43;
      else
        v18 = 45;
      *(_DWORD *)buf = 67109890;
      v21 = v18;
      v22 = 2082;
      v23 = object_getClassName(a1);
      v24 = 2082;
      v25 = sel_getName("_getSEMemoryInfo:result:");
      v26 = 1024;
      v27 = 1142;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select CASD", buf, 0x22u);
    }

  }
  return 0;
}

NSMutableArray *sub_1000DFC1C(uint64_t a1)
{
  void *v3;
  id v4;
  void *v5;
  NSMutableArray *v6;
  NSMutableArray *v7;
  NSMutableArray *v8;
  NSMutableArray *v9;

  if (!a1 || (unint64_t)objc_msgSend(*(id *)(a1 + 384), "siliconName") < 0xE)
    return (NSMutableArray *)0;
  v3 = *(void **)(a1 + 368);
  v9 = 0;
  v4 = sub_1001D36D0(v3, &v9);
  v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  v6 = v9;
  v7 = v6;
  if (v5)
  {

  }
  else if (-[NSMutableArray count](v6, "count"))
  {
    v8 = v7;
    goto LABEL_9;
  }
  v8 = 0;
LABEL_9:

  return v8;
}

id sub_1000DFCAC(uint64_t a1)
{
  void *v2;
  id v3;

  if (!a1 || !*(_QWORD *)(a1 + 384))
    return 0;
  v2 = (void *)objc_claimAutoreleasedReturnValue(+[NFCALogger sharedCALogger](NFCALogger, "sharedCALogger"));
  v3 = objc_msgSend(v2, "getHardwareTypeForCA:", objc_msgSend(*(id *)(a1 + 384), "siliconName"));

  return v3;
}

void sub_1000DFD10(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *v7;
  _BOOL4 v8;
  const char *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  const char *v18;
  void *specific;
  uint64_t Logger;
  void (*v21)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  objc_class *v28;
  int v29;
  const char *v30;
  const char *v31;
  const char *v32;
  const char *Name;
  uint8_t buf[4];
  int v35;
  __int16 v36;
  const char *v37;
  __int16 v38;
  const char *v39;
  __int16 v40;
  int v41;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)(v2 + 32);
  if (!v3)
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 32) = malloc_type_calloc(1uLL, 0x34uLL, 0x10000403884A0CCuLL);
    v2 = *(_QWORD *)(a1 + 32);
    v3 = *(_QWORD *)(v2 + 32);
    if (!v3)
    {
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v21 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(*(id *)(a1 + 32));
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(*(id *)(a1 + 32));
        Name = sel_getName(*(SEL *)(a1 + 40));
        v25 = 45;
        if (isMetaClass)
          v25 = 43;
        v21(3, "%c[%{public}s %{public}s]:%i Failed to create SE memory.", v25, ClassName, Name, 717);
      }
      v26 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v27 = NFSharedLogGetLogger(v26);
      v13 = objc_claimAutoreleasedReturnValue(v27);
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        goto LABEL_23;
      v28 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v28))
        v29 = 43;
      else
        v29 = 45;
      v30 = object_getClassName(*(id *)(a1 + 32));
      v31 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)buf = 67109890;
      v35 = v29;
      v36 = 2082;
      v37 = v30;
      v38 = 2082;
      v39 = v31;
      v40 = 1024;
      v41 = 717;
      v18 = "%c[%{public}s %{public}s]:%i Failed to create SE memory.";
      goto LABEL_22;
    }
  }
  if (sub_1000DFA18((void **)v2, v3))
    return;
  v4 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v5 = NFLogGetLogger(v4);
  if (v5)
  {
    v6 = (void (*)(uint64_t, const char *, ...))v5;
    v7 = object_getClass(*(id *)(a1 + 32));
    v8 = class_isMetaClass(v7);
    v9 = object_getClassName(*(id *)(a1 + 32));
    v32 = sel_getName(*(SEL *)(a1 + 40));
    v10 = 45;
    if (v8)
      v10 = 43;
    v6(4, "%c[%{public}s %{public}s]:%i Failed to get memory info", v10, v9, v32, 722);
  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)buf = 67109890;
    v35 = v15;
    v36 = 2082;
    v37 = v16;
    v38 = 2082;
    v39 = v17;
    v40 = 1024;
    v41 = 722;
    v18 = "%c[%{public}s %{public}s]:%i Failed to get memory info";
LABEL_22:
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, v18, buf, 0x22u);
  }
LABEL_23:

}

id *sub_1000DFFD0(id *result, double a2)
{
  id *v3;
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *Name;
  uint8_t buf[4];
  int v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  double v26;

  if (result[16])
  {
    v3 = result;
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v3);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(v3);
      Name = sel_getName("schedulePostStartupWork:");
      v10 = 45;
      if (isMetaClass)
        v10 = 43;
      v6(6, "%c[%{public}s %{public}s]:%i Scheduling post stack bootup work in %f seconds", v10, ClassName, Name, 794, *(_QWORD *)&a2);
    }
    v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v12 = NFSharedLogGetLogger(v11);
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      v14 = object_getClass(v3);
      if (class_isMetaClass(v14))
        v15 = 43;
      else
        v15 = 45;
      *(_DWORD *)buf = 67110146;
      v18 = v15;
      v19 = 2082;
      v20 = object_getClassName(v3);
      v21 = 2082;
      v22 = sel_getName("schedulePostStartupWork:");
      v23 = 1024;
      v24 = 794;
      v25 = 2048;
      v26 = a2;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Scheduling post stack bootup work in %f seconds", buf, 0x2Cu);
    }

    return (id *)objc_msgSend(v3[16], "startTimer:", a2);
  }
  return result;
}

void sub_1000E0180(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  id v4;
  _QWORD v5[4];
  __int128 v6;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 232);
  v3 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig embeddedWiredMode](NFRoutingConfig, "embeddedWiredMode"));
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_1000E0228;
  v5[3] = &unk_1002E5C30;
  v6 = *(_OWORD *)(a1 + 32);
  v4 = +[_NFBuiltinSession createSessionWithWorkQueue:routing:sessionQueuer:didStartWork:](_NFBuiltinSession, "createSessionWithWorkQueue:routing:sessionQueuer:didStartWork:", v2, v3, (_QWORD)v6, v5);

}

void sub_1000E0228(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  NSObject *v11;
  objc_class *v12;
  int v13;
  const char *v14;
  const char *v15;
  id v16;
  void *v17;
  id v18;
  void *v19;
  uint64_t v20;
  NSMutableDictionary *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  NSMutableArray *v28;
  void *v29;
  void *v30;
  void *v31;
  __CFString *v32;
  void *v33;
  id v34;
  const __CFString *v35;
  id v36;
  NSNumber *v37;
  _UNKNOWN **v38;
  uint64_t v39;
  void *v40;
  _UNKNOWN **v41;
  uint64_t v42;
  void *v43;
  _UNKNOWN **v44;
  void *v45;
  void *v46;
  void *v47;
  uint64_t v48;
  void *v49;
  _UNKNOWN **v50;
  uint64_t v51;
  void *v52;
  _UNKNOWN **v53;
  void *v54;
  void *v55;
  void *v56;
  void *v57;
  void *v58;
  const char *Name;
  void *v60;
  void *v61;
  void *v62;
  void *v63;
  void *v64;
  unsigned int v65;
  void *v66;
  void *v67;
  void *v68;
  void *v69;
  void *v70;
  __CFString *v71;
  NSMutableDictionary *v72;
  __CFString *v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  uint64_t v77;
  const __CFString *v78;
  void *v79;
  _QWORD v80[17];
  uint8_t buf[8];
  _BYTE v82[32];
  void *v83;
  void *v84;
  void *v85;
  void *v86;
  _UNKNOWN **v87;
  _UNKNOWN **v88;
  void *v89;
  void *v90;
  void *v91;
  _UNKNOWN **v92;
  _UNKNOWN **v93;
  __CFString *v94;
  _QWORD v95[5];
  _QWORD v96[5];

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 40));
    v8 = 45;
    if (isMetaClass)
      v8 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i daily stats", v8, ClassName, Name, 812);
  }
  v9 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v10 = NFSharedLogGetLogger(v9);
  v11 = objc_claimAutoreleasedReturnValue(v10);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v12 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v12))
      v13 = 43;
    else
      v13 = 45;
    v14 = object_getClassName(*(id *)(a1 + 32));
    v15 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)buf = 67109890;
    *(_DWORD *)&buf[4] = v13;
    *(_WORD *)v82 = 2082;
    *(_QWORD *)&v82[2] = v14;
    *(_WORD *)&v82[10] = 2082;
    *(_QWORD *)&v82[12] = v15;
    *(_WORD *)&v82[20] = 1024;
    *(_DWORD *)&v82[22] = 812;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i daily stats", buf, 0x22u);
  }

  sub_1000E0AA0(*(void ***)(a1 + 32));
  v16 = sub_100042330(*(_QWORD **)(*(_QWORD *)(a1 + 32) + 24));
  v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
  if (v17)
    sub_1000A8738((uint64_t)NFUnifiedAccessTransactionCALogger, v17);
  v18 = sub_100042948(*(_QWORD **)(*(_QWORD *)(a1 + 32) + 24));
  v19 = (void *)objc_claimAutoreleasedReturnValue(v18);

  if (v19)
    sub_1000A8798((uint64_t)NFUnifiedAccessTransactionCALogger, v19);
  v20 = *(_QWORD *)(a1 + 32);
  if (v20)
  {
    v21 = objc_opt_new(NSMutableDictionary);
    v77 = 0;
    v75 = 0u;
    v76 = 0u;
    v74 = 0u;
    if (sub_1000DFA18((void **)v20, (uint64_t)&v74))
    {
      v95[0] = CFSTR("seTransientDeselect");
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", DWORD2(v74)));
      v96[0] = v22;
      v95[1] = CFSTR("seTransientReset");
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", DWORD1(v74)));
      v96[1] = v23;
      v95[2] = CFSTR("seTransientPersistent");
      v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v74));
      v96[2] = v24;
      v95[3] = CFSTR("seAvailableIndices");
      v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", HIDWORD(v74)));
      v96[3] = v25;
      v95[4] = CFSTR("seTotalIndices");
      v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v75));
      v96[4] = v26;
      v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v96, v95, 5));
      -[NSMutableDictionary addEntriesFromDictionary:](v21, "addEntriesFromDictionary:", v27);

    }
    v28 = sub_1000DFC1C(v20);
    v29 = (void *)objc_claimAutoreleasedReturnValue(v28);
    v30 = v29;
    if (v29 && objc_msgSend(v29, "count"))
      sub_10020C4FC((uint64_t)NFDailyStatisticsCALogger, v30);
    if (*(_QWORD *)(v20 + 384))
    {
      v31 = *(void **)(v20 + 40);
      v32 = &stru_1002ED8A8;
      if (v31)
      {
        v70 = v19;
        if ((unint64_t)objc_msgSend(v31, "migrationState") <= 1
          && (unint64_t)objc_msgSend(*(id *)(v20 + 40), "migrationState") > 6)
        {
          v35 = &stru_1002ED8A8;
        }
        else
        {
          v33 = *(void **)(v20 + 376);
          v73 = &stru_1002ED8A8;
          v34 = sub_1000A3C04(v33, &v73);
          v35 = v73;
        }
        v36 = sub_1000A1044(*(void **)(v20 + 376), (_DWORD *)&v77 + 1, 1);
        v80[0] = CFSTR("nfccHWVersion");
        v69 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(*(id *)(v20 + 384), "siliconVersion")));
        *(_QWORD *)buf = v69;
        v80[1] = CFSTR("nfccROMVersion");
        v68 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(*(id *)(v20 + 384), "ROMVersion")));
        *(_QWORD *)v82 = v68;
        v80[2] = CFSTR("nfccFWVersion");
        v67 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(*(id *)(v20 + 384), "firmwareVersion")));
        *(_QWORD *)&v82[8] = v67;
        v80[3] = CFSTR("middlewareVersion");
        v66 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(*(id *)(v20 + 384), "middlewareVersion")));
        *(_QWORD *)&v82[16] = v66;
        v80[4] = CFSTR("hardwareType");
        v65 = sub_1000DFCAC(v20);
        v71 = (__CFString *)v35;
        v72 = v21;
        if (v65)
        {
          v37 = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", sub_1000DFCAC(v20));
          v38 = (_UNKNOWN **)objc_claimAutoreleasedReturnValue(v37);
        }
        else
        {
          v38 = &off_1002FEDC0;
        }
        v60 = v38;
        *(_QWORD *)&v82[24] = v38;
        v80[5] = CFSTR("seDeviceType");
        v64 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(*(id *)(v20 + 40), "deviceType")));
        v83 = v64;
        v80[6] = CFSTR("seHWVersion");
        v63 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(*(id *)(v20 + 40), "hardwareVersion")));
        v84 = v63;
        v80[7] = CFSTR("seFWVersion");
        v62 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(*(id *)(v20 + 40), "firmwareVersion")));
        v85 = v62;
        v80[8] = CFSTR("seSignKeyType");
        v61 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(*(id *)(v20 + 40), "signingKeyType")));
        v86 = v61;
        v80[9] = CFSTR("seSequenceCounter");
        v39 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v20 + 40), "sequenceCounter"));
        v40 = (void *)v39;
        if (v39)
          v41 = (_UNKNOWN **)v39;
        else
          v41 = &off_1002FEDC0;
        v87 = v41;
        v80[10] = CFSTR("seReferenceCounter");
        v42 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v20 + 40), "referenceCounter"));
        v43 = (void *)v42;
        if (v42)
          v44 = (_UNKNOWN **)v42;
        else
          v44 = &off_1002FEDC0;
        v88 = v44;
        v80[11] = CFSTR("seOSMode");
        v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(*(id *)(v20 + 40), "OSMode")));
        v89 = v45;
        v80[12] = CFSTR("seRestrictedMode");
        v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", objc_msgSend(*(id *)(v20 + 40), "restrictedMode")));
        v90 = v46;
        v80[13] = CFSTR("seMigrationState");
        v47 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(*(id *)(v20 + 40), "migrationState")));
        v91 = v47;
        v80[14] = CFSTR("seMigrationPkgs");
        v48 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v20 + 40), "migrationPackages"));
        v49 = (void *)v48;
        if (v48)
          v50 = (_UNKNOWN **)v48;
        else
          v50 = &off_1002FEDC0;
        v92 = v50;
        v80[15] = CFSTR("seMigrationInst");
        v51 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v20 + 40), "migrationInstances"));
        v52 = (void *)v51;
        if (v51)
          v53 = (_UNKNOWN **)v51;
        else
          v53 = &off_1002FEDC0;
        v80[16] = CFSTR("sePidMigrationState");
        v93 = v53;
        v94 = v71;
        v54 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, v80, 17));
        -[NSMutableDictionary addEntriesFromDictionary:](v72, "addEntriesFromDictionary:", v54);

        if (v65)
        v19 = v70;
        v32 = v71;
        v21 = v72;
      }
    }
    else
    {
      v32 = &stru_1002ED8A8;
    }
    if (-[NSMutableDictionary count](v21, "count"))
      sub_10020BF08((uint64_t)NFDailyStatisticsCALogger, v21);
    v55 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v20 + 376), "cachedAppletsUnfiltered"));

    if (v55)
      sub_10022B744(*(void **)(v20 + 376));
    v78 = CFSTR("radioIsEnabled");
    if (*(_QWORD *)(v20 + 288) == 1)
      v56 = &__kCFBooleanTrue;
    else
      v56 = &__kCFBooleanFalse;
    v79 = v56;
    v57 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v79, &v78, 1));
    +[NFGeneralStatisticsCALogger updateGeneralDeviceStatistic:](NFGeneralStatisticsCALogger, "updateGeneralDeviceStatistic:", v57);

    +[NFGeneralStatisticsCALogger postGeneralDeviceStatistics](NFGeneralStatisticsCALogger, "postGeneralDeviceStatistics");
    +[NFGeneralStatisticsCALogger postAnalyticsGeneralTransactionStatistics](NFGeneralStatisticsCALogger, "postAnalyticsGeneralTransactionStatistics");
    if (HIDWORD(v77))
    {
      if (*(_QWORD *)(v20 + 384))
      {
        v58 = *(void **)(v20 + 40);
        if (v58)
          sub_10020BF78((uint64_t)NFDailyStatisticsCALogger, v58, HIDWORD(v77));
      }
    }

  }
}

void sub_1000E0AA0(void **a1)
{
  id v2;
  char *v3;
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  objc_class *v13;
  int v14;
  const char *v15;
  const char *v16;
  objc_class *v17;
  _BOOL4 v18;
  const char *v19;
  const char *v20;
  const char *v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  NSObject *v25;
  objc_class *v26;
  int v27;
  const char *v28;
  const char *v29;
  const char *v30;
  void *v31;
  void *v32;
  id v33;
  char *v34;
  char *v35;
  void *v36;
  uint64_t v37;
  void (*v38)(uint64_t, const char *, ...);
  objc_class *v39;
  _BOOL4 v40;
  uint64_t v41;
  void *v42;
  uint64_t v43;
  NSObject *v44;
  objc_class *v45;
  int v46;
  const char *v47;
  const char *v48;
  const char *v49;
  NSObject *v50;
  os_log_type_t v51;
  objc_class *v52;
  _BOOL4 v53;
  uint64_t v54;
  void *v55;
  uint64_t v56;
  objc_class *v57;
  int v58;
  const char *v59;
  const char *v60;
  const char *ClassName;
  const char *v62;
  const char *v63;
  const char *Name;
  const char *v65;
  const char *v66;
  char *v67;
  char v68;
  const __CFString *v69;
  void *v70;
  uint8_t buf[4];
  int v72;
  __int16 v73;
  const char *v74;
  __int16 v75;
  const char *v76;
  __int16 v77;
  int v78;
  __int16 v79;
  const char *v80;

  if (a1)
  {
    v68 = 0;
    v2 = sub_1000A0E48(a1[47], (uint64_t)&v68);
    v3 = (char *)objc_claimAutoreleasedReturnValue(v2);
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    v6 = (void (*)(uint64_t, const char *, ...))Logger;
    if (v3)
    {
      if (Logger)
      {
        Class = object_getClass(a1);
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(a1);
        Name = sel_getName("_logSEAttacks");
        v9 = 45;
        if (isMetaClass)
          v9 = 43;
        v6(3, "%c[%{public}s %{public}s]:%i Failed to get AC log presence : %@", v9, ClassName, Name, 7551, v3);
      }
      v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v11 = NFSharedLogGetLogger(v10);
      v12 = objc_claimAutoreleasedReturnValue(v11);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        v13 = object_getClass(a1);
        if (class_isMetaClass(v13))
          v14 = 43;
        else
          v14 = 45;
        v15 = object_getClassName(a1);
        v16 = sel_getName("_logSEAttacks");
        *(_DWORD *)buf = 67110146;
        v72 = v14;
        v73 = 2082;
        v74 = v15;
        v75 = 2082;
        v76 = v16;
        v77 = 1024;
        v78 = 7551;
        v79 = 2112;
        v80 = v3;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get AC log presence : %@", buf, 0x2Cu);
      }
    }
    else
    {
      if (Logger)
      {
        v17 = object_getClass(a1);
        v18 = class_isMetaClass(v17);
        v19 = object_getClassName(a1);
        v20 = sel_getName("_logSEAttacks");
        if (v68)
          v21 = "";
        else
          v21 = " not";
        v22 = 45;
        if (v18)
          v22 = 43;
        v6(6, "%c[%{public}s %{public}s]:%i AC Log%s present", v22, v19, v20, 7548, v21);
      }
      v23 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v24 = NFSharedLogGetLogger(v23);
      v25 = objc_claimAutoreleasedReturnValue(v24);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        v26 = object_getClass(a1);
        if (class_isMetaClass(v26))
          v27 = 43;
        else
          v27 = 45;
        v28 = object_getClassName(a1);
        v29 = sel_getName("_logSEAttacks");
        if (v68)
          v30 = "";
        else
          v30 = " not";
        *(_DWORD *)buf = 67110146;
        v72 = v27;
        v73 = 2082;
        v74 = v28;
        v75 = 2082;
        v76 = v29;
        v77 = 1024;
        v78 = 7548;
        v79 = 2080;
        v80 = v30;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i AC Log%s present", buf, 0x2Cu);
      }

      v69 = CFSTR("hasAttackLogs");
      v31 = &__kCFBooleanTrue;
      if (!v68)
        v31 = &__kCFBooleanFalse;
      v70 = v31;
      v12 = objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v70, &v69, 1));
      +[NFGeneralStatisticsCALogger updateGeneralDeviceStatistic:](NFGeneralStatisticsCALogger, "updateGeneralDeviceStatistic:", v12);
    }

    v32 = a1[47];
    v67 = v3;
    v33 = sub_1000A0078(v32, &v67);
    v34 = (char *)objc_claimAutoreleasedReturnValue(v33);
    v35 = v67;

    v36 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v37 = NFLogGetLogger(v36);
    v38 = (void (*)(uint64_t, const char *, ...))v37;
    if (v35)
    {
      if (v37)
      {
        v39 = object_getClass(a1);
        v40 = class_isMetaClass(v39);
        v62 = object_getClassName(a1);
        v65 = sel_getName("_logSEAttacks");
        v41 = 45;
        if (v40)
          v41 = 43;
        v38(3, "%c[%{public}s %{public}s]:%i Failed to get AC log : %@", v41, v62, v65, 7557, v35);
      }
      v42 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v43 = NFSharedLogGetLogger(v42);
      v44 = objc_claimAutoreleasedReturnValue(v43);
      if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
        goto LABEL_50;
      v45 = object_getClass(a1);
      if (class_isMetaClass(v45))
        v46 = 43;
      else
        v46 = 45;
      v47 = object_getClassName(a1);
      v48 = sel_getName("_logSEAttacks");
      *(_DWORD *)buf = 67110146;
      v72 = v46;
      v73 = 2082;
      v74 = v47;
      v75 = 2082;
      v76 = v48;
      v77 = 1024;
      v78 = 7557;
      v79 = 2112;
      v80 = v35;
      v49 = "%c[%{public}s %{public}s]:%i Failed to get AC log : %@";
      v50 = v44;
      v51 = OS_LOG_TYPE_ERROR;
    }
    else
    {
      if (v37)
      {
        v52 = object_getClass(a1);
        v53 = class_isMetaClass(v52);
        v63 = object_getClassName(a1);
        v66 = sel_getName("_logSEAttacks");
        v54 = 45;
        if (v53)
          v54 = 43;
        v38(6, "%c[%{public}s %{public}s]:%i AC Log : %{public}@", v54, v63, v66, 7555, v34);
      }
      v55 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v56 = NFSharedLogGetLogger(v55);
      v44 = objc_claimAutoreleasedReturnValue(v56);
      if (!os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
        goto LABEL_50;
      v57 = object_getClass(a1);
      if (class_isMetaClass(v57))
        v58 = 43;
      else
        v58 = 45;
      v59 = object_getClassName(a1);
      v60 = sel_getName("_logSEAttacks");
      *(_DWORD *)buf = 67110146;
      v72 = v58;
      v73 = 2082;
      v74 = v59;
      v75 = 2082;
      v76 = v60;
      v77 = 1024;
      v78 = 7555;
      v79 = 2114;
      v80 = v34;
      v49 = "%c[%{public}s %{public}s]:%i AC Log : %{public}@";
      v50 = v44;
      v51 = OS_LOG_TYPE_DEFAULT;
    }
    _os_log_impl((void *)&_mh_execute_header, v50, v51, v49, buf, 0x2Cu);
LABEL_50:

  }
}

void sub_1000E1058(void *a1, uint64_t a2)
{
  _QWORD *v3;
  void *specific;
  void (*Logger)(uint64_t, const char *, ...);
  objc_class *Class;
  uint64_t v7;
  const char *ClassName;
  const char *Name;
  unint64_t v10;
  const __CFString *v11;
  const __CFString *v12;
  void *v13;
  uint64_t v14;
  NSObject *v15;
  objc_class *v16;
  int v17;
  const char *v18;
  const char *v19;
  unint64_t v20;
  const __CFString *v21;
  const __CFString *v22;
  uint8_t buf[4];
  int v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  const __CFString *v32;
  __int16 v33;
  const __CFString *v34;

  v3 = a1;
  objc_sync_enter(v3);
  if (v3[35] != a2)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(specific);
    if (Logger)
    {
      Class = object_getClass(v3);
      if (class_isMetaClass(Class))
        v7 = 43;
      else
        v7 = 45;
      ClassName = object_getClassName(v3);
      Name = sel_getName("_updateHardwareState:");
      v10 = v3[35] - 1;
      if (v10 > 3)
        v11 = CFSTR("Unknown");
      else
        v11 = (const __CFString *)*((_QWORD *)&off_1002E8718 + v10);
      if ((unint64_t)(a2 - 1) > 3)
        v12 = CFSTR("Unknown");
      else
        v12 = (const __CFString *)*((_QWORD *)&off_1002E8718 + a2 - 1);
      Logger(6, "%c[%{public}s %{public}s]:%i Hardware state %@ -> %@", v7, ClassName, Name, 1580, v11, v12);
    }
    v13 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v14 = NFSharedLogGetLogger(v13);
    v15 = objc_claimAutoreleasedReturnValue(v14);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v16 = object_getClass(v3);
      if (class_isMetaClass(v16))
        v17 = 43;
      else
        v17 = 45;
      v18 = object_getClassName(v3);
      v19 = sel_getName("_updateHardwareState:");
      v20 = v3[35] - 1;
      if (v20 > 3)
        v21 = CFSTR("Unknown");
      else
        v21 = (const __CFString *)*((_QWORD *)&off_1002E8718 + v20);
      if ((unint64_t)(a2 - 1) > 3)
        v22 = CFSTR("Unknown");
      else
        v22 = (const __CFString *)*((_QWORD *)&off_1002E8718 + a2 - 1);
      *(_DWORD *)buf = 67110402;
      v24 = v17;
      v25 = 2082;
      v26 = v18;
      v27 = 2082;
      v28 = v19;
      v29 = 1024;
      v30 = 1580;
      v31 = 2112;
      v32 = v21;
      v33 = 2112;
      v34 = v22;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Hardware state %@ -> %@", buf, 0x36u);
    }

    v3[35] = a2;
  }
  objc_sync_exit(v3);

}

void sub_1000E12B4(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000E12D8(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  _BOOL4 v18;
  _BOOL4 v19;
  _BOOL4 v20;
  void *v21;
  uint64_t v22;
  void (*v23)(uint64_t, const char *, ...);
  objc_class *v24;
  _BOOL4 v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  NSObject *v29;
  objc_class *v30;
  int v31;
  const char *v32;
  const char *v33;
  _BOOL4 v34;
  id v35;
  void *v36;
  uint64_t v37;
  void (*v38)(uint64_t, const char *, ...);
  objc_class *v39;
  _BOOL4 v40;
  uint64_t v41;
  void *v42;
  uint64_t v43;
  NSObject *v44;
  objc_class *v45;
  int v46;
  const char *v47;
  const char *v48;
  void *v49;
  uint64_t v50;
  void (*v51)(uint64_t, const char *, ...);
  objc_class *v52;
  _BOOL4 v53;
  const char *v54;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  NSObject *v58;
  objc_class *v59;
  int v60;
  const char *v61;
  const char *v62;
  NSObject *v63;
  NSObject *v64;
  const char *v65;
  const char *v66;
  const char *Name;
  const char *v68;
  const char *v69;
  const char *v70;
  _QWORD block[5];
  id v72;
  void **state;
  _BYTE state_8[38];
  __int16 v75;
  _BOOL4 v76;

  v2 = _os_activity_create((void *)&_mh_execute_header, "Lock state changed", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_IF_NONE_PRESENT);
  state = 0;
  *(_QWORD *)state_8 = 0;
  os_activity_scope_enter(v2, (os_activity_scope_state_t)&state);
  os_activity_scope_leave((os_activity_scope_state_t)&state);

  v3 = *(_QWORD *)(a1 + 32);
  if (v3)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass((id)v3);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName((id)v3);
      Name = sel_getName("lockStateChanged");
      v10 = 45;
      if (isMetaClass)
        v10 = 43;
      v6(6, "%c[%{public}s %{public}s]:%i ", v10, ClassName, Name, 2479);
    }
    v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v12 = NFSharedLogGetLogger(v11);
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      v14 = object_getClass((id)v3);
      if (class_isMetaClass(v14))
        v15 = 43;
      else
        v15 = 45;
      v16 = object_getClassName((id)v3);
      v17 = sel_getName("lockStateChanged");
      LODWORD(state) = 67109890;
      HIDWORD(state) = v15;
      *(_WORD *)state_8 = 2082;
      *(_QWORD *)&state_8[2] = v16;
      *(_WORD *)&state_8[10] = 2082;
      *(_QWORD *)&state_8[12] = v17;
      *(_WORD *)&state_8[20] = 1024;
      *(_DWORD *)&state_8[22] = 2479;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", (uint8_t *)&state, 0x22u);
    }

    v18 = sub_1001EB62C(*(void **)(v3 + 88));
    v19 = sub_1000098F0(*(void **)(v3 + 88));
    v20 = sub_10000993C(*(void **)(v3 + 88));
    v21 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v22 = NFLogGetLogger(v21);
    if (v22)
    {
      v23 = (void (*)(uint64_t, const char *, ...))v22;
      v24 = object_getClass((id)v3);
      v25 = class_isMetaClass(v24);
      v65 = object_getClassName((id)v3);
      v68 = sel_getName("lockStateChanged");
      v26 = 45;
      if (v25)
        v26 = 43;
      v23(6, "%c[%{public}s %{public}s]:%i isLocked: %d, hasBeenUnLocked: %d, hasBeenSEUnlocked: %d", v26, v65, v68, 2489, v18, v19, v20);
    }
    v27 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v28 = NFSharedLogGetLogger(v27);
    v29 = objc_claimAutoreleasedReturnValue(v28);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      v30 = object_getClass((id)v3);
      if (class_isMetaClass(v30))
        v31 = 43;
      else
        v31 = 45;
      v32 = object_getClassName((id)v3);
      v33 = sel_getName("lockStateChanged");
      LODWORD(state) = 67110658;
      HIDWORD(state) = v31;
      *(_WORD *)state_8 = 2082;
      *(_QWORD *)&state_8[2] = v32;
      *(_WORD *)&state_8[10] = 2082;
      *(_QWORD *)&state_8[12] = v33;
      *(_WORD *)&state_8[20] = 1024;
      *(_DWORD *)&state_8[22] = 2489;
      *(_WORD *)&state_8[26] = 1024;
      *(_DWORD *)&state_8[28] = v18;
      *(_WORD *)&state_8[32] = 1024;
      *(_DWORD *)&state_8[34] = v19;
      v75 = 1024;
      v76 = v20;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i isLocked: %d, hasBeenUnLocked: %d, hasBeenSEUnlocked: %d", (uint8_t *)&state, 0x34u);
    }

    if (!v18
      && !+[NFSecureElementWrapper isAuthRandomEntangled](NFSecureElementWrapper, "isAuthRandomEntangled")
      && objc_msgSend(*(id *)(v3 + 376), "jcopSupportsEntanglement"))
    {
      v72 = 0;
      v34 = sub_1002074C8((uint64_t)NFSSEWrapper, &v72);
      v35 = v72;
      if (v34)
      {
        sub_1000E3810(v3, 0);
      }
      else
      {
        v36 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v37 = NFLogGetLogger(v36);
        if (v37)
        {
          v38 = (void (*)(uint64_t, const char *, ...))v37;
          v39 = object_getClass((id)v3);
          v40 = class_isMetaClass(v39);
          v66 = object_getClassName((id)v3);
          v69 = sel_getName("lockStateChanged");
          v41 = 45;
          if (v40)
            v41 = 43;
          v38(6, "%c[%{public}s %{public}s]:%i SSE does not support entanglement : %{public}@", v41, v66, v69, 2499, v35);
        }
        v42 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v43 = NFSharedLogGetLogger(v42);
        v44 = objc_claimAutoreleasedReturnValue(v43);
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
        {
          v45 = object_getClass((id)v3);
          if (class_isMetaClass(v45))
            v46 = 43;
          else
            v46 = 45;
          v47 = object_getClassName((id)v3);
          v48 = sel_getName("lockStateChanged");
          LODWORD(state) = 67110146;
          HIDWORD(state) = v46;
          *(_WORD *)state_8 = 2082;
          *(_QWORD *)&state_8[2] = v47;
          *(_WORD *)&state_8[10] = 2082;
          *(_QWORD *)&state_8[12] = v48;
          *(_WORD *)&state_8[20] = 1024;
          *(_DWORD *)&state_8[22] = 2499;
          *(_WORD *)&state_8[26] = 2114;
          *(_QWORD *)&state_8[28] = v35;
          _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i SSE does not support entanglement : %{public}@", (uint8_t *)&state, 0x2Cu);
        }

      }
    }
    if (v19)
    {
      if ((NFProductIsMac() & 1) == 0)
        sub_1000E7FE0(v3, 0);
      if (!v20)
      {
        NFProductIsWatch();
LABEL_55:
        v64 = *(NSObject **)(v3 + 232);
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_1000EBF98;
        block[3] = &unk_1002E5C58;
        block[4] = v3;
        dispatch_async(v64, block);
        return;
      }
      if (*(_BYTE *)(v3 + 338))
      {
        *(_BYTE *)(v3 + 338) = 0;
        v49 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v50 = NFLogGetLogger(v49);
        if (v50)
        {
          v51 = (void (*)(uint64_t, const char *, ...))v50;
          v52 = object_getClass((id)v3);
          v53 = class_isMetaClass(v52);
          v54 = object_getClassName((id)v3);
          v70 = sel_getName("lockStateChanged");
          v55 = 45;
          if (v53)
            v55 = 43;
          v51(6, "%c[%{public}s %{public}s]:%i Ending hardware pre-warm", v55, v54, v70, 2532);
        }
        v56 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v57 = NFSharedLogGetLogger(v56);
        v58 = objc_claimAutoreleasedReturnValue(v57);
        if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
        {
          v59 = object_getClass((id)v3);
          if (class_isMetaClass(v59))
            v60 = 43;
          else
            v60 = 45;
          v61 = object_getClassName((id)v3);
          v62 = sel_getName("lockStateChanged");
          LODWORD(state) = 67109890;
          HIDWORD(state) = v60;
          *(_WORD *)state_8 = 2082;
          *(_QWORD *)&state_8[2] = v61;
          *(_WORD *)&state_8[10] = 2082;
          *(_QWORD *)&state_8[12] = v62;
          *(_WORD *)&state_8[20] = 1024;
          *(_DWORD *)&state_8[22] = 2532;
          _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Ending hardware pre-warm", (uint8_t *)&state, 0x22u);
        }

        sub_1001FABB8(*(void **)(v3 + 368), CFSTR("Prewarm"));
      }
    }
    if ((NFProductIsWatch() & 1) == 0 && v20)
    {
      v63 = *(NSObject **)(v3 + 232);
      state = _NSConcreteStackBlock;
      *(_QWORD *)state_8 = 3221225472;
      *(_QWORD *)&state_8[8] = sub_1000EBE90;
      *(_QWORD *)&state_8[16] = &unk_1002E5C58;
      *(_QWORD *)&state_8[24] = v3;
      dispatch_async(v63, &state);
    }
    goto LABEL_55;
  }
}

NSMutableDictionary *sub_1000E194C(NSMutableDictionary *a1)
{
  NSMutableDictionary *v1;
  id v2;
  uint64_t v3;
  id v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  void *specific;
  uint64_t Logger;
  void (*v16)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  NSObject *v23;
  objc_class *v24;
  int v25;
  void *v26;
  uint64_t v27;
  void (*v28)(uint64_t, const char *, ...);
  objc_class *v29;
  _BOOL4 v30;
  const char *v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  NSObject *v35;
  objc_class *v36;
  int v37;
  const char *v38;
  const char *v39;
  void *v40;
  uint64_t v41;
  void (*v42)(uint64_t, const char *, ...);
  objc_class *v43;
  _BOOL4 v44;
  const char *v45;
  uint64_t v46;
  void *v47;
  uint64_t v48;
  NSObject *v49;
  objc_class *v50;
  int v51;
  const char *v52;
  const char *v53;
  void *v54;
  uint64_t v55;
  void (*v56)(uint64_t, const char *, ...);
  objc_class *v57;
  _BOOL4 v58;
  const char *v59;
  uint64_t v60;
  void *v61;
  uint64_t v62;
  NSObject *v63;
  objc_class *v64;
  int v65;
  const char *v66;
  const char *v67;
  void *v68;
  uint64_t v69;
  void (*v70)(uint64_t, const char *, ...);
  objc_class *v71;
  _BOOL4 v72;
  const char *v73;
  uint64_t v74;
  void *v75;
  uint64_t v76;
  NSObject *v77;
  objc_class *v78;
  int v79;
  const char *v80;
  const char *v81;
  void *v82;
  uint64_t v83;
  void (*v84)(uint64_t, const char *, ...);
  objc_class *v85;
  _BOOL4 v86;
  const char *v87;
  uint64_t v88;
  void *v89;
  uint64_t v90;
  NSObject *v91;
  objc_class *v92;
  int v93;
  const char *v94;
  const char *v95;
  id v96;
  void *v97;
  uint64_t v98;
  void (*v99)(uint64_t, const char *, ...);
  objc_class *v100;
  _BOOL4 v101;
  const char *v102;
  uint64_t v103;
  void *v104;
  uint64_t v105;
  NSObject *v106;
  objc_class *v107;
  int v108;
  const char *v109;
  const char *v110;
  void *v111;
  void *v112;
  unsigned int v113;
  void *v114;
  uint64_t v115;
  void (*v116)(uint64_t, const char *, ...);
  objc_class *v117;
  _BOOL4 v118;
  uint64_t v119;
  void *v120;
  uint64_t v121;
  NSObject *v122;
  objc_class *v123;
  int v124;
  const char *v125;
  const char *v126;
  uint64_t v127;
  void *v128;
  void *v129;
  unsigned int v130;
  void *v131;
  uint64_t v132;
  void (*v133)(uint64_t, const char *, ...);
  objc_class *v134;
  _BOOL4 v135;
  uint64_t v136;
  void *v137;
  uint64_t v138;
  NSObject *v139;
  objc_class *v140;
  int v141;
  const char *v142;
  const char *v143;
  uint64_t v144;
  void *v145;
  void *v146;
  unsigned int v147;
  void *v148;
  uint64_t v149;
  void (*v150)(uint64_t, const char *, ...);
  objc_class *v151;
  _BOOL4 v152;
  uint64_t v153;
  void *v154;
  uint64_t v155;
  NSObject *v156;
  objc_class *v157;
  int v158;
  const char *v159;
  const char *v160;
  uint64_t v161;
  void *v162;
  void *v163;
  unsigned int v164;
  void *v165;
  uint64_t v166;
  void (*v167)(uint64_t, const char *, ...);
  objc_class *v168;
  _BOOL4 v169;
  uint64_t v170;
  void *v171;
  uint64_t v172;
  NSObject *v173;
  objc_class *v174;
  int v175;
  const char *v176;
  const char *v177;
  uint64_t v178;
  void *v179;
  void *v180;
  unsigned int v181;
  void *v182;
  uint64_t v183;
  void (*v184)(uint64_t, const char *, ...);
  objc_class *v185;
  _BOOL4 v186;
  uint64_t v187;
  void *v188;
  uint64_t v189;
  NSObject *v190;
  objc_class *v191;
  int v192;
  const char *v193;
  const char *v194;
  uint64_t v195;
  void *v196;
  void *v197;
  unsigned int v198;
  void *v199;
  uint64_t v200;
  void (*v201)(uint64_t, const char *, ...);
  objc_class *v202;
  _BOOL4 v203;
  uint64_t v204;
  void *v205;
  uint64_t v206;
  NSObject *v207;
  objc_class *v208;
  int v209;
  const char *v210;
  const char *v211;
  uint64_t v212;
  void *v213;
  void *v214;
  id v215;
  void *v216;
  uint64_t v217;
  void (*v218)(uint64_t, const char *, ...);
  objc_class *v219;
  _BOOL4 v220;
  uint64_t v221;
  void *v222;
  uint64_t v223;
  NSObject *v224;
  objc_class *v225;
  int v226;
  const char *v227;
  const char *v228;
  unint64_t v229;
  uint64_t v230;
  void *v231;
  void *v232;
  id v233;
  void *v234;
  uint64_t v235;
  void (*v236)(uint64_t, const char *, ...);
  objc_class *v237;
  _BOOL4 v238;
  uint64_t v239;
  void *v240;
  uint64_t v241;
  NSObject *v242;
  objc_class *v243;
  int v244;
  const char *v245;
  const char *v246;
  unint64_t v247;
  void *v248;
  uint64_t v249;
  id v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  void *v256;
  void *v257;
  void *v258;
  Class isa;
  char v260;
  id v261;
  uint64_t v262;
  uint64_t v263;
  const char *v265;
  const char *v266;
  const char *v267;
  const char *v268;
  const char *v269;
  const char *v270;
  const char *v271;
  const char *v272;
  const char *Name;
  const char *v274;
  const char *v275;
  const char *v276;
  const char *v277;
  const char *v278;
  const char *v279;
  const char *v280;
  const char *v281;
  const char *v282;
  const char *v283;
  const char *v284;
  const char *v285;
  const char *v286;
  const char *v287;
  void *v288;
  NSMutableDictionary *v289;
  uint8_t buf[4];
  int v291;
  __int16 v292;
  const char *v293;
  __int16 v294;
  const char *v295;
  __int16 v296;
  int v297;
  __int16 v298;
  unsigned int v299;

  v1 = a1;
  if (a1)
  {
    v289 = objc_opt_new(NSMutableDictionary);
    v2 = objc_msgSend(objc_alloc((Class)NSUserDefaults), "initWithSuiteName:", CFSTR("com.apple.stockholm"));
    objc_msgSend(v2, "synchronize");
    if (objc_msgSend(v2, "BOOLForKey:", CFSTR("LogNCI")))
      v3 = 132;
    else
      v3 = 128;
    if (objc_msgSend(v2, "BOOLForKey:", CFSTR("LogAPI")))
      v3 |= 8uLL;
    if (objc_msgSend(v2, "BOOLForKey:", CFSTR("LogAPDU")))
      v3 |= 0x10uLL;
    if (objc_msgSend(v2, "BOOLForKey:", CFSTR("LogTransactionDetails")))
      v3 |= 0x200uLL;
    if (objc_msgSend(v2, "BOOLForKey:", CFSTR("LogExpressMode")))
      v3 |= 0x400uLL;
    if (objc_msgSend(v2, "BOOLForKey:", CFSTR("LogRSSI")))
      v3 |= 0x4000uLL;
    if (objc_msgSend(v2, "BOOLForKey:", CFSTR("LogMW")))
      v3 |= 0x40000000uLL;
    if (objc_msgSend(v2, "BOOLForKey:", CFSTR("DisableSEUptime")))
      v3 |= 0x8000uLL;
    if (objc_msgSend(v2, "BOOLForKey:", CFSTR("SinglePollExpress")))
      v3 |= 0x40000uLL;
    if (objc_msgSend(v2, "BOOLForKey:", CFSTR("SimulateRestoreOS")))
      v3 |= 0x200000uLL;
    if (objc_msgSend(v2, "BOOLForKey:", CFSTR("LogL1ExtStandby")))
      v3 |= 0x400000uLL;
    if (objc_msgSend(v2, "BOOLForKey:", CFSTR("ForceVenReset")))
      v3 |= 0x4000000uLL;
    v4 = objc_msgSend(v2, "integerForKey:", CFSTR("LogRF"));
    v5 = v3 | 1;
    v6 = v3 | 2;
    if (v4 != (id)1)
      v6 = v3;
    if (v4 != (id)2)
      v5 = v6;
    if (v4 == (id)4)
      v7 = v3 | 3;
    else
      v7 = v5;
    if (objc_msgSend(v2, "integerForKey:", CFSTR("LogLPCD")))
      v7 |= 0x2000uLL;
    if (objc_msgSend(v2, "integerForKey:", CFSTR("LogLPCDAssist")))
      v7 |= 0x100000uLL;
    switch((unint64_t)objc_msgSend(v2, "integerForKey:", CFSTR("CETech")))
    {
      case 1uLL:
        v7 |= 0x20uLL;
        break;
      case 2uLL:
        v7 |= 0x40uLL;
        break;
      case 3uLL:
        v7 |= 0x100uLL;
        break;
      case 4uLL:
        v7 |= 0x60uLL;
        break;
      case 5uLL:
        v8 = 288;
        goto LABEL_46;
      case 6uLL:
        v8 = 320;
        goto LABEL_46;
      case 7uLL:
        v8 = 352;
LABEL_46:
        v7 |= v8;
        break;
      default:
        break;
    }
    v9 = objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "objectForKey:", CFSTR("lpcdConfigOverride")));
    v288 = (void *)v9;
    if (v9)
    {
      v10 = (void *)v9;
      v11 = objc_opt_class(NSNumber);
      if ((objc_opt_isKindOfClass(v10, v11) & 1) != 0)
      {
        v12 = objc_msgSend(v10, "BOOLValue");
        v13 = 0x10000;
        if (v12)
          v13 = 4096;
        v7 |= v13;
      }
    }
    if (objc_msgSend(v2, "BOOLForKey:", CFSTR("lpcdAssistDisabled")))
    {
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v16 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(v1);
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(v1);
        Name = sel_getName("_readDriverSettings");
        v20 = 45;
        if (isMetaClass)
          v20 = 43;
        v16(6, "%c[%{public}s %{public}s]:%i disabling LPCD assist with defaults", v20, ClassName, Name, 8045);
      }
      v21 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v22 = NFSharedLogGetLogger(v21);
      v23 = objc_claimAutoreleasedReturnValue(v22);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        v24 = object_getClass(v1);
        if (class_isMetaClass(v24))
          v25 = 43;
        else
          v25 = 45;
        *(_DWORD *)buf = 67109890;
        v291 = v25;
        v292 = 2082;
        v293 = object_getClassName(v1);
        v294 = 2082;
        v295 = sel_getName("_readDriverSettings");
        v296 = 1024;
        v297 = 8045;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i disabling LPCD assist with defaults", buf, 0x22u);
      }

      v7 |= 0x2000000uLL;
    }
    if (objc_msgSend(v2, "BOOLForKey:", CFSTR("lpcdAssistWithECP")))
    {
      v26 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v27 = NFLogGetLogger(v26);
      if (v27)
      {
        v28 = (void (*)(uint64_t, const char *, ...))v27;
        v29 = object_getClass(v1);
        v30 = class_isMetaClass(v29);
        v31 = object_getClassName(v1);
        v274 = sel_getName("_readDriverSettings");
        v32 = 45;
        if (v30)
          v32 = 43;
        v28(6, "%c[%{public}s %{public}s]:%i Enabling LPCD assist w/ECP", v32, v31, v274, 8050);
      }
      v33 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v34 = NFSharedLogGetLogger(v33);
      v35 = objc_claimAutoreleasedReturnValue(v34);
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
      {
        v36 = object_getClass(v1);
        if (class_isMetaClass(v36))
          v37 = 43;
        else
          v37 = 45;
        v38 = object_getClassName(v1);
        v39 = sel_getName("_readDriverSettings");
        *(_DWORD *)buf = 67109890;
        v291 = v37;
        v292 = 2082;
        v293 = v38;
        v294 = 2082;
        v295 = v39;
        v296 = 1024;
        v297 = 8050;
        _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Enabling LPCD assist w/ECP", buf, 0x22u);
      }

      v7 |= 0xFFFFFFFF80000000;
    }
    if (objc_msgSend(v2, "BOOLForKey:", CFSTR("DisableLPCDCardRemoval")))
    {
      v40 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v41 = NFLogGetLogger(v40);
      if (v41)
      {
        v42 = (void (*)(uint64_t, const char *, ...))v41;
        v43 = object_getClass(v1);
        v44 = class_isMetaClass(v43);
        v45 = object_getClassName(v1);
        v275 = sel_getName("_readDriverSettings");
        v46 = 45;
        if (v44)
          v46 = 43;
        v42(6, "%c[%{public}s %{public}s]:%i Disable LPCD card removal with defaults", v46, v45, v275, 8055);
      }
      v47 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v48 = NFSharedLogGetLogger(v47);
      v49 = objc_claimAutoreleasedReturnValue(v48);
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
      {
        v50 = object_getClass(v1);
        if (class_isMetaClass(v50))
          v51 = 43;
        else
          v51 = 45;
        v52 = object_getClassName(v1);
        v53 = sel_getName("_readDriverSettings");
        *(_DWORD *)buf = 67109890;
        v291 = v51;
        v292 = 2082;
        v293 = v52;
        v294 = 2082;
        v295 = v53;
        v296 = 1024;
        v297 = 8055;
        _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Disable LPCD card removal with defaults", buf, 0x22u);
      }

      v7 |= 0x8000000uLL;
    }
    if (objc_msgSend(v2, "BOOLForKey:", CFSTR("WriteCounters")))
    {
      v54 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v55 = NFLogGetLogger(v54);
      if (v55)
      {
        v56 = (void (*)(uint64_t, const char *, ...))v55;
        v57 = object_getClass(v1);
        v58 = class_isMetaClass(v57);
        v59 = object_getClassName(v1);
        v276 = sel_getName("_readDriverSettings");
        v60 = 45;
        if (v58)
          v60 = 43;
        v56(6, "%c[%{public}s %{public}s]:%i Enabling write counters", v60, v59, v276, 8060);
      }
      v61 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v62 = NFSharedLogGetLogger(v61);
      v63 = objc_claimAutoreleasedReturnValue(v62);
      if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
      {
        v64 = object_getClass(v1);
        if (class_isMetaClass(v64))
          v65 = 43;
        else
          v65 = 45;
        v66 = object_getClassName(v1);
        v67 = sel_getName("_readDriverSettings");
        *(_DWORD *)buf = 67109890;
        v291 = v65;
        v292 = 2082;
        v293 = v66;
        v294 = 2082;
        v295 = v67;
        v296 = 1024;
        v297 = 8060;
        _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Enabling write counters", buf, 0x22u);
      }

      v7 |= 0x10000000uLL;
    }
    if (objc_msgSend(v2, "BOOLForKey:", CFSTR("forceFieldDetectOff")))
    {
      v68 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v69 = NFLogGetLogger(v68);
      if (v69)
      {
        v70 = (void (*)(uint64_t, const char *, ...))v69;
        v71 = object_getClass(v1);
        v72 = class_isMetaClass(v71);
        v73 = object_getClassName(v1);
        v277 = sel_getName("_readDriverSettings");
        v74 = 45;
        if (v72)
          v74 = 43;
        v70(6, "%c[%{public}s %{public}s]:%i Force disabling FD", v74, v73, v277, 8065);
      }
      v75 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v76 = NFSharedLogGetLogger(v75);
      v77 = objc_claimAutoreleasedReturnValue(v76);
      if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
      {
        v78 = object_getClass(v1);
        if (class_isMetaClass(v78))
          v79 = 43;
        else
          v79 = 45;
        v80 = object_getClassName(v1);
        v81 = sel_getName("_readDriverSettings");
        *(_DWORD *)buf = 67109890;
        v291 = v79;
        v292 = 2082;
        v293 = v80;
        v294 = 2082;
        v295 = v81;
        v296 = 1024;
        v297 = 8065;
        _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Force disabling FD", buf, 0x22u);
      }

      v7 |= 0x20000000uLL;
    }
    if (objc_msgSend(v2, "BOOLForKey:", CFSTR("DisableTypeBSuppression")))
    {
      v82 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v83 = NFLogGetLogger(v82);
      if (v83)
      {
        v84 = (void (*)(uint64_t, const char *, ...))v83;
        v85 = object_getClass(v1);
        v86 = class_isMetaClass(v85);
        v87 = object_getClassName(v1);
        v278 = sel_getName("_readDriverSettings");
        v88 = 45;
        if (v86)
          v88 = 43;
        v84(6, "%c[%{public}s %{public}s]:%i Force disabling Type B Suppression", v88, v87, v278, 8070);
      }
      v89 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v90 = NFSharedLogGetLogger(v89);
      v91 = objc_claimAutoreleasedReturnValue(v90);
      if (os_log_type_enabled(v91, OS_LOG_TYPE_DEFAULT))
      {
        v92 = object_getClass(v1);
        if (class_isMetaClass(v92))
          v93 = 43;
        else
          v93 = 45;
        v94 = object_getClassName(v1);
        v95 = sel_getName("_readDriverSettings");
        *(_DWORD *)buf = 67109890;
        v291 = v93;
        v292 = 2082;
        v293 = v94;
        v294 = 2082;
        v295 = v95;
        v296 = 1024;
        v297 = 8070;
        _os_log_impl((void *)&_mh_execute_header, v91, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Force disabling Type B Suppression", buf, 0x22u);
      }

      v7 |= (unint64_t)&_mh_execute_header;
    }
    v96 = objc_msgSend(objc_alloc((Class)NSDictionary), "initWithContentsOfFile:", CFSTR("/Library/Preferences/Logging/Subsystems/com.apple.nfc.plist"));
    if (v96)
    {
      v97 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v98 = NFLogGetLogger(v97);
      if (v98)
      {
        v99 = (void (*)(uint64_t, const char *, ...))v98;
        v100 = object_getClass(v1);
        v101 = class_isMetaClass(v100);
        v102 = object_getClassName(v1);
        v279 = sel_getName("_readDriverSettings");
        v103 = 45;
        if (v101)
          v103 = 43;
        v99(6, "%c[%{public}s %{public}s]:%i Loading managed profile settings", v103, v102, v279, 8077);
      }
      v104 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v105 = NFSharedLogGetLogger(v104);
      v106 = objc_claimAutoreleasedReturnValue(v105);
      if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT))
      {
        v107 = object_getClass(v1);
        if (class_isMetaClass(v107))
          v108 = 43;
        else
          v108 = 45;
        v109 = object_getClassName(v1);
        v110 = sel_getName("_readDriverSettings");
        *(_DWORD *)buf = 67109890;
        v291 = v108;
        v292 = 2082;
        v293 = v109;
        v294 = 2082;
        v295 = v110;
        v296 = 1024;
        v297 = 8077;
        _os_log_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Loading managed profile settings", buf, 0x22u);
      }

      v111 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v96, "objectForKey:", CFSTR("LogTransactionDetails")));
      if (v111)
      {
        v112 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v96, "objectForKey:", CFSTR("LogTransactionDetails")));
        v113 = objc_msgSend(v112, "BOOLValue");

        v114 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v115 = NFLogGetLogger(v114);
        if (v115)
        {
          v116 = (void (*)(uint64_t, const char *, ...))v115;
          v117 = object_getClass(v1);
          v118 = class_isMetaClass(v117);
          v265 = object_getClassName(v1);
          v280 = sel_getName("_readDriverSettings");
          v119 = 45;
          if (v118)
            v119 = 43;
          v116(5, "%c[%{public}s %{public}s]:%i Overriding pref settings for Tx Details with managed profile: %d", v119, v265, v280, 8080, v113);
        }
        v120 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v121 = NFSharedLogGetLogger(v120);
        v122 = objc_claimAutoreleasedReturnValue(v121);
        if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT))
        {
          v123 = object_getClass(v1);
          if (class_isMetaClass(v123))
            v124 = 43;
          else
            v124 = 45;
          v125 = object_getClassName(v1);
          v126 = sel_getName("_readDriverSettings");
          *(_DWORD *)buf = 67110146;
          v291 = v124;
          v292 = 2082;
          v293 = v125;
          v294 = 2082;
          v295 = v126;
          v296 = 1024;
          v297 = 8080;
          v298 = 1024;
          v299 = v113;
          _os_log_impl((void *)&_mh_execute_header, v122, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Overriding pref settings for Tx Details with managed profile: %d", buf, 0x28u);
        }

        v127 = 512;
        if (!v113)
          v127 = 0;
        v7 = v127 | v7 & 0xFFFFFFFFFFFFFDFFLL;
      }
      v128 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v96, "objectForKey:", CFSTR("LogAPDU")));

      if (v128)
      {
        v129 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v96, "objectForKey:", CFSTR("LogAPDU")));
        v130 = objc_msgSend(v129, "BOOLValue");

        v131 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v132 = NFLogGetLogger(v131);
        if (v132)
        {
          v133 = (void (*)(uint64_t, const char *, ...))v132;
          v134 = object_getClass(v1);
          v135 = class_isMetaClass(v134);
          v266 = object_getClassName(v1);
          v281 = sel_getName("_readDriverSettings");
          v136 = 45;
          if (v135)
            v136 = 43;
          v133(5, "%c[%{public}s %{public}s]:%i Overriding pref settings for LogAPDU with managed profile: %d", v136, v266, v281, 8086, v130);
        }
        v137 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v138 = NFSharedLogGetLogger(v137);
        v139 = objc_claimAutoreleasedReturnValue(v138);
        if (os_log_type_enabled(v139, OS_LOG_TYPE_DEFAULT))
        {
          v140 = object_getClass(v1);
          if (class_isMetaClass(v140))
            v141 = 43;
          else
            v141 = 45;
          v142 = object_getClassName(v1);
          v143 = sel_getName("_readDriverSettings");
          *(_DWORD *)buf = 67110146;
          v291 = v141;
          v292 = 2082;
          v293 = v142;
          v294 = 2082;
          v295 = v143;
          v296 = 1024;
          v297 = 8086;
          v298 = 1024;
          v299 = v130;
          _os_log_impl((void *)&_mh_execute_header, v139, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Overriding pref settings for LogAPDU with managed profile: %d", buf, 0x28u);
        }

        v144 = 16;
        if (!v130)
          v144 = 0;
        v7 = v144 | v7 & 0xFFFFFFFFFFFFFFEFLL;
      }
      v145 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v96, "objectForKey:", CFSTR("LogAPI")));

      if (v145)
      {
        v146 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v96, "objectForKey:", CFSTR("LogAPI")));
        v147 = objc_msgSend(v146, "BOOLValue");

        v148 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v149 = NFLogGetLogger(v148);
        if (v149)
        {
          v150 = (void (*)(uint64_t, const char *, ...))v149;
          v151 = object_getClass(v1);
          v152 = class_isMetaClass(v151);
          v267 = object_getClassName(v1);
          v282 = sel_getName("_readDriverSettings");
          v153 = 45;
          if (v152)
            v153 = 43;
          v150(5, "%c[%{public}s %{public}s]:%i Overriding pref settings for LogAPI with managed profile: %d", v153, v267, v282, 8092, v147);
        }
        v154 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v155 = NFSharedLogGetLogger(v154);
        v156 = objc_claimAutoreleasedReturnValue(v155);
        if (os_log_type_enabled(v156, OS_LOG_TYPE_DEFAULT))
        {
          v157 = object_getClass(v1);
          if (class_isMetaClass(v157))
            v158 = 43;
          else
            v158 = 45;
          v159 = object_getClassName(v1);
          v160 = sel_getName("_readDriverSettings");
          *(_DWORD *)buf = 67110146;
          v291 = v158;
          v292 = 2082;
          v293 = v159;
          v294 = 2082;
          v295 = v160;
          v296 = 1024;
          v297 = 8092;
          v298 = 1024;
          v299 = v147;
          _os_log_impl((void *)&_mh_execute_header, v156, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Overriding pref settings for LogAPI with managed profile: %d", buf, 0x28u);
        }

        v161 = 8;
        if (!v147)
          v161 = 0;
        v7 = v161 | v7 & 0xFFFFFFFFFFFFFFF7;
      }
      v162 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v96, "objectForKey:", CFSTR("LogExpressMode")));

      if (v162)
      {
        v163 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v96, "objectForKey:", CFSTR("LogExpressMode")));
        v164 = objc_msgSend(v163, "BOOLValue");

        v165 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v166 = NFLogGetLogger(v165);
        if (v166)
        {
          v167 = (void (*)(uint64_t, const char *, ...))v166;
          v168 = object_getClass(v1);
          v169 = class_isMetaClass(v168);
          v268 = object_getClassName(v1);
          v283 = sel_getName("_readDriverSettings");
          v170 = 45;
          if (v169)
            v170 = 43;
          v167(5, "%c[%{public}s %{public}s]:%i Overriding pref settings for LogExpressMode with managed profile: %d", v170, v268, v283, 8098, v164);
        }
        v171 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v172 = NFSharedLogGetLogger(v171);
        v173 = objc_claimAutoreleasedReturnValue(v172);
        if (os_log_type_enabled(v173, OS_LOG_TYPE_DEFAULT))
        {
          v174 = object_getClass(v1);
          if (class_isMetaClass(v174))
            v175 = 43;
          else
            v175 = 45;
          v176 = object_getClassName(v1);
          v177 = sel_getName("_readDriverSettings");
          *(_DWORD *)buf = 67110146;
          v291 = v175;
          v292 = 2082;
          v293 = v176;
          v294 = 2082;
          v295 = v177;
          v296 = 1024;
          v297 = 8098;
          v298 = 1024;
          v299 = v164;
          _os_log_impl((void *)&_mh_execute_header, v173, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Overriding pref settings for LogExpressMode with managed profile: %d", buf, 0x28u);
        }

        v178 = 1024;
        if (!v164)
          v178 = 0;
        v7 = v178 | v7 & 0xFFFFFFFFFFFFFBFFLL;
      }
      v179 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v96, "objectForKey:", CFSTR("LogNCI")));

      if (v179)
      {
        v180 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v96, "objectForKey:", CFSTR("LogNCI")));
        v181 = objc_msgSend(v180, "BOOLValue");

        v182 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v183 = NFLogGetLogger(v182);
        if (v183)
        {
          v184 = (void (*)(uint64_t, const char *, ...))v183;
          v185 = object_getClass(v1);
          v186 = class_isMetaClass(v185);
          v269 = object_getClassName(v1);
          v284 = sel_getName("_readDriverSettings");
          v187 = 45;
          if (v186)
            v187 = 43;
          v184(5, "%c[%{public}s %{public}s]:%i Overriding pref settings with LogNCI managed profile: %d", v187, v269, v284, 8104, v181);
        }
        v188 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v189 = NFSharedLogGetLogger(v188);
        v190 = objc_claimAutoreleasedReturnValue(v189);
        if (os_log_type_enabled(v190, OS_LOG_TYPE_DEFAULT))
        {
          v191 = object_getClass(v1);
          if (class_isMetaClass(v191))
            v192 = 43;
          else
            v192 = 45;
          v193 = object_getClassName(v1);
          v194 = sel_getName("_readDriverSettings");
          *(_DWORD *)buf = 67110146;
          v291 = v192;
          v292 = 2082;
          v293 = v193;
          v294 = 2082;
          v295 = v194;
          v296 = 1024;
          v297 = 8104;
          v298 = 1024;
          v299 = v181;
          _os_log_impl((void *)&_mh_execute_header, v190, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Overriding pref settings with LogNCI managed profile: %d", buf, 0x28u);
        }

        v195 = 4;
        if (!v181)
          v195 = 0;
        v7 = v195 | v7 & 0xFFFFFFFFFFFFFFFBLL;
      }
      v196 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v96, "objectForKey:", CFSTR("SinglePollExpress")));

      if (v196)
      {
        v197 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v96, "objectForKey:", CFSTR("SinglePollExpress")));
        v198 = objc_msgSend(v197, "BOOLValue");

        v199 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v200 = NFLogGetLogger(v199);
        if (v200)
        {
          v201 = (void (*)(uint64_t, const char *, ...))v200;
          v202 = object_getClass(v1);
          v203 = class_isMetaClass(v202);
          v270 = object_getClassName(v1);
          v285 = sel_getName("_readDriverSettings");
          v204 = 45;
          if (v203)
            v204 = 43;
          v201(5, "%c[%{public}s %{public}s]:%i Overriding pref settings with Force SinglePoll Express managed profile: %d", v204, v270, v285, 8111, v198);
        }
        v205 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v206 = NFSharedLogGetLogger(v205);
        v207 = objc_claimAutoreleasedReturnValue(v206);
        if (os_log_type_enabled(v207, OS_LOG_TYPE_DEFAULT))
        {
          v208 = object_getClass(v1);
          if (class_isMetaClass(v208))
            v209 = 43;
          else
            v209 = 45;
          v210 = object_getClassName(v1);
          v211 = sel_getName("_readDriverSettings");
          *(_DWORD *)buf = 67110146;
          v291 = v209;
          v292 = 2082;
          v293 = v210;
          v294 = 2082;
          v295 = v211;
          v296 = 1024;
          v297 = 8111;
          v298 = 1024;
          v299 = v198;
          _os_log_impl((void *)&_mh_execute_header, v207, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Overriding pref settings with Force SinglePoll Express managed profile: %d", buf, 0x28u);
        }

        v212 = 0x40000;
        if (!v198)
          v212 = 0;
        v7 = v212 | v7 & 0xFFFFFFFFFFFBFFFFLL;
      }
      v213 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v96, "objectForKey:", CFSTR("CETech")));

      if (v213)
      {
        v214 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v96, "objectForKey:", CFSTR("CETech")));
        v215 = objc_msgSend(v214, "intValue");

        v216 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v217 = NFLogGetLogger(v216);
        if (v217)
        {
          v218 = (void (*)(uint64_t, const char *, ...))v217;
          v219 = object_getClass(v1);
          v220 = class_isMetaClass(v219);
          v271 = object_getClassName(v1);
          v286 = sel_getName("_readDriverSettings");
          v221 = 45;
          if (v220)
            v221 = 43;
          v218(5, "%c[%{public}s %{public}s]:%i Overriding pref settings with CE Tech managed profile: 0x%04x", v221, v271, v286, 8118, v215);
        }
        v222 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v223 = NFSharedLogGetLogger(v222);
        v224 = objc_claimAutoreleasedReturnValue(v223);
        if (os_log_type_enabled(v224, OS_LOG_TYPE_DEFAULT))
        {
          v225 = object_getClass(v1);
          if (class_isMetaClass(v225))
            v226 = 43;
          else
            v226 = 45;
          v227 = object_getClassName(v1);
          v228 = sel_getName("_readDriverSettings");
          *(_DWORD *)buf = 67110146;
          v291 = v226;
          v292 = 2082;
          v293 = v227;
          v294 = 2082;
          v295 = v228;
          v296 = 1024;
          v297 = 8118;
          v298 = 1024;
          v299 = v215;
          _os_log_impl((void *)&_mh_execute_header, v224, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Overriding pref settings with CE Tech managed profile: 0x%04x", buf, 0x28u);
        }

        v229 = v7 & 0xFFFFFFFFFFFFFE9FLL;
        switch((int)v215)
        {
          case 1:
            v7 = v229 | 0x20;
            break;
          case 2:
            v7 = v229 | 0x40;
            break;
          case 3:
            v7 = v229 | 0x100;
            break;
          case 4:
            v7 = v229 | 0x60;
            break;
          case 5:
            v230 = 288;
            goto LABEL_224;
          case 6:
            v230 = 320;
LABEL_224:
            v7 = v229 | v230;
            break;
          case 7:
            v7 |= 0x160uLL;
            break;
          default:
            v7 &= 0xFFFFFFFFFFFFFE9FLL;
            break;
        }
      }
      v231 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v96, "objectForKey:", CFSTR("LogRF")));

      if (v231)
      {
        v232 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v96, "objectForKey:", CFSTR("LogRF")));
        v233 = objc_msgSend(v232, "intValue");

        v234 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v235 = NFLogGetLogger(v234);
        if (v235)
        {
          v236 = (void (*)(uint64_t, const char *, ...))v235;
          v237 = object_getClass(v1);
          v238 = class_isMetaClass(v237);
          v272 = object_getClassName(v1);
          v287 = sel_getName("_readDriverSettings");
          v239 = 45;
          if (v238)
            v239 = 43;
          v236(5, "%c[%{public}s %{public}s]:%i Overriding pref settings with LogRF managed profile: 0x%04x", v239, v272, v287, 8133, v233);
        }
        v240 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v241 = NFSharedLogGetLogger(v240);
        v242 = objc_claimAutoreleasedReturnValue(v241);
        if (os_log_type_enabled(v242, OS_LOG_TYPE_DEFAULT))
        {
          v243 = object_getClass(v1);
          if (class_isMetaClass(v243))
            v244 = 43;
          else
            v244 = 45;
          v245 = object_getClassName(v1);
          v246 = sel_getName("_readDriverSettings");
          *(_DWORD *)buf = 67110146;
          v291 = v244;
          v292 = 2082;
          v293 = v245;
          v294 = 2082;
          v295 = v246;
          v296 = 1024;
          v297 = 8133;
          v298 = 1024;
          v299 = v233;
          _os_log_impl((void *)&_mh_execute_header, v242, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Overriding pref settings with LogRF managed profile: 0x%04x", buf, 0x28u);
        }

        v247 = v7 & 0xFFFFFFFFFFFFFFFCLL;
        if ((_DWORD)v233 == 1)
          v247 = v7 & 0xFFFFFFFFFFFFFFFCLL | 2;
        if ((_DWORD)v233 == 2)
          v247 = v7 & 0xFFFFFFFFFFFFFFFCLL | 1;
        if ((_DWORD)v233 == 4)
          v7 |= 3uLL;
        else
          v7 = v247;
      }
    }
    v248 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "dataForKey:", CFSTR("ChipscopeConfig")));
    if (v248)
    {
      v249 = objc_opt_class(NSData);
      if ((objc_opt_isKindOfClass(v248, v249) & 1) != 0)
      {
        v250 = objc_retainAutorelease(v248);
        if (objc_msgSend(v250, "bytes"))
        {
          if (objc_msgSend(v250, "length") && objc_msgSend(v2, "integerForKey:", CFSTR("Chipscope")))
          {
            v7 |= 0x20000uLL;
            -[NSMutableDictionary setObject:forKeyedSubscript:](v289, "setObject:forKeyedSubscript:", v250, CFSTR("chipscope"));
          }
        }
      }
    }
    v251 = (uint64_t)objc_msgSend(v2, "integerForKey:", CFSTR("PollingPeriod"));
    v252 = v251 & ~(v251 >> 63);
    v253 = (uint64_t)objc_msgSend(v2, "integerForKey:", CFSTR("GenericATxTimeout"));
    v254 = v253 & ~(v253 >> 63);
    if (NFProductHasThermistor())
      v255 = v7 | 0x1000000;
    else
      v255 = v7;
    v256 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v255));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v289, "setObject:forKeyedSubscript:", v256, CFSTR("flags"));

    v257 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", v252));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v289, "setObject:forKeyedSubscript:", v257, CFSTR("pollPeriod"));

    v258 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", v254));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v289, "setObject:forKeyedSubscript:", v258, CFSTR("atx"));

    isa = v1[10].super.super.isa;
    if (isa)
      v260 = *((_BYTE *)isa + 8) != 0;
    else
      v260 = 0;
    sub_1000E43E4(v1, v260);
    -[objc_class refreshUserDefaultsOverride](v1[51].super.super.isa, "refreshUserDefaultsOverride");
    BYTE6(v1[43].super.super.isa) = objc_msgSend(v2, "BOOLForKey:", CFSTR("DumpLogsOnStartup"));
    v261 = objc_msgSend(v2, "BOOLForKey:", CFSTR("LPMAlwaysOn"));
    BYTE5(v1[43].super.super.isa) = (_BYTE)v261;
    if (NFIsInternalBuild(v261))
    {
      v262 = (uint64_t)objc_msgSend(v2, "integerForKey:", CFSTR("PowerCountersInterval"));
      v263 = v262 & ~(v262 >> 63);
    }
    else
    {
      v263 = 0;
    }
    v1[37].super.super.isa = (Class)v263;
    v1 = v289;

  }
  return v1;
}

void sub_1000E32B0(uint64_t a1)
{
  void *v2;
  id v3;
  void *v4;
  uint64_t v5;
  void *v6;
  id v7;
  uint64_t v8;
  _QWORD v9[4];
  id v10[3];
  id location;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  __int128 buf;
  void (*v17)(_QWORD *);
  void *v18;
  uint64_t *v19;

  objc_initWeak(&location, *(id *)(a1 + 32));
  v12 = 0;
  v13 = &v12;
  v14 = 0x2050000000;
  v2 = (void *)qword_10032A9D0;
  v15 = qword_10032A9D0;
  if (!qword_10032A9D0)
  {
    *(_QWORD *)&buf = _NSConcreteStackBlock;
    *((_QWORD *)&buf + 1) = 3221225472;
    v17 = sub_10011BA34;
    v18 = &unk_1002E5E30;
    v19 = &v12;
    sub_10011BA34(&buf);
    v2 = (void *)v13[3];
  }
  v3 = objc_retainAutorelease(v2);
  _Block_object_dispose(&v12, 8);
  v4 = (void *)objc_opt_new(v3);
  v5 = *(_QWORD *)(a1 + 40);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  v9[2] = sub_1000E34E0;
  v9[3] = &unk_1002E7F50;
  objc_copyWeak(v10, &location);
  v6 = *(void **)(a1 + 40);
  v10[1] = *(id *)(a1 + 48);
  v10[2] = v6;
  objc_msgSend(v4, "postComponentStatusEventFor:status:withReply:", 7, v5, v9);

  v7 = *(id *)(a1 + 32);
  objc_sync_enter(v7);
  qword_100329770 = *(_QWORD *)(a1 + 40);
  objc_sync_exit(v7);

  v8 = *(_QWORD *)(a1 + 40);
  if (v8 != 1 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_FAULT))
  {
    LODWORD(buf) = 134217984;
    *(_QWORD *)((char *)&buf + 4) = v8;
    _os_log_fault_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_FAULT, "HW in bad state %llu - reported to the system health monitor", (uint8_t *)&buf, 0xCu);
  }
  objc_destroyWeak(v10);
  objc_destroyWeak(&location);
}

void sub_1000E34A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location, char a17)
{
  _Block_object_dispose(&a17, 8);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000E34E0(uint64_t a1, int a2, void *a3)
{
  __CFString *v5;
  id WeakRetained;
  void *specific;
  uint64_t Logger;
  void (*v9)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  const __CFString *v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  NSObject *v18;
  objc_class *v19;
  int v20;
  const char *v21;
  const char *v22;
  const __CFString *v23;
  const char *v24;
  NSObject *v25;
  os_log_type_t v26;
  objc_class *v27;
  _BOOL4 v28;
  const char *v29;
  const char *v30;
  const __CFString *v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  objc_class *v35;
  int v36;
  const char *v37;
  const char *v38;
  const __CFString *v39;
  const __CFString *v40;
  const __CFString *v41;
  uint8_t buf[4];
  int v43;
  __int16 v44;
  const char *v45;
  __int16 v46;
  const char *v47;
  __int16 v48;
  int v49;
  __int16 v50;
  const __CFString *v51;
  __int16 v52;
  const __CFString *v53;

  v5 = a3;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  v9 = (void (*)(uint64_t, const char *, ...))Logger;
  if (v5)
  {
    if (Logger)
    {
      Class = object_getClass(WeakRetained);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(WeakRetained);
      Name = sel_getName(*(SEL *)(a1 + 40));
      if (a2)
        v14 = CFSTR("success");
      else
        v14 = CFSTR("failure");
      v41 = v14;
      v15 = 45;
      if (isMetaClass)
        v15 = 43;
      v9(3, "%c[%{public}s %{public}s]:%i Error posting status (%{public}@) to SystemHealthManager - %{public}@", v15, ClassName, Name, 996, v41, v5);
    }
    v16 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v17 = NFSharedLogGetLogger(v16);
    v18 = objc_claimAutoreleasedReturnValue(v17);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      v19 = object_getClass(WeakRetained);
      if (class_isMetaClass(v19))
        v20 = 43;
      else
        v20 = 45;
      v21 = object_getClassName(WeakRetained);
      v22 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)buf = 67110402;
      if (a2)
        v23 = CFSTR("success");
      else
        v23 = CFSTR("failure");
      v43 = v20;
      v44 = 2082;
      v45 = v21;
      v46 = 2082;
      v47 = v22;
      v48 = 1024;
      v49 = 996;
      v50 = 2114;
      v51 = v23;
      v52 = 2114;
      v53 = v5;
      v24 = "%c[%{public}s %{public}s]:%i Error posting status (%{public}@) to SystemHealthManager - %{public}@";
      v25 = v18;
      v26 = OS_LOG_TYPE_ERROR;
LABEL_30:
      _os_log_impl((void *)&_mh_execute_header, v25, v26, v24, buf, 0x36u);
    }
  }
  else
  {
    if (Logger)
    {
      v27 = object_getClass(WeakRetained);
      v28 = class_isMetaClass(v27);
      v29 = object_getClassName(WeakRetained);
      v30 = sel_getName(*(SEL *)(a1 + 40));
      v31 = CFSTR("failure");
      if (a2)
        v31 = CFSTR("success");
      v32 = 45;
      if (v28)
        v32 = 43;
      v9(6, "%c[%{public}s %{public}s]:%i Posted status (%llu) to SystemHealthManager - %@", v32, v29, v30, 999, *(_QWORD *)(a1 + 48), v31);
    }
    v33 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v34 = NFSharedLogGetLogger(v33);
    v18 = objc_claimAutoreleasedReturnValue(v34);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      v35 = object_getClass(WeakRetained);
      if (class_isMetaClass(v35))
        v36 = 43;
      else
        v36 = 45;
      v37 = object_getClassName(WeakRetained);
      v38 = sel_getName(*(SEL *)(a1 + 40));
      v39 = *(const __CFString **)(a1 + 48);
      v40 = CFSTR("failure");
      *(_DWORD *)buf = 67110402;
      v43 = v36;
      if (a2)
        v40 = CFSTR("success");
      v44 = 2082;
      v45 = v37;
      v46 = 2082;
      v47 = v38;
      v48 = 1024;
      v49 = 999;
      v50 = 2048;
      v51 = v39;
      v52 = 2112;
      v53 = v40;
      v24 = "%c[%{public}s %{public}s]:%i Posted status (%llu) to SystemHealthManager - %@";
      v25 = v18;
      v26 = OS_LOG_TYPE_DEFAULT;
      goto LABEL_30;
    }
  }

}

void sub_1000E3810(uint64_t a1, int a2)
{
  unsigned __int8 v4;
  void *specific;
  uint64_t Logger;
  void (*v7)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  void *v16;
  int v17;
  void *v18;
  void (*v19)(uint64_t, const char *, ...);
  objc_class *v20;
  uint64_t v21;
  const char *v22;
  const char *v23;
  void *v24;
  uint64_t v25;
  NSObject *v26;
  objc_class *v27;
  int v28;
  const char *v29;
  const char *v30;
  uint64_t v31;
  uint64_t v32;
  id v33;
  const char *ClassName;
  const char *Name;
  _QWORD v36[5];
  _QWORD v37[6];
  uint8_t v38[4];
  int v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  const char *v43;
  __int16 v44;
  int v45;
  __int16 v46;
  uint64_t v47;
  uint8_t buf[8];
  _BYTE v49[32];
  id v50;

  v4 = objc_msgSend(*(id *)(a1 + 376), "upgradeChecked");
  if (!+[NFSecureElementWrapper isAuthRandomEntangled](NFSecureElementWrapper, "isAuthRandomEntangled")
    && (v4 & 1) == 0
    && objc_msgSend(*(id *)(a1 + 376), "jcopSupportsEntanglement")
    && sub_1002074C8((uint64_t)NFSSEWrapper, 0))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v7 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass((id)a1);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName((id)a1);
      Name = sel_getName("_upgradeAuthRandomSynchronously:");
      v10 = 45;
      if (isMetaClass)
        v10 = 43;
      v7(6, "%c[%{public}s %{public}s]:%i UpgradeChecked = %d", v10, ClassName, Name, 1191, 0);
    }
    v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v12 = NFSharedLogGetLogger(v11);
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      v14 = object_getClass((id)a1);
      if (class_isMetaClass(v14))
        v15 = 43;
      else
        v15 = 45;
      *(_DWORD *)buf = 67110146;
      *(_DWORD *)&buf[4] = v15;
      *(_WORD *)v49 = 2082;
      *(_QWORD *)&v49[2] = object_getClassName((id)a1);
      *(_WORD *)&v49[10] = 2082;
      *(_QWORD *)&v49[12] = sel_getName("_upgradeAuthRandomSynchronously:");
      *(_WORD *)&v49[20] = 1024;
      *(_DWORD *)&v49[22] = 1191;
      *(_WORD *)&v49[26] = 1024;
      *(_DWORD *)&v49[28] = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i UpgradeChecked = %d", buf, 0x28u);
    }

    *(_QWORD *)buf = 0;
    *(_QWORD *)v49 = buf;
    *(_QWORD *)&v49[8] = 0x3032000000;
    *(_QWORD *)&v49[16] = sub_1000E3C80;
    *(_QWORD *)&v49[24] = sub_1000E3C90;
    v50 = 0;
    if (a2)
    {
      v37[0] = _NSConcreteStackBlock;
      v37[1] = 3221225472;
      v37[2] = sub_1000E3C98;
      v37[3] = &unk_1002E81B8;
      v37[4] = a1;
      v37[5] = buf;
      v16 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig embeddedWiredModeWithFD:](NFRoutingConfig, "embeddedWiredModeWithFD:", 0));
      v17 = sub_1000E3CEC((void **)a1, v37, CFSTR("Upgrade SEP token"), v16);

      if (v17 && !*(_QWORD *)(*(_QWORD *)v49 + 40))
        goto LABEL_29;
      v18 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v19 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v18);
      if (v19)
      {
        v20 = object_getClass((id)a1);
        if (class_isMetaClass(v20))
          v21 = 43;
        else
          v21 = 45;
        v22 = object_getClassName((id)a1);
        v23 = sel_getName("_upgradeAuthRandomSynchronously:");
        v19(3, "%c[%{public}s %{public}s]:%i Failed: %{public}@", v21, v22, v23, 1205, *(_QWORD *)(*(_QWORD *)v49 + 40));
      }
      v24 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v25 = NFSharedLogGetLogger(v24);
      v26 = objc_claimAutoreleasedReturnValue(v25);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        v27 = object_getClass((id)a1);
        if (class_isMetaClass(v27))
          v28 = 43;
        else
          v28 = 45;
        v29 = object_getClassName((id)a1);
        v30 = sel_getName("_upgradeAuthRandomSynchronously:");
        v31 = *(_QWORD *)(*(_QWORD *)v49 + 40);
        *(_DWORD *)v38 = 67110146;
        v39 = v28;
        v40 = 2082;
        v41 = v29;
        v42 = 2082;
        v43 = v30;
        v44 = 1024;
        v45 = 1205;
        v46 = 2114;
        v47 = v31;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed: %{public}@", v38, 0x2Cu);
      }
    }
    else
    {
      v32 = *(_QWORD *)(a1 + 232);
      v26 = objc_claimAutoreleasedReturnValue(+[NFRoutingConfig embeddedWiredMode](NFRoutingConfig, "embeddedWiredMode"));
      v36[0] = _NSConcreteStackBlock;
      v36[1] = 3221225472;
      v36[2] = sub_1000E40E4;
      v36[3] = &unk_1002E5C58;
      v36[4] = a1;
      v33 = +[_NFBuiltinSession createSessionWithWorkQueue:routing:sessionQueuer:didStartWork:](_NFBuiltinSession, "createSessionWithWorkQueue:routing:sessionQueuer:didStartWork:", v32, v26, a1, v36);
    }

LABEL_29:
    _Block_object_dispose(buf, 8);

  }
}

void sub_1000E3C50(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 144), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000E3C80(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_1000E3C90(uint64_t a1)
{

}

BOOL sub_1000E3C98(uint64_t a1)
{
  id v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;

  v2 = sub_1001E5110(*(id *)(*(_QWORD *)(a1 + 32) + 376));
  v3 = objc_claimAutoreleasedReturnValue(v2);
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  v5 = *(void **)(v4 + 40);
  *(_QWORD *)(v4 + 40) = v3;

  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40) == 0;
}

uint64_t sub_1000E3CEC(void **a1, void *a2, void *a3, void *a4)
{
  uint64_t (**v7)(_QWORD);
  id v8;
  id v9;
  void *v10;
  id v11;
  void *v12;
  unint64_t v13;
  void *v14;
  id v15;
  void *v16;
  uint64_t v17;
  void *v18;
  void *specific;
  uint64_t Logger;
  void (*v21)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  NSObject *v28;
  objc_class *v29;
  int v30;
  void *v31;
  void *v32;
  uint64_t v33;
  void (*v34)(uint64_t, const char *, ...);
  objc_class *v35;
  _BOOL4 v36;
  const char *v37;
  uint64_t v38;
  void *v39;
  uint64_t v40;
  NSObject *v41;
  objc_class *v42;
  int v43;
  const char *Name;
  const char *v46;
  uint8_t buf[4];
  int v48;
  __int16 v49;
  const char *v50;
  __int16 v51;
  const char *v52;
  __int16 v53;
  int v54;

  v7 = a2;
  v8 = a3;
  v9 = a4;
  if (a1)
  {
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "lastKnownRoutingConfig"));
    v11 = objc_msgSend(v10, "copy");

    if (!v8)
      goto LABEL_7;
    v12 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig embeddedWiredModeWithFD:](NFRoutingConfig, "embeddedWiredModeWithFD:", 0));
    v13 = 0;
    if ((objc_msgSend(v9, "isEqual:", v12) & 1) == 0)
    {
      v14 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig routingOff](NFRoutingConfig, "routingOff"));
      v13 = objc_msgSend(v9, "isEqual:", v14) ^ 1;

    }
    v15 = sub_1001F84C8(a1[46], v8, v13);
    v16 = (void *)objc_claimAutoreleasedReturnValue(v15);
    if (v16)
    {
      v17 = 0;
    }
    else
    {
LABEL_7:
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "setRoutingConfig:", v9));

      if (v18)
      {
        specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        Logger = NFLogGetLogger(specific);
        if (Logger)
        {
          v21 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(a1);
          isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(a1);
          Name = sel_getName("executeBlock:sessionName:routingConfig:");
          v25 = 45;
          if (isMetaClass)
            v25 = 43;
          v21(3, "%c[%{public}s %{public}s]:%i Failed to change routing.", v25, ClassName, Name, 1711);
        }
        v26 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v27 = NFSharedLogGetLogger(v26);
        v28 = objc_claimAutoreleasedReturnValue(v27);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        {
          v29 = object_getClass(a1);
          if (class_isMetaClass(v29))
            v30 = 43;
          else
            v30 = 45;
          *(_DWORD *)buf = 67109890;
          v48 = v30;
          v49 = 2082;
          v50 = object_getClassName(a1);
          v51 = 2082;
          v52 = sel_getName("executeBlock:sessionName:routingConfig:");
          v53 = 1024;
          v54 = 1711;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to change routing.", buf, 0x22u);
        }

        sub_1001FABB8(a1[46], v8);
        v17 = 0;
      }
      else
      {
        v17 = v7[2](v7);
        v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "setRoutingConfig:", v11));

        if (v31)
        {
          v32 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v33 = NFLogGetLogger(v32);
          if (v33)
          {
            v34 = (void (*)(uint64_t, const char *, ...))v33;
            v35 = object_getClass(a1);
            v36 = class_isMetaClass(v35);
            v37 = object_getClassName(a1);
            v46 = sel_getName("executeBlock:sessionName:routingConfig:");
            v38 = 45;
            if (v36)
              v38 = 43;
            v34(3, "%c[%{public}s %{public}s]:%i Failed to restore routing", v38, v37, v46, 1719);
          }
          v39 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v40 = NFSharedLogGetLogger(v39);
          v41 = objc_claimAutoreleasedReturnValue(v40);
          if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
          {
            v42 = object_getClass(a1);
            if (class_isMetaClass(v42))
              v43 = 43;
            else
              v43 = 45;
            *(_DWORD *)buf = 67109890;
            v48 = v43;
            v49 = 2082;
            v50 = object_getClassName(a1);
            v51 = 2082;
            v52 = sel_getName("executeBlock:sessionName:routingConfig:");
            v53 = 1024;
            v54 = 1719;
            _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to restore routing", buf, 0x22u);
          }

        }
        if (v8)
          sub_1001FABB8(a1[46], v8);
      }
      v16 = 0;
    }

  }
  else
  {
    v17 = 0;
  }

  return v17;
}

id sub_1000E40E4(uint64_t a1)
{
  return sub_1001E5110(*(id *)(*(_QWORD *)(a1 + 32) + 376));
}

BOOL sub_1000E4108(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  v2 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 376), "negotiatePerBootAuthKeys"));
  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  v4 = *(void **)(v3 + 40);
  *(_QWORD *)(v3 + 40) = v2;

  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40) == 0;
}

id sub_1000E415C(uint64_t a1)
{
  return objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 376), "negotiatePerBootAuthKeys");
}

uint64_t sub_1000E4180(uint64_t result)
{
  if (result)
  {
    if (objc_msgSend(*(id *)(result + 40), "migrationState") == (id)1)
    {
      return 0;
    }
    else
    {
      sub_100187CDC((uint64_t)NFBugCapture, CFSTR("Failed to start the session"), CFSTR("File: _NFHardwareManager, Function: _isInAppletMigrationState, Error: Migration state is not idle"), &off_1003065B0);
      return 1;
    }
  }
  return result;
}

uint64_t sub_1000E41D4(uint64_t result)
{
  id *v1;
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  objc_class *v13;
  int v14;
  const char *v15;
  const char *v16;
  unsigned int v17;
  unsigned int v18;
  id v19;
  id v20;
  uint8_t buf[4];
  int v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  unsigned int v30;
  __int16 v31;
  unsigned int v32;

  if (result)
  {
    v1 = (id *)result;
    result = (uint64_t)objc_msgSend(*(id *)(result + 40), "migrationState");
    if (result)
    {
      if (objc_msgSend(v1[5], "migrationState") == (id)1 || objc_msgSend(v1[5], "migrationContext") != (id)3)
      {
        return 0;
      }
      else
      {
        specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        Logger = NFLogGetLogger(specific);
        if (Logger)
        {
          v4 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(v1);
          isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(v1);
          Name = sel_getName("_isInOSUAppletMigrationState");
          v19 = objc_msgSend(v1[5], "migrationState");
          v20 = objc_msgSend(v1[5], "migrationContext");
          v9 = 45;
          if (isMetaClass)
            v9 = 43;
          v4(3, "%c[%{public}s %{public}s]:%i OSU SE migration incomplete 0x%04x, context 0x%04x", v9, ClassName, Name, 1264, v19, v20);
        }
        v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v11 = NFSharedLogGetLogger(v10);
        v12 = objc_claimAutoreleasedReturnValue(v11);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          v13 = object_getClass(v1);
          if (class_isMetaClass(v13))
            v14 = 43;
          else
            v14 = 45;
          v15 = object_getClassName(v1);
          v16 = sel_getName("_isInOSUAppletMigrationState");
          v17 = objc_msgSend(v1[5], "migrationState");
          v18 = objc_msgSend(v1[5], "migrationContext");
          *(_DWORD *)buf = 67110402;
          v22 = v14;
          v23 = 2082;
          v24 = v15;
          v25 = 2082;
          v26 = v16;
          v27 = 1024;
          v28 = 1264;
          v29 = 1024;
          v30 = v17;
          v31 = 1024;
          v32 = v18;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i OSU SE migration incomplete 0x%04x, context 0x%04x", buf, 0x2Eu);
        }

        return 1;
      }
    }
  }
  return result;
}

void sub_1000E43E4(_QWORD *a1, char a2)
{
  NSObject *v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  void (*v9)(uint64_t, const char *, ...);
  objc_class *v10;
  _BOOL4 v11;
  const char *v12;
  const char *v13;
  const __CFString *v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  NSObject *v18;
  objc_class *v19;
  int v20;
  const char *v21;
  const char *v22;
  const __CFString *v23;
  void *v24;
  uint64_t v25;
  void (*v26)(uint64_t, const char *, ...);
  objc_class *v27;
  _BOOL4 v28;
  const char *v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  objc_class *v33;
  int v34;
  void *v35;
  unsigned int v36;
  void *specific;
  uint64_t Logger;
  void (*v39)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  const __CFString *v44;
  uint64_t v45;
  void *v46;
  uint64_t v47;
  NSObject *v48;
  objc_class *v49;
  int v50;
  const char *v51;
  const char *v52;
  const __CFString *v53;
  void *v54;
  uint64_t v55;
  void (*v56)(uint64_t, const char *, ...);
  objc_class *v57;
  _BOOL4 v58;
  const char *v59;
  const char *v60;
  uint64_t v61;
  void *v62;
  uint64_t v63;
  NSObject *v64;
  objc_class *v65;
  int v66;
  const char *v67;
  const char *v68;
  uint64_t v69;
  const char *v70;
  uint8_t buf[4];
  int v72;
  __int16 v73;
  const char *v74;
  __int16 v75;
  const char *v76;
  __int16 v77;
  int v78;
  __int16 v79;
  const __CFString *v80;

  if (a1)
  {
    if ((a2 & 1) != 0)
    {
      v3 = objc_msgSend(objc_alloc((Class)NSUserDefaults), "initWithSuiteName:", CFSTR("com.apple.stockholm"));
      v4 = NFIsChinaSku(-[NSObject synchronize](v3, "synchronize"));
      if ((v4 & 1) == 0)
      {
        if (!NFIsInternalBuild(v4))
          goto LABEL_47;
        v35 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject objectForKey:](v3, "objectForKey:", CFSTR("forceChinaSku")));

        if (!v35)
          goto LABEL_47;
        v36 = -[NSObject BOOLForKey:](v3, "BOOLForKey:", CFSTR("forceChinaSku"));
        specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        Logger = NFLogGetLogger(specific);
        if (Logger)
        {
          v39 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(a1);
          isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(a1);
          Name = sel_getName("radioConfigChanged:");
          if (v36)
            v44 = CFSTR("on");
          else
            v44 = CFSTR("off");
          v45 = 45;
          if (isMetaClass)
            v45 = 43;
          v39(5, "%c[%{public}s %{public}s]:%i Force China Sku: %{public}@", v45, ClassName, Name, 1335, v44);
        }
        v46 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v47 = NFSharedLogGetLogger(v46);
        v48 = objc_claimAutoreleasedReturnValue(v47);
        if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
        {
          v49 = object_getClass(a1);
          if (class_isMetaClass(v49))
            v50 = 43;
          else
            v50 = 45;
          v51 = object_getClassName(a1);
          v52 = sel_getName("radioConfigChanged:");
          *(_DWORD *)buf = 67110146;
          if (v36)
            v53 = CFSTR("on");
          else
            v53 = CFSTR("off");
          v72 = v50;
          v73 = 2082;
          v74 = v51;
          v75 = 2082;
          v76 = v52;
          v77 = 1024;
          v78 = 1335;
          v79 = 2114;
          v80 = v53;
          _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Force China Sku: %{public}@", buf, 0x2Cu);
        }

        if (!v36)
          goto LABEL_47;
      }
      v5 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject objectForKey:](v3, "objectForKey:", CFSTR("nfcRadioEnabled")));

      if (v5)
      {
        v6 = -[NSObject BOOLForKey:](v3, "BOOLForKey:", CFSTR("nfcRadioEnabled"));
        v7 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v8 = NFLogGetLogger(v7);
        if (v8)
        {
          v9 = (void (*)(uint64_t, const char *, ...))v8;
          v10 = object_getClass(a1);
          v11 = class_isMetaClass(v10);
          v12 = object_getClassName(a1);
          v13 = sel_getName("radioConfigChanged:");
          if ((_DWORD)v6)
            v14 = CFSTR("on");
          else
            v14 = CFSTR("off");
          v15 = 45;
          if (v11)
            v15 = 43;
          v9(5, "%c[%{public}s %{public}s]:%i NFC radio preference setting %{public}@", v15, v12, v13, 1344, v14);
        }
        v16 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v17 = NFSharedLogGetLogger(v16);
        v18 = objc_claimAutoreleasedReturnValue(v17);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          v19 = object_getClass(a1);
          if (class_isMetaClass(v19))
            v20 = 43;
          else
            v20 = 45;
          v21 = object_getClassName(a1);
          v22 = sel_getName("radioConfigChanged:");
          v23 = CFSTR("off");
          *(_DWORD *)buf = 67110146;
          v72 = v20;
          v73 = 2082;
          if ((_DWORD)v6)
            v23 = CFSTR("on");
          v74 = v21;
          v75 = 2082;
          v76 = v22;
          v77 = 1024;
          v78 = 1344;
          v79 = 2114;
          v80 = v23;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i NFC radio preference setting %{public}@", buf, 0x2Cu);
        }

      }
      else
      {
LABEL_47:
        v6 = 1;
      }
      a1[36] = v6;
      v54 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v55 = NFLogGetLogger(v54);
      if (v55)
      {
        v56 = (void (*)(uint64_t, const char *, ...))v55;
        v57 = object_getClass(a1);
        v58 = class_isMetaClass(v57);
        v59 = object_getClassName(a1);
        v60 = sel_getName("radioConfigChanged:");
        v61 = 45;
        if (v58)
          v61 = 43;
        v56(6, "%c[%{public}s %{public}s]:%i radio state: %d", v61, v59, v60, 1352, a1[36]);
      }
      v62 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v63 = NFSharedLogGetLogger(v62);
      v64 = objc_claimAutoreleasedReturnValue(v63);
      if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
      {
        v65 = object_getClass(a1);
        if (class_isMetaClass(v65))
          v66 = 43;
        else
          v66 = 45;
        v67 = object_getClassName(a1);
        v68 = sel_getName("radioConfigChanged:");
        v69 = a1[36];
        *(_DWORD *)buf = 67110146;
        v72 = v66;
        v73 = 2082;
        v74 = v67;
        v75 = 2082;
        v76 = v68;
        v77 = 1024;
        v78 = 1352;
        v79 = 1024;
        LODWORD(v80) = v69;
        _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i radio state: %d", buf, 0x28u);
      }

    }
    else
    {
      a1[36] = -1;
      v24 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v25 = NFLogGetLogger(v24);
      if (v25)
      {
        v26 = (void (*)(uint64_t, const char *, ...))v25;
        v27 = object_getClass(a1);
        v28 = class_isMetaClass(v27);
        v29 = object_getClassName(a1);
        v70 = sel_getName("radioConfigChanged:");
        v30 = 45;
        if (v28)
          v30 = 43;
        v26(5, "%c[%{public}s %{public}s]:%i Radio disabled by mobileconfig", v30, v29, v70, 1320);
      }
      v31 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v32 = NFSharedLogGetLogger(v31);
      v3 = objc_claimAutoreleasedReturnValue(v32);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        v33 = object_getClass(a1);
        if (class_isMetaClass(v33))
          v34 = 43;
        else
          v34 = 45;
        *(_DWORD *)buf = 67109890;
        v72 = v34;
        v73 = 2082;
        v74 = object_getClassName(a1);
        v75 = 2082;
        v76 = sel_getName("radioConfigChanged:");
        v77 = 1024;
        v78 = 1320;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Radio disabled by mobileconfig", buf, 0x22u);
      }
    }

  }
}

void sub_1000E49FC(uint64_t a1)
{
  id WeakRetained;
  _BYTE *v2;
  id v3;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v3 = WeakRetained;
    v2 = WeakRetained;
    objc_sync_enter(v2);
    v2[352] = 0;
    objc_sync_exit(v2);

    WeakRetained = v3;
  }

}

void sub_1000E5020(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  void *v14;
  void *v15;
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  objc_sync_exit(v15);
  objc_sync_exit(v14);
  _Unwind_Resume(a1);
}

void sub_1000E506C(uint64_t *a1, void *a2)
{
  id v3;
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v11;
  void *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  NSObject *v16;
  objc_class *v17;
  int v18;
  const char *v19;
  const char *v20;
  void *v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  NSObject *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  NSObject *v31;
  _QWORD block[5];
  id v33;
  const char *v34;
  uint8_t buf[4];
  _BYTE v36[14];
  __int16 v37;
  const char *v38;
  __int16 v39;
  int v40;
  __int16 v41;
  void *v42;
  __int16 v43;
  id v44;

  v3 = a2;
  if (a1)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("didCloseXPCConnection:");
      v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "NF_userInfo"));
      v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "objectForKeyedSubscript:", CFSTR("ClientName")));
      v13 = 45;
      if (isMetaClass)
        v13 = 43;
      v6(6, "%c[%{public}s %{public}s]:%i Removing XPC connection for %{public}@ - %{public}@", v13, ClassName, Name, 1510, v12, v3);

    }
    v14 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v15 = NFSharedLogGetLogger(v14);
    v16 = objc_claimAutoreleasedReturnValue(v15);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      v17 = object_getClass(a1);
      if (class_isMetaClass(v17))
        v18 = 43;
      else
        v18 = 45;
      v19 = object_getClassName(a1);
      v20 = sel_getName("didCloseXPCConnection:");
      v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "NF_userInfo"));
      v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "objectForKeyedSubscript:", CFSTR("ClientName")));
      *(_DWORD *)buf = 67110402;
      *(_DWORD *)v36 = v18;
      *(_WORD *)&v36[4] = 2082;
      *(_QWORD *)&v36[6] = v19;
      v37 = 2082;
      v38 = v20;
      v39 = 1024;
      v40 = 1510;
      v41 = 2114;
      v42 = v22;
      v43 = 2114;
      v44 = v3;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Removing XPC connection for %{public}@ - %{public}@", buf, 0x36u);

    }
    v23 = kdebug_trace(724566044, 0, 0, 0, 0);
    v24 = NFSharedSignpostLog(v23);
    v25 = objc_claimAutoreleasedReturnValue(v24);
    if (os_signpost_enabled(v25))
    {
      v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "NF_userInfo"));
      v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v26, "objectForKeyedSubscript:", CFSTR("ClientName")));
      *(_DWORD *)buf = 138412290;
      *(_QWORD *)v36 = v27;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v25, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "XPC_DISCONNECT", "removing XPC connection for %@", buf, 0xCu);

    }
    v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "userInfo"));
    v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "objectForKey:", CFSTR("serviceType")));

    if (v29 && objc_msgSend(v29, "unsignedIntegerValue") == (id)2)
    {
      v30 = (void *)a1[21];
      a1[21] = 0;

    }
    sub_100050294(a1[9], v3);
    v31 = a1[29];
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000E53D4;
    block[3] = &unk_1002E5C80;
    block[4] = a1;
    v33 = v3;
    v34 = "didCloseXPCConnection:";
    dispatch_async(v31, block);

  }
}

id sub_1000E53D4(uint64_t a1)
{
  id v2;
  id v3;
  void *v4;
  void *v5;
  id v6;
  id v7;
  void *i;
  void *v9;
  uint64_t v10;
  id v11;
  void *v12;
  void *specific;
  void (*Logger)(uint64_t, const char *, ...);
  objc_class *Class;
  uint64_t v16;
  const char *ClassName;
  const char *Name;
  void *v19;
  void *v20;
  void *v21;
  uint64_t v22;
  NSObject *v23;
  objc_class *v24;
  int v25;
  const char *v26;
  const char *v27;
  void *v28;
  void *v29;
  id v31;
  id obj;
  uint64_t v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  uint8_t buf[4];
  int v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  const char *v43;
  __int16 v44;
  int v45;
  __int16 v46;
  id v47;
  __int16 v48;
  void *v49;
  _BYTE v50[128];

  v2 = *(id *)(*(_QWORD *)(a1 + 32) + 176);
  objc_sync_enter(v2);
  objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 176), "removeObject:", *(_QWORD *)(a1 + 40));
  objc_sync_exit(v2);

  sub_1000E57E0(*(_QWORD *)(a1 + 32), *(void **)(a1 + 40));
  v31 = *(id *)(*(_QWORD *)(a1 + 32) + 184);
  objc_sync_enter(v31);
  v3 = objc_alloc((Class)NSSet);
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "NF_userInfo"));
  v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "objectForKeyedSubscript:", CFSTR("ProxyObjects")));
  v6 = objc_msgSend(v3, "initWithSet:", v5);

  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  obj = v6;
  v7 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v34, v50, 16);
  if (v7)
  {
    v33 = *(_QWORD *)v35;
    do
    {
      for (i = 0; i != v7; i = (char *)i + 1)
      {
        if (*(_QWORD *)v35 != v33)
          objc_enumerationMutation(obj);
        v9 = *(void **)(*((_QWORD *)&v34 + 1) + 8 * (_QWORD)i);
        v10 = objc_opt_class(_NFXPCSession);
        if ((objc_opt_isKindOfClass(v9, v10) & 1) != 0)
        {
          v11 = v9;
          if ((objc_opt_respondsToSelector(v11, "handleInvalidatedXPCWithConnectionUserInfo:") & 1) != 0)
          {
            v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "NF_userInfo"));
            objc_msgSend(v11, "handleInvalidatedXPCWithConnectionUserInfo:", v12);

          }
          specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(specific);
          if (Logger)
          {
            Class = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(Class))
              v16 = 43;
            else
              v16 = 45;
            ClassName = object_getClassName(*(id *)(a1 + 32));
            Name = sel_getName(*(SEL *)(a1 + 48));
            v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "NF_userInfo"));
            v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v19, "objectForKeyedSubscript:", CFSTR("ClientName")));
            Logger(6, "%c[%{public}s %{public}s]:%i dequeueing session:%{public}@ for %{public}@", v16, ClassName, Name, 1543, v11, v20);

          }
          v21 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v22 = NFSharedLogGetLogger(v21);
          v23 = objc_claimAutoreleasedReturnValue(v22);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
          {
            v24 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v24))
              v25 = 43;
            else
              v25 = 45;
            v26 = object_getClassName(*(id *)(a1 + 32));
            v27 = sel_getName(*(SEL *)(a1 + 48));
            v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "NF_userInfo"));
            v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "objectForKeyedSubscript:", CFSTR("ClientName")));
            *(_DWORD *)buf = 67110402;
            v39 = v25;
            v40 = 2082;
            v41 = v26;
            v42 = 2082;
            v43 = v27;
            v44 = 1024;
            v45 = 1543;
            v46 = 2114;
            v47 = v11;
            v48 = 2114;
            v49 = v29;
            _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i dequeueing session:%{public}@ for %{public}@", buf, 0x36u);

          }
          sub_1000E5BAC(*(id **)(a1 + 32), v11, 0);

        }
      }
      v7 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v34, v50, 16);
    }
    while (v7);
  }

  objc_sync_exit(v31);
  sub_10016F980(*(void **)(a1 + 32), *(void **)(a1 + 40));
  return objc_msgSend(*(id *)(a1 + 32), "maybeStartNextSession");
}

void sub_1000E579C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id obj)
{
  objc_sync_exit(obj);
  _Unwind_Resume(a1);
}

void sub_1000E57E0(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  void *specific;
  uint64_t Logger;
  void (*v8)(uint64_t, const char *, ...);
  objc_class *Class;
  uint64_t v10;
  const char *ClassName;
  const char *Name;
  id v13;
  void *v14;
  void *v15;
  uint64_t v16;
  NSObject *v17;
  objc_class *v18;
  int v19;
  const char *v20;
  const char *v21;
  unsigned int v22;
  void *v23;
  void *v24;
  id v25;
  void *v26;
  void (*v27)(uint64_t, const char *, ...);
  objc_class *v28;
  uint64_t v29;
  const char *v30;
  const char *v31;
  void *v32;
  uint64_t v33;
  NSObject *v34;
  objc_class *v35;
  int v36;
  const char *v37;
  const char *v38;
  void *v39;
  uint8_t buf[4];
  int v41;
  __int16 v42;
  const char *v43;
  __int16 v44;
  const char *v45;
  __int16 v46;
  int v47;
  __int16 v48;
  unsigned int v49;
  __int16 v50;
  void *v51;

  v3 = a2;
  v4 = v3;
  if (a1)
  {
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "NF_whitelistChecker"));
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v8 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass((id)a1);
      if (class_isMetaClass(Class))
        v10 = 43;
      else
        v10 = 45;
      ClassName = object_getClassName((id)a1);
      Name = sel_getName("_sync_unregisterForCallbacks:");
      v13 = objc_msgSend(v4, "processIdentifier");
      v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "clientName"));
      v8(6, "%c[%{public}s %{public}s]:%i Client %d (%{public}@) unregistered callback", v10, ClassName, Name, 3177, v13, v14);

    }
    v15 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v16 = NFSharedLogGetLogger(v15);
    v17 = objc_claimAutoreleasedReturnValue(v16);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      v18 = object_getClass((id)a1);
      if (class_isMetaClass(v18))
        v19 = 43;
      else
        v19 = 45;
      v20 = object_getClassName((id)a1);
      v21 = sel_getName("_sync_unregisterForCallbacks:");
      v22 = objc_msgSend(v4, "processIdentifier");
      v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "clientName"));
      *(_DWORD *)buf = 67110402;
      v41 = v19;
      v42 = 2082;
      v43 = v20;
      v44 = 2082;
      v45 = v21;
      v46 = 1024;
      v47 = 3177;
      v48 = 1024;
      v49 = v22;
      v50 = 2114;
      v51 = v23;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Client %d (%{public}@) unregistered callback", buf, 0x32u);

    }
    v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", (int)objc_msgSend(v4, "processIdentifier")));
    v25 = *(id *)(a1 + 160);
    objc_sync_enter(v25);
    objc_msgSend(*(id *)(a1 + 160), "removeObjectForKey:", v24);
    if (!objc_msgSend(*(id *)(a1 + 160), "count") && *(_QWORD *)(a1 + 272))
    {
      v26 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v27 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v26);
      if (v27)
      {
        v28 = object_getClass((id)a1);
        if (class_isMetaClass(v28))
          v29 = 43;
        else
          v29 = 45;
        v30 = object_getClassName((id)a1);
        v31 = sel_getName("_sync_unregisterForCallbacks:");
        v27(6, "%c[%{public}s %{public}s]:%i releasing NFCD keep alive transaction", v29, v30, v31, 3185);
      }
      v32 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v33 = NFSharedLogGetLogger(v32);
      v34 = objc_claimAutoreleasedReturnValue(v33);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        v35 = object_getClass((id)a1);
        if (class_isMetaClass(v35))
          v36 = 43;
        else
          v36 = 45;
        v37 = object_getClassName((id)a1);
        v38 = sel_getName("_sync_unregisterForCallbacks:");
        *(_DWORD *)buf = 67109890;
        v41 = v36;
        v42 = 2082;
        v43 = v37;
        v44 = 2082;
        v45 = v38;
        v46 = 1024;
        v47 = 3185;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i releasing NFCD keep alive transaction", buf, 0x22u);
      }

      v39 = *(void **)(a1 + 272);
      *(_QWORD *)(a1 + 272) = 0;

    }
    objc_sync_exit(v25);

  }
}

void sub_1000E5B84(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000E5BAC(id *a1, void *a2, unsigned int a3)
{
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  void *v7;
  id v8;
  id *v9;
  BOOL v10;
  id v11;
  uint64_t v12;
  id v13;
  int v14;
  BOOL v15;
  int v16;
  void *specific;
  void (*Logger)(uint64_t, const char *, ...);
  objc_class *Class;
  uint64_t v20;
  const char *ClassName;
  const char *Name;
  void *v23;
  void *v24;
  uint64_t v25;
  NSObject *v26;
  objc_class *v27;
  int v28;
  const char *v29;
  const char *v30;
  void *v31;
  void *v32;
  void *v33;
  void (*v34)(uint64_t, const char *, ...);
  objc_class *v35;
  uint64_t v36;
  const char *v37;
  const char *v38;
  void *v39;
  uint64_t v40;
  NSObject *v41;
  objc_class *v42;
  int v43;
  const char *v44;
  const char *v45;
  dispatch_time_t v46;
  NSObject *v47;
  id v48;
  id v49;
  NSObject *v50;
  void *v51;
  void *v52;
  id v53;
  unsigned int v54;
  id v55;
  uint64_t v56;
  id v57;
  void *v58;
  void *v59;
  id v60;
  _QWORD *v61;
  _BOOL4 v62;
  id v63;
  void *v64;
  void *v65;
  void *v66;
  id v67;
  id v68;
  unsigned int v69;
  id v70;
  unsigned int v71;
  double v72;
  id v73;
  uint64_t v74;
  uint64_t v75;
  id v76;
  id v77;
  uint64_t v78;
  id v79;
  uint64_t v80;
  int v81;
  uint64_t v82;
  int v83;
  uint64_t v84;
  uint64_t v85;
  int v86;
  uint64_t v87;
  void *v88;
  _BOOL4 v89;
  id v90;
  double v91;
  id v92;
  void *v93;
  float v94;
  void *v95;
  void (*v96)(uint64_t, const char *, ...);
  objc_class *v97;
  uint64_t v98;
  const char *v99;
  void *v100;
  uint64_t v101;
  NSObject *v102;
  objc_class *v103;
  int v104;
  const char *v105;
  const char *v106;
  void *v107;
  void (*v108)(uint64_t, const char *, ...);
  objc_class *v109;
  uint64_t v110;
  const char *v111;
  const char *v112;
  void *v113;
  uint64_t v114;
  NSObject *v115;
  objc_class *v116;
  int v117;
  const char *v118;
  const char *v119;
  dispatch_time_t v120;
  NSObject *v121;
  _BYTE *v122;
  id v123;
  void *v124;
  void *v125;
  void *v126;
  id v127;
  id v128;
  void *v129;
  void (*v130)(uint64_t, const char *, ...);
  objc_class *v131;
  uint64_t v132;
  const char *v133;
  const char *v134;
  void *v135;
  uint64_t v136;
  NSObject *v137;
  objc_class *v138;
  int v139;
  const char *v140;
  const char *v141;
  int v142;
  int v143;
  void *v144;
  unsigned int v145;
  _QWORD *v146;
  void *v147;
  void (*v148)(uint64_t, const char *, ...);
  objc_class *v149;
  uint64_t v150;
  const char *v151;
  const char *v152;
  void *v153;
  uint64_t v154;
  objc_class *v155;
  int v156;
  const char *v157;
  const char *v158;
  id v159;
  id v160;
  unsigned int v161;
  void *v162;
  void (*v163)(uint64_t, const char *, ...);
  objc_class *v164;
  uint64_t v165;
  const char *v166;
  const char *v167;
  void *v168;
  uint64_t v169;
  NSObject *v170;
  objc_class *v171;
  int v172;
  const char *v173;
  const char *v174;
  int v175;
  id v176;
  id v177;
  int v178;
  void *v179;
  unsigned int v180;
  void *v181;
  uint64_t v182;
  void (*v183)(uint64_t, const char *, ...);
  objc_class *v184;
  uint64_t v185;
  const char *v186;
  const char *v187;
  void *v188;
  uint64_t v189;
  NSObject *v190;
  objc_class *v191;
  int v192;
  const char *v193;
  const char *v194;
  objc_class *v195;
  uint64_t v196;
  const char *v197;
  const char *v198;
  void *v199;
  uint64_t v200;
  NSObject *v201;
  objc_class *v202;
  int v203;
  const char *v204;
  const char *v205;
  id v206;
  void *v207;
  char v208;
  unsigned int v209;
  id v210;
  uint64_t v211;
  _BYTE *v212;
  uint64_t v213;
  NSObject *v214;
  const char *v215;
  char isKindOfClass;
  unsigned int v217;
  void *v218;
  _BOOL4 v219;
  id v221;
  NSErrorUserInfoKey v222;
  void *v223;
  NSErrorUserInfoKey v224;
  void *v225;
  NSErrorUserInfoKey v226;
  void *v227;
  _BYTE buf[58];
  NSErrorUserInfoKey v229;
  void *v230;

  v221 = a2;
  if (a1)
  {
    v4 = kdebug_trace(724566056, 0, 0, 0, 0);
    v5 = NFSharedSignpostLog(v4);
    v6 = objc_claimAutoreleasedReturnValue(v5);
    if (os_signpost_enabled(v6))
    {
      v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v221, "sessionUID"));
      *(_DWORD *)buf = 138412290;
      *(_QWORD *)&buf[4] = v7;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v6, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SESSION_ENDED", "sessionUID=%@", buf, 0xCu);

    }
    v8 = a1[23];
    objc_sync_enter(v8);
    v9 = a1;
    objc_sync_enter(v9);
    v10 = *((_BYTE *)v9 + 337) == 0;
    objc_sync_exit(v9);

    if (v10)
      goto LABEL_144;
    v11 = v221;
    v12 = objc_opt_class(_NFReaderSession);
    if ((objc_opt_isKindOfClass(v11, v12) & 1) != 0)
    {
      v13 = v11;
      if (objc_msgSend(v13, "timeLimitedSession"))
      {
        v14 = *((_DWORD *)v9 + 80);
        v15 = __OFSUB__(v14, 1);
        v16 = v14 - 1;
        if (v16 < 0 == v15)
          *((_DWORD *)v9 + 80) = v16;
      }
      if (v9[14] == v13 && objc_msgSend(v13, "didStart") && objc_msgSend(v13, "uiShown"))
      {
        if (objc_msgSend(v13, "uiActivated"))
        {
          specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(specific);
          if (Logger)
          {
            Class = object_getClass(v9);
            if (class_isMetaClass(Class))
              v20 = 43;
            else
              v20 = 45;
            ClassName = object_getClassName(v9);
            Name = sel_getName("_dequeueHelperReaderSession:");
            v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "sessionUID"));
            Logger(6, "%c[%{public}s %{public}s]:%i Suspend until UI invalidation handler executes for session %@", v20, ClassName, Name, 2122, v23);

          }
          v24 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v25 = NFSharedLogGetLogger(v24);
          v26 = objc_claimAutoreleasedReturnValue(v25);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            v27 = object_getClass(v9);
            if (class_isMetaClass(v27))
              v28 = 43;
            else
              v28 = 45;
            v29 = object_getClassName(v9);
            v30 = sel_getName("_dequeueHelperReaderSession:");
            v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "sessionUID"));
            *(_DWORD *)buf = 67110146;
            *(_DWORD *)&buf[4] = v28;
            *(_WORD *)&buf[8] = 2082;
            *(_QWORD *)&buf[10] = v29;
            *(_WORD *)&buf[18] = 2082;
            *(_QWORD *)&buf[20] = v30;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = 2122;
            *(_WORD *)&buf[34] = 2112;
            *(_QWORD *)&buf[36] = v31;
            _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Suspend until UI invalidation handler executes for session %@", buf, 0x2Cu);

          }
          v9[38] = (char *)v9[38] + 1;
          objc_msgSend(v9[51], "suspend");
        }
        else
        {
          v9[38] = (char *)v9[38] + 1;
          objc_msgSend(v9[51], "suspend");
          v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "sessionUID"));
          v33 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v34 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v33);
          if (v34)
          {
            v35 = object_getClass(v9);
            if (class_isMetaClass(v35))
              v36 = 43;
            else
              v36 = 45;
            v37 = object_getClassName(v9);
            v38 = sel_getName("_dequeueHelperReaderSession:");
            v34(6, "%c[%{public}s %{public}s]:%i Suspend reader activity for %fs (session %@)", v36, v37, v38, 2128, 0x3FF8000000000000, v32);
          }
          v39 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v40 = NFSharedLogGetLogger(v39);
          v41 = objc_claimAutoreleasedReturnValue(v40);
          if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
          {
            v42 = object_getClass(v9);
            if (class_isMetaClass(v42))
              v43 = 43;
            else
              v43 = 45;
            v44 = object_getClassName(v9);
            v45 = sel_getName("_dequeueHelperReaderSession:");
            *(_DWORD *)buf = 67110402;
            *(_DWORD *)&buf[4] = v43;
            *(_WORD *)&buf[8] = 2082;
            *(_QWORD *)&buf[10] = v44;
            *(_WORD *)&buf[18] = 2082;
            *(_QWORD *)&buf[20] = v45;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = 2128;
            *(_WORD *)&buf[34] = 2048;
            *(_QWORD *)&buf[36] = 0x3FF8000000000000;
            *(_WORD *)&buf[44] = 2112;
            *(_QWORD *)&buf[46] = v32;
            _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Suspend reader activity for %fs (session %@)", buf, 0x36u);
          }

          v46 = dispatch_time(0, 1500000000);
          v47 = v9[29];
          *(_QWORD *)buf = _NSConcreteStackBlock;
          *(_QWORD *)&buf[8] = 3221225472;
          *(_QWORD *)&buf[16] = sub_1000EB710;
          *(_QWORD *)&buf[24] = &unk_1002E5C80;
          *(_QWORD *)&buf[40] = v32;
          *(_QWORD *)&buf[48] = "_dequeueHelperReaderSession:";
          *(_QWORD *)&buf[32] = v9;
          v48 = v32;
          dispatch_after(v46, v47, buf);

        }
      }

    }
    if (v9[14] != v11)
    {
      if (objc_msgSend(a1[23], "containsObject:", v11))
      {
        objc_msgSend(a1[23], "removeObject:", v11);
        v49 = objc_alloc((Class)NSError);
        v50 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v226 = NSLocalizedDescriptionKey;
        v51 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Aborted"));
        v227 = v51;
        v52 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v227, &v226, 1));
        v53 = objc_msgSend(v49, "initWithDomain:code:userInfo:", v50, 3, v52);
        objc_msgSend(v11, "didEndSession:", v53);

      }
      else if (objc_msgSend(v9[24], "containsObject:", v11))
      {
        objc_msgSend(v9[24], "removeObject:", v11);
        v57 = objc_alloc((Class)NSError);
        v50 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v224 = NSLocalizedDescriptionKey;
        v58 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Aborted"));
        v225 = v58;
        v59 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v225, &v224, 1));
        v60 = objc_msgSend(v57, "initWithDomain:code:userInfo:", v50, 3, v59);
        objc_msgSend(v11, "didEndSession:", v60);

      }
      else if (objc_msgSend(v11, "isFeatureSupported:", 4))
      {
        v63 = objc_alloc((Class)NSError);
        v64 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v222 = NSLocalizedDescriptionKey;
        v65 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Aborted"));
        v223 = v65;
        v66 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v223, &v222, 1));
        v67 = objc_msgSend(v63, "initWithDomain:code:userInfo:", v64, 3, v66);
        objc_msgSend(v11, "didEndSession:", v67);

        v50 = v11;
        v68 = v9[2];
        v69 = objc_msgSend(v68, "containsFieldDetectSession:", v50);

        v70 = v9[2];
        objc_msgSend(v70, "removeFieldDetectSession:", v50);

        if (v9[14])
          v71 = 0;
        else
          v71 = v69;
        if (v71 == 1)
          objc_msgSend(v9, "maybeStartNextSession");
      }
      else
      {
        v147 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v148 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v147);
        if (v148)
        {
          v149 = object_getClass(v9);
          if (class_isMetaClass(v149))
            v150 = 43;
          else
            v150 = 45;
          v151 = object_getClassName(v9);
          v152 = sel_getName("_dequeueSession:startNextSession:");
          v148(4, "%c[%{public}s %{public}s]:%i Session is not active or queued", v150, v151, v152, 2362);
        }
        v153 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v154 = NFSharedLogGetLogger(v153);
        v50 = objc_claimAutoreleasedReturnValue(v154);
        if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
        {
          v155 = object_getClass(v9);
          if (class_isMetaClass(v155))
            v156 = 43;
          else
            v156 = 45;
          v157 = object_getClassName(v9);
          v158 = sel_getName("_dequeueSession:startNextSession:");
          *(_DWORD *)buf = 67109890;
          *(_DWORD *)&buf[4] = v156;
          *(_WORD *)&buf[8] = 2082;
          *(_QWORD *)&buf[10] = v157;
          *(_WORD *)&buf[18] = 2082;
          *(_QWORD *)&buf[20] = v158;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = 2362;
          _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session is not active or queued", buf, 0x22u);
        }
      }

LABEL_127:
      objc_msgSend(v11, "releaseObjects");
      if (!v9[14] && !objc_msgSend(a1[23], "count"))
        sub_1000DBE28(v9, 0);
      sub_1001C8AA0((uint64_t)v9);
      v159 = v9[51];
      objc_msgSend(v159, "releaseECPOption:", objc_msgSend(v11, "backgroundTagReadEcpOption"));

      if (objc_msgSend(v11, "backgroundTagReadEcpOption") == (id)1 && !v9[14])
      {
        v160 = v9[51];
        v161 = objc_msgSend(v160, "isActive");

        if (v161)
        {
          v162 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v163 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v162);
          if (v163)
          {
            v164 = object_getClass(v9);
            if (class_isMetaClass(v164))
              v165 = 43;
            else
              v165 = 45;
            v166 = object_getClassName(v9);
            v167 = sel_getName("_dequeueSession:startNextSession:");
            v163(6, "%c[%{public}s %{public}s]:%i Refresh background tag reading to update VAS", v165, v166, v167, 2379);
          }
          v168 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v169 = NFSharedLogGetLogger(v168);
          v170 = objc_claimAutoreleasedReturnValue(v169);
          if (os_log_type_enabled(v170, OS_LOG_TYPE_DEFAULT))
          {
            v171 = object_getClass(v9);
            if (class_isMetaClass(v171))
              v172 = 43;
            else
              v172 = 45;
            v173 = object_getClassName(v9);
            v174 = sel_getName("_dequeueSession:startNextSession:");
            *(_DWORD *)buf = 67109890;
            *(_DWORD *)&buf[4] = v172;
            *(_WORD *)&buf[8] = 2082;
            *(_QWORD *)&buf[10] = v173;
            *(_WORD *)&buf[18] = 2082;
            *(_QWORD *)&buf[20] = v174;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = 2379;
            _os_log_impl((void *)&_mh_execute_header, v170, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Refresh background tag reading to update VAS", buf, 0x22u);
          }

          objc_msgSend(v9, "maybeStartNextSession");
        }
      }
LABEL_144:
      objc_sync_exit(v8);

      goto LABEL_145;
    }
    v54 = objc_msgSend(v11, "conformsToProtocol:", &OBJC_PROTOCOL___NFContactlessPaymentSessionInterface);
    v55 = v9[14];
    v56 = objc_opt_class(_NFContactlessSession);
    isKindOfClass = objc_opt_isKindOfClass(v55, v56);
    v217 = v54;
    if ((unint64_t)objc_msgSend(a1[23], "count") <= 1 && (v61 = v9[3]) != 0)
    {
      v62 = v61[17] == 1 || *((unsigned __int8 *)v61 + 170) != 0;
      v219 = v62;
    }
    else
    {
      v219 = 0;
    }
    v72 = sub_1000DB680((uint64_t)v9);
    sub_1000DFFD0(v9, v72);
    v73 = v11;
    v74 = objc_opt_class(_NFLoyaltyAndPaymentSession);
    if ((objc_opt_isKindOfClass(v73, v74) & 1) != 0 && v9[14] == v73)
    {
      v75 = objc_claimAutoreleasedReturnValue(objc_msgSend(v73, "hostCardEmulationLog"));
      v76 = v9[25];
      v9[25] = (id)v75;

    }
    v77 = v73;
    v78 = objc_opt_class(_NFSecureElementManagerSession);
    if ((objc_opt_isKindOfClass(v77, v78) & 1) != 0)
      *((_BYTE *)v9 + 345) = 0;

    v79 = v77;
    v218 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v79, "sessionUID"));
    v80 = objc_opt_class(_NFSecureElementReaderSession);
    v81 = objc_opt_isKindOfClass(v79, v80);
    v82 = objc_opt_class(_NFSecureTransactionServicesHandoverSession);
    if ((objc_opt_isKindOfClass(v79, v82) & 1) != 0)
    {
      v83 = 1;
    }
    else
    {
      v84 = objc_opt_class(_NFSecureTransactionServicesHandoverHybridSession);
      v83 = objc_opt_isKindOfClass(v79, v84);
    }
    v85 = objc_opt_class(_NFLoyaltyAndPaymentSession);
    v86 = objc_opt_isKindOfClass(v79, v85);
    v87 = objc_opt_class(_NFHCESession);
    if ((objc_opt_isKindOfClass(v79, v87) & 1) != 0)
    {
      v88 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v79, "suspendOnFieldList"));
      v89 = objc_msgSend(v88, "count") != 0;

    }
    else
    {
      v89 = 0;
    }
    if (((v81 | v83 | v86) & 1) != 0 || v89)
    {
      v9[38] = (char *)v9[38] + 1;
      v90 = objc_msgSend(v9[51], "suspend");
      if (v89)
        v91 = 1.0;
      else
        v91 = 4.0;
      if (NFIsInternalBuild(v90))
      {
        v92 = objc_msgSend(objc_alloc((Class)NSUserDefaults), "initWithSuiteName:", CFSTR("com.apple.stockholm"));
        v93 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v92, "objectForKey:", CFSTR("seReaderSessionToBGTagReaderDelay")));

        if (v93)
        {
          objc_msgSend(v92, "floatForKey:", CFSTR("seReaderSessionToBGTagReaderDelay"));
          v91 = v94;
          if (v94 > 10.0)
          {
            v95 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v96 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v95);
            if (v96)
            {
              v97 = object_getClass(v9);
              if (class_isMetaClass(v97))
                v98 = 43;
              else
                v98 = 45;
              v215 = object_getClassName(v9);
              v99 = sel_getName("_dequeueHelperSessionAffectingBackgroundTagReading:");
              v96(4, "%c[%{public}s %{public}s]:%i seReaderSessionToBGTagReaderDelay (%fs) is too large - using %fs instead", v98, v215, v99, 2254, *(_QWORD *)&v91, 0x4024000000000000);
            }
            v100 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v101 = NFSharedLogGetLogger(v100);
            v102 = objc_claimAutoreleasedReturnValue(v101);
            if (os_log_type_enabled(v102, OS_LOG_TYPE_ERROR))
            {
              v103 = object_getClass(v9);
              if (class_isMetaClass(v103))
                v104 = 43;
              else
                v104 = 45;
              v105 = object_getClassName(v9);
              v106 = sel_getName("_dequeueHelperSessionAffectingBackgroundTagReading:");
              *(_DWORD *)buf = 67110402;
              *(_DWORD *)&buf[4] = v104;
              *(_WORD *)&buf[8] = 2082;
              *(_QWORD *)&buf[10] = v105;
              *(_WORD *)&buf[18] = 2082;
              *(_QWORD *)&buf[20] = v106;
              *(_WORD *)&buf[28] = 1024;
              *(_DWORD *)&buf[30] = 2254;
              *(_WORD *)&buf[34] = 2048;
              *(double *)&buf[36] = v91;
              *(_WORD *)&buf[44] = 2048;
              *(_QWORD *)&buf[46] = 0x4024000000000000;
              _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i seReaderSessionToBGTagReaderDelay (%fs) is too large - using %fs instead", buf, 0x36u);
            }

            v91 = 10.0;
          }
        }

      }
      v107 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v108 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v107);
      if (v108)
      {
        v109 = object_getClass(v9);
        if (class_isMetaClass(v109))
          v110 = 43;
        else
          v110 = 45;
        v111 = object_getClassName(v9);
        v112 = sel_getName("_dequeueHelperSessionAffectingBackgroundTagReading:");
        v108(6, "%c[%{public}s %{public}s]:%i Suspend reader activity for %fs (session %@)", v110, v111, v112, 2260, *(_QWORD *)&v91, v218);
      }
      v113 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v114 = NFSharedLogGetLogger(v113);
      v115 = objc_claimAutoreleasedReturnValue(v114);
      if (os_log_type_enabled(v115, OS_LOG_TYPE_DEFAULT))
      {
        v116 = object_getClass(v9);
        if (class_isMetaClass(v116))
          v117 = 43;
        else
          v117 = 45;
        v118 = object_getClassName(v9);
        v119 = sel_getName("_dequeueHelperSessionAffectingBackgroundTagReading:");
        *(_DWORD *)buf = 67110402;
        *(_DWORD *)&buf[4] = v117;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = v118;
        *(_WORD *)&buf[18] = 2082;
        *(_QWORD *)&buf[20] = v119;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 2260;
        *(_WORD *)&buf[34] = 2048;
        *(double *)&buf[36] = v91;
        *(_WORD *)&buf[44] = 2112;
        *(_QWORD *)&buf[46] = v218;
        _os_log_impl((void *)&_mh_execute_header, v115, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Suspend reader activity for %fs (session %@)", buf, 0x36u);
      }

      v120 = dispatch_time(0, (uint64_t)(v91 * 1000000000.0));
      v121 = v9[29];
      *(_QWORD *)buf = _NSConcreteStackBlock;
      *(_QWORD *)&buf[8] = 3221225472;
      *(_QWORD *)&buf[16] = sub_1000EB8A8;
      *(_QWORD *)&buf[24] = &unk_1002E5C80;
      *(_QWORD *)&buf[32] = v9;
      *(_QWORD *)&buf[48] = "_dequeueHelperSessionAffectingBackgroundTagReading:";
      *(_QWORD *)&buf[40] = v218;
      dispatch_after(v120, v121, buf);

    }
    v122 = v9[46];
    if (v122)
      v122[221] = 0;
    v123 = objc_alloc((Class)NSError);
    v124 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v229 = NSLocalizedDescriptionKey;
    v125 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Aborted"));
    v230 = v125;
    v126 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v230, &v229, 1));
    v127 = objc_msgSend(v123, "initWithDomain:code:userInfo:", v124, 3, v126);
    objc_msgSend(v79, "didEndSession:", v127);

    v128 = v9[14];
    v9[14] = 0;

    sub_1001D4F84(v9);
    v129 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v130 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v129);
    if (v130)
    {
      v131 = object_getClass(v9);
      if (class_isMetaClass(v131))
        v132 = 43;
      else
        v132 = 45;
      v133 = object_getClassName(v9);
      v134 = sel_getName("_dequeueSession:startNextSession:");
      v130(6, "%c[%{public}s %{public}s]:%i startNextSession=%d,_systemWillSleep=%d,_powerCycleAfterThisSession=%d,nextIsExpress=%d", v132, v133, v134, 2307, a3, *((unsigned __int8 *)v9 + 344), *((unsigned __int8 *)v9 + 348), v219);
    }
    v135 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v136 = NFSharedLogGetLogger(v135);
    v137 = objc_claimAutoreleasedReturnValue(v136);
    if (os_log_type_enabled(v137, OS_LOG_TYPE_DEFAULT))
    {
      v138 = object_getClass(v9);
      if (class_isMetaClass(v138))
        v139 = 43;
      else
        v139 = 45;
      v140 = object_getClassName(v9);
      v141 = sel_getName("_dequeueSession:startNextSession:");
      v142 = *((unsigned __int8 *)v9 + 344);
      v143 = *((unsigned __int8 *)v9 + 348);
      *(_DWORD *)buf = 67110914;
      *(_DWORD *)&buf[4] = v139;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = v140;
      *(_WORD *)&buf[18] = 2082;
      *(_QWORD *)&buf[20] = v141;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 2307;
      *(_WORD *)&buf[34] = 1024;
      *(_DWORD *)&buf[36] = a3;
      *(_WORD *)&buf[40] = 1024;
      *(_DWORD *)&buf[42] = v142;
      *(_WORD *)&buf[46] = 1024;
      *(_DWORD *)&buf[48] = v143;
      *(_WORD *)&buf[52] = 1024;
      *(_DWORD *)&buf[54] = v219;
      _os_log_impl((void *)&_mh_execute_header, v137, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i startNextSession=%d,_systemWillSleep=%d,_powerCycleAfterThisSession=%d,nextIsExpress=%d", buf, 0x3Au);
    }

    if (objc_msgSend(a1[23], "count"))
    {
      if (a3)
      {
        v144 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[23], "objectAtIndex:", 0));
        v145 = objc_msgSend(v144, "conformsToProtocol:", &OBJC_PROTOCOL___NFContactlessPaymentSessionInterface);

      }
      else
      {
        v145 = 0;
      }
      LODWORD(v146) = 1;
    }
    else
    {
      v146 = v9[3];
      if (v146)
      {
        if (v146[17] == 1)
        {
          LODWORD(v146) = 1;
          v145 = 1;
        }
        else
        {
          LODWORD(v146) = *((unsigned __int8 *)v146 + 170) != 0;
          v145 = v146;
        }
      }
      else
      {
        v145 = 0;
      }
    }
    if (*((_BYTE *)v9 + 348))
      v175 = (int)v146;
    else
      v175 = 0;
    v176 = objc_msgSend(v9[48], "siliconName");
    v177 = objc_msgSend(v9[48], "siliconName");
    v178 = v217 & v145 ^ 1;
    if ((unint64_t)v176 >= 7)
      v178 = 0;
    if ((unint64_t)v177 <= 0xD && v175 | v178)
    {
      *((_BYTE *)v9 + 348) = 0;
      v179 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"));
      v180 = objc_msgSend(v179, "BOOLForKey:", CFSTR("DontPowerCycle"));

      v181 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v182 = NFLogGetLogger(v181);
      v183 = (void (*)(uint64_t, const char *, ...))v182;
      if (v180)
      {
        if (v182)
        {
          v184 = object_getClass(v9);
          if (class_isMetaClass(v184))
            v185 = 43;
          else
            v185 = 45;
          v186 = object_getClassName(v9);
          v187 = sel_getName("_dequeueHelperPowerCycle:startNextSession:");
          v183(4, "%c[%{public}s %{public}s]:%i Defaults override of power cycling SE", v185, v186, v187, 2190);
        }
        v188 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v189 = NFSharedLogGetLogger(v188);
        v190 = objc_claimAutoreleasedReturnValue(v189);
        if (os_log_type_enabled(v190, OS_LOG_TYPE_ERROR))
        {
          v191 = object_getClass(v9);
          if (class_isMetaClass(v191))
            v192 = 43;
          else
            v192 = 45;
          v193 = object_getClassName(v9);
          v194 = sel_getName("_dequeueHelperPowerCycle:startNextSession:");
          *(_DWORD *)buf = 67109890;
          *(_DWORD *)&buf[4] = v192;
          *(_WORD *)&buf[8] = 2082;
          *(_QWORD *)&buf[10] = v193;
          *(_WORD *)&buf[18] = 2082;
          *(_QWORD *)&buf[20] = v194;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = 2190;
          _os_log_impl((void *)&_mh_execute_header, v190, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Defaults override of power cycling SE", buf, 0x22u);
        }

      }
      else
      {
        if (v182)
        {
          v195 = object_getClass(v9);
          if (class_isMetaClass(v195))
            v196 = 43;
          else
            v196 = 45;
          v197 = object_getClassName(v9);
          v198 = sel_getName("_dequeueHelperPowerCycle:startNextSession:");
          v183(6, "%c[%{public}s %{public}s]:%i Restarting eSE", v196, v197, v198, 2192);
        }
        v199 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v200 = NFSharedLogGetLogger(v199);
        v201 = objc_claimAutoreleasedReturnValue(v200);
        if (os_log_type_enabled(v201, OS_LOG_TYPE_DEFAULT))
        {
          v202 = object_getClass(v9);
          if (class_isMetaClass(v202))
            v203 = 43;
          else
            v203 = 45;
          v204 = object_getClassName(v9);
          v205 = sel_getName("_dequeueHelperPowerCycle:startNextSession:");
          *(_DWORD *)buf = 67109890;
          *(_DWORD *)&buf[4] = v203;
          *(_WORD *)&buf[8] = 2082;
          *(_QWORD *)&buf[10] = v204;
          *(_WORD *)&buf[18] = 2082;
          *(_QWORD *)&buf[20] = v205;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = 2192;
          _os_log_impl((void *)&_mh_execute_header, v201, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Restarting eSE", buf, 0x22u);
        }

        v206 = objc_msgSend(v9, "powerCycleSE:", v9[47]);
      }
    }
    sub_1000487B0((uint64_t)v9[3], 0);
    if (v219)
    {
      sub_10003D1FC((uint64_t)v9[3]);
    }
    else if ((isKindOfClass & 1) == 0)
    {
      sub_100043B7C((uint64_t)v9[3]);
    }
    v207 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v79, "parentToken"));

    if (v207)
    {
      if (sub_1001C9CFC(v9, v79) && (a3 & 1) == 0)
        goto LABEL_184;
    }
    else if (!a3)
    {
LABEL_184:
      v208 = 0;
      goto LABEL_188;
    }
    if (!*((_BYTE *)v9 + 344))
    {
      objc_msgSend(v9, "maybeStartNextSession");
      v208 = 1;
      goto LABEL_189;
    }
    v208 = 1;
LABEL_188:
    sub_1001D4314((uint64_t)v9);
LABEL_189:
    v209 = sub_100098AF4((uint64_t)v9);
    v210 = sub_1000984B4(v9, v209);
    if ((v208 & 1) == 0)
      sub_1000EA9A0(v9, 0);
    sub_1001FABB8(v9[46], CFSTR("Session"));
    if (*((_BYTE *)v9 + 344))
    {
      v212 = v9[3];
      if (!v212 || !v212[172])
      {
        v213 = NFSharedSignpostLog(v211);
        v214 = objc_claimAutoreleasedReturnValue(v213);
        if (os_signpost_enabled(v214))
        {
          *(_WORD *)buf = 0;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v214, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "_dequeueSession: allowing to sleep", "", buf, 2u);
        }

        objc_msgSend(v9[7], "allowSleep");
      }
    }
    goto LABEL_127;
  }
LABEL_145:

}

void sub_1000E7260(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000E77B0(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  void *v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  objc_class *v15;
  int v16;
  const char *v17;
  const char *v18;
  void *v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint8_t buf[4];
  int v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  void *v33;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "NF_userInfo"));
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("ClientName")));
    v11 = 45;
    if (isMetaClass)
      v11 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i Processing %{public}@", v11, ClassName, Name, 1609, v10);

  }
  v12 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v13 = NFSharedLogGetLogger(v12);
  v14 = objc_claimAutoreleasedReturnValue(v13);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    v15 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v15))
      v16 = 43;
    else
      v16 = 45;
    v17 = object_getClassName(*(id *)(a1 + 32));
    v18 = sel_getName(*(SEL *)(a1 + 56));
    v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "NF_userInfo"));
    v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v19, "objectForKeyedSubscript:", CFSTR("ClientName")));
    *(_DWORD *)buf = 67110146;
    v25 = v16;
    v26 = 2082;
    v27 = v17;
    v28 = 2082;
    v29 = v18;
    v30 = 1024;
    v31 = 1609;
    v32 = 2114;
    v33 = v20;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Processing %{public}@", buf, 0x2Cu);

  }
  v21 = *(_QWORD *)(a1 + 48);
  v22 = -[_NFHardwareManager getPrimaryHardwareState]_0(*(_QWORD *)(a1 + 32));
  return (*(uint64_t (**)(uint64_t, uint64_t))(v21 + 16))(v21, v22);
}

void sub_1000E7A18(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000E7A2C(uint64_t a1)
{
  uint64_t v1;
  id v2;

  v1 = a1;
  if (a1)
  {
    v2 = *(id *)(a1 + 184);
    objc_sync_enter(v2);
    v1 = *(_QWORD *)(v1 + 112) != 0;
    objc_sync_exit(v2);

  }
  return v1;
}

void sub_1000E7A78(uint64_t a1)
{
  id *v2;
  id v3;
  id v4;
  id v5;
  char v6;

  if (a1)
  {
    v6 = 0;
    v2 = *(id **)(a1 + 368);
    v5 = 0;
    sub_1001FFC44(v2, &v6, &v5);
    v3 = v5;
    if (v6)
    {
      if ((objc_opt_respondsToSelector(*(_QWORD *)(a1 + 112), "handleFieldChanged:") & 1) != 0)
        objc_msgSend(*(id *)(a1 + 112), "handleFieldChanged:", 1);
      if (v3 && (objc_opt_respondsToSelector(*(_QWORD *)(a1 + 112), "handleFieldNotification:") & 1) != 0)
      {
        v4 = objc_msgSend(v3, "copy");
        objc_msgSend(v4, "setCachedBeforeRFReset:", 1);
        objc_msgSend(*(id *)(a1 + 112), "handleFieldNotification:", v4);

      }
      if (objc_msgSend(v3, "chFieldType") != (id)1)
        +[NFGeneralStatisticsCALogger updateAnalyticsGeneralTransactionStatistics:](NFGeneralStatisticsCALogger, "updateAnalyticsGeneralTransactionStatistics:", &off_1003065D8);
    }

  }
}

void *sub_1000E7B58(void *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  void *v7;
  uint64_t v8;
  unsigned int v9;
  void *specific;
  uint64_t Logger;
  void (*v12)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  NSObject *v20;
  objc_class *v21;
  int v22;
  id v23;
  uint64_t v25;
  uint8_t buf[4];
  int v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  const char *v31;
  __int16 v32;
  int v33;
  __int16 v34;
  id v35;
  __int16 v36;
  void *v37;

  v5 = a2;
  v6 = a3;
  v7 = v6;
  if (a1)
  {
    v9 = 1;
    if ((objc_msgSend(v6, "isEqualToString:", CFSTR("seld")) & 1) == 0
      && (objc_msgSend(v7, "isEqualToString:", CFSTR("seserviced")) & 1) == 0
      && (objc_msgSend(v7, "isEqualToString:", CFSTR("asd")) & 1) == 0)
    {
      v8 = objc_opt_class(_NFSecureElementLoggingSession);
      if ((objc_opt_isKindOfClass(v5, v8) & 1) == 0)
        v9 = 0;
    }
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v12 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("regularSessionsAllowed:clientName:");
      v25 = objc_opt_class(v5);
      v17 = 45;
      if (isMetaClass)
        v17 = 43;
      v12(6, "%c[%{public}s %{public}s]:%i Checking for %{public}@ session for %{public}@", v17, ClassName, Name, 2453, v25, v7);
    }
    v18 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v19 = NFSharedLogGetLogger(v18);
    v20 = objc_claimAutoreleasedReturnValue(v19);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      v21 = object_getClass(a1);
      if (class_isMetaClass(v21))
        v22 = 43;
      else
        v22 = 45;
      *(_DWORD *)buf = 67110402;
      v27 = v22;
      v28 = 2082;
      v29 = object_getClassName(a1);
      v30 = 2082;
      v31 = sel_getName("regularSessionsAllowed:clientName:");
      v32 = 1024;
      v33 = 2453;
      v34 = 2114;
      v35 = (id)objc_opt_class(v5);
      v36 = 2114;
      v37 = v7;
      v23 = v35;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Checking for %{public}@ session for %{public}@", buf, 0x36u);

    }
    a1 = (void *)sub_1000EA2AC((void **)a1, v9);
  }

  return a1;
}

void sub_1000E7DBC(uint64_t a1)
{
  NSMutableDictionary *v2;
  NSString *v3;
  void *v4;
  id v5;
  BOOL v6;
  void *specific;
  uint64_t Logger;
  void (*v9)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  objc_class *v16;
  int v17;
  const char *v18;
  const char *v19;
  id v20;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  NSObject *v25;
  const char *Name;
  id v27;
  uint8_t buf[4];
  int v29;
  __int16 v30;
  const char *v31;
  __int16 v32;
  const char *v33;
  __int16 v34;
  int v35;

  v2 = *(NSMutableDictionary **)(*(_QWORD *)(a1 + 32) + 376);
  v27 = 0;
  v3 = sub_1000993E4(v2, 5, &v27);
  v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  v5 = v27;

  if (v4)
    v6 = 1;
  else
    v6 = v5 == 0;
  if (v6)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v9 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 40));
      v13 = 45;
      if (isMetaClass)
        v13 = 43;
      v9(6, "%c[%{public}s %{public}s]:%i Failed to log Applet FTA CDS Log", v13, ClassName, Name, 1748);
    }
    v14 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v15 = NFSharedLogGetLogger(v14);
    v22 = objc_claimAutoreleasedReturnValue(v15);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      v16 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v16))
        v17 = 43;
      else
        v17 = 45;
      v18 = object_getClassName(*(id *)(a1 + 32));
      v19 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)buf = 67109890;
      v29 = v17;
      v30 = 2082;
      v31 = v18;
      v32 = 2082;
      v33 = v19;
      v34 = 1024;
      v35 = 1748;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Failed to log Applet FTA CDS Log", buf, 0x22u);
    }
  }
  else
  {
    v20 = objc_msgSend(v5, "copy");
    v21 = *(_QWORD *)(a1 + 32);
    v22 = *(NSObject **)(v21 + 208);
    *(_QWORD *)(v21 + 208) = v20;
  }

  v24 = NFSharedSignpostLog(v23);
  v25 = objc_claimAutoreleasedReturnValue(v24);
  if (os_signpost_enabled(v25))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v25, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "DUMP_LOGS_BOOTUP", "", buf, 2u);
  }

}

void sub_1000E7FE0(uint64_t a1, int a2)
{
  _BYTE *v4;
  void *specific;
  uint64_t Logger;
  void (*v7)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  objc_class *v15;
  int v16;
  void *v17;
  int v18;
  void *v19;
  void (*v20)(uint64_t, const char *, ...);
  objc_class *v21;
  uint64_t v22;
  const char *v23;
  const char *v24;
  void *v25;
  uint64_t v26;
  NSObject *v27;
  objc_class *v28;
  int v29;
  const char *v30;
  const char *v31;
  uint64_t v32;
  uint64_t v33;
  id v34;
  const char *Name;
  void **v36;
  uint64_t v37;
  void *v38;
  void *v39;
  uint64_t v40;
  uint8_t *v41;
  uint8_t v42[4];
  int v43;
  __int16 v44;
  const char *v45;
  __int16 v46;
  const char *v47;
  __int16 v48;
  int v49;
  __int16 v50;
  uint64_t v51;
  uint8_t buf[8];
  _BYTE v53[32];
  id v54;

  if ((byte_10032A9C0 & 1) == 0)
  {
    v4 = *(_BYTE **)(a1 + 88);
    if (v4)
    {
      sub_1001EAC98(v4);
      v4 = *(_BYTE **)(a1 + 88);
    }
    if (sub_1000098F0(v4))
    {
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v7 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass((id)a1);
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName((id)a1);
        Name = sel_getName("_updateSEPairingSynchronously:");
        v11 = 45;
        if (isMetaClass)
          v11 = 43;
        v7(6, "%c[%{public}s %{public}s]:%i ", v11, ClassName, Name, 1765);
      }
      v12 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v13 = NFSharedLogGetLogger(v12);
      v14 = objc_claimAutoreleasedReturnValue(v13);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        v15 = object_getClass((id)a1);
        if (class_isMetaClass(v15))
          v16 = 43;
        else
          v16 = 45;
        *(_DWORD *)buf = 67109890;
        *(_DWORD *)&buf[4] = v16;
        *(_WORD *)v53 = 2082;
        *(_QWORD *)&v53[2] = object_getClassName((id)a1);
        *(_WORD *)&v53[10] = 2082;
        *(_QWORD *)&v53[12] = sel_getName("_updateSEPairingSynchronously:");
        *(_WORD *)&v53[20] = 1024;
        *(_DWORD *)&v53[22] = 1765;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
      }

      sub_1000E3810(a1, a2);
      *(_QWORD *)buf = 0;
      *(_QWORD *)v53 = buf;
      *(_QWORD *)&v53[8] = 0x3032000000;
      *(_QWORD *)&v53[16] = sub_1000E3C80;
      *(_QWORD *)&v53[24] = sub_1000E3C90;
      v54 = 0;
      if (objc_msgSend(*(id *)(a1 + 376), "pairedState"))
        goto LABEL_30;
      if (a2)
      {
        v36 = _NSConcreteStackBlock;
        v37 = 3221225472;
        v38 = sub_1000E4108;
        v39 = &unk_1002E81B8;
        v40 = a1;
        v41 = buf;
        v17 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig embeddedWiredModeWithFD:](NFRoutingConfig, "embeddedWiredModeWithFD:", 0));
        v18 = sub_1000E3CEC((void **)a1, &v36, CFSTR("Negotiate Auth Keys"), v17);

        if (v18 && !*(_QWORD *)(*(_QWORD *)v53 + 40))
          goto LABEL_30;
        v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v20 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v19);
        if (v20)
        {
          v21 = object_getClass((id)a1);
          if (class_isMetaClass(v21))
            v22 = 43;
          else
            v22 = 45;
          v23 = object_getClassName((id)a1);
          v24 = sel_getName("_negotiatePerBootAuthKeysSynchronously:");
          v20(3, "%c[%{public}s %{public}s]:%i Failed: %{public}@", v22, v23, v24, 1232, *(_QWORD *)(*(_QWORD *)v53 + 40));
        }
        v25 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v26 = NFSharedLogGetLogger(v25);
        v27 = objc_claimAutoreleasedReturnValue(v26);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        {
          v28 = object_getClass((id)a1);
          if (class_isMetaClass(v28))
            v29 = 43;
          else
            v29 = 45;
          v30 = object_getClassName((id)a1);
          v31 = sel_getName("_negotiatePerBootAuthKeysSynchronously:");
          v32 = *(_QWORD *)(*(_QWORD *)v53 + 40);
          *(_DWORD *)v42 = 67110146;
          v43 = v29;
          v44 = 2082;
          v45 = v30;
          v46 = 2082;
          v47 = v31;
          v48 = 1024;
          v49 = 1232;
          v50 = 2114;
          v51 = v32;
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed: %{public}@", v42, 0x2Cu);
        }
      }
      else
      {
        v33 = *(_QWORD *)(a1 + 232);
        v27 = objc_claimAutoreleasedReturnValue(+[NFRoutingConfig embeddedWiredMode](NFRoutingConfig, "embeddedWiredMode"));
        v36 = _NSConcreteStackBlock;
        v37 = 3221225472;
        v38 = sub_1000E415C;
        v39 = &unk_1002E5C58;
        v40 = a1;
        v34 = +[_NFBuiltinSession createSessionWithWorkQueue:routing:sessionQueuer:didStartWork:](_NFBuiltinSession, "createSessionWithWorkQueue:routing:sessionQueuer:didStartWork:", v33, v27, a1, &v36);
      }

LABEL_30:
      _Block_object_dispose(buf, 8);

      byte_10032A9C0 = 1;
    }
  }
}

void sub_1000E8420(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

void sub_1000E8458(id *a1, void *a2)
{
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  id *v6;
  BOOL v7;
  void *specific;
  void (*Logger)(uint64_t, const char *, ...);
  objc_class *Class;
  uint64_t v11;
  const char *ClassName;
  const char *Name;
  void *v14;
  uint64_t v15;
  NSObject *v16;
  objc_class *v17;
  int v18;
  const char *v19;
  const char *v20;
  const char *v21;
  void *v22;
  void (*v23)(uint64_t, const char *, ...);
  objc_class *v24;
  uint64_t v25;
  const char *v26;
  const char *v27;
  void *v28;
  uint64_t v29;
  objc_class *v30;
  int v31;
  const char *v32;
  const char *v33;
  void *v34;
  uint64_t v35;
  void *v36;
  void *v37;
  void *v38;
  void (*v39)(uint64_t, const char *, ...);
  objc_class *v40;
  uint64_t v41;
  const char *v42;
  const char *v43;
  void *v44;
  void *v45;
  uint64_t v46;
  NSObject *v47;
  objc_class *v48;
  int v49;
  const char *v50;
  const char *v51;
  void *v52;
  uint64_t v53;
  uint64_t v54;
  void *v55;
  unsigned __int8 v56;
  _BYTE *v57;
  void *v58;
  void (*v59)(uint64_t, const char *, ...);
  objc_class *v60;
  uint64_t v61;
  const char *v62;
  const char *v63;
  void *v64;
  uint64_t v65;
  NSObject *v66;
  objc_class *v67;
  int v68;
  const char *v69;
  const char *v70;
  NSObject *v71;
  const char *v72;
  id *v73;
  void *v74;
  void (*v75)(uint64_t, const char *, ...);
  objc_class *v76;
  uint64_t v77;
  const char *v78;
  const char *v79;
  void *v80;
  uint64_t v81;
  objc_class *v82;
  int v83;
  const char *v84;
  const char *v85;
  void *v86;
  void (*v87)(uint64_t, const char *, ...);
  objc_class *v88;
  uint64_t v89;
  const char *v90;
  const char *v91;
  void *v92;
  uint64_t v93;
  objc_class *v94;
  int v95;
  const char *v96;
  const char *v97;
  void *v98;
  _BOOL4 v99;
  int v100;
  id v101;
  id v102;
  _BYTE *v103;
  void *v104;
  void (*v105)(uint64_t, const char *, ...);
  objc_class *v106;
  uint64_t v107;
  const char *v108;
  const char *v109;
  void *v110;
  uint64_t v111;
  NSObject *v112;
  objc_class *v113;
  int v114;
  const char *v115;
  const char *v116;
  id v117;
  id v118;
  uint64_t v119;
  unint64_t v120;
  void *v121;
  void *v122;
  void (*v123)(uint64_t, const char *, ...);
  objc_class *v124;
  uint64_t v125;
  const char *v126;
  const char *v127;
  void *v128;
  void *v129;
  uint64_t v130;
  NSObject *v131;
  objc_class *v132;
  int v133;
  const char *v134;
  const char *v135;
  void *v136;
  id v137;
  id v138;
  void *v139;
  void *v140;
  id v141;
  id v142;
  void *v143;
  id v144;
  id v145;
  uint64_t v146;
  void *v147;
  void (*v148)(uint64_t, const char *, ...);
  objc_class *v149;
  uint64_t v150;
  const char *v151;
  const char *v152;
  void *v153;
  uint64_t v154;
  objc_class *v155;
  int v156;
  const char *v157;
  const char *v158;
  id v159;
  void *v160;
  void *v161;
  void (*v162)(uint64_t, const char *, ...);
  objc_class *v163;
  uint64_t v164;
  const char *v165;
  const char *v166;
  void *v167;
  uint64_t v168;
  NSObject *v169;
  objc_class *v170;
  int v171;
  const char *v172;
  const char *v173;
  void *v174;
  id v175;
  void *v176;
  id v177;
  id v178;
  id v179;
  uint64_t v180;
  int v181;
  BOOL v182;
  int v183;
  id v184;
  _BYTE *v185;
  void *v186;
  void (*v187)(uint64_t, const char *, ...);
  objc_class *v188;
  uint64_t v189;
  const char *v190;
  const char *v191;
  void *v192;
  uint64_t v193;
  objc_class *v194;
  int v195;
  const char *v196;
  const char *v197;
  void *v198;
  void (*v199)(uint64_t, const char *, ...);
  objc_class *v200;
  uint64_t v201;
  const char *v202;
  const char *v203;
  void *v204;
  uint64_t v205;
  NSObject *v206;
  objc_class *v207;
  int v208;
  const char *v209;
  const char *v210;
  void *v211;
  void (*v212)(uint64_t, const char *, ...);
  objc_class *v213;
  uint64_t v214;
  const char *v215;
  const char *v216;
  void *v217;
  uint64_t v218;
  NSObject *v219;
  objc_class *v220;
  int v221;
  const char *v222;
  const char *v223;
  id v224;
  id v225;
  uint64_t v226;
  void *i;
  void *v228;
  void *v229;
  void *v230;
  uint64_t v231;
  char isKindOfClass;
  NSObject *v233;
  id v234;
  void *v235;
  id v236;
  void *v237;
  void *v238;
  unsigned int v239;
  void *v240;
  unsigned int v241;
  int v242;
  id v243;
  void *v244;
  _BOOL4 v245;
  void *v246;
  id obj;
  id v248;
  __int128 v249;
  __int128 v250;
  __int128 v251;
  __int128 v252;
  _QWORD block[5];
  _BYTE v254[128];
  _QWORD v255[5];
  _QWORD v256[5];
  _QWORD v257[4];
  _QWORD v258[4];
  uint8_t buf[4];
  int v260;
  __int16 v261;
  const char *v262;
  __int16 v263;
  const char *v264;
  __int16 v265;
  int v266;
  __int16 v267;
  uint64_t v268;

  v248 = a2;
  if (a1
    && (-[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)a1) == 2
     || -[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)a1) == 5))
  {
    obj = a1[23];
    objc_sync_enter(obj);
    v3 = kdebug_trace(724566216, 0, 0, 0, 0);
    v4 = NFSharedSignpostLog(v3);
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_signpost_enabled(v5))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v5, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "MAYBE_START_NEXT_SESSION", "", buf, 2u);
    }

    v6 = a1;
    objc_sync_enter(v6);
    v7 = *((_BYTE *)v6 + 337) == 0;
    objc_sync_exit(v6);

    if (v7)
      goto LABEL_35;
    if (*((_BYTE *)v6 + 356))
    {
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(specific);
      if (Logger)
      {
        Class = object_getClass(v6);
        if (class_isMetaClass(Class))
          v11 = 43;
        else
          v11 = 45;
        ClassName = object_getClassName(v6);
        Name = sel_getName("maybeStartNextSessionOnField:");
        Logger(6, "%c[%{public}s %{public}s]:%i User-initated shutdown started, abort further processing", v11, ClassName, Name, 1797);
      }
      v14 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v15 = NFSharedLogGetLogger(v14);
      v16 = objc_claimAutoreleasedReturnValue(v15);
      if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        goto LABEL_30;
      v17 = object_getClass(v6);
      if (class_isMetaClass(v17))
        v18 = 43;
      else
        v18 = 45;
      v19 = object_getClassName(v6);
      v20 = sel_getName("maybeStartNextSessionOnField:");
      *(_DWORD *)buf = 67109890;
      v260 = v18;
      v261 = 2082;
      v262 = v19;
      v263 = 2082;
      v264 = v20;
      v265 = 1024;
      v266 = 1797;
      v21 = "%c[%{public}s %{public}s]:%i User-initated shutdown started, abort further processing";
      goto LABEL_29;
    }
    if (*((_BYTE *)v6 + 344))
    {
      v22 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v23 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v22);
      if (v23)
      {
        v24 = object_getClass(v6);
        if (class_isMetaClass(v24))
          v25 = 43;
        else
          v25 = 45;
        v26 = object_getClassName(v6);
        v27 = sel_getName("maybeStartNextSessionOnField:");
        v23(6, "%c[%{public}s %{public}s]:%i System is going to sleep - delaying start of new session", v25, v26, v27, 1803);
      }
      v28 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v29 = NFSharedLogGetLogger(v28);
      v16 = objc_claimAutoreleasedReturnValue(v29);
      if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        goto LABEL_30;
      v30 = object_getClass(v6);
      if (class_isMetaClass(v30))
        v31 = 43;
      else
        v31 = 45;
      v32 = object_getClassName(v6);
      v33 = sel_getName("maybeStartNextSessionOnField:");
      *(_DWORD *)buf = 67109890;
      v260 = v31;
      v261 = 2082;
      v262 = v32;
      v263 = 2082;
      v264 = v33;
      v265 = 1024;
      v266 = 1803;
      v21 = "%c[%{public}s %{public}s]:%i System is going to sleep - delaying start of new session";
LABEL_29:
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v21, buf, 0x22u);
      goto LABEL_30;
    }
    v35 = sub_100098AF4((uint64_t)v6);
    sub_100097E1C((uint64_t)v6, v35);
    if (v6[14] || (sub_1000E7FE0((uint64_t)v6, 1), v6[14]))
    {
LABEL_35:
      v34 = 0;
      goto LABEL_36;
    }
    v34 = 0;
LABEL_39:
    v246 = v34;
    if (!objc_msgSend(a1[23], "count"))
    {
      if (!v6[14])
      {
LABEL_168:
        v185 = v6[3];
        if (v185 && v185[172])
        {
          v186 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v187 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v186);
          if (v187)
          {
            v188 = object_getClass(v6);
            if (class_isMetaClass(v188))
              v189 = 43;
            else
              v189 = 45;
            v190 = object_getClassName(v6);
            v191 = sel_getName("maybeStartNextSessionOnField:");
            v187(6, "%c[%{public}s %{public}s]:%i Express Mode in progress - skip routing config", v189, v190, v191, 1925);
          }
          v192 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v193 = NFSharedLogGetLogger(v192);
          v16 = objc_claimAutoreleasedReturnValue(v193);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            v194 = object_getClass(v6);
            if (class_isMetaClass(v194))
              v195 = 43;
            else
              v195 = 45;
            v196 = object_getClassName(v6);
            v197 = sel_getName("maybeStartNextSessionOnField:");
            *(_DWORD *)buf = 67109890;
            v260 = v195;
            v261 = 2082;
            v262 = v196;
            v263 = 2082;
            v264 = v197;
            v265 = 1024;
            v266 = 1925;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Express Mode in progress - skip routing config", buf, 0x22u);
          }
        }
        else
        {
          sub_1000E9FE8((uint64_t)v6);
          sub_1001D4314((uint64_t)v6);
          if (sub_1000EA2AC(v6, 1u))
            objc_msgSend(v6[51], "start");
          if (*((_BYTE *)v6 + 339))
          {
            v198 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v199 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v198);
            if (v199)
            {
              v200 = object_getClass(v6);
              if (class_isMetaClass(v200))
                v201 = 43;
              else
                v201 = 45;
              v202 = object_getClassName(v6);
              v203 = sel_getName("maybeStartNextSessionOnField:");
              v199(5, "%c[%{public}s %{public}s]:%i Restarting driver for defaults changes", v201, v202, v203, 1945);
            }
            v204 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v205 = NFSharedLogGetLogger(v204);
            v206 = objc_claimAutoreleasedReturnValue(v205);
            if (os_log_type_enabled(v206, OS_LOG_TYPE_DEFAULT))
            {
              v207 = object_getClass(v6);
              if (class_isMetaClass(v207))
                v208 = 43;
              else
                v208 = 45;
              v209 = object_getClassName(v6);
              v210 = sel_getName("maybeStartNextSessionOnField:");
              *(_DWORD *)buf = 67109890;
              v260 = v208;
              v261 = 2082;
              v262 = v209;
              v263 = 2082;
              v264 = v210;
              v265 = 1024;
              v266 = 1945;
              _os_log_impl((void *)&_mh_execute_header, v206, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Restarting driver for defaults changes", buf, 0x22u);
            }

            sub_1001FB970(v6[46]);
            *((_BYTE *)v6 + 339) = 0;
            v211 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v212 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v211);
            if (v212)
            {
              v213 = object_getClass(v6);
              if (class_isMetaClass(v213))
                v214 = 43;
              else
                v214 = 45;
              v215 = object_getClassName(v6);
              v216 = sel_getName("maybeStartNextSessionOnField:");
              v212(5, "%c[%{public}s %{public}s]:%i Done restarting driver for defaults changes", v214, v215, v216, 1948);
            }
            v217 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v218 = NFSharedLogGetLogger(v217);
            v219 = objc_claimAutoreleasedReturnValue(v218);
            if (os_log_type_enabled(v219, OS_LOG_TYPE_DEFAULT))
            {
              v220 = object_getClass(v6);
              if (class_isMetaClass(v220))
                v221 = 43;
              else
                v221 = 45;
              v222 = object_getClassName(v6);
              v223 = sel_getName("maybeStartNextSessionOnField:");
              *(_DWORD *)buf = 67109890;
              v260 = v221;
              v261 = 2082;
              v262 = v222;
              v263 = 2082;
              v264 = v223;
              v265 = 1024;
              v266 = 1948;
              _os_log_impl((void *)&_mh_execute_header, v219, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Done restarting driver for defaults changes", buf, 0x22u);
            }

          }
          v251 = 0u;
          v252 = 0u;
          v249 = 0u;
          v250 = 0u;
          v224 = v6[24];
          v225 = objc_msgSend(v224, "countByEnumeratingWithState:objects:count:", &v249, v254, 16);
          if (v225)
          {
            v226 = *(_QWORD *)v250;
            while (2)
            {
              for (i = 0; i != v225; i = (char *)i + 1)
              {
                if (*(_QWORD *)v250 != v226)
                  objc_enumerationMutation(v224);
                v228 = *(void **)(*((_QWORD *)&v249 + 1) + 8 * (_QWORD)i);
                v229 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v228, "startOnFieldList"));
                if (v229)
                {
                  v230 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v228, "parentToken"));
                  if (v230)
                  {

                  }
                  else
                  {
                    v231 = objc_opt_class(_NFHCESession);
                    isKindOfClass = objc_opt_isKindOfClass(v228, v231);

                    if ((isKindOfClass & 1) != 0)
                    {
                      v234 = v228;
                      v16 = objc_claimAutoreleasedReturnValue(objc_msgSend(v234, "effectiveECPFrame"));

                      goto LABEL_218;
                    }
                  }
                }
              }
              v225 = objc_msgSend(v224, "countByEnumeratingWithState:objects:count:", &v249, v254, 16);
              if (v225)
                continue;
              break;
            }
          }
          v16 = 0;
LABEL_218:

          sub_1000EA4A4(v6, v16);
          v235 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "lastKnownRoutingConfig"));
          v236 = sub_1000EA6F4((uint64_t)v6, (uint64_t)objc_msgSend(v235, "fieldDetectType"), v16);
          v237 = (void *)objc_claimAutoreleasedReturnValue(v236);

          v238 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "lastKnownRoutingConfig"));
          v239 = objc_msgSend(v237, "isEquivalentRouting:", v238);

          if (!v239
            || (v240 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "lastKnownRoutingConfig")),
                v241 = objc_msgSend(v240, "fdOn"),
                v242 = sub_100098AF4((uint64_t)v6),
                v240,
                ((v241 ^ v242) & 1) != 0))
          {
            v243 = sub_1001F84C8(v6[46], CFSTR("StartSessionOFF"), 1uLL);
            v244 = (void *)objc_claimAutoreleasedReturnValue(v243);
            v245 = v244 == 0;

            if (v245)
            {
              sub_1000EA9A0(v6, v16);
              sub_1001FABB8(v6[46], CFSTR("StartSessionOFF"));
            }
          }

        }
        goto LABEL_31;
      }
LABEL_32:
      v34 = v246;
      goto LABEL_36;
    }
    v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[23], "objectAtIndex:", 0));
    while (1)
    {
      if (!objc_msgSend(a1[23], "count"))
      {
        v37 = 0;
LABEL_100:

        v101 = v6[14];
        v6[14] = v37;

        v102 = v6[14];
        if (!v102)
          goto LABEL_168;
        v103 = v6[3];
        if (v103 && v103[172] && objc_msgSend(v102, "forceExpressExit"))
        {
          v104 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v105 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v104);
          if (v105)
          {
            v106 = object_getClass(v6);
            if (class_isMetaClass(v106))
              v107 = 43;
            else
              v107 = 45;
            v108 = object_getClassName(v6);
            v109 = sel_getName("maybeStartNextSessionOnField:");
            v105(6, "%c[%{public}s %{public}s]:%i forcing exiting express mode", v107, v108, v109, 1833);
          }
          v110 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v111 = NFSharedLogGetLogger(v110);
          v112 = objc_claimAutoreleasedReturnValue(v111);
          if (os_log_type_enabled(v112, OS_LOG_TYPE_DEFAULT))
          {
            v113 = object_getClass(v6);
            if (class_isMetaClass(v113))
              v114 = 43;
            else
              v114 = 45;
            v115 = object_getClassName(v6);
            v116 = sel_getName("maybeStartNextSessionOnField:");
            *(_DWORD *)buf = 67109890;
            v260 = v114;
            v261 = 2082;
            v262 = v115;
            v263 = 2082;
            v264 = v116;
            v265 = 1024;
            v266 = 1833;
            _os_log_impl((void *)&_mh_execute_header, v112, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i forcing exiting express mode", buf, 0x22u);
          }

          v117 = v6[3];
          if (v117)
            sub_1000498F8(v117, 0);
        }
        if (objc_msgSend(v6[14], "priority"))
          sub_1001C8AA0((uint64_t)v6);
        if ((objc_msgSend(v6[14], "allowsBackgroundMode") & 1) != 0
          || (v118 = v6[14],
              v119 = objc_opt_class(_NFXPCSession),
              (objc_opt_isKindOfClass(v118, v119) & 1) == 0)
          || (v120 = (unint64_t)v6[9],
              v121 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6[14], "connection")),
              LODWORD(v120) = sub_100050744(v120, v121),
              v121,
              !(_DWORD)v120))
        {
          objc_msgSend(v6[14], "holdAssertion");
          v145 = sub_1001F84C8(v6[46], CFSTR("Session"), objc_msgSend(v6[14], "isSessionSEOnly") ^ 1);
          v146 = objc_claimAutoreleasedReturnValue(v145);

          objc_msgSend(v6[51], "stop");
          if (v146)
          {
            v147 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v148 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v147);
            if (v148)
            {
              v149 = object_getClass(v6);
              if (class_isMetaClass(v149))
                v150 = 43;
              else
                v150 = 45;
              v151 = object_getClassName(v6);
              v152 = sel_getName("maybeStartNextSessionOnField:");
              v148(3, "%c[%{public}s %{public}s]:%i Failed to open session with SE : %@", v150, v151, v152, 1896, v146);
            }
            v153 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v154 = NFSharedLogGetLogger(v153);
            v16 = objc_claimAutoreleasedReturnValue(v154);
            if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
            {
              v155 = object_getClass(v6);
              if (class_isMetaClass(v155))
                v156 = 43;
              else
                v156 = 45;
              v157 = object_getClassName(v6);
              v158 = sel_getName("maybeStartNextSessionOnField:");
              *(_DWORD *)buf = 67110146;
              v260 = v156;
              v261 = 2082;
              v262 = v157;
              v263 = 2082;
              v264 = v158;
              v265 = 1024;
              v266 = 1896;
              v267 = 2112;
              v268 = v146;
              _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session with SE : %@", buf, 0x2Cu);
            }
            v246 = (void *)v146;
LABEL_158:

            v176 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Failed to open session. Error = %@"), v246));
            sub_100187CDC((uint64_t)NFBugCapture, CFSTR("Failed to start the session"), v176, 0);

            v177 = v6[14];
            v178 = objc_alloc((Class)NSError);
            v139 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
            v255[0] = NSLocalizedDescriptionKey;
            v140 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
            v256[0] = v140;
            v256[1] = v246;
            v255[1] = NSUnderlyingErrorKey;
            v255[2] = CFSTR("Line");
            v256[2] = &off_1002FEE68;
            v255[3] = CFSTR("Method");
            v141 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("maybeStartNextSessionOnField:"));
            v256[3] = v141;
            v255[4] = NSDebugDescriptionErrorKey;
            v142 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("maybeStartNextSessionOnField:"), 1903);
            v256[4] = v142;
            v143 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v256, v255, 5));
            v144 = objc_msgSend(v178, "initWithDomain:code:userInfo:", v139, 15, v143);
            objc_msgSend(v177, "didStartSession:", v144);
            goto LABEL_159;
          }
          objc_msgSend(v6[14], "willStartSession");
          v159 = v6[14];
          v16 = objc_claimAutoreleasedReturnValue(objc_msgSend(v159, "initialECPConfig"));

          if (-[NSObject length](v16, "length"))
            objc_msgSend(v6, "configureECPPolling:", v16);
          v160 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6[14], "initialRoutingConfigWithField:", v248));
          v246 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "setRoutingConfig:", v160));

          if (v246)
          {
            v161 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v162 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v161);
            if (v162)
            {
              v163 = object_getClass(v6);
              if (class_isMetaClass(v163))
                v164 = 43;
              else
                v164 = 45;
              v165 = object_getClassName(v6);
              v166 = sel_getName("maybeStartNextSessionOnField:");
              v162(3, "%c[%{public}s %{public}s]:%i Failed to set initial routing for session : %{public}@", v164, v165, v166, 1889, v246);
            }
            v167 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v168 = NFSharedLogGetLogger(v167);
            v169 = objc_claimAutoreleasedReturnValue(v168);
            if (os_log_type_enabled(v169, OS_LOG_TYPE_ERROR))
            {
              v170 = object_getClass(v6);
              if (class_isMetaClass(v170))
                v171 = 43;
              else
                v171 = 45;
              v172 = object_getClassName(v6);
              v173 = sel_getName("maybeStartNextSessionOnField:");
              *(_DWORD *)buf = 67110146;
              v260 = v171;
              v261 = 2082;
              v262 = v172;
              v263 = 2082;
              v264 = v173;
              v265 = 1024;
              v266 = 1889;
              v267 = 2114;
              v268 = (uint64_t)v246;
              _os_log_impl((void *)&_mh_execute_header, v169, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to set initial routing for session : %{public}@", buf, 0x2Cu);
            }

            v174 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig routingOff](NFRoutingConfig, "routingOff"));
            v175 = objc_msgSend(v6, "setRoutingConfig:", v174);

            sub_1001FABB8(v6[46], CFSTR("Session"));
            goto LABEL_158;
          }
          v233 = v6[29];
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472;
          block[2] = sub_1000E9EBC;
          block[3] = &unk_1002E5C58;
          block[4] = v6;
          dispatch_async(v233, block);
          sub_1001D4F38(v6);
LABEL_30:
          v246 = 0;
LABEL_31:

          goto LABEL_32;
        }
        v122 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v123 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v122);
        if (v123)
        {
          v124 = object_getClass(v6);
          if (class_isMetaClass(v124))
            v125 = 43;
          else
            v125 = 45;
          v126 = object_getClassName(v6);
          v127 = sel_getName("maybeStartNextSessionOnField:");
          v128 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6[14], "clientName"));
          v123(6, "%c[%{public}s %{public}s]:%i Session is not allowed because %{public}@ is in background mode", v125, v126, v127, 1845, v128);

        }
        v129 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v130 = NFSharedLogGetLogger(v129);
        v131 = objc_claimAutoreleasedReturnValue(v130);
        if (os_log_type_enabled(v131, OS_LOG_TYPE_DEFAULT))
        {
          v132 = object_getClass(v6);
          if (class_isMetaClass(v132))
            v133 = 43;
          else
            v133 = 45;
          v134 = object_getClassName(v6);
          v135 = sel_getName("maybeStartNextSessionOnField:");
          v136 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6[14], "clientName"));
          *(_DWORD *)buf = 67110146;
          v260 = v133;
          v261 = 2082;
          v262 = v134;
          v263 = 2082;
          v264 = v135;
          v265 = 1024;
          v266 = 1845;
          v267 = 2114;
          v268 = (uint64_t)v136;
          _os_log_impl((void *)&_mh_execute_header, v131, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Session is not allowed because %{public}@ is in background mode", buf, 0x2Cu);

        }
        v137 = v6[14];
        v138 = objc_alloc((Class)NSError);
        v139 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v257[0] = NSLocalizedDescriptionKey;
        v140 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid State"));
        v258[0] = v140;
        v258[1] = &off_1002FEE50;
        v257[1] = CFSTR("Line");
        v257[2] = CFSTR("Method");
        v141 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("maybeStartNextSessionOnField:"));
        v258[2] = v141;
        v257[3] = NSDebugDescriptionErrorKey;
        v142 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("maybeStartNextSessionOnField:"), 1846);
        v258[3] = v142;
        v143 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v258, v257, 4));
        v144 = objc_msgSend(v138, "initWithDomain:code:userInfo:", v139, 12, v143);
        objc_msgSend(v137, "didStartSession:", v144);
LABEL_159:

        v179 = v6[14];
        v180 = objc_opt_class(_NFReaderSession);
        if ((objc_opt_isKindOfClass(v179, v180) & 1) != 0)
        {
          if (objc_msgSend(v6[14], "timeLimitedSession"))
          {
            v181 = *((_DWORD *)v6 + 80);
            v182 = __OFSUB__(v181, 1);
            v183 = v181 - 1;
            if (v183 < 0 == v182)
              *((_DWORD *)v6 + 80) = v183;
          }
        }
        objc_msgSend(v6[14], "releaseObjects");
        v184 = v6[14];
        v6[14] = 0;

        if (!objc_msgSend(a1[23], "count"))
          sub_1000DBE28(v6, 0);
        v34 = v246;
        if (v6[14])
        {
LABEL_36:

          objc_sync_exit(obj);
          goto LABEL_37;
        }
        goto LABEL_39;
      }
      v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[23], "objectAtIndex:", 0));
      objc_msgSend(a1[23], "removeObjectAtIndex:", 0);
      v38 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v39 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v38);
      if (v39)
      {
        v40 = object_getClass(v6);
        if (class_isMetaClass(v40))
          v41 = 43;
        else
          v41 = 45;
        v42 = object_getClassName(v6);
        v43 = sel_getName("copyNextDequeuableSession");
        v44 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v37, "sessionUID"));
        v39(6, "%c[%{public}s %{public}s]:%i Next queued session=%{public}@", v41, v42, v43, 1665, v44);

      }
      v45 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v46 = NFSharedLogGetLogger(v45);
      v47 = objc_claimAutoreleasedReturnValue(v46);
      if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
      {
        v48 = object_getClass(v6);
        if (class_isMetaClass(v48))
          v49 = 43;
        else
          v49 = 45;
        v50 = object_getClassName(v6);
        v51 = sel_getName("copyNextDequeuableSession");
        v52 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v37, "sessionUID"));
        *(_DWORD *)buf = 67110146;
        v260 = v49;
        v261 = 2082;
        v262 = v50;
        v263 = 2082;
        v264 = v51;
        v265 = 1024;
        v266 = 1665;
        v267 = 2114;
        v268 = (uint64_t)v52;
        _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Next queued session=%{public}@", buf, 0x2Cu);

      }
      v53 = objc_opt_class(v37);
      if (v53 == objc_opt_class(_NFReaderSession))
      {
        v73 = (id *)v6[46];
        if (v73)
        {
          if ((objc_msgSend(v73[11], "readerModeProtectionActive") & 1) != 0)
            break;
        }
        if (v6[38])
          break;
      }
      v54 = objc_opt_class(v37);
      if (v54 != objc_opt_class(_NFSeshatSession))
      {
        v55 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v37, "clientName"));
        v56 = sub_1000E7B58(v6, v37, v55);

        if ((v56 & 1) == 0)
        {
          v86 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v87 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v86);
          if (v87)
          {
            v88 = object_getClass(v6);
            if (class_isMetaClass(v88))
              v89 = 43;
            else
              v89 = 45;
            v90 = object_getClassName(v6);
            v91 = sel_getName("copyNextDequeuableSession");
            v87(6, "%c[%{public}s %{public}s]:%i Only seshat session allowed currently, enqueuing for later", v89, v90, v91, 1674);
          }
          v92 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v93 = NFSharedLogGetLogger(v92);
          v66 = objc_claimAutoreleasedReturnValue(v93);
          if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
          {
            v94 = object_getClass(v6);
            if (class_isMetaClass(v94))
              v95 = 43;
            else
              v95 = 45;
            v96 = object_getClassName(v6);
            v97 = sel_getName("copyNextDequeuableSession");
            *(_DWORD *)buf = 67109890;
            v260 = v95;
            v261 = 2082;
            v262 = v96;
            v263 = 2082;
            v264 = v97;
            v265 = 1024;
            v266 = 1674;
            v71 = v66;
            v72 = "%c[%{public}s %{public}s]:%i Only seshat session allowed currently, enqueuing for later";
            goto LABEL_91;
          }
LABEL_92:

          objc_msgSend(a1[23], "addObject:", v37);
          v37 = 0;
          goto LABEL_93;
        }
      }
      v57 = v6[3];
      if (v57 && v57[172] && (objc_msgSend(v37, "forceExpressExit") & 1) == 0)
      {
        v58 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v59 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v58);
        if (v59)
        {
          v60 = object_getClass(v6);
          if (class_isMetaClass(v60))
            v61 = 43;
          else
            v61 = 45;
          v62 = object_getClassName(v6);
          v63 = sel_getName("copyNextDequeuableSession");
          v59(6, "%c[%{public}s %{public}s]:%i Express Mode in progress - delaying start of session", v61, v62, v63, 1680);
        }
        v64 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v65 = NFSharedLogGetLogger(v64);
        v66 = objc_claimAutoreleasedReturnValue(v65);
        if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
        {
          v67 = object_getClass(v6);
          if (class_isMetaClass(v67))
            v68 = 43;
          else
            v68 = 45;
          v69 = object_getClassName(v6);
          v70 = sel_getName("copyNextDequeuableSession");
          *(_DWORD *)buf = 67109890;
          v260 = v68;
          v261 = 2082;
          v262 = v69;
          v263 = 2082;
          v264 = v70;
          v265 = 1024;
          v266 = 1680;
          v71 = v66;
          v72 = "%c[%{public}s %{public}s]:%i Express Mode in progress - delaying start of session";
          goto LABEL_91;
        }
        goto LABEL_92;
      }
LABEL_93:
      if (objc_msgSend(a1[23], "count"))
      {
        v98 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[23], "objectAtIndex:", 0));
        v99 = v98 == v36;

        v100 = v37 || v99;
        if (v100 != 1)
          continue;
      }
      goto LABEL_100;
    }
    v74 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v75 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v74);
    if (v75)
    {
      v76 = object_getClass(v6);
      if (class_isMetaClass(v76))
        v77 = 43;
      else
        v77 = 45;
      v78 = object_getClassName(v6);
      v79 = sel_getName("copyNextDequeuableSession");
      v75(6, "%c[%{public}s %{public}s]:%i Reader sessions not ready for dequeue, enqueuing for later", v77, v78, v79, 1668);
    }
    v80 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v81 = NFSharedLogGetLogger(v80);
    v66 = objc_claimAutoreleasedReturnValue(v81);
    if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
    {
      v82 = object_getClass(v6);
      if (class_isMetaClass(v82))
        v83 = 43;
      else
        v83 = 45;
      v84 = object_getClassName(v6);
      v85 = sel_getName("copyNextDequeuableSession");
      *(_DWORD *)buf = 67109890;
      v260 = v83;
      v261 = 2082;
      v262 = v84;
      v263 = 2082;
      v264 = v85;
      v265 = 1024;
      v266 = 1668;
      v71 = v66;
      v72 = "%c[%{public}s %{public}s]:%i Reader sessions not ready for dequeue, enqueuing for later";
LABEL_91:
      _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, v72, buf, 0x22u);
    }
    goto LABEL_92;
  }
LABEL_37:

}

void sub_1000E9E04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,id obj)
{
  objc_sync_exit(obj);
  _Unwind_Resume(a1);
}

void sub_1000E9EBC(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  void *v5;
  unsigned __int8 v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  void *v10;

  v2 = kdebug_trace(724566052, 0, 0, 0, 0);
  v3 = NFSharedSignpostLog(v2);
  v4 = objc_claimAutoreleasedReturnValue(v3);
  if (os_signpost_enabled(v4))
  {
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 112), "sessionUID"));
    v9 = 138412290;
    v10 = v5;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SESSION_STARTED", "sessionUID=%@", (uint8_t *)&v9, 0xCu);

  }
  objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 112), "didStartSession:", 0);
  v6 = objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 112), "shouldHandleSecureElementTransactionData");
  v7 = *(_QWORD *)(a1 + 32);
  v8 = *(_QWORD *)(v7 + 368);
  if (v8)
  {
    *(_BYTE *)(v8 + 221) = v6;
    v7 = *(_QWORD *)(a1 + 32);
  }
  sub_1000E7A78(v7);
  sub_1001C8CF8(*(_QWORD *)(a1 + 32));
}

void sub_1000E9FE8(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  NSObject *v11;
  objc_class *v12;
  int v13;
  id v14;
  void *v15;
  void *v16;
  uint64_t v17;
  void (*v18)(uint64_t, const char *, ...);
  objc_class *v19;
  _BOOL4 v20;
  const char *v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  NSObject *v25;
  objc_class *v26;
  int v27;
  const char *Name;
  const char *v29;
  uint8_t buf[4];
  int v31;
  __int16 v32;
  const char *v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  int v37;

  if (*(_BYTE *)(a1 + 354))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass((id)a1);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName((id)a1);
      Name = sel_getName("_handleBackgroundTasks");
      v8 = 45;
      if (isMetaClass)
        v8 = 43;
      v4(4, "%c[%{public}s %{public}s]:%i FailForward disabled - are you sure you want this?!", v8, ClassName, Name, 1999);
    }
    v9 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v10 = NFSharedLogGetLogger(v9);
    v11 = objc_claimAutoreleasedReturnValue(v10);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v12 = object_getClass((id)a1);
      if (class_isMetaClass(v12))
        v13 = 43;
      else
        v13 = 45;
      *(_DWORD *)buf = 67109890;
      v31 = v13;
      v32 = 2082;
      v33 = object_getClassName((id)a1);
      v34 = 2082;
      v35 = sel_getName("_handleBackgroundTasks");
      v36 = 1024;
      v37 = 1999;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i FailForward disabled - are you sure you want this?!", buf, 0x22u);
    }

  }
  else
  {
    v14 = sub_100202170(*(void **)(a1 + 368));
    v15 = (void *)objc_claimAutoreleasedReturnValue(v14);

    if (v15)
    {
      v16 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v17 = NFLogGetLogger(v16);
      if (v17)
      {
        v18 = (void (*)(uint64_t, const char *, ...))v17;
        v19 = object_getClass((id)a1);
        v20 = class_isMetaClass(v19);
        v21 = object_getClassName((id)a1);
        v29 = sel_getName("_handleBackgroundTasks");
        v22 = 45;
        if (v20)
          v22 = 43;
        v18(3, "%c[%{public}s %{public}s]:%i Failed to attempt Fail Forward recovery - bailing.", v22, v21, v29, 1994);
      }
      v23 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v24 = NFSharedLogGetLogger(v23);
      v25 = objc_claimAutoreleasedReturnValue(v24);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        v26 = object_getClass((id)a1);
        if (class_isMetaClass(v26))
          v27 = 43;
        else
          v27 = 45;
        *(_DWORD *)buf = 67109890;
        v31 = v27;
        v32 = 2082;
        v33 = object_getClassName((id)a1);
        v34 = 2082;
        v35 = sel_getName("_handleBackgroundTasks");
        v36 = 1024;
        v37 = 1994;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to attempt Fail Forward recovery - bailing.", buf, 0x22u);
      }

      exit(-1);
    }
  }
}

uint64_t sub_1000EA2AC(void **a1, unsigned int a2)
{
  _BOOL4 v4;
  _BOOL4 v5;
  uint64_t result;
  void *specific;
  uint64_t Logger;
  void (*v9)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  NSObject *v15;
  objc_class *v16;
  int v17;
  const char *ClassName;
  const char *Name;
  uint8_t buf[4];
  int v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  const char *v25;
  __int16 v26;
  int v27;
  __int16 v28;
  unsigned int v29;
  __int16 v30;
  _BOOL4 v31;
  __int16 v32;
  _BOOL4 v33;

  v4 = sub_1000098F0(a1[11]);
  v5 = sub_10000993C(a1[11]);
  result = 1;
  if ((v4 & ~a2 & 1) == 0 && (a2 & v4 & v5 & 1) == 0)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v9 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("sessionsAllowedForTimeConsumingOperations:");
      v12 = 45;
      if (isMetaClass)
        v12 = 43;
      v9(6, "%c[%{public}s %{public}s]:%i sessionTimeConsuming=%d allowSimpleSessions=%d allowTimeConsumingSessions=%d", v12, ClassName, Name, 2470, a2, v4, v5);
    }
    v13 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v14 = NFSharedLogGetLogger(v13);
    v15 = objc_claimAutoreleasedReturnValue(v14);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v16 = object_getClass(a1);
      if (class_isMetaClass(v16))
        v17 = 43;
      else
        v17 = 45;
      *(_DWORD *)buf = 67110658;
      v21 = v17;
      v22 = 2082;
      v23 = object_getClassName(a1);
      v24 = 2082;
      v25 = sel_getName("sessionsAllowedForTimeConsumingOperations:");
      v26 = 1024;
      v27 = 2470;
      v28 = 1024;
      v29 = a2;
      v30 = 1024;
      v31 = v4;
      v32 = 1024;
      v33 = v5;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i sessionTimeConsuming=%d allowSimpleSessions=%d allowTimeConsumingSessions=%d", buf, 0x34u);
    }

    if (a2)
      return v5;
    else
      return v4;
  }
  return result;
}

void sub_1000EA4A4(void *a1, void *a2)
{
  id v3;
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  objc_class *v13;
  int v14;
  void *v15;
  void *v16;
  void *v17;
  id v18;
  os_unfair_lock_s *v19;
  id v20;
  const char *ClassName;
  const char *Name;
  const __CFString *v23;
  id v24;
  uint8_t buf[4];
  int v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  int v32;
  __int16 v33;
  id v34;

  v3 = a2;
  if (objc_msgSend(v3, "length"))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("_updateECPRandomOverride:");
      v9 = 45;
      if (isMetaClass)
        v9 = 43;
      v6(6, "%c[%{public}s %{public}s]:%i %@", v9, ClassName, Name, 8500, v3);
    }
    v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v11 = NFSharedLogGetLogger(v10);
    v12 = objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      v13 = object_getClass(a1);
      if (class_isMetaClass(v13))
        v14 = 43;
      else
        v14 = 45;
      *(_DWORD *)buf = 67110146;
      v26 = v14;
      v27 = 2082;
      v28 = object_getClassName(a1);
      v29 = 2082;
      v30 = sel_getName("_updateECPRandomOverride:");
      v31 = 1024;
      v32 = 8500;
      v33 = 2112;
      v34 = v3;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %@", buf, 0x2Cu);
    }

    v23 = CFSTR("ECPData");
    v24 = v3;
    v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v24, &v23, 1));
    v16 = (void *)objc_claimAutoreleasedReturnValue(+[NFFieldNotification notificationWithDictionary:](NFFieldNotification, "notificationWithDictionary:", v15));

    v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "chRandomData"));
    if (v17)
    {
      v18 = sub_100172E84((uint64_t)NFLPCDRandomGenerator);
      v19 = (os_unfair_lock_s *)objc_claimAutoreleasedReturnValue(v18);
      sub_100172F78(v19, v17);

    }
  }
  else
  {
    v20 = sub_100172E84((uint64_t)NFLPCDRandomGenerator);
    v16 = (void *)objc_claimAutoreleasedReturnValue(v20);
    sub_100173224((uint64_t)v16);
  }

}

id sub_1000EA6F4(uint64_t a1, uint64_t a2, void *a3)
{
  id v5;
  _BOOL8 v6;
  uint64_t v7;
  unsigned __int8 v8;
  id v9;
  void *v10;
  void *specific;
  uint64_t Logger;
  void (*v13)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  NSObject *v19;
  objc_class *v20;
  int v21;
  uint64_t v22;
  void *v23;
  id v25;
  const char *ClassName;
  const char *Name;
  uint8_t buf[4];
  int v29;
  __int16 v30;
  const char *v31;
  __int16 v32;
  const char *v33;
  __int16 v34;
  int v35;
  __int16 v36;
  void *v37;

  v5 = a3;
  if (!a1)
  {
    v23 = 0;
    goto LABEL_26;
  }
  v6 = sub_100041B44(*(_QWORD *)(a1 + 24));
  if (objc_msgSend(*(id *)(a1 + 384), "hasReaderModeSupport")
    && (NFProductIsDevBoard() & 1) == 0
    && (NFProductIsNED() & 1) == 0
    && objc_msgSend((id)a1, "nfcRadioEnabled:showUIPopup:", 0, 0) == (id)1
    && NFIsUIBuild()
    && (!NFProductIsDevBoard() || *(_QWORD *)(a1 + 280) == 1)
    && objc_msgSend(*(id *)(a1 + 408), "isActive")
    && (sub_1000EA2AC((void **)a1, 1u) & 1) != 0)
  {
    v7 = *(_QWORD *)(a1 + 368);
    if (!v7)
    {
      v25 = v5;
      goto LABEL_13;
    }
    v8 = objc_msgSend(*(id *)(v7 + 88), "readerModeProtectionActive");
    v9 = v5;
    if ((v8 & 1) == 0)
    {
LABEL_13:
      v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 408), "getECPFrame"));

      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v13 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass((id)a1);
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName((id)a1);
        Name = sel_getName("defaultRoutingConfig:ecp:");
        v16 = 45;
        if (isMetaClass)
          v16 = 43;
        v13(6, "%c[%{public}s %{public}s]:%i Setting ecp frame for background tag scanning: %{public}@", v16, ClassName, Name, 8531, v10);
      }
      v17 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v18 = NFSharedLogGetLogger(v17);
      v19 = objc_claimAutoreleasedReturnValue(v18);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        v20 = object_getClass((id)a1);
        if (class_isMetaClass(v20))
          v21 = 43;
        else
          v21 = 45;
        *(_DWORD *)buf = 67110146;
        v29 = v21;
        v30 = 2082;
        v31 = object_getClassName((id)a1);
        v32 = 2082;
        v33 = sel_getName("defaultRoutingConfig:ecp:");
        v34 = 1024;
        v35 = 8531;
        v36 = 2114;
        v37 = v10;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Setting ecp frame for background tag scanning: %{public}@", buf, 0x2Cu);
      }

      v22 = 1;
      goto LABEL_25;
    }
  }
  else
  {
    v9 = v5;
  }
  v10 = v9;
  v22 = 0;
LABEL_25:
  v23 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig wantsLPCD:expressForEmbedded:hostCardEmulation:fieldDetect:lpcdEcpFrame:](NFRoutingConfig, "wantsLPCD:expressForEmbedded:hostCardEmulation:fieldDetect:lpcdEcpFrame:", v22, v6, 0, a2, v10));

LABEL_26:
  return v23;
}

void sub_1000EA9A0(void *a1, void *a2)
{
  id v3;
  unsigned int v4;
  id v5;
  void *v6;
  void *v7;
  void *v8;
  void *specific;
  uint64_t Logger;
  void (*v11)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  NSObject *v17;
  objc_class *v18;
  int v19;
  id v20;
  const char *ClassName;
  const char *Name;
  uint8_t buf[4];
  int v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  void *v32;

  v3 = a2;
  v4 = sub_100098AF4((uint64_t)a1);
  v5 = sub_1000EA6F4((uint64_t)a1, v4, v3);
  v6 = (void *)objc_claimAutoreleasedReturnValue(v5);

  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "setRoutingConfig:", v6));
  if (objc_msgSend(v7, "code") == (id)47)
  {
    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "defaultRoutingConfig:", 3));
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v11 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("enableDefaultRoutingWithECP:");
      v14 = 45;
      if (isMetaClass)
        v14 = 43;
      v11(6, "%c[%{public}s %{public}s]:%i Retrying to set routing with mode %{public}@", v14, ClassName, Name, 2019, v8);
    }
    v15 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v16 = NFSharedLogGetLogger(v15);
    v17 = objc_claimAutoreleasedReturnValue(v16);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      v18 = object_getClass(a1);
      if (class_isMetaClass(v18))
        v19 = 43;
      else
        v19 = 45;
      *(_DWORD *)buf = 67110146;
      v24 = v19;
      v25 = 2082;
      v26 = object_getClassName(a1);
      v27 = 2082;
      v28 = sel_getName("enableDefaultRoutingWithECP:");
      v29 = 1024;
      v30 = 2019;
      v31 = 2114;
      v32 = v8;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Retrying to set routing with mode %{public}@", buf, 0x2Cu);
    }

    v20 = objc_msgSend(a1, "setRoutingConfig:", v8);
  }

}

id sub_1000EABBC(id a1, void *a2, void *a3, uint64_t a4, void *a5, void *a6, _BYTE *a7, _QWORD *a8)
{
  id v14;
  _NFReaderSession *v15;
  uint64_t v16;
  id v17;
  id v18;
  void *v19;
  _NFReaderSession *v20;
  id v21;
  void *v22;
  uint64_t v23;
  id v24;
  void *v25;
  void *v26;
  id v27;
  id v28;
  void *v29;
  void *specific;
  uint64_t Logger;
  void (*v32)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v36;
  void *v37;
  uint64_t v38;
  NSObject *v39;
  objc_class *v40;
  int v41;
  id v42;
  void *v43;
  void *v44;
  void *v45;
  id v46;
  int v47;
  void *v48;
  void (*v49)(uint64_t, const char *, ...);
  objc_class *v50;
  uint64_t v51;
  const char *v52;
  const char *v53;
  void *v54;
  uint64_t v55;
  NSObject *v56;
  objc_class *v57;
  int v58;
  const char *v59;
  const char *v60;
  id v61;
  void *v62;
  void *v63;
  void *v64;
  void *v65;
  void *v66;
  const char *Name;
  id v70;
  id v71;
  id v72;
  _QWORD v73[6];
  NSErrorUserInfoKey v74;
  void *v75;
  _QWORD v76[4];
  _QWORD v77[4];
  NSErrorUserInfoKey v78;
  void *v79;
  uint8_t buf[4];
  int v81;
  __int16 v82;
  const char *v83;
  __int16 v84;
  const char *v85;
  __int16 v86;
  int v87;

  v71 = a2;
  v14 = a3;
  v72 = a5;
  v70 = a6;
  if (a1)
  {
    v15 = [_NFReaderSession alloc];
    v16 = *((_QWORD *)a1 + 29);
    v17 = objc_msgSend(v14, "uiMode");
    v18 = objc_msgSend(v14, "sessionType");
    v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "initialScanText"));
    v20 = -[_NFReaderSession initWithRemoteObject:workQueue:whitelist:serviceType:showSharingUI:coreNFCSessionType:scanText:](v15, "initWithRemoteObject:workQueue:whitelist:serviceType:showSharingUI:coreNFCSessionType:scanText:", v71, v16, v72, a4, v17, v18, v19);

    if (!v20)
    {
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v32 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(a1);
        Name = sel_getName("_queueHelperReaderSession:sessionConfig:serviceType:whitelist:xpcConnection:isFirstInQueue:outSession:");
        v36 = 45;
        if (isMetaClass)
          v36 = 43;
        v32(3, "%c[%{public}s %{public}s]:%i Session creation failed.", v36, ClassName, Name, 2041);
      }
      v37 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v38 = NFSharedLogGetLogger(v37);
      v39 = objc_claimAutoreleasedReturnValue(v38);
      if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
      {
        v40 = object_getClass(a1);
        if (class_isMetaClass(v40))
          v41 = 43;
        else
          v41 = 45;
        *(_DWORD *)buf = 67109890;
        v81 = v41;
        v82 = 2082;
        v83 = object_getClassName(a1);
        v84 = 2082;
        v85 = sel_getName("_queueHelperReaderSession:sessionConfig:serviceType:whitelist:xpcConnection:isFirstInQueue:outSession:");
        v86 = 1024;
        v87 = 2041;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session creation failed.", buf, 0x22u);
      }

      v42 = objc_alloc((Class)NSError);
      v43 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v78 = NSLocalizedDescriptionKey;
      v44 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unexpected Result"));
      v79 = v44;
      v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v79, &v78, 1));
      a1 = objc_msgSend(v42, "initWithDomain:code:userInfo:", v43, 13, v45);

      goto LABEL_36;
    }
    -[_NFSession setQueue:](v20, "setQueue:", a1);
    -[_NFXPCSession setConnection:](v20, "setConnection:", v70);
    -[_NFSession setUid:](v20, "setUid:", 0xFFFFFFFFLL);
    v21 = sub_10019C0D0((uint64_t)NFSystemPowerConsumptionMonitor);
    v22 = (void *)objc_claimAutoreleasedReturnValue(v21);
    -[_NFReaderSession setPowerConsumptionReporter:](v20, "setPowerConsumptionReporter:", v22);

    if (objc_msgSend(v14, "uiMode"))
    {
      v73[0] = _NSConcreteStackBlock;
      v73[1] = 3221225472;
      v73[2] = sub_1000EB368;
      v73[3] = &unk_1002E8208;
      v73[4] = a1;
      v73[5] = "_queueHelperReaderSession:sessionConfig:serviceType:whitelist:xpcConnection:isFirstInQueue:outSession:";
      -[_NFReaderSession setUiInvalidationHandler:](v20, "setUiInvalidationHandler:", v73);
    }
    -[_NFSession setServiceType:](v20, "setServiceType:", a4);
    -[_NFReaderSession setDriverWrapper:](v20, "setDriverWrapper:", *((_QWORD *)a1 + 46));
    *a7 = 0;
    v23 = *((_QWORD *)a1 + 46);
    if (v23 && objc_msgSend(*(id *)(v23 + 88), "readerModeProtectionActive"))
    {
      v24 = objc_alloc((Class)NSError);
      v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v76[0] = NSLocalizedDescriptionKey;
      v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Reader mode temporarily disabled"));
      v77[0] = v26;
      v77[1] = &off_1002FEE80;
      v76[1] = CFSTR("Line");
      v76[2] = CFSTR("Method");
      v27 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_queueHelperReaderSession:sessionConfig:serviceType:whitelist:xpcConnection:isFirstInQueue:outSession:"));
      v77[2] = v27;
      v76[3] = NSDebugDescriptionErrorKey;
      v28 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_queueHelperReaderSession:sessionConfig:serviceType:whitelist:xpcConnection:isFirstInQueue:outSession:"), 2073);
      v77[3] = v28;
      v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v77, v76, 4));
      a1 = objc_msgSend(v24, "initWithDomain:code:userInfo:", v25, 47, v29);

    }
    else
    {
      v46 = *((id *)a1 + 23);
      objc_sync_enter(v46);
      if (-[_NFReaderSession timeLimitedSession](v20, "timeLimitedSession"))
      {
        v47 = *((_DWORD *)a1 + 80);
        if (v47 >= 1)
        {
          v48 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v49 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v48);
          if (v49)
          {
            v50 = object_getClass(a1);
            if (class_isMetaClass(v50))
              v51 = 43;
            else
              v51 = 45;
            v52 = object_getClassName(a1);
            v53 = sel_getName("_queueHelperReaderSession:sessionConfig:serviceType:whitelist:xpcConnection:isFirstInQueue:outSession:");
            v49(6, "%c[%{public}s %{public}s]:%i MaxReaderSession reached.", v51, v52, v53, 2081);
          }
          v54 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v55 = NFSharedLogGetLogger(v54);
          v56 = objc_claimAutoreleasedReturnValue(v55);
          if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
          {
            v57 = object_getClass(a1);
            if (class_isMetaClass(v57))
              v58 = 43;
            else
              v58 = 45;
            v59 = object_getClassName(a1);
            v60 = sel_getName("_queueHelperReaderSession:sessionConfig:serviceType:whitelist:xpcConnection:isFirstInQueue:outSession:");
            *(_DWORD *)buf = 67109890;
            v81 = v58;
            v82 = 2082;
            v83 = v59;
            v84 = 2082;
            v85 = v60;
            v86 = 1024;
            v87 = 2081;
            _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i MaxReaderSession reached.", buf, 0x22u);
          }

          v61 = objc_alloc((Class)NSError);
          v62 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
          v74 = NSLocalizedDescriptionKey;
          v63 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Busy"));
          v75 = v63;
          v64 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v75, &v74, 1));
          a1 = objc_msgSend(v61, "initWithDomain:code:userInfo:", v62, 2, v64);

          objc_sync_exit(v46);
          goto LABEL_36;
        }
        *((_DWORD *)a1 + 80) = v47 + 1;
      }
      v65 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v70, "NF_userInfo"));
      v66 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v65, "objectForKeyedSubscript:", CFSTR("ProxyObjects")));
      objc_msgSend(v66, "addObject:", v20);

      if (*((_QWORD *)a1 + 14) || objc_msgSend(*((id *)a1 + 23), "count"))
      {
        *a7 = 0;
      }
      else
      {
        *a7 = 1;
        sub_1000DBE28(a1, 1);
      }
      objc_msgSend(*((id *)a1 + 23), "addObject:", v20);
      objc_sync_exit(v46);

      a1 = 0;
      *a8 = objc_retainAutorelease(v20);
    }
LABEL_36:

  }
  return a1;
}

void sub_1000EB340(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000EB368(uint64_t a1, void *a2)
{
  id v3;
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  NSObject *v15;
  objc_class *v16;
  int v17;
  const char *v18;
  const char *v19;
  void *v20;
  uint8_t buf[4];
  int v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  void *v30;

  v3 = a2;
  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v6 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 40));
    v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "sessionUID"));
    v12 = 45;
    if (isMetaClass)
      v12 = 43;
    v6(6, "%c[%{public}s %{public}s]:%i Got invalidation handler (session %@)", v12, ClassName, Name, 2058, v11);

  }
  v13 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v14 = NFSharedLogGetLogger(v13);
  v15 = objc_claimAutoreleasedReturnValue(v14);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    v16 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v16))
      v17 = 43;
    else
      v17 = 45;
    v18 = object_getClassName(*(id *)(a1 + 32));
    v19 = sel_getName(*(SEL *)(a1 + 40));
    v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v22 = v17;
    v23 = 2082;
    v24 = v18;
    v25 = 2082;
    v26 = v19;
    v27 = 1024;
    v28 = 2058;
    v29 = 2112;
    v30 = v20;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Got invalidation handler (session %@)", buf, 0x2Cu);

  }
  if (objc_msgSend(v3, "didEnd"))
    sub_1000EB548(*(_QWORD *)(a1 + 32));

}

void sub_1000EB548(uint64_t a1)
{
  uint64_t v2;
  void *specific;
  uint64_t Logger;
  void (*v5)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  objc_class *v13;
  int v14;
  const char *Name;
  uint8_t buf[4];
  int v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;

  if (a1)
  {
    v2 = *(_QWORD *)(a1 + 304);
    if (v2)
    {
      *(_QWORD *)(a1 + 304) = v2 - 1;
      objc_msgSend(*(id *)(a1 + 408), "resume");
    }
    else
    {
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v5 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass((id)a1);
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName((id)a1);
        Name = sel_getName("resumeReaderSessionStart");
        v9 = 45;
        if (isMetaClass)
          v9 = 43;
        v5(3, "%c[%{public}s %{public}s]:%i Suspend count underflow", v9, ClassName, Name, 8808);
      }
      v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v11 = NFSharedLogGetLogger(v10);
      v12 = objc_claimAutoreleasedReturnValue(v11);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        v13 = object_getClass((id)a1);
        if (class_isMetaClass(v13))
          v14 = 43;
        else
          v14 = 45;
        *(_DWORD *)buf = 67109890;
        v17 = v14;
        v18 = 2082;
        v19 = object_getClassName((id)a1);
        v20 = 2082;
        v21 = sel_getName("resumeReaderSessionStart");
        v22 = 1024;
        v23 = 8808;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Suspend count underflow", buf, 0x22u);
      }

    }
  }
}

void sub_1000EB710(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  objc_class *v13;
  int v14;
  const char *v15;
  const char *v16;
  uint64_t v17;
  uint8_t buf[4];
  int v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  uint64_t v27;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v9 = 45;
    if (isMetaClass)
      v9 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i Resume reader activity after expiration of %@", v9, ClassName, Name, 2132, *(_QWORD *)(a1 + 40));
  }
  v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v11 = NFSharedLogGetLogger(v10);
  v12 = objc_claimAutoreleasedReturnValue(v11);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    v13 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v13))
      v14 = 43;
    else
      v14 = 45;
    v15 = object_getClassName(*(id *)(a1 + 32));
    v16 = sel_getName(*(SEL *)(a1 + 48));
    v17 = *(_QWORD *)(a1 + 40);
    *(_DWORD *)buf = 67110146;
    v19 = v14;
    v20 = 2082;
    v21 = v15;
    v22 = 2082;
    v23 = v16;
    v24 = 1024;
    v25 = 2132;
    v26 = 2112;
    v27 = v17;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Resume reader activity after expiration of %@", buf, 0x2Cu);
  }

  sub_1000EB548(*(_QWORD *)(a1 + 32));
}

void sub_1000EB8A8(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  objc_class *v13;
  int v14;
  const char *v15;
  const char *v16;
  uint64_t v17;
  uint8_t buf[4];
  int v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  uint64_t v27;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v9 = 45;
    if (isMetaClass)
      v9 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i Resume reader activity after delay (session %@)", v9, ClassName, Name, 2264, *(_QWORD *)(a1 + 40));
  }
  v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v11 = NFSharedLogGetLogger(v10);
  v12 = objc_claimAutoreleasedReturnValue(v11);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    v13 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v13))
      v14 = 43;
    else
      v14 = 45;
    v15 = object_getClassName(*(id *)(a1 + 32));
    v16 = sel_getName(*(SEL *)(a1 + 48));
    v17 = *(_QWORD *)(a1 + 40);
    *(_DWORD *)buf = 67110146;
    v19 = v14;
    v20 = 2082;
    v21 = v15;
    v22 = 2082;
    v23 = v16;
    v24 = 1024;
    v25 = 2264;
    v26 = 2112;
    v27 = v17;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Resume reader activity after delay (session %@)", buf, 0x2Cu);
  }

  sub_1000EB548(*(_QWORD *)(a1 + 32));
}

void sub_1000EBE90(uint64_t a1)
{
  void *specific;
  void (*Logger)(uint64_t, const char *, ...);
  void *v4;
  uint64_t v5;
  NSObject *v6;
  uint8_t buf[4];
  const char *v8;
  __int16 v9;
  int v10;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(specific);
  if (Logger)
    Logger(6, "%s:%i Unregistering key bag handler after unlock", "-[_NFHardwareManager lockStateChanged]_block_invoke", 2540);
  v4 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v5 = NFSharedLogGetLogger(v4);
  v6 = objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446466;
    v8 = "-[_NFHardwareManager lockStateChanged]_block_invoke";
    v9 = 1024;
    v10 = 2540;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s:%i Unregistering key bag handler after unlock", buf, 0x12u);
  }

  sub_1001EB470(*(void **)(*(_QWORD *)(a1 + 32) + 88));
}

id sub_1000EBF98(uint64_t a1)
{
  void *specific;
  void (*Logger)(uint64_t, const char *, ...);
  void *v4;
  uint64_t v5;
  NSObject *v6;
  uint8_t buf[4];
  const char *v9;
  __int16 v10;
  int v11;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(specific);
  if (Logger)
    Logger(6, "%s:%i Lock state changed", "-[_NFHardwareManager lockStateChanged]_block_invoke", 2548);
  v4 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v5 = NFSharedLogGetLogger(v4);
  v6 = objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446466;
    v9 = "-[_NFHardwareManager lockStateChanged]_block_invoke";
    v10 = 1024;
    v11 = 2548;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s:%i Lock state changed", buf, 0x12u);
  }

  return objc_msgSend(*(id *)(a1 + 32), "maybeStartNextSession");
}

void sub_1000EC09C(void *a1, int a2, uint64_t a3)
{
  void *specific;
  uint64_t Logger;
  void (*v7)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  id *v17;
  uint64_t v18;
  void *v19;
  NSMutableDictionary *v20;
  NSNumber *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  NSObject *v28;
  _BYTE *v29;
  void *v30;
  id v31;
  void *v32;
  id v33;
  id *v34;
  void *v35;
  id v36;
  id v37;
  uint64_t v38;
  void *i;
  const char *ClassName;
  const char *Name;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  _QWORD v46[5];
  uint8_t v47[128];
  uint8_t buf[4];
  int v49;
  __int16 v50;
  const char *v51;
  __int16 v52;
  const char *v53;
  __int16 v54;
  int v55;
  __int16 v56;
  uint64_t v57;

  if (a1)
  {
    if ((a3 & 0xFFFFFFFFFFFFFFFDLL) != 0)
    {
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v7 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(a1);
        Name = sel_getName("processRestrictedModeState:os:");
        v10 = 45;
        if (isMetaClass)
          v10 = 43;
        v7(6, "%c[%{public}s %{public}s]:%i Ignoring restricted mode for %ld", v10, ClassName, Name, 2592, a3);
      }
      v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v12 = NFSharedLogGetLogger(v11);
      v13 = objc_claimAutoreleasedReturnValue(v12);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        v14 = object_getClass(a1);
        if (class_isMetaClass(v14))
          v15 = 43;
        else
          v15 = 45;
        *(_DWORD *)buf = 67110146;
        v49 = v15;
        v50 = 2082;
        v51 = object_getClassName(a1);
        v52 = 2082;
        v53 = sel_getName("processRestrictedModeState:os:");
        v54 = 1024;
        v55 = 2592;
        v56 = 2048;
        v57 = a3;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Ignoring restricted mode for %ld", buf, 0x2Cu);
      }
    }
    else
    {
      v17 = a1;
      objc_sync_enter(v17);
      if (*((_BYTE *)v17 + 345))
      {
        objc_sync_exit(v17);

      }
      else
      {
        *((_BYTE *)v17 + 345) = 1;
        objc_sync_exit(v17);

        if (a2 == 1)
        {
          objc_msgSend(v17[5], "_setIsInRestrictedMode:", 1);
          v18 = objc_claimAutoreleasedReturnValue(objc_msgSend(v17[5], "platformIdentifier"));
          if (v18)
          {
            v19 = (void *)v18;
            v20 = objc_opt_new(NSMutableDictionary);
            v21 = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", sub_1000DFCAC((uint64_t)v17));
            v22 = (void *)objc_claimAutoreleasedReturnValue(v21);
            -[NSMutableDictionary setObject:forKeyedSubscript:](v20, "setObject:forKeyedSubscript:", v22, CFSTR("hardwareType"));

            v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "lastKnownRoutingConfig"));
            v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", objc_msgSend(v23, "embeddedMode") == (id)2));
            -[NSMutableDictionary setObject:forKeyedSubscript:](v20, "setObject:forKeyedSubscript:", v24, CFSTR("contactless"));

            -[NSMutableDictionary setObject:forKeyedSubscript:](v20, "setObject:forKeyedSubscript:", v19, CFSTR("platformIdentifier"));
            +[NFExceptionsCALogger postAnalyticsSERestrictedModeEntered:](NFExceptionsCALogger, "postAnalyticsSERestrictedModeEntered:", v20);

          }
        }
        if (!*((_BYTE *)v17 + 347))
        {
          *((_BYTE *)v17 + 347) = 1;
          v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSDistributedNotificationCenter defaultCenter](NSDistributedNotificationCenter, "defaultCenter"));
          objc_msgSend(v25, "postNotificationName:object:userInfo:options:", CFSTR("com.apple.nfcd.se.restricted"), 0, 0, 3);

          v27 = NFSharedSignpostLog(v26);
          v28 = objc_claimAutoreleasedReturnValue(v27);
          if (os_signpost_enabled(v28))
          {
            *(_WORD *)buf = 0;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v28, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SE_RESTRICTED_NOTIFICATION", "com.apple.nfcd.se.restricted", buf, 2u);
          }

        }
        v29 = v17[3];
        if (v29 && v29[172])
        {
          sub_10003DA78(v29);
          v30 = (void *)objc_claimAutoreleasedReturnValue(+[NFPowerAssertion sharedPowerAssertion](NFPowerAssertion, "sharedPowerAssertion"));
          objc_msgSend(v30, "releasePowerAssertion:", CFSTR("ExpressMode"));

        }
        v31 = v17[29];
        v32 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig embeddedWiredMode](NFRoutingConfig, "embeddedWiredMode"));
        v46[0] = _NSConcreteStackBlock;
        v46[1] = 3221225472;
        v46[2] = sub_1000EC560;
        v46[3] = &unk_1002E5C58;
        v46[4] = v17;
        v33 = +[_NFBuiltinSession createSessionWithWorkQueue:routing:sessionQueuer:didStartWork:](_NFBuiltinSession, "createSessionWithWorkQueue:routing:sessionQueuer:didStartWork:", v31, v32, v17, v46);

      }
      v34 = sub_100007A04(v17);
      v13 = objc_claimAutoreleasedReturnValue(v34);
      v42 = 0u;
      v43 = 0u;
      v44 = 0u;
      v45 = 0u;
      v35 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject allValues](v13, "allValues"));
      v36 = objc_msgSend(v35, "countByEnumeratingWithState:objects:count:", &v42, v47, 16);
      if (v36)
      {
        v37 = v36;
        v38 = *(_QWORD *)v43;
        do
        {
          for (i = 0; i != v37; i = (char *)i + 1)
          {
            if (*(_QWORD *)v43 != v38)
              objc_enumerationMutation(v35);
            objc_msgSend(*(id *)(*((_QWORD *)&v42 + 1) + 8 * (_QWORD)i), "secureElementWithIdentifier:didChangeRestrictedMode:", CFSTR("embedded"), 1);
          }
          v37 = objc_msgSend(v35, "countByEnumeratingWithState:objects:count:", &v42, v47, 16);
        }
        while (v37);
      }

    }
  }
}

void sub_1000EC560(uint64_t a1)
{
  sub_1000E0AA0(*(void ***)(a1 + 32));
}

void sub_1000EC568(void *a1, void *a2, void *a3)
{
  id v5;
  void *specific;
  uint64_t Logger;
  void (*v8)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  objc_class *v15;
  int v16;
  id v17;
  void *v18;
  id v19;
  void *v20;
  uint64_t v21;
  void (*v22)(uint64_t, const char *, ...);
  objc_class *v23;
  _BOOL4 v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  NSObject *v28;
  objc_class *v29;
  int v30;
  const char *v31;
  const char *v32;
  void *v33;
  void *v34;
  const char *ClassName;
  const char *v36;
  const char *Name;
  const char *v38;
  uint8_t buf[4];
  int v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  const char *v44;
  __int16 v45;
  int v46;
  __int16 v47;
  id v48;

  v5 = a3;
  if (a1)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v8 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("_postEvent:identifier:additionalData:");
      v11 = 45;
      if (isMetaClass)
        v11 = 43;
      v8(6, "%c[%{public}s %{public}s]:%i posting notification: %s with additional data.", v11, ClassName, Name, 2683, a2);
    }
    v12 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v13 = NFSharedLogGetLogger(v12);
    v14 = objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      v15 = object_getClass(a1);
      if (class_isMetaClass(v15))
        v16 = 43;
      else
        v16 = 45;
      *(_DWORD *)buf = 67110146;
      v40 = v16;
      v41 = 2082;
      v42 = object_getClassName(a1);
      v43 = 2082;
      v44 = sel_getName("_postEvent:identifier:additionalData:");
      v45 = 1024;
      v46 = 2683;
      v47 = 2080;
      v48 = a2;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i posting notification: %s with additional data.", buf, 0x2Cu);
    }

    v17 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", a2);
    v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSDistributedNotificationCenter defaultCenter](NSDistributedNotificationCenter, "defaultCenter"));
    objc_msgSend(v18, "postNotificationName:object:userInfo:options:", v17, v5, 0, 3);

    v19 = objc_alloc_init((Class)NSMutableDictionary);
    objc_msgSend(v19, "setObject:forKeyedSubscript:", v17, CFSTR("xpcEventName"));
    objc_msgSend(v19, "setObject:forKeyedSubscript:", v5, CFSTR("xpcEventSimpleString"));
    v20 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v21 = NFLogGetLogger(v20);
    if (v21)
    {
      v22 = (void (*)(uint64_t, const char *, ...))v21;
      v23 = object_getClass(a1);
      v24 = class_isMetaClass(v23);
      v36 = object_getClassName(a1);
      v38 = sel_getName("_postEvent:identifier:additionalData:");
      v25 = 45;
      if (v24)
        v25 = 43;
      v22(6, "%c[%{public}s %{public}s]:%i XpcPayload %{public}@", v25, v36, v38, 2700, v19);
    }
    v26 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v27 = NFSharedLogGetLogger(v26);
    v28 = objc_claimAutoreleasedReturnValue(v27);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      v29 = object_getClass(a1);
      if (class_isMetaClass(v29))
        v30 = 43;
      else
        v30 = 45;
      v31 = object_getClassName(a1);
      v32 = sel_getName("_postEvent:identifier:additionalData:");
      *(_DWORD *)buf = 67110146;
      v40 = v30;
      v41 = 2082;
      v42 = v31;
      v43 = 2082;
      v44 = v32;
      v45 = 1024;
      v46 = 2700;
      v47 = 2114;
      v48 = v19;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i XpcPayload %{public}@", buf, 0x2Cu);
    }

    v33 = (void *)objc_claimAutoreleasedReturnValue(+[NFSecureXPCEventPublisherManager sharedManager](NFSecureXPCEventPublisherManager, "sharedManager"));
    v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v33, "wallet"));
    objc_msgSend(v34, "sendDictionary:", v19);

  }
}

void sub_1000EC8E8(void *a1, uint64_t a2, void *a3)
{
  id v5;
  void *specific;
  uint64_t Logger;
  void (*v8)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  objc_class *v15;
  int v16;
  id v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  const char *ClassName;
  const char *Name;
  uint8_t buf[4];
  int v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  uint64_t v33;

  v5 = a3;
  if (a1)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v8 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("_postEvent:objectString:");
      v11 = 45;
      if (isMetaClass)
        v11 = 43;
      v8(6, "%c[%{public}s %{public}s]:%i posting notification: %s", v11, ClassName, Name, 2707, a2);
    }
    v12 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v13 = NFSharedLogGetLogger(v12);
    v14 = objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      v15 = object_getClass(a1);
      if (class_isMetaClass(v15))
        v16 = 43;
      else
        v16 = 45;
      *(_DWORD *)buf = 67110146;
      v25 = v16;
      v26 = 2082;
      v27 = object_getClassName(a1);
      v28 = 2082;
      v29 = sel_getName("_postEvent:objectString:");
      v30 = 1024;
      v31 = 2707;
      v32 = 2080;
      v33 = a2;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i posting notification: %s", buf, 0x2Cu);
    }

    v17 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", a2);
    v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSDistributedNotificationCenter defaultCenter](NSDistributedNotificationCenter, "defaultCenter"));
    objc_msgSend(v18, "postNotificationName:object:userInfo:options:", v17, v5, 0, 3);

    v19 = (void *)objc_claimAutoreleasedReturnValue(+[NFSecureXPCEventPublisherManager sharedManager](NFSecureXPCEventPublisherManager, "sharedManager"));
    v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v19, "wallet"));
    v21 = v20;
    if (v5)
      objc_msgSend(v20, "sendSimpleEvent:objectString:", v17, v5);
    else
      objc_msgSend(v20, "sendSimpleEvent:", v17);

  }
}

uint64_t sub_1000ECE40(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  char isKindOfClass;
  void *v9;

  v3 = a2;
  v4 = v3;
  if (a1)
  {
    if ((!v3 || (v5 = objc_opt_class(NSDictionary), (objc_opt_isKindOfClass(v4, v5) & 1) != 0))
      && (v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "objectForKeyedSubscript:", CFSTR("session.prevent.ui.popup.on.radio.disabled"))), v7 = objc_opt_class(NSNumber), isKindOfClass = objc_opt_isKindOfClass(v6, v7), v6, (isKindOfClass & 1) != 0))
    {
      v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "objectForKeyedSubscript:", CFSTR("session.prevent.ui.popup.on.radio.disabled")));
      a1 = objc_msgSend(v9, "BOOLValue") ^ 1;

    }
    else
    {
      a1 = 0;
    }
  }

  return a1;
}

NSMutableArray *sub_1000ECF00(uint64_t a1, void *a2)
{
  id v3;
  id v4;
  id v5;
  id v6;
  uint64_t v7;
  void *i;
  void *v9;
  uint64_t v10;
  void *v11;
  void *v12;
  NSMutableArray *v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  _QWORD v19[2];
  _QWORD v20[2];
  _BYTE v21[128];

  v3 = a2;
  if (a1)
  {
    v14 = objc_opt_new(NSMutableArray);
    if (objc_msgSend(v3, "count"))
    {
      v17 = 0u;
      v18 = 0u;
      v15 = 0u;
      v16 = 0u;
      v4 = v3;
      v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v15, v21, 16);
      if (v5)
      {
        v6 = v5;
        v7 = *(_QWORD *)v16;
        do
        {
          for (i = 0; i != v6; i = (char *)i + 1)
          {
            if (*(_QWORD *)v16 != v7)
              objc_enumerationMutation(v4);
            v9 = *(void **)(*((_QWORD *)&v15 + 1) + 8 * (_QWORD)i);
            v10 = objc_opt_class(NSData);
            if ((objc_opt_isKindOfClass(v9, v10) & 1) != 0 && objc_msgSend(v9, "length"))
            {
              v19[0] = CFSTR("ECPData");
              v19[1] = CFSTR("IgnoreRFTechOnIsEqual");
              v20[0] = v9;
              v20[1] = &off_1002FEE38;
              v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v20, v19, 2));
              v12 = (void *)objc_claimAutoreleasedReturnValue(+[NFFieldNotification notificationWithDictionary:](NFFieldNotification, "notificationWithDictionary:", v11));

              if (v12)
                -[NSMutableArray addObject:](v14, "addObject:", v12);

            }
          }
          v6 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v15, v21, 16);
        }
        while (v6);
      }

    }
  }
  else
  {
    v14 = 0;
  }

  return v14;
}

void sub_1000ED1B4(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  objc_class *v13;
  int v14;
  const char *v15;
  const char *v16;
  uint64_t v17;
  void *v18;
  uint8_t buf[4];
  int v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  uint64_t v28;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v9 = 45;
    if (isMetaClass)
      v9 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i Refresh express setting due to domain change=%@", v9, ClassName, Name, 2807, *(_QWORD *)(a1 + 40));
  }
  v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v11 = NFSharedLogGetLogger(v10);
  v12 = objc_claimAutoreleasedReturnValue(v11);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    v13 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v13))
      v14 = 43;
    else
      v14 = 45;
    v15 = object_getClassName(*(id *)(a1 + 32));
    v16 = sel_getName(*(SEL *)(a1 + 48));
    v17 = *(_QWORD *)(a1 + 40);
    *(_DWORD *)buf = 67110146;
    v20 = v14;
    v21 = 2082;
    v22 = v15;
    v23 = 2082;
    v24 = v16;
    v25 = 1024;
    v26 = 2807;
    v27 = 2112;
    v28 = v17;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Refresh express setting due to domain change=%@", buf, 0x2Cu);
  }

  sub_10004BD90(*(unsigned __int8 **)(*(_QWORD *)(a1 + 32) + 24));
  v18 = (void *)objc_claimAutoreleasedReturnValue(+[_NFHardwareManager sharedHardwareManager](_NFHardwareManager, "sharedHardwareManager"));
  objc_msgSend(v18, "maybeStartNextSession");

}

void sub_1000ED3E8(uint64_t a1)
{
  uint64_t v2;
  id v3;
  void *v4;
  void *v5;
  void *v6;
  id v7;
  NSErrorUserInfoKey v8;
  void *v9;

  if (-[_NFHardwareManager getPrimaryHardwareState]_0(*(_QWORD *)(a1 + 32)) == 2
    || -[_NFHardwareManager getPrimaryHardwareState]_0(*(_QWORD *)(a1 + 32)) == 5)
  {
    (*(void (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), *(_QWORD *)(*(_QWORD *)(a1 + 32) + 384), 0);
  }
  else
  {
    v2 = *(_QWORD *)(a1 + 40);
    v3 = objc_alloc((Class)NSError);
    v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v8 = NSLocalizedDescriptionKey;
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
    v9 = v5;
    v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v9, &v8, 1));
    v7 = objc_msgSend(v3, "initWithDomain:code:userInfo:", v4, 58, v6);
    (*(void (**)(uint64_t, _QWORD, id))(v2 + 16))(v2, 0, v7);

  }
}

void sub_1000ED5DC(uint64_t a1)
{
  uint64_t v1;
  void (**v2)(_QWORD, _QWORD, _QWORD, _QWORD);
  uint64_t v3;
  void (**v4)(_QWORD, _QWORD, _QWORD, _QWORD);
  _BOOL8 v5;
  NSMutableDictionary *v6;
  id v7;

  v1 = *(_QWORD *)(a1 + 32);
  if (v1)
  {
    v2 = *(void (***)(_QWORD, _QWORD, _QWORD, _QWORD))(a1 + 40);
    v3 = *(_QWORD *)(v1 + 24);
    v4 = v2;
    if (v3)
      v3 = *(_QWORD *)(v3 + 136);
    v5 = sub_100041B44(*(_QWORD *)(v1 + 24));
    v6 = sub_100048378(*(_QWORD *)(v1 + 24));
    v7 = (id)objc_claimAutoreleasedReturnValue(v6);
    ((void (**)(_QWORD, uint64_t, _BOOL8, id))v2)[2](v4, v3, v5, v7);

  }
}

BOOL sub_1000EDC64(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  objc_class *v13;
  int v14;
  const char *v15;
  const char *v16;
  uint64_t v17;
  id v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  id v22;
  void *v23;
  id v24;
  uint64_t v25;
  id v26;
  void *v27;
  id v28;
  id v29;
  void *v30;
  void *v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  id v35;
  uint64_t v36;
  void *v37;
  _QWORD v39[5];
  _QWORD v40[5];
  _QWORD v41[4];
  _QWORD v42[4];
  uint8_t buf[4];
  int v44;
  __int16 v45;
  const char *v46;
  __int16 v47;
  const char *v48;
  __int16 v49;
  int v50;
  __int16 v51;
  uint64_t v52;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    v9 = 45;
    if (isMetaClass)
      v9 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i Requested to set AID to %@", v9, ClassName, Name, 2884, *(_QWORD *)(a1 + 40));
  }
  v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v11 = NFSharedLogGetLogger(v10);
  v12 = objc_claimAutoreleasedReturnValue(v11);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    v13 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v13))
      v14 = 43;
    else
      v14 = 45;
    v15 = object_getClassName(*(id *)(a1 + 32));
    v16 = sel_getName(*(SEL *)(a1 + 56));
    v17 = *(_QWORD *)(a1 + 40);
    *(_DWORD *)buf = 67110146;
    v44 = v14;
    v45 = 2082;
    v46 = v15;
    v47 = 2082;
    v48 = v16;
    v49 = 1024;
    v50 = 2884;
    v51 = 2112;
    v52 = v17;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Requested to set AID to %@", buf, 0x2Cu);
  }

  v18 = sub_1001CC114(*(void **)(*(_QWORD *)(a1 + 32) + 368), *(void **)(a1 + 40));
  v19 = objc_claimAutoreleasedReturnValue(v18);
  v20 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
  v21 = *(void **)(v20 + 40);
  *(_QWORD *)(v20 + 40) = v19;

  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40))
  {
    v22 = objc_alloc((Class)NSError);
    v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v24 = objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40), "code");
    v39[0] = NSLocalizedDescriptionKey;
    if ((uint64_t)objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40), "code") > 70)
      v25 = 71;
    else
      v25 = (uint64_t)objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40), "code");
    v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E7F70[v25]));
    v39[1] = NSUnderlyingErrorKey;
    v34 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40);
    v40[0] = v27;
    v40[1] = v34;
    v40[2] = &off_1002FEEB0;
    v39[2] = CFSTR("Line");
    v39[3] = CFSTR("Method");
    v28 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v40[3] = v28;
    v39[4] = NSDebugDescriptionErrorKey;
    v29 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 2892);
    v40[4] = v29;
    v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v40, v39, 5));
    v31 = v22;
    v32 = v23;
    v33 = (uint64_t)v24;
    goto LABEL_17;
  }
  if ((sub_1001FB970(*(void **)(*(_QWORD *)(a1 + 32) + 368)) & 1) == 0)
  {
    v26 = objc_alloc((Class)NSError);
    v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v41[0] = NSLocalizedDescriptionKey;
    v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
    v42[0] = v27;
    v42[1] = &off_1002FEE98;
    v41[1] = CFSTR("Line");
    v41[2] = CFSTR("Method");
    v28 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v42[2] = v28;
    v41[3] = NSDebugDescriptionErrorKey;
    v29 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 2889);
    v42[3] = v29;
    v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v42, v41, 4));
    v31 = v26;
    v32 = v23;
    v33 = 15;
LABEL_17:
    v35 = objc_msgSend(v31, "initWithDomain:code:userInfo:", v32, v33, v30);
    v36 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
    v37 = *(void **)(v36 + 40);
    *(_QWORD *)(v36 + 40) = v35;

  }
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40) == 0;
}

void sub_1000EE1D0(uint64_t a1)
{
  void **v1;
  void *v2;
  id v3;
  void (**v4)(id, _QWORD);
  void *v5;
  uint64_t v6;
  id v7;
  uint64_t *v8;
  const char *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t (*v13)(uint64_t, uint64_t);
  void (*v14)(uint64_t);
  id v15;

  v1 = *(void ***)(a1 + 32);
  v2 = *(void **)(a1 + 48);
  v3 = *(id *)(a1 + 40);
  v4 = v2;
  if (v1)
  {
    v10 = 0;
    v11 = &v10;
    v12 = 0x3032000000;
    v13 = sub_1000E3C80;
    v14 = sub_1000E3C90;
    v15 = 0;
    v9 = "_sync_setAntiRelay:completion:";
    v7 = v3;
    v8 = &v10;
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig routingOffWithFD:](NFRoutingConfig, "routingOffWithFD:", 0, _NSConcreteStackBlock, 3221225472, sub_1000EDC64, &unk_1002E8230, v1));
    sub_1000E3CEC(v1, &v6, CFSTR("Anti relay"), v5);

    v4[2](v4, v11[5]);
    _Block_object_dispose(&v10, 8);

  }
}

void sub_1000EE2F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000EE384(uint64_t a1)
{
  uint64_t v1;
  id v2;
  NSMutableDictionary *v3;
  uint64_t v4;
  void *specific;
  uint64_t Logger;
  void (*v7)(uint64_t, const char *, ...);
  objc_class *Class;
  uint64_t v9;
  const char *ClassName;
  const char *Name;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  NSObject *v16;
  objc_class *v17;
  int v18;
  const char *v19;
  const char *v20;
  int v21;
  uint64_t v22;
  id v23;
  void *v24;
  void *v25;
  id v26;
  id v27;
  void *v28;
  void *v29;
  void *v30;
  uint64_t v31;
  id v32;
  id v33;
  id v34;
  void *v35;
  char v36;
  id v37;
  void *v38;
  NSString *v39;
  __CFString *v40;
  NSString *v41;
  void *v42;
  id v43;
  _QWORD v44[4];
  uint8_t buf[8];
  _BYTE v46[32];
  NSMutableDictionary *v47;
  id v48;
  const char *v49;
  NSErrorUserInfoKey v50;
  const __CFString *v51;
  const __CFString *v52;
  NSErrorUserInfoKey v53;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(id *)(a1 + 40);
  if (v1)
  {
    v3 = objc_opt_new(NSMutableDictionary);
    if (-[_NFHardwareManager getPrimaryHardwareState]_0(v1) == 2)
    {
      if ((sub_1000E7A2C(v1) & 1) == 0)
      {
        v4 = *(_QWORD *)(v1 + 24);
        if (!v4 || !*(_BYTE *)(v4 + 172))
        {
          *(_QWORD *)buf = _NSConcreteStackBlock;
          *(_QWORD *)v46 = 3221225472;
          *(_QWORD *)&v46[8] = sub_1000EE9E8;
          *(_QWORD *)&v46[16] = &unk_1002E8280;
          *(_QWORD *)&v46[24] = v1;
          v47 = v3;
          v34 = v2;
          v48 = v34;
          v49 = "_sync_rfSettingsWithCompletion:";
          v35 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig routingOffWithFD:](NFRoutingConfig, "routingOffWithFD:", 0));
          v36 = sub_1000E3CEC((void **)v1, buf, CFSTR("Get RF Settings"), v35);

          if ((v36 & 1) == 0)
          {
            v37 = objc_alloc((Class)NSError);
            v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
            v44[0] = NSLocalizedDescriptionKey;
            v39 = (NSString *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
            v50 = v39;
            v51 = (const __CFString *)&off_1002FEF10;
            v44[1] = CFSTR("Line");
            v44[2] = CFSTR("Method");
            v40 = (__CFString *)objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_rfSettingsWithCompletion:"));
            v52 = v40;
            v44[3] = NSDebugDescriptionErrorKey;
            v41 = (NSString *)objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_rfSettingsWithCompletion:"), 2943);
            v53 = v41;
            v42 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v50, v44, 4));
            v43 = objc_msgSend(v37, "initWithDomain:code:userInfo:", v38, 15, v42);
            (*((void (**)(id, _QWORD, id))v34 + 2))(v34, 0, v43);

          }
          goto LABEL_23;
        }
      }
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v7 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass((id)v1);
        if (class_isMetaClass(Class))
          v9 = 43;
        else
          v9 = 45;
        ClassName = object_getClassName((id)v1);
        Name = sel_getName("_sync_rfSettingsWithCompletion:");
        v12 = sub_1000E7A2C(v1);
        v13 = *(_QWORD *)(v1 + 24);
        if (v13)
          v13 = *(unsigned __int8 *)(v13 + 172);
        v7(3, "%c[%{public}s %{public}s]:%i Session in progress (%d) or express in progress (%d) - bailing", v9, ClassName, Name, 2925, v12, v13);
      }
      v14 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v15 = NFSharedLogGetLogger(v14);
      v16 = objc_claimAutoreleasedReturnValue(v15);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        v17 = object_getClass((id)v1);
        if (class_isMetaClass(v17))
          v18 = 43;
        else
          v18 = 45;
        v19 = object_getClassName((id)v1);
        v20 = sel_getName("_sync_rfSettingsWithCompletion:");
        v21 = sub_1000E7A2C(v1);
        v22 = *(_QWORD *)(v1 + 24);
        if (v22)
          LODWORD(v22) = *(unsigned __int8 *)(v22 + 172);
        *(_DWORD *)buf = 67110402;
        *(_DWORD *)&buf[4] = v18;
        *(_WORD *)v46 = 2082;
        *(_QWORD *)&v46[2] = v19;
        *(_WORD *)&v46[10] = 2082;
        *(_QWORD *)&v46[12] = v20;
        *(_WORD *)&v46[20] = 1024;
        *(_DWORD *)&v46[22] = 2925;
        *(_WORD *)&v46[26] = 1024;
        *(_DWORD *)&v46[28] = v21;
        LOWORD(v47) = 1024;
        *(_DWORD *)((char *)&v47 + 2) = v22;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session in progress (%d) or express in progress (%d) - bailing", buf, 0x2Eu);
      }

      v23 = objc_alloc((Class)NSError);
      v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v50 = NSLocalizedDescriptionKey;
      v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Busy"));
      *(_QWORD *)buf = v25;
      *(_QWORD *)v46 = &off_1002FEEE0;
      v51 = CFSTR("Line");
      v52 = CFSTR("Method");
      v26 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_rfSettingsWithCompletion:"));
      *(_QWORD *)&v46[8] = v26;
      v53 = NSDebugDescriptionErrorKey;
      v27 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_rfSettingsWithCompletion:"), 2926);
      *(_QWORD *)&v46[16] = v27;
      v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v50, 4));
      v29 = v23;
      v30 = v24;
      v31 = 2;
    }
    else
    {
      v32 = objc_alloc((Class)NSError);
      v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v50 = NSLocalizedDescriptionKey;
      v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
      *(_QWORD *)buf = v25;
      *(_QWORD *)v46 = &off_1002FEEC8;
      v51 = CFSTR("Line");
      v52 = CFSTR("Method");
      v26 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_rfSettingsWithCompletion:"));
      *(_QWORD *)&v46[8] = v26;
      v53 = NSDebugDescriptionErrorKey;
      v27 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_rfSettingsWithCompletion:"), 2920);
      *(_QWORD *)&v46[16] = v27;
      v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v50, 4));
      v29 = v32;
      v30 = v24;
      v31 = 58;
    }
    v33 = objc_msgSend(v29, "initWithDomain:code:userInfo:", v30, v31, v28);
    (*((void (**)(id, _QWORD, id))v2 + 2))(v2, 0, v33);

LABEL_23:
  }

}

uint64_t sub_1000EE9E8(uint64_t a1)
{
  unsigned int v2;
  uint64_t v3;
  id v4;
  void *v5;
  void *v6;
  id v7;
  id v8;
  void *v9;
  id v10;
  _QWORD v12[4];
  _QWORD v13[4];

  v2 = sub_1001CB624(*(void **)(*(_QWORD *)(a1 + 32) + 368), *(void **)(a1 + 40));
  v3 = *(_QWORD *)(a1 + 48);
  if (v2)
  {
    (*(void (**)(_QWORD, _QWORD, _QWORD))(v3 + 16))(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 40), 0);
  }
  else
  {
    v4 = objc_alloc((Class)NSError);
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v12[0] = NSLocalizedDescriptionKey;
    v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Feature Not Supported"));
    v13[0] = v6;
    v13[1] = &off_1002FEEF8;
    v12[1] = CFSTR("Line");
    v12[2] = CFSTR("Method");
    v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v13[2] = v7;
    v12[3] = NSDebugDescriptionErrorKey;
    v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 2937);
    v13[3] = v8;
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v13, v12, 4));
    v10 = objc_msgSend(v4, "initWithDomain:code:userInfo:", v5, 14, v9);
    (*(void (**)(uint64_t, _QWORD, id))(v3 + 16))(v3, 0, v10);

  }
  return 1;
}

void sub_1000EEC48(uint64_t a1)
{
  void **v1;
  void (**v2)(id, void *, _QWORD);
  id v3;
  uint64_t v4;
  void *v5;
  void *specific;
  uint64_t Logger;
  void (*v8)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  objc_class *v15;
  int v16;
  id v17;
  void *v18;
  id v19;
  uint64_t v20;
  id v21;
  id v22;
  id v23;
  id v24;
  void *v25;
  id v26;
  void *v27;
  id v28;
  id v29;
  void *v30;
  id v31;
  id v32;
  void *v33;
  void *v34;
  id v35;
  id v36;
  void *v37;
  id v38;
  const char *ClassName;
  const char *Name;
  NSErrorUserInfoKey v41;
  const __CFString *v42;
  const __CFString *v43;
  const __CFString *v44;
  NSErrorUserInfoKey v45;
  uint8_t buf[8];
  _BYTE v47[36];

  v1 = *(void ***)(a1 + 32);
  v2 = (void (**)(id, void *, _QWORD))*(id *)(a1 + 40);
  if (v1)
  {
    if (-[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)v1) == 2
      || -[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)v1) == 5)
    {
      v3 = sub_1001F84C8(v1[46], CFSTR("DieID"), 2uLL);
      v4 = objc_claimAutoreleasedReturnValue(v3);
      if (!v4)
      {
        v21 = sub_1001FF4FC(v1[46]);
        v5 = (void *)objc_claimAutoreleasedReturnValue(v21);
        if (v5)
        {
          v2[2](v2, v5, 0);
        }
        else
        {
          v32 = objc_alloc((Class)NSError);
          v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
          v41 = NSLocalizedDescriptionKey;
          v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unknown Error"));
          *(_QWORD *)buf = v34;
          *(_QWORD *)v47 = &off_1002FEF58;
          v42 = CFSTR("Line");
          v43 = CFSTR("Method");
          v35 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_getDieIDWithCompletion:"));
          *(_QWORD *)&v47[8] = v35;
          v44 = (const __CFString *)NSDebugDescriptionErrorKey;
          v36 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_getDieIDWithCompletion:"), 2971);
          *(_QWORD *)&v47[16] = v36;
          v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v41, 4));
          v38 = objc_msgSend(v32, "initWithDomain:code:userInfo:", v33, 6, v37);
          ((void (**)(id, void *, id))v2)[2](v2, 0, v38);

        }
        sub_1001FABB8(v1[46], CFSTR("DieID"));
        goto LABEL_24;
      }
      v5 = (void *)v4;
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v8 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(v1);
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(v1);
        Name = sel_getName("_sync_getDieIDWithCompletion:");
        v11 = 45;
        if (isMetaClass)
          v11 = 43;
        v8(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v11, ClassName, Name, 2965, v5);
      }
      v12 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v13 = NFSharedLogGetLogger(v12);
      v14 = objc_claimAutoreleasedReturnValue(v13);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        v15 = object_getClass(v1);
        if (class_isMetaClass(v15))
          v16 = 43;
        else
          v16 = 45;
        *(_DWORD *)buf = 67110146;
        *(_DWORD *)&buf[4] = v16;
        *(_WORD *)v47 = 2082;
        *(_QWORD *)&v47[2] = object_getClassName(v1);
        *(_WORD *)&v47[10] = 2082;
        *(_QWORD *)&v47[12] = sel_getName("_sync_getDieIDWithCompletion:");
        *(_WORD *)&v47[20] = 1024;
        *(_DWORD *)&v47[22] = 2965;
        *(_WORD *)&v47[26] = 2112;
        *(_QWORD *)&v47[28] = v5;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
      }

      v17 = objc_alloc((Class)NSError);
      v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v19 = objc_msgSend(v5, "code");
      v41 = NSLocalizedDescriptionKey;
      if ((uint64_t)objc_msgSend(v5, "code") > 70)
        v20 = 71;
      else
        v20 = (uint64_t)objc_msgSend(v5, "code");
      v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E7F70[v20]));
      *(_QWORD *)buf = v27;
      *(_QWORD *)v47 = v5;
      v42 = (const __CFString *)NSUnderlyingErrorKey;
      v43 = CFSTR("Line");
      *(_QWORD *)&v47[8] = &off_1002FEF40;
      v44 = CFSTR("Method");
      v28 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_getDieIDWithCompletion:"));
      *(_QWORD *)&v47[16] = v28;
      v45 = NSDebugDescriptionErrorKey;
      v29 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_getDieIDWithCompletion:"), 2966);
      *(_QWORD *)&v47[24] = v29;
      v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v41, 5));
      v31 = objc_msgSend(v17, "initWithDomain:code:userInfo:", v18, v19, v30);
      ((void (**)(id, void *, id))v2)[2](v2, 0, v31);

    }
    else
    {
      v22 = objc_alloc((Class)NSError);
      v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v41 = NSLocalizedDescriptionKey;
      v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
      *(_QWORD *)buf = v18;
      *(_QWORD *)v47 = &off_1002FEF28;
      v42 = CFSTR("Line");
      v43 = CFSTR("Method");
      v23 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_getDieIDWithCompletion:"));
      *(_QWORD *)&v47[8] = v23;
      v44 = (const __CFString *)NSDebugDescriptionErrorKey;
      v24 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_getDieIDWithCompletion:"), 2959);
      *(_QWORD *)&v47[16] = v24;
      v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v41, 4));
      v26 = objc_msgSend(v22, "initWithDomain:code:userInfo:", v5, 58, v25);
      ((void (**)(id, void *, id))v2)[2](v2, 0, v26);

    }
LABEL_24:

  }
}

void sub_1000EF320(uint64_t a1)
{
  void **v1;
  void (**v2)(id, _QWORD, id);
  id v3;
  uint64_t v4;
  id v5;
  void *specific;
  uint64_t Logger;
  void (*v8)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  objc_class *v15;
  int v16;
  id v17;
  void *v18;
  id v19;
  uint64_t v20;
  void *v21;
  _QWORD *v22;
  id v23;
  id v24;
  id v25;
  void *v26;
  id v27;
  void *v28;
  id v29;
  id v30;
  void *v31;
  id v32;
  const char *ClassName;
  const char *Name;
  NSErrorUserInfoKey v35;
  const __CFString *v36;
  const __CFString *v37;
  const __CFString *v38;
  NSErrorUserInfoKey v39;
  uint8_t buf[8];
  _BYTE v41[36];

  v1 = *(void ***)(a1 + 32);
  v2 = (void (**)(id, _QWORD, id))*(id *)(a1 + 40);
  if (v1)
  {
    if (-[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)v1) == 2
      || -[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)v1) == 5)
    {
      v3 = sub_1001F84C8(v1[46], CFSTR("FDRKey"), 2uLL);
      v4 = objc_claimAutoreleasedReturnValue(v3);
      if (v4)
      {
        v5 = (id)v4;
        specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        Logger = NFLogGetLogger(specific);
        if (Logger)
        {
          v8 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(v1);
          isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(v1);
          Name = sel_getName("_sync_getUniqueFDRKeyWithCompletion:");
          v11 = 45;
          if (isMetaClass)
            v11 = 43;
          v8(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v11, ClassName, Name, 2994, v5);
        }
        v12 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v13 = NFSharedLogGetLogger(v12);
        v14 = objc_claimAutoreleasedReturnValue(v13);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          v15 = object_getClass(v1);
          if (class_isMetaClass(v15))
            v16 = 43;
          else
            v16 = 45;
          *(_DWORD *)buf = 67110146;
          *(_DWORD *)&buf[4] = v16;
          *(_WORD *)v41 = 2082;
          *(_QWORD *)&v41[2] = object_getClassName(v1);
          *(_WORD *)&v41[10] = 2082;
          *(_QWORD *)&v41[12] = sel_getName("_sync_getUniqueFDRKeyWithCompletion:");
          *(_WORD *)&v41[20] = 1024;
          *(_DWORD *)&v41[22] = 2994;
          *(_WORD *)&v41[26] = 2112;
          *(_QWORD *)&v41[28] = v5;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
        }

        v17 = objc_alloc((Class)NSError);
        v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v19 = objc_msgSend(v5, "code");
        v35 = NSLocalizedDescriptionKey;
        if ((uint64_t)objc_msgSend(v5, "code") > 70)
          v20 = 71;
        else
          v20 = (uint64_t)objc_msgSend(v5, "code");
        v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E7F70[v20]));
        *(_QWORD *)buf = v28;
        *(_QWORD *)v41 = v5;
        v36 = (const __CFString *)NSUnderlyingErrorKey;
        v37 = CFSTR("Line");
        *(_QWORD *)&v41[8] = &off_1002FEF88;
        v38 = CFSTR("Method");
        v29 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_getUniqueFDRKeyWithCompletion:"));
        *(_QWORD *)&v41[16] = v29;
        v39 = NSDebugDescriptionErrorKey;
        v30 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_getUniqueFDRKeyWithCompletion:"), 2995);
        *(_QWORD *)&v41[24] = v30;
        v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v35, 5));
        v32 = objc_msgSend(v17, "initWithDomain:code:userInfo:", v18, v19, v31);
        v2[2](v2, 0, v32);

      }
      else
      {
        v21 = v1[46];
        *(_QWORD *)buf = 0;
        v22 = sub_1001FF714(v21, buf);
        v18 = (void *)objc_claimAutoreleasedReturnValue(v22);
        v5 = *(id *)buf;
        ((void (**)(id, void *, id))v2)[2](v2, v18, v5);
        sub_1001FABB8(v1[46], CFSTR("FDRKey"));
      }
    }
    else
    {
      v23 = objc_alloc((Class)NSError);
      v5 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v35 = NSLocalizedDescriptionKey;
      v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
      *(_QWORD *)buf = v18;
      *(_QWORD *)v41 = &off_1002FEF70;
      v36 = CFSTR("Line");
      v37 = CFSTR("Method");
      v24 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_getUniqueFDRKeyWithCompletion:"));
      *(_QWORD *)&v41[8] = v24;
      v38 = (const __CFString *)NSDebugDescriptionErrorKey;
      v25 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_getUniqueFDRKeyWithCompletion:"), 2988);
      *(_QWORD *)&v41[16] = v25;
      v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v35, 4));
      v27 = objc_msgSend(v23, "initWithDomain:code:userInfo:", v5, 58, v26);
      v2[2](v2, 0, v27);

    }
  }

}

void sub_1000EF8B8(uint64_t a1)
{
  uint64_t v1;
  NSMutableDictionary *v2;
  id v3;

  v1 = *(_QWORD *)(a1 + 40);
  v2 = sub_1000EF900(*(_QWORD *)(a1 + 32));
  v3 = (id)objc_claimAutoreleasedReturnValue(v2);
  (*(void (**)(uint64_t, id, _QWORD))(v1 + 16))(v1, v3, 0);

}

NSMutableDictionary *sub_1000EF900(uint64_t a1)
{
  void *v1;
  uint64_t v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  int v7;
  void *v8;
  void *v9;
  uint64_t v10;
  void *v11;
  void *v12;
  NSMutableArray *v13;
  void *v14;
  id v15;
  uint64_t v16;
  void *i;
  void *v18;
  void *v19;
  uint64_t v20;
  _BOOL8 v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  _QWORD *v26;
  const __CFString *v27;
  id v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  NSMutableDictionary *v37;
  void *v38;
  _QWORD *v39;
  void *v40;
  id v41;
  _QWORD *v42;
  _QWORD *v43;
  void *v44;
  void *v45;
  NSMutableDictionary *v46;
  id v47;
  void *j;
  id v49;
  id v50;
  uint64_t v51;
  void *k;
  uint64_t v53;
  void *v54;
  id v55;
  uint64_t v56;
  id v57;
  id v58;
  unsigned int *v59;
  id v60;
  void *v61;
  void *v62;
  void *v63;
  void *v64;
  SEL v65;
  id v66;
  id v67;
  void *m;
  void *v69;
  id v70;
  void *v71;
  void *v72;
  void *v73;
  void *v74;
  void *v75;
  void *v76;
  void *v77;
  uint64_t v78;
  NSMutableArray *v79;
  id v80;
  id v81;
  uint64_t v82;
  void *n;
  void *v84;
  void *v85;
  void *v86;
  id v87;
  void *v88;
  void *v89;
  void *v90;
  id v92;
  NSMutableDictionary *v94;
  id obj;
  uint64_t v96;
  id v97;
  uint64_t v98;
  NSMutableDictionary *v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  _BYTE v120[128];
  _BYTE v121[128];
  _BYTE v122[128];
  _BYTE v123[128];
  _BYTE v124[128];

  if (!a1)
    return (NSMutableDictionary *)0;
  v94 = objc_opt_new(NSMutableDictionary);
  v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", *(_QWORD *)(a1 + 288)));
  -[NSMutableDictionary setObject:forKeyedSubscript:](v94, "setObject:forKeyedSubscript:", v1, CFSTR("radio"));

  v2 = a1;
  v3 = *(void **)(a1 + 384);
  if (v3)
  {
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "asDictionary"));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v94, "setObject:forKeyedSubscript:", v4, CFSTR("controller"));

    v2 = a1;
  }
  v5 = *(void **)(v2 + 40);
  if (v5)
  {
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "asDictionary"));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v94, "setObject:forKeyedSubscript:", v6, CFSTR("embeddedSE"));

    v2 = a1;
  }
  v7 = *(unsigned __int16 *)(v2 + 332);
  if (v7)
  {
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithShort:](NSNumber, "numberWithShort:", (__int16)v7));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v94, "setObject:forKeyedSubscript:", v8, CFSTR("ATE Trim Version"));

  }
  v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", +[NFSecureElementWrapper isAuthRandomEntangled](NFSecureElementWrapper, "isAuthRandomEntangled")));
  -[NSMutableDictionary setObject:forKeyedSubscript:](v94, "setObject:forKeyedSubscript:", v9, CFSTR("authRandomEntangled"));

  v10 = a1;
  v11 = *(void **)(a1 + 376);
  if (v11)
  {
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "cachedAppletsUnfiltered"));

    v10 = a1;
    if (v12)
    {
      v13 = objc_opt_new(NSMutableArray);
      v108 = 0u;
      v109 = 0u;
      v110 = 0u;
      v111 = 0u;
      v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 376), "cachedAppletsUnfiltered"));
      v15 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v108, v122, 16);
      if (v15)
      {
        v16 = *(_QWORD *)v109;
        do
        {
          for (i = 0; i != v15; i = (char *)i + 1)
          {
            if (*(_QWORD *)v109 != v16)
              objc_enumerationMutation(v14);
            v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*((_QWORD *)&v108 + 1) + 8 * (_QWORD)i), "description"));
            -[NSMutableArray addObject:](v13, "addObject:", v18);

          }
          v15 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v108, v122, 16);
        }
        while (v15);
      }

      -[NSMutableDictionary setObject:forKeyedSubscript:](v94, "setObject:forKeyedSubscript:", v13, CFSTR("embeddedSEApplets"));
      v10 = a1;
    }
  }
  v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *(unsigned __int8 *)(v10 + 337)));
  -[NSMutableDictionary setObject:forKeyedSubscript:](v94, "setObject:forKeyedSubscript:", v19, CFSTR("isRunning"));

  v20 = *(_QWORD *)(a1 + 24);
  if (v20)
    v21 = *(unsigned __int8 *)(v20 + 172) != 0;
  else
    v21 = 0;
  v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v21));
  -[NSMutableDictionary setObject:forKeyedSubscript:](v94, "setObject:forKeyedSubscript:", v22, CFSTR("expressModeInProgress"));

  v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *(unsigned __int8 *)(a1 + 338)));
  -[NSMutableDictionary setObject:forKeyedSubscript:](v94, "setObject:forKeyedSubscript:", v23, CFSTR("didPrewWarmHardware"));

  v24 = *(void **)(a1 + 184);
  if (v24)
  {
    v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", objc_msgSend(v24, "count")));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v94, "setObject:forKeyedSubscript:", v25, CFSTR("numQueuedSessions"));

  }
  else
  {
    -[NSMutableDictionary setObject:forKeyedSubscript:](v94, "setObject:forKeyedSubscript:", &off_1002FEDC0, CFSTR("numQueuedSessions"));
  }
  v26 = (_QWORD *)(a1 + 112);
  if (*(_QWORD *)(a1 + 112))
    v27 = CFSTR("YES");
  else
    v27 = CFSTR("NO");
  -[NSMutableDictionary setObject:forKeyedSubscript:](v94, "setObject:forKeyedSubscript:", v27, CFSTR("hasCurrentSession"));
  if (*v26)
  {
    v28 = objc_msgSend((id)objc_opt_class(*v26), "description");
    v29 = (void *)objc_claimAutoreleasedReturnValue(v28);
    -[NSMutableDictionary setObject:forKeyedSubscript:](v94, "setObject:forKeyedSubscript:", v29, CFSTR("currentSessionType"));

    v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 112), "clientName"));
    if (v30)
    {
      v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 112), "clientName"));
      -[NSMutableDictionary setObject:forKeyedSubscript:](v94, "setObject:forKeyedSubscript:", v31, CFSTR("currentSessionOwner"));

    }
    else
    {
      -[NSMutableDictionary setObject:forKeyedSubscript:](v94, "setObject:forKeyedSubscript:", &stru_1002ED8A8, CFSTR("currentSessionOwner"));
    }

    v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 112), "creation"));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v94, "setObject:forKeyedSubscript:", v32, CFSTR("currentSessionCreation"));

    v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 112), "dequeueDate"));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v94, "setObject:forKeyedSubscript:", v33, CFSTR("currentSessionDequeue"));

    v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 112), "sessionUID"));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v94, "setObject:forKeyedSubscript:", v34, CFSTR("currentSessionUID"));

  }
  v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "lastKnownRoutingConfig"));
  v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v35, "description"));
  -[NSMutableDictionary setObject:forKeyedSubscript:](v94, "setObject:forKeyedSubscript:", v36, CFSTR("routingConfig"));

  if (NF_isFeatureSupported(1))
  {
    v37 = sub_100048570(*(_QWORD *)(a1 + 24));
    v38 = (void *)objc_claimAutoreleasedReturnValue(v37);
    -[NSMutableDictionary setObject:forKeyedSubscript:](v94, "setObject:forKeyedSubscript:", v38, CFSTR("expressModeState"));

  }
  v39 = sub_1001FC144(*(_QWORD **)(a1 + 368));
  v40 = (void *)objc_claimAutoreleasedReturnValue(v39);
  -[NSMutableDictionary setObject:forKeyedSubscript:](v94, "setObject:forKeyedSubscript:", v40, CFSTR("driverwrapperState"));

  v41 = sub_100203984((uint64_t)NFHeadlessModeController);
  v42 = (_QWORD *)objc_claimAutoreleasedReturnValue(v41);
  v43 = sub_100207348(v42);
  v44 = (void *)objc_claimAutoreleasedReturnValue(v43);
  -[NSMutableDictionary setObject:forKeyedSubscript:](v94, "setObject:forKeyedSubscript:", v44, CFSTR("LPEMState"));

  v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", *(_QWORD *)(a1 + 304)));
  -[NSMutableDictionary setObject:forKeyedSubscript:](v94, "setObject:forKeyedSubscript:", v45, CFSTR("Reader Session suspension count"));

  v46 = objc_opt_new(NSMutableDictionary);
  v118 = 0u;
  v119 = 0u;
  v116 = 0u;
  v117 = 0u;
  v47 = objc_msgSend(&off_100305E18, "countByEnumeratingWithState:objects:count:", &v116, v124, 16);
  if (v47)
  {
    v98 = *(_QWORD *)v117;
    do
    {
      for (j = 0; j != v47; j = (char *)j + 1)
      {
        if (*(_QWORD *)v117 != v98)
          objc_enumerationMutation(&off_100305E18);
        v49 = objc_msgSend(objc_alloc((Class)NSUserDefaults), "initWithSuiteName:", *(_QWORD *)(*((_QWORD *)&v116 + 1) + 8 * (_QWORD)j));
        v114 = 0u;
        v115 = 0u;
        v112 = 0u;
        v113 = 0u;
        v50 = objc_msgSend(&off_100305E00, "countByEnumeratingWithState:objects:count:", &v112, v123, 16);
        if (v50)
        {
          v51 = *(_QWORD *)v113;
          do
          {
            for (k = 0; k != v50; k = (char *)k + 1)
            {
              if (*(_QWORD *)v113 != v51)
                objc_enumerationMutation(&off_100305E00);
              v53 = *(_QWORD *)(*((_QWORD *)&v112 + 1) + 8 * (_QWORD)k);
              v54 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v49, "objectForKey:", v53));
              if (v54)
                -[NSMutableDictionary setObject:forKeyedSubscript:](v46, "setObject:forKeyedSubscript:", v54, v53);

            }
            v50 = objc_msgSend(&off_100305E00, "countByEnumeratingWithState:objects:count:", &v112, v123, 16);
          }
          while (v50);
        }

      }
      v47 = objc_msgSend(&off_100305E18, "countByEnumeratingWithState:objects:count:", &v116, v124, 16);
    }
    while (v47);
  }
  -[NSMutableDictionary setObject:forKeyedSubscript:](v94, "setObject:forKeyedSubscript:", v46, CFSTR("settings"));

  if (objc_msgSend(*(id *)(a1 + 216), "checkResourceIsReachableAndReturnError:", 0))
  {
    v55 = objc_msgSend(objc_alloc((Class)NSDictionary), "initWithContentsOfURL:", *(_QWORD *)(a1 + 216));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v94, "setObject:forKeyedSubscript:", v55, CFSTR("LPCDFalseDetects"));

  }
  v56 = *(_QWORD *)(a1 + 208);
  if (v56)
    -[NSMutableDictionary setObject:forKeyedSubscript:](v94, "setObject:forKeyedSubscript:", v56, CFSTR("LPEMLoggingFTA"));
  v57 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", "NFCD built from (B&I) Stockholm_Base-350.33.1");
  -[NSMutableDictionary setObject:forKeyedSubscript:](v94, "setObject:forKeyedSubscript:", v57, CFSTR("buildInfo"));

  if (*(_QWORD *)(a1 + 32))
  {
    v58 = objc_alloc((Class)NSString);
    v59 = *(unsigned int **)(a1 + 32);
    v60 = objc_msgSend(v58, "initWithFormat:", CFSTR("Persistent=%d, COR=%d, CODS=%d, idx=%d/%d, availablePersistent=%d, eUICC=%d, reservedCODS=%d, maxMappedCODS=%d, tmpOSU=%d, OSU=%d, tmpCommon=%d, reservedCommon=%d"), *v59, v59[1], v59[2], v59[3], v59[4], v59[5], v59[6], v59[7], v59[8], v59[9], v59[10], v59[11], v59[12]);
    -[NSMutableDictionary setObject:forKeyedSubscript:](v94, "setObject:forKeyedSubscript:", v60, CFSTR("SE Memory"));

  }
  v61 = (void *)objc_claimAutoreleasedReturnValue(+[NFPowerAssertion sharedPowerAssertion](NFPowerAssertion, "sharedPowerAssertion"));
  v62 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v61, "dumpState"));
  -[NSMutableDictionary addEntriesFromDictionary:](v94, "addEntriesFromDictionary:", v62);

  v63 = *(void **)(a1 + 408);
  if (v63)
  {
    v64 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v63, "dumpState"));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v94, "setObject:forKeyedSubscript:", v64, CFSTR("Background Tag Reading"));

  }
  v99 = objc_opt_new(NSMutableDictionary);
  v92 = objc_getProperty((id)a1, v65, 176, 1);
  objc_sync_enter(v92);
  v66 = objc_msgSend(*(id *)(a1 + 176), "copy");
  v106 = 0u;
  v107 = 0u;
  v104 = 0u;
  v105 = 0u;
  obj = v66;
  v67 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v104, v121, 16);
  if (v67)
  {
    v96 = *(_QWORD *)v105;
    do
    {
      v97 = v67;
      for (m = 0; m != v97; m = (char *)m + 1)
      {
        if (*(_QWORD *)v105 != v96)
          objc_enumerationMutation(obj);
        v69 = *(void **)(*((_QWORD *)&v104 + 1) + 8 * (_QWORD)m);
        v70 = objc_msgSend(v69, "processIdentifier");
        v71 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v69, "NF_userInfo"));
        v72 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v71, "objectsForKeys:notFoundMarker:", &off_100305E30, &stru_1002ED8A8));

        v73 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v70));
        v74 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v73, "stringValue"));

        v75 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionaryWithObjects:forKeys:](NSMutableDictionary, "dictionaryWithObjects:forKeys:", v72, &off_100305E30));
        -[NSMutableDictionary setObject:forKeyedSubscript:](v99, "setObject:forKeyedSubscript:", v75, v74);

        v76 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](v99, "objectForKeyedSubscript:", v74));
        v77 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v76, "objectForKeyedSubscript:", CFSTR("assertions")));

        v78 = objc_opt_class(NSArray);
        if ((objc_opt_isKindOfClass(v77, v78) & 1) != 0 && objc_msgSend(v77, "count"))
        {
          v79 = objc_opt_new(NSMutableArray);
          v102 = 0u;
          v103 = 0u;
          v100 = 0u;
          v101 = 0u;
          v80 = v77;
          v81 = objc_msgSend(v80, "countByEnumeratingWithState:objects:count:", &v100, v120, 16);
          if (v81)
          {
            v82 = *(_QWORD *)v101;
            do
            {
              for (n = 0; n != v81; n = (char *)n + 1)
              {
                if (*(_QWORD *)v101 != v82)
                  objc_enumerationMutation(v80);
                v84 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*((_QWORD *)&v100 + 1)
                                                                                   + 8 * (_QWORD)n), "description"));
                -[NSMutableArray addObject:](v79, "addObject:", v84);

              }
              v81 = objc_msgSend(v80, "countByEnumeratingWithState:objects:count:", &v100, v120, 16);
            }
            while (v81);
          }

          v85 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](v99, "objectForKeyedSubscript:", v74));
          objc_msgSend(v85, "setObject:forKeyedSubscript:", v79, CFSTR("assertions"));

        }
      }
      v67 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v104, v121, 16);
    }
    while (v67);
  }

  v86 = *(void **)(a1 + 416);
  if (v86)
  {
    v87 = v86;
    -[NSMutableDictionary setObject:forKeyedSubscript:](v94, "setObject:forKeyedSubscript:", v87, CFSTR("CHAssertionForCamera"));

  }
  objc_sync_exit(v92);

  -[NSMutableDictionary setObject:forKeyedSubscript:](v94, "setObject:forKeyedSubscript:", v99, CFSTR("XPCs"));
  v88 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 160), "allKeys"));
  -[NSMutableDictionary setObject:forKeyedSubscript:](v94, "setObject:forKeyedSubscript:", v88, CFSTR("callbackHandlers"));

  v89 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 120), "dumpState"));
  -[NSMutableDictionary setObject:forKeyedSubscript:](v94, "setObject:forKeyedSubscript:", v89, CFSTR("walletPresentationService"));

  v90 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 16), "getStateDumpInfo"));
  -[NSMutableDictionary addEntriesFromDictionary:](v94, "addEntriesFromDictionary:", v90);

  return v94;
}

void sub_1000F0564(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id obj)
{
  objc_sync_exit(obj);
  _Unwind_Resume(a1);
}

void sub_1000F0654(uint64_t a1)
{
  void **v1;
  void *v2;
  id v3;
  void (**v4)(id, id);
  uint64_t v5;
  void *v6;
  char v7;
  void *specific;
  void (*Logger)(uint64_t, const char *, ...);
  objc_class *Class;
  uint64_t v11;
  const char *ClassName;
  const char *Name;
  void *v14;
  uint64_t v15;
  NSObject *v16;
  objc_class *v17;
  int v18;
  const char *v19;
  const char *v20;
  uint64_t v21;
  id v22;
  void *v23;
  void *v24;
  void *v25;
  id v26;
  id v27;
  void *v28;
  void *v29;
  void *v30;
  id v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t (*v35)(uint64_t, uint64_t);
  void (*v36)(uint64_t);
  id v37;
  uint8_t buf[8];
  __int16 v39;
  const char *v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  int v44;
  __int16 v45;
  uint64_t v46;
  _QWORD v47[5];
  id v48;
  uint64_t *v49;

  v1 = *(void ***)(a1 + 32);
  v2 = *(void **)(a1 + 48);
  v3 = *(id *)(a1 + 40);
  v4 = v2;
  if (v1)
  {
    v32 = 0;
    v33 = &v32;
    v34 = 0x3032000000;
    v35 = sub_1000E3C80;
    v36 = sub_1000E3C90;
    v37 = 0;
    if (-[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)v1) == 2)
    {
      if (v3 && (v5 = objc_opt_class(NSData), (objc_opt_isKindOfClass(v3, v5) & 1) == 0))
      {
        v27 = objc_alloc((Class)NSError);
        v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        *(_QWORD *)buf = NSLocalizedDescriptionKey;
        v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid Parameter"));
        v47[0] = v29;
        v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v47, buf, 1));
        v31 = objc_msgSend(v27, "initWithDomain:code:userInfo:", v28, 10, v30);
        v4[2](v4, v31);

      }
      else
      {
        v47[0] = _NSConcreteStackBlock;
        v47[1] = 3221225472;
        v47[2] = sub_1000F0AC0;
        v47[3] = &unk_1002E83E8;
        v49 = &v32;
        v47[4] = v1;
        v48 = v3;
        v6 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig routingOffWithFD:](NFRoutingConfig, "routingOffWithFD:", 0));
        v7 = sub_1000E3CEC(v1, v47, CFSTR("Push RF"), v6);

        if ((v7 & 1) == 0)
        {
          specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(specific);
          if (Logger)
          {
            Class = object_getClass(v1);
            if (class_isMetaClass(Class))
              v11 = 43;
            else
              v11 = 45;
            ClassName = object_getClassName(v1);
            Name = sel_getName("_sync_pushSignedRF:completion:");
            Logger(3, "%c[%{public}s %{public}s]:%i Failed to push signed rf: %{public}@", v11, ClassName, Name, 3088, v33[5]);
          }
          v14 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v15 = NFSharedLogGetLogger(v14);
          v16 = objc_claimAutoreleasedReturnValue(v15);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          {
            v17 = object_getClass(v1);
            if (class_isMetaClass(v17))
              v18 = 43;
            else
              v18 = 45;
            v19 = object_getClassName(v1);
            v20 = sel_getName("_sync_pushSignedRF:completion:");
            v21 = v33[5];
            *(_DWORD *)buf = 67110146;
            *(_DWORD *)&buf[4] = v18;
            v39 = 2082;
            v40 = v19;
            v41 = 2082;
            v42 = v20;
            v43 = 1024;
            v44 = 3088;
            v45 = 2114;
            v46 = v21;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to push signed rf: %{public}@", buf, 0x2Cu);
          }

        }
        v4[2](v4, (id)v33[5]);

      }
    }
    else
    {
      v22 = objc_alloc((Class)NSError);
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      *(_QWORD *)buf = NSLocalizedDescriptionKey;
      v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
      v47[0] = v24;
      v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v47, buf, 1));
      v26 = objc_msgSend(v22, "initWithDomain:code:userInfo:", v23, 58, v25);
      v4[2](v4, v26);

    }
    _Block_object_dispose(&v32, 8);

  }
}

void sub_1000F0A90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_1000F0AC0(uint64_t a1)
{
  id v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;

  v2 = sub_1001CBE00(*(_QWORD **)(*(_QWORD *)(a1 + 32) + 368), *(void **)(a1 + 40));
  v3 = objc_claimAutoreleasedReturnValue(v2);
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
  v5 = *(void **)(v4 + 40);
  *(_QWORD *)(v4 + 40) = v3;

  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40) == 0;
}

void sub_1000F0BD8(uint64_t a1)
{
  int v1;
  uint64_t v2;
  id v3;
  void *v4;
  void *v5;
  uint64_t v6;
  void *specific;
  uint64_t Logger;
  const char *v9;
  void (*v10)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *Name;
  int v14;
  id v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  NSObject *v19;
  objc_class *v20;
  int v21;
  const char *v22;
  const char *v23;
  const char *v24;
  id v25;
  int v26;
  id v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  void (*v31)(uint64_t, const char *, ...);
  objc_class *v32;
  _BOOL4 v33;
  const char *v34;
  uint64_t v35;
  void *v36;
  uint64_t v37;
  NSObject *v38;
  void *v39;
  objc_class *v40;
  int v41;
  const char *v42;
  const char *v43;
  id v44;
  void *v45;
  void *v46;
  void *v47;
  uint64_t v48;
  id v49;
  void *v50;
  void *v51;
  void *v52;
  void *v53;
  const char *v54;
  id v55;
  id v56;
  void *v58;
  const char *ClassName;
  int v60;
  id v61;
  NSErrorUserInfoKey v62;
  uint8_t buf[8];
  __int16 v64;
  const char *v65;
  __int16 v66;
  const char *v67;
  __int16 v68;
  int v69;
  __int16 v70;
  const char *v71;
  __int16 v72;
  id v73;
  __int16 v74;
  void *v75;

  v1 = *(unsigned __int8 *)(a1 + 56);
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(id *)(a1 + 40);
  v4 = v3;
  if (!v2)
  {
    v61 = 0;
    v48 = a1;
    goto LABEL_36;
  }
  v56 = v3;
  v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "NF_userInfo"));
  v6 = objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("ClientName")));

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  v9 = "Enabling";
  if (Logger)
  {
    v10 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass((id)v2);
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName((id)v2);
    Name = sel_getName("_sync_setFieldDetectEnabled:connection:");
    if (!v1)
      v9 = "Disabling";
    v14 = v1;
    v15 = *(id *)(v2 + 16);
    v55 = objc_msgSend(v15, "totalPersistentClient");
    v16 = 43;
    if (!isMetaClass)
      v16 = 45;
    v10(6, "%c[%{public}s %{public}s]:%i %s (%lu clients) persistent field detect by %{public}@", v16, ClassName, Name, 3108, v9, v55, v6);

    v1 = v14;
  }
  v58 = (void *)v6;
  v17 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v18 = NFSharedLogGetLogger(v17);
  v19 = objc_claimAutoreleasedReturnValue(v18);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    v20 = object_getClass((id)v2);
    if (class_isMetaClass(v20))
      v21 = 43;
    else
      v21 = 45;
    v60 = v21;
    v22 = object_getClassName((id)v2);
    v23 = sel_getName("_sync_setFieldDetectEnabled:connection:");
    if (v1)
      v24 = "Enabling";
    else
      v24 = "Disabling";
    v25 = *(id *)(v2 + 16);
    v26 = v1;
    v27 = objc_msgSend(v25, "totalPersistentClient");

    *(_DWORD *)buf = 67110658;
    *(_DWORD *)&buf[4] = v60;
    v64 = 2082;
    v65 = v22;
    v66 = 2082;
    v67 = v23;
    v68 = 1024;
    v69 = 3108;
    v70 = 2080;
    v71 = v24;
    v72 = 2048;
    v73 = v27;
    v1 = v26;
    v74 = 2114;
    v75 = v58;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %s (%lu clients) persistent field detect by %{public}@", buf, 0x40u);
  }

  if (-[_NFHardwareManager getPrimaryHardwareState]_0(v2) == 2)
  {
    v28 = *(_QWORD *)(v2 + 368);
    if (!v28 || (*(_BYTE *)(v28 + 218) & 1) == 0)
    {
      v29 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v30 = NFLogGetLogger(v29);
      if (v30)
      {
        v31 = (void (*)(uint64_t, const char *, ...))v30;
        v32 = object_getClass((id)v2);
        v33 = class_isMetaClass(v32);
        v34 = object_getClassName((id)v2);
        v54 = sel_getName("_sync_setFieldDetectEnabled:connection:");
        v35 = 45;
        if (v33)
          v35 = 43;
        v31(4, "%c[%{public}s %{public}s]:%i Device does not have antenna", v35, v34, v54, 3115);
      }
      v36 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v37 = NFSharedLogGetLogger(v36);
      v38 = objc_claimAutoreleasedReturnValue(v37);
      v39 = v58;
      if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
      {
        v40 = object_getClass((id)v2);
        if (class_isMetaClass(v40))
          v41 = 43;
        else
          v41 = 45;
        v42 = object_getClassName((id)v2);
        v43 = sel_getName("_sync_setFieldDetectEnabled:connection:");
        *(_DWORD *)buf = 67109890;
        *(_DWORD *)&buf[4] = v41;
        v64 = 2082;
        v65 = v42;
        v66 = 2082;
        v67 = v43;
        v68 = 1024;
        v69 = 3115;
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Device does not have antenna", buf, 0x22u);
      }

      v44 = objc_alloc((Class)NSError);
      v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v62 = NSLocalizedDescriptionKey;
      v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Feature Not Supported"));
      *(_QWORD *)buf = v46;
      v47 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v62, 1));
      v61 = objc_msgSend(v44, "initWithDomain:code:userInfo:", v45, 14, v47);

      v4 = v56;
      v48 = a1;
      goto LABEL_35;
    }
    v53 = *(void **)(v2 + 16);
    v4 = v56;
    if (v1)
      objc_msgSend(v53, "addPersistentFieldObserver:", v56);
    else
      objc_msgSend(v53, "removePersistentFieldObserver:", v56);
    v48 = a1;
    objc_msgSend((id)v2, "maybeStartNextSession");
    v61 = 0;
  }
  else
  {
    v49 = objc_alloc((Class)NSError);
    v50 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v62 = NSLocalizedDescriptionKey;
    v51 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
    *(_QWORD *)buf = v51;
    v52 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v62, 1));
    v61 = objc_msgSend(v49, "initWithDomain:code:userInfo:", v50, 58, v52);

    v4 = v56;
    v48 = a1;
  }
  v39 = v58;
LABEL_35:

LABEL_36:
  (*(void (**)(void))(*(_QWORD *)(v48 + 48) + 16))();

}

void sub_1000F1200(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  id v3;
  id v4;
  void *v5;
  void *specific;
  uint64_t Logger;
  void (*v8)(uint64_t, const char *, ...);
  objc_class *Class;
  uint64_t v10;
  const char *ClassName;
  const char *Name;
  id v13;
  void *v14;
  void *v15;
  uint64_t v16;
  NSObject *v17;
  objc_class *v18;
  int v19;
  const char *v20;
  const char *v21;
  unsigned int v22;
  void *v23;
  void *v24;
  id v25;
  void *v26;
  void (*v27)(uint64_t, const char *, ...);
  objc_class *v28;
  uint64_t v29;
  const char *v30;
  const char *v31;
  void *v32;
  uint64_t v33;
  NSObject *v34;
  objc_class *v35;
  int v36;
  const char *v37;
  const char *v38;
  uint64_t v39;
  void *v40;
  void *v41;
  uint8_t buf[4];
  int v43;
  __int16 v44;
  const char *v45;
  __int16 v46;
  const char *v47;
  __int16 v48;
  int v49;
  __int16 v50;
  unsigned int v51;
  __int16 v52;
  void *v53;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(void **)(a1 + 48);
  v3 = *(id *)(a1 + 40);
  v4 = v2;
  v5 = v4;
  if (v1)
  {
    v41 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "NF_whitelistChecker"));
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v8 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass((id)v1);
      if (class_isMetaClass(Class))
        v10 = 43;
      else
        v10 = 45;
      ClassName = object_getClassName((id)v1);
      Name = sel_getName("_sync_registerForCallbacks:connection:");
      v13 = objc_msgSend(v5, "processIdentifier");
      v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v41, "clientName"));
      v8(6, "%c[%{public}s %{public}s]:%i Client %d (%{public}@) registered callback", v10, ClassName, Name, 3149, v13, v14);

    }
    v15 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v16 = NFSharedLogGetLogger(v15);
    v17 = objc_claimAutoreleasedReturnValue(v16);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      v18 = object_getClass((id)v1);
      if (class_isMetaClass(v18))
        v19 = 43;
      else
        v19 = 45;
      v20 = object_getClassName((id)v1);
      v21 = sel_getName("_sync_registerForCallbacks:connection:");
      v22 = objc_msgSend(v5, "processIdentifier");
      v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v41, "clientName"));
      *(_DWORD *)buf = 67110402;
      v43 = v19;
      v44 = 2082;
      v45 = v20;
      v46 = 2082;
      v47 = v21;
      v48 = 1024;
      v49 = 3149;
      v50 = 1024;
      v51 = v22;
      v52 = 2114;
      v53 = v23;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Client %d (%{public}@) registered callback", buf, 0x32u);

    }
    v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", (int)objc_msgSend(v5, "processIdentifier")));
    v25 = *(id *)(v1 + 160);
    objc_sync_enter(v25);
    objc_msgSend(*(id *)(v1 + 160), "setObject:forKeyedSubscript:", v3, v24);
    objc_sync_exit(v25);

    if (!*(_QWORD *)(v1 + 272))
    {
      v26 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v27 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v26);
      if (v27)
      {
        v28 = object_getClass((id)v1);
        if (class_isMetaClass(v28))
          v29 = 43;
        else
          v29 = 45;
        v30 = object_getClassName((id)v1);
        v31 = sel_getName("_sync_registerForCallbacks:connection:");
        v27(6, "%c[%{public}s %{public}s]:%i creating NFCD keep alive transaction", v29, v30, v31, 3158);
      }
      v32 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v33 = NFSharedLogGetLogger(v32);
      v34 = objc_claimAutoreleasedReturnValue(v33);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        v35 = object_getClass((id)v1);
        if (class_isMetaClass(v35))
          v36 = 43;
        else
          v36 = 45;
        v37 = object_getClassName((id)v1);
        v38 = sel_getName("_sync_registerForCallbacks:connection:");
        *(_DWORD *)buf = 67109890;
        v43 = v36;
        v44 = 2082;
        v45 = v37;
        v46 = 2082;
        v47 = v38;
        v48 = 1024;
        v49 = 3158;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i creating NFCD keep alive transaction", buf, 0x22u);
      }

      v39 = os_transaction_create("com.apple.nfcd.keepAlive");
      v40 = *(void **)(v1 + 272);
      *(_QWORD *)(v1 + 272) = v39;

    }
    objc_msgSend(v3, "hwStateDidChange:", -[_NFHardwareManager getPrimaryHardwareState]_0(v1));

  }
}

void sub_1000F15D0(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000F1674(uint64_t a1)
{
  sub_1000E57E0(*(_QWORD *)(a1 + 32), *(void **)(a1 + 40));
}

void sub_1000F16FC(uint64_t a1)
{
  id v2;
  NSArray *v3;
  NSArray *v4;
  id v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;

  if (-[_NFHardwareManager getPrimaryHardwareState]_0(*(_QWORD *)(a1 + 32)) == 2
    || -[_NFHardwareManager getPrimaryHardwareState]_0(*(_QWORD *)(a1 + 32)) == 5)
  {
    v2 = *(id *)(a1 + 32);
    objc_sync_enter(v2);
    if (*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40))
    {
      v9 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 40);
      v3 = (NSArray *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v9, 1));
    }
    else
    {
      v3 = objc_opt_new(NSArray);
    }
    v4 = v3;
    objc_sync_exit(v2);

    (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
  }
  else
  {
    v5 = *(id *)(a1 + 32);
    objc_sync_enter(v5);
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 40);
    if (v6)
    {
      v7 = *(_QWORD *)(a1 + 40);
      v10 = v6;
      v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v10, 1));
      (*(void (**)(uint64_t, void *))(v7 + 16))(v7, v8);

      objc_sync_exit(v5);
    }
    else
    {
      objc_sync_exit(v5);

      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), 0);
    }
  }
}

void sub_1000F1888(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000F1B58(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void (**v3)(id, id);
  id v4;
  uint64_t v5;
  void *v6;
  void *specific;
  uint64_t Logger;
  void (*v9)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  NSObject *v15;
  objc_class *v16;
  int v17;
  id v18;
  void *v19;
  id v20;
  uint64_t v21;
  id v22;
  void *v23;
  void *v24;
  id v25;
  id v26;
  void *v27;
  id v28;
  void *v29;
  uint64_t v30;
  void (*v31)(uint64_t, const char *, ...);
  objc_class *v32;
  _BOOL4 v33;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  NSObject *v37;
  objc_class *v38;
  int v39;
  dispatch_time_t v40;
  NSObject *v41;
  void *v42;
  id v43;
  id v44;
  void *v45;
  id v46;
  id v47;
  void *v48;
  void *v49;
  id v50;
  id v51;
  void *v52;
  id v53;
  const char *ClassName;
  const char *v55;
  const char *Name;
  const char *v57;
  NSErrorUserInfoKey v58;
  const __CFString *v59;
  const __CFString *v60;
  const __CFString *v61;
  NSErrorUserInfoKey v62;
  uint8_t buf[8];
  _BYTE v64[36];

  v1 = *(unsigned __int8 *)(a1 + 48);
  v2 = *(_QWORD *)(a1 + 32);
  v3 = (void (**)(id, id))*(id *)(a1 + 40);
  if (v2)
  {
    if (-[_NFHardwareManager getPrimaryHardwareState]_0(v2) == 2)
    {
      v4 = sub_1001F84C8(*(void **)(v2 + 368), CFSTR("Delayed Sleep"), 1uLL);
      v5 = objc_claimAutoreleasedReturnValue(v4);
      if (v5)
      {
        v6 = (void *)v5;
        specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        Logger = NFLogGetLogger(specific);
        if (Logger)
        {
          v9 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass((id)v2);
          isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName((id)v2);
          Name = sel_getName("_sync_triggerDelayedWake:completion:");
          v12 = 45;
          if (isMetaClass)
            v12 = 43;
          v9(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v12, ClassName, Name, 3260, v6);
        }
        v13 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v14 = NFSharedLogGetLogger(v13);
        v15 = objc_claimAutoreleasedReturnValue(v14);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        {
          v16 = object_getClass((id)v2);
          if (class_isMetaClass(v16))
            v17 = 43;
          else
            v17 = 45;
          *(_DWORD *)buf = 67110146;
          *(_DWORD *)&buf[4] = v17;
          *(_WORD *)v64 = 2082;
          *(_QWORD *)&v64[2] = object_getClassName((id)v2);
          *(_WORD *)&v64[10] = 2082;
          *(_QWORD *)&v64[12] = sel_getName("_sync_triggerDelayedWake:completion:");
          *(_WORD *)&v64[20] = 1024;
          *(_DWORD *)&v64[22] = 3260;
          *(_WORD *)&v64[26] = 2112;
          *(_QWORD *)&v64[28] = v6;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
        }

        v18 = objc_alloc((Class)NSError);
        v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v20 = objc_msgSend(v6, "code");
        v58 = NSLocalizedDescriptionKey;
        if ((uint64_t)objc_msgSend(v6, "code") > 70)
          v21 = 71;
        else
          v21 = (uint64_t)objc_msgSend(v6, "code");
        v42 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E7F70[v21]));
        *(_QWORD *)buf = v42;
        *(_QWORD *)v64 = v6;
        v59 = (const __CFString *)NSUnderlyingErrorKey;
        v60 = CFSTR("Line");
        *(_QWORD *)&v64[8] = &off_1002FEFD0;
        v61 = CFSTR("Method");
        v43 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_triggerDelayedWake:completion:"));
        *(_QWORD *)&v64[16] = v43;
        v62 = NSDebugDescriptionErrorKey;
        v44 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_triggerDelayedWake:completion:"), 3261);
        *(_QWORD *)&v64[24] = v44;
        v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v58, 5));
        v46 = objc_msgSend(v18, "initWithDomain:code:userInfo:", v19, v20, v45);
        v3[2](v3, v46);

      }
      else if ((sub_1001D5544(*(void **)(v2 + 368), v1) & 1) != 0)
      {
        *(_BYTE *)(v2 + 346) = 1;
        v3[2](v3, 0);
        v29 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v30 = NFLogGetLogger(v29);
        if (v30)
        {
          v31 = (void (*)(uint64_t, const char *, ...))v30;
          v32 = object_getClass((id)v2);
          v33 = class_isMetaClass(v32);
          v55 = object_getClassName((id)v2);
          v57 = sel_getName("_sync_triggerDelayedWake:completion:");
          v34 = 45;
          if (v33)
            v34 = 43;
          v31(6, "%c[%{public}s %{public}s]:%i Delaying session close for %d seconds", v34, v55, v57, 3277, (v1 + 1));
        }
        v35 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v36 = NFSharedLogGetLogger(v35);
        v37 = objc_claimAutoreleasedReturnValue(v36);
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
        {
          v38 = object_getClass((id)v2);
          if (class_isMetaClass(v38))
            v39 = 43;
          else
            v39 = 45;
          *(_DWORD *)buf = 67110146;
          *(_DWORD *)&buf[4] = v39;
          *(_WORD *)v64 = 2082;
          *(_QWORD *)&v64[2] = object_getClassName((id)v2);
          *(_WORD *)&v64[10] = 2082;
          *(_QWORD *)&v64[12] = sel_getName("_sync_triggerDelayedWake:completion:");
          *(_WORD *)&v64[20] = 1024;
          *(_DWORD *)&v64[22] = 3277;
          *(_WORD *)&v64[26] = 1024;
          *(_DWORD *)&v64[28] = v1 + 1;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Delaying session close for %d seconds", buf, 0x28u);
        }

        v40 = dispatch_time(0, 1000000000 * v1 + 1000000000);
        v41 = *(NSObject **)(v2 + 232);
        *(_QWORD *)buf = _NSConcreteStackBlock;
        *(_QWORD *)v64 = 3221225472;
        *(_QWORD *)&v64[8] = sub_1000F2320;
        *(_QWORD *)&v64[16] = &unk_1002E5C58;
        *(_QWORD *)&v64[24] = v2;
        dispatch_after(v40, v41, buf);
      }
      else
      {
        v47 = objc_alloc((Class)NSError);
        v48 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v58 = NSLocalizedDescriptionKey;
        v49 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
        *(_QWORD *)buf = v49;
        *(_QWORD *)v64 = &off_1002FEFE8;
        v59 = CFSTR("Line");
        v60 = CFSTR("Method");
        v50 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_triggerDelayedWake:completion:"));
        *(_QWORD *)&v64[8] = v50;
        v61 = (const __CFString *)NSDebugDescriptionErrorKey;
        v51 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_triggerDelayedWake:completion:"), 3267);
        *(_QWORD *)&v64[16] = v51;
        v52 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v58, 4));
        v53 = objc_msgSend(v47, "initWithDomain:code:userInfo:", v48, 15, v52);
        v3[2](v3, v53);

        sub_1001FABB8(*(void **)(v2 + 368), CFSTR("Delayed Sleep"));
      }
    }
    else
    {
      v22 = objc_alloc((Class)NSError);
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v58 = NSLocalizedDescriptionKey;
      v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
      *(_QWORD *)buf = v24;
      *(_QWORD *)v64 = &off_1002FEFB8;
      v59 = CFSTR("Line");
      v60 = CFSTR("Method");
      v25 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_triggerDelayedWake:completion:"));
      *(_QWORD *)&v64[8] = v25;
      v61 = (const __CFString *)NSDebugDescriptionErrorKey;
      v26 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_triggerDelayedWake:completion:"), 3254);
      *(_QWORD *)&v64[16] = v26;
      v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v58, 4));
      v28 = objc_msgSend(v22, "initWithDomain:code:userInfo:", v23, 58, v27);
      v3[2](v3, v28);

    }
  }

}

id sub_1000F2320(uint64_t a1)
{
  sub_1001FABB8(*(void **)(*(_QWORD *)(a1 + 32) + 368), CFSTR("Delayed Sleep"));
  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 346) = 0;
  return objc_msgSend(*(id *)(a1 + 32), "maybeStartNextSession");
}

void sub_1000F23E8(uint64_t a1)
{
  __int16 v1;
  uint64_t v2;
  id v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  id v7;
  id v8;
  void *v9;
  void **v10;
  void (*v11)(uint64_t);
  id v12;
  void *v13;
  void *v14;
  void *v15;
  uint64_t v16;
  id v17;
  id v18;
  void **v19;
  uint64_t v20;
  void (*v21)(uint64_t);
  void *v22;
  uint64_t v23;
  id v24;
  const char *v25;
  __int16 v26;
  NSErrorUserInfoKey v27;
  const __CFString *v28;
  const __CFString *v29;
  NSErrorUserInfoKey v30;

  v1 = *(_WORD *)(a1 + 48);
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(id *)(a1 + 40);
  if (v2)
  {
    v4 = -[_NFHardwareManager getPrimaryHardwareState]_0(v2);
    if ((_DWORD)v4 == 2)
    {
      if ((NFIsInternalBuild(v4) & 1) != 0)
      {
        v5 = *(_QWORD *)(v2 + 232);
        v6 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig embeddedWiredMode](NFRoutingConfig, "embeddedWiredMode"));
        v19 = _NSConcreteStackBlock;
        v20 = 3221225472;
        v21 = sub_1000F2770;
        v22 = &unk_1002E6358;
        v23 = v2;
        v26 = v1;
        v24 = v3;
        v25 = "_sync_triggerCrash:completion:";
        v7 = +[_NFBuiltinSession createSessionWithWorkQueue:routing:sessionQueuer:didStartWork:](_NFBuiltinSession, "createSessionWithWorkQueue:routing:sessionQueuer:didStartWork:", v5, v6, v2, &v19);

        goto LABEL_8;
      }
      v17 = objc_alloc((Class)NSError);
      v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v27 = NSLocalizedDescriptionKey;
      v10 = (void **)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Feature Not Supported"));
      v19 = v10;
      v20 = (uint64_t)&off_1002FF018;
      v28 = CFSTR("Line");
      v29 = CFSTR("Method");
      v11 = (void (*)(uint64_t))objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_triggerCrash:completion:"));
      v21 = v11;
      v30 = NSDebugDescriptionErrorKey;
      v12 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_triggerCrash:completion:"), 3300);
      v22 = v12;
      v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v19, &v27, 4));
      v14 = v17;
      v15 = v9;
      v16 = 14;
    }
    else
    {
      v8 = objc_alloc((Class)NSError);
      v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v27 = NSLocalizedDescriptionKey;
      v10 = (void **)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
      v19 = v10;
      v20 = (uint64_t)&off_1002FF000;
      v28 = CFSTR("Line");
      v29 = CFSTR("Method");
      v11 = (void (*)(uint64_t))objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_triggerCrash:completion:"));
      v21 = v11;
      v30 = NSDebugDescriptionErrorKey;
      v12 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_triggerCrash:completion:"), 3295);
      v22 = v12;
      v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v19, &v27, 4));
      v14 = v8;
      v15 = v9;
      v16 = 58;
    }
    v18 = objc_msgSend(v14, "initWithDomain:code:userInfo:", v15, v16, v13);
    (*((void (**)(id, id))v3 + 2))(v3, v18);

  }
LABEL_8:

}

void sub_1000F2770(uint64_t a1)
{
  char v2;
  uint64_t v3;
  id v4;
  void *v5;
  void *v6;
  id v7;
  id v8;
  void *v9;
  id v10;
  _QWORD v11[4];
  _QWORD v12[4];

  v2 = sub_1001D55BC(*(void **)(*(_QWORD *)(a1 + 32) + 368), *(unsigned __int16 *)(a1 + 56));
  v3 = *(_QWORD *)(a1 + 40);
  if ((v2 & 1) != 0)
  {
    (*(void (**)(_QWORD, _QWORD))(v3 + 16))(*(_QWORD *)(a1 + 40), 0);
  }
  else
  {
    v4 = objc_alloc((Class)NSError);
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v11[0] = NSLocalizedDescriptionKey;
    v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
    v12[0] = v6;
    v12[1] = &off_1002FF030;
    v11[1] = CFSTR("Line");
    v11[2] = CFSTR("Method");
    v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 48)));
    v12[2] = v7;
    v11[3] = NSDebugDescriptionErrorKey;
    v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 48)), 3310);
    v12[3] = v8;
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v12, v11, 4));
    v10 = objc_msgSend(v4, "initWithDomain:code:userInfo:", v5, 15, v9);
    (*(void (**)(uint64_t, id))(v3 + 16))(v3, v10);

  }
}

void sub_1000F2A04(uint64_t a1)
{
  uint64_t v1;
  void **v2;
  void (**v3)(id, id);
  id v4;
  uint64_t v5;
  id v6;
  void *specific;
  uint64_t Logger;
  void (*v9)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  NSObject *v15;
  objc_class *v16;
  int v17;
  id v18;
  void *v19;
  id v20;
  uint64_t v21;
  id v22;
  id v23;
  id v24;
  void *v25;
  id v26;
  void *v27;
  id v28;
  id v29;
  void *v30;
  id v31;
  id v32;
  void *v33;
  void *v34;
  id v35;
  id v36;
  void *v37;
  const char *ClassName;
  const char *Name;
  NSErrorUserInfoKey v40;
  const __CFString *v41;
  const __CFString *v42;
  const __CFString *v43;
  NSErrorUserInfoKey v44;
  uint8_t buf[8];
  _BYTE v46[36];

  v1 = *(unsigned __int16 *)(a1 + 48);
  v2 = *(void ***)(a1 + 32);
  v3 = (void (**)(id, id))*(id *)(a1 + 40);
  if (v2)
  {
    if (-[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)v2) == 2)
    {
      v4 = sub_1001F84C8(v2[46], CFSTR("GPIO toggle"), 1uLL);
      v5 = objc_claimAutoreleasedReturnValue(v4);
      if (!v5)
      {
        if ((sub_1001D5634(v2[46], v1) & 1) != 0)
        {
          v6 = 0;
        }
        else
        {
          v32 = objc_alloc((Class)NSError);
          v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
          v40 = NSLocalizedDescriptionKey;
          v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
          *(_QWORD *)buf = v34;
          *(_QWORD *)v46 = &off_1002FF078;
          v41 = CFSTR("Line");
          v42 = CFSTR("Method");
          v35 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_toggleGPIO:completion:"));
          *(_QWORD *)&v46[8] = v35;
          v43 = (const __CFString *)NSDebugDescriptionErrorKey;
          v36 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_toggleGPIO:completion:"), 3344);
          *(_QWORD *)&v46[16] = v36;
          v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v40, 4));
          v6 = objc_msgSend(v32, "initWithDomain:code:userInfo:", v33, 15, v37);

        }
        v3[2](v3, v6);
        sub_1001FABB8(v2[46], CFSTR("GPIO toggle"));
        goto LABEL_21;
      }
      v6 = (id)v5;
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v9 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(v2);
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(v2);
        Name = sel_getName("_sync_toggleGPIO:completion:");
        v12 = 45;
        if (isMetaClass)
          v12 = 43;
        v9(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v12, ClassName, Name, 3337, v6);
      }
      v13 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v14 = NFSharedLogGetLogger(v13);
      v15 = objc_claimAutoreleasedReturnValue(v14);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        v16 = object_getClass(v2);
        if (class_isMetaClass(v16))
          v17 = 43;
        else
          v17 = 45;
        *(_DWORD *)buf = 67110146;
        *(_DWORD *)&buf[4] = v17;
        *(_WORD *)v46 = 2082;
        *(_QWORD *)&v46[2] = object_getClassName(v2);
        *(_WORD *)&v46[10] = 2082;
        *(_QWORD *)&v46[12] = sel_getName("_sync_toggleGPIO:completion:");
        *(_WORD *)&v46[20] = 1024;
        *(_DWORD *)&v46[22] = 3337;
        *(_WORD *)&v46[26] = 2112;
        *(_QWORD *)&v46[28] = v6;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
      }

      v18 = objc_alloc((Class)NSError);
      v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v20 = objc_msgSend(v6, "code");
      v40 = NSLocalizedDescriptionKey;
      if ((uint64_t)objc_msgSend(v6, "code") > 70)
        v21 = 71;
      else
        v21 = (uint64_t)objc_msgSend(v6, "code");
      v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E7F70[v21]));
      *(_QWORD *)buf = v27;
      *(_QWORD *)v46 = v6;
      v41 = (const __CFString *)NSUnderlyingErrorKey;
      v42 = CFSTR("Line");
      *(_QWORD *)&v46[8] = &off_1002FF060;
      v43 = CFSTR("Method");
      v28 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_toggleGPIO:completion:"));
      *(_QWORD *)&v46[16] = v28;
      v44 = NSDebugDescriptionErrorKey;
      v29 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_toggleGPIO:completion:"), 3338);
      *(_QWORD *)&v46[24] = v29;
      v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v40, 5));
      v31 = objc_msgSend(v18, "initWithDomain:code:userInfo:", v19, v20, v30);
      v3[2](v3, v31);

    }
    else
    {
      v22 = objc_alloc((Class)NSError);
      v6 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v40 = NSLocalizedDescriptionKey;
      v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
      *(_QWORD *)buf = v19;
      *(_QWORD *)v46 = &off_1002FF048;
      v41 = CFSTR("Line");
      v42 = CFSTR("Method");
      v23 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_toggleGPIO:completion:"));
      *(_QWORD *)&v46[8] = v23;
      v43 = (const __CFString *)NSDebugDescriptionErrorKey;
      v24 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_toggleGPIO:completion:"), 3331);
      *(_QWORD *)&v46[16] = v24;
      v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v40, 4));
      v26 = objc_msgSend(v22, "initWithDomain:code:userInfo:", v6, 58, v25);
      v3[2](v3, v26);

    }
LABEL_21:

  }
}

void sub_1000F30E4(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  id v3;
  id v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  void (*v10)(uint64_t, const char *, ...);
  objc_class *v11;
  _BOOL4 v12;
  const char *v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  NSObject *v17;
  objc_class *v18;
  int v19;
  void *v20;
  void *v21;
  uint64_t v22;
  void (*v23)(uint64_t, const char *, ...);
  objc_class *v24;
  _BOOL4 v25;
  const char *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  NSObject *v30;
  objc_class *v31;
  int v32;
  id v33;
  void *v34;
  void *v35;
  id v36;
  void *specific;
  uint64_t Logger;
  void (*v39)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  uint64_t v44;
  void *v45;
  uint64_t v46;
  NSObject *v47;
  objc_class *v48;
  int v49;
  const char *v50;
  const char *v51;
  uint64_t v52;
  id v53;
  void *v54;
  void *v55;
  id v56;
  const char *v57;
  const char *v58;
  uint8_t buf[8];
  __int16 v60;
  const char *v61;
  __int16 v62;
  const char *v63;
  __int16 v64;
  int v65;
  __int16 v66;
  uint64_t v67;
  NSErrorUserInfoKey v68;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(void **)(a1 + 48);
  v3 = *(id *)(a1 + 40);
  v4 = v2;
  if (v1)
  {
    if (-[_NFHardwareManager getPrimaryHardwareState]_0(v1) == 2
      || -[_NFHardwareManager getPrimaryHardwareState]_0(v1) == 5)
    {
      v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "NF_whitelistChecker"));
      if ((objc_msgSend(v5, "hceAccess") & 1) != 0)
      {
        v6 = *(_QWORD *)(v1 + 112);
        if (!v6
          || (v7 = objc_opt_class(_NFLoyaltyAndPaymentSession), (objc_opt_isKindOfClass(v6, v7) & 1) == 0))
        {
          specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          Logger = NFLogGetLogger(specific);
          if (Logger)
          {
            v39 = (void (*)(uint64_t, const char *, ...))Logger;
            Class = object_getClass((id)v1);
            isMetaClass = class_isMetaClass(Class);
            ClassName = object_getClassName((id)v1);
            Name = sel_getName("_sync_getHostCardEmulationLogForConnection:completion:");
            v44 = 45;
            if (isMetaClass)
              v44 = 43;
            v39(6, "%c[%{public}s %{public}s]:%i %{public}@", v44, ClassName, Name, 3380, *(_QWORD *)(v1 + 200));
          }
          v45 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v46 = NFSharedLogGetLogger(v45);
          v47 = objc_claimAutoreleasedReturnValue(v46);
          if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
          {
            v48 = object_getClass((id)v1);
            if (class_isMetaClass(v48))
              v49 = 43;
            else
              v49 = 45;
            v50 = object_getClassName((id)v1);
            v51 = sel_getName("_sync_getHostCardEmulationLogForConnection:completion:");
            v52 = *(_QWORD *)(v1 + 200);
            *(_DWORD *)buf = 67110146;
            *(_DWORD *)&buf[4] = v49;
            v60 = 2082;
            v61 = v50;
            v62 = 2082;
            v63 = v51;
            v64 = 1024;
            v65 = 3380;
            v66 = 2114;
            v67 = v52;
            _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
          }

          (*((void (**)(id, _QWORD, _QWORD))v4 + 2))(v4, *(_QWORD *)(v1 + 200), 0);
          goto LABEL_39;
        }
        v8 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v9 = NFLogGetLogger(v8);
        if (v9)
        {
          v10 = (void (*)(uint64_t, const char *, ...))v9;
          v11 = object_getClass((id)v1);
          v12 = class_isMetaClass(v11);
          v13 = object_getClassName((id)v1);
          v57 = sel_getName("_sync_getHostCardEmulationLogForConnection:completion:");
          v14 = 45;
          if (v12)
            v14 = 43;
          v10(6, "%c[%{public}s %{public}s]:%i Getting host card emulation log from session", v14, v13, v57, 3375);
        }
        v15 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v16 = NFSharedLogGetLogger(v15);
        v17 = objc_claimAutoreleasedReturnValue(v16);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          v18 = object_getClass((id)v1);
          if (class_isMetaClass(v18))
            v19 = 43;
          else
            v19 = 45;
          *(_DWORD *)buf = 67109890;
          *(_DWORD *)&buf[4] = v19;
          v60 = 2082;
          v61 = object_getClassName((id)v1);
          v62 = 2082;
          v63 = sel_getName("_sync_getHostCardEmulationLogForConnection:completion:");
          v64 = 1024;
          v65 = 3375;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Getting host card emulation log from session", buf, 0x22u);
        }

        v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v1 + 112), "hostCardEmulationLog"));
        (*((void (**)(id, void *, _QWORD))v4 + 2))(v4, v20, 0);
      }
      else
      {
        v21 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v22 = NFLogGetLogger(v21);
        if (v22)
        {
          v23 = (void (*)(uint64_t, const char *, ...))v22;
          v24 = object_getClass((id)v1);
          v25 = class_isMetaClass(v24);
          v26 = object_getClassName((id)v1);
          v58 = sel_getName("_sync_getHostCardEmulationLogForConnection:completion:");
          v27 = 45;
          if (v25)
            v27 = 43;
          v23(3, "%c[%{public}s %{public}s]:%i Invalid entitlements, requiring HCE access", v27, v26, v58, 3369);
        }
        v28 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v29 = NFSharedLogGetLogger(v28);
        v30 = objc_claimAutoreleasedReturnValue(v29);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        {
          v31 = object_getClass((id)v1);
          if (class_isMetaClass(v31))
            v32 = 43;
          else
            v32 = 45;
          *(_DWORD *)buf = 67109890;
          *(_DWORD *)&buf[4] = v32;
          v60 = 2082;
          v61 = object_getClassName((id)v1);
          v62 = 2082;
          v63 = sel_getName("_sync_getHostCardEmulationLogForConnection:completion:");
          v64 = 1024;
          v65 = 3369;
          _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid entitlements, requiring HCE access", buf, 0x22u);
        }

        v33 = objc_alloc((Class)NSError);
        v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v68 = NSLocalizedDescriptionKey;
        v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Not entitled"));
        *(_QWORD *)buf = v34;
        v35 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v68, 1));
        v36 = objc_msgSend(v33, "initWithDomain:code:userInfo:", v20, 32, v35);
        (*((void (**)(id, _QWORD, id))v4 + 2))(v4, 0, v36);

      }
    }
    else
    {
      v53 = objc_alloc((Class)NSError);
      v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v68 = NSLocalizedDescriptionKey;
      v54 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
      *(_QWORD *)buf = v54;
      v55 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v68, 1));
      v56 = objc_msgSend(v53, "initWithDomain:code:userInfo:", v5, 58, v55);
      (*((void (**)(id, _QWORD, id))v4 + 2))(v4, 0, v56);

    }
LABEL_39:

  }
}

void sub_1000F3830(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  NSObject *v11;
  objc_class *v12;
  int v13;
  const char *v14;
  const char *v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  const char *Name;
  uint8_t buf[4];
  int v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    v8 = 45;
    if (isMetaClass)
      v8 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i ", v8, ClassName, Name, 3400);
  }
  v9 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v10 = NFSharedLogGetLogger(v9);
  v11 = objc_claimAutoreleasedReturnValue(v10);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v12 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v12))
      v13 = 43;
    else
      v13 = 45;
    v14 = object_getClassName(*(id *)(a1 + 32));
    v15 = sel_getName(*(SEL *)(a1 + 56));
    *(_DWORD *)buf = 67109890;
    v22 = v13;
    v23 = 2082;
    v24 = v14;
    v25 = 2082;
    v26 = v15;
    v27 = 1024;
    v28 = 3400;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
  }

  v16 = sub_10020218C(*(_QWORD **)(*(_QWORD *)(a1 + 32) + 368), *(void **)(a1 + 40));
  v17 = objc_claimAutoreleasedReturnValue(v16);
  v18 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
  v19 = *(void **)(v18 + 40);
  *(_QWORD *)(v18 + 40) = v17;

}

id sub_1000F39CC(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "maybeStartNextSession");
}

void sub_1000F3F30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_1000F3F68(uint64_t a1)
{
  id v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  id v6;
  void *v7;
  void *v8;
  void *v9;
  id v10;
  uint64_t v11;
  void *v12;
  NSErrorUserInfoKey v14;
  void *v15;

  if (objc_msgSend(*(id *)(a1 + 32), "isEqual:", *(_QWORD *)(*(_QWORD *)(a1 + 40) + 376)))
  {
    v2 = sub_1000271E0(*(void **)(*(_QWORD *)(a1 + 40) + 368), 1);
    v3 = objc_claimAutoreleasedReturnValue(v2);
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
    v5 = *(void **)(v4 + 40);
    *(_QWORD *)(v4 + 40) = v3;

  }
  else
  {
    v6 = objc_alloc((Class)NSError);
    v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v14 = NSLocalizedDescriptionKey;
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "SE not available"));
    v15 = v8;
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v15, &v14, 1));
    v10 = objc_msgSend(v6, "initWithDomain:code:userInfo:", v7, 35, v9);
    v11 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
    v12 = *(void **)(v11 + 40);
    *(_QWORD *)(v11 + 40) = v10;

  }
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40) == 0;
}

void sub_1000F414C(uint64_t a1)
{
  id v2;
  void *v3;
  void *v4;
  void *v5;
  id v6;
  uint64_t v7;
  id v8;
  void *v9;
  void *v10;
  id v11;
  NSErrorUserInfoKey v12;
  void *v13;
  NSErrorUserInfoKey v14;
  void *v15;

  if (-[_NFHardwareManager getPrimaryHardwareState]_0(*(_QWORD *)(a1 + 32)) == 2)
  {
    v2 = objc_alloc((Class)NSError);
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v12 = NSLocalizedDescriptionKey;
    v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Feature Not Supported"));
    v13 = v4;
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v13, &v12, 1));
    v6 = objc_msgSend(v2, "initWithDomain:code:userInfo:", v3, 14, v5);

    (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
  }
  else
  {
    v7 = *(_QWORD *)(a1 + 40);
    v8 = objc_alloc((Class)NSError);
    v6 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v14 = NSLocalizedDescriptionKey;
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
    v15 = v9;
    v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v15, &v14, 1));
    v11 = objc_msgSend(v8, "initWithDomain:code:userInfo:", v6, 58, v10);
    (*(void (**)(uint64_t, id))(v7 + 16))(v7, v11);

  }
}

void sub_1000F439C(uint64_t a1)
{
  id v2;
  void *v3;
  void *v4;
  void *v5;
  id v6;
  uint64_t v7;
  id v8;
  void *v9;
  void *v10;
  id v11;
  NSErrorUserInfoKey v12;
  void *v13;
  NSErrorUserInfoKey v14;
  void *v15;

  if (-[_NFHardwareManager getPrimaryHardwareState]_0(*(_QWORD *)(a1 + 32)) == 2)
  {
    v2 = objc_alloc((Class)NSError);
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v12 = NSLocalizedDescriptionKey;
    v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Feature Not Supported"));
    v13 = v4;
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v13, &v12, 1));
    v6 = objc_msgSend(v2, "initWithDomain:code:userInfo:", v3, 14, v5);

    (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
  }
  else
  {
    v7 = *(_QWORD *)(a1 + 40);
    v8 = objc_alloc((Class)NSError);
    v6 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v14 = NSLocalizedDescriptionKey;
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
    v15 = v9;
    v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v15, &v14, 1));
    v11 = objc_msgSend(v8, "initWithDomain:code:userInfo:", v6, 58, v10);
    (*(void (**)(uint64_t, id))(v7 + 16))(v7, v11);

  }
}

void sub_1000F45EC(uint64_t a1)
{
  void *v2;
  id v3;
  uint64_t v4;
  id v5;
  void *v6;
  void *v7;
  id v8;
  id v9;
  NSErrorUserInfoKey v10;
  void *v11;

  if (-[_NFHardwareManager getPrimaryHardwareState]_0(*(_QWORD *)(a1 + 32)) == 2)
  {
    v2 = *(void **)(a1 + 32);
    v9 = 0;
    objc_msgSend(v2, "nfcRadioEnabled:showUIPopup:", &v9, 0);
    v3 = v9;
    (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
  }
  else
  {
    v4 = *(_QWORD *)(a1 + 40);
    v5 = objc_alloc((Class)NSError);
    v3 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v10 = NSLocalizedDescriptionKey;
    v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
    v11 = v6;
    v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v11, &v10, 1));
    v8 = objc_msgSend(v5, "initWithDomain:code:userInfo:", v3, 58, v7);
    (*(void (**)(uint64_t, _QWORD, id))(v4 + 16))(v4, 0, v8);

  }
}

void sub_1000F4814(uint64_t a1)
{
  void *v2;
  id v3;
  id v4;
  id v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  void (*v11)(uint64_t, const char *, ...);
  objc_class *v12;
  _BOOL4 v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  NSObject *v19;
  objc_class *v20;
  int v21;
  const char *v22;
  const char *v23;
  int v24;
  void *v25;
  void *v26;
  id *v27;
  void *v28;
  void *v29;
  id v30;
  id v31;
  uint64_t v32;
  void *i;
  __CFString *v34;
  uint64_t v35;
  id v36;
  id v37;
  void *specific;
  uint64_t Logger;
  void (*v40)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v44;
  void *v45;
  uint64_t v46;
  NSObject *v47;
  objc_class *v48;
  int v49;
  const char *v50;
  const char *v51;
  uint64_t v52;
  id v53;
  void **v54;
  NSErrorUserInfoKey *v55;
  void *v56;
  uint64_t v57;
  void (*v58)(uint64_t, const char *, ...);
  objc_class *v59;
  _BOOL4 v60;
  const char *v61;
  uint64_t v62;
  void *v63;
  uint64_t v64;
  NSObject *v65;
  objc_class *v66;
  int v67;
  const char *v68;
  const char *v69;
  void *v70;
  id v71;
  void *v72;
  uint64_t v73;
  void (*v74)(uint64_t, const char *, ...);
  objc_class *v75;
  _BOOL4 v76;
  const char *v77;
  uint64_t v78;
  void *v79;
  uint64_t v80;
  NSObject *v81;
  objc_class *v82;
  int v83;
  const char *v84;
  const char *v85;
  uint64_t v86;
  void *v87;
  unsigned int v88;
  void *v89;
  uint64_t v90;
  void (*v91)(uint64_t, const char *, ...);
  objc_class *v92;
  _BOOL4 v93;
  const char *v94;
  const char *v95;
  const __CFString *v96;
  uint64_t v97;
  void *v98;
  uint64_t v99;
  NSObject *v100;
  objc_class *v101;
  int v102;
  const char *v103;
  const char *v104;
  const __CFString *v105;
  uint64_t v106;
  id v107;
  void *v108;
  id v109;
  const char *Name;
  const char *v111;
  const char *v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  _BYTE v117[128];
  const __CFString *v118;
  void *v119;
  NSErrorUserInfoKey v120;
  void *v121;
  uint8_t buf[4];
  int v123;
  __int16 v124;
  const char *v125;
  __int16 v126;
  const char *v127;
  __int16 v128;
  int v129;
  __int16 v130;
  const __CFString *v131;
  NSErrorUserInfoKey v132;
  void *v133;
  NSErrorUserInfoKey v134;
  void *v135;
  NSErrorUserInfoKey v136;
  id v137;

  if (-[_NFHardwareManager getPrimaryHardwareState]_0(*(_QWORD *)(a1 + 32)) != 2)
  {
    v35 = *(_QWORD *)(a1 + 48);
    v36 = objc_alloc((Class)NSError);
    v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v136 = NSLocalizedDescriptionKey;
    v3 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
    v137 = v3;
    v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v137, &v136, 1));
    v37 = objc_msgSend(v36, "initWithDomain:code:userInfo:", v2, 58, v28);
    (*(void (**)(uint64_t, id))(v35 + 16))(v35, v37);

    goto LABEL_55;
  }
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "NF_whitelistChecker"));
  if ((objc_msgSend(v2, "radioToggle") & 1) == 0)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v40 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      v44 = 45;
      if (isMetaClass)
        v44 = 43;
      v40(3, "%c[%{public}s %{public}s]:%i Invalid entitlements, missing radio toggle", v44, ClassName, Name, 3908);
    }
    v45 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v46 = NFSharedLogGetLogger(v45);
    v47 = objc_claimAutoreleasedReturnValue(v46);
    if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
    {
      v48 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v48))
        v49 = 43;
      else
        v49 = 45;
      v50 = object_getClassName(*(id *)(a1 + 32));
      v51 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)buf = 67109890;
      v123 = v49;
      v124 = 2082;
      v125 = v50;
      v126 = 2082;
      v127 = v51;
      v128 = 1024;
      v129 = 3908;
      _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid entitlements, missing radio toggle", buf, 0x22u);
    }

    v52 = *(_QWORD *)(a1 + 48);
    v53 = objc_alloc((Class)NSError);
    v3 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v134 = NSLocalizedDescriptionKey;
    v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Not entitled"));
    v135 = v28;
    v54 = &v135;
    v55 = &v134;
    goto LABEL_53;
  }
  if (*(_QWORD *)(*(_QWORD *)(a1 + 32) + 288) == -1)
  {
    v56 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v57 = NFLogGetLogger(v56);
    if (v57)
    {
      v58 = (void (*)(uint64_t, const char *, ...))v57;
      v59 = object_getClass(*(id *)(a1 + 32));
      v60 = class_isMetaClass(v59);
      v61 = object_getClassName(*(id *)(a1 + 32));
      v111 = sel_getName(*(SEL *)(a1 + 56));
      v62 = 45;
      if (v60)
        v62 = 43;
      v58(3, "%c[%{public}s %{public}s]:%i Radio disabled by mobileconfig", v62, v61, v111, 3914);
    }
    v63 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v64 = NFSharedLogGetLogger(v63);
    v65 = objc_claimAutoreleasedReturnValue(v64);
    if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
    {
      v66 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v66))
        v67 = 43;
      else
        v67 = 45;
      v68 = object_getClassName(*(id *)(a1 + 32));
      v69 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)buf = 67109890;
      v123 = v67;
      v124 = 2082;
      v125 = v68;
      v126 = 2082;
      v127 = v69;
      v128 = 1024;
      v129 = 3914;
      _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Radio disabled by mobileconfig", buf, 0x22u);
    }

    v52 = *(_QWORD *)(a1 + 48);
    v53 = objc_alloc((Class)NSError);
    v3 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v132 = NSLocalizedDescriptionKey;
    v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Not entitled"));
    v133 = v28;
    v54 = &v133;
    v55 = &v132;
LABEL_53:
    v70 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v54, v55, 1));
    v71 = objc_msgSend(v53, "initWithDomain:code:userInfo:", v3, 32, v70);
    (*(void (**)(uint64_t, id))(v52 + 16))(v52, v71);

LABEL_54:
    goto LABEL_55;
  }
  v3 = objc_msgSend(objc_alloc((Class)NSUserDefaults), "initWithSuiteName:", CFSTR("com.apple.stockholm"));
  if ((NFIsChinaSku(v3) & 1) == 0)
  {
    v72 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v73 = NFLogGetLogger(v72);
    if (v73)
    {
      v74 = (void (*)(uint64_t, const char *, ...))v73;
      v75 = object_getClass(*(id *)(a1 + 32));
      v76 = class_isMetaClass(v75);
      v77 = object_getClassName(*(id *)(a1 + 32));
      v112 = sel_getName(*(SEL *)(a1 + 56));
      v78 = 45;
      if (v76)
        v78 = 43;
      v74(3, "%c[%{public}s %{public}s]:%i Feature not supported on this device", v78, v77, v112, 3922);
    }
    v79 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v80 = NFSharedLogGetLogger(v79);
    v81 = objc_claimAutoreleasedReturnValue(v80);
    if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
    {
      v82 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v82))
        v83 = 43;
      else
        v83 = 45;
      v84 = object_getClassName(*(id *)(a1 + 32));
      v85 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)buf = 67109890;
      v123 = v83;
      v124 = 2082;
      v125 = v84;
      v126 = 2082;
      v127 = v85;
      v128 = 1024;
      v129 = 3922;
      _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Feature not supported on this device", buf, 0x22u);
    }

    if (!NFIsInternalBuild(v86))
      goto LABEL_82;
    v87 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKey:", CFSTR("forceChinaSku")));

    if (!v87)
      goto LABEL_82;
    v88 = objc_msgSend(v3, "BOOLForKey:", CFSTR("forceChinaSku"));
    v89 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v90 = NFLogGetLogger(v89);
    if (v90)
    {
      v91 = (void (*)(uint64_t, const char *, ...))v90;
      v92 = object_getClass(*(id *)(a1 + 32));
      v93 = class_isMetaClass(v92);
      v94 = object_getClassName(*(id *)(a1 + 32));
      v95 = sel_getName(*(SEL *)(a1 + 56));
      if (v88)
        v96 = CFSTR("on");
      else
        v96 = CFSTR("off");
      v97 = 45;
      if (v93)
        v97 = 43;
      v91(5, "%c[%{public}s %{public}s]:%i Force China Sku: %{public}@", v97, v94, v95, 3928, v96);
    }
    v98 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v99 = NFSharedLogGetLogger(v98);
    v100 = objc_claimAutoreleasedReturnValue(v99);
    if (os_log_type_enabled(v100, OS_LOG_TYPE_DEFAULT))
    {
      v101 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v101))
        v102 = 43;
      else
        v102 = 45;
      v103 = object_getClassName(*(id *)(a1 + 32));
      v104 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)buf = 67110146;
      v105 = CFSTR("on");
      if (!v88)
        v105 = CFSTR("off");
      v123 = v102;
      v124 = 2082;
      v125 = v103;
      v126 = 2082;
      v127 = v104;
      v128 = 1024;
      v129 = 3928;
      v130 = 2114;
      v131 = v105;
      _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Force China Sku: %{public}@", buf, 0x2Cu);
    }

    if ((v88 & 1) == 0)
    {
LABEL_82:
      v106 = *(_QWORD *)(a1 + 48);
      v107 = objc_alloc((Class)NSError);
      v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v120 = NSLocalizedDescriptionKey;
      v70 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Feature Not Supported"));
      v121 = v70;
      v108 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v121, &v120, 1));
      v109 = objc_msgSend(v107, "initWithDomain:code:userInfo:", v28, 14, v108);
      (*(void (**)(uint64_t, id))(v106 + 16))(v106, v109);

      goto LABEL_54;
    }
  }
  objc_msgSend(v3, "setBool:forKey:", *(unsigned __int8 *)(a1 + 64), CFSTR("nfcRadioEnabled"));
  objc_msgSend(v3, "synchronize");
  if (!*(_BYTE *)(a1 + 64))
    v4 = sub_10003F7D8(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 24), 0);
  v5 = *(id *)(a1 + 32);
  objc_sync_enter(v5);
  v6 = *(_QWORD *)(a1 + 32);
  v7 = *(_QWORD *)(v6 + 288);
  v8 = *(unsigned __int8 *)(a1 + 64);
  *(_QWORD *)(v6 + 288) = v8;
  objc_sync_exit(v5);

  v9 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v10 = NFLogGetLogger(v9);
  if (v10)
  {
    v11 = (void (*)(uint64_t, const char *, ...))v10;
    v12 = object_getClass(*(id *)(a1 + 32));
    v13 = class_isMetaClass(v12);
    v14 = object_getClassName(*(id *)(a1 + 32));
    v15 = sel_getName(*(SEL *)(a1 + 56));
    v16 = 45;
    if (v13)
      v16 = 43;
    v11(6, "%c[%{public}s %{public}s]:%i %d", v16, v14, v15, 3952, *(unsigned __int8 *)(a1 + 64));
  }
  v17 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v18 = NFSharedLogGetLogger(v17);
  v19 = objc_claimAutoreleasedReturnValue(v18);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    v20 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v20))
      v21 = 43;
    else
      v21 = 45;
    v22 = object_getClassName(*(id *)(a1 + 32));
    v23 = sel_getName(*(SEL *)(a1 + 56));
    v24 = *(unsigned __int8 *)(a1 + 64);
    *(_DWORD *)buf = 67110146;
    v123 = v21;
    v124 = 2082;
    v125 = v22;
    v126 = 2082;
    v127 = v23;
    v128 = 1024;
    v129 = 3952;
    v130 = 1024;
    LODWORD(v131) = v24;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %d", buf, 0x28u);
  }

  v118 = CFSTR("radioIsEnabled");
  if (*(_QWORD *)(*(_QWORD *)(a1 + 32) + 288) == 1)
    v25 = &__kCFBooleanTrue;
  else
    v25 = &__kCFBooleanFalse;
  v119 = v25;
  v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v119, &v118, 1));
  +[NFGeneralStatisticsCALogger updateGeneralDeviceStatistic:](NFGeneralStatisticsCALogger, "updateGeneralDeviceStatistic:", v26);

  if (v7 != v8)
    +[NFGeneralStatisticsCALogger updateAnalyticsGeneralTransactionStatistics:](NFGeneralStatisticsCALogger, "updateAnalyticsGeneralTransactionStatistics:", &off_100306600);
  (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
  v27 = sub_100007A04(*(id **)(a1 + 32));
  v28 = (void *)objc_claimAutoreleasedReturnValue(v27);
  v113 = 0u;
  v114 = 0u;
  v115 = 0u;
  v116 = 0u;
  v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "allValues"));
  v30 = objc_msgSend(v29, "countByEnumeratingWithState:objects:count:", &v113, v117, 16);
  if (v30)
  {
    v31 = v30;
    v32 = *(_QWORD *)v114;
    do
    {
      for (i = 0; i != v31; i = (char *)i + 1)
      {
        if (*(_QWORD *)v114 != v32)
          objc_enumerationMutation(v29);
        objc_msgSend(*(id *)(*((_QWORD *)&v113 + 1) + 8 * (_QWORD)i), "didChangeRadioState:", *(unsigned __int8 *)(a1 + 64));
      }
      v31 = objc_msgSend(v29, "countByEnumeratingWithState:objects:count:", &v113, v117, 16);
    }
    while (v31);
  }

  if (*(_BYTE *)(a1 + 64))
    v34 = CFSTR("1");
  else
    v34 = CFSTR("0");
  sub_1000EC8E8(*(void **)(a1 + 32), (uint64_t)"com.apple.stockhom.radio.stateChanged", v34);
  objc_msgSend(*(id *)(a1 + 32), "maybeStartNextSession");
LABEL_55:

}

void sub_1000F53D4(uint64_t a1)
{
  id v2;
  uint64_t v3;
  void *v4;
  void *specific;
  uint64_t Logger;
  void (*v7)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  id v19;
  void *v20;
  id v21;
  uint64_t v22;
  uint64_t v23;
  id v24;
  void *v25;
  id v26;
  id v27;
  void *v28;
  id v29;
  id v30;
  uint64_t v31;
  id v32;
  void *v33;
  id v34;
  uint64_t v35;
  void *v36;
  id v37;
  id v38;
  void *v39;
  id v40;
  void *v41;
  id v42;
  id v43;
  void *v44;
  id v45;
  const char *ClassName;
  const char *Name;
  double v48;
  _QWORD v49[5];
  _QWORD v50[5];
  _QWORD v51[5];
  _QWORD v52[5];
  uint8_t buf[4];
  int v54;
  __int16 v55;
  const char *v56;
  __int16 v57;
  const char *v58;
  __int16 v59;
  int v60;
  __int16 v61;
  void *v62;
  _QWORD v63[4];
  _QWORD v64[4];

  v48 = 0.0;
  if (-[_NFHardwareManager getPrimaryHardwareState]_0(*(_QWORD *)(a1 + 32)) == 2)
  {
    v2 = sub_1001F84C8(*(void **)(*(_QWORD *)(a1 + 32) + 368), CFSTR("GetTemperature"), 1uLL);
    v3 = objc_claimAutoreleasedReturnValue(v2);
    if (v3)
    {
      v4 = (void *)v3;
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v7 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(*(id *)(a1 + 32));
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(*(id *)(a1 + 32));
        Name = sel_getName(*(SEL *)(a1 + 48));
        v10 = 45;
        if (isMetaClass)
          v10 = 43;
        v7(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v10, ClassName, Name, 3990, v4);
      }
      v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v12 = NFSharedLogGetLogger(v11);
      v13 = objc_claimAutoreleasedReturnValue(v12);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        v14 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v14))
          v15 = 43;
        else
          v15 = 45;
        v16 = object_getClassName(*(id *)(a1 + 32));
        v17 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)buf = 67110146;
        v54 = v15;
        v55 = 2082;
        v56 = v16;
        v57 = 2082;
        v58 = v17;
        v59 = 1024;
        v60 = 3990;
        v61 = 2112;
        v62 = v4;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
      }

      v18 = *(_QWORD *)(a1 + 40);
      v19 = objc_alloc((Class)NSError);
      v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v21 = objc_msgSend(v4, "code");
      v51[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)objc_msgSend(v4, "code") > 70)
        v22 = 71;
      else
        v22 = (uint64_t)objc_msgSend(v4, "code");
      v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E7F70[v22]));
      v52[0] = v36;
      v52[1] = v4;
      v51[1] = NSUnderlyingErrorKey;
      v51[2] = CFSTR("Line");
      v52[2] = &off_1002FF0A8;
      v51[3] = CFSTR("Method");
      v37 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 48)));
      v52[3] = v37;
      v51[4] = NSDebugDescriptionErrorKey;
      v38 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 48)), 3991);
      v52[4] = v38;
      v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v52, v51, 5));
      v40 = objc_msgSend(v19, "initWithDomain:code:userInfo:", v20, v21, v39);
      (*(void (**)(uint64_t, id, double))(v18 + 16))(v18, v40, 0.0);

    }
    else
    {
      v30 = sub_1001FFCA0(*(void **)(*(_QWORD *)(a1 + 32) + 368), (uint64_t)&v48);
      v4 = (void *)objc_claimAutoreleasedReturnValue(v30);
      v31 = *(_QWORD *)(a1 + 40);
      if (v4)
      {
        v32 = objc_alloc((Class)NSError);
        v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v34 = objc_msgSend(v4, "code");
        v49[0] = NSLocalizedDescriptionKey;
        if ((uint64_t)objc_msgSend(v4, "code") > 70)
          v35 = 71;
        else
          v35 = (uint64_t)objc_msgSend(v4, "code");
        v41 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E7F70[v35]));
        v50[0] = v41;
        v50[1] = v4;
        v49[1] = NSUnderlyingErrorKey;
        v49[2] = CFSTR("Line");
        v50[2] = &off_1002FF0C0;
        v49[3] = CFSTR("Method");
        v42 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 48)));
        v50[3] = v42;
        v49[4] = NSDebugDescriptionErrorKey;
        v43 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 48)), 3997);
        v50[4] = v43;
        v44 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v50, v49, 5));
        v45 = objc_msgSend(v32, "initWithDomain:code:userInfo:", v33, v34, v44);
        (*(void (**)(uint64_t, id, double))(v31 + 16))(v31, v45, 0.0);

      }
      else
      {
        (*(void (**)(_QWORD, _QWORD, double))(v31 + 16))(*(_QWORD *)(a1 + 40), 0, v48);
      }
      sub_1001FABB8(*(void **)(*(_QWORD *)(a1 + 32) + 368), CFSTR("GetTemperature"));
    }
  }
  else
  {
    v23 = *(_QWORD *)(a1 + 40);
    v24 = objc_alloc((Class)NSError);
    v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v63[0] = NSLocalizedDescriptionKey;
    v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
    v64[0] = v25;
    v64[1] = &off_1002FF090;
    v63[1] = CFSTR("Line");
    v63[2] = CFSTR("Method");
    v26 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 48)));
    v64[2] = v26;
    v63[3] = NSDebugDescriptionErrorKey;
    v27 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 48)), 3984);
    v64[3] = v27;
    v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v64, v63, 4));
    v29 = objc_msgSend(v24, "initWithDomain:code:userInfo:", v4, 58, v28);
    (*(void (**)(uint64_t, id, double))(v23 + 16))(v23, v29, 0.0);

  }
}

void sub_1000F5AF4(uint64_t a1)
{
  sub_1000F5B00(*(void ***)(a1 + 32), *(void **)(a1 + 40));
}

void sub_1000F5B00(void **a1, void *a2)
{
  id v3;
  id v4;
  uint64_t v5;
  void *v6;
  void *specific;
  uint64_t Logger;
  void (*v9)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  NSObject *v15;
  objc_class *v16;
  int v17;
  id v18;
  void *v19;
  id v20;
  uint64_t v21;
  id v22;
  id v23;
  id v24;
  void *v25;
  id v26;
  id v27;
  id v28;
  void *v29;
  id v30;
  uint64_t v31;
  void *v32;
  id v33;
  id v34;
  void *v35;
  id v36;
  void *v37;
  id v38;
  id v39;
  void *v40;
  id v41;
  const char *ClassName;
  const char *Name;
  _QWORD v44[5];
  _QWORD v45[5];
  _QWORD v46[5];
  _QWORD v47[5];
  uint8_t buf[8];
  __int16 v49;
  const char *v50;
  __int16 v51;
  const char *v52;
  __int16 v53;
  int v54;
  __int16 v55;
  void *v56;
  _QWORD v57[4];
  _QWORD v58[4];

  v3 = a2;
  if (a1)
  {
    if (-[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)a1) == 2)
    {
      v4 = sub_1001F84C8(a1[46], CFSTR("GetReaderProhibitTimer"), 0);
      v5 = objc_claimAutoreleasedReturnValue(v4);
      if (!v5)
      {
        *(_QWORD *)buf = 0;
        v27 = sub_100029844(a1[46], (uint64_t)buf);
        v6 = (void *)objc_claimAutoreleasedReturnValue(v27);
        if (v6)
        {
          v28 = objc_alloc((Class)NSError);
          v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
          v30 = objc_msgSend(v6, "code");
          v44[0] = NSLocalizedDescriptionKey;
          if ((uint64_t)objc_msgSend(v6, "code") > 70)
            v31 = 71;
          else
            v31 = (uint64_t)objc_msgSend(v6, "code");
          v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E7F70[v31]));
          v45[0] = v37;
          v45[1] = v6;
          v44[1] = NSUnderlyingErrorKey;
          v44[2] = CFSTR("Line");
          v45[2] = &off_1002FF108;
          v44[3] = CFSTR("Method");
          v38 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_getReaderProhibitTimer:"));
          v45[3] = v38;
          v44[4] = NSDebugDescriptionErrorKey;
          v39 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_getReaderProhibitTimer:"), 4030);
          v45[4] = v39;
          v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v45, v44, 5));
          v41 = objc_msgSend(v28, "initWithDomain:code:userInfo:", v29, v30, v40);
          (*((void (**)(id, _QWORD, _QWORD, _QWORD, id))v3 + 2))(v3, 0, 0, 0, v41);

        }
        else
        {
          (*((void (**)(id, _QWORD, _QWORD, _QWORD, _QWORD))v3 + 2))(v3, buf[0], buf[1], *(unsigned int *)&buf[4], 0);
        }
        sub_1001FABB8(a1[46], CFSTR("GetReaderProhibitTimer"));
        goto LABEL_22;
      }
      v6 = (void *)v5;
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v9 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(a1);
        Name = sel_getName("_sync_getReaderProhibitTimer:");
        v12 = 45;
        if (isMetaClass)
          v12 = 43;
        v9(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v12, ClassName, Name, 4021, v6);
      }
      v13 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v14 = NFSharedLogGetLogger(v13);
      v15 = objc_claimAutoreleasedReturnValue(v14);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        v16 = object_getClass(a1);
        if (class_isMetaClass(v16))
          v17 = 43;
        else
          v17 = 45;
        *(_DWORD *)buf = 67110146;
        *(_DWORD *)&buf[4] = v17;
        v49 = 2082;
        v50 = object_getClassName(a1);
        v51 = 2082;
        v52 = sel_getName("_sync_getReaderProhibitTimer:");
        v53 = 1024;
        v54 = 4021;
        v55 = 2112;
        v56 = v6;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
      }

      v18 = objc_alloc((Class)NSError);
      v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v20 = objc_msgSend(v6, "code");
      v46[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)objc_msgSend(v6, "code") > 70)
        v21 = 71;
      else
        v21 = (uint64_t)objc_msgSend(v6, "code");
      v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E7F70[v21]));
      v47[0] = v32;
      v47[1] = v6;
      v46[1] = NSUnderlyingErrorKey;
      v46[2] = CFSTR("Line");
      v47[2] = &off_1002FF0F0;
      v46[3] = CFSTR("Method");
      v33 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_getReaderProhibitTimer:"));
      v47[3] = v33;
      v46[4] = NSDebugDescriptionErrorKey;
      v34 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_getReaderProhibitTimer:"), 4022);
      v47[4] = v34;
      v35 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v47, v46, 5));
      v36 = objc_msgSend(v18, "initWithDomain:code:userInfo:", v19, v20, v35);
      (*((void (**)(id, _QWORD, _QWORD, _QWORD, id))v3 + 2))(v3, 0, 0, 0, v36);

    }
    else
    {
      v22 = objc_alloc((Class)NSError);
      v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v57[0] = NSLocalizedDescriptionKey;
      v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
      v58[0] = v19;
      v58[1] = &off_1002FF0D8;
      v57[1] = CFSTR("Line");
      v57[2] = CFSTR("Method");
      v23 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_getReaderProhibitTimer:"));
      v58[2] = v23;
      v57[3] = NSDebugDescriptionErrorKey;
      v24 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_getReaderProhibitTimer:"), 4015);
      v58[3] = v24;
      v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v58, v57, 4));
      v26 = objc_msgSend(v22, "initWithDomain:code:userInfo:", v6, 58, v25);
      (*((void (**)(id, _QWORD, _QWORD, _QWORD, id))v3 + 2))(v3, 0, 0, 0, v26);

    }
LABEL_22:

  }
}

void sub_1000F623C(uint64_t a1)
{
  void **v1;
  void (**v2)(id, _QWORD);
  id v3;
  void *v4;
  void *specific;
  uint64_t Logger;
  void (*v7)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  id v16;
  void *v17;
  id v18;
  uint64_t v19;
  id v20;
  id v21;
  id v22;
  void *v23;
  id v24;
  void *v25;
  id v26;
  id v27;
  void *v28;
  id v29;
  const char *ClassName;
  const char *Name;
  NSErrorUserInfoKey v32;
  const __CFString *v33;
  const __CFString *v34;
  const __CFString *v35;
  NSErrorUserInfoKey v36;
  uint8_t buf[8];
  _BYTE v38[36];

  v1 = *(void ***)(a1 + 32);
  v2 = (void (**)(id, _QWORD))*(id *)(a1 + 40);
  if (v1)
  {
    if (-[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)v1) == 2)
    {
      v3 = sub_1001F84C8(v1[46], CFSTR("LPM Debug"), 1uLL);
      v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
      if (!v4)
      {
        sub_1001992F0(v1[46]);
        sub_1001FABB8(v1[46], CFSTR("LPM Debug"));
        v2[2](v2, 0);
LABEL_20:

        goto LABEL_21;
      }
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v7 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(v1);
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(v1);
        Name = sel_getName("_sync_dumpLPMDebugLogWithCompletion:");
        v10 = 45;
        if (isMetaClass)
          v10 = 43;
        v7(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v10, ClassName, Name, 4053, v4);
      }
      v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v12 = NFSharedLogGetLogger(v11);
      v13 = objc_claimAutoreleasedReturnValue(v12);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        v14 = object_getClass(v1);
        if (class_isMetaClass(v14))
          v15 = 43;
        else
          v15 = 45;
        *(_DWORD *)buf = 67110146;
        *(_DWORD *)&buf[4] = v15;
        *(_WORD *)v38 = 2082;
        *(_QWORD *)&v38[2] = object_getClassName(v1);
        *(_WORD *)&v38[10] = 2082;
        *(_QWORD *)&v38[12] = sel_getName("_sync_dumpLPMDebugLogWithCompletion:");
        *(_WORD *)&v38[20] = 1024;
        *(_DWORD *)&v38[22] = 4053;
        *(_WORD *)&v38[26] = 2112;
        *(_QWORD *)&v38[28] = v4;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
      }

      v16 = objc_alloc((Class)NSError);
      v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v18 = objc_msgSend(v4, "code");
      v32 = NSLocalizedDescriptionKey;
      if ((uint64_t)objc_msgSend(v4, "code") > 70)
        v19 = 71;
      else
        v19 = (uint64_t)objc_msgSend(v4, "code");
      v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E7F70[v19]));
      *(_QWORD *)buf = v25;
      *(_QWORD *)v38 = v4;
      v33 = (const __CFString *)NSUnderlyingErrorKey;
      v34 = CFSTR("Line");
      *(_QWORD *)&v38[8] = &off_1002FF138;
      v35 = CFSTR("Method");
      v26 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_dumpLPMDebugLogWithCompletion:"));
      *(_QWORD *)&v38[16] = v26;
      v36 = NSDebugDescriptionErrorKey;
      v27 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_dumpLPMDebugLogWithCompletion:"), 4054);
      *(_QWORD *)&v38[24] = v27;
      v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v32, 5));
      v29 = objc_msgSend(v16, "initWithDomain:code:userInfo:", v17, v18, v28);
      ((void (**)(id, id))v2)[2](v2, v29);

    }
    else
    {
      v20 = objc_alloc((Class)NSError);
      v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v32 = NSLocalizedDescriptionKey;
      v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
      *(_QWORD *)buf = v17;
      *(_QWORD *)v38 = &off_1002FF120;
      v33 = CFSTR("Line");
      v34 = CFSTR("Method");
      v21 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_dumpLPMDebugLogWithCompletion:"));
      *(_QWORD *)&v38[8] = v21;
      v35 = (const __CFString *)NSDebugDescriptionErrorKey;
      v22 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_dumpLPMDebugLogWithCompletion:"), 4047);
      *(_QWORD *)&v38[16] = v22;
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v32, 4));
      v24 = objc_msgSend(v20, "initWithDomain:code:userInfo:", v4, 58, v23);
      ((void (**)(id, id))v2)[2](v2, v24);

    }
    goto LABEL_20;
  }
LABEL_21:

}

void sub_1000F67AC(uint64_t a1)
{
  int v1;
  uint64_t v2;
  void (**v3)(id, id);
  id v4;
  _QWORD *v5;
  void *v6;
  id v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  void (*v15)(uint64_t, const char *, ...);
  objc_class *v16;
  _BOOL4 v17;
  const char *v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  NSObject *v22;
  objc_class *v23;
  int v24;
  const char *v25;
  void *specific;
  uint64_t Logger;
  void (*v28)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  objc_class *v35;
  int v36;
  id v37;
  id v38;
  const char *v39;
  const char *Name;
  uint8_t buf[8];
  __int16 v42;
  const char *v43;
  __int16 v44;
  const char *v45;
  __int16 v46;
  int v47;
  NSErrorUserInfoKey v48;

  v1 = *(unsigned __int8 *)(a1 + 48);
  v2 = *(_QWORD *)(a1 + 32);
  v3 = (void (**)(id, id))*(id *)(a1 + 40);
  if (v2)
  {
    if (-[_NFHardwareManager getPrimaryHardwareState]_0(v2) != 2)
    {
      v7 = objc_alloc((Class)NSError);
      v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v48 = NSLocalizedDescriptionKey;
      v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
      *(_QWORD *)buf = v8;
      v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v48, 1));
      v10 = v7;
      v11 = v6;
      v12 = 58;
LABEL_27:
      v38 = objc_msgSend(v10, "initWithDomain:code:userInfo:", v11, v12, v9);
      v3[2](v3, v38);

      goto LABEL_28;
    }
    v4 = objc_msgSend(*(id *)(v2 + 384), "hasAntenna");
    if ((v4 & 1) != 0)
    {
      if ((NFIsInternalBuild(v4) & 1) != 0)
      {
        v5 = sub_1001D56AC(*(_QWORD **)(v2 + 368), v1 != 0);
        v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
        v3[2](v3, v6);
LABEL_28:

        goto LABEL_29;
      }
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v28 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass((id)v2);
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName((id)v2);
        Name = sel_getName("_sync_setChipscope:completion:");
        v32 = 45;
        if (isMetaClass)
          v32 = 43;
        v28(4, "%c[%{public}s %{public}s]:%i Not an internal build", v32, ClassName, Name, 4086);
      }
      v33 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v34 = NFSharedLogGetLogger(v33);
      v22 = objc_claimAutoreleasedReturnValue(v34);
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        goto LABEL_26;
      v35 = object_getClass((id)v2);
      if (class_isMetaClass(v35))
        v36 = 43;
      else
        v36 = 45;
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)&buf[4] = v36;
      v42 = 2082;
      v43 = object_getClassName((id)v2);
      v44 = 2082;
      v45 = sel_getName("_sync_setChipscope:completion:");
      v46 = 1024;
      v47 = 4086;
      v25 = "%c[%{public}s %{public}s]:%i Not an internal build";
    }
    else
    {
      v13 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v14 = NFLogGetLogger(v13);
      if (v14)
      {
        v15 = (void (*)(uint64_t, const char *, ...))v14;
        v16 = object_getClass((id)v2);
        v17 = class_isMetaClass(v16);
        v18 = object_getClassName((id)v2);
        v39 = sel_getName("_sync_setChipscope:completion:");
        v19 = 45;
        if (v17)
          v19 = 43;
        v15(4, "%c[%{public}s %{public}s]:%i No antenna", v19, v18, v39, 4080);
      }
      v20 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v21 = NFSharedLogGetLogger(v20);
      v22 = objc_claimAutoreleasedReturnValue(v21);
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        goto LABEL_26;
      v23 = object_getClass((id)v2);
      if (class_isMetaClass(v23))
        v24 = 43;
      else
        v24 = 45;
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)&buf[4] = v24;
      v42 = 2082;
      v43 = object_getClassName((id)v2);
      v44 = 2082;
      v45 = sel_getName("_sync_setChipscope:completion:");
      v46 = 1024;
      v47 = 4080;
      v25 = "%c[%{public}s %{public}s]:%i No antenna";
    }
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, v25, buf, 0x22u);
LABEL_26:

    v37 = objc_alloc((Class)NSError);
    v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v48 = NSLocalizedDescriptionKey;
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Feature Not Supported"));
    *(_QWORD *)buf = v8;
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v48, 1));
    v10 = v37;
    v11 = v6;
    v12 = 14;
    goto LABEL_27;
  }
LABEL_29:

}

void sub_1000F6C50(uint64_t a1)
{
  uint64_t v2;
  id v3;
  void *v4;
  void *v5;
  void *v6;
  id v7;
  NSErrorUserInfoKey v8;
  void *v9;

  if (-[_NFHardwareManager getPrimaryHardwareState]_0(*(_QWORD *)(a1 + 32)) == 2
    || -[_NFHardwareManager getPrimaryHardwareState]_0(*(_QWORD *)(a1 + 32)) == 5)
  {
    (*(void (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), 0, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 208));
  }
  else
  {
    v2 = *(_QWORD *)(a1 + 40);
    v3 = objc_alloc((Class)NSError);
    v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v8 = NSLocalizedDescriptionKey;
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
    v9 = v5;
    v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v9, &v8, 1));
    v7 = objc_msgSend(v3, "initWithDomain:code:userInfo:", v4, 58, v6);
    (*(void (**)(uint64_t, id, _QWORD))(v2 + 16))(v2, v7, 0);

  }
}

void sub_1000F6E88(uint64_t a1)
{
  sub_10016DAB0(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 56), *(void **)(a1 + 40), *(void **)(a1 + 48));
}

void sub_1000F6F74(void **a1)
{
  sub_10016F1B0(a1[4], a1[5], a1[6], a1[7]);
}

void sub_1000F72D4(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  id v4;
  void *v5;
  void *v6;
  id v7;
  id v8;
  void *v9;
  void *v10;
  void *v11;
  uint64_t v12;
  void *v13;
  id v14;
  id v15;
  id v16;
  uint64_t v17;
  void *v18;
  NSObject *v19;
  _QWORD block[5];
  id v21;
  id v22;
  _QWORD v23[4];
  _QWORD v24[4];
  _QWORD v25[4];
  _QWORD v26[4];
  _QWORD v27[4];
  _QWORD v28[4];

  switch(a2)
  {
    case 0:
      v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
      objc_msgSend(v13, "handleFailureInMethod:object:file:lineNumber:description:", *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 32), CFSTR("_NFHardwareManager.m"), 4151, CFSTR("Invalid state"));

      v3 = *(_QWORD *)(a1 + 48);
      v14 = objc_alloc((Class)NSError);
      v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v23[0] = NSLocalizedDescriptionKey;
      v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid State"));
      v24[0] = v6;
      v24[1] = &off_1002FF180;
      v23[1] = CFSTR("Line");
      v23[2] = CFSTR("Method");
      v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
      v24[2] = v7;
      v23[3] = NSDebugDescriptionErrorKey;
      v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 4152);
      v24[3] = v8;
      v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v24, v23, 4));
      v10 = v14;
      v11 = v5;
      v12 = 12;
      goto LABEL_7;
    case 3:
      v3 = *(_QWORD *)(a1 + 48);
      v15 = objc_alloc((Class)NSError);
      v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v25[0] = NSLocalizedDescriptionKey;
      v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session ineligible"));
      v26[0] = v6;
      v26[1] = &off_1002FF168;
      v25[1] = CFSTR("Line");
      v25[2] = CFSTR("Method");
      v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
      v26[2] = v7;
      v25[3] = NSDebugDescriptionErrorKey;
      v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 4148);
      v26[3] = v8;
      v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v26, v25, 4));
      v10 = v15;
      v11 = v5;
      v12 = 70;
      goto LABEL_7;
    case 2:
      v3 = *(_QWORD *)(a1 + 48);
      v4 = objc_alloc((Class)NSError);
      v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v27[0] = NSLocalizedDescriptionKey;
      v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "TCC access denied"));
      v28[0] = v6;
      v28[1] = &off_1002FF150;
      v27[1] = CFSTR("Line");
      v27[2] = CFSTR("Method");
      v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
      v28[2] = v7;
      v27[3] = NSDebugDescriptionErrorKey;
      v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 4145);
      v28[3] = v8;
      v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v28, v27, 4));
      v10 = v4;
      v11 = v5;
      v12 = 69;
LABEL_7:
      v16 = objc_msgSend(v10, "initWithDomain:code:userInfo:", v11, v12, v9);
      (*(void (**)(uint64_t, _QWORD, id))(v3 + 16))(v3, 0, v16);

      return;
  }
  v17 = *(_QWORD *)(a1 + 32);
  v18 = *(void **)(a1 + 40);
  v19 = *(NSObject **)(v17 + 232);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000F777C;
  block[3] = &unk_1002E8258;
  block[4] = v17;
  v21 = v18;
  v22 = *(id *)(a1 + 48);
  dispatch_async(v19, block);

}

void sub_1000F777C(uint64_t a1)
{
  sub_10016DAB0(*(_QWORD *)(a1 + 32), 4, *(void **)(a1 + 40), *(void **)(a1 + 48));
}

void sub_1000F7870(uint64_t a1)
{
  void *v2;
  void *v3;
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  id v19;
  void *v20;
  void *v21;
  id v22;
  id v23;
  void *v24;
  id v25;
  const char *Name;
  _QWORD v27[4];
  _QWORD v28[4];
  uint8_t buf[4];
  int v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  int v36;

  v2 = *(void **)(a1 + 32);
  if (v2 && (v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "assertionTime")), v3, v3))
  {
    sub_10016F1B0(*(void **)(a1 + 40), *(void **)(a1 + 32), *(void **)(a1 + 48), *(void **)(a1 + 56));
  }
  else
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 40));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 40));
      Name = sel_getName(*(SEL *)(a1 + 64));
      v10 = 45;
      if (isMetaClass)
        v10 = 43;
      v6(3, "%c[%{public}s %{public}s]:%i Invalid assertion", v10, ClassName, Name, 4170);
    }
    v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v12 = NFSharedLogGetLogger(v11);
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v14 = object_getClass(*(id *)(a1 + 40));
      if (class_isMetaClass(v14))
        v15 = 43;
      else
        v15 = 45;
      v16 = object_getClassName(*(id *)(a1 + 40));
      v17 = sel_getName(*(SEL *)(a1 + 64));
      *(_DWORD *)buf = 67109890;
      v30 = v15;
      v31 = 2082;
      v32 = v16;
      v33 = 2082;
      v34 = v17;
      v35 = 1024;
      v36 = 4170;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid assertion", buf, 0x22u);
    }

    v18 = *(_QWORD *)(a1 + 56);
    v19 = objc_alloc((Class)NSError);
    v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v27[0] = NSLocalizedDescriptionKey;
    v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid Parameter"));
    v28[0] = v21;
    v28[1] = &off_1002FF198;
    v27[1] = CFSTR("Line");
    v27[2] = CFSTR("Method");
    v22 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 64)));
    v28[2] = v22;
    v27[3] = NSDebugDescriptionErrorKey;
    v23 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 64)), 4171);
    v28[3] = v23;
    v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v28, v27, 4));
    v25 = objc_msgSend(v19, "initWithDomain:code:userInfo:", v20, 10, v24);
    (*(void (**)(uint64_t, id))(v18 + 16))(v18, v25);

  }
}

void sub_1000F87DC(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000F8FD4(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  id v4;
  void *v5;
  void *v6;
  id v7;
  id v8;
  void *v9;
  void *v10;
  void *v11;
  uint64_t v12;
  id v13;
  id v14;
  id v15;
  id v16;
  id v17;
  void *v18;
  id v19;
  void *v20;
  id v21;
  uint64_t v22;
  void *v23;
  id v24;
  id v25;
  void *v26;
  id v27;
  _QWORD v28[5];
  _QWORD v29[5];
  _QWORD v30[4];
  _QWORD v31[4];
  _QWORD v32[4];
  _QWORD v33[4];
  _QWORD v34[4];
  _QWORD v35[4];
  _QWORD v36[4];
  _QWORD v37[4];

  v2 = *(_QWORD *)(a1 + 32);
  if (!v2 || objc_msgSend(*(id *)(v2 + 40), "OSMode") != (id)2)
  {
    v3 = *(void **)(a1 + 40);
    v13 = objc_alloc((Class)NSError);
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v36[0] = NSLocalizedDescriptionKey;
    v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "JCOP not available"));
    v37[0] = v6;
    v37[1] = &off_1002FF1B0;
    v36[1] = CFSTR("Line");
    v36[2] = CFSTR("Method");
    v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v37[2] = v7;
    v36[3] = NSDebugDescriptionErrorKey;
    v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 4292);
    v37[3] = v8;
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v37, v36, 4));
    v10 = v13;
    v11 = v5;
    v12 = 53;
    goto LABEL_6;
  }
  if (objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 40), "restrictedMode"))
  {
    v3 = *(void **)(a1 + 40);
    v4 = objc_alloc((Class)NSError);
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v34[0] = NSLocalizedDescriptionKey;
    v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Restricted Mode"));
    v35[0] = v6;
    v35[1] = &off_1002FF1C8;
    v34[1] = CFSTR("Line");
    v34[2] = CFSTR("Method");
    v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v35[2] = v7;
    v34[3] = NSDebugDescriptionErrorKey;
    v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 4295);
    v35[3] = v8;
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v35, v34, 4));
    v10 = v4;
    v11 = v5;
    v12 = 24;
LABEL_6:
    v14 = objc_msgSend(v10, "initWithDomain:code:userInfo:", v11, v12, v9);
    objc_msgSend(v3, "didStartSession:", v14);

    goto LABEL_7;
  }
  if (sub_1000E4180(*(_QWORD *)(a1 + 32)))
  {
    v3 = *(void **)(a1 + 40);
    v15 = objc_alloc((Class)NSError);
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v32[0] = NSLocalizedDescriptionKey;
    v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Applet Migration"));
    v33[0] = v6;
    v33[1] = &off_1002FF1E0;
    v32[1] = CFSTR("Line");
    v32[2] = CFSTR("Method");
    v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v33[2] = v7;
    v32[3] = NSDebugDescriptionErrorKey;
    v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 4298);
    v33[3] = v8;
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v33, v32, 4));
    v10 = v15;
    v11 = v5;
    v12 = 26;
    goto LABEL_6;
  }
  if (sub_1000E41D4(*(_QWORD *)(a1 + 32)))
  {
    v3 = *(void **)(a1 + 40);
    v16 = objc_alloc((Class)NSError);
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v30[0] = NSLocalizedDescriptionKey;
    v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "JCOP in OSU"));
    v31[0] = v6;
    v31[1] = &off_1002FF1F8;
    v30[1] = CFSTR("Line");
    v30[2] = CFSTR("Method");
    v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v31[2] = v7;
    v30[3] = NSDebugDescriptionErrorKey;
    v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 4301);
    v31[3] = v8;
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v31, v30, 4));
    v10 = v16;
    v11 = v5;
    v12 = 52;
    goto LABEL_6;
  }
  v17 = sub_1001C7B30(*(_QWORD *)(a1 + 32), *(void **)(a1 + 40), *(void **)(a1 + 48), 0);
  v5 = (void *)objc_claimAutoreleasedReturnValue(v17);
  if (v5)
  {
    v18 = *(void **)(a1 + 40);
    v19 = objc_alloc((Class)NSError);
    v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v21 = objc_msgSend(v5, "code");
    v28[0] = NSLocalizedDescriptionKey;
    if ((uint64_t)objc_msgSend(v5, "code") > 70)
      v22 = 71;
    else
      v22 = (uint64_t)objc_msgSend(v5, "code");
    v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E7F70[v22]));
    v29[0] = v23;
    v29[1] = v5;
    v28[1] = NSUnderlyingErrorKey;
    v28[2] = CFSTR("Line");
    v29[2] = &off_1002FF210;
    v28[3] = CFSTR("Method");
    v24 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v29[3] = v24;
    v28[4] = NSDebugDescriptionErrorKey;
    v25 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 4305);
    v29[4] = v25;
    v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v29, v28, 5));
    v27 = objc_msgSend(v19, "initWithDomain:code:userInfo:", v20, v21, v26);
    objc_msgSend(v18, "didStartSession:", v27);

  }
  else
  {
    objc_msgSend(*(id *)(a1 + 32), "maybeStartNextSession");
  }
LABEL_7:

}

void sub_1000FA384(uint64_t a1)
{
  id v2;
  void *v3;
  uint64_t v4;
  void *v5;
  id v6;
  void *v7;
  void *v8;
  id v9;
  id v10;
  void *v11;
  void *v12;
  void *v13;
  uint64_t v14;
  id v15;
  id v16;
  id v17;
  id v18;
  id v19;
  void *v20;
  id v21;
  void *v22;
  id v23;
  uint64_t v24;
  void *v25;
  id v26;
  id v27;
  void *v28;
  id v29;
  _QWORD v30[5];
  _QWORD v31[5];
  _QWORD v32[4];
  _QWORD v33[4];
  _QWORD v34[4];
  _QWORD v35[4];
  _QWORD v36[4];
  _QWORD v37[4];
  _QWORD v38[4];
  _QWORD v39[4];

  v2 = sub_10019C0D0((uint64_t)NFSystemPowerConsumptionMonitor);
  v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  objc_msgSend(*(id *)(a1 + 32), "setPowerConsumptionReporter:", v3);

  v4 = *(_QWORD *)(a1 + 40);
  if (!v4 || objc_msgSend(*(id *)(v4 + 40), "OSMode") != (id)2)
  {
    v5 = *(void **)(a1 + 32);
    v15 = objc_alloc((Class)NSError);
    v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v38[0] = NSLocalizedDescriptionKey;
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "JCOP not available"));
    v39[0] = v8;
    v39[1] = &off_1002FF228;
    v38[1] = CFSTR("Line");
    v38[2] = CFSTR("Method");
    v9 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v39[2] = v9;
    v38[3] = NSDebugDescriptionErrorKey;
    v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 4381);
    v39[3] = v10;
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v39, v38, 4));
    v12 = v15;
    v13 = v7;
    v14 = 53;
    goto LABEL_6;
  }
  if (objc_msgSend(*(id *)(*(_QWORD *)(a1 + 40) + 40), "restrictedMode"))
  {
    v5 = *(void **)(a1 + 32);
    v6 = objc_alloc((Class)NSError);
    v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v36[0] = NSLocalizedDescriptionKey;
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Restricted Mode"));
    v37[0] = v8;
    v37[1] = &off_1002FF240;
    v36[1] = CFSTR("Line");
    v36[2] = CFSTR("Method");
    v9 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v37[2] = v9;
    v36[3] = NSDebugDescriptionErrorKey;
    v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 4384);
    v37[3] = v10;
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v37, v36, 4));
    v12 = v6;
    v13 = v7;
    v14 = 24;
LABEL_6:
    v16 = objc_msgSend(v12, "initWithDomain:code:userInfo:", v13, v14, v11);
    objc_msgSend(v5, "didStartSession:", v16);

    goto LABEL_7;
  }
  if (sub_1000E4180(*(_QWORD *)(a1 + 40)))
  {
    v5 = *(void **)(a1 + 32);
    v17 = objc_alloc((Class)NSError);
    v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v34[0] = NSLocalizedDescriptionKey;
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Applet Migration"));
    v35[0] = v8;
    v35[1] = &off_1002FF258;
    v34[1] = CFSTR("Line");
    v34[2] = CFSTR("Method");
    v9 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v35[2] = v9;
    v34[3] = NSDebugDescriptionErrorKey;
    v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 4387);
    v35[3] = v10;
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v35, v34, 4));
    v12 = v17;
    v13 = v7;
    v14 = 26;
    goto LABEL_6;
  }
  if (sub_1000E41D4(*(_QWORD *)(a1 + 40)))
  {
    v5 = *(void **)(a1 + 32);
    v18 = objc_alloc((Class)NSError);
    v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v32[0] = NSLocalizedDescriptionKey;
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "JCOP in OSU"));
    v33[0] = v8;
    v33[1] = &off_1002FF270;
    v32[1] = CFSTR("Line");
    v32[2] = CFSTR("Method");
    v9 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v33[2] = v9;
    v32[3] = NSDebugDescriptionErrorKey;
    v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 4390);
    v33[3] = v10;
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v33, v32, 4));
    v12 = v18;
    v13 = v7;
    v14 = 52;
    goto LABEL_6;
  }
  v19 = sub_1001C7B30(*(_QWORD *)(a1 + 40), *(void **)(a1 + 32), *(void **)(a1 + 48), 0);
  v7 = (void *)objc_claimAutoreleasedReturnValue(v19);
  if (v7)
  {
    v20 = *(void **)(a1 + 32);
    v21 = objc_alloc((Class)NSError);
    v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v23 = objc_msgSend(v7, "code");
    v30[0] = NSLocalizedDescriptionKey;
    if ((uint64_t)objc_msgSend(v7, "code") > 70)
      v24 = 71;
    else
      v24 = (uint64_t)objc_msgSend(v7, "code");
    v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E7F70[v24]));
    v31[0] = v25;
    v31[1] = v7;
    v30[1] = NSUnderlyingErrorKey;
    v30[2] = CFSTR("Line");
    v31[2] = &off_1002FF288;
    v30[3] = CFSTR("Method");
    v26 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v31[3] = v26;
    v30[4] = NSDebugDescriptionErrorKey;
    v27 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 4394);
    v31[4] = v27;
    v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v31, v30, 5));
    v29 = objc_msgSend(v21, "initWithDomain:code:userInfo:", v22, v23, v28);
    objc_msgSend(v20, "didStartSession:", v29);

  }
  else
  {
    objc_msgSend(*(id *)(a1 + 40), "maybeStartNextSession");
  }
LABEL_7:

}

void sub_1000FB730(uint64_t a1)
{
  id v2;
  void *v3;
  uint64_t v4;
  void *v5;
  id v6;
  void *v7;
  void *v8;
  id v9;
  id v10;
  void *v11;
  void *v12;
  void *v13;
  uint64_t v14;
  id v15;
  id v16;
  id v17;
  id v18;
  id v19;
  void *v20;
  id v21;
  void *v22;
  id v23;
  uint64_t v24;
  void *v25;
  id v26;
  id v27;
  void *v28;
  id v29;
  _QWORD v30[5];
  _QWORD v31[5];
  _QWORD v32[4];
  _QWORD v33[4];
  _QWORD v34[4];
  _QWORD v35[4];
  _QWORD v36[4];
  _QWORD v37[4];
  _QWORD v38[4];
  _QWORD v39[4];

  v2 = sub_10019C0D0((uint64_t)NFSystemPowerConsumptionMonitor);
  v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  objc_msgSend(*(id *)(a1 + 32), "setPowerConsumptionReporter:", v3);

  v4 = *(_QWORD *)(a1 + 40);
  if (!v4 || objc_msgSend(*(id *)(v4 + 40), "OSMode") != (id)2)
  {
    v5 = *(void **)(a1 + 32);
    v15 = objc_alloc((Class)NSError);
    v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v38[0] = NSLocalizedDescriptionKey;
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "JCOP not available"));
    v39[0] = v8;
    v39[1] = &off_1002FF2A0;
    v38[1] = CFSTR("Line");
    v38[2] = CFSTR("Method");
    v9 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v39[2] = v9;
    v38[3] = NSDebugDescriptionErrorKey;
    v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 4468);
    v39[3] = v10;
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v39, v38, 4));
    v12 = v15;
    v13 = v7;
    v14 = 53;
    goto LABEL_6;
  }
  if (objc_msgSend(*(id *)(*(_QWORD *)(a1 + 40) + 40), "restrictedMode"))
  {
    v5 = *(void **)(a1 + 32);
    v6 = objc_alloc((Class)NSError);
    v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v36[0] = NSLocalizedDescriptionKey;
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Restricted Mode"));
    v37[0] = v8;
    v37[1] = &off_1002FF2B8;
    v36[1] = CFSTR("Line");
    v36[2] = CFSTR("Method");
    v9 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v37[2] = v9;
    v36[3] = NSDebugDescriptionErrorKey;
    v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 4471);
    v37[3] = v10;
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v37, v36, 4));
    v12 = v6;
    v13 = v7;
    v14 = 24;
LABEL_6:
    v16 = objc_msgSend(v12, "initWithDomain:code:userInfo:", v13, v14, v11);
    objc_msgSend(v5, "didStartSession:", v16);

    goto LABEL_7;
  }
  if (sub_1000E4180(*(_QWORD *)(a1 + 40)))
  {
    v5 = *(void **)(a1 + 32);
    v17 = objc_alloc((Class)NSError);
    v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v34[0] = NSLocalizedDescriptionKey;
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Applet Migration"));
    v35[0] = v8;
    v35[1] = &off_1002FF2D0;
    v34[1] = CFSTR("Line");
    v34[2] = CFSTR("Method");
    v9 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v35[2] = v9;
    v34[3] = NSDebugDescriptionErrorKey;
    v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 4474);
    v35[3] = v10;
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v35, v34, 4));
    v12 = v17;
    v13 = v7;
    v14 = 26;
    goto LABEL_6;
  }
  if (sub_1000E41D4(*(_QWORD *)(a1 + 40)))
  {
    v5 = *(void **)(a1 + 32);
    v18 = objc_alloc((Class)NSError);
    v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v32[0] = NSLocalizedDescriptionKey;
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "JCOP in OSU"));
    v33[0] = v8;
    v33[1] = &off_1002FF2E8;
    v32[1] = CFSTR("Line");
    v32[2] = CFSTR("Method");
    v9 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v33[2] = v9;
    v32[3] = NSDebugDescriptionErrorKey;
    v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 4477);
    v33[3] = v10;
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v33, v32, 4));
    v12 = v18;
    v13 = v7;
    v14 = 52;
    goto LABEL_6;
  }
  v19 = sub_1001C7B30(*(_QWORD *)(a1 + 40), *(void **)(a1 + 32), *(void **)(a1 + 48), 0);
  v7 = (void *)objc_claimAutoreleasedReturnValue(v19);
  if (v7)
  {
    v20 = *(void **)(a1 + 32);
    v21 = objc_alloc((Class)NSError);
    v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v23 = objc_msgSend(v7, "code");
    v30[0] = NSLocalizedDescriptionKey;
    if ((uint64_t)objc_msgSend(v7, "code") > 70)
      v24 = 71;
    else
      v24 = (uint64_t)objc_msgSend(v7, "code");
    v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E7F70[v24]));
    v31[0] = v25;
    v31[1] = v7;
    v30[1] = NSUnderlyingErrorKey;
    v30[2] = CFSTR("Line");
    v31[2] = &off_1002FF300;
    v30[3] = CFSTR("Method");
    v26 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v31[3] = v26;
    v30[4] = NSDebugDescriptionErrorKey;
    v27 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 4481);
    v31[4] = v27;
    v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v31, v30, 5));
    v29 = objc_msgSend(v21, "initWithDomain:code:userInfo:", v22, v23, v28);
    objc_msgSend(v20, "didStartSession:", v29);

  }
  else
  {
    objc_msgSend(*(id *)(a1 + 40), "maybeStartNextSession");
  }
LABEL_7:

}

void sub_1000FC78C(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  char isKindOfClass;
  void *v5;
  unsigned __int8 v6;
  uint64_t v7;
  id v8;
  void *v9;
  void *v10;
  id v11;
  void *v12;
  id v13;
  uint64_t v14;
  void *v15;
  id v16;
  void *v17;
  id v18;
  id v19;
  void *v20;
  id v21;
  void *v22;
  id v23;
  id v24;
  void *v25;
  id v26;
  _QWORD v27[5];
  _QWORD v28[5];
  _QWORD v29[4];
  _QWORD v30[4];

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "objectForKey:", CFSTR("session.allowInJBSL")));
  v3 = objc_opt_class(NSNumber);
  isKindOfClass = objc_opt_isKindOfClass(v2, v3);

  if ((isKindOfClass & 1) != 0
    && (v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "objectForKeyedSubscript:", CFSTR("session.allowInJBSL"))),
        v6 = objc_msgSend(v5, "BOOLValue"),
        v5,
        (v6 & 1) != 0)
    || (v7 = *(_QWORD *)(a1 + 40)) != 0 && objc_msgSend(*(id *)(v7 + 40), "OSMode") == (id)2)
  {
    v8 = sub_1001C7B30(*(_QWORD *)(a1 + 40), *(void **)(a1 + 48), *(void **)(a1 + 56), 0);
    v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
    if (v9)
    {
      v10 = *(void **)(a1 + 48);
      v11 = objc_alloc((Class)NSError);
      v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v13 = objc_msgSend(v9, "code");
      v27[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)objc_msgSend(v9, "code") > 70)
        v14 = 71;
      else
        v14 = (uint64_t)objc_msgSend(v9, "code");
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E7F70[v14]));
      v28[0] = v22;
      v28[1] = v9;
      v27[1] = NSUnderlyingErrorKey;
      v27[2] = CFSTR("Line");
      v28[2] = &off_1002FF330;
      v27[3] = CFSTR("Method");
      v23 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 64)));
      v28[3] = v23;
      v27[4] = NSDebugDescriptionErrorKey;
      v24 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 64)), 4568);
      v28[4] = v24;
      v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v28, v27, 5));
      v26 = objc_msgSend(v11, "initWithDomain:code:userInfo:", v12, v13, v25);
      objc_msgSend(v10, "didStartSession:", v26);

    }
    else
    {
      objc_msgSend(*(id *)(a1 + 40), "maybeStartNextSession");
    }
  }
  else
  {
    v15 = *(void **)(a1 + 48);
    v16 = objc_alloc((Class)NSError);
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v29[0] = NSLocalizedDescriptionKey;
    v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "JCOP not available"));
    v30[0] = v17;
    v30[1] = &off_1002FF318;
    v29[1] = CFSTR("Line");
    v29[2] = CFSTR("Method");
    v18 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 64)));
    v30[2] = v18;
    v29[3] = NSDebugDescriptionErrorKey;
    v19 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 64)), 4564);
    v30[3] = v19;
    v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v30, v29, 4));
    v21 = objc_msgSend(v16, "initWithDomain:code:userInfo:", v9, 53, v20);
    objc_msgSend(v15, "didStartSession:", v21);

  }
}

void sub_1000FD8A8(uint64_t a1)
{
  id v2;
  void *v3;
  uint64_t v4;
  void *v5;
  id v6;
  void *v7;
  void *v8;
  id v9;
  id v10;
  void *v11;
  void *v12;
  void *v13;
  uint64_t v14;
  id v15;
  id v16;
  id v17;
  id v18;
  id v19;
  void *v20;
  id v21;
  void *v22;
  id v23;
  uint64_t v24;
  unsigned int v25;
  _QWORD *v26;
  uint64_t v27;
  void *specific;
  uint64_t Logger;
  void (*v30)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  NSObject *v37;
  objc_class *v38;
  int v39;
  const char *v40;
  const char *v41;
  void *v42;
  id v43;
  id v44;
  void *v45;
  id v46;
  const char *Name;
  char v48;
  uint8_t buf[4];
  int v50;
  __int16 v51;
  const char *v52;
  __int16 v53;
  const char *v54;
  __int16 v55;
  int v56;
  _QWORD v57[5];
  _QWORD v58[5];
  _QWORD v59[4];
  _QWORD v60[4];
  _QWORD v61[4];
  _QWORD v62[4];
  _QWORD v63[4];
  _QWORD v64[4];
  _QWORD v65[4];
  _QWORD v66[4];

  v2 = sub_10019C0D0((uint64_t)NFSystemPowerConsumptionMonitor);
  v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  objc_msgSend(*(id *)(a1 + 32), "setPowerConsumptionReporter:", v3);

  v4 = *(_QWORD *)(a1 + 40);
  if (!v4 || objc_msgSend(*(id *)(v4 + 40), "OSMode") != (id)2)
  {
    v5 = *(void **)(a1 + 32);
    v15 = objc_alloc((Class)NSError);
    v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v65[0] = NSLocalizedDescriptionKey;
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "JCOP not available"));
    v66[0] = v8;
    v66[1] = &off_1002FF348;
    v65[1] = CFSTR("Line");
    v65[2] = CFSTR("Method");
    v9 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v66[2] = v9;
    v65[3] = NSDebugDescriptionErrorKey;
    v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 4651);
    v66[3] = v10;
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v66, v65, 4));
    v12 = v15;
    v13 = v7;
    v14 = 53;
    goto LABEL_6;
  }
  if (objc_msgSend(*(id *)(*(_QWORD *)(a1 + 40) + 40), "restrictedMode"))
  {
    v5 = *(void **)(a1 + 32);
    v6 = objc_alloc((Class)NSError);
    v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v63[0] = NSLocalizedDescriptionKey;
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Restricted Mode"));
    v64[0] = v8;
    v64[1] = &off_1002FF360;
    v63[1] = CFSTR("Line");
    v63[2] = CFSTR("Method");
    v9 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v64[2] = v9;
    v63[3] = NSDebugDescriptionErrorKey;
    v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 4654);
    v64[3] = v10;
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v64, v63, 4));
    v12 = v6;
    v13 = v7;
    v14 = 24;
LABEL_6:
    v16 = objc_msgSend(v12, "initWithDomain:code:userInfo:", v13, v14, v11);
    objc_msgSend(v5, "didStartSession:", v16);

    goto LABEL_7;
  }
  if (sub_1000E4180(*(_QWORD *)(a1 + 40)))
  {
    v5 = *(void **)(a1 + 32);
    v17 = objc_alloc((Class)NSError);
    v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v61[0] = NSLocalizedDescriptionKey;
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Applet Migration"));
    v62[0] = v8;
    v62[1] = &off_1002FF378;
    v61[1] = CFSTR("Line");
    v61[2] = CFSTR("Method");
    v9 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v62[2] = v9;
    v61[3] = NSDebugDescriptionErrorKey;
    v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 4657);
    v62[3] = v10;
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v62, v61, 4));
    v12 = v17;
    v13 = v7;
    v14 = 26;
    goto LABEL_6;
  }
  if (sub_1000E41D4(*(_QWORD *)(a1 + 40)))
  {
    v5 = *(void **)(a1 + 32);
    v18 = objc_alloc((Class)NSError);
    v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v59[0] = NSLocalizedDescriptionKey;
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "JCOP in OSU"));
    v60[0] = v8;
    v60[1] = &off_1002FF390;
    v59[1] = CFSTR("Line");
    v59[2] = CFSTR("Method");
    v9 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v60[2] = v9;
    v59[3] = NSDebugDescriptionErrorKey;
    v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 4660);
    v60[3] = v10;
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v60, v59, 4));
    v12 = v18;
    v13 = v7;
    v14 = 52;
    goto LABEL_6;
  }
  v48 = 0;
  v19 = sub_1001C7B30(*(_QWORD *)(a1 + 40), *(void **)(a1 + 32), *(void **)(a1 + 48), &v48);
  v7 = (void *)objc_claimAutoreleasedReturnValue(v19);
  v20 = *(void **)(a1 + 32);
  if (v7)
  {
    v21 = objc_alloc((Class)NSError);
    v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v23 = objc_msgSend(v7, "code");
    v57[0] = NSLocalizedDescriptionKey;
    if ((uint64_t)objc_msgSend(v7, "code") > 70)
      v24 = 71;
    else
      v24 = (uint64_t)objc_msgSend(v7, "code");
    v42 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E7F70[v24]));
    v58[0] = v42;
    v58[1] = v7;
    v57[1] = NSUnderlyingErrorKey;
    v57[2] = CFSTR("Line");
    v58[2] = &off_1002FF3A8;
    v57[3] = CFSTR("Method");
    v43 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v58[3] = v43;
    v57[4] = NSDebugDescriptionErrorKey;
    v44 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 4665);
    v58[4] = v44;
    v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v58, v57, 5));
    v46 = objc_msgSend(v21, "initWithDomain:code:userInfo:", v22, v23, v45);
    objc_msgSend(v20, "didStartSession:", v46);

  }
  else
  {
    v25 = objc_msgSend(*(id *)(a1 + 32), "forceExpressExit");
    v26 = *(_QWORD **)(a1 + 40);
    if (v25)
    {
      if (!v48)
      {
        v27 = v26[3];
        if (v27)
        {
          if (*(_BYTE *)(v27 + 172))
          {
            specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            Logger = NFLogGetLogger(specific);
            if (Logger)
            {
              v30 = (void (*)(uint64_t, const char *, ...))Logger;
              Class = object_getClass(*(id *)(a1 + 40));
              isMetaClass = class_isMetaClass(Class);
              ClassName = object_getClassName(*(id *)(a1 + 40));
              Name = sel_getName(*(SEL *)(a1 + 56));
              v34 = 45;
              if (isMetaClass)
                v34 = 43;
              v30(6, "%c[%{public}s %{public}s]:%i forceExpressExit is set - re-prioritiing the session.", v34, ClassName, Name, 4670);
            }
            v35 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v36 = NFSharedLogGetLogger(v35);
            v37 = objc_claimAutoreleasedReturnValue(v36);
            if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
            {
              v38 = object_getClass(*(id *)(a1 + 40));
              if (class_isMetaClass(v38))
                v39 = 43;
              else
                v39 = 45;
              v40 = object_getClassName(*(id *)(a1 + 40));
              v41 = sel_getName(*(SEL *)(a1 + 56));
              *(_DWORD *)buf = 67109890;
              v50 = v39;
              v51 = 2082;
              v52 = v40;
              v53 = 2082;
              v54 = v41;
              v55 = 1024;
              v56 = 4670;
              _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i forceExpressExit is set - re-prioritiing the session.", buf, 0x22u);
            }

            objc_msgSend(*(id *)(a1 + 40), "prioritizeSession:", *(_QWORD *)(a1 + 32));
            v26 = *(_QWORD **)(a1 + 40);
          }
        }
      }
    }
    objc_msgSend(v26, "maybeStartNextSession");
  }
LABEL_7:

}

id sub_1000FF4E0(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "maybeStartNextSession");
}

void sub_1000FF59C(uint64_t a1)
{
  int v2;
  uint64_t v3;
  id v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  uint64_t v10;
  id v11;
  id v13;
  id v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  id v20;
  void *v21;
  void *v22;
  void *v23;
  id v24;
  NSErrorUserInfoKey v25;
  void *v26;
  NSErrorUserInfoKey v27;
  void *v28;
  NSErrorUserInfoKey v29;
  void *v30;
  NSErrorUserInfoKey v31;
  void *v32;

  v2 = -[_NFHardwareManager getPrimaryHardwareState]_0(*(_QWORD *)(a1 + 32));
  if ((v2 & 5) != 1)
  {
    if (v2 == 4)
    {
      v3 = *(_QWORD *)(a1 + 48);
      v11 = objc_alloc((Class)NSError);
      v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v29 = NSLocalizedDescriptionKey;
      v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "No NFC on device"));
      v30 = v6;
      v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v30, &v29, 1));
      v8 = v11;
      v9 = v5;
      v10 = 57;
      goto LABEL_11;
    }
    if (*(_QWORD *)(a1 + 56) > 0x7FuLL || (*(_QWORD *)(a1 + 56) & 0x7FLL) == 0)
    {
      v3 = *(_QWORD *)(a1 + 48);
      v13 = objc_alloc((Class)NSError);
      v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v25 = NSLocalizedDescriptionKey;
      v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid Parameter"));
      v26 = v6;
      v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v26, &v25, 1));
      v8 = v13;
      v9 = v5;
      v10 = 10;
      goto LABEL_11;
    }
    v15 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "NF_whitelistChecker"));
    if (!v15)
    {
      v19 = *(_QWORD *)(a1 + 48);
      v20 = objc_alloc((Class)NSError);
      v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v27 = NSLocalizedDescriptionKey;
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Not entitled"));
      v28 = v22;
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v28, &v27, 1));
      v24 = objc_msgSend(v20, "initWithDomain:code:userInfo:", v21, 32, v23);
      (*(void (**)(uint64_t, _QWORD, id))(v19 + 16))(v19, 0, v24);

      v5 = 0;
      goto LABEL_12;
    }
    v5 = (void *)v15;
    v16 = objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 384), "hasReaderModeSupport");
    v17 = v16;
    v18 = *(_QWORD *)(a1 + 56);
    if ((v18 & 6) != 0 && v16)
    {
      objc_msgSend(v5, "nfcNDEFReaderAccess");
      v18 = *(_QWORD *)(a1 + 56);
    }
    if ((v18 & 8) != 0)
    {
      if (v17)
      {
        objc_msgSend(v5, "nfcISO15693ReaderAccess");
        v18 = *(_QWORD *)(a1 + 56);
      }
      if ((v18 & 0x10) == 0)
      {
LABEL_20:
        if ((v18 & 0x20) == 0)
        {
LABEL_30:
          (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
          goto LABEL_12;
        }
LABEL_28:
        if (v17)
          objc_msgSend(v5, "nfcVASReaderAccess");
        goto LABEL_30;
      }
    }
    else if ((v18 & 0x10) == 0)
    {
      goto LABEL_20;
    }
    if (v17)
    {
      objc_msgSend(v5, "nfcTagReaderAccess");
      v18 = *(_QWORD *)(a1 + 56);
    }
    if ((v18 & 0x20) == 0)
      goto LABEL_30;
    goto LABEL_28;
  }
  v3 = *(_QWORD *)(a1 + 48);
  v4 = objc_alloc((Class)NSError);
  v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
  v31 = NSLocalizedDescriptionKey;
  v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
  v32 = v6;
  v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v32, &v31, 1));
  v8 = v4;
  v9 = v5;
  v10 = 58;
LABEL_11:
  v14 = objc_msgSend(v8, "initWithDomain:code:userInfo:", v9, v10, v7);
  (*(void (**)(uint64_t, _QWORD, id))(v3 + 16))(v3, 0, v14);

LABEL_12:
}

void sub_1000FFA60(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  void *v3;
  void (**v4)(id, _QWORD);
  void *specific;
  uint64_t Logger;
  void (*v7)(uint64_t, const char *, ...);
  objc_class *Class;
  uint64_t v9;
  const char *ClassName;
  const char *Name;
  void *v12;
  void *v13;
  void *v14;
  uint64_t v15;
  NSObject *v16;
  objc_class *v17;
  int v18;
  const char *v19;
  const char *v20;
  void *v21;
  void *v22;
  void *v23;
  char v24;
  void *v25;
  void (*v26)(uint64_t, const char *, ...);
  objc_class *v27;
  uint64_t v28;
  const char *v29;
  const char *v30;
  void *v31;
  uint64_t v32;
  NSObject *v33;
  objc_class *v34;
  int v35;
  const char *v36;
  const char *v37;
  uint64_t v38;
  id v39;
  void *v40;
  void *v41;
  void *v42;
  id v43;
  uint64_t v44;
  id v45;
  uint64_t v46;
  uint64_t *v47;
  uint64_t v48;
  uint64_t (*v49)(uint64_t, uint64_t);
  void (*v50)(uint64_t);
  id v51;
  uint8_t v52[8];
  __int16 v53;
  const char *v54;
  __int16 v55;
  const char *v56;
  __int16 v57;
  int v58;
  __int16 v59;
  int v60;
  __int16 v61;
  uint64_t v62;
  uint8_t buf[8];
  _BYTE v64[44];
  char v65;

  v1 = *(unsigned __int8 *)(a1 + 60);
  v44 = *(unsigned int *)(a1 + 56);
  v2 = *(void **)(a1 + 32);
  v3 = *(void **)(a1 + 48);
  v45 = *(id *)(a1 + 40);
  v4 = v3;
  if (v2)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v7 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v2);
      if (class_isMetaClass(Class))
        v9 = 43;
      else
        v9 = 45;
      ClassName = object_getClassName(v2);
      Name = sel_getName("_sync_configureReaderModeRFForTransitPartner:transitPartner:connection:completion:");
      v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v45, "NF_userInfo"));
      v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "objectForKeyedSubscript:", CFSTR("ClientName")));
      v7(6, "%c[%{public}s %{public}s]:%i %{public}@ with configureNewRFConfig = %d", v9, ClassName, Name, 4833, v13, v1);

    }
    v14 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v15 = NFSharedLogGetLogger(v14);
    v16 = objc_claimAutoreleasedReturnValue(v15);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      v17 = object_getClass(v2);
      if (class_isMetaClass(v17))
        v18 = 43;
      else
        v18 = 45;
      v19 = object_getClassName(v2);
      v20 = sel_getName("_sync_configureReaderModeRFForTransitPartner:transitPartner:connection:completion:");
      v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v45, "NF_userInfo"));
      v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "objectForKeyedSubscript:", CFSTR("ClientName")));
      *(_DWORD *)buf = 67110402;
      *(_DWORD *)&buf[4] = v18;
      *(_WORD *)v64 = 2082;
      *(_QWORD *)&v64[2] = v19;
      *(_WORD *)&v64[10] = 2082;
      *(_QWORD *)&v64[12] = v20;
      *(_WORD *)&v64[20] = 1024;
      *(_DWORD *)&v64[22] = 4833;
      *(_WORD *)&v64[26] = 2114;
      *(_QWORD *)&v64[28] = v22;
      *(_WORD *)&v64[36] = 1024;
      *(_DWORD *)&v64[38] = v1;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@ with configureNewRFConfig = %d", buf, 0x32u);

    }
    v46 = 0;
    v47 = &v46;
    v48 = 0x3032000000;
    v49 = sub_1000E3C80;
    v50 = sub_1000E3C90;
    v51 = 0;
    if (-[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)v2) == 2)
    {
      *(_QWORD *)buf = _NSConcreteStackBlock;
      *(_QWORD *)v64 = 3221225472;
      *(_QWORD *)&v64[8] = sub_1000FFFB0;
      *(_QWORD *)&v64[16] = &unk_1002E84D8;
      v65 = v1;
      *(_DWORD *)&v64[40] = v44;
      *(_QWORD *)&v64[24] = v2;
      *(_QWORD *)&v64[32] = &v46;
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig routingOffWithFD:](NFRoutingConfig, "routingOffWithFD:", 0));
      v24 = sub_1000E3CEC((void **)v2, buf, CFSTR("ConfigureRF"), v23);

      if ((v24 & 1) == 0)
      {
        v25 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v26 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v25);
        if (v26)
        {
          v27 = object_getClass(v2);
          if (class_isMetaClass(v27))
            v28 = 43;
          else
            v28 = 45;
          v29 = object_getClassName(v2);
          v30 = sel_getName("_sync_configureReaderModeRFForTransitPartner:transitPartner:connection:completion:");
          v26(3, "%c[%{public}s %{public}s]:%i configureReaderModeRFForTransitPartner for %d, failed: %{public}@", v28, v29, v30, 4852, v44, v47[5]);
        }
        v31 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v32 = NFSharedLogGetLogger(v31);
        v33 = objc_claimAutoreleasedReturnValue(v32);
        if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
        {
          v34 = object_getClass(v2);
          if (class_isMetaClass(v34))
            v35 = 43;
          else
            v35 = 45;
          v36 = object_getClassName(v2);
          v37 = sel_getName("_sync_configureReaderModeRFForTransitPartner:transitPartner:connection:completion:");
          v38 = v47[5];
          *(_DWORD *)v52 = 67110402;
          *(_DWORD *)&v52[4] = v35;
          v53 = 2082;
          v54 = v36;
          v55 = 2082;
          v56 = v37;
          v57 = 1024;
          v58 = 4852;
          v59 = 1024;
          v60 = v44;
          v61 = 2114;
          v62 = v38;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i configureReaderModeRFForTransitPartner for %d, failed: %{public}@", v52, 0x32u);
        }

      }
      v4[2](v4, v47[5]);
    }
    else
    {
      v39 = objc_alloc((Class)NSError);
      v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      *(_QWORD *)v52 = NSLocalizedDescriptionKey;
      v41 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
      *(_QWORD *)buf = v41;
      v42 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, v52, 1));
      v43 = objc_msgSend(v39, "initWithDomain:code:userInfo:", v40, 58, v42);
      ((void (**)(id, id))v4)[2](v4, v43);

    }
    _Block_object_dispose(&v46, 8);

  }
}

void sub_1000FFF80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_1000FFFB0(uint64_t a1)
{
  id v2;
  void *v3;
  void *v4;
  void *v5;
  id v6;
  uint64_t v7;
  void *v8;
  NSErrorUserInfoKey v10;
  void *v11;

  if ((sub_1001CB940(*(void **)(*(_QWORD *)(a1 + 32) + 368), *(unsigned __int8 *)(a1 + 52), *(_DWORD *)(a1 + 48)) & 1) == 0)
  {
    v2 = objc_alloc((Class)NSError);
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v10 = NSLocalizedDescriptionKey;
    v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
    v11 = v4;
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v11, &v10, 1));
    v6 = objc_msgSend(v2, "initWithDomain:code:userInfo:", v3, 15, v5);
    v7 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    v8 = *(void **)(v7 + 40);
    *(_QWORD *)(v7 + 40) = v6;

  }
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40) == 0;
}

id sub_10010115C(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "maybeStartNextSession");
}

void sub_100101A44(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_100101A60(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "maybeStartNextSession");
}

void sub_100101B1C(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  NSObject *v11;
  objc_class *v12;
  int v13;
  const char *v14;
  const char *v15;
  void *v16;
  void *v17;
  void *v18;
  uint64_t v19;
  id v20;
  void *v21;
  void *v22;
  void *v23;
  id v24;
  const char *Name;
  NSErrorUserInfoKey v26;
  void *v27;
  uint8_t buf[4];
  int v29;
  __int16 v30;
  const char *v31;
  __int16 v32;
  const char *v33;
  __int16 v34;
  int v35;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    v8 = 45;
    if (isMetaClass)
      v8 = 43;
    v4(5, "%c[%{public}s %{public}s]:%i ", v8, ClassName, Name, 5031);
  }
  v9 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v10 = NFSharedLogGetLogger(v9);
  v11 = objc_claimAutoreleasedReturnValue(v10);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v12 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v12))
      v13 = 43;
    else
      v13 = 45;
    v14 = object_getClassName(*(id *)(a1 + 32));
    v15 = sel_getName(*(SEL *)(a1 + 56));
    *(_DWORD *)buf = 67109890;
    v29 = v13;
    v30 = 2082;
    v31 = v14;
    v32 = 2082;
    v33 = v15;
    v34 = 1024;
    v35 = 5031;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
  }

  if (-[_NFHardwareManager getPrimaryHardwareState]_0(*(_QWORD *)(a1 + 32)) == 2
    || -[_NFHardwareManager getPrimaryHardwareState]_0(*(_QWORD *)(a1 + 32)) == 5)
  {
    v16 = *(void **)(a1 + 32);
    v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "NF_userInfo"));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "objectForKeyedSubscript:", CFSTR("ClientName")));
    sub_1000E7B58(v16, 0, v18);

    (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
  }
  else
  {
    v19 = *(_QWORD *)(a1 + 48);
    v20 = objc_alloc((Class)NSError);
    v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v26 = NSLocalizedDescriptionKey;
    v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
    v27 = v22;
    v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v27, &v26, 1));
    v24 = objc_msgSend(v20, "initWithDomain:code:userInfo:", v21, 58, v23);
    (*(void (**)(uint64_t, _QWORD, id))(v19 + 16))(v19, 0, v24);

  }
}

void sub_1001025A0(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  id v4;
  void *v5;
  void *v6;
  id v7;
  id v8;
  void *v9;
  void *v10;
  void *v11;
  uint64_t v12;
  id v13;
  id v14;
  id v15;
  id v16;
  id v17;
  void *v18;
  id v19;
  void *v20;
  id v21;
  uint64_t v22;
  void *v23;
  id v24;
  id v25;
  void *v26;
  id v27;
  _QWORD v28[5];
  _QWORD v29[5];
  _QWORD v30[4];
  _QWORD v31[4];
  _QWORD v32[4];
  _QWORD v33[4];
  _QWORD v34[4];
  _QWORD v35[4];
  _QWORD v36[4];
  _QWORD v37[4];

  v2 = *(_QWORD *)(a1 + 32);
  if (!v2 || objc_msgSend(*(id *)(v2 + 40), "OSMode") != (id)2)
  {
    v3 = *(void **)(a1 + 40);
    v13 = objc_alloc((Class)NSError);
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v36[0] = NSLocalizedDescriptionKey;
    v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "JCOP not available"));
    v37[0] = v6;
    v37[1] = &off_1002FF3D8;
    v36[1] = CFSTR("Line");
    v36[2] = CFSTR("Method");
    v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v37[2] = v7;
    v36[3] = NSDebugDescriptionErrorKey;
    v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 5096);
    v37[3] = v8;
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v37, v36, 4));
    v10 = v13;
    v11 = v5;
    v12 = 53;
    goto LABEL_6;
  }
  if (objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 40), "restrictedMode"))
  {
    v3 = *(void **)(a1 + 40);
    v4 = objc_alloc((Class)NSError);
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v34[0] = NSLocalizedDescriptionKey;
    v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Restricted Mode"));
    v35[0] = v6;
    v35[1] = &off_1002FF3F0;
    v34[1] = CFSTR("Line");
    v34[2] = CFSTR("Method");
    v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v35[2] = v7;
    v34[3] = NSDebugDescriptionErrorKey;
    v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 5099);
    v35[3] = v8;
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v35, v34, 4));
    v10 = v4;
    v11 = v5;
    v12 = 24;
LABEL_6:
    v14 = objc_msgSend(v10, "initWithDomain:code:userInfo:", v11, v12, v9);
    objc_msgSend(v3, "didStartSession:", v14);

    goto LABEL_7;
  }
  if (sub_1000E4180(*(_QWORD *)(a1 + 32)))
  {
    v3 = *(void **)(a1 + 40);
    v15 = objc_alloc((Class)NSError);
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v32[0] = NSLocalizedDescriptionKey;
    v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Applet Migration"));
    v33[0] = v6;
    v33[1] = &off_1002FF408;
    v32[1] = CFSTR("Line");
    v32[2] = CFSTR("Method");
    v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v33[2] = v7;
    v32[3] = NSDebugDescriptionErrorKey;
    v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 5102);
    v33[3] = v8;
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v33, v32, 4));
    v10 = v15;
    v11 = v5;
    v12 = 26;
    goto LABEL_6;
  }
  if (sub_1000E41D4(*(_QWORD *)(a1 + 32)))
  {
    v3 = *(void **)(a1 + 40);
    v16 = objc_alloc((Class)NSError);
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v30[0] = NSLocalizedDescriptionKey;
    v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "JCOP in OSU"));
    v31[0] = v6;
    v31[1] = &off_1002FF420;
    v30[1] = CFSTR("Line");
    v30[2] = CFSTR("Method");
    v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v31[2] = v7;
    v30[3] = NSDebugDescriptionErrorKey;
    v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 5105);
    v31[3] = v8;
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v31, v30, 4));
    v10 = v16;
    v11 = v5;
    v12 = 52;
    goto LABEL_6;
  }
  v17 = sub_1001C7B30(*(_QWORD *)(a1 + 32), *(void **)(a1 + 40), *(void **)(a1 + 48), 0);
  v5 = (void *)objc_claimAutoreleasedReturnValue(v17);
  if (v5)
  {
    v18 = *(void **)(a1 + 40);
    v19 = objc_alloc((Class)NSError);
    v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v21 = objc_msgSend(v5, "code");
    v28[0] = NSLocalizedDescriptionKey;
    if ((uint64_t)objc_msgSend(v5, "code") > 70)
      v22 = 71;
    else
      v22 = (uint64_t)objc_msgSend(v5, "code");
    v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E7F70[v22]));
    v29[0] = v23;
    v29[1] = v5;
    v28[1] = NSUnderlyingErrorKey;
    v28[2] = CFSTR("Line");
    v29[2] = &off_1002FF438;
    v28[3] = CFSTR("Method");
    v24 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v29[3] = v24;
    v28[4] = NSDebugDescriptionErrorKey;
    v25 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 5109);
    v29[4] = v25;
    v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v29, v28, 5));
    v27 = objc_msgSend(v19, "initWithDomain:code:userInfo:", v20, v21, v26);
    objc_msgSend(v18, "didStartSession:", v27);

  }
  else
  {
    objc_msgSend(*(id *)(a1 + 32), "maybeStartNextSession");
  }
LABEL_7:

}

void sub_1001033BC(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  id v4;
  void *v5;
  void *v6;
  id v7;
  id v8;
  void *v9;
  void *v10;
  void *v11;
  uint64_t v12;
  id v13;
  id v14;
  id v15;
  id v16;
  id v17;
  void *v18;
  id v19;
  void *v20;
  id v21;
  uint64_t v22;
  void *v23;
  id v24;
  id v25;
  void *v26;
  id v27;
  _QWORD v28[5];
  _QWORD v29[5];
  _QWORD v30[4];
  _QWORD v31[4];
  _QWORD v32[4];
  _QWORD v33[4];
  _QWORD v34[4];
  _QWORD v35[4];
  _QWORD v36[4];
  _QWORD v37[4];

  v2 = *(_QWORD *)(a1 + 32);
  if (!v2 || objc_msgSend(*(id *)(v2 + 40), "OSMode") != (id)2)
  {
    v3 = *(void **)(a1 + 40);
    v13 = objc_alloc((Class)NSError);
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v36[0] = NSLocalizedDescriptionKey;
    v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "JCOP not available"));
    v37[0] = v6;
    v37[1] = &off_1002FF450;
    v36[1] = CFSTR("Line");
    v36[2] = CFSTR("Method");
    v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v37[2] = v7;
    v36[3] = NSDebugDescriptionErrorKey;
    v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 5168);
    v37[3] = v8;
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v37, v36, 4));
    v10 = v13;
    v11 = v5;
    v12 = 53;
    goto LABEL_6;
  }
  if (objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 40), "restrictedMode"))
  {
    v3 = *(void **)(a1 + 40);
    v4 = objc_alloc((Class)NSError);
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v34[0] = NSLocalizedDescriptionKey;
    v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Restricted Mode"));
    v35[0] = v6;
    v35[1] = &off_1002FF468;
    v34[1] = CFSTR("Line");
    v34[2] = CFSTR("Method");
    v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v35[2] = v7;
    v34[3] = NSDebugDescriptionErrorKey;
    v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 5171);
    v35[3] = v8;
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v35, v34, 4));
    v10 = v4;
    v11 = v5;
    v12 = 24;
LABEL_6:
    v14 = objc_msgSend(v10, "initWithDomain:code:userInfo:", v11, v12, v9);
    objc_msgSend(v3, "didStartSession:", v14);

    goto LABEL_7;
  }
  if (sub_1000E4180(*(_QWORD *)(a1 + 32)))
  {
    v3 = *(void **)(a1 + 40);
    v15 = objc_alloc((Class)NSError);
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v32[0] = NSLocalizedDescriptionKey;
    v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Applet Migration"));
    v33[0] = v6;
    v33[1] = &off_1002FF480;
    v32[1] = CFSTR("Line");
    v32[2] = CFSTR("Method");
    v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v33[2] = v7;
    v32[3] = NSDebugDescriptionErrorKey;
    v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 5174);
    v33[3] = v8;
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v33, v32, 4));
    v10 = v15;
    v11 = v5;
    v12 = 26;
    goto LABEL_6;
  }
  if (sub_1000E41D4(*(_QWORD *)(a1 + 32)))
  {
    v3 = *(void **)(a1 + 40);
    v16 = objc_alloc((Class)NSError);
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v30[0] = NSLocalizedDescriptionKey;
    v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "JCOP in OSU"));
    v31[0] = v6;
    v31[1] = &off_1002FF498;
    v30[1] = CFSTR("Line");
    v30[2] = CFSTR("Method");
    v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v31[2] = v7;
    v30[3] = NSDebugDescriptionErrorKey;
    v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 5177);
    v31[3] = v8;
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v31, v30, 4));
    v10 = v16;
    v11 = v5;
    v12 = 52;
    goto LABEL_6;
  }
  v17 = sub_1001C7B30(*(_QWORD *)(a1 + 32), *(void **)(a1 + 40), *(void **)(a1 + 48), 0);
  v5 = (void *)objc_claimAutoreleasedReturnValue(v17);
  if (v5)
  {
    v18 = *(void **)(a1 + 40);
    v19 = objc_alloc((Class)NSError);
    v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v21 = objc_msgSend(v5, "code");
    v28[0] = NSLocalizedDescriptionKey;
    if ((uint64_t)objc_msgSend(v5, "code") > 70)
      v22 = 71;
    else
      v22 = (uint64_t)objc_msgSend(v5, "code");
    v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E7F70[v22]));
    v29[0] = v23;
    v29[1] = v5;
    v28[1] = NSUnderlyingErrorKey;
    v28[2] = CFSTR("Line");
    v29[2] = &off_1002FF4B0;
    v28[3] = CFSTR("Method");
    v24 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v29[3] = v24;
    v28[4] = NSDebugDescriptionErrorKey;
    v25 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 5181);
    v29[4] = v25;
    v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v29, v28, 5));
    v27 = objc_msgSend(v19, "initWithDomain:code:userInfo:", v20, v21, v26);
    objc_msgSend(v18, "didStartSession:", v27);

  }
  else
  {
    objc_msgSend(*(id *)(a1 + 32), "maybeStartNextSession");
  }
LABEL_7:

}

id sub_100104564(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "maybeStartNextSession");
}

void sub_100105AD8(uint64_t a1)
{
  id v2;
  void *v3;
  unsigned int v4;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  id v9;
  id v10;
  void *specific;
  uint64_t Logger;
  void (*v13)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  NSObject *v20;
  objc_class *v21;
  int v22;
  const char *v23;
  const char *v24;
  const char *Name;
  uint8_t buf[4];
  int v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  const char *v31;
  __int16 v32;
  int v33;

  v2 = sub_1001F8494(*(id *)(*(_QWORD *)(a1 + 32) + 368));
  v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  v4 = objc_msgSend(v3, "fdOn");

  objc_msgSend(*(id *)(a1 + 32), "maybeStartNextSession");
  if (objc_msgSend(*(id *)(a1 + 40), "count"))
    v5 = v4 == 0;
  else
    v5 = 1;
  if (!v5 && (sub_1000E7A2C(*(_QWORD *)(a1 + 32)) & 1) == 0)
  {
    v6 = *(_QWORD *)(a1 + 32);
    v7 = *(_QWORD *)(v6 + 24);
    if ((!v7 || !*(_BYTE *)(v7 + 172)) && (objc_msgSend(*(id *)(v6 + 408), "isActive") & 1) == 0)
    {
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 368);
      if (v8)
      {
        objc_msgSend(*(id *)(v8 + 104), "lock");
        v9 = objc_retainAutorelease(*(id *)(v8 + 160));
        objc_msgSend(*(id *)(v8 + 104), "unlock");
        v10 = v9;
        if (v10)
        {
          specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          Logger = NFLogGetLogger(specific);
          if (Logger)
          {
            v13 = (void (*)(uint64_t, const char *, ...))Logger;
            Class = object_getClass(*(id *)(a1 + 32));
            isMetaClass = class_isMetaClass(Class);
            ClassName = object_getClassName(*(id *)(a1 + 32));
            Name = sel_getName(*(SEL *)(a1 + 48));
            v17 = 45;
            if (isMetaClass)
              v17 = 43;
            v13(6, "%c[%{public}s %{public}s]:%i Restart FD to refresh field notification", v17, ClassName, Name, 5429);
          }
          v18 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v19 = NFSharedLogGetLogger(v18);
          v20 = objc_claimAutoreleasedReturnValue(v19);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            v21 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v21))
              v22 = 43;
            else
              v22 = 45;
            v23 = object_getClassName(*(id *)(a1 + 32));
            v24 = sel_getName(*(SEL *)(a1 + 48));
            *(_DWORD *)buf = 67109890;
            v27 = v22;
            v28 = 2082;
            v29 = v23;
            v30 = 2082;
            v31 = v24;
            v32 = 1024;
            v33 = 5429;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Restart FD to refresh field notification", buf, 0x22u);
          }

          sub_1001FBF60(*(void **)(*(_QWORD *)(a1 + 32) + 368));
        }
      }
      else
      {
        v10 = 0;
      }

    }
  }
}

id sub_1001069B4(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "maybeStartNextSession");
}

id sub_100107648(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "maybeStartNextSession");
}

id sub_10010824C(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "maybeStartNextSession");
}

id sub_100108E44(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "maybeStartNextSession");
}

void sub_100109918(uint64_t a1)
{
  id v2;
  void *v3;
  id v4;
  void *v5;
  void *v6;
  id v7;
  void *v8;
  id v9;
  uint64_t v10;
  uint64_t v11;
  void *specific;
  uint64_t Logger;
  void (*v14)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  NSObject *v21;
  objc_class *v22;
  int v23;
  const char *v24;
  const char *v25;
  void *v26;
  id v27;
  id v28;
  void *v29;
  id v30;
  const char *Name;
  uint8_t buf[4];
  int v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  const char *v37;
  __int16 v38;
  int v39;
  _QWORD v40[5];
  _QWORD v41[5];

  v2 = sub_10019C0D0((uint64_t)NFSystemPowerConsumptionMonitor);
  v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  objc_msgSend(*(id *)(a1 + 32), "setPowerConsumptionReporter:", v3);

  v4 = sub_1001C7B30(*(_QWORD *)(a1 + 40), *(void **)(a1 + 32), *(void **)(a1 + 48), 0);
  v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  v6 = *(void **)(a1 + 32);
  if (v5)
  {
    v7 = objc_alloc((Class)NSError);
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v9 = objc_msgSend(v5, "code");
    v40[0] = NSLocalizedDescriptionKey;
    if ((uint64_t)objc_msgSend(v5, "code") > 70)
      v10 = 71;
    else
      v10 = (uint64_t)objc_msgSend(v5, "code");
    v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E7F70[v10]));
    v41[0] = v26;
    v41[1] = v5;
    v40[1] = NSUnderlyingErrorKey;
    v40[2] = CFSTR("Line");
    v41[2] = &off_1002FF4C8;
    v40[3] = CFSTR("Method");
    v27 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v41[3] = v27;
    v40[4] = NSDebugDescriptionErrorKey;
    v28 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 5782);
    v41[4] = v28;
    v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v41, v40, 5));
    v30 = objc_msgSend(v7, "initWithDomain:code:userInfo:", v8, v9, v29);
    objc_msgSend(v6, "didStartSession:", v30);

  }
  else
  {
    if (objc_msgSend(*(id *)(a1 + 32), "forceExpressExit"))
    {
      if (!*(_BYTE *)(a1 + 64))
      {
        v11 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 24);
        if (v11)
        {
          if (*(_BYTE *)(v11 + 172))
          {
            specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            Logger = NFLogGetLogger(specific);
            if (Logger)
            {
              v14 = (void (*)(uint64_t, const char *, ...))Logger;
              Class = object_getClass(*(id *)(a1 + 40));
              isMetaClass = class_isMetaClass(Class);
              ClassName = object_getClassName(*(id *)(a1 + 40));
              Name = sel_getName(*(SEL *)(a1 + 56));
              v18 = 45;
              if (isMetaClass)
                v18 = 43;
              v14(6, "%c[%{public}s %{public}s]:%i forceExpressExit is set - re-prioritiing the session.", v18, ClassName, Name, 5787);
            }
            v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v20 = NFSharedLogGetLogger(v19);
            v21 = objc_claimAutoreleasedReturnValue(v20);
            if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
            {
              v22 = object_getClass(*(id *)(a1 + 40));
              if (class_isMetaClass(v22))
                v23 = 43;
              else
                v23 = 45;
              v24 = object_getClassName(*(id *)(a1 + 40));
              v25 = sel_getName(*(SEL *)(a1 + 56));
              *(_DWORD *)buf = 67109890;
              v33 = v23;
              v34 = 2082;
              v35 = v24;
              v36 = 2082;
              v37 = v25;
              v38 = 1024;
              v39 = 5787;
              _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i forceExpressExit is set - re-prioritiing the session.", buf, 0x22u);
            }

            objc_msgSend(*(id *)(a1 + 40), "prioritizeSession:", *(_QWORD *)(a1 + 32));
          }
        }
      }
    }
    objc_msgSend(*(id *)(a1 + 40), "maybeStartNextSession");
  }

}

id sub_10010A4AC(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "maybeStartNextSession");
}

id sub_10010A9FC(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "maybeStartNextSession");
}

void sub_10010B3AC(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  id v4;
  _NFCardSession *v5;
  void *v6;
  id v7;
  id v8;
  void *v9;
  void *v10;
  _NFCardSession *v11;
  uint64_t v12;
  void *v13;
  id v14;
  id v15;
  id v16;
  _NFCardSession *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  id *v21;
  void *v22;
  id v23;
  void *v24;
  void *specific;
  uint64_t Logger;
  void (*v27)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  NSObject *v34;
  objc_class *v35;
  int v36;
  const char *v37;
  const char *v38;
  uint64_t v39;
  id v40;
  void *v41;
  void *v42;
  id v43;
  id v44;
  void *v45;
  id v46;
  id *v47;
  NSObject *v48;
  const char *Name;
  _QWORD block[5];
  _QWORD v51[4];
  _QWORD v52[4];
  uint8_t buf[4];
  int v54;
  __int16 v55;
  const char *v56;
  __int16 v57;
  const char *v58;
  __int16 v59;
  int v60;
  _QWORD v61[4];
  _QWORD v62[4];
  _QWORD v63[4];
  _QWORD v64[4];
  _QWORD v65[4];
  _QWORD v66[4];

  switch(a2)
  {
    case 0:
      v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
      objc_msgSend(v13, "handleFailureInMethod:object:file:lineNumber:description:", *(_QWORD *)(a1 + 88), *(_QWORD *)(a1 + 32), CFSTR("_NFHardwareManager.m"), 5992, CFSTR("Invalid state"));

      v3 = *(_QWORD *)(a1 + 80);
      v14 = objc_alloc((Class)NSError);
      v5 = (_NFCardSession *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v61[0] = NSLocalizedDescriptionKey;
      v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid State"));
      v62[0] = v6;
      v62[1] = &off_1002FF528;
      v61[1] = CFSTR("Line");
      v61[2] = CFSTR("Method");
      v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 88)));
      v62[2] = v7;
      v61[3] = NSDebugDescriptionErrorKey;
      v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 88)), 5993);
      v62[3] = v8;
      v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v62, v61, 4));
      v10 = v14;
      v11 = v5;
      v12 = 12;
      goto LABEL_7;
    case 3:
      v3 = *(_QWORD *)(a1 + 80);
      v15 = objc_alloc((Class)NSError);
      v5 = (_NFCardSession *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v63[0] = NSLocalizedDescriptionKey;
      v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session ineligible"));
      v64[0] = v6;
      v64[1] = &off_1002FF510;
      v63[1] = CFSTR("Line");
      v63[2] = CFSTR("Method");
      v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 88)));
      v64[2] = v7;
      v63[3] = NSDebugDescriptionErrorKey;
      v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 88)), 5989);
      v64[3] = v8;
      v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v64, v63, 4));
      v10 = v15;
      v11 = v5;
      v12 = 70;
      goto LABEL_7;
    case 2:
      v3 = *(_QWORD *)(a1 + 80);
      v4 = objc_alloc((Class)NSError);
      v5 = (_NFCardSession *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v65[0] = NSLocalizedDescriptionKey;
      v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "TCC access denied"));
      v66[0] = v6;
      v66[1] = &off_1002FF4F8;
      v65[1] = CFSTR("Line");
      v65[2] = CFSTR("Method");
      v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 88)));
      v66[2] = v7;
      v65[3] = NSDebugDescriptionErrorKey;
      v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 88)), 5986);
      v66[3] = v8;
      v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v66, v65, 4));
      v10 = v4;
      v11 = v5;
      v12 = 69;
LABEL_7:
      v16 = objc_msgSend(v10, "initWithDomain:code:userInfo:", v11, v12, v9);
      (*(void (**)(uint64_t, _QWORD, _QWORD, id))(v3 + 16))(v3, 0, 0, v16);

      goto LABEL_8;
  }
  v17 = [_NFCardSession alloc];
  v18 = *(_QWORD *)(a1 + 48);
  v19 = *(_QWORD *)(a1 + 56);
  v20 = *(_QWORD *)(a1 + 40);
  v21 = sub_100111A40(*(id **)(a1 + 32));
  v22 = (void *)objc_claimAutoreleasedReturnValue(v21);
  v5 = -[_NFCardSession initWithConfig:allowlistChecker:remoteObject:workQueue:](v17, "initWithConfig:allowlistChecker:remoteObject:workQueue:", v20, v18, v19, v22);

  if (v5)
  {
    -[_NFSession setQueue:](v5, "setQueue:", *(_QWORD *)(a1 + 32));
    -[_NFXPCSession setConnection:](v5, "setConnection:", *(_QWORD *)(a1 + 64));
    -[_NFSession setUid:](v5, "setUid:", *(unsigned int *)(a1 + 96));
    -[_NFHCESession setReadOnConnected:](v5, "setReadOnConnected:", 1);
    -[_NFHCESession setEmulationOnSessionStart:](v5, "setEmulationOnSessionStart:", 1);
    -[_NFSession setServiceType:](v5, "setServiceType:", objc_msgSend(*(id *)(a1 + 72), "unsignedIntegerValue"));
    buf[0] = 0;
    v23 = sub_1001C7B30(*(_QWORD *)(a1 + 32), v5, *(void **)(a1 + 64), buf);
    v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
    if (!v24)
    {
      v47 = sub_100111A40(*(id **)(a1 + 32));
      v48 = objc_claimAutoreleasedReturnValue(v47);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10010BBA4;
      block[3] = &unk_1002E5C58;
      block[4] = *(_QWORD *)(a1 + 32);
      dispatch_async(v48, block);

    }
    (*(void (**)(void))(*(_QWORD *)(a1 + 80) + 16))();

  }
  else
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v27 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 88));
      v31 = 45;
      if (isMetaClass)
        v31 = 43;
      v27(3, "%c[%{public}s %{public}s]:%i Session creation failed.", v31, ClassName, Name, 6002);
    }
    v32 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v33 = NFSharedLogGetLogger(v32);
    v34 = objc_claimAutoreleasedReturnValue(v33);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
    {
      v35 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v35))
        v36 = 43;
      else
        v36 = 45;
      v37 = object_getClassName(*(id *)(a1 + 32));
      v38 = sel_getName(*(SEL *)(a1 + 88));
      *(_DWORD *)buf = 67109890;
      v54 = v36;
      v55 = 2082;
      v56 = v37;
      v57 = 2082;
      v58 = v38;
      v59 = 1024;
      v60 = 6002;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session creation failed.", buf, 0x22u);
    }

    v39 = *(_QWORD *)(a1 + 80);
    v40 = objc_alloc((Class)NSError);
    v41 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v51[0] = NSLocalizedDescriptionKey;
    v42 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unexpected Result"));
    v52[0] = v42;
    v52[1] = &off_1002FF540;
    v51[1] = CFSTR("Line");
    v51[2] = CFSTR("Method");
    v43 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 88)));
    v52[2] = v43;
    v51[3] = NSDebugDescriptionErrorKey;
    v44 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 88)), 6003);
    v52[3] = v44;
    v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v52, v51, 4));
    v46 = objc_msgSend(v40, "initWithDomain:code:userInfo:", v41, 13, v45);
    (*(void (**)(uint64_t, _QWORD, _QWORD, id))(v39 + 16))(v39, 0, 0, v46);

    v5 = 0;
  }
LABEL_8:

}

id sub_10010BBA4(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "maybeStartNextSession");
}

void sub_10010C4F0(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  id v4;
  _NFFieldDetectSession *v5;
  void *v6;
  id v7;
  id v8;
  void *v9;
  void *v10;
  _NFFieldDetectSession *v11;
  uint64_t v12;
  void *v13;
  id v14;
  id v15;
  id v16;
  _NFFieldDetectSession *v17;
  uint64_t v18;
  id *v19;
  void *v20;
  void *specific;
  uint64_t Logger;
  void (*v23)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  NSObject *v30;
  objc_class *v31;
  int v32;
  const char *v33;
  const char *v34;
  uint64_t v35;
  id v36;
  void *v37;
  void *v38;
  id v39;
  id v40;
  void *v41;
  id v42;
  const char *Name;
  _QWORD v44[4];
  _QWORD v45[4];
  uint8_t buf[4];
  int v47;
  __int16 v48;
  const char *v49;
  __int16 v50;
  const char *v51;
  __int16 v52;
  int v53;
  _QWORD v54[4];
  _QWORD v55[4];
  _QWORD v56[4];
  _QWORD v57[4];
  _QWORD v58[4];
  _QWORD v59[4];

  switch(a2)
  {
    case 0:
      v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
      objc_msgSend(v13, "handleFailureInMethod:object:file:lineNumber:description:", *(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 32), CFSTR("_NFHardwareManager.m"), 6081, CFSTR("Invalid state"));

      v3 = *(_QWORD *)(a1 + 64);
      v14 = objc_alloc((Class)NSError);
      v5 = (_NFFieldDetectSession *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v54[0] = NSLocalizedDescriptionKey;
      v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid State"));
      v55[0] = v6;
      v55[1] = &off_1002FF5A0;
      v54[1] = CFSTR("Line");
      v54[2] = CFSTR("Method");
      v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 72)));
      v55[2] = v7;
      v54[3] = NSDebugDescriptionErrorKey;
      v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 72)), 6082);
      v55[3] = v8;
      v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v55, v54, 4));
      v10 = v14;
      v11 = v5;
      v12 = 12;
      goto LABEL_7;
    case 3:
      v3 = *(_QWORD *)(a1 + 64);
      v15 = objc_alloc((Class)NSError);
      v5 = (_NFFieldDetectSession *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v56[0] = NSLocalizedDescriptionKey;
      v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session ineligible"));
      v57[0] = v6;
      v57[1] = &off_1002FF588;
      v56[1] = CFSTR("Line");
      v56[2] = CFSTR("Method");
      v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 72)));
      v57[2] = v7;
      v56[3] = NSDebugDescriptionErrorKey;
      v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 72)), 6078);
      v57[3] = v8;
      v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v57, v56, 4));
      v10 = v15;
      v11 = v5;
      v12 = 70;
      goto LABEL_7;
    case 2:
      v3 = *(_QWORD *)(a1 + 64);
      v4 = objc_alloc((Class)NSError);
      v5 = (_NFFieldDetectSession *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v58[0] = NSLocalizedDescriptionKey;
      v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "TCC access denied"));
      v59[0] = v6;
      v59[1] = &off_1002FF570;
      v58[1] = CFSTR("Line");
      v58[2] = CFSTR("Method");
      v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 72)));
      v59[2] = v7;
      v58[3] = NSDebugDescriptionErrorKey;
      v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 72)), 6075);
      v59[3] = v8;
      v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v59, v58, 4));
      v10 = v4;
      v11 = v5;
      v12 = 69;
LABEL_7:
      v16 = objc_msgSend(v10, "initWithDomain:code:userInfo:", v11, v12, v9);
      (*(void (**)(uint64_t, _QWORD, id))(v3 + 16))(v3, 0, v16);

      goto LABEL_8;
  }
  v17 = [_NFFieldDetectSession alloc];
  v18 = *(_QWORD *)(a1 + 40);
  v19 = sub_100111A40(*(id **)(a1 + 32));
  v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
  v5 = -[_NFFieldDetectSession initWithRemoteObject:workQueue:](v17, "initWithRemoteObject:workQueue:", v18, v20);

  if (v5)
  {
    -[_NFSession setQueue:](v5, "setQueue:", *(_QWORD *)(a1 + 32));
    -[_NFXPCSession setConnection:](v5, "setConnection:", *(_QWORD *)(a1 + 48));
    -[_NFSession setUid:](v5, "setUid:", *(unsigned int *)(a1 + 80));
    -[_NFSession setServiceType:](v5, "setServiceType:", objc_msgSend(*(id *)(a1 + 56), "unsignedIntegerValue"));
    -[_NFFieldDetectSession setNotificationConfig:](v5, "setNotificationConfig:", 14);
    -[_NFFieldDetectSession setNotificationCategories:](v5, "setNotificationCategories:", 4);
    sub_100098D38(*(_QWORD *)(a1 + 32), v5, 1, *(_DWORD *)(a1 + 84), *(void **)(a1 + 64));
  }
  else
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v23 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 72));
      v27 = 45;
      if (isMetaClass)
        v27 = 43;
      v23(3, "%c[%{public}s %{public}s]:%i Session creation failed.", v27, ClassName, Name, 6090);
    }
    v28 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v29 = NFSharedLogGetLogger(v28);
    v30 = objc_claimAutoreleasedReturnValue(v29);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      v31 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v31))
        v32 = 43;
      else
        v32 = 45;
      v33 = object_getClassName(*(id *)(a1 + 32));
      v34 = sel_getName(*(SEL *)(a1 + 72));
      *(_DWORD *)buf = 67109890;
      v47 = v32;
      v48 = 2082;
      v49 = v33;
      v50 = 2082;
      v51 = v34;
      v52 = 1024;
      v53 = 6090;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session creation failed.", buf, 0x22u);
    }

    v35 = *(_QWORD *)(a1 + 64);
    v36 = objc_alloc((Class)NSError);
    v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v44[0] = NSLocalizedDescriptionKey;
    v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unexpected Result"));
    v45[0] = v38;
    v45[1] = &off_1002FF5B8;
    v44[1] = CFSTR("Line");
    v44[2] = CFSTR("Method");
    v39 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 72)));
    v45[2] = v39;
    v44[3] = NSDebugDescriptionErrorKey;
    v40 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 72)), 6091);
    v45[3] = v40;
    v41 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v45, v44, 4));
    v42 = objc_msgSend(v36, "initWithDomain:code:userInfo:", v37, 13, v41);
    (*(void (**)(uint64_t, _QWORD, id))(v35 + 16))(v35, 0, v42);

    v5 = 0;
  }
LABEL_8:

}

uint64_t sub_10010D1A8(uint64_t a1, uint64_t a2)
{
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  objc_class *v13;
  int v14;
  const char *v15;
  const char *v16;
  const char *ClassName;
  const char *Name;
  uint8_t buf[4];
  int v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  const char *v25;
  __int16 v26;
  int v27;
  __int16 v28;
  uint64_t v29;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v6 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v9 = 45;
    if (isMetaClass)
      v9 = 43;
    v6(6, "%c[%{public}s %{public}s]:%i eligible=%lu", v9, ClassName, Name, 6129, a2);
  }
  v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v11 = NFSharedLogGetLogger(v10);
  v12 = objc_claimAutoreleasedReturnValue(v11);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    v13 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v13))
      v14 = 43;
    else
      v14 = 45;
    v15 = object_getClassName(*(id *)(a1 + 32));
    v16 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)buf = 67110146;
    v21 = v14;
    v22 = 2082;
    v23 = v15;
    v24 = 2082;
    v25 = v16;
    v26 = 1024;
    v27 = 6129;
    v28 = 2048;
    v29 = a2;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i eligible=%lu", buf, 0x2Cu);
  }

  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
}

void sub_10010D3FC(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  id v3;
  id v4;
  void *v5;
  void *specific;
  uint64_t Logger;
  void (*v8)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  id v13;
  void *v14;
  void *v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  NSObject *v19;
  objc_class *v20;
  int v21;
  const char *v22;
  const char *v23;
  void *v24;
  id v25;
  void *v26;
  id v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void (*v31)(uint64_t, const char *, ...);
  objc_class *v32;
  _BOOL4 v33;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  NSObject *v37;
  objc_class *v38;
  int v39;
  const char *v40;
  const char *v41;
  id v42;
  void *v43;
  id v44;
  uint64_t v45;
  id v46;
  void *v47;
  void *v48;
  void *v49;
  id v50;
  objc_class *v51;
  _BOOL4 v52;
  const char *v53;
  uint64_t v54;
  void *v55;
  uint64_t v56;
  NSObject *v57;
  objc_class *v58;
  int v59;
  const char *v60;
  const char *v61;
  void *v62;
  id v63;
  id v64;
  void *v65;
  id v66;
  const char *v67;
  const char *v68;
  const char *v69;
  id v70;
  void (**v71)(_QWORD, id);
  _QWORD v72[5];
  uint8_t buf[8];
  _BYTE v74[36];

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(void **)(a1 + 48);
  v3 = *(id *)(a1 + 40);
  v4 = v2;
  v5 = v4;
  if (!v1)
    goto LABEL_39;
  v71 = (void (**)(_QWORD, id))v4;
  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v8 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass((id)v1);
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName((id)v1);
    Name = sel_getName("_sync_preWarmForConnection:completion:");
    v13 = v3;
    v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "NF_userInfo"));
    v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "objectForKeyedSubscript:", CFSTR("ClientName")));
    v16 = 45;
    if (isMetaClass)
      v16 = 43;
    v8(6, "%c[%{public}s %{public}s]:%i %{public}@", v16, ClassName, Name, 6144, v15);

    v3 = v13;
  }
  v17 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v18 = NFSharedLogGetLogger(v17);
  v19 = objc_claimAutoreleasedReturnValue(v18);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    v20 = object_getClass((id)v1);
    if (class_isMetaClass(v20))
      v21 = 43;
    else
      v21 = 45;
    v22 = object_getClassName((id)v1);
    v23 = sel_getName("_sync_preWarmForConnection:completion:");
    v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "NF_userInfo"));
    v25 = v3;
    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v24, "objectForKeyedSubscript:", CFSTR("ClientName")));
    *(_DWORD *)buf = 67110146;
    *(_DWORD *)&buf[4] = v21;
    *(_WORD *)v74 = 2082;
    *(_QWORD *)&v74[2] = v22;
    *(_WORD *)&v74[10] = 2082;
    *(_QWORD *)&v74[12] = v23;
    *(_WORD *)&v74[20] = 1024;
    *(_DWORD *)&v74[22] = 6144;
    *(_WORD *)&v74[26] = 2114;
    *(_QWORD *)&v74[28] = v26;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);

    v3 = v25;
  }

  if (-[_NFHardwareManager getPrimaryHardwareState]_0(v1) != 2
    && -[_NFHardwareManager getPrimaryHardwareState]_0(v1) != 5)
  {
    v46 = objc_alloc((Class)NSError);
    v47 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v72[0] = NSLocalizedDescriptionKey;
    v48 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
    *(_QWORD *)buf = v48;
    v49 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, v72, 1));
    v50 = objc_msgSend(v46, "initWithDomain:code:userInfo:", v47, 58, v49);
    v5 = v71;
    v71[2](v71, v50);

    goto LABEL_39;
  }
  if (*(_BYTE *)(v1 + 338) || sub_10000993C(*(void **)(v1 + 88)))
  {
LABEL_38:
    v5 = v71;
    v71[2](v71, 0);
    goto LABEL_39;
  }
  v27 = sub_1001F84C8(*(void **)(v1 + 368), CFSTR("Prewarm"), 0);
  v28 = (void *)objc_claimAutoreleasedReturnValue(v27);
  v29 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v30 = NFLogGetLogger(v29);
  v31 = (void (*)(uint64_t, const char *, ...))v30;
  if (!v28)
  {
    if (v30)
    {
      v51 = object_getClass((id)v1);
      v52 = class_isMetaClass(v51);
      v53 = object_getClassName((id)v1);
      v69 = sel_getName("_sync_preWarmForConnection:completion:");
      v54 = 45;
      if (v52)
        v54 = 43;
      v31(6, "%c[%{public}s %{public}s]:%i pre-warming hardware until unlock", v54, v53, v69, 6160);
    }
    v55 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v56 = NFSharedLogGetLogger(v55);
    v57 = objc_claimAutoreleasedReturnValue(v56);
    if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
    {
      v58 = object_getClass((id)v1);
      if (class_isMetaClass(v58))
        v59 = 43;
      else
        v59 = 45;
      v60 = object_getClassName((id)v1);
      v61 = sel_getName("_sync_preWarmForConnection:completion:");
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)&buf[4] = v59;
      *(_WORD *)v74 = 2082;
      *(_QWORD *)&v74[2] = v60;
      *(_WORD *)&v74[10] = 2082;
      *(_QWORD *)&v74[12] = v61;
      *(_WORD *)&v74[20] = 1024;
      *(_DWORD *)&v74[22] = 6160;
      _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i pre-warming hardware until unlock", buf, 0x22u);
    }

    *(_BYTE *)(v1 + 338) = 1;
    goto LABEL_38;
  }
  if (v30)
  {
    v32 = object_getClass((id)v1);
    v33 = class_isMetaClass(v32);
    v67 = object_getClassName((id)v1);
    v68 = sel_getName("_sync_preWarmForConnection:completion:");
    v34 = 45;
    if (v33)
      v34 = 43;
    v31(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v34, v67, v68, 6156, v28);
  }
  v35 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v36 = NFSharedLogGetLogger(v35);
  v37 = objc_claimAutoreleasedReturnValue(v36);
  if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
  {
    v38 = object_getClass((id)v1);
    if (class_isMetaClass(v38))
      v39 = 43;
    else
      v39 = 45;
    v40 = object_getClassName((id)v1);
    v41 = sel_getName("_sync_preWarmForConnection:completion:");
    *(_DWORD *)buf = 67110146;
    *(_DWORD *)&buf[4] = v39;
    *(_WORD *)v74 = 2082;
    *(_QWORD *)&v74[2] = v40;
    *(_WORD *)&v74[10] = 2082;
    *(_QWORD *)&v74[12] = v41;
    *(_WORD *)&v74[20] = 1024;
    *(_DWORD *)&v74[22] = 6156;
    *(_WORD *)&v74[26] = 2112;
    *(_QWORD *)&v74[28] = v28;
    _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
  }

  v42 = objc_alloc((Class)NSError);
  v43 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
  v44 = objc_msgSend(v28, "code");
  v72[0] = NSLocalizedDescriptionKey;
  v70 = v3;
  if ((uint64_t)objc_msgSend(v28, "code") > 70)
    v45 = 71;
  else
    v45 = (uint64_t)objc_msgSend(v28, "code");
  v62 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E7F70[v45]));
  *(_QWORD *)buf = v62;
  *(_QWORD *)v74 = v28;
  v72[1] = NSUnderlyingErrorKey;
  v72[2] = CFSTR("Line");
  *(_QWORD *)&v74[8] = &off_1002FF5D0;
  v72[3] = CFSTR("Method");
  v63 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_preWarmForConnection:completion:"));
  *(_QWORD *)&v74[16] = v63;
  v72[4] = NSDebugDescriptionErrorKey;
  v64 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_preWarmForConnection:completion:"), 6157);
  *(_QWORD *)&v74[24] = v64;
  v65 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, v72, 5));
  v66 = objc_msgSend(v42, "initWithDomain:code:userInfo:", v43, v44, v65);
  v5 = v71;
  v71[2](v71, v66);

  v3 = v70;
LABEL_39:

}

void sub_10010DBF0(uint64_t a1)
{
  id *v1;
  void *v2;
  id v3;
  id v4;
  void *v5;
  void *specific;
  uint64_t Logger;
  void (*v8)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  id v13;
  void *v14;
  void *v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  NSObject *v19;
  objc_class *v20;
  int v21;
  const char *v22;
  const char *v23;
  void *v24;
  id v25;
  void *v26;
  void *v27;
  int v28;
  id v29;
  void *v30;
  void *v31;
  id v32;
  void *v33;
  uint64_t v34;
  void (*v35)(uint64_t, const char *, ...);
  objc_class *v36;
  _BOOL4 v37;
  const char *v38;
  uint64_t v39;
  void *v40;
  uint64_t v41;
  NSObject *v42;
  objc_class *v43;
  int v44;
  const char *v45;
  const char *v46;
  id v47;
  void *v48;
  void *v49;
  void *v50;
  id v51;
  uint64_t v52;
  const char *v53;
  int v54;
  id v55;
  NSErrorUserInfoKey v56;
  uint8_t buf[8];
  __int16 v58;
  const char *v59;
  __int16 v60;
  const char *v61;
  __int16 v62;
  int v63;
  __int16 v64;
  void *v65;

  v54 = *(_DWORD *)(a1 + 56);
  v1 = *(id **)(a1 + 32);
  v2 = *(void **)(a1 + 48);
  v3 = *(id *)(a1 + 40);
  v4 = v2;
  v5 = v4;
  if (v1)
  {
    v55 = v4;
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v8 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v1);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(v1);
      Name = sel_getName("_sync_updateBackgroundTagReading:connection:completion:");
      v13 = v3;
      v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "NF_userInfo"));
      v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "objectForKeyedSubscript:", CFSTR("ClientName")));
      v16 = 45;
      if (isMetaClass)
        v16 = 43;
      v8(6, "%c[%{public}s %{public}s]:%i %{public}@", v16, ClassName, Name, 6180, v15);

      v3 = v13;
    }
    v17 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v18 = NFSharedLogGetLogger(v17);
    v19 = objc_claimAutoreleasedReturnValue(v18);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      v20 = object_getClass(v1);
      if (class_isMetaClass(v20))
        v21 = 43;
      else
        v21 = 45;
      v22 = object_getClassName(v1);
      v23 = sel_getName("_sync_updateBackgroundTagReading:connection:completion:");
      v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "NF_userInfo"));
      v25 = v3;
      v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v24, "objectForKeyedSubscript:", CFSTR("ClientName")));
      *(_DWORD *)buf = 67110146;
      *(_DWORD *)&buf[4] = v21;
      v58 = 2082;
      v59 = v22;
      v60 = 2082;
      v61 = v23;
      v62 = 1024;
      v63 = 6180;
      v64 = 2114;
      v65 = v26;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);

      v3 = v25;
    }

    if (-[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)v1) == 2)
    {
      v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "NF_whitelistChecker"));
      if ((objc_msgSend(v27, "readerInternalAccess") & 1) != 0)
      {
        if (byte_10032A9C4)
          v28 = 3;
        else
          v28 = 2;
        v5 = v55;
        if (v54 && v28 != v54)
        {
          if (v54 == 2)
          {
            byte_10032A9C4 = 0;
            objc_msgSend(v1[51], "resume");
          }
          else if (v54 == 3)
          {
            byte_10032A9C4 = 1;
            objc_msgSend(v1[51], "suspend");
          }
        }
        if (byte_10032A9C4)
          v52 = 3;
        else
          v52 = 2;
        (*((void (**)(id, _QWORD, uint64_t))v55 + 2))(v55, 0, v52);
      }
      else
      {
        v33 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v34 = NFLogGetLogger(v33);
        if (v34)
        {
          v35 = (void (*)(uint64_t, const char *, ...))v34;
          v36 = object_getClass(v1);
          v37 = class_isMetaClass(v36);
          v38 = object_getClassName(v1);
          v53 = sel_getName("_sync_updateBackgroundTagReading:connection:completion:");
          v39 = 45;
          if (v37)
            v39 = 43;
          v35(3, "%c[%{public}s %{public}s]:%i Invalid entitlements, requiring internal reader access", v39, v38, v53, 6190);
        }
        v40 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v41 = NFSharedLogGetLogger(v40);
        v42 = objc_claimAutoreleasedReturnValue(v41);
        if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
        {
          v43 = object_getClass(v1);
          if (class_isMetaClass(v43))
            v44 = 43;
          else
            v44 = 45;
          v45 = object_getClassName(v1);
          v46 = sel_getName("_sync_updateBackgroundTagReading:connection:completion:");
          *(_DWORD *)buf = 67109890;
          *(_DWORD *)&buf[4] = v44;
          v58 = 2082;
          v59 = v45;
          v60 = 2082;
          v61 = v46;
          v62 = 1024;
          v63 = 6190;
          _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid entitlements, requiring internal reader access", buf, 0x22u);
        }

        v47 = objc_alloc((Class)NSError);
        v48 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v56 = NSLocalizedDescriptionKey;
        v49 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Not entitled"));
        *(_QWORD *)buf = v49;
        v50 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v56, 1));
        v51 = objc_msgSend(v47, "initWithDomain:code:userInfo:", v48, 32, v50);
        v5 = v55;
        (*((void (**)(id, id, _QWORD))v55 + 2))(v55, v51, 0);

      }
    }
    else
    {
      v29 = objc_alloc((Class)NSError);
      v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v56 = NSLocalizedDescriptionKey;
      v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
      *(_QWORD *)buf = v30;
      v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v56, 1));
      v32 = objc_msgSend(v29, "initWithDomain:code:userInfo:", v27, 58, v31);
      v5 = v55;
      (*((void (**)(id, id, uint64_t))v55 + 2))(v55, v32, 1);

    }
  }

}

void sub_10010E1DC(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void (**v3)(_QWORD);
  uint64_t v4;
  void *specific;
  uint64_t Logger;
  void (*v7)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  void (*v21)(uint64_t, const char *, ...);
  objc_class *v22;
  _BOOL4 v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  objc_class *v27;
  int v28;
  char v29;
  uint64_t v30;
  BOOL v31;
  BOOL v33;
  uint64_t v35;
  void *v36;
  id v37;
  void *v38;
  uint64_t v39;
  void (*v40)(uint64_t, const char *, ...);
  objc_class *v41;
  _BOOL4 v42;
  uint64_t v43;
  void *v44;
  uint64_t v45;
  NSObject *v46;
  objc_class *v47;
  int v48;
  id v49;
  _BYTE *v50;
  void *v51;
  uint64_t v52;
  void (*v53)(uint64_t, const char *, ...);
  objc_class *v54;
  _BOOL4 v55;
  const char *v56;
  uint64_t v57;
  void *v58;
  uint64_t v59;
  NSObject *v60;
  objc_class *v61;
  int v62;
  const char *v63;
  const char *v64;
  void *v65;
  id v66;
  id v67;
  uint64_t v68;
  NSArray *v69;
  id v70;
  void *v71;
  uint64_t v72;
  void (*v73)(uint64_t, const char *, ...);
  objc_class *v74;
  _BOOL4 v75;
  uint64_t v76;
  void *v77;
  uint64_t v78;
  NSObject *v79;
  objc_class *v80;
  int v81;
  id v82;
  _BYTE *v83;
  void *v84;
  id v85;
  void *v86;
  uint64_t v87;
  void (*v88)(uint64_t, const char *, ...);
  objc_class *v89;
  _BOOL4 v90;
  uint64_t v91;
  void *v92;
  uint64_t v93;
  NSObject *v94;
  objc_class *v95;
  int v96;
  const char *ClassName;
  const char *v98;
  const char *v99;
  const char *v100;
  const char *v101;
  const char *Name;
  const char *v103;
  const char *v104;
  const char *v105;
  const char *v106;
  const char *v107;
  uint8_t buf[4];
  int v109;
  __int16 v110;
  const char *v111;
  __int16 v112;
  const char *v113;
  __int16 v114;
  int v115;
  __int16 v116;
  int v117;

  v1 = *(unsigned int *)(a1 + 48);
  v2 = *(_QWORD *)(a1 + 32);
  v3 = (void (**)(_QWORD))*(id *)(a1 + 40);
  if (v2)
  {
    if (!(_DWORD)v1)
    {
LABEL_28:
      v3[2](v3);
      goto LABEL_29;
    }
    v4 = sub_100197958(*(_QWORD *)(v2 + 368));
    if (*(_BYTE *)(v2 + 349))
    {
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v7 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass((id)v2);
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName((id)v2);
        Name = sel_getName("_sync_actOnUserInitiatedSystemShutDown:completion:");
        v10 = 45;
        if (isMetaClass)
          v10 = 43;
        v7(6, "%c[%{public}s %{public}s]:%i User shutdown (0x%x) - testing headless", v10, ClassName, Name, 6232, v1);
      }
      v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v12 = NFSharedLogGetLogger(v11);
      v13 = objc_claimAutoreleasedReturnValue(v12);
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        goto LABEL_25;
      v14 = object_getClass((id)v2);
      if (class_isMetaClass(v14))
        v15 = 43;
      else
        v15 = 45;
      *(_DWORD *)buf = 67110146;
      v109 = v15;
      v110 = 2082;
      v111 = object_getClassName((id)v2);
      v112 = 2082;
      v113 = sel_getName("_sync_actOnUserInitiatedSystemShutDown:completion:");
      v114 = 1024;
      v115 = 6232;
      v116 = 1024;
      v117 = v1;
      v16 = "%c[%{public}s %{public}s]:%i User shutdown (0x%x) - testing headless";
LABEL_24:
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v16, buf, 0x28u);
LABEL_25:

LABEL_26:
      v29 = 0;
LABEL_27:
      *(_BYTE *)(v2 + 356) = v29;
      goto LABEL_28;
    }
    v17 = v4;
    v18 = *(_QWORD *)(v2 + 24);
    if (v18 && *(_BYTE *)(v18 + 170))
    {
      v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v20 = NFLogGetLogger(v19);
      if (v20)
      {
        v21 = (void (*)(uint64_t, const char *, ...))v20;
        v22 = object_getClass((id)v2);
        v23 = class_isMetaClass(v22);
        v98 = object_getClassName((id)v2);
        v103 = sel_getName("_sync_actOnUserInitiatedSystemShutDown:completion:");
        v24 = 45;
        if (v23)
          v24 = 43;
        v21(6, "%c[%{public}s %{public}s]:%i User shutdown (0x%x) - factory test mode", v24, v98, v103, 6237, v1);
      }
      v25 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v26 = NFSharedLogGetLogger(v25);
      v13 = objc_claimAutoreleasedReturnValue(v26);
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        goto LABEL_25;
      v27 = object_getClass((id)v2);
      if (class_isMetaClass(v27))
        v28 = 43;
      else
        v28 = 45;
      *(_DWORD *)buf = 67110146;
      v109 = v28;
      v110 = 2082;
      v111 = object_getClassName((id)v2);
      v112 = 2082;
      v113 = sel_getName("_sync_actOnUserInitiatedSystemShutDown:completion:");
      v114 = 1024;
      v115 = 6237;
      v116 = 1024;
      v117 = v1;
      v16 = "%c[%{public}s %{public}s]:%i User shutdown (0x%x) - factory test mode";
      goto LABEL_24;
    }
    v30 = v4 & 0x1C;
    if (objc_msgSend(*(id *)(v2 + 384), "hasLPEMSupport"))
      v31 = v30 == 0;
    else
      v31 = 1;
    if (!v31 && (v17 & 0xFFFFFFFFFFFFFFE3) == 0)
    {
      v38 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v39 = NFLogGetLogger(v38);
      if (v39)
      {
        v40 = (void (*)(uint64_t, const char *, ...))v39;
        v41 = object_getClass((id)v2);
        v42 = class_isMetaClass(v41);
        v99 = object_getClassName((id)v2);
        v104 = sel_getName("_sync_actOnUserInitiatedSystemShutDown:completion:");
        v43 = 45;
        if (v42)
          v43 = 43;
        v40(6, "%c[%{public}s %{public}s]:%i User shutdown (0x%x) - find my is enabled", v43, v99, v104, 6244, v1);
      }
      v44 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v45 = NFSharedLogGetLogger(v44);
      v46 = objc_claimAutoreleasedReturnValue(v45);
      if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
      {
        v47 = object_getClass((id)v2);
        if (class_isMetaClass(v47))
          v48 = 43;
        else
          v48 = 45;
        *(_DWORD *)buf = 67110146;
        v109 = v48;
        v110 = 2082;
        v111 = object_getClassName((id)v2);
        v112 = 2082;
        v113 = sel_getName("_sync_actOnUserInitiatedSystemShutDown:completion:");
        v114 = 1024;
        v115 = 6244;
        v116 = 1024;
        v117 = v1;
        _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i User shutdown (0x%x) - find my is enabled", buf, 0x28u);
      }

      v49 = sub_100203984((uint64_t)NFHeadlessModeController);
      v50 = (_BYTE *)objc_claimAutoreleasedReturnValue(v49);
      sub_100206140(v50);

      v51 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v52 = NFLogGetLogger(v51);
      if (v52)
      {
        v53 = (void (*)(uint64_t, const char *, ...))v52;
        v54 = object_getClass((id)v2);
        v55 = class_isMetaClass(v54);
        v56 = object_getClassName((id)v2);
        v105 = sel_getName("_sync_actOnUserInitiatedSystemShutDown:completion:");
        v57 = 45;
        if (v55)
          v57 = 43;
        v53(6, "%c[%{public}s %{public}s]:%i Clear SE express config", v57, v56, v105, 6250);
      }
      v58 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v59 = NFSharedLogGetLogger(v58);
      v60 = objc_claimAutoreleasedReturnValue(v59);
      if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
      {
        v61 = object_getClass((id)v2);
        if (class_isMetaClass(v61))
          v62 = 43;
        else
          v62 = 45;
        v63 = object_getClassName((id)v2);
        v64 = sel_getName("_sync_actOnUserInitiatedSystemShutDown:completion:");
        *(_DWORD *)buf = 67109890;
        v109 = v62;
        v110 = 2082;
        v111 = v63;
        v112 = 2082;
        v113 = v64;
        v114 = 1024;
        v115 = 6250;
        _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Clear SE express config", buf, 0x22u);
      }

      goto LABEL_71;
    }
    if (objc_msgSend(*(id *)(v2 + 384), "hasLPEMSupport"))
      v33 = v30 == 0;
    else
      v33 = 1;
    if (!v33 && (v17 & 3) != 0)
    {
      v71 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v72 = NFLogGetLogger(v71);
      if (v72)
      {
        v73 = (void (*)(uint64_t, const char *, ...))v72;
        v74 = object_getClass((id)v2);
        v75 = class_isMetaClass(v74);
        v100 = object_getClassName((id)v2);
        v106 = sel_getName("_sync_actOnUserInitiatedSystemShutDown:completion:");
        v76 = 45;
        if (v75)
          v76 = 43;
        v73(6, "%c[%{public}s %{public}s]:%i User shutdown (0x%x) - find my is enabled but so is NFC / Alisha", v76, v100, v106, 6265, v1);
      }
      v77 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v78 = NFSharedLogGetLogger(v77);
      v79 = objc_claimAutoreleasedReturnValue(v78);
      if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
      {
        v80 = object_getClass((id)v2);
        if (class_isMetaClass(v80))
          v81 = 43;
        else
          v81 = 45;
        *(_DWORD *)buf = 67110146;
        v109 = v81;
        v110 = 2082;
        v111 = object_getClassName((id)v2);
        v112 = 2082;
        v113 = sel_getName("_sync_actOnUserInitiatedSystemShutDown:completion:");
        v114 = 1024;
        v115 = 6265;
        v116 = 1024;
        v117 = v1;
        _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i User shutdown (0x%x) - find my is enabled but so is NFC / Alisha", buf, 0x28u);
      }

      v82 = sub_100203984((uint64_t)NFHeadlessModeController);
      v83 = (_BYTE *)objc_claimAutoreleasedReturnValue(v82);
      sub_100206140(v83);

      if ((v17 & 2) != 0)
        sub_1001980AC(*(_QWORD *)(v2 + 368), 2);
LABEL_71:
      v65 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig embeddedWiredMode](NFRoutingConfig, "embeddedWiredMode"));
      v66 = objc_msgSend((id)v2, "setRoutingConfig:", v65);

      v67 = sub_10022DCC4(*(void **)(v2 + 376));
      v68 = *(_QWORD *)(v2 + 24);
      v69 = objc_opt_new(NSArray);
      v70 = sub_100040810(v68, v69, 0, 0);

      sub_10003D1FC(*(_QWORD *)(v2 + 24));
      goto LABEL_26;
    }
    if (!objc_msgSend(*(id *)(v2 + 384), "hasLPEMSupport"))
      goto LABEL_51;
    v35 = *(_QWORD *)(v2 + 24);
    if (v35)
    {
      if (*(_QWORD *)(v35 + 136) == 1)
        goto LABEL_83;
      LOBYTE(v35) = *(_BYTE *)(v35 + 170) != 0;
    }
    if ((v35 & 1) == 0 && !v17)
    {
LABEL_51:
      v36 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig routingOff](NFRoutingConfig, "routingOff"));
      v37 = objc_msgSend((id)v2, "setRoutingConfig:", v36);

LABEL_93:
      v29 = 1;
      goto LABEL_27;
    }
LABEL_83:
    v84 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig routingOff](NFRoutingConfig, "routingOff"));
    v85 = objc_msgSend((id)v2, "setRoutingConfig:", v84);

    v86 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v87 = NFLogGetLogger(v86);
    if (v87)
    {
      v88 = (void (*)(uint64_t, const char *, ...))v87;
      v89 = object_getClass((id)v2);
      v90 = class_isMetaClass(v89);
      v101 = object_getClassName((id)v2);
      v107 = sel_getName("_sync_actOnUserInitiatedSystemShutDown:completion:");
      v91 = 45;
      if (v90)
        v91 = 43;
      v88(6, "%c[%{public}s %{public}s]:%i User shutdown (0x%x) - tearing down headless", v91, v101, v107, 6282, v1);
    }
    v92 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v93 = NFSharedLogGetLogger(v92);
    v94 = objc_claimAutoreleasedReturnValue(v93);
    if (os_log_type_enabled(v94, OS_LOG_TYPE_DEFAULT))
    {
      v95 = object_getClass((id)v2);
      if (class_isMetaClass(v95))
        v96 = 43;
      else
        v96 = 45;
      *(_DWORD *)buf = 67110146;
      v109 = v96;
      v110 = 2082;
      v111 = object_getClassName((id)v2);
      v112 = 2082;
      v113 = sel_getName("_sync_actOnUserInitiatedSystemShutDown:completion:");
      v114 = 1024;
      v115 = 6282;
      v116 = 1024;
      v117 = v1;
      _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i User shutdown (0x%x) - tearing down headless", buf, 0x28u);
    }

    sub_1001982D0(*(id *)(v2 + 368));
    goto LABEL_93;
  }
LABEL_29:

}

void sub_10010ECB0(uint64_t a1)
{
  char v2;
  void *specific;
  uint64_t Logger;
  void (*v5)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  objc_class *v13;
  int v14;
  const char *v15;
  const char *v16;
  const char *v17;
  NSObject *v18;
  os_log_type_t v19;
  objc_class *v20;
  _BOOL4 v21;
  const char *v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  objc_class *v26;
  int v27;
  const char *v28;
  const char *v29;
  const char *Name;
  const char *v31;
  uint8_t buf[4];
  int v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  const char *v37;
  __int16 v38;
  int v39;

  v2 = sub_1001FBF60(*(void **)(*(_QWORD *)(a1 + 32) + 368));
  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  v5 = (void (*)(uint64_t, const char *, ...))Logger;
  if ((v2 & 1) != 0)
  {
    if (Logger)
    {
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 40));
      v9 = 45;
      if (isMetaClass)
        v9 = 43;
      v5(6, "%c[%{public}s %{public}s]:%i Succesfully restarted Discovery", v9, ClassName, Name, 6342);
    }
    v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v11 = NFSharedLogGetLogger(v10);
    v12 = objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      v13 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v13))
        v14 = 43;
      else
        v14 = 45;
      v15 = object_getClassName(*(id *)(a1 + 32));
      v16 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)buf = 67109890;
      v33 = v14;
      v34 = 2082;
      v35 = v15;
      v36 = 2082;
      v37 = v16;
      v38 = 1024;
      v39 = 6342;
      v17 = "%c[%{public}s %{public}s]:%i Succesfully restarted Discovery";
      v18 = v12;
      v19 = OS_LOG_TYPE_DEFAULT;
LABEL_20:
      _os_log_impl((void *)&_mh_execute_header, v18, v19, v17, buf, 0x22u);
    }
  }
  else
  {
    if (Logger)
    {
      v20 = object_getClass(*(id *)(a1 + 32));
      v21 = class_isMetaClass(v20);
      v22 = object_getClassName(*(id *)(a1 + 32));
      v31 = sel_getName(*(SEL *)(a1 + 40));
      v23 = 45;
      if (v21)
        v23 = 43;
      v5(3, "%c[%{public}s %{public}s]:%i Error restarting Discovery", v23, v22, v31, 6339);
    }
    v24 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v25 = NFSharedLogGetLogger(v24);
    v12 = objc_claimAutoreleasedReturnValue(v25);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v26 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v26))
        v27 = 43;
      else
        v27 = 45;
      v28 = object_getClassName(*(id *)(a1 + 32));
      v29 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)buf = 67109890;
      v33 = v27;
      v34 = 2082;
      v35 = v28;
      v36 = 2082;
      v37 = v29;
      v38 = 1024;
      v39 = 6339;
      v17 = "%c[%{public}s %{public}s]:%i Error restarting Discovery";
      v18 = v12;
      v19 = OS_LOG_TYPE_ERROR;
      goto LABEL_20;
    }
  }

}

id sub_10010EF8C(uint64_t a1)
{
  id result;
  uint64_t v3;

  result = sub_1001FFBD4(*(void **)(*(_QWORD *)(a1 + 32) + 368));
  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 368);
  if (v3)
    return (id)NFDriverSimulateCrash(*(_QWORD *)(v3 + 40), 57005, *(_QWORD *)(a1 + 40));
  return result;
}

id sub_10010F658(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "preferencesDidChange");
}

id *sub_100111A40(id *a1)
{
  if (a1)
    a1 = (id *)a1[29];
  return a1;
}

void sub_100111F38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_100111F70(uint64_t a1)
{
  void *v2;
  void *v3;
  id v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;

  v2 = *(void **)(*(_QWORD *)(a1 + 32) + 368);
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "handle"));
  v4 = sub_10002789C(v2, (uint64_t)objc_msgSend(v3, "identifier"));
  v5 = objc_claimAutoreleasedReturnValue(v4);
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
  v7 = *(void **)(v6 + 40);
  *(_QWORD *)(v6 + 40) = v5;

  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40) == 0;
}

void sub_100111FE8(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  void *v5;
  id v6;
  void *v7;
  void *v8;
  unsigned int v9;
  void *v10;
  void *specific;
  uint64_t Logger;
  void (*v13)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  NSObject *v22;
  objc_class *v23;
  int v24;
  const char *v25;
  const char *v26;
  void *v27;
  int v28;
  uint8_t buf[4];
  int v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  int v36;
  __int16 v37;
  void *v38;
  __int16 v39;
  int v40;
  __int16 v41;
  unsigned int v42;

  v3 = a2;
  v4 = objc_opt_class(_NFXPCSession);
  if ((objc_opt_isKindOfClass(v3, v4) & 1) != 0)
    v5 = v3;
  else
    v5 = 0;
  v6 = v5;
  v7 = v6;
  if (v6)
  {
    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "connection"));
    if ((objc_msgSend(v8, "NF_presentmentIntentSuppressionHolder") & 1) != 0)
    {
      v9 = 1;
    }
    else
    {
      v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "connection"));
      v9 = objc_msgSend(v10, "NF_fdPresentmentIntentSuppressionHolder");

    }
  }
  else
  {
    v9 = 0;
  }
  if ((!*(_BYTE *)(a1 + 48) || v9)
    && ((objc_msgSend(v3, "requireSuppressDefaultAppPresentmentAssertion") ^ 1 | v9) & 1) != 0)
  {
    objc_msgSend(v3, "handleFieldChanged:", *(unsigned __int8 *)(a1 + 49));
  }
  else
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v13 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 40));
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "clientName"));
      v19 = 45;
      if (isMetaClass)
        v19 = 43;
      v13(5, "%c[%{public}s %{public}s]:%i Suppress notification to %{public}@ (defaultAppPresentmentSuppression=%d, assertionHolder=%d)", v19, ClassName, Name, 6775, v18, *(unsigned __int8 *)(a1 + 48), v9);

    }
    v20 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v21 = NFSharedLogGetLogger(v20);
    v22 = objc_claimAutoreleasedReturnValue(v21);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      v23 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v23))
        v24 = 43;
      else
        v24 = 45;
      v25 = object_getClassName(*(id *)(a1 + 32));
      v26 = sel_getName(*(SEL *)(a1 + 40));
      v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "clientName"));
      v28 = *(unsigned __int8 *)(a1 + 48);
      *(_DWORD *)buf = 67110658;
      v30 = v24;
      v31 = 2082;
      v32 = v25;
      v33 = 2082;
      v34 = v26;
      v35 = 1024;
      v36 = 6775;
      v37 = 2114;
      v38 = v27;
      v39 = 1024;
      v40 = v28;
      v41 = 1024;
      v42 = v9;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Suppress notification to %{public}@ (defaultAppPresentmentSuppression=%d, assertionHolder=%d)", buf, 0x38u);

    }
  }

}

void sub_100112310(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  objc_class *v13;
  int v14;
  const char *v15;
  const char *v16;
  uint64_t v17;
  int v18;
  char v19;
  uint64_t v20;
  void *v21;
  id v22;
  void *v23;
  uint64_t v24;
  void (*v25)(uint64_t, const char *, ...);
  objc_class *v26;
  _BOOL4 v27;
  const char *v28;
  uint64_t v29;
  void *v30;
  uint64_t v31;
  NSObject *v32;
  objc_class *v33;
  int v34;
  const char *v35;
  const char *v36;
  int v37;
  NSObject *v38;
  void *v39;
  uint64_t v40;
  void (*v41)(uint64_t, const char *, ...);
  objc_class *v42;
  _BOOL4 v43;
  const char *v44;
  const char *v45;
  uint64_t v46;
  void *v47;
  uint64_t v48;
  NSObject *v49;
  objc_class *v50;
  int v51;
  const char *v52;
  const char *v53;
  uint64_t v54;
  const char *v55;
  __int128 v56;
  _QWORD v57[5];
  __int128 v58;
  char v59;
  uint8_t buf[8];
  _BYTE v61[10];
  __int16 v62;
  const char *v63;
  __int16 v64;
  int v65;
  __int16 v66;
  uint64_t v67;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v9 = 45;
    if (isMetaClass)
      v9 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 6789, *(_QWORD *)(a1 + 40));
  }
  v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v11 = NFSharedLogGetLogger(v10);
  v12 = objc_claimAutoreleasedReturnValue(v11);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    v13 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v13))
      v14 = 43;
    else
      v14 = 45;
    v15 = object_getClassName(*(id *)(a1 + 32));
    v16 = sel_getName(*(SEL *)(a1 + 48));
    v17 = *(_QWORD *)(a1 + 40);
    *(_DWORD *)buf = 67110146;
    *(_DWORD *)&buf[4] = v14;
    *(_WORD *)v61 = 2082;
    *(_QWORD *)&v61[2] = v15;
    v62 = 2082;
    v63 = v16;
    v64 = 1024;
    v65 = 6789;
    v66 = 2114;
    v67 = v17;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }

  sub_1000086F4(*(void **)(a1 + 32), *(void **)(a1 + 40));
  if (sub_1001701C8(*(_QWORD *)(a1 + 32)) && objc_msgSend(*(id *)(a1 + 40), "chFieldType") != (id)1)
  {
    v39 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v40 = NFLogGetLogger(v39);
    if (v40)
    {
      v41 = (void (*)(uint64_t, const char *, ...))v40;
      v42 = object_getClass(*(id *)(a1 + 32));
      v43 = class_isMetaClass(v42);
      v44 = object_getClassName(*(id *)(a1 + 32));
      v45 = sel_getName(*(SEL *)(a1 + 48));
      v46 = 45;
      if (v43)
        v46 = 43;
      v41(5, "%c[%{public}s %{public}s]:%i Dropping field due to connection handover assertion: %@", v46, v44, v45, 6794, *(_QWORD *)(a1 + 40));
    }
    v47 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v48 = NFSharedLogGetLogger(v47);
    v49 = objc_claimAutoreleasedReturnValue(v48);
    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
    {
      v50 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v50))
        v51 = 43;
      else
        v51 = 45;
      v52 = object_getClassName(*(id *)(a1 + 32));
      v53 = sel_getName(*(SEL *)(a1 + 48));
      v54 = *(_QWORD *)(a1 + 40);
      *(_DWORD *)buf = 67110146;
      *(_DWORD *)&buf[4] = v51;
      *(_WORD *)v61 = 2082;
      *(_QWORD *)&v61[2] = v52;
      v62 = 2082;
      v63 = v53;
      v64 = 1024;
      v65 = 6794;
      v66 = 2112;
      v67 = v54;
      _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Dropping field due to connection handover assertion: %@", buf, 0x2Cu);
    }

  }
  else
  {
    v18 = sub_100170214(*(_QWORD *)(a1 + 32));
    v19 = objc_opt_respondsToSelector(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 112), "handleFilteredFieldNotification:");
    if ((v19 & 1) != 0)
      objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 112), "handleFilteredFieldNotification:", *(_QWORD *)(a1 + 40));
    v20 = *(_QWORD *)(a1 + 32);
    if (v20)
      v21 = *(void **)(v20 + 16);
    else
      v21 = 0;
    v57[0] = _NSConcreteStackBlock;
    v57[1] = 3221225472;
    v57[2] = sub_100112808;
    v57[3] = &unk_1002E8618;
    v59 = v18;
    v57[4] = v20;
    v56 = *(_OWORD *)(a1 + 40);
    v22 = (id)v56;
    v58 = v56;
    objc_msgSend(v21, "enumerateFieldDetectSessionsUsingBlock:", v57);
    if (v18)
    {
      v23 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v24 = NFLogGetLogger(v23);
      if (v24)
      {
        v25 = (void (*)(uint64_t, const char *, ...))v24;
        v26 = object_getClass(*(id *)(a1 + 32));
        v27 = class_isMetaClass(v26);
        v28 = object_getClassName(*(id *)(a1 + 32));
        v55 = sel_getName(*(SEL *)(a1 + 48));
        v29 = 45;
        if (v27)
          v29 = 43;
        v25(5, "%c[%{public}s %{public}s]:%i Default app presentment suppression in place", v29, v28, v55, 6829);
      }
      v30 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v31 = NFSharedLogGetLogger(v30);
      v32 = objc_claimAutoreleasedReturnValue(v31);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
        v33 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v33))
          v34 = 43;
        else
          v34 = 45;
        v35 = object_getClassName(*(id *)(a1 + 32));
        v36 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)buf = 67109890;
        *(_DWORD *)&buf[4] = v34;
        *(_WORD *)v61 = 2082;
        *(_QWORD *)&v61[2] = v35;
        v62 = 2082;
        v63 = v36;
        v64 = 1024;
        v65 = 6829;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Default app presentment suppression in place", buf, 0x22u);
      }

    }
    else
    {
      v37 = sub_10000949C(*(_QWORD *)(a1 + 32), *(void **)(a1 + 40));
      if ((v19 & 1) == 0 || v37)
      {
        v38 = _os_activity_create((void *)&_mh_execute_header, "resumeSessionWaitingOnField:forceStartSession:", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_IF_NONE_PRESENT);
        *(_QWORD *)buf = 0;
        *(_QWORD *)v61 = 0;
        os_activity_scope_enter(v38, (os_activity_scope_state_t)buf);
        os_activity_scope_leave((os_activity_scope_state_t)buf);

        sub_1000035AC(*(id **)(a1 + 32), *(void **)(a1 + 40), 0);
      }
    }

  }
}

void sub_100112808(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  void *v5;
  id v6;
  void *v7;
  void *v8;
  unsigned int v9;
  void *v10;
  void *specific;
  uint64_t Logger;
  void (*v13)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  NSObject *v22;
  objc_class *v23;
  int v24;
  const char *v25;
  const char *v26;
  void *v27;
  int v28;
  uint8_t buf[4];
  int v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  int v36;
  __int16 v37;
  void *v38;
  __int16 v39;
  int v40;
  __int16 v41;
  unsigned int v42;

  v3 = a2;
  v4 = objc_opt_class(_NFXPCSession);
  if ((objc_opt_isKindOfClass(v3, v4) & 1) != 0)
    v5 = v3;
  else
    v5 = 0;
  v6 = v5;
  v7 = v6;
  if (v6)
  {
    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "connection"));
    if ((objc_msgSend(v8, "NF_presentmentIntentSuppressionHolder") & 1) != 0)
    {
      v9 = 1;
    }
    else
    {
      v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "connection"));
      v9 = objc_msgSend(v10, "NF_fdPresentmentIntentSuppressionHolder");

    }
  }
  else
  {
    v9 = 0;
  }
  if ((!*(_BYTE *)(a1 + 56) || v9)
    && ((objc_msgSend(v3, "requireSuppressDefaultAppPresentmentAssertion") ^ 1 | v9) & 1) != 0)
  {
    objc_msgSend(v3, "handleFilteredFieldNotification:", *(_QWORD *)(a1 + 40));
  }
  else
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v13 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "clientName"));
      v19 = 45;
      if (isMetaClass)
        v19 = 43;
      v13(5, "%c[%{public}s %{public}s]:%i Suppress notification to %{public}@ (defaultAppPresentmentSuppression=%d, assertionHolder=%d)", v19, ClassName, Name, 6821, v18, *(unsigned __int8 *)(a1 + 56), v9);

    }
    v20 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v21 = NFSharedLogGetLogger(v20);
    v22 = objc_claimAutoreleasedReturnValue(v21);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      v23 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v23))
        v24 = 43;
      else
        v24 = 45;
      v25 = object_getClassName(*(id *)(a1 + 32));
      v26 = sel_getName(*(SEL *)(a1 + 48));
      v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "clientName"));
      v28 = *(unsigned __int8 *)(a1 + 56);
      *(_DWORD *)buf = 67110658;
      v30 = v24;
      v31 = 2082;
      v32 = v25;
      v33 = 2082;
      v34 = v26;
      v35 = 1024;
      v36 = 6821;
      v37 = 2114;
      v38 = v27;
      v39 = 1024;
      v40 = v28;
      v41 = 1024;
      v42 = v9;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Suppress notification to %{public}@ (defaultAppPresentmentSuppression=%d, assertionHolder=%d)", buf, 0x38u);

    }
  }

}

void sub_100112AA4(uint64_t a1, void *a2)
{
  id v4;
  id v5;
  uint64_t v6;
  void *v7;
  id v8;
  void *v9;
  void *v10;
  unsigned int v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  uint64_t v16;
  void (*v17)(uint64_t, const char *, ...);
  objc_class *v18;
  _BOOL4 v19;
  const char *v20;
  const char *v21;
  void *v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  NSObject *v26;
  objc_class *v27;
  int v28;
  const char *v29;
  const char *v30;
  void *v31;
  int v32;
  void *v33;
  unsigned int v34;
  void *specific;
  uint64_t Logger;
  void (*v37)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v41;
  void *v42;
  uint64_t v43;
  NSObject *v44;
  objc_class *v45;
  int v46;
  const char *v47;
  const char *v48;
  const char *Name;
  uint8_t buf[4];
  int v51;
  __int16 v52;
  const char *v53;
  __int16 v54;
  const char *v55;
  __int16 v56;
  int v57;
  __int16 v58;
  void *v59;
  __int16 v60;
  int v61;
  __int16 v62;
  unsigned int v63;

  v4 = a2;
  v5 = objc_msgSend(v4, "notificationCategories");
  v6 = objc_opt_class(_NFXPCSession);
  if ((objc_opt_isKindOfClass(v4, v6) & 1) != 0)
    v7 = v4;
  else
    v7 = 0;
  v8 = v7;
  v9 = v8;
  if (v8)
  {
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "connection"));
    if ((objc_msgSend(v10, "NF_presentmentIntentSuppressionHolder") & 1) != 0)
    {
      v11 = 1;
    }
    else
    {
      v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "connection"));
      v11 = objc_msgSend(v12, "NF_fdPresentmentIntentSuppressionHolder");

    }
  }
  else
  {
    v11 = 0;
  }
  if ((!*(_BYTE *)(a1 + 80) || v11)
    && ((objc_msgSend(v4, "requireSuppressDefaultAppPresentmentAssertion") ^ 1 | v11) & 1) != 0)
  {
    if (v5 == (id)-1 || (v5 & 4) == 0)
    {
      if (*(_BYTE *)(a1 + 81)
        || (v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "clientName")),
            v34 = objc_msgSend(v33, "isEqual:", CFSTR("passd")),
            v33,
            !v34))
      {
        objc_msgSend(v4, "handleFieldNotification:", *(_QWORD *)(a1 + 56));
      }
      else
      {
        specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        Logger = NFLogGetLogger(specific);
        if (Logger)
        {
          v37 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(*(id *)(a1 + 32));
          isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(*(id *)(a1 + 32));
          Name = sel_getName(*(SEL *)(a1 + 72));
          v41 = 45;
          if (isMetaClass)
            v41 = 43;
          v37(4, "%c[%{public}s %{public}s]:%i Suppress field notification to passd", v41, ClassName, Name, 6930);
        }
        v42 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v43 = NFSharedLogGetLogger(v42);
        v44 = objc_claimAutoreleasedReturnValue(v43);
        if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
        {
          v45 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v45))
            v46 = 43;
          else
            v46 = 45;
          v47 = object_getClassName(*(id *)(a1 + 32));
          v48 = sel_getName(*(SEL *)(a1 + 72));
          *(_DWORD *)buf = 67109890;
          v51 = v46;
          v52 = 2082;
          v53 = v47;
          v54 = 2082;
          v55 = v48;
          v56 = 1024;
          v57 = 6930;
          _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Suppress field notification to passd", buf, 0x22u);
        }

      }
    }
    else
    {
      v13 = *(void **)(a1 + 40);
      v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "bundleIdentifier"));
      LODWORD(v13) = objc_msgSend(v13, "isEqual:", v14);

      if ((_DWORD)v13)
        objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 40), a2);
      else
        objc_msgSend(*(id *)(a1 + 48), "addObject:", v4);
    }
  }
  else
  {
    v15 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v16 = NFLogGetLogger(v15);
    if (v16)
    {
      v17 = (void (*)(uint64_t, const char *, ...))v16;
      v18 = object_getClass(*(id *)(a1 + 32));
      v19 = class_isMetaClass(v18);
      v20 = object_getClassName(*(id *)(a1 + 32));
      v21 = sel_getName(*(SEL *)(a1 + 72));
      v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "clientName"));
      v23 = 45;
      if (v19)
        v23 = 43;
      v17(5, "%c[%{public}s %{public}s]:%i Suppress notification to %{public}@ (defaultAppPresentmentSuppression=%d, assertionHolder=%d)", v23, v20, v21, 6911, v22, *(unsigned __int8 *)(a1 + 80), v11);

    }
    v24 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v25 = NFSharedLogGetLogger(v24);
    v26 = objc_claimAutoreleasedReturnValue(v25);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      v27 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v27))
        v28 = 43;
      else
        v28 = 45;
      v29 = object_getClassName(*(id *)(a1 + 32));
      v30 = sel_getName(*(SEL *)(a1 + 72));
      v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "clientName"));
      v32 = *(unsigned __int8 *)(a1 + 80);
      *(_DWORD *)buf = 67110658;
      v51 = v28;
      v52 = 2082;
      v53 = v29;
      v54 = 2082;
      v55 = v30;
      v56 = 1024;
      v57 = 6911;
      v58 = 2114;
      v59 = v31;
      v60 = 1024;
      v61 = v32;
      v62 = 1024;
      v63 = v11;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Suppress notification to %{public}@ (defaultAppPresentmentSuppression=%d, assertionHolder=%d)", buf, 0x38u);

    }
  }

}

uint64_t sub_100112F50(uint64_t a1)
{
  uint64_t result;

  result = objc_opt_respondsToSelector(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 112), "handleSecureElementEndOfOperation");
  if ((result & 1) != 0)
    return (uint64_t)objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 112), "handleSecureElementEndOfOperation");
  return result;
}

void sub_100112FF4(uint64_t a1)
{
  sub_1000EC09C(*(void **)(a1 + 32), *(_DWORD *)(a1 + 48), *(_QWORD *)(a1 + 40));
}

void sub_100113320(uint64_t a1)
{
  id v2;
  void *v3;
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  objc_class *v13;
  int v14;
  const char *v15;
  const char *v16;
  NSObject *v17;
  void *v18;
  void *v19;
  unsigned int v20;
  id v21;
  void *v22;
  const char *ClassName;
  const char *Name;
  uint8_t buf[4];
  int v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  int v32;
  __int16 v33;
  void *v34;

  v2 = sub_1001F84C8(*(void **)(*(_QWORD *)(a1 + 32) + 368), CFSTR("Entered restrictedMode Exit"), 0);
  v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  if (v3)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 40));
      v9 = 45;
      if (isMetaClass)
        v9 = 43;
      v6(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v9, ClassName, Name, 7004, v3);
    }
    v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v11 = NFSharedLogGetLogger(v10);
    v12 = objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v13 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v13))
        v14 = 43;
      else
        v14 = 45;
      v15 = object_getClassName(*(id *)(a1 + 32));
      v16 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)buf = 67110146;
      v26 = v14;
      v27 = 2082;
      v28 = v15;
      v29 = 2082;
      v30 = v16;
      v31 = 1024;
      v32 = 7004;
      v33 = 2112;
      v34 = v3;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
    }
  }
  else
  {
    v17 = *(id *)(*(_QWORD *)(a1 + 32) + 376);
    v12 = v17;
    if (v17)
    {
      v18 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject handle](v17, "handle"));
      v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "info"));
      v20 = objc_msgSend(v19, "restrictedMode");

      if (v20)
      {
        v21 = objc_msgSend(*(id *)(a1 + 32), "secureElementDidExitRestrictedMode:os:", v12, *(_QWORD *)(a1 + 48));
        v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSDistributedNotificationCenter defaultCenter](NSDistributedNotificationCenter, "defaultCenter"));
        objc_msgSend(v22, "postNotificationName:object:userInfo:options:", CFSTR("com.apple.nfcd.se.restricted.exit"), 0, 0, 3);

      }
    }
    sub_1001FABB8(*(void **)(*(_QWORD *)(a1 + 32) + 368), CFSTR("Entered restrictedMode Exit"));
  }

}

void sub_100113600(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  objc_class *v13;
  int v14;
  const char *v15;
  const char *v16;
  uint64_t v17;
  uint8_t buf[4];
  int v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  uint64_t v27;

  if ((objc_opt_respondsToSelector(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 112), "handleSelectEvent:") & 1) != 0)
  {
    objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 112), "handleSelectEvent:", *(_QWORD *)(a1 + 40));
  }
  else
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      v9 = 45;
      if (isMetaClass)
        v9 = 43;
      v4(4, "%c[%{public}s %{public}s]:%i Unexpected active session: %{public}@", v9, ClassName, Name, 7025, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 112));
    }
    v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v11 = NFSharedLogGetLogger(v10);
    v12 = objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v13 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v13))
        v14 = 43;
      else
        v14 = 45;
      v15 = object_getClassName(*(id *)(a1 + 32));
      v16 = sel_getName(*(SEL *)(a1 + 48));
      v17 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 112);
      *(_DWORD *)buf = 67110146;
      v19 = v14;
      v20 = 2082;
      v21 = v15;
      v22 = 2082;
      v23 = v16;
      v24 = 1024;
      v25 = 7025;
      v26 = 2114;
      v27 = v17;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unexpected active session: %{public}@", buf, 0x2Cu);
    }

  }
}

void sub_100113888(uint64_t a1)
{
  NSMutableArray *v1;
  NSArray *v2;
  void *v3;
  const __CFString *v4;
  NSArray *v5;

  v1 = sub_1000DFC1C(*(_QWORD *)(a1 + 32));
  v2 = (NSArray *)objc_claimAutoreleasedReturnValue(v1);
  if (!v2)
    v2 = objc_opt_new(NSArray);
  v4 = CFSTR("Erase counter");
  v5 = v2;
  v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v5, &v4, 1));
  sub_100187CDC((uint64_t)NFBugCapture, CFSTR("Flash wear issue : erase counter exceeded"), CFSTR("Flash wear issue : erase counter exceeded"), v3);

}

void sub_1001139E0(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  objc_class *v13;
  int v14;
  const char *v15;
  const char *v16;
  uint64_t v17;
  uint8_t buf[4];
  int v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  uint64_t v27;

  if ((objc_opt_respondsToSelector(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 112), "secureElementReaderStarted:") & 1) != 0)
  {
    objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 112), "secureElementReaderStarted:", *(_QWORD *)(a1 + 40));
  }
  else
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      v9 = 45;
      if (isMetaClass)
        v9 = 43;
      v4(4, "%c[%{public}s %{public}s]:%i Unexpected active session: %{public}@", v9, ClassName, Name, 7074, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 112));
    }
    v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v11 = NFSharedLogGetLogger(v10);
    v12 = objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v13 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v13))
        v14 = 43;
      else
        v14 = 45;
      v15 = object_getClassName(*(id *)(a1 + 32));
      v16 = sel_getName(*(SEL *)(a1 + 48));
      v17 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 112);
      *(_DWORD *)buf = 67110146;
      v19 = v14;
      v20 = 2082;
      v21 = v15;
      v22 = 2082;
      v23 = v16;
      v24 = 1024;
      v25 = 7074;
      v26 = 2114;
      v27 = v17;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unexpected active session: %{public}@", buf, 0x2Cu);
    }

  }
}

void sub_100113C54(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  objc_class *v13;
  int v14;
  const char *v15;
  const char *v16;
  uint64_t v17;
  uint8_t buf[4];
  int v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  uint64_t v27;

  if ((objc_opt_respondsToSelector(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 112), "secureElementReaderStopped:") & 1) != 0)
  {
    objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 112), "secureElementReaderStopped:", *(_QWORD *)(a1 + 40));
  }
  else
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      v9 = 45;
      if (isMetaClass)
        v9 = 43;
      v4(4, "%c[%{public}s %{public}s]:%i Unexpected active session: %{public}@", v9, ClassName, Name, 7085, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 112));
    }
    v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v11 = NFSharedLogGetLogger(v10);
    v12 = objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v13 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v13))
        v14 = 43;
      else
        v14 = 45;
      v15 = object_getClassName(*(id *)(a1 + 32));
      v16 = sel_getName(*(SEL *)(a1 + 48));
      v17 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 112);
      *(_DWORD *)buf = 67110146;
      v19 = v14;
      v20 = 2082;
      v21 = v15;
      v22 = 2082;
      v23 = v16;
      v24 = 1024;
      v25 = 7085;
      v26 = 2114;
      v27 = v17;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unexpected active session: %{public}@", buf, 0x2Cu);
    }

  }
}

void sub_100113EA0(uint64_t a1)
{
  void *specific;
  void (*Logger)(uint64_t, const char *, ...);
  void *v4;
  uint64_t v5;
  NSObject *v6;
  uint8_t buf[4];
  const char *v8;
  __int16 v9;
  int v10;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(specific);
  if (Logger)
    Logger(6, "%s:%i Refresh on RM timer ends", "-[_NFHardwareManager handleReaderModeProhibitTimerEvent:]_block_invoke", 7096);
  v4 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v5 = NFSharedLogGetLogger(v4);
  v6 = objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446466;
    v8 = "-[_NFHardwareManager handleReaderModeProhibitTimerEvent:]_block_invoke";
    v9 = 1024;
    v10 = 7096;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s:%i Refresh on RM timer ends", buf, 0x12u);
  }

  sub_1001D4314(*(_QWORD *)(a1 + 32));
}

void sub_100114050(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  objc_class *v13;
  int v14;
  const char *v15;
  const char *v16;
  uint64_t v17;
  uint8_t buf[4];
  int v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  uint64_t v27;

  if ((objc_opt_respondsToSelector(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 112), "handleSecureElementTransactionData:appletIdentifier:") & 1) != 0)
  {
    objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 112), "handleSecureElementTransactionData:appletIdentifier:", *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48));
  }
  else
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      v9 = 45;
      if (isMetaClass)
        v9 = 43;
      v4(4, "%c[%{public}s %{public}s]:%i Unexpected active session: %{public}@", v9, ClassName, Name, 7108, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 112));
    }
    v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v11 = NFSharedLogGetLogger(v10);
    v12 = objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v13 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v13))
        v14 = 43;
      else
        v14 = 45;
      v15 = object_getClassName(*(id *)(a1 + 32));
      v16 = sel_getName(*(SEL *)(a1 + 56));
      v17 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 112);
      *(_DWORD *)buf = 67110146;
      v19 = v14;
      v20 = 2082;
      v21 = v15;
      v22 = 2082;
      v23 = v16;
      v24 = 1024;
      v25 = 7108;
      v26 = 2114;
      v27 = v17;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unexpected active session: %{public}@", buf, 0x2Cu);
    }

  }
}

void sub_100114408(_QWORD *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  void *specific;
  uint64_t Logger;
  void (*v9)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  NSObject *v16;
  objc_class *v17;
  int v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  void (*v22)(uint64_t, const char *, ...);
  objc_class *v23;
  _BOOL4 v24;
  const char *v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  NSObject *v29;
  objc_class *v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  void *v34;
  const char *Name;
  const char *v36;
  uint8_t buf[4];
  _BYTE v38[24];
  __int16 v39;
  int v40;

  v5 = a2;
  v6 = a3;
  if (a1)
  {
    if (objc_msgSend(v5, "background"))
    {
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v9 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(a1);
        Name = sel_getName("_postExpressTransactionStartEvent:keyIdentifier:");
        v13 = 45;
        if (isMetaClass)
          v13 = 43;
        v9(6, "%c[%{public}s %{public}s]:%i Ignoring background transaction event while in express mode", v13, ClassName, Name, 7128);
      }
      v14 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v15 = NFSharedLogGetLogger(v14);
      v16 = objc_claimAutoreleasedReturnValue(v15);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        v17 = object_getClass(a1);
        if (class_isMetaClass(v17))
          v18 = 43;
        else
          v18 = 45;
        *(_DWORD *)buf = 67109890;
        *(_DWORD *)v38 = v18;
        *(_WORD *)&v38[4] = 2082;
        *(_QWORD *)&v38[6] = object_getClassName(a1);
        *(_WORD *)&v38[14] = 2082;
        *(_QWORD *)&v38[16] = sel_getName("_postExpressTransactionStartEvent:keyIdentifier:");
        v39 = 1024;
        v40 = 7128;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Ignoring background transaction event while in express mode", buf, 0x22u);
      }
LABEL_12:

      goto LABEL_16;
    }
    v19 = a1[3];
    if (v19 && *(_BYTE *)(v19 + 172) && !*(_BYTE *)(v19 + 173))
    {
      v20 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v21 = NFLogGetLogger(v20);
      if (v21)
      {
        v22 = (void (*)(uint64_t, const char *, ...))v21;
        v23 = object_getClass(a1);
        v24 = class_isMetaClass(v23);
        v25 = object_getClassName(a1);
        v36 = sel_getName("_postExpressTransactionStartEvent:keyIdentifier:");
        v26 = 45;
        if (v24)
          v26 = 43;
        v22(6, "%c[%{public}s %{public}s]:%i Firing express txn started notification", v26, v25, v36, 7131);
      }
      v27 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v28 = NFSharedLogGetLogger(v27);
      v29 = objc_claimAutoreleasedReturnValue(v28);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        v30 = object_getClass(a1);
        if (class_isMetaClass(v30))
          v31 = 43;
        else
          v31 = 45;
        *(_DWORD *)buf = 67109890;
        *(_DWORD *)v38 = v31;
        *(_WORD *)&v38[4] = 2082;
        *(_QWORD *)&v38[6] = object_getClassName(a1);
        *(_WORD *)&v38[14] = 2082;
        *(_QWORD *)&v38[16] = sel_getName("_postExpressTransactionStartEvent:keyIdentifier:");
        v39 = 1024;
        v40 = 7131;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Firing express txn started notification", buf, 0x22u);
      }

      sub_1000EC8E8(a1, (uint64_t)"com.apple.stockholm.express.transaction.start", v6);
      v33 = NFSharedSignpostLog(v32);
      v16 = objc_claimAutoreleasedReturnValue(v33);
      if (os_signpost_enabled(v16))
      {
        v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "appletIdentifier"));
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)v38 = "com.apple.stockholm.express.transaction.start";
        *(_WORD *)&v38[8] = 2112;
        *(_QWORD *)&v38[10] = v34;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "EXPRESS_MODE_TX_START_NOTIFICATION", "%s, aid: %@", buf, 0x16u);

      }
      goto LABEL_12;
    }
  }
LABEL_16:

}

void sub_100114EF4(_QWORD *a1, void *a2, void *a3, void *a4, void *a5, int a6, void *a7)
{
  id v13;
  id v14;
  id v15;
  id v16;
  void *specific;
  uint64_t Logger;
  void (*v19)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  NSObject *v26;
  objc_class *v27;
  int v28;
  const char *v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  void (*v33)(uint64_t, const char *, ...);
  objc_class *v34;
  _BOOL4 v35;
  const char *v36;
  uint64_t v37;
  void *v38;
  uint64_t v39;
  objc_class *v40;
  int v41;
  uint64_t v42;
  void *v43;
  void *v44;
  uint64_t v45;
  void *v46;
  uint64_t v47;
  uint64_t v48;
  NSObject *v49;
  uint64_t v50;
  void *v51;
  const char *Name;
  const char *v53;
  uint8_t buf[4];
  _BYTE v55[24];
  __int16 v56;
  int v57;

  v13 = a2;
  v14 = a3;
  v15 = a4;
  v16 = a7;
  if (a1)
  {
    if (objc_msgSend(v13, "background"))
    {
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v19 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(a1);
        Name = sel_getName("_postExpressTransactionEndEvent:atlData:keyIdentifier:additionalData:notificationName:isUnifiedAccess:homePayload:");
        v23 = 45;
        if (isMetaClass)
          v23 = 43;
        v19(6, "%c[%{public}s %{public}s]:%i Ignoring transaction event while in express mode", v23, ClassName, Name, 7229);
      }
      v24 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v25 = NFSharedLogGetLogger(v24);
      v26 = objc_claimAutoreleasedReturnValue(v25);
      if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        goto LABEL_25;
      v27 = object_getClass(a1);
      if (class_isMetaClass(v27))
        v28 = 43;
      else
        v28 = 45;
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)v55 = v28;
      *(_WORD *)&v55[4] = 2082;
      *(_QWORD *)&v55[6] = object_getClassName(a1);
      *(_WORD *)&v55[14] = 2082;
      *(_QWORD *)&v55[16] = sel_getName("_postExpressTransactionEndEvent:atlData:keyIdentifier:additionalData:notificationName:isUnifiedAccess:homePayload:");
      v56 = 1024;
      v57 = 7229;
      v29 = "%c[%{public}s %{public}s]:%i Ignoring transaction event while in express mode";
      goto LABEL_24;
    }
    v30 = a1[3];
    if (v30 && *(_BYTE *)(v30 + 172))
    {
      if (!*(_BYTE *)(v30 + 173))
      {
        sub_1000EC568(a1, a5, v15);
        if (a6)
        {
          v43 = (void *)objc_claimAutoreleasedReturnValue(+[NFSecureXPCEventPublisherManager sharedManager](NFSecureXPCEventPublisherManager, "sharedManager"));
          v44 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v43, "homed"));
          objc_msgSend(a1, "postEventForPublisher:event:objectString:", v44, "com.apple.stockholm.forHome.transaction.end", v16);

          if (v14)
          {
            v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "objectForKeyedSubscript:", CFSTR("EventType")));
            v47 = objc_opt_class(NSString);
            if ((objc_opt_isKindOfClass(v46, v47) & 1) != 0
              && objc_msgSend(v46, "isEqualToString:", CFSTR("EndEvent")))
            {
              sub_1000A6FB8((uint64_t)NFUnifiedAccessTransactionCALogger, v14, 1, 0);
            }

          }
          v48 = NFSharedSignpostLog(v45);
          v49 = objc_claimAutoreleasedReturnValue(v48);
          if (os_signpost_enabled(v49))
          {
            *(_WORD *)buf = 0;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v49, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "AtlEvent", "AtlEndEventComplete", buf, 2u);
          }

        }
        v50 = NFSharedSignpostLog(v42);
        v26 = objc_claimAutoreleasedReturnValue(v50);
        if (os_signpost_enabled(v26))
        {
          v51 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "appletIdentifier"));
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)v55 = a5;
          *(_WORD *)&v55[8] = 2112;
          *(_QWORD *)&v55[10] = v51;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v26, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "EXPRESS_MODE_TX_END_NOTIFICATION", "%s, aid: %@", buf, 0x16u);

        }
        goto LABEL_25;
      }
      v31 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v32 = NFLogGetLogger(v31);
      if (v32)
      {
        v33 = (void (*)(uint64_t, const char *, ...))v32;
        v34 = object_getClass(a1);
        v35 = class_isMetaClass(v34);
        v36 = object_getClassName(a1);
        v53 = sel_getName("_postExpressTransactionEndEvent:atlData:keyIdentifier:additionalData:notificationName:isUnifiedAccess:homePayload:");
        v37 = 45;
        if (v35)
          v37 = 43;
        v33(5, "%c[%{public}s %{public}s]:%i Express end notification already fired, ignoring", v37, v36, v53, 7262);
      }
      v38 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v39 = NFSharedLogGetLogger(v38);
      v26 = objc_claimAutoreleasedReturnValue(v39);
      if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
LABEL_25:

        goto LABEL_26;
      }
      v40 = object_getClass(a1);
      if (class_isMetaClass(v40))
        v41 = 43;
      else
        v41 = 45;
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)v55 = v41;
      *(_WORD *)&v55[4] = 2082;
      *(_QWORD *)&v55[6] = object_getClassName(a1);
      *(_WORD *)&v55[14] = 2082;
      *(_QWORD *)&v55[16] = sel_getName("_postExpressTransactionEndEvent:atlData:keyIdentifier:additionalData:notificationName:isUnifiedAccess:homePayload:");
      v56 = 1024;
      v57 = 7262;
      v29 = "%c[%{public}s %{public}s]:%i Express end notification already fired, ignoring";
LABEL_24:
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, v29, buf, 0x22u);
      goto LABEL_25;
    }
  }
LABEL_26:

}

uint64_t sub_1001165C4(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(_QWORD *)(*(_QWORD *)(result + 32) + 112);
  if (v1)
  {
    v2 = result;
    v3 = objc_opt_class(_NFXPCSession);
    result = objc_opt_isKindOfClass(v1, v3);
    if ((result & 1) != 0)
    {
      result = objc_opt_respondsToSelector(*(_QWORD *)(*(_QWORD *)(v2 + 32) + 112), "handleHostCardReaderDetected:");
      if ((result & 1) != 0)
        return (uint64_t)objc_msgSend(*(id *)(*(_QWORD *)(v2 + 32) + 112), "handleHostCardReaderDetected:", *(_QWORD *)(v2 + 40));
    }
  }
  return result;
}

id sub_1001166C8(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  NSObject *v11;
  objc_class *v12;
  int v13;
  const char *v14;
  const char *v15;
  void *v17;
  uint64_t v18;
  void (*v19)(uint64_t, const char *, ...);
  objc_class *v20;
  _BOOL4 v21;
  const char *v22;
  const char *v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  NSObject *v27;
  objc_class *v28;
  int v29;
  const char *v30;
  const char *v31;
  uint64_t v32;
  uint64_t v33;
  void *v34;
  const char *Name;
  uint8_t buf[4];
  int v37;
  __int16 v38;
  const char *v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  int v43;
  __int16 v44;
  uint64_t v45;

  if (*(_BYTE *)(a1 + 56))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      v8 = 45;
      if (isMetaClass)
        v8 = 43;
      v4(5, "%c[%{public}s %{public}s]:%i Drop and restart", v8, ClassName, Name, 7489);
    }
    v9 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v10 = NFSharedLogGetLogger(v9);
    v11 = objc_claimAutoreleasedReturnValue(v10);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      v12 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v12))
        v13 = 43;
      else
        v13 = 45;
      v14 = object_getClassName(*(id *)(a1 + 32));
      v15 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)buf = 67109890;
      v37 = v13;
      v38 = 2082;
      v39 = v14;
      v40 = 2082;
      v41 = v15;
      v42 = 1024;
      v43 = 7489;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Drop and restart", buf, 0x22u);
    }

    return (id)sub_1001FBF60(*(void **)(*(_QWORD *)(a1 + 32) + 368));
  }
  else if ((objc_opt_respondsToSelector(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 112), "handleRemoteTagsDetected:") & 1) != 0)
  {
    return objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 112), "handleRemoteTagsDetected:", *(_QWORD *)(a1 + 40));
  }
  else
  {
    v17 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v18 = NFLogGetLogger(v17);
    if (v18)
    {
      v19 = (void (*)(uint64_t, const char *, ...))v18;
      v20 = object_getClass(*(id *)(a1 + 32));
      v21 = class_isMetaClass(v20);
      v22 = object_getClassName(*(id *)(a1 + 32));
      v23 = sel_getName(*(SEL *)(a1 + 48));
      v24 = 45;
      if (v21)
        v24 = 43;
      v19(6, "%c[%{public}s %{public}s]:%i Found tags:%{public}@", v24, v22, v23, 7497, *(_QWORD *)(a1 + 40));
    }
    v25 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v26 = NFSharedLogGetLogger(v25);
    v27 = objc_claimAutoreleasedReturnValue(v26);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      v28 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v28))
        v29 = 43;
      else
        v29 = 45;
      v30 = object_getClassName(*(id *)(a1 + 32));
      v31 = sel_getName(*(SEL *)(a1 + 48));
      v32 = *(_QWORD *)(a1 + 40);
      *(_DWORD *)buf = 67110146;
      v37 = v29;
      v38 = 2082;
      v39 = v30;
      v40 = 2082;
      v41 = v31;
      v42 = 1024;
      v43 = 7497;
      v44 = 2114;
      v45 = v32;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Found tags:%{public}@", buf, 0x2Cu);
    }

    v33 = *(_QWORD *)(a1 + 32);
    if (v33)
      v34 = *(void **)(v33 + 408);
    else
      v34 = 0;
    return objc_msgSend(v34, "handleDetectedTags:", *(_QWORD *)(a1 + 40));
  }
}

void sub_100116EB4(uint64_t a1)
{
  id v2;
  void *v3;
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  objc_class *v13;
  int v14;
  const char *v15;
  const char *v16;
  void *v17;
  uint64_t v18;
  const __CFString *v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  NSObject *v23;
  uint64_t v24;
  void *v25;
  id v26;
  const char *ClassName;
  const char *Name;
  uint8_t buf[4];
  _BYTE v30[14];
  __int16 v31;
  const char *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  void *v36;

  v2 = sub_1001F84C8(*(void **)(*(_QWORD *)(a1 + 32) + 368), CFSTR("SE Removed"), 0);
  v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  if (v3)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 40));
      v9 = 45;
      if (isMetaClass)
        v9 = 43;
      v6(3, "%c[%{public}s %{public}s]:%i Failed to open session: %@", v9, ClassName, Name, 7568, v3);
    }
    v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v11 = NFSharedLogGetLogger(v10);
    v12 = objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v13 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v13))
        v14 = 43;
      else
        v14 = 45;
      v15 = object_getClassName(*(id *)(a1 + 32));
      v16 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)buf = 67110146;
      *(_DWORD *)v30 = v14;
      *(_WORD *)&v30[4] = 2082;
      *(_QWORD *)&v30[6] = v15;
      v31 = 2082;
      v32 = v16;
      v33 = 1024;
      v34 = 7568;
      v35 = 2112;
      v36 = v3;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session: %@", buf, 0x2Cu);
    }

  }
  else
  {
    sub_10003DA78(*(void **)(*(_QWORD *)(a1 + 32) + 24));
    v17 = (void *)objc_claimAutoreleasedReturnValue(+[NFPowerAssertion sharedPowerAssertion](NFPowerAssertion, "sharedPowerAssertion"));
    objc_msgSend(v17, "releasePowerAssertion:logFaultOnOverRelease:", CFSTR("ExpressMode"), 0);

    objc_msgSend(*(id *)(a1 + 32), "refreshSecureElementInfo");
    v18 = *(int *)(a1 + 48);
    if (v18 > 4)
      v19 = CFSTR("unknown");
    else
      v19 = (const __CFString *)*((_QWORD *)&off_1002E8738 + v18);
    v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSDistributedNotificationCenter defaultCenter](NSDistributedNotificationCenter, "defaultCenter"));
    objc_msgSend(v20, "postNotificationName:object:userInfo:options:", CFSTR("com.apple.nfcd.se.removed"), v19, 0, 3);

    v22 = NFSharedSignpostLog(v21);
    v23 = objc_claimAutoreleasedReturnValue(v22);
    if (os_signpost_enabled(v23))
    {
      *(_DWORD *)buf = 138412290;
      *(_QWORD *)v30 = v19;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v23, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SE_REMOVED_NOTIFICATION", "com.apple.nfcd.se.removed for %@", buf, 0xCu);
    }

    v24 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 232);
    v25 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig embeddedWiredMode](NFRoutingConfig, "embeddedWiredMode"));
    v26 = +[_NFBuiltinSession createSessionWithWorkQueue:routing:sessionQueuer:didStartWork:](_NFBuiltinSession, "createSessionWithWorkQueue:routing:sessionQueuer:didStartWork:", v24, v25);

    sub_1001FABB8(*(void **)(*(_QWORD *)(a1 + 32) + 368), CFSTR("SE Removed"));
  }

}

void sub_1001171E4(uint64_t a1)
{
  sub_1000E0AA0(*(void ***)(a1 + 32));
}

void sub_100117404(uint64_t a1)
{
  void *v2;
  void *v3;
  double v4;
  void *v5;
  uint64_t v6;
  void (*v7)(uint64_t, const char *, ...);
  objc_class *v8;
  _BOOL4 v9;
  const char *v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  objc_class *v15;
  int v16;
  const char *v17;
  const char *v18;
  char v19;
  void *specific;
  uint64_t Logger;
  void (*v22)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  NSObject *v31;
  objc_class *v32;
  int v33;
  const char *v34;
  const char *v35;
  uint64_t v36;
  const char *v37;
  NSObject *v38;
  uint32_t v39;
  void *v40;
  uint64_t v41;
  void (*v42)(uint64_t, const char *, ...);
  objc_class *v43;
  _BOOL4 v44;
  const char *v45;
  uint64_t v46;
  void *v47;
  uint64_t v48;
  objc_class *v49;
  int v50;
  const char *v51;
  const char *v52;
  uint64_t v53;
  id v54;
  unint64_t v55;
  void *v56;
  const __CFString *v57;
  void *v58;
  uint64_t v59;
  uint64_t v60;
  NSObject *v61;
  uint64_t v62;
  void *v63;
  id v64;
  const char *v65;
  const char *v66;
  uint8_t buf[4];
  _BYTE v68[14];
  __int16 v69;
  const char *v70;
  __int16 v71;
  int v72;
  __int16 v73;
  uint64_t v74;

  v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate now](NSDate, "now"));
  v3 = v2;
  if (!*(_QWORD *)(*(_QWORD *)(a1 + 32) + 224))
    goto LABEL_23;
  objc_msgSend(v2, "timeIntervalSinceDate:");
  if (v4 >= 3600.0)
  {
    if (*(_QWORD *)(*(_QWORD *)(a1 + 32) + 224))
    {
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v22 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(*(id *)(a1 + 32));
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(*(id *)(a1 + 32));
        Name = sel_getName(*(SEL *)(a1 + 40));
        objc_msgSend(v3, "timeIntervalSinceDate:", *(_QWORD *)(*(_QWORD *)(a1 + 32) + 224));
        v28 = 45;
        if (isMetaClass)
          v28 = 43;
        v22(6, "%c[%{public}s %{public}s]:%i Last OS reset was %f seconds ago", v28, ClassName, Name, 7619, v27);
      }
      v29 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v30 = NFSharedLogGetLogger(v29);
      v31 = objc_claimAutoreleasedReturnValue(v30);
      if (!os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
        goto LABEL_33;
      v32 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v32))
        v33 = 43;
      else
        v33 = 45;
      v34 = object_getClassName(*(id *)(a1 + 32));
      v35 = sel_getName(*(SEL *)(a1 + 40));
      objc_msgSend(v3, "timeIntervalSinceDate:", *(_QWORD *)(*(_QWORD *)(a1 + 32) + 224));
      *(_DWORD *)buf = 67110146;
      *(_DWORD *)v68 = v33;
      *(_WORD *)&v68[4] = 2082;
      *(_QWORD *)&v68[6] = v34;
      v69 = 2082;
      v70 = v35;
      v71 = 1024;
      v72 = 7619;
      v73 = 2048;
      v74 = v36;
      v37 = "%c[%{public}s %{public}s]:%i Last OS reset was %f seconds ago";
      v38 = v31;
      v39 = 44;
LABEL_32:
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, v37, buf, v39);
LABEL_33:

      v53 = *(_QWORD *)(a1 + 32);
      v54 = v3;
      v19 = 0;
      v14 = *(NSObject **)(v53 + 224);
      *(_QWORD *)(v53 + 224) = v54;
      goto LABEL_34;
    }
LABEL_23:
    v40 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v41 = NFLogGetLogger(v40);
    if (v41)
    {
      v42 = (void (*)(uint64_t, const char *, ...))v41;
      v43 = object_getClass(*(id *)(a1 + 32));
      v44 = class_isMetaClass(v43);
      v45 = object_getClassName(*(id *)(a1 + 32));
      v66 = sel_getName(*(SEL *)(a1 + 40));
      v46 = 45;
      if (v44)
        v46 = 43;
      v42(6, "%c[%{public}s %{public}s]:%i Cool ! This is the first SE OS reset since our process started. I mean it's not great but as the internets say : 'First!'", v46, v45, v66, 7621);
    }
    v47 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v48 = NFSharedLogGetLogger(v47);
    v31 = objc_claimAutoreleasedReturnValue(v48);
    if (!os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      goto LABEL_33;
    v49 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v49))
      v50 = 43;
    else
      v50 = 45;
    v51 = object_getClassName(*(id *)(a1 + 32));
    v52 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)buf = 67109890;
    *(_DWORD *)v68 = v50;
    *(_WORD *)&v68[4] = 2082;
    *(_QWORD *)&v68[6] = v51;
    v69 = 2082;
    v70 = v52;
    v71 = 1024;
    v72 = 7621;
    v37 = "%c[%{public}s %{public}s]:%i Cool ! This is the first SE OS reset since our process started. I mean it's not g"
          "reat but as the internets say : 'First!'";
    v38 = v31;
    v39 = 34;
    goto LABEL_32;
  }
  v5 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v6 = NFLogGetLogger(v5);
  if (v6)
  {
    v7 = (void (*)(uint64_t, const char *, ...))v6;
    v8 = object_getClass(*(id *)(a1 + 32));
    v9 = class_isMetaClass(v8);
    v10 = object_getClassName(*(id *)(a1 + 32));
    v65 = sel_getName(*(SEL *)(a1 + 40));
    v11 = 45;
    if (v9)
      v11 = 43;
    v7(3, "%c[%{public}s %{public}s]:%i Already reset within the last: %f", v11, v10, v65, 7615, 0x40AC200000000000);
  }
  v12 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v13 = NFSharedLogGetLogger(v12);
  v14 = objc_claimAutoreleasedReturnValue(v13);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    v15 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v15))
      v16 = 43;
    else
      v16 = 45;
    v17 = object_getClassName(*(id *)(a1 + 32));
    v18 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)buf = 67110146;
    *(_DWORD *)v68 = v16;
    *(_WORD *)&v68[4] = 2082;
    *(_QWORD *)&v68[6] = v17;
    v69 = 2082;
    v70 = v18;
    v71 = 1024;
    v72 = 7615;
    v73 = 2048;
    v74 = 0x40AC200000000000;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Already reset within the last: %f", buf, 0x2Cu);
  }
  v19 = 1;
LABEL_34:

  v55 = *(_QWORD *)(a1 + 48);
  if ((v55 | 2) == 2)
  {
    sub_10003DA78(*(void **)(*(_QWORD *)(a1 + 32) + 24));
    v56 = (void *)objc_claimAutoreleasedReturnValue(+[NFPowerAssertion sharedPowerAssertion](NFPowerAssertion, "sharedPowerAssertion"));
    objc_msgSend(v56, "releasePowerAssertion:logFaultOnOverRelease:", CFSTR("ExpressMode"), 0);

    v55 = *(_QWORD *)(a1 + 48);
  }
  if (v55 > 3)
    v57 = CFSTR("unknown");
  else
    v57 = (const __CFString *)*((_QWORD *)&off_1002E8760 + v55);
  v58 = (void *)objc_claimAutoreleasedReturnValue(+[NSDistributedNotificationCenter defaultCenter](NSDistributedNotificationCenter, "defaultCenter"));
  objc_msgSend(v58, "postNotificationName:object:userInfo:options:", CFSTR("com.apple.nfcd.se.os.reset"), v57, 0, 3);

  v60 = NFSharedSignpostLog(v59);
  v61 = objc_claimAutoreleasedReturnValue(v60);
  if (os_signpost_enabled(v61))
  {
    *(_DWORD *)buf = 138412290;
    *(_QWORD *)v68 = v57;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v61, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SE_REMOVED_NOTIFICATION", "com.apple.nfcd.se.os.reset for %@", buf, 0xCu);
  }

  if ((v19 & 1) == 0)
  {
    v62 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 232);
    v63 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig embeddedWiredMode](NFRoutingConfig, "embeddedWiredMode"));
    v64 = +[_NFBuiltinSession createSessionWithWorkQueue:routing:sessionQueuer:didStartWork:](_NFBuiltinSession, "createSessionWithWorkQueue:routing:sessionQueuer:didStartWork:", v62, v63);

  }
}

uint64_t sub_1001179E4(uint64_t a1)
{
  const char *v2;
  uint64_t v3;

  objc_msgSend(*(id *)(a1 + 32), "refreshSecureElementInfo");
  sub_1000E0AA0(*(void ***)(a1 + 32));
  if (*(_QWORD *)(a1 + 40) == 1)
  {
    v2 = "eUICC OS reset";
    v3 = 12748;
  }
  else
  {
    v2 = "SE OS reset";
    v3 = 21253;
  }
  return NFSimulateCrash(v3, v2);
}

uint64_t sub_100117DF8(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 112);
  v3 = objc_opt_class(_NFXPCSession);
  result = objc_opt_isKindOfClass(v2, v3);
  if ((result & 1) != 0)
  {
    result = objc_opt_respondsToSelector(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 112), "handleHceTargetLost");
    if ((result & 1) != 0)
      return (uint64_t)objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 112), "handleHceTargetLost");
  }
  return result;
}

void sub_100117EBC(uint64_t a1)
{
  sub_1000EC09C(*(void **)(a1 + 32), 1, *(_QWORD *)(a1 + 40));
}

void sub_10011831C(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  NSObject *v20;
  uint64_t v21;
  NSObject *v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  _BOOL4 v26;
  void *v27;
  uint64_t v28;
  void (*v29)(uint64_t, const char *, ...);
  objc_class *v30;
  uint64_t v31;
  const char *v32;
  const char *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  NSObject *v37;
  objc_class *v38;
  int v39;
  const char *v40;
  const char *v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  void *v46;
  id v47;
  objc_class *v48;
  uint64_t v49;
  const char *v50;
  const char *v51;
  void *v52;
  void *v53;
  uint64_t v54;
  NSObject *v55;
  objc_class *v56;
  int v57;
  const char *v58;
  const char *v59;
  void *v60;
  void *v61;
  id v62;
  uint64_t IsPad;
  uint64_t v64;
  void *v65;
  void (*v66)(uint64_t, const char *, ...);
  objc_class *v67;
  uint64_t v68;
  const char *v69;
  const char *v70;
  void *v71;
  uint64_t v72;
  NSObject *v73;
  objc_class *v74;
  int v75;
  const char *v76;
  const char *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  int v81;
  void *v82;
  void (*v83)(uint64_t, const char *, ...);
  objc_class *v84;
  uint64_t v85;
  const char *v86;
  const char *v87;
  void *v88;
  uint64_t v89;
  NSObject *v90;
  objc_class *v91;
  int v92;
  const char *v93;
  const char *v94;
  uint64_t v95;
  void *v96;
  void (*v97)(uint64_t, const char *, ...);
  objc_class *v98;
  uint64_t v99;
  const char *v100;
  const char *v101;
  void *v102;
  uint64_t v103;
  NSObject *v104;
  objc_class *v105;
  int v106;
  const char *v107;
  const char *v108;
  id v109;
  id v110;
  uint64_t v111;
  void *v112;
  void (*v113)(uint64_t, const char *, ...);
  objc_class *v114;
  uint64_t v115;
  const char *v116;
  const char *v117;
  objc_class *v118;
  const char *v119;
  void *v120;
  uint64_t v121;
  NSObject *v122;
  objc_class *v123;
  int v124;
  const char *v125;
  const char *v126;
  objc_class *v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t isKindOfClass;
  void *v131;
  uint64_t v132;
  NSObject *v133;
  const char *Name;
  uint8_t v135[4];
  int v136;
  __int16 v137;
  const char *v138;
  __int16 v139;
  const char *v140;
  __int16 v141;
  int v142;
  __int16 v143;
  uint8_t *v144;
  __int16 v145;
  const char *v146;
  uint8_t buf[48];
  __int128 v148;
  __int128 v149;
  __int128 v150;
  __int128 v151;
  __int128 v152;
  __int128 v153;
  __int128 v154;
  __int128 v155;
  __int128 v156;
  __int128 v157;
  __int128 v158;
  _BYTE v159[31];

  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 337))
  {
    v21 = NFSharedSignpostLog(v2);
    v22 = objc_claimAutoreleasedReturnValue(v21);
    if (os_signpost_enabled(v22))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v22, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "powerObserverSystemWillSleep: not running; allowing to sleep",
        "",
        buf,
        2u);
    }
    goto LABEL_72;
  }
  v3 = *(_QWORD *)(v2 + 24);
  if (v3 && *(_BYTE *)(v3 + 172))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 40));
      v10 = 45;
      if (isMetaClass)
        v10 = 43;
      v6(6, "%c[%{public}s %{public}s]:%i Express mode in progress - delaying sleep", v10, ClassName, Name, 7753);
    }
    v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v12 = NFSharedLogGetLogger(v11);
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      v14 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v14))
        v15 = 43;
      else
        v15 = 45;
      v16 = object_getClassName(*(id *)(a1 + 32));
      v17 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)&buf[4] = v15;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = v16;
      *(_WORD *)&buf[18] = 2082;
      *(_QWORD *)&buf[20] = v17;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 7753;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Express mode in progress - delaying sleep", buf, 0x22u);
    }

    v19 = NFSharedSignpostLog(v18);
    v20 = objc_claimAutoreleasedReturnValue(v19);
    if (os_signpost_enabled(v20))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v20, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "powerObserverSystemWillSleep: express in progress; preventing sleep",
        "",
        buf,
        2u);
    }

    return;
  }
  if (!*(_QWORD *)(v2 + 112))
  {
    v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v2, "lastKnownRoutingConfig"));
    if ((objc_msgSend(v23, "activeRouting") & 1) != 0)
      goto LABEL_23;
    v24 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24);
    if (!v24)
    {

      goto LABEL_52;
    }
    if (*(_QWORD *)(v24 + 136) == 1)
    {
LABEL_23:

    }
    else
    {
      v81 = *(unsigned __int8 *)(v24 + 170);

      if (!v81)
        goto LABEL_52;
    }
    v25 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24);
    if (v25)
      v26 = *(_QWORD *)(v25 + 136) == 1 || *(unsigned __int8 *)(v25 + 170) != 0;
    else
      v26 = 0;
    v27 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v28 = NFLogGetLogger(v27);
    v29 = (void (*)(uint64_t, const char *, ...))v28;
    if (v26)
    {
      if (v28)
      {
        v30 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v30))
          v31 = 43;
        else
          v31 = 45;
        v32 = object_getClassName(*(id *)(a1 + 32));
        v33 = sel_getName(*(SEL *)(a1 + 40));
        v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "lastKnownRoutingConfig"));
        v29(6, "%c[%{public}s %{public}s]:%i Setting routing to express before poweroff - was  %{public}@", v31, v32, v33, 7763, v34);

      }
      v35 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v36 = NFSharedLogGetLogger(v35);
      v37 = objc_claimAutoreleasedReturnValue(v36);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        v38 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v38))
          v39 = 43;
        else
          v39 = 45;
        v40 = object_getClassName(*(id *)(a1 + 32));
        v41 = sel_getName(*(SEL *)(a1 + 40));
        v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "lastKnownRoutingConfig"));
        *(_DWORD *)buf = 67110146;
        *(_DWORD *)&buf[4] = v39;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = v40;
        *(_WORD *)&buf[18] = 2082;
        *(_QWORD *)&buf[20] = v41;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 7763;
        *(_WORD *)&buf[34] = 2114;
        *(_QWORD *)&buf[36] = v42;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Setting routing to express before poweroff - was  %{public}@", buf, 0x2Cu);

      }
      v43 = *(void **)(a1 + 32);
      v44 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v43, "lastKnownRoutingConfig"));
      v45 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v44, "lpcdEcpFrame"));
      v46 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig expressWithECP:](NFRoutingConfig, "expressWithECP:", v45));
      v47 = objc_msgSend(v43, "setRoutingConfig:", v46);
    }
    else
    {
      if (v28)
      {
        v48 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v48))
          v49 = 43;
        else
          v49 = 45;
        v50 = object_getClassName(*(id *)(a1 + 32));
        v51 = sel_getName(*(SEL *)(a1 + 40));
        v52 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "lastKnownRoutingConfig"));
        v29(6, "%c[%{public}s %{public}s]:%i Forcing SE routing off:was  %{public}@", v49, v50, v51, 7766, v52);

      }
      v53 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v54 = NFSharedLogGetLogger(v53);
      v55 = objc_claimAutoreleasedReturnValue(v54);
      if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
      {
        v56 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v56))
          v57 = 43;
        else
          v57 = 45;
        v58 = object_getClassName(*(id *)(a1 + 32));
        v59 = sel_getName(*(SEL *)(a1 + 40));
        v60 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "lastKnownRoutingConfig"));
        *(_DWORD *)buf = 67110146;
        *(_DWORD *)&buf[4] = v57;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = v58;
        *(_WORD *)&buf[18] = 2082;
        *(_QWORD *)&buf[20] = v59;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 7766;
        *(_WORD *)&buf[34] = 2114;
        *(_QWORD *)&buf[36] = v60;
        _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Forcing SE routing off:was  %{public}@", buf, 0x2Cu);

      }
      v61 = *(void **)(a1 + 32);
      v44 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v61, "lastKnownRoutingConfig"));
      v45 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v44, "lpcdEcpFrame"));
      v46 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig routingOffWithFD:ecp:](NFRoutingConfig, "routingOffWithFD:ecp:", 3, v45));
      v62 = objc_msgSend(v61, "setRoutingConfig:", v46);
    }

  }
LABEL_52:
  IsPad = NFProductIsPad();
  v64 = *(_QWORD *)(a1 + 32);
  if ((_DWORD)IsPad && *(_BYTE *)(v64 + 338))
  {
    v65 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v66 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v65);
    if (v66)
    {
      v67 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v67))
        v68 = 43;
      else
        v68 = 45;
      v69 = object_getClassName(*(id *)(a1 + 32));
      v70 = sel_getName(*(SEL *)(a1 + 40));
      v66(6, "%c[%{public}s %{public}s]:%i Closing pre-warmed session due to sleep", v68, v69, v70, 7778);
    }
    v71 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v72 = NFSharedLogGetLogger(v71);
    v73 = objc_claimAutoreleasedReturnValue(v72);
    if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
    {
      v74 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v74))
        v75 = 43;
      else
        v75 = 45;
      v76 = object_getClassName(*(id *)(a1 + 32));
      v77 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)&buf[4] = v75;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = v76;
      *(_WORD *)&buf[18] = 2082;
      *(_QWORD *)&buf[20] = v77;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 7778;
      _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Closing pre-warmed session due to sleep", buf, 0x22u);
    }

    sub_1001FABB8(*(void **)(*(_QWORD *)(a1 + 32) + 368), CFSTR("Prewarm"));
    v64 = *(_QWORD *)(a1 + 32);
  }
  v78 = *(_QWORD *)(v64 + 368);
  if (!v78)
    goto LABEL_70;
  if ((*(_BYTE *)(v78 + 219) & 1) == 0)
    goto LABEL_70;
  v79 = *(_QWORD *)(v64 + 24);
  if (v79)
  {
    if (*(_QWORD *)(v79 + 136) == 1 || *(_BYTE *)(v79 + 170))
      goto LABEL_70;
  }
  if (NFProductIsWatch() && sub_100098B40(*(_QWORD *)(a1 + 32)))
  {
    v82 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v83 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v82);
    if (v83)
    {
      v84 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v84))
        v85 = 43;
      else
        v85 = 45;
      v86 = object_getClassName(*(id *)(a1 + 32));
      v87 = sel_getName(*(SEL *)(a1 + 40));
      v83(6, "%c[%{public}s %{public}s]:%i Persistent field detect enabled on device which is supposed to sleep. Not disabling FD.", v85, v86, v87, 7789);
    }
    v88 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v89 = NFSharedLogGetLogger(v88);
    v90 = objc_claimAutoreleasedReturnValue(v89);
    if (os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT))
    {
      v91 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v91))
        v92 = 43;
      else
        v92 = 45;
      v93 = object_getClassName(*(id *)(a1 + 32));
      v94 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)&buf[4] = v92;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = v93;
      *(_WORD *)&buf[18] = 2082;
      *(_QWORD *)&buf[20] = v94;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 7789;
      _os_log_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Persistent field detect enabled on device which is supposed to sleep. Not disabling FD.", buf, 0x22u);
    }

  }
  else
  {
    v95 = *(_QWORD *)(a1 + 32);
    if (v95 && (*(_BYTE *)(v95 + 355) & 1) != 0)
    {
      v96 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v97 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v96);
      if (v97)
      {
        v98 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v98))
          v99 = 43;
        else
          v99 = 45;
        v100 = object_getClassName(*(id *)(a1 + 32));
        v101 = sel_getName(*(SEL *)(a1 + 40));
        v97(3, "%c[%{public}s %{public}s]:%i Forcing field detect off", v99, v100, v101, 7795);
      }
      v102 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v103 = NFSharedLogGetLogger(v102);
      v104 = objc_claimAutoreleasedReturnValue(v103);
      if (os_log_type_enabled(v104, OS_LOG_TYPE_ERROR))
      {
        v105 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v105))
          v106 = 43;
        else
          v106 = 45;
        v107 = object_getClassName(*(id *)(a1 + 32));
        v108 = sel_getName(*(SEL *)(a1 + 40));
        *(_DWORD *)buf = 67109890;
        *(_DWORD *)&buf[4] = v106;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = v107;
        *(_WORD *)&buf[18] = 2082;
        *(_QWORD *)&buf[20] = v108;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 7795;
        _os_log_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Forcing field detect off", buf, 0x22u);
      }

      sub_100097E1C(*(_QWORD *)(a1 + 32), 0);
      v109 = sub_1000984B4(*(id **)(a1 + 32), 0);
    }
  }
  v110 = *(id *)(*(_QWORD *)(a1 + 32) + 184);
  objc_sync_enter(v110);
  v111 = *(_QWORD *)(a1 + 32);
  if (!*(_QWORD *)(v111 + 112))
  {
    objc_sync_exit(v110);

LABEL_70:
    v80 = NFSharedSignpostLog(IsPad);
    v22 = objc_claimAutoreleasedReturnValue(v80);
    if (os_signpost_enabled(v22))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v22, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "powerObserverSystemWillSleep: allowing to sleep", "", buf, 2u);
    }
LABEL_72:

    objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 56), "allowSleep");
    return;
  }
  v158 = 0u;
  memset(v159, 0, sizeof(v159));
  v156 = 0u;
  v157 = 0u;
  v154 = 0u;
  v155 = 0u;
  v152 = 0u;
  v153 = 0u;
  v150 = 0u;
  v151 = 0u;
  v148 = 0u;
  v149 = 0u;
  memset(buf, 0, sizeof(buf));
  proc_name((int)objc_msgSend(*(id *)(v111 + 112), "processIdentifier"), buf, 0xFEu);
  v112 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v113 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v112);
  if (v113)
  {
    v114 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v114))
      v115 = 43;
    else
      v115 = 45;
    v116 = object_getClassName(*(id *)(a1 + 32));
    v117 = sel_getName(*(SEL *)(a1 + 40));
    v118 = (objc_class *)objc_opt_class(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 112));
    v119 = class_getName(v118);
    v113(6, "%c[%{public}s %{public}s]:%i Invalidating opened session from %s: %s", v115, v116, v117, 7804, buf, v119);
  }
  v120 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v121 = NFSharedLogGetLogger(v120);
  v122 = objc_claimAutoreleasedReturnValue(v121);
  if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT))
  {
    v123 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v123))
      v124 = 43;
    else
      v124 = 45;
    v125 = object_getClassName(*(id *)(a1 + 32));
    v126 = sel_getName(*(SEL *)(a1 + 40));
    v127 = (objc_class *)objc_opt_class(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 112));
    *(_DWORD *)v135 = 67110402;
    v136 = v124;
    v137 = 2082;
    v138 = v125;
    v139 = 2082;
    v140 = v126;
    v141 = 1024;
    v142 = 7804;
    v143 = 2080;
    v144 = buf;
    v145 = 2080;
    v146 = class_getName(v127);
    _os_log_impl((void *)&_mh_execute_header, v122, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Invalidating opened session from %s: %s", v135, 0x36u);
  }

  v128 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 112);
  v129 = objc_opt_class(_NFXPCSession);
  isKindOfClass = objc_opt_isKindOfClass(v128, v129);
  if ((isKindOfClass & 1) != 0)
  {
    v131 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 112), "connection"));
    objc_msgSend(v131, "invalidate");

  }
  v132 = NFSharedSignpostLog(isKindOfClass);
  v133 = objc_claimAutoreleasedReturnValue(v132);
  if (os_signpost_enabled(v133))
  {
    *(_WORD *)v135 = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v133, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "powerObserverSystemWillSleep: session in progress; preventing sleep",
      "",
      v135,
      2u);
  }

  objc_sync_exit(v110);
}

void sub_10011900C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1001191F0(_QWORD *result)
{
  uint64_t v1;
  _QWORD *v2;
  id v3;
  uint64_t v4;
  uint64_t v5;
  int IsPad;
  _BYTE *v7;
  void *specific;
  uint64_t Logger;
  void (*v10)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  NSObject *v17;
  objc_class *v18;
  int v19;
  const char *v20;
  const char *v21;
  id v22;
  void *v23;
  void *v24;
  void (*v25)(uint64_t, const char *, ...);
  objc_class *v26;
  uint64_t v27;
  const char *v28;
  const char *v29;
  void *v30;
  uint64_t v31;
  NSObject *v32;
  objc_class *v33;
  int v34;
  const char *v35;
  const char *v36;
  const char *Name;
  uint8_t buf[4];
  int v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  const char *v43;
  __int16 v44;
  int v45;
  __int16 v46;
  void *v47;

  v1 = result[4];
  if (*(_BYTE *)(v1 + 337))
  {
    v2 = result;
    v3 = *(id *)(v1 + 184);
    objc_sync_enter(v3);
    *(_BYTE *)(v2[4] + 344) = 0;
    sub_1001C8AA0(v2[4]);
    objc_sync_exit(v3);

    v4 = v2[4];
    v5 = sub_100098AF4(v4);
    sub_100097E1C(v4, v5);
    IsPad = NFProductIsPad();
    v7 = (_BYTE *)v2[4];
    if (IsPad && v7[338])
    {
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v10 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass((id)v2[4]);
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName((id)v2[4]);
        Name = sel_getName((SEL)v2[5]);
        v14 = 45;
        if (isMetaClass)
          v14 = 43;
        v10(6, "%c[%{public}s %{public}s]:%i Re-opening pre-warm session", v14, ClassName, Name, 7860);
      }
      v15 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v16 = NFSharedLogGetLogger(v15);
      v17 = objc_claimAutoreleasedReturnValue(v16);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        v18 = object_getClass((id)v2[4]);
        if (class_isMetaClass(v18))
          v19 = 43;
        else
          v19 = 45;
        v20 = object_getClassName((id)v2[4]);
        v21 = sel_getName((SEL)v2[5]);
        *(_DWORD *)buf = 67109890;
        v39 = v19;
        v40 = 2082;
        v41 = v20;
        v42 = 2082;
        v43 = v21;
        v44 = 1024;
        v45 = 7860;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Re-opening pre-warm session", buf, 0x22u);
      }

      v22 = sub_1001F84C8(*(void **)(v2[4] + 368), CFSTR("Prewarm"), 0);
      v23 = (void *)objc_claimAutoreleasedReturnValue(v22);
      if (v23)
      {
        v24 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v25 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v24);
        if (v25)
        {
          v26 = object_getClass((id)v2[4]);
          if (class_isMetaClass(v26))
            v27 = 43;
          else
            v27 = 45;
          v28 = object_getClassName((id)v2[4]);
          v29 = sel_getName((SEL)v2[5]);
          v25(4, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v27, v28, v29, 7863, v23);
        }
        v30 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v31 = NFSharedLogGetLogger(v30);
        v32 = objc_claimAutoreleasedReturnValue(v31);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        {
          v33 = object_getClass((id)v2[4]);
          if (class_isMetaClass(v33))
            v34 = 43;
          else
            v34 = 45;
          v35 = object_getClassName((id)v2[4]);
          v36 = sel_getName((SEL)v2[5]);
          *(_DWORD *)buf = 67110146;
          v39 = v34;
          v40 = 2082;
          v41 = v35;
          v42 = 2082;
          v43 = v36;
          v44 = 1024;
          v45 = 7863;
          v46 = 2112;
          v47 = v23;
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
        }

      }
      v7 = (_BYTE *)v2[4];
    }
    return objc_msgSend(v7, "maybeStartNextSession");
  }
  return result;
}

void sub_100119524(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10011984C(uint64_t a1)
{
  void *v2;
  unsigned int v3;
  void *v4;
  uint64_t v5;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *v7;
  _BOOL4 v8;
  const char *v9;
  const char *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  NSObject *v16;
  objc_class *v17;
  int v18;
  const char *v19;
  const char *v20;
  void *v21;
  void *v22;
  void *v23;
  int v24;
  void *specific;
  uint64_t Logger;
  void (*v27)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v32;
  void *v33;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  NSObject *v37;
  objc_class *v38;
  int v39;
  const char *v40;
  const char *v41;
  void *v42;
  void *v43;
  int v44;
  void *v45;
  uint64_t v46;
  void (*v47)(uint64_t, const char *, ...);
  objc_class *v48;
  _BOOL4 v49;
  const char *v50;
  const char *v51;
  void *v52;
  void *v53;
  uint64_t v54;
  void *v55;
  uint64_t v56;
  objc_class *v57;
  int v58;
  const char *v59;
  const char *v60;
  objc_class *v61;
  _BOOL4 v62;
  const char *v63;
  uint64_t v64;
  void *v65;
  uint64_t v66;
  NSObject *v67;
  objc_class *v68;
  int v69;
  const char *v70;
  const char *v71;
  const char *v72;
  objc_class *v73;
  _BOOL4 v74;
  const char *v75;
  uint64_t v76;
  void *v77;
  uint64_t v78;
  objc_class *v79;
  int v80;
  const char *v81;
  const char *v82;
  const char *v83;
  const char *v84;
  uint8_t buf[4];
  int v86;
  __int16 v87;
  const char *v88;
  __int16 v89;
  const char *v90;
  __int16 v91;
  int v92;
  __int16 v93;
  void *v94;

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "NF_whitelistChecker"));
  v3 = objc_msgSend(v2, "ignoreAppStateMonitor");

  if (!v3)
  {
    v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "NF_userInfo"));
    v16 = objc_claimAutoreleasedReturnValue(objc_msgSend(v23, "objectForKey:", CFSTR("serviceType")));

    if (v16 && -[NSObject unsignedIntegerValue](v16, "unsignedIntegerValue") == (id)2)
    {
      v24 = sub_100050744(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 72), *(void **)(a1 + 32));
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      v27 = (void (*)(uint64_t, const char *, ...))Logger;
      if (v24)
      {
        if (Logger)
        {
          Class = object_getClass(*(id *)(a1 + 40));
          isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(*(id *)(a1 + 40));
          Name = sel_getName(*(SEL *)(a1 + 48));
          v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "NF_userInfo"));
          v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v32, "objectForKeyedSubscript:", CFSTR("ClientName")));
          v34 = 45;
          if (isMetaClass)
            v34 = 43;
          v27(6, "%c[%{public}s %{public}s]:%i Invalidating XPC connection for %{public}@", v34, ClassName, Name, 7903, v33);

        }
        v35 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v36 = NFSharedLogGetLogger(v35);
        v37 = objc_claimAutoreleasedReturnValue(v36);
        if (!os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
          goto LABEL_34;
        v38 = object_getClass(*(id *)(a1 + 40));
        if (class_isMetaClass(v38))
          v39 = 43;
        else
          v39 = 45;
        v40 = object_getClassName(*(id *)(a1 + 40));
        v41 = sel_getName(*(SEL *)(a1 + 48));
        v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "NF_userInfo"));
        v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v42, "objectForKeyedSubscript:", CFSTR("ClientName")));
        *(_DWORD *)buf = 67110146;
        v86 = v39;
        v87 = 2082;
        v88 = v40;
        v89 = 2082;
        v90 = v41;
        v91 = 1024;
        v92 = 7903;
        v93 = 2114;
        v94 = v43;
LABEL_33:
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Invalidating XPC connection for %{public}@", buf, 0x2Cu);

LABEL_34:
        sub_100050294(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 72), *(void **)(a1 + 32));
        objc_msgSend(*(id *)(a1 + 32), "invalidate");
        goto LABEL_55;
      }
      if (Logger)
      {
        v73 = object_getClass(*(id *)(a1 + 40));
        v74 = class_isMetaClass(v73);
        v75 = object_getClassName(*(id *)(a1 + 40));
        v84 = sel_getName(*(SEL *)(a1 + 48));
        v76 = 45;
        if (v74)
          v76 = 43;
        v27(6, "%c[%{public}s %{public}s]:%i Client is no longer in background", v76, v75, v84, 7907);
      }
      v77 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v78 = NFSharedLogGetLogger(v77);
      v67 = objc_claimAutoreleasedReturnValue(v78);
      if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
      {
        v79 = object_getClass(*(id *)(a1 + 40));
        if (class_isMetaClass(v79))
          v80 = 43;
        else
          v80 = 45;
        v81 = object_getClassName(*(id *)(a1 + 40));
        v82 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)buf = 67109890;
        v86 = v80;
        v87 = 2082;
        v88 = v81;
        v89 = 2082;
        v90 = v82;
        v91 = 1024;
        v92 = 7907;
        v72 = "%c[%{public}s %{public}s]:%i Client is no longer in background";
LABEL_53:
        _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, v72, buf, 0x22u);
      }
    }
    else
    {
      v44 = sub_1000503DC(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 72), *(void **)(a1 + 32));
      v45 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v46 = NFLogGetLogger(v45);
      v47 = (void (*)(uint64_t, const char *, ...))v46;
      if (v44)
      {
        if (v46)
        {
          v48 = object_getClass(*(id *)(a1 + 40));
          v49 = class_isMetaClass(v48);
          v50 = object_getClassName(*(id *)(a1 + 40));
          v51 = sel_getName(*(SEL *)(a1 + 48));
          v52 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "NF_userInfo"));
          v53 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v52, "objectForKeyedSubscript:", CFSTR("ClientName")));
          v54 = 45;
          if (v49)
            v54 = 43;
          v47(6, "%c[%{public}s %{public}s]:%i Invalidating XPC connection for %{public}@", v54, v50, v51, 7914, v53);

        }
        v55 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v56 = NFSharedLogGetLogger(v55);
        v37 = objc_claimAutoreleasedReturnValue(v56);
        if (!os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
          goto LABEL_34;
        v57 = object_getClass(*(id *)(a1 + 40));
        if (class_isMetaClass(v57))
          v58 = 43;
        else
          v58 = 45;
        v59 = object_getClassName(*(id *)(a1 + 40));
        v60 = sel_getName(*(SEL *)(a1 + 48));
        v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "NF_userInfo"));
        v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v42, "objectForKeyedSubscript:", CFSTR("ClientName")));
        *(_DWORD *)buf = 67110146;
        v86 = v58;
        v87 = 2082;
        v88 = v59;
        v89 = 2082;
        v90 = v60;
        v91 = 1024;
        v92 = 7914;
        v93 = 2114;
        v94 = v43;
        goto LABEL_33;
      }
      if (v46)
      {
        v61 = object_getClass(*(id *)(a1 + 40));
        v62 = class_isMetaClass(v61);
        v63 = object_getClassName(*(id *)(a1 + 40));
        v83 = sel_getName(*(SEL *)(a1 + 48));
        v64 = 45;
        if (v62)
          v64 = 43;
        v47(6, "%c[%{public}s %{public}s]:%i Client is no longer suspended", v64, v63, v83, 7919);
      }
      v65 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v66 = NFSharedLogGetLogger(v65);
      v67 = objc_claimAutoreleasedReturnValue(v66);
      if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
      {
        v68 = object_getClass(*(id *)(a1 + 40));
        if (class_isMetaClass(v68))
          v69 = 43;
        else
          v69 = 45;
        v70 = object_getClassName(*(id *)(a1 + 40));
        v71 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)buf = 67109890;
        v86 = v69;
        v87 = 2082;
        v88 = v70;
        v89 = 2082;
        v90 = v71;
        v91 = 1024;
        v92 = 7919;
        v72 = "%c[%{public}s %{public}s]:%i Client is no longer suspended";
        goto LABEL_53;
      }
    }

    goto LABEL_55;
  }
  v4 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v5 = NFLogGetLogger(v4);
  if (v5)
  {
    v6 = (void (*)(uint64_t, const char *, ...))v5;
    v7 = object_getClass(*(id *)(a1 + 40));
    v8 = class_isMetaClass(v7);
    v9 = object_getClassName(*(id *)(a1 + 40));
    v10 = sel_getName(*(SEL *)(a1 + 48));
    v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "NF_userInfo"));
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "objectForKeyedSubscript:", CFSTR("ClientName")));
    v13 = 45;
    if (v8)
      v13 = 43;
    v6(6, "%c[%{public}s %{public}s]:%i Ignoring suspension since process allows for background : %{public}@", v13, v9, v10, 7887, v12);

  }
  v14 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v15 = NFSharedLogGetLogger(v14);
  v16 = objc_claimAutoreleasedReturnValue(v15);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    v17 = object_getClass(*(id *)(a1 + 40));
    if (class_isMetaClass(v17))
      v18 = 43;
    else
      v18 = 45;
    v19 = object_getClassName(*(id *)(a1 + 40));
    v20 = sel_getName(*(SEL *)(a1 + 48));
    v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "NF_userInfo"));
    v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "objectForKeyedSubscript:", CFSTR("ClientName")));
    *(_DWORD *)buf = 67110146;
    v86 = v18;
    v87 = 2082;
    v88 = v19;
    v89 = 2082;
    v90 = v20;
    v91 = 1024;
    v92 = 7887;
    v93 = 2114;
    v94 = v22;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Ignoring suspension since process allows for background : %{public}@", buf, 0x2Cu);

  }
LABEL_55:

}

void sub_10011A01C(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSMutableDictionary *v4;
  void *v5;
  void *specific;
  uint64_t Logger;
  void (*v8)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  NSObject *v15;
  objc_class *v16;
  int v17;
  const char *v18;
  const char *v19;
  const char *Name;
  uint8_t buf[4];
  int v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;

  v2 = *(_QWORD *)(a1 + 32);
  if (*(_BYTE *)(v2 + 337))
  {
    if (*(_QWORD *)(v2 + 280) == 1)
    {
      v3 = *(_QWORD *)(v2 + 368);
      v4 = sub_1000E194C((NSMutableDictionary *)v2);
      v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LODWORD(v3) = sub_1001FB714(v3, v5);

      if ((_DWORD)v3)
      {
        specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        Logger = NFLogGetLogger(specific);
        if (Logger)
        {
          v8 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(*(id *)(a1 + 32));
          isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(*(id *)(a1 + 32));
          Name = sel_getName(*(SEL *)(a1 + 40));
          v12 = 45;
          if (isMetaClass)
            v12 = 43;
          v8(5, "%c[%{public}s %{public}s]:%i driver flag change pending", v12, ClassName, Name, 8214);
        }
        v13 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v14 = NFSharedLogGetLogger(v13);
        v15 = objc_claimAutoreleasedReturnValue(v14);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          v16 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v16))
            v17 = 43;
          else
            v17 = 45;
          v18 = object_getClassName(*(id *)(a1 + 32));
          v19 = sel_getName(*(SEL *)(a1 + 40));
          *(_DWORD *)buf = 67109890;
          v22 = v17;
          v23 = 2082;
          v24 = v18;
          v25 = 2082;
          v26 = v19;
          v27 = 1024;
          v28 = 8214;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i driver flag change pending", buf, 0x22u);
        }

        *(_BYTE *)(*(_QWORD *)(a1 + 32) + 339) = 1;
        objc_msgSend(*(id *)(a1 + 32), "maybeStartNextSession");
      }
    }
  }
}

id sub_10011A4FC(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  NSObject *v5;
  void *v6;
  id v7;
  void *v8;
  uint64_t v9;
  void *specific;
  uint64_t Logger;
  void (*v12)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  NSObject *v19;
  objc_class *v20;
  int v21;
  const char *v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  NSObject *v26;
  id v27;
  uint64_t v28;
  NSObject *v29;
  const char *Name;
  uint8_t buf[4];
  int v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  const char *v37;
  __int16 v38;
  int v39;

  if (!a1)
    return 0;
  v3 = a2;
  v4 = NFSharedSignpostLog(v3);
  v5 = objc_claimAutoreleasedReturnValue(v4);
  if (os_signpost_enabled(v5))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v5, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "SetRoutingConfigInDriver", "", buf, 2u);
  }

  objc_msgSend(v3, "calculateFieldDetectEnabled:", sub_100098AF4(a1));
  v6 = (void *)objc_claimAutoreleasedReturnValue(+[NFPowerAssertion sharedPowerAssertion](NFPowerAssertion, "sharedPowerAssertion"));
  objc_msgSend(v6, "releasePowerAssertion:logFaultOnOverRelease:", CFSTR("ExpressMode"), 0);

  sub_10003DA78(*(void **)(a1 + 24));
  v7 = sub_1001FD360(*(_QWORD **)(a1 + 368), v3);
  v8 = (void *)objc_claimAutoreleasedReturnValue(v7);

  if (v8)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v12 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass((id)a1);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName((id)a1);
      Name = sel_getName("_setRoutingConfigInDriver:");
      v16 = 45;
      if (isMetaClass)
        v16 = 43;
      v12(3, "%c[%{public}s %{public}s]:%i Failed to change mode", v16, ClassName, Name, 8475);
    }
    v17 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v18 = NFSharedLogGetLogger(v17);
    v19 = objc_claimAutoreleasedReturnValue(v18);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      v20 = object_getClass((id)a1);
      if (class_isMetaClass(v20))
        v21 = 43;
      else
        v21 = 45;
      v22 = object_getClassName((id)a1);
      v23 = sel_getName("_setRoutingConfigInDriver:");
      *(_DWORD *)buf = 67109890;
      v33 = v21;
      v34 = 2082;
      v35 = v22;
      v36 = 2082;
      v37 = v23;
      v38 = 1024;
      v39 = 8475;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to change mode", buf, 0x22u);
    }

    v25 = NFSharedSignpostLog(v24);
    v26 = objc_claimAutoreleasedReturnValue(v25);
    if (os_signpost_enabled(v26))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v26, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SetRoutingConfigInDriver", "Failed", buf, 2u);
    }

    v27 = v8;
  }
  else
  {
    v28 = NFSharedSignpostLog(v9);
    v29 = objc_claimAutoreleasedReturnValue(v28);
    if (os_signpost_enabled(v29))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v29, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SetRoutingConfigInDriver", "Success", buf, 2u);
    }

  }
  return v8;
}

_QWORD *sub_10011ABCC(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  const char *Name;
  uint8_t buf[4];
  int v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  const char *v25;
  __int16 v26;
  int v27;

  v2 = (_QWORD *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "driverWrapper"));
  v3 = sub_1001CB430(v2, *(void **)(a1 + 40));

  if ((v3 & 1) == 0)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      v10 = 45;
      if (isMetaClass)
        v10 = 43;
      v6(3, "%c[%{public}s %{public}s]:%i Failed to configure ECP polling.", v10, ClassName, Name, 8355);
    }
    v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v12 = NFSharedLogGetLogger(v11);
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v14 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v14))
        v15 = 43;
      else
        v15 = 45;
      v16 = object_getClassName(*(id *)(a1 + 32));
      v17 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)buf = 67109890;
      v21 = v15;
      v22 = 2082;
      v23 = v16;
      v24 = 2082;
      v25 = v17;
      v26 = 1024;
      v27 = 8355;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to configure ECP polling.", buf, 0x22u);
    }

  }
  return v3;
}

uint64_t sub_10011B38C(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v5)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  objc_class *v13;
  int v14;
  const char *v15;
  const char *v16;
  const char *v17;
  void *v18;
  uint64_t v19;
  void (*v20)(uint64_t, const char *, ...);
  objc_class *v21;
  _BOOL4 v22;
  const char *v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  objc_class *v27;
  int v28;
  const char *v29;
  const char *v30;
  const char *Name;
  const char *v32;
  uint8_t buf[4];
  int v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  const char *v38;
  __int16 v39;
  int v40;

  if (!sub_1001CB84C(*(void **)(*(_QWORD *)(a1 + 32) + 368), *(unsigned int *)(a1 + 48)))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 40));
      v9 = 45;
      if (isMetaClass)
        v9 = 43;
      v5(3, "%c[%{public}s %{public}s]:%i Failed to configure Felica entry conditions", v9, ClassName, Name, 8789);
    }
    v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v11 = NFSharedLogGetLogger(v10);
    v12 = objc_claimAutoreleasedReturnValue(v11);
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      goto LABEL_23;
    v13 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v13))
      v14 = 43;
    else
      v14 = 45;
    v15 = object_getClassName(*(id *)(a1 + 32));
    v16 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)buf = 67109890;
    v34 = v14;
    v35 = 2082;
    v36 = v15;
    v37 = 2082;
    v38 = v16;
    v39 = 1024;
    v40 = 8789;
    v17 = "%c[%{public}s %{public}s]:%i Failed to configure Felica entry conditions";
    goto LABEL_22;
  }
  if ((sub_1001CB7DC(*(void **)(*(_QWORD *)(a1 + 32) + 368)) & 1) != 0)
    return 1;
  v18 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v19 = NFLogGetLogger(v18);
  if (v19)
  {
    v20 = (void (*)(uint64_t, const char *, ...))v19;
    v21 = object_getClass(*(id *)(a1 + 32));
    v22 = class_isMetaClass(v21);
    v23 = object_getClassName(*(id *)(a1 + 32));
    v32 = sel_getName(*(SEL *)(a1 + 40));
    v24 = 45;
    if (v22)
      v24 = 43;
    v20(3, "%c[%{public}s %{public}s]:%i Failed to enable Felica dual entry", v24, v23, v32, 8785);
  }
  v25 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v26 = NFSharedLogGetLogger(v25);
  v12 = objc_claimAutoreleasedReturnValue(v26);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    v27 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v27))
      v28 = 43;
    else
      v28 = 45;
    v29 = object_getClassName(*(id *)(a1 + 32));
    v30 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)buf = 67109890;
    v34 = v28;
    v35 = 2082;
    v36 = v29;
    v37 = 2082;
    v38 = v30;
    v39 = 1024;
    v40 = 8785;
    v17 = "%c[%{public}s %{public}s]:%i Failed to enable Felica dual entry";
LABEL_22:
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, v17, buf, 0x22u);
  }
LABEL_23:

  return 0;
}

id sub_10011B638(id result)
{
  void *v1;
  id v2;

  if (result)
  {
    v1 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(result, "lastKnownRoutingConfig"));
    v2 = objc_msgSend(v1, "wantsReader");

    return v2;
  }
  return result;
}

void sub_10011B6A8(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  id v5;

  v3 = a2;
  if (a1)
  {
    v4 = *(void **)(a1 + 120);
    v5 = v3;
    if (v4)
    {
      objc_msgSend(v4, "removeObserver:forKeyPath:", a1, CFSTR("walletDomain"));
      v3 = v5;
    }
    *(_QWORD *)(a1 + 120) = v3;
    objc_msgSend(v3, "addObserver:forKeyPath:options:context:", a1, CFSTR("walletDomain"), 5, off_100329780);
    v3 = v5;
  }

}

void sub_10011B75C(uint64_t a1, void *a2)
{
  if (a1)
    objc_storeStrong((id *)(a1 + 168), a2);
}

void sub_10011B76C(uint64_t a1, void *a2)
{
  if (a1)
    objc_storeStrong((id *)(a1 + 112), a2);
}

uint64_t sub_10011B964(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  uint64_t v8;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v1 = qword_10032A9C8;
  v6 = qword_10032A9C8;
  if (!qword_10032A9C8)
  {
    v7 = *(_OWORD *)off_1002E8700;
    v8 = 0;
    v1 = _sl_dlopen(&v7, a1);
    v4[3] = v1;
    qword_10032A9C8 = v1;
  }
  _Block_object_dispose(&v3, 8);
  return v1;
}

void sub_10011BA1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

void sub_10011BA34(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  v6 = 0;
  if (sub_10011B964((uint64_t)&v6))
  {
    v2 = v6;
    if (!v6)
      goto LABEL_3;
  }
  else
  {
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
    a1 = (_QWORD *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "void *libSystemHealthLibrary(void)"));
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", a1, CFSTR("_NFHardwareManager.m"), 130, CFSTR("%s"), v6);

    __break(1u);
  }
  free(v2);
LABEL_3:
  *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = objc_getClass("SystemHealthManager");
  if (*(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24))
  {
    qword_10032A9D0 = *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
  }
  else
  {
    v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Class getSystemHealthManagerClass(void)_block_invoke"));
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, CFSTR("_NFHardwareManager.m"), 131, CFSTR("Unable to find class %s"), "SystemHealthManager");

    __break(1u);
  }
}

void sub_10011F1FC(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  void *specific;
  uint64_t Logger;
  void (*v7)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  NSObject *v16;
  objc_class *v17;
  int v18;
  const char *v19;
  const char *v20;
  void *v21;
  uint64_t v22;
  id v23;
  void *v24;
  void *v25;
  void *v26;
  id v27;
  uint64_t v28;
  NSErrorUserInfoKey v29;
  void *v30;
  uint8_t buf[4];
  int v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  int v38;
  __int16 v39;
  void *v40;

  v2 = kdebug_trace(724566076, 1, 0, 0, 0);
  v3 = NFSharedSignpostLog(v2);
  v4 = objc_claimAutoreleasedReturnValue(v3);
  if (os_signpost_enabled(v4))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLIENT_GET_APPLETS", "in dispatch", buf, 2u);
  }

  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "preloadApplets"));
    v28 = *(_QWORD *)(a1 + 40);
    v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "applets"));
    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "activeApplet"));
    (*(void (**)(uint64_t, void *, void *, void *))(v28 + 16))(v28, v25, v26, v24);
    goto LABEL_17;
  }
  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v7 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v13 = 45;
    if (isMetaClass)
      v13 = 43;
    v7(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v13, ClassName, Name, 260, v12);

  }
  v14 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v15 = NFSharedLogGetLogger(v14);
  v16 = objc_claimAutoreleasedReturnValue(v15);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    v17 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v17))
      v18 = 43;
    else
      v18 = 45;
    v19 = object_getClassName(*(id *)(a1 + 32));
    v20 = sel_getName(*(SEL *)(a1 + 48));
    v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v32 = v18;
    v33 = 2082;
    v34 = v19;
    v35 = 2082;
    v36 = v20;
    v37 = 1024;
    v38 = 260;
    v39 = 2114;
    v40 = v21;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v22 = *(_QWORD *)(a1 + 40);
  if (v22)
  {
    v23 = objc_alloc((Class)NSError);
    v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v29 = NSLocalizedDescriptionKey;
    v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v30 = v25;
    v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v30, &v29, 1));
    v27 = objc_msgSend(v23, "initWithDomain:code:userInfo:", v24, 54, v26);
    (*(void (**)(uint64_t, _QWORD, _QWORD, id))(v22 + 16))(v22, 0, 0, v27);

LABEL_17:
  }
}

void sub_10011F734(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *v5;
  _BOOL4 v6;
  const char *v7;
  const char *v8;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  uint64_t v19;
  id v20;
  id v21;
  void *v22;
  void *v23;
  id v24;
  void *specific;
  uint64_t Logger;
  void (*v27)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v32;
  uint64_t v33;
  void *v34;
  uint64_t v35;
  NSObject *v36;
  objc_class *v37;
  int v38;
  const char *v39;
  const char *v40;
  void *v41;
  void *v42;
  uint64_t v43;
  unsigned __int8 *v44;
  int v45;
  void *v46;
  uint64_t v47;
  void (*v48)(uint64_t, const char *, ...);
  objc_class *v49;
  _BOOL4 v50;
  const char *v51;
  uint64_t v52;
  void *v53;
  uint64_t v54;
  NSObject *v55;
  objc_class *v56;
  int v57;
  const char *v58;
  const char *v59;
  uint64_t v60;
  id v61;
  void *v62;
  void *v63;
  void *v64;
  id v65;
  uint64_t v66;
  void *v67;
  void *v68;
  unsigned __int8 v69;
  void *v70;
  void *v71;
  id v72;
  void *v73;
  void *v74;
  uint64_t v75;
  void (*v76)(uint64_t, const char *, ...);
  objc_class *v77;
  _BOOL4 v78;
  uint64_t v79;
  void *v80;
  uint64_t v81;
  NSObject *v82;
  objc_class *v83;
  int v84;
  const char *v85;
  const char *v86;
  id v87;
  uint64_t v88;
  uint64_t v89;
  void *v90;
  uint64_t v91;
  void *v92;
  uint64_t v93;
  void *v94;
  void *v95;
  uint64_t v96;
  void (*v97)(uint64_t, const char *, ...);
  objc_class *v98;
  _BOOL4 v99;
  const char *v100;
  const char *v101;
  uint64_t v102;
  void *v103;
  uint64_t v104;
  NSObject *v105;
  objc_class *v106;
  int v107;
  const char *v108;
  const char *v109;
  void *v110;
  uint64_t v111;
  void *v112;
  void *v113;
  void *v114;
  unsigned __int8 v115;
  _BYTE *v116;
  void *v117;
  void *v118;
  void *v119;
  void *v120;
  void *v121;
  uint64_t v122;
  void (*v123)(uint64_t, const char *, ...);
  objc_class *v124;
  const char *v125;
  const char *v126;
  void *v127;
  uint64_t v128;
  void *v129;
  uint64_t v130;
  NSObject *v131;
  objc_class *v132;
  int v133;
  const char *v134;
  const char *v135;
  void *v136;
  id v137;
  void *v138;
  uint64_t v139;
  void (*v140)(uint64_t, const char *, ...);
  objc_class *v141;
  _BOOL4 v142;
  const char *v143;
  const char *v144;
  void *v145;
  void *v146;
  uint64_t v147;
  void *v148;
  uint64_t v149;
  NSObject *v150;
  objc_class *v151;
  int v152;
  const char *v153;
  const char *v154;
  void *v155;
  void *v156;
  uint64_t v157;
  uint64_t v158;
  NSObject *v159;
  uint64_t v160;
  void *v161;
  uint64_t v162;
  void *v163;
  id v164;
  void *v165;
  uint64_t v166;
  void (*v167)(uint64_t, const char *, ...);
  objc_class *v168;
  _BOOL4 v169;
  uint64_t v170;
  void *v171;
  uint64_t v172;
  NSObject *v173;
  objc_class *v174;
  int v175;
  const char *v176;
  const char *v177;
  uint64_t v178;
  uint64_t v179;
  NSObject *v180;
  uint64_t v181;
  uint64_t v182;
  NSObject *v183;
  void *v184;
  uint64_t v185;
  void (*v186)(uint64_t, const char *, ...);
  objc_class *v187;
  _BOOL4 v188;
  const char *v189;
  uint64_t v190;
  void *v191;
  uint64_t v192;
  NSObject *v193;
  objc_class *v194;
  int v195;
  const char *v196;
  const char *v197;
  _BYTE *v198;
  uint64_t v199;
  void *v200;
  void *v201;
  id v202;
  void *v203;
  void *v204;
  void *v205;
  void *v206;
  void *v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  _BYTE *v211;
  void *v212;
  uint64_t v213;
  void (*v214)(uint64_t, const char *, ...);
  objc_class *v215;
  _BOOL4 v216;
  const char *v217;
  uint64_t v218;
  void *v219;
  uint64_t v220;
  NSObject *v221;
  objc_class *v222;
  int v223;
  const char *v224;
  const char *v225;
  void *v226;
  uint64_t v227;
  void (*v228)(uint64_t, const char *, ...);
  objc_class *v229;
  _BOOL4 v230;
  const char *v231;
  uint64_t v232;
  void *v233;
  uint64_t v234;
  NSObject *v235;
  objc_class *v236;
  int v237;
  const char *v238;
  const char *v239;
  id v240;
  id v241;
  void *v242;
  void *v243;
  uint64_t v244;
  uint64_t v245;
  NSObject *v246;
  void *v247;
  const char *v248;
  const char *v249;
  const char *v250;
  const char *v251;
  const char *v252;
  const char *v253;
  const char *v254;
  const char *v255;
  _BOOL4 v256;
  int v257;
  _QWORD v258[5];
  id v259;
  NSErrorUserInfoKey v260;
  void *v261;
  NSErrorUserInfoKey v262;
  void *v263;
  NSErrorUserInfoKey v264;
  void *v265;
  uint8_t buf[4];
  int v267;
  __int16 v268;
  const char *v269;
  __int16 v270;
  const char *v271;
  __int16 v272;
  int v273;
  __int16 v274;
  id v275;
  __int16 v276;
  void *v277;
  __int16 v278;
  uint64_t v279;
  NSErrorUserInfoKey v280;
  void *v281;

  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v27 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 72));
      v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
      v33 = 43;
      if (!isMetaClass)
        v33 = 45;
      v27(6, "%c[%{public}s %{public}s]:%i %{public}@ : requestedApplet: %{public}@ keyIdentifiers: %{public}@", v33, ClassName, Name, 279, v32, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48));

    }
    v34 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v35 = NFSharedLogGetLogger(v34);
    v36 = objc_claimAutoreleasedReturnValue(v35);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
    {
      v37 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v37))
        v38 = 43;
      else
        v38 = 45;
      v39 = object_getClassName(*(id *)(a1 + 32));
      v40 = sel_getName(*(SEL *)(a1 + 72));
      v41 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
      v42 = *(void **)(a1 + 40);
      v43 = *(_QWORD *)(a1 + 48);
      *(_DWORD *)buf = 67110658;
      v267 = v38;
      v268 = 2082;
      v269 = v39;
      v270 = 2082;
      v271 = v40;
      v272 = 1024;
      v273 = 279;
      v274 = 2114;
      v275 = v41;
      v276 = 2114;
      v277 = v42;
      v278 = 2114;
      v279 = v43;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@ : requestedApplet: %{public}@ keyIdentifiers: %{public}@", buf, 0x40u);

    }
    v21 = *(id *)(a1 + 40);
    v44 = (unsigned __int8 *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "expressModeManager"));
    if (v44)
    {
      v45 = v44[172];

      if (v45)
      {
        v46 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v47 = NFLogGetLogger(v46);
        if (v47)
        {
          v48 = (void (*)(uint64_t, const char *, ...))v47;
          v49 = object_getClass(*(id *)(a1 + 32));
          v50 = class_isMetaClass(v49);
          v51 = object_getClassName(*(id *)(a1 + 32));
          v250 = sel_getName(*(SEL *)(a1 + 72));
          v52 = 45;
          if (v50)
            v52 = 43;
          v48(4, "%c[%{public}s %{public}s]:%i Express mode in progress, denying..", v52, v51, v250, 284);
        }
        v53 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v54 = NFSharedLogGetLogger(v53);
        v55 = objc_claimAutoreleasedReturnValue(v54);
        if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
        {
          v56 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v56))
            v57 = 43;
          else
            v57 = 45;
          v58 = object_getClassName(*(id *)(a1 + 32));
          v59 = sel_getName(*(SEL *)(a1 + 72));
          *(_DWORD *)buf = 67109890;
          v267 = v57;
          v268 = 2082;
          v269 = v58;
          v270 = 2082;
          v271 = v59;
          v272 = 1024;
          v273 = 284;
          _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Express mode in progress, denying..", buf, 0x22u);
        }

        v60 = *(_QWORD *)(a1 + 64);
        v61 = objc_alloc((Class)NSError);
        v62 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v264 = NSLocalizedDescriptionKey;
        v63 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Express Mode in progress"));
        v265 = v63;
        v64 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v265, &v264, 1));
        v65 = objc_msgSend(v61, "initWithDomain:code:userInfo:", v62, 38, v64);
        (*(void (**)(uint64_t, _QWORD, _QWORD, id))(v60 + 16))(v60, 0, 0, v65);

        goto LABEL_16;
      }
    }
    v66 = objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "groupHeadID"));
    if (v66)
    {
      v67 = (void *)v66;
      v68 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "secureElementWrapper"));
      v69 = objc_msgSend(v68, "supportedTechnologies");

      if ((v69 & 4) != 0)
      {
        objc_msgSend(*(id *)(a1 + 32), "switchToSecureElementWrapperForApplet:", v21);
        objc_msgSend(*(id *)(a1 + 32), "startWiredMode");
        v70 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "secureElementWrapper"));
        v71 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "groupHeadID"));
        v72 = sub_10022F2F0(v70, v71);
        v73 = (void *)objc_claimAutoreleasedReturnValue(v72);

        if (objc_msgSend(v73, "isTypeF"))
        {
          v74 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v75 = NFLogGetLogger(v74);
          if (v75)
          {
            v76 = (void (*)(uint64_t, const char *, ...))v75;
            v77 = object_getClass(*(id *)(a1 + 32));
            v78 = class_isMetaClass(v77);
            v248 = object_getClassName(*(id *)(a1 + 32));
            v251 = sel_getName(*(SEL *)(a1 + 72));
            v79 = 45;
            if (v78)
              v79 = 43;
            v76(6, "%c[%{public}s %{public}s]:%i Switching applet to Type-F group head applet - %{public}@", v79, v248, v251, 296, v73);
          }
          v80 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v81 = NFSharedLogGetLogger(v80);
          v82 = objc_claimAutoreleasedReturnValue(v81);
          if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
          {
            v83 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v83))
              v84 = 43;
            else
              v84 = 45;
            v85 = object_getClassName(*(id *)(a1 + 32));
            v86 = sel_getName(*(SEL *)(a1 + 72));
            *(_DWORD *)buf = 67110146;
            v267 = v84;
            v268 = 2082;
            v269 = v85;
            v270 = 2082;
            v271 = v86;
            v272 = 1024;
            v273 = 296;
            v274 = 2114;
            v275 = v73;
            _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Switching applet to Type-F group head applet - %{public}@", buf, 0x2Cu);
          }

          v87 = v73;
          v21 = v87;
        }

      }
    }
    v89 = *(_QWORD *)(a1 + 40);
    v88 = *(_QWORD *)(a1 + 48);
    v90 = *(void **)(a1 + 32);
    v91 = objc_claimAutoreleasedReturnValue(objc_msgSend(v90, "expressModeManager"));
    v92 = (void *)v91;
    if (v91)
      v93 = *(_QWORD *)(v91 + 136);
    else
      v93 = 0;
    v94 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v90, "setActiveKeys:onApplet:allowBackgroundTransactions:", v88, v89, v93 != -1));

    if (v94)
    {
      v95 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v96 = NFLogGetLogger(v95);
      if (v96)
      {
        v97 = (void (*)(uint64_t, const char *, ...))v96;
        v98 = object_getClass(*(id *)(a1 + 32));
        v99 = class_isMetaClass(v98);
        v100 = object_getClassName(*(id *)(a1 + 32));
        v101 = sel_getName(*(SEL *)(a1 + 72));
        v102 = 45;
        if (v99)
          v102 = 43;
        v97(3, "%c[%{public}s %{public}s]:%i Failed to setup active keys %{public}@ - error %{public}@", v102, v100, v101, 307, *(_QWORD *)(a1 + 48), v94);
      }
      v103 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v104 = NFSharedLogGetLogger(v103);
      v105 = objc_claimAutoreleasedReturnValue(v104);
      if (os_log_type_enabled(v105, OS_LOG_TYPE_ERROR))
      {
        v106 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v106))
          v107 = 43;
        else
          v107 = 45;
        v108 = object_getClassName(*(id *)(a1 + 32));
        v109 = sel_getName(*(SEL *)(a1 + 72));
        v110 = *(void **)(a1 + 48);
        *(_DWORD *)buf = 67110402;
        v267 = v107;
        v268 = 2082;
        v269 = v108;
        v270 = 2082;
        v271 = v109;
        v272 = 1024;
        v273 = 307;
        v274 = 2114;
        v275 = v110;
        v276 = 2114;
        v277 = v94;
        _os_log_impl((void *)&_mh_execute_header, v105, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to setup active keys %{public}@ - error %{public}@", buf, 0x36u);
      }

      goto LABEL_66;
    }
    objc_msgSend(*(id *)(a1 + 32), "setDeferredActivationApplet:", 0);
    v114 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "activeApplet"));
    v115 = objc_msgSend(v21, "isEqualToApplet:", v114);

    if ((v115 & 1) == 0)
    {
      v116 = *(_BYTE **)(a1 + 32);
      if (v21)
      {
        if (v116[264])
        {
          v117 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "activeApplet"));

          v116 = *(_BYTE **)(a1 + 32);
          if (v117)
          {
            v118 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "activeApplet"));
            v119 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v116, "seidForApplet:", v118));

            v120 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "seidForApplet:", v21));
            if ((objc_msgSend(v119, "isEqualToString:", v120) & 1) == 0)
            {
              v121 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v122 = NFLogGetLogger(v121);
              if (v122)
              {
                v123 = (void (*)(uint64_t, const char *, ...))v122;
                v124 = object_getClass(*(id *)(a1 + 32));
                v256 = class_isMetaClass(v124);
                v125 = object_getClassName(*(id *)(a1 + 32));
                v126 = sel_getName(*(SEL *)(a1 + 72));
                v127 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "activeApplet"));
                v128 = 45;
                if (v256)
                  v128 = 43;
                v123(6, "%c[%{public}s %{public}s]:%i deauthorizing previously authed applet on different seid: %{public}@", v128, v125, v126, 321, v127);

              }
              v129 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v130 = NFSharedLogGetLogger(v129);
              v131 = objc_claimAutoreleasedReturnValue(v130);
              if (os_log_type_enabled(v131, OS_LOG_TYPE_DEFAULT))
              {
                v132 = object_getClass(*(id *)(a1 + 32));
                if (class_isMetaClass(v132))
                  v133 = 43;
                else
                  v133 = 45;
                v257 = v133;
                v134 = object_getClassName(*(id *)(a1 + 32));
                v135 = sel_getName(*(SEL *)(a1 + 72));
                v136 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "activeApplet"));
                *(_DWORD *)buf = 67110146;
                v267 = v257;
                v268 = 2082;
                v269 = v134;
                v270 = 2082;
                v271 = v135;
                v272 = 1024;
                v273 = 321;
                v274 = 2114;
                v275 = v136;
                _os_log_impl((void *)&_mh_execute_header, v131, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i deauthorizing previously authed applet on different seid: %{public}@", buf, 0x2Cu);

              }
              objc_msgSend(*(id *)(a1 + 32), "_deauthorize");
            }

            v116 = *(_BYTE **)(a1 + 32);
          }
        }
      }
      if (objc_msgSend(v116, "_requiresDeferredActivation:", v21))
      {
        objc_msgSend(*(id *)(a1 + 32), "setDeferredActivationApplet:", v21);
        v137 = objc_msgSend(*(id *)(a1 + 32), "setActiveApplet:", 0);
        v138 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v139 = NFLogGetLogger(v138);
        if (v139)
        {
          v140 = (void (*)(uint64_t, const char *, ...))v139;
          v141 = object_getClass(*(id *)(a1 + 32));
          v142 = class_isMetaClass(v141);
          v143 = object_getClassName(*(id *)(a1 + 32));
          v144 = sel_getName(*(SEL *)(a1 + 72));
          v145 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "deferredActivationApplet"));
          v146 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v145, "identifier"));
          v147 = 45;
          if (v142)
            v147 = 43;
          v140(6, "%c[%{public}s %{public}s]:%i Applet %{public}@ requires deferred activation", v147, v143, v144, 329, v146);

        }
        v148 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v149 = NFSharedLogGetLogger(v148);
        v150 = objc_claimAutoreleasedReturnValue(v149);
        if (os_log_type_enabled(v150, OS_LOG_TYPE_DEFAULT))
        {
          v151 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v151))
            v152 = 43;
          else
            v152 = 45;
          v153 = object_getClassName(*(id *)(a1 + 32));
          v154 = sel_getName(*(SEL *)(a1 + 72));
          v155 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "deferredActivationApplet"));
          v156 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v155, "identifier"));
          *(_DWORD *)buf = 67110146;
          v267 = v152;
          v268 = 2082;
          v269 = v153;
          v270 = 2082;
          v271 = v154;
          v272 = 1024;
          v273 = 329;
          v274 = 2114;
          v275 = v156;
          _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Applet %{public}@ requires deferred activation", buf, 0x2Cu);

        }
      }
      else
      {
        v157 = kdebug_trace(724566060, 0, 0, 0, 0);
        v158 = NFSharedSignpostLog(v157);
        v159 = objc_claimAutoreleasedReturnValue(v158);
        if (os_signpost_enabled(v159))
        {
          *(_WORD *)buf = 0;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v159, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "ACTIVATE_APPLET", "", buf, 2u);
        }

        v160 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "setActiveApplet:", v21));
        if (v160)
        {
          v94 = (void *)v160;
LABEL_66:
          v111 = *(_QWORD *)(a1 + 64);
          v112 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "activeApplet"));
          v113 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "activeKeyIdentifiers"));
          (*(void (**)(uint64_t, void *, void *, void *))(v111 + 16))(v111, v112, v113, v94);

          objc_msgSend(*(id *)(a1 + 32), "startDefaultMode");
          goto LABEL_16;
        }
      }
    }
    v161 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "deferredActivationApplet"));

    if (v161)
    {
      v162 = *(_QWORD *)(a1 + 56);
      if (v162)
      {
        v163 = *(void **)(a1 + 32);
        v258[0] = _NSConcreteStackBlock;
        v258[1] = 3221225472;
        v258[2] = sub_100120DE4;
        v258[3] = &unk_1002E89D0;
        v164 = *(id *)(a1 + 64);
        v258[4] = *(_QWORD *)(a1 + 32);
        v259 = v164;
        objc_msgSend(v163, "_sync_startDeferredCardEmulationWithAuthorization:completion:", v162, v258);

        goto LABEL_16;
      }
      v209 = *(_QWORD *)(a1 + 64);
      v210 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "deferredActivationApplet"));
      goto LABEL_158;
    }
    objc_msgSend(*(id *)(a1 + 32), "switchToSecureElementWrapperForApplet:", v21);
    v165 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v166 = NFLogGetLogger(v165);
    if (v166)
    {
      v167 = (void (*)(uint64_t, const char *, ...))v166;
      v168 = object_getClass(*(id *)(a1 + 32));
      v169 = class_isMetaClass(v168);
      v249 = object_getClassName(*(id *)(a1 + 32));
      v252 = sel_getName(*(SEL *)(a1 + 72));
      v170 = 45;
      if (v169)
        v170 = 43;
      v167(6, "%c[%{public}s %{public}s]:%i active = %{public}@", v170, v249, v252, 359, v21);
    }
    v171 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v172 = NFSharedLogGetLogger(v171);
    v173 = objc_claimAutoreleasedReturnValue(v172);
    if (os_log_type_enabled(v173, OS_LOG_TYPE_DEFAULT))
    {
      v174 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v174))
        v175 = 43;
      else
        v175 = 45;
      v176 = object_getClassName(*(id *)(a1 + 32));
      v177 = sel_getName(*(SEL *)(a1 + 72));
      *(_DWORD *)buf = 67110146;
      v267 = v175;
      v268 = 2082;
      v269 = v176;
      v270 = 2082;
      v271 = v177;
      v272 = 1024;
      v273 = 359;
      v274 = 2114;
      v275 = v21;
      _os_log_impl((void *)&_mh_execute_header, v173, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i active = %{public}@", buf, 0x2Cu);
    }

    if (*(_QWORD *)(a1 + 56))
    {
      v178 = kdebug_trace(724566064, 0, 0, 0, 0);
      v179 = NFSharedSignpostLog(v178);
      v180 = objc_claimAutoreleasedReturnValue(v179);
      if (os_signpost_enabled(v180))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v180, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "AUTHORIZE_APPLET", "", buf, 2u);
      }

      if ((objc_msgSend(*(id *)(a1 + 32), "_authorize:", *(_QWORD *)(a1 + 56)) & 1) == 0)
      {
        v226 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v227 = NFLogGetLogger(v226);
        if (v227)
        {
          v228 = (void (*)(uint64_t, const char *, ...))v227;
          v229 = object_getClass(*(id *)(a1 + 32));
          v230 = class_isMetaClass(v229);
          v231 = object_getClassName(*(id *)(a1 + 32));
          v255 = sel_getName(*(SEL *)(a1 + 72));
          v232 = 45;
          if (v230)
            v232 = 43;
          v228(3, "%c[%{public}s %{public}s]:%i Failed to authorize", v232, v231, v255, 366);
        }
        v233 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v234 = NFSharedLogGetLogger(v233);
        v235 = objc_claimAutoreleasedReturnValue(v234);
        if (os_log_type_enabled(v235, OS_LOG_TYPE_ERROR))
        {
          v236 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v236))
            v237 = 43;
          else
            v237 = 45;
          v238 = object_getClassName(*(id *)(a1 + 32));
          v239 = sel_getName(*(SEL *)(a1 + 72));
          *(_DWORD *)buf = 67109890;
          v267 = v237;
          v268 = 2082;
          v269 = v238;
          v270 = 2082;
          v271 = v239;
          v272 = 1024;
          v273 = 366;
          _os_log_impl((void *)&_mh_execute_header, v235, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to authorize", buf, 0x22u);
        }

        v199 = *(_QWORD *)(a1 + 64);
        v200 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "activeApplet"));
        v201 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "activeKeyIdentifiers"));
        v240 = objc_alloc((Class)NSError);
        v203 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v262 = NSLocalizedDescriptionKey;
        v204 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Commmand Error"));
        v263 = v204;
        v205 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v263, &v262, 1));
        v206 = v240;
        v207 = v203;
        v208 = 16;
        goto LABEL_151;
      }
      v181 = kdebug_trace(724566068, 0, 0, 0, 0);
      v182 = NFSharedSignpostLog(v181);
      v183 = objc_claimAutoreleasedReturnValue(v182);
      if (os_signpost_enabled(v183))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v183, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "START_PAYMENT_EMULATION", "", buf, 2u);
      }

      if ((objc_msgSend(*(id *)(a1 + 32), "startCardEmulationWithType:", objc_msgSend(*(id *)(a1 + 32), "defaultEmulationType")) & 1) == 0)
      {
        v184 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v185 = NFLogGetLogger(v184);
        if (v185)
        {
          v186 = (void (*)(uint64_t, const char *, ...))v185;
          v187 = object_getClass(*(id *)(a1 + 32));
          v188 = class_isMetaClass(v187);
          v189 = object_getClassName(*(id *)(a1 + 32));
          v253 = sel_getName(*(SEL *)(a1 + 72));
          v190 = 45;
          if (v188)
            v190 = 43;
          v186(3, "%c[%{public}s %{public}s]:%i Failed to start card emulation", v190, v189, v253, 376);
        }
        v191 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v192 = NFSharedLogGetLogger(v191);
        v193 = objc_claimAutoreleasedReturnValue(v192);
        if (os_log_type_enabled(v193, OS_LOG_TYPE_ERROR))
        {
          v194 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v194))
            v195 = 43;
          else
            v195 = 45;
          v196 = object_getClassName(*(id *)(a1 + 32));
          v197 = sel_getName(*(SEL *)(a1 + 72));
          *(_DWORD *)buf = 67109890;
          v267 = v195;
          v268 = 2082;
          v269 = v196;
          v270 = 2082;
          v271 = v197;
          v272 = 1024;
          v273 = 376;
          _os_log_impl((void *)&_mh_execute_header, v193, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to start card emulation", buf, 0x22u);
        }

        v198 = *(_BYTE **)(a1 + 32);
        if (v198[264])
        {
          objc_msgSend(v198, "_deauthorize");
          v198 = *(_BYTE **)(a1 + 32);
        }
        v199 = *(_QWORD *)(a1 + 64);
        v200 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v198, "activeApplet"));
        v201 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "activeKeyIdentifiers"));
        v202 = objc_alloc((Class)NSError);
        v203 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v260 = NSLocalizedDescriptionKey;
        v204 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
        v261 = v204;
        v205 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v261, &v260, 1));
        v206 = v202;
        v207 = v203;
        v208 = 15;
LABEL_151:
        v241 = objc_msgSend(v206, "initWithDomain:code:userInfo:", v207, v208, v205);
        (*(void (**)(uint64_t, void *, void *, id))(v199 + 16))(v199, v200, v201, v241);

        objc_msgSend(*(id *)(a1 + 32), "startDefaultMode");
        goto LABEL_16;
      }
    }
    else
    {
      v211 = *(_BYTE **)(a1 + 32);
      if (v211[264])
      {
        v212 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v213 = NFLogGetLogger(v212);
        if (v213)
        {
          v214 = (void (*)(uint64_t, const char *, ...))v213;
          v215 = object_getClass(*(id *)(a1 + 32));
          v216 = class_isMetaClass(v215);
          v217 = object_getClassName(*(id *)(a1 + 32));
          v254 = sel_getName(*(SEL *)(a1 + 72));
          v218 = 45;
          if (v216)
            v218 = 43;
          v214(6, "%c[%{public}s %{public}s]:%i Already authorized - staying in wired mode - need to call startCardEmulation or enable express", v218, v217, v254, 386);
        }
        v219 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v220 = NFSharedLogGetLogger(v219);
        v221 = objc_claimAutoreleasedReturnValue(v220);
        if (os_log_type_enabled(v221, OS_LOG_TYPE_DEFAULT))
        {
          v222 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v222))
            v223 = 43;
          else
            v223 = 45;
          v224 = object_getClassName(*(id *)(a1 + 32));
          v225 = sel_getName(*(SEL *)(a1 + 72));
          *(_DWORD *)buf = 67109890;
          v267 = v223;
          v268 = 2082;
          v269 = v224;
          v270 = 2082;
          v271 = v225;
          v272 = 1024;
          v273 = 386;
          _os_log_impl((void *)&_mh_execute_header, v221, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Already authorized - staying in wired mode - need to call startCardEmulation or enable express", buf, 0x22u);
        }

      }
      else
      {
        v242 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v211, "activeKeyIdentifiers"));

        v243 = *(void **)(a1 + 32);
        if (v242)
          objc_msgSend(v243, "startDefaultModeAndKeepSEOn:", 1);
        else
          objc_msgSend(v243, "startDefaultMode");
      }
    }
    v244 = kdebug_trace(724566152, 0, 0, 0, 0);
    v245 = NFSharedSignpostLog(v244);
    v246 = objc_claimAutoreleasedReturnValue(v245);
    if (os_signpost_enabled(v246))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v246, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLIENT_CALLBACK", "", buf, 2u);
    }

    v209 = *(_QWORD *)(a1 + 64);
    v210 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "activeApplet"));
LABEL_158:
    v22 = (void *)v210;
    v247 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "activeKeyIdentifiers"));
    (*(void (**)(uint64_t, void *, void *, _QWORD))(v209 + 16))(v209, v22, v247, 0);

    goto LABEL_15;
  }
  v2 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v3 = NFLogGetLogger(v2);
  if (v3)
  {
    v4 = (void (*)(uint64_t, const char *, ...))v3;
    v5 = object_getClass(*(id *)(a1 + 32));
    v6 = class_isMetaClass(v5);
    v7 = object_getClassName(*(id *)(a1 + 32));
    v8 = sel_getName(*(SEL *)(a1 + 72));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v10 = 45;
    if (v6)
      v10 = 43;
    v4(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v10, v7, v8, 277, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 72));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v267 = v15;
    v268 = 2082;
    v269 = v16;
    v270 = 2082;
    v271 = v17;
    v272 = 1024;
    v273 = 277;
    v274 = 2114;
    v275 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v19 = *(_QWORD *)(a1 + 64);
  if (v19)
  {
    v20 = objc_alloc((Class)NSError);
    v21 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v280 = NSLocalizedDescriptionKey;
    v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v281 = v22;
    v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v281, &v280, 1));
    v24 = objc_msgSend(v20, "initWithDomain:code:userInfo:", v21, 54, v23);
    (*(void (**)(uint64_t, _QWORD, _QWORD, id))(v19 + 16))(v19, 0, 0, v24);

LABEL_15:
LABEL_16:

  }
}

void sub_100120DE4(uint64_t a1, void *a2)
{
  uint64_t v3;
  void *v4;
  id v5;
  void *v6;
  id v7;

  v4 = *(void **)(a1 + 32);
  v3 = *(_QWORD *)(a1 + 40);
  v5 = a2;
  v7 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "deferredActivationApplet"));
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "activeKeyIdentifiers"));
  (*(void (**)(uint64_t, id, void *, id))(v3 + 16))(v3, v7, v6, v5);

}

void sub_100121010(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *v5;
  _BOOL4 v6;
  const char *v7;
  const char *v8;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  uint64_t v19;
  id v20;
  id v21;
  void *v22;
  id v23;
  id v24;
  void *v25;
  void *v26;
  id v27;
  uint64_t v28;
  id v29;
  unsigned __int8 *v30;
  int v31;
  void *specific;
  uint64_t Logger;
  void (*v34)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v38;
  void *v39;
  uint64_t v40;
  NSObject *v41;
  objc_class *v42;
  int v43;
  const char *v44;
  const char *v45;
  id v46;
  void *v47;
  uint64_t v48;
  uint64_t v49;
  void *v50;
  uint64_t v51;
  void *v52;
  uint64_t v53;
  void (*v54)(uint64_t, const char *, ...);
  objc_class *v55;
  _BOOL4 v56;
  const char *v57;
  const char *v58;
  uint64_t v59;
  void *v60;
  uint64_t v61;
  NSObject *v62;
  objc_class *v63;
  int v64;
  const char *v65;
  const char *v66;
  void *v67;
  uint64_t v68;
  void *v69;
  void *v70;
  void *v71;
  uint64_t v72;
  void (*v73)(uint64_t, const char *, ...);
  objc_class *v74;
  _BOOL4 v75;
  const char *v76;
  const char *v77;
  uint64_t v78;
  void *v79;
  uint64_t v80;
  NSObject *v81;
  objc_class *v82;
  int v83;
  const char *v84;
  const char *v85;
  void *v86;
  id v87;
  NSMutableArray *v88;
  void *v89;
  uint64_t v90;
  void *v91;
  void *v92;
  id v93;
  void *v94;
  uint64_t v95;
  void *v96;
  unsigned __int8 v97;
  _BYTE *v98;
  void *v99;
  void *v100;
  void *v101;
  void *v102;
  void *v103;
  uint64_t v104;
  void (*v105)(uint64_t, const char *, ...);
  objc_class *v106;
  const char *v107;
  void *v108;
  uint64_t v109;
  void *v110;
  uint64_t v111;
  NSObject *v112;
  objc_class *v113;
  int v114;
  const char *v115;
  void *v116;
  id v117;
  void *v118;
  uint64_t v119;
  void (*v120)(uint64_t, const char *, ...);
  objc_class *v121;
  const char *v122;
  const char *v123;
  void *v124;
  void *v125;
  uint64_t v126;
  void *v127;
  uint64_t v128;
  NSObject *v129;
  objc_class *v130;
  int v131;
  const char *v132;
  const char *v133;
  void *v134;
  void *v135;
  void *v136;
  uint64_t v137;
  void (*v138)(uint64_t, const char *, ...);
  objc_class *v139;
  _BOOL4 v140;
  uint64_t v141;
  void *v142;
  uint64_t v143;
  NSObject *v144;
  objc_class *v145;
  int v146;
  const char *v147;
  const char *v148;
  id v149;
  NSObject *v150;
  void *v151;
  id v152;
  id v153;
  void *v154;
  uint64_t v155;
  void *v156;
  void *v157;
  uint64_t v158;
  uint64_t v159;
  NSObject *v160;
  uint64_t v161;
  void *v162;
  uint64_t v163;
  void (*v164)(uint64_t, const char *, ...);
  objc_class *v165;
  _BOOL4 v166;
  uint64_t v167;
  void *v168;
  uint64_t v169;
  objc_class *v170;
  int v171;
  const char *v172;
  const char *v173;
  void *v174;
  uint64_t v175;
  void *v176;
  id v177;
  void *v178;
  uint64_t v179;
  void (*v180)(uint64_t, const char *, ...);
  objc_class *v181;
  _BOOL4 v182;
  uint64_t v183;
  void *v184;
  uint64_t v185;
  NSObject *v186;
  objc_class *v187;
  int v188;
  const char *v189;
  const char *v190;
  uint64_t v191;
  uint64_t v192;
  NSObject *v193;
  uint64_t v194;
  uint64_t v195;
  NSObject *v196;
  void *v197;
  uint64_t v198;
  void (*v199)(uint64_t, const char *, ...);
  objc_class *v200;
  _BOOL4 v201;
  const char *v202;
  uint64_t v203;
  void *v204;
  uint64_t v205;
  NSObject *v206;
  objc_class *v207;
  int v208;
  const char *v209;
  const char *v210;
  _BYTE *v211;
  uint64_t v212;
  void *v213;
  uint64_t v214;
  id v215;
  void *v216;
  void *v217;
  uint64_t v218;
  void *v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  _BYTE *v223;
  void *v224;
  uint64_t v225;
  void (*v226)(uint64_t, const char *, ...);
  objc_class *v227;
  _BOOL4 v228;
  const char *v229;
  uint64_t v230;
  void *v231;
  uint64_t v232;
  NSObject *v233;
  objc_class *v234;
  int v235;
  const char *v236;
  const char *v237;
  void *v238;
  uint64_t v239;
  void (*v240)(uint64_t, const char *, ...);
  objc_class *v241;
  _BOOL4 v242;
  const char *v243;
  uint64_t v244;
  void *v245;
  uint64_t v246;
  NSObject *v247;
  objc_class *v248;
  int v249;
  const char *v250;
  const char *v251;
  uint64_t v252;
  id v253;
  void *v254;
  void *v255;
  uint64_t v256;
  uint64_t v257;
  NSObject *v258;
  void *v259;
  void *v260;
  const char *v261;
  const char *v262;
  const char *v263;
  const char *Name;
  const char *v265;
  const char *v266;
  const char *v267;
  const char *v268;
  const char *v269;
  const char *v270;
  id v271;
  id v272;
  id v273;
  const char *v274;
  const char *v275;
  void *v276;
  _BOOL4 v277;
  int v278;
  _BOOL4 v279;
  int v280;
  void *v281;
  _QWORD v282[5];
  id v283;
  _QWORD v284[4];
  _QWORD v285[4];
  _QWORD v286[4];
  _QWORD v287[4];
  _QWORD v288[4];
  _QWORD v289[4];
  uint8_t buf[4];
  int v291;
  __int16 v292;
  const char *v293;
  __int16 v294;
  const char *v295;
  __int16 v296;
  int v297;
  __int16 v298;
  id v299;
  __int16 v300;
  id v301;
  _QWORD v302[4];
  _QWORD v303[4];
  _QWORD v304[4];
  _QWORD v305[4];
  _QWORD v306[4];
  _QWORD v307[4];

  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v30 = (unsigned __int8 *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "expressModeManager"));
    if (v30)
    {
      v31 = v30[172];

      if (v31)
      {
        specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        Logger = NFLogGetLogger(specific);
        if (Logger)
        {
          v34 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(*(id *)(a1 + 32));
          isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(*(id *)(a1 + 32));
          Name = sel_getName(*(SEL *)(a1 + 64));
          v38 = 45;
          if (isMetaClass)
            v38 = 43;
          v34(4, "%c[%{public}s %{public}s]:%i Express mode in progress, denying..", v38, ClassName, Name, 416);
        }
        v39 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v40 = NFSharedLogGetLogger(v39);
        v41 = objc_claimAutoreleasedReturnValue(v40);
        if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
        {
          v42 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v42))
            v43 = 43;
          else
            v43 = 45;
          v44 = object_getClassName(*(id *)(a1 + 32));
          v45 = sel_getName(*(SEL *)(a1 + 64));
          *(_DWORD *)buf = 67109890;
          v291 = v43;
          v292 = 2082;
          v293 = v44;
          v294 = 2082;
          v295 = v45;
          v296 = 1024;
          v297 = 416;
          _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Express mode in progress, denying..", buf, 0x22u);
        }

        v19 = *(_QWORD *)(a1 + 56);
        v46 = objc_alloc((Class)NSError);
        v21 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v304[0] = NSLocalizedDescriptionKey;
        v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Express Mode in progress"));
        v305[0] = v22;
        v305[1] = &off_1002FF738;
        v304[1] = CFSTR("Line");
        v304[2] = CFSTR("Method");
        v23 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 64)));
        v305[2] = v23;
        v304[3] = NSDebugDescriptionErrorKey;
        v24 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 64)), 417);
        v305[3] = v24;
        v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v305, v304, 4));
        v26 = v46;
        v27 = v21;
        v28 = 38;
        goto LABEL_15;
      }
    }
    if (objc_msgSend(*(id *)(a1 + 40), "count") != (id)2)
    {
      v71 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v72 = NFLogGetLogger(v71);
      if (v72)
      {
        v73 = (void (*)(uint64_t, const char *, ...))v72;
        v74 = object_getClass(*(id *)(a1 + 32));
        v75 = class_isMetaClass(v74);
        v76 = object_getClassName(*(id *)(a1 + 32));
        v77 = sel_getName(*(SEL *)(a1 + 64));
        v78 = 45;
        if (v75)
          v78 = 43;
        v73(3, "%c[%{public}s %{public}s]:%i Invalid number of aidsAndKeys %{public}@", v78, v76, v77, 422, *(_QWORD *)(a1 + 40));
      }
      v79 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v80 = NFSharedLogGetLogger(v79);
      v81 = objc_claimAutoreleasedReturnValue(v80);
      if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
      {
        v82 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v82))
          v83 = 43;
        else
          v83 = 45;
        v84 = object_getClassName(*(id *)(a1 + 32));
        v85 = sel_getName(*(SEL *)(a1 + 64));
        v86 = *(void **)(a1 + 40);
        *(_DWORD *)buf = 67110146;
        v291 = v83;
        v292 = 2082;
        v293 = v84;
        v294 = 2082;
        v295 = v85;
        v296 = 1024;
        v297 = 422;
        v298 = 2114;
        v299 = v86;
        _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid number of aidsAndKeys %{public}@", buf, 0x2Cu);
      }

      v19 = *(_QWORD *)(a1 + 56);
      v87 = objc_alloc((Class)NSError);
      v21 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v302[0] = NSLocalizedDescriptionKey;
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid Parameter"));
      v303[0] = v22;
      v303[1] = &off_1002FF750;
      v302[1] = CFSTR("Line");
      v302[2] = CFSTR("Method");
      v23 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 64)));
      v303[2] = v23;
      v302[3] = NSDebugDescriptionErrorKey;
      v24 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 64)), 423);
      v303[3] = v24;
      v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v303, v302, 4));
      v26 = v87;
      v27 = v21;
      v28 = 10;
      goto LABEL_15;
    }
    v47 = *(void **)(a1 + 32);
    v48 = *(_QWORD *)(a1 + 40);
    v49 = objc_claimAutoreleasedReturnValue(objc_msgSend(v47, "expressModeManager"));
    v50 = (void *)v49;
    if (v49)
      v51 = *(_QWORD *)(v49 + 136);
    else
      v51 = 0;
    v21 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v47, "setActiveKeys:allowBackgroundTransactions:", v48, v51 != -1));

    if (v21)
    {
      v52 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v53 = NFLogGetLogger(v52);
      if (v53)
      {
        v54 = (void (*)(uint64_t, const char *, ...))v53;
        v55 = object_getClass(*(id *)(a1 + 32));
        v56 = class_isMetaClass(v55);
        v57 = object_getClassName(*(id *)(a1 + 32));
        v58 = sel_getName(*(SEL *)(a1 + 64));
        v59 = 45;
        if (v56)
          v59 = 43;
        v54(3, "%c[%{public}s %{public}s]:%i Failed to setup active keys %{public}@ - error %{public}@", v59, v57, v58, 431, *(_QWORD *)(a1 + 40), v21);
      }
      v60 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v61 = NFSharedLogGetLogger(v60);
      v62 = objc_claimAutoreleasedReturnValue(v61);
      if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
      {
        v63 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v63))
          v64 = 43;
        else
          v64 = 45;
        v65 = object_getClassName(*(id *)(a1 + 32));
        v66 = sel_getName(*(SEL *)(a1 + 64));
        v67 = *(void **)(a1 + 40);
        *(_DWORD *)buf = 67110402;
        v291 = v64;
        v292 = 2082;
        v293 = v65;
        v294 = 2082;
        v295 = v66;
        v296 = 1024;
        v297 = 431;
        v298 = 2114;
        v299 = v67;
        v300 = 2114;
        v301 = v21;
        _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to setup active keys %{public}@ - error %{public}@", buf, 0x36u);
      }

      v68 = *(_QWORD *)(a1 + 56);
      v69 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "activeApplet"));
      v70 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "activeKeyIdentifiers"));
      (*(void (**)(uint64_t, void *, void *, id))(v68 + 16))(v68, v69, v70, v21);

      objc_msgSend(*(id *)(a1 + 32), "startDefaultMode");
      goto LABEL_16;
    }
    objc_msgSend(*(id *)(a1 + 32), "setDeferredActivationApplet:", 0);
    v88 = objc_opt_new(NSMutableArray);
    v89 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "keyEnumerator"));
    v90 = objc_claimAutoreleasedReturnValue(objc_msgSend(v89, "nextObject"));
    if (v90)
    {
      v91 = (void *)v90;
      while (1)
      {
        v92 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "secureElementWrapper"));
        v93 = sub_10022F2F0(v92, v91);
        v94 = (void *)objc_claimAutoreleasedReturnValue(v93);

        if (!v94)
          break;
        -[NSMutableArray addObject:](v88, "addObject:", v94);

        v95 = objc_claimAutoreleasedReturnValue(objc_msgSend(v89, "nextObject"));
        v91 = (void *)v95;
        if (!v95)
          goto LABEL_58;
      }
      v136 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v137 = NFLogGetLogger(v136);
      if (v137)
      {
        v138 = (void (*)(uint64_t, const char *, ...))v137;
        v139 = object_getClass(*(id *)(a1 + 32));
        v140 = class_isMetaClass(v139);
        v261 = object_getClassName(*(id *)(a1 + 32));
        v265 = sel_getName(*(SEL *)(a1 + 64));
        v141 = 45;
        if (v140)
          v141 = 43;
        v138(3, "%c[%{public}s %{public}s]:%i No applet for aid %@", v141, v261, v265, 445, v91);
      }
      v142 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v143 = NFSharedLogGetLogger(v142);
      v144 = objc_claimAutoreleasedReturnValue(v143);
      if (os_log_type_enabled(v144, OS_LOG_TYPE_ERROR))
      {
        v145 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v145))
          v146 = 43;
        else
          v146 = 45;
        v147 = object_getClassName(*(id *)(a1 + 32));
        v148 = sel_getName(*(SEL *)(a1 + 64));
        *(_DWORD *)buf = 67110146;
        v291 = v146;
        v292 = 2082;
        v293 = v147;
        v294 = 2082;
        v295 = v148;
        v296 = 1024;
        v297 = 445;
        v298 = 2112;
        v299 = v91;
        _os_log_impl((void *)&_mh_execute_header, v144, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i No applet for aid %@", buf, 0x2Cu);
      }

      v149 = objc_alloc((Class)NSError);
      v150 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v288[0] = NSLocalizedDescriptionKey;
      v151 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid Parameter"));
      v289[0] = v151;
      v289[1] = &off_1002FF768;
      v288[1] = CFSTR("Line");
      v288[2] = CFSTR("Method");
      v152 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 64)));
      v289[2] = v152;
      v288[3] = NSDebugDescriptionErrorKey;
      v153 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 64)), 446);
      v289[3] = v153;
      v154 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v289, v288, 4));
      v21 = objc_msgSend(v149, "initWithDomain:code:userInfo:", v150, 10, v154);

      goto LABEL_95;
    }
LABEL_58:
    v91 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray objectAtIndex:](v88, "objectAtIndex:", 0));
    v96 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "activeApplet"));
    v97 = objc_msgSend(v91, "isEqualToApplet:", v96);

    if ((v97 & 1) == 0)
    {
      v98 = *(_BYTE **)(a1 + 32);
      if (v91)
      {
        if (v98[264])
        {
          v99 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "activeApplet"));

          v98 = *(_BYTE **)(a1 + 32);
          if (v99)
          {
            v100 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "activeApplet"));
            v101 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v98, "seidForApplet:", v100));

            v102 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "seidForApplet:", v91));
            if ((objc_msgSend(v101, "isEqualToString:", v102) & 1) == 0)
            {
              v103 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v104 = NFLogGetLogger(v103);
              if (v104)
              {
                v105 = (void (*)(uint64_t, const char *, ...))v104;
                v106 = object_getClass(*(id *)(a1 + 32));
                v277 = class_isMetaClass(v106);
                v274 = object_getClassName(*(id *)(a1 + 32));
                v107 = sel_getName(*(SEL *)(a1 + 64));
                v108 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "activeApplet"));
                v109 = 45;
                if (v277)
                  v109 = 43;
                v105(6, "%c[%{public}s %{public}s]:%i deauthorizing previously authed applet on different seid: %{public}@", v109, v274, v107, 462, v108);

              }
              v110 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v111 = NFSharedLogGetLogger(v110);
              v112 = objc_claimAutoreleasedReturnValue(v111);
              if (os_log_type_enabled(v112, OS_LOG_TYPE_DEFAULT))
              {
                v113 = object_getClass(*(id *)(a1 + 32));
                if (class_isMetaClass(v113))
                  v114 = 43;
                else
                  v114 = 45;
                v278 = v114;
                v275 = object_getClassName(*(id *)(a1 + 32));
                v115 = sel_getName(*(SEL *)(a1 + 64));
                v116 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "activeApplet"));
                *(_DWORD *)buf = 67110146;
                v291 = v278;
                v292 = 2082;
                v293 = v275;
                v294 = 2082;
                v295 = v115;
                v296 = 1024;
                v297 = 462;
                v298 = 2114;
                v299 = v116;
                _os_log_impl((void *)&_mh_execute_header, v112, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i deauthorizing previously authed applet on different seid: %{public}@", buf, 0x2Cu);

              }
              objc_msgSend(*(id *)(a1 + 32), "_deauthorize");
            }

            v98 = *(_BYTE **)(a1 + 32);
          }
        }
      }
      if (objc_msgSend(v98, "_requiresDeferredActivation:", v91))
      {
        objc_msgSend(*(id *)(a1 + 32), "setDeferredActivationApplet:", v91);
        v117 = objc_msgSend(*(id *)(a1 + 32), "setActiveApplet:", 0);
        v118 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v119 = NFLogGetLogger(v118);
        if (v119)
        {
          v120 = (void (*)(uint64_t, const char *, ...))v119;
          v121 = object_getClass(*(id *)(a1 + 32));
          v279 = class_isMetaClass(v121);
          v122 = object_getClassName(*(id *)(a1 + 32));
          v123 = sel_getName(*(SEL *)(a1 + 64));
          v124 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "deferredActivationApplet"));
          v125 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v124, "identifier"));
          v126 = 45;
          if (v279)
            v126 = 43;
          v120(6, "%c[%{public}s %{public}s]:%i Applet %{public}@ requires deferred activation", v126, v122, v123, 470, v125);

        }
        v127 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v128 = NFSharedLogGetLogger(v127);
        v129 = objc_claimAutoreleasedReturnValue(v128);
        if (os_log_type_enabled(v129, OS_LOG_TYPE_DEFAULT))
        {
          v130 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v130))
            v131 = 43;
          else
            v131 = 45;
          v280 = v131;
          v132 = object_getClassName(*(id *)(a1 + 32));
          v133 = sel_getName(*(SEL *)(a1 + 64));
          v134 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "deferredActivationApplet"));
          v135 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v134, "identifier"));
          *(_DWORD *)buf = 67110146;
          v291 = v280;
          v292 = 2082;
          v293 = v132;
          v294 = 2082;
          v295 = v133;
          v296 = 1024;
          v297 = 470;
          v298 = 2114;
          v299 = v135;
          _os_log_impl((void *)&_mh_execute_header, v129, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Applet %{public}@ requires deferred activation", buf, 0x2Cu);

        }
      }
      else
      {
        v158 = kdebug_trace(724566060, 0, 0, 0, 0);
        v159 = NFSharedSignpostLog(v158);
        v160 = objc_claimAutoreleasedReturnValue(v159);
        if (os_signpost_enabled(v160))
        {
          *(_WORD *)buf = 0;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v160, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "ACTIVATE_APPLET", "", buf, 2u);
        }

        v161 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "setActiveApplets:", v88));
        if (v161)
        {
          v21 = (id)v161;
          v162 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v163 = NFLogGetLogger(v162);
          if (v163)
          {
            v164 = (void (*)(uint64_t, const char *, ...))v163;
            v165 = object_getClass(*(id *)(a1 + 32));
            v166 = class_isMetaClass(v165);
            v262 = object_getClassName(*(id *)(a1 + 32));
            v266 = sel_getName(*(SEL *)(a1 + 64));
            v167 = 45;
            if (v166)
              v167 = 43;
            v164(3, "%c[%{public}s %{public}s]:%i Unable to setActiveApplets : error = %@", v167, v262, v266, 477, v21);
          }
          v168 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v169 = NFSharedLogGetLogger(v168);
          v150 = objc_claimAutoreleasedReturnValue(v169);
          if (os_log_type_enabled(v150, OS_LOG_TYPE_ERROR))
          {
            v170 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v170))
              v171 = 43;
            else
              v171 = 45;
            v172 = object_getClassName(*(id *)(a1 + 32));
            v173 = sel_getName(*(SEL *)(a1 + 64));
            *(_DWORD *)buf = 67110146;
            v291 = v171;
            v292 = 2082;
            v293 = v172;
            v294 = 2082;
            v295 = v173;
            v296 = 1024;
            v297 = 477;
            v298 = 2112;
            v299 = v21;
            _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unable to setActiveApplets : error = %@", buf, 0x2Cu);
          }
LABEL_95:

          v155 = *(_QWORD *)(a1 + 56);
          v156 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "activeApplet"));
          v157 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "activeKeyIdentifiers"));
          (*(void (**)(uint64_t, void *, void *, id))(v155 + 16))(v155, v156, v157, v21);

          objc_msgSend(*(id *)(a1 + 32), "startDefaultMode");
LABEL_170:

          goto LABEL_16;
        }
      }
    }
    v174 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "deferredActivationApplet"));

    if (v174)
    {
      v175 = *(_QWORD *)(a1 + 48);
      if (v175)
      {
        v176 = *(void **)(a1 + 32);
        v282[0] = _NSConcreteStackBlock;
        v282[1] = 3221225472;
        v282[2] = sub_100122CC4;
        v282[3] = &unk_1002E89D0;
        v177 = *(id *)(a1 + 56);
        v282[4] = *(_QWORD *)(a1 + 32);
        v283 = v177;
        objc_msgSend(v176, "_sync_startDeferredCardEmulationWithAuthorization:completion:", v175, v282);

LABEL_169:
        v21 = 0;
        goto LABEL_170;
      }
      v221 = *(_QWORD *)(a1 + 56);
      v222 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "deferredActivationApplet"));
LABEL_168:
      v259 = (void *)v222;
      v260 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "activeKeyIdentifiers"));
      (*(void (**)(uint64_t, void *, void *, _QWORD))(v221 + 16))(v221, v259, v260, 0);

      goto LABEL_169;
    }
    objc_msgSend(*(id *)(a1 + 32), "switchToSecureElementWrapperForApplet:", v91);
    v178 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v179 = NFLogGetLogger(v178);
    if (v179)
    {
      v180 = (void (*)(uint64_t, const char *, ...))v179;
      v181 = object_getClass(*(id *)(a1 + 32));
      v182 = class_isMetaClass(v181);
      v263 = object_getClassName(*(id *)(a1 + 32));
      v267 = sel_getName(*(SEL *)(a1 + 64));
      v183 = 45;
      if (v182)
        v183 = 43;
      v180(6, "%c[%{public}s %{public}s]:%i active = %{public}@", v183, v263, v267, 501, v91);
    }
    v184 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v185 = NFSharedLogGetLogger(v184);
    v186 = objc_claimAutoreleasedReturnValue(v185);
    if (os_log_type_enabled(v186, OS_LOG_TYPE_DEFAULT))
    {
      v187 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v187))
        v188 = 43;
      else
        v188 = 45;
      v189 = object_getClassName(*(id *)(a1 + 32));
      v190 = sel_getName(*(SEL *)(a1 + 64));
      *(_DWORD *)buf = 67110146;
      v291 = v188;
      v292 = 2082;
      v293 = v189;
      v294 = 2082;
      v295 = v190;
      v296 = 1024;
      v297 = 501;
      v298 = 2114;
      v299 = v91;
      _os_log_impl((void *)&_mh_execute_header, v186, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i active = %{public}@", buf, 0x2Cu);
    }

    if (*(_QWORD *)(a1 + 48))
    {
      v191 = kdebug_trace(724566064, 0, 0, 0, 0);
      v192 = NFSharedSignpostLog(v191);
      v193 = objc_claimAutoreleasedReturnValue(v192);
      if (os_signpost_enabled(v193))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v193, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "AUTHORIZE_APPLET", "", buf, 2u);
      }

      if ((objc_msgSend(*(id *)(a1 + 32), "_authorize:", *(_QWORD *)(a1 + 48)) & 1) == 0)
      {
        v238 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v239 = NFLogGetLogger(v238);
        if (v239)
        {
          v240 = (void (*)(uint64_t, const char *, ...))v239;
          v241 = object_getClass(*(id *)(a1 + 32));
          v242 = class_isMetaClass(v241);
          v243 = object_getClassName(*(id *)(a1 + 32));
          v270 = sel_getName(*(SEL *)(a1 + 64));
          v244 = 45;
          if (v242)
            v244 = 43;
          v240(3, "%c[%{public}s %{public}s]:%i Failed to authorize", v244, v243, v270, 508);
        }
        v245 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v246 = NFSharedLogGetLogger(v245);
        v247 = objc_claimAutoreleasedReturnValue(v246);
        if (os_log_type_enabled(v247, OS_LOG_TYPE_ERROR))
        {
          v248 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v248))
            v249 = 43;
          else
            v249 = 45;
          v250 = object_getClassName(*(id *)(a1 + 32));
          v251 = sel_getName(*(SEL *)(a1 + 64));
          *(_DWORD *)buf = 67109890;
          v291 = v249;
          v292 = 2082;
          v293 = v250;
          v294 = 2082;
          v295 = v251;
          v296 = 1024;
          v297 = 508;
          _os_log_impl((void *)&_mh_execute_header, v247, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to authorize", buf, 0x22u);
        }

        v212 = *(_QWORD *)(a1 + 56);
        v213 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "activeApplet"));
        v281 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "activeKeyIdentifiers"));
        v273 = objc_alloc((Class)NSError);
        v252 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v286[0] = NSLocalizedDescriptionKey;
        v276 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Commmand Error"));
        v287[0] = v276;
        v287[1] = &off_1002FF780;
        v286[1] = CFSTR("Line");
        v286[2] = CFSTR("Method");
        v271 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 64)));
        v287[2] = v271;
        v286[3] = NSDebugDescriptionErrorKey;
        v215 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 64)), 509);
        v287[3] = v215;
        v216 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v287, v286, 4));
        v217 = v273;
        v218 = v252;
        v219 = (void *)v252;
        v220 = 16;
        goto LABEL_161;
      }
      v194 = kdebug_trace(724566068, 0, 0, 0, 0);
      v195 = NFSharedSignpostLog(v194);
      v196 = objc_claimAutoreleasedReturnValue(v195);
      if (os_signpost_enabled(v196))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v196, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "START_PAYMENT_EMULATION", "", buf, 2u);
      }

      if ((objc_msgSend(*(id *)(a1 + 32), "startCardEmulationWithType:", objc_msgSend(*(id *)(a1 + 32), "defaultEmulationType")) & 1) == 0)
      {
        v197 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v198 = NFLogGetLogger(v197);
        if (v198)
        {
          v199 = (void (*)(uint64_t, const char *, ...))v198;
          v200 = object_getClass(*(id *)(a1 + 32));
          v201 = class_isMetaClass(v200);
          v202 = object_getClassName(*(id *)(a1 + 32));
          v268 = sel_getName(*(SEL *)(a1 + 64));
          v203 = 45;
          if (v201)
            v203 = 43;
          v199(3, "%c[%{public}s %{public}s]:%i Failed to start card emulation", v203, v202, v268, 518);
        }
        v204 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v205 = NFSharedLogGetLogger(v204);
        v206 = objc_claimAutoreleasedReturnValue(v205);
        if (os_log_type_enabled(v206, OS_LOG_TYPE_ERROR))
        {
          v207 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v207))
            v208 = 43;
          else
            v208 = 45;
          v209 = object_getClassName(*(id *)(a1 + 32));
          v210 = sel_getName(*(SEL *)(a1 + 64));
          *(_DWORD *)buf = 67109890;
          v291 = v208;
          v292 = 2082;
          v293 = v209;
          v294 = 2082;
          v295 = v210;
          v296 = 1024;
          v297 = 518;
          _os_log_impl((void *)&_mh_execute_header, v206, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to start card emulation", buf, 0x22u);
        }

        v211 = *(_BYTE **)(a1 + 32);
        if (v211[264])
        {
          objc_msgSend(v211, "_deauthorize");
          v211 = *(_BYTE **)(a1 + 32);
        }
        v212 = *(_QWORD *)(a1 + 56);
        v213 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v211, "activeApplet"));
        v281 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "activeKeyIdentifiers"));
        v272 = objc_alloc((Class)NSError);
        v214 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v284[0] = NSLocalizedDescriptionKey;
        v276 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
        v285[0] = v276;
        v285[1] = &off_1002FF798;
        v284[1] = CFSTR("Line");
        v284[2] = CFSTR("Method");
        v271 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 64)));
        v285[2] = v271;
        v284[3] = NSDebugDescriptionErrorKey;
        v215 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 64)), 522);
        v285[3] = v215;
        v216 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v285, v284, 4));
        v217 = v272;
        v218 = v214;
        v219 = (void *)v214;
        v220 = 15;
LABEL_161:
        v253 = objc_msgSend(v217, "initWithDomain:code:userInfo:", v218, v220, v216);
        (*(void (**)(uint64_t, void *, void *, id))(v212 + 16))(v212, v213, v281, v253);

        objc_msgSend(*(id *)(a1 + 32), "startDefaultMode");
        goto LABEL_169;
      }
    }
    else
    {
      v223 = *(_BYTE **)(a1 + 32);
      if (v223[264])
      {
        v224 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v225 = NFLogGetLogger(v224);
        if (v225)
        {
          v226 = (void (*)(uint64_t, const char *, ...))v225;
          v227 = object_getClass(*(id *)(a1 + 32));
          v228 = class_isMetaClass(v227);
          v229 = object_getClassName(*(id *)(a1 + 32));
          v269 = sel_getName(*(SEL *)(a1 + 64));
          v230 = 45;
          if (v228)
            v230 = 43;
          v226(6, "%c[%{public}s %{public}s]:%i Already authorized - staying in wired mode - need to call startCardEmulation or enable express", v230, v229, v269, 528);
        }
        v231 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v232 = NFSharedLogGetLogger(v231);
        v233 = objc_claimAutoreleasedReturnValue(v232);
        if (os_log_type_enabled(v233, OS_LOG_TYPE_DEFAULT))
        {
          v234 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v234))
            v235 = 43;
          else
            v235 = 45;
          v236 = object_getClassName(*(id *)(a1 + 32));
          v237 = sel_getName(*(SEL *)(a1 + 64));
          *(_DWORD *)buf = 67109890;
          v291 = v235;
          v292 = 2082;
          v293 = v236;
          v294 = 2082;
          v295 = v237;
          v296 = 1024;
          v297 = 528;
          _os_log_impl((void *)&_mh_execute_header, v233, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Already authorized - staying in wired mode - need to call startCardEmulation or enable express", buf, 0x22u);
        }

      }
      else
      {
        v254 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v223, "activeKeyIdentifiers"));

        v255 = *(void **)(a1 + 32);
        if (v254)
          objc_msgSend(v255, "startDefaultModeAndKeepSEOn:", 1);
        else
          objc_msgSend(v255, "startDefaultMode");
      }
    }
    v256 = kdebug_trace(724566152, 0, 0, 0, 0);
    v257 = NFSharedSignpostLog(v256);
    v258 = objc_claimAutoreleasedReturnValue(v257);
    if (os_signpost_enabled(v258))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v258, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLIENT_CALLBACK", "", buf, 2u);
    }

    v221 = *(_QWORD *)(a1 + 56);
    v222 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "activeApplet"));
    goto LABEL_168;
  }
  v2 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v3 = NFLogGetLogger(v2);
  if (v3)
  {
    v4 = (void (*)(uint64_t, const char *, ...))v3;
    v5 = object_getClass(*(id *)(a1 + 32));
    v6 = class_isMetaClass(v5);
    v7 = object_getClassName(*(id *)(a1 + 32));
    v8 = sel_getName(*(SEL *)(a1 + 64));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v10 = 45;
    if (v6)
      v10 = 43;
    v4(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v10, v7, v8, 413, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 64));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v291 = v15;
    v292 = 2082;
    v293 = v16;
    v294 = 2082;
    v295 = v17;
    v296 = 1024;
    v297 = 413;
    v298 = 2114;
    v299 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v19 = *(_QWORD *)(a1 + 56);
  if (v19)
  {
    v20 = objc_alloc((Class)NSError);
    v21 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v306[0] = NSLocalizedDescriptionKey;
    v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v307[0] = v22;
    v307[1] = &off_1002FF720;
    v306[1] = CFSTR("Line");
    v306[2] = CFSTR("Method");
    v23 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 64)));
    v307[2] = v23;
    v306[3] = NSDebugDescriptionErrorKey;
    v24 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 64)), 413);
    v307[3] = v24;
    v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v307, v306, 4));
    v26 = v20;
    v27 = v21;
    v28 = 54;
LABEL_15:
    v29 = objc_msgSend(v26, "initWithDomain:code:userInfo:", v27, v28, v25);
    (*(void (**)(uint64_t, _QWORD, _QWORD, id))(v19 + 16))(v19, 0, 0, v29);

LABEL_16:
  }
}

void sub_100122CC4(uint64_t a1, void *a2)
{
  uint64_t v3;
  void *v4;
  id v5;
  void *v6;
  id v7;

  v4 = *(void **)(a1 + 32);
  v3 = *(_QWORD *)(a1 + 40);
  v5 = a2;
  v7 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "deferredActivationApplet"));
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "activeKeyIdentifiers"));
  (*(void (**)(uint64_t, id, void *, id))(v3 + 16))(v3, v7, v6, v5);

}

void sub_100122ECC(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  uint64_t v19;
  id v20;
  void *v21;
  void *v22;
  void *v23;
  id v24;
  unsigned __int8 *v25;
  int v26;
  void *v27;
  uint64_t v28;
  void (*v29)(uint64_t, const char *, ...);
  objc_class *v30;
  _BOOL4 v31;
  const char *v32;
  uint64_t v33;
  void *v34;
  uint64_t v35;
  NSObject *v36;
  objc_class *v37;
  int v38;
  const char *v39;
  const char *v40;
  uint64_t v41;
  id v42;
  void *v43;
  void *v44;
  void *v45;
  id v46;
  void *v47;
  void *v48;
  uint64_t v49;
  void (*v50)(uint64_t, const char *, ...);
  objc_class *v51;
  _BOOL4 v52;
  const char *v53;
  const char *v54;
  void *v55;
  uint64_t v56;
  void *v57;
  uint64_t v58;
  NSObject *v59;
  objc_class *v60;
  int v61;
  const char *v62;
  const char *v63;
  void *v64;
  const char *v65;
  NSErrorUserInfoKey v66;
  void *v67;
  NSErrorUserInfoKey v68;
  void *v69;
  uint8_t buf[4];
  int v71;
  __int16 v72;
  const char *v73;
  __int16 v74;
  const char *v75;
  __int16 v76;
  int v77;
  __int16 v78;
  void *v79;

  if (!objc_msgSend(*(id *)(a1 + 32), "didStart")
    || (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) != 0
    || objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      v10 = 45;
      if (isMetaClass)
        v10 = 43;
      v4(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v10, ClassName, Name, 554, v9);

    }
    v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v12 = NFSharedLogGetLogger(v11);
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v14 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v14))
        v15 = 43;
      else
        v15 = 45;
      v16 = object_getClassName(*(id *)(a1 + 32));
      v17 = sel_getName(*(SEL *)(a1 + 56));
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      *(_DWORD *)buf = 67110146;
      v71 = v15;
      v72 = 2082;
      v73 = v16;
      v74 = 2082;
      v75 = v17;
      v76 = 1024;
      v77 = 554;
      v78 = 2114;
      v79 = v18;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

    }
    v19 = *(_QWORD *)(a1 + 48);
    if (v19)
    {
      v20 = objc_alloc((Class)NSError);
      v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v68 = NSLocalizedDescriptionKey;
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
      v69 = v22;
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v69, &v68, 1));
      v24 = objc_msgSend(v20, "initWithDomain:code:userInfo:", v21, 54, v23);
      (*(void (**)(uint64_t, id))(v19 + 16))(v19, v24);

    }
  }
  else
  {
    v25 = (unsigned __int8 *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "expressModeManager"));
    if (v25 && (v26 = v25[172], v25, v26))
    {
      v27 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v28 = NFLogGetLogger(v27);
      if (v28)
      {
        v29 = (void (*)(uint64_t, const char *, ...))v28;
        v30 = object_getClass(*(id *)(a1 + 32));
        v31 = class_isMetaClass(v30);
        v32 = object_getClassName(*(id *)(a1 + 32));
        v65 = sel_getName(*(SEL *)(a1 + 56));
        v33 = 45;
        if (v31)
          v33 = 43;
        v29(4, "%c[%{public}s %{public}s]:%i Express mode in progress, denying..", v33, v32, v65, 557);
      }
      v34 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v35 = NFSharedLogGetLogger(v34);
      v36 = objc_claimAutoreleasedReturnValue(v35);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      {
        v37 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v37))
          v38 = 43;
        else
          v38 = 45;
        v39 = object_getClassName(*(id *)(a1 + 32));
        v40 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)buf = 67109890;
        v71 = v38;
        v72 = 2082;
        v73 = v39;
        v74 = 2082;
        v75 = v40;
        v76 = 1024;
        v77 = 557;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Express mode in progress, denying..", buf, 0x22u);
      }

      v41 = *(_QWORD *)(a1 + 48);
      v42 = objc_alloc((Class)NSError);
      v43 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v66 = NSLocalizedDescriptionKey;
      v44 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Express Mode in progress"));
      v67 = v44;
      v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v67, &v66, 1));
      v46 = objc_msgSend(v42, "initWithDomain:code:userInfo:", v43, 38, v45);
      (*(void (**)(uint64_t, id))(v41 + 16))(v41, v46);

    }
    else
    {
      v47 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "deferredActivationApplet"));

      if (v47)
      {
        v48 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v49 = NFLogGetLogger(v48);
        if (v49)
        {
          v50 = (void (*)(uint64_t, const char *, ...))v49;
          v51 = object_getClass(*(id *)(a1 + 32));
          v52 = class_isMetaClass(v51);
          v53 = object_getClassName(*(id *)(a1 + 32));
          v54 = sel_getName(*(SEL *)(a1 + 56));
          v55 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "deferredActivationApplet"));
          v56 = 45;
          if (v52)
            v56 = 43;
          v50(6, "%c[%{public}s %{public}s]:%i Applet requires deferred activation: %{public}@", v56, v53, v54, 560, v55);

        }
        v57 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v58 = NFSharedLogGetLogger(v57);
        v59 = objc_claimAutoreleasedReturnValue(v58);
        if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
        {
          v60 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v60))
            v61 = 43;
          else
            v61 = 45;
          v62 = object_getClassName(*(id *)(a1 + 32));
          v63 = sel_getName(*(SEL *)(a1 + 56));
          v64 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "deferredActivationApplet"));
          *(_DWORD *)buf = 67110146;
          v71 = v61;
          v72 = 2082;
          v73 = v62;
          v74 = 2082;
          v75 = v63;
          v76 = 1024;
          v77 = 560;
          v78 = 2114;
          v79 = v64;
          _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Applet requires deferred activation: %{public}@", buf, 0x2Cu);

        }
        objc_msgSend(*(id *)(a1 + 32), "_sync_startDeferredCardEmulationWithAuthorization:completion:", *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48));
      }
      else
      {
        objc_msgSend(*(id *)(a1 + 32), "_performAuthAndStartCardEmulation:fromDeferred:completion:", *(_QWORD *)(a1 + 40), 0, *(_QWORD *)(a1 + 48));
      }
    }
  }
}

void sub_100123EC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,id location)
{
  id *v21;

  objc_destroyWeak(v21);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100123F04(uint64_t a1)
{
  NSObject *v2;
  id WeakRetained;
  os_activity_scope_state_s v4;

  v2 = _os_activity_create((void *)&_mh_execute_header, "com.apple.nfcd.txn.deferredAuthTimer", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  v4.opaque[0] = 0;
  v4.opaque[1] = 0;
  os_activity_scope_enter(v2, &v4);
  os_activity_scope_leave(&v4);

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  objc_msgSend(WeakRetained, "handleDeferredAuthTimeout");

}

void sub_100124054(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  uint64_t v19;
  id v20;
  void *v21;
  void *v22;
  void *v23;
  id v24;
  NSErrorUserInfoKey v25;
  void *v26;
  uint8_t buf[4];
  int v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  void *v36;

  if (!objc_msgSend(*(id *)(a1 + 32), "didStart")
    || (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) != 0
    || objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      v10 = 45;
      if (isMetaClass)
        v10 = 43;
      v4(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v10, ClassName, Name, 639, v9);

    }
    v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v12 = NFSharedLogGetLogger(v11);
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v14 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v14))
        v15 = 43;
      else
        v15 = 45;
      v16 = object_getClassName(*(id *)(a1 + 32));
      v17 = sel_getName(*(SEL *)(a1 + 56));
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      *(_DWORD *)buf = 67110146;
      v28 = v15;
      v29 = 2082;
      v30 = v16;
      v31 = 2082;
      v32 = v17;
      v33 = 1024;
      v34 = 639;
      v35 = 2114;
      v36 = v18;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

    }
    v19 = *(_QWORD *)(a1 + 48);
    if (v19)
    {
      v20 = objc_alloc((Class)NSError);
      v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v25 = NSLocalizedDescriptionKey;
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
      v26 = v22;
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v26, &v25, 1));
      v24 = objc_msgSend(v20, "initWithDomain:code:userInfo:", v21, 54, v23);
      (*(void (**)(uint64_t, id))(v19 + 16))(v19, v24);

    }
  }
  else
  {
    objc_msgSend(*(id *)(a1 + 32), "_sync_startDeferredCardEmulationWithAuthorization:completion:", *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48));
  }
}

void sub_1001243F0(uint64_t a1)
{
  void *v2;
  void *v3;
  id v4;
  void *v5;
  unsigned int v6;
  void *v7;
  uint64_t v8;
  void (*v9)(uint64_t, const char *, ...);
  objc_class *v10;
  _BOOL4 v11;
  const char *v12;
  const char *v13;
  void *v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  NSObject *v18;
  objc_class *v19;
  int v20;
  const char *v21;
  const char *v22;
  void (**v23)(id, id);
  void (**v24)(id, id);
  id v25;
  void *v26;
  void *v27;
  id v28;
  id v29;
  void *v30;
  id v31;
  void *specific;
  uint64_t Logger;
  void (*v34)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  uint64_t v39;
  void *v40;
  uint64_t v41;
  NSObject *v42;
  objc_class *v43;
  int v44;
  const char *v45;
  const char *v46;
  int v47;
  _BYTE *v48;
  void *v49;
  void *v50;
  id v51;
  void *v52;
  unsigned __int8 v53;
  void *v54;
  uint64_t v55;
  void (*v56)(uint64_t, const char *, ...);
  objc_class *v57;
  _BOOL4 v58;
  const char *v59;
  uint64_t v60;
  void *v61;
  uint64_t v62;
  NSObject *v63;
  objc_class *v64;
  int v65;
  const char *v66;
  const char *v67;
  id v68;
  void *v69;
  void *v70;
  id v71;
  id v72;
  void *v73;
  void *v74;
  void *v75;
  void *v76;
  uint64_t v77;
  void (*v78)(uint64_t, const char *, ...);
  objc_class *v79;
  _BOOL4 v80;
  const char *v81;
  uint64_t v82;
  void *v83;
  uint64_t v84;
  NSObject *v85;
  objc_class *v86;
  int v87;
  const char *v88;
  const char *v89;
  id v90;
  void *v91;
  void *v92;
  id v93;
  id v94;
  void *v95;
  int v96;
  void *v97;
  void *v98;
  unsigned __int8 v99;
  void *v100;
  uint64_t v101;
  void (*v102)(uint64_t, const char *, ...);
  objc_class *v103;
  _BOOL4 v104;
  const char *v105;
  uint64_t v106;
  void *v107;
  uint64_t v108;
  NSObject *v109;
  objc_class *v110;
  int v111;
  const char *v112;
  const char *v113;
  void *v114;
  void *v115;
  uint64_t v116;
  void *v117;
  id v118;
  void *v119;
  uint64_t v120;
  void (*v121)(uint64_t, const char *, ...);
  objc_class *v122;
  _BOOL4 v123;
  uint64_t v124;
  void *v125;
  uint64_t v126;
  NSObject *v127;
  objc_class *v128;
  int v129;
  const char *v130;
  const char *v131;
  void *v132;
  void *v133;
  uint64_t v134;
  void *v135;
  id v136;
  void *v137;
  uint64_t v138;
  void (*v139)(uint64_t, const char *, ...);
  objc_class *v140;
  _BOOL4 v141;
  uint64_t v142;
  void *v143;
  uint64_t v144;
  objc_class *v145;
  int v146;
  const char *v147;
  const char *v148;
  id v149;
  id v150;
  _BYTE *v151;
  void *v152;
  uint64_t v153;
  void (*v154)(uint64_t, const char *, ...);
  objc_class *v155;
  _BOOL4 v156;
  const char *v157;
  uint64_t v158;
  void *v159;
  uint64_t v160;
  NSObject *v161;
  objc_class *v162;
  int v163;
  const char *v164;
  const char *v165;
  id v166;
  void *v167;
  void *v168;
  id v169;
  id v170;
  void *v171;
  const char *v172;
  const char *v173;
  const char *v174;
  const char *v175;
  const char *v176;
  const char *v177;
  const char *v178;
  const char *v179;
  char v180;
  _QWORD v181[4];
  _QWORD v182[4];
  _QWORD v183[4];
  _QWORD v184[4];
  _QWORD v185[4];
  _QWORD v186[4];
  _QWORD v187[4];
  _QWORD v188[4];
  uint8_t buf[4];
  int v190;
  __int16 v191;
  const char *v192;
  __int16 v193;
  const char *v194;
  __int16 v195;
  int v196;
  __int16 v197;
  void (**v198)(id, id);

  v2 = (void *)objc_claimAutoreleasedReturnValue(+[_NFHardwareManager sharedHardwareManager](_NFHardwareManager, "sharedHardwareManager"));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "driverWrapper"));
  v4 = sub_1001F8494(v3);
  v5 = (void *)objc_claimAutoreleasedReturnValue(v4);

  v6 = objc_msgSend(v5, "fdOn");
  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v34 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      v39 = 45;
      if (isMetaClass)
        v39 = 43;
      v34(6, "%c[%{public}s %{public}s]:%i %d", v39, ClassName, Name, 657, *(unsigned __int8 *)(a1 + 56));
    }
    v40 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v41 = NFSharedLogGetLogger(v40);
    v42 = objc_claimAutoreleasedReturnValue(v41);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      v43 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v43))
        v44 = 43;
      else
        v44 = 45;
      v45 = object_getClassName(*(id *)(a1 + 32));
      v46 = sel_getName(*(SEL *)(a1 + 48));
      v47 = *(unsigned __int8 *)(a1 + 56);
      *(_DWORD *)buf = 67110146;
      v190 = v44;
      v191 = 2082;
      v192 = v45;
      v193 = 2082;
      v194 = v46;
      v195 = 1024;
      v196 = 657;
      v197 = 1024;
      LODWORD(v198) = v47;
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %d", buf, 0x28u);
    }

    v48 = *(_BYTE **)(a1 + 32);
    if (v48[280])
    {
      v49 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v48, "activeApplet"));

      if (!v49)
      {
        if (!v6)
        {
          v96 = 0;
LABEL_56:
          v97 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "secureElementWrapper"));
          v98 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v97, "handle"));
          v99 = objc_msgSend(v98, "enableGreenCarThreshold:", *(_BYTE *)(a1 + 56) == 0);

          if ((v99 & 1) == 0)
          {
            v100 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v101 = NFLogGetLogger(v100);
            if (v101)
            {
              v102 = (void (*)(uint64_t, const char *, ...))v101;
              v103 = object_getClass(*(id *)(a1 + 32));
              v104 = class_isMetaClass(v103);
              v105 = object_getClassName(*(id *)(a1 + 32));
              v176 = sel_getName(*(SEL *)(a1 + 48));
              v106 = 45;
              if (v104)
                v106 = 43;
              v102(6, "%c[%{public}s %{public}s]:%i Failed to configure GC logic", v106, v105, v176, 687);
            }
            v107 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v108 = NFSharedLogGetLogger(v107);
            v109 = objc_claimAutoreleasedReturnValue(v108);
            if (os_log_type_enabled(v109, OS_LOG_TYPE_DEFAULT))
            {
              v110 = object_getClass(*(id *)(a1 + 32));
              if (class_isMetaClass(v110))
                v111 = 43;
              else
                v111 = 45;
              v112 = object_getClassName(*(id *)(a1 + 32));
              v113 = sel_getName(*(SEL *)(a1 + 48));
              *(_DWORD *)buf = 67109890;
              v190 = v111;
              v191 = 2082;
              v192 = v112;
              v193 = 2082;
              v194 = v113;
              v195 = 1024;
              v196 = 687;
              _os_log_impl((void *)&_mh_execute_header, v109, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Failed to configure GC logic", buf, 0x22u);
            }

          }
          v114 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "activeApplet"));

          if (v114
            && (v115 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "secureElementWrapper")),
                v116 = *(unsigned __int8 *)(a1 + 56),
                v117 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "activeApplet")),
                v118 = sub_100239BA4(v115, v116, v117),
                v24 = (void (**)(id, id))objc_claimAutoreleasedReturnValue(v118),
                v117,
                v115,
                v24))
          {
            v119 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v120 = NFLogGetLogger(v119);
            if (v120)
            {
              v121 = (void (*)(uint64_t, const char *, ...))v120;
              v122 = object_getClass(*(id *)(a1 + 32));
              v123 = class_isMetaClass(v122);
              v172 = object_getClassName(*(id *)(a1 + 32));
              v177 = sel_getName(*(SEL *)(a1 + 48));
              v124 = 45;
              if (v123)
                v124 = 43;
              v121(6, "%c[%{public}s %{public}s]:%i Failed to configure plasticCardModeForApplet: %{public}@", v124, v172, v177, 693, v24);
            }
            v125 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v126 = NFSharedLogGetLogger(v125);
            v127 = objc_claimAutoreleasedReturnValue(v126);
            if (!os_log_type_enabled(v127, OS_LOG_TYPE_DEFAULT))
            {
LABEL_90:

              if ((v96 & 1) == 0)
              {
LABEL_92:
                (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
                if (!*(_BYTE *)(a1 + 56))
                  goto LABEL_16;
                +[NFGeneralStatisticsCALogger updateAnalyticsGeneralTransactionStatistics:](NFGeneralStatisticsCALogger, "updateAnalyticsGeneralTransactionStatistics:", &off_100306650);
                v150 = objc_msgSend(*(id *)(a1 + 32), "plasticCardMode");
                v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "activeApplet"));
                v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v26, "identifier"));
                +[NFGeneralStatisticsCALogger postPlasticCardEnableStatus:aid:](NFGeneralStatisticsCALogger, "postPlasticCardEnableStatus:aid:", v150, v27);
                goto LABEL_15;
              }
LABEL_91:
              v149 = objc_msgSend(v2, "setRoutingConfig:", v5);
              goto LABEL_92;
            }
            v128 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v128))
              v129 = 43;
            else
              v129 = 45;
            v130 = object_getClassName(*(id *)(a1 + 32));
            v131 = sel_getName(*(SEL *)(a1 + 48));
            *(_DWORD *)buf = 67110146;
            v190 = v129;
            v191 = 2082;
            v192 = v130;
            v193 = 2082;
            v194 = v131;
            v195 = 1024;
            v196 = 693;
            v197 = 2114;
            v198 = v24;
          }
          else
          {
            v132 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "deferredActivationApplet"));

            if (!v132
              || (v133 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "secureElementWrapper")),
                  v134 = *(unsigned __int8 *)(a1 + 56),
                  v135 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "deferredActivationApplet")),
                  v136 = sub_100239BA4(v133, v134, v135),
                  v24 = (void (**)(id, id))objc_claimAutoreleasedReturnValue(v136),
                  v135,
                  v133,
                  !v24))
            {
              objc_msgSend(*(id *)(a1 + 32), "setPlasticCardMode:", *(unsigned __int8 *)(a1 + 56));
              v151 = *(_BYTE **)(a1 + 32);
              if (v151[264])
              {
                if ((objc_msgSend(v151, "startCardEmulationWithType:", 2) & 1) != 0)
                {
                  v24 = 0;
                  goto LABEL_92;
                }
                v152 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                v153 = NFLogGetLogger(v152);
                if (v153)
                {
                  v154 = (void (*)(uint64_t, const char *, ...))v153;
                  v155 = object_getClass(*(id *)(a1 + 32));
                  v156 = class_isMetaClass(v155);
                  v157 = object_getClassName(*(id *)(a1 + 32));
                  v179 = sel_getName(*(SEL *)(a1 + 48));
                  v158 = 45;
                  if (v156)
                    v158 = 43;
                  v154(3, "%c[%{public}s %{public}s]:%i Failed to restore emulation after enabling plastic card mode", v158, v157, v179, 711);
                }
                v180 = v96;
                v159 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                v160 = NFSharedLogGetLogger(v159);
                v161 = objc_claimAutoreleasedReturnValue(v160);
                if (os_log_type_enabled(v161, OS_LOG_TYPE_ERROR))
                {
                  v162 = object_getClass(*(id *)(a1 + 32));
                  if (class_isMetaClass(v162))
                    v163 = 43;
                  else
                    v163 = 45;
                  v164 = object_getClassName(*(id *)(a1 + 32));
                  v165 = sel_getName(*(SEL *)(a1 + 48));
                  *(_DWORD *)buf = 67109890;
                  v190 = v163;
                  v191 = 2082;
                  v192 = v164;
                  v193 = 2082;
                  v194 = v165;
                  v195 = 1024;
                  v196 = 711;
                  _os_log_impl((void *)&_mh_execute_header, v161, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to restore emulation after enabling plastic card mode", buf, 0x22u);
                }

                v166 = objc_alloc((Class)NSError);
                v167 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
                v181[0] = NSLocalizedDescriptionKey;
                v168 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
                v182[0] = v168;
                v182[1] = &off_1002FF7F8;
                v181[1] = CFSTR("Line");
                v181[2] = CFSTR("Method");
                v169 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 48)));
                v182[2] = v169;
                v181[3] = NSDebugDescriptionErrorKey;
                v170 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 48)), 712);
                v182[3] = v170;
                v171 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v182, v181, 4));
                v24 = (void (**)(id, id))objc_msgSend(v166, "initWithDomain:code:userInfo:", v167, 15, v171);

                if ((v180 & 1) == 0)
                  goto LABEL_92;
              }
              else
              {
                v24 = 0;
                if (!v96)
                  goto LABEL_92;
              }
              goto LABEL_91;
            }
            v137 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v138 = NFLogGetLogger(v137);
            if (v138)
            {
              v139 = (void (*)(uint64_t, const char *, ...))v138;
              v140 = object_getClass(*(id *)(a1 + 32));
              v141 = class_isMetaClass(v140);
              v173 = object_getClassName(*(id *)(a1 + 32));
              v178 = sel_getName(*(SEL *)(a1 + 48));
              v142 = 45;
              if (v141)
                v142 = 43;
              v139(6, "%c[%{public}s %{public}s]:%i Failed to configure plasticCardModeForApplet: %{public}@", v142, v173, v178, 701, v24);
            }
            v143 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v144 = NFSharedLogGetLogger(v143);
            v127 = objc_claimAutoreleasedReturnValue(v144);
            if (!os_log_type_enabled(v127, OS_LOG_TYPE_DEFAULT))
              goto LABEL_90;
            v145 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v145))
              v146 = 43;
            else
              v146 = 45;
            v147 = object_getClassName(*(id *)(a1 + 32));
            v148 = sel_getName(*(SEL *)(a1 + 48));
            *(_DWORD *)buf = 67110146;
            v190 = v146;
            v191 = 2082;
            v192 = v147;
            v193 = 2082;
            v194 = v148;
            v195 = 1024;
            v196 = 701;
            v197 = 2114;
            v198 = v24;
          }
          _os_log_impl((void *)&_mh_execute_header, v127, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Failed to configure plasticCardModeForApplet: %{public}@", buf, 0x2Cu);
          goto LABEL_90;
        }
        goto LABEL_43;
      }
      v48 = *(_BYTE **)(a1 + 32);
    }
    if ((objc_msgSend(v48, "startWiredMode") & 1) == 0)
    {
      v54 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v55 = NFLogGetLogger(v54);
      if (v55)
      {
        v56 = (void (*)(uint64_t, const char *, ...))v55;
        v57 = object_getClass(*(id *)(a1 + 32));
        v58 = class_isMetaClass(v57);
        v59 = object_getClassName(*(id *)(a1 + 32));
        v174 = sel_getName(*(SEL *)(a1 + 48));
        v60 = 45;
        if (v58)
          v60 = 43;
        v56(3, "%c[%{public}s %{public}s]:%i Failed to set wired mode", v60, v59, v174, 665);
      }
      v61 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v62 = NFSharedLogGetLogger(v61);
      v63 = objc_claimAutoreleasedReturnValue(v62);
      if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
      {
        v64 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v64))
          v65 = 43;
        else
          v65 = 45;
        v66 = object_getClassName(*(id *)(a1 + 32));
        v67 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)buf = 67109890;
        v190 = v65;
        v191 = 2082;
        v192 = v66;
        v193 = 2082;
        v194 = v67;
        v195 = 1024;
        v196 = 665;
        _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to set wired mode", buf, 0x22u);
      }

      v68 = objc_alloc((Class)NSError);
      v69 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v185[0] = NSLocalizedDescriptionKey;
      v70 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
      v186[0] = v70;
      v186[1] = &off_1002FF7C8;
      v185[1] = CFSTR("Line");
      v185[2] = CFSTR("Method");
      v71 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 48)));
      v186[2] = v71;
      v185[3] = NSDebugDescriptionErrorKey;
      v72 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 48)), 666);
      v186[3] = v72;
      v73 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v186, v185, 4));
      v24 = (void (**)(id, id))objc_msgSend(v68, "initWithDomain:code:userInfo:", v69, 15, v73);

      goto LABEL_92;
    }
    v50 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "driverWrapper"));
    v51 = sub_1001F8494(v50);
    v52 = (void *)objc_claimAutoreleasedReturnValue(v51);
    v53 = objc_msgSend(v52, "fdOn");

    if ((v53 & 1) == 0)
    {
LABEL_54:
      v96 = 1;
      goto LABEL_56;
    }
LABEL_43:
    v74 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "cloneWithFieldDetect:", 0));
    v75 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "setRoutingConfig:", v74));

    if (v75)
    {
      v76 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v77 = NFLogGetLogger(v76);
      if (v77)
      {
        v78 = (void (*)(uint64_t, const char *, ...))v77;
        v79 = object_getClass(*(id *)(a1 + 32));
        v80 = class_isMetaClass(v79);
        v81 = object_getClassName(*(id *)(a1 + 32));
        v175 = sel_getName(*(SEL *)(a1 + 48));
        v82 = 45;
        if (v80)
          v82 = 43;
        v78(6, "%c[%{public}s %{public}s]:%i Failed to disable FD.", v82, v81, v175, 679);
      }
      v83 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v84 = NFSharedLogGetLogger(v83);
      v85 = objc_claimAutoreleasedReturnValue(v84);
      if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT))
      {
        v86 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v86))
          v87 = 43;
        else
          v87 = 45;
        v88 = object_getClassName(*(id *)(a1 + 32));
        v89 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)buf = 67109890;
        v190 = v87;
        v191 = 2082;
        v192 = v88;
        v193 = 2082;
        v194 = v89;
        v195 = 1024;
        v196 = 679;
        _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Failed to disable FD.", buf, 0x22u);
      }

      v90 = objc_alloc((Class)NSError);
      v91 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v183[0] = NSLocalizedDescriptionKey;
      v92 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
      v184[0] = v92;
      v184[1] = &off_1002FF7E0;
      v183[1] = CFSTR("Line");
      v183[2] = CFSTR("Method");
      v93 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 48)));
      v184[2] = v93;
      v183[3] = NSDebugDescriptionErrorKey;
      v94 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 48)), 680);
      v184[3] = v94;
      v95 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v184, v183, 4));
      v24 = (void (**)(id, id))objc_msgSend(v90, "initWithDomain:code:userInfo:", v91, 15, v95);

      goto LABEL_91;
    }
    goto LABEL_54;
  }
  v7 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v8 = NFLogGetLogger(v7);
  if (v8)
  {
    v9 = (void (*)(uint64_t, const char *, ...))v8;
    v10 = object_getClass(*(id *)(a1 + 32));
    v11 = class_isMetaClass(v10);
    v12 = object_getClassName(*(id *)(a1 + 32));
    v13 = sel_getName(*(SEL *)(a1 + 48));
    v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v15 = 45;
    if (v11)
      v15 = 43;
    v9(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v15, v12, v13, 655, v14);

  }
  v16 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v17 = NFSharedLogGetLogger(v16);
  v18 = objc_claimAutoreleasedReturnValue(v17);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    v19 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v19))
      v20 = 43;
    else
      v20 = 45;
    v21 = object_getClassName(*(id *)(a1 + 32));
    v22 = sel_getName(*(SEL *)(a1 + 48));
    v23 = (void (**)(id, id))objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v190 = v20;
    v191 = 2082;
    v192 = v21;
    v193 = 2082;
    v194 = v22;
    v195 = 1024;
    v196 = 655;
    v197 = 2114;
    v198 = v23;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v24 = *(void (***)(id, id))(a1 + 40);
  if (v24)
  {
    v25 = objc_alloc((Class)NSError);
    v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v187[0] = NSLocalizedDescriptionKey;
    v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v188[0] = v27;
    v188[1] = &off_1002FF7B0;
    v187[1] = CFSTR("Line");
    v187[2] = CFSTR("Method");
    v28 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 48)));
    v188[2] = v28;
    v187[3] = NSDebugDescriptionErrorKey;
    v29 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 48)), 655);
    v188[3] = v29;
    v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v188, v187, 4));
    v31 = objc_msgSend(v25, "initWithDomain:code:userInfo:", v26, 54, v30);
    v24[2](v24, v31);

    v24 = 0;
LABEL_15:

  }
LABEL_16:

}

void sub_1001255E0(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  void *v19;
  uint64_t v20;
  void (*v21)(uint64_t, const char *, ...);
  objc_class *v22;
  _BOOL4 v23;
  const char *v24;
  const char *v25;
  void *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  NSObject *v30;
  objc_class *v31;
  int v32;
  const char *v33;
  const char *v34;
  void *v35;
  uint64_t v36;
  id v37;
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  uint64_t v43;
  id v44;
  void *v45;
  void *v46;
  uint64_t v47;
  void (*v48)(uint64_t, const char *, ...);
  objc_class *v49;
  _BOOL4 v50;
  const char *v51;
  uint64_t v52;
  void *v53;
  uint64_t v54;
  NSObject *v55;
  objc_class *v56;
  int v57;
  const char *v58;
  const char *v59;
  uint64_t v60;
  id v61;
  void *v62;
  void *v63;
  void *v64;
  id v65;
  void *v66;
  unsigned __int8 v67;
  id v68;
  const char *v69;
  NSErrorUserInfoKey v70;
  void *v71;
  NSErrorUserInfoKey v72;
  void *v73;
  NSErrorUserInfoKey v74;
  void *v75;
  uint8_t buf[4];
  int v77;
  __int16 v78;
  const char *v79;
  __int16 v80;
  const char *v81;
  __int16 v82;
  int v83;
  __int16 v84;
  void *v85;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v10 = 45;
    if (isMetaClass)
      v10 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@", v10, ClassName, Name, 734, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 48));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    *(_DWORD *)buf = 67110146;
    v77 = v15;
    v78 = 2082;
    v79 = v16;
    v80 = 2082;
    v81 = v17;
    v82 = 1024;
    v83 = 734;
    v84 = 2114;
    v85 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);

  }
  if (!objc_msgSend(*(id *)(a1 + 32), "didStart")
    || (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) != 0
    || objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v20 = NFLogGetLogger(v19);
    if (v20)
    {
      v21 = (void (*)(uint64_t, const char *, ...))v20;
      v22 = object_getClass(*(id *)(a1 + 32));
      v23 = class_isMetaClass(v22);
      v24 = object_getClassName(*(id *)(a1 + 32));
      v25 = sel_getName(*(SEL *)(a1 + 48));
      v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      v27 = 45;
      if (v23)
        v27 = 43;
      v21(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v27, v24, v25, 736, v26);

    }
    v28 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v29 = NFSharedLogGetLogger(v28);
    v30 = objc_claimAutoreleasedReturnValue(v29);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      v31 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v31))
        v32 = 43;
      else
        v32 = 45;
      v33 = object_getClassName(*(id *)(a1 + 32));
      v34 = sel_getName(*(SEL *)(a1 + 48));
      v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      *(_DWORD *)buf = 67110146;
      v77 = v32;
      v78 = 2082;
      v79 = v33;
      v80 = 2082;
      v81 = v34;
      v82 = 1024;
      v83 = 736;
      v84 = 2114;
      v85 = v35;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

    }
    v36 = *(_QWORD *)(a1 + 40);
    if (v36)
    {
      v37 = objc_alloc((Class)NSError);
      v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v74 = NSLocalizedDescriptionKey;
      v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
      v75 = v39;
      v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v75, &v74, 1));
      v41 = v37;
      v42 = v38;
      v43 = 54;
LABEL_24:
      v44 = objc_msgSend(v41, "initWithDomain:code:userInfo:", v42, v43, v40);
      (*(void (**)(uint64_t, id))(v36 + 16))(v36, v44);

    }
  }
  else
  {
    v45 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "activeApplet"));

    if (!v45)
    {
      v66 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "expressModeManager"));
      sub_10003D1FC((uint64_t)v66);

      v67 = objc_msgSend(*(id *)(a1 + 32), "startCardEmulationWithType:", 8);
      v36 = *(_QWORD *)(a1 + 40);
      if ((v67 & 1) != 0)
      {
        (*(void (**)(uint64_t, _QWORD))(v36 + 16))(v36, 0);
        return;
      }
      v68 = objc_alloc((Class)NSError);
      v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v70 = NSLocalizedDescriptionKey;
      v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unknown Error"));
      v71 = v39;
      v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v71, &v70, 1));
      v41 = v68;
      v42 = v38;
      v43 = 6;
      goto LABEL_24;
    }
    v46 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v47 = NFLogGetLogger(v46);
    if (v47)
    {
      v48 = (void (*)(uint64_t, const char *, ...))v47;
      v49 = object_getClass(*(id *)(a1 + 32));
      v50 = class_isMetaClass(v49);
      v51 = object_getClassName(*(id *)(a1 + 32));
      v69 = sel_getName(*(SEL *)(a1 + 48));
      v52 = 45;
      if (v50)
        v52 = 43;
      v48(3, "%c[%{public}s %{public}s]:%i Can not start express mode when an applet is selected", v52, v51, v69, 739);
    }
    v53 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v54 = NFSharedLogGetLogger(v53);
    v55 = objc_claimAutoreleasedReturnValue(v54);
    if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
    {
      v56 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v56))
        v57 = 43;
      else
        v57 = 45;
      v58 = object_getClassName(*(id *)(a1 + 32));
      v59 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)buf = 67109890;
      v77 = v57;
      v78 = 2082;
      v79 = v58;
      v80 = 2082;
      v81 = v59;
      v82 = 1024;
      v83 = 739;
      _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Can not start express mode when an applet is selected", buf, 0x22u);
    }

    v60 = *(_QWORD *)(a1 + 40);
    v61 = objc_alloc((Class)NSError);
    v62 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v72 = NSLocalizedDescriptionKey;
    v63 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid State"));
    v73 = v63;
    v64 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v73, &v72, 1));
    v65 = objc_msgSend(v61, "initWithDomain:code:userInfo:", v62, 12, v64);
    (*(void (**)(uint64_t, id))(v60 + 16))(v60, v65);

  }
}

void sub_100125D28(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  void *v19;
  uint64_t v20;
  void (*v21)(uint64_t, const char *, ...);
  objc_class *v22;
  _BOOL4 v23;
  const char *v24;
  const char *v25;
  void *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  NSObject *v30;
  objc_class *v31;
  int v32;
  const char *v33;
  const char *v34;
  void *v35;
  uint64_t v36;
  id v37;
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  uint64_t v43;
  id v44;
  unsigned __int8 *v45;
  int v46;
  void *v47;
  uint64_t v48;
  void (*v49)(uint64_t, const char *, ...);
  objc_class *v50;
  _BOOL4 v51;
  const char *v52;
  uint64_t v53;
  void *v54;
  uint64_t v55;
  NSObject *v56;
  objc_class *v57;
  int v58;
  const char *v59;
  const char *v60;
  uint64_t v61;
  id v62;
  void *v63;
  void *v64;
  void *v65;
  id v66;
  unsigned __int8 v67;
  id v68;
  const char *v69;
  NSErrorUserInfoKey v70;
  void *v71;
  NSErrorUserInfoKey v72;
  void *v73;
  NSErrorUserInfoKey v74;
  void *v75;
  uint8_t buf[4];
  int v77;
  __int16 v78;
  const char *v79;
  __int16 v80;
  const char *v81;
  __int16 v82;
  int v83;
  __int16 v84;
  void *v85;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v10 = 45;
    if (isMetaClass)
      v10 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@", v10, ClassName, Name, 756, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 48));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    *(_DWORD *)buf = 67110146;
    v77 = v15;
    v78 = 2082;
    v79 = v16;
    v80 = 2082;
    v81 = v17;
    v82 = 1024;
    v83 = 756;
    v84 = 2114;
    v85 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);

  }
  if (!objc_msgSend(*(id *)(a1 + 32), "didStart")
    || (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) != 0
    || objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v20 = NFLogGetLogger(v19);
    if (v20)
    {
      v21 = (void (*)(uint64_t, const char *, ...))v20;
      v22 = object_getClass(*(id *)(a1 + 32));
      v23 = class_isMetaClass(v22);
      v24 = object_getClassName(*(id *)(a1 + 32));
      v25 = sel_getName(*(SEL *)(a1 + 48));
      v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      v27 = 45;
      if (v23)
        v27 = 43;
      v21(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v27, v24, v25, 758, v26);

    }
    v28 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v29 = NFSharedLogGetLogger(v28);
    v30 = objc_claimAutoreleasedReturnValue(v29);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      v31 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v31))
        v32 = 43;
      else
        v32 = 45;
      v33 = object_getClassName(*(id *)(a1 + 32));
      v34 = sel_getName(*(SEL *)(a1 + 48));
      v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      *(_DWORD *)buf = 67110146;
      v77 = v32;
      v78 = 2082;
      v79 = v33;
      v80 = 2082;
      v81 = v34;
      v82 = 1024;
      v83 = 758;
      v84 = 2114;
      v85 = v35;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

    }
    v36 = *(_QWORD *)(a1 + 40);
    if (v36)
    {
      v37 = objc_alloc((Class)NSError);
      v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v74 = NSLocalizedDescriptionKey;
      v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
      v75 = v39;
      v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v75, &v74, 1));
      v41 = v37;
      v42 = v38;
      v43 = 54;
LABEL_24:
      v44 = objc_msgSend(v41, "initWithDomain:code:userInfo:", v42, v43, v40);
      (*(void (**)(uint64_t, id))(v36 + 16))(v36, v44);

    }
  }
  else
  {
    v45 = (unsigned __int8 *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "expressModeManager"));
    if (!v45 || (v46 = v45[172], v45, !v46))
    {
      v67 = objc_msgSend(*(id *)(a1 + 32), "startCardEmulationWithType:", 4);
      v36 = *(_QWORD *)(a1 + 40);
      if ((v67 & 1) != 0)
      {
        (*(void (**)(uint64_t, _QWORD))(v36 + 16))(v36, 0);
        return;
      }
      v68 = objc_alloc((Class)NSError);
      v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v70 = NSLocalizedDescriptionKey;
      v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unknown Error"));
      v71 = v39;
      v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v71, &v70, 1));
      v41 = v68;
      v42 = v38;
      v43 = 6;
      goto LABEL_24;
    }
    v47 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v48 = NFLogGetLogger(v47);
    if (v48)
    {
      v49 = (void (*)(uint64_t, const char *, ...))v48;
      v50 = object_getClass(*(id *)(a1 + 32));
      v51 = class_isMetaClass(v50);
      v52 = object_getClassName(*(id *)(a1 + 32));
      v69 = sel_getName(*(SEL *)(a1 + 48));
      v53 = 45;
      if (v51)
        v53 = 43;
      v49(4, "%c[%{public}s %{public}s]:%i Express mode in progress, denying..", v53, v52, v69, 761);
    }
    v54 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v55 = NFSharedLogGetLogger(v54);
    v56 = objc_claimAutoreleasedReturnValue(v55);
    if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
    {
      v57 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v57))
        v58 = 43;
      else
        v58 = 45;
      v59 = object_getClassName(*(id *)(a1 + 32));
      v60 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)buf = 67109890;
      v77 = v58;
      v78 = 2082;
      v79 = v59;
      v80 = 2082;
      v81 = v60;
      v82 = 1024;
      v83 = 761;
      _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Express mode in progress, denying..", buf, 0x22u);
    }

    v61 = *(_QWORD *)(a1 + 40);
    v62 = objc_alloc((Class)NSError);
    v63 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v72 = NSLocalizedDescriptionKey;
    v64 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Express Mode in progress"));
    v73 = v64;
    v65 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v73, &v72, 1));
    v66 = objc_msgSend(v62, "initWithDomain:code:userInfo:", v63, 38, v65);
    (*(void (**)(uint64_t, id))(v61 + 16))(v61, v66);

  }
}

void sub_10012645C(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  void *v19;
  uint64_t v20;
  void (*v21)(uint64_t, const char *, ...);
  objc_class *v22;
  _BOOL4 v23;
  const char *v24;
  const char *v25;
  void *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  NSObject *v30;
  objc_class *v31;
  int v32;
  const char *v33;
  const char *v34;
  void *v35;
  uint64_t v36;
  id v37;
  void *v38;
  void *v39;
  void *v40;
  id v41;
  void *v42;
  void *v43;
  unsigned __int8 v44;
  void *v45;
  uint64_t v46;
  void (*v47)(uint64_t, const char *, ...);
  objc_class *v48;
  _BOOL4 v49;
  const char *v50;
  uint64_t v51;
  void *v52;
  uint64_t v53;
  NSObject *v54;
  objc_class *v55;
  int v56;
  const char *v57;
  const char *v58;
  const char *v59;
  NSErrorUserInfoKey v60;
  void *v61;
  uint8_t buf[4];
  int v63;
  __int16 v64;
  const char *v65;
  __int16 v66;
  const char *v67;
  __int16 v68;
  int v69;
  __int16 v70;
  void *v71;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v10 = 45;
    if (isMetaClass)
      v10 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@", v10, ClassName, Name, 777, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 48));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    *(_DWORD *)buf = 67110146;
    v63 = v15;
    v64 = 2082;
    v65 = v16;
    v66 = 2082;
    v67 = v17;
    v68 = 1024;
    v69 = 777;
    v70 = 2114;
    v71 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);

  }
  if (!objc_msgSend(*(id *)(a1 + 32), "didStart")
    || (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) != 0
    || objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v20 = NFLogGetLogger(v19);
    if (v20)
    {
      v21 = (void (*)(uint64_t, const char *, ...))v20;
      v22 = object_getClass(*(id *)(a1 + 32));
      v23 = class_isMetaClass(v22);
      v24 = object_getClassName(*(id *)(a1 + 32));
      v25 = sel_getName(*(SEL *)(a1 + 48));
      v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      v27 = 45;
      if (v23)
        v27 = 43;
      v21(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v27, v24, v25, 779, v26);

    }
    v28 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v29 = NFSharedLogGetLogger(v28);
    v30 = objc_claimAutoreleasedReturnValue(v29);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      v31 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v31))
        v32 = 43;
      else
        v32 = 45;
      v33 = object_getClassName(*(id *)(a1 + 32));
      v34 = sel_getName(*(SEL *)(a1 + 48));
      v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      *(_DWORD *)buf = 67110146;
      v63 = v32;
      v64 = 2082;
      v65 = v33;
      v66 = 2082;
      v67 = v34;
      v68 = 1024;
      v69 = 779;
      v70 = 2114;
      v71 = v35;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

    }
    v36 = *(_QWORD *)(a1 + 40);
    if (v36)
    {
      v37 = objc_alloc((Class)NSError);
      v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v60 = NSLocalizedDescriptionKey;
      v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
      v61 = v39;
      v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v61, &v60, 1));
      v41 = objc_msgSend(v37, "initWithDomain:code:userInfo:", v38, 54, v40);
      (*(void (**)(uint64_t, id))(v36 + 16))(v36, v41);

    }
  }
  else
  {
    *(_BYTE *)(*(_QWORD *)(a1 + 32) + 320) = 0;
    objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 304), "stopTimer");
    if (objc_msgSend(*(id *)(a1 + 32), "plasticCardMode"))
    {
      v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "secureElementWrapper"));
      v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v42, "handle"));
      v44 = objc_msgSend(v43, "enableGreenCarThreshold:", 1);

      if ((v44 & 1) == 0)
      {
        v45 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v46 = NFLogGetLogger(v45);
        if (v46)
        {
          v47 = (void (*)(uint64_t, const char *, ...))v46;
          v48 = object_getClass(*(id *)(a1 + 32));
          v49 = class_isMetaClass(v48);
          v50 = object_getClassName(*(id *)(a1 + 32));
          v59 = sel_getName(*(SEL *)(a1 + 48));
          v51 = 45;
          if (v49)
            v51 = 43;
          v47(6, "%c[%{public}s %{public}s]:%i Failed to re-enable GC logic", v51, v50, v59, 786);
        }
        v52 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v53 = NFSharedLogGetLogger(v52);
        v54 = objc_claimAutoreleasedReturnValue(v53);
        if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
        {
          v55 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v55))
            v56 = 43;
          else
            v56 = 45;
          v57 = object_getClassName(*(id *)(a1 + 32));
          v58 = sel_getName(*(SEL *)(a1 + 48));
          *(_DWORD *)buf = 67109890;
          v63 = v56;
          v64 = 2082;
          v65 = v57;
          v66 = 2082;
          v67 = v58;
          v68 = 1024;
          v69 = 786;
          _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Failed to re-enable GC logic", buf, 0x22u);
        }

      }
    }
    objc_msgSend(*(id *)(a1 + 32), "startDefaultMode");
    (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
  }
}

void sub_100126B08(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  void *v6;
  _BOOL4 v7;
  void *v8;
  uint64_t v9;
  void (*v10)(uint64_t, const char *, ...);
  objc_class *v11;
  _BOOL4 v12;
  const char *v13;
  const char *v14;
  void *v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  NSObject *v19;
  objc_class *v20;
  int v21;
  const char *v22;
  const char *v23;
  void *v24;
  uint64_t v25;
  id v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  id v33;
  void *v34;
  void *v35;
  id v36;
  void *v37;
  NSObject *v38;
  NSObject *v39;
  NSObject *v40;
  uint64_t v41;
  uint64_t v42;
  NSObject *v43;
  uint64_t v44;
  void *v45;
  uint64_t v46;
  void (*v47)(uint64_t, const char *, ...);
  objc_class *v48;
  _BOOL4 v49;
  const char *v50;
  uint64_t v51;
  void *v52;
  uint64_t v53;
  NSObject *v54;
  objc_class *v55;
  int v56;
  const char *v57;
  const char *v58;
  id v59;
  id v60;
  id v61;
  double *v62;
  void *specific;
  uint64_t Logger;
  void (*v65)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v69;
  void *v70;
  uint64_t v71;
  NSObject *v72;
  objc_class *v73;
  int v74;
  const char *v75;
  const char *v76;
  id v77;
  void *v78;
  void *v79;
  void *v80;
  id v81;
  const char *v82;
  const char *Name;
  id v84;
  NSErrorUserInfoKey v85;
  void *v86;
  NSErrorUserInfoKey v87;
  void *v88;
  NSErrorUserInfoKey v89;
  void *v90;
  uint8_t buf[4];
  int v92;
  __int16 v93;
  const char *v94;
  __int16 v95;
  const char *v96;
  __int16 v97;
  int v98;
  __int16 v99;
  void *v100;

  v2 = kdebug_trace(724566156, 0, 0, 0, 0);
  v3 = NFSharedSignpostLog(v2);
  v4 = objc_claimAutoreleasedReturnValue(v3);
  if (os_signpost_enabled(v4))
  {
    v5 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "expressModeManager"));
    v6 = (void *)v5;
    if (v5)
      v7 = *(_BYTE *)(v5 + 172) != 0;
    else
      v7 = 0;
    *(_DWORD *)buf = 67109120;
    v92 = v7;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLIENT_FELICA_APPLET_STATE", "InSessionExpress=%d", buf, 8u);

  }
  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    objc_msgSend(*(id *)(a1 + 32), "switchToSecureElementWrapperForApplet:", *(_QWORD *)(a1 + 40));
    if ((objc_msgSend(*(id *)(a1 + 32), "startWiredMode") & 1) != 0)
    {
      v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "secureElementWrapper"));
      v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "identifier"));
      v36 = sub_10022F2F0(v34, v35);
      v28 = (void *)objc_claimAutoreleasedReturnValue(v36);

      v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "secureElementWrapper"));
      LODWORD(v35) = sub_10023B608(v37, v28);

      v38 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "secureElementWrapper"));
      v39 = v38;
      if ((_DWORD)v35)
      {
        v40 = sub_10006CB58(v38, v28);
        v27 = (void *)objc_claimAutoreleasedReturnValue(v40);

        v41 = kdebug_trace(724566152, 0, 0, 0, 0);
        v42 = NFSharedSignpostLog(v41);
        v43 = objc_claimAutoreleasedReturnValue(v42);
        if (os_signpost_enabled(v43))
        {
          *(_WORD *)buf = 0;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v43, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLIENT_CALLBACK", "", buf, 2u);
        }

        v44 = *(_QWORD *)(a1 + 48);
        if (v27)
        {
          (*(void (**)(_QWORD, void *, _QWORD))(v44 + 16))(*(_QWORD *)(a1 + 48), v27, 0);
        }
        else
        {
          v77 = objc_alloc((Class)NSError);
          v78 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
          v85 = NSLocalizedDescriptionKey;
          v79 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unexpected Result"));
          v86 = v79;
          v80 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v86, &v85, 1));
          v81 = objc_msgSend(v77, "initWithDomain:code:userInfo:", v78, 13, v80);
          (*(void (**)(uint64_t, _QWORD, id))(v44 + 16))(v44, 0, v81);

        }
        objc_msgSend(*(id *)(a1 + 32), "startDefaultMode");
      }
      else
      {
        v84 = 0;
        v60 = sub_100237A30(v38, v28, &v84);
        v27 = (void *)objc_claimAutoreleasedReturnValue(v60);
        v61 = v84;

        (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
        v62 = *(double **)(a1 + 32);
        if (v62[34] <= 0.0)
        {
          objc_msgSend(v62, "startDefaultMode");
        }
        else
        {
          specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          Logger = NFLogGetLogger(specific);
          if (Logger)
          {
            v65 = (void (*)(uint64_t, const char *, ...))Logger;
            Class = object_getClass(*(id *)(a1 + 32));
            isMetaClass = class_isMetaClass(Class);
            ClassName = object_getClassName(*(id *)(a1 + 32));
            Name = sel_getName(*(SEL *)(a1 + 56));
            v69 = 45;
            if (isMetaClass)
              v69 = 43;
            v65(6, "%c[%{public}s %{public}s]:%i Delaying restart of default mode", v69, ClassName, Name, 844);
          }
          v70 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v71 = NFSharedLogGetLogger(v70);
          v72 = objc_claimAutoreleasedReturnValue(v71);
          if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
          {
            v73 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v73))
              v74 = 43;
            else
              v74 = 45;
            v75 = object_getClassName(*(id *)(a1 + 32));
            v76 = sel_getName(*(SEL *)(a1 + 56));
            *(_DWORD *)buf = 67109890;
            v92 = v74;
            v93 = 2082;
            v94 = v75;
            v95 = 2082;
            v96 = v76;
            v97 = 1024;
            v98 = 844;
            _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Delaying restart of default mode", buf, 0x22u);
          }

          objc_msgSend(*(id *)(a1 + 32), "pauseExpressAndStartDefaultModeAfter:", *(double *)(*(_QWORD *)(a1 + 32) + 272));
        }

      }
      goto LABEL_20;
    }
    v45 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v46 = NFLogGetLogger(v45);
    if (v46)
    {
      v47 = (void (*)(uint64_t, const char *, ...))v46;
      v48 = object_getClass(*(id *)(a1 + 32));
      v49 = class_isMetaClass(v48);
      v50 = object_getClassName(*(id *)(a1 + 32));
      v82 = sel_getName(*(SEL *)(a1 + 56));
      v51 = 45;
      if (v49)
        v51 = 43;
      v47(3, "%c[%{public}s %{public}s]:%i Failed to set mode to wired", v51, v50, v82, 810);
    }
    v52 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v53 = NFSharedLogGetLogger(v52);
    v54 = objc_claimAutoreleasedReturnValue(v53);
    if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
    {
      v55 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v55))
        v56 = 43;
      else
        v56 = 45;
      v57 = object_getClassName(*(id *)(a1 + 32));
      v58 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)buf = 67109890;
      v92 = v56;
      v93 = 2082;
      v94 = v57;
      v95 = 2082;
      v96 = v58;
      v97 = 1024;
      v98 = 810;
      _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to set mode to wired", buf, 0x22u);
    }

    v25 = *(_QWORD *)(a1 + 48);
    v59 = objc_alloc((Class)NSError);
    v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v87 = NSLocalizedDescriptionKey;
    v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unexpected Result"));
    v88 = v28;
    v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v88, &v87, 1));
    v30 = v59;
    v31 = v27;
    v32 = 13;
LABEL_19:
    v33 = objc_msgSend(v30, "initWithDomain:code:userInfo:", v31, v32, v29);
    (*(void (**)(uint64_t, _QWORD, id))(v25 + 16))(v25, 0, v33);

LABEL_20:
    return;
  }
  v8 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v9 = NFLogGetLogger(v8);
  if (v9)
  {
    v10 = (void (*)(uint64_t, const char *, ...))v9;
    v11 = object_getClass(*(id *)(a1 + 32));
    v12 = class_isMetaClass(v11);
    v13 = object_getClassName(*(id *)(a1 + 32));
    v14 = sel_getName(*(SEL *)(a1 + 56));
    v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v16 = 45;
    if (v12)
      v16 = 43;
    v10(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v16, v13, v14, 803, v15);

  }
  v17 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v18 = NFSharedLogGetLogger(v17);
  v19 = objc_claimAutoreleasedReturnValue(v18);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    v20 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v20))
      v21 = 43;
    else
      v21 = 45;
    v22 = object_getClassName(*(id *)(a1 + 32));
    v23 = sel_getName(*(SEL *)(a1 + 56));
    v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v92 = v21;
    v93 = 2082;
    v94 = v22;
    v95 = 2082;
    v96 = v23;
    v97 = 1024;
    v98 = 803;
    v99 = 2114;
    v100 = v24;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v25 = *(_QWORD *)(a1 + 48);
  if (v25)
  {
    v26 = objc_alloc((Class)NSError);
    v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v89 = NSLocalizedDescriptionKey;
    v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v90 = v28;
    v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v90, &v89, 1));
    v30 = v26;
    v31 = v27;
    v32 = 54;
    goto LABEL_19;
  }
}

void sub_1001274A8(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  void *v6;
  int v7;
  void *v8;
  uint64_t v9;
  void (*v10)(uint64_t, const char *, ...);
  objc_class *v11;
  _BOOL4 v12;
  const char *v13;
  const char *v14;
  void *v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  NSObject *v19;
  objc_class *v20;
  int v21;
  const char *v22;
  const char *v23;
  void *v24;
  uint64_t v25;
  id v26;
  id v27;
  void *v28;
  void *v29;
  void *v30;
  id v31;
  uint64_t v32;
  id v33;
  void *v34;
  void *v35;
  id v36;
  void *v37;
  id v38;
  uint64_t v39;
  uint64_t v40;
  NSObject *v41;
  double *v42;
  void *specific;
  uint64_t Logger;
  void (*v45)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v49;
  void *v50;
  uint64_t v51;
  NSObject *v52;
  objc_class *v53;
  int v54;
  const char *v55;
  const char *v56;
  void *v57;
  uint64_t v58;
  void (*v59)(uint64_t, const char *, ...);
  objc_class *v60;
  _BOOL4 v61;
  const char *v62;
  uint64_t v63;
  void *v64;
  uint64_t v65;
  NSObject *v66;
  objc_class *v67;
  int v68;
  const char *v69;
  const char *v70;
  id v71;
  const char *Name;
  const char *v73;
  id v74;
  NSErrorUserInfoKey v75;
  void *v76;
  NSErrorUserInfoKey v77;
  void *v78;
  uint8_t buf[4];
  int v80;
  __int16 v81;
  const char *v82;
  __int16 v83;
  const char *v84;
  __int16 v85;
  int v86;
  __int16 v87;
  void *v88;

  v2 = kdebug_trace(724566228, 0, 0, 0, 0);
  v3 = NFSharedSignpostLog(v2);
  v4 = objc_claimAutoreleasedReturnValue(v3);
  if (os_signpost_enabled(v4))
  {
    v5 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "expressModeManager"));
    v6 = (void *)v5;
    if (v5)
      v7 = *(unsigned __int8 *)(v5 + 172);
    else
      v7 = 0;
    *(_DWORD *)buf = 67109120;
    v80 = v7;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLIENT_TRANSIT_APPLET_STATE", "InSessionExpress=%d", buf, 8u);

  }
  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    objc_msgSend(*(id *)(a1 + 32), "switchToSecureElementWrapperForApplet:", *(_QWORD *)(a1 + 40));
    if ((objc_msgSend(*(id *)(a1 + 32), "startWiredMode") & 1) != 0)
    {
      v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "secureElementWrapper"));
      v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "identifier"));
      v36 = sub_10022F2F0(v34, v35);
      v28 = (void *)objc_claimAutoreleasedReturnValue(v36);

      v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "secureElementWrapper"));
      v74 = 0;
      v38 = sub_100237A30(v37, v28, &v74);
      v29 = (void *)objc_claimAutoreleasedReturnValue(v38);
      v27 = v74;

      v39 = kdebug_trace(724566152, 0, 0, 0, 0);
      v40 = NFSharedSignpostLog(v39);
      v41 = objc_claimAutoreleasedReturnValue(v40);
      if (os_signpost_enabled(v41))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v41, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLIENT_CALLBACK", "", buf, 2u);
      }

      (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
      v42 = *(double **)(a1 + 32);
      if (v42[34] <= 0.0)
      {
        objc_msgSend(v42, "startDefaultMode");
      }
      else
      {
        specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        Logger = NFLogGetLogger(specific);
        if (Logger)
        {
          v45 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(*(id *)(a1 + 32));
          isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(*(id *)(a1 + 32));
          Name = sel_getName(*(SEL *)(a1 + 56));
          v49 = 45;
          if (isMetaClass)
            v49 = 43;
          v45(6, "%c[%{public}s %{public}s]:%i Delaying restart of default mode", v49, ClassName, Name, 886);
        }
        v50 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v51 = NFSharedLogGetLogger(v50);
        v52 = objc_claimAutoreleasedReturnValue(v51);
        if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
        {
          v53 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v53))
            v54 = 43;
          else
            v54 = 45;
          v55 = object_getClassName(*(id *)(a1 + 32));
          v56 = sel_getName(*(SEL *)(a1 + 56));
          *(_DWORD *)buf = 67109890;
          v80 = v54;
          v81 = 2082;
          v82 = v55;
          v83 = 2082;
          v84 = v56;
          v85 = 1024;
          v86 = 886;
          _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Delaying restart of default mode", buf, 0x22u);
        }

        objc_msgSend(*(id *)(a1 + 32), "pauseExpressAndStartDefaultModeAfter:", *(double *)(*(_QWORD *)(a1 + 32) + 272));
      }
      goto LABEL_20;
    }
    v57 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v58 = NFLogGetLogger(v57);
    if (v58)
    {
      v59 = (void (*)(uint64_t, const char *, ...))v58;
      v60 = object_getClass(*(id *)(a1 + 32));
      v61 = class_isMetaClass(v60);
      v62 = object_getClassName(*(id *)(a1 + 32));
      v73 = sel_getName(*(SEL *)(a1 + 56));
      v63 = 45;
      if (v61)
        v63 = 43;
      v59(3, "%c[%{public}s %{public}s]:%i Failed to set mode to wired", v63, v62, v73, 869);
    }
    v64 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v65 = NFSharedLogGetLogger(v64);
    v66 = objc_claimAutoreleasedReturnValue(v65);
    if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
    {
      v67 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v67))
        v68 = 43;
      else
        v68 = 45;
      v69 = object_getClassName(*(id *)(a1 + 32));
      v70 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)buf = 67109890;
      v80 = v68;
      v81 = 2082;
      v82 = v69;
      v83 = 2082;
      v84 = v70;
      v85 = 1024;
      v86 = 869;
      _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to set mode to wired", buf, 0x22u);
    }

    v25 = *(_QWORD *)(a1 + 48);
    v71 = objc_alloc((Class)NSError);
    v27 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v75 = NSLocalizedDescriptionKey;
    v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unexpected Result"));
    v76 = v28;
    v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v76, &v75, 1));
    v30 = v71;
    v31 = v27;
    v32 = 13;
LABEL_19:
    v33 = objc_msgSend(v30, "initWithDomain:code:userInfo:", v31, v32, v29);
    (*(void (**)(uint64_t, _QWORD, id))(v25 + 16))(v25, 0, v33);

LABEL_20:
    return;
  }
  v8 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v9 = NFLogGetLogger(v8);
  if (v9)
  {
    v10 = (void (*)(uint64_t, const char *, ...))v9;
    v11 = object_getClass(*(id *)(a1 + 32));
    v12 = class_isMetaClass(v11);
    v13 = object_getClassName(*(id *)(a1 + 32));
    v14 = sel_getName(*(SEL *)(a1 + 56));
    v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v16 = 45;
    if (v12)
      v16 = 43;
    v10(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v16, v13, v14, 862, v15);

  }
  v17 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v18 = NFSharedLogGetLogger(v17);
  v19 = objc_claimAutoreleasedReturnValue(v18);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    v20 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v20))
      v21 = 43;
    else
      v21 = 45;
    v22 = object_getClassName(*(id *)(a1 + 32));
    v23 = sel_getName(*(SEL *)(a1 + 56));
    v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v80 = v21;
    v81 = 2082;
    v82 = v22;
    v83 = 2082;
    v84 = v23;
    v85 = 1024;
    v86 = 862;
    v87 = 2114;
    v88 = v24;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v25 = *(_QWORD *)(a1 + 48);
  if (v25)
  {
    v26 = objc_alloc((Class)NSError);
    v27 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v77 = NSLocalizedDescriptionKey;
    v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v78 = v28;
    v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v78, &v77, 1));
    v30 = v26;
    v31 = v27;
    v32 = 54;
    goto LABEL_19;
  }
}

void sub_10012A2E8(uint64_t a1, uint64_t a2)
{
  id v2;

  if (a2)
  {
    v2 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "remoteObject"));
    objc_msgSend(v2, "didFailDeferredAuthorization");

  }
}

void sub_10012DBDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id location)
{
  id *v22;

  objc_destroyWeak(v22);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10012DC24(uint64_t a1)
{
  NSObject *v2;
  _QWORD *WeakRetained;
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  _BYTE *v18;
  void *v19;
  void *v20;
  const char *Name;
  _BYTE state[18];
  __int16 v23;
  const char *v24;
  __int16 v25;
  int v26;

  v2 = _os_activity_create((void *)&_mh_execute_header, "com.apple.nfcd.express.restartTimer", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  *(_QWORD *)state = 0;
  *(_QWORD *)&state[8] = 0;
  os_activity_scope_enter(v2, (os_activity_scope_state_t)state);
  os_activity_scope_leave((os_activity_scope_state_t)state);

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(WeakRetained);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(WeakRetained);
      Name = sel_getName(*(SEL *)(a1 + 40));
      v10 = 45;
      if (isMetaClass)
        v10 = 43;
      v6(6, "%c[%{public}s %{public}s]:%i ", v10, ClassName, Name, 1584);
    }
    v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v12 = NFSharedLogGetLogger(v11);
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      v14 = object_getClass(WeakRetained);
      if (class_isMetaClass(v14))
        v15 = 43;
      else
        v15 = 45;
      v16 = object_getClassName(WeakRetained);
      v17 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)state = 67109890;
      *(_DWORD *)&state[4] = v15;
      *(_WORD *)&state[8] = 2082;
      *(_QWORD *)&state[10] = v16;
      v23 = 2082;
      v24 = v17;
      v25 = 1024;
      v26 = 1584;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", state, 0x22u);
    }

    v18 = (_BYTE *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "expressModeManager"));
    v19 = v18;
    if (v18)
      sub_100040428(v18, 0, 1u);

    objc_msgSend(WeakRetained, "startDefaultMode");
    v20 = (void *)WeakRetained[39];
    WeakRetained[39] = 0;

  }
}

void sub_10012F23C(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  NSObject *v11;
  objc_class *v12;
  int v13;
  const char *v14;
  const char *v15;
  void *v16;
  const char *Name;
  uint8_t buf[4];
  int v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 40));
    v8 = 45;
    if (isMetaClass)
      v8 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i ", v8, ClassName, Name, 1749);
  }
  v9 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v10 = NFSharedLogGetLogger(v9);
  v11 = objc_claimAutoreleasedReturnValue(v10);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v12 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v12))
      v13 = 43;
    else
      v13 = 45;
    v14 = object_getClassName(*(id *)(a1 + 32));
    v15 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)buf = 67109890;
    v19 = v13;
    v20 = 2082;
    v21 = v14;
    v22 = 2082;
    v23 = v15;
    v24 = 1024;
    v25 = 1749;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
  }

  v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "remoteObject"));
  objc_msgSend(v16, "didReceivePendingServerRequest");

}

void sub_10012FF38(uint64_t a1, void *a2, void *a3)
{
  id v4;
  id v5;
  id v6;
  id v7;
  id v8;
  uint64_t v9;
  void *i;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  uint64_t v15;
  id v16;
  void *v17;
  void *v18;
  id v19;
  NFContactlessPaymentEndEvent *v20;
  void *specific;
  uint64_t Logger;
  void (*v23)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  NSObject *v29;
  objc_class *v30;
  int v31;
  const char *v32;
  const char *v33;
  void *v34;
  const char *ClassName;
  const char *Name;
  id v37;
  id v38;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  uint8_t buf[4];
  int v45;
  __int16 v46;
  const char *v47;
  __int16 v48;
  const char *v49;
  __int16 v50;
  int v51;
  __int16 v52;
  NFContactlessPaymentEndEvent *v53;
  _QWORD v54[4];
  _QWORD v55[4];
  _BYTE v56[128];

  v4 = a2;
  v5 = a3;
  v40 = 0u;
  v41 = 0u;
  v42 = 0u;
  v43 = 0u;
  v6 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("NFHistoryRecords")));
  v7 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v40, v56, 16);
  if (v7)
  {
    v8 = v7;
    v9 = *(_QWORD *)v41;
    v37 = v5;
    v38 = v4;
    while (2)
    {
      for (i = 0; i != v8; i = (char *)i + 1)
      {
        if (*(_QWORD *)v41 != v9)
          objc_enumerationMutation(v6);
        v11 = *(void **)(*((_QWORD *)&v40 + 1) + 8 * (_QWORD)i);
        v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "objectForKeyedSubscript:", CFSTR("NFServiceProviderID")));
        if (objc_msgSend(v12, "intValue") == 1 || objc_msgSend(v12, "intValue") == 4)
          goto LABEL_16;
        v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "objectForKeyedSubscript:", CFSTR("NFBalance")));
        if (v13
          || (v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "objectForKeyedSubscript:", CFSTR("NFTransactionDate")))) != 0)
        {

LABEL_16:
          v15 = 61441;
          v5 = v37;
          v4 = v38;
          goto LABEL_17;
        }
        v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "objectForKeyedSubscript:", CFSTR("NFAmount")));

        if (v14)
          goto LABEL_16;

      }
      v8 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v40, v56, 16);
      v15 = 61442;
      v5 = v37;
      v4 = v38;
      if (v8)
        continue;
      break;
    }
  }
  else
  {
    v15 = 61442;
  }
LABEL_17:

  v16 = objc_alloc((Class)NSMutableDictionary);
  v54[0] = CFSTR("appletIdentifier");
  v54[1] = CFSTR("type");
  v55[0] = v4;
  v55[1] = &off_1002FF8D0;
  v54[2] = CFSTR("result");
  v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", v15));
  v54[3] = CFSTR("felicaInfo");
  v55[2] = v17;
  v55[3] = v5;
  v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v55, v54, 4));
  v19 = objc_msgSend(v16, "initWithDictionary:", v18);

  v20 = -[NFContactlessPaymentEndEvent initWithDictionary:]([NFContactlessPaymentEndEvent alloc], "initWithDictionary:", v19);
  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v23 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 40));
    v26 = 45;
    if (isMetaClass)
      v26 = 43;
    v23(6, "%c[%{public}s %{public}s]:%i %{public}@", v26, ClassName, Name, 1855, v20);
  }
  v27 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v28 = NFSharedLogGetLogger(v27);
  v29 = objc_claimAutoreleasedReturnValue(v28);
  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
  {
    v30 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v30))
      v31 = 43;
    else
      v31 = 45;
    v32 = object_getClassName(*(id *)(a1 + 32));
    v33 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)buf = 67110146;
    v45 = v31;
    v46 = 2082;
    v47 = v32;
    v48 = 2082;
    v49 = v33;
    v50 = 1024;
    v51 = 1855;
    v52 = 2114;
    v53 = v20;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }

  v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "remoteObject"));
  objc_msgSend(v34, "didEndTransaction:", v20);

}

id sub_100130704(void *a1)
{
  id v1;
  id v2;
  id v3;
  void *v4;
  id v5;
  uint64_t v7;
  id v8;

  v1 = a1;
  v2 = objc_alloc((Class)NSError);
  v3 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("NFTrust Internal Error : '%@'"), v1, NSLocalizedDescriptionKey);

  v8 = v3;
  v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v8, &v7, 1));
  v5 = objc_msgSend(v2, "initWithDomain:code:userInfo:", CFSTR("Trust"), 0, v4);

  return v5;
}

id sub_1001307F4()
{
  id v0;
  id v1;
  void *v2;
  id v3;
  NSErrorUserInfoKey v5;
  id v6;

  v0 = objc_alloc((Class)NSError);
  v5 = NSLocalizedDescriptionKey;
  v1 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("NFTrust Need Refresh"));
  v6 = v1;
  v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v6, &v5, 1));
  v3 = objc_msgSend(v0, "initWithDomain:code:userInfo:", CFSTR("Trust"), 1, v2);

  return v3;
}

id sub_1001308D0()
{
  id v0;
  id v1;
  void *v2;
  id v3;
  NSErrorUserInfoKey v5;
  id v6;

  v0 = objc_alloc((Class)NSError);
  v5 = NSLocalizedDescriptionKey;
  v1 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("NFTrust database error"));
  v6 = v1;
  v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v6, &v5, 1));
  v3 = objc_msgSend(v0, "initWithDomain:code:userInfo:", CFSTR("Trust"), 7, v2);

  return v3;
}

id sub_1001309AC()
{
  id v0;
  id v1;
  void *v2;
  id v3;
  NSErrorUserInfoKey v5;
  id v6;

  v0 = objc_alloc((Class)NSError);
  v5 = NSLocalizedDescriptionKey;
  v1 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("Operation requires LocalValidation"));
  v6 = v1;
  v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v6, &v5, 1));
  v3 = objc_msgSend(v0, "initWithDomain:code:userInfo:", CFSTR("Trust"), 4, v2);

  return v3;
}

id sub_100130A88(void *a1)
{
  id v1;
  id v2;
  id v3;
  void *v4;
  id v5;
  uint64_t v7;
  id v8;

  v1 = a1;
  v2 = objc_alloc((Class)NSError);
  v3 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("No space left in the instance to %@"), v1, NSLocalizedDescriptionKey);

  v8 = v3;
  v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v8, &v7, 1));
  v5 = objc_msgSend(v2, "initWithDomain:code:userInfo:", CFSTR("Trust"), 6, v4);

  return v5;
}

id sub_100130B78(void *a1)
{
  id v1;
  id v2;
  id v3;
  void *v4;
  id v5;
  uint64_t v7;
  id v8;

  v1 = a1;
  v2 = objc_alloc((Class)NSError);
  v3 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("Key with Identifier '%@' not found"), v1, NSLocalizedDescriptionKey);

  v8 = v3;
  v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v8, &v7, 1));
  v5 = objc_msgSend(v2, "initWithDomain:code:userInfo:", CFSTR("Trust"), 2, v4);

  return v5;
}

id sub_100130C68(void *a1)
{
  id v1;
  id v2;
  id v3;
  void *v4;
  id v5;
  uint64_t v7;
  id v8;

  v1 = a1;
  v2 = objc_alloc((Class)NSError);
  v3 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("Key with Identifier '%@' already exists"), v1, NSLocalizedDescriptionKey);

  v8 = v3;
  v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v8, &v7, 1));
  v5 = objc_msgSend(v2, "initWithDomain:code:userInfo:", CFSTR("Trust"), 3, v4);

  return v5;
}

id sub_100130D58(void *a1)
{
  id v1;
  id v2;
  id v3;
  void *v4;
  id v5;
  uint64_t v7;
  id v8;

  v1 = a1;
  v2 = objc_alloc((Class)NSError);
  v3 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("Invalid Parameters : '%@'"), v1, NSLocalizedDescriptionKey);

  v8 = v3;
  v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v8, &v7, 1));
  v5 = objc_msgSend(v2, "initWithDomain:code:userInfo:", CFSTR("Trust"), 5, v4);

  return v5;
}

void sub_100130E88(id a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  id v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  id v19;

  v19 = objc_alloc((Class)NSSet);
  v18 = objc_opt_class(NSArray);
  v17 = objc_opt_class(NSMutableArray);
  v16 = objc_opt_class(NSDictionary);
  v15 = objc_opt_class(NSMutableDictionary);
  v14 = objc_opt_class(NSString);
  v13 = objc_opt_class(NSMutableString);
  v1 = objc_opt_class(NSData);
  v2 = objc_opt_class(NSMutableData);
  v3 = objc_opt_class(NSNumber);
  v4 = objc_opt_class(NSDate);
  v5 = objc_opt_class(NSDateComponents);
  v6 = objc_opt_class(NFTrustKey);
  v7 = objc_opt_class(NFTrustPaymentSignResponse);
  v8 = objc_opt_class(NFTrustSignRequest);
  v9 = objc_opt_class(NFTrustSignResponse);
  v10 = objc_opt_class(NFECommercePaymentResponse);
  v11 = objc_msgSend(v19, "initWithObjects:", v18, v17, v16, v15, v14, v13, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, objc_opt_class(NFTrustLocalValidation),
          0);
  v12 = (void *)qword_10032A9F0;
  qword_10032A9F0 = (uint64_t)v11;

}

void sub_100137408(uint64_t a1)
{
  void *v2;
  void *v3;
  unsigned __int8 v4;
  uint64_t v5;
  id v6;
  void *v7;
  void *v8;
  id v9;
  id v10;
  void *v11;
  void *v12;
  void *v13;
  uint64_t v14;
  id v15;
  void *specific;
  uint64_t Logger;
  void (*v18)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  NSObject *v25;
  objc_class *v26;
  int v27;
  const char *v28;
  const char *v29;
  NSString *v30;
  void *v31;
  void *v32;
  unsigned int v33;
  id v34;
  void *v35;
  uint64_t v36;
  void (*v37)(uint64_t, const char *, ...);
  objc_class *v38;
  _BOOL4 v39;
  uint64_t v40;
  void *v41;
  uint64_t v42;
  NSObject *v43;
  objc_class *v44;
  int v45;
  const char *v46;
  const char *v47;
  id v48;
  id v49;
  id v50;
  void *v51;
  uint64_t v52;
  void (*v53)(uint64_t, const char *, ...);
  objc_class *v54;
  _BOOL4 v55;
  uint64_t v56;
  void *v57;
  uint64_t v58;
  NSObject *v59;
  objc_class *v60;
  int v61;
  const char *v62;
  const char *v63;
  void *v64;
  uint64_t v65;
  void (*v66)(uint64_t, const char *, ...);
  objc_class *v67;
  _BOOL4 v68;
  const char *v69;
  uint64_t v70;
  void *v71;
  uint64_t v72;
  NSObject *v73;
  objc_class *v74;
  int v75;
  const char *v76;
  const char *v77;
  id v78;
  id v79;
  void *v80;
  uint64_t v81;
  void (*v82)(uint64_t, const char *, ...);
  objc_class *v83;
  _BOOL4 v84;
  const char *v85;
  uint64_t v86;
  void *v87;
  uint64_t v88;
  NSObject *v89;
  objc_class *v90;
  int v91;
  const char *v92;
  const char *v93;
  id v94;
  void *v95;
  void *v96;
  uint64_t v97;
  void (*v98)(uint64_t, const char *, ...);
  objc_class *v99;
  _BOOL4 v100;
  uint64_t v101;
  void *v102;
  uint64_t v103;
  objc_class *v104;
  int v105;
  const char *v106;
  const char *v107;
  NSObject *v108;
  void *v109;
  uint64_t v110;
  void (*v111)(uint64_t, const char *, ...);
  objc_class *v112;
  _BOOL4 v113;
  const char *v114;
  uint64_t v115;
  void *v116;
  uint64_t v117;
  NSObject *v118;
  objc_class *v119;
  int v120;
  const char *v121;
  const char *v122;
  id v123;
  void *v124;
  uint64_t v125;
  void (*v126)(uint64_t, const char *, ...);
  objc_class *v127;
  _BOOL4 v128;
  const char *v129;
  uint64_t v130;
  void *v131;
  uint64_t v132;
  NSObject *v133;
  objc_class *v134;
  int v135;
  const char *v136;
  const char *v137;
  id v138;
  NSString *v139;
  void *v140;
  void *v141;
  uint64_t v142;
  void (*v143)(uint64_t, const char *, ...);
  objc_class *v144;
  _BOOL4 v145;
  const char *v146;
  uint64_t v147;
  void *v148;
  uint64_t v149;
  NSObject *v150;
  objc_class *v151;
  int v152;
  const char *v153;
  void *v154;
  uint64_t v155;
  void (*v156)(uint64_t, const char *, ...);
  objc_class *v157;
  _BOOL4 v158;
  const char *v159;
  uint64_t v160;
  void *v161;
  uint64_t v162;
  NSObject *v163;
  objc_class *v164;
  int v165;
  const char *v166;
  const char *v167;
  id v168;
  uint64_t v169;
  void *v170;
  const char *v171;
  const char *v172;
  const char *v173;
  const char *Name;
  const char *v175;
  const char *v176;
  const char *v177;
  const char *v178;
  const char *v179;
  const char *v180;
  const char *v181;
  const char *v182;
  const char *v183;
  const char *v184;
  void *v185;
  _QWORD v186[4];
  id v187;
  uint64_t v188;
  uint64_t v189;
  id v190;
  id v191;
  NSErrorUserInfoKey v192;
  NSObject *v193;
  uint8_t buf[4];
  int v195;
  __int16 v196;
  const char *v197;
  __int16 v198;
  const char *v199;
  __int16 v200;
  int v201;
  __int16 v202;
  id v203;
  _QWORD v204[4];
  _QWORD v205[4];
  _QWORD v206[4];
  _QWORD v207[4];
  _QWORD v208[4];
  _QWORD v209[4];

  v2 = (void *)objc_claimAutoreleasedReturnValue(+[_NFHardwareManager sharedHardwareManager](_NFHardwareManager, "sharedHardwareManager"));
  if (-[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)v2) != 2)
  {
    v5 = *(_QWORD *)(a1 + 40);
    v6 = objc_alloc((Class)NSError);
    v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v208[0] = NSLocalizedDescriptionKey;
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
    v209[0] = v8;
    v209[1] = &off_1002FF948;
    v208[1] = CFSTR("Line");
    v208[2] = CFSTR("Method");
    v9 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 48)));
    v209[2] = v9;
    v208[3] = NSDebugDescriptionErrorKey;
    v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 48)), 94);
    v209[3] = v10;
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v209, v208, 4));
    v12 = v6;
    v13 = v7;
    v14 = 58;
LABEL_48:
    v79 = objc_msgSend(v12, "initWithDomain:code:userInfo:", v13, v14, v11);
    (*(void (**)(uint64_t, id, _QWORD))(v5 + 16))(v5, v79, 0);

    goto LABEL_49;
  }
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "controllerInfo"));
  v4 = objc_msgSend(v3, "hasLPEMSupport");

  if ((v4 & 1) == 0)
  {
    v5 = *(_QWORD *)(a1 + 40);
    v15 = objc_alloc((Class)NSError);
    v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v206[0] = NSLocalizedDescriptionKey;
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Feature Not Supported"));
    v207[0] = v8;
    v207[1] = &off_1002FF960;
    v206[1] = CFSTR("Line");
    v206[2] = CFSTR("Method");
    v9 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 48)));
    v207[2] = v9;
    v206[3] = NSDebugDescriptionErrorKey;
    v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 48)), 99);
    v207[3] = v10;
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v207, v206, 4));
    v12 = v15;
    v13 = v7;
    v14 = 14;
    goto LABEL_48;
  }
  if (byte_10032A9F8 == 1)
  {
    (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
    goto LABEL_49;
  }
  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v18 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v22 = 45;
    if (isMetaClass)
      v22 = 43;
    v18(6, "%c[%{public}s %{public}s]:%i Querying bluetooth log", v22, ClassName, Name, 109);
  }
  v23 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v24 = NFSharedLogGetLogger(v23);
  v25 = objc_claimAutoreleasedReturnValue(v24);
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    v26 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v26))
      v27 = 43;
    else
      v27 = 45;
    v28 = object_getClassName(*(id *)(a1 + 32));
    v29 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)buf = 67109890;
    v195 = v27;
    v196 = 2082;
    v197 = v28;
    v198 = 2082;
    v199 = v29;
    v200 = 1024;
    v201 = 109;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Querying bluetooth log", buf, 0x22u);
  }

  if ((objc_msgSend(*(id *)(a1 + 32), "_dumpLPEMAppletLogs") & 1) == 0)
  {
    v64 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v65 = NFLogGetLogger(v64);
    if (v65)
    {
      v66 = (void (*)(uint64_t, const char *, ...))v65;
      v67 = object_getClass(*(id *)(a1 + 32));
      v68 = class_isMetaClass(v67);
      v69 = object_getClassName(*(id *)(a1 + 32));
      v177 = sel_getName(*(SEL *)(a1 + 48));
      v70 = 45;
      if (v68)
        v70 = 43;
      v66(3, "%c[%{public}s %{public}s]:%i Failed to query log", v70, v69, v177, 111);
    }
    v71 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v72 = NFSharedLogGetLogger(v71);
    v73 = objc_claimAutoreleasedReturnValue(v72);
    if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
    {
      v74 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v74))
        v75 = 43;
      else
        v75 = 45;
      v76 = object_getClassName(*(id *)(a1 + 32));
      v77 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)buf = 67109890;
      v195 = v75;
      v196 = 2082;
      v197 = v76;
      v198 = 2082;
      v199 = v77;
      v200 = 1024;
      v201 = 111;
      _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to query log", buf, 0x22u);
    }

    v5 = *(_QWORD *)(a1 + 40);
    v78 = objc_alloc((Class)NSError);
    v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v204[0] = NSLocalizedDescriptionKey;
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unknown Error"));
    v205[0] = v8;
    v205[1] = &off_1002FF978;
    v204[1] = CFSTR("Line");
    v204[2] = CFSTR("Method");
    v9 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 48)));
    v205[2] = v9;
    v204[3] = NSDebugDescriptionErrorKey;
    v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 48)), 112);
    v205[3] = v10;
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v205, v204, 4));
    v12 = v78;
    v13 = v7;
    v14 = 6;
    goto LABEL_48;
  }
  v30 = NSHomeDirectory();
  v185 = (void *)objc_claimAutoreleasedReturnValue(v30);
  v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v185, "stringByAppendingFormat:", CFSTR("/Library/Logs/nfcd_lpem.bin")));
  v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:](NSURL, "fileURLWithPath:", v31));

  if (!v32)
  {
    v80 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v81 = NFLogGetLogger(v80);
    if (v81)
    {
      v82 = (void (*)(uint64_t, const char *, ...))v81;
      v83 = object_getClass(*(id *)(a1 + 32));
      v84 = class_isMetaClass(v83);
      v85 = object_getClassName(*(id *)(a1 + 32));
      v178 = sel_getName(*(SEL *)(a1 + 48));
      v86 = 45;
      if (v84)
        v86 = 43;
      v82(3, "%c[%{public}s %{public}s]:%i bluetoothLog not found", v86, v85, v178, 156);
    }
    v87 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v88 = NFSharedLogGetLogger(v87);
    v89 = objc_claimAutoreleasedReturnValue(v88);
    if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
    {
      v90 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v90))
        v91 = 43;
      else
        v91 = 45;
      v92 = object_getClassName(*(id *)(a1 + 32));
      v93 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)buf = 67109890;
      v195 = v91;
      v196 = 2082;
      v197 = v92;
      v198 = 2082;
      v199 = v93;
      v200 = 1024;
      v201 = 156;
      _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i bluetoothLog not found", buf, 0x22u);
    }

    v94 = objc_alloc((Class)NSError);
    v34 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v192 = NSLocalizedDescriptionKey;
    v59 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Not found"));
    v193 = v59;
    v95 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v193, &v192, 1));
    v50 = objc_msgSend(v94, "initWithDomain:code:userInfo:", v34, 65, v95);

    v48 = 0;
    goto LABEL_107;
  }
  v191 = 0;
  v33 = objc_msgSend(v32, "checkResourceIsReachableAndReturnError:", &v191);
  v34 = v191;
  v35 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v36 = NFLogGetLogger(v35);
  if (v36)
  {
    v37 = (void (*)(uint64_t, const char *, ...))v36;
    v38 = object_getClass(*(id *)(a1 + 32));
    v39 = class_isMetaClass(v38);
    v171 = object_getClassName(*(id *)(a1 + 32));
    v175 = sel_getName(*(SEL *)(a1 + 48));
    v40 = 45;
    if (v39)
      v40 = 43;
    v37(6, "%c[%{public}s %{public}s]:%i bluetoothLogURL present = %d", v40, v171, v175, 125, v33);
  }
  v41 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v42 = NFSharedLogGetLogger(v41);
  v43 = objc_claimAutoreleasedReturnValue(v42);
  if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
  {
    v44 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v44))
      v45 = 43;
    else
      v45 = 45;
    v46 = object_getClassName(*(id *)(a1 + 32));
    v47 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)buf = 67110146;
    v195 = v45;
    v196 = 2082;
    v197 = v46;
    v198 = 2082;
    v199 = v47;
    v200 = 1024;
    v201 = 125;
    v202 = 1024;
    LODWORD(v203) = v33;
    _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i bluetoothLogURL present = %d", buf, 0x28u);
  }

  if (v33)
  {
    v190 = 0;
    v48 = objc_msgSend(objc_alloc((Class)NSDictionary), "initWithContentsOfURL:error:", v32, &v190);
    v49 = v190;
    if (v49)
    {
      v50 = v49;
      v51 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v52 = NFLogGetLogger(v51);
      if (v52)
      {
        v53 = (void (*)(uint64_t, const char *, ...))v52;
        v54 = object_getClass(*(id *)(a1 + 32));
        v55 = class_isMetaClass(v54);
        v172 = object_getClassName(*(id *)(a1 + 32));
        v176 = sel_getName(*(SEL *)(a1 + 48));
        v56 = 45;
        if (v55)
          v56 = 43;
        v53(6, "%c[%{public}s %{public}s]:%i FileError: %@", v56, v172, v176, 129, v50);
      }
      v57 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v58 = NFSharedLogGetLogger(v57);
      v59 = objc_claimAutoreleasedReturnValue(v58);
      if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
      {
        v60 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v60))
          v61 = 43;
        else
          v61 = 45;
        v62 = object_getClassName(*(id *)(a1 + 32));
        v63 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)buf = 67110146;
        v195 = v61;
        v196 = 2082;
        v197 = v62;
        v198 = 2082;
        v199 = v63;
        v200 = 1024;
        v201 = 129;
        v202 = 2112;
        v203 = v50;
        _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i FileError: %@", buf, 0x2Cu);
      }
      goto LABEL_107;
    }
    byte_10032A9F8 = 1;
    v108 = objc_claimAutoreleasedReturnValue(objc_msgSend(v48, "NF_numberForKey:", CFSTR("retrieved")));
    v59 = v108;
    if (v108 && -[NSObject BOOLValue](v108, "BOOLValue"))
    {
      v109 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v110 = NFLogGetLogger(v109);
      if (v110)
      {
        v111 = (void (*)(uint64_t, const char *, ...))v110;
        v112 = object_getClass(*(id *)(a1 + 32));
        v113 = class_isMetaClass(v112);
        v114 = object_getClassName(*(id *)(a1 + 32));
        v180 = sel_getName(*(SEL *)(a1 + 48));
        v115 = 45;
        if (v113)
          v115 = 43;
        v111(6, "%c[%{public}s %{public}s]:%i Log file already retrieved", v115, v114, v180, 136);
      }
      v116 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v117 = NFSharedLogGetLogger(v116);
      v118 = objc_claimAutoreleasedReturnValue(v117);
      if (os_log_type_enabled(v118, OS_LOG_TYPE_DEFAULT))
      {
        v119 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v119))
          v120 = 43;
        else
          v120 = 45;
        v121 = object_getClassName(*(id *)(a1 + 32));
        v122 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)buf = 67109890;
        v195 = v120;
        v196 = 2082;
        v197 = v121;
        v198 = 2082;
        v199 = v122;
        v200 = 1024;
        v201 = 136;
        _os_log_impl((void *)&_mh_execute_header, v118, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Log file already retrieved", buf, 0x22u);
      }
      v123 = v48;
      v48 = 0;
    }
    else
    {
      if (!*(_BYTE *)(a1 + 56))
      {
LABEL_106:
        v50 = 0;
LABEL_107:

        goto LABEL_108;
      }
      v124 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v125 = NFLogGetLogger(v124);
      if (v125)
      {
        v126 = (void (*)(uint64_t, const char *, ...))v125;
        v127 = object_getClass(*(id *)(a1 + 32));
        v128 = class_isMetaClass(v127);
        v129 = object_getClassName(*(id *)(a1 + 32));
        v181 = sel_getName(*(SEL *)(a1 + 48));
        v130 = 45;
        if (v128)
          v130 = 43;
        v126(6, "%c[%{public}s %{public}s]:%i Updating log file as retrieved", v130, v129, v181, 141);
      }
      v131 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v132 = NFSharedLogGetLogger(v131);
      v133 = objc_claimAutoreleasedReturnValue(v132);
      if (os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT))
      {
        v134 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v134))
          v135 = 43;
        else
          v135 = 45;
        v136 = object_getClassName(*(id *)(a1 + 32));
        v137 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)buf = 67109890;
        v195 = v135;
        v196 = 2082;
        v197 = v136;
        v198 = 2082;
        v199 = v137;
        v200 = 1024;
        v201 = 141;
        _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Updating log file as retrieved", buf, 0x22u);
      }

      v138 = objc_alloc((Class)NSString);
      v139 = NSHomeDirectory();
      v140 = (void *)objc_claimAutoreleasedReturnValue(v139);
      v123 = objc_msgSend(v138, "initWithFormat:", CFSTR("%@%@"), v140, CFSTR("/Library/Logs/nfcd_lpem.bin"));

      v118 = objc_msgSend(v48, "mutableCopy");
      -[NSObject setObject:forKeyedSubscript:](v118, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("retrieved"));
      if ((-[NSObject writeToFile:atomically:](v118, "writeToFile:atomically:", v123, 0) & 1) == 0)
      {
        v141 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v142 = NFLogGetLogger(v141);
        if (v142)
        {
          v143 = (void (*)(uint64_t, const char *, ...))v142;
          v144 = object_getClass(*(id *)(a1 + 32));
          v145 = class_isMetaClass(v144);
          v183 = object_getClassName(*(id *)(a1 + 32));
          v146 = sel_getName(*(SEL *)(a1 + 48));
          v147 = 45;
          if (v145)
            v147 = 43;
          v143(3, "%c[%{public}s %{public}s]:%i Failed to update LPEM log as read: %{public}@", v147, v183, v146, 146, v123);
        }
        v148 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v149 = NFSharedLogGetLogger(v148);
        v150 = objc_claimAutoreleasedReturnValue(v149);
        if (os_log_type_enabled(v150, OS_LOG_TYPE_ERROR))
        {
          v151 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v151))
            v152 = 43;
          else
            v152 = 45;
          v184 = object_getClassName(*(id *)(a1 + 32));
          v153 = sel_getName(*(SEL *)(a1 + 48));
          *(_DWORD *)buf = 67110146;
          v195 = v152;
          v196 = 2082;
          v197 = v184;
          v198 = 2082;
          v199 = v153;
          v200 = 1024;
          v201 = 146;
          v202 = 2114;
          v203 = v123;
          _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to update LPEM log as read: %{public}@", buf, 0x2Cu);
        }

      }
    }

    goto LABEL_106;
  }
  if (v34)
  {
    v96 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v97 = NFLogGetLogger(v96);
    if (v97)
    {
      v98 = (void (*)(uint64_t, const char *, ...))v97;
      v99 = object_getClass(*(id *)(a1 + 32));
      v100 = class_isMetaClass(v99);
      v173 = object_getClassName(*(id *)(a1 + 32));
      v179 = sel_getName(*(SEL *)(a1 + 48));
      v101 = 45;
      if (v100)
        v101 = 43;
      v98(3, "%c[%{public}s %{public}s]:%i Failed file check: %@", v101, v173, v179, 152, v34);
    }
    v102 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v103 = NFSharedLogGetLogger(v102);
    v59 = objc_claimAutoreleasedReturnValue(v103);
    if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
    {
      v104 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v104))
        v105 = 43;
      else
        v105 = 45;
      v106 = object_getClassName(*(id *)(a1 + 32));
      v107 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)buf = 67110146;
      v195 = v105;
      v196 = 2082;
      v197 = v106;
      v198 = 2082;
      v199 = v107;
      v200 = 1024;
      v201 = 152;
      v202 = 2112;
      v203 = v34;
      _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed file check: %@", buf, 0x2Cu);
    }
    v48 = 0;
    goto LABEL_106;
  }
  v48 = 0;
  v50 = 0;
LABEL_108:

  if (*(_BYTE *)(a1 + 56))
  {
    v154 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v155 = NFLogGetLogger(v154);
    if (v155)
    {
      v156 = (void (*)(uint64_t, const char *, ...))v155;
      v157 = object_getClass(*(id *)(a1 + 32));
      v158 = class_isMetaClass(v157);
      v159 = object_getClassName(*(id *)(a1 + 32));
      v182 = sel_getName(*(SEL *)(a1 + 48));
      v160 = 45;
      if (v158)
        v160 = 43;
      v156(6, "%c[%{public}s %{public}s]:%i Clearing log data", v160, v159, v182, 161);
    }
    v161 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v162 = NFSharedLogGetLogger(v161);
    v163 = objc_claimAutoreleasedReturnValue(v162);
    if (os_log_type_enabled(v163, OS_LOG_TYPE_DEFAULT))
    {
      v164 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v164))
        v165 = 43;
      else
        v165 = 45;
      v166 = object_getClassName(*(id *)(a1 + 32));
      v167 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)buf = 67109890;
      v195 = v165;
      v196 = 2082;
      v197 = v166;
      v198 = 2082;
      v199 = v167;
      v200 = 1024;
      v201 = 161;
      _os_log_impl((void *)&_mh_execute_header, v163, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Clearing log data", buf, 0x22u);
    }

    v186[0] = _NSConcreteStackBlock;
    v186[1] = 3221225472;
    v186[2] = sub_100138670;
    v186[3] = &unk_1002E86B8;
    v168 = v2;
    v169 = *(_QWORD *)(a1 + 32);
    v187 = v168;
    v188 = v169;
    v189 = *(_QWORD *)(a1 + 48);
    v170 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig embeddedWiredModeWithFD:](NFRoutingConfig, "embeddedWiredModeWithFD:", 2));
    sub_1000E3CEC((void **)v168, v186, CFSTR("erase bt log"), v170);

  }
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

LABEL_49:
}

uint64_t sub_100138670(uint64_t a1)
{
  void *v2;
  NSString *v3;
  void *v4;
  void *v5;
  NSString *v6;
  void *specific;
  uint64_t Logger;
  void (*v9)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  NSObject *v15;
  objc_class *v16;
  int v17;
  const char *v18;
  const char *v19;
  const char *ClassName;
  const char *Name;
  uint8_t buf[4];
  int v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  void *v32;

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "secureElementWrapper"));
  v3 = sub_10009E300(v2, 4);
  v4 = (void *)objc_claimAutoreleasedReturnValue(v3);

  if (!v4)
  {
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "secureElementWrapper"));
    v6 = sub_10009E300(v5, 5);
    v4 = (void *)objc_claimAutoreleasedReturnValue(v6);

    if (!v4)
      return 1;
  }
  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v9 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 40));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 40));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v12 = 45;
    if (isMetaClass)
      v12 = 43;
    v9(3, "%c[%{public}s %{public}s]:%i Failed to erase BT logs %@", v12, ClassName, Name, 172, v4);
  }
  v13 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v14 = NFSharedLogGetLogger(v13);
  v15 = objc_claimAutoreleasedReturnValue(v14);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    v16 = object_getClass(*(id *)(a1 + 40));
    if (class_isMetaClass(v16))
      v17 = 43;
    else
      v17 = 45;
    v18 = object_getClassName(*(id *)(a1 + 40));
    v19 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)buf = 67110146;
    v24 = v17;
    v25 = 2082;
    v26 = v18;
    v27 = 2082;
    v28 = v19;
    v29 = 1024;
    v30 = 172;
    v31 = 2112;
    v32 = v4;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to erase BT logs %@", buf, 0x2Cu);
  }

  return 0;
}

void sub_100139708(uint64_t a1, _QWORD *a2, void *a3)
{
  id v5;
  id v6;

  v6 = a3;
  if (a2)
  {
    if (a2[1])
      v5 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", *a2, a2[1]);
    else
      v5 = 0;
    NFDataRelease(a2);
  }
  else
  {
    v5 = 0;
  }
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();

}

uint64_t sub_100139980(uint64_t result, unint64_t a2)
{
  void *v3;
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  objc_class *v13;
  int v14;
  const char *v15;
  NSObject *v16;
  uint32_t v17;
  __int16 v18;
  void *v19;
  uint64_t v20;
  void (*v21)(uint64_t, const char *, ...);
  objc_class *v22;
  _BOOL4 v23;
  const char *v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  objc_class *v28;
  int v29;
  const char *ClassName;
  const char *Name;
  const char *v32;
  uint8_t buf[4];
  int v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  const char *v38;
  __int16 v39;
  int v40;
  __int16 v41;
  unint64_t v42;

  if (result)
  {
    v3 = (void *)result;
    if (a2 >= 3)
    {
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v6 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(v3);
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(v3);
        Name = sel_getName("assert:");
        v9 = 45;
        if (isMetaClass)
          v9 = 43;
        v6(3, "%c[%{public}s %{public}s]:%i Invalid type: %lu", v9, ClassName, Name, 25, a2);
      }
      v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v11 = NFSharedLogGetLogger(v10);
      v12 = objc_claimAutoreleasedReturnValue(v11);
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        goto LABEL_23;
      v13 = object_getClass(v3);
      if (class_isMetaClass(v13))
        v14 = 43;
      else
        v14 = 45;
      *(_DWORD *)buf = 67110146;
      v34 = v14;
      v35 = 2082;
      v36 = object_getClassName(v3);
      v37 = 2082;
      v38 = sel_getName("assert:");
      v39 = 1024;
      v40 = 25;
      v41 = 2048;
      v42 = a2;
      v15 = "%c[%{public}s %{public}s]:%i Invalid type: %lu";
      v16 = v12;
      v17 = 44;
LABEL_22:
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, v15, buf, v17);
LABEL_23:

      return 0;
    }
    v18 = (*(_BYTE *)(result + a2 + 8))++ + 1;
    if ((v18 & 0x100) != 0)
    {
      v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v20 = NFLogGetLogger(v19);
      if (v20)
      {
        v21 = (void (*)(uint64_t, const char *, ...))v20;
        v22 = object_getClass(v3);
        v23 = class_isMetaClass(v22);
        v24 = object_getClassName(v3);
        v32 = sel_getName("assert:");
        v25 = 45;
        if (v23)
          v25 = 43;
        v21(3, "%c[%{public}s %{public}s]:%i Count overflow", v25, v24, v32, 30);
      }
      v26 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v27 = NFSharedLogGetLogger(v26);
      v12 = objc_claimAutoreleasedReturnValue(v27);
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        goto LABEL_23;
      v28 = object_getClass(v3);
      if (class_isMetaClass(v28))
        v29 = 43;
      else
        v29 = 45;
      *(_DWORD *)buf = 67109890;
      v34 = v29;
      v35 = 2082;
      v36 = object_getClassName(v3);
      v37 = 2082;
      v38 = sel_getName("assert:");
      v39 = 1024;
      v40 = 30;
      v15 = "%c[%{public}s %{public}s]:%i Count overflow";
      v16 = v12;
      v17 = 34;
      goto LABEL_22;
    }
    return 1;
  }
  return result;
}

uint64_t sub_100139C5C(uint64_t result, unint64_t a2)
{
  void *v3;
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  objc_class *v13;
  int v14;
  const char *v15;
  NSObject *v16;
  uint32_t v17;
  unsigned int v18;
  void *v19;
  uint64_t v20;
  void (*v21)(uint64_t, const char *, ...);
  objc_class *v22;
  _BOOL4 v23;
  const char *v24;
  const char *v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  objc_class *v29;
  int v30;
  const char *ClassName;
  const char *Name;
  uint8_t buf[4];
  int v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  const char *v38;
  __int16 v39;
  int v40;
  __int16 v41;
  unint64_t v42;

  if (result)
  {
    v3 = (void *)result;
    if (a2 >= 3)
    {
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v6 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(v3);
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(v3);
        Name = sel_getName("deassert:");
        v9 = 45;
        if (isMetaClass)
          v9 = 43;
        v6(3, "%c[%{public}s %{public}s]:%i Invalid type: %lu", v9, ClassName, Name, 40, a2);
      }
      v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v11 = NFSharedLogGetLogger(v10);
      v12 = objc_claimAutoreleasedReturnValue(v11);
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        goto LABEL_23;
      v13 = object_getClass(v3);
      if (class_isMetaClass(v13))
        v14 = 43;
      else
        v14 = 45;
      *(_DWORD *)buf = 67110146;
      v34 = v14;
      v35 = 2082;
      v36 = object_getClassName(v3);
      v37 = 2082;
      v38 = sel_getName("deassert:");
      v39 = 1024;
      v40 = 40;
      v41 = 2048;
      v42 = a2;
      v15 = "%c[%{public}s %{public}s]:%i Invalid type: %lu";
      v16 = v12;
      v17 = 44;
LABEL_22:
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, v15, buf, v17);
LABEL_23:

      return 0;
    }
    v18 = (*(_BYTE *)(result + a2 + 8))-- - 1;
    if (v18 >= 0x100)
    {
      v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v20 = NFLogGetLogger(v19);
      if (v20)
      {
        v21 = (void (*)(uint64_t, const char *, ...))v20;
        v22 = object_getClass(v3);
        v23 = class_isMetaClass(v22);
        v24 = object_getClassName(v3);
        v25 = sel_getName("deassert:");
        v26 = 45;
        if (v23)
          v26 = 43;
        v21(3, "%c[%{public}s %{public}s]:%i Count underflow", v26, v24, v25, 45);
      }
      v27 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v28 = NFSharedLogGetLogger(v27);
      v12 = objc_claimAutoreleasedReturnValue(v28);
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        goto LABEL_23;
      v29 = object_getClass(v3);
      if (class_isMetaClass(v29))
        v30 = 43;
      else
        v30 = 45;
      *(_DWORD *)buf = 67109890;
      v34 = v30;
      v35 = 2082;
      v36 = object_getClassName(v3);
      v37 = 2082;
      v38 = sel_getName("deassert:");
      v39 = 1024;
      v40 = 45;
      v15 = "%c[%{public}s %{public}s]:%i Count underflow";
      v16 = v12;
      v17 = 34;
      goto LABEL_22;
    }
    return 1;
  }
  return result;
}

void *sub_100139F34(void *result, unint64_t a2)
{
  void *v3;
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  objc_class *v13;
  int v14;
  const char *ClassName;
  const char *Name;
  uint8_t buf[4];
  int v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  unint64_t v26;

  if (result)
  {
    v3 = result;
    if (a2 < 3)
    {
      return (void *)(*((_BYTE *)result + a2 + 8) != 0);
    }
    else
    {
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v6 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(v3);
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(v3);
        Name = sel_getName("isAsserted:");
        v9 = 45;
        if (isMetaClass)
          v9 = 43;
        v6(3, "%c[%{public}s %{public}s]:%i Invalid type: %lu", v9, ClassName, Name, 55, a2);
      }
      v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v11 = NFSharedLogGetLogger(v10);
      v12 = objc_claimAutoreleasedReturnValue(v11);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        v13 = object_getClass(v3);
        if (class_isMetaClass(v13))
          v14 = 43;
        else
          v14 = 45;
        *(_DWORD *)buf = 67110146;
        v18 = v14;
        v19 = 2082;
        v20 = object_getClassName(v3);
        v21 = 2082;
        v22 = sel_getName("isAsserted:");
        v23 = 1024;
        v24 = 55;
        v25 = 2048;
        v26 = a2;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid type: %lu", buf, 0x2Cu);
      }

      return 0;
    }
  }
  return result;
}

NSMutableDictionary *sub_10013A0F4(unsigned __int8 *a1)
{
  NSMutableDictionary *v2;
  void *v3;
  void *v4;
  void *v5;

  if (a1)
  {
    v2 = objc_opt_new(NSMutableDictionary);
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", a1[8]));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v2, "setObject:forKeyedSubscript:", v3, CFSTR("PKForegroundPresentment"));

    v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", a1[9]));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v2, "setObject:forKeyedSubscript:", v4, CFSTR("DefaultAppPresentmentSuppress"));

    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", a1[10]));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v2, "setObject:forKeyedSubscript:", v5, CFSTR("FDDefaultAppPresentmentSuppress"));

  }
  else
  {
    v2 = 0;
  }
  return v2;
}

_QWORD *sub_10013A378(_QWORD *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id v7;
  void *v8;
  objc_super v10;

  v5 = a2;
  v6 = a3;
  if (a1)
  {
    v10.receiver = a1;
    v10.super_class = (Class)NFTagAppProcessorHomeKitAccessory;
    a1 = objc_msgSendSuper2(&v10, "init");
    if (a1)
    {
      v7 = objc_msgSend(objc_alloc((Class)NFXPCEventPublisher), "initWithStreamName:queue:", v5, v6);
      v8 = (void *)a1[1];
      a1[1] = v7;

    }
  }

  return a1;
}

void sub_10013A8E8(id a1)
{
  uint64_t v1;
  void *v2;
  _QWORD v3[6];
  _QWORD v4[6];

  v3[0] = &off_1002FF990;
  v3[1] = &off_1002FF9A8;
  v4[0] = CFSTR("Suica");
  v4[1] = CFSTR("ECP1.Access");
  v3[2] = &off_1002FF9C0;
  v3[3] = &off_1002FF9D8;
  v4[2] = CFSTR("GenericA");
  v4[3] = CFSTR("ECP2");
  v3[4] = &off_1002FF9F0;
  v3[5] = &off_1002FFA08;
  v4[4] = CFSTR("Cathay");
  v4[5] = CFSTR("QuickMode");
  v1 = objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v4, v3, 6));
  v2 = (void *)qword_10032AA00;
  qword_10032AA00 = v1;

}

void sub_10013AA5C(id a1)
{
  uint64_t v1;
  void *v2;
  _QWORD v3[6];
  _QWORD v4[6];

  v3[0] = CFSTR("Suica");
  v3[1] = CFSTR("ECP1.Access");
  v4[0] = &off_1002FF990;
  v4[1] = &off_1002FF9A8;
  v3[2] = CFSTR("GenericA");
  v3[3] = CFSTR("ECP2");
  v4[2] = &off_1002FF9C0;
  v4[3] = &off_1002FF9D8;
  v3[4] = CFSTR("Cathay");
  v3[5] = CFSTR("QuickMode");
  v4[4] = &off_1002FF9F0;
  v4[5] = &off_1002FFA08;
  v1 = objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v4, v3, 6));
  v2 = (void *)qword_10032AA10;
  qword_10032AA10 = v1;

}

void sub_10013C3D4(void *a1, void *a2, void *a3, void *a4, unsigned int a5, void *a6)
{
  id v10;
  id v11;
  id v12;
  void *v13;
  id v14;
  void *v15;
  NSObject *v16;
  uint64_t v17;
  void *v18;
  id v19;
  id v20;
  id v21;
  uint64_t v22;
  void *v23;
  void *v24;
  NSObject *v25;
  void *v26;
  id v27;
  void *specific;
  uint64_t Logger;
  void (*v30)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  objc_class *v37;
  int v38;
  const char *v39;
  const char *v40;
  id v41;
  NSMutableDictionary *v42;
  void *v43;
  uint64_t v44;
  void (*v45)(uint64_t, const char *, ...);
  objc_class *v46;
  _BOOL4 v47;
  const char *v48;
  uint64_t v49;
  void *v50;
  uint64_t v51;
  NSObject *v52;
  objc_class *v53;
  int v54;
  const char *v55;
  const char *v56;
  void *v57;
  void *v58;
  id v59;
  void *v60;
  void *v61;
  void *v62;
  void *v63;
  void *v64;
  void *v65;
  void *v66;
  void *v67;
  id v68;
  void *v69;
  void *v70;
  void *v71;
  void *v72;
  void *v73;
  void *v74;
  uint64_t v75;
  void (*v76)(uint64_t, const char *, ...);
  objc_class *v77;
  _BOOL4 v78;
  uint64_t v79;
  void *v80;
  uint64_t v81;
  objc_class *v82;
  int v83;
  const char *v84;
  const char *Name;
  const char *v86;
  const char *v87;
  uint64_t v88;
  NSObject *v89;
  void *v90;
  void *v91;
  id v93;
  id v94;
  uint64_t v95;
  id v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  uint8_t buf[8];
  __int16 v106;
  const char *v107;
  __int16 v108;
  const char *v109;
  __int16 v110;
  int v111;
  __int16 v112;
  id v113;
  __int16 v114;
  void *v115;
  _BYTE v116[128];
  _BYTE v117[128];

  v10 = a2;
  v11 = a3;
  v12 = a4;
  v93 = a6;
  if (a1)
  {
    v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "getSecureElementWrapperAndSetRouting"));
    v14 = sub_10022F2F0(v13, v11);
    v15 = (void *)objc_claimAutoreleasedReturnValue(v14);

    v96 = a1;
    if (v15)
    {
      v103 = 0u;
      v104 = 0u;
      v101 = 0u;
      v102 = 0u;
      v16 = v10;
      v94 = -[NSObject countByEnumeratingWithState:objects:count:](v16, "countByEnumeratingWithState:objects:count:", &v101, v117, 16);
      if (!v94)
        goto LABEL_59;
      v88 = *(_QWORD *)v102;
      v90 = v15;
      v91 = v12;
      v89 = v16;
      while (1)
      {
        v17 = 0;
        do
        {
          if (*(_QWORD *)v102 != v88)
            objc_enumerationMutation(v16);
          v95 = v17;
          v18 = *(void **)(*((_QWORD *)&v101 + 1) + 8 * v17);
          v97 = 0u;
          v98 = 0u;
          v99 = 0u;
          v100 = 0u;
          v19 = v93;
          v20 = objc_msgSend(v19, "countByEnumeratingWithState:objects:count:", &v97, v116, 16);
          if (v20)
          {
            v21 = v20;
            v22 = *(_QWORD *)v98;
            do
            {
              v23 = 0;
              do
              {
                if (*(_QWORD *)v98 != v22)
                  objc_enumerationMutation(v19);
                v24 = *(void **)(*((_QWORD *)&v97 + 1) + 8 * (_QWORD)v23);
                v25 = objc_claimAutoreleasedReturnValue(objc_msgSend(v24, "objectForKeyedSubscript:", CFSTR("appletIdentifier")));
                if (objc_msgSend(v11, "caseInsensitiveCompare:", v25))
                  goto LABEL_14;
                v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v24, "objectForKeyedSubscript:", CFSTR("keyIdentifier")));
                v27 = objc_msgSend(v18, "caseInsensitiveCompare:", v26);

                if (!v27)
                {
                  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  Logger = NFLogGetLogger(specific);
                  if (Logger)
                  {
                    v30 = (void (*)(uint64_t, const char *, ...))Logger;
                    Class = object_getClass(v96);
                    isMetaClass = class_isMetaClass(Class);
                    ClassName = object_getClassName(v96);
                    Name = sel_getName("_addKeysFromArray:forAid:expressInfo:supportsUWB:intoPassArray:");
                    v34 = 45;
                    if (isMetaClass)
                      v34 = 43;
                    v30(6, "%c[%{public}s %{public}s]:%i aid:%{public}@ key:%{public}@ is already in the config", v34, ClassName, Name, 289, v11, v18);
                  }
                  v35 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  v36 = NFSharedLogGetLogger(v35);
                  v25 = objc_claimAutoreleasedReturnValue(v36);
                  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
                  {
                    v37 = object_getClass(v96);
                    if (class_isMetaClass(v37))
                      v38 = 43;
                    else
                      v38 = 45;
                    v39 = object_getClassName(v96);
                    v40 = sel_getName("_addKeysFromArray:forAid:expressInfo:supportsUWB:intoPassArray:");
                    *(_DWORD *)buf = 67110402;
                    *(_DWORD *)&buf[4] = v38;
                    v106 = 2082;
                    v107 = v39;
                    v108 = 2082;
                    v109 = v40;
                    v110 = 1024;
                    v111 = 289;
                    v112 = 2114;
                    v113 = v11;
                    v114 = 2114;
                    v115 = v18;
                    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i aid:%{public}@ key:%{public}@ is already in the config", buf, 0x36u);
                  }
LABEL_14:

                }
                v23 = (char *)v23 + 1;
              }
              while (v21 != v23);
              v41 = objc_msgSend(v19, "countByEnumeratingWithState:objects:count:", &v97, v116, 16);
              v21 = v41;
            }
            while (v41);
          }

          v42 = objc_opt_new(NSMutableDictionary);
          v43 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v44 = NFLogGetLogger(v43);
          if (v44)
          {
            v45 = (void (*)(uint64_t, const char *, ...))v44;
            v46 = object_getClass(v96);
            v47 = class_isMetaClass(v46);
            v48 = object_getClassName(v96);
            v86 = sel_getName("_addKeysFromArray:forAid:expressInfo:supportsUWB:intoPassArray:");
            v49 = 45;
            if (v47)
              v49 = 43;
            v45(6, "%c[%{public}s %{public}s]:%i new pass for aid:%{public}@ key:%{public}@", v49, v48, v86, 295, v11, v18);
          }
          v50 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v51 = NFSharedLogGetLogger(v50);
          v52 = objc_claimAutoreleasedReturnValue(v51);
          v12 = v91;
          if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
          {
            v53 = object_getClass(v96);
            if (class_isMetaClass(v53))
              v54 = 43;
            else
              v54 = 45;
            v55 = object_getClassName(v96);
            v56 = sel_getName("_addKeysFromArray:forAid:expressInfo:supportsUWB:intoPassArray:");
            *(_DWORD *)buf = 67110402;
            *(_DWORD *)&buf[4] = v54;
            v106 = 2082;
            v107 = v55;
            v108 = 2082;
            v109 = v56;
            v110 = 1024;
            v111 = 295;
            v112 = 2114;
            v113 = v11;
            v114 = 2114;
            v115 = v18;
            _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i new pass for aid:%{public}@ key:%{public}@", buf, 0x36u);
          }

          v57 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v91, "objectForKeyedSubscript:", CFSTR("ExpressType")));
          -[NSMutableDictionary setObject:forKeyedSubscript:](v42, "setObject:forKeyedSubscript:", v57, CFSTR("ExpressType"));

          -[NSMutableDictionary setObject:forKeyedSubscript:](v42, "setObject:forKeyedSubscript:", v11, CFSTR("appletIdentifier"));
          -[NSMutableDictionary setObject:forKeyedSubscript:](v42, "setObject:forKeyedSubscript:", v18, CFSTR("keyIdentifier"));
          -[NSMutableDictionary setObject:forKeyedSubscript:](v42, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("expressEnabled"));
          v58 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", a5));
          -[NSMutableDictionary setObject:forKeyedSubscript:](v42, "setObject:forKeyedSubscript:", v58, CFSTR("UWBExpressEnabled"));

          *(_QWORD *)buf = 0;
          *(_QWORD *)buf = arc4random();
          *(_QWORD *)buf = arc4random() | (*(_QWORD *)buf << 32);
          v59 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", buf, 8);
          v60 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v59, "NF_asHexString"));
          -[NSMutableDictionary setObject:forKeyedSubscript:](v42, "setObject:forKeyedSubscript:", v60, CFSTR("passUniqueID"));

          v61 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v91, "objectForKeyedSubscript:", CFSTR("ECP2Info")));
          if (v61)
          {
            v62 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v91, "objectForKeyedSubscript:", CFSTR("ECP2Info")));
            -[NSMutableDictionary setObject:forKeyedSubscript:](v42, "setObject:forKeyedSubscript:", v62, CFSTR("ECP2Info"));

          }
          v15 = v90;
          v63 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v90, "moduleIdentifier"));
          -[NSMutableDictionary setObject:forKeyedSubscript:](v42, "setObject:forKeyedSubscript:", v63, CFSTR("moduleIdentifier"));

          v64 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", objc_msgSend(v90, "groupActivationStyle")));
          -[NSMutableDictionary setObject:forKeyedSubscript:](v42, "setObject:forKeyedSubscript:", v64, CFSTR("groupActivationStyle"));

          v65 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v90, "groupHeadID"));
          if (v65)
          {
            v66 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v90, "groupHeadID"));
            -[NSMutableDictionary setObject:forKeyedSubscript:](v42, "setObject:forKeyedSubscript:", v66, CFSTR("groupHead"));

          }
          v67 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v90, "groupMemberIDs"));
          v68 = objc_msgSend(v67, "count");

          if (v68)
          {
            v69 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v90, "groupMemberIDs"));
            -[NSMutableDictionary setObject:forKeyedSubscript:](v42, "setObject:forKeyedSubscript:", v69, CFSTR("groupMembers"));

          }
          v70 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v91, "objectForKeyedSubscript:", CFSTR("aliroGroupResolvingKeys")));

          if (v70)
          {
            v71 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v91, "objectForKeyedSubscript:", CFSTR("aliroGroupResolvingKeys")));
            -[NSMutableDictionary setObject:forKeyedSubscript:](v42, "setObject:forKeyedSubscript:", v71, CFSTR("aliroGroupResolvingKeys"));

          }
          v72 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v91, "objectForKeyedSubscript:", CFSTR("associatedReaderIdentifiers")));

          if (v72)
          {
            v73 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v91, "objectForKeyedSubscript:", CFSTR("associatedReaderIdentifiers")));
            -[NSMutableDictionary setObject:forKeyedSubscript:](v42, "setObject:forKeyedSubscript:", v73, CFSTR("associatedReaderIdentifiers"));

          }
          objc_msgSend(v19, "addObject:", v42);

          v17 = v95 + 1;
          v16 = v89;
        }
        while ((id)(v95 + 1) != v94);
        v94 = -[NSObject countByEnumeratingWithState:objects:count:](v89, "countByEnumeratingWithState:objects:count:", &v101, v117, 16);
        if (!v94)
          goto LABEL_59;
      }
    }
    v74 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v75 = NFLogGetLogger(v74);
    if (v75)
    {
      v76 = (void (*)(uint64_t, const char *, ...))v75;
      v77 = object_getClass(a1);
      v78 = class_isMetaClass(v77);
      v84 = object_getClassName(a1);
      v87 = sel_getName("_addKeysFromArray:forAid:expressInfo:supportsUWB:intoPassArray:");
      v79 = 45;
      if (v78)
        v79 = 43;
      v76(3, "%c[%{public}s %{public}s]:%i no applet for AID: %{public}@ - skip", v79, v84, v87, 280, v11);
    }
    v80 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v81 = NFSharedLogGetLogger(v80);
    v16 = objc_claimAutoreleasedReturnValue(v81);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      v82 = object_getClass(v96);
      if (class_isMetaClass(v82))
        v83 = 43;
      else
        v83 = 45;
      *(_DWORD *)buf = 67110146;
      *(_DWORD *)&buf[4] = v83;
      v106 = 2082;
      v107 = object_getClassName(v96);
      v108 = 2082;
      v109 = sel_getName("_addKeysFromArray:forAid:expressInfo:supportsUWB:intoPassArray:");
      v110 = 1024;
      v111 = 280;
      v112 = 2114;
      v113 = v11;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i no applet for AID: %{public}@ - skip", buf, 0x2Cu);
    }
LABEL_59:

  }
}

void sub_10013CDCC(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  id v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  NSMutableDictionary *v17;
  void *v18;
  uint64_t v19;
  id v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  id v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  id v34;
  void *v35;
  void *specific;
  uint64_t Logger;
  void (*v38)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v41;
  void *v42;
  uint64_t v43;
  NSObject *v44;
  objc_class *v45;
  int v46;
  const char *v47;
  const char *v48;
  const char *ClassName;
  const char *Name;
  unint64_t v51;
  uint8_t buf[4];
  int v53;
  __int16 v54;
  const char *v55;
  __int16 v56;
  const char *v57;
  __int16 v58;
  int v59;
  __int16 v60;
  id v61;

  v5 = a2;
  v6 = a3;
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "objectForKeyedSubscript:", CFSTR("keyIdentifiersUWB")));

  if (v7)
  {
    v8 = *(void **)(a1 + 32);
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "objectForKeyedSubscript:", CFSTR("keyIdentifiersUWB")));
    sub_10013C3D4(v8, v9, v5, v6, 1u, *(void **)(a1 + 40));

  }
  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "objectForKeyedSubscript:", CFSTR("keyIdentifiers")));

  if (v10)
  {
    v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "objectForKeyedSubscript:", CFSTR("keyIdentifiers")));
    v12 = objc_msgSend(v11, "mutableCopy");

    v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "objectForKeyedSubscript:", CFSTR("keyIdentifiersUWB")));
    if (v13)
    {
      v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "objectForKeyedSubscript:", CFSTR("keyIdentifiersUWB")));
      objc_msgSend(v12, "removeObjectsInArray:", v14);

    }
    sub_10013C3D4(*(void **)(a1 + 32), v12, v5, v6, 0, *(void **)(a1 + 40));

  }
  v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "objectForKeyedSubscript:", CFSTR("keyIdentifiersUWB")));
  if (v15)
  {

  }
  else
  {
    v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "objectForKeyedSubscript:", CFSTR("keyIdentifiers")));

    if (!v16)
    {
      v17 = objc_opt_new(NSMutableDictionary);
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "objectForKeyedSubscript:", CFSTR("ExpressType")));
      -[NSMutableDictionary setObject:forKeyedSubscript:](v17, "setObject:forKeyedSubscript:", v18, CFSTR("ExpressType"));

      -[NSMutableDictionary setObject:forKeyedSubscript:](v17, "setObject:forKeyedSubscript:", v5, CFSTR("appletIdentifier"));
      -[NSMutableDictionary setObject:forKeyedSubscript:](v17, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("expressEnabled"));
      v19 = arc4random();
      v51 = arc4random() | (unint64_t)(v19 << 32);
      v20 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &v51, 8);
      v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "NF_asHexString"));
      -[NSMutableDictionary setObject:forKeyedSubscript:](v17, "setObject:forKeyedSubscript:", v21, CFSTR("passUniqueID"));

      v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "objectForKeyedSubscript:", CFSTR("inSessionOnly")));
      if (v22)
      {
        v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "objectForKeyedSubscript:", CFSTR("inSessionOnly")));
        -[NSMutableDictionary setObject:forKeyedSubscript:](v17, "setObject:forKeyedSubscript:", v23, CFSTR("inSessionOnly"));

      }
      v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "objectForKeyedSubscript:", CFSTR("ECP2Info")));

      if (v24)
      {
        v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "objectForKeyedSubscript:", CFSTR("ECP2Info")));
        -[NSMutableDictionary setObject:forKeyedSubscript:](v17, "setObject:forKeyedSubscript:", v25, CFSTR("ECP2Info"));

      }
      v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "getSecureElementWrapperAndSetRouting"));
      v27 = sub_10022F2F0(v26, v5);
      v28 = (void *)objc_claimAutoreleasedReturnValue(v27);

      if (v28)
      {
        v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "moduleIdentifier"));
        -[NSMutableDictionary setObject:forKeyedSubscript:](v17, "setObject:forKeyedSubscript:", v29, CFSTR("moduleIdentifier"));

        v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", objc_msgSend(v28, "groupActivationStyle")));
        -[NSMutableDictionary setObject:forKeyedSubscript:](v17, "setObject:forKeyedSubscript:", v30, CFSTR("groupActivationStyle"));

        v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "groupHeadID"));
        if (v31)
        {
          v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "groupHeadID"));
          -[NSMutableDictionary setObject:forKeyedSubscript:](v17, "setObject:forKeyedSubscript:", v32, CFSTR("groupHead"));

        }
        v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "groupMemberIDs"));
        v34 = objc_msgSend(v33, "count");

        if (v34)
        {
          v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "groupMemberIDs"));
          -[NSMutableDictionary setObject:forKeyedSubscript:](v17, "setObject:forKeyedSubscript:", v35, CFSTR("groupMembers"));

        }
        objc_msgSend(*(id *)(a1 + 40), "addObject:", v17);
      }
      else
      {
        specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        Logger = NFLogGetLogger(specific);
        if (Logger)
        {
          v38 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(*(id *)(a1 + 32));
          isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(*(id *)(a1 + 32));
          Name = sel_getName(*(SEL *)(a1 + 48));
          v41 = 45;
          if (isMetaClass)
            v41 = 43;
          v38(3, "%c[%{public}s %{public}s]:%i no applet for AID: %{public}@ - skip", v41, ClassName, Name, 368, v5, v51);
        }
        v42 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v43 = NFSharedLogGetLogger(v42);
        v44 = objc_claimAutoreleasedReturnValue(v43);
        if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
        {
          v45 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v45))
            v46 = 43;
          else
            v46 = 45;
          v47 = object_getClassName(*(id *)(a1 + 32));
          v48 = sel_getName(*(SEL *)(a1 + 48));
          *(_DWORD *)buf = 67110146;
          v53 = v46;
          v54 = 2082;
          v55 = v47;
          v56 = 2082;
          v57 = v48;
          v58 = 1024;
          v59 = 368;
          v60 = 2114;
          v61 = v5;
          _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i no applet for AID: %{public}@ - skip", buf, 0x2Cu);
        }

      }
    }
  }

}

uint64_t sub_10013DF30(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_10013DF40(uint64_t a1)
{

}

void sub_10013DF48(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  void *v7;
  void *v8;
  id v9;

  v9 = a2;
  v5 = a3;
  if (objc_msgSend(v5, "count"))
  {
    v6 = sub_10022F2F0(*(void **)(a1 + 32), v9);
    v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "disableExpressForKeys:onApplet:", v5, v7));
    if (v8)
      objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40), v8);

  }
}

void sub_10013F1E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43)
{
  _Block_object_dispose(&a43, 8);
  _Unwind_Resume(a1);
}

void sub_1001400D4(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  void *v4;
  void *v5;
  uint64_t v6;
  void *v7;
  id WeakRetained;
  uint64_t v9;
  void (*v10)(uint64_t, const char *, ...);
  objc_class *v11;
  _BOOL4 v12;
  const char *v13;
  const char *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  objc_class *v19;
  int v20;
  const char *v21;
  const char *v22;
  void *v23;
  void *specific;
  uint64_t Logger;
  void (*v26)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  NSObject *v33;
  objc_class *v34;
  int v35;
  const char *v36;
  const char *v37;
  const char *Name;
  uint8_t buf[4];
  int v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  const char *v44;
  __int16 v45;
  int v46;
  __int16 v47;
  void *v48;

  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 168) = 1;
  v2 = NFSharedSignpostLog(a1);
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_signpost_enabled(v3))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v3, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "_NFSecureElementReaderSession+handleReaderBurnoutTimer", "", buf, 2u);
  }

  v4 = (void *)objc_claimAutoreleasedReturnValue(+[_NFHardwareManager sharedHardwareManager](_NFHardwareManager, "sharedHardwareManager"));
  v5 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig embeddedWiredMode](NFRoutingConfig, "embeddedWiredMode"));
  v6 = objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "setRoutingConfig:", v5));

  if (v6)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v26 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 40));
      v30 = 45;
      if (isMetaClass)
        v30 = 43;
      v26(3, "%c[%{public}s %{public}s]:%i Failed to reset routing. Critical - exiting", v30, ClassName, Name, 127);
    }
    v31 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v32 = NFSharedLogGetLogger(v31);
    v33 = objc_claimAutoreleasedReturnValue(v32);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      v34 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v34))
        v35 = 43;
      else
        v35 = 45;
      v36 = object_getClassName(*(id *)(a1 + 32));
      v37 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)buf = 67109890;
      v40 = v35;
      v41 = 2082;
      v42 = v36;
      v43 = 2082;
      v44 = v37;
      v45 = 1024;
      v46 = 127;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to reset routing. Critical - exiting", buf, 0x22u);
    }

    sub_1001FB2A8(*(void **)(*(_QWORD *)(a1 + 32) + 192));
    exit(1);
  }
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "remoteObject"));
  objc_msgSend(v7, "didReceiveThermalIndication:", 1);

  WeakRetained = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 200));
  sub_10019D694((uint64_t)WeakRetained, *(void **)(a1 + 32));

  v9 = NFLogGetLogger(2);
  if (v9)
  {
    v10 = (void (*)(uint64_t, const char *, ...))v9;
    v11 = object_getClass(*(id *)(a1 + 32));
    v12 = class_isMetaClass(v11);
    v13 = object_getClassName(*(id *)(a1 + 32));
    v14 = sel_getName(*(SEL *)(a1 + 40));
    v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v16 = 45;
    if (v12)
      v16 = 43;
    v10(6, "%c[%{public}s %{public}s]:%i NFC Reader mode terminated: %@", v16, v13, v14, 134, v15);

  }
  v17 = NFSharedLogGetLogger(2);
  v18 = objc_claimAutoreleasedReturnValue(v17);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    v19 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v19))
      v20 = 43;
    else
      v20 = 45;
    v21 = object_getClassName(*(id *)(a1 + 32));
    v22 = sel_getName(*(SEL *)(a1 + 40));
    v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    *(_DWORD *)buf = 67110146;
    v40 = v20;
    v41 = 2082;
    v42 = v21;
    v43 = 2082;
    v44 = v22;
    v45 = 1024;
    v46 = 134;
    v47 = 2112;
    v48 = v23;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i NFC Reader mode terminated: %@", buf, 0x2Cu);

  }
  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 169) = 0;
}

void sub_100140EE4(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  NSObject *v11;
  objc_class *v12;
  int v13;
  const char *v14;
  const char *v15;
  void *v16;
  uint64_t v17;
  void (*v18)(uint64_t, const char *, ...);
  objc_class *v19;
  _BOOL4 v20;
  const char *v21;
  const char *v22;
  void *v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  NSObject *v27;
  objc_class *v28;
  int v29;
  const char *v30;
  const char *v31;
  void *v32;
  uint64_t v33;
  id v34;
  void *v35;
  void *v36;
  void *v37;
  id v38;
  void *v39;
  id v40;
  void *v41;
  uint64_t v42;
  void (*v43)(uint64_t, const char *, ...);
  objc_class *v44;
  _BOOL4 v45;
  const char *v46;
  uint64_t v47;
  void *v48;
  uint64_t v49;
  NSObject *v50;
  objc_class *v51;
  int v52;
  const char *v53;
  const char *v54;
  uint64_t v55;
  id v56;
  const char *Name;
  const char *v58;
  NSErrorUserInfoKey v59;
  void *v60;
  uint8_t buf[4];
  int v62;
  __int16 v63;
  const char *v64;
  __int16 v65;
  const char *v66;
  __int16 v67;
  int v68;
  __int16 v69;
  void *v70;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    v8 = 45;
    if (isMetaClass)
      v8 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i ", v8, ClassName, Name, 192);
  }
  v9 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v10 = NFSharedLogGetLogger(v9);
  v11 = objc_claimAutoreleasedReturnValue(v10);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v12 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v12))
      v13 = 43;
    else
      v13 = 45;
    v14 = object_getClassName(*(id *)(a1 + 32));
    v15 = sel_getName(*(SEL *)(a1 + 56));
    *(_DWORD *)buf = 67109890;
    v62 = v13;
    v63 = 2082;
    v64 = v14;
    v65 = 2082;
    v66 = v15;
    v67 = 1024;
    v68 = 192;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
  }

  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v39 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
    v40 = sub_10022DCC4(v39);

    v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "selectApplets:", *(_QWORD *)(a1 + 40)));
    if (v35)
    {
      v41 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v42 = NFLogGetLogger(v41);
      if (v42)
      {
        v43 = (void (*)(uint64_t, const char *, ...))v42;
        v44 = object_getClass(*(id *)(a1 + 32));
        v45 = class_isMetaClass(v44);
        v46 = object_getClassName(*(id *)(a1 + 32));
        v58 = sel_getName(*(SEL *)(a1 + 56));
        v47 = 45;
        if (v45)
          v47 = 43;
        v43(3, "%c[%{public}s %{public}s]:%i Failed to select applets", v47, v46, v58, 199);
      }
      v48 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v49 = NFSharedLogGetLogger(v48);
      v50 = objc_claimAutoreleasedReturnValue(v49);
      if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
      {
        v51 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v51))
          v52 = 43;
        else
          v52 = 45;
        v53 = object_getClassName(*(id *)(a1 + 32));
        v54 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)buf = 67109890;
        v62 = v52;
        v63 = 2082;
        v64 = v53;
        v65 = 2082;
        v66 = v54;
        v67 = 1024;
        v68 = 199;
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select applets", buf, 0x22u);
      }
    }
    else
    {
      v55 = *(_QWORD *)(a1 + 32);
      v56 = *(id *)(a1 + 40);
      v50 = *(NSObject **)(v55 + 160);
      *(_QWORD *)(v55 + 160) = v56;
    }

    (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
    goto LABEL_24;
  }
  v16 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v17 = NFLogGetLogger(v16);
  if (v17)
  {
    v18 = (void (*)(uint64_t, const char *, ...))v17;
    v19 = object_getClass(*(id *)(a1 + 32));
    v20 = class_isMetaClass(v19);
    v21 = object_getClassName(*(id *)(a1 + 32));
    v22 = sel_getName(*(SEL *)(a1 + 56));
    v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v24 = 45;
    if (v20)
      v24 = 43;
    v18(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v24, v21, v22, 193, v23);

  }
  v25 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v26 = NFSharedLogGetLogger(v25);
  v27 = objc_claimAutoreleasedReturnValue(v26);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
  {
    v28 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v28))
      v29 = 43;
    else
      v29 = 45;
    v30 = object_getClassName(*(id *)(a1 + 32));
    v31 = sel_getName(*(SEL *)(a1 + 56));
    v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v62 = v29;
    v63 = 2082;
    v64 = v30;
    v65 = 2082;
    v66 = v31;
    v67 = 1024;
    v68 = 193;
    v69 = 2114;
    v70 = v32;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v33 = *(_QWORD *)(a1 + 48);
  if (v33)
  {
    v34 = objc_alloc((Class)NSError);
    v35 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v59 = NSLocalizedDescriptionKey;
    v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v60 = v36;
    v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v60, &v59, 1));
    v38 = objc_msgSend(v34, "initWithDomain:code:userInfo:", v35, 54, v37);
    (*(void (**)(uint64_t, id))(v33 + 16))(v33, v38);

LABEL_24:
  }
}

void sub_1001414B8(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  NSObject *v11;
  objc_class *v12;
  int v13;
  const char *v14;
  const char *v15;
  void *v16;
  uint64_t v17;
  void (*v18)(uint64_t, const char *, ...);
  objc_class *v19;
  _BOOL4 v20;
  const char *v21;
  const char *v22;
  void *v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  NSObject *v27;
  objc_class *v28;
  int v29;
  const char *v30;
  const char *v31;
  void *v32;
  uint64_t v33;
  id v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  uint64_t v40;
  id v41;
  void *v42;
  void *v43;
  uint64_t v44;
  void (*v45)(uint64_t, const char *, ...);
  objc_class *v46;
  _BOOL4 v47;
  const char *v48;
  uint64_t v49;
  void *v50;
  uint64_t v51;
  NSObject *v52;
  objc_class *v53;
  int v54;
  const char *v55;
  const char *v56;
  id v57;
  void *v58;
  void *v59;
  uint64_t v60;
  uint64_t v61;
  NSObject *WeakRetained;
  _BOOL4 v63;
  unsigned int v64;
  const char *Name;
  const char *v66;
  NSErrorUserInfoKey v67;
  void *v68;
  NSErrorUserInfoKey v69;
  void *v70;
  uint8_t buf[4];
  unsigned int v72;
  __int16 v73;
  const char *v74;
  __int16 v75;
  const char *v76;
  __int16 v77;
  int v78;
  __int16 v79;
  void *v80;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v8 = 45;
    if (isMetaClass)
      v8 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i ", v8, ClassName, Name, 211);
  }
  v9 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v10 = NFSharedLogGetLogger(v9);
  v11 = objc_claimAutoreleasedReturnValue(v10);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v12 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v12))
      v13 = 43;
    else
      v13 = 45;
    v14 = object_getClassName(*(id *)(a1 + 32));
    v15 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)buf = 67109890;
    v72 = v13;
    v73 = 2082;
    v74 = v14;
    v75 = 2082;
    v76 = v15;
    v77 = 1024;
    v78 = 211;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
  }

  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v42 = *(void **)(*(_QWORD *)(a1 + 32) + 160);
    if (v42 && objc_msgSend(v42, "count"))
    {
      if (*(_BYTE *)(*(_QWORD *)(a1 + 32) + 169))
      {
        v35 = 0;
      }
      else
      {
        v58 = (void *)objc_claimAutoreleasedReturnValue(+[_NFHardwareManager sharedHardwareManager](_NFHardwareManager, "sharedHardwareManager"));
        v59 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig secureElementAsReaderMode](NFRoutingConfig, "secureElementAsReaderMode"));
        v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v58, "setRoutingConfig:", v59));

        v61 = NFSharedSignpostLog(v60);
        WeakRetained = objc_claimAutoreleasedReturnValue(v61);
        v63 = os_signpost_enabled(WeakRetained);
        if (v35)
        {
          if (v63)
          {
            v64 = objc_msgSend(v35, "code");
            *(_DWORD *)buf = 67109120;
            v72 = v64;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, WeakRetained, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "_NFSecureElementReaderSession+se_polling", "begin, error.code: %d", buf, 8u);
          }
        }
        else
        {
          if (v63)
          {
            *(_WORD *)buf = 0;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, WeakRetained, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "_NFSecureElementReaderSession+se_polling", "begin", buf, 2u);
          }

          *(_BYTE *)(*(_QWORD *)(a1 + 32) + 169) = 1;
          WeakRetained = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 200));
          sub_10019E124((uint64_t)WeakRetained, *(void **)(a1 + 32));
        }

      }
      (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
      goto LABEL_25;
    }
    v43 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v44 = NFLogGetLogger(v43);
    if (v44)
    {
      v45 = (void (*)(uint64_t, const char *, ...))v44;
      v46 = object_getClass(*(id *)(a1 + 32));
      v47 = class_isMetaClass(v46);
      v48 = object_getClassName(*(id *)(a1 + 32));
      v66 = sel_getName(*(SEL *)(a1 + 48));
      v49 = 45;
      if (v47)
        v49 = 43;
      v45(3, "%c[%{public}s %{public}s]:%i Invalid applets", v49, v48, v66, 217);
    }
    v50 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v51 = NFSharedLogGetLogger(v50);
    v52 = objc_claimAutoreleasedReturnValue(v51);
    if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
    {
      v53 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v53))
        v54 = 43;
      else
        v54 = 45;
      v55 = object_getClassName(*(id *)(a1 + 32));
      v56 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)buf = 67109890;
      v72 = v54;
      v73 = 2082;
      v74 = v55;
      v75 = 2082;
      v76 = v56;
      v77 = 1024;
      v78 = 217;
      _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid applets", buf, 0x22u);
    }

    v33 = *(_QWORD *)(a1 + 40);
    v57 = objc_alloc((Class)NSError);
    v35 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v67 = NSLocalizedDescriptionKey;
    v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid Parameter"));
    v68 = v36;
    v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v68, &v67, 1));
    v38 = v57;
    v39 = v35;
    v40 = 10;
LABEL_24:
    v41 = objc_msgSend(v38, "initWithDomain:code:userInfo:", v39, v40, v37);
    (*(void (**)(uint64_t, id))(v33 + 16))(v33, v41);

LABEL_25:
    return;
  }
  v16 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v17 = NFLogGetLogger(v16);
  if (v17)
  {
    v18 = (void (*)(uint64_t, const char *, ...))v17;
    v19 = object_getClass(*(id *)(a1 + 32));
    v20 = class_isMetaClass(v19);
    v21 = object_getClassName(*(id *)(a1 + 32));
    v22 = sel_getName(*(SEL *)(a1 + 48));
    v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v24 = 45;
    if (v20)
      v24 = 43;
    v18(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v24, v21, v22, 212, v23);

  }
  v25 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v26 = NFSharedLogGetLogger(v25);
  v27 = objc_claimAutoreleasedReturnValue(v26);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
  {
    v28 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v28))
      v29 = 43;
    else
      v29 = 45;
    v30 = object_getClassName(*(id *)(a1 + 32));
    v31 = sel_getName(*(SEL *)(a1 + 48));
    v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v72 = v29;
    v73 = 2082;
    v74 = v30;
    v75 = 2082;
    v76 = v31;
    v77 = 1024;
    v78 = 212;
    v79 = 2114;
    v80 = v32;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v33 = *(_QWORD *)(a1 + 40);
  if (v33)
  {
    v34 = objc_alloc((Class)NSError);
    v35 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v69 = NSLocalizedDescriptionKey;
    v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v70 = v36;
    v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v70, &v69, 1));
    v38 = v34;
    v39 = v35;
    v40 = 54;
    goto LABEL_24;
  }
}

void sub_100141C24(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  NSObject *v11;
  objc_class *v12;
  int v13;
  const char *v14;
  const char *v15;
  void *v16;
  uint64_t v17;
  void (*v18)(uint64_t, const char *, ...);
  objc_class *v19;
  _BOOL4 v20;
  const char *v21;
  const char *v22;
  void *v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  NSObject *v27;
  objc_class *v28;
  int v29;
  const char *v30;
  const char *v31;
  void *v32;
  uint64_t v33;
  id v34;
  void *v35;
  void *v36;
  void *v37;
  id v38;
  void *v39;
  void *v40;
  uint64_t v41;
  uint64_t v42;
  NSObject *v43;
  unsigned int v44;
  const char *v45;
  NSObject *v46;
  uint32_t v47;
  id WeakRetained;
  uint64_t v49;
  void (*v50)(uint64_t, const char *, ...);
  objc_class *v51;
  _BOOL4 v52;
  const char *v53;
  const char *v54;
  void *v55;
  uint64_t v56;
  uint64_t v57;
  NSObject *v58;
  objc_class *v59;
  int v60;
  const char *v61;
  const char *v62;
  void *v63;
  uint64_t v64;
  uint64_t v65;
  const char *Name;
  NSErrorUserInfoKey v67;
  void *v68;
  uint8_t buf[4];
  unsigned int v70;
  __int16 v71;
  const char *v72;
  __int16 v73;
  const char *v74;
  __int16 v75;
  int v76;
  __int16 v77;
  void *v78;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v8 = 45;
    if (isMetaClass)
      v8 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i ", v8, ClassName, Name, 243);
  }
  v9 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v10 = NFSharedLogGetLogger(v9);
  v11 = objc_claimAutoreleasedReturnValue(v10);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v12 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v12))
      v13 = 43;
    else
      v13 = 45;
    v14 = object_getClassName(*(id *)(a1 + 32));
    v15 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)buf = 67109890;
    v70 = v13;
    v71 = 2082;
    v72 = v14;
    v73 = 2082;
    v74 = v15;
    v75 = 1024;
    v76 = 243;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
  }

  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    if (!*(_BYTE *)(*(_QWORD *)(a1 + 32) + 169))
    {
      v35 = 0;
LABEL_44:
      (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
      goto LABEL_24;
    }
    v39 = (void *)objc_claimAutoreleasedReturnValue(+[_NFHardwareManager sharedHardwareManager](_NFHardwareManager, "sharedHardwareManager"));
    v40 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig embeddedWiredMode](NFRoutingConfig, "embeddedWiredMode"));
    v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v39, "setRoutingConfig:", v40));

    if (v35)
    {
      v42 = NFSharedSignpostLog(v41);
      v43 = objc_claimAutoreleasedReturnValue(v42);
      if (!os_signpost_enabled(v43))
      {
LABEL_43:

        goto LABEL_44;
      }
      v44 = objc_msgSend(v35, "code");
      *(_DWORD *)buf = 67109120;
      v70 = v44;
      v45 = "end, error.code: %d";
      v46 = v43;
      v47 = 8;
    }
    else
    {
      *(_BYTE *)(*(_QWORD *)(a1 + 32) + 169) = 0;
      WeakRetained = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 200));
      sub_10019D694((uint64_t)WeakRetained, *(void **)(a1 + 32));

      v49 = NFLogGetLogger(2);
      if (v49)
      {
        v50 = (void (*)(uint64_t, const char *, ...))v49;
        v51 = object_getClass(*(id *)(a1 + 32));
        v52 = class_isMetaClass(v51);
        v53 = object_getClassName(*(id *)(a1 + 32));
        v54 = sel_getName(*(SEL *)(a1 + 48));
        v55 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
        v56 = 45;
        if (v52)
          v56 = 43;
        v50(6, "%c[%{public}s %{public}s]:%i NFC Reader mode terminated: %@", v56, v53, v54, 251, v55);

      }
      v57 = NFSharedLogGetLogger(2);
      v58 = objc_claimAutoreleasedReturnValue(v57);
      if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
      {
        v59 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v59))
          v60 = 43;
        else
          v60 = 45;
        v61 = object_getClassName(*(id *)(a1 + 32));
        v62 = sel_getName(*(SEL *)(a1 + 48));
        v63 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
        *(_DWORD *)buf = 67110146;
        v70 = v60;
        v71 = 2082;
        v72 = v61;
        v73 = 2082;
        v74 = v62;
        v75 = 1024;
        v76 = 251;
        v77 = 2112;
        v78 = v63;
        _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i NFC Reader mode terminated: %@", buf, 0x2Cu);

      }
      v65 = NFSharedSignpostLog(v64);
      v43 = objc_claimAutoreleasedReturnValue(v65);
      if (!os_signpost_enabled(v43))
        goto LABEL_43;
      *(_WORD *)buf = 0;
      v45 = "end";
      v46 = v43;
      v47 = 2;
    }
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v46, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "_NFSecureElementReaderSession+se_polling", v45, buf, v47);
    goto LABEL_43;
  }
  v16 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v17 = NFLogGetLogger(v16);
  if (v17)
  {
    v18 = (void (*)(uint64_t, const char *, ...))v17;
    v19 = object_getClass(*(id *)(a1 + 32));
    v20 = class_isMetaClass(v19);
    v21 = object_getClassName(*(id *)(a1 + 32));
    v22 = sel_getName(*(SEL *)(a1 + 48));
    v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v24 = 45;
    if (v20)
      v24 = 43;
    v18(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v24, v21, v22, 244, v23);

  }
  v25 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v26 = NFSharedLogGetLogger(v25);
  v27 = objc_claimAutoreleasedReturnValue(v26);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
  {
    v28 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v28))
      v29 = 43;
    else
      v29 = 45;
    v30 = object_getClassName(*(id *)(a1 + 32));
    v31 = sel_getName(*(SEL *)(a1 + 48));
    v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v70 = v29;
    v71 = 2082;
    v72 = v30;
    v73 = 2082;
    v74 = v31;
    v75 = 1024;
    v76 = 244;
    v77 = 2114;
    v78 = v32;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v33 = *(_QWORD *)(a1 + 40);
  if (v33)
  {
    v34 = objc_alloc((Class)NSError);
    v35 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v67 = NSLocalizedDescriptionKey;
    v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v68 = v36;
    v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v68, &v67, 1));
    v38 = objc_msgSend(v34, "initWithDomain:code:userInfo:", v35, 54, v37);
    (*(void (**)(uint64_t, id))(v33 + 16))(v33, v38);

LABEL_24:
  }
}

void sub_100142350(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  NSObject *v11;
  objc_class *v12;
  int v13;
  const char *v14;
  const char *v15;
  void *v16;
  uint64_t v17;
  void (*v18)(uint64_t, const char *, ...);
  objc_class *v19;
  _BOOL4 v20;
  const char *v21;
  const char *v22;
  void *v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  NSObject *v27;
  objc_class *v28;
  int v29;
  const char *v30;
  const char *v31;
  void *v32;
  uint64_t v33;
  id v34;
  id v35;
  void *v36;
  void *v37;
  id v38;
  void *v39;
  uint64_t v40;
  void **v41;
  uint64_t v42;
  const char *Name;
  _QWORD v44[6];
  id v45;
  NSErrorUserInfoKey v46;
  void *v47;
  uint8_t buf[4];
  int v49;
  __int16 v50;
  const char *v51;
  __int16 v52;
  const char *v53;
  __int16 v54;
  int v55;
  __int16 v56;
  void *v57;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    v8 = 45;
    if (isMetaClass)
      v8 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i ", v8, ClassName, Name, 266);
  }
  v9 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v10 = NFSharedLogGetLogger(v9);
  v11 = objc_claimAutoreleasedReturnValue(v10);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v12 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v12))
      v13 = 43;
    else
      v13 = 45;
    v14 = object_getClassName(*(id *)(a1 + 32));
    v15 = sel_getName(*(SEL *)(a1 + 56));
    *(_DWORD *)buf = 67109890;
    v49 = v13;
    v50 = 2082;
    v51 = v14;
    v52 = 2082;
    v53 = v15;
    v54 = 1024;
    v55 = 266;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
  }

  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v39 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
    v40 = *(_QWORD *)(a1 + 40);
    v45 = 0;
    v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v39, "transceiveData:toOS:error:", v40, 0, &v45));
    v35 = v45;

    v37 = (void *)objc_claimAutoreleasedReturnValue(+[NFResponseAPDU responseWithData:](NFResponseAPDU, "responseWithData:", v36));
    if (objc_msgSend(v37, "status") == 25392)
    {
      v41 = (void **)objc_claimAutoreleasedReturnValue(+[_NFHardwareManager sharedHardwareManager](_NFHardwareManager, "sharedHardwareManager"));
      v44[0] = _NSConcreteStackBlock;
      v44[1] = 3221225472;
      v44[2] = sub_1001427D4;
      v44[3] = &unk_1002E8FF0;
      v42 = *(_QWORD *)(a1 + 56);
      v44[4] = *(_QWORD *)(a1 + 32);
      v44[5] = v42;
      sub_1000F5B00(v41, v44);

    }
    (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
    goto LABEL_24;
  }
  v16 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v17 = NFLogGetLogger(v16);
  if (v17)
  {
    v18 = (void (*)(uint64_t, const char *, ...))v17;
    v19 = object_getClass(*(id *)(a1 + 32));
    v20 = class_isMetaClass(v19);
    v21 = object_getClassName(*(id *)(a1 + 32));
    v22 = sel_getName(*(SEL *)(a1 + 56));
    v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v24 = 45;
    if (v20)
      v24 = 43;
    v18(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v24, v21, v22, 267, v23);

  }
  v25 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v26 = NFSharedLogGetLogger(v25);
  v27 = objc_claimAutoreleasedReturnValue(v26);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
  {
    v28 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v28))
      v29 = 43;
    else
      v29 = 45;
    v30 = object_getClassName(*(id *)(a1 + 32));
    v31 = sel_getName(*(SEL *)(a1 + 56));
    v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v49 = v29;
    v50 = 2082;
    v51 = v30;
    v52 = 2082;
    v53 = v31;
    v54 = 1024;
    v55 = 267;
    v56 = 2114;
    v57 = v32;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v33 = *(_QWORD *)(a1 + 48);
  if (v33)
  {
    v34 = objc_alloc((Class)NSError);
    v35 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v46 = NSLocalizedDescriptionKey;
    v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v47 = v36;
    v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v47, &v46, 1));
    v38 = objc_msgSend(v34, "initWithDomain:code:userInfo:", v35, 54, v37);
    (*(void (**)(uint64_t, _QWORD, id))(v33 + 16))(v33, 0, v38);

LABEL_24:
  }
}

void sub_1001427D4(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  void *specific;
  uint64_t Logger;
  void (*v11)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  NSObject *v17;
  objc_class *v18;
  int v19;
  const char *v20;
  const char *v21;
  const char *ClassName;
  const char *Name;
  uint8_t buf[4];
  int v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  unsigned int v33;
  __int16 v34;
  unsigned int v35;
  __int16 v36;
  int v37;

  if (!a5)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v11 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 40));
      v14 = 45;
      if (isMetaClass)
        v14 = 43;
      v11(6, "%c[%{public}s %{public}s]:%i SERmRunning=%d, HostRMRunning=%d, remainingTime=%d", v14, ClassName, Name, 277, a2, a3, a4);
    }
    v15 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v16 = NFSharedLogGetLogger(v15);
    v17 = objc_claimAutoreleasedReturnValue(v16);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      v18 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v18))
        v19 = 43;
      else
        v19 = 45;
      v20 = object_getClassName(*(id *)(a1 + 32));
      v21 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)buf = 67110658;
      v25 = v19;
      v26 = 2082;
      v27 = v20;
      v28 = 2082;
      v29 = v21;
      v30 = 1024;
      v31 = 277;
      v32 = 1024;
      v33 = a2;
      v34 = 1024;
      v35 = a3;
      v36 = 1024;
      v37 = a4;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i SERmRunning=%d, HostRMRunning=%d, remainingTime=%d", buf, 0x34u);
    }

  }
}

void sub_100142A68(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  NSObject *v11;
  objc_class *v12;
  int v13;
  const char *v14;
  const char *v15;
  void *v16;
  uint64_t v17;
  void (*v18)(uint64_t, const char *, ...);
  objc_class *v19;
  _BOOL4 v20;
  const char *v21;
  const char *v22;
  void *v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  NSObject *v27;
  objc_class *v28;
  int v29;
  const char *v30;
  const char *v31;
  char *v32;
  uint64_t v33;
  id v34;
  id v35;
  void *v36;
  void *v37;
  void *v38;
  id v39;
  uint64_t v40;
  id v41;
  void *v42;
  id v43;
  void *v44;
  uint64_t v45;
  void (*v46)(uint64_t, const char *, ...);
  objc_class *v47;
  _BOOL4 v48;
  const char *v49;
  uint64_t v50;
  void *v51;
  uint64_t v52;
  NSObject *v53;
  objc_class *v54;
  int v55;
  const char *v56;
  const char *v57;
  void *v58;
  unsigned __int8 v59;
  void *v60;
  uint64_t v61;
  void (*v62)(uint64_t, const char *, ...);
  objc_class *v63;
  _BOOL4 v64;
  const char *v65;
  const char *v66;
  const char *v67;
  uint64_t v68;
  void *v69;
  uint64_t v70;
  NSObject *v71;
  objc_class *v72;
  int v73;
  const char *v74;
  const char *v75;
  const char *v76;
  void *v77;
  uint64_t v78;
  void (*v79)(uint64_t, const char *, ...);
  objc_class *v80;
  _BOOL4 v81;
  const char *v82;
  uint64_t v83;
  void *v84;
  uint64_t v85;
  NSObject *v86;
  objc_class *v87;
  int v88;
  const char *v89;
  const char *v90;
  void *v91;
  uint64_t v92;
  uint64_t v93;
  NSObject *v94;
  _BOOL4 v95;
  unsigned int v96;
  void *v97;
  uint64_t v98;
  void (*v99)(uint64_t, const char *, ...);
  objc_class *v100;
  _BOOL4 v101;
  const char *v102;
  uint64_t v103;
  void *v104;
  uint64_t v105;
  NSObject *v106;
  objc_class *v107;
  int v108;
  const char *v109;
  const char *v110;
  id v111;
  void *v112;
  uint64_t v113;
  void (*v114)(uint64_t, const char *, ...);
  objc_class *v115;
  _BOOL4 v116;
  const char *v117;
  uint64_t v118;
  void *v119;
  uint64_t v120;
  NSObject *v121;
  objc_class *v122;
  int v123;
  const char *v124;
  const char *v125;
  uint64_t v126;
  void (*v127)(uint64_t, const char *, ...);
  objc_class *v128;
  _BOOL4 v129;
  const char *v130;
  const char *v131;
  void *v132;
  uint64_t v133;
  uint64_t v134;
  NSObject *v135;
  objc_class *v136;
  int v137;
  const char *v138;
  const char *v139;
  char *v140;
  id WeakRetained;
  uint64_t v142;
  void *v143;
  uint64_t v144;
  const char *Name;
  const char *v146;
  const char *v147;
  const char *v148;
  const char *v149;
  NSErrorUserInfoKey v150;
  void *v151;
  NSErrorUserInfoKey v152;
  void *v153;
  uint8_t buf[4];
  unsigned int v155;
  __int16 v156;
  const char *v157;
  __int16 v158;
  const char *v159;
  __int16 v160;
  int v161;
  __int16 v162;
  const char *v163;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    v8 = 45;
    if (isMetaClass)
      v8 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i ", v8, ClassName, Name, 289);
  }
  v9 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v10 = NFSharedLogGetLogger(v9);
  v11 = objc_claimAutoreleasedReturnValue(v10);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v12 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v12))
      v13 = 43;
    else
      v13 = 45;
    v14 = object_getClassName(*(id *)(a1 + 32));
    v15 = sel_getName(*(SEL *)(a1 + 56));
    *(_DWORD *)buf = 67109890;
    v155 = v13;
    v156 = 2082;
    v157 = v14;
    v158 = 2082;
    v159 = v15;
    v160 = 1024;
    v161 = 289;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
  }

  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v42 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"));
    v43 = objc_msgSend(v42, "integerForKey:", CFSTR("SEReaderPollingDuration"));

    if ((_DWORD)v43)
    {
      v44 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v45 = NFLogGetLogger(v44);
      if (v45)
      {
        v46 = (void (*)(uint64_t, const char *, ...))v45;
        v47 = object_getClass(*(id *)(a1 + 32));
        v48 = class_isMetaClass(v47);
        v49 = object_getClassName(*(id *)(a1 + 32));
        v146 = sel_getName(*(SEL *)(a1 + 56));
        v50 = 45;
        if (v48)
          v50 = 43;
        v46(6, "%c[%{public}s %{public}s]:%i Using Polling override: %u", v50, v49, v146, 309, v43);
      }
      v51 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v52 = NFSharedLogGetLogger(v51);
      v53 = objc_claimAutoreleasedReturnValue(v52);
      if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
      {
        v54 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v54))
          v55 = 43;
        else
          v55 = 45;
        v56 = object_getClassName(*(id *)(a1 + 32));
        v57 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)buf = 67110146;
        v155 = v55;
        v156 = 2082;
        v157 = v56;
        v158 = 2082;
        v159 = v57;
        v160 = 1024;
        v161 = 309;
        v162 = 1024;
        LODWORD(v163) = (_DWORD)v43;
        _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Using Polling override: %u", buf, 0x28u);
      }

    }
    else
    {
      LODWORD(v43) = 20;
    }
    v58 = (void *)objc_claimAutoreleasedReturnValue(+[_NFHardwareManager sharedHardwareManager](_NFHardwareManager, "sharedHardwareManager"));
    v59 = objc_msgSend(v58, "configureECPPolling:", *(_QWORD *)(a1 + 40));

    if ((v59 & 1) != 0)
    {
      *(_BYTE *)(*(_QWORD *)(a1 + 32) + 170) = objc_msgSend(*(id *)(a1 + 40), "length") != 0;
      v60 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v61 = NFLogGetLogger(v60);
      if (v61)
      {
        v62 = (void (*)(uint64_t, const char *, ...))v61;
        v63 = object_getClass(*(id *)(a1 + 32));
        v64 = class_isMetaClass(v63);
        v65 = object_getClassName(*(id *)(a1 + 32));
        v66 = sel_getName(*(SEL *)(a1 + 56));
        if (*(_BYTE *)(*(_QWORD *)(a1 + 32) + 170))
          v67 = "VAS ECP set";
        else
          v67 = "VAS ECP not set";
        v68 = 45;
        if (v64)
          v68 = 43;
        v62(6, "%c[%{public}s %{public}s]:%i %s", v68, v65, v66, 324, v67);
      }
      v69 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v70 = NFSharedLogGetLogger(v69);
      v71 = objc_claimAutoreleasedReturnValue(v70);
      if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
      {
        v72 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v72))
          v73 = 43;
        else
          v73 = 45;
        v74 = object_getClassName(*(id *)(a1 + 32));
        v75 = sel_getName(*(SEL *)(a1 + 56));
        if (*(_BYTE *)(*(_QWORD *)(a1 + 32) + 170))
          v76 = "VAS ECP set";
        else
          v76 = "VAS ECP not set";
        *(_DWORD *)buf = 67110146;
        v155 = v73;
        v156 = 2082;
        v157 = v74;
        v158 = 2082;
        v159 = v75;
        v160 = 1024;
        v161 = 324;
        v162 = 2080;
        v163 = v76;
        _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %s", buf, 0x2Cu);
      }

      v77 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v78 = NFLogGetLogger(v77);
      if (v78)
      {
        v79 = (void (*)(uint64_t, const char *, ...))v78;
        v80 = object_getClass(*(id *)(a1 + 32));
        v81 = class_isMetaClass(v80);
        v82 = object_getClassName(*(id *)(a1 + 32));
        v147 = sel_getName(*(SEL *)(a1 + 56));
        v83 = 45;
        if (v81)
          v83 = 43;
        v79(6, "%c[%{public}s %{public}s]:%i SEtting routing for polling and wired with no FD", v83, v82, v147, 327);
      }
      v84 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v85 = NFSharedLogGetLogger(v84);
      v86 = objc_claimAutoreleasedReturnValue(v85);
      if (os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT))
      {
        v87 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v87))
          v88 = 43;
        else
          v88 = 45;
        v89 = object_getClassName(*(id *)(a1 + 32));
        v90 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)buf = 67109890;
        v155 = v88;
        v156 = 2082;
        v157 = v89;
        v158 = 2082;
        v159 = v90;
        v160 = 1024;
        v161 = 327;
        _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i SEtting routing for polling and wired with no FD", buf, 0x22u);
      }

      LODWORD(v144) = (_DWORD)v43;
      v35 = -[NFRoutingConfig initPollingType:wantsSEReader:wantsExpress:cardEmulationType:hostMode:embeddedMode:fieldDetect:pollingDuration:lpcdEcpFrame:]([NFRoutingConfig alloc], "initPollingType:wantsSEReader:wantsExpress:cardEmulationType:hostMode:embeddedMode:fieldDetect:pollingDuration:lpcdEcpFrame:", 1, 0, 0, 0, 0, 1, 0, v144, *(_QWORD *)(a1 + 40));
      objc_msgSend(v35, "setPollingMask:tagConfig:", 19, 112);
      v91 = (void *)objc_claimAutoreleasedReturnValue(+[_NFHardwareManager sharedHardwareManager](_NFHardwareManager, "sharedHardwareManager"));
      v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v91, "setRoutingConfig:", v35));

      v93 = NFSharedSignpostLog(v92);
      v94 = objc_claimAutoreleasedReturnValue(v93);
      v95 = os_signpost_enabled(v94);
      if (v36)
      {
        if (v95)
        {
          v96 = objc_msgSend(v36, "code");
          *(_DWORD *)buf = 67109120;
          v155 = v96;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v94, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "_NFSecureElementReaderSession+vas_polling", "begin, error.code=%d", buf, 8u);
        }

        v97 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v98 = NFLogGetLogger(v97);
        if (v98)
        {
          v99 = (void (*)(uint64_t, const char *, ...))v98;
          v100 = object_getClass(*(id *)(a1 + 32));
          v101 = class_isMetaClass(v100);
          v102 = object_getClassName(*(id *)(a1 + 32));
          v148 = sel_getName(*(SEL *)(a1 + 56));
          v103 = 45;
          if (v101)
            v103 = 43;
          v99(3, "%c[%{public}s %{public}s]:%i Failed to start polling", v103, v102, v148, 353);
        }
        v104 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v105 = NFSharedLogGetLogger(v104);
        v106 = objc_claimAutoreleasedReturnValue(v105);
        if (os_log_type_enabled(v106, OS_LOG_TYPE_ERROR))
        {
          v107 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v107))
            v108 = 43;
          else
            v108 = 45;
          v109 = object_getClassName(*(id *)(a1 + 32));
          v110 = sel_getName(*(SEL *)(a1 + 56));
          *(_DWORD *)buf = 67109890;
          v155 = v108;
          v156 = 2082;
          v157 = v109;
          v158 = 2082;
          v159 = v110;
          v160 = 1024;
          v161 = 353;
          _os_log_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to start polling", buf, 0x22u);
        }

        (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
      }
      else
      {
        if (v95)
        {
          *(_WORD *)buf = 0;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v94, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "_NFSecureElementReaderSession+vas_polling", "begin", buf, 2u);
        }

        v112 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v113 = NFLogGetLogger(v112);
        if (v113)
        {
          v114 = (void (*)(uint64_t, const char *, ...))v113;
          v115 = object_getClass(*(id *)(a1 + 32));
          v116 = class_isMetaClass(v115);
          v117 = object_getClassName(*(id *)(a1 + 32));
          v149 = sel_getName(*(SEL *)(a1 + 56));
          v118 = 45;
          if (v116)
            v118 = 43;
          v114(6, "%c[%{public}s %{public}s]:%i VAS Reader started", v118, v117, v149, 344);
        }
        v119 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v120 = NFSharedLogGetLogger(v119);
        v121 = objc_claimAutoreleasedReturnValue(v120);
        if (os_log_type_enabled(v121, OS_LOG_TYPE_DEFAULT))
        {
          v122 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v122))
            v123 = 43;
          else
            v123 = 45;
          v124 = object_getClassName(*(id *)(a1 + 32));
          v125 = sel_getName(*(SEL *)(a1 + 56));
          *(_DWORD *)buf = 67109890;
          v155 = v123;
          v156 = 2082;
          v157 = v124;
          v158 = 2082;
          v159 = v125;
          v160 = 1024;
          v161 = 344;
          _os_log_impl((void *)&_mh_execute_header, v121, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i VAS Reader started", buf, 0x22u);
        }

        v126 = NFLogGetLogger(2);
        if (v126)
        {
          v127 = (void (*)(uint64_t, const char *, ...))v126;
          v128 = object_getClass(*(id *)(a1 + 32));
          v129 = class_isMetaClass(v128);
          v130 = object_getClassName(*(id *)(a1 + 32));
          v131 = sel_getName(*(SEL *)(a1 + 56));
          v132 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
          v133 = 45;
          if (v129)
            v133 = 43;
          v127(6, "%c[%{public}s %{public}s]:%i NFC Reader mode activated: %@", v133, v130, v131, 345, v132);

        }
        v134 = NFSharedLogGetLogger(2);
        v135 = objc_claimAutoreleasedReturnValue(v134);
        if (os_log_type_enabled(v135, OS_LOG_TYPE_DEFAULT))
        {
          v136 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v136))
            v137 = 43;
          else
            v137 = 45;
          v138 = object_getClassName(*(id *)(a1 + 32));
          v139 = sel_getName(*(SEL *)(a1 + 56));
          v140 = (char *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
          *(_DWORD *)buf = 67110146;
          v155 = v137;
          v156 = 2082;
          v157 = v138;
          v158 = 2082;
          v159 = v139;
          v160 = 1024;
          v161 = 345;
          v162 = 2112;
          v163 = v140;
          _os_log_impl((void *)&_mh_execute_header, v135, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i NFC Reader mode activated: %@", buf, 0x2Cu);

        }
        WeakRetained = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 200));
        sub_10019E124((uint64_t)WeakRetained, *(void **)(a1 + 32));

        v142 = *(_QWORD *)(a1 + 32);
        v143 = *(void **)(v142 + 184);
        *(_QWORD *)(v142 + 184) = 0;

        (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
        v36 = 0;
      }
      goto LABEL_25;
    }
    *(_BYTE *)(*(_QWORD *)(a1 + 32) + 170) = 0;
    v33 = *(_QWORD *)(a1 + 48);
    v111 = objc_alloc((Class)NSError);
    v35 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v150 = NSLocalizedDescriptionKey;
    v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
    v151 = v36;
    v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v151, &v150, 1));
    v38 = v111;
    v39 = v35;
    v40 = 15;
LABEL_24:
    v41 = objc_msgSend(v38, "initWithDomain:code:userInfo:", v39, v40, v37);
    (*(void (**)(uint64_t, id))(v33 + 16))(v33, v41);

LABEL_25:
    return;
  }
  v16 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v17 = NFLogGetLogger(v16);
  if (v17)
  {
    v18 = (void (*)(uint64_t, const char *, ...))v17;
    v19 = object_getClass(*(id *)(a1 + 32));
    v20 = class_isMetaClass(v19);
    v21 = object_getClassName(*(id *)(a1 + 32));
    v22 = sel_getName(*(SEL *)(a1 + 56));
    v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v24 = 45;
    if (v20)
      v24 = 43;
    v18(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v24, v21, v22, 290, v23);

  }
  v25 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v26 = NFSharedLogGetLogger(v25);
  v27 = objc_claimAutoreleasedReturnValue(v26);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
  {
    v28 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v28))
      v29 = 43;
    else
      v29 = 45;
    v30 = object_getClassName(*(id *)(a1 + 32));
    v31 = sel_getName(*(SEL *)(a1 + 56));
    v32 = (char *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v155 = v29;
    v156 = 2082;
    v157 = v30;
    v158 = 2082;
    v159 = v31;
    v160 = 1024;
    v161 = 290;
    v162 = 2114;
    v163 = v32;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v33 = *(_QWORD *)(a1 + 48);
  if (v33)
  {
    v34 = objc_alloc((Class)NSError);
    v35 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v152 = NSLocalizedDescriptionKey;
    v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v153 = v36;
    v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v153, &v152, 1));
    v38 = v34;
    v39 = v35;
    v40 = 54;
    goto LABEL_24;
  }
}

void sub_100143850(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  NSObject *v11;
  objc_class *v12;
  int v13;
  const char *v14;
  const char *v15;
  void *v16;
  uint64_t v17;
  void (*v18)(uint64_t, const char *, ...);
  objc_class *v19;
  _BOOL4 v20;
  const char *v21;
  const char *v22;
  void *v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  NSObject *v27;
  objc_class *v28;
  int v29;
  const char *v30;
  const char *v31;
  void *v32;
  uint64_t v33;
  id v34;
  void *v35;
  void *v36;
  void *v37;
  id v38;
  uint64_t v39;
  void *v40;
  void *v41;
  uint64_t v42;
  uint64_t v43;
  NSObject *v44;
  _BOOL4 v45;
  unsigned int v46;
  void *v47;
  uint64_t v48;
  void (*v49)(uint64_t, const char *, ...);
  objc_class *v50;
  _BOOL4 v51;
  const char *v52;
  uint64_t v53;
  void *v54;
  uint64_t v55;
  NSObject *v56;
  objc_class *v57;
  int v58;
  const char *v59;
  const char *v60;
  void *v61;
  uint64_t v62;
  void (*v63)(uint64_t, const char *, ...);
  objc_class *v64;
  _BOOL4 v65;
  const char *v66;
  uint64_t v67;
  void *v68;
  uint64_t v69;
  NSObject *v70;
  objc_class *v71;
  int v72;
  const char *v73;
  const char *v74;
  id WeakRetained;
  void *v76;
  const char *Name;
  const char *v78;
  const char *v79;
  NSErrorUserInfoKey v80;
  void *v81;
  uint8_t buf[4];
  unsigned int v83;
  __int16 v84;
  const char *v85;
  __int16 v86;
  const char *v87;
  __int16 v88;
  int v89;
  __int16 v90;
  void *v91;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v8 = 45;
    if (isMetaClass)
      v8 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i ", v8, ClassName, Name, 365);
  }
  v9 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v10 = NFSharedLogGetLogger(v9);
  v11 = objc_claimAutoreleasedReturnValue(v10);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v12 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v12))
      v13 = 43;
    else
      v13 = 45;
    v14 = object_getClassName(*(id *)(a1 + 32));
    v15 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)buf = 67109890;
    v83 = v13;
    v84 = 2082;
    v85 = v14;
    v86 = 2082;
    v87 = v15;
    v88 = 1024;
    v89 = 365;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
  }

  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v39 = *(_QWORD *)(a1 + 32);
    v40 = *(void **)(v39 + 184);
    *(_QWORD *)(v39 + 184) = 0;

    v35 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig embeddedWiredMode](NFRoutingConfig, "embeddedWiredMode"));
    v41 = (void *)objc_claimAutoreleasedReturnValue(+[_NFHardwareManager sharedHardwareManager](_NFHardwareManager, "sharedHardwareManager"));
    v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v41, "setRoutingConfig:", v35));

    v43 = NFSharedSignpostLog(v42);
    v44 = objc_claimAutoreleasedReturnValue(v43);
    v45 = os_signpost_enabled(v44);
    if (v36)
    {
      if (v45)
      {
        v46 = objc_msgSend(v36, "code");
        *(_DWORD *)buf = 67109120;
        v83 = v46;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v44, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "_NFSecureElementReaderSession+vas_polling", "end, error.code: %d", buf, 8u);
      }

      v47 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v48 = NFLogGetLogger(v47);
      if (v48)
      {
        v49 = (void (*)(uint64_t, const char *, ...))v48;
        v50 = object_getClass(*(id *)(a1 + 32));
        v51 = class_isMetaClass(v50);
        v52 = object_getClassName(*(id *)(a1 + 32));
        v78 = sel_getName(*(SEL *)(a1 + 48));
        v53 = 45;
        if (v51)
          v53 = 43;
        v49(3, "%c[%{public}s %{public}s]:%i Failed to stop polling", v53, v52, v78, 381);
      }
      v54 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v55 = NFSharedLogGetLogger(v54);
      v56 = objc_claimAutoreleasedReturnValue(v55);
      if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
      {
        v57 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v57))
          v58 = 43;
        else
          v58 = 45;
        v59 = object_getClassName(*(id *)(a1 + 32));
        v60 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)buf = 67109890;
        v83 = v58;
        v84 = 2082;
        v85 = v59;
        v86 = 2082;
        v87 = v60;
        v88 = 1024;
        v89 = 381;
        _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to stop polling", buf, 0x22u);
      }

      (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
    }
    else
    {
      if (v45)
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v44, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "_NFSecureElementReaderSession+vas_polling", "end", buf, 2u);
      }

      v61 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v62 = NFLogGetLogger(v61);
      if (v62)
      {
        v63 = (void (*)(uint64_t, const char *, ...))v62;
        v64 = object_getClass(*(id *)(a1 + 32));
        v65 = class_isMetaClass(v64);
        v66 = object_getClassName(*(id *)(a1 + 32));
        v79 = sel_getName(*(SEL *)(a1 + 48));
        v67 = 45;
        if (v65)
          v67 = 43;
        v63(6, "%c[%{public}s %{public}s]:%i VAS Reader stopped", v67, v66, v79, 374);
      }
      v68 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v69 = NFSharedLogGetLogger(v68);
      v70 = objc_claimAutoreleasedReturnValue(v69);
      if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
      {
        v71 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v71))
          v72 = 43;
        else
          v72 = 45;
        v73 = object_getClassName(*(id *)(a1 + 32));
        v74 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)buf = 67109890;
        v83 = v72;
        v84 = 2082;
        v85 = v73;
        v86 = 2082;
        v87 = v74;
        v88 = 1024;
        v89 = 374;
        _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i VAS Reader stopped", buf, 0x22u);
      }

      WeakRetained = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 200));
      sub_10019D694((uint64_t)WeakRetained, *(void **)(a1 + 32));

      v76 = (void *)objc_claimAutoreleasedReturnValue(+[_NFHardwareManager sharedHardwareManager](_NFHardwareManager, "sharedHardwareManager"));
      objc_msgSend(v76, "notifyReaderModeActivityEnd");

      (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
      v36 = 0;
    }
    goto LABEL_24;
  }
  v16 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v17 = NFLogGetLogger(v16);
  if (v17)
  {
    v18 = (void (*)(uint64_t, const char *, ...))v17;
    v19 = object_getClass(*(id *)(a1 + 32));
    v20 = class_isMetaClass(v19);
    v21 = object_getClassName(*(id *)(a1 + 32));
    v22 = sel_getName(*(SEL *)(a1 + 48));
    v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v24 = 45;
    if (v20)
      v24 = 43;
    v18(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v24, v21, v22, 366, v23);

  }
  v25 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v26 = NFSharedLogGetLogger(v25);
  v27 = objc_claimAutoreleasedReturnValue(v26);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
  {
    v28 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v28))
      v29 = 43;
    else
      v29 = 45;
    v30 = object_getClassName(*(id *)(a1 + 32));
    v31 = sel_getName(*(SEL *)(a1 + 48));
    v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v83 = v29;
    v84 = 2082;
    v85 = v30;
    v86 = 2082;
    v87 = v31;
    v88 = 1024;
    v89 = 366;
    v90 = 2114;
    v91 = v32;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v33 = *(_QWORD *)(a1 + 40);
  if (v33)
  {
    v34 = objc_alloc((Class)NSError);
    v35 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v80 = NSLocalizedDescriptionKey;
    v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v81 = v36;
    v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v81, &v80, 1));
    v38 = objc_msgSend(v34, "initWithDomain:code:userInfo:", v35, 54, v37);
    (*(void (**)(uint64_t, id))(v33 + 16))(v33, v38);

LABEL_24:
  }
}

void sub_10014403C(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  NSObject *v11;
  objc_class *v12;
  int v13;
  const char *v14;
  const char *v15;
  _QWORD *v16;
  id v17;
  void *v18;
  uint64_t v19;
  void (*v20)(uint64_t, const char *, ...);
  objc_class *v21;
  _BOOL4 v22;
  const char *v23;
  const char *v24;
  void *v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  NSObject *v29;
  objc_class *v30;
  int v31;
  const char *v32;
  const char *v33;
  void *v34;
  uint64_t v35;
  id v36;
  id v37;
  uint64_t v38;
  NSMutableDictionary *v39;
  void *v40;
  id v41;
  uint64_t v42;
  void *v43;
  uint64_t v44;
  void (*v45)(uint64_t, const char *, ...);
  objc_class *v46;
  _BOOL4 v47;
  const char *v48;
  uint64_t v49;
  void *v50;
  uint64_t v51;
  NSObject *v52;
  objc_class *v53;
  int v54;
  const char *v55;
  const char *v56;
  id v57;
  id v58;
  NFVASReader *v59;
  uint64_t v60;
  void *v61;
  void *v62;
  uint64_t v63;
  uint64_t v64;
  NSObject *v65;
  uint64_t v66;
  NSObject *v67;
  objc_class *v68;
  objc_class *v69;
  id v70;
  void *v71;
  id v72;
  uint64_t v73;
  void *v74;
  id v75;
  id v76;
  void *v77;
  uint64_t v78;
  uint64_t v79;
  NSObject *v80;
  unsigned int v81;
  id v82;
  id v83;
  id v84;
  id v85;
  id v86;
  id v87;
  id v88;
  id v89;
  id v90;
  id v91;
  char v92;
  id v93;
  id v94;
  char v95;
  id v96;
  char v97;
  id v98;
  const char *Name;
  const char *v100;
  NSObject v101;
  _QWORD v102[5];
  _QWORD v103[5];
  NSErrorUserInfoKey v104;
  uint64_t v105;
  uint8_t buf[4];
  unsigned int v107;
  __int16 v108;
  const char *v109;
  __int16 v110;
  const char *v111;
  __int16 v112;
  int v113;
  __int16 v114;
  void *v115;
  NSErrorUserInfoKey v116;
  uint64_t v117;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v8 = 45;
    if (isMetaClass)
      v8 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i ", v8, ClassName, Name, 393);
  }
  v9 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v10 = NFSharedLogGetLogger(v9);
  v11 = objc_claimAutoreleasedReturnValue(v10);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v12 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v12))
      v13 = 43;
    else
      v13 = 45;
    v14 = object_getClassName(*(id *)(a1 + 32));
    v15 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)buf = 67109890;
    v107 = v13;
    v108 = 2082;
    v109 = v14;
    v110 = 2082;
    v111 = v15;
    v112 = 1024;
    v113 = 393;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
  }

  v16 = *(_QWORD **)(a1 + 32);
  if (!v16[22])
  {
    v43 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v44 = NFLogGetLogger(v43);
    if (v44)
    {
      v45 = (void (*)(uint64_t, const char *, ...))v44;
      v46 = object_getClass(*(id *)(a1 + 32));
      v47 = class_isMetaClass(v46);
      v48 = object_getClassName(*(id *)(a1 + 32));
      v100 = sel_getName(*(SEL *)(a1 + 48));
      v49 = 45;
      if (v47)
        v49 = 43;
      v45(3, "%c[%{public}s %{public}s]:%i Tag not connected", v49, v48, v100, 395);
    }
    v50 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v51 = NFSharedLogGetLogger(v50);
    v52 = objc_claimAutoreleasedReturnValue(v51);
    if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
    {
      v53 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v53))
        v54 = 43;
      else
        v54 = 45;
      v55 = object_getClassName(*(id *)(a1 + 32));
      v56 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)buf = 67109890;
      v107 = v54;
      v108 = 2082;
      v109 = v55;
      v110 = 2082;
      v111 = v56;
      v112 = 1024;
      v113 = 395;
      _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Tag not connected", buf, 0x22u);
    }

    v35 = *(_QWORD *)(a1 + 40);
    v57 = objc_alloc((Class)NSError);
    v37 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v116 = NSLocalizedDescriptionKey;
    v38 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Tag Not Found"));
    v117 = v38;
    v39 = (NSMutableDictionary *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v117, &v116, 1));
    v40 = v57;
    v41 = v37;
    v42 = 28;
    goto LABEL_35;
  }
  if (objc_msgSend(v16, "didStart"))
  {
    if ((objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0)
    {
      v17 = objc_msgSend(*(id *)(a1 + 32), "didEnd");
      if (!(_DWORD)v17)
      {
        if (!*(_QWORD *)(*(_QWORD *)(a1 + 32) + 184))
        {
          v59 = objc_opt_new(NFVASReader);
          v60 = *(_QWORD *)(a1 + 32);
          v61 = *(void **)(v60 + 184);
          *(_QWORD *)(v60 + 184) = v59;

          v62 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "driverWrapper"));
          sub_100051EF0(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 184), v62);

          sub_100084994(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 184), *(void **)(*(_QWORD *)(a1 + 32) + 176));
          v63 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 184);
          if (v63)
            *(_QWORD *)(v63 + 24) = 0x404E000000000000;
        }
        v64 = NFSharedSignpostLog(v17);
        v65 = objc_claimAutoreleasedReturnValue(v64);
        if (os_signpost_enabled(v65))
        {
          *(_WORD *)buf = 0;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v65, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "_NFSecureElementReaderSession+select_OSE", "", buf, 2u);
        }

        v66 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 184);
        v101.isa = 0;
        v67 = sub_10008201C(v66, &v101);
        v38 = objc_claimAutoreleasedReturnValue(v67);
        v68 = v101.isa;
        if (v68)
        {
          v69 = v68;
          v70 = objc_alloc((Class)NSError);
          v71 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
          v72 = -[objc_class code](v69, "code");
          v102[0] = NSLocalizedDescriptionKey;
          if ((uint64_t)-[objc_class code](v69, "code") > 70)
            v73 = 71;
          else
            v73 = (uint64_t)-[objc_class code](v69, "code");
          v74 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E8DA8[v73]));
          v103[0] = v74;
          v103[1] = v69;
          v102[1] = NSUnderlyingErrorKey;
          v102[2] = CFSTR("Line");
          v103[2] = &off_1002FFAE0;
          v102[3] = CFSTR("Method");
          v75 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 48)));
          v103[3] = v75;
          v102[4] = NSDebugDescriptionErrorKey;
          v76 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 48)), 413);
          v103[4] = v76;
          v77 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v103, v102, 5));
          v37 = objc_msgSend(v70, "initWithDomain:code:userInfo:", v71, v72, v77);

          v79 = NFSharedSignpostLog(v78);
          v80 = objc_claimAutoreleasedReturnValue(v79);
          if (os_signpost_enabled(v80))
          {
            v81 = objc_msgSend(v37, "code");
            *(_DWORD *)buf = 67109120;
            v107 = v81;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v80, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "_NFSecureElementReaderSession+select_OSE", "error.code: %d", buf, 8u);
          }

          if (v38)
            goto LABEL_52;
        }
        else
        {
          v37 = 0;
          if (v38)
          {
LABEL_52:
            v39 = objc_opt_new(NSMutableDictionary);
            v82 = *(id *)(v38 + 16);
            v83 = objc_msgSend(v82, "length");

            if (v83)
            {
              v84 = *(id *)(v38 + 16);
              -[NSMutableDictionary setObject:forKeyedSubscript:](v39, "setObject:forKeyedSubscript:", v84, CFSTR("AppLabel"));

            }
            v85 = *(id *)(v38 + 24);
            v86 = objc_msgSend(v85, "length");

            if (v86)
            {
              v87 = *(id *)(v38 + 24);
              -[NSMutableDictionary setObject:forKeyedSubscript:](v39, "setObject:forKeyedSubscript:", v87, CFSTR("AppVersion"));

            }
            v88 = *(id *)(v38 + 32);
            v89 = objc_msgSend(v88, "length");

            if (v89)
            {
              v90 = *(id *)(v38 + 32);
              -[NSMutableDictionary setObject:forKeyedSubscript:](v39, "setObject:forKeyedSubscript:", v90, CFSTR("Unpredictable"));

            }
            v91 = objc_msgSend(objc_alloc((Class)NSMutableData), "initWithLength:", 1);
            v92 = *(_BYTE *)(v38 + 8);
            v93 = objc_retainAutorelease(v91);
            *(_BYTE *)objc_msgSend(v93, "mutableBytes") = v92;
            -[NSMutableDictionary setObject:forKeyedSubscript:](v39, "setObject:forKeyedSubscript:", v93, CFSTR("MobileCapabilities"));
            v94 = objc_msgSend(objc_alloc((Class)NSMutableData), "initWithLength:", 2);
            v95 = *(_BYTE *)(v38 + 11);
            v96 = objc_retainAutorelease(v94);
            *(_BYTE *)objc_msgSend(v96, "mutableBytes") = v95;
            v97 = *(_BYTE *)(v38 + 10);
            v98 = objc_retainAutorelease(v96);
            *((_BYTE *)objc_msgSend(v98, "mutableBytes") + 1) = v97;
            -[NSMutableDictionary setObject:forKeyedSubscript:](v39, "setObject:forKeyedSubscript:", v98, CFSTR("Status"));

            goto LABEL_59;
          }
        }
        v39 = 0;
LABEL_59:
        (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
        goto LABEL_36;
      }
    }
  }
  v18 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v19 = NFLogGetLogger(v18);
  if (v19)
  {
    v20 = (void (*)(uint64_t, const char *, ...))v19;
    v21 = object_getClass(*(id *)(a1 + 32));
    v22 = class_isMetaClass(v21);
    v23 = object_getClassName(*(id *)(a1 + 32));
    v24 = sel_getName(*(SEL *)(a1 + 48));
    v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v26 = 45;
    if (v22)
      v26 = 43;
    v20(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v26, v23, v24, 400, v25);

  }
  v27 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v28 = NFSharedLogGetLogger(v27);
  v29 = objc_claimAutoreleasedReturnValue(v28);
  if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
  {
    v30 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v30))
      v31 = 43;
    else
      v31 = 45;
    v32 = object_getClassName(*(id *)(a1 + 32));
    v33 = sel_getName(*(SEL *)(a1 + 48));
    v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v107 = v31;
    v108 = 2082;
    v109 = v32;
    v110 = 2082;
    v111 = v33;
    v112 = 1024;
    v113 = 400;
    v114 = 2114;
    v115 = v34;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v35 = *(_QWORD *)(a1 + 40);
  if (v35)
  {
    v36 = objc_alloc((Class)NSError);
    v37 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v104 = NSLocalizedDescriptionKey;
    v38 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v105 = v38;
    v39 = (NSMutableDictionary *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v105, &v104, 1));
    v40 = v36;
    v41 = v37;
    v42 = 54;
LABEL_35:
    v58 = objc_msgSend(v40, "initWithDomain:code:userInfo:", v41, v42, v39);
    (*(void (**)(uint64_t, _QWORD, id))(v35 + 16))(v35, 0, v58);

LABEL_36:
  }
}

void sub_100144AF8(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  NSObject *v11;
  objc_class *v12;
  int v13;
  const char *v14;
  const char *v15;
  void *v16;
  uint64_t v17;
  void (*v18)(uint64_t, const char *, ...);
  objc_class *v19;
  _BOOL4 v20;
  const char *v21;
  const char *v22;
  void *v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  NSObject *v27;
  objc_class *v28;
  int v29;
  const char *v30;
  const char *v31;
  objc_class *v32;
  uint64_t v33;
  id v34;
  objc_class *v35;
  NSMutableArray *v36;
  void *v37;
  void *v38;
  objc_class *v39;
  uint64_t v40;
  id v41;
  id v42;
  id v43;
  uint64_t v44;
  void *i;
  uint64_t v46;
  NFVASReader *v47;
  uint64_t v48;
  void *v49;
  void *v50;
  uint64_t v51;
  uint64_t v52;
  NSObject *v53;
  uint64_t v54;
  NSObject *v55;
  objc_class *v56;
  uint64_t v57;
  NSObject *v58;
  unsigned int v59;
  void *v60;
  uint64_t v61;
  void (*v62)(uint64_t, const char *, ...);
  objc_class *v63;
  _BOOL4 v64;
  uint64_t v65;
  void *v66;
  uint64_t v67;
  NSObject *v68;
  objc_class *v69;
  int v70;
  const char *v71;
  const char *v72;
  uint64_t v73;
  id v74;
  void *v75;
  id v76;
  uint64_t v77;
  void *v78;
  uint64_t v79;
  void (*v80)(uint64_t, const char *, ...);
  objc_class *v81;
  _BOOL4 v82;
  const char *v83;
  uint64_t v84;
  void *v85;
  uint64_t v86;
  NSObject *v87;
  objc_class *v88;
  int v89;
  const char *v90;
  const char *v91;
  uint64_t v92;
  id v93;
  void *v94;
  id v95;
  void *v96;
  uint64_t v97;
  void (*v98)(uint64_t, const char *, ...);
  objc_class *v99;
  _BOOL4 v100;
  const char *v101;
  uint64_t v102;
  void *v103;
  uint64_t v104;
  NSObject *v105;
  objc_class *v106;
  int v107;
  const char *v108;
  const char *v109;
  id v110;
  void *v111;
  unsigned __int8 *v112;
  id v113;
  void *v114;
  uint64_t v115;
  void (*v116)(uint64_t, const char *, ...);
  objc_class *v117;
  _BOOL4 v118;
  uint64_t v119;
  void *v120;
  uint64_t v121;
  NSObject *v122;
  objc_class *v123;
  int v124;
  const char *v125;
  const char *v126;
  void *v127;
  id v128;
  id v129;
  void *v130;
  id v131;
  const char *v132;
  const char *v133;
  const char *Name;
  const char *v135;
  const char *v136;
  const char *v137;
  const char *v138;
  NSMutableArray *v139;
  NSObject v140;
  __int128 v141;
  __int128 v142;
  __int128 v143;
  __int128 v144;
  _QWORD v145[5];
  _QWORD v146[5];
  NSErrorUserInfoKey v147;
  void *v148;
  _BYTE v149[128];
  NSErrorUserInfoKey v150;
  NSMutableArray *v151;
  NSErrorUserInfoKey v152;
  NSMutableArray *v153;
  uint8_t buf[4];
  unsigned int v155;
  __int16 v156;
  const char *v157;
  __int16 v158;
  const char *v159;
  __int16 v160;
  int v161;
  __int16 v162;
  objc_class *v163;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    v8 = 45;
    if (isMetaClass)
      v8 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i ", v8, ClassName, Name, 450);
  }
  v9 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v10 = NFSharedLogGetLogger(v9);
  v11 = objc_claimAutoreleasedReturnValue(v10);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v12 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v12))
      v13 = 43;
    else
      v13 = 45;
    v14 = object_getClassName(*(id *)(a1 + 32));
    v15 = sel_getName(*(SEL *)(a1 + 56));
    *(_DWORD *)buf = 67109890;
    v155 = v13;
    v156 = 2082;
    v157 = v14;
    v158 = 2082;
    v159 = v15;
    v160 = 1024;
    v161 = 450;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
  }

  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    if (!*(_QWORD *)(*(_QWORD *)(a1 + 32) + 176))
    {
      v96 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v97 = NFLogGetLogger(v96);
      if (v97)
      {
        v98 = (void (*)(uint64_t, const char *, ...))v97;
        v99 = object_getClass(*(id *)(a1 + 32));
        v100 = class_isMetaClass(v99);
        v101 = object_getClassName(*(id *)(a1 + 32));
        v137 = sel_getName(*(SEL *)(a1 + 56));
        v102 = 45;
        if (v100)
          v102 = 43;
        v98(3, "%c[%{public}s %{public}s]:%i Tag not connected", v102, v101, v137, 455);
      }
      v103 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v104 = NFSharedLogGetLogger(v103);
      v105 = objc_claimAutoreleasedReturnValue(v104);
      if (os_log_type_enabled(v105, OS_LOG_TYPE_ERROR))
      {
        v106 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v106))
          v107 = 43;
        else
          v107 = 45;
        v108 = object_getClassName(*(id *)(a1 + 32));
        v109 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)buf = 67109890;
        v155 = v107;
        v156 = 2082;
        v157 = v108;
        v158 = 2082;
        v159 = v109;
        v160 = 1024;
        v161 = 455;
        _os_log_impl((void *)&_mh_execute_header, v105, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Tag not connected", buf, 0x22u);
      }

      v33 = *(_QWORD *)(a1 + 48);
      v110 = objc_alloc((Class)NSError);
      v35 = (objc_class *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v150 = NSLocalizedDescriptionKey;
      v36 = (NSMutableArray *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Tag Not Found"));
      v151 = v36;
      v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v151, &v150, 1));
      v38 = v110;
      v39 = v35;
      v40 = 28;
LABEL_24:
      v41 = objc_msgSend(v38, "initWithDomain:code:userInfo:", v39, v40, v37);
      (*(void (**)(uint64_t, id, _QWORD))(v33 + 16))(v33, v41, 0);

LABEL_25:
      goto LABEL_26;
    }
    v143 = 0u;
    v144 = 0u;
    v141 = 0u;
    v142 = 0u;
    v35 = (objc_class *)*(id *)(a1 + 40);
    v42 = -[objc_class countByEnumeratingWithState:objects:count:](v35, "countByEnumeratingWithState:objects:count:", &v141, v149, 16);
    if (v42)
    {
      v43 = v42;
      v44 = *(_QWORD *)v142;
      while (2)
      {
        for (i = 0; i != v43; i = (char *)i + 1)
        {
          if (*(_QWORD *)v142 != v44)
            objc_enumerationMutation(v35);
          if (!+[NFVASRequest validateDictionary:](NFVASRequest, "validateDictionary:", *(_QWORD *)(*((_QWORD *)&v141 + 1) + 8 * (_QWORD)i)))
          {
            v78 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v79 = NFLogGetLogger(v78);
            if (v79)
            {
              v80 = (void (*)(uint64_t, const char *, ...))v79;
              v81 = object_getClass(*(id *)(a1 + 32));
              v82 = class_isMetaClass(v81);
              v83 = object_getClassName(*(id *)(a1 + 32));
              v136 = sel_getName(*(SEL *)(a1 + 56));
              v84 = 45;
              if (v82)
                v84 = 43;
              v80(3, "%c[%{public}s %{public}s]:%i Invalid parameter", v84, v83, v136, 462);
            }
            v85 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v86 = NFSharedLogGetLogger(v85);
            v87 = objc_claimAutoreleasedReturnValue(v86);
            if (os_log_type_enabled(v87, OS_LOG_TYPE_ERROR))
            {
              v88 = object_getClass(*(id *)(a1 + 32));
              if (class_isMetaClass(v88))
                v89 = 43;
              else
                v89 = 45;
              v90 = object_getClassName(*(id *)(a1 + 32));
              v91 = sel_getName(*(SEL *)(a1 + 56));
              *(_DWORD *)buf = 67109890;
              v155 = v89;
              v156 = 2082;
              v157 = v90;
              v158 = 2082;
              v159 = v91;
              v160 = 1024;
              v161 = 462;
              _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid parameter", buf, 0x22u);
            }

            v92 = *(_QWORD *)(a1 + 48);
            v93 = objc_alloc((Class)NSError);
            v36 = (NSMutableArray *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
            v147 = NSLocalizedDescriptionKey;
            v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid Parameter"));
            v148 = v37;
            v94 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v148, &v147, 1));
            v95 = objc_msgSend(v93, "initWithDomain:code:userInfo:", v36, 10, v94);
            (*(void (**)(uint64_t, id, _QWORD))(v92 + 16))(v92, v95, 0);

            goto LABEL_25;
          }
        }
        v43 = -[objc_class countByEnumeratingWithState:objects:count:](v35, "countByEnumeratingWithState:objects:count:", &v141, v149, 16);
        if (v43)
          continue;
        break;
      }
    }

    if (!*(_QWORD *)(*(_QWORD *)(a1 + 32) + 184))
    {
      v47 = objc_opt_new(NFVASReader);
      v48 = *(_QWORD *)(a1 + 32);
      v49 = *(void **)(v48 + 184);
      *(_QWORD *)(v48 + 184) = v47;

      v50 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "driverWrapper"));
      sub_100051EF0(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 184), v50);

      sub_100084994(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 184), *(void **)(*(_QWORD *)(a1 + 32) + 176));
      v51 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 184);
      if (v51)
        *(_QWORD *)(v51 + 24) = 0x404E000000000000;
    }
    if (*(_BYTE *)(a1 + 64))
    {
      v52 = NFSharedSignpostLog(v46);
      v53 = objc_claimAutoreleasedReturnValue(v52);
      if (os_signpost_enabled(v53))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v53, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "_NFSecureElementReaderSession+select_OSE", "", buf, 2u);
      }

      v54 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 184);
      v140.isa = 0;
      v55 = sub_10008201C(v54, &v140);
      v36 = (NSMutableArray *)objc_claimAutoreleasedReturnValue(v55);
      v56 = v140.isa;
      if (v56)
      {
        v35 = v56;
        v57 = NFSharedSignpostLog(v56);
        v58 = objc_claimAutoreleasedReturnValue(v57);
        if (os_signpost_enabled(v58))
        {
          v59 = -[objc_class code](v35, "code");
          *(_DWORD *)buf = 67109120;
          v155 = v59;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v58, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "_NFSecureElementReaderSession+select_OSE", "error.code: %d", buf, 8u);
        }

        v60 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v61 = NFLogGetLogger(v60);
        if (v61)
        {
          v62 = (void (*)(uint64_t, const char *, ...))v61;
          v63 = object_getClass(*(id *)(a1 + 32));
          v64 = class_isMetaClass(v63);
          v132 = object_getClassName(*(id *)(a1 + 32));
          v135 = sel_getName(*(SEL *)(a1 + 56));
          v65 = 45;
          if (v64)
            v65 = 43;
          v62(3, "%c[%{public}s %{public}s]:%i error: %{public}@", v65, v132, v135, 481, v35);
        }
        v66 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v67 = NFSharedLogGetLogger(v66);
        v68 = objc_claimAutoreleasedReturnValue(v67);
        if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
        {
          v69 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v69))
            v70 = 43;
          else
            v70 = 45;
          v71 = object_getClassName(*(id *)(a1 + 32));
          v72 = sel_getName(*(SEL *)(a1 + 56));
          *(_DWORD *)buf = 67110146;
          v155 = v70;
          v156 = 2082;
          v157 = v71;
          v158 = 2082;
          v159 = v72;
          v160 = 1024;
          v161 = 481;
          v162 = 2114;
          v163 = v35;
          _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i error: %{public}@", buf, 0x2Cu);
        }

        v73 = *(_QWORD *)(a1 + 48);
        v74 = objc_alloc((Class)NSError);
        v75 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v76 = -[objc_class code](v35, "code");
        v145[0] = NSLocalizedDescriptionKey;
        if ((uint64_t)-[objc_class code](v35, "code") > 70)
          v77 = 71;
        else
          v77 = (uint64_t)-[objc_class code](v35, "code");
        v127 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E8DA8[v77]));
        v146[0] = v127;
        v146[1] = v35;
        v145[1] = NSUnderlyingErrorKey;
        v145[2] = CFSTR("Line");
        v146[2] = &off_1002FFAF8;
        v145[3] = CFSTR("Method");
        v128 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
        v146[3] = v128;
        v145[4] = NSDebugDescriptionErrorKey;
        v129 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 482);
        v146[4] = v129;
        v130 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v146, v145, 5));
        v131 = objc_msgSend(v74, "initWithDomain:code:userInfo:", v75, v76, v130);
        (*(void (**)(uint64_t, id, _QWORD))(v73 + 16))(v73, v131, 0);

LABEL_26:
        return;
      }

    }
    v111 = *(void **)(a1 + 40);
    v112 = *(unsigned __int8 **)(*(_QWORD *)(a1 + 32) + 184);
    v139 = 0;
    v113 = sub_1000830AC(v112, v111, &v139);
    v35 = (objc_class *)objc_claimAutoreleasedReturnValue(v113);
    v36 = v139;
    if (v35)
    {
      v114 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v115 = NFLogGetLogger(v114);
      if (v115)
      {
        v116 = (void (*)(uint64_t, const char *, ...))v115;
        v117 = object_getClass(*(id *)(a1 + 32));
        v118 = class_isMetaClass(v117);
        v133 = object_getClassName(*(id *)(a1 + 32));
        v138 = sel_getName(*(SEL *)(a1 + 56));
        v119 = 45;
        if (v118)
          v119 = 43;
        v116(3, "%c[%{public}s %{public}s]:%i error: %{public}@", v119, v133, v138, 490, v35);
      }
      v120 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v121 = NFSharedLogGetLogger(v120);
      v122 = objc_claimAutoreleasedReturnValue(v121);
      if (os_log_type_enabled(v122, OS_LOG_TYPE_ERROR))
      {
        v123 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v123))
          v124 = 43;
        else
          v124 = 45;
        v125 = object_getClassName(*(id *)(a1 + 32));
        v126 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)buf = 67110146;
        v155 = v124;
        v156 = 2082;
        v157 = v125;
        v158 = 2082;
        v159 = v126;
        v160 = 1024;
        v161 = 490;
        v162 = 2114;
        v163 = v35;
        _os_log_impl((void *)&_mh_execute_header, v122, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i error: %{public}@", buf, 0x2Cu);
      }

    }
    (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
    goto LABEL_26;
  }
  v16 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v17 = NFLogGetLogger(v16);
  if (v17)
  {
    v18 = (void (*)(uint64_t, const char *, ...))v17;
    v19 = object_getClass(*(id *)(a1 + 32));
    v20 = class_isMetaClass(v19);
    v21 = object_getClassName(*(id *)(a1 + 32));
    v22 = sel_getName(*(SEL *)(a1 + 56));
    v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v24 = 45;
    if (v20)
      v24 = 43;
    v18(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v24, v21, v22, 452, v23);

  }
  v25 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v26 = NFSharedLogGetLogger(v25);
  v27 = objc_claimAutoreleasedReturnValue(v26);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
  {
    v28 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v28))
      v29 = 43;
    else
      v29 = 45;
    v30 = object_getClassName(*(id *)(a1 + 32));
    v31 = sel_getName(*(SEL *)(a1 + 56));
    v32 = (objc_class *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v155 = v29;
    v156 = 2082;
    v157 = v30;
    v158 = 2082;
    v159 = v31;
    v160 = 1024;
    v161 = 452;
    v162 = 2114;
    v163 = v32;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v33 = *(_QWORD *)(a1 + 48);
  if (v33)
  {
    v34 = objc_alloc((Class)NSError);
    v35 = (objc_class *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v152 = NSLocalizedDescriptionKey;
    v36 = (NSMutableArray *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v153 = v36;
    v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v153, &v152, 1));
    v38 = v34;
    v39 = v35;
    v40 = 54;
    goto LABEL_24;
  }
}

void sub_100145AC4(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  objc_class *v13;
  int v14;
  const char *v15;
  const char *v16;
  void *v17;
  void *v18;
  uint64_t v19;
  void (*v20)(uint64_t, const char *, ...);
  objc_class *v21;
  _BOOL4 v22;
  const char *v23;
  const char *v24;
  void *v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  NSObject *v29;
  objc_class *v30;
  int v31;
  const char *v32;
  const char *v33;
  void *v34;
  uint64_t v35;
  id v36;
  id v37;
  void *v38;
  void *v39;
  id v40;
  void *v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  id v45;
  void *v46;
  void *v48;
  void *v49;
  uint64_t v50;
  uint64_t v51;
  NSObject *v52;
  unsigned int v53;
  uint64_t v54;
  NSObject *v55;
  id v56;
  uint64_t v57;
  NSErrorUserInfoKey v58;
  void *v59;
  NSErrorUserInfoKey v60;
  void *v61;
  uint8_t buf[4];
  unsigned int v63;
  __int16 v64;
  const char *v65;
  __int16 v66;
  const char *v67;
  __int16 v68;
  int v69;
  __int16 v70;
  void *v71;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    v9 = 45;
    if (isMetaClass)
      v9 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 506, *(_QWORD *)(a1 + 40));
  }
  v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v11 = NFSharedLogGetLogger(v10);
  v12 = objc_claimAutoreleasedReturnValue(v11);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    v13 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v13))
      v14 = 43;
    else
      v14 = 45;
    v15 = object_getClassName(*(id *)(a1 + 32));
    v16 = sel_getName(*(SEL *)(a1 + 56));
    v17 = *(void **)(a1 + 40);
    *(_DWORD *)buf = 67110146;
    v63 = v14;
    v64 = 2082;
    v65 = v15;
    v66 = 2082;
    v67 = v16;
    v68 = 1024;
    v69 = 506;
    v70 = 2114;
    v71 = v17;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }

  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v41 = (void *)objc_claimAutoreleasedReturnValue(+[_NFHardwareManager sharedHardwareManager](_NFHardwareManager, "sharedHardwareManager"));
    objc_msgSend(v41, "notifyReaderModeActivityStart");

    v42 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 192);
    if (v42 && (v42 = sub_10017E9A4((void *)v42, *(void **)(a1 + 40), 0), (_DWORD)v42))
    {
      LODWORD(v43) = v42;
      v44 = v42 & 0x6F;
      v45 = objc_alloc((Class)NSError);
      v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      if (v44 == 35 || (_DWORD)v43 == 64)
        v43 = v43;
      else
        v43 = 15;
      v58 = NSLocalizedDescriptionKey;
      v48 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E8DA8[v43]));
      v59 = v48;
      v49 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v59, &v58, 1));
      v37 = objc_msgSend(v45, "initWithDomain:code:userInfo:", v46, v43, v49);

      v51 = NFSharedSignpostLog(v50);
      v52 = objc_claimAutoreleasedReturnValue(v51);
      if (os_signpost_enabled(v52))
      {
        v53 = objc_msgSend(v37, "code");
        *(_DWORD *)buf = 67109120;
        v63 = v53;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v52, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "_NFSecureElementReaderSession+tag_connect", "begin, error.code: %d", buf, 8u);
      }
    }
    else
    {
      v54 = NFSharedSignpostLog(v42);
      v55 = objc_claimAutoreleasedReturnValue(v54);
      if (os_signpost_enabled(v55))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v55, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "_NFSecureElementReaderSession+tag_connect", "begin", buf, 2u);
      }

      v56 = objc_msgSend(objc_alloc((Class)NFTagInternal), "initWithNFTag:", *(_QWORD *)(a1 + 40));
      v37 = 0;
      v57 = *(_QWORD *)(a1 + 32);
      v52 = *(NSObject **)(v57 + 176);
      *(_QWORD *)(v57 + 176) = v56;
    }

    (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
    goto LABEL_24;
  }
  v18 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v19 = NFLogGetLogger(v18);
  if (v19)
  {
    v20 = (void (*)(uint64_t, const char *, ...))v19;
    v21 = object_getClass(*(id *)(a1 + 32));
    v22 = class_isMetaClass(v21);
    v23 = object_getClassName(*(id *)(a1 + 32));
    v24 = sel_getName(*(SEL *)(a1 + 56));
    v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v26 = 45;
    if (v22)
      v26 = 43;
    v20(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v26, v23, v24, 507, v25);

  }
  v27 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v28 = NFSharedLogGetLogger(v27);
  v29 = objc_claimAutoreleasedReturnValue(v28);
  if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
  {
    v30 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v30))
      v31 = 43;
    else
      v31 = 45;
    v32 = object_getClassName(*(id *)(a1 + 32));
    v33 = sel_getName(*(SEL *)(a1 + 56));
    v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v63 = v31;
    v64 = 2082;
    v65 = v32;
    v66 = 2082;
    v67 = v33;
    v68 = 1024;
    v69 = 507;
    v70 = 2114;
    v71 = v34;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v35 = *(_QWORD *)(a1 + 48);
  if (v35)
  {
    v36 = objc_alloc((Class)NSError);
    v37 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v60 = NSLocalizedDescriptionKey;
    v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v61 = v38;
    v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v61, &v60, 1));
    v40 = objc_msgSend(v36, "initWithDomain:code:userInfo:", v37, 54, v39);
    (*(void (**)(uint64_t, id))(v35 + 16))(v35, v40);

LABEL_24:
  }
}

void sub_100146150(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  void *v10;
  id v11;
  void *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  NSObject *v16;
  objc_class *v17;
  int v18;
  const char *v19;
  const char *v20;
  void *v21;
  void *v22;
  unsigned int v23;
  void *v24;
  void *v25;
  uint64_t v26;
  void (*v27)(uint64_t, const char *, ...);
  objc_class *v28;
  _BOOL4 v29;
  const char *v30;
  const char *v31;
  void *v32;
  uint64_t v33;
  void *v34;
  uint64_t v35;
  NSObject *v36;
  objc_class *v37;
  int v38;
  const char *v39;
  const char *v40;
  void *v41;
  uint64_t v42;
  id v43;
  void *v44;
  void *v45;
  void *v46;
  id v47;
  void *v48;
  uint64_t v49;
  NSObject *v50;
  _BOOL4 v51;
  unsigned int v52;
  const char *v53;
  NSObject *v54;
  uint32_t v55;
  NSErrorUserInfoKey v56;
  void *v57;
  uint8_t buf[4];
  unsigned int v59;
  __int16 v60;
  const char *v61;
  __int16 v62;
  const char *v63;
  __int16 v64;
  int v65;
  __int16 v66;
  void *v67;
  __int16 v68;
  unsigned int v69;
  __int16 v70;
  void *v71;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "connection"));
    v11 = objc_msgSend(v10, "processIdentifier");
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v13 = 43;
    if (!isMetaClass)
      v13 = 45;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@ (%d) %{public}@", v13, ClassName, Name, 533, v9, v11, v12);

  }
  v14 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v15 = NFSharedLogGetLogger(v14);
  v16 = objc_claimAutoreleasedReturnValue(v15);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    v17 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v17))
      v18 = 43;
    else
      v18 = 45;
    v19 = object_getClassName(*(id *)(a1 + 32));
    v20 = sel_getName(*(SEL *)(a1 + 48));
    v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "connection"));
    v23 = objc_msgSend(v22, "processIdentifier");
    v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110658;
    v59 = v18;
    v60 = 2082;
    v61 = v19;
    v62 = 2082;
    v63 = v20;
    v64 = 1024;
    v65 = 533;
    v66 = 2114;
    v67 = v21;
    v68 = 1024;
    v69 = v23;
    v70 = 2114;
    v71 = v24;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@ (%d) %{public}@", buf, 0x3Cu);

  }
  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v48 = (void *)objc_claimAutoreleasedReturnValue(+[_NFHardwareManager sharedHardwareManager](_NFHardwareManager, "sharedHardwareManager"));
    objc_msgSend(v48, "notifyReaderModeActivityEnd");

    v44 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "_disconnectWithCardRemoval:", *(unsigned __int8 *)(a1 + 56)));
    v49 = NFSharedSignpostLog(v44);
    v50 = objc_claimAutoreleasedReturnValue(v49);
    v51 = os_signpost_enabled(v50);
    if (v44)
    {
      if (v51)
      {
        v52 = objc_msgSend(v44, "code");
        *(_DWORD *)buf = 67109120;
        v59 = v52;
        v53 = "end, error.code: %d";
        v54 = v50;
        v55 = 8;
LABEL_31:
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v54, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "_NFSecureElementReaderSession+tag_connect", v53, buf, v55);
      }
    }
    else if (v51)
    {
      *(_WORD *)buf = 0;
      v53 = "end";
      v54 = v50;
      v55 = 2;
      goto LABEL_31;
    }

    (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
    goto LABEL_24;
  }
  v25 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v26 = NFLogGetLogger(v25);
  if (v26)
  {
    v27 = (void (*)(uint64_t, const char *, ...))v26;
    v28 = object_getClass(*(id *)(a1 + 32));
    v29 = class_isMetaClass(v28);
    v30 = object_getClassName(*(id *)(a1 + 32));
    v31 = sel_getName(*(SEL *)(a1 + 48));
    v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v33 = 45;
    if (v29)
      v33 = 43;
    v27(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v33, v30, v31, 535, v32);

  }
  v34 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v35 = NFSharedLogGetLogger(v34);
  v36 = objc_claimAutoreleasedReturnValue(v35);
  if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
  {
    v37 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v37))
      v38 = 43;
    else
      v38 = 45;
    v39 = object_getClassName(*(id *)(a1 + 32));
    v40 = sel_getName(*(SEL *)(a1 + 48));
    v41 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v59 = v38;
    v60 = 2082;
    v61 = v39;
    v62 = 2082;
    v63 = v40;
    v64 = 1024;
    v65 = 535;
    v66 = 2114;
    v67 = v41;
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v42 = *(_QWORD *)(a1 + 40);
  if (v42)
  {
    v43 = objc_alloc((Class)NSError);
    v44 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v56 = NSLocalizedDescriptionKey;
    v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v57 = v45;
    v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v57, &v56, 1));
    v47 = objc_msgSend(v43, "initWithDomain:code:userInfo:", v44, 54, v46);
    (*(void (**)(uint64_t, id))(v42 + 16))(v42, v47);

LABEL_24:
  }
}

void sub_10014741C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100147454(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_100147464(uint64_t a1)
{

}

void sub_10014746C(uint64_t a1, void *a2, uint64_t a3, _BYTE *a4)
{
  void *v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  id v11;

  v11 = a2;
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "identifierAsData"));
  v7 = objc_msgSend(v6, "isEqualToData:", *(_QWORD *)(a1 + 32));

  if (v7)
  {
    v8 = objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "identifier"));
    v9 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    v10 = *(void **)(v9 + 40);
    *(_QWORD *)(v9 + 40) = v8;

    *a4 = 1;
  }

}

void sub_1001480F8(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100148A8C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100148D04(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_100148D2C(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  NSObject *v11;
  objc_class *v12;
  int v13;
  const char *v14;
  const char *v15;
  const char *Name;
  uint8_t buf[4];
  int v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v8 = 45;
    if (isMetaClass)
      v8 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i ", v8, ClassName, Name, 186);
  }
  v9 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v10 = NFSharedLogGetLogger(v9);
  v11 = objc_claimAutoreleasedReturnValue(v10);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v12 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v12))
      v13 = 43;
    else
      v13 = 45;
    v14 = object_getClassName(*(id *)(a1 + 32));
    v15 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)buf = 67109890;
    v19 = v13;
    v20 = 2082;
    v21 = v14;
    v22 = 2082;
    v23 = v15;
    v24 = 1024;
    v25 = 186;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
  }

  return objc_msgSend(*(id *)(a1 + 32), "internalEndSession:", *(_QWORD *)(a1 + 40));
}

void sub_100149514(uint64_t a1)
{
  void *v2;
  void *v3;
  int v4;
  void *v5;
  uint64_t v6;
  void (*v7)(uint64_t, const char *, ...);
  objc_class *v8;
  _BOOL4 v9;
  const char *v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  objc_class *v15;
  int v16;
  id v17;
  void *specific;
  uint64_t Logger;
  void (*v20)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  NSObject *v27;
  objc_class *v28;
  int v29;
  uint64_t v30;
  NSObject *v31;
  id v32;
  void *v33;
  uint64_t v34;
  void (*v35)(uint64_t, const char *, ...);
  objc_class *v36;
  _BOOL4 v37;
  const char *v38;
  uint64_t v39;
  void *v40;
  uint64_t v41;
  NSObject *v42;
  objc_class *v43;
  int v44;
  const char *v45;
  const char *v46;
  void *v47;
  void *v48;
  void *v49;
  uint64_t v50;
  uint64_t v51;
  NSObject *v52;
  _BOOL4 v53;
  uint64_t v54;
  NSObject *v55;
  id v56;
  void *v57;
  uint64_t v58;
  void (*v59)(uint64_t, const char *, ...);
  objc_class *v60;
  _BOOL4 v61;
  const char *v62;
  uint64_t v63;
  void *v64;
  uint64_t v65;
  NSObject *v66;
  objc_class *v67;
  int v68;
  const char *v69;
  const char *v70;
  void *v71;
  void *v72;
  uint64_t v73;
  uint64_t v74;
  _BOOL4 v75;
  uint64_t v76;
  NSObject *v77;
  id v78;
  void *v79;
  uint64_t v80;
  void (*v81)(uint64_t, const char *, ...);
  objc_class *v82;
  _BOOL4 v83;
  const char *v84;
  uint64_t v85;
  void *v86;
  uint64_t v87;
  NSObject *v88;
  objc_class *v89;
  int v90;
  const char *v91;
  const char *v92;
  void *v93;
  void *v94;
  uint64_t v95;
  uint64_t v96;
  _BOOL4 v97;
  const char *v98;
  const char *Name;
  const char *v100;
  const char *v101;
  const char *v102;
  uint8_t buf[4];
  int v104;
  __int16 v105;
  const char *v106;
  __int16 v107;
  const char *v108;
  __int16 v109;
  int v110;

  if (a1)
  {
    v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"));
    v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "objectForKey:", CFSTR("RecoveryAttempts")));
    v4 = objc_msgSend(v3, "intValue");

    if (v4 < 101)
    {
      v17 = objc_msgSend((id)a1, "_checkFailForwardState");
      switch((int)v17)
      {
        case 0:
          specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          Logger = NFLogGetLogger(specific);
          if (Logger)
          {
            v20 = (void (*)(uint64_t, const char *, ...))Logger;
            Class = object_getClass((id)a1);
            isMetaClass = class_isMetaClass(Class);
            ClassName = object_getClassName((id)a1);
            Name = sel_getName("recoverFailForwardIfNeeded");
            v24 = 45;
            if (isMetaClass)
              v24 = 43;
            v20(6, "%c[%{public}s %{public}s]:%i recovered already..", v24, ClassName, Name, 149);
          }
          v25 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v26 = NFSharedLogGetLogger(v25);
          v27 = objc_claimAutoreleasedReturnValue(v26);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
          {
            v28 = object_getClass((id)a1);
            if (class_isMetaClass(v28))
              v29 = 43;
            else
              v29 = 45;
            *(_DWORD *)buf = 67109890;
            v104 = v29;
            v105 = 2082;
            v106 = object_getClassName((id)a1);
            v107 = 2082;
            v108 = sel_getName("recoverFailForwardIfNeeded");
            v109 = 1024;
            v110 = 149;
            _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i recovered already..", buf, 0x22u);
          }

          if (!*(_BYTE *)(a1 + 24))
            objc_msgSend((id)a1, "_storeFailForwardRecovery:", 1);
          return;
        case 1:
          v30 = NFSharedSignpostLog(v17);
          v31 = objc_claimAutoreleasedReturnValue(v30);
          if (os_signpost_enabled(v31))
          {
            *(_WORD *)buf = 0;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v31, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "HWRecovery", "begin", buf, 2u);
          }

          v32 = *(id *)(a1 + 248);
          objc_msgSend(v32, "handleHWRecoveryStarted");

          v33 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v34 = NFLogGetLogger(v33);
          if (v34)
          {
            v35 = (void (*)(uint64_t, const char *, ...))v34;
            v36 = object_getClass((id)a1);
            v37 = class_isMetaClass(v36);
            v38 = object_getClassName((id)a1);
            v100 = sel_getName("recoverFailForwardIfNeeded");
            v39 = 45;
            if (v37)
              v39 = 43;
            v35(6, "%c[%{public}s %{public}s]:%i Full restore..", v39, v38, v100, 106);
          }
          v40 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v41 = NFSharedLogGetLogger(v40);
          v42 = objc_claimAutoreleasedReturnValue(v41);
          if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
          {
            v43 = object_getClass((id)a1);
            if (class_isMetaClass(v43))
              v44 = 43;
            else
              v44 = 45;
            v45 = object_getClassName((id)a1);
            v46 = sel_getName("recoverFailForwardIfNeeded");
            *(_DWORD *)buf = 67109890;
            v104 = v44;
            v105 = 2082;
            v106 = v45;
            v107 = 2082;
            v108 = v46;
            v109 = 1024;
            v110 = 106;
            _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Full restore..", buf, 0x22u);
          }

          v47 = (void *)objc_opt_new(NFRestoreService);
          v48 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v47, "runService:", &off_100306808));

          v49 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v48, "valueForKey:", CFSTR("Error")));
          v51 = NFSharedSignpostLog(v50);
          v52 = objc_claimAutoreleasedReturnValue(v51);
          v53 = os_signpost_enabled(v52);
          if (v49)
          {
            if (!v53)
              goto LABEL_68;
            *(_WORD *)buf = 0;
            goto LABEL_67;
          }
          if (!v53)
            goto LABEL_76;
          *(_WORD *)buf = 0;
          goto LABEL_75;
        case 2:
          v54 = NFSharedSignpostLog(v17);
          v55 = objc_claimAutoreleasedReturnValue(v54);
          if (os_signpost_enabled(v55))
          {
            *(_WORD *)buf = 0;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v55, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "HWRecovery", "begin", buf, 2u);
          }

          v56 = *(id *)(a1 + 248);
          objc_msgSend(v56, "handleHWRecoveryStarted");

          v57 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v58 = NFLogGetLogger(v57);
          if (v58)
          {
            v59 = (void (*)(uint64_t, const char *, ...))v58;
            v60 = object_getClass((id)a1);
            v61 = class_isMetaClass(v60);
            v62 = object_getClassName((id)a1);
            v101 = sel_getName("recoverFailForwardIfNeeded");
            v63 = 45;
            if (v61)
              v63 = 43;
            v59(6, "%c[%{public}s %{public}s]:%i Stockholm only restore..", v63, v62, v101, 120);
          }
          v64 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v65 = NFSharedLogGetLogger(v64);
          v66 = objc_claimAutoreleasedReturnValue(v65);
          if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
          {
            v67 = object_getClass((id)a1);
            if (class_isMetaClass(v67))
              v68 = 43;
            else
              v68 = 45;
            v69 = object_getClassName((id)a1);
            v70 = sel_getName("recoverFailForwardIfNeeded");
            *(_DWORD *)buf = 67109890;
            v104 = v68;
            v105 = 2082;
            v106 = v69;
            v107 = 2082;
            v108 = v70;
            v109 = 1024;
            v110 = 120;
            _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Stockholm only restore..", buf, 0x22u);
          }

          v71 = (void *)objc_opt_new(NFRestoreService);
          v48 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v71, "runService:", &off_100306830));

          v72 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v48, "valueForKey:", CFSTR("Error")));
          v74 = NFSharedSignpostLog(v73);
          v52 = objc_claimAutoreleasedReturnValue(v74);
          v75 = os_signpost_enabled(v52);
          if (v72)
          {
            if (!v75)
              goto LABEL_68;
            *(_WORD *)buf = 0;
            goto LABEL_67;
          }
          if (!v75)
            goto LABEL_76;
          *(_WORD *)buf = 0;
          goto LABEL_75;
        case 3:
          v76 = NFSharedSignpostLog(v17);
          v77 = objc_claimAutoreleasedReturnValue(v76);
          if (os_signpost_enabled(v77))
          {
            *(_WORD *)buf = 0;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v77, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "HWRecovery", "begin", buf, 2u);
          }

          v78 = *(id *)(a1 + 248);
          objc_msgSend(v78, "handleHWRecoveryStarted");

          v79 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v80 = NFLogGetLogger(v79);
          if (v80)
          {
            v81 = (void (*)(uint64_t, const char *, ...))v80;
            v82 = object_getClass((id)a1);
            v83 = class_isMetaClass(v82);
            v84 = object_getClassName((id)a1);
            v102 = sel_getName("recoverFailForwardIfNeeded");
            v85 = 45;
            if (v83)
              v85 = 43;
            v81(6, "%c[%{public}s %{public}s]:%i hammerfest only restore..", v85, v84, v102, 135);
          }
          v86 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v87 = NFSharedLogGetLogger(v86);
          v88 = objc_claimAutoreleasedReturnValue(v87);
          if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
          {
            v89 = object_getClass((id)a1);
            if (class_isMetaClass(v89))
              v90 = 43;
            else
              v90 = 45;
            v91 = object_getClassName((id)a1);
            v92 = sel_getName("recoverFailForwardIfNeeded");
            *(_DWORD *)buf = 67109890;
            v104 = v90;
            v105 = 2082;
            v106 = v91;
            v107 = 2082;
            v108 = v92;
            v109 = 1024;
            v110 = 135;
            _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i hammerfest only restore..", buf, 0x22u);
          }

          v93 = (void *)objc_opt_new(NFRestoreService);
          v48 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v93, "runService:", &off_100306858));

          v94 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v48, "valueForKey:", CFSTR("Error")));
          v96 = NFSharedSignpostLog(v95);
          v52 = objc_claimAutoreleasedReturnValue(v96);
          v97 = os_signpost_enabled(v52);
          if (v94)
          {
            if (v97)
            {
              *(_WORD *)buf = 0;
LABEL_67:
              _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v52, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "HWRecovery", "end, failed", buf, 2u);
            }
LABEL_68:

            objc_msgSend((id)a1, "_recoveryFailed");
          }
          else
          {
            if (v97)
            {
              *(_WORD *)buf = 0;
LABEL_75:
              _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v52, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "HWRecovery", "end", buf, 2u);
            }
LABEL_76:

            objc_msgSend((id)a1, "_recoverySucceeded");
          }

          break;
        default:
          return;
      }
    }
    else
    {
      v5 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v6 = NFLogGetLogger(v5);
      if (v6)
      {
        v7 = (void (*)(uint64_t, const char *, ...))v6;
        v8 = object_getClass((id)a1);
        v9 = class_isMetaClass(v8);
        v10 = object_getClassName((id)a1);
        v98 = sel_getName("recoverFailForwardIfNeeded");
        v11 = 45;
        if (v9)
          v11 = 43;
        v7(6, "%c[%{public}s %{public}s]:%i Recovered from failed restore", v11, v10, v98, 96);
      }
      v12 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v13 = NFSharedLogGetLogger(v12);
      v14 = objc_claimAutoreleasedReturnValue(v13);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        v15 = object_getClass((id)a1);
        if (class_isMetaClass(v15))
          v16 = 43;
        else
          v16 = 45;
        *(_DWORD *)buf = 67109890;
        v104 = v16;
        v105 = 2082;
        v106 = object_getClassName((id)a1);
        v107 = 2082;
        v108 = sel_getName("recoverFailForwardIfNeeded");
        v109 = 1024;
        v110 = 96;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Recovered from failed restore", buf, 0x22u);
      }

    }
  }
}

uint64_t sub_10014A36C(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  NSObject *v11;
  objc_class *v12;
  int v13;
  const char *v14;
  const char *v15;
  const char *Name;
  uint8_t buf[4];
  int v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 40));
    v8 = 45;
    if (isMetaClass)
      v8 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i Hammerfest failed during restore", v8, ClassName, Name, 202);
  }
  v9 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v10 = NFSharedLogGetLogger(v9);
  v11 = objc_claimAutoreleasedReturnValue(v10);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v12 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v12))
      v13 = 43;
    else
      v13 = 45;
    v14 = object_getClassName(*(id *)(a1 + 32));
    v15 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)buf = 67109890;
    v19 = v13;
    v20 = 2082;
    v21 = v14;
    v22 = 2082;
    v23 = v15;
    v24 = 1024;
    v25 = 202;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Hammerfest failed during restore", buf, 0x22u);
  }

  *(_DWORD *)(*(_QWORD *)(a1 + 32) + 28) = 3;
  return *(unsigned int *)(*(_QWORD *)(a1 + 32) + 28);
}

uint64_t sub_10014A4F8(uint64_t a1)
{
  int v2;
  _UNKNOWN **v3;
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  const __CFString *v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  NSObject *v15;
  objc_class *v16;
  int v17;
  const char *v18;
  const char *v19;
  const __CFString *v20;
  uint8_t buf[4];
  int v23;
  __int16 v24;
  const char *v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  const __CFString *v31;

  v2 = MSUParsedToleratedFailureForStep(CFSTR("update_stockholm"));
  *(_DWORD *)(*(_QWORD *)(a1 + 32) + 28) = 2 * (v2 != 0);
  if (*(_DWORD *)(*(_QWORD *)(a1 + 32) + 28))
  {
    +[NFExceptionsCALogger postAnalyticsMobileSoftwareUpdateExceptionEvent:](NFExceptionsCALogger, "postAnalyticsMobileSoftwareUpdateExceptionEvent:", (unsigned __int16)v2);
    v3 = &off_100306880;
  }
  else
  {
    v3 = &off_1003068A8;
  }
  +[NFGeneralStatisticsCALogger updateGeneralDeviceStatistic:](NFGeneralStatisticsCALogger, "updateGeneralDeviceStatistic:", v3);
  objc_msgSend(*(id *)(a1 + 40), "removeObjectForKey:", CFSTR("RecoveryAttempts"));
  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v6 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    if (*(_DWORD *)(*(_QWORD *)(a1 + 32) + 28))
      v11 = CFSTR("failed");
    else
      v11 = CFSTR("succeeded");
    v12 = 45;
    if (isMetaClass)
      v12 = 43;
    v6(6, "%c[%{public}s %{public}s]:%i MSU reports restore %{public}@", v12, ClassName, Name, 226, v11);
  }
  v13 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v14 = NFSharedLogGetLogger(v13);
  v15 = objc_claimAutoreleasedReturnValue(v14);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    v16 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v16))
      v17 = 43;
    else
      v17 = 45;
    v18 = object_getClassName(*(id *)(a1 + 32));
    v19 = sel_getName(*(SEL *)(a1 + 48));
    if (*(_DWORD *)(*(_QWORD *)(a1 + 32) + 28))
      v20 = CFSTR("failed");
    else
      v20 = CFSTR("succeeded");
    *(_DWORD *)buf = 67110146;
    v23 = v17;
    v24 = 2082;
    v25 = v18;
    v26 = 2082;
    v27 = v19;
    v28 = 1024;
    v29 = 226;
    v30 = 2114;
    v31 = v20;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i MSU reports restore %{public}@", buf, 0x2Cu);
  }

  return *(unsigned int *)(*(_QWORD *)(a1 + 32) + 28);
}

void sub_10014AB8C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10014ABB8(uint64_t a1, int a2)
{
  void *v3;
  id v4;

  if (a1)
  {
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"));
    v4 = v3;
    if (a2)
      objc_msgSend(v3, "setBool:forKey:", 1, CFSTR("RecoveryInProgress"));
    else
      objc_msgSend(v3, "removeObjectForKey:", CFSTR("RecoveryInProgress"));

  }
}

id sub_10014AC20(void *a1)
{
  uint64_t v2;
  void *v3;
  id v4;
  void *v5;
  void *specific;
  void (*Logger)(uint64_t, const char *, ...);
  objc_class *Class;
  uint64_t v9;
  const char *ClassName;
  const char *Name;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  objc_class *v15;
  int v16;
  id v17;
  void *v18;
  uint64_t v19;
  void (*v20)(uint64_t, const char *, ...);
  objc_class *v21;
  _BOOL4 isMetaClass;
  const char *v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  NSObject *v27;
  objc_class *v28;
  int v29;
  id v30;
  void *v31;
  void *v32;
  const char *v34;
  uint8_t buf[4];
  int v36;
  __int16 v37;
  const char *v38;
  __int16 v39;
  const char *v40;
  __int16 v41;
  int v42;
  __int16 v43;
  void *v44;
  __int16 v45;
  const __CFString *v46;
  NSErrorUserInfoKey v47;
  void *v48;

  if (!a1)
    return 0;
  v2 = NFBuildVersion();
  v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  if (v3)
  {
    v4 = a1;
    objc_sync_enter(v4);
    sub_10014ABB8((uint64_t)v4, 1);
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"));
    objc_msgSend(v5, "setObject:forKey:", v3, CFSTR("FuryRecoveryNeeded"));

    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(specific);
    if (Logger)
    {
      Class = object_getClass(v4);
      if (class_isMetaClass(Class))
        v9 = 43;
      else
        v9 = 45;
      ClassName = object_getClassName(v4);
      Name = sel_getName("attemptHammerfestRecovery");
      Logger(3, "%c[%{public}s %{public}s]:%i set %{public}@ for %{public}@", v9, ClassName, Name, 291, v3, CFSTR("FuryRecoveryNeeded"));
    }
    v12 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v13 = NFSharedLogGetLogger(v12);
    v14 = objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      v15 = object_getClass(v4);
      if (class_isMetaClass(v15))
        v16 = 43;
      else
        v16 = 45;
      *(_DWORD *)buf = 67110402;
      v36 = v16;
      v37 = 2082;
      v38 = object_getClassName(v4);
      v39 = 2082;
      v40 = sel_getName("attemptHammerfestRecovery");
      v41 = 1024;
      v42 = 291;
      v43 = 2114;
      v44 = v3;
      v45 = 2114;
      v46 = CFSTR("FuryRecoveryNeeded");
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i set %{public}@ for %{public}@", buf, 0x36u);
    }

    objc_sync_exit(v4);
    v17 = 0;
  }
  else
  {
    v18 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v19 = NFLogGetLogger(v18);
    if (v19)
    {
      v20 = (void (*)(uint64_t, const char *, ...))v19;
      v21 = object_getClass(a1);
      isMetaClass = class_isMetaClass(v21);
      v23 = object_getClassName(a1);
      v34 = sel_getName("attemptHammerfestRecovery");
      v24 = 45;
      if (isMetaClass)
        v24 = 43;
      v20(3, "%c[%{public}s %{public}s]:%i Failed to query build", v24, v23, v34, 284);
    }
    v25 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v26 = NFSharedLogGetLogger(v25);
    v27 = objc_claimAutoreleasedReturnValue(v26);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      v28 = object_getClass(a1);
      if (class_isMetaClass(v28))
        v29 = 43;
      else
        v29 = 45;
      *(_DWORD *)buf = 67109890;
      v36 = v29;
      v37 = 2082;
      v38 = object_getClassName(a1);
      v39 = 2082;
      v40 = sel_getName("attemptHammerfestRecovery");
      v41 = 1024;
      v42 = 284;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to query build", buf, 0x22u);
    }

    v30 = objc_alloc((Class)NSError);
    v4 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v47 = NSLocalizedDescriptionKey;
    v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unknown Error"));
    v48 = v31;
    v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v48, &v47, 1));
    v17 = objc_msgSend(v30, "initWithDomain:code:userInfo:", v4, 6, v32);

  }
  return v17;
}

void sub_10014AFE8(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_10014B010(void *a1)
{
  id v1;
  id v2;
  void *specific;
  void (*Logger)(uint64_t, const char *, ...);
  objc_class *Class;
  uint64_t v6;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  NSObject *v11;
  objc_class *v12;
  int v13;
  void *v14;
  void (*v15)(uint64_t, const char *, ...);
  objc_class *v16;
  uint64_t v17;
  const char *v18;
  const char *v19;
  void *v20;
  void *v21;
  uint64_t v22;
  NSObject *v23;
  objc_class *v24;
  int v25;
  const char *v26;
  const char *v27;
  void *v28;
  id v29;
  void *v30;
  _BOOL4 v31;
  id v32;
  void *v33;
  uint64_t v34;
  id v35;
  void *v36;
  void (*v37)(uint64_t, const char *, ...);
  objc_class *v38;
  uint64_t v39;
  const char *v40;
  const char *v41;
  void *v42;
  uint64_t v43;
  NSObject *v44;
  objc_class *v45;
  int v46;
  const char *v47;
  const char *v48;
  uint64_t v50;
  uint8_t buf[4];
  int v52;
  __int16 v53;
  const char *v54;
  __int16 v55;
  const char *v56;
  __int16 v57;
  int v58;
  __int16 v59;
  id v60;

  if (a1)
  {
    v1 = a1;
    objc_sync_enter(v1);
    v2 = objc_msgSend(v1, "_checkFailForwardState");
    if ((_DWORD)v2)
    {
      v50 = *((_QWORD *)v1 + 37);
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(specific);
      if (Logger)
      {
        Class = object_getClass(v1);
        if (class_isMetaClass(Class))
          v6 = 43;
        else
          v6 = 45;
        ClassName = object_getClassName(v1);
        Name = sel_getName("attemptFailForwardRecovery");
        Logger(6, "%c[%{public}s %{public}s]:%i [self checkFailForwardState] = %d", v6, ClassName, Name, 306, v2);
      }
      v9 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v10 = NFSharedLogGetLogger(v9);
      v11 = objc_claimAutoreleasedReturnValue(v10);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        v12 = object_getClass(v1);
        if (class_isMetaClass(v12))
          v13 = 43;
        else
          v13 = 45;
        *(_DWORD *)buf = 67110146;
        v52 = v13;
        v53 = 2082;
        v54 = object_getClassName(v1);
        v55 = 2082;
        v56 = sel_getName("attemptFailForwardRecovery");
        v57 = 1024;
        v58 = 306;
        v59 = 1024;
        LODWORD(v60) = (_DWORD)v2;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i [self checkFailForwardState] = %d", buf, 0x28u);
      }

      v14 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v15 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v14);
      if (v15)
      {
        v16 = object_getClass(v1);
        if (class_isMetaClass(v16))
          v17 = 43;
        else
          v17 = 45;
        v18 = object_getClassName(v1);
        v19 = sel_getName("attemptFailForwardRecovery");
        v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"));
        v15(6, "%c[%{public}s %{public}s]:%i NFFailedForwardRecoveryAttempts = %ld", v17, v18, v19, 307, objc_msgSend(v20, "integerForKey:", CFSTR("RecoveryAttempts")));

      }
      v21 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v22 = NFSharedLogGetLogger(v21);
      v23 = objc_claimAutoreleasedReturnValue(v22);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        v24 = object_getClass(v1);
        if (class_isMetaClass(v24))
          v25 = 43;
        else
          v25 = 45;
        v26 = object_getClassName(v1);
        v27 = sel_getName("attemptFailForwardRecovery");
        v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"));
        v29 = objc_msgSend(v28, "integerForKey:", CFSTR("RecoveryAttempts"));
        *(_DWORD *)buf = 67110146;
        v52 = v25;
        v53 = 2082;
        v54 = v26;
        v55 = 2082;
        v56 = v27;
        v57 = 1024;
        v58 = 307;
        v59 = 2048;
        v60 = v29;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i NFFailedForwardRecoveryAttempts = %ld", buf, 0x2Cu);

      }
      if (v2 <= 3)
      {
        v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"));
        v31 = (uint64_t)objc_msgSend(v30, "integerForKey:", CFSTR("RecoveryAttempts")) < 101;

        if (v31)
        {
          if ((*((_BYTE *)v1 + 222) & 1) == 0)
          {
            sub_10014ABB8((uint64_t)v1, 1);
            sub_1001FB474((uint64_t)v1, 0);
            v32 = sub_1001F913C((uint64_t)v1);
            v33 = (void *)objc_claimAutoreleasedReturnValue(v32);
            v34 = *((_QWORD *)v1 + 37);
            if (v34 == 4 || v34 == 1)
            {
              sub_1001FA9CC((uint64_t)v1);
              v34 = *((_QWORD *)v1 + 37);
            }
            if (v34 == v50 || v34 == 1 && v50 == 4)
            {
              v35 = 0;
            }
            else
            {
              v35 = v33;
              v33 = v35;
            }
            goto LABEL_45;
          }
          v36 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v37 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v36);
          if (v37)
          {
            v38 = object_getClass(v1);
            if (class_isMetaClass(v38))
              v39 = 43;
            else
              v39 = 45;
            v40 = object_getClassName(v1);
            v41 = sel_getName("attemptFailForwardRecovery");
            v37(3, "%c[%{public}s %{public}s]:%i Not allowed to power off NFCC. Retry later", v39, v40, v41, 314);
          }
          v42 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v43 = NFSharedLogGetLogger(v42);
          v44 = objc_claimAutoreleasedReturnValue(v43);
          if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
          {
            v45 = object_getClass(v1);
            if (class_isMetaClass(v45))
              v46 = 43;
            else
              v46 = 45;
            v47 = object_getClassName(v1);
            v48 = sel_getName("attemptFailForwardRecovery");
            *(_DWORD *)buf = 67109890;
            v52 = v46;
            v53 = 2082;
            v54 = v47;
            v55 = 2082;
            v56 = v48;
            v57 = 1024;
            v58 = 314;
            _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Not allowed to power off NFCC. Retry later", buf, 0x22u);
          }

        }
      }
    }
    v35 = 0;
    v33 = 0;
LABEL_45:

    objc_sync_exit(v1);
    return v35;
  }
  return 0;
}

void sub_10014B51C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10014C1A8(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10014C1E4(_QWORD *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id v7;
  id v8;
  void *v9;
  void *v10;
  _QWORD v11[5];
  id v12;
  const char *v13;

  v5 = a3;
  if (a1)
  {
    v6 = a2;
    v7 = objc_alloc((Class)NFTimer);
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472;
    v11[2] = sub_10014C2C8;
    v11[3] = &unk_1002E5D28;
    v11[4] = a1;
    v12 = v5;
    v13 = "scheduleNFCCRecoveryOnQueue:onSuccess:";
    v8 = objc_msgSend(v7, "initSleepTimerWithCallback:queue:", v11, v6);

    v9 = (void *)a1[4];
    a1[4] = v8;

    v10 = (void *)a1[4];
    objc_msgSend(a1, "nextRetryTime");
    objc_msgSend(v10, "startTimer:");

  }
}

void sub_10014C2C8(uint64_t a1)
{
  NSObject *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  void *specific;
  uint64_t Logger;
  void (*v10)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  NSObject *v19;
  objc_class *v20;
  int v21;
  const char *v22;
  const char *v23;
  uint64_t v24;
  _QWORD *v25;
  void *v26;
  _BYTE state[18];
  __int16 v28;
  const char *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  uint64_t v33;

  v2 = _os_activity_create((void *)&_mh_execute_header, "com.apple.nfcd.hw.recoveryTimer", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  *(_QWORD *)state = 0;
  *(_QWORD *)&state[8] = 0;
  os_activity_scope_enter(v2, (os_activity_scope_state_t)state);
  os_activity_scope_leave((os_activity_scope_state_t)state);

  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "_attemptNFCCRecovery"));
  if (v3)
    goto LABEL_8;
  v4 = *(_QWORD *)(a1 + 32);
  if (v4)
    *(_BYTE *)(v4 + 223) = 0;
  if (((*(uint64_t (**)(void))(*(_QWORD *)(a1 + 40) + 16))() & 1) == 0)
  {
LABEL_8:
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v10 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      objc_msgSend(*(id *)(a1 + 32), "nextRetryTime");
      v16 = 45;
      if (isMetaClass)
        v16 = 43;
      v10(6, "%c[%{public}s %{public}s]:%i Retrying recovery in %lf seconds", v16, ClassName, Name, 462, v15);
    }
    v17 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v18 = NFSharedLogGetLogger(v17);
    v19 = objc_claimAutoreleasedReturnValue(v18);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      v20 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v20))
        v21 = 43;
      else
        v21 = 45;
      v22 = object_getClassName(*(id *)(a1 + 32));
      v23 = sel_getName(*(SEL *)(a1 + 48));
      objc_msgSend(*(id *)(a1 + 32), "nextRetryTime");
      *(_DWORD *)state = 67110146;
      *(_DWORD *)&state[4] = v21;
      *(_WORD *)&state[8] = 2082;
      *(_QWORD *)&state[10] = v22;
      v28 = 2082;
      v29 = v23;
      v30 = 1024;
      v31 = 462;
      v32 = 2048;
      v33 = v24;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Retrying recovery in %lf seconds", state, 0x2Cu);
    }

    v25 = *(_QWORD **)(a1 + 32);
    v26 = (void *)v25[4];
    objc_msgSend(v25, "nextRetryTime");
    objc_msgSend(v26, "startTimer:");
  }
  else
  {
    v5 = *(_QWORD *)(a1 + 32);
    if (v5)
    {
      *(_DWORD *)(v5 + 8) = 0;
      *(_QWORD *)(v5 + 16) = 0;
      v6 = *(_QWORD *)(a1 + 32);
      if (v6)
      {
        objc_msgSend(*(id *)(v6 + 32), "stopTimer");
        v7 = *(void **)(v6 + 32);
        *(_QWORD *)(v6 + 32) = 0;

      }
    }
  }

}

id sub_10014C524(id result)
{
  void *v1;
  id v2;

  if (result)
  {
    v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"));
    v2 = objc_msgSend(v1, "BOOLForKey:", CFSTR("RecoveryInProgress"));

    return v2;
  }
  return result;
}

BOOL sub_1001519C4(_BOOL8 result)
{
  void *v1;
  id v2;

  if (result)
  {
    v1 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(result + 24), "info"));
    v2 = objc_msgSend(v1, "deviceType");

    return v2 != (id)115;
  }
  return result;
}

void sub_10015584C(uint64_t a1, void *a2)
{
  id v3;
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  objc_class *v13;
  int v14;
  const char *v15;
  const char *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  NSObject *v20;
  const char *ClassName;
  const char *Name;
  uint8_t buf[4];
  _BYTE v24[24];
  __int16 v25;
  int v26;
  __int16 v27;
  id v28;

  v3 = a2;
  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v6 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 40));
    v9 = 45;
    if (isMetaClass)
      v9 = 43;
    v6(6, "%c[%{public}s %{public}s]:%i TSM update notification for AID %{public}@", v9, ClassName, Name, 436, v3);
  }
  v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v11 = NFSharedLogGetLogger(v10);
  v12 = objc_claimAutoreleasedReturnValue(v11);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    v13 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v13))
      v14 = 43;
    else
      v14 = 45;
    v15 = object_getClassName(*(id *)(a1 + 32));
    v16 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)buf = 67110146;
    *(_DWORD *)v24 = v14;
    *(_WORD *)&v24[4] = 2082;
    *(_QWORD *)&v24[6] = v15;
    *(_WORD *)&v24[14] = 2082;
    *(_QWORD *)&v24[16] = v16;
    v25 = 1024;
    v26 = 436;
    v27 = 2114;
    v28 = v3;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i TSM update notification for AID %{public}@", buf, 0x2Cu);
  }

  v17 = (void *)objc_claimAutoreleasedReturnValue(+[_NFHardwareManager sharedHardwareManager](_NFHardwareManager, "sharedHardwareManager"));
  sub_1000EC8E8(v17, (uint64_t)"com.apple.stockholm.se.update.by.tsm", v3);

  v19 = NFSharedSignpostLog(v18);
  v20 = objc_claimAutoreleasedReturnValue(v19);
  if (os_signpost_enabled(v20))
  {
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)v24 = "com.apple.stockholm.se.update.by.tsm";
    *(_WORD *)&v24[8] = 2112;
    *(_QWORD *)&v24[10] = v3;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v20, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "UPDATE_BY_TSM_NOTIFICATION", "%s, key: %@", buf, 0x16u);
  }

}

void sub_100155E7C(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  __CFString *v18;
  void *v19;
  uint64_t v20;
  void (*v21)(uint64_t, const char *, ...);
  objc_class *v22;
  _BOOL4 v23;
  const char *v24;
  const char *v25;
  void *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  NSObject *v30;
  objc_class *v31;
  int v32;
  const char *v33;
  const char *v34;
  __CFString *v35;
  uint64_t v36;
  id v37;
  NSMutableArray *v38;
  id v39;
  void *v40;
  id v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  int v46;
  uint64_t v47;
  void *v48;
  uint64_t v49;
  void (*v50)(uint64_t, const char *, ...);
  objc_class *v51;
  _BOOL4 v52;
  const char *v53;
  const char *v54;
  int v55;
  uint64_t v56;
  void *v57;
  uint64_t v58;
  NSObject *v59;
  objc_class *v60;
  int v61;
  const char *v62;
  const char *v63;
  uint64_t v64;
  char *v65;
  void *v66;
  uint64_t v67;
  void (*v68)(uint64_t, const char *, ...);
  objc_class *v69;
  _BOOL4 v70;
  const char *v71;
  uint64_t v72;
  void *v73;
  uint64_t v74;
  NSObject *v75;
  objc_class *v76;
  int v77;
  const char *v78;
  const char *v79;
  uint64_t v80;
  id v81;
  void *v82;
  id v83;
  uint64_t v84;
  id v85;
  void *v86;
  void *v87;
  void *v88;
  id v89;
  const char *v90;
  char *v91;
  id v92;
  NSErrorUserInfoKey v93;
  void *v94;
  uint8_t buf[4];
  int v96;
  __int16 v97;
  const char *v98;
  __int16 v99;
  const char *v100;
  __int16 v101;
  int v102;
  __int16 v103;
  const __CFString *v104;
  __int16 v105;
  int v106;
  __int16 v107;
  char *v108;
  NSErrorUserInfoKey v109;
  void *v110;
  NSErrorUserInfoKey v111;
  id v112;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v10 = 45;
    if (isMetaClass)
      v10 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@", v10, ClassName, Name, 487, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 56));
    v18 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    *(_DWORD *)buf = 67110146;
    v96 = v15;
    v97 = 2082;
    v98 = v16;
    v99 = 2082;
    v100 = v17;
    v101 = 1024;
    v102 = 487;
    v103 = 2114;
    v104 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);

  }
  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v38 = objc_opt_new(NSMutableArray);
    v42 = *(void **)(a1 + 32);
    v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v42, "embeddedSecureElementWrapper"));
    LOBYTE(v42) = objc_msgSend(v42, "_activateSecureElementWrapper:", v43);

    if ((v42 & 1) != 0)
    {
      v44 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
      v45 = *(void **)(a1 + 40);
      v46 = *(unsigned __int8 *)(a1 + 64);
      v92 = 0;
      v47 = sub_100174BF0(v44, v45, v46, &v92);
      v39 = v92;

      if ((_DWORD)v47)
      {
        v48 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v49 = NFLogGetLogger(v48);
        if (v49)
        {
          v50 = (void (*)(uint64_t, const char *, ...))v49;
          v51 = object_getClass(*(id *)(a1 + 32));
          v52 = class_isMetaClass(v51);
          v53 = object_getClassName(*(id *)(a1 + 32));
          v54 = sel_getName(*(SEL *)(a1 + 56));
          if (v47 >= 0x47)
            v55 = 71;
          else
            v55 = v47;
          v91 = off_1002E9508[v55];
          v56 = 43;
          if (!v52)
            v56 = 45;
          v50(3, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", v56, v53, v54, 502, CFSTR("Returned"), v47, v91);
        }
        v57 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v58 = NFSharedLogGetLogger(v57);
        v59 = objc_claimAutoreleasedReturnValue(v58);
        if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
        {
          v60 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v60))
            v61 = 43;
          else
            v61 = 45;
          v62 = object_getClassName(*(id *)(a1 + 32));
          v63 = sel_getName(*(SEL *)(a1 + 56));
          if (v47 >= 0x47)
            v64 = 71;
          else
            v64 = v47;
          v65 = off_1002E9508[v64];
          *(_DWORD *)buf = 67110658;
          v96 = v61;
          v97 = 2082;
          v98 = v62;
          v99 = 2082;
          v100 = v63;
          v101 = 1024;
          v102 = 502;
          v103 = 2112;
          v104 = CFSTR("Returned");
          v105 = 1024;
          v106 = v47;
          v107 = 2080;
          v108 = v65;
          _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", buf, 0x3Cu);
        }
        else if (v47 >= 0x47)
        {
          v64 = 71;
        }
        else
        {
          v64 = v47;
        }

        v84 = *(_QWORD *)(a1 + 48);
        v85 = objc_alloc((Class)NSError);
        v86 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v93 = NSLocalizedDescriptionKey;
        v87 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E9508[v64]));
        v94 = v87;
        v88 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v94, &v93, 1));
        v89 = objc_msgSend(v85, "initWithDomain:code:userInfo:", v86, v47, v88);
        (*(void (**)(uint64_t, _QWORD, id))(v84 + 16))(v84, 0, v89);

      }
      else
      {
        -[NSMutableArray addObject:](v38, "addObject:", v39);
        (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
      }
      goto LABEL_25;
    }
    v66 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v67 = NFLogGetLogger(v66);
    if (v67)
    {
      v68 = (void (*)(uint64_t, const char *, ...))v67;
      v69 = object_getClass(*(id *)(a1 + 32));
      v70 = class_isMetaClass(v69);
      v71 = object_getClassName(*(id *)(a1 + 32));
      v90 = sel_getName(*(SEL *)(a1 + 56));
      v72 = 45;
      if (v70)
        v72 = 43;
      v68(3, "%c[%{public}s %{public}s]:%i Failed to activate embedded secure element", v72, v71, v90, 494);
    }
    v73 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v74 = NFSharedLogGetLogger(v73);
    v75 = objc_claimAutoreleasedReturnValue(v74);
    if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
    {
      v76 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v76))
        v77 = 43;
      else
        v77 = 45;
      v78 = object_getClassName(*(id *)(a1 + 32));
      v79 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)buf = 67109890;
      v96 = v77;
      v97 = 2082;
      v98 = v78;
      v99 = 2082;
      v100 = v79;
      v101 = 1024;
      v102 = 494;
      _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to activate embedded secure element", buf, 0x22u);
    }

    v80 = *(_QWORD *)(a1 + 48);
    v81 = objc_alloc((Class)NSError);
    v39 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v109 = NSLocalizedDescriptionKey;
    v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
    v110 = v40;
    v82 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v110, &v109, 1));
    v83 = objc_msgSend(v81, "initWithDomain:code:userInfo:", v39, 15, v82);
    (*(void (**)(uint64_t, _QWORD, id))(v80 + 16))(v80, 0, v83);

LABEL_24:
LABEL_25:

    return;
  }
  v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v20 = NFLogGetLogger(v19);
  if (v20)
  {
    v21 = (void (*)(uint64_t, const char *, ...))v20;
    v22 = object_getClass(*(id *)(a1 + 32));
    v23 = class_isMetaClass(v22);
    v24 = object_getClassName(*(id *)(a1 + 32));
    v25 = sel_getName(*(SEL *)(a1 + 56));
    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v27 = 45;
    if (v23)
      v27 = 43;
    v21(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v27, v24, v25, 489, v26);

  }
  v28 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v29 = NFSharedLogGetLogger(v28);
  v30 = objc_claimAutoreleasedReturnValue(v29);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
  {
    v31 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v31))
      v32 = 43;
    else
      v32 = 45;
    v33 = object_getClassName(*(id *)(a1 + 32));
    v34 = sel_getName(*(SEL *)(a1 + 56));
    v35 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v96 = v32;
    v97 = 2082;
    v98 = v33;
    v99 = 2082;
    v100 = v34;
    v101 = 1024;
    v102 = 489;
    v103 = 2114;
    v104 = v35;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v36 = *(_QWORD *)(a1 + 48);
  if (v36)
  {
    v37 = objc_alloc((Class)NSError);
    v38 = (NSMutableArray *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v111 = NSLocalizedDescriptionKey;
    v39 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v112 = v39;
    v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v112, &v111, 1));
    v41 = objc_msgSend(v37, "initWithDomain:code:userInfo:", v38, 54, v40);
    (*(void (**)(uint64_t, _QWORD, id))(v36 + 16))(v36, 0, v41);

    goto LABEL_24;
  }
}

void sub_1001567E4(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  __CFString *v18;
  void *v19;
  uint64_t v20;
  void (*v21)(uint64_t, const char *, ...);
  objc_class *v22;
  _BOOL4 v23;
  const char *v24;
  const char *v25;
  void *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  NSObject *v30;
  objc_class *v31;
  int v32;
  const char *v33;
  const char *v34;
  __CFString *v35;
  uint64_t v36;
  id v37;
  id v38;
  NSMutableDictionary *v39;
  void *v40;
  void *v41;
  id v42;
  uint64_t v43;
  id v44;
  void *v45;
  void *v46;
  void *v47;
  void *v48;
  void *v49;
  unsigned int v50;
  id v51;
  void *v52;
  uint64_t v53;
  void (*v54)(uint64_t, const char *, ...);
  objc_class *v55;
  _BOOL4 v56;
  const char *v57;
  uint64_t v58;
  void *v59;
  uint64_t v60;
  NSObject *v61;
  objc_class *v62;
  int v63;
  const char *v64;
  const char *v65;
  id v66;
  void *v67;
  void *v68;
  uint64_t v69;
  void *v70;
  uint64_t v71;
  void (*v72)(uint64_t, const char *, ...);
  objc_class *v73;
  _BOOL4 v74;
  const char *v75;
  const char *v76;
  int v77;
  uint64_t v78;
  void *v79;
  uint64_t v80;
  NSObject *v81;
  objc_class *v82;
  int v83;
  const char *v84;
  const char *v85;
  uint64_t v86;
  char *v87;
  void *v88;
  void *v89;
  void *v90;
  void *v91;
  void *v92;
  void *v93;
  void *v94;
  void *v95;
  void *v96;
  void *v97;
  void *v98;
  void *v99;
  uint64_t v100;
  id v101;
  void *v102;
  void *v103;
  id v104;
  const char *v105;
  char *v106;
  id v107;
  NSErrorUserInfoKey v108;
  void *v109;
  uint8_t buf[4];
  int v111;
  __int16 v112;
  const char *v113;
  __int16 v114;
  const char *v115;
  __int16 v116;
  int v117;
  __int16 v118;
  const __CFString *v119;
  __int16 v120;
  int v121;
  __int16 v122;
  char *v123;
  NSErrorUserInfoKey v124;
  NSMutableDictionary *v125;
  NSErrorUserInfoKey v126;
  NSMutableDictionary *v127;
  NSErrorUserInfoKey v128;
  NSMutableDictionary *v129;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v10 = 45;
    if (isMetaClass)
      v10 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@", v10, ClassName, Name, 517, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 56));
    v18 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    *(_DWORD *)buf = 67110146;
    v111 = v15;
    v112 = 2082;
    v113 = v16;
    v114 = 2082;
    v115 = v17;
    v116 = 1024;
    v117 = 517;
    v118 = 2114;
    v119 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);

  }
  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v45 = *(void **)(a1 + 32);
    v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v45, "embeddedSecureElementWrapper"));
    LOBYTE(v45) = objc_msgSend(v45, "_activateSecureElementWrapper:", v46);

    if ((v45 & 1) != 0)
    {
      v47 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
      v48 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v47, "handle"));
      v49 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v48, "info"));
      v50 = objc_msgSend(v49, "restrictedMode");

      if (!v50)
      {
        v67 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
        v68 = *(void **)(a1 + 40);
        v107 = 0;
        v69 = sub_1001E3990(v67, v68, 3, &v107);
        v38 = v107;

        if ((_DWORD)v69)
        {
          v70 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v71 = NFLogGetLogger(v70);
          if (v71)
          {
            v72 = (void (*)(uint64_t, const char *, ...))v71;
            v73 = object_getClass(*(id *)(a1 + 32));
            v74 = class_isMetaClass(v73);
            v75 = object_getClassName(*(id *)(a1 + 32));
            v76 = sel_getName(*(SEL *)(a1 + 56));
            if (v69 >= 0x47)
              v77 = 71;
            else
              v77 = v69;
            v106 = off_1002E9508[v77];
            v78 = 43;
            if (!v74)
              v78 = 45;
            v72(3, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", v78, v75, v76, 534, CFSTR("Returned"), v69, v106);
          }
          v79 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v80 = NFSharedLogGetLogger(v79);
          v81 = objc_claimAutoreleasedReturnValue(v80);
          if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
          {
            v82 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v82))
              v83 = 43;
            else
              v83 = 45;
            v84 = object_getClassName(*(id *)(a1 + 32));
            v85 = sel_getName(*(SEL *)(a1 + 56));
            if (v69 >= 0x47)
              v86 = 71;
            else
              v86 = v69;
            v87 = off_1002E9508[v86];
            *(_DWORD *)buf = 67110658;
            v111 = v83;
            v112 = 2082;
            v113 = v84;
            v114 = 2082;
            v115 = v85;
            v116 = 1024;
            v117 = 534;
            v118 = 2112;
            v119 = CFSTR("Returned");
            v120 = 1024;
            v121 = v69;
            v122 = 2080;
            v123 = v87;
            _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", buf, 0x3Cu);
          }
          else if (v69 >= 0x47)
          {
            v86 = 71;
          }
          else
          {
            v86 = v69;
          }

          v100 = *(_QWORD *)(a1 + 48);
          v101 = objc_alloc((Class)NSError);
          v39 = (NSMutableDictionary *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
          v108 = NSLocalizedDescriptionKey;
          v102 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E9508[v86]));
          v109 = v102;
          v103 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v109, &v108, 1));
          v104 = objc_msgSend(v101, "initWithDomain:code:userInfo:", v39, v69, v103);
          (*(void (**)(uint64_t, _QWORD, _QWORD, id))(v100 + 16))(v100, 0, 0, v104);

        }
        else
        {
          v39 = objc_opt_new(NSMutableDictionary);
          v88 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
          v89 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v88, "rsaCertificate"));

          if (v89)
          {
            v90 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
            v91 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v90, "rsaCertificate"));
            -[NSMutableDictionary setObject:forKeyedSubscript:](v39, "setObject:forKeyedSubscript:", v91, CFSTR("RSA"));

          }
          v92 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
          v93 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v92, "eccCertificate"));

          if (v93)
          {
            v94 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
            v95 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v94, "eccCertificate"));
            -[NSMutableDictionary setObject:forKeyedSubscript:](v39, "setObject:forKeyedSubscript:", v95, CFSTR("ECDSA"));

          }
          v96 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
          v97 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v96, "eckaCertificate"));

          if (v97)
          {
            v98 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
            v99 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v98, "eckaCertificate"));
            -[NSMutableDictionary setObject:forKeyedSubscript:](v39, "setObject:forKeyedSubscript:", v99, CFSTR("ECKA"));

          }
          (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
        }
        goto LABEL_25;
      }
      v36 = *(_QWORD *)(a1 + 48);
      v51 = objc_alloc((Class)NSError);
      v38 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v124 = NSLocalizedDescriptionKey;
      v39 = (NSMutableDictionary *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Restricted Mode"));
      v125 = v39;
      v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v125, &v124, 1));
      v41 = v51;
      v42 = v38;
      v43 = 24;
    }
    else
    {
      v52 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v53 = NFLogGetLogger(v52);
      if (v53)
      {
        v54 = (void (*)(uint64_t, const char *, ...))v53;
        v55 = object_getClass(*(id *)(a1 + 32));
        v56 = class_isMetaClass(v55);
        v57 = object_getClassName(*(id *)(a1 + 32));
        v105 = sel_getName(*(SEL *)(a1 + 56));
        v58 = 45;
        if (v56)
          v58 = 43;
        v54(3, "%c[%{public}s %{public}s]:%i Failed to activate embedded secure element", v58, v57, v105, 522);
      }
      v59 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v60 = NFSharedLogGetLogger(v59);
      v61 = objc_claimAutoreleasedReturnValue(v60);
      if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
      {
        v62 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v62))
          v63 = 43;
        else
          v63 = 45;
        v64 = object_getClassName(*(id *)(a1 + 32));
        v65 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)buf = 67109890;
        v111 = v63;
        v112 = 2082;
        v113 = v64;
        v114 = 2082;
        v115 = v65;
        v116 = 1024;
        v117 = 522;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to activate embedded secure element", buf, 0x22u);
      }

      v36 = *(_QWORD *)(a1 + 48);
      v66 = objc_alloc((Class)NSError);
      v38 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v126 = NSLocalizedDescriptionKey;
      v39 = (NSMutableDictionary *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
      v127 = v39;
      v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v127, &v126, 1));
      v41 = v66;
      v42 = v38;
      v43 = 15;
    }
LABEL_24:
    v44 = objc_msgSend(v41, "initWithDomain:code:userInfo:", v42, v43, v40);
    (*(void (**)(uint64_t, _QWORD, _QWORD, id))(v36 + 16))(v36, 0, 0, v44);

LABEL_25:
    return;
  }
  v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v20 = NFLogGetLogger(v19);
  if (v20)
  {
    v21 = (void (*)(uint64_t, const char *, ...))v20;
    v22 = object_getClass(*(id *)(a1 + 32));
    v23 = class_isMetaClass(v22);
    v24 = object_getClassName(*(id *)(a1 + 32));
    v25 = sel_getName(*(SEL *)(a1 + 56));
    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v27 = 45;
    if (v23)
      v27 = 43;
    v21(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v27, v24, v25, 519, v26);

  }
  v28 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v29 = NFSharedLogGetLogger(v28);
  v30 = objc_claimAutoreleasedReturnValue(v29);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
  {
    v31 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v31))
      v32 = 43;
    else
      v32 = 45;
    v33 = object_getClassName(*(id *)(a1 + 32));
    v34 = sel_getName(*(SEL *)(a1 + 56));
    v35 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v111 = v32;
    v112 = 2082;
    v113 = v33;
    v114 = 2082;
    v115 = v34;
    v116 = 1024;
    v117 = 519;
    v118 = 2114;
    v119 = v35;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v36 = *(_QWORD *)(a1 + 48);
  if (v36)
  {
    v37 = objc_alloc((Class)NSError);
    v38 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v128 = NSLocalizedDescriptionKey;
    v39 = (NSMutableDictionary *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v129 = v39;
    v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v129, &v128, 1));
    v41 = v37;
    v42 = v38;
    v43 = 54;
    goto LABEL_24;
  }
}

void sub_100157314(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  __CFString *v18;
  void *v19;
  uint64_t v20;
  void (*v21)(uint64_t, const char *, ...);
  objc_class *v22;
  _BOOL4 v23;
  const char *v24;
  const char *v25;
  void *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  NSObject *v30;
  objc_class *v31;
  int v32;
  const char *v33;
  const char *v34;
  __CFString *v35;
  uint64_t v36;
  id v37;
  NSMutableDictionary *v38;
  id v39;
  NFSignatureInfo *v40;
  void *v41;
  NSMutableDictionary *v42;
  uint64_t v43;
  id v44;
  void *v45;
  void *v46;
  void *v47;
  void *v48;
  void *v49;
  unsigned int v50;
  id v51;
  void *v52;
  uint64_t v53;
  void (*v54)(uint64_t, const char *, ...);
  objc_class *v55;
  _BOOL4 v56;
  const char *v57;
  uint64_t v58;
  void *v59;
  uint64_t v60;
  NSObject *v61;
  objc_class *v62;
  int v63;
  const char *v64;
  const char *v65;
  id v66;
  void *v67;
  void *v68;
  void *v69;
  void *v70;
  void *v71;
  void *v72;
  void *v73;
  void *v74;
  void *v75;
  void *v76;
  void *v77;
  unsigned int v78;
  uint64_t v79;
  id v80;
  uint64_t v81;
  int v82;
  void *v83;
  void *v84;
  id v85;
  uint64_t v86;
  void *v87;
  uint64_t v88;
  void (*v89)(uint64_t, const char *, ...);
  objc_class *v90;
  _BOOL4 v91;
  const char *v92;
  const char *v93;
  int v94;
  uint64_t v95;
  void *v96;
  uint64_t v97;
  NSObject *v98;
  objc_class *v99;
  int v100;
  const char *v101;
  const char *v102;
  uint64_t v103;
  char *v104;
  void *v105;
  void *v106;
  uint64_t v107;
  id v108;
  void *v109;
  void *v110;
  id v111;
  uint64_t v112;
  void *v113;
  void *v114;
  void *v115;
  uint64_t v116;
  void *v117;
  void *v118;
  void *v119;
  void *v120;
  void *v121;
  void *v122;
  uint64_t v123;
  const char *v124;
  char *v125;
  void *v126;
  void *v127;
  id v128;
  id v129;
  NSErrorUserInfoKey v130;
  void *v131;
  uint8_t buf[4];
  int v133;
  __int16 v134;
  const char *v135;
  __int16 v136;
  const char *v137;
  __int16 v138;
  int v139;
  __int16 v140;
  const __CFString *v141;
  __int16 v142;
  int v143;
  __int16 v144;
  char *v145;
  NSErrorUserInfoKey v146;
  void *v147;
  NSErrorUserInfoKey v148;
  id v149;
  NSErrorUserInfoKey v150;
  id v151;
  NSErrorUserInfoKey v152;
  id v153;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v10 = 45;
    if (isMetaClass)
      v10 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@", v10, ClassName, Name, 552, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 56));
    v18 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    *(_DWORD *)buf = 67110146;
    v133 = v15;
    v134 = 2082;
    v135 = v16;
    v136 = 2082;
    v137 = v17;
    v138 = 1024;
    v139 = 552;
    v140 = 2114;
    v141 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);

  }
  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v45 = *(void **)(a1 + 32);
    v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v45, "embeddedSecureElementWrapper"));
    LOBYTE(v45) = objc_msgSend(v45, "_activateSecureElementWrapper:", v46);

    if ((v45 & 1) == 0)
    {
      v52 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v53 = NFLogGetLogger(v52);
      if (v53)
      {
        v54 = (void (*)(uint64_t, const char *, ...))v53;
        v55 = object_getClass(*(id *)(a1 + 32));
        v56 = class_isMetaClass(v55);
        v57 = object_getClassName(*(id *)(a1 + 32));
        v124 = sel_getName(*(SEL *)(a1 + 56));
        v58 = 45;
        if (v56)
          v58 = 43;
        v54(3, "%c[%{public}s %{public}s]:%i Failed to activate embedded secure element", v58, v57, v124, 557);
      }
      v59 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v60 = NFSharedLogGetLogger(v59);
      v61 = objc_claimAutoreleasedReturnValue(v60);
      if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
      {
        v62 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v62))
          v63 = 43;
        else
          v63 = 45;
        v64 = object_getClassName(*(id *)(a1 + 32));
        v65 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)buf = 67109890;
        v133 = v63;
        v134 = 2082;
        v135 = v64;
        v136 = 2082;
        v137 = v65;
        v138 = 1024;
        v139 = 557;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to activate embedded secure element", buf, 0x22u);
      }

      v36 = *(_QWORD *)(a1 + 48);
      v66 = objc_alloc((Class)NSError);
      v38 = (NSMutableDictionary *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v150 = NSLocalizedDescriptionKey;
      v39 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
      v151 = v39;
      v40 = (NFSignatureInfo *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v151, &v150, 1));
      v41 = v66;
      v42 = v38;
      v43 = 15;
      goto LABEL_24;
    }
    v47 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
    v48 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v47, "handle"));
    v49 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v48, "info"));
    v50 = objc_msgSend(v49, "restrictedMode");

    if (v50)
    {
      v36 = *(_QWORD *)(a1 + 48);
      v51 = objc_alloc((Class)NSError);
      v38 = (NSMutableDictionary *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v148 = NSLocalizedDescriptionKey;
      v39 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Restricted Mode"));
      v149 = v39;
      v40 = (NFSignatureInfo *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v149, &v148, 1));
      v41 = v51;
      v42 = v38;
      v43 = 24;
      goto LABEL_24;
    }
    v38 = objc_opt_new(NSMutableDictionary);
    v67 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
    v68 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v67, "rsaCertificate"));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v38, "setObject:forKeyedSubscript:", v68, CFSTR("rsa"));

    v69 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
    v70 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v69, "eccCertificate"));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v38, "setObject:forKeyedSubscript:", v70, CFSTR("ecc"));

    v71 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
    v72 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v71, "eckaCertificate"));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v38, "setObject:forKeyedSubscript:", v72, CFSTR("ecka"));

    v73 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
    v74 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v73, "serialNumber"));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v38, "setObject:forKeyedSubscript:", v74, CFSTR("seid"));

    -[NSMutableDictionary setObject:forKeyedSubscript:](v38, "setObject:forKeyedSubscript:", &off_1002FFD68, CFSTR("certVersion"));
    LODWORD(v73) = *(unsigned __int8 *)(a1 + 64);
    v75 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
    v76 = v75;
    v77 = *(void **)(a1 + 40);
    if (!(_DWORD)v73)
    {
      v128 = 0;
      v86 = sub_1001E3990(v75, v77, 3, &v128);
      v39 = v128;

      if ((_DWORD)v86)
      {
        v87 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v88 = NFLogGetLogger(v87);
        if (v88)
        {
          v89 = (void (*)(uint64_t, const char *, ...))v88;
          v90 = object_getClass(*(id *)(a1 + 32));
          v91 = class_isMetaClass(v90);
          v92 = object_getClassName(*(id *)(a1 + 32));
          v93 = sel_getName(*(SEL *)(a1 + 56));
          if (v86 >= 0x47)
            v94 = 71;
          else
            v94 = v86;
          v125 = off_1002E9508[v94];
          v95 = 43;
          if (!v91)
            v95 = 45;
          v89(3, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", v95, v92, v93, 605, CFSTR("Returned"), v86, v125);
        }
        v96 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v97 = NFSharedLogGetLogger(v96);
        v98 = objc_claimAutoreleasedReturnValue(v97);
        if (os_log_type_enabled(v98, OS_LOG_TYPE_ERROR))
        {
          v99 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v99))
            v100 = 43;
          else
            v100 = 45;
          v101 = object_getClassName(*(id *)(a1 + 32));
          v102 = sel_getName(*(SEL *)(a1 + 56));
          if (v86 >= 0x47)
            v103 = 71;
          else
            v103 = v86;
          v104 = off_1002E9508[v103];
          *(_DWORD *)buf = 67110658;
          v133 = v100;
          v134 = 2082;
          v135 = v101;
          v136 = 2082;
          v137 = v102;
          v138 = 1024;
          v139 = 605;
          v140 = 2112;
          v141 = CFSTR("Returned");
          v142 = 1024;
          v143 = v86;
          v144 = 2080;
          v145 = v104;
          _os_log_impl((void *)&_mh_execute_header, v98, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", buf, 0x3Cu);
        }
        else if (v86 >= 0x47)
        {
          v103 = 71;
        }
        else
        {
          v103 = v86;
        }

        v107 = *(_QWORD *)(a1 + 48);
        v108 = objc_alloc((Class)NSError);
        v40 = (NFSignatureInfo *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v130 = NSLocalizedDescriptionKey;
        v109 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E9508[v103]));
        v131 = v109;
        v110 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v131, &v130, 1));
        v111 = objc_msgSend(v108, "initWithDomain:code:userInfo:", v40, v86, v110);
        (*(void (**)(uint64_t, _QWORD, _QWORD, id))(v107 + 16))(v107, 0, 0, v111);

      }
      else
      {
        v40 = -[NFSignatureInfo initWithDictionary:]([NFSignatureInfo alloc], "initWithDictionary:", v38);
        (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
      }
      goto LABEL_25;
    }
    v129 = 0;
    v78 = sub_1001E77C4((uint64_t)v75, v77, &v129);
    v39 = v129;

    if (v78)
    {
      v79 = *(_QWORD *)(a1 + 48);
      v80 = objc_alloc((Class)NSError);
      v40 = (NFSignatureInfo *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v81 = v78;
      v146 = NSLocalizedDescriptionKey;
      if (v78 >= 0x47)
        v82 = 71;
      else
        v82 = v78;
      v83 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E9508[v82]));
      v147 = v83;
      v84 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v147, &v146, 1));
      v85 = objc_msgSend(v80, "initWithDomain:code:userInfo:", v40, v81, v84);
      (*(void (**)(uint64_t, _QWORD, _QWORD, id))(v79 + 16))(v79, 0, 0, v85);

LABEL_78:
      goto LABEL_25;
    }
    v105 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v39, "objectForKeyedSubscript:", CFSTR("kPlatformId")));

    if (v105)
    {
      v106 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v39, "objectForKeyedSubscript:", CFSTR("kPlatformId")));
      -[NSMutableDictionary setObject:forKeyedSubscript:](v38, "setObject:forKeyedSubscript:", v106, CFSTR("platformid"));
    }
    else
    {
      v106 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
      v112 = objc_claimAutoreleasedReturnValue(objc_msgSend(v106, "handle"));
      if (v112)
      {
        v113 = (void *)v112;
        v114 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
        v115 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v114, "handle"));
        v116 = objc_claimAutoreleasedReturnValue(objc_msgSend(v115, "info"));
        if (v116)
        {
          v117 = (void *)v116;
          v126 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
          v118 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v126, "handle"));
          v127 = v114;
          v119 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v118, "info"));
          v120 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v119, "platformIdentifier"));

          if (!v120)
          {
LABEL_75:
            v121 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v39, "objectForKeyedSubscript:", CFSTR("jsblSequenceCounter")));

            if (v121)
            {
              v122 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v39, "objectForKeyedSubscript:", CFSTR("jsblSequenceCounter")));
              -[NSMutableDictionary setObject:forKeyedSubscript:](v38, "setObject:forKeyedSubscript:", v122, CFSTR("jsblCounter"));

            }
            v40 = -[NFSignatureInfo initWithDictionary:]([NFSignatureInfo alloc], "initWithDictionary:", v38);
            v123 = *(_QWORD *)(a1 + 48);
            v83 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v39, "objectForKeyedSubscript:", CFSTR("SignedResponse")));
            (*(void (**)(uint64_t, void *, NFSignatureInfo *, _QWORD))(v123 + 16))(v123, v83, v40, 0);
            goto LABEL_78;
          }
          v106 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
          v113 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v106, "handle"));
          v114 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v113, "info"));
          v115 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v114, "platformIdentifier"));
          -[NSMutableDictionary setObject:forKeyedSubscript:](v38, "setObject:forKeyedSubscript:", v115, CFSTR("platformid"));
        }

      }
    }

    goto LABEL_75;
  }
  v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v20 = NFLogGetLogger(v19);
  if (v20)
  {
    v21 = (void (*)(uint64_t, const char *, ...))v20;
    v22 = object_getClass(*(id *)(a1 + 32));
    v23 = class_isMetaClass(v22);
    v24 = object_getClassName(*(id *)(a1 + 32));
    v25 = sel_getName(*(SEL *)(a1 + 56));
    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v27 = 45;
    if (v23)
      v27 = 43;
    v21(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v27, v24, v25, 554, v26);

  }
  v28 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v29 = NFSharedLogGetLogger(v28);
  v30 = objc_claimAutoreleasedReturnValue(v29);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
  {
    v31 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v31))
      v32 = 43;
    else
      v32 = 45;
    v33 = object_getClassName(*(id *)(a1 + 32));
    v34 = sel_getName(*(SEL *)(a1 + 56));
    v35 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v133 = v32;
    v134 = 2082;
    v135 = v33;
    v136 = 2082;
    v137 = v34;
    v138 = 1024;
    v139 = 554;
    v140 = 2114;
    v141 = v35;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v36 = *(_QWORD *)(a1 + 48);
  if (v36)
  {
    v37 = objc_alloc((Class)NSError);
    v38 = (NSMutableDictionary *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v152 = NSLocalizedDescriptionKey;
    v39 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v153 = v39;
    v40 = (NFSignatureInfo *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v153, &v152, 1));
    v41 = v37;
    v42 = v38;
    v43 = 54;
LABEL_24:
    v44 = objc_msgSend(v41, "initWithDomain:code:userInfo:", v42, v43, v40);
    (*(void (**)(uint64_t, _QWORD, _QWORD, id))(v36 + 16))(v36, 0, 0, v44);

LABEL_25:
  }
}

void sub_100158160(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  __CFString *v18;
  void *v19;
  uint64_t v20;
  void (*v21)(uint64_t, const char *, ...);
  objc_class *v22;
  _BOOL4 v23;
  const char *v24;
  const char *v25;
  void *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  NSObject *v30;
  objc_class *v31;
  int v32;
  const char *v33;
  const char *v34;
  __CFString *v35;
  uint64_t v36;
  id v37;
  void *v38;
  id v39;
  NSMutableDictionary *v40;
  NFSignatureInfo *v41;
  void *v42;
  void *v43;
  void *v44;
  unsigned int v45;
  uint64_t v46;
  id v47;
  void *v48;
  id v49;
  uint64_t v50;
  void *v51;
  uint64_t v52;
  void (*v53)(uint64_t, const char *, ...);
  objc_class *v54;
  _BOOL4 v55;
  const char *v56;
  uint64_t v57;
  void *v58;
  uint64_t v59;
  NSObject *v60;
  objc_class *v61;
  int v62;
  const char *v63;
  const char *v64;
  id v65;
  id v66;
  void *v67;
  void *v68;
  uint64_t v69;
  void *v70;
  uint64_t v71;
  void (*v72)(uint64_t, const char *, ...);
  objc_class *v73;
  _BOOL4 v74;
  const char *v75;
  const char *v76;
  int v77;
  uint64_t v78;
  void *v79;
  uint64_t v80;
  NSObject *v81;
  objc_class *v82;
  int v83;
  const char *v84;
  const char *v85;
  uint64_t v86;
  char *v87;
  void *v88;
  void *v89;
  void *v90;
  void *v91;
  void *v92;
  void *v93;
  void *v94;
  void *v95;
  void *v96;
  void *v97;
  void *v98;
  void *v99;
  void *v100;
  uint64_t v101;
  void *v102;
  void *v103;
  void *v104;
  void *v105;
  void *v106;
  void *v107;
  void *v108;
  void *v109;
  void *v110;
  void *v111;
  void *v112;
  void *v113;
  void *v114;
  void *v115;
  void *v116;
  void *v117;
  void *v118;
  void *v119;
  void *v120;
  void *v121;
  void *v122;
  void *v123;
  id v124;
  void *v125;
  void *v126;
  void *v127;
  id v128;
  uint64_t v129;
  id v130;
  uint64_t v131;
  void *v132;
  id v133;
  const char *v134;
  char *v135;
  id v136;
  NSErrorUserInfoKey v137;
  NFSignatureInfo *v138;
  uint8_t buf[4];
  int v140;
  __int16 v141;
  const char *v142;
  __int16 v143;
  const char *v144;
  __int16 v145;
  int v146;
  __int16 v147;
  const __CFString *v148;
  __int16 v149;
  int v150;
  __int16 v151;
  char *v152;
  NSErrorUserInfoKey v153;
  NSMutableDictionary *v154;
  NSErrorUserInfoKey v155;
  NSMutableDictionary *v156;
  NSErrorUserInfoKey v157;
  id v158;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 64));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v10 = 45;
    if (isMetaClass)
      v10 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@", v10, ClassName, Name, 621, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 64));
    v18 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    *(_DWORD *)buf = 67110146;
    v140 = v15;
    v141 = 2082;
    v142 = v16;
    v143 = 2082;
    v144 = v17;
    v145 = 1024;
    v146 = 621;
    v147 = 2114;
    v148 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);

  }
  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "_getSecureElementForAID:", *(_QWORD *)(a1 + 40)));
    if ((objc_msgSend(*(id *)(a1 + 32), "_activateSecureElementWrapper:", v38) & 1) == 0)
    {
      v51 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v52 = NFLogGetLogger(v51);
      if (v52)
      {
        v53 = (void (*)(uint64_t, const char *, ...))v52;
        v54 = object_getClass(*(id *)(a1 + 32));
        v55 = class_isMetaClass(v54);
        v56 = object_getClassName(*(id *)(a1 + 32));
        v134 = sel_getName(*(SEL *)(a1 + 64));
        v57 = 45;
        if (v55)
          v57 = 43;
        v53(3, "%c[%{public}s %{public}s]:%i Failed to activate secure element", v57, v56, v134, 628);
      }
      v58 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v59 = NFSharedLogGetLogger(v58);
      v60 = objc_claimAutoreleasedReturnValue(v59);
      if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
      {
        v61 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v61))
          v62 = 43;
        else
          v62 = 45;
        v63 = object_getClassName(*(id *)(a1 + 32));
        v64 = sel_getName(*(SEL *)(a1 + 64));
        *(_DWORD *)buf = 67109890;
        v140 = v62;
        v141 = 2082;
        v142 = v63;
        v143 = 2082;
        v144 = v64;
        v145 = 1024;
        v146 = 628;
        _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to activate secure element", buf, 0x22u);
      }

      v46 = *(_QWORD *)(a1 + 56);
      v65 = objc_alloc((Class)NSError);
      v39 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v155 = NSLocalizedDescriptionKey;
      v40 = (NSMutableDictionary *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
      v156 = v40;
      v41 = (NFSignatureInfo *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v156, &v155, 1));
      v48 = v65;
      v49 = v39;
      v50 = 15;
      goto LABEL_39;
    }
    v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
    v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v42, "handle"));
    v44 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v43, "info"));
    v45 = objc_msgSend(v44, "restrictedMode");

    if (v45)
    {
      v46 = *(_QWORD *)(a1 + 56);
      v47 = objc_alloc((Class)NSError);
      v39 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v153 = NSLocalizedDescriptionKey;
      v40 = (NSMutableDictionary *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Restricted Mode"));
      v154 = v40;
      v41 = (NFSignatureInfo *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v154, &v153, 1));
      v48 = v47;
      v49 = v39;
      v50 = 24;
LABEL_39:
      v66 = objc_msgSend(v48, "initWithDomain:code:userInfo:", v49, v50, v41);
      (*(void (**)(uint64_t, _QWORD, _QWORD, id))(v46 + 16))(v46, 0, 0, v66);

      goto LABEL_24;
    }
    v67 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
    v68 = *(void **)(a1 + 48);
    v136 = 0;
    v69 = sub_1001E3990(v67, v68, 3, &v136);
    v39 = v136;

    if ((_DWORD)v69)
    {
      v70 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v71 = NFLogGetLogger(v70);
      if (v71)
      {
        v72 = (void (*)(uint64_t, const char *, ...))v71;
        v73 = object_getClass(*(id *)(a1 + 32));
        v74 = class_isMetaClass(v73);
        v75 = object_getClassName(*(id *)(a1 + 32));
        v76 = sel_getName(*(SEL *)(a1 + 64));
        if (v69 >= 0x47)
          v77 = 71;
        else
          v77 = v69;
        v135 = off_1002E9508[v77];
        v78 = 43;
        if (!v74)
          v78 = 45;
        v72(3, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", v78, v75, v76, 640, CFSTR("Returned"), v69, v135);
      }
      v79 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v80 = NFSharedLogGetLogger(v79);
      v81 = objc_claimAutoreleasedReturnValue(v80);
      if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
      {
        v82 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v82))
          v83 = 43;
        else
          v83 = 45;
        v84 = object_getClassName(*(id *)(a1 + 32));
        v85 = sel_getName(*(SEL *)(a1 + 64));
        if (v69 >= 0x47)
          v86 = 71;
        else
          v86 = v69;
        v87 = off_1002E9508[v86];
        *(_DWORD *)buf = 67110658;
        v140 = v83;
        v141 = 2082;
        v142 = v84;
        v143 = 2082;
        v144 = v85;
        v145 = 1024;
        v146 = 640;
        v147 = 2112;
        v148 = CFSTR("Returned");
        v149 = 1024;
        v150 = v69;
        v151 = 2080;
        v152 = v87;
        _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", buf, 0x3Cu);
      }
      else if (v69 >= 0x47)
      {
        v86 = 71;
      }
      else
      {
        v86 = v69;
      }

      v129 = *(_QWORD *)(a1 + 56);
      v130 = objc_alloc((Class)NSError);
      v40 = (NSMutableDictionary *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v131 = v69;
      v137 = NSLocalizedDescriptionKey;
      v41 = (NFSignatureInfo *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E9508[v86]));
      v138 = v41;
      v132 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v138, &v137, 1));
      v133 = objc_msgSend(v130, "initWithDomain:code:userInfo:", v40, v131, v132);
      (*(void (**)(uint64_t, _QWORD, _QWORD, id))(v129 + 16))(v129, 0, 0, v133);

      goto LABEL_24;
    }
    v40 = objc_opt_new(NSMutableDictionary);
    v88 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
    v89 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v88, "rsaCertificate"));

    if (v89)
    {
      v90 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
      v91 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v90, "rsaCertificate"));
      -[NSMutableDictionary setObject:forKeyedSubscript:](v40, "setObject:forKeyedSubscript:", v91, CFSTR("rsa"));

    }
    v92 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
    v93 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v92, "eccCertificate"));

    if (v93)
    {
      v94 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
      v95 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v94, "eccCertificate"));
      -[NSMutableDictionary setObject:forKeyedSubscript:](v40, "setObject:forKeyedSubscript:", v95, CFSTR("ecc"));

    }
    v96 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
    v97 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v96, "eckaCertificate"));

    if (v97)
    {
      v98 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
      v99 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v98, "eckaCertificate"));
      -[NSMutableDictionary setObject:forKeyedSubscript:](v40, "setObject:forKeyedSubscript:", v99, CFSTR("ecka"));

    }
    -[NSMutableDictionary setObject:forKeyedSubscript:](v40, "setObject:forKeyedSubscript:", &off_1002FFD68, CFSTR("certVersion"));
    v100 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
    v101 = objc_claimAutoreleasedReturnValue(objc_msgSend(v100, "handle"));
    if (v101)
    {
      v102 = (void *)v101;
      v103 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
      v104 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v103, "handle"));
      v105 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v104, "info"));

      if (!v105)
        goto LABEL_71;
      v106 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
      v107 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v106, "handle"));
      v108 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v107, "info"));
      v109 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v108, "serialNumber"));

      if (v109)
      {
        v110 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
        v111 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v110, "serialNumber"));
        -[NSMutableDictionary setObject:forKeyedSubscript:](v40, "setObject:forKeyedSubscript:", v111, CFSTR("seid"));

      }
      v112 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
      v113 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v112, "handle"));
      v114 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v113, "info"));
      v115 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v114, "platformIdentifier"));

      if (v115)
      {
        v116 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
        v117 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v116, "handle"));
        v118 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v117, "info"));
        v119 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v118, "platformIdentifier"));
        -[NSMutableDictionary setObject:forKeyedSubscript:](v40, "setObject:forKeyedSubscript:", v119, CFSTR("platformid"));

      }
      v120 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
      v121 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v120, "handle"));
      v122 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v121, "info"));
      v123 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v122, "sequenceCounter"));

      if (!v123)
        goto LABEL_71;
      v124 = objc_alloc((Class)NSString);
      v100 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
      v125 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v100, "handle"));
      v126 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v125, "info"));
      v127 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v126, "sequenceCounter"));
      v128 = objc_msgSend(v124, "initWithFormat:", CFSTR("%X"), objc_msgSend(v127, "intValue"));
      -[NSMutableDictionary setObject:forKeyedSubscript:](v40, "setObject:forKeyedSubscript:", v128, CFSTR("jsblCounter"));

    }
LABEL_71:
    v41 = -[NFSignatureInfo initWithDictionary:]([NFSignatureInfo alloc], "initWithDictionary:", v40);
    (*(void (**)(_QWORD, id, NFSignatureInfo *, _QWORD))(*(_QWORD *)(a1 + 56) + 16))(*(_QWORD *)(a1 + 56), v39, v41, 0);
    goto LABEL_24;
  }
  v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v20 = NFLogGetLogger(v19);
  if (v20)
  {
    v21 = (void (*)(uint64_t, const char *, ...))v20;
    v22 = object_getClass(*(id *)(a1 + 32));
    v23 = class_isMetaClass(v22);
    v24 = object_getClassName(*(id *)(a1 + 32));
    v25 = sel_getName(*(SEL *)(a1 + 64));
    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v27 = 45;
    if (v23)
      v27 = 43;
    v21(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v27, v24, v25, 623, v26);

  }
  v28 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v29 = NFSharedLogGetLogger(v28);
  v30 = objc_claimAutoreleasedReturnValue(v29);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
  {
    v31 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v31))
      v32 = 43;
    else
      v32 = 45;
    v33 = object_getClassName(*(id *)(a1 + 32));
    v34 = sel_getName(*(SEL *)(a1 + 64));
    v35 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v140 = v32;
    v141 = 2082;
    v142 = v33;
    v143 = 2082;
    v144 = v34;
    v145 = 1024;
    v146 = 623;
    v147 = 2114;
    v148 = v35;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v36 = *(_QWORD *)(a1 + 56);
  if (v36)
  {
    v37 = objc_alloc((Class)NSError);
    v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v157 = NSLocalizedDescriptionKey;
    v39 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v158 = v39;
    v40 = (NSMutableDictionary *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v158, &v157, 1));
    v41 = (NFSignatureInfo *)objc_msgSend(v37, "initWithDomain:code:userInfo:", v38, 54, v40);
    (*(void (**)(uint64_t, _QWORD, _QWORD, NFSignatureInfo *))(v36 + 16))(v36, 0, 0, v41);
LABEL_24:

  }
}

void sub_100158F1C(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  void *v19;
  uint64_t v20;
  void (*v21)(uint64_t, const char *, ...);
  objc_class *v22;
  _BOOL4 v23;
  const char *v24;
  const char *v25;
  void *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  NSObject *v30;
  objc_class *v31;
  int v32;
  const char *v33;
  const char *v34;
  void *v35;
  uint64_t v36;
  id v37;
  void *v38;
  void *v39;
  id v40;
  id v41;
  void (*v42)(void);
  uint64_t v43;
  id v44;
  void *v45;
  void *v46;
  void *v47;
  unsigned int v48;
  uint64_t v49;
  id v50;
  void *v51;
  void *v52;
  uint64_t v53;
  id v54;
  id v55;
  void *v56;
  id v57;
  id v58;
  id v59;
  NSErrorUserInfoKey v60;
  id v61;
  NSErrorUserInfoKey v62;
  id v63;
  NSErrorUserInfoKey v64;
  void *v65;
  uint8_t buf[4];
  int v67;
  __int16 v68;
  const char *v69;
  __int16 v70;
  const char *v71;
  __int16 v72;
  int v73;
  __int16 v74;
  void *v75;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v10 = 45;
    if (isMetaClass)
      v10 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@", v10, ClassName, Name, 676, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 56));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    *(_DWORD *)buf = 67110146;
    v67 = v15;
    v68 = 2082;
    v69 = v16;
    v70 = 2082;
    v71 = v17;
    v72 = 1024;
    v73 = 676;
    v74 = 2114;
    v75 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);

  }
  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "_getSecureElementWrapperForSEID:", *(_QWORD *)(a1 + 40)));
    if ((objc_msgSend(*(id *)(a1 + 32), "_activateSecureElementWrapper:", v38) & 1) != 0)
    {
      v45 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
      v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v45, "handle"));
      v47 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v46, "info"));
      v48 = objc_msgSend(v47, "restrictedMode");

      if (!v48)
      {
        v56 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
        v58 = 0;
        v59 = 0;
        v57 = sub_1001E40C4(v56, &v59, &v58);
        v39 = (void *)objc_claimAutoreleasedReturnValue(v57);
        v40 = v59;
        v41 = v58;

        v43 = *(_QWORD *)(a1 + 48);
        v42 = *(void (**)(void))(v43 + 16);
        if (!v39 && v40 && v41)
        {
          v42();
          v39 = 0;
          goto LABEL_25;
        }
        v44 = v39;
        goto LABEL_24;
      }
      v49 = *(_QWORD *)(a1 + 48);
      v50 = objc_alloc((Class)NSError);
      v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v60 = NSLocalizedDescriptionKey;
      v40 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Restricted Mode"));
      v61 = v40;
      v41 = (id)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v61, &v60, 1));
      v51 = v50;
      v52 = v39;
      v53 = 24;
    }
    else
    {
      v49 = *(_QWORD *)(a1 + 48);
      v54 = objc_alloc((Class)NSError);
      v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v62 = NSLocalizedDescriptionKey;
      v40 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
      v63 = v40;
      v41 = (id)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v63, &v62, 1));
      v51 = v54;
      v52 = v39;
      v53 = 15;
    }
    v55 = objc_msgSend(v51, "initWithDomain:code:userInfo:", v52, v53, v41);
    (*(void (**)(uint64_t, _QWORD, _QWORD, id))(v49 + 16))(v49, 0, 0, v55);

    goto LABEL_25;
  }
  v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v20 = NFLogGetLogger(v19);
  if (v20)
  {
    v21 = (void (*)(uint64_t, const char *, ...))v20;
    v22 = object_getClass(*(id *)(a1 + 32));
    v23 = class_isMetaClass(v22);
    v24 = object_getClassName(*(id *)(a1 + 32));
    v25 = sel_getName(*(SEL *)(a1 + 56));
    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v27 = 45;
    if (v23)
      v27 = 43;
    v21(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v27, v24, v25, 678, v26);

  }
  v28 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v29 = NFSharedLogGetLogger(v28);
  v30 = objc_claimAutoreleasedReturnValue(v29);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
  {
    v31 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v31))
      v32 = 43;
    else
      v32 = 45;
    v33 = object_getClassName(*(id *)(a1 + 32));
    v34 = sel_getName(*(SEL *)(a1 + 56));
    v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v67 = v32;
    v68 = 2082;
    v69 = v33;
    v70 = 2082;
    v71 = v34;
    v72 = 1024;
    v73 = 678;
    v74 = 2114;
    v75 = v35;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v36 = *(_QWORD *)(a1 + 48);
  if (v36)
  {
    v37 = objc_alloc((Class)NSError);
    v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v64 = NSLocalizedDescriptionKey;
    v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v65 = v39;
    v40 = (id)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v65, &v64, 1));
    v41 = objc_msgSend(v37, "initWithDomain:code:userInfo:", v38, 54, v40);
    v42 = *(void (**)(void))(v36 + 16);
    v43 = v36;
    v44 = v41;
LABEL_24:
    ((void (*)(uint64_t, _QWORD, _QWORD, id))v42)(v43, 0, 0, v44);
LABEL_25:

  }
}

void sub_1001595E4(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  uint64_t v19;
  id v20;
  id v21;
  void *v22;
  void *v23;
  void *v24;
  id v25;
  uint64_t v26;
  id v27;
  void *v28;
  void *v29;
  void *v30;
  unsigned int v31;
  id v32;
  void *v33;
  id v34;
  void *v35;
  id v36;
  NSErrorUserInfoKey v37;
  void *v38;
  NSErrorUserInfoKey v39;
  void *v40;
  uint8_t buf[4];
  int v42;
  __int16 v43;
  const char *v44;
  __int16 v45;
  const char *v46;
  __int16 v47;
  int v48;
  __int16 v49;
  void *v50;

  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
    v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "handle"));
    v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v29, "info"));
    v31 = objc_msgSend(v30, "restrictedMode");

    if (!v31)
    {
      v33 = *(void **)(a1 + 32);
      v36 = 0;
      v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v33, "_getAllApplets:", &v36));
      v21 = v36;
      if (v22)
      {
        v34 = 0;
        v35 = v22;
      }
      else
      {
        v34 = v21;
        v35 = 0;
      }
      (*(void (**)(_QWORD, id, void *))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), v34, v35);
      goto LABEL_16;
    }
    v19 = *(_QWORD *)(a1 + 40);
    v32 = objc_alloc((Class)NSError);
    v21 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v37 = NSLocalizedDescriptionKey;
    v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Restricted Mode"));
    v38 = v22;
    v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v38, &v37, 1));
    v24 = v32;
    v25 = v21;
    v26 = 24;
LABEL_15:
    v27 = objc_msgSend(v24, "initWithDomain:code:userInfo:", v25, v26, v23);
    (*(void (**)(uint64_t, _QWORD, id))(v19 + 16))(v19, 0, v27);

LABEL_16:
    return;
  }
  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v10 = 45;
    if (isMetaClass)
      v10 = 43;
    v4(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v10, ClassName, Name, 713, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 48));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v42 = v15;
    v43 = 2082;
    v44 = v16;
    v45 = 2082;
    v46 = v17;
    v47 = 1024;
    v48 = 713;
    v49 = 2114;
    v50 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v19 = *(_QWORD *)(a1 + 40);
  if (v19)
  {
    v20 = objc_alloc((Class)NSError);
    v21 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v39 = NSLocalizedDescriptionKey;
    v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v40 = v22;
    v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v40, &v39, 1));
    v24 = v20;
    v25 = v21;
    v26 = 54;
    goto LABEL_15;
  }
}

void sub_100159A78(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  void *v19;
  uint64_t v20;
  void (*v21)(uint64_t, const char *, ...);
  objc_class *v22;
  _BOOL4 v23;
  const char *v24;
  const char *v25;
  void *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  NSObject *v30;
  objc_class *v31;
  int v32;
  const char *v33;
  const char *v34;
  void *v35;
  uint64_t v36;
  id v37;
  id v38;
  void *v39;
  void *v40;
  void *v41;
  id v42;
  uint64_t v43;
  id v44;
  void *v45;
  void *v46;
  void *v47;
  unsigned int v48;
  id v49;
  id v50;
  id v51;
  uint64_t v52;
  void *i;
  uint64_t v54;
  uint64_t v55;
  void *v56;
  id v57;
  void *v58;
  uint64_t v59;
  void (*v60)(uint64_t, const char *, ...);
  objc_class *v61;
  _BOOL4 v62;
  const char *v63;
  const char *v64;
  uint64_t v65;
  void *v66;
  uint64_t v67;
  NSObject *v68;
  objc_class *v69;
  int v70;
  const char *v71;
  const char *v72;
  void *v73;
  void *v74;
  uint64_t v75;
  void (*v76)(uint64_t, const char *, ...);
  objc_class *v77;
  _BOOL4 v78;
  const char *v79;
  uint64_t v80;
  void *v81;
  uint64_t v82;
  NSObject *v83;
  objc_class *v84;
  int v85;
  const char *v86;
  const char *v87;
  uint64_t v88;
  id v89;
  void *v90;
  void *v91;
  void *v92;
  id v93;
  void *v94;
  void *v95;
  const char *v96;
  id v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  NSErrorUserInfoKey v102;
  void *v103;
  _BYTE v104[128];
  NSErrorUserInfoKey v105;
  void *v106;
  NSErrorUserInfoKey v107;
  void *v108;
  uint8_t buf[4];
  int v110;
  __int16 v111;
  const char *v112;
  __int16 v113;
  const char *v114;
  __int16 v115;
  int v116;
  __int16 v117;
  void *v118;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v10 = 45;
    if (isMetaClass)
      v10 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@", v10, ClassName, Name, 739, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 56));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    *(_DWORD *)buf = 67110146;
    v110 = v15;
    v111 = 2082;
    v112 = v16;
    v113 = 2082;
    v114 = v17;
    v115 = 1024;
    v116 = 739;
    v117 = 2114;
    v118 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);

  }
  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v45 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
    v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v45, "handle"));
    v47 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v46, "info"));
    v48 = objc_msgSend(v47, "restrictedMode");

    if (!v48)
    {
      v100 = 0u;
      v101 = 0u;
      v98 = 0u;
      v99 = 0u;
      v38 = *(id *)(a1 + 40);
      v50 = objc_msgSend(v38, "countByEnumeratingWithState:objects:count:", &v98, v104, 16);
      if (v50)
      {
        v51 = v50;
        v52 = *(_QWORD *)v99;
        while (2)
        {
          for (i = 0; i != v51; i = (char *)i + 1)
          {
            if (*(_QWORD *)v99 != v52)
              objc_enumerationMutation(v38);
            v54 = *(_QWORD *)(*((_QWORD *)&v98 + 1) + 8 * (_QWORD)i);
            v55 = objc_opt_class(NFApplet);
            if ((objc_opt_isKindOfClass(v54, v55) & 1) == 0)
            {
              v74 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v75 = NFLogGetLogger(v74);
              if (v75)
              {
                v76 = (void (*)(uint64_t, const char *, ...))v75;
                v77 = object_getClass(*(id *)(a1 + 32));
                v78 = class_isMetaClass(v77);
                v79 = object_getClassName(*(id *)(a1 + 32));
                v96 = sel_getName(*(SEL *)(a1 + 56));
                v80 = 45;
                if (v78)
                  v80 = 43;
                v76(3, "%c[%{public}s %{public}s]:%i Invalid type for applet.", v80, v79, v96, 751);
              }
              v81 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v82 = NFSharedLogGetLogger(v81);
              v83 = objc_claimAutoreleasedReturnValue(v82);
              if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
              {
                v84 = object_getClass(*(id *)(a1 + 32));
                if (class_isMetaClass(v84))
                  v85 = 43;
                else
                  v85 = 45;
                v86 = object_getClassName(*(id *)(a1 + 32));
                v87 = sel_getName(*(SEL *)(a1 + 56));
                *(_DWORD *)buf = 67109890;
                v110 = v85;
                v111 = 2082;
                v112 = v86;
                v113 = 2082;
                v114 = v87;
                v115 = 1024;
                v116 = 751;
                _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid type for applet.", buf, 0x22u);
              }

              v88 = *(_QWORD *)(a1 + 48);
              v89 = objc_alloc((Class)NSError);
              v90 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
              v102 = NSLocalizedDescriptionKey;
              v91 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid Parameter"));
              v103 = v91;
              v92 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v103, &v102, 1));
              v93 = objc_msgSend(v89, "initWithDomain:code:userInfo:", v90, 10, v92);
              (*(void (**)(uint64_t, _QWORD, id))(v88 + 16))(v88, 0, v93);

              goto LABEL_25;
            }
          }
          v51 = objc_msgSend(v38, "countByEnumeratingWithState:objects:count:", &v98, v104, 16);
          if (v51)
            continue;
          break;
        }
      }

      v56 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
      v57 = sub_10022E09C(v56, *(void **)(a1 + 40));
      v38 = (id)objc_claimAutoreleasedReturnValue(v57);

      if (v38)
      {
        v58 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v59 = NFLogGetLogger(v58);
        if (v59)
        {
          v60 = (void (*)(uint64_t, const char *, ...))v59;
          v61 = object_getClass(*(id *)(a1 + 32));
          v62 = class_isMetaClass(v61);
          v63 = object_getClassName(*(id *)(a1 + 32));
          v64 = sel_getName(*(SEL *)(a1 + 56));
          v65 = 45;
          if (v62)
            v65 = 43;
          v60(3, "%c[%{public}s %{public}s]:%i Failed to delete applets from embedded SE %{public}@", v65, v63, v64, 759, *(_QWORD *)(a1 + 40));
        }
        v66 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v67 = NFSharedLogGetLogger(v66);
        v68 = objc_claimAutoreleasedReturnValue(v67);
        if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
        {
          v69 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v69))
            v70 = 43;
          else
            v70 = 45;
          v71 = object_getClassName(*(id *)(a1 + 32));
          v72 = sel_getName(*(SEL *)(a1 + 56));
          v73 = *(void **)(a1 + 40);
          *(_DWORD *)buf = 67110146;
          v110 = v70;
          v111 = 2082;
          v112 = v71;
          v113 = 2082;
          v114 = v72;
          v115 = 1024;
          v116 = 759;
          v117 = 2114;
          v118 = v73;
          _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to delete applets from embedded SE %{public}@", buf, 0x2Cu);
        }

        (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
      }
      else
      {
        v94 = *(void **)(a1 + 32);
        v97 = 0;
        v95 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v94, "_getAllApplets:", &v97));
        v38 = v97;
        (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();

      }
      goto LABEL_25;
    }
    v36 = *(_QWORD *)(a1 + 48);
    v49 = objc_alloc((Class)NSError);
    v38 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v105 = NSLocalizedDescriptionKey;
    v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Restricted Mode"));
    v106 = v39;
    v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v106, &v105, 1));
    v41 = v49;
    v42 = v38;
    v43 = 24;
LABEL_24:
    v44 = objc_msgSend(v41, "initWithDomain:code:userInfo:", v42, v43, v40);
    (*(void (**)(uint64_t, _QWORD, id))(v36 + 16))(v36, 0, v44);

LABEL_25:
    return;
  }
  v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v20 = NFLogGetLogger(v19);
  if (v20)
  {
    v21 = (void (*)(uint64_t, const char *, ...))v20;
    v22 = object_getClass(*(id *)(a1 + 32));
    v23 = class_isMetaClass(v22);
    v24 = object_getClassName(*(id *)(a1 + 32));
    v25 = sel_getName(*(SEL *)(a1 + 56));
    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v27 = 45;
    if (v23)
      v27 = 43;
    v21(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v27, v24, v25, 741, v26);

  }
  v28 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v29 = NFSharedLogGetLogger(v28);
  v30 = objc_claimAutoreleasedReturnValue(v29);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
  {
    v31 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v31))
      v32 = 43;
    else
      v32 = 45;
    v33 = object_getClassName(*(id *)(a1 + 32));
    v34 = sel_getName(*(SEL *)(a1 + 56));
    v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v110 = v32;
    v111 = 2082;
    v112 = v33;
    v113 = 2082;
    v114 = v34;
    v115 = 1024;
    v116 = 741;
    v117 = 2114;
    v118 = v35;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v36 = *(_QWORD *)(a1 + 48);
  if (v36)
  {
    v37 = objc_alloc((Class)NSError);
    v38 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v107 = NSLocalizedDescriptionKey;
    v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v108 = v39;
    v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v108, &v107, 1));
    v41 = v37;
    v42 = v38;
    v43 = 54;
    goto LABEL_24;
  }
}

void sub_10015A40C(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  NSObject *v18;
  void *v19;
  uint64_t v20;
  void (*v21)(uint64_t, const char *, ...);
  objc_class *v22;
  _BOOL4 v23;
  const char *v24;
  const char *v25;
  void *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  NSObject *v30;
  objc_class *v31;
  int v32;
  const char *v33;
  const char *v34;
  NSObject *v35;
  uint64_t v36;
  id v37;
  NSObject *v38;
  id v39;
  NSObject *v40;
  void *v41;
  NSObject *v42;
  uint64_t v43;
  id v44;
  void *v45;
  void *v46;
  void *v47;
  unsigned int v48;
  id v49;
  void *v50;
  unsigned int v51;
  _BOOL4 v52;
  NSObject *v53;
  void *v54;
  uint64_t v55;
  void (*v56)(uint64_t, const char *, ...);
  objc_class *v57;
  _BOOL4 v58;
  const char *v59;
  uint64_t v60;
  void *v61;
  uint64_t v62;
  objc_class *v63;
  int v64;
  const char *v65;
  const char *v66;
  void *v67;
  uint64_t v68;
  void (*v69)(uint64_t, const char *, ...);
  objc_class *v70;
  _BOOL4 v71;
  uint64_t v72;
  void *v73;
  uint64_t v74;
  NSObject *v75;
  objc_class *v76;
  int v77;
  const char *v78;
  const char *v79;
  int v80;
  uint64_t v81;
  uint64_t v82;
  NSObject *v83;
  unsigned int v84;
  uint64_t v85;
  uint64_t v86;
  NSObject *v87;
  void *v88;
  uint64_t v89;
  void (*v90)(uint64_t, const char *, ...);
  objc_class *v91;
  _BOOL4 v92;
  const char *v93;
  uint64_t v94;
  void *v95;
  uint64_t v96;
  NSObject *v97;
  objc_class *v98;
  int v99;
  const char *v100;
  const char *v101;
  id v102;
  void *v103;
  int v104;
  void *v105;
  void *v106;
  uint64_t v107;
  uint64_t v108;
  _QWORD *v109;
  void *v110;
  id v111;
  NSObject *v112;
  uint64_t v113;
  void *v114;
  uint64_t v115;
  void (*v116)(uint64_t, const char *, ...);
  objc_class *v117;
  _BOOL4 v118;
  uint64_t v119;
  void *v120;
  uint64_t v121;
  NSObject *v122;
  objc_class *v123;
  int v124;
  const char *v125;
  const char *v126;
  void *v127;
  void *v128;
  uint64_t v129;
  void (*v130)(uint64_t, const char *, ...);
  objc_class *v131;
  _BOOL4 v132;
  uint64_t v133;
  void *v134;
  uint64_t v135;
  NSObject *v136;
  objc_class *v137;
  int v138;
  const char *v139;
  const char *v140;
  const char *v141;
  const char *v142;
  const char *v143;
  const char *v144;
  const char *v145;
  const char *v146;
  const char *v147;
  const char *v148;
  id v149;
  id v150;
  NSErrorUserInfoKey v151;
  void *v152;
  NSErrorUserInfoKey v153;
  id v154;
  NSErrorUserInfoKey v155;
  id v156;
  uint8_t buf[4];
  int v158;
  __int16 v159;
  const char *v160;
  __int16 v161;
  const char *v162;
  __int16 v163;
  int v164;
  __int16 v165;
  NSObject *v166;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v10 = 45;
    if (isMetaClass)
      v10 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@", v10, ClassName, Name, 779, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 48));
    v18 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    *(_DWORD *)buf = 67110146;
    v158 = v15;
    v159 = 2082;
    v160 = v16;
    v161 = 2082;
    v162 = v17;
    v163 = 1024;
    v164 = 779;
    v165 = 2114;
    v166 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);

  }
  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v45 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
    v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v45, "handle"));
    v47 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v46, "info"));
    v48 = objc_msgSend(v47, "restrictedMode");

    if (!v48)
    {
      if (!+[NFSecureElementWrapper isAuthRandomEntangled](NFSecureElementWrapper, "isAuthRandomEntangled"))
      {
        v50 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
        v51 = objc_msgSend(v50, "jcopSupportsEntanglement");

        if (v51)
        {
          v150 = 0;
          v52 = sub_1002074C8((uint64_t)NFSSEWrapper, &v150);
          v53 = v150;
          if (v52)
          {
            +[NFSecureElementWrapper setAuthRandomEntangled](NFSecureElementWrapper, "setAuthRandomEntangled");
            sub_100207A10((uint64_t)NFSSEWrapper, 1);
          }
          else
          {
            v67 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v68 = NFLogGetLogger(v67);
            if (v68)
            {
              v69 = (void (*)(uint64_t, const char *, ...))v68;
              v70 = object_getClass(*(id *)(a1 + 32));
              v71 = class_isMetaClass(v70);
              v141 = object_getClassName(*(id *)(a1 + 32));
              v145 = sel_getName(*(SEL *)(a1 + 48));
              v72 = 45;
              if (v71)
                v72 = 43;
              v69(6, "%c[%{public}s %{public}s]:%i SSE does not support entanglement : %{public}@", v72, v141, v145, 800, v53);
            }
            v73 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v74 = NFSharedLogGetLogger(v73);
            v75 = objc_claimAutoreleasedReturnValue(v74);
            if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
            {
              v76 = object_getClass(*(id *)(a1 + 32));
              if (class_isMetaClass(v76))
                v77 = 43;
              else
                v77 = 45;
              v78 = object_getClassName(*(id *)(a1 + 32));
              v79 = sel_getName(*(SEL *)(a1 + 48));
              *(_DWORD *)buf = 67110146;
              v158 = v77;
              v159 = 2082;
              v160 = v78;
              v161 = 2082;
              v162 = v79;
              v163 = 1024;
              v164 = 800;
              v165 = 2114;
              v166 = v53;
              _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i SSE does not support entanglement : %{public}@", buf, 0x2Cu);
            }

          }
        }
        else
        {
          v54 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v55 = NFLogGetLogger(v54);
          if (v55)
          {
            v56 = (void (*)(uint64_t, const char *, ...))v55;
            v57 = object_getClass(*(id *)(a1 + 32));
            v58 = class_isMetaClass(v57);
            v59 = object_getClassName(*(id *)(a1 + 32));
            v144 = sel_getName(*(SEL *)(a1 + 48));
            v60 = 45;
            if (v58)
              v60 = 43;
            v56(6, "%c[%{public}s %{public}s]:%i JCOP does not support entanglement", v60, v59, v144, 803);
          }
          v61 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v62 = NFSharedLogGetLogger(v61);
          v53 = objc_claimAutoreleasedReturnValue(v62);
          if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
          {
            v63 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v63))
              v64 = 43;
            else
              v64 = 45;
            v65 = object_getClassName(*(id *)(a1 + 32));
            v66 = sel_getName(*(SEL *)(a1 + 48));
            *(_DWORD *)buf = 67109890;
            v158 = v64;
            v159 = 2082;
            v160 = v65;
            v161 = 2082;
            v162 = v66;
            v163 = 1024;
            v164 = 803;
            _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i JCOP does not support entanglement", buf, 0x22u);
          }
        }

      }
      v80 = +[NFSecureElementWrapper isAuthRandomEntangled](NFSecureElementWrapper, "isAuthRandomEntangled");
      v81 = kdebug_trace(724566148, 0, 0, 0, 0);
      v82 = NFSharedSignpostLog(v81);
      v83 = objc_claimAutoreleasedReturnValue(v82);
      if (os_signpost_enabled(v83))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v83, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "sseEffaceAuthorization in", buf, 2u);
      }

      v84 = sub_100207D1C((uint64_t)NFSSEWrapper, v80);
      v85 = kdebug_trace(724566148, 1, 0, 0, 0);
      v86 = NFSharedSignpostLog(v85);
      v87 = objc_claimAutoreleasedReturnValue(v86);
      if (os_signpost_enabled(v87))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v87, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "sseEffaceAuthorization out", buf, 2u);
      }

      if (v84)
      {
        v88 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v89 = NFLogGetLogger(v88);
        if (v89)
        {
          v90 = (void (*)(uint64_t, const char *, ...))v89;
          v91 = object_getClass(*(id *)(a1 + 32));
          v92 = class_isMetaClass(v91);
          v93 = object_getClassName(*(id *)(a1 + 32));
          v146 = sel_getName(*(SEL *)(a1 + 48));
          v94 = 45;
          if (v92)
            v94 = 43;
          v90(3, "%c[%{public}s %{public}s]:%i Failed to efface SEP", v94, v93, v146, 814);
        }
        v95 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v96 = NFSharedLogGetLogger(v95);
        v97 = objc_claimAutoreleasedReturnValue(v96);
        if (os_log_type_enabled(v97, OS_LOG_TYPE_ERROR))
        {
          v98 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v98))
            v99 = 43;
          else
            v99 = 45;
          v100 = object_getClassName(*(id *)(a1 + 32));
          v101 = sel_getName(*(SEL *)(a1 + 48));
          *(_DWORD *)buf = 67109890;
          v158 = v99;
          v159 = 2082;
          v160 = v100;
          v161 = 2082;
          v162 = v101;
          v163 = 1024;
          v164 = 814;
          _os_log_impl((void *)&_mh_execute_header, v97, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to efface SEP", buf, 0x22u);
        }

        v102 = objc_alloc((Class)NSError);
        v103 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v151 = NSLocalizedDescriptionKey;
        if (v84 >= 0x47)
          v104 = 71;
        else
          v104 = v84;
        v105 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E9508[v104]));
        v152 = v105;
        v106 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v152, &v151, 1));
        v38 = objc_msgSend(v102, "initWithDomain:code:userInfo:", v103, v84, v106);

      }
      else
      {
        v38 = 0;
      }
      if (objc_msgSend(*(id *)(a1 + 32), "uid"))
        v108 = (uint64_t)objc_msgSend(*(id *)(a1 + 32), "uid");
      else
        v108 = 0xFFFFFFFFLL;
      v109 = *(_QWORD **)(a1 + 32);
      if (v109[25])
      {
        NFDriverRedactLogging(1, v107);
        v109 = *(_QWORD **)(a1 + 32);
      }
      v110 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v109, "embeddedSecureElementWrapper"));
      v111 = sub_10022BEF4(v110, v108);
      v112 = objc_claimAutoreleasedReturnValue(v111);

      if (*(_QWORD *)(*(_QWORD *)(a1 + 32) + 200))
        NFDriverRedactLogging(0, v113);
      if (v112)
      {
        v114 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v115 = NFLogGetLogger(v114);
        if (v115)
        {
          v116 = (void (*)(uint64_t, const char *, ...))v115;
          v117 = object_getClass(*(id *)(a1 + 32));
          v118 = class_isMetaClass(v117);
          v142 = object_getClassName(*(id *)(a1 + 32));
          v147 = sel_getName(*(SEL *)(a1 + 48));
          v119 = 45;
          if (v118)
            v119 = 43;
          v116(3, "%c[%{public}s %{public}s]:%i Failed to delete applets from ese: %{public}@", v119, v142, v147, 827, v112);
        }
        v120 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v121 = NFSharedLogGetLogger(v120);
        v122 = objc_claimAutoreleasedReturnValue(v121);
        if (os_log_type_enabled(v122, OS_LOG_TYPE_ERROR))
        {
          v123 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v123))
            v124 = 43;
          else
            v124 = 45;
          v125 = object_getClassName(*(id *)(a1 + 32));
          v126 = sel_getName(*(SEL *)(a1 + 48));
          *(_DWORD *)buf = 67110146;
          v158 = v124;
          v159 = 2082;
          v160 = v125;
          v161 = 2082;
          v162 = v126;
          v163 = 1024;
          v164 = 827;
          v165 = 2114;
          v166 = v112;
          _os_log_impl((void *)&_mh_execute_header, v122, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to delete applets from ese: %{public}@", buf, 0x2Cu);
        }

        if (!v38)
          v38 = v112;
      }
      v127 = *(void **)(a1 + 32);
      v149 = 0;
      v40 = objc_claimAutoreleasedReturnValue(objc_msgSend(v127, "_getAllApplets:", &v149));
      v39 = v149;

      if (v40)
      {
        v128 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v129 = NFLogGetLogger(v128);
        if (v129)
        {
          v130 = (void (*)(uint64_t, const char *, ...))v129;
          v131 = object_getClass(*(id *)(a1 + 32));
          v132 = class_isMetaClass(v131);
          v143 = object_getClassName(*(id *)(a1 + 32));
          v148 = sel_getName(*(SEL *)(a1 + 48));
          v133 = 45;
          if (v132)
            v133 = 43;
          v130(3, "%c[%{public}s %{public}s]:%i Failed to get applets: %{public}@", v133, v143, v148, 835, v40);
        }
        v134 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v135 = NFSharedLogGetLogger(v134);
        v136 = objc_claimAutoreleasedReturnValue(v135);
        if (os_log_type_enabled(v136, OS_LOG_TYPE_ERROR))
        {
          v137 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v137))
            v138 = 43;
          else
            v138 = 45;
          v139 = object_getClassName(*(id *)(a1 + 32));
          v140 = sel_getName(*(SEL *)(a1 + 48));
          *(_DWORD *)buf = 67110146;
          v158 = v138;
          v159 = 2082;
          v160 = v139;
          v161 = 2082;
          v162 = v140;
          v163 = 1024;
          v164 = 835;
          v165 = 2114;
          v166 = v40;
          _os_log_impl((void *)&_mh_execute_header, v136, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get applets: %{public}@", buf, 0x2Cu);
        }

        if (!v38)
          v38 = v40;
      }
      (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
      goto LABEL_25;
    }
    v36 = *(_QWORD *)(a1 + 40);
    v49 = objc_alloc((Class)NSError);
    v38 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v153 = NSLocalizedDescriptionKey;
    v39 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Restricted Mode"));
    v154 = v39;
    v40 = objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v154, &v153, 1));
    v41 = v49;
    v42 = v38;
    v43 = 24;
LABEL_24:
    v44 = objc_msgSend(v41, "initWithDomain:code:userInfo:", v42, v43, v40);
    (*(void (**)(uint64_t, _QWORD, id))(v36 + 16))(v36, 0, v44);

LABEL_25:
    return;
  }
  v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v20 = NFLogGetLogger(v19);
  if (v20)
  {
    v21 = (void (*)(uint64_t, const char *, ...))v20;
    v22 = object_getClass(*(id *)(a1 + 32));
    v23 = class_isMetaClass(v22);
    v24 = object_getClassName(*(id *)(a1 + 32));
    v25 = sel_getName(*(SEL *)(a1 + 48));
    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v27 = 45;
    if (v23)
      v27 = 43;
    v21(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v27, v24, v25, 783, v26);

  }
  v28 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v29 = NFSharedLogGetLogger(v28);
  v30 = objc_claimAutoreleasedReturnValue(v29);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
  {
    v31 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v31))
      v32 = 43;
    else
      v32 = 45;
    v33 = object_getClassName(*(id *)(a1 + 32));
    v34 = sel_getName(*(SEL *)(a1 + 48));
    v35 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v158 = v32;
    v159 = 2082;
    v160 = v33;
    v161 = 2082;
    v162 = v34;
    v163 = 1024;
    v164 = 783;
    v165 = 2114;
    v166 = v35;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v36 = *(_QWORD *)(a1 + 40);
  if (v36)
  {
    v37 = objc_alloc((Class)NSError);
    v38 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v155 = NSLocalizedDescriptionKey;
    v39 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v156 = v39;
    v40 = objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v156, &v155, 1));
    v41 = v37;
    v42 = v38;
    v43 = 54;
    goto LABEL_24;
  }
}

void sub_10015B25C(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  uint64_t v19;
  id v20;
  void *v21;
  void *v22;
  id v23;
  id v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  id v29;
  void *v30;
  id v31;
  id v32;
  NSErrorUserInfoKey v33;
  id v34;
  NSErrorUserInfoKey v35;
  void *v36;
  uint8_t buf[4];
  int v38;
  __int16 v39;
  const char *v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  int v44;
  __int16 v45;
  void *v46;

  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    objc_msgSend(*(id *)(a1 + 32), "markAsDirty:", 1);
    v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "_getSecureElementWrapperForSEID:", *(_QWORD *)(a1 + 40)));
    if ((objc_msgSend(*(id *)(a1 + 32), "_activateSecureElementWrapper:", v21) & 1) != 0)
    {
      v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
      v26 = *(_QWORD *)(a1 + 48);
      v27 = *(_QWORD *)(a1 + 72);
      v32 = 0;
      v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v25, "transceiveData:toOS:error:", v26, v27, &v32));
      v23 = v32;

      (*(void (**)(void))(*(_QWORD *)(a1 + 56) + 16))();
    }
    else
    {
      v28 = *(_QWORD *)(a1 + 56);
      v29 = objc_alloc((Class)NSError);
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v33 = NSLocalizedDescriptionKey;
      v23 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
      v34 = v23;
      v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v34, &v33, 1));
      v31 = objc_msgSend(v29, "initWithDomain:code:userInfo:", v22, 15, v30);
      (*(void (**)(uint64_t, _QWORD, id))(v28 + 16))(v28, 0, v31);

    }
    goto LABEL_15;
  }
  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 64));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v10 = 45;
    if (isMetaClass)
      v10 = 43;
    v4(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v10, ClassName, Name, 857, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 64));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v38 = v15;
    v39 = 2082;
    v40 = v16;
    v41 = 2082;
    v42 = v17;
    v43 = 1024;
    v44 = 857;
    v45 = 2114;
    v46 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v19 = *(_QWORD *)(a1 + 56);
  if (v19)
  {
    v20 = objc_alloc((Class)NSError);
    v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v35 = NSLocalizedDescriptionKey;
    v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v36 = v22;
    v23 = (id)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v36, &v35, 1));
    v24 = objc_msgSend(v20, "initWithDomain:code:userInfo:", v21, 54, v23);
    (*(void (**)(uint64_t, _QWORD, id))(v19 + 16))(v19, 0, v24);

LABEL_15:
  }
}

void sub_10015B73C(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *v5;
  _BOOL4 v6;
  const char *v7;
  const char *v8;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  uint64_t v19;
  id v20;
  void *v21;
  id v22;
  void *v23;
  NSMutableArray *v24;
  uint64_t v25;
  void *i;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  void *v31;
  id v32;
  void *specific;
  uint64_t Logger;
  void (*v35)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v39;
  void *v40;
  uint64_t v41;
  NSObject *v42;
  objc_class *v43;
  int v44;
  const char *v45;
  const char *v46;
  id v47;
  void *v48;
  uint64_t v49;
  void (*v50)(uint64_t, const char *, ...);
  objc_class *v51;
  _BOOL4 v52;
  uint64_t v53;
  void *v54;
  uint64_t v55;
  NSObject *v56;
  objc_class *v57;
  int v58;
  const char *v59;
  const char *v60;
  NSData *v61;
  uint64_t v62;
  id v63;
  id v64;
  const char *v65;
  const char *Name;
  const char *v67;
  void *v68;
  NSMutableArray *v69;
  id obj;
  uint64_t v71;
  id v72;
  id v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  uint8_t buf[4];
  int v79;
  __int16 v80;
  const char *v81;
  __int16 v82;
  const char *v83;
  __int16 v84;
  int v85;
  __int16 v86;
  _QWORD v87[3];
  _BYTE v88[128];
  NSErrorUserInfoKey v89;
  void *v90;
  NSErrorUserInfoKey v91;
  id v92;

  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    objc_msgSend(*(id *)(a1 + 32), "markAsDirty:", 1);
    v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "_getSecureElementWrapperForSEID:", *(_QWORD *)(a1 + 40)));
    if ((objc_msgSend(*(id *)(a1 + 32), "_activateSecureElementWrapper:", v21) & 1) != 0)
    {
      v68 = v21;
      v69 = objc_opt_new(NSMutableArray);
      v74 = 0u;
      v75 = 0u;
      v76 = 0u;
      v77 = 0u;
      obj = *(id *)(a1 + 48);
      v72 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v74, v88, 16);
      if (v72)
      {
        v25 = 0;
        v23 = 0;
        v22 = 0;
        v71 = *(_QWORD *)v75;
        do
        {
          for (i = 0; i != v72; i = (char *)i + 1)
          {
            if (*(_QWORD *)v75 != v71)
              objc_enumerationMutation(obj);
            v27 = *(_QWORD *)(*((_QWORD *)&v74 + 1) + 8 * (_QWORD)i);
            v28 = objc_opt_class(NSData);
            if ((objc_opt_isKindOfClass(v27, v28) & 1) != 0)
            {
              v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
              v30 = *(_QWORD *)(a1 + 72);
              v73 = v22;
              v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v29, "transceiveData:toOS:error:", v27, v30, &v73));
              v32 = v73;

              if (v32)
              {
                specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                Logger = NFLogGetLogger(specific);
                if (Logger)
                {
                  v35 = (void (*)(uint64_t, const char *, ...))Logger;
                  Class = object_getClass(*(id *)(a1 + 32));
                  isMetaClass = class_isMetaClass(Class);
                  ClassName = object_getClassName(*(id *)(a1 + 32));
                  Name = sel_getName(*(SEL *)(a1 + 64));
                  v39 = 45;
                  if (isMetaClass)
                    v39 = 43;
                  v35(3, "%c[%{public}s %{public}s]:%i transceive failed for [%d]: %{public}@", v39, ClassName, Name, 908, (char *)i + v25, v32);
                }
                v40 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                v41 = NFSharedLogGetLogger(v40);
                v42 = objc_claimAutoreleasedReturnValue(v41);
                if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
                {
                  v43 = object_getClass(*(id *)(a1 + 32));
                  if (class_isMetaClass(v43))
                    v44 = 43;
                  else
                    v44 = 45;
                  v45 = object_getClassName(*(id *)(a1 + 32));
                  v46 = sel_getName(*(SEL *)(a1 + 64));
                  *(_DWORD *)buf = 67110402;
                  v79 = v44;
                  v80 = 2082;
                  v81 = v45;
                  v82 = 2082;
                  v83 = v46;
                  v84 = 1024;
                  v85 = 908;
                  v86 = 1024;
                  LODWORD(v87[0]) = v25 + (_DWORD)i;
                  WORD2(v87[0]) = 2114;
                  *(_QWORD *)((char *)v87 + 6) = v32;
                  _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i transceive failed for [%d]: %{public}@", buf, 0x32u);
                }

                v47 = v32;
                v23 = v47;
              }
              if (v31)
              {
                -[NSMutableArray addObject:](v69, "addObject:", v31);
              }
              else
              {
                v61 = objc_opt_new(NSData);
                -[NSMutableArray addObject:](v69, "addObject:", v61);

              }
              v22 = v32;
            }
            else
            {
              v48 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v49 = NFLogGetLogger(v48);
              if (v49)
              {
                v50 = (void (*)(uint64_t, const char *, ...))v49;
                v51 = object_getClass(*(id *)(a1 + 32));
                v52 = class_isMetaClass(v51);
                v65 = object_getClassName(*(id *)(a1 + 32));
                v67 = sel_getName(*(SEL *)(a1 + 64));
                v53 = 45;
                if (v52)
                  v53 = 43;
                v50(3, "%c[%{public}s %{public}s]:%i Invalid class for APDU %d", v53, v65, v67, 900, (char *)i + v25);
              }
              v54 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v55 = NFSharedLogGetLogger(v54);
              v56 = objc_claimAutoreleasedReturnValue(v55);
              if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
              {
                v57 = object_getClass(*(id *)(a1 + 32));
                if (class_isMetaClass(v57))
                  v58 = 43;
                else
                  v58 = 45;
                v59 = object_getClassName(*(id *)(a1 + 32));
                v60 = sel_getName(*(SEL *)(a1 + 64));
                *(_DWORD *)buf = 67110146;
                v79 = v58;
                v80 = 2082;
                v81 = v59;
                v82 = 2082;
                v83 = v60;
                v84 = 1024;
                v85 = 900;
                v86 = 1024;
                LODWORD(v87[0]) = v25 + (_DWORD)i;
                _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid class for APDU %d", buf, 0x28u);
              }

              v22 = v22;
              v31 = v23;
              v23 = v22;
            }

          }
          v25 = (v25 + (_DWORD)i);
          v72 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v74, v88, 16);
        }
        while (v72);
      }
      else
      {
        v23 = 0;
        v22 = 0;
      }

      v24 = v69;
      (*(void (**)(void))(*(_QWORD *)(a1 + 56) + 16))();
      v21 = v68;
    }
    else
    {
      v62 = *(_QWORD *)(a1 + 56);
      v63 = objc_alloc((Class)NSError);
      v22 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v89 = NSLocalizedDescriptionKey;
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
      v90 = v23;
      v24 = (NSMutableArray *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v90, &v89, 1));
      v64 = objc_msgSend(v63, "initWithDomain:code:userInfo:", v22, 15, v24);
      (*(void (**)(uint64_t, _QWORD, id))(v62 + 16))(v62, 0, v64);

    }
    goto LABEL_15;
  }
  v2 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v3 = NFLogGetLogger(v2);
  if (v3)
  {
    v4 = (void (*)(uint64_t, const char *, ...))v3;
    v5 = object_getClass(*(id *)(a1 + 32));
    v6 = class_isMetaClass(v5);
    v7 = object_getClassName(*(id *)(a1 + 32));
    v8 = sel_getName(*(SEL *)(a1 + 64));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v10 = 45;
    if (v6)
      v10 = 43;
    v4(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v10, v7, v8, 884, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 64));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v79 = v15;
    v80 = 2082;
    v81 = v16;
    v82 = 2082;
    v83 = v17;
    v84 = 1024;
    v85 = 884;
    v86 = 2114;
    v87[0] = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v19 = *(_QWORD *)(a1 + 56);
  if (v19)
  {
    v20 = objc_alloc((Class)NSError);
    v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v91 = NSLocalizedDescriptionKey;
    v22 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v92 = v22;
    v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v92, &v91, 1));
    v24 = (NSMutableArray *)objc_msgSend(v20, "initWithDomain:code:userInfo:", v21, 54, v23);
    (*(void (**)(uint64_t, _QWORD, NSMutableArray *))(v19 + 16))(v19, 0, v24);
LABEL_15:

  }
}

id sub_10015BEE4(void *a1, void *a2, void *a3, void *a4, uint64_t *a5, _QWORD *a6, _BYTE *a7)
{
  id v12;
  id v13;
  id v14;
  char **v15;
  _UNKNOWN **v16;
  uint64_t v17;
  __CFString *v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  void *v22;
  void *v23;
  char v24;
  void *v25;
  uint64_t v26;
  unsigned int v27;
  id v28;
  id v29;
  uint64_t v30;
  void *i;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  uint64_t v38;
  void *v39;
  uint64_t v40;
  void (*v41)(uint64_t, const char *, ...);
  objc_class *v42;
  _BOOL4 v43;
  uint64_t v44;
  void *v45;
  uint64_t v46;
  NSObject *v47;
  objc_class *v48;
  int v49;
  const char *v50;
  const char *v51;
  void *v52;
  uint64_t v53;
  __CFString *v54;
  void (*v55)(uint64_t, const char *, ...);
  objc_class *v56;
  _BOOL4 v57;
  const char *v58;
  const char *v59;
  const __CFString *v60;
  uint64_t v61;
  void *v62;
  uint64_t v63;
  NSObject *v64;
  objc_class *v65;
  int v66;
  const char *v67;
  const char *v68;
  const __CFString *v69;
  id v70;
  uint64_t v71;
  void *v72;
  id v73;
  NSMutableData *v74;
  void *v75;
  void *v76;
  void *v77;
  int v78;
  void *v79;
  uint64_t v80;
  void (*v81)(uint64_t, const char *, ...);
  objc_class *v82;
  _BOOL4 v83;
  uint64_t v84;
  void *v85;
  uint64_t v86;
  NSObject *v87;
  objc_class *v88;
  int v89;
  const char *v90;
  const char *v91;
  id v92;
  id v93;
  void *v94;
  id v95;
  id v96;
  void *v97;
  uint64_t v98;
  uint64_t ElapsedTimeInMillisecondsFromMachTime;
  uint64_t v100;
  void *v101;
  uint64_t v102;
  void (*v103)(uint64_t, const char *, ...);
  objc_class *v104;
  _BOOL4 v105;
  const char *v106;
  const char *v107;
  __CFString *v108;
  uint64_t v109;
  void *v110;
  uint64_t v111;
  NSObject *v112;
  objc_class *v113;
  int v114;
  const char *v115;
  const char *v116;
  __CFString *v117;
  NSMutableDictionary *v118;
  void *v119;
  void *v120;
  void *v121;
  void *v122;
  void *v123;
  void *v124;
  void *v125;
  id v126;
  void *v127;
  uint64_t v128;
  void (*v129)(uint64_t, const char *, ...);
  objc_class *v130;
  _BOOL4 v131;
  const char *v132;
  uint64_t v133;
  void *v134;
  uint64_t v135;
  NSObject *v136;
  objc_class *v137;
  int v138;
  const char *v139;
  const char *v140;
  void *v141;
  void *v142;
  id v143;
  id v144;
  void *v145;
  id v146;
  void *v147;
  void *v148;
  id v149;
  id v150;
  void *v151;
  void *v152;
  id v153;
  id v154;
  void *v155;
  void *specific;
  uint64_t Logger;
  void (*v158)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v162;
  void *v163;
  uint64_t v164;
  NSObject *v165;
  objc_class *v166;
  int v167;
  const char *v168;
  const char *v169;
  id v170;
  void *v171;
  void *v172;
  id v173;
  id v174;
  void *v175;
  const char *v177;
  const char *v178;
  const char *v179;
  const char *v180;
  const char *v181;
  const char *Name;
  _BYTE *v183;
  id v184;
  void *v185;
  id v186;
  void *v187;
  void *v189;
  const char *sel;
  id v191;
  _QWORD *v192;
  uint64_t v193;
  id v194;
  void *v195;
  id v196;
  id v197;
  id v198;
  void *v199;
  id v200;
  __CFString *v201;
  uint64_t v202;
  id v203;
  void *v204;
  __CFString *v205;
  uint64_t v206;
  NSMutableData *v207;
  id v208;
  __int128 v209;
  __int128 v210;
  __int128 v211;
  __int128 v212;
  __int16 v213;
  id v214;
  char v215;
  int v216;
  _QWORD v217[4];
  _QWORD v218[4];
  _QWORD v219[4];
  _QWORD v220[4];
  _QWORD v221[4];
  _QWORD v222[4];
  _QWORD v223[4];
  _QWORD v224[4];
  uint8_t buf[8];
  _BYTE v226[26];
  __int16 v227;
  const __CFString *v228;
  _QWORD v229[4];
  _QWORD v230[4];
  _BYTE v231[128];
  NSErrorUserInfoKey v232;
  const __CFString *v233;
  const __CFString *v234;
  NSErrorUserInfoKey v235;

  v12 = a2;
  v13 = a3;
  v191 = a4;
  v208 = a1;
  v189 = v12;
  if (a1)
  {
    v209 = 0u;
    v210 = 0u;
    v211 = 0u;
    v212 = 0u;
    v14 = v12;
    v203 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v209, v231, 16);
    if (v203)
    {
      v192 = a6;
      v183 = a7;
      v15 = &selRef_initWithTechnology_andValueAddedServiceMode_andSystemCode_;
      v16 = &AMFDRSealingMapCopyLocalData_ptr;
      v202 = *(_QWORD *)v210;
      v194 = v14;
      v195 = v13;
LABEL_4:
      v17 = 0;
      sel = v15[492];
      while (1)
      {
        if (*(_QWORD *)v210 != v202)
          objc_enumerationMutation(v14);
        v18 = *(__CFString **)(*((_QWORD *)&v209 + 1) + 8 * v17);
        if (objc_msgSend(v208, "didEnd"))
        {
          specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          Logger = NFLogGetLogger(specific);
          if (Logger)
          {
            v158 = (void (*)(uint64_t, const char *, ...))Logger;
            Class = object_getClass(v208);
            isMetaClass = class_isMetaClass(Class);
            ClassName = object_getClassName(v208);
            Name = sel_getName("_executeCommands:params:responses:lastSWStatus:totalAPDUTxTimeInMS:appletResponseFailure:");
            v162 = 45;
            if (isMetaClass)
              v162 = 43;
            v158(5, "%c[%{public}s %{public}s]:%i Aborted", v162, ClassName, Name, 980);
          }
          v163 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v164 = NFSharedLogGetLogger(v163);
          v165 = objc_claimAutoreleasedReturnValue(v164);
          if (os_log_type_enabled(v165, OS_LOG_TYPE_DEFAULT))
          {
            v166 = object_getClass(v208);
            if (class_isMetaClass(v166))
              v167 = 43;
            else
              v167 = 45;
            v168 = object_getClassName(v208);
            v169 = sel_getName("_executeCommands:params:responses:lastSWStatus:totalAPDUTxTimeInMS:appletResponseFailure:");
            *(_DWORD *)buf = 67109890;
            *(_DWORD *)&buf[4] = v167;
            *(_WORD *)v226 = 2082;
            *(_QWORD *)&v226[2] = v168;
            *(_WORD *)&v226[10] = 2082;
            *(_QWORD *)&v226[12] = v169;
            *(_WORD *)&v226[20] = 1024;
            *(_DWORD *)&v226[22] = 980;
            _os_log_impl((void *)&_mh_execute_header, v165, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Aborted", buf, 0x22u);
          }

          v170 = objc_alloc((Class)NSError);
          v171 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
          v229[0] = NSLocalizedDescriptionKey;
          v172 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Aborted"));
          v230[0] = v172;
          v230[1] = &off_1002FFDB0;
          v229[1] = CFSTR("Line");
          v229[2] = CFSTR("Method");
          v173 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_executeCommands:params:responses:lastSWStatus:totalAPDUTxTimeInMS:appletResponseFailure:"));
          v230[2] = v173;
          v229[3] = NSDebugDescriptionErrorKey;
          v174 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_executeCommands:params:responses:lastSWStatus:totalAPDUTxTimeInMS:appletResponseFailure:"), 981);
          v230[3] = v174;
          v175 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16[241], "dictionaryWithObjects:forKeys:count:", v230, v229, 4));
          v196 = objc_msgSend(v170, "initWithDomain:code:userInfo:", v171, 3, v175);

          goto LABEL_129;
        }
        v19 = objc_opt_class(v16[241]);
        v206 = v17;
        if ((objc_opt_isKindOfClass(v18, v19) & 1) != 0)
          break;
        v39 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v40 = NFLogGetLogger(v39);
        if (v40)
        {
          v41 = (void (*)(uint64_t, const char *, ...))v40;
          v42 = object_getClass(v208);
          v43 = class_isMetaClass(v42);
          v177 = object_getClassName(v208);
          v179 = sel_getName("_executeCommands:params:responses:lastSWStatus:totalAPDUTxTimeInMS:appletResponseFailure:");
          v44 = 45;
          if (v43)
            v44 = 43;
          v41(5, "%c[%{public}s %{public}s]:%i Command is not in expected format: %{public}@", v44, v177, v179, 985, v18);
        }
        v45 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v46 = NFSharedLogGetLogger(v45);
        v47 = objc_claimAutoreleasedReturnValue(v46);
        if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
        {
          v48 = object_getClass(v208);
          if (class_isMetaClass(v48))
            v49 = 43;
          else
            v49 = 45;
          v50 = object_getClassName(v208);
          v51 = sel_getName("_executeCommands:params:responses:lastSWStatus:totalAPDUTxTimeInMS:appletResponseFailure:");
          *(_DWORD *)buf = 67110146;
          *(_DWORD *)&buf[4] = v49;
          *(_WORD *)v226 = 2082;
          *(_QWORD *)&v226[2] = v50;
          *(_WORD *)&v226[10] = 2082;
          *(_QWORD *)&v226[12] = v51;
          *(_WORD *)&v226[20] = 1024;
          *(_DWORD *)&v226[22] = 985;
          v227 = 2114;
          v228 = v18;
          _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Command is not in expected format: %{public}@", buf, 0x2Cu);
        }

LABEL_116:
        v17 = v206 + 1;
        if ((id)(v206 + 1) == v203)
        {
          v203 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v209, v231, 16);
          v15 = &selRef_initWithTechnology_andValueAddedServiceMode_andSystemCode_;
          if (v203)
            goto LABEL_4;
          goto LABEL_118;
        }
      }
      v201 = (__CFString *)objc_claimAutoreleasedReturnValue(-[__CFString NF_stringForKey:](v18, "NF_stringForKey:", CFSTR("kMessageName")));
      v205 = (__CFString *)objc_claimAutoreleasedReturnValue(-[__CFString NF_stringForKey:](v18, "NF_stringForKey:", CFSTR("kData")));
      v20 = objc_claimAutoreleasedReturnValue(+[NSData NF_dataWithHexString:](NSData, "NF_dataWithHexString:"));
      v204 = (void *)v20;
      if (v20)
      {
        v21 = (void *)v20;
        v200 = objc_msgSend(objc_alloc((Class)NFCommandAPDU), "initWithData:", v20);
        if (!objc_msgSend(v13, "checkAIDAllowList")
          || (v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "AIDAllowList")),
              v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSSet setWithArray:](NSSet, "setWithArray:", v22)),
              v24 = ValidateAPDUWithAIDAllowList(v200, v23),
              v23,
              v22,
              v21 = v204,
              (v24 & 1) != 0))
        {
          v25 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString NF_numberForKey:](v18, "NF_numberForKey:", CFSTR("kChainingResponse")));
          v193 = mach_continuous_time();
          if (objc_msgSend(v13, "toSystemOS"))
            v26 = 2;
          else
            v26 = 0;
          v199 = v25;
          v27 = objc_msgSend(v25, "BOOLValue");
          v28 = objc_retainAutorelease(v21);
          v215 = *(_BYTE *)objc_msgSend(v28, "bytes");
          v216 = 192;
          v207 = objc_opt_new(NSMutableData);
          v29 = 0;
          v30 = -1;
          for (i = v28; ; i = (void *)v38)
          {
            v32 = v29;
            v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v208, "embeddedSecureElementWrapper"));
            v214 = v29;
            v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v33, "transceiveData:toOS:error:", i, v26, &v214));
            v29 = v214;

            if (!v34)
              break;
            v35 = (void *)objc_claimAutoreleasedReturnValue(+[NFResponseAPDU responseWithData:](NFResponseAPDU, "responseWithData:", v34));
            v36 = v35;
            if (!v35)
            {
              v186 = objc_alloc((Class)NSError);
              v185 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
              v232 = NSLocalizedDescriptionKey;
              v187 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unexpected Result"));
              *(_QWORD *)buf = v187;
              *(_QWORD *)v226 = &off_1002FFD98;
              v233 = CFSTR("Line");
              v234 = CFSTR("Method");
              v184 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(sel));
              *(_QWORD *)&v226[8] = v184;
              v235 = NSDebugDescriptionErrorKey;
              v96 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(sel), 942);
              *(_QWORD *)&v226[16] = v96;
              v97 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v232, 4));
              v95 = objc_msgSend(v186, "initWithDomain:code:userInfo:", v185, 13, v97);

LABEL_61:
              goto LABEL_62;
            }
            v30 = objc_msgSend(v35, "status");
            v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v36, "response"));
            -[NSMutableData appendData:](v207, "appendData:", v37);

            if (!v27)
            {
              v95 = 0;
              i = v28;
              goto LABEL_61;
            }
            if ((objc_msgSend(v36, "status") & 0xFF00) != 0x6100)
            {
              v95 = 0;
              goto LABEL_61;
            }
            HIBYTE(v216) = objc_msgSend(v36, "status");
            v38 = objc_claimAutoreleasedReturnValue(+[NSData dataWithBytesNoCopy:length:freeWhenDone:](NSData, "dataWithBytesNoCopy:length:freeWhenDone:", &v215, 5, 0));

          }
          if (v29)
          {
            v95 = objc_retainAutorelease(v29);
            v29 = v95;
          }
          else
          {
            v146 = objc_alloc((Class)NSError);
            v147 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
            v232 = NSLocalizedDescriptionKey;
            v148 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
            *(_QWORD *)buf = v148;
            *(_QWORD *)v226 = &off_1002FFD80;
            v233 = CFSTR("Line");
            v234 = CFSTR("Method");
            v149 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(sel));
            *(_QWORD *)&v226[8] = v149;
            v235 = NSDebugDescriptionErrorKey;
            v150 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(sel), 935);
            *(_QWORD *)&v226[16] = v150;
            v151 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v232, 4));
            v95 = objc_retainAutorelease(objc_msgSend(v146, "initWithDomain:code:userInfo:", v147, 15, v151));

            v29 = 0;
          }
LABEL_62:
          v72 = v199;
          if (v30 != -1)
          {
            v213 = bswap32(v30) >> 16;
            -[NSMutableData appendBytes:length:](v207, "appendBytes:length:", &v213, 2);
          }

          v73 = v95;
          v98 = mach_continuous_time();
          ElapsedTimeInMillisecondsFromMachTime = GetElapsedTimeInMillisecondsFromMachTime(v98, v193);
          v100 = ElapsedTimeInMillisecondsFromMachTime;
          if (v192)
            *v192 += ElapsedTimeInMillisecondsFromMachTime;
          if (v73)
          {
            v101 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v102 = NFLogGetLogger(v101);
            v54 = v201;
            if (v102)
            {
              v103 = (void (*)(uint64_t, const char *, ...))v102;
              v104 = object_getClass(v208);
              v105 = class_isMetaClass(v104);
              v106 = object_getClassName(v208);
              v107 = sel_getName("_executeCommands:params:responses:lastSWStatus:totalAPDUTxTimeInMS:appletResponseFailure:");
              if (v201)
                v108 = v201;
              else
                v108 = v205;
              v72 = v199;
              v109 = 45;
              if (v105)
                v109 = 43;
              v103(3, "%c[%{public}s %{public}s]:%i Failed to execute C-APDU %{public}@", v109, v106, v107, 1026, v108);
            }
            v110 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v111 = NFSharedLogGetLogger(v110);
            v112 = objc_claimAutoreleasedReturnValue(v111);
            if (os_log_type_enabled(v112, OS_LOG_TYPE_ERROR))
            {
              v113 = object_getClass(v208);
              if (class_isMetaClass(v113))
                v114 = 43;
              else
                v114 = 45;
              v115 = object_getClassName(v208);
              v116 = sel_getName("_executeCommands:params:responses:lastSWStatus:totalAPDUTxTimeInMS:appletResponseFailure:");
              *(_DWORD *)buf = 67110146;
              v117 = v205;
              if (v201)
                v117 = v201;
              *(_DWORD *)&buf[4] = v114;
              *(_WORD *)v226 = 2082;
              *(_QWORD *)&v226[2] = v115;
              v72 = v199;
              *(_WORD *)&v226[10] = 2082;
              *(_QWORD *)&v226[12] = v116;
              *(_WORD *)&v226[20] = 1024;
              *(_DWORD *)&v226[22] = 1026;
              v227 = 2114;
              v228 = v117;
              _os_log_impl((void *)&_mh_execute_header, v112, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to execute C-APDU %{public}@", buf, 0x2Cu);
            }

            v73 = v73;
            v78 = 1;
            v196 = v73;
            v77 = v200;
            goto LABEL_114;
          }
          if (!-[NSMutableData length](v207, "length"))
          {
            v127 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v128 = NFLogGetLogger(v127);
            if (v128)
            {
              v129 = (void (*)(uint64_t, const char *, ...))v128;
              v130 = object_getClass(v208);
              v131 = class_isMetaClass(v130);
              v132 = object_getClassName(v208);
              v181 = sel_getName("_executeCommands:params:responses:lastSWStatus:totalAPDUTxTimeInMS:appletResponseFailure:");
              v133 = 45;
              if (v131)
                v133 = 43;
              v129(5, "%c[%{public}s %{public}s]:%i Unexpected empty response with no error", v133, v132, v181, 1031);
            }
            v134 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v135 = NFSharedLogGetLogger(v134);
            v136 = objc_claimAutoreleasedReturnValue(v135);
            v54 = v201;
            if (os_log_type_enabled(v136, OS_LOG_TYPE_DEFAULT))
            {
              v137 = object_getClass(v208);
              if (class_isMetaClass(v137))
                v138 = 43;
              else
                v138 = 45;
              v139 = object_getClassName(v208);
              v140 = sel_getName("_executeCommands:params:responses:lastSWStatus:totalAPDUTxTimeInMS:appletResponseFailure:");
              *(_DWORD *)buf = 67109890;
              *(_DWORD *)&buf[4] = v138;
              *(_WORD *)v226 = 2082;
              *(_QWORD *)&v226[2] = v139;
              *(_WORD *)&v226[10] = 2082;
              *(_QWORD *)&v226[12] = v140;
              *(_WORD *)&v226[20] = 1024;
              *(_DWORD *)&v226[22] = 1031;
              _os_log_impl((void *)&_mh_execute_header, v136, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Unexpected empty response with no error", buf, 0x22u);
            }

            v197 = objc_alloc((Class)NSError);
            v141 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
            v219[0] = NSLocalizedDescriptionKey;
            v142 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Empty response"));
            v220[0] = v142;
            v220[1] = &off_1002FFDF8;
            v219[1] = CFSTR("Line");
            v219[2] = CFSTR("Method");
            v143 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_executeCommands:params:responses:lastSWStatus:totalAPDUTxTimeInMS:appletResponseFailure:"));
            v220[2] = v143;
            v219[3] = NSDebugDescriptionErrorKey;
            v144 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_executeCommands:params:responses:lastSWStatus:totalAPDUTxTimeInMS:appletResponseFailure:"), 1032);
            v220[3] = v144;
            v145 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v220, v219, 4));
            v196 = objc_msgSend(v197, "initWithDomain:code:userInfo:", v141, 66, v145);

            v78 = 1;
            goto LABEL_113;
          }
          v118 = objc_opt_new(NSMutableDictionary);
          if (objc_msgSend(v195, "includeAPDUDuration"))
          {
            v119 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v100));
            -[NSMutableDictionary setObject:forKeyedSubscript:](v118, "setObject:forKeyedSubscript:", v119, CFSTR("durationInMS"));

          }
          v120 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableData NF_asHexString](v207, "NF_asHexString"));
          -[NSMutableDictionary setObject:forKeyedSubscript:](v118, "setObject:forKeyedSubscript:", v120, CFSTR("kData"));

          v121 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v18, "objectForKeyedSubscript:", CFSTR("kMessageId")));
          -[NSMutableDictionary setObject:forKeyedSubscript:](v118, "setObject:forKeyedSubscript:", v121, CFSTR("kMessageId"));

          if (v201)
          {
            v122 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString stringByAppendingString:](v201, "stringByAppendingString:", CFSTR("_RESP")));
            -[NSMutableDictionary setObject:forKeyedSubscript:](v118, "setObject:forKeyedSubscript:", v122, CFSTR("kMessageName"));

          }
          v123 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString NF_stringForKey:](v18, "NF_stringForKey:", CFSTR("dataProtocol")));
          if (v123)
            -[NSMutableDictionary setObject:forKeyedSubscript:](v118, "setObject:forKeyedSubscript:", v123, CFSTR("dataProtocol"));
          if (-[NSMutableDictionary count](v118, "count"))
            objc_msgSend(v191, "addObject:", v118);
          if (a5)
            *a5 = v30;
          v124 = (void *)objc_claimAutoreleasedReturnValue(+[NFResponseAPDU responseWithData:](NFResponseAPDU, "responseWithData:", v207));
          if (v124)
          {
            v125 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v208, "_processCommandDataProtocol:response:", v18, v124));
            if (v125)
            {
              v54 = v201;
              if (v183)
                *v183 = 1;
              v126 = v125;
              v78 = 1;
              v196 = v126;
              goto LABEL_112;
            }
            v126 = 0;
            v78 = 0;
          }
          else
          {
            v198 = objc_alloc((Class)NSError);
            v126 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
            v217[0] = NSLocalizedDescriptionKey;
            v152 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Empty response"));
            v218[0] = v152;
            v218[1] = &off_1002FFE10;
            v217[1] = CFSTR("Line");
            v217[2] = CFSTR("Method");
            v153 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_executeCommands:params:responses:lastSWStatus:totalAPDUTxTimeInMS:appletResponseFailure:"));
            v218[2] = v153;
            v217[3] = NSDebugDescriptionErrorKey;
            v154 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_executeCommands:params:responses:lastSWStatus:totalAPDUTxTimeInMS:appletResponseFailure:"), 1060);
            v218[3] = v154;
            v155 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v218, v217, 4));
            v196 = objc_msgSend(v198, "initWithDomain:code:userInfo:", v126, 66, v155);

            v78 = 1;
          }
          v54 = v201;
LABEL_112:

LABEL_113:
          v72 = v199;
          v77 = v200;
LABEL_114:
          v74 = v207;
          goto LABEL_115;
        }
        v79 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v80 = NFLogGetLogger(v79);
        if (v80)
        {
          v81 = (void (*)(uint64_t, const char *, ...))v80;
          v82 = object_getClass(v208);
          v83 = class_isMetaClass(v82);
          v178 = object_getClassName(v208);
          v180 = sel_getName("_executeCommands:params:responses:lastSWStatus:totalAPDUTxTimeInMS:appletResponseFailure:");
          v84 = 45;
          if (v83)
            v84 = 43;
          v81(3, "%c[%{public}s %{public}s]:%i Validation failed, C-APDU %{public}@", v84, v178, v180, 1004, v205);
        }
        v85 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v86 = NFSharedLogGetLogger(v85);
        v87 = objc_claimAutoreleasedReturnValue(v86);
        v54 = v201;
        if (os_log_type_enabled(v87, OS_LOG_TYPE_ERROR))
        {
          v88 = object_getClass(v208);
          if (class_isMetaClass(v88))
            v89 = 43;
          else
            v89 = 45;
          v90 = object_getClassName(v208);
          v91 = sel_getName("_executeCommands:params:responses:lastSWStatus:totalAPDUTxTimeInMS:appletResponseFailure:");
          *(_DWORD *)buf = 67110146;
          *(_DWORD *)&buf[4] = v89;
          *(_WORD *)v226 = 2082;
          *(_QWORD *)&v226[2] = v90;
          *(_WORD *)&v226[10] = 2082;
          *(_QWORD *)&v226[12] = v91;
          *(_WORD *)&v226[20] = 1024;
          *(_DWORD *)&v226[22] = 1004;
          v227 = 2114;
          v228 = v205;
          _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Validation failed, C-APDU %{public}@", buf, 0x2Cu);
        }

        v92 = objc_alloc((Class)NSError);
        v72 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v221[0] = NSLocalizedDescriptionKey;
        v73 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Commmand Error"));
        v222[0] = v73;
        v222[1] = &off_1002FFDE0;
        v221[1] = CFSTR("Line");
        v221[2] = CFSTR("Method");
        v74 = (NSMutableData *)objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_executeCommands:params:responses:lastSWStatus:totalAPDUTxTimeInMS:appletResponseFailure:"));
        v222[2] = v74;
        v221[3] = NSDebugDescriptionErrorKey;
        v93 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_executeCommands:params:responses:lastSWStatus:totalAPDUTxTimeInMS:appletResponseFailure:"), 1005);
        v222[3] = v93;
        v94 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v222, v221, 4));
        v196 = objc_msgSend(v92, "initWithDomain:code:userInfo:", v72, 16, v94);

        v78 = 1;
        v77 = v200;
      }
      else
      {
        v52 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v53 = NFLogGetLogger(v52);
        v54 = v201;
        if (v53)
        {
          v55 = (void (*)(uint64_t, const char *, ...))v53;
          v56 = object_getClass(v208);
          v57 = class_isMetaClass(v56);
          v58 = object_getClassName(v208);
          v59 = sel_getName("_executeCommands:params:responses:lastSWStatus:totalAPDUTxTimeInMS:appletResponseFailure:");
          if (v201)
            v60 = v201;
          else
            v60 = CFSTR("NO_NAME");
          v61 = 45;
          if (v57)
            v61 = 43;
          v55(3, "%c[%{public}s %{public}s]:%i Invalid C-APDU %{public}@", v61, v58, v59, 997, v60);
        }
        v62 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v63 = NFSharedLogGetLogger(v62);
        v64 = objc_claimAutoreleasedReturnValue(v63);
        if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
        {
          v65 = object_getClass(v208);
          if (class_isMetaClass(v65))
            v66 = 43;
          else
            v66 = 45;
          v67 = object_getClassName(v208);
          v68 = sel_getName("_executeCommands:params:responses:lastSWStatus:totalAPDUTxTimeInMS:appletResponseFailure:");
          *(_DWORD *)buf = 67110146;
          v69 = CFSTR("NO_NAME");
          if (v201)
            v69 = v201;
          *(_DWORD *)&buf[4] = v66;
          *(_WORD *)v226 = 2082;
          *(_QWORD *)&v226[2] = v67;
          *(_WORD *)&v226[10] = 2082;
          *(_QWORD *)&v226[12] = v68;
          *(_WORD *)&v226[20] = 1024;
          *(_DWORD *)&v226[22] = 997;
          v227 = 2114;
          v228 = v69;
          _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid C-APDU %{public}@", buf, 0x2Cu);
        }

        v70 = objc_alloc((Class)NSError);
        v71 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v223[0] = NSLocalizedDescriptionKey;
        v72 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Decoding Error"));
        v224[0] = v72;
        v224[1] = &off_1002FFDC8;
        v223[1] = CFSTR("Line");
        v223[2] = CFSTR("Method");
        v73 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_executeCommands:params:responses:lastSWStatus:totalAPDUTxTimeInMS:appletResponseFailure:"));
        v224[2] = v73;
        v223[3] = NSDebugDescriptionErrorKey;
        v74 = (NSMutableData *)objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_executeCommands:params:responses:lastSWStatus:totalAPDUTxTimeInMS:appletResponseFailure:"), 998);
        v224[3] = v74;
        v75 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v224, v223, 4));
        v76 = v70;
        v77 = (void *)v71;
        v196 = objc_msgSend(v76, "initWithDomain:code:userInfo:", v71, 23, v75);

        v78 = 1;
      }
LABEL_115:

      v14 = v194;
      v13 = v195;
      v16 = &AMFDRSealingMapCopyLocalData_ptr;
      if (v78)
        goto LABEL_129;
      goto LABEL_116;
    }
LABEL_118:
    v196 = 0;
LABEL_129:

  }
  else
  {
    v196 = 0;
  }

  return v196;
}

void sub_10015D660(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  void *v19;
  uint64_t v20;
  void (*v21)(uint64_t, const char *, ...);
  objc_class *v22;
  _BOOL4 v23;
  const char *v24;
  const char *v25;
  void *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  NSObject *v30;
  objc_class *v31;
  int v32;
  const char *v33;
  const char *v34;
  void *v35;
  uint64_t v36;
  id v37;
  void *v38;
  void *v39;
  void *v40;
  id v41;
  void *v42;
  void *v43;
  void *v44;
  id v45;
  void *v46;
  uint64_t v47;
  NSDictionary *v48;
  void *v49;
  uint64_t v50;
  void (*v51)(uint64_t, const char *, ...);
  objc_class *v52;
  _BOOL4 v53;
  const char *v54;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  NSObject *v58;
  objc_class *v59;
  int v60;
  const char *v61;
  const char *v62;
  uint64_t v63;
  id v64;
  void *v65;
  id v66;
  id v67;
  void *v68;
  id v69;
  void *v70;
  void *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  void *v77;
  id v78;
  void *v79;
  void *v80;
  NSMutableArray *v81;
  id v82;
  void *v83;
  uint64_t v84;
  void (*v85)(uint64_t, const char *, ...);
  objc_class *v86;
  void *v87;
  void *v88;
  uint64_t v89;
  void *v90;
  uint64_t v91;
  NSObject *v92;
  objc_class *v93;
  int v94;
  const char *v95;
  void *v96;
  void *v97;
  void *v98;
  uint64_t v99;
  void *v100;
  uint64_t v101;
  void (*v102)(uint64_t, const char *, ...);
  objc_class *v103;
  _BOOL4 v104;
  const char *v105;
  uint64_t v106;
  void *v107;
  uint64_t v108;
  NSObject *v109;
  objc_class *v110;
  int v111;
  const char *v112;
  const char *v113;
  uint64_t v114;
  id v115;
  void *v116;
  id v117;
  id v118;
  void *v119;
  id v120;
  void *v121;
  uint64_t v122;
  void (*v123)(uint64_t, const char *, ...);
  objc_class *v124;
  _BOOL4 v125;
  const char *v126;
  uint64_t v127;
  void *v128;
  uint64_t v129;
  NSObject *v130;
  objc_class *v131;
  int v132;
  const char *v133;
  const char *v134;
  void *v135;
  uint64_t v136;
  void (*v137)(uint64_t, const char *, ...);
  objc_class *v138;
  _BOOL4 v139;
  const char *v140;
  uint64_t v141;
  void *v142;
  uint64_t v143;
  NSObject *v144;
  objc_class *v145;
  int v146;
  const char *v147;
  const char *v148;
  uint64_t v149;
  id v150;
  void *v151;
  id v152;
  id v153;
  _QWORD *v154;
  _QWORD *v155;
  void *v156;
  uint64_t v157;
  void (*v158)(uint64_t, const char *, ...);
  objc_class *v159;
  _BOOL4 v160;
  const char *v161;
  uint64_t v162;
  void *v163;
  uint64_t v164;
  NSObject *v165;
  objc_class *v166;
  int v167;
  const char *v168;
  const char *v169;
  void *v170;
  id v171;
  id v172;
  void *v173;
  void *v174;
  void *v175;
  id v176;
  void *v177;
  id v178;
  void *v179;
  void *v180;
  void *v181;
  const __CFString *v182;
  void *v183;
  id v184;
  void *v185;
  uint64_t v186;
  void (*v187)(uint64_t, const char *, ...);
  objc_class *v188;
  _BOOL4 v189;
  const char *v190;
  uint64_t v191;
  void *v192;
  uint64_t v193;
  NSObject *v194;
  objc_class *v195;
  int v196;
  const char *v197;
  const char *v198;
  id v199;
  void *v200;
  void *v201;
  void *v202;
  id v203;
  id v204;
  void *v205;
  void *v206;
  uint64_t v207;
  void *v208;
  void *v209;
  uint64_t v210;
  void (*v211)(uint64_t, const char *, ...);
  objc_class *v212;
  _BOOL4 v213;
  void *v214;
  void *v215;
  uint64_t v216;
  void *v217;
  uint64_t v218;
  NSObject *v219;
  objc_class *v220;
  int v221;
  const char *v222;
  void *v223;
  void *v224;
  unsigned int v225;
  id v226;
  id v227;
  const char *v228;
  const char *v229;
  const char *v230;
  const char *v231;
  const char *v232;
  const char *v233;
  uint64_t v234;
  id v235;
  const char *v236;
  id v237;
  const char *v238;
  uint64_t v239;
  const char *v240;
  void *v241;
  _BOOL4 v242;
  const char *v243;
  void *v244;
  void *v245;
  const char *v246;
  const char *v247;
  void *v248;
  void *v249;
  void *v250;
  char v251;
  id v252;
  uint64_t v253;
  unint64_t v254;
  _QWORD v255[4];
  _QWORD v256[4];
  NSErrorUserInfoKey v257;
  void *v258;
  _QWORD v259[5];
  _QWORD v260[5];
  _QWORD v261[4];
  _QWORD v262[4];
  int buf;
  int v264;
  __int16 v265;
  const char *v266;
  __int16 v267;
  const char *v268;
  __int16 v269;
  int v270;
  __int16 v271;
  void *v272;
  __int16 v273;
  unsigned int v274;
  _QWORD v275[4];
  _QWORD v276[4];
  _QWORD v277[4];
  _QWORD v278[4];
  _QWORD v279[4];
  _QWORD v280[4];
  _QWORD v281[4];
  _QWORD v282[4];
  NSErrorUserInfoKey v283;
  void *v284;

  v254 = 0;
  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 64));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v10 = 45;
    if (isMetaClass)
      v10 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@", v10, ClassName, Name, 1083, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 64));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    buf = 67110146;
    v264 = v15;
    v265 = 2082;
    v266 = v16;
    v267 = 2082;
    v268 = v17;
    v269 = 1024;
    v270 = 1083;
    v271 = 2114;
    v272 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", (uint8_t *)&buf, 0x2Cu);

  }
  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    objc_msgSend(*(id *)(a1 + 32), "markAsDirty:", 1);
    v42 = *(void **)(a1 + 32);
    v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "seid"));
    v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v42, "_getSecureElementWrapperForSEID:", v43));

    if ((objc_msgSend(*(id *)(a1 + 32), "_activateSecureElementWrapper:", v38) & 1) == 0)
    {
      v49 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v50 = NFLogGetLogger(v49);
      if (v50)
      {
        v51 = (void (*)(uint64_t, const char *, ...))v50;
        v52 = object_getClass(*(id *)(a1 + 32));
        v53 = class_isMetaClass(v52);
        v54 = object_getClassName(*(id *)(a1 + 32));
        v228 = sel_getName(*(SEL *)(a1 + 64));
        v55 = 45;
        if (v53)
          v55 = 43;
        v51(3, "%c[%{public}s %{public}s]:%i SE activation failed", v55, v54, v228, 1091);
      }
      v56 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v57 = NFSharedLogGetLogger(v56);
      v58 = objc_claimAutoreleasedReturnValue(v57);
      if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
      {
        v59 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v59))
          v60 = 43;
        else
          v60 = 45;
        v61 = object_getClassName(*(id *)(a1 + 32));
        v62 = sel_getName(*(SEL *)(a1 + 64));
        buf = 67109890;
        v264 = v60;
        v265 = 2082;
        v266 = v61;
        v267 = 2082;
        v268 = v62;
        v269 = 1024;
        v270 = 1091;
        _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i SE activation failed", (uint8_t *)&buf, 0x22u);
      }

      v63 = *(_QWORD *)(a1 + 56);
      v64 = objc_alloc((Class)NSError);
      v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v281[0] = NSLocalizedDescriptionKey;
      v65 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
      v282[0] = v65;
      v282[1] = &off_1002FFE28;
      v281[1] = CFSTR("Line");
      v281[2] = CFSTR("Method");
      v66 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 64)));
      v282[2] = v66;
      v281[3] = NSDebugDescriptionErrorKey;
      v67 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 64)), 1092);
      v282[3] = v67;
      v68 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v282, v281, 4));
      v69 = objc_msgSend(v64, "initWithDomain:code:userInfo:", v46, 15, v68);
      (*(void (**)(uint64_t, _QWORD, uint64_t, id, double))(v63 + 16))(v63, 0, -1, v69, 0.0);

      goto LABEL_40;
    }
    if (objc_msgSend(*(id *)(a1 + 40), "deactivateAllApps"))
    {
      v44 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
      v45 = sub_10022DCC4(v44);
      v46 = (void *)objc_claimAutoreleasedReturnValue(v45);

      if (v46)
      {
        v47 = *(_QWORD *)(a1 + 56);
        v48 = objc_opt_new(NSDictionary);
        (*(void (**)(uint64_t, NSDictionary *, _QWORD, void *, double))(v47 + 16))(v47, v48, 0, v46, 0.0);

LABEL_40:
        goto LABEL_24;
      }
    }
    if (!objc_msgSend(*(id *)(a1 + 48), "count"))
    {
      v121 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v122 = NFLogGetLogger(v121);
      if (v122)
      {
        v123 = (void (*)(uint64_t, const char *, ...))v122;
        v124 = object_getClass(*(id *)(a1 + 32));
        v125 = class_isMetaClass(v124);
        v126 = object_getClassName(*(id *)(a1 + 32));
        v230 = sel_getName(*(SEL *)(a1 + 64));
        v127 = 45;
        if (v125)
          v127 = 43;
        v123(5, "%c[%{public}s %{public}s]:%i Script is empty", v127, v126, v230, 1107);
      }
      v128 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v129 = NFSharedLogGetLogger(v128);
      v130 = objc_claimAutoreleasedReturnValue(v129);
      if (os_log_type_enabled(v130, OS_LOG_TYPE_DEFAULT))
      {
        v131 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v131))
          v132 = 43;
        else
          v132 = 45;
        v133 = object_getClassName(*(id *)(a1 + 32));
        v134 = sel_getName(*(SEL *)(a1 + 64));
        buf = 67109890;
        v264 = v132;
        v265 = 2082;
        v266 = v133;
        v267 = 2082;
        v268 = v134;
        v269 = 1024;
        v270 = 1107;
        _os_log_impl((void *)&_mh_execute_header, v130, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Script is empty", (uint8_t *)&buf, 0x22u);
      }

      (*(void (**)(double))(*(_QWORD *)(a1 + 56) + 16))(0.0);
      goto LABEL_24;
    }
    v253 = -1;
    v70 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "NF_stringForKey:", CFSTR("kBatchId")));
    v71 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "NF_arrayForKey:", CFSTR("kCommands")));
    v72 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "NF_stringForKey:", CFSTR("kTaskId")));
    v249 = (void *)v72;
    v250 = v71;
    if (!v70 || (v73 = v72, v74 = objc_opt_class(NSString), (objc_opt_isKindOfClass(v70, v74) & 1) == 0))
    {
      v100 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v101 = NFLogGetLogger(v100);
      if (v101)
      {
        v102 = (void (*)(uint64_t, const char *, ...))v101;
        v103 = object_getClass(*(id *)(a1 + 32));
        v104 = class_isMetaClass(v103);
        v105 = object_getClassName(*(id *)(a1 + 32));
        v229 = sel_getName(*(SEL *)(a1 + 64));
        v106 = 45;
        if (v104)
          v106 = 43;
        v102(3, "%c[%{public}s %{public}s]:%i Invalid batch ID", v106, v105, v229, 1119);
      }
      v107 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v108 = NFSharedLogGetLogger(v107);
      v109 = objc_claimAutoreleasedReturnValue(v108);
      if (os_log_type_enabled(v109, OS_LOG_TYPE_ERROR))
      {
        v110 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v110))
          v111 = 43;
        else
          v111 = 45;
        v112 = object_getClassName(*(id *)(a1 + 32));
        v113 = sel_getName(*(SEL *)(a1 + 64));
        buf = 67109890;
        v264 = v111;
        v265 = 2082;
        v266 = v112;
        v267 = 2082;
        v268 = v113;
        v269 = 1024;
        v270 = 1119;
        _os_log_impl((void *)&_mh_execute_header, v109, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid batch ID", (uint8_t *)&buf, 0x22u);
      }

      v114 = *(_QWORD *)(a1 + 56);
      v115 = objc_alloc((Class)NSError);
      v81 = (NSMutableArray *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v279[0] = NSLocalizedDescriptionKey;
      v116 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Missing Parameter"));
      v280[0] = v116;
      v280[1] = &off_1002FFE40;
      v279[1] = CFSTR("Line");
      v279[2] = CFSTR("Method");
      v117 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 64)));
      v280[2] = v117;
      v279[3] = NSDebugDescriptionErrorKey;
      v118 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 64)), 1120);
      v280[3] = v118;
      v119 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v280, v279, 4));
      v120 = objc_msgSend(v115, "initWithDomain:code:userInfo:", v81, 9, v119);
      (*(void (**)(uint64_t, _QWORD, uint64_t, id, double))(v114 + 16))(v114, 0, -1, v120, 0.0);

      v82 = 0;
      goto LABEL_104;
    }
    v248 = v70;
    if (v71 && (v75 = objc_opt_class(NSArray), (objc_opt_isKindOfClass(v71, v75) & 1) != 0))
    {
      if (v73)
      {
        v76 = objc_opt_class(NSString);
        if ((objc_opt_isKindOfClass(v73, v76) & 1) != 0)
        {
          if (objc_msgSend(*(id *)(a1 + 40), "initialSelectBeforeRun"))
          {
            v77 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "AIDAllowList"));
            v78 = objc_msgSend(v77, "count");

            if (v78)
            {
              v241 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
              v79 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "AIDAllowList"));
              v80 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v79, "firstObject"));
              v252 = 0;
              v81 = (NSMutableArray *)objc_claimAutoreleasedReturnValue(objc_msgSend(v241, "selectByName:error:", v80, &v252));
              v82 = v252;

              if (v82)
              {
                v83 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                v84 = NFLogGetLogger(v83);
                if (v84)
                {
                  v85 = (void (*)(uint64_t, const char *, ...))v84;
                  v86 = object_getClass(*(id *)(a1 + 32));
                  v242 = class_isMetaClass(v86);
                  v238 = object_getClassName(*(id *)(a1 + 32));
                  v236 = sel_getName(*(SEL *)(a1 + 64));
                  v87 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "AIDAllowList"));
                  v88 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v87, "firstObject"));
                  v89 = 45;
                  if (v242)
                    v89 = 43;
                  v85(3, "%c[%{public}s %{public}s]:%i Fail to select %{public}@", v89, v238, v236, 1145, v88);

                }
                v90 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                v91 = NFSharedLogGetLogger(v90);
                v92 = objc_claimAutoreleasedReturnValue(v91);
                if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
                {
                  v93 = object_getClass(*(id *)(a1 + 32));
                  if (class_isMetaClass(v93))
                    v94 = 43;
                  else
                    v94 = 45;
                  v243 = object_getClassName(*(id *)(a1 + 32));
                  v95 = sel_getName(*(SEL *)(a1 + 64));
                  v96 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "AIDAllowList"));
                  v97 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v96, "firstObject"));
                  buf = 67110146;
                  v264 = v94;
                  v265 = 2082;
                  v266 = v243;
                  v267 = 2082;
                  v268 = v95;
                  v269 = 1024;
                  v270 = 1145;
                  v271 = 2114;
                  v272 = v97;
                  _os_log_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Fail to select %{public}@", (uint8_t *)&buf, 0x2Cu);

                }
                v239 = *(_QWORD *)(a1 + 56);
                v237 = objc_alloc((Class)NSError);
                v98 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
                v235 = objc_msgSend(v82, "code");
                v259[0] = NSLocalizedDescriptionKey;
                if ((uint64_t)objc_msgSend(v82, "code") > 70)
                  v99 = 71;
                else
                  v99 = (uint64_t)objc_msgSend(v82, "code");
                v245 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E9508[v99]));
                v260[0] = v245;
                v260[1] = v82;
                v259[1] = NSUnderlyingErrorKey;
                v259[2] = CFSTR("Line");
                v260[2] = &off_1002FFEA0;
                v259[3] = CFSTR("Method");
                v203 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 64)));
                v260[3] = v203;
                v259[4] = NSDebugDescriptionErrorKey;
                v204 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 64)), 1146);
                v260[4] = v204;
                v205 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v260, v259, 5));
                v207 = (uint64_t)v235;
                v206 = v237;
                v208 = v98;
LABEL_147:
                v227 = objc_msgSend(v206, "initWithDomain:code:userInfo:", v208, v207, v205);
                (*(void (**)(uint64_t, _QWORD, uint64_t, id, double))(v239 + 16))(v239, 0, -1, v227, 0.0);

                goto LABEL_103;
              }
              if (-[NSMutableArray status](v81, "status") != 36864)
              {
                v209 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                v210 = NFLogGetLogger(v209);
                if (v210)
                {
                  v211 = (void (*)(uint64_t, const char *, ...))v210;
                  v212 = object_getClass(*(id *)(a1 + 32));
                  v213 = class_isMetaClass(v212);
                  v246 = object_getClassName(*(id *)(a1 + 32));
                  v240 = sel_getName(*(SEL *)(a1 + 64));
                  v214 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "AIDAllowList"));
                  v215 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v214, "firstObject"));
                  v234 = -[NSMutableArray status](v81, "status");
                  v216 = 45;
                  if (v213)
                    v216 = 43;
                  v211(3, "%c[%{public}s %{public}s]:%i Fail to select %{public}@, status=0x%hX", v216, v246, v240, 1139, v215, v234);

                }
                v217 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                v218 = NFSharedLogGetLogger(v217);
                v219 = objc_claimAutoreleasedReturnValue(v218);
                if (os_log_type_enabled(v219, OS_LOG_TYPE_ERROR))
                {
                  v220 = object_getClass(*(id *)(a1 + 32));
                  if (class_isMetaClass(v220))
                    v221 = 43;
                  else
                    v221 = 45;
                  v247 = object_getClassName(*(id *)(a1 + 32));
                  v222 = sel_getName(*(SEL *)(a1 + 64));
                  v223 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "AIDAllowList"));
                  v224 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v223, "firstObject"));
                  v225 = -[NSMutableArray status](v81, "status");
                  buf = 67110402;
                  v264 = v221;
                  v265 = 2082;
                  v266 = v247;
                  v267 = 2082;
                  v268 = v222;
                  v269 = 1024;
                  v270 = 1139;
                  v271 = 2114;
                  v272 = v224;
                  v273 = 1024;
                  v274 = v225;
                  _os_log_impl((void *)&_mh_execute_header, v219, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Fail to select %{public}@, status=0x%hX", (uint8_t *)&buf, 0x32u);

                }
                v239 = *(_QWORD *)(a1 + 56);
                v226 = objc_alloc((Class)NSError);
                v98 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
                v261[0] = NSLocalizedDescriptionKey;
                v245 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Not found"));
                v262[0] = v245;
                v262[1] = &off_1002FFE88;
                v261[1] = CFSTR("Line");
                v261[2] = CFSTR("Method");
                v203 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 64)));
                v262[2] = v203;
                v261[3] = NSDebugDescriptionErrorKey;
                v204 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 64)), 1140);
                v262[3] = v204;
                v205 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v262, v261, 4));
                v206 = v226;
                v208 = v98;
                v207 = 65;
                goto LABEL_147;
              }

              v71 = v250;
            }
          }
          v81 = objc_opt_new(NSMutableArray);
          v251 = 0;
          v172 = sub_10015BEE4(*(void **)(a1 + 32), v71, *(void **)(a1 + 40), v81, &v253, &v254, &v251);
          v173 = (void *)objc_claimAutoreleasedReturnValue(v172);
          v174 = v173;
          if ((!v173 || objc_msgSend(v173, "code") == (id)66) && !-[NSMutableArray count](v81, "count"))
          {
            v244 = v174;
            v185 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v186 = NFLogGetLogger(v185);
            if (v186)
            {
              v187 = (void (*)(uint64_t, const char *, ...))v186;
              v188 = object_getClass(*(id *)(a1 + 32));
              v189 = class_isMetaClass(v188);
              v190 = object_getClassName(*(id *)(a1 + 32));
              v233 = sel_getName(*(SEL *)(a1 + 64));
              v191 = 45;
              if (v189)
                v191 = 43;
              v187(3, "%c[%{public}s %{public}s]:%i No response from SE", v191, v190, v233, 1165);
            }
            v192 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v193 = NFSharedLogGetLogger(v192);
            v194 = objc_claimAutoreleasedReturnValue(v193);
            if (os_log_type_enabled(v194, OS_LOG_TYPE_ERROR))
            {
              v195 = object_getClass(*(id *)(a1 + 32));
              if (class_isMetaClass(v195))
                v196 = 43;
              else
                v196 = 45;
              v197 = object_getClassName(*(id *)(a1 + 32));
              v198 = sel_getName(*(SEL *)(a1 + 64));
              buf = 67109890;
              v264 = v196;
              v265 = 2082;
              v266 = v197;
              v267 = 2082;
              v268 = v198;
              v269 = 1024;
              v270 = 1165;
              _os_log_impl((void *)&_mh_execute_header, v194, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i No response from SE", (uint8_t *)&buf, 0x22u);
            }

            v199 = objc_alloc((Class)NSError);
            v200 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
            v257 = NSLocalizedDescriptionKey;
            v201 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Empty response"));
            v258 = v201;
            v202 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v258, &v257, 1));
            v82 = objc_msgSend(v199, "initWithDomain:code:userInfo:", v200, 66, v202);

            (*(void (**)(double))(*(_QWORD *)(a1 + 56) + 16))((double)v254 / 1000.0);
            goto LABEL_104;
          }
          v175 = v174;
          if (-[NSMutableArray count](v81, "count")
            && (objc_msgSend(*(id *)(a1 + 40), "disableCompletionNotification") & 1) == 0)
          {
            *(_BYTE *)(*(_QWORD *)(a1 + 32) + 161) = 1;
          }
          v176 = objc_alloc((Class)NSMutableDictionary);
          v255[0] = CFSTR("kBatchId");
          v255[1] = CFSTR("kTaskId");
          v256[0] = v70;
          v256[1] = v249;
          v255[2] = CFSTR("kCommandsResponse");
          v255[3] = CFSTR("kVersion");
          v256[2] = v81;
          v256[3] = &off_1002FFEB8;
          v177 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v256, v255, 4));
          v178 = objc_msgSend(v176, "initWithDictionary:", v177);

          if (objc_msgSend(*(id *)(a1 + 40), "includeAPDUDuration"))
          {
            v179 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v254));
            objc_msgSend(v178, "setObject:forKeyedSubscript:", v179, CFSTR("totalCommandResponseTimeInMS"));

          }
          v180 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "objectForKey:", CFSTR("targetSEID")));

          if (v180)
          {
            v181 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "seid"));
            v182 = CFSTR("targetSEID");
          }
          else
          {
            v183 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "objectForKey:", CFSTR("SEID")));

            if (!v183)
            {
LABEL_120:
              v184 = -[NSMutableArray count](v81, "count");
              if (v184 != objc_msgSend(v250, "count"))
                objc_msgSend(v178, "setValue:forKey:", &__kCFBooleanTrue, CFSTR("incompletedExecution"));
              if (v251)
                objc_msgSend(v178, "setValue:forKey:", &__kCFBooleanTrue, CFSTR("commandResponseFailureDetected"));
              (*(void (**)(double))(*(_QWORD *)(a1 + 56) + 16))((double)v254 / 1000.0);

              v82 = v175;
              goto LABEL_104;
            }
            v181 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "seid"));
            v182 = CFSTR("SEID");
          }
          objc_msgSend(v178, "setValue:forKey:", v181, v182);

          goto LABEL_120;
        }
      }
      v156 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v157 = NFLogGetLogger(v156);
      if (v157)
      {
        v158 = (void (*)(uint64_t, const char *, ...))v157;
        v159 = object_getClass(*(id *)(a1 + 32));
        v160 = class_isMetaClass(v159);
        v161 = object_getClassName(*(id *)(a1 + 32));
        v232 = sel_getName(*(SEL *)(a1 + 64));
        v162 = 45;
        if (v160)
          v162 = 43;
        v158(3, "%c[%{public}s %{public}s]:%i Invalid task ID", v162, v161, v232, 1131);
      }
      v163 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v164 = NFSharedLogGetLogger(v163);
      v165 = objc_claimAutoreleasedReturnValue(v164);
      if (os_log_type_enabled(v165, OS_LOG_TYPE_ERROR))
      {
        v166 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v166))
          v167 = 43;
        else
          v167 = 45;
        v168 = object_getClassName(*(id *)(a1 + 32));
        v169 = sel_getName(*(SEL *)(a1 + 64));
        buf = 67109890;
        v264 = v167;
        v265 = 2082;
        v266 = v168;
        v267 = 2082;
        v268 = v169;
        v269 = 1024;
        v270 = 1131;
        _os_log_impl((void *)&_mh_execute_header, v165, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid task ID", (uint8_t *)&buf, 0x22u);
      }

      v149 = *(_QWORD *)(a1 + 56);
      v150 = objc_alloc((Class)NSError);
      v81 = (NSMutableArray *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v275[0] = NSLocalizedDescriptionKey;
      v151 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Missing Parameter"));
      v276[0] = v151;
      v276[1] = &off_1002FFE70;
      v275[1] = CFSTR("Line");
      v275[2] = CFSTR("Method");
      v152 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 64)));
      v276[2] = v152;
      v275[3] = NSDebugDescriptionErrorKey;
      v153 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 64)), 1132);
      v276[3] = v153;
      v154 = v276;
      v155 = v275;
    }
    else
    {
      v135 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v136 = NFLogGetLogger(v135);
      if (v136)
      {
        v137 = (void (*)(uint64_t, const char *, ...))v136;
        v138 = object_getClass(*(id *)(a1 + 32));
        v139 = class_isMetaClass(v138);
        v140 = object_getClassName(*(id *)(a1 + 32));
        v231 = sel_getName(*(SEL *)(a1 + 64));
        v141 = 45;
        if (v139)
          v141 = 43;
        v137(3, "%c[%{public}s %{public}s]:%i Invalid commands", v141, v140, v231, 1125);
      }
      v142 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v143 = NFSharedLogGetLogger(v142);
      v144 = objc_claimAutoreleasedReturnValue(v143);
      if (os_log_type_enabled(v144, OS_LOG_TYPE_ERROR))
      {
        v145 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v145))
          v146 = 43;
        else
          v146 = 45;
        v147 = object_getClassName(*(id *)(a1 + 32));
        v148 = sel_getName(*(SEL *)(a1 + 64));
        buf = 67109890;
        v264 = v146;
        v265 = 2082;
        v266 = v147;
        v267 = 2082;
        v268 = v148;
        v269 = 1024;
        v270 = 1125;
        _os_log_impl((void *)&_mh_execute_header, v144, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid commands", (uint8_t *)&buf, 0x22u);
      }

      v149 = *(_QWORD *)(a1 + 56);
      v150 = objc_alloc((Class)NSError);
      v81 = (NSMutableArray *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v277[0] = NSLocalizedDescriptionKey;
      v151 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Missing Parameter"));
      v278[0] = v151;
      v278[1] = &off_1002FFE58;
      v277[1] = CFSTR("Line");
      v277[2] = CFSTR("Method");
      v152 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 64)));
      v278[2] = v152;
      v277[3] = NSDebugDescriptionErrorKey;
      v153 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 64)), 1126);
      v278[3] = v153;
      v154 = v278;
      v155 = v277;
    }
    v170 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v154, v155, 4));
    v171 = objc_msgSend(v150, "initWithDomain:code:userInfo:", v81, 9, v170);
    (*(void (**)(uint64_t, _QWORD, uint64_t, id, double))(v149 + 16))(v149, 0, -1, v171, 0.0);

    v82 = 0;
LABEL_103:
    v70 = v248;
LABEL_104:

    goto LABEL_24;
  }
  v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v20 = NFLogGetLogger(v19);
  if (v20)
  {
    v21 = (void (*)(uint64_t, const char *, ...))v20;
    v22 = object_getClass(*(id *)(a1 + 32));
    v23 = class_isMetaClass(v22);
    v24 = object_getClassName(*(id *)(a1 + 32));
    v25 = sel_getName(*(SEL *)(a1 + 64));
    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v27 = 45;
    if (v23)
      v27 = 43;
    v21(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v27, v24, v25, 1085, v26);

  }
  v28 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v29 = NFSharedLogGetLogger(v28);
  v30 = objc_claimAutoreleasedReturnValue(v29);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
  {
    v31 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v31))
      v32 = 43;
    else
      v32 = 45;
    v33 = object_getClassName(*(id *)(a1 + 32));
    v34 = sel_getName(*(SEL *)(a1 + 64));
    v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    buf = 67110146;
    v264 = v32;
    v265 = 2082;
    v266 = v33;
    v267 = 2082;
    v268 = v34;
    v269 = 1024;
    v270 = 1085;
    v271 = 2114;
    v272 = v35;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", (uint8_t *)&buf, 0x2Cu);

  }
  v36 = *(_QWORD *)(a1 + 56);
  if (v36)
  {
    v37 = objc_alloc((Class)NSError);
    v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v283 = NSLocalizedDescriptionKey;
    v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v284 = v39;
    v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v284, &v283, 1));
    v41 = objc_msgSend(v37, "initWithDomain:code:userInfo:", v38, 54, v40);
    (*(void (**)(uint64_t, _QWORD, uint64_t, id, double))(v36 + 16))(v36, 0, -1, v41, 0.0);

LABEL_24:
  }
}

void sub_10015F228(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  void *v19;
  uint64_t v20;
  void (*v21)(uint64_t, const char *, ...);
  objc_class *v22;
  _BOOL4 v23;
  const char *v24;
  const char *v25;
  void *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  NSObject *v30;
  objc_class *v31;
  int v32;
  const char *v33;
  const char *v34;
  void *v35;
  uint64_t v36;
  id v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  id v41;
  void *v42;
  void *v43;
  void *v44;
  unsigned __int8 v45;
  void *v46;
  void *v47;
  id v48;
  void *v49;
  id v50;
  void *v51;
  uint64_t v52;
  id v53;
  void *v54;
  id v55;
  void *v56;
  id v57;
  id v58;
  void *v59;
  id v60;
  id v61;
  void *v62;
  void *v63;
  id v64;
  uint64_t v65;
  uint64_t v66;
  _QWORD v67[5];
  _QWORD v68[5];
  NSErrorUserInfoKey v69;
  uint64_t v70;
  NSErrorUserInfoKey v71;
  uint64_t v72;
  uint8_t buf[4];
  int v74;
  __int16 v75;
  const char *v76;
  __int16 v77;
  const char *v78;
  __int16 v79;
  int v80;
  __int16 v81;
  void *v82;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v10 = 45;
    if (isMetaClass)
      v10 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@", v10, ClassName, Name, 1208, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 56));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    *(_DWORD *)buf = 67110146;
    v74 = v15;
    v75 = 2082;
    v76 = v16;
    v77 = 2082;
    v78 = v17;
    v79 = 1024;
    v80 = 1208;
    v81 = 2114;
    v82 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);

  }
  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "_getSecureElementWrapperForSEID:", *(_QWORD *)(a1 + 40)));
    if ((objc_msgSend(*(id *)(a1 + 32), "_activateSecureElementWrapper:", v38) & 1) != 0)
    {
      v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
      v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v42, "handle"));
      v44 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v43, "info"));
      v45 = objc_msgSend(v44, "restrictedMode");

      if ((v45 & 1) == 0)
      {
        v46 = (void *)objc_claimAutoreleasedReturnValue(+[_NFHardwareManager sharedHardwareManager](_NFHardwareManager, "sharedHardwareManager"));
        objc_msgSend(v46, "refreshSecureElementInfo");

      }
      v47 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
      v48 = sub_10022BED0(v47);
      v40 = objc_claimAutoreleasedReturnValue(v48);

      v49 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
      v50 = sub_1002390B4(v49);

      if (objc_msgSend(*(id *)(a1 + 32), "isDirty"))
      {
        v51 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
        v39 = objc_claimAutoreleasedReturnValue(objc_msgSend(v51, "refreshISDCounter"));

      }
      else
      {
        v39 = 0;
      }
      if (!(v40 | v39))
      {
        objc_msgSend(*(id *)(a1 + 32), "markAsDirty:", 0);
        (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
        v40 = 0;
        v39 = 0;
        goto LABEL_24;
      }
      if (v40)
        v56 = (void *)v40;
      else
        v56 = (void *)v39;
      v66 = *(_QWORD *)(a1 + 48);
      v57 = v56;
      v58 = objc_alloc((Class)NSError);
      v65 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v67[0] = NSLocalizedDescriptionKey;
      v59 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Commmand Error"));
      v68[0] = v59;
      v68[1] = v57;
      v67[1] = NSUnderlyingErrorKey;
      v67[2] = CFSTR("Line");
      v68[2] = &off_1002FFED0;
      v67[3] = CFSTR("Method");
      v60 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
      v68[3] = v60;
      v67[4] = NSDebugDescriptionErrorKey;
      v61 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 1238);
      v68[4] = v61;
      v62 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v68, v67, 5));
      v63 = v58;
      v54 = (void *)v65;
      v64 = objc_msgSend(v63, "initWithDomain:code:userInfo:", v65, 16, v62);
      (*(void (**)(uint64_t, id))(v66 + 16))(v66, v64);

    }
    else
    {
      v52 = *(_QWORD *)(a1 + 48);
      v53 = objc_alloc((Class)NSError);
      v39 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v69 = NSLocalizedDescriptionKey;
      v40 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
      v70 = v40;
      v54 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v70, &v69, 1));
      v55 = objc_msgSend(v53, "initWithDomain:code:userInfo:", v39, 15, v54);
      (*(void (**)(uint64_t, id))(v52 + 16))(v52, v55);

    }
    goto LABEL_24;
  }
  v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v20 = NFLogGetLogger(v19);
  if (v20)
  {
    v21 = (void (*)(uint64_t, const char *, ...))v20;
    v22 = object_getClass(*(id *)(a1 + 32));
    v23 = class_isMetaClass(v22);
    v24 = object_getClassName(*(id *)(a1 + 32));
    v25 = sel_getName(*(SEL *)(a1 + 56));
    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v27 = 45;
    if (v23)
      v27 = 43;
    v21(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v27, v24, v25, 1210, v26);

  }
  v28 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v29 = NFSharedLogGetLogger(v28);
  v30 = objc_claimAutoreleasedReturnValue(v29);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
  {
    v31 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v31))
      v32 = 43;
    else
      v32 = 45;
    v33 = object_getClassName(*(id *)(a1 + 32));
    v34 = sel_getName(*(SEL *)(a1 + 56));
    v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v74 = v32;
    v75 = 2082;
    v76 = v33;
    v77 = 2082;
    v78 = v34;
    v79 = 1024;
    v80 = 1210;
    v81 = 2114;
    v82 = v35;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v36 = *(_QWORD *)(a1 + 48);
  if (v36)
  {
    v37 = objc_alloc((Class)NSError);
    v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v71 = NSLocalizedDescriptionKey;
    v39 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v72 = v39;
    v40 = objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v72, &v71, 1));
    v41 = objc_msgSend(v37, "initWithDomain:code:userInfo:", v38, 54, v40);
    (*(void (**)(uint64_t, id))(v36 + 16))(v36, v41);

LABEL_24:
  }
}

void sub_10015FA24(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  void *v19;
  uint64_t v20;
  void (*v21)(uint64_t, const char *, ...);
  objc_class *v22;
  _BOOL4 v23;
  const char *v24;
  const char *v25;
  void *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  NSObject *v30;
  objc_class *v31;
  int v32;
  const char *v33;
  const char *v34;
  void *v35;
  uint64_t v36;
  id v37;
  void *v38;
  void *v39;
  void *v40;
  id v41;
  uint64_t v42;
  void *v43;
  unsigned int v44;
  uint64_t v45;
  uint64_t v46;
  id v47;
  void *v48;
  void *v49;
  void *v50;
  uint64_t v51;
  id v52;
  id v53;
  id v54;
  void *v55;
  void *v56;
  NSErrorUserInfoKey v57;
  void *v58;
  NSErrorUserInfoKey v59;
  void *v60;
  NSErrorUserInfoKey v61;
  void *v62;
  NSErrorUserInfoKey v63;
  void *v64;
  uint8_t buf[4];
  int v66;
  __int16 v67;
  const char *v68;
  __int16 v69;
  const char *v70;
  __int16 v71;
  int v72;
  __int16 v73;
  void *v74;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v10 = 45;
    if (isMetaClass)
      v10 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@", v10, ClassName, Name, 1247, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 48));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    *(_DWORD *)buf = 67110146;
    v66 = v15;
    v67 = 2082;
    v68 = v16;
    v69 = 2082;
    v70 = v17;
    v71 = 1024;
    v72 = 1247;
    v73 = 2114;
    v74 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);

  }
  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    if (objc_msgSend(*(id *)(a1 + 32), "uid"))
      v42 = (uint64_t)objc_msgSend(*(id *)(a1 + 32), "uid");
    else
      v42 = 0xFFFFFFFFLL;
    v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
    v44 = sub_1001E5098(v43, v42);

    switch(v44)
    {
      case 0x18u:
        v46 = *(_QWORD *)(a1 + 40);
        v47 = objc_alloc((Class)NSError);
        v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v59 = NSLocalizedDescriptionKey;
        v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Restricted Mode"));
        v60 = v39;
        v48 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v60, &v59, 1));
        v49 = v47;
        v50 = v38;
        v51 = 24;
        break;
      case 8u:
        v46 = *(_QWORD *)(a1 + 40);
        v52 = objc_alloc((Class)NSError);
        v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v61 = NSLocalizedDescriptionKey;
        v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Security Not Initialized"));
        v62 = v39;
        v48 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v62, &v61, 1));
        v49 = v52;
        v50 = v38;
        v51 = 27;
        break;
      case 0u:
        v45 = *(_QWORD *)(a1 + 40);
        v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
        (*(void (**)(uint64_t, _QWORD, _QWORD, id))(v45 + 16))(v45, 0, 0, objc_msgSend(v38, "getPairingVersion"));
        goto LABEL_25;
      default:
        v46 = *(_QWORD *)(a1 + 40);
        v53 = objc_alloc((Class)NSError);
        v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v57 = NSLocalizedDescriptionKey;
        v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unknown Error"));
        v58 = v39;
        v48 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v58, &v57, 1));
        v49 = v53;
        v50 = v38;
        v51 = 6;
        break;
    }
    v54 = objc_msgSend(v49, "initWithDomain:code:userInfo:", v50, v51, v48);
    v55 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
    v56 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v55, "serialNumber"));
    (*(void (**)(uint64_t, id, void *, _QWORD))(v46 + 16))(v46, v54, v56, 0);

LABEL_24:
LABEL_25:

    return;
  }
  v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v20 = NFLogGetLogger(v19);
  if (v20)
  {
    v21 = (void (*)(uint64_t, const char *, ...))v20;
    v22 = object_getClass(*(id *)(a1 + 32));
    v23 = class_isMetaClass(v22);
    v24 = object_getClassName(*(id *)(a1 + 32));
    v25 = sel_getName(*(SEL *)(a1 + 48));
    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v27 = 45;
    if (v23)
      v27 = 43;
    v21(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v27, v24, v25, 1249, v26);

  }
  v28 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v29 = NFSharedLogGetLogger(v28);
  v30 = objc_claimAutoreleasedReturnValue(v29);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
  {
    v31 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v31))
      v32 = 43;
    else
      v32 = 45;
    v33 = object_getClassName(*(id *)(a1 + 32));
    v34 = sel_getName(*(SEL *)(a1 + 48));
    v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v66 = v32;
    v67 = 2082;
    v68 = v33;
    v69 = 2082;
    v70 = v34;
    v71 = 1024;
    v72 = 1249;
    v73 = 2114;
    v74 = v35;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v36 = *(_QWORD *)(a1 + 40);
  if (v36)
  {
    v37 = objc_alloc((Class)NSError);
    v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v63 = NSLocalizedDescriptionKey;
    v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v64 = v39;
    v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v64, &v63, 1));
    v41 = objc_msgSend(v37, "initWithDomain:code:userInfo:", v38, 54, v40);
    (*(void (**)(uint64_t, id, _QWORD, _QWORD))(v36 + 16))(v36, v41, 0, 0);

    goto LABEL_24;
  }
}

void sub_10016016C(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  uint64_t v19;
  id v20;
  void *v21;
  void *v22;
  void *v23;
  id v24;
  uint64_t v25;
  void *v26;
  void *v27;
  id v28;
  NSErrorUserInfoKey v29;
  void *v30;
  uint8_t buf[4];
  int v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  int v38;
  __int16 v39;
  void *v40;

  if (!objc_msgSend(*(id *)(a1 + 32), "didStart")
    || (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) != 0
    || objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      v10 = 45;
      if (isMetaClass)
        v10 = 43;
      v4(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v10, ClassName, Name, 1281, v9);

    }
    v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v12 = NFSharedLogGetLogger(v11);
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v14 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v14))
        v15 = 43;
      else
        v15 = 45;
      v16 = object_getClassName(*(id *)(a1 + 32));
      v17 = sel_getName(*(SEL *)(a1 + 56));
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      *(_DWORD *)buf = 67110146;
      v32 = v15;
      v33 = 2082;
      v34 = v16;
      v35 = 2082;
      v36 = v17;
      v37 = 1024;
      v38 = 1281;
      v39 = 2114;
      v40 = v18;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

    }
    v19 = *(_QWORD *)(a1 + 48);
    if (v19)
    {
      v20 = objc_alloc((Class)NSError);
      v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v29 = NSLocalizedDescriptionKey;
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
      v30 = v22;
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v30, &v29, 1));
      v24 = objc_msgSend(v20, "initWithDomain:code:userInfo:", v21, 54, v23);
      (*(void (**)(uint64_t, id))(v19 + 16))(v19, v24);

    }
  }
  else
  {
    v28 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "_getSecureElementWrapperForSEID:", *(_QWORD *)(a1 + 40)));
    v25 = *(_QWORD *)(a1 + 48);
    v26 = (void *)objc_claimAutoreleasedReturnValue(+[_NFHardwareManager sharedHardwareManager](_NFHardwareManager, "sharedHardwareManager"));
    v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v26, "secureElementDidExitRestrictedMode:os:", v28, 0));
    (*(void (**)(uint64_t, void *))(v25 + 16))(v25, v27);

  }
}

void sub_100160548(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  void *v19;
  uint64_t v20;
  void (*v21)(uint64_t, const char *, ...);
  objc_class *v22;
  _BOOL4 v23;
  const char *v24;
  const char *v25;
  void *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  NSObject *v30;
  objc_class *v31;
  int v32;
  const char *v33;
  const char *v34;
  void *v35;
  uint64_t v36;
  id v37;
  id v38;
  id v39;
  void *v40;
  void *v41;
  id v42;
  uint64_t v43;
  id v44;
  void *v45;
  void *v46;
  void *v47;
  unsigned int v48;
  void *v49;
  void *v50;
  void *v51;
  uint64_t v52;
  void (*v53)(uint64_t, const char *, ...);
  objc_class *v54;
  _BOOL4 v55;
  const char *v56;
  uint64_t v57;
  void *v58;
  uint64_t v59;
  NSObject *v60;
  objc_class *v61;
  int v62;
  const char *v63;
  const char *v64;
  uint64_t v65;
  id v66;
  void *v67;
  uint64_t v68;
  int v69;
  void *v70;
  void *v71;
  id v72;
  id v73;
  const char *v74;
  void *v75;
  void *v76;
  NSErrorUserInfoKey v77;
  void *v78;
  NSErrorUserInfoKey v79;
  id v80;
  NSErrorUserInfoKey v81;
  id v82;
  uint8_t buf[4];
  int v84;
  __int16 v85;
  const char *v86;
  __int16 v87;
  const char *v88;
  __int16 v89;
  int v90;
  __int16 v91;
  void *v92;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v10 = 45;
    if (isMetaClass)
      v10 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@", v10, ClassName, Name, 1293, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 48));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    *(_DWORD *)buf = 67110146;
    v84 = v15;
    v85 = 2082;
    v86 = v16;
    v87 = 2082;
    v88 = v17;
    v89 = 1024;
    v90 = 1293;
    v91 = 2114;
    v92 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);

  }
  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v45 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));

    if (v45)
    {
      v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
      v47 = v46;
      v75 = 0;
      v76 = 0;
      if (v46)
      {
        v48 = sub_1001E702C(v46, &v76, &v75);
        v50 = v75;
        v49 = v76;
      }
      else
      {
        v50 = 0;
        v49 = 0;
        v48 = 0;
      }
      v38 = v49;
      v39 = v50;

      if (v48)
      {
        v51 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v52 = NFLogGetLogger(v51);
        if (v52)
        {
          v53 = (void (*)(uint64_t, const char *, ...))v52;
          v54 = object_getClass(*(id *)(a1 + 32));
          v55 = class_isMetaClass(v54);
          v56 = object_getClassName(*(id *)(a1 + 32));
          v74 = sel_getName(*(SEL *)(a1 + 48));
          v57 = 45;
          if (v55)
            v57 = 43;
          v53(3, "%c[%{public}s %{public}s]:%i Failed to get cryptogram", v57, v56, v74, 1308);
        }
        v58 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v59 = NFSharedLogGetLogger(v58);
        v60 = objc_claimAutoreleasedReturnValue(v59);
        if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
        {
          v61 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v61))
            v62 = 43;
          else
            v62 = 45;
          v63 = object_getClassName(*(id *)(a1 + 32));
          v64 = sel_getName(*(SEL *)(a1 + 48));
          *(_DWORD *)buf = 67109890;
          v84 = v62;
          v85 = 2082;
          v86 = v63;
          v87 = 2082;
          v88 = v64;
          v89 = 1024;
          v90 = 1308;
          _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get cryptogram", buf, 0x22u);
        }

        v65 = *(_QWORD *)(a1 + 40);
        v66 = objc_alloc((Class)NSError);
        v67 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v68 = v48;
        v77 = NSLocalizedDescriptionKey;
        if (v48 >= 0x47)
          v69 = 71;
        else
          v69 = v48;
        v70 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E9508[v69]));
        v78 = v70;
        v71 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v78, &v77, 1));
        v72 = objc_msgSend(v66, "initWithDomain:code:userInfo:", v67, v68, v71);
        (*(void (**)(uint64_t, _QWORD, _QWORD, id))(v65 + 16))(v65, 0, 0, v72);

      }
      else
      {
        (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
      }
      goto LABEL_25;
    }
    v36 = *(_QWORD *)(a1 + 40);
    v73 = objc_alloc((Class)NSError);
    v38 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v79 = NSLocalizedDescriptionKey;
    v39 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
    v80 = v39;
    v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v80, &v79, 1));
    v41 = v73;
    v42 = v38;
    v43 = 15;
LABEL_24:
    v44 = objc_msgSend(v41, "initWithDomain:code:userInfo:", v42, v43, v40);
    (*(void (**)(uint64_t, _QWORD, _QWORD, id))(v36 + 16))(v36, 0, 0, v44);

LABEL_25:
    return;
  }
  v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v20 = NFLogGetLogger(v19);
  if (v20)
  {
    v21 = (void (*)(uint64_t, const char *, ...))v20;
    v22 = object_getClass(*(id *)(a1 + 32));
    v23 = class_isMetaClass(v22);
    v24 = object_getClassName(*(id *)(a1 + 32));
    v25 = sel_getName(*(SEL *)(a1 + 48));
    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v27 = 45;
    if (v23)
      v27 = 43;
    v21(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v27, v24, v25, 1295, v26);

  }
  v28 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v29 = NFSharedLogGetLogger(v28);
  v30 = objc_claimAutoreleasedReturnValue(v29);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
  {
    v31 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v31))
      v32 = 43;
    else
      v32 = 45;
    v33 = object_getClassName(*(id *)(a1 + 32));
    v34 = sel_getName(*(SEL *)(a1 + 48));
    v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v84 = v32;
    v85 = 2082;
    v86 = v33;
    v87 = 2082;
    v88 = v34;
    v89 = 1024;
    v90 = 1295;
    v91 = 2114;
    v92 = v35;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v36 = *(_QWORD *)(a1 + 40);
  if (v36)
  {
    v37 = objc_alloc((Class)NSError);
    v38 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v81 = NSLocalizedDescriptionKey;
    v39 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v82 = v39;
    v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v82, &v81, 1));
    v41 = v37;
    v42 = v38;
    v43 = 54;
    goto LABEL_24;
  }
}

void sub_100160D78(uint64_t a1)
{
  id v2;
  void *specific;
  uint64_t Logger;
  void (*v5)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  objc_class *v15;
  int v16;
  const char *v17;
  const char *v18;
  void *v19;
  uint64_t v20;
  id v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  uint64_t v27;
  id v28;
  uint64_t v29;
  NSObject *v30;
  void *v31;
  void *v32;
  uint64_t v33;
  void (*v34)(uint64_t, const char *, ...);
  objc_class *v35;
  _BOOL4 v36;
  const char *v37;
  const char *v38;
  void *v39;
  uint64_t v40;
  void *v41;
  uint64_t v42;
  NSObject *v43;
  objc_class *v44;
  int v45;
  const char *v46;
  const char *v47;
  void *v48;
  void *v49;
  id v50;
  uint64_t v51;
  uint64_t v52;
  NSObject *v53;
  objc_class *v54;
  _BOOL4 v55;
  const char *v56;
  uint64_t v57;
  void *v58;
  uint64_t v59;
  NSObject *v60;
  objc_class *v61;
  int v62;
  const char *v63;
  const char *v64;
  uint64_t v65;
  uint64_t v66;
  NSObject *v67;
  id v68;
  const char *v69;
  NSErrorUserInfoKey v70;
  void *v71;
  NSErrorUserInfoKey v72;
  void *v73;
  uint8_t buf[4];
  int v75;
  __int16 v76;
  const char *v77;
  __int16 v78;
  const char *v79;
  __int16 v80;
  int v81;
  __int16 v82;
  void *v83;

  if (!objc_msgSend(*(id *)(a1 + 32), "didStart")
    || (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) != 0
    || (v2 = objc_msgSend(*(id *)(a1 + 32), "didEnd"), (_DWORD)v2))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      v11 = 45;
      if (isMetaClass)
        v11 = 43;
      v5(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v11, ClassName, Name, 1326, v10);

    }
    v12 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v13 = NFSharedLogGetLogger(v12);
    v14 = objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      v15 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v15))
        v16 = 43;
      else
        v16 = 45;
      v17 = object_getClassName(*(id *)(a1 + 32));
      v18 = sel_getName(*(SEL *)(a1 + 56));
      v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      *(_DWORD *)buf = 67110146;
      v75 = v16;
      v76 = 2082;
      v77 = v17;
      v78 = 2082;
      v79 = v18;
      v80 = 1024;
      v81 = 1326;
      v82 = 2114;
      v83 = v19;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

    }
    v20 = *(_QWORD *)(a1 + 48);
    if (v20)
    {
      v21 = objc_alloc((Class)NSError);
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v72 = NSLocalizedDescriptionKey;
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
      v73 = v23;
      v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v73, &v72, 1));
      v25 = v21;
      v26 = v22;
      v27 = 54;
LABEL_15:
      v28 = objc_msgSend(v25, "initWithDomain:code:userInfo:", v26, v27, v24);
      (*(void (**)(uint64_t, id))(v20 + 16))(v20, v28);

LABEL_16:
    }
  }
  else
  {
    v29 = NFSharedSignpostLog(v2);
    v30 = objc_claimAutoreleasedReturnValue(v29);
    if (os_signpost_enabled(v30))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v30, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SEMSession:setExpressPassConfig", "processing", buf, 2u);
    }

    v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "expressModeManager"));
    v32 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v33 = NFLogGetLogger(v32);
    v34 = (void (*)(uint64_t, const char *, ...))v33;
    if (v31)
    {
      if (v33)
      {
        v35 = object_getClass(*(id *)(a1 + 32));
        v36 = class_isMetaClass(v35);
        v37 = object_getClassName(*(id *)(a1 + 32));
        v38 = sel_getName(*(SEL *)(a1 + 56));
        v39 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
        v40 = 45;
        if (v36)
          v40 = 43;
        v34(6, "%c[%{public}s %{public}s]:%i %{public}@", v40, v37, v38, 1339, v39);

      }
      v41 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v42 = NFSharedLogGetLogger(v41);
      v43 = objc_claimAutoreleasedReturnValue(v42);
      if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        v44 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v44))
          v45 = 43;
        else
          v45 = 45;
        v46 = object_getClassName(*(id *)(a1 + 32));
        v47 = sel_getName(*(SEL *)(a1 + 56));
        v48 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
        *(_DWORD *)buf = 67110146;
        v75 = v45;
        v76 = 2082;
        v77 = v46;
        v78 = 2082;
        v79 = v47;
        v80 = 1024;
        v81 = 1339;
        v82 = 2114;
        v83 = v48;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);

      }
      v49 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "expressModeManager"));
      v50 = sub_100040810((uint64_t)v49, *(void **)(a1 + 40), *(unsigned __int8 *)(a1 + 64), 1);
      v22 = (void *)objc_claimAutoreleasedReturnValue(v50);

      v52 = NFSharedSignpostLog(v51);
      v53 = objc_claimAutoreleasedReturnValue(v52);
      if (os_signpost_enabled(v53))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v53, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:setExpressPassConfig", "user callback", buf, 2u);
      }

      (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
      goto LABEL_16;
    }
    if (v33)
    {
      v54 = object_getClass(*(id *)(a1 + 32));
      v55 = class_isMetaClass(v54);
      v56 = object_getClassName(*(id *)(a1 + 32));
      v69 = sel_getName(*(SEL *)(a1 + 56));
      v57 = 45;
      if (v55)
        v57 = 43;
      v34(3, "%c[%{public}s %{public}s]:%i EMM is nil!", v57, v56, v69, 1331);
    }
    v58 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v59 = NFSharedLogGetLogger(v58);
    v60 = objc_claimAutoreleasedReturnValue(v59);
    if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
    {
      v61 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v61))
        v62 = 43;
      else
        v62 = 45;
      v63 = object_getClassName(*(id *)(a1 + 32));
      v64 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)buf = 67109890;
      v75 = v62;
      v76 = 2082;
      v77 = v63;
      v78 = 2082;
      v79 = v64;
      v80 = 1024;
      v81 = 1331;
      _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i EMM is nil!", buf, 0x22u);
    }

    if (*(_QWORD *)(a1 + 48))
    {
      v66 = NFSharedSignpostLog(v65);
      v67 = objc_claimAutoreleasedReturnValue(v66);
      if (os_signpost_enabled(v67))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v67, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:setExpressPassConfig", "failure", buf, 2u);
      }

      v20 = *(_QWORD *)(a1 + 48);
      v68 = objc_alloc((Class)NSError);
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v70 = NSLocalizedDescriptionKey;
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid State"));
      v71 = v23;
      v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v71, &v70, 1));
      v25 = v68;
      v26 = v22;
      v27 = 12;
      goto LABEL_15;
    }
  }
}

void sub_100161508(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  void *v19;
  uint64_t v20;
  void (*v21)(uint64_t, const char *, ...);
  objc_class *v22;
  _BOOL4 v23;
  const char *v24;
  const char *v25;
  void *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  NSObject *v30;
  objc_class *v31;
  int v32;
  const char *v33;
  const char *v34;
  void *v35;
  uint64_t v36;
  id v37;
  id v38;
  void *v39;
  void *v40;
  id v41;
  void *v42;
  _QWORD *v43;
  _QWORD *v44;
  id v45;
  void *v46;
  void *v47;
  id v48;
  id v49;
  id v50;
  void *v51;
  _QWORD v52[5];
  _QWORD v53[5];
  NSErrorUserInfoKey v54;
  void *v55;
  uint8_t buf[4];
  int v57;
  __int16 v58;
  const char *v59;
  __int16 v60;
  const char *v61;
  __int16 v62;
  int v63;
  __int16 v64;
  void *v65;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v10 = 45;
    if (isMetaClass)
      v10 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@", v10, ClassName, Name, 1351, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 48));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    *(_DWORD *)buf = 67110146;
    v57 = v15;
    v58 = 2082;
    v59 = v16;
    v60 = 2082;
    v61 = v17;
    v62 = 1024;
    v63 = 1351;
    v64 = 2114;
    v65 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);

  }
  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "expressModeManager"));

    if (v42)
    {
      v43 = (_QWORD *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "expressModeManager"));
      v44 = sub_1000412C0(v43);
      v38 = (id)objc_claimAutoreleasedReturnValue(v44);

    }
    else
    {
      v45 = objc_alloc((Class)NSError);
      v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v52[0] = NSLocalizedDescriptionKey;
      v47 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Feature Not Supported"));
      v53[0] = v47;
      v53[1] = &off_1002FFEE8;
      v52[1] = CFSTR("Line");
      v52[2] = CFSTR("Method");
      v48 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 48)));
      v53[2] = v48;
      v52[3] = NSDebugDescriptionErrorKey;
      v49 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 48)), 1357);
      v53[3] = v49;
      v52[4] = NSLocalizedFailureReasonErrorKey;
      v50 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("EMM not initialized"));
      v53[4] = v50;
      v51 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v53, v52, 5));
      v38 = objc_msgSend(v45, "initWithDomain:code:userInfo:", v46, 14, v51);

    }
    (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
    goto LABEL_24;
  }
  v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v20 = NFLogGetLogger(v19);
  if (v20)
  {
    v21 = (void (*)(uint64_t, const char *, ...))v20;
    v22 = object_getClass(*(id *)(a1 + 32));
    v23 = class_isMetaClass(v22);
    v24 = object_getClassName(*(id *)(a1 + 32));
    v25 = sel_getName(*(SEL *)(a1 + 48));
    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v27 = 45;
    if (v23)
      v27 = 43;
    v21(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v27, v24, v25, 1353, v26);

  }
  v28 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v29 = NFSharedLogGetLogger(v28);
  v30 = objc_claimAutoreleasedReturnValue(v29);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
  {
    v31 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v31))
      v32 = 43;
    else
      v32 = 45;
    v33 = object_getClassName(*(id *)(a1 + 32));
    v34 = sel_getName(*(SEL *)(a1 + 48));
    v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v57 = v32;
    v58 = 2082;
    v59 = v33;
    v60 = 2082;
    v61 = v34;
    v62 = 1024;
    v63 = 1353;
    v64 = 2114;
    v65 = v35;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v36 = *(_QWORD *)(a1 + 40);
  if (v36)
  {
    v37 = objc_alloc((Class)NSError);
    v38 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v54 = NSLocalizedDescriptionKey;
    v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v55 = v39;
    v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v55, &v54, 1));
    v41 = objc_msgSend(v37, "initWithDomain:code:userInfo:", v38, 54, v40);
    (*(void (**)(uint64_t, _QWORD, id))(v36 + 16))(v36, 0, v41);

LABEL_24:
  }
}

void sub_100161BE0(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  id v19;
  void *v20;
  uint64_t v21;
  void (*v22)(uint64_t, const char *, ...);
  objc_class *v23;
  _BOOL4 v24;
  const char *v25;
  const char *v26;
  void *v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  NSObject *v31;
  objc_class *v32;
  int v33;
  const char *v34;
  const char *v35;
  void *v36;
  uint64_t v37;
  id v38;
  void *v39;
  void *v40;
  void *v41;
  id v42;
  uint64_t v43;
  NSObject *v44;
  void *v45;
  void *v46;
  void *v47;
  unsigned int v48;
  void *v49;
  uint64_t v50;
  void (*v51)(uint64_t, const char *, ...);
  objc_class *v52;
  _BOOL4 v53;
  const char *v54;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  NSObject *v58;
  objc_class *v59;
  int v60;
  const char *v61;
  const char *v62;
  uint64_t v63;
  uint64_t v64;
  NSObject *v65;
  uint64_t v66;
  id v67;
  void *v68;
  void *v69;
  void *v70;
  void *v71;
  void *v72;
  uint64_t v73;
  void *v74;
  id v75;
  void *v76;
  void *v77;
  uint64_t v78;
  void (*v79)(uint64_t, const char *, ...);
  objc_class *v80;
  _BOOL4 v81;
  const char *v82;
  const char *v83;
  uint64_t v84;
  void *v85;
  uint64_t v86;
  NSObject *v87;
  objc_class *v88;
  int v89;
  const char *v90;
  const char *v91;
  void *v92;
  void *v93;
  id v94;
  uint64_t v95;
  uint64_t v96;
  NSObject *v97;
  objc_class *v98;
  _BOOL4 v99;
  const char *v100;
  uint64_t v101;
  void *v102;
  uint64_t v103;
  NSObject *v104;
  objc_class *v105;
  int v106;
  const char *v107;
  const char *v108;
  uint64_t v109;
  uint64_t v110;
  NSObject *v111;
  id v112;
  void *v113;
  uint64_t v114;
  void (*v115)(uint64_t, const char *, ...);
  objc_class *v116;
  _BOOL4 v117;
  const char *v118;
  uint64_t v119;
  void *v120;
  uint64_t v121;
  NSObject *v122;
  objc_class *v123;
  int v124;
  const char *v125;
  const char *v126;
  uint64_t v127;
  uint64_t v128;
  NSObject *v129;
  id v130;
  id v131;
  const char *v132;
  const char *v133;
  const char *v134;
  NSErrorUserInfoKey v135;
  void *v136;
  NSErrorUserInfoKey v137;
  void *v138;
  NSErrorUserInfoKey v139;
  void *v140;
  NSErrorUserInfoKey v141;
  void *v142;
  uint8_t buf[4];
  int v144;
  __int16 v145;
  const char *v146;
  __int16 v147;
  const char *v148;
  __int16 v149;
  int v150;
  __int16 v151;
  void *v152;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v10 = 45;
    if (isMetaClass)
      v10 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@", v10, ClassName, Name, 1371, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 48));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    *(_DWORD *)buf = 67110146;
    v144 = v15;
    v145 = 2082;
    v146 = v16;
    v147 = 2082;
    v148 = v17;
    v149 = 1024;
    v150 = 1371;
    v151 = 2114;
    v152 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);

  }
  if (!objc_msgSend(*(id *)(a1 + 32), "didStart")
    || (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) != 0
    || (v19 = objc_msgSend(*(id *)(a1 + 32), "didEnd"), (_DWORD)v19))
  {
    v20 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v21 = NFLogGetLogger(v20);
    if (v21)
    {
      v22 = (void (*)(uint64_t, const char *, ...))v21;
      v23 = object_getClass(*(id *)(a1 + 32));
      v24 = class_isMetaClass(v23);
      v25 = object_getClassName(*(id *)(a1 + 32));
      v26 = sel_getName(*(SEL *)(a1 + 48));
      v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      v28 = 45;
      if (v24)
        v28 = 43;
      v22(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v28, v25, v26, 1373, v27);

    }
    v29 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v30 = NFSharedLogGetLogger(v29);
    v31 = objc_claimAutoreleasedReturnValue(v30);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      v32 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v32))
        v33 = 43;
      else
        v33 = 45;
      v34 = object_getClassName(*(id *)(a1 + 32));
      v35 = sel_getName(*(SEL *)(a1 + 48));
      v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      *(_DWORD *)buf = 67110146;
      v144 = v33;
      v145 = 2082;
      v146 = v34;
      v147 = 2082;
      v148 = v35;
      v149 = 1024;
      v150 = 1373;
      v151 = 2114;
      v152 = v36;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

    }
    v37 = *(_QWORD *)(a1 + 40);
    if (v37)
    {
      v38 = objc_alloc((Class)NSError);
      v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v141 = NSLocalizedDescriptionKey;
      v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
      v142 = v40;
      v41 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v142, &v141, 1));
      v42 = objc_msgSend(v38, "initWithDomain:code:userInfo:", v39, 54, v41);
      (*(void (**)(uint64_t, id))(v37 + 16))(v37, v42);

    }
    return;
  }
  v43 = NFSharedSignpostLog(v19);
  v44 = objc_claimAutoreleasedReturnValue(v43);
  if (os_signpost_enabled(v44))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v44, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SEMSession:setExpressModesControlState", "processing", buf, 2u);
  }

  if (*(_QWORD *)(a1 + 56) == 1)
  {
    v45 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
    v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v45, "handle"));
    v47 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v46, "info"));
    v48 = objc_msgSend(v47, "restrictedMode");

    if (v48)
    {
      v49 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v50 = NFLogGetLogger(v49);
      if (v50)
      {
        v51 = (void (*)(uint64_t, const char *, ...))v50;
        v52 = object_getClass(*(id *)(a1 + 32));
        v53 = class_isMetaClass(v52);
        v54 = object_getClassName(*(id *)(a1 + 32));
        v132 = sel_getName(*(SEL *)(a1 + 48));
        v55 = 45;
        if (v53)
          v55 = 43;
        v51(3, "%c[%{public}s %{public}s]:%i SE in restricted mode", v55, v54, v132, 1380);
      }
      v56 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v57 = NFSharedLogGetLogger(v56);
      v58 = objc_claimAutoreleasedReturnValue(v57);
      if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
      {
        v59 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v59))
          v60 = 43;
        else
          v60 = 45;
        v61 = object_getClassName(*(id *)(a1 + 32));
        v62 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)buf = 67109890;
        v144 = v60;
        v145 = 2082;
        v146 = v61;
        v147 = 2082;
        v148 = v62;
        v149 = 1024;
        v150 = 1380;
        _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i SE in restricted mode", buf, 0x22u);
      }

      if (*(_QWORD *)(a1 + 40))
      {
        v64 = NFSharedSignpostLog(v63);
        v65 = objc_claimAutoreleasedReturnValue(v64);
        if (os_signpost_enabled(v65))
        {
          *(_WORD *)buf = 0;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v65, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:setExpressModesControlState", "failure", buf, 2u);
        }

        v66 = *(_QWORD *)(a1 + 40);
        v67 = objc_alloc((Class)NSError);
        v68 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v139 = NSLocalizedDescriptionKey;
        v69 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Restricted Mode"));
        v140 = v69;
        v70 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v140, &v139, 1));
        v71 = v67;
        v72 = v68;
        v73 = 24;
LABEL_82:
        v131 = objc_msgSend(v71, "initWithDomain:code:userInfo:", v72, v73, v70);
        (*(void (**)(uint64_t, id))(v66 + 16))(v66, v131);

        return;
      }
      return;
    }
    v74 = (void *)objc_claimAutoreleasedReturnValue(+[_NFHardwareManager sharedHardwareManager](_NFHardwareManager, "sharedHardwareManager"));
    v75 = objc_msgSend(v74, "nfcRadioEnabled:showUIPopup:", 0, 0);

    if (!v75)
    {
      v113 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v114 = NFLogGetLogger(v113);
      if (v114)
      {
        v115 = (void (*)(uint64_t, const char *, ...))v114;
        v116 = object_getClass(*(id *)(a1 + 32));
        v117 = class_isMetaClass(v116);
        v118 = object_getClassName(*(id *)(a1 + 32));
        v134 = sel_getName(*(SEL *)(a1 + 48));
        v119 = 45;
        if (v117)
          v119 = 43;
        v115(6, "%c[%{public}s %{public}s]:%i NFC radio disabled", v119, v118, v134, 1389);
      }
      v120 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v121 = NFSharedLogGetLogger(v120);
      v122 = objc_claimAutoreleasedReturnValue(v121);
      if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT))
      {
        v123 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v123))
          v124 = 43;
        else
          v124 = 45;
        v125 = object_getClassName(*(id *)(a1 + 32));
        v126 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)buf = 67109890;
        v144 = v124;
        v145 = 2082;
        v146 = v125;
        v147 = 2082;
        v148 = v126;
        v149 = 1024;
        v150 = 1389;
        _os_log_impl((void *)&_mh_execute_header, v122, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i NFC radio disabled", buf, 0x22u);
      }

      if (*(_QWORD *)(a1 + 40))
      {
        v128 = NFSharedSignpostLog(v127);
        v129 = objc_claimAutoreleasedReturnValue(v128);
        if (os_signpost_enabled(v129))
        {
          *(_WORD *)buf = 0;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v129, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:setExpressModesControlState", "failure", buf, 2u);
        }

        v66 = *(_QWORD *)(a1 + 40);
        v130 = objc_alloc((Class)NSError);
        v68 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v137 = NSLocalizedDescriptionKey;
        v69 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "NFC radio disabled"));
        v138 = v69;
        v70 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v138, &v137, 1));
        v71 = v130;
        v72 = v68;
        v73 = 50;
        goto LABEL_82;
      }
      return;
    }
  }
  v76 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "expressModeManager"));

  v77 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v78 = NFLogGetLogger(v77);
  v79 = (void (*)(uint64_t, const char *, ...))v78;
  if (v76)
  {
    if (v78)
    {
      v80 = object_getClass(*(id *)(a1 + 32));
      v81 = class_isMetaClass(v80);
      v82 = object_getClassName(*(id *)(a1 + 32));
      v83 = sel_getName(*(SEL *)(a1 + 48));
      v84 = 45;
      if (v81)
        v84 = 43;
      v79(6, "%c[%{public}s %{public}s]:%i state=%ld", v84, v82, v83, 1407, *(_QWORD *)(a1 + 56));
    }
    v85 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v86 = NFSharedLogGetLogger(v85);
    v87 = objc_claimAutoreleasedReturnValue(v86);
    if (os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT))
    {
      v88 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v88))
        v89 = 43;
      else
        v89 = 45;
      v90 = object_getClassName(*(id *)(a1 + 32));
      v91 = sel_getName(*(SEL *)(a1 + 48));
      v92 = *(void **)(a1 + 56);
      *(_DWORD *)buf = 67110146;
      v144 = v89;
      v145 = 2082;
      v146 = v90;
      v147 = 2082;
      v148 = v91;
      v149 = 1024;
      v150 = 1407;
      v151 = 2048;
      v152 = v92;
      _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i state=%ld", buf, 0x2Cu);
    }

    v93 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "expressModeManager"));
    v94 = sub_10003F7D8((uint64_t)v93, *(_QWORD *)(a1 + 56));

    v96 = NFSharedSignpostLog(v95);
    v97 = objc_claimAutoreleasedReturnValue(v96);
    if (os_signpost_enabled(v97))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v97, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:setExpressModesControlState", "user callback", buf, 2u);
    }

    (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
  }
  else
  {
    if (v78)
    {
      v98 = object_getClass(*(id *)(a1 + 32));
      v99 = class_isMetaClass(v98);
      v100 = object_getClassName(*(id *)(a1 + 32));
      v133 = sel_getName(*(SEL *)(a1 + 48));
      v101 = 45;
      if (v99)
        v101 = 43;
      v79(3, "%c[%{public}s %{public}s]:%i EMM is nil!", v101, v100, v133, 1399);
    }
    v102 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v103 = NFSharedLogGetLogger(v102);
    v104 = objc_claimAutoreleasedReturnValue(v103);
    if (os_log_type_enabled(v104, OS_LOG_TYPE_ERROR))
    {
      v105 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v105))
        v106 = 43;
      else
        v106 = 45;
      v107 = object_getClassName(*(id *)(a1 + 32));
      v108 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)buf = 67109890;
      v144 = v106;
      v145 = 2082;
      v146 = v107;
      v147 = 2082;
      v148 = v108;
      v149 = 1024;
      v150 = 1399;
      _os_log_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i EMM is nil!", buf, 0x22u);
    }

    if (*(_QWORD *)(a1 + 40))
    {
      v110 = NFSharedSignpostLog(v109);
      v111 = objc_claimAutoreleasedReturnValue(v110);
      if (os_signpost_enabled(v111))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v111, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:setExpressModesControlState", "failure", buf, 2u);
      }

      v66 = *(_QWORD *)(a1 + 40);
      v112 = objc_alloc((Class)NSError);
      v68 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v135 = NSLocalizedDescriptionKey;
      v69 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid State"));
      v136 = v69;
      v70 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v136, &v135, 1));
      v71 = v112;
      v72 = v68;
      v73 = 12;
      goto LABEL_82;
    }
  }
}

void sub_100162998(uint64_t a1)
{
  id v2;
  void *specific;
  uint64_t Logger;
  void (*v5)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  objc_class *v15;
  int v16;
  const char *v17;
  const char *v18;
  void *v19;
  uint64_t v20;
  id v21;
  void *v22;
  void *v23;
  void *v24;
  id v25;
  uint64_t v26;
  NSObject *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void (*v31)(uint64_t, const char *, ...);
  objc_class *v32;
  _BOOL4 v33;
  const char *v34;
  const char *v35;
  uint64_t v36;
  void *v37;
  uint64_t v38;
  NSObject *v39;
  objc_class *v40;
  int v41;
  const char *v42;
  const char *v43;
  void *v44;
  _QWORD *v45;
  unsigned int v46;
  uint64_t v47;
  void *v48;
  uint64_t v49;
  void (*v50)(uint64_t, const char *, ...);
  objc_class *v51;
  _BOOL4 v52;
  const char *v53;
  uint64_t v54;
  void *v55;
  uint64_t v56;
  NSObject *v57;
  objc_class *v58;
  int v59;
  const char *v60;
  const char *v61;
  uint64_t v62;
  uint64_t v63;
  NSObject *v64;
  uint64_t v65;
  id v66;
  void *v67;
  uint64_t v68;
  int v69;
  void *v70;
  void *v71;
  id v72;
  objc_class *v73;
  _BOOL4 v74;
  const char *v75;
  uint64_t v76;
  void *v77;
  uint64_t v78;
  NSObject *v79;
  objc_class *v80;
  int v81;
  const char *v82;
  const char *v83;
  uint64_t v84;
  uint64_t v85;
  NSObject *v86;
  uint64_t v87;
  id v88;
  void *v89;
  void *v90;
  id v91;
  uint64_t v92;
  NSObject *v93;
  const char *v94;
  const char *v95;
  NSErrorUserInfoKey v96;
  void *v97;
  NSErrorUserInfoKey v98;
  void *v99;
  NSErrorUserInfoKey v100;
  void *v101;
  uint8_t buf[4];
  int v103;
  __int16 v104;
  const char *v105;
  __int16 v106;
  const char *v107;
  __int16 v108;
  int v109;
  __int16 v110;
  void *v111;

  if (!objc_msgSend(*(id *)(a1 + 32), "didStart")
    || (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) != 0
    || (v2 = objc_msgSend(*(id *)(a1 + 32), "didEnd"), (_DWORD)v2))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      v11 = 45;
      if (isMetaClass)
        v11 = 43;
      v5(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v11, ClassName, Name, 1419, v10);

    }
    v12 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v13 = NFSharedLogGetLogger(v12);
    v14 = objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      v15 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v15))
        v16 = 43;
      else
        v16 = 45;
      v17 = object_getClassName(*(id *)(a1 + 32));
      v18 = sel_getName(*(SEL *)(a1 + 56));
      v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      *(_DWORD *)buf = 67110146;
      v103 = v16;
      v104 = 2082;
      v105 = v17;
      v106 = 2082;
      v107 = v18;
      v108 = 1024;
      v109 = 1419;
      v110 = 2114;
      v111 = v19;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

    }
    v20 = *(_QWORD *)(a1 + 48);
    if (v20)
    {
      v21 = objc_alloc((Class)NSError);
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v100 = NSLocalizedDescriptionKey;
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
      v101 = v23;
      v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v101, &v100, 1));
      v25 = objc_msgSend(v21, "initWithDomain:code:userInfo:", v22, 54, v24);
      (*(void (**)(uint64_t, id))(v20 + 16))(v20, v25);

    }
    return;
  }
  v26 = NFSharedSignpostLog(v2);
  v27 = objc_claimAutoreleasedReturnValue(v26);
  if (os_signpost_enabled(v27))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v27, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SEMSession:restoreAuthorizationForAllAppletsExcept", "processing", buf, 2u);
  }

  v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "expressModeManager"));
  v29 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v30 = NFLogGetLogger(v29);
  v31 = (void (*)(uint64_t, const char *, ...))v30;
  if (v28)
  {
    if (v30)
    {
      v32 = object_getClass(*(id *)(a1 + 32));
      v33 = class_isMetaClass(v32);
      v34 = object_getClassName(*(id *)(a1 + 32));
      v35 = sel_getName(*(SEL *)(a1 + 56));
      v36 = 45;
      if (v33)
        v36 = 43;
      v31(6, "%c[%{public}s %{public}s]:%i %{public}@", v36, v34, v35, 1432, *(_QWORD *)(a1 + 40));
    }
    v37 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v38 = NFSharedLogGetLogger(v37);
    v39 = objc_claimAutoreleasedReturnValue(v38);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
    {
      v40 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v40))
        v41 = 43;
      else
        v41 = 45;
      v42 = object_getClassName(*(id *)(a1 + 32));
      v43 = sel_getName(*(SEL *)(a1 + 56));
      v44 = *(void **)(a1 + 40);
      *(_DWORD *)buf = 67110146;
      v103 = v41;
      v104 = 2082;
      v105 = v42;
      v106 = 2082;
      v107 = v43;
      v108 = 1024;
      v109 = 1432;
      v110 = 2114;
      v111 = v44;
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
    }

    v45 = (_QWORD *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "expressModeManager"));
    v46 = sub_1000414F0(v45, *(void **)(a1 + 40), objc_msgSend(*(id *)(a1 + 32), "uid"));

    if (v46)
    {
      v48 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v49 = NFLogGetLogger(v48);
      if (v49)
      {
        v50 = (void (*)(uint64_t, const char *, ...))v49;
        v51 = object_getClass(*(id *)(a1 + 32));
        v52 = class_isMetaClass(v51);
        v53 = object_getClassName(*(id *)(a1 + 32));
        v94 = sel_getName(*(SEL *)(a1 + 56));
        v54 = 45;
        if (v52)
          v54 = 43;
        v50(3, "%c[%{public}s %{public}s]:%i Failed to restore authorization on all applets", v54, v53, v94, 1436);
      }
      v55 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v56 = NFSharedLogGetLogger(v55);
      v57 = objc_claimAutoreleasedReturnValue(v56);
      if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
      {
        v58 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v58))
          v59 = 43;
        else
          v59 = 45;
        v60 = object_getClassName(*(id *)(a1 + 32));
        v61 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)buf = 67109890;
        v103 = v59;
        v104 = 2082;
        v105 = v60;
        v106 = 2082;
        v107 = v61;
        v108 = 1024;
        v109 = 1436;
        _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to restore authorization on all applets", buf, 0x22u);
      }

      v63 = NFSharedSignpostLog(v62);
      v64 = objc_claimAutoreleasedReturnValue(v63);
      if (os_signpost_enabled(v64))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v64, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:restoreAuthorizationForAllAppletsExcept", "failure", buf, 2u);
      }

      v65 = *(_QWORD *)(a1 + 48);
      v66 = objc_alloc((Class)NSError);
      v67 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v68 = v46;
      v96 = NSLocalizedDescriptionKey;
      if (v46 >= 0x47)
        v69 = 71;
      else
        v69 = v46;
      v70 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E9508[v69]));
      v97 = v70;
      v71 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v97, &v96, 1));
      v72 = objc_msgSend(v66, "initWithDomain:code:userInfo:", v67, v68, v71);
      (*(void (**)(uint64_t, id))(v65 + 16))(v65, v72);

LABEL_57:
      return;
    }
    v92 = NFSharedSignpostLog(v47);
    v93 = objc_claimAutoreleasedReturnValue(v92);
    if (os_signpost_enabled(v93))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v93, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:restoreAuthorizationForAllAppletsExcept", "user callback", buf, 2u);
    }

    (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
  }
  else
  {
    if (v30)
    {
      v73 = object_getClass(*(id *)(a1 + 32));
      v74 = class_isMetaClass(v73);
      v75 = object_getClassName(*(id *)(a1 + 32));
      v95 = sel_getName(*(SEL *)(a1 + 56));
      v76 = 45;
      if (v74)
        v76 = 43;
      v31(3, "%c[%{public}s %{public}s]:%i EMM is nil!", v76, v75, v95, 1424);
    }
    v77 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v78 = NFSharedLogGetLogger(v77);
    v79 = objc_claimAutoreleasedReturnValue(v78);
    if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
    {
      v80 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v80))
        v81 = 43;
      else
        v81 = 45;
      v82 = object_getClassName(*(id *)(a1 + 32));
      v83 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)buf = 67109890;
      v103 = v81;
      v104 = 2082;
      v105 = v82;
      v106 = 2082;
      v107 = v83;
      v108 = 1024;
      v109 = 1424;
      _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i EMM is nil!", buf, 0x22u);
    }

    if (*(_QWORD *)(a1 + 48))
    {
      v85 = NFSharedSignpostLog(v84);
      v86 = objc_claimAutoreleasedReturnValue(v85);
      if (os_signpost_enabled(v86))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v86, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:restoreAuthorizationForAllAppletsExcept", "failure", buf, 2u);
      }

      v87 = *(_QWORD *)(a1 + 48);
      v88 = objc_alloc((Class)NSError);
      v67 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v98 = NSLocalizedDescriptionKey;
      v89 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid State"));
      v99 = v89;
      v90 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v99, &v98, 1));
      v91 = objc_msgSend(v88, "initWithDomain:code:userInfo:", v67, 12, v90);
      (*(void (**)(uint64_t, id))(v87 + 16))(v87, v91);

      goto LABEL_57;
    }
  }
}

void sub_100163400(uint64_t a1)
{
  id v2;
  void *specific;
  uint64_t Logger;
  void (*v5)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  objc_class *v15;
  int v16;
  const char *v17;
  const char *v18;
  void *v19;
  uint64_t v20;
  id v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  uint64_t v27;
  id v28;
  uint64_t v29;
  NSObject *v30;
  void *v31;
  void *v32;
  uint64_t v33;
  void (*v34)(uint64_t, const char *, ...);
  objc_class *v35;
  _BOOL4 v36;
  const char *v37;
  const char *v38;
  uint64_t v39;
  void *v40;
  uint64_t v41;
  NSObject *v42;
  objc_class *v43;
  int v44;
  const char *v45;
  const char *v46;
  void *v47;
  uint64_t v48;
  void *v49;
  id v50;
  uint64_t v51;
  uint64_t v52;
  NSObject *v53;
  void *v54;
  uint64_t v55;
  void (*v56)(uint64_t, const char *, ...);
  objc_class *v57;
  _BOOL4 v58;
  const char *v59;
  uint64_t v60;
  void *v61;
  uint64_t v62;
  NSObject *v63;
  objc_class *v64;
  int v65;
  const char *v66;
  const char *v67;
  void (*v68)(void);
  objc_class *v69;
  _BOOL4 v70;
  const char *v71;
  uint64_t v72;
  void *v73;
  uint64_t v74;
  NSObject *v75;
  objc_class *v76;
  int v77;
  const char *v78;
  const char *v79;
  uint64_t v80;
  uint64_t v81;
  NSObject *v82;
  id v83;
  const char *v84;
  const char *v85;
  uint8_t buf[4];
  int v87;
  __int16 v88;
  const char *v89;
  __int16 v90;
  const char *v91;
  __int16 v92;
  int v93;
  __int16 v94;
  void *v95;
  __int16 v96;
  uint64_t v97;
  NSErrorUserInfoKey v98;
  void *v99;
  NSErrorUserInfoKey v100;
  void *v101;

  if (!objc_msgSend(*(id *)(a1 + 32), "didStart")
    || (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) != 0
    || (v2 = objc_msgSend(*(id *)(a1 + 32), "didEnd"), (_DWORD)v2))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 64));
      v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      v11 = 45;
      if (isMetaClass)
        v11 = 43;
      v5(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v11, ClassName, Name, 1452, v10);

    }
    v12 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v13 = NFSharedLogGetLogger(v12);
    v14 = objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      v15 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v15))
        v16 = 43;
      else
        v16 = 45;
      v17 = object_getClassName(*(id *)(a1 + 32));
      v18 = sel_getName(*(SEL *)(a1 + 64));
      v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      *(_DWORD *)buf = 67110146;
      v87 = v16;
      v88 = 2082;
      v89 = v17;
      v90 = 2082;
      v91 = v18;
      v92 = 1024;
      v93 = 1452;
      v94 = 2114;
      v95 = v19;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

    }
    v20 = *(_QWORD *)(a1 + 56);
    if (v20)
    {
      v21 = objc_alloc((Class)NSError);
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v100 = NSLocalizedDescriptionKey;
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
      v101 = v23;
      v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v101, &v100, 1));
      v25 = v21;
      v26 = v22;
      v27 = 54;
LABEL_15:
      v28 = objc_msgSend(v25, "initWithDomain:code:userInfo:", v26, v27, v24);
      (*(void (**)(uint64_t, id))(v20 + 16))(v20, v28);

LABEL_16:
    }
  }
  else
  {
    v29 = NFSharedSignpostLog(v2);
    v30 = objc_claimAutoreleasedReturnValue(v29);
    if (os_signpost_enabled(v30))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v30, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SEMSession:restoreAuthorizarionForKeys", "processing", buf, 2u);
    }

    v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "expressModeManager"));
    v32 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v33 = NFLogGetLogger(v32);
    v34 = (void (*)(uint64_t, const char *, ...))v33;
    if (v31)
    {
      if (v33)
      {
        v35 = object_getClass(*(id *)(a1 + 32));
        v36 = class_isMetaClass(v35);
        v37 = object_getClassName(*(id *)(a1 + 32));
        v38 = sel_getName(*(SEL *)(a1 + 64));
        v39 = 45;
        if (v36)
          v39 = 43;
        v34(6, "%c[%{public}s %{public}s]:%i keys: %{public}@  applet:%{public}@", v39, v37, v38, 1465, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48));
      }
      v40 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v41 = NFSharedLogGetLogger(v40);
      v42 = objc_claimAutoreleasedReturnValue(v41);
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
      {
        v43 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v43))
          v44 = 43;
        else
          v44 = 45;
        v45 = object_getClassName(*(id *)(a1 + 32));
        v46 = sel_getName(*(SEL *)(a1 + 64));
        v47 = *(void **)(a1 + 40);
        v48 = *(_QWORD *)(a1 + 48);
        *(_DWORD *)buf = 67110402;
        v87 = v44;
        v88 = 2082;
        v89 = v45;
        v90 = 2082;
        v91 = v46;
        v92 = 1024;
        v93 = 1465;
        v94 = 2114;
        v95 = v47;
        v96 = 2114;
        v97 = v48;
        _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i keys: %{public}@  applet:%{public}@", buf, 0x36u);
      }

      v49 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "expressModeManager"));
      v50 = sub_1000417F4((uint64_t)v49, *(void **)(a1 + 40), *(void **)(a1 + 48));
      v22 = (void *)objc_claimAutoreleasedReturnValue(v50);

      v52 = NFSharedSignpostLog(v51);
      v53 = objc_claimAutoreleasedReturnValue(v52);
      if (os_signpost_enabled(v53))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v53, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:restoreAuthorizarionForKeys", "user callback", buf, 2u);
      }

      if (v22)
      {
        v54 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v55 = NFLogGetLogger(v54);
        if (v55)
        {
          v56 = (void (*)(uint64_t, const char *, ...))v55;
          v57 = object_getClass(*(id *)(a1 + 32));
          v58 = class_isMetaClass(v57);
          v59 = object_getClassName(*(id *)(a1 + 32));
          v84 = sel_getName(*(SEL *)(a1 + 64));
          v60 = 45;
          if (v58)
            v60 = 43;
          v56(3, "%c[%{public}s %{public}s]:%i Failed to restore authorization on keys", v60, v59, v84, 1470);
        }
        v61 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v62 = NFSharedLogGetLogger(v61);
        v63 = objc_claimAutoreleasedReturnValue(v62);
        if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
        {
          v64 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v64))
            v65 = 43;
          else
            v65 = 45;
          v66 = object_getClassName(*(id *)(a1 + 32));
          v67 = sel_getName(*(SEL *)(a1 + 64));
          *(_DWORD *)buf = 67109890;
          v87 = v65;
          v88 = 2082;
          v89 = v66;
          v90 = 2082;
          v91 = v67;
          v92 = 1024;
          v93 = 1470;
          _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to restore authorization on keys", buf, 0x22u);
        }

        v68 = *(void (**)(void))(*(_QWORD *)(a1 + 56) + 16);
      }
      else
      {
        v68 = *(void (**)(void))(*(_QWORD *)(a1 + 56) + 16);
      }
      v68();
      goto LABEL_16;
    }
    if (v33)
    {
      v69 = object_getClass(*(id *)(a1 + 32));
      v70 = class_isMetaClass(v69);
      v71 = object_getClassName(*(id *)(a1 + 32));
      v85 = sel_getName(*(SEL *)(a1 + 64));
      v72 = 45;
      if (v70)
        v72 = 43;
      v34(3, "%c[%{public}s %{public}s]:%i EMM is nil!", v72, v71, v85, 1457);
    }
    v73 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v74 = NFSharedLogGetLogger(v73);
    v75 = objc_claimAutoreleasedReturnValue(v74);
    if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
    {
      v76 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v76))
        v77 = 43;
      else
        v77 = 45;
      v78 = object_getClassName(*(id *)(a1 + 32));
      v79 = sel_getName(*(SEL *)(a1 + 64));
      *(_DWORD *)buf = 67109890;
      v87 = v77;
      v88 = 2082;
      v89 = v78;
      v90 = 2082;
      v91 = v79;
      v92 = 1024;
      v93 = 1457;
      _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i EMM is nil!", buf, 0x22u);
    }

    if (*(_QWORD *)(a1 + 56))
    {
      v81 = NFSharedSignpostLog(v80);
      v82 = objc_claimAutoreleasedReturnValue(v81);
      if (os_signpost_enabled(v82))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v82, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:restoreAuthorizarionForKeys", "failure", buf, 2u);
      }

      v20 = *(_QWORD *)(a1 + 56);
      v83 = objc_alloc((Class)NSError);
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v98 = NSLocalizedDescriptionKey;
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid State"));
      v99 = v23;
      v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v99, &v98, 1));
      v25 = v83;
      v26 = v22;
      v27 = 12;
      goto LABEL_15;
    }
  }
}

void sub_100163F80(uint64_t a1)
{
  id v2;
  void *specific;
  uint64_t Logger;
  void (*v5)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  objc_class *v15;
  int v16;
  const char *v17;
  const char *v18;
  void *v19;
  uint64_t v20;
  id v21;
  void *v22;
  void *v23;
  void *v24;
  id v25;
  uint64_t v26;
  NSObject *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void (*v31)(uint64_t, const char *, ...);
  objc_class *v32;
  _BOOL4 v33;
  const char *v34;
  const char *v35;
  void *v36;
  void *v37;
  uint64_t v38;
  void *v39;
  uint64_t v40;
  NSObject *v41;
  objc_class *v42;
  int v43;
  const char *v44;
  const char *v45;
  void *v46;
  void *v47;
  _QWORD *v48;
  id v49;
  uint64_t v50;
  uint64_t v51;
  NSObject *v52;
  void *v53;
  uint64_t v54;
  void (*v55)(uint64_t, const char *, ...);
  objc_class *v56;
  _BOOL4 v57;
  const char *v58;
  uint64_t v59;
  void *v60;
  uint64_t v61;
  NSObject *v62;
  objc_class *v63;
  int v64;
  const char *v65;
  const char *v66;
  uint64_t v67;
  id v68;
  void *v69;
  id v70;
  uint64_t v71;
  objc_class *v72;
  _BOOL4 v73;
  const char *v74;
  uint64_t v75;
  void *v76;
  uint64_t v77;
  NSObject *v78;
  objc_class *v79;
  int v80;
  const char *v81;
  const char *v82;
  uint64_t v83;
  uint64_t v84;
  NSObject *v85;
  uint64_t v86;
  id v87;
  id v88;
  id v89;
  void *v90;
  id v91;
  void *v92;
  id v93;
  id v94;
  void *v95;
  id v96;
  const char *v97;
  const char *v98;
  _QWORD v99[5];
  _QWORD v100[5];
  uint8_t buf[4];
  int v102;
  __int16 v103;
  const char *v104;
  __int16 v105;
  const char *v106;
  __int16 v107;
  int v108;
  __int16 v109;
  void *v110;
  __int16 v111;
  void *v112;
  _QWORD v113[4];
  _QWORD v114[4];
  NSErrorUserInfoKey v115;
  void *v116;

  if (!objc_msgSend(*(id *)(a1 + 32), "didStart")
    || (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) != 0
    || (v2 = objc_msgSend(*(id *)(a1 + 32), "didEnd"), (_DWORD)v2))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 72));
      v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      v11 = 45;
      if (isMetaClass)
        v11 = 43;
      v5(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v11, ClassName, Name, 1503, v10);

    }
    v12 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v13 = NFSharedLogGetLogger(v12);
    v14 = objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      v15 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v15))
        v16 = 43;
      else
        v16 = 45;
      v17 = object_getClassName(*(id *)(a1 + 32));
      v18 = sel_getName(*(SEL *)(a1 + 72));
      v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      *(_DWORD *)buf = 67110146;
      v102 = v16;
      v103 = 2082;
      v104 = v17;
      v105 = 2082;
      v106 = v18;
      v107 = 1024;
      v108 = 1503;
      v109 = 2114;
      v110 = v19;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

    }
    v20 = *(_QWORD *)(a1 + 64);
    if (v20)
    {
      v21 = objc_alloc((Class)NSError);
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v115 = NSLocalizedDescriptionKey;
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
      v116 = v23;
      v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v116, &v115, 1));
      v25 = objc_msgSend(v21, "initWithDomain:code:userInfo:", v22, 54, v24);
      (*(void (**)(uint64_t, id))(v20 + 16))(v20, v25);

LABEL_15:
LABEL_16:

    }
  }
  else
  {
    v26 = NFSharedSignpostLog(v2);
    v27 = objc_claimAutoreleasedReturnValue(v26);
    if (os_signpost_enabled(v27))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v27, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SEMSession:disableAuthorizationForApplets", "processing", buf, 2u);
    }

    v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "expressModeManager"));
    v29 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v30 = NFLogGetLogger(v29);
    v31 = (void (*)(uint64_t, const char *, ...))v30;
    if (v28)
    {
      if (v30)
      {
        v32 = object_getClass(*(id *)(a1 + 32));
        v33 = class_isMetaClass(v32);
        v34 = object_getClassName(*(id *)(a1 + 32));
        v35 = sel_getName(*(SEL *)(a1 + 72));
        v36 = (void *)objc_claimAutoreleasedReturnValue(+[NFApplet aidListForPrinting:](NFApplet, "aidListForPrinting:", *(_QWORD *)(a1 + 40)));
        v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
        v38 = 45;
        if (v33)
          v38 = 43;
        v31(6, "%c[%{public}s %{public}s]:%i applets=%{public}@  client=%{public}@", v38, v34, v35, 1516, v36, v37);

      }
      v39 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v40 = NFSharedLogGetLogger(v39);
      v41 = objc_claimAutoreleasedReturnValue(v40);
      if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
      {
        v42 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v42))
          v43 = 43;
        else
          v43 = 45;
        v44 = object_getClassName(*(id *)(a1 + 32));
        v45 = sel_getName(*(SEL *)(a1 + 72));
        v46 = (void *)objc_claimAutoreleasedReturnValue(+[NFApplet aidListForPrinting:](NFApplet, "aidListForPrinting:", *(_QWORD *)(a1 + 40)));
        v47 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
        *(_DWORD *)buf = 67110402;
        v102 = v43;
        v103 = 2082;
        v104 = v44;
        v105 = 2082;
        v106 = v45;
        v107 = 1024;
        v108 = 1516;
        v109 = 2114;
        v110 = v46;
        v111 = 2114;
        v112 = v47;
        _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i applets=%{public}@  client=%{public}@", buf, 0x36u);

      }
      v48 = (_QWORD *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "expressModeManager"));
      v49 = sub_100044EE4(v48, *(void **)(a1 + 40), *(void **)(a1 + 48), *(void **)(a1 + 56));
      v22 = (void *)objc_claimAutoreleasedReturnValue(v49);

      v51 = NFSharedSignpostLog(v50);
      v52 = objc_claimAutoreleasedReturnValue(v51);
      if (os_signpost_enabled(v52))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v52, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:disableAuthorizationForApplets", "user callback", buf, 2u);
      }

      if (v22)
      {
        v53 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v54 = NFLogGetLogger(v53);
        if (v54)
        {
          v55 = (void (*)(uint64_t, const char *, ...))v54;
          v56 = object_getClass(*(id *)(a1 + 32));
          v57 = class_isMetaClass(v56);
          v58 = object_getClassName(*(id *)(a1 + 32));
          v97 = sel_getName(*(SEL *)(a1 + 72));
          v59 = 45;
          if (v57)
            v59 = 43;
          v55(3, "%c[%{public}s %{public}s]:%i Failed to disable auth on applet", v59, v58, v97, 1521);
        }
        v60 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v61 = NFSharedLogGetLogger(v60);
        v62 = objc_claimAutoreleasedReturnValue(v61);
        if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
        {
          v63 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v63))
            v64 = 43;
          else
            v64 = 45;
          v65 = object_getClassName(*(id *)(a1 + 32));
          v66 = sel_getName(*(SEL *)(a1 + 72));
          *(_DWORD *)buf = 67109890;
          v102 = v64;
          v103 = 2082;
          v104 = v65;
          v105 = 2082;
          v106 = v66;
          v107 = 1024;
          v108 = 1521;
          _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to disable auth on applet", buf, 0x22u);
        }

        v67 = *(_QWORD *)(a1 + 64);
        v68 = objc_alloc((Class)NSError);
        v69 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v70 = objc_msgSend(v22, "code");
        v99[0] = NSLocalizedDescriptionKey;
        if ((uint64_t)objc_msgSend(v22, "code") > 70)
          v71 = 71;
        else
          v71 = (uint64_t)objc_msgSend(v22, "code");
        v92 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E9508[v71]));
        v100[0] = v92;
        v100[1] = v22;
        v99[1] = NSUnderlyingErrorKey;
        v99[2] = CFSTR("Line");
        v100[2] = &off_1002FFF30;
        v99[3] = CFSTR("Method");
        v93 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 72)));
        v100[3] = v93;
        v99[4] = NSDebugDescriptionErrorKey;
        v94 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 72)), 1522);
        v100[4] = v94;
        v95 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v100, v99, 5));
        v96 = objc_msgSend(v68, "initWithDomain:code:userInfo:", v69, v70, v95);
        (*(void (**)(uint64_t, id))(v67 + 16))(v67, v96);

      }
      else
      {
        (*(void (**)(void))(*(_QWORD *)(a1 + 64) + 16))();
      }
      goto LABEL_16;
    }
    if (v30)
    {
      v72 = object_getClass(*(id *)(a1 + 32));
      v73 = class_isMetaClass(v72);
      v74 = object_getClassName(*(id *)(a1 + 32));
      v98 = sel_getName(*(SEL *)(a1 + 72));
      v75 = 45;
      if (v73)
        v75 = 43;
      v31(3, "%c[%{public}s %{public}s]:%i EMM is nil!", v75, v74, v98, 1508);
    }
    v76 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v77 = NFSharedLogGetLogger(v76);
    v78 = objc_claimAutoreleasedReturnValue(v77);
    if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
    {
      v79 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v79))
        v80 = 43;
      else
        v80 = 45;
      v81 = object_getClassName(*(id *)(a1 + 32));
      v82 = sel_getName(*(SEL *)(a1 + 72));
      *(_DWORD *)buf = 67109890;
      v102 = v80;
      v103 = 2082;
      v104 = v81;
      v105 = 2082;
      v106 = v82;
      v107 = 1024;
      v108 = 1508;
      _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i EMM is nil!", buf, 0x22u);
    }

    if (*(_QWORD *)(a1 + 64))
    {
      v84 = NFSharedSignpostLog(v83);
      v85 = objc_claimAutoreleasedReturnValue(v84);
      if (os_signpost_enabled(v85))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v85, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:disableAuthorizationForApplets", "failure", buf, 2u);
      }

      v86 = *(_QWORD *)(a1 + 64);
      v87 = objc_alloc((Class)NSError);
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v113[0] = NSLocalizedDescriptionKey;
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid State"));
      v114[0] = v23;
      v114[1] = &off_1002FFF18;
      v113[1] = CFSTR("Line");
      v113[2] = CFSTR("Method");
      v88 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 72)));
      v114[2] = v88;
      v113[3] = NSDebugDescriptionErrorKey;
      v89 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 72)), 1511);
      v114[3] = v89;
      v90 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v114, v113, 4));
      v91 = objc_msgSend(v87, "initWithDomain:code:userInfo:", v22, 12, v90);
      (*(void (**)(uint64_t, id))(v86 + 16))(v86, v91);

      goto LABEL_15;
    }
  }
}

void sub_100164B58(uint64_t a1)
{
  id v2;
  void *specific;
  uint64_t Logger;
  void (*v5)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  objc_class *v15;
  int v16;
  const char *v17;
  const char *v18;
  void *v19;
  uint64_t v20;
  id v21;
  void *v22;
  void *v23;
  void *v24;
  id v25;
  uint64_t v26;
  NSObject *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void (*v31)(uint64_t, const char *, ...);
  objc_class *v32;
  _BOOL4 v33;
  const char *v34;
  const char *v35;
  uint64_t v36;
  void *v37;
  uint64_t v38;
  void *v39;
  uint64_t v40;
  NSObject *v41;
  objc_class *v42;
  int v43;
  const char *v44;
  const char *v45;
  void *v46;
  void *v47;
  _QWORD *v48;
  id v49;
  uint64_t v50;
  uint64_t v51;
  NSObject *v52;
  void *v53;
  uint64_t v54;
  void (*v55)(uint64_t, const char *, ...);
  objc_class *v56;
  _BOOL4 v57;
  const char *v58;
  uint64_t v59;
  void *v60;
  uint64_t v61;
  NSObject *v62;
  objc_class *v63;
  int v64;
  const char *v65;
  const char *v66;
  uint64_t v67;
  id v68;
  void *v69;
  id v70;
  uint64_t v71;
  objc_class *v72;
  _BOOL4 v73;
  const char *v74;
  uint64_t v75;
  void *v76;
  uint64_t v77;
  NSObject *v78;
  objc_class *v79;
  int v80;
  const char *v81;
  const char *v82;
  uint64_t v83;
  uint64_t v84;
  NSObject *v85;
  uint64_t v86;
  id v87;
  id v88;
  id v89;
  void *v90;
  id v91;
  void *v92;
  id v93;
  id v94;
  void *v95;
  id v96;
  const char *v97;
  const char *v98;
  _QWORD v99[5];
  _QWORD v100[5];
  uint8_t buf[4];
  int v102;
  __int16 v103;
  const char *v104;
  __int16 v105;
  const char *v106;
  __int16 v107;
  int v108;
  __int16 v109;
  void *v110;
  __int16 v111;
  void *v112;
  _QWORD v113[4];
  _QWORD v114[4];
  NSErrorUserInfoKey v115;
  void *v116;

  if (!objc_msgSend(*(id *)(a1 + 32), "didStart")
    || (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) != 0
    || (v2 = objc_msgSend(*(id *)(a1 + 32), "didEnd"), (_DWORD)v2))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 64));
      v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      v11 = 45;
      if (isMetaClass)
        v11 = 43;
      v5(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v11, ClassName, Name, 1537, v10);

    }
    v12 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v13 = NFSharedLogGetLogger(v12);
    v14 = objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      v15 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v15))
        v16 = 43;
      else
        v16 = 45;
      v17 = object_getClassName(*(id *)(a1 + 32));
      v18 = sel_getName(*(SEL *)(a1 + 64));
      v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      *(_DWORD *)buf = 67110146;
      v102 = v16;
      v103 = 2082;
      v104 = v17;
      v105 = 2082;
      v106 = v18;
      v107 = 1024;
      v108 = 1537;
      v109 = 2114;
      v110 = v19;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

    }
    v20 = *(_QWORD *)(a1 + 56);
    if (v20)
    {
      v21 = objc_alloc((Class)NSError);
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v115 = NSLocalizedDescriptionKey;
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
      v116 = v23;
      v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v116, &v115, 1));
      v25 = objc_msgSend(v21, "initWithDomain:code:userInfo:", v22, 54, v24);
      (*(void (**)(uint64_t, id))(v20 + 16))(v20, v25);

LABEL_15:
LABEL_16:

    }
  }
  else
  {
    v26 = NFSharedSignpostLog(v2);
    v27 = objc_claimAutoreleasedReturnValue(v26);
    if (os_signpost_enabled(v27))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v27, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SEMSession:disableAuthorizationForPasses", "processing", buf, 2u);
    }

    v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "expressModeManager"));
    v29 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v30 = NFLogGetLogger(v29);
    v31 = (void (*)(uint64_t, const char *, ...))v30;
    if (v28)
    {
      if (v30)
      {
        v32 = object_getClass(*(id *)(a1 + 32));
        v33 = class_isMetaClass(v32);
        v34 = object_getClassName(*(id *)(a1 + 32));
        v35 = sel_getName(*(SEL *)(a1 + 64));
        v36 = *(_QWORD *)(a1 + 40);
        v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
        v38 = 45;
        if (v33)
          v38 = 43;
        v31(6, "%c[%{public}s %{public}s]:%i passes=%{public}@  client=%{public}@", v38, v34, v35, 1550, v36, v37);

      }
      v39 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v40 = NFSharedLogGetLogger(v39);
      v41 = objc_claimAutoreleasedReturnValue(v40);
      if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
      {
        v42 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v42))
          v43 = 43;
        else
          v43 = 45;
        v44 = object_getClassName(*(id *)(a1 + 32));
        v45 = sel_getName(*(SEL *)(a1 + 64));
        v46 = *(void **)(a1 + 40);
        v47 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
        *(_DWORD *)buf = 67110402;
        v102 = v43;
        v103 = 2082;
        v104 = v44;
        v105 = 2082;
        v106 = v45;
        v107 = 1024;
        v108 = 1550;
        v109 = 2114;
        v110 = v46;
        v111 = 2114;
        v112 = v47;
        _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i passes=%{public}@  client=%{public}@", buf, 0x36u);

      }
      v48 = (_QWORD *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "expressModeManager"));
      v49 = sub_1000469C4(v48, *(void **)(a1 + 40), *(void **)(a1 + 48));
      v22 = (void *)objc_claimAutoreleasedReturnValue(v49);

      v51 = NFSharedSignpostLog(v50);
      v52 = objc_claimAutoreleasedReturnValue(v51);
      if (os_signpost_enabled(v52))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v52, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:disableAuthorizationForPasses", "user callback", buf, 2u);
      }

      if (v22)
      {
        v53 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v54 = NFLogGetLogger(v53);
        if (v54)
        {
          v55 = (void (*)(uint64_t, const char *, ...))v54;
          v56 = object_getClass(*(id *)(a1 + 32));
          v57 = class_isMetaClass(v56);
          v58 = object_getClassName(*(id *)(a1 + 32));
          v97 = sel_getName(*(SEL *)(a1 + 64));
          v59 = 45;
          if (v57)
            v59 = 43;
          v55(3, "%c[%{public}s %{public}s]:%i Failed to disable auth on passes", v59, v58, v97, 1555);
        }
        v60 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v61 = NFSharedLogGetLogger(v60);
        v62 = objc_claimAutoreleasedReturnValue(v61);
        if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
        {
          v63 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v63))
            v64 = 43;
          else
            v64 = 45;
          v65 = object_getClassName(*(id *)(a1 + 32));
          v66 = sel_getName(*(SEL *)(a1 + 64));
          *(_DWORD *)buf = 67109890;
          v102 = v64;
          v103 = 2082;
          v104 = v65;
          v105 = 2082;
          v106 = v66;
          v107 = 1024;
          v108 = 1555;
          _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to disable auth on passes", buf, 0x22u);
        }

        v67 = *(_QWORD *)(a1 + 56);
        v68 = objc_alloc((Class)NSError);
        v69 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v70 = objc_msgSend(v22, "code");
        v99[0] = NSLocalizedDescriptionKey;
        if ((uint64_t)objc_msgSend(v22, "code") > 70)
          v71 = 71;
        else
          v71 = (uint64_t)objc_msgSend(v22, "code");
        v92 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E9508[v71]));
        v100[0] = v92;
        v100[1] = v22;
        v99[1] = NSUnderlyingErrorKey;
        v99[2] = CFSTR("Line");
        v100[2] = &off_1002FFF60;
        v99[3] = CFSTR("Method");
        v93 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 64)));
        v100[3] = v93;
        v99[4] = NSDebugDescriptionErrorKey;
        v94 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 64)), 1556);
        v100[4] = v94;
        v95 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v100, v99, 5));
        v96 = objc_msgSend(v68, "initWithDomain:code:userInfo:", v69, v70, v95);
        (*(void (**)(uint64_t, id))(v67 + 16))(v67, v96);

      }
      else
      {
        (*(void (**)(void))(*(_QWORD *)(a1 + 56) + 16))();
      }
      goto LABEL_16;
    }
    if (v30)
    {
      v72 = object_getClass(*(id *)(a1 + 32));
      v73 = class_isMetaClass(v72);
      v74 = object_getClassName(*(id *)(a1 + 32));
      v98 = sel_getName(*(SEL *)(a1 + 64));
      v75 = 45;
      if (v73)
        v75 = 43;
      v31(3, "%c[%{public}s %{public}s]:%i EMM is nil!", v75, v74, v98, 1542);
    }
    v76 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v77 = NFSharedLogGetLogger(v76);
    v78 = objc_claimAutoreleasedReturnValue(v77);
    if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
    {
      v79 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v79))
        v80 = 43;
      else
        v80 = 45;
      v81 = object_getClassName(*(id *)(a1 + 32));
      v82 = sel_getName(*(SEL *)(a1 + 64));
      *(_DWORD *)buf = 67109890;
      v102 = v80;
      v103 = 2082;
      v104 = v81;
      v105 = 2082;
      v106 = v82;
      v107 = 1024;
      v108 = 1542;
      _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i EMM is nil!", buf, 0x22u);
    }

    if (*(_QWORD *)(a1 + 56))
    {
      v84 = NFSharedSignpostLog(v83);
      v85 = objc_claimAutoreleasedReturnValue(v84);
      if (os_signpost_enabled(v85))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v85, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:disableAuthorizationForPasses", "failure", buf, 2u);
      }

      v86 = *(_QWORD *)(a1 + 56);
      v87 = objc_alloc((Class)NSError);
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v113[0] = NSLocalizedDescriptionKey;
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid State"));
      v114[0] = v23;
      v114[1] = &off_1002FFF48;
      v113[1] = CFSTR("Line");
      v113[2] = CFSTR("Method");
      v88 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 64)));
      v114[2] = v88;
      v113[3] = NSDebugDescriptionErrorKey;
      v89 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 64)), 1545);
      v114[3] = v89;
      v90 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v114, v113, 4));
      v91 = objc_msgSend(v87, "initWithDomain:code:userInfo:", v22, 12, v90);
      (*(void (**)(uint64_t, id))(v86 + 16))(v86, v91);

      goto LABEL_15;
    }
  }
}

void sub_1001656D4(uint64_t a1)
{
  id v2;
  void *v3;
  uint64_t v4;
  void (*v5)(uint64_t, const char *, ...);
  objc_class *v6;
  _BOOL4 v7;
  const char *v8;
  const char *v9;
  void *v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  objc_class *v15;
  int v16;
  const char *v17;
  const char *v18;
  void *v19;
  uint64_t v20;
  id v21;
  NSObject *v22;
  void *v23;
  void *v24;
  id v25;
  uint64_t v26;
  NSObject *v27;
  uint64_t v28;
  void *v29;
  int v30;
  void *v31;
  void *v32;
  void *v33;
  id v34;
  NSObject *v35;
  uint64_t v36;
  NSObject *v37;
  uint64_t v38;
  void *v39;
  uint64_t v40;
  void (*v41)(uint64_t, const char *, ...);
  objc_class *v42;
  _BOOL4 v43;
  const char *v44;
  uint64_t v45;
  void *v46;
  uint64_t v47;
  NSObject *v48;
  objc_class *v49;
  int v50;
  const char *v51;
  const char *v52;
  uint64_t v53;
  uint64_t v54;
  NSObject *v55;
  uint64_t v56;
  id v57;
  void *v58;
  id v59;
  id v60;
  id v61;
  uint64_t v62;
  NSObject *v63;
  void *specific;
  uint64_t Logger;
  void (*v66)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v70;
  void *v71;
  uint64_t v72;
  NSObject *v73;
  objc_class *v74;
  int v75;
  const char *v76;
  const char *v77;
  id v78;
  void *v79;
  id v80;
  void *v81;
  void *v82;
  double v83;
  id v84;
  void *v85;
  id v86;
  const char *v87;
  const char *Name;
  id v89;
  id v90;
  NSErrorUserInfoKey v91;
  void *v92;
  NSErrorUserInfoKey v93;
  void *v94;
  NSErrorUserInfoKey v95;
  void *v96;
  uint8_t buf[4];
  int v98;
  __int16 v99;
  const char *v100;
  __int16 v101;
  const char *v102;
  __int16 v103;
  int v104;
  __int16 v105;
  void *v106;

  if (objc_msgSend(*(id *)(a1 + 32), "didStart"))
  {
    if ((objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0)
    {
      v2 = objc_msgSend(*(id *)(a1 + 32), "didEnd");
      if (!(_DWORD)v2)
      {
        v26 = NFSharedSignpostLog(v2);
        v27 = objc_claimAutoreleasedReturnValue(v26);
        if (os_signpost_enabled(v27))
        {
          v28 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "expressModeManager"));
          v29 = (void *)v28;
          if (v28)
            v30 = *(unsigned __int8 *)(v28 + 172);
          else
            v30 = 0;
          *(_DWORD *)buf = 67109120;
          v98 = v30;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v27, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SEMSession:getFelicaAppletState", "InSessionExpress=%d", buf, 8u);

        }
        v31 = *(void **)(a1 + 32);
        v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "identifier"));
        v22 = objc_claimAutoreleasedReturnValue(objc_msgSend(v31, "_getSecureElementForAID:", v32));

        if ((objc_msgSend(*(id *)(a1 + 32), "_activateSecureElementWrapper:", v22) & 1) != 0)
        {
          v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "identifier"));
          v34 = sub_10022F2F0(v22, v33);
          v23 = (void *)objc_claimAutoreleasedReturnValue(v34);

          if (!sub_10023B608(v22, v23))
          {
            v90 = 0;
            v60 = sub_100237A30(v22, v23, &v90);
            v24 = (void *)objc_claimAutoreleasedReturnValue(v60);
            v61 = v90;
            v62 = NFSharedSignpostLog(v61);
            v63 = objc_claimAutoreleasedReturnValue(v62);
            if (os_signpost_enabled(v63))
            {
              *(_WORD *)buf = 0;
              _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v63, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:getFelicaAppletState", "user callback", buf, 2u);
            }

            (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
            specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            Logger = NFLogGetLogger(specific);
            if (Logger)
            {
              v66 = (void (*)(uint64_t, const char *, ...))Logger;
              Class = object_getClass(*(id *)(a1 + 32));
              isMetaClass = class_isMetaClass(Class);
              ClassName = object_getClassName(*(id *)(a1 + 32));
              Name = sel_getName(*(SEL *)(a1 + 56));
              v70 = 45;
              if (isMetaClass)
                v70 = 43;
              v66(6, "%c[%{public}s %{public}s]:%i Delaying express mode", v70, ClassName, Name, 1609);
            }
            v71 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v72 = NFSharedLogGetLogger(v71);
            v73 = objc_claimAutoreleasedReturnValue(v72);
            if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
            {
              v74 = object_getClass(*(id *)(a1 + 32));
              if (class_isMetaClass(v74))
                v75 = 43;
              else
                v75 = 45;
              v76 = object_getClassName(*(id *)(a1 + 32));
              v77 = sel_getName(*(SEL *)(a1 + 56));
              *(_DWORD *)buf = 67109890;
              v98 = v75;
              v99 = 2082;
              v100 = v76;
              v101 = 2082;
              v102 = v77;
              v103 = 1024;
              v104 = 1609;
              _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Delaying express mode", buf, 0x22u);
            }

            v89 = v61;
            v78 = sub_1002380E0(v22, v23, &v89);
            v79 = (void *)objc_claimAutoreleasedReturnValue(v78);
            v80 = v89;

            if (!v80)
            {
              v81 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v79, "objectForKeyedSubscript:", CFSTR("DelayExpressReentry")));

              if (v81)
              {
                v82 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v79, "objectForKeyedSubscript:", CFSTR("DelayExpressReentry")));
                objc_msgSend(v82, "doubleValue");
                *(double *)(*(_QWORD *)(a1 + 32) + 168) = v83 / 1000.0;

              }
            }

            goto LABEL_15;
          }
          v35 = sub_10006CB58(v22, v23);
          v24 = (void *)objc_claimAutoreleasedReturnValue(v35);
          v36 = NFSharedSignpostLog(v24);
          v37 = objc_claimAutoreleasedReturnValue(v36);
          if (os_signpost_enabled(v37))
          {
            *(_WORD *)buf = 0;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v37, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:getFelicaAppletState", "user callback", buf, 2u);
          }

          v38 = *(_QWORD *)(a1 + 48);
          if (v24)
          {
            (*(void (**)(uint64_t, void *, _QWORD))(v38 + 16))(v38, v24, 0);
            goto LABEL_15;
          }
          v84 = objc_alloc((Class)NSError);
          v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
          v91 = NSLocalizedDescriptionKey;
          v58 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unexpected Result"));
          v92 = v58;
          v85 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v92, &v91, 1));
          v86 = objc_msgSend(v84, "initWithDomain:code:userInfo:", v24, 13, v85);
          (*(void (**)(uint64_t, _QWORD, id))(v38 + 16))(v38, 0, v86);

        }
        else
        {
          v39 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v40 = NFLogGetLogger(v39);
          if (v40)
          {
            v41 = (void (*)(uint64_t, const char *, ...))v40;
            v42 = object_getClass(*(id *)(a1 + 32));
            v43 = class_isMetaClass(v42);
            v44 = object_getClassName(*(id *)(a1 + 32));
            v87 = sel_getName(*(SEL *)(a1 + 56));
            v45 = 45;
            if (v43)
              v45 = 43;
            v41(3, "%c[%{public}s %{public}s]:%i Failed to set mode to wired", v45, v44, v87, 1581);
          }
          v46 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v47 = NFSharedLogGetLogger(v46);
          v48 = objc_claimAutoreleasedReturnValue(v47);
          if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
          {
            v49 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v49))
              v50 = 43;
            else
              v50 = 45;
            v51 = object_getClassName(*(id *)(a1 + 32));
            v52 = sel_getName(*(SEL *)(a1 + 56));
            *(_DWORD *)buf = 67109890;
            v98 = v50;
            v99 = 2082;
            v100 = v51;
            v101 = 2082;
            v102 = v52;
            v103 = 1024;
            v104 = 1581;
            _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to set mode to wired", buf, 0x22u);
          }

          v54 = NFSharedSignpostLog(v53);
          v55 = objc_claimAutoreleasedReturnValue(v54);
          if (os_signpost_enabled(v55))
          {
            *(_WORD *)buf = 0;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v55, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:getFelicaAppletState", "failure", buf, 2u);
          }

          v56 = *(_QWORD *)(a1 + 48);
          v57 = objc_alloc((Class)NSError);
          v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
          v93 = NSLocalizedDescriptionKey;
          v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unexpected Result"));
          v94 = v24;
          v58 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v94, &v93, 1));
          v59 = objc_msgSend(v57, "initWithDomain:code:userInfo:", v23, 13, v58);
          (*(void (**)(uint64_t, _QWORD, id))(v56 + 16))(v56, 0, v59);

        }
        goto LABEL_15;
      }
    }
  }
  v3 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v4 = NFLogGetLogger(v3);
  if (v4)
  {
    v5 = (void (*)(uint64_t, const char *, ...))v4;
    v6 = object_getClass(*(id *)(a1 + 32));
    v7 = class_isMetaClass(v6);
    v8 = object_getClassName(*(id *)(a1 + 32));
    v9 = sel_getName(*(SEL *)(a1 + 56));
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v11 = 45;
    if (v7)
      v11 = 43;
    v5(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v11, v8, v9, 1572, v10);

  }
  v12 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v13 = NFSharedLogGetLogger(v12);
  v14 = objc_claimAutoreleasedReturnValue(v13);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    v15 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v15))
      v16 = 43;
    else
      v16 = 45;
    v17 = object_getClassName(*(id *)(a1 + 32));
    v18 = sel_getName(*(SEL *)(a1 + 56));
    v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v98 = v16;
    v99 = 2082;
    v100 = v17;
    v101 = 2082;
    v102 = v18;
    v103 = 1024;
    v104 = 1572;
    v105 = 2114;
    v106 = v19;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v20 = *(_QWORD *)(a1 + 48);
  if (v20)
  {
    v21 = objc_alloc((Class)NSError);
    v22 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v95 = NSLocalizedDescriptionKey;
    v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v96 = v23;
    v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v96, &v95, 1));
    v25 = objc_msgSend(v21, "initWithDomain:code:userInfo:", v22, 54, v24);
    (*(void (**)(uint64_t, _QWORD, id))(v20 + 16))(v20, 0, v25);

LABEL_15:
  }
}

void sub_100166138(uint64_t a1)
{
  id v2;
  void *v3;
  uint64_t v4;
  void (*v5)(uint64_t, const char *, ...);
  objc_class *v6;
  _BOOL4 v7;
  const char *v8;
  const char *v9;
  void *v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  objc_class *v15;
  int v16;
  const char *v17;
  const char *v18;
  void *v19;
  uint64_t v20;
  id v21;
  void *v22;
  id v23;
  void *v24;
  id v25;
  uint64_t v26;
  NSObject *v27;
  uint64_t v28;
  void *v29;
  int v30;
  void *v31;
  void *v32;
  void *v33;
  id v34;
  id v35;
  id v36;
  uint64_t v37;
  NSObject *v38;
  void *specific;
  uint64_t Logger;
  void (*v41)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v45;
  void *v46;
  uint64_t v47;
  NSObject *v48;
  objc_class *v49;
  int v50;
  const char *v51;
  const char *v52;
  id v53;
  id v54;
  void *v55;
  void *v56;
  double v57;
  void *v58;
  uint64_t v59;
  void (*v60)(uint64_t, const char *, ...);
  objc_class *v61;
  _BOOL4 v62;
  const char *v63;
  uint64_t v64;
  void *v65;
  uint64_t v66;
  NSObject *v67;
  objc_class *v68;
  int v69;
  const char *v70;
  const char *v71;
  uint64_t v72;
  uint64_t v73;
  NSObject *v74;
  uint64_t v75;
  id v76;
  const char *Name;
  const char *v78;
  id v79;
  id v80;
  NSErrorUserInfoKey v81;
  void *v82;
  NSErrorUserInfoKey v83;
  id v84;
  uint8_t buf[4];
  int v86;
  __int16 v87;
  const char *v88;
  __int16 v89;
  const char *v90;
  __int16 v91;
  int v92;
  __int16 v93;
  void *v94;

  if (objc_msgSend(*(id *)(a1 + 32), "didStart"))
  {
    if ((objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0)
    {
      v2 = objc_msgSend(*(id *)(a1 + 32), "didEnd");
      if (!(_DWORD)v2)
      {
        v26 = NFSharedSignpostLog(v2);
        v27 = objc_claimAutoreleasedReturnValue(v26);
        if (os_signpost_enabled(v27))
        {
          v28 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "expressModeManager"));
          v29 = (void *)v28;
          if (v28)
            v30 = *(unsigned __int8 *)(v28 + 172);
          else
            v30 = 0;
          *(_DWORD *)buf = 67109120;
          v86 = v30;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v27, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SEMSession:getTransitAppletState", "InSessionExpress=%d", buf, 8u);

        }
        v31 = *(void **)(a1 + 32);
        v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "identifier"));
        v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v31, "_getSecureElementForAID:", v32));

        if ((objc_msgSend(*(id *)(a1 + 32), "_activateSecureElementWrapper:", v22) & 1) != 0)
        {
          v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "identifier"));
          v34 = sub_10022F2F0(v22, v33);
          v24 = (void *)objc_claimAutoreleasedReturnValue(v34);

          v80 = 0;
          v35 = sub_100237A30(v22, v24, &v80);
          v25 = (id)objc_claimAutoreleasedReturnValue(v35);
          v36 = v80;
          v37 = NFSharedSignpostLog(v36);
          v38 = objc_claimAutoreleasedReturnValue(v37);
          if (os_signpost_enabled(v38))
          {
            *(_WORD *)buf = 0;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v38, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:getTransitAppletState", "user callback", buf, 2u);
          }

          (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
          specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          Logger = NFLogGetLogger(specific);
          if (Logger)
          {
            v41 = (void (*)(uint64_t, const char *, ...))Logger;
            Class = object_getClass(*(id *)(a1 + 32));
            isMetaClass = class_isMetaClass(Class);
            ClassName = object_getClassName(*(id *)(a1 + 32));
            Name = sel_getName(*(SEL *)(a1 + 56));
            v45 = 45;
            if (isMetaClass)
              v45 = 43;
            v41(6, "%c[%{public}s %{public}s]:%i Delaying express mode", v45, ClassName, Name, 1651);
          }
          v46 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v47 = NFSharedLogGetLogger(v46);
          v48 = objc_claimAutoreleasedReturnValue(v47);
          if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
          {
            v49 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v49))
              v50 = 43;
            else
              v50 = 45;
            v51 = object_getClassName(*(id *)(a1 + 32));
            v52 = sel_getName(*(SEL *)(a1 + 56));
            *(_DWORD *)buf = 67109890;
            v86 = v50;
            v87 = 2082;
            v88 = v51;
            v89 = 2082;
            v90 = v52;
            v91 = 1024;
            v92 = 1651;
            _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Delaying express mode", buf, 0x22u);
          }

          v79 = v36;
          v53 = sub_1002380E0(v22, v24, &v79);
          v54 = (id)objc_claimAutoreleasedReturnValue(v53);
          v23 = v79;

          if (!v23)
          {
            v55 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v54, "objectForKeyedSubscript:", CFSTR("DelayExpressReentry")));

            if (v55)
            {
              v56 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v54, "objectForKeyedSubscript:", CFSTR("DelayExpressReentry")));
              objc_msgSend(v56, "doubleValue");
              *(double *)(*(_QWORD *)(a1 + 32) + 168) = v57 / 1000.0;

            }
            v23 = 0;
          }
        }
        else
        {
          v58 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v59 = NFLogGetLogger(v58);
          if (v59)
          {
            v60 = (void (*)(uint64_t, const char *, ...))v59;
            v61 = object_getClass(*(id *)(a1 + 32));
            v62 = class_isMetaClass(v61);
            v63 = object_getClassName(*(id *)(a1 + 32));
            v78 = sel_getName(*(SEL *)(a1 + 56));
            v64 = 45;
            if (v62)
              v64 = 43;
            v60(3, "%c[%{public}s %{public}s]:%i Failed to set mode to wired", v64, v63, v78, 1637);
          }
          v65 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v66 = NFSharedLogGetLogger(v65);
          v67 = objc_claimAutoreleasedReturnValue(v66);
          if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
          {
            v68 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v68))
              v69 = 43;
            else
              v69 = 45;
            v70 = object_getClassName(*(id *)(a1 + 32));
            v71 = sel_getName(*(SEL *)(a1 + 56));
            *(_DWORD *)buf = 67109890;
            v86 = v69;
            v87 = 2082;
            v88 = v70;
            v89 = 2082;
            v90 = v71;
            v91 = 1024;
            v92 = 1637;
            _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to set mode to wired", buf, 0x22u);
          }

          v73 = NFSharedSignpostLog(v72);
          v74 = objc_claimAutoreleasedReturnValue(v73);
          if (os_signpost_enabled(v74))
          {
            *(_WORD *)buf = 0;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v74, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:getTransitAppletState", "failure", buf, 2u);
          }

          v75 = *(_QWORD *)(a1 + 48);
          v76 = objc_alloc((Class)NSError);
          v23 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
          v81 = NSLocalizedDescriptionKey;
          v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unexpected Result"));
          v82 = v24;
          v25 = (id)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v82, &v81, 1));
          v54 = objc_msgSend(v76, "initWithDomain:code:userInfo:", v23, 13, v25);
          (*(void (**)(uint64_t, _QWORD, id))(v75 + 16))(v75, 0, v54);
        }

        goto LABEL_15;
      }
    }
  }
  v3 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v4 = NFLogGetLogger(v3);
  if (v4)
  {
    v5 = (void (*)(uint64_t, const char *, ...))v4;
    v6 = object_getClass(*(id *)(a1 + 32));
    v7 = class_isMetaClass(v6);
    v8 = object_getClassName(*(id *)(a1 + 32));
    v9 = sel_getName(*(SEL *)(a1 + 56));
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v11 = 45;
    if (v7)
      v11 = 43;
    v5(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v11, v8, v9, 1628, v10);

  }
  v12 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v13 = NFSharedLogGetLogger(v12);
  v14 = objc_claimAutoreleasedReturnValue(v13);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    v15 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v15))
      v16 = 43;
    else
      v16 = 45;
    v17 = object_getClassName(*(id *)(a1 + 32));
    v18 = sel_getName(*(SEL *)(a1 + 56));
    v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v86 = v16;
    v87 = 2082;
    v88 = v17;
    v89 = 2082;
    v90 = v18;
    v91 = 1024;
    v92 = 1628;
    v93 = 2114;
    v94 = v19;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v20 = *(_QWORD *)(a1 + 48);
  if (v20)
  {
    v21 = objc_alloc((Class)NSError);
    v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v83 = NSLocalizedDescriptionKey;
    v23 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v84 = v23;
    v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v84, &v83, 1));
    v25 = objc_msgSend(v21, "initWithDomain:code:userInfo:", v22, 54, v24);
    (*(void (**)(uint64_t, _QWORD, id))(v20 + 16))(v20, 0, v25);
LABEL_15:

  }
}

void sub_100166A98(uint64_t a1)
{
  id v2;
  void *v3;
  uint64_t v4;
  void (*v5)(uint64_t, const char *, ...);
  objc_class *v6;
  _BOOL4 v7;
  const char *v8;
  const char *v9;
  void *v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  objc_class *v15;
  int v16;
  const char *v17;
  const char *v18;
  void *v19;
  uint64_t v20;
  id v21;
  void *v22;
  id v23;
  void *v24;
  id v25;
  uint64_t v26;
  NSObject *v27;
  void *v28;
  void *v29;
  void *v30;
  id v31;
  void *v32;
  void *v33;
  id *v34;
  id v35;
  uint64_t v36;
  void *specific;
  uint64_t Logger;
  void (*v39)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v43;
  void *v44;
  uint64_t v45;
  NSObject *v46;
  objc_class *v47;
  int v48;
  const char *v49;
  const char *v50;
  uint64_t v51;
  uint64_t v52;
  NSObject *v53;
  uint64_t v54;
  id v55;
  id v56;
  id v57;
  uint64_t v58;
  NSObject *v59;
  const char *Name;
  uint64_t v61;
  uint64_t v62;
  NSErrorUserInfoKey v63;
  void *v64;
  NSErrorUserInfoKey v65;
  id v66;
  uint8_t buf[4];
  int v68;
  __int16 v69;
  const char *v70;
  __int16 v71;
  const char *v72;
  __int16 v73;
  int v74;
  __int16 v75;
  void *v76;

  if (objc_msgSend(*(id *)(a1 + 32), "didStart"))
  {
    if ((objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0)
    {
      v2 = objc_msgSend(*(id *)(a1 + 32), "didEnd");
      if (!(_DWORD)v2)
      {
        v26 = NFSharedSignpostLog(v2);
        v27 = objc_claimAutoreleasedReturnValue(v26);
        if (os_signpost_enabled(v27))
        {
          *(_WORD *)buf = 0;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v27, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SEMSession:getServiceProviderDataForApplet", "processing", buf, 2u);
        }

        v28 = *(void **)(a1 + 32);
        v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "identifier"));
        v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "_getSecureElementForAID:", v29));

        if ((objc_msgSend(*(id *)(a1 + 32), "_activateSecureElementWrapper:", v22) & 1) != 0)
        {
          v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "identifier"));
          v31 = sub_10022F2F0(v22, v30);
          v24 = (void *)objc_claimAutoreleasedReturnValue(v31);

          v32 = *(void **)(a1 + 48);
          if (v32 && (v33 = *(void **)(a1 + 56)) != 0)
          {
            v62 = 0;
            v34 = (id *)&v62;
            v35 = sub_100238BB4(v22, v24, v32, v33, &v62);
            v36 = objc_claimAutoreleasedReturnValue(v35);
          }
          else
          {
            v61 = 0;
            v34 = (id *)&v61;
            v57 = sub_100238590(v22, v24, &v61);
            v36 = objc_claimAutoreleasedReturnValue(v57);
          }
          v25 = (id)v36;
          v23 = *v34;
          v58 = NFSharedSignpostLog(v23);
          v59 = objc_claimAutoreleasedReturnValue(v58);
          if (os_signpost_enabled(v59))
          {
            *(_WORD *)buf = 0;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v59, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:getServiceProviderDataForApplet", "user callback", buf, 2u);
          }

          (*(void (**)(_QWORD, id, id))(*(_QWORD *)(a1 + 64) + 16))(*(_QWORD *)(a1 + 64), v25, v23);
        }
        else
        {
          specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          Logger = NFLogGetLogger(specific);
          if (Logger)
          {
            v39 = (void (*)(uint64_t, const char *, ...))Logger;
            Class = object_getClass(*(id *)(a1 + 32));
            isMetaClass = class_isMetaClass(Class);
            ClassName = object_getClassName(*(id *)(a1 + 32));
            Name = sel_getName(*(SEL *)(a1 + 72));
            v43 = 45;
            if (isMetaClass)
              v43 = 43;
            v39(3, "%c[%{public}s %{public}s]:%i Failed to set mode to wired", v43, ClassName, Name, 1683);
          }
          v44 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v45 = NFSharedLogGetLogger(v44);
          v46 = objc_claimAutoreleasedReturnValue(v45);
          if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
          {
            v47 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v47))
              v48 = 43;
            else
              v48 = 45;
            v49 = object_getClassName(*(id *)(a1 + 32));
            v50 = sel_getName(*(SEL *)(a1 + 72));
            *(_DWORD *)buf = 67109890;
            v68 = v48;
            v69 = 2082;
            v70 = v49;
            v71 = 2082;
            v72 = v50;
            v73 = 1024;
            v74 = 1683;
            _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to set mode to wired", buf, 0x22u);
          }

          v52 = NFSharedSignpostLog(v51);
          v53 = objc_claimAutoreleasedReturnValue(v52);
          if (os_signpost_enabled(v53))
          {
            *(_WORD *)buf = 0;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v53, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:getServiceProviderDataForApplet", "failure", buf, 2u);
          }

          v54 = *(_QWORD *)(a1 + 64);
          v55 = objc_alloc((Class)NSError);
          v23 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
          v63 = NSLocalizedDescriptionKey;
          v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unexpected Result"));
          v64 = v24;
          v25 = (id)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v64, &v63, 1));
          v56 = objc_msgSend(v55, "initWithDomain:code:userInfo:", v23, 13, v25);
          (*(void (**)(uint64_t, _QWORD, id))(v54 + 16))(v54, 0, v56);

        }
        goto LABEL_15;
      }
    }
  }
  v3 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v4 = NFLogGetLogger(v3);
  if (v4)
  {
    v5 = (void (*)(uint64_t, const char *, ...))v4;
    v6 = object_getClass(*(id *)(a1 + 32));
    v7 = class_isMetaClass(v6);
    v8 = object_getClassName(*(id *)(a1 + 32));
    v9 = sel_getName(*(SEL *)(a1 + 72));
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v11 = 45;
    if (v7)
      v11 = 43;
    v5(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v11, v8, v9, 1674, v10);

  }
  v12 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v13 = NFSharedLogGetLogger(v12);
  v14 = objc_claimAutoreleasedReturnValue(v13);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    v15 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v15))
      v16 = 43;
    else
      v16 = 45;
    v17 = object_getClassName(*(id *)(a1 + 32));
    v18 = sel_getName(*(SEL *)(a1 + 72));
    v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v68 = v16;
    v69 = 2082;
    v70 = v17;
    v71 = 2082;
    v72 = v18;
    v73 = 1024;
    v74 = 1674;
    v75 = 2114;
    v76 = v19;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v20 = *(_QWORD *)(a1 + 64);
  if (v20)
  {
    v21 = objc_alloc((Class)NSError);
    v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v65 = NSLocalizedDescriptionKey;
    v23 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v66 = v23;
    v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v66, &v65, 1));
    v25 = objc_msgSend(v21, "initWithDomain:code:userInfo:", v22, 54, v24);
    (*(void (**)(uint64_t, _QWORD, id))(v20 + 16))(v20, 0, v25);
LABEL_15:

  }
}

void sub_100167180(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  void *v19;
  uint64_t v20;
  void (*v21)(uint64_t, const char *, ...);
  objc_class *v22;
  _BOOL4 v23;
  const char *v24;
  const char *v25;
  void *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  NSObject *v30;
  objc_class *v31;
  int v32;
  const char *v33;
  const char *v34;
  void *v35;
  uint64_t v36;
  id v37;
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  uint64_t v43;
  id v44;
  void *v45;
  void *v46;
  void *v47;
  id v48;
  void *v49;
  uint64_t v50;
  void (*v51)(uint64_t, const char *, ...);
  objc_class *v52;
  _BOOL4 v53;
  const char *v54;
  const char *v55;
  uint64_t v56;
  void *v57;
  uint64_t v58;
  NSObject *v59;
  objc_class *v60;
  int v61;
  const char *v62;
  const char *v63;
  void *v64;
  uint64_t v65;
  void (*v66)(uint64_t, const char *, ...);
  objc_class *v67;
  _BOOL4 v68;
  const char *v69;
  uint64_t v70;
  void *v71;
  uint64_t v72;
  NSObject *v73;
  objc_class *v74;
  int v75;
  const char *v76;
  const char *v77;
  id v78;
  const char *v79;
  uint64_t v80;
  NSErrorUserInfoKey v81;
  void *v82;
  NSErrorUserInfoKey v83;
  void *v84;
  uint8_t buf[4];
  int v86;
  __int16 v87;
  const char *v88;
  __int16 v89;
  const char *v90;
  __int16 v91;
  int v92;
  __int16 v93;
  uint64_t v94;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v10 = 45;
    if (isMetaClass)
      v10 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@", v10, ClassName, Name, 1722, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 48));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    *(_DWORD *)buf = 67110146;
    v86 = v15;
    v87 = 2082;
    v88 = v16;
    v89 = 2082;
    v90 = v17;
    v91 = 1024;
    v92 = 1722;
    v93 = 2114;
    v94 = (uint64_t)v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);

  }
  v80 = -1;
  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v45 = *(void **)(a1 + 32);
    v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v45, "embeddedSecureElementWrapper"));
    LOBYTE(v45) = objc_msgSend(v45, "_activateSecureElementWrapper:", v46);

    if ((v45 & 1) != 0)
    {
      v47 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
      v48 = sub_1000A3258(v47, &v80);
      v38 = (void *)objc_claimAutoreleasedReturnValue(v48);

      v49 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v50 = NFLogGetLogger(v49);
      if (v50)
      {
        v51 = (void (*)(uint64_t, const char *, ...))v50;
        v52 = object_getClass(*(id *)(a1 + 32));
        v53 = class_isMetaClass(v52);
        v54 = object_getClassName(*(id *)(a1 + 32));
        v55 = sel_getName(*(SEL *)(a1 + 48));
        v56 = 45;
        if (v53)
          v56 = 43;
        v51(6, "%c[%{public}s %{public}s]:%i Counter = %lu, ", v56, v54, v55, 1735, v80);
      }
      v57 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v58 = NFSharedLogGetLogger(v57);
      v59 = objc_claimAutoreleasedReturnValue(v58);
      if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
      {
        v60 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v60))
          v61 = 43;
        else
          v61 = 45;
        v62 = object_getClassName(*(id *)(a1 + 32));
        v63 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)buf = 67110146;
        v86 = v61;
        v87 = 2082;
        v88 = v62;
        v89 = 2082;
        v90 = v63;
        v91 = 1024;
        v92 = 1735;
        v93 = 2048;
        v94 = v80;
        _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Counter = %lu, ", buf, 0x2Cu);
      }

      (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
      goto LABEL_25;
    }
    v64 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v65 = NFLogGetLogger(v64);
    if (v65)
    {
      v66 = (void (*)(uint64_t, const char *, ...))v65;
      v67 = object_getClass(*(id *)(a1 + 32));
      v68 = class_isMetaClass(v67);
      v69 = object_getClassName(*(id *)(a1 + 32));
      v79 = sel_getName(*(SEL *)(a1 + 48));
      v70 = 45;
      if (v68)
        v70 = 43;
      v66(3, "%c[%{public}s %{public}s]:%i Failed to set mode to wired", v70, v69, v79, 1729);
    }
    v71 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v72 = NFSharedLogGetLogger(v71);
    v73 = objc_claimAutoreleasedReturnValue(v72);
    if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
    {
      v74 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v74))
        v75 = 43;
      else
        v75 = 45;
      v76 = object_getClassName(*(id *)(a1 + 32));
      v77 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)buf = 67109890;
      v86 = v75;
      v87 = 2082;
      v88 = v76;
      v89 = 2082;
      v90 = v77;
      v91 = 1024;
      v92 = 1729;
      _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to set mode to wired", buf, 0x22u);
    }

    v36 = *(_QWORD *)(a1 + 40);
    v78 = objc_alloc((Class)NSError);
    v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v81 = NSLocalizedDescriptionKey;
    v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unexpected Result"));
    v82 = v39;
    v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v82, &v81, 1));
    v41 = v78;
    v42 = v38;
    v43 = 13;
LABEL_24:
    v44 = objc_msgSend(v41, "initWithDomain:code:userInfo:", v42, v43, v40);
    (*(void (**)(uint64_t, uint64_t, id))(v36 + 16))(v36, -1, v44);

LABEL_25:
    return;
  }
  v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v20 = NFLogGetLogger(v19);
  if (v20)
  {
    v21 = (void (*)(uint64_t, const char *, ...))v20;
    v22 = object_getClass(*(id *)(a1 + 32));
    v23 = class_isMetaClass(v22);
    v24 = object_getClassName(*(id *)(a1 + 32));
    v25 = sel_getName(*(SEL *)(a1 + 48));
    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v27 = 45;
    if (v23)
      v27 = 43;
    v21(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v27, v24, v25, 1726, v26);

  }
  v28 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v29 = NFSharedLogGetLogger(v28);
  v30 = objc_claimAutoreleasedReturnValue(v29);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
  {
    v31 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v31))
      v32 = 43;
    else
      v32 = 45;
    v33 = object_getClassName(*(id *)(a1 + 32));
    v34 = sel_getName(*(SEL *)(a1 + 48));
    v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v86 = v32;
    v87 = 2082;
    v88 = v33;
    v89 = 2082;
    v90 = v34;
    v91 = 1024;
    v92 = 1726;
    v93 = 2114;
    v94 = (uint64_t)v35;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v36 = *(_QWORD *)(a1 + 40);
  if (v36)
  {
    v37 = objc_alloc((Class)NSError);
    v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v83 = NSLocalizedDescriptionKey;
    v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v84 = v39;
    v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v84, &v83, 1));
    v41 = v37;
    v42 = v38;
    v43 = 54;
    goto LABEL_24;
  }
}

void sub_100167958(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  void *v19;
  uint64_t v20;
  void (*v21)(uint64_t, const char *, ...);
  objc_class *v22;
  _BOOL4 v23;
  const char *v24;
  const char *v25;
  void *v26;
  NSMutableDictionary *v27;
  void *v28;
  uint64_t v29;
  void *v30;
  uint64_t v31;
  NSObject *v32;
  objc_class *v33;
  int v34;
  const char *v35;
  const char *v36;
  void *v37;
  NSMutableDictionary *v38;
  void *v39;
  void *v40;
  uint64_t v41;
  void (*v42)(uint64_t, const char *, ...);
  objc_class *v43;
  _BOOL4 v44;
  const char *v45;
  const char *v46;
  void *v47;
  uint64_t v48;
  void *v49;
  uint64_t v50;
  NSObject *v51;
  objc_class *v52;
  int v53;
  const char *v54;
  const char *v55;
  void *v56;
  uint64_t v57;
  id v58;
  void *v59;
  void *v60;
  void *v61;
  id v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  NSMutableDictionary *v66;
  NSErrorUserInfoKey v67;
  void *v68;
  uint8_t buf[4];
  int v70;
  __int16 v71;
  const char *v72;
  __int16 v73;
  const char *v74;
  __int16 v75;
  int v76;
  __int16 v77;
  void *v78;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v10 = 45;
    if (isMetaClass)
      v10 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@", v10, ClassName, Name, 1745, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 48));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    *(_DWORD *)buf = 67110146;
    v70 = v15;
    v71 = 2082;
    v72 = v16;
    v73 = 2082;
    v74 = v17;
    v75 = 1024;
    v76 = 1745;
    v77 = 2114;
    v78 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);

  }
  v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v20 = NFLogGetLogger(v19);
  if (v20)
  {
    v21 = (void (*)(uint64_t, const char *, ...))v20;
    v22 = object_getClass(*(id *)(a1 + 32));
    v23 = class_isMetaClass(v22);
    v24 = object_getClassName(*(id *)(a1 + 32));
    v25 = sel_getName(*(SEL *)(a1 + 48));
    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "expressModeManager"));
    v27 = sub_100048378((uint64_t)v26);
    v28 = (void *)objc_claimAutoreleasedReturnValue(v27);
    v29 = 45;
    if (v23)
      v29 = 43;
    v21(6, "%c[%{public}s %{public}s]:%i express applets: %{public}@", v29, v24, v25, 1746, v28);

  }
  v30 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v31 = NFSharedLogGetLogger(v30);
  v32 = objc_claimAutoreleasedReturnValue(v31);
  if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
  {
    v33 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v33))
      v34 = 43;
    else
      v34 = 45;
    v35 = object_getClassName(*(id *)(a1 + 32));
    v36 = sel_getName(*(SEL *)(a1 + 48));
    v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "expressModeManager"));
    v38 = sub_100048378((uint64_t)v37);
    v39 = (void *)objc_claimAutoreleasedReturnValue(v38);
    *(_DWORD *)buf = 67110146;
    v70 = v34;
    v71 = 2082;
    v72 = v35;
    v73 = 2082;
    v74 = v36;
    v75 = 1024;
    v76 = 1746;
    v77 = 2114;
    v78 = v39;
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i express applets: %{public}@", buf, 0x2Cu);

  }
  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v63 = *(_QWORD *)(a1 + 40);
    v64 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "expressModeManager"));
    v59 = (void *)v64;
    if (v64)
      v65 = *(_QWORD *)(v64 + 136);
    else
      v65 = 0;
    v60 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "expressModeManager"));
    v66 = sub_100048378((uint64_t)v60);
    v61 = (void *)objc_claimAutoreleasedReturnValue(v66);
    (*(void (**)(uint64_t, uint64_t, void *, _QWORD))(v63 + 16))(v63, v65, v61, 0);
    goto LABEL_33;
  }
  v40 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v41 = NFLogGetLogger(v40);
  if (v41)
  {
    v42 = (void (*)(uint64_t, const char *, ...))v41;
    v43 = object_getClass(*(id *)(a1 + 32));
    v44 = class_isMetaClass(v43);
    v45 = object_getClassName(*(id *)(a1 + 32));
    v46 = sel_getName(*(SEL *)(a1 + 48));
    v47 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v48 = 45;
    if (v44)
      v48 = 43;
    v42(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v48, v45, v46, 1747, v47);

  }
  v49 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v50 = NFSharedLogGetLogger(v49);
  v51 = objc_claimAutoreleasedReturnValue(v50);
  if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
  {
    v52 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v52))
      v53 = 43;
    else
      v53 = 45;
    v54 = object_getClassName(*(id *)(a1 + 32));
    v55 = sel_getName(*(SEL *)(a1 + 48));
    v56 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v70 = v53;
    v71 = 2082;
    v72 = v54;
    v73 = 2082;
    v74 = v55;
    v75 = 1024;
    v76 = 1747;
    v77 = 2114;
    v78 = v56;
    _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v57 = *(_QWORD *)(a1 + 40);
  if (v57)
  {
    v58 = objc_alloc((Class)NSError);
    v59 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v67 = NSLocalizedDescriptionKey;
    v60 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v68 = v60;
    v61 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v68, &v67, 1));
    v62 = objc_msgSend(v58, "initWithDomain:code:userInfo:", v59, 54, v61);
    (*(void (**)(uint64_t, _QWORD, _QWORD, id))(v57 + 16))(v57, 0, 0, v62);

LABEL_33:
  }
}

void sub_100167FF0(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *v5;
  _BOOL4 v6;
  const char *v7;
  const char *v8;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  uint64_t v19;
  id v20;
  NFPeerPaymentEnrollmentResponse *v21;
  id v22;
  void *v23;
  void *v24;
  NFPeerPaymentEnrollmentResponse *v25;
  uint64_t v26;
  id v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  NSObject *v31;
  void *v32;
  void *v33;
  NSErrorUserInfoKey v34;
  uint64_t v35;
  NSMutableDictionary *v36;
  NSMutableDictionary *v37;
  void *v38;
  NSMutableDictionary *v39;
  void *v40;
  void *v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  void *v46;
  uint64_t v47;
  NSObject *v48;
  uint64_t v49;
  uint64_t v50;
  NSObject *v51;
  void *specific;
  uint64_t Logger;
  void (*v54)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v58;
  void *v59;
  uint64_t v60;
  NSObject *v61;
  objc_class *v62;
  int v63;
  const char *v64;
  const char *v65;
  id v66;
  const char *Name;
  id v68;
  _QWORD v69[2];
  _QWORD v70[2];
  NSErrorUserInfoKey v71;
  id v72;
  NSErrorUserInfoKey v73;
  id v74;
  uint8_t buf[4];
  int v76;
  __int16 v77;
  const char *v78;
  __int16 v79;
  const char *v80;
  __int16 v81;
  int v82;
  __int16 v83;
  void *v84;

  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "alternateDSID"));

    if (v28)
    {
      v30 = NFSharedSignpostLog(v29);
      v31 = objc_claimAutoreleasedReturnValue(v30);
      if (os_signpost_enabled(v31))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v31, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SURF_ENROLLMENT", "in", buf, 2u);
      }

      v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
      v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "alternateDSID"));
      v68 = 0;
      v34 = sub_10008DFD8(v32, v33, &v68);
      v23 = (void *)objc_claimAutoreleasedReturnValue(v34);
      v22 = v68;

      v21 = 0;
      if (!v23)
      {
        v36 = (NSMutableDictionary *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
        v37 = sub_100096974(v36);
        v38 = (void *)objc_claimAutoreleasedReturnValue(v37);

        v39 = objc_opt_new(NSMutableDictionary);
        v40 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v38, "objectForKeyedSubscript:", CFSTR("ECKA")));

        if (v40)
        {
          v41 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v38, "objectForKeyedSubscript:", CFSTR("ECKA")));
          -[NSMutableDictionary setObject:forKey:](v39, "setObject:forKey:", v41, CFSTR("ECC"));

        }
        v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v38, "objectForKeyedSubscript:", CFSTR("ECDSA")));

        if (v42)
        {
          v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v38, "objectForKeyedSubscript:", CFSTR("ECDSA")));
          -[NSMutableDictionary setObject:forKey:](v39, "setObject:forKey:", v43, CFSTR("ECDSA"));

        }
        v44 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v38, "objectForKeyedSubscript:", CFSTR("RSA")));

        if (v44)
        {
          v45 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v38, "objectForKeyedSubscript:", CFSTR("RSA")));
          -[NSMutableDictionary setObject:forKey:](v39, "setObject:forKey:", v45, CFSTR("RSA"));

        }
        v69[0] = CFSTR("paymentCertificate");
        v69[1] = CFSTR("certificates");
        v70[0] = v22;
        v70[1] = v39;
        v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v70, v69, 2));
        v21 = -[NFPeerPaymentEnrollmentResponse initWithDictionary:]([NFPeerPaymentEnrollmentResponse alloc], "initWithDictionary:", v46);

      }
      v47 = NFSharedSignpostLog(v35);
      v48 = objc_claimAutoreleasedReturnValue(v47);
      if (os_signpost_enabled(v48))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v48, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SURF_ENROLLMENT", "user callback", buf, 2u);
      }

      v49 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
      v50 = NFSharedSignpostLog(v49);
      v51 = objc_claimAutoreleasedReturnValue(v50);
      if (os_signpost_enabled(v51))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v51, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SURF_ENROLLMENT", "out", buf, 2u);
      }

      v27 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
      sub_10008DA38(v27);
      goto LABEL_16;
    }
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v54 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      v58 = 45;
      if (isMetaClass)
        v58 = 43;
      v54(3, "%c[%{public}s %{public}s]:%i Invalid authtoken parameter : nil", v58, ClassName, Name, 1761);
    }
    v59 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v60 = NFSharedLogGetLogger(v59);
    v61 = objc_claimAutoreleasedReturnValue(v60);
    if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
    {
      v62 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v62))
        v63 = 43;
      else
        v63 = 45;
      v64 = object_getClassName(*(id *)(a1 + 32));
      v65 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)buf = 67109890;
      v76 = v63;
      v77 = 2082;
      v78 = v64;
      v79 = 2082;
      v80 = v65;
      v81 = 1024;
      v82 = 1761;
      _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid authtoken parameter : nil", buf, 0x22u);
    }

    v19 = *(_QWORD *)(a1 + 48);
    v66 = objc_alloc((Class)NSError);
    v21 = (NFPeerPaymentEnrollmentResponse *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v71 = NSLocalizedDescriptionKey;
    v22 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Missing Parameter"));
    v72 = v22;
    v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v72, &v71, 1));
    v24 = v66;
    v25 = v21;
    v26 = 9;
LABEL_15:
    v27 = objc_msgSend(v24, "initWithDomain:code:userInfo:", v25, v26, v23);
    (*(void (**)(uint64_t, _QWORD, id))(v19 + 16))(v19, 0, v27);
LABEL_16:

    return;
  }
  v2 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v3 = NFLogGetLogger(v2);
  if (v3)
  {
    v4 = (void (*)(uint64_t, const char *, ...))v3;
    v5 = object_getClass(*(id *)(a1 + 32));
    v6 = class_isMetaClass(v5);
    v7 = object_getClassName(*(id *)(a1 + 32));
    v8 = sel_getName(*(SEL *)(a1 + 56));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v10 = 45;
    if (v6)
      v10 = 43;
    v4(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v10, v7, v8, 1758, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 56));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v76 = v15;
    v77 = 2082;
    v78 = v16;
    v79 = 2082;
    v80 = v17;
    v81 = 1024;
    v82 = 1758;
    v83 = 2114;
    v84 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v19 = *(_QWORD *)(a1 + 48);
  if (v19)
  {
    v20 = objc_alloc((Class)NSError);
    v21 = (NFPeerPaymentEnrollmentResponse *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v73 = NSLocalizedDescriptionKey;
    v22 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v74 = v22;
    v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v74, &v73, 1));
    v24 = v20;
    v25 = v21;
    v26 = 54;
    goto LABEL_15;
  }
}

void sub_100168824(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  void *v19;
  uint64_t v20;
  void (*v21)(uint64_t, const char *, ...);
  objc_class *v22;
  _BOOL4 v23;
  const char *v24;
  const char *v25;
  void *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  NSObject *v30;
  objc_class *v31;
  int v32;
  const char *v33;
  const char *v34;
  void *v35;
  uint64_t v36;
  id v37;
  id v38;
  void *v39;
  void *v40;
  id v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  void *v46;
  id v47;
  void *v48;
  id v49;
  id v50;
  void *v51;
  _QWORD v52[4];
  _QWORD v53[4];
  NSErrorUserInfoKey v54;
  void *v55;
  uint8_t buf[4];
  int v57;
  __int16 v58;
  const char *v59;
  __int16 v60;
  const char *v61;
  __int16 v62;
  int v63;
  __int16 v64;
  void *v65;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v10 = 45;
    if (isMetaClass)
      v10 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@", v10, ClassName, Name, 1804, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 56));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    *(_DWORD *)buf = 67110146;
    v57 = v15;
    v58 = 2082;
    v59 = v16;
    v60 = 2082;
    v61 = v17;
    v62 = 1024;
    v63 = 1804;
    v64 = 2114;
    v65 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);

  }
  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v42 = *(void **)(a1 + 40);
    v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 208), "serialNumber"));
    if (objc_msgSend(v42, "isEqualToString:", v43))
    {

    }
    else
    {
      v44 = *(void **)(a1 + 40);
      v45 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 208), "systemOSSerialNumber"));
      LODWORD(v44) = objc_msgSend(v44, "isEqualToString:", v45);

      if (!(_DWORD)v44)
      {
        v47 = objc_alloc((Class)NSError);
        v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v52[0] = NSLocalizedDescriptionKey;
        v48 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "SE not available"));
        v53[0] = v48;
        v53[1] = &off_1002FFF78;
        v52[1] = CFSTR("Line");
        v52[2] = CFSTR("Method");
        v49 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
        v53[2] = v49;
        v52[3] = NSDebugDescriptionErrorKey;
        v50 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 1810);
        v53[3] = v50;
        v51 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v53, v52, 4));
        v38 = objc_msgSend(v47, "initWithDomain:code:userInfo:", v46, 35, v51);

        goto LABEL_31;
      }
    }
    v46 = (void *)objc_claimAutoreleasedReturnValue(+[_NFHardwareManager sharedHardwareManager](_NFHardwareManager, "sharedHardwareManager"));
    v38 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v46, "powerCycleSE:", *(_QWORD *)(*(_QWORD *)(a1 + 32)
                                                                                             + 208)));
LABEL_31:

    (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
    goto LABEL_24;
  }
  v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v20 = NFLogGetLogger(v19);
  if (v20)
  {
    v21 = (void (*)(uint64_t, const char *, ...))v20;
    v22 = object_getClass(*(id *)(a1 + 32));
    v23 = class_isMetaClass(v22);
    v24 = object_getClassName(*(id *)(a1 + 32));
    v25 = sel_getName(*(SEL *)(a1 + 56));
    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v27 = 45;
    if (v23)
      v27 = 43;
    v21(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v27, v24, v25, 1805, v26);

  }
  v28 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v29 = NFSharedLogGetLogger(v28);
  v30 = objc_claimAutoreleasedReturnValue(v29);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
  {
    v31 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v31))
      v32 = 43;
    else
      v32 = 45;
    v33 = object_getClassName(*(id *)(a1 + 32));
    v34 = sel_getName(*(SEL *)(a1 + 56));
    v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v57 = v32;
    v58 = 2082;
    v59 = v33;
    v60 = 2082;
    v61 = v34;
    v62 = 1024;
    v63 = 1805;
    v64 = 2114;
    v65 = v35;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v36 = *(_QWORD *)(a1 + 48);
  if (v36)
  {
    v37 = objc_alloc((Class)NSError);
    v38 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v54 = NSLocalizedDescriptionKey;
    v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v55 = v39;
    v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v55, &v54, 1));
    v41 = objc_msgSend(v37, "initWithDomain:code:userInfo:", v38, 54, v40);
    (*(void (**)(uint64_t, id))(v36 + 16))(v36, v41);

LABEL_24:
  }
}

void sub_100168ECC(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  void *v19;
  uint64_t v20;
  void (*v21)(uint64_t, const char *, ...);
  objc_class *v22;
  _BOOL4 v23;
  const char *v24;
  const char *v25;
  void *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  NSObject *v30;
  objc_class *v31;
  int v32;
  const char *v33;
  const char *v34;
  void *v35;
  uint64_t v36;
  id v37;
  void *v38;
  id v39;
  void *v40;
  id v41;
  id v42;
  void *v43;
  void *v44;
  id v45;
  void *v46;
  id v47;
  id v48;
  uint64_t v49;
  void *v50;
  uint64_t v51;
  void (*v52)(uint64_t, const char *, ...);
  objc_class *v53;
  _BOOL4 v54;
  const char *v55;
  uint64_t v56;
  void *v57;
  uint64_t v58;
  NSObject *v59;
  objc_class *v60;
  int v61;
  const char *v62;
  const char *v63;
  uint64_t v64;
  id v65;
  void *v66;
  id v67;
  id v68;
  uint64_t v69;
  void *v70;
  void *v71;
  id v72;
  void *v73;
  id v74;
  id v75;
  void *v76;
  id v77;
  const char *v78;
  id v79;
  id v80;
  unsigned __int8 v81;
  NSErrorUserInfoKey v82;
  void *v83;
  _QWORD v84[5];
  _QWORD v85[5];
  NSErrorUserInfoKey v86;
  void *v87;
  NSErrorUserInfoKey v88;
  id v89;
  uint8_t buf[4];
  int v91;
  __int16 v92;
  const char *v93;
  __int16 v94;
  const char *v95;
  __int16 v96;
  int v97;
  __int16 v98;
  void *v99;

  v81 = 0;
  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v10 = 45;
    if (isMetaClass)
      v10 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@", v10, ClassName, Name, 1824, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 56));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    *(_DWORD *)buf = 67110146;
    v91 = v15;
    v92 = 2082;
    v93 = v16;
    v94 = 2082;
    v95 = v17;
    v96 = 1024;
    v97 = 1824;
    v98 = 2114;
    v99 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);

  }
  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "_getSecureElementWrapperForSEID:", *(_QWORD *)(a1 + 40)));
    if ((objc_msgSend(*(id *)(a1 + 32), "_activateSecureElementWrapper:", v38) & 1) == 0)
    {
      v50 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v51 = NFLogGetLogger(v50);
      if (v51)
      {
        v52 = (void (*)(uint64_t, const char *, ...))v51;
        v53 = object_getClass(*(id *)(a1 + 32));
        v54 = class_isMetaClass(v53);
        v55 = object_getClassName(*(id *)(a1 + 32));
        v78 = sel_getName(*(SEL *)(a1 + 56));
        v56 = 45;
        if (v54)
          v56 = 43;
        v52(3, "%c[%{public}s %{public}s]:%i Failed to activate embedded secure element", v56, v55, v78, 1830);
      }
      v57 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v58 = NFSharedLogGetLogger(v57);
      v59 = objc_claimAutoreleasedReturnValue(v58);
      if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
      {
        v60 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v60))
          v61 = 43;
        else
          v61 = 45;
        v62 = object_getClassName(*(id *)(a1 + 32));
        v63 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)buf = 67109890;
        v91 = v61;
        v92 = 2082;
        v93 = v62;
        v94 = 2082;
        v95 = v63;
        v96 = 1024;
        v97 = 1830;
        _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to activate embedded secure element", buf, 0x22u);
      }

      v64 = *(_QWORD *)(a1 + 48);
      v65 = objc_alloc((Class)NSError);
      v39 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v86 = NSLocalizedDescriptionKey;
      v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
      v87 = v40;
      v66 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v87, &v86, 1));
      v67 = objc_msgSend(v65, "initWithDomain:code:userInfo:", v39, 15, v66);
      (*(void (**)(uint64_t, _QWORD, id))(v64 + 16))(v64, 0, v67);

      goto LABEL_25;
    }
    v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary"));
    v42 = sub_1000A0E48(v38, (uint64_t)&v81);
    v43 = (void *)objc_claimAutoreleasedReturnValue(v42);

    if (!v43)
    {
      v44 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v81));
      objc_msgSend(v40, "setObject:forKeyedSubscript:", v44, CFSTR("Presence"));

    }
    v80 = 0;
    v45 = sub_1000A0078(v38, &v80);
    v46 = (void *)objc_claimAutoreleasedReturnValue(v45);
    v39 = v80;
    objc_msgSend(v40, "addEntriesFromDictionary:", v46);

    if (*(_BYTE *)(a1 + 64))
      v47 = sub_1000A018C(v38);
    v48 = objc_msgSend(v40, "count");
    v49 = *(_QWORD *)(a1 + 48);
    if ((unint64_t)v48 >= 2)
    {
      (*(void (**)(_QWORD, void *, id))(v49 + 16))(*(_QWORD *)(a1 + 48), v40, v39);
      goto LABEL_25;
    }
    v68 = objc_alloc((Class)NSError);
    v41 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    if (!v39)
    {
      v82 = NSLocalizedDescriptionKey;
      v70 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unexpected Result"));
      v83 = v70;
      v71 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v83, &v82, 1));
      v72 = objc_msgSend(v68, "initWithDomain:code:userInfo:", v41, 13, v71);
      (*(void (**)(uint64_t, _QWORD, id))(v49 + 16))(v49, 0, v72);

      v39 = 0;
      goto LABEL_25;
    }
    v79 = objc_msgSend(v39, "code");
    v84[0] = NSLocalizedDescriptionKey;
    if ((uint64_t)objc_msgSend(v39, "code") > 70)
      v69 = 71;
    else
      v69 = (uint64_t)objc_msgSend(v39, "code");
    v73 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E9508[v69]));
    v85[0] = v73;
    v85[1] = v39;
    v84[1] = NSUnderlyingErrorKey;
    v84[2] = CFSTR("Line");
    v85[2] = &off_1002FFF90;
    v84[3] = CFSTR("Method");
    v74 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v85[3] = v74;
    v84[4] = NSDebugDescriptionErrorKey;
    v75 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 1849);
    v85[4] = v75;
    v76 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v85, v84, 5));
    v77 = objc_msgSend(v68, "initWithDomain:code:userInfo:", v41, v79, v76);
    (*(void (**)(uint64_t, _QWORD, id))(v49 + 16))(v49, 0, v77);

LABEL_24:
LABEL_25:

    return;
  }
  v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v20 = NFLogGetLogger(v19);
  if (v20)
  {
    v21 = (void (*)(uint64_t, const char *, ...))v20;
    v22 = object_getClass(*(id *)(a1 + 32));
    v23 = class_isMetaClass(v22);
    v24 = object_getClassName(*(id *)(a1 + 32));
    v25 = sel_getName(*(SEL *)(a1 + 56));
    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v27 = 45;
    if (v23)
      v27 = 43;
    v21(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v27, v24, v25, 1826, v26);

  }
  v28 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v29 = NFSharedLogGetLogger(v28);
  v30 = objc_claimAutoreleasedReturnValue(v29);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
  {
    v31 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v31))
      v32 = 43;
    else
      v32 = 45;
    v33 = object_getClassName(*(id *)(a1 + 32));
    v34 = sel_getName(*(SEL *)(a1 + 56));
    v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v91 = v32;
    v92 = 2082;
    v93 = v33;
    v94 = 2082;
    v95 = v34;
    v96 = 1024;
    v97 = 1826;
    v98 = 2114;
    v99 = v35;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v36 = *(_QWORD *)(a1 + 48);
  if (v36)
  {
    v37 = objc_alloc((Class)NSError);
    v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v88 = NSLocalizedDescriptionKey;
    v39 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v89 = v39;
    v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v89, &v88, 1));
    v41 = objc_msgSend(v37, "initWithDomain:code:userInfo:", v38, 54, v40);
    (*(void (**)(uint64_t, _QWORD, id))(v36 + 16))(v36, 0, v41);
    goto LABEL_24;
  }
}

void sub_10016988C(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  void *v19;
  uint64_t v20;
  void (*v21)(uint64_t, const char *, ...);
  objc_class *v22;
  _BOOL4 v23;
  const char *v24;
  const char *v25;
  void *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  NSObject *v30;
  objc_class *v31;
  int v32;
  const char *v33;
  const char *v34;
  void *v35;
  uint64_t v36;
  id v37;
  void *v38;
  void *v39;
  void *v40;
  id v41;
  id v42;
  void *v43;
  uint64_t v44;
  void (*v45)(uint64_t, const char *, ...);
  objc_class *v46;
  _BOOL4 v47;
  const char *v48;
  uint64_t v49;
  void *v50;
  uint64_t v51;
  NSObject *v52;
  objc_class *v53;
  int v54;
  const char *v55;
  const char *v56;
  uint64_t v57;
  id v58;
  id v59;
  id v60;
  void *v61;
  id v62;
  const char *v63;
  char v64;
  _QWORD v65[4];
  _QWORD v66[4];
  NSErrorUserInfoKey v67;
  void *v68;
  uint8_t buf[4];
  int v70;
  __int16 v71;
  const char *v72;
  __int16 v73;
  const char *v74;
  __int16 v75;
  int v76;
  __int16 v77;
  void *v78;

  v64 = 0;
  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v10 = 45;
    if (isMetaClass)
      v10 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@", v10, ClassName, Name, 1860, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 56));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    *(_DWORD *)buf = 67110146;
    v70 = v15;
    v71 = 2082;
    v72 = v16;
    v73 = 2082;
    v74 = v17;
    v75 = 1024;
    v76 = 1860;
    v77 = 2114;
    v78 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);

  }
  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "_getSecureElementWrapperForSEID:", *(_QWORD *)(a1 + 40)));
    if ((objc_msgSend(*(id *)(a1 + 32), "_activateSecureElementWrapper:", v38) & 1) != 0)
    {
      v42 = sub_1000A0E48(v38, (uint64_t)&v64);
      v39 = (void *)objc_claimAutoreleasedReturnValue(v42);
      (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
      goto LABEL_25;
    }
    v43 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v44 = NFLogGetLogger(v43);
    if (v44)
    {
      v45 = (void (*)(uint64_t, const char *, ...))v44;
      v46 = object_getClass(*(id *)(a1 + 32));
      v47 = class_isMetaClass(v46);
      v48 = object_getClassName(*(id *)(a1 + 32));
      v63 = sel_getName(*(SEL *)(a1 + 56));
      v49 = 45;
      if (v47)
        v49 = 43;
      v45(3, "%c[%{public}s %{public}s]:%i Failed to activate embedded secure element", v49, v48, v63, 1866);
    }
    v50 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v51 = NFSharedLogGetLogger(v50);
    v52 = objc_claimAutoreleasedReturnValue(v51);
    if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
    {
      v53 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v53))
        v54 = 43;
      else
        v54 = 45;
      v55 = object_getClassName(*(id *)(a1 + 32));
      v56 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)buf = 67109890;
      v70 = v54;
      v71 = 2082;
      v72 = v55;
      v73 = 2082;
      v74 = v56;
      v75 = 1024;
      v76 = 1866;
      _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to activate embedded secure element", buf, 0x22u);
    }

    v57 = *(_QWORD *)(a1 + 48);
    v58 = objc_alloc((Class)NSError);
    v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v65[0] = NSLocalizedDescriptionKey;
    v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
    v66[0] = v40;
    v66[1] = &off_1002FFFA8;
    v65[1] = CFSTR("Line");
    v65[2] = CFSTR("Method");
    v59 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v66[2] = v59;
    v65[3] = NSDebugDescriptionErrorKey;
    v60 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 1867);
    v66[3] = v60;
    v61 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v66, v65, 4));
    v62 = objc_msgSend(v58, "initWithDomain:code:userInfo:", v39, 15, v61);
    (*(void (**)(uint64_t, _QWORD, id))(v57 + 16))(v57, 0, v62);

LABEL_24:
LABEL_25:

    return;
  }
  v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v20 = NFLogGetLogger(v19);
  if (v20)
  {
    v21 = (void (*)(uint64_t, const char *, ...))v20;
    v22 = object_getClass(*(id *)(a1 + 32));
    v23 = class_isMetaClass(v22);
    v24 = object_getClassName(*(id *)(a1 + 32));
    v25 = sel_getName(*(SEL *)(a1 + 56));
    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v27 = 45;
    if (v23)
      v27 = 43;
    v21(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v27, v24, v25, 1862, v26);

  }
  v28 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v29 = NFSharedLogGetLogger(v28);
  v30 = objc_claimAutoreleasedReturnValue(v29);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
  {
    v31 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v31))
      v32 = 43;
    else
      v32 = 45;
    v33 = object_getClassName(*(id *)(a1 + 32));
    v34 = sel_getName(*(SEL *)(a1 + 56));
    v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v70 = v32;
    v71 = 2082;
    v72 = v33;
    v73 = 2082;
    v74 = v34;
    v75 = 1024;
    v76 = 1862;
    v77 = 2114;
    v78 = v35;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v36 = *(_QWORD *)(a1 + 48);
  if (v36)
  {
    v37 = objc_alloc((Class)NSError);
    v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v67 = NSLocalizedDescriptionKey;
    v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v68 = v39;
    v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v68, &v67, 1));
    v41 = objc_msgSend(v37, "initWithDomain:code:userInfo:", v38, 54, v40);
    (*(void (**)(uint64_t, _QWORD, id))(v36 + 16))(v36, 0, v41);

    goto LABEL_24;
  }
}

void sub_10016A014(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *v5;
  _BOOL4 v6;
  const char *v7;
  const char *v8;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  uint64_t v19;
  id v20;
  NSMutableDictionary *v21;
  id v22;
  void *v23;
  id v24;
  uint64_t v25;
  NSString *v26;
  id v27;
  void *v28;
  void *specific;
  uint64_t Logger;
  void (*v31)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v35;
  void *v36;
  uint64_t v37;
  NSObject *v38;
  objc_class *v39;
  int v40;
  const char *v41;
  const char *v42;
  uint64_t v43;
  id v44;
  void *v45;
  id v46;
  const char *Name;
  id v48;
  NSErrorUserInfoKey v49;
  void *v50;
  NSErrorUserInfoKey v51;
  id v52;
  uint8_t buf[4];
  int v54;
  __int16 v55;
  const char *v56;
  __int16 v57;
  const char *v58;
  __int16 v59;
  int v60;
  __int16 v61;
  void *v62;

  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v21 = (NSMutableDictionary *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "_getSecureElementWrapperForSEID:", *(_QWORD *)(a1 + 40)));
    if ((objc_msgSend(*(id *)(a1 + 32), "_activateSecureElementWrapper:", v21) & 1) != 0)
    {
      v25 = *(unsigned __int8 *)(a1 + 64);
      v48 = 0;
      v26 = sub_1000993E4(v21, v25, &v48);
      v23 = (void *)objc_claimAutoreleasedReturnValue(v26);
      v22 = v48;
      if (v23)
      {
        v27 = 0;
        v28 = v23;
      }
      else
      {
        v27 = v22;
        v28 = 0;
      }
      (*(void (**)(_QWORD, id, void *))(*(_QWORD *)(a1 + 48) + 16))(*(_QWORD *)(a1 + 48), v27, v28);
    }
    else
    {
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v31 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(*(id *)(a1 + 32));
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(*(id *)(a1 + 32));
        Name = sel_getName(*(SEL *)(a1 + 56));
        v35 = 45;
        if (isMetaClass)
          v35 = 43;
        v31(3, "%c[%{public}s %{public}s]:%i Failed to activate secure element", v35, ClassName, Name, 1891);
      }
      v36 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v37 = NFSharedLogGetLogger(v36);
      v38 = objc_claimAutoreleasedReturnValue(v37);
      if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
      {
        v39 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v39))
          v40 = 43;
        else
          v40 = 45;
        v41 = object_getClassName(*(id *)(a1 + 32));
        v42 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)buf = 67109890;
        v54 = v40;
        v55 = 2082;
        v56 = v41;
        v57 = 2082;
        v58 = v42;
        v59 = 1024;
        v60 = 1891;
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to activate secure element", buf, 0x22u);
      }

      v43 = *(_QWORD *)(a1 + 48);
      v44 = objc_alloc((Class)NSError);
      v22 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v49 = NSLocalizedDescriptionKey;
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
      v50 = v23;
      v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v50, &v49, 1));
      v46 = objc_msgSend(v44, "initWithDomain:code:userInfo:", v22, 15, v45);
      (*(void (**)(uint64_t, _QWORD, id))(v43 + 16))(v43, 0, v46);

    }
    goto LABEL_15;
  }
  v2 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v3 = NFLogGetLogger(v2);
  if (v3)
  {
    v4 = (void (*)(uint64_t, const char *, ...))v3;
    v5 = object_getClass(*(id *)(a1 + 32));
    v6 = class_isMetaClass(v5);
    v7 = object_getClassName(*(id *)(a1 + 32));
    v8 = sel_getName(*(SEL *)(a1 + 56));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v10 = 45;
    if (v6)
      v10 = 43;
    v4(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v10, v7, v8, 1885, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 56));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v54 = v15;
    v55 = 2082;
    v56 = v16;
    v57 = 2082;
    v58 = v17;
    v59 = 1024;
    v60 = 1885;
    v61 = 2114;
    v62 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v19 = *(_QWORD *)(a1 + 48);
  if (v19)
  {
    v20 = objc_alloc((Class)NSError);
    v21 = (NSMutableDictionary *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v51 = NSLocalizedDescriptionKey;
    v22 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v52 = v22;
    v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v52, &v51, 1));
    v24 = objc_msgSend(v20, "initWithDomain:code:userInfo:", v21, 54, v23);
    (*(void (**)(uint64_t, _QWORD, id))(v19 + 16))(v19, 0, v24);

LABEL_15:
  }
}

void sub_10016A5A4(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *v5;
  _BOOL4 v6;
  const char *v7;
  const char *v8;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  uint64_t v19;
  id v20;
  id v21;
  void *v22;
  void *v23;
  void *v24;
  id v25;
  uint64_t v26;
  id v27;
  void *v28;
  void *v29;
  void *v30;
  id v31;
  id v32;
  id v33;
  void *v34;
  id v35;
  uint64_t v36;
  void *specific;
  uint64_t Logger;
  void (*v39)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v43;
  void *v44;
  uint64_t v45;
  NSObject *v46;
  objc_class *v47;
  int v48;
  const char *v49;
  const char *v50;
  id v51;
  void *v52;
  id v53;
  id v54;
  void *v55;
  const char *Name;
  id v57;
  _QWORD v58[5];
  _QWORD v59[5];
  NSErrorUserInfoKey v60;
  void *v61;
  NSErrorUserInfoKey v62;
  void *v63;
  uint8_t buf[4];
  int v65;
  __int16 v66;
  const char *v67;
  __int16 v68;
  const char *v69;
  __int16 v70;
  int v71;
  __int16 v72;
  void *v73;

  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v28 = *(void **)(a1 + 32);
    v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "embeddedSecureElementWrapper"));
    LOBYTE(v28) = objc_msgSend(v28, "_activateSecureElementWrapper:", v29);

    if ((v28 & 1) != 0)
    {
      v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "embeddedSecureElementWrapper"));
      v57 = 0;
      v31 = sub_10009FE58(v30, &v57);
      v22 = (void *)objc_claimAutoreleasedReturnValue(v31);
      v32 = v57;

      if (v32)
      {
        v33 = objc_alloc((Class)NSError);
        v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v35 = objc_msgSend(v32, "code");
        v58[0] = NSLocalizedDescriptionKey;
        if ((uint64_t)objc_msgSend(v32, "code") > 70)
          v36 = 71;
        else
          v36 = (uint64_t)objc_msgSend(v32, "code");
        v52 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E9508[v36]));
        v59[0] = v52;
        v59[1] = v32;
        v58[1] = NSUnderlyingErrorKey;
        v58[2] = CFSTR("Line");
        v59[2] = &off_1002FFFC0;
        v58[3] = CFSTR("Method");
        v53 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 48)));
        v59[3] = v53;
        v58[4] = NSDebugDescriptionErrorKey;
        v54 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 48)), 1920);
        v59[4] = v54;
        v55 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v59, v58, 5));
        v21 = objc_msgSend(v33, "initWithDomain:code:userInfo:", v34, v35, v55);

      }
      else
      {
        v21 = 0;
      }
      (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
      goto LABEL_16;
    }
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v39 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      v43 = 45;
      if (isMetaClass)
        v43 = 43;
      v39(3, "%c[%{public}s %{public}s]:%i Failed to activate embedded secure element", v43, ClassName, Name, 1912);
    }
    v44 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v45 = NFSharedLogGetLogger(v44);
    v46 = objc_claimAutoreleasedReturnValue(v45);
    if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
    {
      v47 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v47))
        v48 = 43;
      else
        v48 = 45;
      v49 = object_getClassName(*(id *)(a1 + 32));
      v50 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)buf = 67109890;
      v65 = v48;
      v66 = 2082;
      v67 = v49;
      v68 = 2082;
      v69 = v50;
      v70 = 1024;
      v71 = 1912;
      _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to activate embedded secure element", buf, 0x22u);
    }

    v19 = *(_QWORD *)(a1 + 40);
    v51 = objc_alloc((Class)NSError);
    v21 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v60 = NSLocalizedDescriptionKey;
    v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
    v61 = v22;
    v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v61, &v60, 1));
    v24 = v51;
    v25 = v21;
    v26 = 15;
LABEL_15:
    v27 = objc_msgSend(v24, "initWithDomain:code:userInfo:", v25, v26, v23);
    (*(void (**)(uint64_t, _QWORD, id))(v19 + 16))(v19, 0, v27);

LABEL_16:
    return;
  }
  v2 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v3 = NFLogGetLogger(v2);
  if (v3)
  {
    v4 = (void (*)(uint64_t, const char *, ...))v3;
    v5 = object_getClass(*(id *)(a1 + 32));
    v6 = class_isMetaClass(v5);
    v7 = object_getClassName(*(id *)(a1 + 32));
    v8 = sel_getName(*(SEL *)(a1 + 48));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v10 = 45;
    if (v6)
      v10 = 43;
    v4(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v10, v7, v8, 1909, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 48));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v65 = v15;
    v66 = 2082;
    v67 = v16;
    v68 = 2082;
    v69 = v17;
    v70 = 1024;
    v71 = 1909;
    v72 = 2114;
    v73 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v19 = *(_QWORD *)(a1 + 40);
  if (v19)
  {
    v20 = objc_alloc((Class)NSError);
    v21 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v62 = NSLocalizedDescriptionKey;
    v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v63 = v22;
    v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v63, &v62, 1));
    v24 = v20;
    v25 = v21;
    v26 = 54;
    goto LABEL_15;
  }
}

NSXPCInterface *sub_10016D6AC(uint64_t a1)
{
  objc_opt_self(a1);
  return +[NSXPCInterface interfaceWithProtocol:](NSXPCInterface, "interfaceWithProtocol:", &OBJC_PROTOCOL___NFReaderSessionAccessoryInterface);
}

id sub_10016D6D0(uint64_t a1)
{
  void *v1;
  id v2;
  uint64_t v3;
  id v4;

  objc_opt_self(a1);
  v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSXPCInterface interfaceWithProtocol:](NSXPCInterface, "interfaceWithProtocol:", &OBJC_PROTOCOL___NFReaderSessionAccessoryCallbacks));
  v2 = objc_alloc((Class)NSSet);
  v3 = objc_opt_class(NSArray);
  v4 = objc_msgSend(v2, "initWithObjects:", v3, objc_opt_class(NFTagInternal), 0);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v4, "didDetectTags:", 0, 0);

  return v1;
}

void sub_10016DAB0(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  id v11;
  void *v12;
  _BOOL4 v13;
  id v14;
  NFAssertPowerUp *v15;
  _BOOL4 v16;
  void *v17;
  void *v18;
  id v19;
  _BOOL8 v20;
  id *v21;
  char v22;
  NFAssertPowerUp *v23;
  NSMutableArray *v24;
  SEL v25;
  SEL v26;
  id v27;
  uint64_t v28;
  void *i;
  void *v30;
  void *v31;
  id v32;
  id v33;
  uint64_t v34;
  void *j;
  void *v36;
  void *v37;
  void (*v38)(uint64_t, const char *, ...);
  objc_class *v39;
  uint64_t v40;
  const char *v41;
  const char *v42;
  void *v43;
  uint64_t v44;
  NSObject *v45;
  objc_class *v46;
  int v47;
  const char *v48;
  const char *v49;
  const char *v50;
  id v51;
  void *v52;
  id v53;
  uint64_t v54;
  void *v55;
  void (*v56)(uint64_t, const char *, ...);
  objc_class *v57;
  uint64_t v58;
  const char *v59;
  const char *v60;
  void *v61;
  uint64_t v62;
  NSObject *v63;
  objc_class *v64;
  int v65;
  const char *v66;
  const char *v67;
  id v68;
  id v69;
  void *v70;
  void *v71;
  void *v72;
  id v73;
  void *v74;
  void (*v75)(uint64_t, const char *, ...);
  objc_class *v76;
  uint64_t v77;
  const char *v78;
  const char *v79;
  void *v80;
  uint64_t v81;
  NSObject *v82;
  objc_class *v83;
  int v84;
  const char *v85;
  const char *v86;
  id v87;
  void *v88;
  void *v89;
  id v90;
  id v91;
  void *v92;
  id v93;
  void *v94;
  void (*v95)(uint64_t, const char *, ...);
  objc_class *v96;
  uint64_t v97;
  const char *v98;
  const char *v99;
  void *v100;
  uint64_t v101;
  NSObject *v102;
  objc_class *v103;
  int v104;
  const char *v105;
  const char *v106;
  id v107;
  void *v108;
  void *v109;
  id v110;
  id v111;
  void *v112;
  id v113;
  void *specific;
  void (*Logger)(uint64_t, const char *, ...);
  objc_class *Class;
  uint64_t v117;
  const char *ClassName;
  const char *Name;
  void *v120;
  uint64_t v121;
  NSObject *v122;
  objc_class *v123;
  int v124;
  const char *v125;
  const char *v126;
  id v127;
  void *v128;
  void *v129;
  id v130;
  id v131;
  void *v132;
  id v133;
  id v134;
  void *v135;
  void *v136;
  _BOOL4 v137;
  NSMutableArray *v138;
  void *v139;
  void *v140;
  void *v141;
  void *v142;
  void (*v143)(uint64_t, const char *, ...);
  objc_class *v144;
  uint64_t v145;
  const char *v146;
  const char *v147;
  id v148;
  void *v149;
  void *v150;
  uint64_t v151;
  NSObject *v152;
  objc_class *v153;
  int v154;
  const char *v155;
  const char *v156;
  unsigned int v157;
  void *v158;
  void *v159;
  uint64_t v160;
  id v161;
  id v162;
  void *v163;
  id v164;
  id v165;
  NFAssertPowerUp *v166;
  id v167;
  void *v168;
  id v170;
  void (**v171)(id, _QWORD, id);
  void *v172;
  id *self;
  id v174;
  id obj;
  id v176;
  _QWORD v177[5];
  id v178;
  __int128 v179;
  __int128 v180;
  __int128 v181;
  __int128 v182;
  __int128 v183;
  __int128 v184;
  __int128 v185;
  __int128 v186;
  _QWORD v187[5];
  _QWORD v188[5];
  _QWORD v189[4];
  _QWORD v190[4];
  _QWORD v191[4];
  _QWORD v192[4];
  _QWORD v193[4];
  _QWORD v194[4];
  NSErrorUserInfoKey v195;
  void *v196;
  _QWORD v197[3];
  _QWORD v198[3];
  NSErrorUserInfoKey v199;
  void *v200;
  uint64_t v201;
  uint64_t *v202;
  uint64_t v203;
  uint64_t (*v204)(uint64_t, uint64_t);
  void (*v205)(uint64_t);
  id v206;
  uint8_t buf[4];
  int v208;
  __int16 v209;
  const char *v210;
  __int16 v211;
  const char *v212;
  __int16 v213;
  int v214;
  __int16 v215;
  void *v216;
  __int16 v217;
  unsigned int v218;
  __int16 v219;
  void *v220;

  v176 = a3;
  v171 = a4;
  self = (id *)a1;
  if (a1)
  {
    v168 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v176, "NF_whitelistChecker"));
    if (-[_NFHardwareManager getPrimaryHardwareState]_0(a1) == 2)
    {
      v6 = objc_alloc((Class)NFAssertionInternal);
      v197[0] = CFSTR("NFAssertionType");
      v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", a2));
      v198[0] = v7;
      v197[1] = CFSTR("NFAssertionPID");
      v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", objc_msgSend(v176, "processIdentifier")));
      v198[1] = v8;
      v197[2] = CFSTR("NFAssertionTime");
      v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate now](NSDate, "now"));
      v198[2] = v9;
      v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v198, v197, 3));
      v11 = objc_msgSend(v6, "initWithDictionary:", v10);

      v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v176, "NF_userInfo"));
      v172 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "objectForKey:", CFSTR("serviceType")));

      if (v172)
        v13 = objc_msgSend(v172, "unsignedIntegerValue") == (id)2;
      else
        v13 = 0;
      v16 = a2 == 4 && v13;
      v178 = 0;
      v174 = v11;
      v167 = v176;
      v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v167, "NF_userInfo"));
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "objectForKeyedSubscript:", CFSTR("ClientName")));

      v19 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%@,PID:%d"), v18, objc_msgSend(v167, "processIdentifier"));
      switch(a2)
      {
        case 0:
          v166 = -[NFAsserter initWithRemoteAssertion:]([NFAssertPowerUp alloc], "initWithRemoteAssertion:", v174);
          break;
        case 1:
          v166 = -[NFAsserter initWithRemoteAssertion:]([NFAssertDontReset alloc], "initWithRemoteAssertion:", v174);
          break;
        case 2:
          v166 = -[NFAsserter initWithRemoteAssertion:]([NFAssertPreventBackgroundTagReading alloc], "initWithRemoteAssertion:", v174);
          break;
        case 3:
          v166 = (NFAssertPowerUp *)sub_1001CC3F4((id *)[NFAssertPreventConnectionHandover alloc], v174, v19);
          break;
        case 4:
        case 6:
          v166 = (NFAssertPowerUp *)sub_1001722D4((id *)[NFAssertSuppressPresentmentIntentToDefaultApp alloc], v174, v19);
          break;
        case 5:
          v166 = (NFAssertPowerUp *)sub_1000AC4E4([NFAssertPKWalletForegroundPresentment alloc], v174, v167, &v178);
          break;
        default:
          break;
      }

      v170 = v178;
      if (v166)
      {
        if (-[NFAssertPowerUp isEntitled:](v166, "isEntitled:", v167))
        {
          v20 = -[NFAssertPowerUp isSupported](v166, "isSupported");
          if (v20)
          {
            if (v16
              && (v21 = (id *)self[9], v22 = sub_100050BD4(v21, v167), v21, (v22 & 1) == 0))
            {
              specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(specific);
              if (Logger)
              {
                Class = object_getClass(self);
                if (class_isMetaClass(Class))
                  v117 = 43;
                else
                  v117 = 45;
                ClassName = object_getClassName(self);
                Name = sel_getName("_sync_requestAssertion:xpcConnection:completion:");
                Logger(6, "%c[%{public}s %{public}s]:%i Client is not foreground", v117, ClassName, Name, 133);
              }
              v120 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v121 = NFSharedLogGetLogger(v120);
              v122 = objc_claimAutoreleasedReturnValue(v121);
              if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT))
              {
                v123 = object_getClass(self);
                if (class_isMetaClass(v123))
                  v124 = 43;
                else
                  v124 = 45;
                v125 = object_getClassName(self);
                v126 = sel_getName("_sync_requestAssertion:xpcConnection:completion:");
                *(_DWORD *)buf = 67109890;
                v208 = v124;
                v209 = 2082;
                v210 = v125;
                v211 = 2082;
                v212 = v126;
                v213 = 1024;
                v214 = 133;
                _os_log_impl((void *)&_mh_execute_header, v122, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Client is not foreground", buf, 0x22u);
              }

              v127 = objc_alloc((Class)NSError);
              v128 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
              v189[0] = NSLocalizedDescriptionKey;
              v129 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid State"));
              v190[0] = v129;
              v190[1] = &off_100300008;
              v189[1] = CFSTR("Line");
              v189[2] = CFSTR("Method");
              v130 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_requestAssertion:xpcConnection:completion:"));
              v190[2] = v130;
              v189[3] = NSDebugDescriptionErrorKey;
              v131 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_requestAssertion:xpcConnection:completion:"), 134);
              v190[3] = v131;
              v132 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v190, v189, 4));
              v133 = objc_msgSend(v127, "initWithDomain:code:userInfo:", v128, 12, v132);
              v171[2](v171, 0, v133);

            }
            else
            {
              if (NFIsInternalBuild(v20))
              {
                v23 = v166;
                v24 = objc_opt_new(NSMutableArray);
                v165 = objc_getProperty(self, v25, 176, 1);
                objc_sync_enter(v165);
                v183 = 0u;
                v184 = 0u;
                v185 = 0u;
                v186 = 0u;
                obj = objc_getProperty(self, v26, 176, 1);
                v27 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v183, buf, 16);
                if (v27)
                {
                  v28 = *(_QWORD *)v184;
                  do
                  {
                    for (i = 0; i != v27; i = (char *)i + 1)
                    {
                      if (*(_QWORD *)v184 != v28)
                        objc_enumerationMutation(obj);
                      v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*((_QWORD *)&v183 + 1)
                                                                                         + 8 * (_QWORD)i), "NF_userInfo"));
                      v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "objectForKeyedSubscript:", CFSTR("assertions")));

                      v181 = 0u;
                      v182 = 0u;
                      v179 = 0u;
                      v180 = 0u;
                      v32 = v31;
                      v33 = objc_msgSend(v32, "countByEnumeratingWithState:objects:count:", &v179, &v201, 16);
                      if (v33)
                      {
                        v34 = *(_QWORD *)v180;
                        do
                        {
                          for (j = 0; j != v33; j = (char *)j + 1)
                          {
                            if (*(_QWORD *)v180 != v34)
                              objc_enumerationMutation(v32);
                            v36 = *(void **)(*((_QWORD *)&v179 + 1) + 8 * (_QWORD)j);
                            if (objc_msgSend(v36, "isEqualType:", v23))
                              -[NSMutableArray addObject:](v24, "addObject:", v36);
                          }
                          v33 = objc_msgSend(v32, "countByEnumeratingWithState:objects:count:", &v179, &v201, 16);
                        }
                        while (v33);
                      }

                    }
                    v27 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v183, buf, 16);
                  }
                  while (v27);
                }

                objc_sync_exit(v165);
                if (-[NSMutableArray count](v24, "count"))
                {
                  v37 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  v38 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v37);
                  if (v38)
                  {
                    v39 = object_getClass(self);
                    if (class_isMetaClass(v39))
                      v40 = 43;
                    else
                      v40 = 45;
                    v41 = object_getClassName(self);
                    v42 = sel_getName("_sync_requestAssertion:xpcConnection:completion:");
                    v38(5, "%c[%{public}s %{public}s]:%i Existing assertions: %{public}@", v40, v41, v42, 144, v24);
                  }
                  v43 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  v44 = NFSharedLogGetLogger(v43);
                  v45 = objc_claimAutoreleasedReturnValue(v44);
                  if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
                  {
                    v46 = object_getClass(self);
                    if (class_isMetaClass(v46))
                      v47 = 43;
                    else
                      v47 = 45;
                    v48 = object_getClassName(self);
                    v49 = sel_getName("_sync_requestAssertion:xpcConnection:completion:");
                    *(_DWORD *)buf = 67110146;
                    v208 = v47;
                    v209 = 2082;
                    v210 = v48;
                    v211 = 2082;
                    v212 = v49;
                    v213 = 1024;
                    v214 = 144;
                    v215 = 2114;
                    v216 = v24;
                    _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Existing assertions: %{public}@", buf, 0x2Cu);
                  }

                }
              }
              v201 = 0;
              v202 = &v201;
              v203 = 0x3032000000;
              v204 = sub_10016F114;
              v205 = sub_10016F124;
              v206 = 0;
              v177[0] = _NSConcreteStackBlock;
              v177[1] = 3221225472;
              v177[2] = sub_10016F12C;
              v177[3] = &unk_1002E9B98;
              v177[4] = &v201;
              -[NFAssertPowerUp onAssertWithCompletion:](v166, "onAssertWithCompletion:", v177);
              if (v202[5])
              {
                v51 = objc_alloc((Class)NSError);
                v52 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
                v53 = objc_msgSend((id)v202[5], "code");
                v187[0] = NSLocalizedDescriptionKey;
                if ((uint64_t)objc_msgSend((id)v202[5], "code") > 70)
                  v54 = 71;
                else
                  v54 = (uint64_t)objc_msgSend((id)v202[5], "code");
                v159 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002E9950[v54]));
                v160 = v202[5];
                v188[0] = v159;
                v188[1] = v160;
                v187[1] = NSUnderlyingErrorKey;
                v187[2] = CFSTR("Line");
                v188[2] = &off_100300020;
                v187[3] = CFSTR("Method");
                v161 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_requestAssertion:xpcConnection:completion:"));
                v188[3] = v161;
                v187[4] = NSDebugDescriptionErrorKey;
                v162 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_requestAssertion:xpcConnection:completion:"), 156);
                v188[4] = v162;
                v163 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v188, v187, 5));
                v164 = objc_msgSend(v51, "initWithDomain:code:userInfo:", v52, v53, v163);
                v171[2](v171, 0, v164);

              }
              else
              {
                v134 = objc_getProperty(self, v50, 176, 1);
                objc_sync_enter(v134);
                v135 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v167, "NF_userInfo"));
                v136 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v135, "objectForKeyedSubscript:", CFSTR("assertions")));
                v137 = v136 == 0;

                if (v137)
                {
                  v138 = objc_opt_new(NSMutableArray);
                  v139 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v167, "NF_userInfo"));
                  objc_msgSend(v139, "setObject:forKeyedSubscript:", v138, CFSTR("assertions"));

                }
                v140 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v167, "NF_userInfo"));
                v141 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v140, "objectForKeyedSubscript:", CFSTR("assertions")));

                objc_msgSend(v141, "addObject:", v166);
                objc_sync_exit(v134);

                v142 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                v143 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v142);
                if (v143)
                {
                  v144 = object_getClass(self);
                  if (class_isMetaClass(v144))
                    v145 = 43;
                  else
                    v145 = 45;
                  v146 = object_getClassName(self);
                  v147 = sel_getName("_sync_requestAssertion:xpcConnection:completion:");
                  v148 = objc_msgSend(v167, "processIdentifier");
                  v149 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v168, "clientName"));
                  v143(6, "%c[%{public}s %{public}s]:%i Assertion %{public}@ requested from PID %d (%{public}@)", v145, v146, v147, 170, v166, v148, v149);

                }
                v150 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                v151 = NFSharedLogGetLogger(v150);
                v152 = objc_claimAutoreleasedReturnValue(v151);
                if (os_log_type_enabled(v152, OS_LOG_TYPE_DEFAULT))
                {
                  v153 = object_getClass(self);
                  if (class_isMetaClass(v153))
                    v154 = 43;
                  else
                    v154 = 45;
                  v155 = object_getClassName(self);
                  v156 = sel_getName("_sync_requestAssertion:xpcConnection:completion:");
                  v157 = objc_msgSend(v167, "processIdentifier");
                  v158 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v168, "clientName"));
                  *(_DWORD *)buf = 67110658;
                  v208 = v154;
                  v209 = 2082;
                  v210 = v155;
                  v211 = 2082;
                  v212 = v156;
                  v213 = 1024;
                  v214 = 170;
                  v215 = 2114;
                  v216 = v166;
                  v217 = 1024;
                  v218 = v157;
                  v219 = 2114;
                  v220 = v158;
                  _os_log_impl((void *)&_mh_execute_header, v152, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Assertion %{public}@ requested from PID %d (%{public}@)", buf, 0x3Cu);

                }
                if (a2 == 4)
                {
                  objc_msgSend(v167, "NF_setPresentmentIntentSuppressionHolder");
                }
                else if (a2 == 6)
                {
                  objc_msgSend(v167, "NF_setFDPresentmentIntentSuppressionHolder");
                }
                ((void (**)(id, id, id))v171)[2](v171, v174, 0);
              }
              _Block_object_dispose(&v201, 8);

            }
          }
          else
          {
            v94 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v95 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v94);
            if (v95)
            {
              v96 = object_getClass(self);
              if (class_isMetaClass(v96))
                v97 = 43;
              else
                v97 = 45;
              v98 = object_getClassName(self);
              v99 = sel_getName("_sync_requestAssertion:xpcConnection:completion:");
              v95(6, "%c[%{public}s %{public}s]:%i Not supported", v97, v98, v99, 126);
            }
            v100 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v101 = NFSharedLogGetLogger(v100);
            v102 = objc_claimAutoreleasedReturnValue(v101);
            if (os_log_type_enabled(v102, OS_LOG_TYPE_DEFAULT))
            {
              v103 = object_getClass(self);
              if (class_isMetaClass(v103))
                v104 = 43;
              else
                v104 = 45;
              v105 = object_getClassName(self);
              v106 = sel_getName("_sync_requestAssertion:xpcConnection:completion:");
              *(_DWORD *)buf = 67109890;
              v208 = v104;
              v209 = 2082;
              v210 = v105;
              v211 = 2082;
              v212 = v106;
              v213 = 1024;
              v214 = 126;
              _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Not supported", buf, 0x22u);
            }

            v107 = objc_alloc((Class)NSError);
            v108 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
            v191[0] = NSLocalizedDescriptionKey;
            v109 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Feature Not Supported"));
            v192[0] = v109;
            v192[1] = &off_1002FFFF0;
            v191[1] = CFSTR("Line");
            v191[2] = CFSTR("Method");
            v110 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_requestAssertion:xpcConnection:completion:"));
            v192[2] = v110;
            v191[3] = NSDebugDescriptionErrorKey;
            v111 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_requestAssertion:xpcConnection:completion:"), 127);
            v192[3] = v111;
            v112 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v192, v191, 4));
            v113 = objc_msgSend(v107, "initWithDomain:code:userInfo:", v108, 14, v112);
            v171[2](v171, 0, v113);

          }
        }
        else
        {
          v74 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v75 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v74);
          if (v75)
          {
            v76 = object_getClass(self);
            if (class_isMetaClass(v76))
              v77 = 43;
            else
              v77 = 45;
            v78 = object_getClassName(self);
            v79 = sel_getName("_sync_requestAssertion:xpcConnection:completion:");
            v75(6, "%c[%{public}s %{public}s]:%i Not Entitled", v77, v78, v79, 120);
          }
          v80 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v81 = NFSharedLogGetLogger(v80);
          v82 = objc_claimAutoreleasedReturnValue(v81);
          if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
          {
            v83 = object_getClass(self);
            if (class_isMetaClass(v83))
              v84 = 43;
            else
              v84 = 45;
            v85 = object_getClassName(self);
            v86 = sel_getName("_sync_requestAssertion:xpcConnection:completion:");
            *(_DWORD *)buf = 67109890;
            v208 = v84;
            v209 = 2082;
            v210 = v85;
            v211 = 2082;
            v212 = v86;
            v213 = 1024;
            v214 = 120;
            _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Not Entitled", buf, 0x22u);
          }

          v87 = objc_alloc((Class)NSError);
          v88 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
          v193[0] = NSLocalizedDescriptionKey;
          v89 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Not entitled"));
          v194[0] = v89;
          v194[1] = &off_1002FFFD8;
          v193[1] = CFSTR("Line");
          v193[2] = CFSTR("Method");
          v90 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_requestAssertion:xpcConnection:completion:"));
          v194[2] = v90;
          v193[3] = NSDebugDescriptionErrorKey;
          v91 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_requestAssertion:xpcConnection:completion:"), 121);
          v194[3] = v91;
          v92 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v194, v193, 4));
          v93 = objc_msgSend(v87, "initWithDomain:code:userInfo:", v88, 32, v92);
          v171[2](v171, 0, v93);

        }
        v15 = v166;
      }
      else
      {
        v55 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v56 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v55);
        if (v56)
        {
          v57 = object_getClass(self);
          if (class_isMetaClass(v57))
            v58 = 43;
          else
            v58 = 45;
          v59 = object_getClassName(self);
          v60 = sel_getName("_sync_requestAssertion:xpcConnection:completion:");
          v56(3, "%c[%{public}s %{public}s]:%i Resource allocation failed", v58, v59, v60, 113);
        }
        v61 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v62 = NFSharedLogGetLogger(v61);
        v63 = objc_claimAutoreleasedReturnValue(v62);
        if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
        {
          v64 = object_getClass(self);
          if (class_isMetaClass(v64))
            v65 = 43;
          else
            v65 = 45;
          v66 = object_getClassName(self);
          v67 = sel_getName("_sync_requestAssertion:xpcConnection:completion:");
          *(_DWORD *)buf = 67109890;
          v208 = v65;
          v209 = 2082;
          v210 = v66;
          v211 = 2082;
          v212 = v67;
          v213 = 1024;
          v214 = 113;
          _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Resource allocation failed", buf, 0x22u);
        }

        v68 = v170;
        if (!v170)
        {
          v69 = objc_alloc((Class)NSError);
          v70 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
          v195 = NSLocalizedDescriptionKey;
          v71 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "No resources"));
          v196 = v71;
          v72 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v196, &v195, 1));
          v73 = objc_msgSend(v69, "initWithDomain:code:userInfo:", v70, 34, v72);

          v68 = v73;
        }
        v170 = v68;
        ((void (*)(void (**)(id, _QWORD, id), _QWORD))v171[2])(v171, 0);
        v15 = 0;
      }
    }
    else
    {
      v14 = objc_alloc((Class)NSError);
      v174 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v199 = NSLocalizedDescriptionKey;
      v172 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
      v200 = v172;
      v170 = (id)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v200, &v199, 1));
      v15 = (NFAssertPowerUp *)objc_msgSend(v14, "initWithDomain:code:userInfo:", v174, 58, v170);
      v171[2](v171, 0, v15);
    }

  }
}

void sub_10016F090(_Unwind_Exception *a1)
{
  _Block_object_dispose(&STACK[0x2B0], 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10016F114(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_10016F124(uint64_t a1)
{

}

void sub_10016F12C(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), a2);
}

id sub_10016F13C(id a1, void *a2)
{
  id v2;
  void *v3;
  void *v4;
  id v5;

  v2 = a1;
  if (a1)
  {
    v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a2, "sessionID"));
    if (v3)
    {
      v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "driverWrapper"));
      v5 = sub_1001F84C8(v4, v3, 0);
      v2 = (id)objc_claimAutoreleasedReturnValue(v5);

    }
    else
    {
      v2 = 0;
    }

  }
  return v2;
}

void sub_10016F1B0(void *a1, void *a2, void *a3, void *a4)
{
  id v7;
  SEL v8;
  void *v9;
  void *v10;
  id v11;
  id v12;
  uint64_t v13;
  void *i;
  void *v15;
  void *v16;
  unsigned int v17;
  id v18;
  void *specific;
  void (*Logger)(uint64_t, const char *, ...);
  objc_class *Class;
  uint64_t v22;
  const char *ClassName;
  const char *Name;
  id v25;
  void *v26;
  void *v27;
  uint64_t v28;
  NSObject *v29;
  objc_class *v30;
  int v31;
  const char *v32;
  const char *v33;
  unsigned int v34;
  void *v35;
  void *v36;
  void (*v37)(uint64_t, const char *, ...);
  objc_class *v38;
  uint64_t v39;
  const char *v40;
  const char *v41;
  id v42;
  void *v43;
  void *v44;
  uint64_t v45;
  NSObject *v46;
  objc_class *v47;
  int v48;
  const char *v49;
  const char *v50;
  unsigned int v51;
  void *v52;
  void *v53;
  void (*v54)(uint64_t, const char *, ...);
  objc_class *v55;
  uint64_t v56;
  const char *v57;
  const char *v58;
  id v59;
  void *v60;
  void *v61;
  uint64_t v62;
  NSObject *v63;
  objc_class *v64;
  int v65;
  const char *v66;
  const char *v67;
  unsigned int v68;
  void *v69;
  id obj;
  void (**v71)(id, _QWORD);
  void *v72;
  id v73;
  _QWORD v74[5];
  uint64_t v75;
  uint64_t *v76;
  uint64_t v77;
  uint64_t (*v78)(uint64_t, uint64_t);
  void (*v79)(uint64_t);
  id v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  uint8_t buf[4];
  int v86;
  __int16 v87;
  const char *v88;
  __int16 v89;
  const char *v90;
  __int16 v91;
  int v92;
  __int16 v93;
  _BYTE v94[14];
  __int16 v95;
  id v96;
  _BYTE v97[128];

  v7 = a2;
  v73 = a3;
  v71 = a4;
  if (a1)
  {
    v72 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v73, "NF_whitelistChecker"));
    obj = objc_getProperty(a1, v8, 176, 1);
    objc_sync_enter(obj);
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v73, "NF_userInfo"));
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("assertions")));

    v84 = 0u;
    v82 = 0u;
    v83 = 0u;
    v81 = 0u;
    v11 = v10;
    v12 = objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v81, v97, 16);
    if (v12)
    {
      v13 = *(_QWORD *)v82;
      while (2)
      {
        for (i = 0; i != v12; i = (char *)i + 1)
        {
          if (*(_QWORD *)v82 != v13)
            objc_enumerationMutation(v11);
          v15 = *(void **)(*((_QWORD *)&v81 + 1) + 8 * (_QWORD)i);
          v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "remoteAssertion"));
          v17 = objc_msgSend(v16, "isEqual:", v7);

          if (v17)
          {
            specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(specific);
            if (Logger)
            {
              Class = object_getClass(a1);
              if (class_isMetaClass(Class))
                v22 = 43;
              else
                v22 = 45;
              ClassName = object_getClassName(a1);
              Name = sel_getName("_sync_releaseAssertion:xpcConnection:completion:");
              v25 = objc_msgSend(v73, "processIdentifier");
              v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v72, "clientName"));
              Logger(6, "%c[%{public}s %{public}s]:%i Assertion %{public}@ released from PID %d (%{public}@)", v22, ClassName, Name, 207, v7, v25, v26);

            }
            v27 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v28 = NFSharedLogGetLogger(v27);
            v29 = objc_claimAutoreleasedReturnValue(v28);
            if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
            {
              v30 = object_getClass(a1);
              if (class_isMetaClass(v30))
                v31 = 43;
              else
                v31 = 45;
              v32 = object_getClassName(a1);
              v33 = sel_getName("_sync_releaseAssertion:xpcConnection:completion:");
              v34 = objc_msgSend(v73, "processIdentifier");
              v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v72, "clientName"));
              *(_DWORD *)buf = 67110658;
              v86 = v31;
              v87 = 2082;
              v88 = v32;
              v89 = 2082;
              v90 = v33;
              v91 = 1024;
              v92 = 207;
              v93 = 2114;
              *(_QWORD *)v94 = v7;
              *(_WORD *)&v94[8] = 1024;
              *(_DWORD *)&v94[10] = v34;
              v95 = 2114;
              v96 = v35;
              _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Assertion %{public}@ released from PID %d (%{public}@)", buf, 0x3Cu);

            }
            v18 = v15;
            objc_msgSend(v11, "removeObject:", v18);
            v36 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v37 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v36);
            if (v37)
            {
              v38 = object_getClass(a1);
              if (class_isMetaClass(v38))
                v39 = 43;
              else
                v39 = 45;
              v40 = object_getClassName(a1);
              v41 = sel_getName("_sync_releaseAssertion:xpcConnection:completion:");
              v42 = objc_msgSend(v73, "processIdentifier");
              v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v72, "clientName"));
              v37(6, "%c[%{public}s %{public}s]:%i Assertion available for PID %d (%{public}@) are %{public}@", v39, v40, v41, 212, v42, v43, v11);

            }
            v44 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v45 = NFSharedLogGetLogger(v44);
            v46 = objc_claimAutoreleasedReturnValue(v45);
            if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
            {
              v47 = object_getClass(a1);
              if (class_isMetaClass(v47))
                v48 = 43;
              else
                v48 = 45;
              v49 = object_getClassName(a1);
              v50 = sel_getName("_sync_releaseAssertion:xpcConnection:completion:");
              v51 = objc_msgSend(v73, "processIdentifier");
              v52 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v72, "clientName"));
              *(_DWORD *)buf = 67110658;
              v86 = v48;
              v87 = 2082;
              v88 = v49;
              v89 = 2082;
              v90 = v50;
              v91 = 1024;
              v92 = 212;
              v93 = 1024;
              *(_DWORD *)v94 = v51;
              *(_WORD *)&v94[4] = 2114;
              *(_QWORD *)&v94[6] = v52;
              v95 = 2114;
              v96 = v11;
              _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Assertion available for PID %d (%{public}@) are %{public}@", buf, 0x3Cu);

            }
            goto LABEL_32;
          }
        }
        v12 = objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v81, v97, 16);
        if (v12)
          continue;
        break;
      }
    }
    v18 = 0;
LABEL_32:

    objc_sync_exit(obj);
    v75 = 0;
    v76 = &v75;
    v77 = 0x3032000000;
    v78 = sub_10016F114;
    v79 = sub_10016F124;
    v80 = 0;
    if (v18)
    {
      v74[0] = _NSConcreteStackBlock;
      v74[1] = 3221225472;
      v74[2] = sub_10016F970;
      v74[3] = &unk_1002E9B98;
      v74[4] = &v75;
      objc_msgSend(v18, "onDeassertWithCompletion:", v74);
      if (objc_msgSend(v7, "assertionType") == (id)4)
      {
        objc_msgSend(v73, "NF_clearPresentmentIntentSuppressionHolder");
      }
      else if (objc_msgSend(v7, "assertionType") == (id)6)
      {
        objc_msgSend(v73, "NF_clearFDPresentmentIntentSuppressionHolder");
      }
    }
    else
    {
      v53 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v54 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v53);
      if (v54)
      {
        v55 = object_getClass(a1);
        if (class_isMetaClass(v55))
          v56 = 43;
        else
          v56 = 45;
        v57 = object_getClassName(a1);
        v58 = sel_getName("_sync_releaseAssertion:xpcConnection:completion:");
        v59 = objc_msgSend(v73, "processIdentifier");
        v60 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v72, "clientName"));
        v54(4, "%c[%{public}s %{public}s]:%i Assertion %{public}@ not available for PID %d (%{public}@)", v56, v57, v58, 230, v7, v59, v60);

      }
      v61 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v62 = NFSharedLogGetLogger(v61);
      v63 = objc_claimAutoreleasedReturnValue(v62);
      if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
      {
        v64 = object_getClass(a1);
        if (class_isMetaClass(v64))
          v65 = 43;
        else
          v65 = 45;
        v66 = object_getClassName(a1);
        v67 = sel_getName("_sync_releaseAssertion:xpcConnection:completion:");
        v68 = objc_msgSend(v73, "processIdentifier");
        v69 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v72, "clientName"));
        *(_DWORD *)buf = 67110658;
        v86 = v65;
        v87 = 2082;
        v88 = v66;
        v89 = 2082;
        v90 = v67;
        v91 = 1024;
        v92 = 230;
        v93 = 2114;
        *(_QWORD *)v94 = v7;
        *(_WORD *)&v94[8] = 1024;
        *(_DWORD *)&v94[10] = v68;
        v95 = 2114;
        v96 = v69;
        _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Assertion %{public}@ not available for PID %d (%{public}@)", buf, 0x3Cu);

      }
    }
    v71[2](v71, v76[5]);
    _Block_object_dispose(&v75, 8);

  }
}

void sub_10016F910(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id obj, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

void sub_10016F970(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), a2);
}

void sub_10016F980(void *a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  void *v6;
  void *i;
  void *v8;
  void *specific;
  uint64_t Logger;
  void (*v11)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  id v16;
  void *v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  NSObject *v21;
  objc_class *v22;
  int v23;
  const char *v24;
  const char *v25;
  unsigned int v26;
  void *v27;
  void *v28;
  id v29;
  void *v30;
  id v31;
  void *v32;
  id obj;
  uint64_t v34;
  id v35;
  void *v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  uint8_t buf[4];
  int v42;
  __int16 v43;
  const char *v44;
  __int16 v45;
  const char *v46;
  __int16 v47;
  int v48;
  __int16 v49;
  void *v50;
  __int16 v51;
  unsigned int v52;
  __int16 v53;
  void *v54;
  _BYTE v55[128];

  v3 = a2;
  v4 = v3;
  if (a1)
  {
    v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "NF_whitelistChecker"));
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "NF_userInfo"));
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("assertions")));

    v39 = 0u;
    v40 = 0u;
    v37 = 0u;
    v38 = 0u;
    obj = v6;
    v35 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v37, v55, 16);
    if (v35)
    {
      v34 = *(_QWORD *)v38;
      do
      {
        for (i = 0; i != v35; i = (char *)i + 1)
        {
          if (*(_QWORD *)v38 != v34)
            objc_enumerationMutation(obj);
          v8 = *(void **)(*((_QWORD *)&v37 + 1) + 8 * (_QWORD)i);
          specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          Logger = NFLogGetLogger(specific);
          if (Logger)
          {
            v11 = (void (*)(uint64_t, const char *, ...))Logger;
            Class = object_getClass(a1);
            isMetaClass = class_isMetaClass(Class);
            ClassName = object_getClassName(a1);
            Name = sel_getName("releaseAssertionsForConnection:");
            v16 = objc_msgSend(v4, "processIdentifier");
            v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v36, "clientName"));
            v18 = 45;
            if (isMetaClass)
              v18 = 43;
            v11(6, "%c[%{public}s %{public}s]:%i Assertion %{public}@ released from PID %d (%{public}@)", v18, ClassName, Name, 243, v8, v16, v17);

          }
          v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v20 = NFSharedLogGetLogger(v19);
          v21 = objc_claimAutoreleasedReturnValue(v20);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
          {
            v22 = object_getClass(a1);
            if (class_isMetaClass(v22))
              v23 = 43;
            else
              v23 = 45;
            v24 = object_getClassName(a1);
            v25 = sel_getName("releaseAssertionsForConnection:");
            v26 = objc_msgSend(v4, "processIdentifier");
            v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v36, "clientName"));
            *(_DWORD *)buf = 67110658;
            v42 = v23;
            v43 = 2082;
            v44 = v24;
            v45 = 2082;
            v46 = v25;
            v47 = 1024;
            v48 = 243;
            v49 = 2114;
            v50 = v8;
            v51 = 1024;
            v52 = v26;
            v53 = 2114;
            v54 = v27;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Assertion %{public}@ released from PID %d (%{public}@)", buf, 0x3Cu);

          }
          objc_msgSend(v8, "onDeassertWithCompletion:", 0);
          v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "remoteAssertion"));
          v29 = objc_msgSend(v28, "assertionType");

          if (v29 == (id)4)
          {
            objc_msgSend(v4, "NF_clearPresentmentIntentSuppressionHolder");
          }
          else
          {
            v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "remoteAssertion"));
            v31 = objc_msgSend(v30, "assertionType");

            if (v31 == (id)6)
              objc_msgSend(v4, "NF_clearFDPresentmentIntentSuppressionHolder");
          }
        }
        v35 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v37, v55, 16);
      }
      while (v35);
    }

    v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "NF_userInfo"));
    objc_msgSend(v32, "setObject:forKeyedSubscript:", 0, CFSTR("assertions"));

  }
}

void sub_10016FD04(void *a1, void *a2)
{
  void *v3;
  void *v4;
  id v5;

  if (a1)
  {
    v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a2, "sessionID"));
    if (v3)
    {
      v5 = v3;
      v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "driverWrapper"));
      sub_1001FABB8(v4, v5);

      v3 = v5;
    }

  }
}

void sub_10016FD64(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  id v5;
  const char *v6;
  void *specific;
  uint64_t Logger;
  void (*v9)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  NSObject *v16;
  objc_class *v17;
  int v18;
  int v19;
  id v20;
  id v21;
  void *v22;
  void *v23;
  id v24;
  void *v25;
  uint64_t v26;
  void (*v27)(uint64_t, const char *, ...);
  objc_class *v28;
  _BOOL4 v29;
  const char *v30;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  objc_class *v34;
  int v35;
  const char *Name;
  const char *v37;
  _QWORD v38[2];
  _QWORD v39[2];
  uint8_t buf[4];
  int v41;
  __int16 v42;
  const char *v43;
  __int16 v44;
  const char *v45;
  __int16 v46;
  int v47;

  v3 = a2;
  v4 = v3;
  if (a1)
  {
    if (objc_msgSend(v3, "isEqualToString:", CFSTR("NFCameraStateMonitor")))
    {
      v5 = *(id *)(a1 + 416);

      if (v5)
      {
        specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        Logger = NFLogGetLogger(specific);
        if (Logger)
        {
          v9 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass((id)a1);
          isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName((id)a1);
          Name = sel_getName("requestConnectionHandoverAssert:");
          v13 = 45;
          if (isMetaClass)
            v13 = 43;
          v9(5, "%c[%{public}s %{public}s]:%i Camera assertion exists", v13, ClassName, Name, 268);
        }
        v14 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v15 = NFSharedLogGetLogger(v14);
        v16 = objc_claimAutoreleasedReturnValue(v15);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          v17 = object_getClass((id)a1);
          if (class_isMetaClass(v17))
            v18 = 43;
          else
            v18 = 45;
          *(_DWORD *)buf = 67109890;
          v41 = v18;
          v42 = 2082;
          v43 = object_getClassName((id)a1);
          v44 = 2082;
          v45 = sel_getName("requestConnectionHandoverAssert:");
          v46 = 1024;
          v47 = 268;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Camera assertion exists", buf, 0x22u);
        }
LABEL_26:

        goto LABEL_27;
      }
      v20 = objc_getProperty((id)a1, v6, 176, 1);
      objc_sync_enter(v20);
      v21 = objc_alloc((Class)NFAssertionInternal);
      v38[0] = CFSTR("NFAssertionType");
      v38[1] = CFSTR("NFAssertionTime");
      v39[0] = &off_100300038;
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate now](NSDate, "now"));
      v39[1] = v22;
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v39, v38, 2));
      v24 = objc_msgSend(v21, "initWithDictionary:", v23);
      objc_storeStrong((id *)(a1 + 416), v24);

      objc_sync_exit(v20);
    }
    else
    {
      v19 = *(_DWORD *)(a1 + 328);
      if (v19 == -1)
      {
        v25 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v26 = NFLogGetLogger(v25);
        if (v26)
        {
          v27 = (void (*)(uint64_t, const char *, ...))v26;
          v28 = object_getClass((id)a1);
          v29 = class_isMetaClass(v28);
          v30 = object_getClassName((id)a1);
          v37 = sel_getName("requestConnectionHandoverAssert:");
          v31 = 45;
          if (v29)
            v31 = 43;
          v27(3, "%c[%{public}s %{public}s]:%i CH assertion count overflow!", v31, v30, v37, 283);
        }
        v32 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v33 = NFSharedLogGetLogger(v32);
        v16 = objc_claimAutoreleasedReturnValue(v33);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          v34 = object_getClass((id)a1);
          if (class_isMetaClass(v34))
            v35 = 43;
          else
            v35 = 45;
          *(_DWORD *)buf = 67109890;
          v41 = v35;
          v42 = 2082;
          v43 = object_getClassName((id)a1);
          v44 = 2082;
          v45 = sel_getName("requestConnectionHandoverAssert:");
          v46 = 1024;
          v47 = 283;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i CH assertion count overflow!", buf, 0x22u);
        }
        goto LABEL_26;
      }
      *(_DWORD *)(a1 + 328) = v19 + 1;
    }
  }
LABEL_27:

}

void sub_100170118(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100170134(uint64_t a1, void *a2)
{
  id v3;
  const char *v4;
  id v5;
  int v6;
  id v7;

  v3 = a2;
  if (a1)
  {
    v7 = v3;
    if (objc_msgSend(v3, "isEqualToString:", CFSTR("NFCameraStateMonitor")))
    {
      v5 = objc_getProperty((id)a1, v4, 176, 1);
      objc_sync_enter(v5);
      objc_storeStrong((id *)(a1 + 416), 0);
      objc_sync_exit(v5);

      v3 = v7;
    }
    else
    {
      v6 = *(_DWORD *)(a1 + 328);
      v3 = v7;
      if (v6)
        *(_DWORD *)(a1 + 328) = v6 - 1;
    }
  }

}

uint64_t sub_1001701C8(uint64_t a1)
{
  _BOOL8 v1;
  id v2;

  if (!a1)
    return 0;
  if (*(_DWORD *)(a1 + 328))
    return 1;
  v2 = *(id *)(a1 + 416);
  v1 = v2 != 0;

  return v1;
}

uint64_t sub_100170214(uint64_t a1)
{
  id v2;
  uint64_t v3;
  id v4;

  if (!a1)
    return 0;
  v2 = *(id *)(a1 + 120);
  v3 = 1;
  if ((objc_msgSend(v2, "isAsserted:", 1) & 1) == 0)
  {
    v4 = *(id *)(a1 + 120);
    v3 = (uint64_t)objc_msgSend(v4, "isAsserted:", 2);

  }
  return v3;
}

id sub_100170854(uint64_t a1)
{
  objc_opt_self(a1);
  if (qword_10032AA30 != -1)
    dispatch_once(&qword_10032AA30, &stru_1002E9BB8);
  return (id)qword_10032AA28;
}

void sub_100170898(id a1)
{
  NFCameraStateMonitor *v1;
  void *v2;

  v1 = objc_alloc_init(NFCameraStateMonitor);
  v2 = (void *)qword_10032AA28;
  qword_10032AA28 = (uint64_t)v1;

}

void sub_1001708C0(uint64_t a1)
{
  NSMutableArray *v2;
  id v3;
  id v4;
  id v5;
  uint64_t v6;
  void *i;
  uint64_t v8;
  void *v9;
  NSMutableArray *v10;
  id v11;
  id v12;
  uint64_t v13;
  void *j;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  _BYTE v23[128];
  _BYTE v24[128];

  if (a1)
  {
    v2 = objc_opt_new(NSMutableArray);
    v19 = 0u;
    v20 = 0u;
    v21 = 0u;
    v22 = 0u;
    v3 = *(id *)(a1 + 16);
    v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v19, v24, 16);
    if (v4)
    {
      v5 = v4;
      v6 = *(_QWORD *)v20;
      do
      {
        for (i = 0; i != v5; i = (char *)i + 1)
        {
          if (*(_QWORD *)v20 != v6)
            objc_enumerationMutation(v3);
          v8 = *(_QWORD *)(*((_QWORD *)&v19 + 1) + 8 * (_QWORD)i);
          v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 16), "objectForKey:", v8));

          if (!v9)
            -[NSMutableArray addObject:](v2, "addObject:", v8);
        }
        v5 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v19, v24, 16);
      }
      while (v5);
    }

    v17 = 0u;
    v18 = 0u;
    v15 = 0u;
    v16 = 0u;
    v10 = v2;
    v11 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v10, "countByEnumeratingWithState:objects:count:", &v15, v23, 16);
    if (v11)
    {
      v12 = v11;
      v13 = *(_QWORD *)v16;
      do
      {
        for (j = 0; j != v12; j = (char *)j + 1)
        {
          if (*(_QWORD *)v16 != v13)
            objc_enumerationMutation(v10);
          objc_msgSend(*(id *)(a1 + 16), "removeObjectForKey:", *(_QWORD *)(*((_QWORD *)&v15 + 1) + 8 * (_QWORD)j), (_QWORD)v15);
        }
        v12 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v10, "countByEnumeratingWithState:objects:count:", &v15, v23, 16);
      }
      while (v12);
    }

  }
}

void sub_100170A84(os_unfair_lock_s *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  os_unfair_lock_s *v7;
  id v8;
  id v9;
  void *specific;
  uint64_t Logger;
  void (*v12)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  NSObject *v19;
  objc_class *v20;
  int v21;
  const char *Name;
  uint64_t v23[7];
  uint8_t buf[4];
  int v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  int v31;

  v5 = a2;
  v6 = a3;
  if (a1)
  {
    if ((objc_opt_respondsToSelector(v5, "didCameraStateChange:") & 1) != 0)
    {
      v7 = a1 + 13;
      v23[0] = (uint64_t)_NSConcreteStackBlock;
      v23[1] = 3221225472;
      v23[2] = (uint64_t)sub_100170CB0;
      v23[3] = (uint64_t)&unk_1002E82F8;
      v23[4] = (uint64_t)a1;
      v8 = v5;
      v23[5] = (uint64_t)v8;
      v9 = v6;
      v23[6] = (uint64_t)v9;
      os_unfair_lock_lock(v7);
      sub_100170CB0(v23);
      os_unfair_lock_unlock(v7);

    }
    else
    {
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v12 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(a1);
        Name = sel_getName("registerStateChangeWithDelegate:client:");
        v16 = 45;
        if (isMetaClass)
          v16 = 43;
        v12(3, "%c[%{public}s %{public}s]:%i Unexpected delegate type, dropping registration", v16, ClassName, Name, 131);
      }
      v17 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v18 = NFSharedLogGetLogger(v17);
      v19 = objc_claimAutoreleasedReturnValue(v18);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        v20 = object_getClass(a1);
        if (class_isMetaClass(v20))
          v21 = 43;
        else
          v21 = 45;
        *(_DWORD *)buf = 67109890;
        v25 = v21;
        v26 = 2082;
        v27 = object_getClassName(a1);
        v28 = 2082;
        v29 = sel_getName("registerStateChangeWithDelegate:client:");
        v30 = 1024;
        v31 = 131;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unexpected delegate type, dropping registration", buf, 0x22u);
      }

    }
  }

}

void sub_100170CB0(uint64_t *a1)
{
  id v2;
  uint64_t v3;
  void *specific;
  void (*Logger)(uint64_t, const char *, ...);
  objc_class *Class;
  uint64_t v7;
  const char *ClassName;
  const char *Name;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  objc_class *v13;
  int v14;
  const char *v15;
  const char *v16;
  IONotificationPort *v17;
  IONotificationPort *v18;
  io_registry_entry_t v19;
  id v20;
  id v21;
  void *v22;
  id v23;
  id v24;
  kern_return_t v25;
  void *v26;
  void (*v27)(uint64_t, const char *, ...);
  objc_class *v28;
  uint64_t v29;
  const char *v30;
  const char *v31;
  void *v32;
  uint64_t v33;
  NSObject *v34;
  objc_class *v35;
  int v36;
  const char *v37;
  const char *v38;
  void *v39;
  void (*v40)(uint64_t, const char *, ...);
  objc_class *v41;
  uint64_t v42;
  const char *v43;
  const char *v44;
  void *v45;
  uint64_t v46;
  NSObject *v47;
  objc_class *v48;
  int v49;
  const char *v50;
  const char *v51;
  void *v52;
  void (*v53)(uint64_t, const char *, ...);
  objc_class *v54;
  uint64_t v55;
  const char *v56;
  const char *v57;
  void *v58;
  uint64_t v59;
  objc_class *v60;
  int v61;
  const char *v62;
  const char *v63;
  void *v64;
  void (*v65)(uint64_t, const char *, ...);
  objc_class *v66;
  uint64_t v67;
  const char *v68;
  const char *v69;
  void *v70;
  uint64_t v71;
  NSObject *v72;
  objc_class *v73;
  int v74;
  const char *v75;
  const char *v76;
  uint64_t v77;
  NSObject *v78;
  id v79;
  void *v80;
  _DWORD *v81;
  id location;
  id from;
  uint8_t v84[8];
  _BYTE v85[26];
  _BYTE buf[34];
  const char *v87;

  v2 = objc_msgSend(*(id *)(a1[4] + 16), "count");
  objc_msgSend(*(id *)(a1[4] + 16), "setObject:forKey:", a1[5], a1[6]);
  sub_1001708C0(a1[4]);
  if (!v2)
  {
    v3 = a1[4];
    if (v3)
    {
      objc_initWeak(&location, (id)v3);
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(specific);
      if (Logger)
      {
        Class = object_getClass((id)v3);
        if (class_isMetaClass(Class))
          v7 = 43;
        else
          v7 = 45;
        ClassName = object_getClassName((id)v3);
        Name = sel_getName("_registerForCameraNotifications");
        Logger(6, "%c[%{public}s %{public}s]:%i ", v7, ClassName, Name, 194);
      }
      v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v11 = NFSharedLogGetLogger(v10);
      v12 = objc_claimAutoreleasedReturnValue(v11);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        v13 = object_getClass((id)v3);
        if (class_isMetaClass(v13))
          v14 = 43;
        else
          v14 = 45;
        v15 = object_getClassName((id)v3);
        v16 = sel_getName("_registerForCameraNotifications");
        *(_DWORD *)buf = 67109890;
        *(_DWORD *)&buf[4] = v14;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = v15;
        *(_WORD *)&buf[18] = 2082;
        *(_QWORD *)&buf[20] = v16;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 194;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
      }

      if (!qword_10032AA38)
      {
        *(_OWORD *)buf = off_1002E9C68;
        *(_QWORD *)&buf[16] = 0;
        qword_10032AA38 = _sl_dlopen(buf, 0);
      }
      if (qword_10032AA38)
      {
        v17 = IONotificationPortCreate(kIOMainPortDefault);
        *(_QWORD *)(v3 + 40) = v17;
        if (v17)
        {
          IONotificationPortSetDispatchQueue(v17, *(dispatch_queue_t *)(v3 + 32));
          v18 = *(IONotificationPort **)(v3 + 40);
          v19 = sub_100171A84(v3);
          if (v19)
          {
            objc_initWeak(&from, (id)v3);
            if (!*(_QWORD *)(v3 + 8))
            {
              v20 = objc_alloc((Class)NFTimer);
              *(_QWORD *)buf = _NSConcreteStackBlock;
              *(_QWORD *)&buf[8] = 3221225472;
              *(_QWORD *)&buf[16] = sub_100171CCC;
              *(_QWORD *)&buf[24] = &unk_1002E6290;
              objc_copyWeak((id *)&buf[32], &from);
              v87 = "listenForCameraNotificationFromPort:";
              v21 = objc_msgSend(v20, "initWithCallback:queue:", buf, *(_QWORD *)(v3 + 32));
              v22 = *(void **)(v3 + 8);
              *(_QWORD *)(v3 + 8) = v21;

              objc_destroyWeak((id *)&buf[32]);
            }
            v23 = objc_loadWeakRetained(&from);
            sub_1000065D8(v23, v19, -536870608);

            v24 = objc_loadWeakRetained(&from);
            v25 = IOServiceAddInterestNotification(v18, v19, "IOGeneralInterest", (IOServiceInterestCallback)sub_1000065D8, v24, (io_object_t *)(v3 + 48));

            if (v25)
            {
              v26 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v27 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v26);
              if (v27)
              {
                v28 = object_getClass((id)v3);
                if (class_isMetaClass(v28))
                  v29 = 43;
                else
                  v29 = 45;
                v30 = object_getClassName((id)v3);
                v31 = sel_getName("listenForCameraNotificationFromPort:");
                v27(3, "%c[%{public}s %{public}s]:%i Subscribe notification failed", v29, v30, v31, 430);
              }
              v32 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v33 = NFSharedLogGetLogger(v32);
              v34 = objc_claimAutoreleasedReturnValue(v33);
              if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
              {
                v35 = object_getClass((id)v3);
                if (class_isMetaClass(v35))
                  v36 = 43;
                else
                  v36 = 45;
                v37 = object_getClassName((id)v3);
                v38 = sel_getName("listenForCameraNotificationFromPort:");
                *(_DWORD *)v84 = 67109890;
                *(_DWORD *)&v84[4] = v36;
                *(_WORD *)v85 = 2082;
                *(_QWORD *)&v85[2] = v37;
                *(_WORD *)&v85[10] = 2082;
                *(_QWORD *)&v85[12] = v38;
                *(_WORD *)&v85[20] = 1024;
                *(_DWORD *)&v85[22] = 430;
                _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Subscribe notification failed", v84, 0x22u);
              }

            }
            else
            {
              IOObjectRelease(v19);
            }
            objc_destroyWeak(&from);
          }
          else
          {
            v64 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v65 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v64);
            if (v65)
            {
              v66 = object_getClass((id)v3);
              if (class_isMetaClass(v66))
                v67 = 43;
              else
                v67 = 45;
              v68 = object_getClassName((id)v3);
              v69 = sel_getName("listenForCameraNotificationFromPort:");
              v65(3, "%c[%{public}s %{public}s]:%i Service not available", v67, v68, v69, 378);
            }
            v70 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v71 = NFSharedLogGetLogger(v70);
            v72 = objc_claimAutoreleasedReturnValue(v71);
            if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
            {
              v73 = object_getClass((id)v3);
              if (class_isMetaClass(v73))
                v74 = 43;
              else
                v74 = 45;
              v75 = object_getClassName((id)v3);
              v76 = sel_getName("listenForCameraNotificationFromPort:");
              *(_DWORD *)buf = 67109890;
              *(_DWORD *)&buf[4] = v74;
              *(_WORD *)&buf[8] = 2082;
              *(_QWORD *)&buf[10] = v75;
              *(_WORD *)&buf[18] = 2082;
              *(_QWORD *)&buf[20] = v76;
              *(_WORD *)&buf[28] = 1024;
              *(_DWORD *)&buf[30] = 378;
              _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Service not available", buf, 0x22u);
            }

            v77 = NFSharedLogGetLogger(0);
            v78 = objc_claimAutoreleasedReturnValue(v77);
            if (os_log_type_enabled(v78, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "-[NFCameraStateMonitor listenForCameraNotificationFromPort:]";
              _os_log_fault_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_FAULT, "[%{public}s] Cannot locate service; check hardware configuration",
                buf,
                0xCu);
            }

          }
          v79 = objc_msgSend(sub_1001718B4(), "server");
          v80 = (void *)objc_claimAutoreleasedReturnValue(v79);
          *(_QWORD *)buf = _NSConcreteStackBlock;
          *(_QWORD *)&buf[8] = 3221225472;
          *(_QWORD *)&buf[16] = sub_10017196C;
          *(_QWORD *)&buf[24] = &unk_1002E9BE0;
          objc_copyWeak((id *)&buf[32], &location);
          *(_QWORD *)v84 = _NSConcreteStackBlock;
          *(_QWORD *)v85 = 3221225472;
          *(_QWORD *)&v85[8] = sub_100171AE4;
          *(_QWORD *)&v85[16] = &unk_1002E9C08;
          objc_copyWeak((id *)&v85[24], &location);
          objc_msgSend(v80, "registerSpringBoardActionHandler:withIdentifierCallback:", buf, v84);

          v81 = (id)v3;
          objc_sync_enter(v81);
          v81[16] = -1;
          objc_sync_exit(v81);

          objc_destroyWeak((id *)&v85[24]);
          objc_destroyWeak((id *)&buf[32]);
          goto LABEL_70;
        }
        v52 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v53 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v52);
        if (v53)
        {
          v54 = object_getClass((id)v3);
          if (class_isMetaClass(v54))
            v55 = 43;
          else
            v55 = 45;
          v56 = object_getClassName((id)v3);
          v57 = sel_getName("_registerForCameraNotifications");
          v53(3, "%c[%{public}s %{public}s]:%i Unable to get notify port", v55, v56, v57, 203);
        }
        v58 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v59 = NFSharedLogGetLogger(v58);
        v47 = objc_claimAutoreleasedReturnValue(v59);
        if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
        {
          v60 = object_getClass((id)v3);
          if (class_isMetaClass(v60))
            v61 = 43;
          else
            v61 = 45;
          v62 = object_getClassName((id)v3);
          v63 = sel_getName("_registerForCameraNotifications");
          *(_DWORD *)buf = 67109890;
          *(_DWORD *)&buf[4] = v61;
          *(_WORD *)&buf[8] = 2082;
          *(_QWORD *)&buf[10] = v62;
          *(_WORD *)&buf[18] = 2082;
          *(_QWORD *)&buf[20] = v63;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = 203;
          _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unable to get notify port", buf, 0x22u);
        }
      }
      else
      {
        v39 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v40 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v39);
        if (v40)
        {
          v41 = object_getClass((id)v3);
          if (class_isMetaClass(v41))
            v42 = 43;
          else
            v42 = 45;
          v43 = object_getClassName((id)v3);
          v44 = sel_getName("_registerForCameraNotifications");
          v40(6, "%c[%{public}s %{public}s]:%i No accessibility support", v42, v43, v44, 197);
        }
        v45 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v46 = NFSharedLogGetLogger(v45);
        v47 = objc_claimAutoreleasedReturnValue(v46);
        if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
        {
          v48 = object_getClass((id)v3);
          if (class_isMetaClass(v48))
            v49 = 43;
          else
            v49 = 45;
          v50 = object_getClassName((id)v3);
          v51 = sel_getName("_registerForCameraNotifications");
          *(_DWORD *)buf = 67109890;
          *(_DWORD *)&buf[4] = v49;
          *(_WORD *)&buf[8] = 2082;
          *(_QWORD *)&buf[10] = v50;
          *(_WORD *)&buf[18] = 2082;
          *(_QWORD *)&buf[20] = v51;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = 197;
          _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i No accessibility support", buf, 0x22u);
        }
      }

LABEL_70:
      objc_destroyWeak(&location);
    }
  }
}

void sub_100171554(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  objc_destroyWeak(&a13);
  _Unwind_Resume(a1);
}

void sub_1001715DC(os_unfair_lock_s *a1, void *a2)
{
  id v3;
  os_unfair_lock_s *v4;
  id v5;
  id v6;
  _QWORD v7[6];

  v3 = a2;
  if (a1)
  {
    v4 = a1 + 13;
    v7[1] = 3221225472;
    v7[2] = sub_100171668;
    v7[3] = &unk_1002E5CA8;
    v7[4] = a1;
    v6 = v3;
    v7[0] = _NSConcreteStackBlock;
    v5 = v3;
    v7[5] = v5;
    os_unfair_lock_lock(v4);
    sub_100171668((uint64_t)v7);
    os_unfair_lock_unlock(v4);

    v3 = v6;
  }

}

void sub_100171668(uint64_t a1)
{
  id v2;
  id v3;
  BOOL v4;
  uint64_t v5;
  void *specific;
  uint64_t Logger;
  void (*v8)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  NSObject *v15;
  objc_class *v16;
  int v17;
  IONotificationPort *v18;
  io_object_t v19;
  id v20;
  void *v21;
  void *v22;
  const char *Name;
  _BYTE buf[28];
  __int16 v25;
  int v26;

  v2 = objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 16), "count");
  objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 16), "removeObjectForKey:", *(_QWORD *)(a1 + 40));
  sub_1001708C0(*(_QWORD *)(a1 + 32));
  v3 = objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 16), "count");
  if (v2)
    v4 = v3 == 0;
  else
    v4 = 0;
  if (v4)
  {
    v5 = *(_QWORD *)(a1 + 32);
    if (v5)
    {
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v8 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass((id)v5);
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName((id)v5);
        Name = sel_getName("_unregisterCameraNotifications");
        v12 = 45;
        if (isMetaClass)
          v12 = 43;
        v8(6, "%c[%{public}s %{public}s]:%i ", v12, ClassName, Name, 168);
      }
      v13 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v14 = NFSharedLogGetLogger(v13);
      v15 = objc_claimAutoreleasedReturnValue(v14);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        v16 = object_getClass((id)v5);
        if (class_isMetaClass(v16))
          v17 = 43;
        else
          v17 = 45;
        *(_DWORD *)buf = 67109890;
        *(_DWORD *)&buf[4] = v17;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = object_getClassName((id)v5);
        *(_WORD *)&buf[18] = 2082;
        *(_QWORD *)&buf[20] = sel_getName("_unregisterCameraNotifications");
        v25 = 1024;
        v26 = 168;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
      }

      v18 = *(IONotificationPort **)(v5 + 40);
      if (v18)
      {
        IONotificationPortDestroy(v18);
        *(_QWORD *)(v5 + 40) = 0;
      }
      v19 = *(_DWORD *)(v5 + 48);
      if (v19)
      {
        IOObjectRelease(v19);
        *(_DWORD *)(v5 + 48) = 0;
      }
      if (!qword_10032AA38)
      {
        *(_OWORD *)buf = off_1002E9C68;
        *(_QWORD *)&buf[16] = 0;
        qword_10032AA38 = _sl_dlopen(buf, 0);
      }
      if (qword_10032AA38)
      {
        v20 = objc_msgSend(sub_1001718B4(), "server");
        v21 = (void *)objc_claimAutoreleasedReturnValue(v20);
        objc_msgSend(v21, "removeActionHandler:", *(_QWORD *)(v5 + 24));

      }
      v22 = *(void **)(v5 + 24);
      *(_QWORD *)(v5 + 24) = 0;

      *(_BYTE *)(v5 + 60) = 0;
    }
  }
}

id sub_1001718B4()
{
  void *v0;
  id v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2050000000;
  v0 = (void *)qword_10032AA40;
  v7 = qword_10032AA40;
  if (!qword_10032AA40)
  {
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    v3[2] = sub_100172138;
    v3[3] = &unk_1002E5E30;
    v3[4] = &v4;
    sub_100172138((uint64_t)v3);
    v0 = (void *)v5[3];
  }
  v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_100171954(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10017196C(uint64_t a1, uint64_t a2)
{
  id WeakRetained;
  void *v4;
  _BYTE *v5;
  NSObject **v6;
  dispatch_time_t v7;
  NSObject *v8;
  _QWORD block[5];

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v4 = WeakRetained;
  if (WeakRetained)
  {
    if (a2 == 10)
    {
      v6 = (NSObject **)WeakRetained;
      objc_sync_enter(v6);
      *((_BYTE *)v6 + 60) = 0;
      objc_sync_exit(v6);

      v7 = dispatch_time(0, 100000001);
      v8 = v6[4];
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_100171A40;
      block[3] = &unk_1002E5C58;
      block[4] = v6;
      dispatch_after(v7, v8, block);
    }
    else if (a2 == 9)
    {
      v5 = WeakRetained;
      objc_sync_enter(v5);
      v5[60] = 1;
      objc_sync_exit(v5);

    }
  }

}

void sub_100171A40(uint64_t a1)
{
  io_registry_entry_t v2;

  v2 = sub_100171A84(*(_QWORD *)(a1 + 32));
  if (v2)
    sub_1000065D8(*(void **)(a1 + 32), v2, -536870608);
}

uint64_t sub_100171A84(uint64_t result)
{
  unint64_t v1;
  const __CFDictionary *v2;

  if (result)
  {
    v1 = 0;
    do
    {
      v2 = IOServiceMatching((&off_1002E9C50)[v1]);
      result = IOServiceGetMatchingService(kIOMainPortDefault, v2);
      if (v1 > 1)
        break;
      ++v1;
    }
    while (!(_DWORD)result);
  }
  return result;
}

void sub_100171AE4(uint64_t a1, void *a2)
{
  id *WeakRetained;
  id *v5;
  id v6;

  v6 = a2;
  WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  v5 = WeakRetained;
  if (WeakRetained)
    objc_storeStrong(WeakRetained + 3, a2);

}

BOOL sub_100171B38(void *a1)
{
  _DWORD *v1;
  _BOOL8 v2;

  if (!a1)
    return 0;
  v1 = a1;
  objc_sync_enter(v1);
  v2 = v1[14] != 0;
  objc_sync_exit(v1);

  return v2;
}

BOOL sub_100171B84(os_unfair_lock_s *a1, void *a2)
{
  id v3;
  void *v4;
  os_unfair_lock_s *v5;
  _QWORD *v6;
  _BOOL8 v7;
  _QWORD v9[2];
  void (*v10)(_QWORD *);
  void *v11;
  os_unfair_lock_s *v12;
  id v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  char v18;

  v3 = a2;
  v4 = v3;
  if (a1)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v18 = 0;
    v5 = a1 + 13;
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    v10 = sub_100171C8C;
    v11 = &unk_1002E9C30;
    v14 = &v15;
    v12 = a1;
    v13 = v3;
    v6 = v9;
    os_unfair_lock_lock(v5);
    v10(v6);
    os_unfair_lock_unlock(v5);

    v7 = *((_BYTE *)v16 + 24) != 0;
    _Block_object_dispose(&v15, 8);
  }
  else
  {
    v7 = 0;
  }

  return v7;
}

void sub_100171C74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100171C8C(_QWORD *a1)
{
  void *v2;

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1[4] + 16), "objectForKey:", a1[5]));
  *(_BYTE *)(*(_QWORD *)(a1[6] + 8) + 24) = v2 != 0;

}

void sub_100171CCC(uint64_t a1)
{
  unsigned __int8 *WeakRetained;
  unsigned __int8 *v3;
  _BOOL8 v4;
  void *specific;
  uint64_t Logger;
  void (*v7)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  NSObject *v15;
  objc_class *v16;
  int v17;
  const char *v18;
  const char *v19;
  int v20;
  const char *v21;
  NSObject *v22;
  unsigned __int8 *v23;
  int v24;
  int v25;
  void *v26;
  uint64_t v27;
  void (*v28)(uint64_t, const char *, ...);
  objc_class *v29;
  _BOOL4 v30;
  const char *v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  NSObject *v35;
  objc_class *v36;
  int v37;
  const char *v38;
  const char *v39;
  id v40;
  id v41;
  id v42;
  uint64_t v43;
  void *i;
  void *v45;
  const char *v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  _BYTE v51[128];
  uint8_t buf[8];
  _BYTE v53[10];
  __int16 v54;
  const char *v55;
  __int16 v56;
  int v57;
  __int16 v58;
  _BOOL4 v59;
  __int16 v60;
  int v61;

  WeakRetained = (unsigned __int8 *)objc_loadWeakRetained((id *)(a1 + 32));
  v3 = WeakRetained;
  if (WeakRetained)
  {
    v4 = sub_100171B38(WeakRetained);
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v7 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v3);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(v3);
      Name = sel_getName(*(SEL *)(a1 + 40));
      v12 = 45;
      if (isMetaClass)
        v12 = 43;
      v7(6, "%c[%{public}s %{public}s]:%i state changed: status= %u, visualAlert=%d", v12, ClassName, Name, 397, v4, v3[60]);
    }
    v13 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v14 = NFSharedLogGetLogger(v13);
    v15 = objc_claimAutoreleasedReturnValue(v14);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v16 = object_getClass(v3);
      if (class_isMetaClass(v16))
        v17 = 43;
      else
        v17 = 45;
      v18 = object_getClassName(v3);
      v19 = sel_getName(*(SEL *)(a1 + 40));
      v20 = v3[60];
      *(_DWORD *)buf = 67110402;
      *(_DWORD *)&buf[4] = v17;
      *(_WORD *)v53 = 2082;
      *(_QWORD *)&v53[2] = v18;
      v54 = 2082;
      v55 = v19;
      v56 = 1024;
      v57 = 397;
      v58 = 1024;
      v59 = v4;
      v60 = 1024;
      v61 = v20;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i state changed: status= %u, visualAlert=%d", buf, 0x2Eu);
    }

    if (v4)
      v21 = "com.apple.nfcd.camera.debounceTimer.on";
    else
      v21 = "com.apple.nfcd.camera.debounceTimer.off";
    v22 = _os_activity_create((void *)&_mh_execute_header, v21, (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
    *(_QWORD *)buf = 0;
    *(_QWORD *)v53 = 0;
    os_activity_scope_enter(v22, (os_activity_scope_state_t)buf);
    os_activity_scope_leave((os_activity_scope_state_t)buf);

    v23 = v3;
    objc_sync_enter(v23);
    v24 = *((_DWORD *)v23 + 16);
    v25 = *((_DWORD *)v23 + 14);
    *((_DWORD *)v23 + 16) = -1;
    objc_sync_exit(v23);

    if (!v23[60])
    {
      if (v24 == v25)
      {
        v26 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v27 = NFLogGetLogger(v26);
        if (v27)
        {
          v28 = (void (*)(uint64_t, const char *, ...))v27;
          v29 = object_getClass(v23);
          v30 = class_isMetaClass(v29);
          v31 = object_getClassName(v23);
          v46 = sel_getName(*(SEL *)(a1 + 40));
          v32 = 45;
          if (v30)
            v32 = 43;
          v28(5, "%c[%{public}s %{public}s]:%i No state change after debounce", v32, v31, v46, 408);
        }
        v33 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v34 = NFSharedLogGetLogger(v33);
        v35 = objc_claimAutoreleasedReturnValue(v34);
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
        {
          v36 = object_getClass(v23);
          if (class_isMetaClass(v36))
            v37 = 43;
          else
            v37 = 45;
          v38 = object_getClassName(v23);
          v39 = sel_getName(*(SEL *)(a1 + 40));
          *(_DWORD *)buf = 67109890;
          *(_DWORD *)&buf[4] = v37;
          *(_WORD *)v53 = 2082;
          *(_QWORD *)&v53[2] = v38;
          v54 = 2082;
          v55 = v39;
          v56 = 1024;
          v57 = 408;
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i No state change after debounce", buf, 0x22u);
        }
      }
      else
      {
        os_unfair_lock_lock((os_unfair_lock_t)v23 + 13);
        v40 = objc_msgSend(*((id *)v23 + 2), "copy");
        os_unfair_lock_unlock((os_unfair_lock_t)v23 + 13);
        v49 = 0u;
        v50 = 0u;
        v47 = 0u;
        v48 = 0u;
        v35 = v40;
        v41 = -[NSObject countByEnumeratingWithState:objects:count:](v35, "countByEnumeratingWithState:objects:count:", &v47, v51, 16);
        if (v41)
        {
          v42 = v41;
          v43 = *(_QWORD *)v48;
          do
          {
            for (i = 0; i != v42; i = (char *)i + 1)
            {
              if (*(_QWORD *)v48 != v43)
                objc_enumerationMutation(v35);
              v45 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject objectForKey:](v35, "objectForKey:", *(_QWORD *)(*((_QWORD *)&v47 + 1) + 8 * (_QWORD)i)));
              objc_msgSend(v45, "didCameraStateChange:", v4);

            }
            v42 = -[NSObject countByEnumeratingWithState:objects:count:](v35, "countByEnumeratingWithState:objects:count:", &v47, v51, 16);
          }
          while (v42);
        }

      }
    }
  }

}

Class sub_100172138(uint64_t a1)
{
  Class result;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  __int128 v7;
  uint64_t v8;

  v6 = 0;
  if (!qword_10032AA38)
  {
    v7 = off_1002E9C68;
    v8 = 0;
    qword_10032AA38 = _sl_dlopen(&v7, &v6);
  }
  if (!qword_10032AA38)
  {
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
    v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "void *AccessibilityUtilitiesLibrary(void)"));
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, CFSTR("NFCameraStateMonitor.m"), 21, CFSTR("%s"), v6);

    goto LABEL_10;
  }
  if (v6)
    free(v6);
  result = objc_getClass("AXSpringBoardServer");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Class getAXSpringBoardServerClass(void)_block_invoke"));
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v5, CFSTR("NFCameraStateMonitor.m"), 22, CFSTR("Unable to find class %s"), "AXSpringBoardServer");

LABEL_10:
    __break(1u);
  }
  qword_10032AA40 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

id *sub_1001722D4(id *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  objc_super v8;

  v5 = a2;
  v6 = a3;
  if (a1)
  {
    v8.receiver = a1;
    v8.super_class = (Class)NFAssertSuppressPresentmentIntentToDefaultApp;
    a1 = (id *)objc_msgSendSuper2(&v8, "initWithRemoteAssertion:", v5);
    if (a1)
    {
      *((_BYTE *)a1 + 16) = objc_msgSend(v5, "assertionType") == (id)6;
      objc_storeStrong(a1 + 3, a3);
    }
  }

  return a1;
}

id sub_100172E84(uint64_t a1)
{
  objc_opt_self(a1);
  if (qword_10032AA50 != -1)
    dispatch_once(&qword_10032AA50, &stru_1002E9C80);
  return (id)qword_10032AA48;
}

void sub_100172EC8(id a1)
{
  NFLPCDRandomGenerator *v1;
  void *v2;

  v1 = objc_alloc_init(NFLPCDRandomGenerator);
  v2 = (void *)qword_10032AA48;
  qword_10032AA48 = (uint64_t)v1;

}

void sub_100172F78(os_unfair_lock_s *a1, void *a2)
{
  id v3;
  void *v4;
  void *specific;
  uint64_t Logger;
  void (*v7)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  NSObject *v15;
  objc_class *v16;
  int v17;
  os_unfair_lock_s *v18;
  id v19;
  id v20;
  _QWORD v21[6];
  uint8_t buf[4];
  int v23;
  __int16 v24;
  const char *v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  id v31;

  v3 = a2;
  v4 = v3;
  if (a1)
  {
    if ((unint64_t)objc_msgSend(v3, "length") <= 0xC && (unint64_t)objc_msgSend(v4, "length") > 5)
    {
      v18 = a1 + 3;
      v21[0] = _NSConcreteStackBlock;
      v21[1] = 3221225472;
      v21[2] = sub_1001731B8;
      v21[3] = &unk_1002E5CA8;
      v21[4] = a1;
      v19 = v4;
      v21[5] = v19;
      os_unfair_lock_lock(v18);
      sub_1001731B8((uint64_t)v21);
      os_unfair_lock_unlock(v18);

    }
    else
    {
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v7 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(a1);
        Name = sel_getName("setOverride:");
        v20 = objc_msgSend(v4, "length");
        v12 = 45;
        if (isMetaClass)
          v12 = 43;
        v7(3, "%c[%{public}s %{public}s]:%i Invalid data size: %ld", v12, ClassName, Name, 57, v20);
      }
      v13 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v14 = NFSharedLogGetLogger(v13);
      v15 = objc_claimAutoreleasedReturnValue(v14);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        v16 = object_getClass(a1);
        if (class_isMetaClass(v16))
          v17 = 43;
        else
          v17 = 45;
        *(_DWORD *)buf = 67110146;
        v23 = v17;
        v24 = 2082;
        v25 = object_getClassName(a1);
        v26 = 2082;
        v27 = sel_getName("setOverride:");
        v28 = 1024;
        v29 = 57;
        v30 = 2048;
        v31 = objc_msgSend(v4, "length");
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid data size: %ld", buf, 0x2Cu);
      }

    }
  }

}

void sub_1001731B8(uint64_t a1)
{
  uint64_t v2;
  id v3;

  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
    *(_BYTE *)(v2 + 8) = 1;
  v3 = objc_msgSend(objc_alloc((Class)NSMutableData), "initWithData:", *(_QWORD *)(a1 + 40));
  sub_100173214(*(_QWORD *)(a1 + 32), v3);

}

void sub_100173214(uint64_t a1, void *a2)
{
  if (a1)
    objc_storeStrong((id *)(a1 + 24), a2);
}

void sub_100173224(uint64_t a1)
{
  os_unfair_lock_s *v2;

  if (a1)
  {
    v2 = (os_unfair_lock_s *)(a1 + 12);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 12));
    *(_BYTE *)(a1 + 8) = 0;
    sub_100173214(a1, 0);
    os_unfair_lock_unlock(v2);
  }
}

uint64_t sub_100173268(os_unfair_lock_s *a1)
{
  os_unfair_lock_s *v1;
  _QWORD *v2;
  uint64_t v3;
  _QWORD v5[2];
  void (*v6)(uint64_t);
  void *v7;
  os_unfair_lock_s *v8;
  uint64_t *v9;
  const char *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;

  if (!a1)
    return 0;
  v11 = 0;
  v12 = &v11;
  v13 = 0x2020000000;
  v14 = 0;
  v1 = a1 + 3;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v6 = sub_100173348;
  v7 = &unk_1002E9CA8;
  v9 = &v11;
  v10 = "value";
  v8 = a1;
  v2 = v5;
  os_unfair_lock_lock(v1);
  v6((uint64_t)v2);
  os_unfair_lock_unlock(v1);

  v3 = v12[3];
  _Block_object_dispose(&v11, 8);
  return v3;
}

void sub_100173330(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_100173348(uint64_t a1)
{
  _BYTE *v2;
  uint64_t v3;
  _BYTE *v4;
  unsigned __int8 *v5;
  void *specific;
  uint64_t Logger;
  void (*v8)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  NSObject *v15;
  objc_class *v16;
  int v17;
  const char *v18;
  const char *v19;
  unint64_t v20;
  const char *Name;
  uint8_t buf[4];
  int v23;
  __int16 v24;
  const char *v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  uint64_t v31;

  v2 = *(_BYTE **)(a1 + 32);
  if (v2)
  {
    v3 = 24;
    if (!v2[8])
      v3 = 16;
    v2 = *(_BYTE **)&v2[v3];
  }
  v4 = objc_retainAutorelease(v2);
  v5 = (unsigned __int8 *)objc_msgSend(v4, "bytes");
  if ((unint64_t)objc_msgSend(v4, "length") >= 9)
  {
    objc_msgSend(v4, "setLength:", 8);
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v8 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      v12 = 45;
      if (isMetaClass)
        v12 = 43;
      v8(4, "%c[%{public}s %{public}s]:%i Dropping %zu MSBs", v12, ClassName, Name, 88, 8);
    }
    v5 += 8;
    v13 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v14 = NFSharedLogGetLogger(v13);
    v15 = objc_claimAutoreleasedReturnValue(v14);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      v16 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v16))
        v17 = 43;
      else
        v17 = 45;
      v18 = object_getClassName(*(id *)(a1 + 32));
      v19 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)buf = 67110146;
      v23 = v17;
      v24 = 2082;
      v25 = v18;
      v26 = 2082;
      v27 = v19;
      v28 = 1024;
      v29 = 88;
      v30 = 2048;
      v31 = 8;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Dropping %zu MSBs", buf, 0x2Cu);
    }

  }
  if (objc_msgSend(v4, "length"))
  {
    v20 = 0;
    do
    {
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) <<= 8;
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) |= *v5;
      ++v20;
    }
    while ((unint64_t)objc_msgSend(v4, "length") > v20);
  }

}

id sub_100173588(os_unfair_lock_s *a1)
{
  os_unfair_lock_s *v1;
  _QWORD *v2;
  id v3;
  _QWORD v5[2];
  void (*v6)(uint64_t);
  void *v7;
  os_unfair_lock_s *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t (*v13)(uint64_t, uint64_t);
  void (*v14)(uint64_t);
  id v15;

  if (!a1)
    return 0;
  v10 = 0;
  v11 = &v10;
  v12 = 0x3032000000;
  v13 = sub_100173680;
  v14 = sub_100173690;
  v15 = 0;
  v1 = a1 + 3;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v6 = sub_100173698;
  v7 = &unk_1002E5EA8;
  v8 = a1;
  v9 = &v10;
  v2 = v5;
  os_unfair_lock_lock(v1);
  v6((uint64_t)v2);
  os_unfair_lock_unlock(v1);

  v3 = (id)v11[5];
  _Block_object_dispose(&v10, 8);

  return v3;
}

void sub_100173668(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100173680(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_100173690(uint64_t a1)
{

}

void sub_100173698(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  id v5;

  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
  {
    v3 = 24;
    if (!*(_BYTE *)(v2 + 8))
      v3 = 16;
    v4 = *(void **)(v2 + v3);
  }
  else
  {
    v4 = 0;
  }
  v5 = v4;
  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), v4);

}

void sub_100173704(os_unfair_lock_s *a1)
{
  os_unfair_lock_s *v1;
  _QWORD v2[5];

  if (a1)
  {
    v1 = a1 + 3;
    v2[0] = _NSConcreteStackBlock;
    v2[1] = 3221225472;
    v2[2] = sub_100173774;
    v2[3] = &unk_1002E5C58;
    v2[4] = a1;
    os_unfair_lock_lock(a1 + 3);
    sub_100173774((uint64_t)v2);
    os_unfair_lock_unlock(v1);
  }
}

void sub_100173774(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  id v4;
  uint64_t v5;
  void *v6;

  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
  {
    if (*(_BYTE *)(v2 + 8))
      return;
    v3 = *(void **)(v2 + 16);
  }
  else
  {
    v3 = 0;
  }
  v4 = objc_msgSend(objc_retainAutorelease(v3), "mutableBytes");
  v5 = *(_QWORD *)(a1 + 32);
  if (v5)
    v6 = *(void **)(v5 + 16);
  else
    v6 = 0;
  arc4random_buf(v4, (size_t)objc_msgSend(v6, "length"));
}

void sub_100174538(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  uint64_t v15;
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v15 - 128), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100174570(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_100174580(uint64_t a1)
{

}

void sub_100174588(uint64_t a1, void *a2, void *a3, int a4)
{
  id v7;
  id v8;
  void *v9;
  id v10;
  id v11;
  useconds_t v12;
  NSObject *v13;
  BOOL v14;
  void *v15;
  NFContactlessPaymentEndEvent *v16;
  uint64_t v17;
  void *v18;
  void *v19;
  id v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  id v25;
  id v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  NSObject *v31;
  uint64_t v32;
  void *v33;
  id v34;
  _QWORD block[4];
  id v36;
  id v37;
  id v38;
  id location;
  id v40;

  v7 = a2;
  v8 = a3;
  v9 = v8;
  if (!v7 || v8)
  {
    v10 = *(id *)(a1 + 32);

    v7 = v10;
  }
  objc_msgSend(*(id *)(a1 + 40), "sendAPDU:", v7);
  if (a4)
  {
    v11 = objc_msgSend(objc_alloc((Class)NSUserDefaults), "initWithSuiteName:", CFSTR("com.apple.stockholm"));
    if (objc_msgSend(v11, "integerForKey:", CFSTR("DelayAfterStepUpOperation")))
      v12 = 1000 * objc_msgSend(v11, "integerForKey:", CFSTR("DelayAfterStepUpOperation"));
    else
      v12 = 50000;
    usleep(v12);
    if (v7)
      v14 = v9 == 0;
    else
      v14 = 0;
    if (v14)
      v15 = &__kCFBooleanFalse;
    else
      v15 = &__kCFBooleanTrue;
    objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 40), "setObject:forKeyedSubscript:", v15, CFSTR("didError"));
    v16 = -[NFContactlessPaymentEndEvent initWithDictionary:]([NFContactlessPaymentEndEvent alloc], "initWithDictionary:", *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 40));
    v17 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8);
    v18 = *(void **)(v17 + 40);
    *(_QWORD *)(v17 + 40) = v16;

    v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)(a1 + 48) + 48), "identifier"));
    if (v19)
    {
      v20 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A548, 9);
      v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "NF_asHexString"));

      if (!objc_msgSend(v19, "compare:options:range:", v21, 1, 0, objc_msgSend(v21, "length")))
      {
        v34 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A551, 2);
        v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)(a1 + 48) + 48), "identifier"));
        v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)(a1 + 48) + 48), "packageIdentifier"));
        v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)(a1 + 48) + 48), "moduleIdentifier"));
        v40 = v9;
        v25 = +[AppletTranslator parseHCIEvent:withApplet:withPackage:withModule:withTransceiver:withError:](AppletTranslator, "parseHCIEvent:withApplet:withPackage:withModule:withTransceiver:withError:", v34, v22, v23, v24, 0, &v40);
        v26 = v40;

        v9 = v26;
      }

    }
    (*(void (**)(void))(*(_QWORD *)(a1 + 56) + 16))();
    v27 = *(_QWORD *)(a1 + 48);
    v28 = *(void **)(v27 + 32);
    if (v28)
    {
      sub_1000A6FB8((uint64_t)NFUnifiedAccessTransactionCALogger, v28, *(unsigned int *)(v27 + 40), (uint64_t)objc_msgSend(v9, "code"));
      v30 = NFSharedSignpostLog(v29);
      v31 = objc_claimAutoreleasedReturnValue(v30);
      if (os_signpost_enabled(v31))
      {
        LOWORD(location) = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v31, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "AtlEvent", "AtlStepUpEventComplete", (uint8_t *)&location, 2u);
      }

      v32 = *(_QWORD *)(a1 + 48);
      v33 = *(void **)(v32 + 32);
      *(_QWORD *)(v32 + 32) = 0;

    }
  }
  else
  {
    objc_initWeak(&location, *(id *)(a1 + 48));
    v13 = *(NSObject **)(*(_QWORD *)(a1 + 48) + 16);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10017494C;
    block[3] = &unk_1002E9CD0;
    objc_copyWeak(&v38, &location);
    v37 = *(id *)(a1 + 56);
    v36 = *(id *)(a1 + 40);
    dispatch_async(v13, block);

    objc_destroyWeak(&v38);
    objc_destroyWeak(&location);
  }

}

void sub_10017494C(uint64_t a1)
{
  id WeakRetained;
  id v3;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  v3 = WeakRetained;
  if (WeakRetained)
    objc_msgSend(WeakRetained, "hceReadWithHandle:completion:", *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
  else
    (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

}

id sub_1001749F8(uint64_t a1)
{
  objc_opt_self(a1);
  if (qword_10032AA60 != -1)
    dispatch_once(&qword_10032AA60, &stru_1002E9D18);
  return (id)qword_10032AA58;
}

void sub_100174A3C(id a1)
{
  uint64_t v1;
  void *v2;
  void *v3;
  id v4;
  void *v5;
  void *v6;
  NSXPCInterface *v7;
  void *v8;
  id v9;
  uint64_t v10;
  id v11;

  v1 = objc_claimAutoreleasedReturnValue(+[NSXPCInterface interfaceWithProtocol:](NSXPCInterface, "interfaceWithProtocol:", &OBJC_PROTOCOL___NFHardwareManagerAccessoryInterface));
  v2 = (void *)qword_10032AA58;
  qword_10032AA58 = v1;

  v3 = (void *)qword_10032AA58;
  v4 = sub_10016D6D0((uint64_t)NFReaderSessionAccessoryCallbacks);
  v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  objc_msgSend(v3, "setInterface:forSelector:argumentIndex:ofReply:", v5, "queueReaderSession:callback:", 0, 0);

  v6 = (void *)qword_10032AA58;
  v7 = sub_10016D6AC((uint64_t)NFReaderSessionAccessoryInterface);
  v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
  objc_msgSend(v6, "setInterface:forSelector:argumentIndex:ofReply:", v8, "queueReaderSession:callback:", 0, 1);

  v9 = objc_alloc((Class)NSSet);
  v10 = objc_opt_class(NSArray);
  v11 = objc_msgSend(v9, "initWithObjects:", v10, objc_opt_class(NFTagInternal), 0);
  objc_msgSend((id)qword_10032AA58, "setClasses:forSelector:argumentIndex:ofReply:", v11, "getLastDetectedTags:", 0, 1);
  objc_msgSend((id)qword_10032AA58, "setClasses:forSelector:argumentIndex:ofReply:", v11, "getMultiTagState:", 0, 1);

}

id sub_100174B78(uint64_t a1)
{
  objc_opt_self(a1);
  if (qword_10032AA70 != -1)
    dispatch_once(&qword_10032AA70, &stru_1002E9D38);
  return (id)qword_10032AA68;
}

void sub_100174BBC(id a1)
{
  uint64_t v1;
  void *v2;

  v1 = objc_claimAutoreleasedReturnValue(+[NSXPCInterface interfaceWithProtocol:](NSXPCInterface, "interfaceWithProtocol:", &OBJC_PROTOCOL___NFHardwareManagerAccessoryCallbacks));
  v2 = (void *)qword_10032AA68;
  qword_10032AA68 = v1;

}

uint64_t sub_100174BF0(void *a1, void *a2, int a3, _QWORD *a4)
{
  id v5;
  void *v6;
  uint64_t v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  NSMutableDictionary *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  NSMutableDictionary *v19;
  id v20;
  unsigned __int8 v21;
  NSObject *v22;
  NSObject *v23;
  void *v24;
  void *specific;
  uint64_t Logger;
  void (*v27)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  NSObject *p_super;
  objc_class *v35;
  int v36;
  uint64_t v37;
  void *v38;
  uint64_t v39;
  void (*v40)(uint64_t, const char *, ...);
  objc_class *v41;
  _BOOL4 v42;
  const char *v43;
  uint64_t v44;
  void *v45;
  uint64_t v46;
  objc_class *v47;
  int v48;
  void *v49;
  uint64_t v50;
  void (*v51)(uint64_t, const char *, ...);
  objc_class *v52;
  _BOOL4 v53;
  const char *v54;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  NSObject *v58;
  objc_class *v59;
  int v60;
  void *v61;
  id v62;
  void *v63;
  void (*v64)(uint64_t, const char *, ...);
  objc_class *v65;
  uint64_t v66;
  const char *v67;
  const char *v68;
  void *v69;
  uint64_t v70;
  NSObject *v71;
  objc_class *v72;
  int v73;
  const char *v74;
  const char *v75;
  void *v76;
  void (*v77)(uint64_t, const char *, ...);
  objc_class *v78;
  uint64_t v79;
  const char *v80;
  const char *v81;
  void *v82;
  uint64_t v83;
  NSObject *v84;
  objc_class *v85;
  int v86;
  const char *v87;
  const char *v88;
  void *v89;
  void *v90;
  void *v91;
  void (*v92)(uint64_t, const char *, ...);
  objc_class *v93;
  uint64_t v94;
  const char *v95;
  const char *v96;
  void *v97;
  uint64_t v98;
  NSObject *v99;
  objc_class *v100;
  int v101;
  const char *v102;
  const char *v103;
  id v104;
  id v105;
  id v106;
  unsigned int v107;
  unsigned int v108;
  unsigned int v109;
  NSObject *v110;
  void *v111;
  NSMutableDictionary *v112;
  id v113;
  void *v114;
  NSObject *v115;
  uint8_t *v116;
  char *v117;
  void *v118;
  void *v119;
  void *v120;
  void *v121;
  void *v122;
  void *v123;
  uint64_t v124;
  void (*v125)(uint64_t, const char *, ...);
  objc_class *v126;
  _BOOL4 v127;
  const char *v128;
  const char *v129;
  uint64_t v130;
  void *v131;
  uint64_t v132;
  NSObject *v133;
  objc_class *v134;
  int v135;
  const char *v136;
  const char *v137;
  unsigned int v138;
  void *v139;
  void (*v140)(uint64_t, const char *, ...);
  objc_class *v141;
  uint64_t v142;
  const char *v143;
  const char *v144;
  void *v145;
  uint64_t v146;
  objc_class *v147;
  int v148;
  const char *v149;
  const char *v150;
  void *v151;
  void *v152;
  uint64_t v153;
  void *v154;
  uint64_t v155;
  void *v156;
  id v157;
  unsigned __int8 v158;
  id v159;
  void *v160;
  NSMutableDictionary *v161;
  id v162;
  id v163;
  id v164;
  id v165;
  id v166;
  id v167;
  id v168;
  id v169;
  void *v170;
  void *v171;
  uint64_t v172;
  id v173;
  unsigned int v174;
  id v175;
  id v176;
  id v177;
  id v178;
  void *v179;
  NSObject *v180;
  id v181;
  id v182;
  void *v183;
  void *v184;
  void (*v185)(uint64_t, const char *, ...);
  objc_class *v186;
  uint64_t v187;
  const char *v188;
  const char *v189;
  void *v190;
  uint64_t v191;
  NSObject *v192;
  objc_class *v193;
  int v194;
  const char *v195;
  const char *v196;
  void *v197;
  void *v198;
  uint64_t v199;
  void (*v200)(uint64_t, const char *, ...);
  objc_class *v201;
  _BOOL4 v202;
  const char *v203;
  uint64_t v204;
  void *v205;
  uint64_t v206;
  NSObject *v207;
  objc_class *v208;
  int v209;
  const char *v210;
  const char *v211;
  id v212;
  id v213;
  void *v214;
  void *v215;
  void (*v216)(uint64_t, const char *, ...);
  objc_class *v217;
  uint64_t v218;
  const char *v219;
  const char *v220;
  void *v221;
  uint64_t v222;
  NSObject *v223;
  objc_class *v224;
  int v225;
  const char *v226;
  const char *v227;
  BOOL v228;
  _UNKNOWN **v229;
  void *v230;
  void *v231;
  uint64_t v232;
  void (*v233)(uint64_t, const char *, ...);
  objc_class *v234;
  _BOOL4 v235;
  const char *v236;
  uint64_t v237;
  void *v238;
  uint64_t v239;
  NSObject *v240;
  objc_class *v241;
  int v242;
  const char *v243;
  const char *v244;
  void *v245;
  uint64_t v246;
  void (*v247)(uint64_t, const char *, ...);
  objc_class *v248;
  _BOOL4 v249;
  const char *v250;
  uint64_t v251;
  void *v252;
  uint64_t v253;
  NSObject *v254;
  objc_class *v255;
  int v256;
  const char *v257;
  const char *v258;
  void *v259;
  void *v260;
  void *v261;
  id v262;
  void *v263;
  void *v264;
  NSMutableArray *v265;
  id v266;
  id v267;
  id v268;
  id v269;
  id v270;
  id v271;
  id v272;
  id v273;
  const char *v274;
  const char *v275;
  void *v276;
  void *v277;
  unsigned __int8 v278;
  NSMutableDictionary *v279;
  void *v280;
  void *v281;
  void *v282;
  unsigned __int8 v283;
  void *v284;
  void *v285;
  void *v286;
  void *v287;
  void *v288;
  void (*v289)(uint64_t, const char *, ...);
  objc_class *v290;
  uint64_t v291;
  const char *v292;
  const char *v293;
  void *v294;
  void *v295;
  void *v296;
  uint64_t v297;
  NSObject *v298;
  objc_class *v299;
  int v300;
  const char *v301;
  const char *v302;
  void *v303;
  void *v304;
  void *v305;
  NSObject *v306;
  id v307;
  uint64_t v308;
  void *j;
  void *v310;
  void *v311;
  _BOOL4 v312;
  void *v313;
  void (*v314)(uint64_t, const char *, ...);
  objc_class *v315;
  uint64_t v316;
  const char *v317;
  const char *v318;
  void *v319;
  void *v320;
  uint64_t v321;
  objc_class *v322;
  int v323;
  const char *v324;
  const char *v325;
  void *v326;
  void *v327;
  void *v328;
  void *v329;
  NSObject *v330;
  void *v331;
  void *v332;
  void (*v333)(uint64_t, const char *, ...);
  objc_class *v334;
  uint64_t v335;
  const char *v336;
  const char *v337;
  void *v338;
  void *v339;
  uint64_t v340;
  objc_class *v341;
  int v342;
  const char *v343;
  const char *v344;
  void *v345;
  void *v346;
  void *v347;
  void *v348;
  void *v349;
  void *v350;
  void *v351;
  void *v352;
  void *v353;
  void *v354;
  id v355;
  void *v356;
  _UNKNOWN **v357;
  void *v358;
  id v359;
  void *v360;
  void *v361;
  void (*v362)(uint64_t, const char *, ...);
  objc_class *v363;
  uint64_t v364;
  const char *v365;
  const char *v366;
  void *v367;
  uint64_t v368;
  objc_class *v369;
  int v370;
  const char *v371;
  const char *v372;
  NSMutableArray *v373;
  id v374;
  void *v375;
  id v376;
  void *v377;
  id v378;
  void *v379;
  id v380;
  void *v381;
  void *v382;
  void *v383;
  uint64_t v384;
  void *v385;
  NSObject *v386;
  void *v387;
  void (*v388)(uint64_t, const char *, ...);
  objc_class *v389;
  uint64_t v390;
  const char *v391;
  const char *v392;
  void *v393;
  uint64_t v394;
  objc_class *v395;
  int v396;
  const char *v397;
  const char *v398;
  uint64_t v399;
  NSMutableArray *v400;
  NSObject *v401;
  void *v402;
  void (*v403)(uint64_t, const char *, ...);
  objc_class *v404;
  uint64_t v405;
  const char *v406;
  const char *v407;
  void *v408;
  uint64_t v409;
  objc_class *v410;
  int v411;
  const char *v412;
  const char *v413;
  id v414;
  unsigned __int8 v415;
  id v416;
  void *v417;
  void *v418;
  void *v419;
  void *v420;
  void *v421;
  NSMutableData *v422;
  void *v423;
  void *v424;
  void *v425;
  NSMutableData *v426;
  id v427;
  void *v428;
  void *v429;
  void *v430;
  void *v431;
  void *v432;
  void *v433;
  NSObject *v434;
  id v435;
  uint64_t v436;
  void *i;
  void *v438;
  int v439;
  id v441;
  void *v442;
  NSObject *v443;
  void *v444;
  void (*v445)(uint64_t, const char *, ...);
  objc_class *v446;
  uint64_t v447;
  const char *v448;
  const char *v449;
  void *v450;
  uint64_t v451;
  objc_class *v452;
  int v453;
  const char *v454;
  const char *v455;
  unsigned int v456;
  void *v457;
  void *v458;
  void *v459;
  void (*v460)(uint64_t, const char *, ...);
  objc_class *v461;
  uint64_t v462;
  const char *v463;
  const char *v464;
  void *v465;
  uint64_t v466;
  objc_class *v467;
  int v468;
  const char *v469;
  const char *v470;
  void *v471;
  void (*v472)(uint64_t, const char *, ...);
  objc_class *v473;
  uint64_t v474;
  const char *v475;
  const char *v476;
  void *v477;
  uint64_t v478;
  objc_class *v479;
  int v480;
  const char *v481;
  const char *v482;
  unsigned int v483;
  NSMutableDictionary *v484;
  void *v485;
  void *v486;
  void *v487;
  char *v488;
  void *v489;
  void *v490;
  void (*v491)(uint64_t, const char *, ...);
  objc_class *v492;
  uint64_t v493;
  const char *v494;
  const char *v495;
  void *v496;
  uint64_t v497;
  NSObject *v498;
  objc_class *v499;
  int v500;
  const char *v501;
  const char *v502;
  id v503;
  void *v504;
  NSMutableDictionary *v505;
  NSMutableDictionary *v506;
  NSMutableDictionary *v507;
  void *v508;
  void *v509;
  _QWORD *v510;
  void *v511;
  void *v512;
  BOOL v513;
  void *v514;
  id v515;
  void *v516;
  void *v517;
  _BOOL4 v518;
  void *v519;
  void *v520;
  void *v521;
  void *v522;
  void *v523;
  void *v524;
  void *v525;
  void *v526;
  void *v527;
  void *v528;
  void *v529;
  void *v530;
  NSMutableDictionary *v531;
  NSMutableDictionary *v532;
  NSMutableDictionary *v533;
  void *v534;
  void (*v535)(uint64_t, const char *, ...);
  objc_class *v536;
  uint64_t v537;
  const char *v538;
  const char *v539;
  void *v540;
  uint64_t v541;
  NSObject *v542;
  objc_class *v543;
  int v544;
  const char *v545;
  const char *v546;
  unsigned int v547;
  NSMutableDictionary *v548;
  void *v549;
  void (*v550)(uint64_t, const char *, ...);
  objc_class *v551;
  uint64_t v552;
  const char *v553;
  const char *v554;
  void *v555;
  uint64_t v556;
  NSObject *v557;
  objc_class *v558;
  int v559;
  const char *v560;
  const char *v561;
  void *v562;
  void (*v563)(uint64_t, const char *, ...);
  objc_class *v564;
  uint64_t v565;
  const char *v566;
  const char *v567;
  void *v568;
  uint64_t v569;
  objc_class *v570;
  int v571;
  const char *v572;
  const char *v573;
  unsigned int v574;
  void *v575;
  void (*v576)(uint64_t, const char *, ...);
  objc_class *v577;
  uint64_t v578;
  const char *v579;
  const char *v580;
  void *v581;
  uint64_t v582;
  objc_class *v583;
  int v584;
  const char *v585;
  const char *v586;
  void *v587;
  void (*v588)(uint64_t, const char *, ...);
  objc_class *v589;
  uint64_t v590;
  const char *v591;
  const char *v592;
  void *v593;
  uint64_t v594;
  objc_class *v595;
  int v596;
  const char *v597;
  const char *v598;
  NSMutableDictionary *v599;
  const char *Name;
  const char *v602;
  const char *v603;
  const char *v604;
  const char *v605;
  const char *v606;
  uint64_t v607;
  void *v608;
  NSMutableData *v609;
  unsigned int v611;
  NSMutableDictionary *v612;
  NSMutableDictionary *v613;
  void *v614;
  void *v615;
  void *v616;
  void *v617;
  NSMutableDictionary *v618;
  void *v619;
  void *v620;
  id obj;
  id obja;
  char *v623;
  void *v624;
  void *v625;
  NSMutableDictionary *v626;
  os_log_t oslogb;
  NSMutableArray *oslog;
  NSMutableData *osloga;
  os_log_t logc;
  os_log_t log;
  NSObject *loga;
  os_log_t logb;
  void *v634;
  void *v635;
  SEL v636;
  char *v638;
  SEL v639;
  char *v640;
  void *v641;
  void *v642;
  NSMutableDictionary *v643;
  id v644;
  id v645;
  id v646;
  id v647;
  _QWORD v648[4];
  id v649;
  id v650;
  const __CFString *v651;
  NSMutableDictionary *v652;
  const __CFString *v653;
  NSMutableArray *v654;
  __int128 v655;
  __int128 v656;
  __int128 v657;
  __int128 v658;
  const __CFString *v659;
  const __CFString *v660;
  const __CFString *v661;
  const __CFString *v662;
  const __CFString *v663;
  uint8_t md[48];
  __int128 v665;
  uint8_t v666[8];
  _BYTE v667[20];
  __int16 v668;
  int v669;
  __int16 v670;
  void *v671;
  __int16 v672;
  void *v673;
  uint8_t v674[48];
  __int128 v675;
  _QWORD v676[3];
  _QWORD v677[5];
  uint8_t buf[8];
  _BYTE v679[32];
  os_log_t v680;
  id v681;
  uint8_t *v682;
  const char *v683;
  void *v684;
  void *v685;
  void *v686;
  void *v687;

  v5 = a2;
  v645 = a1;
  v614 = v5;
  if (!a1)
  {
    v37 = 0;
    goto LABEL_496;
  }
  v6 = v5;
  v618 = objc_opt_new(NSMutableDictionary);
  v616 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "objectForKeyedSubscript:", CFSTR("version")));
  if (v616)
  {
    v7 = objc_opt_class(NSNumber);
    if ((objc_opt_isKindOfClass(v616, v7) & 1) != 0)
      v611 = objc_msgSend(v616, "unsignedIntValue");
    else
      v611 = 2;
  }
  else
  {
    v611 = 2;
  }
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "serialNumber"));

  if (!v8)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v27 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(v645);
      Name = sel_getName("remoteAdminState:appletFiltering:stateInfo:");
      v31 = 45;
      if (isMetaClass)
        v31 = 43;
      v27(3, "%c[%{public}s %{public}s]:%i Failed to get serial number failing remote admin state", v31, ClassName, Name, 103);
    }
    v32 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v33 = NFSharedLogGetLogger(v32);
    p_super = objc_claimAutoreleasedReturnValue(v33);
    if (os_log_type_enabled(p_super, OS_LOG_TYPE_ERROR))
    {
      v35 = object_getClass(v645);
      if (class_isMetaClass(v35))
        v36 = 43;
      else
        v36 = 45;
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)&buf[4] = v36;
      *(_WORD *)v679 = 2082;
      *(_QWORD *)&v679[2] = object_getClassName(v645);
      *(_WORD *)&v679[10] = 2082;
      *(_QWORD *)&v679[12] = sel_getName("remoteAdminState:appletFiltering:stateInfo:");
      *(_WORD *)&v679[20] = 1024;
      *(_DWORD *)&v679[22] = 103;
      _os_log_impl((void *)&_mh_execute_header, p_super, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get serial number failing remote admin state", buf, 0x22u);
    }
    v37 = 13;
    goto LABEL_495;
  }
  -[NSMutableDictionary setObject:forKey:](v618, "setObject:forKey:", CFSTR("JCOP"), CFSTR("secureElementType"));
  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "serialNumber"));
  -[NSMutableDictionary setObject:forKey:](v618, "setObject:forKey:", v9, CFSTR("SEID"));

  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "rsaCertificate"));
  v11 = a1;
  if (v10)
  {
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "eccCertificate"));

    v11 = v645;
    if (v12)
    {
      v13 = objc_opt_new(NSMutableDictionary);
      v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v645, "rsaCertificate"));
      -[NSMutableDictionary setObject:forKey:](v13, "setObject:forKey:", v14, CFSTR("RSA"));

      v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v645, "eccCertificate"));
      -[NSMutableDictionary setObject:forKey:](v13, "setObject:forKey:", v15, CFSTR("ECDSA"));

      if (v611 <= 3)
      {
        v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v645, "eccCertificate"));
        -[NSMutableDictionary setObject:forKey:](v13, "setObject:forKey:", v16, CFSTR("ECC"));

        v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v645, "eckaCertificate"));
        if (v17)
        {
          v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v645, "eckaCertificate"));
          -[NSMutableDictionary setObject:forKey:](v13, "setObject:forKey:", v18, CFSTR("ECKA"));

        }
      }
      -[NSMutableDictionary setObject:forKey:](v618, "setObject:forKey:", v13, CFSTR("casdCertificate"));

      v11 = v645;
    }
  }
  v19 = objc_opt_new(NSMutableDictionary);
  v20 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A554, 8);
  v21 = objc_msgSend(v11, "select:error:", v20, 0);

  if ((v21 & 1) != 0)
  {
    v22 = objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "getData:", 193));
    v23 = v22;
    if (v22)
    {
      v24 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject NF_asHexString](v22, "NF_asHexString"));
      -[NSMutableDictionary setObject:forKey:](v19, "setObject:forKey:", v24, CFSTR("isdSequenceCounter"));

    }
    else
    {
      v49 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v50 = NFLogGetLogger(v49);
      if (v50)
      {
        v51 = (void (*)(uint64_t, const char *, ...))v50;
        v52 = object_getClass(v645);
        v53 = class_isMetaClass(v52);
        v54 = object_getClassName(v645);
        v603 = sel_getName("_getISDInfo");
        v55 = 45;
        if (v53)
          v55 = 43;
        v51(3, "%c[%{public}s %{public}s]:%i Failed to get sequence counter", v55, v54, v603, 300);
      }
      v56 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v57 = NFSharedLogGetLogger(v56);
      v58 = objc_claimAutoreleasedReturnValue(v57);
      if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
      {
        v59 = object_getClass(v645);
        if (class_isMetaClass(v59))
          v60 = 43;
        else
          v60 = 45;
        *(_DWORD *)buf = 67109890;
        *(_DWORD *)&buf[4] = v60;
        *(_WORD *)v679 = 2082;
        *(_QWORD *)&v679[2] = object_getClassName(v645);
        *(_WORD *)&v679[10] = 2082;
        *(_QWORD *)&v679[12] = sel_getName("_getISDInfo");
        *(_WORD *)&v679[20] = 1024;
        *(_DWORD *)&v679[22] = 300;
        _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get sequence counter", buf, 0x22u);
      }

    }
    v61 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v645, "getData:subtag:", 254, 57120));
    if (v61)
    {
      v62 = objc_msgSend(objc_alloc((Class)NSString), "initWithData:encoding:", v61, 4);
      if (v62)
      {
        -[NSMutableDictionary setObject:forKey:](v19, "setObject:forKey:", v62, CFSTR("kPlatformId"));
LABEL_72:
        v89 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v645, "getData:subtag:", 254, 57137));
        v90 = v89;
        if (v89 && (unint64_t)objc_msgSend(v89, "length") > 1)
        {
          v104 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v90, "subdataWithRange:", 0, 2));
          v105 = v62;
          v106 = objc_retainAutorelease(v104);
          v107 = *(unsigned __int16 *)objc_msgSend(v106, "bytes");
          v108 = objc_msgSend(v105, "isEqualToString:", CFSTR("N5E0000000990000"));
          if (bswap32(v107) >> 16 > 0xB3)
            v109 = v108;
          else
            v109 = 0;
          if (v109 == 1)
            v110 = objc_claimAutoreleasedReturnValue(+[NSData NF_dataWithHexString:](NSData, "NF_dataWithHexString:", CFSTR("00B3")));
          else
            v110 = v106;
          v99 = v110;

          v111 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject NF_asHexString](v99, "NF_asHexString"));
          -[NSMutableDictionary setObject:forKey:](v19, "setObject:forKey:", v111, CFSTR("jsblSequenceCounter"));

        }
        else
        {
          v91 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v92 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v91);
          if (v92)
          {
            v93 = object_getClass(v645);
            if (class_isMetaClass(v93))
              v94 = 43;
            else
              v94 = 45;
            v95 = object_getClassName(v645);
            v96 = sel_getName("_getISDInfo");
            v92(3, "%c[%{public}s %{public}s]:%i Failed to get update info", v94, v95, v96, 324);
          }
          v97 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v98 = NFSharedLogGetLogger(v97);
          v99 = objc_claimAutoreleasedReturnValue(v98);
          if (os_log_type_enabled(v99, OS_LOG_TYPE_ERROR))
          {
            v100 = object_getClass(v645);
            if (class_isMetaClass(v100))
              v101 = 43;
            else
              v101 = 45;
            v102 = object_getClassName(v645);
            v103 = sel_getName("_getISDInfo");
            *(_DWORD *)buf = 67109890;
            *(_DWORD *)&buf[4] = v101;
            *(_WORD *)v679 = 2082;
            *(_QWORD *)&v679[2] = v102;
            *(_WORD *)&v679[10] = 2082;
            *(_QWORD *)&v679[12] = v103;
            *(_WORD *)&v679[20] = 1024;
            *(_DWORD *)&v679[22] = 324;
            _os_log_impl((void *)&_mh_execute_header, v99, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get update info", buf, 0x22u);
          }
        }

        v613 = v19;
        goto LABEL_92;
      }
      v63 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v64 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v63);
      if (v64)
      {
        v65 = object_getClass(v645);
        if (class_isMetaClass(v65))
          v66 = 43;
        else
          v66 = 45;
        v67 = object_getClassName(v645);
        v68 = sel_getName("_getISDInfo");
        v64(3, "%c[%{public}s %{public}s]:%i Fail to encode platform ID into string", v66, v67, v68, 310);
      }
      v69 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v70 = NFSharedLogGetLogger(v69);
      v71 = objc_claimAutoreleasedReturnValue(v70);
      if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
      {
        v72 = object_getClass(v645);
        if (class_isMetaClass(v72))
          v73 = 43;
        else
          v73 = 45;
        v74 = object_getClassName(v645);
        v75 = sel_getName("_getISDInfo");
        *(_DWORD *)buf = 67109890;
        *(_DWORD *)&buf[4] = v73;
        *(_WORD *)v679 = 2082;
        *(_QWORD *)&v679[2] = v74;
        *(_WORD *)&v679[10] = 2082;
        *(_QWORD *)&v679[12] = v75;
        *(_WORD *)&v679[20] = 1024;
        *(_DWORD *)&v679[22] = 310;
        _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Fail to encode platform ID into string", buf, 0x22u);
      }

    }
    v76 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v77 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v76);
    if (v77)
    {
      v78 = object_getClass(v645);
      if (class_isMetaClass(v78))
        v79 = 43;
      else
        v79 = 45;
      v80 = object_getClassName(v645);
      v81 = sel_getName("_getISDInfo");
      v77(3, "%c[%{public}s %{public}s]:%i Failed to get platform ID", v79, v80, v81, 318);
    }
    v82 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v83 = NFSharedLogGetLogger(v82);
    v84 = objc_claimAutoreleasedReturnValue(v83);
    if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR))
    {
      v85 = object_getClass(v645);
      if (class_isMetaClass(v85))
        v86 = 43;
      else
        v86 = 45;
      v87 = object_getClassName(v645);
      v88 = sel_getName("_getISDInfo");
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)&buf[4] = v86;
      *(_WORD *)v679 = 2082;
      *(_QWORD *)&v679[2] = v87;
      *(_WORD *)&v679[10] = 2082;
      *(_QWORD *)&v679[12] = v88;
      *(_WORD *)&v679[20] = 1024;
      *(_DWORD *)&v679[22] = 318;
      _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get platform ID", buf, 0x22u);
    }

    v62 = 0;
    goto LABEL_72;
  }
  v38 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v39 = NFLogGetLogger(v38);
  if (v39)
  {
    v40 = (void (*)(uint64_t, const char *, ...))v39;
    v41 = object_getClass(v11);
    v42 = class_isMetaClass(v41);
    v43 = object_getClassName(v11);
    v602 = sel_getName("_getISDInfo");
    v44 = 45;
    if (v42)
      v44 = 43;
    v40(3, "%c[%{public}s %{public}s]:%i Failed to select ISD", v44, v43, v602, 290);
  }
  v45 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v46 = NFSharedLogGetLogger(v45);
  v23 = objc_claimAutoreleasedReturnValue(v46);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
  {
    v47 = object_getClass(v645);
    if (class_isMetaClass(v47))
      v48 = 43;
    else
      v48 = 45;
    *(_DWORD *)buf = 67109890;
    *(_DWORD *)&buf[4] = v48;
    *(_WORD *)v679 = 2082;
    *(_QWORD *)&v679[2] = object_getClassName(v645);
    *(_WORD *)&v679[10] = 2082;
    *(_QWORD *)&v679[12] = sel_getName("_getISDInfo");
    *(_WORD *)&v679[20] = 1024;
    *(_DWORD *)&v679[22] = 290;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select ISD", buf, 0x22u);
  }
  v613 = 0;
LABEL_92:

  if (v613)
    -[NSMutableDictionary addEntriesFromDictionary:](v618, "addEntriesFromDictionary:");
  v112 = objc_opt_new(NSMutableDictionary);
  v113 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A55C, 12);
  v114 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v645, "selectByName:error:", v113, 0));

  if (objc_msgSend(v114, "status") == 26277)
  {
    -[NSMutableDictionary setObject:forKey:](v112, "setObject:forKey:", &__kCFBooleanTrue, CFSTR("restrictedMode"));
LABEL_120:
    v612 = v112;
    goto LABEL_121;
  }
  if (objc_msgSend(v114, "status") == 36864)
  {
    LODWORD(v675) = 0;
    memset(v674, 0, sizeof(v674));
    if (sub_1000974B8(v645, (uint64_t)v674))
    {
      *(_QWORD *)&v655 = CFSTR("persistentMemory");
      v115 = objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)v674));
      *(_QWORD *)buf = v115;
      *((_QWORD *)&v655 + 1) = CFSTR("clearOnResetMemory");
      v641 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)&v674[4]));
      *(_QWORD *)v679 = v641;
      *(_QWORD *)&v656 = CFSTR("clearOnDeselectMemory");
      v638 = (char *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)&v674[8]));
      *(_QWORD *)&v679[8] = v638;
      *((_QWORD *)&v656 + 1) = CFSTR("availableIndicies");
      v634 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)&v674[12]));
      *(_QWORD *)&v679[16] = v634;
      *(_QWORD *)&v657 = CFSTR("totalNumberOfIndicies");
      logc = (os_log_t)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)&v674[16]));
      *(_QWORD *)&v679[24] = logc;
      *((_QWORD *)&v657 + 1) = CFSTR("availablePersistent");
      oslogb = (os_log_t)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)&v674[20]));
      v680 = oslogb;
      *(_QWORD *)&v658 = CFSTR("availableTransienteUICC");
      v624 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)&v674[24]));
      v681 = v624;
      *((_QWORD *)&v658 + 1) = CFSTR("reservedClearOnDelect");
      v116 = (uint8_t *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)&v674[28]));
      v682 = v116;
      v659 = CFSTR("maximumMappedClearOnDeselect");
      v117 = (char *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)&v674[32]));
      v683 = v117;
      v660 = CFSTR("reservedTransientOSUpdate");
      v118 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)&v674[36]));
      v684 = v118;
      v661 = CFSTR("reservedPersistentOSUpdate");
      v119 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)&v674[40]));
      v685 = v119;
      v662 = CFSTR("transientCommonPool");
      v120 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)&v674[44]));
      v686 = v120;
      v663 = CFSTR("persistentCommonPool");
      v121 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v675));
      v687 = v121;
      v122 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v655, 13));
      -[NSMutableDictionary setObject:forKey:](v112, "setObject:forKey:", v122, CFSTR("availableMemory"));

    }
    else
    {
      v139 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v140 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v139);
      if (v140)
      {
        v141 = object_getClass(v645);
        if (class_isMetaClass(v141))
          v142 = 43;
        else
          v142 = 45;
        v143 = object_getClassName(v645);
        v144 = sel_getName("_getCASDInfo");
        v140(4, "%c[%{public}s %{public}s]:%i Failed to get memory info", v142, v143, v144, 415);
      }
      v145 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v146 = NFSharedLogGetLogger(v145);
      v115 = objc_claimAutoreleasedReturnValue(v146);
      if (os_log_type_enabled(v115, OS_LOG_TYPE_ERROR))
      {
        v147 = object_getClass(v645);
        if (class_isMetaClass(v147))
          v148 = 43;
        else
          v148 = 45;
        v149 = object_getClassName(v645);
        v150 = sel_getName("_getCASDInfo");
        *(_DWORD *)buf = 67109890;
        *(_DWORD *)&buf[4] = v148;
        *(_WORD *)v679 = 2082;
        *(_QWORD *)&v679[2] = v149;
        *(_WORD *)&v679[10] = 2082;
        *(_QWORD *)&v679[12] = v150;
        *(_WORD *)&v679[20] = 1024;
        *(_DWORD *)&v679[22] = 415;
        _os_log_impl((void *)&_mh_execute_header, v115, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get memory info", buf, 0x22u);
      }
    }

    goto LABEL_120;
  }
  v123 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v124 = NFLogGetLogger(v123);
  if (v124)
  {
    v125 = (void (*)(uint64_t, const char *, ...))v124;
    v126 = object_getClass(v645);
    v127 = class_isMetaClass(v126);
    v128 = object_getClassName(v645);
    v129 = sel_getName("_getCASDInfo");
    v607 = objc_msgSend(v114, "status");
    v130 = 45;
    if (v127)
      v130 = 43;
    v125(3, "%c[%{public}s %{public}s]:%i Failed to select CASD: 0x%04x", v130, v128, v129, 408, v607);
  }
  v131 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v132 = NFSharedLogGetLogger(v131);
  v133 = objc_claimAutoreleasedReturnValue(v132);
  if (os_log_type_enabled(v133, OS_LOG_TYPE_ERROR))
  {
    v134 = object_getClass(v645);
    if (class_isMetaClass(v134))
      v135 = 43;
    else
      v135 = 45;
    v136 = object_getClassName(v645);
    v137 = sel_getName("_getCASDInfo");
    v138 = objc_msgSend(v114, "status");
    *(_DWORD *)buf = 67110146;
    *(_DWORD *)&buf[4] = v135;
    *(_WORD *)v679 = 2082;
    *(_QWORD *)&v679[2] = v136;
    *(_WORD *)&v679[10] = 2082;
    *(_QWORD *)&v679[12] = v137;
    *(_WORD *)&v679[20] = 1024;
    *(_DWORD *)&v679[22] = 408;
    *(_WORD *)&v679[26] = 1024;
    *(_DWORD *)&v679[28] = v138;
    _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select CASD: 0x%04x", buf, 0x28u);
  }

  v612 = 0;
LABEL_121:

  if (v612)
    -[NSMutableDictionary addEntriesFromDictionary:](v618, "addEntriesFromDictionary:");
  v615 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary valueForKey:](v618, "valueForKey:", CFSTR("restrictedMode")));

  v151 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v645, "handle"));
  v152 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v151, "info"));
  v153 = (uint64_t)objc_msgSend(v152, "deviceType");

  if (v153 > 99)
  {
    v154 = v645;
    if (v153 > 199)
    {
      if (v153 == 200)
      {
        v155 = 7;
      }
      else
      {
        if (v153 != 210)
          goto LABEL_186;
        v155 = 8;
      }
    }
    else if (v153 == 100)
    {
      v155 = 6;
    }
    else
    {
      if (v153 != 115)
        goto LABEL_186;
      v155 = 5;
    }
  }
  else
  {
    v154 = v645;
    if (v153 > 54)
    {
      if (v153 == 55)
      {
        v155 = 10;
      }
      else
      {
        if (v153 != 56)
          goto LABEL_186;
        v155 = 13;
      }
    }
    else
    {
      if (v153 != 44)
      {
        if (v153 == 54)
        {
          v155 = 11;
          goto LABEL_142;
        }
LABEL_186:
        v231 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v232 = NFLogGetLogger(v231);
        if (v232)
        {
          v233 = (void (*)(uint64_t, const char *, ...))v232;
          v234 = object_getClass(v154);
          v235 = class_isMetaClass(v234);
          v236 = object_getClassName(v154);
          v605 = sel_getName("_getTSMHardwareType");
          v237 = 45;
          if (v235)
            v237 = 43;
          v233(3, "%c[%{public}s %{public}s]:%i Critical error : unsupported hardware!", v237, v236, v605, 83);
        }
        v238 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v239 = NFSharedLogGetLogger(v238);
        v240 = objc_claimAutoreleasedReturnValue(v239);
        if (os_log_type_enabled(v240, OS_LOG_TYPE_ERROR))
        {
          v241 = object_getClass(v645);
          if (class_isMetaClass(v241))
            v242 = 43;
          else
            v242 = 45;
          v243 = object_getClassName(v645);
          v244 = sel_getName("_getTSMHardwareType");
          *(_DWORD *)buf = 67109890;
          *(_DWORD *)&buf[4] = v242;
          *(_WORD *)v679 = 2082;
          *(_QWORD *)&v679[2] = v243;
          *(_WORD *)&v679[10] = 2082;
          *(_QWORD *)&v679[12] = v244;
          *(_WORD *)&v679[20] = 1024;
          *(_DWORD *)&v679[22] = 83;
          _os_log_impl((void *)&_mh_execute_header, v240, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Critical error : unsupported hardware!", buf, 0x22u);
        }

        v245 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v246 = NFLogGetLogger(v245);
        if (v246)
        {
          v247 = (void (*)(uint64_t, const char *, ...))v246;
          v248 = object_getClass(v645);
          v249 = class_isMetaClass(v248);
          v250 = object_getClassName(v645);
          v606 = sel_getName("remoteAdminState:appletFiltering:stateInfo:");
          v251 = 45;
          if (v249)
            v251 = 43;
          v247(3, "%c[%{public}s %{public}s]:%i Unknown hardware platform", v251, v250, v606, 143);
        }
        v252 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v253 = NFSharedLogGetLogger(v252);
        v254 = objc_claimAutoreleasedReturnValue(v253);
        if (os_log_type_enabled(v254, OS_LOG_TYPE_ERROR))
        {
          v255 = object_getClass(v645);
          if (class_isMetaClass(v255))
            v256 = 43;
          else
            v256 = 45;
          v257 = object_getClassName(v645);
          v258 = sel_getName("remoteAdminState:appletFiltering:stateInfo:");
          *(_DWORD *)buf = 67109890;
          *(_DWORD *)&buf[4] = v256;
          *(_WORD *)v679 = 2082;
          *(_QWORD *)&v679[2] = v257;
          *(_WORD *)&v679[10] = 2082;
          *(_QWORD *)&v679[12] = v258;
          *(_WORD *)&v679[20] = 1024;
          *(_DWORD *)&v679[22] = 143;
          _os_log_impl((void *)&_mh_execute_header, v254, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unknown hardware platform", buf, 0x22u);
        }

        v259 = 0;
        v37 = 6;
        goto LABEL_494;
      }
      v155 = 9;
    }
  }
LABEL_142:
  v156 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", v155));
  -[NSMutableDictionary setObject:forKey:](v618, "setObject:forKey:", v156, CFSTR("hardwareType"));

  if (!v615)
  {
    if (sub_100179018((_BOOL8)v645))
    {
      v162 = sub_100179134(v645, a3);
      v635 = (void *)objc_claimAutoreleasedReturnValue(v162);
      v163 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A662, 8);
      *(_QWORD *)&v655 = v163;
      v164 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A66A, 9);
      *((_QWORD *)&v655 + 1) = v164;
      v165 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A673, 12);
      *(_QWORD *)&v656 = v165;
      v166 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A67F, 14);
      *((_QWORD *)&v656 + 1) = v166;
      v167 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A68D, 8);
      *(_QWORD *)&v657 = v167;
      v168 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A695, 10);
      *((_QWORD *)&v657 + 1) = v168;
      v169 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A69F, 12);
      *(_QWORD *)&v658 = v169;
      v170 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v655, 7));
      v171 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithArray:](NSMutableArray, "arrayWithArray:", v170));

      if (NFIsInternalBuild(v172))
      {
        v173 = objc_msgSend(objc_alloc((Class)NSUserDefaults), "initWithSuiteName:", CFSTR("nfcd"));
        v174 = objc_msgSend(v173, "BOOLForKey:", CFSTR("UnhideFTA"));

        if (v174)
        {
          v175 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A67F, 14);
          objc_msgSend(v171, "removeObject:", v175);

        }
      }
      v176 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A6AB, 13);
      *(_QWORD *)v666 = v176;
      v177 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A6B8, 12);
      *(_QWORD *)v667 = v177;
      v178 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A6C4, 15);
      *(_QWORD *)&v667[8] = v178;
      v179 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v666, 3));

      *(_QWORD *)v674 = 0;
      *(_QWORD *)&v674[8] = v674;
      *(_QWORD *)&v674[16] = 0x3032000000;
      *(_QWORD *)&v674[24] = sub_10017C2C4;
      *(_QWORD *)&v674[32] = sub_10017C2D4;
      *(_QWORD *)&v674[40] = objc_opt_new(NSMutableArray);
      *(_QWORD *)buf = _NSConcreteStackBlock;
      *(_QWORD *)v679 = 3221225472;
      *(_QWORD *)&v679[8] = sub_10017DAF8;
      *(_QWORD *)&v679[16] = &unk_1002E9DD8;
      *(_QWORD *)&v679[24] = v645;
      v683 = "getStatusProprietaryPackagesWithFiltering:";
      LOBYTE(v684) = a3;
      v180 = v179;
      v680 = v180;
      v181 = v171;
      v681 = v181;
      v682 = v674;
      v182 = sub_10017CDE0(v645, 16, (uint64_t)&unk_10026A65E, 4uLL, buf);
      v183 = (void *)objc_claimAutoreleasedReturnValue(v182);
      if (v183)
      {
        v184 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v185 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v184);
        if (v185)
        {
          v186 = object_getClass(v645);
          if (class_isMetaClass(v186))
            v187 = 43;
          else
            v187 = 45;
          v188 = object_getClassName(v645);
          v189 = sel_getName("getStatusProprietaryPackagesWithFiltering:");
          v185(3, "%c[%{public}s %{public}s]:%i Failed to call proprietary get status %{public}@", v187, v188, v189, 1084, v183);
        }
        v190 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v191 = NFSharedLogGetLogger(v190);
        v192 = objc_claimAutoreleasedReturnValue(v191);
        if (os_log_type_enabled(v192, OS_LOG_TYPE_ERROR))
        {
          v193 = object_getClass(v645);
          if (class_isMetaClass(v193))
            v194 = 43;
          else
            v194 = 45;
          v195 = object_getClassName(v645);
          v196 = sel_getName("getStatusProprietaryPackagesWithFiltering:");
          *(_DWORD *)md = 67110146;
          *(_DWORD *)&md[4] = v194;
          *(_WORD *)&md[8] = 2082;
          *(_QWORD *)&md[10] = v195;
          *(_WORD *)&md[18] = 2082;
          *(_QWORD *)&md[20] = v196;
          *(_WORD *)&md[28] = 1024;
          *(_DWORD *)&md[30] = 1084;
          *(_WORD *)&md[34] = 2114;
          *(_QWORD *)&md[36] = v183;
          _os_log_impl((void *)&_mh_execute_header, v192, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to call proprietary get status %{public}@", md, 0x2Cu);
        }

        v197 = 0;
      }
      else
      {
        v677[0] = CFSTR("packages");
        *(_QWORD *)md = *(_QWORD *)(*(_QWORD *)&v674[8] + 40);
        v197 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", md, v677, 1));
      }

      _Block_object_dispose(v674, 8);
      v358 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v635, "objectForKeyedSubscript:", CFSTR("orphanedSSDs")));
      v648[0] = _NSConcreteStackBlock;
      v648[1] = 3221225472;
      v648[2] = sub_100179B18;
      v648[3] = &unk_1002E9D60;
      v359 = v197;
      v649 = v359;
      v360 = (void *)objc_claimAutoreleasedReturnValue(+[NSPredicate predicateWithBlock:](NSPredicate, "predicateWithBlock:", v648));
      objc_msgSend(v358, "filterUsingPredicate:", v360);

      if (v635)
        -[NSMutableDictionary addEntriesFromDictionary:](v618, "addEntriesFromDictionary:", v635);
      if (v359)
        -[NSMutableDictionary addEntriesFromDictionary:](v618, "addEntriesFromDictionary:", v359);

      goto LABEL_309;
    }
    v650 = 0;
    v212 = objc_msgSend(v645, "selectCRSWithError:", &v650);
    v213 = v650;
    if (v213)
    {
      v214 = v213;
      v215 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v216 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v215);
      if (v216)
      {
        v217 = object_getClass(v645);
        if (class_isMetaClass(v217))
          v218 = 43;
        else
          v218 = 45;
        v219 = object_getClassName(v645);
        v220 = sel_getName("_getCRSInfoWithFiltering:");
        v216(3, "%c[%{public}s %{public}s]:%i Failed to select CRS: %{public}@", v218, v219, v220, 443, v214);
      }
      v221 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v222 = NFSharedLogGetLogger(v221);
      v223 = objc_claimAutoreleasedReturnValue(v222);
      if (os_log_type_enabled(v223, OS_LOG_TYPE_ERROR))
      {
        v224 = object_getClass(v645);
        if (class_isMetaClass(v224))
          v225 = 43;
        else
          v225 = 45;
        v226 = object_getClassName(v645);
        v227 = sel_getName("_getCRSInfoWithFiltering:");
        *(_DWORD *)v666 = 67110146;
        *(_DWORD *)&v666[4] = v225;
        *(_WORD *)v667 = 2082;
        *(_QWORD *)&v667[2] = v226;
        *(_WORD *)&v667[10] = 2082;
        *(_QWORD *)&v667[12] = v227;
        v668 = 1024;
        v669 = 443;
        v670 = 2114;
        v671 = v214;
        _os_log_impl((void *)&_mh_execute_header, v223, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select CRS: %{public}@", v666, 0x2Cu);
      }

      v228 = objc_msgSend(v214, "code") == (id)24;
      if (!v228)
      {
        v635 = 0;
        v230 = v645;
LABEL_299:
        v373 = objc_opt_new(NSMutableArray);
        v374 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A5CE, 12);
        v375 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v230, "selectByName:error:", v374, 0));

        if (objc_msgSend(v375, "status") == 36864)
        {
          v376 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A5CE, 12);
          v377 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v376, "NF_asHexString"));
          -[NSMutableArray addObject:](v373, "addObject:", v377);

        }
        v378 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A5DA, 12);
        v379 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v645, "selectByName:error:", v378, 0));

        if (objc_msgSend(v379, "status") == 36864)
        {
          v380 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A5DA, 12);
          v381 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v380, "NF_asHexString"));
          -[NSMutableArray addObject:](v373, "addObject:", v381);

        }
        if (-[NSMutableArray count](v373, "count"))
        {
          *(_QWORD *)&v655 = CFSTR("VASDs");
          *(_QWORD *)buf = v373;
          v382 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v655, 1));
        }
        else
        {
          v382 = 0;
        }

        if (v382)
          -[NSMutableDictionary addEntriesFromDictionary:](v618, "addEntriesFromDictionary:", v382);

LABEL_309:
        if (v611 >= 4)
        {
          v383 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v614, "objectForKeyedSubscript:", CFSTR("whitelistedInstances")));
          v384 = objc_opt_class(NSArray);
          if ((objc_opt_isKindOfClass(v383, v384) & 1) != 0 && objc_msgSend(v383, "count"))
          {
            v385 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v383, "objectAtIndexedSubscript:", 0));
            if (v385)
              v386 = objc_claimAutoreleasedReturnValue(objc_msgSend(v383, "objectAtIndexedSubscript:", 0));
            else
              v386 = 0;

            v399 = objc_opt_class(NSData);
            if ((objc_opt_isKindOfClass(v386, v399) & 1) != 0)
            {
              v400 = sub_100179C64(v645, v635, v386);
              v401 = objc_claimAutoreleasedReturnValue(v400);
              if (v401)
                -[NSMutableDictionary setObject:forKeyedSubscript:](v618, "setObject:forKeyedSubscript:", v401, CFSTR("protocolV4Containers"));
            }
            else
            {
              v402 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v403 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v402);
              if (v403)
              {
                v404 = object_getClass(v645);
                if (class_isMetaClass(v404))
                  v405 = 43;
                else
                  v405 = 45;
                v406 = object_getClassName(v645);
                v407 = sel_getName("remoteAdminState:appletFiltering:stateInfo:");
                v403(3, "%c[%{public}s %{public}s]:%i Unexpected type for allow listed AID.", v405, v406, v407, 203);
              }
              v408 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v409 = NFSharedLogGetLogger(v408);
              v401 = objc_claimAutoreleasedReturnValue(v409);
              if (os_log_type_enabled(v401, OS_LOG_TYPE_ERROR))
              {
                v410 = object_getClass(v645);
                if (class_isMetaClass(v410))
                  v411 = 43;
                else
                  v411 = 45;
                v412 = object_getClassName(v645);
                v413 = sel_getName("remoteAdminState:appletFiltering:stateInfo:");
                *(_DWORD *)buf = 67109890;
                *(_DWORD *)&buf[4] = v411;
                *(_WORD *)v679 = 2082;
                *(_QWORD *)&v679[2] = v412;
                *(_WORD *)&v679[10] = 2082;
                *(_QWORD *)&v679[12] = v413;
                *(_WORD *)&v679[20] = 1024;
                *(_DWORD *)&v679[22] = 203;
                _os_log_impl((void *)&_mh_execute_header, v401, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unexpected type for allow listed AID.", buf, 0x22u);
              }
            }

          }
          else
          {
            v387 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v388 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v387);
            if (v388)
            {
              v389 = object_getClass(v645);
              if (class_isMetaClass(v389))
                v390 = 43;
              else
                v390 = 45;
              v391 = object_getClassName(v645);
              v392 = sel_getName("remoteAdminState:appletFiltering:stateInfo:");
              v388(4, "%c[%{public}s %{public}s]:%i No whitelisted AID found. Will not populate the V4 container!", v390, v391, v392, 207);
            }
            v393 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v394 = NFSharedLogGetLogger(v393);
            v386 = objc_claimAutoreleasedReturnValue(v394);
            if (os_log_type_enabled(v386, OS_LOG_TYPE_ERROR))
            {
              v395 = object_getClass(v645);
              if (class_isMetaClass(v395))
                v396 = 43;
              else
                v396 = 45;
              v397 = object_getClassName(v645);
              v398 = sel_getName("remoteAdminState:appletFiltering:stateInfo:");
              *(_DWORD *)buf = 67109890;
              *(_DWORD *)&buf[4] = v396;
              *(_WORD *)v679 = 2082;
              *(_QWORD *)&v679[2] = v397;
              *(_WORD *)&v679[10] = 2082;
              *(_QWORD *)&v679[12] = v398;
              *(_WORD *)&v679[20] = 1024;
              *(_DWORD *)&v679[22] = 207;
              _os_log_impl((void *)&_mh_execute_header, v386, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i No whitelisted AID found. Will not populate the V4 container!", buf, 0x22u);
            }
          }

        }
        v414 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A554, 8);
        v415 = objc_msgSend(v645, "select:error:", v414, 0);

        if ((v415 & 1) != 0)
        {
          v416 = sub_10017B250(v645, 1);
          loga = objc_claimAutoreleasedReturnValue(v416);
          if (loga)
            -[NSMutableDictionary addEntriesFromDictionary:](v618, "addEntriesFromDictionary:", loga);
          v626 = v618;
          v417 = objc_autoreleasePoolPush();
          v418 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKey:](v626, "objectForKey:", CFSTR("casdCertificate")));
          v419 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v418, "objectForKey:", CFSTR("RSA")));
          v420 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v418, "objectForKey:", CFSTR("ECDSA")));
          v421 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKey:](v626, "objectForKey:", CFSTR("isdSequenceCounter")));
          v422 = objc_opt_new(NSMutableData);
          if (v420 && v419)
          {
            v423 = (void *)objc_claimAutoreleasedReturnValue(+[NSData NF_dataWithHexString:](NSData, "NF_dataWithHexString:", v420));
            -[NSMutableData appendData:](v422, "appendData:", v423);

            v424 = (void *)objc_claimAutoreleasedReturnValue(+[NSData NF_dataWithHexString:](NSData, "NF_dataWithHexString:", v419));
            -[NSMutableData appendData:](v422, "appendData:", v424);

          }
          v425 = (void *)objc_claimAutoreleasedReturnValue(+[NSData NF_dataWithHexString:](NSData, "NF_dataWithHexString:", v421));
          -[NSMutableData appendData:](v422, "appendData:", v425);

          v426 = objc_retainAutorelease(v422);
          CC_SHA256(-[NSMutableData bytes](v426, "bytes"), (CC_LONG)-[NSMutableData length](v426, "length"), md);

          objc_autoreleasePoolPop(v417);
          obja = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", md, 32);
          v620 = (void *)objc_claimAutoreleasedReturnValue(+[NFTLV TLVWithTag:value:](NFTLV, "TLVWithTag:value:", 40759, obja));
          *(_DWORD *)v666 = 836706527;
          v427 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", v666, 4);
          v617 = (void *)objc_claimAutoreleasedReturnValue(+[NFTLV TLVWithTag:value:](NFTLV, "TLVWithTag:value:", 92, v427));

          osloga = objc_opt_new(NSMutableData);
          v428 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v620, "asData"));
          -[NSMutableData appendData:](osloga, "appendData:", v428);

          v429 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v617, "asData"));
          -[NSMutableData appendData:](osloga, "appendData:", v429);

          v623 = (char *)objc_claimAutoreleasedReturnValue(objc_msgSend(v645, "getData:tag:data:error:", 128, 257, osloga, 0));
          if (objc_msgSend(v623, "status") == 36864)
          {
            v643 = objc_opt_new(NSMutableDictionary);
            v430 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v623, "response"));
            v431 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v430, "NF_asHexString"));
            -[NSMutableDictionary setObject:forKey:](v643, "setObject:forKey:", v431, CFSTR("SignedResponse"));

            v432 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v623, "response"));
            v433 = (void *)objc_claimAutoreleasedReturnValue(+[NFTLV TLVsWithData:](NFTLV, "TLVsWithData:", v432));

            v658 = 0u;
            v656 = 0u;
            v657 = 0u;
            v655 = 0u;
            v434 = v433;
            v435 = -[NSObject countByEnumeratingWithState:objects:count:](v434, "countByEnumeratingWithState:objects:count:", &v655, buf, 16);
            if (!v435)
              goto LABEL_376;
            v436 = *(_QWORD *)v656;
            while (1)
            {
              for (i = 0; i != v435; i = (char *)i + 1)
              {
                if (*(_QWORD *)v656 != v436)
                  objc_enumerationMutation(v434);
                v438 = *(void **)(*((_QWORD *)&v655 + 1) + 8 * (_QWORD)i);
                v439 = objc_msgSend(v438, "tag");
                if (v439 > 57119)
                {
                  if (v439 == 57137)
                  {
                    v457 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v438, "value"));
                    v443 = objc_claimAutoreleasedReturnValue(objc_msgSend(v457, "NF_asHexString"));

                    v458 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject substringWithRange:](v443, "substringWithRange:", 0, 4));
                    -[NSMutableDictionary setObject:forKey:](v643, "setObject:forKey:", v458, CFSTR("jsblSequenceCounter"));

                  }
                  else if (v439 == 57120)
                  {
                    v441 = objc_alloc((Class)NSString);
                    v442 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v438, "value"));
                    v443 = objc_msgSend(v441, "initWithData:encoding:", v442, 4);

                    -[NSMutableDictionary setObject:forKey:](v643, "setObject:forKey:", v443, CFSTR("kPlatformId"));
                  }
                  else
                  {
LABEL_362:
                    v444 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                    v445 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v444);
                    if (v445)
                    {
                      v446 = object_getClass(v645);
                      if (class_isMetaClass(v446))
                        v447 = 43;
                      else
                        v447 = 45;
                      v448 = object_getClassName(v645);
                      v449 = sel_getName("_generateCASDSignatureComet:");
                      v445(3, "%c[%{public}s %{public}s]:%i Unexpected tag found, %d", v447, v448, v449, 673, objc_msgSend(v438, "tag"));
                    }
                    v450 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                    v451 = NFSharedLogGetLogger(v450);
                    v443 = objc_claimAutoreleasedReturnValue(v451);
                    if (os_log_type_enabled(v443, OS_LOG_TYPE_ERROR))
                    {
                      v452 = object_getClass(v645);
                      if (class_isMetaClass(v452))
                        v453 = 43;
                      else
                        v453 = 45;
                      v454 = object_getClassName(v645);
                      v455 = sel_getName("_generateCASDSignatureComet:");
                      v456 = objc_msgSend(v438, "tag");
                      *(_DWORD *)v674 = 67110146;
                      *(_DWORD *)&v674[4] = v453;
                      *(_WORD *)&v674[8] = 2082;
                      *(_QWORD *)&v674[10] = v454;
                      *(_WORD *)&v674[18] = 2082;
                      *(_QWORD *)&v674[20] = v455;
                      *(_WORD *)&v674[28] = 1024;
                      *(_DWORD *)&v674[30] = 673;
                      *(_WORD *)&v674[34] = 1024;
                      *(_DWORD *)&v674[36] = v456;
                      _os_log_impl((void *)&_mh_execute_header, v443, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unexpected tag found, %d", v674, 0x28u);
                    }
                  }

                  continue;
                }
                if (v439 != 133 && v439 != 24375)
                  goto LABEL_362;
              }
              v435 = -[NSObject countByEnumeratingWithState:objects:count:](v434, "countByEnumeratingWithState:objects:count:", &v655, buf, 16);
              if (!v435)
              {
LABEL_376:

                goto LABEL_398;
              }
            }
          }
          v471 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v472 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v471);
          if (v472)
          {
            v473 = object_getClass(v645);
            if (class_isMetaClass(v473))
              v474 = 43;
            else
              v474 = 45;
            v475 = object_getClassName(v645);
            v476 = sel_getName("_generateCASDSignatureComet:");
            v472(3, "%c[%{public}s %{public}s]:%i Unable to obtain Authenticated GET DATA 0x%x", v474, v475, v476, 641, objc_msgSend(v623, "status"));
          }
          v477 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v478 = NFSharedLogGetLogger(v477);
          v434 = objc_claimAutoreleasedReturnValue(v478);
          if (os_log_type_enabled(v434, OS_LOG_TYPE_ERROR))
          {
            v479 = object_getClass(v645);
            if (class_isMetaClass(v479))
              v480 = 43;
            else
              v480 = 45;
            v481 = object_getClassName(v645);
            v482 = sel_getName("_generateCASDSignatureComet:");
            v483 = objc_msgSend(v623, "status");
            *(_DWORD *)buf = 67110146;
            *(_DWORD *)&buf[4] = v480;
            *(_WORD *)v679 = 2082;
            *(_QWORD *)&v679[2] = v481;
            *(_WORD *)&v679[10] = 2082;
            *(_QWORD *)&v679[12] = v482;
            *(_WORD *)&v679[20] = 1024;
            *(_DWORD *)&v679[22] = 641;
            *(_WORD *)&v679[26] = 1024;
            *(_DWORD *)&v679[28] = v483;
            _os_log_impl((void *)&_mh_execute_header, v434, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unable to obtain Authenticated GET DATA 0x%x", buf, 0x28u);
          }
          v643 = 0;
LABEL_398:

          v484 = v643;
          if (v643)
          {
            v651 = CFSTR("CASDSignedInfo");
            v652 = v643;
            v485 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v652, &v651, 1));
            -[NSMutableDictionary addEntriesFromDictionary:](v626, "addEntriesFromDictionary:", v485);

            v484 = v643;
          }

        }
        else
        {
          v459 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v460 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v459);
          if (v460)
          {
            v461 = object_getClass(v645);
            if (class_isMetaClass(v461))
              v462 = 43;
            else
              v462 = 45;
            v463 = object_getClassName(v645);
            v464 = sel_getName("remoteAdminState:appletFiltering:stateInfo:");
            v460(3, "%c[%{public}s %{public}s]:%i Failed to select ISD", v462, v463, v464, 213);
          }
          v465 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v466 = NFSharedLogGetLogger(v465);
          loga = objc_claimAutoreleasedReturnValue(v466);
          if (os_log_type_enabled(loga, OS_LOG_TYPE_ERROR))
          {
            v467 = object_getClass(v645);
            if (class_isMetaClass(v467))
              v468 = 43;
            else
              v468 = 45;
            v469 = object_getClassName(v645);
            v470 = sel_getName("remoteAdminState:appletFiltering:stateInfo:");
            *(_DWORD *)buf = 67109890;
            *(_DWORD *)&buf[4] = v468;
            *(_WORD *)v679 = 2082;
            *(_QWORD *)&v679[2] = v469;
            *(_WORD *)&v679[10] = 2082;
            *(_QWORD *)&v679[12] = v470;
            *(_WORD *)&v679[20] = 1024;
            *(_DWORD *)&v679[22] = 213;
            _os_log_impl((void *)&_mh_execute_header, loga, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select ISD", buf, 0x22u);
          }
        }

        v486 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v645, "handle"));
        v487 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v486, "info"));
        v488 = (char *)objc_msgSend(v487, "migrationState");

        if ((unint64_t)(v488 - 1) > 5)
        {
          v490 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v491 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v490);
          if (v491)
          {
            v492 = object_getClass(v645);
            if (class_isMetaClass(v492))
              v493 = 43;
            else
              v493 = 45;
            v494 = object_getClassName(v645);
            v495 = sel_getName("remoteAdminState:appletFiltering:stateInfo:");
            v491(3, "%c[%{public}s %{public}s]:%i Unexpected AM status", v493, v494, v495, 244);
          }
          v496 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v497 = NFSharedLogGetLogger(v496);
          v498 = objc_claimAutoreleasedReturnValue(v497);
          if (os_log_type_enabled(v498, OS_LOG_TYPE_ERROR))
          {
            v499 = object_getClass(v645);
            if (class_isMetaClass(v499))
              v500 = 43;
            else
              v500 = 45;
            v501 = object_getClassName(v645);
            v502 = sel_getName("remoteAdminState:appletFiltering:stateInfo:");
            *(_DWORD *)buf = 67109890;
            *(_DWORD *)&buf[4] = v500;
            *(_WORD *)v679 = 2082;
            *(_QWORD *)&v679[2] = v501;
            *(_WORD *)&v679[10] = 2082;
            *(_QWORD *)&v679[12] = v502;
            *(_WORD *)&v679[20] = 1024;
            *(_DWORD *)&v679[22] = 244;
            _os_log_impl((void *)&_mh_execute_header, v498, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unexpected AM status", buf, 0x22u);
          }

        }
        else
        {
          v489 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", dword_10026A6F0[(_QWORD)(v488 - 1)]));
          -[NSMutableDictionary setObject:forKey:](v618, "setObject:forKey:", v489, CFSTR("amStatus"));

        }
        goto LABEL_414;
      }
      v229 = &off_100306998;
      v230 = v645;
    }
    else
    {
      v609 = objc_opt_new(NSMutableData);
      v260 = (void *)objc_claimAutoreleasedReturnValue(+[NFTLV TLVWithTag:value:](NFTLV, "TLVWithTag:value:", 79, 0));
      v261 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v260, "asData"));
      -[NSMutableData appendData:](v609, "appendData:", v261);

      v262 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A568, 12);
      v263 = (void *)objc_claimAutoreleasedReturnValue(+[NFTLV TLVWithTag:value:](NFTLV, "TLVWithTag:value:", 92, v262));
      v264 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v263, "asData"));
      -[NSMutableData appendData:](v609, "appendData:", v264);

      v265 = sub_1000B3E38(v645, v609, 0);
      v608 = (void *)objc_claimAutoreleasedReturnValue(v265);
      if (v608)
      {
        oslog = objc_opt_new(NSMutableArray);
        v266 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A574, 12);
        v677[0] = v266;
        v267 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A580, 9);
        v677[1] = v267;
        v268 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A589, 8);
        v677[2] = v268;
        v269 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A591, 14);
        v677[3] = v269;
        v270 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A59F, 9);
        v677[4] = v270;
        v619 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v677, 5));

        v271 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A5A8, 14);
        v676[0] = v271;
        v272 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A5B6, 12);
        v676[1] = v272;
        v273 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A5C2, 12);
        v676[2] = v273;
        v625 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v676, 3));

        v675 = 0u;
        memset(v674, 0, sizeof(v674));
        obj = v608;
        v636 = (SEL)objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", v674, buf, 16);
        if (v636)
        {
          log = **(os_log_t **)&v674[16];
          do
          {
            v274 = 0;
            do
            {
              if (**(os_log_t **)&v674[16] != log)
              {
                v275 = v274;
                objc_enumerationMutation(obj);
                v274 = v275;
              }
              v639 = v274;
              v276 = *(void **)(*(_QWORD *)&v674[8] + 8 * (_QWORD)v274);
              if (!a3
                || (v277 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)&v674[8]
                                                                                        + 8 * (_QWORD)v274), "identifierAsData")),
                    v278 = objc_msgSend(v619, "containsObject:", v277),
                    v277,
                    (v278 & 1) == 0))
              {
                v279 = objc_opt_new(NSMutableDictionary);
                -[NSMutableArray addObject:](oslog, "addObject:", v279);
                v280 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v276, "identifier"));
                -[NSMutableDictionary setObject:forKey:](v279, "setObject:forKey:", v280, CFSTR("appletAid"));

                v281 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(v276, "rawGPState")));
                -[NSMutableDictionary setObject:forKey:](v279, "setObject:forKey:", v281, CFSTR("lifeCycleState"));

                v282 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v276, "identifierAsData"));
                v283 = objc_msgSend(v625, "containsObject:", v282);

                if ((v283 & 1) == 0
                  && (objc_msgSend(v276, "isContainer") & 1) == 0
                  && (objc_msgSend(v276, "isProxy") & 1) == 0)
                {
                  v284 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v276, "discretionaryData"));
                  v285 = (void *)objc_claimAutoreleasedReturnValue(+[NFTLV TLVWithTag:fromData:](NFTLV, "TLVWithTag:fromData:", 204, v284));
                  v286 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v285, "value"));

                  if (v286)
                  {
                    v287 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v286, "NF_asHexString"));
                    -[NSMutableDictionary setObject:forKey:](v279, "setObject:forKey:", v287, CFSTR("ssdAid"));

                    sub_10017BAD0(v645, v286, v279);
                  }
                  else
                  {
                    v288 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                    v289 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v288);
                    if (v289)
                    {
                      v290 = object_getClass(v645);
                      if (class_isMetaClass(v290))
                        v291 = 43;
                      else
                        v291 = 45;
                      v292 = object_getClassName(v645);
                      v293 = sel_getName("_getCRSInfoWithFiltering:");
                      v294 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v276, "identifier"));
                      v295 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v276, "discretionaryData"));
                      v289(4, "%c[%{public}s %{public}s]:%i Failed to get SSD ID %{public}@: %{public}@", v291, v292, v293, 516, v294, v295);

                    }
                    v296 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                    v297 = NFSharedLogGetLogger(v296);
                    v298 = objc_claimAutoreleasedReturnValue(v297);
                    if (os_log_type_enabled(v298, OS_LOG_TYPE_ERROR))
                    {
                      v299 = object_getClass(v645);
                      if (class_isMetaClass(v299))
                        v300 = 43;
                      else
                        v300 = 45;
                      v301 = object_getClassName(v645);
                      v302 = sel_getName("_getCRSInfoWithFiltering:");
                      v303 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v276, "identifier"));
                      v304 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v276, "discretionaryData"));
                      *(_DWORD *)v666 = 67110402;
                      *(_DWORD *)&v666[4] = v300;
                      *(_WORD *)v667 = 2082;
                      *(_QWORD *)&v667[2] = v301;
                      *(_WORD *)&v667[10] = 2082;
                      *(_QWORD *)&v667[12] = v302;
                      v668 = 1024;
                      v669 = 516;
                      v670 = 2114;
                      v671 = v303;
                      v672 = 2114;
                      v673 = v304;
                      _os_log_impl((void *)&_mh_execute_header, v298, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get SSD ID %{public}@: %{public}@", v666, 0x36u);

                    }
                  }

                }
                v305 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v276, "discretionaryData"));
                v642 = (void *)objc_claimAutoreleasedReturnValue(+[NFTLV TLVWithTag:fromData:](NFTLV, "TLVWithTag:fromData:", 254, v305));

                if (v642)
                {
                  v665 = 0u;
                  memset(md, 0, sizeof(md));
                  v306 = objc_claimAutoreleasedReturnValue(objc_msgSend(v642, "children"));
                  v307 = -[NSObject countByEnumeratingWithState:objects:count:](v306, "countByEnumeratingWithState:objects:count:", md, &v655, 16);
                  if (v307)
                  {
                    v308 = **(_QWORD **)&md[16];
                    while (2)
                    {
                      for (j = 0; j != v307; j = (char *)j + 1)
                      {
                        if (**(_QWORD **)&md[16] != v308)
                          objc_enumerationMutation(v306);
                        v310 = *(void **)(*(_QWORD *)&md[8] + 8 * (_QWORD)j);
                        if (objc_msgSend(v310, "tag") == 57152)
                        {
                          v311 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v310, "value"));
                          v312 = objc_msgSend(v311, "length") == (id)2;

                          if (v312)
                          {
                            v327 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v310, "value"));
                            v328 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v327, "NF_asHexString"));
                            -[NSMutableDictionary setObject:forKey:](v279, "setObject:forKey:", v328, CFSTR("extendedFunction"));

                            goto LABEL_252;
                          }
                        }
                      }
                      v307 = -[NSObject countByEnumeratingWithState:objects:count:](v306, "countByEnumeratingWithState:objects:count:", md, &v655, 16);
                      if (v307)
                        continue;
                      break;
                    }
                  }
                }
                else
                {
                  v313 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  v314 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v313);
                  if (v314)
                  {
                    v315 = object_getClass(v645);
                    if (class_isMetaClass(v315))
                      v316 = 43;
                    else
                      v316 = 45;
                    v317 = object_getClassName(v645);
                    v318 = sel_getName("_getCRSInfoWithFiltering:");
                    v319 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v276, "identifier"));
                    v314(3, "%c[%{public}s %{public}s]:%i Failed to get extended function information for %{public}@", v316, v317, v318, 531, v319);

                  }
                  v320 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  v321 = NFSharedLogGetLogger(v320);
                  v306 = objc_claimAutoreleasedReturnValue(v321);
                  if (os_log_type_enabled(v306, OS_LOG_TYPE_ERROR))
                  {
                    v322 = object_getClass(v645);
                    if (class_isMetaClass(v322))
                      v323 = 43;
                    else
                      v323 = 45;
                    v324 = object_getClassName(v645);
                    v325 = sel_getName("_getCRSInfoWithFiltering:");
                    v326 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v276, "identifier"));
                    *(_DWORD *)v666 = 67110146;
                    *(_DWORD *)&v666[4] = v323;
                    *(_WORD *)v667 = 2082;
                    *(_QWORD *)&v667[2] = v324;
                    *(_WORD *)&v667[10] = 2082;
                    *(_QWORD *)&v667[12] = v325;
                    v668 = 1024;
                    v669 = 531;
                    v670 = 2114;
                    v671 = v326;
                    _os_log_impl((void *)&_mh_execute_header, v306, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get extended function information for %{public}@", v666, 0x2Cu);

                  }
                }
LABEL_252:

                v329 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v276, "discretionaryData"));
                if (v329)
                {
                  v330 = objc_claimAutoreleasedReturnValue(objc_msgSend(v276, "discretionaryData"));
                  v331 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject NF_asHexString](v330, "NF_asHexString"));
                  -[NSMutableDictionary setObject:forKey:](v279, "setObject:forKey:", v331, CFSTR("discretionaryData"));

                }
                else
                {
                  v332 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  v333 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v332);
                  if (v333)
                  {
                    v334 = object_getClass(v645);
                    if (class_isMetaClass(v334))
                      v335 = 43;
                    else
                      v335 = 45;
                    v336 = object_getClassName(v645);
                    v337 = sel_getName("_getCRSInfoWithFiltering:");
                    v338 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v276, "identifier"));
                    v333(3, "%c[%{public}s %{public}s]:%i nil discretionary data for %{public}@", v335, v336, v337, 538, v338);

                  }
                  v339 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  v340 = NFSharedLogGetLogger(v339);
                  v330 = objc_claimAutoreleasedReturnValue(v340);
                  if (os_log_type_enabled(v330, OS_LOG_TYPE_ERROR))
                  {
                    v341 = object_getClass(v645);
                    if (class_isMetaClass(v341))
                      v342 = 43;
                    else
                      v342 = 45;
                    v343 = object_getClassName(v645);
                    v344 = sel_getName("_getCRSInfoWithFiltering:");
                    v345 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v276, "identifier"));
                    *(_DWORD *)v666 = 67110146;
                    *(_DWORD *)&v666[4] = v342;
                    *(_WORD *)v667 = 2082;
                    *(_QWORD *)&v667[2] = v343;
                    *(_WORD *)&v667[10] = 2082;
                    *(_QWORD *)&v667[12] = v344;
                    v668 = 1024;
                    v669 = 538;
                    v670 = 2114;
                    v671 = v345;
                    _os_log_impl((void *)&_mh_execute_header, v330, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i nil discretionary data for %{public}@", v666, 0x2Cu);

                  }
                }

                v346 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v276, "groupHeadID"));
                if (v346)
                  -[NSMutableDictionary setObject:forKey:](v279, "setObject:forKey:", v346, CFSTR("primaryContainer"));
                v347 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v276, "groupMemberIDs"));
                if (v347)
                  -[NSMutableDictionary setObject:forKey:](v279, "setObject:forKey:", v347, CFSTR("auxilaryContainers"));
                v348 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", objc_msgSend(v276, "isContainer")));
                -[NSMutableDictionary setObject:forKey:](v279, "setObject:forKey:", v348, CFSTR("containerInstance"));

                v349 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", objc_msgSend(v276, "isProxy")));
                -[NSMutableDictionary setObject:forKey:](v279, "setObject:forKey:", v349, CFSTR("proxyInstance"));

                v350 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v276, "packageIdentifier"));
                if (v350)
                {
                  v351 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v276, "packageIdentifier"));
                  -[NSMutableDictionary setObject:forKey:](v279, "setObject:forKey:", v351, CFSTR("packageAid"));

                }
                v352 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v276, "moduleIdentifier"));

                if (v352)
                {
                  v353 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v276, "moduleIdentifier"));
                  -[NSMutableDictionary setObject:forKey:](v279, "setObject:forKey:", v353, CFSTR("moduleAid"));

                }
                v354 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v276, "multiSEGroupMemberIDs"));
                v355 = objc_msgSend(v354, "count");

                if (v355)
                {
                  v356 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v276, "multiSEGroupMemberIDs"));
                  -[NSMutableDictionary setObject:forKey:](v279, "setObject:forKey:", v356, CFSTR("multiSEApplicationGroup"));

                }
              }
              v274 = v639 + 1;
            }
            while (v639 + 1 != v636);
            v636 = (SEL)objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", v674, buf, 16);
          }
          while (v636);
        }

        v653 = CFSTR("containers");
        v654 = oslog;
        v357 = (_UNKNOWN **)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v654, &v653, 1));

      }
      else
      {
        v361 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v362 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v361);
        if (v362)
        {
          v363 = object_getClass(v645);
          if (class_isMetaClass(v363))
            v364 = 43;
          else
            v364 = 45;
          v365 = object_getClassName(v645);
          v366 = sel_getName("_getCRSInfoWithFiltering:");
          v362(3, "%c[%{public}s %{public}s]:%i Failed to get applications", v364, v365, v366, 472);
        }
        v367 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v368 = NFSharedLogGetLogger(v367);
        oslog = (NSMutableArray *)objc_claimAutoreleasedReturnValue(v368);
        if (os_log_type_enabled(&oslog->super.super, OS_LOG_TYPE_ERROR))
        {
          v369 = object_getClass(v645);
          if (class_isMetaClass(v369))
            v370 = 43;
          else
            v370 = 45;
          v371 = object_getClassName(v645);
          v372 = sel_getName("_getCRSInfoWithFiltering:");
          *(_DWORD *)v666 = 67109890;
          *(_DWORD *)&v666[4] = v370;
          *(_WORD *)v667 = 2082;
          *(_QWORD *)&v667[2] = v371;
          *(_WORD *)&v667[10] = 2082;
          *(_QWORD *)&v667[12] = v372;
          v668 = 1024;
          v669 = 472;
          _os_log_impl((void *)&_mh_execute_header, &oslog->super.super, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get applications", v666, 0x22u);
        }
        v357 = &off_1003069C0;
      }

      v230 = v645;
      v229 = v357;
      if (!v357)
      {
        v635 = 0;
        goto LABEL_299;
      }
    }
    v635 = v229;
    -[NSMutableDictionary addEntriesFromDictionary:](v618, "addEntriesFromDictionary:");
    goto LABEL_299;
  }
  v157 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A554, 8);
  v158 = objc_msgSend(v645, "select:error:", v157, 0);

  if ((v158 & 1) == 0)
  {
    v198 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v199 = NFLogGetLogger(v198);
    if (v199)
    {
      v200 = (void (*)(uint64_t, const char *, ...))v199;
      v201 = object_getClass(v645);
      v202 = class_isMetaClass(v201);
      v203 = object_getClassName(v645);
      v604 = sel_getName("remoteAdminState:appletFiltering:stateInfo:");
      v204 = 45;
      if (v202)
        v204 = 43;
      v200(3, "%c[%{public}s %{public}s]:%i Failed to select ISD", v204, v203, v604, 250);
    }
    v205 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v206 = NFSharedLogGetLogger(v205);
    v207 = objc_claimAutoreleasedReturnValue(v206);
    if (os_log_type_enabled(v207, OS_LOG_TYPE_ERROR))
    {
      v208 = object_getClass(v645);
      if (class_isMetaClass(v208))
        v209 = 43;
      else
        v209 = 45;
      v210 = object_getClassName(v645);
      v211 = sel_getName("remoteAdminState:appletFiltering:stateInfo:");
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)&buf[4] = v209;
      *(_WORD *)v679 = 2082;
      *(_QWORD *)&v679[2] = v210;
      *(_WORD *)&v679[10] = 2082;
      *(_QWORD *)&v679[12] = v211;
      *(_WORD *)&v679[20] = 1024;
      *(_DWORD *)&v679[22] = 250;
      _os_log_impl((void *)&_mh_execute_header, v207, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select ISD", buf, 0x22u);
    }

    v635 = 0;
LABEL_414:
    v161 = v618;
    goto LABEL_415;
  }
  v159 = sub_10017B250(v645, 1);
  v160 = (void *)objc_claimAutoreleasedReturnValue(v159);
  v161 = v618;
  if (v160)
    -[NSMutableDictionary addEntriesFromDictionary:](v618, "addEntriesFromDictionary:", v160);

  v635 = 0;
LABEL_415:
  if (-[NSMutableDictionary count](v161, "count"))
  {
    if (v615)
    {
      v647 = 0;
      v503 = sub_1000A0078(v645, &v647);
      v504 = (void *)objc_claimAutoreleasedReturnValue(v503);
      v644 = v647;
      v505 = objc_opt_new(NSMutableDictionary);
      v506 = v505;
      if (v504)
        -[NSMutableDictionary setObject:forKey:](v505, "setObject:forKey:", v504, CFSTR("attackLogDictionary"));
      v507 = objc_opt_new(NSMutableDictionary);
      v508 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v645, "handle"));
      v509 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v508, "driver"));
      v510 = (_QWORD *)sub_1000297CC(v509, 1);

      if (!v510)
      {
        v533 = v507;
LABEL_489:

        if (v507)
          -[NSMutableDictionary addEntriesFromDictionary:](v506, "addEntriesFromDictionary:", v507);
        -[NSMutableDictionary setObject:forKey:](v618, "setObject:forKey:", v506, CFSTR("restrictedMode"));

        v532 = v618;
LABEL_492:
        v37 = 0;
        *a4 = objc_retainAutorelease(v532);
        goto LABEL_493;
      }
      v640 = (char *)objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", *v510, v510[1]);
      NFDataRelease(v510);
      v511 = (void *)objc_claimAutoreleasedReturnValue(+[NFTLV TLVWithData:](NFTLV, "TLVWithData:", v640));
      if (objc_msgSend(v511, "tag") != 48)
      {
        v534 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v535 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v534);
        if (v535)
        {
          v536 = object_getClass(v645);
          if (class_isMetaClass(v536))
            v537 = 43;
          else
            v537 = 45;
          v538 = object_getClassName(v645);
          v539 = sel_getName("_getUnlockRequestInfoFrom:");
          v535(3, "%c[%{public}s %{public}s]:%i Unexpected tag: 0x%x", v537, v538, v539, 703, objc_msgSend(v511, "tag"));
        }
        v540 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v541 = NFSharedLogGetLogger(v540);
        v542 = objc_claimAutoreleasedReturnValue(v541);
        if (os_log_type_enabled(v542, OS_LOG_TYPE_ERROR))
        {
          v543 = object_getClass(v645);
          if (class_isMetaClass(v543))
            v544 = 43;
          else
            v544 = 45;
          v545 = object_getClassName(v645);
          v546 = sel_getName("_getUnlockRequestInfoFrom:");
          v547 = objc_msgSend(v511, "tag");
          *(_DWORD *)buf = 67110146;
          *(_DWORD *)&buf[4] = v544;
          *(_WORD *)v679 = 2082;
          *(_QWORD *)&v679[2] = v545;
          *(_WORD *)&v679[10] = 2082;
          *(_QWORD *)&v679[12] = v546;
          *(_WORD *)&v679[20] = 1024;
          *(_DWORD *)&v679[22] = 703;
          *(_WORD *)&v679[26] = 1024;
          *(_DWORD *)&v679[28] = v547;
          _os_log_impl((void *)&_mh_execute_header, v542, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unexpected tag: 0x%x", buf, 0x28u);
        }

        v548 = v507;
        goto LABEL_488;
      }
      logb = (os_log_t)objc_claimAutoreleasedReturnValue(objc_msgSend(v511, "children"));
      if (-[NSObject count](logb, "count") == (id)5)
      {
        v512 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject objectAtIndexedSubscript:](logb, "objectAtIndexedSubscript:", 0));
        v513 = objc_msgSend(v512, "tag") == 2;

        if (v513)
        {
          v514 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject objectAtIndexedSubscript:](logb, "objectAtIndexedSubscript:", 0));
          v515 = objc_msgSend(v514, "valueAsUnsignedLong");

          if ((_DWORD)v515 == 2)
          {
            v516 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject objectAtIndexedSubscript:](logb, "objectAtIndexedSubscript:", 4));
            v517 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v516, "value"));
            v518 = objc_msgSend(v517, "length") == (id)24;

            if (v518)
            {
              v519 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject objectAtIndexedSubscript:](logb, "objectAtIndexedSubscript:", 1));
              v520 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v519, "value"));
              v521 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v520, "NF_asHexString"));

              v522 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject objectAtIndexedSubscript:](logb, "objectAtIndexedSubscript:", 2));
              v523 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v522, "value"));
              v646 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v523, "NF_asHexString"));

              v524 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject objectAtIndexedSubscript:](logb, "objectAtIndexedSubscript:", 3));
              v525 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v524, "value"));
              v526 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v525, "NF_asHexString"));

              v527 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject objectAtIndexedSubscript:](logb, "objectAtIndexedSubscript:", 4));
              v528 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v527, "value"));
              v529 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v528, "NF_asHexString"));

              v530 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", 2));
              -[NSMutableDictionary setObject:forKey:](v507, "setObject:forKey:", v530, CFSTR("version"));

              -[NSMutableDictionary setObject:forKey:](v507, "setObject:forKey:", v521, CFSTR("nonce"));
              -[NSMutableDictionary setObject:forKey:](v507, "setObject:forKey:", v646, CFSTR("unlockKeyID"));
              -[NSMutableDictionary setObject:forKey:](v507, "setObject:forKey:", v526, CFSTR("kPlatformId"));
              -[NSMutableDictionary setObject:forKey:](v507, "setObject:forKey:", v529, CFSTR("SEID"));
              v531 = v507;

LABEL_487:
LABEL_488:

              goto LABEL_489;
            }
            v587 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v588 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v587);
            if (v588)
            {
              v589 = object_getClass(v645);
              if (class_isMetaClass(v589))
                v590 = 43;
              else
                v590 = 45;
              v591 = object_getClassName(v645);
              v592 = sel_getName("_getUnlockRequestInfoFrom:");
              v588(3, "%c[%{public}s %{public}s]:%i Unexpected data structure", v590, v591, v592, 745);
            }
            v593 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v594 = NFSharedLogGetLogger(v593);
            v557 = objc_claimAutoreleasedReturnValue(v594);
            if (os_log_type_enabled(v557, OS_LOG_TYPE_ERROR))
            {
              v595 = object_getClass(v645);
              if (class_isMetaClass(v595))
                v596 = 43;
              else
                v596 = 45;
              v597 = object_getClassName(v645);
              v598 = sel_getName("_getUnlockRequestInfoFrom:");
              *(_DWORD *)buf = 67109890;
              *(_DWORD *)&buf[4] = v596;
              *(_WORD *)v679 = 2082;
              *(_QWORD *)&v679[2] = v597;
              *(_WORD *)&v679[10] = 2082;
              *(_QWORD *)&v679[12] = v598;
              *(_WORD *)&v679[20] = 1024;
              *(_DWORD *)&v679[22] = 745;
              _os_log_impl((void *)&_mh_execute_header, v557, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unexpected data structure", buf, 0x22u);
            }
          }
          else
          {
            v575 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v576 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v575);
            if (v576)
            {
              v577 = object_getClass(v645);
              if (class_isMetaClass(v577))
                v578 = 43;
              else
                v578 = 45;
              v579 = object_getClassName(v645);
              v580 = sel_getName("_getUnlockRequestInfoFrom:");
              v576(3, "%c[%{public}s %{public}s]:%i Unsupported version: 0x%x", v578, v579, v580, 721, v515);
            }
            v581 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v582 = NFSharedLogGetLogger(v581);
            v557 = objc_claimAutoreleasedReturnValue(v582);
            if (os_log_type_enabled(v557, OS_LOG_TYPE_ERROR))
            {
              v583 = object_getClass(v645);
              if (class_isMetaClass(v583))
                v584 = 43;
              else
                v584 = 45;
              v585 = object_getClassName(v645);
              v586 = sel_getName("_getUnlockRequestInfoFrom:");
              *(_DWORD *)buf = 67110146;
              *(_DWORD *)&buf[4] = v584;
              *(_WORD *)v679 = 2082;
              *(_QWORD *)&v679[2] = v585;
              *(_WORD *)&v679[10] = 2082;
              *(_QWORD *)&v679[12] = v586;
              *(_WORD *)&v679[20] = 1024;
              *(_DWORD *)&v679[22] = 721;
              *(_WORD *)&v679[26] = 1024;
              *(_DWORD *)&v679[28] = (_DWORD)v515;
              _os_log_impl((void *)&_mh_execute_header, v557, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unsupported version: 0x%x", buf, 0x28u);
            }
          }
        }
        else
        {
          v562 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v563 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v562);
          if (v563)
          {
            v564 = object_getClass(v645);
            if (class_isMetaClass(v564))
              v565 = 43;
            else
              v565 = 45;
            v566 = object_getClassName(v645);
            v567 = sel_getName("_getUnlockRequestInfoFrom:");
            v563(3, "%c[%{public}s %{public}s]:%i Unexpected tag: 0x%x", v565, v566, v567, 715, objc_msgSend(v511, "tag"));
          }
          v568 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v569 = NFSharedLogGetLogger(v568);
          v557 = objc_claimAutoreleasedReturnValue(v569);
          if (os_log_type_enabled(v557, OS_LOG_TYPE_ERROR))
          {
            v570 = object_getClass(v645);
            if (class_isMetaClass(v570))
              v571 = 43;
            else
              v571 = 45;
            v572 = object_getClassName(v645);
            v573 = sel_getName("_getUnlockRequestInfoFrom:");
            v574 = objc_msgSend(v511, "tag");
            *(_DWORD *)buf = 67110146;
            *(_DWORD *)&buf[4] = v571;
            *(_WORD *)v679 = 2082;
            *(_QWORD *)&v679[2] = v572;
            *(_WORD *)&v679[10] = 2082;
            *(_QWORD *)&v679[12] = v573;
            *(_WORD *)&v679[20] = 1024;
            *(_DWORD *)&v679[22] = 715;
            *(_WORD *)&v679[26] = 1024;
            *(_DWORD *)&v679[28] = v574;
            _os_log_impl((void *)&_mh_execute_header, v557, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unexpected tag: 0x%x", buf, 0x28u);
          }
        }
      }
      else
      {
        v549 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v550 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v549);
        if (v550)
        {
          v551 = object_getClass(v645);
          if (class_isMetaClass(v551))
            v552 = 43;
          else
            v552 = 45;
          v553 = object_getClassName(v645);
          v554 = sel_getName("_getUnlockRequestInfoFrom:");
          v550(3, "%c[%{public}s %{public}s]:%i Invalid number of subtags", v552, v553, v554, 710);
        }
        v555 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v556 = NFSharedLogGetLogger(v555);
        v557 = objc_claimAutoreleasedReturnValue(v556);
        if (os_log_type_enabled(v557, OS_LOG_TYPE_ERROR))
        {
          v558 = object_getClass(v645);
          if (class_isMetaClass(v558))
            v559 = 43;
          else
            v559 = 45;
          v560 = object_getClassName(v645);
          v561 = sel_getName("_getUnlockRequestInfoFrom:");
          *(_DWORD *)buf = 67109890;
          *(_DWORD *)&buf[4] = v559;
          *(_WORD *)v679 = 2082;
          *(_QWORD *)&v679[2] = v560;
          *(_WORD *)&v679[10] = 2082;
          *(_QWORD *)&v679[12] = v561;
          *(_WORD *)&v679[20] = 1024;
          *(_DWORD *)&v679[22] = 710;
          _os_log_impl((void *)&_mh_execute_header, v557, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid number of subtags", buf, 0x22u);
        }
      }

      v599 = v507;
      goto LABEL_487;
    }
    v37 = 6;
    v532 = v618;
    v259 = v635;
    if (!v613 || !v612)
      goto LABEL_494;
    if (v635)
      goto LABEL_492;
  }
  else
  {
    v37 = 6;
  }
LABEL_493:
  v259 = v635;
LABEL_494:

  p_super = &v613->super.super;
LABEL_495:

LABEL_496:
  return v37;
}

void sub_100178FEC(_Unwind_Exception *a1)
{
  _Block_object_dispose(&STACK[0x260], 8);
  _Unwind_Resume(a1);
}

BOOL sub_100179018(_BOOL8 a1)
{
  _BOOL8 v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  unint64_t v6;
  id v7;
  void *v8;
  void *v9;
  void *v10;
  unsigned int v11;

  v1 = a1;
  if (a1)
  {
    v2 = (void *)objc_claimAutoreleasedReturnValue(+[_NFHardwareManager sharedHardwareManager](_NFHardwareManager, "sharedHardwareManager"));
    v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "controllerInfo"));

    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v1, "handle"));
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "info"));
    v6 = (unint64_t)objc_msgSend(v5, "seType");

    if (v6 <= 7)
    {
      if (((1 << v6) & 0xB1) != 0)
      {
        v1 = 0;
LABEL_10:

        return v1;
      }
      if (v6 == 2)
      {
        v7 = objc_msgSend(v3, "siliconName");
        v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v1, "handle"));
        v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "info"));
        v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "sequenceCounter"));
        v11 = objc_msgSend(v10, "unsignedIntValue");

        if ((unint64_t)v7 >= 7)
          v1 = v11 > 0x630;
        else
          v1 = v11 > 0x505;
        goto LABEL_10;
      }
    }
    v1 = 1;
    goto LABEL_10;
  }
  return v1;
}

id sub_100179134(void *a1, char a2)
{
  void *v2;
  void *v3;
  uint64_t v4;
  int v5;
  void *v6;
  void *v7;
  void *v8;
  BOOL v9;
  id v10;
  id v11;
  id v12;
  id v13;
  id v14;
  id v15;
  id v16;
  id v17;
  id v18;
  id v19;
  id v20;
  id v21;
  id v22;
  unint64_t v23;
  id v24;
  void *specific;
  void (*Logger)(uint64_t, const char *, ...);
  objc_class *Class;
  uint64_t v28;
  const char *ClassName;
  const char *Name;
  void *v31;
  uint64_t v32;
  NSObject *v33;
  objc_class *v34;
  int v35;
  const char *v36;
  const char *v37;
  void *v38;
  char *v39;
  char *i;
  void *v41;
  void *v42;
  void *v43;
  id v44;
  unsigned int v45;
  void *v46;
  void *v47;
  unsigned int v48;
  void *v49;
  unsigned int v50;
  void *v51;
  unsigned int v52;
  int v53;
  void *v54;
  void *v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  void *v60;
  int v61;
  id v63;
  id v64;
  id v65;
  id v66;
  void *v67;
  id v69;
  void *v70;
  _QWORD v71[5];
  _QWORD v72[5];
  id v73;
  uint64_t *v74;
  uint64_t *v75;
  uint64_t *v76;
  const char *v77;
  char v78;
  uint64_t v79;
  uint64_t *v80;
  uint64_t v81;
  uint64_t (*v82)(uint64_t, uint64_t);
  void (*v83)(uint64_t);
  id v84;
  uint64_t v85;
  uint64_t *v86;
  uint64_t v87;
  uint64_t (*v88)(uint64_t, uint64_t);
  void (*v89)(uint64_t);
  NSMutableArray *v90;
  uint64_t v91;
  uint64_t *v92;
  uint64_t v93;
  uint64_t (*v94)(uint64_t, uint64_t);
  void (*v95)(uint64_t);
  NSMutableArray *v96;
  _QWORD v97[3];
  _QWORD v98[3];
  uint8_t buf[4];
  int v100;
  __int16 v101;
  const char *v102;
  __int16 v103;
  const char *v104;
  __int16 v105;
  int v106;
  __int16 v107;
  void *v108;
  _QWORD v109[3];
  _QWORD v110[14];

  if (!a1)
  {
    v38 = 0;
    return v38;
  }
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "handle"));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "info"));
  v4 = (uint64_t)objc_msgSend(v3, "deviceType");

  v5 = 0;
  if (v4 <= 99)
  {
    switch(v4)
    {
      case ',':
        v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "handle"));
        v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "info"));
        v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "sequenceCounter"));
        v9 = objc_msgSend(v8, "unsignedIntValue") > 0x326;
        break;
      case '6':
        v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "handle"));
        v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "info"));
        v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "sequenceCounter"));
        v9 = objc_msgSend(v8, "unsignedIntValue") > 0x123;
        break;
      case '7':
        goto LABEL_20;
      default:
        goto LABEL_46;
    }
LABEL_16:
    v5 = v9;

    goto LABEL_20;
  }
  if (v4 > 199)
  {
    if (v4 != 210 && v4 != 200)
      goto LABEL_46;
    goto LABEL_13;
  }
  if (v4 == 100)
  {
LABEL_13:
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "handle"));
    v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "info"));
    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "sequenceCounter"));
    v9 = objc_msgSend(v8, "unsignedIntValue") > 0xF1D;
    goto LABEL_16;
  }
  if (v4 != 115)
LABEL_46:
    v5 = 1;
LABEL_20:
  v61 = v5;
  v63 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A574, 12);
  v110[0] = v63;
  v64 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A580, 9);
  v110[1] = v64;
  v66 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A589, 8);
  v110[2] = v66;
  v69 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A591, 14);
  v110[3] = v69;
  v10 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A5F1, 10);
  v110[4] = v10;
  v11 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A5FB, 14);
  v110[5] = v11;
  v12 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A609, 12);
  v110[6] = v12;
  v13 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A615, 16);
  v110[7] = v13;
  v14 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A625, 13);
  v110[8] = v14;
  v15 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A632, 12);
  v110[9] = v15;
  v16 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A63E, 12);
  v110[10] = v16;
  v17 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A64A, 10);
  v110[11] = v17;
  v18 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A654, 10);
  v110[12] = v18;
  v19 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A59F, 9);
  v110[13] = v19;
  v60 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v110, 14));

  v20 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A5A8, 14);
  v109[0] = v20;
  v21 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A5B6, 12);
  v109[1] = v21;
  v22 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A5C2, 12);
  v109[2] = v22;
  v70 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v109, 3));

  v91 = 0;
  v92 = &v91;
  v93 = 0x3032000000;
  v94 = sub_10017C2C4;
  v95 = sub_10017C2D4;
  v96 = objc_opt_new(NSMutableArray);
  v85 = 0;
  v86 = &v85;
  v87 = 0x3032000000;
  v88 = sub_10017C2C4;
  v89 = sub_10017C2D4;
  v90 = objc_opt_new(NSMutableArray);
  v79 = 0;
  v80 = &v79;
  v81 = 0x3032000000;
  v82 = sub_10017C2C4;
  v83 = sub_10017C2D4;
  v84 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", 2);
  if (v61)
    v23 = 11;
  else
    v23 = 10;
  v72[0] = _NSConcreteStackBlock;
  v72[1] = 3221225472;
  v72[2] = sub_10017C2DC;
  v72[3] = &unk_1002E9D88;
  v72[4] = a1;
  v77 = "getStatusProprietaryApplicationsWithFiltering:";
  v78 = a2;
  v65 = v60;
  v73 = v65;
  v74 = &v79;
  v75 = &v85;
  v76 = &v91;
  v24 = sub_10017CDE0(a1, 64, (uint64_t)&unk_10026A5E6, v23, v72);
  v67 = (void *)objc_claimAutoreleasedReturnValue(v24);
  if (v67)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(specific);
    if (Logger)
    {
      Class = object_getClass(a1);
      if (class_isMetaClass(Class))
        v28 = 43;
      else
        v28 = 45;
      ClassName = object_getClassName(a1);
      Name = sel_getName("getStatusProprietaryApplicationsWithFiltering:");
      Logger(3, "%c[%{public}s %{public}s]:%i Failed to call proprietary get status %{public}@", v28, ClassName, Name, 947, v67);
    }
    v31 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v32 = NFSharedLogGetLogger(v31);
    v33 = objc_claimAutoreleasedReturnValue(v32);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      v34 = object_getClass(a1);
      if (class_isMetaClass(v34))
        v35 = 43;
      else
        v35 = 45;
      v36 = object_getClassName(a1);
      v37 = sel_getName("getStatusProprietaryApplicationsWithFiltering:");
      *(_DWORD *)buf = 67110146;
      v100 = v35;
      v101 = 2082;
      v102 = v36;
      v103 = 2082;
      v104 = v37;
      v105 = 1024;
      v106 = 947;
      v107 = 2114;
      v108 = v67;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to call proprietary get status %{public}@", buf, 0x2Cu);
    }

    v38 = 0;
  }
  else
  {
    v39 = (char *)objc_msgSend((id)v92[5], "count");
    if (v39)
    {
      for (i = 0; i != v39; ++i)
      {
        v41 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v92[5], "objectAtIndexedSubscript:", i));
        v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v41, "objectForKeyedSubscript:", CFSTR("associatedSSD")));
        v43 = (void *)objc_claimAutoreleasedReturnValue(+[NSData NF_dataWithHexString:](NSData, "NF_dataWithHexString:", v42));
        v44 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A554, 8);
        v45 = objc_msgSend(v43, "isEqualToData:", v44);

        v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v41, "objectForKeyedSubscript:", CFSTR("appletAid")));
        v47 = (void *)objc_claimAutoreleasedReturnValue(+[NSData NF_dataWithHexString:](NSData, "NF_dataWithHexString:", v46));
        v48 = objc_msgSend(v70, "containsObject:", v47);

        v49 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v41, "objectForKeyedSubscript:", CFSTR("containerInstance")));
        v50 = objc_msgSend(v49, "BOOLValue");

        v51 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v41, "objectForKeyedSubscript:", CFSTR("proxyInstance")));
        v52 = objc_msgSend(v51, "BOOLValue");

        if (v42)
          v53 = v45;
        else
          v53 = 1;
        if (((v53 | v48 | v50 | v52) & 1) == 0)
        {
          v54 = (void *)objc_claimAutoreleasedReturnValue(+[NSData NF_dataWithHexString:](NSData, "NF_dataWithHexString:", v42));
          sub_10017BAD0(a1, v54, v41);

        }
      }
    }
    v55 = (void *)v86[5];
    v71[0] = _NSConcreteStackBlock;
    v71[1] = 3221225472;
    v71[2] = sub_10017D9B0;
    v71[3] = &unk_1002E9DB0;
    v71[4] = &v91;
    v56 = (void *)objc_claimAutoreleasedReturnValue(+[NSPredicate predicateWithBlock:](NSPredicate, "predicateWithBlock:", v71));
    objc_msgSend(v55, "filterUsingPredicate:", v56);

    v57 = v92[5];
    v97[0] = CFSTR("containers");
    v97[1] = CFSTR("orphanedSSDs");
    v58 = v86[5];
    v98[0] = v57;
    v98[1] = v58;
    v97[2] = CFSTR("VASDs");
    v98[2] = v80[5];
    v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v98, v97, 3));
  }

  _Block_object_dispose(&v79, 8);
  _Block_object_dispose(&v85, 8);

  _Block_object_dispose(&v91, 8);
  return v38;
}

void sub_100179AA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49)
{
  _Block_object_dispose(&a37, 8);
  _Block_object_dispose(&a43, 8);
  _Block_object_dispose(&a49, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100179B18(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  id v5;
  id v6;
  uint64_t v7;
  void *v8;
  void *v9;
  unsigned __int8 v10;
  uint64_t v11;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  _BYTE v17[128];

  v3 = a2;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "objectForKeyedSubscript:", CFSTR("packages"), 0));
  v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v13, v17, 16);
  if (v5)
  {
    v6 = v5;
    v7 = *(_QWORD *)v14;
    while (2)
    {
      v8 = 0;
      do
      {
        if (*(_QWORD *)v14 != v7)
          objc_enumerationMutation(v4);
        v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*((_QWORD *)&v13 + 1) + 8 * (_QWORD)v8), "objectForKeyedSubscript:", CFSTR("associatedSSD")));
        v10 = objc_msgSend(v9, "isEqualToString:", v3);

        if ((v10 & 1) != 0)
        {
          v11 = 0;
          goto LABEL_11;
        }
        v8 = (char *)v8 + 1;
      }
      while (v6 != v8);
      v6 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v13, v17, 16);
      if (v6)
        continue;
      break;
    }
  }
  v11 = 1;
LABEL_11:

  return v11;
}

NSMutableArray *sub_100179C64(void *a1, void *a2, void *a3)
{
  id v4;
  id v5;
  NSObject *v6;
  id v7;
  id v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  uint64_t v15;
  void (*v16)(uint64_t, const char *, ...);
  objc_class *v17;
  _BOOL4 v18;
  const char *v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  NSObject *v23;
  objc_class *v24;
  int v25;
  const char *v26;
  const char *v27;
  NSMutableArray *v28;
  NSMutableArray *v29;
  void *v30;
  void *v31;
  void *v32;
  id v33;
  id v34;
  unsigned __int8 v35;
  void *v36;
  unsigned __int8 v37;
  NSMutableDictionary *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  void *v43;
  NSObject *v44;
  void *v45;
  id v46;
  unsigned int v47;
  id v48;
  void *v49;
  void *v50;
  void *v51;
  void *v52;
  void *v53;
  void *v54;
  const __CFString *v55;
  void *specific;
  uint64_t Logger;
  void (*v58)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v61;
  void *v62;
  uint64_t v63;
  objc_class *v64;
  int v65;
  const char *v66;
  const char *v67;
  void *v68;
  void *v69;
  uint64_t v70;
  void (*v71)(uint64_t, const char *, ...);
  objc_class *v72;
  _BOOL4 v73;
  uint64_t v74;
  void *v75;
  uint64_t v76;
  NSObject *v77;
  objc_class *v78;
  int v79;
  const char *v80;
  const char *v81;
  void *v82;
  uint64_t v83;
  void (*v84)(uint64_t, const char *, ...);
  objc_class *v85;
  _BOOL4 v86;
  const char *v87;
  uint64_t v88;
  void *v89;
  uint64_t v90;
  objc_class *v91;
  int v92;
  const char *v93;
  const char *v94;
  const char *v95;
  void *v96;
  uint64_t v97;
  void (*v98)(uint64_t, const char *, ...);
  objc_class *v99;
  _BOOL4 v100;
  const char *v101;
  uint64_t v102;
  void *v103;
  uint64_t v104;
  objc_class *v105;
  int v106;
  const char *v107;
  const char *v108;
  void *v109;
  uint64_t v110;
  void (*v111)(uint64_t, const char *, ...);
  objc_class *v112;
  _BOOL4 v113;
  NSMutableDictionary *v114;
  const char *v115;
  const char *v116;
  uint64_t v117;
  void *v118;
  uint64_t v119;
  NSObject *v120;
  objc_class *v121;
  int v122;
  const char *v123;
  const char *v124;
  void *v125;
  unsigned int v126;
  NSObject *v127;
  void *v128;
  void *v129;
  void *v130;
  void *v131;
  uint64_t v132;
  void *v133;
  id v134;
  void *v135;
  void *v136;
  void *v137;
  id v138;
  void *v139;
  uint64_t v140;
  void (*v141)(uint64_t, const char *, ...);
  objc_class *v142;
  _BOOL4 v143;
  const char *v144;
  const char *v145;
  uint64_t v146;
  void *v147;
  uint64_t v148;
  NSObject *v149;
  objc_class *v150;
  int v151;
  const char *v152;
  const char *v153;
  void *v154;
  unsigned int v155;
  const char *v156;
  void *v157;
  uint64_t v158;
  void (*v159)(uint64_t, const char *, ...);
  objc_class *v160;
  _BOOL4 v161;
  const char *v162;
  const char *v163;
  uint64_t v164;
  void *v165;
  uint64_t v166;
  objc_class *v167;
  int v168;
  const char *v169;
  const char *v170;
  unsigned int v171;
  void *v172;
  uint64_t v173;
  void (*v174)(uint64_t, const char *, ...);
  objc_class *v175;
  _BOOL4 v176;
  const char *v177;
  const char *v178;
  uint64_t v179;
  void *v180;
  uint64_t v181;
  NSObject *v182;
  objc_class *v183;
  int v184;
  const char *v185;
  const char *v186;
  unsigned int v187;
  void *v188;
  uint64_t v189;
  void (*v190)(uint64_t, const char *, ...);
  objc_class *v191;
  _BOOL4 v192;
  const char *v193;
  uint64_t v194;
  void *v195;
  uint64_t v196;
  NSObject *v197;
  objc_class *v198;
  int v199;
  const char *v200;
  const char *v201;
  const char *v202;
  void *v203;
  uint64_t v204;
  void (*v205)(uint64_t, const char *, ...);
  objc_class *v206;
  _BOOL4 v207;
  const char *v208;
  uint64_t v209;
  void *v210;
  uint64_t v211;
  objc_class *v212;
  int v213;
  const char *v214;
  const char *v215;
  void *v216;
  uint64_t v217;
  void (*v218)(uint64_t, const char *, ...);
  objc_class *v219;
  _BOOL4 v220;
  const char *v221;
  uint64_t v222;
  void *v223;
  uint64_t v224;
  NSObject *v225;
  objc_class *v226;
  int v227;
  const char *v228;
  const char *v229;
  const char *ClassName;
  const char *v232;
  const char *v233;
  const char *v234;
  const char *v235;
  const char *v236;
  const char *Name;
  const char *v238;
  const char *v239;
  const char *v240;
  const char *v241;
  const char *v242;
  const char *v243;
  const char *v244;
  const char *v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  NSObject *v250;
  void *v251;
  void *v252;
  os_log_t log;
  NSObject *loga;
  NSObject *v255;
  void *v256;
  void *v257;
  void *v258;
  void *v259;
  NSMutableArray *v260;
  id v261;
  NSObject *v263;
  NSObject *v264;
  NSObject *v265;
  id v266;
  __int128 v267;
  __int128 v268;
  __int128 v269;
  __int128 v270;
  uint8_t buf[4];
  int v272;
  __int16 v273;
  const char *v274;
  __int16 v275;
  const char *v276;
  __int16 v277;
  int v278;
  __int16 v279;
  _BYTE v280[14];
  __int16 v281;
  NSObject *v282;
  _BYTE v283[128];

  v4 = a2;
  v5 = a3;
  v260 = objc_opt_new(NSMutableArray);
  v261 = v4;
  v267 = 0u;
  v268 = 0u;
  v269 = 0u;
  v270 = 0u;
  v6 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "objectForKeyedSubscript:", CFSTR("containers")));
  v7 = -[NSObject countByEnumeratingWithState:objects:count:](v6, "countByEnumeratingWithState:objects:count:", &v267, v283, 16);
  if (v7)
  {
    v8 = v7;
    v9 = *(_QWORD *)v268;
LABEL_3:
    v10 = 0;
    while (1)
    {
      if (*(_QWORD *)v268 != v9)
        objc_enumerationMutation(v6);
      v11 = *(void **)(*((_QWORD *)&v267 + 1) + 8 * v10);
      v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "objectForKeyedSubscript:", CFSTR("appletAid")));
      v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSData NF_dataWithHexString:](NSData, "NF_dataWithHexString:", v12));

      if (objc_msgSend(v13, "isEqualToData:", v5))
        break;

      if (v8 == (id)++v10)
      {
        v8 = -[NSObject countByEnumeratingWithState:objects:count:](v6, "countByEnumeratingWithState:objects:count:", &v267, v283, 16);
        if (v8)
          goto LABEL_3;
        goto LABEL_9;
      }
    }
    v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "objectForKeyedSubscript:", CFSTR("moduleAid")));
    v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSData NF_dataWithHexString:](NSData, "NF_dataWithHexString:", v31));
    v33 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A6D3, 16);
    v259 = v32;
    if (objc_msgSend(v32, "isEqualToData:", v33))
    {

    }
    else
    {
      v34 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A6E3, 12);
      v35 = objc_msgSend(v32, "isEqualToData:", v34);

      if ((v35 & 1) == 0)
      {
        specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        Logger = NFLogGetLogger(specific);
        if (Logger)
        {
          v58 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(a1);
          isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(a1);
          Name = sel_getName("getGetProtocolV4Container:forApplet:");
          v61 = 45;
          if (isMetaClass)
            v61 = 43;
          v58(3, "%c[%{public}s %{public}s]:%i moduleID  %{public}@ does not match MiFare or MOT MID. ", v61, ClassName, Name, 1253, v32);
        }
        v62 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v63 = NFSharedLogGetLogger(v62);
        v38 = (NSMutableDictionary *)objc_claimAutoreleasedReturnValue(v63);
        v30 = v261;
        if (os_log_type_enabled(&v38->super.super, OS_LOG_TYPE_ERROR))
        {
          v64 = object_getClass(a1);
          if (class_isMetaClass(v64))
            v65 = 43;
          else
            v65 = 45;
          v66 = object_getClassName(a1);
          v67 = sel_getName("getGetProtocolV4Container:forApplet:");
          *(_DWORD *)buf = 67110146;
          v272 = v65;
          v273 = 2082;
          v274 = v66;
          v275 = 2082;
          v276 = v67;
          v277 = 1024;
          v278 = 1253;
          v279 = 2114;
          v68 = v259;
          *(_QWORD *)v280 = v259;
          _os_log_impl((void *)&_mh_execute_header, &v38->super.super, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i moduleID  %{public}@ does not match MiFare or MOT MID. ", buf, 0x2Cu);
          v28 = 0;
          v29 = v260;
        }
        else
        {
          v28 = 0;
          v68 = v32;
          v29 = v260;
        }
        goto LABEL_156;
      }
    }
    v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "objectForKeyedSubscript:", CFSTR("lifeCycleState")));
    v37 = objc_msgSend(v36, "intValue");

    if (v37 != 15 && v37 != 130)
    {
      v258 = v31;
      v69 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v70 = NFLogGetLogger(v69);
      if (v70)
      {
        v71 = (void (*)(uint64_t, const char *, ...))v70;
        v72 = object_getClass(a1);
        v73 = class_isMetaClass(v72);
        v232 = object_getClassName(a1);
        v238 = sel_getName("getGetProtocolV4Container:forApplet:");
        v74 = 45;
        if (v73)
          v74 = 43;
        v71(3, "%c[%{public}s %{public}s]:%i lifeCycle  %d is not valid ", v74, v232, v238, 1260, v37);
      }
      v75 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v76 = NFSharedLogGetLogger(v75);
      v77 = objc_claimAutoreleasedReturnValue(v76);
      v30 = v261;
      if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR))
      {
        v78 = object_getClass(a1);
        if (class_isMetaClass(v78))
          v79 = 43;
        else
          v79 = 45;
        v80 = object_getClassName(a1);
        v81 = sel_getName("getGetProtocolV4Container:forApplet:");
        *(_DWORD *)buf = 67110146;
        v272 = v79;
        v273 = 2082;
        v274 = v80;
        v275 = 2082;
        v276 = v81;
        v277 = 1024;
        v278 = 1260;
        v279 = 1024;
        *(_DWORD *)v280 = v37;
        _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i lifeCycle  %d is not valid ", buf, 0x28u);
      }
      v28 = 0;
      v68 = v259;
      v29 = v260;
      v38 = (NSMutableDictionary *)v77;
      v31 = v258;
      goto LABEL_156;
    }
    v38 = objc_opt_new(NSMutableDictionary);
    v39 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "objectForKeyedSubscript:", CFSTR("ssdCounter")));

    if (v39)
    {
      v40 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "objectForKeyedSubscript:", CFSTR("ssdCounter")));
      -[NSMutableDictionary setObject:forKeyedSubscript:](v38, "setObject:forKeyedSubscript:", v40, CFSTR("ssdCounter"));

      v41 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "objectForKeyedSubscript:", CFSTR("appletAid")));
      if (v41)
      {
        v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "objectForKeyedSubscript:", CFSTR("appletAid")));
        -[NSMutableDictionary setObject:forKeyedSubscript:](v38, "setObject:forKeyedSubscript:", v42, CFSTR("appletAid"));

        v266 = 0;
        v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "selectByName:error:", v13, &v266));
        v44 = v266;
        v257 = v31;
        if (objc_msgSend(v43, "status") != 36864)
        {
          v256 = v43;
          v109 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v110 = NFLogGetLogger(v109);
          if (v110)
          {
            v111 = (void (*)(uint64_t, const char *, ...))v110;
            v112 = object_getClass(a1);
            v113 = class_isMetaClass(v112);
            v114 = v38;
            v115 = object_getClassName(a1);
            v116 = sel_getName("getGetProtocolV4Container:forApplet:");
            v248 = objc_msgSend(v43, "status");
            v233 = v115;
            v117 = 45;
            if (v113)
              v117 = 43;
            v38 = v114;
            v111(3, "%c[%{public}s %{public}s]:%i Failed to select AID %{public}@: status 0x%04x, error = %{public}@", v117, v233, v116, 1289, v13, v248, v44);
          }
          v118 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v119 = NFSharedLogGetLogger(v118);
          v120 = objc_claimAutoreleasedReturnValue(v119);
          if (!os_log_type_enabled(v120, OS_LOG_TYPE_ERROR))
          {
            v28 = 0;
            v127 = v120;
            v29 = v260;
            v30 = v261;
            v68 = v259;
LABEL_153:
            v125 = v256;
            goto LABEL_154;
          }
          v121 = object_getClass(a1);
          if (class_isMetaClass(v121))
            v122 = 43;
          else
            v122 = 45;
          v123 = object_getClassName(a1);
          v124 = sel_getName("getGetProtocolV4Container:forApplet:");
          v125 = v256;
          v126 = objc_msgSend(v256, "status");
          *(_DWORD *)buf = 67110658;
          v272 = v122;
          v273 = 2082;
          v274 = v123;
          v275 = 2082;
          v276 = v124;
          v277 = 1024;
          v278 = 1289;
          v279 = 2114;
          *(_QWORD *)v280 = v13;
          *(_WORD *)&v280[8] = 1024;
          *(_DWORD *)&v280[10] = v126;
          v281 = 2114;
          v282 = v44;
          _os_log_impl((void *)&_mh_execute_header, v120, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select AID %{public}@: status 0x%04x, error = %{public}@", buf, 0x3Cu);
          v28 = 0;
          v127 = v120;
          v30 = v261;
          goto LABEL_81;
        }
        v45 = v43;
        log = &v38->super.super;
        v46 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A6D3, 16);
        v47 = objc_msgSend(v259, "isEqualToData:", v46);

        if (v47)
        {
          v48 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A6EF, 1);
          v265 = v44;
          v49 = a1;
          v50 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "getData:tag:data:error:", 128, 0, v48, &v265));
          v255 = v265;

          if (v50 && objc_msgSend(v50, "status") == 36864)
          {
            v51 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v50, "data"));
            v52 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v51, "NF_asHexString"));
            v53 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v52, "substringWithRange:", 0, 4));

            if (v53)
            {
              v54 = v50;
              v55 = CFSTR("authenticationCounter");
              v38 = (NSMutableDictionary *)log;
              goto LABEL_86;
            }
            v252 = v50;
            v188 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v189 = NFLogGetLogger(v188);
            v38 = (NSMutableDictionary *)log;
            if (v189)
            {
              v190 = (void (*)(uint64_t, const char *, ...))v189;
              v191 = object_getClass(a1);
              v192 = class_isMetaClass(v191);
              v193 = object_getClassName(a1);
              v243 = sel_getName("getGetProtocolV4Container:forApplet:");
              v194 = 45;
              if (v192)
                v194 = 43;
              v190(3, "%c[%{public}s %{public}s]:%i Nil auth counter", v194, v193, v243, 1310);
            }
            v195 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v196 = NFSharedLogGetLogger(v195);
            v197 = objc_claimAutoreleasedReturnValue(v196);
            v30 = v261;
            if (!os_log_type_enabled(v197, OS_LOG_TYPE_ERROR))
              goto LABEL_140;
            v198 = object_getClass(a1);
            if (class_isMetaClass(v198))
              v199 = 43;
            else
              v199 = 45;
            v200 = object_getClassName(a1);
            v201 = sel_getName("getGetProtocolV4Container:forApplet:");
            *(_DWORD *)buf = 67109890;
            v272 = v199;
            v273 = 2082;
            v274 = v200;
            v275 = 2082;
            v276 = v201;
            v277 = 1024;
            v278 = 1310;
            v202 = "%c[%{public}s %{public}s]:%i Nil auth counter";
LABEL_139:
            _os_log_impl((void *)&_mh_execute_header, v197, OS_LOG_TYPE_ERROR, v202, buf, 0x22u);
LABEL_140:
            v127 = v197;
            v28 = 0;
            v125 = v252;
            v44 = v255;
LABEL_81:
            v68 = v259;
            v29 = v260;
LABEL_154:

            v31 = v257;
            goto LABEL_155;
          }
          v251 = v50;
          v139 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v140 = NFLogGetLogger(v139);
          if (v140)
          {
            v141 = (void (*)(uint64_t, const char *, ...))v140;
            v142 = object_getClass(a1);
            v143 = class_isMetaClass(v142);
            v144 = object_getClassName(a1);
            v145 = sel_getName("getGetProtocolV4Container:forApplet:");
            v246 = objc_msgSend(v50, "status");
            v241 = v145;
            v49 = a1;
            v146 = 45;
            if (v143)
              v146 = 43;
            v141(3, "%c[%{public}s %{public}s]:%i Failed to execute get auth command: 0x%04x, error = %{public}@", v146, v144, v241, 1301, v246, v255);
          }
          v147 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v148 = NFSharedLogGetLogger(v147);
          v149 = objc_claimAutoreleasedReturnValue(v148);
          v30 = v261;
          if (os_log_type_enabled(v149, OS_LOG_TYPE_ERROR))
          {
            v150 = object_getClass(v49);
            if (class_isMetaClass(v150))
              v151 = 43;
            else
              v151 = 45;
            v152 = object_getClassName(v49);
            v153 = sel_getName("getGetProtocolV4Container:forApplet:");
            v154 = v251;
            v155 = objc_msgSend(v251, "status");
            *(_DWORD *)buf = 67110402;
            v272 = v151;
            v273 = 2082;
            v274 = v152;
            v275 = 2082;
            v276 = v153;
            v277 = 1024;
            v278 = 1301;
            v279 = 1024;
            *(_DWORD *)v280 = v155;
            *(_WORD *)&v280[4] = 2114;
            v44 = v255;
            *(_QWORD *)&v280[6] = v255;
            v156 = "%c[%{public}s %{public}s]:%i Failed to execute get auth command: 0x%04x, error = %{public}@";
LABEL_108:
            _os_log_impl((void *)&_mh_execute_header, v149, OS_LOG_TYPE_ERROR, v156, buf, 0x32u);
            v28 = 0;
            v127 = v149;
            v125 = v154;
LABEL_110:
            v68 = v259;
            v29 = v260;
            v38 = (NSMutableDictionary *)log;
            goto LABEL_154;
          }
        }
        else
        {
          v264 = v44;
          v128 = a1;
          v129 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "sendCommandWithClass:instruction:p1:p2:data:error:", 128, 241, 0, 0, 0, &v264));
          v255 = v264;

          if (v129 && objc_msgSend(v129, "status") == 36864)
          {
            v130 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v129, "data"));
            v53 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v130, "NF_asHexString"));

            v38 = (NSMutableDictionary *)log;
            if (v53)
            {
              v54 = v129;
              v55 = CFSTR("appletSignedState");
LABEL_86:
              -[NSMutableDictionary setObject:forKeyedSubscript:](v38, "setObject:forKeyedSubscript:", v53, v55);

              v131 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "objectForKeyedSubscript:", CFSTR("ssdAid")));
              v132 = objc_claimAutoreleasedReturnValue(+[NSData NF_dataWithHexString:](NSData, "NF_dataWithHexString:", v131));

              v263 = v255;
              v250 = v132;
              v133 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "selectByName:error:", v132, &v263));
              v44 = v263;

              v256 = v133;
              if (objc_msgSend(v133, "status") == 36864)
              {
                v134 = sub_10017B250(a1, 0);
                v135 = (void *)objc_claimAutoreleasedReturnValue(v134);
                v136 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v135, "objectForKeyedSubscript:", CFSTR("ssdKeyVersionNumber")));
                v30 = v261;
                if (objc_msgSend(v136, "count"))
                {
                  v137 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v136, "objectAtIndexedSubscript:", 0));
                  v138 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%02lX"), objc_msgSend(v137, "integerValue"));
                  -[NSObject setObject:forKeyedSubscript:](log, "setObject:forKeyedSubscript:", v138, CFSTR("kvn"));

                  v38 = (NSMutableDictionary *)log;
                  v29 = v260;
                  -[NSMutableArray addObject:](v260, "addObject:", log);
                  v28 = v260;
LABEL_152:
                  v68 = v259;
                  v127 = v250;
                  goto LABEL_153;
                }
                v216 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                v217 = NFLogGetLogger(v216);
                if (v217)
                {
                  v218 = (void (*)(uint64_t, const char *, ...))v217;
                  v219 = object_getClass(a1);
                  v220 = class_isMetaClass(v219);
                  v221 = object_getClassName(a1);
                  v245 = sel_getName("getGetProtocolV4Container:forApplet:");
                  v222 = 45;
                  if (v220)
                    v222 = 43;
                  v235 = v221;
                  v38 = (NSMutableDictionary *)log;
                  v218(3, "%c[%{public}s %{public}s]:%i No KVN found", v222, v235, v245, 1367);
                }
                v223 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                v224 = NFSharedLogGetLogger(v223);
                v225 = objc_claimAutoreleasedReturnValue(v224);
                if (os_log_type_enabled(v225, OS_LOG_TYPE_ERROR))
                {
                  v226 = object_getClass(a1);
                  loga = v225;
                  if (class_isMetaClass(v226))
                    v227 = 43;
                  else
                    v227 = 45;
                  v228 = object_getClassName(a1);
                  v229 = sel_getName("getGetProtocolV4Container:forApplet:");
                  *(_DWORD *)buf = 67109890;
                  v272 = v227;
                  v225 = loga;
                  v273 = 2082;
                  v274 = v228;
                  v275 = 2082;
                  v276 = v229;
                  v277 = 1024;
                  v278 = 1367;
                  _os_log_impl((void *)&_mh_execute_header, loga, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i No KVN found", buf, 0x22u);
                }

                v28 = 0;
              }
              else
              {
                v172 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                v173 = NFLogGetLogger(v172);
                if (v173)
                {
                  v174 = (void (*)(uint64_t, const char *, ...))v173;
                  v175 = object_getClass(a1);
                  v176 = class_isMetaClass(v175);
                  v177 = object_getClassName(a1);
                  v178 = sel_getName("getGetProtocolV4Container:forApplet:");
                  v249 = objc_msgSend(v256, "status");
                  v234 = v177;
                  v179 = 45;
                  if (v176)
                    v179 = 43;
                  v38 = (NSMutableDictionary *)log;
                  v174(3, "%c[%{public}s %{public}s]:%i Failed to select SSD %{public}@: 0x%04x, error = %{public}@", v179, v234, v178, 1350, v250, v249, v44);
                }
                v180 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                v181 = NFSharedLogGetLogger(v180);
                v182 = objc_claimAutoreleasedReturnValue(v181);
                if (os_log_type_enabled(v182, OS_LOG_TYPE_ERROR))
                {
                  v183 = object_getClass(a1);
                  if (class_isMetaClass(v183))
                    v184 = 43;
                  else
                    v184 = 45;
                  v185 = object_getClassName(a1);
                  v186 = sel_getName("getGetProtocolV4Container:forApplet:");
                  v187 = objc_msgSend(v256, "status");
                  *(_DWORD *)buf = 67110658;
                  v272 = v184;
                  v273 = 2082;
                  v274 = v185;
                  v275 = 2082;
                  v276 = v186;
                  v38 = (NSMutableDictionary *)log;
                  v277 = 1024;
                  v278 = 1350;
                  v279 = 2114;
                  *(_QWORD *)v280 = v250;
                  *(_WORD *)&v280[8] = 1024;
                  *(_DWORD *)&v280[10] = v187;
                  v281 = 2114;
                  v282 = v44;
                  _os_log_impl((void *)&_mh_execute_header, v182, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select SSD %{public}@: 0x%04x, error = %{public}@", buf, 0x3Cu);
                }

                v28 = 0;
                v30 = v261;
              }
              v29 = v260;
              goto LABEL_152;
            }
            v252 = v129;
            v203 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v204 = NFLogGetLogger(v203);
            if (v204)
            {
              v205 = (void (*)(uint64_t, const char *, ...))v204;
              v206 = object_getClass(a1);
              v207 = class_isMetaClass(v206);
              v208 = object_getClassName(a1);
              v244 = sel_getName("getGetProtocolV4Container:forApplet:");
              v209 = 45;
              if (v207)
                v209 = 43;
              v205(3, "%c[%{public}s %{public}s]:%i appletSignedState does not exist", v209, v208, v244, 1337);
            }
            v210 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v211 = NFSharedLogGetLogger(v210);
            v197 = objc_claimAutoreleasedReturnValue(v211);
            v30 = v261;
            if (!os_log_type_enabled(v197, OS_LOG_TYPE_ERROR))
              goto LABEL_140;
            v212 = object_getClass(a1);
            if (class_isMetaClass(v212))
              v213 = 43;
            else
              v213 = 45;
            v214 = object_getClassName(a1);
            v215 = sel_getName("getGetProtocolV4Container:forApplet:");
            *(_DWORD *)buf = 67109890;
            v272 = v213;
            v273 = 2082;
            v274 = v214;
            v275 = 2082;
            v276 = v215;
            v277 = 1024;
            v278 = 1337;
            v202 = "%c[%{public}s %{public}s]:%i appletSignedState does not exist";
            goto LABEL_139;
          }
          v251 = v129;
          v157 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v158 = NFLogGetLogger(v157);
          if (v158)
          {
            v159 = (void (*)(uint64_t, const char *, ...))v158;
            v160 = object_getClass(a1);
            v161 = class_isMetaClass(v160);
            v162 = object_getClassName(a1);
            v163 = sel_getName("getGetProtocolV4Container:forApplet:");
            v247 = objc_msgSend(v129, "status");
            v242 = v163;
            v128 = a1;
            v164 = 45;
            if (v161)
              v164 = 43;
            v159(3, "%c[%{public}s %{public}s]:%i Failed to execute get applet signed state command: 0x%04x, error = %{public}@", v164, v162, v242, 1328, v247, v255);
          }
          v165 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v166 = NFSharedLogGetLogger(v165);
          v149 = objc_claimAutoreleasedReturnValue(v166);
          v30 = v261;
          if (os_log_type_enabled(v149, OS_LOG_TYPE_ERROR))
          {
            v167 = object_getClass(v128);
            if (class_isMetaClass(v167))
              v168 = 43;
            else
              v168 = 45;
            v169 = object_getClassName(v128);
            v170 = sel_getName("getGetProtocolV4Container:forApplet:");
            v154 = v251;
            v171 = objc_msgSend(v251, "status");
            *(_DWORD *)buf = 67110402;
            v272 = v168;
            v273 = 2082;
            v274 = v169;
            v275 = 2082;
            v276 = v170;
            v277 = 1024;
            v278 = 1328;
            v279 = 1024;
            *(_DWORD *)v280 = v171;
            *(_WORD *)&v280[4] = 2114;
            v44 = v255;
            *(_QWORD *)&v280[6] = v255;
            v156 = "%c[%{public}s %{public}s]:%i Failed to execute get applet signed state command: 0x%04x, error = %{public}@";
            goto LABEL_108;
          }
        }
        v28 = 0;
        v127 = v149;
        v125 = v251;
        v44 = v255;
        goto LABEL_110;
      }
      v96 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v97 = NFLogGetLogger(v96);
      if (v97)
      {
        v98 = (void (*)(uint64_t, const char *, ...))v97;
        v99 = object_getClass(a1);
        v100 = class_isMetaClass(v99);
        v101 = object_getClassName(a1);
        v240 = sel_getName("getGetProtocolV4Container:forApplet:");
        v102 = 45;
        if (v100)
          v102 = 43;
        v98(3, "%c[%{public}s %{public}s]:%i ContainersAppletAID does not exist in container", v102, v101, v240, 1279);
      }
      v103 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v104 = NFSharedLogGetLogger(v103);
      v44 = objc_claimAutoreleasedReturnValue(v104);
      v30 = v261;
      if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
      {
LABEL_71:
        v28 = 0;
        v68 = v259;
        v29 = v260;
LABEL_155:

LABEL_156:
        v23 = v6;
        goto LABEL_157;
      }
      v105 = object_getClass(a1);
      if (class_isMetaClass(v105))
        v106 = 43;
      else
        v106 = 45;
      v107 = object_getClassName(a1);
      v108 = sel_getName("getGetProtocolV4Container:forApplet:");
      *(_DWORD *)buf = 67109890;
      v272 = v106;
      v273 = 2082;
      v274 = v107;
      v275 = 2082;
      v276 = v108;
      v277 = 1024;
      v278 = 1279;
      v95 = "%c[%{public}s %{public}s]:%i ContainersAppletAID does not exist in container";
    }
    else
    {
      v82 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v83 = NFLogGetLogger(v82);
      v30 = v261;
      if (v83)
      {
        v84 = (void (*)(uint64_t, const char *, ...))v83;
        v85 = object_getClass(a1);
        v86 = class_isMetaClass(v85);
        v87 = object_getClassName(a1);
        v239 = sel_getName("getGetProtocolV4Container:forApplet:");
        v88 = 45;
        if (v86)
          v88 = 43;
        v84(3, "%c[%{public}s %{public}s]:%i SSDCounter does not exist in container", v88, v87, v239, 1271);
      }
      v89 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v90 = NFSharedLogGetLogger(v89);
      v44 = objc_claimAutoreleasedReturnValue(v90);
      if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
        goto LABEL_71;
      v91 = object_getClass(a1);
      if (class_isMetaClass(v91))
        v92 = 43;
      else
        v92 = 45;
      v93 = object_getClassName(a1);
      v94 = sel_getName("getGetProtocolV4Container:forApplet:");
      *(_DWORD *)buf = 67109890;
      v272 = v92;
      v273 = 2082;
      v274 = v93;
      v275 = 2082;
      v276 = v94;
      v277 = 1024;
      v278 = 1271;
      v95 = "%c[%{public}s %{public}s]:%i SSDCounter does not exist in container";
    }
    _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, v95, buf, 0x22u);
    goto LABEL_71;
  }
LABEL_9:

  v14 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v15 = NFLogGetLogger(v14);
  if (v15)
  {
    v16 = (void (*)(uint64_t, const char *, ...))v15;
    v17 = object_getClass(a1);
    v18 = class_isMetaClass(v17);
    v19 = object_getClassName(a1);
    v236 = sel_getName("getGetProtocolV4Container:forApplet:");
    v20 = 45;
    if (v18)
      v20 = 43;
    v16(3, "%c[%{public}s %{public}s]:%i No matching whitelisted applet found", v20, v19, v236, 1376);
  }
  v21 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v22 = NFSharedLogGetLogger(v21);
  v23 = objc_claimAutoreleasedReturnValue(v22);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
  {
    v24 = object_getClass(a1);
    if (class_isMetaClass(v24))
      v25 = 43;
    else
      v25 = 45;
    v26 = object_getClassName(a1);
    v27 = sel_getName("getGetProtocolV4Container:forApplet:");
    *(_DWORD *)buf = 67109890;
    v272 = v25;
    v273 = 2082;
    v274 = v26;
    v275 = 2082;
    v276 = v27;
    v277 = 1024;
    v278 = 1376;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i No matching whitelisted applet found", buf, 0x22u);
  }
  v28 = 0;
  v29 = v260;
  v30 = v261;
LABEL_157:

  return v28;
}

id sub_10017B250(void *a1, int a2)
{
  void *v4;
  void *v5;
  void *v6;
  uint64_t v7;
  void (*v8)(uint64_t, const char *, ...);
  objc_class *v9;
  _BOOL4 v10;
  const char *v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  NSObject *v15;
  objc_class *v16;
  int v17;
  const char *v18;
  NSObject *v19;
  void *v20;
  void *specific;
  uint64_t Logger;
  void (*v23)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  objc_class *v30;
  int v31;
  uint64_t v33;
  void *v34;
  void *v35;
  uint64_t v36;
  void *v37;
  void *v38;
  void *v39;
  void *v40;
  NSObject *v41;
  uint64_t v42;
  void *v43;
  uint64_t v44;
  void (*v45)(uint64_t, const char *, ...);
  objc_class *v46;
  _BOOL4 v47;
  const char *v48;
  uint64_t v49;
  void *v50;
  uint64_t v51;
  objc_class *v52;
  int v53;
  const char *v54;
  const char *v55;
  NSObject *v56;
  const char *v57;
  void *v58;
  uint64_t v59;
  void (*v60)(uint64_t, const char *, ...);
  objc_class *v61;
  _BOOL4 v62;
  const char *v63;
  uint64_t v64;
  void *v65;
  uint64_t v66;
  objc_class *v67;
  int v68;
  const char *v69;
  const char *v70;
  id v71;
  NSObject **v72;
  const __CFString **v73;
  void *v74;
  uint64_t v75;
  void (*v76)(uint64_t, const char *, ...);
  objc_class *v77;
  _BOOL4 v78;
  const char *v79;
  uint64_t v80;
  void *v81;
  uint64_t v82;
  objc_class *v83;
  int v84;
  const char *v85;
  const char *v86;
  const char *v87;
  const char *Name;
  const char *v89;
  const char *v90;
  const char *v91;
  int v92;
  void *v93;
  NSObject *v94;
  unsigned __int8 v95;
  __int16 v96;
  const __CFString *v97;
  NSObject *v98;
  const __CFString *v99;
  NSObject *v100;
  uint8_t buf[4];
  int v102;
  __int16 v103;
  const char *v104;
  __int16 v105;
  const char *v106;
  __int16 v107;
  int v108;

  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "getData:", 224));
  if (!v4)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v23 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("_getKeyInfo:");
      v27 = 45;
      if (isMetaClass)
        v27 = 43;
      v23(3, "%c[%{public}s %{public}s]:%i Failed to get key information template", v27, ClassName, Name, 339);
    }
    v28 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v29 = NFSharedLogGetLogger(v28);
    v19 = objc_claimAutoreleasedReturnValue(v29);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      v30 = object_getClass(a1);
      if (class_isMetaClass(v30))
        v31 = 43;
      else
        v31 = 45;
      *(_DWORD *)buf = 67109890;
      v102 = v31;
      v103 = 2082;
      v104 = object_getClassName(a1);
      v105 = 2082;
      v106 = sel_getName("_getKeyInfo:");
      v107 = 1024;
      v108 = 339;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get key information template", buf, 0x22u);
    }
    v20 = 0;
    goto LABEL_26;
  }
  v5 = (void *)objc_claimAutoreleasedReturnValue(+[NFTLV TLVsWithData:](NFTLV, "TLVsWithData:", v4));
  if ((unint64_t)objc_msgSend(v5, "count") < 3
    || 0xAAAAAAAAAAAAAAABLL * (unint64_t)objc_msgSend(v5, "count") > 0x5555555555555555)
  {
    v6 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v7 = NFLogGetLogger(v6);
    if (v7)
    {
      v8 = (void (*)(uint64_t, const char *, ...))v7;
      v9 = object_getClass(a1);
      v10 = class_isMetaClass(v9);
      v11 = object_getClassName(a1);
      v87 = sel_getName("_getKeyInfo:");
      v12 = 45;
      if (v10)
        v12 = 43;
      v8(3, "%c[%{public}s %{public}s]:%i Invalid key set", v12, v11, v87, 348);
    }
    v13 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v14 = NFSharedLogGetLogger(v13);
    v15 = objc_claimAutoreleasedReturnValue(v14);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      goto LABEL_14;
    v16 = object_getClass(a1);
    if (class_isMetaClass(v16))
      v17 = 43;
    else
      v17 = 45;
    *(_DWORD *)buf = 67109890;
    v102 = v17;
    v103 = 2082;
    v104 = object_getClassName(a1);
    v105 = 2082;
    v106 = sel_getName("_getKeyInfo:");
    v107 = 1024;
    v108 = 348;
    v18 = "%c[%{public}s %{public}s]:%i Invalid key set";
LABEL_13:
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, v18, buf, 0x22u);
LABEL_14:

    v19 = 0;
    v20 = 0;
    goto LABEL_15;
  }
  if (!objc_msgSend(v5, "count"))
  {
LABEL_61:
    v74 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v75 = NFLogGetLogger(v74);
    if (v75)
    {
      v76 = (void (*)(uint64_t, const char *, ...))v75;
      v77 = object_getClass(a1);
      v78 = class_isMetaClass(v77);
      v79 = object_getClassName(a1);
      v91 = sel_getName("_getKeyInfo:");
      v80 = 45;
      if (v78)
        v80 = 43;
      v76(3, "%c[%{public}s %{public}s]:%i Failed to get key information template", v80, v79, v91, 385);
    }
    v81 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v82 = NFSharedLogGetLogger(v81);
    v15 = objc_claimAutoreleasedReturnValue(v82);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      goto LABEL_14;
    v83 = object_getClass(a1);
    if (class_isMetaClass(v83))
      v84 = 43;
    else
      v84 = 45;
    v85 = object_getClassName(a1);
    v86 = sel_getName("_getKeyInfo:");
    *(_DWORD *)buf = 67109890;
    v102 = v84;
    v103 = 2082;
    v104 = v85;
    v105 = 2082;
    v106 = v86;
    v107 = 1024;
    v108 = 385;
    v18 = "%c[%{public}s %{public}s]:%i Failed to get key information template";
    goto LABEL_13;
  }
  v92 = a2;
  v93 = v4;
  v94 = 0;
  v33 = 0;
  do
  {
    v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectAtIndexedSubscript:", v33));
    v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectAtIndexedSubscript:", v33 + 1));
    v36 = v33 + 2;
    v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectAtIndexedSubscript:", v33 + 2));
    if (objc_msgSend(v34, "tag") == 192
      && objc_msgSend(v35, "tag") == 192
      && objc_msgSend(v37, "tag") == 192)
    {
      v96 = 0;
      v95 = 0;
      v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v34, "value"));
      objc_msgSend(v38, "getBytes:range:", (char *)&v96 + 1, 1, 1);

      v39 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v35, "value"));
      objc_msgSend(v39, "getBytes:range:", &v96, 1, 1);

      v40 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v37, "value"));
      objc_msgSend(v40, "getBytes:range:", &v95, 1, 1);

      if (HIBYTE(v96) == v96 && HIBYTE(v96) == v95)
      {
        if (v94)
        {
          v41 = objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:"));
          v42 = objc_claimAutoreleasedReturnValue(-[NSObject arrayByAddingObject:](v94, "arrayByAddingObject:", v41));

          v94 = v42;
        }
        else
        {
          v71 = objc_alloc((Class)NSArray);
          v41 = objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", HIBYTE(v96)));
          v94 = objc_msgSend(v71, "initWithObjects:", v41, 0);
        }
      }
      else
      {
        v58 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v59 = NFLogGetLogger(v58);
        if (v59)
        {
          v60 = (void (*)(uint64_t, const char *, ...))v59;
          v61 = object_getClass(a1);
          v62 = class_isMetaClass(v61);
          v63 = object_getClassName(a1);
          v90 = sel_getName("_getKeyInfo:");
          v64 = 45;
          if (v62)
            v64 = 43;
          v60(3, "%c[%{public}s %{public}s]:%i Inconsistent KVN in keyset", v64, v63, v90, 373);
        }
        v65 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v66 = NFSharedLogGetLogger(v65);
        v41 = objc_claimAutoreleasedReturnValue(v66);
        if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
        {
          v67 = object_getClass(a1);
          if (class_isMetaClass(v67))
            v68 = 43;
          else
            v68 = 45;
          v69 = object_getClassName(a1);
          v70 = sel_getName("_getKeyInfo:");
          *(_DWORD *)buf = 67109890;
          v102 = v68;
          v103 = 2082;
          v104 = v69;
          v105 = 2082;
          v106 = v70;
          v107 = 1024;
          v108 = 373;
          v56 = v41;
          v57 = "%c[%{public}s %{public}s]:%i Inconsistent KVN in keyset";
LABEL_45:
          _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_ERROR, v57, buf, 0x22u);
        }
      }
    }
    else
    {
      v43 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v44 = NFLogGetLogger(v43);
      if (v44)
      {
        v45 = (void (*)(uint64_t, const char *, ...))v44;
        v46 = object_getClass(a1);
        v47 = class_isMetaClass(v46);
        v48 = object_getClassName(a1);
        v89 = sel_getName("_getKeyInfo:");
        v49 = 45;
        if (v47)
          v49 = 43;
        v45(3, "%c[%{public}s %{public}s]:%i Invalid data format", v49, v48, v89, 360);
      }
      v50 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v51 = NFSharedLogGetLogger(v50);
      v41 = objc_claimAutoreleasedReturnValue(v51);
      if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
      {
        v52 = object_getClass(a1);
        if (class_isMetaClass(v52))
          v53 = 43;
        else
          v53 = 45;
        v54 = object_getClassName(a1);
        v55 = sel_getName("_getKeyInfo:");
        *(_DWORD *)buf = 67109890;
        v102 = v53;
        v103 = 2082;
        v104 = v54;
        v105 = 2082;
        v106 = v55;
        v107 = 1024;
        v108 = 360;
        v56 = v41;
        v57 = "%c[%{public}s %{public}s]:%i Invalid data format";
        goto LABEL_45;
      }
    }

    v33 = v36 + 1;
  }
  while ((unint64_t)objc_msgSend(v5, "count") > v36 + 1);
  v4 = v93;
  v19 = v94;
  if (!v94)
    goto LABEL_61;
  if (v92)
  {
    v99 = CFSTR("isdKeyVersionNumber");
    v100 = v94;
    v72 = &v100;
    v73 = &v99;
  }
  else
  {
    v97 = CFSTR("ssdKeyVersionNumber");
    v98 = v94;
    v72 = &v98;
    v73 = &v97;
  }
  v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v72, v73, 1));
LABEL_15:

LABEL_26:
  return v20;
}

void sub_10017BAD0(void *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  uint64_t v12;
  void (*v13)(uint64_t, const char *, ...);
  objc_class *v14;
  _BOOL4 v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  NSObject *v21;
  objc_class *v22;
  int v23;
  void *specific;
  uint64_t Logger;
  void (*v26)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v29;
  void *v30;
  uint64_t v31;
  NSObject *v32;
  objc_class *v33;
  int v34;
  void *v35;
  void *v36;
  NSObject *v37;
  void *v38;
  uint64_t v39;
  void (*v40)(uint64_t, const char *, ...);
  objc_class *v41;
  _BOOL4 v42;
  uint64_t v43;
  void *v44;
  uint64_t v45;
  objc_class *v46;
  int v47;
  const char *v48;
  const char *v49;
  void *v50;
  void *v51;
  NSObject *v52;
  void *v53;
  void *v54;
  uint64_t v55;
  void (*v56)(uint64_t, const char *, ...);
  objc_class *v57;
  _BOOL4 v58;
  uint64_t v59;
  void *v60;
  uint64_t v61;
  objc_class *v62;
  int v63;
  const char *v64;
  const char *v65;
  void *v66;
  uint64_t v67;
  void (*v68)(uint64_t, const char *, ...);
  objc_class *v69;
  _BOOL4 v70;
  uint64_t v71;
  void *v72;
  uint64_t v73;
  objc_class *v74;
  int v75;
  const char *v76;
  const char *v77;
  const char *ClassName;
  const char *v79;
  const char *v80;
  const char *v81;
  const char *Name;
  const char *v83;
  const char *v84;
  const char *v85;
  uint64_t v86;
  uint8_t buf[4];
  int v88;
  __int16 v89;
  const char *v90;
  __int16 v91;
  const char *v92;
  __int16 v93;
  int v94;
  __int16 v95;
  id v96;
  __int16 v97;
  unsigned int v98;

  v5 = a2;
  v6 = a3;
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "selectByName:error:", v5, 0));
  if (objc_msgSend(v7, "status") == 36864)
  {
    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "getData:", 193));
    v9 = v8;
    if (v8)
    {
      v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "NF_asHexString"));
      objc_msgSend(v6, "setObject:forKey:", v10, CFSTR("ssdCounter"));

    }
    else
    {
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v26 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(a1);
        Name = sel_getName("_addEntriesFromSSD:intoApp:");
        v29 = 45;
        if (isMetaClass)
          v29 = 43;
        v26(3, "%c[%{public}s %{public}s]:%i Failed to get sequence counter: %{public}@", v29, ClassName, Name, 1210, v5);
      }
      v30 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v31 = NFSharedLogGetLogger(v30);
      v32 = objc_claimAutoreleasedReturnValue(v31);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        v33 = object_getClass(a1);
        if (class_isMetaClass(v33))
          v34 = 43;
        else
          v34 = 45;
        *(_DWORD *)buf = 67110146;
        v88 = v34;
        v89 = 2082;
        v90 = object_getClassName(a1);
        v91 = 2082;
        v92 = sel_getName("_addEntriesFromSSD:intoApp:");
        v93 = 1024;
        v94 = 1210;
        v95 = 2114;
        v96 = v5;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get sequence counter: %{public}@", buf, 0x2Cu);
      }

      v9 = 0;
    }
    v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "getData:subtag:", 254, 57136));
    v36 = v35;
    if (v35)
    {
      v37 = objc_claimAutoreleasedReturnValue(objc_msgSend(v35, "NF_asHexString"));
      objc_msgSend(v6, "setObject:forKey:", v37, CFSTR("obgk"));
    }
    else
    {
      v38 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v39 = NFLogGetLogger(v38);
      if (v39)
      {
        v40 = (void (*)(uint64_t, const char *, ...))v39;
        v41 = object_getClass(a1);
        v42 = class_isMetaClass(v41);
        v79 = object_getClassName(a1);
        v83 = sel_getName("_addEntriesFromSSD:intoApp:");
        v43 = 45;
        if (v42)
          v43 = 43;
        v40(3, "%c[%{public}s %{public}s]:%i Failed to get OBGK: %{public}@", v43, v79, v83, 1217, v5);
      }
      v44 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v45 = NFSharedLogGetLogger(v44);
      v37 = objc_claimAutoreleasedReturnValue(v45);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
      {
        v46 = object_getClass(a1);
        if (class_isMetaClass(v46))
          v47 = 43;
        else
          v47 = 45;
        v48 = object_getClassName(a1);
        v49 = sel_getName("_addEntriesFromSSD:intoApp:");
        *(_DWORD *)buf = 67110146;
        v88 = v47;
        v89 = 2082;
        v90 = v48;
        v91 = 2082;
        v92 = v49;
        v93 = 1024;
        v94 = 1217;
        v95 = 2114;
        v96 = v5;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get OBGK: %{public}@", buf, 0x2Cu);
      }
    }

    v50 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "getData:", 32545));
    if (v50)
    {
      v51 = (void *)objc_claimAutoreleasedReturnValue(+[NFTLV TLVWithTag:fromData:](NFTLV, "TLVWithTag:fromData:", 147, v50));
      v52 = objc_claimAutoreleasedReturnValue(objc_msgSend(v51, "value"));

      if (v52)
      {
        v53 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject NF_asHexString](v52, "NF_asHexString"));
        objc_msgSend(v6, "setObject:forKey:", v53, CFSTR("certSN"));

LABEL_58:
        goto LABEL_59;
      }
      v66 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v67 = NFLogGetLogger(v66);
      if (v67)
      {
        v68 = (void (*)(uint64_t, const char *, ...))v67;
        v69 = object_getClass(a1);
        v70 = class_isMetaClass(v69);
        v81 = object_getClassName(a1);
        v85 = sel_getName("_addEntriesFromSSD:intoApp:");
        v71 = 45;
        if (v70)
          v71 = 43;
        v68(3, "%c[%{public}s %{public}s]:%i Failed to get certificate serial number: %{public}@", v71, v81, v85, 1229, v5);
      }
      v72 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v73 = NFSharedLogGetLogger(v72);
      v52 = objc_claimAutoreleasedReturnValue(v73);
      if (!os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
        goto LABEL_58;
      v74 = object_getClass(a1);
      if (class_isMetaClass(v74))
        v75 = 43;
      else
        v75 = 45;
      v76 = object_getClassName(a1);
      v77 = sel_getName("_addEntriesFromSSD:intoApp:");
      *(_DWORD *)buf = 67110146;
      v88 = v75;
      v89 = 2082;
      v90 = v76;
      v91 = 2082;
      v92 = v77;
      v93 = 1024;
      v94 = 1229;
      v95 = 2114;
      v96 = v5;
    }
    else
    {
      v54 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v55 = NFLogGetLogger(v54);
      if (v55)
      {
        v56 = (void (*)(uint64_t, const char *, ...))v55;
        v57 = object_getClass(a1);
        v58 = class_isMetaClass(v57);
        v80 = object_getClassName(a1);
        v84 = sel_getName("_addEntriesFromSSD:intoApp:");
        v59 = 45;
        if (v58)
          v59 = 43;
        v56(3, "%c[%{public}s %{public}s]:%i Failed to get certificate serial number: %{public}@", v59, v80, v84, 1225, v5);
      }
      v60 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v61 = NFSharedLogGetLogger(v60);
      v52 = objc_claimAutoreleasedReturnValue(v61);
      if (!os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
        goto LABEL_58;
      v62 = object_getClass(a1);
      if (class_isMetaClass(v62))
        v63 = 43;
      else
        v63 = 45;
      v64 = object_getClassName(a1);
      v65 = sel_getName("_addEntriesFromSSD:intoApp:");
      *(_DWORD *)buf = 67110146;
      v88 = v63;
      v89 = 2082;
      v90 = v64;
      v91 = 2082;
      v92 = v65;
      v93 = 1024;
      v94 = 1225;
      v95 = 2114;
      v96 = v5;
    }
    _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get certificate serial number: %{public}@", buf, 0x2Cu);
    goto LABEL_58;
  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFLogGetLogger(v11);
  if (v12)
  {
    v13 = (void (*)(uint64_t, const char *, ...))v12;
    v14 = object_getClass(a1);
    v15 = class_isMetaClass(v14);
    v16 = object_getClassName(a1);
    v17 = sel_getName("_addEntriesFromSSD:intoApp:");
    v86 = objc_msgSend(v7, "status");
    v18 = 45;
    if (v15)
      v18 = 43;
    v13(3, "%c[%{public}s %{public}s]:%i Failed to select SSD %{public}@: 0x%04x", v18, v16, v17, 1196, v5, v86);
  }
  v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v20 = NFSharedLogGetLogger(v19);
  v21 = objc_claimAutoreleasedReturnValue(v20);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    v22 = object_getClass(a1);
    if (class_isMetaClass(v22))
      v23 = 43;
    else
      v23 = 45;
    *(_DWORD *)buf = 67110402;
    v88 = v23;
    v89 = 2082;
    v90 = object_getClassName(a1);
    v91 = 2082;
    v92 = sel_getName("_addEntriesFromSSD:intoApp:");
    v93 = 1024;
    v94 = 1196;
    v95 = 2114;
    v96 = v5;
    v97 = 1024;
    v98 = objc_msgSend(v7, "status");
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select SSD %{public}@: 0x%04x", buf, 0x32u);
  }

  if (objc_msgSend(v7, "status") == 27033)
    objc_msgSend(v6, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("ssdIsLocked"));
LABEL_59:

}

uint64_t sub_10017C2C4(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_10017C2D4(uint64_t a1)
{

}

void sub_10017C2DC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v4;
  _UNKNOWN **v5;
  _UNKNOWN **v6;
  uint64_t v7;
  void *v8;
  void *v9;
  void *v10;
  NSObject *v11;
  NSObject *v12;
  void *v13;
  id v14;
  void *v15;
  uint64_t v16;
  void (*v17)(uint64_t, const char *, ...);
  objc_class *v18;
  _BOOL4 v19;
  const char *v20;
  const char *v21;
  void *v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  NSObject *v26;
  objc_class *v27;
  void *v28;
  int v29;
  const char *v30;
  const char *v31;
  void *v32;
  id v33;
  void *specific;
  uint64_t Logger;
  void (*v36)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v40;
  void *v41;
  uint64_t v42;
  objc_class *v43;
  int v44;
  const char *v45;
  const char *v46;
  unsigned int v47;
  void *v48;
  uint64_t v49;
  uint64_t v50;
  void *v51;
  int v52;
  void *v53;
  id v54;
  void *v55;
  id v56;
  void *v57;
  void *v58;
  NSObject *v59;
  void *v60;
  const __CFString *v61;
  id v62;
  void *v63;
  id v64;
  void *v65;
  id v66;
  id v67;
  uint64_t v68;
  void *i;
  void *v70;
  void *v71;
  void *v72;
  void *v73;
  uint64_t v74;
  id v75;
  NSObject *v76;
  void *v77;
  void *v78;
  void *v79;
  void *v80;
  void *v81;
  void *v82;
  void *v83;
  void *v84;
  void *v85;
  id v86;
  id v87;
  id v88;
  id v89;
  uint64_t v90;
  void *j;
  void *v92;
  void *v93;
  void *v94;
  id v95;
  const char *Name;
  id v97;
  void *v98;
  NSObject *v99;
  uint64_t v100;
  id v101;
  uint64_t v102;
  void *v103;
  uint64_t v104;
  id v105;
  NSObject *v106;
  void *v107;
  void *v108;
  uint64_t v109;
  id v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  _BYTE v127[128];
  _BYTE v128[128];
  uint8_t v129[128];
  uint8_t buf[4];
  int v131;
  __int16 v132;
  const char *v133;
  __int16 v134;
  const char *v135;
  __int16 v136;
  int v137;
  __int16 v138;
  id v139;

  v4 = (void *)objc_claimAutoreleasedReturnValue(+[NFTLV TLVSsWithBytes:length:requireDefiniteEncoding:](NFTLV, "TLVSsWithBytes:length:requireDefiniteEncoding:", a2, a3, 1));
  v119 = 0u;
  v120 = 0u;
  v121 = 0u;
  v122 = 0u;
  v101 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v119, v129, 16);
  if (v101)
  {
    v100 = *(_QWORD *)v120;
    v5 = &AMFDRSealingMapCopyLocalData_ptr;
    v6 = &AMFDRSealingMapCopyLocalData_ptr;
    v104 = a1;
    v98 = v4;
    do
    {
      v7 = 0;
      do
      {
        if (*(_QWORD *)v120 != v100)
          objc_enumerationMutation(v4);
        v102 = v7;
        v8 = *(void **)(*((_QWORD *)&v119 + 1) + 8 * v7);
        v103 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "childWithTag:", 79));
        if (!v103)
        {
          specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          Logger = NFLogGetLogger(specific);
          if (Logger)
          {
            v36 = (void (*)(uint64_t, const char *, ...))Logger;
            Class = object_getClass(*(id *)(a1 + 32));
            isMetaClass = class_isMetaClass(Class);
            ClassName = object_getClassName(*(id *)(a1 + 32));
            Name = sel_getName(*(SEL *)(a1 + 72));
            v40 = 45;
            if (isMetaClass)
              v40 = 43;
            v36(3, "%c[%{public}s %{public}s]:%i Missing AID tag", v40, ClassName, Name, 846);
          }
          v41 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v42 = NFSharedLogGetLogger(v41);
          v12 = objc_claimAutoreleasedReturnValue(v42);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          {
            v43 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v43))
              v44 = 43;
            else
              v44 = 45;
            v45 = object_getClassName(*(id *)(a1 + 32));
            v46 = sel_getName(*(SEL *)(a1 + 72));
            *(_DWORD *)buf = 67109890;
            v131 = v44;
            v132 = 2082;
            v133 = v45;
            v134 = 2082;
            v135 = v46;
            v136 = 1024;
            v137 = 846;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Missing AID tag", buf, 0x22u);
          }
          goto LABEL_90;
        }
        if (!*(_BYTE *)(a1 + 80)
          || (v9 = *(void **)(a1 + 40),
              v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v103, "value")),
              LOBYTE(v9) = objc_msgSend(v9, "containsObject:", v10),
              v10,
              (v9 & 1) == 0))
        {
          v11 = objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "childWithTag:", 197));
          v12 = v11;
          if (!v11
            || (v13 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject value](v11, "value")),
                v14 = objc_msgSend(v13, "length"),
                v13,
                (unint64_t)v14 >= 5))
          {
            v15 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v16 = NFLogGetLogger(v15);
            if (v16)
            {
              v17 = (void (*)(uint64_t, const char *, ...))v16;
              v18 = object_getClass(*(id *)(a1 + 32));
              v19 = class_isMetaClass(v18);
              v20 = object_getClassName(*(id *)(a1 + 32));
              v21 = sel_getName(*(SEL *)(a1 + 72));
              v22 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject value](v12, "value"));
              v97 = objc_msgSend(v22, "length");
              v23 = 45;
              if (v19)
                v23 = 43;
              v17(3, "%c[%{public}s %{public}s]:%i Missing or too long privilege tag 0xC5 %lu", v23, v20, v21, 860, v97);

            }
            v24 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v25 = NFSharedLogGetLogger(v24);
            v26 = objc_claimAutoreleasedReturnValue(v25);
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
            {
              v27 = object_getClass(*(id *)(a1 + 32));
              v28 = v4;
              if (class_isMetaClass(v27))
                v29 = 43;
              else
                v29 = 45;
              v30 = object_getClassName(*(id *)(a1 + 32));
              v31 = sel_getName(*(SEL *)(a1 + 72));
              v32 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject value](v12, "value"));
              v33 = objc_msgSend(v32, "length");
              *(_DWORD *)buf = 67110146;
              v131 = v29;
              v4 = v28;
              v132 = 2082;
              v133 = v30;
              v134 = 2082;
              v135 = v31;
              v136 = 1024;
              v137 = 860;
              v138 = 2048;
              v139 = v33;
              _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Missing or too long privilege tag 0xC5 %lu", buf, 0x2Cu);

            }
            goto LABEL_89;
          }
          v99 = v12;
          v47 = -[NSObject valueAsUnsignedLong](v12, "valueAsUnsignedLong");
          if ((v47 & 0x800000) != 0)
          {
            if ((~v47 & 0xC10000) != 0)
            {
              if ((v47 & 0x540) == 0)
              {
                v94 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 40);
                v26 = objc_claimAutoreleasedReturnValue(objc_msgSend(v103, "valueAsHexString"));
                objc_msgSend(v94, "addObject:", v26);
                goto LABEL_89;
              }
            }
            else
            {
              v93 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40);
              v26 = objc_claimAutoreleasedReturnValue(objc_msgSend(v103, "valueAsHexString"));
              objc_msgSend(v93, "addObject:", v26);
LABEL_88:
              v12 = v99;
LABEL_89:

            }
LABEL_90:

            goto LABEL_91;
          }
          v26 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithCapacity:", 18);
          v115 = 0u;
          v116 = 0u;
          v117 = 0u;
          v118 = 0u;
          v48 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "children"));
          v110 = objc_msgSend(v48, "countByEnumeratingWithState:objects:count:", &v115, v128, 16);
          if (!v110)
            goto LABEL_85;
          v49 = *(_QWORD *)v116;
          v106 = v26;
          v108 = v48;
          v109 = *(_QWORD *)v116;
          while (2)
          {
            v50 = 0;
LABEL_33:
            if (*(_QWORD *)v116 != v49)
              objc_enumerationMutation(v48);
            v51 = *(void **)(*((_QWORD *)&v115 + 1) + 8 * v50);
            v52 = objc_msgSend(v51, "tag");
            if (v52 <= 164)
            {
              if (v52 <= 159)
              {
                if (v52 == 79)
                {
                  v58 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v51, "valueAsHexString"));
                  v59 = v26;
                  v60 = v58;
                  v61 = CFSTR("appletAid");
                }
                else
                {
                  if (v52 != 132)
                    goto LABEL_83;
                  v58 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v51, "valueAsHexString"));
                  v59 = v26;
                  v60 = v58;
                  v61 = CFSTR("moduleAid");
                }
                goto LABEL_81;
              }
              if (v52 == 160)
              {
                v71 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v51, "childWithTag:", 79));
                v58 = v71;
                if (!v71)
                  v71 = v51;
                v72 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v71, "valueAsHexString"));
                -[NSObject setObject:forKeyedSubscript:](v26, "setObject:forKeyedSubscript:", v72, CFSTR("primaryContainer"));

                goto LABEL_82;
              }
              if (v52 == 164)
              {
                v62 = objc_alloc((Class)v5[252]);
                v63 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v51, "children"));
                v64 = objc_msgSend(v62, "initWithCapacity:", objc_msgSend(v63, "count"));

                v113 = 0u;
                v114 = 0u;
                v111 = 0u;
                v112 = 0u;
                v65 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v51, "children"));
                v66 = objc_msgSend(v65, "countByEnumeratingWithState:objects:count:", &v111, v127, 16);
                if (v66)
                {
                  v67 = v66;
                  v68 = *(_QWORD *)v112;
                  do
                  {
                    for (i = 0; i != v67; i = (char *)i + 1)
                    {
                      if (*(_QWORD *)v112 != v68)
                        objc_enumerationMutation(v65);
                      v70 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*((_QWORD *)&v111 + 1) + 8 * (_QWORD)i), "valueAsHexString"));
                      objc_msgSend(v64, "addObject:", v70);

                    }
                    v67 = objc_msgSend(v65, "countByEnumeratingWithState:objects:count:", &v111, v127, 16);
                  }
                  while (v67);
                }

                v26 = v106;
                -[NSObject setObject:forKeyedSubscript:](v106, "setObject:forKeyedSubscript:", v64, CFSTR("auxilaryContainers"));

                v48 = v108;
                v49 = v109;
              }
            }
            else
            {
              if (v52 > 203)
              {
                if (v52 == 204)
                {
                  v58 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v51, "valueAsHexString"));
                  v59 = v26;
                  v60 = v58;
                  v61 = CFSTR("associatedSSD");
                }
                else
                {
                  if (v52 != 218)
                  {
                    if (v52 == 40816)
                    {
                      v53 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v51, "value"));
                      v54 = objc_msgSend(v53, "length");

                      if (v54)
                      {
                        v55 = v6[260];
                        v56 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(v51, "value")));
                        v57 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v55, "numberWithUnsignedChar:", *(unsigned __int8 *)objc_msgSend(v56, "bytes")));
                        -[NSObject setObject:forKeyedSubscript:](v26, "setObject:forKeyedSubscript:", v57, CFSTR("lifeCycleState"));

                      }
                    }
                    goto LABEL_83;
                  }
                  v58 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v51, "valueAsHexString"));
                  v59 = v26;
                  v60 = v58;
                  v61 = CFSTR("appletPresentmentACL");
                }
LABEL_81:
                -[NSObject setObject:forKeyedSubscript:](v59, "setObject:forKeyedSubscript:", v60, v61);
LABEL_82:

                goto LABEL_83;
              }
              if (v52 != 165)
              {
                if (v52 != 196)
                  goto LABEL_83;
                v58 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v51, "valueAsHexString"));
                v59 = v26;
                v60 = v58;
                v61 = CFSTR("packageAid");
                goto LABEL_81;
              }
              v73 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v51, "valueAsHexString"));
              -[NSObject setObject:forKeyedSubscript:](v26, "setObject:forKeyedSubscript:", v73, CFSTR("discretionaryData"));

              v74 = *(_QWORD *)(a1 + 32);
              v75 = v51;
              v76 = v26;
              if (v74)
              {
                v77 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v75, "childWithTag:", 254));
                v78 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v77, "childWithTag:", 57152));

                if (v78)
                {
                  v79 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v78, "valueAsHexString"));
                  -[NSObject setObject:forKeyedSubscript:](v76, "setObject:forKeyedSubscript:", v79, CFSTR("extendedFunction"));

                  LODWORD(v79) = objc_msgSend(v78, "valueAsUnsignedShort");
                  v80 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6[260], "numberWithBool:", (v79 >> 2) & 1));
                  -[NSObject setObject:forKeyedSubscript:](v76, "setObject:forKeyedSubscript:", v80, CFSTR("containerInstance"));

                  v81 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6[260], "numberWithBool:", (v79 >> 3) & 1));
                  -[NSObject setObject:forKeyedSubscript:](v76, "setObject:forKeyedSubscript:", v81, CFSTR("proxyInstance"));

                }
                v107 = v78;
                v82 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v75, "childWithTag:", 204));
                v83 = v82;
                if (v82)
                {
                  v84 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v82, "valueAsHexString"));
                  -[NSObject setObject:forKeyedSubscript:](v76, "setObject:forKeyedSubscript:", v84, CFSTR("ssdAid"));

                }
                v85 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v75, "childrenWithTag:", 221));
                if (objc_msgSend(v85, "count"))
                {
                  v105 = v75;
                  v86 = objc_msgSend(objc_alloc((Class)v5[252]), "initWithCapacity:", objc_msgSend(v85, "count"));
                  v123 = 0u;
                  v124 = 0u;
                  v125 = 0u;
                  v126 = 0u;
                  v87 = v85;
                  v88 = objc_msgSend(v87, "countByEnumeratingWithState:objects:count:", &v123, buf, 16);
                  if (v88)
                  {
                    v89 = v88;
                    v90 = *(_QWORD *)v124;
                    do
                    {
                      for (j = 0; j != v89; j = (char *)j + 1)
                      {
                        if (*(_QWORD *)v124 != v90)
                          objc_enumerationMutation(v87);
                        v92 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*((_QWORD *)&v123 + 1) + 8 * (_QWORD)j), "valueAsHexString"));
                        objc_msgSend(v86, "addObject:", v92);

                      }
                      v89 = objc_msgSend(v87, "countByEnumeratingWithState:objects:count:", &v123, buf, 16);
                    }
                    while (v89);
                  }

                  -[NSObject setObject:forKeyedSubscript:](v76, "setObject:forKeyedSubscript:", v86, CFSTR("multiSEApplicationGroup"));
                  a1 = v104;
                  v75 = v105;
                  v5 = &AMFDRSealingMapCopyLocalData_ptr;
                  v6 = &AMFDRSealingMapCopyLocalData_ptr;
                  v26 = v106;
                }

                v48 = v108;
              }

              v49 = v109;
            }
LABEL_83:
            if ((id)++v50 == v110)
            {
              v110 = objc_msgSend(v48, "countByEnumeratingWithState:objects:count:", &v115, v128, 16);
              if (!v110)
              {
LABEL_85:

                objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 40), "addObject:", v26);
                v4 = v98;
                goto LABEL_88;
              }
              continue;
            }
            goto LABEL_33;
          }
        }
LABEL_91:

        v7 = v102 + 1;
      }
      while ((id)(v102 + 1) != v101);
      v95 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v119, v129, 16);
      v101 = v95;
    }
    while (v95);
  }

}

id sub_10017CDE0(void *a1, uint64_t a2, uint64_t a3, unint64_t a4, void *a5)
{
  id v9;
  id v10;
  id v11;
  void *v12;
  id v13;
  id v14;
  id v15;
  void *v16;
  id v17;
  void *v18;
  void *v19;
  uint64_t v20;
  id v21;
  id v22;
  uint64_t v23;
  id v24;
  id v25;
  unsigned int v26;
  void (**v27)(_QWORD, id, char *);
  id v28;
  char *v29;
  unsigned int v30;
  uint64_t v31;
  id v32;
  id v33;
  void *v34;
  id v35;
  id v36;
  void *v37;
  id v38;
  id v39;
  _QWORD *v40;
  _QWORD *v41;
  void *v42;
  id v43;
  uint64_t v44;
  id v46;
  id v47;
  id v48;
  id v49;
  id v50;
  char v51;
  __int16 v52;
  char v53;
  char v54;
  _QWORD v55[5];
  _QWORD v56[5];
  _QWORD v57[5];
  _QWORD v58[5];
  _QWORD v59[5];
  _QWORD v60[5];
  _QWORD v61[5];
  _QWORD v62[5];
  _QWORD v63[5];
  _QWORD v64[5];
  _QWORD v65[4];
  _QWORD v66[4];
  _QWORD v67[5];
  _QWORD v68[5];

  v9 = a5;
  if (a1)
  {
    v52 = 79;
    v53 = 92;
    v54 = a4;
    v51 = 3;
    if (a4 < 0x100)
    {
      v18 = (void *)objc_claimAutoreleasedReturnValue(+[NFCommandAPDU buildAPDUHeaderWithClass:instruction:p1:p2:len:useExtendedLength:](NFCommandAPDU, "buildAPDUHeaderWithClass:instruction:p1:p2:len:useExtendedLength:", 128, 175, a2, 2, (a4 + 4), 1));
      if (v18)
      {
        v19 = v18;
        objc_msgSend(v18, "appendBytes:length:", &v52, 4);
        objc_msgSend(v19, "appendBytes:length:", a3, a4);
        v20 = objc_claimAutoreleasedReturnValue(+[NFCommandAPDU appendExpectedLength:usingExtendedLength:toAPDU:](NFCommandAPDU, "appendExpectedLength:usingExtendedLength:toAPDU:", 0, 1, v19));
        if (v20)
        {
          v11 = (id)v20;
          v21 = objc_alloc((Class)NSError);
          v13 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
          v22 = objc_msgSend(v11, "code");
          v63[0] = NSLocalizedDescriptionKey;
          v49 = v9;
          if ((uint64_t)objc_msgSend(v11, "code") > 70)
            v23 = 71;
          else
            v23 = (uint64_t)objc_msgSend(v11, "code");
          v14 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", (&off_1002E9DF8)[v23]));
          v64[0] = v14;
          v64[1] = v11;
          v63[1] = NSUnderlyingErrorKey;
          v63[2] = CFSTR("Line");
          v64[2] = &off_1003000B0;
          v63[3] = CFSTR("Method");
          v15 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("sendProprietaryGetStatusCommand:tagList:tagListLen:callback:"));
          v64[3] = v15;
          v63[4] = NSDebugDescriptionErrorKey;
          v33 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("sendProprietaryGetStatusCommand:tagList:tagListLen:callback:"), 1129);
          v64[4] = v33;
          v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v64, v63, 5));
          v17 = objc_msgSend(v21, "initWithDomain:code:userInfo:", v13, v22, v34);

          v12 = v19;
          v9 = v49;
        }
        else
        {
          v25 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10026A554, 8);
          v26 = objc_msgSend(a1, "select:error:", v25, 0);

          if (v26)
          {
            while (1)
            {
              v50 = 0;
              v13 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "transceiveData:toOS:error:", v19, 0, &v50));
              v11 = v50;
              if (v11)
                break;
              v27 = (void (**)(_QWORD, id, char *))v9;
              if (!v13 || (unint64_t)objc_msgSend(v13, "length") <= 1)
              {
                v47 = objc_alloc((Class)NSError);
                v14 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
                v57[0] = NSLocalizedDescriptionKey;
                v15 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Commmand Error"));
                v58[0] = v15;
                v58[1] = &off_1003000F8;
                v57[1] = CFSTR("Line");
                v57[2] = CFSTR("Method");
                v48 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("sendProprietaryGetStatusCommand:tagList:tagListLen:callback:"));
                v58[2] = v48;
                v57[3] = NSDebugDescriptionErrorKey;
                v38 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("sendProprietaryGetStatusCommand:tagList:tagListLen:callback:"), 1145);
                v58[3] = v38;
                v57[4] = NSLocalizedFailureReasonErrorKey;
                v39 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("Null or too-short response"));
                v58[4] = v39;
                v40 = v58;
                v41 = v57;
LABEL_21:
                v42 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v40, v41, 5));
                v17 = objc_msgSend(v47, "initWithDomain:code:userInfo:", v14, 16, v42);

                goto LABEL_26;
              }
              v28 = objc_retainAutorelease(v13);
              v29 = (char *)objc_msgSend(v28, "bytes");
              v30 = *(unsigned __int16 *)&v29[(_QWORD)objc_msgSend(v28, "length") - 2];
              v31 = __rev16(v30);
              if ((_DWORD)v31 != 25360 && (_DWORD)v31 != 36864)
              {
                v47 = objc_alloc((Class)NSError);
                v14 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
                v55[0] = NSLocalizedDescriptionKey;
                v15 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Commmand Error"));
                v56[0] = v15;
                v56[1] = &off_100300110;
                v55[1] = CFSTR("Line");
                v55[2] = CFSTR("Method");
                v48 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("sendProprietaryGetStatusCommand:tagList:tagListLen:callback:"));
                v56[2] = v48;
                v55[3] = NSDebugDescriptionErrorKey;
                v38 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("sendProprietaryGetStatusCommand:tagList:tagListLen:callback:"), 1149);
                v56[3] = v38;
                v55[4] = NSLocalizedFailureReasonErrorKey;
                v39 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("error status word 0x%hx"), v31);
                v56[4] = v39;
                v40 = v56;
                v41 = v55;
                goto LABEL_21;
              }
              v32 = objc_retainAutorelease(v28);
              v9 = v27;
              v27[2](v27, objc_msgSend(v32, "bytes"), (char *)objc_msgSend(v32, "length") - 2);

              objc_msgSend(v19, "replaceBytesInRange:withBytes:length:", 3, 1, &v51, 1);
              if (v30 != 4195)
              {
                v17 = 0;
                goto LABEL_28;
              }
            }
            v43 = objc_alloc((Class)NSError);
            v14 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
            v46 = objc_msgSend(v11, "code");
            v59[0] = NSLocalizedDescriptionKey;
            v27 = (void (**)(_QWORD, id, char *))v9;
            if ((uint64_t)objc_msgSend(v11, "code") > 70)
              v44 = 71;
            else
              v44 = (uint64_t)objc_msgSend(v11, "code");
            v15 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", (&off_1002E9DF8)[v44]));
            v60[0] = v15;
            v60[1] = v11;
            v59[1] = NSUnderlyingErrorKey;
            v59[2] = CFSTR("Line");
            v60[2] = &off_1003000E0;
            v59[3] = CFSTR("Method");
            v48 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("sendProprietaryGetStatusCommand:tagList:tagListLen:callback:"));
            v60[3] = v48;
            v59[4] = NSDebugDescriptionErrorKey;
            v38 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("sendProprietaryGetStatusCommand:tagList:tagListLen:callback:"), 1142);
            v60[4] = v38;
            v39 = (id)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v60, v59, 5));
            v17 = objc_msgSend(v43, "initWithDomain:code:userInfo:", v14, v46, v39);
LABEL_26:

            v12 = v19;
            v9 = v27;
          }
          else
          {
            v35 = objc_alloc((Class)NSError);
            v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
            v61[0] = NSLocalizedDescriptionKey;
            v13 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Commmand Error"));
            v62[0] = v13;
            v62[1] = &off_1003000C8;
            v61[1] = CFSTR("Line");
            v61[2] = CFSTR("Method");
            v14 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("sendProprietaryGetStatusCommand:tagList:tagListLen:callback:"));
            v62[2] = v14;
            v61[3] = NSDebugDescriptionErrorKey;
            v15 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("sendProprietaryGetStatusCommand:tagList:tagListLen:callback:"), 1133);
            v62[3] = v15;
            v61[4] = NSLocalizedFailureReasonErrorKey;
            v36 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("Failed to select ISD"));
            v62[4] = v36;
            v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v62, v61, 5));
            v17 = objc_msgSend(v35, "initWithDomain:code:userInfo:", v12, 16, v37);

            v11 = v19;
          }
        }
      }
      else
      {
        v24 = objc_alloc((Class)NSError);
        v11 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v65[0] = NSLocalizedDescriptionKey;
        v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "No resources"));
        v66[0] = v12;
        v66[1] = &off_100300098;
        v65[1] = CFSTR("Line");
        v65[2] = CFSTR("Method");
        v13 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("sendProprietaryGetStatusCommand:tagList:tagListLen:callback:"));
        v66[2] = v13;
        v65[3] = NSDebugDescriptionErrorKey;
        v14 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("sendProprietaryGetStatusCommand:tagList:tagListLen:callback:"), 1122);
        v66[3] = v14;
        v15 = (id)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v66, v65, 4));
        v17 = objc_msgSend(v24, "initWithDomain:code:userInfo:", v11, 34, v15);
      }
    }
    else
    {
      v10 = objc_alloc((Class)NSError);
      v11 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v67[0] = NSLocalizedDescriptionKey;
      v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid Parameter"));
      v68[0] = v12;
      v68[1] = &off_100300080;
      v67[1] = CFSTR("Line");
      v67[2] = CFSTR("Method");
      v13 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("sendProprietaryGetStatusCommand:tagList:tagListLen:callback:"));
      v68[2] = v13;
      v67[3] = NSDebugDescriptionErrorKey;
      v14 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("sendProprietaryGetStatusCommand:tagList:tagListLen:callback:"), 1111);
      v68[3] = v14;
      v67[4] = NSLocalizedFailureReasonErrorKey;
      v15 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("Tag list length too long"));
      v68[4] = v15;
      v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v68, v67, 5));
      v17 = objc_msgSend(v10, "initWithDomain:code:userInfo:", v11, 10, v16);

    }
    v19 = v11;
LABEL_28:

  }
  else
  {
    v17 = 0;
  }

  return v17;
}

uint64_t sub_10017D9B0(uint64_t a1, void *a2)
{
  id v3;
  id v4;
  id v5;
  id v6;
  uint64_t v7;
  void *v8;
  void *v9;
  unsigned __int8 v10;
  uint64_t v11;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  _BYTE v17[128];

  v3 = a2;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  v4 = *(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v13, v17, 16);
  if (v5)
  {
    v6 = v5;
    v7 = *(_QWORD *)v14;
    while (2)
    {
      v8 = 0;
      do
      {
        if (*(_QWORD *)v14 != v7)
          objc_enumerationMutation(v4);
        v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*((_QWORD *)&v13 + 1) + 8 * (_QWORD)v8), "objectForKeyedSubscript:", CFSTR("associatedSSD"), (_QWORD)v13));
        v10 = objc_msgSend(v9, "isEqualToString:", v3);

        if ((v10 & 1) != 0)
        {
          v11 = 0;
          goto LABEL_11;
        }
        v8 = (char *)v8 + 1;
      }
      while (v6 != v8);
      v6 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v13, v17, 16);
      if (v6)
        continue;
      break;
    }
  }
  v11 = 1;
LABEL_11:

  return v11;
}

void sub_10017DAF8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v4;
  id v5;
  uint64_t v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  NSObject *v11;
  void *v12;
  void *v13;
  void *specific;
  uint64_t Logger;
  void (*v16)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  NSObject *v22;
  objc_class *v23;
  int v24;
  const char *v25;
  const char *v26;
  void *v27;
  id v28;
  id v29;
  id v30;
  uint64_t v31;
  uint64_t v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  uint64_t v38;
  void (*v39)(uint64_t, const char *, ...);
  objc_class *v40;
  _BOOL4 v41;
  const char *v42;
  uint64_t v43;
  void *v44;
  uint64_t v45;
  objc_class *v46;
  int v47;
  const char *v48;
  const char *v49;
  void *v50;
  uint64_t v51;
  void (*v52)(uint64_t, const char *, ...);
  objc_class *v53;
  _BOOL4 v54;
  const char *v55;
  const char *v56;
  void *v57;
  uint64_t v58;
  void *v59;
  uint64_t v60;
  NSObject *v61;
  objc_class *v62;
  int v63;
  const char *v64;
  const char *v65;
  void *v66;
  id v67;
  void *v68;
  void *v69;
  void *v70;
  void *v71;
  uint64_t v72;
  void (*v73)(uint64_t, const char *, ...);
  objc_class *v74;
  _BOOL4 v75;
  uint64_t v76;
  void *v77;
  uint64_t v78;
  NSObject *v79;
  objc_class *v80;
  int v81;
  const char *v82;
  const char *v83;
  void *v84;
  void *v85;
  void *v86;
  void *v87;
  uint64_t v88;
  void (*v89)(uint64_t, const char *, ...);
  objc_class *v90;
  uint64_t v91;
  void *v92;
  uint64_t v93;
  NSObject *v94;
  objc_class *v95;
  int v96;
  const char *v97;
  const char *v98;
  const char *ClassName;
  const char *v100;
  const char *v101;
  const char *Name;
  const char *v103;
  const char *v104;
  const char *v105;
  uint64_t v106;
  id v107;
  id obj;
  void *v109;
  _BOOL4 v110;
  int v111;
  void *v112;
  NSObject *v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  uint8_t buf[4];
  int v123;
  __int16 v124;
  const char *v125;
  __int16 v126;
  const char *v127;
  __int16 v128;
  int v129;
  __int16 v130;
  NSObject *v131;
  __int16 v132;
  void *v133;
  _BYTE v134[128];
  _BYTE v135[128];

  v118 = 0u;
  v119 = 0u;
  v120 = 0u;
  v121 = 0u;
  obj = (id)objc_claimAutoreleasedReturnValue(+[NFTLV TLVSsWithBytes:length:requireDefiniteEncoding:](NFTLV, "TLVSsWithBytes:length:requireDefiniteEncoding:", a2, a3, 1));
  v4 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v118, v135, 16);
  if (v4)
  {
    v5 = v4;
    v6 = *(_QWORD *)v119;
    v106 = *(_QWORD *)v119;
    do
    {
      v7 = 0;
      v107 = v5;
      do
      {
        if (*(_QWORD *)v119 != v6)
          objc_enumerationMutation(obj);
        v8 = *(void **)(*((_QWORD *)&v118 + 1) + 8 * (_QWORD)v7);
        v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "childWithTag:", 79));
        v10 = v9;
        if (v9)
        {
          v11 = objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "valueAsHexString"));
          v112 = v10;
          if (*(_BYTE *)(a1 + 72)
            && (v12 = *(void **)(a1 + 40),
                v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "value")),
                LODWORD(v12) = objc_msgSend(v12, "containsObject:", v13),
                v13,
                (_DWORD)v12))
          {
            specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            Logger = NFLogGetLogger(specific);
            if (Logger)
            {
              v16 = (void (*)(uint64_t, const char *, ...))Logger;
              Class = object_getClass(*(id *)(a1 + 32));
              isMetaClass = class_isMetaClass(Class);
              ClassName = object_getClassName(*(id *)(a1 + 32));
              Name = sel_getName(*(SEL *)(a1 + 64));
              v19 = 45;
              if (isMetaClass)
                v19 = 43;
              v16(3, "%c[%{public}s %{public}s]:%i Hiding package AID %{public}@", v19, ClassName, Name, 1035, v11);
            }
            v20 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v21 = NFSharedLogGetLogger(v20);
            v22 = objc_claimAutoreleasedReturnValue(v21);
            if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
            {
              v23 = object_getClass(*(id *)(a1 + 32));
              if (class_isMetaClass(v23))
                v24 = 43;
              else
                v24 = 45;
              v25 = object_getClassName(*(id *)(a1 + 32));
              v26 = sel_getName(*(SEL *)(a1 + 64));
              *(_DWORD *)buf = 67110146;
              v123 = v24;
              v124 = 2082;
              v125 = v25;
              v126 = 2082;
              v127 = v26;
              v128 = 1024;
              v129 = 1035;
              v130 = 2114;
              v131 = v11;
              _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Hiding package AID %{public}@", buf, 0x2Cu);
            }
          }
          else
          {
            v113 = v11;
            v109 = v8;
            v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "childrenWithTag:", 132));
            v28 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", objc_msgSend(v27, "count"));
            v114 = 0u;
            v115 = 0u;
            v116 = 0u;
            v117 = 0u;
            v22 = v27;
            v29 = -[NSObject countByEnumeratingWithState:objects:count:](v22, "countByEnumeratingWithState:objects:count:", &v114, v134, 16);
            if (v29)
            {
              v30 = v29;
              v31 = *(_QWORD *)v115;
LABEL_20:
              v32 = 0;
              while (1)
              {
                if (*(_QWORD *)v115 != v31)
                  objc_enumerationMutation(v22);
                v33 = *(void **)(*((_QWORD *)&v114 + 1) + 8 * v32);
                if (*(_BYTE *)(a1 + 72))
                {
                  v34 = *(void **)(a1 + 48);
                  v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*((_QWORD *)&v114 + 1) + 8 * v32), "value"));
                  LODWORD(v34) = objc_msgSend(v34, "containsObject:", v35);

                  if ((_DWORD)v34)
                    break;
                }
                v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v33, "valueAsHexString"));
                objc_msgSend(v28, "addObject:", v36);

                if (v30 == (id)++v32)
                {
                  v30 = -[NSObject countByEnumeratingWithState:objects:count:](v22, "countByEnumeratingWithState:objects:count:", &v114, v134, 16);
                  if (v30)
                    goto LABEL_20;
                  goto LABEL_27;
                }
              }
              v50 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v51 = NFLogGetLogger(v50);
              if (v51)
              {
                v52 = (void (*)(uint64_t, const char *, ...))v51;
                v53 = object_getClass(*(id *)(a1 + 32));
                v54 = class_isMetaClass(v53);
                v55 = object_getClassName(*(id *)(a1 + 32));
                v56 = sel_getName(*(SEL *)(a1 + 64));
                v57 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v33, "valueAsHexString"));
                v58 = 45;
                if (v54)
                  v58 = 43;
                v52(6, "%c[%{public}s %{public}s]:%i Hiding package %{public}@ / module %{public}@", v58, v55, v56, 1044, v113, v57);

              }
              v59 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v60 = NFSharedLogGetLogger(v59);
              v61 = objc_claimAutoreleasedReturnValue(v60);
              if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
              {
                v62 = object_getClass(*(id *)(a1 + 32));
                if (class_isMetaClass(v62))
                  v63 = 43;
                else
                  v63 = 45;
                v64 = object_getClassName(*(id *)(a1 + 32));
                v65 = sel_getName(*(SEL *)(a1 + 64));
                v66 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v33, "valueAsHexString"));
                *(_DWORD *)buf = 67110402;
                v123 = v63;
                v124 = 2082;
                v125 = v64;
                v126 = 2082;
                v127 = v65;
                v128 = 1024;
                v129 = 1044;
                v130 = 2114;
                v131 = v113;
                v132 = 2114;
                v133 = v66;
                _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Hiding package %{public}@ / module %{public}@", buf, 0x36u);

              }
              v11 = v113;
              if (*(_BYTE *)(a1 + 72))
                goto LABEL_76;
            }
            else
            {
LABEL_27:

              v11 = v113;
            }
            v67 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithObjectsAndKeys:", v11, CFSTR("packageAid"), v28, CFSTR("moduleAids"), 0);
            v68 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v109, "childWithTag:", 206));
            v69 = v68;
            if (v68)
            {
              v70 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v68, "valueAsHexString"));
              if (v70)
              {
                objc_msgSend(v67, "setObject:forKeyedSubscript:", v70, CFSTR("version"));
              }
              else
              {
                v71 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                v72 = NFLogGetLogger(v71);
                if (v72)
                {
                  v73 = (void (*)(uint64_t, const char *, ...))v72;
                  v74 = object_getClass(*(id *)(a1 + 32));
                  v75 = class_isMetaClass(v74);
                  v100 = object_getClassName(*(id *)(a1 + 32));
                  v104 = sel_getName(*(SEL *)(a1 + 64));
                  v76 = 45;
                  if (v75)
                    v76 = 43;
                  v73(4, "%c[%{public}s %{public}s]:%i Missing package version info %{public}@", v76, v100, v104, 1064, v113);
                }
                v77 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                v78 = NFSharedLogGetLogger(v77);
                v79 = objc_claimAutoreleasedReturnValue(v78);
                if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
                {
                  v80 = object_getClass(*(id *)(a1 + 32));
                  if (class_isMetaClass(v80))
                    v81 = 43;
                  else
                    v81 = 45;
                  v82 = object_getClassName(*(id *)(a1 + 32));
                  v83 = sel_getName(*(SEL *)(a1 + 64));
                  *(_DWORD *)buf = 67110146;
                  v123 = v81;
                  v124 = 2082;
                  v125 = v82;
                  v126 = 2082;
                  v127 = v83;
                  v128 = 1024;
                  v129 = 1064;
                  v130 = 2114;
                  v131 = v113;
                  _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Missing package version info %{public}@", buf, 0x2Cu);
                }

              }
            }
            v84 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v109, "childWithTag:", 204));
            v85 = v84;
            if (v84)
            {
              v86 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v84, "valueAsHexString"));
              if (v86)
              {
                objc_msgSend(v67, "setObject:forKeyedSubscript:", v86, CFSTR("associatedSSD"));
              }
              else
              {
                v87 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                v88 = NFLogGetLogger(v87);
                if (v88)
                {
                  v89 = (void (*)(uint64_t, const char *, ...))v88;
                  v90 = object_getClass(*(id *)(a1 + 32));
                  v110 = class_isMetaClass(v90);
                  v101 = object_getClassName(*(id *)(a1 + 32));
                  v105 = sel_getName(*(SEL *)(a1 + 64));
                  v91 = 45;
                  if (v110)
                    v91 = 43;
                  v89(4, "%c[%{public}s %{public}s]:%i Missing associated SSD String info %{public}@", v91, v101, v105, 1075, v113);
                }
                v92 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                v93 = NFSharedLogGetLogger(v92);
                v94 = objc_claimAutoreleasedReturnValue(v93);
                if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
                {
                  v95 = object_getClass(*(id *)(a1 + 32));
                  if (class_isMetaClass(v95))
                    v96 = 43;
                  else
                    v96 = 45;
                  v111 = v96;
                  v97 = object_getClassName(*(id *)(a1 + 32));
                  v98 = sel_getName(*(SEL *)(a1 + 64));
                  *(_DWORD *)buf = 67110146;
                  v123 = v111;
                  v124 = 2082;
                  v125 = v97;
                  v126 = 2082;
                  v127 = v98;
                  v128 = 1024;
                  v129 = 1075;
                  v130 = 2114;
                  v131 = v113;
                  _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Missing associated SSD String info %{public}@", buf, 0x2Cu);
                }

              }
            }
            objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 40), "addObject:", v67);

            v11 = v113;
LABEL_76:

            v6 = v106;
            v5 = v107;
          }

          v10 = v112;
        }
        else
        {
          v37 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v38 = NFLogGetLogger(v37);
          if (v38)
          {
            v39 = (void (*)(uint64_t, const char *, ...))v38;
            v40 = object_getClass(*(id *)(a1 + 32));
            v41 = class_isMetaClass(v40);
            v42 = object_getClassName(*(id *)(a1 + 32));
            v103 = sel_getName(*(SEL *)(a1 + 64));
            v43 = 45;
            if (v41)
              v43 = 43;
            v39(3, "%c[%{public}s %{public}s]:%i Missing packgeTag?!", v43, v42, v103, 1030);
          }
          v44 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v45 = NFSharedLogGetLogger(v44);
          v11 = objc_claimAutoreleasedReturnValue(v45);
          if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          {
            v46 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v46))
              v47 = 43;
            else
              v47 = 45;
            v48 = object_getClassName(*(id *)(a1 + 32));
            v49 = sel_getName(*(SEL *)(a1 + 64));
            *(_DWORD *)buf = 67109890;
            v123 = v47;
            v124 = 2082;
            v125 = v48;
            v126 = 2082;
            v127 = v49;
            v128 = 1024;
            v129 = 1030;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Missing packgeTag?!", buf, 0x22u);
          }
        }

        v7 = (char *)v7 + 1;
      }
      while (v7 != v5);
      v5 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v118, v135, 16);
    }
    while (v5);
  }

}

void sub_10017E530(id a1)
{
  uint64_t v1;
  void *v2;
  NFSecureTransactionServicesHandoverBaseSessionInterface *v3;

  v3 = -[NFSecureTransactionServicesHandoverBaseSessionInterface initWithProtocol:]([NFSecureTransactionServicesHandoverBaseSessionInterface alloc], "initWithProtocol:", &OBJC_PROTOCOL___NFSecureTransactionServicesHandoverBaseSessionInterface);
  v1 = objc_claimAutoreleasedReturnValue(-[NFSecureTransactionServicesHandoverBaseSessionInterface protocolInterface](v3, "protocolInterface"));
  v2 = (void *)qword_10032AA78;
  qword_10032AA78 = v1;

}

void sub_10017E658(id a1)
{
  uint64_t v1;
  void *v2;
  NFSecureTransactionServicesHandoverBaseSessionCallbacksInterface *v3;

  v3 = -[NFSecureTransactionServicesHandoverBaseSessionCallbacksInterface initWithProtocol:]([NFSecureTransactionServicesHandoverBaseSessionCallbacksInterface alloc], "initWithProtocol:", &OBJC_PROTOCOL___NFSecureTransactionServicesHandoverBaseSessionCallbacksInterface);
  v1 = objc_claimAutoreleasedReturnValue(-[NFSecureTransactionServicesHandoverBaseSessionCallbacksInterface protocolInterface](v3, "protocolInterface"));
  v2 = (void *)qword_10032AA88;
  qword_10032AA88 = v1;

}

id sub_10017E740(uint64_t a1, void *a2)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  id v7;

  if (!a1)
    return 0;
  v2 = *(void **)(a1 + 56);
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a2, "UID"));
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "objectForKey:", v3));

  v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "objectForKey:", CFSTR("type")));
  v6 = v5;
  if (v5)
    v7 = objc_msgSend(v5, "unsignedIntValue");
  else
    v7 = 0;

  return v7;
}

id sub_10017E7EC(uint64_t a1, void *a2)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  id v7;

  if (!a1)
    return 0;
  v2 = *(void **)(a1 + 56);
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a2, "UID"));
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "objectForKey:", v3));

  v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "objectForKey:", CFSTR("tagHandle")));
  v6 = v5;
  if (v5)
    v7 = objc_msgSend(v5, "pointerValue");
  else
    v7 = 0;

  return v7;
}

uint64_t sub_10017E9A4(void *a1, void *a2, _QWORD *a3)
{
  id v5;
  id v6;
  uint64_t v7;
  void *v9;
  void *specific;
  void (*Logger)(uint64_t, const char *, ...);
  objc_class *Class;
  uint64_t v13;
  const char *ClassName;
  const char *Name;
  void *v16;
  uint64_t v17;
  NSObject *v18;
  objc_class *v19;
  int v20;
  uint64_t v21;
  id v22;
  int v23;
  void *v24;
  void (*v25)(uint64_t, const char *, ...);
  objc_class *v26;
  uint64_t v27;
  const char *v28;
  const char *v29;
  void *v30;
  uint64_t v31;
  NSObject *v32;
  objc_class *v33;
  int v34;
  const char *v35;
  const char *v36;
  void *v37;
  dispatch_semaphore_t v38;
  void *v39;
  uint8_t buf[4];
  int v41;
  __int16 v42;
  const char *v43;
  __int16 v44;
  const char *v45;
  __int16 v46;
  int v47;
  __int16 v48;
  id v49;

  v5 = a2;
  if (a1)
  {
    v6 = a1;
    objc_sync_enter(v6);
    if (*((_BYTE *)v6 + 137))
    {
      v7 = 3;
    }
    else
    {
      v9 = malloc_type_calloc(1uLL, 0x60uLL, 0x108004063299CC8uLL);
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(specific);
      if (Logger)
      {
        Class = object_getClass(v6);
        if (class_isMetaClass(Class))
          v13 = 43;
        else
          v13 = 45;
        ClassName = object_getClassName(v6);
        Name = sel_getName("connectTag:updatedTag:");
        Logger(6, "%c[%{public}s %{public}s]:%i Connecting to tag: %{public}@", v13, ClassName, Name, 93, v5);
      }
      v16 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v17 = NFSharedLogGetLogger(v16);
      v18 = objc_claimAutoreleasedReturnValue(v17);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        v19 = object_getClass(v6);
        if (class_isMetaClass(v19))
          v20 = 43;
        else
          v20 = 45;
        *(_DWORD *)buf = 67110146;
        v41 = v20;
        v42 = 2082;
        v43 = object_getClassName(v6);
        v44 = 2082;
        v45 = sel_getName("connectTag:updatedTag:");
        v46 = 1024;
        v47 = 93;
        v48 = 2114;
        v49 = v5;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Connecting to tag: %{public}@", buf, 0x2Cu);
      }

      v21 = *((_QWORD *)v6 + 5);
      v22 = sub_10017E7EC((uint64_t)v6, v5);
      v23 = NFDriverRemoteDevConnect(v21, v22, v9);
      if (v23)
      {
        v24 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v25 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v24);
        if (v25)
        {
          v26 = object_getClass(v6);
          if (class_isMetaClass(v26))
            v27 = 43;
          else
            v27 = 45;
          v28 = object_getClassName(v6);
          v29 = sel_getName("connectTag:updatedTag:");
          v25(3, "%c[%{public}s %{public}s]:%i Failed to connect to tag: %{public}@", v27, v28, v29, 100, v5);
        }
        v30 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v31 = NFSharedLogGetLogger(v30);
        v32 = objc_claimAutoreleasedReturnValue(v31);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        {
          v33 = object_getClass(v6);
          if (class_isMetaClass(v33))
            v34 = 43;
          else
            v34 = 45;
          v35 = object_getClassName(v6);
          v36 = sel_getName("connectTag:updatedTag:");
          *(_DWORD *)buf = 67110146;
          v41 = v34;
          v42 = 2082;
          v43 = v35;
          v44 = 2082;
          v45 = v36;
          v46 = 1024;
          v47 = 100;
          v48 = 2114;
          v49 = v5;
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to connect to tag: %{public}@", buf, 0x2Cu);
        }

        if (v9)
          free(v9);
        switch(v23)
        {
          case 4:
            v7 = 35;
            break;
          case 18:
            v7 = 51;
            break;
          case 23:
            v7 = 64;
            break;
          default:
            v7 = 28;
            break;
        }
      }
      else
      {
        if (a3)
          *a3 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "_refreshTagInfo:update:", v5, v9));
        if (v9)
          free(v9);
        v37 = (void *)*((_QWORD *)v6 + 6);
        *((_QWORD *)v6 + 6) = 0;

        if (objc_msgSend(v6, "_isEMVPolling"))
        {
          v38 = dispatch_semaphore_create(0);
          v39 = (void *)*((_QWORD *)v6 + 6);
          *((_QWORD *)v6 + 6) = v38;

        }
        v7 = 0;
      }
    }
    objc_sync_exit(v6);

  }
  else
  {
    v7 = 0;
  }

  return v7;
}

void sub_10017ED8C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10017EF78(void *a1, void *a2, uint64_t a3)
{
  id v5;
  id v6;
  uint64_t v7;
  void *specific;
  void (*Logger)(uint64_t, const char *, ...);
  objc_class *Class;
  uint64_t v11;
  const char *ClassName;
  const char *Name;
  void *v14;
  uint64_t v15;
  NSObject *v16;
  objc_class *v17;
  int v18;
  uint64_t v19;
  id v20;
  int v21;
  uint64_t v22;
  id v23;
  dispatch_time_t v24;
  void *v25;
  void (*v26)(uint64_t, const char *, ...);
  objc_class *v27;
  uint64_t v28;
  const char *v29;
  const char *v30;
  void *v31;
  uint64_t v32;
  NSObject *v33;
  objc_class *v34;
  int v35;
  const char *v36;
  const char *v37;
  void *v38;
  void (*v39)(uint64_t, const char *, ...);
  objc_class *v40;
  uint64_t v41;
  const char *v42;
  const char *v43;
  void *v44;
  uint64_t v45;
  NSObject *v46;
  objc_class *v47;
  int v48;
  const char *v49;
  const char *v50;
  id v51;
  uint8_t buf[4];
  int v54;
  __int16 v55;
  const char *v56;
  __int16 v57;
  const char *v58;
  __int16 v59;
  int v60;
  __int16 v61;
  id v62;
  __int16 v63;
  int v64;

  v5 = a2;
  if (a1)
  {
    v6 = a1;
    objc_sync_enter(v6);
    if (*((_BYTE *)v6 + 137))
    {
      v7 = 3;
    }
    else
    {
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(specific);
      if (Logger)
      {
        Class = object_getClass(v6);
        if (class_isMetaClass(Class))
          v11 = 43;
        else
          v11 = 45;
        ClassName = object_getClassName(v6);
        Name = sel_getName("disconnectTag:tagRemovalDetect:");
        Logger(6, "%c[%{public}s %{public}s]:%i disconnecting from tag: %{public}@, tagRemovalDetect=%d", v11, ClassName, Name, 157, v5, a3);
      }
      v14 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v15 = NFSharedLogGetLogger(v14);
      v16 = objc_claimAutoreleasedReturnValue(v15);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        v17 = object_getClass(v6);
        if (class_isMetaClass(v17))
          v18 = 43;
        else
          v18 = 45;
        *(_DWORD *)buf = 67110402;
        v54 = v18;
        v55 = 2082;
        v56 = object_getClassName(v6);
        v57 = 2082;
        v58 = sel_getName("disconnectTag:tagRemovalDetect:");
        v59 = 1024;
        v60 = 157;
        v61 = 2114;
        v62 = v5;
        v63 = 1024;
        v64 = a3;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i disconnecting from tag: %{public}@, tagRemovalDetect=%d", buf, 0x32u);
      }

      if ((*((_QWORD *)v6 + 34) & 0x8000000) != 0
        || (v19 = *((_QWORD *)v6 + 5),
            v20 = sub_10017E7EC((uint64_t)v6, v5),
            v21 = NFDriverRemoteDevDisconnect(v19, v20, a3),
            v21 == 19))
      {
        objc_msgSend(v6, "_cardRemovalDetect:", v5);
        v22 = *((_QWORD *)v6 + 5);
        v23 = sub_10017E7EC((uint64_t)v6, v5);
        v21 = NFDriverRemoteDevDisconnect(v22, v23, 0);
      }
      if (!(_DWORD)a3 || v21)
      {
        v7 = 0;
        if (v21 && v21 != 6)
        {
          v38 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v39 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v38);
          if (v39)
          {
            v40 = object_getClass(v6);
            if (class_isMetaClass(v40))
              v41 = 43;
            else
              v41 = 45;
            v42 = object_getClassName(v6);
            v43 = sel_getName("disconnectTag:tagRemovalDetect:");
            v39(3, "%c[%{public}s %{public}s]:%i Failed to disconnect tag: %{public}@", v41, v42, v43, 186, v5);
          }
          v44 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v45 = NFSharedLogGetLogger(v44);
          v46 = objc_claimAutoreleasedReturnValue(v45);
          if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
          {
            v47 = object_getClass(v6);
            if (class_isMetaClass(v47))
              v48 = 43;
            else
              v48 = 45;
            v49 = object_getClassName(v6);
            v50 = sel_getName("disconnectTag:tagRemovalDetect:");
            *(_DWORD *)buf = 67110146;
            v54 = v48;
            v55 = 2082;
            v56 = v49;
            v57 = 2082;
            v58 = v50;
            v59 = 1024;
            v60 = 186;
            v61 = 2114;
            v62 = v5;
            _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to disconnect tag: %{public}@", buf, 0x2Cu);
          }

          if (v21 == 18)
            v7 = 51;
          else
            v7 = 15;
        }
      }
      else
      {
        if (*((_QWORD *)v6 + 6))
        {
          if (objc_msgSend(v6, "_isEMVPolling"))
          {
            v24 = dispatch_time(0, 300000000000);
            if (dispatch_semaphore_wait(*((dispatch_semaphore_t *)v6 + 6), v24))
            {
              v25 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v26 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v25);
              if (v26)
              {
                v27 = object_getClass(v6);
                if (class_isMetaClass(v27))
                  v28 = 43;
                else
                  v28 = 45;
                v29 = object_getClassName(v6);
                v30 = sel_getName("disconnectTag:tagRemovalDetect:");
                v26(3, "%c[%{public}s %{public}s]:%i Timeout on tag remove", v28, v29, v30, 181);
              }
              v31 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v32 = NFSharedLogGetLogger(v31);
              v33 = objc_claimAutoreleasedReturnValue(v32);
              if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
              {
                v34 = object_getClass(v6);
                if (class_isMetaClass(v34))
                  v35 = 43;
                else
                  v35 = 45;
                v36 = object_getClassName(v6);
                v37 = sel_getName("disconnectTag:tagRemovalDetect:");
                *(_DWORD *)buf = 67109890;
                v54 = v35;
                v55 = 2082;
                v56 = v36;
                v57 = 2082;
                v58 = v37;
                v59 = 1024;
                v60 = 181;
                _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Timeout on tag remove", buf, 0x22u);
              }

            }
          }
        }
        v7 = 0;
      }
      if ((_DWORD)a3)
      {
        sub_1001D16D8(*((_BYTE **)v6 + 10), 0);
        if (objc_msgSend(*((id *)v6 + 11), "readerModeStoppedShouldCooloffRun"))
          v51 = sub_1001F84C8(v6, CFSTR("Cooloff"), 1uLL);
      }
    }
    objc_sync_exit(v6);

  }
  else
  {
    v7 = 0;
  }

  return v7;
}

void sub_10017F494(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10017F4D4(void *a1, void *a2, uint64_t *a3, uint64_t a4)
{
  id v7;
  id v8;
  id v9;
  NSObject *v10;
  void *v11;
  id v12;
  id v13;
  void *v14;
  id v15;
  uint64_t v16;
  id v17;
  int v18;
  void *v19;
  void (*v20)(uint64_t, const char *, ...);
  objc_class *v21;
  uint64_t v22;
  const char *v23;
  const char *v24;
  void *v25;
  uint64_t v26;
  NSObject *v27;
  objc_class *v28;
  int v29;
  id v30;
  void *specific;
  void (*Logger)(uint64_t, const char *, ...);
  objc_class *Class;
  uint64_t v34;
  const char *ClassName;
  const char *Name;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  id v41;
  void *v42;
  uint64_t v43;
  objc_class *v44;
  int v45;
  const char *v46;
  const char *v47;
  int v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  id v53;
  id v54;
  id v55;
  id v56;
  id v57;
  uint8_t buf[4];
  int v59;
  __int16 v60;
  const char *v61;
  __int16 v62;
  const char *v63;
  __int16 v64;
  int v65;
  __int16 v66;
  int v67;
  __int16 v68;
  int v69;
  __int16 v70;
  uint64_t v71;
  __int16 v72;
  uint64_t v73;
  __int16 v74;
  id v75;
  _QWORD v76[4];
  _QWORD v77[4];
  _QWORD v78[4];
  _QWORD v79[4];
  _QWORD v80[4];
  _QWORD v81[4];
  _QWORD v82[4];
  _QWORD v83[4];
  _QWORD v84[4];
  _QWORD v85[4];
  _QWORD v86[4];
  _QWORD v87[4];
  _QWORD v88[4];
  _QWORD v89[4];
  _QWORD v90[4];
  _QWORD v91[4];

  v7 = a2;
  if (!a1)
  {
    a4 = 0;
    goto LABEL_44;
  }
  v8 = a1;
  objc_sync_enter(v8);
  if (!*((_BYTE *)v8 + 137))
  {
    v16 = *((_QWORD *)v8 + 5);
    v17 = sub_10017E7EC((uint64_t)v8, v7);
    v18 = NFDriverRemoteDevCheckNdef(v16, v17, a3);
    if (!v18)
    {
      if (a4)
        *(_QWORD *)a4 = 0;
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(specific);
      if (Logger)
      {
        Class = object_getClass(v8);
        if (class_isMetaClass(Class))
          v34 = 43;
        else
          v34 = 45;
        ClassName = object_getClassName(v8);
        Name = sel_getName("queryTagNDEFCapability:hasNdefAbility:error:");
        if (a3)
        {
          v37 = *((unsigned __int8 *)a3 + 16);
          v38 = *((unsigned __int8 *)a3 + 17);
          v40 = *a3;
          v39 = a3[1];
        }
        else
        {
          v39 = 0;
          v37 = 0;
          v38 = 0;
          v40 = 0;
        }
        Logger(6, "%c[%{public}s %{public}s]:%i read=%d write=%d capacity=%lu, messageSize=%lu tag=%{public}@", v34, ClassName, Name, 239, v37, v38, v39, v40, v7);
      }
      v42 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v43 = NFSharedLogGetLogger(v42);
      v10 = objc_claimAutoreleasedReturnValue(v43);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        v44 = object_getClass(v8);
        if (class_isMetaClass(v44))
          v45 = 43;
        else
          v45 = 45;
        v46 = object_getClassName(v8);
        v47 = sel_getName("queryTagNDEFCapability:hasNdefAbility:error:");
        if (a3)
        {
          v48 = *((unsigned __int8 *)a3 + 16);
          v49 = *((unsigned __int8 *)a3 + 17);
          v51 = *a3;
          v50 = a3[1];
        }
        else
        {
          v50 = 0;
          v48 = 0;
          v49 = 0;
          v51 = 0;
        }
        *(_DWORD *)buf = 67111170;
        v59 = v45;
        v60 = 2082;
        v61 = v46;
        v62 = 2082;
        v63 = v47;
        v64 = 1024;
        v65 = 239;
        v66 = 1024;
        v67 = v48;
        v68 = 1024;
        v69 = v49;
        v70 = 2048;
        v71 = v50;
        v72 = 2048;
        v73 = v51;
        v74 = 2114;
        v75 = v7;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i read=%d write=%d capacity=%lu, messageSize=%lu tag=%{public}@", buf, 0x4Cu);
      }
      a4 = 1;
      goto LABEL_42;
    }
    v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v20 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v19);
    if (v20)
    {
      v21 = object_getClass(v8);
      if (class_isMetaClass(v21))
        v22 = 43;
      else
        v22 = 45;
      v23 = object_getClassName(v8);
      v24 = sel_getName("queryTagNDEFCapability:hasNdefAbility:error:");
      v20(3, "%c[%{public}s %{public}s]:%i Failed to perform Ndef check", v22, v23, v24, 211);
    }
    v25 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v26 = NFSharedLogGetLogger(v25);
    v27 = objc_claimAutoreleasedReturnValue(v26);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      v28 = object_getClass(v8);
      if (class_isMetaClass(v28))
        v29 = 43;
      else
        v29 = 45;
      *(_DWORD *)buf = 67109890;
      v59 = v29;
      v60 = 2082;
      v61 = object_getClassName(v8);
      v62 = 2082;
      v63 = sel_getName("queryTagNDEFCapability:hasNdefAbility:error:");
      v64 = 1024;
      v65 = 211;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to perform Ndef check", buf, 0x22u);
    }

    if (!a4)
      goto LABEL_43;
    switch(v18)
    {
      case 4:
        v30 = objc_alloc((Class)NSError);
        v10 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v78[0] = NSLocalizedDescriptionKey;
        v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "SE not available"));
        v79[0] = v11;
        v79[1] = &off_1003001B8;
        v78[1] = CFSTR("Line");
        v78[2] = CFSTR("Method");
        v12 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("queryTagNDEFCapability:hasNdefAbility:error:"));
        v79[2] = v12;
        v78[3] = NSDebugDescriptionErrorKey;
        v13 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("queryTagNDEFCapability:hasNdefAbility:error:"), 224);
        v79[3] = v13;
        v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v79, v78, 4));
        v15 = objc_msgSend(v30, "initWithDomain:code:userInfo:", v10, 35, v14);
        break;
      case 5:
        v54 = objc_alloc((Class)NSError);
        v10 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v86[0] = NSLocalizedDescriptionKey;
        v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid Parameter"));
        v87[0] = v11;
        v87[1] = &off_100300158;
        v86[1] = CFSTR("Line");
        v86[2] = CFSTR("Method");
        v12 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("queryTagNDEFCapability:hasNdefAbility:error:"));
        v87[2] = v12;
        v86[3] = NSDebugDescriptionErrorKey;
        v13 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("queryTagNDEFCapability:hasNdefAbility:error:"), 216);
        v87[3] = v13;
        v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v87, v86, 4));
        v15 = objc_msgSend(v54, "initWithDomain:code:userInfo:", v10, 10, v14);
        break;
      case 6:
        v55 = objc_alloc((Class)NSError);
        v10 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v88[0] = NSLocalizedDescriptionKey;
        v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Tag Not Found"));
        v89[0] = v11;
        v89[1] = &off_100300140;
        v88[1] = CFSTR("Line");
        v88[2] = CFSTR("Method");
        v12 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("queryTagNDEFCapability:hasNdefAbility:error:"));
        v89[2] = v12;
        v88[3] = NSDebugDescriptionErrorKey;
        v13 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("queryTagNDEFCapability:hasNdefAbility:error:"), 214);
        v89[3] = v13;
        v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v89, v88, 4));
        v15 = objc_msgSend(v55, "initWithDomain:code:userInfo:", v10, 28, v14);
        break;
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
        goto LABEL_45;
      case 12:
        v56 = objc_alloc((Class)NSError);
        v10 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v84[0] = NSLocalizedDescriptionKey;
        v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Tag Not NDEF formatted"));
        v85[0] = v11;
        v85[1] = &off_100300170;
        v84[1] = CFSTR("Line");
        v84[2] = CFSTR("Method");
        v12 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("queryTagNDEFCapability:hasNdefAbility:error:"));
        v85[2] = v12;
        v84[3] = NSDebugDescriptionErrorKey;
        v13 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("queryTagNDEFCapability:hasNdefAbility:error:"), 218);
        v85[3] = v13;
        v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v85, v84, 4));
        v15 = objc_msgSend(v56, "initWithDomain:code:userInfo:", v10, 37, v14);
        break;
      default:
        if (v18 == 18)
        {
          v57 = objc_alloc((Class)NSError);
          v10 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
          v82[0] = NSLocalizedDescriptionKey;
          v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "RF Deactivated"));
          v83[0] = v11;
          v83[1] = &off_100300188;
          v82[1] = CFSTR("Line");
          v82[2] = CFSTR("Method");
          v12 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("queryTagNDEFCapability:hasNdefAbility:error:"));
          v83[2] = v12;
          v82[3] = NSDebugDescriptionErrorKey;
          v13 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("queryTagNDEFCapability:hasNdefAbility:error:"), 220);
          v83[3] = v13;
          v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v83, v82, 4));
          v15 = objc_msgSend(v57, "initWithDomain:code:userInfo:", v10, 51, v14);
        }
        else if (v18 == 23)
        {
          v41 = objc_alloc((Class)NSError);
          v10 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
          v80[0] = NSLocalizedDescriptionKey;
          v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Reader mode prohibit timer"));
          v81[0] = v11;
          v81[1] = &off_1003001A0;
          v80[1] = CFSTR("Line");
          v80[2] = CFSTR("Method");
          v12 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("queryTagNDEFCapability:hasNdefAbility:error:"));
          v81[2] = v12;
          v80[3] = NSDebugDescriptionErrorKey;
          v13 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("queryTagNDEFCapability:hasNdefAbility:error:"), 222);
          v81[3] = v13;
          v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v81, v80, 4));
          v15 = objc_msgSend(v41, "initWithDomain:code:userInfo:", v10, 64, v14);
        }
        else
        {
LABEL_45:
          v53 = objc_alloc((Class)NSError);
          v10 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
          v76[0] = NSLocalizedDescriptionKey;
          v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
          v77[0] = v11;
          v77[1] = &off_1003001D0;
          v76[1] = CFSTR("Line");
          v76[2] = CFSTR("Method");
          v12 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("queryTagNDEFCapability:hasNdefAbility:error:"));
          v77[2] = v12;
          v76[3] = NSDebugDescriptionErrorKey;
          v13 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("queryTagNDEFCapability:hasNdefAbility:error:"), 226);
          v77[3] = v13;
          v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v77, v76, 4));
          v15 = objc_msgSend(v53, "initWithDomain:code:userInfo:", v10, 15, v14);
        }
        break;
    }
LABEL_5:
    *(_QWORD *)a4 = v15;

    a4 = 0;
LABEL_42:

    goto LABEL_43;
  }
  if (a4)
  {
    v9 = objc_alloc((Class)NSError);
    v10 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v90[0] = NSLocalizedDescriptionKey;
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Aborted"));
    v91[0] = v11;
    v91[1] = &off_100300128;
    v90[1] = CFSTR("Line");
    v90[2] = CFSTR("Method");
    v12 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("queryTagNDEFCapability:hasNdefAbility:error:"));
    v91[2] = v12;
    v90[3] = NSDebugDescriptionErrorKey;
    v13 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("queryTagNDEFCapability:hasNdefAbility:error:"), 205);
    v91[3] = v13;
    v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v91, v90, 4));
    v15 = objc_msgSend(v9, "initWithDomain:code:userInfo:", v10, 3, v14);
    goto LABEL_5;
  }
LABEL_43:
  objc_sync_exit(v8);

LABEL_44:
  return a4;
}

void sub_1001801C0(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

unint64_t sub_1001801F8(void *a1, void *a2, unint64_t a3)
{
  id v5;
  uint64_t v6;
  id v7;
  id v8;
  void *v9;
  void *v10;
  id v11;
  id v12;
  void *v13;
  void *v14;
  uint64_t v15;
  void (*v16)(uint64_t, const char *, ...);
  objc_class *v17;
  _BOOL4 isMetaClass;
  const char *v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  NSObject *v23;
  objc_class *v24;
  int v25;
  id v26;
  void *v27;
  id v28;
  id v29;
  void *v30;
  uint64_t v31;
  id v32;
  int MiFareInfo;
  void *specific;
  void (*Logger)(uint64_t, const char *, ...);
  objc_class *Class;
  uint64_t v37;
  const char *ClassName;
  const char *Name;
  void *v40;
  uint64_t v41;
  NSObject *v42;
  objc_class *v43;
  int v44;
  id v45;
  void *v46;
  void *v47;
  id v48;
  id v49;
  void *v50;
  id v51;
  id v52;
  id v53;
  const char *v55;
  _QWORD v56[4];
  _QWORD v57[4];
  _QWORD v58[4];
  _QWORD v59[4];
  _QWORD v60[4];
  _QWORD v61[4];
  _QWORD v62[4];
  _QWORD v63[4];
  uint8_t v64[4];
  int v65;
  __int16 v66;
  const char *v67;
  __int16 v68;
  const char *v69;
  __int16 v70;
  int v71;
  uint8_t buf[48];
  uint64_t v73;
  _QWORD v74[4];
  _QWORD v75[4];
  _QWORD v76[4];
  _QWORD v77[4];

  v5 = a2;
  if (!a1)
  {
    a3 = 0;
    goto LABEL_43;
  }
  v6 = objc_opt_class(NFTagInternal);
  if ((objc_opt_isKindOfClass(v5, v6) & 1) != 0)
  {
    v7 = a1;
    objc_sync_enter(v7);
    if (*((_BYTE *)v7 + 137))
    {
      if (!a3)
      {
LABEL_41:
        objc_sync_exit(v7);
        goto LABEL_42;
      }
      v8 = objc_alloc((Class)NSError);
      v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v74[0] = NSLocalizedDescriptionKey;
      v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Aborted"));
      v75[0] = v10;
      v75[1] = &off_100300200;
      v74[1] = CFSTR("Line");
      v74[2] = CFSTR("Method");
      v11 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("queryMifareTagCapability:error:"));
      v75[2] = v11;
      v74[3] = NSDebugDescriptionErrorKey;
      v12 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("queryMifareTagCapability:error:"), 255);
      v75[3] = v12;
      v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v75, v74, 4));
      *(_QWORD *)a3 = objc_msgSend(v8, "initWithDomain:code:userInfo:", v9, 3, v13);

    }
    else
    {
      v73 = 0;
      memset(buf, 0, sizeof(buf));
      v31 = *((_QWORD *)v7 + 5);
      v32 = sub_10017E7EC((uint64_t)v7, v5);
      MiFareInfo = NFDriverRemoteDevGetMiFareInfo(v31, v32, buf);
      if (!MiFareInfo)
      {
        if ((*(_DWORD *)buf - 1) >= 4)
          a3 = 0;
        else
          a3 = (*(_DWORD *)buf + 12);
        goto LABEL_41;
      }
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(specific);
      if (Logger)
      {
        Class = object_getClass(v7);
        if (class_isMetaClass(Class))
          v37 = 43;
        else
          v37 = 45;
        ClassName = object_getClassName(v7);
        Name = sel_getName("queryMifareTagCapability:error:");
        Logger(3, "%c[%{public}s %{public}s]:%i Failed to query MIFARE info", v37, ClassName, Name, 262);
      }
      v40 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v41 = NFSharedLogGetLogger(v40);
      v42 = objc_claimAutoreleasedReturnValue(v41);
      if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
      {
        v43 = object_getClass(v7);
        if (class_isMetaClass(v43))
          v44 = 43;
        else
          v44 = 45;
        *(_DWORD *)v64 = 67109890;
        v65 = v44;
        v66 = 2082;
        v67 = object_getClassName(v7);
        v68 = 2082;
        v69 = sel_getName("queryMifareTagCapability:error:");
        v70 = 1024;
        v71 = 262;
        _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to query MIFARE info", v64, 0x22u);
      }

      if (!a3)
        goto LABEL_41;
      if (MiFareInfo == 4)
      {
        v52 = objc_alloc((Class)NSError);
        v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v58[0] = NSLocalizedDescriptionKey;
        v47 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "SE not available"));
        v59[0] = v47;
        v59[1] = &off_100300248;
        v58[1] = CFSTR("Line");
        v58[2] = CFSTR("Method");
        v48 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("queryMifareTagCapability:error:"));
        v59[2] = v48;
        v58[3] = NSDebugDescriptionErrorKey;
        v49 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("queryMifareTagCapability:error:"), 269);
        v59[3] = v49;
        v50 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v59, v58, 4));
        v51 = objc_msgSend(v52, "initWithDomain:code:userInfo:", v46, 35, v50);
      }
      else if (MiFareInfo == 23)
      {
        v53 = objc_alloc((Class)NSError);
        v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v60[0] = NSLocalizedDescriptionKey;
        v47 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Reader mode prohibit timer"));
        v61[0] = v47;
        v61[1] = &off_100300230;
        v60[1] = CFSTR("Line");
        v60[2] = CFSTR("Method");
        v48 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("queryMifareTagCapability:error:"));
        v61[2] = v48;
        v60[3] = NSDebugDescriptionErrorKey;
        v49 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("queryMifareTagCapability:error:"), 267);
        v61[3] = v49;
        v50 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v61, v60, 4));
        v51 = objc_msgSend(v53, "initWithDomain:code:userInfo:", v46, 64, v50);
      }
      else
      {
        v45 = objc_alloc((Class)NSError);
        if (MiFareInfo == 18)
        {
          v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
          v62[0] = NSLocalizedDescriptionKey;
          v47 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "RF Deactivated"));
          v63[0] = v47;
          v63[1] = &off_100300218;
          v62[1] = CFSTR("Line");
          v62[2] = CFSTR("Method");
          v48 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("queryMifareTagCapability:error:"));
          v63[2] = v48;
          v62[3] = NSDebugDescriptionErrorKey;
          v49 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("queryMifareTagCapability:error:"), 265);
          v63[3] = v49;
          v50 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v63, v62, 4));
          v51 = objc_msgSend(v45, "initWithDomain:code:userInfo:", v46, 51, v50);
        }
        else
        {
          v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
          v56[0] = NSLocalizedDescriptionKey;
          v47 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
          v57[0] = v47;
          v57[1] = &off_100300260;
          v56[1] = CFSTR("Line");
          v56[2] = CFSTR("Method");
          v48 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("queryMifareTagCapability:error:"));
          v57[2] = v48;
          v56[3] = NSDebugDescriptionErrorKey;
          v49 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("queryMifareTagCapability:error:"), 271);
          v57[3] = v49;
          v50 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v57, v56, 4));
          v51 = objc_msgSend(v45, "initWithDomain:code:userInfo:", v46, 15, v50);
        }
      }
      *(_QWORD *)a3 = v51;

    }
    a3 = 0;
    goto LABEL_41;
  }
  v14 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v15 = NFLogGetLogger(v14);
  if (v15)
  {
    v16 = (void (*)(uint64_t, const char *, ...))v15;
    v17 = object_getClass(a1);
    isMetaClass = class_isMetaClass(v17);
    v19 = object_getClassName(a1);
    v55 = sel_getName("queryMifareTagCapability:error:");
    v20 = 45;
    if (isMetaClass)
      v20 = 43;
    v16(3, "%c[%{public}s %{public}s]:%i Invalid tag parameter", v20, v19, v55, 248);
  }
  v21 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v22 = NFSharedLogGetLogger(v21);
  v23 = objc_claimAutoreleasedReturnValue(v22);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
  {
    v24 = object_getClass(a1);
    if (class_isMetaClass(v24))
      v25 = 43;
    else
      v25 = 45;
    *(_DWORD *)buf = 67109890;
    *(_DWORD *)&buf[4] = v25;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = object_getClassName(a1);
    *(_WORD *)&buf[18] = 2082;
    *(_QWORD *)&buf[20] = sel_getName("queryMifareTagCapability:error:");
    *(_WORD *)&buf[28] = 1024;
    *(_DWORD *)&buf[30] = 248;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid tag parameter", buf, 0x22u);
  }

  if (a3)
  {
    v26 = objc_alloc((Class)NSError);
    v7 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v76[0] = NSLocalizedDescriptionKey;
    v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid Parameter"));
    v77[0] = v27;
    v77[1] = &off_1003001E8;
    v76[1] = CFSTR("Line");
    v76[2] = CFSTR("Method");
    v28 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("queryMifareTagCapability:error:"));
    v77[2] = v28;
    v76[3] = NSDebugDescriptionErrorKey;
    v29 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("queryMifareTagCapability:error:"), 249);
    v77[3] = v29;
    v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v77, v76, 4));
    *(_QWORD *)a3 = objc_msgSend(v26, "initWithDomain:code:userInfo:", v7, 10, v30);

    a3 = 0;
LABEL_42:

  }
LABEL_43:

  return a3;
}

void sub_100180C80(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_100180CAC(void *a1, void *a2, unsigned int a3, _QWORD *a4)
{
  id v7;
  id v8;
  id v9;
  void *v10;
  void *v11;
  id v12;
  id v13;
  void *v14;
  void *specific;
  void (*Logger)(uint64_t, const char *, ...);
  objc_class *Class;
  uint64_t v18;
  const char *ClassName;
  const char *Name;
  void *v21;
  uint64_t v22;
  NSObject *v23;
  objc_class *v24;
  int v25;
  id v26;
  void *v27;
  void *v28;
  id v29;
  id v30;
  void *v31;
  uint64_t v32;
  id v33;
  uint64_t v34;
  void *v35;
  void (*v36)(uint64_t, const char *, ...);
  objc_class *v37;
  uint64_t v38;
  const char *v39;
  const char *v40;
  void *v41;
  uint64_t v42;
  NSObject *v43;
  objc_class *v44;
  int v45;
  const char *v46;
  const char *v47;
  id v48;
  void *v49;
  void *v50;
  id v51;
  id v52;
  void *v53;
  id v54;
  void *v55;
  void (*v56)(uint64_t, const char *, ...);
  objc_class *v57;
  uint64_t v58;
  const char *v59;
  const char *v60;
  void *v61;
  uint64_t v62;
  NSObject *v63;
  objc_class *v64;
  int v65;
  id v66;
  void *v67;
  void *v68;
  id v69;
  id v70;
  void *v71;
  id v72;
  void *v73;
  void *v74;
  id v75;
  id v76;
  void *v77;
  id v79;
  void *v80;
  void (*v81)(uint64_t, const char *, ...);
  objc_class *v82;
  uint64_t v83;
  const char *v84;
  const char *v85;
  void *v86;
  uint64_t v87;
  NSObject *v88;
  objc_class *v89;
  int v90;
  const char *v91;
  const char *v92;
  id v93;
  id v94;
  id v95;
  id v96;
  id v97;
  id v98;
  id v99;
  _QWORD *v100;
  unsigned int v101;
  _QWORD v102[4];
  _QWORD v103[4];
  _QWORD v104[4];
  _QWORD v105[4];
  _QWORD v106[4];
  _QWORD v107[4];
  _QWORD v108[4];
  _QWORD v109[4];
  _QWORD v110[4];
  _QWORD v111[4];
  _QWORD v112[4];
  _QWORD v113[4];
  _QWORD v114[4];
  _QWORD v115[4];
  _QWORD v116[4];
  _QWORD v117[4];
  _QWORD v118[4];
  _QWORD v119[4];
  uint8_t buf[4];
  int v121;
  __int16 v122;
  const char *v123;
  __int16 v124;
  const char *v125;
  __int16 v126;
  int v127;
  __int16 v128;
  id v129;
  __int16 v130;
  int v131;
  _QWORD v132[4];
  _QWORD v133[4];
  _QWORD v134[4];
  _QWORD v135[4];
  _QWORD v136[4];
  _QWORD v137[4];

  v7 = a2;
  if (!a1)
  {
    a4 = 0;
    goto LABEL_52;
  }
  v8 = a1;
  objc_sync_enter(v8);
  if (*((_BYTE *)v8 + 137))
  {
    if (a4)
    {
      v9 = objc_alloc((Class)NSError);
      v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v136[0] = NSLocalizedDescriptionKey;
      v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Aborted"));
      v137[0] = v11;
      v137[1] = &off_100300278;
      v136[1] = CFSTR("Line");
      v136[2] = CFSTR("Method");
      v12 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("readNdefDataFromTag:messageSize:error:"));
      v137[2] = v12;
      v136[3] = NSDebugDescriptionErrorKey;
      v13 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("readNdefDataFromTag:messageSize:error:"), 301);
      v137[3] = v13;
      v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v137, v136, 4));
      *a4 = objc_msgSend(v9, "initWithDomain:code:userInfo:", v10, 3, v14);

LABEL_50:
      a4 = 0;
      goto LABEL_51;
    }
    goto LABEL_51;
  }
  if (a3 > 0x8000)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(specific);
    if (Logger)
    {
      Class = object_getClass(v8);
      if (class_isMetaClass(Class))
        v18 = 43;
      else
        v18 = 45;
      ClassName = object_getClassName(v8);
      Name = sel_getName("readNdefDataFromTag:messageSize:error:");
      Logger(5, "%c[%{public}s %{public}s]:%i NDEF message size is over the read limit", v18, ClassName, Name, 307);
    }
    v21 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v22 = NFSharedLogGetLogger(v21);
    v23 = objc_claimAutoreleasedReturnValue(v22);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      v24 = object_getClass(v8);
      if (class_isMetaClass(v24))
        v25 = 43;
      else
        v25 = 45;
      *(_DWORD *)buf = 67109890;
      v121 = v25;
      v122 = 2082;
      v123 = object_getClassName(v8);
      v124 = 2082;
      v125 = sel_getName("readNdefDataFromTag:messageSize:error:");
      v126 = 1024;
      v127 = 307;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i NDEF message size is over the read limit", buf, 0x22u);
    }

    if (!a4)
      goto LABEL_51;
    v26 = objc_alloc((Class)NSError);
    v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v134[0] = NSLocalizedDescriptionKey;
    v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "NDEF message size is over the limit"));
    v135[0] = v28;
    v135[1] = &off_100300290;
    v134[1] = CFSTR("Line");
    v134[2] = CFSTR("Method");
    v29 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("readNdefDataFromTag:messageSize:error:"));
    v135[2] = v29;
    v134[3] = NSDebugDescriptionErrorKey;
    v30 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("readNdefDataFromTag:messageSize:error:"), 308);
    v135[3] = v30;
    v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v135, v134, 4));
    *a4 = objc_msgSend(v26, "initWithDomain:code:userInfo:", v27, 43, v31);

    goto LABEL_50;
  }
  if (!a3)
  {
    v55 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v56 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v55);
    if (v56)
    {
      v57 = object_getClass(v8);
      if (class_isMetaClass(v57))
        v58 = 43;
      else
        v58 = 45;
      v59 = object_getClassName(v8);
      v60 = sel_getName("readNdefDataFromTag:messageSize:error:");
      v56(5, "%c[%{public}s %{public}s]:%i zero-length message", v58, v59, v60, 311);
    }
    v61 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v62 = NFSharedLogGetLogger(v61);
    v63 = objc_claimAutoreleasedReturnValue(v62);
    if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
    {
      v64 = object_getClass(v8);
      if (class_isMetaClass(v64))
        v65 = 43;
      else
        v65 = 45;
      *(_DWORD *)buf = 67109890;
      v121 = v65;
      v122 = 2082;
      v123 = object_getClassName(v8);
      v124 = 2082;
      v125 = sel_getName("readNdefDataFromTag:messageSize:error:");
      v126 = 1024;
      v127 = 311;
      _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i zero-length message", buf, 0x22u);
    }

    if (!a4)
      goto LABEL_51;
    v66 = objc_alloc((Class)NSError);
    v67 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v132[0] = NSLocalizedDescriptionKey;
    v68 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Zero-length NDEF message"));
    v133[0] = v68;
    v133[1] = &off_1003002A8;
    v132[1] = CFSTR("Line");
    v132[2] = CFSTR("Method");
    v69 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("readNdefDataFromTag:messageSize:error:"));
    v133[2] = v69;
    v132[3] = NSDebugDescriptionErrorKey;
    v70 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("readNdefDataFromTag:messageSize:error:"), 312);
    v133[3] = v70;
    v71 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v133, v132, 4));
    *a4 = objc_msgSend(v66, "initWithDomain:code:userInfo:", v67, 49, v71);

    goto LABEL_50;
  }
  if (a4)
    *a4 = 0;
  v101 = 0;
  v100 = (_QWORD *)NFDataCreateWithLength(a3);
  if (v100)
  {
    v32 = *((_QWORD *)v8 + 5);
    v33 = sub_10017E7EC((uint64_t)v8, v7);
    v34 = NFDriverRemoteDevReadNdef(v32, v33, v100, &v101);
    if ((_DWORD)v34)
    {
      v35 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v36 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v35);
      if (v36)
      {
        v37 = object_getClass(v8);
        if (class_isMetaClass(v37))
          v38 = 43;
        else
          v38 = 45;
        v39 = object_getClassName(v8);
        v40 = sel_getName("readNdefDataFromTag:messageSize:error:");
        v36(3, "%c[%{public}s %{public}s]:%i Failed to read NDEF from tag %{public}@, status=%d", v38, v39, v40, 325, v7, v34);
      }
      v41 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v42 = NFSharedLogGetLogger(v41);
      v43 = objc_claimAutoreleasedReturnValue(v42);
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
      {
        v44 = object_getClass(v8);
        if (class_isMetaClass(v44))
          v45 = 43;
        else
          v45 = 45;
        v46 = object_getClassName(v8);
        v47 = sel_getName("readNdefDataFromTag:messageSize:error:");
        *(_DWORD *)buf = 67110402;
        v121 = v45;
        v122 = 2082;
        v123 = v46;
        v124 = 2082;
        v125 = v47;
        v126 = 1024;
        v127 = 325;
        v128 = 2114;
        v129 = v7;
        v130 = 1024;
        v131 = v34;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to read NDEF from tag %{public}@, status=%d", buf, 0x32u);
      }

      if (!a4)
        goto LABEL_76;
      switch((int)v34)
      {
        case 4:
          v48 = objc_alloc((Class)NSError);
          v49 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
          v108[0] = NSLocalizedDescriptionKey;
          v50 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "SE not available"));
          v109[0] = v50;
          v109[1] = &off_100300338;
          v108[1] = CFSTR("Line");
          v108[2] = CFSTR("Method");
          v51 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("readNdefDataFromTag:messageSize:error:"));
          v109[2] = v51;
          v108[3] = NSDebugDescriptionErrorKey;
          v52 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("readNdefDataFromTag:messageSize:error:"), 338);
          v109[3] = v52;
          v53 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v109, v108, 4));
          v54 = objc_msgSend(v48, "initWithDomain:code:userInfo:", v49, 35, v53);
          break;
        case 5:
          v96 = objc_alloc((Class)NSError);
          v49 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
          v116[0] = NSLocalizedDescriptionKey;
          v50 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid Parameter"));
          v117[0] = v50;
          v117[1] = &off_1003002D8;
          v116[1] = CFSTR("Line");
          v116[2] = CFSTR("Method");
          v51 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("readNdefDataFromTag:messageSize:error:"));
          v117[2] = v51;
          v116[3] = NSDebugDescriptionErrorKey;
          v52 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("readNdefDataFromTag:messageSize:error:"), 330);
          v117[3] = v52;
          v53 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v117, v116, 4));
          v54 = objc_msgSend(v96, "initWithDomain:code:userInfo:", v49, 10, v53);
          break;
        case 6:
          v97 = objc_alloc((Class)NSError);
          v49 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
          v118[0] = NSLocalizedDescriptionKey;
          v50 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Connection Closed"));
          v119[0] = v50;
          v119[1] = &off_1003002C0;
          v118[1] = CFSTR("Line");
          v118[2] = CFSTR("Method");
          v51 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("readNdefDataFromTag:messageSize:error:"));
          v119[2] = v51;
          v118[3] = NSDebugDescriptionErrorKey;
          v52 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("readNdefDataFromTag:messageSize:error:"), 328);
          v119[3] = v52;
          v53 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v119, v118, 4));
          v54 = objc_msgSend(v97, "initWithDomain:code:userInfo:", v49, 21, v53);
          break;
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
          goto LABEL_70;
        case 12:
          v98 = objc_alloc((Class)NSError);
          v49 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
          v114[0] = NSLocalizedDescriptionKey;
          v50 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Tag Not NDEF formatted"));
          v115[0] = v50;
          v115[1] = &off_1003002F0;
          v114[1] = CFSTR("Line");
          v114[2] = CFSTR("Method");
          v51 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("readNdefDataFromTag:messageSize:error:"));
          v115[2] = v51;
          v114[3] = NSDebugDescriptionErrorKey;
          v52 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("readNdefDataFromTag:messageSize:error:"), 332);
          v115[3] = v52;
          v53 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v115, v114, 4));
          v54 = objc_msgSend(v98, "initWithDomain:code:userInfo:", v49, 37, v53);
          break;
        default:
          if ((_DWORD)v34 == 18)
          {
            v99 = objc_alloc((Class)NSError);
            v49 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
            v112[0] = NSLocalizedDescriptionKey;
            v50 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "RF Deactivated"));
            v113[0] = v50;
            v113[1] = &off_100300308;
            v112[1] = CFSTR("Line");
            v112[2] = CFSTR("Method");
            v51 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("readNdefDataFromTag:messageSize:error:"));
            v113[2] = v51;
            v112[3] = NSDebugDescriptionErrorKey;
            v52 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("readNdefDataFromTag:messageSize:error:"), 334);
            v113[3] = v52;
            v53 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v113, v112, 4));
            v54 = objc_msgSend(v99, "initWithDomain:code:userInfo:", v49, 51, v53);
          }
          else if ((_DWORD)v34 == 23)
          {
            v94 = objc_alloc((Class)NSError);
            v49 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
            v110[0] = NSLocalizedDescriptionKey;
            v50 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Reader mode prohibit timer"));
            v111[0] = v50;
            v111[1] = &off_100300320;
            v110[1] = CFSTR("Line");
            v110[2] = CFSTR("Method");
            v51 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("readNdefDataFromTag:messageSize:error:"));
            v111[2] = v51;
            v110[3] = NSDebugDescriptionErrorKey;
            v52 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("readNdefDataFromTag:messageSize:error:"), 336);
            v111[3] = v52;
            v53 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v111, v110, 4));
            v54 = objc_msgSend(v94, "initWithDomain:code:userInfo:", v49, 64, v53);
          }
          else
          {
LABEL_70:
            v95 = objc_alloc((Class)NSError);
            v49 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
            v106[0] = NSLocalizedDescriptionKey;
            v50 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
            v107[0] = v50;
            v107[1] = &off_100300350;
            v106[1] = CFSTR("Line");
            v106[2] = CFSTR("Method");
            v51 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("readNdefDataFromTag:messageSize:error:"));
            v107[2] = v51;
            v106[3] = NSDebugDescriptionErrorKey;
            v52 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("readNdefDataFromTag:messageSize:error:"), 340);
            v107[3] = v52;
            v53 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v107, v106, 4));
            v54 = objc_msgSend(v95, "initWithDomain:code:userInfo:", v49, 15, v53);
          }
          break;
      }
    }
    else
    {
      if (v101)
      {
        v79 = objc_alloc((Class)NSData);
        a4 = objc_msgSend(v79, "initWithBytes:length:", *v100, v101);
LABEL_77:
        NFDataRelease(v100);
        goto LABEL_51;
      }
      v80 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v81 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v80);
      if (v81)
      {
        v82 = object_getClass(v8);
        if (class_isMetaClass(v82))
          v83 = 43;
        else
          v83 = 45;
        v84 = object_getClassName(v8);
        v85 = sel_getName("readNdefDataFromTag:messageSize:error:");
        v81(5, "%c[%{public}s %{public}s]:%i zero-length message", v83, v84, v85, 346);
      }
      v86 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v87 = NFSharedLogGetLogger(v86);
      v88 = objc_claimAutoreleasedReturnValue(v87);
      if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
      {
        v89 = object_getClass(v8);
        if (class_isMetaClass(v89))
          v90 = 43;
        else
          v90 = 45;
        v91 = object_getClassName(v8);
        v92 = sel_getName("readNdefDataFromTag:messageSize:error:");
        *(_DWORD *)buf = 67109890;
        v121 = v90;
        v122 = 2082;
        v123 = v91;
        v124 = 2082;
        v125 = v92;
        v126 = 1024;
        v127 = 346;
        _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i zero-length message", buf, 0x22u);
      }

      if (!a4)
      {
LABEL_76:
        a4 = 0;
        goto LABEL_77;
      }
      v93 = objc_alloc((Class)NSError);
      v49 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v104[0] = NSLocalizedDescriptionKey;
      v50 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Zero-length NDEF message"));
      v105[0] = v50;
      v105[1] = &off_100300368;
      v104[1] = CFSTR("Line");
      v104[2] = CFSTR("Method");
      v51 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("readNdefDataFromTag:messageSize:error:"));
      v105[2] = v51;
      v104[3] = NSDebugDescriptionErrorKey;
      v52 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("readNdefDataFromTag:messageSize:error:"), 347);
      v105[3] = v52;
      v53 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v105, v104, 4));
      v54 = objc_msgSend(v93, "initWithDomain:code:userInfo:", v49, 49, v53);
    }
    *a4 = v54;

    goto LABEL_76;
  }
  if (a4)
  {
    v72 = objc_alloc((Class)NSError);
    v73 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v102[0] = NSLocalizedDescriptionKey;
    v74 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "No resources"));
    v103[0] = v74;
    v103[1] = &off_100300380;
    v102[1] = CFSTR("Line");
    v102[2] = CFSTR("Method");
    v75 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("readNdefDataFromTag:messageSize:error:"));
    v103[2] = v75;
    v102[3] = NSDebugDescriptionErrorKey;
    v76 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("readNdefDataFromTag:messageSize:error:"), 354);
    v103[3] = v76;
    v77 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v103, v102, 4));
    *a4 = objc_msgSend(v72, "initWithDomain:code:userInfo:", v73, 34, v77);

    goto LABEL_50;
  }
LABEL_51:
  objc_sync_exit(v8);

LABEL_52:
  return a4;
}

void sub_1001820CC(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_100182124(void *a1, void *a2, _QWORD *a3)
{
  id v3;

  if (a1)
  {
    v3 = sub_100182148(a1, a2, 0x8000u, a3);
    a1 = (void *)objc_claimAutoreleasedReturnValue(v3);
  }
  return a1;
}

id sub_100182148(void *a1, void *a2, unsigned int a3, _QWORD *a4)
{
  _QWORD *v4;
  void *v5;
  id v6;
  id v7;
  id v8;

  if (a1)
  {
    v4 = sub_100180CAC(a1, a2, a3, a4);
    v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
    if (v5)
    {
      v6 = objc_alloc((Class)NFNdefMessageInternal);
      v7 = objc_retainAutorelease(v5);
      v8 = objc_msgSend(v6, "initWithBytes:length:", objc_msgSend(v7, "bytes"), objc_msgSend(v7, "length"));
    }
    else
    {
      v8 = 0;
    }

  }
  else
  {
    v8 = 0;
  }
  return v8;
}

BOOL sub_1001821D4(void *a1, void *a2, void *a3, uint64_t a4, _QWORD *a5)
{
  id v9;
  id v10;
  id v11;
  void *v12;
  id v13;
  id v14;
  id v15;
  uint64_t v16;
  id v17;
  void *v18;
  _BOOL8 v19;
  uint64_t v20;
  id v21;
  int v22;
  void *specific;
  void (*Logger)(uint64_t, const char *, ...);
  objc_class *Class;
  uint64_t v26;
  const char *ClassName;
  const char *Name;
  void *v29;
  uint64_t v30;
  NSObject *v31;
  objc_class *v32;
  int v33;
  void *v34;
  id v35;
  id v36;
  void *v37;
  void *v39;
  id v40;
  id v41;
  void *v42;
  void *v43;
  id v44;
  id v45;
  void *v46;
  void *v47;
  id v48;
  id v49;
  void *v50;
  void *v51;
  id v52;
  id v53;
  void *v54;
  void *v55;
  id v56;
  id v57;
  void *v58;
  void *v59;
  id v60;
  id v61;
  void *v62;
  void *v63;
  id v64;
  id v65;
  void *v66;
  void *v67;
  id v68;
  id v69;
  void *v70;
  id v71;
  id v72;
  id v73;
  id v74;
  id v75;
  id v76;
  id v77;
  id v78;
  id v79;
  void *v80;
  void *v81;
  void *v82;
  void *v83;
  void *v84;
  void *v85;
  void *v86;
  void *v87;
  void *v88;
  uint64_t v89;
  id v90;
  id v91;
  _QWORD v92[4];
  _QWORD v93[4];
  _QWORD v94[4];
  _QWORD v95[4];
  _QWORD v96[4];
  _QWORD v97[4];
  _QWORD v98[4];
  _QWORD v99[4];
  _QWORD v100[4];
  _QWORD v101[4];
  _QWORD v102[4];
  _QWORD v103[4];
  _QWORD v104[4];
  _QWORD v105[4];
  _QWORD v106[4];
  _QWORD v107[4];
  _QWORD v108[4];
  _QWORD v109[4];
  uint8_t buf[4];
  int v111;
  __int16 v112;
  const char *v113;
  __int16 v114;
  const char *v115;
  __int16 v116;
  int v117;
  __int16 v118;
  id v119;
  _QWORD v120[4];
  _QWORD v121[4];
  _QWORD v122[4];
  _QWORD v123[4];

  v91 = a2;
  v90 = a3;
  if (!a1)
  {
    v19 = 0;
    goto LABEL_29;
  }
  v9 = a1;
  objc_sync_enter(v9);
  if (!*((_BYTE *)v9 + 137))
  {
    v11 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(v91, "asData")));
    v16 = NFDataCreateWithBytesNoCopy(objc_msgSend(v11, "bytes"), objc_msgSend(v11, "length"), 0);
    if (!a5 || v16)
    {
      v89 = v16;
      v20 = *((_QWORD *)v9 + 5);
      v21 = sub_10017E7EC((uint64_t)v9, v90);
      v22 = NFDriverRemoteDevWriteNdef(v20, v21, v89, a4);
      v19 = v22 == 0;
      if (v22)
      {
        specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(specific);
        if (Logger)
        {
          Class = object_getClass(v9);
          if (class_isMetaClass(Class))
            v26 = 43;
          else
            v26 = 45;
          ClassName = object_getClassName(v9);
          Name = sel_getName("writeNdefData:toTag:nLengthOptimization:error:");
          Logger(3, "%c[%{public}s %{public}s]:%i Failed to write NDEF data to tag %{public}@", v26, ClassName, Name, 400, v90);
        }
        v29 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v30 = NFSharedLogGetLogger(v29);
        v31 = objc_claimAutoreleasedReturnValue(v30);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
        {
          v32 = object_getClass(v9);
          if (class_isMetaClass(v32))
            v33 = 43;
          else
            v33 = 45;
          *(_DWORD *)buf = 67110146;
          v111 = v33;
          v112 = 2082;
          v113 = object_getClassName(v9);
          v114 = 2082;
          v115 = sel_getName("writeNdefData:toTag:nLengthOptimization:error:");
          v116 = 1024;
          v117 = 400;
          v118 = 2114;
          v119 = v90;
          _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to write NDEF data to tag %{public}@", buf, 0x2Cu);
        }

        if (a5)
        {
          switch(v22)
          {
            case 3:
              v71 = objc_alloc((Class)NSError);
              v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
              v100[0] = NSLocalizedDescriptionKey;
              v80 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "No resources"));
              v101[0] = v80;
              v101[1] = &off_100300428;
              v100[1] = CFSTR("Line");
              v100[2] = CFSTR("Method");
              v35 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("writeNdefData:toTag:nLengthOptimization:error:"));
              v101[2] = v35;
              v100[3] = NSDebugDescriptionErrorKey;
              v36 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("writeNdefData:toTag:nLengthOptimization:error:"), 412);
              v101[3] = v36;
              v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v101, v100, 4));
              *a5 = objc_msgSend(v71, "initWithDomain:code:userInfo:", v34, 34, v37);

              break;
            case 4:
              v74 = objc_alloc((Class)NSError);
              v47 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
              v94[0] = NSLocalizedDescriptionKey;
              v83 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "SE not available"));
              v95[0] = v83;
              v95[1] = &off_100300470;
              v94[1] = CFSTR("Line");
              v94[2] = CFSTR("Method");
              v48 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("writeNdefData:toTag:nLengthOptimization:error:"));
              v95[2] = v48;
              v94[3] = NSDebugDescriptionErrorKey;
              v49 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("writeNdefData:toTag:nLengthOptimization:error:"), 418);
              v95[3] = v49;
              v50 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v95, v94, 4));
              *a5 = objc_msgSend(v74, "initWithDomain:code:userInfo:", v47, 35, v50);

              break;
            case 5:
              v75 = objc_alloc((Class)NSError);
              v51 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
              v106[0] = NSLocalizedDescriptionKey;
              v84 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid Parameter"));
              v107[0] = v84;
              v107[1] = &off_1003003E0;
              v106[1] = CFSTR("Line");
              v106[2] = CFSTR("Method");
              v52 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("writeNdefData:toTag:nLengthOptimization:error:"));
              v107[2] = v52;
              v106[3] = NSDebugDescriptionErrorKey;
              v53 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("writeNdefData:toTag:nLengthOptimization:error:"), 406);
              v107[3] = v53;
              v54 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v107, v106, 4));
              *a5 = objc_msgSend(v75, "initWithDomain:code:userInfo:", v51, 10, v54);

              break;
            case 6:
              v76 = objc_alloc((Class)NSError);
              v55 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
              v108[0] = NSLocalizedDescriptionKey;
              v85 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Connection Closed"));
              v109[0] = v85;
              v109[1] = &off_1003003C8;
              v108[1] = CFSTR("Line");
              v108[2] = CFSTR("Method");
              v56 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("writeNdefData:toTag:nLengthOptimization:error:"));
              v109[2] = v56;
              v108[3] = NSDebugDescriptionErrorKey;
              v57 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("writeNdefData:toTag:nLengthOptimization:error:"), 404);
              v109[3] = v57;
              v58 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v109, v108, 4));
              *a5 = objc_msgSend(v76, "initWithDomain:code:userInfo:", v55, 21, v58);

              break;
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 13:
            case 14:
            case 16:
            case 17:
              goto LABEL_32;
            case 12:
              v77 = objc_alloc((Class)NSError);
              v59 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
              v104[0] = NSLocalizedDescriptionKey;
              v86 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Tag Not NDEF formatted"));
              v105[0] = v86;
              v105[1] = &off_1003003F8;
              v104[1] = CFSTR("Line");
              v104[2] = CFSTR("Method");
              v60 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("writeNdefData:toTag:nLengthOptimization:error:"));
              v105[2] = v60;
              v104[3] = NSDebugDescriptionErrorKey;
              v61 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("writeNdefData:toTag:nLengthOptimization:error:"), 408);
              v105[3] = v61;
              v62 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v105, v104, 4));
              *a5 = objc_msgSend(v77, "initWithDomain:code:userInfo:", v59, 37, v62);

              break;
            case 15:
              v78 = objc_alloc((Class)NSError);
              v63 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
              v102[0] = NSLocalizedDescriptionKey;
              v87 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "NDEF message size is over the limit"));
              v103[0] = v87;
              v103[1] = &off_100300410;
              v102[1] = CFSTR("Line");
              v102[2] = CFSTR("Method");
              v64 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("writeNdefData:toTag:nLengthOptimization:error:"));
              v103[2] = v64;
              v102[3] = NSDebugDescriptionErrorKey;
              v65 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("writeNdefData:toTag:nLengthOptimization:error:"), 410);
              v103[3] = v65;
              v66 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v103, v102, 4));
              *a5 = objc_msgSend(v78, "initWithDomain:code:userInfo:", v63, 43, v66);

              break;
            case 18:
              v79 = objc_alloc((Class)NSError);
              v67 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
              v98[0] = NSLocalizedDescriptionKey;
              v88 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "RF Deactivated"));
              v99[0] = v88;
              v99[1] = &off_100300440;
              v98[1] = CFSTR("Line");
              v98[2] = CFSTR("Method");
              v68 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("writeNdefData:toTag:nLengthOptimization:error:"));
              v99[2] = v68;
              v98[3] = NSDebugDescriptionErrorKey;
              v69 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("writeNdefData:toTag:nLengthOptimization:error:"), 414);
              v99[3] = v69;
              v70 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v99, v98, 4));
              *a5 = objc_msgSend(v79, "initWithDomain:code:userInfo:", v67, 51, v70);

              break;
            default:
              if (v22 == 23)
              {
                v72 = objc_alloc((Class)NSError);
                v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
                v96[0] = NSLocalizedDescriptionKey;
                v81 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Reader mode prohibit timer"));
                v97[0] = v81;
                v97[1] = &off_100300458;
                v96[1] = CFSTR("Line");
                v96[2] = CFSTR("Method");
                v40 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("writeNdefData:toTag:nLengthOptimization:error:"));
                v97[2] = v40;
                v96[3] = NSDebugDescriptionErrorKey;
                v41 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("writeNdefData:toTag:nLengthOptimization:error:"), 416);
                v97[3] = v41;
                v42 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v97, v96, 4));
                *a5 = objc_msgSend(v72, "initWithDomain:code:userInfo:", v39, 64, v42);

              }
              else
              {
LABEL_32:
                v73 = objc_alloc((Class)NSError);
                v43 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
                v92[0] = NSLocalizedDescriptionKey;
                v82 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
                v93[0] = v82;
                v93[1] = &off_100300488;
                v92[1] = CFSTR("Line");
                v92[2] = CFSTR("Method");
                v44 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("writeNdefData:toTag:nLengthOptimization:error:"));
                v93[2] = v44;
                v92[3] = NSDebugDescriptionErrorKey;
                v45 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("writeNdefData:toTag:nLengthOptimization:error:"), 420);
                v93[3] = v45;
                v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v93, v92, 4));
                *a5 = objc_msgSend(v73, "initWithDomain:code:userInfo:", v43, 15, v46);

              }
              break;
          }
        }
      }
      else if (a5)
      {
        *a5 = 0;
      }
      NFDataRelease(v89);
      goto LABEL_27;
    }
    v17 = objc_alloc((Class)NSError);
    v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v120[0] = NSLocalizedDescriptionKey;
    v13 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "No resources"));
    v121[0] = v13;
    v121[1] = &off_1003003B0;
    v120[1] = CFSTR("Line");
    v120[2] = CFSTR("Method");
    v14 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("writeNdefData:toTag:nLengthOptimization:error:"));
    v121[2] = v14;
    v120[3] = NSDebugDescriptionErrorKey;
    v15 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("writeNdefData:toTag:nLengthOptimization:error:"), 394);
    v121[3] = v15;
    v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v121, v120, 4));
    *a5 = objc_msgSend(v17, "initWithDomain:code:userInfo:", v12, 34, v18);

LABEL_8:
    v19 = 0;
LABEL_27:

    goto LABEL_28;
  }
  if (a5)
  {
    v10 = objc_alloc((Class)NSError);
    v11 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v122[0] = NSLocalizedDescriptionKey;
    v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Aborted"));
    v123[0] = v12;
    v123[1] = &off_100300398;
    v122[1] = CFSTR("Line");
    v122[2] = CFSTR("Method");
    v13 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("writeNdefData:toTag:nLengthOptimization:error:"));
    v123[2] = v13;
    v122[3] = NSDebugDescriptionErrorKey;
    v14 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("writeNdefData:toTag:nLengthOptimization:error:"), 385);
    v123[3] = v14;
    v15 = (id)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v123, v122, 4));
    *a5 = objc_msgSend(v10, "initWithDomain:code:userInfo:", v11, 3, v15);
    goto LABEL_8;
  }
  v19 = 0;
LABEL_28:
  objc_sync_exit(v9);

LABEL_29:
  return v19;
}

void sub_100183280(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

BOOL sub_1001832B4(void *a1, void *a2, _QWORD *a3)
{
  id v5;
  id v6;
  id v7;
  void *v8;
  void *v9;
  id v10;
  id v11;
  void *v12;
  id v13;
  _BOOL8 v14;
  uint64_t v16;
  id v17;
  int v18;
  id v19;
  id v20;
  id v21;
  id v22;
  id v23;
  _QWORD v24[4];
  _QWORD v25[4];
  _QWORD v26[4];
  _QWORD v27[4];
  _QWORD v28[4];
  _QWORD v29[4];
  _QWORD v30[4];
  _QWORD v31[4];
  _QWORD v32[4];
  _QWORD v33[4];
  _QWORD v34[4];
  _QWORD v35[4];

  v5 = a2;
  if (!a1)
  {
    v14 = 0;
    goto LABEL_8;
  }
  v6 = a1;
  objc_sync_enter(v6);
  if (!*((_BYTE *)v6 + 137))
  {
    v16 = *((_QWORD *)v6 + 5);
    v17 = sub_10017E7EC((uint64_t)v6, v5);
    v18 = NFDriverRemoteDevWriteLockNdef(v16, v17);
    v14 = v18 == 0;
    if (!a3 || !v18)
      goto LABEL_7;
    if (v18 > 11)
    {
      if (v18 == 12)
      {
        v22 = objc_alloc((Class)NSError);
        v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v30[0] = NSLocalizedDescriptionKey;
        v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Tag Not NDEF formatted"));
        v31[0] = v9;
        v31[1] = &off_1003004D0;
        v30[1] = CFSTR("Line");
        v30[2] = CFSTR("Method");
        v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("writeLockNdef:error:"));
        v31[2] = v10;
        v30[3] = NSDebugDescriptionErrorKey;
        v11 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("writeLockNdef:error:"), 447);
        v31[3] = v11;
        v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v31, v30, 4));
        v13 = objc_msgSend(v22, "initWithDomain:code:userInfo:", v8, 37, v12);
        goto LABEL_5;
      }
      if (v18 == 23)
      {
        v20 = objc_alloc((Class)NSError);
        v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v28[0] = NSLocalizedDescriptionKey;
        v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Reader mode prohibit timer"));
        v29[0] = v9;
        v29[1] = &off_1003004E8;
        v28[1] = CFSTR("Line");
        v28[2] = CFSTR("Method");
        v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("writeLockNdef:error:"));
        v29[2] = v10;
        v28[3] = NSDebugDescriptionErrorKey;
        v11 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("writeLockNdef:error:"), 449);
        v29[3] = v11;
        v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v29, v28, 4));
        v13 = objc_msgSend(v20, "initWithDomain:code:userInfo:", v8, 64, v12);
        goto LABEL_5;
      }
    }
    else
    {
      if (v18 == 4)
      {
        v21 = objc_alloc((Class)NSError);
        v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v26[0] = NSLocalizedDescriptionKey;
        v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "SE not available"));
        v27[0] = v9;
        v27[1] = &off_100300500;
        v26[1] = CFSTR("Line");
        v26[2] = CFSTR("Method");
        v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("writeLockNdef:error:"));
        v27[2] = v10;
        v26[3] = NSDebugDescriptionErrorKey;
        v11 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("writeLockNdef:error:"), 451);
        v27[3] = v11;
        v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v27, v26, 4));
        v13 = objc_msgSend(v21, "initWithDomain:code:userInfo:", v8, 35, v12);
        goto LABEL_5;
      }
      if (v18 == 6)
      {
        v19 = objc_alloc((Class)NSError);
        v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v32[0] = NSLocalizedDescriptionKey;
        v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Connection Closed"));
        v33[0] = v9;
        v33[1] = &off_1003004B8;
        v32[1] = CFSTR("Line");
        v32[2] = CFSTR("Method");
        v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("writeLockNdef:error:"));
        v33[2] = v10;
        v32[3] = NSDebugDescriptionErrorKey;
        v11 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("writeLockNdef:error:"), 445);
        v33[3] = v11;
        v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v33, v32, 4));
        v13 = objc_msgSend(v19, "initWithDomain:code:userInfo:", v8, 21, v12);
        goto LABEL_5;
      }
    }
    v23 = objc_alloc((Class)NSError);
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v24[0] = NSLocalizedDescriptionKey;
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
    v25[0] = v9;
    v25[1] = &off_100300518;
    v24[1] = CFSTR("Line");
    v24[2] = CFSTR("Method");
    v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("writeLockNdef:error:"));
    v25[2] = v10;
    v24[3] = NSDebugDescriptionErrorKey;
    v11 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("writeLockNdef:error:"), 453);
    v25[3] = v11;
    v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v25, v24, 4));
    v13 = objc_msgSend(v23, "initWithDomain:code:userInfo:", v8, 15, v12);
    goto LABEL_5;
  }
  if (a3)
  {
    v7 = objc_alloc((Class)NSError);
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v34[0] = NSLocalizedDescriptionKey;
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Aborted"));
    v35[0] = v9;
    v35[1] = &off_1003004A0;
    v34[1] = CFSTR("Line");
    v34[2] = CFSTR("Method");
    v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("writeLockNdef:error:"));
    v35[2] = v10;
    v34[3] = NSDebugDescriptionErrorKey;
    v11 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("writeLockNdef:error:"), 437);
    v35[3] = v11;
    v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v35, v34, 4));
    v13 = objc_msgSend(v7, "initWithDomain:code:userInfo:", v8, 3, v12);
LABEL_5:
    *a3 = v13;

  }
  v14 = 0;
LABEL_7:
  objc_sync_exit(v6);

LABEL_8:
  return v14;
}

void sub_100183AA0(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100183AC0(void *a1, void *a2)
{
  id v3;
  id v4;
  uint64_t v5;
  uint64_t v7;
  id v8;
  int v9;

  v3 = a2;
  if (!a1)
  {
    v5 = 0;
    goto LABEL_5;
  }
  v4 = a1;
  objc_sync_enter(v4);
  if (!*((_BYTE *)v4 + 137))
  {
    v7 = *((_QWORD *)v4 + 5);
    v8 = sub_10017E7EC((uint64_t)v4, v3);
    v9 = NFDriverRemoteDevCheckPresence(v7, v8);
    if (v9 > 17)
    {
      if (v9 == 18)
      {
        v5 = 51;
        goto LABEL_4;
      }
      if (v9 == 23)
      {
        v5 = 64;
        goto LABEL_4;
      }
    }
    else
    {
      if (!v9)
      {
        v5 = 0;
        goto LABEL_4;
      }
      if (v9 == 4)
      {
        v5 = 35;
        goto LABEL_4;
      }
    }
    v5 = 28;
    goto LABEL_4;
  }
  v5 = 3;
LABEL_4:
  objc_sync_exit(v4);

LABEL_5:
  return v5;
}

void sub_100183B8C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

BOOL sub_100183BA0(void *a1, void *a2, void *a3, _QWORD *a4)
{
  id v7;
  id v8;
  id v9;
  id v10;
  void *v11;
  void *v12;
  id v13;
  id v14;
  void *v15;
  _BOOL8 v16;
  uint64_t v17;
  id v18;
  uint64_t v19;
  id v20;
  NSObject *v21;
  void *v22;
  id v23;
  id v24;
  void *v25;
  id v26;
  void *v27;
  id v28;
  id v29;
  void *v30;
  void *v31;
  void (*v32)(uint64_t, const char *, ...);
  objc_class *v33;
  uint64_t v34;
  const char *v35;
  const char *v36;
  void *v37;
  uint64_t v38;
  objc_class *v39;
  int v40;
  const char *v41;
  const char *v42;
  uint64_t ErrorCode;
  void *v44;
  id v45;
  id v46;
  void *v47;
  id v49;
  uint64_t v50;
  uint64_t v51;
  id v52;
  int v53;
  id v54;
  id v55;
  void *v56;
  void *specific;
  void (*Logger)(uint64_t, const char *, ...);
  objc_class *Class;
  uint64_t v60;
  const char *ClassName;
  const char *Name;
  void *v63;
  uint64_t v64;
  NSObject *v65;
  objc_class *v66;
  int v67;
  id v68;
  void *v69;
  void *v70;
  id v71;
  id v72;
  void *v73;
  id v74;
  id v75;
  void *v76;
  void *v77;
  void *v78;
  _QWORD v79[2];
  uint64_t v80;
  _QWORD v81[4];
  _QWORD v82[4];
  _QWORD v83[5];
  _QWORD v84[5];
  _QWORD v85[4];
  _QWORD v86[4];
  _QWORD v87[4];
  _QWORD v88[4];
  _QWORD v89[4];
  _QWORD v90[4];
  uint8_t buf[4];
  int v92;
  __int16 v93;
  const char *v94;
  __int16 v95;
  const char *v96;
  __int16 v97;
  int v98;
  __int16 v99;
  unsigned int v100;
  _QWORD v101[4];
  _QWORD v102[4];

  v7 = a2;
  v8 = a3;
  if (!a1)
  {
    v16 = 0;
    goto LABEL_39;
  }
  v9 = a1;
  objc_sync_enter(v9);
  if (*((_BYTE *)v9 + 137))
  {
    if (a4)
    {
      v10 = objc_alloc((Class)NSError);
      v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v101[0] = NSLocalizedDescriptionKey;
      v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Aborted"));
      v102[0] = v12;
      v102[1] = &off_100300530;
      v101[1] = CFSTR("Line");
      v101[2] = CFSTR("Method");
      v13 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("formatTagToNdef:withKey:error:"));
      v102[2] = v13;
      v101[3] = NSDebugDescriptionErrorKey;
      v14 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("formatTagToNdef:withKey:error:"), 489);
      v102[3] = v14;
      v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v102, v101, 4));
      *a4 = objc_msgSend(v10, "initWithDomain:code:userInfo:", v11, 3, v15);

    }
    goto LABEL_5;
  }
  if (objc_msgSend(v7, "type") != 9
    && objc_msgSend(v7, "type") != 14
    && objc_msgSend(v7, "type") != 15
    && objc_msgSend(v7, "type") != 16
    && objc_msgSend(v7, "type") != 1
    && objc_msgSend(v7, "type") != 4)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(specific);
    if (Logger)
    {
      Class = object_getClass(v9);
      if (class_isMetaClass(Class))
        v60 = 43;
      else
        v60 = 45;
      ClassName = object_getClassName(v9);
      Name = sel_getName("formatTagToNdef:withKey:error:");
      Logger(3, "%c[%{public}s %{public}s]:%i Unsupport tag type:%d", v60, ClassName, Name, 495, objc_msgSend(v7, "type"));
    }
    v63 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v64 = NFSharedLogGetLogger(v63);
    v65 = objc_claimAutoreleasedReturnValue(v64);
    if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
    {
      v66 = object_getClass(v9);
      if (class_isMetaClass(v66))
        v67 = 43;
      else
        v67 = 45;
      *(_DWORD *)buf = 67110146;
      v92 = v67;
      v93 = 2082;
      v94 = object_getClassName(v9);
      v95 = 2082;
      v96 = sel_getName("formatTagToNdef:withKey:error:");
      v97 = 1024;
      v98 = 495;
      v99 = 1024;
      v100 = objc_msgSend(v7, "type");
      _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unsupport tag type:%d", buf, 0x28u);
    }

    if (a4)
    {
      v68 = objc_alloc((Class)NSError);
      v69 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v89[0] = NSLocalizedDescriptionKey;
      v70 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Feature Not Supported"));
      v90[0] = v70;
      v90[1] = &off_100300548;
      v89[1] = CFSTR("Line");
      v89[2] = CFSTR("Method");
      v71 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("formatTagToNdef:withKey:error:"));
      v90[2] = v71;
      v89[3] = NSDebugDescriptionErrorKey;
      v72 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("formatTagToNdef:withKey:error:"), 496);
      v90[3] = v72;
      v73 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v90, v89, 4));
      *a4 = objc_msgSend(v68, "initWithDomain:code:userInfo:", v69, 14, v73);

    }
    goto LABEL_5;
  }
  v79[0] = 0;
  v79[1] = 0;
  v80 = 0;
  v17 = *((_QWORD *)v9 + 5);
  v18 = sub_10017E7EC((uint64_t)v9, v7);
  v19 = NFDriverRemoteDevCheckNdef(v17, v18, v79);
  if ((int)v19 > 11)
  {
    if ((_DWORD)v19 != 12)
    {
      if ((_DWORD)v19 == 23)
      {
        if (a4)
        {
          v26 = objc_alloc((Class)NSError);
          v21 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
          v87[0] = NSLocalizedDescriptionKey;
          v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Reader mode prohibit timer"));
          v88[0] = v27;
          v88[1] = &off_100300560;
          v87[1] = CFSTR("Line");
          v87[2] = CFSTR("Method");
          v28 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("formatTagToNdef:withKey:error:"));
          v88[2] = v28;
          v87[3] = NSDebugDescriptionErrorKey;
          v29 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("formatTagToNdef:withKey:error:"), 504);
          v88[3] = v29;
          v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v88, v87, 4));
          *a4 = objc_msgSend(v26, "initWithDomain:code:userInfo:", v21, 64, v30);

          goto LABEL_36;
        }
        goto LABEL_5;
      }
LABEL_33:
      ErrorCode = NFDriverCreateErrorCode(v19);
      v21 = ErrorCode;
      v16 = 0;
      if (!a4 || !ErrorCode)
        goto LABEL_37;
      v75 = objc_alloc((Class)NSError);
      v77 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v83[0] = NSLocalizedDescriptionKey;
      v44 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
      v84[0] = v44;
      v84[1] = v21;
      v83[1] = NSUnderlyingErrorKey;
      v83[2] = CFSTR("Line");
      v84[2] = &off_100300590;
      v83[3] = CFSTR("Method");
      v45 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("formatTagToNdef:withKey:error:"));
      v84[3] = v45;
      v83[4] = NSDebugDescriptionErrorKey;
      v46 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("formatTagToNdef:withKey:error:"), 511);
      v84[4] = v46;
      v47 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v84, v83, 5));
      *a4 = objc_msgSend(v75, "initWithDomain:code:userInfo:", v77, 15, v47);

LABEL_36:
      v16 = 0;
LABEL_37:

      goto LABEL_38;
    }
LABEL_21:
    if (!(_BYTE)v80)
    {
      if (objc_msgSend(v8, "length"))
      {
        v49 = objc_retainAutorelease(v8);
        v50 = NFDataCreateWithBytesNoCopy(objc_msgSend(v49, "bytes"), objc_msgSend(v49, "length"), 0);
      }
      else
      {
        v50 = 0;
      }
      v51 = *((_QWORD *)v9 + 5);
      v52 = sub_10017E7EC((uint64_t)v9, v7);
      v53 = NFDriverRemoteDevFormatNdef(v51, v52, v50);
      v16 = v53 == 0;
      if (a4 && v53)
      {
        v74 = objc_alloc((Class)NSError);
        v76 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v81[0] = NSLocalizedDescriptionKey;
        v78 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Tag Error"));
        v82[0] = v78;
        v82[1] = &off_1003005A8;
        v81[1] = CFSTR("Line");
        v81[2] = CFSTR("Method");
        v54 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("formatTagToNdef:withKey:error:"));
        v82[2] = v54;
        v81[3] = NSDebugDescriptionErrorKey;
        v55 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("formatTagToNdef:withKey:error:"), 529);
        v82[3] = v55;
        v56 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v82, v81, 4));
        *a4 = objc_msgSend(v74, "initWithDomain:code:userInfo:", v76, 29, v56);

      }
      NFDataRelease(v50);
      goto LABEL_38;
    }
    v31 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v32 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v31);
    if (v32)
    {
      v33 = object_getClass(v9);
      if (class_isMetaClass(v33))
        v34 = 43;
      else
        v34 = 45;
      v35 = object_getClassName(v9);
      v36 = sel_getName("formatTagToNdef:withKey:error:");
      v32(5, "%c[%{public}s %{public}s]:%i Tag is already formatted!", v34, v35, v36, 516);
    }
    v37 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v38 = NFSharedLogGetLogger(v37);
    v21 = objc_claimAutoreleasedReturnValue(v38);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      v39 = object_getClass(v9);
      if (class_isMetaClass(v39))
        v40 = 43;
      else
        v40 = 45;
      v41 = object_getClassName(v9);
      v42 = sel_getName("formatTagToNdef:withKey:error:");
      *(_DWORD *)buf = 67109890;
      v92 = v40;
      v93 = 2082;
      v94 = v41;
      v95 = 2082;
      v96 = v42;
      v97 = 1024;
      v98 = 516;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Tag is already formatted!", buf, 0x22u);
    }
    v16 = 1;
    goto LABEL_37;
  }
  if (!(_DWORD)v19)
    goto LABEL_21;
  if ((_DWORD)v19 != 4)
    goto LABEL_33;
  if (a4)
  {
    v20 = objc_alloc((Class)NSError);
    v21 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v85[0] = NSLocalizedDescriptionKey;
    v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "SE not available"));
    v86[0] = v22;
    v86[1] = &off_100300578;
    v85[1] = CFSTR("Line");
    v85[2] = CFSTR("Method");
    v23 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("formatTagToNdef:withKey:error:"));
    v86[2] = v23;
    v85[3] = NSDebugDescriptionErrorKey;
    v24 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("formatTagToNdef:withKey:error:"), 507);
    v86[3] = v24;
    v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v86, v85, 4));
    *a4 = objc_msgSend(v20, "initWithDomain:code:userInfo:", v21, 35, v25);

    goto LABEL_36;
  }
LABEL_5:
  v16 = 0;
LABEL_38:
  objc_sync_exit(v9);

LABEL_39:
  return v16;
}

void sub_10018479C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_1001847DC(void *a1, void *a2, void *a3, _QWORD *a4, double a5)
{
  id v9;
  id v10;
  id v11;
  id v12;
  void *v13;
  void *v14;
  id v15;
  id v16;
  void *v17;
  id v18;
  id v19;
  uint64_t v20;
  uint64_t v21;
  id v22;
  uint64_t v23;
  uint64_t v24;
  id v25;
  uint64_t v26;
  id v27;
  uint64_t v28;
  id v29;
  void *v30;
  id v31;
  id v32;
  void *v33;
  uint64_t v34;
  id v35;
  void *v36;
  uint64_t v37;
  id v38;
  void *v39;
  uint64_t ErrorCode;
  id v41;
  id v42;
  uint64_t v43;
  id v44;
  void *specific;
  void (*Logger)(uint64_t, const char *, ...);
  objc_class *Class;
  uint64_t v49;
  const char *ClassName;
  const char *Name;
  void *v52;
  uint64_t v53;
  NSObject *v54;
  objc_class *v55;
  int v56;
  const char *v57;
  const char *v58;
  unsigned int v59;
  void *v60;
  void (*v61)(uint64_t, const char *, ...);
  objc_class *v62;
  uint64_t v63;
  const char *v64;
  const char *v65;
  void *v66;
  uint64_t v67;
  NSObject *v68;
  objc_class *v69;
  int v70;
  const char *v71;
  const char *v72;
  id v73;
  id v74;
  id v75;
  void *v76;
  _QWORD *v77;
  _QWORD v78[2];
  _QWORD v79[2];
  _QWORD v80[5];
  _QWORD v81[5];
  _QWORD v82[5];
  _QWORD v83[5];
  _QWORD v84[2];
  _QWORD v85[2];
  _QWORD v86[4];
  _QWORD v87[4];
  uint8_t buf[4];
  int v89;
  __int16 v90;
  const char *v91;
  __int16 v92;
  const char *v93;
  __int16 v94;
  int v95;
  __int16 v96;
  unsigned int v97;
  _QWORD v98[4];
  _QWORD v99[4];

  v9 = a2;
  v10 = a3;
  if (!a1)
  {
    v18 = 0;
    goto LABEL_46;
  }
  v11 = a1;
  objc_sync_enter(v11);
  if (*((_BYTE *)v11 + 137))
  {
    if (a4)
    {
      v12 = objc_alloc((Class)NSError);
      v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v98[0] = NSLocalizedDescriptionKey;
      v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Aborted"));
      v99[0] = v14;
      v99[1] = &off_1003005C0;
      v98[1] = CFSTR("Line");
      v98[2] = CFSTR("Method");
      v15 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("transceive:tag:maxTimeout:error:"));
      v99[2] = v15;
      v98[3] = NSDebugDescriptionErrorKey;
      v16 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("transceive:tag:maxTimeout:error:"), 540);
      v99[3] = v16;
      v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v99, v98, 4));
      *a4 = objc_msgSend(v12, "initWithDomain:code:userInfo:", v13, 3, v17);

    }
    v18 = 0;
    goto LABEL_45;
  }
  v19 = objc_retainAutorelease(v9);
  v20 = NFDataCreateWithBytesNoCopy(objc_msgSend(v19, "bytes"), objc_msgSend(v19, "length"), 0);
  v77 = 0;
  if (a5 < 0.0)
    a5 = 5.0;
  if (a4)
    *a4 = 0;
  if (objc_msgSend(v10, "technology") == 4)
  {
    v21 = *((_QWORD *)v11 + 5);
    v22 = sub_10017E7EC((uint64_t)v11, v10);
    v23 = NFDriverRemoteDeviceFelicaTransceive(v21, v22, v20, &v77, a5);
LABEL_17:
    v28 = v23;
    goto LABEL_18;
  }
  if (objc_msgSend(v10, "technology") == 16)
  {
    v24 = *((_QWORD *)v11 + 5);
    v25 = sub_10017E7EC((uint64_t)v11, v10);
    v23 = NFDriverRemoteDeviceIso15693Transceive(v24, v25, v20, &v77, a5);
    goto LABEL_17;
  }
  if (objc_msgSend(v10, "technology") == 1 || objc_msgSend(v10, "technology") == 2)
  {
    v26 = *((_QWORD *)v11 + 5);
    v27 = sub_10017E7EC((uint64_t)v11, v10);
    v23 = NFDriverRemoteDeviceIso14443Transceive(v26, v27, v20, &v77, a5);
    goto LABEL_17;
  }
  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(specific);
  if (Logger)
  {
    Class = object_getClass(v11);
    if (class_isMetaClass(Class))
      v49 = 43;
    else
      v49 = 45;
    ClassName = object_getClassName(v11);
    Name = sel_getName("transceive:tag:maxTimeout:error:");
    Logger(3, "%c[%{public}s %{public}s]:%i Tag tech = %d", v49, ClassName, Name, 564, objc_msgSend(v10, "technology"));
  }
  v52 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v53 = NFSharedLogGetLogger(v52);
  v54 = objc_claimAutoreleasedReturnValue(v53);
  if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
  {
    v55 = object_getClass(v11);
    if (class_isMetaClass(v55))
      v56 = 43;
    else
      v56 = 45;
    v57 = object_getClassName(v11);
    v58 = sel_getName("transceive:tag:maxTimeout:error:");
    v59 = objc_msgSend(v10, "technology");
    *(_DWORD *)buf = 67110146;
    v89 = v56;
    v90 = 2082;
    v91 = v57;
    v92 = 2082;
    v93 = v58;
    v94 = 1024;
    v95 = 564;
    v96 = 1024;
    v97 = v59;
    _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Tag tech = %d", buf, 0x28u);
  }

  v60 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v61 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v60);
  if (v61)
  {
    v62 = object_getClass(v11);
    if (class_isMetaClass(v62))
      v63 = 43;
    else
      v63 = 45;
    v64 = object_getClassName(v11);
    v65 = sel_getName("transceive:tag:maxTimeout:error:");
    v61(3, "%c[%{public}s %{public}s]:%i Reader mode transceive is not supported for this tag type", v63, v64, v65, 565);
  }
  v66 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v67 = NFSharedLogGetLogger(v66);
  v68 = objc_claimAutoreleasedReturnValue(v67);
  if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
  {
    v69 = object_getClass(v11);
    if (class_isMetaClass(v69))
      v70 = 43;
    else
      v70 = 45;
    v71 = object_getClassName(v11);
    v72 = sel_getName("transceive:tag:maxTimeout:error:");
    *(_DWORD *)buf = 67109890;
    v89 = v70;
    v90 = 2082;
    v91 = v71;
    v92 = 2082;
    v93 = v72;
    v94 = 1024;
    v95 = 565;
    _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Reader mode transceive is not supported for this tag type", buf, 0x22u);
  }

  v28 = 5;
LABEL_18:
  if (v77)
  {
    v29 = objc_alloc((Class)NSData);
    v18 = objc_msgSend(v29, "initWithBytes:length:", *v77, v77[1]);
  }
  else
  {
    v18 = 0;
  }
  NFDataRelease(v20);
  NFDataRelease(v77);
  if (!(_DWORD)v28 && v18)
    goto LABEL_45;
  if ((int)v28 > 19)
  {
    if ((_DWORD)v28 == 20)
    {
      ErrorCode = NFDriverCreateErrorCode(20);
      v30 = (void *)ErrorCode;
      if (!a4 || !ErrorCode)
        goto LABEL_44;
      v41 = objc_alloc((Class)NSError);
      v76 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v84[0] = NSLocalizedDescriptionKey;
      v31 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Tag Error"));
      v84[1] = NSUnderlyingErrorKey;
      v85[0] = v31;
      v85[1] = v30;
      v32 = (id)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v85, v84, 2));
      v42 = objc_msgSend(v41, "initWithDomain:code:userInfo:", v76, 29, v32);
LABEL_42:
      *a4 = v42;
      goto LABEL_43;
    }
    if ((_DWORD)v28 == 23)
    {
      v34 = NFDriverCreateErrorCode(23);
      v30 = (void *)v34;
      if (!a4 || !v34)
        goto LABEL_44;
      v74 = objc_alloc((Class)NSError);
      v76 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v82[0] = NSLocalizedDescriptionKey;
      v31 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Reader mode prohibit timer"));
      v83[0] = v31;
      v83[1] = v30;
      v82[1] = NSUnderlyingErrorKey;
      v82[2] = CFSTR("Line");
      v83[2] = &off_1003005F0;
      v82[3] = CFSTR("Method");
      v32 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("transceive:tag:maxTimeout:error:"));
      v83[3] = v32;
      v82[4] = NSDebugDescriptionErrorKey;
      v35 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("transceive:tag:maxTimeout:error:"), 588);
      v83[4] = v35;
      v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v83, v82, 5));
      *a4 = objc_msgSend(v74, "initWithDomain:code:userInfo:", v76, 64, v36);

      goto LABEL_43;
    }
LABEL_39:
    v43 = NFDriverCreateErrorCode(v28);
    v30 = (void *)v43;
    if (!a4 || !v43)
      goto LABEL_44;
    v44 = objc_alloc((Class)NSError);
    v76 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v78[0] = NSLocalizedDescriptionKey;
    v31 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
    v78[1] = NSUnderlyingErrorKey;
    v79[0] = v31;
    v79[1] = v30;
    v32 = (id)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v79, v78, 2));
    v42 = objc_msgSend(v44, "initWithDomain:code:userInfo:", v76, 15, v32);
    goto LABEL_42;
  }
  if ((_DWORD)v28 == 4)
  {
    v37 = NFDriverCreateErrorCode(4);
    v30 = (void *)v37;
    if (!a4 || !v37)
      goto LABEL_44;
    v75 = objc_alloc((Class)NSError);
    v76 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v80[0] = NSLocalizedDescriptionKey;
    v31 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "SE not available"));
    v81[0] = v31;
    v81[1] = v30;
    v80[1] = NSUnderlyingErrorKey;
    v80[2] = CFSTR("Line");
    v81[2] = &off_100300608;
    v80[3] = CFSTR("Method");
    v32 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("transceive:tag:maxTimeout:error:"));
    v81[3] = v32;
    v80[4] = NSDebugDescriptionErrorKey;
    v38 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("transceive:tag:maxTimeout:error:"), 591);
    v81[4] = v38;
    v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v81, v80, 5));
    *a4 = objc_msgSend(v75, "initWithDomain:code:userInfo:", v76, 35, v39);

    goto LABEL_43;
  }
  if ((_DWORD)v28 != 6)
    goto LABEL_39;
  if (a4)
  {
    v73 = objc_alloc((Class)NSError);
    v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v86[0] = NSLocalizedDescriptionKey;
    v76 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Tag Not Found"));
    v87[0] = v76;
    v87[1] = &off_1003005D8;
    v86[1] = CFSTR("Line");
    v86[2] = CFSTR("Method");
    v31 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("transceive:tag:maxTimeout:error:"));
    v87[2] = v31;
    v86[3] = NSDebugDescriptionErrorKey;
    v32 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("transceive:tag:maxTimeout:error:"), 577);
    v87[3] = v32;
    v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v87, v86, 4));
    *a4 = objc_msgSend(v73, "initWithDomain:code:userInfo:", v30, 28, v33);

LABEL_43:
LABEL_44:

  }
LABEL_45:
  objc_sync_exit(v11);

LABEL_46:
  return v18;
}

void sub_100185350(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10018539C(void *a1, uint64_t a2, _QWORD *a3)
{
  unsigned __int8 *v5;
  int v6;
  uint64_t v7;
  id v8;
  void *v9;
  void *v10;
  void *v11;
  id v12;
  id v13;
  id v14;
  id v15;
  id v16;
  int v18;
  NSErrorUserInfoKey v19;
  void *v20;
  NSErrorUserInfoKey v21;
  void *v22;
  NSErrorUserInfoKey v23;
  void *v24;
  NSErrorUserInfoKey v25;
  void *v26;
  NSErrorUserInfoKey v27;
  void *v28;

  if (!a1)
    return 0;
  v5 = a1;
  objc_sync_enter(v5);
  v6 = v5[137];
  objc_sync_exit(v5);

  if (v6)
    return 0;
  v18 = 0;
  v7 = NFDriverRemoteDevReceive(*((_QWORD *)v5 + 5), a2, &v18);
  switch(v18)
  {
    case 1:
      if (a3)
      {
        v8 = objc_alloc((Class)NSError);
        v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v25 = NSLocalizedDescriptionKey;
        v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
        v26 = v10;
        v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v26, &v25, 1));
        v12 = objc_msgSend(v8, "initWithDomain:code:userInfo:", v9, 15, v11);
        goto LABEL_16;
      }
      break;
    case 3:
      if (a3)
      {
        v14 = objc_alloc((Class)NSError);
        v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v21 = NSLocalizedDescriptionKey;
        v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "No resources"));
        v22 = v10;
        v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v22, &v21, 1));
        v12 = objc_msgSend(v14, "initWithDomain:code:userInfo:", v9, 34, v11);
        goto LABEL_16;
      }
      break;
    case 5:
      if (a3)
      {
        v15 = objc_alloc((Class)NSError);
        v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v23 = NSLocalizedDescriptionKey;
        v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid Parameter"));
        v24 = v10;
        v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v24, &v23, 1));
        v12 = objc_msgSend(v15, "initWithDomain:code:userInfo:", v9, 10, v11);
        goto LABEL_16;
      }
      break;
    case 6:
      if (a3)
      {
        v16 = objc_alloc((Class)NSError);
        v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v27 = NSLocalizedDescriptionKey;
        v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Tag Not Found"));
        v28 = v10;
        v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v28, &v27, 1));
        v12 = objc_msgSend(v16, "initWithDomain:code:userInfo:", v9, 28, v11);
        goto LABEL_16;
      }
      break;
    default:
      if (a3 && v18 == 21)
      {
        v13 = objc_alloc((Class)NSError);
        v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v19 = NSLocalizedDescriptionKey;
        v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Tag is halted"));
        v20 = v10;
        v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v20, &v19, 1));
        v12 = objc_msgSend(v13, "initWithDomain:code:userInfo:", v9, 62, v11);
LABEL_16:
        *a3 = v12;

      }
      break;
  }
  return v7;
}

void sub_100185770(void *a1, uint64_t a2, void *a3)
{
  void (**v5)(id, _QWORD, id);
  id v6;
  id v7;
  void *v8;
  void *v9;
  id v10;
  id v11;
  void *v12;
  id v13;
  uint64_t v14;
  _QWORD v15[4];
  void (**v16)(id, _QWORD, id);
  const char *v17;
  _QWORD v18[4];
  _QWORD v19[4];

  v5 = a3;
  if (a1)
  {
    v6 = a1;
    objc_sync_enter(v6);
    if (*((_BYTE *)v6 + 137))
    {
      v7 = objc_alloc((Class)NSError);
      v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v18[0] = NSLocalizedDescriptionKey;
      v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid State"));
      v19[0] = v9;
      v19[1] = &off_100300620;
      v18[1] = CFSTR("Line");
      v18[2] = CFSTR("Method");
      v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("readFromHCEDevice:completion:"));
      v19[2] = v10;
      v18[3] = NSDebugDescriptionErrorKey;
      v11 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("readFromHCEDevice:completion:"), 633);
      v19[3] = v11;
      v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v19, v18, 4));
      v13 = objc_msgSend(v7, "initWithDomain:code:userInfo:", v8, 12, v12);
      v5[2](v5, 0, v13);

      objc_sync_exit(v6);
    }
    else
    {
      objc_sync_exit(v6);

      v14 = *((_QWORD *)v6 + 5);
      v15[0] = _NSConcreteStackBlock;
      v15[1] = 3221225472;
      v15[2] = sub_1001859E4;
      v15[3] = &unk_1002EA080;
      v17 = "readFromHCEDevice:completion:";
      v16 = v5;
      NFDriverRemoteDevReceiveAsync(v14, a2, v15);
      v6 = v16;
    }

  }
}

void sub_1001859C8(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_1001859E4(uint64_t a1, int a2)
{
  id v3;
  id v4;
  void *v5;
  void *v6;
  id v7;
  id v8;
  void *v9;
  void *v10;
  void *v11;
  uint64_t v12;
  id v13;
  id v14;
  id v15;
  id v16;
  _QWORD v17[4];
  _QWORD v18[4];
  _QWORD v19[4];
  _QWORD v20[4];
  _QWORD v21[4];
  _QWORD v22[4];
  _QWORD v23[4];
  _QWORD v24[4];
  _QWORD v25[4];
  _QWORD v26[4];

  v3 = 0;
  switch(a2)
  {
    case 1:
      v4 = objc_alloc((Class)NSError);
      v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v23[0] = NSLocalizedDescriptionKey;
      v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
      v24[0] = v6;
      v24[1] = &off_100300650;
      v23[1] = CFSTR("Line");
      v23[2] = CFSTR("Method");
      v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 40)));
      v24[2] = v7;
      v23[3] = NSDebugDescriptionErrorKey;
      v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 40)), 645);
      v24[3] = v8;
      v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v24, v23, 4));
      v10 = v4;
      v11 = v5;
      v12 = 15;
      goto LABEL_8;
    case 2:
    case 4:
      goto LABEL_9;
    case 3:
      v14 = objc_alloc((Class)NSError);
      v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v19[0] = NSLocalizedDescriptionKey;
      v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "No resources"));
      v20[0] = v6;
      v20[1] = &off_100300680;
      v19[1] = CFSTR("Line");
      v19[2] = CFSTR("Method");
      v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 40)));
      v20[2] = v7;
      v19[3] = NSDebugDescriptionErrorKey;
      v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 40)), 649);
      v20[3] = v8;
      v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v20, v19, 4));
      v10 = v14;
      v11 = v5;
      v12 = 34;
      goto LABEL_8;
    case 5:
      v15 = objc_alloc((Class)NSError);
      v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v21[0] = NSLocalizedDescriptionKey;
      v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid Parameter"));
      v22[0] = v6;
      v22[1] = &off_100300668;
      v21[1] = CFSTR("Line");
      v21[2] = CFSTR("Method");
      v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 40)));
      v22[2] = v7;
      v21[3] = NSDebugDescriptionErrorKey;
      v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 40)), 647);
      v22[3] = v8;
      v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v22, v21, 4));
      v10 = v15;
      v11 = v5;
      v12 = 10;
      goto LABEL_8;
    case 6:
      v16 = objc_alloc((Class)NSError);
      v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v25[0] = NSLocalizedDescriptionKey;
      v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Tag Not Found"));
      v26[0] = v6;
      v26[1] = &off_100300638;
      v25[1] = CFSTR("Line");
      v25[2] = CFSTR("Method");
      v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 40)));
      v26[2] = v7;
      v25[3] = NSDebugDescriptionErrorKey;
      v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 40)), 643);
      v26[3] = v8;
      v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v26, v25, 4));
      v10 = v16;
      v11 = v5;
      v12 = 28;
      goto LABEL_8;
    default:
      if (a2 != 21)
        goto LABEL_9;
      v13 = objc_alloc((Class)NSError);
      v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v17[0] = NSLocalizedDescriptionKey;
      v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Tag is halted"));
      v18[0] = v6;
      v18[1] = &off_100300698;
      v17[1] = CFSTR("Line");
      v17[2] = CFSTR("Method");
      v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 40)));
      v18[2] = v7;
      v17[3] = NSDebugDescriptionErrorKey;
      v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 40)), 651);
      v18[3] = v8;
      v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v18, v17, 4));
      v10 = v13;
      v11 = v5;
      v12 = 62;
LABEL_8:
      v3 = objc_msgSend(v10, "initWithDomain:code:userInfo:", v11, v12, v9);

LABEL_9:
      (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();

      return;
  }
}

uint64_t sub_100186034(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v7;
  int v8;

  if (a1
    && (v7 = a1,
        objc_sync_enter(v7),
        v8 = *((unsigned __int8 *)v7 + 137),
        objc_sync_exit(v7),
        v7,
        !v8))
  {
    return NFDriverRemoteDevSend(v7[5], a2, a3, a4);
  }
  else
  {
    return 0;
  }
}

void sub_1001860B4(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  NSMutableArray *v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  unsigned __int8 *v13;
  id v14;
  id v15;
  void *v16;
  uint64_t v17;
  void (*v18)(uint64_t, const char *, ...);
  objc_class *v19;
  _BOOL4 v20;
  const char *v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  NSObject *v25;
  objc_class *v26;
  int v27;
  const char *v28;
  const char *v29;
  void *v30;
  uint64_t v31;
  unsigned int v32;
  id v33;
  id v34;
  id v35;
  uint64_t v36;
  unsigned int v37;
  id v38;
  id v39;
  id v40;
  id v41;
  id v42;
  void *v43;
  void *v44;
  void *v45;
  void *v46;
  id v47;
  NSMutableArray *v48;
  void *v49;
  uint64_t v50;
  void (*v51)(uint64_t, const char *, ...);
  objc_class *v52;
  _BOOL4 v53;
  const char *v54;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  NSObject *v58;
  objc_class *v59;
  int v60;
  const char *v61;
  const char *v62;
  const __CFString *v63;
  uint64_t v64;
  void *specific;
  uint64_t Logger;
  void (*v67)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v71;
  void *v72;
  uint64_t v73;
  NSObject *v74;
  objc_class *v75;
  int v76;
  const char *v77;
  const char *v78;
  const char *v79;
  const char *v80;
  const char *Name;
  unsigned int v82;
  NSMutableArray *v83;
  _QWORD v84[2];
  _QWORD v85[2];
  uint8_t buf[4];
  int v87;
  __int16 v88;
  const char *v89;
  __int16 v90;
  const char *v91;
  __int16 v92;
  int v93;

  if (a1)
  {
    v8 = objc_opt_new(NSMutableArray);
    objc_msgSend(*(id *)(a1 + 56), "removeAllObjects");
    sub_1001FBD08(a1);
    v10 = NFSharedSignpostLog(v9);
    v11 = objc_claimAutoreleasedReturnValue(v10);
    if (os_signpost_enabled(v11))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v11, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "TAGS_DETECTED", "", buf, 2u);
    }
    v83 = v8;

    v82 = a4;
    if ((a4 & 1) != 0)
    {
      if (!a3)
      {
LABEL_38:
        objc_msgSend(*(id *)(a1 + 88), "tagDetected");
        sub_1001D16D8(*(_BYTE **)(a1 + 80), 1u);
        if (!*(_BYTE *)(*(_QWORD *)(a1 + 40) + 62) || *(_BYTE *)(a1 + 64))
        {
          v47 = *(id *)(a1 + 248);
          v48 = v83;
          objc_msgSend(v47, "handleRemoteTagsDetected:dropAndRestartDiscovery:", v83, v82);

LABEL_62:
          return;
        }
        specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        Logger = NFLogGetLogger(specific);
        if (Logger)
        {
          v67 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass((id)a1);
          isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName((id)a1);
          Name = sel_getName("driverDidDetectRemoteTags:count:dropAndRestartDiscovery:");
          v71 = 45;
          if (isMetaClass)
            v71 = 43;
          v67(3, "%c[%{public}s %{public}s]:%i Error ! Applet hasn't started reader mode, yet the field is on.", v71, ClassName, Name, 792);
        }
        v72 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v73 = NFSharedLogGetLogger(v72);
        v74 = objc_claimAutoreleasedReturnValue(v73);
        if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
        {
          v75 = object_getClass((id)a1);
          if (class_isMetaClass(v75))
            v76 = 43;
          else
            v76 = 45;
          v77 = object_getClassName((id)a1);
          v78 = sel_getName("driverDidDetectRemoteTags:count:dropAndRestartDiscovery:");
          *(_DWORD *)buf = 67109890;
          v87 = v76;
          v88 = 2082;
          v89 = v77;
          v90 = 2082;
          v91 = v78;
          v92 = 1024;
          v93 = 792;
          _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error ! Applet hasn't started reader mode, yet the field is on.", buf, 0x22u);
        }

        v63 = CFSTR("tag found during SERM, Applet did not request SERM.");
        sub_100187C44((uint64_t)NFBugCapture, CFSTR("Applet hasn't started reader mode, yet we found a tag"), CFSTR("tag found during SERM, Applet did not request SERM."), 0);
        v64 = 6;
LABEL_61:
        +[NFExceptionsCALogger postAnalyticsSEFailureEvent:context:error:](NFExceptionsCALogger, "postAnalyticsSEFailureEvent:context:error:", v64, v63, 0);
        v48 = v83;
        goto LABEL_62;
      }
    }
    else if (!a2 || !a3)
    {
      v49 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v50 = NFLogGetLogger(v49);
      if (v50)
      {
        v51 = (void (*)(uint64_t, const char *, ...))v50;
        v52 = object_getClass((id)a1);
        v53 = class_isMetaClass(v52);
        v54 = object_getClassName((id)a1);
        v80 = sel_getName("driverDidDetectRemoteTags:count:dropAndRestartDiscovery:");
        v55 = 45;
        if (v53)
          v55 = 43;
        v51(3, "%c[%{public}s %{public}s]:%i Invalid tag data", v55, v54, v80, 697);
      }
      v56 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v57 = NFSharedLogGetLogger(v56);
      v58 = objc_claimAutoreleasedReturnValue(v57);
      if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
      {
        v59 = object_getClass((id)a1);
        if (class_isMetaClass(v59))
          v60 = 43;
        else
          v60 = 45;
        v61 = object_getClassName((id)a1);
        v62 = sel_getName("driverDidDetectRemoteTags:count:dropAndRestartDiscovery:");
        *(_DWORD *)buf = 67109890;
        v87 = v60;
        v88 = 2082;
        v89 = v61;
        v90 = 2082;
        v91 = v62;
        v92 = 1024;
        v93 = 697;
        _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid tag data", buf, 0x22u);
      }

      v63 = CFSTR("NFC Invalid tag data");
      sub_100187C44((uint64_t)NFBugCapture, CFSTR("NFC Invalid tag data"), CFSTR("NFC Invalid tag data"), 0);
      v64 = 5;
      goto LABEL_61;
    }
    v12 = a3;
    v13 = (unsigned __int8 *)(a2 + 67);
    while (2)
    {
      v14 = objc_alloc_init((Class)NFTagInternal);
      v15 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", v13 + 5, v13[21]);
      objc_msgSend(v14, "_setIdentifier:", v15);
      switch(*(_DWORD *)(v13 - 59))
      {
        case 0:
          objc_msgSend(v14, "_setTechnology:", 0);
          v30 = v14;
          v31 = 0;
          goto LABEL_35;
        case 1:
          objc_msgSend(v14, "_setTechnology:", 1);
          v32 = *(_DWORD *)(v13 - 55);
          if (v32 <= 2)
            objc_msgSend(v14, "_setType:", v32 + 1);
          v33 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", v13 - 48, *v13);
          objc_msgSend(v14, "_setHistoricalBytes:", v33);

          v34 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", v13 - 50, 2);
          objc_msgSend(v14, "_setAtqa:", v34);

          v35 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", v13 - 51, 1);
          objc_msgSend(v14, "_setSak:", v35);

          v36 = v13[1];
          goto LABEL_27;
        case 2:
          objc_msgSend(v14, "_setTechnology:", 2);
          v37 = *(_DWORD *)(v13 - 55);
          if (v37 <= 2)
            objc_msgSend(v14, "_setType:", v37 + 4);
          v36 = *(v13 - 51);
LABEL_27:
          objc_msgSend(v14, "_setSFGI:", v36);
          goto LABEL_36;
        case 3:
          objc_msgSend(v14, "_setTechnology:", 4);
          objc_msgSend(v14, "_setType:", 7);
          v38 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", v13 - 54, *(v13 - 55));
          objc_msgSend(v14, "_setIdentifier:", v38);

          v39 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", v13 - 54, *(v13 - 55));
          objc_msgSend(v14, "_setIDm:", v39);

          v40 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", v13 - 44, 8);
          objc_msgSend(v14, "_setPMm:", v40);
          goto LABEL_30;
        case 4:
          objc_msgSend(v14, "_setTechnology:", 1);
          objc_msgSend(v14, "_setType:", 9);
          v41 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", v13 - 48, *v13);
          objc_msgSend(v14, "_setHistoricalBytes:", v41);

          v42 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", v13 - 50, 2);
          objc_msgSend(v14, "_setAtqa:", v42);

          v40 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", v13 - 51, 1);
          objc_msgSend(v14, "_setSak:", v40);
LABEL_30:

          goto LABEL_36;
        case 5:
          objc_msgSend(v14, "_setTechnology:", 16);
          v30 = v14;
          v31 = 8;
          goto LABEL_35;
        case 6:
          objc_msgSend(v14, "_setTechnology:", 1);
          v30 = v14;
          v31 = 11;
          goto LABEL_35;
        case 7:
          objc_msgSend(v14, "_setTechnology:", 1);
          v30 = v14;
          v31 = 12;
          goto LABEL_35;
        case 8:
          objc_msgSend(v14, "_setTechnology:", 0);
          v30 = v14;
          v31 = 10;
LABEL_35:
          objc_msgSend(v30, "_setType:", v31);
          goto LABEL_36;
        case 9:
        case 0xA:
        case 0xB:
          v16 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v17 = NFLogGetLogger(v16);
          if (v17)
          {
            v18 = (void (*)(uint64_t, const char *, ...))v17;
            v19 = object_getClass((id)a1);
            v20 = class_isMetaClass(v19);
            v21 = object_getClassName((id)a1);
            v79 = sel_getName("driverDidDetectRemoteTags:count:dropAndRestartDiscovery:");
            v22 = 45;
            if (v20)
              v22 = 43;
            v18(4, "%c[%{public}s %{public}s]:%i unexpected silent tag found", v22, v21, v79, 772);
          }
          v23 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v24 = NFSharedLogGetLogger(v23);
          v25 = objc_claimAutoreleasedReturnValue(v24);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            v26 = object_getClass((id)a1);
            if (class_isMetaClass(v26))
              v27 = 43;
            else
              v27 = 45;
            v28 = object_getClassName((id)a1);
            v29 = sel_getName("driverDidDetectRemoteTags:count:dropAndRestartDiscovery:");
            *(_DWORD *)buf = 67109890;
            v87 = v27;
            v88 = 2082;
            v89 = v28;
            v90 = 2082;
            v91 = v29;
            v92 = 1024;
            v93 = 772;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i unexpected silent tag found", buf, 0x22u);
          }
          goto LABEL_37;
        default:
LABEL_36:
          v25 = objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "_getExtendedIdentifier:", v14));
          v43 = *(void **)(a1 + 56);
          v84[0] = CFSTR("tagHandle");
          v44 = (void *)objc_claimAutoreleasedReturnValue(+[NSValue valueWithPointer:](NSValue, "valueWithPointer:", *(_QWORD *)(v13 - 67)));
          v84[1] = CFSTR("type");
          v85[0] = v44;
          v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", objc_msgSend(v14, "type")));
          v85[1] = v45;
          v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v85, v84, 2));
          objc_msgSend(v43, "setObject:forKey:", v46, v25);

          objc_msgSend(v14, "_setUID:", v25);
          -[NSMutableArray addObject:](v83, "addObject:", v14);
LABEL_37:

          v13 += 96;
          if (!--v12)
            goto LABEL_38;
          continue;
      }
    }
  }
}

void sub_1001869B0(uint64_t a1)
{
  id v1;

  if (a1)
  {
    v1 = *(id *)(a1 + 248);
    objc_msgSend(v1, "handleHceTargetLost");

  }
}

void sub_100186C9C(id a1)
{
  NFBugCapture *v1;
  void *v2;

  v1 = objc_alloc_init(NFBugCapture);
  v2 = (void *)qword_10032AAB0;
  qword_10032AAB0 = (uint64_t)v1;

}

id sub_100187A18(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "_handleCallbackSync:", *(_QWORD *)(a1 + 40));
}

void sub_100187A24(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  id v11;
  id v12;
  id v13;
  id v14;
  id v15;
  void *v16;
  _QWORD *v17;
  void *v18;
  NSObject *v19;
  _QWORD block[4];
  _QWORD *v21;
  id v22;
  id v23;
  id v24;
  id v25;
  id v26;
  id v27;

  v11 = a2;
  v12 = a3;
  v13 = a4;
  v14 = a5;
  v15 = a6;
  objc_opt_self(a1);
  v16 = objc_autoreleasePoolPush();
  if (os_variant_has_internal_diagnostics("com.apple.nearfield"))
  {
    v17 = (_QWORD *)objc_claimAutoreleasedReturnValue(+[NFBugCapture _getInstance](NFBugCapture, "_getInstance"));
    v18 = v17;
    if (v17)
    {
      v19 = v17[1];
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_100187B94;
      block[3] = &unk_1002EA0C8;
      v21 = v17;
      v22 = v11;
      v23 = v12;
      v24 = 0;
      v25 = v13;
      v26 = v14;
      v27 = v15;
      dispatch_async(v19, block);

    }
  }
  objc_autoreleasePoolPop(v16);

}

id sub_100187B94(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "_requestTapToRadarSync:componentName:preferences:withType:withSubTypeContext:additionalInfo:", *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 80));
}

void sub_100187BAC(uint64_t a1, void *a2, void *a3, void *a4)
{
  _UNKNOWN **v7;
  id v8;
  id v9;
  _UNKNOWN **v10;
  id v11;

  v7 = a4;
  v8 = a3;
  v9 = a2;
  objc_opt_self(a1);
  if (v7)
    v10 = v7;
  else
    v10 = &off_1003069E8;
  v11 = v10;
  sub_100187A24((uint64_t)NFBugCapture, v9, CFSTR("NFC-SE"), CFSTR("Transaction Failure"), v8, v10);

}

void sub_100187C44(uint64_t a1, void *a2, void *a3, void *a4)
{
  _UNKNOWN **v7;
  id v8;
  id v9;
  _UNKNOWN **v10;
  id v11;

  v7 = a4;
  v8 = a3;
  v9 = a2;
  objc_opt_self(a1);
  if (v7)
    v10 = v7;
  else
    v10 = &off_100306A10;
  v11 = v10;
  sub_100187A24((uint64_t)NFBugCapture, v9, CFSTR("Purple Stockholm"), CFSTR("Unexpected crash"), v8, v10);

}

void sub_100187CDC(uint64_t a1, void *a2, void *a3, void *a4)
{
  _UNKNOWN **v7;
  id v8;
  id v9;
  _UNKNOWN **v10;
  id v11;

  v7 = a4;
  v8 = a3;
  v9 = a2;
  objc_opt_self(a1);
  if (v7)
    v10 = v7;
  else
    v10 = &off_100306A38;
  v11 = v10;
  sub_100187A24((uint64_t)NFBugCapture, v9, CFSTR("NFC-SE"), CFSTR("Contactless Failure"), v8, v10);

}

void sub_100187D74(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;

  v7 = a4;
  v8 = a3;
  v9 = a2;
  objc_opt_self(a1);
  sub_100187A24((uint64_t)NFBugCapture, v9, CFSTR("NFC-SE"), CFSTR("Provisioning Failure"), v8, v7);

}

void sub_100187DFC(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;

  v7 = a4;
  v8 = a3;
  v9 = a2;
  objc_opt_self(a1);
  sub_100187A24((uint64_t)NFBugCapture, v9, CFSTR("NFC-SE"), CFSTR("ATL Failure"), v8, v7);

}

void sub_100187E84(uint64_t a1, void *a2, void *a3, void *a4)
{
  _UNKNOWN **v7;
  id v8;
  id v9;
  _UNKNOWN **v10;
  id v11;

  v7 = a4;
  v8 = a3;
  v9 = a2;
  objc_opt_self(a1);
  if (v7)
    v10 = v7;
  else
    v10 = &off_100306A60;
  v11 = v10;
  sub_100187A24((uint64_t)NFBugCapture, v9, CFSTR("NFC-SE"), CFSTR("Express Mode Failure"), v8, v10);

}

void sub_100187F1C(uint64_t a1, void *a2, void *a3, void *a4)
{
  _UNKNOWN **v7;
  id v8;
  id v9;
  _UNKNOWN **v10;
  id v11;

  v7 = a4;
  v8 = a3;
  v9 = a2;
  objc_opt_self(a1);
  if (v7)
    v10 = v7;
  else
    v10 = &off_100306A88;
  v11 = v10;
  sub_100187A24((uint64_t)NFBugCapture, v9, CFSTR("Purple Stockholm"), CFSTR("NFAccessory Failure"), v8, v10);

}

void sub_100188DD8()
{
  id *v0;
  id v1;
  void *v2;
  void *v3;
  _QWORD v4[5];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v0 = (id *)qword_10032AAC8;
  v8 = qword_10032AAC8;
  if (!qword_10032AAC8)
  {
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 3221225472;
    v4[2] = sub_100189C10;
    v4[3] = &unk_1002E5E30;
    v4[4] = &v5;
    sub_100189C10(v4);
    v0 = (id *)v6[3];
  }
  _Block_object_dispose(&v5, 8);
  if (v0)
  {
    v1 = *v0;
  }
  else
  {
    v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "NSString *getSBUserNotificationDismissOnLock(void)"));
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, CFSTR("NFBugCapture.m"), 43, CFSTR("%s"), dlerror());

    __break(1u);
  }
}

void sub_100188ED8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_100188EF0(uint64_t a1, uint64_t a2)
{
  return +[NFBugCapture handleCallback:](NFBugCapture, "handleCallback:", a2);
}

void sub_1001895B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1001895D4(uint64_t a1, void *a2)
{
  id v3;
  _QWORD *v4;
  void *v5;
  void *v6;
  unsigned int v7;
  void *specific;
  uint64_t Logger;
  void (*v10)(uint64_t, const char *, ...);
  objc_class *Class;
  uint64_t v12;
  const char *ClassName;
  const char *Name;
  void *v15;
  uint64_t v16;
  NSObject *v17;
  objc_class *v18;
  int v19;
  const char *v20;
  const char *v21;
  objc_class *v22;
  uint64_t v23;
  const char *v24;
  const char *v25;
  void *v26;
  void *v27;
  uint64_t v28;
  objc_class *v29;
  int v30;
  const char *v31;
  const char *v32;
  void *v33;
  void *v34;
  void *v35;
  uint8_t buf[8];
  _BYTE v37[26];
  __int16 v38;
  void *v39;

  v3 = a2;
  *(_QWORD *)buf = 0;
  *(_QWORD *)v37 = buf;
  *(_QWORD *)&v37[8] = 0x2020000000;
  v4 = (_QWORD *)qword_10032AAA8;
  *(_QWORD *)&v37[16] = qword_10032AAA8;
  if (!qword_10032AAA8)
  {
    v5 = sub_100189E08();
    v4 = dlsym(v5, "kSymptomDiagnosticReplySuccess");
    *(_QWORD *)(*(_QWORD *)v37 + 24) = v4;
    qword_10032AAA8 = (uint64_t)v4;
  }
  _Block_object_dispose(buf, 8);
  if (!v4)
  {
    v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
    v35 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "NSString *const getkSymptomDiagnosticReplySuccess(void)"));
    objc_msgSend(v34, "handleFailureInFunction:file:lineNumber:description:", v35, CFSTR("NFBugCapture.m"), 39, CFSTR("%s"), dlerror());

    __break(1u);
  }
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKeyedSubscript:", *v4));
  v7 = objc_msgSend(v6, "BOOLValue");

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  v10 = (void (*)(uint64_t, const char *, ...))Logger;
  if (v7)
  {
    if (Logger)
    {
      Class = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(Class))
        v12 = 43;
      else
        v12 = 45;
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 40));
      v10(6, "%c[%{public}s %{public}s]:%i ABC Request submitted successfully", v12, ClassName, Name, 500);
    }
    v15 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v16 = NFSharedLogGetLogger(v15);
    v17 = objc_claimAutoreleasedReturnValue(v16);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      v18 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v18))
        v19 = 43;
      else
        v19 = 45;
      v20 = object_getClassName(*(id *)(a1 + 32));
      v21 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)&buf[4] = v19;
      *(_WORD *)v37 = 2082;
      *(_QWORD *)&v37[2] = v20;
      *(_WORD *)&v37[10] = 2082;
      *(_QWORD *)&v37[12] = v21;
      *(_WORD *)&v37[20] = 1024;
      *(_DWORD *)&v37[22] = 500;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ABC Request submitted successfully", buf, 0x22u);
    }
  }
  else
  {
    if (Logger)
    {
      v22 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v22))
        v23 = 43;
      else
        v23 = 45;
      v24 = object_getClassName(*(id *)(a1 + 32));
      v25 = sel_getName(*(SEL *)(a1 + 40));
      v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("reason")));
      v10(3, "%c[%{public}s %{public}s]:%i ABC Request was rejected. Reason Code: %{public}@", v23, v24, v25, 502, v26);

    }
    v27 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v28 = NFSharedLogGetLogger(v27);
    v17 = objc_claimAutoreleasedReturnValue(v28);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      v29 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v29))
        v30 = 43;
      else
        v30 = 45;
      v31 = object_getClassName(*(id *)(a1 + 32));
      v32 = sel_getName(*(SEL *)(a1 + 40));
      v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("reason")));
      *(_DWORD *)buf = 67110146;
      *(_DWORD *)&buf[4] = v30;
      *(_WORD *)v37 = 2082;
      *(_QWORD *)&v37[2] = v31;
      *(_WORD *)&v37[10] = 2082;
      *(_QWORD *)&v37[12] = v32;
      *(_WORD *)&v37[20] = 1024;
      *(_DWORD *)&v37[22] = 502;
      v38 = 2114;
      v39 = v33;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i ABC Request was rejected. Reason Code: %{public}@", buf, 0x2Cu);

    }
  }

}

void sub_100189998(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *sub_100189C10(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *result;
  void *v5;
  __int128 v6;
  uint64_t v7;

  v5 = 0;
  if (!qword_10032AAC0)
  {
    v6 = off_1002EA110;
    v7 = 0;
    qword_10032AAC0 = _sl_dlopen(&v6, &v5);
  }
  v2 = (void *)qword_10032AAC0;
  if (!qword_10032AAC0)
  {
    a1 = (_QWORD *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
    v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "void *SpringBoardServicesLibrary(void)"));
    objc_msgSend(a1, "handleFailureInFunction:file:lineNumber:description:", v2, CFSTR("NFBugCapture.m"), 42, CFSTR("%s"), v5);

    __break(1u);
    goto LABEL_7;
  }
  v3 = v5;
  if (v5)
LABEL_7:
    free(v3);
  result = dlsym(v2, "SBUserNotificationDismissOnLock");
  *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = result;
  qword_10032AAC8 = *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
  return result;
}

void sub_100189D44(uint64_t a1)
{
  void *v2;
  void *v3;

  sub_100189E08();
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = objc_getClass("SDRDiagnosticReporter");
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    qword_10032AA98 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  else
  {
    v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Class getSDRDiagnosticReporterClass(void)_block_invoke"));
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, CFSTR("NFBugCapture.m"), 38, CFSTR("Unable to find class %s"), "SDRDiagnosticReporter");

    __break(1u);
  }
}

void *sub_100189E08()
{
  void *v0;
  void *v1;
  void *v3;
  void *v4;
  __int128 v5;
  uint64_t v6;

  v4 = 0;
  if (!qword_10032AAA0)
  {
    v5 = off_1002EA128;
    v6 = 0;
    qword_10032AAA0 = _sl_dlopen(&v5, &v4);
  }
  v0 = (void *)qword_10032AAA0;
  if (!qword_10032AAA0)
  {
    v0 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "void *SymptomDiagnosticReporterLibrary(void)"));
    objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", v3, CFSTR("NFBugCapture.m"), 37, CFSTR("%s"), v4);

    __break(1u);
    goto LABEL_7;
  }
  v1 = v4;
  if (v4)
LABEL_7:
    free(v1);
  return v0;
}

void sub_100189F0C(void *a1)
{
  void *v2;
  char v3;
  uint64_t v4;
  void *v5;
  id v6;

  if (a1)
  {
    v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "driverWrapper"));
    v3 = sub_100197958((uint64_t)v2);

    v4 = v3 & 0x1E;
    if (v4)
    {
      if ((byte_10032AAD0 & 1) != 0)
        return;
      v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "driverWrapper"));
      v6 = sub_1001F84C8(v5, CFSTR("LPEM features"), 1uLL);
    }
    else
    {
      if (!byte_10032AAD0)
        return;
      v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "driverWrapper"));
      sub_1001FABB8(v5, CFSTR("LPEM features"));
    }

    byte_10032AAD0 = v4 != 0;
  }
}

uint64_t sub_10018A0BC(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_10018A0CC(uint64_t a1)
{

}

void sub_10018A0D4(uint64_t a1)
{
  void *v2;
  void *v3;
  char v4;
  uint64_t v5;
  unsigned __int8 *v6;
  int v7;
  void *specific;
  uint64_t Logger;
  void (*v10)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  NSObject *v17;
  objc_class *v18;
  int v19;
  const char *v20;
  const char *v21;
  uint64_t v22;
  id v23;
  void *v24;
  void *v25;
  id v26;
  id v27;
  void *v28;
  void *v29;
  void *v30;
  uint64_t v31;
  id v32;
  id v33;
  id v34;
  void *v35;
  id v36;
  void *v37;
  uint64_t v38;
  void (*v39)(uint64_t, const char *, ...);
  objc_class *v40;
  _BOOL4 v41;
  uint64_t v42;
  void *v43;
  uint64_t v44;
  NSObject *v45;
  objc_class *v46;
  int v47;
  const char *v48;
  const char *v49;
  uint64_t v50;
  id v51;
  void *v52;
  id v53;
  uint64_t v54;
  objc_class *v55;
  _BOOL4 v56;
  const char *v57;
  const char *v58;
  uint64_t v59;
  void *v60;
  uint64_t v61;
  NSObject *v62;
  objc_class *v63;
  int v64;
  const char *v65;
  const char *v66;
  unsigned int v67;
  uint64_t v68;
  void *v69;
  char v70;
  uint64_t v71;
  void *v72;
  uint64_t v73;
  void *v74;
  uint64_t v75;
  void (*v76)(uint64_t, const char *, ...);
  objc_class *v77;
  _BOOL4 v78;
  const char *v79;
  uint64_t v80;
  void *v81;
  uint64_t v82;
  NSObject *v83;
  objc_class *v84;
  int v85;
  const char *v86;
  const char *v87;
  void *v88;
  void *v89;
  id v90;
  void *v91;
  id v92;
  id v93;
  void *v94;
  id v95;
  id v96;
  id v97;
  void *v98;
  id v99;
  const char *v100;
  const char *Name;
  const char *v102;
  const char *v103;
  id v104;
  _QWORD v105[2];
  _QWORD v106[2];
  uint8_t buf[4];
  int v108;
  __int16 v109;
  const char *v110;
  __int16 v111;
  const char *v112;
  __int16 v113;
  int v114;
  __int16 v115;
  _BYTE v116[10];
  uint64_t v117;
  _QWORD v118[4];
  _QWORD v119[4];
  _QWORD v120[5];
  _QWORD v121[5];
  _QWORD v122[4];
  _QWORD v123[4];
  _QWORD v124[4];
  _QWORD v125[4];
  _QWORD v126[4];
  _QWORD v127[4];

  if (-[_NFHardwareManager getPrimaryHardwareState]_0(*(_QWORD *)(a1 + 32)) != 2)
  {
    v22 = *(_QWORD *)(a1 + 40);
    v32 = objc_alloc((Class)NSError);
    v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v126[0] = NSLocalizedDescriptionKey;
    v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
    v127[0] = v25;
    v127[1] = &off_1003006B0;
    v126[1] = CFSTR("Line");
    v126[2] = CFSTR("Method");
    v26 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v127[2] = v26;
    v126[3] = NSDebugDescriptionErrorKey;
    v27 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 54);
    v127[3] = v27;
    v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v127, v126, 4));
    v29 = v32;
    v30 = v24;
    v31 = 58;
LABEL_20:
    v34 = objc_msgSend(v29, "initWithDomain:code:userInfo:", v30, v31, v28);
    (*(void (**)(uint64_t, id))(v22 + 16))(v22, v34);

    goto LABEL_21;
  }
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "controllerInfo"));
  if ((objc_msgSend(v2, "hasLPEMSupport") & 1) == 0)
  {

    goto LABEL_19;
  }
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "driverWrapper"));
  v4 = sub_1001979A4((uint64_t)v3, *(_QWORD *)(a1 + 64));

  if ((v4 & 1) == 0)
  {
LABEL_19:
    v22 = *(_QWORD *)(a1 + 40);
    v33 = objc_alloc((Class)NSError);
    v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v124[0] = NSLocalizedDescriptionKey;
    v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Feature Not Supported"));
    v125[0] = v25;
    v125[1] = &off_1003006C8;
    v124[1] = CFSTR("Line");
    v124[2] = CFSTR("Method");
    v26 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v125[2] = v26;
    v124[3] = NSDebugDescriptionErrorKey;
    v27 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 59);
    v125[3] = v27;
    v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v125, v124, 4));
    v29 = v33;
    v30 = v24;
    v31 = 14;
    goto LABEL_20;
  }
  v5 = *(_QWORD *)(a1 + 32);
  if (v5)
  {
    v6 = (unsigned __int8 *)*(id *)(v5 + 24);
    if (v6)
    {
      v7 = v6[172];

      if (v7)
      {
        specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        Logger = NFLogGetLogger(specific);
        if (Logger)
        {
          v10 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(*(id *)(a1 + 32));
          isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(*(id *)(a1 + 32));
          Name = sel_getName(*(SEL *)(a1 + 56));
          v14 = 45;
          if (isMetaClass)
            v14 = 43;
          v10(5, "%c[%{public}s %{public}s]:%i Cannot disable LPEM feature when express mode is active", v14, ClassName, Name, 64);
        }
        v15 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v16 = NFSharedLogGetLogger(v15);
        v17 = objc_claimAutoreleasedReturnValue(v16);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          v18 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v18))
            v19 = 43;
          else
            v19 = 45;
          v20 = object_getClassName(*(id *)(a1 + 32));
          v21 = sel_getName(*(SEL *)(a1 + 56));
          *(_DWORD *)buf = 67109890;
          v108 = v19;
          v109 = 2082;
          v110 = v20;
          v111 = 2082;
          v112 = v21;
          v113 = 1024;
          v114 = 64;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Cannot disable LPEM feature when express mode is active", buf, 0x22u);
        }

        v22 = *(_QWORD *)(a1 + 40);
        v23 = objc_alloc((Class)NSError);
        v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v122[0] = NSLocalizedDescriptionKey;
        v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Busy"));
        v123[0] = v25;
        v123[1] = &off_1003006E0;
        v122[1] = CFSTR("Line");
        v122[2] = CFSTR("Method");
        v26 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
        v123[2] = v26;
        v122[3] = NSDebugDescriptionErrorKey;
        v27 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 65);
        v123[3] = v27;
        v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v123, v122, 4));
        v29 = v23;
        v30 = v24;
        v31 = 2;
        goto LABEL_20;
      }
    }
  }
  v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "driverWrapper"));
  v36 = sub_1001F84C8(v35, CFSTR("LPEM feature change"), 1uLL);
  v24 = (void *)objc_claimAutoreleasedReturnValue(v36);

  v37 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v38 = NFLogGetLogger(v37);
  v39 = (void (*)(uint64_t, const char *, ...))v38;
  if (v24)
  {
    if (v38)
    {
      v40 = object_getClass(*(id *)(a1 + 32));
      v41 = class_isMetaClass(v40);
      v100 = object_getClassName(*(id *)(a1 + 32));
      v102 = sel_getName(*(SEL *)(a1 + 56));
      v42 = 45;
      if (v41)
        v42 = 43;
      v39(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v42, v100, v102, 71, v24);
    }
    v43 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v44 = NFSharedLogGetLogger(v43);
    v45 = objc_claimAutoreleasedReturnValue(v44);
    if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
    {
      v46 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v46))
        v47 = 43;
      else
        v47 = 45;
      v48 = object_getClassName(*(id *)(a1 + 32));
      v49 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)buf = 67110146;
      v108 = v47;
      v109 = 2082;
      v110 = v48;
      v111 = 2082;
      v112 = v49;
      v113 = 1024;
      v114 = 71;
      v115 = 2112;
      *(_QWORD *)v116 = v24;
      _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
    }

    v50 = *(_QWORD *)(a1 + 40);
    v51 = objc_alloc((Class)NSError);
    v52 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v53 = objc_msgSend(v24, "code");
    v120[0] = NSLocalizedDescriptionKey;
    if ((uint64_t)objc_msgSend(v24, "code") > 70)
      v54 = 71;
    else
      v54 = (uint64_t)objc_msgSend(v24, "code");
    v91 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002EA140[v54]));
    v121[0] = v91;
    v121[1] = v24;
    v120[1] = NSUnderlyingErrorKey;
    v120[2] = CFSTR("Line");
    v121[2] = &off_1003006F8;
    v120[3] = CFSTR("Method");
    v92 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v121[3] = v92;
    v120[4] = NSDebugDescriptionErrorKey;
    v93 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 72);
    v121[4] = v93;
    v94 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v121, v120, 5));
    v95 = objc_msgSend(v51, "initWithDomain:code:userInfo:", v52, v53, v94);
    (*(void (**)(uint64_t, id))(v50 + 16))(v50, v95);

  }
  else
  {
    if (v38)
    {
      v55 = object_getClass(*(id *)(a1 + 32));
      v56 = class_isMetaClass(v55);
      v57 = object_getClassName(*(id *)(a1 + 32));
      v58 = sel_getName(*(SEL *)(a1 + 56));
      v104 = objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40), "processIdentifier");
      v59 = 45;
      if (v56)
        v59 = 43;
      v39(6, "%c[%{public}s %{public}s]:%i PID %d disabling feature %d", v59, v57, v58, 76, v104, *(_QWORD *)(a1 + 64));
    }
    v60 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v61 = NFSharedLogGetLogger(v60);
    v62 = objc_claimAutoreleasedReturnValue(v61);
    if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
    {
      v63 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v63))
        v64 = 43;
      else
        v64 = 45;
      v65 = object_getClassName(*(id *)(a1 + 32));
      v66 = sel_getName(*(SEL *)(a1 + 56));
      v67 = objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40), "processIdentifier");
      v68 = *(_QWORD *)(a1 + 64);
      *(_DWORD *)buf = 67110402;
      v108 = v64;
      v109 = 2082;
      v110 = v65;
      v111 = 2082;
      v112 = v66;
      v113 = 1024;
      v114 = 76;
      v115 = 1024;
      *(_DWORD *)v116 = v67;
      *(_WORD *)&v116[4] = 1024;
      *(_DWORD *)&v116[6] = v68;
      _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i PID %d disabling feature %d", buf, 0x2Eu);
    }

    v69 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "driverWrapper"));
    v70 = sub_1001980AC((uint64_t)v69, *(_QWORD *)(a1 + 64));

    v71 = *(_QWORD *)(a1 + 40);
    if ((v70 & 1) != 0)
    {
      (*(void (**)(_QWORD, _QWORD))(v71 + 16))(*(_QWORD *)(a1 + 40), 0);
      sub_100189F0C(*(void **)(a1 + 32));
      v72 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "driverWrapper"));
      v73 = sub_100197958((uint64_t)v72);

      v74 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v75 = NFLogGetLogger(v74);
      if (v75)
      {
        v76 = (void (*)(uint64_t, const char *, ...))v75;
        v77 = object_getClass(*(id *)(a1 + 32));
        v78 = class_isMetaClass(v77);
        v79 = object_getClassName(*(id *)(a1 + 32));
        v103 = sel_getName(*(SEL *)(a1 + 56));
        v80 = 45;
        if (v78)
          v80 = 43;
        v76(6, "%c[%{public}s %{public}s]:%i posting %{public}@ to SESD - current state %lx", v80, v79, v103, 83, CFSTR("com.apple.stockholm.lpem.changed"), v73);
      }
      v81 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v82 = NFSharedLogGetLogger(v81);
      v83 = objc_claimAutoreleasedReturnValue(v82);
      if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT))
      {
        v84 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v84))
          v85 = 43;
        else
          v85 = 45;
        v86 = object_getClassName(*(id *)(a1 + 32));
        v87 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)buf = 67110402;
        v108 = v85;
        v109 = 2082;
        v110 = v86;
        v111 = 2082;
        v112 = v87;
        v113 = 1024;
        v114 = 83;
        v115 = 2114;
        *(_QWORD *)v116 = CFSTR("com.apple.stockholm.lpem.changed");
        *(_WORD *)&v116[8] = 2048;
        v117 = v73;
        _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i posting %{public}@ to SESD - current state %lx", buf, 0x36u);
      }

      v88 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sesdEventPublisher"));
      v105[0] = CFSTR("Payload");
      v105[1] = CFSTR("lpemFeatures");
      v106[0] = CFSTR("com.apple.stockholm.lpem.changed");
      v89 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", v73));
      v106[1] = v89;
      v90 = (id)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v106, v105, 2));
      objc_msgSend(v88, "sendXpcNotificationEventWithDictionary:", v90);
    }
    else
    {
      v96 = objc_alloc((Class)NSError);
      v88 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v118[0] = NSLocalizedDescriptionKey;
      v89 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
      v119[0] = v89;
      v119[1] = &off_100300710;
      v118[1] = CFSTR("Line");
      v118[2] = CFSTR("Method");
      v90 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
      v119[2] = v90;
      v118[3] = NSDebugDescriptionErrorKey;
      v97 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 78);
      v119[3] = v97;
      v98 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v119, v118, 4));
      v99 = objc_msgSend(v96, "initWithDomain:code:userInfo:", v88, 15, v98);
      (*(void (**)(uint64_t, id))(v71 + 16))(v71, v99);

    }
    v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "driverWrapper"));
    sub_1001FABB8(v24, CFSTR("LPEM feature change"));
  }
LABEL_21:

}

void sub_10018ADF4(uint64_t a1, uint64_t a2, char a3, void *a4)
{
  id v7;
  NSObject *v8;
  _QWORD v9[5];
  id v10;
  _QWORD *v11;
  const char *v12;
  uint64_t v13;
  char v14;
  _QWORD v15[5];
  id v16;

  v7 = a4;
  if (a1)
  {
    v15[0] = 0;
    v15[1] = v15;
    v15[2] = 0x3032000000;
    v15[3] = sub_10018A0BC;
    v15[4] = sub_10018A0CC;
    v16 = (id)objc_claimAutoreleasedReturnValue(+[NSXPCConnection currentConnection](NSXPCConnection, "currentConnection"));
    v8 = *(id *)(a1 + 232);
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    v9[2] = sub_10018AF04;
    v9[3] = &unk_1002EA3B0;
    v9[4] = a1;
    v12 = "enableLPEMFeature:rebootIfNeeded:completion:";
    v13 = a2;
    v14 = a3;
    v10 = v7;
    v11 = v15;
    dispatch_async(v8, v9);

    _Block_object_dispose(v15, 8);
  }

}

void sub_10018AF04(uint64_t a1)
{
  void *v2;
  void *v3;
  char v4;
  uint64_t v5;
  unsigned __int8 *v6;
  int v7;
  void *specific;
  uint64_t Logger;
  void (*v10)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  NSObject *v17;
  objc_class *v18;
  int v19;
  const char *v20;
  const char *v21;
  uint64_t v22;
  id v23;
  id v24;
  void *v25;
  id v26;
  id v27;
  void *v28;
  void *v29;
  id v30;
  uint64_t v31;
  id v32;
  id v33;
  id v34;
  void *v35;
  id v36;
  void *v37;
  uint64_t v38;
  void (*v39)(uint64_t, const char *, ...);
  objc_class *v40;
  _BOOL4 v41;
  uint64_t v42;
  void *v43;
  uint64_t v44;
  NSObject *v45;
  objc_class *v46;
  int v47;
  const char *v48;
  const char *v49;
  uint64_t v50;
  id v51;
  void *v52;
  id v53;
  uint64_t v54;
  void *v55;
  id v56;
  void *v57;
  char v58;
  void *v59;
  uint64_t v60;
  void *v61;
  id v62;
  id v63;
  _QWORD *v64;
  _QWORD *v65;
  void *v66;
  id v67;
  _BOOL4 v68;
  void *v69;
  uint64_t v70;
  void (*v71)(uint64_t, const char *, ...);
  objc_class *v72;
  _BOOL4 v73;
  const char *v74;
  const char *v75;
  uint64_t v76;
  void *v77;
  uint64_t v78;
  NSObject *v79;
  objc_class *v80;
  int v81;
  const char *v82;
  const char *v83;
  unsigned int v84;
  uint64_t v85;
  void *v86;
  char v87;
  uint64_t v88;
  void *v89;
  void *v90;
  uint64_t v91;
  void *v92;
  uint64_t v93;
  void (*v94)(uint64_t, const char *, ...);
  objc_class *v95;
  _BOOL4 v96;
  const char *v97;
  uint64_t v98;
  void *v99;
  uint64_t v100;
  NSObject *v101;
  objc_class *v102;
  int v103;
  const char *v104;
  const char *v105;
  void *v106;
  void *v107;
  id v108;
  id v109;
  id v110;
  void *v111;
  id v112;
  const char *v113;
  const char *Name;
  const char *v115;
  const char *v116;
  id v117;
  id v118;
  _QWORD v119[2];
  _QWORD v120[2];
  uint8_t buf[4];
  int v122;
  __int16 v123;
  const char *v124;
  __int16 v125;
  const char *v126;
  __int16 v127;
  int v128;
  __int16 v129;
  _BYTE v130[10];
  uint64_t v131;
  _QWORD v132[4];
  _QWORD v133[4];
  _QWORD v134[5];
  _QWORD v135[5];
  _QWORD v136[5];
  _QWORD v137[5];
  _QWORD v138[4];
  _QWORD v139[4];
  _QWORD v140[4];
  _QWORD v141[4];
  _QWORD v142[4];
  _QWORD v143[4];

  if (-[_NFHardwareManager getPrimaryHardwareState]_0(*(_QWORD *)(a1 + 32)) != 2)
  {
    v22 = *(_QWORD *)(a1 + 40);
    v32 = objc_alloc((Class)NSError);
    v24 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v142[0] = NSLocalizedDescriptionKey;
    v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
    v143[0] = v25;
    v143[1] = &off_100300728;
    v142[1] = CFSTR("Line");
    v142[2] = CFSTR("Method");
    v26 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v143[2] = v26;
    v142[3] = NSDebugDescriptionErrorKey;
    v27 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 104);
    v143[3] = v27;
    v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v143, v142, 4));
    v29 = v32;
    v30 = v24;
    v31 = 58;
LABEL_20:
    v34 = objc_msgSend(v29, "initWithDomain:code:userInfo:", v30, v31, v28);
    (*(void (**)(uint64_t, id))(v22 + 16))(v22, v34);

    goto LABEL_21;
  }
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "controllerInfo"));
  if ((objc_msgSend(v2, "hasLPEMSupport") & 1) == 0)
  {

    goto LABEL_19;
  }
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "driverWrapper"));
  v4 = sub_1001979A4((uint64_t)v3, *(_QWORD *)(a1 + 64));

  if ((v4 & 1) == 0)
  {
LABEL_19:
    v22 = *(_QWORD *)(a1 + 40);
    v33 = objc_alloc((Class)NSError);
    v24 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v140[0] = NSLocalizedDescriptionKey;
    v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Feature Not Supported"));
    v141[0] = v25;
    v141[1] = &off_100300740;
    v140[1] = CFSTR("Line");
    v140[2] = CFSTR("Method");
    v26 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v141[2] = v26;
    v140[3] = NSDebugDescriptionErrorKey;
    v27 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 109);
    v141[3] = v27;
    v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v141, v140, 4));
    v29 = v33;
    v30 = v24;
    v31 = 14;
    goto LABEL_20;
  }
  v5 = *(_QWORD *)(a1 + 32);
  if (v5)
  {
    v6 = (unsigned __int8 *)*(id *)(v5 + 24);
    if (v6)
    {
      v7 = v6[172];

      if (v7)
      {
        specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        Logger = NFLogGetLogger(specific);
        if (Logger)
        {
          v10 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(*(id *)(a1 + 32));
          isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(*(id *)(a1 + 32));
          Name = sel_getName(*(SEL *)(a1 + 56));
          v14 = 45;
          if (isMetaClass)
            v14 = 43;
          v10(5, "%c[%{public}s %{public}s]:%i Cannot enable LPEM feature when express mode is active", v14, ClassName, Name, 114);
        }
        v15 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v16 = NFSharedLogGetLogger(v15);
        v17 = objc_claimAutoreleasedReturnValue(v16);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          v18 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v18))
            v19 = 43;
          else
            v19 = 45;
          v20 = object_getClassName(*(id *)(a1 + 32));
          v21 = sel_getName(*(SEL *)(a1 + 56));
          *(_DWORD *)buf = 67109890;
          v122 = v19;
          v123 = 2082;
          v124 = v20;
          v125 = 2082;
          v126 = v21;
          v127 = 1024;
          v128 = 114;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Cannot enable LPEM feature when express mode is active", buf, 0x22u);
        }

        v22 = *(_QWORD *)(a1 + 40);
        v23 = objc_alloc((Class)NSError);
        v24 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v138[0] = NSLocalizedDescriptionKey;
        v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Busy"));
        v139[0] = v25;
        v139[1] = &off_100300758;
        v138[1] = CFSTR("Line");
        v138[2] = CFSTR("Method");
        v26 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
        v139[2] = v26;
        v138[3] = NSDebugDescriptionErrorKey;
        v27 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 115);
        v139[3] = v27;
        v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v139, v138, 4));
        v29 = v23;
        v30 = v24;
        v31 = 2;
        goto LABEL_20;
      }
    }
  }
  v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "driverWrapper"));
  v36 = sub_1001F84C8(v35, CFSTR("LPEM feature change"), 1uLL);
  v24 = (id)objc_claimAutoreleasedReturnValue(v36);

  if (v24)
  {
    v37 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v38 = NFLogGetLogger(v37);
    if (v38)
    {
      v39 = (void (*)(uint64_t, const char *, ...))v38;
      v40 = object_getClass(*(id *)(a1 + 32));
      v41 = class_isMetaClass(v40);
      v113 = object_getClassName(*(id *)(a1 + 32));
      v115 = sel_getName(*(SEL *)(a1 + 56));
      v42 = 45;
      if (v41)
        v42 = 43;
      v39(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v42, v113, v115, 121, v24);
    }
    v43 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v44 = NFSharedLogGetLogger(v43);
    v45 = objc_claimAutoreleasedReturnValue(v44);
    if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
    {
      v46 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v46))
        v47 = 43;
      else
        v47 = 45;
      v48 = object_getClassName(*(id *)(a1 + 32));
      v49 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)buf = 67110146;
      v122 = v47;
      v123 = 2082;
      v124 = v48;
      v125 = 2082;
      v126 = v49;
      v127 = 1024;
      v128 = 121;
      v129 = 2112;
      *(_QWORD *)v130 = v24;
      _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
    }

    v50 = *(_QWORD *)(a1 + 40);
    v51 = objc_alloc((Class)NSError);
    v52 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v53 = objc_msgSend(v24, "code");
    v136[0] = NSLocalizedDescriptionKey;
    if ((uint64_t)objc_msgSend(v24, "code") > 70)
      v54 = 71;
    else
      v54 = (uint64_t)objc_msgSend(v24, "code");
    v61 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002EA140[v54]));
    v137[0] = v61;
    v137[1] = v24;
    v136[1] = NSUnderlyingErrorKey;
    v136[2] = CFSTR("Line");
    v137[2] = &off_100300770;
    v136[3] = CFSTR("Method");
    v62 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v137[3] = v62;
    v136[4] = NSDebugDescriptionErrorKey;
    v63 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 122);
    v137[4] = v63;
    v64 = v137;
    v65 = v136;
    goto LABEL_41;
  }
  v55 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "controllerInfo"));
  v56 = objc_msgSend(v55, "siliconName");

  if (v56 == (id)18 || !*(_BYTE *)(a1 + 72))
  {
    v68 = 0;
  }
  else
  {
    v57 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "driverWrapper"));
    v118 = 0;
    v58 = sub_100198F98(v57, &v118);
    v24 = v118;

    if (v24)
    {
      v59 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "driverWrapper"));
      sub_1001FABB8(v59, CFSTR("LPEM feature change"));

      v50 = *(_QWORD *)(a1 + 40);
      v51 = objc_alloc((Class)NSError);
      v52 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v53 = objc_msgSend(v24, "code");
      v134[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)objc_msgSend(v24, "code") > 70)
        v60 = 71;
      else
        v60 = (uint64_t)objc_msgSend(v24, "code");
      v61 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002EA140[v60]));
      v135[0] = v61;
      v135[1] = v24;
      v134[1] = NSUnderlyingErrorKey;
      v134[2] = CFSTR("Line");
      v135[2] = &off_100300788;
      v134[3] = CFSTR("Method");
      v62 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
      v135[3] = v62;
      v134[4] = NSDebugDescriptionErrorKey;
      v63 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 133);
      v135[4] = v63;
      v64 = v135;
      v65 = v134;
LABEL_41:
      v66 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v64, v65, 5));
      v67 = objc_msgSend(v51, "initWithDomain:code:userInfo:", v52, v53, v66);
      (*(void (**)(uint64_t, id))(v50 + 16))(v50, v67);

      goto LABEL_21;
    }
    v68 = (v58 & 1) == 0;
  }
  v69 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v70 = NFLogGetLogger(v69);
  if (v70)
  {
    v71 = (void (*)(uint64_t, const char *, ...))v70;
    v72 = object_getClass(*(id *)(a1 + 32));
    v73 = class_isMetaClass(v72);
    v74 = object_getClassName(*(id *)(a1 + 32));
    v75 = sel_getName(*(SEL *)(a1 + 56));
    v117 = objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40), "processIdentifier");
    v76 = 45;
    if (v73)
      v76 = 43;
    v71(6, "%c[%{public}s %{public}s]:%i PID %d enabling feature %d", v76, v74, v75, 142, v117, *(_QWORD *)(a1 + 64));
  }
  v77 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v78 = NFSharedLogGetLogger(v77);
  v79 = objc_claimAutoreleasedReturnValue(v78);
  if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
  {
    v80 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v80))
      v81 = 43;
    else
      v81 = 45;
    v82 = object_getClassName(*(id *)(a1 + 32));
    v83 = sel_getName(*(SEL *)(a1 + 56));
    v84 = objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40), "processIdentifier");
    v85 = *(_QWORD *)(a1 + 64);
    *(_DWORD *)buf = 67110402;
    v122 = v81;
    v123 = 2082;
    v124 = v82;
    v125 = 2082;
    v126 = v83;
    v127 = 1024;
    v128 = 142;
    v129 = 1024;
    *(_DWORD *)v130 = v84;
    *(_WORD *)&v130[4] = 1024;
    *(_DWORD *)&v130[6] = v85;
    _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i PID %d enabling feature %d", buf, 0x2Eu);
  }

  v86 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "driverWrapper"));
  v87 = sub_100197C58(v86, *(_QWORD *)(a1 + 64));

  v88 = *(_QWORD *)(a1 + 40);
  if ((v87 & 1) != 0)
  {
    (*(void (**)(_QWORD, _QWORD))(v88 + 16))(*(_QWORD *)(a1 + 40), 0);
    sub_100189F0C(*(void **)(a1 + 32));
    if (v68)
    {
      v89 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "driverWrapper"));
      sub_1001FB970(v89);

    }
    v90 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "driverWrapper"));
    v91 = sub_100197958((uint64_t)v90);

    v92 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v93 = NFLogGetLogger(v92);
    if (v93)
    {
      v94 = (void (*)(uint64_t, const char *, ...))v93;
      v95 = object_getClass(*(id *)(a1 + 32));
      v96 = class_isMetaClass(v95);
      v97 = object_getClassName(*(id *)(a1 + 32));
      v116 = sel_getName(*(SEL *)(a1 + 56));
      v98 = 45;
      if (v96)
        v98 = 43;
      v94(6, "%c[%{public}s %{public}s]:%i posting %{public}@ to SESD - current state %lx", v98, v97, v116, 152, CFSTR("com.apple.stockholm.lpem.changed"), v91);
    }
    v99 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v100 = NFSharedLogGetLogger(v99);
    v101 = objc_claimAutoreleasedReturnValue(v100);
    if (os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT))
    {
      v102 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v102))
        v103 = 43;
      else
        v103 = 45;
      v104 = object_getClassName(*(id *)(a1 + 32));
      v105 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)buf = 67110402;
      v122 = v103;
      v123 = 2082;
      v124 = v104;
      v125 = 2082;
      v126 = v105;
      v127 = 1024;
      v128 = 152;
      v129 = 2114;
      *(_QWORD *)v130 = CFSTR("com.apple.stockholm.lpem.changed");
      *(_WORD *)&v130[8] = 2048;
      v131 = v91;
      _os_log_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i posting %{public}@ to SESD - current state %lx", buf, 0x36u);
    }

    v106 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sesdEventPublisher"));
    v119[0] = CFSTR("Payload");
    v119[1] = CFSTR("lpemFeatures");
    v120[0] = CFSTR("com.apple.stockholm.lpem.changed");
    v107 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", v91));
    v120[1] = v107;
    v108 = (id)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v120, v119, 2));
    objc_msgSend(v106, "sendXpcNotificationEventWithDictionary:", v108);
  }
  else
  {
    v109 = objc_alloc((Class)NSError);
    v106 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v132[0] = NSLocalizedDescriptionKey;
    v107 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
    v133[0] = v107;
    v133[1] = &off_1003007A0;
    v132[1] = CFSTR("Line");
    v132[2] = CFSTR("Method");
    v108 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v133[2] = v108;
    v132[3] = NSDebugDescriptionErrorKey;
    v110 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 144);
    v133[3] = v110;
    v111 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v133, v132, 4));
    v112 = objc_msgSend(v109, "initWithDomain:code:userInfo:", v106, 15, v111);
    (*(void (**)(uint64_t, id))(v88 + 16))(v88, v112);

  }
  v24 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "driverWrapper"));
  sub_1001FABB8(v24, CFSTR("LPEM feature change"));
LABEL_21:

}

void sub_10018BE3C(uint64_t a1, void *a2)
{
  id v3;
  NSObject *v4;
  _QWORD v5[5];
  id v6;
  _QWORD *v7;
  const char *v8;
  _QWORD v9[5];
  id v10;

  v3 = a2;
  if (a1)
  {
    v9[0] = 0;
    v9[1] = v9;
    v9[2] = 0x3032000000;
    v9[3] = sub_10018A0BC;
    v9[4] = sub_10018A0CC;
    v10 = (id)objc_claimAutoreleasedReturnValue(+[NSXPCConnection currentConnection](NSXPCConnection, "currentConnection"));
    v4 = *(id *)(a1 + 232);
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    v5[2] = sub_10018BF38;
    v5[3] = &unk_1002EA3D8;
    v5[4] = a1;
    v7 = v9;
    v8 = "getLPEMFeaturesWithCompletion:";
    v6 = v3;
    dispatch_async(v4, v5);

    _Block_object_dispose(v9, 8);
  }

}

void sub_10018BF38(uint64_t a1)
{
  void *v2;
  unsigned __int8 v3;
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  objc_class *v15;
  int v16;
  const char *v17;
  const char *v18;
  unsigned int v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  id v24;
  void *v25;
  id v26;
  id v27;
  void *v28;
  void *v29;
  void *v30;
  uint64_t v31;
  id v32;
  id v33;
  id v34;
  uint8_t buf[4];
  int v36;
  __int16 v37;
  const char *v38;
  __int16 v39;
  const char *v40;
  __int16 v41;
  int v42;
  __int16 v43;
  unsigned int v44;
  _QWORD v45[4];
  _QWORD v46[4];
  _QWORD v47[4];
  _QWORD v48[4];

  if (-[_NFHardwareManager getPrimaryHardwareState]_0(*(_QWORD *)(a1 + 32)) != 2)
  {
    v23 = *(_QWORD *)(a1 + 40);
    v24 = objc_alloc((Class)NSError);
    v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v47[0] = NSLocalizedDescriptionKey;
    v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
    v48[0] = v25;
    v48[1] = &off_1003007B8;
    v47[1] = CFSTR("Line");
    v47[2] = CFSTR("Method");
    v26 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v48[2] = v26;
    v47[3] = NSDebugDescriptionErrorKey;
    v27 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 175);
    v48[3] = v27;
    v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v48, v47, 4));
    v29 = v24;
    v30 = v21;
    v31 = 58;
LABEL_15:
    v33 = objc_msgSend(v29, "initWithDomain:code:userInfo:", v30, v31, v28);
    (*(void (**)(uint64_t, id, _QWORD))(v23 + 16))(v23, v33, 0);

    goto LABEL_16;
  }
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "controllerInfo"));
  v3 = objc_msgSend(v2, "hasLPEMSupport");

  if ((v3 & 1) == 0)
  {
    v23 = *(_QWORD *)(a1 + 40);
    v32 = objc_alloc((Class)NSError);
    v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v45[0] = NSLocalizedDescriptionKey;
    v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Feature Not Supported"));
    v46[0] = v25;
    v46[1] = &off_1003007D0;
    v45[1] = CFSTR("Line");
    v45[2] = CFSTR("Method");
    v26 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
    v46[2] = v26;
    v45[3] = NSDebugDescriptionErrorKey;
    v27 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 180);
    v46[3] = v27;
    v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v46, v45, 4));
    v29 = v32;
    v30 = v21;
    v31 = 14;
    goto LABEL_15;
  }
  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v6 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    v34 = objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40), "processIdentifier");
    v11 = 45;
    if (isMetaClass)
      v11 = 43;
    v6(6, "%c[%{public}s %{public}s]:%i PID %d getting LPEM features", v11, ClassName, Name, 184, v34);
  }
  v12 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v13 = NFSharedLogGetLogger(v12);
  v14 = objc_claimAutoreleasedReturnValue(v13);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    v15 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v15))
      v16 = 43;
    else
      v16 = 45;
    v17 = object_getClassName(*(id *)(a1 + 32));
    v18 = sel_getName(*(SEL *)(a1 + 56));
    v19 = objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40), "processIdentifier");
    *(_DWORD *)buf = 67110146;
    v36 = v16;
    v37 = 2082;
    v38 = v17;
    v39 = 2082;
    v40 = v18;
    v41 = 1024;
    v42 = 184;
    v43 = 1024;
    v44 = v19;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i PID %d getting LPEM features", buf, 0x28u);
  }

  v20 = *(_QWORD *)(a1 + 40);
  v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "driverWrapper"));
  v22 = sub_100197958((uint64_t)v21);
  (*(void (**)(uint64_t, _QWORD, uint64_t))(v20 + 16))(v20, 0, v22);
LABEL_16:

}

void sub_10018C454(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  void (**v3)(id, id);
  void *v4;
  unsigned __int8 v5;
  void *v6;
  id v7;
  void *v8;
  void *specific;
  uint64_t Logger;
  void (*v11)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  NSObject *v17;
  objc_class *v18;
  int v19;
  id v20;
  void *v21;
  id v22;
  uint64_t v23;
  id v24;
  id v25;
  id v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  id v31;
  id v32;
  void *v33;
  char v34;
  void *v35;
  void *v36;
  id v37;
  id v38;
  void *v39;
  id v40;
  id v41;
  void *v42;
  void *v43;
  id v44;
  id v45;
  void *v46;
  id v47;
  void *v48;
  const char *ClassName;
  const char *Name;
  NSErrorUserInfoKey v51;
  const __CFString *v52;
  const __CFString *v53;
  const __CFString *v54;
  NSErrorUserInfoKey v55;
  uint8_t buf[8];
  _BYTE v57[36];

  v1 = *(unsigned __int16 *)(a1 + 48);
  v2 = *(void **)(a1 + 32);
  v3 = (void (**)(id, id))*(id *)(a1 + 40);
  if (!v2)
    goto LABEL_20;
  if (-[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)v2) != 2)
  {
    v24 = objc_alloc((Class)NSError);
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v51 = NSLocalizedDescriptionKey;
    v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
    *(_QWORD *)buf = v21;
    *(_QWORD *)v57 = &off_1003007E8;
    v52 = CFSTR("Line");
    v53 = CFSTR("Method");
    v25 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_enableHeadlessTestMode:completion:"));
    *(_QWORD *)&v57[8] = v25;
    v54 = (const __CFString *)NSDebugDescriptionErrorKey;
    v26 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_enableHeadlessTestMode:completion:"), 209);
    *(_QWORD *)&v57[16] = v26;
    v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v51, 4));
    v28 = v24;
    v29 = v8;
    v30 = 58;
LABEL_18:
    v32 = objc_msgSend(v28, "initWithDomain:code:userInfo:", v29, v30, v27);
    v3[2](v3, v32);

LABEL_19:
    goto LABEL_20;
  }
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "controllerInfo"));
  v5 = objc_msgSend(v4, "hasLPEMSupport");

  if ((v5 & 1) == 0)
  {
    v31 = objc_alloc((Class)NSError);
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v51 = NSLocalizedDescriptionKey;
    v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Feature Not Supported"));
    *(_QWORD *)buf = v21;
    *(_QWORD *)v57 = &off_100300800;
    v52 = CFSTR("Line");
    v53 = CFSTR("Method");
    v25 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_enableHeadlessTestMode:completion:"));
    *(_QWORD *)&v57[8] = v25;
    v54 = (const __CFString *)NSDebugDescriptionErrorKey;
    v26 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_enableHeadlessTestMode:completion:"), 214);
    *(_QWORD *)&v57[16] = v26;
    v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v51, 4));
    v28 = v31;
    v29 = v8;
    v30 = 14;
    goto LABEL_18;
  }
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "driverWrapper"));
  v7 = sub_1001F84C8(v6, CFSTR("Headless Test Mode"), 1uLL);
  v8 = (void *)objc_claimAutoreleasedReturnValue(v7);

  if (v8)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v11 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v2);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(v2);
      Name = sel_getName("_sync_enableHeadlessTestMode:completion:");
      v14 = 45;
      if (isMetaClass)
        v14 = 43;
      v11(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v14, ClassName, Name, 220, v8);
    }
    v15 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v16 = NFSharedLogGetLogger(v15);
    v17 = objc_claimAutoreleasedReturnValue(v16);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      v18 = object_getClass(v2);
      if (class_isMetaClass(v18))
        v19 = 43;
      else
        v19 = 45;
      *(_DWORD *)buf = 67110146;
      *(_DWORD *)&buf[4] = v19;
      *(_WORD *)v57 = 2082;
      *(_QWORD *)&v57[2] = object_getClassName(v2);
      *(_WORD *)&v57[10] = 2082;
      *(_QWORD *)&v57[12] = sel_getName("_sync_enableHeadlessTestMode:completion:");
      *(_WORD *)&v57[20] = 1024;
      *(_DWORD *)&v57[22] = 220;
      *(_WORD *)&v57[26] = 2112;
      *(_QWORD *)&v57[28] = v8;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
    }

    v20 = objc_alloc((Class)NSError);
    v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v22 = objc_msgSend(v8, "code");
    v51 = NSLocalizedDescriptionKey;
    if ((uint64_t)objc_msgSend(v8, "code") > 70)
      v23 = 71;
    else
      v23 = (uint64_t)objc_msgSend(v8, "code");
    v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002EA140[v23]));
    *(_QWORD *)buf = v36;
    *(_QWORD *)v57 = v8;
    v52 = (const __CFString *)NSUnderlyingErrorKey;
    v53 = CFSTR("Line");
    *(_QWORD *)&v57[8] = &off_100300818;
    v54 = CFSTR("Method");
    v37 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_enableHeadlessTestMode:completion:"));
    *(_QWORD *)&v57[16] = v37;
    v55 = NSDebugDescriptionErrorKey;
    v38 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_enableHeadlessTestMode:completion:"), 221);
    *(_QWORD *)&v57[24] = v38;
    v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v51, 5));
    v40 = objc_msgSend(v20, "initWithDomain:code:userInfo:", v21, v22, v39);
    v3[2](v3, v40);

    goto LABEL_19;
  }
  v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "driverWrapper"));
  v34 = sub_100199270(v33, v1);

  if ((v34 & 1) != 0)
  {
    v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "driverWrapper"));
    sub_1001FABB8(v35, CFSTR("Headless Test Mode"));

    v3[2](v3, 0);
  }
  else
  {
    v41 = objc_alloc((Class)NSError);
    v42 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v51 = NSLocalizedDescriptionKey;
    v43 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
    *(_QWORD *)buf = v43;
    *(_QWORD *)v57 = &off_100300830;
    v52 = CFSTR("Line");
    v53 = CFSTR("Method");
    v44 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_enableHeadlessTestMode:completion:"));
    *(_QWORD *)&v57[8] = v44;
    v54 = (const __CFString *)NSDebugDescriptionErrorKey;
    v45 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_enableHeadlessTestMode:completion:"), 227);
    *(_QWORD *)&v57[16] = v45;
    v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v51, 4));
    v47 = objc_msgSend(v41, "initWithDomain:code:userInfo:", v42, 15, v46);
    v3[2](v3, v47);

    v48 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "driverWrapper"));
    sub_1001FABB8(v48, CFSTR("Headless Test Mode"));

  }
LABEL_20:

}

void sub_10018CD18(uint64_t a1)
{
  int v1;
  void *v2;
  id *v3;
  id v4;
  void (**v5)(id, id);
  void *v6;
  void *v7;
  void *v8;
  char v9;
  void *v10;
  id v11;
  void *v12;
  void *v13;
  uint64_t v14;
  void (*v15)(uint64_t, const char *, ...);
  objc_class *v16;
  _BOOL4 v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  NSObject *v21;
  objc_class *v22;
  int v23;
  id v24;
  void *v25;
  id v26;
  uint64_t v27;
  id v28;
  void *v29;
  void *v30;
  id v31;
  id v32;
  void *v33;
  id v34;
  void *specific;
  uint64_t Logger;
  void (*v37)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void (**v42)(id, id);
  id v43;
  id v44;
  void *v45;
  uint64_t v46;
  void *v47;
  uint64_t v48;
  NSObject *v49;
  objc_class *v50;
  int v51;
  const char *v52;
  const char *v53;
  unsigned int v54;
  void *v55;
  id v56;
  void *v57;
  void *v58;
  id v59;
  id v60;
  void *v61;
  void *v62;
  void *v63;
  uint64_t v64;
  id v65;
  id v66;
  unsigned __int8 *v67;
  unsigned __int8 *v68;
  void *v69;
  void *v70;
  uint64_t v71;
  void *v72;
  id v73;
  id v74;
  const char *v75;
  uint64_t v76;
  char v77;
  void *v78;
  id v79;
  id v80;
  const char *v81;
  uint64_t v82;
  id v83;
  void *v84;
  id v85;
  char v86;
  unsigned int v87;
  id v88;
  void *v89;
  void *v90;
  void *v91;
  const char *v92;
  const char *v93;
  id v94;
  id v95;
  void *v96;
  NSErrorUserInfoKey v97;
  const __CFString *v98;
  const __CFString *v99;
  const __CFString *v100;
  NSErrorUserInfoKey v101;
  uint8_t buf[8];
  _BYTE v103[42];
  __int16 v104;
  const char *v105;

  v1 = *(unsigned __int8 *)(a1 + 56);
  v2 = *(void **)(a1 + 40);
  v3 = *(id **)(a1 + 32);
  v4 = *(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40);
  v5 = v2;
  if (v3)
  {
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "NF_whitelistChecker"));
    if (-[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)v3) != 2)
    {
      v28 = objc_alloc((Class)NSError);
      v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v97 = NSLocalizedDescriptionKey;
      v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
      *(_QWORD *)buf = v30;
      *(_QWORD *)v103 = &off_100300848;
      v98 = CFSTR("Line");
      v99 = CFSTR("Method");
      v31 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:"));
      *(_QWORD *)&v103[8] = v31;
      v100 = (const __CFString *)NSDebugDescriptionErrorKey;
      v32 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:"), 257);
      *(_QWORD *)&v103[16] = v32;
      v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v97, 4));
      v34 = objc_msgSend(v28, "initWithDomain:code:userInfo:", v29, 58, v33);
      v5[2](v5, v34);

LABEL_33:
      goto LABEL_34;
    }
    v96 = v6;
    if ((objc_msgSend(v6, "lpmFactoryTest") & 1) == 0)
    {
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v37 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(v3);
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(v3);
        Name = sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:");
        v42 = v5;
        v43 = v4;
        v44 = objc_msgSend(v4, "processIdentifier");
        v45 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "clientName"));
        v94 = v44;
        v4 = v43;
        v5 = v42;
        v46 = 43;
        if (!isMetaClass)
          v46 = 45;
        v37(3, "%c[%{public}s %{public}s]:%i PID %d (%{public}@) missing entitlement: %s", v46, ClassName, Name, 262, v94, v45, "com.apple.nfcd.lpm.factorytest");

      }
      v47 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v48 = NFSharedLogGetLogger(v47);
      v49 = objc_claimAutoreleasedReturnValue(v48);
      if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
      {
        v50 = object_getClass(v3);
        if (class_isMetaClass(v50))
          v51 = 43;
        else
          v51 = 45;
        v52 = object_getClassName(v3);
        v53 = sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:");
        v54 = objc_msgSend(v4, "processIdentifier");
        v55 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v96, "clientName"));
        *(_DWORD *)buf = 67110658;
        *(_DWORD *)&buf[4] = v51;
        *(_WORD *)v103 = 2082;
        *(_QWORD *)&v103[2] = v52;
        *(_WORD *)&v103[10] = 2082;
        *(_QWORD *)&v103[12] = v53;
        *(_WORD *)&v103[20] = 1024;
        *(_DWORD *)&v103[22] = 262;
        *(_WORD *)&v103[26] = 1024;
        *(_DWORD *)&v103[28] = v54;
        *(_WORD *)&v103[32] = 2114;
        *(_QWORD *)&v103[34] = v55;
        v104 = 2080;
        v105 = "com.apple.nfcd.lpm.factorytest";
        _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i PID %d (%{public}@) missing entitlement: %s", buf, 0x3Cu);

      }
      v56 = objc_alloc((Class)NSError);
      v57 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v97 = NSLocalizedDescriptionKey;
      v58 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Not entitled"));
      *(_QWORD *)buf = v58;
      *(_QWORD *)v103 = &off_100300860;
      v98 = CFSTR("Line");
      v99 = CFSTR("Method");
      v59 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:"));
      *(_QWORD *)&v103[8] = v59;
      v100 = (const __CFString *)NSDebugDescriptionErrorKey;
      v60 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:"), 263);
      *(_QWORD *)&v103[16] = v60;
      v61 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v97, 4));
      v62 = v56;
      v63 = v57;
      v64 = 32;
      goto LABEL_31;
    }
    v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "controllerInfo"));
    if ((objc_msgSend(v7, "hasLPEMSupport") & 1) != 0)
    {
      v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "driverWrapper"));
      v9 = sub_1001979A4((uint64_t)v8, 1);

      if ((v9 & 1) != 0)
      {
        v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "driverWrapper"));
        v11 = sub_1001F84C8(v10, CFSTR("Set Headless Factory"), 1uLL);
        v12 = (void *)objc_claimAutoreleasedReturnValue(v11);

        if (v12)
        {
          v13 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v14 = NFLogGetLogger(v13);
          if (v14)
          {
            v15 = (void (*)(uint64_t, const char *, ...))v14;
            v16 = object_getClass(v3);
            v17 = class_isMetaClass(v16);
            v92 = object_getClassName(v3);
            v93 = sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:");
            v18 = 45;
            if (v17)
              v18 = 43;
            v15(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v18, v92, v93, 274, v12);
          }
          v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v20 = NFSharedLogGetLogger(v19);
          v21 = objc_claimAutoreleasedReturnValue(v20);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            v22 = object_getClass(v3);
            if (class_isMetaClass(v22))
              v23 = 43;
            else
              v23 = 45;
            *(_DWORD *)buf = 67110146;
            *(_DWORD *)&buf[4] = v23;
            *(_WORD *)v103 = 2082;
            *(_QWORD *)&v103[2] = object_getClassName(v3);
            *(_WORD *)&v103[10] = 2082;
            *(_QWORD *)&v103[12] = sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:");
            *(_WORD *)&v103[20] = 1024;
            *(_DWORD *)&v103[22] = 274;
            *(_WORD *)&v103[26] = 2112;
            *(_QWORD *)&v103[28] = v12;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
          }

          v24 = objc_alloc((Class)NSError);
          v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
          v26 = objc_msgSend(v12, "code");
          v97 = NSLocalizedDescriptionKey;
          v95 = v4;
          if ((uint64_t)objc_msgSend(v12, "code") > 70)
            v27 = 71;
          else
            v27 = (uint64_t)objc_msgSend(v12, "code");
          v72 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002EA140[v27]));
          *(_QWORD *)buf = v72;
          *(_QWORD *)v103 = v12;
          v98 = (const __CFString *)NSUnderlyingErrorKey;
          v99 = CFSTR("Line");
          *(_QWORD *)&v103[8] = &off_100300890;
          v100 = CFSTR("Method");
          v73 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:"));
          *(_QWORD *)&v103[16] = v73;
          v101 = NSDebugDescriptionErrorKey;
          v74 = objc_alloc((Class)NSString);
          v75 = sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:");
          v76 = 275;
          goto LABEL_45;
        }
        v67 = (unsigned __int8 *)v3[3];
        v68 = sub_100048D70(v67, v1 != 0);
        v12 = (void *)objc_claimAutoreleasedReturnValue(v68);

        v69 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "driverWrapper"));
        v70 = v69;
        if (v12)
        {
          sub_1001FABB8(v69, CFSTR("Set Headless Factory"));

          v24 = objc_alloc((Class)NSError);
          v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
          v26 = objc_msgSend(v12, "code");
          v97 = NSLocalizedDescriptionKey;
          v95 = v4;
          if ((uint64_t)objc_msgSend(v12, "code") > 70)
            v71 = 71;
          else
            v71 = (uint64_t)objc_msgSend(v12, "code");
          v72 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002EA140[v71]));
          *(_QWORD *)buf = v72;
          *(_QWORD *)v103 = v12;
          v98 = (const __CFString *)NSUnderlyingErrorKey;
          v99 = CFSTR("Line");
          *(_QWORD *)&v103[8] = &off_1003008A8;
          v100 = CFSTR("Method");
          v73 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:"));
          *(_QWORD *)&v103[16] = v73;
          v101 = NSDebugDescriptionErrorKey;
          v74 = objc_alloc((Class)NSString);
          v75 = sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:");
          v76 = 283;
LABEL_45:
          v83 = objc_msgSend(v74, "initWithFormat:", CFSTR("%s:%d"), v75, v76);
          *(_QWORD *)&v103[24] = v83;
          v84 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v97, 5));
          v85 = objc_msgSend(v24, "initWithDomain:code:userInfo:", v25, v26, v84);
          v5[2](v5, v85);

          v4 = v95;
          goto LABEL_32;
        }
        if (v1)
        {
          v77 = sub_100197C58(v69, 1);

          if ((v77 & 1) == 0)
          {
            v78 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "driverWrapper"));
            sub_1001FABB8(v78, CFSTR("Set Headless Factory"));

            v79 = objc_alloc((Class)NSError);
            v57 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
            v97 = NSLocalizedDescriptionKey;
            v58 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
            *(_QWORD *)buf = v58;
            *(_QWORD *)v103 = &off_1003008C0;
            v98 = CFSTR("Line");
            v99 = CFSTR("Method");
            v59 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:"));
            *(_QWORD *)&v103[8] = v59;
            v100 = (const __CFString *)NSDebugDescriptionErrorKey;
            v80 = objc_alloc((Class)NSString);
            v81 = sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:");
            v82 = 291;
LABEL_50:
            v60 = objc_msgSend(v80, "initWithFormat:", CFSTR("%s:%d"), v81, v82);
            *(_QWORD *)&v103[16] = v60;
            v61 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v97, 4));
            v62 = v79;
            v63 = v57;
            v64 = 15;
            goto LABEL_31;
          }
        }
        else
        {
          v86 = sub_1001980AC((uint64_t)v69, 31);

          if ((v86 & 1) == 0)
          {
            v91 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "driverWrapper"));
            sub_1001FABB8(v91, CFSTR("Set Headless Factory"));

            v79 = objc_alloc((Class)NSError);
            v57 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
            v97 = NSLocalizedDescriptionKey;
            v58 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
            *(_QWORD *)buf = v58;
            *(_QWORD *)v103 = &off_1003008D8;
            v98 = CFSTR("Line");
            v99 = CFSTR("Method");
            v59 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:"));
            *(_QWORD *)&v103[8] = v59;
            v100 = (const __CFString *)NSDebugDescriptionErrorKey;
            v80 = objc_alloc((Class)NSString);
            v81 = sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:");
            v82 = 299;
            goto LABEL_50;
          }
        }
        v87 = sub_100098AF4((uint64_t)v3);
        v88 = sub_1000984B4(v3, v87);
        v89 = (void *)objc_claimAutoreleasedReturnValue(v88);

        v90 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "driverWrapper"));
        sub_1001FABB8(v90, CFSTR("Set Headless Factory"));

        if (!v89)
        {
          v5[2](v5, 0);
          goto LABEL_32;
        }
        v79 = objc_alloc((Class)NSError);
        v57 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v97 = NSLocalizedDescriptionKey;
        v58 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
        *(_QWORD *)buf = v58;
        *(_QWORD *)v103 = &off_1003008F0;
        v98 = CFSTR("Line");
        v99 = CFSTR("Method");
        v59 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:"));
        *(_QWORD *)&v103[8] = v59;
        v100 = (const __CFString *)NSDebugDescriptionErrorKey;
        v80 = objc_alloc((Class)NSString);
        v81 = sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:");
        v82 = 307;
        goto LABEL_50;
      }
    }
    else
    {

    }
    v65 = objc_alloc((Class)NSError);
    v57 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v97 = NSLocalizedDescriptionKey;
    v58 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Feature Not Supported"));
    *(_QWORD *)buf = v58;
    *(_QWORD *)v103 = &off_100300878;
    v98 = CFSTR("Line");
    v99 = CFSTR("Method");
    v59 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:"));
    *(_QWORD *)&v103[8] = v59;
    v100 = (const __CFString *)NSDebugDescriptionErrorKey;
    v60 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:"), 268);
    *(_QWORD *)&v103[16] = v60;
    v61 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v97, 4));
    v62 = v65;
    v63 = v57;
    v64 = 14;
LABEL_31:
    v66 = objc_msgSend(v62, "initWithDomain:code:userInfo:", v63, v64, v61);
    v5[2](v5, v66);

LABEL_32:
    v6 = v96;
    goto LABEL_33;
  }
LABEL_34:

}

void sub_10018DC74(_QWORD *a1)
{
  void *v1;
  void *v2;
  id v3;
  void (**v4)(id, id, _QWORD);
  void *v5;
  void *v6;
  unsigned __int8 v7;
  void *v8;
  id v9;
  id v10;
  void *specific;
  uint64_t Logger;
  void (*v13)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  NSObject *v19;
  objc_class *v20;
  int v21;
  id v22;
  void *v23;
  id v24;
  uint64_t v25;
  id v26;
  void *v27;
  id v28;
  id v29;
  void *v30;
  id v31;
  void *v32;
  uint64_t v33;
  void (*v34)(uint64_t, const char *, ...);
  objc_class *v35;
  _BOOL4 v36;
  const char *v37;
  const char *v38;
  void (**v39)(id, id, _QWORD);
  id v40;
  id v41;
  void *v42;
  uint64_t v43;
  void *v44;
  uint64_t v45;
  NSObject *v46;
  objc_class *v47;
  int v48;
  const char *v49;
  const char *v50;
  unsigned int v51;
  void *v52;
  id v53;
  void *v54;
  id v55;
  id v56;
  void *v57;
  void *v58;
  id v59;
  uint64_t v60;
  id v61;
  id v62;
  void *v63;
  uint64_t v64;
  id v65;
  id v66;
  void *v67;
  id v68;
  uint64_t v69;
  void *v70;
  id v71;
  id v72;
  void *v73;
  id v74;
  void *v75;
  id v76;
  id v77;
  void *v78;
  void *v79;
  const char *ClassName;
  const char *Name;
  id v82;
  id v83;
  unsigned int v84;
  id v85;
  id v86;
  void *v87;
  id v88;
  NSErrorUserInfoKey v89;
  const __CFString *v90;
  const __CFString *v91;
  const __CFString *v92;
  NSErrorUserInfoKey v93;
  uint8_t buf[8];
  _BYTE v95[42];
  __int16 v96;
  const char *v97;

  v1 = (void *)a1[5];
  v2 = (void *)a1[4];
  v3 = *(id *)(*(_QWORD *)(a1[6] + 8) + 40);
  v4 = v1;
  if (v2)
  {
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "NF_whitelistChecker"));
    if (-[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)v2) != 2)
    {
      v26 = objc_alloc((Class)NSError);
      v10 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v89 = NSLocalizedDescriptionKey;
      v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
      *(_QWORD *)buf = v27;
      *(_QWORD *)v95 = &off_100300908;
      v90 = CFSTR("Line");
      v91 = CFSTR("Method");
      v28 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_headlessFactoryModeFromConnection:completion:"));
      *(_QWORD *)&v95[8] = v28;
      v92 = (const __CFString *)NSDebugDescriptionErrorKey;
      v29 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_headlessFactoryModeFromConnection:completion:"), 335);
      *(_QWORD *)&v95[16] = v29;
      v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v89, 4));
      v31 = objc_msgSend(v26, "initWithDomain:code:userInfo:", v10, 58, v30);
      v4[2](v4, v31, 0);

LABEL_31:
      goto LABEL_32;
    }
    v87 = v5;
    if ((objc_msgSend(v5, "lpmFactoryTest") & 1) != 0)
    {
      v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "controllerInfo"));
      v7 = objc_msgSend(v6, "hasLPEMSupport");

      if ((v7 & 1) != 0)
      {
        v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "driverWrapper"));
        v9 = sub_1001F84C8(v8, CFSTR("Get Headless Factory"), 1uLL);
        v10 = (id)objc_claimAutoreleasedReturnValue(v9);

        if (v10)
        {
          specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          Logger = NFLogGetLogger(specific);
          if (Logger)
          {
            v13 = (void (*)(uint64_t, const char *, ...))Logger;
            Class = object_getClass(v2);
            isMetaClass = class_isMetaClass(Class);
            ClassName = object_getClassName(v2);
            Name = sel_getName("_sync_headlessFactoryModeFromConnection:completion:");
            v16 = 45;
            if (isMetaClass)
              v16 = 43;
            v13(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v16, ClassName, Name, 352, v10);
          }
          v17 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v18 = NFSharedLogGetLogger(v17);
          v19 = objc_claimAutoreleasedReturnValue(v18);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            v20 = object_getClass(v2);
            if (class_isMetaClass(v20))
              v21 = 43;
            else
              v21 = 45;
            *(_DWORD *)buf = 67110146;
            *(_DWORD *)&buf[4] = v21;
            *(_WORD *)v95 = 2082;
            *(_QWORD *)&v95[2] = object_getClassName(v2);
            *(_WORD *)&v95[10] = 2082;
            *(_QWORD *)&v95[12] = sel_getName("_sync_headlessFactoryModeFromConnection:completion:");
            *(_WORD *)&v95[20] = 1024;
            *(_DWORD *)&v95[22] = 352;
            *(_WORD *)&v95[26] = 2112;
            *(_QWORD *)&v95[28] = v10;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
          }

          v22 = objc_alloc((Class)NSError);
          v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
          v24 = objc_msgSend(v10, "code");
          v89 = NSLocalizedDescriptionKey;
          v85 = v3;
          if ((uint64_t)objc_msgSend(v10, "code") > 70)
            v25 = 71;
          else
            v25 = (uint64_t)objc_msgSend(v10, "code");
          v70 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002EA140[v25]));
          *(_QWORD *)buf = v70;
          *(_QWORD *)v95 = v10;
          v90 = (const __CFString *)NSUnderlyingErrorKey;
          v91 = CFSTR("Line");
          *(_QWORD *)&v95[8] = &off_100300950;
          v92 = CFSTR("Method");
          v71 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_headlessFactoryModeFromConnection:completion:"));
          *(_QWORD *)&v95[16] = v71;
          v93 = NSDebugDescriptionErrorKey;
          v72 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_headlessFactoryModeFromConnection:completion:"), 353);
          *(_QWORD *)&v95[24] = v72;
          v73 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v89, 5));
          v74 = objc_msgSend(v22, "initWithDomain:code:userInfo:", v23, v24, v73);
          v4[2](v4, v74, 0);

          v3 = v85;
        }
        else
        {
          v63 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "driverWrapper"));
          v88 = 0;
          v64 = sub_100198F98(v63, &v88);
          v65 = v88;

          if (v65)
          {
            v84 = v64;
            v66 = objc_alloc((Class)NSError);
            v67 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
            v68 = objc_msgSend(v65, "code");
            v89 = NSLocalizedDescriptionKey;
            v86 = v3;
            v83 = v68;
            if ((uint64_t)objc_msgSend(v65, "code") > 70)
              v69 = 71;
            else
              v69 = (uint64_t)objc_msgSend(v65, "code");
            v75 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002EA140[v69]));
            *(_QWORD *)buf = v75;
            *(_QWORD *)v95 = v65;
            v90 = (const __CFString *)NSUnderlyingErrorKey;
            v91 = CFSTR("Line");
            *(_QWORD *)&v95[8] = &off_100300968;
            v92 = CFSTR("Method");
            v76 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_headlessFactoryModeFromConnection:completion:"));
            *(_QWORD *)&v95[16] = v76;
            v93 = NSDebugDescriptionErrorKey;
            v77 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_headlessFactoryModeFromConnection:completion:"), 359);
            *(_QWORD *)&v95[24] = v77;
            v78 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v89, 5));
            v10 = objc_msgSend(v66, "initWithDomain:code:userInfo:", v67, v83, v78);

            v3 = v86;
            v64 = v84;
          }
          else
          {
            v10 = 0;
          }
          v79 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "driverWrapper"));
          sub_1001FABB8(v79, CFSTR("Get Headless Factory"));

          v4[2](v4, v10, v64);
        }
        goto LABEL_30;
      }
      v61 = objc_alloc((Class)NSError);
      v10 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v89 = NSLocalizedDescriptionKey;
      v54 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Feature Not Supported"));
      *(_QWORD *)buf = v54;
      *(_QWORD *)v95 = &off_100300938;
      v90 = CFSTR("Line");
      v91 = CFSTR("Method");
      v55 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_headlessFactoryModeFromConnection:completion:"));
      *(_QWORD *)&v95[8] = v55;
      v92 = (const __CFString *)NSDebugDescriptionErrorKey;
      v56 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_headlessFactoryModeFromConnection:completion:"), 346);
      *(_QWORD *)&v95[16] = v56;
      v57 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v89, 4));
      v58 = v61;
      v59 = v10;
      v60 = 14;
    }
    else
    {
      v32 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v33 = NFLogGetLogger(v32);
      if (v33)
      {
        v34 = (void (*)(uint64_t, const char *, ...))v33;
        v35 = object_getClass(v2);
        v36 = class_isMetaClass(v35);
        v37 = object_getClassName(v2);
        v38 = sel_getName("_sync_headlessFactoryModeFromConnection:completion:");
        v39 = v4;
        v40 = v3;
        v41 = objc_msgSend(v3, "processIdentifier");
        v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "clientName"));
        v82 = v41;
        v3 = v40;
        v4 = v39;
        v43 = 43;
        if (!v36)
          v43 = 45;
        v34(3, "%c[%{public}s %{public}s]:%i PID %d (%{public}@) missing entitlement: %s", v43, v37, v38, 340, v82, v42, "com.apple.nfcd.lpm.factorytest");

      }
      v44 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v45 = NFSharedLogGetLogger(v44);
      v46 = objc_claimAutoreleasedReturnValue(v45);
      if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
      {
        v47 = object_getClass(v2);
        if (class_isMetaClass(v47))
          v48 = 43;
        else
          v48 = 45;
        v49 = object_getClassName(v2);
        v50 = sel_getName("_sync_headlessFactoryModeFromConnection:completion:");
        v51 = objc_msgSend(v3, "processIdentifier");
        v52 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v87, "clientName"));
        *(_DWORD *)buf = 67110658;
        *(_DWORD *)&buf[4] = v48;
        *(_WORD *)v95 = 2082;
        *(_QWORD *)&v95[2] = v49;
        *(_WORD *)&v95[10] = 2082;
        *(_QWORD *)&v95[12] = v50;
        *(_WORD *)&v95[20] = 1024;
        *(_DWORD *)&v95[22] = 340;
        *(_WORD *)&v95[26] = 1024;
        *(_DWORD *)&v95[28] = v51;
        *(_WORD *)&v95[32] = 2114;
        *(_QWORD *)&v95[34] = v52;
        v96 = 2080;
        v97 = "com.apple.nfcd.lpm.factorytest";
        _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i PID %d (%{public}@) missing entitlement: %s", buf, 0x3Cu);

      }
      v53 = objc_alloc((Class)NSError);
      v10 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v89 = NSLocalizedDescriptionKey;
      v54 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Not entitled"));
      *(_QWORD *)buf = v54;
      *(_QWORD *)v95 = &off_100300920;
      v90 = CFSTR("Line");
      v91 = CFSTR("Method");
      v55 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_headlessFactoryModeFromConnection:completion:"));
      *(_QWORD *)&v95[8] = v55;
      v92 = (const __CFString *)NSDebugDescriptionErrorKey;
      v56 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_headlessFactoryModeFromConnection:completion:"), 341);
      *(_QWORD *)&v95[16] = v56;
      v57 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v89, 4));
      v58 = v53;
      v59 = v10;
      v60 = 32;
    }
    v62 = objc_msgSend(v58, "initWithDomain:code:userInfo:", v59, v60, v57);
    v4[2](v4, v62, 0);

LABEL_30:
    v5 = v87;
    goto LABEL_31;
  }
LABEL_32:

}

void sub_10018E8C0(_QWORD *a1)
{
  void *v1;
  void *v2;
  id v3;
  void (**v4)(id, id);
  void *v5;
  void *v6;
  unsigned __int8 v7;
  void *v8;
  id v9;
  id v10;
  void *specific;
  uint64_t Logger;
  void (*v13)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  NSObject *v19;
  objc_class *v20;
  int v21;
  id v22;
  void *v23;
  id v24;
  uint64_t v25;
  id v26;
  void *v27;
  id v28;
  id v29;
  void *v30;
  id v31;
  void *v32;
  uint64_t v33;
  void (*v34)(uint64_t, const char *, ...);
  objc_class *v35;
  _BOOL4 v36;
  const char *v37;
  const char *v38;
  void (**v39)(id, id);
  id v40;
  id v41;
  void *v42;
  uint64_t v43;
  void *v44;
  uint64_t v45;
  NSObject *v46;
  objc_class *v47;
  int v48;
  const char *v49;
  const char *v50;
  unsigned int v51;
  void *v52;
  id v53;
  void *v54;
  id v55;
  id v56;
  void *v57;
  void *v58;
  id v59;
  uint64_t v60;
  id v61;
  id v62;
  void *v63;
  id v64;
  void *v65;
  id v66;
  void *v67;
  uint64_t v68;
  void *v69;
  id v70;
  id v71;
  void *v72;
  id v73;
  void *v74;
  id v75;
  id v76;
  void *v77;
  void *v78;
  const char *ClassName;
  const char *Name;
  id v81;
  id v82;
  id v83;
  id v84;
  void *v85;
  NSErrorUserInfoKey v86;
  const __CFString *v87;
  const __CFString *v88;
  const __CFString *v89;
  NSErrorUserInfoKey v90;
  uint8_t buf[8];
  _BYTE v92[42];
  __int16 v93;
  const char *v94;

  v1 = (void *)a1[5];
  v2 = (void *)a1[4];
  v3 = *(id *)(*(_QWORD *)(a1[6] + 8) + 40);
  v4 = v1;
  if (v2)
  {
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "NF_whitelistChecker"));
    if (-[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)v2) != 2)
    {
      v26 = objc_alloc((Class)NSError);
      v10 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v86 = NSLocalizedDescriptionKey;
      v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unresponsive hardware"));
      *(_QWORD *)buf = v27;
      *(_QWORD *)v92 = &off_100300980;
      v87 = CFSTR("Line");
      v88 = CFSTR("Method");
      v28 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_disableHeadlessMiniNVForConnection:completion:"));
      *(_QWORD *)&v92[8] = v28;
      v89 = (const __CFString *)NSDebugDescriptionErrorKey;
      v29 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_disableHeadlessMiniNVForConnection:completion:"), 386);
      *(_QWORD *)&v92[16] = v29;
      v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v86, 4));
      v31 = objc_msgSend(v26, "initWithDomain:code:userInfo:", v10, 58, v30);
      v4[2](v4, v31);

LABEL_31:
      goto LABEL_32;
    }
    v85 = v5;
    if ((objc_msgSend(v5, "miniNVWriteAccess") & 1) != 0)
    {
      v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "controllerInfo"));
      v7 = objc_msgSend(v6, "hasLPEMSupport");

      if ((v7 & 1) != 0)
      {
        v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "driverWrapper"));
        v9 = sub_1001F84C8(v8, CFSTR("Disable Headless"), 1uLL);
        v10 = (id)objc_claimAutoreleasedReturnValue(v9);

        if (v10)
        {
          specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          Logger = NFLogGetLogger(specific);
          if (Logger)
          {
            v13 = (void (*)(uint64_t, const char *, ...))Logger;
            Class = object_getClass(v2);
            isMetaClass = class_isMetaClass(Class);
            ClassName = object_getClassName(v2);
            Name = sel_getName("_sync_disableHeadlessMiniNVForConnection:completion:");
            v16 = 45;
            if (isMetaClass)
              v16 = 43;
            v13(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@error", v16, ClassName, Name, 403, v10);
          }
          v17 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v18 = NFSharedLogGetLogger(v17);
          v19 = objc_claimAutoreleasedReturnValue(v18);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            v20 = object_getClass(v2);
            if (class_isMetaClass(v20))
              v21 = 43;
            else
              v21 = 45;
            *(_DWORD *)buf = 67110146;
            *(_DWORD *)&buf[4] = v21;
            *(_WORD *)v92 = 2082;
            *(_QWORD *)&v92[2] = object_getClassName(v2);
            *(_WORD *)&v92[10] = 2082;
            *(_QWORD *)&v92[12] = sel_getName("_sync_disableHeadlessMiniNVForConnection:completion:");
            *(_WORD *)&v92[20] = 1024;
            *(_DWORD *)&v92[22] = 403;
            *(_WORD *)&v92[26] = 2112;
            *(_QWORD *)&v92[28] = v10;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@error", buf, 0x2Cu);
          }

          v22 = objc_alloc((Class)NSError);
          v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
          v24 = objc_msgSend(v10, "code");
          v86 = NSLocalizedDescriptionKey;
          v83 = v3;
          if ((uint64_t)objc_msgSend(v10, "code") > 70)
            v25 = 71;
          else
            v25 = (uint64_t)objc_msgSend(v10, "code");
          v69 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002EA140[v25]));
          *(_QWORD *)buf = v69;
          *(_QWORD *)v92 = v10;
          v87 = (const __CFString *)NSUnderlyingErrorKey;
          v88 = CFSTR("Line");
          *(_QWORD *)&v92[8] = &off_1003009C8;
          v89 = CFSTR("Method");
          v70 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_disableHeadlessMiniNVForConnection:completion:"));
          *(_QWORD *)&v92[16] = v70;
          v90 = NSDebugDescriptionErrorKey;
          v71 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_disableHeadlessMiniNVForConnection:completion:"), 404);
          *(_QWORD *)&v92[24] = v71;
          v72 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v86, 5));
          v73 = objc_msgSend(v22, "initWithDomain:code:userInfo:", v23, v24, v72);
          v4[2](v4, v73);

          v3 = v83;
        }
        else
        {
          v63 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "driverWrapper"));
          v64 = sub_100198900(v63);
          v65 = (void *)objc_claimAutoreleasedReturnValue(v64);

          if (v65)
          {
            v66 = objc_alloc((Class)NSError);
            v67 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
            v86 = NSLocalizedDescriptionKey;
            v82 = objc_msgSend(v65, "code");
            v84 = v3;
            if ((uint64_t)objc_msgSend(v65, "code") > 70)
              v68 = 71;
            else
              v68 = (uint64_t)objc_msgSend(v65, "code");
            v74 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002EA140[v68]));
            *(_QWORD *)buf = v74;
            *(_QWORD *)v92 = v65;
            v87 = (const __CFString *)NSUnderlyingErrorKey;
            v88 = CFSTR("Line");
            *(_QWORD *)&v92[8] = &off_1003009E0;
            v89 = CFSTR("Method");
            v75 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_disableHeadlessMiniNVForConnection:completion:"));
            *(_QWORD *)&v92[16] = v75;
            v90 = NSDebugDescriptionErrorKey;
            v76 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_disableHeadlessMiniNVForConnection:completion:"), 410);
            *(_QWORD *)&v92[24] = v76;
            v77 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v86, 5));
            v10 = objc_msgSend(v66, "initWithDomain:code:userInfo:", v67, v82, v77);

            v3 = v84;
          }
          else
          {
            v10 = 0;
          }
          v78 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "driverWrapper"));
          sub_1001FABB8(v78, CFSTR("Disable Headless"));

          v4[2](v4, v10);
        }
        goto LABEL_30;
      }
      v61 = objc_alloc((Class)NSError);
      v10 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v86 = NSLocalizedDescriptionKey;
      v54 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Feature Not Supported"));
      *(_QWORD *)buf = v54;
      *(_QWORD *)v92 = &off_1003009B0;
      v87 = CFSTR("Line");
      v88 = CFSTR("Method");
      v55 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_disableHeadlessMiniNVForConnection:completion:"));
      *(_QWORD *)&v92[8] = v55;
      v89 = (const __CFString *)NSDebugDescriptionErrorKey;
      v56 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_disableHeadlessMiniNVForConnection:completion:"), 397);
      *(_QWORD *)&v92[16] = v56;
      v57 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v86, 4));
      v58 = v61;
      v59 = v10;
      v60 = 14;
    }
    else
    {
      v32 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v33 = NFLogGetLogger(v32);
      if (v33)
      {
        v34 = (void (*)(uint64_t, const char *, ...))v33;
        v35 = object_getClass(v2);
        v36 = class_isMetaClass(v35);
        v37 = object_getClassName(v2);
        v38 = sel_getName("_sync_disableHeadlessMiniNVForConnection:completion:");
        v39 = v4;
        v40 = v3;
        v41 = objc_msgSend(v3, "processIdentifier");
        v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "clientName"));
        v81 = v41;
        v3 = v40;
        v4 = v39;
        v43 = 43;
        if (!v36)
          v43 = 45;
        v34(3, "%c[%{public}s %{public}s]:%i PID %d (%{public}@) missing entitlement: %s", v43, v37, v38, 391, v81, v42, "com.apple.nfcd.mininv.write");

      }
      v44 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v45 = NFSharedLogGetLogger(v44);
      v46 = objc_claimAutoreleasedReturnValue(v45);
      if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
      {
        v47 = object_getClass(v2);
        if (class_isMetaClass(v47))
          v48 = 43;
        else
          v48 = 45;
        v49 = object_getClassName(v2);
        v50 = sel_getName("_sync_disableHeadlessMiniNVForConnection:completion:");
        v51 = objc_msgSend(v3, "processIdentifier");
        v52 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v85, "clientName"));
        *(_DWORD *)buf = 67110658;
        *(_DWORD *)&buf[4] = v48;
        *(_WORD *)v92 = 2082;
        *(_QWORD *)&v92[2] = v49;
        *(_WORD *)&v92[10] = 2082;
        *(_QWORD *)&v92[12] = v50;
        *(_WORD *)&v92[20] = 1024;
        *(_DWORD *)&v92[22] = 391;
        *(_WORD *)&v92[26] = 1024;
        *(_DWORD *)&v92[28] = v51;
        *(_WORD *)&v92[32] = 2114;
        *(_QWORD *)&v92[34] = v52;
        v93 = 2080;
        v94 = "com.apple.nfcd.mininv.write";
        _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i PID %d (%{public}@) missing entitlement: %s", buf, 0x3Cu);

      }
      v53 = objc_alloc((Class)NSError);
      v10 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v86 = NSLocalizedDescriptionKey;
      v54 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Not entitled"));
      *(_QWORD *)buf = v54;
      *(_QWORD *)v92 = &off_100300998;
      v87 = CFSTR("Line");
      v88 = CFSTR("Method");
      v55 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_sync_disableHeadlessMiniNVForConnection:completion:"));
      *(_QWORD *)&v92[8] = v55;
      v89 = (const __CFString *)NSDebugDescriptionErrorKey;
      v56 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_sync_disableHeadlessMiniNVForConnection:completion:"), 392);
      *(_QWORD *)&v92[16] = v56;
      v57 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v86, 4));
      v58 = v53;
      v59 = v10;
      v60 = 32;
    }
    v62 = objc_msgSend(v58, "initWithDomain:code:userInfo:", v59, v60, v57);
    v4[2](v4, v62);

LABEL_30:
    v5 = v85;
    goto LABEL_31;
  }
LABEL_32:

}

void sub_10018F3F4(uint64_t a1, void *a2)
{
  id v3;
  NSObject *v4;
  _QWORD block[5];
  id v6;
  const char *v7;

  v3 = a2;
  if (a1)
  {
    v4 = *(id *)(a1 + 232);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10018F494;
    block[3] = &unk_1002E5D28;
    block[4] = a1;
    v6 = v3;
    v7 = "configureMiniNVWithCompletion:";
    dispatch_async(v4, block);

  }
}

void sub_10018F494(uint64_t a1)
{
  void *v2;
  unsigned __int8 v3;
  void *v4;
  id v5;
  void *v6;
  uint64_t v7;
  void (*v8)(uint64_t, const char *, ...);
  objc_class *v9;
  _BOOL4 v10;
  const char *v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  NSObject *v15;
  objc_class *v16;
  int v17;
  const char *v18;
  const char *v19;
  uint64_t v20;
  id v21;
  id v22;
  void *v23;
  id v24;
  id v25;
  void *v26;
  id v27;
  void *v28;
  id v29;
  void *specific;
  uint64_t Logger;
  void (*v32)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v35;
  void *v36;
  uint64_t v37;
  NSObject *v38;
  objc_class *v39;
  int v40;
  const char *v41;
  const char *v42;
  uint64_t v43;
  id v44;
  void *v45;
  id v46;
  uint64_t v47;
  void *v48;
  char v49;
  void *v50;
  uint64_t v51;
  void *v52;
  id v53;
  id v54;
  _QWORD *v55;
  _QWORD *v56;
  void *v57;
  uint64_t v58;
  void (*v59)(uint64_t, const char *, ...);
  objc_class *v60;
  _BOOL4 v61;
  const char *v62;
  uint64_t v63;
  void *v64;
  uint64_t v65;
  NSObject *v66;
  objc_class *v67;
  int v68;
  const char *v69;
  const char *v70;
  void *v71;
  id v72;
  uint64_t v73;
  NSErrorUserInfoKey v74;
  id v75;
  void *v76;
  id v77;
  uint64_t v78;
  void *v79;
  id v80;
  void *v81;
  int v82;
  void *v83;
  id v84;
  id v85;
  void *v86;
  id v87;
  void *v88;
  id v89;
  void *v90;
  void *v91;
  void *v92;
  const char *ClassName;
  const char *v94;
  const char *Name;
  const char *v96;
  id v97;
  _QWORD v98[5];
  _QWORD v99[5];
  NSErrorUserInfoKey v100;
  void *v101;
  _QWORD v102[5];
  _QWORD v103[5];
  _QWORD v104[5];
  _QWORD v105[5];
  uint8_t buf[4];
  int v107;
  __int16 v108;
  const char *v109;
  __int16 v110;
  const char *v111;
  __int16 v112;
  int v113;
  __int16 v114;
  id v115;
  _QWORD v116[4];
  _QWORD v117[4];

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "controllerInfo"));
  v3 = objc_msgSend(v2, "hasLPEMSupport");

  if ((v3 & 1) == 0)
  {
    v20 = *(_QWORD *)(a1 + 40);
    v21 = objc_alloc((Class)NSError);
    v22 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v116[0] = NSLocalizedDescriptionKey;
    v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Feature Not Supported"));
    v117[0] = v23;
    v117[1] = &off_1003009F8;
    v116[1] = CFSTR("Line");
    v116[2] = CFSTR("Method");
    v24 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 48)));
    v117[2] = v24;
    v116[3] = NSDebugDescriptionErrorKey;
    v25 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 48)), 426);
    v117[3] = v25;
    v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v117, v116, 4));
    v27 = objc_msgSend(v21, "initWithDomain:code:userInfo:", v22, 14, v26);
    (*(void (**)(uint64_t, id))(v20 + 16))(v20, v27);

LABEL_48:
    return;
  }
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "controllerInfo"));
  v5 = objc_msgSend(v4, "siliconName");

  if (v5 != (id)18)
  {
    v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "driverWrapper"));
    v29 = sub_1001F84C8(v28, CFSTR("LPEM MiniNV config"), 1uLL);
    v22 = (id)objc_claimAutoreleasedReturnValue(v29);

    if (v22)
    {
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v32 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(*(id *)(a1 + 32));
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(*(id *)(a1 + 32));
        Name = sel_getName(*(SEL *)(a1 + 48));
        v35 = 45;
        if (isMetaClass)
          v35 = 43;
        v32(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v35, ClassName, Name, 438, v22);
      }
      v36 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v37 = NFSharedLogGetLogger(v36);
      v38 = objc_claimAutoreleasedReturnValue(v37);
      if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
      {
        v39 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v39))
          v40 = 43;
        else
          v40 = 45;
        v41 = object_getClassName(*(id *)(a1 + 32));
        v42 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)buf = 67110146;
        v107 = v40;
        v108 = 2082;
        v109 = v41;
        v110 = 2082;
        v111 = v42;
        v112 = 1024;
        v113 = 438;
        v114 = 2112;
        v115 = v22;
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
      }

      v43 = *(_QWORD *)(a1 + 40);
      v44 = objc_alloc((Class)NSError);
      v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v46 = objc_msgSend(v22, "code");
      v104[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)objc_msgSend(v22, "code") > 70)
        v47 = 71;
      else
        v47 = (uint64_t)objc_msgSend(v22, "code");
      v52 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002EA140[v47]));
      v105[0] = v52;
      v105[1] = v22;
      v104[1] = NSUnderlyingErrorKey;
      v104[2] = CFSTR("Line");
      v105[2] = &off_100300A10;
      v104[3] = CFSTR("Method");
      v53 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 48)));
      v105[3] = v53;
      v104[4] = NSDebugDescriptionErrorKey;
      v54 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 48)), 439);
      v105[4] = v54;
      v55 = v105;
      v56 = v104;
      goto LABEL_47;
    }
    v48 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "driverWrapper"));
    v97 = 0;
    v49 = sub_100198F98(v48, &v97);
    v22 = v97;

    if (v22)
    {
      v50 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "driverWrapper"));
      sub_1001FABB8(v50, CFSTR("LPEM MiniNV config"));

      v43 = *(_QWORD *)(a1 + 40);
      v44 = objc_alloc((Class)NSError);
      v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v46 = objc_msgSend(v22, "code");
      v102[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)objc_msgSend(v22, "code") > 70)
        v51 = 71;
      else
        v51 = (uint64_t)objc_msgSend(v22, "code");
      v52 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002EA140[v51]));
      v103[0] = v52;
      v103[1] = v22;
      v102[1] = NSUnderlyingErrorKey;
      v102[2] = CFSTR("Line");
      v103[2] = &off_100300A28;
      v102[3] = CFSTR("Method");
      v53 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 48)));
      v103[3] = v53;
      v102[4] = NSDebugDescriptionErrorKey;
      v54 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 48)), 446);
      v103[4] = v54;
      v55 = v103;
      v56 = v102;
LABEL_47:
      v79 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v55, v56, 5));
      v80 = objc_msgSend(v44, "initWithDomain:code:userInfo:", v45, v46, v79);
      (*(void (**)(uint64_t, id))(v43 + 16))(v43, v80);

      goto LABEL_48;
    }
    if ((v49 & 1) != 0)
      goto LABEL_50;
    v57 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v58 = NFLogGetLogger(v57);
    if (v58)
    {
      v59 = (void (*)(uint64_t, const char *, ...))v58;
      v60 = object_getClass(*(id *)(a1 + 32));
      v61 = class_isMetaClass(v60);
      v62 = object_getClassName(*(id *)(a1 + 32));
      v96 = sel_getName(*(SEL *)(a1 + 48));
      v63 = 45;
      if (v61)
        v63 = 43;
      v59(6, "%c[%{public}s %{public}s]:%i enabling MiniNV", v63, v62, v96, 451);
    }
    v64 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v65 = NFSharedLogGetLogger(v64);
    v66 = objc_claimAutoreleasedReturnValue(v65);
    if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
    {
      v67 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v67))
        v68 = 43;
      else
        v68 = 45;
      v69 = object_getClassName(*(id *)(a1 + 32));
      v70 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)buf = 67109890;
      v107 = v68;
      v108 = 2082;
      v109 = v69;
      v110 = 2082;
      v111 = v70;
      v112 = 1024;
      v113 = 451;
      _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i enabling MiniNV", buf, 0x22u);
    }

    v71 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "driverWrapper"));
    v72 = sub_100198C78(v71);
    v22 = (id)objc_claimAutoreleasedReturnValue(v72);

    if (v22)
    {
      v73 = *(_QWORD *)(a1 + 40);
      v74 = NSLocalizedDescriptionKey;
LABEL_43:
      v75 = objc_alloc((Class)NSError);
      v76 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v77 = objc_msgSend(v22, "code");
      v98[0] = v74;
      if ((uint64_t)objc_msgSend(v22, "code") > 70)
        v78 = 71;
      else
        v78 = (uint64_t)objc_msgSend(v22, "code");
      v83 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002EA140[v78]));
      v99[0] = v83;
      v99[1] = v22;
      v98[1] = NSUnderlyingErrorKey;
      v98[2] = CFSTR("Line");
      v99[2] = &off_100300A40;
      v98[3] = CFSTR("Method");
      v84 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 48)));
      v99[3] = v84;
      v98[4] = NSDebugDescriptionErrorKey;
      v85 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 48)), 459);
      v99[4] = v85;
      v86 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v99, v98, 5));
      v87 = objc_msgSend(v75, "initWithDomain:code:userInfo:", v76, v77, v86);
      (*(void (**)(uint64_t, id))(v73 + 16))(v73, v87);

      goto LABEL_54;
    }
    v81 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "driverWrapper"));
    v82 = sub_1001FB970(v81);

    if (v82)
    {
LABEL_50:
      v73 = *(_QWORD *)(a1 + 40);
    }
    else
    {
      v89 = objc_alloc((Class)NSError);
      v90 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v74 = NSLocalizedDescriptionKey;
      v100 = NSLocalizedDescriptionKey;
      v91 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
      v101 = v91;
      v92 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v101, &v100, 1));
      v22 = objc_msgSend(v89, "initWithDomain:code:userInfo:", v90, 15, v92);

      v73 = *(_QWORD *)(a1 + 40);
      if (v22)
        goto LABEL_43;
    }
    (*(void (**)(uint64_t, _QWORD))(v73 + 16))(v73, 0);
    v22 = 0;
LABEL_54:
    v88 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "driverWrapper"));
    sub_1001FABB8(v88, CFSTR("LPEM MiniNV config"));

    goto LABEL_48;
  }
  v6 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v7 = NFLogGetLogger(v6);
  if (v7)
  {
    v8 = (void (*)(uint64_t, const char *, ...))v7;
    v9 = object_getClass(*(id *)(a1 + 32));
    v10 = class_isMetaClass(v9);
    v11 = object_getClassName(*(id *)(a1 + 32));
    v94 = sel_getName(*(SEL *)(a1 + 48));
    v12 = 45;
    if (v10)
      v12 = 43;
    v8(6, "%c[%{public}s %{public}s]:%i No MiniNV config on this platform.", v12, v11, v94, 431);
  }
  v13 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v14 = NFSharedLogGetLogger(v13);
  v15 = objc_claimAutoreleasedReturnValue(v14);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    v16 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v16))
      v17 = 43;
    else
      v17 = 45;
    v18 = object_getClassName(*(id *)(a1 + 32));
    v19 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)buf = 67109890;
    v107 = v17;
    v108 = 2082;
    v109 = v18;
    v110 = 2082;
    v111 = v19;
    v112 = 1024;
    v113 = 431;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i No MiniNV config on this platform.", buf, 0x22u);
  }

  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
}

_QWORD *sub_10019002C(_QWORD *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id v7;
  void *v8;
  objc_super v10;

  v5 = a2;
  v6 = a3;
  if (a1)
  {
    v10.receiver = a1;
    v10.super_class = (Class)NFTagAppProcessorDockKit;
    a1 = objc_msgSendSuper2(&v10, "init");
    if (a1)
    {
      v7 = objc_msgSend(objc_alloc((Class)NFXPCEventPublisher), "initWithStreamName:queue:", v5, v6);
      v8 = (void *)a1[1];
      a1[1] = v7;

    }
  }

  return a1;
}

void sub_100190B60(uint64_t a1)
{
  id v2;
  void *v3;
  uint64_t v4;
  void (*v5)(uint64_t, const char *, ...);
  objc_class *v6;
  _BOOL4 v7;
  const char *v8;
  const char *v9;
  void *v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  objc_class *v15;
  int v16;
  const char *v17;
  const char *v18;
  void *v19;
  int v20;
  void *specific;
  uint64_t Logger;
  void (*v23)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  NSObject *v31;
  objc_class *v32;
  int v33;
  const char *v34;
  const char *v35;
  void *v36;
  const char *v37;
  NSObject *v38;
  uint32_t v39;
  objc_class *v40;
  _BOOL4 v41;
  const char *v42;
  const char *v43;
  uint64_t v44;
  void *v45;
  uint64_t v46;
  objc_class *v47;
  int v48;
  const char *v49;
  const char *v50;
  unsigned int v51;
  id v52;
  uint8_t buf[4];
  int v54;
  __int16 v55;
  const char *v56;
  __int16 v57;
  const char *v58;
  __int16 v59;
  int v60;
  __int16 v61;
  void *v62;

  if (objc_msgSend(*(id *)(a1 + 32), "didStart"))
  {
    if ((objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0)
    {
      v2 = objc_msgSend(*(id *)(a1 + 32), "didEnd");
      if (!(_DWORD)v2)
      {
        v20 = NFIsInternalBuild(v2);
        specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        Logger = NFLogGetLogger(specific);
        v23 = (void (*)(uint64_t, const char *, ...))Logger;
        if (v20)
        {
          if (Logger)
          {
            Class = object_getClass(*(id *)(a1 + 32));
            isMetaClass = class_isMetaClass(Class);
            ClassName = object_getClassName(*(id *)(a1 + 32));
            Name = sel_getName(*(SEL *)(a1 + 48));
            v28 = 45;
            if (isMetaClass)
              v28 = 43;
            v23(10, "%c[%{public}s %{public}s]:%i %@", v28, ClassName, Name, 88, *(_QWORD *)(a1 + 40));
          }
          v29 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v30 = NFSharedLogGetLogger(v29);
          v31 = objc_claimAutoreleasedReturnValue(v30);
          if (!os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
            goto LABEL_34;
          v32 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v32))
            v33 = 43;
          else
            v33 = 45;
          v34 = object_getClassName(*(id *)(a1 + 32));
          v35 = sel_getName(*(SEL *)(a1 + 48));
          v36 = *(void **)(a1 + 40);
          *(_DWORD *)buf = 67110146;
          v54 = v33;
          v55 = 2082;
          v56 = v34;
          v57 = 2082;
          v58 = v35;
          v59 = 1024;
          v60 = 88;
          v61 = 2112;
          v62 = v36;
          v37 = "%c[%{public}s %{public}s]:%i %@";
          v38 = v31;
          v39 = 44;
        }
        else
        {
          if (Logger)
          {
            v40 = object_getClass(*(id *)(a1 + 32));
            v41 = class_isMetaClass(v40);
            v42 = object_getClassName(*(id *)(a1 + 32));
            v43 = sel_getName(*(SEL *)(a1 + 48));
            v52 = objc_msgSend(*(id *)(a1 + 40), "count");
            v44 = 45;
            if (v41)
              v44 = 43;
            v23(6, "%c[%{public}s %{public}s]:%i Setting %d host cards", v44, v42, v43, 91, v52);
          }
          v45 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v46 = NFSharedLogGetLogger(v45);
          v31 = objc_claimAutoreleasedReturnValue(v46);
          if (!os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
            goto LABEL_34;
          v47 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v47))
            v48 = 43;
          else
            v48 = 45;
          v49 = object_getClassName(*(id *)(a1 + 32));
          v50 = sel_getName(*(SEL *)(a1 + 48));
          v51 = objc_msgSend(*(id *)(a1 + 40), "count");
          *(_DWORD *)buf = 67110146;
          v54 = v48;
          v55 = 2082;
          v56 = v49;
          v57 = 2082;
          v58 = v50;
          v59 = 1024;
          v60 = 91;
          v61 = 1024;
          LODWORD(v62) = v51;
          v37 = "%c[%{public}s %{public}s]:%i Setting %d host cards";
          v38 = v31;
          v39 = 40;
        }
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, v37, buf, v39);
LABEL_34:

        objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 371), "setHostCards:", *(_QWORD *)(a1 + 40));
        return;
      }
    }
  }
  v3 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v4 = NFLogGetLogger(v3);
  if (v4)
  {
    v5 = (void (*)(uint64_t, const char *, ...))v4;
    v6 = object_getClass(*(id *)(a1 + 32));
    v7 = class_isMetaClass(v6);
    v8 = object_getClassName(*(id *)(a1 + 32));
    v9 = sel_getName(*(SEL *)(a1 + 48));
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v11 = 45;
    if (v7)
      v11 = 43;
    v5(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v11, v8, v9, 85, v10);

  }
  v12 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v13 = NFSharedLogGetLogger(v12);
  v14 = objc_claimAutoreleasedReturnValue(v13);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    v15 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v15))
      v16 = 43;
    else
      v16 = 45;
    v17 = object_getClassName(*(id *)(a1 + 32));
    v18 = sel_getName(*(SEL *)(a1 + 48));
    v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v54 = v16;
    v55 = 2082;
    v56 = v17;
    v57 = 2082;
    v58 = v18;
    v59 = 1024;
    v60 = 85;
    v61 = 2114;
    v62 = v19;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
}

void sub_1001917E0(void *a1, void *a2)
{
  id *v3;
  id v4;
  id v5;
  CFRunLoopRef Main;
  unsigned int v7;
  void *specific;
  uint64_t Logger;
  void (*v10)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  NSObject *v16;
  objc_class *v17;
  int v18;
  _BOOL8 v19;
  const char *ClassName;
  const char *Name;
  uint8_t buf[4];
  int v23;
  __int16 v24;
  const char *v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  unsigned int v31;

  if (a1)
  {
    v3 = a1;
    v4 = a2;
    objc_sync_enter(v3);
    objc_storeWeak(v3 + 1, v4);

    objc_sync_exit(v3);
    sub_1001919FC(v3);
    if (!*((_BYTE *)v3 + 17))
    {
      v5 = v3[3];
      Main = CFRunLoopGetMain();
      v7 = TelephonyBasebandRegisterForReset(v5, Main, sub_100191A54, v3);
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v10 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(v3);
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(v3);
        Name = sel_getName("setDelegate:");
        v13 = 45;
        if (isMetaClass)
          v13 = 43;
        v10(6, "%c[%{public}s %{public}s]:%i didRegister = %d", v13, ClassName, Name, 60, v7);
      }
      v14 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v15 = NFSharedLogGetLogger(v14);
      v16 = objc_claimAutoreleasedReturnValue(v15);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        v17 = object_getClass(v3);
        if (class_isMetaClass(v17))
          v18 = 43;
        else
          v18 = 45;
        *(_DWORD *)buf = 67110146;
        v23 = v18;
        v24 = 2082;
        v25 = object_getClassName(v3);
        v26 = 2082;
        v27 = sel_getName("setDelegate:");
        v28 = 1024;
        v29 = 60;
        v30 = 1024;
        v31 = v7;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i didRegister = %d", buf, 0x28u);
      }

      *((_BYTE *)v3 + 17) = v7;
    }
    v19 = sub_100191E28(v3);
    sub_100191E74(v3, v19);
  }
}

void sub_1001919FC(_QWORD *a1)
{
  _BYTE *v2;
  char v3;

  v3 = 0;
  TelephonyBasebandGetReset(a1[3], &v3);
  v2 = a1;
  objc_sync_enter(v2);
  v2[16] = v3 ^ 1;
  objc_sync_exit(v2);

}

void sub_100191A54(_QWORD *a1, uint64_t a2, int a3)
{
  void *specific;
  void (*Logger)(uint64_t, const char *, ...);
  void *v6;
  uint64_t v7;
  NSObject *v8;
  const char *v9;
  void *v10;
  void (*v11)(uint64_t, const char *, ...);
  void *v12;
  uint64_t v13;
  void *v14;
  void (*v15)(uint64_t, const char *, ...);
  void *v16;
  uint64_t v17;
  NSObject *v18;
  const char *v19;
  void *v20;
  void (*v21)(uint64_t, const char *, ...);
  void *v22;
  uint64_t v23;
  void *v24;
  void (*v25)(uint64_t, const char *, ...);
  void *v26;
  uint64_t v27;
  _BOOL4 v28;
  _BOOL8 v29;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  int v33;

  switch(a3)
  {
    case -469794816:
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(specific);
      if (Logger)
        Logger(6, "%s:%i baseband reset", "BBNotificationCallback", 132);
      v6 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v7 = NFSharedLogGetLogger(v6);
      v8 = objc_claimAutoreleasedReturnValue(v7);
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        goto LABEL_25;
      *(_DWORD *)buf = 136446466;
      v31 = "BBNotificationCallback";
      v32 = 1024;
      v33 = 132;
      v9 = "%{public}s:%i baseband reset";
      goto LABEL_24;
    case -469794815:
      v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v11 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v10);
      if (v11)
        v11(6, "%s:%i baseband alive", "BBNotificationCallback", 136);
      v12 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v13 = NFSharedLogGetLogger(v12);
      v8 = objc_claimAutoreleasedReturnValue(v13);
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        goto LABEL_25;
      *(_DWORD *)buf = 136446466;
      v31 = "BBNotificationCallback";
      v32 = 1024;
      v33 = 136;
      v9 = "%{public}s:%i baseband alive";
      goto LABEL_24;
    case -469794813:
      v14 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v15 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v14);
      if (v15)
        v15(6, "%s:%i Baseband power on", "BBNotificationCallback", 140);
      v16 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v17 = NFSharedLogGetLogger(v16);
      v18 = objc_claimAutoreleasedReturnValue(v17);
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        goto LABEL_19;
      *(_DWORD *)buf = 136446466;
      v31 = "BBNotificationCallback";
      v32 = 1024;
      v33 = 140;
      v19 = "%{public}s:%i Baseband power on";
      goto LABEL_18;
    case -469794812:
      v20 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v21 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v20);
      if (v21)
        v21(6, "%s:%i baseband down", "BBNotificationCallback", 143);
      v22 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v23 = NFSharedLogGetLogger(v22);
      v18 = objc_claimAutoreleasedReturnValue(v23);
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        goto LABEL_19;
      *(_DWORD *)buf = 136446466;
      v31 = "BBNotificationCallback";
      v32 = 1024;
      v33 = 143;
      v19 = "%{public}s:%i baseband down";
LABEL_18:
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v19, buf, 0x12u);
LABEL_19:

      break;
    case -469794811:
      v24 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v25 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v24);
      if (v25)
        v25(6, "%s:%i baseband up", "BBNotificationCallback", 146);
      v26 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v27 = NFSharedLogGetLogger(v26);
      v8 = objc_claimAutoreleasedReturnValue(v27);
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        goto LABEL_25;
      *(_DWORD *)buf = 136446466;
      v31 = "BBNotificationCallback";
      v32 = 1024;
      v33 = 146;
      v9 = "%{public}s:%i baseband up";
LABEL_24:
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v9, buf, 0x12u);
LABEL_25:

      if (a1)
      {
        v28 = sub_100191E28(a1);
        sub_1001919FC(a1);
        v29 = sub_100191E28(a1);
        if (v28 != v29)
          sub_100191E74(a1, v29);
      }
      break;
    default:
      return;
  }
}

BOOL sub_100191E28(void *a1)
{
  _BYTE *v1;
  _BOOL8 v2;

  if (!a1)
    return 0;
  v1 = a1;
  objc_sync_enter(v1);
  v2 = v1[16] != 0;
  objc_sync_exit(v1);

  return v2;
}

void sub_100191E74(void *a1, uint64_t a2)
{
  id WeakRetained;
  id *obj;

  obj = a1;
  objc_sync_enter(obj);
  WeakRetained = objc_loadWeakRetained(obj + 1);
  objc_msgSend(WeakRetained, "basebandStateChanged:", a2);

  objc_sync_exit(obj);
}

void sub_100191ECC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
  objc_sync_exit(obj);
  _Unwind_Resume(a1);
}

void sub_100192270(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 128));
  _Unwind_Resume(a1);
}

void sub_100192298(uint64_t a1, void *a2, char a3)
{
  id v5;
  id WeakRetained;
  void *v7;
  NSObject *v8;
  uint64_t v9;
  id v10;
  uint64_t v11;
  _QWORD block[5];
  id v13;
  uint64_t v14;
  uint64_t v15;
  char v16;

  v5 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v7 = WeakRetained;
  if (WeakRetained)
  {
    v8 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "workQueue"));
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100192360;
    block[3] = &unk_1002E8500;
    v9 = *(_QWORD *)(a1 + 48);
    block[4] = v7;
    v15 = v9;
    v10 = v5;
    v16 = a3;
    v11 = *(_QWORD *)(a1 + 32);
    v13 = v10;
    v14 = v11;
    dispatch_async(v8, block);

  }
}

id sub_100192360(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  id v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  id v18;
  id v19;
  void *v20;
  void *v21;
  void *v22;
  id v23;
  void *v24;
  id v26;
  objc_super v27;
  NSErrorUserInfoKey v28;
  void *v29;
  uint8_t buf[4];
  int v31;
  __int16 v32;
  const char *v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  int v37;
  __int16 v38;
  id v39;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    v9 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "debugDescription")));
    v26 = objc_msgSend(v9, "UTF8String");
    v10 = 45;
    if (isMetaClass)
      v10 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i UI is dismissed, error = %s", v10, ClassName, Name, 83, v26);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 56));
    v18 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "debugDescription")));
    *(_DWORD *)buf = 67110146;
    v31 = v15;
    v32 = 2082;
    v33 = v16;
    v34 = 2082;
    v35 = v17;
    v36 = 1024;
    v37 = 83;
    v38 = 2080;
    v39 = objc_msgSend(v18, "UTF8String");
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i UI is dismissed, error = %s", buf, 0x2Cu);

  }
  if (*(_BYTE *)(a1 + 64))
  {
    v19 = objc_alloc((Class)NSError);
    v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v28 = NSLocalizedDescriptionKey;
    v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "User cancelled"));
    v29 = v21;
    v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v29, &v28, 1));
    v23 = objc_msgSend(v19, "initWithDomain:code:userInfo:", v20, 48, v22);

    if (v23)
    {
      v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "remoteObject"));
      objc_msgSend(v24, "didTerminate:", v23);

    }
  }
  v27.receiver = *(id *)(a1 + 48);
  v27.super_class = (Class)_NFCardSession;
  return objc_msgSendSuper2(&v27, "stopEmulationWithCompletion:", 0);
}

void sub_10019261C(uint64_t a1, void *a2)
{
  id v3;
  NSObject *v4;
  id v5;
  id v6;
  _QWORD v7[4];
  id v8;
  id v9;

  v3 = a2;
  v4 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "workQueue"));
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_1001926C4;
  v7[3] = &unk_1002E82A8;
  v5 = *(id *)(a1 + 40);
  v8 = v3;
  v9 = v5;
  v6 = v3;
  dispatch_async(v4, v7);

}

uint64_t sub_1001926C4(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32));
}

void sub_100192C80(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  uint64_t v19;
  id v20;
  void *v21;
  void *v22;
  void *v23;
  id v24;
  void *v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  _QWORD v29[5];
  id v30;
  NSErrorUserInfoKey v31;
  void *v32;
  uint8_t buf[4];
  int v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  const char *v38;
  __int16 v39;
  int v40;
  __int16 v41;
  void *v42;

  if (!objc_msgSend(*(id *)(a1 + 32), "didStart")
    || (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) != 0
    || objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      v10 = 45;
      if (isMetaClass)
        v10 = 43;
      v4(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v10, ClassName, Name, 145, v9);

    }
    v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v12 = NFSharedLogGetLogger(v11);
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v14 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v14))
        v15 = 43;
      else
        v15 = 45;
      v16 = object_getClassName(*(id *)(a1 + 32));
      v17 = sel_getName(*(SEL *)(a1 + 56));
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      *(_DWORD *)buf = 67110146;
      v34 = v15;
      v35 = 2082;
      v36 = v16;
      v37 = 2082;
      v38 = v17;
      v39 = 1024;
      v40 = 145;
      v41 = 2114;
      v42 = v18;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

    }
    v19 = *(_QWORD *)(a1 + 48);
    v20 = objc_alloc((Class)NSError);
    v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v31 = NSLocalizedDescriptionKey;
    v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v32 = v22;
    v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v32, &v31, 1));
    v24 = objc_msgSend(v20, "initWithDomain:code:userInfo:", v21, 54, v23);
    (*(void (**)(uint64_t, id))(v19 + 16))(v19, v24);

  }
  else
  {
    if (objc_msgSend(*(id *)(a1 + 32), "cardState") == (id)2)
    {
      v25 = (void *)objc_claimAutoreleasedReturnValue(+[NFResponseAPDU responseWithData:](NFResponseAPDU, "responseWithData:", *(_QWORD *)(a1 + 40)));
      if (!v25)
        objc_msgSend(*(id *)(a1 + 32), "setCardState:", 1);
      if (objc_msgSend(v25, "status") == 36864)
        v26 = 3;
      else
        v26 = 1;
      objc_msgSend(*(id *)(a1 + 32), "setCardState:", v26);

    }
    v27 = *(void **)(a1 + 32);
    v28 = *(_QWORD *)(a1 + 40);
    v29[0] = _NSConcreteStackBlock;
    v29[1] = 3221225472;
    v29[2] = sub_100192FD4;
    v29[3] = &unk_1002EA478;
    v29[4] = v27;
    v30 = *(id *)(a1 + 48);
    objc_msgSend(v27, "sendAPDU:startReadOnCompletion:completion:", v28, 1, v29);

  }
}

void sub_100192FD4(uint64_t a1, void *a2)
{
  id v3;

  v3 = a2;
  if (v3)
    objc_msgSend(*(id *)(a1 + 32), "setCardState:", 1);
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

}

void sub_100193118(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  uint64_t v19;
  id v20;
  void *v21;
  void *v22;
  void *v23;
  id v24;
  void *v25;
  id v26;
  __int128 v27;
  _QWORD v28[5];
  __int128 v29;
  NSErrorUserInfoKey v30;
  void *v31;
  uint8_t buf[4];
  int v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  const char *v37;
  __int16 v38;
  int v39;
  __int16 v40;
  void *v41;

  if (!objc_msgSend(*(id *)(a1 + 32), "didStart")
    || (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) != 0
    || objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      v10 = 45;
      if (isMetaClass)
        v10 = 43;
      v4(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v10, ClassName, Name, 174, v9);

    }
    v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v12 = NFSharedLogGetLogger(v11);
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v14 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v14))
        v15 = 43;
      else
        v15 = 45;
      v16 = object_getClassName(*(id *)(a1 + 32));
      v17 = sel_getName(*(SEL *)(a1 + 48));
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      *(_DWORD *)buf = 67110146;
      v33 = v15;
      v34 = 2082;
      v35 = v16;
      v36 = 2082;
      v37 = v17;
      v38 = 1024;
      v39 = 174;
      v40 = 2114;
      v41 = v18;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

    }
    v19 = *(_QWORD *)(a1 + 40);
    v20 = objc_alloc((Class)NSError);
    v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v30 = NSLocalizedDescriptionKey;
    v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v31 = v22;
    v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v31, &v30, 1));
    v24 = objc_msgSend(v20, "initWithDomain:code:userInfo:", v21, 54, v23);
    (*(void (**)(uint64_t, id))(v19 + 16))(v19, v24);

  }
  else
  {
    v25 = *(void **)(a1 + 32);
    v28[0] = _NSConcreteStackBlock;
    v28[1] = 3221225472;
    v28[2] = sub_100193414;
    v28[3] = &unk_1002E6218;
    v28[4] = v25;
    v27 = *(_OWORD *)(a1 + 40);
    v26 = (id)v27;
    v29 = v27;
    objc_msgSend(v25, "_activateUIControllerWithCompletion:", v28);

  }
}

void sub_100193414(uint64_t a1, void *a2)
{
  id v3;
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  objc_class *v13;
  int v14;
  const char *v15;
  const char *v16;
  uint64_t v17;
  id v18;
  void *v19;
  void *v20;
  id v21;
  id v22;
  void *v23;
  id v24;
  uint64_t v25;
  const char *ClassName;
  const char *Name;
  objc_super v28;
  _QWORD v29[4];
  _QWORD v30[4];
  uint8_t buf[4];
  int v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  int v38;
  __int16 v39;
  id v40;

  v3 = a2;
  if (v3)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      v9 = 45;
      if (isMetaClass)
        v9 = 43;
      v6(5, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 178, v3);
    }
    v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v11 = NFSharedLogGetLogger(v10);
    v12 = objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      v13 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v13))
        v14 = 43;
      else
        v14 = 45;
      v15 = object_getClassName(*(id *)(a1 + 32));
      v16 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)buf = 67110146;
      v32 = v14;
      v33 = 2082;
      v34 = v15;
      v35 = 2082;
      v36 = v16;
      v37 = 1024;
      v38 = 178;
      v39 = 2114;
      v40 = v3;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
    }

    objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 224), "coreNFCUIInvalidate");
    v17 = *(_QWORD *)(a1 + 40);
    v18 = objc_alloc((Class)NSError);
    v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v29[0] = NSLocalizedDescriptionKey;
    v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid State"));
    v30[0] = v20;
    v30[1] = &off_100300A70;
    v29[1] = CFSTR("Line");
    v29[2] = CFSTR("Method");
    v21 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 48)));
    v30[2] = v21;
    v29[3] = NSDebugDescriptionErrorKey;
    v22 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 48)), 180);
    v30[3] = v22;
    v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v30, v29, 4));
    v24 = objc_msgSend(v18, "initWithDomain:code:userInfo:", v19, 12, v23);
    (*(void (**)(uint64_t, id))(v17 + 16))(v17, v24);

  }
  else
  {
    objc_msgSend(*(id *)(a1 + 32), "setCardState:", 1);
    v25 = *(_QWORD *)(a1 + 40);
    v28.receiver = *(id *)(a1 + 32);
    v28.super_class = (Class)_NFCardSession;
    objc_msgSendSuper2(&v28, "_syncStartEmulationWithCompletion:", v25);
    objc_msgSend(*(id *)(a1 + 32), "_initPaymentAIDList");
  }

}

uint64_t sub_100193888(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *v7;
  _BOOL4 v8;
  const char *v9;
  const char *v10;
  void *v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  NSObject *v15;
  objc_class *v16;
  int v17;
  const char *v18;
  const char *v19;
  void *v20;
  void *specific;
  uint64_t Logger;
  void (*v23)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  objc_class *v30;
  int v31;
  const char *v32;
  const char *v33;
  void *v35;
  uint64_t v36;
  void (*v37)(uint64_t, const char *, ...);
  objc_class *v38;
  _BOOL4 v39;
  const char *v40;
  const char *v41;
  uint64_t v42;
  void *v43;
  uint64_t v44;
  NSObject *v45;
  objc_class *v46;
  int v47;
  const char *v48;
  const char *v49;
  void *v50;
  const char *Name;
  uint8_t buf[4];
  int v53;
  __int16 v54;
  const char *v55;
  __int16 v56;
  const char *v57;
  __int16 v58;
  int v59;
  __int16 v60;
  void *v61;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = objc_opt_class(NSString);
  if ((objc_opt_isKindOfClass(v2, v3) & 1) == 0)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v23 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 40));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 40));
      Name = sel_getName(*(SEL *)(a1 + 56));
      v27 = 45;
      if (isMetaClass)
        v27 = 43;
      v23(4, "%c[%{public}s %{public}s]:%i Invalid string; dropping request", v27, ClassName, Name, 202);
    }
    v28 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v29 = NFSharedLogGetLogger(v28);
    v15 = objc_claimAutoreleasedReturnValue(v29);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      v30 = object_getClass(*(id *)(a1 + 40));
      if (class_isMetaClass(v30))
        v31 = 43;
      else
        v31 = 45;
      v32 = object_getClassName(*(id *)(a1 + 40));
      v33 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)buf = 67109890;
      v53 = v31;
      v54 = 2082;
      v55 = v32;
      v56 = 2082;
      v57 = v33;
      v58 = 1024;
      v59 = 202;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid string; dropping request",
        buf,
        0x22u);
    }
    goto LABEL_23;
  }
  if (!objc_msgSend(*(id *)(a1 + 40), "didStart")
    || (objc_msgSend(*(id *)(a1 + 40), "isSuspended") & 1) != 0
    || objc_msgSend(*(id *)(a1 + 40), "didEnd"))
  {
    v4 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v5 = NFLogGetLogger(v4);
    if (v5)
    {
      v6 = (void (*)(uint64_t, const char *, ...))v5;
      v7 = object_getClass(*(id *)(a1 + 40));
      v8 = class_isMetaClass(v7);
      v9 = object_getClassName(*(id *)(a1 + 40));
      v10 = sel_getName(*(SEL *)(a1 + 56));
      v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "sessionUID"));
      v12 = 45;
      if (v8)
        v12 = 43;
      v6(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v12, v9, v10, 207, v11);

    }
    v13 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v14 = NFSharedLogGetLogger(v13);
    v15 = objc_claimAutoreleasedReturnValue(v14);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      v16 = object_getClass(*(id *)(a1 + 40));
      if (class_isMetaClass(v16))
        v17 = 43;
      else
        v17 = 45;
      v18 = object_getClassName(*(id *)(a1 + 40));
      v19 = sel_getName(*(SEL *)(a1 + 56));
      v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "sessionUID"));
      *(_DWORD *)buf = 67110146;
      v53 = v17;
      v54 = 2082;
      v55 = v18;
      v56 = 2082;
      v57 = v19;
      v58 = 1024;
      v59 = 207;
      v60 = 2114;
      v61 = v20;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

    }
LABEL_23:

    return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
  }
  v35 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v36 = NFLogGetLogger(v35);
  if (v36)
  {
    v37 = (void (*)(uint64_t, const char *, ...))v36;
    v38 = object_getClass(*(id *)(a1 + 40));
    v39 = class_isMetaClass(v38);
    v40 = object_getClassName(*(id *)(a1 + 40));
    v41 = sel_getName(*(SEL *)(a1 + 56));
    v42 = 45;
    if (v39)
      v42 = 43;
    v37(5, "%c[%{public}s %{public}s]:%i String updated=%{public}@", v42, v40, v41, 209, *(_QWORD *)(a1 + 32));
  }
  v43 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v44 = NFSharedLogGetLogger(v43);
  v45 = objc_claimAutoreleasedReturnValue(v44);
  if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
  {
    v46 = object_getClass(*(id *)(a1 + 40));
    if (class_isMetaClass(v46))
      v47 = 43;
    else
      v47 = 45;
    v48 = object_getClassName(*(id *)(a1 + 40));
    v49 = sel_getName(*(SEL *)(a1 + 56));
    v50 = *(void **)(a1 + 32);
    *(_DWORD *)buf = 67110146;
    v53 = v47;
    v54 = 2082;
    v55 = v48;
    v56 = 2082;
    v57 = v49;
    v58 = 1024;
    v59 = 209;
    v60 = 2114;
    v61 = v50;
    _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i String updated=%{public}@", buf, 0x2Cu);
  }

  objc_msgSend(*(id *)(*(_QWORD *)(a1 + 40) + 224), "coreNFCUISetScanText:", *(_QWORD *)(a1 + 32));
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
}

void sub_100195CCC(uint64_t a1, void *a2)
{
  id v3;
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  objc_class *v13;
  int v14;
  const char *v15;
  const char *v16;
  const char *ClassName;
  const char *Name;
  uint8_t buf[4];
  int v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  id v28;

  v3 = a2;
  if (v3)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 40));
      v9 = 45;
      if (isMetaClass)
        v9 = 43;
      v6(5, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 375, v3);
    }
    v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v11 = NFSharedLogGetLogger(v10);
    v12 = objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      v13 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v13))
        v14 = 43;
      else
        v14 = 45;
      v15 = object_getClassName(*(id *)(a1 + 32));
      v16 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)buf = 67110146;
      v20 = v14;
      v21 = 2082;
      v22 = v15;
      v23 = 2082;
      v24 = v16;
      v25 = 1024;
      v26 = 375;
      v27 = 2114;
      v28 = v3;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
    }

    objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 224), "coreNFCUIInvalidate");
  }
  else
  {
    objc_msgSend(*(id *)(a1 + 32), "setCardState:", 1);
  }

}

void sub_100195F14(uint64_t a1, void *a2)
{
  id v3;
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  objc_class *v13;
  int v14;
  const char *v15;
  const char *v16;
  const char *ClassName;
  const char *Name;
  uint8_t buf[4];
  int v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  id v28;

  v3 = a2;
  if (v3)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 40));
      v9 = 45;
      if (isMetaClass)
        v9 = 43;
      v6(5, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 392, v3);
    }
    v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v11 = NFSharedLogGetLogger(v10);
    v12 = objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      v13 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v13))
        v14 = 43;
      else
        v14 = 45;
      v15 = object_getClassName(*(id *)(a1 + 32));
      v16 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)buf = 67110146;
      v20 = v14;
      v21 = 2082;
      v22 = v15;
      v23 = 2082;
      v24 = v16;
      v25 = 1024;
      v26 = 392;
      v27 = 2114;
      v28 = v3;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
    }

    objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 224), "coreNFCUIInvalidate");
  }
  else
  {
    objc_msgSend(*(id *)(a1 + 32), "setCardState:", 1);
  }

}

uint64_t sub_1001962B0(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_1001962C0(uint64_t a1)
{

}

void sub_1001962C8(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t domain_answer;
  uint64_t v6;
  void *specific;
  uint64_t Logger;
  void (*v9)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  NSObject *v15;
  objc_class *v16;
  int v17;
  const char *v18;
  const char *v19;
  void *v20;
  uint64_t v21;
  void (*v22)(uint64_t, const char *, ...);
  objc_class *v23;
  _BOOL4 v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  NSObject *v28;
  objc_class *v29;
  int v30;
  const char *v31;
  const char *v32;
  void *v33;
  uint64_t v34;
  void (*v35)(uint64_t, const char *, ...);
  objc_class *v36;
  _BOOL4 v37;
  const char *v38;
  uint64_t v39;
  void *v40;
  uint64_t v41;
  NSObject *v42;
  objc_class *v43;
  int v44;
  const char *v45;
  const char *v46;
  void *v47;
  uint64_t v48;
  void (*v49)(uint64_t, const char *, ...);
  objc_class *v50;
  _BOOL4 v51;
  const char *v52;
  uint64_t v53;
  void *v54;
  uint64_t v55;
  NSObject *v56;
  objc_class *v57;
  int v58;
  const char *v59;
  const char *v60;
  uint64_t v61;
  void *v62;
  void (*v63)(void);
  uint64_t v64;
  void *v65;
  uint64_t v66;
  void *v67;
  uint64_t v68;
  uint64_t v69;
  __int128 v70;
  const char *ClassName;
  const char *v72;
  const char *Name;
  const char *v74;
  const char *v75;
  const char *v76;
  _QWORD v77[4];
  id v78;
  uint64_t v79;
  int8x16_t v80;
  uint64_t v81;
  _BYTE buf[34];
  __int16 v83;
  int v84;

  v81 = 0;
  if (a2)
    v4 = 13;
  else
    v4 = 12;
  domain_answer = os_eligibility_get_domain_answer(v4, &v81, 0, 0, 0);
  if ((_DWORD)domain_answer)
  {
    v6 = domain_answer;
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v9 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 48));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 48));
      Name = sel_getName(*(SEL *)(a1 + 56));
      v12 = 45;
      if (isMetaClass)
        v12 = 43;
      v9(6, "%c[%{public}s %{public}s]:%i errno=%{public}d", v12, ClassName, Name, 422, v6);
    }
    v13 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v14 = NFSharedLogGetLogger(v13);
    v15 = objc_claimAutoreleasedReturnValue(v14);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v16 = object_getClass(*(id *)(a1 + 48));
      if (class_isMetaClass(v16))
        v17 = 43;
      else
        v17 = 45;
      v18 = object_getClassName(*(id *)(a1 + 48));
      v19 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)buf = 67110146;
      *(_DWORD *)&buf[4] = v17;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = v18;
      *(_WORD *)&buf[18] = 2082;
      *(_QWORD *)&buf[20] = v19;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 422;
      v83 = 1026;
      v84 = v6;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i errno=%{public}d", buf, 0x28u);
    }

LABEL_47:
    v63 = *(void (**)(void))(*(_QWORD *)(a1 + 32) + 16);
LABEL_48:
    v63();
  }
  else
  {
    switch(v81)
    {
      case 0:
        v20 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v21 = NFLogGetLogger(v20);
        if (v21)
        {
          v22 = (void (*)(uint64_t, const char *, ...))v21;
          v23 = object_getClass(*(id *)(a1 + 48));
          v24 = class_isMetaClass(v23);
          v72 = object_getClassName(*(id *)(a1 + 48));
          v74 = sel_getName(*(SEL *)(a1 + 56));
          v25 = 45;
          if (v24)
            v25 = 43;
          v22(3, "%c[%{public}s %{public}s]:%i Error=%d", v25, v72, v74, 429, 0);
        }
        v26 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v27 = NFSharedLogGetLogger(v26);
        v28 = objc_claimAutoreleasedReturnValue(v27);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        {
          v29 = object_getClass(*(id *)(a1 + 48));
          if (class_isMetaClass(v29))
            v30 = 43;
          else
            v30 = 45;
          v31 = object_getClassName(*(id *)(a1 + 48));
          v32 = sel_getName(*(SEL *)(a1 + 56));
          *(_DWORD *)buf = 67110146;
          *(_DWORD *)&buf[4] = v30;
          *(_WORD *)&buf[8] = 2082;
          *(_QWORD *)&buf[10] = v31;
          *(_WORD *)&buf[18] = 2082;
          *(_QWORD *)&buf[20] = v32;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = 429;
          v83 = 1024;
          v84 = 0;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error=%d", buf, 0x28u);
        }

        goto LABEL_26;
      case 1:
        goto LABEL_36;
      case 2:
        goto LABEL_46;
      case 3:
LABEL_26:
        v33 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v34 = NFLogGetLogger(v33);
        if (v34)
        {
          v35 = (void (*)(uint64_t, const char *, ...))v34;
          v36 = object_getClass(*(id *)(a1 + 48));
          v37 = class_isMetaClass(v36);
          v38 = object_getClassName(*(id *)(a1 + 48));
          v75 = sel_getName(*(SEL *)(a1 + 56));
          v39 = 45;
          if (v37)
            v39 = 43;
          v35(4, "%c[%{public}s %{public}s]:%i Forcing uncertainity to ineligible", v39, v38, v75, 432);
        }
        v40 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v41 = NFSharedLogGetLogger(v40);
        v42 = objc_claimAutoreleasedReturnValue(v41);
        if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
        {
          v43 = object_getClass(*(id *)(a1 + 48));
          if (class_isMetaClass(v43))
            v44 = 43;
          else
            v44 = 45;
          v45 = object_getClassName(*(id *)(a1 + 48));
          v46 = sel_getName(*(SEL *)(a1 + 56));
          *(_DWORD *)buf = 67109890;
          *(_DWORD *)&buf[4] = v44;
          *(_WORD *)&buf[8] = 2082;
          *(_QWORD *)&buf[10] = v45;
          *(_WORD *)&buf[18] = 2082;
          *(_QWORD *)&buf[20] = v46;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = 432;
          _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Forcing uncertainity to ineligible", buf, 0x22u);
        }

LABEL_36:
        v47 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v48 = NFLogGetLogger(v47);
        if (v48)
        {
          v49 = (void (*)(uint64_t, const char *, ...))v48;
          v50 = object_getClass(*(id *)(a1 + 48));
          v51 = class_isMetaClass(v50);
          v52 = object_getClassName(*(id *)(a1 + 48));
          v76 = sel_getName(*(SEL *)(a1 + 56));
          v53 = 45;
          if (v51)
            v53 = 43;
          v49(6, "%c[%{public}s %{public}s]:%i Unknown answer", v53, v52, v76, 435);
        }
        v54 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v55 = NFSharedLogGetLogger(v54);
        v56 = objc_claimAutoreleasedReturnValue(v55);
        if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
        {
          v57 = object_getClass(*(id *)(a1 + 48));
          if (class_isMetaClass(v57))
            v58 = 43;
          else
            v58 = 45;
          v59 = object_getClassName(*(id *)(a1 + 48));
          v60 = sel_getName(*(SEL *)(a1 + 56));
          *(_DWORD *)buf = 67109890;
          *(_DWORD *)&buf[4] = v58;
          *(_WORD *)&buf[8] = 2082;
          *(_QWORD *)&buf[10] = v59;
          *(_WORD *)&buf[18] = 2082;
          *(_QWORD *)&buf[20] = v60;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = 435;
          _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Unknown answer", buf, 0x22u);
        }

LABEL_46:
        v61 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
        v62 = *(void **)(v61 + 40);
        *(_QWORD *)(v61 + 40) = 0;

        goto LABEL_47;
      default:
        if (!*(_BYTE *)(a1 + 96) || a2 == 2 || a2 == 1)
        {
          v64 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
          v65 = *(void **)(v64 + 40);
          *(_QWORD *)(v64 + 40) = 0;

          v63 = *(void (**)(void))(*(_QWORD *)(a1 + 32) + 16);
          goto LABEL_48;
        }
        v67 = *(void **)(a1 + 32);
        v66 = *(_QWORD *)(a1 + 40);
        v68 = *(_QWORD *)(v66 + 8);
        v77[0] = _NSConcreteStackBlock;
        v77[2] = sub_10019692C;
        v77[3] = &unk_1002EA4C0;
        v69 = *(_QWORD *)(v68 + 40);
        v77[1] = 3221225472;
        v80 = vextq_s8(*(int8x16_t *)(a1 + 48), *(int8x16_t *)(a1 + 48), 8uLL);
        v79 = v66;
        v78 = v67;
        v70 = *(_OWORD *)(a1 + 80);
        *(_OWORD *)buf = *(_OWORD *)(a1 + 64);
        *(_OWORD *)&buf[16] = v70;
        sub_1000AA494(v69, 1, (__int128 *)buf, v77);

        break;
    }
  }
}

uint64_t sub_10019692C(_QWORD *a1, uint64_t a2)
{
  void *v3;
  uint64_t v4;
  void *v5;

  if (!a2)
  {
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
    objc_msgSend(v3, "handleFailureInMethod:object:file:lineNumber:description:", a1[6], a1[7], CFSTR("_NFCardSession.m"), 478, CFSTR("Invalid state"));

  }
  v4 = *(_QWORD *)(a1[5] + 8);
  v5 = *(void **)(v4 + 40);
  *(_QWORD *)(v4 + 40) = 0;

  return (*(uint64_t (**)(void))(a1[4] + 16))();
}

void sub_100196E44(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  uint64_t v19;
  id v20;
  void *v21;
  void *v22;
  void *v23;
  id v24;
  uint64_t v25;
  id v26;
  id v27;
  NSErrorUserInfoKey v28;
  void *v29;
  uint8_t buf[4];
  int v31;
  __int16 v32;
  const char *v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  int v37;
  __int16 v38;
  void *v39;

  if (!objc_msgSend(*(id *)(a1 + 32), "didStart")
    || (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) != 0
    || objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      v10 = 45;
      if (isMetaClass)
        v10 = 43;
      v4(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v10, ClassName, Name, 54, v9);

    }
    v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v12 = NFSharedLogGetLogger(v11);
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v14 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v14))
        v15 = 43;
      else
        v15 = 45;
      v16 = object_getClassName(*(id *)(a1 + 32));
      v17 = sel_getName(*(SEL *)(a1 + 48));
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      *(_DWORD *)buf = 67110146;
      v31 = v15;
      v32 = 2082;
      v33 = v16;
      v34 = 2082;
      v35 = v17;
      v36 = 1024;
      v37 = 54;
      v38 = 2114;
      v39 = v18;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

    }
    v19 = *(_QWORD *)(a1 + 40);
    if (v19)
    {
      v20 = objc_alloc((Class)NSError);
      v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v28 = NSLocalizedDescriptionKey;
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
      v29 = v22;
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v29, &v28, 1));
      v24 = objc_msgSend(v20, "initWithDomain:code:userInfo:", v21, 54, v23);
      (*(void (**)(uint64_t, id))(v19 + 16))(v19, v24);

    }
  }
  else
  {
    v25 = *(_QWORD *)(a1 + 40);
    v26 = sub_1000964AC(*(id *)(*(_QWORD *)(a1 + 32) + 160));
    v27 = (id)objc_claimAutoreleasedReturnValue(v26);
    (*(void (**)(uint64_t))(v25 + 16))(v25);

  }
}

void sub_100197244(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  NSObject *v15;
  objc_class *v16;
  int v17;
  const char *v18;
  const char *v19;
  void *v20;
  uint64_t v21;
  id v22;
  NFPeerPaymentResponse *v23;
  void *v24;
  NSObject *v25;
  id v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  unsigned int v30;
  void *v31;
  objc_class *v32;
  uint64_t v33;
  NSObject *v34;
  uint64_t v35;
  uint64_t v36;
  NFPeerPaymentResponse *v37;
  NSErrorUserInfoKey v38;
  void *v39;
  uint8_t buf[4];
  int v41;
  __int16 v42;
  const char *v43;
  __int16 v44;
  const char *v45;
  __int16 v46;
  int v47;
  __int16 v48;
  void *v49;

  v2 = NFSharedSignpostLog(a1);
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_signpost_enabled(v3))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v3, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SURF_PAYMENT", "in", buf, 2u);
  }

  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v27 = *(_QWORD **)(a1 + 32);
    v28 = *(void **)(a1 + 40);
    v29 = (void *)v27[20];
    v30 = objc_msgSend(v27, "uid");
    v31 = *(void **)(a1 + 48);
    v37 = 0;
    v32 = sub_100094B68(v29, v28, v30, v31, &v37);
    v24 = (void *)objc_claimAutoreleasedReturnValue(v32);
    v23 = v37;
    if (v24)
      +[NFGeneralStatisticsCALogger updateAnalyticsGeneralTransactionStatistics:](NFGeneralStatisticsCALogger, "updateAnalyticsGeneralTransactionStatistics:", &off_100306AB0);
    v33 = NFSharedSignpostLog(+[NFGeneralStatisticsCALogger updateAnalyticsGeneralTransactionStatistics:](NFGeneralStatisticsCALogger, "updateAnalyticsGeneralTransactionStatistics:", &off_100306AD8));
    v34 = objc_claimAutoreleasedReturnValue(v33);
    if (os_signpost_enabled(v34))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v34, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SURF_PAYMENT", "callback", buf, 2u);
    }

    v35 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 56) + 16))();
    v36 = NFSharedSignpostLog(v35);
    v25 = objc_claimAutoreleasedReturnValue(v36);
    if (os_signpost_enabled(v25))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v25, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SURF_PAYMENT", "out", buf, 2u);
    }
    goto LABEL_17;
  }
  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v6 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 64));
    v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v12 = 45;
    if (isMetaClass)
      v12 = 43;
    v6(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v12, ClassName, Name, 68, v11);

  }
  v13 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v14 = NFSharedLogGetLogger(v13);
  v15 = objc_claimAutoreleasedReturnValue(v14);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    v16 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v16))
      v17 = 43;
    else
      v17 = 45;
    v18 = object_getClassName(*(id *)(a1 + 32));
    v19 = sel_getName(*(SEL *)(a1 + 64));
    v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v41 = v17;
    v42 = 2082;
    v43 = v18;
    v44 = 2082;
    v45 = v19;
    v46 = 1024;
    v47 = 68;
    v48 = 2114;
    v49 = v20;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v21 = *(_QWORD *)(a1 + 56);
  if (v21)
  {
    v22 = objc_alloc((Class)NSError);
    v23 = (NFPeerPaymentResponse *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v38 = NSLocalizedDescriptionKey;
    v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v39 = v24;
    v25 = objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v39, &v38, 1));
    v26 = objc_msgSend(v22, "initWithDomain:code:userInfo:", v23, 54, v25);
    (*(void (**)(uint64_t, _QWORD, id))(v21 + 16))(v21, 0, v26);

LABEL_17:
  }
}

uint64_t sub_100197698(uint64_t result)
{
  _BYTE *v1;
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  NSObject *v11;
  objc_class *v12;
  int v13;
  const char *v14;
  const char *v15;
  const char *Name;
  _QWORD v17[3];
  int v18;
  uint8_t buf[4];
  int v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  int v26;

  if (result)
  {
    if (HIBYTE(word_10032AAD2) == 1)
    {
      return word_10032AAD2;
    }
    else
    {
      v1 = (_BYTE *)result;
      memset(v17, 0, sizeof(v17));
      v18 = 0;
      if ((NFDriverGetControllerInfo(*(_QWORD *)(result + 40), v17) & 1) != 0)
      {
        if (HIDWORD(v17[0]) > 7)
        {
          if ((v1[218] & 1) != 0)
          {
            word_10032AAD2 = 257;
            return 1;
          }
          else
          {
            if ((NFIsNonRFDeviceWithLPMSupport() & 1) != 0)
            {
              result = 1;
              LOBYTE(word_10032AAD2) = 1;
            }
            else
            {
              result = word_10032AAD2;
            }
            HIBYTE(word_10032AAD2) = 1;
          }
        }
        else
        {
          HIBYTE(word_10032AAD2) = 1;
          return word_10032AAD2;
        }
      }
      else
      {
        specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        Logger = NFLogGetLogger(specific);
        if (Logger)
        {
          v4 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(v1);
          isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(v1);
          Name = sel_getName("supportsLPEM");
          v8 = 45;
          if (isMetaClass)
            v8 = 43;
          v4(3, "%c[%{public}s %{public}s]:%i Failed to get info", v8, ClassName, Name, 27);
        }
        v9 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v10 = NFSharedLogGetLogger(v9);
        v11 = objc_claimAutoreleasedReturnValue(v10);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          v12 = object_getClass(v1);
          if (class_isMetaClass(v12))
            v13 = 43;
          else
            v13 = 45;
          v14 = object_getClassName(v1);
          v15 = sel_getName("supportsLPEM");
          *(_DWORD *)buf = 67109890;
          v20 = v13;
          v21 = 2082;
          v22 = v14;
          v23 = 2082;
          v24 = v15;
          v25 = 1024;
          v26 = 27;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get info", buf, 0x22u);
        }

        return 0;
      }
    }
  }
  return result;
}

uint64_t sub_1001978C4(uint64_t a1)
{
  uint64_t v1;

  if (!sub_100197698(a1))
    return 0;
  v1 = (NFProductIsPhone() & 1) != 0 || NFProductIsWatch();
  if ((NFProductIsPhone() & 1) != 0 || NFProductIsWatch())
    v1 |= 2uLL;
  if ((NFProductIsPhone() & 1) != 0 || (NFProductIsWatch() & 1) != 0 || NFIsNonRFDeviceWithLPMSupport())
    v1 |= 4uLL;
  if (NFIsSeashipSupported())
    v1 |= 8uLL;
  if (NFIsSeashipSupported())
    return v1 | 0x10;
  else
    return v1;
}

uint64_t sub_100197958(uint64_t a1)
{
  id v1;
  _QWORD *v2;
  uint64_t v3;

  if (!a1)
    return 0;
  v1 = sub_100203984((uint64_t)NFHeadlessModeController);
  v2 = (_QWORD *)objc_claimAutoreleasedReturnValue(v1);
  if (v2)
    v3 = v2[4];
  else
    v3 = 0;

  return v3;
}

uint64_t sub_1001979A4(uint64_t result, uint64_t a2)
{
  char v2;
  _BYTE *v3;
  void *v4;
  uint64_t v5;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *v7;
  _BOOL4 v8;
  const char *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  void *specific;
  uint64_t Logger;
  void (*v19)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  objc_class *v26;
  int v27;
  const char *v28;
  const char *Name;
  uint8_t buf[4];
  int v31;
  __int16 v32;
  const char *v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  int v37;

  if (result)
  {
    v2 = a2;
    if (a2)
    {
      v3 = (_BYTE *)result;
      if ((sub_100197698(result) & 1) == 0)
      {
        specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        Logger = NFLogGetLogger(specific);
        if (Logger)
        {
          v19 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(v3);
          isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(v3);
          Name = sel_getName("isHeadlessModeFeatureSupported:");
          v23 = 45;
          if (isMetaClass)
            v23 = 43;
          v19(3, "%c[%{public}s %{public}s]:%i LPEM not supported!", v23, ClassName, Name, 155);
        }
        v24 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v25 = NFSharedLogGetLogger(v24);
        v13 = objc_claimAutoreleasedReturnValue(v25);
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          goto LABEL_26;
        v26 = object_getClass(v3);
        if (class_isMetaClass(v26))
          v27 = 43;
        else
          v27 = 45;
        *(_DWORD *)buf = 67109890;
        v31 = v27;
        v32 = 2082;
        v33 = object_getClassName(v3);
        v34 = 2082;
        v35 = sel_getName("isHeadlessModeFeatureSupported:");
        v36 = 1024;
        v37 = 155;
        v16 = "%c[%{public}s %{public}s]:%i LPEM not supported!";
        goto LABEL_25;
      }
      if ((v2 & 3) != 0 && (v3[218] & 1) == 0)
      {
        v4 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v5 = NFLogGetLogger(v4);
        if (v5)
        {
          v6 = (void (*)(uint64_t, const char *, ...))v5;
          v7 = object_getClass(v3);
          v8 = class_isMetaClass(v7);
          v9 = object_getClassName(v3);
          v28 = sel_getName("isHeadlessModeFeatureSupported:");
          v10 = 45;
          if (v8)
            v10 = 43;
          v6(3, "%c[%{public}s %{public}s]:%i no antenna - this type is not supported!", v10, v9, v28, 162);
        }
        v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v12 = NFSharedLogGetLogger(v11);
        v13 = objc_claimAutoreleasedReturnValue(v12);
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          goto LABEL_26;
        v14 = object_getClass(v3);
        if (class_isMetaClass(v14))
          v15 = 43;
        else
          v15 = 45;
        *(_DWORD *)buf = 67109890;
        v31 = v15;
        v32 = 2082;
        v33 = object_getClassName(v3);
        v34 = 2082;
        v35 = sel_getName("isHeadlessModeFeatureSupported:");
        v36 = 1024;
        v37 = 162;
        v16 = "%c[%{public}s %{public}s]:%i no antenna - this type is not supported!";
LABEL_25:
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, v16, buf, 0x22u);
LABEL_26:

        return 0;
      }
    }
    return 1;
  }
  return result;
}

uint64_t sub_100197C58(void *a1, uint64_t a2)
{
  uint64_t v2;
  id v4;
  void *v5;
  _BOOL4 v6;
  void *v7;
  uint64_t v8;
  void (*v9)(uint64_t, const char *, ...);
  objc_class *v10;
  _BOOL4 v11;
  const char *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  NSObject *v16;
  objc_class *v17;
  int v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  void (*v22)(uint64_t, const char *, ...);
  objc_class *v23;
  _BOOL4 v24;
  const char *v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  NSObject *v29;
  objc_class *v30;
  int v31;
  const char *v32;
  const char *v33;
  id v34;
  NSObject *v35;
  void *specific;
  uint64_t Logger;
  void (*v38)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v41;
  void *v42;
  uint64_t v43;
  objc_class *v44;
  int v45;
  const char *ClassName;
  const char *v48;
  const char *v49;
  const char *Name;
  uint8_t buf[4];
  int v52;
  __int16 v53;
  const char *v54;
  __int16 v55;
  const char *v56;
  __int16 v57;
  int v58;
  __int16 v59;
  int v60;

  if (!a1)
    return 0;
  v2 = a2;
  if (a2 == 31)
    v2 = sub_1001978C4((uint64_t)a1);
  if ((sub_1001979A4((uint64_t)a1, v2) & 1) == 0)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v38 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("addHeadlessModeFeature:");
      v41 = 45;
      if (isMetaClass)
        v41 = 43;
      v38(6, "%c[%{public}s %{public}s]:%i type %x not supported!", v41, ClassName, Name, 199, v2);
    }
    v42 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v43 = NFSharedLogGetLogger(v42);
    v35 = objc_claimAutoreleasedReturnValue(v43);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      v44 = object_getClass(a1);
      if (class_isMetaClass(v44))
        v45 = 43;
      else
        v45 = 45;
      *(_DWORD *)buf = 67110146;
      v52 = v45;
      v53 = 2082;
      v54 = object_getClassName(a1);
      v55 = 2082;
      v56 = sel_getName("addHeadlessModeFeature:");
      v57 = 1024;
      v58 = 199;
      v59 = 1024;
      v60 = v2;
      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i type %x not supported!", buf, 0x28u);
    }
    goto LABEL_35;
  }
  v4 = sub_100203984((uint64_t)NFHeadlessModeController);
  v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  v6 = sub_10020664C(v5, v2);

  if (!v6)
    return 1;
  v7 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v8 = NFLogGetLogger(v7);
  if (v8)
  {
    v9 = (void (*)(uint64_t, const char *, ...))v8;
    v10 = object_getClass(a1);
    v11 = class_isMetaClass(v10);
    v12 = object_getClassName(a1);
    v48 = sel_getName("addHeadlessModeFeature:");
    v13 = 45;
    if (v11)
      v13 = 43;
    v9(6, "%c[%{public}s %{public}s]:%i LPEM features changed, enabling", v13, v12, v48, 204);
  }
  v14 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v15 = NFSharedLogGetLogger(v14);
  v16 = objc_claimAutoreleasedReturnValue(v15);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    v17 = object_getClass(a1);
    if (class_isMetaClass(v17))
      v18 = 43;
    else
      v18 = 45;
    *(_DWORD *)buf = 67109890;
    v52 = v18;
    v53 = 2082;
    v54 = object_getClassName(a1);
    v55 = 2082;
    v56 = sel_getName("addHeadlessModeFeature:");
    v57 = 1024;
    v58 = 204;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i LPEM features changed, enabling", buf, 0x22u);
  }

  v19 = 1;
  if ((objc_msgSend(a1, "enableHeadlessMode:shutdown:", 1, 0) & 1) == 0)
  {
    v20 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v21 = NFLogGetLogger(v20);
    if (v21)
    {
      v22 = (void (*)(uint64_t, const char *, ...))v21;
      v23 = object_getClass(a1);
      v24 = class_isMetaClass(v23);
      v25 = object_getClassName(a1);
      v49 = sel_getName("addHeadlessModeFeature:");
      v26 = 45;
      if (v24)
        v26 = 43;
      v22(3, "%c[%{public}s %{public}s]:%i Failed to enable LPEM, reverting", v26, v25, v49, 206);
    }
    v27 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v28 = NFSharedLogGetLogger(v27);
    v29 = objc_claimAutoreleasedReturnValue(v28);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      v30 = object_getClass(a1);
      if (class_isMetaClass(v30))
        v31 = 43;
      else
        v31 = 45;
      v32 = object_getClassName(a1);
      v33 = sel_getName("addHeadlessModeFeature:");
      *(_DWORD *)buf = 67109890;
      v52 = v31;
      v53 = 2082;
      v54 = v32;
      v55 = 2082;
      v56 = v33;
      v57 = 1024;
      v58 = 206;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to enable LPEM, reverting", buf, 0x22u);
    }

    v34 = sub_100203984((uint64_t)NFHeadlessModeController);
    v35 = objc_claimAutoreleasedReturnValue(v34);
    sub_100206980(v35, v2);
LABEL_35:

    return 0;
  }
  return v19;
}

uint64_t sub_1001980AC(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  void *v3;
  id v4;
  void *v5;
  _BOOL4 v6;
  void *specific;
  uint64_t Logger;
  void (*v9)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  NSObject *v16;
  objc_class *v17;
  int v18;
  id v19;
  void *v20;
  const char *Name;
  uint8_t buf[4];
  int v23;
  __int16 v24;
  const char *v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  int v29;

  if (result)
  {
    v2 = a2;
    v3 = (void *)result;
    if (a2 == 31)
      v2 = sub_1001978C4(result);
    if (sub_1001979A4((uint64_t)v3, v2)
      && (v4 = sub_100203984((uint64_t)NFHeadlessModeController),
          v5 = (void *)objc_claimAutoreleasedReturnValue(v4),
          v6 = sub_100206980(v5, v2),
          v5,
          v6)
      && (objc_msgSend(v3, "enableHeadlessMode:shutdown:", sub_100197958((uint64_t)v3) != 0, 0) & 1) == 0)
    {
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v9 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(v3);
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(v3);
        Name = sel_getName("removeHeadlessModeFeature:");
        v13 = 45;
        if (isMetaClass)
          v13 = 43;
        v9(3, "%c[%{public}s %{public}s]:%i Failed to change LPEM, reverting", v13, ClassName, Name, 227);
      }
      v14 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v15 = NFSharedLogGetLogger(v14);
      v16 = objc_claimAutoreleasedReturnValue(v15);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        v17 = object_getClass(v3);
        if (class_isMetaClass(v17))
          v18 = 43;
        else
          v18 = 45;
        *(_DWORD *)buf = 67109890;
        v23 = v18;
        v24 = 2082;
        v25 = object_getClassName(v3);
        v26 = 2082;
        v27 = sel_getName("removeHeadlessModeFeature:");
        v28 = 1024;
        v29 = 227;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to change LPEM, reverting", buf, 0x22u);
      }

      v19 = sub_100203984((uint64_t)NFHeadlessModeController);
      v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
      sub_10020664C(v20, v2);

      return 0;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

id sub_1001982D0(id result)
{
  void *v1;
  id v2;
  void *v3;

  if (result)
  {
    v1 = result;
    v2 = sub_100203984((uint64_t)NFHeadlessModeController);
    v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
    sub_1002065C0(v3, 0);

    return objc_msgSend(v1, "enableHeadlessMode:shutdown:", 0, 1);
  }
  return result;
}

void sub_1001988CC(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_100198900(void *a1)
{
  id v1;
  id v2;
  void *v3;
  void *v4;
  id v5;
  id v6;
  void *v7;
  id v8;
  unsigned __int8 v9;
  unsigned __int8 v10;
  id v11;
  void *v12;
  id v13;
  _BYTE *v14;
  id v15;
  void *v16;
  id v17;
  _QWORD v19[4];
  _QWORD v20[4];
  _QWORD v21[4];
  _QWORD v22[4];

  if (!a1)
    return 0;
  v1 = a1;
  objc_sync_enter(v1);
  if (*((_BYTE *)v1 + 137))
  {
    v2 = objc_alloc((Class)NSError);
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v21[0] = NSLocalizedDescriptionKey;
    v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Aborted"));
    v22[0] = v4;
    v22[1] = &off_100300B48;
    v21[1] = CFSTR("Line");
    v21[2] = CFSTR("Method");
    v5 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("disableHeadlessMiniNV"));
    v22[2] = v5;
    v21[3] = NSDebugDescriptionErrorKey;
    v6 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("disableHeadlessMiniNV"), 289);
    v22[3] = v6;
    v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v22, v21, 4));
    v8 = objc_msgSend(v2, "initWithDomain:code:userInfo:", v3, 3, v7);
LABEL_7:
    v16 = v8;

    goto LABEL_8;
  }
  v9 = NFDriverSetHeadlessMode(*((_QWORD *)v1 + 5), 0);
  v10 = NFDriverDisableHeadlessModeMiniNV(*((_QWORD *)v1 + 5));
  v11 = sub_100203984((uint64_t)NFHeadlessModeController);
  v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
  sub_100206E80((uint64_t)v12);

  v13 = sub_100203984((uint64_t)NFHeadlessModeController);
  v14 = (_BYTE *)objc_claimAutoreleasedReturnValue(v13);
  v15 = sub_100203F98(v14);

  if ((v9 & v10 & 1) == 0)
  {
    v17 = objc_alloc((Class)NSError);
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v19[0] = NSLocalizedDescriptionKey;
    v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unknown Error"));
    v20[0] = v4;
    v20[1] = &off_100300B60;
    v19[1] = CFSTR("Line");
    v19[2] = CFSTR("Method");
    v5 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("disableHeadlessMiniNV"));
    v20[2] = v5;
    v19[3] = NSDebugDescriptionErrorKey;
    v6 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("disableHeadlessMiniNV"), 298);
    v20[3] = v6;
    v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v20, v19, 4));
    v8 = objc_msgSend(v17, "initWithDomain:code:userInfo:", v3, 6, v7);
    goto LABEL_7;
  }
  v16 = 0;
LABEL_8:
  objc_sync_exit(v1);

  return v16;
}

void sub_100198C58(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_100198C78(void *a1)
{
  id v1;
  id v2;
  void *v3;
  void *v4;
  id v5;
  id v6;
  void *v7;
  id v8;
  void *v9;
  id v10;
  _QWORD v12[4];
  _QWORD v13[4];
  _QWORD v14[4];
  _QWORD v15[4];

  if (!a1)
    return 0;
  v1 = a1;
  objc_sync_enter(v1);
  if (*((_BYTE *)v1 + 137))
  {
    v2 = objc_alloc((Class)NSError);
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v14[0] = NSLocalizedDescriptionKey;
    v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Aborted"));
    v15[0] = v4;
    v15[1] = &off_100300B78;
    v14[1] = CFSTR("Line");
    v14[2] = CFSTR("Method");
    v5 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("enableHeadlessMiniNV"));
    v15[2] = v5;
    v14[3] = NSDebugDescriptionErrorKey;
    v6 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("enableHeadlessMiniNV"), 310);
    v15[3] = v6;
    v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v15, v14, 4));
    v8 = objc_msgSend(v2, "initWithDomain:code:userInfo:", v3, 3, v7);
LABEL_7:
    v9 = v8;

    goto LABEL_8;
  }
  if ((NFDriverEnableHeadlessModeMiniNV(*((_QWORD *)v1 + 5)) & 1) == 0)
  {
    v10 = objc_alloc((Class)NSError);
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v12[0] = NSLocalizedDescriptionKey;
    v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unknown Error"));
    v13[0] = v4;
    v13[1] = &off_100300B90;
    v12[1] = CFSTR("Line");
    v12[2] = CFSTR("Method");
    v5 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("enableHeadlessMiniNV"));
    v13[2] = v5;
    v12[3] = NSDebugDescriptionErrorKey;
    v6 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("enableHeadlessMiniNV"), 313);
    v13[3] = v6;
    v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v13, v12, 4));
    v8 = objc_msgSend(v10, "initWithDomain:code:userInfo:", v3, 6, v7);
    goto LABEL_7;
  }
  v9 = 0;
LABEL_8:
  objc_sync_exit(v1);

  return v9;
}

void sub_100198F7C(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t sub_100198F98(void *a1, _QWORD *a2)
{
  id v3;
  id v4;
  void *ErrorCode;
  void *v6;
  id v7;
  id v8;
  void *v9;
  uint64_t HeadlessModeFlags;
  id v11;
  unsigned int v13;
  _QWORD v14[2];
  _QWORD v15[2];
  _QWORD v16[4];
  _QWORD v17[4];

  if (!a1)
    return 0;
  v13 = 0;
  v3 = a1;
  objc_sync_enter(v3);
  if (*((_BYTE *)v3 + 137))
  {
    if (!a2)
    {
      HeadlessModeFlags = 0;
      goto LABEL_10;
    }
    v4 = objc_alloc((Class)NSError);
    ErrorCode = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v16[0] = NSLocalizedDescriptionKey;
    v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Aborted"));
    v17[0] = v6;
    v17[1] = &off_100300BA8;
    v16[1] = CFSTR("Line");
    v16[2] = CFSTR("Method");
    v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("getHeadlessFlags:"));
    v17[2] = v7;
    v16[3] = NSDebugDescriptionErrorKey;
    v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("getHeadlessFlags:"), 327);
    v17[3] = v8;
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v17, v16, 4));
    *a2 = objc_msgSend(v4, "initWithDomain:code:userInfo:", ErrorCode, 3, v9);

    HeadlessModeFlags = 0;
  }
  else
  {
    HeadlessModeFlags = NFDriverGetHeadlessModeFlags(*((_QWORD *)v3 + 5), &v13);
    if (!a2 || !v13)
      goto LABEL_10;
    ErrorCode = (void *)NFDriverCreateErrorCode(v13);
    v11 = objc_alloc((Class)NSError);
    v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v14[0] = NSLocalizedDescriptionKey;
    v7 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Stack Error"));
    v14[1] = NSUnderlyingErrorKey;
    v15[0] = v7;
    v15[1] = ErrorCode;
    v8 = (id)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v15, v14, 2));
    *a2 = objc_msgSend(v11, "initWithDomain:code:userInfo:", v6, 15, v8);
  }

LABEL_10:
  objc_sync_exit(v3);

  return HeadlessModeFlags;
}

void sub_100199250(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100199270(void *a1, uint64_t a2)
{
  id v3;
  uint64_t v4;

  if (!a1)
    return 0;
  v3 = a1;
  objc_sync_enter(v3);
  if (*((_BYTE *)v3 + 137))
    v4 = 0;
  else
    v4 = NFDriverEnableHeadlessTestMode(*((_QWORD *)v3 + 5), (_DWORD)a2 != 0, a2);
  objc_sync_exit(v3);

  return v4;
}

void sub_1001992DC(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1001992F0(void *a1)
{
  id obj;

  if (a1)
  {
    obj = a1;
    objc_sync_enter(obj);
    if (!*((_BYTE *)obj + 137))
      NFDriverDumpLPMDebugLog(*((_QWORD *)obj + 5));
    objc_sync_exit(obj);

  }
}

void sub_100199354(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
  objc_sync_exit(obj);
  _Unwind_Resume(a1);
}

NFPowerTrackingConsumer *sub_100199368(uint64_t a1, unint64_t a2)
{
  NFPowerTrackingConsumer *v3;

  objc_opt_self(a1);
  v3 = objc_opt_new(NFPowerTrackingConsumer);
  if (v3)
    v3->_hwType = a2;
  return v3;
}

id sub_10019939C(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  void *v6;
  void *v7;
  _QWORD v9[3];
  _QWORD v10[3];

  if (!a1)
    return 0;
  sub_100199470();
  v2 = (void *)objc_claimAutoreleasedReturnValue(v1);
  v9[0] = v2;
  v10[0] = &off_100300BC0;
  sub_100199568();
  v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  v9[1] = v4;
  v10[1] = &off_100300BC0;
  sub_100199660();
  v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
  v9[2] = v6;
  v10[2] = &off_100300BC0;
  v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v10, v9, 3));

  return v7;
}

void sub_100199470()
{
  id *v0;
  void *v1;
  id v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v0 = (id *)qword_10032AAD8;
  v8 = qword_10032AAD8;
  if (!qword_10032AAD8)
  {
    v1 = sub_10019EA18();
    v0 = (id *)dlsym(v1, "kCPMSPowerTimeScaleInstantaneous");
    v6[3] = (uint64_t)v0;
    qword_10032AAD8 = (uint64_t)v0;
  }
  _Block_object_dispose(&v5, 8);
  if (v0)
  {
    v2 = *v0;
  }
  else
  {
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
    v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "NSString *getkCPMSPowerTimeScaleInstantaneous(void)"));
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, CFSTR("NFCoreDuetWrapper.m"), 33, CFSTR("%s"), dlerror());

    __break(1u);
  }
}

void sub_100199550(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100199568()
{
  id *v0;
  void *v1;
  id v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v0 = (id *)qword_10032AAE0;
  v8 = qword_10032AAE0;
  if (!qword_10032AAE0)
  {
    v1 = sub_10019EA18();
    v0 = (id *)dlsym(v1, "kCPMSPowerTimeScale100ms");
    v6[3] = (uint64_t)v0;
    qword_10032AAE0 = (uint64_t)v0;
  }
  _Block_object_dispose(&v5, 8);
  if (v0)
  {
    v2 = *v0;
  }
  else
  {
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
    v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "NSString *getkCPMSPowerTimeScale100ms(void)"));
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, CFSTR("NFCoreDuetWrapper.m"), 34, CFSTR("%s"), dlerror());

    __break(1u);
  }
}

void sub_100199648(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100199660()
{
  id *v0;
  void *v1;
  id v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v0 = (id *)qword_10032AAE8;
  v8 = qword_10032AAE8;
  if (!qword_10032AAE8)
  {
    v1 = sub_10019EA18();
    v0 = (id *)dlsym(v1, "kCPMSPowerTimeScale1s");
    v6[3] = (uint64_t)v0;
    qword_10032AAE8 = (uint64_t)v0;
  }
  _Block_object_dispose(&v5, 8);
  if (v0)
  {
    v2 = *v0;
  }
  else
  {
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
    v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "NSString *getkCPMSPowerTimeScale1s(void)"));
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, CFSTR("NFCoreDuetWrapper.m"), 35, CFSTR("%s"), dlerror());

    __break(1u);
  }
}

void sub_100199740(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_100199758(_QWORD *a1)
{
  void *v2;
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  void *v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *specific;
  uint64_t Logger;
  void (*v20)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  objc_class *v27;
  int v28;
  const char *Name;
  uint8_t buf[4];
  int v31;
  __int16 v32;
  const char *v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  int v37;
  _QWORD v38[3];
  _QWORD v39[3];
  _QWORD v40[3];
  _QWORD v41[3];
  _QWORD v42[3];
  _QWORD v43[3];

  if (!a1)
    return 0;
  v2 = 0;
  switch(a1[1])
  {
    case 7:
    case 8:
      sub_100199470();
      v4 = objc_claimAutoreleasedReturnValue(v14);
      v42[0] = v4;
      v43[0] = &off_100300BD8;
      sub_100199568();
      v6 = (void *)objc_claimAutoreleasedReturnValue(v15);
      v42[1] = v6;
      v43[1] = &off_100300BF0;
      sub_100199660();
      v8 = (void *)objc_claimAutoreleasedReturnValue(v16);
      v42[2] = v8;
      v43[2] = &off_100300C08;
      v9 = v43;
      v10 = v42;
      goto LABEL_6;
    case 0xALL:
    case 0xBLL:
    case 0xCLL:
    case 0x14:
      sub_100199470();
      v4 = objc_claimAutoreleasedReturnValue(v3);
      v40[0] = v4;
      v41[0] = &off_100300BD8;
      sub_100199568();
      v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
      v40[1] = v6;
      v41[1] = &off_100300BF0;
      sub_100199660();
      v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
      v40[2] = v8;
      v41[2] = &off_100300C08;
      v9 = v41;
      v10 = v40;
      goto LABEL_6;
    case 0xELL:
    case 0xFLL:
    case 0x10:
    case 0x11:
      sub_100199470();
      v4 = objc_claimAutoreleasedReturnValue(v11);
      v38[0] = v4;
      v39[0] = &off_100300C20;
      sub_100199568();
      v6 = (void *)objc_claimAutoreleasedReturnValue(v12);
      v38[1] = v6;
      v39[1] = &off_100300C20;
      sub_100199660();
      v8 = (void *)objc_claimAutoreleasedReturnValue(v13);
      v38[2] = v8;
      v39[2] = &off_100300C20;
      v9 = v39;
      v10 = v38;
LABEL_6:
      v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v9, v10, 3));

      goto LABEL_7;
    case 0x12:
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v20 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(a1);
        Name = sel_getName("powerLevelReader");
        v24 = 45;
        if (isMetaClass)
          v24 = 43;
        v20(3, "%c[%{public}s %{public}s]:%i This hardware does not support reader", v24, ClassName, Name, 170);
      }
      v25 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v26 = NFSharedLogGetLogger(v25);
      v4 = objc_claimAutoreleasedReturnValue(v26);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        v27 = object_getClass(a1);
        if (class_isMetaClass(v27))
          v28 = 43;
        else
          v28 = 45;
        *(_DWORD *)buf = 67109890;
        v31 = v28;
        v32 = 2082;
        v33 = object_getClassName(a1);
        v34 = 2082;
        v35 = sel_getName("powerLevelReader");
        v36 = 1024;
        v37 = 170;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i This hardware does not support reader", buf, 0x22u);
      }
      v2 = 0;
LABEL_7:

      break;
    default:
      return v2;
  }
  return v2;
}

id sub_100199A60(_QWORD *a1)
{
  void *v2;
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  void *v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *specific;
  uint64_t Logger;
  void (*v20)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  objc_class *v27;
  int v28;
  const char *Name;
  _QWORD v30[3];
  _QWORD v31[3];
  uint8_t buf[4];
  int v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  const char *v37;
  __int16 v38;
  int v39;
  _QWORD v40[3];
  _QWORD v41[3];
  _QWORD v42[3];
  _QWORD v43[3];

  if (!a1)
    return 0;
  v2 = 0;
  switch(a1[1])
  {
    case 7:
    case 8:
      sub_100199470();
      v4 = objc_claimAutoreleasedReturnValue(v14);
      v42[0] = v4;
      v43[0] = &off_100300C38;
      sub_100199568();
      v6 = (void *)objc_claimAutoreleasedReturnValue(v15);
      v42[1] = v6;
      v43[1] = &off_100300C50;
      sub_100199660();
      v8 = (void *)objc_claimAutoreleasedReturnValue(v16);
      v42[2] = v8;
      v43[2] = &off_100300C68;
      v9 = v43;
      v10 = v42;
      goto LABEL_6;
    case 0xALL:
    case 0xBLL:
    case 0xCLL:
    case 0x14:
      sub_100199470();
      v4 = objc_claimAutoreleasedReturnValue(v3);
      v40[0] = v4;
      v41[0] = &off_100300C80;
      sub_100199568();
      v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
      v40[1] = v6;
      v41[1] = &off_100300C98;
      sub_100199660();
      v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
      v40[2] = v8;
      v41[2] = &off_100300CB0;
      v9 = v41;
      v10 = v40;
      goto LABEL_6;
    case 0xELL:
    case 0xFLL:
    case 0x10:
    case 0x11:
      sub_100199470();
      v4 = objc_claimAutoreleasedReturnValue(v11);
      v30[0] = v4;
      v31[0] = &off_100300CC8;
      sub_100199568();
      v6 = (void *)objc_claimAutoreleasedReturnValue(v12);
      v30[1] = v6;
      v31[1] = &off_100300CE0;
      sub_100199660();
      v8 = (void *)objc_claimAutoreleasedReturnValue(v13);
      v30[2] = v8;
      v31[2] = &off_100300CF8;
      v9 = v31;
      v10 = v30;
LABEL_6:
      v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v9, v10, 3));

      goto LABEL_7;
    case 0x12:
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v20 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(a1);
        Name = sel_getName("powerLevelSECardEmulation");
        v24 = 45;
        if (isMetaClass)
          v24 = 43;
        v20(3, "%c[%{public}s %{public}s]:%i This hardware does not support CE", v24, ClassName, Name, 205);
      }
      v25 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v26 = NFSharedLogGetLogger(v25);
      v4 = objc_claimAutoreleasedReturnValue(v26);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        v27 = object_getClass(a1);
        if (class_isMetaClass(v27))
          v28 = 43;
        else
          v28 = 45;
        *(_DWORD *)buf = 67109890;
        v33 = v28;
        v34 = 2082;
        v35 = object_getClassName(a1);
        v36 = 2082;
        v37 = sel_getName("powerLevelSECardEmulation");
        v38 = 1024;
        v39 = 205;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i This hardware does not support CE", buf, 0x22u);
      }
      v2 = 0;
LABEL_7:

      break;
    default:
      return v2;
  }
  return v2;
}

id sub_100199D78(_QWORD *a1)
{
  void *v2;
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  void *v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *specific;
  uint64_t Logger;
  void (*v20)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  objc_class *v27;
  int v28;
  const char *Name;
  _QWORD v30[3];
  _QWORD v31[3];
  uint8_t buf[4];
  int v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  const char *v37;
  __int16 v38;
  int v39;
  _QWORD v40[3];
  _QWORD v41[3];
  _QWORD v42[3];
  _QWORD v43[3];

  if (!a1)
    return 0;
  v2 = 0;
  switch(a1[1])
  {
    case 7:
    case 8:
      sub_100199470();
      v4 = objc_claimAutoreleasedReturnValue(v14);
      v42[0] = v4;
      v43[0] = &off_100300D10;
      sub_100199568();
      v6 = (void *)objc_claimAutoreleasedReturnValue(v15);
      v42[1] = v6;
      v43[1] = &off_100300D28;
      sub_100199660();
      v8 = (void *)objc_claimAutoreleasedReturnValue(v16);
      v42[2] = v8;
      v43[2] = &off_100300D40;
      v9 = v43;
      v10 = v42;
      goto LABEL_6;
    case 0xALL:
    case 0xBLL:
    case 0xCLL:
    case 0x14:
      sub_100199470();
      v4 = objc_claimAutoreleasedReturnValue(v3);
      v40[0] = v4;
      v41[0] = &off_100300D58;
      sub_100199568();
      v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
      v40[1] = v6;
      v41[1] = &off_100300D70;
      sub_100199660();
      v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
      v40[2] = v8;
      v41[2] = &off_100300D88;
      v9 = v41;
      v10 = v40;
      goto LABEL_6;
    case 0xELL:
    case 0xFLL:
    case 0x10:
    case 0x11:
      sub_100199470();
      v4 = objc_claimAutoreleasedReturnValue(v11);
      v30[0] = v4;
      v31[0] = &off_100300DA0;
      sub_100199568();
      v6 = (void *)objc_claimAutoreleasedReturnValue(v12);
      v30[1] = v6;
      v31[1] = &off_100300DB8;
      sub_100199660();
      v8 = (void *)objc_claimAutoreleasedReturnValue(v13);
      v30[2] = v8;
      v31[2] = &off_100300DD0;
      v9 = v31;
      v10 = v30;
LABEL_6:
      v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v9, v10, 3));

      goto LABEL_7;
    case 0x12:
      specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      Logger = NFLogGetLogger(specific);
      if (Logger)
      {
        v20 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(a1);
        Name = sel_getName("powerLevelCombined");
        v24 = 45;
        if (isMetaClass)
          v24 = 43;
        v20(3, "%c[%{public}s %{public}s]:%i This hardware does not support CE", v24, ClassName, Name, 254);
      }
      v25 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v26 = NFSharedLogGetLogger(v25);
      v4 = objc_claimAutoreleasedReturnValue(v26);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        v27 = object_getClass(a1);
        if (class_isMetaClass(v27))
          v28 = 43;
        else
          v28 = 45;
        *(_DWORD *)buf = 67109890;
        v33 = v28;
        v34 = 2082;
        v35 = object_getClassName(a1);
        v36 = 2082;
        v37 = sel_getName("powerLevelCombined");
        v38 = 1024;
        v39 = 254;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i This hardware does not support CE", buf, 0x22u);
      }
      v2 = 0;
LABEL_7:

      break;
    default:
      return v2;
  }
  return v2;
}

void sub_10019A090(id *a1, void *a2, void *a3)
{
  id v5;
  int v6;
  uint64_t v7;
  id obj;

  obj = a2;
  v5 = a3;
  if (a1)
  {
    objc_storeWeak(a1 + 8, obj);
    objc_storeStrong(a1 + 9, a3);
    if (obj)
    {
      v6 = objc_msgSend(a1[6], "intValue");
      if (v6 >= 1)
        v7 = v6 < 850;
      else
        v7 = 2;
      objc_msgSend(obj, "thermalStateChanged:", v7);
    }
  }

}

void sub_10019A120(uint64_t a1, void *a2)
{
  id *WeakRetained;
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  objc_class *v13;
  int v14;
  NSObject *v15;
  id v16;
  uint64_t v17;
  void *i;
  void *v19;
  void *v20;
  void (*v21)(uint64_t, const char *, ...);
  objc_class *v22;
  uint64_t v23;
  const char *v24;
  const char *v25;
  void *v26;
  uint64_t v27;
  NSObject *v28;
  objc_class *v29;
  int v30;
  const char *v31;
  const char *v32;
  const char *ClassName;
  const char *Name;
  id v35;
  id v36;
  id v37;
  id obj;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  uint8_t v43[4];
  int v44;
  __int16 v45;
  const char *v46;
  __int16 v47;
  const char *v48;
  __int16 v49;
  int v50;
  uint8_t buf[8];
  _BYTE v52[10];
  __int16 v53;
  const char *v54;
  __int16 v55;
  int v56;
  __int16 v57;
  id v58;

  if (a2)
  {
    v37 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(a2, "objectForKey:", CFSTR("com.apple.duet.ppm-bgt.stck")));
    if (v37)
    {
      WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
      v36 = v37;
      if (WeakRetained)
      {
        specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        Logger = NFLogGetLogger(specific);
        if (Logger)
        {
          v6 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(WeakRetained);
          isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(WeakRetained);
          Name = sel_getName("_handleUpdatedBudgetValue:");
          v9 = 45;
          if (isMetaClass)
            v9 = 43;
          v6(5, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 973, v36);
        }
        v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v11 = NFSharedLogGetLogger(v10);
        v12 = objc_claimAutoreleasedReturnValue(v11);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          v13 = object_getClass(WeakRetained);
          if (class_isMetaClass(v13))
            v14 = 43;
          else
            v14 = 45;
          *(_DWORD *)buf = 67110146;
          *(_DWORD *)&buf[4] = v14;
          *(_WORD *)v52 = 2082;
          *(_QWORD *)&v52[2] = object_getClassName(WeakRetained);
          v53 = 2082;
          v54 = sel_getName("_handleUpdatedBudgetValue:");
          v55 = 1024;
          v56 = 973;
          v57 = 2114;
          v58 = v36;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
        }

        if (!objc_msgSend(v36, "integerValue"))
        {
          v15 = _os_activity_create((void *)&_mh_execute_header, "coreduet revoked", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_IF_NONE_PRESENT);
          *(_QWORD *)buf = 0;
          *(_QWORD *)v52 = 0;
          os_activity_scope_enter(v15, (os_activity_scope_state_t)buf);
          os_activity_scope_leave((os_activity_scope_state_t)buf);

          v35 = WeakRetained[4];
          objc_sync_enter(v35);
          v41 = 0u;
          v42 = 0u;
          v39 = 0u;
          v40 = 0u;
          obj = WeakRetained[4];
          v16 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v39, buf, 16);
          if (v16)
          {
            v17 = *(_QWORD *)v40;
            do
            {
              for (i = 0; i != v16; i = (char *)i + 1)
              {
                if (*(_QWORD *)v40 != v17)
                  objc_enumerationMutation(obj);
                v19 = *(void **)(*((_QWORD *)&v39 + 1) + 8 * (_QWORD)i);
                v20 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                v21 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v20);
                if (v21)
                {
                  v22 = object_getClass(WeakRetained);
                  if (class_isMetaClass(v22))
                    v23 = 43;
                  else
                    v23 = 45;
                  v24 = object_getClassName(WeakRetained);
                  v25 = sel_getName("_handleUpdatedBudgetValue:");
                  v21(5, "%c[%{public}s %{public}s]:%i Revoking core duet activity", v23, v24, v25, 980);
                }
                v26 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                v27 = NFSharedLogGetLogger(v26);
                v28 = objc_claimAutoreleasedReturnValue(v27);
                if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
                {
                  v29 = object_getClass(WeakRetained);
                  if (class_isMetaClass(v29))
                    v30 = 43;
                  else
                    v30 = 45;
                  v31 = object_getClassName(WeakRetained);
                  v32 = sel_getName("_handleUpdatedBudgetValue:");
                  *(_DWORD *)v43 = 67109890;
                  v44 = v30;
                  v45 = 2082;
                  v46 = v31;
                  v47 = 2082;
                  v48 = v32;
                  v49 = 1024;
                  v50 = 980;
                  _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Revoking core duet activity", v43, 0x22u);
                }

                objc_msgSend(v19, "coreDuetActivityRevoked");
              }
              v16 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v39, buf, 16);
            }
            while (v16);
          }

          objc_sync_exit(v35);
        }
      }

    }
  }
}

void sub_10019A578(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id obj)
{
  objc_sync_exit(obj);
  _Unwind_Resume(a1);
}

id sub_10019A5A8(id result)
{
  __int128 v1;
  uint64_t v2;

  if (result)
  {
    if (!qword_10032ACB8)
    {
      v1 = off_1002EA5C8;
      v2 = 0;
      qword_10032ACB8 = _sl_dlopen(&v1, 0);
    }
    if (qword_10032ACB8)
      return objc_msgSend(sub_10019A644(), "isCPMSSupported");
    else
      return 0;
  }
  return result;
}

id sub_10019A644()
{
  void *v0;
  id v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2050000000;
  v0 = (void *)qword_10032ACC0;
  v7 = qword_10032ACC0;
  if (!qword_10032ACC0)
  {
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    v3[2] = sub_10019EB1C;
    v3[3] = &unk_1002E5E30;
    v3[4] = &v4;
    sub_10019EB1C((uint64_t)v3);
    v0 = (void *)v5[3];
  }
  v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_10019A6E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10019A984(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10019A9BC(uint64_t a1)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 64));
  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
  {
    v3 = objc_msgSend(*(id *)(v2 + 48), "intValue");
    if (v3 >= 1)
      v4 = v3 < 850;
    else
      v4 = 2;
  }
  else
  {
    v4 = 0;
  }
  objc_msgSend(WeakRetained, "thermalStateChanged:", v4);

}

id sub_10019AA28(uint64_t a1)
{
  _BYTE *WeakRetained;
  _BYTE *v2;
  int v3;
  _QWORD *v4;
  id v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  NSObject *v9;
  int v11;
  void *v12;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v2 = WeakRetained;
  if (WeakRetained)
  {
    v3 = WeakRetained[40];
    v4 = (_QWORD *)*((_QWORD *)WeakRetained + 3);
    if (v2[41])
    {
      if (v3)
        v5 = sub_100199D78(v4);
      else
        v5 = sub_100199A60(v4);
    }
    else if (v3)
    {
      v5 = sub_100199758(v4);
    }
    else
    {
      v5 = sub_10019939C((uint64_t)v4);
    }
    v6 = objc_claimAutoreleasedReturnValue(v5);
    v7 = (void *)v6;
    v8 = NFSharedSignpostLog(v6);
    v9 = objc_claimAutoreleasedReturnValue(v8);
    if (os_signpost_enabled(v9))
    {
      v11 = 138412290;
      v12 = v7;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CPMS_GET_CURRENT", "%@", (uint8_t *)&v11, 0xCu);
    }

  }
  else
  {
    v7 = 0;
  }

  return v7;
}

void sub_10019AB44(uint64_t a1, void *a2)
{
  id v3;
  id WeakRetained;
  id v5;
  uint64_t v6;
  NSObject *v7;
  void *specific;
  uint64_t Logger;
  void (*v10)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  NSObject *v16;
  objc_class *v17;
  int v18;
  const char *v19;
  const char *v20;
  uint64_t v21;
  id v22;
  void *v23;
  uint64_t v24;
  void (*v25)(uint64_t, const char *, ...);
  objc_class *v26;
  _BOOL4 v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  NSObject *v31;
  objc_class *v32;
  int v33;
  const char *v34;
  const char *v35;
  id v36;
  void *v37;
  uint64_t v38;
  void *v39;
  void *v40;
  uint64_t v41;
  void *v42;
  uint64_t v43;
  void (*v44)(uint64_t, const char *, ...);
  objc_class *v45;
  const char *v46;
  uint64_t v47;
  void *v48;
  uint64_t v49;
  NSObject *v50;
  objc_class *v51;
  int v52;
  const char *v53;
  uint64_t v54;
  id v55;
  uint64_t v56;
  NSObject *v57;
  id v58;
  uint64_t v59;
  void *v60;
  const char *ClassName;
  const char *v62;
  const char *Name;
  const char *v64;
  _BOOL4 v65;
  const char *v66;
  const char *v67;
  int v68;
  uint8_t buf[8];
  _BYTE v70[36];
  __int16 v71;
  id v72;

  v3 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v5 = objc_msgSend(v3, "mutableCopy");
  v6 = NFSharedSignpostLog(v5);
  v7 = objc_claimAutoreleasedReturnValue(v6);
  if (os_signpost_enabled(v7))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v7, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CPMS_SET_CALLBACK", "", buf, 2u);
  }

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v10 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(WeakRetained);
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(WeakRetained);
    Name = sel_getName(*(SEL *)(a1 + 48));
    v13 = 45;
    if (isMetaClass)
      v13 = 43;
    v10(6, "%c[%{public}s %{public}s]:%i Got power request : %@", v13, ClassName, Name, 541, v3);
  }
  v14 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v15 = NFSharedLogGetLogger(v14);
  v16 = objc_claimAutoreleasedReturnValue(v15);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    v17 = object_getClass(WeakRetained);
    if (class_isMetaClass(v17))
      v18 = 43;
    else
      v18 = 45;
    v19 = object_getClassName(WeakRetained);
    v20 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)buf = 67110146;
    *(_DWORD *)&buf[4] = v18;
    *(_WORD *)v70 = 2082;
    *(_QWORD *)&v70[2] = v19;
    *(_WORD *)&v70[10] = 2082;
    *(_QWORD *)&v70[12] = v20;
    *(_WORD *)&v70[20] = 1024;
    *(_DWORD *)&v70[22] = 541;
    *(_WORD *)&v70[26] = 2112;
    *(_QWORD *)&v70[28] = v3;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Got power request : %@", buf, 0x2Cu);
  }

  if (NFThermalMonitorProvidedBySMC(v21)
    && *(_QWORD *)(a1 + 32) == *((_QWORD *)WeakRetained + 2)
    && (sub_10019B110(),
        v39 = (void *)objc_claimAutoreleasedReturnValue(v38),
        v40 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "valueForKey:", v39)),
        v39,
        v40))
  {
    v41 = objc_opt_class(NSNumber);
    if ((objc_opt_isKindOfClass(v40, v41) & 1) != 0)
    {
      v22 = v40;
      if ((objc_msgSend(*((id *)WeakRetained + 6), "isEqualToNumber:", v22) & 1) == 0)
      {
        v42 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v43 = NFLogGetLogger(v42);
        if (v43)
        {
          v44 = (void (*)(uint64_t, const char *, ...))v43;
          v45 = object_getClass(WeakRetained);
          v65 = class_isMetaClass(v45);
          v67 = object_getClassName(WeakRetained);
          v46 = sel_getName("processNewThermalBudget:");
          v47 = 45;
          if (v65)
            v47 = 43;
          v44(6, "%c[%{public}s %{public}s]:%i New thermal budget: %{public}@ -> %{public}@", v47, v67, v46, 475, *((_QWORD *)WeakRetained + 6), v22);
        }
        v48 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v49 = NFSharedLogGetLogger(v48);
        v50 = objc_claimAutoreleasedReturnValue(v49);
        if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
        {
          v51 = object_getClass(WeakRetained);
          if (class_isMetaClass(v51))
            v52 = 43;
          else
            v52 = 45;
          v68 = v52;
          v66 = object_getClassName(WeakRetained);
          v53 = sel_getName("processNewThermalBudget:");
          v54 = *((_QWORD *)WeakRetained + 6);
          *(_DWORD *)buf = 67110402;
          *(_DWORD *)&buf[4] = v68;
          *(_WORD *)v70 = 2082;
          *(_QWORD *)&v70[2] = v66;
          *(_WORD *)&v70[10] = 2082;
          *(_QWORD *)&v70[12] = v53;
          *(_WORD *)&v70[20] = 1024;
          *(_DWORD *)&v70[22] = 475;
          *(_WORD *)&v70[26] = 2114;
          *(_QWORD *)&v70[28] = v54;
          v71 = 2114;
          v72 = v22;
          _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i New thermal budget: %{public}@ -> %{public}@", buf, 0x36u);
        }

        objc_storeStrong((id *)WeakRetained + 6, v40);
        v55 = objc_loadWeakRetained((id *)WeakRetained + 8);
        if (v55)
        {
          v56 = *((_QWORD *)WeakRetained + 9);

          if (v56)
          {
            v57 = *((_QWORD *)WeakRetained + 9);
            *(_QWORD *)buf = _NSConcreteStackBlock;
            *(_QWORD *)v70 = 3221225472;
            *(_QWORD *)&v70[8] = sub_10019A9BC;
            *(_QWORD *)&v70[16] = &unk_1002E5C58;
            *(_QWORD *)&v70[24] = WeakRetained;
            dispatch_async(v57, buf);
          }
        }
      }
      v58 = *((id *)WeakRetained + 6);

      if (v58)
      {
        sub_10019B110();
        v60 = (void *)objc_claimAutoreleasedReturnValue(v59);
        objc_msgSend(v5, "setValue:forKey:", v58, v60);

      }
    }
    else
    {
      v22 = v40;
    }
  }
  else
  {
    v22 = 0;
  }
  v23 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v24 = NFLogGetLogger(v23);
  if (v24)
  {
    v25 = (void (*)(uint64_t, const char *, ...))v24;
    v26 = object_getClass(WeakRetained);
    v27 = class_isMetaClass(v26);
    v62 = object_getClassName(WeakRetained);
    v64 = sel_getName(*(SEL *)(a1 + 48));
    v28 = 45;
    if (v27)
      v28 = 43;
    v25(6, "%c[%{public}s %{public}s]:%i Got power request : %@", v28, v62, v64, 553, v5);
  }
  v29 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v30 = NFSharedLogGetLogger(v29);
  v31 = objc_claimAutoreleasedReturnValue(v30);
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    v32 = object_getClass(WeakRetained);
    if (class_isMetaClass(v32))
      v33 = 43;
    else
      v33 = 45;
    v34 = object_getClassName(WeakRetained);
    v35 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)buf = 67110146;
    *(_DWORD *)&buf[4] = v33;
    *(_WORD *)v70 = 2082;
    *(_QWORD *)&v70[2] = v34;
    *(_WORD *)&v70[10] = 2082;
    *(_QWORD *)&v70[12] = v35;
    *(_WORD *)&v70[20] = 1024;
    *(_DWORD *)&v70[22] = 553;
    *(_WORD *)&v70[26] = 2112;
    *(_QWORD *)&v70[28] = v5;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Got power request : %@", buf, 0x2Cu);
  }

  v36 = objc_msgSend(sub_10019A644(), "sharedCPMSAgent");
  v37 = (void *)objc_claimAutoreleasedReturnValue(v36);
  objc_msgSend(v37, "acknowledgePowerBudget:forClientId:error:", v5, *(_QWORD *)(a1 + 56), 0);

}

void sub_10019B110()
{
  id *v0;
  void *v1;
  id v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v0 = (id *)qword_10032AAF8;
  v8 = qword_10032AAF8;
  if (!qword_10032AAF8)
  {
    v1 = sub_10019EA18();
    v0 = (id *)dlsym(v1, "kCPMSPowerTimeScaleThermal");
    v6[3] = (uint64_t)v0;
    qword_10032AAF8 = (uint64_t)v0;
  }
  _Block_object_dispose(&v5, 8);
  if (v0)
  {
    v2 = *v0;
  }
  else
  {
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
    v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "NSString *getkCPMSPowerTimeScaleThermal(void)"));
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, CFSTR("NFCoreDuetWrapper.m"), 36, CFSTR("%s"), dlerror());

    __break(1u);
  }
}

void sub_10019B1F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10019B208(uint64_t val)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  void *specific;
  void (*Logger)(uint64_t, const char *, ...);
  objc_class *Class;
  uint64_t v7;
  const char *ClassName;
  const char *Name;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  objc_class *v13;
  int v14;
  const char *v15;
  const char *v16;
  void *v17;
  void *v18;
  objc_class *v19;
  id v20;
  void *v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void (*v32)(uint64_t, const char *, ...);
  objc_class *v33;
  uint64_t v34;
  const char *v35;
  const char *v36;
  void *v37;
  uint64_t v38;
  NSObject *v39;
  objc_class *v40;
  int v41;
  const char *v42;
  const char *v43;
  id v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  id v54;
  id v55;
  void *v56;
  unsigned __int8 v57;
  id v58;
  void *v59;
  id v60;
  void *v61;
  id v62;
  NSObject *v63;
  void *v64;
  uint64_t v65;
  void *v66;
  void (*v67)(uint64_t, const char *, ...);
  objc_class *v68;
  uint64_t v69;
  const char *v70;
  const char *v71;
  void *v72;
  uint64_t v73;
  NSObject *v74;
  objc_class *v75;
  int v76;
  const char *v77;
  const char *v78;
  NSObject *v79;
  const char *v80;
  NSObject *v81;
  os_log_type_t v82;
  void *v83;
  void (*v84)(uint64_t, const char *, ...);
  objc_class *v85;
  uint64_t v86;
  const char *v87;
  const char *v88;
  void *v89;
  uint64_t v90;
  NSObject *v91;
  objc_class *v92;
  int v93;
  const char *v94;
  const char *v95;
  void (*v96)(uint64_t, const char *, ...);
  objc_class *v97;
  uint64_t v98;
  const char *v99;
  const char *v100;
  void *v101;
  uint64_t v102;
  objc_class *v103;
  int v104;
  const char *v105;
  const char *v106;
  id v107;
  void *v108;
  id v109;
  void *v110;
  id v111;
  void *v112;
  void (*v113)(uint64_t, const char *, ...);
  objc_class *v114;
  uint64_t v115;
  const char *v116;
  const char *v117;
  void *v118;
  uint64_t v119;
  NSObject *v120;
  objc_class *v121;
  int v122;
  const char *v123;
  const char *v124;
  void *v125;
  void *v126;
  uint64_t v127;
  void (*v128)(uint64_t, const char *, ...);
  objc_class *v129;
  _BOOL4 isMetaClass;
  const char *v131;
  uint64_t v132;
  void *v133;
  uint64_t v134;
  NSObject *v135;
  objc_class *v136;
  int v137;
  const char *v138;
  const char *v139;
  const char *v140;
  NSObject *v141;
  NSObject *v142;
  id v143;
  _QWORD v144[4];
  id v145;
  id location;
  uint8_t v147[8];
  _BYTE v148[26];
  __int16 v149;
  NSObject *v150;
  uint8_t buf[8];
  _BYTE v152[36];
  __int16 v153;
  _BYTE v154[10];
  uint64_t v155;

  if (!val)
    return val;
  v1 = (_QWORD *)val;
  v2 = *(_QWORD *)(val + 24);
  if (v2)
  {
    if ((*(_BYTE *)(v2 + 16) & 1) != 0)
      v3 = 3;
    else
      v3 = 9;
  }
  else
  {
    v3 = 9;
  }
  objc_initWeak(&location, (id)val);
  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(specific);
  if (Logger)
  {
    Class = object_getClass(v1);
    if (class_isMetaClass(Class))
      v7 = 43;
    else
      v7 = 45;
    ClassName = object_getClassName(v1);
    Name = sel_getName("createCPMSDescription:");
    Logger(6, "%c[%{public}s %{public}s]:%i Using CPMS for client ID 0x%lx (%@)", v7, ClassName, Name, 496, v3, v1);
  }
  v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v11 = NFSharedLogGetLogger(v10);
  v12 = objc_claimAutoreleasedReturnValue(v11);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    v13 = object_getClass(v1);
    if (class_isMetaClass(v13))
      v14 = 43;
    else
      v14 = 45;
    v15 = object_getClassName(v1);
    v16 = sel_getName("createCPMSDescription:");
    *(_DWORD *)buf = 67110402;
    *(_DWORD *)&buf[4] = v14;
    *(_WORD *)v152 = 2082;
    *(_QWORD *)&v152[2] = v15;
    *(_WORD *)&v152[10] = 2082;
    *(_QWORD *)&v152[12] = v16;
    *(_WORD *)&v152[20] = 1024;
    *(_DWORD *)&v152[22] = 496;
    *(_WORD *)&v152[26] = 2048;
    *(_QWORD *)&v152[28] = v3;
    v153 = 2112;
    *(_QWORD *)v154 = v1;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Using CPMS for client ID 0x%lx (%@)", buf, 0x36u);
  }

  v17 = (void *)v1[6];
  v1[6] = &off_100300E60;

  *(_QWORD *)v147 = 0;
  *(_QWORD *)v148 = v147;
  *(_QWORD *)&v148[8] = 0x2050000000;
  v18 = (void *)qword_10032AAF0;
  *(_QWORD *)&v148[16] = qword_10032AAF0;
  if (!qword_10032AAF0)
  {
    *(_QWORD *)buf = _NSConcreteStackBlock;
    *(_QWORD *)v152 = 3221225472;
    *(_QWORD *)&v152[8] = sub_10019EBE0;
    *(_QWORD *)&v152[16] = &unk_1002E5E30;
    *(_QWORD *)&v152[24] = v147;
    sub_10019EBE0((uint64_t)buf);
    v18 = *(void **)(*(_QWORD *)v148 + 24);
  }
  v19 = objc_retainAutorelease(v18);
  _Block_object_dispose(v147, 8);
  v20 = objc_alloc_init(v19);
  v21 = v20;
  if (!v20)
  {
    v31 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v32 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v31);
    if (v32)
    {
      v33 = object_getClass(v1);
      if (class_isMetaClass(v33))
        v34 = 43;
      else
        v34 = 45;
      v35 = object_getClassName(v1);
      v36 = sel_getName("createCPMSDescription:");
      v32(3, "%c[%{public}s %{public}s]:%i Failed to create description", v34, v35, v36, 503);
    }
    v37 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v38 = NFSharedLogGetLogger(v37);
    v39 = objc_claimAutoreleasedReturnValue(v38);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
    {
      v40 = object_getClass(v1);
      if (class_isMetaClass(v40))
        v41 = 43;
      else
        v41 = 45;
      v42 = object_getClassName(v1);
      v43 = sel_getName("createCPMSDescription:");
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)&buf[4] = v41;
      *(_WORD *)v152 = 2082;
      *(_QWORD *)&v152[2] = v42;
      *(_WORD *)&v152[10] = 2082;
      *(_QWORD *)&v152[12] = v43;
      *(_WORD *)&v152[20] = 1024;
      *(_DWORD *)&v152[22] = 503;
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to create description", buf, 0x22u);
    }
    v44 = 0;
    goto LABEL_85;
  }
  objc_msgSend(v20, "setClientId:", v3);
  objc_msgSend(v21, "setIsContinuous:", 0);
  objc_msgSend(v21, "setPowerBudgetUpdateMinimumPeriod:", 1000);
  v22 = v1[3];
  if (v22)
  {
    v23 = 0;
    switch(*(_QWORD *)(v22 + 8))
    {
      case 7:
      case 8:
        sub_100199470();
        v25 = (void *)objc_claimAutoreleasedReturnValue(v48);
        *(_QWORD *)v147 = v25;
        *(_QWORD *)buf = &off_100305E78;
        sub_100199568();
        v27 = (void *)objc_claimAutoreleasedReturnValue(v49);
        *(_QWORD *)v148 = v27;
        *(_QWORD *)v152 = &off_100305E90;
        sub_100199660();
        v29 = (void *)objc_claimAutoreleasedReturnValue(v50);
        *(_QWORD *)&v148[8] = v29;
        *(_QWORD *)&v152[8] = &off_100305EA8;
        v30 = objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, v147, 3));
        goto LABEL_36;
      case 0xALL:
      case 0xBLL:
      case 0xCLL:
      case 0x14:
        sub_100199470();
        v25 = (void *)objc_claimAutoreleasedReturnValue(v24);
        *(_QWORD *)v147 = v25;
        *(_QWORD *)buf = &off_100305EC0;
        sub_100199568();
        v27 = (void *)objc_claimAutoreleasedReturnValue(v26);
        *(_QWORD *)v148 = v27;
        *(_QWORD *)v152 = &off_100305ED8;
        sub_100199660();
        v29 = (void *)objc_claimAutoreleasedReturnValue(v28);
        *(_QWORD *)&v148[8] = v29;
        *(_QWORD *)&v152[8] = &off_100305EF0;
        v30 = objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, v147, 3));
        goto LABEL_36;
      case 0xELL:
      case 0xFLL:
      case 0x10:
      case 0x11:
        sub_100199470();
        v25 = (void *)objc_claimAutoreleasedReturnValue(v45);
        *(_QWORD *)v147 = v25;
        *(_QWORD *)buf = &off_100305F08;
        sub_100199568();
        v27 = (void *)objc_claimAutoreleasedReturnValue(v46);
        *(_QWORD *)v148 = v27;
        *(_QWORD *)v152 = &off_100305F20;
        sub_100199660();
        v29 = (void *)objc_claimAutoreleasedReturnValue(v47);
        *(_QWORD *)&v148[8] = v29;
        *(_QWORD *)&v152[8] = &off_100305F38;
        v30 = objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, v147, 3));
        goto LABEL_36;
      case 0x12:
        sub_100199470();
        v25 = (void *)objc_claimAutoreleasedReturnValue(v51);
        *(_QWORD *)v147 = v25;
        *(_QWORD *)buf = &off_100305F50;
        sub_100199568();
        v27 = (void *)objc_claimAutoreleasedReturnValue(v52);
        *(_QWORD *)v148 = v27;
        *(_QWORD *)v152 = &off_100305F68;
        sub_100199660();
        v29 = (void *)objc_claimAutoreleasedReturnValue(v53);
        *(_QWORD *)&v148[8] = v29;
        *(_QWORD *)&v152[8] = &off_100305F80;
        v30 = objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, v147, 3));
LABEL_36:
        v23 = (void *)v30;

        break;
      default:
        break;
    }
  }
  else
  {
    v23 = 0;
  }
  objc_msgSend(v21, "setPowerLevels:", v23);

  v144[0] = _NSConcreteStackBlock;
  v144[1] = 3221225472;
  v144[2] = sub_10019AA28;
  v144[3] = &unk_1002EA538;
  objc_copyWeak(&v145, &location);
  objc_msgSend(v21, "setGetCurrentPower:", v144);
  *(_QWORD *)buf = _NSConcreteStackBlock;
  *(_QWORD *)v152 = 3221225472;
  *(_QWORD *)&v152[8] = sub_10019AB44;
  *(_QWORD *)&v152[16] = &unk_1002EA560;
  objc_copyWeak((id *)&v152[32], &location);
  *(_QWORD *)&v154[2] = "createCPMSDescription:";
  v54 = v21;
  *(_QWORD *)&v152[24] = v54;
  v155 = v3;
  objc_msgSend(v54, "setNotificationCallback:", buf);
  v55 = objc_msgSend(sub_10019A644(), "sharedCPMSAgent");
  v56 = (void *)objc_claimAutoreleasedReturnValue(v55);
  v143 = 0;
  v57 = objc_msgSend(v56, "registerClientWithDescription:error:", v54, &v143);
  v39 = v143;

  if ((v57 & 1) == 0)
  {
    v83 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v84 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v83);
    if (v84)
    {
      v85 = object_getClass(v1);
      if (class_isMetaClass(v85))
        v86 = 43;
      else
        v86 = 45;
      v87 = object_getClassName(v1);
      v88 = sel_getName("createCPMSDescription:");
      v84(3, "%c[%{public}s %{public}s]:%i Failed to register CPMS : %{public}@", v86, v87, v88, 559, v39);
    }
    v89 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v90 = NFSharedLogGetLogger(v89);
    v91 = objc_claimAutoreleasedReturnValue(v90);
    if (os_log_type_enabled(v91, OS_LOG_TYPE_ERROR))
    {
      v92 = object_getClass(v1);
      if (class_isMetaClass(v92))
        v93 = 43;
      else
        v93 = 45;
      v94 = object_getClassName(v1);
      v95 = sel_getName("createCPMSDescription:");
      *(_DWORD *)v147 = 67110146;
      *(_DWORD *)&v147[4] = v93;
      *(_WORD *)v148 = 2082;
      *(_QWORD *)&v148[2] = v94;
      *(_WORD *)&v148[10] = 2082;
      *(_QWORD *)&v148[12] = v95;
      *(_WORD *)&v148[20] = 1024;
      *(_DWORD *)&v148[22] = 559;
      v149 = 2114;
      v150 = v39;
      _os_log_impl((void *)&_mh_execute_header, v91, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to register CPMS : %{public}@", v147, 0x2Cu);
    }

    v44 = 0;
    goto LABEL_84;
  }
  v58 = objc_msgSend(sub_10019A644(), "sharedCPMSAgent");
  v59 = (void *)objc_claimAutoreleasedReturnValue(v58);
  v60 = sub_100199D78((_QWORD *)v1[3]);
  v61 = (void *)objc_claimAutoreleasedReturnValue(v60);
  v142 = v39;
  v62 = objc_msgSend(v59, "copyPowerBudgetForRequest:forClient:error:", v61, v3, &v142);
  v63 = v142;

  v64 = (void *)v1[7];
  v1[7] = v62;

  v65 = v1[7];
  v66 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  if (v65)
  {
    v67 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v66);
    if (v67)
    {
      v68 = object_getClass(v1);
      if (class_isMetaClass(v68))
        v69 = 43;
      else
        v69 = 45;
      v70 = object_getClassName(v1);
      v71 = sel_getName("createCPMSDescription:");
      v67(6, "%c[%{public}s %{public}s]:%i Max Power budget is %{public}@", v69, v70, v71, 568, v1[7]);
    }
    v72 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v73 = NFSharedLogGetLogger(v72);
    v74 = objc_claimAutoreleasedReturnValue(v73);
    if (!os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
      goto LABEL_71;
    v75 = object_getClass(v1);
    if (class_isMetaClass(v75))
      v76 = 43;
    else
      v76 = 45;
    v77 = object_getClassName(v1);
    v78 = sel_getName("createCPMSDescription:");
    v79 = v1[7];
    *(_DWORD *)v147 = 67110146;
    *(_DWORD *)&v147[4] = v76;
    *(_WORD *)v148 = 2082;
    *(_QWORD *)&v148[2] = v77;
    *(_WORD *)&v148[10] = 2082;
    *(_QWORD *)&v148[12] = v78;
    *(_WORD *)&v148[20] = 1024;
    *(_DWORD *)&v148[22] = 568;
    v149 = 2114;
    v150 = v79;
    v80 = "%c[%{public}s %{public}s]:%i Max Power budget is %{public}@";
    v81 = v74;
    v82 = OS_LOG_TYPE_DEFAULT;
  }
  else
  {
    v96 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v66);
    if (v96)
    {
      v97 = object_getClass(v1);
      if (class_isMetaClass(v97))
        v98 = 43;
      else
        v98 = 45;
      v99 = object_getClassName(v1);
      v100 = sel_getName("createCPMSDescription:");
      v96(3, "%c[%{public}s %{public}s]:%i Error query power budget CPMS : %{public}@", v98, v99, v100, 566, v63);
    }
    v101 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v102 = NFSharedLogGetLogger(v101);
    v74 = objc_claimAutoreleasedReturnValue(v102);
    if (!os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
      goto LABEL_71;
    v103 = object_getClass(v1);
    if (class_isMetaClass(v103))
      v104 = 43;
    else
      v104 = 45;
    v105 = object_getClassName(v1);
    v106 = sel_getName("createCPMSDescription:");
    *(_DWORD *)v147 = 67110146;
    *(_DWORD *)&v147[4] = v104;
    *(_WORD *)v148 = 2082;
    *(_QWORD *)&v148[2] = v105;
    *(_WORD *)&v148[10] = 2082;
    *(_QWORD *)&v148[12] = v106;
    *(_WORD *)&v148[20] = 1024;
    *(_DWORD *)&v148[22] = 566;
    v149 = 2114;
    v150 = v63;
    v80 = "%c[%{public}s %{public}s]:%i Error query power budget CPMS : %{public}@";
    v81 = v74;
    v82 = OS_LOG_TYPE_ERROR;
  }
  _os_log_impl((void *)&_mh_execute_header, v81, v82, v80, v147, 0x2Cu);
LABEL_71:

  v107 = objc_msgSend(sub_10019A644(), "sharedCPMSAgent");
  v108 = (void *)objc_claimAutoreleasedReturnValue(v107);
  v109 = sub_10019939C(v1[3]);
  v110 = (void *)objc_claimAutoreleasedReturnValue(v109);
  v141 = v63;
  v111 = objc_msgSend(v108, "copyPowerBudgetForRequest:forClient:error:", v110, v3, &v141);
  v39 = v141;

  if (!v111)
  {
    v112 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v113 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v112);
    if (v113)
    {
      v114 = object_getClass(v1);
      if (class_isMetaClass(v114))
        v115 = 43;
      else
        v115 = 45;
      v116 = object_getClassName(v1);
      v117 = sel_getName("createCPMSDescription:");
      v113(3, "%c[%{public}s %{public}s]:%i Error resetting power budget CPMS : %{public}@", v115, v116, v117, 573, v39);
    }
    v118 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v119 = NFSharedLogGetLogger(v118);
    v120 = objc_claimAutoreleasedReturnValue(v119);
    if (os_log_type_enabled(v120, OS_LOG_TYPE_ERROR))
    {
      v121 = object_getClass(v1);
      if (class_isMetaClass(v121))
        v122 = 43;
      else
        v122 = 45;
      v123 = object_getClassName(v1);
      v124 = sel_getName("createCPMSDescription:");
      *(_DWORD *)v147 = 67110146;
      *(_DWORD *)&v147[4] = v122;
      *(_WORD *)v148 = 2082;
      *(_QWORD *)&v148[2] = v123;
      *(_WORD *)&v148[10] = 2082;
      *(_QWORD *)&v148[12] = v124;
      *(_WORD *)&v148[20] = 1024;
      *(_DWORD *)&v148[22] = 573;
      v149 = 2114;
      v150 = v39;
      _os_log_impl((void *)&_mh_execute_header, v120, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error resetting power budget CPMS : %{public}@", v147, 0x2Cu);
    }

  }
  v44 = v54;
LABEL_84:

  objc_destroyWeak((id *)&v152[32]);
  objc_destroyWeak(&v145);
LABEL_85:

  objc_destroyWeak(&location);
  v125 = (void *)v1[2];
  v1[2] = v44;

  if (v1[2])
    return 1;
  v126 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v127 = NFLogGetLogger(v126);
  if (v127)
  {
    v128 = (void (*)(uint64_t, const char *, ...))v127;
    v129 = object_getClass(v1);
    isMetaClass = class_isMetaClass(v129);
    v131 = object_getClassName(v1);
    v140 = sel_getName("setupCPMS");
    v132 = 45;
    if (isMetaClass)
      v132 = 43;
    v128(3, "%c[%{public}s %{public}s]:%i Failed to create description", v132, v131, v140, 585);
  }
  v133 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v134 = NFSharedLogGetLogger(v133);
  v135 = objc_claimAutoreleasedReturnValue(v134);
  if (os_log_type_enabled(v135, OS_LOG_TYPE_ERROR))
  {
    v136 = object_getClass(v1);
    if (class_isMetaClass(v136))
      v137 = 43;
    else
      v137 = 45;
    v138 = object_getClassName(v1);
    v139 = sel_getName("setupCPMS");
    *(_DWORD *)buf = 67109890;
    *(_DWORD *)&buf[4] = v137;
    *(_WORD *)v152 = 2082;
    *(_QWORD *)&v152[2] = v138;
    *(_WORD *)&v152[10] = 2082;
    *(_QWORD *)&v152[12] = v139;
    *(_WORD *)&v152[20] = 1024;
    *(_DWORD *)&v152[22] = 585;
    _os_log_impl((void *)&_mh_execute_header, v135, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to create description", buf, 0x22u);
  }

  return 0;
}

void sub_10019BFCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id *a16, id *location, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,id a26,char a27)
{
  objc_destroyWeak(location);
  objc_destroyWeak(a16);
  objc_destroyWeak(&a26);
  _Unwind_Resume(a1);
}

void sub_10019C070(uint64_t a1, void *a2)
{
  id v4;

  v4 = a2;
  if (a1)
  {
    objc_storeStrong((id *)(a1 + 24), a2);
    if (!*(_QWORD *)(a1 + 16))
    {
      if (sub_10019A5A8((id)a1))
        sub_10019B208(a1);
    }
  }

}

id sub_10019C0D0(uint64_t a1)
{
  _QWORD v2[6];

  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  v2[2] = sub_10019C150;
  v2[3] = &unk_1002EA580;
  v2[4] = objc_opt_self(a1);
  v2[5] = "stockholmSystemPowerConsumptionMonitor";
  if (qword_10032AB08 != -1)
    dispatch_once(&qword_10032AB08, v2);
  return (id)qword_10032AB00;
}

void sub_10019C150(uint64_t a1)
{
  NFSystemPowerConsumptionMonitor *v2;
  void *v3;
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  objc_class *v15;
  int v16;
  const char *v17;
  const char *v18;
  uint8_t buf[4];
  int v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  uint64_t v28;

  v2 = objc_alloc_init(NFSystemPowerConsumptionMonitor);
  v3 = (void *)qword_10032AB00;
  qword_10032AB00 = (uint64_t)v2;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v6 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 40));
    v11 = 45;
    if (isMetaClass)
      v11 = 43;
    v6(6, "%c[%{public}s %{public}s]:%i Stockholm CPMS : %@", v11, ClassName, Name, 615, qword_10032AB00);
  }
  v12 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v13 = NFSharedLogGetLogger(v12);
  v14 = objc_claimAutoreleasedReturnValue(v13);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    v15 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v15))
      v16 = 43;
    else
      v16 = 45;
    v17 = object_getClassName(*(id *)(a1 + 32));
    v18 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)buf = 67110146;
    v20 = v16;
    v21 = 2082;
    v22 = v17;
    v23 = 2082;
    v24 = v18;
    v25 = 1024;
    v26 = 615;
    v27 = 2112;
    v28 = qword_10032AB00;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Stockholm CPMS : %@", buf, 0x2Cu);
  }

}

id sub_10019C2FC(uint64_t a1)
{
  _QWORD v2[6];

  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  v2[2] = sub_10019C37C;
  v2[3] = &unk_1002EA580;
  v2[4] = objc_opt_self(a1);
  v2[5] = "furySystemPowerConsumptionMonitor";
  if (qword_10032AB18 != -1)
    dispatch_once(&qword_10032AB18, v2);
  return (id)qword_10032AB10;
}

void sub_10019C37C(uint64_t a1)
{
  NFSystemPowerConsumptionMonitor *v2;
  void *v3;
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  objc_class *v15;
  int v16;
  const char *v17;
  const char *v18;
  uint8_t buf[4];
  int v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  uint64_t v28;

  v2 = objc_alloc_init(NFSystemPowerConsumptionMonitor);
  v3 = (void *)qword_10032AB10;
  qword_10032AB10 = (uint64_t)v2;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v6 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 40));
    v11 = 45;
    if (isMetaClass)
      v11 = 43;
    v6(6, "%c[%{public}s %{public}s]:%i Fury CPMS : %@", v11, ClassName, Name, 627, qword_10032AB10);
  }
  v12 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v13 = NFSharedLogGetLogger(v12);
  v14 = objc_claimAutoreleasedReturnValue(v13);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    v15 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v15))
      v16 = 43;
    else
      v16 = 45;
    v17 = object_getClassName(*(id *)(a1 + 32));
    v18 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)buf = 67110146;
    v20 = v16;
    v21 = 2082;
    v22 = v17;
    v23 = 2082;
    v24 = v18;
    v25 = 1024;
    v26 = 627;
    v27 = 2112;
    v28 = qword_10032AB10;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Fury CPMS : %@", buf, 0x2Cu);
  }

}

uint64_t sub_10019C528(_QWORD *a1)
{
  void *v2;
  uint64_t v3;
  id v4;
  void *specific;
  uint64_t Logger;
  void (*v7)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  const char *ClassName;
  const char *Name;
  id v21;
  uint8_t buf[4];
  int v23;
  __int16 v24;
  const char *v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  id v31;

  if (!a1)
    return 0;
  v2 = (void *)a1[1];
  if (!v2)
    return 0;
  v21 = 0;
  LODWORD(v3) = objc_msgSend(v2, "activityStoppedWithLevel:options:error:", &off_100300E78, 0, &v21);
  v4 = v21;
  if (v4)
    v3 = 0;
  else
    v3 = v3;
  if ((v3 & 1) == 0)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v7 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("didEndPaymentActivityForCoreDuet");
      v10 = 45;
      if (isMetaClass)
        v10 = 43;
      v7(3, "%c[%{public}s %{public}s]:%i Error stopping PPM activity: %{public}@", v10, ClassName, Name, 648, v4);
    }
    v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v12 = NFSharedLogGetLogger(v11);
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v14 = object_getClass(a1);
      if (class_isMetaClass(v14))
        v15 = 43;
      else
        v15 = 45;
      v16 = object_getClassName(a1);
      v17 = sel_getName("didEndPaymentActivityForCoreDuet");
      *(_DWORD *)buf = 67110146;
      v23 = v15;
      v24 = 2082;
      v25 = v16;
      v26 = 2082;
      v27 = v17;
      v28 = 1024;
      v29 = 648;
      v30 = 2114;
      v31 = v4;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error stopping PPM activity: %{public}@", buf, 0x2Cu);
    }

  }
  return v3;
}

BOOL sub_10019C710(uint64_t a1)
{
  _QWORD *v2;
  id v3;
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  _BOOL8 v16;
  void *v17;
  uint64_t v18;
  NSObject *v19;
  id v20;
  void *v21;
  id v22;
  id v23;
  void *v24;
  void *v25;
  uint64_t v26;
  void (*v27)(uint64_t, const char *, ...);
  objc_class *v28;
  _BOOL4 v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  NSObject *v33;
  objc_class *v34;
  int v35;
  const char *v36;
  const char *v37;
  const char *v38;
  void *v39;
  uint64_t v40;
  void (*v41)(uint64_t, const char *, ...);
  objc_class *v42;
  _BOOL4 v43;
  uint64_t v44;
  void *v45;
  uint64_t v46;
  objc_class *v47;
  int v48;
  const char *v49;
  const char *v50;
  const char *v52;
  const char *v53;
  const char *Name;
  const char *v55;
  const char *v56;
  id v57;
  id v58;
  uint8_t buf[4];
  _BYTE v60[14];
  __int16 v61;
  const char *v62;
  __int16 v63;
  int v64;
  __int16 v65;
  NSObject *v66;

  if (!a1)
    return 0;
  if (!*(_QWORD *)(a1 + 16))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass((id)a1);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName((id)a1);
      Name = sel_getName("didEndPaymentActivityForCPMS");
      v10 = 45;
      if (isMetaClass)
        v10 = 43;
      v6(3, "%c[%{public}s %{public}s]:%i Error : no CPMS description", v10, ClassName, Name, 663);
    }
    v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v12 = NFSharedLogGetLogger(v11);
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v14 = object_getClass((id)a1);
      if (class_isMetaClass(v14))
        v15 = 43;
      else
        v15 = 45;
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)v60 = v15;
      *(_WORD *)&v60[4] = 2082;
      *(_QWORD *)&v60[6] = object_getClassName((id)a1);
      v61 = 2082;
      v62 = sel_getName("didEndPaymentActivityForCPMS");
      v63 = 1024;
      v64 = 663;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error : no CPMS description", buf, 0x22u);
    }
    v16 = 0;
    goto LABEL_42;
  }
  v2 = *(_QWORD **)(a1 + 24);
  if (*(_BYTE *)(a1 + 40))
    v3 = sub_100199758(v2);
  else
    v3 = sub_10019939C((uint64_t)v2);
  v17 = (void *)objc_claimAutoreleasedReturnValue(v3);
  v18 = NFSharedSignpostLog(v17);
  v19 = objc_claimAutoreleasedReturnValue(v18);
  if (os_signpost_enabled(v19))
  {
    *(_DWORD *)buf = 138412290;
    *(_QWORD *)v60 = v17;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v19, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CPMS_REQUEST", "%@", buf, 0xCu);
  }

  v20 = objc_msgSend(sub_10019A644(), "sharedCPMSAgent");
  v21 = (void *)objc_claimAutoreleasedReturnValue(v20);
  v58 = 0;
  v22 = objc_msgSend(v21, "copyPowerBudgetForRequest:forClient:error:", v17, 3, &v58);
  v13 = v58;

  if (!v22 || v13)
  {
    v39 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v40 = NFLogGetLogger(v39);
    if (v40)
    {
      v41 = (void (*)(uint64_t, const char *, ...))v40;
      v42 = object_getClass((id)a1);
      v43 = class_isMetaClass(v42);
      v53 = object_getClassName((id)a1);
      v56 = sel_getName("didEndPaymentActivityForCPMS");
      v44 = 45;
      if (v43)
        v44 = 43;
      v41(3, "%c[%{public}s %{public}s]:%i Failed to get power budget: error: %{public}@", v44, v53, v56, 678, v13);
    }
    v45 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v46 = NFSharedLogGetLogger(v45);
    v33 = objc_claimAutoreleasedReturnValue(v46);
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      goto LABEL_40;
    v47 = object_getClass((id)a1);
    if (class_isMetaClass(v47))
      v48 = 43;
    else
      v48 = 45;
    v49 = object_getClassName((id)a1);
    v50 = sel_getName("didEndPaymentActivityForCPMS");
    *(_DWORD *)buf = 67110146;
    *(_DWORD *)v60 = v48;
    *(_WORD *)&v60[4] = 2082;
    *(_QWORD *)&v60[6] = v49;
    v61 = 2082;
    v62 = v50;
    v63 = 1024;
    v64 = 678;
    v65 = 2114;
    v66 = v13;
    v38 = "%c[%{public}s %{public}s]:%i Failed to get power budget: error: %{public}@";
    goto LABEL_39;
  }
  v23 = objc_msgSend(sub_10019A644(), "sharedCPMSAgent");
  v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
  v57 = 0;
  objc_msgSend(v24, "acknowledgePowerBudget:forClientId:error:", v22, 3, &v57);
  v13 = v57;

  if (v13)
  {
    v25 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v26 = NFLogGetLogger(v25);
    if (v26)
    {
      v27 = (void (*)(uint64_t, const char *, ...))v26;
      v28 = object_getClass((id)a1);
      v29 = class_isMetaClass(v28);
      v52 = object_getClassName((id)a1);
      v55 = sel_getName("didEndPaymentActivityForCPMS");
      v30 = 45;
      if (v29)
        v30 = 43;
      v27(3, "%c[%{public}s %{public}s]:%i Failed to acknowledge budget: error: %{public}@", v30, v52, v55, 674, v13);
    }
    v31 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v32 = NFSharedLogGetLogger(v31);
    v33 = objc_claimAutoreleasedReturnValue(v32);
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      goto LABEL_40;
    v34 = object_getClass((id)a1);
    if (class_isMetaClass(v34))
      v35 = 43;
    else
      v35 = 45;
    v36 = object_getClassName((id)a1);
    v37 = sel_getName("didEndPaymentActivityForCPMS");
    *(_DWORD *)buf = 67110146;
    *(_DWORD *)v60 = v35;
    *(_WORD *)&v60[4] = 2082;
    *(_QWORD *)&v60[6] = v36;
    v61 = 2082;
    v62 = v37;
    v63 = 1024;
    v64 = 674;
    v65 = 2114;
    v66 = v13;
    v38 = "%c[%{public}s %{public}s]:%i Failed to acknowledge budget: error: %{public}@";
LABEL_39:
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, v38, buf, 0x2Cu);
LABEL_40:

  }
  v16 = v13 == 0;

LABEL_42:
  return v16;
}

uint64_t sub_10019CC08(uint64_t result)
{
  _QWORD *v1;

  if (result)
  {
    v1 = (_QWORD *)result;
    if (*(_BYTE *)(result + 41))
    {
      *(_BYTE *)(result + 41) = 0;
      if (sub_10019A5A8((id)result))
        return sub_10019C710((uint64_t)v1);
      else
        return sub_10019C528(v1);
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t sub_10019CC64(_QWORD *a1)
{
  _QWORD *v2;
  void *v3;
  uint64_t v4;
  id v5;
  void *specific;
  uint64_t Logger;
  void (*v8)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  objc_class *v15;
  int v16;
  const char *v17;
  const char *v18;
  const char *ClassName;
  const char *Name;
  id v22;
  _QWORD v23[6];
  uint8_t buf[4];
  int v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  id v33;

  if (!a1 || !a1[1])
    return 0;
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 3221225472;
  v23[2] = sub_10019CE9C;
  v23[3] = &unk_1002EA5A8;
  v23[4] = a1;
  v23[5] = "willStartPaymentActivityForCoreDuet";
  v2 = objc_retainBlock(v23);
  v3 = (void *)a1[1];
  v22 = 0;
  LODWORD(v4) = objc_msgSend(v3, "admissionCheckWithLevel:options:error:handler:", &off_100300E78, 0, &v22, v2);
  v5 = v22;
  if (v5)
    v4 = 0;
  else
    v4 = v4;
  if ((v4 & 1) == 0)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v8 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("willStartPaymentActivityForCoreDuet");
      v11 = 45;
      if (isMetaClass)
        v11 = 43;
      v8(3, "%c[%{public}s %{public}s]:%i Error starting PPM activity: %{public}@", v11, ClassName, Name, 727, v5);
    }
    v12 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v13 = NFSharedLogGetLogger(v12);
    v14 = objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      v15 = object_getClass(a1);
      if (class_isMetaClass(v15))
        v16 = 43;
      else
        v16 = 45;
      v17 = object_getClassName(a1);
      v18 = sel_getName("willStartPaymentActivityForCoreDuet");
      *(_DWORD *)buf = 67110146;
      v25 = v16;
      v26 = 2082;
      v27 = v17;
      v28 = 2082;
      v29 = v18;
      v30 = 1024;
      v31 = 727;
      v32 = 2114;
      v33 = v5;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error starting PPM activity: %{public}@", buf, 0x2Cu);
    }

  }
  return v4;
}

void sub_10019CE9C(uint64_t a1, uint64_t a2, void *a3)
{
  id v5;
  void *specific;
  uint64_t Logger;
  void (*v8)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  NSObject *v15;
  objc_class *v16;
  int v17;
  const char *v18;
  const char *v19;
  const char *v20;
  NSObject *v21;
  os_log_type_t v22;
  uint32_t v23;
  objc_class *v24;
  _BOOL4 v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  objc_class *v29;
  int v30;
  const char *v31;
  const char *v32;
  const char *v33;
  const char *Name;
  const char *v35;
  uint8_t buf[4];
  int v37;
  __int16 v38;
  const char *v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  int v43;
  __int16 v44;
  id v45;

  v5 = a3;
  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  v8 = (void (*)(uint64_t, const char *, ...))Logger;
  if (a2 == 1)
  {
    if (Logger)
    {
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 40));
      v12 = 45;
      if (isMetaClass)
        v12 = 43;
      v8(6, "%c[%{public}s %{public}s]:%i started", v12, ClassName, Name, 714);
    }
    v13 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v14 = NFSharedLogGetLogger(v13);
    v15 = objc_claimAutoreleasedReturnValue(v14);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v16 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v16))
        v17 = 43;
      else
        v17 = 45;
      v18 = object_getClassName(*(id *)(a1 + 32));
      v19 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)buf = 67109890;
      v37 = v17;
      v38 = 2082;
      v39 = v18;
      v40 = 2082;
      v41 = v19;
      v42 = 1024;
      v43 = 714;
      v20 = "%c[%{public}s %{public}s]:%i started";
      v21 = v15;
      v22 = OS_LOG_TYPE_DEFAULT;
      v23 = 34;
LABEL_20:
      _os_log_impl((void *)&_mh_execute_header, v21, v22, v20, buf, v23);
    }
  }
  else
  {
    if (Logger)
    {
      v24 = object_getClass(*(id *)(a1 + 32));
      v25 = class_isMetaClass(v24);
      v33 = object_getClassName(*(id *)(a1 + 32));
      v35 = sel_getName(*(SEL *)(a1 + 40));
      v26 = 45;
      if (v25)
        v26 = 43;
      v8(3, "%c[%{public}s %{public}s]:%i PPM refuses to start activity: %{public}@", v26, v33, v35, 712, v5);
    }
    v27 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v28 = NFSharedLogGetLogger(v27);
    v15 = objc_claimAutoreleasedReturnValue(v28);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      v29 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v29))
        v30 = 43;
      else
        v30 = 45;
      v31 = object_getClassName(*(id *)(a1 + 32));
      v32 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)buf = 67110146;
      v37 = v30;
      v38 = 2082;
      v39 = v31;
      v40 = 2082;
      v41 = v32;
      v42 = 1024;
      v43 = 712;
      v44 = 2114;
      v45 = v5;
      v20 = "%c[%{public}s %{public}s]:%i PPM refuses to start activity: %{public}@";
      v21 = v15;
      v22 = OS_LOG_TYPE_ERROR;
      v23 = 44;
      goto LABEL_20;
    }
  }

}

BOOL sub_10019D138(uint64_t a1)
{
  _QWORD *v2;
  id v3;
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  _BOOL8 v16;
  void *v17;
  uint64_t v18;
  NSObject *v19;
  id v20;
  void *v21;
  id v22;
  id v23;
  void *v24;
  void *v25;
  uint64_t v26;
  void (*v27)(uint64_t, const char *, ...);
  objc_class *v28;
  _BOOL4 v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  NSObject *v33;
  objc_class *v34;
  int v35;
  const char *v36;
  const char *v37;
  const char *v38;
  void *v39;
  uint64_t v40;
  void (*v41)(uint64_t, const char *, ...);
  objc_class *v42;
  _BOOL4 v43;
  uint64_t v44;
  void *v45;
  uint64_t v46;
  objc_class *v47;
  int v48;
  const char *v49;
  const char *v50;
  const char *v52;
  const char *v53;
  const char *Name;
  const char *v55;
  const char *v56;
  id v57;
  id v58;
  uint8_t buf[4];
  _BYTE v60[14];
  __int16 v61;
  const char *v62;
  __int16 v63;
  int v64;
  __int16 v65;
  NSObject *v66;

  if (!a1)
    return 0;
  if (!*(_QWORD *)(a1 + 16))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass((id)a1);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName((id)a1);
      Name = sel_getName("willStartPaymentActivityForCPMS");
      v10 = 45;
      if (isMetaClass)
        v10 = 43;
      v6(3, "%c[%{public}s %{public}s]:%i Error : no CPMS description", v10, ClassName, Name, 743);
    }
    v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v12 = NFSharedLogGetLogger(v11);
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v14 = object_getClass((id)a1);
      if (class_isMetaClass(v14))
        v15 = 43;
      else
        v15 = 45;
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)v60 = v15;
      *(_WORD *)&v60[4] = 2082;
      *(_QWORD *)&v60[6] = object_getClassName((id)a1);
      v61 = 2082;
      v62 = sel_getName("willStartPaymentActivityForCPMS");
      v63 = 1024;
      v64 = 743;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error : no CPMS description", buf, 0x22u);
    }
    v16 = 0;
    goto LABEL_42;
  }
  v2 = *(_QWORD **)(a1 + 24);
  if (*(_BYTE *)(a1 + 40))
    v3 = sub_100199D78(v2);
  else
    v3 = sub_100199A60(v2);
  v17 = (void *)objc_claimAutoreleasedReturnValue(v3);
  v18 = NFSharedSignpostLog(v17);
  v19 = objc_claimAutoreleasedReturnValue(v18);
  if (os_signpost_enabled(v19))
  {
    *(_DWORD *)buf = 138412290;
    *(_QWORD *)v60 = v17;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v19, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CPMS_REQUEST", "%@", buf, 0xCu);
  }

  v20 = objc_msgSend(sub_10019A644(), "sharedCPMSAgent");
  v21 = (void *)objc_claimAutoreleasedReturnValue(v20);
  v58 = 0;
  v22 = objc_msgSend(v21, "copyPowerBudgetForRequest:forClient:error:", v17, 3, &v58);
  v13 = v58;

  if (!v22 || v13)
  {
    v39 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v40 = NFLogGetLogger(v39);
    if (v40)
    {
      v41 = (void (*)(uint64_t, const char *, ...))v40;
      v42 = object_getClass((id)a1);
      v43 = class_isMetaClass(v42);
      v53 = object_getClassName((id)a1);
      v56 = sel_getName("willStartPaymentActivityForCPMS");
      v44 = 45;
      if (v43)
        v44 = 43;
      v41(3, "%c[%{public}s %{public}s]:%i Failed to get power budget: error: %{public}@", v44, v53, v56, 758, v13);
    }
    v45 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v46 = NFSharedLogGetLogger(v45);
    v33 = objc_claimAutoreleasedReturnValue(v46);
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      goto LABEL_40;
    v47 = object_getClass((id)a1);
    if (class_isMetaClass(v47))
      v48 = 43;
    else
      v48 = 45;
    v49 = object_getClassName((id)a1);
    v50 = sel_getName("willStartPaymentActivityForCPMS");
    *(_DWORD *)buf = 67110146;
    *(_DWORD *)v60 = v48;
    *(_WORD *)&v60[4] = 2082;
    *(_QWORD *)&v60[6] = v49;
    v61 = 2082;
    v62 = v50;
    v63 = 1024;
    v64 = 758;
    v65 = 2114;
    v66 = v13;
    v38 = "%c[%{public}s %{public}s]:%i Failed to get power budget: error: %{public}@";
    goto LABEL_39;
  }
  v23 = objc_msgSend(sub_10019A644(), "sharedCPMSAgent");
  v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
  v57 = 0;
  objc_msgSend(v24, "acknowledgePowerBudget:forClientId:error:", v22, 3, &v57);
  v13 = v57;

  if (v13)
  {
    v25 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v26 = NFLogGetLogger(v25);
    if (v26)
    {
      v27 = (void (*)(uint64_t, const char *, ...))v26;
      v28 = object_getClass((id)a1);
      v29 = class_isMetaClass(v28);
      v52 = object_getClassName((id)a1);
      v55 = sel_getName("willStartPaymentActivityForCPMS");
      v30 = 45;
      if (v29)
        v30 = 43;
      v27(3, "%c[%{public}s %{public}s]:%i Failed to acknowledge budget: error: %{public}@", v30, v52, v55, 754, v13);
    }
    v31 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v32 = NFSharedLogGetLogger(v31);
    v33 = objc_claimAutoreleasedReturnValue(v32);
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      goto LABEL_40;
    v34 = object_getClass((id)a1);
    if (class_isMetaClass(v34))
      v35 = 43;
    else
      v35 = 45;
    v36 = object_getClassName((id)a1);
    v37 = sel_getName("willStartPaymentActivityForCPMS");
    *(_DWORD *)buf = 67110146;
    *(_DWORD *)v60 = v35;
    *(_WORD *)&v60[4] = 2082;
    *(_QWORD *)&v60[6] = v36;
    v61 = 2082;
    v62 = v37;
    v63 = 1024;
    v64 = 754;
    v65 = 2114;
    v66 = v13;
    v38 = "%c[%{public}s %{public}s]:%i Failed to acknowledge budget: error: %{public}@";
LABEL_39:
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, v38, buf, 0x2Cu);
LABEL_40:

  }
  v16 = v13 == 0;

LABEL_42:
  return v16;
}

uint64_t sub_10019D630(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    v1 = result;
    if (*(_BYTE *)(result + 41))
      return 1;
    if (sub_10019A5A8((id)result))
    {
      if (!sub_10019D138(v1))
        return 0;
    }
    else
    {
      result = sub_10019CC64((_QWORD *)v1);
      if (!(_DWORD)result)
        return result;
    }
    result = 1;
    *(_BYTE *)(v1 + 41) = 1;
  }
  return result;
}

uint64_t sub_10019D694(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  id v5;
  _QWORD *v6;
  id v7;
  void *v8;
  uint64_t v9;
  void (*v10)(uint64_t, const char *, ...);
  objc_class *v11;
  _BOOL4 v12;
  const char *v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  NSObject *v17;
  objc_class *v18;
  int v19;
  uint64_t v20;
  void *v21;
  NSObject *v22;
  void *specific;
  void (*Logger)(uint64_t, const char *, ...);
  objc_class *Class;
  uint64_t v26;
  const char *ClassName;
  const char *Name;
  void *v29;
  uint64_t v30;
  NSObject *v31;
  objc_class *v32;
  int v33;
  const char *v34;
  const char *v35;
  void *v36;
  uint64_t v37;
  void (*v38)(uint64_t, const char *, ...);
  objc_class *v39;
  _BOOL4 isMetaClass;
  const char *v41;
  uint64_t v42;
  void *v43;
  uint64_t v44;
  NSObject *v45;
  objc_class *v46;
  int v47;
  void *v48;
  uint64_t v49;
  NSObject *v50;
  id v51;
  void *v52;
  id v53;
  id v54;
  void *v55;
  void *v56;
  void (*v57)(uint64_t, const char *, ...);
  objc_class *v58;
  uint64_t v59;
  const char *v60;
  const char *v61;
  void *v62;
  uint64_t v63;
  NSObject *v64;
  objc_class *v65;
  int v66;
  const char *v67;
  const char *v68;
  const char *v69;
  void *v70;
  void (*v71)(uint64_t, const char *, ...);
  objc_class *v72;
  uint64_t v73;
  const char *v74;
  const char *v75;
  void *v76;
  uint64_t v77;
  objc_class *v78;
  int v79;
  const char *v80;
  const char *v81;
  const char *v83;
  const char *v84;
  id v85;
  id v86;
  uint8_t buf[4];
  _BYTE v88[14];
  __int16 v89;
  const char *v90;
  __int16 v91;
  int v92;
  __int16 v93;
  NSObject *v94;

  v3 = a2;
  v4 = v3;
  if (a1)
  {
    if (*(_BYTE *)(a1 + 40))
    {
      if (v3)
      {
        v5 = *(id *)(a1 + 32);
        objc_sync_enter(v5);
        objc_msgSend(*(id *)(a1 + 32), "removeObject:", v4);
        objc_sync_exit(v5);

      }
      if (!sub_10019A5A8((id)a1))
      {
        v21 = *(void **)(a1 + 8);
        if (v21)
        {
          v86 = 0;
          LODWORD(v20) = objc_msgSend(v21, "activityStoppedWithLevel:options:error:", &off_100300E90, 0, &v86);
          v22 = v86;
          if (v22)
            v20 = 0;
          else
            v20 = v20;
          if ((v20 & 1) == 0)
          {
            specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(specific);
            if (Logger)
            {
              Class = object_getClass((id)a1);
              if (class_isMetaClass(Class))
                v26 = 43;
              else
                v26 = 45;
              ClassName = object_getClassName((id)a1);
              Name = sel_getName("didEndReaderActivityForCoreDuet");
              Logger(3, "%c[%{public}s %{public}s]:%i Error stopping PPM activity: %{public}@", v26, ClassName, Name, 805, v22);
            }
            v29 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v30 = NFSharedLogGetLogger(v29);
            v31 = objc_claimAutoreleasedReturnValue(v30);
            if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
            {
              v32 = object_getClass((id)a1);
              if (class_isMetaClass(v32))
                v33 = 43;
              else
                v33 = 45;
              v34 = object_getClassName((id)a1);
              v35 = sel_getName("didEndReaderActivityForCoreDuet");
              *(_DWORD *)buf = 67110146;
              *(_DWORD *)v88 = v33;
              *(_WORD *)&v88[4] = 2082;
              *(_QWORD *)&v88[6] = v34;
              v89 = 2082;
              v90 = v35;
              v91 = 1024;
              v92 = 805;
              v93 = 2114;
              v94 = v22;
              _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error stopping PPM activity: %{public}@", buf, 0x2Cu);
            }

          }
        }
        else
        {
          v20 = 0;
        }
        goto LABEL_78;
      }
      if (!*(_QWORD *)(a1 + 16))
      {
        v36 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v37 = NFLogGetLogger(v36);
        if (v37)
        {
          v38 = (void (*)(uint64_t, const char *, ...))v37;
          v39 = object_getClass((id)a1);
          isMetaClass = class_isMetaClass(v39);
          v41 = object_getClassName((id)a1);
          v84 = sel_getName("didEndReaderActivityForCPMS");
          v42 = 45;
          if (isMetaClass)
            v42 = 43;
          v38(3, "%c[%{public}s %{public}s]:%i Error : no CPMS description", v42, v41, v84, 821);
        }
        v43 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v44 = NFSharedLogGetLogger(v43);
        v45 = objc_claimAutoreleasedReturnValue(v44);
        if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
        {
          v46 = object_getClass((id)a1);
          if (class_isMetaClass(v46))
            v47 = 43;
          else
            v47 = 45;
          *(_DWORD *)buf = 67109890;
          *(_DWORD *)v88 = v47;
          *(_WORD *)&v88[4] = 2082;
          *(_QWORD *)&v88[6] = object_getClassName((id)a1);
          v89 = 2082;
          v90 = sel_getName("didEndReaderActivityForCPMS");
          v91 = 1024;
          v92 = 821;
          _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error : no CPMS description", buf, 0x22u);
        }
        v20 = 0;
        goto LABEL_77;
      }
      v6 = *(_QWORD **)(a1 + 24);
      if (*(_BYTE *)(a1 + 41))
        v7 = sub_100199A60(v6);
      else
        v7 = sub_10019939C((uint64_t)v6);
      v48 = (void *)objc_claimAutoreleasedReturnValue(v7);
      v49 = NFSharedSignpostLog(v48);
      v50 = objc_claimAutoreleasedReturnValue(v49);
      if (os_signpost_enabled(v50))
      {
        *(_DWORD *)buf = 138412290;
        *(_QWORD *)v88 = v48;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v50, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CPMS_REQUEST", "%@", buf, 0xCu);
      }

      v51 = objc_msgSend(sub_10019A644(), "sharedCPMSAgent");
      v52 = (void *)objc_claimAutoreleasedReturnValue(v51);
      v86 = 0;
      v53 = objc_msgSend(v52, "copyPowerBudgetForRequest:forClient:error:", v48, 3, &v86);
      v45 = v86;

      if (!v53 || v45)
      {
        v70 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v71 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v70);
        if (v71)
        {
          v72 = object_getClass((id)a1);
          if (class_isMetaClass(v72))
            v73 = 43;
          else
            v73 = 45;
          v74 = object_getClassName((id)a1);
          v75 = sel_getName("didEndReaderActivityForCPMS");
          v71(3, "%c[%{public}s %{public}s]:%i Failed to get power budget: error: %{public}@", v73, v74, v75, 836, v45);
        }
        v76 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v77 = NFSharedLogGetLogger(v76);
        v64 = objc_claimAutoreleasedReturnValue(v77);
        if (!os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
          goto LABEL_75;
        v78 = object_getClass((id)a1);
        if (class_isMetaClass(v78))
          v79 = 43;
        else
          v79 = 45;
        v80 = object_getClassName((id)a1);
        v81 = sel_getName("didEndReaderActivityForCPMS");
        *(_DWORD *)buf = 67110146;
        *(_DWORD *)v88 = v79;
        *(_WORD *)&v88[4] = 2082;
        *(_QWORD *)&v88[6] = v80;
        v89 = 2082;
        v90 = v81;
        v91 = 1024;
        v92 = 836;
        v93 = 2114;
        v94 = v45;
        v69 = "%c[%{public}s %{public}s]:%i Failed to get power budget: error: %{public}@";
      }
      else
      {
        v54 = objc_msgSend(sub_10019A644(), "sharedCPMSAgent");
        v55 = (void *)objc_claimAutoreleasedReturnValue(v54);
        v85 = 0;
        objc_msgSend(v55, "acknowledgePowerBudget:forClientId:error:", v53, 3, &v85);
        v45 = v85;

        if (!v45)
        {
LABEL_76:
          v20 = v45 == 0;

LABEL_77:
LABEL_78:
          *(_BYTE *)(a1 + 40) = 0;
          goto LABEL_79;
        }
        v56 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v57 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v56);
        if (v57)
        {
          v58 = object_getClass((id)a1);
          if (class_isMetaClass(v58))
            v59 = 43;
          else
            v59 = 45;
          v60 = object_getClassName((id)a1);
          v61 = sel_getName("didEndReaderActivityForCPMS");
          v57(3, "%c[%{public}s %{public}s]:%i Failed to acknowledge budget: error: %{public}@", v59, v60, v61, 832, v45);
        }
        v62 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v63 = NFSharedLogGetLogger(v62);
        v64 = objc_claimAutoreleasedReturnValue(v63);
        if (!os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
        {
LABEL_75:

          goto LABEL_76;
        }
        v65 = object_getClass((id)a1);
        if (class_isMetaClass(v65))
          v66 = 43;
        else
          v66 = 45;
        v67 = object_getClassName((id)a1);
        v68 = sel_getName("didEndReaderActivityForCPMS");
        *(_DWORD *)buf = 67110146;
        *(_DWORD *)v88 = v66;
        *(_WORD *)&v88[4] = 2082;
        *(_QWORD *)&v88[6] = v67;
        v89 = 2082;
        v90 = v68;
        v91 = 1024;
        v92 = 832;
        v93 = 2114;
        v94 = v45;
        v69 = "%c[%{public}s %{public}s]:%i Failed to acknowledge budget: error: %{public}@";
      }
      _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_ERROR, v69, buf, 0x2Cu);
      goto LABEL_75;
    }
    v8 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v9 = NFLogGetLogger(v8);
    if (v9)
    {
      v10 = (void (*)(uint64_t, const char *, ...))v9;
      v11 = object_getClass((id)a1);
      v12 = class_isMetaClass(v11);
      v13 = object_getClassName((id)a1);
      v83 = sel_getName("didEndReaderActivityWithDelegate:");
      v14 = 45;
      if (v12)
        v14 = 43;
      v10(6, "%c[%{public}s %{public}s]:%i Reader activity not started", v14, v13, v83, 850);
    }
    v15 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v16 = NFSharedLogGetLogger(v15);
    v17 = objc_claimAutoreleasedReturnValue(v16);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      v18 = object_getClass((id)a1);
      if (class_isMetaClass(v18))
        v19 = 43;
      else
        v19 = 45;
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)v88 = v19;
      *(_WORD *)&v88[4] = 2082;
      *(_QWORD *)&v88[6] = object_getClassName((id)a1);
      v89 = 2082;
      v90 = sel_getName("didEndReaderActivityWithDelegate:");
      v91 = 1024;
      v92 = 850;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Reader activity not started", buf, 0x22u);
    }

  }
  v20 = 0;
LABEL_79:

  return v20;
}

void sub_10019DE6C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10019DE88(uint64_t a1, uint64_t a2, void *a3)
{
  id v5;
  void *specific;
  uint64_t Logger;
  void (*v8)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  NSObject *v15;
  objc_class *v16;
  int v17;
  const char *v18;
  const char *v19;
  const char *v20;
  NSObject *v21;
  os_log_type_t v22;
  uint32_t v23;
  objc_class *v24;
  _BOOL4 v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  objc_class *v29;
  int v30;
  const char *v31;
  const char *v32;
  const char *v33;
  const char *Name;
  const char *v35;
  uint8_t buf[4];
  int v37;
  __int16 v38;
  const char *v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  int v43;
  __int16 v44;
  id v45;

  v5 = a3;
  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  v8 = (void (*)(uint64_t, const char *, ...))Logger;
  if (a2 == 1)
  {
    if (Logger)
    {
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 40));
      v12 = 45;
      if (isMetaClass)
        v12 = 43;
      v8(6, "%c[%{public}s %{public}s]:%i acitvity started", v12, ClassName, Name, 884);
    }
    v13 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v14 = NFSharedLogGetLogger(v13);
    v15 = objc_claimAutoreleasedReturnValue(v14);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v16 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v16))
        v17 = 43;
      else
        v17 = 45;
      v18 = object_getClassName(*(id *)(a1 + 32));
      v19 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)buf = 67109890;
      v37 = v17;
      v38 = 2082;
      v39 = v18;
      v40 = 2082;
      v41 = v19;
      v42 = 1024;
      v43 = 884;
      v20 = "%c[%{public}s %{public}s]:%i acitvity started";
      v21 = v15;
      v22 = OS_LOG_TYPE_DEFAULT;
      v23 = 34;
LABEL_20:
      _os_log_impl((void *)&_mh_execute_header, v21, v22, v20, buf, v23);
    }
  }
  else
  {
    if (Logger)
    {
      v24 = object_getClass(*(id *)(a1 + 32));
      v25 = class_isMetaClass(v24);
      v33 = object_getClassName(*(id *)(a1 + 32));
      v35 = sel_getName(*(SEL *)(a1 + 40));
      v26 = 45;
      if (v25)
        v26 = 43;
      v8(3, "%c[%{public}s %{public}s]:%i PPM refuses to start activity: %{public}@", v26, v33, v35, 881, v5);
    }
    v27 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v28 = NFSharedLogGetLogger(v27);
    v15 = objc_claimAutoreleasedReturnValue(v28);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      v29 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v29))
        v30 = 43;
      else
        v30 = 45;
      v31 = object_getClassName(*(id *)(a1 + 32));
      v32 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)buf = 67110146;
      v37 = v30;
      v38 = 2082;
      v39 = v31;
      v40 = 2082;
      v41 = v32;
      v42 = 1024;
      v43 = 881;
      v44 = 2114;
      v45 = v5;
      v20 = "%c[%{public}s %{public}s]:%i PPM refuses to start activity: %{public}@";
      v21 = v15;
      v22 = OS_LOG_TYPE_ERROR;
      v23 = 44;
      goto LABEL_20;
    }
  }

}

uint64_t sub_10019E124(uint64_t a1, void *a2)
{
  id v3;
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  uint64_t v16;
  id v17;
  _QWORD *v18;
  id v19;
  _BYTE *v20;
  void *v21;
  unsigned __int8 v22;
  id v23;
  unsigned __int8 v24;
  void *v25;
  uint64_t v26;
  void (*v27)(uint64_t, const char *, ...);
  objc_class *v28;
  _BOOL4 v29;
  const char *v30;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  NSObject *v34;
  objc_class *v35;
  int v36;
  void *v37;
  void *v38;
  void (*v39)(uint64_t, const char *, ...);
  objc_class *v40;
  uint64_t v41;
  const char *v42;
  const char *v43;
  void *v44;
  uint64_t v45;
  NSObject *v46;
  objc_class *v47;
  int v48;
  const char *v49;
  const char *v50;
  void *v51;
  uint64_t v52;
  NSObject *v53;
  id v54;
  void *v55;
  id v56;
  id v57;
  id v58;
  void *v59;
  void *v60;
  void (*v61)(uint64_t, const char *, ...);
  objc_class *v62;
  uint64_t v63;
  const char *v64;
  const char *v65;
  void *v66;
  uint64_t v67;
  NSObject *v68;
  objc_class *v69;
  int v70;
  const char *v71;
  const char *v72;
  const char *v73;
  void *v74;
  void (*v75)(uint64_t, const char *, ...);
  objc_class *v76;
  uint64_t v77;
  const char *v78;
  const char *v79;
  void *v80;
  uint64_t v81;
  objc_class *v82;
  int v83;
  const char *v84;
  const char *v85;
  id v86;
  const char *Name;
  const char *v89;
  id v90;
  uint8_t v91[8];
  __int16 v92;
  const char *v93;
  __int16 v94;
  const char *v95;
  __int16 v96;
  int v97;
  __int16 v98;
  void *v99;
  _BYTE buf[48];

  v3 = a2;
  if (!a1)
  {
    v16 = 0;
    goto LABEL_77;
  }
  if (*(_BYTE *)(a1 + 40))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass((id)a1);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName((id)a1);
      Name = sel_getName("willStartReaderActivityWithDelegate:");
      v10 = 45;
      if (isMetaClass)
        v10 = 43;
      v6(6, "%c[%{public}s %{public}s]:%i Reader activity already started", v10, ClassName, Name, 943);
    }
    v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v12 = NFSharedLogGetLogger(v11);
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      v14 = object_getClass((id)a1);
      if (class_isMetaClass(v14))
        v15 = 43;
      else
        v15 = 45;
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)&buf[4] = v15;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = object_getClassName((id)a1);
      *(_WORD *)&buf[18] = 2082;
      *(_QWORD *)&buf[20] = sel_getName("willStartReaderActivityWithDelegate:");
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 943;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Reader activity already started", buf, 0x22u);
    }

    goto LABEL_13;
  }
  *(_BYTE *)(a1 + 40) = 1;
  v17 = *(id *)(a1 + 32);
  objc_sync_enter(v17);
  objc_msgSend(*(id *)(a1 + 32), "addObject:", v3);
  objc_sync_exit(v17);

  if (sub_10019A5A8((id)a1))
  {
    if (!*(_QWORD *)(a1 + 16))
    {
      v25 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v26 = NFLogGetLogger(v25);
      if (v26)
      {
        v27 = (void (*)(uint64_t, const char *, ...))v26;
        v28 = object_getClass((id)a1);
        v29 = class_isMetaClass(v28);
        v30 = object_getClassName((id)a1);
        v89 = sel_getName("willStartReaderActivityForCPMS");
        v31 = 45;
        if (v29)
          v31 = 43;
        v27(3, "%c[%{public}s %{public}s]:%i Error : no CPMS description", v31, v30, v89, 913);
      }
      v32 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v33 = NFSharedLogGetLogger(v32);
      v34 = objc_claimAutoreleasedReturnValue(v33);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
      {
        v35 = object_getClass((id)a1);
        if (class_isMetaClass(v35))
          v36 = 43;
        else
          v36 = 45;
        *(_DWORD *)buf = 67109890;
        *(_DWORD *)&buf[4] = v36;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = object_getClassName((id)a1);
        *(_WORD *)&buf[18] = 2082;
        *(_QWORD *)&buf[20] = sel_getName("willStartReaderActivityForCPMS");
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 913;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error : no CPMS description", buf, 0x22u);
      }

      goto LABEL_74;
    }
    v18 = *(_QWORD **)(a1 + 24);
    if (*(_BYTE *)(a1 + 41))
      v19 = sub_100199D78(v18);
    else
      v19 = sub_100199758(v18);
    v51 = (void *)objc_claimAutoreleasedReturnValue(v19);
    v52 = NFSharedSignpostLog(v51);
    v53 = objc_claimAutoreleasedReturnValue(v52);
    if (os_signpost_enabled(v53))
    {
      *(_DWORD *)buf = 138412290;
      *(_QWORD *)&buf[4] = v51;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v53, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CPMS_REQUEST", "%@", buf, 0xCu);
    }

    v54 = objc_msgSend(sub_10019A644(), "sharedCPMSAgent");
    v55 = (void *)objc_claimAutoreleasedReturnValue(v54);
    *(_QWORD *)v91 = 0;
    v56 = objc_msgSend(v55, "copyPowerBudgetForRequest:forClient:error:", v51, 3, v91);
    v57 = *(id *)v91;

    if (!v56 || v57)
    {
      v74 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v75 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v74);
      if (v75)
      {
        v76 = object_getClass((id)a1);
        if (class_isMetaClass(v76))
          v77 = 43;
        else
          v77 = 45;
        v78 = object_getClassName((id)a1);
        v79 = sel_getName("willStartReaderActivityForCPMS");
        v75(3, "%c[%{public}s %{public}s]:%i Failed to get power budget: error: %{public}@", v77, v78, v79, 928, v57);
      }
      v80 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v81 = NFSharedLogGetLogger(v80);
      v68 = objc_claimAutoreleasedReturnValue(v81);
      if (!os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
        goto LABEL_72;
      v82 = object_getClass((id)a1);
      if (class_isMetaClass(v82))
        v83 = 43;
      else
        v83 = 45;
      v84 = object_getClassName((id)a1);
      v85 = sel_getName("willStartReaderActivityForCPMS");
      *(_DWORD *)buf = 67110146;
      *(_DWORD *)&buf[4] = v83;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = v84;
      *(_WORD *)&buf[18] = 2082;
      *(_QWORD *)&buf[20] = v85;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 928;
      *(_WORD *)&buf[34] = 2114;
      *(_QWORD *)&buf[36] = v57;
      v73 = "%c[%{public}s %{public}s]:%i Failed to get power budget: error: %{public}@";
    }
    else
    {
      v58 = objc_msgSend(sub_10019A644(), "sharedCPMSAgent");
      v59 = (void *)objc_claimAutoreleasedReturnValue(v58);
      v90 = 0;
      objc_msgSend(v59, "acknowledgePowerBudget:forClientId:error:", v56, 3, &v90);
      v57 = v90;

      if (!v57)
        goto LABEL_73;
      v60 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v61 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v60);
      if (v61)
      {
        v62 = object_getClass((id)a1);
        if (class_isMetaClass(v62))
          v63 = 43;
        else
          v63 = 45;
        v64 = object_getClassName((id)a1);
        v65 = sel_getName("willStartReaderActivityForCPMS");
        v61(3, "%c[%{public}s %{public}s]:%i Failed to acknowledge budget: error: %{public}@", v63, v64, v65, 924, v57);
      }
      v66 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v67 = NFSharedLogGetLogger(v66);
      v68 = objc_claimAutoreleasedReturnValue(v67);
      if (!os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
      {
LABEL_72:

LABEL_73:
        if (v57)
          goto LABEL_74;
LABEL_13:
        v16 = 1;
        goto LABEL_77;
      }
      v69 = object_getClass((id)a1);
      if (class_isMetaClass(v69))
        v70 = 43;
      else
        v70 = 45;
      v71 = object_getClassName((id)a1);
      v72 = sel_getName("willStartReaderActivityForCPMS");
      *(_DWORD *)buf = 67110146;
      *(_DWORD *)&buf[4] = v70;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = v71;
      *(_WORD *)&buf[18] = 2082;
      *(_QWORD *)&buf[20] = v72;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 924;
      *(_WORD *)&buf[34] = 2114;
      *(_QWORD *)&buf[36] = v57;
      v73 = "%c[%{public}s %{public}s]:%i Failed to acknowledge budget: error: %{public}@";
    }
    _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_ERROR, v73, buf, 0x2Cu);
    goto LABEL_72;
  }
  if (*(_QWORD *)(a1 + 8))
  {
    *(_QWORD *)buf = _NSConcreteStackBlock;
    *(_QWORD *)&buf[8] = 3221225472;
    *(_QWORD *)&buf[16] = sub_10019DE88;
    *(_QWORD *)&buf[24] = &unk_1002EA5A8;
    *(_QWORD *)&buf[32] = a1;
    *(_QWORD *)&buf[40] = "willStartReaderActivityForCoreDuet";
    v20 = objc_retainBlock(buf);
    v21 = *(void **)(a1 + 8);
    v90 = 0;
    v22 = objc_msgSend(v21, "admissionCheckWithLevel:options:error:handler:", &off_100300E90, 0, &v90, v20);
    v23 = v90;
    if (v23)
      v24 = 0;
    else
      v24 = v22;
    if ((v24 & 1) == 0)
    {
      v37 = v23;
      v38 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v39 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger(v38);
      if (v39)
      {
        v40 = object_getClass((id)a1);
        if (class_isMetaClass(v40))
          v41 = 43;
        else
          v41 = 45;
        v42 = object_getClassName((id)a1);
        v43 = sel_getName("willStartReaderActivityForCoreDuet");
        v39(3, "%c[%{public}s %{public}s]:%i Error starting PPM activity: %{public}@", v41, v42, v43, 897, v37);
      }
      v44 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v45 = NFSharedLogGetLogger(v44);
      v46 = objc_claimAutoreleasedReturnValue(v45);
      if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
      {
        v47 = object_getClass((id)a1);
        if (class_isMetaClass(v47))
          v48 = 43;
        else
          v48 = 45;
        v49 = object_getClassName((id)a1);
        v50 = sel_getName("willStartReaderActivityForCoreDuet");
        *(_DWORD *)v91 = 67110146;
        *(_DWORD *)&v91[4] = v48;
        v92 = 2082;
        v93 = v49;
        v94 = 2082;
        v95 = v50;
        v96 = 1024;
        v97 = 897;
        v98 = 2114;
        v99 = v37;
        _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error starting PPM activity: %{public}@", v91, 0x2Cu);
      }

      goto LABEL_74;
    }

    goto LABEL_13;
  }
LABEL_74:
  if (v3)
  {
    v86 = *(id *)(a1 + 32);
    objc_sync_enter(v86);
    objc_msgSend(*(id *)(a1 + 32), "removeObject:", v3);
    objc_sync_exit(v86);

  }
  v16 = 0;
  *(_BYTE *)(a1 + 40) = 0;
LABEL_77:

  return v16;
}

void sub_10019E984(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void *sub_10019EA18()
{
  void *v0;
  void *v1;
  void *v3;
  void *v4;
  __int128 v5;
  uint64_t v6;

  v4 = 0;
  if (!qword_10032ACB8)
  {
    v5 = off_1002EA5C8;
    v6 = 0;
    qword_10032ACB8 = _sl_dlopen(&v5, &v4);
  }
  v0 = (void *)qword_10032ACB8;
  if (!qword_10032ACB8)
  {
    v0 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "void *CPMSLibrary(void)"));
    objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", v3, CFSTR("NFCoreDuetWrapper.m"), 30, CFSTR("%s"), v4);

    __break(1u);
    goto LABEL_7;
  }
  v1 = v4;
  if (v4)
LABEL_7:
    free(v1);
  return v0;
}

void sub_10019EB1C(uint64_t a1)
{
  void *v2;
  void *v3;

  sub_10019EA18();
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = objc_getClass("CPMSAgent");
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    qword_10032ACC0 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  else
  {
    v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Class getCPMSAgentClass(void)_block_invoke"));
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, CFSTR("NFCoreDuetWrapper.m"), 32, CFSTR("Unable to find class %s"), "CPMSAgent");

    __break(1u);
  }
}

void sub_10019EBE0(uint64_t a1)
{
  void *v2;
  void *v3;

  sub_10019EA18();
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = objc_getClass("CPMSClientDescription");
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    qword_10032AAF0 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  else
  {
    v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Class getCPMSClientDescriptionClass(void)_block_invoke"));
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, CFSTR("NFCoreDuetWrapper.m"), 31, CFSTR("Unable to find class %s"), "CPMSClientDescription");

    __break(1u);
  }
}

void sub_10019F4C8(uint64_t a1, void *a2, int a3)
{
  id v5;
  uint64_t v6;
  void *specific;
  uint64_t Logger;
  void (*v9)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  id v14;
  int v15;
  id v16;
  id v17;
  void *v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  NSObject *v22;
  objc_class *v23;
  int v24;
  const char *v25;
  const char *v26;
  id v27;
  int v28;
  id v29;
  void *v30;
  id v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  uint64_t v37;
  id v38;
  _QWORD *v39;
  int64_t v40;
  dispatch_time_t v41;
  NSObject *v42;
  id *v43;
  id *v44;
  id *v45;
  id v46;
  id v47;
  id v48;
  id v49;
  int v50;
  __int128 v51;
  __int128 v52;
  _QWORD v53[4];
  id v54;
  id v55;
  __int128 v56;
  _QWORD block[4];
  id v58;
  id v59;
  __int128 v60;
  NSErrorUserInfoKey v61;
  void *v62;
  NSErrorUserInfoKey v63;
  void *v64;
  uint8_t buf[4];
  int v66;
  __int16 v67;
  const char *v68;
  __int16 v69;
  const char *v70;
  __int16 v71;
  int v72;
  __int16 v73;
  id v74;
  __int16 v75;
  void *v76;

  v5 = a2;
  v6 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v6 + 241))
  {
    *(_BYTE *)(v6 + 241) = 1;
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v9 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      v14 = v5;
      v15 = a3;
      v16 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "debugDescription")));
      v17 = objc_msgSend(v16, "UTF8String");
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "sessionUID"));
      v19 = 45;
      if (isMetaClass)
        v19 = 43;
      v9(6, "%c[%{public}s %{public}s]:%i UI is dismissed, error = %s for session %@", v19, ClassName, Name, 212, v17, v18);

      a3 = v15;
      v5 = v14;
    }
    v20 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v21 = NFSharedLogGetLogger(v20);
    v22 = objc_claimAutoreleasedReturnValue(v21);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      v23 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v23))
        v24 = 43;
      else
        v24 = 45;
      v50 = v24;
      v25 = object_getClassName(*(id *)(a1 + 32));
      v26 = sel_getName(*(SEL *)(a1 + 56));
      v27 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "debugDescription")));
      v28 = a3;
      v29 = objc_msgSend(v27, "UTF8String");
      v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "sessionUID"));
      *(_DWORD *)buf = 67110402;
      v66 = v50;
      v67 = 2082;
      v68 = v25;
      v69 = 2082;
      v70 = v26;
      v71 = 1024;
      v72 = 212;
      v73 = 2080;
      v74 = v29;
      a3 = v28;
      v75 = 2112;
      v76 = v30;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i UI is dismissed, error = %s for session %@", buf, 0x36u);

    }
    v31 = objc_alloc((Class)NSError);
    v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    if (a3)
    {
      v63 = NSLocalizedDescriptionKey;
      v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "User cancelled"));
      v64 = v33;
      v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v64, &v63, 1));
      v35 = v31;
      v36 = v32;
      v37 = 48;
    }
    else
    {
      v61 = NSLocalizedDescriptionKey;
      v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Aborted"));
      v62 = v33;
      v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v62, &v61, 1));
      v35 = v31;
      v36 = v32;
      v37 = 3;
    }
    v38 = objc_msgSend(v35, "initWithDomain:code:userInfo:", v36, v37, v34);

    v39 = *(_QWORD **)(a1 + 32);
    if (v39[29])
    {
      if (a3)
        v40 = 500000000;
      else
        v40 = 2500000000;
      v41 = dispatch_time(0, v40);
      v42 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "workQueue"));
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10019F980;
      block[3] = &unk_1002E5CD0;
      v43 = &v58;
      v44 = &v59;
      v58 = *(id *)(a1 + 32);
      v59 = v38;
      v45 = (id *)&v60;
      v51 = *(_OWORD *)(a1 + 48);
      v46 = (id)v51;
      v60 = v51;
      v47 = v38;
      dispatch_after(v41, v42, block);
    }
    else
    {
      v42 = objc_claimAutoreleasedReturnValue(objc_msgSend(v39, "workQueue"));
      v53[0] = _NSConcreteStackBlock;
      v53[1] = 3221225472;
      v53[2] = sub_10019FB94;
      v53[3] = &unk_1002E5CD0;
      v43 = &v54;
      v44 = &v55;
      v54 = *(id *)(a1 + 32);
      v55 = v38;
      v45 = (id *)&v56;
      v52 = *(_OWORD *)(a1 + 48);
      v48 = (id)v52;
      v56 = v52;
      v49 = v38;
      dispatch_async(v42, v53);
    }

  }
}

id sub_10019F980(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  id v9;
  void *v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  objc_class *v15;
  int v16;
  const char *v17;
  const char *v18;
  id v19;
  void *v20;
  uint64_t v21;
  uint8_t buf[4];
  int v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  id v32;
  __int16 v33;
  void *v34;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    v9 = objc_msgSend(*(id *)(a1 + 40), "code");
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v11 = 45;
    if (isMetaClass)
      v11 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i Activating invalidation handler: error=0x%lx for session %@", v11, ClassName, Name, 237, v9, v10);

  }
  v12 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v13 = NFSharedLogGetLogger(v12);
  v14 = objc_claimAutoreleasedReturnValue(v13);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    v15 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v15))
      v16 = 43;
    else
      v16 = 45;
    v17 = object_getClassName(*(id *)(a1 + 32));
    v18 = sel_getName(*(SEL *)(a1 + 56));
    v19 = objc_msgSend(*(id *)(a1 + 40), "code");
    v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110402;
    v24 = v16;
    v25 = 2082;
    v26 = v17;
    v27 = 2082;
    v28 = v18;
    v29 = 1024;
    v30 = 237;
    v31 = 2048;
    v32 = v19;
    v33 = 2112;
    v34 = v20;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Activating invalidation handler: error=0x%lx for session %@", buf, 0x36u);

  }
  v21 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 232);
  if (v21)
    (*(void (**)(void))(v21 + 16))();
  objc_msgSend(*(id *)(a1 + 48), "didUIControllerInvalidate:", *(_QWORD *)(a1 + 40));
  return objc_msgSend(*(id *)(a1 + 32), "clearUIControllerInvalidationHandler");
}

id sub_10019FB94(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  id v9;
  void *v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  objc_class *v15;
  int v16;
  const char *v17;
  const char *v18;
  id v19;
  void *v20;
  uint8_t buf[4];
  int v23;
  __int16 v24;
  const char *v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  id v31;
  __int16 v32;
  void *v33;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    v9 = objc_msgSend(*(id *)(a1 + 40), "code");
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v11 = 45;
    if (isMetaClass)
      v11 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i Activating invalidation handler: error=0x%lx for session %@", v11, ClassName, Name, 246, v9, v10);

  }
  v12 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v13 = NFSharedLogGetLogger(v12);
  v14 = objc_claimAutoreleasedReturnValue(v13);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    v15 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v15))
      v16 = 43;
    else
      v16 = 45;
    v17 = object_getClassName(*(id *)(a1 + 32));
    v18 = sel_getName(*(SEL *)(a1 + 56));
    v19 = objc_msgSend(*(id *)(a1 + 40), "code");
    v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110402;
    v23 = v16;
    v24 = 2082;
    v25 = v17;
    v26 = 2082;
    v27 = v18;
    v28 = 1024;
    v29 = 246;
    v30 = 2048;
    v31 = v19;
    v32 = 2112;
    v33 = v20;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Activating invalidation handler: error=0x%lx for session %@", buf, 0x36u);

  }
  objc_msgSend(*(id *)(a1 + 48), "didUIControllerInvalidate:", *(_QWORD *)(a1 + 40));
  return objc_msgSend(*(id *)(a1 + 32), "clearUIControllerInvalidationHandler");
}

void sub_10019FD88(uint64_t a1, void *a2)
{
  id v3;
  NSObject *v4;
  id v5;
  uint64_t v6;
  id v7;
  id v8;
  __int128 v9;
  _QWORD block[4];
  id v11;
  id v12;
  uint64_t v13;
  __int128 v14;

  v3 = a2;
  v4 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "workQueue"));
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10019FE58;
  block[3] = &unk_1002EA850;
  v11 = v3;
  v5 = *(id *)(a1 + 32);
  v6 = *(_QWORD *)(a1 + 40);
  v12 = v5;
  v13 = v6;
  v9 = *(_OWORD *)(a1 + 48);
  v7 = (id)v9;
  v14 = v9;
  v8 = v3;
  dispatch_async(v4, block);

}

void sub_10019FE58(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  objc_class *v15;
  int v16;
  const char *v17;
  const char *v18;
  uint64_t v19;
  void *v20;
  id v21;
  void *v22;
  uint64_t v23;
  void (*v24)(uint64_t, const char *, ...);
  objc_class *v25;
  _BOOL4 v26;
  const char *v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  NSObject *v31;
  objc_class *v32;
  int v33;
  const char *v34;
  const char *v35;
  id v36;
  void *v37;
  void *v38;
  void *v39;
  const char *v40;
  NSErrorUserInfoKey v41;
  void *v42;
  uint8_t buf[4];
  int v44;
  __int16 v45;
  const char *v46;
  __int16 v47;
  const char *v48;
  __int16 v49;
  int v50;
  __int16 v51;
  uint64_t v52;
  __int16 v53;
  void *v54;

  if (*(_QWORD *)(a1 + 32))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 40));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 40));
      Name = sel_getName(*(SEL *)(a1 + 64));
      v9 = *(_QWORD *)(a1 + 32);
      v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "sessionUID"));
      v11 = 45;
      if (isMetaClass)
        v11 = 43;
      v4(3, "%c[%{public}s %{public}s]:%i Error activating UI : %@ for session %@", v11, ClassName, Name, 257, v9, v10);

    }
    v12 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v13 = NFSharedLogGetLogger(v12);
    v14 = objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      v15 = object_getClass(*(id *)(a1 + 40));
      if (class_isMetaClass(v15))
        v16 = 43;
      else
        v16 = 45;
      v17 = object_getClassName(*(id *)(a1 + 40));
      v18 = sel_getName(*(SEL *)(a1 + 64));
      v19 = *(_QWORD *)(a1 + 32);
      v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "sessionUID"));
      *(_DWORD *)buf = 67110402;
      v44 = v16;
      v45 = 2082;
      v46 = v17;
      v47 = 2082;
      v48 = v18;
      v49 = 1024;
      v50 = 257;
      v51 = 2112;
      v52 = v19;
      v53 = 2112;
      v54 = v20;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error activating UI : %@ for session %@", buf, 0x36u);

    }
    objc_msgSend(*(id *)(a1 + 40), "clearUIControllerInvalidationHandler");
    v21 = *(id *)(a1 + 32);
  }
  else if ((objc_msgSend(*(id *)(a1 + 40), "didEnd") & 1) != 0
         || objc_msgSend(*(id *)(a1 + 48), "isSuspended"))
  {
    v22 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v23 = NFLogGetLogger(v22);
    if (v23)
    {
      v24 = (void (*)(uint64_t, const char *, ...))v23;
      v25 = object_getClass(*(id *)(a1 + 40));
      v26 = class_isMetaClass(v25);
      v27 = object_getClassName(*(id *)(a1 + 40));
      v40 = sel_getName(*(SEL *)(a1 + 64));
      v28 = 45;
      if (v26)
        v28 = 43;
      v24(6, "%c[%{public}s %{public}s]:%i Session has been terminated / suspended", v28, v27, v40, 261);
    }
    v29 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v30 = NFSharedLogGetLogger(v29);
    v31 = objc_claimAutoreleasedReturnValue(v30);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      v32 = object_getClass(*(id *)(a1 + 40));
      if (class_isMetaClass(v32))
        v33 = 43;
      else
        v33 = 45;
      v34 = object_getClassName(*(id *)(a1 + 40));
      v35 = sel_getName(*(SEL *)(a1 + 64));
      *(_DWORD *)buf = 67109890;
      v44 = v33;
      v45 = 2082;
      v46 = v34;
      v47 = 2082;
      v48 = v35;
      v49 = 1024;
      v50 = 261;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Session has been terminated / suspended", buf, 0x22u);
    }

    v36 = objc_alloc((Class)NSError);
    v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v41 = NSLocalizedDescriptionKey;
    v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid State"));
    v42 = v38;
    v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v42, &v41, 1));
    v21 = objc_msgSend(v36, "initWithDomain:code:userInfo:", v37, 12, v39);

    objc_msgSend(*(id *)(*(_QWORD *)(a1 + 40) + 216), "coreNFCUIInvalidate");
  }
  else
  {
    v21 = 0;
    *(_BYTE *)(*(_QWORD *)(a1 + 40) + 240) = 1;
  }
  (*(void (**)(void))(*(_QWORD *)(a1 + 56) + 16))();

}

void sub_1001A0838(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,id location)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1001A0874(uint64_t a1)
{
  NSObject *v2;
  id WeakRetained;
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v11;
  void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  NSObject *v18;
  objc_class *v19;
  int v20;
  const char *v21;
  const char *v22;
  void *v23;
  void *v24;
  unsigned int v25;
  void *v26;
  void *v27;
  uint64_t v28;
  NSObject *v29;
  void *v30;
  id v31;
  void *v32;
  void *v33;
  void *v34;
  id v35;
  NSErrorUserInfoKey v36;
  void *v37;
  _BYTE state[18];
  __int16 v39;
  const char *v40;
  __int16 v41;
  int v42;
  __int16 v43;
  void *v44;
  __int16 v45;
  unsigned int v46;
  __int16 v47;
  void *v48;

  v2 = _os_activity_create((void *)&_mh_execute_header, "com.apple.nfcd.reader.sessionTimer", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  *(_QWORD *)state = 0;
  *(_QWORD *)&state[8] = 0;
  os_activity_scope_enter(v2, (os_activity_scope_state_t)state);
  os_activity_scope_leave((os_activity_scope_state_t)state);

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(WeakRetained);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(WeakRetained);
      Name = sel_getName(*(SEL *)(a1 + 40));
      v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "clientName"));
      v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "connection"));
      v13 = objc_msgSend(v12, "processIdentifier");
      v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "sessionUID"));
      v15 = 43;
      if (!isMetaClass)
        v15 = 45;
      v6(5, "%c[%{public}s %{public}s]:%i Reader session expired: %@ (%d) %@", v15, ClassName, Name, 337, v11, v13, v14);

    }
    v16 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v17 = NFSharedLogGetLogger(v16);
    v18 = objc_claimAutoreleasedReturnValue(v17);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      v19 = object_getClass(WeakRetained);
      if (class_isMetaClass(v19))
        v20 = 43;
      else
        v20 = 45;
      v21 = object_getClassName(WeakRetained);
      v22 = sel_getName(*(SEL *)(a1 + 40));
      v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "clientName"));
      v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "connection"));
      v25 = objc_msgSend(v24, "processIdentifier");
      v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "sessionUID"));
      *(_DWORD *)state = 67110658;
      *(_DWORD *)&state[4] = v20;
      *(_WORD *)&state[8] = 2082;
      *(_QWORD *)&state[10] = v21;
      v39 = 2082;
      v40 = v22;
      v41 = 1024;
      v42 = 337;
      v43 = 2112;
      v44 = v23;
      v45 = 1024;
      v46 = v25;
      v47 = 2112;
      v48 = v26;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Reader session expired: %@ (%d) %@", state, 0x3Cu);

    }
    *((_DWORD *)WeakRetained + 50) = 1;
    v27 = (void *)*((_QWORD *)WeakRetained + 43);
    *((_QWORD *)WeakRetained + 43) = 0;

    *((_QWORD *)WeakRetained + 28) = 0;
    v28 = NFSharedSignpostLog(objc_msgSend(WeakRetained, "endSession:", 0));
    v29 = objc_claimAutoreleasedReturnValue(v28);
    if (os_signpost_enabled(v29))
    {
      *(_WORD *)state = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v29, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "sessionTimerExpired", "", state, 2u);
    }

    v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "remoteObject"));
    v31 = objc_alloc((Class)NSError);
    v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v36 = NSLocalizedDescriptionKey;
    v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Timeout"));
    v37 = v33;
    v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v37, &v36, 1));
    v35 = objc_msgSend(v31, "initWithDomain:code:userInfo:", v32, 5, v34);
    objc_msgSend(v30, "didTerminate:", v35);

  }
}

void sub_1001A161C(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  NSObject *v11;
  objc_class *v12;
  int v13;
  const char *v14;
  const char *v15;
  void *v16;
  unsigned int v17;
  void *v18;
  id v19;
  id WeakRetained;
  id v21;
  uint64_t v22;
  NSObject *v23;
  const char *Name;
  uint8_t buf[4];
  int v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  int v32;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 40));
    v8 = 45;
    if (isMetaClass)
      v8 = 43;
    v4(4, "%c[%{public}s %{public}s]:%i Stopping reader session due to revocation of PPM", v8, ClassName, Name, 451);
  }
  v9 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v10 = NFSharedLogGetLogger(v9);
  v11 = objc_claimAutoreleasedReturnValue(v10);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    v12 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v12))
      v13 = 43;
    else
      v13 = 45;
    v14 = object_getClassName(*(id *)(a1 + 32));
    v15 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)buf = 67109890;
    v26 = v13;
    v27 = 2082;
    v28 = v14;
    v29 = 2082;
    v30 = v15;
    v31 = 1024;
    v32 = 451;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Stopping reader session due to revocation of PPM", buf, 0x22u);
  }

  if ((objc_msgSend(*(id *)(a1 + 32), "didEnd") & 1) == 0)
  {
    v16 = (void *)objc_claimAutoreleasedReturnValue(+[_NFHardwareManager sharedHardwareManager](_NFHardwareManager, "sharedHardwareManager"));
    v17 = sub_10011B638(v16);
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "defaultRoutingConfig:", 3));
    v19 = objc_msgSend(v16, "setRoutingConfig:", v18);

    WeakRetained = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 320));
    sub_10019D694((uint64_t)WeakRetained, *(void **)(a1 + 32));

    v21 = objc_msgSend(v16, "notifyReaderModeActivityEnd");
    if (v17)
    {
      v22 = NFSharedSignpostLog(v21);
      v23 = objc_claimAutoreleasedReturnValue(v22);
      if (os_signpost_enabled(v23))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v23, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "Polling", "", buf, 2u);
      }

    }
  }
}

id sub_1001A24F8(id result, uint64_t a2)
{
  uint64_t v2;

  if (a2 == 1)
  {
    v2 = *((_QWORD *)result + 4);
    if (*(_BYTE *)(v2 + 240))
      return objc_msgSend(*(id *)(v2 + 216), "coreNFCUITagScannedCount:", objc_msgSend(*((id *)result + 5), "count"));
  }
  return result;
}

void sub_1001A4810(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  uint64_t v19;
  id v20;
  void *v21;
  void *v22;
  void *v23;
  id v24;
  NSErrorUserInfoKey v25;
  void *v26;
  uint8_t buf[4];
  int v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  void *v36;

  if (!objc_msgSend(*(id *)(a1 + 32), "didStart")
    || (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) != 0
    || objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      v10 = 45;
      if (isMetaClass)
        v10 = 43;
      v4(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v10, ClassName, Name, 811, v9);

    }
    v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v12 = NFSharedLogGetLogger(v11);
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v14 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v14))
        v15 = 43;
      else
        v15 = 45;
      v16 = object_getClassName(*(id *)(a1 + 32));
      v17 = sel_getName(*(SEL *)(a1 + 56));
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      *(_DWORD *)buf = 67110146;
      v28 = v15;
      v29 = 2082;
      v30 = v16;
      v31 = 2082;
      v32 = v17;
      v33 = 1024;
      v34 = 811;
      v35 = 2114;
      v36 = v18;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

    }
    v19 = *(_QWORD *)(a1 + 48);
    if (v19)
    {
      v20 = objc_alloc((Class)NSError);
      v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v25 = NSLocalizedDescriptionKey;
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
      v26 = v22;
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v26, &v25, 1));
      v24 = objc_msgSend(v20, "initWithDomain:code:userInfo:", v21, 54, v23);
      (*(void (**)(uint64_t, _QWORD, id))(v19 + 16))(v19, 0, v24);

    }
  }
  else
  {
    objc_msgSend(*(id *)(a1 + 32), "_sync_connect:completion:", *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48));
  }
}

void sub_1001A4EFC(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  void *v10;
  id v11;
  void *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  NSObject *v16;
  objc_class *v17;
  int v18;
  const char *v19;
  const char *v20;
  void *v21;
  void *v22;
  unsigned int v23;
  void *v24;
  void *v25;
  uint64_t v26;
  void (*v27)(uint64_t, const char *, ...);
  objc_class *v28;
  _BOOL4 v29;
  const char *v30;
  const char *v31;
  void *v32;
  uint64_t v33;
  void *v34;
  uint64_t v35;
  NSObject *v36;
  objc_class *v37;
  int v38;
  const char *v39;
  const char *v40;
  void *v41;
  uint64_t v42;
  id v43;
  void *v44;
  void *v45;
  void *v46;
  id v47;
  NSErrorUserInfoKey v48;
  void *v49;
  uint8_t buf[4];
  int v51;
  __int16 v52;
  const char *v53;
  __int16 v54;
  const char *v55;
  __int16 v56;
  int v57;
  __int16 v58;
  void *v59;
  __int16 v60;
  unsigned int v61;
  __int16 v62;
  void *v63;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "connection"));
    v11 = objc_msgSend(v10, "processIdentifier");
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v13 = 43;
    if (!isMetaClass)
      v13 = 45;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@ (%d) %{public}@", v13, ClassName, Name, 842, v9, v11, v12);

  }
  v14 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v15 = NFSharedLogGetLogger(v14);
  v16 = objc_claimAutoreleasedReturnValue(v15);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    v17 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v17))
      v18 = 43;
    else
      v18 = 45;
    v19 = object_getClassName(*(id *)(a1 + 32));
    v20 = sel_getName(*(SEL *)(a1 + 48));
    v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "connection"));
    v23 = objc_msgSend(v22, "processIdentifier");
    v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110658;
    v51 = v18;
    v52 = 2082;
    v53 = v19;
    v54 = 2082;
    v55 = v20;
    v56 = 1024;
    v57 = 842;
    v58 = 2114;
    v59 = v21;
    v60 = 1024;
    v61 = v23;
    v62 = 2114;
    v63 = v24;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@ (%d) %{public}@", buf, 0x3Cu);

  }
  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v44 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "_disconnectWithCardRemoval:", *(unsigned __int8 *)(a1 + 56)));
    (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
    if (v44)
    {
      +[NFExceptionsCALogger postAnalyticsReaderModeExceptionForType:tagType:rfFrameInterface:withErrorCode:](NFExceptionsCALogger, "postAnalyticsReaderModeExceptionForType:tagType:rfFrameInterface:withErrorCode:", 2, objc_msgSend(*(id *)(a1 + 32), "_getTagTypeFromTag:", *(_QWORD *)(*(_QWORD *)(a1 + 32) + 344)), (*(_DWORD *)(*(_QWORD *)(a1 + 32) + 280) >> 12) & 1, objc_msgSend(v44, "code"));
      sub_10020CAC8((uint64_t)NFDailyStatisticsCALogger, CFSTR("readerModeDisconnectErrorCount"));
    }
    goto LABEL_24;
  }
  v25 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v26 = NFLogGetLogger(v25);
  if (v26)
  {
    v27 = (void (*)(uint64_t, const char *, ...))v26;
    v28 = object_getClass(*(id *)(a1 + 32));
    v29 = class_isMetaClass(v28);
    v30 = object_getClassName(*(id *)(a1 + 32));
    v31 = sel_getName(*(SEL *)(a1 + 48));
    v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v33 = 45;
    if (v29)
      v33 = 43;
    v27(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v33, v30, v31, 844, v32);

  }
  v34 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v35 = NFSharedLogGetLogger(v34);
  v36 = objc_claimAutoreleasedReturnValue(v35);
  if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
  {
    v37 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v37))
      v38 = 43;
    else
      v38 = 45;
    v39 = object_getClassName(*(id *)(a1 + 32));
    v40 = sel_getName(*(SEL *)(a1 + 48));
    v41 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v51 = v38;
    v52 = 2082;
    v53 = v39;
    v54 = 2082;
    v55 = v40;
    v56 = 1024;
    v57 = 844;
    v58 = 2114;
    v59 = v41;
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v42 = *(_QWORD *)(a1 + 40);
  if (v42)
  {
    v43 = objc_alloc((Class)NSError);
    v44 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v48 = NSLocalizedDescriptionKey;
    v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v49 = v45;
    v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v49, &v48, 1));
    v47 = objc_msgSend(v43, "initWithDomain:code:userInfo:", v44, 54, v46);
    (*(void (**)(uint64_t, id))(v42 + 16))(v42, v47);

LABEL_24:
  }
}

void sub_1001A5F48(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  uint64_t v5;
  id v6;
  void *v7;
  int v8;
  void *v9;
  void *v10;
  id v11;
  void *v12;
  id v13;
  void *v14;
  void *v15;
  void *v16;
  id v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  NSErrorUserInfoKey v21;
  void *v22;

  v4 = *(_QWORD *)(a1 + 40);
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 344);
  v6 = objc_alloc((Class)NSError);
  v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
  v21 = NSLocalizedDescriptionKey;
  if (a2 >= 0x47)
    v8 = 71;
  else
    v8 = a2;
  v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002EA5E0[v8], NSLocalizedDescriptionKey));
  v22 = v9;
  v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v22, &v21, 1));
  v11 = objc_msgSend(v6, "initWithDomain:code:userInfo:", v7, a2, v10);
  (*(void (**)(uint64_t, uint64_t, _QWORD, id))(v4 + 16))(v4, v5, 0, v11);

  +[NFExceptionsCALogger postAnalyticsReaderModeExceptionForType:tagType:rfFrameInterface:withErrorCode:](NFExceptionsCALogger, "postAnalyticsReaderModeExceptionForType:tagType:rfFrameInterface:withErrorCode:", 3, objc_msgSend(*(id *)(a1 + 32), "_getTagTypeFromTag:", *(_QWORD *)(*(_QWORD *)(a1 + 32) + 344)), (*(_DWORD *)(*(_QWORD *)(a1 + 32) + 280) >> 12) & 1, 8);
  sub_10020CAC8((uint64_t)NFDailyStatisticsCALogger, CFSTR("readerModeTransceiveErrorCount"));
  if (a2 == 32)
  {
    objc_msgSend(*(id *)(a1 + 32), "endSession:", 0);
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "remoteObject"));
    v13 = objc_alloc((Class)NSError);
    v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v19 = v18;
    v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Not entitled"));
    v20 = v15;
    v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v20, &v19, 1));
    v17 = objc_msgSend(v13, "initWithDomain:code:userInfo:", v14, 32, v16);
    objc_msgSend(v12, "didTerminate:", v17);

  }
}

void sub_1001A629C(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  uint64_t v19;
  id v20;
  void *v21;
  void *v22;
  void *v23;
  id v24;
  NSErrorUserInfoKey v25;
  void *v26;
  uint8_t buf[4];
  int v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  void *v36;

  if (!objc_msgSend(*(id *)(a1 + 32), "didStart")
    || (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) != 0
    || objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      v10 = 45;
      if (isMetaClass)
        v10 = 43;
      v4(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v10, ClassName, Name, 997, v9);

    }
    v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v12 = NFSharedLogGetLogger(v11);
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v14 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v14))
        v15 = 43;
      else
        v15 = 45;
      v16 = object_getClassName(*(id *)(a1 + 32));
      v17 = sel_getName(*(SEL *)(a1 + 56));
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      *(_DWORD *)buf = 67110146;
      v28 = v15;
      v29 = 2082;
      v30 = v16;
      v31 = 2082;
      v32 = v17;
      v33 = 1024;
      v34 = 997;
      v35 = 2114;
      v36 = v18;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

    }
    v19 = *(_QWORD *)(a1 + 48);
    if (v19)
    {
      v20 = objc_alloc((Class)NSError);
      v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v25 = NSLocalizedDescriptionKey;
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
      v26 = v22;
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v26, &v25, 1));
      v24 = objc_msgSend(v20, "initWithDomain:code:userInfo:", v21, 54, v23);
      (*(void (**)(uint64_t, _QWORD, _QWORD, id))(v19 + 16))(v19, 0, 0, v24);

    }
  }
  else
  {
    objc_msgSend(*(id *)(a1 + 32), "_sync_transceive:completion:", *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48));
  }
}

void sub_1001A6630(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *v5;
  _BOOL4 v6;
  const char *v7;
  const char *v8;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  uint64_t v19;
  id v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  uint64_t v26;
  id v27;
  _QWORD *v28;
  unsigned int v29;
  unsigned int v30;
  uint64_t v31;
  id v32;
  uint64_t v33;
  int v34;
  id v35;
  id v36;
  void *v37;
  id v38;
  void *specific;
  uint64_t Logger;
  void (*v41)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v45;
  void *v46;
  uint64_t v47;
  NSObject *v48;
  objc_class *v49;
  int v50;
  const char *v51;
  const char *v52;
  id v53;
  uint64_t v54;
  void *v55;
  void *v56;
  char v57;
  id v58;
  void (*v59)(void);
  const char *Name;
  id v61;
  uint64_t v62[3];
  _QWORD v63[4];
  _QWORD v64[4];
  NSErrorUserInfoKey v65;
  void *v66;
  NSErrorUserInfoKey v67;
  void *v68;
  uint8_t buf[4];
  int v70;
  __int16 v71;
  const char *v72;
  __int16 v73;
  const char *v74;
  __int16 v75;
  int v76;
  __int16 v77;
  void *v78;

  memset(v62, 0, sizeof(v62));
  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v28 = *(_QWORD **)(a1 + 32);
    if (v28[43])
    {
      v29 = objc_msgSend(v28, "_refreshNdefTagConnection");
      if (!v29)
      {
        v54 = *(_QWORD *)(a1 + 32);
        v55 = *(void **)(v54 + 312);
        v56 = *(void **)(v54 + 344);
        v61 = 0;
        v57 = sub_10017F4D4(v55, v56, v62, (uint64_t)&v61);
        v58 = v61;
        v21 = v58;
        if ((v57 & 1) != 0)
        {
          v59 = *(void (**)(void))(*(_QWORD *)(a1 + 40) + 16);
        }
        else
        {
          if (objc_msgSend(v58, "code") == (id)37)
          {

            v21 = 0;
          }
          v59 = *(void (**)(void))(*(_QWORD *)(a1 + 40) + 16);
        }
        v59();
        goto LABEL_17;
      }
      v30 = v29;
      v31 = *(_QWORD *)(a1 + 40);
      v32 = objc_alloc((Class)NSError);
      v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v33 = v30;
      v63[0] = NSLocalizedDescriptionKey;
      if (v30 >= 0x47)
        v34 = 71;
      else
        v34 = v30;
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002EA5E0[v34]));
      v64[0] = v22;
      v64[1] = &off_100300EF0;
      v63[1] = CFSTR("Line");
      v63[2] = CFSTR("Method");
      v35 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 48)));
      v64[2] = v35;
      v63[3] = NSDebugDescriptionErrorKey;
      v36 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 48)), 1020);
      v64[3] = v36;
      v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v64, v63, 4));
      v38 = objc_msgSend(v32, "initWithDomain:code:userInfo:", v21, v33, v37);
      (*(void (**)(uint64_t, _QWORD, _QWORD, id))(v31 + 16))(v31, 0, 0, v38);

LABEL_16:
LABEL_17:

      return;
    }
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v41 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      v45 = 45;
      if (isMetaClass)
        v45 = 43;
      v41(3, "%c[%{public}s %{public}s]:%i Tag not connected", v45, ClassName, Name, 1013);
    }
    v46 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v47 = NFSharedLogGetLogger(v46);
    v48 = objc_claimAutoreleasedReturnValue(v47);
    if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
    {
      v49 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v49))
        v50 = 43;
      else
        v50 = 45;
      v51 = object_getClassName(*(id *)(a1 + 32));
      v52 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)buf = 67109890;
      v70 = v50;
      v71 = 2082;
      v72 = v51;
      v73 = 2082;
      v74 = v52;
      v75 = 1024;
      v76 = 1013;
      _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Tag not connected", buf, 0x22u);
    }

    v19 = *(_QWORD *)(a1 + 40);
    v53 = objc_alloc((Class)NSError);
    v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v65 = NSLocalizedDescriptionKey;
    v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Tag Not Found"));
    v66 = v22;
    v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v66, &v65, 1));
    v24 = v53;
    v25 = v21;
    v26 = 28;
LABEL_15:
    v27 = objc_msgSend(v24, "initWithDomain:code:userInfo:", v25, v26, v23);
    (*(void (**)(uint64_t, _QWORD, _QWORD, id))(v19 + 16))(v19, 0, 0, v27);

    goto LABEL_16;
  }
  v2 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v3 = NFLogGetLogger(v2);
  if (v3)
  {
    v4 = (void (*)(uint64_t, const char *, ...))v3;
    v5 = object_getClass(*(id *)(a1 + 32));
    v6 = class_isMetaClass(v5);
    v7 = object_getClassName(*(id *)(a1 + 32));
    v8 = sel_getName(*(SEL *)(a1 + 48));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v10 = 45;
    if (v6)
      v10 = 43;
    v4(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v10, v7, v8, 1010, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 48));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v70 = v15;
    v71 = 2082;
    v72 = v16;
    v73 = 2082;
    v74 = v17;
    v75 = 1024;
    v76 = 1010;
    v77 = 2114;
    v78 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v19 = *(_QWORD *)(a1 + 40);
  if (v19)
  {
    v20 = objc_alloc((Class)NSError);
    v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v67 = NSLocalizedDescriptionKey;
    v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v68 = v22;
    v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v68, &v67, 1));
    v24 = v20;
    v25 = v21;
    v26 = 54;
    goto LABEL_15;
  }
}

void sub_1001A6D7C(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  void *v10;
  id v11;
  void *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  NSObject *v16;
  objc_class *v17;
  int v18;
  const char *v19;
  const char *v20;
  void *v21;
  void *v22;
  unsigned int v23;
  void *v24;
  void *v25;
  uint64_t v26;
  void (*v27)(uint64_t, const char *, ...);
  objc_class *v28;
  _BOOL4 v29;
  const char *v30;
  const char *v31;
  void *v32;
  uint64_t v33;
  void *v34;
  uint64_t v35;
  NSObject *v36;
  objc_class *v37;
  int v38;
  const char *v39;
  const char *v40;
  void *v41;
  uint64_t v42;
  id v43;
  id v44;
  void *v45;
  void *v46;
  void *v47;
  id v48;
  uint64_t v49;
  id v50;
  uint64_t v51;
  void *v52;
  unsigned int v53;
  unsigned int v54;
  uint64_t v55;
  id v56;
  uint64_t v57;
  int v58;
  id v59;
  id v60;
  void *v61;
  id v62;
  void *v63;
  uint64_t v64;
  void (*v65)(uint64_t, const char *, ...);
  objc_class *v66;
  _BOOL4 v67;
  const char *v68;
  uint64_t v69;
  void *v70;
  uint64_t v71;
  NSObject *v72;
  objc_class *v73;
  int v74;
  const char *v75;
  const char *v76;
  id v77;
  void *v78;
  id v79;
  void *v80;
  id v81;
  id v82;
  void *v83;
  void *v84;
  uint64_t v85;
  void *v86;
  void *v87;
  char v88;
  uint64_t v89;
  void *v90;
  void *v91;
  id v92;
  void *v93;
  id v94;
  id v95;
  void *v96;
  void *v97;
  id v98;
  void *v99;
  uint64_t v100;
  void (*v101)(uint64_t, const char *, ...);
  objc_class *v102;
  _BOOL4 v103;
  uint64_t v104;
  void *v105;
  uint64_t v106;
  NSObject *v107;
  objc_class *v108;
  int v109;
  const char *v110;
  const char *v111;
  void *v112;
  uint64_t v113;
  void (*v114)(uint64_t, const char *, ...);
  objc_class *v115;
  _BOOL4 v116;
  const char *v117;
  uint64_t v118;
  void *v119;
  uint64_t v120;
  NSObject *v121;
  objc_class *v122;
  int v123;
  const char *v124;
  const char *v125;
  uint64_t v126;
  id v127;
  void *v128;
  void *v129;
  void *v130;
  id v131;
  id v132;
  const char *v133;
  const char *v134;
  const char *v135;
  const char *v136;
  id v137;
  id v138;
  uint64_t v139[2];
  uint64_t v140;
  id v141;
  NSErrorUserInfoKey v142;
  void *v143;
  _QWORD v144[4];
  _QWORD v145[4];
  NSErrorUserInfoKey v146;
  void *v147;
  NSErrorUserInfoKey v148;
  void *v149;
  uint8_t buf[4];
  int v151;
  __int16 v152;
  const char *v153;
  __int16 v154;
  const char *v155;
  __int16 v156;
  int v157;
  __int16 v158;
  id v159;
  __int16 v160;
  unsigned int v161;
  __int16 v162;
  void *v163;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "connection"));
    v11 = objc_msgSend(v10, "processIdentifier");
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v13 = 43;
    if (!isMetaClass)
      v13 = 45;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@ (%d) %{public}@", v13, ClassName, Name, 1048, v9, v11, v12);

  }
  v14 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v15 = NFSharedLogGetLogger(v14);
  v16 = objc_claimAutoreleasedReturnValue(v15);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    v17 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v17))
      v18 = 43;
    else
      v18 = 45;
    v19 = object_getClassName(*(id *)(a1 + 32));
    v20 = sel_getName(*(SEL *)(a1 + 48));
    v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "connection"));
    v23 = objc_msgSend(v22, "processIdentifier");
    v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110658;
    v151 = v18;
    v152 = 2082;
    v153 = v19;
    v154 = 2082;
    v155 = v20;
    v156 = 1024;
    v157 = 1048;
    v158 = 2114;
    v159 = v21;
    v160 = 1024;
    v161 = v23;
    v162 = 2114;
    v163 = v24;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@ (%d) %{public}@", buf, 0x3Cu);

  }
  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v51 = *(_QWORD *)(a1 + 32);
    v52 = *(void **)(v51 + 344);
    if (!v52)
    {
      v63 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v64 = NFLogGetLogger(v63);
      if (v64)
      {
        v65 = (void (*)(uint64_t, const char *, ...))v64;
        v66 = object_getClass(*(id *)(a1 + 32));
        v67 = class_isMetaClass(v66);
        v68 = object_getClassName(*(id *)(a1 + 32));
        v134 = sel_getName(*(SEL *)(a1 + 48));
        v69 = 45;
        if (v67)
          v69 = 43;
        v65(3, "%c[%{public}s %{public}s]:%i Tag not connected", v69, v68, v134, 1053);
      }
      v70 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v71 = NFSharedLogGetLogger(v70);
      v72 = objc_claimAutoreleasedReturnValue(v71);
      if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
      {
        v73 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v73))
          v74 = 43;
        else
          v74 = 45;
        v75 = object_getClassName(*(id *)(a1 + 32));
        v76 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)buf = 67109890;
        v151 = v74;
        v152 = 2082;
        v153 = v75;
        v154 = 2082;
        v155 = v76;
        v156 = 1024;
        v157 = 1053;
        _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Tag not connected", buf, 0x22u);
      }

      v42 = *(_QWORD *)(a1 + 40);
      v77 = objc_alloc((Class)NSError);
      v44 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v146 = NSLocalizedDescriptionKey;
      v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Tag Not Found"));
      v147 = v45;
      v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v147, &v146, 1));
      v47 = v77;
      v48 = v44;
      v49 = 28;
      goto LABEL_24;
    }
    if ((*(_BYTE *)(v51 + 353) & 2) == 0)
    {
      v53 = objc_msgSend((id)v51, "_refreshNdefTagConnection");
      if (v53)
      {
        v54 = v53;
        v55 = *(_QWORD *)(a1 + 40);
        v56 = objc_alloc((Class)NSError);
        v44 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v57 = v54;
        v144[0] = NSLocalizedDescriptionKey;
        if (v54 >= 0x47)
          v58 = 71;
        else
          v58 = v54;
        v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002EA5E0[v58]));
        v145[0] = v45;
        v145[1] = &off_100300F08;
        v144[1] = CFSTR("Line");
        v144[2] = CFSTR("Method");
        v59 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 48)));
        v145[2] = v59;
        v144[3] = NSDebugDescriptionErrorKey;
        v60 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 48)), 1074);
        v145[3] = v60;
        v61 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v145, v144, 4));
        v62 = objc_msgSend(v56, "initWithDomain:code:userInfo:", v44, v57, v61);
        (*(void (**)(uint64_t, id, _QWORD))(v55 + 16))(v55, v62, 0);

        goto LABEL_25;
      }
      v139[0] = 0;
      v139[1] = 0;
      v140 = 0;
      v85 = *(_QWORD *)(a1 + 32);
      v86 = *(void **)(v85 + 312);
      v87 = *(void **)(v85 + 344);
      v138 = 0;
      v88 = sub_10017F4D4(v86, v87, v139, (uint64_t)&v138);
      v44 = v138;
      if ((v88 & 1) == 0)
      {
        v99 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v100 = NFLogGetLogger(v99);
        if (v100)
        {
          v101 = (void (*)(uint64_t, const char *, ...))v100;
          v102 = object_getClass(*(id *)(a1 + 32));
          v103 = class_isMetaClass(v102);
          v133 = object_getClassName(*(id *)(a1 + 32));
          v135 = sel_getName(*(SEL *)(a1 + 48));
          v104 = 45;
          if (v103)
            v104 = 43;
          v101(3, "%c[%{public}s %{public}s]:%i Failed to query NDEF capability, %{public}@", v104, v133, v135, 1080, v44);
        }
        v105 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v106 = NFSharedLogGetLogger(v105);
        v107 = objc_claimAutoreleasedReturnValue(v106);
        if (os_log_type_enabled(v107, OS_LOG_TYPE_ERROR))
        {
          v108 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v108))
            v109 = 43;
          else
            v109 = 45;
          v110 = object_getClassName(*(id *)(a1 + 32));
          v111 = sel_getName(*(SEL *)(a1 + 48));
          *(_DWORD *)buf = 67110146;
          v151 = v109;
          v152 = 2082;
          v153 = v110;
          v154 = 2082;
          v155 = v111;
          v156 = 1024;
          v157 = 1080;
          v158 = 2114;
          v159 = v44;
          _os_log_impl((void *)&_mh_execute_header, v107, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to query NDEF capability, %{public}@", buf, 0x2Cu);
        }

        (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
        goto LABEL_26;
      }
      if (!(_BYTE)v140)
      {
        v112 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v113 = NFLogGetLogger(v112);
        if (v113)
        {
          v114 = (void (*)(uint64_t, const char *, ...))v113;
          v115 = object_getClass(*(id *)(a1 + 32));
          v116 = class_isMetaClass(v115);
          v117 = object_getClassName(*(id *)(a1 + 32));
          v136 = sel_getName(*(SEL *)(a1 + 48));
          v118 = 45;
          if (v116)
            v118 = 43;
          v114(3, "%c[%{public}s %{public}s]:%i Tag is not NDEF readable", v118, v117, v136, 1086);
        }
        v119 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v120 = NFSharedLogGetLogger(v119);
        v121 = objc_claimAutoreleasedReturnValue(v120);
        if (os_log_type_enabled(v121, OS_LOG_TYPE_ERROR))
        {
          v122 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v122))
            v123 = 43;
          else
            v123 = 45;
          v124 = object_getClassName(*(id *)(a1 + 32));
          v125 = sel_getName(*(SEL *)(a1 + 48));
          *(_DWORD *)buf = 67109890;
          v151 = v123;
          v152 = 2082;
          v153 = v124;
          v154 = 2082;
          v155 = v125;
          v156 = 1024;
          v157 = 1086;
          _os_log_impl((void *)&_mh_execute_header, v121, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Tag is not NDEF readable", buf, 0x22u);
        }

        v126 = *(_QWORD *)(a1 + 40);
        v127 = objc_alloc((Class)NSError);
        v128 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v142 = NSLocalizedDescriptionKey;
        v129 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Tag Not NDEF formatted"));
        v143 = v129;
        v130 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v143, &v142, 1));
        v131 = objc_msgSend(v127, "initWithDomain:code:userInfo:", v128, 37, v130);
        (*(void (**)(uint64_t, id, _QWORD))(v126 + 16))(v126, v131, 0);

        goto LABEL_26;
      }
      v89 = *(_QWORD *)(a1 + 32);
      v90 = *(void **)(v89 + 312);
      v91 = *(void **)(v89 + 344);
      v137 = v44;
      v92 = sub_100182124(v90, v91, &v137);
      v93 = (void *)objc_claimAutoreleasedReturnValue(v92);
      v94 = v137;

      if (v93)
      {
        v95 = sub_100226308((uint64_t)NFTagReadCALogger);
        v96 = (void *)objc_claimAutoreleasedReturnValue(v95);
        v97 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v93, "asData"));
        sub_10022684C((uint64_t)v96, (uint64_t)objc_msgSend(v97, "length"));

      }
      else
      {
        if (!v94)
        {
LABEL_78:
          (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

          v44 = v94;
          goto LABEL_26;
        }
        v132 = sub_100226308((uint64_t)NFTagReadCALogger);
        v96 = (void *)objc_claimAutoreleasedReturnValue(v132);
        sub_1002269C8((uint64_t)v96, v94);
      }

      goto LABEL_78;
    }
    v78 = *(void **)(v51 + 312);
    v141 = 0;
    v79 = sub_100182124(v78, v52, &v141);
    v80 = (void *)objc_claimAutoreleasedReturnValue(v79);
    v81 = v141;
    v44 = v81;
    if (v80)
    {
      v82 = sub_100226308((uint64_t)NFTagReadCALogger);
      v83 = (void *)objc_claimAutoreleasedReturnValue(v82);
      v84 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v80, "asData"));
      sub_10022684C((uint64_t)v83, (uint64_t)objc_msgSend(v84, "length"));

    }
    else
    {
      if (!v81)
      {
LABEL_54:
        (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

        goto LABEL_26;
      }
      v98 = sub_100226308((uint64_t)NFTagReadCALogger);
      v83 = (void *)objc_claimAutoreleasedReturnValue(v98);
      sub_1002269C8((uint64_t)v83, v44);
    }

    goto LABEL_54;
  }
  v25 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v26 = NFLogGetLogger(v25);
  if (v26)
  {
    v27 = (void (*)(uint64_t, const char *, ...))v26;
    v28 = object_getClass(*(id *)(a1 + 32));
    v29 = class_isMetaClass(v28);
    v30 = object_getClassName(*(id *)(a1 + 32));
    v31 = sel_getName(*(SEL *)(a1 + 48));
    v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v33 = 45;
    if (v29)
      v33 = 43;
    v27(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v33, v30, v31, 1051, v32);

  }
  v34 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v35 = NFSharedLogGetLogger(v34);
  v36 = objc_claimAutoreleasedReturnValue(v35);
  if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
  {
    v37 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v37))
      v38 = 43;
    else
      v38 = 45;
    v39 = object_getClassName(*(id *)(a1 + 32));
    v40 = sel_getName(*(SEL *)(a1 + 48));
    v41 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v151 = v38;
    v152 = 2082;
    v153 = v39;
    v154 = 2082;
    v155 = v40;
    v156 = 1024;
    v157 = 1051;
    v158 = 2114;
    v159 = v41;
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v42 = *(_QWORD *)(a1 + 40);
  if (v42)
  {
    v43 = objc_alloc((Class)NSError);
    v44 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v148 = NSLocalizedDescriptionKey;
    v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v149 = v45;
    v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v149, &v148, 1));
    v47 = v43;
    v48 = v44;
    v49 = 54;
LABEL_24:
    v50 = objc_msgSend(v47, "initWithDomain:code:userInfo:", v48, v49, v46);
    (*(void (**)(uint64_t, id, _QWORD))(v42 + 16))(v42, v50, 0);

LABEL_25:
LABEL_26:

  }
}

void sub_1001A7AA8(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  void *v10;
  id v11;
  void *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  NSObject *v16;
  objc_class *v17;
  int v18;
  const char *v19;
  const char *v20;
  void *v21;
  void *v22;
  unsigned int v23;
  void *v24;
  void *v25;
  uint64_t v26;
  void (*v27)(uint64_t, const char *, ...);
  objc_class *v28;
  _BOOL4 v29;
  const char *v30;
  const char *v31;
  void *v32;
  uint64_t v33;
  void *v34;
  uint64_t v35;
  NSObject *v36;
  objc_class *v37;
  int v38;
  const char *v39;
  const char *v40;
  void *v41;
  uint64_t v42;
  id v43;
  id v44;
  void *v45;
  void *v46;
  void *v47;
  id v48;
  uint64_t v49;
  id v50;
  uint64_t v51;
  unsigned int v52;
  unsigned int v53;
  uint64_t v54;
  id v55;
  uint64_t v56;
  int v57;
  id v58;
  id v59;
  void *v60;
  id v61;
  void *v62;
  uint64_t v63;
  void (*v64)(uint64_t, const char *, ...);
  objc_class *v65;
  _BOOL4 v66;
  const char *v67;
  uint64_t v68;
  void *v69;
  uint64_t v70;
  NSObject *v71;
  objc_class *v72;
  int v73;
  const char *v74;
  const char *v75;
  id v76;
  void *v77;
  uint64_t v78;
  void (*v79)(uint64_t, const char *, ...);
  objc_class *v80;
  _BOOL4 v81;
  const char *v82;
  uint64_t v83;
  void *v84;
  uint64_t v85;
  NSObject *v86;
  objc_class *v87;
  int v88;
  const char *v89;
  const char *v90;
  id v91;
  void *v92;
  void *v93;
  void *v94;
  void *v95;
  uint64_t v96;
  void *v97;
  void *v98;
  char v99;
  void *v100;
  uint64_t v101;
  void *v102;
  void *v103;
  void *v104;
  id v105;
  void *v106;
  uint64_t v107;
  void (*v108)(uint64_t, const char *, ...);
  objc_class *v109;
  _BOOL4 v110;
  uint64_t v111;
  void *v112;
  uint64_t v113;
  NSObject *v114;
  objc_class *v115;
  int v116;
  const char *v117;
  const char *v118;
  void *v119;
  uint64_t v120;
  void (*v121)(uint64_t, const char *, ...);
  objc_class *v122;
  _BOOL4 v123;
  const char *v124;
  uint64_t v125;
  void *v126;
  uint64_t v127;
  NSObject *v128;
  objc_class *v129;
  int v130;
  const char *v131;
  const char *v132;
  uint64_t v133;
  id v134;
  void *v135;
  void *v136;
  void *v137;
  id v138;
  const char *v139;
  const char *v140;
  const char *v141;
  const char *v142;
  const char *v143;
  id v144;
  id v145;
  uint64_t v146[2];
  uint64_t v147;
  void *v148;
  NSErrorUserInfoKey v149;
  void *v150;
  _QWORD v151[4];
  _QWORD v152[4];
  NSErrorUserInfoKey v153;
  void *v154;
  NSErrorUserInfoKey v155;
  void *v156;
  NSErrorUserInfoKey v157;
  void *v158;
  uint8_t buf[4];
  int v160;
  __int16 v161;
  const char *v162;
  __int16 v163;
  const char *v164;
  __int16 v165;
  int v166;
  __int16 v167;
  id v168;
  __int16 v169;
  unsigned int v170;
  __int16 v171;
  void *v172;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "connection"));
    v11 = objc_msgSend(v10, "processIdentifier");
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v13 = 43;
    if (!isMetaClass)
      v13 = 45;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@ (%d) %{public}@", v13, ClassName, Name, 1106, v9, v11, v12);

  }
  v14 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v15 = NFSharedLogGetLogger(v14);
  v16 = objc_claimAutoreleasedReturnValue(v15);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    v17 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v17))
      v18 = 43;
    else
      v18 = 45;
    v19 = object_getClassName(*(id *)(a1 + 32));
    v20 = sel_getName(*(SEL *)(a1 + 56));
    v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "connection"));
    v23 = objc_msgSend(v22, "processIdentifier");
    v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110658;
    v160 = v18;
    v161 = 2082;
    v162 = v19;
    v163 = 2082;
    v164 = v20;
    v165 = 1024;
    v166 = 1106;
    v167 = 2114;
    v168 = v21;
    v169 = 1024;
    v170 = v23;
    v171 = 2114;
    v172 = v24;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@ (%d) %{public}@", buf, 0x3Cu);

  }
  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    if (*(_QWORD *)(*(_QWORD *)(a1 + 32) + 344))
    {
      if ((objc_msgSend(*(id *)(a1 + 40), "conformsToProtocol:", &OBJC_PROTOCOL___NFNdefMessage) & 1) != 0)
      {
        v51 = *(_QWORD *)(a1 + 32);
        if ((*(_BYTE *)(v51 + 353) & 2) != 0)
        {
          v92 = *(void **)(v51 + 312);
          v93 = *(void **)(a1 + 40);
          v94 = *(void **)(v51 + 344);
          v148 = 0;
          if (v92)
          {
            sub_1001821D4(v92, v93, v94, 1, &v148);
            v95 = v148;
          }
          else
          {
            v95 = 0;
          }
          v44 = v95;
        }
        else
        {
          v52 = objc_msgSend(*(id *)(a1 + 32), "_refreshNdefTagConnection");
          if (v52)
          {
            v53 = v52;
            v54 = *(_QWORD *)(a1 + 48);
            v55 = objc_alloc((Class)NSError);
            v44 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
            v56 = v53;
            v151[0] = NSLocalizedDescriptionKey;
            if (v53 >= 0x47)
              v57 = 71;
            else
              v57 = v53;
            v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002EA5E0[v57]));
            v152[0] = v45;
            v152[1] = &off_100300F20;
            v151[1] = CFSTR("Line");
            v151[2] = CFSTR("Method");
            v58 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
            v152[2] = v58;
            v151[3] = NSDebugDescriptionErrorKey;
            v59 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 1131);
            v152[3] = v59;
            v60 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v152, v151, 4));
            v61 = objc_msgSend(v55, "initWithDomain:code:userInfo:", v44, v56, v60);
            (*(void (**)(uint64_t, id))(v54 + 16))(v54, v61);

            goto LABEL_25;
          }
          v146[0] = 0;
          v146[1] = 0;
          v147 = 0;
          v96 = *(_QWORD *)(a1 + 32);
          v97 = *(void **)(v96 + 312);
          v98 = *(void **)(v96 + 344);
          v145 = 0;
          v99 = sub_10017F4D4(v97, v98, v146, (uint64_t)&v145);
          v44 = v145;
          if ((v99 & 1) != 0)
          {
            if (BYTE1(v147))
            {
              v101 = *(_QWORD *)(a1 + 32);
              v100 = *(void **)(a1 + 40);
              v102 = *(void **)(v101 + 312);
              v103 = *(void **)(v101 + 344);
              v144 = v44;
              v104 = v44;
              if (v102)
              {
                sub_1001821D4(v102, v100, v103, 1, &v144);
                v104 = v144;
              }
              v105 = v104;

              (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
              v44 = v105;
            }
            else
            {
              v119 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v120 = NFLogGetLogger(v119);
              if (v120)
              {
                v121 = (void (*)(uint64_t, const char *, ...))v120;
                v122 = object_getClass(*(id *)(a1 + 32));
                v123 = class_isMetaClass(v122);
                v124 = object_getClassName(*(id *)(a1 + 32));
                v143 = sel_getName(*(SEL *)(a1 + 56));
                v125 = 45;
                if (v123)
                  v125 = 43;
                v121(3, "%c[%{public}s %{public}s]:%i Not writable", v125, v124, v143, 1143);
              }
              v126 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v127 = NFSharedLogGetLogger(v126);
              v128 = objc_claimAutoreleasedReturnValue(v127);
              if (os_log_type_enabled(v128, OS_LOG_TYPE_ERROR))
              {
                v129 = object_getClass(*(id *)(a1 + 32));
                if (class_isMetaClass(v129))
                  v130 = 43;
                else
                  v130 = 45;
                v131 = object_getClassName(*(id *)(a1 + 32));
                v132 = sel_getName(*(SEL *)(a1 + 56));
                *(_DWORD *)buf = 67109890;
                v160 = v130;
                v161 = 2082;
                v162 = v131;
                v163 = 2082;
                v164 = v132;
                v165 = 1024;
                v166 = 1143;
                _os_log_impl((void *)&_mh_execute_header, v128, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Not writable", buf, 0x22u);
              }

              v133 = *(_QWORD *)(a1 + 48);
              v134 = objc_alloc((Class)NSError);
              v135 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
              v149 = NSLocalizedDescriptionKey;
              v136 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Tag is Read Only"));
              v150 = v136;
              v137 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v150, &v149, 1));
              v138 = objc_msgSend(v134, "initWithDomain:code:userInfo:", v135, 46, v137);
              (*(void (**)(uint64_t, id))(v133 + 16))(v133, v138);

            }
            goto LABEL_26;
          }
          v106 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v107 = NFLogGetLogger(v106);
          if (v107)
          {
            v108 = (void (*)(uint64_t, const char *, ...))v107;
            v109 = object_getClass(*(id *)(a1 + 32));
            v110 = class_isMetaClass(v109);
            v139 = object_getClassName(*(id *)(a1 + 32));
            v142 = sel_getName(*(SEL *)(a1 + 56));
            v111 = 45;
            if (v110)
              v111 = 43;
            v108(3, "%c[%{public}s %{public}s]:%i Failed to query NDEF capability, %{public}@", v111, v139, v142, 1137, v44);
          }
          v112 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v113 = NFSharedLogGetLogger(v112);
          v114 = objc_claimAutoreleasedReturnValue(v113);
          if (os_log_type_enabled(v114, OS_LOG_TYPE_ERROR))
          {
            v115 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v115))
              v116 = 43;
            else
              v116 = 45;
            v117 = object_getClassName(*(id *)(a1 + 32));
            v118 = sel_getName(*(SEL *)(a1 + 56));
            *(_DWORD *)buf = 67110146;
            v160 = v116;
            v161 = 2082;
            v162 = v117;
            v163 = 2082;
            v164 = v118;
            v165 = 1024;
            v166 = 1137;
            v167 = 2114;
            v168 = v44;
            _os_log_impl((void *)&_mh_execute_header, v114, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to query NDEF capability, %{public}@", buf, 0x2Cu);
          }

        }
        (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
        goto LABEL_26;
      }
      v77 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v78 = NFLogGetLogger(v77);
      if (v78)
      {
        v79 = (void (*)(uint64_t, const char *, ...))v78;
        v80 = object_getClass(*(id *)(a1 + 32));
        v81 = class_isMetaClass(v80);
        v82 = object_getClassName(*(id *)(a1 + 32));
        v141 = sel_getName(*(SEL *)(a1 + 56));
        v83 = 45;
        if (v81)
          v83 = 43;
        v79(3, "%c[%{public}s %{public}s]:%i Invalid parameter", v83, v82, v141, 1118);
      }
      v84 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v85 = NFSharedLogGetLogger(v84);
      v86 = objc_claimAutoreleasedReturnValue(v85);
      if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
      {
        v87 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v87))
          v88 = 43;
        else
          v88 = 45;
        v89 = object_getClassName(*(id *)(a1 + 32));
        v90 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)buf = 67109890;
        v160 = v88;
        v161 = 2082;
        v162 = v89;
        v163 = 2082;
        v164 = v90;
        v165 = 1024;
        v166 = 1118;
        _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid parameter", buf, 0x22u);
      }

      v42 = *(_QWORD *)(a1 + 48);
      v91 = objc_alloc((Class)NSError);
      v44 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v153 = NSLocalizedDescriptionKey;
      v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid Parameter"));
      v154 = v45;
      v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v154, &v153, 1));
      v47 = v91;
      v48 = v44;
      v49 = 10;
    }
    else
    {
      v62 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v63 = NFLogGetLogger(v62);
      if (v63)
      {
        v64 = (void (*)(uint64_t, const char *, ...))v63;
        v65 = object_getClass(*(id *)(a1 + 32));
        v66 = class_isMetaClass(v65);
        v67 = object_getClassName(*(id *)(a1 + 32));
        v140 = sel_getName(*(SEL *)(a1 + 56));
        v68 = 45;
        if (v66)
          v68 = 43;
        v64(3, "%c[%{public}s %{public}s]:%i Tag not connected", v68, v67, v140, 1112);
      }
      v69 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v70 = NFSharedLogGetLogger(v69);
      v71 = objc_claimAutoreleasedReturnValue(v70);
      if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
      {
        v72 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v72))
          v73 = 43;
        else
          v73 = 45;
        v74 = object_getClassName(*(id *)(a1 + 32));
        v75 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)buf = 67109890;
        v160 = v73;
        v161 = 2082;
        v162 = v74;
        v163 = 2082;
        v164 = v75;
        v165 = 1024;
        v166 = 1112;
        _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Tag not connected", buf, 0x22u);
      }

      v42 = *(_QWORD *)(a1 + 48);
      v76 = objc_alloc((Class)NSError);
      v44 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v155 = NSLocalizedDescriptionKey;
      v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Tag Not Found"));
      v156 = v45;
      v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v156, &v155, 1));
      v47 = v76;
      v48 = v44;
      v49 = 28;
    }
LABEL_24:
    v50 = objc_msgSend(v47, "initWithDomain:code:userInfo:", v48, v49, v46);
    (*(void (**)(uint64_t, id))(v42 + 16))(v42, v50);

LABEL_25:
LABEL_26:

    return;
  }
  v25 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v26 = NFLogGetLogger(v25);
  if (v26)
  {
    v27 = (void (*)(uint64_t, const char *, ...))v26;
    v28 = object_getClass(*(id *)(a1 + 32));
    v29 = class_isMetaClass(v28);
    v30 = object_getClassName(*(id *)(a1 + 32));
    v31 = sel_getName(*(SEL *)(a1 + 56));
    v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v33 = 45;
    if (v29)
      v33 = 43;
    v27(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v33, v30, v31, 1109, v32);

  }
  v34 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v35 = NFSharedLogGetLogger(v34);
  v36 = objc_claimAutoreleasedReturnValue(v35);
  if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
  {
    v37 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v37))
      v38 = 43;
    else
      v38 = 45;
    v39 = object_getClassName(*(id *)(a1 + 32));
    v40 = sel_getName(*(SEL *)(a1 + 56));
    v41 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v160 = v38;
    v161 = 2082;
    v162 = v39;
    v163 = 2082;
    v164 = v40;
    v165 = 1024;
    v166 = 1109;
    v167 = 2114;
    v168 = v41;
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v42 = *(_QWORD *)(a1 + 48);
  if (v42)
  {
    v43 = objc_alloc((Class)NSError);
    v44 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v157 = NSLocalizedDescriptionKey;
    v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v158 = v45;
    v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v158, &v157, 1));
    v47 = v43;
    v48 = v44;
    v49 = 54;
    goto LABEL_24;
  }
}

void sub_1001A88A8(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  void *v10;
  id v11;
  void *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  NSObject *v16;
  objc_class *v17;
  int v18;
  const char *v19;
  const char *v20;
  void *v21;
  void *v22;
  unsigned int v23;
  void *v24;
  void *v25;
  uint64_t v26;
  void (*v27)(uint64_t, const char *, ...);
  objc_class *v28;
  _BOOL4 v29;
  const char *v30;
  const char *v31;
  void *v32;
  uint64_t v33;
  void *v34;
  uint64_t v35;
  NSObject *v36;
  objc_class *v37;
  int v38;
  const char *v39;
  const char *v40;
  void *v41;
  uint64_t v42;
  id v43;
  id v44;
  void *v45;
  void *v46;
  void *v47;
  id v48;
  uint64_t v49;
  id v50;
  _QWORD *v51;
  unsigned int v52;
  unsigned int v53;
  uint64_t v54;
  id v55;
  uint64_t v56;
  int v57;
  id v58;
  id v59;
  void *v60;
  id v61;
  void *v62;
  uint64_t v63;
  void (*v64)(uint64_t, const char *, ...);
  objc_class *v65;
  _BOOL4 v66;
  const char *v67;
  uint64_t v68;
  void *v69;
  uint64_t v70;
  NSObject *v71;
  objc_class *v72;
  int v73;
  const char *v74;
  const char *v75;
  id v76;
  void *v77;
  uint64_t v78;
  void *v79;
  void *v80;
  const char *v81;
  id v82;
  _QWORD v83[4];
  _QWORD v84[4];
  NSErrorUserInfoKey v85;
  void *v86;
  NSErrorUserInfoKey v87;
  void *v88;
  uint8_t buf[4];
  int v90;
  __int16 v91;
  const char *v92;
  __int16 v93;
  const char *v94;
  __int16 v95;
  int v96;
  __int16 v97;
  void *v98;
  __int16 v99;
  unsigned int v100;
  __int16 v101;
  void *v102;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "connection"));
    v11 = objc_msgSend(v10, "processIdentifier");
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v13 = 43;
    if (!isMetaClass)
      v13 = 45;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@ (%d) %{public}@", v13, ClassName, Name, 1155, v9, v11, v12);

  }
  v14 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v15 = NFSharedLogGetLogger(v14);
  v16 = objc_claimAutoreleasedReturnValue(v15);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    v17 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v17))
      v18 = 43;
    else
      v18 = 45;
    v19 = object_getClassName(*(id *)(a1 + 32));
    v20 = sel_getName(*(SEL *)(a1 + 56));
    v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "connection"));
    v23 = objc_msgSend(v22, "processIdentifier");
    v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110658;
    v90 = v18;
    v91 = 2082;
    v92 = v19;
    v93 = 2082;
    v94 = v20;
    v95 = 1024;
    v96 = 1155;
    v97 = 2114;
    v98 = v21;
    v99 = 1024;
    v100 = v23;
    v101 = 2114;
    v102 = v24;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@ (%d) %{public}@", buf, 0x3Cu);

  }
  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v51 = *(_QWORD **)(a1 + 32);
    if (v51[43])
    {
      v52 = objc_msgSend(v51, "_refreshNdefTagConnection");
      if (!v52)
      {
        v78 = *(_QWORD *)(a1 + 32);
        v77 = *(void **)(a1 + 40);
        v79 = *(void **)(v78 + 312);
        v80 = *(void **)(v78 + 344);
        v82 = 0;
        sub_100183BA0(v79, v80, v77, &v82);
        v44 = v82;
        (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
        goto LABEL_26;
      }
      v53 = v52;
      v54 = *(_QWORD *)(a1 + 48);
      v55 = objc_alloc((Class)NSError);
      v44 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v56 = v53;
      v83[0] = NSLocalizedDescriptionKey;
      if (v53 >= 0x47)
        v57 = 71;
      else
        v57 = v53;
      v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002EA5E0[v57]));
      v84[0] = v45;
      v84[1] = &off_100300F38;
      v83[1] = CFSTR("Line");
      v83[2] = CFSTR("Method");
      v58 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
      v84[2] = v58;
      v83[3] = NSDebugDescriptionErrorKey;
      v59 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 1167);
      v84[3] = v59;
      v60 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v84, v83, 4));
      v61 = objc_msgSend(v55, "initWithDomain:code:userInfo:", v44, v56, v60);
      (*(void (**)(uint64_t, id))(v54 + 16))(v54, v61);

LABEL_25:
LABEL_26:

      return;
    }
    v62 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v63 = NFLogGetLogger(v62);
    if (v63)
    {
      v64 = (void (*)(uint64_t, const char *, ...))v63;
      v65 = object_getClass(*(id *)(a1 + 32));
      v66 = class_isMetaClass(v65);
      v67 = object_getClassName(*(id *)(a1 + 32));
      v81 = sel_getName(*(SEL *)(a1 + 56));
      v68 = 45;
      if (v66)
        v68 = 43;
      v64(3, "%c[%{public}s %{public}s]:%i Invalid tag state", v68, v67, v81, 1160);
    }
    v69 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v70 = NFSharedLogGetLogger(v69);
    v71 = objc_claimAutoreleasedReturnValue(v70);
    if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
    {
      v72 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v72))
        v73 = 43;
      else
        v73 = 45;
      v74 = object_getClassName(*(id *)(a1 + 32));
      v75 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)buf = 67109890;
      v90 = v73;
      v91 = 2082;
      v92 = v74;
      v93 = 2082;
      v94 = v75;
      v95 = 1024;
      v96 = 1160;
      _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid tag state", buf, 0x22u);
    }

    v42 = *(_QWORD *)(a1 + 48);
    v76 = objc_alloc((Class)NSError);
    v44 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v85 = NSLocalizedDescriptionKey;
    v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid State"));
    v86 = v45;
    v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v86, &v85, 1));
    v47 = v76;
    v48 = v44;
    v49 = 12;
LABEL_24:
    v50 = objc_msgSend(v47, "initWithDomain:code:userInfo:", v48, v49, v46);
    (*(void (**)(uint64_t, id))(v42 + 16))(v42, v50);

    goto LABEL_25;
  }
  v25 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v26 = NFLogGetLogger(v25);
  if (v26)
  {
    v27 = (void (*)(uint64_t, const char *, ...))v26;
    v28 = object_getClass(*(id *)(a1 + 32));
    v29 = class_isMetaClass(v28);
    v30 = object_getClassName(*(id *)(a1 + 32));
    v31 = sel_getName(*(SEL *)(a1 + 56));
    v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v33 = 45;
    if (v29)
      v33 = 43;
    v27(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v33, v30, v31, 1157, v32);

  }
  v34 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v35 = NFSharedLogGetLogger(v34);
  v36 = objc_claimAutoreleasedReturnValue(v35);
  if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
  {
    v37 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v37))
      v38 = 43;
    else
      v38 = 45;
    v39 = object_getClassName(*(id *)(a1 + 32));
    v40 = sel_getName(*(SEL *)(a1 + 56));
    v41 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v90 = v38;
    v91 = 2082;
    v92 = v39;
    v93 = 2082;
    v94 = v40;
    v95 = 1024;
    v96 = 1157;
    v97 = 2114;
    v98 = v41;
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v42 = *(_QWORD *)(a1 + 48);
  if (v42)
  {
    v43 = objc_alloc((Class)NSError);
    v44 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v87 = NSLocalizedDescriptionKey;
    v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v88 = v45;
    v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v88, &v87, 1));
    v47 = v43;
    v48 = v44;
    v49 = 54;
    goto LABEL_24;
  }
}

void sub_1001A9124(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  void *v10;
  id v11;
  void *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  NSObject *v16;
  objc_class *v17;
  int v18;
  const char *v19;
  const char *v20;
  char *v21;
  void *v22;
  unsigned int v23;
  void *v24;
  void *v25;
  uint64_t v26;
  void (*v27)(uint64_t, const char *, ...);
  objc_class *v28;
  _BOOL4 v29;
  const char *v30;
  const char *v31;
  void *v32;
  uint64_t v33;
  void *v34;
  uint64_t v35;
  NSObject *v36;
  objc_class *v37;
  int v38;
  const char *v39;
  const char *v40;
  char *v41;
  uint64_t v42;
  id v43;
  void *v44;
  void *v45;
  void *v46;
  id v47;
  uint64_t v48;
  void *v49;
  unsigned int v50;
  unsigned int v51;
  void *v52;
  uint64_t v53;
  void (*v54)(uint64_t, const char *, ...);
  objc_class *v55;
  _BOOL4 v56;
  const char *v57;
  const char *v58;
  const char *v59;
  uint64_t v60;
  void *v61;
  uint64_t v62;
  NSObject *v63;
  objc_class *v64;
  int v65;
  const char *v66;
  const char *v67;
  const char *v68;
  id v69;
  void *v70;
  id v71;
  void *v72;
  uint64_t v73;
  int v74;
  char *v75;
  void *v76;
  void *v77;
  id v78;
  uint64_t v79;
  id v80;
  void *v81;
  void *v82;
  void *v83;
  id v84;
  void *v85;
  uint64_t v86;
  void (*v87)(uint64_t, const char *, ...);
  objc_class *v88;
  _BOOL4 v89;
  const char *v90;
  uint64_t v91;
  void *v92;
  uint64_t v93;
  NSObject *v94;
  objc_class *v95;
  int v96;
  const char *v97;
  const char *v98;
  uint64_t v99;
  id v100;
  void *v101;
  void *v102;
  void *v103;
  id v104;
  const char *v105;
  NSErrorUserInfoKey v106;
  void *v107;
  NSErrorUserInfoKey v108;
  void *v109;
  NSErrorUserInfoKey v110;
  void *v111;
  NSErrorUserInfoKey v112;
  void *v113;
  uint8_t buf[4];
  int v115;
  __int16 v116;
  const char *v117;
  __int16 v118;
  const char *v119;
  __int16 v120;
  int v121;
  __int16 v122;
  const char *v123;
  __int16 v124;
  unsigned int v125;
  __int16 v126;
  void *v127;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "connection"));
    v11 = objc_msgSend(v10, "processIdentifier");
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v13 = 43;
    if (!isMetaClass)
      v13 = 45;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@ (%d) %{public}@", v13, ClassName, Name, 1181, v9, v11, v12);

  }
  v14 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v15 = NFSharedLogGetLogger(v14);
  v16 = objc_claimAutoreleasedReturnValue(v15);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    v17 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v17))
      v18 = 43;
    else
      v18 = 45;
    v19 = object_getClassName(*(id *)(a1 + 32));
    v20 = sel_getName(*(SEL *)(a1 + 48));
    v21 = (char *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "connection"));
    v23 = objc_msgSend(v22, "processIdentifier");
    v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110658;
    v115 = v18;
    v116 = 2082;
    v117 = v19;
    v118 = 2082;
    v119 = v20;
    v120 = 1024;
    v121 = 1181;
    v122 = 2114;
    v123 = v21;
    v124 = 1024;
    v125 = v23;
    v126 = 2114;
    v127 = v24;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@ (%d) %{public}@", buf, 0x3Cu);

  }
  if (!objc_msgSend(*(id *)(a1 + 32), "didStart")
    || (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) != 0
    || objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v25 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v26 = NFLogGetLogger(v25);
    if (v26)
    {
      v27 = (void (*)(uint64_t, const char *, ...))v26;
      v28 = object_getClass(*(id *)(a1 + 32));
      v29 = class_isMetaClass(v28);
      v30 = object_getClassName(*(id *)(a1 + 32));
      v31 = sel_getName(*(SEL *)(a1 + 48));
      v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      v33 = 45;
      if (v29)
        v33 = 43;
      v27(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v33, v30, v31, 1183, v32);

    }
    v34 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v35 = NFSharedLogGetLogger(v34);
    v36 = objc_claimAutoreleasedReturnValue(v35);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
    {
      v37 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v37))
        v38 = 43;
      else
        v38 = 45;
      v39 = object_getClassName(*(id *)(a1 + 32));
      v40 = sel_getName(*(SEL *)(a1 + 48));
      v41 = (char *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      *(_DWORD *)buf = 67110146;
      v115 = v38;
      v116 = 2082;
      v117 = v39;
      v118 = 2082;
      v119 = v40;
      v120 = 1024;
      v121 = 1183;
      v122 = 2114;
      v123 = v41;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

    }
    v42 = *(_QWORD *)(a1 + 40);
    if (v42)
    {
      v43 = objc_alloc((Class)NSError);
      v44 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v112 = NSLocalizedDescriptionKey;
      v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
      v113 = v45;
      v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v113, &v112, 1));
      v47 = objc_msgSend(v43, "initWithDomain:code:userInfo:", v44, 54, v46);
      (*(void (**)(uint64_t, id, _QWORD))(v42 + 16))(v42, v47, 0);

    }
  }
  else
  {
    v48 = *(_QWORD *)(a1 + 32);
    v49 = *(void **)(v48 + 344);
    if (v49)
    {
      v50 = sub_100183AC0(*(void **)(v48 + 312), v49);
      if (v50)
      {
        v51 = v50;
        v52 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v53 = NFLogGetLogger(v52);
        if (v53)
        {
          v54 = (void (*)(uint64_t, const char *, ...))v53;
          v55 = object_getClass(*(id *)(a1 + 32));
          v56 = class_isMetaClass(v55);
          v57 = object_getClassName(*(id *)(a1 + 32));
          v58 = sel_getName(*(SEL *)(a1 + 48));
          if (v51 == 28)
            v59 = "NFResultTagNotFound";
          else
            v59 = "NFResultRFDeactivated";
          v60 = 45;
          if (v56)
            v60 = 43;
          v54(3, "%c[%{public}s %{public}s]:%i checkTagPresence return error: %s", v60, v57, v58, 1195, v59);
        }
        v61 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v62 = NFSharedLogGetLogger(v61);
        v63 = objc_claimAutoreleasedReturnValue(v62);
        if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
        {
          v64 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v64))
            v65 = 43;
          else
            v65 = 45;
          v66 = object_getClassName(*(id *)(a1 + 32));
          v67 = sel_getName(*(SEL *)(a1 + 48));
          *(_DWORD *)buf = 67110146;
          if (v51 == 28)
            v68 = "NFResultTagNotFound";
          else
            v68 = "NFResultRFDeactivated";
          v115 = v65;
          v116 = 2082;
          v117 = v66;
          v118 = 2082;
          v119 = v67;
          v120 = 1024;
          v121 = 1195;
          v122 = 2080;
          v123 = v68;
          _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i checkTagPresence return error: %s", buf, 0x2Cu);
        }

        v69 = sub_100226308((uint64_t)NFTagReadCALogger);
        v70 = (void *)objc_claimAutoreleasedReturnValue(v69);
        v71 = objc_alloc((Class)NSError);
        v72 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v73 = v51;
        v108 = NSLocalizedDescriptionKey;
        if (v51 >= 0x47)
          v74 = 71;
        else
          v74 = v51;
        v75 = off_1002EA5E0[v74];
        v76 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v75));
        v109 = v76;
        v77 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v109, &v108, 1));
        v78 = objc_msgSend(v71, "initWithDomain:code:userInfo:", v72, v73, v77);
        sub_1002269C8((uint64_t)v70, v78);

        v79 = *(_QWORD *)(a1 + 40);
        v80 = objc_alloc((Class)NSError);
        v81 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v106 = NSLocalizedDescriptionKey;
        v82 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v75));
        v107 = v82;
        v83 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v107, &v106, 1));
        v84 = objc_msgSend(v80, "initWithDomain:code:userInfo:", v81, v73, v83);
        (*(void (**)(uint64_t, id, _QWORD))(v79 + 16))(v79, v84, 0);

      }
      else
      {
        (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
      }
    }
    else
    {
      v85 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v86 = NFLogGetLogger(v85);
      if (v86)
      {
        v87 = (void (*)(uint64_t, const char *, ...))v86;
        v88 = object_getClass(*(id *)(a1 + 32));
        v89 = class_isMetaClass(v88);
        v90 = object_getClassName(*(id *)(a1 + 32));
        v105 = sel_getName(*(SEL *)(a1 + 48));
        v91 = 45;
        if (v89)
          v91 = 43;
        v87(3, "%c[%{public}s %{public}s]:%i Invalid tag state", v91, v90, v105, 1186);
      }
      v92 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v93 = NFSharedLogGetLogger(v92);
      v94 = objc_claimAutoreleasedReturnValue(v93);
      if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
      {
        v95 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v95))
          v96 = 43;
        else
          v96 = 45;
        v97 = object_getClassName(*(id *)(a1 + 32));
        v98 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)buf = 67109890;
        v115 = v96;
        v116 = 2082;
        v117 = v97;
        v118 = 2082;
        v119 = v98;
        v120 = 1024;
        v121 = 1186;
        _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid tag state", buf, 0x22u);
      }

      v99 = *(_QWORD *)(a1 + 40);
      v100 = objc_alloc((Class)NSError);
      v101 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v110 = NSLocalizedDescriptionKey;
      v102 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid State"));
      v111 = v102;
      v103 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v111, &v110, 1));
      v104 = objc_msgSend(v100, "initWithDomain:code:userInfo:", v101, 12, v103);
      (*(void (**)(uint64_t, id, _QWORD))(v99 + 16))(v99, v104, 0);

    }
  }
}

id sub_1001AAE8C(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  NSObject *v11;
  objc_class *v12;
  int v13;
  const char *v14;
  const char *v15;
  id v16;
  void *v17;
  void *v18;
  void *v19;
  id v20;
  id WeakRetained;
  void *v22;
  void *v23;
  id v24;
  void *v25;
  void *v26;
  uint64_t v27;
  void (*v28)(uint64_t, const char *, ...);
  objc_class *v29;
  _BOOL4 v30;
  const char *v31;
  const char *v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  NSObject *v36;
  objc_class *v37;
  int v38;
  const char *v39;
  const char *v40;
  void *v41;
  uint64_t v42;
  uint64_t v43;
  NSObject *v44;
  unsigned int v45;
  uint64_t v46;
  id v47;
  const char *Name;
  uint8_t buf[4];
  _BYTE v51[24];
  __int16 v52;
  int v53;
  __int16 v54;
  void *v55;
  NSErrorUserInfoKey v56;
  void *v57;

  if ((objc_msgSend(*(id *)(a1 + 32), "didEnd") & 1) != 0
    || objc_msgSend(*(id *)(a1 + 32), "isSuspended"))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 40));
      v8 = 45;
      if (isMetaClass)
        v8 = 43;
      v4(3, "%c[%{public}s %{public}s]:%i Session has been terminated / suspended", v8, ClassName, Name, 1335);
    }
    v9 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v10 = NFSharedLogGetLogger(v9);
    v11 = objc_claimAutoreleasedReturnValue(v10);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v12 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v12))
        v13 = 43;
      else
        v13 = 45;
      v14 = object_getClassName(*(id *)(a1 + 32));
      v15 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)v51 = v13;
      *(_WORD *)&v51[4] = 2082;
      *(_QWORD *)&v51[6] = v14;
      *(_WORD *)&v51[14] = 2082;
      *(_QWORD *)&v51[16] = v15;
      v52 = 1024;
      v53 = 1335;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session has been terminated / suspended", buf, 0x22u);
    }

    v16 = objc_alloc((Class)NSError);
    v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v56 = NSLocalizedDescriptionKey;
    v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid State"));
    v57 = v18;
    v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v57, &v56, 1));
    v20 = objc_msgSend(v16, "initWithDomain:code:userInfo:", v17, 12, v19);

  }
  else
  {
    WeakRetained = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 320));
    sub_10019E124((uint64_t)WeakRetained, *(void **)(a1 + 32));

    v22 = (void *)objc_claimAutoreleasedReturnValue(+[_NFHardwareManager sharedHardwareManager](_NFHardwareManager, "sharedHardwareManager"));
    objc_msgSend(v22, "notifyReaderModeActivityEnd");

    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 208) = *(_QWORD *)(a1 + 48);
    if ((*(_BYTE *)(a1 + 57) & 8) != 0)
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig readerWithLPCD:fieldDetect:pollDuration:ecp:](NFRoutingConfig, "readerWithLPCD:fieldDetect:pollDuration:ecp:", 1, 2, 0, 0));
    else
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig readerModeWithFD:](NFRoutingConfig, "readerModeWithFD:", 2));
    v17 = v23;
    objc_msgSend(v23, "setPollingMask:tagConfig:", *(unsigned int *)(*(_QWORD *)(a1 + 32) + 280), objc_msgSend(*(id *)(a1 + 32), "_getTagNotificationConfig"));
    if (*(_BYTE *)(a1 + 64))
    {
      v51[0] = 2;
      *(_DWORD *)buf = 4194666;
      v24 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", buf, 5);
      v25 = (void *)objc_claimAutoreleasedReturnValue(+[_NFHardwareManager sharedHardwareManager](_NFHardwareManager, "sharedHardwareManager"));
      objc_msgSend(v25, "configureECPPolling:", v24);

    }
    v26 = (void *)objc_claimAutoreleasedReturnValue(+[_NFHardwareManager sharedHardwareManager](_NFHardwareManager, "sharedHardwareManager"));
    v20 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v26, "setRoutingConfig:", v17));

    if (!v20)
    {
      v27 = NFLogGetLogger(2);
      if (v27)
      {
        v28 = (void (*)(uint64_t, const char *, ...))v27;
        v29 = object_getClass(*(id *)(a1 + 32));
        v30 = class_isMetaClass(v29);
        v31 = object_getClassName(*(id *)(a1 + 32));
        v32 = sel_getName(*(SEL *)(a1 + 40));
        v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
        v34 = 45;
        if (v30)
          v34 = 43;
        v28(6, "%c[%{public}s %{public}s]:%i NFC Reader mode activated: %@", v34, v31, v32, 1362, v33);

      }
      v35 = NFSharedLogGetLogger(2);
      v36 = objc_claimAutoreleasedReturnValue(v35);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
      {
        v37 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v37))
          v38 = 43;
        else
          v38 = 45;
        v39 = object_getClassName(*(id *)(a1 + 32));
        v40 = sel_getName(*(SEL *)(a1 + 40));
        v41 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
        *(_DWORD *)buf = 67110146;
        *(_DWORD *)v51 = v38;
        *(_WORD *)&v51[4] = 2082;
        *(_QWORD *)&v51[6] = v39;
        *(_WORD *)&v51[14] = 2082;
        *(_QWORD *)&v51[16] = v40;
        v52 = 1024;
        v53 = 1362;
        v54 = 2112;
        v55 = v41;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i NFC Reader mode activated: %@", buf, 0x2Cu);

      }
      v43 = NFSharedSignpostLog(v42);
      v44 = objc_claimAutoreleasedReturnValue(v43);
      if (os_signpost_enabled(v44))
      {
        v45 = objc_msgSend(*(id *)(a1 + 32), "_isCoreNFCSession");
        v46 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 360);
        *(_DWORD *)buf = 134349312;
        *(_QWORD *)v51 = v45;
        *(_WORD *)&v51[8] = 2050;
        *(_QWORD *)&v51[10] = v46;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v44, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "Polling", " coreNFC=%{public,signpost.description:attribute}lu  sessionType=%{public,signpost.description:attribute}lu ", buf, 0x16u);
      }

    }
    v47 = sub_100226308((uint64_t)NFTagReadCALogger);
    v18 = (void *)objc_claimAutoreleasedReturnValue(v47);
    sub_100226F44((uint64_t)v18, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 208));
  }

  return v20;
}

void sub_1001AB3F4(uint64_t a1, void *a2)
{
  id v3;
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  objc_class *v13;
  int v14;
  const char *v15;
  const char *v16;
  uint64_t v17;
  id v18;
  void *v19;
  void *v20;
  void *v21;
  id v22;
  uint64_t v23;
  uint64_t v24;
  const char *ClassName;
  const char *Name;
  NSErrorUserInfoKey v27;
  void *v28;
  uint8_t buf[4];
  int v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  int v36;
  __int16 v37;
  id v38;

  v3 = a2;
  if (v3)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      v9 = 45;
      if (isMetaClass)
        v9 = 43;
      v6(6, "%c[%{public}s %{public}s]:%i Not ready: %{public}@", v9, ClassName, Name, 1379, v3);
    }
    v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v11 = NFSharedLogGetLogger(v10);
    v12 = objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      v13 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v13))
        v14 = 43;
      else
        v14 = 45;
      v15 = object_getClassName(*(id *)(a1 + 32));
      v16 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)buf = 67110146;
      v30 = v14;
      v31 = 2082;
      v32 = v15;
      v33 = 2082;
      v34 = v16;
      v35 = 1024;
      v36 = 1379;
      v37 = 2114;
      v38 = v3;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Not ready: %{public}@", buf, 0x2Cu);
    }

    v17 = *(_QWORD *)(a1 + 40);
    v18 = objc_alloc((Class)NSError);
    v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v27 = NSLocalizedDescriptionKey;
    v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Busy"));
    v28 = v20;
    v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v28, &v27, 1));
    v22 = objc_msgSend(v18, "initWithDomain:code:userInfo:", v19, 2, v21);
    (*(void (**)(uint64_t, id))(v17 + 16))(v17, v22);

  }
  else
  {
    v23 = *(_QWORD *)(a1 + 40);
    v24 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
    v19 = (void *)objc_claimAutoreleasedReturnValue(v24);
    (*(void (**)(uint64_t, void *))(v23 + 16))(v23, v19);
  }

}

void sub_1001ABA78(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  uint64_t v19;
  id v20;
  void *v21;
  void *v22;
  void *v23;
  id v24;
  NSErrorUserInfoKey v25;
  void *v26;
  uint8_t buf[4];
  int v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  void *v36;

  if (!objc_msgSend(*(id *)(a1 + 32), "didStart")
    || (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) != 0
    || objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      v10 = 45;
      if (isMetaClass)
        v10 = 43;
      v4(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v10, ClassName, Name, 1415, v9);

    }
    v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v12 = NFSharedLogGetLogger(v11);
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v14 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v14))
        v15 = 43;
      else
        v15 = 45;
      v16 = object_getClassName(*(id *)(a1 + 32));
      v17 = sel_getName(*(SEL *)(a1 + 56));
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      *(_DWORD *)buf = 67110146;
      v28 = v15;
      v29 = 2082;
      v30 = v16;
      v31 = 2082;
      v32 = v17;
      v33 = 1024;
      v34 = 1415;
      v35 = 2114;
      v36 = v18;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

    }
    v19 = *(_QWORD *)(a1 + 48);
    if (v19)
    {
      v20 = objc_alloc((Class)NSError);
      v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v25 = NSLocalizedDescriptionKey;
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
      v26 = v22;
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v26, &v25, 1));
      v24 = objc_msgSend(v20, "initWithDomain:code:userInfo:", v21, 54, v23);
      (*(void (**)(uint64_t, id))(v19 + 16))(v19, v24);

    }
  }
  else
  {
    objc_msgSend(*(id *)(a1 + 32), "_sync_setECPPayload:completion:", *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48));
  }
}

void sub_1001ABE80(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  uint64_t v19;
  id v20;
  void *v21;
  void *v22;
  void *v23;
  id v24;
  NSErrorUserInfoKey v25;
  void *v26;
  uint8_t buf[4];
  int v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  void *v36;

  if (!objc_msgSend(*(id *)(a1 + 32), "didStart")
    || (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) != 0
    || objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      v10 = 45;
      if (isMetaClass)
        v10 = 43;
      v4(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v10, ClassName, Name, 1445, v9);

    }
    v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v12 = NFSharedLogGetLogger(v11);
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v14 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v14))
        v15 = 43;
      else
        v15 = 45;
      v16 = object_getClassName(*(id *)(a1 + 32));
      v17 = sel_getName(*(SEL *)(a1 + 48));
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      *(_DWORD *)buf = 67110146;
      v28 = v15;
      v29 = 2082;
      v30 = v16;
      v31 = 2082;
      v32 = v17;
      v33 = 1024;
      v34 = 1445;
      v35 = 2114;
      v36 = v18;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

    }
    v19 = *(_QWORD *)(a1 + 40);
    if (v19)
    {
      v20 = objc_alloc((Class)NSError);
      v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v25 = NSLocalizedDescriptionKey;
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
      v26 = v22;
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v26, &v25, 1));
      v24 = objc_msgSend(v20, "initWithDomain:code:userInfo:", v21, 54, v23);
      (*(void (**)(uint64_t, id))(v19 + 16))(v19, v24);

    }
  }
  else
  {
    objc_msgSend(*(id *)(a1 + 32), "_sync_startPollingForTags:sessionConfig:completion:", *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 40));
  }
}

void sub_1001AC20C(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  NSObject *v11;
  objc_class *v12;
  int v13;
  const char *v14;
  const char *v15;
  void *v16;
  uint64_t v17;
  void (*v18)(uint64_t, const char *, ...);
  objc_class *v19;
  _BOOL4 v20;
  const char *v21;
  const char *v22;
  void *v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  NSObject *v27;
  objc_class *v28;
  int v29;
  const char *v30;
  const char *v31;
  void *v32;
  uint64_t v33;
  id v34;
  void *v35;
  void *v36;
  void *v37;
  id v38;
  const char *Name;
  NSErrorUserInfoKey v40;
  void *v41;
  uint8_t buf[4];
  int v43;
  __int16 v44;
  const char *v45;
  __int16 v46;
  const char *v47;
  __int16 v48;
  int v49;
  __int16 v50;
  void *v51;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v8 = 45;
    if (isMetaClass)
      v8 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i ", v8, ClassName, Name, 1454);
  }
  v9 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v10 = NFSharedLogGetLogger(v9);
  v11 = objc_claimAutoreleasedReturnValue(v10);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v12 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v12))
      v13 = 43;
    else
      v13 = 45;
    v14 = object_getClassName(*(id *)(a1 + 32));
    v15 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)buf = 67109890;
    v43 = v13;
    v44 = 2082;
    v45 = v14;
    v46 = 2082;
    v47 = v15;
    v48 = 1024;
    v49 = 1454;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
  }

  if (!objc_msgSend(*(id *)(a1 + 32), "didStart")
    || (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) != 0
    || objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v16 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v17 = NFLogGetLogger(v16);
    if (v17)
    {
      v18 = (void (*)(uint64_t, const char *, ...))v17;
      v19 = object_getClass(*(id *)(a1 + 32));
      v20 = class_isMetaClass(v19);
      v21 = object_getClassName(*(id *)(a1 + 32));
      v22 = sel_getName(*(SEL *)(a1 + 48));
      v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      v24 = 45;
      if (v20)
        v24 = 43;
      v18(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v24, v21, v22, 1455, v23);

    }
    v25 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v26 = NFSharedLogGetLogger(v25);
    v27 = objc_claimAutoreleasedReturnValue(v26);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      v28 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v28))
        v29 = 43;
      else
        v29 = 45;
      v30 = object_getClassName(*(id *)(a1 + 32));
      v31 = sel_getName(*(SEL *)(a1 + 48));
      v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      *(_DWORD *)buf = 67110146;
      v43 = v29;
      v44 = 2082;
      v45 = v30;
      v46 = 2082;
      v47 = v31;
      v48 = 1024;
      v49 = 1455;
      v50 = 2114;
      v51 = v32;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

    }
    v33 = *(_QWORD *)(a1 + 40);
    if (v33)
    {
      v34 = objc_alloc((Class)NSError);
      v35 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v40 = NSLocalizedDescriptionKey;
      v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
      v41 = v36;
      v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v41, &v40, 1));
      v38 = objc_msgSend(v34, "initWithDomain:code:userInfo:", v35, 54, v37);
      (*(void (**)(uint64_t, id))(v33 + 16))(v33, v38);

    }
  }
  else
  {
    *(_BYTE *)(*(_QWORD *)(a1 + 32) + 306) = 1;
    (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
  }
}

void sub_1001AC6BC(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  uint64_t v19;
  id v20;
  void *v21;
  void *v22;
  void *v23;
  id v24;
  NSErrorUserInfoKey v25;
  void *v26;
  uint8_t buf[4];
  int v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  void *v36;

  if (!objc_msgSend(*(id *)(a1 + 32), "didStart")
    || (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) != 0
    || objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      v10 = 45;
      if (isMetaClass)
        v10 = 43;
      v4(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v10, ClassName, Name, 1466, v9);

    }
    v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v12 = NFSharedLogGetLogger(v11);
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v14 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v14))
        v15 = 43;
      else
        v15 = 45;
      v16 = object_getClassName(*(id *)(a1 + 32));
      v17 = sel_getName(*(SEL *)(a1 + 56));
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      *(_DWORD *)buf = 67110146;
      v28 = v15;
      v29 = 2082;
      v30 = v16;
      v31 = 2082;
      v32 = v17;
      v33 = 1024;
      v34 = 1466;
      v35 = 2114;
      v36 = v18;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

    }
    v19 = *(_QWORD *)(a1 + 48);
    if (v19)
    {
      v20 = objc_alloc((Class)NSError);
      v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v25 = NSLocalizedDescriptionKey;
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
      v26 = v22;
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v26, &v25, 1));
      v24 = objc_msgSend(v20, "initWithDomain:code:userInfo:", v21, 54, v23);
      (*(void (**)(uint64_t, id))(v19 + 16))(v19, v24);

    }
  }
  else
  {
    objc_msgSend(*(id *)(a1 + 32), "_sync_startPollingWithConfig:completion:", *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48));
  }
}

id sub_1001ADAA8(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  NSObject *v11;
  objc_class *v12;
  int v13;
  const char *v14;
  const char *v15;
  id v16;
  void *v17;
  NSObject *v18;
  void *v19;
  id v20;
  void *v22;
  id v23;
  uint64_t v24;
  void *v25;
  id v26;
  void *v27;
  uint64_t v28;
  void (*v29)(uint64_t, const char *, ...);
  objc_class *v30;
  _BOOL4 v31;
  const char *v32;
  const char *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  NSObject *v37;
  objc_class *v38;
  int v39;
  const char *v40;
  const char *v41;
  void *v42;
  uint64_t v43;
  uint64_t v44;
  unsigned int v45;
  uint64_t v46;
  const char *Name;
  uint8_t buf[4];
  _BYTE v49[24];
  __int16 v50;
  int v51;
  __int16 v52;
  void *v53;
  NSErrorUserInfoKey v54;
  NSObject *v55;

  if ((objc_msgSend(*(id *)(a1 + 32), "didEnd") & 1) != 0
    || objc_msgSend(*(id *)(a1 + 32), "isSuspended"))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 64));
      v8 = 45;
      if (isMetaClass)
        v8 = 43;
      v4(3, "%c[%{public}s %{public}s]:%i Session has been terminated / suspended", v8, ClassName, Name, 1562);
    }
    v9 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v10 = NFSharedLogGetLogger(v9);
    v11 = objc_claimAutoreleasedReturnValue(v10);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v12 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v12))
        v13 = 43;
      else
        v13 = 45;
      v14 = object_getClassName(*(id *)(a1 + 32));
      v15 = sel_getName(*(SEL *)(a1 + 64));
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)v49 = v13;
      *(_WORD *)&v49[4] = 2082;
      *(_QWORD *)&v49[6] = v14;
      *(_WORD *)&v49[14] = 2082;
      *(_QWORD *)&v49[16] = v15;
      v50 = 1024;
      v51 = 1562;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session has been terminated / suspended", buf, 0x22u);
    }

    v16 = objc_alloc((Class)NSError);
    v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v54 = NSLocalizedDescriptionKey;
    v18 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid State"));
    v55 = v18;
    v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v55, &v54, 1));
    v20 = objc_msgSend(v16, "initWithDomain:code:userInfo:", v17, 12, v19);

LABEL_13:
    goto LABEL_14;
  }
  v22 = *(void **)(a1 + 40);
  if (v22)
    v23 = objc_msgSend(v22, "BOOLValue");
  else
    v23 = 0;
  v24 = *(_QWORD *)(a1 + 72);
  v25 = *(void **)(a1 + 48);
  if (v25)
    v26 = objc_msgSend(v25, "unsignedIntValue");
  else
    v26 = 0;
  v17 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig readerWithLPCD:fieldDetect:pollDuration:ecp:](NFRoutingConfig, "readerWithLPCD:fieldDetect:pollDuration:ecp:", v23, v24, v26, *(_QWORD *)(a1 + 56)));
  objc_msgSend(v17, "setPollingMask:tagConfig:", *(unsigned int *)(*(_QWORD *)(a1 + 32) + 280), objc_msgSend(*(id *)(a1 + 32), "_getTagNotificationConfig"));
  v27 = (void *)objc_claimAutoreleasedReturnValue(+[_NFHardwareManager sharedHardwareManager](_NFHardwareManager, "sharedHardwareManager"));
  v20 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v27, "setRoutingConfig:", v17));

  if (!v20)
  {
    v28 = NFLogGetLogger(2);
    if (v28)
    {
      v29 = (void (*)(uint64_t, const char *, ...))v28;
      v30 = object_getClass(*(id *)(a1 + 32));
      v31 = class_isMetaClass(v30);
      v32 = object_getClassName(*(id *)(a1 + 32));
      v33 = sel_getName(*(SEL *)(a1 + 64));
      v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
      v35 = 45;
      if (v31)
        v35 = 43;
      v29(6, "%c[%{public}s %{public}s]:%i NFC Reader mode activated: %@", v35, v32, v33, 1575, v34);

    }
    v36 = NFSharedLogGetLogger(2);
    v37 = objc_claimAutoreleasedReturnValue(v36);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      v38 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v38))
        v39 = 43;
      else
        v39 = 45;
      v40 = object_getClassName(*(id *)(a1 + 32));
      v41 = sel_getName(*(SEL *)(a1 + 64));
      v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
      *(_DWORD *)buf = 67110146;
      *(_DWORD *)v49 = v39;
      *(_WORD *)&v49[4] = 2082;
      *(_QWORD *)&v49[6] = v40;
      *(_WORD *)&v49[14] = 2082;
      *(_QWORD *)&v49[16] = v41;
      v50 = 1024;
      v51 = 1575;
      v52 = 2112;
      v53 = v42;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i NFC Reader mode activated: %@", buf, 0x2Cu);

    }
    v44 = NFSharedSignpostLog(v43);
    v18 = objc_claimAutoreleasedReturnValue(v44);
    if (os_signpost_enabled(v18))
    {
      v45 = objc_msgSend(*(id *)(a1 + 32), "_isCoreNFCSession");
      v46 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 360);
      *(_DWORD *)buf = 134349312;
      *(_QWORD *)v49 = v45;
      *(_WORD *)&v49[8] = 2050;
      *(_QWORD *)&v49[10] = v46;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v18, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "Polling", " coreNFC=%{public,signpost.description:attribute}lu  sessionType=%{public,signpost.description:attribute}lu ", buf, 0x16u);
    }
    v20 = 0;
    goto LABEL_13;
  }
LABEL_14:

  return v20;
}

void sub_1001ADF5C(uint64_t a1, void *a2)
{
  id v3;
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  objc_class *v13;
  int v14;
  const char *v15;
  const char *v16;
  uint64_t v17;
  id v18;
  void *v19;
  void *v20;
  void *v21;
  id v22;
  uint64_t v23;
  uint64_t v24;
  const char *ClassName;
  const char *Name;
  NSErrorUserInfoKey v27;
  void *v28;
  uint8_t buf[4];
  int v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  int v36;
  __int16 v37;
  id v38;

  v3 = a2;
  if (v3)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      v9 = 45;
      if (isMetaClass)
        v9 = 43;
      v6(6, "%c[%{public}s %{public}s]:%i Not ready: %{public}@", v9, ClassName, Name, 1590, v3);
    }
    v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v11 = NFSharedLogGetLogger(v10);
    v12 = objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      v13 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v13))
        v14 = 43;
      else
        v14 = 45;
      v15 = object_getClassName(*(id *)(a1 + 32));
      v16 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)buf = 67110146;
      v30 = v14;
      v31 = 2082;
      v32 = v15;
      v33 = 2082;
      v34 = v16;
      v35 = 1024;
      v36 = 1590;
      v37 = 2114;
      v38 = v3;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Not ready: %{public}@", buf, 0x2Cu);
    }

    v17 = *(_QWORD *)(a1 + 40);
    v18 = objc_alloc((Class)NSError);
    v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v27 = NSLocalizedDescriptionKey;
    v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Busy"));
    v28 = v20;
    v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v28, &v27, 1));
    v22 = objc_msgSend(v18, "initWithDomain:code:userInfo:", v19, 2, v21);
    (*(void (**)(uint64_t, id))(v17 + 16))(v17, v22);

  }
  else
  {
    v23 = *(_QWORD *)(a1 + 40);
    v24 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
    v19 = (void *)objc_claimAutoreleasedReturnValue(v24);
    (*(void (**)(uint64_t, void *))(v23 + 16))(v23, v19);
  }

}

void sub_1001AE290(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  uint64_t v19;
  id v20;
  void *v21;
  void *v22;
  void *v23;
  id v24;
  NSErrorUserInfoKey v25;
  void *v26;
  uint8_t buf[4];
  int v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  void *v36;

  if (!objc_msgSend(*(id *)(a1 + 32), "didStart")
    || (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) != 0
    || objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      v10 = 45;
      if (isMetaClass)
        v10 = 43;
      v4(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v10, ClassName, Name, 1608, v9);

    }
    v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v12 = NFSharedLogGetLogger(v11);
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v14 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v14))
        v15 = 43;
      else
        v15 = 45;
      v16 = object_getClassName(*(id *)(a1 + 32));
      v17 = sel_getName(*(SEL *)(a1 + 48));
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      *(_DWORD *)buf = 67110146;
      v28 = v15;
      v29 = 2082;
      v30 = v16;
      v31 = 2082;
      v32 = v17;
      v33 = 1024;
      v34 = 1608;
      v35 = 2114;
      v36 = v18;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

    }
    v19 = *(_QWORD *)(a1 + 40);
    if (v19)
    {
      v20 = objc_alloc((Class)NSError);
      v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v25 = NSLocalizedDescriptionKey;
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
      v26 = v22;
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v26, &v25, 1));
      v24 = objc_msgSend(v20, "initWithDomain:code:userInfo:", v21, 54, v23);
      (*(void (**)(uint64_t, id))(v19 + 16))(v19, v24);

    }
  }
  else
  {
    objc_msgSend(*(id *)(a1 + 32), "_sync_startPollingForNDEFMessagesWithSessionConfig:completion:", *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 40));
  }
}

id sub_1001AEAB4(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  NSObject *v11;
  objc_class *v12;
  int v13;
  const char *v14;
  const char *v15;
  id v16;
  void *v17;
  void *v18;
  void *v19;
  id v20;
  id WeakRetained;
  void *v22;
  void *v23;
  uint64_t v24;
  void (*v25)(uint64_t, const char *, ...);
  objc_class *v26;
  _BOOL4 v27;
  const char *v28;
  const char *v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  NSObject *v33;
  objc_class *v34;
  int v35;
  const char *v36;
  const char *v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  NSObject *v41;
  unsigned int v42;
  uint64_t v43;
  id v44;
  const char *Name;
  uint8_t buf[4];
  _BYTE v48[24];
  __int16 v49;
  int v50;
  __int16 v51;
  void *v52;
  NSErrorUserInfoKey v53;
  void *v54;

  if ((objc_msgSend(*(id *)(a1 + 32), "didEnd") & 1) != 0
    || objc_msgSend(*(id *)(a1 + 32), "isSuspended"))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 40));
      v8 = 45;
      if (isMetaClass)
        v8 = 43;
      v4(3, "%c[%{public}s %{public}s]:%i Session has been terminated / suspended", v8, ClassName, Name, 1626);
    }
    v9 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v10 = NFSharedLogGetLogger(v9);
    v11 = objc_claimAutoreleasedReturnValue(v10);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v12 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v12))
        v13 = 43;
      else
        v13 = 45;
      v14 = object_getClassName(*(id *)(a1 + 32));
      v15 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)v48 = v13;
      *(_WORD *)&v48[4] = 2082;
      *(_QWORD *)&v48[6] = v14;
      *(_WORD *)&v48[14] = 2082;
      *(_QWORD *)&v48[16] = v15;
      v49 = 1024;
      v50 = 1626;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session has been terminated / suspended", buf, 0x22u);
    }

    v16 = objc_alloc((Class)NSError);
    v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v53 = NSLocalizedDescriptionKey;
    v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid State"));
    v54 = v18;
    v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v54, &v53, 1));
    v20 = objc_msgSend(v16, "initWithDomain:code:userInfo:", v17, 12, v19);

  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 208) = 2;
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 352) = *(_QWORD *)(a1 + 48);
    WeakRetained = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 320));
    sub_10019E124((uint64_t)WeakRetained, *(void **)(a1 + 32));

    v22 = (void *)objc_claimAutoreleasedReturnValue(+[_NFHardwareManager sharedHardwareManager](_NFHardwareManager, "sharedHardwareManager"));
    objc_msgSend(v22, "notifyReaderModeActivityEnd");

    *(_DWORD *)(*(_QWORD *)(a1 + 32) + 280) = 15;
    v17 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig readerModeWithFD:](NFRoutingConfig, "readerModeWithFD:", 2));
    objc_msgSend(v17, "setPollingMask:tagConfig:", *(unsigned int *)(*(_QWORD *)(a1 + 32) + 280), objc_msgSend(*(id *)(a1 + 32), "_getTagNotificationConfig"));
    v23 = (void *)objc_claimAutoreleasedReturnValue(+[_NFHardwareManager sharedHardwareManager](_NFHardwareManager, "sharedHardwareManager"));
    v20 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v23, "setRoutingConfig:", v17));

    if (!v20)
    {
      v24 = NFLogGetLogger(2);
      if (v24)
      {
        v25 = (void (*)(uint64_t, const char *, ...))v24;
        v26 = object_getClass(*(id *)(a1 + 32));
        v27 = class_isMetaClass(v26);
        v28 = object_getClassName(*(id *)(a1 + 32));
        v29 = sel_getName(*(SEL *)(a1 + 40));
        v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
        v31 = 45;
        if (v27)
          v31 = 43;
        v25(6, "%c[%{public}s %{public}s]:%i NFC Reader mode activated: %@", v31, v28, v29, 1647, v30);

      }
      v32 = NFSharedLogGetLogger(2);
      v33 = objc_claimAutoreleasedReturnValue(v32);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        v34 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v34))
          v35 = 43;
        else
          v35 = 45;
        v36 = object_getClassName(*(id *)(a1 + 32));
        v37 = sel_getName(*(SEL *)(a1 + 40));
        v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
        *(_DWORD *)buf = 67110146;
        *(_DWORD *)v48 = v35;
        *(_WORD *)&v48[4] = 2082;
        *(_QWORD *)&v48[6] = v36;
        *(_WORD *)&v48[14] = 2082;
        *(_QWORD *)&v48[16] = v37;
        v49 = 1024;
        v50 = 1647;
        v51 = 2112;
        v52 = v38;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i NFC Reader mode activated: %@", buf, 0x2Cu);

      }
      v40 = NFSharedSignpostLog(v39);
      v41 = objc_claimAutoreleasedReturnValue(v40);
      if (os_signpost_enabled(v41))
      {
        v42 = objc_msgSend(*(id *)(a1 + 32), "_isCoreNFCSession");
        v43 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 360);
        *(_DWORD *)buf = 134349312;
        *(_QWORD *)v48 = v42;
        *(_WORD *)&v48[8] = 2050;
        *(_QWORD *)&v48[10] = v43;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v41, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "Polling", " coreNFC=%{public,signpost.description:attribute}lu  sessionType=%{public,signpost.description:attribute}lu ", buf, 0x16u);
      }

    }
    v44 = sub_100226308((uint64_t)NFTagReadCALogger);
    v18 = (void *)objc_claimAutoreleasedReturnValue(v44);
    sub_100226F44((uint64_t)v18, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 208));
  }

  return v20;
}

void sub_1001AEFB8(uint64_t a1, void *a2)
{
  id v3;
  void *specific;
  uint64_t Logger;
  void (*v6)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  objc_class *v13;
  int v14;
  const char *v15;
  const char *v16;
  uint64_t v17;
  id v18;
  void *v19;
  void *v20;
  void *v21;
  id v22;
  uint64_t v23;
  uint64_t v24;
  const char *ClassName;
  const char *Name;
  NSErrorUserInfoKey v27;
  void *v28;
  uint8_t buf[4];
  int v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  int v36;
  __int16 v37;
  id v38;

  v3 = a2;
  if (v3)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      v9 = 45;
      if (isMetaClass)
        v9 = 43;
      v6(6, "%c[%{public}s %{public}s]:%i Not ready: %{public}@", v9, ClassName, Name, 1664, v3);
    }
    v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v11 = NFSharedLogGetLogger(v10);
    v12 = objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      v13 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v13))
        v14 = 43;
      else
        v14 = 45;
      v15 = object_getClassName(*(id *)(a1 + 32));
      v16 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)buf = 67110146;
      v30 = v14;
      v31 = 2082;
      v32 = v15;
      v33 = 2082;
      v34 = v16;
      v35 = 1024;
      v36 = 1664;
      v37 = 2114;
      v38 = v3;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Not ready: %{public}@", buf, 0x2Cu);
    }

    v17 = *(_QWORD *)(a1 + 40);
    v18 = objc_alloc((Class)NSError);
    v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v27 = NSLocalizedDescriptionKey;
    v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Busy"));
    v28 = v20;
    v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v28, &v27, 1));
    v22 = objc_msgSend(v18, "initWithDomain:code:userInfo:", v19, 2, v21);
    (*(void (**)(uint64_t, id))(v17 + 16))(v17, v22);

  }
  else
  {
    v23 = *(_QWORD *)(a1 + 40);
    v24 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
    v19 = (void *)objc_claimAutoreleasedReturnValue(v24);
    (*(void (**)(uint64_t, void *))(v23 + 16))(v23, v19);
  }

}

void sub_1001AF2E0(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  uint64_t v19;
  id v20;
  void *v21;
  void *v22;
  void *v23;
  id v24;
  NSErrorUserInfoKey v25;
  void *v26;
  uint8_t buf[4];
  int v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  void *v36;

  if (!objc_msgSend(*(id *)(a1 + 32), "didStart")
    || (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) != 0
    || objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      v10 = 45;
      if (isMetaClass)
        v10 = 43;
      v4(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v10, ClassName, Name, 1682, v9);

    }
    v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v12 = NFSharedLogGetLogger(v11);
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v14 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v14))
        v15 = 43;
      else
        v15 = 45;
      v16 = object_getClassName(*(id *)(a1 + 32));
      v17 = sel_getName(*(SEL *)(a1 + 48));
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      *(_DWORD *)buf = 67110146;
      v28 = v15;
      v29 = 2082;
      v30 = v16;
      v31 = 2082;
      v32 = v17;
      v33 = 1024;
      v34 = 1682;
      v35 = 2114;
      v36 = v18;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

    }
    v19 = *(_QWORD *)(a1 + 40);
    if (v19)
    {
      v20 = objc_alloc((Class)NSError);
      v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v25 = NSLocalizedDescriptionKey;
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
      v26 = v22;
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v26, &v25, 1));
      v24 = objc_msgSend(v20, "initWithDomain:code:userInfo:", v21, 54, v23);
      (*(void (**)(uint64_t, id))(v19 + 16))(v19, v24);

    }
  }
  else
  {
    objc_msgSend(*(id *)(a1 + 32), "_sync_stopPolling:", *(_QWORD *)(a1 + 40));
  }
}

void sub_1001AFBC8(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  uint64_t v19;
  id v20;
  void *v21;
  void *v22;
  void *v23;
  id v24;
  NSErrorUserInfoKey v25;
  void *v26;
  uint8_t buf[4];
  int v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  void *v36;

  if (!objc_msgSend(*(id *)(a1 + 32), "didStart")
    || (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) != 0
    || objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      v10 = 45;
      if (isMetaClass)
        v10 = 43;
      v4(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v10, ClassName, Name, 1710, v9);

    }
    v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v12 = NFSharedLogGetLogger(v11);
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v14 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v14))
        v15 = 43;
      else
        v15 = 45;
      v16 = object_getClassName(*(id *)(a1 + 32));
      v17 = sel_getName(*(SEL *)(a1 + 48));
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      *(_DWORD *)buf = 67110146;
      v28 = v15;
      v29 = 2082;
      v30 = v16;
      v31 = 2082;
      v32 = v17;
      v33 = 1024;
      v34 = 1710;
      v35 = 2114;
      v36 = v18;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

    }
    v19 = *(_QWORD *)(a1 + 40);
    if (v19)
    {
      v20 = objc_alloc((Class)NSError);
      v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v25 = NSLocalizedDescriptionKey;
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
      v26 = v22;
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v26, &v25, 1));
      v24 = objc_msgSend(v20, "initWithDomain:code:userInfo:", v21, 54, v23);
      (*(void (**)(uint64_t, id))(v19 + 16))(v19, v24);

    }
  }
  else
  {
    objc_msgSend(*(id *)(a1 + 32), "_sync_restartPolling:", *(_QWORD *)(a1 + 40));
  }
}

void sub_1001B03A4(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  uint64_t v19;
  id v20;
  void *v21;
  void *v22;
  void *v23;
  id v24;
  NSErrorUserInfoKey v25;
  void *v26;
  uint8_t buf[4];
  int v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  void *v36;

  if (!objc_msgSend(*(id *)(a1 + 32), "didStart")
    || (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) != 0
    || objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      v10 = 45;
      if (isMetaClass)
        v10 = 43;
      v4(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v10, ClassName, Name, 1753, v9);

    }
    v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v12 = NFSharedLogGetLogger(v11);
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v14 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v14))
        v15 = 43;
      else
        v15 = 45;
      v16 = object_getClassName(*(id *)(a1 + 32));
      v17 = sel_getName(*(SEL *)(a1 + 56));
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      *(_DWORD *)buf = 67110146;
      v28 = v15;
      v29 = 2082;
      v30 = v16;
      v31 = 2082;
      v32 = v17;
      v33 = 1024;
      v34 = 1753;
      v35 = 2114;
      v36 = v18;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

    }
    v19 = *(_QWORD *)(a1 + 48);
    if (v19)
    {
      v20 = objc_alloc((Class)NSError);
      v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v25 = NSLocalizedDescriptionKey;
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
      v26 = v22;
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v26, &v25, 1));
      v24 = objc_msgSend(v20, "initWithDomain:code:userInfo:", v21, 54, v23);
      (*(void (**)(uint64_t, _QWORD, _QWORD, id, double))(v19 + 16))(v19, 0, 0, v24, 0.0);

    }
  }
  else
  {
    objc_msgSend(*(id *)(a1 + 32), "_sync_execRemoteAdminScript:completion:", *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48));
  }
}

void sub_1001B2494(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  uint64_t v19;
  id v20;
  void *v21;
  void *v22;
  void *v23;
  id v24;
  NSErrorUserInfoKey v25;
  void *v26;
  uint8_t buf[4];
  int v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  void *v36;

  if (!objc_msgSend(*(id *)(a1 + 32), "didStart")
    || (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) != 0
    || objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 64));
      v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      v10 = 45;
      if (isMetaClass)
        v10 = 43;
      v4(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v10, ClassName, Name, 1930, v9);

    }
    v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v12 = NFSharedLogGetLogger(v11);
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v14 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v14))
        v15 = 43;
      else
        v15 = 45;
      v16 = object_getClassName(*(id *)(a1 + 32));
      v17 = sel_getName(*(SEL *)(a1 + 64));
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      *(_DWORD *)buf = 67110146;
      v28 = v15;
      v29 = 2082;
      v30 = v16;
      v31 = 2082;
      v32 = v17;
      v33 = 1024;
      v34 = 1930;
      v35 = 2114;
      v36 = v18;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

    }
    v19 = *(_QWORD *)(a1 + 56);
    if (v19)
    {
      v20 = objc_alloc((Class)NSError);
      v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v25 = NSLocalizedDescriptionKey;
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
      v26 = v22;
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v26, &v25, 1));
      v24 = objc_msgSend(v20, "initWithDomain:code:userInfo:", v21, 54, v23);
      (*(void (**)(uint64_t, _QWORD, id))(v19 + 16))(v19, 0, v24);

    }
  }
  else
  {
    objc_msgSend(*(id *)(a1 + 32), "_sync_felicaStateForSystemCode:withRequestService:performSearchServiceCode:completion:", *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(unsigned __int8 *)(a1 + 72), *(_QWORD *)(a1 + 56));
  }
}

void sub_1001B3468(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  uint64_t v19;
  id v20;
  void *v21;
  void *v22;
  void *v23;
  id v24;
  id v25;
  id v26;
  uint64_t v27;
  id v28;
  void *v29;
  void *v30;
  void *v31;
  id v32;
  NSErrorUserInfoKey v33;
  void *v34;
  NSErrorUserInfoKey v35;
  void *v36;
  uint8_t buf[4];
  int v38;
  __int16 v39;
  const char *v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  int v44;
  __int16 v45;
  void *v46;

  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "_RequestService:", *(_QWORD *)(a1 + 40)));
    v25 = objc_msgSend(v21, "count");
    v26 = objc_msgSend(*(id *)(a1 + 40), "count");
    v27 = *(_QWORD *)(a1 + 48);
    if (v25 == v26)
    {
      (*(void (**)(uint64_t, void *, _QWORD))(v27 + 16))(v27, v21, 0);
    }
    else
    {
      v28 = objc_alloc((Class)NSError);
      v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v33 = NSLocalizedDescriptionKey;
      v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unexpected Result"));
      v34 = v30;
      v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v34, &v33, 1));
      v32 = objc_msgSend(v28, "initWithDomain:code:userInfo:", v29, 13, v31);
      (*(void (**)(uint64_t, void *, id))(v27 + 16))(v27, v21, v32);

    }
    goto LABEL_15;
  }
  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v10 = 45;
    if (isMetaClass)
      v10 = 43;
    v4(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v10, ClassName, Name, 2036, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 56));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v38 = v15;
    v39 = 2082;
    v40 = v16;
    v41 = 2082;
    v42 = v17;
    v43 = 1024;
    v44 = 2036;
    v45 = 2114;
    v46 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v19 = *(_QWORD *)(a1 + 48);
  if (v19)
  {
    v20 = objc_alloc((Class)NSError);
    v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v35 = NSLocalizedDescriptionKey;
    v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v36 = v22;
    v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v36, &v35, 1));
    v24 = objc_msgSend(v20, "initWithDomain:code:userInfo:", v21, 54, v23);
    (*(void (**)(uint64_t, _QWORD, id))(v19 + 16))(v19, 0, v24);

LABEL_15:
  }
}

void sub_1001B3904(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  uint64_t v19;
  id v20;
  void *v21;
  void *v22;
  void *v23;
  id v24;
  id v25;
  id v26;
  uint64_t v27;
  id v28;
  void *v29;
  void *v30;
  void *v31;
  id v32;
  NSErrorUserInfoKey v33;
  void *v34;
  NSErrorUserInfoKey v35;
  void *v36;
  uint8_t buf[4];
  int v38;
  __int16 v39;
  const char *v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  int v44;
  __int16 v45;
  void *v46;

  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "_RequestService:forSystemCode:", *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48)));
    v25 = objc_msgSend(v21, "count");
    v26 = objc_msgSend(*(id *)(a1 + 40), "count");
    v27 = *(_QWORD *)(a1 + 56);
    if (v25 == v26)
    {
      (*(void (**)(uint64_t, void *, _QWORD))(v27 + 16))(v27, v21, 0);
    }
    else
    {
      v28 = objc_alloc((Class)NSError);
      v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v33 = NSLocalizedDescriptionKey;
      v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Unexpected Result"));
      v34 = v30;
      v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v34, &v33, 1));
      v32 = objc_msgSend(v28, "initWithDomain:code:userInfo:", v29, 13, v31);
      (*(void (**)(uint64_t, void *, id))(v27 + 16))(v27, v21, v32);

    }
    goto LABEL_15;
  }
  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 64));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v10 = 45;
    if (isMetaClass)
      v10 = 43;
    v4(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v10, ClassName, Name, 2051, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 64));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v38 = v15;
    v39 = 2082;
    v40 = v16;
    v41 = 2082;
    v42 = v17;
    v43 = 1024;
    v44 = 2051;
    v45 = 2114;
    v46 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v19 = *(_QWORD *)(a1 + 56);
  if (v19)
  {
    v20 = objc_alloc((Class)NSError);
    v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v35 = NSLocalizedDescriptionKey;
    v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v36 = v22;
    v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v36, &v35, 1));
    v24 = objc_msgSend(v20, "initWithDomain:code:userInfo:", v21, 54, v23);
    (*(void (**)(uint64_t, _QWORD, id))(v19 + 16))(v19, 0, v24);

LABEL_15:
  }
}

void sub_1001B3D58(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  void *v19;
  uint64_t v20;
  void (*v21)(uint64_t, const char *, ...);
  objc_class *v22;
  _BOOL4 v23;
  const char *v24;
  const char *v25;
  void *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  NSObject *v30;
  objc_class *v31;
  int v32;
  const char *v33;
  const char *v34;
  void *v35;
  uint64_t v36;
  id v37;
  id v38;
  void *v39;
  void *v40;
  void *v41;
  id v42;
  uint64_t v43;
  id v44;
  uint64_t v45;
  void *v46;
  void *v47;
  void *v48;
  uint64_t v49;
  void (*v50)(uint64_t, const char *, ...);
  objc_class *v51;
  _BOOL4 v52;
  const char *v53;
  uint64_t v54;
  void *v55;
  uint64_t v56;
  NSObject *v57;
  objc_class *v58;
  int v59;
  const char *v60;
  const char *v61;
  id v62;
  const char *v63;
  id v64;
  NSErrorUserInfoKey v65;
  void *v66;
  NSErrorUserInfoKey v67;
  void *v68;
  uint8_t buf[4];
  int v70;
  __int16 v71;
  const char *v72;
  __int16 v73;
  const char *v74;
  __int16 v75;
  int v76;
  __int16 v77;
  void *v78;

  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  if (Logger)
  {
    v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    v10 = 45;
    if (isMetaClass)
      v10 = 43;
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@", v10, ClassName, Name, 2066, v9);

  }
  v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v12 = NFSharedLogGetLogger(v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14))
      v15 = 43;
    else
      v15 = 45;
    v16 = object_getClassName(*(id *)(a1 + 32));
    v17 = sel_getName(*(SEL *)(a1 + 48));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clientName"));
    *(_DWORD *)buf = 67110146;
    v70 = v15;
    v71 = 2082;
    v72 = v16;
    v73 = 2082;
    v74 = v17;
    v75 = 1024;
    v76 = 2066;
    v77 = 2114;
    v78 = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);

  }
  if (objc_msgSend(*(id *)(a1 + 32), "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v45 = *(_QWORD *)(a1 + 32);
    v46 = *(void **)(v45 + 344);
    if (v46)
    {
      v47 = *(void **)(v45 + 312);
      v64 = 0;
      sub_1001832B4(v47, v46, &v64);
      v38 = v64;
      (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
      goto LABEL_25;
    }
    v48 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v49 = NFLogGetLogger(v48);
    if (v49)
    {
      v50 = (void (*)(uint64_t, const char *, ...))v49;
      v51 = object_getClass(*(id *)(a1 + 32));
      v52 = class_isMetaClass(v51);
      v53 = object_getClassName(*(id *)(a1 + 32));
      v63 = sel_getName(*(SEL *)(a1 + 48));
      v54 = 45;
      if (v52)
        v54 = 43;
      v50(3, "%c[%{public}s %{public}s]:%i Invalid tag state", v54, v53, v63, 2072);
    }
    v55 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v56 = NFSharedLogGetLogger(v55);
    v57 = objc_claimAutoreleasedReturnValue(v56);
    if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
    {
      v58 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v58))
        v59 = 43;
      else
        v59 = 45;
      v60 = object_getClassName(*(id *)(a1 + 32));
      v61 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)buf = 67109890;
      v70 = v59;
      v71 = 2082;
      v72 = v60;
      v73 = 2082;
      v74 = v61;
      v75 = 1024;
      v76 = 2072;
      _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid tag state", buf, 0x22u);
    }

    v36 = *(_QWORD *)(a1 + 40);
    v62 = objc_alloc((Class)NSError);
    v38 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v65 = NSLocalizedDescriptionKey;
    v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid State"));
    v66 = v39;
    v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v66, &v65, 1));
    v41 = v62;
    v42 = v38;
    v43 = 12;
LABEL_24:
    v44 = objc_msgSend(v41, "initWithDomain:code:userInfo:", v42, v43, v40);
    (*(void (**)(uint64_t, id))(v36 + 16))(v36, v44);

LABEL_25:
    return;
  }
  v19 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v20 = NFLogGetLogger(v19);
  if (v20)
  {
    v21 = (void (*)(uint64_t, const char *, ...))v20;
    v22 = object_getClass(*(id *)(a1 + 32));
    v23 = class_isMetaClass(v22);
    v24 = object_getClassName(*(id *)(a1 + 32));
    v25 = sel_getName(*(SEL *)(a1 + 48));
    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v27 = 45;
    if (v23)
      v27 = 43;
    v21(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v27, v24, v25, 2069, v26);

  }
  v28 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v29 = NFSharedLogGetLogger(v28);
  v30 = objc_claimAutoreleasedReturnValue(v29);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
  {
    v31 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v31))
      v32 = 43;
    else
      v32 = 45;
    v33 = object_getClassName(*(id *)(a1 + 32));
    v34 = sel_getName(*(SEL *)(a1 + 48));
    v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v70 = v32;
    v71 = 2082;
    v72 = v33;
    v73 = 2082;
    v74 = v34;
    v75 = 1024;
    v76 = 2069;
    v77 = 2114;
    v78 = v35;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v36 = *(_QWORD *)(a1 + 40);
  if (v36)
  {
    v37 = objc_alloc((Class)NSError);
    v38 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v67 = NSLocalizedDescriptionKey;
    v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v68 = v39;
    v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v68, &v67, 1));
    v41 = v37;
    v42 = v38;
    v43 = 54;
    goto LABEL_24;
  }
}

void sub_1001B4408(uint64_t a1)
{
  _QWORD *v2;
  void *v3;
  uint64_t v4;
  void (*v5)(uint64_t, const char *, ...);
  objc_class *v6;
  _BOOL4 v7;
  const char *v8;
  const char *v9;
  void *v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  objc_class *v15;
  int v16;
  const char *v17;
  const char *v18;
  objc_class *v19;
  uint64_t v20;
  id v21;
  objc_class *v22;
  NFVASReader *v23;
  void *v24;
  void *v25;
  objc_class *v26;
  uint64_t v27;
  void *specific;
  uint64_t Logger;
  void (*v30)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  NSObject *v37;
  objc_class *v38;
  int v39;
  const char *v40;
  const char *v41;
  id v42;
  NSMutableArray *v43;
  id v44;
  id v45;
  uint64_t v46;
  void *i;
  void *v48;
  void *v49;
  void *v50;
  double v51;
  NSObject *v52;
  objc_class *v53;
  void *v54;
  uint64_t v55;
  void (*v56)(uint64_t, const char *, ...);
  objc_class *v57;
  _BOOL4 v58;
  uint64_t v59;
  void *v60;
  uint64_t v61;
  NSObject *v62;
  objc_class *v63;
  int v64;
  const char *v65;
  const char *v66;
  uint64_t v67;
  id v68;
  uint64_t v69;
  void *v70;
  uint64_t v71;
  void (*v72)(uint64_t, const char *, ...);
  objc_class *v73;
  _BOOL4 v74;
  const char *v75;
  uint64_t v76;
  void *v77;
  uint64_t v78;
  NSObject *v79;
  objc_class *v80;
  int v81;
  const char *v82;
  const char *v83;
  uint64_t v84;
  id v85;
  id v86;
  void *v87;
  id v88;
  void *v89;
  uint64_t v90;
  void (*v91)(uint64_t, const char *, ...);
  objc_class *v92;
  _BOOL4 v93;
  uint64_t v94;
  void *v95;
  uint64_t v96;
  NSObject *v97;
  objc_class *v98;
  int v99;
  const char *v100;
  const char *v101;
  void *v102;
  id v103;
  id v104;
  void *v105;
  id v106;
  const char *v107;
  const char *v108;
  const char *Name;
  const char *v110;
  const char *v111;
  const char *v112;
  id v113;
  NSMutableArray *v114;
  NSObject v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  _QWORD v120[5];
  _QWORD v121[5];
  NSErrorUserInfoKey v122;
  void *v123;
  _BYTE v124[128];
  NSErrorUserInfoKey v125;
  NFVASReader *v126;
  uint8_t buf[4];
  int v128;
  __int16 v129;
  const char *v130;
  __int16 v131;
  const char *v132;
  __int16 v133;
  int v134;
  __int16 v135;
  objc_class *v136;
  NSErrorUserInfoKey v137;
  NFVASReader *v138;

  v2 = *(_QWORD **)(a1 + 32);
  if (!v2[43])
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v30 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      v34 = 45;
      if (isMetaClass)
        v34 = 43;
      v30(3, "%c[%{public}s %{public}s]:%i Tag not connected", v34, ClassName, Name, 2087);
    }
    v35 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v36 = NFSharedLogGetLogger(v35);
    v37 = objc_claimAutoreleasedReturnValue(v36);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
    {
      v38 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v38))
        v39 = 43;
      else
        v39 = 45;
      v40 = object_getClassName(*(id *)(a1 + 32));
      v41 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)buf = 67109890;
      v128 = v39;
      v129 = 2082;
      v130 = v40;
      v131 = 2082;
      v132 = v41;
      v133 = 1024;
      v134 = 2087;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Tag not connected", buf, 0x22u);
    }

    v20 = *(_QWORD *)(a1 + 48);
    v42 = objc_alloc((Class)NSError);
    v22 = (objc_class *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v137 = NSLocalizedDescriptionKey;
    v23 = (NFVASReader *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Tag Not Found"));
    v138 = v23;
    v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v138, &v137, 1));
    v25 = v42;
    v26 = v22;
    v27 = 28;
    goto LABEL_26;
  }
  if (objc_msgSend(v2, "didStart")
    && (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) == 0
    && !objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    v118 = 0u;
    v119 = 0u;
    v116 = 0u;
    v117 = 0u;
    v22 = (objc_class *)*(id *)(a1 + 40);
    v44 = -[objc_class countByEnumeratingWithState:objects:count:](v22, "countByEnumeratingWithState:objects:count:", &v116, v124, 16);
    if (v44)
    {
      v45 = v44;
      v46 = *(_QWORD *)v117;
      while (2)
      {
        for (i = 0; i != v45; i = (char *)i + 1)
        {
          if (*(_QWORD *)v117 != v46)
            objc_enumerationMutation(v22);
          if (!+[NFVASRequest validateDictionary:](NFVASRequest, "validateDictionary:", *(_QWORD *)(*((_QWORD *)&v116 + 1) + 8 * (_QWORD)i)))
          {
            v70 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v71 = NFLogGetLogger(v70);
            if (v71)
            {
              v72 = (void (*)(uint64_t, const char *, ...))v71;
              v73 = object_getClass(*(id *)(a1 + 32));
              v74 = class_isMetaClass(v73);
              v75 = object_getClassName(*(id *)(a1 + 32));
              v111 = sel_getName(*(SEL *)(a1 + 56));
              v76 = 45;
              if (v74)
                v76 = 43;
              v72(3, "%c[%{public}s %{public}s]:%i Invalid parameter", v76, v75, v111, 2096);
            }
            v77 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v78 = NFSharedLogGetLogger(v77);
            v79 = objc_claimAutoreleasedReturnValue(v78);
            if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
            {
              v80 = object_getClass(*(id *)(a1 + 32));
              if (class_isMetaClass(v80))
                v81 = 43;
              else
                v81 = 45;
              v82 = object_getClassName(*(id *)(a1 + 32));
              v83 = sel_getName(*(SEL *)(a1 + 56));
              *(_DWORD *)buf = 67109890;
              v128 = v81;
              v129 = 2082;
              v130 = v82;
              v131 = 2082;
              v132 = v83;
              v133 = 1024;
              v134 = 2096;
              _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid parameter", buf, 0x22u);
            }

            v84 = *(_QWORD *)(a1 + 48);
            v85 = objc_alloc((Class)NSError);
            v23 = (NFVASReader *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
            v122 = NSLocalizedDescriptionKey;
            v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid Parameter"));
            v123 = v24;
            v43 = (NSMutableArray *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v123, &v122, 1));
            v86 = objc_msgSend(v85, "initWithDomain:code:userInfo:", v23, 10, v43);
            (*(void (**)(uint64_t, id, _QWORD))(v84 + 16))(v84, v86, 0);

            goto LABEL_27;
          }
        }
        v45 = -[objc_class countByEnumeratingWithState:objects:count:](v22, "countByEnumeratingWithState:objects:count:", &v116, v124, 16);
        if (v45)
          continue;
        break;
      }
    }

    v23 = objc_opt_new(NFVASReader);
    v48 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "driverWrapper"));
    sub_100051EF0((uint64_t)v23, v48);

    v49 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "currentTag"));
    sub_100084994((uint64_t)v23, v49);

    v50 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "whitelistChecker"));
    objc_msgSend(v50, "sessionTimeLimit");
    if (v23)
      v23->_maxTime = v51;

    v115.isa = 0;
    v52 = sub_10008201C((uint64_t)v23, &v115);
    v24 = (void *)objc_claimAutoreleasedReturnValue(v52);
    v53 = v115.isa;
    if (v53)
    {
      v22 = v53;
      v54 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v55 = NFLogGetLogger(v54);
      if (v55)
      {
        v56 = (void (*)(uint64_t, const char *, ...))v55;
        v57 = object_getClass(*(id *)(a1 + 32));
        v58 = class_isMetaClass(v57);
        v107 = object_getClassName(*(id *)(a1 + 32));
        v110 = sel_getName(*(SEL *)(a1 + 56));
        v59 = 45;
        if (v58)
          v59 = 43;
        v56(3, "%c[%{public}s %{public}s]:%i error: %{public}@", v59, v107, v110, 2110, v22);
      }
      v60 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v61 = NFSharedLogGetLogger(v60);
      v62 = objc_claimAutoreleasedReturnValue(v61);
      if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
      {
        v63 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v63))
          v64 = 43;
        else
          v64 = 45;
        v65 = object_getClassName(*(id *)(a1 + 32));
        v66 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)buf = 67110146;
        v128 = v64;
        v129 = 2082;
        v130 = v65;
        v131 = 2082;
        v132 = v66;
        v133 = 1024;
        v134 = 2110;
        v135 = 2114;
        v136 = v22;
        _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i error: %{public}@", buf, 0x2Cu);
      }

      v67 = *(_QWORD *)(a1 + 48);
      v113 = objc_alloc((Class)NSError);
      v43 = (NSMutableArray *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v68 = -[objc_class code](v22, "code");
      v120[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)-[objc_class code](v22, "code") > 70)
        v69 = 71;
      else
        v69 = (uint64_t)-[objc_class code](v22, "code");
      v102 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_1002EA5E0[v69]));
      v121[0] = v102;
      v121[1] = v22;
      v120[1] = NSUnderlyingErrorKey;
      v120[2] = CFSTR("Line");
      v121[2] = &off_100300F50;
      v120[3] = CFSTR("Method");
      v103 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName(*(SEL *)(a1 + 56)));
      v121[3] = v103;
      v120[4] = NSDebugDescriptionErrorKey;
      v104 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName(*(SEL *)(a1 + 56)), 2111);
      v121[4] = v104;
      v105 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v121, v120, 5));
      v106 = objc_msgSend(v113, "initWithDomain:code:userInfo:", v43, v68, v105);
      (*(void (**)(uint64_t, id, _QWORD))(v67 + 16))(v67, v106, 0);

    }
    else
    {
      v87 = *(void **)(a1 + 40);
      v114 = 0;
      v88 = sub_1000830AC((unsigned __int8 *)v23, v87, &v114);
      v22 = (objc_class *)objc_claimAutoreleasedReturnValue(v88);
      v43 = v114;
      if (v22)
      {
        v89 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v90 = NFLogGetLogger(v89);
        if (v90)
        {
          v91 = (void (*)(uint64_t, const char *, ...))v90;
          v92 = object_getClass(*(id *)(a1 + 32));
          v93 = class_isMetaClass(v92);
          v108 = object_getClassName(*(id *)(a1 + 32));
          v112 = sel_getName(*(SEL *)(a1 + 56));
          v94 = 45;
          if (v93)
            v94 = 43;
          v91(3, "%c[%{public}s %{public}s]:%i error: %{public}@", v94, v108, v112, 2118, v22);
        }
        v95 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v96 = NFSharedLogGetLogger(v95);
        v97 = objc_claimAutoreleasedReturnValue(v96);
        if (os_log_type_enabled(v97, OS_LOG_TYPE_ERROR))
        {
          v98 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v98))
            v99 = 43;
          else
            v99 = 45;
          v100 = object_getClassName(*(id *)(a1 + 32));
          v101 = sel_getName(*(SEL *)(a1 + 56));
          *(_DWORD *)buf = 67110146;
          v128 = v99;
          v129 = 2082;
          v130 = v100;
          v131 = 2082;
          v132 = v101;
          v133 = 1024;
          v134 = 2118;
          v135 = 2114;
          v136 = v22;
          _os_log_impl((void *)&_mh_execute_header, v97, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i error: %{public}@", buf, 0x2Cu);
        }

      }
      (*(void (**)(_QWORD, objc_class *, NSMutableArray *))(*(_QWORD *)(a1 + 48) + 16))(*(_QWORD *)(a1 + 48), v22, v43);
    }
    goto LABEL_27;
  }
  v3 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v4 = NFLogGetLogger(v3);
  if (v4)
  {
    v5 = (void (*)(uint64_t, const char *, ...))v4;
    v6 = object_getClass(*(id *)(a1 + 32));
    v7 = class_isMetaClass(v6);
    v8 = object_getClassName(*(id *)(a1 + 32));
    v9 = sel_getName(*(SEL *)(a1 + 56));
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    v11 = 45;
    if (v7)
      v11 = 43;
    v5(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v11, v8, v9, 2092, v10);

  }
  v12 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v13 = NFSharedLogGetLogger(v12);
  v14 = objc_claimAutoreleasedReturnValue(v13);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    v15 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v15))
      v16 = 43;
    else
      v16 = 45;
    v17 = object_getClassName(*(id *)(a1 + 32));
    v18 = sel_getName(*(SEL *)(a1 + 56));
    v19 = (objc_class *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
    *(_DWORD *)buf = 67110146;
    v128 = v16;
    v129 = 2082;
    v130 = v17;
    v131 = 2082;
    v132 = v18;
    v133 = 1024;
    v134 = 2092;
    v135 = 2114;
    v136 = v19;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

  }
  v20 = *(_QWORD *)(a1 + 48);
  if (v20)
  {
    v21 = objc_alloc((Class)NSError);
    v22 = (objc_class *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v125 = NSLocalizedDescriptionKey;
    v23 = (NFVASReader *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
    v126 = v23;
    v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v126, &v125, 1));
    v25 = v21;
    v26 = v22;
    v27 = 54;
LABEL_26:
    v43 = (NSMutableArray *)objc_msgSend(v25, "initWithDomain:code:userInfo:", v26, v27, v24);
    (*(void (**)(uint64_t, NSMutableArray *, _QWORD))(v20 + 16))(v20, v43, 0);
LABEL_27:

  }
}

void sub_1001B5048(uint64_t a1)
{
  void *specific;
  uint64_t Logger;
  void (*v4)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  objc_class *v14;
  int v15;
  const char *v16;
  const char *v17;
  void *v18;
  uint64_t v19;
  id v20;
  void *v21;
  void *v22;
  void *v23;
  id v24;
  void *v25;
  uint64_t v26;
  void (*v27)(uint64_t, const char *, ...);
  objc_class *v28;
  _BOOL4 v29;
  const char *v30;
  const char *v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  NSObject *v35;
  objc_class *v36;
  int v37;
  const char *v38;
  const char *v39;
  void *v40;
  int v41;
  void *v42;
  uint64_t v43;
  void (*v44)(uint64_t, const char *, ...);
  objc_class *v45;
  _BOOL4 v46;
  const char *v47;
  uint64_t v48;
  void *v49;
  uint64_t v50;
  NSObject *v51;
  objc_class *v52;
  int v53;
  const char *v54;
  const char *v55;
  uint64_t v56;
  id v57;
  void *v58;
  void *v59;
  void *v60;
  id v61;
  void *v62;
  uint64_t v63;
  void (*v64)(uint64_t, const char *, ...);
  objc_class *v65;
  _BOOL4 v66;
  const char *v67;
  uint64_t v68;
  void *v69;
  uint64_t v70;
  NSObject *v71;
  objc_class *v72;
  int v73;
  const char *v74;
  const char *v75;
  const char *v76;
  const char *v77;
  NSErrorUserInfoKey v78;
  void *v79;
  NSErrorUserInfoKey v80;
  void *v81;
  uint8_t buf[4];
  int v83;
  __int16 v84;
  const char *v85;
  __int16 v86;
  const char *v87;
  __int16 v88;
  int v89;
  __int16 v90;
  void *v91;

  if (!objc_msgSend(*(id *)(a1 + 32), "didStart")
    || (objc_msgSend(*(id *)(a1 + 32), "isSuspended") & 1) != 0
    || objc_msgSend(*(id *)(a1 + 32), "didEnd"))
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      v10 = 45;
      if (isMetaClass)
        v10 = 43;
      v4(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v10, ClassName, Name, 2128, v9);

    }
    v11 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v12 = NFSharedLogGetLogger(v11);
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v14 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v14))
        v15 = 43;
      else
        v15 = 45;
      v16 = object_getClassName(*(id *)(a1 + 32));
      v17 = sel_getName(*(SEL *)(a1 + 48));
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sessionUID"));
      *(_DWORD *)buf = 67110146;
      v83 = v15;
      v84 = 2082;
      v85 = v16;
      v86 = 2082;
      v87 = v17;
      v88 = 1024;
      v89 = 2128;
      v90 = 2114;
      v91 = v18;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);

    }
    v19 = *(_QWORD *)(a1 + 40);
    if (v19)
    {
      v20 = objc_alloc((Class)NSError);
      v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v80 = NSLocalizedDescriptionKey;
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Session not active"));
      v81 = v22;
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v81, &v80, 1));
      v24 = objc_msgSend(v20, "initWithDomain:code:userInfo:", v21, 54, v23);
      (*(void (**)(uint64_t, id))(v19 + 16))(v19, v24);

    }
  }
  else if (objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 160), "readerInternalAccess")
         && (objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 160), "pollingProfileUpdate") & 1) != 0)
  {
    v25 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v26 = NFLogGetLogger(v25);
    if (v26)
    {
      v27 = (void (*)(uint64_t, const char *, ...))v26;
      v28 = object_getClass(*(id *)(a1 + 32));
      v29 = class_isMetaClass(v28);
      v30 = object_getClassName(*(id *)(a1 + 32));
      v31 = sel_getName(*(SEL *)(a1 + 48));
      v32 = 45;
      if (v29)
        v32 = 43;
      v27(6, "%c[%{public}s %{public}s]:%i Using polling profile: %ld", v32, v30, v31, 2136, *(_QWORD *)(a1 + 56));
    }
    v33 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v34 = NFSharedLogGetLogger(v33);
    v35 = objc_claimAutoreleasedReturnValue(v34);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      v36 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v36))
        v37 = 43;
      else
        v37 = 45;
      v38 = object_getClassName(*(id *)(a1 + 32));
      v39 = sel_getName(*(SEL *)(a1 + 48));
      v40 = *(void **)(a1 + 56);
      *(_DWORD *)buf = 67110146;
      v83 = v37;
      v84 = 2082;
      v85 = v38;
      v86 = 2082;
      v87 = v39;
      v88 = 1024;
      v89 = 2136;
      v90 = 2048;
      v91 = v40;
      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Using polling profile: %ld", buf, 0x2Cu);
    }

    *(_DWORD *)(*(_QWORD *)(a1 + 32) + 288) = 0;
    v41 = 0;
    switch(*(_QWORD *)(a1 + 56))
    {
      case 0:
        goto LABEL_51;
      case 1:
        v41 = 1;
        goto LABEL_51;
      case 2:
        v41 = 2;
        goto LABEL_51;
      case 3:
        v41 = 3;
        goto LABEL_51;
      case 4:
        v62 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v63 = NFLogGetLogger(v62);
        if (v63)
        {
          v64 = (void (*)(uint64_t, const char *, ...))v63;
          v65 = object_getClass(*(id *)(a1 + 32));
          v66 = class_isMetaClass(v65);
          v67 = object_getClassName(*(id *)(a1 + 32));
          v77 = sel_getName(*(SEL *)(a1 + 48));
          v68 = 45;
          if (v66)
            v68 = 43;
          v64(6, "%c[%{public}s %{public}s]:%i NON ECP Polling", v68, v67, v77, 2148);
        }
        v69 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v70 = NFSharedLogGetLogger(v69);
        v71 = objc_claimAutoreleasedReturnValue(v70);
        if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
        {
          v72 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v72))
            v73 = 43;
          else
            v73 = 45;
          v74 = object_getClassName(*(id *)(a1 + 32));
          v75 = sel_getName(*(SEL *)(a1 + 48));
          *(_DWORD *)buf = 67109890;
          v83 = v73;
          v84 = 2082;
          v85 = v74;
          v86 = 2082;
          v87 = v75;
          v88 = 1024;
          v89 = 2148;
          _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i NON ECP Polling", buf, 0x22u);
        }

        v41 = 4;
LABEL_51:
        *(_DWORD *)(*(_QWORD *)(a1 + 32) + 288) = v41;
        break;
      default:
        break;
    }
    (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
  }
  else
  {
    v42 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v43 = NFLogGetLogger(v42);
    if (v43)
    {
      v44 = (void (*)(uint64_t, const char *, ...))v43;
      v45 = object_getClass(*(id *)(a1 + 32));
      v46 = class_isMetaClass(v45);
      v47 = object_getClassName(*(id *)(a1 + 32));
      v76 = sel_getName(*(SEL *)(a1 + 48));
      v48 = 45;
      if (v46)
        v48 = 43;
      v44(3, "%c[%{public}s %{public}s]:%i Missing entitlement", v48, v47, v76, 2131);
    }
    v49 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v50 = NFSharedLogGetLogger(v49);
    v51 = objc_claimAutoreleasedReturnValue(v50);
    if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
    {
      v52 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v52))
        v53 = 43;
      else
        v53 = 45;
      v54 = object_getClassName(*(id *)(a1 + 32));
      v55 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)buf = 67109890;
      v83 = v53;
      v84 = 2082;
      v85 = v54;
      v86 = 2082;
      v87 = v55;
      v88 = 1024;
      v89 = 2131;
      _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Missing entitlement", buf, 0x22u);
    }

    v56 = *(_QWORD *)(a1 + 40);
    v57 = objc_alloc((Class)NSError);
    v58 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
    v78 = NSLocalizedDescriptionKey;
    v59 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Not entitled"));
    v79 = v59;
    v60 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v79, &v78, 1));
    v61 = objc_msgSend(v57, "initWithDomain:code:userInfo:", v58, 32, v60);
    (*(void (**)(uint64_t, id))(v56 + 16))(v56, v61);

  }
}

void sub_1001B5AC8(uint64_t a1)
{
  unsigned __int8 v2;
  void *specific;
  uint64_t Logger;
  void (*v5)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  const char *Name;
  const char *v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  objc_class *v15;
  int v16;
  const char *v17;
  const char *v18;
  const char *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  uint64_t v24;
  void (*v25)(uint64_t, const char *, ...);
  objc_class *v26;
  _BOOL4 v27;
  const char *v28;
  uint64_t v29;
  void *v30;
  uint64_t v31;
  NSObject *v32;
  objc_class *v33;
  int v34;
  const char *v35;
  const char *v36;
  const char *v37;
  NSObject *v38;
  os_log_type_t v39;
  uint32_t v40;
  objc_class *v41;
  _BOOL4 v42;
  const char *v43;
  uint64_t v44;
  void *v45;
  uint64_t v46;
  NSObject *v47;
  objc_class *v48;
  int v49;
  const char *v50;
  const char *v51;
  uint64_t v52;
  id v53;
  void *v54;
  void *v55;
  id v56;
  id v57;
  void *v58;
  uint64_t v59;
  void (*v60)(uint64_t, const char *, ...);
  objc_class *v61;
  _BOOL4 v62;
  const char *v63;
  const char *v64;
  const char *v65;
  uint64_t v66;
  void *v67;
  uint64_t v68;
  objc_class *v69;
  int v70;
  const char *v71;
  const char *v72;
  const char *v73;
  uint64_t v74;
  const char *v75;
  const char *v76;
  const char *v77;
  uint8_t buf[4];
  int v79;
  __int16 v80;
  const char *v81;
  __int16 v82;
  const char *v83;
  __int16 v84;
  int v85;
  __int16 v86;
  const char *v87;
  __int16 v88;
  void *v89;
  NSErrorUserInfoKey v90;
  void *v91;

  v2 = objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 160), "readerInternalAccess");
  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  Logger = NFLogGetLogger(specific);
  v5 = (void (*)(uint64_t, const char *, ...))Logger;
  if ((v2 & 1) != 0)
  {
    if (Logger)
    {
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      if (*(_BYTE *)(a1 + 56))
        v10 = "enable";
      else
        v10 = "disable";
      v11 = 45;
      if (isMetaClass)
        v11 = 43;
      v5(6, "%c[%{public}s %{public}s]:%i Wanting to %s ContinuousWave", v11, ClassName, Name, 2185, v10);
    }
    v12 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v13 = NFSharedLogGetLogger(v12);
    v14 = objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      v15 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v15))
        v16 = 43;
      else
        v16 = 45;
      v17 = object_getClassName(*(id *)(a1 + 32));
      v18 = sel_getName(*(SEL *)(a1 + 48));
      if (*(_BYTE *)(a1 + 56))
        v19 = "enable";
      else
        v19 = "disable";
      *(_DWORD *)buf = 67110146;
      v79 = v16;
      v80 = 2082;
      v81 = v17;
      v82 = 2082;
      v83 = v18;
      v84 = 1024;
      v85 = 2185;
      v86 = 2080;
      v87 = v19;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Wanting to %s ContinuousWave", buf, 0x2Cu);
    }

    v20 = (void *)objc_claimAutoreleasedReturnValue(+[_NFHardwareManager sharedHardwareManager](_NFHardwareManager, "sharedHardwareManager"));
    v21 = (void *)objc_claimAutoreleasedReturnValue(+[NFRoutingConfig routingOffWithFD:](NFRoutingConfig, "routingOffWithFD:", 0));
    v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "setRoutingConfig:", v21));

    if (v22)
    {
      v23 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v24 = NFLogGetLogger(v23);
      if (v24)
      {
        v25 = (void (*)(uint64_t, const char *, ...))v24;
        v26 = object_getClass(*(id *)(a1 + 32));
        v27 = class_isMetaClass(v26);
        v28 = object_getClassName(*(id *)(a1 + 32));
        v75 = sel_getName(*(SEL *)(a1 + 48));
        v29 = 45;
        if (v27)
          v29 = 43;
        v25(6, "%c[%{public}s %{public}s]:%i Error turning off routing.", v29, v28, v75, 2189);
      }
      v30 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v31 = NFSharedLogGetLogger(v30);
      v32 = objc_claimAutoreleasedReturnValue(v31);
      if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
        goto LABEL_54;
      v33 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v33))
        v34 = 43;
      else
        v34 = 45;
      v35 = object_getClassName(*(id *)(a1 + 32));
      v36 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)buf = 67109890;
      v79 = v34;
      v80 = 2082;
      v81 = v35;
      v82 = 2082;
      v83 = v36;
      v84 = 1024;
      v85 = 2189;
      v37 = "%c[%{public}s %{public}s]:%i Error turning off routing.";
      v38 = v32;
      v39 = OS_LOG_TYPE_DEFAULT;
      v40 = 34;
    }
    else
    {
      v57 = sub_1001D6A14(*(void **)(*(_QWORD *)(a1 + 32) + 312), *(unsigned __int8 *)(a1 + 56), *(unsigned __int8 *)(a1 + 57));
      v22 = (void *)objc_claimAutoreleasedReturnValue(v57);
      if (!v22)
      {
        v74 = 1;
        if (*(_BYTE *)(a1 + 57))
          v74 = 2;
        *(_QWORD *)(*(_QWORD *)(a1 + 32) + 296) = v74;
        goto LABEL_55;
      }
      v58 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v59 = NFLogGetLogger(v58);
      if (v59)
      {
        v60 = (void (*)(uint64_t, const char *, ...))v59;
        v61 = object_getClass(*(id *)(a1 + 32));
        v62 = class_isMetaClass(v61);
        v63 = object_getClassName(*(id *)(a1 + 32));
        v64 = sel_getName(*(SEL *)(a1 + 48));
        if (*(_BYTE *)(a1 + 56))
          v65 = "enable";
        else
          v65 = "disable";
        v77 = v65;
        v66 = 45;
        if (v62)
          v66 = 43;
        v60(3, "%c[%{public}s %{public}s]:%i Failed to %s ContinuousWave - error=%{public}@", v66, v63, v64, 2193, v77, v22);
      }
      v67 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v68 = NFSharedLogGetLogger(v67);
      v32 = objc_claimAutoreleasedReturnValue(v68);
      if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
LABEL_54:

LABEL_55:
        (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
        goto LABEL_56;
      }
      v69 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v69))
        v70 = 43;
      else
        v70 = 45;
      v71 = object_getClassName(*(id *)(a1 + 32));
      v72 = sel_getName(*(SEL *)(a1 + 48));
      if (*(_BYTE *)(a1 + 56))
        v73 = "enable";
      else
        v73 = "disable";
      *(_DWORD *)buf = 67110402;
      v79 = v70;
      v80 = 2082;
      v81 = v71;
      v82 = 2082;
      v83 = v72;
      v84 = 1024;
      v85 = 2193;
      v86 = 2080;
      v87 = v73;
      v88 = 2114;
      v89 = v22;
      v37 = "%c[%{public}s %{public}s]:%i Failed to %s ContinuousWave - error=%{public}@";
      v38 = v32;
      v39 = OS_LOG_TYPE_ERROR;
      v40 = 54;
    }
    _os_log_impl((void *)&_mh_execute_header, v38, v39, v37, buf, v40);
    goto LABEL_54;
  }
  if (Logger)
  {
    v41 = object_getClass(*(id *)(a1 + 32));
    v42 = class_isMetaClass(v41);
    v43 = object_getClassName(*(id *)(a1 + 32));
    v76 = sel_getName(*(SEL *)(a1 + 48));
    v44 = 45;
    if (v42)
      v44 = 43;
    v5(3, "%c[%{public}s %{public}s]:%i Missing entitlement", v44, v43, v76, 2180);
  }
  v45 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v46 = NFSharedLogGetLogger(v45);
  v47 = objc_claimAutoreleasedReturnValue(v46);
  if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
  {
    v48 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v48))
      v49 = 43;
    else
      v49 = 45;
    v50 = object_getClassName(*(id *)(a1 + 32));
    v51 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)buf = 67109890;
    v79 = v49;
    v80 = 2082;
    v81 = v50;
    v82 = 2082;
    v83 = v51;
    v84 = 1024;
    v85 = 2180;
    _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Missing entitlement", buf, 0x22u);
  }

  v52 = *(_QWORD *)(a1 + 40);
  v53 = objc_alloc((Class)NSError);
  v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
  v90 = NSLocalizedDescriptionKey;
  v54 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Not entitled"));
  v91 = v54;
  v55 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v91, &v90, 1));
  v56 = objc_msgSend(v53, "initWithDomain:code:userInfo:", v22, 32, v55);
  (*(void (**)(uint64_t, id))(v52 + 16))(v52, v56);

LABEL_56:
}

void sub_1001B690C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  id *v11;
  uint64_t v12;
  uint64_t v14;
  va_list va;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  va_list va1;

  va_start(va1, a11);
  va_start(va, a11);
  v14 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  v19 = va_arg(va1, _QWORD);
  v20 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  objc_destroyWeak(v11);
  _Block_object_dispose(va1, 8);
  objc_destroyWeak((id *)(v12 - 88));
  _Unwind_Resume(a1);
}

uint64_t sub_1001B6950(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_1001B6960(uint64_t a1)
{

}

void sub_1001B6968(uint64_t a1)
{
  NSObject *v2;
  void **WeakRetained;
  void **v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  os_activity_scope_state_s v8;

  v2 = _os_activity_create((void *)&_mh_execute_header, "com.apple.nfcd.reader.presenceCheckTimer", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  v8.opaque[0] = 0;
  v8.opaque[1] = 0;
  os_activity_scope_enter(v2, &v8);
  os_activity_scope_leave(&v8);

  WeakRetained = (void **)objc_loadWeakRetained((id *)(a1 + 48));
  v4 = WeakRetained;
  if (WeakRetained && (objc_msgSend(WeakRetained, "didEnd") & 1) == 0)
  {
    v5 = sub_100183AC0(v4[39], *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40));
    if ((_DWORD)v5 != 51)
    {
      if (!(_DWORD)v5)
      {
        objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), "startTimer:", 0.5);
        goto LABEL_10;
      }
      v5 = sub_10017EF78(v4[39], *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), 0);
    }
    v6 = NFSharedSignpostLog(v5);
    v7 = objc_claimAutoreleasedReturnValue(v6);
    if (os_signpost_enabled(v7))
    {
      LOWORD(v8.opaque[0]) = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v7, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "tagRemovalDetect", "", (uint8_t *)&v8, 2u);
    }

    sub_1001FBF60(v4[39]);
  }
LABEL_10:

}

BOOL sub_1001B95E0(id a1, NF7816App *a2, NSDictionary *a3)
{
  return (id)-[NF7816App type](a2, "type", a3) == (id)3;
}

BOOL sub_1001B9600(id a1, NF7816App *a2, NSDictionary *a3)
{
  return (id)-[NF7816App type](a2, "type", a3) != (id)3;
}

id sub_1001C29C8(uint64_t a1, unint64_t a2, size_t a3)
{
  _BYTE *v5;
  uint64_t v6;
  int64x2_t v7;
  uint64x2_t v8;
  int64x2_t v9;
  int32x2_t v10;
  int64x2_t v11;

  objc_opt_self(a1);
  v5 = malloc_type_calloc(1uLL, a3, 0x100004077774924uLL);
  v6 = 0;
  v7 = (int64x2_t)xmmword_10026A890;
  v8 = (uint64x2_t)vdupq_n_s64(a3 - 1);
  v9 = vdupq_n_s64(2uLL);
  do
  {
    v10 = vmovn_s64((int64x2_t)vcgeq_u64(v8, (uint64x2_t)v7));
    v11 = vaddq_s64(v7, vdupq_n_s64(1uLL));
    if ((v10.i8[0] & 1) != 0)
      v5[v6] = a2 >> (8 * (a3 - v11.i8[0]));
    if ((v10.i8[4] & 1) != 0)
      v5[v6 + 1] = a2 >> (8 * (a3 - v11.i8[8]));
    v6 += 2;
    v7 = vaddq_s64(v7, v9);
  }
  while (((a3 + 1) & 0xFFFFFFFFFFFFFFFELL) != v6);
  return objc_msgSend(objc_alloc((Class)NSData), "initWithBytesNoCopy:length:", v5, a3);
}

id sub_1001C2AB0(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  void *v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  id v13;
  void *v14;
  void *v15;
  void *specific;
  uint64_t Logger;
  void (*v18)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  NSObject *v25;
  objc_class *v26;
  int v27;
  const char *Name;
  uint8_t buf[4];
  int v31;
  __int16 v32;
  const char *v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  int v37;

  v3 = a2;
  v4 = objc_opt_self(a1);
  if (v3)
  {
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSCalendar currentCalendar](NSCalendar, "currentCalendar"));
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "components:fromDate:", 28, v3));

    v7 = (uint64_t)objc_msgSend(v6, "year");
    v8 = (unsigned __int128)(v7 / 10 * (__int128)0x6666666666666667) >> 64;
    buf[0] = ((int)objc_msgSend(v6, "year") % 10) | (16 * (v7 / 10 - 10 * ((v8 < 0) + (v8 >> 2))));
    v9 = (uint64_t)objc_msgSend(v6, "month");
    v10 = (unsigned __int128)(v9 / 10 * (__int128)0x6666666666666667) >> 64;
    buf[1] = ((int)objc_msgSend(v6, "month") % 10) | (16 * (v9 / 10 - 10 * ((v10 < 0) + (v10 >> 2))));
    v11 = (uint64_t)objc_msgSend(v6, "day");
    v12 = (unsigned __int128)(v11 / 10 * (__int128)0x6666666666666667) >> 64;
    buf[2] = ((char)objc_msgSend(v6, "day") % 10) | (16 * (v11 / 10 - 10 * ((v12 < 0) + (v12 >> 2))));
    v13 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", buf, 3);
    v14 = (void *)objc_claimAutoreleasedReturnValue(+[NFTLV TLVWithTag:value:](NFTLV, "TLVWithTag:value:", 154, v13));

  }
  else
  {
    v15 = (void *)v4;
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v18 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v15);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(v15);
      Name = sel_getName("_tlvForDate:");
      v22 = 45;
      if (isMetaClass)
        v22 = 43;
      v18(3, "%c[%{public}s %{public}s]:%i Invalid parameter", v22, ClassName, Name, 52);
    }
    v23 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v24 = NFSharedLogGetLogger(v23);
    v25 = objc_claimAutoreleasedReturnValue(v24);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      v26 = object_getClass(v15);
      if (class_isMetaClass(v26))
        v27 = 43;
      else
        v27 = 45;
      *(_DWORD *)buf = 67109890;
      v31 = v27;
      v32 = 2082;
      v33 = object_getClassName(v15);
      v34 = 2082;
      v35 = sel_getName("_tlvForDate:");
      v36 = 1024;
      v37 = 52;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid parameter", buf, 0x22u);
    }

    v14 = 0;
  }

  return v14;
}

id sub_1001C2DB0(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  unint64_t v5;
  id v6;
  void *v7;
  void *v8;
  void *specific;
  uint64_t Logger;
  void (*v11)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  NSObject *v17;
  objc_class *v18;
  int v19;
  const char *ClassName;
  const char *Name;
  uint8_t buf[4];
  int v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  id v32;

  v3 = a2;
  v4 = (void *)objc_opt_self(a1);
  v5 = sub_1001C2FBC((uint64_t)NFECommercePaymentRequestEncoder, v3);
  if (v5)
  {
    v6 = sub_1001C29C8((uint64_t)v4, v5, 2uLL);
    v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NFTLV TLVWithTag:value:](NFTLV, "TLVWithTag:value:", 40730, v7));

  }
  else
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v11 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v4);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(v4);
      Name = sel_getName("_tlvForCountryCode:");
      v14 = 45;
      if (isMetaClass)
        v14 = 43;
      v11(3, "%c[%{public}s %{public}s]:%i Invalid country code, %{public}@", v14, ClassName, Name, 75, v3);
    }
    v15 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v16 = NFSharedLogGetLogger(v15);
    v17 = objc_claimAutoreleasedReturnValue(v16);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      v18 = object_getClass(v4);
      if (class_isMetaClass(v18))
        v19 = 43;
      else
        v19 = 45;
      *(_DWORD *)buf = 67110146;
      v24 = v19;
      v25 = 2082;
      v26 = object_getClassName(v4);
      v27 = 2082;
      v28 = sel_getName("_tlvForCountryCode:");
      v29 = 1024;
      v30 = 75;
      v31 = 2114;
      v32 = v3;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid country code, %{public}@", buf, 0x2Cu);
    }

    v8 = 0;
  }

  return v8;
}

uint64_t sub_1001C2FBC(uint64_t a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  unsigned int v6;
  uint64_t v7;
  void *specific;
  uint64_t Logger;
  void (*v10)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  NSObject *v17;
  objc_class *v18;
  int v19;
  const char *v20;
  NSObject *v21;
  uint32_t v22;
  void *v23;
  uint64_t v24;
  void (*v25)(uint64_t, const char *, ...);
  objc_class *v26;
  _BOOL4 v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  objc_class *v31;
  int v32;
  const char *v34;
  const char *Name;
  const char *v36;
  uint8_t buf[4];
  int v38;
  __int16 v39;
  const char *v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  int v44;
  __int16 v45;
  id v46;

  v3 = a2;
  v4 = (id)objc_opt_self(a1);
  objc_sync_enter(v4);
  if (!qword_10032AB20)
    qword_10032AB20 = (uint64_t)&off_100306B28;
  objc_sync_exit(v4);

  if (objc_msgSend(v3, "length") != (id)2)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v10 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v4);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(v4);
      Name = sel_getName("_iso3166ForCountryCode:");
      v14 = 45;
      if (isMetaClass)
        v14 = 43;
      v10(3, "%c[%{public}s %{public}s]:%i Country code length too small", v14, ClassName, Name, 352);
    }
    v15 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v16 = NFSharedLogGetLogger(v15);
    v17 = objc_claimAutoreleasedReturnValue(v16);
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      goto LABEL_25;
    v18 = object_getClass(v4);
    if (class_isMetaClass(v18))
      v19 = 43;
    else
      v19 = 45;
    *(_DWORD *)buf = 67109890;
    v38 = v19;
    v39 = 2082;
    v40 = object_getClassName(v4);
    v41 = 2082;
    v42 = sel_getName("_iso3166ForCountryCode:");
    v43 = 1024;
    v44 = 352;
    v20 = "%c[%{public}s %{public}s]:%i Country code length too small";
    v21 = v17;
    v22 = 34;
    goto LABEL_24;
  }
  v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)qword_10032AB20, "objectForKey:", v3));
  v6 = objc_msgSend(v5, "unsignedShortValue");

  if (!v6)
  {
    v23 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v24 = NFLogGetLogger(v23);
    if (v24)
    {
      v25 = (void (*)(uint64_t, const char *, ...))v24;
      v26 = object_getClass(v4);
      v27 = class_isMetaClass(v26);
      v34 = object_getClassName(v4);
      v36 = sel_getName("_iso3166ForCountryCode:");
      v28 = 45;
      if (v27)
        v28 = 43;
      v25(3, "%c[%{public}s %{public}s]:%i Invalid country code, %{public}@", v28, v34, v36, 358, v3);
    }
    v29 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v30 = NFSharedLogGetLogger(v29);
    v17 = objc_claimAutoreleasedReturnValue(v30);
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      goto LABEL_25;
    v31 = object_getClass(v4);
    if (class_isMetaClass(v31))
      v32 = 43;
    else
      v32 = 45;
    *(_DWORD *)buf = 67110146;
    v38 = v32;
    v39 = 2082;
    v40 = object_getClassName(v4);
    v41 = 2082;
    v42 = sel_getName("_iso3166ForCountryCode:");
    v43 = 1024;
    v44 = 358;
    v45 = 2114;
    v46 = v3;
    v20 = "%c[%{public}s %{public}s]:%i Invalid country code, %{public}@";
    v21 = v17;
    v22 = 44;
LABEL_24:
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, v20, buf, v22);
LABEL_25:

    v7 = 0;
    goto LABEL_26;
  }
  v7 = v6;
LABEL_26:

  return v7;
}

id sub_1001C32F0(uint64_t a1, void *a2, _QWORD *a3)
{
  id v5;
  void *v6;
  int NumericCode;
  int v8;
  int DefaultFractionDigits;
  void *v10;
  uint64_t v11;
  void (*v12)(uint64_t, const char *, ...);
  objc_class *v13;
  _BOOL4 v14;
  const char *v15;
  const char *v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  NSObject *v20;
  objc_class *v21;
  int v22;
  const char *v23;
  const char *v24;
  void *v25;
  void *specific;
  uint64_t Logger;
  void (*v28)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  NSObject *v35;
  objc_class *v36;
  int v37;
  const char *v38;
  NSObject *v39;
  uint32_t v40;
  void *v41;
  uint64_t v42;
  void (*v43)(uint64_t, const char *, ...);
  objc_class *v44;
  _BOOL4 v45;
  uint64_t v46;
  void *v47;
  uint64_t v48;
  objc_class *v49;
  int v50;
  int v51;
  unsigned int v52;
  id v53;
  const char *v55;
  const char *Name;
  const char *v57;
  int v58;
  uint8_t buf[4];
  int v60;
  __int16 v61;
  const char *v62;
  __int16 v63;
  const char *v64;
  __int16 v65;
  int v66;
  __int16 v67;
  id v68;
  uint64_t v69;

  v5 = a2;
  v6 = (void *)objc_opt_self(a1);
  if (objc_msgSend(v5, "length") != (id)3)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v28 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v6);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(v6);
      Name = sel_getName("_tlvForCurrency:decimalDigits:");
      v32 = 45;
      if (isMetaClass)
        v32 = 43;
      v28(3, "%c[%{public}s %{public}s]:%i Invalid parameter length", v32, ClassName, Name, 86);
    }
    v33 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v34 = NFSharedLogGetLogger(v33);
    v35 = objc_claimAutoreleasedReturnValue(v34);
    if (!os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      goto LABEL_34;
    v36 = object_getClass(v6);
    if (class_isMetaClass(v36))
      v37 = 43;
    else
      v37 = 45;
    *(_DWORD *)buf = 67109890;
    v60 = v37;
    v61 = 2082;
    v62 = object_getClassName(v6);
    v63 = 2082;
    v64 = sel_getName("_tlvForCurrency:decimalDigits:");
    v65 = 1024;
    v66 = 86;
    v38 = "%c[%{public}s %{public}s]:%i Invalid parameter length";
    v39 = v35;
    v40 = 34;
    goto LABEL_33;
  }
  v69 = 0;
  objc_msgSend(v5, "getCharacters:range:", &v69, 0, 3);
  NumericCode = ucurr_getNumericCode(&v69);
  if (!NumericCode)
  {
    v41 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v42 = NFLogGetLogger(v41);
    if (v42)
    {
      v43 = (void (*)(uint64_t, const char *, ...))v42;
      v44 = object_getClass(v6);
      v45 = class_isMetaClass(v44);
      v55 = object_getClassName(v6);
      v57 = sel_getName("_tlvForCurrency:decimalDigits:");
      v46 = 45;
      if (v45)
        v46 = 43;
      v43(3, "%c[%{public}s %{public}s]:%i Unable to determine ISO currency code for %{public}@", v46, v55, v57, 95, v5);
    }
    v47 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v48 = NFSharedLogGetLogger(v47);
    v35 = objc_claimAutoreleasedReturnValue(v48);
    if (!os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      goto LABEL_34;
    v49 = object_getClass(v6);
    if (class_isMetaClass(v49))
      v50 = 43;
    else
      v50 = 45;
    *(_DWORD *)buf = 67110146;
    v60 = v50;
    v61 = 2082;
    v62 = object_getClassName(v6);
    v63 = 2082;
    v64 = sel_getName("_tlvForCurrency:decimalDigits:");
    v65 = 1024;
    v66 = 95;
    v67 = 2114;
    v68 = v5;
    v38 = "%c[%{public}s %{public}s]:%i Unable to determine ISO currency code for %{public}@";
    v39 = v35;
    v40 = 44;
LABEL_33:
    _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, v38, buf, v40);
LABEL_34:

    v25 = 0;
    goto LABEL_39;
  }
  v8 = NumericCode;
  v58 = 0;
  DefaultFractionDigits = ucurr_getDefaultFractionDigits(&v69, &v58);
  if (DefaultFractionDigits > 0 || v58 < 1)
  {
    if (a3)
      *a3 = DefaultFractionDigits;
    v51 = v8 / 100 % 100;
    v52 = (((103 * (char)v51) >> 15) & 1) + ((103 * (char)v51) >> 10);
    v53 = sub_1001C29C8((uint64_t)v6, (unsigned __int16)(((_WORD)v52 << 12) | (((_WORD)v51 - 10 * (_WORD)v52) << 8)) | (unint64_t)((v8 % 100 - 10 * ((((103 * (v8 % 100)) & 0x8000) != 0) + ((103 * (v8 % 100)) >> 10))) | (16 * ((((103 * (v8 % 100)) & 0x8000) != 0) + ((103 * (v8 % 100)) >> 10)))), 2uLL);
    v20 = objc_claimAutoreleasedReturnValue(v53);
    v25 = (void *)objc_claimAutoreleasedReturnValue(+[NFTLV TLVWithTag:value:](NFTLV, "TLVWithTag:value:", 24362, v20));
  }
  else
  {
    v10 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v11 = NFLogGetLogger(v10);
    if (v11)
    {
      v12 = (void (*)(uint64_t, const char *, ...))v11;
      v13 = object_getClass(v6);
      v14 = class_isMetaClass(v13);
      v15 = object_getClassName(v6);
      v16 = sel_getName("_tlvForCurrency:decimalDigits:");
      v17 = 45;
      if (v14)
        v17 = 43;
      v12(3, "%c[%{public}s %{public}s]:%i Invalid fractional digits: 0x%x", v17, v15, v16, 102, v58);
    }
    v18 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v19 = NFSharedLogGetLogger(v18);
    v20 = objc_claimAutoreleasedReturnValue(v19);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      v21 = object_getClass(v6);
      if (class_isMetaClass(v21))
        v22 = 43;
      else
        v22 = 45;
      v23 = object_getClassName(v6);
      v24 = sel_getName("_tlvForCurrency:decimalDigits:");
      *(_DWORD *)buf = 67110146;
      v60 = v22;
      v61 = 2082;
      v62 = v23;
      v63 = 2082;
      v64 = v24;
      v65 = 1024;
      v66 = 102;
      v67 = 1024;
      LODWORD(v68) = v58;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid fractional digits: 0x%x", buf, 0x28u);
    }
    v25 = 0;
  }

LABEL_39:
  return v25;
}

id sub_1001C380C(uint64_t a1, void *a2, uint64_t a3)
{
  id v5;
  void *v6;
  void *v7;
  uint64_t v8;
  void (*v9)(uint64_t, const char *, ...);
  objc_class *v10;
  _BOOL4 v11;
  const char *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  NSObject *v16;
  objc_class *v17;
  int v18;
  const char *v19;
  void *specific;
  uint64_t Logger;
  void (*v22)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  objc_class *v29;
  int v30;
  void *v31;
  uint64_t v32;
  void (*v33)(uint64_t, const char *, ...);
  objc_class *v34;
  _BOOL4 v35;
  const char *v36;
  uint64_t v37;
  void *v38;
  uint64_t v39;
  objc_class *v40;
  int v41;
  void *v42;
  unsigned int v43;
  void *v44;
  uint64_t v45;
  void (*v46)(uint64_t, const char *, ...);
  objc_class *v47;
  _BOOL4 v48;
  const char *v49;
  uint64_t v50;
  void *v51;
  uint64_t v52;
  objc_class *v53;
  int v54;
  void *v55;
  id v56;
  void *v57;
  unsigned __int8 v58;
  NSObject *v59;
  void *v60;
  void *v61;
  uint64_t v62;
  void (*v63)(uint64_t, const char *, ...);
  objc_class *v64;
  _BOOL4 v65;
  const char *v66;
  uint64_t v67;
  void *v68;
  uint64_t v69;
  objc_class *v70;
  int v71;
  void *v73;
  unsigned int v74;
  unint64_t v75;
  void *v76;
  unint64_t v77;
  void *v78;
  uint64_t v79;
  void (*v80)(uint64_t, const char *, ...);
  objc_class *v81;
  _BOOL4 v82;
  const char *v83;
  uint64_t v84;
  void *v85;
  uint64_t v86;
  NSObject *v87;
  objc_class *v88;
  int v89;
  const char *v90;
  const char *v91;
  void *v92;
  uint64_t v93;
  void (*v94)(uint64_t, const char *, ...);
  objc_class *v95;
  _BOOL4 v96;
  const char *v97;
  uint64_t v98;
  void *v99;
  uint64_t v100;
  objc_class *v101;
  int v102;
  const char *v103;
  const char *v104;
  uint64_t v105;
  BOOL v106;
  const char *v107;
  const char *Name;
  const char *v109;
  const char *v110;
  const char *v111;
  const char *v112;
  const char *v113;
  int v114;
  __int16 v115;
  uint8_t buf[4];
  int v117;
  __int16 v118;
  const char *v119;
  __int16 v120;
  const char *v121;
  __int16 v122;
  int v123;
  __int16 v124;
  uint64_t v125;
  __int16 v126;
  unint64_t v127;

  v5 = a2;
  v6 = (void *)objc_opt_self(a1);
  if (!v5)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v22 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v6);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(v6);
      Name = sel_getName("_tlvForAmount:decimalDigits:");
      v26 = 45;
      if (isMetaClass)
        v26 = 43;
      v22(3, "%c[%{public}s %{public}s]:%i Invalid parameter", v26, ClassName, Name, 116);
    }
    v27 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v28 = NFSharedLogGetLogger(v27);
    v16 = objc_claimAutoreleasedReturnValue(v28);
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      goto LABEL_54;
    v29 = object_getClass(v6);
    if (class_isMetaClass(v29))
      v30 = 43;
    else
      v30 = 45;
    *(_DWORD *)buf = 67109890;
    v117 = v30;
    v118 = 2082;
    v119 = object_getClassName(v6);
    v120 = 2082;
    v121 = sel_getName("_tlvForAmount:decimalDigits:");
    v122 = 1024;
    v123 = 116;
    v19 = "%c[%{public}s %{public}s]:%i Invalid parameter";
    goto LABEL_53;
  }
  if (a3 < 0)
  {
    v31 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v32 = NFLogGetLogger(v31);
    if (v32)
    {
      v33 = (void (*)(uint64_t, const char *, ...))v32;
      v34 = object_getClass(v6);
      v35 = class_isMetaClass(v34);
      v36 = object_getClassName(v6);
      v109 = sel_getName("_tlvForAmount:decimalDigits:");
      v37 = 45;
      if (v35)
        v37 = 43;
      v33(3, "%c[%{public}s %{public}s]:%i Digits is negative", v37, v36, v109, 121);
    }
    v38 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v39 = NFSharedLogGetLogger(v38);
    v16 = objc_claimAutoreleasedReturnValue(v39);
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      goto LABEL_54;
    v40 = object_getClass(v6);
    if (class_isMetaClass(v40))
      v41 = 43;
    else
      v41 = 45;
    *(_DWORD *)buf = 67109890;
    v117 = v41;
    v118 = 2082;
    v119 = object_getClassName(v6);
    v120 = 2082;
    v121 = sel_getName("_tlvForAmount:decimalDigits:");
    v122 = 1024;
    v123 = 121;
    v19 = "%c[%{public}s %{public}s]:%i Digits is negative";
    goto LABEL_53;
  }
  if ((unint64_t)a3 < 0x10000)
  {
    v42 = (void *)objc_claimAutoreleasedReturnValue(+[NSDecimalNumber notANumber](NSDecimalNumber, "notANumber"));
    v43 = objc_msgSend(v5, "isEqualToNumber:", v42);

    if (v43)
    {
      v44 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v45 = NFLogGetLogger(v44);
      if (v45)
      {
        v46 = (void (*)(uint64_t, const char *, ...))v45;
        v47 = object_getClass(v6);
        v48 = class_isMetaClass(v47);
        v49 = object_getClassName(v6);
        v110 = sel_getName("_tlvForAmount:decimalDigits:");
        v50 = 45;
        if (v48)
          v50 = 43;
        v46(3, "%c[%{public}s %{public}s]:%i Value is NaN", v50, v49, v110, 132);
      }
      v51 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v52 = NFSharedLogGetLogger(v51);
      v16 = objc_claimAutoreleasedReturnValue(v52);
      if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        goto LABEL_54;
      v53 = object_getClass(v6);
      if (class_isMetaClass(v53))
        v54 = 43;
      else
        v54 = 45;
      *(_DWORD *)buf = 67109890;
      v117 = v54;
      v118 = 2082;
      v119 = object_getClassName(v6);
      v120 = 2082;
      v121 = sel_getName("_tlvForAmount:decimalDigits:");
      v122 = 1024;
      v123 = 132;
      v19 = "%c[%{public}s %{public}s]:%i Value is NaN";
      goto LABEL_53;
    }
    v55 = (void *)objc_claimAutoreleasedReturnValue(+[NSDecimalNumber zero](NSDecimalNumber, "zero"));
    v56 = objc_msgSend(v5, "compare:", v55);

    if (v56 == (id)-1)
    {
      v61 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v62 = NFLogGetLogger(v61);
      if (v62)
      {
        v63 = (void (*)(uint64_t, const char *, ...))v62;
        v64 = object_getClass(v6);
        v65 = class_isMetaClass(v64);
        v66 = object_getClassName(v6);
        v111 = sel_getName("_tlvForAmount:decimalDigits:");
        v67 = 45;
        if (v65)
          v67 = 43;
        v63(3, "%c[%{public}s %{public}s]:%i Value is negative", v67, v66, v111, 138);
      }
      v68 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v69 = NFSharedLogGetLogger(v68);
      v16 = objc_claimAutoreleasedReturnValue(v69);
      if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        goto LABEL_54;
      v70 = object_getClass(v6);
      if (class_isMetaClass(v70))
        v71 = 43;
      else
        v71 = 45;
      *(_DWORD *)buf = 67109890;
      v117 = v71;
      v118 = 2082;
      v119 = object_getClassName(v6);
      v120 = 2082;
      v121 = sel_getName("_tlvForAmount:decimalDigits:");
      v122 = 1024;
      v123 = 138;
      v19 = "%c[%{public}s %{public}s]:%i Value is negative";
      goto LABEL_53;
    }
    v115 = 0;
    v114 = 0;
    v57 = (void *)objc_claimAutoreleasedReturnValue(+[NSDecimalNumber zero](NSDecimalNumber, "zero"));
    v58 = objc_msgSend(v5, "isEqualToNumber:", v57);

    if ((v58 & 1) != 0)
      goto LABEL_43;
    v73 = (void *)objc_claimAutoreleasedReturnValue(+[NSDecimalNumber one](NSDecimalNumber, "one"));
    v74 = objc_msgSend(v5, "isEqualToNumber:", v73);

    if (v74)
    {
      v75 = (unint64_t)__exp10((double)a3);
    }
    else
    {
      v76 = (void *)objc_claimAutoreleasedReturnValue(+[NSDecimalNumberHandler decimalNumberHandlerWithRoundingMode:scale:raiseOnExactness:raiseOnOverflow:raiseOnUnderflow:raiseOnDivideByZero:](NSDecimalNumberHandler, "decimalNumberHandlerWithRoundingMode:scale:raiseOnExactness:raiseOnOverflow:raiseOnUnderflow:raiseOnDivideByZero:", 0, (__int16)a3, 0, 0, 0, 0));
      v59 = objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "decimalNumberByRoundingAccordingToBehavior:", v76));

      if (v59)
        -[NSObject decimalValue](v59, "decimalValue");
      v77 = (unint64_t)__exp10((double)a3);
      if (!is_mul_ok(0, v77))
      {
        v78 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v79 = NFLogGetLogger(v78);
        if (v79)
        {
          v80 = (void (*)(uint64_t, const char *, ...))v79;
          v81 = object_getClass(v6);
          v82 = class_isMetaClass(v81);
          v83 = object_getClassName(v6);
          v112 = sel_getName("_tlvForAmount:decimalDigits:");
          v84 = 45;
          if (v82)
            v84 = 43;
          v80(3, "%c[%{public}s %{public}s]:%i mantissa overflow during mult of %llu and %lld", v84, v83, v112, 185, 0, v77);
        }
        v85 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v86 = NFSharedLogGetLogger(v85);
        v87 = objc_claimAutoreleasedReturnValue(v86);
        if (os_log_type_enabled(v87, OS_LOG_TYPE_ERROR))
        {
          v88 = object_getClass(v6);
          if (class_isMetaClass(v88))
            v89 = 43;
          else
            v89 = 45;
          v90 = object_getClassName(v6);
          v91 = sel_getName("_tlvForAmount:decimalDigits:");
          *(_DWORD *)buf = 67110402;
          v117 = v89;
          v118 = 2082;
          v119 = v90;
          v120 = 2082;
          v121 = v91;
          v122 = 1024;
          v123 = 185;
          v124 = 2048;
          v125 = 0;
          v126 = 2048;
          v127 = v77;
          _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i mantissa overflow during mult of %llu and %lld", buf, 0x36u);
        }

        goto LABEL_87;
      }
      v75 = 0;

    }
    if (v75 <= 0xE8D4A50FFFLL)
    {
      if (v75)
      {
        v105 = 5;
        do
        {
          *((_BYTE *)&v114 + v105) = (v75 % 0x64 % 0xA) | (16 * (v75 % 0x64 / 0xA));
          if ((unint64_t)(v105 + 1) < 2)
            break;
          --v105;
          v106 = v75 > 0x63;
          v75 /= 0x64uLL;
        }
        while (v106);
      }
LABEL_43:
      v59 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &v114, 6);
      v60 = (void *)objc_claimAutoreleasedReturnValue(+[NFTLV TLVWithTag:value:](NFTLV, "TLVWithTag:value:", 40706, v59));
LABEL_88:

      goto LABEL_55;
    }
    v92 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v93 = NFLogGetLogger(v92);
    if (v93)
    {
      v94 = (void (*)(uint64_t, const char *, ...))v93;
      v95 = object_getClass(v6);
      v96 = class_isMetaClass(v95);
      v97 = object_getClassName(v6);
      v113 = sel_getName("_tlvForAmount:decimalDigits:");
      v98 = 45;
      if (v96)
        v98 = 43;
      v94(3, "%c[%{public}s %{public}s]:%i Size of mantissa > provided buffer size.", v98, v97, v113, 194);
    }
    v99 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v100 = NFSharedLogGetLogger(v99);
    v59 = objc_claimAutoreleasedReturnValue(v100);
    if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
    {
      v101 = object_getClass(v6);
      if (class_isMetaClass(v101))
        v102 = 43;
      else
        v102 = 45;
      v103 = object_getClassName(v6);
      v104 = sel_getName("_tlvForAmount:decimalDigits:");
      *(_DWORD *)buf = 67109890;
      v117 = v102;
      v118 = 2082;
      v119 = v103;
      v120 = 2082;
      v121 = v104;
      v122 = 1024;
      v123 = 194;
      _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Size of mantissa > provided buffer size.", buf, 0x22u);
    }
LABEL_87:
    v60 = 0;
    goto LABEL_88;
  }
  v7 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v8 = NFLogGetLogger(v7);
  if (v8)
  {
    v9 = (void (*)(uint64_t, const char *, ...))v8;
    v10 = object_getClass(v6);
    v11 = class_isMetaClass(v10);
    v12 = object_getClassName(v6);
    v107 = sel_getName("_tlvForAmount:decimalDigits:");
    v13 = 45;
    if (v11)
      v13 = 43;
    v9(3, "%c[%{public}s %{public}s]:%i Digits is too large", v13, v12, v107, 126);
  }
  v14 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v15 = NFSharedLogGetLogger(v14);
  v16 = objc_claimAutoreleasedReturnValue(v15);
  if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    goto LABEL_54;
  v17 = object_getClass(v6);
  if (class_isMetaClass(v17))
    v18 = 43;
  else
    v18 = 45;
  *(_DWORD *)buf = 67109890;
  v117 = v18;
  v118 = 2082;
  v119 = object_getClassName(v6);
  v120 = 2082;
  v121 = sel_getName("_tlvForAmount:decimalDigits:");
  v122 = 1024;
  v123 = 126;
  v19 = "%c[%{public}s %{public}s]:%i Digits is too large";
LABEL_53:
  _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, v19, buf, 0x22u);
LABEL_54:

  v60 = 0;
LABEL_55:

  return v60;
}

NSMutableData *sub_1001C43B8(uint64_t a1, void *a2, void *a3, NSMutableData *a4)
{
  id v7;
  id v8;
  void *v9;
  void *v10;
  NSMutableArray *v11;
  void *v12;
  id v13;
  void *v14;
  void *v15;
  id v16;
  void *v17;
  void *v18;
  id v19;
  void *v20;
  void *v21;
  id v22;
  void *v23;
  unint64_t v24;
  uint64_t v25;
  id v26;
  void *v27;
  void *v28;
  id v29;
  uint64_t v30;
  void *v31;
  id v32;
  void *v33;
  void *v34;
  void *v35;
  NSMutableData *v36;
  id v37;
  void *v38;
  uint64_t v39;
  void *v40;
  _UNKNOWN **v41;
  void *v42;
  void *v43;
  uint64_t v44;
  void (*v45)(uint64_t, const char *, ...);
  objc_class *v46;
  _BOOL4 v47;
  const char *v48;
  uint64_t v49;
  void *v50;
  uint64_t v51;
  NSObject *v52;
  objc_class *v53;
  int v54;
  id v55;
  void *v56;
  void *v57;
  id v58;
  id v59;
  _QWORD *v60;
  _QWORD *v61;
  void *v62;
  uint64_t v63;
  void (*v64)(uint64_t, const char *, ...);
  objc_class *v65;
  _BOOL4 v66;
  const char *v67;
  uint64_t v68;
  void *v69;
  uint64_t v70;
  NSObject *v71;
  objc_class *v72;
  int v73;
  void *v74;
  id v75;
  id v76;
  id v77;
  _QWORD *v78;
  _QWORD *v79;
  void *specific;
  uint64_t Logger;
  void (*v82)(uint64_t, const char *, ...);
  objc_class *Class;
  const char *Name;
  uint64_t v85;
  void *v86;
  uint64_t v87;
  NSObject *v88;
  objc_class *v89;
  int v90;
  const char *ClassName;
  const char *v92;
  void *v93;
  void *v95;
  uint64_t v96;
  void (*v97)(uint64_t, const char *, ...);
  objc_class *v98;
  _BOOL4 v99;
  void *v100;
  const char *v101;
  uint64_t v102;
  void *v103;
  uint64_t v104;
  NSObject *v105;
  objc_class *v106;
  int v107;
  const char *v108;
  id v109;
  void *v110;
  const char *v111;
  const char *v112;
  id v113;
  id v114;
  void *v115;
  void *v116;
  uint64_t v117;
  void (*v118)(uint64_t, const char *, ...);
  objc_class *v119;
  _BOOL4 v120;
  BOOL v121;
  uint64_t v122;
  void *v123;
  uint64_t v124;
  NSObject *v125;
  objc_class *v126;
  void *v127;
  id v128;
  void *v129;
  int v130;
  const char *v131;
  const char *v132;
  id v133;
  id v134;
  void *v135;
  void *v136;
  void *v137;
  void *v138;
  void *v139;
  void *v140;
  void *v141;
  void *v142;
  void *v143;
  void *v144;
  void *v145;
  void *v146;
  void *v147;
  const char *v148;
  const char *v149;
  const char *v150;
  const char *v151;
  const char *v152;
  const char *v153;
  void *v154;
  id v155;
  id v156;
  void *v157;
  void *v158;
  _BOOL4 isMetaClass;
  int v160;
  void *v161;
  void *v162;
  const char *sel;
  uint64_t v164;
  _QWORD v165[4];
  _QWORD v166[4];
  _QWORD v167[4];
  _QWORD v168[4];
  _QWORD v169[4];
  _QWORD v170[4];
  _QWORD v171[4];
  _QWORD v172[4];
  _QWORD v173[4];
  _QWORD v174[4];
  _QWORD v175[4];
  _QWORD v176[4];
  _QWORD v177[4];
  _QWORD v178[4];
  _QWORD v179[4];
  _QWORD v180[4];
  uint8_t buf[8];
  _BYTE v182[26];
  __int16 v183;
  id v184;
  NSErrorUserInfoKey v185;
  const __CFString *v186;
  const __CFString *v187;
  NSErrorUserInfoKey v188;

  v7 = a2;
  v8 = a3;
  v9 = (void *)objc_opt_self(a1);
  if (v7)
  {
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "merchantData"));

    if (v10)
    {
      v164 = 0;
      v11 = objc_opt_new(NSMutableArray);
      v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "countryCode"));
      v13 = sub_1001C2DB0((uint64_t)v9, v12);
      v14 = (void *)objc_claimAutoreleasedReturnValue(v13);

      if (v14)
      {
        -[NSMutableArray addObject:](v11, "addObject:", v14);
        v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "transactionDate"));
        v16 = sub_1001C2AB0((uint64_t)v9, v15);
        v17 = (void *)objc_claimAutoreleasedReturnValue(v16);

        if (v17)
        {
          -[NSMutableArray addObject:](v11, "addObject:", v17);
          v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "currencyCode"));
          v19 = sub_1001C32F0((uint64_t)v9, v18, &v164);
          v20 = (void *)objc_claimAutoreleasedReturnValue(v19);

          if (v20)
          {
            -[NSMutableArray addObject:](v11, "addObject:", v20);
            v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "transactionAmount"));
            v22 = sub_1001C380C((uint64_t)v9, v21, v164);
            v23 = (void *)objc_claimAutoreleasedReturnValue(v22);

            if (v23)
            {
              -[NSMutableArray addObject:](v11, "addObject:", v23);
              v24 = objc_msgSend(v7, "unpredictableNumber");
              v25 = objc_opt_self(v9);
              v26 = sub_1001C29C8(v25, v24, 4uLL);
              v27 = (void *)objc_claimAutoreleasedReturnValue(v26);
              v28 = (void *)objc_claimAutoreleasedReturnValue(+[NFTLV TLVWithTag:value:](NFTLV, "TLVWithTag:value:", 40759, v27));

              if (v28)
              {
                -[NSMutableArray addObject:](v11, "addObject:", v28);
                v29 = objc_msgSend(v7, "merchantCapabilities");
                v30 = objc_opt_self(v9);
                v31 = (void *)v30;
                if ((v29 & 0x43) == 0 || (v29 & 0xBC) != 0)
                {
                  specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  Logger = NFLogGetLogger(specific);
                  if (Logger)
                  {
                    v82 = (void (*)(uint64_t, const char *, ...))Logger;
                    Class = object_getClass(v31);
                    isMetaClass = class_isMetaClass(Class);
                    sel = object_getClassName(v31);
                    Name = sel_getName("_tlvForMerchantCapabilities:");
                    v85 = 45;
                    if (isMetaClass)
                      v85 = 43;
                    v82(3, "%c[%{public}s %{public}s]:%i Invalid merchant capabilities 0x%x", v85, sel, Name, 218, v29);
                  }
                  v86 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  v87 = NFSharedLogGetLogger(v86);
                  v88 = objc_claimAutoreleasedReturnValue(v87);
                  if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR))
                  {
                    v89 = object_getClass(v31);
                    if (class_isMetaClass(v89))
                      v90 = 43;
                    else
                      v90 = 45;
                    v160 = v90;
                    ClassName = object_getClassName(v31);
                    v92 = sel_getName("_tlvForMerchantCapabilities:");
                    *(_DWORD *)buf = 67110146;
                    *(_DWORD *)&buf[4] = v160;
                    *(_WORD *)v182 = 2082;
                    *(_QWORD *)&v182[2] = ClassName;
                    *(_WORD *)&v182[10] = 2082;
                    *(_QWORD *)&v182[12] = v92;
                    *(_WORD *)&v182[20] = 1024;
                    *(_DWORD *)&v182[22] = 218;
                    v183 = 1024;
                    LODWORD(v184) = (_DWORD)v29;
                    _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid merchant capabilities 0x%x", buf, 0x28u);
                  }

                }
                else
                {
                  v32 = sub_1001C29C8(v30, v29 | 0x80, 1uLL);
                  v33 = (void *)objc_claimAutoreleasedReturnValue(v32);
                  v34 = (void *)objc_claimAutoreleasedReturnValue(+[NFTLV TLVWithTag:value:](NFTLV, "TLVWithTag:value:", 40757, v33));

                  if (v34)
                  {
                    -[NSMutableArray addObject:](v11, "addObject:", v34);
                    if (v8)
                    {
                      v35 = (void *)objc_claimAutoreleasedReturnValue(+[NFTLV TLVWithTag:value:](NFTLV, "TLVWithTag:value:", 153, v8));
                      -[NSMutableArray addObject:](v11, "addObject:", v35);

                    }
                    v36 = objc_opt_new(NSMutableData);
                    v37 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "appletIdentifier"));
                    v38 = (void *)objc_opt_self(v9);
                    if (v37)
                    {
                      v39 = objc_claimAutoreleasedReturnValue(+[NSData NF_dataWithHexString:](NSData, "NF_dataWithHexString:", v37));
                      if (v39)
                      {
                        v40 = (void *)v39;
                        v41 = &AMFDRSealingMapCopyLocalData_ptr;
                        v42 = (void *)objc_claimAutoreleasedReturnValue(+[NFTLV TLVWithTag:value:](NFTLV, "TLVWithTag:value:", 79, v39));
LABEL_90:

                        goto LABEL_91;
                      }
                      v116 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                      v117 = NFLogGetLogger(v116);
                      v162 = v34;
                      if (v117)
                      {
                        v118 = (void (*)(uint64_t, const char *, ...))v117;
                        v119 = object_getClass(v38);
                        v120 = class_isMetaClass(v119);
                        v149 = object_getClassName(v38);
                        v153 = sel_getName("_tlvForApplicationIdentifier:error:");
                        v121 = !v120;
                        v34 = v162;
                        v122 = 45;
                        if (!v121)
                          v122 = 43;
                        v118(3, "%c[%{public}s %{public}s]:%i Invalid identifier: %{public}@", v122, v149, v153, 41, v37);
                      }
                      v123 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                      v124 = NFSharedLogGetLogger(v123);
                      v125 = objc_claimAutoreleasedReturnValue(v124);
                      if (os_log_type_enabled(v125, OS_LOG_TYPE_ERROR))
                      {
                        v126 = object_getClass(v38);
                        v121 = !class_isMetaClass(v126);
                        v127 = v38;
                        v128 = v37;
                        v129 = v34;
                        if (v121)
                          v130 = 45;
                        else
                          v130 = 43;
                        v131 = object_getClassName(v127);
                        v132 = sel_getName("_tlvForApplicationIdentifier:error:");
                        *(_DWORD *)buf = 67110146;
                        *(_DWORD *)&buf[4] = v130;
                        v34 = v129;
                        v37 = v128;
                        *(_WORD *)v182 = 2082;
                        *(_QWORD *)&v182[2] = v131;
                        *(_WORD *)&v182[10] = 2082;
                        *(_QWORD *)&v182[12] = v132;
                        *(_WORD *)&v182[20] = 1024;
                        *(_DWORD *)&v182[22] = 41;
                        v183 = 2114;
                        v184 = v128;
                        _os_log_impl((void *)&_mh_execute_header, v125, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid identifier: %{public}@", buf, 0x2Cu);
                      }

                      if (a4)
                      {
                        v156 = objc_alloc((Class)NSError);
                        v154 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
                        v185 = NSLocalizedDescriptionKey;
                        v158 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid Parameter"));
                        *(_QWORD *)buf = v158;
                        *(_QWORD *)v182 = &off_100301280;
                        v186 = CFSTR("Line");
                        v187 = CFSTR("Method");
                        v133 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_tlvForApplicationIdentifier:error:"));
                        *(_QWORD *)&v182[8] = v133;
                        v188 = NSDebugDescriptionErrorKey;
                        v134 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_tlvForApplicationIdentifier:error:"), 42);
                        *(_QWORD *)&v182[16] = v134;
                        v135 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v185, 4));
                        a4->super.super.isa = (Class)objc_msgSend(v156, "initWithDomain:code:userInfo:", v154, 10, v135);

                        v34 = v162;
                      }
                      v40 = 0;
                    }
                    else
                    {
                      v95 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                      v96 = NFLogGetLogger(v95);
                      if (v96)
                      {
                        v97 = (void (*)(uint64_t, const char *, ...))v96;
                        v98 = object_getClass(v38);
                        v99 = class_isMetaClass(v98);
                        v100 = v34;
                        v101 = object_getClassName(v38);
                        v152 = sel_getName("_tlvForApplicationIdentifier:error:");
                        v102 = 45;
                        if (v99)
                          v102 = 43;
                        v148 = v101;
                        v34 = v100;
                        v37 = 0;
                        v97(3, "%c[%{public}s %{public}s]:%i Invalid parameter length", v102, v148, v152, 34);
                      }
                      v103 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                      v104 = NFSharedLogGetLogger(v103);
                      v105 = objc_claimAutoreleasedReturnValue(v104);
                      if (os_log_type_enabled(v105, OS_LOG_TYPE_ERROR))
                      {
                        v106 = object_getClass(v38);
                        if (class_isMetaClass(v106))
                          v107 = 43;
                        else
                          v107 = 45;
                        v108 = object_getClassName(v38);
                        v109 = v37;
                        v110 = v34;
                        v111 = v108;
                        v112 = sel_getName("_tlvForApplicationIdentifier:error:");
                        *(_DWORD *)buf = 67109890;
                        *(_DWORD *)&buf[4] = v107;
                        *(_WORD *)v182 = 2082;
                        *(_QWORD *)&v182[2] = v111;
                        v34 = v110;
                        v37 = v109;
                        *(_WORD *)&v182[10] = 2082;
                        *(_QWORD *)&v182[12] = v112;
                        *(_WORD *)&v182[20] = 1024;
                        *(_DWORD *)&v182[22] = 34;
                        _os_log_impl((void *)&_mh_execute_header, v105, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid parameter length", buf, 0x22u);
                      }

                      if (!a4)
                      {
                        v42 = 0;
                        v41 = &AMFDRSealingMapCopyLocalData_ptr;
LABEL_91:

                        if (v42)
                        {
                          v136 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v42, "asData"));
                          -[NSMutableData appendData:](v36, "appendData:", v136);

                          v137 = v41[225];
                          v138 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "merchantData"));
                          v139 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v137, "TLVWithTag:value:", 40726, v138));
                          v140 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v139, "asData"));
                          -[NSMutableData appendData:](v36, "appendData:", v140);

                          if ((objc_msgSend(v7, "merchantCapabilities") & 0x40) != 0)
                          {
                            v141 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "networkMerchantIdentifier"));

                            if (v141)
                            {
                              v142 = v41[225];
                              v143 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "networkMerchantIdentifier"));
                              v144 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v142, "TLVWithTag:value:", 57206, v143));
                              v145 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v144, "asData"));
                              -[NSMutableData appendData:](v36, "appendData:", v145);

                            }
                          }
                          v146 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v41[225], "TLVWithTag:children:", 226, v11));
                          v147 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v146, "asData"));
                          -[NSMutableData appendData:](v36, "appendData:", v147);

                          v36 = v36;
                          a4 = v36;
                          goto LABEL_63;
                        }
LABEL_62:
                        a4 = 0;
LABEL_63:

                        goto LABEL_64;
                      }
                      v155 = objc_alloc((Class)NSError);
                      v161 = v34;
                      v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
                      v185 = NSLocalizedDescriptionKey;
                      v157 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Missing Parameter"));
                      *(_QWORD *)buf = v157;
                      *(_QWORD *)v182 = &off_100301268;
                      v186 = CFSTR("Line");
                      v187 = CFSTR("Method");
                      v113 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("_tlvForApplicationIdentifier:error:"));
                      *(_QWORD *)&v182[8] = v113;
                      v188 = NSDebugDescriptionErrorKey;
                      v114 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("_tlvForApplicationIdentifier:error:"), 35);
                      *(_QWORD *)&v182[16] = v114;
                      v115 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, &v185, 4));
                      a4->super.super.isa = (Class)objc_msgSend(v155, "initWithDomain:code:userInfo:", v40, 9, v115);

                      v34 = v161;
                    }
                    v42 = 0;
                    v41 = &AMFDRSealingMapCopyLocalData_ptr;
                    goto LABEL_90;
                  }
                }
                if (a4)
                {
                  v75 = objc_alloc((Class)NSError);
                  v42 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
                  v165[0] = NSLocalizedDescriptionKey;
                  v36 = (NSMutableData *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Encoding Error"));
                  v166[0] = v36;
                  v166[1] = &off_100301340;
                  v165[1] = CFSTR("Line");
                  v165[2] = CFSTR("Method");
                  v76 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("encodeRequest:withPIN:error:"));
                  v166[2] = v76;
                  v165[3] = NSDebugDescriptionErrorKey;
                  v77 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("encodeRequest:withPIN:error:"), 269);
                  v166[3] = v77;
                  v78 = v166;
                  v79 = v165;
                  goto LABEL_61;
                }
LABEL_64:

                goto LABEL_65;
              }
              if (!a4)
                goto LABEL_64;
              v75 = objc_alloc((Class)NSError);
              v42 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
              v167[0] = NSLocalizedDescriptionKey;
              v36 = (NSMutableData *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Encoding Error"));
              v168[0] = v36;
              v168[1] = &off_100301328;
              v167[1] = CFSTR("Line");
              v167[2] = CFSTR("Method");
              v76 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("encodeRequest:withPIN:error:"));
              v168[2] = v76;
              v167[3] = NSDebugDescriptionErrorKey;
              v77 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("encodeRequest:withPIN:error:"), 266);
              v168[3] = v77;
              v78 = v168;
              v79 = v167;
            }
            else
            {
              if (!a4)
                goto LABEL_64;
              v75 = objc_alloc((Class)NSError);
              v42 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
              v169[0] = NSLocalizedDescriptionKey;
              v36 = (NSMutableData *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Encoding Error"));
              v170[0] = v36;
              v170[1] = &off_100301310;
              v169[1] = CFSTR("Line");
              v169[2] = CFSTR("Method");
              v76 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("encodeRequest:withPIN:error:"));
              v170[2] = v76;
              v169[3] = NSDebugDescriptionErrorKey;
              v77 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("encodeRequest:withPIN:error:"), 263);
              v170[3] = v77;
              v78 = v170;
              v79 = v169;
            }
          }
          else
          {
            if (!a4)
              goto LABEL_64;
            v75 = objc_alloc((Class)NSError);
            v42 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
            v171[0] = NSLocalizedDescriptionKey;
            v36 = (NSMutableData *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Encoding Error"));
            v172[0] = v36;
            v172[1] = &off_1003012F8;
            v171[1] = CFSTR("Line");
            v171[2] = CFSTR("Method");
            v76 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("encodeRequest:withPIN:error:"));
            v172[2] = v76;
            v171[3] = NSDebugDescriptionErrorKey;
            v77 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("encodeRequest:withPIN:error:"), 260);
            v172[3] = v77;
            v78 = v172;
            v79 = v171;
          }
        }
        else
        {
          if (!a4)
            goto LABEL_64;
          v75 = objc_alloc((Class)NSError);
          v42 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
          v173[0] = NSLocalizedDescriptionKey;
          v36 = (NSMutableData *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Encoding Error"));
          v174[0] = v36;
          v174[1] = &off_1003012E0;
          v173[1] = CFSTR("Line");
          v173[2] = CFSTR("Method");
          v76 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("encodeRequest:withPIN:error:"));
          v174[2] = v76;
          v173[3] = NSDebugDescriptionErrorKey;
          v77 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("encodeRequest:withPIN:error:"), 256);
          v174[3] = v77;
          v78 = v174;
          v79 = v173;
        }
      }
      else
      {
        if (!a4)
          goto LABEL_64;
        v75 = objc_alloc((Class)NSError);
        v42 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
        v175[0] = NSLocalizedDescriptionKey;
        v36 = (NSMutableData *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Encoding Error"));
        v176[0] = v36;
        v176[1] = &off_1003012C8;
        v175[1] = CFSTR("Line");
        v175[2] = CFSTR("Method");
        v76 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("encodeRequest:withPIN:error:"));
        v176[2] = v76;
        v175[3] = NSDebugDescriptionErrorKey;
        v77 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("encodeRequest:withPIN:error:"), 253);
        v176[3] = v77;
        v78 = v176;
        v79 = v175;
      }
LABEL_61:
      v93 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v78, v79, 4));
      a4->super.super.isa = (Class)objc_msgSend(v75, "initWithDomain:code:userInfo:", v42, 22, v93);

      goto LABEL_62;
    }
    v62 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v63 = NFLogGetLogger(v62);
    if (v63)
    {
      v64 = (void (*)(uint64_t, const char *, ...))v63;
      v65 = object_getClass(v9);
      v66 = class_isMetaClass(v65);
      v67 = object_getClassName(v9);
      v151 = sel_getName("encodeRequest:withPIN:error:");
      v68 = 45;
      if (v66)
        v68 = 43;
      v64(3, "%c[%{public}s %{public}s]:%i Invalid parameter", v68, v67, v151, 244);
    }
    v69 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v70 = NFSharedLogGetLogger(v69);
    v71 = objc_claimAutoreleasedReturnValue(v70);
    if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
    {
      v72 = object_getClass(v9);
      if (class_isMetaClass(v72))
        v73 = 43;
      else
        v73 = 45;
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)&buf[4] = v73;
      *(_WORD *)v182 = 2082;
      *(_QWORD *)&v182[2] = object_getClassName(v9);
      *(_WORD *)&v182[10] = 2082;
      *(_QWORD *)&v182[12] = sel_getName("encodeRequest:withPIN:error:");
      *(_WORD *)&v182[20] = 1024;
      *(_DWORD *)&v182[22] = 244;
      _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid parameter", buf, 0x22u);
    }

    if (a4)
    {
      v55 = objc_alloc((Class)NSError);
      v56 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v177[0] = NSLocalizedDescriptionKey;
      v57 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid Parameter"));
      v178[0] = v57;
      v178[1] = &off_1003012B0;
      v177[1] = CFSTR("Line");
      v177[2] = CFSTR("Method");
      v58 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("encodeRequest:withPIN:error:"));
      v178[2] = v58;
      v177[3] = NSDebugDescriptionErrorKey;
      v59 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("encodeRequest:withPIN:error:"), 245);
      v178[3] = v59;
      v60 = v178;
      v61 = v177;
      goto LABEL_38;
    }
  }
  else
  {
    v43 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v44 = NFLogGetLogger(v43);
    if (v44)
    {
      v45 = (void (*)(uint64_t, const char *, ...))v44;
      v46 = object_getClass(v9);
      v47 = class_isMetaClass(v46);
      v48 = object_getClassName(v9);
      v150 = sel_getName("encodeRequest:withPIN:error:");
      v49 = 45;
      if (v47)
        v49 = 43;
      v45(3, "%c[%{public}s %{public}s]:%i Invalid parameter", v49, v48, v150, 238);
    }
    v50 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v51 = NFSharedLogGetLogger(v50);
    v52 = objc_claimAutoreleasedReturnValue(v51);
    if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
    {
      v53 = object_getClass(v9);
      if (class_isMetaClass(v53))
        v54 = 43;
      else
        v54 = 45;
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)&buf[4] = v54;
      *(_WORD *)v182 = 2082;
      *(_QWORD *)&v182[2] = object_getClassName(v9);
      *(_WORD *)&v182[10] = 2082;
      *(_QWORD *)&v182[12] = sel_getName("encodeRequest:withPIN:error:");
      *(_WORD *)&v182[20] = 1024;
      *(_DWORD *)&v182[22] = 238;
      _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid parameter", buf, 0x22u);
    }

    if (a4)
    {
      v55 = objc_alloc((Class)NSError);
      v56 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "nfcd"));
      v179[0] = NSLocalizedDescriptionKey;
      v57 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Invalid Parameter"));
      v180[0] = v57;
      v180[1] = &off_100301298;
      v179[1] = CFSTR("Line");
      v179[2] = CFSTR("Method");
      v58 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), sel_getName("encodeRequest:withPIN:error:"));
      v180[2] = v58;
      v179[3] = NSDebugDescriptionErrorKey;
      v59 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), sel_getName("encodeRequest:withPIN:error:"), 239);
      v180[3] = v59;
      v60 = v180;
      v61 = v179;
LABEL_38:
      v74 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v60, v61, 4));
      a4->super.super.isa = (Class)objc_msgSend(v55, "initWithDomain:code:userInfo:", v56, 10, v74);

      a4 = 0;
    }
  }
LABEL_65:

  return a4;
}

uint64_t sub_1001C59A4(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  int NumericCode;
  int v6;
  void *v7;
  uint64_t v8;
  void (*v9)(uint64_t, const char *, ...);
  objc_class *v10;
  _BOOL4 v11;
  const char *v12;
  const char *v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  NSObject *v17;
  objc_class *v18;
  int v19;
  const char *v20;
  const char *v21;
  const char *v22;
  NSObject *v23;
  uint32_t v24;
  void *specific;
  uint64_t Logger;
  void (*v27)(uint64_t, const char *, ...);
  objc_class *Class;
  _BOOL4 isMetaClass;
  const char *ClassName;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  objc_class *v34;
  int v35;
  void *v36;
  uint64_t v37;
  void (*v38)(uint64_t, const char *, ...);
  objc_class *v39;
  _BOOL4 v40;
  uint64_t v41;
  void *v42;
  uint64_t v43;
  objc_class *v44;
  int v45;
  uint64_t v46;
  const char *v48;
  const char *Name;
  const char *v50;
  int v51;
  uint8_t buf[4];
  int v53;
  __int16 v54;
  const char *v55;
  __int16 v56;
  const char *v57;
  __int16 v58;
  int v59;
  __int16 v60;
  id v61;
  uint64_t v62;

  v3 = a2;
  v4 = (void *)objc_opt_self(a1);
  if (objc_msgSend(v3, "length") != (id)3)
  {
    specific = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger(specific);
    if (Logger)
    {
      v27 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v4);
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(v4);
      Name = sel_getName("_iso4217ForCurrencyCode:");
      v31 = 45;
      if (isMetaClass)
        v31 = 43;
      v27(3, "%c[%{public}s %{public}s]:%i Invalid parameter length", v31, ClassName, Name, 295);
    }
    v32 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v33 = NFSharedLogGetLogger(v32);
    v17 = objc_claimAutoreleasedReturnValue(v33);
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      goto LABEL_33;
    v34 = object_getClass(v4);
    if (class_isMetaClass(v34))
      v35 = 43;
    else
      v35 = 45;
    *(_DWORD *)buf = 67109890;
    v53 = v35;
    v54 = 2082;
    v55 = object_getClassName(v4);
    v56 = 2082;
    v57 = sel_getName("_iso4217ForCurrencyCode:");
    v58 = 1024;
    v59 = 295;
    v22 = "%c[%{public}s %{public}s]:%i Invalid parameter length";
    v23 = v17;
    v24 = 34;
    goto LABEL_32;
  }
  v62 = 0;
  objc_msgSend(v3, "getCharacters:range:", &v62, 0, 3);
  NumericCode = ucurr_getNumericCode(&v62);
  if (!NumericCode)
  {
    v36 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v37 = NFLogGetLogger(v36);
    if (v37)
    {
      v38 = (void (*)(uint64_t, const char *, ...))v37;
      v39 = object_getClass(v4);
      v40 = class_isMetaClass(v39);
      v48 = object_getClassName(v4);
      v50 = sel_getName("_iso4217ForCurrencyCode:");
      v41 = 45;
      if (v40)
        v41 = 43;
      v38(3, "%c[%{public}s %{public}s]:%i Unable to determine ISO currency code for %{public}@", v41, v48, v50, 304, v3);
    }
    v42 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v43 = NFSharedLogGetLogger(v42);
    v17 = objc_claimAutoreleasedReturnValue(v43);
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      goto LABEL_33;
    v44 = object_getClass(v4);
    if (class_isMetaClass(v44))
      v45 = 43;
    else
      v45 = 45;
    *(_DWORD *)buf = 67110146;
    v53 = v45;
    v54 = 2082;
    v55 = object_getClassName(v4);
    v56 = 2082;
    v57 = sel_getName("_iso4217ForCurrencyCode:");
    v58 = 1024;
    v59 = 304;
    v60 = 2114;
    v61 = v3;
    v22 = "%c[%{public}s %{public}s]:%i Unable to determine ISO currency code for %{public}@";
    v23 = v17;
    v24 = 44;
    goto LABEL_32;
  }
  v6 = NumericCode;
  v51 = 0;
  if ((int)ucurr_getDefaultFractionDigits(&v62, &v51) > 0 || v51 < 1)
  {
    v46 = v6;
    goto LABEL_34;
  }
  v7 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v8 = NFLogGetLogger(v7);
  if (v8)
  {
    v9 = (void (*)(uint64_t, const char *, ...))v8;
    v10 = object_getClass(v4);
    v11 = class_isMetaClass(v10);
    v12 = object_getClassName(v4);
    v13 = sel_getName("_iso4217ForCurrencyCode:");
    v14 = 45;
    if (v11)
      v14 = 43;
    v9(3, "%c[%{public}s %{public}s]:%i Invalid fractional digits: 0x%x", v14, v12, v13, 311, v51);
  }
  v15 = dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v16 = NFSharedLogGetLogger(v15);
  v17 = objc_claimAutoreleasedReturnValue(v16);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    v18 = object_getClass(v4);
    if (class_isMetaClass(v18))
      v19 = 43;
    else
      v19 = 45;
    v20 = object_getClassName(v4);
    v21 = sel_getName("_iso4217ForCurrencyCode:");
    *(_DWORD *)buf = 67110146;
    v53 = v19;
    v54 = 2082;
    v55 = v20;
    v56 = 2082;
    v57 = v21;
    v58 = 1024;
    v59 = 311;
    v60 = 1024;
    LODWORD(v61) = v51;
    v22 = "%c[%{public}s %{public}s]:%i Invalid fractional digits: 0x%x";
    v23 = v17;
    v24 = 40;
LABEL_32:
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, v22, buf, v24);
  }
LABEL_33:

  v46 = -1;
LABEL_34:

  return v46;
}

