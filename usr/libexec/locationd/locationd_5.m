uint64_t sub_1002D71D4(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  char *v5;
  wireless_diagnostics::google::protobuf::io::CodedInputStream *TagFallback;
  int v7;
  char *v8;
  unsigned int v9;
  BOOL v10;
  _BYTE *v11;
  void *v12;
  _BYTE *v13;
  void *v14;
  _BYTE *v15;
  void *v16;
  uint64_t result;
  unsigned int v18;

  while (2)
  {
    v5 = (char *)*((_QWORD *)this + 1);
    if ((unint64_t)v5 < *((_QWORD *)this + 2) && (*v5 & 0x80000000) == 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((_QWORD *)this + 1) = v5 + 1;
      if (!(_DWORD)TagFallback)
        return 1;
LABEL_6:
      switch(TagFallback >> 3)
      {
        case 1u:
          v7 = TagFallback & 7;
          if ((TagFallback & 7) != 0)
            goto LABEL_18;
          v18 = 0;
          v8 = (char *)*((_QWORD *)this + 1);
          if ((unint64_t)v8 >= *((_QWORD *)this + 2) || *v8 < 0)
          {
            result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v18);
            if (!(_DWORD)result)
              return result;
            v9 = v18;
          }
          else
          {
            v9 = *v8;
            *((_QWORD *)this + 1) = v8 + 1;
          }
          if (v9 - 31 < 0x19 || (v9 <= 0xE ? (v10 = ((1 << v9) & 0x76B6) == 0) : (v10 = 1), !v10))
          {
            if (v9 - 31 >= 0x19 && (v9 > 0xE || ((1 << v9) & 0x76B6) == 0))
              sub_1018F24AC();
            *(_DWORD *)(a1 + 40) |= 1u;
            *(_DWORD *)(a1 + 32) = v9;
          }
          v11 = (_BYTE *)*((_QWORD *)this + 1);
          if ((unint64_t)v11 < *((_QWORD *)this + 2) && *v11 == 18)
          {
            *((_QWORD *)this + 1) = v11 + 1;
            goto LABEL_35;
          }
          continue;
        case 2u:
          v7 = TagFallback & 7;
          if (v7 != 2)
            goto LABEL_18;
LABEL_35:
          *(_DWORD *)(a1 + 40) |= 2u;
          v12 = *(void **)(a1 + 8);
          if (v12 == &wireless_diagnostics::google::protobuf::internal::kEmptyString)
            operator new();
          result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString(this, v12);
          if (!(_DWORD)result)
            return result;
          v13 = (_BYTE *)*((_QWORD *)this + 1);
          if ((unint64_t)v13 >= *((_QWORD *)this + 2) || *v13 != 26)
            continue;
          *((_QWORD *)this + 1) = v13 + 1;
LABEL_41:
          *(_DWORD *)(a1 + 40) |= 4u;
          v14 = *(void **)(a1 + 16);
          if (v14 == &wireless_diagnostics::google::protobuf::internal::kEmptyString)
            operator new();
          result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes(this, v14);
          if (!(_DWORD)result)
            return result;
          v15 = (_BYTE *)*((_QWORD *)this + 1);
          if ((unint64_t)v15 >= *((_QWORD *)this + 2) || *v15 != 34)
            continue;
          *((_QWORD *)this + 1) = v15 + 1;
LABEL_47:
          *(_DWORD *)(a1 + 40) |= 8u;
          v16 = *(void **)(a1 + 24);
          if (v16 == &wireless_diagnostics::google::protobuf::internal::kEmptyString)
            operator new();
          result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes(this, v16);
          if (!(_DWORD)result)
            return result;
          if (*((_QWORD *)this + 1) != *((_QWORD *)this + 2)
            || !*((_DWORD *)this + 11) && *((_DWORD *)this + 6) != *((_DWORD *)this + 10))
          {
            continue;
          }
          *((_DWORD *)this + 8) = 0;
          result = 1;
          *((_BYTE *)this + 36) = 1;
          return result;
        case 3u:
          v7 = TagFallback & 7;
          if (v7 == 2)
            goto LABEL_41;
          goto LABEL_18;
        case 4u:
          v7 = TagFallback & 7;
          if (v7 == 2)
            goto LABEL_47;
          goto LABEL_18;
        default:
          v7 = TagFallback & 7;
LABEL_18:
          if (v7 == 4)
            return 1;
          if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, TagFallback, a3) & 1) != 0)
            continue;
          return 0;
      }
    }
    break;
  }
  TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
  *((_DWORD *)this + 8) = (_DWORD)TagFallback;
  if ((_DWORD)TagFallback)
    goto LABEL_6;
  return 1;
}

uint64_t sub_1002D74E8(uint64_t result, uint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5;
  int v6;

  v5 = result;
  v6 = *(_DWORD *)(result + 40);
  if ((v6 & 1) != 0)
  {
    result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 32), a2, a4);
    v6 = *(_DWORD *)(v5 + 40);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0)
        goto LABEL_4;
      goto LABEL_8;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString(2, *(_QWORD *)(v5 + 8), a2);
  v6 = *(_DWORD *)(v5 + 40);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0)
      return result;
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes(4, *(_QWORD *)(v5 + 24), a2);
  }
LABEL_8:
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes(3, *(_QWORD *)(v5 + 16), a2);
  if ((*(_DWORD *)(v5 + 40) & 8) != 0)
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes(4, *(_QWORD *)(v5 + 24), a2);
  return result;
}

uint64_t sub_1002D757C(uint64_t a1, unsigned int a2)
{
  int v3;
  uint64_t v4;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v5;
  uint64_t v6;
  int v7;
  char v8;
  uint64_t v9;
  unint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  char v14;
  uint64_t v15;
  unint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  char v20;
  uint64_t v21;
  unint64_t v22;
  int v23;

  LOBYTE(v3) = *(_BYTE *)(a1 + 40);
  if (!(_BYTE)v3)
  {
    v4 = 0;
    goto LABEL_43;
  }
  if ((*(_BYTE *)(a1 + 40) & 1) != 0)
  {
    v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 32);
    if ((v5 & 0x80000000) != 0)
    {
      v4 = 11;
      if ((v3 & 2) == 0)
        goto LABEL_22;
    }
    else if (v5 >= 0x80)
    {
      v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
      v3 = *(_DWORD *)(a1 + 40);
      if ((v3 & 2) == 0)
        goto LABEL_22;
    }
    else
    {
      v4 = 2;
      if ((v3 & 2) == 0)
        goto LABEL_22;
    }
  }
  else
  {
    v4 = 0;
    if ((*(_BYTE *)(a1 + 40) & 2) == 0)
      goto LABEL_22;
  }
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(unsigned __int8 *)(v6 + 23);
  v8 = v7;
  v9 = *(_QWORD *)(v6 + 8);
  if ((v7 & 0x80u) == 0)
    v10 = *(unsigned __int8 *)(v6 + 23);
  else
    v10 = v9;
  if (v10 >= 0x80)
  {
    v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v10, a2);
    v7 = *(unsigned __int8 *)(v6 + 23);
    v9 = *(_QWORD *)(v6 + 8);
    v3 = *(_DWORD *)(a1 + 40);
    v8 = *(_BYTE *)(v6 + 23);
  }
  else
  {
    v11 = 1;
  }
  if (v8 < 0)
    v7 = v9;
  v4 = (v4 + v11 + v7 + 1);
LABEL_22:
  if ((v3 & 4) == 0)
  {
    if ((v3 & 8) == 0)
      goto LABEL_43;
    goto LABEL_34;
  }
  v12 = *(_QWORD *)(a1 + 16);
  v13 = *(unsigned __int8 *)(v12 + 23);
  v14 = v13;
  v15 = *(_QWORD *)(v12 + 8);
  if ((v13 & 0x80u) == 0)
    v16 = *(unsigned __int8 *)(v12 + 23);
  else
    v16 = v15;
  if (v16 >= 0x80)
  {
    v17 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v16, a2);
    v13 = *(unsigned __int8 *)(v12 + 23);
    v15 = *(_QWORD *)(v12 + 8);
    v3 = *(_DWORD *)(a1 + 40);
    v14 = *(_BYTE *)(v12 + 23);
  }
  else
  {
    v17 = 1;
  }
  if (v14 < 0)
    v13 = v15;
  v4 = (v4 + v17 + v13 + 1);
  if ((v3 & 8) != 0)
  {
LABEL_34:
    v18 = *(_QWORD *)(a1 + 24);
    v19 = *(unsigned __int8 *)(v18 + 23);
    v20 = v19;
    v21 = *(_QWORD *)(v18 + 8);
    if ((v19 & 0x80u) == 0)
      v22 = *(unsigned __int8 *)(v18 + 23);
    else
      v22 = v21;
    if (v22 >= 0x80)
    {
      v23 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v22, a2);
      v19 = *(unsigned __int8 *)(v18 + 23);
      v21 = *(_QWORD *)(v18 + 8);
      v20 = *(_BYTE *)(v18 + 23);
    }
    else
    {
      v23 = 1;
    }
    if (v20 < 0)
      v19 = v21;
    v4 = (v4 + v23 + v19 + 1);
  }
LABEL_43:
  *(_DWORD *)(a1 + 36) = v4;
  return v4;
}

void sub_1002D7708(uint64_t a1, void *lpsrc)
{
  uint64_t v4;
  uint64_t v5;

  sub_1002D6E6C(a1, (uint64_t)lpsrc);
}

void sub_1002D7754(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
    sub_1002D6E6C(a1, a2);
  }
}

uint64_t sub_1002D7794()
{
  return 1;
}

_QWORD *sub_1002D779C@<X0>(_QWORD *a1@<X8>)
{
  return sub_1015A2E04(a1, "CLMicroLocationProto.RequestPrediction");
}

void sub_1002D77AC(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  const std::string *v7;
  std::string *v8;
  char v9;
  _BYTE v10[48];

  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage(v10, 3, "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/proto/gen-cpp/microlocation.pb.cc", 14541);
    v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<(v10, "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v9, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v10);
  }
  LOBYTE(v5) = *(_BYTE *)(a2 + 24);
  if ((_BYTE)v5)
  {
    if ((*(_BYTE *)(a2 + 24) & 1) != 0)
    {
      v6 = *(_DWORD *)(a2 + 16);
      if (v6 - 31 >= 0x19 && (v6 > 0xE || ((1 << v6) & 0x76B6) == 0))
        sub_1018F24D4();
      *(_DWORD *)(a1 + 24) |= 1u;
      *(_DWORD *)(a1 + 16) = v6;
      v5 = *(_DWORD *)(a2 + 24);
    }
    if ((v5 & 2) != 0)
    {
      v7 = *(const std::string **)(a2 + 8);
      *(_DWORD *)(a1 + 24) |= 2u;
      v8 = *(std::string **)(a1 + 8);
      if (v8 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
        operator new();
      std::string::operator=(v8, v7);
    }
  }
}

void sub_1002D78BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_1002D78D4(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(_QWORD *)a1 = off_10212D328;
  sub_100109DDC((uint64_t)a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_1002D7904(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(_QWORD *)a1 = off_10212D328;
  sub_100109DDC((uint64_t)a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete();
}

void sub_1002D7948()
{
  operator new();
}

uint64_t sub_1002D7994(uint64_t result)
{
  char v1;
  uint64_t v2;

  v1 = *(_BYTE *)(result + 24);
  if (v1)
  {
    *(_DWORD *)(result + 16) = 44;
    if ((v1 & 2) != 0)
    {
      v2 = *(_QWORD *)(result + 8);
      if ((_UNKNOWN *)v2 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v2 + 23) < 0)
        {
          **(_BYTE **)v2 = 0;
          *(_QWORD *)(v2 + 8) = 0;
        }
        else
        {
          *(_BYTE *)v2 = 0;
          *(_BYTE *)(v2 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(result + 24) = 0;
  return result;
}

uint64_t sub_1002D79E4(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  char *v5;
  wireless_diagnostics::google::protobuf::io::CodedInputStream *TagFallback;
  int v7;
  char *v8;
  unsigned int v9;
  BOOL v10;
  _BYTE *v12;
  void *v13;
  uint64_t result;
  unsigned int v15;

  while (1)
  {
    while (1)
    {
      v5 = (char *)*((_QWORD *)this + 1);
      if ((unint64_t)v5 >= *((_QWORD *)this + 2) || *v5 < 0)
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        if (!(_DWORD)TagFallback)
          return 1;
      }
      else
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        *((_QWORD *)this + 1) = v5 + 1;
        if (!(_DWORD)TagFallback)
          return 1;
      }
      if (TagFallback >> 3 != 1)
        break;
      v7 = TagFallback & 7;
      if ((TagFallback & 7) != 0)
        goto LABEL_15;
      v15 = 0;
      v8 = (char *)*((_QWORD *)this + 1);
      if ((unint64_t)v8 >= *((_QWORD *)this + 2) || *v8 < 0)
      {
        result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v15);
        if (!(_DWORD)result)
          return result;
        v9 = v15;
      }
      else
      {
        v9 = *v8;
        *((_QWORD *)this + 1) = v8 + 1;
      }
      if (v9 - 31 < 0x19 || (v9 <= 0xE ? (v10 = ((1 << v9) & 0x76B6) == 0) : (v10 = 1), !v10))
      {
        if (v9 - 31 >= 0x19 && (v9 > 0xE || ((1 << v9) & 0x76B6) == 0))
          sub_1018F24D4();
        *(_DWORD *)(a1 + 24) |= 1u;
        *(_DWORD *)(a1 + 16) = v9;
      }
      v12 = (_BYTE *)*((_QWORD *)this + 1);
      if ((unint64_t)v12 < *((_QWORD *)this + 2) && *v12 == 18)
      {
        *((_QWORD *)this + 1) = v12 + 1;
LABEL_34:
        *(_DWORD *)(a1 + 24) |= 2u;
        v13 = *(void **)(a1 + 8);
        if (v13 == &wireless_diagnostics::google::protobuf::internal::kEmptyString)
          operator new();
        result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString(this, v13);
        if (!(_DWORD)result)
          return result;
        if (*((_QWORD *)this + 1) == *((_QWORD *)this + 2)
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          result = 1;
          *((_BYTE *)this + 36) = 1;
          return result;
        }
      }
    }
    if (TagFallback >> 3 == 2)
    {
      v7 = TagFallback & 7;
      if (v7 == 2)
        goto LABEL_34;
    }
    else
    {
      v7 = TagFallback & 7;
    }
LABEL_15:
    if (v7 == 4)
      return 1;
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, TagFallback, a3) & 1) == 0)
      return 0;
  }
}

uint64_t sub_1002D7BEC(uint64_t result, uint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5;
  int v6;

  v5 = result;
  v6 = *(_DWORD *)(result + 24);
  if ((v6 & 1) != 0)
  {
    result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 16), a2, a4);
    v6 = *(_DWORD *)(v5 + 24);
  }
  if ((v6 & 2) != 0)
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString(2, *(_QWORD *)(v5 + 8), a2);
  return result;
}

uint64_t sub_1002D7C44(uint64_t a1, unsigned int a2)
{
  char v3;
  uint64_t v4;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v5;
  uint64_t v6;
  int v7;
  char v8;
  uint64_t v9;
  unint64_t v10;
  int v11;

  v3 = *(_BYTE *)(a1 + 24);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 24) & 1) != 0)
    {
      v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
      if ((v5 & 0x80000000) != 0)
      {
        v4 = 11;
        if ((v3 & 2) == 0)
          goto LABEL_22;
      }
      else if (v5 >= 0x80)
      {
        v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2)
           + 1;
        if ((*(_DWORD *)(a1 + 24) & 2) == 0)
          goto LABEL_22;
      }
      else
      {
        v4 = 2;
        if ((v3 & 2) == 0)
          goto LABEL_22;
      }
    }
    else
    {
      v4 = 0;
      if ((*(_BYTE *)(a1 + 24) & 2) == 0)
        goto LABEL_22;
    }
    v6 = *(_QWORD *)(a1 + 8);
    v7 = *(unsigned __int8 *)(v6 + 23);
    v8 = v7;
    v9 = *(_QWORD *)(v6 + 8);
    if ((v7 & 0x80u) == 0)
      v10 = *(unsigned __int8 *)(v6 + 23);
    else
      v10 = v9;
    if (v10 >= 0x80)
    {
      v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v10, a2);
      v7 = *(unsigned __int8 *)(v6 + 23);
      v9 = *(_QWORD *)(v6 + 8);
      v8 = *(_BYTE *)(v6 + 23);
    }
    else
    {
      v11 = 1;
    }
    if (v8 < 0)
      v7 = v9;
    v4 = (v4 + v11 + v7 + 1);
  }
  else
  {
    v4 = 0;
  }
LABEL_22:
  *(_DWORD *)(a1 + 20) = v4;
  return v4;
}

void sub_1002D7D18(uint64_t a1, void *lpsrc)
{
  uint64_t v4;
  uint64_t v5;

  sub_1002D77AC(a1, (uint64_t)lpsrc);
}

void sub_1002D7D64(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
    sub_1002D77AC(a1, a2);
  }
}

uint64_t sub_1002D7DA4()
{
  return 1;
}

_QWORD *sub_1002D7DAC@<X0>(_QWORD *a1@<X8>)
{
  return sub_1015A2E04(a1, "CLMicroLocationProto.MiloInit");
}

BOOL sub_1002D7DBC(unsigned int a1)
{
  return a1 < 0xB;
}

void sub_1002D7DC8(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  const std::string *v7;
  std::string *v8;
  unsigned int v9;
  const std::string *v10;
  std::string *v11;
  unsigned int v12;
  int v13;
  char v14;
  _BYTE v15[48];

  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage(v15, 3, "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/proto/gen-cpp/microlocation.pb.cc", 14942);
    v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<(v15, "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v14, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v15);
  }
  LOBYTE(v5) = *(_BYTE *)(a2 + 44);
  if ((_BYTE)v5)
  {
    if ((*(_BYTE *)(a2 + 44) & 1) != 0)
    {
      v6 = *(_DWORD *)(a2 + 16);
      if (v6 - 31 >= 0x19 && (v6 > 0xE || ((1 << v6) & 0x76B6) == 0))
        sub_1018F254C();
      *(_DWORD *)(a1 + 44) |= 1u;
      *(_DWORD *)(a1 + 16) = v6;
      v5 = *(_DWORD *)(a2 + 44);
    }
    if ((v5 & 2) != 0)
    {
      v7 = *(const std::string **)(a2 + 8);
      *(_DWORD *)(a1 + 44) |= 2u;
      v8 = *(std::string **)(a1 + 8);
      if (v8 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
        operator new();
      std::string::operator=(v8, v7);
      v5 = *(_DWORD *)(a2 + 44);
    }
    if ((v5 & 4) != 0)
    {
      v9 = *(_DWORD *)(a2 + 20);
      if (v9 >= 0xB)
        sub_1018F2524();
      *(_DWORD *)(a1 + 44) |= 4u;
      *(_DWORD *)(a1 + 20) = v9;
      v5 = *(_DWORD *)(a2 + 44);
    }
    if ((v5 & 8) != 0)
    {
      v10 = *(const std::string **)(a2 + 24);
      *(_DWORD *)(a1 + 44) |= 8u;
      v11 = *(std::string **)(a1 + 24);
      if (v11 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
        operator new();
      std::string::operator=(v11, v10);
      v5 = *(_DWORD *)(a2 + 44);
    }
    if ((v5 & 0x10) != 0)
    {
      v12 = *(_DWORD *)(a2 + 32);
      if (v12 >= 3)
        sub_1018F24FC();
      *(_DWORD *)(a1 + 44) |= 0x10u;
      *(_DWORD *)(a1 + 32) = v12;
      v5 = *(_DWORD *)(a2 + 44);
    }
    if ((v5 & 0x20) != 0)
    {
      v13 = *(_DWORD *)(a2 + 36);
      *(_DWORD *)(a1 + 44) |= 0x20u;
      *(_DWORD *)(a1 + 36) = v13;
    }
  }
}

void sub_1002D7FA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_1002D7FBC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(_QWORD *)a1 = off_10212D3A0;
  sub_1002D5368((uint64_t)a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_1002D7FEC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(_QWORD *)a1 = off_10212D3A0;
  sub_1002D5368((uint64_t)a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete();
}

void sub_1002D8030()
{
  operator new();
}

uint64_t sub_1002D8080(uint64_t result)
{
  char v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(_BYTE *)(result + 44);
  if (v1)
  {
    *(_DWORD *)(result + 16) = 45;
    if ((v1 & 2) != 0)
    {
      v2 = *(_QWORD *)(result + 8);
      if ((_UNKNOWN *)v2 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v2 + 23) < 0)
        {
          **(_BYTE **)v2 = 0;
          *(_QWORD *)(v2 + 8) = 0;
        }
        else
        {
          *(_BYTE *)v2 = 0;
          *(_BYTE *)(v2 + 23) = 0;
        }
      }
    }
    *(_DWORD *)(result + 20) = 0;
    if ((*(_BYTE *)(result + 44) & 8) != 0)
    {
      v3 = *(_QWORD *)(result + 24);
      if ((_UNKNOWN *)v3 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v3 + 23) < 0)
        {
          **(_BYTE **)v3 = 0;
          *(_QWORD *)(v3 + 8) = 0;
        }
        else
        {
          *(_BYTE *)v3 = 0;
          *(_BYTE *)(v3 + 23) = 0;
        }
      }
    }
    *(_QWORD *)(result + 32) = 0;
  }
  *(_DWORD *)(result + 44) = 0;
  return result;
}

uint64_t sub_1002D810C(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  unsigned int *v5;
  char *v6;
  wireless_diagnostics::google::protobuf::io::CodedInputStream *TagFallback;
  int v8;
  char *v9;
  unsigned int v10;
  unint64_t v11;
  char *v12;
  unint64_t v13;
  char *v14;
  unint64_t v15;
  char *v16;
  BOOL v17;
  _BYTE *v18;
  void *v19;
  _BYTE *v20;
  unsigned int v21;
  _BYTE *v22;
  void *v23;
  _BYTE *v24;
  unsigned int v25;
  _BYTE *v26;
  unsigned __int8 *v27;
  uint64_t result;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;

  v5 = (unsigned int *)(a1 + 36);
  while (2)
  {
    v6 = (char *)*((_QWORD *)this + 1);
    if ((unint64_t)v6 >= *((_QWORD *)this + 2) || *v6 < 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      if (!(_DWORD)TagFallback)
        return 1;
    }
    else
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v6;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((_QWORD *)this + 1) = v6 + 1;
      if (!(_DWORD)TagFallback)
        return 1;
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0)
          goto LABEL_22;
        v31 = 0;
        v9 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v9 < *((_QWORD *)this + 2) && (*v9 & 0x80000000) == 0)
        {
          v10 = *v9;
          *((_QWORD *)this + 1) = v9 + 1;
LABEL_28:
          if (v10 - 31 < 0x19 || (v10 <= 0xE ? (v17 = ((1 << v10) & 0x76B6) == 0) : (v17 = 1), !v17))
          {
            if (v10 - 31 >= 0x19 && (v10 > 0xE || ((1 << v10) & 0x76B6) == 0))
              sub_1018F254C();
            *(_DWORD *)(a1 + 44) |= 1u;
            *(_DWORD *)(a1 + 16) = v10;
          }
          v18 = (_BYTE *)*((_QWORD *)this + 1);
          if ((unint64_t)v18 < *((_QWORD *)this + 2) && *v18 == 18)
          {
            *((_QWORD *)this + 1) = v18 + 1;
            goto LABEL_40;
          }
          continue;
        }
        result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v31);
        if ((_DWORD)result)
        {
          v10 = v31;
          goto LABEL_28;
        }
        break;
      case 2u:
        v8 = TagFallback & 7;
        if (v8 != 2)
          goto LABEL_22;
LABEL_40:
        *(_DWORD *)(a1 + 44) |= 2u;
        v19 = *(void **)(a1 + 8);
        if (v19 == &wireless_diagnostics::google::protobuf::internal::kEmptyString)
          operator new();
        result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString(this, v19);
        if (!(_DWORD)result)
          return result;
        v20 = (_BYTE *)*((_QWORD *)this + 1);
        v11 = *((_QWORD *)this + 2);
        if ((unint64_t)v20 >= v11 || *v20 != 24)
          continue;
        v12 = v20 + 1;
        *((_QWORD *)this + 1) = v12;
LABEL_46:
        v30 = 0;
        if ((unint64_t)v12 >= v11 || *v12 < 0)
        {
          result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v30);
          if (!(_DWORD)result)
            return result;
          v21 = v30;
        }
        else
        {
          v21 = *v12;
          *((_QWORD *)this + 1) = v12 + 1;
        }
        if (v21 <= 0xA)
        {
          *(_DWORD *)(a1 + 44) |= 4u;
          *(_DWORD *)(a1 + 20) = v21;
        }
        v22 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v22 >= *((_QWORD *)this + 2) || *v22 != 34)
          continue;
        *((_QWORD *)this + 1) = v22 + 1;
LABEL_56:
        *(_DWORD *)(a1 + 44) |= 8u;
        v23 = *(void **)(a1 + 24);
        if (v23 == &wireless_diagnostics::google::protobuf::internal::kEmptyString)
          operator new();
        result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString(this, v23);
        if (!(_DWORD)result)
          return result;
        v24 = (_BYTE *)*((_QWORD *)this + 1);
        v13 = *((_QWORD *)this + 2);
        if ((unint64_t)v24 >= v13 || *v24 != 40)
          continue;
        v14 = v24 + 1;
        *((_QWORD *)this + 1) = v14;
LABEL_62:
        v29 = 0;
        if ((unint64_t)v14 >= v13 || *v14 < 0)
        {
          result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v29);
          if (!(_DWORD)result)
            return result;
          v25 = v29;
        }
        else
        {
          v25 = *v14;
          *((_QWORD *)this + 1) = v14 + 1;
        }
        if (v25 <= 2)
        {
          *(_DWORD *)(a1 + 44) |= 0x10u;
          *(_DWORD *)(a1 + 32) = v25;
        }
        v26 = (_BYTE *)*((_QWORD *)this + 1);
        v15 = *((_QWORD *)this + 2);
        if ((unint64_t)v26 >= v15 || *v26 != 48)
          continue;
        v16 = v26 + 1;
        *((_QWORD *)this + 1) = v16;
LABEL_72:
        if ((unint64_t)v16 >= v15 || *v16 < 0)
        {
          result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v5);
          if (!(_DWORD)result)
            return result;
          v27 = (unsigned __int8 *)*((_QWORD *)this + 1);
          v15 = *((_QWORD *)this + 2);
        }
        else
        {
          *v5 = *v16;
          v27 = (unsigned __int8 *)(v16 + 1);
          *((_QWORD *)this + 1) = v27;
        }
        *(_DWORD *)(a1 + 44) |= 0x20u;
        if (v27 != (unsigned __int8 *)v15 || !*((_DWORD *)this + 11) && *((_DWORD *)this + 6) != *((_DWORD *)this + 10))
          continue;
        *((_DWORD *)this + 8) = 0;
        result = 1;
        *((_BYTE *)this + 36) = 1;
        return result;
      case 3u:
        v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0)
          goto LABEL_22;
        v12 = (char *)*((_QWORD *)this + 1);
        v11 = *((_QWORD *)this + 2);
        goto LABEL_46;
      case 4u:
        v8 = TagFallback & 7;
        if (v8 == 2)
          goto LABEL_56;
        goto LABEL_22;
      case 5u:
        v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0)
          goto LABEL_22;
        v14 = (char *)*((_QWORD *)this + 1);
        v13 = *((_QWORD *)this + 2);
        goto LABEL_62;
      case 6u:
        v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0)
          goto LABEL_22;
        v16 = (char *)*((_QWORD *)this + 1);
        v15 = *((_QWORD *)this + 2);
        goto LABEL_72;
      default:
        v8 = TagFallback & 7;
LABEL_22:
        if (v8 == 4)
          return 1;
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, TagFallback, a3) & 1) != 0)
          continue;
        return 0;
    }
    return result;
  }
}

uint64_t sub_1002D8524(uint64_t result, uint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5;
  int v6;

  v5 = result;
  v6 = *(_DWORD *)(result + 44);
  if ((v6 & 1) != 0)
  {
    result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 16), a2, a4);
    v6 = *(_DWORD *)(v5 + 44);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0)
        goto LABEL_4;
      goto LABEL_10;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString(2, *(_QWORD *)(v5 + 8), a2);
  v6 = *(_DWORD *)(v5 + 44);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0)
      goto LABEL_5;
    goto LABEL_11;
  }
LABEL_10:
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, *(_DWORD *)(v5 + 20), a2, a4);
  v6 = *(_DWORD *)(v5 + 44);
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0)
      goto LABEL_6;
    goto LABEL_12;
  }
LABEL_11:
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString(4, *(_QWORD *)(v5 + 24), a2);
  v6 = *(_DWORD *)(v5 + 44);
  if ((v6 & 0x10) == 0)
  {
LABEL_6:
    if ((v6 & 0x20) == 0)
      return result;
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, *(_DWORD *)(v5 + 36), a2, a4);
  }
LABEL_12:
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, *(_DWORD *)(v5 + 32), a2, a4);
  if ((*(_DWORD *)(v5 + 44) & 0x20) != 0)
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, *(_DWORD *)(v5 + 36), a2, a4);
  return result;
}

uint64_t sub_1002D85F0(uint64_t a1, unsigned int a2)
{
  int v3;
  uint64_t v4;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v5;
  uint64_t v6;
  int v7;
  char v8;
  uint64_t v9;
  unint64_t v10;
  int v11;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v12;
  int v13;
  uint64_t v14;
  int v15;
  char v16;
  uint64_t v17;
  unint64_t v18;
  int v19;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v20;
  int v21;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v22;
  int v23;

  LOBYTE(v3) = *(_BYTE *)(a1 + 44);
  if (!(_BYTE)v3)
  {
    v4 = 0;
    goto LABEL_52;
  }
  if ((*(_BYTE *)(a1 + 44) & 1) != 0)
  {
    v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
    if ((v5 & 0x80000000) != 0)
    {
      v4 = 11;
      if ((v3 & 2) == 0)
        goto LABEL_22;
    }
    else if (v5 >= 0x80)
    {
      v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
      v3 = *(_DWORD *)(a1 + 44);
      if ((v3 & 2) == 0)
        goto LABEL_22;
    }
    else
    {
      v4 = 2;
      if ((v3 & 2) == 0)
        goto LABEL_22;
    }
  }
  else
  {
    v4 = 0;
    if ((*(_BYTE *)(a1 + 44) & 2) == 0)
      goto LABEL_22;
  }
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(unsigned __int8 *)(v6 + 23);
  v8 = v7;
  v9 = *(_QWORD *)(v6 + 8);
  if ((v7 & 0x80u) == 0)
    v10 = *(unsigned __int8 *)(v6 + 23);
  else
    v10 = v9;
  if (v10 >= 0x80)
  {
    v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v10, a2);
    v7 = *(unsigned __int8 *)(v6 + 23);
    v9 = *(_QWORD *)(v6 + 8);
    v3 = *(_DWORD *)(a1 + 44);
    v8 = *(_BYTE *)(v6 + 23);
  }
  else
  {
    v11 = 1;
  }
  if (v8 < 0)
    v7 = v9;
  v4 = (v4 + v11 + v7 + 1);
LABEL_22:
  if ((v3 & 4) != 0)
  {
    v12 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 20);
    if ((v12 & 0x80000000) != 0)
    {
      v13 = 11;
    }
    else if (v12 >= 0x80)
    {
      v13 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v12, a2) + 1;
      v3 = *(_DWORD *)(a1 + 44);
    }
    else
    {
      v13 = 2;
    }
    v4 = (v13 + v4);
    if ((v3 & 8) == 0)
    {
LABEL_24:
      if ((v3 & 0x10) == 0)
        goto LABEL_25;
      goto LABEL_42;
    }
  }
  else if ((v3 & 8) == 0)
  {
    goto LABEL_24;
  }
  v14 = *(_QWORD *)(a1 + 24);
  v15 = *(unsigned __int8 *)(v14 + 23);
  v16 = v15;
  v17 = *(_QWORD *)(v14 + 8);
  if ((v15 & 0x80u) == 0)
    v18 = *(unsigned __int8 *)(v14 + 23);
  else
    v18 = v17;
  if (v18 >= 0x80)
  {
    v19 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v18, a2);
    v15 = *(unsigned __int8 *)(v14 + 23);
    v17 = *(_QWORD *)(v14 + 8);
    v3 = *(_DWORD *)(a1 + 44);
    v16 = *(_BYTE *)(v14 + 23);
  }
  else
  {
    v19 = 1;
  }
  if (v16 < 0)
    v15 = v17;
  v4 = (v4 + v19 + v15 + 1);
  if ((v3 & 0x10) == 0)
  {
LABEL_25:
    if ((v3 & 0x20) == 0)
      goto LABEL_52;
    goto LABEL_48;
  }
LABEL_42:
  v20 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 32);
  if ((v20 & 0x80000000) != 0)
  {
    v21 = 11;
  }
  else if (v20 >= 0x80)
  {
    v21 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v20, a2) + 1;
    v3 = *(_DWORD *)(a1 + 44);
  }
  else
  {
    v21 = 2;
  }
  v4 = (v21 + v4);
  if ((v3 & 0x20) != 0)
  {
LABEL_48:
    v22 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 36);
    if (v22 >= 0x80)
      v23 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v22, a2) + 1;
    else
      v23 = 2;
    v4 = (v23 + v4);
  }
LABEL_52:
  *(_DWORD *)(a1 + 40) = v4;
  return v4;
}

void sub_1002D87BC(uint64_t a1, void *lpsrc)
{
  uint64_t v4;
  uint64_t v5;

  sub_1002D7DC8(a1, (uint64_t)lpsrc);
}

void sub_1002D8808(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
    sub_1002D7DC8(a1, a2);
  }
}

uint64_t sub_1002D8848()
{
  return 1;
}

_QWORD *sub_1002D8850@<X0>(_QWORD *a1@<X8>)
{
  return sub_1015A2E04(a1, "CLMicroLocationProto.MotionEvent");
}

void sub_1002D8860(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  const std::string *v7;
  std::string *v8;
  char v9;
  _BYTE v10[48];

  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage(v10, 3, "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/proto/gen-cpp/microlocation.pb.cc", 15169);
    v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<(v10, "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v9, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v10);
  }
  LOBYTE(v5) = *(_BYTE *)(a2 + 24);
  if ((_BYTE)v5)
  {
    if ((*(_BYTE *)(a2 + 24) & 1) != 0)
    {
      v6 = *(_DWORD *)(a2 + 16);
      if (v6 - 31 >= 0x19 && (v6 > 0xE || ((1 << v6) & 0x76B6) == 0))
        sub_1018F2574();
      *(_DWORD *)(a1 + 24) |= 1u;
      *(_DWORD *)(a1 + 16) = v6;
      v5 = *(_DWORD *)(a2 + 24);
    }
    if ((v5 & 2) != 0)
    {
      v7 = *(const std::string **)(a2 + 8);
      *(_DWORD *)(a1 + 24) |= 2u;
      v8 = *(std::string **)(a1 + 8);
      if (v8 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
        operator new();
      std::string::operator=(v8, v7);
    }
  }
}

void sub_1002D8970(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_1002D8988(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(_QWORD *)a1 = off_10212D418;
  sub_100109DDC((uint64_t)a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_1002D89B8(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(_QWORD *)a1 = off_10212D418;
  sub_100109DDC((uint64_t)a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete();
}

void sub_1002D89FC()
{
  operator new();
}

uint64_t sub_1002D8A48(uint64_t result)
{
  char v1;
  uint64_t v2;

  v1 = *(_BYTE *)(result + 24);
  if (v1)
  {
    *(_DWORD *)(result + 16) = 46;
    if ((v1 & 2) != 0)
    {
      v2 = *(_QWORD *)(result + 8);
      if ((_UNKNOWN *)v2 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v2 + 23) < 0)
        {
          **(_BYTE **)v2 = 0;
          *(_QWORD *)(v2 + 8) = 0;
        }
        else
        {
          *(_BYTE *)v2 = 0;
          *(_BYTE *)(v2 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(result + 24) = 0;
  return result;
}

uint64_t sub_1002D8A98(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  char *v5;
  wireless_diagnostics::google::protobuf::io::CodedInputStream *TagFallback;
  int v7;
  char *v8;
  unsigned int v9;
  BOOL v10;
  _BYTE *v12;
  void *v13;
  uint64_t result;
  unsigned int v15;

  while (1)
  {
    while (1)
    {
      v5 = (char *)*((_QWORD *)this + 1);
      if ((unint64_t)v5 >= *((_QWORD *)this + 2) || *v5 < 0)
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        if (!(_DWORD)TagFallback)
          return 1;
      }
      else
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        *((_QWORD *)this + 1) = v5 + 1;
        if (!(_DWORD)TagFallback)
          return 1;
      }
      if (TagFallback >> 3 != 1)
        break;
      v7 = TagFallback & 7;
      if ((TagFallback & 7) != 0)
        goto LABEL_15;
      v15 = 0;
      v8 = (char *)*((_QWORD *)this + 1);
      if ((unint64_t)v8 >= *((_QWORD *)this + 2) || *v8 < 0)
      {
        result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v15);
        if (!(_DWORD)result)
          return result;
        v9 = v15;
      }
      else
      {
        v9 = *v8;
        *((_QWORD *)this + 1) = v8 + 1;
      }
      if (v9 - 31 < 0x19 || (v9 <= 0xE ? (v10 = ((1 << v9) & 0x76B6) == 0) : (v10 = 1), !v10))
      {
        if (v9 - 31 >= 0x19 && (v9 > 0xE || ((1 << v9) & 0x76B6) == 0))
          sub_1018F2574();
        *(_DWORD *)(a1 + 24) |= 1u;
        *(_DWORD *)(a1 + 16) = v9;
      }
      v12 = (_BYTE *)*((_QWORD *)this + 1);
      if ((unint64_t)v12 < *((_QWORD *)this + 2) && *v12 == 18)
      {
        *((_QWORD *)this + 1) = v12 + 1;
LABEL_34:
        *(_DWORD *)(a1 + 24) |= 2u;
        v13 = *(void **)(a1 + 8);
        if (v13 == &wireless_diagnostics::google::protobuf::internal::kEmptyString)
          operator new();
        result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString(this, v13);
        if (!(_DWORD)result)
          return result;
        if (*((_QWORD *)this + 1) == *((_QWORD *)this + 2)
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          result = 1;
          *((_BYTE *)this + 36) = 1;
          return result;
        }
      }
    }
    if (TagFallback >> 3 == 2)
    {
      v7 = TagFallback & 7;
      if (v7 == 2)
        goto LABEL_34;
    }
    else
    {
      v7 = TagFallback & 7;
    }
LABEL_15:
    if (v7 == 4)
      return 1;
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, TagFallback, a3) & 1) == 0)
      return 0;
  }
}

uint64_t sub_1002D8CA0(uint64_t result, uint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5;
  int v6;

  v5 = result;
  v6 = *(_DWORD *)(result + 24);
  if ((v6 & 1) != 0)
  {
    result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 16), a2, a4);
    v6 = *(_DWORD *)(v5 + 24);
  }
  if ((v6 & 2) != 0)
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString(2, *(_QWORD *)(v5 + 8), a2);
  return result;
}

uint64_t sub_1002D8CF8(uint64_t a1, unsigned int a2)
{
  char v3;
  uint64_t v4;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v5;
  uint64_t v6;
  int v7;
  char v8;
  uint64_t v9;
  unint64_t v10;
  int v11;

  v3 = *(_BYTE *)(a1 + 24);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 24) & 1) != 0)
    {
      v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
      if ((v5 & 0x80000000) != 0)
      {
        v4 = 11;
        if ((v3 & 2) == 0)
          goto LABEL_22;
      }
      else if (v5 >= 0x80)
      {
        v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2)
           + 1;
        if ((*(_DWORD *)(a1 + 24) & 2) == 0)
          goto LABEL_22;
      }
      else
      {
        v4 = 2;
        if ((v3 & 2) == 0)
          goto LABEL_22;
      }
    }
    else
    {
      v4 = 0;
      if ((*(_BYTE *)(a1 + 24) & 2) == 0)
        goto LABEL_22;
    }
    v6 = *(_QWORD *)(a1 + 8);
    v7 = *(unsigned __int8 *)(v6 + 23);
    v8 = v7;
    v9 = *(_QWORD *)(v6 + 8);
    if ((v7 & 0x80u) == 0)
      v10 = *(unsigned __int8 *)(v6 + 23);
    else
      v10 = v9;
    if (v10 >= 0x80)
    {
      v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v10, a2);
      v7 = *(unsigned __int8 *)(v6 + 23);
      v9 = *(_QWORD *)(v6 + 8);
      v8 = *(_BYTE *)(v6 + 23);
    }
    else
    {
      v11 = 1;
    }
    if (v8 < 0)
      v7 = v9;
    v4 = (v4 + v11 + v7 + 1);
  }
  else
  {
    v4 = 0;
  }
LABEL_22:
  *(_DWORD *)(a1 + 20) = v4;
  return v4;
}

void sub_1002D8DCC(uint64_t a1, void *lpsrc)
{
  uint64_t v4;
  uint64_t v5;

  sub_1002D8860(a1, (uint64_t)lpsrc);
}

void sub_1002D8E18(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
    sub_1002D8860(a1, a2);
  }
}

uint64_t sub_1002D8E58()
{
  return 1;
}

_QWORD *sub_1002D8E60@<X0>(_QWORD *a1@<X8>)
{
  return sub_1015A2E04(a1, "CLMicroLocationProto.LegacyThrottle");
}

void sub_1002D8E70(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  char v7;
  const std::string *v8;
  std::string *v9;
  const std::string *v10;
  std::string *v11;
  const std::string *v12;
  std::string *v13;
  int v14;
  char v15;
  _BYTE v16[48];

  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage(v16, 3, "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/proto/gen-cpp/microlocation.pb.cc", 15517);
    v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<(v16, "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v15, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v16);
  }
  LOBYTE(v5) = *(_BYTE *)(a2 + 48);
  if (!(_BYTE)v5)
    return;
  if ((*(_BYTE *)(a2 + 48) & 1) != 0)
  {
    v6 = *(_DWORD *)(a2 + 24);
    if (v6 - 31 >= 0x19 && (v6 > 0xE || ((1 << v6) & 0x76B6) == 0))
      sub_1018F25C4();
    *(_DWORD *)(a1 + 48) |= 1u;
    *(_DWORD *)(a1 + 24) = v6;
    v5 = *(_DWORD *)(a2 + 48);
  }
  if ((v5 & 2) != 0)
  {
    v8 = *(const std::string **)(a2 + 8);
    *(_DWORD *)(a1 + 48) |= 2u;
    v9 = *(std::string **)(a1 + 8);
    if (v9 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      operator new();
    std::string::operator=(v9, v8);
    v5 = *(_DWORD *)(a2 + 48);
    if ((v5 & 4) == 0)
    {
LABEL_11:
      if ((v5 & 8) == 0)
        goto LABEL_12;
LABEL_22:
      v12 = *(const std::string **)(a2 + 32);
      *(_DWORD *)(a1 + 48) |= 8u;
      v13 = *(std::string **)(a1 + 32);
      if (v13 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
        operator new();
      std::string::operator=(v13, v12);
      v5 = *(_DWORD *)(a2 + 48);
      if ((v5 & 0x10) == 0)
      {
LABEL_13:
        if ((v5 & 0x20) == 0)
          return;
        goto LABEL_14;
      }
      goto LABEL_25;
    }
  }
  else if ((v5 & 4) == 0)
  {
    goto LABEL_11;
  }
  v10 = *(const std::string **)(a2 + 16);
  *(_DWORD *)(a1 + 48) |= 4u;
  v11 = *(std::string **)(a1 + 16);
  if (v11 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    operator new();
  std::string::operator=(v11, v10);
  v5 = *(_DWORD *)(a2 + 48);
  if ((v5 & 8) != 0)
    goto LABEL_22;
LABEL_12:
  if ((v5 & 0x10) == 0)
    goto LABEL_13;
LABEL_25:
  v14 = *(_DWORD *)(a2 + 28);
  if ((v14 - 1) >= 0xB)
    sub_1018F259C();
  *(_DWORD *)(a1 + 48) |= 0x10u;
  *(_DWORD *)(a1 + 28) = v14;
  if ((*(_DWORD *)(a2 + 48) & 0x20) != 0)
  {
LABEL_14:
    v7 = *(_BYTE *)(a2 + 40);
    *(_DWORD *)(a1 + 48) |= 0x20u;
    *(_BYTE *)(a1 + 40) = v7;
  }
}

void sub_1002D9094(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

_QWORD *sub_1002D90AC(_QWORD *result)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v5;

  v1 = result[1];
  if ((_UNKNOWN *)v1 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v1 != 0)
  {
    if (*(char *)(v1 + 23) < 0)
      operator delete(*(void **)v1);
    operator delete();
  }
  v3 = result[2];
  if ((_UNKNOWN *)v3 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v3 != 0)
  {
    if (*(char *)(v3 + 23) < 0)
      operator delete(*(void **)v3);
    operator delete();
  }
  v5 = result[4];
  if ((_UNKNOWN *)v5 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v5 != 0)
  {
    if (*(char *)(v5 + 23) < 0)
      operator delete(*(void **)v5);
    operator delete();
  }
  return result;
}

void sub_1002D918C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(_QWORD *)a1 = off_10212D490;
  sub_1002D90AC(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_1002D91BC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(_QWORD *)a1 = off_10212D490;
  sub_1002D90AC(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete();
}

void sub_1002D9200()
{
  operator new();
}

uint64_t sub_1002D9258(uint64_t result)
{
  char v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v1 = *(_BYTE *)(result + 48);
  if (v1)
  {
    *(_DWORD *)(result + 24) = 47;
    if ((v1 & 2) != 0)
    {
      v2 = *(_QWORD *)(result + 8);
      if ((_UNKNOWN *)v2 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v2 + 23) < 0)
        {
          **(_BYTE **)v2 = 0;
          *(_QWORD *)(v2 + 8) = 0;
        }
        else
        {
          *(_BYTE *)v2 = 0;
          *(_BYTE *)(v2 + 23) = 0;
        }
      }
    }
    if ((*(_BYTE *)(result + 48) & 4) != 0)
    {
      v3 = *(_QWORD *)(result + 16);
      if ((_UNKNOWN *)v3 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v3 + 23) < 0)
        {
          **(_BYTE **)v3 = 0;
          *(_QWORD *)(v3 + 8) = 0;
        }
        else
        {
          *(_BYTE *)v3 = 0;
          *(_BYTE *)(v3 + 23) = 0;
        }
      }
    }
    if ((*(_BYTE *)(result + 48) & 8) != 0)
    {
      v4 = *(_QWORD *)(result + 32);
      if ((_UNKNOWN *)v4 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v4 + 23) < 0)
        {
          **(_BYTE **)v4 = 0;
          *(_QWORD *)(v4 + 8) = 0;
        }
        else
        {
          *(_BYTE *)v4 = 0;
          *(_BYTE *)(v4 + 23) = 0;
        }
      }
    }
    *(_DWORD *)(result + 28) = 1;
    *(_BYTE *)(result + 40) = 0;
  }
  *(_DWORD *)(result + 48) = 0;
  return result;
}

uint64_t sub_1002D931C(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  char *v5;
  wireless_diagnostics::google::protobuf::io::CodedInputStream *TagFallback;
  int v7;
  char *v8;
  unsigned int v9;
  unint64_t v10;
  char *v11;
  unint64_t v12;
  char *v13;
  BOOL v14;
  _BYTE *v15;
  void *v16;
  _BYTE *v17;
  void *v18;
  _BYTE *v19;
  void *v20;
  _BYTE *v21;
  unsigned int v22;
  _BYTE *v23;
  unsigned int v24;
  unsigned __int8 *v25;
  uint64_t result;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;

  while (2)
  {
    v5 = (char *)*((_QWORD *)this + 1);
    if ((unint64_t)v5 >= *((_QWORD *)this + 2) || *v5 < 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      if (!(_DWORD)TagFallback)
        return 1;
    }
    else
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((_QWORD *)this + 1) = v5 + 1;
      if (!(_DWORD)TagFallback)
        return 1;
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0)
          goto LABEL_22;
        v28 = 0;
        v8 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v8 < *((_QWORD *)this + 2) && (*v8 & 0x80000000) == 0)
        {
          v9 = *v8;
          *((_QWORD *)this + 1) = v8 + 1;
LABEL_27:
          if (v9 - 31 < 0x19 || (v9 <= 0xE ? (v14 = ((1 << v9) & 0x76B6) == 0) : (v14 = 1), !v14))
          {
            if (v9 - 31 >= 0x19 && (v9 > 0xE || ((1 << v9) & 0x76B6) == 0))
              sub_1018F25C4();
            *(_DWORD *)(a1 + 48) |= 1u;
            *(_DWORD *)(a1 + 24) = v9;
          }
          v15 = (_BYTE *)*((_QWORD *)this + 1);
          if ((unint64_t)v15 < *((_QWORD *)this + 2) && *v15 == 18)
          {
            *((_QWORD *)this + 1) = v15 + 1;
            goto LABEL_39;
          }
          continue;
        }
        result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v28);
        if ((_DWORD)result)
        {
          v9 = v28;
          goto LABEL_27;
        }
        break;
      case 2u:
        v7 = TagFallback & 7;
        if (v7 != 2)
          goto LABEL_22;
LABEL_39:
        *(_DWORD *)(a1 + 48) |= 2u;
        v16 = *(void **)(a1 + 8);
        if (v16 == &wireless_diagnostics::google::protobuf::internal::kEmptyString)
          operator new();
        result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes(this, v16);
        if (!(_DWORD)result)
          return result;
        v17 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v17 >= *((_QWORD *)this + 2) || *v17 != 26)
          continue;
        *((_QWORD *)this + 1) = v17 + 1;
LABEL_45:
        *(_DWORD *)(a1 + 48) |= 4u;
        v18 = *(void **)(a1 + 16);
        if (v18 == &wireless_diagnostics::google::protobuf::internal::kEmptyString)
          operator new();
        result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString(this, v18);
        if (!(_DWORD)result)
          return result;
        v19 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v19 >= *((_QWORD *)this + 2) || *v19 != 34)
          continue;
        *((_QWORD *)this + 1) = v19 + 1;
LABEL_51:
        *(_DWORD *)(a1 + 48) |= 8u;
        v20 = *(void **)(a1 + 32);
        if (v20 == &wireless_diagnostics::google::protobuf::internal::kEmptyString)
          operator new();
        result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes(this, v20);
        if (!(_DWORD)result)
          return result;
        v21 = (_BYTE *)*((_QWORD *)this + 1);
        v10 = *((_QWORD *)this + 2);
        if ((unint64_t)v21 >= v10 || *v21 != 40)
          continue;
        v11 = v21 + 1;
        *((_QWORD *)this + 1) = v11;
LABEL_57:
        v27 = 0;
        if ((unint64_t)v11 >= v10 || *v11 < 0)
        {
          result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v27);
          if (!(_DWORD)result)
            return result;
          v22 = v27;
        }
        else
        {
          v22 = *v11;
          *((_QWORD *)this + 1) = v11 + 1;
        }
        if (v22 - 1 <= 0xA)
        {
          *(_DWORD *)(a1 + 48) |= 0x10u;
          *(_DWORD *)(a1 + 28) = v22;
        }
        v23 = (_BYTE *)*((_QWORD *)this + 1);
        v12 = *((_QWORD *)this + 2);
        if ((unint64_t)v23 >= v12 || *v23 != 48)
          continue;
        v13 = v23 + 1;
        *((_QWORD *)this + 1) = v13;
LABEL_67:
        v29 = 0;
        if ((unint64_t)v13 >= v12 || *v13 < 0)
        {
          result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v29);
          if (!(_DWORD)result)
            return result;
          v24 = v29;
          v25 = (unsigned __int8 *)*((_QWORD *)this + 1);
          v12 = *((_QWORD *)this + 2);
        }
        else
        {
          v24 = *v13;
          v25 = (unsigned __int8 *)(v13 + 1);
          *((_QWORD *)this + 1) = v25;
        }
        *(_BYTE *)(a1 + 40) = v24 != 0;
        *(_DWORD *)(a1 + 48) |= 0x20u;
        if (v25 != (unsigned __int8 *)v12 || !*((_DWORD *)this + 11) && *((_DWORD *)this + 6) != *((_DWORD *)this + 10))
          continue;
        *((_DWORD *)this + 8) = 0;
        result = 1;
        *((_BYTE *)this + 36) = 1;
        return result;
      case 3u:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_45;
        goto LABEL_22;
      case 4u:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_51;
        goto LABEL_22;
      case 5u:
        v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0)
          goto LABEL_22;
        v11 = (char *)*((_QWORD *)this + 1);
        v10 = *((_QWORD *)this + 2);
        goto LABEL_57;
      case 6u:
        v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0)
          goto LABEL_22;
        v13 = (char *)*((_QWORD *)this + 1);
        v12 = *((_QWORD *)this + 2);
        goto LABEL_67;
      default:
        v7 = TagFallback & 7;
LABEL_22:
        if (v7 == 4)
          return 1;
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, TagFallback, a3) & 1) != 0)
          continue;
        return 0;
    }
    return result;
  }
}

uint64_t sub_1002D9734(uint64_t result, uint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5;
  int v6;

  v5 = result;
  v6 = *(_DWORD *)(result + 48);
  if ((v6 & 1) != 0)
  {
    result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 24), a2, a4);
    v6 = *(_DWORD *)(v5 + 48);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0)
        goto LABEL_4;
      goto LABEL_10;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes(2, *(_QWORD *)(v5 + 8), a2);
  v6 = *(_DWORD *)(v5 + 48);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0)
      goto LABEL_5;
    goto LABEL_11;
  }
LABEL_10:
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString(3, *(_QWORD *)(v5 + 16), a2);
  v6 = *(_DWORD *)(v5 + 48);
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0)
      goto LABEL_6;
    goto LABEL_12;
  }
LABEL_11:
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes(4, *(_QWORD *)(v5 + 32), a2);
  v6 = *(_DWORD *)(v5 + 48);
  if ((v6 & 0x10) == 0)
  {
LABEL_6:
    if ((v6 & 0x20) == 0)
      return result;
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, *(unsigned __int8 *)(v5 + 40), a2, a4);
  }
LABEL_12:
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, *(_DWORD *)(v5 + 28), a2, a4);
  if ((*(_DWORD *)(v5 + 48) & 0x20) != 0)
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, *(unsigned __int8 *)(v5 + 40), a2, a4);
  return result;
}

uint64_t sub_1002D9800(uint64_t a1, unsigned int a2)
{
  int v3;
  unsigned int v4;
  uint64_t result;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v6;
  uint64_t v7;
  int v8;
  char v9;
  uint64_t v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  char v15;
  uint64_t v16;
  unint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  char v21;
  uint64_t v22;
  unint64_t v23;
  int v24;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v25;
  int v26;

  LOBYTE(v3) = *(_BYTE *)(a1 + 48);
  if (!(_BYTE)v3)
  {
    result = 0;
    goto LABEL_53;
  }
  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 24);
    if ((v6 & 0x80000000) != 0)
    {
      v4 = 11;
      if ((v3 & 2) == 0)
        goto LABEL_22;
    }
    else if (v6 >= 0x80)
    {
      v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 1;
      v3 = *(_DWORD *)(a1 + 48);
      if ((v3 & 2) == 0)
        goto LABEL_22;
    }
    else
    {
      v4 = 2;
      if ((v3 & 2) == 0)
        goto LABEL_22;
    }
  }
  else
  {
    v4 = 0;
    if ((*(_BYTE *)(a1 + 48) & 2) == 0)
      goto LABEL_22;
  }
  v7 = *(_QWORD *)(a1 + 8);
  v8 = *(unsigned __int8 *)(v7 + 23);
  v9 = v8;
  v10 = *(_QWORD *)(v7 + 8);
  if ((v8 & 0x80u) == 0)
    v11 = *(unsigned __int8 *)(v7 + 23);
  else
    v11 = v10;
  if (v11 >= 0x80)
  {
    v12 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v11, a2);
    v8 = *(unsigned __int8 *)(v7 + 23);
    v10 = *(_QWORD *)(v7 + 8);
    v3 = *(_DWORD *)(a1 + 48);
    v9 = *(_BYTE *)(v7 + 23);
  }
  else
  {
    v12 = 1;
  }
  if (v9 < 0)
    v8 = v10;
  v4 += v12 + v8 + 1;
LABEL_22:
  if ((v3 & 4) == 0)
  {
    if ((v3 & 8) == 0)
      goto LABEL_24;
LABEL_35:
    v19 = *(_QWORD *)(a1 + 32);
    v20 = *(unsigned __int8 *)(v19 + 23);
    v21 = v20;
    v22 = *(_QWORD *)(v19 + 8);
    if ((v20 & 0x80u) == 0)
      v23 = *(unsigned __int8 *)(v19 + 23);
    else
      v23 = v22;
    if (v23 >= 0x80)
    {
      v24 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v23, a2);
      v20 = *(unsigned __int8 *)(v19 + 23);
      v22 = *(_QWORD *)(v19 + 8);
      v3 = *(_DWORD *)(a1 + 48);
      v21 = *(_BYTE *)(v19 + 23);
    }
    else
    {
      v24 = 1;
    }
    if (v21 < 0)
      v20 = v22;
    v4 += v24 + v20 + 1;
    if ((v3 & 0x10) == 0)
      goto LABEL_50;
    goto LABEL_44;
  }
  v13 = *(_QWORD *)(a1 + 16);
  v14 = *(unsigned __int8 *)(v13 + 23);
  v15 = v14;
  v16 = *(_QWORD *)(v13 + 8);
  if ((v14 & 0x80u) == 0)
    v17 = *(unsigned __int8 *)(v13 + 23);
  else
    v17 = v16;
  if (v17 >= 0x80)
  {
    v18 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v17, a2);
    v14 = *(unsigned __int8 *)(v13 + 23);
    v16 = *(_QWORD *)(v13 + 8);
    v3 = *(_DWORD *)(a1 + 48);
    v15 = *(_BYTE *)(v13 + 23);
  }
  else
  {
    v18 = 1;
  }
  if (v15 < 0)
    v14 = v16;
  v4 += v18 + v14 + 1;
  if ((v3 & 8) != 0)
    goto LABEL_35;
LABEL_24:
  if ((v3 & 0x10) != 0)
  {
LABEL_44:
    v25 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 28);
    if ((v25 & 0x80000000) != 0)
    {
      v26 = 11;
    }
    else if (v25 >= 0x80)
    {
      v26 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v25, a2) + 1;
      v3 = *(_DWORD *)(a1 + 48);
    }
    else
    {
      v26 = 2;
    }
    v4 += v26;
  }
LABEL_50:
  if ((v3 & 0x20) != 0)
    result = v4 + 2;
  else
    result = v4;
LABEL_53:
  *(_DWORD *)(a1 + 44) = result;
  return result;
}

void sub_1002D99D0(uint64_t a1, void *lpsrc)
{
  uint64_t v4;
  uint64_t v5;

  sub_1002D8E70(a1, (uint64_t)lpsrc);
}

void sub_1002D9A1C(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
    sub_1002D8E70(a1, a2);
  }
}

uint64_t sub_1002D9A5C()
{
  return 1;
}

_QWORD *sub_1002D9A64@<X0>(_QWORD *a1@<X8>)
{
  return sub_1015A2E04(a1, "CLMicroLocationProto.RetrievedLoi");
}

void sub_1002D9A74(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  const std::string *v7;
  std::string *v8;
  char v9;
  _BYTE v10[48];

  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage(v10, 3, "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/proto/gen-cpp/microlocation.pb.cc", 15744);
    v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<(v10, "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v9, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v10);
  }
  LOBYTE(v5) = *(_BYTE *)(a2 + 24);
  if ((_BYTE)v5)
  {
    if ((*(_BYTE *)(a2 + 24) & 1) != 0)
    {
      v6 = *(_DWORD *)(a2 + 16);
      if (v6 - 31 >= 0x19 && (v6 > 0xE || ((1 << v6) & 0x76B6) == 0))
        sub_1018F25EC();
      *(_DWORD *)(a1 + 24) |= 1u;
      *(_DWORD *)(a1 + 16) = v6;
      v5 = *(_DWORD *)(a2 + 24);
    }
    if ((v5 & 2) != 0)
    {
      v7 = *(const std::string **)(a2 + 8);
      *(_DWORD *)(a1 + 24) |= 2u;
      v8 = *(std::string **)(a1 + 8);
      if (v8 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
        operator new();
      std::string::operator=(v8, v7);
    }
  }
}

void sub_1002D9B84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_1002D9B9C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(_QWORD *)a1 = off_10212D508;
  sub_100109DDC((uint64_t)a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_1002D9BCC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(_QWORD *)a1 = off_10212D508;
  sub_100109DDC((uint64_t)a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete();
}

void sub_1002D9C10()
{
  operator new();
}

uint64_t sub_1002D9C5C(uint64_t result)
{
  char v1;
  uint64_t v2;

  v1 = *(_BYTE *)(result + 24);
  if (v1)
  {
    *(_DWORD *)(result + 16) = 55;
    if ((v1 & 2) != 0)
    {
      v2 = *(_QWORD *)(result + 8);
      if ((_UNKNOWN *)v2 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v2 + 23) < 0)
        {
          **(_BYTE **)v2 = 0;
          *(_QWORD *)(v2 + 8) = 0;
        }
        else
        {
          *(_BYTE *)v2 = 0;
          *(_BYTE *)(v2 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(result + 24) = 0;
  return result;
}

uint64_t sub_1002D9CAC(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  char *v5;
  wireless_diagnostics::google::protobuf::io::CodedInputStream *TagFallback;
  int v7;
  char *v8;
  unsigned int v9;
  BOOL v10;
  _BYTE *v12;
  void *v13;
  uint64_t result;
  unsigned int v15;

  while (1)
  {
    while (1)
    {
      v5 = (char *)*((_QWORD *)this + 1);
      if ((unint64_t)v5 >= *((_QWORD *)this + 2) || *v5 < 0)
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        if (!(_DWORD)TagFallback)
          return 1;
      }
      else
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        *((_QWORD *)this + 1) = v5 + 1;
        if (!(_DWORD)TagFallback)
          return 1;
      }
      if (TagFallback >> 3 != 1)
        break;
      v7 = TagFallback & 7;
      if ((TagFallback & 7) != 0)
        goto LABEL_15;
      v15 = 0;
      v8 = (char *)*((_QWORD *)this + 1);
      if ((unint64_t)v8 >= *((_QWORD *)this + 2) || *v8 < 0)
      {
        result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v15);
        if (!(_DWORD)result)
          return result;
        v9 = v15;
      }
      else
      {
        v9 = *v8;
        *((_QWORD *)this + 1) = v8 + 1;
      }
      if (v9 - 31 < 0x19 || (v9 <= 0xE ? (v10 = ((1 << v9) & 0x76B6) == 0) : (v10 = 1), !v10))
      {
        if (v9 - 31 >= 0x19 && (v9 > 0xE || ((1 << v9) & 0x76B6) == 0))
          sub_1018F25EC();
        *(_DWORD *)(a1 + 24) |= 1u;
        *(_DWORD *)(a1 + 16) = v9;
      }
      v12 = (_BYTE *)*((_QWORD *)this + 1);
      if ((unint64_t)v12 < *((_QWORD *)this + 2) && *v12 == 18)
      {
        *((_QWORD *)this + 1) = v12 + 1;
LABEL_34:
        *(_DWORD *)(a1 + 24) |= 2u;
        v13 = *(void **)(a1 + 8);
        if (v13 == &wireless_diagnostics::google::protobuf::internal::kEmptyString)
          operator new();
        result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes(this, v13);
        if (!(_DWORD)result)
          return result;
        if (*((_QWORD *)this + 1) == *((_QWORD *)this + 2)
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          result = 1;
          *((_BYTE *)this + 36) = 1;
          return result;
        }
      }
    }
    if (TagFallback >> 3 == 2)
    {
      v7 = TagFallback & 7;
      if (v7 == 2)
        goto LABEL_34;
    }
    else
    {
      v7 = TagFallback & 7;
    }
LABEL_15:
    if (v7 == 4)
      return 1;
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, TagFallback, a3) & 1) == 0)
      return 0;
  }
}

uint64_t sub_1002D9EB4(uint64_t result, uint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5;
  int v6;

  v5 = result;
  v6 = *(_DWORD *)(result + 24);
  if ((v6 & 1) != 0)
  {
    result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 16), a2, a4);
    v6 = *(_DWORD *)(v5 + 24);
  }
  if ((v6 & 2) != 0)
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes(2, *(_QWORD *)(v5 + 8), a2);
  return result;
}

uint64_t sub_1002D9F0C(uint64_t a1, unsigned int a2)
{
  char v3;
  uint64_t v4;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v5;
  uint64_t v6;
  int v7;
  char v8;
  uint64_t v9;
  unint64_t v10;
  int v11;

  v3 = *(_BYTE *)(a1 + 24);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 24) & 1) != 0)
    {
      v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
      if ((v5 & 0x80000000) != 0)
      {
        v4 = 11;
        if ((v3 & 2) == 0)
          goto LABEL_22;
      }
      else if (v5 >= 0x80)
      {
        v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2)
           + 1;
        if ((*(_DWORD *)(a1 + 24) & 2) == 0)
          goto LABEL_22;
      }
      else
      {
        v4 = 2;
        if ((v3 & 2) == 0)
          goto LABEL_22;
      }
    }
    else
    {
      v4 = 0;
      if ((*(_BYTE *)(a1 + 24) & 2) == 0)
        goto LABEL_22;
    }
    v6 = *(_QWORD *)(a1 + 8);
    v7 = *(unsigned __int8 *)(v6 + 23);
    v8 = v7;
    v9 = *(_QWORD *)(v6 + 8);
    if ((v7 & 0x80u) == 0)
      v10 = *(unsigned __int8 *)(v6 + 23);
    else
      v10 = v9;
    if (v10 >= 0x80)
    {
      v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v10, a2);
      v7 = *(unsigned __int8 *)(v6 + 23);
      v9 = *(_QWORD *)(v6 + 8);
      v8 = *(_BYTE *)(v6 + 23);
    }
    else
    {
      v11 = 1;
    }
    if (v8 < 0)
      v7 = v9;
    v4 = (v4 + v11 + v7 + 1);
  }
  else
  {
    v4 = 0;
  }
LABEL_22:
  *(_DWORD *)(a1 + 20) = v4;
  return v4;
}

void sub_1002D9FE0(uint64_t a1, void *lpsrc)
{
  uint64_t v4;
  uint64_t v5;

  sub_1002D9A74(a1, (uint64_t)lpsrc);
}

void sub_1002DA02C(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
    sub_1002D9A74(a1, a2);
  }
}

uint64_t sub_1002DA06C()
{
  return 1;
}

_QWORD *sub_1002DA074@<X0>(_QWORD *a1@<X8>)
{
  return sub_1015A2E04(a1, "CLMicroLocationProto.EnableAtCurrentLocation");
}

void sub_1002DA084(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(_QWORD *)a1 = off_10212D580;
  sub_1000B2778(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete();
}

void sub_1002DA0C8()
{
  operator new();
}

uint64_t sub_1002DA14C(uint64_t result)
{
  uint64_t v1;
  unsigned int *v2;
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;

  v1 = result;
  v2 = (unsigned int *)(result + 292);
  v3 = *(_DWORD *)(result + 292);
  if ((_BYTE)v3)
  {
    if ((v3 & 1) != 0)
    {
      result = *(_QWORD *)(result + 8);
      if (result)
      {
        result = sub_1002CA600(result);
        v3 = *v2;
      }
    }
    if ((v3 & 2) != 0)
    {
      result = *(_QWORD *)(v1 + 16);
      if (result)
      {
        result = sub_1002CBB28(result);
        v3 = *v2;
      }
    }
    if ((v3 & 4) != 0)
    {
      result = *(_QWORD *)(v1 + 24);
      if (result)
      {
        result = sub_1002CC428(result);
        v3 = *v2;
      }
    }
    if ((v3 & 8) != 0)
    {
      v4 = *(_QWORD *)(v1 + 32);
      if (v4)
      {
        if (*(_BYTE *)(v4 + 16))
          *(_DWORD *)(v4 + 8) = 5;
        *(_DWORD *)(v4 + 16) = 0;
        v3 = *v2;
      }
    }
    if ((v3 & 0x10) != 0)
    {
      v5 = *(_QWORD *)(v1 + 40);
      if (v5)
      {
        if (*(_BYTE *)(v5 + 16))
          *(_DWORD *)(v5 + 8) = 7;
        *(_DWORD *)(v5 + 16) = 0;
        v3 = *v2;
      }
    }
    if ((v3 & 0x20) != 0)
    {
      result = *(_QWORD *)(v1 + 48);
      if (result)
      {
        result = sub_1002CE358(result);
        v3 = *v2;
      }
    }
    if ((v3 & 0x40) != 0)
    {
      result = *(_QWORD *)(v1 + 56);
      if (result)
      {
        result = sub_1002CFC98(result);
        v3 = *v2;
      }
    }
    if ((v3 & 0x80) != 0)
    {
      result = *(_QWORD *)(v1 + 64);
      if (result)
      {
        result = sub_1002D1598(result);
        v3 = *v2;
      }
    }
  }
  if ((v3 & 0xFF00) != 0)
  {
    if ((v3 & 0x100) != 0)
    {
      result = *(_QWORD *)(v1 + 72);
      if (result)
      {
        result = sub_1002CB034(result);
        v3 = *v2;
      }
    }
    if ((v3 & 0x200) != 0)
    {
      result = *(_QWORD *)(v1 + 80);
      if (result)
      {
        result = sub_1002CCFC4(result);
        v3 = *v2;
      }
    }
    if ((v3 & 0x400) != 0)
    {
      v6 = *(_QWORD *)(v1 + 88);
      if (v6)
      {
        if (*(_BYTE *)(v6 + 16))
          *(_DWORD *)(v6 + 8) = 31;
        *(_DWORD *)(v6 + 16) = 0;
        v3 = *v2;
      }
    }
    if ((v3 & 0x800) != 0)
    {
      v7 = *(_QWORD *)(v1 + 96);
      if (v7)
      {
        if (*(_BYTE *)(v7 + 16))
          *(_DWORD *)(v7 + 8) = 32;
        *(_DWORD *)(v7 + 16) = 0;
        v3 = *v2;
      }
    }
    if ((v3 & 0x1000) != 0)
    {
      v8 = *(_QWORD *)(v1 + 104);
      if (v8)
      {
        if (*(_BYTE *)(v8 + 16))
          *(_DWORD *)(v8 + 8) = 33;
        *(_DWORD *)(v8 + 16) = 0;
        v3 = *v2;
      }
    }
    if ((v3 & 0x2000) != 0)
    {
      v9 = *(_QWORD *)(v1 + 112);
      if (v9)
      {
        if (*(_BYTE *)(v9 + 16))
          *(_DWORD *)(v9 + 8) = 34;
        *(_DWORD *)(v9 + 16) = 0;
        v3 = *v2;
      }
    }
    if ((v3 & 0x4000) != 0)
    {
      v10 = *(_QWORD *)(v1 + 120);
      if (v10)
      {
        if (*(_BYTE *)(v10 + 16))
          *(_DWORD *)(v10 + 8) = 35;
        *(_DWORD *)(v10 + 16) = 0;
        v3 = *v2;
      }
    }
    if ((v3 & 0x8000) != 0)
    {
      result = *(_QWORD *)(v1 + 128);
      if (result)
      {
        result = sub_1002D3544(result);
        v3 = *v2;
      }
    }
  }
  if ((v3 & 0xFF0000) != 0)
  {
    if ((v3 & 0x10000) != 0)
    {
      result = *(_QWORD *)(v1 + 136);
      if (result)
      {
        result = sub_1002D3D18(result);
        v3 = *v2;
      }
    }
    if ((v3 & 0x20000) != 0)
    {
      result = *(_QWORD *)(v1 + 144);
      if (result)
      {
        result = sub_1002D44BC(result);
        v3 = *v2;
      }
    }
    if ((v3 & 0x40000) != 0)
    {
      result = *(_QWORD *)(v1 + 152);
      if (result)
      {
        result = sub_1002D4C60(result);
        v3 = *v2;
      }
    }
    if ((v3 & 0x80000) != 0)
    {
      result = *(_QWORD *)(v1 + 160);
      if (result)
      {
        result = sub_1002D54D8(result);
        v3 = *v2;
      }
    }
    if ((v3 & 0x100000) != 0)
    {
      result = *(_QWORD *)(v1 + 168);
      if (result)
      {
        result = sub_1002D5D34(result);
        v3 = *v2;
      }
    }
    if ((v3 & 0x200000) != 0)
    {
      result = *(_QWORD *)(v1 + 176);
      if (result)
      {
        result = sub_1002D66B4(result);
        v3 = *v2;
      }
    }
    if ((v3 & 0x400000) != 0)
    {
      result = *(_QWORD *)(v1 + 184);
      if (result)
      {
        result = sub_1002D711C(result);
        v3 = *v2;
      }
    }
    if ((v3 & 0x800000) != 0)
    {
      result = *(_QWORD *)(v1 + 192);
      if (result)
      {
        result = sub_1002D7994(result);
        v3 = *v2;
      }
    }
  }
  if (HIBYTE(v3))
  {
    if ((v3 & 0x1000000) != 0)
    {
      result = *(_QWORD *)(v1 + 200);
      if (result)
      {
        result = sub_1002D8080(result);
        v3 = *v2;
      }
    }
    if ((v3 & 0x2000000) != 0)
    {
      result = *(_QWORD *)(v1 + 208);
      if (result)
      {
        result = sub_1002D8A48(result);
        v3 = *v2;
      }
    }
    if ((v3 & 0x4000000) != 0)
    {
      result = *(_QWORD *)(v1 + 216);
      if (result)
      {
        result = sub_1002D9258(result);
        v3 = *v2;
      }
    }
    if ((v3 & 0x8000000) != 0)
    {
      result = *(_QWORD *)(v1 + 224);
      if (result)
      {
        result = sub_1002DA530(result);
        v3 = *v2;
      }
    }
    if ((v3 & 0x10000000) != 0)
    {
      v11 = *(_QWORD *)(v1 + 232);
      if (v11)
      {
        if (*(_BYTE *)(v11 + 20))
          *(_QWORD *)(v11 + 8) = 0x100000031;
        *(_DWORD *)(v11 + 20) = 0;
        v3 = *v2;
      }
    }
    if ((v3 & 0x20000000) != 0)
    {
      v12 = *(_QWORD *)(v1 + 240);
      if (v12)
      {
        if (*(_BYTE *)(v12 + 20))
        {
          *(_DWORD *)(v12 + 8) = 50;
          *(_BYTE *)(v12 + 12) = 0;
        }
        *(_DWORD *)(v12 + 20) = 0;
        v3 = *v2;
      }
    }
    if ((v3 & 0x40000000) != 0)
    {
      v13 = *(_QWORD *)(v1 + 248);
      if (v13)
      {
        if (*(_BYTE *)(v13 + 24))
        {
          *(_QWORD *)(v13 + 8) = 51;
          *(_WORD *)(v13 + 16) = 0;
        }
        *(_DWORD *)(v13 + 24) = 0;
        v3 = *v2;
      }
    }
    if ((v3 & 0x80000000) != 0)
    {
      v14 = *(_QWORD *)(v1 + 256);
      if (v14)
      {
        if (*(_BYTE *)(v14 + 20))
        {
          *(_DWORD *)(v14 + 8) = 52;
          *(_BYTE *)(v14 + 12) = 0;
        }
        *(_DWORD *)(v14 + 20) = 0;
      }
    }
  }
  LOBYTE(v15) = *(_BYTE *)(v1 + 296);
  if ((_BYTE)v15)
  {
    if ((*(_BYTE *)(v1 + 296) & 1) != 0)
    {
      v16 = *(_QWORD *)(v1 + 264);
      if (v16)
      {
        if (*(_BYTE *)(v16 + 16))
          *(_DWORD *)(v16 + 8) = 53;
        *(_DWORD *)(v16 + 16) = 0;
        v15 = *(_DWORD *)(v1 + 296);
      }
    }
    if ((v15 & 2) != 0)
    {
      v17 = *(_QWORD *)(v1 + 272);
      if (v17)
      {
        if (*(_BYTE *)(v17 + 16))
          *(_DWORD *)(v17 + 8) = 54;
        *(_DWORD *)(v17 + 16) = 0;
        v15 = *(_DWORD *)(v1 + 296);
      }
    }
    if ((v15 & 4) != 0)
    {
      result = *(_QWORD *)(v1 + 280);
      if (result)
        result = sub_1002D9C5C(result);
    }
  }
  *(_QWORD *)v2 = 0;
  return result;
}

uint64_t sub_1002DA530(uint64_t result)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v1 = *(_DWORD *)(result + 80);
  if ((_BYTE)v1)
  {
    *(_DWORD *)(result + 24) = 48;
    *(_QWORD *)(result + 8) = 0;
    *(_BYTE *)(result + 28) = 0;
    if ((v1 & 8) != 0)
    {
      v2 = *(_QWORD *)(result + 16);
      if ((_UNKNOWN *)v2 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v2 + 23) < 0)
        {
          **(_BYTE **)v2 = 0;
          *(_QWORD *)(v2 + 8) = 0;
        }
        else
        {
          *(_BYTE *)v2 = 0;
          *(_BYTE *)(v2 + 23) = 0;
        }
      }
    }
    if ((*(_BYTE *)(result + 80) & 0x10) != 0)
    {
      v3 = *(_QWORD *)(result + 32);
      if ((_UNKNOWN *)v3 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v3 + 23) < 0)
        {
          **(_BYTE **)v3 = 0;
          *(_QWORD *)(v3 + 8) = 0;
        }
        else
        {
          *(_BYTE *)v3 = 0;
          *(_BYTE *)(v3 + 23) = 0;
        }
      }
    }
    if ((*(_BYTE *)(result + 80) & 0x20) != 0)
    {
      v4 = *(_QWORD *)(result + 40);
      if ((_UNKNOWN *)v4 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v4 + 23) < 0)
        {
          **(_BYTE **)v4 = 0;
          *(_QWORD *)(v4 + 8) = 0;
        }
        else
        {
          *(_BYTE *)v4 = 0;
          *(_BYTE *)(v4 + 23) = 0;
        }
      }
    }
    if ((*(_BYTE *)(result + 80) & 0x40) != 0)
    {
      v5 = *(_QWORD *)(result + 48);
      if ((_UNKNOWN *)v5 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v5 + 23) < 0)
        {
          **(_BYTE **)v5 = 0;
          *(_QWORD *)(v5 + 8) = 0;
        }
        else
        {
          *(_BYTE *)v5 = 0;
          *(_BYTE *)(v5 + 23) = 0;
        }
      }
    }
    *(_BYTE *)(result + 29) = 0;
    v1 = *(_DWORD *)(result + 80);
  }
  if ((v1 & 0xFF00) != 0)
  {
    *(_QWORD *)(result + 56) = 0;
    *(_DWORD *)(result + 72) = 0;
    if ((v1 & 0x800) != 0)
    {
      v6 = *(_QWORD *)(result + 64);
      if ((_UNKNOWN *)v6 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v6 + 23) < 0)
        {
          **(_BYTE **)v6 = 0;
          *(_QWORD *)(v6 + 8) = 0;
        }
        else
        {
          *(_BYTE *)v6 = 0;
          *(_BYTE *)(v6 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(result + 80) = 0;
  return result;
}

uint64_t sub_1002DA678(uint64_t result)
{
  if (*(_BYTE *)(result + 20))
    *(_QWORD *)(result + 8) = 0x100000031;
  *(_DWORD *)(result + 20) = 0;
  return result;
}

uint64_t sub_1002DA694(uint64_t result)
{
  if (*(_BYTE *)(result + 20))
  {
    *(_DWORD *)(result + 8) = 50;
    *(_BYTE *)(result + 12) = 0;
  }
  *(_DWORD *)(result + 20) = 0;
  return result;
}

uint64_t sub_1002DA6B0(uint64_t result)
{
  if (*(_BYTE *)(result + 24))
  {
    *(_QWORD *)(result + 8) = 51;
    *(_WORD *)(result + 16) = 0;
  }
  *(_DWORD *)(result + 24) = 0;
  return result;
}

uint64_t sub_1002DA6CC(uint64_t result)
{
  if (*(_BYTE *)(result + 16))
    *(_DWORD *)(result + 8) = 53;
  *(_DWORD *)(result + 16) = 0;
  return result;
}

uint64_t sub_1002DA6E4(uint64_t result)
{
  if (*(_BYTE *)(result + 16))
    *(_DWORD *)(result + 8) = 54;
  *(_DWORD *)(result + 16) = 0;
  return result;
}

uint64_t sub_1002DA6FC(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  char *v5;
  wireless_diagnostics::google::protobuf::io::CodedInputStream *TagFallback;
  int v7;
  uint64_t v8;
  char *v9;
  int v10;
  int v11;
  int v12;
  unsigned int v13;
  int v14;
  BOOL v15;
  int v16;
  _BYTE *v17;
  uint64_t v18;
  char *v19;
  int v20;
  int v21;
  int v22;
  unsigned int v23;
  int v24;
  int v25;
  _BYTE *v26;
  uint64_t v27;
  char *v28;
  int v29;
  int v30;
  int v31;
  unsigned int v32;
  int v33;
  int v34;
  _BYTE *v35;
  uint64_t v36;
  char *v37;
  int v38;
  int v39;
  int v40;
  unsigned int v41;
  int v42;
  int v43;
  _BYTE *v44;
  uint64_t v45;
  char *v46;
  int v47;
  int v48;
  int v49;
  unsigned int v50;
  int v51;
  int v52;
  _BYTE *v53;
  uint64_t v54;
  char *v55;
  int v56;
  int v57;
  int v58;
  unsigned int v59;
  int v60;
  int v61;
  _BYTE *v62;
  uint64_t v63;
  char *v64;
  int v65;
  int v66;
  int v67;
  unsigned int v68;
  int v69;
  int v70;
  _BYTE *v71;
  uint64_t v72;
  char *v73;
  int v74;
  int v75;
  int v76;
  unsigned int v77;
  int v78;
  int v79;
  _BYTE *v80;
  uint64_t v81;
  char *v82;
  int v83;
  int v84;
  int v85;
  unsigned int v86;
  int v87;
  int v88;
  _BYTE *v89;
  uint64_t v90;
  char *v91;
  int v92;
  int v93;
  int v94;
  unsigned int v95;
  int v96;
  int v97;
  _BYTE *v98;
  uint64_t v99;
  char *v100;
  int v101;
  int v102;
  int v103;
  unsigned int v104;
  int v105;
  int v106;
  _BYTE *v107;
  uint64_t v108;
  char *v109;
  int v110;
  int v111;
  int v112;
  unsigned int v113;
  int v114;
  int v115;
  unsigned __int8 *v116;
  uint64_t v117;
  char *v118;
  int v119;
  int v120;
  int v121;
  unsigned int v122;
  int v123;
  int v124;
  unsigned __int8 *v125;
  uint64_t v126;
  char *v127;
  int v128;
  int v129;
  int v130;
  unsigned int v131;
  int v132;
  int v133;
  unsigned __int8 *v134;
  uint64_t v135;
  char *v136;
  int v137;
  int v138;
  int v139;
  unsigned int v140;
  int v141;
  int v142;
  unsigned __int8 *v143;
  uint64_t v144;
  char *v145;
  int v146;
  int v147;
  int v148;
  unsigned int v149;
  int v150;
  int v151;
  unsigned __int8 *v152;
  uint64_t v153;
  char *v154;
  int v155;
  int v156;
  int v157;
  unsigned int v158;
  int v159;
  int v160;
  unsigned __int8 *v161;
  uint64_t v162;
  char *v163;
  int v164;
  int v165;
  int v166;
  unsigned int v167;
  int v168;
  int v169;
  unsigned __int8 *v170;
  uint64_t v171;
  char *v172;
  int v173;
  int v174;
  int v175;
  unsigned int v176;
  int v177;
  int v178;
  unsigned __int8 *v179;
  uint64_t v180;
  char *v181;
  int v182;
  int v183;
  int v184;
  unsigned int v185;
  int v186;
  int v187;
  unsigned __int8 *v188;
  uint64_t v189;
  char *v190;
  int v191;
  int v192;
  int v193;
  unsigned int v194;
  int v195;
  int v196;
  unsigned __int8 *v197;
  uint64_t v198;
  char *v199;
  int v200;
  int v201;
  int v202;
  unsigned int v203;
  int v204;
  int v205;
  unsigned __int8 *v206;
  uint64_t v207;
  char *v208;
  int v209;
  int v210;
  int v211;
  unsigned int v212;
  int v213;
  int v214;
  unsigned __int8 *v215;
  uint64_t v216;
  char *v217;
  int v218;
  int v219;
  int v220;
  unsigned int v221;
  int v222;
  int v223;
  unsigned __int8 *v224;
  uint64_t v225;
  char *v226;
  int v227;
  int v228;
  int v229;
  unsigned int v230;
  int v231;
  int v232;
  unsigned __int8 *v233;
  uint64_t v234;
  char *v235;
  int v236;
  int v237;
  int v238;
  unsigned int v239;
  int v240;
  int v241;
  unsigned __int8 *v242;
  uint64_t v243;
  char *v244;
  int v245;
  int v246;
  int v247;
  unsigned int v248;
  int v249;
  int v250;
  unsigned __int8 *v251;
  uint64_t v252;
  char *v253;
  int v254;
  int v255;
  int v256;
  unsigned int v257;
  int v258;
  int v259;
  unsigned __int8 *v260;
  _DWORD *v261;
  char *v262;
  int v263;
  int v264;
  int v265;
  unsigned int v266;
  int v267;
  int v268;
  unsigned __int8 *v269;
  uint64_t v270;
  char *v271;
  int v272;
  int v273;
  int v274;
  unsigned int v275;
  int v276;
  int v277;
  unsigned __int8 *v278;
  uint64_t v279;
  char *v280;
  int v281;
  int v282;
  int v283;
  unsigned int v284;
  int v285;
  int v286;
  unsigned __int8 *v287;
  uint64_t v288;
  char *v289;
  int v290;
  int v291;
  int v292;
  unsigned int v293;
  int v294;
  int v295;
  unsigned __int8 *v296;
  uint64_t v297;
  char *v298;
  int v299;
  int v300;
  int v301;
  unsigned int v302;
  int v303;
  int v304;
  unsigned __int8 *v305;
  uint64_t v306;
  char *v307;
  int v308;
  int v309;
  int v310;
  unsigned int v311;
  int v312;
  int v313;
  unsigned __int8 *v314;
  uint64_t v315;
  char *v316;
  int v317;
  int v318;
  int v319;
  unsigned int v320;
  int v321;
  int v322;
  uint64_t result;
  unsigned int v324;

  while (1)
  {
    v5 = (char *)*((_QWORD *)this + 1);
    if ((unint64_t)v5 < *((_QWORD *)this + 2) && (*v5 & 0x80000000) == 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((_QWORD *)this + 1) = v5 + 1;
      if (!(_DWORD)TagFallback)
        return 1;
      goto LABEL_6;
    }
    TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
    *((_DWORD *)this + 8) = (_DWORD)TagFallback;
    if (!(_DWORD)TagFallback)
      return 1;
LABEL_6:
    switch(TagFallback >> 3)
    {
      case 1u:
        v7 = TagFallback & 7;
        if (v7 != 2)
          goto LABEL_81;
        *(_DWORD *)(a1 + 292) |= 1u;
        v8 = *(_QWORD *)(a1 + 8);
        if (!v8)
          operator new();
        v324 = 0;
        v9 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v9 >= *((_QWORD *)this + 2) || *v9 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v9;
          *((_QWORD *)this + 1) = v9 + 1;
        }
        v10 = *((_DWORD *)this + 14);
        v11 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v10 + 1;
        if (v10 >= v11)
          return 0;
        v12 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002CA6B8(v8, this, v13) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v12);
        v14 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v14, 1);
        v16 = v14 - 1;
        if (v16 < 0 == v15)
          *((_DWORD *)this + 14) = v16;
        v17 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v17 >= *((_QWORD *)this + 2) || *v17 != 18)
          continue;
        *((_QWORD *)this + 1) = v17 + 1;
        goto LABEL_93;
      case 2u:
        v7 = TagFallback & 7;
        if (v7 != 2)
          goto LABEL_81;
LABEL_93:
        *(_DWORD *)(a1 + 292) |= 2u;
        v18 = *(_QWORD *)(a1 + 16);
        if (!v18)
          operator new();
        v324 = 0;
        v19 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v19 >= *((_QWORD *)this + 2) || *v19 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v19;
          *((_QWORD *)this + 1) = v19 + 1;
        }
        v20 = *((_DWORD *)this + 14);
        v21 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v20 + 1;
        if (v20 >= v21)
          return 0;
        v22 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002CBBCC(v18, this, v23) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v22);
        v24 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v24, 1);
        v25 = v24 - 1;
        if (v25 < 0 == v15)
          *((_DWORD *)this + 14) = v25;
        v26 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v26 >= *((_QWORD *)this + 2) || *v26 != 34)
          continue;
        *((_QWORD *)this + 1) = v26 + 1;
LABEL_107:
        *(_DWORD *)(a1 + 292) |= 4u;
        v27 = *(_QWORD *)(a1 + 24);
        if (!v27)
          operator new();
        v324 = 0;
        v28 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v28 >= *((_QWORD *)this + 2) || *v28 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v28;
          *((_QWORD *)this + 1) = v28 + 1;
        }
        v29 = *((_DWORD *)this + 14);
        v30 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v29 + 1;
        if (v29 >= v30)
          return 0;
        v31 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002CC478(v27, this, v32) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v31);
        v33 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v33, 1);
        v34 = v33 - 1;
        if (v34 < 0 == v15)
          *((_DWORD *)this + 14) = v34;
        v35 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v35 >= *((_QWORD *)this + 2) || *v35 != 42)
          continue;
        *((_QWORD *)this + 1) = v35 + 1;
LABEL_121:
        *(_DWORD *)(a1 + 292) |= 8u;
        v36 = *(_QWORD *)(a1 + 32);
        if (!v36)
          operator new();
        v324 = 0;
        v37 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v37 >= *((_QWORD *)this + 2) || *v37 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v37;
          *((_QWORD *)this + 1) = v37 + 1;
        }
        v38 = *((_DWORD *)this + 14);
        v39 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v38 + 1;
        if (v38 >= v39)
          return 0;
        v40 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002CC9B8(v36, this, v41) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v40);
        v42 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v42, 1);
        v43 = v42 - 1;
        if (v43 < 0 == v15)
          *((_DWORD *)this + 14) = v43;
        v44 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v44 >= *((_QWORD *)this + 2) || *v44 != 58)
          continue;
        *((_QWORD *)this + 1) = v44 + 1;
LABEL_135:
        *(_DWORD *)(a1 + 292) |= 0x10u;
        v45 = *(_QWORD *)(a1 + 40);
        if (!v45)
          operator new();
        v324 = 0;
        v46 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v46 >= *((_QWORD *)this + 2) || *v46 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v46;
          *((_QWORD *)this + 1) = v46 + 1;
        }
        v47 = *((_DWORD *)this + 14);
        v48 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v47 + 1;
        if (v47 >= v48)
          return 0;
        v49 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002CD7BC(v45, this, v50) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v49);
        v51 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v51, 1);
        v52 = v51 - 1;
        if (v52 < 0 == v15)
          *((_DWORD *)this + 14) = v52;
        v53 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v53 >= *((_QWORD *)this + 2) || *v53 != 74)
          continue;
        *((_QWORD *)this + 1) = v53 + 1;
LABEL_149:
        *(_DWORD *)(a1 + 292) |= 0x20u;
        v54 = *(_QWORD *)(a1 + 48);
        if (!v54)
          operator new();
        v324 = 0;
        v55 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v55 >= *((_QWORD *)this + 2) || *v55 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v55;
          *((_QWORD *)this + 1) = v55 + 1;
        }
        v56 = *((_DWORD *)this + 14);
        v57 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v56 + 1;
        if (v56 >= v57)
          return 0;
        v58 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002CE618(v54, this, v59) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v58);
        v60 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v60, 1);
        v61 = v60 - 1;
        if (v61 < 0 == v15)
          *((_DWORD *)this + 14) = v61;
        v62 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v62 >= *((_QWORD *)this + 2) || *v62 != 82)
          continue;
        *((_QWORD *)this + 1) = v62 + 1;
LABEL_163:
        *(_DWORD *)(a1 + 292) |= 0x40u;
        v63 = *(_QWORD *)(a1 + 56);
        if (!v63)
          operator new();
        v324 = 0;
        v64 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v64 >= *((_QWORD *)this + 2) || *v64 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v64;
          *((_QWORD *)this + 1) = v64 + 1;
        }
        v65 = *((_DWORD *)this + 14);
        v66 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v65 + 1;
        if (v65 >= v66)
          return 0;
        v67 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002CFE68(v63, this, v68) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v67);
        v69 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v69, 1);
        v70 = v69 - 1;
        if (v70 < 0 == v15)
          *((_DWORD *)this + 14) = v70;
        v71 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v71 >= *((_QWORD *)this + 2) || *v71 != 90)
          continue;
        *((_QWORD *)this + 1) = v71 + 1;
LABEL_177:
        *(_DWORD *)(a1 + 292) |= 0x80u;
        v72 = *(_QWORD *)(a1 + 64);
        if (!v72)
          operator new();
        v324 = 0;
        v73 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v73 >= *((_QWORD *)this + 2) || *v73 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v73;
          *((_QWORD *)this + 1) = v73 + 1;
        }
        v74 = *((_DWORD *)this + 14);
        v75 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v74 + 1;
        if (v74 >= v75)
          return 0;
        v76 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002D1690(v72, this, v77) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v76);
        v78 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v78, 1);
        v79 = v78 - 1;
        if (v79 < 0 == v15)
          *((_DWORD *)this + 14) = v79;
        v80 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v80 >= *((_QWORD *)this + 2) || *v80 != 98)
          continue;
        *((_QWORD *)this + 1) = v80 + 1;
LABEL_191:
        *(_DWORD *)(a1 + 292) |= 0x100u;
        v81 = *(_QWORD *)(a1 + 72);
        if (!v81)
          operator new();
        v324 = 0;
        v82 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v82 >= *((_QWORD *)this + 2) || *v82 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v82;
          *((_QWORD *)this + 1) = v82 + 1;
        }
        v83 = *((_DWORD *)this + 14);
        v84 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v83 + 1;
        if (v83 >= v84)
          return 0;
        v85 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002CB0F0(v81, this, v86) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v85);
        v87 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v87, 1);
        v88 = v87 - 1;
        if (v88 < 0 == v15)
          *((_DWORD *)this + 14) = v88;
        v89 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v89 >= *((_QWORD *)this + 2) || *v89 != 106)
          continue;
        *((_QWORD *)this + 1) = v89 + 1;
LABEL_205:
        *(_DWORD *)(a1 + 292) |= 0x200u;
        v90 = *(_QWORD *)(a1 + 80);
        if (!v90)
          operator new();
        v324 = 0;
        v91 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v91 >= *((_QWORD *)this + 2) || *v91 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v91;
          *((_QWORD *)this + 1) = v91 + 1;
        }
        v92 = *((_DWORD *)this + 14);
        v93 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v92 + 1;
        if (v92 >= v93)
          return 0;
        v94 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002CD07C(v90, this, v95) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v94);
        v96 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v96, 1);
        v97 = v96 - 1;
        if (v97 < 0 == v15)
          *((_DWORD *)this + 14) = v97;
        v98 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v98 >= *((_QWORD *)this + 2) || *v98 != 114)
          continue;
        *((_QWORD *)this + 1) = v98 + 1;
LABEL_219:
        *(_DWORD *)(a1 + 292) |= 0x400u;
        v99 = *(_QWORD *)(a1 + 88);
        if (!v99)
          operator new();
        v324 = 0;
        v100 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v100 >= *((_QWORD *)this + 2) || *v100 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v100;
          *((_QWORD *)this + 1) = v100 + 1;
        }
        v101 = *((_DWORD *)this + 14);
        v102 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v101 + 1;
        if (v101 >= v102)
          return 0;
        v103 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002D2128(v99, this, v104) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v103);
        v105 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v105, 1);
        v106 = v105 - 1;
        if (v106 < 0 == v15)
          *((_DWORD *)this + 14) = v106;
        v107 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v107 >= *((_QWORD *)this + 2) || *v107 != 122)
          continue;
        *((_QWORD *)this + 1) = v107 + 1;
LABEL_233:
        *(_DWORD *)(a1 + 292) |= 0x800u;
        v108 = *(_QWORD *)(a1 + 96);
        if (!v108)
          operator new();
        v324 = 0;
        v109 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v109 >= *((_QWORD *)this + 2) || *v109 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v109;
          *((_QWORD *)this + 1) = v109 + 1;
        }
        v110 = *((_DWORD *)this + 14);
        v111 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v110 + 1;
        if (v110 >= v111)
          return 0;
        v112 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002D250C(v108, this, v113) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v112);
        v114 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v114, 1);
        v115 = v114 - 1;
        if (v115 < 0 == v15)
          *((_DWORD *)this + 14) = v115;
        v116 = (unsigned __int8 *)*((_QWORD *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v116 <= 1 || *v116 != 130 || v116[1] != 1)
          continue;
        *((_QWORD *)this + 1) = v116 + 2;
LABEL_248:
        *(_DWORD *)(a1 + 292) |= 0x1000u;
        v117 = *(_QWORD *)(a1 + 104);
        if (!v117)
          operator new();
        v324 = 0;
        v118 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v118 >= *((_QWORD *)this + 2) || *v118 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v118;
          *((_QWORD *)this + 1) = v118 + 1;
        }
        v119 = *((_DWORD *)this + 14);
        v120 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v119 + 1;
        if (v119 >= v120)
          return 0;
        v121 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002D28F0(v117, this, v122) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v121);
        v123 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v123, 1);
        v124 = v123 - 1;
        if (v124 < 0 == v15)
          *((_DWORD *)this + 14) = v124;
        v125 = (unsigned __int8 *)*((_QWORD *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v125 <= 1 || *v125 != 138 || v125[1] != 1)
          continue;
        *((_QWORD *)this + 1) = v125 + 2;
LABEL_263:
        *(_DWORD *)(a1 + 292) |= 0x2000u;
        v126 = *(_QWORD *)(a1 + 112);
        if (!v126)
          operator new();
        v324 = 0;
        v127 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v127 >= *((_QWORD *)this + 2) || *v127 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v127;
          *((_QWORD *)this + 1) = v127 + 1;
        }
        v128 = *((_DWORD *)this + 14);
        v129 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v128 + 1;
        if (v128 >= v129)
          return 0;
        v130 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002D2CD4(v126, this, v131) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v130);
        v132 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v132, 1);
        v133 = v132 - 1;
        if (v133 < 0 == v15)
          *((_DWORD *)this + 14) = v133;
        v134 = (unsigned __int8 *)*((_QWORD *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v134 <= 1 || *v134 != 146 || v134[1] != 1)
          continue;
        *((_QWORD *)this + 1) = v134 + 2;
LABEL_278:
        *(_DWORD *)(a1 + 292) |= 0x4000u;
        v135 = *(_QWORD *)(a1 + 120);
        if (!v135)
          operator new();
        v324 = 0;
        v136 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v136 >= *((_QWORD *)this + 2) || *v136 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v136;
          *((_QWORD *)this + 1) = v136 + 1;
        }
        v137 = *((_DWORD *)this + 14);
        v138 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v137 + 1;
        if (v137 >= v138)
          return 0;
        v139 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002D30B8(v135, this, v140) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v139);
        v141 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v141, 1);
        v142 = v141 - 1;
        if (v142 < 0 == v15)
          *((_DWORD *)this + 14) = v142;
        v143 = (unsigned __int8 *)*((_QWORD *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v143 <= 1 || *v143 != 154 || v143[1] != 1)
          continue;
        *((_QWORD *)this + 1) = v143 + 2;
LABEL_293:
        *(_DWORD *)(a1 + 292) |= 0x8000u;
        v144 = *(_QWORD *)(a1 + 128);
        if (!v144)
          operator new();
        v324 = 0;
        v145 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v145 >= *((_QWORD *)this + 2) || *v145 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v145;
          *((_QWORD *)this + 1) = v145 + 1;
        }
        v146 = *((_DWORD *)this + 14);
        v147 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v146 + 1;
        if (v146 >= v147)
          return 0;
        v148 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002D3598(v144, this, v149) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v148);
        v150 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v150, 1);
        v151 = v150 - 1;
        if (v151 < 0 == v15)
          *((_DWORD *)this + 14) = v151;
        v152 = (unsigned __int8 *)*((_QWORD *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v152 <= 1 || *v152 != 162 || v152[1] != 1)
          continue;
        *((_QWORD *)this + 1) = v152 + 2;
LABEL_308:
        *(_DWORD *)(a1 + 292) |= 0x10000u;
        v153 = *(_QWORD *)(a1 + 136);
        if (!v153)
          operator new();
        v324 = 0;
        v154 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v154 >= *((_QWORD *)this + 2) || *v154 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v154;
          *((_QWORD *)this + 1) = v154 + 1;
        }
        v155 = *((_DWORD *)this + 14);
        v156 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v155 + 1;
        if (v155 >= v156)
          return 0;
        v157 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002D3D9C(v153, this, v158) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v157);
        v159 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v159, 1);
        v160 = v159 - 1;
        if (v160 < 0 == v15)
          *((_DWORD *)this + 14) = v160;
        v161 = (unsigned __int8 *)*((_QWORD *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v161 <= 1 || *v161 != 170 || v161[1] != 1)
          continue;
        *((_QWORD *)this + 1) = v161 + 2;
LABEL_323:
        *(_DWORD *)(a1 + 292) |= 0x20000u;
        v162 = *(_QWORD *)(a1 + 144);
        if (!v162)
          operator new();
        v324 = 0;
        v163 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v163 >= *((_QWORD *)this + 2) || *v163 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v163;
          *((_QWORD *)this + 1) = v163 + 1;
        }
        v164 = *((_DWORD *)this + 14);
        v165 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v164 + 1;
        if (v164 >= v165)
          return 0;
        v166 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002D4540(v162, this, v167) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v166);
        v168 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v168, 1);
        v169 = v168 - 1;
        if (v169 < 0 == v15)
          *((_DWORD *)this + 14) = v169;
        v170 = (unsigned __int8 *)*((_QWORD *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v170 <= 1 || *v170 != 178 || v170[1] != 1)
          continue;
        *((_QWORD *)this + 1) = v170 + 2;
LABEL_338:
        *(_DWORD *)(a1 + 292) |= 0x40000u;
        v171 = *(_QWORD *)(a1 + 152);
        if (!v171)
          operator new();
        v324 = 0;
        v172 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v172 >= *((_QWORD *)this + 2) || *v172 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v172;
          *((_QWORD *)this + 1) = v172 + 1;
        }
        v173 = *((_DWORD *)this + 14);
        v174 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v173 + 1;
        if (v173 >= v174)
          return 0;
        v175 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002D4CE4(v171, this, v176) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v175);
        v177 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v177, 1);
        v178 = v177 - 1;
        if (v178 < 0 == v15)
          *((_DWORD *)this + 14) = v178;
        v179 = (unsigned __int8 *)*((_QWORD *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v179 <= 1 || *v179 != 186 || v179[1] != 1)
          continue;
        *((_QWORD *)this + 1) = v179 + 2;
LABEL_353:
        *(_DWORD *)(a1 + 292) |= 0x80000u;
        v180 = *(_QWORD *)(a1 + 160);
        if (!v180)
          operator new();
        v324 = 0;
        v181 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v181 >= *((_QWORD *)this + 2) || *v181 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v181;
          *((_QWORD *)this + 1) = v181 + 1;
        }
        v182 = *((_DWORD *)this + 14);
        v183 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v182 + 1;
        if (v182 >= v183)
          return 0;
        v184 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002D5560(v180, this, v185) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v184);
        v186 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v186, 1);
        v187 = v186 - 1;
        if (v187 < 0 == v15)
          *((_DWORD *)this + 14) = v187;
        v188 = (unsigned __int8 *)*((_QWORD *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v188 <= 1 || *v188 != 194 || v188[1] != 1)
          continue;
        *((_QWORD *)this + 1) = v188 + 2;
LABEL_368:
        *(_DWORD *)(a1 + 292) |= 0x100000u;
        v189 = *(_QWORD *)(a1 + 168);
        if (!v189)
          operator new();
        v324 = 0;
        v190 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v190 >= *((_QWORD *)this + 2) || *v190 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v190;
          *((_QWORD *)this + 1) = v190 + 1;
        }
        v191 = *((_DWORD *)this + 14);
        v192 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v191 + 1;
        if (v191 >= v192)
          return 0;
        v193 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002D5DB8(v189, this, v194) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v193);
        v195 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v195, 1);
        v196 = v195 - 1;
        if (v196 < 0 == v15)
          *((_DWORD *)this + 14) = v196;
        v197 = (unsigned __int8 *)*((_QWORD *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v197 <= 1 || *v197 != 202 || v197[1] != 1)
          continue;
        *((_QWORD *)this + 1) = v197 + 2;
LABEL_383:
        *(_DWORD *)(a1 + 292) |= 0x200000u;
        v198 = *(_QWORD *)(a1 + 176);
        if (!v198)
          operator new();
        v324 = 0;
        v199 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v199 >= *((_QWORD *)this + 2) || *v199 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v199;
          *((_QWORD *)this + 1) = v199 + 1;
        }
        v200 = *((_DWORD *)this + 14);
        v201 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v200 + 1;
        if (v200 >= v201)
          return 0;
        v202 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002D67A0(v198, this, v203) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v202);
        v204 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v204, 1);
        v205 = v204 - 1;
        if (v205 < 0 == v15)
          *((_DWORD *)this + 14) = v205;
        v206 = (unsigned __int8 *)*((_QWORD *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v206 <= 1 || *v206 != 210 || v206[1] != 1)
          continue;
        *((_QWORD *)this + 1) = v206 + 2;
LABEL_398:
        *(_DWORD *)(a1 + 292) |= 0x400000u;
        v207 = *(_QWORD *)(a1 + 184);
        if (!v207)
          operator new();
        v324 = 0;
        v208 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v208 >= *((_QWORD *)this + 2) || *v208 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v208;
          *((_QWORD *)this + 1) = v208 + 1;
        }
        v209 = *((_DWORD *)this + 14);
        v210 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v209 + 1;
        if (v209 >= v210)
          return 0;
        v211 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002D71D4(v207, this, v212) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v211);
        v213 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v213, 1);
        v214 = v213 - 1;
        if (v214 < 0 == v15)
          *((_DWORD *)this + 14) = v214;
        v215 = (unsigned __int8 *)*((_QWORD *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v215 <= 1 || *v215 != 218 || v215[1] != 1)
          continue;
        *((_QWORD *)this + 1) = v215 + 2;
LABEL_413:
        *(_DWORD *)(a1 + 292) |= 0x800000u;
        v216 = *(_QWORD *)(a1 + 192);
        if (!v216)
          operator new();
        v324 = 0;
        v217 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v217 >= *((_QWORD *)this + 2) || *v217 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v217;
          *((_QWORD *)this + 1) = v217 + 1;
        }
        v218 = *((_DWORD *)this + 14);
        v219 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v218 + 1;
        if (v218 >= v219)
          return 0;
        v220 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002D79E4(v216, this, v221) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v220);
        v222 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v222, 1);
        v223 = v222 - 1;
        if (v223 < 0 == v15)
          *((_DWORD *)this + 14) = v223;
        v224 = (unsigned __int8 *)*((_QWORD *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v224 <= 1 || *v224 != 226 || v224[1] != 1)
          continue;
        *((_QWORD *)this + 1) = v224 + 2;
LABEL_428:
        *(_DWORD *)(a1 + 292) |= 0x1000000u;
        v225 = *(_QWORD *)(a1 + 200);
        if (!v225)
          operator new();
        v324 = 0;
        v226 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v226 >= *((_QWORD *)this + 2) || *v226 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v226;
          *((_QWORD *)this + 1) = v226 + 1;
        }
        v227 = *((_DWORD *)this + 14);
        v228 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v227 + 1;
        if (v227 >= v228)
          return 0;
        v229 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002D810C(v225, this, v230) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v229);
        v231 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v231, 1);
        v232 = v231 - 1;
        if (v232 < 0 == v15)
          *((_DWORD *)this + 14) = v232;
        v233 = (unsigned __int8 *)*((_QWORD *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v233 <= 1 || *v233 != 234 || v233[1] != 1)
          continue;
        *((_QWORD *)this + 1) = v233 + 2;
LABEL_443:
        *(_DWORD *)(a1 + 292) |= 0x2000000u;
        v234 = *(_QWORD *)(a1 + 208);
        if (!v234)
          operator new();
        v324 = 0;
        v235 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v235 >= *((_QWORD *)this + 2) || *v235 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v235;
          *((_QWORD *)this + 1) = v235 + 1;
        }
        v236 = *((_DWORD *)this + 14);
        v237 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v236 + 1;
        if (v236 >= v237)
          return 0;
        v238 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002D8A98(v234, this, v239) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v238);
        v240 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v240, 1);
        v241 = v240 - 1;
        if (v241 < 0 == v15)
          *((_DWORD *)this + 14) = v241;
        v242 = (unsigned __int8 *)*((_QWORD *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v242 <= 1 || *v242 != 242 || v242[1] != 1)
          continue;
        *((_QWORD *)this + 1) = v242 + 2;
LABEL_458:
        *(_DWORD *)(a1 + 292) |= 0x4000000u;
        v243 = *(_QWORD *)(a1 + 216);
        if (!v243)
          operator new();
        v324 = 0;
        v244 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v244 >= *((_QWORD *)this + 2) || *v244 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v244;
          *((_QWORD *)this + 1) = v244 + 1;
        }
        v245 = *((_DWORD *)this + 14);
        v246 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v245 + 1;
        if (v245 >= v246)
          return 0;
        v247 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002D931C(v243, this, v248) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v247);
        v249 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v249, 1);
        v250 = v249 - 1;
        if (v250 < 0 == v15)
          *((_DWORD *)this + 14) = v250;
        v251 = (unsigned __int8 *)*((_QWORD *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v251 <= 1 || *v251 != 250 || v251[1] != 1)
          continue;
        *((_QWORD *)this + 1) = v251 + 2;
LABEL_473:
        *(_DWORD *)(a1 + 292) |= 0x8000000u;
        v252 = *(_QWORD *)(a1 + 224);
        if (!v252)
          operator new();
        v324 = 0;
        v253 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v253 >= *((_QWORD *)this + 2) || *v253 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v253;
          *((_QWORD *)this + 1) = v253 + 1;
        }
        v254 = *((_DWORD *)this + 14);
        v255 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v254 + 1;
        if (v254 >= v255)
          return 0;
        v256 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002E0EA0(v252, this, v257) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v256);
        v258 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v258, 1);
        v259 = v258 - 1;
        if (v259 < 0 == v15)
          *((_DWORD *)this + 14) = v259;
        v260 = (unsigned __int8 *)*((_QWORD *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v260 <= 1 || *v260 != 130 || v260[1] != 2)
          continue;
        *((_QWORD *)this + 1) = v260 + 2;
LABEL_488:
        *(_DWORD *)(a1 + 292) |= 0x10000000u;
        v261 = *(_DWORD **)(a1 + 232);
        if (!v261)
          operator new();
        v324 = 0;
        v262 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v262 >= *((_QWORD *)this + 2) || *v262 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v262;
          *((_QWORD *)this + 1) = v262 + 1;
        }
        v263 = *((_DWORD *)this + 14);
        v264 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v263 + 1;
        if (v263 >= v264)
          return 0;
        v265 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002E1B30(v261, this, v266) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v265);
        v267 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v267, 1);
        v268 = v267 - 1;
        if (v268 < 0 == v15)
          *((_DWORD *)this + 14) = v268;
        v269 = (unsigned __int8 *)*((_QWORD *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v269 <= 1 || *v269 != 138 || v269[1] != 2)
          continue;
        *((_QWORD *)this + 1) = v269 + 2;
LABEL_503:
        *(_DWORD *)(a1 + 292) |= 0x20000000u;
        v270 = *(_QWORD *)(a1 + 240);
        if (!v270)
          operator new();
        v324 = 0;
        v271 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v271 >= *((_QWORD *)this + 2) || *v271 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v271;
          *((_QWORD *)this + 1) = v271 + 1;
        }
        v272 = *((_DWORD *)this + 14);
        v273 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v272 + 1;
        if (v272 >= v273)
          return 0;
        v274 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002E1F60(v270, this, v275) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v274);
        v276 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v276, 1);
        v277 = v276 - 1;
        if (v277 < 0 == v15)
          *((_DWORD *)this + 14) = v277;
        v278 = (unsigned __int8 *)*((_QWORD *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v278 <= 1 || *v278 != 146 || v278[1] != 2)
          continue;
        *((_QWORD *)this + 1) = v278 + 2;
LABEL_518:
        *(_DWORD *)(a1 + 292) |= 0x40000000u;
        v279 = *(_QWORD *)(a1 + 248);
        if (!v279)
          operator new();
        v324 = 0;
        v280 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v280 >= *((_QWORD *)this + 2) || *v280 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v280;
          *((_QWORD *)this + 1) = v280 + 1;
        }
        v281 = *((_DWORD *)this + 14);
        v282 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v281 + 1;
        if (v281 >= v282)
          return 0;
        v283 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002E234C(v279, this, v284) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v283);
        v285 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v285, 1);
        v286 = v285 - 1;
        if (v286 < 0 == v15)
          *((_DWORD *)this + 14) = v286;
        v287 = (unsigned __int8 *)*((_QWORD *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v287 <= 1 || *v287 != 154 || v287[1] != 2)
          continue;
        *((_QWORD *)this + 1) = v287 + 2;
LABEL_533:
        *(_DWORD *)(a1 + 292) |= 0x80000000;
        v288 = *(_QWORD *)(a1 + 256);
        if (!v288)
          operator new();
        v324 = 0;
        v289 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v289 >= *((_QWORD *)this + 2) || *v289 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v289;
          *((_QWORD *)this + 1) = v289 + 1;
        }
        v290 = *((_DWORD *)this + 14);
        v291 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v290 + 1;
        if (v290 >= v291)
          return 0;
        v292 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002E2A68(v288, this, v293) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v292);
        v294 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v294, 1);
        v295 = v294 - 1;
        if (v295 < 0 == v15)
          *((_DWORD *)this + 14) = v295;
        v296 = (unsigned __int8 *)*((_QWORD *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v296 <= 1 || *v296 != 162 || v296[1] != 2)
          continue;
        *((_QWORD *)this + 1) = v296 + 2;
LABEL_548:
        *(_DWORD *)(a1 + 296) |= 1u;
        v297 = *(_QWORD *)(a1 + 264);
        if (!v297)
          operator new();
        v324 = 0;
        v298 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v298 >= *((_QWORD *)this + 2) || *v298 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v298;
          *((_QWORD *)this + 1) = v298 + 1;
        }
        v299 = *((_DWORD *)this + 14);
        v300 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v299 + 1;
        if (v299 >= v300)
          return 0;
        v301 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002E2E18(v297, this, v302) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v301);
        v303 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v303, 1);
        v304 = v303 - 1;
        if (v304 < 0 == v15)
          *((_DWORD *)this + 14) = v304;
        v305 = (unsigned __int8 *)*((_QWORD *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v305 <= 1 || *v305 != 170 || v305[1] != 2)
          continue;
        *((_QWORD *)this + 1) = v305 + 2;
LABEL_563:
        *(_DWORD *)(a1 + 296) |= 2u;
        v306 = *(_QWORD *)(a1 + 272);
        if (!v306)
          operator new();
        v324 = 0;
        v307 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v307 >= *((_QWORD *)this + 2) || *v307 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v307;
          *((_QWORD *)this + 1) = v307 + 1;
        }
        v308 = *((_DWORD *)this + 14);
        v309 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v308 + 1;
        if (v308 >= v309)
          return 0;
        v310 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002E30D8(v306, this, v311) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v310);
        v312 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v312, 1);
        v313 = v312 - 1;
        if (v313 < 0 == v15)
          *((_DWORD *)this + 14) = v313;
        v314 = (unsigned __int8 *)*((_QWORD *)this + 1);
        if (*((_DWORD *)this + 4) - (int)v314 <= 1 || *v314 != 178 || v314[1] != 2)
          continue;
        *((_QWORD *)this + 1) = v314 + 2;
LABEL_578:
        *(_DWORD *)(a1 + 296) |= 4u;
        v315 = *(_QWORD *)(a1 + 280);
        if (!v315)
          operator new();
        v324 = 0;
        v316 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v316 >= *((_QWORD *)this + 2) || *v316 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v324))return 0;
        }
        else
        {
          v324 = *v316;
          *((_QWORD *)this + 1) = v316 + 1;
        }
        v317 = *((_DWORD *)this + 14);
        v318 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v317 + 1;
        if (v317 >= v318)
          return 0;
        v319 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v324);
        if (!sub_1002D9CAC(v315, this, v320) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v319);
        v321 = *((_DWORD *)this + 14);
        v15 = __OFSUB__(v321, 1);
        v322 = v321 - 1;
        if (v322 < 0 == v15)
          *((_DWORD *)this + 14) = v322;
        if (*((_QWORD *)this + 1) == *((_QWORD *)this + 2)
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          result = 1;
          *((_BYTE *)this + 36) = 1;
          return result;
        }
        break;
      case 4u:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_107;
        goto LABEL_81;
      case 5u:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_121;
        goto LABEL_81;
      case 7u:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_135;
        goto LABEL_81;
      case 9u:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_149;
        goto LABEL_81;
      case 0xAu:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_163;
        goto LABEL_81;
      case 0xBu:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_177;
        goto LABEL_81;
      case 0xCu:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_191;
        goto LABEL_81;
      case 0xDu:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_205;
        goto LABEL_81;
      case 0xEu:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_219;
        goto LABEL_81;
      case 0xFu:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_233;
        goto LABEL_81;
      case 0x10u:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_248;
        goto LABEL_81;
      case 0x11u:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_263;
        goto LABEL_81;
      case 0x12u:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_278;
        goto LABEL_81;
      case 0x13u:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_293;
        goto LABEL_81;
      case 0x14u:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_308;
        goto LABEL_81;
      case 0x15u:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_323;
        goto LABEL_81;
      case 0x16u:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_338;
        goto LABEL_81;
      case 0x17u:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_353;
        goto LABEL_81;
      case 0x18u:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_368;
        goto LABEL_81;
      case 0x19u:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_383;
        goto LABEL_81;
      case 0x1Au:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_398;
        goto LABEL_81;
      case 0x1Bu:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_413;
        goto LABEL_81;
      case 0x1Cu:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_428;
        goto LABEL_81;
      case 0x1Du:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_443;
        goto LABEL_81;
      case 0x1Eu:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_458;
        goto LABEL_81;
      case 0x1Fu:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_473;
        goto LABEL_81;
      case 0x20u:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_488;
        goto LABEL_81;
      case 0x21u:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_503;
        goto LABEL_81;
      case 0x22u:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_518;
        goto LABEL_81;
      case 0x23u:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_533;
        goto LABEL_81;
      case 0x24u:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_548;
        goto LABEL_81;
      case 0x25u:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_563;
        goto LABEL_81;
      case 0x26u:
        v7 = TagFallback & 7;
        if (v7 != 2)
          goto LABEL_81;
        goto LABEL_578;
      default:
        v7 = TagFallback & 7;
LABEL_81:
        if (v7 == 4)
          return 1;
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, TagFallback, a3) & 1) == 0)
          return 0;
        continue;
    }
  }
}

uint64_t sub_1002DD088(uint64_t result, wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;

  v5 = result;
  v6 = *(_DWORD *)(result + 292);
  if ((v6 & 1) != 0)
  {
    v7 = *(_QWORD *)(result + 8);
    if (!v7)
      v7 = *(_QWORD *)(qword_1023103F8 + 8);
    result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, v7, a2, a4);
    v6 = *(_DWORD *)(v5 + 292);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0)
        goto LABEL_4;
      goto LABEL_40;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  v8 = *(_QWORD *)(v5 + 16);
  if (!v8)
    v8 = *(_QWORD *)(qword_1023103F8 + 16);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v8, a2, a4);
  v6 = *(_DWORD *)(v5 + 292);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0)
      goto LABEL_5;
    goto LABEL_43;
  }
LABEL_40:
  v9 = *(_QWORD *)(v5 + 24);
  if (!v9)
    v9 = *(_QWORD *)(qword_1023103F8 + 24);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, v9, a2, a4);
  v6 = *(_DWORD *)(v5 + 292);
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0)
      goto LABEL_6;
    goto LABEL_46;
  }
LABEL_43:
  v10 = *(_QWORD *)(v5 + 32);
  if (!v10)
    v10 = *(_QWORD *)(qword_1023103F8 + 32);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, v10, a2, a4);
  v6 = *(_DWORD *)(v5 + 292);
  if ((v6 & 0x10) == 0)
  {
LABEL_6:
    if ((v6 & 0x20) == 0)
      goto LABEL_7;
    goto LABEL_49;
  }
LABEL_46:
  v11 = *(_QWORD *)(v5 + 40);
  if (!v11)
    v11 = *(_QWORD *)(qword_1023103F8 + 40);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)7, v11, a2, a4);
  v6 = *(_DWORD *)(v5 + 292);
  if ((v6 & 0x20) == 0)
  {
LABEL_7:
    if ((v6 & 0x40) == 0)
      goto LABEL_8;
    goto LABEL_52;
  }
LABEL_49:
  v12 = *(_QWORD *)(v5 + 48);
  if (!v12)
    v12 = *(_QWORD *)(qword_1023103F8 + 48);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)9, v12, a2, a4);
  v6 = *(_DWORD *)(v5 + 292);
  if ((v6 & 0x40) == 0)
  {
LABEL_8:
    if ((v6 & 0x80) == 0)
      goto LABEL_9;
    goto LABEL_55;
  }
LABEL_52:
  v13 = *(_QWORD *)(v5 + 56);
  if (!v13)
    v13 = *(_QWORD *)(qword_1023103F8 + 56);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xA, v13, a2, a4);
  v6 = *(_DWORD *)(v5 + 292);
  if ((v6 & 0x80) == 0)
  {
LABEL_9:
    if ((v6 & 0x100) == 0)
      goto LABEL_10;
    goto LABEL_58;
  }
LABEL_55:
  v14 = *(_QWORD *)(v5 + 64);
  if (!v14)
    v14 = *(_QWORD *)(qword_1023103F8 + 64);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xB, v14, a2, a4);
  v6 = *(_DWORD *)(v5 + 292);
  if ((v6 & 0x100) == 0)
  {
LABEL_10:
    if ((v6 & 0x200) == 0)
      goto LABEL_11;
    goto LABEL_61;
  }
LABEL_58:
  v15 = *(_QWORD *)(v5 + 72);
  if (!v15)
    v15 = *(_QWORD *)(qword_1023103F8 + 72);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xC, v15, a2, a4);
  v6 = *(_DWORD *)(v5 + 292);
  if ((v6 & 0x200) == 0)
  {
LABEL_11:
    if ((v6 & 0x400) == 0)
      goto LABEL_12;
    goto LABEL_64;
  }
LABEL_61:
  v16 = *(_QWORD *)(v5 + 80);
  if (!v16)
    v16 = *(_QWORD *)(qword_1023103F8 + 80);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xD, v16, a2, a4);
  v6 = *(_DWORD *)(v5 + 292);
  if ((v6 & 0x400) == 0)
  {
LABEL_12:
    if ((v6 & 0x800) == 0)
      goto LABEL_13;
    goto LABEL_67;
  }
LABEL_64:
  v17 = *(_QWORD *)(v5 + 88);
  if (!v17)
    v17 = *(_QWORD *)(qword_1023103F8 + 88);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xE, v17, a2, a4);
  v6 = *(_DWORD *)(v5 + 292);
  if ((v6 & 0x800) == 0)
  {
LABEL_13:
    if ((v6 & 0x1000) == 0)
      goto LABEL_14;
    goto LABEL_70;
  }
LABEL_67:
  v18 = *(_QWORD *)(v5 + 96);
  if (!v18)
    v18 = *(_QWORD *)(qword_1023103F8 + 96);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xF, v18, a2, a4);
  v6 = *(_DWORD *)(v5 + 292);
  if ((v6 & 0x1000) == 0)
  {
LABEL_14:
    if ((v6 & 0x2000) == 0)
      goto LABEL_15;
    goto LABEL_73;
  }
LABEL_70:
  v19 = *(_QWORD *)(v5 + 104);
  if (!v19)
    v19 = *(_QWORD *)(qword_1023103F8 + 104);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x10, v19, a2, a4);
  v6 = *(_DWORD *)(v5 + 292);
  if ((v6 & 0x2000) == 0)
  {
LABEL_15:
    if ((v6 & 0x4000) == 0)
      goto LABEL_16;
    goto LABEL_76;
  }
LABEL_73:
  v20 = *(_QWORD *)(v5 + 112);
  if (!v20)
    v20 = *(_QWORD *)(qword_1023103F8 + 112);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x11, v20, a2, a4);
  v6 = *(_DWORD *)(v5 + 292);
  if ((v6 & 0x4000) == 0)
  {
LABEL_16:
    if ((v6 & 0x8000) == 0)
      goto LABEL_17;
    goto LABEL_79;
  }
LABEL_76:
  v21 = *(_QWORD *)(v5 + 120);
  if (!v21)
    v21 = *(_QWORD *)(qword_1023103F8 + 120);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x12, v21, a2, a4);
  v6 = *(_DWORD *)(v5 + 292);
  if ((v6 & 0x8000) == 0)
  {
LABEL_17:
    if ((v6 & 0x10000) == 0)
      goto LABEL_18;
    goto LABEL_82;
  }
LABEL_79:
  v22 = *(_QWORD *)(v5 + 128);
  if (!v22)
    v22 = *(_QWORD *)(qword_1023103F8 + 128);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x13, v22, a2, a4);
  v6 = *(_DWORD *)(v5 + 292);
  if ((v6 & 0x10000) == 0)
  {
LABEL_18:
    if ((v6 & 0x20000) == 0)
      goto LABEL_19;
    goto LABEL_85;
  }
LABEL_82:
  v23 = *(_QWORD *)(v5 + 136);
  if (!v23)
    v23 = *(_QWORD *)(qword_1023103F8 + 136);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x14, v23, a2, a4);
  v6 = *(_DWORD *)(v5 + 292);
  if ((v6 & 0x20000) == 0)
  {
LABEL_19:
    if ((v6 & 0x40000) == 0)
      goto LABEL_20;
    goto LABEL_88;
  }
LABEL_85:
  v24 = *(_QWORD *)(v5 + 144);
  if (!v24)
    v24 = *(_QWORD *)(qword_1023103F8 + 144);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x15, v24, a2, a4);
  v6 = *(_DWORD *)(v5 + 292);
  if ((v6 & 0x40000) == 0)
  {
LABEL_20:
    if ((v6 & 0x80000) == 0)
      goto LABEL_21;
    goto LABEL_91;
  }
LABEL_88:
  v25 = *(_QWORD *)(v5 + 152);
  if (!v25)
    v25 = *(_QWORD *)(qword_1023103F8 + 152);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x16, v25, a2, a4);
  v6 = *(_DWORD *)(v5 + 292);
  if ((v6 & 0x80000) == 0)
  {
LABEL_21:
    if ((v6 & 0x100000) == 0)
      goto LABEL_22;
    goto LABEL_94;
  }
LABEL_91:
  v26 = *(_QWORD *)(v5 + 160);
  if (!v26)
    v26 = *(_QWORD *)(qword_1023103F8 + 160);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x17, v26, a2, a4);
  v6 = *(_DWORD *)(v5 + 292);
  if ((v6 & 0x100000) == 0)
  {
LABEL_22:
    if ((v6 & 0x200000) == 0)
      goto LABEL_23;
    goto LABEL_97;
  }
LABEL_94:
  v27 = *(_QWORD *)(v5 + 168);
  if (!v27)
    v27 = *(_QWORD *)(qword_1023103F8 + 168);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x18, v27, a2, a4);
  v6 = *(_DWORD *)(v5 + 292);
  if ((v6 & 0x200000) == 0)
  {
LABEL_23:
    if ((v6 & 0x400000) == 0)
      goto LABEL_24;
    goto LABEL_100;
  }
LABEL_97:
  v28 = *(_QWORD *)(v5 + 176);
  if (!v28)
    v28 = *(_QWORD *)(qword_1023103F8 + 176);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x19, v28, a2, a4);
  v6 = *(_DWORD *)(v5 + 292);
  if ((v6 & 0x400000) == 0)
  {
LABEL_24:
    if ((v6 & 0x800000) == 0)
      goto LABEL_25;
    goto LABEL_103;
  }
LABEL_100:
  v29 = *(_QWORD *)(v5 + 184);
  if (!v29)
    v29 = *(_QWORD *)(qword_1023103F8 + 184);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x1A, v29, a2, a4);
  v6 = *(_DWORD *)(v5 + 292);
  if ((v6 & 0x800000) == 0)
  {
LABEL_25:
    if ((v6 & 0x1000000) == 0)
      goto LABEL_26;
    goto LABEL_106;
  }
LABEL_103:
  v30 = *(_QWORD *)(v5 + 192);
  if (!v30)
    v30 = *(_QWORD *)(qword_1023103F8 + 192);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x1B, v30, a2, a4);
  v6 = *(_DWORD *)(v5 + 292);
  if ((v6 & 0x1000000) == 0)
  {
LABEL_26:
    if ((v6 & 0x2000000) == 0)
      goto LABEL_27;
    goto LABEL_109;
  }
LABEL_106:
  v31 = *(_QWORD *)(v5 + 200);
  if (!v31)
    v31 = *(_QWORD *)(qword_1023103F8 + 200);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x1C, v31, a2, a4);
  v6 = *(_DWORD *)(v5 + 292);
  if ((v6 & 0x2000000) == 0)
  {
LABEL_27:
    if ((v6 & 0x4000000) == 0)
      goto LABEL_28;
    goto LABEL_112;
  }
LABEL_109:
  v32 = *(_QWORD *)(v5 + 208);
  if (!v32)
    v32 = *(_QWORD *)(qword_1023103F8 + 208);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x1D, v32, a2, a4);
  v6 = *(_DWORD *)(v5 + 292);
  if ((v6 & 0x4000000) == 0)
  {
LABEL_28:
    if ((v6 & 0x8000000) == 0)
      goto LABEL_29;
    goto LABEL_115;
  }
LABEL_112:
  v33 = *(_QWORD *)(v5 + 216);
  if (!v33)
    v33 = *(_QWORD *)(qword_1023103F8 + 216);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x1E, v33, a2, a4);
  v6 = *(_DWORD *)(v5 + 292);
  if ((v6 & 0x8000000) == 0)
  {
LABEL_29:
    if ((v6 & 0x10000000) == 0)
      goto LABEL_30;
    goto LABEL_118;
  }
LABEL_115:
  v34 = *(_QWORD *)(v5 + 224);
  if (!v34)
    v34 = *(_QWORD *)(qword_1023103F8 + 224);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x1F, v34, a2, a4);
  v6 = *(_DWORD *)(v5 + 292);
  if ((v6 & 0x10000000) == 0)
  {
LABEL_30:
    if ((v6 & 0x20000000) == 0)
      goto LABEL_31;
    goto LABEL_121;
  }
LABEL_118:
  v35 = *(_QWORD *)(v5 + 232);
  if (!v35)
    v35 = *(_QWORD *)(qword_1023103F8 + 232);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x20, v35, a2, a4);
  v6 = *(_DWORD *)(v5 + 292);
  if ((v6 & 0x20000000) == 0)
  {
LABEL_31:
    if ((v6 & 0x40000000) == 0)
      goto LABEL_32;
    goto LABEL_124;
  }
LABEL_121:
  v36 = *(_QWORD *)(v5 + 240);
  if (!v36)
    v36 = *(_QWORD *)(qword_1023103F8 + 240);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x21, v36, a2, a4);
  v6 = *(_DWORD *)(v5 + 292);
  if ((v6 & 0x40000000) == 0)
  {
LABEL_32:
    if ((v6 & 0x80000000) == 0)
      goto LABEL_130;
    goto LABEL_127;
  }
LABEL_124:
  v37 = *(_QWORD *)(v5 + 248);
  if (!v37)
    v37 = *(_QWORD *)(qword_1023103F8 + 248);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x22, v37, a2, a4);
  if ((*(_DWORD *)(v5 + 292) & 0x80000000) != 0)
  {
LABEL_127:
    v38 = *(_QWORD *)(v5 + 256);
    if (!v38)
      v38 = *(_QWORD *)(qword_1023103F8 + 256);
    result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x23, v38, a2, a4);
  }
LABEL_130:
  v39 = *(_DWORD *)(v5 + 296);
  if ((v39 & 1) != 0)
  {
    v40 = *(_QWORD *)(v5 + 264);
    if (!v40)
      v40 = *(_QWORD *)(qword_1023103F8 + 264);
    result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x24, v40, a2, a4);
    v39 = *(_DWORD *)(v5 + 296);
    if ((v39 & 2) == 0)
    {
LABEL_132:
      if ((v39 & 4) == 0)
        return result;
      goto LABEL_140;
    }
  }
  else if ((v39 & 2) == 0)
  {
    goto LABEL_132;
  }
  v41 = *(_QWORD *)(v5 + 272);
  if (!v41)
    v41 = *(_QWORD *)(qword_1023103F8 + 272);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x25, v41, a2, a4);
  if ((*(_DWORD *)(v5 + 296) & 4) != 0)
  {
LABEL_140:
    v42 = *(_QWORD *)(v5 + 280);
    if (!v42)
      v42 = *(_QWORD *)(qword_1023103F8 + 280);
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x26, v42, a2, a4);
  }
  return result;
}

uint64_t sub_1002DD6B0(uint64_t a1, unint64_t a2)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v6;
  int v7;
  int v8;
  uint64_t v9;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v10;
  int v11;
  int v12;
  uint64_t v13;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v14;
  int v15;
  int v16;
  uint64_t v17;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v18;
  int v19;
  int v20;
  uint64_t v21;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v22;
  int v23;
  int v24;
  uint64_t v25;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v26;
  int v27;
  int v28;
  uint64_t v29;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v30;
  int v31;
  int v32;
  uint64_t v33;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v34;
  int v35;
  int v36;
  uint64_t v37;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v38;
  int v39;
  int v40;
  uint64_t v41;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v42;
  int v43;
  int v44;
  uint64_t v45;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v46;
  int v47;
  int v48;
  uint64_t v49;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v50;
  int v51;
  int v52;
  uint64_t v53;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v54;
  int v55;
  int v56;
  uint64_t v57;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v58;
  int v59;
  int v60;
  uint64_t v61;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v62;
  int v63;
  int v64;
  uint64_t v65;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v66;
  int v67;
  int v68;
  uint64_t v69;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v70;
  int v71;
  int v72;
  uint64_t v73;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v74;
  int v75;
  int v76;
  uint64_t v77;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v78;
  int v79;
  int v80;
  uint64_t v81;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v82;
  int v83;
  int v84;
  uint64_t v85;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v86;
  int v87;
  int v88;
  uint64_t v89;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v90;
  int v91;
  int v92;
  uint64_t v93;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v94;
  int v95;
  int v96;
  uint64_t v97;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v98;
  int v99;
  int v100;
  uint64_t v101;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v102;
  int v103;
  int v104;
  uint64_t v105;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v106;
  int v107;
  int v108;
  uint64_t v109;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v110;
  int v111;
  int v112;
  uint64_t v113;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v114;
  int v115;
  int v116;
  uint64_t v117;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v118;
  int v119;
  int v120;
  uint64_t v121;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v122;
  int v123;
  int v124;
  uint64_t v125;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v126;
  int v127;
  int v128;
  uint64_t v129;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v130;
  int v131;
  int v132;
  int v133;
  uint64_t v134;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v135;
  int v136;
  int v137;
  uint64_t v138;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v139;
  int v140;
  int v141;
  uint64_t v142;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v143;
  unsigned int v144;
  int v145;
  int v146;

  v3 = *(_DWORD *)(a1 + 292);
  if (!(_BYTE)v3)
  {
    v4 = 0;
    goto LABEL_61;
  }
  if ((v3 & 1) == 0)
  {
    v4 = 0;
    if ((v3 & 2) == 0)
      goto LABEL_18;
    goto LABEL_12;
  }
  v5 = *(_QWORD *)(a1 + 8);
  if (!v5)
    v5 = *(_QWORD *)(qword_1023103F8 + 8);
  v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002CAB00(v5, a2);
  v7 = (int)v6;
  if (v6 >= 0x80)
    v8 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2);
  else
    v8 = 1;
  v4 = (v7 + v8 + 1);
  v3 = *(_DWORD *)(a1 + 292);
  if ((v3 & 2) != 0)
  {
LABEL_12:
    v9 = *(_QWORD *)(a1 + 16);
    if (!v9)
      v9 = *(_QWORD *)(qword_1023103F8 + 16);
    v10 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002CC024(v9, a2);
    v11 = (int)v10;
    if (v10 >= 0x80)
      v12 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v10, a2);
    else
      v12 = 1;
    v4 = (v4 + v11 + v12 + 1);
    v3 = *(_DWORD *)(a1 + 292);
  }
LABEL_18:
  if ((v3 & 4) != 0)
  {
    v13 = *(_QWORD *)(a1 + 24);
    if (!v13)
      v13 = *(_QWORD *)(qword_1023103F8 + 24);
    v14 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002CC6D8(v13, a2);
    v15 = (int)v14;
    if (v14 >= 0x80)
      v16 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v14, a2);
    else
      v16 = 1;
    v4 = (v4 + v15 + v16 + 1);
    v3 = *(_DWORD *)(a1 + 292);
    if ((v3 & 8) == 0)
    {
LABEL_20:
      if ((v3 & 0x10) == 0)
        goto LABEL_21;
      goto LABEL_37;
    }
  }
  else if ((v3 & 8) == 0)
  {
    goto LABEL_20;
  }
  v17 = *(_QWORD *)(a1 + 32);
  if (!v17)
    v17 = *(_QWORD *)(qword_1023103F8 + 32);
  v18 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002CCB38(v17, a2);
  v19 = (int)v18;
  if (v18 >= 0x80)
    v20 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v18, a2);
  else
    v20 = 1;
  v4 = (v4 + v19 + v20 + 1);
  v3 = *(_DWORD *)(a1 + 292);
  if ((v3 & 0x10) == 0)
  {
LABEL_21:
    if ((v3 & 0x20) == 0)
      goto LABEL_22;
    goto LABEL_43;
  }
LABEL_37:
  v21 = *(_QWORD *)(a1 + 40);
  if (!v21)
    v21 = *(_QWORD *)(qword_1023103F8 + 40);
  v22 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002CD93C(v21, a2);
  v23 = (int)v22;
  if (v22 >= 0x80)
    v24 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v22, a2);
  else
    v24 = 1;
  v4 = (v4 + v23 + v24 + 1);
  v3 = *(_DWORD *)(a1 + 292);
  if ((v3 & 0x20) == 0)
  {
LABEL_22:
    if ((v3 & 0x40) == 0)
      goto LABEL_23;
    goto LABEL_49;
  }
LABEL_43:
  v25 = *(_QWORD *)(a1 + 48);
  if (!v25)
    v25 = *(_QWORD *)(qword_1023103F8 + 48);
  v26 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002CF050(v25, a2);
  v27 = (int)v26;
  if (v26 >= 0x80)
    v28 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v26, a2);
  else
    v28 = 1;
  v4 = (v4 + v27 + v28 + 1);
  v3 = *(_DWORD *)(a1 + 292);
  if ((v3 & 0x40) == 0)
  {
LABEL_23:
    if ((v3 & 0x80) == 0)
      goto LABEL_61;
    goto LABEL_55;
  }
LABEL_49:
  v29 = *(_QWORD *)(a1 + 56);
  if (!v29)
    v29 = *(_QWORD *)(qword_1023103F8 + 56);
  v30 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002D0640(v29, a2);
  v31 = (int)v30;
  if (v30 >= 0x80)
    v32 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v30, a2);
  else
    v32 = 1;
  v4 = (v4 + v31 + v32 + 1);
  v3 = *(_DWORD *)(a1 + 292);
  if ((v3 & 0x80) != 0)
  {
LABEL_55:
    v33 = *(_QWORD *)(a1 + 64);
    if (!v33)
      v33 = *(_QWORD *)(qword_1023103F8 + 64);
    v34 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002D1D24(v33, a2);
    v35 = (int)v34;
    if (v34 >= 0x80)
      v36 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v34, a2);
    else
      v36 = 1;
    v4 = (v4 + v35 + v36 + 1);
    v3 = *(_DWORD *)(a1 + 292);
  }
LABEL_61:
  if ((v3 & 0xFF00) == 0)
    goto LABEL_119;
  if ((v3 & 0x100) != 0)
  {
    v37 = *(_QWORD *)(a1 + 72);
    if (!v37)
      v37 = *(_QWORD *)(qword_1023103F8 + 72);
    v38 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002CB538(v37, a2);
    v39 = (int)v38;
    if (v38 >= 0x80)
      v40 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v38, a2);
    else
      v40 = 1;
    v4 = (v4 + v39 + v40 + 1);
    v3 = *(_DWORD *)(a1 + 292);
    if ((v3 & 0x200) == 0)
    {
LABEL_64:
      if ((v3 & 0x400) == 0)
        goto LABEL_65;
      goto LABEL_83;
    }
  }
  else if ((v3 & 0x200) == 0)
  {
    goto LABEL_64;
  }
  v41 = *(_QWORD *)(a1 + 80);
  if (!v41)
    v41 = *(_QWORD *)(qword_1023103F8 + 80);
  v42 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002CD424(v41, a2);
  v43 = (int)v42;
  if (v42 >= 0x80)
    v44 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v42, a2);
  else
    v44 = 1;
  v4 = (v4 + v43 + v44 + 1);
  v3 = *(_DWORD *)(a1 + 292);
  if ((v3 & 0x400) == 0)
  {
LABEL_65:
    if ((v3 & 0x800) == 0)
      goto LABEL_66;
    goto LABEL_89;
  }
LABEL_83:
  v45 = *(_QWORD *)(a1 + 88);
  if (!v45)
    v45 = *(_QWORD *)(qword_1023103F8 + 88);
  v46 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002D22A8(v45, a2);
  v47 = (int)v46;
  if (v46 >= 0x80)
    v48 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v46, a2);
  else
    v48 = 1;
  v4 = (v4 + v47 + v48 + 1);
  v3 = *(_DWORD *)(a1 + 292);
  if ((v3 & 0x800) == 0)
  {
LABEL_66:
    if ((v3 & 0x1000) == 0)
      goto LABEL_67;
    goto LABEL_95;
  }
LABEL_89:
  v49 = *(_QWORD *)(a1 + 96);
  if (!v49)
    v49 = *(_QWORD *)(qword_1023103F8 + 96);
  v50 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002D268C(v49, a2);
  v51 = (int)v50;
  if (v50 >= 0x80)
    v52 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v50, a2);
  else
    v52 = 1;
  v4 = (v4 + v51 + v52 + 1);
  v3 = *(_DWORD *)(a1 + 292);
  if ((v3 & 0x1000) == 0)
  {
LABEL_67:
    if ((v3 & 0x2000) == 0)
      goto LABEL_68;
    goto LABEL_101;
  }
LABEL_95:
  v53 = *(_QWORD *)(a1 + 104);
  if (!v53)
    v53 = *(_QWORD *)(qword_1023103F8 + 104);
  v54 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002D2A70(v53, a2);
  v55 = (int)v54;
  if (v54 >= 0x80)
    v56 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v54, a2);
  else
    v56 = 1;
  v4 = (v4 + v55 + v56 + 2);
  v3 = *(_DWORD *)(a1 + 292);
  if ((v3 & 0x2000) == 0)
  {
LABEL_68:
    if ((v3 & 0x4000) == 0)
      goto LABEL_69;
    goto LABEL_107;
  }
LABEL_101:
  v57 = *(_QWORD *)(a1 + 112);
  if (!v57)
    v57 = *(_QWORD *)(qword_1023103F8 + 112);
  v58 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002D2E54(v57, a2);
  v59 = (int)v58;
  if (v58 >= 0x80)
    v60 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v58, a2);
  else
    v60 = 1;
  v4 = (v4 + v59 + v60 + 2);
  v3 = *(_DWORD *)(a1 + 292);
  if ((v3 & 0x4000) == 0)
  {
LABEL_69:
    if ((v3 & 0x8000) == 0)
      goto LABEL_119;
    goto LABEL_113;
  }
LABEL_107:
  v61 = *(_QWORD *)(a1 + 120);
  if (!v61)
    v61 = *(_QWORD *)(qword_1023103F8 + 120);
  v62 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002D3238(v61, a2);
  v63 = (int)v62;
  if (v62 >= 0x80)
    v64 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v62, a2);
  else
    v64 = 1;
  v4 = (v4 + v63 + v64 + 2);
  v3 = *(_DWORD *)(a1 + 292);
  if ((v3 & 0x8000) != 0)
  {
LABEL_113:
    v65 = *(_QWORD *)(a1 + 128);
    if (!v65)
      v65 = *(_QWORD *)(qword_1023103F8 + 128);
    v66 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002D3894(v65, a2);
    v67 = (int)v66;
    if (v66 >= 0x80)
      v68 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v66, a2);
    else
      v68 = 1;
    v4 = (v4 + v67 + v68 + 2);
    v3 = *(_DWORD *)(a1 + 292);
  }
LABEL_119:
  if ((v3 & 0xFF0000) == 0)
    goto LABEL_177;
  if ((v3 & 0x10000) != 0)
  {
    v69 = *(_QWORD *)(a1 + 136);
    if (!v69)
      v69 = *(_QWORD *)(qword_1023103F8 + 136);
    v70 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002D40A0(v69, a2);
    v71 = (int)v70;
    if (v70 >= 0x80)
      v72 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v70, a2);
    else
      v72 = 1;
    v4 = (v4 + v71 + v72 + 2);
    v3 = *(_DWORD *)(a1 + 292);
    if ((v3 & 0x20000) == 0)
    {
LABEL_122:
      if ((v3 & 0x40000) == 0)
        goto LABEL_123;
      goto LABEL_141;
    }
  }
  else if ((v3 & 0x20000) == 0)
  {
    goto LABEL_122;
  }
  v73 = *(_QWORD *)(a1 + 144);
  if (!v73)
    v73 = *(_QWORD *)(qword_1023103F8 + 144);
  v74 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002D4844(v73, a2);
  v75 = (int)v74;
  if (v74 >= 0x80)
    v76 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v74, a2);
  else
    v76 = 1;
  v4 = (v4 + v75 + v76 + 2);
  v3 = *(_DWORD *)(a1 + 292);
  if ((v3 & 0x40000) == 0)
  {
LABEL_123:
    if ((v3 & 0x80000) == 0)
      goto LABEL_124;
    goto LABEL_147;
  }
LABEL_141:
  v77 = *(_QWORD *)(a1 + 152);
  if (!v77)
    v77 = *(_QWORD *)(qword_1023103F8 + 152);
  v78 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002D4FE8(v77, a2);
  v79 = (int)v78;
  if (v78 >= 0x80)
    v80 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v78, a2);
  else
    v80 = 1;
  v4 = (v4 + v79 + v80 + 2);
  v3 = *(_DWORD *)(a1 + 292);
  if ((v3 & 0x80000) == 0)
  {
LABEL_124:
    if ((v3 & 0x100000) == 0)
      goto LABEL_125;
    goto LABEL_153;
  }
LABEL_147:
  v81 = *(_QWORD *)(a1 + 160);
  if (!v81)
    v81 = *(_QWORD *)(qword_1023103F8 + 160);
  v82 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002D590C(v81, a2);
  v83 = (int)v82;
  if (v82 >= 0x80)
    v84 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v82, a2);
  else
    v84 = 1;
  v4 = (v4 + v83 + v84 + 2);
  v3 = *(_DWORD *)(a1 + 292);
  if ((v3 & 0x100000) == 0)
  {
LABEL_125:
    if ((v3 & 0x200000) == 0)
      goto LABEL_126;
    goto LABEL_159;
  }
LABEL_153:
  v85 = *(_QWORD *)(a1 + 168);
  if (!v85)
    v85 = *(_QWORD *)(qword_1023103F8 + 168);
  v86 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002D60BC(v85, a2);
  v87 = (int)v86;
  if (v86 >= 0x80)
    v88 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v86, a2);
  else
    v88 = 1;
  v4 = (v4 + v87 + v88 + 2);
  v3 = *(_DWORD *)(a1 + 292);
  if ((v3 & 0x200000) == 0)
  {
LABEL_126:
    if ((v3 & 0x400000) == 0)
      goto LABEL_127;
    goto LABEL_165;
  }
LABEL_159:
  v89 = *(_QWORD *)(a1 + 176);
  if (!v89)
    v89 = *(_QWORD *)(qword_1023103F8 + 176);
  v90 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002D6BE0(v89, a2);
  v91 = (int)v90;
  if (v90 >= 0x80)
    v92 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v90, a2);
  else
    v92 = 1;
  v4 = (v4 + v91 + v92 + 2);
  v3 = *(_DWORD *)(a1 + 292);
  if ((v3 & 0x400000) == 0)
  {
LABEL_127:
    if ((v3 & 0x800000) == 0)
      goto LABEL_177;
    goto LABEL_171;
  }
LABEL_165:
  v93 = *(_QWORD *)(a1 + 184);
  if (!v93)
    v93 = *(_QWORD *)(qword_1023103F8 + 184);
  v94 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002D757C(v93, a2);
  v95 = (int)v94;
  if (v94 >= 0x80)
    v96 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v94, a2);
  else
    v96 = 1;
  v4 = (v4 + v95 + v96 + 2);
  v3 = *(_DWORD *)(a1 + 292);
  if ((v3 & 0x800000) != 0)
  {
LABEL_171:
    v97 = *(_QWORD *)(a1 + 192);
    if (!v97)
      v97 = *(_QWORD *)(qword_1023103F8 + 192);
    v98 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002D7C44(v97, a2);
    v99 = (int)v98;
    if (v98 >= 0x80)
      v100 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v98, a2);
    else
      v100 = 1;
    v4 = (v4 + v99 + v100 + 2);
    v3 = *(_DWORD *)(a1 + 292);
  }
LABEL_177:
  if (!HIBYTE(v3))
    goto LABEL_235;
  if ((v3 & 0x1000000) != 0)
  {
    v101 = *(_QWORD *)(a1 + 200);
    if (!v101)
      v101 = *(_QWORD *)(qword_1023103F8 + 200);
    v102 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002D85F0(v101, a2);
    v103 = (int)v102;
    if (v102 >= 0x80)
      v104 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v102, a2);
    else
      v104 = 1;
    v4 = (v4 + v103 + v104 + 2);
    v3 = *(_DWORD *)(a1 + 292);
    if ((v3 & 0x2000000) == 0)
    {
LABEL_180:
      if ((v3 & 0x4000000) == 0)
        goto LABEL_181;
      goto LABEL_199;
    }
  }
  else if ((v3 & 0x2000000) == 0)
  {
    goto LABEL_180;
  }
  v105 = *(_QWORD *)(a1 + 208);
  if (!v105)
    v105 = *(_QWORD *)(qword_1023103F8 + 208);
  v106 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002D8CF8(v105, a2);
  v107 = (int)v106;
  if (v106 >= 0x80)
    v108 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v106, a2);
  else
    v108 = 1;
  v4 = (v4 + v107 + v108 + 2);
  v3 = *(_DWORD *)(a1 + 292);
  if ((v3 & 0x4000000) == 0)
  {
LABEL_181:
    if ((v3 & 0x8000000) == 0)
      goto LABEL_182;
    goto LABEL_205;
  }
LABEL_199:
  v109 = *(_QWORD *)(a1 + 216);
  if (!v109)
    v109 = *(_QWORD *)(qword_1023103F8 + 216);
  v110 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002D9800(v109, a2);
  v111 = (int)v110;
  if (v110 >= 0x80)
    v112 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v110, a2);
  else
    v112 = 1;
  v4 = (v4 + v111 + v112 + 2);
  v3 = *(_DWORD *)(a1 + 292);
  if ((v3 & 0x8000000) == 0)
  {
LABEL_182:
    if ((v3 & 0x10000000) == 0)
      goto LABEL_183;
    goto LABEL_211;
  }
LABEL_205:
  v113 = *(_QWORD *)(a1 + 224);
  if (!v113)
    v113 = *(_QWORD *)(qword_1023103F8 + 224);
  v114 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002E16F8(v113, a2);
  v115 = (int)v114;
  if (v114 >= 0x80)
    v116 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v114, a2);
  else
    v116 = 1;
  v4 = (v4 + v115 + v116 + 2);
  v3 = *(_DWORD *)(a1 + 292);
  if ((v3 & 0x10000000) == 0)
  {
LABEL_183:
    if ((v3 & 0x20000000) == 0)
      goto LABEL_184;
    goto LABEL_217;
  }
LABEL_211:
  v117 = *(_QWORD *)(a1 + 232);
  if (!v117)
    v117 = *(_QWORD *)(qword_1023103F8 + 232);
  v118 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002E1D90(v117, a2);
  v119 = (int)v118;
  if (v118 >= 0x80)
    v120 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v118, a2);
  else
    v120 = 1;
  v4 = (v4 + v119 + v120 + 2);
  v3 = *(_DWORD *)(a1 + 292);
  if ((v3 & 0x20000000) == 0)
  {
LABEL_184:
    if ((v3 & 0x40000000) == 0)
      goto LABEL_185;
    goto LABEL_223;
  }
LABEL_217:
  v121 = *(_QWORD *)(a1 + 240);
  if (!v121)
    v121 = *(_QWORD *)(qword_1023103F8 + 240);
  v122 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002E21B4(v121, a2);
  v123 = (int)v122;
  if (v122 >= 0x80)
    v124 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v122, a2);
  else
    v124 = 1;
  v4 = (v4 + v123 + v124 + 2);
  v3 = *(_DWORD *)(a1 + 292);
  if ((v3 & 0x40000000) == 0)
  {
LABEL_185:
    if ((v3 & 0x80000000) == 0)
      goto LABEL_235;
    goto LABEL_229;
  }
LABEL_223:
  v125 = *(_QWORD *)(a1 + 248);
  if (!v125)
    v125 = *(_QWORD *)(qword_1023103F8 + 248);
  v126 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002E28D0(v125, a2);
  v127 = (int)v126;
  if (v126 >= 0x80)
    v128 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v126, a2);
  else
    v128 = 1;
  v4 = (v4 + v127 + v128 + 2);
  if ((*(_DWORD *)(a1 + 292) & 0x80000000) != 0)
  {
LABEL_229:
    v129 = *(_QWORD *)(a1 + 256);
    if (!v129)
      v129 = *(_QWORD *)(qword_1023103F8 + 256);
    v130 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002E2CBC(v129, a2);
    v131 = (int)v130;
    if (v130 >= 0x80)
      v132 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v130, a2);
    else
      v132 = 1;
    v4 = (v4 + v131 + v132 + 2);
  }
LABEL_235:
  LOBYTE(v133) = *(_BYTE *)(a1 + 296);
  if (!(_BYTE)v133)
    goto LABEL_258;
  if ((*(_BYTE *)(a1 + 296) & 1) != 0)
  {
    v134 = *(_QWORD *)(a1 + 264);
    if (!v134)
      v134 = *(_QWORD *)(qword_1023103F8 + 264);
    v135 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002E2F98(v134, a2);
    v136 = (int)v135;
    if (v135 >= 0x80)
      v137 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v135, a2);
    else
      v137 = 1;
    v4 = (v4 + v136 + v137 + 2);
    v133 = *(_DWORD *)(a1 + 296);
    if ((v133 & 2) == 0)
    {
LABEL_238:
      if ((v133 & 4) == 0)
        goto LABEL_258;
      goto LABEL_252;
    }
  }
  else if ((*(_BYTE *)(a1 + 296) & 2) == 0)
  {
    goto LABEL_238;
  }
  v138 = *(_QWORD *)(a1 + 272);
  if (!v138)
    v138 = *(_QWORD *)(qword_1023103F8 + 272);
  v139 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002E3258(v138, a2);
  v140 = (int)v139;
  if (v139 >= 0x80)
    v141 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v139, a2);
  else
    v141 = 1;
  v4 = (v4 + v140 + v141 + 2);
  if ((*(_DWORD *)(a1 + 296) & 4) != 0)
  {
LABEL_252:
    v142 = *(_QWORD *)(a1 + 280);
    if (!v142)
      v142 = *(_QWORD *)(qword_1023103F8 + 280);
    v143 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002D9F0C(v142, a2);
    v145 = (int)v143;
    if (v143 >= 0x80)
      v146 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v143, v144);
    else
      v146 = 1;
    v4 = (v4 + v145 + v146 + 2);
  }
LABEL_258:
  *(_DWORD *)(a1 + 288) = v4;
  return v4;
}

void sub_1002DE16C(uint64_t a1, void *lpsrc)
{
  uint64_t v4;
  uint64_t v5;

  sub_1000B14DC(a1, (uint64_t)lpsrc);
}

void sub_1002DE1B8(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  char v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  const std::string *v11;
  std::string *v12;
  uint64_t v13;
  char v14;
  const std::string *v15;
  std::string *v16;
  const std::string *v17;
  std::string *v18;
  const std::string *v19;
  std::string *v20;
  const std::string *v21;
  std::string *v22;
  char v23;
  _BYTE v24[48];

  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage(v24, 3, "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/proto/gen-cpp/microlocation.pb.cc", 18748);
    v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<(v24, "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v23, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v24);
  }
  v5 = *(_DWORD *)(a2 + 80);
  if (!(_BYTE)v5)
    goto LABEL_17;
  if ((v5 & 1) != 0)
  {
    v6 = *(_DWORD *)(a2 + 24);
    if (v6 - 31 >= 0x19 && (v6 > 0xE || ((1 << v6) & 0x76B6) == 0))
      sub_1018F268C();
    *(_DWORD *)(a1 + 80) |= 1u;
    *(_DWORD *)(a1 + 24) = v6;
    v5 = *(_DWORD *)(a2 + 80);
  }
  if ((v5 & 2) != 0)
  {
    v13 = *(_QWORD *)(a2 + 8);
    *(_DWORD *)(a1 + 80) |= 2u;
    *(_QWORD *)(a1 + 8) = v13;
    v5 = *(_DWORD *)(a2 + 80);
    if ((v5 & 4) == 0)
    {
LABEL_11:
      if ((v5 & 8) == 0)
        goto LABEL_12;
      goto LABEL_34;
    }
  }
  else if ((v5 & 4) == 0)
  {
    goto LABEL_11;
  }
  v14 = *(_BYTE *)(a2 + 28);
  *(_DWORD *)(a1 + 80) |= 4u;
  *(_BYTE *)(a1 + 28) = v14;
  v5 = *(_DWORD *)(a2 + 80);
  if ((v5 & 8) == 0)
  {
LABEL_12:
    if ((v5 & 0x10) == 0)
      goto LABEL_13;
    goto LABEL_37;
  }
LABEL_34:
  v15 = *(const std::string **)(a2 + 16);
  *(_DWORD *)(a1 + 80) |= 8u;
  v16 = *(std::string **)(a1 + 16);
  if (v16 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    operator new();
  std::string::operator=(v16, v15);
  v5 = *(_DWORD *)(a2 + 80);
  if ((v5 & 0x10) == 0)
  {
LABEL_13:
    if ((v5 & 0x20) == 0)
      goto LABEL_14;
LABEL_40:
    v19 = *(const std::string **)(a2 + 40);
    *(_DWORD *)(a1 + 80) |= 0x20u;
    v20 = *(std::string **)(a1 + 40);
    if (v20 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      operator new();
    std::string::operator=(v20, v19);
    v5 = *(_DWORD *)(a2 + 80);
    if ((v5 & 0x40) == 0)
    {
LABEL_15:
      if ((v5 & 0x80) == 0)
        goto LABEL_17;
      goto LABEL_16;
    }
    goto LABEL_43;
  }
LABEL_37:
  v17 = *(const std::string **)(a2 + 32);
  *(_DWORD *)(a1 + 80) |= 0x10u;
  v18 = *(std::string **)(a1 + 32);
  if (v18 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    operator new();
  std::string::operator=(v18, v17);
  v5 = *(_DWORD *)(a2 + 80);
  if ((v5 & 0x20) != 0)
    goto LABEL_40;
LABEL_14:
  if ((v5 & 0x40) == 0)
    goto LABEL_15;
LABEL_43:
  v21 = *(const std::string **)(a2 + 48);
  *(_DWORD *)(a1 + 80) |= 0x40u;
  v22 = *(std::string **)(a1 + 48);
  if (v22 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    operator new();
  std::string::operator=(v22, v21);
  v5 = *(_DWORD *)(a2 + 80);
  if ((v5 & 0x80) != 0)
  {
LABEL_16:
    v7 = *(_BYTE *)(a2 + 29);
    *(_DWORD *)(a1 + 80) |= 0x80u;
    *(_BYTE *)(a1 + 29) = v7;
    v5 = *(_DWORD *)(a2 + 80);
  }
LABEL_17:
  if ((v5 & 0xFF00) != 0)
  {
    if ((v5 & 0x100) != 0)
    {
      v8 = *(_DWORD *)(a2 + 56);
      if (v8 >= 2)
        sub_1018F2664();
      *(_DWORD *)(a1 + 80) |= 0x100u;
      *(_DWORD *)(a1 + 56) = v8;
      v5 = *(_DWORD *)(a2 + 80);
    }
    if ((v5 & 0x200) != 0)
    {
      v9 = *(_DWORD *)(a2 + 60);
      if (v9 >= 6)
        sub_1018F263C();
      *(_DWORD *)(a1 + 80) |= 0x200u;
      *(_DWORD *)(a1 + 60) = v9;
      v5 = *(_DWORD *)(a2 + 80);
    }
    if ((v5 & 0x400) != 0)
    {
      v10 = *(_DWORD *)(a2 + 72);
      if (v10 >= 6)
        sub_1018F2614();
      *(_DWORD *)(a1 + 80) |= 0x400u;
      *(_DWORD *)(a1 + 72) = v10;
      v5 = *(_DWORD *)(a2 + 80);
    }
    if ((v5 & 0x800) != 0)
    {
      v11 = *(const std::string **)(a2 + 64);
      *(_DWORD *)(a1 + 80) |= 0x800u;
      v12 = *(std::string **)(a1 + 64);
      if (v12 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
        operator new();
      std::string::operator=(v12, v11);
    }
  }
}

void sub_1002DE524(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_1002DE53C(_DWORD *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  int v7;
  char v8;
  _BYTE v9[48];

  if ((_DWORD *)a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage(v9, 3, "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/proto/gen-cpp/microlocation.pb.cc", 18998);
    v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<(v9, "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v8, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }
  LOBYTE(v5) = *(_BYTE *)(a2 + 20);
  if ((_BYTE)v5)
  {
    if ((*(_BYTE *)(a2 + 20) & 1) != 0)
    {
      v6 = *(_DWORD *)(a2 + 8);
      if (v6 - 31 >= 0x19 && (v6 > 0xE || ((1 << v6) & 0x76B6) == 0))
        sub_1018F26DC();
      a1[5] |= 1u;
      a1[2] = v6;
      v5 = *(_DWORD *)(a2 + 20);
    }
    if ((v5 & 2) != 0)
    {
      v7 = *(_DWORD *)(a2 + 12);
      if ((v7 - 1) >= 2 && v7 != 255)
        sub_1018F26B4();
      a1[5] |= 2u;
      a1[3] = v7;
    }
  }
}

void sub_1002DE628(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_1002DE640(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  char v7;
  char v8;
  _BYTE v9[48];

  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage(v9, 3, "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/proto/gen-cpp/microlocation.pb.cc", 19201);
    v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<(v9, "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v8, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }
  LOBYTE(v5) = *(_BYTE *)(a2 + 20);
  if ((_BYTE)v5)
  {
    if ((*(_BYTE *)(a2 + 20) & 1) != 0)
    {
      v6 = *(_DWORD *)(a2 + 8);
      if (v6 - 31 >= 0x19 && (v6 > 0xE || ((1 << v6) & 0x76B6) == 0))
        sub_1018F2704();
      *(_DWORD *)(a1 + 20) |= 1u;
      *(_DWORD *)(a1 + 8) = v6;
      v5 = *(_DWORD *)(a2 + 20);
    }
    if ((v5 & 2) != 0)
    {
      v7 = *(_BYTE *)(a2 + 12);
      *(_DWORD *)(a1 + 20) |= 2u;
      *(_BYTE *)(a1 + 12) = v7;
    }
  }
}

void sub_1002DE714(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_1002DE72C(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  char v7;
  char v8;
  char v9;
  char v10;
  char v11;
  char v12;
  char v13;
  _BYTE v14[48];

  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage(v14, 3, "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/proto/gen-cpp/microlocation.pb.cc", 19549);
    v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<(v14, "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v13, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v14);
  }
  LOBYTE(v5) = *(_BYTE *)(a2 + 24);
  if (!(_BYTE)v5)
    return;
  if ((*(_BYTE *)(a2 + 24) & 1) != 0)
  {
    v6 = *(_DWORD *)(a2 + 8);
    if (v6 - 31 >= 0x19 && (v6 > 0xE || ((1 << v6) & 0x76B6) == 0))
      sub_1018F272C();
    *(_DWORD *)(a1 + 24) |= 1u;
    *(_DWORD *)(a1 + 8) = v6;
    v5 = *(_DWORD *)(a2 + 24);
  }
  if ((v5 & 2) != 0)
  {
    v8 = *(_BYTE *)(a2 + 12);
    *(_DWORD *)(a1 + 24) |= 2u;
    *(_BYTE *)(a1 + 12) = v8;
    v5 = *(_DWORD *)(a2 + 24);
    if ((v5 & 4) == 0)
    {
LABEL_11:
      if ((v5 & 8) == 0)
        goto LABEL_12;
      goto LABEL_19;
    }
  }
  else if ((v5 & 4) == 0)
  {
    goto LABEL_11;
  }
  v9 = *(_BYTE *)(a2 + 13);
  *(_DWORD *)(a1 + 24) |= 4u;
  *(_BYTE *)(a1 + 13) = v9;
  v5 = *(_DWORD *)(a2 + 24);
  if ((v5 & 8) == 0)
  {
LABEL_12:
    if ((v5 & 0x10) == 0)
      goto LABEL_13;
LABEL_20:
    v11 = *(_BYTE *)(a2 + 15);
    *(_DWORD *)(a1 + 24) |= 0x10u;
    *(_BYTE *)(a1 + 15) = v11;
    v5 = *(_DWORD *)(a2 + 24);
    if ((v5 & 0x20) == 0)
    {
LABEL_14:
      if ((v5 & 0x40) == 0)
        return;
      goto LABEL_15;
    }
    goto LABEL_21;
  }
LABEL_19:
  v10 = *(_BYTE *)(a2 + 14);
  *(_DWORD *)(a1 + 24) |= 8u;
  *(_BYTE *)(a1 + 14) = v10;
  v5 = *(_DWORD *)(a2 + 24);
  if ((v5 & 0x10) != 0)
    goto LABEL_20;
LABEL_13:
  if ((v5 & 0x20) == 0)
    goto LABEL_14;
LABEL_21:
  v12 = *(_BYTE *)(a2 + 16);
  *(_DWORD *)(a1 + 24) |= 0x20u;
  *(_BYTE *)(a1 + 16) = v12;
  if ((*(_DWORD *)(a2 + 24) & 0x40) != 0)
  {
LABEL_15:
    v7 = *(_BYTE *)(a2 + 17);
    *(_DWORD *)(a1 + 24) |= 0x40u;
    *(_BYTE *)(a1 + 17) = v7;
  }
}

void sub_1002DE8A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_1002DE8BC(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int v5;
  char v7;
  _BYTE v8[48];

  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage(v8, 3, "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/proto/gen-cpp/microlocation.pb.cc", 19946);
    v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<(v8, "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v7, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v8);
  }
  if ((*(_BYTE *)(a2 + 16) & 1) != 0)
  {
    v5 = *(_DWORD *)(a2 + 8);
    if (v5 - 31 >= 0x19 && (v5 > 0xE || ((1 << v5) & 0x76B6) == 0))
      sub_1018F277C();
    *(_DWORD *)(a1 + 16) |= 1u;
    *(_DWORD *)(a1 + 8) = v5;
  }
}

void sub_1002DE970(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_1002DE988(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int v5;
  char v7;
  _BYTE v8[48];

  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage(v8, 3, "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/proto/gen-cpp/microlocation.pb.cc", 20116);
    v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<(v8, "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v7, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v8);
  }
  if ((*(_BYTE *)(a2 + 16) & 1) != 0)
  {
    v5 = *(_DWORD *)(a2 + 8);
    if (v5 - 31 >= 0x19 && (v5 > 0xE || ((1 << v5) & 0x76B6) == 0))
      sub_1018F27A4();
    *(_DWORD *)(a1 + 16) |= 1u;
    *(_DWORD *)(a1 + 8) = v5;
  }
}

void sub_1002DEA3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002DEA54()
{
  return 1;
}

_QWORD *sub_1002DEA5C@<X0>(_QWORD *a1@<X8>)
{
  return sub_1015A2E04(a1, "CLMicroLocationProto.ReceivedEvent");
}

uint64_t sub_1002DEA6C(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = off_10212D5F8;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 72) = 1;
  *(_WORD *)(a1 + 76) = 0;
  *(_DWORD *)(a1 + 128) = 0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  sub_1002DEB08(a1, a2);
  return a1;
}

void sub_1002DEAD4(_Unwind_Exception *a1)
{
  wireless_diagnostics::google::protobuf::MessageLite *v1;
  _QWORD *v2;
  _QWORD *v3;

  v3 = v2;
  if (*v3)
    operator delete[]();
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(v1);
  _Unwind_Resume(a1);
}

void sub_1002DEB08(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  unsigned int v31;
  char v32;
  _BYTE v33[48];

  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage(v33, 3, "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/proto/gen-cpp/microlocation.pb.cc", 18140);
    v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<(v33, "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v32, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v33);
  }
  v5 = *(_DWORD *)(a2 + 112);
  if (v5)
  {
    sub_1002A19E0(a1 + 104, *(_DWORD *)(a1 + 112) + v5);
    memcpy((void *)(*(_QWORD *)(a1 + 104) + 4 * *(int *)(a1 + 112)), *(const void **)(a2 + 104), 4 * *(int *)(a2 + 112));
    *(_DWORD *)(a1 + 112) += *(_DWORD *)(a2 + 112);
  }
  v6 = *(_DWORD *)(a2 + 128);
  if (!(_BYTE)v6)
    goto LABEL_50;
  if ((v6 & 1) != 0)
  {
    v7 = *(_DWORD *)(a2 + 72);
    if (v7 - 31 >= 0x19 && (v7 > 0xE || ((1 << v7) & 0x76B6) == 0))
      sub_1018F27CC();
    *(_DWORD *)(a1 + 128) |= 1u;
    *(_DWORD *)(a1 + 72) = v7;
    v6 = *(_DWORD *)(a2 + 128);
  }
  if ((v6 & 2) != 0)
  {
    v8 = *(_QWORD *)(a2 + 8);
    *(_DWORD *)(a1 + 128) |= 2u;
    *(_QWORD *)(a1 + 8) = v8;
    v6 = *(_DWORD *)(a2 + 128);
    if ((v6 & 4) == 0)
    {
LABEL_13:
      if ((v6 & 8) == 0)
        goto LABEL_14;
      goto LABEL_25;
    }
  }
  else if ((v6 & 4) == 0)
  {
    goto LABEL_13;
  }
  *(_DWORD *)(a1 + 128) |= 4u;
  v9 = *(_QWORD *)(a1 + 16);
  if (!v9)
    operator new();
  v10 = *(_QWORD *)(a2 + 16);
  if (!v10)
    v10 = *(_QWORD *)(qword_102310400 + 16);
  sub_1002CA258(v9, v10);
  v6 = *(_DWORD *)(a2 + 128);
  if ((v6 & 8) == 0)
  {
LABEL_14:
    if ((v6 & 0x10) == 0)
      goto LABEL_15;
    goto LABEL_30;
  }
LABEL_25:
  *(_DWORD *)(a1 + 128) |= 8u;
  v11 = *(_QWORD *)(a1 + 24);
  if (!v11)
    operator new();
  v12 = *(_QWORD *)(a2 + 24);
  if (!v12)
    v12 = *(_QWORD *)(qword_102310400 + 24);
  sub_1002CB7A0(v11, v12);
  v6 = *(_DWORD *)(a2 + 128);
  if ((v6 & 0x10) == 0)
  {
LABEL_15:
    if ((v6 & 0x20) == 0)
      goto LABEL_16;
LABEL_35:
    *(_DWORD *)(a1 + 128) |= 0x20u;
    v15 = *(_QWORD *)(a1 + 40);
    if (!v15)
      operator new();
    v16 = *(_QWORD *)(a2 + 40);
    if (!v16)
      v16 = *(_QWORD *)(qword_102310400 + 40);
    sub_1002CC850(v15, v16);
    v6 = *(_DWORD *)(a2 + 128);
    if ((v6 & 0x40) == 0)
    {
LABEL_17:
      if ((v6 & 0x80) == 0)
        goto LABEL_50;
      goto LABEL_45;
    }
    goto LABEL_40;
  }
LABEL_30:
  *(_DWORD *)(a1 + 128) |= 0x10u;
  v13 = *(_QWORD *)(a1 + 32);
  if (!v13)
    operator new();
  v14 = *(_QWORD *)(a2 + 32);
  if (!v14)
    v14 = *(_QWORD *)(qword_102310400 + 32);
  sub_1002CC240(v13, v14);
  v6 = *(_DWORD *)(a2 + 128);
  if ((v6 & 0x20) != 0)
    goto LABEL_35;
LABEL_16:
  if ((v6 & 0x40) == 0)
    goto LABEL_17;
LABEL_40:
  *(_DWORD *)(a1 + 128) |= 0x40u;
  v17 = *(_QWORD *)(a1 + 48);
  if (!v17)
    operator new();
  v18 = *(_QWORD *)(a2 + 48);
  if (!v18)
    v18 = *(_QWORD *)(qword_102310400 + 48);
  sub_1002CD654(v17, v18);
  v6 = *(_DWORD *)(a2 + 128);
  if ((v6 & 0x80) != 0)
  {
LABEL_45:
    *(_DWORD *)(a1 + 128) |= 0x80u;
    v19 = *(_QWORD *)(a1 + 56);
    if (!v19)
      operator new();
    v20 = *(_QWORD *)(a2 + 56);
    if (!v20)
      v20 = *(_QWORD *)(qword_102310400 + 56);
    sub_1002CDA38(v19, v20);
    v6 = *(_DWORD *)(a2 + 128);
  }
LABEL_50:
  if ((v6 & 0xFF00) == 0)
    return;
  if ((v6 & 0x100) != 0)
  {
    *(_DWORD *)(a1 + 128) |= 0x100u;
    v21 = *(_QWORD *)(a1 + 64);
    if (!v21)
      operator new();
    v22 = *(_QWORD *)(a2 + 64);
    if (!v22)
      v22 = *(_QWORD *)(qword_102310400 + 64);
    sub_1002CF5D0(v21, v22);
    v6 = *(_DWORD *)(a2 + 128);
    if ((v6 & 0x200) == 0)
    {
LABEL_53:
      if ((v6 & 0x400) == 0)
        goto LABEL_54;
      goto LABEL_69;
    }
  }
  else if ((v6 & 0x200) == 0)
  {
    goto LABEL_53;
  }
  *(_DWORD *)(a1 + 128) |= 0x200u;
  v23 = *(_QWORD *)(a1 + 80);
  if (!v23)
    operator new();
  v24 = *(_QWORD *)(a2 + 80);
  if (!v24)
    v24 = *(_QWORD *)(qword_102310400 + 80);
  sub_1002D1100(v23, v24);
  v6 = *(_DWORD *)(a2 + 128);
  if ((v6 & 0x400) == 0)
  {
LABEL_54:
    if ((v6 & 0x800) == 0)
      goto LABEL_55;
    goto LABEL_74;
  }
LABEL_69:
  *(_DWORD *)(a1 + 128) |= 0x400u;
  v25 = *(_QWORD *)(a1 + 88);
  if (!v25)
    operator new();
  v26 = *(_QWORD *)(a2 + 88);
  if (!v26)
    v26 = *(_QWORD *)(qword_102310400 + 88);
  sub_1002CAD68(v25, v26);
  v6 = *(_DWORD *)(a2 + 128);
  if ((v6 & 0x800) == 0)
  {
LABEL_55:
    if ((v6 & 0x1000) == 0)
      goto LABEL_56;
    goto LABEL_75;
  }
LABEL_74:
  v27 = *(_BYTE *)(a2 + 76);
  *(_DWORD *)(a1 + 128) |= 0x800u;
  *(_BYTE *)(a1 + 76) = v27;
  v6 = *(_DWORD *)(a2 + 128);
  if ((v6 & 0x1000) == 0)
  {
LABEL_56:
    if ((v6 & 0x2000) == 0)
      goto LABEL_57;
LABEL_80:
    v30 = *(_BYTE *)(a2 + 77);
    *(_DWORD *)(a1 + 128) |= 0x2000u;
    *(_BYTE *)(a1 + 77) = v30;
    if ((*(_DWORD *)(a2 + 128) & 0x4000) == 0)
      return;
    goto LABEL_81;
  }
LABEL_75:
  *(_DWORD *)(a1 + 128) |= 0x1000u;
  v28 = *(_QWORD *)(a1 + 96);
  if (!v28)
    operator new();
  v29 = *(_QWORD *)(a2 + 96);
  if (!v29)
    v29 = *(_QWORD *)(qword_102310400 + 96);
  sub_1002CCC34(v28, v29);
  v6 = *(_DWORD *)(a2 + 128);
  if ((v6 & 0x2000) != 0)
    goto LABEL_80;
LABEL_57:
  if ((v6 & 0x4000) == 0)
    return;
LABEL_81:
  v31 = *(_DWORD *)(a2 + 120);
  if (v31 >= 4 && v31 != 15)
    sub_1018F0A78();
  *(_DWORD *)(a1 + 128) |= 0x4000u;
  *(_DWORD *)(a1 + 120) = v31;
}

void sub_1002DF17C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_1002DF198(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(_QWORD *)a1 = off_10212D5F8;
  sub_1002DF1E4(a1);
  if (*((_QWORD *)a1 + 13))
    operator delete[]();
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

_QWORD *sub_1002DF1E4(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if ((_QWORD *)qword_102310400 != result)
  {
    v1 = result;
    v2 = result[2];
    if (v2)
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
    v3 = v1[3];
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
    v4 = v1[4];
    if (v4)
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
    v5 = v1[5];
    if (v5)
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
    v6 = v1[6];
    if (v6)
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
    v7 = v1[7];
    if (v7)
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
    v8 = v1[8];
    if (v8)
      (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
    v9 = v1[10];
    if (v9)
      (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
    v10 = v1[11];
    if (v10)
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
    result = (_QWORD *)v1[12];
    if (result)
      return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 8))(result);
  }
  return result;
}

void sub_1002DF2E4(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  sub_1002DF198(a1);
  operator delete();
}

void sub_1002DF308()
{
  operator new();
}

uint64_t sub_1002DF36C(uint64_t result)
{
  uint64_t v1;
  int v2;
  uint64_t v3;
  uint64_t v4;

  v1 = result;
  v2 = *(_DWORD *)(result + 128);
  if ((_BYTE)v2)
  {
    *(_DWORD *)(result + 72) = 1;
    *(_QWORD *)(result + 8) = 0;
    if ((v2 & 4) != 0)
    {
      result = *(_QWORD *)(result + 16);
      if (result)
      {
        result = sub_1002CA600(result);
        v2 = *(_DWORD *)(v1 + 128);
      }
    }
    if ((v2 & 8) != 0)
    {
      result = *(_QWORD *)(v1 + 24);
      if (result)
      {
        result = sub_1002CBB28(result);
        v2 = *(_DWORD *)(v1 + 128);
      }
    }
    if ((v2 & 0x10) != 0)
    {
      result = *(_QWORD *)(v1 + 32);
      if (result)
      {
        result = sub_1002CC428(result);
        v2 = *(_DWORD *)(v1 + 128);
      }
    }
    if ((v2 & 0x20) != 0)
    {
      v3 = *(_QWORD *)(v1 + 40);
      if (v3)
      {
        if (*(_BYTE *)(v3 + 16))
          *(_DWORD *)(v3 + 8) = 5;
        *(_DWORD *)(v3 + 16) = 0;
        v2 = *(_DWORD *)(v1 + 128);
      }
    }
    if ((v2 & 0x40) != 0)
    {
      v4 = *(_QWORD *)(v1 + 48);
      if (v4)
      {
        if (*(_BYTE *)(v4 + 16))
          *(_DWORD *)(v4 + 8) = 7;
        *(_DWORD *)(v4 + 16) = 0;
        v2 = *(_DWORD *)(v1 + 128);
      }
    }
    if ((v2 & 0x80) != 0)
    {
      result = *(_QWORD *)(v1 + 56);
      if (result)
      {
        result = sub_1002CE358(result);
        v2 = *(_DWORD *)(v1 + 128);
      }
    }
  }
  if ((v2 & 0xFF00) != 0)
  {
    if ((v2 & 0x100) != 0)
    {
      result = *(_QWORD *)(v1 + 64);
      if (result)
      {
        result = sub_1002CFC98(result);
        v2 = *(_DWORD *)(v1 + 128);
      }
    }
    if ((v2 & 0x200) != 0)
    {
      result = *(_QWORD *)(v1 + 80);
      if (result)
      {
        result = sub_1002D1598(result);
        v2 = *(_DWORD *)(v1 + 128);
      }
    }
    if ((v2 & 0x400) != 0)
    {
      result = *(_QWORD *)(v1 + 88);
      if (result)
      {
        result = sub_1002CB034(result);
        v2 = *(_DWORD *)(v1 + 128);
      }
    }
    *(_BYTE *)(v1 + 76) = 0;
    if ((v2 & 0x1000) != 0)
    {
      result = *(_QWORD *)(v1 + 96);
      if (result)
        result = sub_1002CCFC4(result);
    }
    *(_BYTE *)(v1 + 77) = 0;
    *(_DWORD *)(v1 + 120) = 0;
  }
  *(_DWORD *)(v1 + 112) = 0;
  *(_DWORD *)(v1 + 128) = 0;
  return result;
}

uint64_t sub_1002DF4A0(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  uint64_t v5;
  char *v6;
  wireless_diagnostics::google::protobuf::io::CodedInputStream *TagFallback;
  int v8;
  char *v9;
  unsigned int v10;
  unint64_t v11;
  unsigned __int8 *v12;
  int v13;
  unint64_t v14;
  unsigned __int8 *v15;
  int v16;
  char *v17;
  unsigned __int8 *v18;
  char *v19;
  uint64_t result;
  BOOL v21;
  _BYTE *v22;
  _BYTE *v23;
  uint64_t v24;
  char *v25;
  int v26;
  int v27;
  int v28;
  unsigned int v29;
  int v30;
  BOOL v31;
  int v32;
  _BYTE *v33;
  uint64_t v34;
  char *v35;
  int v36;
  int v37;
  int v38;
  unsigned int v39;
  int v40;
  int v41;
  _BYTE *v42;
  uint64_t v43;
  char *v44;
  int v45;
  int v46;
  int v47;
  unsigned int v48;
  int v49;
  int v50;
  _BYTE *v51;
  uint64_t v52;
  char *v53;
  int v54;
  int v55;
  int v56;
  unsigned int v57;
  int v58;
  int v59;
  _BYTE *v60;
  uint64_t v61;
  char *v62;
  int v63;
  int v64;
  int v65;
  unsigned int v66;
  int v67;
  int v68;
  _BYTE *v69;
  uint64_t v70;
  char *v71;
  int v72;
  int v73;
  int v74;
  unsigned int v75;
  int v76;
  int v77;
  _BYTE *v78;
  uint64_t v79;
  char *v80;
  int v81;
  int v82;
  int v83;
  unsigned int v84;
  int v85;
  int v86;
  _BYTE *v87;
  uint64_t v88;
  char *v89;
  int v90;
  int v91;
  int v92;
  unsigned int v93;
  int v94;
  int v95;
  _BYTE *v96;
  uint64_t v97;
  char *v98;
  int v99;
  int v100;
  int v101;
  unsigned int v102;
  int v103;
  int v104;
  unsigned __int8 *v105;
  unsigned int v106;
  unsigned __int8 *v107;
  uint64_t v108;
  char *v109;
  int v110;
  int v111;
  int v112;
  unsigned int v113;
  int v114;
  int v115;
  unsigned __int8 *v116;
  unsigned int v117;
  unsigned __int8 *v118;
  unsigned int v119;
  unsigned __int8 *v121;
  unsigned int v122;
  int v123;
  uint64_t v124;
  unsigned int v125[2];

  v5 = a1 + 104;
  while (2)
  {
    v6 = (char *)*((_QWORD *)this + 1);
    if ((unint64_t)v6 >= *((_QWORD *)this + 2) || *v6 < 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      if (!(_DWORD)TagFallback)
        return 1;
    }
    else
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v6;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((_QWORD *)this + 1) = v6 + 1;
      if (!(_DWORD)TagFallback)
        return 1;
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0)
          goto LABEL_44;
        v125[0] = 0;
        v9 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v9 >= *((_QWORD *)this + 2) || *v9 < 0)
        {
          result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v125);
          if (!(_DWORD)result)
            return result;
          v10 = v125[0];
        }
        else
        {
          v10 = *v9;
          *((_QWORD *)this + 1) = v9 + 1;
        }
        if (v10 - 31 < 0x19 || (v10 <= 0xE ? (v21 = ((1 << v10) & 0x76B6) == 0) : (v21 = 1), !v21))
        {
          if (v10 - 31 >= 0x19 && (v10 > 0xE || ((1 << v10) & 0x76B6) == 0))
            sub_1018F27CC();
          *(_DWORD *)(a1 + 128) |= 1u;
          *(_DWORD *)(a1 + 72) = v10;
        }
        v22 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v22 < *((_QWORD *)this + 2) && *v22 == 17)
        {
          *((_QWORD *)this + 1) = v22 + 1;
          goto LABEL_63;
        }
        continue;
      case 2u:
        v8 = TagFallback & 7;
        if (v8 != 1)
          goto LABEL_44;
LABEL_63:
        *(_QWORD *)v125 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v125) & 1) == 0)return 0;
        *(_QWORD *)(a1 + 8) = *(_QWORD *)v125;
        v13 = *(_DWORD *)(a1 + 128) | 2;
        *(_DWORD *)(a1 + 128) = v13;
        v23 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v23 >= *((_QWORD *)this + 2) || *v23 != 26)
          continue;
        *((_QWORD *)this + 1) = v23 + 1;
LABEL_67:
        *(_DWORD *)(a1 + 128) = v13 | 4;
        v24 = *(_QWORD *)(a1 + 16);
        if (!v24)
          operator new();
        v125[0] = 0;
        v25 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v25 >= *((_QWORD *)this + 2) || *v25 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v125))return 0;
        }
        else
        {
          v125[0] = *v25;
          *((_QWORD *)this + 1) = v25 + 1;
        }
        v26 = *((_DWORD *)this + 14);
        v27 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v26 + 1;
        if (v26 >= v27)
          return 0;
        v28 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v125[0]);
        if (!sub_1002CA6B8(v24, this, v29) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v28);
        v30 = *((_DWORD *)this + 14);
        v31 = __OFSUB__(v30, 1);
        v32 = v30 - 1;
        if (v32 < 0 == v31)
          *((_DWORD *)this + 14) = v32;
        v33 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v33 >= *((_QWORD *)this + 2) || *v33 != 34)
          continue;
        *((_QWORD *)this + 1) = v33 + 1;
LABEL_81:
        *(_DWORD *)(a1 + 128) |= 8u;
        v34 = *(_QWORD *)(a1 + 24);
        if (!v34)
          operator new();
        v125[0] = 0;
        v35 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v35 >= *((_QWORD *)this + 2) || *v35 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v125))return 0;
        }
        else
        {
          v125[0] = *v35;
          *((_QWORD *)this + 1) = v35 + 1;
        }
        v36 = *((_DWORD *)this + 14);
        v37 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v36 + 1;
        if (v36 >= v37)
          return 0;
        v38 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v125[0]);
        if (!sub_1002CBBCC(v34, this, v39) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v38);
        v40 = *((_DWORD *)this + 14);
        v31 = __OFSUB__(v40, 1);
        v41 = v40 - 1;
        if (v41 < 0 == v31)
          *((_DWORD *)this + 14) = v41;
        v42 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v42 >= *((_QWORD *)this + 2) || *v42 != 50)
          continue;
        *((_QWORD *)this + 1) = v42 + 1;
LABEL_95:
        *(_DWORD *)(a1 + 128) |= 0x10u;
        v43 = *(_QWORD *)(a1 + 32);
        if (!v43)
          operator new();
        v125[0] = 0;
        v44 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v44 >= *((_QWORD *)this + 2) || *v44 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v125))return 0;
        }
        else
        {
          v125[0] = *v44;
          *((_QWORD *)this + 1) = v44 + 1;
        }
        v45 = *((_DWORD *)this + 14);
        v46 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v45 + 1;
        if (v45 >= v46)
          return 0;
        v47 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v125[0]);
        if (!sub_1002CC478(v43, this, v48) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v47);
        v49 = *((_DWORD *)this + 14);
        v31 = __OFSUB__(v49, 1);
        v50 = v49 - 1;
        if (v50 < 0 == v31)
          *((_DWORD *)this + 14) = v50;
        v51 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v51 >= *((_QWORD *)this + 2) || *v51 != 58)
          continue;
        *((_QWORD *)this + 1) = v51 + 1;
LABEL_109:
        *(_DWORD *)(a1 + 128) |= 0x20u;
        v52 = *(_QWORD *)(a1 + 40);
        if (!v52)
          operator new();
        v125[0] = 0;
        v53 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v53 >= *((_QWORD *)this + 2) || *v53 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v125))return 0;
        }
        else
        {
          v125[0] = *v53;
          *((_QWORD *)this + 1) = v53 + 1;
        }
        v54 = *((_DWORD *)this + 14);
        v55 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v54 + 1;
        if (v54 >= v55)
          return 0;
        v56 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v125[0]);
        if (!sub_1002CC9B8(v52, this, v57) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v56);
        v58 = *((_DWORD *)this + 14);
        v31 = __OFSUB__(v58, 1);
        v59 = v58 - 1;
        if (v59 < 0 == v31)
          *((_DWORD *)this + 14) = v59;
        v60 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v60 >= *((_QWORD *)this + 2) || *v60 != 74)
          continue;
        *((_QWORD *)this + 1) = v60 + 1;
LABEL_123:
        *(_DWORD *)(a1 + 128) |= 0x40u;
        v61 = *(_QWORD *)(a1 + 48);
        if (!v61)
          operator new();
        v125[0] = 0;
        v62 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v62 >= *((_QWORD *)this + 2) || *v62 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v125))return 0;
        }
        else
        {
          v125[0] = *v62;
          *((_QWORD *)this + 1) = v62 + 1;
        }
        v63 = *((_DWORD *)this + 14);
        v64 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v63 + 1;
        if (v63 >= v64)
          return 0;
        v65 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v125[0]);
        if (!sub_1002CD7BC(v61, this, v66) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v65);
        v67 = *((_DWORD *)this + 14);
        v31 = __OFSUB__(v67, 1);
        v68 = v67 - 1;
        if (v68 < 0 == v31)
          *((_DWORD *)this + 14) = v68;
        v69 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v69 >= *((_QWORD *)this + 2) || *v69 != 90)
          continue;
        *((_QWORD *)this + 1) = v69 + 1;
LABEL_137:
        *(_DWORD *)(a1 + 128) |= 0x80u;
        v70 = *(_QWORD *)(a1 + 56);
        if (!v70)
          operator new();
        v125[0] = 0;
        v71 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v71 >= *((_QWORD *)this + 2) || *v71 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v125))return 0;
        }
        else
        {
          v125[0] = *v71;
          *((_QWORD *)this + 1) = v71 + 1;
        }
        v72 = *((_DWORD *)this + 14);
        v73 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v72 + 1;
        if (v72 >= v73)
          return 0;
        v74 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v125[0]);
        if (!sub_1002CE618(v70, this, v75) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v74);
        v76 = *((_DWORD *)this + 14);
        v31 = __OFSUB__(v76, 1);
        v77 = v76 - 1;
        if (v77 < 0 == v31)
          *((_DWORD *)this + 14) = v77;
        v78 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v78 >= *((_QWORD *)this + 2) || *v78 != 98)
          continue;
        *((_QWORD *)this + 1) = v78 + 1;
LABEL_151:
        *(_DWORD *)(a1 + 128) |= 0x100u;
        v79 = *(_QWORD *)(a1 + 64);
        if (!v79)
          operator new();
        v125[0] = 0;
        v80 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v80 >= *((_QWORD *)this + 2) || *v80 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v125))return 0;
        }
        else
        {
          v125[0] = *v80;
          *((_QWORD *)this + 1) = v80 + 1;
        }
        v81 = *((_DWORD *)this + 14);
        v82 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v81 + 1;
        if (v81 >= v82)
          return 0;
        v83 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v125[0]);
        if (!sub_1002CFE68(v79, this, v84) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v83);
        v85 = *((_DWORD *)this + 14);
        v31 = __OFSUB__(v85, 1);
        v86 = v85 - 1;
        if (v86 < 0 == v31)
          *((_DWORD *)this + 14) = v86;
        v87 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v87 >= *((_QWORD *)this + 2) || *v87 != 114)
          continue;
        *((_QWORD *)this + 1) = v87 + 1;
LABEL_165:
        *(_DWORD *)(a1 + 128) |= 0x200u;
        v88 = *(_QWORD *)(a1 + 80);
        if (!v88)
          operator new();
        v125[0] = 0;
        v89 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v89 >= *((_QWORD *)this + 2) || *v89 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v125))return 0;
        }
        else
        {
          v125[0] = *v89;
          *((_QWORD *)this + 1) = v89 + 1;
        }
        v90 = *((_DWORD *)this + 14);
        v91 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v90 + 1;
        if (v90 >= v91)
          return 0;
        v92 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v125[0]);
        if (!sub_1002D1690(v88, this, v93) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v92);
        v94 = *((_DWORD *)this + 14);
        v31 = __OFSUB__(v94, 1);
        v95 = v94 - 1;
        if (v95 < 0 == v31)
          *((_DWORD *)this + 14) = v95;
        v96 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v96 >= *((_QWORD *)this + 2) || *v96 != 122)
          continue;
        *((_QWORD *)this + 1) = v96 + 1;
LABEL_179:
        *(_DWORD *)(a1 + 128) |= 0x400u;
        v97 = *(_QWORD *)(a1 + 88);
        if (!v97)
          operator new();
        v125[0] = 0;
        v98 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v98 >= *((_QWORD *)this + 2) || *v98 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v125))return 0;
        }
        else
        {
          v125[0] = *v98;
          *((_QWORD *)this + 1) = v98 + 1;
        }
        v99 = *((_DWORD *)this + 14);
        v100 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v99 + 1;
        if (v99 >= v100)
          return 0;
        v101 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v125[0]);
        if (!sub_1002CB0F0(v97, this, v102) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v101);
        v103 = *((_DWORD *)this + 14);
        v31 = __OFSUB__(v103, 1);
        v104 = v103 - 1;
        if (v104 < 0 == v31)
          *((_DWORD *)this + 14) = v104;
        v105 = (unsigned __int8 *)*((_QWORD *)this + 1);
        v14 = *((_QWORD *)this + 2);
        if ((int)v14 - (int)v105 <= 1 || *v105 != 128 || v105[1] != 1)
          continue;
        v15 = v105 + 2;
        *((_QWORD *)this + 1) = v15;
LABEL_194:
        v125[0] = 0;
        if ((unint64_t)v15 >= v14 || (char)*v15 < 0)
        {
          result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v125);
          if (!(_DWORD)result)
            return result;
          v106 = v125[0];
          v107 = (unsigned __int8 *)*((_QWORD *)this + 1);
          v14 = *((_QWORD *)this + 2);
        }
        else
        {
          v106 = *v15;
          v107 = v15 + 1;
          *((_QWORD *)this + 1) = v107;
        }
        *(_BYTE *)(a1 + 76) = v106 != 0;
        v16 = *(_DWORD *)(a1 + 128) | 0x800;
        *(_DWORD *)(a1 + 128) = v16;
        if ((int)v14 - (int)v107 < 2 || *v107 != 138 || v107[1] != 1)
          continue;
        *((_QWORD *)this + 1) = v107 + 2;
LABEL_203:
        *(_DWORD *)(a1 + 128) = v16 | 0x1000;
        v108 = *(_QWORD *)(a1 + 96);
        if (!v108)
          operator new();
        v125[0] = 0;
        v109 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v109 >= *((_QWORD *)this + 2) || *v109 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v125))return 0;
        }
        else
        {
          v125[0] = *v109;
          *((_QWORD *)this + 1) = v109 + 1;
        }
        v110 = *((_DWORD *)this + 14);
        v111 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v110 + 1;
        if (v110 >= v111)
          return 0;
        v112 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v125[0]);
        if (!sub_1002CD07C(v108, this, v113) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v112);
        v114 = *((_DWORD *)this + 14);
        v31 = __OFSUB__(v114, 1);
        v115 = v114 - 1;
        if (v115 < 0 == v31)
          *((_DWORD *)this + 14) = v115;
        v116 = (unsigned __int8 *)*((_QWORD *)this + 1);
        v11 = *((_QWORD *)this + 2);
        if ((int)v11 - (int)v116 > 1 && *v116 == 144 && v116[1] == 1)
        {
          v12 = v116 + 2;
          *((_QWORD *)this + 1) = v12;
LABEL_218:
          v125[0] = 0;
          if ((unint64_t)v12 >= v11 || (char)*v12 < 0)
          {
            result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v125);
            if (!(_DWORD)result)
              return result;
            v117 = v125[0];
            v118 = (unsigned __int8 *)*((_QWORD *)this + 1);
            v11 = *((_QWORD *)this + 2);
          }
          else
          {
            v117 = *v12;
            v118 = v12 + 1;
            *((_QWORD *)this + 1) = v118;
          }
          *(_BYTE *)(a1 + 77) = v117 != 0;
          *(_DWORD *)(a1 + 128) |= 0x2000u;
          if ((int)v11 - (int)v118 >= 2 && *v118 == 152 && v118[1] == 1)
          {
            v17 = (char *)(v118 + 2);
            *((_QWORD *)this + 1) = v17;
LABEL_227:
            v125[0] = 0;
            if ((unint64_t)v17 >= v11 || *v17 < 0)
            {
              result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v125);
              if (!(_DWORD)result)
                return result;
              v119 = v125[0];
            }
            else
            {
              v119 = *v17;
              *((_QWORD *)this + 1) = v17 + 1;
            }
            if (v119 < 4 || v119 == 15)
            {
              *(_DWORD *)(a1 + 128) |= 0x4000u;
              *(_DWORD *)(a1 + 120) = v119;
            }
            v121 = (unsigned __int8 *)*((_QWORD *)this + 1);
            v18 = (unsigned __int8 *)*((_QWORD *)this + 2);
            if ((int)v18 - (int)v121 >= 2 && *v121 == 160 && v121[1] == 1)
              goto LABEL_241;
          }
        }
        continue;
      case 3u:
        v8 = TagFallback & 7;
        if (v8 != 2)
          goto LABEL_44;
        v13 = *(_DWORD *)(a1 + 128);
        goto LABEL_67;
      case 4u:
        v8 = TagFallback & 7;
        if (v8 == 2)
          goto LABEL_81;
        goto LABEL_44;
      case 6u:
        v8 = TagFallback & 7;
        if (v8 == 2)
          goto LABEL_95;
        goto LABEL_44;
      case 7u:
        v8 = TagFallback & 7;
        if (v8 == 2)
          goto LABEL_109;
        goto LABEL_44;
      case 9u:
        v8 = TagFallback & 7;
        if (v8 == 2)
          goto LABEL_123;
        goto LABEL_44;
      case 0xBu:
        v8 = TagFallback & 7;
        if (v8 == 2)
          goto LABEL_137;
        goto LABEL_44;
      case 0xCu:
        v8 = TagFallback & 7;
        if (v8 == 2)
          goto LABEL_151;
        goto LABEL_44;
      case 0xEu:
        v8 = TagFallback & 7;
        if (v8 == 2)
          goto LABEL_165;
        goto LABEL_44;
      case 0xFu:
        v8 = TagFallback & 7;
        if (v8 == 2)
          goto LABEL_179;
        goto LABEL_44;
      case 0x10u:
        v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0)
          goto LABEL_44;
        v15 = (unsigned __int8 *)*((_QWORD *)this + 1);
        v14 = *((_QWORD *)this + 2);
        goto LABEL_194;
      case 0x11u:
        v8 = TagFallback & 7;
        if (v8 != 2)
          goto LABEL_44;
        v16 = *(_DWORD *)(a1 + 128);
        goto LABEL_203;
      case 0x12u:
        v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0)
          goto LABEL_44;
        v12 = (unsigned __int8 *)*((_QWORD *)this + 1);
        v11 = *((_QWORD *)this + 2);
        goto LABEL_218;
      case 0x13u:
        v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0)
          goto LABEL_44;
        v17 = (char *)*((_QWORD *)this + 1);
        v11 = *((_QWORD *)this + 2);
        goto LABEL_227;
      case 0x14u:
        v8 = TagFallback & 7;
        if (v8 == 2)
        {
          result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadPackedEnumNoInline(this, sub_1002BC68C, v5);
          if (!(_DWORD)result)
            return result;
          while (1)
          {
            v121 = (unsigned __int8 *)*((_QWORD *)this + 1);
            v18 = (unsigned __int8 *)*((_QWORD *)this + 2);
            if ((int)v18 - (int)v121 < 2 || *v121 != 160 || v121[1] != 1)
              break;
LABEL_241:
            v19 = (char *)(v121 + 2);
            *((_QWORD *)this + 1) = v19;
LABEL_242:
            v125[0] = 0;
            if (v19 >= (char *)v18 || *v19 < 0)
            {
              result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v125);
              if (!(_DWORD)result)
                return result;
              v122 = v125[0];
            }
            else
            {
              v122 = *v19;
              *((_QWORD *)this + 1) = v19 + 1;
            }
            if (v122 <= 7)
            {
              v123 = *(_DWORD *)(a1 + 112);
              if (v123 == *(_DWORD *)(a1 + 116))
              {
                sub_1002A19E0(v5, v123 + 1);
                v123 = *(_DWORD *)(a1 + 112);
              }
              v124 = *(_QWORD *)(a1 + 104);
              *(_DWORD *)(a1 + 112) = v123 + 1;
              *(_DWORD *)(v124 + 4 * v123) = v122;
            }
          }
          if (v121 == v18 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
          {
            *((_DWORD *)this + 8) = 0;
            result = 1;
            *((_BYTE *)this + 36) = 1;
            return result;
          }
          continue;
        }
        if ((TagFallback & 7) == 0)
        {
          v19 = (char *)*((_QWORD *)this + 1);
          v18 = (unsigned __int8 *)*((_QWORD *)this + 2);
          goto LABEL_242;
        }
LABEL_44:
        if (v8 != 4)
        {
          if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, TagFallback, a3) & 1) == 0)
            return 0;
          continue;
        }
        return 1;
      default:
        v8 = TagFallback & 7;
        goto LABEL_44;
    }
  }
}

uint64_t sub_1002E0490(uint64_t result, const wireless_diagnostics::google::protobuf::MessageLite *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v5 = result;
  v6 = *(_DWORD *)(result + 128);
  if ((v6 & 1) != 0)
  {
    result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 72), (int)a2, a4);
    v6 = *(_DWORD *)(v5 + 128);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0)
        goto LABEL_4;
      goto LABEL_23;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, (int)a2, *(double *)(v5 + 8), a3);
  v6 = *(_DWORD *)(v5 + 128);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0)
      goto LABEL_5;
    goto LABEL_26;
  }
LABEL_23:
  v8 = *(_QWORD *)(v5 + 16);
  if (!v8)
    v8 = *(_QWORD *)(qword_102310400 + 16);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, v8, a2, a4);
  v6 = *(_DWORD *)(v5 + 128);
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0)
      goto LABEL_6;
    goto LABEL_29;
  }
LABEL_26:
  v9 = *(_QWORD *)(v5 + 24);
  if (!v9)
    v9 = *(_QWORD *)(qword_102310400 + 24);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, v9, a2, a4);
  v6 = *(_DWORD *)(v5 + 128);
  if ((v6 & 0x10) == 0)
  {
LABEL_6:
    if ((v6 & 0x20) == 0)
      goto LABEL_7;
    goto LABEL_32;
  }
LABEL_29:
  v10 = *(_QWORD *)(v5 + 32);
  if (!v10)
    v10 = *(_QWORD *)(qword_102310400 + 32);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, v10, a2, a4);
  v6 = *(_DWORD *)(v5 + 128);
  if ((v6 & 0x20) == 0)
  {
LABEL_7:
    if ((v6 & 0x40) == 0)
      goto LABEL_8;
    goto LABEL_35;
  }
LABEL_32:
  v11 = *(_QWORD *)(v5 + 40);
  if (!v11)
    v11 = *(_QWORD *)(qword_102310400 + 40);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)7, v11, a2, a4);
  v6 = *(_DWORD *)(v5 + 128);
  if ((v6 & 0x40) == 0)
  {
LABEL_8:
    if ((v6 & 0x80) == 0)
      goto LABEL_9;
    goto LABEL_38;
  }
LABEL_35:
  v12 = *(_QWORD *)(v5 + 48);
  if (!v12)
    v12 = *(_QWORD *)(qword_102310400 + 48);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)9, v12, a2, a4);
  v6 = *(_DWORD *)(v5 + 128);
  if ((v6 & 0x80) == 0)
  {
LABEL_9:
    if ((v6 & 0x100) == 0)
      goto LABEL_10;
    goto LABEL_41;
  }
LABEL_38:
  v13 = *(_QWORD *)(v5 + 56);
  if (!v13)
    v13 = *(_QWORD *)(qword_102310400 + 56);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xB, v13, a2, a4);
  v6 = *(_DWORD *)(v5 + 128);
  if ((v6 & 0x100) == 0)
  {
LABEL_10:
    if ((v6 & 0x200) == 0)
      goto LABEL_11;
    goto LABEL_44;
  }
LABEL_41:
  v14 = *(_QWORD *)(v5 + 64);
  if (!v14)
    v14 = *(_QWORD *)(qword_102310400 + 64);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xC, v14, a2, a4);
  v6 = *(_DWORD *)(v5 + 128);
  if ((v6 & 0x200) == 0)
  {
LABEL_11:
    if ((v6 & 0x400) == 0)
      goto LABEL_12;
    goto LABEL_47;
  }
LABEL_44:
  v15 = *(_QWORD *)(v5 + 80);
  if (!v15)
    v15 = *(_QWORD *)(qword_102310400 + 80);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xE, v15, a2, a4);
  v6 = *(_DWORD *)(v5 + 128);
  if ((v6 & 0x400) == 0)
  {
LABEL_12:
    if ((v6 & 0x800) == 0)
      goto LABEL_13;
    goto LABEL_50;
  }
LABEL_47:
  v16 = *(_QWORD *)(v5 + 88);
  if (!v16)
    v16 = *(_QWORD *)(qword_102310400 + 88);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xF, v16, a2, a4);
  v6 = *(_DWORD *)(v5 + 128);
  if ((v6 & 0x800) == 0)
  {
LABEL_13:
    if ((v6 & 0x1000) == 0)
      goto LABEL_14;
    goto LABEL_51;
  }
LABEL_50:
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x10, *(unsigned __int8 *)(v5 + 76), (BOOL)a2, a4);
  v6 = *(_DWORD *)(v5 + 128);
  if ((v6 & 0x1000) == 0)
  {
LABEL_14:
    if ((v6 & 0x2000) == 0)
      goto LABEL_15;
    goto LABEL_54;
  }
LABEL_51:
  v17 = *(_QWORD *)(v5 + 96);
  if (!v17)
    v17 = *(_QWORD *)(qword_102310400 + 96);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x11, v17, a2, a4);
  v6 = *(_DWORD *)(v5 + 128);
  if ((v6 & 0x2000) == 0)
  {
LABEL_15:
    if ((v6 & 0x4000) == 0)
      goto LABEL_17;
    goto LABEL_16;
  }
LABEL_54:
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x12, *(unsigned __int8 *)(v5 + 77), (BOOL)a2, a4);
  if ((*(_DWORD *)(v5 + 128) & 0x4000) != 0)
LABEL_16:
    result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x13, *(_DWORD *)(v5 + 120), (int)a2, a4);
LABEL_17:
  if (*(int *)(v5 + 112) >= 1)
  {
    v7 = 0;
    do
      result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x14, *(_DWORD *)(*(_QWORD *)(v5 + 104) + 4 * v7++), (int)a2, a4);
    while (v7 < *(int *)(v5 + 112));
  }
  return result;
}

uint64_t sub_1002E0730(uint64_t a1, unsigned int a2)
{
  int v3;
  int v4;
  int v5;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v6;
  int v7;
  uint64_t v8;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v9;
  int v10;
  int v11;
  uint64_t v12;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v13;
  int v14;
  int v15;
  uint64_t v16;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v17;
  int v18;
  int v19;
  uint64_t v20;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v21;
  int v22;
  int v23;
  uint64_t v24;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v25;
  int v26;
  int v27;
  uint64_t v28;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v29;
  int v30;
  int v31;
  uint64_t v32;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v33;
  int v34;
  int v35;
  uint64_t v36;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v37;
  int v38;
  int v39;
  uint64_t v40;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v41;
  int v42;
  int v43;
  uint64_t v44;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v45;
  int v46;
  int v47;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v48;
  int v49;
  int v50;
  uint64_t v51;
  int v52;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v53;
  int v54;
  uint64_t result;

  v3 = *(_DWORD *)(a1 + 128);
  if (!(_BYTE)v3)
  {
    v5 = 0;
    goto LABEL_57;
  }
  if ((v3 & 1) != 0)
  {
    v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 72);
    if ((v6 & 0x80000000) != 0)
    {
      v7 = 10;
    }
    else if (v6 >= 0x80)
    {
      v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2);
      v3 = *(_DWORD *)(a1 + 128);
    }
    else
    {
      v7 = 1;
    }
    v4 = v7 + 1;
  }
  else
  {
    v4 = 0;
  }
  if ((v3 & 2) != 0)
    v5 = v4 + 9;
  else
    v5 = v4;
  if ((v3 & 4) != 0)
  {
    v8 = *(_QWORD *)(a1 + 16);
    if (!v8)
      v8 = *(_QWORD *)(qword_102310400 + 16);
    v9 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002CAB00(v8, a2);
    v10 = (int)v9;
    if (v9 >= 0x80)
      v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v9, a2);
    else
      v11 = 1;
    v5 += v10 + v11 + 1;
    v3 = *(_DWORD *)(a1 + 128);
    if ((v3 & 8) == 0)
    {
LABEL_16:
      if ((v3 & 0x10) == 0)
        goto LABEL_17;
      goto LABEL_33;
    }
  }
  else if ((v3 & 8) == 0)
  {
    goto LABEL_16;
  }
  v12 = *(_QWORD *)(a1 + 24);
  if (!v12)
    v12 = *(_QWORD *)(qword_102310400 + 24);
  v13 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002CC024(v12, a2);
  v14 = (int)v13;
  if (v13 >= 0x80)
    v15 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v13, a2);
  else
    v15 = 1;
  v5 += v14 + v15 + 1;
  v3 = *(_DWORD *)(a1 + 128);
  if ((v3 & 0x10) == 0)
  {
LABEL_17:
    if ((v3 & 0x20) == 0)
      goto LABEL_18;
    goto LABEL_39;
  }
LABEL_33:
  v16 = *(_QWORD *)(a1 + 32);
  if (!v16)
    v16 = *(_QWORD *)(qword_102310400 + 32);
  v17 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002CC6D8(v16, a2);
  v18 = (int)v17;
  if (v17 >= 0x80)
    v19 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v17, a2);
  else
    v19 = 1;
  v5 += v18 + v19 + 1;
  v3 = *(_DWORD *)(a1 + 128);
  if ((v3 & 0x20) == 0)
  {
LABEL_18:
    if ((v3 & 0x40) == 0)
      goto LABEL_19;
    goto LABEL_45;
  }
LABEL_39:
  v20 = *(_QWORD *)(a1 + 40);
  if (!v20)
    v20 = *(_QWORD *)(qword_102310400 + 40);
  v21 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002CCB38(v20, a2);
  v22 = (int)v21;
  if (v21 >= 0x80)
    v23 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v21, a2);
  else
    v23 = 1;
  v5 += v22 + v23 + 1;
  v3 = *(_DWORD *)(a1 + 128);
  if ((v3 & 0x40) == 0)
  {
LABEL_19:
    if ((v3 & 0x80) == 0)
      goto LABEL_57;
    goto LABEL_51;
  }
LABEL_45:
  v24 = *(_QWORD *)(a1 + 48);
  if (!v24)
    v24 = *(_QWORD *)(qword_102310400 + 48);
  v25 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002CD93C(v24, a2);
  v26 = (int)v25;
  if (v25 >= 0x80)
    v27 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v25, a2);
  else
    v27 = 1;
  v5 += v26 + v27 + 1;
  v3 = *(_DWORD *)(a1 + 128);
  if ((v3 & 0x80) != 0)
  {
LABEL_51:
    v28 = *(_QWORD *)(a1 + 56);
    if (!v28)
      v28 = *(_QWORD *)(qword_102310400 + 56);
    v29 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002CF050(v28, a2);
    v30 = (int)v29;
    if (v29 >= 0x80)
      v31 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v29, a2);
    else
      v31 = 1;
    v5 += v30 + v31 + 1;
    v3 = *(_DWORD *)(a1 + 128);
  }
LABEL_57:
  if ((v3 & 0xFF00) == 0)
    goto LABEL_98;
  if ((v3 & 0x100) == 0)
  {
    if ((v3 & 0x200) == 0)
      goto LABEL_60;
LABEL_68:
    v36 = *(_QWORD *)(a1 + 80);
    if (!v36)
      v36 = *(_QWORD *)(qword_102310400 + 80);
    v37 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002D1D24(v36, a2);
    v38 = (int)v37;
    if (v37 >= 0x80)
      v39 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v37, a2);
    else
      v39 = 1;
    v5 += v38 + v39 + 1;
    v3 = *(_DWORD *)(a1 + 128);
    if ((v3 & 0x400) == 0)
      goto LABEL_80;
    goto LABEL_74;
  }
  v32 = *(_QWORD *)(a1 + 64);
  if (!v32)
    v32 = *(_QWORD *)(qword_102310400 + 64);
  v33 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002D0640(v32, a2);
  v34 = (int)v33;
  if (v33 >= 0x80)
    v35 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v33, a2);
  else
    v35 = 1;
  v5 += v34 + v35 + 1;
  v3 = *(_DWORD *)(a1 + 128);
  if ((v3 & 0x200) != 0)
    goto LABEL_68;
LABEL_60:
  if ((v3 & 0x400) != 0)
  {
LABEL_74:
    v40 = *(_QWORD *)(a1 + 88);
    if (!v40)
      v40 = *(_QWORD *)(qword_102310400 + 88);
    v41 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002CB538(v40, a2);
    v42 = (int)v41;
    if (v41 >= 0x80)
      v43 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v41, a2);
    else
      v43 = 1;
    v5 += v42 + v43 + 1;
    v3 = *(_DWORD *)(a1 + 128);
  }
LABEL_80:
  if ((v3 & 0x800) != 0)
    v5 += 3;
  if ((v3 & 0x1000) != 0)
  {
    v44 = *(_QWORD *)(a1 + 96);
    if (!v44)
      v44 = *(_QWORD *)(qword_102310400 + 96);
    v45 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002CD424(v44, a2);
    v46 = (int)v45;
    if (v45 >= 0x80)
      v47 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v45, a2);
    else
      v47 = 1;
    v5 += v46 + v47 + 2;
    v3 = *(_DWORD *)(a1 + 128);
  }
  if ((v3 & 0x2000) != 0)
    v5 += 3;
  if ((v3 & 0x4000) != 0)
  {
    v48 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 120);
    if ((v48 & 0x80000000) != 0)
    {
      v49 = 12;
    }
    else if (v48 >= 0x80)
    {
      v49 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v48, a2) + 2;
    }
    else
    {
      v49 = 3;
    }
    v5 += v49;
  }
LABEL_98:
  v50 = *(_DWORD *)(a1 + 112);
  if (v50 < 1)
  {
    v52 = 0;
  }
  else
  {
    v51 = 0;
    v52 = 0;
    do
    {
      v53 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(*(_QWORD *)(a1 + 104)
                                                                                             + 4 * v51);
      if ((v53 & 0x80000000) != 0)
      {
        v54 = 10;
      }
      else if (v53 >= 0x80)
      {
        v54 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v53, a2);
        v50 = *(_DWORD *)(a1 + 112);
      }
      else
      {
        v54 = 1;
      }
      v52 += v54;
      ++v51;
    }
    while (v51 < v50);
  }
  result = (v52 + v5 + 2 * v50);
  *(_DWORD *)(a1 + 124) = result;
  return result;
}

void sub_1002E0B54(uint64_t a1, void *lpsrc)
{
  uint64_t v4;
  uint64_t v5;

  sub_1002DEB08(a1, (uint64_t)lpsrc);
}

void sub_1002E0BA0(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
    sub_1002DEB08(a1, a2);
  }
}

uint64_t sub_1002E0BE0()
{
  return 1;
}

_QWORD *sub_1002E0BE8@<X0>(_QWORD *a1@<X8>)
{
  return sub_1015A2E04(a1, "CLMicroLocationProto.RecordingEvent");
}

uint64_t sub_1002E0BF8(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 24) = 48;
  *(_QWORD *)a1 = off_10212D670;
  *(_QWORD *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 28) = 0;
  *(_QWORD *)(a1 + 16) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *(_QWORD *)(a1 + 32) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *(_QWORD *)(a1 + 40) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *(_QWORD *)(a1 + 48) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 64) = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  *(_DWORD *)(a1 + 80) = 0;
  sub_1002DE1B8(a1, a2);
  return a1;
}

void sub_1002E0C5C(_Unwind_Exception *a1)
{
  wireless_diagnostics::google::protobuf::MessageLite *v1;

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1002E0C74(_QWORD *result)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v5;
  uint64_t v7;
  uint64_t v9;

  v1 = result[2];
  if ((_UNKNOWN *)v1 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v1 != 0)
  {
    if (*(char *)(v1 + 23) < 0)
      operator delete(*(void **)v1);
    operator delete();
  }
  v3 = result[4];
  if ((_UNKNOWN *)v3 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v3 != 0)
  {
    if (*(char *)(v3 + 23) < 0)
      operator delete(*(void **)v3);
    operator delete();
  }
  v5 = result[5];
  if ((_UNKNOWN *)v5 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v5 != 0)
  {
    if (*(char *)(v5 + 23) < 0)
      operator delete(*(void **)v5);
    operator delete();
  }
  v7 = result[6];
  if ((_UNKNOWN *)v7 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v7 != 0)
  {
    if (*(char *)(v7 + 23) < 0)
      operator delete(*(void **)v7);
    operator delete();
  }
  v9 = result[8];
  if ((_UNKNOWN *)v9 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v9)
  {
    if (*(char *)(v9 + 23) < 0)
      operator delete(*(void **)v9);
    operator delete();
  }
  return result;
}

void sub_1002E0DC4(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(_QWORD *)a1 = off_10212D670;
  sub_1002E0C74(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_1002E0DF4(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(_QWORD *)a1 = off_10212D670;
  sub_1002E0C74(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete();
}

void sub_1002E0E38()
{
  operator new();
}

uint64_t sub_1002E0EA0(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  char *v5;
  wireless_diagnostics::google::protobuf::io::CodedInputStream *TagFallback;
  int v7;
  char *v8;
  unsigned int v9;
  unint64_t v10;
  char *v11;
  int v12;
  unint64_t v13;
  char *v14;
  unint64_t v15;
  char *v16;
  char *v17;
  unint64_t v18;
  char *v19;
  uint64_t result;
  BOOL v21;
  _BYTE *v22;
  _BYTE *v23;
  unsigned int v24;
  _BYTE *v25;
  void *v26;
  _BYTE *v27;
  void *v28;
  _BYTE *v29;
  void *v30;
  _BYTE *v31;
  void *v32;
  _BYTE *v33;
  unsigned int v34;
  _BYTE *v35;
  unsigned int v36;
  _BYTE *v37;
  unsigned int v38;
  _BYTE *v39;
  unsigned int v40;
  _BYTE *v41;
  void *v42;
  unsigned int v43[2];

  while (2)
  {
    v5 = (char *)*((_QWORD *)this + 1);
    if ((unint64_t)v5 >= *((_QWORD *)this + 2) || *v5 < 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      if (!(_DWORD)TagFallback)
        return 1;
    }
    else
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((_QWORD *)this + 1) = v5 + 1;
      if (!(_DWORD)TagFallback)
        return 1;
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0)
          goto LABEL_34;
        v43[0] = 0;
        v8 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v8 < *((_QWORD *)this + 2) && (*v8 & 0x80000000) == 0)
        {
          v9 = *v8;
          *((_QWORD *)this + 1) = v8 + 1;
LABEL_39:
          if (v9 - 31 < 0x19 || (v9 <= 0xE ? (v21 = ((1 << v9) & 0x76B6) == 0) : (v21 = 1), !v21))
          {
            if (v9 - 31 >= 0x19 && (v9 > 0xE || ((1 << v9) & 0x76B6) == 0))
              sub_1018F268C();
            *(_DWORD *)(a1 + 80) |= 1u;
            *(_DWORD *)(a1 + 24) = v9;
          }
          v22 = (_BYTE *)*((_QWORD *)this + 1);
          if ((unint64_t)v22 < *((_QWORD *)this + 2) && *v22 == 17)
          {
            *((_QWORD *)this + 1) = v22 + 1;
            goto LABEL_51;
          }
          continue;
        }
        result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v43);
        if ((_DWORD)result)
        {
          v9 = v43[0];
          goto LABEL_39;
        }
        break;
      case 2u:
        v7 = TagFallback & 7;
        if (v7 != 1)
          goto LABEL_34;
LABEL_51:
        *(_QWORD *)v43 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v43) & 1) == 0)return 0;
        *(_QWORD *)(a1 + 8) = *(_QWORD *)v43;
        *(_DWORD *)(a1 + 80) |= 2u;
        v23 = (_BYTE *)*((_QWORD *)this + 1);
        v10 = *((_QWORD *)this + 2);
        if ((unint64_t)v23 >= v10 || *v23 != 24)
          continue;
        v11 = v23 + 1;
        *((_QWORD *)this + 1) = v11;
LABEL_55:
        v43[0] = 0;
        if ((unint64_t)v11 >= v10 || *v11 < 0)
        {
          result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v43);
          if (!(_DWORD)result)
            return result;
          v24 = v43[0];
          v25 = (_BYTE *)*((_QWORD *)this + 1);
          v10 = *((_QWORD *)this + 2);
        }
        else
        {
          v24 = *v11;
          v25 = v11 + 1;
          *((_QWORD *)this + 1) = v25;
        }
        *(_BYTE *)(a1 + 28) = v24 != 0;
        v12 = *(_DWORD *)(a1 + 80) | 4;
        *(_DWORD *)(a1 + 80) = v12;
        if ((unint64_t)v25 >= v10 || *v25 != 34)
          continue;
        *((_QWORD *)this + 1) = v25 + 1;
LABEL_63:
        *(_DWORD *)(a1 + 80) = v12 | 8;
        v26 = *(void **)(a1 + 16);
        if (v26 == &wireless_diagnostics::google::protobuf::internal::kEmptyString)
          operator new();
        result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString(this, v26);
        if (!(_DWORD)result)
          return result;
        v27 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v27 >= *((_QWORD *)this + 2) || *v27 != 42)
          continue;
        *((_QWORD *)this + 1) = v27 + 1;
LABEL_69:
        *(_DWORD *)(a1 + 80) |= 0x10u;
        v28 = *(void **)(a1 + 32);
        if (v28 == &wireless_diagnostics::google::protobuf::internal::kEmptyString)
          operator new();
        result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString(this, v28);
        if (!(_DWORD)result)
          return result;
        v29 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v29 >= *((_QWORD *)this + 2) || *v29 != 50)
          continue;
        *((_QWORD *)this + 1) = v29 + 1;
LABEL_75:
        *(_DWORD *)(a1 + 80) |= 0x20u;
        v30 = *(void **)(a1 + 40);
        if (v30 == &wireless_diagnostics::google::protobuf::internal::kEmptyString)
          operator new();
        result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString(this, v30);
        if (!(_DWORD)result)
          return result;
        v31 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v31 >= *((_QWORD *)this + 2) || *v31 != 58)
          continue;
        *((_QWORD *)this + 1) = v31 + 1;
LABEL_81:
        *(_DWORD *)(a1 + 80) |= 0x40u;
        v32 = *(void **)(a1 + 48);
        if (v32 == &wireless_diagnostics::google::protobuf::internal::kEmptyString)
          operator new();
        result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes(this, v32);
        if (!(_DWORD)result)
          return result;
        v33 = (_BYTE *)*((_QWORD *)this + 1);
        v15 = *((_QWORD *)this + 2);
        if ((unint64_t)v33 >= v15 || *v33 != 64)
          continue;
        v16 = v33 + 1;
        *((_QWORD *)this + 1) = v16;
LABEL_87:
        v43[0] = 0;
        if ((unint64_t)v16 >= v15 || *v16 < 0)
        {
          result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v43);
          if (!(_DWORD)result)
            return result;
          v34 = v43[0];
          v35 = (_BYTE *)*((_QWORD *)this + 1);
          v15 = *((_QWORD *)this + 2);
        }
        else
        {
          v34 = *v16;
          v35 = v16 + 1;
          *((_QWORD *)this + 1) = v35;
        }
        *(_BYTE *)(a1 + 29) = v34 != 0;
        *(_DWORD *)(a1 + 80) |= 0x80u;
        if ((unint64_t)v35 >= v15 || *v35 != 72)
          continue;
        v17 = v35 + 1;
        *((_QWORD *)this + 1) = v17;
LABEL_95:
        v43[0] = 0;
        if ((unint64_t)v17 >= v15 || *v17 < 0)
        {
          result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v43);
          if (!(_DWORD)result)
            return result;
          v36 = v43[0];
        }
        else
        {
          v36 = *v17;
          *((_QWORD *)this + 1) = v17 + 1;
        }
        if (v36 <= 1)
        {
          *(_DWORD *)(a1 + 80) |= 0x100u;
          *(_DWORD *)(a1 + 56) = v36;
        }
        v37 = (_BYTE *)*((_QWORD *)this + 1);
        v13 = *((_QWORD *)this + 2);
        if ((unint64_t)v37 >= v13 || *v37 != 80)
          continue;
        v14 = v37 + 1;
        *((_QWORD *)this + 1) = v14;
LABEL_105:
        v43[0] = 0;
        if ((unint64_t)v14 >= v13 || *v14 < 0)
        {
          result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v43);
          if (!(_DWORD)result)
            return result;
          v38 = v43[0];
        }
        else
        {
          v38 = *v14;
          *((_QWORD *)this + 1) = v14 + 1;
        }
        if (v38 <= 5)
        {
          *(_DWORD *)(a1 + 80) |= 0x200u;
          *(_DWORD *)(a1 + 60) = v38;
        }
        v39 = (_BYTE *)*((_QWORD *)this + 1);
        v18 = *((_QWORD *)this + 2);
        if ((unint64_t)v39 >= v18 || *v39 != 88)
          continue;
        v19 = v39 + 1;
        *((_QWORD *)this + 1) = v19;
LABEL_115:
        v43[0] = 0;
        if ((unint64_t)v19 >= v18 || *v19 < 0)
        {
          result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v43);
          if (!(_DWORD)result)
            return result;
          v40 = v43[0];
        }
        else
        {
          v40 = *v19;
          *((_QWORD *)this + 1) = v19 + 1;
        }
        if (v40 <= 5)
        {
          *(_DWORD *)(a1 + 80) |= 0x400u;
          *(_DWORD *)(a1 + 72) = v40;
        }
        v41 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v41 >= *((_QWORD *)this + 2) || *v41 != 98)
          continue;
        *((_QWORD *)this + 1) = v41 + 1;
LABEL_125:
        *(_DWORD *)(a1 + 80) |= 0x800u;
        v42 = *(void **)(a1 + 64);
        if (v42 == &wireless_diagnostics::google::protobuf::internal::kEmptyString)
          operator new();
        result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes(this, v42);
        if (!(_DWORD)result)
          return result;
        if (*((_QWORD *)this + 1) != *((_QWORD *)this + 2)
          || !*((_DWORD *)this + 11) && *((_DWORD *)this + 6) != *((_DWORD *)this + 10))
        {
          continue;
        }
        *((_DWORD *)this + 8) = 0;
        result = 1;
        *((_BYTE *)this + 36) = 1;
        return result;
      case 3u:
        v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0)
          goto LABEL_34;
        v11 = (char *)*((_QWORD *)this + 1);
        v10 = *((_QWORD *)this + 2);
        goto LABEL_55;
      case 4u:
        v7 = TagFallback & 7;
        if (v7 != 2)
          goto LABEL_34;
        v12 = *(_DWORD *)(a1 + 80);
        goto LABEL_63;
      case 5u:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_69;
        goto LABEL_34;
      case 6u:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_75;
        goto LABEL_34;
      case 7u:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_81;
        goto LABEL_34;
      case 8u:
        v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0)
          goto LABEL_34;
        v16 = (char *)*((_QWORD *)this + 1);
        v15 = *((_QWORD *)this + 2);
        goto LABEL_87;
      case 9u:
        v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0)
          goto LABEL_34;
        v17 = (char *)*((_QWORD *)this + 1);
        v15 = *((_QWORD *)this + 2);
        goto LABEL_95;
      case 0xAu:
        v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0)
          goto LABEL_34;
        v14 = (char *)*((_QWORD *)this + 1);
        v13 = *((_QWORD *)this + 2);
        goto LABEL_105;
      case 0xBu:
        v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0)
          goto LABEL_34;
        v19 = (char *)*((_QWORD *)this + 1);
        v18 = *((_QWORD *)this + 2);
        goto LABEL_115;
      case 0xCu:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_125;
        goto LABEL_34;
      default:
        v7 = TagFallback & 7;
LABEL_34:
        if (v7 == 4)
          return 1;
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, TagFallback, a3) & 1) != 0)
          continue;
        return 0;
    }
    return result;
  }
}

uint64_t sub_1002E1584(uint64_t result, uint64_t a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5;
  int v6;

  v5 = result;
  v6 = *(_DWORD *)(result + 80);
  if ((v6 & 1) != 0)
  {
    result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 24), a2, a4);
    v6 = *(_DWORD *)(v5 + 80);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0)
        goto LABEL_4;
      goto LABEL_16;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, a2, *(double *)(v5 + 8), a3);
  v6 = *(_DWORD *)(v5 + 80);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0)
      goto LABEL_5;
    goto LABEL_17;
  }
LABEL_16:
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, *(unsigned __int8 *)(v5 + 28), a2, a4);
  v6 = *(_DWORD *)(v5 + 80);
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0)
      goto LABEL_6;
    goto LABEL_18;
  }
LABEL_17:
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString(4, *(_QWORD *)(v5 + 16), a2);
  v6 = *(_DWORD *)(v5 + 80);
  if ((v6 & 0x10) == 0)
  {
LABEL_6:
    if ((v6 & 0x20) == 0)
      goto LABEL_7;
    goto LABEL_19;
  }
LABEL_18:
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString(5, *(_QWORD *)(v5 + 32), a2);
  v6 = *(_DWORD *)(v5 + 80);
  if ((v6 & 0x20) == 0)
  {
LABEL_7:
    if ((v6 & 0x40) == 0)
      goto LABEL_8;
    goto LABEL_20;
  }
LABEL_19:
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString(6, *(_QWORD *)(v5 + 40), a2);
  v6 = *(_DWORD *)(v5 + 80);
  if ((v6 & 0x40) == 0)
  {
LABEL_8:
    if ((v6 & 0x80) == 0)
      goto LABEL_9;
    goto LABEL_21;
  }
LABEL_20:
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes(7, *(_QWORD *)(v5 + 48), a2);
  v6 = *(_DWORD *)(v5 + 80);
  if ((v6 & 0x80) == 0)
  {
LABEL_9:
    if ((v6 & 0x100) == 0)
      goto LABEL_10;
    goto LABEL_22;
  }
LABEL_21:
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)8, *(unsigned __int8 *)(v5 + 29), a2, a4);
  v6 = *(_DWORD *)(v5 + 80);
  if ((v6 & 0x100) == 0)
  {
LABEL_10:
    if ((v6 & 0x200) == 0)
      goto LABEL_11;
    goto LABEL_23;
  }
LABEL_22:
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)9, *(_DWORD *)(v5 + 56), a2, a4);
  v6 = *(_DWORD *)(v5 + 80);
  if ((v6 & 0x200) == 0)
  {
LABEL_11:
    if ((v6 & 0x400) == 0)
      goto LABEL_12;
    goto LABEL_24;
  }
LABEL_23:
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xA, *(_DWORD *)(v5 + 60), a2, a4);
  v6 = *(_DWORD *)(v5 + 80);
  if ((v6 & 0x400) == 0)
  {
LABEL_12:
    if ((v6 & 0x800) == 0)
      return result;
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes(12, *(_QWORD *)(v5 + 64), a2);
  }
LABEL_24:
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xB, *(_DWORD *)(v5 + 72), a2, a4);
  if ((*(_DWORD *)(v5 + 80) & 0x800) != 0)
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes(12, *(_QWORD *)(v5 + 64), a2);
  return result;
}

uint64_t sub_1002E16F8(uint64_t a1, unsigned int a2)
{
  int v3;
  int v4;
  uint64_t v5;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v6;
  int v7;
  uint64_t v8;
  int v9;
  char v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  char v16;
  uint64_t v17;
  unint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  char v22;
  uint64_t v23;
  unint64_t v24;
  int v25;
  uint64_t v26;
  int v27;
  char v28;
  uint64_t v29;
  unint64_t v30;
  int v31;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v32;
  int v33;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v34;
  int v35;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v36;
  int v37;
  uint64_t v38;
  int v39;
  char v40;
  uint64_t v41;
  unint64_t v42;
  int v43;

  v3 = *(_DWORD *)(a1 + 80);
  if (!(_BYTE)v3)
  {
    v5 = 0;
    goto LABEL_60;
  }
  if ((v3 & 1) != 0)
  {
    v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 24);
    if ((v6 & 0x80000000) != 0)
    {
      v7 = 10;
    }
    else if (v6 >= 0x80)
    {
      v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2);
      v3 = *(_DWORD *)(a1 + 80);
    }
    else
    {
      v7 = 1;
    }
    v4 = v7 + 1;
  }
  else
  {
    v4 = 0;
  }
  if ((v3 & 2) != 0)
    v4 += 9;
  if ((v3 & 4) != 0)
    LODWORD(v5) = v4 + 2;
  else
    LODWORD(v5) = v4;
  if ((v3 & 8) != 0)
  {
    v8 = *(_QWORD *)(a1 + 16);
    v9 = *(unsigned __int8 *)(v8 + 23);
    v10 = v9;
    v11 = *(_QWORD *)(v8 + 8);
    if ((v9 & 0x80u) == 0)
      v12 = *(unsigned __int8 *)(v8 + 23);
    else
      v12 = v11;
    if (v12 >= 0x80)
    {
      v13 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v12, a2);
      v9 = *(unsigned __int8 *)(v8 + 23);
      v11 = *(_QWORD *)(v8 + 8);
      v3 = *(_DWORD *)(a1 + 80);
      v10 = *(_BYTE *)(v8 + 23);
    }
    else
    {
      v13 = 1;
    }
    if (v10 < 0)
      v9 = v11;
    LODWORD(v5) = v5 + v13 + v9 + 1;
    if ((v3 & 0x10) == 0)
    {
LABEL_18:
      if ((v3 & 0x20) == 0)
        goto LABEL_19;
LABEL_39:
      v20 = *(_QWORD *)(a1 + 40);
      v21 = *(unsigned __int8 *)(v20 + 23);
      v22 = v21;
      v23 = *(_QWORD *)(v20 + 8);
      if ((v21 & 0x80u) == 0)
        v24 = *(unsigned __int8 *)(v20 + 23);
      else
        v24 = v23;
      if (v24 >= 0x80)
      {
        v25 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v24, a2);
        v21 = *(unsigned __int8 *)(v20 + 23);
        v23 = *(_QWORD *)(v20 + 8);
        v3 = *(_DWORD *)(a1 + 80);
        v22 = *(_BYTE *)(v20 + 23);
      }
      else
      {
        v25 = 1;
      }
      if (v22 < 0)
        v21 = v23;
      LODWORD(v5) = v5 + v25 + v21 + 1;
      if ((v3 & 0x40) == 0)
        goto LABEL_57;
      goto LABEL_48;
    }
  }
  else if ((v3 & 0x10) == 0)
  {
    goto LABEL_18;
  }
  v14 = *(_QWORD *)(a1 + 32);
  v15 = *(unsigned __int8 *)(v14 + 23);
  v16 = v15;
  v17 = *(_QWORD *)(v14 + 8);
  if ((v15 & 0x80u) == 0)
    v18 = *(unsigned __int8 *)(v14 + 23);
  else
    v18 = v17;
  if (v18 >= 0x80)
  {
    v19 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v18, a2);
    v15 = *(unsigned __int8 *)(v14 + 23);
    v17 = *(_QWORD *)(v14 + 8);
    v3 = *(_DWORD *)(a1 + 80);
    v16 = *(_BYTE *)(v14 + 23);
  }
  else
  {
    v19 = 1;
  }
  if (v16 < 0)
    v15 = v17;
  LODWORD(v5) = v5 + v19 + v15 + 1;
  if ((v3 & 0x20) != 0)
    goto LABEL_39;
LABEL_19:
  if ((v3 & 0x40) != 0)
  {
LABEL_48:
    v26 = *(_QWORD *)(a1 + 48);
    v27 = *(unsigned __int8 *)(v26 + 23);
    v28 = v27;
    v29 = *(_QWORD *)(v26 + 8);
    if ((v27 & 0x80u) == 0)
      v30 = *(unsigned __int8 *)(v26 + 23);
    else
      v30 = v29;
    if (v30 >= 0x80)
    {
      v31 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v30, a2);
      v27 = *(unsigned __int8 *)(v26 + 23);
      v29 = *(_QWORD *)(v26 + 8);
      v3 = *(_DWORD *)(a1 + 80);
      v28 = *(_BYTE *)(v26 + 23);
    }
    else
    {
      v31 = 1;
    }
    if (v28 < 0)
      v27 = v29;
    LODWORD(v5) = v5 + v31 + v27 + 1;
  }
LABEL_57:
  if ((v3 & 0x80) != 0)
    v5 = (v5 + 2);
  else
    v5 = v5;
LABEL_60:
  if ((v3 & 0xFF00) == 0)
    goto LABEL_93;
  if ((v3 & 0x100) != 0)
  {
    v32 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 56);
    if ((v32 & 0x80000000) != 0)
    {
      v33 = 11;
    }
    else if (v32 >= 0x80)
    {
      v33 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v32, a2) + 1;
      v3 = *(_DWORD *)(a1 + 80);
    }
    else
    {
      v33 = 2;
    }
    v5 = (v33 + v5);
    if ((v3 & 0x200) == 0)
    {
LABEL_63:
      if ((v3 & 0x400) == 0)
        goto LABEL_64;
      goto LABEL_78;
    }
  }
  else if ((v3 & 0x200) == 0)
  {
    goto LABEL_63;
  }
  v34 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 60);
  if ((v34 & 0x80000000) != 0)
  {
    v35 = 11;
  }
  else if (v34 >= 0x80)
  {
    v35 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v34, a2) + 1;
    v3 = *(_DWORD *)(a1 + 80);
  }
  else
  {
    v35 = 2;
  }
  v5 = (v35 + v5);
  if ((v3 & 0x400) == 0)
  {
LABEL_64:
    if ((v3 & 0x800) == 0)
      goto LABEL_93;
    goto LABEL_84;
  }
LABEL_78:
  v36 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 72);
  if ((v36 & 0x80000000) != 0)
  {
    v37 = 11;
  }
  else if (v36 >= 0x80)
  {
    v37 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v36, a2) + 1;
    v3 = *(_DWORD *)(a1 + 80);
  }
  else
  {
    v37 = 2;
  }
  v5 = (v37 + v5);
  if ((v3 & 0x800) != 0)
  {
LABEL_84:
    v38 = *(_QWORD *)(a1 + 64);
    v39 = *(unsigned __int8 *)(v38 + 23);
    v40 = v39;
    v41 = *(_QWORD *)(v38 + 8);
    if ((v39 & 0x80u) == 0)
      v42 = *(unsigned __int8 *)(v38 + 23);
    else
      v42 = v41;
    if (v42 >= 0x80)
    {
      v43 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v42, a2);
      v39 = *(unsigned __int8 *)(v38 + 23);
      v41 = *(_QWORD *)(v38 + 8);
      v40 = *(_BYTE *)(v38 + 23);
    }
    else
    {
      v43 = 1;
    }
    if (v40 < 0)
      v39 = v41;
    v5 = (v5 + v43 + v39 + 1);
  }
LABEL_93:
  *(_DWORD *)(a1 + 76) = v5;
  return v5;
}

void sub_1002E1A0C(uint64_t a1, void *lpsrc)
{
  uint64_t v4;
  uint64_t v5;

  sub_1002DE1B8(a1, (uint64_t)lpsrc);
}

void sub_1002E1A58(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
    sub_1002DE1B8(a1, a2);
  }
}

uint64_t sub_1002E1A98()
{
  return 1;
}

_QWORD *sub_1002E1AA0@<X0>(_QWORD *a1@<X8>)
{
  return sub_1015A2E04(a1, "CLMicroLocationProto.TriggerEvent");
}

void sub_1002E1AB0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(_QWORD *)a1 = off_10212D6E8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_1002E1AC0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(_QWORD *)a1 = off_10212D6E8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete();
}

void sub_1002E1AF0()
{
  operator new();
}

uint64_t sub_1002E1B30(_DWORD *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  char *v5;
  wireless_diagnostics::google::protobuf::io::CodedInputStream *TagFallback;
  int v7;
  unint64_t v8;
  char *v9;
  char *v10;
  unsigned int v11;
  BOOL v12;
  _BYTE *v14;
  unsigned int v15;
  uint64_t result;
  unsigned int v17;
  unsigned int v18;

  while (1)
  {
    while (1)
    {
      v5 = (char *)*((_QWORD *)this + 1);
      if ((unint64_t)v5 >= *((_QWORD *)this + 2) || *v5 < 0)
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        if (!(_DWORD)TagFallback)
          return 1;
      }
      else
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        *((_QWORD *)this + 1) = v5 + 1;
        if (!(_DWORD)TagFallback)
          return 1;
      }
      if (TagFallback >> 3 != 1)
        break;
      v7 = TagFallback & 7;
      if ((TagFallback & 7) != 0)
        goto LABEL_15;
      v18 = 0;
      v10 = (char *)*((_QWORD *)this + 1);
      if ((unint64_t)v10 >= *((_QWORD *)this + 2) || *v10 < 0)
      {
        result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v18);
        if (!(_DWORD)result)
          return result;
        v11 = v18;
      }
      else
      {
        v11 = *v10;
        *((_QWORD *)this + 1) = v10 + 1;
      }
      if (v11 - 31 < 0x19 || (v11 <= 0xE ? (v12 = ((1 << v11) & 0x76B6) == 0) : (v12 = 1), !v12))
      {
        if (v11 - 31 >= 0x19 && (v11 > 0xE || ((1 << v11) & 0x76B6) == 0))
          sub_1018F26DC();
        a1[5] |= 1u;
        a1[2] = v11;
      }
      v14 = (_BYTE *)*((_QWORD *)this + 1);
      v8 = *((_QWORD *)this + 2);
      if ((unint64_t)v14 < v8 && *v14 == 16)
      {
        v9 = v14 + 1;
        *((_QWORD *)this + 1) = v9;
LABEL_34:
        v17 = 0;
        if ((unint64_t)v9 >= v8 || *v9 < 0)
        {
          result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v17);
          if (!(_DWORD)result)
            return result;
          v15 = v17;
        }
        else
        {
          v15 = *v9;
          *((_QWORD *)this + 1) = v9 + 1;
        }
        if (v15 - 1 < 2 || v15 == 255)
        {
          a1[5] |= 2u;
          a1[3] = v15;
        }
        if (*((_QWORD *)this + 1) == *((_QWORD *)this + 2)
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          result = 1;
          *((_BYTE *)this + 36) = 1;
          return result;
        }
      }
    }
    if (TagFallback >> 3 == 2)
    {
      v7 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        v9 = (char *)*((_QWORD *)this + 1);
        v8 = *((_QWORD *)this + 2);
        goto LABEL_34;
      }
    }
    else
    {
      v7 = TagFallback & 7;
    }
LABEL_15:
    if (v7 == 4)
      return 1;
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, TagFallback, a3) & 1) == 0)
      return 0;
  }
}

uint64_t sub_1002E1D38(uint64_t result, int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5;
  int v6;

  v5 = result;
  v6 = *(_DWORD *)(result + 20);
  if ((v6 & 1) != 0)
  {
    result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 8), a2, a4);
    v6 = *(_DWORD *)(v5 + 20);
  }
  if ((v6 & 2) != 0)
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(_DWORD *)(v5 + 12), a2, a4);
  return result;
}

uint64_t sub_1002E1D90(uint64_t a1, unsigned int a2)
{
  char v3;
  uint64_t v4;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v5;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v6;
  int v7;

  v3 = *(_BYTE *)(a1 + 20);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 20) & 1) != 0)
    {
      v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
      if ((v5 & 0x80000000) != 0)
      {
        v4 = 11;
        if ((v3 & 2) == 0)
          goto LABEL_19;
      }
      else if (v5 >= 0x80)
      {
        v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2)
           + 1;
        if ((*(_DWORD *)(a1 + 20) & 2) == 0)
          goto LABEL_19;
      }
      else
      {
        v4 = 2;
        if ((v3 & 2) == 0)
          goto LABEL_19;
      }
    }
    else
    {
      v4 = 0;
      if ((*(_BYTE *)(a1 + 20) & 2) == 0)
        goto LABEL_19;
    }
    v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 12);
    if ((v6 & 0x80000000) != 0)
    {
      v7 = 11;
    }
    else if (v6 >= 0x80)
    {
      v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 1;
    }
    else
    {
      v7 = 2;
    }
    v4 = (v7 + v4);
  }
  else
  {
    v4 = 0;
  }
LABEL_19:
  *(_DWORD *)(a1 + 16) = v4;
  return v4;
}

void sub_1002E1E38(_DWORD *a1, void *lpsrc)
{
  uint64_t v4;
  uint64_t v5;

  sub_1002DE53C(a1, (uint64_t)lpsrc);
}

void sub_1002E1E84(_DWORD *a1, uint64_t a2)
{
  if ((_DWORD *)a2 != a1)
  {
    (*(void (**)(_DWORD *))(*(_QWORD *)a1 + 32))(a1);
    sub_1002DE53C(a1, a2);
  }
}

uint64_t sub_1002E1EC4()
{
  return 1;
}

_QWORD *sub_1002E1ECC@<X0>(_QWORD *a1@<X8>)
{
  return sub_1015A2E04(a1, "CLMicroLocationProto.LegacyClientStatusUpdate");
}

void sub_1002E1EDC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(_QWORD *)a1 = off_10212D760;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_1002E1EEC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(_QWORD *)a1 = off_10212D760;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete();
}

void sub_1002E1F1C()
{
  operator new();
}

uint64_t sub_1002E1F60(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  char *v5;
  wireless_diagnostics::google::protobuf::io::CodedInputStream *TagFallback;
  int v7;
  unint64_t v8;
  char *v9;
  char *v10;
  unsigned int v11;
  BOOL v12;
  _BYTE *v14;
  unsigned int v15;
  unsigned __int8 *v16;
  uint64_t result;
  unsigned int v18;
  unsigned int v19;

  while (1)
  {
    while (1)
    {
      v5 = (char *)*((_QWORD *)this + 1);
      if ((unint64_t)v5 >= *((_QWORD *)this + 2) || *v5 < 0)
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        if (!(_DWORD)TagFallback)
          return 1;
      }
      else
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        *((_QWORD *)this + 1) = v5 + 1;
        if (!(_DWORD)TagFallback)
          return 1;
      }
      if (TagFallback >> 3 != 1)
        break;
      v7 = TagFallback & 7;
      if ((TagFallback & 7) != 0)
        goto LABEL_15;
      v18 = 0;
      v10 = (char *)*((_QWORD *)this + 1);
      if ((unint64_t)v10 >= *((_QWORD *)this + 2) || *v10 < 0)
      {
        result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v18);
        if (!(_DWORD)result)
          return result;
        v11 = v18;
      }
      else
      {
        v11 = *v10;
        *((_QWORD *)this + 1) = v10 + 1;
      }
      if (v11 - 31 < 0x19 || (v11 <= 0xE ? (v12 = ((1 << v11) & 0x76B6) == 0) : (v12 = 1), !v12))
      {
        if (v11 - 31 >= 0x19 && (v11 > 0xE || ((1 << v11) & 0x76B6) == 0))
          sub_1018F2704();
        *(_DWORD *)(a1 + 20) |= 1u;
        *(_DWORD *)(a1 + 8) = v11;
      }
      v14 = (_BYTE *)*((_QWORD *)this + 1);
      v8 = *((_QWORD *)this + 2);
      if ((unint64_t)v14 < v8 && *v14 == 16)
      {
        v9 = v14 + 1;
        *((_QWORD *)this + 1) = v9;
LABEL_34:
        v19 = 0;
        if ((unint64_t)v9 >= v8 || *v9 < 0)
        {
          result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v19);
          if (!(_DWORD)result)
            return result;
          v15 = v19;
          v16 = (unsigned __int8 *)*((_QWORD *)this + 1);
          v8 = *((_QWORD *)this + 2);
        }
        else
        {
          v15 = *v9;
          v16 = (unsigned __int8 *)(v9 + 1);
          *((_QWORD *)this + 1) = v16;
        }
        *(_BYTE *)(a1 + 12) = v15 != 0;
        *(_DWORD *)(a1 + 20) |= 2u;
        if (v16 == (unsigned __int8 *)v8 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          result = 1;
          *((_BYTE *)this + 36) = 1;
          return result;
        }
      }
    }
    if (TagFallback >> 3 == 2)
    {
      v7 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        v9 = (char *)*((_QWORD *)this + 1);
        v8 = *((_QWORD *)this + 2);
        goto LABEL_34;
      }
    }
    else
    {
      v7 = TagFallback & 7;
    }
LABEL_15:
    if (v7 == 4)
      return 1;
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, TagFallback, a3) & 1) == 0)
      return 0;
  }
}

uint64_t sub_1002E215C(uint64_t result, char a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5;
  int v6;

  v5 = result;
  v6 = *(_DWORD *)(result + 20);
  if ((v6 & 1) != 0)
  {
    result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 8), a2, a4);
    v6 = *(_DWORD *)(v5 + 20);
  }
  if ((v6 & 2) != 0)
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(unsigned __int8 *)(v5 + 12), a2, a4);
  return result;
}

uint64_t sub_1002E21B4(uint64_t a1, unsigned int a2)
{
  int v3;
  unsigned int v4;
  uint64_t result;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v6;

  LOBYTE(v3) = *(_BYTE *)(a1 + 20);
  if ((_BYTE)v3)
  {
    if ((*(_BYTE *)(a1 + 20) & 1) != 0)
    {
      v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
      if ((v6 & 0x80000000) != 0)
      {
        v4 = 11;
      }
      else if (v6 >= 0x80)
      {
        v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 1;
        v3 = *(_DWORD *)(a1 + 20);
      }
      else
      {
        v4 = 2;
      }
    }
    else
    {
      v4 = 0;
    }
    if ((v3 & 2) != 0)
      result = v4 + 2;
    else
      result = v4;
  }
  else
  {
    result = 0;
  }
  *(_DWORD *)(a1 + 16) = result;
  return result;
}

void sub_1002E2228(uint64_t a1, void *lpsrc)
{
  uint64_t v4;
  uint64_t v5;

  sub_1002DE640(a1, (uint64_t)lpsrc);
}

void sub_1002E2274(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
    sub_1002DE640(a1, a2);
  }
}

uint64_t sub_1002E22B4()
{
  return 1;
}

_QWORD *sub_1002E22BC@<X0>(_QWORD *a1@<X8>)
{
  return sub_1015A2E04(a1, "CLMicroLocationProto.SpectatingMotionUpdate");
}

void sub_1002E22CC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(_QWORD *)a1 = off_10212D7D8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_1002E22DC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(_QWORD *)a1 = off_10212D7D8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete();
}

void sub_1002E230C()
{
  operator new();
}

uint64_t sub_1002E234C(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  char *v5;
  wireless_diagnostics::google::protobuf::io::CodedInputStream *TagFallback;
  int v7;
  char *v8;
  unsigned int v9;
  unint64_t v10;
  char *v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  BOOL v17;
  _BYTE *v18;
  unsigned int v19;
  _BYTE *v20;
  unsigned int v21;
  _BYTE *v22;
  unsigned int v23;
  _BYTE *v24;
  unsigned int v25;
  _BYTE *v26;
  unsigned int v27;
  _BYTE *v28;
  unsigned int v29;
  unsigned __int8 *v30;
  uint64_t result;
  unsigned int v32;

  while (2)
  {
    v5 = (char *)*((_QWORD *)this + 1);
    if ((unint64_t)v5 >= *((_QWORD *)this + 2) || *v5 < 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      if (!(_DWORD)TagFallback)
        return 1;
    }
    else
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((_QWORD *)this + 1) = v5 + 1;
      if (!(_DWORD)TagFallback)
        return 1;
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0)
          goto LABEL_23;
        v32 = 0;
        v8 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v8 < *((_QWORD *)this + 2) && (*v8 & 0x80000000) == 0)
        {
          v9 = *v8;
          *((_QWORD *)this + 1) = v8 + 1;
LABEL_29:
          if (v9 - 31 < 0x19 || (v9 <= 0xE ? (v17 = ((1 << v9) & 0x76B6) == 0) : (v17 = 1), !v17))
          {
            if (v9 - 31 >= 0x19 && (v9 > 0xE || ((1 << v9) & 0x76B6) == 0))
              sub_1018F272C();
            *(_DWORD *)(a1 + 24) |= 1u;
            *(_DWORD *)(a1 + 8) = v9;
          }
          v18 = (_BYTE *)*((_QWORD *)this + 1);
          v10 = *((_QWORD *)this + 2);
          if ((unint64_t)v18 < v10 && *v18 == 16)
          {
            v13 = v18 + 1;
            *((_QWORD *)this + 1) = v13;
            goto LABEL_41;
          }
          continue;
        }
        result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v32);
        if ((_DWORD)result)
        {
          v9 = v32;
          goto LABEL_29;
        }
        break;
      case 2u:
        v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0)
          goto LABEL_23;
        v13 = (char *)*((_QWORD *)this + 1);
        v10 = *((_QWORD *)this + 2);
LABEL_41:
        v32 = 0;
        if ((unint64_t)v13 >= v10 || *v13 < 0)
        {
          result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v32);
          if (!(_DWORD)result)
            return result;
          v19 = v32;
          v20 = (_BYTE *)*((_QWORD *)this + 1);
          v10 = *((_QWORD *)this + 2);
        }
        else
        {
          v19 = *v13;
          v20 = v13 + 1;
          *((_QWORD *)this + 1) = v20;
        }
        *(_BYTE *)(a1 + 12) = v19 != 0;
        *(_DWORD *)(a1 + 24) |= 2u;
        if ((unint64_t)v20 >= v10 || *v20 != 24)
          continue;
        v11 = v20 + 1;
        *((_QWORD *)this + 1) = v11;
LABEL_49:
        v32 = 0;
        if ((unint64_t)v11 >= v10 || *v11 < 0)
        {
          result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v32);
          if (!(_DWORD)result)
            return result;
          v21 = v32;
          v22 = (_BYTE *)*((_QWORD *)this + 1);
          v10 = *((_QWORD *)this + 2);
        }
        else
        {
          v21 = *v11;
          v22 = v11 + 1;
          *((_QWORD *)this + 1) = v22;
        }
        *(_BYTE *)(a1 + 13) = v21 != 0;
        *(_DWORD *)(a1 + 24) |= 4u;
        if ((unint64_t)v22 >= v10 || *v22 != 32)
          continue;
        v14 = v22 + 1;
        *((_QWORD *)this + 1) = v14;
LABEL_57:
        v32 = 0;
        if ((unint64_t)v14 >= v10 || *v14 < 0)
        {
          result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v32);
          if (!(_DWORD)result)
            return result;
          v23 = v32;
          v24 = (_BYTE *)*((_QWORD *)this + 1);
          v10 = *((_QWORD *)this + 2);
        }
        else
        {
          v23 = *v14;
          v24 = v14 + 1;
          *((_QWORD *)this + 1) = v24;
        }
        *(_BYTE *)(a1 + 14) = v23 != 0;
        *(_DWORD *)(a1 + 24) |= 8u;
        if ((unint64_t)v24 >= v10 || *v24 != 40)
          continue;
        v12 = v24 + 1;
        *((_QWORD *)this + 1) = v12;
LABEL_65:
        v32 = 0;
        if ((unint64_t)v12 >= v10 || *v12 < 0)
        {
          result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v32);
          if (!(_DWORD)result)
            return result;
          v25 = v32;
          v26 = (_BYTE *)*((_QWORD *)this + 1);
          v10 = *((_QWORD *)this + 2);
        }
        else
        {
          v25 = *v12;
          v26 = v12 + 1;
          *((_QWORD *)this + 1) = v26;
        }
        *(_BYTE *)(a1 + 15) = v25 != 0;
        *(_DWORD *)(a1 + 24) |= 0x10u;
        if ((unint64_t)v26 >= v10 || *v26 != 48)
          continue;
        v15 = v26 + 1;
        *((_QWORD *)this + 1) = v15;
LABEL_73:
        v32 = 0;
        if ((unint64_t)v15 >= v10 || *v15 < 0)
        {
          result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v32);
          if (!(_DWORD)result)
            return result;
          v27 = v32;
          v28 = (_BYTE *)*((_QWORD *)this + 1);
          v10 = *((_QWORD *)this + 2);
        }
        else
        {
          v27 = *v15;
          v28 = v15 + 1;
          *((_QWORD *)this + 1) = v28;
        }
        *(_BYTE *)(a1 + 16) = v27 != 0;
        *(_DWORD *)(a1 + 24) |= 0x20u;
        if ((unint64_t)v28 >= v10 || *v28 != 56)
          continue;
        v16 = v28 + 1;
        *((_QWORD *)this + 1) = v16;
LABEL_81:
        v32 = 0;
        if ((unint64_t)v16 >= v10 || *v16 < 0)
        {
          result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v32);
          if (!(_DWORD)result)
            return result;
          v29 = v32;
          v30 = (unsigned __int8 *)*((_QWORD *)this + 1);
          v10 = *((_QWORD *)this + 2);
        }
        else
        {
          v29 = *v16;
          v30 = (unsigned __int8 *)(v16 + 1);
          *((_QWORD *)this + 1) = v30;
        }
        *(_BYTE *)(a1 + 17) = v29 != 0;
        *(_DWORD *)(a1 + 24) |= 0x40u;
        if (v30 != (unsigned __int8 *)v10 || !*((_DWORD *)this + 11) && *((_DWORD *)this + 6) != *((_DWORD *)this + 10))
          continue;
        *((_DWORD *)this + 8) = 0;
        result = 1;
        *((_BYTE *)this + 36) = 1;
        return result;
      case 3u:
        v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0)
          goto LABEL_23;
        v11 = (char *)*((_QWORD *)this + 1);
        v10 = *((_QWORD *)this + 2);
        goto LABEL_49;
      case 4u:
        v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0)
          goto LABEL_23;
        v14 = (char *)*((_QWORD *)this + 1);
        v10 = *((_QWORD *)this + 2);
        goto LABEL_57;
      case 5u:
        v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0)
          goto LABEL_23;
        v12 = (char *)*((_QWORD *)this + 1);
        v10 = *((_QWORD *)this + 2);
        goto LABEL_65;
      case 6u:
        v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0)
          goto LABEL_23;
        v15 = (char *)*((_QWORD *)this + 1);
        v10 = *((_QWORD *)this + 2);
        goto LABEL_73;
      case 7u:
        v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0)
          goto LABEL_23;
        v16 = (char *)*((_QWORD *)this + 1);
        v10 = *((_QWORD *)this + 2);
        goto LABEL_81;
      default:
        v7 = TagFallback & 7;
LABEL_23:
        if (v7 == 4)
          return 1;
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, TagFallback, a3) & 1) != 0)
          continue;
        return 0;
    }
    return result;
  }
}

uint64_t sub_1002E27E8(uint64_t result, char a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5;
  int v6;

  v5 = result;
  v6 = *(_DWORD *)(result + 24);
  if ((v6 & 1) != 0)
  {
    result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 8), a2, a4);
    v6 = *(_DWORD *)(v5 + 24);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0)
        goto LABEL_4;
      goto LABEL_11;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(unsigned __int8 *)(v5 + 12), a2, a4);
  v6 = *(_DWORD *)(v5 + 24);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0)
      goto LABEL_5;
    goto LABEL_12;
  }
LABEL_11:
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, *(unsigned __int8 *)(v5 + 13), a2, a4);
  v6 = *(_DWORD *)(v5 + 24);
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0)
      goto LABEL_6;
    goto LABEL_13;
  }
LABEL_12:
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, *(unsigned __int8 *)(v5 + 14), a2, a4);
  v6 = *(_DWORD *)(v5 + 24);
  if ((v6 & 0x10) == 0)
  {
LABEL_6:
    if ((v6 & 0x20) == 0)
      goto LABEL_7;
    goto LABEL_14;
  }
LABEL_13:
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, *(unsigned __int8 *)(v5 + 15), a2, a4);
  v6 = *(_DWORD *)(v5 + 24);
  if ((v6 & 0x20) == 0)
  {
LABEL_7:
    if ((v6 & 0x40) == 0)
      return result;
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)7, *(unsigned __int8 *)(v5 + 17), a2, a4);
  }
LABEL_14:
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, *(unsigned __int8 *)(v5 + 16), a2, a4);
  if ((*(_DWORD *)(v5 + 24) & 0x40) != 0)
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)7, *(unsigned __int8 *)(v5 + 17), a2, a4);
  return result;
}

uint64_t sub_1002E28D0(uint64_t a1, unsigned int a2)
{
  int v3;
  unsigned int v4;
  uint64_t result;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v6;

  LOBYTE(v3) = *(_BYTE *)(a1 + 24);
  if ((_BYTE)v3)
  {
    if ((*(_BYTE *)(a1 + 24) & 1) != 0)
    {
      v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
      if ((v6 & 0x80000000) != 0)
      {
        v4 = 11;
      }
      else if (v6 >= 0x80)
      {
        v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 1;
        v3 = *(_DWORD *)(a1 + 24);
      }
      else
      {
        v4 = 2;
      }
    }
    else
    {
      v4 = 0;
    }
    if ((v3 & 2) != 0)
      v4 += 2;
    if ((v3 & 4) != 0)
      v4 += 2;
    if ((v3 & 8) != 0)
      v4 += 2;
    if ((v3 & 0x10) != 0)
      v4 += 2;
    if ((v3 & 0x20) != 0)
      v4 += 2;
    if ((v3 & 0x40) != 0)
      result = v4 + 2;
    else
      result = v4;
  }
  else
  {
    result = 0;
  }
  *(_DWORD *)(a1 + 20) = result;
  return result;
}

void sub_1002E2980(uint64_t a1, void *lpsrc)
{
  uint64_t v4;
  uint64_t v5;

  sub_1002DE72C(a1, (uint64_t)lpsrc);
}

void sub_1002E29CC(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
    sub_1002DE72C(a1, a2);
  }
}

uint64_t sub_1002E2A0C()
{
  return 1;
}

_QWORD *sub_1002E2A14@<X0>(_QWORD *a1@<X8>)
{
  return sub_1015A2E04(a1, "CLMicroLocationProto.EnabledStateUpdate");
}

void sub_1002E2A24()
{
  operator new();
}

uint64_t sub_1002E2A68(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  char *v5;
  wireless_diagnostics::google::protobuf::io::CodedInputStream *TagFallback;
  int v7;
  unint64_t v8;
  char *v9;
  char *v10;
  unsigned int v11;
  BOOL v12;
  _BYTE *v14;
  unsigned int v15;
  unsigned __int8 *v16;
  uint64_t result;
  unsigned int v18;
  unsigned int v19;

  while (1)
  {
    while (1)
    {
      v5 = (char *)*((_QWORD *)this + 1);
      if ((unint64_t)v5 >= *((_QWORD *)this + 2) || *v5 < 0)
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        if (!(_DWORD)TagFallback)
          return 1;
      }
      else
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        *((_QWORD *)this + 1) = v5 + 1;
        if (!(_DWORD)TagFallback)
          return 1;
      }
      if (TagFallback >> 3 != 1)
        break;
      v7 = TagFallback & 7;
      if ((TagFallback & 7) != 0)
        goto LABEL_15;
      v18 = 0;
      v10 = (char *)*((_QWORD *)this + 1);
      if ((unint64_t)v10 >= *((_QWORD *)this + 2) || *v10 < 0)
      {
        result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v18);
        if (!(_DWORD)result)
          return result;
        v11 = v18;
      }
      else
      {
        v11 = *v10;
        *((_QWORD *)this + 1) = v10 + 1;
      }
      if (v11 - 31 < 0x19 || (v11 <= 0xE ? (v12 = ((1 << v11) & 0x76B6) == 0) : (v12 = 1), !v12))
      {
        if (v11 - 31 >= 0x19 && (v11 > 0xE || ((1 << v11) & 0x76B6) == 0))
          sub_1018F2754();
        *(_DWORD *)(a1 + 20) |= 1u;
        *(_DWORD *)(a1 + 8) = v11;
      }
      v14 = (_BYTE *)*((_QWORD *)this + 1);
      v8 = *((_QWORD *)this + 2);
      if ((unint64_t)v14 < v8 && *v14 == 16)
      {
        v9 = v14 + 1;
        *((_QWORD *)this + 1) = v9;
LABEL_34:
        v19 = 0;
        if ((unint64_t)v9 >= v8 || *v9 < 0)
        {
          result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v19);
          if (!(_DWORD)result)
            return result;
          v15 = v19;
          v16 = (unsigned __int8 *)*((_QWORD *)this + 1);
          v8 = *((_QWORD *)this + 2);
        }
        else
        {
          v15 = *v9;
          v16 = (unsigned __int8 *)(v9 + 1);
          *((_QWORD *)this + 1) = v16;
        }
        *(_BYTE *)(a1 + 12) = v15 != 0;
        *(_DWORD *)(a1 + 20) |= 2u;
        if (v16 == (unsigned __int8 *)v8 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          result = 1;
          *((_BYTE *)this + 36) = 1;
          return result;
        }
      }
    }
    if (TagFallback >> 3 == 2)
    {
      v7 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        v9 = (char *)*((_QWORD *)this + 1);
        v8 = *((_QWORD *)this + 2);
        goto LABEL_34;
      }
    }
    else
    {
      v7 = TagFallback & 7;
    }
LABEL_15:
    if (v7 == 4)
      return 1;
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, TagFallback, a3) & 1) == 0)
      return 0;
  }
}

uint64_t sub_1002E2C64(uint64_t result, char a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5;
  int v6;

  v5 = result;
  v6 = *(_DWORD *)(result + 20);
  if ((v6 & 1) != 0)
  {
    result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 8), a2, a4);
    v6 = *(_DWORD *)(v5 + 20);
  }
  if ((v6 & 2) != 0)
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(unsigned __int8 *)(v5 + 12), a2, a4);
  return result;
}

uint64_t sub_1002E2CBC(uint64_t a1, unsigned int a2)
{
  int v3;
  unsigned int v4;
  uint64_t result;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v6;

  LOBYTE(v3) = *(_BYTE *)(a1 + 20);
  if ((_BYTE)v3)
  {
    if ((*(_BYTE *)(a1 + 20) & 1) != 0)
    {
      v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
      if ((v6 & 0x80000000) != 0)
      {
        v4 = 11;
      }
      else if (v6 >= 0x80)
      {
        v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 1;
        v3 = *(_DWORD *)(a1 + 20);
      }
      else
      {
        v4 = 2;
      }
    }
    else
    {
      v4 = 0;
    }
    if ((v3 & 2) != 0)
      result = v4 + 2;
    else
      result = v4;
  }
  else
  {
    result = 0;
  }
  *(_DWORD *)(a1 + 16) = result;
  return result;
}

void sub_1002E2D30(uint64_t a1, void *lpsrc)
{
  uint64_t v4;
  uint64_t v5;

  sub_1000B2608(a1, (uint64_t)lpsrc);
}

uint64_t sub_1002E2D7C()
{
  return 1;
}

_QWORD *sub_1002E2D84@<X0>(_QWORD *a1@<X8>)
{
  return sub_1015A2E04(a1, "CLMicroLocationProto.ScreenStateUpdate");
}

void sub_1002E2D94(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(_QWORD *)a1 = off_10212D8C8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_1002E2DA4(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(_QWORD *)a1 = off_10212D8C8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete();
}

void sub_1002E2DD4()
{
  operator new();
}

uint64_t sub_1002E2E18(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  char *v5;
  wireless_diagnostics::google::protobuf::io::CodedInputStream *TagFallback;
  char *v7;
  unsigned int v8;
  BOOL v9;
  uint64_t result;
  unsigned int v12;

  while (1)
  {
    while (1)
    {
      v5 = (char *)*((_QWORD *)this + 1);
      if ((unint64_t)v5 >= *((_QWORD *)this + 2) || *v5 < 0)
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      }
      else
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        *((_QWORD *)this + 1) = v5 + 1;
      }
      if ((_DWORD)TagFallback != 8)
        break;
      v12 = 0;
      v7 = (char *)*((_QWORD *)this + 1);
      if ((unint64_t)v7 >= *((_QWORD *)this + 2) || *v7 < 0)
      {
        result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v12);
        if (!(_DWORD)result)
          return result;
        v8 = v12;
      }
      else
      {
        v8 = *v7;
        *((_QWORD *)this + 1) = v7 + 1;
      }
      if (v8 - 31 < 0x19 || (v8 <= 0xE ? (v9 = ((1 << v8) & 0x76B6) == 0) : (v9 = 1), !v9))
      {
        if (v8 - 31 >= 0x19 && (v8 > 0xE || ((1 << v8) & 0x76B6) == 0))
          sub_1018F277C();
        *(_DWORD *)(a1 + 16) |= 1u;
        *(_DWORD *)(a1 + 8) = v8;
      }
      if (*((_QWORD *)this + 1) == *((_QWORD *)this + 2)
        && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        result = 1;
        *((_BYTE *)this + 36) = 1;
        return result;
      }
    }
    if (!(_DWORD)TagFallback || (TagFallback & 7) == 4)
      break;
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, TagFallback, a3) & 1) == 0)
      return 0;
  }
  return 1;
}

uint64_t sub_1002E2F7C(uint64_t result, int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if ((*(_BYTE *)(result + 16) & 1) != 0)
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 8), a2, a4);
  return result;
}

uint64_t sub_1002E2F98(uint64_t a1, unsigned int a2)
{
  uint64_t result;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v4;

  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
  {
    v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
    if ((v4 & 0x80000000) != 0)
    {
      result = 11;
    }
    else if (v4 >= 0x80)
    {
      result = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4, a2)
             + 1;
    }
    else
    {
      result = 2;
    }
  }
  else
  {
    result = 0;
  }
  *(_DWORD *)(a1 + 12) = result;
  return result;
}

void sub_1002E2FF0(uint64_t a1, void *lpsrc)
{
  uint64_t v4;
  uint64_t v5;

  sub_1002DE8BC(a1, (uint64_t)lpsrc);
}

uint64_t sub_1002E303C()
{
  return 1;
}

_QWORD *sub_1002E3044@<X0>(_QWORD *a1@<X8>)
{
  return sub_1015A2E04(a1, "CLMicroLocationProto.CloudBackupExport");
}

void sub_1002E3054(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(_QWORD *)a1 = off_10212D940;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_1002E3064(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(_QWORD *)a1 = off_10212D940;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete();
}

void sub_1002E3094()
{
  operator new();
}

uint64_t sub_1002E30D8(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  char *v5;
  wireless_diagnostics::google::protobuf::io::CodedInputStream *TagFallback;
  char *v7;
  unsigned int v8;
  BOOL v9;
  uint64_t result;
  unsigned int v12;

  while (1)
  {
    while (1)
    {
      v5 = (char *)*((_QWORD *)this + 1);
      if ((unint64_t)v5 >= *((_QWORD *)this + 2) || *v5 < 0)
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      }
      else
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        *((_QWORD *)this + 1) = v5 + 1;
      }
      if ((_DWORD)TagFallback != 8)
        break;
      v12 = 0;
      v7 = (char *)*((_QWORD *)this + 1);
      if ((unint64_t)v7 >= *((_QWORD *)this + 2) || *v7 < 0)
      {
        result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v12);
        if (!(_DWORD)result)
          return result;
        v8 = v12;
      }
      else
      {
        v8 = *v7;
        *((_QWORD *)this + 1) = v7 + 1;
      }
      if (v8 - 31 < 0x19 || (v8 <= 0xE ? (v9 = ((1 << v8) & 0x76B6) == 0) : (v9 = 1), !v9))
      {
        if (v8 - 31 >= 0x19 && (v8 > 0xE || ((1 << v8) & 0x76B6) == 0))
          sub_1018F27A4();
        *(_DWORD *)(a1 + 16) |= 1u;
        *(_DWORD *)(a1 + 8) = v8;
      }
      if (*((_QWORD *)this + 1) == *((_QWORD *)this + 2)
        && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        result = 1;
        *((_BYTE *)this + 36) = 1;
        return result;
      }
    }
    if (!(_DWORD)TagFallback || (TagFallback & 7) == 4)
      break;
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, TagFallback, a3) & 1) == 0)
      return 0;
  }
  return 1;
}

uint64_t sub_1002E323C(uint64_t result, int a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if ((*(_BYTE *)(result + 16) & 1) != 0)
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 8), a2, a4);
  return result;
}

uint64_t sub_1002E3258(uint64_t a1, unsigned int a2)
{
  uint64_t result;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v4;

  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
  {
    v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 8);
    if ((v4 & 0x80000000) != 0)
    {
      result = 11;
    }
    else if (v4 >= 0x80)
    {
      result = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4, a2)
             + 1;
    }
    else
    {
      result = 2;
    }
  }
  else
  {
    result = 0;
  }
  *(_DWORD *)(a1 + 12) = result;
  return result;
}

void sub_1002E32B0(uint64_t a1, void *lpsrc)
{
  uint64_t v4;
  uint64_t v5;

  sub_1002DE988(a1, (uint64_t)lpsrc);
}

uint64_t sub_1002E32FC()
{
  return 1;
}

_QWORD *sub_1002E3304@<X0>(_QWORD *a1@<X8>)
{
  return sub_1015A2E04(a1, "CLMicroLocationProto.CloudBackupImport");
}

uint64_t sub_1002E3314(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = off_10212D9B8;
  *(_DWORD *)(a1 + 24) = 0;
  sub_1002E3360(a1, a2);
  return a1;
}

void sub_1002E334C(_Unwind_Exception *a1)
{
  wireless_diagnostics::google::protobuf::MessageLite *v1;

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(v1);
  _Unwind_Resume(a1);
}

void sub_1002E3360(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  char v8;
  _BYTE v9[48];

  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage(v9, 3, "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/proto/gen-cpp/microlocation.pb.cc", 20314);
    v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<(v9, "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v8, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }
  LOBYTE(v5) = *(_BYTE *)(a2 + 24);
  if ((_BYTE)v5)
  {
    if ((*(_BYTE *)(a2 + 24) & 1) != 0)
    {
      v6 = *(_DWORD *)(a2 + 16);
      *(_DWORD *)(a1 + 24) |= 1u;
      *(_DWORD *)(a1 + 16) = v6;
      v5 = *(_DWORD *)(a2 + 24);
    }
    if ((v5 & 2) != 0)
    {
      v7 = *(_QWORD *)(a2 + 8);
      *(_DWORD *)(a1 + 24) |= 2u;
      *(_QWORD *)(a1 + 8) = v7;
    }
  }
}

void sub_1002E3408(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_1002E3424(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(_QWORD *)a1 = off_10212D9B8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_1002E3434(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(_QWORD *)a1 = off_10212D9B8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete();
}

void sub_1002E3464()
{
  operator new();
}

uint64_t sub_1002E34A0(uint64_t result)
{
  if (*(_BYTE *)(result + 24))
  {
    *(_DWORD *)(result + 16) = 0;
    *(_QWORD *)(result + 8) = 0;
  }
  *(_DWORD *)(result + 24) = 0;
  return result;
}

uint64_t sub_1002E34B8(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  unsigned int *v5;
  unint64_t *v6;
  char *v7;
  wireless_diagnostics::google::protobuf::io::CodedInputStream *TagFallback;
  int v9;
  unint64_t v10;
  char *v11;
  char *v12;
  _BYTE *v13;
  unsigned __int8 *v14;
  uint64_t result;

  v5 = (unsigned int *)(a1 + 16);
  v6 = (unint64_t *)(a1 + 8);
  while (1)
  {
    while (1)
    {
      v7 = (char *)*((_QWORD *)this + 1);
      if ((unint64_t)v7 >= *((_QWORD *)this + 2) || *v7 < 0)
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        if (!(_DWORD)TagFallback)
          return 1;
      }
      else
      {
        TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v7;
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        *((_QWORD *)this + 1) = v7 + 1;
        if (!(_DWORD)TagFallback)
          return 1;
      }
      if (TagFallback >> 3 != 1)
        break;
      v9 = TagFallback & 7;
      if ((TagFallback & 7) != 0)
        goto LABEL_16;
      v12 = (char *)*((_QWORD *)this + 1);
      v10 = *((_QWORD *)this + 2);
      if ((unint64_t)v12 >= v10 || *v12 < 0)
      {
        result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v5);
        if (!(_DWORD)result)
          return result;
        v13 = (_BYTE *)*((_QWORD *)this + 1);
        v10 = *((_QWORD *)this + 2);
      }
      else
      {
        *v5 = *v12;
        v13 = v12 + 1;
        *((_QWORD *)this + 1) = v13;
      }
      *(_DWORD *)(a1 + 24) |= 1u;
      if ((unint64_t)v13 < v10 && *v13 == 16)
      {
        v11 = v13 + 1;
        *((_QWORD *)this + 1) = v11;
LABEL_24:
        if ((unint64_t)v11 >= v10 || *v11 < 0)
        {
          result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, v6);
          if (!(_DWORD)result)
            return result;
          v14 = (unsigned __int8 *)*((_QWORD *)this + 1);
          v10 = *((_QWORD *)this + 2);
        }
        else
        {
          *v6 = *v11;
          v14 = (unsigned __int8 *)(v11 + 1);
          *((_QWORD *)this + 1) = v14;
        }
        *(_DWORD *)(a1 + 24) |= 2u;
        if (v14 == (unsigned __int8 *)v10
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          result = 1;
          *((_BYTE *)this + 36) = 1;
          return result;
        }
      }
    }
    if (TagFallback >> 3 == 2)
    {
      v9 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        v11 = (char *)*((_QWORD *)this + 1);
        v10 = *((_QWORD *)this + 2);
        goto LABEL_24;
      }
    }
    else
    {
      v9 = TagFallback & 7;
    }
LABEL_16:
    if (v9 == 4)
      return 1;
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, TagFallback, a3) & 1) == 0)
      return 0;
  }
}

uint64_t sub_1002E3654(uint64_t result, unint64_t a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5;
  int v6;

  v5 = result;
  v6 = *(_DWORD *)(result + 24);
  if ((v6 & 1) != 0)
  {
    result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 16), a2, a4);
    v6 = *(_DWORD *)(v5 + 24);
  }
  if ((v6 & 2) != 0)
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(_QWORD *)(v5 + 8), a2, a4);
  return result;
}

uint64_t sub_1002E36AC(uint64_t a1, unint64_t a2)
{
  char v3;
  uint64_t v4;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v5;

  v3 = *(_BYTE *)(a1 + 24);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 24) & 1) == 0)
    {
      v4 = 0;
      if ((*(_BYTE *)(a1 + 24) & 2) == 0)
        goto LABEL_11;
      goto LABEL_10;
    }
    v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
    if (v5 < 0x80)
    {
      v4 = 2;
      if ((v3 & 2) == 0)
        goto LABEL_11;
      goto LABEL_10;
    }
    v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
    if ((*(_DWORD *)(a1 + 24) & 2) != 0)
LABEL_10:
      v4 = v4
         + wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(a1 + 8), a2)+ 1;
  }
  else
  {
    v4 = 0;
  }
LABEL_11:
  *(_DWORD *)(a1 + 20) = v4;
  return v4;
}

void sub_1002E3728(uint64_t a1, void *lpsrc)
{
  uint64_t v4;
  uint64_t v5;

  sub_1002E3360(a1, (uint64_t)lpsrc);
}

uint64_t sub_1002E3774()
{
  return 1;
}

_QWORD *sub_1002E377C@<X0>(_QWORD *a1@<X8>)
{
  return sub_1015A2E04(a1, "CLMicroLocationProto.ChannelAndCount");
}

void sub_1002E378C(_DWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  char v11;
  _BYTE v12[48];

  if ((_DWORD *)a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage(v12, 3, "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/proto/gen-cpp/microlocation.pb.cc", 20519);
    v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<(v12, "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v11, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v12);
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2), *(_DWORD *)(a2 + 16) + a1[4]);
  if (*(int *)(a2 + 16) >= 1)
  {
    v5 = 0;
    do
    {
      v6 = *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8 * v5);
      v7 = a1[5];
      v8 = (int)a1[4];
      if ((int)v8 >= v7)
      {
        if (v7 == a1[6])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2), v7 + 1);
          v7 = a1[5];
        }
        a1[5] = v7 + 1;
        operator new();
      }
      v9 = *((_QWORD *)a1 + 1);
      a1[4] = v8 + 1;
      sub_1002E3360(*(_QWORD *)(v9 + 8 * v8), v6);
      ++v5;
    }
    while (v5 < *(int *)(a2 + 16));
  }
  if ((*(_BYTE *)(a2 + 40) & 1) != 0)
  {
    v10 = *(_DWORD *)(a2 + 32);
    if (v10 >= 3)
      sub_1018F27F4();
    a1[10] |= 1u;
    a1[8] = v10;
  }
}

void sub_1002E3900(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_1002E3918(uint64_t *a1)
{
  *a1 = (uint64_t)off_10212DA30;
  sub_10010C59C(a1 + 1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite((wireless_diagnostics::google::protobuf::MessageLite *)a1);
}

void sub_1002E3950(uint64_t *a1)
{
  sub_1002E3918(a1);
  operator delete();
}

void sub_1002E3974()
{
  operator new();
}

uint64_t sub_1002E39B8(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = result;
  if (*(_BYTE *)(result + 40))
    *(_DWORD *)(result + 32) = 0;
  if (*(int *)(result + 16) >= 1)
  {
    v2 = 0;
    do
    {
      v3 = *(_QWORD *)(*(_QWORD *)(v1 + 8) + 8 * v2);
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 32))(v3);
      ++v2;
    }
    while (v2 < *(int *)(v1 + 16));
  }
  *(_DWORD *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 40) = 0;
  return result;
}

uint64_t sub_1002E3A1C(int *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *v5;
  char *v6;
  wireless_diagnostics::google::protobuf::io::CodedInputStream *TagFallback;
  int v8;
  char *v9;
  unsigned int v10;
  uint64_t result;
  _BYTE *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  int v18;
  int v19;
  int v20;
  unsigned int v21;
  int v22;
  BOOL v23;
  int v24;
  _BYTE *v25;
  unsigned int v26;
  unsigned int v27;

  v5 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 2);
  while (1)
  {
    while (1)
    {
      while (1)
      {
        v6 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v6 >= *((_QWORD *)this + 2) || *v6 < 0)
        {
          TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
          *((_DWORD *)this + 8) = (_DWORD)TagFallback;
          if (!(_DWORD)TagFallback)
            return 1;
        }
        else
        {
          TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v6;
          *((_DWORD *)this + 8) = (_DWORD)TagFallback;
          *((_QWORD *)this + 1) = v6 + 1;
          if (!(_DWORD)TagFallback)
            return 1;
        }
        if (TagFallback >> 3 != 1)
          break;
        v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0)
          goto LABEL_16;
        v26 = 0;
        v9 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v9 >= *((_QWORD *)this + 2) || *v9 < 0)
        {
          result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v26);
          if (!(_DWORD)result)
            return result;
          v10 = v26;
        }
        else
        {
          v10 = *v9;
          *((_QWORD *)this + 1) = v9 + 1;
        }
        if (v10 <= 2)
        {
          a1[10] |= 1u;
          a1[8] = v10;
        }
        v12 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v12 < *((_QWORD *)this + 2) && *v12 == 18)
          goto LABEL_25;
      }
      if (TagFallback >> 3 != 2)
        break;
      v8 = TagFallback & 7;
      if (v8 != 2)
        goto LABEL_16;
      while (1)
      {
        v13 = a1[5];
        v14 = a1[4];
        if ((int)v14 >= v13)
        {
          if (v13 == a1[6])
          {
            wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v5, v13 + 1);
            v13 = a1[5];
          }
          a1[5] = v13 + 1;
          operator new();
        }
        v15 = *((_QWORD *)a1 + 1);
        a1[4] = v14 + 1;
        v16 = *(_QWORD *)(v15 + 8 * v14);
        v27 = 0;
        v17 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v17 >= *((_QWORD *)this + 2) || *v17 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v27))return 0;
        }
        else
        {
          v27 = *v17;
          *((_QWORD *)this + 1) = v17 + 1;
        }
        v18 = *((_DWORD *)this + 14);
        v19 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v18 + 1;
        if (v18 >= v19)
          return 0;
        v20 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v27);
        if (!sub_1002E34B8(v16, this, v21) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v20);
        v22 = *((_DWORD *)this + 14);
        v23 = __OFSUB__(v22, 1);
        v24 = v22 - 1;
        if (v24 < 0 == v23)
          *((_DWORD *)this + 14) = v24;
        v12 = (_BYTE *)*((_QWORD *)this + 1);
        v25 = (_BYTE *)*((_QWORD *)this + 2);
        if (v12 >= v25 || *v12 != 18)
          break;
LABEL_25:
        *((_QWORD *)this + 1) = v12 + 1;
      }
      if (v12 == v25 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        result = 1;
        *((_BYTE *)this + 36) = 1;
        return result;
      }
    }
    v8 = TagFallback & 7;
LABEL_16:
    if (v8 == 4)
      return 1;
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, TagFallback, a3) & 1) == 0)
      return 0;
  }
}

uint64_t sub_1002E3CC8(uint64_t result, const wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5;
  uint64_t v6;

  v5 = result;
  if ((*(_BYTE *)(result + 40) & 1) != 0)
    result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 32), (int)a2, a4);
  if (*(int *)(v5 + 16) >= 1)
  {
    v6 = 0;
    do
      result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(_QWORD *)(*(_QWORD *)(v5 + 8) + 8 * v6++), a2, a4);
    while (v6 < *(int *)(v5 + 16));
  }
  return result;
}

uint64_t sub_1002E3D3C(uint64_t a1, unint64_t a2)
{
  int v3;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v8;
  int v9;
  int v10;

  if ((*(_BYTE *)(a1 + 40) & 1) != 0)
  {
    v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 32);
    if ((v4 & 0x80000000) != 0)
    {
      v3 = 11;
    }
    else if (v4 >= 0x80)
    {
      v3 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4, a2) + 1;
    }
    else
    {
      v3 = 2;
    }
  }
  else
  {
    v3 = 0;
  }
  v5 = *(_DWORD *)(a1 + 16);
  v6 = (v5 + v3);
  if (v5 >= 1)
  {
    v7 = 0;
    do
    {
      v8 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002E36AC(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v7), a2);
      v9 = (int)v8;
      if (v8 >= 0x80)
        v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v8, a2);
      else
        v10 = 1;
      v6 = (v9 + v6 + v10);
      ++v7;
    }
    while (v7 < *(int *)(a1 + 16));
  }
  *(_DWORD *)(a1 + 36) = v6;
  return v6;
}

void sub_1002E3DF4(_DWORD *a1, void *lpsrc)
{
  uint64_t v4;
  uint64_t v5;

  sub_1002E378C(a1, (uint64_t)lpsrc);
}

void sub_1002E3E40(_DWORD *a1, uint64_t a2)
{
  if ((_DWORD *)a2 != a1)
  {
    (*(void (**)(_DWORD *))(*(_QWORD *)a1 + 32))(a1);
    sub_1002E378C(a1, a2);
  }
}

uint64_t sub_1002E3E80()
{
  return 1;
}

_QWORD *sub_1002E3E88@<X0>(_QWORD *a1@<X8>)
{
  return sub_1015A2E04(a1, "CLMicroLocationProto.WifiHistogram");
}

void sub_1002E3E98(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  _DWORD *v7;
  uint64_t v8;
  char v9;
  _BYTE v10[48];

  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage(v10, 3, "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/proto/gen-cpp/microlocation.pb.cc", 20730);
    v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<(v10, "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v9, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v10);
  }
  LOBYTE(v5) = *(_BYTE *)(a2 + 24);
  if ((_BYTE)v5)
  {
    if ((*(_BYTE *)(a2 + 24) & 1) != 0)
    {
      v6 = *(_DWORD *)(a2 + 16);
      if (v6 >= 3)
        sub_1018F281C();
      *(_DWORD *)(a1 + 24) |= 1u;
      *(_DWORD *)(a1 + 16) = v6;
      v5 = *(_DWORD *)(a2 + 24);
    }
    if ((v5 & 2) != 0)
    {
      *(_DWORD *)(a1 + 24) |= 2u;
      v7 = *(_DWORD **)(a1 + 8);
      if (!v7)
        operator new();
      v8 = *(_QWORD *)(a2 + 8);
      if (!v8)
        v8 = *(_QWORD *)(qword_102310450 + 8);
      sub_1002C4ED8(v7, v8);
    }
  }
}

void sub_1002E3F98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_1002E3FB0(wireless_diagnostics::google::protobuf::MessageLite *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_10212DAA8;
  if ((wireless_diagnostics::google::protobuf::MessageLite *)qword_102310450 != this)
  {
    v2 = *((_QWORD *)this + 1);
    if (v2)
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  }
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

void sub_1002E4004(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  sub_1002E3FB0(a1);
  operator delete();
}

void sub_1002E4028()
{
  operator new();
}

uint64_t sub_1002E406C(uint64_t result)
{
  uint64_t v1;
  char v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v1 = result;
  v2 = *(_BYTE *)(result + 24);
  if (v2)
  {
    *(_DWORD *)(result + 16) = 1;
    if ((v2 & 2) != 0)
    {
      v3 = *(_QWORD *)(result + 8);
      if (v3)
      {
        if (*(int *)(v3 + 16) >= 1)
        {
          v4 = 0;
          do
          {
            v5 = *(_QWORD *)(*(_QWORD *)(v3 + 8) + 8 * v4);
            result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 32))(v5);
            ++v4;
          }
          while (v4 < *(int *)(v3 + 16));
        }
        *(_DWORD *)(v3 + 16) = 0;
        *(_DWORD *)(v3 + 36) = 0;
      }
    }
  }
  *(_DWORD *)(v1 + 24) = 0;
  return result;
}

uint64_t sub_1002E40EC(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  char *v5;
  wireless_diagnostics::google::protobuf::io::CodedInputStream *TagFallback;
  int v7;
  char *v8;
  unsigned int v9;
  uint64_t result;
  _BYTE *v11;
  int *v12;
  char *v13;
  int v14;
  int v15;
  int v16;
  unsigned int v17;
  int v18;
  BOOL v19;
  int v20;
  unsigned int v21;
  unsigned int v22;

  while (1)
  {
    while (1)
    {
      while (1)
      {
        v5 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v5 >= *((_QWORD *)this + 2) || *v5 < 0)
        {
          TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
          *((_DWORD *)this + 8) = (_DWORD)TagFallback;
          if (!(_DWORD)TagFallback)
            return 1;
        }
        else
        {
          TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
          *((_DWORD *)this + 8) = (_DWORD)TagFallback;
          *((_QWORD *)this + 1) = v5 + 1;
          if (!(_DWORD)TagFallback)
            return 1;
        }
        if (TagFallback >> 3 != 1)
          break;
        v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0)
          goto LABEL_15;
        v21 = 0;
        v8 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v8 >= *((_QWORD *)this + 2) || *v8 < 0)
        {
          result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v21);
          if (!(_DWORD)result)
            return result;
          v9 = v21;
        }
        else
        {
          v9 = *v8;
          *((_QWORD *)this + 1) = v8 + 1;
        }
        if (v9 <= 2)
        {
          *(_DWORD *)(a1 + 24) |= 1u;
          *(_DWORD *)(a1 + 16) = v9;
        }
        v11 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v11 < *((_QWORD *)this + 2) && *v11 == 18)
        {
          *((_QWORD *)this + 1) = v11 + 1;
          goto LABEL_25;
        }
      }
      if (TagFallback >> 3 != 2)
      {
        v7 = TagFallback & 7;
        goto LABEL_15;
      }
      v7 = TagFallback & 7;
      if (v7 == 2)
        break;
LABEL_15:
      if (v7 == 4)
        return 1;
      if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, TagFallback, a3) & 1) == 0)
        return 0;
    }
LABEL_25:
    *(_DWORD *)(a1 + 24) |= 2u;
    v12 = *(int **)(a1 + 8);
    if (!v12)
      operator new();
    v22 = 0;
    v13 = (char *)*((_QWORD *)this + 1);
    if ((unint64_t)v13 >= *((_QWORD *)this + 2) || *v13 < 0)
    {
      if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v22))
        return 0;
    }
    else
    {
      v22 = *v13;
      *((_QWORD *)this + 1) = v13 + 1;
    }
    v14 = *((_DWORD *)this + 14);
    v15 = *((_DWORD *)this + 15);
    *((_DWORD *)this + 14) = v14 + 1;
    if (v14 >= v15)
      return 0;
    v16 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v22);
    if (!sub_1002C5144(v12, this, v17) || !*((_BYTE *)this + 36))
      return 0;
    wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v16);
    v18 = *((_DWORD *)this + 14);
    v19 = __OFSUB__(v18, 1);
    v20 = v18 - 1;
    if (v20 < 0 == v19)
      *((_DWORD *)this + 14) = v20;
    if (*((_QWORD *)this + 1) == *((_QWORD *)this + 2)
      && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
    {
      *((_DWORD *)this + 8) = 0;
      result = 1;
      *((_BYTE *)this + 36) = 1;
      return result;
    }
  }
}

uint64_t sub_1002E4340(uint64_t result, const wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5;
  int v6;
  uint64_t v7;

  v5 = result;
  v6 = *(_DWORD *)(result + 24);
  if ((v6 & 1) != 0)
  {
    result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 16), (int)a2, a4);
    if ((*(_DWORD *)(v5 + 24) & 2) == 0)
      return result;
  }
  else if ((v6 & 2) == 0)
  {
    return result;
  }
  v7 = *(_QWORD *)(v5 + 8);
  if (!v7)
    v7 = *(_QWORD *)(qword_102310450 + 8);
  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v7, a2, a4);
}

uint64_t sub_1002E43AC(uint64_t a1, unsigned int a2)
{
  char v3;
  uint64_t v4;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v5;
  uint64_t v6;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v7;
  unsigned int v8;
  int v9;
  int v10;

  v3 = *(_BYTE *)(a1 + 24);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 24) & 1) != 0)
    {
      v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
      if ((v5 & 0x80000000) != 0)
      {
        v4 = 11;
        if ((v3 & 2) == 0)
          goto LABEL_19;
      }
      else if (v5 >= 0x80)
      {
        v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2)
           + 1;
        if ((*(_DWORD *)(a1 + 24) & 2) == 0)
          goto LABEL_19;
      }
      else
      {
        v4 = 2;
        if ((v3 & 2) == 0)
          goto LABEL_19;
      }
    }
    else
    {
      v4 = 0;
      if ((*(_BYTE *)(a1 + 24) & 2) == 0)
        goto LABEL_19;
    }
    v6 = *(_QWORD *)(a1 + 8);
    if (!v6)
      v6 = *(_QWORD *)(qword_102310450 + 8);
    v7 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002C53CC(v6, a2);
    v9 = (int)v7;
    if (v7 >= 0x80)
      v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v7, v8);
    else
      v10 = 1;
    v4 = (v4 + v9 + v10 + 1);
  }
  else
  {
    v4 = 0;
  }
LABEL_19:
  *(_DWORD *)(a1 + 20) = v4;
  return v4;
}

void sub_1002E4470(uint64_t a1, void *lpsrc)
{
  uint64_t v4;
  uint64_t v5;

  sub_1002E3E98(a1, (uint64_t)lpsrc);
}

void sub_1002E44BC(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
    sub_1002E3E98(a1, a2);
  }
}

uint64_t sub_1002E44FC()
{
  return 1;
}

_QWORD *sub_1002E4504@<X0>(_QWORD *a1@<X8>)
{
  return sub_1015A2E04(a1, "CLMicroLocationProto.AnchorAppearanceConfiguration");
}

void sub_1002E4514(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  _DWORD *v7;
  uint64_t v8;
  const std::string *v9;
  std::string *v10;
  char v11;
  _BYTE v12[48];

  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage(v12, 3, "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/proto/gen-cpp/microlocation.pb.cc", 20980);
    v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<(v12, "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v11, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v12);
  }
  LOBYTE(v5) = *(_BYTE *)(a2 + 32);
  if ((_BYTE)v5)
  {
    if ((*(_BYTE *)(a2 + 32) & 1) != 0)
    {
      v6 = *(_DWORD *)(a2 + 24);
      if (v6 >= 3)
        sub_1018F2844();
      *(_DWORD *)(a1 + 32) |= 1u;
      *(_DWORD *)(a1 + 24) = v6;
      v5 = *(_DWORD *)(a2 + 32);
    }
    if ((v5 & 2) != 0)
    {
      *(_DWORD *)(a1 + 32) |= 2u;
      v7 = *(_DWORD **)(a1 + 8);
      if (!v7)
        operator new();
      v8 = *(_QWORD *)(a2 + 8);
      if (!v8)
        v8 = *(_QWORD *)(qword_102310458 + 8);
      sub_1002C6214(v7, v8);
      v5 = *(_DWORD *)(a2 + 32);
    }
    if ((v5 & 4) != 0)
    {
      v9 = *(const std::string **)(a2 + 16);
      *(_DWORD *)(a1 + 32) |= 4u;
      v10 = *(std::string **)(a1 + 16);
      if (v10 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
        operator new();
      std::string::operator=(v10, v9);
    }
  }
}

void sub_1002E466C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

_QWORD *sub_1002E4684(_QWORD *result)
{
  uint64_t v1;

  v1 = result[2];
  if ((_UNKNOWN *)v1 != &wireless_diagnostics::google::protobuf::internal::kEmptyString && v1 != 0)
  {
    if (*(char *)(v1 + 23) < 0)
      operator delete(*(void **)v1);
    operator delete();
  }
  if ((_QWORD *)qword_102310458 != result)
  {
    result = (_QWORD *)result[1];
    if (result)
      return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 8))(result);
  }
  return result;
}

void sub_1002E470C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(_QWORD *)a1 = off_10212DB20;
  sub_1002E4684(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_1002E473C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(_QWORD *)a1 = off_10212DB20;
  sub_1002E4684(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete();
}

void sub_1002E4780()
{
  operator new();
}

uint64_t sub_1002E47D0(uint64_t result)
{
  uint64_t v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v1 = result;
  LOBYTE(v2) = *(_BYTE *)(result + 32);
  if ((_BYTE)v2)
  {
    *(_DWORD *)(result + 24) = 2;
    if ((v2 & 2) != 0)
    {
      v3 = *(_QWORD *)(result + 8);
      if (v3)
      {
        if (*(int *)(v3 + 16) >= 1)
        {
          v4 = 0;
          do
          {
            v5 = *(_QWORD *)(*(_QWORD *)(v3 + 8) + 8 * v4);
            result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 32))(v5);
            ++v4;
          }
          while (v4 < *(int *)(v3 + 16));
        }
        *(_DWORD *)(v3 + 16) = 0;
        *(_DWORD *)(v3 + 36) = 0;
        v2 = *(_DWORD *)(v1 + 32);
      }
    }
    if ((v2 & 4) != 0)
    {
      v6 = *(_QWORD *)(v1 + 16);
      if ((_UNKNOWN *)v6 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v6 + 23) < 0)
        {
          **(_BYTE **)v6 = 0;
          *(_QWORD *)(v6 + 8) = 0;
        }
        else
        {
          *(_BYTE *)v6 = 0;
          *(_BYTE *)(v6 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(v1 + 32) = 0;
  return result;
}

uint64_t sub_1002E488C(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  char *v5;
  wireless_diagnostics::google::protobuf::io::CodedInputStream *TagFallback;
  unsigned int v7;
  int v8;
  char *v9;
  unsigned int v10;
  uint64_t result;
  _BYTE *v12;
  int *v13;
  char *v14;
  int v15;
  int v16;
  int v17;
  unsigned int v18;
  int v19;
  BOOL v20;
  int v21;
  _BYTE *v22;
  void *v23;
  unsigned int v24;
  unsigned int v25;

  while (1)
  {
    while (1)
    {
      while (1)
      {
        v5 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v5 >= *((_QWORD *)this + 2) || *v5 < 0)
        {
          TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
          *((_DWORD *)this + 8) = (_DWORD)TagFallback;
          if (!(_DWORD)TagFallback)
            return 1;
        }
        else
        {
          TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
          *((_DWORD *)this + 8) = (_DWORD)TagFallback;
          *((_QWORD *)this + 1) = v5 + 1;
          if (!(_DWORD)TagFallback)
            return 1;
        }
        v7 = TagFallback >> 3;
        if (TagFallback >> 3 != 1)
          break;
        v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0)
          goto LABEL_18;
        v24 = 0;
        v9 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v9 >= *((_QWORD *)this + 2) || *v9 < 0)
        {
          result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v24);
          if (!(_DWORD)result)
            return result;
          v10 = v24;
        }
        else
        {
          v10 = *v9;
          *((_QWORD *)this + 1) = v9 + 1;
        }
        if (v10 <= 2)
        {
          *(_DWORD *)(a1 + 32) |= 1u;
          *(_DWORD *)(a1 + 24) = v10;
        }
        v12 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v12 < *((_QWORD *)this + 2) && *v12 == 18)
        {
          *((_QWORD *)this + 1) = v12 + 1;
          goto LABEL_28;
        }
      }
      if (v7 == 2)
        break;
      if (v7 == 3)
      {
        v8 = TagFallback & 7;
        if (v8 == 2)
          goto LABEL_42;
      }
      else
      {
        v8 = TagFallback & 7;
      }
LABEL_18:
      if (v8 == 4)
        return 1;
      if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, TagFallback, a3) & 1) == 0)
        return 0;
    }
    v8 = TagFallback & 7;
    if (v8 != 2)
      goto LABEL_18;
LABEL_28:
    *(_DWORD *)(a1 + 32) |= 2u;
    v13 = *(int **)(a1 + 8);
    if (!v13)
      operator new();
    v25 = 0;
    v14 = (char *)*((_QWORD *)this + 1);
    if ((unint64_t)v14 >= *((_QWORD *)this + 2) || *v14 < 0)
    {
      if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v25))
        return 0;
    }
    else
    {
      v25 = *v14;
      *((_QWORD *)this + 1) = v14 + 1;
    }
    v15 = *((_DWORD *)this + 14);
    v16 = *((_DWORD *)this + 15);
    *((_DWORD *)this + 14) = v15 + 1;
    if (v15 >= v16)
      return 0;
    v17 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v25);
    if (!sub_1002C6480(v13, this, v18) || !*((_BYTE *)this + 36))
      return 0;
    wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v17);
    v19 = *((_DWORD *)this + 14);
    v20 = __OFSUB__(v19, 1);
    v21 = v19 - 1;
    if (v21 < 0 == v20)
      *((_DWORD *)this + 14) = v21;
    v22 = (_BYTE *)*((_QWORD *)this + 1);
    if ((unint64_t)v22 < *((_QWORD *)this + 2) && *v22 == 26)
    {
      *((_QWORD *)this + 1) = v22 + 1;
LABEL_42:
      *(_DWORD *)(a1 + 32) |= 4u;
      v23 = *(void **)(a1 + 16);
      if (v23 == &wireless_diagnostics::google::protobuf::internal::kEmptyString)
        operator new();
      result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes(this, v23);
      if (!(_DWORD)result)
        return result;
      if (*((_QWORD *)this + 1) == *((_QWORD *)this + 2)
        && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
      {
        *((_DWORD *)this + 8) = 0;
        result = 1;
        *((_BYTE *)this + 36) = 1;
        return result;
      }
    }
  }
}

uint64_t sub_1002E4B6C(uint64_t result, const wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5;
  int v6;
  uint64_t v7;

  v5 = result;
  v6 = *(_DWORD *)(result + 32);
  if ((v6 & 1) != 0)
  {
    result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 24), (int)a2, a4);
    v6 = *(_DWORD *)(v5 + 32);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0)
        return result;
      return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes(3, *(_QWORD *)(v5 + 16), a2);
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  v7 = *(_QWORD *)(v5 + 8);
  if (!v7)
    v7 = *(_QWORD *)(qword_102310458 + 8);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v7, a2, a4);
  if ((*(_DWORD *)(v5 + 32) & 4) != 0)
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes(3, *(_QWORD *)(v5 + 16), a2);
  return result;
}

uint64_t sub_1002E4BF4(uint64_t a1, unsigned int a2)
{
  int v3;
  uint64_t v4;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v5;
  uint64_t v6;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v7;
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  char v12;
  uint64_t v13;
  unint64_t v14;
  int v15;

  LOBYTE(v3) = *(_BYTE *)(a1 + 32);
  if (!(_BYTE)v3)
  {
    v4 = 0;
    goto LABEL_29;
  }
  if ((*(_BYTE *)(a1 + 32) & 1) == 0)
  {
    v4 = 0;
    if ((*(_BYTE *)(a1 + 32) & 2) == 0)
      goto LABEL_19;
LABEL_13:
    v6 = *(_QWORD *)(a1 + 8);
    if (!v6)
      v6 = *(_QWORD *)(qword_102310458 + 8);
    v7 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002C6708(v6, a2);
    v8 = (int)v7;
    if (v7 >= 0x80)
      v9 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v7, a2);
    else
      v9 = 1;
    v4 = (v4 + v8 + v9 + 1);
    v3 = *(_DWORD *)(a1 + 32);
    goto LABEL_19;
  }
  v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 24);
  if ((v5 & 0x80000000) != 0)
  {
    v4 = 11;
    if ((v3 & 2) != 0)
      goto LABEL_13;
  }
  else
  {
    if (v5 >= 0x80)
    {
      v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5, a2) + 1;
      v3 = *(_DWORD *)(a1 + 32);
      if ((v3 & 2) == 0)
        goto LABEL_19;
      goto LABEL_13;
    }
    v4 = 2;
    if ((v3 & 2) != 0)
      goto LABEL_13;
  }
LABEL_19:
  if ((v3 & 4) != 0)
  {
    v10 = *(_QWORD *)(a1 + 16);
    v11 = *(unsigned __int8 *)(v10 + 23);
    v12 = v11;
    v13 = *(_QWORD *)(v10 + 8);
    if ((v11 & 0x80u) == 0)
      v14 = *(unsigned __int8 *)(v10 + 23);
    else
      v14 = v13;
    if (v14 >= 0x80)
    {
      v15 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v14, a2);
      v11 = *(unsigned __int8 *)(v10 + 23);
      v13 = *(_QWORD *)(v10 + 8);
      v12 = *(_BYTE *)(v10 + 23);
    }
    else
    {
      v15 = 1;
    }
    if (v12 < 0)
      v11 = v13;
    v4 = (v4 + v15 + v11 + 1);
  }
LABEL_29:
  *(_DWORD *)(a1 + 28) = v4;
  return v4;
}

void sub_1002E4D10(uint64_t a1, void *lpsrc)
{
  uint64_t v4;
  uint64_t v5;

  sub_1002E4514(a1, (uint64_t)lpsrc);
}

void sub_1002E4D5C(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
    sub_1002E4514(a1, a2);
  }
}

uint64_t sub_1002E4D9C()
{
  return 1;
}

_QWORD *sub_1002E4DA4@<X0>(_QWORD *a1@<X8>)
{
  return sub_1015A2E04(a1, "CLMicroLocationProto.AnchorValueStatisticsConfiguration");
}

uint64_t sub_1002E4DB4(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = off_10212DB98;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  sub_1002E4E08(a1, a2);
  return a1;
}

void sub_1002E4DF4(_Unwind_Exception *a1)
{
  wireless_diagnostics::google::protobuf::MessageLite *v1;

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(v1);
  _Unwind_Resume(a1);
}

void sub_1002E4E08(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  _DWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  _BYTE v15[48];

  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage(v15, 3, "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/proto/gen-cpp/microlocation.pb.cc", 21304);
    v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<(v15, "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v14, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v15);
  }
  LOBYTE(v5) = *(_BYTE *)(a2 + 48);
  if (!(_BYTE)v5)
    return;
  if ((*(_BYTE *)(a2 + 48) & 1) != 0)
  {
    v6 = *(_DWORD *)(a2 + 40);
    if (v6 >= 3)
      sub_1018F286C();
    *(_DWORD *)(a1 + 48) |= 1u;
    *(_DWORD *)(a1 + 40) = v6;
    v5 = *(_DWORD *)(a2 + 48);
  }
  if ((v5 & 2) == 0)
  {
    if ((v5 & 4) == 0)
      goto LABEL_9;
LABEL_13:
    *(_DWORD *)(a1 + 48) |= 4u;
    v8 = *(_DWORD **)(a1 + 16);
    if (!v8)
      operator new();
    v9 = *(_QWORD *)(a2 + 16);
    if (!v9)
      v9 = *(_QWORD *)(qword_102310460 + 16);
    sub_1002E378C(v8, v9);
    v5 = *(_DWORD *)(a2 + 48);
    if ((v5 & 8) == 0)
    {
LABEL_10:
      if ((v5 & 0x10) == 0)
        return;
      goto LABEL_23;
    }
    goto LABEL_18;
  }
  v7 = *(_QWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 48) |= 2u;
  *(_QWORD *)(a1 + 8) = v7;
  v5 = *(_DWORD *)(a2 + 48);
  if ((v5 & 4) != 0)
    goto LABEL_13;
LABEL_9:
  if ((v5 & 8) == 0)
    goto LABEL_10;
LABEL_18:
  *(_DWORD *)(a1 + 48) |= 8u;
  v10 = *(_QWORD *)(a1 + 24);
  if (!v10)
    operator new();
  v11 = *(_QWORD *)(a2 + 24);
  if (!v11)
    v11 = *(_QWORD *)(qword_102310460 + 24);
  sub_1002E3E98(v10, v11);
  if ((*(_DWORD *)(a2 + 48) & 0x10) != 0)
  {
LABEL_23:
    *(_DWORD *)(a1 + 48) |= 0x10u;
    v12 = *(_QWORD *)(a1 + 32);
    if (!v12)
      operator new();
    v13 = *(_QWORD *)(a2 + 32);
    if (!v13)
      v13 = *(_QWORD *)(qword_102310460 + 32);
    sub_1002E4514(v12, v13);
  }
}

void sub_1002E501C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

_QWORD *sub_1002E5038(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  if ((_QWORD *)qword_102310460 != result)
  {
    v1 = result;
    v2 = result[2];
    if (v2)
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
    v3 = v1[3];
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
    result = (_QWORD *)v1[4];
    if (result)
      return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 8))(result);
  }
  return result;
}

void sub_1002E50A8(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(_QWORD *)a1 = off_10212DB98;
  sub_1002E5038(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_1002E50D8(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(_QWORD *)a1 = off_10212DB98;
  sub_1002E5038(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete();
}

void sub_1002E511C()
{
  operator new();
}

uint64_t sub_1002E5160(uint64_t result)
{
  uint64_t v1;
  int v2;

  v1 = result;
  LOBYTE(v2) = *(_BYTE *)(result + 48);
  if ((_BYTE)v2)
  {
    *(_DWORD *)(result + 40) = 0;
    *(_QWORD *)(result + 8) = 0;
    if ((v2 & 4) != 0)
    {
      result = *(_QWORD *)(result + 16);
      if (result)
      {
        result = sub_1002E39B8(result);
        v2 = *(_DWORD *)(v1 + 48);
      }
    }
    if ((v2 & 8) != 0)
    {
      result = *(_QWORD *)(v1 + 24);
      if (result)
      {
        result = sub_1002E406C(result);
        v2 = *(_DWORD *)(v1 + 48);
      }
    }
    if ((v2 & 0x10) != 0)
    {
      result = *(_QWORD *)(v1 + 32);
      if (result)
        result = sub_1002E47D0(result);
    }
  }
  *(_DWORD *)(v1 + 48) = 0;
  return result;
}

uint64_t sub_1002E51C8(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  char *v5;
  wireless_diagnostics::google::protobuf::io::CodedInputStream *TagFallback;
  int v7;
  char *v8;
  unsigned int v9;
  int v10;
  uint64_t result;
  _BYTE *v12;
  _BYTE *v13;
  int *v14;
  char *v15;
  int v16;
  int v17;
  int v18;
  unsigned int v19;
  int v20;
  BOOL v21;
  int v22;
  _BYTE *v23;
  uint64_t v24;
  char *v25;
  int v26;
  int v27;
  int v28;
  unsigned int v29;
  int v30;
  int v31;
  _BYTE *v32;
  uint64_t v33;
  char *v34;
  int v35;
  int v36;
  int v37;
  unsigned int v38;
  int v39;
  int v40;
  unsigned int v41[2];

  while (1)
  {
    v5 = (char *)*((_QWORD *)this + 1);
    if ((unint64_t)v5 < *((_QWORD *)this + 2) && (*v5 & 0x80000000) == 0)
    {
      TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((_QWORD *)this + 1) = v5 + 1;
      if (!(_DWORD)TagFallback)
        return 1;
      goto LABEL_6;
    }
    TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
    *((_DWORD *)this + 8) = (_DWORD)TagFallback;
    if (!(_DWORD)TagFallback)
      return 1;
LABEL_6:
    switch(TagFallback >> 3)
    {
      case 1u:
        v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0)
          goto LABEL_19;
        v41[0] = 0;
        v8 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v8 >= *((_QWORD *)this + 2) || *v8 < 0)
        {
          result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v41);
          if (!(_DWORD)result)
            return result;
          v9 = v41[0];
        }
        else
        {
          v9 = *v8;
          *((_QWORD *)this + 1) = v8 + 1;
        }
        if (v9 <= 2)
        {
          *(_DWORD *)(a1 + 48) |= 1u;
          *(_DWORD *)(a1 + 40) = v9;
        }
        v12 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v12 < *((_QWORD *)this + 2) && *v12 == 17)
        {
          *((_QWORD *)this + 1) = v12 + 1;
          goto LABEL_29;
        }
        continue;
      case 2u:
        v7 = TagFallback & 7;
        if (v7 != 1)
          goto LABEL_19;
LABEL_29:
        *(_QWORD *)v41 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, (unint64_t *)v41) & 1) == 0)return 0;
        *(_QWORD *)(a1 + 8) = *(_QWORD *)v41;
        v10 = *(_DWORD *)(a1 + 48) | 2;
        *(_DWORD *)(a1 + 48) = v10;
        v13 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v13 >= *((_QWORD *)this + 2) || *v13 != 34)
          continue;
        *((_QWORD *)this + 1) = v13 + 1;
LABEL_33:
        *(_DWORD *)(a1 + 48) = v10 | 4;
        v14 = *(int **)(a1 + 16);
        if (!v14)
          operator new();
        v41[0] = 0;
        v15 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v15 >= *((_QWORD *)this + 2) || *v15 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v41))return 0;
        }
        else
        {
          v41[0] = *v15;
          *((_QWORD *)this + 1) = v15 + 1;
        }
        v16 = *((_DWORD *)this + 14);
        v17 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v16 + 1;
        if (v16 >= v17)
          return 0;
        v18 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v41[0]);
        if (!sub_1002E3A1C(v14, this, v19) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v18);
        v20 = *((_DWORD *)this + 14);
        v21 = __OFSUB__(v20, 1);
        v22 = v20 - 1;
        if (v22 < 0 == v21)
          *((_DWORD *)this + 14) = v22;
        v23 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v23 >= *((_QWORD *)this + 2) || *v23 != 42)
          continue;
        *((_QWORD *)this + 1) = v23 + 1;
LABEL_47:
        *(_DWORD *)(a1 + 48) |= 8u;
        v24 = *(_QWORD *)(a1 + 24);
        if (!v24)
          operator new();
        v41[0] = 0;
        v25 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v25 >= *((_QWORD *)this + 2) || *v25 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v41))return 0;
        }
        else
        {
          v41[0] = *v25;
          *((_QWORD *)this + 1) = v25 + 1;
        }
        v26 = *((_DWORD *)this + 14);
        v27 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v26 + 1;
        if (v26 >= v27)
          return 0;
        v28 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v41[0]);
        if (!sub_1002E40EC(v24, this, v29) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v28);
        v30 = *((_DWORD *)this + 14);
        v21 = __OFSUB__(v30, 1);
        v31 = v30 - 1;
        if (v31 < 0 == v21)
          *((_DWORD *)this + 14) = v31;
        v32 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v32 >= *((_QWORD *)this + 2) || *v32 != 50)
          continue;
        *((_QWORD *)this + 1) = v32 + 1;
LABEL_61:
        *(_DWORD *)(a1 + 48) |= 0x10u;
        v33 = *(_QWORD *)(a1 + 32);
        if (!v33)
          operator new();
        v41[0] = 0;
        v34 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v34 >= *((_QWORD *)this + 2) || *v34 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v41))return 0;
        }
        else
        {
          v41[0] = *v34;
          *((_QWORD *)this + 1) = v34 + 1;
        }
        v35 = *((_DWORD *)this + 14);
        v36 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v35 + 1;
        if (v35 >= v36)
          return 0;
        v37 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v41[0]);
        if (!sub_1002E488C(v33, this, v38) || !*((_BYTE *)this + 36))
          return 0;
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v37);
        v39 = *((_DWORD *)this + 14);
        v21 = __OFSUB__(v39, 1);
        v40 = v39 - 1;
        if (v40 < 0 == v21)
          *((_DWORD *)this + 14) = v40;
        if (*((_QWORD *)this + 1) == *((_QWORD *)this + 2)
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          result = 1;
          *((_BYTE *)this + 36) = 1;
          return result;
        }
        break;
      case 4u:
        v7 = TagFallback & 7;
        if (v7 != 2)
          goto LABEL_19;
        v10 = *(_DWORD *)(a1 + 48);
        goto LABEL_33;
      case 5u:
        v7 = TagFallback & 7;
        if (v7 == 2)
          goto LABEL_47;
        goto LABEL_19;
      case 6u:
        v7 = TagFallback & 7;
        if (v7 != 2)
          goto LABEL_19;
        goto LABEL_61;
      default:
        v7 = TagFallback & 7;
LABEL_19:
        if (v7 == 4)
          return 1;
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, TagFallback, a3) & 1) == 0)
          return 0;
        continue;
    }
  }
}

uint64_t sub_1002E56D8(uint64_t result, const wireless_diagnostics::google::protobuf::MessageLite *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v5 = result;
  v6 = *(_DWORD *)(result + 48);
  if ((v6 & 1) != 0)
  {
    result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(_DWORD *)(result + 40), (int)a2, a4);
    v6 = *(_DWORD *)(v5 + 48);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0)
        goto LABEL_4;
      goto LABEL_9;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, (int)a2, *(double *)(v5 + 8), a3);
  v6 = *(_DWORD *)(v5 + 48);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0)
      goto LABEL_5;
    goto LABEL_12;
  }
LABEL_9:
  v7 = *(_QWORD *)(v5 + 16);
  if (!v7)
    v7 = *(_QWORD *)(qword_102310460 + 16);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, v7, a2, a4);
  v6 = *(_DWORD *)(v5 + 48);
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0)
      return result;
    goto LABEL_15;
  }
LABEL_12:
  v8 = *(_QWORD *)(v5 + 24);
  if (!v8)
    v8 = *(_QWORD *)(qword_102310460 + 24);
  result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, v8, a2, a4);
  if ((*(_DWORD *)(v5 + 48) & 0x10) != 0)
  {
LABEL_15:
    v9 = *(_QWORD *)(v5 + 32);
    if (!v9)
      v9 = *(_QWORD *)(qword_102310460 + 32);
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, v9, a2, a4);
  }
  return result;
}

uint64_t sub_1002E57B8(uint64_t a1, unint64_t a2)
{
  int v3;
  unsigned int v4;
  uint64_t v5;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v6;
  uint64_t v7;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v8;
  int v9;
  int v10;
  uint64_t v11;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v12;
  int v13;
  int v14;
  uint64_t v15;
  wireless_diagnostics::google::protobuf::io::CodedOutputStream *v16;
  unsigned int v17;
  int v18;
  int v19;

  LOBYTE(v3) = *(_BYTE *)(a1 + 48);
  if (!(_BYTE)v3)
  {
    v5 = 0;
    goto LABEL_35;
  }
  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 40);
    if ((v6 & 0x80000000) != 0)
    {
      v4 = 11;
    }
    else if (v6 >= 0x80)
    {
      v4 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6, a2) + 1;
      v3 = *(_DWORD *)(a1 + 48);
    }
    else
    {
      v4 = 2;
    }
  }
  else
  {
    v4 = 0;
  }
  if ((v3 & 2) != 0)
    v5 = v4 + 9;
  else
    v5 = v4;
  if ((v3 & 4) != 0)
  {
    v7 = *(_QWORD *)(a1 + 16);
    if (!v7)
      v7 = *(_QWORD *)(qword_102310460 + 16);
    v8 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002E3D3C(v7, a2);
    v9 = (int)v8;
    if (v8 >= 0x80)
      v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v8, a2);
    else
      v10 = 1;
    v5 = (v5 + v9 + v10 + 1);
    v3 = *(_DWORD *)(a1 + 48);
    if ((v3 & 8) == 0)
    {
LABEL_15:
      if ((v3 & 0x10) == 0)
        goto LABEL_35;
      goto LABEL_29;
    }
  }
  else if ((v3 & 8) == 0)
  {
    goto LABEL_15;
  }
  v11 = *(_QWORD *)(a1 + 24);
  if (!v11)
    v11 = *(_QWORD *)(qword_102310460 + 24);
  v12 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002E43AC(v11, a2);
  v13 = (int)v12;
  if (v12 >= 0x80)
    v14 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v12, a2);
  else
    v14 = 1;
  v5 = (v5 + v13 + v14 + 1);
  if ((*(_DWORD *)(a1 + 48) & 0x10) != 0)
  {
LABEL_29:
    v15 = *(_QWORD *)(a1 + 32);
    if (!v15)
      v15 = *(_QWORD *)(qword_102310460 + 32);
    v16 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1002E4BF4(v15, a2);
    v18 = (int)v16;
    if (v16 >= 0x80)
      v19 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v16, v17);
    else
      v19 = 1;
    v5 = (v5 + v18 + v19 + 1);
  }
LABEL_35:
  *(_DWORD *)(a1 + 44) = v5;
  return v5;
}

void sub_1002E5918(uint64_t a1, void *lpsrc)
{
  uint64_t v4;
  uint64_t v5;

  sub_1002E4E08(a1, (uint64_t)lpsrc);
}

void sub_1002E5964(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
    sub_1002E4E08(a1, a2);
  }
}

uint64_t sub_1002E59A4()
{
  return 1;
}

_QWORD *sub_1002E59AC@<X0>(_QWORD *a1@<X8>)
{
  return sub_1015A2E04(a1, "CLMicroLocationProto.Configuration");
}

_QWORD *sub_1002E59BC(_QWORD *a1, uint64_t a2)
{
  *a1 = off_10212DC10;
  a1[1] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  a1[2] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
  a1[3] = 0;
  sub_1002E5A0C((uint64_t)a1, a2);
  return a1;
}

void sub_1002E59F8(_Unwind_Exception *a1)
{
  wireless_diagnostics::google::protobuf::MessageLite *v1;

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(v1);
  _Unwind_Resume(a1);
}

void sub_1002E5A0C(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  const std::string *v6;
  std::string *v7;
  const std::string *v8;
  std::string *v9;
  char v10;
  _BYTE v11[48];

  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage(v11, 3, "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/proto/gen-cpp/microlocation.pb.cc", 21530);
    v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<(v11, "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v10, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v11);
  }
  LOBYTE(v5) = *(_BYTE *)(a2 + 28);
  if ((_BYTE)v5)
  {
    if ((*(_BYTE *)(a2 + 28) & 1) != 0)
    {
      v6 = *(const std::string **)(a2 + 8);
      *(_DWORD *)(a1 + 28) |= 1u;
      v7 = *(std::string **)(a1 + 8);
      if (v7 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
        operator new();
      std::string::operator=(v7, v6);
      v5 = *(_DWORD *)(a2 + 28);
    }
    if ((v5 & 2) != 0)
    {
      v8 = *(const std::string **)(a2 + 16);
      *(_DWORD *)(a1 + 28) |= 2u;
      v9 = *(std::string **)(a1 + 16);
      if (v9 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
        operator new();
      std::string::operator=(v9, v8);
    }
  }
}

void sub_1002E5B2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void sub_1002E5B48(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(_QWORD *)a1 = off_10212DC10;
  sub_1002D3BAC((uint64_t)a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_1002E5B78(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(_QWORD *)a1 = off_10212DC10;
  sub_1002D3BAC((uint64_t)a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete();
}

void sub_1002E5BBC()
{
  operator new();
}

uint64_t sub_1002E5BFC(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;

  if (*(_BYTE *)(result + 28))
  {
    if ((*(_BYTE *)(result + 28) & 1) != 0)
    {
      v1 = *(_QWORD *)(result + 8);
      if ((_UNKNOWN *)v1 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v1 + 23) < 0)
        {
          **(_BYTE **)v1 = 0;
          *(_QWORD *)(v1 + 8) = 0;
        }
        else
        {
          *(_BYTE *)v1 = 0;
          *(_BYTE *)(v1 + 23) = 0;
        }
      }
    }
    if ((*(_BYTE *)(result + 28) & 2) != 0)
    {
      v2 = *(_QWORD *)(result + 16);
      if ((_UNKNOWN *)v2 != &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      {
        if (*(char *)(v2 + 23) < 0)
        {
          **(_BYTE **)v2 = 0;
          *(_QWORD *)(v2 + 8) = 0;
        }
        else
        {
          *(_BYTE *)v2 = 0;
          *(_BYTE *)(v2 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(result + 28) = 0;
  return result;
}

uint64_t sub_1002E5C78(uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  char *v5;
  wireless_diagnostics::google::protobuf::io::CodedInputStream *TagFallback;
  int v7;
  void *v8;
  uint64_t result;
  _BYTE *v10;
  void *v11;

  do
  {
    while (1)
    {
      while (1)
      {
        v5 = (char *)*((_QWORD *)this + 1);
        if ((unint64_t)v5 >= *((_QWORD *)this + 2) || *v5 < 0)
        {
          TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
          *((_DWORD *)this + 8) = (_DWORD)TagFallback;
          if (!(_DWORD)TagFallback)
            return 1;
        }
        else
        {
          TagFallback = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
          *((_DWORD *)this + 8) = (_DWORD)TagFallback;
          *((_QWORD *)this + 1) = v5 + 1;
          if (!(_DWORD)TagFallback)
            return 1;
        }
        if (TagFallback >> 3 != 1)
          break;
        v7 = TagFallback & 7;
        if (v7 != 2)
          goto LABEL_25;
        *(_DWORD *)(a1 + 28) |= 1u;
        v8 = *(void **)(a1 + 8);
        if (v8 == &wireless_diagnostics::google::protobuf::internal::kEmptyString)
          operator new();
        result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes(this, v8);
        if (!(_DWORD)result)
          return result;
        v10 = (_BYTE *)*((_QWORD *)this + 1);
        if ((unint64_t)v10 < *((_QWORD *)this + 2) && *v10 == 18)
        {
          *((_QWORD *)this + 1) = v10 + 1;
          goto LABEL_17;
        }
      }
      if (TagFallback >> 3 != 2)
      {
        v7 = TagFallback & 7;
        goto LABEL_25;
      }
      v7 = TagFallback & 7;
      if (v7 == 2)
        break;
LABEL_25:
      if (v7 == 4)
        return 1;
      if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(this, TagFallback, a3) & 1) == 0)
        return 0;
    }
LABEL_17:
    *(_DWORD *)(a1 + 28) |= 2u;
    v11 = *(void **)(a1 + 16);
    if (v11 == &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      operator new();
    result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString(this, v11);
    if (!(_DWORD)result)
      return result;
  }
  while (*((_QWORD *)this + 1) != *((_QWORD *)this + 2)
       || !*((_DWORD *)this + 11) && *((_DWORD *)this + 6) != *((_DWORD *)this + 10));
  *((_DWORD *)this + 8) = 0;
  result = 1;
  *((_BYTE *)this + 36) = 1;
  return result;
}

uint64_t sub_1002E5E2C(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  int v4;

  v3 = result;
  v4 = *(_DWORD *)(result + 28);
  if ((v4 & 1) != 0)
  {
    result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes(1, *(_QWORD *)(result + 8), a2);
    v4 = *(_DWORD *)(v3 + 28);
  }
  if ((v4 & 2) != 0)
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString(2, *(_QWORD *)(v3 + 16), a2);
  return result;
}

uint64_t sub_1002E5E84(uint64_t a1, unsigned int a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  char v7;
  uint64_t v8;
  unint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  char v14;
  uint64_t v15;
  unint64_t v16;
  int v17;

  LOBYTE(v3) = *(_BYTE *)(a1 + 28);
  if (!(_BYTE)v3)
  {
    v4 = 0;
    goto LABEL_24;
  }
  if ((*(_BYTE *)(a1 + 28) & 1) == 0)
  {
    v4 = 0;
    if ((*(_BYTE *)(a1 + 28) & 2) == 0)
      goto LABEL_24;
    goto LABEL_15;
  }
  v5 = *(_QWORD *)(a1 + 8);
  v6 = *(unsigned __int8 *)(v5 + 23);
  v7 = v6;
  v8 = *(_QWORD *)(v5 + 8);
  if ((v6 & 0x80u) == 0)
    v9 = *(unsigned __int8 *)(v5 + 23);
  else
    v9 = v8;
  if (v9 >= 0x80)
  {
    v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v9, a2);
    v6 = *(unsigned __int8 *)(v5 + 23);
    v8 = *(_QWORD *)(v5 + 8);
    v10 = v11 + 1;
    v3 = *(_DWORD *)(a1 + 28);
    v7 = *(_BYTE *)(v5 + 23);
  }
  else
  {
    v10 = 2;
  }
  if (v7 < 0)
    v6 = v8;
  v4 = (v10 + v6);
  if ((v3 & 2) != 0)
  {
LABEL_15:
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(unsigned __int8 *)(v12 + 23);
    v14 = v13;
    v15 = *(_QWORD *)(v12 + 8);
    if ((v13 & 0x80u) == 0)
      v16 = *(unsigned __int8 *)(v12 + 23);
    else
      v16 = v15;
    if (v16 >= 0x80)
    {
      v17 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v16, a2);
      v13 = *(unsigned __int8 *)(v12 + 23);
      v15 = *(_QWORD *)(v12 + 8);
      v14 = *(_BYTE *)(v12 + 23);
    }
    else
    {
      v17 = 1;
    }
    if (v14 < 0)
      v13 = v15;
    v4 = (v4 + v17 + v13 + 1);
  }
LABEL_24:
  *(_DWORD *)(a1 + 24) = v4;
  return v4;
}

void sub_1002E5F74(uint64_t a1, void *lpsrc)
{
  uint64_t v4;
  uint64_t v5;

  sub_1002E5A0C(a1, (uint64_t)lpsrc);
}

void sub_1002E5FC0(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
    sub_1002E5A0C(a1, a2);
  }
}

uint64_t sub_1002E6000()
{
  return 1;
}

_QWORD *sub_1002E6008@<X0>(_QWORD *a1@<X8>)
{
  return sub_1015A2E04(a1, "CLMicroLocationProto.RapportDevice");
}

uint64_t sub_1002E6018(uint64_t a1)
{
  return *(unsigned int *)(a1 + 60);
}

uint64_t sub_1002E6020(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

uint64_t sub_1002E6028(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

uint64_t sub_1002E6030(uint64_t a1)
{
  return *(unsigned int *)(a1 + 52);
}

uint64_t sub_1002E6038(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1002E6040(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t sub_1002E6048(uint64_t a1)
{
  return *(unsigned int *)(a1 + 100);
}

uint64_t sub_1002E6050(uint64_t a1)
{
  return *(unsigned int *)(a1 + 72);
}

uint64_t sub_1002E6058(uint64_t a1)
{
  return *(unsigned int *)(a1 + 188);
}

uint64_t sub_1002E6060(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

uint64_t sub_1002E6068(uint64_t a1)
{
  return *(unsigned int *)(a1 + 112);
}

uint64_t sub_1002E6070(uint64_t a1)
{
  return *(unsigned int *)(a1 + 80);
}

uint64_t sub_1002E6078(uint64_t a1)
{
  return *(unsigned int *)(a1 + 64);
}

uint64_t sub_1002E6080(uint64_t a1)
{
  return *(unsigned int *)(a1 + 28);
}

uint64_t sub_1002E6088(uint64_t a1)
{
  return *(unsigned int *)(a1 + 288);
}

uint64_t sub_1002E6090(uint64_t a1)
{
  return *(unsigned int *)(a1 + 124);
}

uint64_t sub_1002E6098(uint64_t a1)
{
  return *(unsigned int *)(a1 + 76);
}

uint64_t sub_1002E60A0(uint64_t result, int a2)
{
  int v2;
  int v3;

  v2 = *(_DWORD *)(result + 12);
  if (v2 < a2)
  {
    v3 = 2 * v2;
    if (v3 <= a2)
      v3 = a2;
    if (v3 <= 4)
      v3 = 4;
    *(_DWORD *)(result + 12) = v3;
    operator new[]();
  }
  return result;
}

uint64_t sub_1002E6138(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;

  if (*(int *)(result + 8) >= 1)
  {
    v1 = 0;
    do
    {
      v2 = *(_QWORD *)(*(_QWORD *)result + 8 * v1);
      if (*(char *)(v2 + 23) < 0)
      {
        **(_BYTE **)v2 = 0;
        *(_QWORD *)(v2 + 8) = 0;
      }
      else
      {
        *(_BYTE *)v2 = 0;
        *(_BYTE *)(v2 + 23) = 0;
      }
      ++v1;
    }
    while (v1 < *(int *)(result + 8));
  }
  *(_DWORD *)(result + 8) = 0;
  return result;
}

uint64_t sub_1002E6188(int *a1)
{
  uint64_t v2;
  uint64_t result;

  if (a1[3] >= 1)
  {
    v2 = 0;
    do
      wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase::Delete(*(_QWORD *)(*(_QWORD *)a1
                                                                                                + 8 * v2++));
    while (v2 < a1[3]);
  }
  result = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
    operator delete[]();
  return result;
}

void sub_1002E61F4(wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;

  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(a1, *(_DWORD *)(a2 + 8) + *((_DWORD *)a1 + 2));
  if (*(int *)(a2 + 8) >= 1)
  {
    v4 = 0;
    do
    {
      v5 = *(_QWORD *)(*(_QWORD *)a2 + 8 * v4);
      v6 = *((_DWORD *)a1 + 3);
      v7 = *((int *)a1 + 2);
      if ((int)v7 >= v6)
      {
        if (v6 == *((_DWORD *)a1 + 4))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(a1, v6 + 1);
          v6 = *((_DWORD *)a1 + 3);
        }
        *((_DWORD *)a1 + 3) = v6 + 1;
        operator new();
      }
      v8 = *(_QWORD *)a1;
      *((_DWORD *)a1 + 2) = v7 + 1;
      sub_1002C2684(*(_QWORD *)(v8 + 8 * v7), v5);
      ++v4;
    }
    while (v4 < *(int *)(a2 + 8));
  }
}

void sub_1002E6310(wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;

  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(a1, *(_DWORD *)(a2 + 8) + *((_DWORD *)a1 + 2));
  if (*(int *)(a2 + 8) >= 1)
  {
    v4 = 0;
    do
    {
      v5 = *(_QWORD *)(*(_QWORD *)a2 + 8 * v4);
      v6 = *((_DWORD *)a1 + 3);
      v7 = *((int *)a1 + 2);
      if ((int)v7 >= v6)
      {
        if (v6 == *((_DWORD *)a1 + 4))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(a1, v6 + 1);
          v6 = *((_DWORD *)a1 + 3);
        }
        *((_DWORD *)a1 + 3) = v6 + 1;
        operator new();
      }
      v8 = *(_QWORD *)a1;
      *((_DWORD *)a1 + 2) = v7 + 1;
      sub_1002C3E28(*(_QWORD *)(v8 + 8 * v7), v5);
      ++v4;
    }
    while (v4 < *(int *)(a2 + 8));
  }
}

void sub_1002E643C(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 348, a4);
}

char *sub_1002E6448@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[31] < 0)
    return (char *)sub_100115CE4((_BYTE *)a2, *((void **)result + 1), *((_QWORD *)result + 2));
  *(_OWORD *)a2 = *(_OWORD *)(result + 8);
  *(_QWORD *)(a2 + 16) = *((_QWORD *)result + 3);
  return result;
}

uint64_t sub_1002E6474(uint64_t a1, char a2)
{
  NSObject *v4;
  _DWORD v6[2];
  __int16 v7;
  const char *v8;

  *(_QWORD *)a1 = off_10212E2B8;
  sub_1015A2E04((_QWORD *)(a1 + 8), "No Name Given");
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 48) = a1 + 56;
  *(_BYTE *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E308);
  v4 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
  {
    v6[0] = 68289026;
    v6[1] = 0;
    v7 = 2082;
    v8 = "";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"StateBase\"}", (uint8_t *)v6, 0x12u);
  }
  *(_BYTE *)(a1 + 32) = a2;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  sub_100090AE4(a1 + 48, *(char **)(a1 + 56));
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 48) = a1 + 56;
  *(_QWORD *)(a1 + 80) = 0;
  return a1;
}

uint64_t sub_1002E65BC(uint64_t a1)
{
  NSObject *v2;
  char *v3;
  _DWORD v5[2];
  __int16 v6;
  const char *v7;

  *(_QWORD *)a1 = off_10212E2B8;
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E308);
  v2 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
  {
    v5[0] = 68289026;
    v5[1] = 0;
    v6 = 2082;
    v7 = "";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"~StateBase\"}", (uint8_t *)v5, 0x12u);
  }
  v3 = *(char **)(a1 + 56);
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  sub_100090AE4(a1 + 48, v3);
  *(_QWORD *)(a1 + 48) = a1 + 56;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  sub_100090AE4(a1 + 48, 0);
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  return a1;
}

void sub_1002E66F4(uint64_t a1)
{
  sub_1002E65BC(a1);
  operator delete();
}

_QWORD *sub_1002E6718(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  *a1 = &off_10212E2D8;
  a1[4] = 0;
  a1[3] = 0;
  v2 = a1 + 3;
  a1[2] = a1 + 3;
  v3 = a1 + 2;
  sub_1002E6C64((uint64_t)(a1 + 2), 0);
  a1[4] = 0;
  a1[5] = 0;
  *v3 = v2;
  *v2 = 0;
  a1[1] = 0;
  a1[6] = 0;
  return a1;
}

_QWORD *sub_1002E6784(_QWORD *a1)
{
  NSObject *v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  BOOL v7;
  _DWORD v9[2];
  __int16 v10;
  const char *v11;

  *a1 = &off_10212E2D8;
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E308);
  v2 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
  {
    v9[0] = 68289026;
    v9[1] = 0;
    v10 = 2082;
    v11 = "";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"~StateMachineBase\"}", (uint8_t *)v9, 0x12u);
  }
  v3 = (_QWORD *)a1[2];
  if (v3 != a1 + 3)
  {
    do
    {
      v4 = v3[7];
      v3[7] = 0;
      if (v4)
        (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
      v5 = (_QWORD *)v3[1];
      if (v5)
      {
        do
        {
          v6 = v5;
          v5 = (_QWORD *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          v6 = (_QWORD *)v3[2];
          v7 = *v6 == (_QWORD)v3;
          v3 = v6;
        }
        while (!v7);
      }
      v3 = v6;
    }
    while (v6 != a1 + 3);
  }
  a1[1] = 0;
  a1[5] = 0;
  a1[6] = 0;
  sub_1002E6C64((uint64_t)(a1 + 2), (_QWORD *)a1[3]);
  return a1;
}

uint64_t sub_1002E68F0(uint64_t a1, __int128 *a2, uint64_t *a3)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t result;
  __int128 *v7;

  v7 = a2;
  v4 = sub_1002E6CF8((uint64_t **)(a1 + 16), (const void **)a2, (uint64_t)&unk_101B9EB60, &v7);
  v5 = *a3;
  *a3 = 0;
  result = v4[7];
  v4[7] = v5;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1002E6954(_QWORD *a1, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t *v7;
  NSObject *v8;
  void *__p[2];
  uint64_t v10;
  uint8_t buf[4];
  int v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  uint64_t *v16;

  v2 = a2;
  if (*((char *)a2 + 23) < 0)
  {
    sub_100115CE4(__p, (void *)*a2, a2[1]);
  }
  else
  {
    *(_OWORD *)__p = *(_OWORD *)a2;
    v10 = a2[2];
  }
  v4 = sub_10019C4C0((uint64_t)(a1 + 2), (const void **)__p);
  if (a1 + 3 == (_QWORD *)v4)
    v5 = 0;
  else
    v5 = *(_QWORD *)(v4 + 56);
  if (SHIBYTE(v10) < 0)
  {
    operator delete(__p[0]);
    if (v5)
      goto LABEL_9;
  }
  else if (v5)
  {
LABEL_9:
    sub_100157578(a1, v5);
    return;
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E308);
  v6 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
  {
    v7 = v2;
    if (*((char *)v2 + 23) < 0)
      v7 = (uint64_t *)*v2;
    *(_DWORD *)buf = 68289283;
    v12 = 0;
    v13 = 2082;
    v14 = "";
    v15 = 2081;
    v16 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"State Machine: Failed to initialize state because requested state doesn't exist in the state table\", \"State\":%{private, location:escape_only}s}", buf, 0x1Cu);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E308);
  }
  v8 = qword_1022A00F8;
  if (os_signpost_enabled((os_log_t)qword_1022A00F8))
  {
    if (*((char *)v2 + 23) < 0)
      v2 = (uint64_t *)*v2;
    *(_DWORD *)buf = 68289283;
    v12 = 0;
    v13 = 2082;
    v14 = "";
    v15 = 2081;
    v16 = v2;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v8, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "State Machine: Failed to initialize state because requested state doesn't exist in the state table", "{\"msg%{public}.0s\":\"State Machine: Failed to initialize state because requested state doesn't exist in the state table\", \"State\":%{private, location:escape_only}s}", buf, 0x1Cu);
  }
}

void sub_1002E6B6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  _Unwind_Resume(exception_object);
}

BOOL sub_1002E6B90(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  int v11;
  BOOL v13;
  BOOL v14;

  v2 = a1[24];
  if (a1[24])
  {
    v3 = a1[23];
    if ((v3 & 0x80u) == 0)
      v4 = a1[23];
    else
      v4 = *((_QWORD *)a1 + 1);
    v5 = a2[23];
    v6 = (char)v5;
    if ((v5 & 0x80u) != 0)
      v5 = *((_QWORD *)a2 + 1);
    if (v4 == v5)
    {
      if (v6 < 0)
        a2 = *(unsigned __int8 **)a2;
      if ((v3 & 0x80) != 0)
      {
        return memcmp(*(const void **)a1, a2, *((_QWORD *)a1 + 1)) == 0;
      }
      else if (a1[23])
      {
        v7 = v3 - 1;
        do
        {
          v9 = *a1++;
          v8 = v9;
          v11 = *a2++;
          v10 = v11;
          v13 = v7-- != 0;
          v14 = v8 == v10;
          v2 = v8 == v10;
        }
        while (v14 && v13);
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

void sub_1002E6C38(id a1)
{
  qword_1022A00F8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_1002E6C64(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    sub_1002E6C64(a1, *a2);
    sub_1002E6C64(a1, a2[1]);
    sub_1002E6CAC((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void sub_1002E6CAC(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

uint64_t *sub_1002E6CF8(uint64_t **a1, const void **a2, uint64_t a3, __int128 **a4)
{
  uint64_t **v6;
  uint64_t *v7;
  uint64_t **v8;
  uint64_t *v10[3];
  uint64_t v11;

  v6 = (uint64_t **)sub_10019C424((uint64_t)a1, &v11, a2);
  v7 = *v6;
  if (!*v6)
  {
    v8 = v6;
    sub_1002E6DA0((uint64_t)a1, a4, (uint64_t)v10);
    sub_1000145B0(a1, v11, v8, v10[0]);
    v7 = v10[0];
    v10[0] = 0;
    sub_1002E6E30((uint64_t)v10, 0);
  }
  return v7;
}

_BYTE *sub_1002E6DA0@<X0>(uint64_t a1@<X0>, __int128 **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5;
  char *v6;
  _BYTE *result;
  __int128 *v8;
  __int128 v9;

  v5 = a1 + 8;
  v6 = (char *)operator new(0x40uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  result = v6 + 32;
  v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    result = sub_100115CE4(result, *(void **)v8, *((_QWORD *)v8 + 1));
  }
  else
  {
    v9 = *v8;
    *((_QWORD *)v6 + 6) = *((_QWORD *)v8 + 2);
    *(_OWORD *)result = v9;
  }
  *((_QWORD *)v6 + 7) = 0;
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_1002E6E18(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1002E6E30(v1, 0);
  _Unwind_Resume(a1);
}

void sub_1002E6E30(uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      sub_1002E6CAC((uint64_t)v2 + 32);
    operator delete(v2);
  }
}

_QWORD *sub_1002E6E74@<X0>(int a1@<W0>, _QWORD *a2@<X8>)
{
  return sub_1015A2E04(a2, (&off_10212E390)[a1]);
}

id sub_1002E6E88(int a1, void *a2, const std::string *a3)
{
  id v5;
  std::string *p_p;
  std::string *v7;
  std::string __p;

  if (!a1)
    return 0;
  v5 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
  sub_10035A2D8(a2, (uint64_t)&__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  objc_msgSend(v5, "setObject:forKeyedSubscript:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", p_p), CFSTR("domain"));
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  objc_msgSend(v5, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("cancelled"));
  objc_msgSend(v5, "setObject:forKeyedSubscript:", &__kCFBooleanFalse, CFSTR("valid"));
  if (a3[1].__r_.__value_.__s.__data_[0])
  {
    sub_1002B88C8(a3, &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v7 = &__p;
    else
      v7 = (std::string *)__p.__r_.__value_.__r.__words[0];
    objc_msgSend(v5, "setObject:forKeyedSubscript:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v7), CFSTR("clientIdentifier"));
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v5;
}

void sub_1002E6FBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002E6FDC(uint64_t result, _QWORD *a2, _QWORD *a3, char a4, double a5)
{
  void *v8;
  unint64_t v9;
  unint64_t v10;
  double v11;
  _QWORD *v12;
  int *v13;
  int *v14;
  int *v15;
  int *v16;
  int v17;
  int *v18;
  int *v19;
  int *v20;
  int *v21;
  int v22;
  _QWORD **v23;
  _QWORD *v24;
  _QWORD **v25;
  int v26;
  _QWORD *v27;
  int *v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  _QWORD v39[13];
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t *v43;
  _QWORD *v44[2];
  uint64_t *v45;
  _QWORD *v46[2];
  uint64_t *v47;
  _QWORD *v48[2];
  double v49;
  double v50;
  double v51;
  double v52;
  double v53;
  __int128 v54;
  __int128 v55;
  int v56;
  double v57;
  int *v58;

  v57 = a5;
  if (result)
  {
    v8 = (void *)result;
    v54 = 0u;
    v55 = 0u;
    v56 = 1065353216;
    v9 = sub_100345FC0(a2);
    if (a4)
      v9 += sub_100345FC0(a3);
    objc_msgSend(v8, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v9), CFSTR("numFingerprints"));
    if (5 * (v9 / 5) >= 0x1F4)
      v10 = 500;
    else
      v10 = 5 * (v9 / 5);
    objc_msgSend(v8, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v10), CFSTR("numFingerprintsBounded"));
    if (v9)
    {
      v52 = 1.79769313e308;
      v53 = -1.79769313e308;
      v50 = 1.79769313e308;
      v51 = -1.79769313e308;
      v48[1] = 0;
      v49 = 0.0;
      v47 = (uint64_t *)v48;
      v48[0] = 0;
      v46[0] = 0;
      v46[1] = 0;
      v44[1] = 0;
      v45 = (uint64_t *)v46;
      v43 = (uint64_t *)v44;
      v44[0] = 0;
      v41 = -1;
      v42 = 0;
      v40 = 0;
      v39[0] = &v57;
      v39[1] = &v54;
      v39[2] = &v53;
      v39[3] = &v52;
      v39[4] = &v51;
      v39[5] = &v50;
      v39[6] = &v49;
      v39[7] = &v47;
      v39[8] = &v45;
      v39[9] = &v43;
      v39[10] = &v42;
      v39[11] = &v41;
      v39[12] = &v40;
      sub_1002E7894((uint64_t)v39, a2);
      if (a4)
        sub_1002E7894((uint64_t)v39, a3);
      objc_msgSend(v8, "setObject:forKeyedSubscript:", +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v53), CFSTR("ageOfOldestFingerprint"));
      objc_msgSend(v8, "setObject:forKeyedSubscript:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", (int)v53), CFSTR("ageOfOldestFingerprintBounded"));
      objc_msgSend(v8, "setObject:forKeyedSubscript:", +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v52), CFSTR("ageOfNewestFingerprint"));
      objc_msgSend(v8, "setObject:forKeyedSubscript:", +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v51), CFSTR("maxFingerprintDuration"));
      objc_msgSend(v8, "setObject:forKeyedSubscript:", +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v50), CFSTR("minFingerprintDuration"));
      v11 = (double)v9;
      objc_msgSend(v8, "setObject:forKeyedSubscript:", +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v49 / (double)v9), CFSTR("avgFingerprintDuration"));
      objc_msgSend(v8, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v42), CFSTR("maxFingerprintSize"));
      objc_msgSend(v8, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v41), CFSTR("minFingerprintSize"));
      objc_msgSend(v8, "setObject:forKeyedSubscript:", +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", (double)v40 / (double)v9), CFSTR("avgFingerprintSize"));
      v12 = v44[0];
      if (v44[0])
      {
        v13 = (int *)v44;
        v14 = (int *)v44[0];
        do
        {
          v15 = v14;
          v16 = v13;
          v17 = v14[8];
          if (v17 >= 1)
            v13 = v14;
          else
            v14 += 2;
          v14 = *(int **)v14;
        }
        while (v14);
        if (v13 != (int *)v44)
        {
          if (v17 < 1)
            v15 = v16;
          if (v15[8] <= 1)
          {
            v38 = 1;
            v58 = &v38;
            objc_msgSend(v8, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_100041CE0(&v47, &v38, (uint64_t)&unk_101B9EB60, &v58)[5]), CFSTR("maxWifiFingerprintSize"));
            v38 = 1;
            v58 = &v38;
            objc_msgSend(v8, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_100041CE0(&v45, &v38, (uint64_t)&unk_101B9EB60, &v58)[5]), CFSTR("minWifiFingerprintSize"));
            v38 = 1;
            v58 = &v38;
            objc_msgSend(v8, "setObject:forKeyedSubscript:", +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", (double)(unint64_t)sub_100041CE0(&v43, &v38, (uint64_t)&unk_101B9EB60, &v58)[5] / v11), CFSTR("avgWifiFingerprintSize"));
            v12 = v44[0];
          }
        }
        if (v12)
        {
          v18 = (int *)v44;
          v19 = (int *)v12;
          do
          {
            v20 = v19;
            v21 = v18;
            v22 = v19[8];
            if (v22 >= 5)
              v18 = v19;
            else
              v19 += 2;
            v19 = *(int **)v19;
          }
          while (v19);
          if (v18 != (int *)v44)
          {
            if (v22 < 5)
              v20 = v21;
            if (v20[8] <= 5)
            {
              v38 = 5;
              v58 = &v38;
              objc_msgSend(v8, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_100041CE0(&v47, &v38, (uint64_t)&unk_101B9EB60, &v58)[5]), CFSTR("maxBleFingerprintSize"));
              v38 = 5;
              v58 = &v38;
              objc_msgSend(v8, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_100041CE0(&v45, &v38, (uint64_t)&unk_101B9EB60, &v58)[5]), CFSTR("minBleFingerprintSize"));
              v38 = 5;
              v58 = &v38;
              objc_msgSend(v8, "setObject:forKeyedSubscript:", +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", (double)(unint64_t)sub_100041CE0(&v43, &v38, (uint64_t)&unk_101B9EB60, &v58)[5] / v11), CFSTR("avgBleFingerprintSize"));
              v12 = v44[0];
            }
          }
          if (v12)
          {
            v23 = v44;
            do
            {
              v24 = v12;
              v25 = v23;
              v26 = *((_DWORD *)v12 + 8);
              v27 = v12 + 1;
              if (v26 >= 6)
              {
                v27 = v24;
                v23 = (_QWORD **)v24;
              }
              v12 = (_QWORD *)*v27;
            }
            while (v12);
            if (v23 != v44)
            {
              v28 = (int *)(v26 >= 6 ? v24 : v25);
              if (v28[8] <= 6)
              {
                v38 = 6;
                v58 = &v38;
                objc_msgSend(v8, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_100041CE0(&v47, &v38, (uint64_t)&unk_101B9EB60, &v58)[5]), CFSTR("maxUwbFingerprintSize"));
                v38 = 6;
                v58 = &v38;
                objc_msgSend(v8, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_100041CE0(&v45, &v38, (uint64_t)&unk_101B9EB60, &v58)[5]), CFSTR("minUwbFingerprintSize"));
                v38 = 6;
                v58 = &v38;
                objc_msgSend(v8, "setObject:forKeyedSubscript:", +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", (double)(unint64_t)sub_100041CE0(&v43, &v38, (uint64_t)&unk_101B9EB60, &v58)[5] / v11), CFSTR("avgUwbFingerprintSize"));
              }
            }
          }
        }
      }
      v29 = (uint64_t *)v55;
      if ((_QWORD)v55)
      {
        v30 = 0;
        do
        {
          if (*((_DWORD *)v29 + 6) == 1)
            ++v30;
          v29 = (uint64_t *)*v29;
        }
        while (v29);
      }
      else
      {
        v30 = 0;
      }
      objc_msgSend(v8, "setObject:forKeyedSubscript:", +[NSNumber numberWithLong:](NSNumber, "numberWithLong:", v30), CFSTR("numSourcesWifi"));
      if ((unint64_t)(5 * (v30 / 5)) >= 0x64)
        v31 = 100;
      else
        v31 = 5 * (v30 / 5);
      objc_msgSend(v8, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v31), CFSTR("numSourcesWifiBounded"));
      v32 = (uint64_t *)v55;
      if ((_QWORD)v55)
      {
        v33 = 0;
        do
        {
          if (*((_DWORD *)v32 + 6) == 5)
            ++v33;
          v32 = (uint64_t *)*v32;
        }
        while (v32);
      }
      else
      {
        v33 = 0;
      }
      objc_msgSend(v8, "setObject:forKeyedSubscript:", +[NSNumber numberWithLong:](NSNumber, "numberWithLong:", v33), CFSTR("numSourcesBle"));
      if (v33 >= 15)
        v34 = 15;
      else
        v34 = v33;
      objc_msgSend(v8, "setObject:forKeyedSubscript:", +[NSNumber numberWithLong:](NSNumber, "numberWithLong:", v34), CFSTR("numSourcesBleBounded"));
      v35 = (uint64_t *)v55;
      if ((_QWORD)v55)
      {
        v36 = 0;
        do
        {
          if (*((_DWORD *)v35 + 6) == 6)
            ++v36;
          v35 = (uint64_t *)*v35;
        }
        while (v35);
      }
      else
      {
        v36 = 0;
      }
      objc_msgSend(v8, "setObject:forKeyedSubscript:", +[NSNumber numberWithLong:](NSNumber, "numberWithLong:", v36), CFSTR("numSourcesUwb"));
      if (v36 >= 15)
        v37 = 15;
      else
        v37 = v36;
      objc_msgSend(v8, "setObject:forKeyedSubscript:", +[NSNumber numberWithLong:](NSNumber, "numberWithLong:", v37), CFSTR("numSourcesUwbBounded"));
      sub_100008848((uint64_t)&v43, v44[0]);
      sub_100008848((uint64_t)&v45, v46[0]);
      sub_100008848((uint64_t)&v47, v48[0]);
    }
    return sub_100271390((uint64_t)&v54);
  }
  return result;
}

void sub_1002E781C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,char a33)
{
  _QWORD **v33;
  uint64_t v34;

  sub_100008848((uint64_t)&a27, v33[1]);
  sub_100008848((uint64_t)&a30, v33[4]);
  sub_100008848((uint64_t)&a33, v33[7]);
  sub_100271390(v34 - 160);
  _Unwind_Resume(a1);
}

BOOL sub_1002E7894(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  _BOOL8 result;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  double *v10;
  double *v11;
  double v12;
  double *v13;
  double v14;
  double *v15;
  uint64_t *v16;
  double v17;
  double v18;
  double *v19;
  uint64_t *v20;
  double v21;
  uint64_t *v22;
  double v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  int *i;
  int *v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  int v34;
  BOOL v35;
  uint64_t *v36;
  uint64_t **v37;
  uint64_t *v38;
  uint64_t *v39;
  uint64_t *v40;
  uint64_t **v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  int v46;
  BOOL v47;
  uint64_t *v48;
  uint64_t **v49;
  uint64_t *v50;
  uint64_t *v51;
  uint64_t *v52;
  uint64_t **v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  int v58;
  BOOL v59;
  uint64_t *v60;
  uint64_t *v61;
  uint64_t v62;
  uint64_t **v63;
  uint64_t **v64;
  _QWORD v65[2];
  _QWORD v66[2];
  _DWORD *v67;

  v66[0] = sub_100345FF8((uint64_t)a2);
  v66[1] = v4;
  v65[0] = sub_100346004(a2);
  v65[1] = v5;
  for (result = sub_100345F10(v66, v65); result; result = sub_100345F10(v66, v65))
  {
    v7 = sub_100345F3C(v66);
    v8 = *(uint64_t **)(v7 + 16);
    if (v8)
    {
      v9 = *(_QWORD *)(a1 + 8);
      do
      {
        sub_1002716E4(v9, (uint64_t)(v8 + 2), (_OWORD *)v8 + 1);
        v8 = (uint64_t *)*v8;
      }
      while (v8);
    }
    v10 = *(double **)(a1 + 16);
    v11 = *(double **)a1;
    v12 = **(double **)a1 - *(double *)(v7 + 144);
    if (*v10 >= v12)
      v12 = *v10;
    *v10 = v12;
    v13 = *(double **)(a1 + 24);
    v14 = *v11 - *(double *)(v7 + 144);
    if (v14 >= *v13)
      v14 = *v13;
    *v13 = v14;
    v15 = *(double **)(a1 + 32);
    LODWORD(v67) = 1;
    v16 = sub_100270BB8((_QWORD *)(v7 + 104), (unsigned int *)&v67);
    v17 = 0.0;
    v18 = 0.0;
    if (v16)
      v18 = *((double *)v16 + 4) - *((double *)v16 + 3);
    if (*v15 >= v18)
      v18 = *v15;
    **(double **)(a1 + 32) = v18;
    v19 = *(double **)(a1 + 40);
    LODWORD(v67) = 1;
    v20 = sub_100270BB8((_QWORD *)(v7 + 104), (unsigned int *)&v67);
    if (v20)
      v17 = *((double *)v20 + 4) - *((double *)v20 + 3);
    v21 = *v19;
    if (v17 < *v19)
      v21 = v17;
    **(double **)(a1 + 40) = v21;
    LODWORD(v67) = 1;
    v22 = sub_100270BB8((_QWORD *)(v7 + 104), (unsigned int *)&v67);
    if (v22)
      v23 = *((double *)v22 + 4) - *((double *)v22 + 3);
    else
      v23 = 0.0;
    **(double **)(a1 + 48) = v23 + **(double **)(a1 + 48);
    v24 = *(unint64_t **)(a1 + 80);
    v25 = *(_QWORD *)(v7 + 24);
    if (*v24 > v25)
      v25 = *v24;
    *v24 = v25;
    v26 = *(unint64_t **)(a1 + 88);
    v27 = *(_QWORD *)(v7 + 24);
    if (v27 >= *v26)
      v27 = *v26;
    *v26 = v27;
    **(_QWORD **)(a1 + 96) += *(_QWORD *)(v7 + 24);
    for (i = *(int **)(v7 + 80); i; i = *(int **)i)
    {
      v29 = i + 4;
      v30 = *(_QWORD *)(a1 + 56);
      v31 = *(_QWORD *)(v30 + 8);
      if (!v31)
        goto LABEL_35;
      v32 = *v29;
      v33 = v30 + 8;
      do
      {
        v34 = *(_DWORD *)(v31 + 32);
        v35 = v34 < v32;
        if (v34 >= v32)
          v36 = (uint64_t *)v31;
        else
          v36 = (uint64_t *)(v31 + 8);
        if (!v35)
          v33 = v31;
        v31 = *v36;
      }
      while (*v36);
      if (v33 == v30 + 8 || v32 < *(_DWORD *)(v33 + 32))
      {
LABEL_35:
        v67 = i + 4;
        sub_100041CE0((uint64_t **)v30, i + 4, (uint64_t)&unk_101B9EB60, &v67)[5] = 0;
        v30 = *(_QWORD *)(a1 + 56);
      }
      v67 = i + 4;
      v37 = sub_100041CE0((uint64_t **)v30, i + 4, (uint64_t)&unk_101B9EB60, &v67);
      v38 = *(uint64_t **)(v7 + 16);
      if (v38)
      {
        v39 = 0;
        do
        {
          if (*((_DWORD *)v38 + 6) == *v29)
            v39 = (uint64_t *)((char *)v39 + 1);
          v38 = (uint64_t *)*v38;
        }
        while (v38);
      }
      else
      {
        v39 = 0;
      }
      if (v37[5] <= v39)
        v40 = v39;
      else
        v40 = v37[5];
      v41 = *(uint64_t ***)(a1 + 56);
      v67 = i + 4;
      sub_100041CE0(v41, i + 4, (uint64_t)&unk_101B9EB60, &v67)[5] = v40;
      v42 = *(_QWORD *)(a1 + 64);
      v43 = *(_QWORD *)(v42 + 8);
      if (!v43)
        goto LABEL_56;
      v44 = *v29;
      v45 = v42 + 8;
      do
      {
        v46 = *(_DWORD *)(v43 + 32);
        v47 = v46 < v44;
        if (v46 >= v44)
          v48 = (uint64_t *)v43;
        else
          v48 = (uint64_t *)(v43 + 8);
        if (!v47)
          v45 = v43;
        v43 = *v48;
      }
      while (*v48);
      if (v45 == v42 + 8 || v44 < *(_DWORD *)(v45 + 32))
LABEL_56:
        v45 = v42 + 8;
      if (v45 == *(_QWORD *)(a1 + 56) + 8)
      {
        v67 = i + 4;
        sub_100041CE0((uint64_t **)v42, i + 4, (uint64_t)&unk_101B9EB60, &v67)[5] = (uint64_t *)-1;
        v42 = *(_QWORD *)(a1 + 64);
      }
      v67 = i + 4;
      v49 = sub_100041CE0((uint64_t **)v42, i + 4, (uint64_t)&unk_101B9EB60, &v67);
      v50 = *(uint64_t **)(v7 + 16);
      if (v50)
      {
        v51 = 0;
        do
        {
          if (*((_DWORD *)v50 + 6) == *v29)
            v51 = (uint64_t *)((char *)v51 + 1);
          v50 = (uint64_t *)*v50;
        }
        while (v50);
      }
      else
      {
        v51 = 0;
      }
      if (v51 >= v49[5])
        v52 = v49[5];
      else
        v52 = v51;
      v53 = *(uint64_t ***)(a1 + 64);
      v67 = i + 4;
      sub_100041CE0(v53, i + 4, (uint64_t)&unk_101B9EB60, &v67)[5] = v52;
      v54 = *(_QWORD *)(a1 + 72);
      v55 = *(_QWORD *)(v54 + 8);
      if (!v55)
        goto LABEL_79;
      v56 = *v29;
      v57 = v54 + 8;
      do
      {
        v58 = *(_DWORD *)(v55 + 32);
        v59 = v58 < v56;
        if (v58 >= v56)
          v60 = (uint64_t *)v55;
        else
          v60 = (uint64_t *)(v55 + 8);
        if (!v59)
          v57 = v55;
        v55 = *v60;
      }
      while (*v60);
      if (v57 == v54 + 8 || v56 < *(_DWORD *)(v57 + 32))
      {
LABEL_79:
        v67 = i + 4;
        sub_100041CE0((uint64_t **)v54, i + 4, (uint64_t)&unk_101B9EB60, &v67)[5] = 0;
        v56 = *v29;
      }
      v61 = *(uint64_t **)(v7 + 16);
      if (v61)
      {
        v62 = 0;
        do
        {
          if (*((_DWORD *)v61 + 6) == v56)
            ++v62;
          v61 = (uint64_t *)*v61;
        }
        while (v61);
      }
      else
      {
        v62 = 0;
      }
      v63 = *(uint64_t ***)(a1 + 72);
      v67 = i + 4;
      v64 = sub_100041CE0(v63, i + 4, (uint64_t)&unk_101B9EB60, &v67);
      v64[5] = (uint64_t *)((char *)v64[5] + v62);
    }
    sub_100345F50((uint64_t)v66);
  }
  return result;
}

void sub_1002E7D1C(void *a1, uint64_t a2)
{
  CFStringRef v4;
  char v5;
  int v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  char v10;
  uint64_t v11;
  _QWORD *v12;
  double v13;
  double v14;
  double v15;
  NSObject *v16;
  uint64_t v17;
  double v18;
  double v19;
  double v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  char *v25;
  uint64_t v26;
  const char *v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  __int16 v36;
  double v37;
  __int16 v38;
  double v39;
  __int16 v40;
  double v41;
  _BYTE buf[22];
  __int16 v43;
  double v44;
  __int16 v45;
  double v46;
  _QWORD v47[2];
  char v48;
  const __CFString *v49;
  uint64_t v50;
  char v51;
  const __CFString *v52;
  uint64_t v53;
  char v54;
  const __CFString *v55;
  uint64_t v56;
  char v57;

  sub_1001E4804(buf);
  LOBYTE(v47[0]) = 0;
  v4 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsAdaptiveSensorsEnable", 0x8000100u, kCFAllocatorNull);
  v5 = sub_1001E48E4(*(uint64_t *)buf, (uint64_t)v4, (BOOL *)v47);
  CFRelease(v4);
  v6 = LOBYTE(v47[0]);
  v7 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v8 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  if (v6)
    v10 = 1;
  else
    v10 = v5 ^ 1;
  v47[0] = &stru_1021D8FB8;
  v47[1] = sub_1002EBABC(1, 1, 1);
  v48 = v10;
  v49 = CFSTR("Wifi");
  v50 = sub_1002EBABC(1, 0, 0);
  v51 = v10;
  v52 = CFSTR("Ble");
  v53 = sub_1002EBABC(0, 1, 0);
  v54 = v10;
  v55 = CFSTR("Uwb");
  v11 = 0;
  v56 = sub_1002EBABC(0, 0, 1);
  v57 = v10;
  do
  {
    v12 = &v47[v11];
    v31 = 0;
    v32 = 0;
    v33 = 0;
    sub_100314B8C(a2, (float *)&v31);
    LODWORD(v13) = v31;
    objc_msgSend(a1, "setObject:forKeyedSubscript:", +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v13), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@%@"), CFSTR("minClusterRfSize"), v47[v11]));
    LODWORD(v14) = HIDWORD(v31);
    objc_msgSend(a1, "setObject:forKeyedSubscript:", +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v14), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@%@"), CFSTR("maxClusterRfSize"), v47[v11]));
    LODWORD(v15) = v32;
    objc_msgSend(a1, "setObject:forKeyedSubscript:", +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v15), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@%@"), CFSTR("avgClusterRfSize"), v47[v11]));
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E370);
    v16 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
    {
      v17 = *v12;
      *(_DWORD *)buf = 138413058;
      *(_QWORD *)&buf[4] = v17;
      *(_WORD *)&buf[12] = 2048;
      *(double *)&buf[14] = *(float *)&v31;
      v43 = 2048;
      v44 = *((float *)&v31 + 1);
      v45 = 2048;
      v46 = *(float *)&v32;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "Model cluster RF sizes %@: %f (min), %f(max), %f (mean)", buf, 0x2Au);
    }
    if (sub_1001BFF7C(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E370);
      v23 = *v12;
      v34 = 138413058;
      v35 = v23;
      v36 = 2048;
      v37 = *(float *)&v31;
      v38 = 2048;
      v39 = *((float *)&v31 + 1);
      v40 = 2048;
      v41 = *(float *)&v32;
      LODWORD(v29) = 42;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 2, "Model cluster RF sizes %@: %f (min), %f(max), %f (mean)", &v34, v29);
      v25 = (char *)v24;
      sub_100512490("Generic", 1, 0, 2, "static void CLMicroLocationCoreAnalyticsPublishHelper::updateClusterRfDistanceCharacteristics(NSMutableDictionary *, const CLMicroLocationModel &)", "%s\n", v24);
      if (v25 != buf)
        free(v25);
    }
    if ((unint64_t)sub_1002ED634(a2) >= 2)
    {
      LODWORD(v18) = HIDWORD(v32);
      objc_msgSend(a1, "setObject:forKeyedSubscript:", +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v18), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@%@"), CFSTR("minClusterRfDistance"), *v12));
      LODWORD(v19) = v33;
      objc_msgSend(a1, "setObject:forKeyedSubscript:", +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v19), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@%@"), CFSTR("maxClusterRfDistance"), *v12));
      LODWORD(v20) = HIDWORD(v33);
      objc_msgSend(a1, "setObject:forKeyedSubscript:", +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v20), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@%@"), CFSTR("avgClusterRfDistance"), *v12));
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E370);
      v21 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
      {
        v22 = *v12;
        *(_DWORD *)buf = 138413058;
        *(_QWORD *)&buf[4] = v22;
        *(_WORD *)&buf[12] = 2048;
        *(double *)&buf[14] = *((float *)&v32 + 1);
        v43 = 2048;
        v44 = *(float *)&v33;
        v45 = 2048;
        v46 = *((float *)&v33 + 1);
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEBUG, "Model cluster RF distances %@: %f (min), %f(max), %f (mean)", buf, 0x2Au);
      }
      if (sub_1001BFF7C(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212E370);
        v26 = *v12;
        v34 = 138413058;
        v35 = v26;
        v36 = 2048;
        v37 = *((float *)&v32 + 1);
        v38 = 2048;
        v39 = *(float *)&v33;
        v40 = 2048;
        v41 = *((float *)&v33 + 1);
        LODWORD(v30) = 42;
        _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 2, "Model cluster RF distances %@: %f (min), %f(max), %f (mean)", &v34, v30);
        v28 = (char *)v27;
        sub_100512490("Generic", 1, 0, 2, "static void CLMicroLocationCoreAnalyticsPublishHelper::updateClusterRfDistanceCharacteristics(NSMutableDictionary *, const CLMicroLocationModel &)", "%s\n", v27);
        if (v28 != buf)
          free(v28);
      }
    }
    v11 += 3;
  }
  while (v11 != 12);
}

void sub_1002E83E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  sub_100261F44((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1002E8400(void *a1, _QWORD *a2, uint64_t a3, double a4)
{
  void *v8;
  uint64_t v9;
  uint64_t v10;
  const __CFString *v11;
  _QWORD *v12;
  unint64_t *v13;
  uint64_t v14;
  unint64_t *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  unint64_t *v23;
  uint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  uint64_t v27;
  CFStringRef v28;
  int v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *p_shared_owners;
  unint64_t v33;
  unint64_t v34;
  unint64_t *v35;
  _QWORD *v36;
  unint64_t v37;
  uint64_t v38;
  void *v39;
  void *v40;
  std::__shared_weak_count *v41;
  char v42;
  void *__p;
  unint64_t *v44;
  unint64_t v45;
  unsigned int v46;

  if (a1)
  {
    objc_msgSend(a1, "setObject:forKeyedSubscript:", &__kCFBooleanFalse, CFSTR("cancelled"));
    if (sub_1002EFEB8((uint64_t)a2))
      v8 = &__kCFBooleanTrue;
    else
      v8 = &__kCFBooleanFalse;
    objc_msgSend(a1, "setObject:forKeyedSubscript:", v8, CFSTR("valid"));
    objc_msgSend(a1, "setObject:forKeyedSubscript:", +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", j__CFAbsoluteTimeGetCurrent() - a4), CFSTR("runTime"));
    v9 = (uint64_t)objc_msgSend(objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("learnCounter")), "integerValue");
    if (v9)
    {
      if (v9 >= 100)
        v10 = 100;
      else
        v10 = v9;
      objc_msgSend(a1, "setObject:forKeyedSubscript:", +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", v10), CFSTR("learnCounter"));
    }
    if (sub_1002EFEB8((uint64_t)a2))
    {
      if (sub_100320298() == 1)
        v11 = CFSTR("Configuration_Default");
      else
        v11 = CFSTR("Configuration_Candidate");
      objc_msgSend(a1, "setObject:forKeyedSubscript:", v11, CFSTR("configSelect"));
      objc_msgSend(a1, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_1002ED634((uint64_t)a2)), CFSTR("numClusters"));
      sub_1002E88F4(a1, (uint64_t)a2, a3);
      sub_1002E7D1C(a1, (uint64_t)a2);
      objc_msgSend(a1, "setObject:forKeyedSubscript:", +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", sub_1002F1514(a2)), CFSTR("representativeFPsRatio"));
      __p = 0;
      v44 = 0;
      v45 = 0;
      v12 = (_QWORD *)a2[34];
      if (v12)
      {
        v13 = 0;
        do
        {
          v14 = (uint64_t)(v12[5] - v12[4]) >> 4;
          if ((unint64_t)v13 >= v45)
          {
            v15 = (unint64_t *)__p;
            v16 = ((char *)v13 - (_BYTE *)__p) >> 3;
            v17 = v16 + 1;
            if ((unint64_t)(v16 + 1) >> 61)
              sub_100259694();
            v18 = v45 - (_QWORD)__p;
            if ((uint64_t)(v45 - (_QWORD)__p) >> 2 > v17)
              v17 = v18 >> 2;
            if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8)
              v19 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v19 = v17;
            if (v19)
            {
              v19 = (unint64_t)sub_10025E6A0((uint64_t)&v45, v19);
              v21 = v20;
              v15 = (unint64_t *)__p;
              v13 = v44;
            }
            else
            {
              v21 = 0;
            }
            v22 = (uint64_t *)(v19 + 8 * v16);
            *v22 = v14;
            v23 = (unint64_t *)(v22 + 1);
            while (v13 != v15)
            {
              v24 = *--v13;
              *--v22 = v24;
            }
            __p = v22;
            v44 = v23;
            v45 = v19 + 8 * v21;
            if (v15)
              operator delete(v15);
            v13 = v23;
          }
          else
          {
            *v13++ = v14;
          }
          v44 = v13;
          v12 = (_QWORD *)*v12;
        }
        while (v12);
        v25 = (unint64_t *)__p;
      }
      else
      {
        v13 = 0;
        v25 = 0;
      }
      v26 = 126 - 2 * __clz(v13 - v25);
      if (v13 == v25)
        v27 = 0;
      else
        v27 = v26;
      sub_1002EA324(v25, v13, (uint64_t)&v40, v27, 1);
      sub_1001E4804(&v40);
      v46 = 0;
      v28 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsMaximumNumberOfClustersForLearningAnalytics", 0x8000100u, kCFAllocatorNull);
      v29 = sub_1000B1180((uint64_t)v40, (uint64_t)v28, &v46);
      CFRelease(v28);
      v30 = v46;
      v31 = v41;
      if (v41)
      {
        p_shared_owners = (unint64_t *)&v41->__shared_owners_;
        do
          v33 = __ldaxr(p_shared_owners);
        while (__stlxr(v33 - 1, p_shared_owners));
        if (!v33)
        {
          ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
          std::__shared_weak_count::__release_weak(v31);
        }
      }
      if (v29)
        v34 = v30;
      else
        v34 = 5;
      v36 = __p;
      v35 = v44;
      if (v44 != __p)
      {
        v37 = 0;
        v38 = 0;
        do
        {
          if (v37 >= v34)
          {
            v38 += v36[v37];
          }
          else
          {
            objc_msgSend(a1, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v36[v37]), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("numFingerprintsInCluster%zu"), v37));
            v36 = __p;
            v35 = v44;
          }
          ++v37;
        }
        while (v37 < v35 - v36);
        if (v38)
        {
          objc_msgSend(a1, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v38), CFSTR("numFingerprintsInRemainingClusters"));
          v35 = v44;
        }
      }
      objc_msgSend(a1, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", *(v35 - 1)), CFSTR("numFingerprintsInSmallestCluster"));
      sub_1002E6E74(*(_DWORD *)a2, &v40);
      if (v42 >= 0)
        v39 = &v40;
      else
        v39 = v40;
      objc_msgSend(a1, "setObject:forKeyedSubscript:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v39), CFSTR("generationAlgorithm"));
      sub_1002E8AB4(a1, (uint64_t)a2);
      if (v42 < 0)
        operator delete(v40);
      if (__p)
      {
        v44 = (unint64_t *)__p;
        operator delete(__p);
      }
    }
  }
}

void sub_1002E8898(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

id sub_1002E88F4(id result, uint64_t a2, uint64_t a3)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (result)
  {
    v4 = result;
    v6 = *(_QWORD *)(a2 + 232);
    v5 = *(_QWORD *)(a2 + 240);
    v7 = (v5 - v6) >> 5;
    if (v5 == v6)
    {
      v11 = 0;
      v10 = 0;
      v9 = 0;
      v8 = 0;
    }
    else
    {
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v11 = 0;
      do
      {
        v12 = *(uint64_t **)(*(_QWORD *)v6 + 16);
        if (v12)
        {
          v13 = 0;
          v14 = *(_QWORD *)(*(_QWORD *)v6 + 16);
          do
          {
            if (*(_DWORD *)(v14 + 24) == 1)
              ++v13;
            v14 = *(_QWORD *)v14;
          }
          while (v14);
          v15 = *(_QWORD *)(*(_QWORD *)v6 + 16);
          do
          {
            if (*(_DWORD *)(v15 + 24) == 5)
              ++v14;
            v15 = *(_QWORD *)v15;
          }
          while (v15);
          v9 += v13;
          do
          {
            if (*((_DWORD *)v12 + 6) == 6)
              ++v15;
            v12 = (uint64_t *)*v12;
          }
          while (v12);
          v10 += v14;
        }
        else
        {
          v15 = 0;
        }
        v8 += *(_QWORD *)(*(_QWORD *)v6 + 24);
        v11 += v15;
        v6 += 32;
      }
      while (v6 != v5);
    }
    objc_msgSend(result, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v7), CFSTR("modelSizeNumFingerprints"));
    objc_msgSend(v4, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v8), CFSTR("modelSizeNumMeasurements"));
    objc_msgSend(v4, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v9), CFSTR("modelSizeNumWiFiMeasurements"));
    objc_msgSend(v4, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v10), CFSTR("modelSizeNumBleMeasurements"));
    objc_msgSend(v4, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v11), CFSTR("modelSizeNumUwbMeasurements"));
    return objc_msgSend(v4, "setObject:forKeyedSubscript:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", (*(uint64_t (**)(uint64_t))(*(_QWORD *)a3 + 72))(a3)), CFSTR("modelLoadedByteSize"));
  }
  return result;
}

void sub_1002E8AB4(void *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  int *v7;
  char *v8;
  void **v9;
  uint64_t v10[3];
  void *v11;
  char *v12;
  uint64_t v13;
  void *__p[2];
  char v15;
  uint64_t *v16;

  objc_msgSend(a1, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", sub_1002ED910(a2)), CFSTR("modelQuality"));
  objc_msgSend(a1, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", sub_1002ED910(a2)), CFSTR("modelQualityBounded"));
  objc_msgSend(a1, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", sub_1002ED918(a2)), CFSTR("candidateModelQuality"));
  v4 = sub_1002ED920(a2);
  v12 = 0;
  v13 = 0;
  v11 = 0;
  sub_10027205C(&v11, *(const void **)v4, *(_QWORD *)(v4 + 8), (uint64_t)(*(_QWORD *)(v4 + 8) - *(_QWORD *)v4) >> 2);
  v5 = 126 - 2 * __clz((v12 - (_BYTE *)v11) >> 2);
  if (v12 == v11)
    v6 = 0;
  else
    v6 = v5;
  sub_1002EAEC4((uint64_t)v11, (int *)v12, (uint64_t)__p, v6, 1);
  memset(v10, 0, sizeof(v10));
  v7 = (int *)v11;
  v8 = v12;
  v16 = v10;
  while (v7 != (int *)v8)
  {
    sub_10035AA98(*v7, __p);
    sub_1002EB978(&v16, (__int128 *)__p);
    if (v15 < 0)
      operator delete(__p[0]);
    ++v7;
  }
  sub_1002563C0(" ", v10, (uint64_t)__p);
  if (v15 >= 0)
    v9 = __p;
  else
    v9 = (void **)__p[0];
  objc_msgSend(a1, "setObject:forKeyedSubscript:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v9), CFSTR("qualityReasons"));
  if (v15 < 0)
    operator delete(__p[0]);
  __p[0] = v10;
  sub_100259608((void ***)__p);
  if (v11)
  {
    v12 = (char *)v11;
    operator delete(v11);
  }
}

void sub_1002E8C80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  uint64_t v21;

  *(_QWORD *)(v21 - 40) = &a10;
  sub_100259608((void ***)(v21 - 40));
  if (__p)
  {
    a14 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1002E8CD4(uint64_t result, _QWORD *a2, _QWORD *a3, uint64_t a4, char a5, double a6)
{
  void *v8;
  int v9;
  _QWORD *v10;
  unint64_t v11;
  double v12;
  _QWORD v13[5];
  _BYTE v14[16];
  _QWORD *v15;

  if (result)
  {
    v8 = (void *)result;
    if (a5)
      objc_msgSend((id)result, "setObject:forKeyedSubscript:", +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", a6 - *(double *)&a4), CFSTR("ageOfOldModel"));
    result = sub_1002EFEB8((uint64_t)a2);
    if ((_DWORD)result)
    {
      objc_msgSend(v8, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_1002ED634((uint64_t)a3)), CFSTR("numOldClusters"));
      v9 = sub_1002ED634((uint64_t)a2);
      objc_msgSend(v8, "setObject:forKeyedSubscript:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v9 - sub_1002ED634((uint64_t)a3)), CFSTR("numClustersDiff"));
      sub_1002EF90C(a2, (uint64_t)v14);
      sub_1002EF90C(a3, (uint64_t)v13);
      v10 = v15;
      if (v15)
      {
        v11 = 0;
        do
        {
          if (sub_1002710E8(v13, v10 + 2))
            ++v11;
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
      else
      {
        v11 = 0;
      }
      objc_msgSend(v8, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v11), CFSTR("numMatchingClustersInt"));
      if (sub_1002ED634((uint64_t)a3))
      {
        *(float *)&v12 = (float)v11 / (float)(unint64_t)sub_1002ED634((uint64_t)a3);
        objc_msgSend(v8, "setObject:forKeyedSubscript:", +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v12), CFSTR("portionMatchingClusters"));
      }
      else
      {
        objc_msgSend(v8, "setObject:forKeyedSubscript:", &off_10221E018, CFSTR("portionMatchingClusters"));
      }
      sub_100067AC4((uint64_t)v13);
      return sub_100067AC4((uint64_t)v14);
    }
  }
  return result;
}

void sub_1002E8E88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  sub_100067AC4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1002E8EB0(void *a1, uint64_t *a2, unsigned int a3)
{
  unint64_t v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v12;
  double v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint8_t buf[4];
  int v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;

  if (a1)
  {
    if (a3)
    {
      v5 = (a2[1] - *a2) >> 3;
      if (v5 >= a3)
      {
        v10 = a3;
        if (v5 > a3)
        {
          v12 = a3 - 1;
          objc_msgSend(a1, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", *(_QWORD *)(*a2 + 8 * v12) - *(_QWORD *)(*a2 + 8 * a3)), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("numFingerprintsPrunedInIteration%u"), v12));
          v14 = *a2;
          v15 = (a2[1] - *a2) >> 3;
          if (v15 > v12)
          {
            v16 = *(_QWORD *)(v14 + 8 * v12);
            if (!v16)
              return;
            if (v15 > v10)
            {
              *(float *)&v13 = 1.0 - (float)((float)*(unint64_t *)(v14 + 8 * v10) / (float)v16);
              objc_msgSend(a1, "setObject:forKeyedSubscript:", +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v13), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("portionFingerprintsPrunedInIteration%u"), v12));
              return;
            }
          }
        }
        sub_1002EAEB0();
      }
    }
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E370);
    v6 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      v7 = (a2[1] - *a2) >> 3;
      *(_DWORD *)buf = 68289538;
      v18 = 0;
      v19 = 2082;
      v20 = "";
      v21 = 2050;
      v22 = a3;
      v23 = 2050;
      v24 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"updateMagicalMomentsNumPrunedFingerprints called incorrectly\", \"iteration\":%{public}lu, \"numFingerprintsPerIteration size\":%{public}lu}", buf, 0x26u);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E370);
    }
    v8 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      v9 = (a2[1] - *a2) >> 3;
      *(_DWORD *)buf = 68289538;
      v18 = 0;
      v19 = 2082;
      v20 = "";
      v21 = 2050;
      v22 = a3;
      v23 = 2050;
      v24 = v9;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v8, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "updateMagicalMomentsNumPrunedFingerprints called incorrectly", "{\"msg%{public}.0s\":\"updateMagicalMomentsNumPrunedFingerprints called incorrectly\", \"iteration\":%{public}lu, \"numFingerprintsPerIteration size\":%{public}lu}", buf, 0x26u);
    }
  }
}

id sub_1002E918C(void *a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  id result;
  double v9;

  result = objc_msgSend(a1, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", a3 - sub_1002ED634(a2)), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("numClustersPrunedIteration%u"), a4));
  if (a3)
  {
    *(float *)&v9 = 1.0 - (float)((float)(unint64_t)sub_1002ED634(a2) / (float)a3);
    return objc_msgSend(a1, "setObject:forKeyedSubscript:", +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v9), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("portionClustersPrunedIteration%u"), a4));
  }
  return result;
}

id sub_1002E9288(id result, _QWORD *a2, _QWORD *a3)
{
  void *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;

  if (result)
  {
    v4 = result;
    v5 = sub_100345FC0(a2);
    v6 = sub_100345FC0(a3);
    objc_msgSend(v4, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v5), CFSTR("numUnlabeledFingerprints"));
    objc_msgSend(v4, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v6), CFSTR("numLabeledFingerprints"));
    v7 = 5 * (v6 / 5);
    if (5 * (v5 / 5) >= 0x1F4)
      v8 = 500;
    else
      v8 = 5 * (v5 / 5);
    objc_msgSend(v4, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v8), CFSTR("numUnlabeledFingerprintsBounded"));
    if (v7 >= 0x1F4)
      v9 = 500;
    else
      v9 = v7;
    return objc_msgSend(v4, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v9), CFSTR("numLabeledFingerprintsBounded"));
  }
  return result;
}

id sub_1002E9384(void *a1, uint64_t a2, _BYTE *a3)
{
  BOOL v6;
  _BOOL8 v7;

  objc_msgSend(a1, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a2 + 12)), CFSTR("DaysWithRecordings"));
  objc_msgSend(a1, "setObject:forKeyedSubscript:", +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", sub_1002ED910(a2) == 3), CFSTR("IsHighQualityModel"));
  objc_msgSend(a1, "setObject:forKeyedSubscript:", +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", sub_1002ED63C(a2)), CFSTR("WasInHighQualityBefore"));
  if (a3[1])
  {
    if (sub_1002ED63C(a2))
    {
      if (a3[1])
        v6 = *a3 == 0;
      else
        v6 = 0;
      v7 = v6;
    }
    else
    {
      v7 = 0;
    }
  }
  else
  {
    v7 = sub_1002ED63C(a2);
  }
  return objc_msgSend(a1, "setObject:forKeyedSubscript:", +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v7), CFSTR("IsBecomingHighQualityModelForTheFirstTime"));
}

uint64_t sub_1002E9498(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, char a6, uint64_t a7)
{
  uint64_t result;
  _QWORD v15[10];
  char v16;
  char v17;

  result = sub_1002E9544();
  if ((_DWORD)result)
  {
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 3221225472;
    v15[2] = sub_1002E9620;
    v15[3] = &unk_10212E330;
    v15[6] = a2;
    v15[7] = a1;
    v15[8] = a3;
    v15[9] = a4;
    v16 = a5;
    v17 = a6;
    v15[4] = a7;
    v15[5] = CFSTR("com.apple.microlocation.triggers");
    return AnalyticsSendEventLazy(CFSTR("com.apple.microlocation.triggers"), v15);
  }
  return result;
}

uint64_t sub_1002E9544()
{
  CFStringRef v0;
  int v1;
  _BOOL4 v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  BOOL v7;
  uint64_t v8;
  std::__shared_weak_count *v9;

  sub_1001E4804(&v8);
  v7 = 0;
  v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsAnalyticsSendEventEnabled", 0x8000100u, kCFAllocatorNull);
  v1 = sub_1001E48E4(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  v2 = v7;
  v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  if (v2)
    return 1;
  else
    return v1 ^ 1u;
}

void sub_1002E9608(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  sub_100261F44((uint64_t)va);
  _Unwind_Resume(a1);
}

id sub_1002E9620(uint64_t a1)
{
  id v2;
  const __CFString *v3;
  const void **v4;
  size_t v5;
  _BYTE *v6;
  const void *v7;
  _BYTE *v8;
  const void **v9;
  size_t v10;
  _BYTE *v11;
  const void *v12;
  _BYTE *v13;
  _BYTE *v14;
  uint64_t *v15;
  const char *v16;
  void *v17;
  id v18;
  uint64_t v19;
  void *v20;
  void *v21;
  id v22;
  NSObject *v23;
  id v24;
  uint64_t v25;
  id v26;
  const char *v27;
  char *v28;
  NSObject *v29;
  id v30;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  int v36;
  id v37;
  _BYTE __p[18];
  __int16 v39;
  id v40;
  __int16 v41;
  id v42;
  _BYTE v43[128];

  v2 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
  v3 = sub_10035A9C8(*(_QWORD *)(a1 + 56));
  v4 = *(const void ***)(a1 + 48);
  if (*((char *)v4 + 23) >= 0)
    v5 = *((unsigned __int8 *)v4 + 23);
  else
    v5 = (size_t)v4[1];
  v6 = __p;
  sub_100259584((uint64_t)__p, v5 + 12);
  if (SBYTE3(v40) < 0)
    v6 = *(_BYTE **)__p;
  if (v5)
  {
    if (*((char *)v4 + 23) >= 0)
      v7 = v4;
    else
      v7 = *v4;
    memmove(v6, v7, v5);
  }
  strcpy(&v6[v5], "TriggerEvent");
  if (SBYTE3(v40) >= 0)
    v8 = __p;
  else
    v8 = *(_BYTE **)__p;
  objc_msgSend(v2, "setObject:forKeyedSubscript:", v3, +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v8));
  if (SBYTE3(v40) < 0)
    operator delete(*(void **)__p);
  v9 = *(const void ***)(a1 + 48);
  if (*((char *)v9 + 23) >= 0)
    v10 = *((unsigned __int8 *)v9 + 23);
  else
    v10 = (size_t)v9[1];
  v11 = __p;
  sub_100259584((uint64_t)__p, v10 + 17);
  if (SBYTE3(v40) < 0)
    v11 = *(_BYTE **)__p;
  if (v10)
  {
    if (*((char *)v9 + 23) >= 0)
      v12 = v9;
    else
      v12 = *v9;
    memmove(v11, v12, v10);
  }
  strcpy(&v11[v10], "TriggerEventCount");
  if (SBYTE3(v40) >= 0)
    v13 = __p;
  else
    v13 = *(_BYTE **)__p;
  objc_msgSend(v2, "setObject:forKeyedSubscript:", &off_10221AFE8, +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v13));
  if (SBYTE3(v40) < 0)
    operator delete(*(void **)__p);
  sub_1002B88C8(*(const std::string **)(a1 + 64), (std::string *)__p);
  if (SBYTE3(v40) >= 0)
    v14 = __p;
  else
    v14 = *(_BYTE **)__p;
  objc_msgSend(v2, "setObject:forKeyedSubscript:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v14), CFSTR("clientId"));
  if (SBYTE3(v40) < 0)
    operator delete(*(void **)__p);
  v15 = *(uint64_t **)(a1 + 72);
  if (*((char *)v15 + 23) < 0)
    v15 = (uint64_t *)*v15;
  objc_msgSend(v2, "setObject:forKeyedSubscript:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v15), CFSTR("requestStatus"));
  if (*(_BYTE *)(a1 + 80))
    v16 = "On";
  else
    v16 = "Off";
  objc_msgSend(v2, "setObject:forKeyedSubscript:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v16), CFSTR("displayState"));
  objc_msgSend(v2, "setObject:forKeyedSubscript:", +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *(unsigned __int8 *)(a1 + 81)), CFSTR("lowLatencySession"));
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v17 = *(void **)(a1 + 32);
  v18 = objc_msgSend(v17, "countByEnumeratingWithState:objects:count:", &v32, v43, 16);
  if (v18)
  {
    v19 = *(_QWORD *)v33;
    do
    {
      v20 = 0;
      do
      {
        if (*(_QWORD *)v33 != v19)
          objc_enumerationMutation(v17);
        v21 = *(void **)(*((_QWORD *)&v32 + 1) + 8 * (_QWORD)v20);
        v22 = objc_msgSend(*(id *)(a1 + 32), "objectForKey:", v21);
        if (objc_msgSend(v2, "objectForKey:", v21))
        {
          if (qword_1022A00F0 != -1)
            dispatch_once(&qword_1022A00F0, &stru_10212E370);
          v23 = qword_1022A00F8;
          if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
          {
            v24 = objc_msgSend(v21, "UTF8String");
            *(_DWORD *)__p = 136315138;
            *(_QWORD *)&__p[4] = v24;
            _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Trigger event already have %s. Ignoring.", __p, 0xCu);
          }
          if (sub_1001BFF7C(115, 0))
          {
            bzero(__p, 0x65CuLL);
            if (qword_1022A00F0 != -1)
              dispatch_once(&qword_1022A00F0, &stru_10212E370);
            v25 = qword_1022A00F8;
            v26 = objc_msgSend(v21, "UTF8String");
            v36 = 136315138;
            v37 = v26;
            _os_log_send_and_compose_impl(2, 0, __p, 1628, &_mh_execute_header, v25, 16, "Trigger event already have %s. Ignoring.", (const char *)&v36);
            v28 = (char *)v27;
            sub_100512490("Generic", 1, 0, 0, "static void CLMicroLocationCoreAnalyticsPublishHelper::sendCommonTriggerEvent(const CLMicroLocationProto::RecordingEvent &, const std::string &, const std::string &, const std::string &, const BOOL, const BOOL, NSMutableDictionary *)_block_invoke", "%s\n", v27);
            if (v28 != __p)
              free(v28);
          }
        }
        else
        {
          objc_msgSend(v2, "setObject:forKeyedSubscript:", v22, v21);
        }
        v20 = (char *)v20 + 1;
      }
      while (v18 != v20);
      v18 = objc_msgSend(v17, "countByEnumeratingWithState:objects:count:", &v32, v43, 16);
    }
    while (v18);
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E370);
  v29 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
  {
    v30 = objc_msgSend(*(id *)(a1 + 40), "UTF8String");
    *(_QWORD *)__p = 68289539;
    *(_WORD *)&__p[8] = 2082;
    *(_QWORD *)&__p[10] = "";
    v39 = 2081;
    v40 = v30;
    v41 = 2113;
    v42 = v2;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"Sending CA event.\", \"name\":%{private, location:escape_only}s, \"event\":%{private, location:escape_only}@}", __p, 0x26u);
  }
  return v2;
}

void sub_1002E9BBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1002E9BE8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6)
{
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  std::string *v15;
  __int128 v16;
  void **v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  void **v22;
  _QWORD v23[9];
  char v24;
  BOOL v25;
  std::string v26;
  void *__p[2];
  int64_t v28;

  if (sub_1002E9544())
  {
    if ((*(_BYTE *)(a1 + 128) & 8) != 0)
    {
      v12 = *(_QWORD *)(a1 + 24);
      if (v12)
      {
        v13 = *(_QWORD *)(a1 + 24);
        if ((*(_BYTE *)(v12 + 40) & 4) == 0)
          goto LABEL_5;
      }
      else
      {
        v13 = *(_QWORD *)(qword_102310400 + 24);
        if ((*(_BYTE *)(v13 + 40) & 4) == 0)
          goto LABEL_5;
      }
      v19 = *(_QWORD *)(v13 + 16);
      if (!v19)
        v19 = *(_QWORD *)(qword_102310320 + 16);
      if (*(_BYTE *)(v19 + 8))
      {
        v14 = 1;
      }
      else
      {
        if (!v12)
          v12 = *(_QWORD *)(qword_102310400 + 24);
        v20 = *(_QWORD *)(v12 + 16);
        if (!v20)
          v20 = *(_QWORD *)(qword_102310320 + 16);
        v14 = *(_BYTE *)(v20 + 9) != 0;
      }
      goto LABEL_6;
    }
LABEL_5:
    v14 = 0;
LABEL_6:
    std::operator+<char>(&v26, "com.apple.microlocation.", a2);
    v15 = std::string::append(&v26, ".triggers");
    v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
    v28 = v15->__r_.__value_.__r.__words[2];
    *(_OWORD *)__p = v16;
    v15->__r_.__value_.__l.__size_ = 0;
    v15->__r_.__value_.__r.__words[2] = 0;
    v15->__r_.__value_.__r.__words[0] = 0;
    if (v28 >= 0)
      v17 = __p;
    else
      v17 = (void **)__p[0];
    v23[0] = _NSConcreteStackBlock;
    v23[1] = 3221225472;
    v23[2] = sub_1002E9F48;
    v23[3] = &unk_10212E350;
    v23[4] = a4;
    v23[5] = a2;
    v23[6] = a1;
    v23[7] = a5;
    v23[8] = a3;
    v24 = a6;
    v25 = v14;
    AnalyticsSendEventLazy(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v17), v23);
    if (SHIBYTE(v28) < 0)
      operator delete(__p[0]);
    if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v26.__r_.__value_.__l.__data_);
    return;
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E370);
  v18 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "CLMicroLocationCoreAnalyticsPublishHelper, sendTriggerEvent, not sending event because sending to CoreAnalytics is disabled", (uint8_t *)__p, 2u);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E370);
    LOWORD(v26.__r_.__value_.__l.__data_) = 0;
    _os_log_send_and_compose_impl(2, 0, __p, 1628, &_mh_execute_header, qword_1022A00F8, 0, "CLMicroLocationCoreAnalyticsPublishHelper, sendTriggerEvent, not sending event because sending to CoreAnalytics is disabled", &v26, 2);
    v22 = (void **)v21;
    sub_100512490("Generic", 1, 0, 2, "static void CLMicroLocationCoreAnalyticsPublishHelper::sendTriggerEvent(const CLMicroLocationProto::RecordingEvent &, const std::string &, const std::string &, const std::string &, const std::string &, const BOOL)", "%s\n", v21);
    if (v22 != __p)
      free(v22);
  }
}

void sub_1002E9F0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a26 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

id sub_1002E9F48(uint64_t a1)
{
  id v2;
  uint64_t *v3;
  const __CFString *v4;
  const void **v5;
  size_t v6;
  std::string *p_p;
  const void *v8;
  std::string *v9;
  const void **v10;
  size_t v11;
  std::string *v12;
  const void *v13;
  std::string *v14;
  uint64_t *v15;
  NSString *v16;
  const void **v17;
  size_t v18;
  std::string *v19;
  const void *v20;
  std::string *v21;
  std::string *v22;
  const char *v23;
  std::string __p;

  v2 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
  v3 = *(uint64_t **)(a1 + 32);
  if (*((char *)v3 + 23) < 0)
    v3 = (uint64_t *)*v3;
  objc_msgSend(v2, "setObject:forKeyedSubscript:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v3), CFSTR("loiType"));
  v4 = sub_10035A9C8(*(_QWORD *)(a1 + 48));
  v5 = *(const void ***)(a1 + 40);
  if (*((char *)v5 + 23) >= 0)
    v6 = *((unsigned __int8 *)v5 + 23);
  else
    v6 = (size_t)v5[1];
  sub_100259584((uint64_t)&__p, v6 + 12);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if (v6)
  {
    if (*((char *)v5 + 23) >= 0)
      v8 = v5;
    else
      v8 = *v5;
    memmove(p_p, v8, v6);
  }
  strcpy((char *)p_p + v6, "TriggerEvent");
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v9 = &__p;
  else
    v9 = (std::string *)__p.__r_.__value_.__r.__words[0];
  objc_msgSend(v2, "setObject:forKeyedSubscript:", v4, +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v9));
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v10 = *(const void ***)(a1 + 40);
  if (*((char *)v10 + 23) >= 0)
    v11 = *((unsigned __int8 *)v10 + 23);
  else
    v11 = (size_t)v10[1];
  sub_100259584((uint64_t)&__p, v11 + 17);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v12 = &__p;
  else
    v12 = (std::string *)__p.__r_.__value_.__r.__words[0];
  if (v11)
  {
    if (*((char *)v10 + 23) >= 0)
      v13 = v10;
    else
      v13 = *v10;
    memmove(v12, v13, v11);
  }
  strcpy((char *)v12 + v11, "TriggerEventCount");
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v14 = &__p;
  else
    v14 = (std::string *)__p.__r_.__value_.__r.__words[0];
  objc_msgSend(v2, "setObject:forKeyedSubscript:", &off_10221AFE8, +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v14));
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v15 = *(uint64_t **)(a1 + 56);
  if (*((char *)v15 + 23) < 0)
    v15 = (uint64_t *)*v15;
  v16 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v15);
  v17 = *(const void ***)(a1 + 40);
  if (*((char *)v17 + 23) >= 0)
    v18 = *((unsigned __int8 *)v17 + 23);
  else
    v18 = (size_t)v17[1];
  sub_100259584((uint64_t)&__p, v18 + 7);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v19 = &__p;
  else
    v19 = (std::string *)__p.__r_.__value_.__r.__words[0];
  if (v18)
  {
    if (*((char *)v17 + 23) >= 0)
      v20 = v17;
    else
      v20 = *v17;
    memmove(v19, v20, v18);
  }
  strcpy((char *)v19 + v18, "Verdict");
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v21 = &__p;
  else
    v21 = (std::string *)__p.__r_.__value_.__r.__words[0];
  objc_msgSend(v2, "setObject:forKeyedSubscript:", v16, +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v21));
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  sub_1002B88C8(*(const std::string **)(a1 + 64), &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v22 = &__p;
  else
    v22 = (std::string *)__p.__r_.__value_.__r.__words[0];
  objc_msgSend(v2, "setObject:forKeyedSubscript:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v22), CFSTR("clientId"));
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (*(_BYTE *)(a1 + 72))
    v23 = "On";
  else
    v23 = "Off";
  objc_msgSend(v2, "setObject:forKeyedSubscript:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v23), CFSTR("displayState"));
  objc_msgSend(v2, "setObject:forKeyedSubscript:", +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *(unsigned __int8 *)(a1 + 73)), CFSTR("isForcedLocalizationApp"));
  return v2;
}

void sub_1002EA2D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1002EA2F8(id a1)
{
  qword_1022A00F8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

unint64_t *sub_1002EA324(unint64_t *result, unint64_t *a2, uint64_t a3, uint64_t a4, char a5)
{
  unint64_t *v8;
  unint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t *v17;
  char v18;
  BOOL v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t *v61;
  BOOL v63;
  uint64_t v64;
  unint64_t *v65;
  unint64_t v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t *v69;
  unint64_t v70;
  unint64_t v71;

  v8 = result;
LABEL_2:
  v9 = v8;
LABEL_3:
  v10 = 1 - a4;
  while (2)
  {
    v8 = v9;
    v11 = v10;
    v12 = (char *)a2 - (char *)v9;
    v13 = a2 - v9;
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        v20 = *(a2 - 1);
        v21 = *v9;
        if (v20 > *v9)
        {
          *v9 = v20;
          *(a2 - 1) = v21;
        }
        return result;
      case 3uLL:
        v22 = v9[1];
        v23 = *(a2 - 1);
        if (v22 <= v23)
          v24 = *(a2 - 1);
        else
          v24 = v9[1];
        if (v22 >= v23)
          v22 = *(a2 - 1);
        *(a2 - 1) = v22;
        v9[1] = v24;
        v25 = *(a2 - 1);
        if (v25 <= *v9)
          v26 = *v9;
        else
          v26 = *(a2 - 1);
        if (v25 >= *v9)
          v25 = *v9;
        *(a2 - 1) = v25;
        v28 = *v9;
        v27 = v9[1];
        if (v26 <= v27)
          v28 = v9[1];
        if (v26 < v27)
          v27 = v26;
        *v9 = v28;
        v9[1] = v27;
        return result;
      case 4uLL:
        v30 = v9[1];
        v29 = v9[2];
        if (*v9 <= v29)
          v31 = v9[2];
        else
          v31 = *v9;
        if (*v9 < v29)
          v29 = *v9;
        v9[2] = v29;
        *v9 = v31;
        v32 = *(a2 - 1);
        if (v30 <= v32)
          v33 = *(a2 - 1);
        else
          v33 = v30;
        if (v30 < v32)
          v32 = v30;
        *(a2 - 1) = v32;
        v34 = *v9;
        if (*v9 <= v33)
          v35 = v33;
        else
          v35 = *v9;
        if (*v9 >= v33)
          v34 = v33;
        *v9 = v35;
        v9[1] = v34;
        v36 = v9[2];
        v37 = *(a2 - 1);
        if (v36 <= v37)
          v38 = *(a2 - 1);
        else
          v38 = v9[2];
        if (v36 >= v37)
          v36 = *(a2 - 1);
        *(a2 - 1) = v36;
        v39 = v9[1];
        if (v39 <= v38)
          v40 = v38;
        else
          v40 = v9[1];
        if (v39 >= v38)
          v39 = v38;
        v9[1] = v40;
        v9[2] = v39;
        return result;
      case 5uLL:
        v41 = *v9;
        v42 = v9[1];
        if (*v9 <= v42)
          v43 = v9[1];
        else
          v43 = *v9;
        if (*v9 >= v42)
          v41 = v9[1];
        *v9 = v43;
        v9[1] = v41;
        v44 = v9[3];
        v45 = *(a2 - 1);
        if (v44 <= v45)
          v46 = *(a2 - 1);
        else
          v46 = v9[3];
        if (v44 >= v45)
          v44 = *(a2 - 1);
        *(a2 - 1) = v44;
        v9[3] = v46;
        v47 = *(a2 - 1);
        v48 = v9[2];
        if (v47 <= v48)
          v49 = v9[2];
        else
          v49 = *(a2 - 1);
        if (v47 >= v48)
          v47 = v9[2];
        *(a2 - 1) = v47;
        v51 = v9[2];
        v50 = v9[3];
        v52 = v9[1];
        if (v49 <= v50)
          v51 = v9[3];
        if (v49 < v50)
          v50 = v49;
        v9[2] = v51;
        v9[3] = v50;
        v53 = *(a2 - 1);
        if (v52 <= v53)
          v54 = *(a2 - 1);
        else
          v54 = v52;
        if (v52 < v53)
          v53 = v52;
        *(a2 - 1) = v53;
        v55 = *v9;
        v57 = v9[2];
        v56 = v9[3];
        if (v56 <= *v9)
          v58 = *v9;
        else
          v58 = v9[3];
        if (v56 >= *v9)
          v56 = *v9;
        if (v58 <= v57)
          v55 = v9[2];
        if (v58 < v57)
          v57 = v58;
        if (v56 <= v54)
          v59 = v54;
        else
          v59 = v56;
        if (v56 >= v54)
          v56 = v54;
        if (v59 <= v57)
          v54 = v57;
        *v9 = v55;
        v9[1] = v54;
        if (v59 >= v57)
          v60 = v57;
        else
          v60 = v59;
        v9[2] = v60;
        v9[3] = v56;
        return result;
      default:
        if (v12 > 191)
        {
          if (v11 == 1)
          {
            if (v9 != a2)
              return sub_1002EAC10(v9, a2, a2, a3);
            return result;
          }
          v14 = v13 >> 1;
          v15 = &v9[v13 >> 1];
          if ((unint64_t)v12 < 0x401)
          {
            sub_1002EA794(&v9[v13 >> 1], v9, a2 - 1);
            if ((a5 & 1) != 0)
              goto LABEL_12;
          }
          else
          {
            sub_1002EA794(v9, &v9[v13 >> 1], a2 - 1);
            sub_1002EA794(v9 + 1, v15 - 1, a2 - 2);
            sub_1002EA794(v9 + 2, &v9[v14 + 1], a2 - 3);
            sub_1002EA794(v15 - 1, v15, &v9[v14 + 1]);
            v16 = *v9;
            *v9 = *v15;
            *v15 = v16;
            if ((a5 & 1) != 0)
              goto LABEL_12;
          }
          if (*(v9 - 1) <= *v9)
          {
            result = sub_1002EA81C(v9, (uint64_t *)a2);
            v9 = result;
            goto LABEL_17;
          }
LABEL_12:
          v17 = sub_1002EA8CC(v9, a2);
          if ((v18 & 1) == 0)
            goto LABEL_15;
          v19 = sub_1002EA980(v9, v17);
          v9 = v17 + 1;
          result = (unint64_t *)sub_1002EA980(v17 + 1, a2);
          if (!(_DWORD)result)
          {
            v10 = v11 + 1;
            if (v19)
              continue;
LABEL_15:
            result = (unint64_t *)sub_1002EA324(v8, v17, a3, -v11, a5 & 1);
            v9 = v17 + 1;
LABEL_17:
            a5 = 0;
            a4 = -v11;
            goto LABEL_3;
          }
          a4 = -v11;
          a2 = v17;
          if (v19)
            return result;
          goto LABEL_2;
        }
        v61 = v9 + 1;
        v63 = v9 == a2 || v61 == a2;
        if ((a5 & 1) != 0)
        {
          if (!v63)
          {
            v64 = 0;
            v65 = v9;
            do
            {
              v67 = *v65;
              v66 = v65[1];
              v65 = v61;
              if (v66 > v67)
              {
                v68 = v64;
                while (1)
                {
                  *(unint64_t *)((char *)v9 + v68 + 8) = v67;
                  if (!v68)
                    break;
                  v67 = *(unint64_t *)((char *)v9 + v68 - 8);
                  v68 -= 8;
                  if (v66 <= v67)
                  {
                    v69 = (unint64_t *)((char *)v9 + v68 + 8);
                    goto LABEL_123;
                  }
                }
                v69 = v9;
LABEL_123:
                *v69 = v66;
              }
              v61 = v65 + 1;
              v64 += 8;
            }
            while (v65 + 1 != a2);
          }
        }
        else if (!v63)
        {
          do
          {
            v71 = *v8;
            v70 = v8[1];
            v8 = v61;
            if (v70 > v71)
            {
              do
              {
                *v61 = v71;
                v71 = *(v61 - 2);
                --v61;
              }
              while (v70 > v71);
              *v61 = v70;
            }
            v61 = v8 + 1;
          }
          while (v8 + 1 != a2);
        }
        return result;
    }
  }
}

uint64_t sub_1002EA794(unint64_t *a1, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;

  v3 = *a2;
  v4 = *a1;
  v5 = *a3;
  if (*a2 > *a1)
  {
    if (v5 > v3)
    {
      *a1 = v5;
      *a3 = v4;
      return 1;
    }
    *a1 = v3;
    *a2 = v4;
    if (*a3 <= v4)
      return 1;
    *a2 = *a3;
    *a3 = v4;
    return 2;
  }
  if (v5 > v3)
  {
    *a2 = v5;
    *a3 = v3;
    v6 = *a1;
    if (*a2 <= *a1)
      return 1;
    *a1 = *a2;
    *a2 = v6;
    return 2;
  }
  return 0;
}

unint64_t *sub_1002EA81C(unint64_t *a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;

  v2 = *a1;
  if (*a1 <= *(a2 - 1))
  {
    v5 = (uint64_t *)(a1 + 1);
    do
    {
      v3 = (unint64_t *)v5;
      if (v5 >= a2)
        break;
      ++v5;
    }
    while (v2 <= *v3);
  }
  else
  {
    v3 = a1;
    do
    {
      v4 = v3[1];
      ++v3;
    }
    while (v2 <= v4);
  }
  if (v3 < (unint64_t *)a2)
  {
    do
      v6 = *--a2;
    while (v2 > v6);
  }
  if (v3 < (unint64_t *)a2)
  {
    v7 = *v3;
    v8 = *a2;
    do
    {
      *v3 = v8;
      *a2 = v7;
      do
      {
        v9 = v3[1];
        ++v3;
        v7 = v9;
      }
      while (v2 <= v9);
      do
      {
        v10 = *--a2;
        v8 = v10;
      }
      while (v2 > v10);
    }
    while (v3 < (unint64_t *)a2);
  }
  if (v3 - 1 != a1)
    *a1 = *(v3 - 1);
  *(v3 - 1) = v2;
  return v3;
}

unint64_t *sub_1002EA8CC(unint64_t *a1, unint64_t *a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t *v5;
  unint64_t *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;

  v2 = 0;
  v3 = *a1;
  do
    v4 = a1[++v2];
  while (v4 > v3);
  v5 = &a1[v2];
  v6 = &a1[v2 - 1];
  if (v2 == 1)
  {
    do
    {
      if (v5 >= a2)
        break;
      v8 = *--a2;
    }
    while (v8 <= v3);
  }
  else
  {
    do
      v7 = *--a2;
    while (v7 <= v3);
  }
  if (v5 < a2)
  {
    v9 = *a2;
    v10 = &a1[v2];
    v11 = a2;
    do
    {
      *v10 = v9;
      *v11 = v4;
      do
      {
        v12 = v10[1];
        ++v10;
        v4 = v12;
      }
      while (v12 > v3);
      do
      {
        v13 = *--v11;
        v9 = v13;
      }
      while (v13 <= v3);
    }
    while (v10 < v11);
    v6 = v10 - 1;
  }
  if (v6 != a1)
    *a1 = *v6;
  *v6 = v3;
  return v6;
}

BOOL sub_1002EA980(unint64_t *a1, unint64_t *a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t *v12;
  int v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;

  v2 = 1;
  switch(a2 - a1)
  {
    case 0:
    case 1:
      return v2;
    case 2:
      v3 = *(a2 - 1);
      v4 = *a1;
      if (v3 > *a1)
      {
        *a1 = v3;
        *(a2 - 1) = v4;
      }
      return 1;
    case 3:
      v20 = a1[1];
      v21 = *(a2 - 1);
      if (v20 <= v21)
        v22 = *(a2 - 1);
      else
        v22 = a1[1];
      if (v20 >= v21)
        v20 = *(a2 - 1);
      *(a2 - 1) = v20;
      a1[1] = v22;
      v23 = *(a2 - 1);
      if (v23 <= *a1)
        v24 = *a1;
      else
        v24 = *(a2 - 1);
      if (v23 >= *a1)
        v23 = *a1;
      *(a2 - 1) = v23;
      v26 = *a1;
      v25 = a1[1];
      if (v24 <= v25)
        v26 = a1[1];
      if (v24 < v25)
        v25 = v24;
      *a1 = v26;
      a1[1] = v25;
      return 1;
    case 4:
      v48 = a1[1];
      v47 = a1[2];
      if (*a1 <= v47)
        v49 = a1[2];
      else
        v49 = *a1;
      if (*a1 < v47)
        v47 = *a1;
      a1[2] = v47;
      *a1 = v49;
      v50 = *(a2 - 1);
      if (v48 <= v50)
        v51 = *(a2 - 1);
      else
        v51 = v48;
      if (v48 < v50)
        v50 = v48;
      *(a2 - 1) = v50;
      v52 = *a1;
      if (*a1 <= v51)
        v53 = v51;
      else
        v53 = *a1;
      if (*a1 >= v51)
        v52 = v51;
      *a1 = v53;
      a1[1] = v52;
      v54 = a1[2];
      v55 = *(a2 - 1);
      if (v54 <= v55)
        v56 = *(a2 - 1);
      else
        v56 = a1[2];
      if (v54 >= v55)
        v54 = *(a2 - 1);
      *(a2 - 1) = v54;
      v57 = a1[1];
      if (v57 <= v56)
        v58 = v56;
      else
        v58 = a1[1];
      if (v57 >= v56)
        v57 = v56;
      a1[1] = v58;
      a1[2] = v57;
      return 1;
    case 5:
      v27 = *a1;
      v28 = a1[1];
      if (*a1 <= v28)
        v29 = a1[1];
      else
        v29 = *a1;
      if (*a1 >= v28)
        v27 = a1[1];
      *a1 = v29;
      a1[1] = v27;
      v30 = a1[3];
      v31 = *(a2 - 1);
      if (v30 <= v31)
        v32 = *(a2 - 1);
      else
        v32 = a1[3];
      if (v30 >= v31)
        v30 = *(a2 - 1);
      *(a2 - 1) = v30;
      a1[3] = v32;
      v33 = *(a2 - 1);
      v34 = a1[2];
      if (v33 <= v34)
        v35 = a1[2];
      else
        v35 = *(a2 - 1);
      if (v33 >= v34)
        v33 = a1[2];
      *(a2 - 1) = v33;
      v37 = a1[2];
      v36 = a1[3];
      v38 = a1[1];
      if (v35 <= v36)
        v37 = a1[3];
      if (v35 < v36)
        v36 = v35;
      a1[2] = v37;
      a1[3] = v36;
      v39 = *(a2 - 1);
      if (v38 <= v39)
        v40 = *(a2 - 1);
      else
        v40 = v38;
      if (v38 < v39)
        v39 = v38;
      *(a2 - 1) = v39;
      v41 = *a1;
      v43 = a1[2];
      v42 = a1[3];
      if (v42 <= *a1)
        v44 = *a1;
      else
        v44 = a1[3];
      if (v42 >= *a1)
        v42 = *a1;
      if (v44 <= v43)
        v41 = a1[2];
      if (v44 < v43)
        v43 = v44;
      if (v42 <= v40)
        v45 = v40;
      else
        v45 = v42;
      if (v42 >= v40)
        v42 = v40;
      if (v45 <= v43)
        v40 = v43;
      *a1 = v41;
      a1[1] = v40;
      if (v45 >= v43)
        v46 = v43;
      else
        v46 = v45;
      a1[2] = v46;
      a1[3] = v42;
      return 1;
    default:
      v6 = a1 + 2;
      v5 = a1[2];
      v8 = *a1;
      v7 = a1[1];
      if (v7 <= v5)
        v9 = a1[2];
      else
        v9 = a1[1];
      if (v7 < v5)
        v5 = a1[1];
      if (v5 <= v8)
        v10 = *a1;
      else
        v10 = v5;
      if (v5 >= v8)
        v5 = *a1;
      *v6 = v5;
      if (v10 <= v9)
        v11 = v9;
      else
        v11 = v8;
      if (v10 >= v9)
        v10 = v9;
      *a1 = v11;
      a1[1] = v10;
      v12 = a1 + 3;
      if (a1 + 3 == a2)
        return 1;
      v13 = 0;
      v14 = 24;
      break;
  }
  while (1)
  {
    v15 = *v12;
    v16 = *v6;
    if (*v12 > v16)
    {
      v17 = v14;
      while (1)
      {
        *(unint64_t *)((char *)a1 + v17) = v16;
        v18 = v17 - 8;
        if (v17 == 8)
          break;
        v16 = *(unint64_t *)((char *)a1 + v17 - 16);
        v17 -= 8;
        if (v15 <= v16)
        {
          v19 = (unint64_t *)((char *)a1 + v18);
          goto LABEL_27;
        }
      }
      v19 = a1;
LABEL_27:
      *v19 = v15;
      if (++v13 == 8)
        return v12 + 1 == a2;
    }
    v6 = v12;
    v14 += 8;
    if (++v12 == a2)
      return 1;
  }
}

unint64_t *sub_1002EAC10(unint64_t *a1, unint64_t *a2, unint64_t *a3, uint64_t a4)
{
  unint64_t *v6;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t *v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t v28;

  if (a1 != a2)
  {
    v6 = a2;
    v8 = (char *)a2 - (char *)a1;
    v9 = a2 - a1;
    if ((char *)a2 - (char *)a1 >= 9)
    {
      v10 = (unint64_t)(v9 - 2) >> 1;
      v11 = v10 + 1;
      v12 = &a1[v10];
      do
      {
        sub_1002EADEC((uint64_t)a1, a4, v9, v12--);
        --v11;
      }
      while (v11);
    }
    v13 = v6;
    if (v6 != a3)
    {
      v14 = v6;
      do
      {
        v15 = *v14;
        if (*v14 > *a1)
        {
          *v14 = *a1;
          *a1 = v15;
          sub_1002EADEC((uint64_t)a1, a4, v9, a1);
        }
        ++v14;
      }
      while (v14 != a3);
      v13 = a3;
    }
    if (v8 >= 9)
    {
      v16 = (unint64_t)v8 >> 3;
      do
      {
        v17 = 0;
        v18 = *a1;
        v19 = a1;
        do
        {
          v20 = &v19[v17 + 1];
          v21 = (2 * v17) | 1;
          v17 = 2 * v17 + 2;
          if (v17 >= v16)
          {
            v22 = *v20;
            v17 = v21;
          }
          else
          {
            v22 = *v20;
            v23 = v20[1];
            if (*v20 >= v23)
              v22 = v20[1];
            if (*v20 <= v23)
              v17 = v21;
            else
              ++v20;
          }
          *v19 = v22;
          v19 = v20;
        }
        while (v17 <= (uint64_t)((unint64_t)(v16 - 2) >> 1));
        if (v20 == --v6)
        {
          *v20 = v18;
        }
        else
        {
          *v20 = *v6;
          *v6 = v18;
          v24 = (char *)v20 - (char *)a1 + 8;
          if (v24 >= 9)
          {
            v25 = (((unint64_t)v24 >> 3) - 2) >> 1;
            v26 = &a1[v25];
            v27 = *v26;
            v28 = *v20;
            if (*v26 > *v20)
            {
              do
              {
                *v20 = v27;
                v20 = v26;
                if (!v25)
                  break;
                v25 = (v25 - 1) >> 1;
                v26 = &a1[v25];
                v27 = *v26;
              }
              while (*v26 > v28);
              *v20 = v28;
            }
          }
        }
      }
      while (v16-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t sub_1002EADEC(uint64_t result, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  uint64_t v4;
  int64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;

  if (a3 >= 2)
  {
    v4 = (uint64_t)a4 - result;
    v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 3)
    {
      v6 = v4 >> 2;
      v7 = (v4 >> 2) + 1;
      v8 = (unint64_t *)(result + 8 * v7);
      v9 = v6 + 2;
      if (v9 >= a3)
      {
        v10 = *v8;
      }
      else
      {
        v10 = *v8;
        v11 = v8[1];
        if (*v8 >= v11)
          v10 = v8[1];
        if (*v8 > v11)
        {
          ++v8;
          v7 = v9;
        }
      }
      v12 = *a4;
      if (v10 <= *a4)
      {
        do
        {
          *a4 = v10;
          a4 = v8;
          if (v5 < v7)
            break;
          v13 = (2 * v7) | 1;
          v8 = (unint64_t *)(result + 8 * v13);
          v7 = 2 * v7 + 2;
          if (v7 >= a3)
          {
            v10 = *v8;
            v7 = v13;
          }
          else
          {
            v10 = *v8;
            v14 = v8[1];
            if (*v8 >= v14)
              v10 = v8[1];
            if (*v8 <= v14)
              v7 = v13;
            else
              ++v8;
          }
        }
        while (v10 <= v12);
        *a4 = v12;
      }
    }
  }
  return result;
}

void sub_1002EAEB0()
{
  sub_100263950("vector");
}

uint64_t sub_1002EAEC4(uint64_t result, int *a2, uint64_t a3, uint64_t a4, char a5)
{
  int *v8;
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  int *v15;
  int v16;
  int *v17;
  char v18;
  BOOL v19;
  int v20;
  int v21;
  int *v22;
  BOOL v24;
  uint64_t v25;
  int *v26;
  int v27;
  int v28;
  uint64_t v29;
  int *v30;
  int v31;
  int v32;

  v8 = (int *)result;
LABEL_2:
  v9 = v8;
LABEL_3:
  v10 = 1 - a4;
  while (2)
  {
    v8 = v9;
    v11 = v10;
    v12 = (char *)a2 - (char *)v9;
    v13 = a2 - v9;
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        v20 = *(a2 - 1);
        v21 = *v9;
        if (v20 < *v9)
        {
          *v9 = v20;
          *(a2 - 1) = v21;
        }
        return result;
      case 3uLL:
        return sub_1002EB25C(v9, v9 + 1, a2 - 1);
      case 4uLL:
        return sub_1002EB5B4(v9, v9 + 1, v9 + 2, a2 - 1);
      case 5uLL:
        return sub_1002EB634(v9, v9 + 1, v9 + 2, v9 + 3, a2 - 1);
      default:
        if (v12 > 95)
        {
          if (v11 == 1)
          {
            if (v9 != a2)
              return (uint64_t)sub_1002EB6D8(v9, a2, a2, a3);
            return result;
          }
          v14 = v13 >> 1;
          v15 = &v9[v13 >> 1];
          if ((unint64_t)v12 < 0x201)
          {
            sub_1002EB25C(&v9[v13 >> 1], v9, a2 - 1);
            if ((a5 & 1) != 0)
              goto LABEL_12;
          }
          else
          {
            sub_1002EB25C(v9, &v9[v13 >> 1], a2 - 1);
            sub_1002EB25C(v9 + 1, v15 - 1, a2 - 2);
            sub_1002EB25C(v9 + 2, &v9[v14 + 1], a2 - 3);
            sub_1002EB25C(v15 - 1, v15, &v9[v14 + 1]);
            v16 = *v9;
            *v9 = *v15;
            *v15 = v16;
            if ((a5 & 1) != 0)
              goto LABEL_12;
          }
          if (*(v9 - 1) >= *v9)
          {
            result = (uint64_t)sub_1002EB2E4(v9, a2);
            v9 = (int *)result;
            goto LABEL_17;
          }
LABEL_12:
          v17 = sub_1002EB394(v9, a2);
          if ((v18 & 1) == 0)
            goto LABEL_15;
          v19 = sub_1002EB448(v9, v17);
          v9 = v17 + 1;
          result = sub_1002EB448(v17 + 1, a2);
          if (!(_DWORD)result)
          {
            v10 = v11 + 1;
            if (v19)
              continue;
LABEL_15:
            result = sub_1002EAEC4(v8, v17, a3, -v11, a5 & 1);
            v9 = v17 + 1;
LABEL_17:
            a5 = 0;
            a4 = -v11;
            goto LABEL_3;
          }
          a4 = -v11;
          a2 = v17;
          if (v19)
            return result;
          goto LABEL_2;
        }
        v22 = v9 + 1;
        v24 = v9 == a2 || v22 == a2;
        if ((a5 & 1) != 0)
        {
          if (!v24)
          {
            v25 = 0;
            v26 = v9;
            do
            {
              v28 = *v26;
              v27 = v26[1];
              v26 = v22;
              if (v27 < v28)
              {
                v29 = v25;
                while (1)
                {
                  *(int *)((char *)v9 + v29 + 4) = v28;
                  if (!v29)
                    break;
                  v28 = *(int *)((char *)v9 + v29 - 4);
                  v29 -= 4;
                  if (v27 >= v28)
                  {
                    v30 = (int *)((char *)v9 + v29 + 4);
                    goto LABEL_42;
                  }
                }
                v30 = v9;
LABEL_42:
                *v30 = v27;
              }
              v22 = v26 + 1;
              v25 += 4;
            }
            while (v26 + 1 != a2);
          }
        }
        else if (!v24)
        {
          do
          {
            v32 = *v8;
            v31 = v8[1];
            v8 = v22;
            if (v31 < v32)
            {
              do
              {
                *v22 = v32;
                v32 = *(v22 - 2);
                --v22;
              }
              while (v31 < v32);
              *v22 = v31;
            }
            v22 = v8 + 1;
          }
          while (v8 + 1 != a2);
        }
        return result;
    }
  }
}

uint64_t sub_1002EB25C(int *a1, int *a2, int *a3)
{
  int v3;
  int v4;
  int v5;
  int v6;

  v3 = *a2;
  v4 = *a1;
  v5 = *a3;
  if (*a2 < *a1)
  {
    if (v5 < v3)
    {
      *a1 = v5;
      *a3 = v4;
      return 1;
    }
    *a1 = v3;
    *a2 = v4;
    if (*a3 >= v4)
      return 1;
    *a2 = *a3;
    *a3 = v4;
    return 2;
  }
  if (v5 < v3)
  {
    *a2 = v5;
    *a3 = v3;
    v6 = *a1;
    if (*a2 >= *a1)
      return 1;
    *a1 = *a2;
    *a2 = v6;
    return 2;
  }
  return 0;
}

int *sub_1002EB2E4(int *a1, int *a2)
{
  int v2;
  int *v3;
  int v4;
  int *v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;

  v2 = *a1;
  if (*a1 >= *(a2 - 1))
  {
    v5 = a1 + 1;
    do
    {
      v3 = v5;
      if (v5 >= a2)
        break;
      ++v5;
    }
    while (v2 >= *v3);
  }
  else
  {
    v3 = a1;
    do
    {
      v4 = v3[1];
      ++v3;
    }
    while (v2 >= v4);
  }
  if (v3 < a2)
  {
    do
      v6 = *--a2;
    while (v2 < v6);
  }
  if (v3 < a2)
  {
    v7 = *v3;
    v8 = *a2;
    do
    {
      *v3 = v8;
      *a2 = v7;
      do
      {
        v9 = v3[1];
        ++v3;
        v7 = v9;
      }
      while (v2 >= v9);
      do
      {
        v10 = *--a2;
        v8 = v10;
      }
      while (v2 < v10);
    }
    while (v3 < a2);
  }
  if (v3 - 1 != a1)
    *a1 = *(v3 - 1);
  *(v3 - 1) = v2;
  return v3;
}

int *sub_1002EB394(int *a1, int *a2)
{
  uint64_t v2;
  int v3;
  int v4;
  int *v5;
  int *v6;
  int v7;
  int v8;
  int v9;
  int *v10;
  int *v11;
  int v12;
  int v13;

  v2 = 0;
  v3 = *a1;
  do
    v4 = a1[++v2];
  while (v4 < v3);
  v5 = &a1[v2];
  v6 = &a1[v2 - 1];
  if (v2 == 1)
  {
    do
    {
      if (v5 >= a2)
        break;
      v8 = *--a2;
    }
    while (v8 >= v3);
  }
  else
  {
    do
      v7 = *--a2;
    while (v7 >= v3);
  }
  if (v5 < a2)
  {
    v9 = *a2;
    v10 = &a1[v2];
    v11 = a2;
    do
    {
      *v10 = v9;
      *v11 = v4;
      do
      {
        v12 = v10[1];
        ++v10;
        v4 = v12;
      }
      while (v12 < v3);
      do
      {
        v13 = *--v11;
        v9 = v13;
      }
      while (v13 >= v3);
    }
    while (v10 < v11);
    v6 = v10 - 1;
  }
  if (v6 != a1)
    *a1 = *v6;
  *v6 = v3;
  return v6;
}

BOOL sub_1002EB448(int *a1, int *a2)
{
  uint64_t v4;
  _BOOL8 result;
  int v6;
  int v7;
  int *v8;
  int *v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int *v16;

  v4 = a2 - a1;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = *(a2 - 1);
      v7 = *a1;
      if (v6 < *a1)
      {
        *a1 = v6;
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      sub_1002EB25C(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      sub_1002EB5B4(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      sub_1002EB634(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      v8 = a1 + 2;
      sub_1002EB25C(a1, a1 + 1, a1 + 2);
      v9 = a1 + 3;
      if (a1 + 3 == a2)
        return 1;
      v10 = 0;
      v11 = 12;
      break;
  }
  while (1)
  {
    v12 = *v9;
    v13 = *v8;
    if (*v9 < *v8)
    {
      v14 = v11;
      while (1)
      {
        *(int *)((char *)a1 + v14) = v13;
        v15 = v14 - 4;
        if (v14 == 4)
          break;
        v13 = *(int *)((char *)a1 + v14 - 8);
        v14 -= 4;
        if (v12 >= v13)
        {
          v16 = (int *)((char *)a1 + v15);
          goto LABEL_12;
        }
      }
      v16 = a1;
LABEL_12:
      *v16 = v12;
      if (++v10 == 8)
        return v9 + 1 == a2;
    }
    v8 = v9;
    v11 += 4;
    if (++v9 == a2)
      return 1;
  }
}

uint64_t sub_1002EB5B4(int *a1, int *a2, int *a3, int *a4)
{
  uint64_t result;
  int v9;
  int v10;
  int v11;

  result = sub_1002EB25C(a1, a2, a3);
  v9 = *a3;
  if (*a4 < *a3)
  {
    *a3 = *a4;
    *a4 = v9;
    v10 = *a2;
    if (*a3 < *a2)
    {
      *a2 = *a3;
      *a3 = v10;
      v11 = *a1;
      if (*a2 < *a1)
      {
        *a1 = *a2;
        *a2 = v11;
      }
    }
  }
  return result;
}

uint64_t sub_1002EB634(int *a1, int *a2, int *a3, int *a4, int *a5)
{
  uint64_t result;
  int v11;
  int v12;
  int v13;
  int v14;

  result = sub_1002EB5B4(a1, a2, a3, a4);
  v11 = *a4;
  if (*a5 < *a4)
  {
    *a4 = *a5;
    *a5 = v11;
    v12 = *a3;
    if (*a4 < *a3)
    {
      *a3 = *a4;
      *a4 = v12;
      v13 = *a2;
      if (*a3 < *a2)
      {
        *a2 = *a3;
        *a3 = v13;
        v14 = *a1;
        if (*a2 < *a1)
        {
          *a1 = *a2;
          *a2 = v14;
        }
      }
    }
  }
  return result;
}

int *sub_1002EB6D8(int *a1, int *a2, int *a3, uint64_t a4)
{
  int *v6;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  int *v12;
  int *v13;
  int *v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int *v19;
  int *v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  unint64_t v25;
  int *v26;
  int v27;
  int v28;

  if (a1 != a2)
  {
    v6 = a2;
    v8 = (char *)a2 - (char *)a1;
    v9 = a2 - a1;
    if ((char *)a2 - (char *)a1 >= 5)
    {
      v10 = (unint64_t)(v9 - 2) >> 1;
      v11 = v10 + 1;
      v12 = &a1[v10];
      do
      {
        sub_1002EB8B4((uint64_t)a1, a4, v9, v12--);
        --v11;
      }
      while (v11);
    }
    v13 = v6;
    if (v6 != a3)
    {
      v14 = v6;
      do
      {
        v15 = *v14;
        if (*v14 < *a1)
        {
          *v14 = *a1;
          *a1 = v15;
          sub_1002EB8B4((uint64_t)a1, a4, v9, a1);
        }
        ++v14;
      }
      while (v14 != a3);
      v13 = a3;
    }
    if (v8 >= 5)
    {
      v16 = (unint64_t)v8 >> 2;
      do
      {
        v17 = 0;
        v18 = *a1;
        v19 = a1;
        do
        {
          v20 = &v19[v17 + 1];
          v21 = (2 * v17) | 1;
          v17 = 2 * v17 + 2;
          if (v17 >= v16)
          {
            v22 = *v20;
            v17 = v21;
          }
          else
          {
            v22 = *v20;
            v23 = v20[1];
            if (*v20 <= v23)
              v22 = v20[1];
            if (*v20 >= v23)
              v17 = v21;
            else
              ++v20;
          }
          *v19 = v22;
          v19 = v20;
        }
        while (v17 <= (uint64_t)((unint64_t)(v16 - 2) >> 1));
        if (v20 == --v6)
        {
          *v20 = v18;
        }
        else
        {
          *v20 = *v6;
          *v6 = v18;
          v24 = (char *)v20 - (char *)a1 + 4;
          if (v24 >= 5)
          {
            v25 = (((unint64_t)v24 >> 2) - 2) >> 1;
            v26 = &a1[v25];
            v27 = *v26;
            v28 = *v20;
            if (*v26 < *v20)
            {
              do
              {
                *v20 = v27;
                v20 = v26;
                if (!v25)
                  break;
                v25 = (v25 - 1) >> 1;
                v26 = &a1[v25];
                v27 = *v26;
              }
              while (*v26 < v28);
              *v20 = v28;
            }
          }
        }
      }
      while (v16-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t sub_1002EB8B4(uint64_t result, uint64_t a2, uint64_t a3, int *a4)
{
  uint64_t v4;
  int64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  int v14;

  if (a3 >= 2)
  {
    v4 = (uint64_t)a4 - result;
    v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 2)
    {
      v6 = v4 >> 1;
      v7 = (v4 >> 1) + 1;
      v8 = (int *)(result + 4 * v7);
      v9 = v6 + 2;
      if (v9 >= a3)
      {
        v10 = *v8;
      }
      else
      {
        v10 = *v8;
        v11 = v8[1];
        if (*v8 <= v11)
          v10 = v8[1];
        if (*v8 < v11)
        {
          ++v8;
          v7 = v9;
        }
      }
      v12 = *a4;
      if (v10 >= *a4)
      {
        do
        {
          *a4 = v10;
          a4 = v8;
          if (v5 < v7)
            break;
          v13 = (2 * v7) | 1;
          v8 = (int *)(result + 4 * v13);
          v7 = 2 * v7 + 2;
          if (v7 >= a3)
          {
            v10 = *v8;
            v7 = v13;
          }
          else
          {
            v10 = *v8;
            v14 = v8[1];
            if (*v8 <= v14)
              v10 = v8[1];
            if (*v8 >= v14)
              v7 = v13;
            else
              ++v8;
          }
        }
        while (v10 >= v12);
        *a4 = v12;
      }
    }
  }
  return result;
}

uint64_t **sub_1002EB978(uint64_t **a1, __int128 *a2)
{
  uint64_t *v4;
  unint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  __int128 v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  __int128 v18;
  _QWORD v20[5];

  v4 = *a1;
  v5 = (*a1)[1];
  v6 = *a1;
  v9 = v6[2];
  v7 = (uint64_t)(v6 + 2);
  v8 = v9;
  if (v5 >= v9)
  {
    v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *v4) >> 3);
    v13 = v12 + 1;
    if (v12 + 1 > 0xAAAAAAAAAAAAAAALL)
      sub_100259694();
    v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v8 - *v4) >> 3);
    if (2 * v14 > v13)
      v13 = 2 * v14;
    if (v14 >= 0x555555555555555)
      v15 = 0xAAAAAAAAAAAAAAALL;
    else
      v15 = v13;
    v20[4] = v7;
    if (v15)
      v16 = (char *)sub_1002596A8(v7, v15);
    else
      v16 = 0;
    v17 = &v16[24 * v12];
    v20[0] = v16;
    v20[1] = v17;
    v20[3] = &v16[24 * v15];
    v18 = *a2;
    *((_QWORD *)v17 + 2) = *((_QWORD *)a2 + 2);
    *(_OWORD *)v17 = v18;
    *((_QWORD *)a2 + 1) = 0;
    *((_QWORD *)a2 + 2) = 0;
    *(_QWORD *)a2 = 0;
    v20[2] = v17 + 24;
    sub_100074D44(v4, v20);
    v11 = v4[1];
    sub_100074DB8((uint64_t)v20);
  }
  else
  {
    v10 = *a2;
    *(_QWORD *)(v5 + 16) = *((_QWORD *)a2 + 2);
    *(_OWORD *)v5 = v10;
    *((_QWORD *)a2 + 1) = 0;
    *((_QWORD *)a2 + 2) = 0;
    *(_QWORD *)a2 = 0;
    v11 = v5 + 24;
    v4[1] = v5 + 24;
  }
  v4[1] = v11;
  return a1;
}

void sub_1002EBAA8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_100074DB8((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002EBABC(int a1, int a2, int a3)
{
  uint64_t v3;

  v3 = 2;
  if (!a1)
    v3 = 0;
  if (a2)
    v3 |= 0x20uLL;
  if (a3)
    return v3 | 0x40;
  else
    return v3;
}

uint64_t sub_1002EBAE4(uint64_t a1, int a2, int a3, double a4)
{
  uint64_t v4;
  int v5;

  v4 = 0;
  if ((a2 & 0x80000000) == 0 && (a3 & 0x80000000) == 0)
  {
    v5 = *(_DWORD *)(a1 + 12);
    if (v5 > a2)
    {
      if (*(_DWORD *)(a1 + 16) <= a3)
      {
        return 0;
      }
      else
      {
        *(double *)(*(_QWORD *)a1 + 8 * (a2 + v5 * a3)) = a4;
        *(_BYTE *)(a1 + 8) = 0;
        return 1;
      }
    }
  }
  return v4;
}

void sub_1002EBB2C(uint64_t a1, int a2, int a3)
{
  *(_QWORD *)a1 = 0;
  *(_WORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = a2;
  *(_DWORD *)(a1 + 16) = a3;
  operator new[]();
}

void sub_1002EBBB4(_Unwind_Exception *exception_object)
{
  uint64_t *v1;
  uint64_t v3;

  v3 = *v1;
  *v1 = 0;
  if (v3)
    operator delete[]();
  _Unwind_Resume(exception_object);
}

void sub_1002EBBE4(_QWORD *a1)
{
  *a1 = 0;
  operator new[]();
}

void sub_1002EBC7C(_Unwind_Exception *exception_object)
{
  uint64_t *v1;
  uint64_t v3;

  v3 = *v1;
  *v1 = 0;
  if (v3)
    operator delete[]();
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002EBCAC(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = *a2;
  *a2 = 0;
  *(_QWORD *)a1 = v3;
  *(_WORD *)(a1 + 8) = *((_WORD *)a2 + 4);
  *(_QWORD *)(a1 + 12) = *(uint64_t *)((char *)a2 + 12);
  v4 = *a2;
  *a2 = 0;
  if (v4)
    operator delete[]();
  *((_WORD *)a2 + 4) = 0;
  *((_DWORD *)a2 + 3) = 0;
  *((_DWORD *)a2 + 4) = 0;
  return a1;
}

uint64_t sub_1002EBD18(uint64_t result, uint64_t a2)
{
  if (result != a2)
    operator new[]();
  return result;
}

uint64_t *sub_1002EBDB4(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (a1 != a2)
  {
    v3 = *a1;
    *a1 = 0;
    if (v3)
      operator delete[]();
    v4 = *a2;
    *a2 = 0;
    v5 = *a1;
    *a1 = v4;
    if (v5)
      operator delete[]();
    *((_WORD *)a1 + 4) = *((_WORD *)a2 + 4);
    *(uint64_t *)((char *)a1 + 12) = *(uint64_t *)((char *)a2 + 12);
    v6 = *a2;
    *a2 = 0;
    if (v6)
      operator delete[]();
    *((_WORD *)a2 + 4) = 0;
    *((_DWORD *)a2 + 3) = 0;
    *((_DWORD *)a2 + 4) = 0;
  }
  return a1;
}

uint64_t sub_1002EBE60@<X0>(uint64_t result@<X0>, unsigned int a2@<W1>, _BYTE *a3@<X8>)
{
  unsigned int v3;
  _QWORD v4[3];

  *a3 = 0;
  a3[24] = 0;
  v3 = *(_DWORD *)(result + 16);
  if (v3 > a2)
    sub_1002EBB2C((uint64_t)v4, *(_DWORD *)(result + 12), v3 - a2);
  return result;
}

void sub_1002EBF08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  uint64_t *v10;
  uint64_t v12;

  if (a10)
    operator delete[]();
  if (*((_BYTE *)v10 + 24))
  {
    v12 = *v10;
    *v10 = 0;
    if (v12)
      operator delete[]();
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_1002EBF64(uint64_t a1, uint64_t *a2)
{
  uint64_t *result;

  if (*(_BYTE *)(a1 + 24))
    return sub_1002EBDB4((uint64_t *)a1, a2);
  result = (uint64_t *)sub_1002EBCAC(a1, a2);
  *((_BYTE *)result + 24) = 1;
  return result;
}

uint64_t sub_1002EBF90(uint64_t a1, int a2, int a3, _QWORD *a4)
{
  uint64_t result;
  int v6;

  if (a2 < 0)
    return 0;
  result = 0;
  if ((a3 & 0x80000000) == 0)
  {
    v6 = *(_DWORD *)(a1 + 12);
    if (v6 > a2)
    {
      if (*(_DWORD *)(a1 + 16) > a3)
      {
        *a4 = *(_QWORD *)(*(_QWORD *)a1 + 8 * (a2 + v6 * a3));
        return 1;
      }
      return 0;
    }
  }
  return result;
}

uint64_t sub_1002EBFD8(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  int v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  double v9;
  NSObject *v10;
  NSObject *v11;
  uint8_t buf[4];
  int v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;

  if (*(_BYTE *)(a1 + 8))
    return 1;
  v3 = *(unsigned int *)(a1 + 12);
  if (!(_DWORD)v3)
    goto LABEL_24;
  v4 = *(_DWORD *)(a1 + 16);
  if (v4)
  {
    if (v4 == 1)
    {
      if ((int)v3 >= 1)
      {
        v5 = *(_QWORD **)a1;
        do
        {
          *v5++ = 0x3FF0000000000000;
          --v3;
        }
        while (v3);
      }
LABEL_24:
      result = 1;
      *(_BYTE *)(a1 + 8) = 1;
      return result;
    }
    if ((int)v3 < 1)
      goto LABEL_24;
    v6 = 0;
    v7 = 0;
    v8 = 1;
    do
    {
      v9 = cblas_dnrm2(*(_DWORD *)(a1 + 16), (const double *)(*(_QWORD *)a1 + v6), v3);
      if (v9 == 0.0)
      {
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212E3C0);
        v10 = qword_1022A00F8;
        if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 68289282;
          v13 = 0;
          v14 = 2082;
          v15 = "";
          v16 = 1026;
          v17 = v7;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"ProbabilityMatrix::normalizeRows, row with zero norm!\", \"RowIndex\":%{public}d}", buf, 0x18u);
          if (qword_1022A00F0 != -1)
            dispatch_once(&qword_1022A00F0, &stru_10212E3C0);
        }
        v11 = qword_1022A00F8;
        if (os_signpost_enabled((os_log_t)qword_1022A00F8))
        {
          *(_DWORD *)buf = 68289282;
          v13 = 0;
          v14 = 2082;
          v15 = "";
          v16 = 1026;
          v17 = v7;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v11, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "ProbabilityMatrix::normalizeRows, row with zero norm!", "{\"msg%{public}.0s\":\"ProbabilityMatrix::normalizeRows, row with zero norm!\", \"RowIndex\":%{public}d}", buf, 0x18u);
        }
        v8 = 0;
      }
      else
      {
        cblas_dscal(*(_DWORD *)(a1 + 16), 1.0 / v9, (double *)(*(_QWORD *)a1 + v6), *(_DWORD *)(a1 + 12));
      }
      ++v7;
      v3 = *(int *)(a1 + 12);
      v6 += 8;
    }
    while (v7 < v3);
    if ((v8 & 1) != 0)
      goto LABEL_24;
  }
  return 0;
}

uint64_t sub_1002EC234@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  uint64_t v9;
  int v10;
  BOOL v11;
  double *v13;

  v4 = 12;
  if (!*(_BYTE *)(result + 9))
    v4 = 16;
  v5 = *(_DWORD *)(result + v4);
  if (*(_BYTE *)(a2 + 9))
    v6 = *(_DWORD *)(a2 + 16);
  else
    v6 = *(_DWORD *)(a2 + 12);
  if (v5 == v6)
  {
    v7 = *(_BYTE *)(a2 + 9) ? *(_DWORD *)(a2 + 12) : *(_DWORD *)(a2 + 16);
    if (v5 == 1 || v7 == 1)
    {
      v9 = 16;
      if (!*(_BYTE *)(result + 9))
        v9 = 12;
      v10 = *(_DWORD *)(result + v9);
      if (v5)
        v11 = v10 == 0;
      else
        v11 = 1;
      if (!v11 && v7 != 0)
        sub_1002EBB2C((uint64_t)&v13, v10, v7);
    }
  }
  *a3 = 0;
  a3[24] = 0;
  return result;
}

void sub_1002EC358(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12)
    operator delete[]();
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002EC384(uint64_t a1, uint64_t a2, unsigned int a3)
{
  unsigned int v6;
  uint64_t v7;
  _BOOL4 v8;
  uint64_t result;
  int v10;
  const char *v11;
  NSObject *v12;
  uint64_t v13;
  _BOOL4 v14;
  unsigned int v15;
  int v16;
  NSObject *v17;
  int v18;
  int v19;
  NSObject *v20;
  unsigned int v21;
  int v22;
  uint8_t buf[4];
  int v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  unsigned int v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;

  if (*(_DWORD *)(a2 + 16) == *(_DWORD *)(a1 + 16))
  {
    v6 = *(_DWORD *)(a2 + 12);
    if (a3 >= v6)
    {
      if (a3 != v6)
      {
        if (*(_DWORD *)(a1 + 12) + v6 <= a3)
          v19 = *(_DWORD *)(a1 + 12);
        else
          v19 = a3 - v6;
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212E3C0);
        v20 = qword_1022A00F8;
        if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
        {
          v21 = *(_DWORD *)(a1 + 12);
          v22 = *(_DWORD *)(a2 + 16);
          *(_DWORD *)buf = 68289794;
          v24 = 0;
          v25 = 2082;
          v26 = "";
          v27 = 1026;
          v28 = v21;
          v29 = 1026;
          v30 = v19;
          v31 = 1026;
          v32 = v22;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"appending rows\", \"NumOldRows\":%{public}d, \"NumOldRowsToKeep\":%{public}d, \"NumRowsToAppend\":%{public}d}", buf, 0x24u);
        }
        operator new[]();
      }
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E3C0);
      v17 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        v18 = *(_DWORD *)(a2 + 16);
        *(_DWORD *)buf = 68289538;
        v24 = 0;
        v25 = 2082;
        v26 = "";
        v27 = 1026;
        v28 = a3;
        v29 = 1026;
        v30 = v18;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"rows to append are max length - copy\", \"MaxNumRows\":%{public}d, \"NumRowsToAppend\":%{public}d}", buf, 0x1Eu);
      }
      sub_1002EBD18(a1, a2);
      return 1;
    }
    else
    {
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E3C0);
      v7 = qword_1022A00F8;
      v8 = os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT);
      result = 0;
      if (v8)
      {
        v10 = *(_DWORD *)(a2 + 16);
        *(_DWORD *)buf = 68289538;
        v24 = 0;
        v25 = 2082;
        v26 = "";
        v27 = 1026;
        v28 = a3;
        v29 = 1026;
        v30 = v10;
        v11 = "{\"msg%{public}.0s\":\"cannot append rows more rows than allowed\", \"MaxNumRows\":%{public}d, \"NumRowsTo"
              "Append\":%{public}d}";
        v12 = v7;
LABEL_11:
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, v11, buf, 0x1Eu);
        return 0;
      }
    }
  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E3C0);
    v13 = qword_1022A00F8;
    v14 = os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (v14)
    {
      v15 = *(_DWORD *)(a1 + 16);
      v16 = *(_DWORD *)(a2 + 16);
      *(_DWORD *)buf = 68289538;
      v24 = 0;
      v25 = 2082;
      v26 = "";
      v27 = 1026;
      v28 = v15;
      v29 = 1026;
      v30 = v16;
      v11 = "{\"msg%{public}.0s\":\"cannot append rows with incompatible number of columns\", \"NumColumns\":%{public}d, "
            "\"OtherNumColumns\":%{public}d}";
      v12 = v13;
      goto LABEL_11;
    }
  }
  return result;
}

_QWORD *sub_1002EC7C4@<X0>(char a1@<W0>, _QWORD *a2@<X8>)
{
  return sub_1015A2E04(a2, (&off_10212E3E0)[a1]);
}

__n128 sub_1002EC7DC(uint64_t a1, char a2, char a3, char a4, uint64_t a5, __n128 *a6, double a7)
{
  __n128 result;

  *(double *)a1 = a7;
  *(_BYTE *)(a1 + 8) = a2;
  *(_BYTE *)(a1 + 9) = a3;
  *(_BYTE *)(a1 + 10) = a4;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)a5;
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a5 + 16);
  *(_QWORD *)a5 = 0;
  *(_QWORD *)(a5 + 8) = 0;
  *(_QWORD *)(a5 + 16) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  result = *a6;
  *(__n128 *)(a1 + 40) = *a6;
  *(_QWORD *)(a1 + 56) = a6[1].n128_u64[0];
  a6->n128_u64[0] = 0;
  a6->n128_u64[1] = 0;
  a6[1].n128_u64[0] = 0;
  return result;
}

_QWORD *sub_1002EC830@<X0>(int a1@<W0>, _QWORD *a2@<X8>)
{
  return sub_1015A2E04(a2, (&off_10212E3F8)[a1]);
}

unint64_t sub_1002EC844(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t result;

  v2 = 0;
  result = 0;
  do
    result ^= (result << 6) + (result >> 2) + 2654435769u + *(unsigned __int8 *)(a2 + v2++);
  while (v2 != 16);
  return result;
}

uint64_t sub_1002EC87C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_QWORD *)a2 == *(_QWORD *)a3 && *(_QWORD *)(a2 + 8) == *(_QWORD *)(a3 + 8))
    return sub_1002EC8A4((unsigned __int8 *)(a2 + 16), (unsigned __int8 *)(a3 + 16));
  else
    return 0;
}

uint64_t sub_1002EC8A4(unsigned __int8 *a1, unsigned __int8 *a2)
{
  BOOL v2;
  _BOOL8 v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  BOOL v14;

  if (a1[24])
    v2 = a2[24] == 0;
  else
    v2 = 1;
  if (v2)
    return (a1[24] != 0) == (a2[24] != 0);
  v4 = a1[23];
  if ((v4 & 0x80u) == 0)
    v5 = a1[23];
  else
    v5 = *((_QWORD *)a1 + 1);
  v6 = a2[23];
  v7 = (char)v6;
  if ((v6 & 0x80u) != 0)
    v6 = *((_QWORD *)a2 + 1);
  if (v5 != v6)
    return 0;
  if (v7 < 0)
    a2 = *(unsigned __int8 **)a2;
  if ((v4 & 0x80) != 0)
    return memcmp(*(const void **)a1, a2, *((_QWORD *)a1 + 1)) == 0;
  if (!a1[23])
    return 1;
  v8 = v4 - 1;
  do
  {
    v10 = *a1++;
    v9 = v10;
    v12 = *a2++;
    v11 = v12;
    v14 = v8-- != 0;
    v2 = v9 == v11;
    v3 = v9 == v11;
  }
  while (v2 && v14);
  return v3;
}

unint64_t sub_1002EC974(int a1)
{
  if ((a1 - 1) > 3)
    return 0;
  else
    return qword_101B9AC98[a1 - 1] | (unint64_t)&_mh_execute_header;
}

BOOL sub_1002EC99C(int a1)
{
  return a1 == 1;
}

void sub_1002EC9A8(id a1)
{
  qword_1022A00F8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_1002EC9D4(uint64_t *a1@<X1>, double *a2@<X2>, _BYTE *a3@<X8>)
{
  BOOL v6;
  int v7;
  NSObject *v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  int v13;
  double v14;
  _BYTE v15[24];
  uint8_t v16[136];
  uint8_t buf[4];
  int v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  int v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;

  if (*((_BYTE *)a1 + 16))
    v6 = 1;
  else
    v6 = *((_BYTE *)a1 + 9) == 0;
  v7 = !v6;
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E438);
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
  {
    v8 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
    {
      v9 = *a1;
      v10 = *((unsigned __int8 *)a1 + 8);
      v11 = *((unsigned __int8 *)a1 + 9);
      v12 = *((_DWORD *)a1 + 3);
      v13 = *((unsigned __int8 *)a1 + 16);
      *(_DWORD *)buf = 68290563;
      v18 = 0;
      v19 = 2082;
      v20 = "";
      v21 = 2049;
      v22 = v9;
      v23 = 1025;
      v24 = v10;
      v25 = 1025;
      v26 = v11;
      v27 = 1025;
      v28 = v12;
      v29 = 1025;
      v30 = v13;
      v31 = 1025;
      v32 = v7;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"batterylevel\", \"level\":\"%{private}f\", \"charged\":%{private}d, \"connected\":%{private}d, \"chargerType\":%{private}d, \"wasConnected\":%{private}d, \"isNewlyConnected\":%{private}d}", buf, 0x3Au);
    }
  }
  v14 = *a2;
  sub_1002BBB9C((uint64_t)v15);
  sub_1002ECBE8((uint64_t)v15, 0, 0, 3u, (uint64_t)v16, v14);
  buf[0] = v7;
  sub_1002DF194(&v19);
  *a3 = buf[0];
  sub_1002DF194(a3 + 8);
  sub_1002DF2E0(&v19);
  sub_1002DF2E0(v16);
  sub_1002CC91C((wireless_diagnostics::google::protobuf::MessageLite *)v15);
}

void sub_1002ECBAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  uint64_t v12;

  sub_1002DF2E0(v12);
  sub_1002DF2E0(&a12);
  sub_1002CC91C((wireless_diagnostics::google::protobuf::MessageLite *)&a9);
  _Unwind_Resume(a1);
}

void sub_1002ECBE8(uint64_t a1@<X0>, char a2@<W1>, char a3@<W2>, unsigned int a4@<W3>, uint64_t a5@<X8>, double a6@<D0>)
{
  unsigned int v12;
  int v13;
  const char *v14;
  int v15;
  const char *v16;

  sub_1002BBFAC(a5);
  v12 = *(_DWORD *)(a1 + 8);
  if (!sub_1002BC6A4(v12))
  {
    v14 = "::CLMicroLocationProto::EventType_IsValid(value)";
    v15 = 19803;
    v16 = "set_eventtype";
    goto LABEL_6;
  }
  v13 = *(_DWORD *)(a5 + 128);
  *(_DWORD *)(a5 + 72) = v12;
  *(double *)(a5 + 8) = a6;
  *(_BYTE *)(a5 + 77) = a2;
  *(_DWORD *)(a5 + 128) = v13 | 0x2803;
  *(_BYTE *)(a5 + 76) = a3;
  if ((sub_1002BC674(a4) & 1) == 0)
  {
    v14 = "::CLMicroLocationProto::ConfidenceLevel_IsValid(value)";
    v15 = 20312;
    v16 = "set_confidencelevel";
LABEL_6:
    __assert_rtn(v16, "microlocation.pb.h", v15, v14);
  }
  *(_DWORD *)(a5 + 128) |= 0x4000u;
  *(_DWORD *)(a5 + 120) = a4;
  sub_1003581E8(a5, a1);
}

void sub_1002ECCCC(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1002DF2E0(v1);
  _Unwind_Resume(a1);
}

void sub_1002ECCE0(id a1)
{
  qword_1022A00F8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

uint64_t sub_1002ECD0C(uint64_t a1)
{
  CFStringRef v2;
  _BOOL4 v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::string __p;
  std::string v9;
  uint64_t v10;
  std::__shared_weak_count *v11;

  *(_DWORD *)(a1 + 12) = 0;
  *(_QWORD *)a1 = 0;
  *(_BYTE *)(a1 + 8) = 0;
  sub_1003A336C(a1 + 16);
  *(_OWORD *)(a1 + 232) = 0u;
  *(_BYTE *)(a1 + 72) = 0;
  *(_BYTE *)(a1 + 192) = 0;
  *(_QWORD *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 216) = 0;
  *(_QWORD *)(a1 + 200) = 0;
  *(_DWORD *)(a1 + 224) = 0;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_QWORD *)(a1 + 280) = 0;
  *(_DWORD *)(a1 + 288) = 1065353216;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  sub_1001E4804(&v10);
  memset(&v9, 0, sizeof(v9));
  v2 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsVersion", 0x8000100u, kCFAllocatorNull);
  v3 = sub_1000BD5F0(v10, (uint64_t)v2, &v9);
  CFRelease(v2);
  if (v3)
  {
    if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0)
      sub_100115CE4(&__p, v9.__r_.__value_.__l.__data_, v9.__r_.__value_.__l.__size_);
    else
      __p = v9;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      sub_100115CE4((_BYTE *)(a1 + 328), __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    else
    {
      *(std::string *)(a1 + 328) = __p;
    }
  }
  else
  {
    sub_1015A2E04((_QWORD *)(a1 + 328), "2.0.9");
  }
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v9.__r_.__value_.__l.__data_);
  v4 = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return a1;
}

void sub_1002ECEB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21)
{
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void *v25;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  sub_100261F44((uint64_t)&a21);
  v25 = *(void **)(v21 + 304);
  if (v25)
  {
    *(_QWORD *)(v21 + 312) = v25;
    operator delete(v25);
  }
  sub_100270738(v21 + 256);
  sub_1002707B4((void ***)&a15);
  sub_100270824(v23);
  sub_100067AC4(v22);
  _Unwind_Resume(a1);
}

std::string *sub_1002ECF30@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t i;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *j;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  std::string *v17;
  std::string *v18;
  uint64_t k;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  std::string *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  unsigned int v30;
  NSObject *v31;
  _BOOL4 v32;
  BOOL v33;
  int v34;
  _DWORD *v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int *v38;
  unsigned int *m;
  unsigned int v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  std::string *v45;
  const char *v47;
  int v48;
  const char *v49;
  int v50;
  const char *v51;
  __int128 v52;
  char v53;
  std::string __str;

  sub_1002BBA84(a2);
  v4 = *(_QWORD *)(a1 + 232);
  for (i = *(_QWORD *)(a1 + 240); v4 != i; v4 += 32)
  {
    v6 = *(_DWORD *)(a2 + 20);
    v7 = *(int *)(a2 + 16);
    if ((int)v7 >= v6)
    {
      if (v6 == *(_DWORD *)(a2 + 24))
      {
        wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 8), v6 + 1);
        v6 = *(_DWORD *)(a2 + 20);
      }
      *(_DWORD *)(a2 + 20) = v6 + 1;
      sub_1002F31D0();
    }
    v8 = *(_QWORD *)(a2 + 8);
    *(_DWORD *)(a2 + 16) = v7 + 1;
    v9 = *(_QWORD *)(v8 + 8 * v7);
    v10 = *(_QWORD *)v4;
    v52 = *(_OWORD *)(v4 + 16);
    v53 = 1;
    sub_10039220C(v10, (uint64_t)&v52, (uint64_t)&__str);
    sub_1002C3760(v9, (uint64_t)&__str);
    sub_1002C2B30(&__str);
  }
  for (j = *(_QWORD **)(a1 + 272); j; j = (_QWORD *)*j)
  {
    v12 = *(_DWORD *)(a2 + 68);
    v13 = *(int *)(a2 + 64);
    if ((int)v13 >= v12)
    {
      if (v12 == *(_DWORD *)(a2 + 72))
      {
        wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 56), v12 + 1);
        v12 = *(_DWORD *)(a2 + 68);
      }
      *(_DWORD *)(a2 + 68) = v12 + 1;
      sub_1002F3230();
    }
    v14 = *(_QWORD *)(a2 + 56);
    *(_DWORD *)(a2 + 64) = v13 + 1;
    v15 = *(_QWORD *)(v14 + 8 * v13);
    v16 = 0;
    *((_BYTE *)&__str.__r_.__value_.__s + 23) = 16;
    do
    {
      __str.__r_.__value_.__s.__data_[v16] = *((_BYTE *)j + v16 + 16);
      ++v16;
    }
    while (v16 != 16);
    __str.__r_.__value_.__s.__data_[16] = 0;
    *(_DWORD *)(v15 + 44) |= 1u;
    v17 = *(std::string **)(v15 + 8);
    if (v17 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      operator new();
    v18 = std::string::operator=(v17, &__str);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__str.__r_.__value_.__l.__data_);
    v20 = j[4];
    for (k = j[5]; v20 != k; v20 += 16)
    {
      v21 = 0;
      *((_BYTE *)&__str.__r_.__value_.__s + 23) = 16;
      do
      {
        __str.__r_.__value_.__s.__data_[v21] = *(_BYTE *)(v20 + v21);
        ++v21;
      }
      while (v21 != 16);
      __str.__r_.__value_.__s.__data_[16] = 0;
      v22 = *(_DWORD *)(v15 + 28);
      v23 = *(int *)(v15 + 24);
      if ((int)v23 >= v22)
      {
        if (v22 == *(_DWORD *)(v15 + 32))
        {
          v18 = (std::string *)wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v15 + 16), v22 + 1);
          v22 = *(_DWORD *)(v15 + 28);
        }
        *(_DWORD *)(v15 + 28) = v22 + 1;
        v25 = (std::string *)wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase::New((wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *)v18);
        v26 = *(_QWORD *)(v15 + 16);
        v27 = *(int *)(v15 + 24);
        *(_DWORD *)(v15 + 24) = v27 + 1;
        *(_QWORD *)(v26 + 8 * v27) = v25;
      }
      else
      {
        v24 = *(_QWORD *)(v15 + 16);
        *(_DWORD *)(v15 + 24) = v23 + 1;
        v25 = *(std::string **)(v24 + 8 * v23);
      }
      v18 = std::string::operator=(v25, &__str);
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__str.__r_.__value_.__l.__data_);
    }
  }
  v28 = *(_QWORD *)(a1 + 280);
  *(_DWORD *)(a2 + 192) |= 2u;
  *(_QWORD *)(a2 + 32) = v28;
  v29 = *(_DWORD *)a1;
  if (!sub_1002BC6DC(*(_DWORD *)a1))
  {
    v47 = "::CLMicroLocationProto::Model_GenerationAlgorithm_IsValid(value)";
    v48 = 12260;
    v49 = "set_generationalgorithm";
    goto LABEL_57;
  }
  *(_DWORD *)(a2 + 192) |= 8u;
  *(_DWORD *)(a2 + 48) = v29;
  v30 = *(_DWORD *)(a1 + 4);
  if (!sub_10002A324(v30))
  {
    v47 = "::CLMicroLocationProto::Model_ModelType_IsValid(value)";
    v48 = 12283;
    v49 = "set_modeltype";
LABEL_57:
    __assert_rtn(v49, "microlocation.pb.h", v48, v47);
  }
  *(_DWORD *)(a2 + 192) |= 0x10u;
  *(_DWORD *)(a2 + 52) = v30;
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E458);
  v31 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
  {
    v32 = sub_1002ED63C(a1);
    __str.__r_.__value_.__r.__words[0] = 68289282;
    LOWORD(__str.__r_.__value_.__r.__words[1]) = 2082;
    *(std::string::size_type *)((char *)&__str.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
    WORD1(__str.__r_.__value_.__r.__words[2]) = 1026;
    HIDWORD(__str.__r_.__value_.__r.__words[2]) = v32;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"isStable, toProtobuf\", \"isStableflag\":%{public}hhd}", (uint8_t *)&__str, 0x18u);
  }
  v33 = sub_1002ED63C(a1);
  v34 = *(_DWORD *)(a2 + 192);
  *(_BYTE *)(a2 + 104) = v33;
  *(_DWORD *)(a2 + 108) = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a2 + 192) = v34 | 0x380;
  v35 = *(_DWORD **)(a2 + 112);
  if (!v35)
    operator new();
  sub_1003A3604(a1 + 16, (int *)&__str);
  sub_1002C5494(v35, (uint64_t)&__str);
  sub_1002C5084((uint64_t *)&__str);
  v36 = *(_DWORD *)(a1 + 296);
  if (!sub_10002A324(v36))
  {
    v50 = 12484;
    v51 = "set_qualityindicator";
    goto LABEL_60;
  }
  *(_DWORD *)(a2 + 192) |= 0x800u;
  *(_DWORD *)(a2 + 128) = v36;
  v37 = *(_DWORD *)(a1 + 300);
  if (!sub_10002A324(v37))
  {
    v50 = 12507;
    v51 = "set_candidatequalityindicator";
LABEL_60:
    __assert_rtn(v51, "microlocation.pb.h", v50, "::CLMicroLocationProto::Model_ModelQualityLevel_IsValid(value)");
  }
  *(_DWORD *)(a2 + 192) |= 0x1000u;
  *(_DWORD *)(a2 + 132) = v37;
  v38 = *(unsigned int **)(a1 + 304);
  for (m = *(unsigned int **)(a1 + 312); v38 != m; ++v38)
  {
    v40 = *v38;
    if (!sub_1002BC698(*v38))
      __assert_rtn("add_candidatequalityreasons", "microlocation.pb.h", 12527, "::CLMicroLocationProto::ServiceQualityReasonEnum_IsValid(value)");
    v41 = *(_DWORD *)(a2 + 144);
    if (v41 == *(_DWORD *)(a2 + 148))
    {
      sub_1002A19E0(a2 + 136, v41 + 1);
      v41 = *(_DWORD *)(a2 + 144);
    }
    v42 = *(_QWORD *)(a2 + 136);
    *(_DWORD *)(a2 + 144) = v41 + 1;
    *(_DWORD *)(v42 + 4 * v41) = v40;
  }
  if (*(_DWORD *)(a1 + 4) == 2 && *(_BYTE *)(a1 + 192))
  {
    *(_DWORD *)(a2 + 192) |= 0x400u;
    v43 = *(_QWORD *)(a2 + 120);
    if (!v43)
      operator new();
    sub_1002ED928((uint64_t *)(a1 + 72), (uint64_t)&__str);
    sub_1002C7974(v43, (uint64_t)&__str);
    sub_1002C725C((uint64_t)&__str);
  }
  v44 = *(_DWORD *)(a2 + 192);
  *(_OWORD *)(a2 + 152) = *(_OWORD *)(a1 + 200);
  *(_QWORD *)(a2 + 168) = *(_QWORD *)(a1 + 216);
  *(_DWORD *)(a2 + 184) = *(_DWORD *)(a1 + 224);
  *(_DWORD *)(a2 + 192) = v44 | 0x3FC000;
  v45 = *(std::string **)(a2 + 176);
  if (v45 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    operator new();
  return std::string::operator=(v45, (const std::string *)(a1 + 328));
}

void sub_1002ED56C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  operator delete();
}

uint64_t sub_1002ED634(uint64_t a1)
{
  return *(_QWORD *)(a1 + 280);
}

BOOL sub_1002ED63C(uint64_t a1)
{
  _QWORD *v3;
  unint64_t v4;
  NSObject *v5;
  uint64_t v6;
  int v7;
  CFStringRef v8;
  int v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  CFStringRef v16;
  int v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t v22;
  unsigned int v23;
  uint8_t buf[8];
  _BYTE v25[10];
  __int16 v26;
  unint64_t v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  int v31;

  if (*(_DWORD *)(a1 + 4) == 2)
    return *(_BYTE *)(a1 + 8) != 0;
  v3 = *(_QWORD **)(a1 + 272);
  if (v3)
  {
    v4 = 0;
    do
    {
      v4 += (uint64_t)(v3[5] - v3[4]) >> 4;
      v3 = (_QWORD *)*v3;
    }
    while (v3);
  }
  else
  {
    v4 = 0;
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E458);
  v5 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
  {
    v6 = *(unsigned int *)(a1 + 12);
    v7 = *(unsigned __int8 *)(a1 + 8);
    *(_DWORD *)buf = 68289794;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)v25 = 2082;
    *(_QWORD *)&v25[2] = "";
    v26 = 2050;
    v27 = v4;
    v28 = 2050;
    v29 = v6;
    v30 = 1026;
    v31 = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"isStable, getter\", \"numRecordingsBeforePruning\":%{public}ld, \"numDaysWithRecordings\":%{public}ld, \"fIsStable\":%{public}hhd}", buf, 0x2Cu);
  }
  if (*(_BYTE *)(a1 + 8))
    return 1;
  sub_1001E4804(buf);
  v23 = 0;
  v8 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsMinimumNumberOfRecordingsInStableModel", 0x8000100u, kCFAllocatorNull);
  v9 = sub_1000B1180(*(uint64_t *)buf, (uint64_t)v8, &v23);
  CFRelease(v8);
  v10 = v23;
  v11 = *(std::__shared_weak_count **)v25;
  if (*(_QWORD *)v25)
  {
    v12 = (unint64_t *)(*(_QWORD *)v25 + 8);
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  v14 = 200;
  if (v9)
    v14 = v10;
  if (v4 >= v14)
    return 1;
  v15 = *(unsigned int *)(a1 + 12);
  sub_1001E4804(buf);
  v23 = 0;
  v16 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsMinimumNumberOfDaysWithRecordingsInStableModel", 0x8000100u, kCFAllocatorNull);
  v17 = sub_1000B1180(*(uint64_t *)buf, (uint64_t)v16, &v23);
  CFRelease(v16);
  v18 = v23;
  v19 = *(std::__shared_weak_count **)v25;
  if (*(_QWORD *)v25)
  {
    v20 = (unint64_t *)(*(_QWORD *)v25 + 8);
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  v22 = 10;
  if (v17)
    v22 = v18;
  return v22 <= v15;
}

void sub_1002ED8E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  sub_100261F44((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002ED910(uint64_t a1)
{
  return *(unsigned int *)(a1 + 296);
}

uint64_t sub_1002ED918(uint64_t a1)
{
  return *(unsigned int *)(a1 + 300);
}

uint64_t sub_1002ED920(uint64_t a1)
{
  return a1 + 304;
}

void sub_1002ED928(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  std::string *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int *v14;
  unsigned int *i;
  unsigned int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  std::string *v28;
  unint64_t v29;
  std::string::size_type v30;
  int v31;
  uint64_t v32;
  std::string __str;

  v4 = (wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *)sub_1002BBA5C(a2);
  v5 = *a1;
  v6 = a1[1];
  if (*a1 != v6)
  {
    do
    {
      v7 = 0;
      *((_BYTE *)&__str.__r_.__value_.__s + 23) = 16;
      do
      {
        __str.__r_.__value_.__s.__data_[v7] = *(_BYTE *)(v5 + v7);
        ++v7;
      }
      while (v7 != 16);
      __str.__r_.__value_.__s.__data_[16] = 0;
      v8 = *(_DWORD *)(a2 + 20);
      v9 = *(int *)(a2 + 16);
      if ((int)v9 >= v8)
      {
        if (v8 == *(_DWORD *)(a2 + 24))
        {
          v4 = (wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *)wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 8), v8 + 1);
          v8 = *(_DWORD *)(a2 + 20);
        }
        *(_DWORD *)(a2 + 20) = v8 + 1;
        v11 = (std::string *)wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase::New(v4);
        v12 = *(_QWORD *)(a2 + 8);
        v13 = *(int *)(a2 + 16);
        *(_DWORD *)(a2 + 16) = v13 + 1;
        *(_QWORD *)(v12 + 8 * v13) = v11;
      }
      else
      {
        v10 = *(_QWORD *)(a2 + 8);
        *(_DWORD *)(a2 + 16) = v9 + 1;
        v11 = *(std::string **)(v10 + 8 * v9);
      }
      v4 = (wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *)std::string::operator=(v11, &__str);
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__str.__r_.__value_.__l.__data_);
      v5 += 16;
    }
    while (v5 != v6);
  }
  v14 = (unsigned int *)a1[10];
  for (i = (unsigned int *)a1[11]; v14 != i; ++v14)
  {
    v16 = *v14;
    if ((sub_1002BC674(*v14) & 1) == 0)
      __assert_rtn("add_eventconfidences", "microlocation.pb.h", 12157, "::CLMicroLocationProto::ConfidenceLevel_IsValid(value)");
    v17 = *(_DWORD *)(a2 + 64);
    if (v17 == *(_DWORD *)(a2 + 68))
    {
      sub_1002A19E0(a2 + 56, v17 + 1);
      v17 = *(_DWORD *)(a2 + 64);
    }
    v18 = *(_QWORD *)(a2 + 56);
    *(_DWORD *)(a2 + 64) = v17 + 1;
    *(_DWORD *)(v18 + 4 * v17) = v16;
  }
  v19 = a1[3];
  if (a1[4] != v19)
  {
    v20 = 0;
    v21 = 0;
    do
    {
      v22 = *(_DWORD *)(a2 + 44);
      v23 = *(int *)(a2 + 40);
      if ((int)v23 >= v22)
      {
        if (v22 == *(_DWORD *)(a2 + 48))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 32), v22 + 1);
          v22 = *(_DWORD *)(a2 + 44);
        }
        *(_DWORD *)(a2 + 44) = v22 + 1;
        sub_1002F3338();
      }
      v24 = *(_QWORD *)(a2 + 32);
      *(_DWORD *)(a2 + 40) = v23 + 1;
      v25 = *(_QWORD *)(v24 + 8 * v23);
      v26 = 0;
      *((_BYTE *)&__str.__r_.__value_.__s + 23) = 16;
      v27 = v19 + v20;
      do
      {
        __str.__r_.__value_.__s.__data_[v26] = *(_BYTE *)(v27 + v26);
        ++v26;
      }
      while (v26 != 16);
      __str.__r_.__value_.__s.__data_[16] = 0;
      *(_DWORD *)(v25 + 36) |= 1u;
      v28 = *(std::string **)(v25 + 8);
      if (v28 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
        operator new();
      std::string::operator=(v28, &__str);
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__str.__r_.__value_.__l.__data_);
      if (a1[1] != *a1)
      {
        v29 = 0;
        do
        {
          __str.__r_.__value_.__r.__words[0] = 0;
          sub_1002EBF90((uint64_t)(a1 + 6), v21, v29, &__str);
          v30 = __str.__r_.__value_.__r.__words[0];
          v31 = *(_DWORD *)(v25 + 24);
          if (v31 == *(_DWORD *)(v25 + 28))
          {
            sub_1002E60A0(v25 + 16, v31 + 1);
            v31 = *(_DWORD *)(v25 + 24);
          }
          v32 = *(_QWORD *)(v25 + 16);
          *(_DWORD *)(v25 + 24) = v31 + 1;
          *(_QWORD *)(v32 + 8 * v31) = v30;
          ++v29;
        }
        while (v29 < (a1[1] - *a1) >> 4);
      }
      ++v21;
      v19 = a1[3];
      v20 += 16;
    }
    while (v21 < (a1[4] - v19) >> 4);
  }
}

void sub_1002EDC50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  sub_1002C725C(v15);
  _Unwind_Resume(a1);
}

void sub_1002EDC8C(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  NSObject *v11;
  const char *v12;
  uint8_t *v13;
  uint64_t **v14;
  int v15;
  NSObject *v16;
  NSObject *v17;
  const char *v18;
  uint8_t *v19;
  const char *v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t **v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  int v31;
  NSObject *v32;
  const char *v33;
  uint8_t *v34;
  NSObject *v35;
  const char *v36;
  uint8_t *v37;
  uint64_t v38;
  int v39;
  NSObject *v40;
  int v41;
  uint64_t v42;
  int v43;
  _QWORD *v44;
  unint64_t v45;
  CFStringRef v46;
  int v47;
  unint64_t v48;
  std::__shared_weak_count *v49;
  unint64_t *v50;
  unint64_t v51;
  unint64_t v52;
  int v53;
  NSObject *v54;
  int v55;
  uint64_t v56;
  char *v57;
  int *v58;
  int *v59;
  int v60;
  uint64_t v61;
  char *v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  unint64_t v66;
  char *v67;
  char *v68;
  int v69;
  unint64_t v70;
  uint64_t *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  _QWORD v75[3];
  void *v76[3];
  _DWORD v77[4];
  uint64_t *v78;
  void *__src;
  char *v80;
  char *v81;
  uint8_t buf[64];
  _BYTE v83[16];
  void *v84;
  uint64_t v85;
  uint64_t v86;
  _BYTE v87[64];
  void *__p;
  void *v89;
  __int128 v90;
  __int128 v91;

  sub_1002ECD0C(a3);
  v91 = 0uLL;
  v90 = 0uLL;
  v74 = a1;
  v6 = *(int *)(a1 + 16);
  if ((_DWORD)v6)
  {
    v7 = *(uint64_t **)(a1 + 8);
    v8 = 8 * v6;
    while (1)
    {
      v9 = *v7;
      v10 = *(_DWORD *)(*v7 + 104);
      if ((v10 & 0x20) != 0)
        break;
      if ((v10 & 2) != 0)
      {
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212E458);
        v16 = qword_1022A00F8;
        if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#Warning The protobuf fingerprint is using a deprecated uint64 cluster label", buf, 2u);
        }
        if (sub_1001BFF7C(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1022A00F0 != -1)
            dispatch_once(&qword_1022A00F0, &stru_10212E458);
          LOWORD(v77[0]) = 0;
          LODWORD(v73) = 2;
          _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#Warning The protobuf fingerprint is using a deprecated uint64 cluster label", v77, v73);
          v19 = (uint8_t *)v18;
          sub_100512490("Generic", 1, 0, 2, "static CLMicroLocationModel CLMicroLocationModel::fromProtobuf(const CLMicroLocationProto::Model &, CLMicroLocationFingerprintPool &)", "%s\n", v18);
          if (v19 != buf)
            free(v19);
        }
        *(_QWORD *)&v91 = *(_QWORD *)(v9 + 32);
        goto LABEL_25;
      }
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E458);
      v11 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#Warning The protobuf fingerprint does not have a cluster identifer", buf, 2u);
      }
      if (sub_1001BFF7C(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212E458);
        LOWORD(v77[0]) = 0;
        LODWORD(v73) = 2;
        _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#Warning The protobuf fingerprint does not have a cluster identifer", v77, v73);
        v13 = (uint8_t *)v12;
        sub_100512490("Generic", 1, 0, 2, "static CLMicroLocationModel CLMicroLocationModel::fromProtobuf(const CLMicroLocationProto::Model &, CLMicroLocationFingerprintPool &)", "%s\n", v12);
LABEL_42:
        if (v13 != buf)
          free(v13);
      }
LABEL_33:
      ++v7;
      v8 -= 8;
      if (!v8)
        goto LABEL_44;
    }
    v14 = *(uint64_t ***)(v9 + 64);
    v15 = *((char *)v14 + 23);
    if (v15 < 0)
    {
      if (v14[1] == (uint64_t *)16)
      {
        v14 = (uint64_t **)*v14;
LABEL_24:
        v91 = *(_OWORD *)v14;
LABEL_25:
        sub_1003906A0((uint64_t)buf, v9);
        sub_1002EEA94(a3, (uint64_t)buf, &v91, a2);
        if (__p)
        {
          v89 = __p;
          operator delete(__p);
        }
        sub_100067AC4((uint64_t)v87);
        sub_100067AC4((uint64_t)v83);
        sub_100271390((uint64_t)buf);
        goto LABEL_33;
      }
    }
    else if (v15 == 16)
    {
      goto LABEL_24;
    }
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E458);
    v17 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#Warning The protobuf fingerprint does not have a valid cluster label uuid", buf, 2u);
    }
    if (!sub_1001BFF7C(115, 2))
      goto LABEL_33;
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E458);
    LOWORD(v77[0]) = 0;
    LODWORD(v73) = 2;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#Warning The protobuf fingerprint does not have a valid cluster label uuid", v77, v73);
    v13 = (uint8_t *)v20;
    sub_100512490("Generic", 1, 0, 2, "static CLMicroLocationModel CLMicroLocationModel::fromProtobuf(const CLMicroLocationProto::Model &, CLMicroLocationFingerprintPool &)", "%s\n", v20);
    goto LABEL_42;
  }
LABEL_44:
  v21 = *(int *)(v74 + 64);
  if ((_DWORD)v21)
  {
    v22 = *(uint64_t **)(v74 + 56);
    v23 = &v22[v21];
    while (1)
    {
      v24 = *v22;
      v25 = *(uint64_t ***)(*v22 + 8);
      v26 = *((char *)v25 + 23);
      if (v26 < 0)
      {
        if (v25[1] != (uint64_t *)16)
        {
LABEL_70:
          if (qword_1022A00F0 != -1)
            dispatch_once(&qword_1022A00F0, &stru_10212E458);
          v35 = qword_1022A00F8;
          if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#Warning The protobuf cluster recording does not have a valid cluster label uuid", buf, 2u);
          }
          if (sub_1001BFF7C(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1022A00F0 != -1)
              dispatch_once(&qword_1022A00F0, &stru_10212E458);
            LOWORD(v77[0]) = 0;
            LODWORD(v73) = 2;
            _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#Warning The protobuf cluster recording does not have a valid cluster label uuid", v77, v73);
            v37 = (uint8_t *)v36;
            sub_100512490("Generic", 1, 0, 2, "static CLMicroLocationModel CLMicroLocationModel::fromProtobuf(const CLMicroLocationProto::Model &, CLMicroLocationFingerprintPool &)", "%s\n", v36);
            if (v37 != buf)
              free(v37);
          }
          goto LABEL_75;
        }
        v25 = (uint64_t **)*v25;
      }
      else if (v26 != 16)
      {
        goto LABEL_70;
      }
      v91 = *(_OWORD *)v25;
      v27 = *(int *)(v24 + 24);
      if ((_DWORD)v27)
        break;
LABEL_75:
      if (++v22 == v23)
        goto LABEL_81;
    }
    v28 = *(_QWORD *)(v24 + 16);
    v29 = 8 * v27;
    while (1)
    {
      v30 = *(_QWORD **)v28;
      v31 = *(char *)(*(_QWORD *)v28 + 23);
      if (v31 < 0)
      {
        if (v30[1] != 16)
        {
LABEL_59:
          if (qword_1022A00F0 != -1)
            dispatch_once(&qword_1022A00F0, &stru_10212E458);
          v32 = qword_1022A00F8;
          if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#Warning The protobuf cluster recording does not have a valid recording uuid", buf, 2u);
          }
          if (sub_1001BFF7C(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1022A00F0 != -1)
              dispatch_once(&qword_1022A00F0, &stru_10212E458);
            LOWORD(v77[0]) = 0;
            LODWORD(v73) = 2;
            _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#Warning The protobuf cluster recording does not have a valid recording uuid", v77, v73);
            v34 = (uint8_t *)v33;
            sub_100512490("Generic", 1, 0, 2, "static CLMicroLocationModel CLMicroLocationModel::fromProtobuf(const CLMicroLocationProto::Model &, CLMicroLocationFingerprintPool &)", "%s\n", v33);
            if (v34 != buf)
              free(v34);
          }
          goto LABEL_64;
        }
        v30 = (_QWORD *)*v30;
      }
      else if (v31 != 16)
      {
        goto LABEL_59;
      }
      v90 = *(_OWORD *)v30;
      sub_1002EEBC4(a3, &v91, &v90);
LABEL_64:
      v28 += 8;
      v29 -= 8;
      if (!v29)
        goto LABEL_75;
    }
  }
LABEL_81:
  v38 = v74;
  v39 = *(_DWORD *)(v74 + 52) & ((int)(*(_DWORD *)(v74 + 192) << 27) >> 31);
  *(_DWORD *)a3 = *(_DWORD *)(v74 + 48);
  *(_DWORD *)(a3 + 4) = v39;
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E458);
  v40 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
  {
    v41 = *(unsigned __int8 *)(v74 + 104);
    *(_DWORD *)buf = 68289282;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = "";
    *(_WORD *)&buf[18] = 1026;
    *(_DWORD *)&buf[20] = v41;
    _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"isStable, fromProtobuf\", \"isStableFlag\":%{public}hhd}", buf, 0x18u);
  }
  *(_BYTE *)(a3 + 8) = *(_BYTE *)(v74 + 104);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(v74 + 108);
  if ((*(_BYTE *)(v74 + 193) & 1) != 0)
  {
    v42 = *(_QWORD *)(v74 + 112);
    if (!v42)
      v42 = *(_QWORD *)(qword_102310300 + 112);
    sub_1003A33C0((uint64_t)buf, v42);
    if ((uint8_t *)(a3 + 16) != buf)
    {
      *(_DWORD *)(a3 + 48) = *(_DWORD *)&buf[32];
      sub_100270130((_QWORD *)(a3 + 16), *(uint64_t **)&buf[16], 0);
    }
    *(_OWORD *)(a3 + 56) = *(_OWORD *)&buf[40];
    sub_100067AC4((uint64_t)buf);
  }
  v43 = *(_DWORD *)(v74 + 128);
  *(_DWORD *)(a3 + 296) = v43;
  if (!v43)
  {
    v44 = *(_QWORD **)(a3 + 272);
    if (v44)
    {
      v45 = 0;
      do
      {
        v45 += (uint64_t)(v44[5] - v44[4]) >> 4;
        v44 = (_QWORD *)*v44;
      }
      while (v44);
    }
    else
    {
      v45 = 0;
    }
    sub_1001E4804(buf);
    v77[0] = 0;
    v46 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsModelQualityNumFingerprintsWiFiOnlyThreshold", 0x8000100u, kCFAllocatorNull);
    v47 = sub_1000B1180(*(uint64_t *)buf, (uint64_t)v46, v77);
    CFRelease(v46);
    v48 = v77[0];
    v49 = *(std::__shared_weak_count **)&buf[8];
    if (*(_QWORD *)&buf[8])
    {
      v50 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
      do
        v51 = __ldaxr(v50);
      while (__stlxr(v51 - 1, v50));
      if (!v51)
      {
        ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
        std::__shared_weak_count::__release_weak(v49);
      }
    }
    v52 = 200;
    if (v47)
      v52 = v48;
    if (v45 <= v52)
      v53 = 1;
    else
      v53 = 3;
    *(_DWORD *)(a3 + 296) = v53;
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E458);
    v38 = v74;
    v54 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      v55 = *(_DWORD *)(a3 + 296);
      *(_DWORD *)buf = 68289282;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 1026;
      *(_DWORD *)&buf[20] = v55;
      _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Loaded model doesn't have model quality, calculate on the fly\", \"QualityIndicator\":%{public}d}", buf, 0x18u);
    }
  }
  *(_DWORD *)(a3 + 300) = *(_DWORD *)(v38 + 132);
  __src = 0;
  v80 = 0;
  v81 = 0;
  v56 = *(int *)(v38 + 144);
  if ((_DWORD)v56)
  {
    v57 = 0;
    v58 = *(int **)(v38 + 136);
    v59 = &v58[v56];
    do
    {
      v60 = *v58;
      if (v57 >= v81)
      {
        v62 = (char *)__src;
        v63 = (v57 - (_BYTE *)__src) >> 2;
        v64 = v63 + 1;
        if ((unint64_t)(v63 + 1) >> 62)
          sub_100259694();
        v65 = v81 - (_BYTE *)__src;
        if ((v81 - (_BYTE *)__src) >> 1 > v64)
          v64 = v65 >> 1;
        if ((unint64_t)v65 >= 0x7FFFFFFFFFFFFFFCLL)
          v66 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v66 = v64;
        if (v66)
        {
          v67 = (char *)sub_100260634((uint64_t)&v81, v66);
          v62 = (char *)__src;
          v57 = v80;
        }
        else
        {
          v67 = 0;
        }
        v68 = &v67[4 * v63];
        *(_DWORD *)v68 = v60;
        v61 = (uint64_t)(v68 + 4);
        while (v57 != v62)
        {
          v69 = *((_DWORD *)v57 - 1);
          v57 -= 4;
          *((_DWORD *)v68 - 1) = v69;
          v68 -= 4;
        }
        __src = v68;
        v80 = (char *)v61;
        v81 = &v67[4 * v66];
        if (v62)
          operator delete(v62);
      }
      else
      {
        *(_DWORD *)v57 = v60;
        v61 = (uint64_t)(v57 + 4);
      }
      v80 = (char *)v61;
      ++v58;
      v57 = (char *)v61;
    }
    while (v58 != v59);
  }
  else
  {
    v61 = 0;
  }
  if ((void **)(a3 + 304) != &__src)
    sub_1002A3054((char *)(a3 + 304), (char *)__src, v61, (v61 - (uint64_t)__src) >> 2);
  if ((*(_BYTE *)(v74 + 193) & 4) != 0)
  {
    v72 = *(_QWORD *)(v74 + 120);
    if (!v72)
      v72 = *(_QWORD *)(qword_102310300 + 120);
    sub_1002EED38(v72, (uint64_t)buf);
  }
  if (v39 == 2)
  {
    sub_1002EF90C((_QWORD *)a3, (uint64_t)v77);
    memset(v76, 0, sizeof(v76));
    v70 = 0;
    if (v78)
    {
      v71 = v78;
      do
      {
        ++v70;
        v71 = (uint64_t *)*v71;
      }
      while (v71);
    }
    sub_1002F34C4((char *)v76, v78, 0, v70);
    v83[8] = 0;
    v87[8] = 0;
    memset(buf, 0, 49);
    v85 = 0;
    v86 = 0;
    v84 = 0;
    v87[0] = 0;
    memset(v75, 0, sizeof(v75));
    sub_1002EF978((uint64_t)buf, v76, v75);
  }
  *(_OWORD *)(a3 + 200) = *(_OWORD *)(v74 + 152);
  *(_QWORD *)(a3 + 216) = *(_QWORD *)(v74 + 168);
  *(_DWORD *)(a3 + 224) = *(_DWORD *)(v74 + 184);
  std::string::operator=((std::string *)(a3 + 328), *(const std::string **)(v74 + 176));
  if (__src)
  {
    v80 = (char *)__src;
    operator delete(__src);
  }
}

void sub_1002EE9B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,char a27)
{
  uint64_t v27;

  sub_10026E1B8(v27);
  _Unwind_Resume(a1);
}

void sub_1002EEA94(uint64_t a1, uint64_t a2, __int128 *a3, uint64_t a4)
{
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  __int128 v18;

  sub_1002B7570(a4, (_QWORD *)(a2 + 40), a2, &v14);
  v16 = v14;
  v17 = v15;
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v18 = *a3;
  sub_1002F1650((uint64_t *)(a1 + 232), (uint64_t)&v16);
  v8 = v17;
  if (v17)
  {
    v9 = (unint64_t *)&v17->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  v11 = v15;
  if (v15)
  {
    v12 = (unint64_t *)&v15->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
}

void sub_1002EEBA0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  sub_100261F44((uint64_t)va1);
  sub_100261F44((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1002EEBC4(uint64_t a1, _OWORD *a2, _OWORD *a3)
{
  _QWORD *v4;
  _OWORD *v5;
  unint64_t v6;
  _OWORD *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  _OWORD *v18;

  v18 = a2;
  v4 = sub_1002F45B8(a1 + 256, a2, (uint64_t)&unk_101B9EB60, &v18);
  v5 = (_OWORD *)v4[5];
  v6 = v4[6];
  if ((unint64_t)v5 >= v6)
  {
    v8 = v4[4];
    v9 = ((uint64_t)v5 - v8) >> 4;
    v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 60)
      sub_100259694();
    v11 = v6 - v8;
    if (v11 >> 3 > v10)
      v10 = v11 >> 3;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0)
      v12 = 0xFFFFFFFFFFFFFFFLL;
    else
      v12 = v10;
    if (v12)
      v13 = (char *)sub_10028E224((uint64_t)(v4 + 6), v12);
    else
      v13 = 0;
    v14 = &v13[16 * v9];
    v15 = &v13[16 * v12];
    *(_OWORD *)v14 = *a3;
    v7 = v14 + 16;
    v17 = (char *)v4[4];
    v16 = (char *)v4[5];
    if (v16 != v17)
    {
      do
      {
        *((_OWORD *)v14 - 1) = *((_OWORD *)v16 - 1);
        v14 -= 16;
        v16 -= 16;
      }
      while (v16 != v17);
      v16 = (char *)v4[4];
    }
    v4[4] = v14;
    v4[5] = v7;
    v4[6] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v5 = *a3;
    v7 = v5 + 1;
  }
  v4[5] = v7;
}

uint64_t sub_1002EECD8(uint64_t result, int a2)
{
  *(_DWORD *)(result + 296) = a2;
  return result;
}

uint64_t sub_1002EECE0(uint64_t a1)
{
  _QWORD *v1;
  uint64_t result;

  v1 = *(_QWORD **)(a1 + 272);
  if (!v1)
    return 0;
  result = 0;
  do
  {
    result += (uint64_t)(v1[5] - v1[4]) >> 4;
    v1 = (_QWORD *)*v1;
  }
  while (v1);
  return result;
}

uint64_t sub_1002EED0C(uint64_t result, int a2)
{
  *(_DWORD *)(result + 300) = a2;
  return result;
}

char *sub_1002EED14(uint64_t a1, uint64_t a2)
{
  char *result;

  result = (char *)(a1 + 304);
  if (result != (char *)a2)
    return sub_1002A3054(result, *(char **)a2, *(_QWORD *)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 2);
  return result;
}

void sub_1002EED38(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t ***v4;
  uint64_t ***v5;
  char *v6;
  char *v7;
  NSObject *v8;
  NSObject *v9;
  char *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  char *v19;
  char *v20;
  char *v21;
  char *v22;
  char *v23;
  int v24;
  int v25;
  uint64_t v26;
  NSObject *v27;
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  NSObject *v32;
  NSObject *v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  NSObject *v37;
  _OWORD *v38;
  void *p_p;
  _OWORD *v40;
  __int128 v41;
  char *v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  char *v46;
  char *v47;
  __int128 v48;
  char *v49;
  char *v50;
  char *v51;
  __int128 v52;
  void *__p;
  __int128 v55;
  void *v56;
  char *v57;
  char *v58;
  __int128 v59;
  char v60;
  __int128 v61;
  int v62;
  __int128 v63;
  char *v64;
  uint64_t buf;
  __int16 v66;
  const char *v67;
  __int16 v68;
  int v69;
  __int16 v70;
  void *v71;
  __int16 v72;
  int v73;

  v56 = 0;
  v57 = 0;
  v58 = 0;
  v3 = *(int *)(a1 + 16);
  if (!(_DWORD)v3)
  {
LABEL_42:
    v63 = 0uLL;
    v64 = 0;
    v24 = *(_DWORD *)(a1 + 40);
    v25 = *(_DWORD *)(a1 + 64);
    LODWORD(v26) = v24;
    if (v24 != v25)
    {
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E458);
      v27 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
      {
        buf = 68289026;
        v66 = 2082;
        v67 = "";
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"CLMicroLocationSimilarityListData fromProtobuf - size of confidences doesn't equal event number, setting all event's confidence to invalid\"}", (uint8_t *)&buf, 0x12u);
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212E458);
      }
      v28 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        buf = 68289026;
        v66 = 2082;
        v67 = "";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v28, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLMicroLocationSimilarityListData fromProtobuf - size of confidences doesn't equal event number, setting all event's confidence to invalid", "{\"msg%{public}.0s\":\"CLMicroLocationSimilarityListData fromProtobuf - size of confidences doesn't equal event number, setting all event's confidence to invalid\"}", (uint8_t *)&buf, 0x12u);
      }
      LODWORD(v26) = *(_DWORD *)(a1 + 40);
    }
    if ((int)v26 >= 1)
    {
      v29 = 0;
      do
      {
        if (v29 >= (int)v26)
        {
          v30 = wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage(&buf, 3, "/AppleInternal/Library/BuildRoots/f82e4213-595f-11ef-b136-76625042721f/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS18.0.Internal.sdk/usr/local/include/google/protobuf/repeated_field.h", 825);
          v31 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<(v30, "CHECK failed: (index) < (size()): ");
          wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&__p, v31);
          wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)&buf);
        }
        sub_10035777C(*(uint64_t ***)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v29) + 8), &v59);
        if (v60)
        {
          v61 = v59;
        }
        else
        {
          if (qword_1022A00F0 != -1)
            dispatch_once(&qword_1022A00F0, &stru_10212E458);
          v32 = qword_1022A00F8;
          if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
          {
            buf = 68289026;
            v66 = 2082;
            v67 = "";
            _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"CLMicroLocationSimilarityListData fromProtobuf - invalid LabelUuid conversion!\"}", (uint8_t *)&buf, 0x12u);
            if (qword_1022A00F0 != -1)
              dispatch_once(&qword_1022A00F0, &stru_10212E458);
          }
          v33 = qword_1022A00F8;
          if (os_signpost_enabled((os_log_t)qword_1022A00F8))
          {
            buf = 68289026;
            v66 = 2082;
            v67 = "";
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v33, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLMicroLocationSimilarityListData fromProtobuf - invalid LabelUuid conversion!", "{\"msg%{public}.0s\":\"CLMicroLocationSimilarityListData fromProtobuf - invalid LabelUuid conversion!\"}", (uint8_t *)&buf, 0x12u);
          }
          v61 = 0uLL;
        }
        if (v24 == v25)
        {
          if (v29 >= *(int *)(a1 + 64))
          {
            v34 = wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage(&buf, 3, "/AppleInternal/Library/BuildRoots/f82e4213-595f-11ef-b136-76625042721f/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS18.0.Internal.sdk/usr/local/include/google/protobuf/repeated_field.h", 614);
            v35 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<(v34, "CHECK failed: (index) < (size()): ");
            wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&__p, v35);
            wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)&buf);
          }
          v36 = *(_DWORD *)(*(_QWORD *)(a1 + 56) + 4 * v29);
        }
        else
        {
          v36 = 0;
        }
        v62 = v36;
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212E458);
        v37 = qword_1022A00F8;
        if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
        {
          v38 = operator new(0x28uLL);
          __p = v38;
          v55 = xmmword_101B97FF0;
          *v38 = 0u;
          v38[1] = 0u;
          *(_QWORD *)((char *)v38 + 29) = 0;
          sub_100261F9C((uint64_t)&v61, v38);
          p_p = &__p;
          if (v55 < 0)
            p_p = __p;
          buf = 68289794;
          v66 = 2082;
          v67 = "";
          v68 = 1026;
          v69 = v29;
          v70 = 2082;
          v71 = p_p;
          v72 = 1026;
          v73 = v62;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMicroLocationSimilarityListData fromProtobuf\", \"listElementInx\":%{public}d, \"event label\":%{public, location:escape_only}s, \"confidence level\":%{public}d}", (uint8_t *)&buf, 0x28u);
          if (SHIBYTE(v55) < 0)
            operator delete(__p);
        }
        v40 = (_OWORD *)*((_QWORD *)&v63 + 1);
        if (*((_QWORD *)&v63 + 1) >= (unint64_t)v64)
        {
          v43 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((_QWORD *)&v63 + 1) - v63) >> 2);
          v44 = v43 + 1;
          if (v43 + 1 > 0xCCCCCCCCCCCCCCCLL)
            sub_100259694();
          if (0x999999999999999ALL * ((uint64_t)&v64[-v63] >> 2) > v44)
            v44 = 0x999999999999999ALL * ((uint64_t)&v64[-v63] >> 2);
          if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)&v64[-v63] >> 2) >= 0x666666666666666)
            v45 = 0xCCCCCCCCCCCCCCCLL;
          else
            v45 = v44;
          if (v45)
            v46 = (char *)sub_1002F5388((uint64_t)&v64, v45);
          else
            v46 = 0;
          v47 = &v46[20 * v43];
          v48 = v61;
          *((_DWORD *)v47 + 4) = v62;
          *(_OWORD *)v47 = v48;
          v49 = (char *)*((_QWORD *)&v63 + 1);
          v50 = (char *)v63;
          v51 = v47;
          if (*((_QWORD *)&v63 + 1) != (_QWORD)v63)
          {
            do
            {
              v52 = *(_OWORD *)(v49 - 20);
              *((_DWORD *)v51 - 1) = *((_DWORD *)v49 - 1);
              *(_OWORD *)(v51 - 20) = v52;
              v51 -= 20;
              v49 -= 20;
            }
            while (v49 != v50);
            v49 = (char *)v63;
          }
          v42 = v47 + 20;
          *(_QWORD *)&v63 = v51;
          *((_QWORD *)&v63 + 1) = v47 + 20;
          v64 = &v46[20 * v45];
          if (v49)
            operator delete(v49);
        }
        else
        {
          v41 = v61;
          *(_DWORD *)(*((_QWORD *)&v63 + 1) + 16) = v62;
          *v40 = v41;
          v42 = (char *)v40 + 20;
        }
        *((_QWORD *)&v63 + 1) = v42;
        ++v29;
        v26 = *(int *)(a1 + 40);
      }
      while (v29 < v26);
    }
    *(_BYTE *)(a2 + 72) = 0;
    *(_BYTE *)(a2 + 112) = 0;
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_BYTE *)(a2 + 48) = 0;
    *(_QWORD *)(a2 + 88) = 0;
    *(_QWORD *)(a2 + 96) = 0;
    *(_QWORD *)(a2 + 80) = 0;
    *(_BYTE *)(a2 + 104) = 0;
    sub_1002EF978(a2, &v56, &v63);
  }
  v4 = *(uint64_t ****)(a1 + 8);
  v5 = &v4[v3];
  while (1)
  {
    sub_10035777C(*v4, &v63);
    if ((_BYTE)v64)
    {
      v6 = v57;
      if (v57 >= v58)
      {
        v11 = (v57 - (_BYTE *)v56) >> 4;
        v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 60)
          sub_100259694();
        v13 = v58 - (_BYTE *)v56;
        if ((v58 - (_BYTE *)v56) >> 3 > v12)
          v12 = v13 >> 3;
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF0)
          v14 = 0xFFFFFFFFFFFFFFFLL;
        else
          v14 = v12;
        if (v14)
          v15 = (char *)sub_10028E224((uint64_t)&v58, v14);
        else
          v15 = 0;
        v19 = &v15[16 * v11];
        *(_OWORD *)v19 = v63;
        v21 = (char *)v56;
        v20 = v57;
        v22 = v19;
        if (v57 != v56)
        {
          do
          {
            *((_OWORD *)v22 - 1) = *((_OWORD *)v20 - 1);
            v22 -= 16;
            v20 -= 16;
          }
          while (v20 != v21);
          goto LABEL_38;
        }
        goto LABEL_39;
      }
      *(_OWORD *)v57 = v63;
      v7 = v6 + 16;
    }
    else
    {
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E458);
      v8 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
      {
        buf = 68289026;
        v66 = 2082;
        v67 = "";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"CLMicroLocationSimilarityListData fromProtobuf - invalid clusterUuid conversion!\"}", (uint8_t *)&buf, 0x12u);
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212E458);
      }
      v9 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        buf = 68289026;
        v66 = 2082;
        v67 = "";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLMicroLocationSimilarityListData fromProtobuf - invalid clusterUuid conversion!", "{\"msg%{public}.0s\":\"CLMicroLocationSimilarityListData fromProtobuf - invalid clusterUuid conversion!\"}", (uint8_t *)&buf, 0x12u);
      }
      v10 = v57;
      if (v57 >= v58)
      {
        v16 = (v57 - (_BYTE *)v56) >> 4;
        v17 = v16 + 1;
        if ((unint64_t)(v16 + 1) >> 60)
          sub_100259694();
        v18 = v58 - (_BYTE *)v56;
        if ((v58 - (_BYTE *)v56) >> 3 > v17)
          v17 = v18 >> 3;
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF0)
          v14 = 0xFFFFFFFFFFFFFFFLL;
        else
          v14 = v17;
        if (v14)
          v15 = (char *)sub_10028E224((uint64_t)&v58, v14);
        else
          v15 = 0;
        v19 = &v15[16 * v16];
        *(_QWORD *)v19 = 0;
        *((_QWORD *)v19 + 1) = 0;
        v23 = (char *)v56;
        v20 = v57;
        v22 = v19;
        if (v57 != v56)
        {
          do
          {
            *((_OWORD *)v22 - 1) = *((_OWORD *)v20 - 1);
            v22 -= 16;
            v20 -= 16;
          }
          while (v20 != v23);
LABEL_38:
          v20 = (char *)v56;
        }
LABEL_39:
        v7 = v19 + 16;
        v56 = v22;
        v57 = v19 + 16;
        v58 = &v15[16 * v14];
        if (v20)
          operator delete(v20);
        goto LABEL_41;
      }
      v7 = v57 + 16;
      *(_QWORD *)v57 = 0;
      *((_QWORD *)v10 + 1) = 0;
    }
LABEL_41:
    v57 = v7;
    if (++v4 == v5)
      goto LABEL_42;
  }
}

void sub_1002EF748(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26)
{
  uint64_t v26;
  uint64_t v27;
  void *v29;

  sub_1002EF894(v26);
  v29 = *(void **)(v27 - 184);
  if (v29)
  {
    *(_QWORD *)(v27 - 176) = v29;
    operator delete(v29);
  }
  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t sub_1002EF810(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  if (*(_BYTE *)(a1 + 120))
  {
    sub_100006898(a1, (__n128 *)a2);
    sub_100006898(a1 + 24, (__n128 *)(a2 + 24));
    sub_1002F32BC((uint64_t *)(a1 + 48), a2 + 48);
    sub_100006898(a1 + 80, (__n128 *)(a2 + 80));
    v4 = *(_QWORD *)(a2 + 104);
    *(_BYTE *)(a1 + 112) = *(_BYTE *)(a2 + 112);
    *(_QWORD *)(a1 + 104) = v4;
  }
  else
  {
    sub_1002F3398(a1, a2);
    *(_BYTE *)(a1 + 120) = 1;
  }
  return a1;
}

uint64_t sub_1002EF894(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  void *v4;
  void *v5;

  v2 = *(void **)(a1 + 80);
  if (v2)
  {
    *(_QWORD *)(a1 + 88) = v2;
    operator delete(v2);
  }
  if (*(_BYTE *)(a1 + 72))
  {
    v3 = *(_QWORD *)(a1 + 48);
    *(_QWORD *)(a1 + 48) = 0;
    if (v3)
      operator delete[]();
  }
  v4 = *(void **)(a1 + 24);
  if (v4)
  {
    *(_QWORD *)(a1 + 32) = v4;
    operator delete(v4);
  }
  v5 = *(void **)a1;
  if (*(_QWORD *)a1)
  {
    *(_QWORD *)(a1 + 8) = v5;
    operator delete(v5);
  }
  return a1;
}

_QWORD *sub_1002EF90C@<X0>(_QWORD *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;

  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_DWORD *)(a2 + 32) = 1065353216;
  v3 = result[29];
  v4 = result[30];
  while (v3 != v4)
  {
    result = sub_100270E98(a2, (_QWORD *)(v3 + 16), (_OWORD *)(v3 + 16));
    v3 += 32;
  }
  return result;
}

void sub_1002EF964(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_100067AC4(v1);
  _Unwind_Resume(a1);
}

void sub_1002EF978(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  __int128 v3;

  sub_1002EBBE0((uint64_t)&v3, -858993459 * ((a3[1] - *a3) >> 2), (a2[1] - *a2) >> 4);
}

void sub_1002EFCA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, _QWORD *a14)
{
  sub_100008848((uint64_t)&a13, a14);
  _Unwind_Resume(a1);
}

uint64_t sub_1002EFD24(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  if (*(_BYTE *)(a1 + 120))
  {
    if (a1 == a2)
    {
      sub_1002F3640(a1 + 48, a1 + 48);
    }
    else
    {
      sub_1002F3538((char *)a1, *(char **)a2, *(_QWORD *)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 4);
      sub_1002F3538((char *)(a1 + 24), *(char **)(a2 + 24), *(_QWORD *)(a2 + 32), (uint64_t)(*(_QWORD *)(a2 + 32) - *(_QWORD *)(a2 + 24)) >> 4);
      sub_1002F3640(a1 + 48, a2 + 48);
      sub_1002A3054((char *)(a1 + 80), *(char **)(a2 + 80), *(_QWORD *)(a2 + 88), (uint64_t)(*(_QWORD *)(a2 + 88) - *(_QWORD *)(a2 + 80)) >> 2);
    }
    v4 = *(_QWORD *)(a2 + 104);
    *(_BYTE *)(a1 + 112) = *(_BYTE *)(a2 + 112);
    *(_QWORD *)(a1 + 104) = v4;
  }
  else
  {
    sub_1002F36BC(a1, a2);
    *(_BYTE *)(a1 + 120) = 1;
  }
  return a1;
}

_QWORD *sub_1002EFDD8@<X0>(_QWORD *result@<X0>, uint64_t a2@<X8>)
{
  unsigned int v3;
  uint64_t *v4;
  _BYTE v5[16];
  uint64_t *v6;
  void **i;

  v3 = *((_DWORD *)result + 1);
  if (v3 < 2)
  {
    sub_1002EF90C(result, (uint64_t)v5);
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    v4 = v6;
    for (i = (void **)a2; v4; v4 = (uint64_t *)*v4)
      sub_10028E12C(&i, (_OWORD *)v4 + 1);
    return (_QWORD *)sub_100067AC4((uint64_t)v5);
  }
  else
  {
    if (v3 == 2)
    {
      if (*((_BYTE *)result + 192))
      {
        *(_QWORD *)a2 = 0;
        *(_QWORD *)(a2 + 8) = 0;
        *(_QWORD *)(a2 + 16) = 0;
        return sub_1002AE804((_QWORD *)a2, (const void *)result[12], result[13], (uint64_t)(result[13] - result[12]) >> 4);
      }
    }
    else if (v3 != 3)
    {
      sub_1018F29E4();
    }
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
  }
  return result;
}

void sub_1002EFE94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;
  void *v11;

  v11 = *(void **)v9;
  if (*(_QWORD *)v9)
  {
    *(_QWORD *)(v9 + 8) = v11;
    operator delete(v11);
  }
  sub_100067AC4((uint64_t)&a9);
  _Unwind_Resume(a1);
}

BOOL sub_1002EFEB8(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  _BOOL8 v3;
  _QWORD *v5;
  _QWORD *v6;
  _BYTE v8[16];
  _QWORD *v9;
  uint64_t v10;

  v1 = *(_QWORD *)(a1 + 232);
  v2 = *(_QWORD *)(a1 + 240);
  v3 = v1 == v2 && *(_DWORD *)(a1 + 4) == 3;
  if (v1 != v2)
  {
    if (*(_QWORD *)(a1 + 280))
    {
      sub_1002EF90C((_QWORD *)a1, (uint64_t)v8);
      if (v10 == *(_QWORD *)(a1 + 280))
      {
        v5 = v9;
        if (v9)
        {
          v6 = (_QWORD *)(a1 + 256);
          LOBYTE(v3) = 1;
          do
          {
            v3 = v3 && sub_1002A1BA8(v6, v5 + 2) != 0;
            v5 = (_QWORD *)*v5;
          }
          while (v5);
        }
        else
        {
          v3 = 1;
        }
      }
      else
      {
        v3 = 0;
      }
      sub_100067AC4((uint64_t)v8);
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

void sub_1002EFF80(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_100067AC4((uint64_t)va);
  _Unwind_Resume(a1);
}

_QWORD *sub_1002EFF94(_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *i;
  char v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;

  v3 = result;
  for (i = (_QWORD *)a2[2]; i; i = (_QWORD *)*i)
  {
    if (i[2] != i[4] || i[3] != i[5])
    {
      result = sub_1002710E8(v3 + 32, i + 2);
      if (result)
      {
        sub_1002F3818((uint64_t)(v3 + 32), i + 4, (_OWORD *)i + 2, (__int128 *)result + 2);
        if ((v6 & 1) == 0)
          sub_1018F2BC8();
        result = sub_1002F3AF8(v3 + 32, i + 2);
      }
    }
  }
  v7 = (_QWORD *)v3[29];
  v8 = (_QWORD *)v3[30];
  if (v7 != v8)
  {
    v9 = v7 + 2;
    do
    {
      result = sub_1002A1BA8(a2, v9);
      if (result)
        *(_OWORD *)v9 = *((_OWORD *)result + 2);
      v10 = v9 + 2;
      v9 += 4;
    }
    while (v10 != v8);
  }
  return result;
}

uint64_t sub_1002F006C@<X0>(unint64_t a1@<X0>, void **a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  uint64_t *v19;
  int v21;

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v21 = 0;
  sub_1000B0C3C(&v21);
  if (a1)
  {
    do
    {
      v4 = sub_1000B0D38((ssize_t)&v21);
      v6 = v4;
      v7 = v5;
      v9 = (uint64_t *)a2[1];
      v8 = (unint64_t)a2[2];
      if ((unint64_t)v9 >= v8)
      {
        v11 = ((char *)v9 - (_BYTE *)*a2) >> 4;
        v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 60)
          sub_100259694();
        v13 = v8 - (_QWORD)*a2;
        if (v13 >> 3 > v12)
          v12 = v13 >> 3;
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF0)
          v14 = 0xFFFFFFFFFFFFFFFLL;
        else
          v14 = v12;
        if (v14)
          v15 = (char *)sub_10028E224((uint64_t)(a2 + 2), v14);
        else
          v15 = 0;
        v16 = (uint64_t *)&v15[16 * v11];
        *v16 = v6;
        v16[1] = v7;
        v18 = (char *)*a2;
        v17 = (char *)a2[1];
        v19 = v16;
        if (v17 != *a2)
        {
          do
          {
            *((_OWORD *)v19 - 1) = *((_OWORD *)v17 - 1);
            v19 -= 2;
            v17 -= 16;
          }
          while (v17 != v18);
          v17 = (char *)*a2;
        }
        v10 = v16 + 2;
        *a2 = v19;
        a2[1] = v16 + 2;
        a2[2] = &v15[16 * v14];
        if (v17)
          operator delete(v17);
      }
      else
      {
        *v9 = v4;
        v9[1] = v5;
        v10 = v9 + 2;
      }
      a2[1] = v10;
    }
    while (a1 > ((char *)v10 - (_BYTE *)*a2) >> 4);
  }
  return sub_1000B0D18((unsigned int *)&v21);
}

void sub_1002F01B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, unsigned int a11)
{
  uint64_t v11;
  void *v13;

  sub_1000B0D18(&a11);
  v13 = *(void **)v11;
  if (*(_QWORD *)v11)
  {
    *(_QWORD *)(v11 + 8) = v13;
    operator delete(v13);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1002F01E0(uint64_t a1, _QWORD *a2, void *a3)
{
  _QWORD *i;
  uint64_t *v6;
  __int128 *v7;
  _QWORD *v8;
  _QWORD *v9;
  CFStringRef v10;
  int v11;
  int v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  int v16;
  CFStringRef v17;
  int v18;
  void *v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  double v23;
  uint64_t *v24;
  double v25;
  double v26;
  _QWORD *v27;
  _QWORD *v28;
  _QWORD *v29;
  _QWORD *v30;
  _QWORD *v31;
  unint64_t v32;
  double v33;
  _QWORD *v34;
  _QWORD *v35;
  BOOL v36;
  double v38;
  double v39;
  __int128 v40;
  uint64_t *v41;
  uint64_t *v44;
  uint64_t *v45;
  uint64_t *v46;
  _QWORD *v47;
  uint64_t *v48;
  uint64_t v49;
  _QWORD *v50;
  uint64_t v51;
  uint64_t **v52;
  uint64_t **v53;
  uint64_t **v54;
  __int128 *v55;
  uint64_t v56;
  uint64_t **v58;
  uint64_t *v60;
  _QWORD *v61;
  uint64_t v62;
  _QWORD v63[2];
  uint64_t *v64;
  _QWORD *v65;
  uint64_t v66;
  _BYTE v67[16];
  _QWORD *v68;
  uint64_t v69;
  _QWORD v70[2];
  uint64_t *v71;
  unint64_t v72;
  _QWORD v73[2];
  void *__p[2];
  __int128 v75;
  __int128 v76;
  __int128 v77;
  int v78;
  __int128 v79;
  char v80;
  __int128 v81;
  __int128 v82;

  sub_1002EF90C((_QWORD *)a1, (uint64_t)v70);
  sub_1002EF90C(a2, (uint64_t)v67);
  if (v72 == *(_QWORD *)(a1 + 280) && v69 == a2[35])
  {
    for (i = v68; v68; i = v68)
    {
      while (!sub_1002710E8(v70, i + 2))
      {
        i = (_QWORD *)*i;
        if (!i)
          goto LABEL_16;
      }
      sub_1002F006C(v72, __p);
      v76 = 0u;
      v77 = 0u;
      v78 = 1065353216;
      v6 = v71;
      if (v71)
      {
        v7 = (__int128 *)__p[0];
        do
        {
          v81 = *((_OWORD *)v6 + 1);
          v82 = *v7;
          sub_1002F3B74((uint64_t)&v76, &v81, &v81);
          v6 = (uint64_t *)*v6;
          ++v7;
        }
        while (v6);
      }
      sub_1002EFF94((_QWORD *)a1, &v76);
      sub_10001BB9C(v70);
      v9 = __p[0];
      v8 = __p[1];
      while (v9 != v8)
      {
        sub_100270E98((uint64_t)v70, v9, v9);
        v9 += 2;
      }
      sub_100067AC4((uint64_t)&v76);
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
    }
LABEL_16:
    v65 = 0;
    v66 = 0;
    v64 = (uint64_t *)&v65;
    sub_1001E4804(&v76);
    LODWORD(v81) = 0;
    v10 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsFingerprintDistanceFunctionType", 0x8000100u, kCFAllocatorNull);
    v11 = sub_1000B1180(v76, (uint64_t)v10, &v81);
    CFRelease(v10);
    v12 = v81;
    v13 = (std::__shared_weak_count *)*((_QWORD *)&v76 + 1);
    if (*((_QWORD *)&v76 + 1))
    {
      v14 = (unint64_t *)(*((_QWORD *)&v76 + 1) + 8);
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
    if (v11)
      v16 = v12;
    else
      v16 = 4;
    sub_100320440(v16, v63);
    sub_1002708EC((uint64_t)&v76, a1 + 16);
    v79 = *(_OWORD *)(a1 + 56);
    v80 = 1;
    sub_1002984A8(v16);
    if (v80)
      sub_100067AC4((uint64_t)&v76);
    sub_1001E4804(&v76);
    __p[0] = 0;
    v17 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsClusterPersistenceDistanceThreshold", 0x8000100u, kCFAllocatorNull);
    v18 = sub_1001FD9FC(v76, (uint64_t)v17, __p);
    CFRelease(v17);
    v19 = __p[0];
    v20 = (std::__shared_weak_count *)*((_QWORD *)&v76 + 1);
    if (*((_QWORD *)&v76 + 1))
    {
      v21 = (unint64_t *)(*((_QWORD *)&v76 + 1) + 8);
      do
        v22 = __ldaxr(v21);
      while (__stlxr(v22 - 1, v21));
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
    }
    if (v18)
      v23 = *(double *)&v19;
    else
      v23 = 0.35;
    v24 = v71;
    if (v71)
    {
      v25 = 0.0;
      v26 = 1.79769313e308;
      while (1)
      {
        v27 = v68;
        v58 = (uint64_t **)v24;
        if (v68)
          break;
        v39 = v25;
LABEL_67:
        v24 = *v58;
        v25 = v39;
        if (!*v58)
          goto LABEL_68;
      }
      v28 = v24 + 2;
      while (1)
      {
        v29 = v27 + 2;
        v31 = *(_QWORD **)(a1 + 232);
        v30 = *(_QWORD **)(a1 + 240);
        if (v31 == v30)
        {
          v32 = 0;
          v33 = 0.0;
        }
        else
        {
          v32 = 0;
          v33 = 0.0;
          do
          {
            v34 = (_QWORD *)a2[29];
            v35 = (_QWORD *)a2[30];
            while (v34 != v35)
            {
              v36 = v31[2] == *v28 && v31[3] == v28[1];
              if (v36 && v34[2] == *v29 && v34[3] == v27[3])
              {
                if (!*((_QWORD *)&v82 + 1))
                  sub_10025FD1C();
                ++v32;
                v33 = v33
                    + (*(double (**)(_QWORD, _QWORD, _QWORD))(**((_QWORD **)&v82 + 1) + 48))(*((_QWORD *)&v82 + 1), *v31, *v34);
              }
              v34 += 4;
            }
            v31 += 4;
          }
          while (v31 != v30);
        }
        v38 = v33 / (double)v32;
        __p[0] = *(void **)&v38;
        if (v38 >= v23)
        {
          if (v38 >= v26)
          {
LABEL_63:
            v39 = v25;
            goto LABEL_64;
          }
          objc_msgSend(a3, "setObject:forKeyedSubscript:", +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v38), CFSTR("minDistanceAbovePersistenceThreshold"));
          v26 = v38;
          v39 = v25;
        }
        else
        {
          v76 = *(_OWORD *)v28;
          v77 = *(_OWORD *)v29;
          sub_1002F3DC4(&v64, (double *)__p, &v76);
          v39 = *(double *)__p;
          if (*(double *)__p <= v25)
            goto LABEL_63;
          objc_msgSend(a3, "setObject:forKeyedSubscript:", +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", *(double *)__p), CFSTR("maxDistanceBelowPersistenceThreshold"));
        }
LABEL_64:
        v27 = (_QWORD *)*v27;
        v25 = v39;
        if (!v27)
          goto LABEL_67;
      }
    }
LABEL_68:
    v76 = 0u;
    v77 = 0u;
    v78 = 1065353216;
    while (v66)
    {
      v40 = *(_OWORD *)(v64 + 7);
      *(_OWORD *)__p = *(_OWORD *)(v64 + 5);
      v75 = v40;
      sub_1002F3B74((uint64_t)&v76, __p, __p);
      v61 = 0;
      v62 = 0;
      v60 = (uint64_t *)&v61;
      v41 = v64;
      v73[0] = &v60;
      v73[1] = &v61;
      if (v64 == (uint64_t *)&v65)
      {
        v49 = 0;
        v47 = 0;
        v48 = (uint64_t *)&v61;
        v46 = (uint64_t *)&v65;
      }
      else
      {
        do
        {
          if (((void *)v41[5] != __p[0] || (void *)v41[6] != __p[1])
            && (v41[7] != (_QWORD)v75 || v41[8] != *((_QWORD *)&v75 + 1)))
          {
            sub_1002F3E60((uint64_t)v73, (uint64_t)(v41 + 4));
          }
          v44 = (uint64_t *)v41[1];
          if (v44)
          {
            do
            {
              v45 = v44;
              v44 = (uint64_t *)*v44;
            }
            while (v44);
          }
          else
          {
            do
            {
              v45 = (uint64_t *)v41[2];
              v36 = *v45 == (_QWORD)v41;
              v41 = v45;
            }
            while (!v36);
          }
          v41 = v45;
        }
        while (v45 != (uint64_t *)&v65);
        v46 = v64;
        v48 = v60;
        v47 = v61;
        v49 = v62;
      }
      v50 = v65;
      v51 = v66;
      v64 = v48;
      v65 = v47;
      v60 = v46;
      v61 = v50;
      v66 = v49;
      v62 = v51;
      v52 = (uint64_t **)(v47 + 2);
      if (v49)
        v53 = v52;
      else
        v53 = &v64;
      *v53 = (uint64_t *)&v65;
      v54 = (uint64_t **)(v50 + 2);
      if (!v51)
        v54 = &v60;
      *v54 = (uint64_t *)&v61;
      sub_100008848((uint64_t)&v60, v50);
    }
    sub_1002EFF94((_QWORD *)a1, &v76);
    sub_100067AC4((uint64_t)&v76);
    v55 = (__int128 *)*((_QWORD *)&v82 + 1);
    if (*((__int128 **)&v82 + 1) == &v81)
    {
      v56 = 4;
      v55 = &v81;
    }
    else
    {
      if (!*((_QWORD *)&v82 + 1))
      {
LABEL_98:
        sub_10011A56C(v63);
        sub_100008848((uint64_t)&v64, v65);
        goto LABEL_99;
      }
      v56 = 5;
    }
    (*(void (**)(void))(*(_QWORD *)v55 + 8 * v56))();
    goto LABEL_98;
  }
LABEL_99:
  sub_100067AC4((uint64_t)v67);
  return sub_100067AC4((uint64_t)v70);
}

void sub_1002F083C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, _QWORD *a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44)
{
  uint64_t v44;
  _QWORD *v46;
  uint64_t v47;

  sub_100067AC4((uint64_t)&a37);
  v46 = *(_QWORD **)(v44 - 136);
  if (v46 == (_QWORD *)(v44 - 160))
  {
    v47 = 4;
    v46 = (_QWORD *)(v44 - 160);
  }
  else
  {
    if (!v46)
      goto LABEL_6;
    v47 = 5;
  }
  (*(void (**)(void))(*v46 + 8 * v47))();
LABEL_6:
  sub_10011A56C(&a16);
  sub_100008848((uint64_t)&a18, a19);
  sub_100067AC4((uint64_t)&a21);
  sub_100067AC4((uint64_t)&a26);
  _Unwind_Resume(a1);
}

void sub_1002F0968(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  uint64_t *v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t *v10;
  NSObject *v11;
  _OWORD *v12;
  void *p_p;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  __int128 *v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void *__p;
  __int128 v26;
  uint8_t buf[4];
  int v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  unint64_t v32;
  __int16 v33;
  uint64_t v34;
  __int16 v35;
  unint64_t v36;

  v4 = a1 + 29;
  v5 = *(_QWORD **)(a2 + 16);
  v23 = a1[29];
  v22 = a1[30];
  if (v5)
  {
    v6 = a1 + 32;
    v7 = a1[30];
    do
    {
      v8 = v7;
      v9 = v5 + 2;
      v10 = sub_1002710E8(v6, v5 + 2);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E458);
      v11 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        v12 = operator new(0x28uLL);
        __p = v12;
        v26 = xmmword_101B97FF0;
        *v12 = 0u;
        v12[1] = 0u;
        *(_QWORD *)((char *)v12 + 29) = 0;
        sub_100261F9C((uint64_t)(v5 + 2), v12);
        p_p = &__p;
        if (v26 < 0)
          p_p = __p;
        v14 = (v10[5] - v10[4]) >> 4;
        *(_DWORD *)buf = 68289794;
        v28 = 0;
        v29 = 2082;
        v30 = "";
        v31 = 2082;
        v32 = (unint64_t)p_p;
        v33 = 2050;
        v34 = v14;
        v35 = 2050;
        v36 = a3;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"pruneSmallClusters\", \"cluster ID\":%{public, location:escape_only}s, \"cluster size\":%{public}lu, \"threshold\":%{public}lu}", buf, 0x30u);
        if (SHIBYTE(v26) < 0)
          operator delete(__p);
      }
      if (a3 <= (v10[5] - v10[4]) >> 4 || (sub_1002F3B2C(v6, v10), v7 = *v4, *v4 == v8))
      {
LABEL_18:
        v7 = v8;
      }
      else
      {
        v15 = v7 + 48;
        while (1)
        {
          v16 = *(_QWORD *)(v7 + 16) == *v9 && *(_QWORD *)(v7 + 24) == v5[3];
          v17 = v7 + 32;
          if (v16)
            break;
          v15 += 32;
          v7 += 32;
          if (v17 == v8)
            goto LABEL_18;
        }
        while (v17 != v8)
        {
          if (*(_QWORD *)v15 != *v9 || *(_QWORD *)(v15 + 8) != v5[3])
          {
            sub_1002B7674(v7, (__int128 *)(v15 - 16));
            *(_OWORD *)(v7 + 16) = *(_OWORD *)v15;
            v7 += 32;
          }
          v17 = v15 + 16;
          v15 += 32;
        }
      }
      v5 = (_QWORD *)*v5;
    }
    while (v5);
    v19 = (__int128 *)a1[30];
  }
  else
  {
    v7 = a1[30];
    v19 = (__int128 *)v7;
  }
  sub_1002F0CC8((uint64_t)v4, v7, v19);
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E458);
  v20 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    v21 = (a1[30] - a1[29]) >> 5;
    *(_DWORD *)buf = 68289794;
    v28 = 0;
    v29 = 2082;
    v30 = "";
    v31 = 2050;
    v32 = a3;
    v33 = 2050;
    v34 = (v22 - v23) >> 5;
    v35 = 2050;
    v36 = v21;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"pruneSmallClusters\", \"clusterSizeThreshold\":%{public}lu, \"numFingerprintsPrePruning\":%{public}lu, \"numFingerprintsPostPruning\":%{public}lu}", buf, 0x30u);
  }
}

void sub_1002F0CAC(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1002F0CC8(uint64_t a1, uint64_t a2, __int128 *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if ((__int128 *)a2 != a3)
  {
    sub_1002F403C(a3, *(__int128 **)(a1 + 8), a2);
    v6 = v5;
    v7 = *(_QWORD *)(a1 + 8);
    if (v7 != v5)
    {
      do
        v7 = sub_100261F44(v7 - 32);
      while (v7 != v6);
    }
    *(_QWORD *)(a1 + 8) = v6;
  }
  return a2;
}

uint64_t sub_1002F0D34(uint64_t *a1)
{
  CFStringRef v2;
  int v3;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  unint64_t v8;
  uint64_t v10;
  std::__shared_weak_count *v11;
  unsigned int v12;

  sub_1001E4804(&v10);
  v12 = 0;
  v2 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsClusterSizeThreshold", 0x8000100u, kCFAllocatorNull);
  v3 = sub_1000B1180(v10, (uint64_t)v2, &v12);
  CFRelease(v2);
  v4 = v12;
  v5 = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  if (v3)
    v8 = v4;
  else
    v8 = 5;
  sub_1002EF90C(a1, (uint64_t)&v10);
  sub_1002F0968(a1, (uint64_t)&v10, v8);
  return sub_100067AC4((uint64_t)&v10);
}

void sub_1002F0E20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100067AC4((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_1002F0E48(uint64_t *a1, uint64_t a2, int a3, void *a4)
{
  CFStringRef v8;
  int v9;
  double v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  double v18;
  unint64_t v19;
  _QWORD *v20;
  uint64_t *v21;
  uint64_t v22;
  NSObject *v23;
  const char *v24;
  uint8_t *v25;
  _QWORD v26[6];
  uint8_t buf[8];
  std::__shared_weak_count *v28;
  uint64_t *v29;

  if (sub_1002EFEB8((uint64_t)a1))
  {
    sub_1001E4804(buf);
    v26[0] = 0;
    v8 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsClusterSizeRatio", 0x8000100u, kCFAllocatorNull);
    v9 = sub_1001FD9FC(*(uint64_t *)buf, (uint64_t)v8, v26);
    CFRelease(v8);
    v10 = *(double *)v26;
    v11 = v28;
    if (v28)
    {
      p_shared_owners = (unint64_t *)&v28->__shared_owners_;
      do
        v13 = __ldaxr(p_shared_owners);
      while (__stlxr(v13 - 1, p_shared_owners));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
    if (!v9)
      v10 = 0.2;
    v14 = (_QWORD *)a1[34];
    v15 = (_QWORD *)*v14;
    if (*v14)
    {
      do
      {
        if (v14[5] - v14[4] < v15[5] - v15[4])
          v14 = v15;
        v15 = (_QWORD *)*v15;
      }
      while (v15);
    }
    v17 = v14[4];
    v16 = v14[5];
    sub_1002F0D34(a1);
    if (sub_1002EFEB8((uint64_t)a1))
    {
      sub_1002EF90C(a1, (uint64_t)buf);
      v18 = v10 * (double)(unint64_t)((v16 - v17) >> 4);
      v19 = (unint64_t)v18;
      if (a3)
        sub_1002F0968(a1, (uint64_t)buf, (unint64_t)v18);
      if (*(_BYTE *)(a2 + 8))
      {
        v20 = *(_QWORD **)a2;
        if (sub_1002EFEB8((uint64_t)v20))
        {
          sub_1002F01E0((uint64_t)a1, v20, a4);
          sub_1002EF90C(a1, (uint64_t)v26);
          v21 = v29;
          if (v29)
          {
            do
            {
              v22 = *v21;
              if (!sub_1002710E8(v26, v21 + 2))
                sub_1002123D8(buf, v21);
              v21 = (uint64_t *)v22;
            }
            while (v22);
          }
          sub_100067AC4((uint64_t)v26);
        }
      }
      if ((a3 & 1) == 0)
        sub_1002F0968(a1, (uint64_t)buf, v19);
      sub_100067AC4((uint64_t)buf);
    }
    else
    {
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E458);
      v23 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Model has become invalid after pruning clusters with absolute size threshold", buf, 2u);
      }
      if (sub_1001BFF7C(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212E458);
        LOWORD(v26[0]) = 0;
        _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "Model has become invalid after pruning clusters with absolute size threshold", v26, 2);
        v25 = (uint8_t *)v24;
        sub_100512490("Generic", 1, 0, 2, "void CLMicroLocationModel::mapIdentifiersFromOldModelAndPruneNoiseClusters(const std::optional<std::reference_wrapper<CLMicroLocationModel>> &, const BOOL, NSMutableDictionary *)", "%s\n", v24);
        if (v25 != buf)
          free(v25);
      }
    }
  }
}

void sub_1002F11A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  sub_100067AC4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002F11E8@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, char **a3@<X8>)
{
  char *v6;
  uint64_t *i;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  double v15;
  unint64_t v16;
  _OWORD *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  _DWORD *v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  char *v27;
  char *v28;
  char *v29;
  int v30;
  double v31;
  uint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  _QWORD *v36[2];
  _BYTE v37[16];
  uint64_t *v38;
  unint64_t *v39;
  void *__p[2];
  _DWORD *v41;
  uint64_t v42;

  v6 = (char *)a1[35];
  sub_1002EF90C(a1, (uint64_t)v37);
  v36[0] = 0;
  v36[1] = 0;
  v34 = 0;
  v35 = (uint64_t *)v36;
  for (i = v38; i; i = (uint64_t *)*i)
  {
    *(_OWORD *)__p = *((_OWORD *)i + 1);
    sub_1002F40A4(&v35, (unint64_t *)__p, __p, &v34);
    ++v34;
  }
  a3[1] = 0;
  v8 = (uint64_t *)(a3 + 1);
  a3[2] = 0;
  a3[3] = 0;
  __p[1] = 0;
  v41 = 0;
  v42 = 0;
  *a3 = v6;
  v39 = 0;
  sub_1002F4200((uint64_t)(a3 + 1), (unint64_t)&v6[(_QWORD)v6 * (_QWORD)v6] >> 1, &v39);
  __p[0] = v6;
  LODWORD(v39) = 0;
  sub_1002F4340((uint64_t)&__p[1], (unint64_t)&v6[(_QWORD)v6 * (_QWORD)v6] >> 1, &v39);
  v10 = a1[29];
  v9 = a1[30];
  if (v9 != v10)
  {
    v11 = 0;
    v12 = 0;
    do
    {
      if (v12 >= (v9 - v10) >> 5)
      {
        v21 = (v9 - v10) >> 5;
      }
      else
      {
        v33 = v11;
        v13 = v12;
        do
        {
          v14 = *(_QWORD *)(a2 + 24);
          if (!v14)
            sub_10025FD1C();
          v15 = (*(double (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v14 + 48))(v14, *(_QWORD *)(v10 + 32 * v12), *(_QWORD *)(v10 + v11));
          v39 = (unint64_t *)(v10 + 32 * v12 + 16);
          v16 = *((_QWORD *)sub_1002F4480(&v35, v39, (uint64_t)&unk_101B9EB60, (_OWORD **)&v39) + 6);
          v39 = (unint64_t *)(v10 + v11 + 16);
          v17 = sub_1002F4480(&v35, v39, (uint64_t)&unk_101B9EB60, (_OWORD **)&v39);
          v18 = *((_QWORD *)v17 + 6);
          if (v16 <= v18)
            v19 = *((_QWORD *)v17 + 6);
          else
            v19 = v16;
          if (v16 < v18)
            v18 = v16;
          v20 = v18 + ((v19 + v19 * v19) >> 1);
          *(double *)(*v8 + 8 * v20) = v15 + *(double *)(*v8 + 8 * v20);
          ++*((_DWORD *)__p[1] + v20);
          ++v13;
          v10 = a1[29];
          v9 = a1[30];
          v11 += 32;
        }
        while (v13 < (v9 - v10) >> 5);
        v21 = (v9 - v10) >> 5;
        v11 = v33;
      }
      ++v12;
      v11 += 32;
    }
    while (v12 < v21);
  }
  v22 = __p[1];
  if (v6)
  {
    v23 = 0;
    v24 = *v8;
    do
    {
      v25 = *v8;
      v26 = v23;
      do
      {
        if (v23 <= v26)
          v27 = v26;
        else
          v27 = v23;
        if (v23 >= v26)
          v28 = v26;
        else
          v28 = v23;
        v29 = &v28[(unint64_t)&v27[(_QWORD)v27 * (_QWORD)v27] >> 1];
        v30 = v22[(_QWORD)v29];
        if (v30)
          v31 = *(double *)(v25 + 8 * (_QWORD)v29) / (double)v30;
        else
          v31 = 0.0;
        *(double *)(v24 + 8 * (_QWORD)v29) = v31;
        ++v26;
      }
      while (v6 != v26);
      ++v23;
    }
    while (v23 != v6);
    v22 = __p[1];
  }
  if (v22)
  {
    v41 = v22;
    operator delete(v22);
  }
  sub_100008848((uint64_t)&v35, v36[0]);
  return sub_100067AC4((uint64_t)v37);
}

void sub_1002F14AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25)
{
  _Unwind_Resume(exception_object);
}

double sub_1002F1514(_QWORD *a1)
{
  _QWORD *v2;
  unint64_t v3;
  double v4;
  NSObject *v5;
  _DWORD v7[2];
  __int16 v8;
  const char *v9;
  __int16 v10;
  _BOOL4 v11;

  v2 = (_QWORD *)a1[34];
  if (!v2)
    goto LABEL_6;
  v3 = 0;
  do
  {
    v3 += (uint64_t)(v2[5] - v2[4]) >> 4;
    v2 = (_QWORD *)*v2;
  }
  while (v2);
  if (v3)
    return (double)(unint64_t)((uint64_t)(a1[30] - a1[29]) >> 5) / (double)v3;
LABEL_6:
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E458);
  v5 = qword_1022A00F8;
  v4 = 1.0;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    v7[0] = 68289282;
    v7[1] = 0;
    v8 = 2082;
    v9 = "";
    v10 = 1026;
    v11 = sub_1002EFEB8((uint64_t)a1);
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"representativeFPsRatio, called with empty model\", \"isValid\":%{public}hhd}", (uint8_t *)v7, 0x18u);
  }
  return v4;
}

_OWORD *sub_1002F1650(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  _OWORD *v7;
  _OWORD *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  _QWORD v16[5];

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_OWORD **)(v4 - 8);
  if ((unint64_t)v7 >= v6)
  {
    v9 = ((uint64_t)v7 - *a1) >> 5;
    v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 59)
      sub_100259694();
    v11 = v5 - *a1;
    if (v11 >> 4 > v10)
      v10 = v11 >> 4;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0)
      v12 = 0x7FFFFFFFFFFFFFFLL;
    else
      v12 = v10;
    v16[4] = v4;
    if (v12)
      v13 = (char *)sub_10025BA00(v4, v12);
    else
      v13 = 0;
    v14 = &v13[32 * v9];
    v16[0] = v13;
    v16[1] = v14;
    v16[3] = &v13[32 * v12];
    *(_OWORD *)v14 = *(_OWORD *)a2;
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *((_OWORD *)v14 + 1) = *(_OWORD *)(a2 + 16);
    v16[2] = v14 + 32;
    sub_1002F4508(a1, v16);
    v8 = (_OWORD *)a1[1];
    sub_1002F456C((uint64_t)v16);
  }
  else
  {
    *v7 = *(_OWORD *)a2;
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    v7[1] = *(_OWORD *)(a2 + 16);
    v8 = v7 + 2;
    a1[1] = (uint64_t)(v7 + 2);
  }
  a1[1] = (uint64_t)v8;
  return v8 - 2;
}

void sub_1002F1750(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1002F456C((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1002F1764(uint64_t *a1, uint64_t a2, _QWORD *a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  NSObject *v11;
  NSObject *v12;
  uint64_t v13;
  _BYTE *v14;
  char *v15;
  _BYTE *v16;
  int64_t v17;
  _QWORD v21[2];
  _QWORD v22[2];
  char v23[8];
  _QWORD *v24;
  uint64_t v25[3];
  void *v26[2];
  char v27;
  char v28;
  uint8_t v29[8];
  _WORD v30[8];
  char v31;

  sub_10035A2D8(0, (uint64_t)v26);
  sub_1002631F8((uint64_t)v23, (unsigned __int8 *)v26);
  v22[0] = sub_100345FF8((uint64_t)a3);
  v22[1] = v7;
  v21[0] = sub_100346004(a3);
  v21[1] = v8;
  if (sub_100345F10(v22, v21))
  {
    v9 = sub_100345F3C(v22);
    v10 = sub_1002A1BA8(a4, (_QWORD *)(v9 + 40));
    if (v10)
    {
      sub_1002F4D5C(a5, v10 + 4);
      sub_10032522C((uint64_t)&v28, a2);
    }
    sub_100263950("unordered_map::at: key not found");
  }
  if ((sub_1002EBFD8((uint64_t)(a1 + 6)) & 1) == 0)
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E458);
    v11 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      *(_QWORD *)v29 = 68289026;
      v30[0] = 2082;
      *(_QWORD *)&v30[1] = "";
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Similarity List Model Learning, error normalizing probability matrix\"}", v29, 0x12u);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E458);
    }
    v12 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      *(_QWORD *)v29 = 68289026;
      v30[0] = 2082;
      *(_QWORD *)&v30[1] = "";
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v12, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Similarity List Model Learning, error normalizing probability matrix", "{\"msg%{public}.0s\":\"Similarity List Model Learning, error normalizing probability matrix\"}", v29, 0x12u);
    }
  }
  if (*(_OWORD *)*a1 == 0)
  {
    sub_1002EBE60((uint64_t)(a1 + 6), 1u, v29);
    sub_1002F32BC(a1 + 6, (uint64_t)v29);
    if (v31)
    {
      v13 = *(_QWORD *)v29;
      *(_QWORD *)v29 = 0;
      if (v13)
        operator delete[]();
    }
    v15 = (char *)*a1;
    v14 = (_BYTE *)a1[1];
    v16 = (_BYTE *)(*a1 + 16);
    v17 = v14 - v16;
    if (v14 != v16)
      memmove((void *)*a1, v16, v14 - v16);
    a1[1] = (uint64_t)&v15[v17];
  }
  sub_10011A56C(v25);
  sub_100008848((uint64_t)v23, v24);
  if (v27 < 0)
    operator delete(v26[0]);
}

void sub_1002F1F2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,_QWORD *a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  uint64_t v40;
  uint64_t v42;

  if (*(_BYTE *)(v40 - 168))
  {
    v42 = *(_QWORD *)(v40 - 192);
    *(_QWORD *)(v40 - 192) = 0;
    if (v42)
      operator delete[]();
  }
  sub_10011A56C(&a32);
  sub_100008848((uint64_t)&a29, a30);
  if (a40 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void sub_1002F2034(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  int v7;
  unint64_t v8;
  uint64_t v9;
  NSObject *v10;
  unint64_t v11;
  uint64_t v12;
  NSObject *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _BYTE v17[8];
  _QWORD *v18;
  _QWORD v19[3];
  void *v20[2];
  char v21;
  uint8_t v22[8];
  _WORD v23[5];
  __int16 v24;
  unint64_t v25;
  __int16 v26;
  uint64_t v27;

  v7 = sub_1002F3094();
  sub_10035A2D8(0, (uint64_t)v20);
  sub_1002631F8((uint64_t)v17, (unsigned __int8 *)v20);
  v8 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a3[1] - *a3) >> 6);
  if (v8 == (uint64_t)(a4[1] - *a4) >> 4)
  {
    if (v7 >= (int)v8)
      v7 = -1431655765 * ((uint64_t)(a3[1] - *a3) >> 6);
    v9 = 60;
    if (!*(_BYTE *)(a1 + 57))
      v9 = 64;
    sub_1002EBBE0((uint64_t)&v16, v7, *(_DWORD *)(a1 + v9) + 1);
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E458);
  v10 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
  {
    v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a3[1] - *a3) >> 6);
    v12 = (uint64_t)(a4[1] - *a4) >> 4;
    *(_QWORD *)v22 = 68289538;
    v23[0] = 2082;
    *(_QWORD *)&v23[1] = "";
    v24 = 2050;
    v25 = v11;
    v26 = 2050;
    v27 = v12;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"SimilarityListData, appendNewEvents, fingerprints size not equal labelUuids size!\", \"Num Fingerprints\":%{public}lu, \"Num Labels\":%{public}lu}", v22, 0x26u);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E458);
  }
  v13 = qword_1022A00F8;
  if (os_signpost_enabled((os_log_t)qword_1022A00F8))
  {
    v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a3[1] - *a3) >> 6);
    v15 = (uint64_t)(a4[1] - *a4) >> 4;
    *(_QWORD *)v22 = 68289538;
    v23[0] = 2082;
    *(_QWORD *)&v23[1] = "";
    v24 = 2050;
    v25 = v14;
    v26 = 2050;
    v27 = v15;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v13, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SimilarityListData, appendNewEvents, fingerprints size not equal labelUuids size!", "{\"msg%{public}.0s\":\"SimilarityListData, appendNewEvents, fingerprints size not equal labelUuids size!\", \"Num Fingerprints\":%{public}lu, \"Num Labels\":%{public}lu}", v22, 0x26u);
  }
  sub_10011A56C(v19);
  sub_100008848((uint64_t)v17, v18);
  if (v21 < 0)
    operator delete(v20[0]);
}

void sub_1002F2FA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  uint64_t v38;

  if (__p)
    operator delete(__p);
  if (a37)
  {
    v38 = a34;
    a34 = 0;
    if (v38)
      operator delete[]();
  }
  if (a18)
    operator delete[]();
  sub_100261EE4((uint64_t)&a21);
  if (a32 < 0)
    operator delete(a27);
  _Unwind_Resume(a1);
}

uint64_t sub_1002F3094()
{
  CFStringRef v0;
  int v1;
  unsigned int v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unsigned int v7;
  uint64_t v8;
  std::__shared_weak_count *v9;

  sub_1001E4804(&v8);
  v7 = 0;
  v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsSimilarityListMaxNumberOfItems", 0x8000100u, kCFAllocatorNull);
  v1 = sub_1001C1194(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  v2 = v7;
  v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  if (v1)
    return v2;
  else
    return 1000;
}

void sub_1002F3158(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  sub_100261F44((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1002F3170(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 4 * a2;
  }
  else
  {
    sub_1002F4E94((char **)a1, a2 - v2);
  }
}

void sub_1002F31A0(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 4;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 16 * a2;
  }
  else
  {
    sub_1002F527C((void **)a1, a2 - v2);
  }
}

void sub_1002F31D0()
{
  operator new();
}

void sub_1002F320C()
{
  operator delete();
}

void sub_1002F3230()
{
  operator new();
}

void sub_1002F326C()
{
  operator delete();
}

void sub_1002F3290(id a1)
{
  qword_1022A00F8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

uint64_t *sub_1002F32BC(uint64_t *result, uint64_t a2)
{
  uint64_t *v2;

  v2 = result;
  if (*((unsigned __int8 *)result + 24) == *(unsigned __int8 *)(a2 + 24))
  {
    if (*((_BYTE *)result + 24))
      return sub_1002EBDB4(result, (uint64_t *)a2);
  }
  else if (*((_BYTE *)result + 24))
  {
    result = (uint64_t *)*result;
    *v2 = 0;
    if (result)
      operator delete[]();
    *((_BYTE *)v2 + 24) = 0;
  }
  else
  {
    result = (uint64_t *)sub_1002EBD14(result);
    *((_BYTE *)v2 + 24) = 1;
  }
  return result;
}

void sub_1002F3338()
{
  operator new();
}

void sub_1002F3374()
{
  operator delete();
}

uint64_t sub_1002F3398(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  sub_1002F3468((_BYTE *)(a1 + 48), a2 + 48);
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 80);
  *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
  *(_QWORD *)(a2 + 80) = 0;
  *(_QWORD *)(a2 + 88) = 0;
  *(_QWORD *)(a2 + 96) = 0;
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 104);
  return a1;
}

void sub_1002F343C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;
  void *v5;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 32) = v4;
    operator delete(v4);
  }
  v5 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

_BYTE *sub_1002F3468(_BYTE *a1, uint64_t a2)
{
  *a1 = 0;
  a1[24] = 0;
  if (*(_BYTE *)(a2 + 24))
  {
    sub_1002EBD14(a1);
    a1[24] = 1;
  }
  return a1;
}

void sub_1002F34A8(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(_BYTE *)(v1 + 24))
    sub_1018F2E98((uint64_t *)v1);
  _Unwind_Resume(exception_object);
}

char *sub_1002F34C4(char *result, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  char *v6;
  _OWORD *v7;

  if (a4)
  {
    v6 = result;
    result = sub_1002AE87C(result, a4);
    v7 = (_OWORD *)*((_QWORD *)v6 + 1);
    while (a2 != a3)
    {
      *v7++ = *((_OWORD *)a2 + 1);
      a2 = (uint64_t *)*a2;
    }
    *((_QWORD *)v6 + 1) = v7;
  }
  return result;
}

void sub_1002F351C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *sub_1002F3538(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 4)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 60)
      sub_100259694();
    v10 = v8 >> 3;
    if (v8 >> 3 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0)
      v11 = 0xFFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = sub_1002AE87C(v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 4;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[16 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

uint64_t sub_1002F3640(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  v2 = result;
  if (*(unsigned __int8 *)(result + 24) == *(unsigned __int8 *)(a2 + 24))
  {
    if (*(_BYTE *)(result + 24))
      return sub_1002EBD18(result, a2);
  }
  else if (*(_BYTE *)(result + 24))
  {
    result = *(_QWORD *)result;
    *(_QWORD *)v2 = 0;
    if (result)
      operator delete[]();
    *(_BYTE *)(v2 + 24) = 0;
  }
  else
  {
    result = sub_1002EBCA8(result);
    *(_BYTE *)(v2 + 24) = 1;
  }
  return result;
}

uint64_t sub_1002F36BC(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  sub_1002AE804((_QWORD *)a1, *(const void **)a2, *(_QWORD *)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 4);
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  sub_1002AE804((_QWORD *)(a1 + 24), *(const void **)(a2 + 24), *(_QWORD *)(a2 + 32), (uint64_t)(*(_QWORD *)(a2 + 32) - *(_QWORD *)(a2 + 24)) >> 4);
  sub_1002F37BC((_BYTE *)(a1 + 48), a2 + 48);
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  sub_10027205C((_QWORD *)(a1 + 80), *(const void **)(a2 + 80), *(_QWORD *)(a2 + 88), (uint64_t)(*(_QWORD *)(a2 + 88) - *(_QWORD *)(a2 + 80)) >> 2);
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 104);
  return a1;
}

void sub_1002F3758(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  uint64_t *v3;
  uint64_t v5;
  void *v6;
  void *v7;

  if (*(_BYTE *)(v1 + 72))
  {
    v5 = *v3;
    *v3 = 0;
    if (v5)
      operator delete[]();
  }
  v6 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 32) = v6;
    operator delete(v6);
  }
  v7 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v7;
    operator delete(v7);
  }
  _Unwind_Resume(exception_object);
}

_BYTE *sub_1002F37BC(_BYTE *a1, uint64_t a2)
{
  *a1 = 0;
  a1[24] = 0;
  if (*(_BYTE *)(a2 + 24))
  {
    sub_1002EBCA8(a1);
    a1[24] = 1;
  }
  return a1;
}

void sub_1002F37FC(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(_BYTE *)(v1 + 24))
    sub_1018F2E98((uint64_t *)v1);
  _Unwind_Resume(exception_object);
}

_QWORD *sub_1002F3818(uint64_t a1, _QWORD *a2, _OWORD *a3, __int128 *a4)
{
  unint64_t v4;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  void **v12;
  _QWORD *v13;
  unint64_t v14;
  _QWORD *v16;
  __int128 v17;
  float v18;
  float v19;
  _BOOL8 v20;
  unint64_t v21;
  unint64_t v22;
  size_t v23;
  uint64_t v24;
  _QWORD *v25;
  unint64_t v26;

  v8 = 0;
  v9 = 0;
  do
    v9 ^= (v9 << 6) + (v9 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + v8++);
  while (v8 != 16);
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      v4 = v9;
      if (v9 >= v10)
        v4 = v9 % v10;
    }
    else
    {
      v4 = (v10 - 1) & v9;
    }
    v12 = *(void ***)(*(_QWORD *)a1 + 8 * v4);
    if (v12)
    {
      v13 = *v12;
      if (*v12)
      {
        do
        {
          v14 = v13[1];
          if (v14 == v9)
          {
            if (v13[2] == *a2 && v13[3] == a2[1])
              return v13;
          }
          else
          {
            if (v11.u32[0] > 1uLL)
            {
              if (v14 >= v10)
                v14 %= v10;
            }
            else
            {
              v14 &= v10 - 1;
            }
            if (v14 != v4)
              break;
          }
          v13 = (_QWORD *)*v13;
        }
        while (v13);
      }
    }
  }
  v16 = (_QWORD *)(a1 + 16);
  v13 = operator new(0x38uLL);
  *v13 = 0;
  v13[1] = v9;
  v17 = *a4;
  *((_OWORD *)v13 + 1) = *a3;
  *((_OWORD *)v13 + 2) = v17;
  v13[6] = *((_QWORD *)a4 + 2);
  *(_QWORD *)a4 = 0;
  *((_QWORD *)a4 + 1) = 0;
  *((_QWORD *)a4 + 2) = 0;
  v18 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v19 = *(float *)(a1 + 32);
  if (!v10 || (float)(v19 * (float)v10) < v18)
  {
    v20 = 1;
    if (v10 >= 3)
      v20 = (v10 & (v10 - 1)) != 0;
    v21 = v20 | (2 * v10);
    v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22)
      v23 = v22;
    else
      v23 = v21;
    sub_10012E444(a1, v23);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v4 = v9 % v10;
      else
        v4 = v9;
    }
    else
    {
      v4 = (v10 - 1) & v9;
    }
  }
  v24 = *(_QWORD *)a1;
  v25 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v25)
  {
    *v13 = *v25;
LABEL_44:
    *v25 = v13;
    goto LABEL_45;
  }
  *v13 = *v16;
  *v16 = v13;
  *(_QWORD *)(v24 + 8 * v4) = v16;
  if (*v13)
  {
    v26 = *(_QWORD *)(*v13 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v26 >= v10)
        v26 %= v10;
    }
    else
    {
      v26 &= v10 - 1;
    }
    v25 = (_QWORD *)(*(_QWORD *)a1 + 8 * v26);
    goto LABEL_44;
  }
LABEL_45:
  ++*(_QWORD *)(a1 + 24);
  return v13;
}

void sub_1002F3A90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  _QWORD *v10;
  uint64_t v11;

  sub_1002F3AAC(v11, v10);
  _Unwind_Resume(a1);
}

void sub_1002F3AAC(uint64_t a1, _QWORD *__p)
{
  void *v3;

  if (*(_BYTE *)(a1 + 8))
  {
    v3 = (void *)__p[4];
    if (v3)
    {
      __p[5] = v3;
      operator delete(v3);
    }
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

uint64_t *sub_1002F3AF8(_QWORD *a1, _QWORD *a2)
{
  uint64_t *result;

  result = sub_1002710E8(a1, a2);
  if (result)
  {
    sub_1002F3B2C(a1, result);
    return (uint64_t *)1;
  }
  return result;
}

uint64_t sub_1002F3B2C(_QWORD *a1, uint64_t *a2)
{
  uint64_t v2;
  _QWORD *v3;
  void *__p;
  uint64_t v6;

  v2 = *a2;
  sub_1000592D8(a1, a2, (uint64_t)&__p);
  v3 = __p;
  __p = 0;
  if (v3)
    sub_1002F3AAC((uint64_t)&v6, v3);
  return v2;
}

_QWORD *sub_1002F3B74(uint64_t a1, _QWORD *a2, _OWORD *a3)
{
  unint64_t v3;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  void **v10;
  _QWORD *v11;
  unint64_t v12;
  __int128 v14;
  float v15;
  float v16;
  _BOOL8 v17;
  unint64_t v18;
  unint64_t v19;
  size_t v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;

  v6 = 0;
  v7 = 0;
  do
    v7 ^= (v7 << 6) + (v7 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + v6++);
  while (v6 != 16);
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v3 = v7;
      if (v7 >= v8)
        v3 = v7 % v8;
    }
    else
    {
      v3 = (v8 - 1) & v7;
    }
    v10 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v10)
    {
      v11 = *v10;
      if (*v10)
      {
        do
        {
          v12 = v11[1];
          if (v12 == v7)
          {
            if (v11[2] == *a2 && v11[3] == a2[1])
              return v11;
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8)
                v12 %= v8;
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v3)
              break;
          }
          v11 = (_QWORD *)*v11;
        }
        while (v11);
      }
    }
  }
  v11 = operator new(0x30uLL);
  *v11 = 0;
  v11[1] = v7;
  v14 = a3[1];
  *((_OWORD *)v11 + 1) = *a3;
  *((_OWORD *)v11 + 2) = v14;
  v15 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v16 = *(float *)(a1 + 32);
  if (!v8 || (float)(v16 * (float)v8) < v15)
  {
    v17 = 1;
    if (v8 >= 3)
      v17 = (v8 & (v8 - 1)) != 0;
    v18 = v17 | (2 * v8);
    v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19)
      v20 = v19;
    else
      v20 = v18;
    sub_10012E444(a1, v20);
    v8 = *(_QWORD *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v3 = v7 % v8;
      else
        v3 = v7;
    }
    else
    {
      v3 = (v8 - 1) & v7;
    }
  }
  v21 = *(_QWORD *)a1;
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v22)
  {
    *v11 = *v22;
LABEL_44:
    *v22 = v11;
    goto LABEL_45;
  }
  *v11 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v11;
  *(_QWORD *)(v21 + 8 * v3) = a1 + 16;
  if (*v11)
  {
    v23 = *(_QWORD *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v23 >= v8)
        v23 %= v8;
    }
    else
    {
      v23 &= v8 - 1;
    }
    v22 = (_QWORD *)(*(_QWORD *)a1 + 8 * v23);
    goto LABEL_44;
  }
LABEL_45:
  ++*(_QWORD *)(a1 + 24);
  return v11;
}

void sub_1002F3DB0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

char *sub_1002F3DC4(uint64_t **a1, double *a2, _OWORD *a3)
{
  char *v6;
  double v7;
  __int128 v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t **v11;

  v6 = (char *)operator new(0x48uLL);
  v7 = *a2;
  *((double *)v6 + 4) = *a2;
  v8 = a3[1];
  *(_OWORD *)(v6 + 40) = *a3;
  *(_OWORD *)(v6 + 56) = v8;
  v9 = a1 + 1;
  v10 = a1[1];
  if (v10)
  {
    do
    {
      while (1)
      {
        v9 = (uint64_t **)v10;
        if (v7 >= *((double *)v10 + 4))
          break;
        v10 = (uint64_t *)*v10;
        v11 = v9;
        if (!*v9)
          goto LABEL_8;
      }
      v10 = (uint64_t *)v10[1];
    }
    while (v10);
    v11 = v9 + 1;
  }
  else
  {
    v11 = a1 + 1;
  }
LABEL_8:
  sub_1000145B0(a1, (uint64_t)v9, v11, (uint64_t *)v6);
  return v6;
}

uint64_t sub_1002F3E60(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  BOOL v6;

  v3 = sub_1002F3EC4(*(uint64_t ***)a1, *(double **)(a1 + 8), a2);
  *(_QWORD *)(a1 + 8) = v3;
  v4 = (_QWORD *)v3[1];
  if (v4)
  {
    do
    {
      v5 = v4;
      v4 = (_QWORD *)*v4;
    }
    while (v4);
  }
  else
  {
    do
    {
      v5 = (_QWORD *)v3[2];
      v6 = *v5 == (_QWORD)v3;
      v3 = v5;
    }
    while (!v6);
  }
  *(_QWORD *)(a1 + 8) = v5;
  return a1;
}

void *sub_1002F3EC4(uint64_t **a1, double *a2, uint64_t a3)
{
  void *v6;
  __int128 v7;
  double *v8;
  double *v10;

  v6 = operator new(0x48uLL);
  v7 = *(_OWORD *)(a3 + 16);
  *((_OWORD *)v6 + 2) = *(_OWORD *)a3;
  *((_OWORD *)v6 + 3) = v7;
  *((_QWORD *)v6 + 8) = *(_QWORD *)(a3 + 32);
  v8 = sub_1002F3F54(a1, a2, &v10, (double *)v6 + 4);
  sub_1000145B0(a1, (uint64_t)v10, (uint64_t **)v8, (uint64_t *)v6);
  return v6;
}

void sub_1002F3F40(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

double *sub_1002F3F54(_QWORD *a1, double *a2, double **a3, double *a4)
{
  double *v4;
  uint64_t v5;
  double v6;
  double v7;
  double *v8;
  double *v9;
  BOOL v10;
  uint64_t v11;

  v4 = (double *)(a1 + 1);
  if (a1 + 1 != (_QWORD *)a2 && a2[4] < *a4)
  {
    while (1)
    {
      v5 = *(_QWORD *)v4;
      a2 = v4;
      if (!*(_QWORD *)v4)
        break;
      while (1)
      {
        v4 = (double *)v5;
        if (*(double *)(v5 + 32) >= *a4)
          break;
        v5 = *(_QWORD *)(v5 + 8);
        if (!v5)
          goto LABEL_19;
      }
    }
LABEL_20:
    *a3 = v4;
    return a2;
  }
  v6 = *a2;
  if ((double *)*a1 == a2)
  {
    v8 = a2;
  }
  else
  {
    if (v6 == 0.0)
    {
      v9 = a2;
      do
      {
        v8 = (double *)*((_QWORD *)v9 + 2);
        v10 = *(_QWORD *)v8 == (_QWORD)v9;
        v9 = v8;
      }
      while (v10);
    }
    else
    {
      v7 = *a2;
      do
      {
        v8 = *(double **)&v7;
        v7 = *(double *)(*(_QWORD *)&v7 + 8);
      }
      while (v7 != 0.0);
    }
    if (*a4 < v8[4])
    {
      while (1)
      {
        v11 = *(_QWORD *)v4;
        a2 = v4;
        if (!*(_QWORD *)v4)
          goto LABEL_20;
        while (1)
        {
          v4 = (double *)v11;
          if (*a4 < *(double *)(v11 + 32))
            break;
          v11 = *(_QWORD *)(v11 + 8);
          if (!v11)
          {
LABEL_19:
            a2 = v4 + 1;
            goto LABEL_20;
          }
        }
      }
    }
  }
  if (v6 == 0.0)
  {
    *a3 = a2;
  }
  else
  {
    *a3 = v8;
    return v8 + 1;
  }
  return a2;
}

__int128 *sub_1002F403C(__int128 *a1, __int128 *a2, uint64_t a3)
{
  __int128 *v4;
  __int128 *v5;

  v4 = a1;
  if (a1 == a2)
    return a1;
  v5 = a2;
  do
  {
    sub_1002B7674(a3, v4);
    *(_OWORD *)(a3 + 16) = v4[1];
    a3 += 32;
    v4 += 2;
  }
  while (v4 != v5);
  return v5;
}

_OWORD *sub_1002F40A4(uint64_t **a1, unint64_t *a2, _OWORD *a3, _QWORD *a4)
{
  void **v7;
  _OWORD *v8;
  uint64_t **v9;
  uint64_t v11;

  v7 = (void **)sub_1002F4138((uint64_t)a1, &v11, a2);
  v8 = *v7;
  if (!*v7)
  {
    v9 = (uint64_t **)v7;
    v8 = operator new(0x38uLL);
    v8[2] = *a3;
    *((_QWORD *)v8 + 6) = *a4;
    sub_1000145B0(a1, v11, v9, (uint64_t *)v8);
  }
  return v8;
}

_QWORD *sub_1002F4138(uint64_t a1, _QWORD *a2, unint64_t *a3)
{
  _QWORD *result;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  unint64_t v7;
  unint64_t v8;
  int v9;
  unint64_t v10;
  unint64_t v11;
  int v12;

  v5 = *(_QWORD **)(a1 + 8);
  result = (_QWORD *)(a1 + 8);
  v4 = v5;
  if (v5)
  {
    do
    {
      while (1)
      {
        v6 = v4;
        v7 = bswap64(*a3);
        v8 = bswap64(v6[4]);
        if (v7 == v8)
        {
          v7 = bswap64(a3[1]);
          v8 = bswap64(v6[5]);
          if (v7 == v8)
            break;
        }
        v9 = v7 < v8 ? -1 : 1;
        if ((v9 & 0x80000000) == 0)
          break;
        v4 = (_QWORD *)*v6;
        result = v6;
        if (!*v6)
          goto LABEL_20;
      }
      v10 = bswap64(v6[4]);
      v11 = bswap64(*a3);
      if (v10 == v11)
      {
        v10 = bswap64(v6[5]);
        v11 = bswap64(a3[1]);
        if (v10 == v11)
          break;
      }
      v12 = v10 < v11 ? -1 : 1;
      if ((v12 & 0x80000000) == 0)
        break;
      result = v6 + 1;
      v4 = (_QWORD *)v6[1];
    }
    while (v4);
  }
  else
  {
    v6 = result;
  }
LABEL_20:
  *a2 = v6;
  return result;
}

void sub_1002F4200(uint64_t a1, unint64_t a2, _QWORD *a3)
{
  unint64_t v3;

  v3 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  if (a2 <= v3)
  {
    if (a2 < v3)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 8 * a2;
  }
  else
  {
    sub_1002F4230((void **)a1, a2 - v3, a3);
  }
}

void sub_1002F4230(void **a1, unint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  _BYTE *v7;
  _BYTE *v8;
  _QWORD *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t v16;
  _QWORD *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  char *i;
  uint64_t v25;

  v8 = a1[2];
  v6 = (uint64_t)(a1 + 2);
  v7 = v8;
  v9 = *(_QWORD **)(v6 - 8);
  if (a2 <= (v8 - (_BYTE *)v9) >> 3)
  {
    if (a2)
    {
      v16 = 8 * a2;
      v17 = &v9[a2];
      do
      {
        *v9++ = *a3;
        v16 -= 8;
      }
      while (v16);
      v9 = v17;
    }
    a1[1] = v9;
  }
  else
  {
    v10 = (char *)v9 - (_BYTE *)*a1;
    v11 = a2 + (v10 >> 3);
    if (v11 >> 61)
      sub_100259694();
    v12 = v10 >> 3;
    v13 = v7 - (_BYTE *)*a1;
    if (v13 >> 2 > v11)
      v11 = v13 >> 2;
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8)
      v14 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v14 = v11;
    if (v14)
      v15 = (char *)sub_10025E6A0(v6, v14);
    else
      v15 = 0;
    v18 = &v15[8 * v12];
    v19 = &v18[8 * a2];
    v20 = 8 * a2;
    v21 = v18;
    do
    {
      *(_QWORD *)v21 = *a3;
      v21 += 8;
      v20 -= 8;
    }
    while (v20);
    v22 = &v15[8 * v14];
    v23 = (char *)*a1;
    for (i = (char *)a1[1]; i != v23; i -= 8)
    {
      v25 = *((_QWORD *)i - 1);
      *((_QWORD *)v18 - 1) = v25;
      v18 -= 8;
    }
    *a1 = v18;
    a1[1] = v19;
    a1[2] = v22;
    if (v23)
      operator delete(v23);
  }
}

void sub_1002F4340(uint64_t a1, unint64_t a2, _DWORD *a3)
{
  unint64_t v3;

  v3 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  if (a2 <= v3)
  {
    if (a2 < v3)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 4 * a2;
  }
  else
  {
    sub_1002F4370((void **)a1, a2 - v3, a3);
  }
}

void sub_1002F4370(void **a1, unint64_t a2, _DWORD *a3)
{
  uint64_t v6;
  _BYTE *v7;
  _BYTE *v8;
  _DWORD *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t v16;
  _DWORD *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  char *i;
  int v25;

  v8 = a1[2];
  v6 = (uint64_t)(a1 + 2);
  v7 = v8;
  v9 = *(_DWORD **)(v6 - 8);
  if (a2 <= (v8 - (_BYTE *)v9) >> 2)
  {
    if (a2)
    {
      v16 = 4 * a2;
      v17 = &v9[a2];
      do
      {
        *v9++ = *a3;
        v16 -= 4;
      }
      while (v16);
      v9 = v17;
    }
    a1[1] = v9;
  }
  else
  {
    v10 = (char *)v9 - (_BYTE *)*a1;
    v11 = a2 + (v10 >> 2);
    if (v11 >> 62)
      sub_100259694();
    v12 = v10 >> 2;
    v13 = v7 - (_BYTE *)*a1;
    if (v13 >> 1 > v11)
      v11 = v13 >> 1;
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL)
      v14 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v14 = v11;
    if (v14)
      v15 = (char *)sub_100260634(v6, v14);
    else
      v15 = 0;
    v18 = &v15[4 * v12];
    v19 = &v18[4 * a2];
    v20 = 4 * a2;
    v21 = v18;
    do
    {
      *(_DWORD *)v21 = *a3;
      v21 += 4;
      v20 -= 4;
    }
    while (v20);
    v22 = &v15[4 * v14];
    v23 = (char *)*a1;
    for (i = (char *)a1[1]; i != v23; i -= 4)
    {
      v25 = *((_DWORD *)i - 1);
      *((_DWORD *)v18 - 1) = v25;
      v18 -= 4;
    }
    *a1 = v18;
    a1[1] = v19;
    a1[2] = v22;
    if (v23)
      operator delete(v23);
  }
}

_OWORD *sub_1002F4480(uint64_t **a1, unint64_t *a2, uint64_t a3, _OWORD **a4)
{
  void **v6;
  _OWORD *v7;
  uint64_t **v8;
  uint64_t v10;

  v6 = (void **)sub_1002F4138((uint64_t)a1, &v10, a2);
  v7 = *v6;
  if (!*v6)
  {
    v8 = (uint64_t **)v6;
    v7 = operator new(0x38uLL);
    v7[2] = **a4;
    *((_QWORD *)v7 + 6) = 0;
    sub_1000145B0(a1, v10, v8, (uint64_t *)v7);
  }
  return v7;
}

uint64_t *sub_1002F4508(uint64_t *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = *result;
  v2 = result[1];
  v4 = a2[1];
  while (v2 != v3)
  {
    v5 = *(_OWORD *)(v2 - 32);
    v2 -= 32;
    *(_OWORD *)(v4 - 32) = v5;
    v4 -= 32;
    *(_QWORD *)v2 = 0;
    *(_QWORD *)(v2 + 8) = 0;
    *(_OWORD *)(v4 + 16) = *(_OWORD *)(v2 + 16);
  }
  a2[1] = v4;
  v6 = *result;
  *result = v4;
  a2[1] = v6;
  v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1002F456C(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 32;
    sub_100261F44(i - 32);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

_QWORD *sub_1002F45B8(uint64_t a1, _QWORD *a2, uint64_t a3, _OWORD **a4)
{
  unint64_t v4;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  _QWORD **v11;
  _QWORD *i;
  unint64_t v13;
  _QWORD *v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  uint64_t v22;
  _QWORD *v23;
  unint64_t v24;

  v7 = 0;
  v8 = 0;
  do
    v8 ^= (v8 << 6) + (v8 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + v7++);
  while (v7 != 16);
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      v4 = v8;
      if (v8 >= v9)
        v4 = v8 % v9;
    }
    else
    {
      v4 = (v9 - 1) & v8;
    }
    v11 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v4);
    if (v11)
    {
      for (i = *v11; i; i = (_QWORD *)*i)
      {
        v13 = i[1];
        if (v13 == v8)
        {
          if (i[2] == *a2 && i[3] == a2[1])
            return i;
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9)
              v13 %= v9;
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v4)
            break;
        }
      }
    }
  }
  v15 = (_QWORD *)(a1 + 16);
  i = operator new(0x38uLL);
  *i = 0;
  i[1] = v8;
  *((_OWORD *)i + 1) = **a4;
  i[5] = 0;
  i[6] = 0;
  i[4] = 0;
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v9 || (float)(v17 * (float)v9) < v16)
  {
    v18 = 1;
    if (v9 >= 3)
      v18 = (v9 & (v9 - 1)) != 0;
    v19 = v18 | (2 * v9);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    sub_10012E444(a1, v21);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v4 = v8 % v9;
      else
        v4 = v8;
    }
    else
    {
      v4 = (v9 - 1) & v8;
    }
  }
  v22 = *(_QWORD *)a1;
  v23 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v23)
  {
    *i = *v23;
LABEL_44:
    *v23 = i;
    goto LABEL_45;
  }
  *i = *v15;
  *v15 = i;
  *(_QWORD *)(v22 + 8 * v4) = v15;
  if (*i)
  {
    v24 = *(_QWORD *)(*i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v24 >= v9)
        v24 %= v9;
    }
    else
    {
      v24 &= v9 - 1;
    }
    v23 = (_QWORD *)(*(_QWORD *)a1 + 8 * v24);
    goto LABEL_44;
  }
LABEL_45:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_1002F4824(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  _QWORD *v10;
  uint64_t v11;

  sub_1002F3AAC(v11, v10);
  _Unwind_Resume(a1);
}

uint64_t sub_1002F4840(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
  _QWORD *v4;
  unint64_t *v6;

  *(_QWORD *)(a1 + 8) = 0;
  v4 = (_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = a1 + 8;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      sub_1002F48C0((uint64_t **)a1, v4, v6, v6);
      v6 += 2;
    }
    while (v6 != a3);
  }
  return a1;
}

void sub_1002F48A8(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_100008848(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

char *sub_1002F48C0(uint64_t **a1, _QWORD *a2, unint64_t *a3, _OWORD *a4)
{
  void **v6;
  char *v7;
  uint64_t **v8;
  uint64_t v10;
  uint64_t v11;

  v6 = (void **)sub_1002F4944(a1, a2, &v11, &v10, a3);
  v7 = (char *)*v6;
  if (!*v6)
  {
    v8 = (uint64_t **)v6;
    v7 = (char *)operator new(0x30uLL);
    *(_OWORD *)(v7 + 25) = *a4;
    sub_1000145B0(a1, v11, v8, (uint64_t *)v7);
  }
  return v7;
}

_QWORD *sub_1002F4944(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, unint64_t *a5)
{
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  int v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  int v15;
  _QWORD *v16;
  BOOL v17;
  unint64_t v18;
  unint64_t v19;
  int v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t v23;
  int v24;

  if (a1 + 1 == a2
    || ((v5 = bswap64(*a5), v6 = bswap64(*(_QWORD *)((char *)a2 + 25)), v5 != v6)
     || (v5 = bswap64(a5[1]), v6 = bswap64(*(_QWORD *)((char *)a2 + 33)), v5 != v6))
    && (v5 < v6 ? (v10 = -1) : (v10 = 1), v10 < 0))
  {
    v7 = *a2;
    if ((_QWORD *)*a1 == a2)
    {
      v9 = a2;
    }
    else
    {
      if (v7)
      {
        v8 = (_QWORD *)*a2;
        do
        {
          v9 = v8;
          v8 = (_QWORD *)v8[1];
        }
        while (v8);
      }
      else
      {
        v16 = a2;
        do
        {
          v9 = (_QWORD *)v16[2];
          v17 = *v9 == (_QWORD)v16;
          v16 = v9;
        }
        while (v17);
      }
      v18 = bswap64(*(_QWORD *)((char *)v9 + 25));
      v19 = bswap64(*a5);
      if (v18 == v19)
      {
        v18 = bswap64(*(_QWORD *)((char *)v9 + 33));
        v19 = bswap64(a5[1]);
        if (v18 == v19)
          return sub_1002F4B4C((uint64_t)a1, a3, a5);
      }
      v20 = v18 < v19 ? -1 : 1;
      if ((v20 & 0x80000000) == 0)
        return sub_1002F4B4C((uint64_t)a1, a3, a5);
    }
    if (v7)
    {
      *a3 = v9;
      return v9 + 1;
    }
    else
    {
      *a3 = a2;
      return a2;
    }
  }
  v11 = bswap64(*(_QWORD *)((char *)a2 + 25));
  v12 = bswap64(*a5);
  if (v11 != v12 || (v11 = bswap64(*(_QWORD *)((char *)a2 + 33)), v12 = bswap64(a5[1]), v11 != v12))
  {
    v15 = v11 < v12 ? -1 : 1;
    if (v15 < 0)
    {
      v13 = a2[1];
      if (v13)
      {
        v14 = (_QWORD *)a2[1];
        do
        {
          a4 = v14;
          v14 = (_QWORD *)*v14;
        }
        while (v14);
      }
      else
      {
        v21 = a2;
        do
        {
          a4 = (_QWORD *)v21[2];
          v17 = *a4 == (_QWORD)v21;
          v21 = a4;
        }
        while (!v17);
      }
      if (a4 == a1 + 1
        || ((v22 = bswap64(*a5), v23 = bswap64(*(_QWORD *)((char *)a4 + 25)), v22 != v23)
         || (v22 = bswap64(a5[1]), v23 = bswap64(*(_QWORD *)((char *)a4 + 33)), v22 != v23)
          ? (v22 < v23
           ? (v24 = -1)
           : (v24 = 1))
          : (v24 = 0),
            v24 < 0))
      {
        if (v13)
        {
          *a3 = a4;
        }
        else
        {
          *a3 = a2;
          return a2 + 1;
        }
        return a4;
      }
      return sub_1002F4B4C((uint64_t)a1, a3, a5);
    }
  }
  *a3 = a2;
  *a4 = a2;
  return a4;
}

_QWORD *sub_1002F4B4C(uint64_t a1, _QWORD *a2, unint64_t *a3)
{
  _QWORD *result;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  unint64_t v7;
  unint64_t v8;
  int v9;
  unint64_t v10;
  unint64_t v11;
  int v12;

  v5 = *(_QWORD **)(a1 + 8);
  result = (_QWORD *)(a1 + 8);
  v4 = v5;
  if (v5)
  {
    do
    {
      while (1)
      {
        v6 = v4;
        v7 = bswap64(*a3);
        v8 = bswap64(*(_QWORD *)((char *)v6 + 25));
        if (v7 == v8)
        {
          v7 = bswap64(a3[1]);
          v8 = bswap64(*(_QWORD *)((char *)v6 + 33));
          if (v7 == v8)
            break;
        }
        v9 = v7 < v8 ? -1 : 1;
        if ((v9 & 0x80000000) == 0)
          break;
        v4 = (_QWORD *)*v6;
        result = v6;
        if (!*v6)
          goto LABEL_20;
      }
      v10 = bswap64(*(_QWORD *)((char *)v6 + 25));
      v11 = bswap64(*a3);
      if (v10 == v11)
      {
        v10 = bswap64(*(_QWORD *)((char *)v6 + 33));
        v11 = bswap64(a3[1]);
        if (v10 == v11)
          break;
      }
      v12 = v10 < v11 ? -1 : 1;
      if ((v12 & 0x80000000) == 0)
        break;
      result = v6 + 1;
      v4 = (_QWORD *)v6[1];
    }
    while (v4);
  }
  else
  {
    v6 = result;
  }
LABEL_20:
  *a2 = v6;
  return result;
}

_QWORD *sub_1002F4C14(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  BOOL v8;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2 == a3)
  {
    v4 = 0;
  }
  else
  {
    v4 = 0;
    v5 = a2;
    do
    {
      v6 = (_QWORD *)v5[1];
      if (v6)
      {
        do
        {
          v7 = v6;
          v6 = (_QWORD *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          v7 = (_QWORD *)v5[2];
          v8 = *v7 == (_QWORD)v5;
          v5 = v7;
        }
        while (!v8);
      }
      ++v4;
      v5 = v7;
    }
    while (v7 != a3);
  }
  sub_1002F4C98(a1, a2, a3, v4);
  return a1;
}

_QWORD *sub_1002F4C98(_QWORD *result, _QWORD *a2, _QWORD *a3, unint64_t a4)
{
  uint64_t v6;

  if (a4)
  {
    v6 = (uint64_t)result;
    sub_1002AE87C(result, a4);
    return (_QWORD *)sub_1002F4D04(v6, a2, a3);
  }
  return result;
}

void sub_1002F4CE8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002F4D04(uint64_t result, _QWORD *a2, _QWORD *a3)
{
  _OWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  BOOL v6;

  v3 = *(_OWORD **)(result + 8);
  if (a2 != a3)
  {
    do
    {
      *v3 = *(_OWORD *)((char *)a2 + 25);
      v4 = (_QWORD *)a2[1];
      if (v4)
      {
        do
        {
          v5 = v4;
          v4 = (_QWORD *)*v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          v5 = (_QWORD *)a2[2];
          v6 = *v5 == (_QWORD)a2;
          a2 = v5;
        }
        while (!v6);
      }
      ++v3;
      a2 = v5;
    }
    while (v5 != a3);
  }
  *(_QWORD *)(result + 8) = v3;
  return result;
}

_QWORD *sub_1002F4D5C(_QWORD *a1, _QWORD *a2)
{
  _QWORD *result;
  _QWORD *v4;

  result = sub_1002A1BA8(a1, a2);
  if (result)
  {
    v4 = result;
    do
    {
      v4 = (_QWORD *)*v4;
      if (!v4)
        break;
    }
    while (v4[2] == *a2 && v4[3] == a2[1]);
  }
  return result;
}

uint64_t *sub_1002F4DA8(uint64_t *a1, _DWORD *a2)
{
  uint64_t v4;
  _DWORD *v5;
  _QWORD *v6;
  _DWORD *v7;
  _DWORD *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  int v16;

  v4 = *a1;
  v5 = *(_DWORD **)(*a1 + 8);
  v6 = (_QWORD *)(*a1 + 16);
  if ((unint64_t)v5 >= *v6)
  {
    v8 = *(_DWORD **)v4;
    v9 = ((uint64_t)v5 - *(_QWORD *)v4) >> 2;
    v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 62)
      sub_100259694();
    v11 = *v6 - (_QWORD)v8;
    if (v11 >> 1 > v10)
      v10 = v11 >> 1;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL)
      v12 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v12 = v10;
    if (v12)
    {
      v13 = (char *)sub_100260634((uint64_t)v6, v12);
      v8 = *(_DWORD **)v4;
      v5 = *(_DWORD **)(v4 + 8);
    }
    else
    {
      v13 = 0;
    }
    v14 = &v13[4 * v9];
    v15 = &v13[4 * v12];
    *(_DWORD *)v14 = *a2;
    v7 = v14 + 4;
    while (v5 != v8)
    {
      v16 = *--v5;
      *((_DWORD *)v14 - 1) = v16;
      v14 -= 4;
    }
    *(_QWORD *)v4 = v14;
    *(_QWORD *)(v4 + 8) = v7;
    *(_QWORD *)(v4 + 16) = v15;
    if (v8)
      operator delete(v8);
  }
  else
  {
    *v5 = *a2;
    v7 = v5 + 1;
  }
  *(_QWORD *)(v4 + 8) = v7;
  return a1;
}

void sub_1002F4E94(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  int v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 2)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 4 * a2);
      v7 += 4 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = *a1;
    v9 = v7 - *a1;
    v10 = a2 + (v9 >> 2);
    if (v10 >> 62)
      sub_100259694();
    v11 = v9 >> 2;
    v12 = v5 - v8;
    if (v12 >> 1 > v10)
      v10 = v12 >> 1;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL)
      v13 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v13 = v10;
    if (v13)
    {
      v14 = (char *)sub_100260634(v4, v13);
      v8 = *a1;
      v7 = a1[1];
    }
    else
    {
      v14 = 0;
    }
    v15 = &v14[4 * v11];
    v16 = &v14[4 * v13];
    bzero(v15, 4 * a2);
    v17 = &v15[4 * a2];
    while (v7 != v8)
    {
      v18 = *((_DWORD *)v7 - 1);
      v7 -= 4;
      *((_DWORD *)v15 - 1) = v18;
      v15 -= 4;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
      operator delete(v8);
  }
}

char *sub_1002F4F9C(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  char *v5;
  char *v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  void *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  int64_t v22;
  char *v23;
  char *v24;
  char *v25;
  char *v26;
  __int128 v27;
  char *v28;
  uint64_t v29;
  char *v30;
  __int128 v31;
  void *__p;
  char *v34;
  char *v35;
  char *v36;
  uint64_t v37;

  v5 = (char *)__dst;
  if (a5 < 1)
    return v5;
  v7 = __src;
  v11 = *(_QWORD *)(a1 + 16);
  v9 = a1 + 16;
  v10 = v11;
  v12 = *(_QWORD *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 4)
  {
    v13 = *(void **)a1;
    v14 = a5 + ((uint64_t)(v12 - *(_QWORD *)a1) >> 4);
    if (v14 >> 60)
      sub_100259694();
    v15 = (__dst - (uint64_t)v13) >> 4;
    v16 = v10 - (_QWORD)v13;
    if (v16 >> 3 > v14)
      v14 = v16 >> 3;
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF0)
      v17 = 0xFFFFFFFFFFFFFFFLL;
    else
      v17 = v14;
    v37 = v9;
    if (v17)
      v18 = (char *)sub_10028E224(v9, v17);
    else
      v18 = 0;
    v28 = &v18[16 * v15];
    __p = v18;
    v34 = v28;
    v36 = &v18[16 * v17];
    v29 = 16 * a5;
    v30 = &v28[16 * a5];
    do
    {
      v31 = *(_OWORD *)v7;
      v7 += 16;
      *(_OWORD *)v28 = v31;
      v28 += 16;
      v29 -= 16;
    }
    while (v29);
    v35 = v30;
    v5 = (char *)sub_1002F51A8((void **)a1, (uint64_t)&__p, v5);
    if (v35 != v34)
      v35 += (v34 - v35 + 15) & 0xFFFFFFFFFFFFFFF0;
    if (__p)
      operator delete(__p);
    return v5;
  }
  v19 = v12 - __dst;
  v20 = (uint64_t)(v12 - __dst) >> 4;
  if (v20 >= a5)
  {
    v21 = &__src[16 * a5];
    v23 = *(char **)(v9 - 8);
LABEL_17:
    v24 = &v5[16 * a5];
    v25 = &v23[-16 * a5];
    v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      v26 = v23;
      do
      {
        v27 = *(_OWORD *)v25;
        v25 += 16;
        *(_OWORD *)v26 = v27;
        v26 += 16;
      }
      while ((unint64_t)v25 < v12);
    }
    *(_QWORD *)(a1 + 8) = v26;
    if (v23 != v24)
      memmove(&v23[-16 * ((v23 - v24) >> 4)], v5, v23 - v24);
    if (v21 != v7)
      memmove(v5, v7, v21 - v7);
    return v5;
  }
  v21 = &__src[16 * v20];
  v22 = a4 - v21;
  if (a4 != v21)
    memmove(*(void **)(v9 - 8), &__src[16 * v20], a4 - v21);
  v23 = (char *)(v12 + v22);
  *(_QWORD *)(a1 + 8) = v12 + v22;
  if (v19 >= 1)
    goto LABEL_17;
  return v5;
}

void sub_1002F5170(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void *sub_1002F51A8(void **a1, uint64_t a2, char *__src)
{
  void *v5;
  char *v6;
  void *v7;
  char *v8;
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  int64_t v12;
  char *v13;
  void *v14;
  void *v15;

  v5 = *(void **)(a2 + 8);
  v6 = (char *)*a1;
  v7 = v5;
  if (*a1 != __src)
  {
    v8 = __src;
    v9 = *(_QWORD *)(a2 + 8);
    do
    {
      v7 = (void *)(v9 - 16);
      *(_OWORD *)(v9 - 16) = *((_OWORD *)v8 - 1);
      v8 -= 16;
      v9 -= 16;
    }
    while (v8 != v6);
  }
  *(_QWORD *)(a2 + 8) = v7;
  v10 = a1[1];
  v11 = *(_QWORD *)(a2 + 16);
  v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    v7 = *(void **)(a2 + 8);
  }
  *(_QWORD *)(a2 + 16) = v11 + v12;
  v13 = (char *)*a1;
  *a1 = v7;
  *(_QWORD *)(a2 + 8) = v13;
  v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v14;
  v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v15;
  *(_QWORD *)a2 = *(_QWORD *)(a2 + 8);
  return v5;
}

void sub_1002F527C(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 4)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 16 * a2);
      v7 += 16 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - (_BYTE *)*a1;
    v9 = a2 + (v8 >> 4);
    if (v9 >> 60)
      sub_100259694();
    v10 = v8 >> 4;
    v11 = v5 - (_BYTE *)*a1;
    if (v11 >> 3 > v9)
      v9 = v11 >> 3;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0)
      v12 = 0xFFFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    if (v12)
      v13 = (char *)sub_10028E224(v4, v12);
    else
      v13 = 0;
    v14 = &v13[16 * v10];
    v15 = &v13[16 * v12];
    bzero(v14, 16 * a2);
    v16 = &v14[16 * a2];
    v18 = (char *)*a1;
    v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        *((_OWORD *)v14 - 1) = *((_OWORD *)v17 - 1);
        v14 -= 16;
        v17 -= 16;
      }
      while (v17 != v18);
      v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
      operator delete(v17);
  }
}

void *sub_1002F5388(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xCCCCCCCCCCCCCCDLL)
    sub_10025955C();
  return operator new(20 * a2);
}

void sub_1002F53CC()
{
  operator delete[]();
}

void sub_1002F53F4(void *a1@<X1>, _BYTE *a2@<X2>, double *a3@<X3>, _BYTE *a4@<X8>)
{
  double v8;
  const std::string::value_type *v9;
  NSObject *v10;
  std::string *v11;
  int v12;
  int v13;
  int v14;
  _BYTE v15[16];
  uint64_t v16;
  std::string *v17;
  int v18;
  uint8_t v19[136];
  uint8_t buf[4];
  int v21;
  _BYTE v22[2];
  const char *v23;
  __int16 v24;
  std::string *v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;

  if (objc_msgSend(objc_msgSend(a1, "bundleId"), "isEqualToString:", &stru_1021D8FB8))
  {
    v8 = *a3;
    sub_1002BBB48((uint64_t)v15);
    sub_1002F5768((uint64_t)v15, 0, 0, 3u, (uint64_t)v19, v8);
    buf[0] = 0;
    sub_1002DF194(v22);
    *a4 = buf[0];
    sub_1002DF194(a4 + 8);
  }
  else
  {
    v9 = (const std::string::value_type *)objc_msgSend(objc_msgSend(a1, "launchReason", sub_1002BBB48((uint64_t)v15)), "UTF8String");
    v18 |= 8u;
    if (v17 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      operator new();
    std::string::assign(v17, v9);
    v18 |= 4u;
    if (!v16)
      operator new();
    sub_1002CA200(v16, a2);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E478);
    v10 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      v11 = v17;
      if (SHIBYTE(v17->__r_.__value_.__r.__words[2]) < 0)
        v11 = (std::string *)v17->__r_.__value_.__r.__words[0];
      v12 = v18 | 4;
      v18 |= 4u;
      if (!v16)
        operator new();
      v13 = *(unsigned __int8 *)(v16 + 8);
      v18 = v12;
      v14 = *(unsigned __int8 *)(v16 + 9);
      *(_DWORD *)buf = 68289794;
      v21 = 0;
      v22[0] = 34;
      v22[1] = 8;
      v23 = "";
      v24 = 2082;
      v25 = v11;
      v26 = 1026;
      v27 = v13;
      v28 = 1026;
      v29 = v14;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"appLaunch\", \"launchReason\":%{public, location:escape_only}s, \"islongformvideo\":%{public}hhd, \"is MR allowed app\":%{public}hhd}", buf, 0x28u);
    }
    sub_1002F5768((uint64_t)v15, 0, 0, 3u, (uint64_t)v19, *a3);
    buf[0] = 1;
    sub_1002DF194(v22);
    *a4 = buf[0];
    sub_1002DF194(a4 + 8);
  }
  sub_1002DF2E0(v22);
  sub_1002DF2E0(v19);
  sub_1002CBA64((wireless_diagnostics::google::protobuf::MessageLite *)v15);
}

void sub_1002F56F4()
{
  operator delete();
}

void sub_1002F5768(uint64_t a1@<X0>, char a2@<W1>, char a3@<W2>, unsigned int a4@<W3>, uint64_t a5@<X8>, double a6@<D0>)
{
  unsigned int v12;
  int v13;
  const char *v14;
  int v15;
  const char *v16;

  sub_1002BBFAC(a5);
  v12 = *(_DWORD *)(a1 + 32);
  if (!sub_1002BC6A4(v12))
  {
    v14 = "::CLMicroLocationProto::EventType_IsValid(value)";
    v15 = 19803;
    v16 = "set_eventtype";
    goto LABEL_6;
  }
  v13 = *(_DWORD *)(a5 + 128);
  *(_DWORD *)(a5 + 72) = v12;
  *(double *)(a5 + 8) = a6;
  *(_BYTE *)(a5 + 77) = a2;
  *(_DWORD *)(a5 + 128) = v13 | 0x2803;
  *(_BYTE *)(a5 + 76) = a3;
  if ((sub_1002BC674(a4) & 1) == 0)
  {
    v14 = "::CLMicroLocationProto::ConfidenceLevel_IsValid(value)";
    v15 = 20312;
    v16 = "set_confidencelevel";
LABEL_6:
    __assert_rtn(v16, "microlocation.pb.h", v15, v14);
  }
  *(_DWORD *)(a5 + 128) |= 0x4000u;
  *(_DWORD *)(a5 + 120) = a4;
  sub_10035815C(a5, a1);
}

void sub_1002F584C(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1002DF2E0(v1);
  _Unwind_Resume(a1);
}

void sub_1002F5860(id a1)
{
  qword_1022A00F8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

_QWORD *sub_1002F588C(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  char *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD v9[4];
  _QWORD v10[4];
  _QWORD v11[4];
  _QWORD v12[4];
  _QWORD v13[4];
  _QWORD v14[3];
  _QWORD *v15;
  uint64_t v16;

  *a1 = a2;
  a1[1] = a3;
  v9[0] = off_10212E510;
  v9[1] = a1;
  v9[3] = v9;
  v10[0] = off_10212E590;
  v10[1] = a1;
  v10[3] = v10;
  v11[0] = off_10212E610;
  v11[1] = a1;
  v11[3] = v11;
  v12[0] = off_10212E690;
  v12[1] = a1;
  v12[3] = v12;
  v13[0] = off_10212E710;
  v13[1] = a1;
  v13[3] = v13;
  v14[0] = off_10212E790;
  v14[1] = a1;
  v15 = v14;
  a1[3] = 0;
  a1[4] = 0;
  a1[2] = 0;
  v4 = (char *)operator new(0xC0uLL);
  a1[4] = v4 + 192;
  a1[2] = v4;
  a1[3] = v4;
  v5 = 0;
  a1[3] = sub_1002AE630((uint64_t)(a1 + 4), (uint64_t)v9, (uint64_t)&v16, (uint64_t)v4);
  do
  {
    v6 = (&v15)[v5];
    if (&v14[v5] == v6)
    {
      v6 = &v14[v5];
      v7 = 4;
    }
    else
    {
      if (!v6)
        goto LABEL_7;
      v7 = 5;
    }
    (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_7:
    v5 -= 4;
  }
  while (v5 != -24);
  return a1;
}

void sub_1002F59F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, char a12)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;
  char *v17;
  uint64_t v18;

  v14 = v13;
  *(_QWORD *)(v12 + 24) = v14;
  sub_1002AE76C(&a10);
  v16 = 0;
  while (1)
  {
    v17 = *(char **)(&a12 + v16 + 184);
    if (&a12 + v16 + 160 == v17)
      break;
    if (v17)
    {
      v18 = 5;
LABEL_6:
      (*(void (**)(void))(*(_QWORD *)v17 + 8 * v18))();
    }
    v16 -= 32;
    if (v16 == -192)
      _Unwind_Resume(a1);
  }
  v17 = &a12 + v16 + 160;
  v18 = 4;
  goto LABEL_6;
}

uint64_t sub_1002F5A60()
{
  CFStringRef v0;
  int v1;
  unsigned int v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unsigned int v7;
  uint64_t v8;
  std::__shared_weak_count *v9;

  sub_1001E4804(&v8);
  v7 = 0;
  v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsLearningLabeledRecordingTriggersLimit", 0x8000100u, kCFAllocatorNull);
  v1 = sub_1000B1180(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  v2 = v7;
  v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  if (v1)
    return v2;
  else
    return 250;
}

void sub_1002F5B24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  sub_100261F44((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002F5B3C@<X0>(uint64_t a1@<X0>, __int128 *a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  _BYTE v11[16];
  uint64_t *v12;
  int v13;
  __int128 v14;
  _BYTE v15[80];
  uint64_t v16;
  char v17;

  sub_1003A336C(a3);
  result = sub_1002F5CC4();
  if ((_DWORD)result)
  {
    sub_1002823C4(*(_QWORD *)(a1 + 8), a2, v15);
    if (v17
      || *a2 != 0
      && (v9 = *(_QWORD *)(a1 + 8),
          v10 = 0uLL,
          sub_1002823C4(v9, &v10, v11),
          sub_1002FFBE0((uint64_t)v15, (uint64_t)v11),
          sub_1002FFD68((uint64_t)v11),
          v17))
    {
      v7 = v16;
      if (!v16)
        v7 = *(_QWORD *)(qword_102310460 + 24);
      v8 = *(_QWORD *)(v7 + 8);
      if (!v8)
        v8 = *(_QWORD *)(qword_102310450 + 8);
      sub_1003A33C0((uint64_t)v11, v8);
      if (v11 != (_BYTE *)a3)
      {
        *(_DWORD *)(a3 + 32) = v13;
        sub_100270130((_QWORD *)a3, v12, 0);
      }
      *(_OWORD *)(a3 + 40) = v14;
      sub_100067AC4((uint64_t)v11);
    }
    return sub_1002FFD68((uint64_t)v15);
  }
  return result;
}

void sub_1002F5C78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  uint64_t v27;

  sub_1002FFD68((uint64_t)&a12);
  sub_1002FFD68((uint64_t)&a27);
  sub_100067AC4(v27);
  _Unwind_Resume(a1);
}

uint64_t sub_1002F5CC4()
{
  CFStringRef v0;
  int v1;
  _BOOL4 v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  BOOL v7;
  uint64_t v8;
  std::__shared_weak_count *v9;

  sub_1001E4804(&v8);
  v7 = 0;
  v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsAdaptiveAnchorsEnable", 0x8000100u, kCFAllocatorNull);
  v1 = sub_1001E48E4(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  v2 = v7;
  v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  if (v2)
    return 1;
  else
    return v1 ^ 1u;
}

void sub_1002F5D88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  sub_100261F44((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1002F5DA0(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned int a8)
{
  char v10;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v21;
  __int128 *v22;
  __int128 *v23;
  uint64_t v24;
  void *__p[2];
  uint64_t v27;
  void **v28;
  __int128 v29;
  uint64_t v30;
  _QWORD v31[2];

  v31[0] = a5;
  v31[1] = a6;
  if (a3[1] != *a3)
  {
    sub_1018F3020();
    goto LABEL_31;
  }
  if (*(_QWORD *)(a4 + 8) != *(_QWORD *)a4)
  {
    sub_1018F2EB0();
LABEL_31:
    __break(1u);
  }
  v10 = a5;
  v14 = a2 + 24;
  sub_10027D890(*(_QWORD *)(a1 + 8), a2 + 24, a5, a6, a8, __p, 0.0);
  sub_100301E28(a3);
  *(_OWORD *)a3 = *(_OWORD *)__p;
  a3[2] = v27;
  __p[1] = 0;
  v27 = 0;
  __p[0] = 0;
  *(_QWORD *)&v29 = __p;
  sub_1002699DC((void ***)&v29);
  v15 = a3[1] - *a3;
  if (a8 > (unint64_t)(v15 >> 6))
  {
    if (v10)
    {
LABEL_5:
      sub_10027D890(*(_QWORD *)(a1 + 8), v14, 0, 0, a8 - ((unint64_t)v15 >> 6), __p, 0.0);
      sub_100301E60(a3, a3[1], (uint64_t)__p[0], (__int128 *)__p[1], ((char *)__p[1] - (char *)__p[0]) >> 6);
      *(_QWORD *)&v29 = __p;
      sub_1002699DC((void ***)&v29);
    }
    else
    {
      v24 = 1;
      while (v24 != 16)
      {
        if (*((unsigned __int8 *)v31 + v24++))
        {
          if ((unint64_t)(v24 - 2) <= 0xE)
            goto LABEL_5;
          break;
        }
      }
    }
  }
  v16 = *(char *)(a2 + 23);
  if (v16 < 0)
  {
    if (*(_QWORD *)(a2 + 8) != 10)
      goto LABEL_18;
    v17 = *(_QWORD *)a2;
  }
  else
  {
    v17 = a2;
    if (v16 != 10)
      goto LABEL_18;
  }
  v18 = *(_QWORD *)v17;
  v19 = *(unsigned __int16 *)(v17 + 8);
  if (v18 == 0x6F6D2D7375636F66 && v19 == 25956)
  {
    v21 = a3[1] - *a3;
    if (a8 > (unint64_t)(v21 >> 6))
    {
      sub_10027D890(*(_QWORD *)(a1 + 8), a2, 0, 0, a8 - ((unint64_t)v21 >> 6), __p, 0.0);
      sub_100301E60(a3, a3[1], (uint64_t)__p[0], (__int128 *)__p[1], ((char *)__p[1] - (char *)__p[0]) >> 6);
      *(_QWORD *)&v29 = __p;
      sub_1002699DC((void ***)&v29);
    }
  }
LABEL_18:
  __p[0] = 0;
  __p[1] = 0;
  v23 = (__int128 *)*a3;
  v22 = (__int128 *)a3[1];
  v27 = 0;
  v28 = __p;
  while (v23 != v22)
  {
    v29 = *v23;
    sub_10028E12C(&v28, &v29);
    v23 += 4;
  }
  sub_10027E6C8(*(_QWORD *)(a1 + 8), (uint64_t)__p, &v29);
  sub_1003024D8((void **)a4);
  *(_OWORD *)a4 = v29;
  *(_QWORD *)(a4 + 16) = v30;
  v30 = 0;
  v28 = (void **)&v29;
  v29 = 0uLL;
  sub_100270C6C(&v28);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_1002F605C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, void **p_p)
{
  p_p = &__p;
  sub_1002699DC(&p_p);
  _Unwind_Resume(a1);
}

void sub_1002F60A0(uint64_t *a1, uint64_t a2, unsigned int a3)
{
  NSObject *v5;
  const __CFAllocator *v6;
  CFStringRef v7;
  int v8;
  int v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  int v13;
  NSObject *v14;
  const char *v15;
  uint8_t *v16;
  const __CFString *v17;
  _BOOL4 v18;
  __n128 v19;
  std::__shared_weak_count *v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  unint64_t v23;
  double Current;
  CFStringRef v25;
  int v26;
  int v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  int v31;
  CFStringRef v32;
  int v33;
  double v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  _BOOL4 v38;
  NSObject *v39;
  const char *v40;
  NSObject *v41;
  const char *v42;
  CFStringRef v43;
  int v44;
  int v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  int v49;
  int v50;
  uint64_t v51;
  NSObject *v52;
  void **v53;
  uint64_t *v54;
  _QWORD **v55;
  _QWORD **v56;
  uint64_t v57;
  _QWORD *v58;
  NSObject *v59;
  const char *v60;
  uint8_t *v61;
  uint8_t *v62;
  uint64_t v63;
  uint64_t v64;
  char v65;
  NSObject *v66;
  char *v67;
  uint8_t *v68;
  CFStringRef v69;
  char v70;
  int v71;
  std::__shared_weak_count *v72;
  unint64_t *v73;
  unint64_t v74;
  char v75;
  id v76;
  void **v77;
  unint64_t v78;
  void **v79;
  NSObject *v80;
  void **v81;
  void *v82;
  _OWORD *v83;
  void *v84;
  uint64_t v85;
  NSMutableDictionary *v86;
  void **v87;
  uint64_t v88;
  __int128 v89;
  void **v90;
  NSObject *v91;
  NSObject *v92;
  char *v93;
  const __CFArray *v94;
  uint64_t v95;
  NSObject *v96;
  NSObject *v97;
  NSObject *v98;
  uint64_t v99;
  void *v100;
  void ***v101;
  uint64_t v102;
  char v103;
  BOOL v104;
  NSObject *v105;
  char *v106;
  const __CFArray *v107;
  uint64_t *v108;
  id v109;
  NSObject *v110;
  uint64_t *v111;
  uint64_t *v112;
  char *v113;
  const __CFArray *v114;
  void **v115;
  uint64_t *v116;
  uint64_t *v117;
  NSObject *v118;
  double v119;
  NSObject *v120;
  uint64_t v121;
  id v122;
  uint64_t *v123;
  void *v124;
  void **v125;
  unint64_t v126;
  uint64_t *v127;
  void *v129[3];
  unint64_t v130;
  uint64_t v131;
  char v132;
  void *__dst[2];
  void *v134;
  char v135;
  uint64_t *v136;
  char *v137;
  uint64_t v138;
  char v139;
  _QWORD v140[7];
  void *v141;
  void *v142;
  uint64_t v143;
  _BYTE v144[24];
  uint64_t v145;
  uint64_t v146;
  void *v147;
  void *v148;
  uint64_t v149;
  void **v150;
  void **v151;
  _QWORD v152[6];
  _BYTE v153[32];
  int v154;
  id v155;
  char v156;
  void *v157;
  _BYTE *v158;
  unsigned __int8 v159;
  char v160;
  unsigned int v161;
  uint8_t v162[8];
  void *v163;
  void *v164;
  __int128 v165;
  __int128 v166;
  char v167;
  uint8_t v168[8];
  _BYTE v169[20];
  __int16 v170;
  void *v171;
  __int16 v172;
  void *v173;
  __int16 v174;
  uint64_t v175;
  unsigned __int8 v176;
  unsigned int v177;
  __int128 v178;
  char v179;
  _BYTE v180[120];
  void *__p;
  std::__shared_weak_count *v182;
  char v183;
  char v184;
  uint8_t buf[8];
  _BYTE v186[32];
  void **v187;
  uint64_t v188;
  _BYTE *v189;
  void **p_p;
  uint8_t *v191;
  char v192;

  v161 = a3;
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E498);
  v5 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 68289282;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)v186 = 2082;
    *(_QWORD *)&v186[2] = "";
    *(_WORD *)&v186[10] = 2050;
    *(_QWORD *)&v186[12] = a3;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"start learn model\", \"model-type\":%{public}lu}", buf, 0x1Cu);
  }
  sub_1001E4804(buf);
  LOBYTE(__p) = 0;
  v6 = kCFAllocatorNull;
  v7 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsEnableLearning", 0x8000100u, kCFAllocatorNull);
  v8 = sub_1001E48E4(*(uint64_t *)buf, (uint64_t)v7, (BOOL *)&__p);
  CFRelease(v7);
  v9 = __p;
  v10 = *(std::__shared_weak_count **)v186;
  if (*(_QWORD *)v186)
  {
    v11 = (unint64_t *)(*(_QWORD *)v186 + 8);
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  if (v9)
    v13 = 0;
  else
    v13 = v8;
  if (v13 == 1)
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E498);
    v14 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#Warning Tried to run learning, but learning is disabled", buf, 2u);
    }
    if (sub_1001BFF7C(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E498);
      LOWORD(__p) = 0;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#Warning Tried to run learning, but learning is disabled", &__p, 2);
      v16 = (uint8_t *)v15;
      sub_100512490("Generic", 1, 0, 2, "void CLMicroLocationLearner::learnFromModelType(CLMicroLocationLearner::ShouldCancelFunction, CLMicroLocationProto::Model::ModelType)", "%s\n", v15);
LABEL_67:
      if (v16 != buf)
        free(v16);
      return;
    }
    return;
  }
  sub_1001E4804(&__p);
  *(_QWORD *)v168 = 0;
  v17 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsEnabledModelTypes", 0x8000100u, kCFAllocatorNull);
  v18 = sub_100527258((uint64_t)__p, v17, (CFTypeRef *)v168);
  CFRelease(v17);
  if (v18)
  {
    v19.n128_f64[0] = sub_1002FFDA8(*(const __CFArray **)v168, (uint64_t)buf);
  }
  else
  {
    *(_QWORD *)v186 = 0;
    *(_QWORD *)buf = 0;
    *(_QWORD *)&v186[8] = 0;
    *(_QWORD *)buf = operator new(8uLL);
    *(_OWORD *)v186 = xmmword_101B9ACD0;
    sub_10030023C(buf, byte_101B9C848, &byte_101B9C848[3], 3);
  }
  v20 = v182;
  if (v182)
  {
    p_shared_owners = (unint64_t *)&v182->__shared_owners_;
    do
      v22 = __ldaxr(p_shared_owners);
    while (__stlxr(v22 - 1, p_shared_owners));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *, __n128))v20->__on_zero_shared)(v20, v19);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  v127 = a1;
  if (*(_QWORD *)v186 <= (unint64_t)v161)
    sub_1002EAEB0();
  v23 = *(_QWORD *)(*(_QWORD *)buf + (((unint64_t)v161 >> 3) & 0x1FFFFFF8));
  operator delete(*(void **)buf);
  if (((v23 >> v161) & 1) == 0)
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E498);
    v39 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 67174657;
      *(_DWORD *)&buf[4] = v161;
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEBUG, "Model Type %{private}d disabled in settings", buf, 8u);
    }
    if (sub_1001BFF7C(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E498);
      LODWORD(__p) = 67174657;
      HIDWORD(__p) = v161;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 2, "Model Type %{private}d disabled in settings", &__p, 8);
      v16 = (uint8_t *)v40;
      sub_100512490("Generic", 1, 0, 2, "void CLMicroLocationLearner::learnFromModelType(CLMicroLocationLearner::ShouldCancelFunction, CLMicroLocationProto::Model::ModelType)", "%s\n", v40);
      goto LABEL_67;
    }
    return;
  }
  sub_100014604(v127[1]);
  if (sub_1000A1914(v127[1]))
  {
    Current = j__CFAbsoluteTimeGetCurrent();
    sub_100197040();
    if (!sub_10075D288())
      goto LABEL_43;
    sub_1001E4804(buf);
    LOBYTE(__p) = 0;
    v25 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsEnableSamplingForLearningAnalyticsOnInternal", 0x8000100u, kCFAllocatorNull);
    v26 = sub_1001E48E4(*(uint64_t *)buf, (uint64_t)v25, (BOOL *)&__p);
    CFRelease(v25);
    v27 = __p;
    v28 = *(std::__shared_weak_count **)v186;
    if (*(_QWORD *)v186)
    {
      v29 = (unint64_t *)(*(_QWORD *)v186 + 8);
      do
        v30 = __ldaxr(v29);
      while (__stlxr(v30 - 1, v29));
      if (!v30)
      {
        ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
        std::__shared_weak_count::__release_weak(v28);
      }
    }
    v31 = v27 ? v26 : 0;
    if (v31 != 1)
    {
      v38 = 1;
    }
    else
    {
LABEL_43:
      sub_1001E4804(buf);
      __p = 0;
      v32 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsSamplingRateForLearningAnalytics", 0x8000100u, kCFAllocatorNull);
      v33 = sub_1001FD9FC(*(uint64_t *)buf, (uint64_t)v32, &__p);
      CFRelease(v32);
      v34 = *(double *)&__p;
      v35 = *(std::__shared_weak_count **)v186;
      if (*(_QWORD *)v186)
      {
        v36 = (unint64_t *)(*(_QWORD *)v186 + 8);
        do
          v37 = __ldaxr(v36);
        while (__stlxr(v37 - 1, v36));
        if (!v37)
        {
          ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
          std::__shared_weak_count::__release_weak(v35);
        }
      }
      if (!v33)
        v34 = 0.1;
      v38 = (double)arc4random_uniform(0xF4241u) / 1000000.0 <= v34;
    }
    v160 = 0;
    sub_1001E4804(buf);
    LOBYTE(__p) = 0;
    v43 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsAnalyticsSendEventEnabled", 0x8000100u, kCFAllocatorNull);
    v44 = sub_1001E48E4(*(uint64_t *)buf, (uint64_t)v43, (BOOL *)&__p);
    CFRelease(v43);
    v45 = __p;
    v46 = *(std::__shared_weak_count **)v186;
    if (*(_QWORD *)v186)
    {
      v47 = (unint64_t *)(*(_QWORD *)v186 + 8);
      do
        v48 = __ldaxr(v47);
      while (__stlxr(v48 - 1, v47));
      if (!v48)
      {
        ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
        std::__shared_weak_count::__release_weak(v46);
      }
    }
    v49 = v44 ^ 1;
    if (v45)
      v49 = 1;
    v160 = v49;
    v50 = v38 & v49;
    v159 = v38 & v49;
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E498);
    v51 = (uint64_t)v127;
    v52 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
    {
      sub_10035A2D8((void *)v161, (uint64_t)&__p);
      v53 = v183 >= 0 ? &__p : (void **)__p;
      *(_DWORD *)buf = 68289538;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)v186 = 2082;
      *(_QWORD *)&v186[2] = "";
      *(_WORD *)&v186[10] = 2082;
      *(_QWORD *)&v186[12] = v53;
      *(_WORD *)&v186[20] = 1026;
      *(_DWORD *)&v186[22] = v50;
      _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"Analytics events for learning\", \"model type\":%{public, location:escape_only}s, \"enabled\":%{public}hhd}", buf, 0x22u);
      if (v183 < 0)
        operator delete(__p);
    }
    sub_1003200B4(v161, (char **)&v157);
    if (v157 == v158)
    {
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E498);
      v59 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67240192;
        *(_DWORD *)&buf[4] = v161;
        _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "#Warning No recording events for model type %{public}d", buf, 8u);
      }
      if (sub_1001BFF7C(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212E498);
        LODWORD(__p) = 67240192;
        HIDWORD(__p) = v161;
        _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#Warning No recording events for model type %{public}d", &__p, 8);
        v61 = (uint8_t *)v60;
        sub_100512490("Generic", 1, 0, 2, "void CLMicroLocationLearner::learnFromModelType(CLMicroLocationLearner::ShouldCancelFunction, CLMicroLocationProto::Model::ModelType)", "%s\n", v60);
        if (v61 != buf)
          free(v61);
      }
      goto LABEL_253;
    }
    LOBYTE(__p) = 0;
    v184 = 0;
    v180[0] = 0;
    v180[112] = 0;
    LOBYTE(v155) = 0;
    v156 = 0;
    memset(v153, 0, sizeof(v153));
    v154 = 1065353216;
    v152[0] = v127;
    v152[1] = &v161;
    v152[2] = &v160;
    v152[3] = &__p;
    v152[4] = v180;
    v152[5] = &v155;
    if (v161 == 2)
    {
      sub_1002F92FC((uint64_t)v127, 4u, 0, (uint64_t *)&v150);
      if (v150 == v151)
      {
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212E498);
        v118 = qword_1022A00F8;
        if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 68289026;
          *(_DWORD *)&buf[4] = 0;
          *(_WORD *)v186 = 2082;
          *(_QWORD *)&v186[2] = "";
          _os_log_impl((void *)&_mh_execute_header, v118, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"skipping Location Similarity List model learning, no such clients\"}", buf, 0x12u);
        }
      }
      else
      {
        sub_10027FDF0(v127[1], &v145);
        buf[0] = 0;
        v186[16] = 0;
        v122 = sub_1002E6E88(v50, (void *)v161, (const std::string *)buf);
        if (v186[16] && (v186[15] & 0x80000000) != 0)
          operator delete(*(void **)buf);
        v64 = v145;
        v63 = v146;
        if (v145 != v146)
        {
          v121 = v146;
          do
          {
            v123 = (uint64_t *)(v64 + 40);
            v126 = sub_10033DA3C((uint64_t *)(v64 + 40));
            if (v65)
            {
              v142 = 0;
              v143 = 0;
              v141 = 0;
              sub_10027205C(&v141, v157, (uint64_t)v158, (v158 - (_BYTE *)v157) >> 2);
              sub_1002F8298((uint64_t)v127, (uint64_t)&v141, *(_QWORD *)(v64 + 24), *(_QWORD *)(v64 + 32), (uint64_t)v144);
              if (v141)
              {
                v142 = v141;
                operator delete(v141);
              }
              sub_1002F5B3C((uint64_t)v127, (__int128 *)(v64 + 24), (uint64_t)v140);
              if (qword_1022A00F0 != -1)
                dispatch_once(&qword_1022A00F0, &stru_10212E498);
              v66 = qword_1022A00F8;
              if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
              {
                v67 = (char *)operator new(0x28uLL);
                *(_QWORD *)v168 = v67;
                *(_OWORD *)v169 = xmmword_101B97FF0;
                *(_OWORD *)v67 = 0u;
                *((_OWORD *)v67 + 1) = 0u;
                *(_QWORD *)(v67 + 29) = 0;
                sub_100261F9C(v64 + 24, v67);
                v68 = v169[15] >= 0 ? v168 : *(uint8_t **)v168;
                *(_DWORD *)buf = 68289282;
                *(_DWORD *)&buf[4] = 0;
                *(_WORD *)v186 = 2082;
                *(_QWORD *)&v186[2] = "";
                *(_WORD *)&v186[10] = 2082;
                *(_QWORD *)&v186[12] = v68;
                _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"learning internal model for LOI\", \"loiGroupId\":%{public, location:escape_only}s}", buf, 0x1Cu);
                if ((v169[15] & 0x80000000) != 0)
                  operator delete(*(void **)v168);
              }
              v168[0] = 0;
              v179 = 0;
              sub_1002F9B1C((uint64_t)v127, v122, (uint64_t)v144, a2, (uint64_t)v153, v64 + 24, (uint64_t)v168, (uint64_t)buf, Current, v161);
              sub_1002708A4((uint64_t)v168);
              if (v192 && sub_1002EFEB8((uint64_t)buf))
              {
                if (!v192)
                  sub_10028DF3C();
                LOBYTE(v136) = 0;
                v139 = 0;
                sub_1001E4804(v168);
                LOBYTE(v164) = 0;
                v69 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsClusterAnchorValueStatisticsEnabled", 0x8000100u, v6);
                v70 = sub_1001E48E4(*(uint64_t *)v168, (uint64_t)v69, (BOOL *)&v164);
                CFRelease(v69);
                v71 = v164;
                v72 = *(std::__shared_weak_count **)v169;
                if (*(_QWORD *)v169)
                {
                  v73 = (unint64_t *)(*(_QWORD *)v169 + 8);
                  do
                    v74 = __ldaxr(v73);
                  while (__stlxr(v74 - 1, v73));
                  if (!v74)
                  {
                    ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
                    std::__shared_weak_count::__release_weak(v72);
                  }
                }
                if (v71)
                  v75 = 0;
                else
                  v75 = v70;
                if ((v75 & 1) == 0)
                  sub_1002FB9A4((uint64_t)&v136);
                v125 = v151;
                v76 = v122;
                if (v150 != v151)
                {
                  v77 = v150 + 3;
                  do
                  {
                    v78 = sub_100346FF8((unint64_t)v77[3]);
                    if (v126 >= 0x20)
                      sub_100263950("bitset test argument out of range");
                    if ((v78 & (1 << v126)) != 0)
                    {
                      if (qword_1022A00F0 != -1)
                        dispatch_once(&qword_1022A00F0, &stru_10212E498);
                      v79 = v77 - 3;
                      v80 = qword_1022A00F8;
                      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
                      {
                        v81 = v77 - 3;
                        if (*((char *)v77 - 1) < 0)
                          v81 = (void **)*v79;
                        v82 = v77;
                        if (*((char *)v77 + 23) < 0)
                          v82 = *v77;
                        v83 = operator new(0x28uLL);
                        v164 = v83;
                        v165 = xmmword_101B97FF0;
                        *v83 = 0u;
                        v83[1] = 0u;
                        *(_QWORD *)((char *)v83 + 29) = 0;
                        sub_100261F9C(v64 + 24, v83);
                        v84 = &v164;
                        if (v165 < 0)
                          v84 = v164;
                        v76 = v122;
                        v85 = v64 + 40;
                        if (*(char *)(v64 + 63) < 0)
                          v85 = *v123;
                        *(_DWORD *)v168 = 68290050;
                        *(_DWORD *)&v168[4] = 0;
                        *(_WORD *)v169 = 2082;
                        *(_QWORD *)&v169[2] = "";
                        *(_WORD *)&v169[10] = 2082;
                        *(_QWORD *)&v169[12] = v81;
                        v170 = 2082;
                        v171 = v82;
                        v172 = 2082;
                        v173 = v84;
                        v174 = 2082;
                        v175 = v85;
                        _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"learning a Location Similarity List model for client\", \"ClientId\":%{public, location:escape_only}s, \"ClientIdAndServiceUuid\":%{public, location:escape_only}s, \"loiGroupId\":%{public, location:escape_only}s, \"loiType\":%{public, location:escape_only}s}", v168, 0x3Au);
                        if (SHIBYTE(v165) < 0)
                          operator delete(v164);
                        v51 = (uint64_t)v127;
                      }
                      if (v76)
                      {
                        v86 = +[NSMutableDictionary dictionaryWithDictionary:](NSMutableDictionary, "dictionaryWithDictionary:", v76);
                        v87 = v77 - 3;
                        if (*((char *)v77 - 1) < 0)
                          v87 = (void **)*v79;
                        -[NSMutableDictionary setObject:forKeyedSubscript:](v86, "setObject:forKeyedSubscript:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v87), CFSTR("clientIdentifier"));
                      }
                      else
                      {
                        v86 = 0;
                      }
                      v88 = *(_QWORD *)(v51 + 8);
                      if (*((char *)v77 + 23) < 0)
                      {
                        sub_100115CE4(__dst, *v77, (unint64_t)v77[1]);
                      }
                      else
                      {
                        v89 = *(_OWORD *)v77;
                        v134 = v77[2];
                        *(_OWORD *)__dst = v89;
                      }
                      v135 = 1;
                      v166 = *(_OWORD *)(v64 + 24);
                      v167 = 1;
                      sub_10027FA60(v88, 2u, (__int128 *)__dst, &v166, v168);
                      if (v135 && SHIBYTE(v134) < 0)
                        operator delete(__dst[0]);
                      LOBYTE(v130) = 0;
                      v132 = 0;
                      if (v179)
                      {
                        v130 = v177 | ((unint64_t)v176 << 32);
                        v131 = *(_QWORD *)&v169[8];
                        v132 = 1;
                      }
                      sub_10027380C((uint64_t)v168);
                      memset(v129, 0, sizeof(v129));
                      sub_10027205C(v129, v157, (uint64_t)v158, (v158 - (_BYTE *)v157) >> 2);
                      sub_1002FB9E8(v51, Current, (uint64_t)v86, a2, (uint64_t)(v77 - 3), (uint64_t)buf, (uint64_t *)(v64 + 24), (uint64_t)v129);
                    }
                    v90 = v77 + 4;
                    v77 += 7;
                  }
                  while (v90 != v125);
                }
                if (v139)
                  sub_100300B8C((uint64_t)&v136);
                v63 = v121;
                v6 = kCFAllocatorNull;
              }
              else
              {
                if (qword_1022A00F0 != -1)
                  dispatch_once(&qword_1022A00F0, &stru_10212E498);
                v91 = qword_1022A00F8;
                if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)v168 = 68289026;
                  *(_DWORD *)&v168[4] = 0;
                  *(_WORD *)v169 = 2082;
                  *(_QWORD *)&v169[2] = "";
                  _os_log_impl((void *)&_mh_execute_header, v91, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Similarity List Model Learning, unsupervised model not created or is invalid so learning is skipped\"}", v168, 0x12u);
                }
              }
              sub_100300C00((uint64_t)buf);
              sub_100067AC4((uint64_t)v140);
              *(_QWORD *)buf = v144;
              sub_100270C6C((void ***)buf);
            }
            else
            {
              if (qword_1022A00F0 != -1)
                dispatch_once(&qword_1022A00F0, &stru_10212E498);
              v92 = qword_1022A00F8;
              if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
              {
                v93 = (char *)operator new(0x28uLL);
                *(_QWORD *)v168 = v93;
                *(_OWORD *)v169 = xmmword_101B97FF0;
                *(_OWORD *)v93 = 0u;
                *((_OWORD *)v93 + 1) = 0u;
                *(_QWORD *)(v93 + 29) = 0;
                sub_100261F9C(v64 + 24, v93);
                if (v169[15] >= 0)
                  v94 = (const __CFArray *)v168;
                else
                  v94 = *(const __CFArray **)v168;
                v95 = v64 + 40;
                if (*(char *)(v64 + 63) < 0)
                  v95 = *v123;
                *(_DWORD *)buf = 68289538;
                *(_DWORD *)&buf[4] = 0;
                *(_WORD *)v186 = 2082;
                *(_QWORD *)&v186[2] = "";
                *(_WORD *)&v186[10] = 2082;
                *(_QWORD *)&v186[12] = v94;
                *(_WORD *)&v186[20] = 2082;
                *(_QWORD *)&v186[22] = v95;
                _os_log_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"skipping Location Similarity List model learning because of LOI\", \"loiGroupId\":%{public, location:escape_only}s, \"loiType\":%{public, location:escape_only}s}", buf, 0x26u);
                if ((v169[15] & 0x80000000) != 0)
                  operator delete(*(void **)v168);
              }
            }
            v64 += 64;
          }
          while (v64 != v63);
        }
        *(_QWORD *)buf = &v145;
        sub_10028E258((void ***)buf);
      }
      v62 = (uint8_t *)&v150;
    }
    else
    {
      if (v161 != 1)
      {
        if (v161)
        {
          if (qword_1022A00F0 != -1)
            dispatch_once(&qword_1022A00F0, &stru_10212E498);
          v96 = qword_1022A00F8;
          if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 68289282;
            *(_DWORD *)&buf[4] = 0;
            *(_WORD *)v186 = 2082;
            *(_QWORD *)&v186[2] = "";
            *(_WORD *)&v186[10] = 2050;
            *(_QWORD *)&v186[12] = v161;
            _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"invalid model type\", \"model type\":%{public}lu}", buf, 0x1Cu);
            if (qword_1022A00F0 != -1)
              dispatch_once(&qword_1022A00F0, &stru_10212E498);
          }
          v97 = qword_1022A00F8;
          if (os_signpost_enabled((os_log_t)qword_1022A00F8))
          {
            *(_DWORD *)buf = 68289282;
            *(_DWORD *)&buf[4] = 0;
            *(_WORD *)v186 = 2082;
            *(_QWORD *)&v186[2] = "";
            *(_WORD *)&v186[10] = 2050;
            *(_QWORD *)&v186[12] = v161;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v97, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "invalid model type", "{\"msg%{public}.0s\":\"invalid model type\", \"model type\":%{public}lu}", buf, 0x1Cu);
          }
        }
        else
        {
          sub_10027FDF0(v127[1], (uint64_t *)v162);
          sub_100284B6C(v127[1], 1u, v140);
          v54 = (uint64_t *)&v137;
          v137 = 0;
          v138 = 0;
          v136 = (uint64_t *)&v137;
          v56 = (_QWORD **)v140[0];
          v55 = (_QWORD **)v140[1];
          while (v56 != v55)
          {
            v58 = *v56;
            v57 = (uint64_t)(v56 + 4);
            sub_100347160(v58, v57, buf);
            sub_10019C3A8(&v136, (const void **)buf, (uint64_t)buf);
            if ((v186[15] & 0x80000000) != 0)
              operator delete(*(void **)buf);
            v56 = (_QWORD **)(v57 + 56);
          }
          if (qword_1022A00F0 != -1)
            dispatch_once(&qword_1022A00F0, &stru_10212E498);
          v98 = qword_1022A00F8;
          if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 68289282;
            *(_DWORD *)&buf[4] = 0;
            *(_WORD *)v186 = 2082;
            *(_QWORD *)&v186[2] = "";
            *(_WORD *)&v186[10] = 2050;
            *(_QWORD *)&v186[12] = v138;
            _os_log_impl((void *)&_mh_execute_header, v98, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"Learning Unsupervised Model for clients\", \"Num Clients\":%{public}lu}", buf, 0x1Cu);
          }
          v99 = *(_QWORD *)v162;
          v100 = v163;
          if (*(void **)v162 != v163)
          {
            v124 = v163;
            do
            {
              v101 = (void ***)(v99 + 40);
              v102 = sub_10033DA3C((uint64_t *)(v99 + 40));
              if (v103)
                v104 = v102 == 0;
              else
                v104 = 0;
              if (v104)
              {
                v148 = 0;
                v149 = 0;
                v147 = 0;
                sub_10027205C(&v147, v157, (uint64_t)v158, (v158 - (_BYTE *)v157) >> 2);
                sub_1002F8298((uint64_t)v127, (uint64_t)&v147, *(_QWORD *)(v99 + 24), *(_QWORD *)(v99 + 32), (uint64_t)&v150);
                if (v147)
                {
                  v148 = v147;
                  operator delete(v147);
                }
                sub_1002F5B3C((uint64_t)v127, (__int128 *)(v99 + 24), (uint64_t)&v164);
                v108 = v136;
                if (v136 != v54)
                {
                  do
                  {
                    buf[0] = 0;
                    v186[16] = 0;
                    v109 = sub_1002E6E88(v159, (void *)v161, (const std::string *)buf);
                    if (v186[16] && (v186[15] & 0x80000000) != 0)
                      operator delete(*(void **)buf);
                    if (qword_1022A00F0 != -1)
                      dispatch_once(&qword_1022A00F0, &stru_10212E498);
                    v110 = qword_1022A00F8;
                    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
                    {
                      v111 = v54;
                      v112 = v108 + 4;
                      if (*((char *)v108 + 55) < 0)
                        v112 = (uint64_t *)v108[4];
                      v113 = (char *)operator new(0x28uLL);
                      *(_QWORD *)v168 = v113;
                      *(_OWORD *)v169 = xmmword_101B97FF0;
                      *(_OWORD *)v113 = 0u;
                      *((_OWORD *)v113 + 1) = 0u;
                      *(_QWORD *)(v113 + 29) = 0;
                      sub_100261F9C(v99 + 24, v113);
                      v114 = (const __CFArray *)v168;
                      if (v169[15] < 0)
                        v114 = *(const __CFArray **)v168;
                      v115 = (void **)(v99 + 40);
                      if (*(char *)(v99 + 63) < 0)
                        v115 = *v101;
                      *(_DWORD *)buf = 68289794;
                      *(_DWORD *)&buf[4] = 0;
                      *(_WORD *)v186 = 2082;
                      *(_QWORD *)&v186[2] = "";
                      *(_WORD *)&v186[10] = 2082;
                      *(_QWORD *)&v186[12] = v112;
                      *(_WORD *)&v186[20] = 2082;
                      *(_QWORD *)&v186[22] = v114;
                      *(_WORD *)&v186[30] = 2082;
                      v187 = v115;
                      _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Learning Unsupervised Model for client\", \"Client ID\":%{public, location:escape_only}s, \"loiGroupId\":%{public, location:escape_only}s, \"loiType\":%{public, location:escape_only}s}", buf, 0x30u);
                      if ((v169[15] & 0x80000000) != 0)
                        operator delete(*(void **)v168);
                      v54 = v111;
                    }
                    sub_1002F83B4((uint64_t)v127, (uint64_t)(v108 + 4), *(_QWORD *)(v99 + 24), *(_QWORD *)(v99 + 32), (uint64_t)buf);
                    sub_1002F84E4((uint64_t)v127, v109, (uint64_t)&v150, a2, (uint64_t)v153, (uint64_t)(v108 + 4), v99 + 24, v168, (uint64_t)buf);
                    if (v179)
                    {
                      v178 = *(_OWORD *)(v99 + 24);
                      sub_1002F89B8((uint64_t)&__p, (uint64_t)v168);
                      sub_10027380C((uint64_t)v168);
                    }
                    if (v109)
                    {
                      v155 = v109;
                      v156 = 1;
                    }
                    sub_1002F89FC((uint64_t)v152);
                    sub_1002708A4((uint64_t)v168);
                    sub_1002708A4((uint64_t)buf);
                    v116 = (uint64_t *)v108[1];
                    if (v116)
                    {
                      do
                      {
                        v117 = v116;
                        v116 = (uint64_t *)*v116;
                      }
                      while (v116);
                    }
                    else
                    {
                      do
                      {
                        v117 = (uint64_t *)v108[2];
                        v104 = *v117 == (_QWORD)v108;
                        v108 = v117;
                      }
                      while (!v104);
                    }
                    v108 = v117;
                  }
                  while (v117 != v54);
                }
                sub_100067AC4((uint64_t)&v164);
                *(_QWORD *)buf = &v150;
                sub_100270C6C((void ***)buf);
                v100 = v124;
              }
              else
              {
                if (qword_1022A00F0 != -1)
                  dispatch_once(&qword_1022A00F0, &stru_10212E498);
                v105 = qword_1022A00F8;
                if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
                {
                  v106 = (char *)operator new(0x28uLL);
                  *(_QWORD *)v168 = v106;
                  *(_OWORD *)v169 = xmmword_101B97FF0;
                  *(_OWORD *)v106 = 0u;
                  *((_OWORD *)v106 + 1) = 0u;
                  *(_QWORD *)(v106 + 29) = 0;
                  sub_100261F9C(v99 + 24, v106);
                  v107 = (const __CFArray *)v168;
                  if (v169[15] < 0)
                    v107 = *(const __CFArray **)v168;
                  if (*(char *)(v99 + 63) < 0)
                    v101 = (void ***)*v101;
                  *(_DWORD *)buf = 68289538;
                  *(_DWORD *)&buf[4] = 0;
                  *(_WORD *)v186 = 2082;
                  *(_QWORD *)&v186[2] = "";
                  *(_WORD *)&v186[10] = 2082;
                  *(_QWORD *)&v186[12] = v107;
                  *(_WORD *)&v186[20] = 2082;
                  *(_QWORD *)&v186[22] = v101;
                  _os_log_impl((void *)&_mh_execute_header, v105, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"skipping Location Unsupervised model learning because of LOI\", \"loiGroupId\":%{public, location:escape_only}s, \"loiType\":%{public, location:escape_only}s}", buf, 0x26u);
                  if ((v169[15] & 0x80000000) != 0)
                    operator delete(*(void **)v168);
                }
              }
              v99 += 64;
            }
            while ((void *)v99 != v100);
          }
          sub_100090AE4((uint64_t)&v136, v137);
          *(_QWORD *)buf = v140;
          sub_100302A1C((void ***)buf);
          *(_QWORD *)buf = v162;
          sub_10028E258((void ***)buf);
        }
        goto LABEL_252;
      }
      sub_1002F92FC((uint64_t)v127, 3u, 1, (uint64_t *)v168);
      sub_1002F92FC((uint64_t)v127, 2u, 1, (uint64_t *)&v164);
      sub_10027FDF0(v127[1], (uint64_t *)v162);
      *(_QWORD *)buf = v127;
      *(_QWORD *)v186 = v152;
      *(_QWORD *)&v186[8] = &v161;
      *(_QWORD *)&v186[16] = &v159;
      *(_QWORD *)&v186[24] = &v155;
      v187 = &v157;
      v188 = a2;
      v189 = v153;
      p_p = &__p;
      v191 = v162;
      sub_1002F9620((uint64_t)buf, (uint64_t *)v168, 3u);
      sub_1002F9620((uint64_t)buf, (uint64_t *)&v164, 4u);
      *(_QWORD *)buf = v162;
      sub_10028E258((void ***)buf);
      *(_QWORD *)buf = &v164;
      sub_100302AE4((void ***)buf);
      v62 = v168;
    }
    *(_QWORD *)buf = v62;
    sub_100302AE4((void ***)buf);
LABEL_252:
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)*v127 + 32))(*v127, v161);
    sub_100300C78((uint64_t)v153);
    sub_1002FFD68((uint64_t)v180);
    sub_1002708A4((uint64_t)&__p);
LABEL_253:
    v119 = j__CFAbsoluteTimeGetCurrent();
    if (qword_1022A0100 != -1)
      dispatch_once(&qword_1022A0100, &stru_10212E4B8);
    v120 = qword_1022A0108;
    if (os_log_type_enabled((os_log_t)qword_1022A0108, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289538;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)v186 = 2082;
      *(_QWORD *)&v186[2] = "";
      *(_WORD *)&v186[10] = 2050;
      *(_QWORD *)&v186[12] = v161;
      *(_WORD *)&v186[20] = 2050;
      *(double *)&v186[22] = v119 - Current;
      _os_log_impl((void *)&_mh_execute_header, v120, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Learning, completed\", \"model-type\":%{public}lu, \"Total Time (sec)\":\"%{public}.4f\"}", buf, 0x26u);
    }
    if (v157)
    {
      v158 = v157;
      operator delete(v157);
    }
    return;
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E498);
  v41 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#Warning Tried to run learning, but database is not valid", buf, 2u);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E498);
    LOWORD(__p) = 0;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#Warning Tried to run learning, but database is not valid", &__p, 2);
    v16 = (uint8_t *)v42;
    sub_100512490("Generic", 1, 0, 2, "void CLMicroLocationLearner::learnFromModelType(CLMicroLocationLearner::ShouldCancelFunction, CLMicroLocationProto::Model::ModelType)", "%s\n", v42);
    goto LABEL_67;
  }
}

void sub_1002F7EB0(_Unwind_Exception *a1)
{
  void *v2;

  v2 = (void *)STACK[0x290];
  if (STACK[0x290])
  {
    STACK[0x298] = (unint64_t)v2;
    operator delete(v2);
  }
  _Unwind_Resume(a1);
}

_BYTE *sub_1002F822C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  char *v4;

  v4 = (char *)operator new(0x28uLL);
  *(_QWORD *)a2 = v4;
  *(_OWORD *)(a2 + 8) = xmmword_101B97FF0;
  *(_OWORD *)v4 = 0u;
  *((_OWORD *)v4 + 1) = 0u;
  *(_QWORD *)(v4 + 29) = 0;
  return sub_100261F9C(a1, v4);
}

void sub_1002F827C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void sub_1002F8298(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v8;
  uint64_t v9;
  __int128 *v10;
  __int128 *v11;
  __int128 **v12;
  __int128 v13;
  char v14;
  __int128 v15;
  char v16;
  __int128 v17;

  *(_QWORD *)&v17 = a3;
  *((_QWORD *)&v17 + 1) = a4;
  v8 = *(_QWORD *)(a1 + 8);
  v15 = v17;
  v16 = 1;
  sub_1002FF904(v8, a2, &v15, (_QWORD *)a5);
  if (v17 != 0)
  {
    v9 = *(_QWORD *)(a1 + 8);
    v13 = 0uLL;
    v14 = 1;
    sub_1002FF904(v9, a2, &v13, &v10);
    sub_1003087F4((uint64_t *)a5, *(__int128 **)(a5 + 8), v10, v11, 0xEEEEEEEEEEEEEEEFLL * (v11 - v10));
    v12 = &v10;
    sub_100270C6C((void ***)&v12);
  }
}

void sub_1002F837C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, void ***a13)
{
  a13 = &a10;
  sub_100270C6C((void ***)&a13);
  sub_100270C6C(&a10);
  _Unwind_Resume(a1);
}

void sub_1002F83B4(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  _BYTE v10[288];

  sub_10027F73C(*(_QWORD *)(a1 + 8), a2, a3, a4, (_BYTE *)a5);
  if (!*(_BYTE *)(a5 + 280))
  {
    sub_10027F73C(*(_QWORD *)(a1 + 8), a2, 0, 0, v10);
    sub_100300D1C(a5, (uint64_t)v10);
    sub_1002708A4((uint64_t)v10);
    if (*(_BYTE *)(a5 + 280))
    {
      *(_QWORD *)(a5 + 264) = a3;
      *(_QWORD *)(a5 + 272) = a4;
    }
    else
    {
      sub_10027F418(*(_QWORD *)(a1 + 8), 0, a3, a4, v10);
      sub_100300D1C(a5, (uint64_t)v10);
      sub_1002708A4((uint64_t)v10);
      if (*(_BYTE *)(a5 + 280))
      {
        if (*(_BYTE *)(a5 + 256))
          sub_10027380C(a5);
      }
    }
  }
}

void sub_1002F84B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  sub_1002708A4((uint64_t)va);
  sub_1002708A4(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_1002F84E4@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X7>, _BYTE *a8@<X8>, uint64_t a9)
{
  double Current;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  NSObject *v26;
  const char *v27;
  uint8_t *v28;
  void *__dst[2];
  uint64_t v31;
  char v32;
  int v33;
  _BYTE v34[4];
  int v35;
  uint64_t v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  char v46;
  uint8_t buf[4];
  int v48;
  __int16 v49;
  const char *v50;
  __int16 v51;
  uint64_t v52;
  __int16 v53;
  uint64_t v54;
  __int16 v55;
  uint64_t v56;
  __int16 v57;
  int v58;
  __int16 v59;
  uint64_t v60;
  __int16 v61;
  int v62;
  __int16 v63;
  int v64;
  __int16 v65;
  int v66;
  __int16 v67;
  int v68;
  __int16 v69;
  int v70;
  __int16 v71;
  int v72;
  __int16 v73;
  int v74;
  void *__p;
  char v76;
  char v77;
  _DWORD v78[50];

  *a8 = 0;
  a8[280] = 0;
  Current = j__CFAbsoluteTimeGetCurrent();
  sub_1002F9B1C(a1, a2, a3, a4, a5, a7, a9, (uint64_t)v34, Current, 0);
  if (v46 && sub_1002EFEB8((uint64_t)v34))
  {
    if (qword_1022A0100 != -1)
      dispatch_once(&qword_1022A0100, &stru_10212E4B8);
    v18 = qword_1022A0108;
    if (os_log_type_enabled((os_log_t)qword_1022A0108, OS_LOG_TYPE_DEFAULT))
    {
      v19 = sub_1002EECE0((uint64_t)v34);
      v21 = v44;
      v20 = v45;
      v22 = sub_1002ED634((uint64_t)v34);
      *(_DWORD *)buf = 68292098;
      v48 = 0;
      v49 = 2082;
      v50 = "";
      v51 = 2050;
      v52 = v19;
      v53 = 2050;
      v54 = (v20 - v21) >> 5;
      v55 = 2050;
      v56 = v22;
      v57 = 1026;
      v58 = v35;
      v59 = 2050;
      v60 = v36;
      v61 = 1026;
      v62 = v37;
      v63 = 1026;
      v64 = v38;
      v65 = 1026;
      v66 = v40;
      v67 = 1026;
      v68 = v39;
      v69 = 1026;
      v70 = v41;
      v71 = 1026;
      v72 = v42;
      v73 = 1026;
      v74 = v43;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Microlocation model learned\", \"numFingerprints before pruning\":%{public}lu, \"numFingerprints after pruning\":%{public}lu, \"numClusters\":%{public}lu, \"type\":%{public}d, \"numAnchors\":%{public}lu, \"Number of Recording triggers at current LOI\":%{public}u, \"Number of Input Valid Fingerprints\":%{public}u, \"Number of Input Valid Fingerprints Labeled\":%{public}u, \"Number of Input Valid Fingerprints Unlabeled\":%{public}u, \"Number of WiFi Access Points\":%{public}u, \"Number of Ble Sources\":%{public}u, \"Number of Uwb Sources\":%{public}u}", buf, 0x6Au);
    }
    v33 = 0;
    sub_1000B0C3C(&v33);
    v23 = sub_1000B0D38((ssize_t)&v33);
    v25 = v24;
    sub_1002ECF30((uint64_t)v34, (uint64_t)v78);
    if (*(char *)(a6 + 23) < 0)
    {
      sub_100115CE4(__dst, *(void **)a6, *(_QWORD *)(a6 + 8));
    }
    else
    {
      *(_OWORD *)__dst = *(_OWORD *)a6;
      v31 = *(_QWORD *)(a6 + 16);
    }
    v32 = 1;
    sub_1003A828C((uint64_t)buf, v23, v25, (uint64_t)v78, (uint64_t)__dst, 0, 0, Current);
    sub_1002F89B8((uint64_t)a8, (uint64_t)buf);
    if (v77 && v76 < 0)
      operator delete(__p);
    sub_1002C8104((char *)&v54 + 2);
    if (v32 && SHIBYTE(v31) < 0)
      operator delete(__dst[0]);
    sub_1002C8104(v78);
    sub_1000B0D18((unsigned int *)&v33);
  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E498);
    v26 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67240192;
      v48 = v35;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "No models were generated for model type %{public}d", buf, 8u);
    }
    if (sub_1001BFF7C(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E498);
      v78[0] = 67240192;
      v78[1] = v35;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "No models were generated for model type %{public}d", v78, 8);
      v28 = (uint8_t *)v27;
      sub_100512490("Generic", 1, 0, 2, "std::optional<CLMicroLocationModelTable::Entry> CLMicroLocationLearner::learnMagicalMomentsModel(NSMutableDictionary *, std::vector<CLMicroLocationRecordingEventsTable::Entry> &, const CLMicroLocationLearner::ShouldCancelFunction &, const CLMicroLocationAnchorAppearanceMap &, CLMicroLocationFingerprintPool &, const std::string &, const boost::uuids::uuid &, const std::optional<CLMicroLocationModelTable::Entry> &)", "%s\n", v27);
      if (v28 != buf)
        free(v28);
    }
  }
  return sub_100300C00((uint64_t)v34);
}

void sub_1002F8930(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, void *__p, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v8;
  va_list va;

  va_start(va, a8);
  sub_100300C00((uint64_t)va);
  sub_1002708A4(v8);
  _Unwind_Resume(a1);
}

uint64_t sub_1002F89B8(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 280))
  {
    sub_1003A836C(a1, a2);
  }
  else
  {
    sub_1003A8368(a1, a2);
    *(_BYTE *)(a1 + 280) = 1;
  }
  return a1;
}

void sub_1002F89FC(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  char v5;
  NSObject *v6;
  int v7;
  NSObject *v8;
  uint64_t v9;
  char *v10;
  uint8_t *v11;
  uint64_t v12;
  uint64_t v13;
  __int128 *v14;
  char *v15;
  char *v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  int v22;
  NSObject *v23;
  uint64_t v24;
  NSObject *v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  uint64_t v32;
  const char *v33;
  int v34;
  const char *v35;
  uint8_t *v36;
  uint64_t v37;
  uint8_t buf[8];
  _BYTE v39[40];
  int v40;
  _BYTE v41[56];
  uint64_t v42;
  void *__p;
  char v44;
  char v45;
  __int128 v46[84];
  __int128 v47;
  _QWORD v48[2];
  _BYTE v49[24];

  v2 = *(_QWORD **)a1;
  v3 = *(_QWORD *)(a1 + 24);
  if (*(_BYTE *)(v3 + 280))
  {
    v4 = v2[1];
    sub_100300804(buf, (__int128 *)v3);
    v47 = 0uLL;
    v48[0] = 0;
    *(_QWORD *)v49 = &v47;
    v49[8] = 0;
    *(_QWORD *)&v47 = operator new(0x118uLL);
    *((_QWORD *)&v47 + 1) = v47;
    v48[0] = v47 + 280;
    *((_QWORD *)&v47 + 1) = sub_100300880((uint64_t)v48, (__int128 *)buf, v46, (_OWORD *)v47);
    v5 = sub_1003002D8(v4);
    *(_QWORD *)v49 = &v47;
    sub_1003009DC((void ***)v49);
    if (v45 && v44 < 0)
      operator delete(__p);
    sub_1002C8104(&v39[24]);
    if ((v5 & 1) != 0)
    {
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E498);
      v6 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        v7 = **(_DWORD **)(a1 + 8);
        *(_DWORD *)buf = 67240192;
        *(_DWORD *)&buf[4] = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Model generated successfully for type %{public}d", buf, 8u);
      }
      if (sub_1001BFF7C(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212E498);
        v34 = **(_DWORD **)(a1 + 8);
        LODWORD(v47) = 67240192;
        DWORD1(v47) = v34;
        _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "Model generated successfully for type %{public}d", &v47, 8);
        v36 = (uint8_t *)v35;
        sub_100512490("Generic", 1, 0, 2, "auto CLMicroLocationLearner::learnFromModelType(CLMicroLocationLearner::ShouldCancelFunction, CLMicroLocationProto::Model::ModelType)::(anonymous class)::operator()() const", "%s\n", v35);
        if (v36 != buf)
          free(v36);
      }
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E498);
      v8 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        v9 = *(_QWORD *)(a1 + 24);
        if (!*(_BYTE *)(v9 + 280))
          sub_10028DF3C();
        v10 = (char *)operator new(0x28uLL);
        *(_QWORD *)buf = v10;
        *(_OWORD *)v39 = xmmword_101B97FF0;
        *(_OWORD *)v10 = 0u;
        *((_OWORD *)v10 + 1) = 0u;
        *(_QWORD *)(v10 + 29) = 0;
        sub_100261F9C(v9, v10);
        v11 = buf;
        if (v39[15] < 0)
          v11 = *(uint8_t **)buf;
        LODWORD(v47) = 136380675;
        *(_QWORD *)((char *)&v47 + 4) = v11;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "MicroLocation learned model: %{private}s", (uint8_t *)&v47, 0xCu);
        if ((v39[15] & 0x80000000) != 0)
          operator delete(*(void **)buf);
      }
      if (!sub_1001BFF7C(115, 2))
        goto LABEL_35;
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E498);
      v12 = *(_QWORD *)(a1 + 24);
      if (!*(_BYTE *)(v12 + 280))
        sub_10028DF3C();
      v13 = qword_1022A00F8;
      sub_1002F822C(v12, (uint64_t)&v47);
      if (v48[0] >= 0)
        v14 = &v47;
      else
        v14 = (__int128 *)v47;
      *(_DWORD *)v49 = 136380675;
      *(_QWORD *)&v49[4] = v14;
      LODWORD(v37) = 12;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, v13, 0, "MicroLocation learned model: %{private}s", v49, v37);
      v16 = v15;
      if (SHIBYTE(v48[0]) < 0)
        operator delete((void *)v47);
      sub_100512490("Generic", 1, 0, 2, "auto CLMicroLocationLearner::learnFromModelType(CLMicroLocationLearner::ShouldCancelFunction, CLMicroLocationProto::Model::ModelType)::(anonymous class)::operator()() const", "%s\n", v16);
      if (v16 == (char *)buf)
        goto LABEL_35;
LABEL_61:
      free(v16);
      goto LABEL_35;
    }
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E498);
  v17 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67240192;
    *(_DWORD *)&buf[4] = 0;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#Warning Model was not generated properly. Inserted: %{public,BOOL}d", buf, 8u);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E498);
    *(_QWORD *)&v47 = 67240192;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#Warning Model was not generated properly. Inserted: %{public,BOOL}d", &v47, 8);
    v16 = (char *)v33;
    sub_100512490("Generic", 1, 0, 2, "auto CLMicroLocationLearner::learnFromModelType(CLMicroLocationLearner::ShouldCancelFunction, CLMicroLocationProto::Model::ModelType)::(anonymous class)::operator()() const", "%s\n", v33);
    if (v16 != (char *)buf)
      goto LABEL_61;
  }
LABEL_35:
  v18 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v18 + 112))
    goto LABEL_45;
  v19 = v2[1];
  *(_QWORD *)buf = *(_QWORD *)v18;
  if (*(char *)(v18 + 31) < 0)
  {
    sub_100115CE4(v39, *(void **)(v18 + 8), *(_QWORD *)(v18 + 16));
  }
  else
  {
    v20 = *(_OWORD *)(v18 + 8);
    *(_QWORD *)&v39[16] = *(_QWORD *)(v18 + 24);
    *(_OWORD *)v39 = v20;
  }
  v21 = *(_OWORD *)(v18 + 32);
  v40 = *(_DWORD *)(v18 + 48);
  *(_OWORD *)&v39[24] = v21;
  sub_1002E5034(v41, v18 + 56);
  v47 = 0uLL;
  v48[0] = 0;
  *(_QWORD *)v49 = &v47;
  v49[8] = 0;
  *(_QWORD *)&v47 = operator new(0x70uLL);
  *((_QWORD *)&v47 + 1) = v47;
  v48[0] = v47 + 112;
  *((_QWORD *)&v47 + 1) = sub_100300A60((uint64_t)v48, (uint64_t)buf, (uint64_t)&v42, v47);
  v22 = sub_1002FEC74(v19);
  *(_QWORD *)v49 = &v47;
  sub_1002A7CB8((void ***)v49);
  sub_1002E50A8((wireless_diagnostics::google::protobuf::MessageLite *)v41);
  if ((v39[23] & 0x80000000) != 0)
    operator delete(*(void **)v39);
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E498);
  v23 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    v24 = **(unsigned int **)(a1 + 8);
    *(_DWORD *)buf = 68289538;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)v39 = 2082;
    *(_QWORD *)&v39[2] = "";
    *(_WORD *)&v39[10] = 2050;
    *(_QWORD *)&v39[12] = v24;
    *(_WORD *)&v39[20] = 1026;
    *(_DWORD *)&v39[22] = v22;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Configuration generated\", \"ModelType\":%{public}lu, \"Inserted\":%{public}hhd}", buf, 0x22u);
LABEL_45:
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E498);
  }
  v25 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    v26 = **(unsigned __int8 **)(a1 + 16);
    v27 = **(unsigned int **)(a1 + 8);
    v28 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 40) + 8);
    *(_DWORD *)buf = 68289794;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)v39 = 2082;
    *(_QWORD *)&v39[2] = "";
    *(_WORD *)&v39[10] = 1026;
    *(_DWORD *)&v39[12] = v26;
    *(_WORD *)&v39[16] = 2050;
    *(_QWORD *)&v39[18] = v27;
    *(_WORD *)&v39[26] = 2050;
    *(_QWORD *)&v39[28] = v28;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"sending CoreAnalytics com.apple.MicroLocation.ModelLearning\", \"sending enabled\":%{public}hhd, \"model type\":%{public}lu, \"has_value\":%{public}lu}", buf, 0x2Cu);
  }
  if (**(_BYTE **)(a1 + 16))
  {
    v29 = *(_QWORD *)(a1 + 40);
    if (*(_BYTE *)(v29 + 8))
      AnalyticsSendEvent(CFSTR("com.apple.MicroLocation.ModelLearning"), *(_QWORD *)v29);
  }
  v30 = *(uint64_t **)(a1 + 40);
  if (*((_BYTE *)v30 + 8))
    v31 = *v30;
  else
    v31 = 0;
  (*(void (**)(_QWORD, _QWORD, _QWORD, uint64_t))(*(_QWORD *)*v2 + 24))(*v2, **(unsigned int **)(a1 + 8), *(_QWORD *)(a1 + 24), v31);
  sub_10027380C(*(_QWORD *)(a1 + 24));
  sub_1002FFCA4(*(_QWORD *)(a1 + 32));
  v32 = *(_QWORD *)(a1 + 40);
  if (*(_BYTE *)(v32 + 8))
    *(_BYTE *)(v32 + 8) = 0;
}

void sub_1002F9264(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  void *v17;

  operator delete(v17);
  _Unwind_Resume(a1);
}

void sub_1002F92FC(uint64_t a1@<X0>, unsigned int a2@<W1>, char a3@<W2>, uint64_t *a4@<X8>)
{
  unsigned __int16 *v8;
  unsigned __int16 *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unsigned __int16 *v13;
  uint64_t v14;
  int v15;
  _BOOL4 v17;
  char v18;
  __int128 v19;
  uint64_t v20;
  unsigned __int16 *v21;
  void *v22[2];
  uint64_t v23;
  std::string __p;
  uint64_t v25;
  void *__dst[2];
  uint64_t v27;
  std::string v28;
  std::string v29;
  unsigned __int16 *v30;
  unsigned __int16 *v31;
  uint64_t v32;
  uint64_t v33;

  sub_10027F114(*(_QWORD *)(a1 + 8), &v32);
  sub_100284B6C(*(_QWORD *)(a1 + 8), a2, &v30);
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  v8 = v31;
  if (v30 != v31)
  {
    v9 = v30 + 16;
    do
    {
      sub_1002B8598((const void **)v9, (uint64_t)(v9 - 12), &v29);
      v10 = sub_100304CA0(v32, v33, (unsigned __int8 **)&v29);
      v11 = v33;
      v12 = *((char *)v9 + 23);
      if (v12 < 0)
      {
        if (*((_QWORD *)v9 + 1) != 10)
          goto LABEL_12;
        v13 = *(unsigned __int16 **)v9;
      }
      else
      {
        v13 = v9;
        if (v12 != 10)
          goto LABEL_12;
      }
      v14 = *(_QWORD *)v13;
      v15 = v13[4];
      if (v14 == 0x6F6D2D7375636F66 && v15 == 25956)
      {
        v20 = sub_100304CA0(v32, v33, (unsigned __int8 **)v9);
        v17 = v20 != v33;
        goto LABEL_13;
      }
LABEL_12:
      v17 = 0;
LABEL_13:
      if (v10 == v11)
        v18 = a3 ^ 1;
      else
        v18 = 1;
      if ((v18 & 1) != 0 || v17)
      {
        if (*((char *)v9 + 23) < 0)
        {
          sub_100115CE4(__dst, *(void **)v9, *((_QWORD *)v9 + 1));
        }
        else
        {
          v19 = *(_OWORD *)v9;
          v27 = *((_QWORD *)v9 + 2);
          *(_OWORD *)__dst = v19;
        }
        if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0)
          sub_100115CE4(&v28, v29.__r_.__value_.__l.__data_, v29.__r_.__value_.__l.__size_);
        else
          v28 = v29;
        if (SHIBYTE(v27) < 0)
        {
          sub_100115CE4(v22, __dst[0], (unint64_t)__dst[1]);
        }
        else
        {
          *(_OWORD *)v22 = *(_OWORD *)__dst;
          v23 = v27;
        }
        if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0)
          sub_100115CE4(&__p, v28.__r_.__value_.__l.__data_, v28.__r_.__value_.__l.__size_);
        else
          __p = v28;
        v25 = *((_QWORD *)v9 + 3);
        sub_1002FDAE0(a4, (__int128 *)v22);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        if (SHIBYTE(v23) < 0)
          operator delete(v22[0]);
        if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v28.__r_.__value_.__l.__data_);
        if (SHIBYTE(v27) < 0)
          operator delete(__dst[0]);
      }
      if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v29.__r_.__value_.__l.__data_);
      v21 = v9 + 28;
      v9 += 44;
    }
    while (v21 != v8);
  }
  v22[0] = &v30;
  sub_100302A1C((void ***)v22);
  v22[0] = &v32;
  sub_100259608((void ***)v22);
}

void sub_1002F9578(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,char a35)
{
  uint64_t v35;

  __p = (void *)(v35 - 112);
  sub_100259608((void ***)&__p);
  _Unwind_Resume(a1);
}

void sub_1002F9620(uint64_t a1, uint64_t *a2, unsigned int a3)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  NSObject *v14;
  void *v15;
  _QWORD *v16;
  _OWORD *v17;
  void *p_p;
  _QWORD *v19;
  int v20;
  void *v21;
  __int128 v22;
  id v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  NSObject *v28;
  _OWORD *v29;
  void *v30;
  _QWORD *v31;
  uint64_t v33;
  _QWORD *v34;
  uint64_t v35;
  uint64_t v36;
  void *__p;
  __int128 v39;
  _BYTE v40[24];
  _BYTE *v41;
  _BYTE buf[28];
  __int16 v43;
  _QWORD *v44;
  __int16 v45;
  void *v46;
  __int16 v47;
  _QWORD *v48;
  char v49;

  v3 = *(uint64_t **)(a1 + 72);
  v4 = *v3;
  v33 = v3[1];
  if (*v3 != v33)
  {
    v36 = *(_QWORD *)a1;
    do
    {
      v34 = (_QWORD *)(v4 + 40);
      v35 = v4;
      v6 = sub_10033DA3C((uint64_t *)(v4 + 40));
      v7 = v35 + 24;
      if (v8)
      {
        v10 = *a2;
        v9 = a2[1];
        if (*a2 != v9)
        {
          v11 = v6;
          v12 = 1 << v6;
          while (2)
          {
            v13 = sub_100346FF8(*(_QWORD *)(v10 + 48));
            if (v11 > 0x1F)
              sub_100263950("bitset test argument out of range");
            if ((v13 & v12) == 0)
              goto LABEL_37;
            if (qword_1022A00F0 != -1)
              dispatch_once(&qword_1022A00F0, &stru_10212E498);
            v14 = qword_1022A00F8;
            if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
            {
              v15 = (void *)v10;
              if (*(char *)(v10 + 23) < 0)
                v15 = *(void **)v10;
              v16 = (_QWORD *)(v10 + 24);
              if (*(char *)(v10 + 47) < 0)
                v16 = (_QWORD *)*v16;
              v17 = operator new(0x28uLL);
              __p = v17;
              v39 = xmmword_101B97FF0;
              *v17 = 0u;
              v17[1] = 0u;
              *(_QWORD *)((char *)v17 + 29) = 0;
              sub_100261F9C(v7, v17);
              p_p = &__p;
              if (v39 < 0)
                p_p = __p;
              v19 = v34;
              if (*(char *)(v35 + 63) < 0)
                v19 = (_QWORD *)*v34;
              *(_DWORD *)buf = 68290050;
              *(_DWORD *)&buf[4] = 0;
              *(_WORD *)&buf[8] = 2082;
              *(_QWORD *)&buf[10] = "";
              *(_WORD *)&buf[18] = 2082;
              *(_QWORD *)&buf[20] = v15;
              v43 = 2082;
              v44 = v16;
              v45 = 2082;
              v46 = p_p;
              v47 = 2082;
              v48 = v19;
              _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"learning a semi-supervised model for client\", \"ClientId\":%{public, location:escape_only}s, \"ClientIdAndServiceUuid\":%{public, location:escape_only}s, \"loiGroupId\":%{public, location:escape_only}s, \"loiType\":%{public, location:escape_only}s}", buf, 0x3Au);
              if (SHIBYTE(v39) < 0)
                operator delete(__p);
            }
            v20 = **(unsigned __int8 **)(a1 + 24);
            v21 = (void *)**(unsigned int **)(a1 + 16);
            if (*(char *)(v10 + 23) < 0)
            {
              sub_100115CE4(buf, *(void **)v10, *(_QWORD *)(v10 + 8));
            }
            else
            {
              v22 = *(_OWORD *)v10;
              *(_QWORD *)&buf[16] = *(_QWORD *)(v10 + 16);
              *(_OWORD *)buf = v22;
            }
            buf[24] = 1;
            v23 = sub_1002E6E88(v20 != 0, v21, (const std::string *)buf);
            if (buf[24] && (buf[23] & 0x80000000) != 0)
              operator delete(*(void **)buf);
            v24 = *(_QWORD *)(a1 + 40);
            sub_100270E34((uint64_t)v40, *(_QWORD *)(a1 + 48));
            sub_1002FD244(v36, v10, v24, a3, (uint64_t)v40, *(_QWORD *)(a1 + 56), buf, v7);
            v25 = v41;
            if (v41 == v40)
            {
              v25 = v40;
              v26 = 4;
LABEL_31:
              (*(void (**)(void))(*v25 + 8 * v26))();
            }
            else if (v41)
            {
              v26 = 5;
              goto LABEL_31;
            }
            if (v49)
              sub_1002F89B8(*(_QWORD *)(a1 + 64), (uint64_t)buf);
            if (v23)
            {
              v27 = *(_QWORD *)(a1 + 32);
              *(_QWORD *)v27 = v23;
              *(_BYTE *)(v27 + 8) = 1;
            }
            sub_1002F89FC(*(_QWORD *)(a1 + 8));
            sub_1002708A4((uint64_t)buf);
LABEL_37:
            v10 += 56;
            if (v10 == v9)
              break;
            continue;
          }
        }
      }
      else
      {
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212E498);
        v28 = qword_1022A00F8;
        if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
        {
          v29 = operator new(0x28uLL);
          __p = v29;
          v39 = xmmword_101B97FF0;
          *v29 = 0u;
          v29[1] = 0u;
          *(_QWORD *)((char *)v29 + 29) = 0;
          sub_100261F9C(v7, v29);
          v30 = &__p;
          if (v39 < 0)
            v30 = __p;
          v31 = v34;
          if (*(char *)(v35 + 63) < 0)
            v31 = (_QWORD *)*v34;
          *(_DWORD *)buf = 68289538;
          *(_DWORD *)&buf[4] = 0;
          *(_WORD *)&buf[8] = 2082;
          *(_QWORD *)&buf[10] = "";
          *(_WORD *)&buf[18] = 2082;
          *(_QWORD *)&buf[20] = v30;
          v43 = 2082;
          v44 = v31;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"skipping Location semi-supervised model learning because of LOI\", \"loiGroupId\":%{public, location:escape_only}s, \"loiType\":%{public, location:escape_only}s}", buf, 0x26u);
          if (SHIBYTE(v39) < 0)
            operator delete(__p);
        }
      }
      v4 = v35 + 64;
    }
    while (v35 + 64 != v33);
  }
}

void sub_1002F9A90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,char a37)
{
  void *v37;

  operator delete(v37);
  _Unwind_Resume(a1);
}

uint64_t sub_1002F9B1C@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X7>, uint64_t a8@<X8>, double a9@<D0>, int a10)
{
  CFStringRef v13;
  int v14;
  unsigned int v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  CFStringRef v20;
  int v21;
  unsigned int v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t *v28;
  CFStringRef v29;
  int v30;
  uint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  uint64_t v35;
  NSObject *v36;
  unint64_t v37;
  unint64_t v38;
  NSObject *v39;
  unint64_t *v40;
  unint64_t v41;
  uint64_t v42;
  _QWORD *i;
  _QWORD *v44;
  _QWORD *v45;
  unint64_t *v46;
  unint64_t *v47;
  unint64_t *j;
  __int128 v49;
  void **v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  CFStringRef v54;
  int v55;
  unsigned int v56;
  std::__shared_weak_count *v57;
  unint64_t *v58;
  unint64_t v59;
  unsigned int v60;
  uint64_t v61;
  void *v62;
  void *v63;
  unint64_t v64;
  NSObject *v65;
  double v66;
  uint64_t v67;
  _QWORD *v68;
  uint64_t v69;
  uint64_t result;
  const char *v71;
  uint8_t *v72;
  const char *v73;
  uint8_t *v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v83;
  _BYTE v86[16];
  void *v87[2];
  uint64_t v88;
  void **v89;
  char v90;
  unsigned int v91;
  uint64_t v92;
  _DWORD v93[36];
  void *v94;
  int v95;
  uint64_t v96;
  uint64_t v97;
  _QWORD *v98;
  void *v99;
  void *v100;
  void *v101;
  char v102;
  __int128 v103;
  _QWORD v104[4];
  int v105;
  __int128 v106;
  _BYTE v107[128];
  _OWORD v108[2];
  __int128 v109;
  uint64_t v110;
  _QWORD v111[6];
  __int128 __p;
  uint64_t v113;
  __int128 v114;
  uint64_t v115;
  void *v116;
  void *v117;
  uint64_t v118;
  uint64_t v119;
  double v120;
  void *v121;
  void *v122[4];
  int v123;
  _QWORD v124[3];
  _QWORD *v125;
  _BYTE v126[24];
  _QWORD v127[3];
  _QWORD *v128;
  uint8_t buf[32];
  _BYTE v130[14];
  int v131;
  __int128 v132;
  _BYTE v133[128];
  _OWORD v134[2];
  __int128 v135;
  uint64_t v136;
  uint64_t v137[6];
  __int128 v138;
  uint64_t v139;
  __int128 v140;
  uint64_t v141;
  _BYTE v142[16];
  uint64_t v143;
  char v144;

  v120 = a9;
  sub_1001E4804(buf);
  LODWORD(v103) = 0;
  v13 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsLearnerAlgorithm", 0x8000100u, kCFAllocatorNull);
  v14 = sub_1000B1180(*(uint64_t *)buf, (uint64_t)v13, &v103);
  CFRelease(v13);
  v15 = v103;
  v16 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v17 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  if (v14)
    v19 = v15;
  else
    v19 = 0;
  sub_100297C28(v19);
  v77 = a6;
  sub_1001E4804(buf);
  LODWORD(v103) = 0;
  v20 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsNumberOfModelIterations", 0x8000100u, kCFAllocatorNull);
  v21 = sub_1000B1180(*(uint64_t *)buf, (uint64_t)v20, &v103);
  CFRelease(v20);
  v22 = v103;
  v23 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v24 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  if (v21)
    v26 = v22;
  else
    v26 = 3;
  v83 = v26;
  v28 = *(unint64_t **)a3;
  v27 = *(_QWORD *)(a3 + 8);
  sub_1001E4804(buf);
  LODWORD(v103) = 0;
  v29 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsMinimumNumberOfRecordingsInStableModel", 0x8000100u, kCFAllocatorNull);
  v30 = sub_1000B1180(*(uint64_t *)buf, (uint64_t)v29, &v103);
  CFRelease(v29);
  v31 = v103;
  v32 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v33 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }
  v35 = 200;
  if (v30)
    v35 = v31;
  v79 = v35;
  v117 = 0;
  v116 = 0;
  v118 = 0;
  sub_1002FF5A4(&v116, v83);
  if (qword_1022A0100 != -1)
    dispatch_once(&qword_1022A0100, &stru_10212E4B8);
  v36 = qword_1022A0108;
  if (os_log_type_enabled((os_log_t)qword_1022A0108, OS_LOG_TYPE_DEFAULT))
  {
    v37 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 4);
    *(_DWORD *)buf = 68290050;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = "";
    *(_WORD *)&buf[18] = 1026;
    *(_DWORD *)&buf[20] = a10;
    *(_WORD *)&buf[24] = 1026;
    *(_DWORD *)&buf[26] = v19;
    *(_WORD *)&buf[30] = 1026;
    *(_DWORD *)v130 = v83;
    *(_WORD *)&v130[4] = 2050;
    *(_QWORD *)&v130[6] = v37;
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Learning started\", \"modelType\":%{public}d, \"algorithmType\":%{public}d, \"numModelIters\":%{public}d, \"numRecordingTriggers\":%{public}lu}", buf, 0x2Eu);
  }
  sub_1002ECF2C(&v103);
  v78 = 0xEEEEEEEEEEEEEEEFLL * ((v27 - (uint64_t)v28) >> 4);
  v142[0] = 0;
  v144 = 0;
  if (*(_BYTE *)(a7 + 280))
  {
    sub_1002EDC8C(a7 + 32, a5, (uint64_t)buf);
    v103 = *(_OWORD *)buf;
    v105 = v131;
    sub_100270130(v104, *(uint64_t **)v130, 0);
    v106 = v132;
    sub_100300D60((uint64_t)v107, (uint64_t)v133);
    v108[0] = v134[0];
    *(_OWORD *)((char *)v108 + 12) = *(_OWORD *)((char *)v134 + 12);
    sub_100300E80((void **)&v109);
    v109 = v135;
    v110 = v136;
    v136 = 0;
    v135 = 0uLL;
    sub_100300EDC((uint64_t)v111, v137);
    v111[5] = v137[5];
    if ((_QWORD)__p)
    {
      *((_QWORD *)&__p + 1) = __p;
      operator delete((void *)__p);
    }
    __p = v138;
    v113 = v139;
    v139 = 0;
    v138 = 0uLL;
    if (SHIBYTE(v115) < 0)
    {
      operator delete((void *)v114);
      v114 = v140;
      v115 = v141;
      HIBYTE(v141) = 0;
      LOBYTE(v140) = 0;
      if ((_QWORD)v138)
      {
        *((_QWORD *)&v138 + 1) = v138;
        operator delete((void *)v138);
      }
    }
    else
    {
      v115 = v141;
      v114 = v140;
      HIBYTE(v141) = 0;
      LOBYTE(v140) = 0;
    }
    sub_100270738((uint64_t)v137);
    v89 = (void **)&v135;
    sub_1002707B4(&v89);
    sub_100270824((uint64_t)v133);
    sub_100067AC4((uint64_t)&buf[16]);
    if (!sub_1002ED63C((uint64_t)&v103))
    {
      if (v78 >= v79 || (v38 = HIDWORD(v103), sub_1002FF638() - 1 <= v38))
      {
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212E498);
        v39 = qword_1022A00F8;
        if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "got sufficient recording triggers, will ignore prior cluster number in learning", buf, 2u);
        }
        if (sub_1001BFF7C(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1022A00F0 != -1)
            dispatch_once(&qword_1022A00F0, &stru_10212E498);
          LOWORD(v89) = 0;
          _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "got sufficient recording triggers, will ignore prior cluster number in learning", &v89, 2);
          v72 = (uint8_t *)v71;
          sub_100512490("Generic", 1, 0, 2, "std::optional<CLMicroLocationModel> CLMicroLocationLearner::learnMagicalMomentsModelInternal(NSMutableDictionary *, std::vector<CLMicroLocationRecordingEventsTable::Entry> &, const CLMicroLocationLearner::ShouldCancelFunction &, const CLMicroLocationAnchorAppearanceMap &, CLMicroLocationFingerprintPool &, cl::chrono::CFAbsoluteTimeClock::time_point, const boost::uuids::uuid &, const std::optional<CLMicroLocationModelTable::Entry> &, const CLMicroLocationProto::Model::ModelType)", "%s\n", v71);
          if (v72 != buf)
            free(v72);
        }
      }
    }
  }
  v127[0] = off_10212A660;
  v127[1] = sub_10038E2F0;
  v128 = v127;
  sub_1002ECF2C(&v89);
  v40 = *(unint64_t **)(a3 + 8);
  v76 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)v40 - *(_QWORD *)a3) >> 4);
  v41 = 126 - 2 * __clz(v76);
  if (v40 == *(unint64_t **)a3)
    v42 = 0;
  else
    v42 = v41;
  sub_100305854(*(unint64_t **)a3, v40, v42, 1);
  if ((_DWORD)v83)
  {
    if (sub_1002EFEB8((uint64_t)&v89))
    {
      memset(buf, 0, sizeof(buf));
      *(_DWORD *)v130 = 1065353216;
      for (i = v98; i; i = (_QWORD *)*i)
      {
        v45 = (_QWORD *)i[4];
        v44 = (_QWORD *)i[5];
        while (v45 != v44)
        {
          sub_100270E98((uint64_t)buf, v45, v45);
          v45 += 2;
        }
      }
      v47 = *(unint64_t **)a3;
      v46 = *(unint64_t **)(a3 + 8);
      if (*(unint64_t **)a3 != v46)
      {
        while (sub_1002710E8(buf, v47))
        {
          v47 += 30;
          if (v47 == v46)
          {
            v47 = v46;
            goto LABEL_66;
          }
        }
        if (v47 != v46)
        {
          for (j = v47 + 30; j != v46; j += 30)
          {
            if (sub_1002710E8(buf, j))
            {
              v49 = *(_OWORD *)j;
              v47[2] = j[2];
              *(_OWORD *)v47 = v49;
              v50 = (void **)(v47 + 3);
              if (*((char *)v47 + 47) < 0)
                operator delete(*v50);
              v51 = *(_OWORD *)(j + 3);
              v47[5] = j[5];
              *(_OWORD *)v50 = v51;
              *((_BYTE *)j + 47) = 0;
              *((_BYTE *)j + 24) = 0;
              v52 = *((_OWORD *)j + 3);
              *(_OWORD *)((char *)v47 + 60) = *(_OWORD *)((char *)j + 60);
              *((_OWORD *)v47 + 3) = v52;
              sub_1002E0BA0((uint64_t)(v47 + 10), (uint64_t)(j + 10));
              v53 = *(_OWORD *)(j + 27);
              *((_BYTE *)v47 + 232) = *((_BYTE *)j + 232);
              *(_OWORD *)(v47 + 27) = v53;
              v47 += 30;
            }
          }
        }
      }
LABEL_66:
      sub_10026D460(a3, (uint64_t)v47, *(__int128 **)(a3 + 8));
      sub_100067AC4((uint64_t)buf);
    }
    sub_1001E4804(buf);
    LODWORD(v121) = 0;
    v54 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsFingerprintDataSource", 0x8000100u, kCFAllocatorNull);
    v55 = sub_1000B1180(*(uint64_t *)buf, (uint64_t)v54, &v121);
    CFRelease(v54);
    v56 = v121;
    v57 = *(std::__shared_weak_count **)&buf[8];
    if (*(_QWORD *)&buf[8])
    {
      v58 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
      do
        v59 = __ldaxr(v58);
      while (__stlxr(v59 - 1, v58));
      if (!v59)
      {
        ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
        std::__shared_weak_count::__release_weak(v57);
      }
    }
    if (v55)
      v60 = v56;
    else
      v60 = 1;
    sub_100270E34((uint64_t)v126, a4);
    v61 = (uint64_t)v128;
    if (v128)
    {
      if (v128 == v127)
      {
        v125 = v124;
        (*(void (**)(uint64_t, _QWORD *))(v127[0] + 24))((uint64_t)v127, v124);
LABEL_80:
        sub_100338E28(v60);
      }
      v61 = (*(uint64_t (**)(void))(*v128 + 16))();
    }
    v125 = (_QWORD *)v61;
    goto LABEL_80;
  }
  LOBYTE(v87[0]) = 0;
  LOBYTE(v88) = 0;
  v62 = a2;
  if (*(_BYTE *)(a7 + 280))
  {
    v63 = *(void **)(a7 + 16);
    v87[0] = (void *)(*(unsigned int *)(a7 + 140) | ((unint64_t)*(unsigned __int8 *)(a7 + 136) << 32));
    v87[1] = v63;
    LOBYTE(v88) = 1;
  }
  sub_1002FF288(a1, (uint64_t)&v89, &v120, (uint64_t)v87, v77);
  if (a10 != 2)
  {
    if (v78 >= v79 || (v64 = v91, sub_1002FF638() <= v64))
    {
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E498);
      v65 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEBUG, "set model to stable", buf, 2u);
      }
      if (sub_1001BFF7C(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212E498);
        LOWORD(v121) = 0;
        LODWORD(v75) = 2;
        _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 2, "set model to stable", &v121, v75);
        v74 = (uint8_t *)v73;
        sub_100512490("Generic", 1, 0, 2, "std::optional<CLMicroLocationModel> CLMicroLocationLearner::learnMagicalMomentsModelInternal(NSMutableDictionary *, std::vector<CLMicroLocationRecordingEventsTable::Entry> &, const CLMicroLocationLearner::ShouldCancelFunction &, const CLMicroLocationAnchorAppearanceMap &, CLMicroLocationFingerprintPool &, cl::chrono::CFAbsoluteTimeClock::time_point, const boost::uuids::uuid &, const std::optional<CLMicroLocationModelTable::Entry> &, const CLMicroLocationProto::Model::ModelType)", "%s\n", v73);
        if (v74 != buf)
          free(v74);
        v62 = a2;
      }
      v90 = 1;
    }
  }
  sub_1002EECD8((uint64_t)&v89, 0);
  sub_10036D014((uint64_t)&v89, (uint64_t)&v121);
  sub_1002EED0C((uint64_t)&v89, (int)v121);
  sub_1002EED14((uint64_t)&v89, (uint64_t)v122);
  v94 = v122[3];
  v95 = v123;
  sub_1002ECF30((uint64_t)&v89, (uint64_t)buf);
  v66 = v120;
  sub_1002E8400(v62, &v89, (uint64_t)buf, v120);
  if (*(_BYTE *)(a7 + 280))
  {
    if (v144)
      v67 = v143;
    else
      v67 = 0;
    sub_1002E8CD4((uint64_t)v62, &v89, &v103, v67, v144, v66);
  }
  v86[0] = sub_1002ED63C((uint64_t)&v103);
  v86[1] = 1;
  sub_1002E9384(v62, (uint64_t)&v89, v86);
  v93[32] = v76;
  v93[33] = 0;
  v93[34] = 0;
  v93[35] = 0;
  sub_100300FD0(a8, (uint64_t)&v89);
  sub_1002C8104(buf);
  if (v122[0])
  {
    v122[1] = v122[0];
    operator delete(v122[0]);
  }
  if (v102 < 0)
    operator delete(v101);
  if (v99)
  {
    v100 = v99;
    operator delete(v99);
  }
  sub_100270738((uint64_t)&v97);
  *(_QWORD *)buf = &v96;
  sub_1002707B4((void ***)buf);
  sub_100270824((uint64_t)v93);
  sub_100067AC4((uint64_t)&v92);
  v68 = v128;
  if (v128 == v127)
  {
    v69 = 4;
    v68 = v127;
  }
  else
  {
    if (!v128)
      goto LABEL_108;
    v69 = 5;
  }
  (*(void (**)(void))(*v68 + 8 * v69))();
LABEL_108:
  sub_1002708A4((uint64_t)v142);
  if (SHIBYTE(v115) < 0)
    operator delete((void *)v114);
  if ((_QWORD)__p)
  {
    *((_QWORD *)&__p + 1) = __p;
    operator delete((void *)__p);
  }
  sub_100270738((uint64_t)v111);
  *(_QWORD *)buf = &v109;
  sub_1002707B4((void ***)buf);
  sub_100270824((uint64_t)v107);
  sub_100067AC4((uint64_t)v104);
  if (v116)
  {
    v117 = v116;
    operator delete(v116);
  }
  result = v119;
  v119 = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1002FB4D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,char a63)
{
  unint64_t *v64;
  uint64_t v65;
  void *v66;
  unint64_t v67;

  if (a62)
    (*(void (**)(uint64_t))(*(_QWORD *)a62 + 8))(a62);
  sub_10026E1B8((uint64_t)&a63);
  v64 = (unint64_t *)STACK[0x538];
  if ((unint64_t *)STACK[0x538] == &STACK[0x520])
  {
    v65 = 4;
    v64 = &STACK[0x520];
  }
  else
  {
    if (!v64)
      goto LABEL_8;
    v65 = 5;
  }
  (*(void (**)(void))(*v64 + 8 * v65))();
LABEL_8:
  sub_1002708A4((uint64_t)&STACK[0xBA8]);
  sub_10026E1B8((uint64_t)&STACK[0x310]);
  v66 = (void *)STACK[0x470];
  if (STACK[0x470])
  {
    STACK[0x478] = (unint64_t)v66;
    operator delete(v66);
  }
  v67 = STACK[0x488];
  STACK[0x488] = 0;
  if (v67)
    (*(void (**)(unint64_t))(*(_QWORD *)v67 + 8))(v67);
  _Unwind_Resume(a1);
}

uint64_t sub_1002FB9A4(uint64_t a1)
{
  uint64_t result;

  if (*(_BYTE *)(a1 + 40))
    *(_BYTE *)(sub_100300B8C(a1) + 40) = 0;
  result = sub_1003A593C();
  *(_BYTE *)(result + 40) = 1;
  return result;
}

void sub_1002FB9E8(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8)
{
  CFStringRef v11;
  int v12;
  unsigned int v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t i;
  _OWORD *v23;
  _OWORD *j;
  NSObject *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  NSObject *v31;
  NSObject *v32;
  uint64_t *v33;
  NSObject *v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  void *v38;
  NSObject *v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  void *v43;
  NSObject *v44;
  uint64_t *v45;
  int v46;
  uint64_t *v47;
  void **v48;
  void *v50;
  __int128 v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  _OWORD v58[2];
  int v59;
  _OWORD v60[2];
  int v61;
  void *__p;
  void *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  _OWORD *v68;
  _OWORD *v69;
  uint64_t v70;
  double v71;
  _BYTE buf[38];
  __int16 v73;
  unint64_t v74;
  __int16 v75;
  const char *v76;

  v71 = a2;
  v69 = 0;
  v68 = 0;
  v70 = 0;
  v66 = 0;
  v65 = 0;
  v67 = 0;
  sub_1001E4804(buf);
  LODWORD(v50) = 0;
  v11 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsSimilarityListMaxNumberOfItems", 0x8000100u, kCFAllocatorNull);
  v12 = sub_1001C1194(*(uint64_t *)buf, (uint64_t)v11, &v50);
  CFRelease(v11);
  v13 = v50;
  v14 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v15 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  v17 = *a7;
  v18 = a7[1];
  v64 = 0;
  __p = 0;
  v63 = 0;
  sub_10027205C(&__p, *(const void **)a8, *(_QWORD *)(a8 + 8), (uint64_t)(*(_QWORD *)(a8 + 8) - *(_QWORD *)a8) >> 2);
  if (v12)
    v20 = v13;
  else
    v20 = 1000;
  sub_1002F5DA0(a1, a5, (uint64_t *)&v68, (uint64_t)&v65, v17, v18, v19, v20);
  if (__p)
  {
    v63 = __p;
    operator delete(__p);
  }
  memset(v60, 0, sizeof(v60));
  v61 = 1065353216;
  v21 = v65;
  for (i = v66; v21 != i; v21 += 240)
  {
    if (!*(_BYTE *)(v21 + 232))
    {
      v33 = &qword_1022A0000;
      if (qword_1022A00F0 != -1)
        goto LABEL_75;
      while (1)
      {
        v34 = qword_1022A00F8;
        if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
        {
          v35 = *(_QWORD *)(a5 + 24);
          v36 = *(char *)(a5 + 47);
          sub_1002F822C(v21, (uint64_t)&v50);
          if (v36 >= 0)
            v37 = a5 + 24;
          else
            v37 = v35;
          if (v51 >= 0)
            v38 = &v50;
          else
            v38 = v50;
          *(_DWORD *)buf = 68290051;
          *(_DWORD *)&buf[4] = 0;
          *(_WORD *)&buf[8] = 2082;
          *(_QWORD *)&buf[10] = "";
          *(_WORD *)&buf[18] = 2082;
          *(_QWORD *)&buf[20] = v37;
          *(_WORD *)&buf[28] = 2082;
          *(_QWORD *)&buf[30] = v38;
          v73 = 2082;
          v74 = (unint64_t)"assert";
          v75 = 2081;
          v76 = "recordingEntry.fTriggerUUID.has_value()";
          _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Similarity List Model Learning, labeled recording entry without trigger UUID\", \"Client Id\":%{public, location:escape_only}s, \"Recording UUID\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
          if (SHIBYTE(v51) < 0)
            operator delete(v50);
          if (v33[30] != -1)
            dispatch_once(&qword_1022A00F0, &stru_10212E498);
        }
        v39 = qword_1022A00F8;
        if (os_signpost_enabled((os_log_t)qword_1022A00F8))
        {
          v40 = *(_QWORD *)(a5 + 24);
          v41 = *(char *)(a5 + 47);
          sub_1002F822C(v21, (uint64_t)&v50);
          if (v41 >= 0)
            v42 = a5 + 24;
          else
            v42 = v40;
          if (v51 >= 0)
            v43 = &v50;
          else
            v43 = v50;
          *(_DWORD *)buf = 68290051;
          *(_DWORD *)&buf[4] = 0;
          *(_WORD *)&buf[8] = 2082;
          *(_QWORD *)&buf[10] = "";
          *(_WORD *)&buf[18] = 2082;
          *(_QWORD *)&buf[20] = v42;
          *(_WORD *)&buf[28] = 2082;
          *(_QWORD *)&buf[30] = v43;
          v73 = 2082;
          v74 = (unint64_t)"assert";
          v75 = 2081;
          v76 = "recordingEntry.fTriggerUUID.has_value()";
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v39, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Similarity List Model Learning, labeled recording entry without trigger UUID", "{\"msg%{public}.0s\":\"Similarity List Model Learning, labeled recording entry without trigger UUID\", \"Client Id\":%{public, location:escape_only}s, \"Recording UUID\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
          if (SHIBYTE(v51) < 0)
            operator delete(v50);
          if (v33[30] != -1)
            dispatch_once(&qword_1022A00F0, &stru_10212E498);
        }
        v44 = qword_1022A00F8;
        if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
        {
          v45 = *(uint64_t **)(a5 + 24);
          a5 += 24;
          v33 = v45;
          v46 = *(char *)(a5 + 23);
          sub_1002F822C(v21, (uint64_t)&v50);
          v47 = v46 >= 0 ? (uint64_t *)a5 : v33;
          v48 = v51 >= 0 ? &v50 : (void **)v50;
          *(_DWORD *)buf = 68290051;
          *(_DWORD *)&buf[4] = 0;
          *(_WORD *)&buf[8] = 2082;
          *(_QWORD *)&buf[10] = "";
          *(_WORD *)&buf[18] = 2082;
          *(_QWORD *)&buf[20] = v47;
          *(_WORD *)&buf[28] = 2082;
          *(_QWORD *)&buf[30] = v48;
          v73 = 2082;
          v74 = (unint64_t)"assert";
          v75 = 2081;
          v76 = "recordingEntry.fTriggerUUID.has_value()";
          _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Similarity List Model Learning, labeled recording entry without trigger UUID\", \"Client Id\":%{public, location:escape_only}s, \"Recording UUID\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
          if (SHIBYTE(v51) < 0)
            operator delete(v50);
        }
        abort_report_np("%s:%d: assertion failure in %s", "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationLearner.mm", 1115, "learnLocationSimilarityListModel");
        __break(1u);
LABEL_75:
        dispatch_once(&qword_1022A00F0, &stru_10212E498);
      }
    }
    *(_OWORD *)buf = *(_OWORD *)v21;
    *(_OWORD *)&buf[16] = *(_OWORD *)(v21 + 216);
    sub_1002F3B74((uint64_t)v60, buf, buf);
  }
  memset(v58, 0, sizeof(v58));
  v59 = 1065353216;
  v23 = v68;
  for (j = v69; v23 != j; v23 += 4)
  {
    *(_OWORD *)buf = *v23;
    *(_OWORD *)&buf[16] = *(_OWORD *)((char *)v23 + 40);
    sub_1003074C4(v58, buf);
  }
  if (v65 == v66)
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E498);
    v25 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      v26 = a5 + 24;
      if (*(char *)(a5 + 47) < 0)
        v26 = *(_QWORD *)(a5 + 24);
      *(_DWORD *)buf = 68289282;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2082;
      *(_QWORD *)&buf[20] = v26;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Similarity List Model Learning, no labeled recording triggers\", \"Client ID\":%{public, location:escape_only}s}", buf, 0x1Cu);
    }
  }
  v56 = 0;
  v55 = 0;
  v57 = 0;
  v53 = 0;
  v52 = 0;
  v54 = 0;
  v27 = v65;
  v28 = v66;
  *(_QWORD *)buf = &v55;
  if (v65 == v66)
    goto LABEL_32;
  do
  {
    if (*(_DWORD *)(v27 + 72) == 13)
      sub_100273B88((uint64_t **)buf, (__int128 *)v27);
    v27 += 240;
  }
  while (v27 != v28);
  v29 = v65;
  v27 = v66;
  *(_QWORD *)buf = &v52;
  if (v65 == v66)
  {
LABEL_32:
    v30 = v27;
  }
  else
  {
    do
    {
      if (*(_DWORD *)(v29 + 72) == 1)
        sub_100273B88((uint64_t **)buf, (__int128 *)v29);
      v29 += 240;
    }
    while (v29 != v27);
    v30 = v66;
    v27 = v65;
  }
  if (0xEEEEEEEEEEEEEEEFLL * ((v30 - v27) >> 4) != 0xEEEEEEEEEEEEEEEFLL * ((v56 - v55) >> 4)
                                                  - 0x1111111111111111 * ((v53 - v52) >> 4))
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E498);
    v31 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 68289794;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2050;
      *(_QWORD *)&buf[20] = 0xEEEEEEEEEEEEEEEFLL * ((v66 - v65) >> 4);
      *(_WORD *)&buf[28] = 2050;
      *(_QWORD *)&buf[30] = 0xEEEEEEEEEEEEEEEFLL * ((v56 - v55) >> 4);
      v73 = 2050;
      v74 = 0xEEEEEEEEEEEEEEEFLL * ((v53 - v52) >> 4);
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"learnLocationSimilarityListModel, didn't classify all labeled triggers to either recording or localization\", \"Num labeled triggers\":%{public}lu, \"Num inferred recordings\":%{public}lu, \"Num inferred localizations\":%{public}lu}", buf, 0x30u);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E498);
    }
    v32 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      *(_DWORD *)buf = 68289794;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2050;
      *(_QWORD *)&buf[20] = 0xEEEEEEEEEEEEEEEFLL * ((v66 - v65) >> 4);
      *(_WORD *)&buf[28] = 2050;
      *(_QWORD *)&buf[30] = 0xEEEEEEEEEEEEEEEFLL * ((v56 - v55) >> 4);
      v73 = 2050;
      v74 = 0xEEEEEEEEEEEEEEEFLL * ((v53 - v52) >> 4);
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v32, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "learnLocationSimilarityListModel, didn't classify all labeled triggers to either recording or localization", "{\"msg%{public}.0s\":\"learnLocationSimilarityListModel, didn't classify all labeled triggers to either recording or localization\", \"Num labeled triggers\":%{public}lu, \"Num inferred recordings\":%{public}lu, \"Num inferred localizations\":%{public}lu}", buf, 0x30u);
    }
  }
  sub_1002FF754();
}

void sub_1002FCF18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30)
{
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;

  v31 = STACK[0x258];
  STACK[0x258] = 0;
  if (v31)
    (*(void (**)(unint64_t))(*(_QWORD *)v31 + 8))(v31);
  v32 = STACK[0x260];
  STACK[0x260] = 0;
  if (v32)
    (*(void (**)(unint64_t))(*(_QWORD *)v32 + 8))(v32);
  v33 = STACK[0x268];
  STACK[0x268] = 0;
  if (v33)
    (*(void (**)(unint64_t))(*(_QWORD *)v33 + 8))(v33);
  a30 = (uint64_t)&STACK[0x270];
  sub_100270C6C((void ***)&a30);
  a30 = (uint64_t)&STACK[0x288];
  sub_100270C6C((void ***)&a30);
  sub_100067AC4((uint64_t)&STACK[0x2A0]);
  sub_100067AC4((uint64_t)&STACK[0x2D0]);
  a30 = (uint64_t)&STACK[0x318];
  sub_100270C6C((void ***)&a30);
  a30 = (uint64_t)&STACK[0x330];
  sub_1002699DC((void ***)&a30);
  _Unwind_Resume(a1);
}

uint64_t sub_1002FD170(uint64_t a1, uint64_t a2)
{
  void **v4;
  __int128 v5;
  __int128 v6;

  if (*(_BYTE *)(a1 + 112))
  {
    *(_QWORD *)a1 = *(_QWORD *)a2;
    v4 = (void **)(a1 + 8);
    if (*(char *)(a1 + 31) < 0)
      operator delete(*v4);
    v5 = *(_OWORD *)(a2 + 8);
    *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
    *(_OWORD *)v4 = v5;
    *(_BYTE *)(a2 + 31) = 0;
    *(_BYTE *)(a2 + 8) = 0;
    v6 = *(_OWORD *)(a2 + 32);
    *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = v6;
    sub_1002E5964(a1 + 56, a2 + 56);
  }
  else
  {
    sub_1002FFCE4(a1, a2);
    *(_BYTE *)(a1 + 112) = 1;
  }
  return a1;
}

uint64_t sub_1002FD20C(uint64_t a1)
{
  sub_1002E50A8((wireless_diagnostics::google::protobuf::MessageLite *)(a1 + 56));
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  return a1;
}

uint64_t sub_1002FD244@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned int a4@<W3>, uint64_t a5@<X5>, uint64_t a6@<X6>, _BYTE *a7@<X8>, uint64_t a8)
{
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _OWORD *v17;
  _OWORD *v18;
  __int128 *v19;
  __int128 *v20;
  __int128 *i;
  __int128 v22;
  void **v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  CFStringRef v27;
  int v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  BOOL v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t *v38;
  unint64_t *v39;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  NSObject *v43;
  NSObject *v44;
  __int128 *v48;
  __int128 *v49;
  _OWORD v50[2];
  int v51;
  void *__p;
  void *v53;
  uint64_t v54;
  _OWORD *v55;
  _OWORD *v56;
  uint64_t v57;
  uint64_t v58[3];
  _BYTE v59[56];
  unsigned int v60;
  _BYTE v61[24];
  _BYTE v62[24];
  _BYTE buf[18];
  __int16 v64;
  uint64_t v65;

  sub_1002F5B3C(a1, (__int128 *)a8, (uint64_t)v59);
  memset(v58, 0, sizeof(v58));
  v55 = 0;
  v56 = 0;
  v57 = 0;
  v13 = sub_1002F5A60();
  v14 = *(_QWORD *)a8;
  v15 = *(_QWORD *)(a8 + 8);
  v53 = 0;
  v54 = 0;
  __p = 0;
  sub_10027205C(&__p, *(const void **)a3, *(_QWORD *)(a3 + 8), (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 2);
  sub_1002F5DA0(a1, a2, v58, (uint64_t)&v55, v14, v15, v16, v13);
  if (__p)
  {
    v53 = __p;
    operator delete(__p);
  }
  memset(v50, 0, sizeof(v50));
  v51 = 1065353216;
  v17 = v55;
  v18 = v56;
  while (v17 != v18)
  {
    *(_OWORD *)buf = *v17;
    sub_100270E98((uint64_t)v50, buf, buf);
    v17 += 15;
  }
  sub_1002FD958(a1, a3, *(_QWORD *)a8, *(_QWORD *)(a8 + 8), (uint64_t)&v48);
  v20 = v48;
  v19 = v49;
  if (v48 != v49)
  {
    while (!sub_1002710E8(v50, v20))
    {
      v20 += 15;
      if (v20 == v19)
      {
        v20 = v19;
        goto LABEL_18;
      }
    }
    if (v20 != v19)
    {
      for (i = v20 + 15; i != v19; i += 15)
      {
        if (!sub_1002710E8(v50, i))
        {
          v22 = *i;
          *((_QWORD *)v20 + 2) = *((_QWORD *)i + 2);
          *v20 = v22;
          v23 = (void **)v20 + 3;
          if (*((char *)v20 + 47) < 0)
            operator delete(*v23);
          v24 = *(__int128 *)((char *)i + 24);
          *((_QWORD *)v20 + 5) = *((_QWORD *)i + 5);
          *(_OWORD *)v23 = v24;
          *((_BYTE *)i + 47) = 0;
          *((_BYTE *)i + 24) = 0;
          v25 = i[3];
          *(__int128 *)((char *)v20 + 60) = *(__int128 *)((char *)i + 60);
          v20[3] = v25;
          sub_1002E0BA0((uint64_t)(v20 + 5), (uint64_t)(i + 5));
          v26 = *(__int128 *)((char *)i + 216);
          *((_BYTE *)v20 + 232) = *((_BYTE *)i + 232);
          *(__int128 *)((char *)v20 + 216) = v26;
          v20 += 15;
        }
      }
    }
  }
LABEL_18:
  sub_10026D460((uint64_t)&v48, (uint64_t)v20, v49);
  sub_1001E4804(buf);
  v60 = 0;
  v27 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsLearningRecordingLimit", 0x8000100u, kCFAllocatorNull);
  v28 = sub_1000B1180(*(uint64_t *)buf, (uint64_t)v27, &v60);
  CFRelease(v27);
  v29 = v60;
  v30 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v31 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }
  v33 = 500;
  if (v28)
    v33 = v29;
  v34 = 0xEEEEEEEEEEEEEEEFLL * (v56 - v55);
  v35 = v33 >= v34;
  v36 = v33 - v34;
  if (v35)
    v37 = v36;
  else
    v37 = 0;
  v39 = (unint64_t *)v48;
  v38 = (unint64_t *)v49;
  v40 = 0xEEEEEEEEEEEEEEEFLL * (v49 - v48);
  if (v40 > v37)
  {
    sub_10026D460((uint64_t)&v48, (uint64_t)v48, &v49[-15 * v37]);
    v39 = (unint64_t *)v48;
    v38 = (unint64_t *)v49;
    v40 = 0xEEEEEEEEEEEEEEEFLL * (v49 - v48);
  }
  v41 = 126 - 2 * __clz(v40);
  if (v38 == v39)
    v42 = 0;
  else
    v42 = v41;
  sub_100302BAC(v39, v38, v42, 1);
  *a7 = 0;
  a7[280] = 0;
  if (a4 == 4)
  {
    sub_100270E34((uint64_t)v61, a5);
    sub_10026E228((uint64_t)v61, v58, (uint64_t *)&v55, &v48, buf, (uint64_t *)(a2 + 24), a6, *(_QWORD *)a8, *(_QWORD *)(a8 + 8));
  }
  if (a4 == 3)
  {
    sub_100270E34((uint64_t)v62, a5);
    sub_10026B298((uint64_t)v62, &v55, &v48, buf, (uint64_t *)(a2 + 24), a6, *(_QWORD *)a8, *(_QWORD *)(a8 + 8));
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E498);
  v43 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 68289282;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = "";
    v64 = 2050;
    v65 = a4;
    _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"invalid generation algorithm\", \"generation algorithm\":%{public}lu}", buf, 0x1Cu);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E498);
  }
  v44 = qword_1022A00F8;
  if (os_signpost_enabled((os_log_t)qword_1022A00F8))
  {
    *(_DWORD *)buf = 68289282;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = "";
    v64 = 2050;
    v65 = a4;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v44, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "invalid generation algorithm", "{\"msg%{public}.0s\":\"invalid generation algorithm\", \"generation algorithm\":%{public}lu}", buf, 0x1Cu);
  }
  *(_QWORD *)buf = &v48;
  sub_100270C6C((void ***)buf);
  sub_100067AC4((uint64_t)v50);
  *(_QWORD *)buf = &v55;
  sub_100270C6C((void ***)buf);
  *(_QWORD *)buf = v58;
  sub_1002699DC((void ***)buf);
  return sub_100067AC4((uint64_t)v59);
}

void sub_1002FD82C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, char *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,char *a40,char a41,uint64_t a42,uint64_t a43,char *a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49)
{
  uint64_t v49;
  char *v51;
  uint64_t v52;

  sub_1002708A4((uint64_t)&a49);
  v51 = a44;
  if (a44 == &a41)
  {
    v52 = 4;
    v51 = &a41;
  }
  else
  {
    if (!a44)
      goto LABEL_6;
    v52 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v51 + 8 * v52))();
LABEL_6:
  sub_1002708A4(v49);
  a40 = &a16;
  sub_100270C6C((void ***)&a40);
  sub_100067AC4((uint64_t)&a19);
  a19 = &a27;
  sub_100270C6C((void ***)&a19);
  a19 = &a30;
  sub_1002699DC((void ***)&a19);
  sub_100067AC4((uint64_t)&a33);
  _Unwind_Resume(a1);
}

void sub_1002FD958(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  char v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 *v13;
  __int128 *v14;
  __int128 **v15;
  __int128 v16;
  char v17;
  __int128 v18;
  char v19;
  __int128 v20;

  v5 = a3;
  *(_QWORD *)&v20 = a3;
  *((_QWORD *)&v20 + 1) = a4;
  v9 = *(_QWORD *)(a1 + 8);
  v18 = v20;
  v19 = 1;
  sub_1002FF9D4(v9, a2, &v18, (_QWORD *)a5);
  if (v5)
  {
LABEL_2:
    v10 = *(_QWORD *)(a1 + 8);
    v16 = 0uLL;
    v17 = 1;
    sub_1002FF9D4(v10, a2, &v16, &v13);
    sub_1003087F4((uint64_t *)a5, *(__int128 **)(a5 + 8), v13, v14, 0xEEEEEEEEEEEEEEEFLL * (v14 - v13));
    v15 = &v13;
    sub_100270C6C((void ***)&v15);
  }
  else
  {
    v11 = 1;
    while (v11 != 16)
    {
      if (*((unsigned __int8 *)&v20 + v11++))
      {
        if ((unint64_t)(v11 - 2) <= 0xE)
          goto LABEL_2;
        return;
      }
    }
  }
}

void sub_1002FDA68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, void ***a13)
{
  a13 = &a10;
  sub_100270C6C((void ***)&a13);
  sub_100270C6C(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_1002FDAA0(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t sub_1002FDAE0(uint64_t *a1, __int128 *a2)
{
  _QWORD *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v21[5];

  v6 = a1[2];
  v4 = a1 + 2;
  v5 = v6;
  v7 = *(v4 - 1);
  if (v7 >= v6)
  {
    v11 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v7 - *a1) >> 3);
    v12 = v11 + 1;
    if ((unint64_t)(v11 + 1) > 0x492492492492492)
      sub_100259694();
    v13 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v13 > v12)
      v12 = 2 * v13;
    if (v13 >= 0x249249249249249)
      v14 = 0x492492492492492;
    else
      v14 = v12;
    v21[4] = v4;
    v15 = (char *)sub_10025B800((uint64_t)v4, v14);
    v16 = &v15[56 * v11];
    v21[0] = v15;
    v21[1] = v16;
    v21[3] = &v15[56 * v17];
    v18 = *((_QWORD *)a2 + 2);
    *(_OWORD *)v16 = *a2;
    *((_QWORD *)v16 + 2) = v18;
    *((_QWORD *)a2 + 1) = 0;
    *((_QWORD *)a2 + 2) = 0;
    *(_QWORD *)a2 = 0;
    v19 = *((_QWORD *)a2 + 5);
    *(_OWORD *)(v16 + 24) = *(__int128 *)((char *)a2 + 24);
    *((_QWORD *)v16 + 5) = v19;
    *((_QWORD *)a2 + 4) = 0;
    *((_QWORD *)a2 + 5) = 0;
    *((_QWORD *)a2 + 3) = 0;
    *((_QWORD *)v16 + 6) = *((_QWORD *)a2 + 6);
    v21[2] = v16 + 56;
    sub_100304D54(a1, v21);
    v10 = a1[1];
    sub_100304F10(v21);
  }
  else
  {
    v8 = *a2;
    *(_QWORD *)(v7 + 16) = *((_QWORD *)a2 + 2);
    *(_OWORD *)v7 = v8;
    *((_QWORD *)a2 + 1) = 0;
    *((_QWORD *)a2 + 2) = 0;
    *(_QWORD *)a2 = 0;
    v9 = *(__int128 *)((char *)a2 + 24);
    *(_QWORD *)(v7 + 40) = *((_QWORD *)a2 + 5);
    *(_OWORD *)(v7 + 24) = v9;
    *((_QWORD *)a2 + 4) = 0;
    *((_QWORD *)a2 + 5) = 0;
    *((_QWORD *)a2 + 3) = 0;
    *(_QWORD *)(v7 + 48) = *((_QWORD *)a2 + 6);
    v10 = v7 + 56;
    a1[1] = v7 + 56;
  }
  a1[1] = v10;
  return v10 - 56;
}

void sub_1002FDC54(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_100304F10((void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002FDC68(uint64_t a1, uint64_t a2, __int128 **a3, uint64_t a4, double a5)
{
  _QWORD *v10;
  _QWORD *v11;
  __int128 *v12;
  __int128 *v13;
  uint64_t v14;
  _OWORD *v15;
  __int128 *v16;
  double Current;
  NSObject *v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  void *__p;
  void *v24;
  _OWORD *v25;
  __int128 v26;
  __int128 v27;
  int v28;
  uint64_t buf;
  __int16 v30;
  const char *v31;
  __int16 v32;
  unint64_t v33;
  __int16 v34;
  uint64_t v35;
  __int16 v36;
  unint64_t v37;
  __int16 v38;
  uint64_t v39;
  __int128 v40;

  v26 = 0u;
  v27 = 0u;
  v28 = 1065353216;
  v10 = *(_QWORD **)a4;
  v11 = *(_QWORD **)(a4 + 8);
  while (v10 != v11)
  {
    sub_100270E98((uint64_t)&v26, v10, v10);
    v10 += 10;
  }
  v12 = *a3;
  v13 = a3[1];
  if (*a3 == v13)
  {
    v16 = *a3;
  }
  else
  {
    do
    {
      v14 = *(_QWORD *)(a1 + 8);
      v40 = *v12;
      v15 = operator new(0x10uLL);
      v24 = v15 + 1;
      v25 = v15 + 1;
      *v15 = v40;
      __p = v15;
      sub_100280A50(v14, (uint64_t)&__p, &buf);
      if (__p)
      {
        v24 = __p;
        operator delete(__p);
      }
      sub_1003A4128(&v26, &buf);
      __p = &buf;
      sub_100296984((void ***)&__p);
      v12 += 15;
    }
    while (v12 != v13);
    v12 = *a3;
    v16 = a3[1];
  }
  Current = j__CFAbsoluteTimeGetCurrent();
  sub_1003A3984(a2, &v26, v16 != v12, a5, Current);
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E498);
  v18 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    v19 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a4 + 8) - *(_QWORD *)a4) >> 4);
    v20 = 0xEEEEEEEEEEEEEEEFLL * (a3[1] - *a3);
    v21 = *(_QWORD *)(a2 + 24);
    buf = 68290050;
    v30 = 2082;
    v31 = "";
    v32 = 2050;
    v33 = v19;
    v34 = 2050;
    v35 = *((_QWORD *)&v27 + 1);
    v36 = 2050;
    v37 = v20;
    v38 = 2050;
    v39 = v21;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Updating Anchor ID Set\", \"Num. Rapport Anchor Devices\":%{public}lu, \"Num Rapport and Measured Anchor Devices\":%{public}lu, \"Number of recordings since last model\":%{public}lu, \"Anchor Appearance Map size\":%{public}lu}", (uint8_t *)&buf, 0x3Au);
  }
  return sub_100067AC4((uint64_t)&v26);
}

void sub_1002FDEBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  sub_100067AC4((uint64_t)&a13);
  _Unwind_Resume(a1);
}

uint64_t sub_1002FDF08@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, __int128 *a3@<X2>, uint64_t a4@<X8>)
{
  NSObject *v8;
  char *v9;
  _BYTE *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  double v14;
  NSObject *v15;
  _OWORD *v16;
  void *v17;
  uint64_t v18;
  NSObject *v19;
  _OWORD *v20;
  void *v21;
  uint64_t *v22;
  double Current;
  uint64_t v24;
  CFStringRef v25;
  int v26;
  int v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  int v31;
  _DWORD *v32;
  __int128 v34;
  uint64_t v35;
  __int128 *v36[3];
  std::string v37;
  std::string v38;
  _OWORD v39[2];
  int v40;
  _QWORD v41[4];
  int v42;
  __int128 v43;
  void *v44;
  __int128 v45;
  int v46;
  _BYTE __p[28];
  __int16 v48;
  uint64_t *v49;
  __int128 v50;
  uint8_t buf[8];
  __int16 v52;
  const char *v53;
  __int16 v54;
  _BYTE *v55;
  __int16 v56;
  uint64_t *v57;
  uint64_t v58;
  char v59;

  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E498);
  v8 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
  {
    v9 = (char *)operator new(0x28uLL);
    *(_QWORD *)__p = v9;
    *(_OWORD *)&__p[8] = xmmword_101B97FF0;
    *(_OWORD *)v9 = 0u;
    *((_OWORD *)v9 + 1) = 0u;
    *(_QWORD *)(v9 + 29) = 0;
    sub_100261F9C((uint64_t)a3, v9);
    v10 = __p;
    if (__p[23] < 0)
      v10 = *(_BYTE **)__p;
    if (*((char *)a2 + 23) >= 0)
      v11 = a2;
    else
      v11 = (uint64_t *)*a2;
    *(_QWORD *)buf = 68289538;
    v52 = 2082;
    v53 = "";
    v54 = 2082;
    v55 = v10;
    v56 = 2082;
    v57 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"generating anchor appearance map for LOI\", \"LOI Id\":%{public, location:escape_only}s, \"LOI Type\":%{public, location:escape_only}s}", buf, 0x26u);
    if ((__p[23] & 0x80000000) != 0)
      operator delete(*(void **)__p);
  }
  sub_1003A336C((uint64_t)v41);
  memset(v39, 0, sizeof(v39));
  v40 = 1065353216;
  sub_1002823C4(a1[1], a3, buf);
  if (v59)
    goto LABEL_12;
  v18 = a1[1];
  v44 = 0;
  *(_QWORD *)&v45 = 0;
  sub_1002823C4(v18, (__int128 *)&v44, __p);
  sub_1002FFBE0((uint64_t)buf, (uint64_t)__p);
  sub_1002FFD68((uint64_t)__p);
  v14 = 0.0;
  if (v59)
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E498);
    v19 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
    {
      v20 = operator new(0x28uLL);
      v44 = v20;
      v45 = xmmword_101B97FF0;
      *v20 = 0u;
      v20[1] = 0u;
      *(_QWORD *)((char *)v20 + 29) = 0;
      sub_100261F9C((uint64_t)a3, v20);
      v21 = &v44;
      if (v45 < 0)
        v21 = v44;
      if (*((char *)a2 + 23) >= 0)
        v22 = a2;
      else
        v22 = (uint64_t *)*a2;
      *(_QWORD *)__p = 68289539;
      *(_WORD *)&__p[8] = 2082;
      *(_QWORD *)&__p[10] = "";
      *(_WORD *)&__p[18] = 2082;
      *(_QWORD *)&__p[20] = v21;
      v48 = 2081;
      v49 = v22;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"Previous anchor appearance not found for LOI ID. Using anchor appearance map for null uuid and loi type\", \"loi id\":%{public, location:escape_only}s, \"loi type\":%{private, location:escape_only}s}", __p, 0x26u);
      if (SHIBYTE(v45) < 0)
        operator delete(v44);
    }
    if (v59)
    {
LABEL_12:
      v12 = v58;
      if (!v58)
        v12 = *(_QWORD *)(qword_102310460 + 24);
      v13 = *(_QWORD *)(v12 + 8);
      if (!v13)
        v13 = *(_QWORD *)(qword_102310450 + 8);
      sub_1003A33C0((uint64_t)__p, v13);
      v42 = *(_DWORD *)((char *)&v49 + 2);
      sub_100270130(v41, *(uint64_t **)&__p[16], 0);
      v43 = v50;
      sub_100067AC4((uint64_t)__p);
      v14 = *(double *)buf;
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E498);
      v15 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        v16 = operator new(0x28uLL);
        v44 = v16;
        v45 = xmmword_101B97FF0;
        *v16 = 0u;
        v16[1] = 0u;
        *(_QWORD *)((char *)v16 + 29) = 0;
        sub_100261F9C((uint64_t)a3, v16);
        v17 = &v44;
        if (v45 < 0)
          v17 = v44;
        *(_QWORD *)__p = 68289538;
        *(_WORD *)&__p[8] = 2082;
        *(_QWORD *)&__p[10] = "";
        *(_WORD *)&__p[18] = 2082;
        *(_QWORD *)&__p[20] = v17;
        v48 = 1026;
        LODWORD(v49) = (int)v14;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Relying on previous anchor appearance map from configuration table\", \"loiGroupId\":%{public, location:escape_only}s, \"timestamp\":%{public}d}", __p, 0x22u);
        if (SHIBYTE(v45) < 0)
          operator delete(v44);
      }
    }
  }
  Current = j__CFAbsoluteTimeGetCurrent();
  std::to_string(&v38, v14);
  std::to_string(&v37, Current);
  sub_1002814D8(a1[1], (uint64_t)&v38, (uint64_t)&v37, (uint64_t)a3, v36);
  if (*a3 != 0)
  {
    v24 = a1[1];
    v44 = 0;
    *(_QWORD *)&v45 = 0;
    sub_1002814D8(v24, (uint64_t)&v38, (uint64_t)&v37, (uint64_t)&v44, __p);
    sub_100304F84((uint64_t *)v36, v36[1], *(__int128 **)__p, *(__int128 **)&__p[8], 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*(_QWORD *)&__p[8] - *(_QWORD *)__p) >> 4));
    v44 = __p;
    sub_100270C6C((void ***)&v44);
  }
  v34 = 0uLL;
  v35 = 0;
  sub_1001E4804(__p);
  LOBYTE(v44) = 0;
  v25 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsRapportUsageEnabled", 0x8000100u, kCFAllocatorNull);
  v26 = sub_1001E48E4(*(uint64_t *)__p, (uint64_t)v25, (BOOL *)&v44);
  CFRelease(v25);
  v27 = v44;
  v28 = *(std::__shared_weak_count **)&__p[8];
  if (*(_QWORD *)&__p[8])
  {
    v29 = (unint64_t *)(*(_QWORD *)&__p[8] + 8);
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  if (v27)
    v31 = 0;
  else
    v31 = v26;
  if (v31 != 1)
  {
    (*(void (**)(_BYTE *__return_ptr, uint64_t, uint64_t *, __int128 *, double))(*(_QWORD *)*a1 + 40))(__p, *a1, a2, a3, v14);
    sub_100305610((void **)&v34);
    v34 = *(_OWORD *)__p;
    v35 = *(_QWORD *)&__p[16];
    memset(__p, 0, 24);
    v44 = __p;
    sub_10030558C((void ***)&v44);
  }
  sub_1002FDC68((uint64_t)a1, (uint64_t)v41, v36, (uint64_t)&v34, v14);
  sub_1002BC0C0((uint64_t)&v44);
  v46 |= 2u;
  v32 = (_DWORD *)v45;
  if (!(_QWORD)v45)
    operator new();
  sub_1003A3604((uint64_t)v41, (int *)__p);
  sub_1002C5494(v32, (uint64_t)__p);
  sub_1002C5084((uint64_t *)__p);
  sub_1002FE724((uint64_t)&v44, a4, Current);
  sub_1002E4000((wireless_diagnostics::google::protobuf::MessageLite *)&v44);
  *(_QWORD *)__p = &v34;
  sub_10030558C((void ***)__p);
  *(_QWORD *)__p = v36;
  sub_100270C6C((void ***)__p);
  if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v37.__r_.__value_.__l.__data_);
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v38.__r_.__value_.__l.__data_);
  sub_1002FFD68((uint64_t)buf);
  sub_100300C78((uint64_t)v39);
  return sub_100067AC4((uint64_t)v41);
}

void sub_1002FE5C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45)
{
  void *v45;
  uint64_t v46;

  operator delete(v45);
  sub_1002FFD68(v46 - 224);
  sub_100300C78((uint64_t)&a27);
  sub_100067AC4((uint64_t)&a32);
  _Unwind_Resume(a1);
}

void sub_1002FE724(uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  unsigned int v6;
  int v7;

  sub_1002BC10C(a2);
  v6 = *(_DWORD *)(a1 + 16);
  if (!sub_10008D1F0(v6))
    __assert_rtn("set_type", "microlocation.pb.h", 21547, "::CLMicroLocationProto::ConfigurationType_IsValid(value)");
  v7 = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a2 + 40) = v6;
  *(_DWORD *)(a2 + 48) = v7 | 3;
  *(double *)(a2 + 8) = a3;
  sub_100358530(a2, a1);
}

void sub_1002FE7B4(_Unwind_Exception *a1)
{
  wireless_diagnostics::google::protobuf::MessageLite *v1;

  sub_1002E50A8(v1);
  _Unwind_Resume(a1);
}

void sub_1002FE7C8(uint64_t *a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  NSObject *v10;
  const char *v11;
  uint8_t *v12;
  NSObject *v13;
  const char *v14;
  _WORD v15[8];
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint8_t buf[8];
  __int16 v22;
  const char *v23;
  __int16 v24;
  uint64_t v25;

  if (sub_1002F5CC4())
  {
    v18 = 0;
    v19 = 0;
    v20 = 0;
    sub_10027FDF0(a1[1], &v16);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E498);
    v4 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 68289282;
      *(_DWORD *)&buf[4] = 0;
      v22 = 2082;
      v23 = "";
      v24 = 2050;
      v25 = (v17 - v16) >> 6;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Generating anchor appearance maps\", \"LOI count\":%{public}ld}", buf, 0x1Cu);
    }
    v5 = v16;
    v6 = v17;
    if (v16 == v17)
    {
LABEL_13:
      if ((sub_1002FEC74(a1[1]) & 1) != 0)
        goto LABEL_27;
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E498);
      v10 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#Warning failed to insert Anchor Appearances Map to MicroLocation DB", buf, 2u);
      }
      if (!sub_1001BFF7C(115, 2))
        goto LABEL_27;
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E498);
      v15[0] = 0;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#Warning failed to insert Anchor Appearances Map to MicroLocation DB", v15, 2);
      v12 = (uint8_t *)v11;
      sub_100512490("Generic", 1, 0, 2, "void CLMicroLocationLearner::generateAnchorAppearanceMap(CLMicroLocationLearner::ShouldCancelFunction)", "%s\n", v11);
    }
    else
    {
      while (1)
      {
        v7 = *(_QWORD *)(a2 + 24);
        if (!v7)
          sub_10025FD1C();
        if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v7 + 48))(v7))
          break;
        sub_1002FDF08(a1, (uint64_t *)(v5 + 40), (__int128 *)(v5 + 24), (uint64_t)buf);
        v8 = v19;
        if (v19 >= v20)
        {
          v9 = sub_10030567C(&v18, v5 + 40, (uint64_t)buf, (uint64_t *)(v5 + 24));
        }
        else
        {
          sub_1003057B8((uint64_t)&v20, v19, v5 + 40, (uint64_t)buf, (uint64_t *)(v5 + 24));
          v9 = v8 + 112;
        }
        v19 = v9;
        sub_1002E50A8((wireless_diagnostics::google::protobuf::MessageLite *)buf);
        v5 += 64;
        if (v5 == v6)
          goto LABEL_13;
      }
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E498);
      v13 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Cancelled, skipping generation of anchor appearance maps", buf, 2u);
      }
      if (!sub_1001BFF7C(115, 2))
        goto LABEL_27;
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E498);
      v15[0] = 0;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "Cancelled, skipping generation of anchor appearance maps", v15, 2);
      v12 = (uint8_t *)v14;
      sub_100512490("Generic", 1, 0, 2, "void CLMicroLocationLearner::generateAnchorAppearanceMap(CLMicroLocationLearner::ShouldCancelFunction)", "%s\n", v14);
    }
    if (v12 != buf)
      free(v12);
LABEL_27:
    *(_QWORD *)buf = &v16;
    sub_10028E258((void ***)buf);
    *(_QWORD *)buf = &v18;
    sub_1002A7CB8((void ***)buf);
  }
}

void sub_1002FEC10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, void **a19)
{
  a19 = (void **)&a13;
  sub_10028E258(&a19);
  a19 = (void **)&a16;
  sub_1002A7CB8(&a19);
  _Unwind_Resume(a1);
}

uint64_t sub_1002FEC74(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v5;
  const char *v6;
  uint8_t *v7;
  _WORD v8[8];
  uint8_t buf[1640];

  if (sub_1000CC4F4(a1 + 72))
  {
    v2 = *(_QWORD *)(a1 + 208);
    if (!v2)
      operator new();
    v3 = sub_1002A44C0(v2);
    sub_10030274C(a1);
    return v3;
  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E498);
    v5 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#Warning Can't insert because the database is invalid", buf, 2u);
    }
    if (sub_1001BFF7C(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E498);
      v8[0] = 0;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#Warning Can't insert because the database is invalid", v8, 2);
      v7 = (uint8_t *)v6;
      sub_100512490("Generic", 1, 0, 2, "BOOL CLMicroLocationDatabase::insertOrReplace(const std::vector<TableEntry> &) [TableEntry = CLMicroLocationConfigurationTable::Entry]", "%s\n", v6);
      if (v7 != buf)
        free(v7);
    }
    return 0;
  }
}

void sub_1002FEEA4()
{
  operator delete();
}

void sub_1002FEED0(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  NSObject *v4;
  const char *v5;
  uint8_t *v6;
  _WORD v7[8];
  uint8_t buf[1640];

  v3 = *(_QWORD *)(a2 + 24);
  if (!v3)
    sub_10025FD1C();
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v3 + 48))(v3))
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E498);
    v4 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Learning cancelled before onLearningBegin event", buf, 2u);
    }
    if (sub_1001BFF7C(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E498);
      v7[0] = 0;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "Learning cancelled before onLearningBegin event", v7, 2);
      v6 = (uint8_t *)v5;
      sub_100512490("Generic", 1, 0, 2, "void CLMicroLocationLearner::onLearningBegin(CLMicroLocationLearner::ShouldCancelFunction)", "%s\n", v5);
      if (v6 != buf)
        free(v6);
    }
  }
  else
  {
    (*(void (**)(void))(**(_QWORD **)a1 + 16))();
  }
}

void sub_1002FF0AC(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  NSObject *v4;
  const char *v5;
  uint8_t *v6;
  _WORD v7[8];
  uint8_t buf[1640];

  v3 = *(_QWORD *)(a2 + 24);
  if (!v3)
    sub_10025FD1C();
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v3 + 48))(v3))
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E498);
    v4 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Learning cancelled before onLearningCompleted event", buf, 2u);
    }
    if (sub_1001BFF7C(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E498);
      v7[0] = 0;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "Learning cancelled before onLearningCompleted event", v7, 2);
      v6 = (uint8_t *)v5;
      sub_100512490("Generic", 1, 0, 2, "void CLMicroLocationLearner::onLearningCompleted(CLMicroLocationLearner::ShouldCancelFunction)", "%s\n", v5);
      if (v6 != buf)
        free(v6);
    }
  }
  else
  {
    (*(void (**)(void))(**(_QWORD **)a1 + 48))();
  }
}

void sub_1002FF288(uint64_t a1, uint64_t a2, double *a3, uint64_t a4, uint64_t a5)
{
  int v10;
  NSObject *v11;
  NSObject *v12;
  int v13;
  const char *v14;
  std::string *v15;
  _QWORD v16[3];
  void **v17;
  std::string v18;
  std::string v19;

  if (*(_BYTE *)(a4 + 16))
  {
    std::to_string(&v18, *(double *)(a4 + 8));
    std::to_string(&v19, *a3);
    sub_1002814D8(*(_QWORD *)(a1 + 8), (uint64_t)&v18, (uint64_t)&v19, a5, v16);
    if (v16[1] == v16[0])
      v10 = *(_DWORD *)a4;
    else
      v10 = *(_DWORD *)a4 + 1;
    *(_DWORD *)(a2 + 12) = v10;
    v17 = (void **)v16;
    sub_100270C6C(&v17);
    if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v19.__r_.__value_.__l.__data_);
    if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v18.__r_.__value_.__l.__data_);
  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E498);
    v11 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
    {
      v18.__r_.__value_.__r.__words[0] = 0x104000100;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "Learning model without old model. Setting number of days with recordings to %d", (uint8_t *)&v18, 8u);
    }
    if (sub_1001BFF7C(115, 2))
    {
      bzero(&v18, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E498);
      v19.__r_.__value_.__r.__words[0] = 0x104000100;
      _os_log_send_and_compose_impl(2, 0, &v18, 1628, &_mh_execute_header, qword_1022A00F8, 2, "Learning model without old model. Setting number of days with recordings to %d", &v19);
      v15 = (std::string *)v14;
      sub_100512490("Generic", 1, 0, 2, "void CLMicroLocationLearner::updateModelDaysWithRecordings(CLMicroLocationModel &, const cl::chrono::CFAbsoluteTimeClock::time_point &, const std::optional<struct ModelStabilityParameters> &, const boost::uuids::uuid &)", "%s\n", v14);
      if (v15 != &v18)
        free(v15);
    }
    *(_DWORD *)(a2 + 12) = 1;
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E498);
  v12 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
  {
    v13 = *(_DWORD *)(a2 + 12);
    v18.__r_.__value_.__r.__words[0] = 68289283;
    LOWORD(v18.__r_.__value_.__r.__words[1]) = 2082;
    *(std::string::size_type *)((char *)&v18.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
    WORD1(v18.__r_.__value_.__r.__words[2]) = 1025;
    HIDWORD(v18.__r_.__value_.__r.__words[2]) = v13;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Setting model number of days with recordings\", \"numDaysWithRecordings\":%{private}u}", (uint8_t *)&v18, 0x18u);
  }
}

void sub_1002FF568(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint64_t v20;

  if (*(char *)(v20 - 73) < 0)
    operator delete(*(void **)(v20 - 96));
  if (a20 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1002FF5A4(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 3)
  {
    if (a2 >> 61)
      sub_100259694();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)sub_10025E6A0(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    v9 = &v6[8 * v8];
    v10 = (char *)*a1;
    v11 = (char *)a1[1];
    v12 = v7;
    if (v11 != *a1)
    {
      v12 = v7;
      do
      {
        v13 = *((_QWORD *)v11 - 1);
        v11 -= 8;
        *((_QWORD *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

uint64_t sub_1002FF638()
{
  CFStringRef v0;
  int v1;
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unsigned int v7;
  uint64_t v8;
  std::__shared_weak_count *v9;

  sub_1001E4804(&v8);
  v7 = 0;
  v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsMinimumNumberOfDaysWithRecordingsInStableModel", 0x8000100u, kCFAllocatorNull);
  v1 = sub_1000B1180(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  v2 = v7;
  v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  if (v1)
    return v2;
  else
    return 10;
}

void sub_1002FF6FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  sub_100261F44((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002FF714(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 256) && *(char *)(a1 + 255) < 0)
    operator delete(*(void **)(a1 + 232));
  sub_1002C8104(a1 + 32);
  return a1;
}

void sub_1002FF754()
{
  operator new();
}

void sub_1002FF87C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  char *v17;
  char *v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;

  v18 = a13;
  if (a13 == v17)
  {
    v19 = 4;
    v18 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v19 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v18 + 8 * v19))();
LABEL_6:
  v20 = a17;
  if (a17 == &a14)
  {
    v21 = 4;
    v20 = &a14;
  }
  else
  {
    if (!a17)
      goto LABEL_11;
    v21 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v20 + 8 * v21))();
LABEL_11:
  operator delete();
}

void sub_1002FF904(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, _QWORD *a4@<X8>)
{
  void *__p[2];
  char v9;
  __int128 v10;
  char v11;

  sub_1015A2E04(__p, "RecordingUUID");
  v10 = *a3;
  v11 = *((_BYTE *)a3 + 16);
  sub_100281088(a1, a2, (uint64_t)__p, (uint64_t)&v10, a4);
  if (v9 < 0)
    operator delete(__p[0]);
}

void sub_1002FF9B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1002FF9D4(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, _QWORD *a4@<X8>)
{
  void *__p[2];
  char v9;
  __int128 v10;
  char v11;

  sub_1015A2E04(__p, "RecordingTimestamp");
  v10 = *a3;
  v11 = *((_BYTE *)a3 + 16);
  sub_100281088(a1, a2, (uint64_t)__p, (uint64_t)&v10, a4);
  if (v9 < 0)
    operator delete(__p[0]);
}

void sub_1002FFA80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *sub_1002FFAA4(_QWORD *result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD v5[3];
  _QWORD *v6;

  v1 = result[2];
  v2 = result[3];
  if (v1 != v2)
  {
    while (1)
    {
      v5[0] = off_10212E810;
      v6 = v5;
      v3 = *(_QWORD *)(v1 + 24);
      if (!v3)
        sub_10025FD1C();
      (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v3 + 48))(v3, v5);
      result = v6;
      if (v6 == v5)
        break;
      if (v6)
      {
        v4 = 5;
LABEL_7:
        result = (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v4))();
      }
      v1 += 32;
      if (v1 == v2)
        return result;
    }
    result = v5;
    v4 = 4;
    goto LABEL_7;
  }
  return result;
}

void sub_1002FFB74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_1002FFBB4(id a1)
{
  qword_1022A00F8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_1002FFBE0(uint64_t a1, uint64_t a2)
{
  void **v4;
  __int128 v5;
  __int128 v6;

  if (*(unsigned __int8 *)(a1 + 112) == *(unsigned __int8 *)(a2 + 112))
  {
    if (*(_BYTE *)(a1 + 112))
    {
      *(_QWORD *)a1 = *(_QWORD *)a2;
      v4 = (void **)(a1 + 8);
      if (*(char *)(a1 + 31) < 0)
        operator delete(*v4);
      v5 = *(_OWORD *)(a2 + 8);
      *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
      *(_OWORD *)v4 = v5;
      *(_BYTE *)(a2 + 31) = 0;
      *(_BYTE *)(a2 + 8) = 0;
      v6 = *(_OWORD *)(a2 + 32);
      *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
      *(_OWORD *)(a1 + 32) = v6;
      sub_1002E5964(a1 + 56, a2 + 56);
    }
  }
  else if (*(_BYTE *)(a1 + 112))
  {
    sub_1002FFCA4(a1);
  }
  else
  {
    sub_1002FFCE4(a1, a2);
    *(_BYTE *)(a1 + 112) = 1;
  }
}

void sub_1002FFCA4(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 112))
  {
    sub_1002E50A8((wireless_diagnostics::google::protobuf::MessageLite *)(a1 + 56));
    if (*(char *)(a1 + 31) < 0)
      operator delete(*(void **)(a1 + 8));
    *(_BYTE *)(a1 + 112) = 0;
  }
}

uint64_t sub_1002FFCE4(uint64_t a1, uint64_t a2)
{
  __int128 v3;
  __int128 v4;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  v3 = *(_OWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 8) = v3;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  v4 = *(_OWORD *)(a2 + 32);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = v4;
  sub_1002E5034(a1 + 56, a2 + 56);
  return a1;
}

void sub_1002FFD4C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 31) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002FFD68(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 112))
  {
    sub_1002E50A8((wireless_diagnostics::google::protobuf::MessageLite *)(a1 + 56));
    if (*(char *)(a1 + 31) < 0)
      operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

double sub_1002FFDA8@<D0>(const __CFArray *a1@<X0>, uint64_t a2@<X8>)
{
  double result;
  uint64_t context;
  __int128 v6;
  CFRange v7;

  context = 0;
  v6 = 0uLL;
  v7.length = CFArrayGetCount(a1);
  v7.location = 0;
  CFArrayApplyFunction(a1, v7, (CFArrayApplierFunction)sub_1002FFE20, &context);
  *(_QWORD *)a2 = context;
  result = *(double *)&v6;
  *(_OWORD *)(a2 + 8) = v6;
  return result;
}

void sub_1002FFE08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1002FFE20(const void *a1, uint64_t a2)
{
  char v3;

  v3 = sub_1002FFE58(a1);
  sub_1002FFE9C(a2, &v3);
}

uint64_t sub_1002FFE58(const void *a1)
{
  CFTypeID v2;
  uint64_t v4;

  v2 = CFGetTypeID(a1);
  if (v2 == CFBooleanGetTypeID())
    return CFBooleanGetValue((CFBooleanRef)a1) != 0;
  v4 = sub_1018F3190();
  return sub_1002FFE9C(v4);
}

void sub_1002FFE9C(uint64_t a1, _BYTE *a2)
{
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  char *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  if (v4 == v5 << 6)
  {
    if ((uint64_t)(v4 + 1) < 0)
      sub_100259694();
    v6 = v5 << 7;
    if (v6 <= (v4 & 0xFFFFFFFFFFFFFFC0) + 64)
      v6 = (v4 & 0xFFFFFFFFFFFFFFC0) + 64;
    if (v4 <= 0x3FFFFFFFFFFFFFFELL)
      v7 = v6;
    else
      v7 = 0x7FFFFFFFFFFFFFFFLL;
    sub_1002FFF40((char **)a1, v7);
    v4 = *(_QWORD *)(a1 + 8);
  }
  *(_QWORD *)(a1 + 8) = v4 + 1;
  v8 = *(char **)a1;
  v9 = v4 >> 6;
  v10 = 1 << v4;
  if (*a2)
    v11 = *(_QWORD *)&v8[8 * v9] | v10;
  else
    v11 = *(_QWORD *)&v8[8 * v9] & ~v10;
  *(_QWORD *)&v8[8 * v9] = v11;
}

void sub_1002FFF40(char **a1, unint64_t a2)
{
  unint64_t v3;
  char *v4;
  __int128 v5;
  char *v6;
  int v7;
  char *v8;
  int v9;
  char *v10;
  __int128 v11;

  if (a2 > (_QWORD)a1[2] << 6)
  {
    if ((a2 & 0x8000000000000000) != 0)
      sub_100259694();
    v10 = 0;
    v11 = 0uLL;
    sub_1002FFFFC(&v10, a2);
    v3 = (unint64_t)a1[1];
    v8 = *a1;
    v9 = 0;
    v6 = &v8[8 * (v3 >> 6)];
    v7 = v3 & 0x3F;
    sub_100300040(&v10, (uint64_t)&v8, (uint64_t)&v6, v3);
    v4 = *a1;
    *a1 = v10;
    v10 = v4;
    v5 = *(_OWORD *)(a1 + 1);
    *(_OWORD *)(a1 + 1) = v11;
    v11 = v5;
    if (v4)
      operator delete(v4);
  }
}

void sub_1002FFFE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void *sub_1002FFFFC(_QWORD *a1, uint64_t a2)
{
  void *result;
  uint64_t v4;

  if (a2 < 0)
    sub_100259694();
  result = sub_10025E6A0((uint64_t)(a1 + 2), ((unint64_t)(a2 - 1) >> 6) + 1);
  *a1 = result;
  a1[1] = 0;
  a1[2] = v4;
  return result;
}

void sub_100300040(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;

  v4 = a1[1];
  v5 = v4 + a4;
  a1[1] = v4 + a4;
  if (!v4 || ((v5 - 1) ^ (v4 - 1)) >= 0x40)
  {
    if (v5 >= 0x41)
      v6 = (v5 - 1) >> 6;
    else
      v6 = 0;
    *(_QWORD *)(*a1 + 8 * v6) = 0;
  }
  v7 = *(_DWORD *)(a2 + 8);
  v8 = *(_QWORD *)a3;
  v9 = *(_DWORD *)(a3 + 8);
  v10 = *a1 + 8 * (v4 >> 6);
  v16 = *(_QWORD *)a2;
  v17 = v7;
  v14 = v8;
  v15 = v9;
  v12 = v10;
  v13 = v4 & 0x3F;
  sub_1003000E0(&v16, &v14, &v12, (uint64_t)&v11);
}

void sub_1003000E0(uint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;

  v5 = *((_DWORD *)a1 + 2);
  v6 = *a2;
  v7 = *((_DWORD *)a2 + 2);
  v16 = *a1;
  v17 = v5;
  v14 = v6;
  v15 = v7;
  v8 = *((_DWORD *)a3 + 2);
  v12 = *a3;
  v13 = v8;
  sub_10030016C((uint64_t)&v16, (uint64_t)&v14, (uint64_t)&v12, (uint64_t)&v18);
  v9 = v19;
  v10 = v20;
  v11 = v21;
  *(_QWORD *)a4 = v18;
  *(_DWORD *)(a4 + 8) = v9;
  *(_QWORD *)(a4 + 16) = v10;
  *(_DWORD *)(a4 + 24) = v11;
}

void sub_10030016C(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  _QWORD *v4;
  int v5;
  int i;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;

  v4 = *(_QWORD **)a1;
  v5 = *(_DWORD *)(a1 + 8);
  for (i = *(_DWORD *)(a3 + 8); *(_QWORD *)a1 != *(_QWORD *)a2 || v5 != *(_DWORD *)(a2 + 8); v5 = *(_DWORD *)(a1 + 8))
  {
    v8 = *(uint64_t **)a3;
    v9 = 1 << i;
    if (((*v4 >> v5) & 1) != 0)
      v10 = *v8 | v9;
    else
      v10 = *v8 & ~v9;
    *v8 = v10;
    if (v5 == 63)
    {
      v11 = 0;
      *(_QWORD *)a1 = v4 + 1;
    }
    else
    {
      v11 = v5 + 1;
    }
    *(_DWORD *)(a1 + 8) = v11;
    v12 = *(_DWORD *)(a3 + 8);
    if (v12 == 63)
    {
      i = 0;
      *(_QWORD *)a3 += 8;
    }
    else
    {
      i = v12 + 1;
    }
    *(_DWORD *)(a3 + 8) = i;
    v4 = *(_QWORD **)a1;
  }
  *(_QWORD *)a4 = v4;
  *(_DWORD *)(a4 + 8) = v5;
  *(_QWORD *)(a4 + 16) = *(_QWORD *)a3;
  *(_DWORD *)(a4 + 24) = i;
}

_QWORD *sub_10030023C(_QWORD *result, _BYTE *a2, _BYTE *a3, uint64_t a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  v4 = result[1];
  v5 = v4 + a4;
  result[1] = v4 + a4;
  if (!v4 || ((v5 - 1) ^ (v4 - 1)) >= 0x40)
  {
    if (v5 >= 0x41)
      v6 = (v5 - 1) >> 6;
    else
      v6 = 0;
    *(_QWORD *)(*result + 8 * v6) = 0;
  }
  if (a2 != a3)
  {
    v7 = v4 & 0x3F;
    v8 = (uint64_t *)(*result + 8 * (v4 >> 6));
    do
    {
      v9 = 1 << v7;
      if (*a2)
        v10 = *v8 | v9;
      else
        v10 = *v8 & ~v9;
      *v8 = v10;
      ++a2;
      v8 += v7 == 63;
      if (v7 == 63)
        v7 = 0;
      else
        ++v7;
    }
    while (a2 != a3);
  }
  return result;
}

uint64_t sub_1003002D8(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v5;
  const char *v6;
  uint8_t *v7;
  _WORD v8[8];
  uint8_t buf[1640];

  if (sub_1000CC4F4(a1 + 72))
  {
    v2 = *(_QWORD *)(a1 + 224);
    if (!v2)
      operator new();
    v3 = sub_1003A8860(v2);
    sub_100300534(a1);
    return v3;
  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E498);
    v5 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#Warning Can't insert because the database is invalid", buf, 2u);
    }
    if (sub_1001BFF7C(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E498);
      v8[0] = 0;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#Warning Can't insert because the database is invalid", v8, 2);
      v7 = (uint8_t *)v6;
      sub_100512490("Generic", 1, 0, 2, "BOOL CLMicroLocationDatabase::insertOrReplace(const std::vector<TableEntry> &) [TableEntry = CLMicroLocationModelTable::Entry]", "%s\n", v6);
      if (v7 != buf)
        free(v7);
    }
    return 0;
  }
}

void sub_100300508()
{
  operator delete();
}

uint64_t sub_100300534(uint64_t a1)
{
  unsigned int v2;
  NSObject *v3;
  uint64_t result;
  uint64_t v5;
  const char *v6;
  uint8_t *v7;
  int v8;
  const char *v9;
  uint8_t buf[4];
  const char *v11;

  v2 = sub_10028F428(a1);
  if (sub_100300728() > v2)
    return 1;
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E498);
  v3 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446210;
    v11 = "MicroLocationModels";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s has been written to more than expected. Clearing up disk space. If this log is seen often that indicates a serious problem", buf, 0xCu);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E498);
    v8 = 136446210;
    v9 = "MicroLocationModels";
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "%{public}s has been written to more than expected. Clearing up disk space. If this log is seen often that indicates a serious problem", &v8, 12);
    v7 = (uint8_t *)v6;
    sub_100512490("Generic", 1, 0, 2, "BOOL CLMicroLocationDatabase::freeSpaceIfFull() [Table = CLMicroLocationModelTable]", "%s\n", v6);
    if (v7 != buf)
      free(v7);
  }
  result = sub_100287D28(a1);
  if ((_DWORD)result)
  {
    if (*(uint64_t *)(a1 + 160) <= 0)
      v5 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v5 = *(_QWORD *)(a1 + 160);
    sub_100053048(a1 + 72, v5);
    return 1;
  }
  return result;
}

uint64_t sub_100300728()
{
  CFStringRef v0;
  int v1;
  unsigned int v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unsigned int v7;
  uint64_t v8;
  std::__shared_weak_count *v9;

  sub_1001E4804(&v8);
  v7 = 0;
  v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsModelTableMaxRows", 0x8000100u, kCFAllocatorNull);
  v1 = sub_1000B1180(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  v2 = v7;
  v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  if (v1)
    return v2;
  else
    return 100;
}

void sub_1003007EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  sub_100261F44((uint64_t)va);
  _Unwind_Resume(a1);
}

_OWORD *sub_100300804(_OWORD *a1, __int128 *a2)
{
  __int128 v4;

  v4 = *a2;
  *(_OWORD *)((char *)a1 + 12) = *(__int128 *)((char *)a2 + 12);
  *a1 = v4;
  sub_1002C7FF4((uint64_t)(a1 + 2), (uint64_t)(a2 + 2));
  sub_1002A2230((uint64_t)a1 + 232, (__int128 *)((char *)a2 + 232));
  *(_OWORD *)((char *)a1 + 264) = *(__int128 *)((char *)a2 + 264);
  return a1;
}

void sub_10030086C(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1002C8104(v1);
  _Unwind_Resume(a1);
}

_OWORD *sub_100300880(uint64_t a1, __int128 *a2, __int128 *a3, _OWORD *a4)
{
  _OWORD *v4;
  __int128 *v6;
  _QWORD v8[3];
  char v9;
  _OWORD *v10;
  _OWORD *v11;

  v4 = a4;
  v10 = a4;
  v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  v9 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      sub_100300804(v4, v6);
      v6 = (__int128 *)((char *)v6 + 280);
      v4 = (_OWORD *)((char *)v11 + 280);
      v11 = (_OWORD *)((char *)v11 + 280);
    }
    while (v6 != a3);
  }
  v9 = 1;
  sub_100300920((uint64_t)v8);
  return v4;
}

void sub_10030090C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100300920((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100300920(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    sub_100300954((uint64_t *)a1);
  return a1;
}

uint64_t *sub_100300954(uint64_t *result)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = (uint64_t *)result[1];
  v1 = (uint64_t *)result[2];
  v3 = *v1;
  v4 = *v2;
  if (*v1 != *v2)
  {
    v5 = *result;
    do
    {
      v3 -= 280;
      result = (uint64_t *)sub_1003009A4(v5, v3);
    }
    while (v3 != v4);
  }
  return result;
}

uint64_t sub_1003009A4(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a2 + 256) && *(char *)(a2 + 255) < 0)
    operator delete(*(void **)(a2 + 232));
  return sub_1002C8104(a2 + 32);
}

void sub_1003009DC(void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 280;
        sub_1003009A4((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_100300A60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v6;
  _QWORD v9[3];
  char v10;
  uint64_t v11;
  uint64_t v12;

  v4 = a4;
  v11 = a4;
  v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  v10 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      sub_1002A7698(a1, v4, v6);
      v6 += 112;
      v4 = v12 + 112;
      v12 += 112;
    }
    while (v6 != a3);
  }
  v10 = 1;
  sub_100300B08((uint64_t)v9);
  return v4;
}

void sub_100300AF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100300B08((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100300B08(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    sub_100300B3C((uint64_t *)a1);
  return a1;
}

void sub_100300B3C(uint64_t *a1)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = (uint64_t *)a1[1];
  v1 = (uint64_t *)a1[2];
  v3 = *v1;
  v4 = *v2;
  if (*v1 != *v2)
  {
    v5 = *a1;
    do
    {
      v3 -= 112;
      sub_1002A77B4(v5, v3);
    }
    while (v3 != v4);
  }
}

uint64_t sub_100300B8C(uint64_t a1)
{
  void *v2;

  sub_100300BC4(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void sub_100300BC4(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (_QWORD *)*v2;
      sub_1002A1C94((uint64_t)(v2 + 4));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

uint64_t sub_100300C00(uint64_t a1)
{
  void *v2;
  void **v4;

  if (*(_BYTE *)(a1 + 352))
  {
    if (*(char *)(a1 + 351) < 0)
      operator delete(*(void **)(a1 + 328));
    v2 = *(void **)(a1 + 304);
    if (v2)
    {
      *(_QWORD *)(a1 + 312) = v2;
      operator delete(v2);
    }
    sub_100270738(a1 + 256);
    v4 = (void **)(a1 + 232);
    sub_1002707B4(&v4);
    sub_100270824(a1 + 72);
    sub_100067AC4(a1 + 16);
  }
  return a1;
}

uint64_t sub_100300C78(uint64_t a1)
{
  void *v2;

  sub_100300CB0(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void sub_100300CB0(int a1, _QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;
  std::__shared_weak_count *v4;

  if (__p)
  {
    v2 = __p;
    do
    {
      v3 = (_QWORD *)*v2;
      v4 = (std::__shared_weak_count *)v2[5];
      if (v4)
        std::__shared_weak_count::__release_weak(v4);
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

void sub_100300CF0(id a1)
{
  qword_1022A0108 = (uint64_t)os_log_create("com.apple.locationd.Position", "MicrolocationQE");
}

uint64_t sub_100300D1C(uint64_t result, uint64_t a2)
{
  if (*(unsigned __int8 *)(result + 280) == *(unsigned __int8 *)(a2 + 280))
  {
    if (*(_BYTE *)(result + 280))
      return sub_1003A836C(result, a2);
  }
  else if (*(_BYTE *)(result + 280))
  {
    return sub_10027380C(result);
  }
  else
  {
    result = sub_1003A8368(result, a2);
    *(_BYTE *)(result + 280) = 1;
  }
  return result;
}

void sub_100300D60(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  if (*(unsigned __int8 *)(a1 + 120) == *(unsigned __int8 *)(a2 + 120))
  {
    if (*(_BYTE *)(a1 + 120))
    {
      sub_100006898(a1, (__n128 *)a2);
      sub_100006898(a1 + 24, (__n128 *)(a2 + 24));
      sub_1002F32BC((uint64_t *)(a1 + 48), a2 + 48);
      sub_100006898(a1 + 80, (__n128 *)(a2 + 80));
      v4 = *(_QWORD *)(a2 + 104);
      *(_BYTE *)(a1 + 112) = *(_BYTE *)(a2 + 112);
      *(_QWORD *)(a1 + 104) = v4;
    }
  }
  else if (*(_BYTE *)(a1 + 120))
  {
    sub_100300E00(a1);
  }
  else
  {
    sub_1002F3398(a1, a2);
    *(_BYTE *)(a1 + 120) = 1;
  }
}

void sub_100300E00(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  void *v4;
  void *v5;

  if (*(_BYTE *)(a1 + 120))
  {
    v2 = *(void **)(a1 + 80);
    if (v2)
    {
      *(_QWORD *)(a1 + 88) = v2;
      operator delete(v2);
    }
    if (*(_BYTE *)(a1 + 72))
    {
      v3 = *(_QWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 48) = 0;
      if (v3)
        operator delete[]();
    }
    v4 = *(void **)(a1 + 24);
    if (v4)
    {
      *(_QWORD *)(a1 + 32) = v4;
      operator delete(v4);
    }
    v5 = *(void **)a1;
    if (*(_QWORD *)a1)
    {
      *(_QWORD *)(a1 + 8) = v5;
      operator delete(v5);
    }
    *(_BYTE *)(a1 + 120) = 0;
  }
}

void sub_100300E80(void **a1)
{
  void *v1;
  uint64_t v3;
  void *v4;

  v1 = *a1;
  if (*a1)
  {
    v3 = (uint64_t)a1[1];
    v4 = v1;
    if ((void *)v3 != v1)
    {
      do
        v3 = sub_100261F44(v3 - 32);
      while ((void *)v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void sub_100300EDC(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;

  sub_100300F7C(a1);
  v4 = *a2;
  *a2 = 0;
  v5 = *(void **)a1;
  *(_QWORD *)a1 = v4;
  if (v5)
    operator delete(v5);
  v8 = a2[2];
  v7 = a2 + 2;
  v6 = v8;
  v9 = *(v7 - 1);
  *(_QWORD *)(a1 + 16) = v8;
  *(_QWORD *)(a1 + 8) = v9;
  *(v7 - 1) = 0;
  v10 = v7[1];
  *(_QWORD *)(a1 + 24) = v10;
  *(_DWORD *)(a1 + 32) = *((_DWORD *)v7 + 4);
  if (v10)
  {
    v11 = *(_QWORD *)(v6 + 8);
    v12 = *(_QWORD *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
        v11 %= v12;
    }
    else
    {
      v11 &= v12 - 1;
    }
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v11) = a1 + 16;
    *v7 = 0;
    v7[1] = 0;
  }
}

void sub_100300F7C(uint64_t a1)
{
  uint64_t v2;
  uint64_t i;

  if (*(_QWORD *)(a1 + 24))
  {
    sub_100270770(a1, *(_QWORD **)(a1 + 16));
    *(_QWORD *)(a1 + 16) = 0;
    v2 = *(_QWORD *)(a1 + 8);
    if (v2)
    {
      for (i = 0; i != v2; ++i)
        *(_QWORD *)(*(_QWORD *)a1 + 8 * i) = 0;
    }
    *(_QWORD *)(a1 + 24) = 0;
  }
}

uint64_t sub_100300FD0(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  __int128 v5;

  *(_OWORD *)a1 = *(_OWORD *)a2;
  sub_1002708EC(a1 + 16, a2 + 16);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  sub_1003010C0((_BYTE *)(a1 + 72), a2 + 72);
  v4 = *(_OWORD *)(a2 + 200);
  *(_OWORD *)(a1 + 212) = *(_OWORD *)(a2 + 212);
  *(_OWORD *)(a1 + 200) = v4;
  *(_QWORD *)(a1 + 240) = 0;
  *(_QWORD *)(a1 + 248) = 0;
  *(_QWORD *)(a1 + 232) = 0;
  *(_OWORD *)(a1 + 232) = *(_OWORD *)(a2 + 232);
  *(_QWORD *)(a1 + 248) = *(_QWORD *)(a2 + 248);
  *(_QWORD *)(a2 + 232) = 0;
  *(_QWORD *)(a2 + 240) = 0;
  *(_QWORD *)(a2 + 248) = 0;
  sub_10012D080(a1 + 256, (uint64_t *)(a2 + 256));
  *(_QWORD *)(a1 + 296) = *(_QWORD *)(a2 + 296);
  *(_QWORD *)(a1 + 304) = 0;
  *(_QWORD *)(a1 + 312) = 0;
  *(_QWORD *)(a1 + 320) = 0;
  *(_OWORD *)(a1 + 304) = *(_OWORD *)(a2 + 304);
  *(_QWORD *)(a1 + 320) = *(_QWORD *)(a2 + 320);
  *(_QWORD *)(a2 + 304) = 0;
  *(_QWORD *)(a2 + 312) = 0;
  *(_QWORD *)(a2 + 320) = 0;
  v5 = *(_OWORD *)(a2 + 328);
  *(_QWORD *)(a1 + 344) = *(_QWORD *)(a2 + 344);
  *(_OWORD *)(a1 + 328) = v5;
  *(_QWORD *)(a2 + 336) = 0;
  *(_QWORD *)(a2 + 344) = 0;
  *(_QWORD *)(a2 + 328) = 0;
  *(_BYTE *)(a1 + 352) = 1;
  return a1;
}

void sub_1003010AC(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_100067AC4(v1);
  _Unwind_Resume(a1);
}

_BYTE *sub_1003010C0(_BYTE *a1, uint64_t a2)
{
  *a1 = 0;
  a1[120] = 0;
  if (*(_BYTE *)(a2 + 120))
  {
    sub_1002F3398((uint64_t)a1, a2);
    a1[120] = 1;
  }
  return a1;
}

void sub_100301100(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_100270824(v1);
  _Unwind_Resume(a1);
}

void sub_100301118()
{
  operator delete();
}

_QWORD *sub_10030112C(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_10212E510;
  result[1] = v3;
  return result;
}

uint64_t sub_100301160(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_10212E510;
  a2[1] = v2;
  return result;
}

_QWORD *sub_10030117C(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *result;
  uint64_t v8;
  _QWORD v9[3];
  _QWORD *v10;
  _BYTE v11[24];
  _BYTE *v12;

  sub_1002AE164((uint64_t)v9, a2);
  v3 = *(_QWORD *)(a1 + 8);
  v4 = (uint64_t)v10;
  if (!v10)
    goto LABEL_4;
  if (v10 != v9)
  {
    v4 = (*(uint64_t (**)(void))(*v10 + 16))();
LABEL_4:
    v12 = (_BYTE *)v4;
    goto LABEL_6;
  }
  v12 = v11;
  (*(void (**)(_QWORD *, _BYTE *))(v9[0] + 24))(v9, v11);
LABEL_6:
  sub_1002FEED0(v3, (uint64_t)v11);
  v5 = v12;
  if (v12 == v11)
  {
    v6 = 4;
    v5 = v11;
  }
  else
  {
    if (!v12)
      goto LABEL_11;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_11:
  result = v10;
  if (v10 == v9)
  {
    v8 = 4;
    result = v9;
  }
  else
  {
    if (!v10)
      return result;
    v8 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v8))();
}

void sub_100301288(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  char *v18;
  uint64_t v19;

  v18 = a13;
  if (a13 == &a10)
  {
    v19 = 4;
    v18 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v19 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v18 + 8 * v19))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003012F8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100301334()
{
}

void sub_100301344()
{
  operator delete();
}

_QWORD *sub_100301358(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_10212E590;
  result[1] = v3;
  return result;
}

uint64_t sub_10030138C(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_10212E590;
  a2[1] = v2;
  return result;
}

_QWORD *sub_1003013A8(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *result;
  uint64_t v8;
  _QWORD v9[3];
  _QWORD *v10;
  _BYTE v11[24];
  _BYTE *v12;

  sub_1002AE164((uint64_t)v9, a2);
  v3 = *(uint64_t **)(a1 + 8);
  v4 = (uint64_t)v10;
  if (!v10)
    goto LABEL_4;
  if (v10 != v9)
  {
    v4 = (*(uint64_t (**)(void))(*v10 + 16))();
LABEL_4:
    v12 = (_BYTE *)v4;
    goto LABEL_6;
  }
  v12 = v11;
  (*(void (**)(_QWORD *, _BYTE *))(v9[0] + 24))(v9, v11);
LABEL_6:
  sub_1002FE7C8(v3, (uint64_t)v11);
  v5 = v12;
  if (v12 == v11)
  {
    v6 = 4;
    v5 = v11;
  }
  else
  {
    if (!v12)
      goto LABEL_11;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_11:
  result = v10;
  if (v10 == v9)
  {
    v8 = 4;
    result = v9;
  }
  else
  {
    if (!v10)
      return result;
    v8 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v8))();
}

void sub_1003014B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  char *v18;
  uint64_t v19;

  v18 = a13;
  if (a13 == &a10)
  {
    v19 = 4;
    v18 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v19 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v18 + 8 * v19))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t sub_100301524(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100301560()
{
}

void sub_100301570()
{
  operator delete();
}

_QWORD *sub_100301584(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_10212E610;
  result[1] = v3;
  return result;
}

uint64_t sub_1003015B8(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_10212E610;
  a2[1] = v2;
  return result;
}

_QWORD *sub_1003015D4(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *result;
  uint64_t v8;
  _QWORD v9[3];
  _QWORD *v10;
  _BYTE v11[24];
  _BYTE *v12;

  sub_1002AE164((uint64_t)v9, a2);
  v3 = *(uint64_t **)(a1 + 8);
  v4 = (uint64_t)v10;
  if (!v10)
    goto LABEL_4;
  if (v10 != v9)
  {
    v4 = (*(uint64_t (**)(void))(*v10 + 16))();
LABEL_4:
    v12 = (_BYTE *)v4;
    goto LABEL_6;
  }
  v12 = v11;
  (*(void (**)(_QWORD *, _BYTE *))(v9[0] + 24))(v9, v11);
LABEL_6:
  sub_1002F60A0(v3, (uint64_t)v11, 0);
  v5 = v12;
  if (v12 == v11)
  {
    v6 = 4;
    v5 = v11;
  }
  else
  {
    if (!v12)
      goto LABEL_11;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_11:
  result = v10;
  if (v10 == v9)
  {
    v8 = 4;
    result = v9;
  }
  else
  {
    if (!v10)
      return result;
    v8 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v8))();
}

void sub_1003016E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  char *v18;
  uint64_t v19;

  v18 = a13;
  if (a13 == &a10)
  {
    v19 = 4;
    v18 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v19 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v18 + 8 * v19))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t sub_100301754(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100301790()
{
}

void sub_1003017A0()
{
  operator delete();
}

_QWORD *sub_1003017B4(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_10212E690;
  result[1] = v3;
  return result;
}

uint64_t sub_1003017E8(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_10212E690;
  a2[1] = v2;
  return result;
}

_QWORD *sub_100301804(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *result;
  uint64_t v8;
  _QWORD v9[3];
  _QWORD *v10;
  _BYTE v11[24];
  _BYTE *v12;

  sub_1002AE164((uint64_t)v9, a2);
  v3 = *(uint64_t **)(a1 + 8);
  v4 = (uint64_t)v10;
  if (!v10)
    goto LABEL_4;
  if (v10 != v9)
  {
    v4 = (*(uint64_t (**)(void))(*v10 + 16))();
LABEL_4:
    v12 = (_BYTE *)v4;
    goto LABEL_6;
  }
  v12 = v11;
  (*(void (**)(_QWORD *, _BYTE *))(v9[0] + 24))(v9, v11);
LABEL_6:
  sub_1002F60A0(v3, (uint64_t)v11, 1u);
  v5 = v12;
  if (v12 == v11)
  {
    v6 = 4;
    v5 = v11;
  }
  else
  {
    if (!v12)
      goto LABEL_11;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_11:
  result = v10;
  if (v10 == v9)
  {
    v8 = 4;
    result = v9;
  }
  else
  {
    if (!v10)
      return result;
    v8 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v8))();
}

void sub_100301914(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  char *v18;
  uint64_t v19;

  v18 = a13;
  if (a13 == &a10)
  {
    v19 = 4;
    v18 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v19 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v18 + 8 * v19))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t sub_100301984(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1003019C0()
{
}

void sub_1003019D0()
{
  operator delete();
}

_QWORD *sub_1003019E4(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_10212E710;
  result[1] = v3;
  return result;
}

uint64_t sub_100301A18(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_10212E710;
  a2[1] = v2;
  return result;
}

_QWORD *sub_100301A34(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *result;
  uint64_t v8;
  _QWORD v9[3];
  _QWORD *v10;
  _BYTE v11[24];
  _BYTE *v12;

  sub_1002AE164((uint64_t)v9, a2);
  v3 = *(uint64_t **)(a1 + 8);
  v4 = (uint64_t)v10;
  if (!v10)
    goto LABEL_4;
  if (v10 != v9)
  {
    v4 = (*(uint64_t (**)(void))(*v10 + 16))();
LABEL_4:
    v12 = (_BYTE *)v4;
    goto LABEL_6;
  }
  v12 = v11;
  (*(void (**)(_QWORD *, _BYTE *))(v9[0] + 24))(v9, v11);
LABEL_6:
  sub_1002F60A0(v3, (uint64_t)v11, 2u);
  v5 = v12;
  if (v12 == v11)
  {
    v6 = 4;
    v5 = v11;
  }
  else
  {
    if (!v12)
      goto LABEL_11;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_11:
  result = v10;
  if (v10 == v9)
  {
    v8 = 4;
    result = v9;
  }
  else
  {
    if (!v10)
      return result;
    v8 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v8))();
}

void sub_100301B44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  char *v18;
  uint64_t v19;

  v18 = a13;
  if (a13 == &a10)
  {
    v19 = 4;
    v18 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v19 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v18 + 8 * v19))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t sub_100301BB4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100301BF0()
{
}

void sub_100301C00()
{
  operator delete();
}

_QWORD *sub_100301C14(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_10212E790;
  result[1] = v3;
  return result;
}

uint64_t sub_100301C48(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_10212E790;
  a2[1] = v2;
  return result;
}

_QWORD *sub_100301C64(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *result;
  uint64_t v8;
  _QWORD v9[3];
  _QWORD *v10;
  _BYTE v11[24];
  _BYTE *v12;

  sub_1002AE164((uint64_t)v9, a2);
  v3 = *(_QWORD *)(a1 + 8);
  v4 = (uint64_t)v10;
  if (!v10)
    goto LABEL_4;
  if (v10 != v9)
  {
    v4 = (*(uint64_t (**)(void))(*v10 + 16))();
LABEL_4:
    v12 = (_BYTE *)v4;
    goto LABEL_6;
  }
  v12 = v11;
  (*(void (**)(_QWORD *, _BYTE *))(v9[0] + 24))(v9, v11);
LABEL_6:
  sub_1002FF0AC(v3, (uint64_t)v11);
  v5 = v12;
  if (v12 == v11)
  {
    v6 = 4;
    v5 = v11;
  }
  else
  {
    if (!v12)
      goto LABEL_11;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_11:
  result = v10;
  if (v10 == v9)
  {
    v8 = 4;
    result = v9;
  }
  else
  {
    if (!v10)
      return result;
    v8 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v8))();
}

void sub_100301D70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  char *v18;
  uint64_t v19;

  v18 = a13;
  if (a13 == &a10)
  {
    v19 = 4;
    v18 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v19 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v18 + 8 * v19))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t sub_100301DE0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100301E1C()
{
}

void sub_100301E28(uint64_t *a1)
{
  if (*a1)
  {
    sub_100269A1C(a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t sub_100301E60(uint64_t *a1, uint64_t a2, uint64_t a3, __int128 *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  __int128 *v21;
  char *v23;
  char *v24;
  char *v25;
  char *v26;
  uint64_t v27;

  v5 = a2;
  if (a5 >= 1)
  {
    v11 = a1[2];
    v9 = (uint64_t)(a1 + 2);
    v10 = v11;
    v12 = *(_QWORD *)(v9 - 8);
    if (a5 <= (uint64_t)(v11 - v12) >> 6)
    {
      v19 = v12 - a2;
      v20 = (uint64_t)(v12 - a2) >> 6;
      if (v20 >= a5)
      {
        v21 = (__int128 *)(a3 + (a5 << 6));
      }
      else
      {
        v21 = (__int128 *)(a3 + (v20 << 6));
        a1[1] = sub_1003021BC(v9, v21, a4, *(_QWORD *)(v9 - 8));
        if (v19 < 1)
          return v5;
      }
      sub_100301FDC((uint64_t)a1, v5, v12, v5 + (a5 << 6));
      sub_1003023C4(a3, (uint64_t)v21, v5);
    }
    else
    {
      v13 = *a1;
      v14 = a5 + ((uint64_t)(v12 - *a1) >> 6);
      if (v14 >> 58)
        sub_100259694();
      v15 = (a2 - v13) >> 6;
      v16 = v10 - v13;
      if (v16 >> 5 > v14)
        v14 = v16 >> 5;
      if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFC0)
        v17 = 0x3FFFFFFFFFFFFFFLL;
      else
        v17 = v14;
      v27 = v9;
      if (v17)
        v18 = (char *)sub_1002697F0(v9, v17);
      else
        v18 = 0;
      v23 = v18;
      v24 = &v18[64 * v15];
      v25 = v24;
      v26 = &v18[64 * v17];
      sub_100302068(&v23, a3, a5);
      v5 = sub_10030210C(a1, &v23, v5);
      sub_100269954((uint64_t)&v23);
    }
  }
  return v5;
}

void sub_100301FBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  uint64_t v10;
  uint64_t v11;

  *(_QWORD *)(v10 + 8) = v11;
  _Unwind_Resume(exception_object);
}

uint64_t sub_100301FDC(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  __int128 v10;
  __int128 v11;
  char v13;

  v6 = *(_QWORD *)(a1 + 8);
  v7 = a2 + v6 - a4;
  v8 = v6;
  if (v7 < a3)
  {
    v9 = v7;
    v8 = *(_QWORD *)(a1 + 8);
    do
    {
      *(_OWORD *)v8 = *(_OWORD *)v9;
      v10 = *(_OWORD *)(v9 + 16);
      *(_QWORD *)(v8 + 32) = *(_QWORD *)(v9 + 32);
      *(_OWORD *)(v8 + 16) = v10;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 0;
      *(_QWORD *)(v9 + 16) = 0;
      v11 = *(_OWORD *)(v9 + 40);
      *(_QWORD *)(v8 + 56) = *(_QWORD *)(v9 + 56);
      *(_OWORD *)(v8 + 40) = v11;
      v8 += 64;
      v9 += 64;
    }
    while (v9 < a3);
  }
  *(_QWORD *)(a1 + 8) = v8;
  return sub_100302314((uint64_t)&v13, a2, v7, v6);
}

_QWORD *sub_100302068(_QWORD *result, uint64_t a2, uint64_t a3)
{
  _QWORD *v3;
  uint64_t v4;
  __int128 *v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;

  v3 = result;
  v4 = result[2];
  if (a3)
  {
    v5 = (__int128 *)(a2 + 16);
    v6 = a3 << 6;
    v7 = v4 + (a3 << 6);
    do
    {
      *(_OWORD *)v4 = *(v5 - 1);
      result = (_QWORD *)(v4 + 16);
      if (*((char *)v5 + 23) < 0)
      {
        result = sub_100115CE4(result, *(void **)v5, *((_QWORD *)v5 + 1));
      }
      else
      {
        v8 = *v5;
        *(_QWORD *)(v4 + 32) = *((_QWORD *)v5 + 2);
        *(_OWORD *)result = v8;
      }
      v9 = *(__int128 *)((char *)v5 + 24);
      *(_QWORD *)(v4 + 56) = *((_QWORD *)v5 + 5);
      *(_OWORD *)(v4 + 40) = v9;
      v4 += 64;
      v5 += 4;
      v6 -= 64;
    }
    while (v6);
    v4 = v7;
  }
  v3[2] = v4;
  return result;
}

void sub_100302104(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 16) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_10030210C(uint64_t *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v6 = a2[1];
  v7 = (uint64_t)(a1 + 2);
  sub_100269824((uint64_t)(a1 + 2), a3, a3, *a1, *a1, v6, v6);
  a2[1] = v8;
  a2[2] = sub_10030243C(v7, a3, a1[1], a2[2]);
  v9 = *a1;
  *a1 = a2[1];
  a2[1] = v9;
  v10 = a1[1];
  a1[1] = a2[2];
  a2[2] = v10;
  v11 = a1[2];
  a1[2] = a2[3];
  a2[3] = v11;
  *a2 = a2[1];
  return v6;
}

uint64_t sub_1003021BC(uint64_t a1, __int128 *a2, __int128 *a3, uint64_t a4)
{
  uint64_t v4;
  __int128 *v6;
  _BYTE *v7;
  __int128 v8;
  uint64_t v9;
  __int128 *v10;
  __int128 v11;
  _QWORD v13[3];
  char v14;
  uint64_t v15;
  uint64_t v16;

  v4 = a4;
  v15 = a4;
  v16 = a4;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  v14 = 0;
  if (a2 != a3)
  {
    v6 = a2 + 1;
    do
    {
      *(_OWORD *)v4 = *(v6 - 1);
      v7 = (_BYTE *)(v4 + 16);
      if (*((char *)v6 + 23) < 0)
      {
        sub_100115CE4(v7, *(void **)v6, *((_QWORD *)v6 + 1));
        v9 = v16;
      }
      else
      {
        v8 = *v6;
        *(_QWORD *)(v4 + 32) = *((_QWORD *)v6 + 2);
        *(_OWORD *)v7 = v8;
        v9 = v4;
      }
      v10 = v6 - 1;
      v11 = *(__int128 *)((char *)v6 + 24);
      *(_QWORD *)(v4 + 56) = *((_QWORD *)v6 + 5);
      *(_OWORD *)(v4 + 40) = v11;
      v4 = v9 + 64;
      v16 = v9 + 64;
      v6 += 4;
    }
    while (v10 + 4 != a3);
  }
  v14 = 1;
  sub_10030229C((uint64_t)v13);
  return v4;
}

void sub_100302288(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_10030229C((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_10030229C(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    sub_1003022D0(a1);
  return a1;
}

void sub_1003022D0(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = **(_QWORD **)(a1 + 16);
  v2 = **(_QWORD **)(a1 + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 - 25) < 0)
      operator delete(*(void **)(v1 - 48));
    v1 -= 64;
  }
}

uint64_t sub_100302314(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void **v10;
  __int128 v11;
  __int128 v12;

  if (a3 != a2)
  {
    v7 = 0;
    do
    {
      v8 = a3 + v7;
      v9 = a4 + v7;
      *(_OWORD *)(a4 + v7 - 64) = *(_OWORD *)(a3 + v7 - 64);
      v10 = (void **)(a4 + v7 - 48);
      if (*(char *)(a4 + v7 - 25) < 0)
        operator delete(*v10);
      v11 = *(_OWORD *)(v8 - 48);
      *(_QWORD *)(a4 + v7 - 32) = *(_QWORD *)(v8 - 32);
      *(_OWORD *)v10 = v11;
      *(_BYTE *)(v8 - 25) = 0;
      *(_BYTE *)(v8 - 48) = 0;
      v12 = *(_OWORD *)(v8 - 24);
      *(_QWORD *)(v9 - 8) = *(_QWORD *)(v8 - 8);
      *(_OWORD *)(v9 - 24) = v12;
      v7 -= 64;
    }
    while (a3 + v7 != a2);
  }
  return a3;
}

uint64_t sub_1003023C4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v4 = a1;
  if (a1 == a2)
    return a1;
  v5 = a2;
  do
  {
    *(_OWORD *)a3 = *(_OWORD *)v4;
    std::string::operator=((std::string *)(a3 + 16), (const std::string *)(v4 + 16));
    v6 = *(_QWORD *)(v4 + 56);
    *(_OWORD *)(a3 + 40) = *(_OWORD *)(v4 + 40);
    *(_QWORD *)(a3 + 56) = v6;
    a3 += 64;
    v4 += 64;
  }
  while (v4 != v5);
  return v5;
}

uint64_t sub_10030243C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  _QWORD v8[3];
  char v9;
  uint64_t v10;
  uint64_t v11;

  v4 = a4;
  v11 = a4;
  v10 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  if (a2 != a3)
  {
    do
    {
      *(_OWORD *)v4 = *(_OWORD *)a2;
      v5 = *(_OWORD *)(a2 + 16);
      *(_QWORD *)(v4 + 32) = *(_QWORD *)(a2 + 32);
      *(_OWORD *)(v4 + 16) = v5;
      *(_QWORD *)(a2 + 24) = 0;
      *(_QWORD *)(a2 + 32) = 0;
      *(_QWORD *)(a2 + 16) = 0;
      v6 = *(_OWORD *)(a2 + 40);
      *(_QWORD *)(v4 + 56) = *(_QWORD *)(a2 + 56);
      *(_OWORD *)(v4 + 40) = v6;
      v4 += 64;
      a2 += 64;
    }
    while (a2 != a3);
    v11 = v4;
  }
  v9 = 1;
  sub_10030229C((uint64_t)v8);
  return v4;
}

void sub_1003024D8(void **a1)
{
  void *v1;
  uint64_t v3;
  void *v4;

  v1 = *a1;
  if (*a1)
  {
    v3 = (uint64_t)a1[1];
    v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 240;
        sub_100270CF0((uint64_t)(a1 + 2), v3);
      }
      while ((void *)v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void sub_100302544(__int128 *a1, __int128 *a2)
{
  uint64_t v4;
  void **v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  void **v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  void *__p[2];
  uint64_t v14;
  _BYTE v15[28];
  _BYTE v16[136];
  __int128 v17;
  char v18;

  v11 = *a1;
  v12 = *((_QWORD *)a1 + 2);
  *(_OWORD *)__p = *(__int128 *)((char *)a1 + 24);
  v14 = *((_QWORD *)a1 + 5);
  *((_QWORD *)a1 + 3) = 0;
  *((_QWORD *)a1 + 4) = 0;
  *((_QWORD *)a1 + 5) = 0;
  *(_OWORD *)v15 = a1[3];
  *(_OWORD *)&v15[12] = *(__int128 *)((char *)a1 + 60);
  v4 = (uint64_t)(a1 + 5);
  sub_1002DF194(v16);
  v5 = (void **)a1 + 3;
  v17 = *(__int128 *)((char *)a1 + 216);
  v18 = *((_BYTE *)a1 + 232);
  v6 = *((_QWORD *)a2 + 2);
  *a1 = *a2;
  *((_QWORD *)a1 + 2) = v6;
  if (*((char *)a1 + 47) < 0)
    operator delete(*v5);
  v7 = *(__int128 *)((char *)a2 + 24);
  *((_QWORD *)a1 + 5) = *((_QWORD *)a2 + 5);
  *(_OWORD *)v5 = v7;
  *((_BYTE *)a2 + 47) = 0;
  *((_BYTE *)a2 + 24) = 0;
  v8 = a2[3];
  *(__int128 *)((char *)a1 + 60) = *(__int128 *)((char *)a2 + 60);
  a1[3] = v8;
  sub_1002E0BA0(v4, (uint64_t)(a2 + 5));
  v9 = (void **)a2 + 3;
  v10 = *(__int128 *)((char *)a2 + 216);
  *((_BYTE *)a1 + 232) = *((_BYTE *)a2 + 232);
  *(__int128 *)((char *)a1 + 216) = v10;
  *a2 = v11;
  *((_QWORD *)a2 + 2) = v12;
  if (*((char *)a2 + 47) < 0)
    operator delete(*v9);
  *(_OWORD *)v9 = *(_OWORD *)__p;
  *((_QWORD *)a2 + 5) = v14;
  a2[3] = *(_OWORD *)v15;
  *(__int128 *)((char *)a2 + 60) = *(_OWORD *)&v15[12];
  sub_1002E0BA0((uint64_t)(a2 + 5), (uint64_t)v16);
  *(__int128 *)((char *)a2 + 216) = v17;
  *((_BYTE *)a2 + 232) = v18;
  sub_1002DF2E0(v16);
}

void sub_100302720(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_10030274C(uint64_t a1)
{
  unsigned int v2;
  NSObject *v3;
  uint64_t result;
  uint64_t v5;
  const char *v6;
  uint8_t *v7;
  int v8;
  const char *v9;
  uint8_t buf[4];
  const char *v11;

  v2 = sub_10028F63C(a1);
  if (sub_100302940() > v2)
    return 1;
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E498);
  v3 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446210;
    v11 = "MicroLocationConfiguration";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s has been written to more than expected. Clearing up disk space. If this log is seen often that indicates a serious problem", buf, 0xCu);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E498);
    v8 = 136446210;
    v9 = "MicroLocationConfiguration";
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "%{public}s has been written to more than expected. Clearing up disk space. If this log is seen often that indicates a serious problem", &v8, 12);
    v7 = (uint8_t *)v6;
    sub_100512490("Generic", 1, 0, 2, "BOOL CLMicroLocationDatabase::freeSpaceIfFull() [Table = CLMicroLocationConfigurationTable]", "%s\n", v6);
    if (v7 != buf)
      free(v7);
  }
  result = sub_100287EEC(a1);
  if ((_DWORD)result)
  {
    if (*(uint64_t *)(a1 + 160) <= 0)
      v5 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v5 = *(_QWORD *)(a1 + 160);
    sub_100053048(a1 + 72, v5);
    return 1;
  }
  return result;
}

uint64_t sub_100302940()
{
  CFStringRef v0;
  int v1;
  unsigned int v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unsigned int v7;
  uint64_t v8;
  std::__shared_weak_count *v9;

  sub_1001E4804(&v8);
  v7 = 0;
  v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsConfigurationTableMaxRows", 0x8000100u, kCFAllocatorNull);
  v1 = sub_1000B1180(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  v2 = v7;
  v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  if (v1)
    return v2;
  else
    return 6666;
}

void sub_100302A04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  sub_100261F44((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100302A1C(void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 88;
        sub_100302AA0((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_100302AA0(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 87) < 0)
    operator delete(*(void **)(a2 + 64));
  if (*(char *)(a2 + 55) < 0)
    operator delete(*(void **)(a2 + 32));
}

void sub_100302AE4(void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 56;
        sub_100302B68((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_100302B68(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 47) < 0)
    operator delete(*(void **)(a2 + 24));
  if (*(char *)(a2 + 23) < 0)
    operator delete(*(void **)a2);
}

void sub_100302BAC(unint64_t *a1, unint64_t *a2, uint64_t a3, char a4)
{
  __int128 *v6;
  unint64_t *v7;
  unint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  __int128 v15;
  unint64_t v16;
  __int128 v17;
  __int128 v18;
  unint64_t v19;
  unint64_t v20;
  int v21;
  int v22;
  __int128 v23;
  unint64_t v24;
  __int128 v25;
  uint64_t v26;
  void **v27;
  __int128 v28;
  unint64_t v29;
  unint64_t v30;
  int v31;
  unint64_t *v32;
  __int128 *v33;
  __int128 *v34;
  unint64_t v35;
  unint64_t v36;
  int v37;
  unint64_t *v38;
  unint64_t v39;
  unint64_t v40;
  int v41;
  __int128 *v42;
  unint64_t *v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  int v47;
  __int128 *v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  int v52;
  unint64_t *v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  void **v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  BOOL v63;
  BOOL v64;
  unint64_t *v65;
  unint64_t v66;
  unint64_t v67;
  int v68;
  unint64_t *v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  int v73;
  __int128 *v74;
  __int128 *v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  int v79;
  unint64_t *v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  int v84;
  __int128 *v85;
  unint64_t v86;
  unint64_t v87;
  unint64_t v88;
  int v89;
  unint64_t *v90;
  void **v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  void **v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  unint64_t v101;
  unint64_t v102;
  unint64_t *v103;
  uint64_t v104;
  _BYTE *v105;
  unint64_t *v106;
  unint64_t *v107;
  unint64_t v108;
  unint64_t v109;
  int v110;
  __int128 v111;
  uint64_t v112;
  uint64_t v113;
  char *v114;
  void **v115;
  char *v116;
  unint64_t v117;
  unint64_t v118;
  int v119;
  uint64_t v120;
  __int128 v121;
  void **v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  int64_t v126;
  int64_t v127;
  int64_t v128;
  uint64_t v129;
  unint64_t *v130;
  unint64_t v131;
  unint64_t v132;
  int v133;
  unint64_t *v134;
  unint64_t v135;
  unint64_t v136;
  int v137;
  __int128 v138;
  unint64_t *v139;
  __int128 v140;
  __int128 v141;
  unint64_t *v142;
  __int128 v143;
  unint64_t *v144;
  __int128 v145;
  void **v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  unint64_t v150;
  unint64_t v151;
  int v152;
  unint64_t v153;
  unint64_t v154;
  int v155;
  void **v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  int64_t v161;
  uint64_t v162;
  __int128 v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  unint64_t v167;
  unint64_t v168;
  int v169;
  __int128 v170;
  void **v171;
  __int128 v172;
  __int128 v173;
  __int128 v174;
  void **v175;
  __int128 *v176;
  __int128 v177;
  __int128 v178;
  __int128 v179;
  void **v180;
  __int128 v181;
  unint64_t *v182;
  unint64_t *v183;
  __int128 v184;
  uint64_t v185;
  unint64_t v186;
  unint64_t *v187;
  unint64_t v188;
  unint64_t v189;
  __int128 v190;
  int v191;
  __int128 v192;
  __int128 v193;
  __int128 v194;
  __int128 v195;
  uint64_t v196;
  __int128 v197;
  void **v198;
  __int128 v199;
  __int128 v200;
  __int128 v201;
  unint64_t v202;
  unint64_t v203;
  int v204;
  void **v205;
  __int128 v206;
  __int128 v207;
  __int128 v208;
  __int128 v209;
  int v211;
  unint64_t *v212;
  unint64_t *i;
  unint64_t *v214;
  unint64_t v215;
  unint64_t v216;
  unint64_t *v217;
  int v218;
  __int128 v219;
  unint64_t *v220;
  void **v221;
  unint64_t v222;
  unint64_t v223;
  int v224;
  __int128 v225;
  void **v226;
  __int128 v227;
  __int128 v228;
  __int128 v229;
  __int128 *v230;
  __int128 *v232;
  __int128 v234;
  unint64_t v235;
  __int128 v236;
  unint64_t v237;
  _BYTE v238[28];
  _BYTE v239[136];
  __int128 v240;
  char v241;
  __int128 v242;
  unint64_t v243;
  __int128 __p;
  unint64_t v245;
  _OWORD v246[2];
  _BYTE v247[136];
  __int128 v248;
  char v249;

void sub_100304320(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,void *__p,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  if (a63 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void sub_1003043F4(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  unint64_t v10;
  unint64_t v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  int v15;
  unint64_t v16;
  unint64_t v17;
  int v18;
  unint64_t v19;
  unint64_t v20;
  int v21;

  sub_100304B5C(a1, a2, a3, a4);
  v10 = bswap64(*a5);
  v11 = bswap64(*a4);
  if (v10 != v11 || (v10 = bswap64(a5[1]), v11 = bswap64(a4[1]), v10 != v11))
  {
    v12 = v10 < v11 ? -1 : 1;
    if (v12 < 0)
    {
      sub_100302544((__int128 *)a4, (__int128 *)a5);
      v13 = bswap64(*a4);
      v14 = bswap64(*a3);
      if (v13 != v14 || (v13 = bswap64(a4[1]), v14 = bswap64(a3[1]), v13 != v14))
      {
        v15 = v13 < v14 ? -1 : 1;
        if (v15 < 0)
        {
          sub_100302544((__int128 *)a3, (__int128 *)a4);
          v16 = bswap64(*a3);
          v17 = bswap64(*a2);
          if (v16 != v17 || (v16 = bswap64(a3[1]), v17 = bswap64(a2[1]), v16 != v17))
          {
            v18 = v16 < v17 ? -1 : 1;
            if (v18 < 0)
            {
              sub_100302544((__int128 *)a2, (__int128 *)a3);
              v19 = bswap64(*a2);
              v20 = bswap64(*a1);
              if (v19 == v20 && (v19 = bswap64(a2[1]), v20 = bswap64(a1[1]), v19 == v20))
              {
                v21 = 0;
              }
              else if (v19 < v20)
              {
                v21 = -1;
              }
              else
              {
                v21 = 1;
              }
              if (v21 < 0)
                sub_100302544((__int128 *)a1, (__int128 *)a2);
            }
          }
        }
      }
    }
  }
}

void sub_1003045A0(unint64_t *a1, unint64_t *a2, unint64_t *a3)
{
  unint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  int v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  int v16;
  __int128 *v17;
  int v18;

  v5 = a1;
  v6 = bswap64(*a2);
  v7 = bswap64(*a1);
  if (v6 == v7 && (v6 = bswap64(a2[1]), v7 = bswap64(a1[1]), v6 == v7))
  {
    v8 = 0;
  }
  else if (v6 < v7)
  {
    v8 = -1;
  }
  else
  {
    v8 = 1;
  }
  v9 = bswap64(*a3);
  v10 = bswap64(*a2);
  if (v9 != v10 || (v9 = bswap64(a3[1]), v10 = bswap64(a2[1]), v9 != v10))
  {
    if (v9 < v10)
      v11 = -1;
    else
      v11 = 1;
    if (v8 < 0)
      goto LABEL_10;
LABEL_18:
    if (v11 < 0)
    {
      sub_100302544((__int128 *)a2, (__int128 *)a3);
      v14 = bswap64(*a2);
      v15 = bswap64(*v5);
      if (v14 != v15 || (v14 = bswap64(a2[1]), v15 = bswap64(v5[1]), v14 != v15))
      {
        v18 = v14 < v15 ? -1 : 1;
        if (v18 < 0)
        {
          a1 = v5;
          v17 = (__int128 *)a2;
          goto LABEL_34;
        }
      }
    }
    return;
  }
  v11 = 0;
  if ((v8 & 0x80000000) == 0)
    goto LABEL_18;
LABEL_10:
  if (v11 < 0)
  {
LABEL_27:
    v17 = (__int128 *)a3;
LABEL_34:
    sub_100302544((__int128 *)a1, v17);
    return;
  }
  sub_100302544((__int128 *)a1, (__int128 *)a2);
  v12 = bswap64(*a3);
  v13 = bswap64(*a2);
  if (v12 != v13 || (v12 = bswap64(a3[1]), v13 = bswap64(a2[1]), v12 != v13))
  {
    v16 = v12 < v13 ? -1 : 1;
    if (v16 < 0)
    {
      a1 = a2;
      goto LABEL_27;
    }
  }
}

BOOL sub_100304734(unint64_t *a1, unint64_t *a2)
{
  unint64_t *v2;
  unint64_t v4;
  _BOOL8 result;
  unint64_t v6;
  unint64_t v7;
  unint64_t *v8;
  unint64_t *v9;
  uint64_t v10;
  int v11;
  void **p_p;
  uint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  int v16;
  void **v17;
  uint64_t *v18;
  uint64_t v19;
  char *v20;
  void **v21;
  char *v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  int v26;
  uint64_t v27;
  char *v28;
  _OWORD *v29;
  uint64_t v30;
  int v31;
  unint64_t *v32;
  __int128 v33;
  unint64_t v34;
  void *__p;
  char v36;
  uint64_t v37;
  _BYTE v38[136];
  __int128 v39;
  char v40;

  v2 = a2;
  v4 = 0xEEEEEEEEEEEEEEEFLL * (((char *)a2 - (char *)a1) >> 4);
  result = 1;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      v6 = bswap64(*(a2 - 30));
      v7 = bswap64(*a1);
      if (v6 != v7 || (v6 = bswap64(*(a2 - 29)), v7 = bswap64(a1[1]), v6 != v7))
      {
        v31 = v6 < v7 ? -1 : 1;
        if (v31 < 0)
        {
          sub_100302544((__int128 *)a1, (__int128 *)a2 - 15);
          return 1;
        }
      }
      return result;
    case 3uLL:
      sub_1003045A0(a1, a1 + 30, a2 - 30);
      return 1;
    case 4uLL:
      sub_100304B5C(a1, a1 + 30, a1 + 60, a2 - 30);
      return 1;
    case 5uLL:
      sub_1003043F4(a1, a1 + 30, a1 + 60, a1 + 90, a2 - 30);
      return 1;
    default:
      v8 = a1 + 60;
      sub_1003045A0(a1, a1 + 30, a1 + 60);
      v9 = a1 + 90;
      if (a1 + 90 == v2)
        return 1;
      v10 = 0;
      v11 = 0;
      p_p = &__p;
      v13 = &v37;
      v32 = v2;
      break;
  }
  while (1)
  {
    v14 = bswap64(*v9);
    v15 = bswap64(*v8);
    if (v14 != v15 || (v14 = bswap64(v9[1]), v15 = bswap64(v8[1]), v14 != v15))
    {
      v16 = v14 < v15 ? -1 : 1;
      if (v16 < 0)
      {
        v33 = *(_OWORD *)v9;
        v34 = v9[2];
        *(_OWORD *)p_p = *(_OWORD *)(v9 + 3);
        v17 = p_p;
        p_p[2] = (void *)v9[5];
        v9[3] = 0;
        v9[4] = 0;
        v9[5] = 0;
        *(_OWORD *)v13 = *((_OWORD *)v9 + 3);
        v18 = v13;
        *(_OWORD *)((char *)v13 + 12) = *(_OWORD *)((char *)v9 + 60);
        sub_1002DF194(v38);
        v39 = *(_OWORD *)(v9 + 27);
        v40 = *((_BYTE *)v9 + 232);
        v19 = v10;
        while (1)
        {
          v20 = (char *)a1 + v19;
          *((_OWORD *)v20 + 45) = *(_OWORD *)((char *)a1 + v19 + 480);
          *((_QWORD *)v20 + 92) = *(unint64_t *)((char *)a1 + v19 + 496);
          v21 = (void **)((char *)a1 + v19 + 744);
          if (*((char *)a1 + v19 + 767) < 0)
            operator delete(*v21);
          *(unint64_t *)((char *)a1 + v19 + 760) = *((_QWORD *)v20 + 65);
          *(_OWORD *)v21 = *(_OWORD *)(v20 + 504);
          v20[527] = 0;
          v20[504] = 0;
          *((_OWORD *)v20 + 48) = *((_OWORD *)v20 + 33);
          *(_OWORD *)(v20 + 780) = *(_OWORD *)(v20 + 540);
          sub_1002E0BA0((uint64_t)(v20 + 800), (uint64_t)(v20 + 560));
          v22 = (char *)a1 + v19;
          v23 = (uint64_t)a1 + v19 + 696;
          *((_BYTE *)a1 + v19 + 952) = *((_BYTE *)a1 + v19 + 712);
          *(_OWORD *)((char *)a1 + v19 + 936) = *(_OWORD *)v23;
          if (v19 == -480)
            break;
          v24 = bswap64(v33);
          v25 = bswap64(*((_QWORD *)v22 + 30));
          if (v24 == v25
            && (v24 = bswap64(*((unint64_t *)&v33 + 1)), v25 = bswap64(*((_QWORD *)v22 + 31)), v24 == v25))
          {
            v26 = 0;
          }
          else if (v24 < v25)
          {
            v26 = -1;
          }
          else
          {
            v26 = 1;
          }
          v19 -= 240;
          if ((v26 & 0x80000000) == 0)
          {
            v27 = (uint64_t)a1 + v19 + 720;
            goto LABEL_26;
          }
        }
        v27 = (uint64_t)a1;
LABEL_26:
        *(_OWORD *)v27 = v33;
        *(_QWORD *)(v27 + 16) = v34;
        v28 = v22 + 504;
        if (*(char *)(v27 + 47) < 0)
          operator delete(*(void **)v28);
        v29 = v22 + 528;
        v30 = (uint64_t)(v22 + 560);
        p_p = v17;
        *(_OWORD *)v28 = *(_OWORD *)v17;
        *((_QWORD *)v28 + 2) = v17[2];
        v36 = 0;
        LOBYTE(__p) = 0;
        v13 = v18;
        *v29 = *(_OWORD *)v18;
        *(_OWORD *)((char *)v29 + 12) = *(_OWORD *)((char *)v18 + 12);
        sub_1002E0BA0(v30, (uint64_t)v38);
        *(_OWORD *)v23 = v39;
        *(_BYTE *)(v23 + 16) = v40;
        sub_1002DF2E0(v38);
        v2 = v32;
        if (v36 < 0)
          operator delete(__p);
        if (++v11 == 8)
          return v9 + 30 == v32;
      }
    }
    v8 = v9;
    v10 += 240;
    v9 += 30;
    if (v9 == v2)
      return 1;
  }
}

void sub_100304B2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  sub_1002B9370((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void sub_100304B5C(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  unint64_t v8;
  unint64_t v9;
  int v10;
  unint64_t v11;
  unint64_t v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  int v16;

  sub_1003045A0(a1, a2, a3);
  v8 = bswap64(*a4);
  v9 = bswap64(*a3);
  if (v8 != v9 || (v8 = bswap64(a4[1]), v9 = bswap64(a3[1]), v8 != v9))
  {
    v10 = v8 < v9 ? -1 : 1;
    if (v10 < 0)
    {
      sub_100302544((__int128 *)a3, (__int128 *)a4);
      v11 = bswap64(*a3);
      v12 = bswap64(*a2);
      if (v11 != v12 || (v11 = bswap64(a3[1]), v12 = bswap64(a2[1]), v11 != v12))
      {
        v13 = v11 < v12 ? -1 : 1;
        if (v13 < 0)
        {
          sub_100302544((__int128 *)a2, (__int128 *)a3);
          v14 = bswap64(*a2);
          v15 = bswap64(*a1);
          if (v14 != v15 || (v14 = bswap64(a2[1]), v15 = bswap64(a1[1]), v14 != v15))
          {
            if (v14 < v15)
              v16 = -1;
            else
              v16 = 1;
            if (v16 < 0)
              sub_100302544((__int128 *)a1, (__int128 *)a2);
          }
        }
      }
    }
  }
}

uint64_t sub_100304CA0(uint64_t a1, uint64_t a2, unsigned __int8 **a3)
{
  uint64_t v3;
  char v5;
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  uint64_t v8;
  unsigned __int8 *v9;
  uint64_t v10;

  v3 = a1;
  if (a1 != a2)
  {
    v5 = *((_BYTE *)a3 + 23);
    if (v5 >= 0)
      v6 = (unsigned __int8 *)*((unsigned __int8 *)a3 + 23);
    else
      v6 = a3[1];
    if (v5 >= 0)
      v7 = (unsigned __int8 *)a3;
    else
      v7 = *a3;
    do
    {
      v8 = *(unsigned __int8 *)(v3 + 23);
      if ((v8 & 0x80u) == 0)
        v9 = (unsigned __int8 *)*(unsigned __int8 *)(v3 + 23);
      else
        v9 = *(unsigned __int8 **)(v3 + 8);
      if (v9 == v6)
      {
        if ((v8 & 0x80) != 0)
        {
          if (!memcmp(*(const void **)v3, v7, *(_QWORD *)(v3 + 8)))
            return v3;
        }
        else
        {
          if (!*(_BYTE *)(v3 + 23))
            return v3;
          v10 = 0;
          while (*(unsigned __int8 *)(v3 + v10) == v7[v10])
          {
            if (v8 == ++v10)
              return v3;
          }
        }
      }
      v3 += 24;
    }
    while (v3 != a2);
    return a2;
  }
  return v3;
}

uint64_t sub_100304D54(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = sub_100304DC8((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_100304DC8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  _QWORD v13[3];
  char v14;
  __int128 v15;
  __int128 v16;

  v7 = a7;
  *(_QWORD *)&v16 = a6;
  *((_QWORD *)&v16 + 1) = a7;
  v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    v11 = a6;
  }
  else
  {
    v8 = a7;
    do
    {
      v9 = *(_OWORD *)(a3 - 56);
      *(_QWORD *)(v8 - 40) = *(_QWORD *)(a3 - 40);
      *(_OWORD *)(v8 - 56) = v9;
      *(_QWORD *)(a3 - 48) = 0;
      *(_QWORD *)(a3 - 40) = 0;
      *(_QWORD *)(a3 - 56) = 0;
      v10 = *(_OWORD *)(a3 - 32);
      *(_QWORD *)(v8 - 16) = *(_QWORD *)(a3 - 16);
      *(_OWORD *)(v8 - 32) = v10;
      *(_QWORD *)(a3 - 24) = 0;
      *(_QWORD *)(a3 - 16) = 0;
      *(_QWORD *)(a3 - 32) = 0;
      *(_QWORD *)(v8 - 8) = *(_QWORD *)(a3 - 8);
      v8 -= 56;
      v7 -= 56;
      a3 -= 56;
    }
    while (a3 != a5);
    *((_QWORD *)&v16 + 1) = v8;
    v11 = v16;
  }
  v14 = 1;
  sub_100304E8C((uint64_t)v13);
  return v11;
}

uint64_t sub_100304E8C(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    sub_100304EC0((uint64_t *)a1);
  return a1;
}

void sub_100304EC0(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(_QWORD *)(a1[2] + 8);
  v2 = *(_QWORD *)(a1[1] + 8);
  if (v1 != v2)
  {
    v3 = *a1;
    do
    {
      sub_100302B68(v3, v1);
      v1 += 56;
    }
    while (v1 != v2);
  }
}

void **sub_100304F10(void **a1)
{
  sub_100304F40(a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void sub_100304F40(_QWORD *a1)
{
  uint64_t i;
  uint64_t v2;
  uint64_t v4;

  v2 = a1[1];
  for (i = a1[2]; i != v2; i = a1[2])
  {
    v4 = a1[4];
    a1[2] = i - 56;
    sub_100302B68(v4, i - 56);
  }
}

__int128 *sub_100304F84(uint64_t *a1, __int128 *a2, __int128 *a3, __int128 *a4, uint64_t a5)
{
  __int128 *v5;
  __int128 *v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  __int128 *v21;
  char *v22;
  uint64_t v23;
  char *v24;
  void *v26[2];
  char *v27;
  char *v28;
  uint64_t v29;

  v5 = a2;
  if (a5 >= 1)
  {
    v7 = a3;
    v11 = a1[2];
    v9 = (uint64_t)(a1 + 2);
    v10 = v11;
    v12 = *(_QWORD *)(v9 - 8);
    if ((uint64_t)(0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v11 - v12) >> 4)) >= a5)
    {
      v20 = v12 - (_QWORD)a2;
      if ((uint64_t)(0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v12 - (_QWORD)a2) >> 4)) >= a5)
      {
        v21 = &a3[15 * a5];
      }
      else
      {
        v21 = &a3[(uint64_t)(v12 - (_QWORD)a2) >> 4];
        a1[1] = sub_1003052CC(v9, v21, a4, *(_QWORD *)(v9 - 8));
        if (v20 < 1)
          return v5;
      }
      sub_100305174((uint64_t)a1, (uint64_t)v5, v12, (uint64_t)&v5[15 * a5]);
      sub_1002711D4((uint64_t)v26, v7, v21, (uint64_t)v5);
    }
    else
    {
      v13 = *a1;
      v14 = a5 - 0x1111111111111111 * ((uint64_t)(v12 - *a1) >> 4);
      if (v14 > 0x111111111111111)
        sub_100259694();
      v15 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)a2 - v13) >> 4);
      v16 = 0xEEEEEEEEEEEEEEEFLL * ((v10 - v13) >> 4);
      v17 = 2 * v16;
      if (2 * v16 <= v14)
        v17 = v14;
      if (v16 >= 0x88888888888888)
        v18 = 0x111111111111111;
      else
        v18 = v17;
      v29 = v9;
      if (v18)
        v19 = (char *)sub_100273E28(v9, v18);
      else
        v19 = 0;
      v22 = &v19[240 * v15];
      v26[0] = v19;
      v26[1] = v22;
      v27 = v22;
      v28 = &v19[240 * v18];
      v23 = 240 * a5;
      v24 = &v22[240 * a5];
      do
      {
        sub_100305374(v29, (uint64_t)v22, v7);
        v22 += 240;
        v7 += 15;
        v23 -= 240;
      }
      while (v23);
      v27 = v24;
      v5 = (__int128 *)sub_10030521C((uint64_t)a1, v26, v5);
      sub_100273FB8(v26);
    }
  }
  return v5;
}

void sub_100305148(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  uint64_t v12;
  uint64_t v13;

  *(_QWORD *)(v12 + 8) = v13;
  _Unwind_Resume(exception_object);
}

uint64_t sub_100305174(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  __int128 *v10;
  char v12;

  v6 = *(_QWORD *)(a1 + 8);
  v7 = a2 + v6 - a4;
  v8 = v6;
  if (v7 < a3)
  {
    v10 = (__int128 *)(a2 + v6 - a4);
    v8 = *(_QWORD *)(a1 + 8);
    do
    {
      sub_100305374(a1 + 16, v8, v10);
      v10 += 15;
      v8 += 240;
    }
    while ((unint64_t)v10 < a3);
  }
  *(_QWORD *)(a1 + 8) = v8;
  return sub_100305410((uint64_t)&v12, a2, v7, v6);
}

void sub_100305214(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_10030521C(uint64_t a1, _QWORD *a2, __int128 *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v6 = a2[1];
  v7 = a1 + 16;
  sub_100273E6C(a1 + 16, (uint64_t)a3, a3, *(_QWORD *)a1, *(__int128 **)a1, v6, v6);
  a2[1] = v8;
  a2[2] = sub_1003054E4(v7, a3, *(__int128 **)(a1 + 8), a2[2]);
  v9 = *(_QWORD *)a1;
  *(_QWORD *)a1 = a2[1];
  a2[1] = v9;
  v10 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = a2[2];
  a2[2] = v10;
  v11 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = a2[3];
  a2[3] = v11;
  *a2 = a2[1];
  return v6;
}

uint64_t sub_1003052CC(uint64_t a1, __int128 *a2, __int128 *a3, uint64_t a4)
{
  uint64_t v4;
  __int128 *v6;
  _QWORD v9[3];
  char v10;
  uint64_t v11;
  uint64_t v12;

  v4 = a4;
  v11 = a4;
  v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  v10 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      sub_100305374(a1, v4, v6);
      v6 += 15;
      v4 = v12 + 240;
      v12 += 240;
    }
    while (v6 != a3);
  }
  v10 = 1;
  sub_1002B9B38((uint64_t)v9);
  return v4;
}

void sub_100305360(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1002B9B38((uint64_t)&a9);
  _Unwind_Resume(a1);
}

__n128 sub_100305374(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __n128 result;

  v5 = *a3;
  *(_QWORD *)(a2 + 16) = *((_QWORD *)a3 + 2);
  *(_OWORD *)a2 = v5;
  v6 = *(__int128 *)((char *)a3 + 24);
  *(_QWORD *)(a2 + 40) = *((_QWORD *)a3 + 5);
  *(_OWORD *)(a2 + 24) = v6;
  *((_QWORD *)a3 + 4) = 0;
  *((_QWORD *)a3 + 5) = 0;
  *((_QWORD *)a3 + 3) = 0;
  v7 = a3[3];
  *(_OWORD *)(a2 + 60) = *(__int128 *)((char *)a3 + 60);
  *(_OWORD *)(a2 + 48) = v7;
  sub_1002DF194(a2 + 80);
  result = *(__n128 *)((char *)a3 + 216);
  *(_BYTE *)(a2 + 232) = *((_BYTE *)a3 + 232);
  *(__n128 *)(a2 + 216) = result;
  return result;
}

void sub_1003053F4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 47) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

uint64_t sub_100305410(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  void **v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;

  if (a3 != a2)
  {
    v7 = 0;
    do
    {
      v8 = a3 + v7;
      v9 = a4 + v7;
      v10 = *(_OWORD *)(a3 + v7 - 240);
      *(_QWORD *)(v9 - 224) = *(_QWORD *)(a3 + v7 - 224);
      *(_OWORD *)(v9 - 240) = v10;
      v11 = (void **)(a4 + v7 - 216);
      if (*(char *)(a4 + v7 - 193) < 0)
        operator delete(*v11);
      v12 = *(_OWORD *)(v8 - 216);
      *(_QWORD *)(a4 + v7 - 200) = *(_QWORD *)(v8 - 200);
      *(_OWORD *)v11 = v12;
      *(_BYTE *)(v8 - 193) = 0;
      *(_BYTE *)(v8 - 216) = 0;
      v13 = *(_OWORD *)(v8 - 192);
      *(_OWORD *)(v9 - 180) = *(_OWORD *)(v8 - 180);
      *(_OWORD *)(v9 - 192) = v13;
      sub_1002E0BA0(v9 - 160, v8 - 160);
      v14 = *(_OWORD *)(v8 - 24);
      *(_BYTE *)(v9 - 8) = *(_BYTE *)(v8 - 8);
      *(_OWORD *)(v9 - 24) = v14;
      v7 -= 240;
    }
    while (a3 + v7 != a2);
  }
  return a3;
}

uint64_t sub_1003054E4(uint64_t a1, __int128 *a2, __int128 *a3, uint64_t a4)
{
  uint64_t v4;
  __int128 *v6;
  _QWORD v9[3];
  char v10;
  uint64_t v11;
  uint64_t v12;

  v4 = a4;
  v11 = a4;
  v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  v10 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      sub_100273D04(a1, v4, v6);
      v6 += 15;
      v4 = v12 + 240;
      v12 += 240;
    }
    while (v6 != a3);
  }
  v10 = 1;
  sub_1002B9B38((uint64_t)v9);
  return v4;
}

void sub_100305578(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1002B9B38((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_10030558C(void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 80;
        sub_10029D400((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_100305610(void **a1)
{
  void *v1;
  uint64_t v3;
  void *v4;

  v1 = *a1;
  if (*a1)
  {
    v3 = (uint64_t)a1[1];
    v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 80;
        sub_10029D400((uint64_t)(a1 + 2), v3);
      }
      while ((void *)v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t sub_10030567C(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v5;
  unint64_t v6;
  unint64_t v10;
  char *v11;
  uint64_t v12;
  void *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t *v18;

  v5 = 0x6DB6DB6DB6DB6DB7 * ((a1[1] - *a1) >> 4);
  v6 = v5 + 1;
  if ((unint64_t)(v5 + 1) > 0x249249249249249)
    sub_100259694();
  if (0xDB6DB6DB6DB6DB6ELL * ((a1[2] - *a1) >> 4) > v6)
    v6 = 0xDB6DB6DB6DB6DB6ELL * ((a1[2] - *a1) >> 4);
  if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((a1[2] - *a1) >> 4)) >= 0x124924924924924)
    v10 = 0x249249249249249;
  else
    v10 = v6;
  v18 = a1 + 2;
  if (v10)
    v11 = (char *)sub_1002A7588((uint64_t)(a1 + 2), v10);
  else
    v11 = 0;
  v14 = v11;
  v15 = &v11[112 * v5];
  v17 = &v11[112 * v10];
  sub_1003057B8((uint64_t)(a1 + 2), (uint64_t)v15, a2, a3, a4);
  v16 = v15 + 112;
  sub_1002A7514(a1, &v14);
  v12 = a1[1];
  sub_1002A77F0(&v14);
  return v12;
}

void sub_1003057A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1002A77F0((void **)va);
  _Unwind_Resume(a1);
}

void sub_1003057B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  void *__p[2];
  uint64_t v9;

  if (*(char *)(a3 + 23) < 0)
  {
    sub_100115CE4(__p, *(void **)a3, *(_QWORD *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)__p = *(_OWORD *)a3;
    v9 = *(_QWORD *)(a3 + 16);
  }
  sub_1002A4048(a2, (__int128 *)__p, a4, *a5, a5[1]);
  if (SHIBYTE(v9) < 0)
    operator delete(__p[0]);
}

void sub_100305838(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_100305854(unint64_t *a1, unint64_t *a2, uint64_t a3, char a4)
{
  __int128 *v6;
  unint64_t *v7;
  unint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  __int128 v15;
  unint64_t v16;
  __int128 v17;
  __int128 v18;
  unint64_t v19;
  unint64_t v20;
  int v21;
  int v22;
  __int128 v23;
  unint64_t v24;
  __int128 v25;
  uint64_t v26;
  void **v27;
  __int128 v28;
  unint64_t v29;
  unint64_t v30;
  int v31;
  unint64_t *v32;
  __int128 *v33;
  __int128 *v34;
  unint64_t v35;
  unint64_t v36;
  int v37;
  unint64_t *v38;
  unint64_t v39;
  unint64_t v40;
  int v41;
  __int128 *v42;
  unint64_t *v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  int v47;
  __int128 *v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  int v52;
  unint64_t *v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  void **v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  BOOL v63;
  BOOL v64;
  unint64_t *v65;
  unint64_t v66;
  unint64_t v67;
  int v68;
  unint64_t *v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  int v73;
  __int128 *v74;
  __int128 *v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  int v79;
  unint64_t *v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  int v84;
  __int128 *v85;
  unint64_t v86;
  unint64_t v87;
  unint64_t v88;
  int v89;
  unint64_t *v90;
  void **v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  void **v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  unint64_t v101;
  unint64_t v102;
  unint64_t *v103;
  uint64_t v104;
  _BYTE *v105;
  unint64_t *v106;
  unint64_t *v107;
  unint64_t v108;
  unint64_t v109;
  int v110;
  __int128 v111;
  uint64_t v112;
  uint64_t v113;
  char *v114;
  void **v115;
  char *v116;
  unint64_t v117;
  unint64_t v118;
  int v119;
  uint64_t v120;
  __int128 v121;
  void **v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  int64_t v126;
  int64_t v127;
  int64_t v128;
  uint64_t v129;
  unint64_t *v130;
  unint64_t v131;
  unint64_t v132;
  int v133;
  unint64_t *v134;
  unint64_t v135;
  unint64_t v136;
  int v137;
  __int128 v138;
  unint64_t *v139;
  __int128 v140;
  __int128 v141;
  unint64_t *v142;
  __int128 v143;
  unint64_t *v144;
  __int128 v145;
  void **v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  unint64_t v150;
  unint64_t v151;
  int v152;
  unint64_t v153;
  unint64_t v154;
  int v155;
  void **v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  int64_t v161;
  uint64_t v162;
  __int128 v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  unint64_t v167;
  unint64_t v168;
  int v169;
  __int128 v170;
  void **v171;
  __int128 v172;
  __int128 v173;
  __int128 v174;
  void **v175;
  __int128 *v176;
  __int128 v177;
  __int128 v178;
  __int128 v179;
  void **v180;
  __int128 v181;
  unint64_t *v182;
  unint64_t *v183;
  __int128 v184;
  uint64_t v185;
  unint64_t v186;
  unint64_t *v187;
  unint64_t v188;
  unint64_t v189;
  __int128 v190;
  int v191;
  __int128 v192;
  __int128 v193;
  __int128 v194;
  __int128 v195;
  uint64_t v196;
  __int128 v197;
  void **v198;
  __int128 v199;
  __int128 v200;
  __int128 v201;
  unint64_t v202;
  unint64_t v203;
  int v204;
  void **v205;
  __int128 v206;
  __int128 v207;
  __int128 v208;
  __int128 v209;
  int v211;
  unint64_t *v212;
  unint64_t *i;
  unint64_t *v214;
  unint64_t v215;
  unint64_t v216;
  unint64_t *v217;
  int v218;
  __int128 v219;
  unint64_t *v220;
  void **v221;
  unint64_t v222;
  unint64_t v223;
  int v224;
  __int128 v225;
  void **v226;
  __int128 v227;
  __int128 v228;
  __int128 v229;
  __int128 *v230;
  __int128 *v232;
  __int128 v234;
  unint64_t v235;
  __int128 v236;
  unint64_t v237;
  _BYTE v238[28];
  _BYTE v239[136];
  __int128 v240;
  char v241;
  __int128 v242;
  unint64_t v243;
  __int128 __p;
  unint64_t v245;
  _OWORD v246[2];
  _BYTE v247[136];
  __int128 v248;
  char v249;

void sub_100306FC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,void *__p,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  if (a63 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

BOOL sub_10030709C(unint64_t *a1, unint64_t *a2)
{
  unint64_t *v2;
  unint64_t v4;
  _BOOL8 result;
  unint64_t v6;
  unint64_t v7;
  unint64_t *v8;
  unint64_t *v9;
  uint64_t v10;
  int v11;
  void **p_p;
  uint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  int v16;
  void **v17;
  uint64_t *v18;
  uint64_t v19;
  char *v20;
  void **v21;
  char *v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  int v26;
  uint64_t v27;
  char *v28;
  _OWORD *v29;
  uint64_t v30;
  int v31;
  unint64_t *v32;
  __int128 v33;
  unint64_t v34;
  void *__p;
  char v36;
  uint64_t v37;
  _BYTE v38[136];
  __int128 v39;
  char v40;

  v2 = a2;
  v4 = 0xEEEEEEEEEEEEEEEFLL * (((char *)a2 - (char *)a1) >> 4);
  result = 1;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      v6 = bswap64(*(a2 - 30));
      v7 = bswap64(*a1);
      if (v6 != v7 || (v6 = bswap64(*(a2 - 29)), v7 = bswap64(a1[1]), v6 != v7))
      {
        v31 = v6 < v7 ? -1 : 1;
        if (v31 < 0)
        {
          sub_100302544((__int128 *)a1, (__int128 *)a2 - 15);
          return 1;
        }
      }
      return result;
    case 3uLL:
      sub_1003045A0(a1, a1 + 30, a2 - 30);
      return 1;
    case 4uLL:
      sub_100304B5C(a1, a1 + 30, a1 + 60, a2 - 30);
      return 1;
    case 5uLL:
      sub_1003043F4(a1, a1 + 30, a1 + 60, a1 + 90, a2 - 30);
      return 1;
    default:
      v8 = a1 + 60;
      sub_1003045A0(a1, a1 + 30, a1 + 60);
      v9 = a1 + 90;
      if (a1 + 90 == v2)
        return 1;
      v10 = 0;
      v11 = 0;
      p_p = &__p;
      v13 = &v37;
      v32 = v2;
      break;
  }
  while (1)
  {
    v14 = bswap64(*v9);
    v15 = bswap64(*v8);
    if (v14 != v15 || (v14 = bswap64(v9[1]), v15 = bswap64(v8[1]), v14 != v15))
    {
      v16 = v14 < v15 ? -1 : 1;
      if (v16 < 0)
      {
        v33 = *(_OWORD *)v9;
        v34 = v9[2];
        *(_OWORD *)p_p = *(_OWORD *)(v9 + 3);
        v17 = p_p;
        p_p[2] = (void *)v9[5];
        v9[3] = 0;
        v9[4] = 0;
        v9[5] = 0;
        *(_OWORD *)v13 = *((_OWORD *)v9 + 3);
        v18 = v13;
        *(_OWORD *)((char *)v13 + 12) = *(_OWORD *)((char *)v9 + 60);
        sub_1002DF194(v38);
        v39 = *(_OWORD *)(v9 + 27);
        v40 = *((_BYTE *)v9 + 232);
        v19 = v10;
        while (1)
        {
          v20 = (char *)a1 + v19;
          *((_OWORD *)v20 + 45) = *(_OWORD *)((char *)a1 + v19 + 480);
          *((_QWORD *)v20 + 92) = *(unint64_t *)((char *)a1 + v19 + 496);
          v21 = (void **)((char *)a1 + v19 + 744);
          if (*((char *)a1 + v19 + 767) < 0)
            operator delete(*v21);
          *(unint64_t *)((char *)a1 + v19 + 760) = *((_QWORD *)v20 + 65);
          *(_OWORD *)v21 = *(_OWORD *)(v20 + 504);
          v20[527] = 0;
          v20[504] = 0;
          *((_OWORD *)v20 + 48) = *((_OWORD *)v20 + 33);
          *(_OWORD *)(v20 + 780) = *(_OWORD *)(v20 + 540);
          sub_1002E0BA0((uint64_t)(v20 + 800), (uint64_t)(v20 + 560));
          v22 = (char *)a1 + v19;
          v23 = (uint64_t)a1 + v19 + 696;
          *((_BYTE *)a1 + v19 + 952) = *((_BYTE *)a1 + v19 + 712);
          *(_OWORD *)((char *)a1 + v19 + 936) = *(_OWORD *)v23;
          if (v19 == -480)
            break;
          v24 = bswap64(v33);
          v25 = bswap64(*((_QWORD *)v22 + 30));
          if (v24 == v25
            && (v24 = bswap64(*((unint64_t *)&v33 + 1)), v25 = bswap64(*((_QWORD *)v22 + 31)), v24 == v25))
          {
            v26 = 0;
          }
          else if (v24 < v25)
          {
            v26 = -1;
          }
          else
          {
            v26 = 1;
          }
          v19 -= 240;
          if ((v26 & 0x80000000) == 0)
          {
            v27 = (uint64_t)a1 + v19 + 720;
            goto LABEL_26;
          }
        }
        v27 = (uint64_t)a1;
LABEL_26:
        *(_OWORD *)v27 = v33;
        *(_QWORD *)(v27 + 16) = v34;
        v28 = v22 + 504;
        if (*(char *)(v27 + 47) < 0)
          operator delete(*(void **)v28);
        v29 = v22 + 528;
        v30 = (uint64_t)(v22 + 560);
        p_p = v17;
        *(_OWORD *)v28 = *(_OWORD *)v17;
        *((_QWORD *)v28 + 2) = v17[2];
        v36 = 0;
        LOBYTE(__p) = 0;
        v13 = v18;
        *v29 = *(_OWORD *)v18;
        *(_OWORD *)((char *)v29 + 12) = *(_OWORD *)((char *)v18 + 12);
        sub_1002E0BA0(v30, (uint64_t)v38);
        *(_OWORD *)v23 = v39;
        *(_BYTE *)(v23 + 16) = v40;
        sub_1002DF2E0(v38);
        v2 = v32;
        if (v36 < 0)
          operator delete(__p);
        if (++v11 == 8)
          return v9 + 30 == v32;
      }
    }
    v8 = v9;
    v10 += 240;
    v9 += 30;
    if (v9 == v2)
      return 1;
  }
}

void sub_100307494(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  sub_1002B9370((uint64_t)&a13);
  _Unwind_Resume(a1);
}

_QWORD *sub_1003074C4(_QWORD *a1, _OWORD *a2)
{
  _QWORD *v4;

  sub_100307518((uint64_t)a1, a2, (uint64_t)&v4);
  return sub_100270234(a1, v4);
}

void sub_1003074FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_OWORD *sub_100307518@<X0>(uint64_t a1@<X0>, _OWORD *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  _OWORD *result;
  uint64_t v7;
  unint64_t v8;
  __int128 v9;

  v5 = a1 + 16;
  result = operator new(0x30uLL);
  v7 = 0;
  v8 = 0;
  *(_QWORD *)a3 = result;
  *(_QWORD *)(a3 + 8) = v5;
  *(_QWORD *)result = 0;
  v9 = a2[1];
  result[1] = *a2;
  result[2] = v9;
  *(_BYTE *)(a3 + 16) = 1;
  do
    v8 ^= (v8 << 6) + (v8 >> 2) + 2654435769u + *((unsigned __int8 *)result + v7++ + 16);
  while (v7 != 16);
  *((_QWORD *)result + 1) = v8;
  return result;
}

char *sub_1003075A0(uint64_t a1, char *__src, _QWORD *a3, _QWORD *a4, uint64_t a5)
{
  char *v5;
  _QWORD *v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  _BYTE *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  unint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  char *v24;
  uint64_t v25;
  char *v26;
  _QWORD *v27;
  _OWORD *v28;
  char *v29;
  char *v30;
  char *v31;
  __int128 v32;
  char *v33;
  void *__p;
  char *v36;
  char *v37;
  char *v38;
  uint64_t v39;

  v5 = __src;
  if (a5 >= 1)
  {
    v7 = a3;
    v11 = *(_QWORD *)(a1 + 16);
    v9 = a1 + 16;
    v10 = v11;
    v12 = *(_QWORD *)(v9 - 8);
    if (a5 <= (uint64_t)(v11 - v12) >> 4)
    {
      v19 = a5 + 1;
      v20 = a3;
      do
      {
        v20 = (_QWORD *)*v20;
        --v19;
      }
      while (v19 > 1);
      v21 = (uint64_t)(v12 - (_QWORD)__src) >> 4;
      if (v21 >= a5)
      {
        v23 = *(char **)(v9 - 8);
        v21 = a5;
      }
      else
      {
        if ((uint64_t)(v12 - (_QWORD)__src) < 1)
        {
          v20 = a3;
        }
        else
        {
          v22 = v21 + 1;
          v20 = a3;
          do
          {
            v20 = (_QWORD *)*v20;
            --v22;
          }
          while (v22 > 1);
        }
        v23 = *(char **)(v9 - 8);
        if (v20 != a4)
        {
          v27 = v20;
          v28 = *(_OWORD **)(v9 - 8);
          do
          {
            *v28++ = *((_OWORD *)v27 + 1);
            v27 = (_QWORD *)*v27;
            v23 += 16;
          }
          while (v27 != a4);
        }
        *(_QWORD *)(a1 + 8) = v23;
      }
      if (v21 >= 1)
      {
        v29 = &__src[16 * a5];
        v30 = &v23[-16 * a5];
        v31 = v23;
        if ((unint64_t)v30 < v12)
        {
          v31 = v23;
          do
          {
            v32 = *(_OWORD *)v30;
            v30 += 16;
            *(_OWORD *)v31 = v32;
            v31 += 16;
          }
          while ((unint64_t)v30 < v12);
        }
        *(_QWORD *)(a1 + 8) = v31;
        if (v23 != v29)
          memmove(&v23[-16 * ((v23 - v29) >> 4)], __src, v23 - v29);
        if (v20 != v7)
        {
          v33 = v5;
          do
          {
            *(_OWORD *)v33 = *((_OWORD *)v7 + 1);
            v33 += 16;
            v7 = (_QWORD *)*v7;
          }
          while (v7 != v20);
        }
      }
    }
    else
    {
      v13 = *(_BYTE **)a1;
      v14 = a5 + ((uint64_t)(v12 - *(_QWORD *)a1) >> 4);
      if (v14 >> 60)
        sub_100259694();
      v15 = (__src - v13) >> 4;
      v16 = v10 - (_QWORD)v13;
      if (v16 >> 3 > v14)
        v14 = v16 >> 3;
      if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF0)
        v17 = 0xFFFFFFFFFFFFFFFLL;
      else
        v17 = v14;
      v39 = v9;
      if (v17)
        v18 = (char *)sub_10028E224(v9, v17);
      else
        v18 = 0;
      v24 = &v18[16 * v15];
      __p = v18;
      v36 = v24;
      v38 = &v18[16 * v17];
      v25 = 16 * a5;
      v26 = &v24[16 * a5];
      do
      {
        *(_OWORD *)v24 = *((_OWORD *)v7 + 1);
        v24 += 16;
        v7 = (_QWORD *)*v7;
        v25 -= 16;
      }
      while (v25);
      v37 = v26;
      v5 = (char *)sub_1002F51A8((void **)a1, (uint64_t)&__p, v5);
      if (v37 != v36)
        v37 += (v36 - v37 + 15) & 0xFFFFFFFFFFFFFFF0;
      if (__p)
        operator delete(__p);
    }
  }
  return v5;
}

void sub_1003077C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *sub_100307800(_QWORD *a1, _QWORD *a2)
{
  _QWORD *result;
  _QWORD *v4;

  result = sub_1002710E8(a1, a2);
  if (result)
  {
    v4 = result;
    do
    {
      v4 = (_QWORD *)*v4;
      if (!v4)
        break;
    }
    while (v4[2] == *a2 && v4[3] == a2[1]);
  }
  return result;
}

void sub_10030784C(uint64_t a1, __n128 *a2, uint64_t a3, char a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  __int128 v13;
  double v14;
  uint64_t v15;
  double v16;
  unint64_t v17;
  __n128 *v18;
  __n128 *v19;
  double v20;
  __n128 *v21;
  double v22;
  __n128 *v23;
  __n128 v24;
  double v25;
  double v26;
  _OWORD *v27;
  __int128 v28;
  BOOL v29;
  uint64_t v30;
  double v31;
  unint64_t v32;
  double v33;
  __n128 *v34;
  __n128 *v35;
  double v36;
  __n128 v37;
  double v38;
  double v39;
  _OWORD *v40;
  __int128 v41;
  __n128 v42;
  __n128 *v43;
  __n128 *v44;
  __n128 *v45;
  __n128 v46;
  __n128 v47;
  __int128 v48;
  __n128 v49;
  __int128 v50;
  __int128 v51;
  __n128 v52;
  __int128 v53;
  __int128 v54;
  __n128 *v55;
  BOOL v57;
  uint64_t v58;
  unint64_t v59;
  double v60;
  double v61;
  uint64_t v62;
  uint64_t v63;
  __int128 v64;
  uint64_t v65;
  int64_t v66;
  int64_t v67;
  int64_t v68;
  uint64_t v69;
  unint64_t v70;
  double v71;
  unint64_t v72;
  _OWORD *v73;
  __int128 v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  _OWORD *v80;
  uint64_t v81;
  uint64_t v82;
  __int128 v83;
  __n128 v84;
  uint64_t v85;
  unint64_t v86;
  double v87;
  _OWORD *v88;
  __int128 v89;
  double v91;
  double v92;
  __n128 *v93;
  __n128 v94;
  double v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  __int128 v102;
  __n128 v103;
  __n128 v104;
  __n128 v105;
  __n128 v106;
  __n128 v107;
  __int128 v108;
  __n128 v109;
  __n128 v110;
  __int128 v111;
  __n128 v112;
  __n128 v113;
  __n128 v114;
  __n128 v115;
  __int128 v116;
  uint64_t v117;
  uint64_t v118;
  __n128 v119;
  uint64_t v120;

double *sub_100308078(double *result, double *a2, double *a3)
{
  double v3;
  double v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;

  v3 = a2[3];
  v4 = a3[3];
  if (result[3] >= v3)
  {
    if (v3 < v4)
    {
      v9 = *(_OWORD *)a2;
      v8 = *((_OWORD *)a2 + 1);
      v10 = *((_OWORD *)a3 + 1);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((_OWORD *)a2 + 1) = v10;
      *(_OWORD *)a3 = v9;
      *((_OWORD *)a3 + 1) = v8;
      if (result[3] < a2[3])
      {
        v12 = *(_OWORD *)result;
        v11 = *((_OWORD *)result + 1);
        v13 = *((_OWORD *)a2 + 1);
        *(_OWORD *)result = *(_OWORD *)a2;
        *((_OWORD *)result + 1) = v13;
        *(_OWORD *)a2 = v12;
        *((_OWORD *)a2 + 1) = v11;
      }
    }
  }
  else
  {
    if (v3 >= v4)
    {
      v15 = *(_OWORD *)result;
      v14 = *((_OWORD *)result + 1);
      v16 = *((_OWORD *)a2 + 1);
      *(_OWORD *)result = *(_OWORD *)a2;
      *((_OWORD *)result + 1) = v16;
      *(_OWORD *)a2 = v15;
      *((_OWORD *)a2 + 1) = v14;
      if (a2[3] >= a3[3])
        return result;
      v6 = *(_OWORD *)a2;
      v5 = *((_OWORD *)a2 + 1);
      v17 = *((_OWORD *)a3 + 1);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((_OWORD *)a2 + 1) = v17;
    }
    else
    {
      v6 = *(_OWORD *)result;
      v5 = *((_OWORD *)result + 1);
      v7 = *((_OWORD *)a3 + 1);
      *(_OWORD *)result = *(_OWORD *)a3;
      *((_OWORD *)result + 1) = v7;
    }
    *(_OWORD *)a3 = v6;
    *((_OWORD *)a3 + 1) = v5;
  }
  return result;
}

BOOL sub_100308154(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int128 v6;
  __n128 v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  double v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  __n128 *v18;
  __n128 *v19;
  __n128 *v20;
  __int128 v21;
  __n128 v22;
  __int128 v23;
  __int128 v24;
  __n128 v25;
  __int128 v26;
  __int128 v27;
  __n128 v28;
  __int128 v29;
  __int128 v30;
  __n128 v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;

  v4 = (a2 - a1) >> 5;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (*(double *)(a1 + 24) < *(double *)(a2 - 8))
      {
        v7 = *(__n128 *)a1;
        v6 = *(_OWORD *)(a1 + 16);
        v8 = *(_OWORD *)(a2 - 16);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 32);
        *(_OWORD *)(a1 + 16) = v8;
        *(__n128 *)(a2 - 32) = v7;
        *(_OWORD *)(a2 - 16) = v6;
      }
      return result;
    case 3:
      sub_100308078((double *)a1, (double *)(a1 + 32), (double *)(a2 - 32));
      return 1;
    case 4:
      sub_1003083A4((__n128 *)a1, (__n128 *)(a1 + 32), (__n128 *)(a1 + 64), (__n128 *)(a2 - 32));
      return 1;
    case 5:
      v18 = (__n128 *)(a1 + 32);
      v19 = (__n128 *)(a1 + 64);
      v20 = (__n128 *)(a1 + 96);
      sub_1003083A4((__n128 *)a1, (__n128 *)(a1 + 32), (__n128 *)(a1 + 64), (__n128 *)(a1 + 96));
      if (*(double *)(a1 + 120) < *(double *)(a2 - 8))
      {
        v22 = *v20;
        v21 = *(_OWORD *)(a1 + 112);
        v23 = *(_OWORD *)(a2 - 16);
        *v20 = *(__n128 *)(a2 - 32);
        *(_OWORD *)(a1 + 112) = v23;
        *(__n128 *)(a2 - 32) = v22;
        *(_OWORD *)(a2 - 16) = v21;
        if (*(double *)(a1 + 88) < *(double *)(a1 + 120))
        {
          v25 = *v19;
          v24 = *(_OWORD *)(a1 + 80);
          v26 = *(_OWORD *)(a1 + 112);
          *v19 = *v20;
          *(_OWORD *)(a1 + 80) = v26;
          *v20 = v25;
          *(_OWORD *)(a1 + 112) = v24;
          if (*(double *)(a1 + 56) < *(double *)(a1 + 88))
          {
            v28 = *v18;
            v27 = *(_OWORD *)(a1 + 48);
            v29 = *(_OWORD *)(a1 + 80);
            *v18 = *v19;
            *(_OWORD *)(a1 + 48) = v29;
            *v19 = v28;
            *(_OWORD *)(a1 + 80) = v27;
            if (*(double *)(a1 + 24) < *(double *)(a1 + 56))
            {
              v31 = *(__n128 *)a1;
              v30 = *(_OWORD *)(a1 + 16);
              v32 = *(_OWORD *)(a1 + 48);
              *(__n128 *)a1 = *v18;
              *(_OWORD *)(a1 + 16) = v32;
              *v18 = v31;
              *(_OWORD *)(a1 + 48) = v30;
            }
          }
        }
      }
      return 1;
    default:
      v9 = a1 + 64;
      sub_100308078((double *)a1, (double *)(a1 + 32), (double *)(a1 + 64));
      v10 = a1 + 96;
      if (a1 + 96 == a2)
        return 1;
      v11 = 0;
      v12 = 0;
      break;
  }
  while (1)
  {
    v13 = *(double *)(v10 + 24);
    if (*(double *)(v9 + 24) < v13)
    {
      v33 = *(_OWORD *)v10;
      v34 = *(_QWORD *)(v10 + 16);
      v14 = v11;
      while (1)
      {
        v15 = a1 + v14;
        v16 = *(_OWORD *)(a1 + v14 + 80);
        *(_OWORD *)(v15 + 96) = *(_OWORD *)(a1 + v14 + 64);
        *(_OWORD *)(v15 + 112) = v16;
        if (v14 == -64)
          break;
        v14 -= 32;
        if (*(double *)(v15 + 56) >= v13)
        {
          v17 = a1 + v14 + 96;
          goto LABEL_12;
        }
      }
      v17 = a1;
LABEL_12:
      *(_OWORD *)v17 = v33;
      *(_QWORD *)(v17 + 16) = v34;
      *(double *)(v17 + 24) = v13;
      if (++v12 == 8)
        return v10 + 32 == a2;
    }
    v9 = v10;
    v11 += 32;
    v10 += 32;
    if (v10 == a2)
      return 1;
  }
}

__n128 sub_1003083A4(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4)
{
  __n128 result;
  __n128 v9;
  __n128 v10;
  __n128 v11;
  __n128 v12;
  __n128 v13;
  __n128 v14;

  sub_100308078(a1->n128_f64, a2->n128_f64, a3->n128_f64);
  result.n128_u64[0] = a3[1].n128_u64[1];
  if (result.n128_f64[0] < a4[1].n128_f64[1])
  {
    v9 = *a3;
    result = a3[1];
    v10 = a4[1];
    *a3 = *a4;
    a3[1] = v10;
    *a4 = v9;
    a4[1] = result;
    result.n128_u64[0] = a2[1].n128_u64[1];
    if (result.n128_f64[0] < a3[1].n128_f64[1])
    {
      v11 = *a2;
      result = a2[1];
      v12 = a3[1];
      *a2 = *a3;
      a2[1] = v12;
      *a3 = v11;
      a3[1] = result;
      result.n128_u64[0] = a1[1].n128_u64[1];
      if (result.n128_f64[0] < a2[1].n128_f64[1])
      {
        v13 = *a1;
        result = a1[1];
        v14 = a2[1];
        *a1 = *a2;
        a1[1] = v14;
        *a2 = v13;
        a2[1] = result;
      }
    }
  }
  return result;
}

void ***sub_10030846C(void ***a1, __int128 *a2)
{
  void **v4;
  char *v5;
  void **v6;
  uint64_t v7;
  char *v8;
  char *v9;
  __int128 v10;
  char *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  __int128 v19;
  char *v20;
  char *v21;
  __int128 v22;

  v4 = *a1;
  v5 = (char *)(*a1)[1];
  v6 = *a1;
  v9 = (char *)v6[2];
  v7 = (uint64_t)(v6 + 2);
  v8 = v9;
  if (v5 >= v9)
  {
    v12 = 0xCCCCCCCCCCCCCCCDLL * ((v5 - (_BYTE *)*v4) >> 2);
    v13 = v12 + 1;
    if (v12 + 1 > 0xCCCCCCCCCCCCCCCLL)
      sub_100259694();
    v14 = 0xCCCCCCCCCCCCCCCDLL * ((v8 - (_BYTE *)*v4) >> 2);
    if (2 * v14 > v13)
      v13 = 2 * v14;
    if (v14 >= 0x666666666666666)
      v15 = 0xCCCCCCCCCCCCCCCLL;
    else
      v15 = v13;
    if (v15)
      v16 = (char *)sub_1002F5388(v7, v15);
    else
      v16 = 0;
    v17 = &v16[20 * v12];
    v18 = &v16[20 * v15];
    v19 = *a2;
    *((_DWORD *)v17 + 4) = *((_DWORD *)a2 + 4);
    *(_OWORD *)v17 = v19;
    v11 = v17 + 20;
    v21 = (char *)*v4;
    v20 = (char *)v4[1];
    if (v20 != *v4)
    {
      do
      {
        v22 = *(_OWORD *)(v20 - 20);
        *((_DWORD *)v17 - 1) = *((_DWORD *)v20 - 1);
        *(_OWORD *)(v17 - 20) = v22;
        v17 -= 20;
        v20 -= 20;
      }
      while (v20 != v21);
      v20 = (char *)*v4;
    }
    *v4 = v17;
    v4[1] = v11;
    v4[2] = v18;
    if (v20)
      operator delete(v20);
  }
  else
  {
    v10 = *a2;
    *((_DWORD *)v5 + 4) = *((_DWORD *)a2 + 4);
    *(_OWORD *)v5 = v10;
    v11 = v5 + 20;
  }
  v4[1] = v11;
  return a1;
}

_QWORD *sub_10030859C(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  void **v10;
  _QWORD *v11;
  unint64_t v12;
  float v14;
  float v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  size_t v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;

  v6 = 0;
  v7 = 0;
  do
    v7 ^= (v7 << 6) + (v7 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + v6++);
  while (v6 != 16);
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v3 = v7;
      if (v7 >= v8)
        v3 = v7 % v8;
    }
    else
    {
      v3 = (v8 - 1) & v7;
    }
    v10 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v10)
    {
      v11 = *v10;
      if (*v10)
      {
        do
        {
          v12 = v11[1];
          if (v12 == v7)
          {
            if (v11[2] == *a2 && v11[3] == a2[1])
              return v11;
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8)
                v12 %= v8;
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v3)
              break;
          }
          v11 = (_QWORD *)*v11;
        }
        while (v11);
      }
    }
  }
  v11 = operator new(0x28uLL);
  *v11 = 0;
  v11[1] = v7;
  *((_OWORD *)v11 + 1) = *(_OWORD *)a3;
  *((_DWORD *)v11 + 8) = *(_DWORD *)(a3 + 16);
  v14 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v15 = *(float *)(a1 + 32);
  if (!v8 || (float)(v15 * (float)v8) < v14)
  {
    v16 = 1;
    if (v8 >= 3)
      v16 = (v8 & (v8 - 1)) != 0;
    v17 = v16 | (2 * v8);
    v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18)
      v19 = v18;
    else
      v19 = v17;
    sub_10012E444(a1, v19);
    v8 = *(_QWORD *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v3 = v7 % v8;
      else
        v3 = v7;
    }
    else
    {
      v3 = (v8 - 1) & v7;
    }
  }
  v20 = *(_QWORD *)a1;
  v21 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v21)
  {
    *v11 = *v21;
LABEL_44:
    *v21 = v11;
    goto LABEL_45;
  }
  *v11 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v11;
  *(_QWORD *)(v20 + 8 * v3) = a1 + 16;
  if (*v11)
  {
    v22 = *(_QWORD *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v22 >= v8)
        v22 %= v8;
    }
    else
    {
      v22 &= v8 - 1;
    }
    v21 = (_QWORD *)(*(_QWORD *)a1 + 8 * v22);
    goto LABEL_44;
  }
LABEL_45:
  ++*(_QWORD *)(a1 + 24);
  return v11;
}

void sub_1003087E0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

__int128 *sub_1003087F4(uint64_t *a1, __int128 *a2, __int128 *a3, __int128 *a4, uint64_t a5)
{
  __int128 *v5;
  __int128 *v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  __int128 *v21;
  char *v22;
  uint64_t v23;
  char *v24;
  void *v26[2];
  char *v27;
  char *v28;
  uint64_t v29;

  v5 = a2;
  if (a5 >= 1)
  {
    v7 = a3;
    v11 = a1[2];
    v9 = (uint64_t)(a1 + 2);
    v10 = v11;
    v12 = *(_QWORD *)(v9 - 8);
    if ((uint64_t)(0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v11 - v12) >> 4)) >= a5)
    {
      v20 = v12 - (_QWORD)a2;
      if ((uint64_t)(0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v12 - (_QWORD)a2) >> 4)) >= a5)
      {
        v21 = &a3[15 * a5];
      }
      else
      {
        v21 = &a3[(uint64_t)(v12 - (_QWORD)a2) >> 4];
        a1[1] = sub_1003089E4(v9, v21, a4, *(_QWORD *)(v9 - 8));
        if (v20 < 1)
          return v5;
      }
      sub_100305174((uint64_t)a1, (uint64_t)v5, v12, (uint64_t)&v5[15 * a5]);
      sub_100308A8C((uint64_t)v26, v7, v21, (uint64_t)v5);
    }
    else
    {
      v13 = *a1;
      v14 = a5 - 0x1111111111111111 * ((uint64_t)(v12 - *a1) >> 4);
      if (v14 > 0x111111111111111)
        sub_100259694();
      v15 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)a2 - v13) >> 4);
      v16 = 0xEEEEEEEEEEEEEEEFLL * ((v10 - v13) >> 4);
      v17 = 2 * v16;
      if (2 * v16 <= v14)
        v17 = v14;
      if (v16 >= 0x88888888888888)
        v18 = 0x111111111111111;
      else
        v18 = v17;
      v29 = v9;
      if (v18)
        v19 = (char *)sub_100273E28(v9, v18);
      else
        v19 = 0;
      v22 = &v19[240 * v15];
      v26[0] = v19;
      v26[1] = v22;
      v27 = v22;
      v28 = &v19[240 * v18];
      v23 = 240 * a5;
      v24 = &v22[240 * a5];
      do
      {
        sub_100273D04(v29, (uint64_t)v22, v7);
        v22 += 240;
        v7 += 15;
        v23 -= 240;
      }
      while (v23);
      v27 = v24;
      v5 = (__int128 *)sub_10030521C((uint64_t)a1, v26, v5);
      sub_100273FB8(v26);
    }
  }
  return v5;
}

void sub_1003089B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  uint64_t v12;
  uint64_t v13;

  *(_QWORD *)(v12 + 8) = v13;
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003089E4(uint64_t a1, __int128 *a2, __int128 *a3, uint64_t a4)
{
  uint64_t v4;
  __int128 *v6;
  _QWORD v9[3];
  char v10;
  uint64_t v11;
  uint64_t v12;

  v4 = a4;
  v11 = a4;
  v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  v10 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      sub_100273D04(a1, v4, v6);
      v6 += 15;
      v4 = v12 + 240;
      v12 += 240;
    }
    while (v6 != a3);
  }
  v10 = 1;
  sub_1002B9B38((uint64_t)v9);
  return v4;
}

void sub_100308A78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1002B9B38((uint64_t)&a9);
  _Unwind_Resume(a1);
}

__int128 *sub_100308A8C(uint64_t a1, __int128 *a2, __int128 *a3, uint64_t a4)
{
  __int128 *v5;
  __int128 *v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;

  v5 = a2;
  if (a2 == a3)
    return a2;
  v6 = a3;
  do
  {
    v7 = *v5;
    *(_QWORD *)(a4 + 16) = *((_QWORD *)v5 + 2);
    *(_OWORD *)a4 = v7;
    std::string::operator=((std::string *)(a4 + 24), (const std::string *)v5 + 1);
    v8 = *(__int128 *)((char *)v5 + 60);
    *(_OWORD *)(a4 + 48) = v5[3];
    *(_OWORD *)(a4 + 60) = v8;
    sub_1002E0BA0(a4 + 80, (uint64_t)(v5 + 5));
    v9 = *(__int128 *)((char *)v5 + 216);
    *(_BYTE *)(a4 + 232) = *((_BYTE *)v5 + 232);
    *(_OWORD *)(a4 + 216) = v9;
    a4 += 240;
    v5 += 15;
  }
  while (v5 != v6);
  return v6;
}

void sub_100308B2C()
{
  operator delete();
}

_QWORD *sub_100308B40()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = off_10212E810;
  return result;
}

void sub_100308B64(uint64_t a1, _QWORD *a2)
{
  *a2 = off_10212E810;
}

uint64_t sub_100308B7C()
{
  return 0;
}

uint64_t sub_100308B84(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else
    return 0;
}

_UNKNOWN **sub_100308BC0()
{
}

_QWORD *sub_100308BCC(_QWORD *result, uint64_t a2)
{
  *result = a2;
  return result;
}

uint64_t sub_100308BD4(uint64_t *a1)
{
  void **v2;
  unsigned int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  NSObject *v10;
  void *__p[2];
  char v13;
  char v14;
  uint8_t buf[4];
  int v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  __int16 v25;
  int v26;
  __int16 v27;
  unsigned int v28;

  sub_100308DDC((uint64_t)a1, (uint64_t)__p);
  if (v14)
  {
    v2 = __p;
    if (v13 < 0)
      v2 = (void **)__p[0];
    v3 = -[NSFileManager fileExistsAtPath:isDirectory:](+[NSFileManager defaultManager](NSFileManager, "defaultManager"), "fileExistsAtPath:isDirectory:", +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), v2), 0);
  }
  else
  {
    v3 = 0;
  }
  v4 = sub_10028F214(*a1);
  v5 = sub_10028EF20(*a1);
  v6 = sub_100308ED8(*a1);
  v7 = v6;
  if (v4)
    v8 = 0;
  else
    v8 = v3;
  if (v5)
    v8 = 0;
  if (v6)
    v9 = 0;
  else
    v9 = v8;
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E880);
  v10 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68290306;
    v16 = 0;
    v17 = 2082;
    v18 = "";
    v19 = 1026;
    v20 = v9;
    v21 = 1026;
    v22 = v4;
    v23 = 1026;
    v24 = v5;
    v25 = 1026;
    v26 = v7;
    v27 = 1026;
    v28 = v3;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Checking if should migrate from backup\", \"result\":%{public}hhd, \"numMainDBRecordingEvents\":%{public}d, \"numMainDBMeasurements\":%{public}d, \"numMainDBServices\":%{public}d, \"restoreDbExists\":%{public}hhd}", buf, 0x30u);
  }
  if (v14 && v13 < 0)
    operator delete(__p[0]);
  return v9;
}

void sub_100308DA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (a17)
  {
    if (a16 < 0)
      operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100308DDC(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  void **v3;
  __int128 v4;
  uint64_t v5;
  void *__p[2];
  char v7;
  char v8;

  sub_10030A3A4(a1, (uint64_t)__p);
  if (v8)
  {
    if (v7 >= 0)
      v3 = __p;
    else
      v3 = (void **)__p[0];
    sub_1015A2E04(&v4, (char *)-[NSString UTF8String](-[NSString stringByAppendingPathComponent:](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), v3), "stringByAppendingPathComponent:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "milo_restore.db")), "UTF8String"));
    *(_OWORD *)a2 = v4;
    *(_QWORD *)(a2 + 16) = v5;
    *(_BYTE *)(a2 + 24) = 1;
    if (v8)
    {
      if (v7 < 0)
        operator delete(__p[0]);
    }
  }
  else
  {
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 24) = 0;
  }
}

void sub_100308EB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19)
{
  if (a19)
  {
    if (a18 < 0)
      operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100308ED8(uint64_t a1)
{
  NSObject *v3;
  const char *v4;
  uint8_t *v5;
  _WORD v6[8];
  uint8_t buf[1640];

  if (sub_1000CC4F4(a1 + 72))
    return sub_10027B660(a1, "MiLoServices");
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E880);
  v3 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#Warning Attempt to get numEntries without a backing database", buf, 2u);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E880);
    v6[0] = 0;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#Warning Attempt to get numEntries without a backing database", v6, 2);
    v5 = (uint8_t *)v4;
    sub_100512490("Generic", 1, 0, 2, "uint32_t CLMicroLocationDatabase::numEntriesFromTriggerTable() [Table = CLMiLoServiceTable]", "%s\n", v4);
    if (v5 != buf)
      free(v5);
  }
  return 0;
}

uint64_t sub_1003090AC(uint64_t a1, uint64_t a2)
{
  double v4;
  uint64_t v5;
  void **v6;
  CLOSTransaction *v7;
  CLOSTransaction *v8;
  void **v9;
  FILE *v10;
  FILE *v11;
  id v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  const char *v16;
  uint8_t *v17;
  NSObject *v18;
  void **v19;
  void **v20;
  const char *v21;
  NSObject *v22;
  NSObject *v24;
  uint64_t v25;
  double v26;
  NSObject *v27;
  const char *v28;
  const char *v29;
  uint8_t *v30;
  void *__p[2];
  char v32;
  char v33;
  int v34;
  void **v35;
  uint8_t buf[4];
  _BYTE v37[14];
  __int16 v38;
  int v39;
  __int16 v40;
  double v41;
  __int16 v42;
  FILE *v43;

  v4 = sub_1001FCBB4();
  sub_100308DDC(a1, (uint64_t)__p);
  if (!v33)
    goto LABEL_17;
  v5 = *(unsigned __int8 *)(a2 + 23);
  if ((v5 & 0x80u) != 0)
    v5 = *(_QWORD *)(a2 + 8);
  if (!v5)
  {
LABEL_17:
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E880);
    v15 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Failed to get paths for exporting iCloud Restore db", buf, 2u);
    }
    if (!sub_1001BFF7C(115, 0))
      goto LABEL_44;
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E880);
    LOWORD(v34) = 0;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 16, "Failed to get paths for exporting iCloud Restore db", &v34, 2);
    v17 = (uint8_t *)v16;
    sub_100512490("Generic", 1, 0, 0, "BOOL CLMicroLocationBackupAndRestore::exportiCloudBackupDatabaseInternal(std::string &)", "%s\n", v16);
    goto LABEL_67;
  }
  v6 = __p;
  if (v32 < 0)
    v6 = (void **)__p[0];
  if (!-[NSFileManager fileExistsAtPath:isDirectory:](+[NSFileManager defaultManager](NSFileManager, "defaultManager"), "fileExistsAtPath:isDirectory:", +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), v6), 0))
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E880);
    v18 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      if (!v33)
        sub_10028DF3C();
      v19 = __p;
      if (v32 < 0)
        v19 = (void **)__p[0];
      *(_DWORD *)buf = 136380675;
      *(_QWORD *)v37 = v19;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "iCloud restore db file does not exist at %{private}s", buf, 0xCu);
    }
    if (!sub_1001BFF7C(115, 0))
      goto LABEL_44;
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E880);
    if (!v33)
      sub_10028DF3C();
    v20 = __p;
    if (v32 < 0)
      v20 = (void **)__p[0];
    v34 = 136380675;
    v35 = v20;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 16, "iCloud restore db file does not exist at %{private}s", &v34, 12);
    v17 = (uint8_t *)v21;
    sub_100512490("Generic", 1, 0, 0, "BOOL CLMicroLocationBackupAndRestore::exportiCloudBackupDatabaseInternal(std::string &)", "%s\n", v21);
    goto LABEL_67;
  }
  if (!+[CLMicroLocationKeychain retrieveSymmetricKey:](_TtC19microlocation_logic23CLMicroLocationKeychain, "retrieveSymmetricKey:", CFSTR("com.apple.milo.security.database.backup")))
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E880);
    v22 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Failed to get key for backup decryption", buf, 2u);
    }
    if (!sub_1001BFF7C(115, 0))
      goto LABEL_44;
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E880);
    LOWORD(v34) = 0;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 16, "Failed to get key for backup decryption", &v34, 2);
    v17 = (uint8_t *)v28;
    sub_100512490("Generic", 1, 0, 0, "BOOL CLMicroLocationBackupAndRestore::exportiCloudBackupDatabaseInternal(std::string &)", "%s\n", v28);
LABEL_67:
    if (v17 != buf)
      free(v17);
LABEL_44:
    v14 = 0;
    goto LABEL_45;
  }
  v7 = -[CLOSTransaction initWithDescription:]([CLOSTransaction alloc], "initWithDescription:", "com.apple.locationd.microlocation.migrate-cloud-backup");
  if (!v33)
    sub_10028DF3C();
  v8 = v7;
  if (v32 >= 0)
    v9 = __p;
  else
    v9 = (void **)__p[0];
  v10 = sub_100068A38((const char *)v9);
  if (!v33)
    sub_10028DF3C();
  v11 = v10;
  v12 = sub_1003098E4((uint64_t)v10, (uint64_t *)__p, (uint64_t *)a2, (uint64_t)CFSTR("com.apple.milo.security.database.backup"));
  if (!(_DWORD)v12)
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E880);
    v24 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Failed to decrypt backup file", buf, 2u);
    }
    if (sub_1001BFF7C(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E880);
      LOWORD(v34) = 0;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 16, "Failed to decrypt backup file", &v34, 2);
      v30 = (uint8_t *)v29;
      sub_100512490("Generic", 1, 0, 0, "BOOL CLMicroLocationBackupAndRestore::exportiCloudBackupDatabaseInternal(std::string &)", "%s\n", v29);
      if (v30 != buf)
        free(v30);
    }
    if (*(char *)(a2 + 23) >= 0)
      v25 = a2;
    else
      v25 = *(_QWORD *)a2;
    v13 = -[NSFileManager fileExistsAtPath:isDirectory:](+[NSFileManager defaultManager](NSFileManager, "defaultManager"), "fileExistsAtPath:isDirectory:", +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), v25), 0);
    if (!(_DWORD)v13)
      goto LABEL_59;
    goto LABEL_58;
  }
  sub_100309998((uint64_t)v12, a2);
  v13 = sub_10028DEBC(a2, 2, 0);
  if (!(_DWORD)v13)
  {
LABEL_58:
    sub_10030A030(v13, a2);
LABEL_59:
    v14 = 0;
    goto LABEL_60;
  }
  sub_100309E94(a1, a2, 2);
  v14 = 1;
LABEL_60:

  v26 = sub_1001FCBB4();
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E880);
  v27 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289795;
    *(_DWORD *)v37 = 0;
    *(_WORD *)&v37[4] = 2082;
    *(_QWORD *)&v37[6] = "";
    v38 = 1025;
    v39 = v14;
    v40 = 2049;
    v41 = v26 - v4;
    v42 = 2049;
    v43 = v11;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Microlocation export restored backup for migration\", \"result\":%{private}hhd, \"duration [s]\":\"%{private}f\", \"restore file size [B]\":%{private}ld}", buf, 0x2Cu);
  }
LABEL_45:
  if (v33 && v32 < 0)
    operator delete(__p[0]);
  return v14;
}

void sub_10030988C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (a17)
  {
    if (a16 < 0)
      operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_1003098E4(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *v6;
  NSString *v7;
  uint64_t *v8;
  NSString *v9;
  uint64_t v10;
  uint64_t v11;

  if (*((char *)a2 + 23) >= 0)
    v6 = a2;
  else
    v6 = (uint64_t *)*a2;
  v7 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), v6);
  if (*((char *)a3 + 23) >= 0)
    v8 = a3;
  else
    v8 = (uint64_t *)*a3;
  v9 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), v8);
  v11 = objc_opt_class(_TtC19microlocation_logic23CLMicroLocationKeychain, v10);
  return (id)+[CLMicroLocationEncryption decryptFile:destinationPath:keyLabel:keychainClass:](_TtC19microlocation_logic25CLMicroLocationEncryption, "decryptFile:destinationPath:keyLabel:keychainClass:", v7, v9, a4, v11);
}

uint64_t sub_100309998(uint64_t a1, uint64_t a2)
{
  int v3;
  _BYTE *v4;
  size_t v5;
  const void *v6;
  _QWORD *v7;
  size_t v8;
  const void *v9;
  uint64_t v10;
  char *v11;
  char *v12;
  char v13;
  char *v14;
  NSFileManager *v15;
  NSDictionary *v16;
  char *v17;
  unsigned __int8 v18;
  NSObject *v19;
  char *v20;
  NSObject *v21;
  char *v22;
  char *v24;
  char *v25;
  char *v26;
  char **v27;
  char v28;
  NSFileAttributeKey v29;
  NSFileProtectionType v30;
  _BYTE buf[38];
  char v32;
  _QWORD v33[2];
  _BYTE v34[9];
  __int128 v35;

  v3 = *(char *)(a2 + 23);
  if (v3 < 0)
  {
    sub_100115CE4(buf, *(void **)a2, *(_QWORD *)(a2 + 8));
    LOBYTE(v3) = *(_BYTE *)(a2 + 23);
  }
  else
  {
    *(_OWORD *)buf = *(_OWORD *)a2;
    *(_QWORD *)&buf[16] = *(_QWORD *)(a2 + 16);
  }
  v4 = &buf[24];
  if ((v3 & 0x80u) == 0)
    v5 = v3;
  else
    v5 = *(_QWORD *)(a2 + 8);
  sub_100259584((uint64_t)&buf[24], v5 + 4);
  if (v32 < 0)
    v4 = *(_BYTE **)&buf[24];
  if (v5)
  {
    if (*(char *)(a2 + 23) >= 0)
      v6 = (const void *)a2;
    else
      v6 = *(const void **)a2;
    memmove(v4, v6, v5);
  }
  strcpy(&v4[v5], "-wal");
  v7 = v33;
  if (*(char *)(a2 + 23) >= 0)
    v8 = *(unsigned __int8 *)(a2 + 23);
  else
    v8 = *(_QWORD *)(a2 + 8);
  sub_100259584((uint64_t)v33, v8 + 4);
  if (v34[0] < 0)
    v7 = (_QWORD *)v33[0];
  if (v8)
  {
    if (*(char *)(a2 + 23) >= 0)
      v9 = (const void *)a2;
    else
      v9 = *(const void **)a2;
    memmove(v7, v9, v8);
  }
  strcpy((char *)v7 + v8, "-shm");
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = &v24;
  v28 = 0;
  v24 = (char *)operator new(0x48uLL);
  v25 = v24;
  v26 = v24 + 72;
  v10 = 0;
  v25 = sub_10030AD14((uint64_t)&v26, (__int128 *)buf, &v35, v24);
  do
  {
    if ((char)v34[v10 * 8] < 0)
      operator delete((void *)v33[v10]);
    v10 -= 3;
  }
  while (v10 != -9);
  v11 = v24;
  v12 = v25;
  if (v24 == v25)
  {
    v13 = 1;
  }
  else
  {
    v13 = 1;
    do
    {
      if (v11[23] >= 0)
        v14 = v11;
      else
        v14 = *(char **)v11;
      if (-[NSFileManager fileExistsAtPath:isDirectory:](+[NSFileManager defaultManager](NSFileManager, "defaultManager"), "fileExistsAtPath:isDirectory:", +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), v14), 0))
      {
        v27 = 0;
        v15 = +[NSFileManager defaultManager](NSFileManager, "defaultManager");
        v29 = NSFileProtectionKey;
        v30 = NSFileProtectionCompleteUnlessOpen;
        v16 = +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v30, &v29, 1);
        v17 = v11;
        if (v11[23] < 0)
          v17 = *(char **)v11;
        v18 = -[NSFileManager setAttributes:ofItemAtPath:error:](v15, "setAttributes:ofItemAtPath:error:", v16, +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), v17), &v27);
        if ((v18 & 1) == 0)
        {
          if (qword_1022A00F0 != -1)
            dispatch_once(&qword_1022A00F0, &stru_10212E880);
          v19 = qword_1022A00F8;
          if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
          {
            v20 = v11;
            if (v11[23] < 0)
              v20 = *(char **)v11;
            *(_DWORD *)buf = 68289539;
            *(_DWORD *)&buf[4] = 0;
            *(_WORD *)&buf[8] = 2082;
            *(_QWORD *)&buf[10] = "";
            *(_WORD *)&buf[18] = 2081;
            *(_QWORD *)&buf[20] = v20;
            *(_WORD *)&buf[28] = 2113;
            *(_QWORD *)&buf[30] = v27;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"failed to set attributes for file\", \"filename\":%{private, location:escape_only}s, \"error\":%{private, location:escape_only}@}", buf, 0x26u);
            if (qword_1022A00F0 != -1)
              dispatch_once(&qword_1022A00F0, &stru_10212E880);
          }
          v21 = qword_1022A00F8;
          if (os_signpost_enabled((os_log_t)qword_1022A00F8))
          {
            v22 = v11;
            if (v11[23] < 0)
              v22 = *(char **)v11;
            *(_DWORD *)buf = 68289539;
            *(_DWORD *)&buf[4] = 0;
            *(_WORD *)&buf[8] = 2082;
            *(_QWORD *)&buf[10] = "";
            *(_WORD *)&buf[18] = 2081;
            *(_QWORD *)&buf[20] = v22;
            *(_WORD *)&buf[28] = 2113;
            *(_QWORD *)&buf[30] = v27;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v21, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "failed to set attributes for file", "{\"msg%{public}.0s\":\"failed to set attributes for file\", \"filename\":%{private, location:escape_only}s, \"error\":%{private, location:escape_only}@}", buf, 0x26u);
          }
        }
        v13 &= v18;
      }
      v11 += 24;
    }
    while (v11 != v12);
  }
  *(_QWORD *)buf = &v24;
  sub_100259608((void ***)buf);
  return v13 & 1;
}

void sub_100309E04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  _Unwind_Resume(exception_object);
}

uint64_t sub_100309E94(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  NSObject *v5;
  _DWORD v7[4];
  void *__p[2];
  uint64_t v9;
  _BYTE v10[304];
  uint64_t buf;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;

  if (*(char *)(a2 + 23) < 0)
  {
    sub_100115CE4(__p, *(void **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)__p = *(_OWORD *)a2;
    v9 = *(_QWORD *)(a2 + 16);
  }
  v4 = sub_10027AB58((uint64_t)v10, (__int128 *)__p, a3);
  if (SHIBYTE(v9) < 0)
    operator delete(__p[0]);
  sub_10030A354(v4, (uint64_t)v10, v7);
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E880);
  v5 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    buf = 68290051;
    v12 = 2082;
    v13 = "";
    v14 = 1025;
    v15 = v7[0];
    v16 = 1025;
    v17 = v7[1];
    v18 = 1025;
    v19 = v7[2];
    v20 = 1025;
    v21 = v7[3];
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Restored iCloud Backup database tables contents\", \"numRecordingEventsEntries\":%{private}d, \"numMeasurementsEntries\":%{private}d, \"numConfigurationEntries\":%{private}d, \"numLoiEntries\":%{private}d}", (uint8_t *)&buf, 0x2Au);
  }
  return sub_10027AD24((uint64_t)v10);
}

void sub_100309FFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18)
{
  _Unwind_Resume(exception_object);
}

void sub_10030A030(uint64_t a1, uint64_t a2)
{
  int v3;
  _QWORD *v4;
  size_t v5;
  const void *v6;
  _QWORD *v7;
  size_t v8;
  const void *v9;
  uint64_t v10;
  char *v11;
  char *i;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  _QWORD v17[2];
  char v18;
  __int128 __dst;
  uint64_t v20;
  _QWORD v21[2];
  char v22;
  _QWORD v23[2];
  char v24;
  __int128 v25;

  v3 = *(char *)(a2 + 23);
  if (v3 < 0)
  {
    sub_100115CE4(&__dst, *(void **)a2, *(_QWORD *)(a2 + 8));
    LOBYTE(v3) = *(_BYTE *)(a2 + 23);
  }
  else
  {
    __dst = *(_OWORD *)a2;
    v20 = *(_QWORD *)(a2 + 16);
  }
  v4 = v21;
  if ((v3 & 0x80u) == 0)
    v5 = v3;
  else
    v5 = *(_QWORD *)(a2 + 8);
  sub_100259584((uint64_t)v21, v5 + 4);
  if (v22 < 0)
    v4 = (_QWORD *)v21[0];
  if (v5)
  {
    if (*(char *)(a2 + 23) >= 0)
      v6 = (const void *)a2;
    else
      v6 = *(const void **)a2;
    memmove(v4, v6, v5);
  }
  strcpy((char *)v4 + v5, "-wal");
  v7 = v23;
  if (*(char *)(a2 + 23) >= 0)
    v8 = *(unsigned __int8 *)(a2 + 23);
  else
    v8 = *(_QWORD *)(a2 + 8);
  sub_100259584((uint64_t)v23, v8 + 4);
  if (v24 < 0)
    v7 = (_QWORD *)v23[0];
  if (v8)
  {
    if (*(char *)(a2 + 23) >= 0)
      v9 = (const void *)a2;
    else
      v9 = *(const void **)a2;
    memmove(v7, v9, v8);
  }
  strcpy((char *)v7 + v8, "-shm");
  v15 = 0;
  v16 = 0;
  v17[0] = 0;
  v17[1] = &v15;
  v18 = 0;
  v15 = (char *)operator new(0x48uLL);
  v16 = v15;
  v17[0] = v15 + 72;
  v10 = 0;
  v16 = sub_10028E070((uint64_t)v17, &__dst, &v25, v15);
  do
  {
    if (*(&v24 + v10 * 8) < 0)
      operator delete((void *)v23[v10]);
    v10 -= 3;
  }
  while (v10 != -9);
  v11 = v15;
  for (i = v16; v11 != i; v11 += 24)
  {
    if (v11[23] >= 0)
      v13 = v11;
    else
      v13 = *(char **)v11;
    if (-[NSFileManager fileExistsAtPath:isDirectory:](+[NSFileManager defaultManager](NSFileManager, "defaultManager"), "fileExistsAtPath:isDirectory:", +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), v13), 0))
    {
      v14 = v11;
      if (v11[23] < 0)
        v14 = *(char **)v11;
      -[NSFileManager removeItemAtURL:error:](+[NSFileManager defaultManager](NSFileManager, "defaultManager"), "removeItemAtURL:error:", +[NSURL fileURLWithPath:](NSURL, "fileURLWithPath:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v14)), 0);
    }
  }
  *(_QWORD *)&__dst = &v15;
  sub_100259608((void ***)&__dst);
}

void sub_10030A2C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15)
{
  _Unwind_Resume(exception_object);
}

uint64_t sub_10030A354(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t result;

  *a3 = sub_10028F214(a2);
  a3[1] = sub_10028EF20(a2);
  a3[2] = sub_10028F63C(a2);
  result = sub_10030AB18(a2);
  a3[3] = result;
  return result;
}

void sub_10030A3A4(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  void **v3;
  NSString *v4;
  unsigned int v5;
  unsigned int v6;
  NSObject *v7;
  const char *v8;
  void **v9;
  _WORD v10[7];
  char v11;
  void *__p[2];
  uint64_t v13;

  sub_10063448C((char *)(*(_QWORD *)a1 + 72), (uint64_t)__p);
  if (v13 >= 0)
    v3 = __p;
  else
    v3 = (void **)__p[0];
  v4 = -[NSString stringByDeletingLastPathComponent](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), v3), "stringByDeletingLastPathComponent");
  if (SHIBYTE(v13) < 0)
    operator delete(__p[0]);
  v11 = 0;
  v5 = -[NSFileManager fileExistsAtPath:isDirectory:](+[NSFileManager defaultManager](NSFileManager, "defaultManager"), "fileExistsAtPath:isDirectory:", v4, &v11);
  if (v11)
    v6 = v5;
  else
    v6 = 0;
  if (v6 == 1)
  {
    sub_1015A2E04(__p, (char *)-[NSString UTF8String](v4, "UTF8String"));
    *(_OWORD *)a2 = *(_OWORD *)__p;
    *(_QWORD *)(a2 + 16) = v13;
    *(_BYTE *)(a2 + 24) = 1;
  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E880);
    v7 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to get locationDb directory", (uint8_t *)__p, 2u);
    }
    if (sub_1001BFF7C(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E880);
      v10[0] = 0;
      _os_log_send_and_compose_impl(2, 0, __p, 1628, &_mh_execute_header, qword_1022A00F8, 16, "Failed to get locationDb directory", v10, 2);
      v9 = (void **)v8;
      sub_100512490("Generic", 1, 0, 0, "std::optional<std::string> CLMicroLocationBackupAndRestore::getLocationDbDirPath()", "%s\n", v8);
      if (v9 != __p)
        free(v9);
    }
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 24) = 0;
  }
}

void sub_10030A5F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_10030A618(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  void **v3;
  NSString *v4;
  __int128 v5;
  uint64_t v6;
  void *__p[2];
  char v8;
  char v9;

  sub_10030A3A4(a1, (uint64_t)__p);
  if (v9
    && (v8 >= 0 ? (v3 = __p) : (v3 = (void **)__p[0]),
        v4 = -[NSString stringByAppendingPathComponent:](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), v3), "stringByAppendingPathComponent:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "milo_cache")), -[NSFileManager fileExistsAtPath:isDirectory:](+[NSFileManager defaultManager](NSFileManager, "defaultManager"), "fileExistsAtPath:isDirectory:", v4, 0)))
  {
    sub_1015A2E04(&v5, (char *)-[NSString UTF8String](v4, "UTF8String"));
    *(_OWORD *)a2 = v5;
    *(_QWORD *)(a2 + 16) = v6;
    *(_BYTE *)(a2 + 24) = 1;
  }
  else
  {
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 24) = 0;
  }
  if (v9)
  {
    if (v8 < 0)
      operator delete(__p[0]);
  }
}

void sub_10030A710(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19)
{
  if (a19)
  {
    if (a18 < 0)
      operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10030A738(uint64_t a1)
{
  void **v2;
  NSObject *v3;
  _BOOL8 v4;
  void **v5;
  void **v6;
  NSString *v7;
  NSObject *v8;
  const char *v9;
  NSObject *v10;
  const char *v11;
  uint64_t v12;
  void *__p[2];
  char v14;
  char v15;
  void *v16[2];
  char v17;
  char v18;
  uint8_t buf[4];
  int v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  uint64_t v26;

  sub_100308DDC(a1, (uint64_t)v16);
  if (v18)
  {
    v2 = v16;
    if (v17 < 0)
      v2 = (void **)v16[0];
    if (-[NSFileManager fileExistsAtPath:isDirectory:](+[NSFileManager defaultManager](NSFileManager, "defaultManager"), "fileExistsAtPath:isDirectory:", +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), v2), 0))
    {
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E880);
      v3 = qword_1022A00F8;
      v4 = os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT);
      if (v4)
      {
        if (!v18)
          sub_10028DF3C();
        v5 = v16;
        if (v17 < 0)
          v5 = (void **)v16[0];
        *(_DWORD *)buf = 68289283;
        v20 = 0;
        v21 = 2082;
        v22 = "";
        v23 = 2081;
        v24 = (const char *)v5;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"deleting restore database file\", \"filename\":%{private, location:escape_only}s}", buf, 0x1Cu);
      }
      if (!v18)
        sub_10028DF3C();
      sub_10030A030(v4, (uint64_t)v16);
    }
  }
  sub_10030A618(a1, (uint64_t)__p);
  if (v15)
  {
    v6 = __p;
    if (v14 < 0)
      v6 = (void **)__p[0];
    v7 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), v6);
    if (-[NSFileManager fileExistsAtPath:isDirectory:](+[NSFileManager defaultManager](NSFileManager, "defaultManager"), "fileExistsAtPath:isDirectory:", v7, 0))
    {
      v12 = 0;
      if (!-[NSFileManager removeItemAtPath:error:](+[NSFileManager defaultManager](NSFileManager, "defaultManager"), "removeItemAtPath:error:", v7, &v12))
      {
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212E880);
        v8 = qword_1022A00F8;
        if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
        {
          v9 = -[NSString UTF8String](v7, "UTF8String");
          *(_DWORD *)buf = 68289538;
          v20 = 0;
          v21 = 2082;
          v22 = "";
          v23 = 2082;
          v24 = v9;
          v25 = 2114;
          v26 = v12;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"failed to remove existing directory\", \"directory\":%{public, location:escape_only}s, \"error\":%{public, location:escape_only}@}", buf, 0x26u);
          if (qword_1022A00F0 != -1)
            dispatch_once(&qword_1022A00F0, &stru_10212E880);
        }
        v10 = qword_1022A00F8;
        if (os_signpost_enabled((os_log_t)qword_1022A00F8))
        {
          v11 = -[NSString UTF8String](v7, "UTF8String");
          *(_DWORD *)buf = 68289538;
          v20 = 0;
          v21 = 2082;
          v22 = "";
          v23 = 2082;
          v24 = v11;
          v25 = 2114;
          v26 = v12;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v10, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "failed to remove existing directory", "{\"msg%{public}.0s\":\"failed to remove existing directory\", \"directory\":%{public, location:escape_only}s, \"error\":%{public, location:escape_only}@}", buf, 0x26u);
        }
      }
    }
    if (v15 && v14 < 0)
      operator delete(__p[0]);
  }
  if (v18)
  {
    if (v17 < 0)
      operator delete(v16[0]);
  }
}

void sub_10030AAB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24)
{
  if (a17 && a16 < 0)
    operator delete(__p);
  if (a24)
  {
    if (a23 < 0)
      operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10030AB18(uint64_t a1)
{
  NSObject *v3;
  const char *v4;
  uint8_t *v5;
  _WORD v6[8];
  uint8_t buf[1640];

  if (sub_1000CC4F4(a1 + 72))
    return sub_10027B660(a1, "MiLoLoiTable");
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E880);
  v3 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#Warning Attempt to get numEntries without a backing database", buf, 2u);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E880);
    v6[0] = 0;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#Warning Attempt to get numEntries without a backing database", v6, 2);
    v5 = (uint8_t *)v4;
    sub_100512490("Generic", 1, 0, 2, "uint32_t CLMicroLocationDatabase::numEntriesFromTriggerTable() [Table = CLMiLoLoiTable]", "%s\n", v4);
    if (v5 != buf)
      free(v5);
  }
  return 0;
}

void sub_10030ACE8(id a1)
{
  qword_1022A00F8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

char *sub_10030AD14(uint64_t a1, __int128 *a2, __int128 *a3, char *__dst)
{
  char *v4;
  __int128 *v6;
  __int128 v7;
  _QWORD v9[3];
  char v10;
  char *v11;
  char *v12;

  v4 = __dst;
  v11 = __dst;
  v12 = __dst;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  v10 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      if (*((char *)v6 + 23) < 0)
      {
        sub_100115CE4(v4, *(void **)v6, *((_QWORD *)v6 + 1));
        v4 = v12;
      }
      else
      {
        v7 = *v6;
        *((_QWORD *)v4 + 2) = *((_QWORD *)v6 + 2);
        *(_OWORD *)v4 = v7;
      }
      v6 = (__int128 *)((char *)v6 + 24);
      v4 += 24;
      v12 = v4;
    }
    while (v6 != a3);
  }
  v10 = 1;
  sub_10030ADD0((uint64_t)v9);
  return v4;
}

void sub_10030ADBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_10030ADD0((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_10030ADD0(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    sub_100259D58(a1);
  return a1;
}

_QWORD *sub_10030AE04(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  char *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD v9[4];
  _QWORD v10[4];
  _QWORD v11[4];
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  *a1 = a2;
  a1[1] = a3;
  v9[0] = off_10212E900;
  v9[1] = a1;
  v9[3] = v9;
  v10[0] = off_10212E980;
  v10[1] = a1;
  v10[3] = v10;
  v11[0] = off_10212EA00;
  v11[1] = a1;
  v11[3] = v11;
  v12[0] = off_10212EA80;
  v12[1] = a1;
  v13 = v12;
  a1[3] = 0;
  a1[4] = 0;
  a1[2] = 0;
  v4 = (char *)operator new(0x80uLL);
  a1[4] = v4 + 128;
  a1[2] = v4;
  a1[3] = v4;
  v5 = 0;
  a1[3] = sub_1002AE630((uint64_t)(a1 + 4), (uint64_t)v9, (uint64_t)&v14, (uint64_t)v4);
  do
  {
    v6 = (&v13)[v5];
    if (&v12[v5] == v6)
    {
      v6 = &v12[v5];
      v7 = 4;
    }
    else
    {
      if (!v6)
        goto LABEL_7;
      v7 = 5;
    }
    (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_7:
    v5 -= 4;
  }
  while (v5 != -16);
  return a1;
}

void sub_10030AF40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, char a12)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;
  char *v17;
  uint64_t v18;

  v14 = v13;
  *(_QWORD *)(v12 + 24) = v14;
  sub_1002AE76C(&a10);
  v16 = 0;
  while (1)
  {
    v17 = *(char **)(&a12 + v16 + 120);
    if (&a12 + v16 + 96 == v17)
      break;
    if (v17)
    {
      v18 = 5;
LABEL_6:
      (*(void (**)(void))(*(_QWORD *)v17 + 8 * v18))();
    }
    v16 -= 32;
    if (v16 == -128)
      _Unwind_Resume(a1);
  }
  v17 = &a12 + v16 + 96;
  v18 = 4;
  goto LABEL_6;
}

_QWORD *sub_10030AFB0(_QWORD *result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD v5[3];
  _QWORD *v6;

  v1 = result[2];
  v2 = result[3];
  if (v1 != v2)
  {
    while (1)
    {
      v5[0] = off_10212EB00;
      v6 = v5;
      v3 = *(_QWORD *)(v1 + 24);
      if (!v3)
        sub_10025FD1C();
      (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v3 + 48))(v3, v5);
      result = v6;
      if (v6 == v5)
        break;
      if (v6)
      {
        v4 = 5;
LABEL_7:
        result = (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v4))();
      }
      v1 += 32;
      if (v1 == v2)
        return result;
    }
    result = v5;
    v4 = 4;
    goto LABEL_7;
  }
  return result;
}

void sub_10030B080(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

unint64_t sub_10030B0C0(uint64_t a1, void *a2, void *a3, __int32 **a4, uint64_t *a5)
{
  unint64_t result;
  double v10;

  objc_msgSend(a2, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_100345C28(a5, a4)), objc_msgSend(a3, "stringByAppendingString:", CFSTR("Count")));
  result = sub_100345E24((uint64_t)a5, a4);
  if ((result & 0xFF00000000) != 0)
  {
    LODWORD(v10) = result;
    return (unint64_t)objc_msgSend(a2, "setObject:forKeyedSubscript:", +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v10), objc_msgSend(a3, "stringByAppendingString:", CFSTR("Utilization")));
  }
  return result;
}

void sub_10030B190(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _OWORD *v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  const char *v12;
  uint8_t *v13;
  _QWORD v14[7];
  void *v15;
  void *v16;
  uint64_t v17;
  void *v18;
  void *v19;
  uint64_t v20;
  void *v21;
  void *v22;
  uint64_t v23;
  void *__p;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  _BYTE *v31;
  void *v32;
  _BYTE *v33;
  void *v34;
  _BYTE *v35;
  void *v36;
  _BYTE *v37;
  uint8_t buf[8];
  void *v39;
  void *v40;
  void *v41;

  if (sub_10030B674())
  {
    v8 = operator new(0x68uLL);
    *v8 = xmmword_101B9B430;
    v8[1] = xmmword_101B9B440;
    v8[2] = xmmword_101B9B450;
    v8[3] = xmmword_101B9B460;
    v8[4] = xmmword_101B9B470;
    v8[5] = xmmword_101B9B480;
    *((_QWORD *)v8 + 12) = 13;
    sub_100312E14(&v36, 0xDuLL);
    v9 = 0;
    *(_QWORD *)buf = &v36;
    do
    {
      LODWORD(v34) = *(_DWORD *)((char *)v8 + v9);
      sub_1002F4DA8((uint64_t *)buf, &v34);
      v9 += 8;
    }
    while (v9 != 24);
    sub_100345B14(buf, a2);
    v10 = sub_1002E6038((uint64_t)buf);
    sub_100345B18((uint64_t *)buf, 3uLL, &v34);
    sub_100345B18((uint64_t *)buf, 4uLL, &v32);
    sub_100345B18((uint64_t *)buf, 5uLL, &v30);
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 3321888768;
    v14[2] = sub_10030B750;
    v14[3] = &unk_10212E8A0;
    v14[4] = a1;
    v14[5] = buf;
    v14[6] = a4;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    sub_10027205C(&v15, v34, (uint64_t)v35, (v35 - (_BYTE *)v34) >> 2);
    v18 = 0;
    v19 = 0;
    v20 = 0;
    sub_10027205C(&v18, v32, (uint64_t)v33, (v33 - (_BYTE *)v32) >> 2);
    v21 = 0;
    v22 = 0;
    v23 = 0;
    sub_10027205C(&v21, v30, (uint64_t)v31, (v31 - (_BYTE *)v30) >> 2);
    __p = 0;
    v25 = 0;
    v26 = 0;
    sub_10027205C(&__p, v36, (uint64_t)v37, (v37 - (_BYTE *)v36) >> 2);
    v27 = a3;
    v28 = v10;
    v29 = a2;
    AnalyticsSendEventLazy(CFSTR("com.apple.MicroLocation.Analytics"), v14);
    if (__p)
    {
      v25 = __p;
      operator delete(__p);
    }
    if (v21)
    {
      v22 = v21;
      operator delete(v21);
    }
    if (v18)
    {
      v19 = v18;
      operator delete(v18);
    }
    if (v15)
    {
      v16 = v15;
      operator delete(v15);
    }
    if (v30)
    {
      v31 = v30;
      operator delete(v30);
    }
    if (v32)
    {
      v33 = v32;
      operator delete(v32);
    }
    if (v34)
    {
      v35 = v34;
      operator delete(v34);
    }
    if (v40)
    {
      v41 = v40;
      operator delete(v40);
    }
    if (*(_QWORD *)buf)
    {
      v39 = *(void **)buf;
      operator delete(*(void **)buf);
    }
    if (v36)
    {
      v37 = v36;
      operator delete(v36);
    }
    operator delete(v8);
  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
    v11 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "CLMicroLocationAnalytics, sendCoreAnalyticsEvent, not sending event because sending to CoreAnalytics is disabled", buf, 2u);
    }
    if (sub_1001BFF7C(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
      LOWORD(v36) = 0;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "CLMicroLocationAnalytics, sendCoreAnalyticsEvent, not sending event because sending to CoreAnalytics is disabled", &v36, 2);
      v13 = (uint8_t *)v12;
      sub_100512490("Generic", 1, 0, 2, "void CLMicroLocationAnalytics::sendCoreAnalyticsEvent(const std::vector<CLMicroLocationWiFiChannelHistogram> &, const std::vector<CLMicroLocationWiFiChannelHistogram> &, const std::string &) const", "%s\n", v12);
      if (v13 != buf)
        free(v13);
    }
  }
}

void sub_10030B580(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  _Unwind_Resume(exception_object);
}

uint64_t sub_10030B674()
{
  CFStringRef v0;
  int v1;
  _BOOL4 v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  BOOL v7;
  uint64_t v8;
  std::__shared_weak_count *v9;

  sub_1001E4804(&v8);
  v7 = 0;
  v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsAnalyticsSendEventEnabled", 0x8000100u, kCFAllocatorNull);
  v1 = sub_1001E48E4(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  v2 = v7;
  v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  if (v2)
    return 1;
  else
    return v1 ^ 1u;
}

void sub_10030B738(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  sub_100261F44((uint64_t)va);
  _Unwind_Resume(a1);
}

id sub_10030B750(uint64_t a1)
{
  id v2;
  uint64_t *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  const void *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  unint64_t v14;
  int v15;
  char *v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  char *v24;
  char *v25;
  int v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  double v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  _QWORD *v35;
  uint64_t v36;
  _QWORD *v37;
  unint64_t v38;
  int v39;
  char *v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  char *v47;
  char *v48;
  char *v49;
  int v50;
  uint64_t v51;
  _QWORD *v52;
  unint64_t i;
  NSString *v54;
  uint64_t v55;
  _QWORD *v56;
  void *v58;
  void *v59;
  uint64_t v60;
  int v61;
  void *v62;
  void *v63;
  uint64_t v64;
  void *v65;
  void *v66;
  uint64_t v67;
  void *v68;
  _BYTE *v69;
  void *v70;
  void *v71;
  uint64_t v72;
  int v73;
  void *v74;
  void *v75;
  uint64_t v76;
  void *v77;
  void *v78;
  uint64_t v79;
  void *v80;
  char *v81;
  unint64_t v82;
  void *v83;
  void *v84;
  uint64_t v85;
  int v86;
  void *v87;
  void *v88;
  uint64_t v89;
  void *v90[3];
  void *v91;
  void *v92;
  uint64_t v93;
  int v94;
  void *v95;
  void *v96;
  uint64_t v97;
  void *v98[3];
  void *v99;
  void *v100;
  uint64_t v101;
  int v102;
  void *v103;
  void *v104;
  uint64_t v105;
  void *v106[3];
  void *v107;
  char *v108;
  unint64_t v109;
  void *v110;
  void *v111;
  void *v112;
  void *v113;
  uint64_t v114;
  int v115;
  void *v116;
  void *v117;
  uint64_t v118;
  void *v119;
  void *v120;
  uint64_t v121;
  void *v122;
  void *v123;
  uint64_t v124;
  int v125;
  void *v126;
  void *v127;
  uint64_t v128;
  void *v129;
  void *v130;
  uint64_t v131;
  void *v132;
  void *v133;
  uint64_t v134;
  int v135;
  void *__p;
  void *v137;
  uint64_t v138;
  void *v139;
  void *v140;
  uint64_t v141;
  void *v142;
  void *v143;
  uint64_t v144;
  int v145;
  void *v146;
  void *v147;
  uint64_t v148;
  __int32 *v149;
  __int32 *v150;
  uint64_t v151;
  void *v152;
  void *v153;
  uint64_t v154;
  int v155;
  void *v156;
  void *v157;
  uint64_t v158;
  __int32 *v159;
  __int32 *v160;
  uint64_t v161;

  v2 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
  objc_msgSend(v2, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_1002E6038(*(_QWORD *)(a1 + 40))), CFSTR("histogramTotalChannelCount"));
  v3 = *(uint64_t **)(a1 + 48);
  if (*((char *)v3 + 23) < 0)
    v3 = (uint64_t *)*v3;
  objc_msgSend(v2, "setObject:forKeyedSubscript:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v3), CFSTR("loiType"));
  v159 = 0;
  v160 = 0;
  v161 = 0;
  sub_10027205C(&v159, *(const void **)(a1 + 56), *(_QWORD *)(a1 + 64), (uint64_t)(*(_QWORD *)(a1 + 64) - *(_QWORD *)(a1 + 56)) >> 2);
  v4 = *(_QWORD *)(a1 + 40);
  v153 = 0;
  v154 = 0;
  v152 = 0;
  sub_10025EA00(&v152, *(const void **)v4, *(_QWORD *)(v4 + 8), (uint64_t)(*(_QWORD *)(v4 + 8) - *(_QWORD *)v4) >> 3);
  v155 = *(_DWORD *)(v4 + 24);
  v157 = 0;
  v158 = 0;
  v156 = 0;
  v5 = sub_10027205C(&v156, *(const void **)(v4 + 32), *(_QWORD *)(v4 + 40), (uint64_t)(*(_QWORD *)(v4 + 40) - *(_QWORD *)(v4 + 32)) >> 2);
  sub_10030B0C0((uint64_t)v5, v2, CFSTR("localizationTopThreeChannels"), &v159, (uint64_t *)&v152);
  if (v156)
  {
    v157 = v156;
    operator delete(v156);
  }
  if (v152)
  {
    v153 = v152;
    operator delete(v152);
  }
  if (v159)
  {
    v160 = v159;
    operator delete(v159);
  }
  v149 = 0;
  v150 = 0;
  v151 = 0;
  sub_10027205C(&v149, *(const void **)(a1 + 80), *(_QWORD *)(a1 + 88), (uint64_t)(*(_QWORD *)(a1 + 88) - *(_QWORD *)(a1 + 80)) >> 2);
  v6 = *(_QWORD *)(a1 + 40);
  v143 = 0;
  v144 = 0;
  v142 = 0;
  sub_10025EA00(&v142, *(const void **)v6, *(_QWORD *)(v6 + 8), (uint64_t)(*(_QWORD *)(v6 + 8) - *(_QWORD *)v6) >> 3);
  v145 = *(_DWORD *)(v6 + 24);
  v147 = 0;
  v148 = 0;
  v146 = 0;
  v7 = sub_10027205C(&v146, *(const void **)(v6 + 32), *(_QWORD *)(v6 + 40), (uint64_t)(*(_QWORD *)(v6 + 40) - *(_QWORD *)(v6 + 32)) >> 2);
  sub_10030B0C0((uint64_t)v7, v2, CFSTR("localizationTopFourChannels"), &v149, (uint64_t *)&v142);
  if (v146)
  {
    v147 = v146;
    operator delete(v146);
  }
  if (v142)
  {
    v143 = v142;
    operator delete(v142);
  }
  if (v149)
  {
    v150 = v149;
    operator delete(v149);
  }
  v140 = 0;
  v139 = 0;
  v141 = 0;
  sub_10027205C(&v139, *(const void **)(a1 + 104), *(_QWORD *)(a1 + 112), (uint64_t)(*(_QWORD *)(a1 + 112) - *(_QWORD *)(a1 + 104)) >> 2);
  v8 = *(_QWORD *)(a1 + 40);
  v134 = 0;
  v132 = 0;
  v133 = 0;
  sub_10025EA00(&v132, *(const void **)v8, *(_QWORD *)(v8 + 8), (uint64_t)(*(_QWORD *)(v8 + 8) - *(_QWORD *)v8) >> 3);
  v135 = *(_DWORD *)(v8 + 24);
  v138 = 0;
  __p = 0;
  v137 = 0;
  v9 = sub_10027205C(&__p, *(const void **)(v8 + 32), *(_QWORD *)(v8 + 40), (uint64_t)(*(_QWORD *)(v8 + 40) - *(_QWORD *)(v8 + 32)) >> 2);
  sub_10030B0C0((uint64_t)v9, v2, CFSTR("localizationTopFiveChannels"), (__int32 **)&v139, (uint64_t *)&v132);
  if (__p)
  {
    v137 = __p;
    operator delete(__p);
  }
  if (v132)
  {
    v133 = v132;
    operator delete(v132);
  }
  if (v139)
  {
    v140 = v139;
    operator delete(v139);
  }
  v10 = *(const void **)(a1 + 128);
  v11 = *(_QWORD *)(a1 + 136);
  v130 = 0;
  v129 = 0;
  v131 = 0;
  sub_10027205C(&v129, v10, v11, (v11 - (uint64_t)v10) >> 2);
  v12 = *(_QWORD *)(a1 + 40);
  v124 = 0;
  v122 = 0;
  v123 = 0;
  sub_10025EA00(&v122, *(const void **)v12, *(_QWORD *)(v12 + 8), (uint64_t)(*(_QWORD *)(v12 + 8) - *(_QWORD *)v12) >> 3);
  v125 = *(_DWORD *)(v12 + 24);
  v128 = 0;
  v126 = 0;
  v127 = 0;
  v13 = sub_10027205C(&v126, *(const void **)(v12 + 32), *(_QWORD *)(v12 + 40), (uint64_t)(*(_QWORD *)(v12 + 40) - *(_QWORD *)(v12 + 32)) >> 2);
  sub_10030B0C0((uint64_t)v13, v2, CFSTR("localizationPopularThreeChannels"), (__int32 **)&v129, (uint64_t *)&v122);
  if (v126)
  {
    v127 = v126;
    operator delete(v126);
  }
  if (v122)
  {
    v123 = v122;
    operator delete(v122);
  }
  if (v129)
  {
    v130 = v129;
    operator delete(v129);
  }
  v14 = sub_100345BA8(*(__int32 ***)(a1 + 40), (__int32 **)(a1 + 128));
  if ((v14 & 0xFF00000000) != 0)
  {
    v15 = v14;
    v107 = 0;
    v108 = 0;
    v109 = 0;
    sub_10027205C(&v107, *(const void **)(a1 + 128), *(_QWORD *)(a1 + 136), (uint64_t)(*(_QWORD *)(a1 + 136) - *(_QWORD *)(a1 + 128)) >> 2);
    v16 = v108;
    if ((unint64_t)v108 >= v109)
    {
      v18 = (char *)v107;
      v19 = (v108 - (_BYTE *)v107) >> 2;
      v20 = v19 + 1;
      if ((unint64_t)(v19 + 1) >> 62)
        sub_100259694();
      v21 = v109 - (_QWORD)v107;
      if ((uint64_t)(v109 - (_QWORD)v107) >> 1 > v20)
        v20 = v21 >> 1;
      if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFFCLL)
        v22 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v22 = v20;
      if (v22)
      {
        v23 = (char *)sub_100260634((uint64_t)&v109, v22);
        v18 = (char *)v107;
        v16 = v108;
      }
      else
      {
        v23 = 0;
      }
      v24 = &v23[4 * v19];
      v25 = &v23[4 * v22];
      *(_DWORD *)v24 = v15;
      v17 = (uint64_t)(v24 + 4);
      while (v16 != v18)
      {
        v26 = *((_DWORD *)v16 - 1);
        v16 -= 4;
        *((_DWORD *)v24 - 1) = v26;
        v24 -= 4;
      }
      v107 = v24;
      v108 = (char *)v17;
      v109 = (unint64_t)v25;
      if (v18)
        operator delete(v18);
    }
    else
    {
      *(_DWORD *)v108 = v15;
      v17 = (uint64_t)(v16 + 4);
    }
    v108 = (char *)v17;
    v121 = 0;
    v119 = 0;
    v120 = 0;
    sub_10027205C(&v119, v107, v17, (v17 - (uint64_t)v107) >> 2);
    v27 = *(_QWORD *)(a1 + 40);
    v114 = 0;
    v112 = 0;
    v113 = 0;
    sub_10025EA00(&v112, *(const void **)v27, *(_QWORD *)(v27 + 8), (uint64_t)(*(_QWORD *)(v27 + 8) - *(_QWORD *)v27) >> 3);
    v115 = *(_DWORD *)(v27 + 24);
    v118 = 0;
    v116 = 0;
    v117 = 0;
    v28 = sub_10027205C(&v116, *(const void **)(v27 + 32), *(_QWORD *)(v27 + 40), (uint64_t)(*(_QWORD *)(v27 + 40) - *(_QWORD *)(v27 + 32)) >> 2);
    sub_10030B0C0((uint64_t)v28, v2, CFSTR("localizationPopularThreeAndTopOneChannels"), (__int32 **)&v119, (uint64_t *)&v112);
    if (v116)
    {
      v117 = v116;
      operator delete(v116);
    }
    if (v112)
    {
      v113 = v112;
      operator delete(v112);
    }
    if (v119)
    {
      v120 = v119;
      operator delete(v119);
    }
    if (v107)
    {
      v108 = (char *)v107;
      operator delete(v107);
    }
  }
  sub_100345B14(&v107, *(_QWORD *)(a1 + 152));
  v29 = sub_1002E6038((uint64_t)&v107);
  objc_msgSend(v2, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v29), CFSTR("prevHistogramTotalChannelCount"));
  v30 = *(_QWORD *)(a1 + 160) - v29;
  objc_msgSend(v2, "setObject:forKeyedSubscript:", +[NSNumber numberWithLong:](NSNumber, "numberWithLong:", v30), CFSTR("histogramDiffCount"));
  if (v29)
  {
    *(float *)&v31 = (float)v30 / (float)(unint64_t)v29;
    objc_msgSend(v2, "setObject:forKeyedSubscript:", +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v31), CFSTR("histogramDiffCountPercentage"));
  }
  sub_100345B18((uint64_t *)&v107, 3uLL, v106);
  v32 = *(_QWORD *)(a1 + 40);
  v100 = 0;
  v101 = 0;
  v99 = 0;
  sub_10025EA00(&v99, *(const void **)v32, *(_QWORD *)(v32 + 8), (uint64_t)(*(_QWORD *)(v32 + 8) - *(_QWORD *)v32) >> 3);
  v102 = *(_DWORD *)(v32 + 24);
  v104 = 0;
  v105 = 0;
  v103 = 0;
  v33 = sub_10027205C(&v103, *(const void **)(v32 + 32), *(_QWORD *)(v32 + 40), (uint64_t)(*(_QWORD *)(v32 + 40) - *(_QWORD *)(v32 + 32)) >> 2);
  sub_10030B0C0((uint64_t)v33, v2, CFSTR("localizationPrevTopThreeChannels"), (__int32 **)v106, (uint64_t *)&v99);
  if (v103)
  {
    v104 = v103;
    operator delete(v103);
  }
  if (v99)
  {
    v100 = v99;
    operator delete(v99);
  }
  if (v106[0])
  {
    v106[1] = v106[0];
    operator delete(v106[0]);
  }
  sub_100345B18((uint64_t *)&v107, 4uLL, v98);
  v34 = *(_QWORD *)(a1 + 40);
  v92 = 0;
  v93 = 0;
  v91 = 0;
  sub_10025EA00(&v91, *(const void **)v34, *(_QWORD *)(v34 + 8), (uint64_t)(*(_QWORD *)(v34 + 8) - *(_QWORD *)v34) >> 3);
  v94 = *(_DWORD *)(v34 + 24);
  v96 = 0;
  v97 = 0;
  v95 = 0;
  v35 = sub_10027205C(&v95, *(const void **)(v34 + 32), *(_QWORD *)(v34 + 40), (uint64_t)(*(_QWORD *)(v34 + 40) - *(_QWORD *)(v34 + 32)) >> 2);
  sub_10030B0C0((uint64_t)v35, v2, CFSTR("localizationPrevTopFourChannels"), (__int32 **)v98, (uint64_t *)&v91);
  if (v95)
  {
    v96 = v95;
    operator delete(v95);
  }
  if (v91)
  {
    v92 = v91;
    operator delete(v91);
  }
  if (v98[0])
  {
    v98[1] = v98[0];
    operator delete(v98[0]);
  }
  sub_100345B18((uint64_t *)&v107, 5uLL, v90);
  v36 = *(_QWORD *)(a1 + 40);
  v84 = 0;
  v85 = 0;
  v83 = 0;
  sub_10025EA00(&v83, *(const void **)v36, *(_QWORD *)(v36 + 8), (uint64_t)(*(_QWORD *)(v36 + 8) - *(_QWORD *)v36) >> 3);
  v86 = *(_DWORD *)(v36 + 24);
  v88 = 0;
  v89 = 0;
  v87 = 0;
  v37 = sub_10027205C(&v87, *(const void **)(v36 + 32), *(_QWORD *)(v36 + 40), (uint64_t)(*(_QWORD *)(v36 + 40) - *(_QWORD *)(v36 + 32)) >> 2);
  sub_10030B0C0((uint64_t)v37, v2, CFSTR("localizationPrevTopFiveChannels"), (__int32 **)v90, (uint64_t *)&v83);
  if (v87)
  {
    v88 = v87;
    operator delete(v87);
  }
  if (v83)
  {
    v84 = v83;
    operator delete(v83);
  }
  if (v90[0])
  {
    v90[1] = v90[0];
    operator delete(v90[0]);
  }
  v38 = sub_100345BA8(*(__int32 ***)(a1 + 40), (__int32 **)(a1 + 128));
  v39 = v38;
  if ((v38 & 0xFF00000000) != 0)
  {
    v80 = 0;
    v81 = 0;
    v82 = 0;
    sub_10027205C(&v80, *(const void **)(a1 + 128), *(_QWORD *)(a1 + 136), (uint64_t)(*(_QWORD *)(a1 + 136) - *(_QWORD *)(a1 + 128)) >> 2);
    v40 = v81;
    if ((unint64_t)v81 >= v82)
    {
      v42 = (char *)v80;
      v43 = (v81 - (_BYTE *)v80) >> 2;
      v44 = v43 + 1;
      if ((unint64_t)(v43 + 1) >> 62)
        sub_100259694();
      v45 = v82 - (_QWORD)v80;
      if ((uint64_t)(v82 - (_QWORD)v80) >> 1 > v44)
        v44 = v45 >> 1;
      if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFFCLL)
        v46 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v46 = v44;
      if (v46)
      {
        v47 = (char *)sub_100260634((uint64_t)&v82, v46);
        v42 = (char *)v80;
        v40 = v81;
      }
      else
      {
        v47 = 0;
      }
      v48 = &v47[4 * v43];
      v49 = &v47[4 * v46];
      *(_DWORD *)v48 = v39;
      v41 = (uint64_t)(v48 + 4);
      while (v40 != v42)
      {
        v50 = *((_DWORD *)v40 - 1);
        v40 -= 4;
        *((_DWORD *)v48 - 1) = v50;
        v48 -= 4;
      }
      v80 = v48;
      v81 = (char *)v41;
      v82 = (unint64_t)v49;
      if (v42)
        operator delete(v42);
    }
    else
    {
      *(_DWORD *)v81 = v39;
      v41 = (uint64_t)(v40 + 4);
    }
    v81 = (char *)v41;
    v78 = 0;
    v79 = 0;
    v77 = 0;
    sub_10027205C(&v77, v80, v41, (v41 - (uint64_t)v80) >> 2);
    v51 = *(_QWORD *)(a1 + 40);
    v71 = 0;
    v72 = 0;
    v70 = 0;
    sub_10025EA00(&v70, *(const void **)v51, *(_QWORD *)(v51 + 8), (uint64_t)(*(_QWORD *)(v51 + 8) - *(_QWORD *)v51) >> 3);
    v73 = *(_DWORD *)(v51 + 24);
    v75 = 0;
    v76 = 0;
    v74 = 0;
    v52 = sub_10027205C(&v74, *(const void **)(v51 + 32), *(_QWORD *)(v51 + 40), (uint64_t)(*(_QWORD *)(v51 + 40) - *(_QWORD *)(v51 + 32)) >> 2);
    sub_10030B0C0((uint64_t)v52, v2, CFSTR("localizationPopularThreeAndPrevOneTopChannels"), (__int32 **)&v77, (uint64_t *)&v70);
    if (v74)
    {
      v75 = v74;
      operator delete(v74);
    }
    if (v70)
    {
      v71 = v70;
      operator delete(v70);
    }
    if (v77)
    {
      v78 = v77;
      operator delete(v77);
    }
    for (i = 3; i != 6; ++i)
    {
      sub_100345CB0(*(int ***)(a1 + 168), *(int ***)(a1 + 152), i, &v68);
      v54 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("localizationTop%dCommonChannels"), i);
      v65 = 0;
      v66 = 0;
      v67 = 0;
      sub_10027205C(&v65, v68, (uint64_t)v69, (v69 - (_BYTE *)v68) >> 2);
      v55 = *(_QWORD *)(a1 + 40);
      v59 = 0;
      v60 = 0;
      v58 = 0;
      sub_10025EA00(&v58, *(const void **)v55, *(_QWORD *)(v55 + 8), (uint64_t)(*(_QWORD *)(v55 + 8) - *(_QWORD *)v55) >> 3);
      v61 = *(_DWORD *)(v55 + 24);
      v63 = 0;
      v64 = 0;
      v62 = 0;
      v56 = sub_10027205C(&v62, *(const void **)(v55 + 32), *(_QWORD *)(v55 + 40), (uint64_t)(*(_QWORD *)(v55 + 40) - *(_QWORD *)(v55 + 32)) >> 2);
      sub_10030B0C0((uint64_t)v56, v2, v54, (__int32 **)&v65, (uint64_t *)&v58);
      if (v62)
      {
        v63 = v62;
        operator delete(v62);
      }
      if (v58)
      {
        v59 = v58;
        operator delete(v58);
      }
      if (v65)
      {
        v66 = v65;
        operator delete(v65);
      }
      if (v68)
      {
        v69 = v68;
        operator delete(v68);
      }
    }
    if (v80)
    {
      v81 = (char *)v80;
      operator delete(v80);
    }
  }
  if (v110)
  {
    v111 = v110;
    operator delete(v110);
  }
  if (v107)
  {
    v108 = (char *)v107;
    operator delete(v107);
  }
  return v2;
}

void sub_10030C1B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,void *a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,void *a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  void *a66;

  sub_10030C484((uint64_t)&a23);
  if (__p)
  {
    a31 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a33)
  {
    a34 = (uint64_t)a33;
    operator delete(a33);
  }
  sub_10030C484((uint64_t)&a66);
  _Unwind_Resume(a1);
}

uint64_t sub_10030C484(uint64_t a1)
{
  void *v2;
  void *v3;

  v2 = *(void **)(a1 + 32);
  if (v2)
  {
    *(_QWORD *)(a1 + 40) = v2;
    operator delete(v2);
  }
  v3 = *(void **)a1;
  if (*(_QWORD *)a1)
  {
    *(_QWORD *)(a1 + 8) = v3;
    operator delete(v3);
  }
  return a1;
}

_QWORD *sub_10030C4C4(_QWORD *a1, uint64_t a2)
{
  a1[7] = 0;
  a1[8] = 0;
  a1[9] = 0;
  sub_10027205C(a1 + 7, *(const void **)(a2 + 56), *(_QWORD *)(a2 + 64), (uint64_t)(*(_QWORD *)(a2 + 64) - *(_QWORD *)(a2 + 56)) >> 2);
  a1[10] = 0;
  a1[11] = 0;
  a1[12] = 0;
  sub_10027205C(a1 + 10, *(const void **)(a2 + 80), *(_QWORD *)(a2 + 88), (uint64_t)(*(_QWORD *)(a2 + 88) - *(_QWORD *)(a2 + 80)) >> 2);
  a1[13] = 0;
  a1[14] = 0;
  a1[15] = 0;
  sub_10027205C(a1 + 13, *(const void **)(a2 + 104), *(_QWORD *)(a2 + 112), (uint64_t)(*(_QWORD *)(a2 + 112) - *(_QWORD *)(a2 + 104)) >> 2);
  a1[16] = 0;
  a1[17] = 0;
  a1[18] = 0;
  return sub_10027205C(a1 + 16, *(const void **)(a2 + 128), *(_QWORD *)(a2 + 136), (uint64_t)(*(_QWORD *)(a2 + 136) - *(_QWORD *)(a2 + 128)) >> 2);
}

void sub_10030C574(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  void **v2;
  void **v3;
  void **v4;
  void *v6;
  void *v7;
  void *v8;

  v6 = *v4;
  if (*v4)
  {
    v1[14] = v6;
    operator delete(v6);
  }
  v7 = *v3;
  if (*v3)
  {
    v1[11] = v7;
    operator delete(v7);
  }
  v8 = *v2;
  if (*v2)
  {
    v1[8] = v8;
    operator delete(v8);
  }
  _Unwind_Resume(exception_object);
}

void sub_10030C5C0(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v2 = (void *)a1[16];
  if (v2)
  {
    a1[17] = v2;
    operator delete(v2);
  }
  v3 = (void *)a1[13];
  if (v3)
  {
    a1[14] = v3;
    operator delete(v3);
  }
  v4 = (void *)a1[10];
  if (v4)
  {
    a1[11] = v4;
    operator delete(v4);
  }
  v5 = (void *)a1[7];
  if (v5)
  {
    a1[8] = v5;
    operator delete(v5);
  }
}

void sub_10030C624(uint64_t *a1, uint64_t a2)
{
  NSObject *v4;
  CFStringRef v5;
  int v6;
  uint64_t data_low;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  NSDate *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  double v18;
  double v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t v23;
  std::string::size_type size;
  std::string::size_type v25;
  uint64_t v26;
  int *v27;
  int *v28;
  int v29;
  int v30;
  uint64_t v31;
  int v32;
  int v33;
  uint64_t v34;
  double Current;
  unint64_t v36;
  uint64_t v37;
  double v38;
  uint64_t v39;
  NSObject *v40;
  NSObject *v41;
  NSObject *v42;
  NSObject *v43;
  uint64_t v44;
  const char *v45;
  NSObject *v46;
  uint32_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  std::string v51;
  std::string v52;
  int v53;
  void *v54;
  _QWORD *v55;
  _OWORD v56[2];
  int v57;
  uint64_t v58;
  unint64_t v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  void *__p;
  _QWORD v64[3];
  uint8_t buf[8];
  _BYTE v66[10];
  __int16 v67;
  const char *v68;
  _BYTE v69[72];
  std::string v70;

  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
  v4 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 68289026;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)v66 = 2082;
    *(_QWORD *)&v66[2] = "";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"analyzing WiFi channels\"}", buf, 0x12u);
  }
  sub_10027FDF0(a1[1], &v61);
  if (v61 == v62)
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
    v41 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 68289026;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)v66 = 2082;
      *(_QWORD *)&v66[2] = "";
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"no LOI ids found\"}", buf, 0x12u);
    }
  }
  else
  {
    sub_1001E4804(buf);
    LODWORD(v51.__r_.__value_.__l.__data_) = 0;
    v5 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsNumberDaysToAnalyzeWiFiChannels", 0x8000100u, kCFAllocatorNull);
    v6 = sub_1000B1180(*(uint64_t *)buf, (uint64_t)v5, &v51);
    CFRelease(v5);
    data_low = LODWORD(v51.__r_.__value_.__l.__data_);
    v8 = *(std::__shared_weak_count **)v66;
    if (*(_QWORD *)v66)
    {
      v9 = (unint64_t *)(*(_QWORD *)v66 + 8);
      do
        v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
    if (v6)
      v11 = data_low;
    else
      v11 = 2;
    v12 = +[NSDate date](NSDate, "date");
    v58 = 0;
    v59 = 0;
    v60 = 0;
    v13 = v61;
    v49 = v62;
    if (v61 == v62)
    {
LABEL_81:
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
      v44 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 68289026;
        *(_DWORD *)&buf[4] = 0;
        *(_WORD *)v66 = 2082;
        *(_QWORD *)&v66[2] = "";
        v45 = "{\"msg%{public}.0s\":\"Wifi Channel Histogram was not generated\"}";
        v46 = v44;
        v47 = 18;
LABEL_85:
        _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, v45, buf, v47);
      }
    }
    else
    {
      v14 = (uint64_t)v12;
      do
      {
        v50 = v13;
        v15 = (uint64_t *)(v13 + 24);
        memset(v56, 0, sizeof(v56));
        v57 = 1065353216;
        if (v11)
        {
          v16 = 0;
          while (1)
          {
            v17 = *(_QWORD *)(a2 + 24);
            if (!v17)
              sub_10025FD1C();
            if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v17 + 48))(v17))
              break;
            v18 = sub_1003B1DE4(v14, ~(_DWORD)v16);
            std::to_string(&v51, v18);
            v19 = sub_1003B1DE4(v14, -(int)v16);
            std::to_string(&v52, v19);
            sub_10027D3B0(a1[1], (uint64_t)v15, (uint64_t)&v51, (uint64_t)&v52, &v54);
            if (*(_OWORD *)v15 != 0)
            {
              v20 = a1[1];
              *(_OWORD *)&v70.__r_.__value_.__l.__data_ = 0uLL;
              sub_10027D3B0(v20, (uint64_t)&v70, (uint64_t)&v51, (uint64_t)&v52, buf);
              sub_100312E88((uint64_t *)&v54, (uint64_t)v55, *(uint64_t *)buf, *(uint64_t *)v66, 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*(_QWORD *)v66 - *(_QWORD *)buf) >> 3));
              v70.__r_.__value_.__r.__words[0] = (std::string::size_type)buf;
              sub_100296984((void ***)&v70);
            }
            v21 = v54;
            v22 = v55;
            if (v54 != v55)
            {
              memset(&v70, 0, sizeof(v70));
              do
              {
                if (*((_DWORD *)v21 + 24) == 1)
                {
                  v23 = v21[6];
                  if (!v23)
                    v23 = *(_QWORD *)(qword_102310298 + 16);
                  sub_1002BD5C4(buf, v23);
                  size = v70.__r_.__value_.__l.__size_;
                  if (v70.__r_.__value_.__l.__size_ >= v70.__r_.__value_.__r.__words[2])
                  {
                    v25 = sub_1003135A0((uint64_t *)&v70, (uint64_t)buf);
                  }
                  else
                  {
                    sub_1002BD5C4(v70.__r_.__value_.__l.__size_, buf);
                    v25 = size + 48;
                  }
                  v70.__r_.__value_.__l.__size_ = v25;
                  sub_1002BD5C8((wireless_diagnostics::google::protobuf::MessageLite *)buf);
                }
                v21 += 15;
              }
              while (v21 != v22);
              sub_100343B9C(v56, (uint64_t *)&v70);
              *(_QWORD *)buf = &v70;
              sub_100313514((void ***)buf);
            }
            *(_QWORD *)buf = &v54;
            sub_100296984((void ***)buf);
            if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v52.__r_.__value_.__l.__data_);
            if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v51.__r_.__value_.__l.__data_);
            if (++v16 == v11)
              goto LABEL_38;
          }
          if (qword_1022A00F0 != -1)
            dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
          v42 = qword_1022A00F8;
          if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 68289282;
            *(_DWORD *)&buf[4] = 0;
            *(_WORD *)v66 = 2082;
            *(_QWORD *)&v66[2] = "";
            v67 = 2082;
            v68 = "MicroLocationAnalytics";
            _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"wifi channels analyitcs operation cancelled\", \"Activity\":%{public, location:escape_only}s}", buf, 0x1Cu);
          }
          sub_100067AC4((uint64_t)v56);
          goto LABEL_86;
        }
LABEL_38:
        if (sub_100343C54((uint64_t)v56))
        {
          sub_100067AC4((uint64_t)v56);
          v26 = v50;
        }
        else
        {
          sub_100343C64((uint64_t)v56, (uint64_t *)&v54);
          sub_1002BC0A0((uint64_t)&v52);
          v27 = (int *)v54;
          v28 = (int *)v55;
          if (v54 != v55)
          {
            v29 = v52.__r_.__value_.__r.__words[2];
            do
            {
              v30 = HIDWORD(v52.__r_.__value_.__r.__words[2]);
              if (v29 >= SHIDWORD(v52.__r_.__value_.__r.__words[2]))
              {
                if (HIDWORD(v52.__r_.__value_.__r.__words[2]) == v53)
                {
                  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)&v52.__r_.__value_.__r.__words[1], HIDWORD(v52.__r_.__value_.__r.__words[2]) + 1);
                  v30 = HIDWORD(v52.__r_.__value_.__r.__words[2]);
                }
                HIDWORD(v52.__r_.__value_.__r.__words[2]) = v30 + 1;
                sub_100311AB8();
              }
              LODWORD(v52.__r_.__value_.__r.__words[2]) = v29 + 1;
              v31 = *(_QWORD *)(v52.__r_.__value_.__l.__size_ + 8 * v29++);
              v32 = *v27;
              v33 = *(_DWORD *)(v31 + 24);
              *(_DWORD *)(v31 + 24) = v33 | 1;
              *(_DWORD *)(v31 + 16) = v32;
              v34 = v27[1];
              *(_DWORD *)(v31 + 24) = v33 | 3;
              *(_QWORD *)(v31 + 8) = v34;
              v27 += 2;
            }
            while (v27 != v28);
          }
          Current = j__CFAbsoluteTimeGetCurrent();
          sub_10030D10C((uint64_t)&v52, (uint64_t)&v51, Current);
          v36 = v59;
          if (v59 >= v60)
          {
            v37 = sub_10030567C(&v58, v50 + 40, (uint64_t)&v51, v15);
          }
          else
          {
            sub_1003057B8((uint64_t)&v60, v59, v50 + 40, (uint64_t)&v51, v15);
            v37 = v36 + 112;
          }
          v26 = v50;
          v59 = v37;
          v38 = sub_1003B1DE4(v14, -(int)v11);
          std::to_string(&v70, v38);
          v39 = a1[1];
          LODWORD(__p) = 0;
          sub_100282724(v39, (__int128 *)v15, (unsigned int *)&__p, (uint64_t)&v70, buf);
          if (v69[56])
          {
            sub_100343EBC((uint64_t)v69, &__p);
            sub_10030B190((uint64_t)a1, (uint64_t)&v54, (uint64_t)&__p, v50 + 40);
            if (__p)
            {
              v64[0] = __p;
              operator delete(__p);
            }
          }
          else
          {
            if (qword_1022A00F0 != -1)
              dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
            v40 = qword_1022A00F8;
            if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
            {
              __p = (void *)68289026;
              LOWORD(v64[0]) = 2082;
              *(_QWORD *)((char *)v64 + 2) = "";
              _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Wifi Channel Histogram analytics was not sent since not enough time elapsed\"}", (uint8_t *)&__p, 0x12u);
            }
          }
          sub_1002FFD68((uint64_t)buf);
          if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v70.__r_.__value_.__l.__data_);
          sub_1002E50A8((wireless_diagnostics::google::protobuf::MessageLite *)&v51);
          sub_1002E394C((uint64_t *)&v52);
          if (v54)
          {
            v55 = v54;
            operator delete(v54);
          }
          sub_100067AC4((uint64_t)v56);
        }
        v13 = v26 + 64;
      }
      while (v13 != v49);
      if (v58 == v59)
        goto LABEL_81;
      if (sub_1002FEC74(a1[1]))
      {
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
        v43 = qword_1022A00F8;
        if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 68289026;
          *(_DWORD *)&buf[4] = 0;
          *(_WORD *)v66 = 2082;
          *(_QWORD *)&v66[2] = "";
          _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Wifi Channel Histogram generated successfully\"}", buf, 0x12u);
        }
        (*(void (**)(uint64_t))(*(_QWORD *)*a1 + 16))(*a1);
      }
      else
      {
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
        v48 = qword_1022A00F8;
        if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 68289282;
          *(_DWORD *)&buf[4] = 0;
          *(_WORD *)v66 = 2082;
          *(_QWORD *)&v66[2] = "";
          v67 = 1026;
          LODWORD(v68) = 0;
          v45 = "{\"msg%{public}.0s\":\"#Warning Wifi Channel Histogram was not generated properly\", \"Inserted\":%{public}hhd}";
          v46 = v48;
          v47 = 24;
          goto LABEL_85;
        }
      }
    }
LABEL_86:
    *(_QWORD *)buf = &v58;
    sub_1002A7CB8((void ***)buf);
  }
  *(_QWORD *)buf = &v61;
  sub_10028E258((void ***)buf);
}

void sub_10030CF78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,void *__p,uint64_t a37,uint64_t a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,char a48,uint64_t a49,uint64_t a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55)
{
  a17 = &a45;
  sub_1002A7CB8((void ***)&a17);
  a17 = &a48;
  sub_10028E258((void ***)&a17);
  _Unwind_Resume(a1);
}

void sub_10030D10C(uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  unsigned int v6;
  int v7;

  sub_1002BC10C(a2);
  v6 = *(_DWORD *)(a1 + 32);
  if (!sub_10008D1F0(v6))
    __assert_rtn("set_type", "microlocation.pb.h", 21547, "::CLMicroLocationProto::ConfigurationType_IsValid(value)");
  v7 = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a2 + 40) = v6;
  *(_DWORD *)(a2 + 48) = v7 | 3;
  *(double *)(a2 + 8) = a3;
  sub_1003584A4(a2, a1);
}

void sub_10030D19C(_Unwind_Exception *a1)
{
  wireless_diagnostics::google::protobuf::MessageLite *v1;

  sub_1002E50A8(v1);
  _Unwind_Resume(a1);
}

void sub_10030D1B0(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  BOOL v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  uint8_t buf[4];
  int v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  uint64_t v19;
  _BYTE v20[24];
  _BYTE *v21;

  if ((sub_10030B674() & 1) != 0)
  {
    sub_100270E34((uint64_t)v20, a2);
    sub_10030D424(a1, (uint64_t)v20, &v12);
    v4 = v21;
    if (v21 == v20)
    {
      v5 = 4;
      v4 = v20;
    }
    else
    {
      if (!v21)
      {
LABEL_11:
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
        v7 = qword_1022A00F8;
        v8 = os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT);
        v9 = v12;
        v10 = v13;
        if (v8)
        {
          *(_DWORD *)buf = 68289282;
          v15 = 0;
          v16 = 2082;
          v17 = "";
          v18 = 2050;
          v19 = v13 - v12;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"sending CoreAnalytics com.apple.MicroLocation.AssociatedState\", \"num events\":%{public}lu}", buf, 0x1Cu);
        }
        if (v9 != v10)
        {
          v11 = v9;
          do
            AnalyticsSendEvent(CFSTR("com.apple.MicroLocation.AssociatedState"), *v11++);
          while (v11 != v10);
        }
        if (v9)
          operator delete(v9);
        return;
      }
      v5 = 5;
    }
    (*(void (**)(void))(*v4 + 8 * v5))();
    goto LABEL_11;
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
  v6 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289026;
    v15 = 0;
    v16 = 2082;
    v17 = "";
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"not analyzing associated state, since sending to core-analytics is disabled\"}", buf, 0x12u);
  }
}

void sub_10030D3D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,char *a21)
{
  char *v21;
  char *v23;
  uint64_t v24;

  v23 = a21;
  if (a21 == v21)
  {
    v24 = 4;
    v23 = &a18;
  }
  else
  {
    if (!a21)
      goto LABEL_6;
    v24 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v23 + 8 * v24))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_10030D424(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  NSObject *v6;
  CFStringRef v7;
  int v8;
  uint64_t data_low;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  NSDate *v14;
  __int128 v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  double v20;
  double v21;
  _DWORD *v22;
  _DWORD *v23;
  BOOL v24;
  _DWORD *v25;
  _DWORD *v26;
  BOOL v27;
  id v28;
  std::string *v29;
  char *v30;
  void *v31;
  id v32;
  std::string *v33;
  char *v34;
  void *v35;
  int64_t v36;
  unint64_t v37;
  unint64_t v38;
  char *v39;
  int64_t v40;
  unint64_t v41;
  unint64_t v42;
  char *v43;
  char *v44;
  char *v45;
  char *v46;
  uint64_t v47;
  NSObject *v48;
  _OWORD *v49;
  const char *p_p;
  std::string *v51;
  char *v52;
  char *v53;
  char *v54;
  uint64_t v55;
  NSObject *v56;
  _OWORD *v57;
  const char *v58;
  std::string *v59;
  NSObject *v60;
  NSObject *v61;
  char *v62;
  _QWORD *v63;
  char *v64;
  std::string v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  char v69;
  void *__p;
  __int128 v71;
  unsigned __int8 *v72;
  unsigned __int8 *v73;
  uint64_t v74;
  unsigned __int8 *v75;
  unsigned __int8 *v76;
  uint64_t v77;
  void *v78[2];
  char *v79;
  void *v80;
  char *v81;
  unsigned __int8 **v82;
  void **v83;
  uint8_t buf[8];
  _BYTE v85[10];
  __int16 v86;
  const char *v87;
  __int16 v88;
  std::string *v89;
  __int16 v90;
  int v91;
  __int16 v92;
  uint64_t v93;
  __int16 v94;
  uint64_t v95;
  __int16 v96;
  uint64_t v97;

  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
  v6 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_QWORD *)buf = 68289026;
    *(_WORD *)v85 = 2082;
    *(_QWORD *)&v85[2] = "";
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"analyzing associated state\"}", buf, 0x12u);
  }
  sub_100285FF8(*(_QWORD *)(a1 + 8), &v80);
  if (v80 == v81)
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
    v60 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      *(_QWORD *)buf = 68289026;
      *(_WORD *)v85 = 2082;
      *(_QWORD *)&v85[2] = "";
      _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"analyzeAssociationState, no LOI IDs found\"}", buf, 0x12u);
    }
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
  }
  else
  {
    sub_1001E4804(buf);
    LODWORD(v65.__r_.__value_.__l.__data_) = 0;
    v7 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsNumberDaysToAnalyzeAssociationState", 0x8000100u, kCFAllocatorNull);
    v8 = sub_1000B1180(*(uint64_t *)buf, (uint64_t)v7, &v65);
    CFRelease(v7);
    data_low = LODWORD(v65.__r_.__value_.__l.__data_);
    v10 = *(std::__shared_weak_count **)v85;
    if (*(_QWORD *)v85)
    {
      v11 = (unint64_t *)(*(_QWORD *)v85 + 8);
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    if (v8)
      v13 = data_low;
    else
      v13 = 7;
    v14 = +[NSDate date](NSDate, "date");
    v79 = 0;
    v15 = 0uLL;
    *(_OWORD *)v78 = 0u;
    v16 = (char *)v80;
    v64 = v81;
    if (v80 == v81)
    {
      v62 = 0;
LABEL_136:
      *(_OWORD *)a3 = v15;
      a3[2] = v62;
    }
    else
    {
      v17 = (uint64_t)v14;
      v63 = a3;
      while (1)
      {
        v75 = 0;
        v76 = 0;
        v77 = 0;
        v72 = 0;
        v73 = 0;
        v74 = 0;
        if (v13)
          break;
        v83 = (void **)v16;
LABEL_55:
        if (v73 != v72)
        {
          sub_10030E0A4((uint64_t)&v83, &v72, (uint64_t)&v65);
          if (v69)
          {
            v32 = objc_alloc_init((Class)NSMutableDictionary);
            objc_msgSend(v32, "setObject:forKeyedSubscript:", &off_10221B018, CFSTR("Band"));
            if (!v69
              || ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                ? (v33 = &v65)
                : (v33 = (std::string *)v65.__r_.__value_.__r.__words[0]),
                  (objc_msgSend(v32, "setObject:forKeyedSubscript:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v33), CFSTR("rtLoiType")), !v69)|| (objc_msgSend(v32, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v66), CFSTR("NumberOfMacAddresses")), !v69)|| (objc_msgSend(v32, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v67), CFSTR("NumberOfChannels")), !v69)))
            {
              sub_10028DF3C();
            }
            objc_msgSend(v32, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v68), CFSTR("NumberOfMacAddressAppearingOnMultipleChannels"));
            v34 = (char *)v78[1];
            if (v78[1] >= v79)
            {
              v36 = ((char *)v78[1] - (char *)v78[0]) >> 3;
              if ((unint64_t)(v36 + 1) >> 61)
                sub_100259694();
              v37 = (v79 - (char *)v78[0]) >> 2;
              if (v37 <= v36 + 1)
                v37 = v36 + 1;
              if ((unint64_t)(v79 - (char *)v78[0]) >= 0x7FFFFFFFFFFFFFF8)
                v38 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v38 = v37;
              if (v38)
                v39 = (char *)sub_10025E6A0((uint64_t)&v79, v38);
              else
                v39 = 0;
              v44 = &v39[8 * v36];
              *(_QWORD *)v44 = v32;
              v35 = v44 + 8;
              v46 = (char *)v78[0];
              v45 = (char *)v78[1];
              if (v78[1] != v78[0])
              {
                do
                {
                  v47 = *((_QWORD *)v45 - 1);
                  v45 -= 8;
                  *((_QWORD *)v44 - 1) = v47;
                  v44 -= 8;
                }
                while (v45 != v46);
                v45 = (char *)v78[0];
              }
              v78[0] = v44;
              v78[1] = v35;
              v79 = &v39[8 * v38];
              if (v45)
                operator delete(v45);
            }
            else
            {
              *(_QWORD *)v78[1] = v32;
              v35 = v34 + 8;
            }
            v78[1] = v35;
            if (qword_1022A00F0 != -1)
              dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
            v48 = qword_1022A00F8;
            if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
            {
              v49 = operator new(0x28uLL);
              __p = v49;
              v71 = xmmword_101B97FF0;
              *v49 = 0u;
              v49[1] = 0u;
              *(_QWORD *)((char *)v49 + 29) = 0;
              sub_100261F9C((uint64_t)v16, v49);
              if (!v69)
                sub_10028DF3C();
              if (v71 >= 0)
                p_p = (const char *)&__p;
              else
                p_p = (const char *)__p;
              v51 = &v65;
              if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                v51 = (std::string *)v65.__r_.__value_.__r.__words[0];
              *(_QWORD *)buf = 68290563;
              *(_WORD *)v85 = 2082;
              *(_QWORD *)&v85[2] = "";
              v86 = 2081;
              v87 = p_p;
              v88 = 2082;
              v89 = v51;
              v90 = 1026;
              v91 = 5;
              v92 = 2050;
              v93 = v66;
              v94 = 2050;
              v95 = v67;
              v96 = 2050;
              v97 = v68;
              _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMicroLocationAnalytics, analyzeAssociationState\", \"rtGroupLoiId\":%{private, location:escape_only}s, \"rtLoiType\":%{public, location:escape_only}s, \"Band\":%{public}d, \"numberOfMacAddresses\":%{public}llu, \"NumberOfChannels\":%{public}llu, \"NumberOfMacAddressAppearingOnMultipleChannels\":%{public}llu}", buf, 0x4Au);
              if (SHIBYTE(v71) < 0)
                operator delete(__p);
            }
            if (v69 && SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v65.__r_.__value_.__l.__data_);
          }
        }
        *(_QWORD *)buf = &v72;
        sub_100313844((void ***)buf);
        *(_QWORD *)buf = &v75;
        sub_100313844((void ***)buf);
        v16 += 16;
        if (v16 == v64)
        {
          v15 = *(_OWORD *)v78;
          v62 = v79;
          a3 = v63;
          goto LABEL_136;
        }
      }
      v18 = 0;
      while (1)
      {
        v19 = *(_QWORD *)(a2 + 24);
        if (!v19)
          sub_10025FD1C();
        if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v19 + 48))(v19))
          break;
        v20 = sub_1003B1DE4(v17, ~(_DWORD)v18);
        std::to_string((std::string *)buf, v20);
        v21 = sub_1003B1DE4(v17, -(int)v18);
        std::to_string(&v65, v21);
        sub_1002862FC(*(_QWORD *)(a1 + 8), (uint64_t)buf, (uint64_t)&v65, *(_QWORD *)v16, *((_QWORD *)v16 + 1), &__p);
        v23 = __p;
        v22 = (_DWORD *)v71;
        if (__p != (void *)v71)
        {
          v82 = &v75;
          do
          {
            if (*((_BYTE *)v23 + 48))
              v24 = v23[16] == 2;
            else
              v24 = 0;
            if (v24)
              sub_1003138D0((uint64_t **)&v82, (__int128 *)v23);
            v23 += 18;
          }
          while (v23 != v22);
          v26 = __p;
          v25 = (_DWORD *)v71;
          v82 = &v72;
          while (v26 != v25)
          {
            if (*((_BYTE *)v26 + 48))
              v27 = v26[16] == 5;
            else
              v27 = 0;
            if (v27)
              sub_1003138D0((uint64_t **)&v82, (__int128 *)v26);
            v26 += 18;
          }
        }
        v83 = &__p;
        sub_100313844(&v83);
        if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v65.__r_.__value_.__l.__data_);
        if (SBYTE3(v87) < 0)
          operator delete(*(void **)buf);
        if (++v18 == v13)
        {
          v83 = (void **)v16;
          if (v76 != v75)
          {
            sub_10030E0A4((uint64_t)&v83, &v75, (uint64_t)&v65);
            if (v69)
            {
              v28 = objc_alloc_init((Class)NSMutableDictionary);
              objc_msgSend(v28, "setObject:forKeyedSubscript:", &off_10221B000, CFSTR("Band"));
              if (!v69
                || ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                  ? (v29 = &v65)
                  : (v29 = (std::string *)v65.__r_.__value_.__r.__words[0]),
                    (objc_msgSend(v28, "setObject:forKeyedSubscript:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v29), CFSTR("rtLoiType")), !v69)|| (objc_msgSend(v28, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v66), CFSTR("NumberOfMacAddresses")), !v69)|| (objc_msgSend(v28, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v67), CFSTR("NumberOfChannels")), !v69)))
              {
                sub_10028DF3C();
              }
              objc_msgSend(v28, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v68), CFSTR("NumberOfMacAddressAppearingOnMultipleChannels"));
              v30 = (char *)v78[1];
              if (v78[1] >= v79)
              {
                v40 = ((char *)v78[1] - (char *)v78[0]) >> 3;
                if ((unint64_t)(v40 + 1) >> 61)
                  sub_100259694();
                v41 = (v79 - (char *)v78[0]) >> 2;
                if (v41 <= v40 + 1)
                  v41 = v40 + 1;
                if ((unint64_t)(v79 - (char *)v78[0]) >= 0x7FFFFFFFFFFFFFF8)
                  v42 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v42 = v41;
                if (v42)
                  v43 = (char *)sub_10025E6A0((uint64_t)&v79, v42);
                else
                  v43 = 0;
                v52 = &v43[8 * v40];
                *(_QWORD *)v52 = v28;
                v31 = v52 + 8;
                v54 = (char *)v78[0];
                v53 = (char *)v78[1];
                if (v78[1] != v78[0])
                {
                  do
                  {
                    v55 = *((_QWORD *)v53 - 1);
                    v53 -= 8;
                    *((_QWORD *)v52 - 1) = v55;
                    v52 -= 8;
                  }
                  while (v53 != v54);
                  v53 = (char *)v78[0];
                }
                v78[0] = v52;
                v78[1] = v31;
                v79 = &v43[8 * v42];
                if (v53)
                  operator delete(v53);
              }
              else
              {
                *(_QWORD *)v78[1] = v28;
                v31 = v30 + 8;
              }
              v78[1] = v31;
              if (qword_1022A00F0 != -1)
                dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
              v56 = qword_1022A00F8;
              if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
              {
                v57 = operator new(0x28uLL);
                __p = v57;
                v71 = xmmword_101B97FF0;
                *v57 = 0u;
                v57[1] = 0u;
                *(_QWORD *)((char *)v57 + 29) = 0;
                sub_100261F9C((uint64_t)v16, v57);
                if (!v69)
                  sub_10028DF3C();
                if (v71 >= 0)
                  v58 = (const char *)&__p;
                else
                  v58 = (const char *)__p;
                v59 = &v65;
                if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                  v59 = (std::string *)v65.__r_.__value_.__r.__words[0];
                *(_QWORD *)buf = 68290563;
                *(_WORD *)v85 = 2082;
                *(_QWORD *)&v85[2] = "";
                v86 = 2081;
                v87 = v58;
                v88 = 2082;
                v89 = v59;
                v90 = 1026;
                v91 = 2;
                v92 = 2050;
                v93 = v66;
                v94 = 2050;
                v95 = v67;
                v96 = 2050;
                v97 = v68;
                _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMicroLocationAnalytics, analyzeAssociationState\", \"rtGroupLoiId\":%{private, location:escape_only}s, \"rtLoiType\":%{public, location:escape_only}s, \"Band\":%{public}d, \"numberOfMacAddresses\":%{public}llu, \"NumberOfChannels\":%{public}llu, \"NumberOfMacAddressAppearingOnMultipleChannels\":%{public}llu}", buf, 0x4Au);
                if (SHIBYTE(v71) < 0)
                  operator delete(__p);
              }
              if (v69 && SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0)
                operator delete(v65.__r_.__value_.__l.__data_);
            }
          }
          goto LABEL_55;
        }
      }
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
      v61 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        *(_QWORD *)buf = 68289282;
        *(_WORD *)v85 = 2082;
        *(_QWORD *)&v85[2] = "";
        v86 = 2082;
        v87 = "MicroLocationAnalytics";
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"analyzeAssociationState cancelled\", \"Activity\":%{public, location:escape_only}s}", buf, 0x1Cu);
      }
      *v63 = 0;
      v63[1] = 0;
      v63[2] = 0;
      *(_QWORD *)buf = &v72;
      sub_100313844((void ***)buf);
      *(_QWORD *)buf = &v75;
      sub_100313844((void ***)buf);
      if (v78[0])
      {
        v78[1] = v78[0];
        operator delete(v78[0]);
      }
    }
  }
  if (v80)
  {
    v81 = (char *)v80;
    operator delete(v80);
  }
}

void sub_10030DF78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,char a33,uint64_t a34,uint64_t a35,char a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,uint64_t a41,void *a42,uint64_t a43)
{
  uint64_t v43;

  if (a32 < 0)
    operator delete(__p);
  if (a26 && a22 < 0)
    operator delete(a17);
  *(_QWORD *)(v43 - 192) = &a33;
  sub_100313844((void ***)(v43 - 192));
  *(_QWORD *)(v43 - 192) = &a36;
  sub_100313844((void ***)(v43 - 192));
  if (a39)
  {
    a40 = (uint64_t)a39;
    operator delete(a39);
  }
  if (a42)
  {
    a43 = (uint64_t)a42;
    operator delete(a42);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10030E0A4@<X0>(uint64_t result@<X0>, unsigned __int8 **a2@<X1>, uint64_t a3@<X8>)
{
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  uint64_t *v6;
  int *v7;
  uint64_t **v8;
  NSObject *v9;
  uint64_t v10;
  char *v11;
  void **v12;
  NSObject *v13;
  uint64_t v14;
  char *v15;
  void **v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *__p[2];
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  int v25;
  __int128 v26;
  __int128 v27;
  int v28;
  __int128 v29;
  __int128 v30;
  int v31;
  _BYTE buf[40];

  v4 = *a2;
  v5 = a2[1];
  if (v5 == *a2)
  {
    *(_BYTE *)a3 = 0;
    *(_BYTE *)(a3 + 48) = 0;
  }
  else
  {
    v6 = (uint64_t *)result;
    v29 = 0u;
    v30 = 0u;
    v31 = 1065353216;
    v26 = 0u;
    v27 = 0u;
    v28 = 1065353216;
    v23 = 0u;
    v24 = 0u;
    v25 = 1065353216;
    do
    {
      sub_100311C38((uint64_t)&v29, v4, (uint64_t)v4);
      v7 = (int *)(v4 + 56);
      __p[0] = (void *)sub_100129380((uint64_t)v7);
      *(_QWORD *)buf = __p;
      v8 = (uint64_t **)sub_100311F54((uint64_t)&v23, (unint64_t *)__p, (uint64_t)&unk_101B9EB60, (uint64_t **)buf);
      v7 += 3;
      sub_1000C6190(v8 + 3, v7, v7);
      sub_1003121F0((uint64_t)&v26, v7, v7);
      v4 = (unsigned __int8 *)(v7 + 1);
    }
    while (v4 != v5);
    if (*((_QWORD *)&v30 + 1) <= 1uLL)
    {
      if (*(char *)(v30 + 39) < 0)
      {
        sub_100115CE4(__p, *(void **)(v30 + 16), *(_QWORD *)(v30 + 24));
      }
      else
      {
        *(_OWORD *)__p = *(_OWORD *)(v30 + 16);
        v22 = *(_QWORD *)(v30 + 32);
      }
      v17 = (_QWORD *)v24;
      if ((_QWORD)v24)
      {
        v18 = 0;
        do
        {
          if (v17[5] > 1uLL)
            ++v18;
          v17 = (_QWORD *)*v17;
        }
        while (v17);
      }
      else
      {
        v18 = 0;
      }
      v19 = *((_QWORD *)&v24 + 1);
      v20 = *((_QWORD *)&v27 + 1);
      if (SHIBYTE(v22) < 0)
      {
        sub_100115CE4(buf, __p[0], (unint64_t)__p[1]);
      }
      else
      {
        *(_OWORD *)buf = *(_OWORD *)__p;
        *(_QWORD *)&buf[16] = v22;
      }
      *(_QWORD *)&buf[24] = v19;
      *(_QWORD *)&buf[32] = v20;
      *(_OWORD *)a3 = *(_OWORD *)buf;
      *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
      *(_QWORD *)(a3 + 40) = v18;
      *(_OWORD *)(a3 + 24) = *(_OWORD *)&buf[24];
      *(_BYTE *)(a3 + 48) = 1;
      if (SHIBYTE(v22) < 0)
        operator delete(__p[0]);
    }
    else
    {
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
      v9 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
      {
        v10 = *v6;
        v11 = (char *)operator new(0x28uLL);
        *(_QWORD *)(v11 + 29) = 0;
        *(_OWORD *)v11 = 0u;
        *((_OWORD *)v11 + 1) = 0u;
        sub_100261F9C(v10, v11);
        sub_100311B18((uint64_t)&v29, ",", (uint64_t)__p);
        if (v22 >= 0)
          v12 = __p;
        else
          v12 = (void **)__p[0];
        *(_QWORD *)buf = 68289538;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2082;
        *(_QWORD *)&buf[20] = v11;
        *(_WORD *)&buf[28] = 2082;
        *(_QWORD *)&buf[30] = v12;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"analyzeAssociationState, loiGroupId without unique rtLoiType\", \"LoiGroupId\":%{public, location:escape_only}s, \"LoiTypes\":%{public, location:escape_only}s}", buf, 0x26u);
        if (SHIBYTE(v22) < 0)
          operator delete(__p[0]);
        operator delete(v11);
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
      }
      v13 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v14 = *v6;
        v15 = (char *)operator new(0x28uLL);
        *(_QWORD *)(v15 + 29) = 0;
        *(_OWORD *)v15 = 0u;
        *((_OWORD *)v15 + 1) = 0u;
        sub_100261F9C(v14, v15);
        sub_100311B18((uint64_t)&v29, ",", (uint64_t)__p);
        if (v22 >= 0)
          v16 = __p;
        else
          v16 = (void **)__p[0];
        *(_QWORD *)buf = 68289538;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2082;
        *(_QWORD *)&buf[20] = v15;
        *(_WORD *)&buf[28] = 2082;
        *(_QWORD *)&buf[30] = v16;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v13, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "analyzeAssociationState, loiGroupId without unique rtLoiType", "{\"msg%{public}.0s\":\"analyzeAssociationState, loiGroupId without unique rtLoiType\", \"LoiGroupId\":%{public, location:escape_only}s, \"LoiTypes\":%{public, location:escape_only}s}", buf, 0x26u);
        if (SHIBYTE(v22) < 0)
          operator delete(__p[0]);
        operator delete(v15);
      }
      *(_BYTE *)a3 = 0;
      *(_BYTE *)(a3 + 48) = 0;
    }
    sub_100312408((uint64_t)&v23);
    sub_100067AC4((uint64_t)&v26);
    return sub_1002A1C94((uint64_t)&v29);
  }
  return result;
}

void sub_10030E4C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  if (a14 < 0)
    operator delete(__p);
  sub_100312408((uint64_t)&a16);
  sub_100067AC4((uint64_t)&a22);
  sub_1002A1C94((uint64_t)&a28);
  _Unwind_Resume(a1);
}

void sub_10030E530(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  NSObject *v8;
  uint32_t v9;
  uint64_t v10;
  id v11;
  NSObject *v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  id v17;
  id v18;
  char *v19;
  char *v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  char *v24;
  char *v25;
  char *v26;
  char *v27;
  uint64_t v28;
  NSObject *v29;
  const char *v30;
  char *v31;
  char *v32;
  NSObject *v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  char *v37;
  char *v38;
  uint8_t buf[8];
  __int16 v40;
  const char *v41;
  __int16 v42;
  const char *v43;
  __int16 v44;
  uint64_t v45;

  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
  v4 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289026;
    *(_DWORD *)&buf[4] = 0;
    v40 = 2082;
    v41 = "";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"analyzing LOI usage\"}", buf, 0x12u);
  }
  if ((sub_10030B674() & 1) != 0)
  {
    v5 = *(_QWORD *)(a2 + 24);
    if (!v5)
      sub_10025FD1C();
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 48))(v5))
    {
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
      v6 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 68289282;
        *(_DWORD *)&buf[4] = 0;
        v40 = 2082;
        v41 = "";
        v42 = 2082;
        v43 = "MicroLocationAnalytics";
        v7 = "{\"msg%{public}.0s\":\"LOI usage analytics canceled\", \"Activity\":%{public, location:escape_only}s}";
        v8 = v6;
        v9 = 28;
LABEL_16:
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, buf, v9);
        return;
      }
      return;
    }
    v11 = sub_10030EB2C(a1);
    if (v11)
    {
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
      v12 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        v13 = (const char *)objc_msgSend(CFSTR("com.apple.MicroLocation.Visit"), "UTF8String");
        *(_DWORD *)buf = 68289282;
        *(_DWORD *)&buf[4] = 0;
        v40 = 2082;
        v41 = "";
        v42 = 2082;
        v43 = v13;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Sending analytics event.\", \"Event name\":%{public, location:escape_only}s}", buf, 0x1Cu);
      }
      AnalyticsSendEvent(CFSTR("com.apple.MicroLocation.Visit"), v11);
    }
    v36 = 0;
    v37 = 0;
    v38 = 0;
    sub_10027FDF0(*(_QWORD *)(a1 + 8), &v34);
    v14 = v34;
    v15 = v35;
    if (v34 == v35)
    {
LABEL_45:
      *(_QWORD *)buf = &v34;
      sub_10028E258((void ***)buf);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
      v29 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        v30 = (const char *)objc_msgSend(CFSTR("com.apple.MicroLocation.Location"), "UTF8String");
        *(_DWORD *)buf = 68289538;
        *(_DWORD *)&buf[4] = 0;
        v40 = 2082;
        v41 = "";
        v42 = 2082;
        v43 = v30;
        v44 = 2050;
        v45 = (v37 - v36) >> 3;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Sending analytics events.\", \"Event name\":%{public, location:escape_only}s, \"Number of events\":%{public}lu}", buf, 0x26u);
      }
      v31 = v36;
      v32 = v37;
      if (v36 == v37)
        goto LABEL_58;
      do
      {
        AnalyticsSendEvent(CFSTR("com.apple.MicroLocation.Location"), *(_QWORD *)v31);
        v31 += 8;
      }
      while (v31 != v32);
    }
    else
    {
      while (1)
      {
        v16 = *(_QWORD *)(a2 + 24);
        if (!v16)
          sub_10025FD1C();
        if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v16 + 48))(v16))
          break;
        v17 = sub_10030F000(a1, (uint64_t *)(v14 + 24));
        v18 = v17;
        if (v17)
        {
          v19 = v37;
          if (v37 >= v38)
          {
            v21 = (v37 - v36) >> 3;
            if ((unint64_t)(v21 + 1) >> 61)
              sub_100259694();
            v22 = (v38 - v36) >> 2;
            if (v22 <= v21 + 1)
              v22 = v21 + 1;
            if ((unint64_t)(v38 - v36) >= 0x7FFFFFFFFFFFFFF8)
              v23 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v23 = v22;
            if (v23)
              v24 = (char *)sub_10025E6A0((uint64_t)&v38, v23);
            else
              v24 = 0;
            v25 = &v24[8 * v21];
            *(_QWORD *)v25 = v18;
            v20 = v25 + 8;
            v27 = v36;
            v26 = v37;
            if (v37 != v36)
            {
              do
              {
                v28 = *((_QWORD *)v26 - 1);
                v26 -= 8;
                *((_QWORD *)v25 - 1) = v28;
                v25 -= 8;
              }
              while (v26 != v27);
              v26 = v36;
            }
            v36 = v25;
            v37 = v20;
            v38 = &v24[8 * v23];
            if (v26)
              operator delete(v26);
          }
          else
          {
            *(_QWORD *)v37 = v17;
            v20 = v19 + 8;
          }
          v37 = v20;
        }
        v14 += 64;
        if (v14 == v15)
          goto LABEL_45;
      }
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
      v33 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 68289282;
        *(_DWORD *)&buf[4] = 0;
        v40 = 2082;
        v41 = "";
        v42 = 2082;
        v43 = "MicroLocationAnalytics";
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"LOI usage analytics canceled\", \"Activity\":%{public, location:escape_only}s}", buf, 0x1Cu);
      }
      *(_QWORD *)buf = &v34;
      sub_10028E258((void ***)buf);
    }
    v31 = v36;
LABEL_58:
    if (v31)
    {
      v37 = v31;
      operator delete(v31);
    }
    return;
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
  v10 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289026;
    *(_DWORD *)&buf[4] = 0;
    v40 = 2082;
    v41 = "";
    v7 = "{\"msg%{public}.0s\":\"not analyzing Locations of Interest usage, since sending to core-analytics is disabled\"}";
    v8 = v10;
    v9 = 18;
    goto LABEL_16;
  }
}

void sub_10030EAD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

id sub_10030EB2C(uint64_t a1)
{
  NSObject *v2;
  __int128 *v3;
  __int128 *v4;
  __int128 *v5;
  _BOOL8 v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  void **v12;
  __int128 v13;
  __int128 *v14;
  uint64_t v15;
  unsigned __int8 *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  id v23;
  uint64_t v24;
  void *__p[2];
  char v27;
  __int128 *v28;
  __int128 *v29;
  void **v30;
  uint8_t buf[32];
  int v32;

  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
  v2 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289282;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = "";
    *(_WORD *)&buf[18] = 2082;
    *(_QWORD *)&buf[20] = objc_msgSend(CFSTR("com.apple.MicroLocation.Visit"), "UTF8String");
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Creating analytics event.\", \"Event name\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
  sub_10027FDF0(*(_QWORD *)(a1 + 8), (uint64_t *)&v28);
  v3 = v28;
  v4 = v29;
  if (v28 == v29)
  {
    v6 = 0;
    v8 = (uint64_t)v28;
  }
  else
  {
    v5 = v28 + 4;
    do
    {
      v6 = *(__int128 *)((char *)v5 - 40) == 0;
      v7 = *(__int128 *)((char *)v5 - 40) == 0 || v5 == v29;
      v5 += 4;
    }
    while (!v7);
    v8 = (uint64_t)v28;
    while (*(_OWORD *)(v8 + 24) != 0)
    {
      v8 += 64;
      if ((__int128 *)v8 == v29)
      {
        v3 = v29;
        v8 = (uint64_t)v29;
        goto LABEL_26;
      }
    }
    if ((__int128 *)v8 == v29 || (v9 = v8 + 64, (__int128 *)(v8 + 64) == v29))
    {
      v3 = v29;
    }
    else
    {
      do
      {
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = 0;
        if (*(_OWORD *)(v9 + 24) != 0)
        {
          v10 = *(_OWORD *)v9;
          v11 = *(_OWORD *)(v9 + 16);
          *(_QWORD *)(v8 + 32) = *(_QWORD *)(v9 + 32);
          *(_OWORD *)v8 = v10;
          *(_OWORD *)(v8 + 16) = v11;
          v12 = (void **)(v8 + 40);
          if (*(char *)(v8 + 63) < 0)
            operator delete(*v12);
          v13 = *(_OWORD *)(v9 + 40);
          *(_QWORD *)(v8 + 56) = *(_QWORD *)(v9 + 56);
          *(_OWORD *)v12 = v13;
          *(_BYTE *)(v9 + 63) = 0;
          *(_BYTE *)(v9 + 40) = 0;
          v8 += 64;
        }
        v9 += 64;
      }
      while ((__int128 *)v9 != v4);
      v3 = v29;
    }
  }
LABEL_26:
  sub_10030F86C((uint64_t)&v28, v8, v3);
  memset(buf, 0, sizeof(buf));
  v32 = 1065353216;
  v15 = (uint64_t)v28;
  v14 = v29;
  if (v28 == v29)
  {
    v17 = (uint64_t)v28;
  }
  else
  {
    do
    {
      __p[0] = (void *)(v15 + 40);
      v16 = sub_100313D14((uint64_t)buf, (unsigned __int8 *)(v15 + 40), (uint64_t)&unk_101B9EB60, (__int128 **)__p);
      ++*((_QWORD *)v16 + 5);
      v15 += 64;
    }
    while ((__int128 *)v15 != v14);
    v15 = (uint64_t)v28;
    v17 = (uint64_t)v29;
  }
  sub_1015A2E04(__p, "home");
  v30 = __p;
  v18 = *((_QWORD *)sub_100314050((uint64_t)buf, (unsigned __int8 *)__p, (uint64_t)&unk_101B9EB60, (__int128 **)&v30) + 5);
  if (v27 < 0)
    operator delete(__p[0]);
  sub_1015A2E04(__p, "work");
  v30 = __p;
  v19 = *((_QWORD *)sub_100314050((uint64_t)buf, (unsigned __int8 *)__p, (uint64_t)&unk_101B9EB60, (__int128 **)&v30) + 5);
  if (v27 < 0)
    operator delete(__p[0]);
  sub_1015A2E04(__p, "airplay");
  v30 = __p;
  v20 = *((_QWORD *)sub_100314050((uint64_t)buf, (unsigned __int8 *)__p, (uint64_t)&unk_101B9EB60, (__int128 **)&v30) + 5);
  if (v27 < 0)
    operator delete(__p[0]);
  v21 = sub_10030F8F0(*(_QWORD *)(a1 + 8));
  v22 = sub_1002833B8(*(_QWORD *)(a1 + 8));
  v23 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
  v24 = (v17 - v15) >> 6;
  objc_msgSend(v23, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v24), CFSTR("loiCount"));
  objc_msgSend(v23, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v18), CFSTR("loiHomeCount"));
  objc_msgSend(v23, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v19), CFSTR("loiWorkCount"));
  objc_msgSend(v23, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v20), CFSTR("loiAirplayCount"));
  objc_msgSend(v23, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v24 - v18), CFSTR("loiNotHomeCount"));
  objc_msgSend(v23, "setObject:forKeyedSubscript:", +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v6), CFSTR("hasLegacy"));
  objc_msgSend(v23, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", (v21 - v22)), CFSTR("deduplicatedLoiCount"));
  sub_1002A1C94((uint64_t)buf);
  *(_QWORD *)buf = &v28;
  sub_10028E258((void ***)buf);
  return v23;
}

void sub_10030EF98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char *a20)
{
  if (a14 < 0)
    operator delete(__p);
  sub_1002A1C94((uint64_t)&a20);
  a20 = &a15;
  sub_10028E258((void ***)&a20);
  _Unwind_Resume(a1);
}

id sub_10030F000(uint64_t a1, uint64_t *a2)
{
  NSObject *v4;
  id v5;
  std::string *v6;
  _QWORD *v7;
  _QWORD *v8;
  NSObject *v9;
  int v10;
  std::string::size_type v11;
  std::string *v12;
  std::string *v13;
  double v14;
  uint64_t *v15;
  uint64_t *v16;
  double *v17;
  double *v18;
  double v20;
  double *v21;
  double v22;
  double v23;
  NSObject *v24;
  std::string *v25;
  NSObject *v26;
  std::string *v27;
  id v28;
  double Current;
  _BOOL8 v30;
  unint64_t v31;
  unint64_t v32;
  void *v34;
  char *v35;
  uint64_t v36;
  std::string v37;
  _QWORD *v38;
  _QWORD *v39;
  std::string v40;
  uint64_t v41;
  void **v42;
  uint8_t buf[8];
  _BYTE v44[20];
  __int16 v45;
  std::string *v46;
  unsigned __int8 v47;
  unsigned __int8 v48;
  std::string __p[10];
  unsigned __int8 v50;

  memset(&v40, 0, sizeof(v40));
  if ((sub_10026A098((uint64_t)a2, &v40) & 1) == 0)
  {
    std::bad_cast::bad_cast((std::bad_cast *)buf);
    *(_QWORD *)buf = &off_10212A508;
    sub_10026A9C8((uint64_t)buf);
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
  v4 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    v5 = objc_msgSend(CFSTR("com.apple.MicroLocation.Location"), "UTF8String");
    v6 = &v40;
    if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v6 = (std::string *)v40.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 68289538;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)v44 = 2082;
    *(_QWORD *)&v44[2] = "";
    *(_WORD *)&v44[10] = 2082;
    *(_QWORD *)&v44[12] = v5;
    v45 = 2082;
    v46 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Creating analytics event.\", \"Event name\":%{public, location:escape_only}s, \"LOI Group ID\":%{public, location:escape_only}s}", buf, 0x26u);
  }
  sub_100283660(*(_QWORD *)(a1 + 8), (uint64_t)a2, &v38);
  v8 = v38;
  v7 = v39;
  if (v39 == v38)
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
    v24 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      memset(&v37, 0, sizeof(v37));
      if ((sub_10026A098((uint64_t)a2, &v37) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)__p);
        __p[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&off_10212A508;
        sub_10026A9C8((uint64_t)__p);
      }
      v25 = &v37;
      if ((v37.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v25 = (std::string *)v37.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289282;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)v44 = 2082;
      *(_QWORD *)&v44[2] = "";
      *(_WORD *)&v44[10] = 2082;
      *(_QWORD *)&v44[12] = v25;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"No LOI entries for specified LOI Group ID\", \"LOIGroupId\":%{public, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v37.__r_.__value_.__l.__data_);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
    }
    v26 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      memset(&v37, 0, sizeof(v37));
      if ((sub_10026A098((uint64_t)a2, &v37) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)__p);
        __p[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&off_10212A508;
        sub_10026A9C8((uint64_t)__p);
      }
      v27 = &v37;
      if ((v37.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v27 = (std::string *)v37.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289282;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)v44 = 2082;
      *(_QWORD *)&v44[2] = "";
      *(_WORD *)&v44[10] = 2082;
      *(_QWORD *)&v44[12] = v27;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v26, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "No LOI entries for specified LOI Group ID", "{\"msg%{public}.0s\":\"No LOI entries for specified LOI Group ID\", \"LOIGroupId\":%{public, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v37.__r_.__value_.__l.__data_);
    }
    v28 = 0;
  }
  else
  {
    memset(&v37, 0, sizeof(v37));
    v34 = &v37;
    do
    {
      memset(__p, 0, 24);
      if ((sub_10026A098((uint64_t)(v8 + 1), __p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(_QWORD *)buf = &off_10212A508;
        sub_10026A9C8((uint64_t)buf);
      }
      sub_1002EB978((uint64_t **)&v34, (__int128 *)__p);
      if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p[0].__r_.__value_.__l.__data_);
      v8 += 8;
    }
    while (v8 != v7);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
    v9 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
    {
      v10 = SHIBYTE(v40.__r_.__value_.__r.__words[2]);
      v11 = v40.__r_.__value_.__r.__words[0];
      sub_1002563C0(",", (uint64_t *)&v37, (uint64_t)__p);
      v12 = &v40;
      if (v10 < 0)
        v12 = (std::string *)v11;
      if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v13 = __p;
      else
        v13 = (std::string *)__p[0].__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289538;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)v44 = 2082;
      *(_QWORD *)&v44[2] = "";
      *(_WORD *)&v44[10] = 2082;
      *(_QWORD *)&v44[12] = v12;
      v45 = 2082;
      v46 = v13;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"LOIs for LOI Group Id\", \"LOI Group ID\":%{public, location:escape_only}s, \"LOI IDs\":%{public, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p[0].__r_.__value_.__l.__data_);
    }
    sub_10028397C(*(_QWORD *)(a1 + 8), (uint64_t)a2, __p);
    if (v50)
      v14 = *(double *)&__p[0].__r_.__value_.__r.__words[2];
    else
      v14 = -1.79769313e308;
    v34 = 0;
    v35 = 0;
    v36 = 0;
    v15 = v38;
    v16 = v39;
    v42 = &v34;
    if (v38 == v39)
    {
      v17 = 0;
    }
    else
    {
      do
      {
        v41 = *v15;
        sub_1003142D8((uint64_t *)&v42, &v41);
        v15 += 8;
      }
      while (v15 != v16);
      v17 = (double *)v34;
      v18 = (double *)((char *)v34 + 8);
      if (v34 != v35 && v18 != (double *)v35)
      {
        v20 = *(double *)v34;
        v21 = (double *)((char *)v34 + 8);
        do
        {
          v22 = *v21++;
          v23 = v22;
          if (v20 < v22)
          {
            v20 = v23;
            v17 = v18;
          }
          v18 = v21;
        }
        while (v21 != (double *)v35);
      }
    }
    Current = j__CFAbsoluteTimeGetCurrent();
    sub_10027F418(*(_QWORD *)(a1 + 8), 0, *a2, a2[1], buf);
    v28 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
    if (*(_BYTE *)a2)
    {
      v30 = 0;
    }
    else
    {
      v31 = 0;
      do
      {
        v32 = v31;
        if (v31 == 15)
          break;
        ++v31;
      }
      while (!*((_BYTE *)a2 + v32 + 1));
      v30 = v32 > 0xE;
    }
    objc_msgSend(v28, "setObject:forKeyedSubscript:", +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v30, v34), CFSTR("isLoiLegacy"));
    objc_msgSend(v28, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", (((char *)v39 - (char *)v38) >> 6) - 1), CFSTR("deduplicatedLoiCount"));
    if (v17 != (double *)v35)
      objc_msgSend(v28, "setObject:forKeyedSubscript:", +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", Current - *v17), CFSTR("lastSeenAge"));
    objc_msgSend(v28, "setObject:forKeyedSubscript:", +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v50), CFSTR("hasRecordings"));
    if (v50)
      objc_msgSend(v28, "setObject:forKeyedSubscript:", +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", Current - v14), CFSTR("lastRecordingAge"));
    objc_msgSend(v28, "setObject:forKeyedSubscript:", +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v48), CFSTR("isModelExists"));
    if (v48)
      objc_msgSend(v28, "setObject:forKeyedSubscript:", +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v47), CFSTR("isModelStable"));
    sub_1002708A4((uint64_t)buf);
    if (v34)
    {
      v35 = (char *)v34;
      operator delete(v34);
    }
    sub_100312480((uint64_t)__p);
    *(_QWORD *)buf = &v37;
    sub_100259608((void ***)buf);
  }
  *(_QWORD *)buf = &v38;
  sub_10028E258((void ***)buf);
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v40.__r_.__value_.__l.__data_);
  return v28;
}

void sub_10030F778(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,std::bad_cast a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  std::bad_cast a65;

  std::bad_cast::~bad_cast(&a65);
  if (a17 < 0)
    operator delete(__p);
  a29.__vftable = (std::bad_cast_vtbl *)&a18;
  sub_10028E258((void ***)&a29);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

uint64_t sub_10030F86C(uint64_t a1, uint64_t a2, __int128 *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v9;

  if ((__int128 *)a2 != a3)
  {
    sub_10028E6D0((uint64_t)&v9, a3, *(__int128 **)(a1 + 8), a2);
    v6 = v5;
    v7 = *(_QWORD *)(a1 + 8);
    if (v7 != v5)
    {
      do
      {
        if (*(char *)(v7 - 1) < 0)
          operator delete(*(void **)(v7 - 24));
        v7 -= 64;
      }
      while (v7 != v6);
    }
    *(_QWORD *)(a1 + 8) = v6;
  }
  return a2;
}

uint64_t sub_10030F8F0(uint64_t a1)
{
  NSObject *v3;
  const char *v4;
  uint8_t *v5;
  _WORD v6[8];
  uint8_t buf[1640];

  if (sub_1000CC4F4(a1 + 72))
    return sub_10027B380(a1, "MiLoLoiTable");
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
  v3 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#Warning Attempt to get numEntries without a backing database", buf, 2u);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
    v6[0] = 0;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#Warning Attempt to get numEntries without a backing database", v6, 2);
    v5 = (uint8_t *)v4;
    sub_100512490("Generic", 1, 0, 2, "uint32_t CLMicroLocationDatabase::numEntries() [Table = CLMiLoLoiTable]", "%s\n", v4);
    if (v5 != buf)
      free(v5);
  }
  return 0;
}

void sub_10030FAC0(_QWORD *a1, uint64_t a2)
{
  NSObject *v4;
  id v5;
  _QWORD *v6;
  uint64_t v7;
  NSObject *v8;
  const char *v9;
  uint64_t v10;
  NSObject *v11;
  id v12;
  int v13;
  int v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  id v18;
  __int16 v19;
  id v20;
  _BYTE v21[24];
  _BYTE *v22;

  if ((sub_10030B674() & 1) != 0)
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
    v4 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      v13 = 68289026;
      v14 = 0;
      v15 = 2082;
      v16 = "";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"analyzing daily trigger usage\"}", (uint8_t *)&v13, 0x12u);
    }
    sub_100270E34((uint64_t)v21, a2);
    v5 = sub_10030FE68(a1, (uint64_t)v21);
    v6 = v22;
    if (v22 == v21)
    {
      v7 = 4;
      v6 = v21;
    }
    else
    {
      if (!v22)
        goto LABEL_15;
      v7 = 5;
    }
    (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_15:
    if (v5)
    {
      v10 = *(_QWORD *)(a2 + 24);
      if (!v10)
        sub_10025FD1C();
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v10 + 48))(v10))
      {
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
        v8 = qword_1022A00F8;
        if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
        {
          v13 = 68289026;
          v14 = 0;
          v15 = 2082;
          v16 = "";
          v9 = "{\"msg%{public}.0s\":\"Trigger types analytics canceled\"}";
          goto LABEL_26;
        }
      }
      else
      {
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
        v11 = qword_1022A00F8;
        if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
        {
          v12 = objc_msgSend(CFSTR("com.apple.microlocation.triggers.daily"), "UTF8String");
          v13 = 68289539;
          v14 = 0;
          v15 = 2082;
          v16 = "";
          v17 = 2082;
          v18 = v12;
          v19 = 2113;
          v20 = v5;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Sending analytics event\", \"Event name\":%{public, location:escape_only}s, \"event\":%{private, location:escape_only}@}", (uint8_t *)&v13, 0x26u);
        }
        AnalyticsSendEvent(CFSTR("com.apple.microlocation.triggers.daily"), v5);
      }
    }
    else
    {
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
      v8 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        v13 = 68289026;
        v14 = 0;
        v15 = 2082;
        v16 = "";
        v9 = "{\"msg%{public}.0s\":\"daily trigger analytics event was not created.\"}";
        goto LABEL_26;
      }
    }
    return;
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
  v8 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    v13 = 68289026;
    v14 = 0;
    v15 = 2082;
    v16 = "";
    v9 = "{\"msg%{public}.0s\":\"not analyzing trigger types, since sending to core-analytics is disabled\"}";
LABEL_26:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v13, 0x12u);
  }
}

void sub_10030FE28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  char *v17;
  char *v19;
  uint64_t v20;

  v19 = a17;
  if (a17 == v17)
  {
    v20 = 4;
    v19 = &a14;
  }
  else
  {
    if (!a17)
      goto LABEL_6;
    v20 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v19 + 8 * v20))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

id sub_10030FE68(_QWORD *a1, uint64_t a2)
{
  NSDate *v4;
  double v5;
  double v6;
  uint64_t v7;
  NSObject *v8;
  id v9;
  uint64_t v10;
  _DWORD *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  CFStringRef v20;
  unint64_t v21;
  int v22;
  unsigned int v23;
  std::__shared_weak_count *size;
  unint64_t *v25;
  unint64_t v26;
  unint64_t v27;
  NSObject *v28;
  double v29;
  int v30;
  unint64_t v32;
  void *__p;
  unint64_t v34;
  _DWORD *v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  std::string v39;
  __int16 v40;
  unint64_t v41;
  __int16 v42;
  unint64_t v43;
  __int16 v44;
  unint64_t v45;
  std::string buf;
  uint64_t v47;
  unsigned int v48[4];

  v4 = +[NSDate date](NSDate, "date");
  v5 = sub_1003B1DE4((uint64_t)v4, -1);
  v6 = sub_1003B1DE4((uint64_t)v4, 0);
  (*(void (**)(_QWORD))(*(_QWORD *)*a1 + 24))(*a1);
  v7 = *(_QWORD *)(a2 + 24);
  if (!v7)
    sub_10025FD1C();
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v7 + 48))(v7))
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
    v8 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      buf.__r_.__value_.__r.__words[0] = 68289026;
      LOWORD(buf.__r_.__value_.__r.__words[1]) = 2082;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Trigger types analytics canceled\"}", (uint8_t *)&buf, 0x12u);
    }
    return 0;
  }
  else
  {
    v10 = a1[1];
    std::to_string(&buf, v5);
    std::to_string(&v39, v6);
    v11 = operator new(4uLL);
    __p = v11;
    *v11 = 48;
    v34 = (unint64_t)(v11 + 1);
    v35 = v11 + 1;
    sub_100281D9C(v10, (uint64_t)&buf, (uint64_t)&v39, (uint64_t)&__p, &v36);
    if (__p)
    {
      v34 = (unint64_t)__p;
      operator delete(__p);
    }
    if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v39.__r_.__value_.__l.__data_);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
      operator delete(buf.__r_.__value_.__l.__data_);
    __p = 0;
    v34 = 0;
    v35 = 0;
    v13 = v36;
    v12 = v37;
    if (v36 != v37)
    {
      v14 = 0;
      do
      {
        if (*(_DWORD *)(v13 + 24) == 48 && (*(_BYTE *)(v13 + 327) & 8) != 0)
        {
          v15 = *(_QWORD *)(v13 + 256);
          if (!v15)
            v15 = *(_QWORD *)(qword_1023103F8 + 224);
          if (v14 >= (unint64_t)v35)
          {
            v14 = sub_100314914((uint64_t *)&__p, v15);
          }
          else
          {
            sub_1002E0C70(v14, v15);
            v14 += 88;
          }
          v34 = v14;
          v12 = v37;
        }
        v13 += 336;
      }
      while (v13 != v12);
    }
    sub_1003B0A70(&buf, &__p);
    v16 = sub_1003B0DAC((uint64_t)&buf);
    v32 = sub_1003B10FC((uint64_t)&buf);
    v17 = sub_1003B1028((uint64_t)&buf);
    v18 = sub_1003B12A8((uint64_t)&buf, 1u, 1);
    v19 = sub_1003B12A8((uint64_t)&buf, 0, 1);
    v9 = objc_alloc_init((Class)NSMutableDictionary);
    objc_msgSend(v9, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_1003B0AD0((uint64_t)&buf)), CFSTR("TotalRecordings"));
    objc_msgSend(v9, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_1003B0CD8((uint64_t)&buf)), CFSTR("TotalLocalizations"));
    objc_msgSend(v9, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v16), CFSTR("TotalLegacyLocalizations"));
    objc_msgSend(v9, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_1003B0E80((uint64_t)&buf)), CFSTR("TotalCachedLegacyLocalizations"));
    objc_msgSend(v9, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_1003B0F54((uint64_t)&buf)), CFSTR("TotalNonCachedLegacyLocalizations"));
    objc_msgSend(v9, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v32), CFSTR("TotalMotionLocalizations"));
    objc_msgSend(v9, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v19), CFSTR("TotalMotionLocalizationsWhileDisplayOn"));
    objc_msgSend(v9, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v18), CFSTR("TotalMotionLocalizationsWhenDisplayTurnedOn"));
    objc_msgSend(v9, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_1003B12A8((uint64_t)&buf, 2u, 1)), CFSTR("TotalMotionLocalizationsWhenRescheduled"));
    objc_msgSend(v9, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v17), CFSTR("TotalNewLocalizations"));
    objc_msgSend(v9, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_1003B11D0((uint64_t)&buf, 1u)), CFSTR("TotalLocalizationsWhenDisplayTurnedOn"));
    objc_msgSend(v9, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", sub_1003B11D0((uint64_t)&buf, 2u)), CFSTR("TotalLocalizationsWhenRescheduled"));
    sub_100311378((uint64_t)a1, v9, v5, v6);
    sub_100311754((uint64_t)a1, v9, v5, v6);
    sub_1001E4804(&v39);
    v38 = 0;
    v20 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsAnalyticsTriggerCountThreshold", 0x8000100u, kCFAllocatorNull);
    v21 = v19;
    v22 = sub_1000B1180((uint64_t)v39.__r_.__value_.__l.__data_, (uint64_t)v20, &v38);
    CFRelease(v20);
    v23 = v38;
    size = (std::__shared_weak_count *)v39.__r_.__value_.__l.__size_;
    if (v39.__r_.__value_.__l.__size_)
    {
      v25 = (unint64_t *)(v39.__r_.__value_.__l.__size_ + 8);
      do
        v26 = __ldaxr(v25);
      while (__stlxr(v26 - 1, v25));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
        std::__shared_weak_count::__release_weak(size);
      }
    }
    if (v22)
      v27 = v23;
    else
      v27 = 5;
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
    v28 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
    {
      v39.__r_.__value_.__r.__words[0] = 68290050;
      LOWORD(v39.__r_.__value_.__r.__words[1]) = 2082;
      *(std::string::size_type *)((char *)&v39.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
      WORD1(v39.__r_.__value_.__r.__words[2]) = 1026;
      HIDWORD(v39.__r_.__value_.__r.__words[2]) = v27;
      v40 = 2050;
      v41 = v16;
      v42 = 2050;
      v43 = v32;
      v44 = 2050;
      v45 = v17;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Adding ratios to trigger analytics if appropriate\", \"TriggerThreshold\":%{public}d, \"TotalLegacyLocalizations\":%{public}lu, \"TotalMotionLocalizations\":%{public}lu, \"TotalNewLocalizations\":%{public}lu}", (uint8_t *)&v39, 0x36u);
    }
    if (v16)
    {
      if (v32 >= v27 && v16 >= v27)
      {
        *(float *)&v29 = (float)v32 / (float)v16;
        objc_msgSend(v9, "setObject:forKeyedSubscript:", +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v29), CFSTR("MotionLocalizationAndLegacyLocalizationsRatio"));
      }
      if (v17 >= v27 && v16 >= v27)
      {
        *(float *)&v29 = (float)v17 / (float)v16;
        objc_msgSend(v9, "setObject:forKeyedSubscript:", +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v29), CFSTR("NewLocalizationAndLegacyLocalizationsRatio"));
      }
    }
    if (v18 && v21 >= v27 && v18 >= v27)
    {
      *(float *)&v29 = (float)v21 / (float)v18;
      objc_msgSend(v9, "setObject:forKeyedSubscript:", +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v29), CFSTR("MotionWhileDisplayOnAndWhenDisplayTurnedOnRatio"));
    }
    *(double *)&v39.__r_.__value_.__l.__data_ = v6;
    v30 = sub_100310E84((uint64_t)a1, (double *)&v39);
    if (v30 != 255)
      objc_msgSend(v9, "setObject:forKeyedSubscript:", +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v30 == 1), CFSTR("isLowObservationLegacyClient"));
    sub_1000B0D18(v48);
    v39.__r_.__value_.__r.__words[0] = (std::string::size_type)&v47;
    sub_100314888((void ***)&v39);
    if (buf.__r_.__value_.__r.__words[0])
    {
      buf.__r_.__value_.__l.__size_ = buf.__r_.__value_.__r.__words[0];
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p;
    sub_100314888((void ***)&buf);
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v36;
    sub_10029A77C((void ***)&buf);
  }
  return v9;
}

void sub_1003105E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char *p_p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  sub_100311A3C((uint64_t)&p_p);
  p_p = (char *)&__p;
  sub_100314888((void ***)&p_p);
  p_p = &a13;
  sub_10029A77C((void ***)&p_p);
  _Unwind_Resume(a1);
}

uint64_t sub_1003106B0(uint64_t a1, double *a2, double *a3, uint64_t a4, uint64_t a5)
{
  NSObject *v5;
  uint64_t v6;
  uint64_t v12;
  int v13;
  char v14;
  double v15;
  uint64_t v16;
  uint64_t v17;
  double v18;
  uint64_t v19;
  double v20;
  double v21;
  const char *v23;
  uint8_t *v24;
  _QWORD v25[3];
  std::string v26;
  std::string v27;
  void **v28;
  uint8_t buf[32];
  uint64_t v30;
  char v31;

  if (*a3 >= *a2)
  {
    std::to_string(&v27, *a2);
    std::to_string(&v26, *a3);
    sub_1002820EC(*(_QWORD *)(a1 + 8), (uint64_t)&v27, a4, buf);
    if (v31)
    {
      v12 = *(_QWORD *)(a5 + 24);
      if (!v12)
        sub_10025FD1C();
      v13 = (*(uint64_t (**)(uint64_t, uint8_t *))(*(_QWORD *)v12 + 48))(v12, buf);
      v14 = v13;
      if (v13)
        v15 = *a2;
      else
        v15 = 0.0;
    }
    else
    {
      v14 = 0;
      v15 = 0.0;
    }
    sub_100281D9C(*(_QWORD *)(a1 + 8), (uint64_t)&v27, (uint64_t)&v26, a4, v25);
    v16 = v25[0];
    v17 = v25[1];
    v18 = 0.0;
    while (v16 != v17)
    {
      v19 = *(_QWORD *)(a5 + 24);
      if (!v19)
        sub_10025FD1C();
      if ((*(unsigned int (**)(uint64_t, uint64_t))(*(_QWORD *)v19 + 48))(v19, v16))
      {
        if (!v14)
        {
          v15 = *(double *)(v16 + 16);
          v14 = 1;
        }
      }
      else if (v14)
      {
        v14 = 0;
        v18 = v18 + *(double *)(v16 + 16) - v15;
      }
      else
      {
        v14 = 0;
      }
      v16 += 336;
    }
    if (v14)
      v20 = *a3 - v15;
    else
      v20 = -0.0;
    v28 = (void **)v25;
    sub_10029A77C(&v28);
    if (v31)
      sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)&v30);
    v21 = v18 + v20;
    if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v26.__r_.__value_.__l.__data_);
    v6 = (uint64_t)v21;
    if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v27.__r_.__value_.__l.__data_);
  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
    v5 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "got start time bigger than end time while calculating milo spectating duration", buf, 2u);
    }
    if (sub_1001BFF7C(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
      LOWORD(v27.__r_.__value_.__l.__data_) = 0;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 16, "got start time bigger than end time while calculating milo spectating duration", &v27, 2);
      v24 = (uint8_t *)v23;
      sub_100512490("Generic", 1, 0, 0, "cl::chrono::seconds CLMicroLocationAnalytics::getMiLoSpectatingDuration(const cl::chrono::time_point<cl::chrono::CFAbsoluteTimeClock> &, const cl::chrono::time_point<cl::chrono::CFAbsoluteTimeClock> &, const std::vector<CLMicroLocationProto::EventType> &, const std::function<BOOL (const CLMicroLocationLoggedEventsTable::Entry &)> &) const", "%s\n", v23);
      if (v24 != buf)
        free(v24);
    }
    return 0;
  }
  return v6;
}

void sub_1003109D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  char a69;

  if (a69)
    sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)&a31);
  if (a19 < 0)
    operator delete(__p);
  if (a25 < 0)
    operator delete(a20);
  _Unwind_Resume(a1);
}

void sub_100310A50(uint64_t a1, void *a2, void *a3, uint64_t a4, double *a5)
{
  id v9;
  id v10;
  uint64_t v11;
  void *v12;
  void *v13;
  id v14;
  double v15;
  double v16;
  id v17;
  double v18;
  NSObject *v19;
  id v20;
  id v21;
  uint64_t v22;
  id v23;
  id v24;
  const char *v25;
  uint8_t *v26;
  id v27;
  NSObject *v28;
  const char *v29;
  uint8_t *v30;
  const char *v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  int v36;
  id v37;
  __int16 v38;
  id v39;
  uint8_t buf[4];
  id v41;
  __int16 v42;
  id v43;
  _BYTE v44[128];

  if (*a5 <= 0.0)
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
    v28 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Tried to add count per hour fields with duration equals 0.", buf, 2u);
    }
    if (sub_1001BFF7C(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
      LOWORD(v36) = 0;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 16, "Tried to add count per hour fields with duration equals 0.", &v36, 2);
      v30 = (uint8_t *)v29;
      sub_100512490("Generic", 1, 0, 0, "void CLMicroLocationAnalytics::addPerHoursFields(NSMutableDictionary *, NSArray<NSString *> *, NSString *, const cl::chrono::hoursf &) const", "%s\n", v29);
      if (v30 != buf)
        free(v30);
    }
  }
  else
  {
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    v9 = objc_msgSend(a3, "countByEnumeratingWithState:objects:count:", &v32, v44, 16);
    if (v9)
    {
      v10 = v9;
      v11 = *(_QWORD *)v33;
      do
      {
        v12 = 0;
        do
        {
          if (*(_QWORD *)v33 != v11)
            objc_enumerationMutation(a3);
          v13 = *(void **)(*((_QWORD *)&v32 + 1) + 8 * (_QWORD)v12);
          v14 = objc_msgSend(a2, "objectForKey:", v13);
          if (v14)
          {
            objc_msgSend(v14, "doubleValue");
            v16 = v15 / *a5;
            v17 = objc_msgSend(v13, "stringByAppendingString:", a4);
            *(float *)&v18 = v16;
            objc_msgSend(a2, "setObject:forKeyedSubscript:", +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v18), v17);
          }
          else
          {
            if (qword_1022A00F0 != -1)
              dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
            v19 = qword_1022A00F8;
            if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
            {
              v20 = objc_msgSend(v13, "UTF8String");
              v21 = objc_msgSend(CFSTR("com.apple.microlocation.triggers.daily"), "UTF8String");
              *(_DWORD *)buf = 136315394;
              v41 = v20;
              v42 = 2080;
              v43 = v21;
              _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "no value found for key %s in %s CA event. Skipping it.", buf, 0x16u);
            }
            if (sub_1001BFF7C(115, 0))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1022A00F0 != -1)
                dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
              v22 = qword_1022A00F8;
              v23 = objc_msgSend(v13, "UTF8String");
              v24 = objc_msgSend(CFSTR("com.apple.microlocation.triggers.daily"), "UTF8String");
              v36 = 136315394;
              v37 = v23;
              v38 = 2080;
              v39 = v24;
              LODWORD(v31) = 22;
              _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, v22, 16, "no value found for key %s in %s CA event. Skipping it.", (const char *)&v36, v31);
              v26 = (uint8_t *)v25;
              sub_100512490("Generic", 1, 0, 0, "void CLMicroLocationAnalytics::addPerHoursFields(NSMutableDictionary *, NSArray<NSString *> *, NSString *, const cl::chrono::hoursf &) const", "%s\n", v25);
              if (v26 != buf)
                free(v26);
            }
          }
          v12 = (char *)v12 + 1;
        }
        while (v10 != v12);
        v27 = objc_msgSend(a3, "countByEnumeratingWithState:objects:count:", &v32, v44, 16);
        v10 = v27;
      }
      while (v27);
    }
  }
}

uint64_t sub_100310E84(uint64_t a1, double *a2)
{
  double v2;
  uint64_t v3;
  _DWORD *v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  const char *v12;
  std::string *v13;
  const char *v14;
  std::string *v15;
  void *__p;
  void *v17;
  _DWORD *v18;
  uint64_t v19;
  uint64_t v20;
  std::string v21;
  std::string v22;

  v2 = *a2;
  v3 = *(_QWORD *)(a1 + 8);
  std::to_string(&v21, *a2 + -172800.0);
  std::to_string(&v22, v2);
  v4 = operator new(4uLL);
  __p = v4;
  *v4 = 49;
  v17 = v4 + 1;
  v18 = v4 + 1;
  sub_100281D9C(v3, (uint64_t)&v21, (uint64_t)&v22, (uint64_t)&__p, &v19);
  if (__p)
  {
    v17 = __p;
    operator delete(__p);
  }
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v22.__r_.__value_.__l.__data_);
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v21.__r_.__value_.__l.__data_);
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
  v5 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(v21.__r_.__value_.__l.__data_) = 134217984;
    *(std::string::size_type *)((char *)v21.__r_.__value_.__r.__words + 4) = 0xCF3CF3CF3CF3CF3DLL * ((v20 - v19) >> 4);
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Selected %lu Legacy status updates", (uint8_t *)&v21, 0xCu);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(&v21, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
    LODWORD(v22.__r_.__value_.__l.__data_) = 134217984;
    *(std::string::size_type *)((char *)v22.__r_.__value_.__r.__words + 4) = 0xCF3CF3CF3CF3CF3DLL * ((v20 - v19) >> 4);
    _os_log_send_and_compose_impl(2, 0, &v21, 1628, &_mh_execute_header, qword_1022A00F8, 2, "Selected %lu Legacy status updates", &v22);
    v13 = (std::string *)v12;
    sub_100512490("Generic", 1, 0, 2, "CLMicroLocationProto::NumberOfObservationsStates CLMicroLocationAnalytics::getLegacyClientNumberOfObservationsState(const cl::chrono::time_point<cl::chrono::CFAbsoluteTimeClock> &) const", "%s\n", v12);
    if (v13 != &v21)
      free(v13);
  }
  v6 = v20;
  while (v6 != v19)
  {
    v7 = *(_QWORD *)(v6 - 72);
    if (!v7)
      v7 = *(_QWORD *)(qword_1023103F8 + 232);
    v8 = *(unsigned int *)(v7 + 12);
    v6 -= 336;
    if ((_DWORD)v8 != 255)
    {
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
      v9 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        v21.__r_.__value_.__r.__words[0] = 68289282;
        LOWORD(v21.__r_.__value_.__r.__words[1]) = 2082;
        *(std::string::size_type *)((char *)&v21.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
        WORD1(v21.__r_.__value_.__r.__words[2]) = 1026;
        HIDWORD(v21.__r_.__value_.__r.__words[2]) = v8 != 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"legacy client low number of observation status found\", \"number of observation status\":%{public}hhd}", (uint8_t *)&v21, 0x18u);
      }
      goto LABEL_27;
    }
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
  v10 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v21.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Could not determine legacy client low number of observation status.", (uint8_t *)&v21, 2u);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(&v21, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
    LOWORD(v22.__r_.__value_.__l.__data_) = 0;
    _os_log_send_and_compose_impl(2, 0, &v21, 1628, &_mh_execute_header, qword_1022A00F8, 0, "Could not determine legacy client low number of observation status.", &v22, 2);
    v15 = (std::string *)v14;
    sub_100512490("Generic", 1, 0, 2, "CLMicroLocationProto::NumberOfObservationsStates CLMicroLocationAnalytics::getLegacyClientNumberOfObservationsState(const cl::chrono::time_point<cl::chrono::CFAbsoluteTimeClock> &) const", "%s\n", v14);
    if (v15 != &v21)
      free(v15);
  }
  v8 = 255;
LABEL_27:
  v21.__r_.__value_.__r.__words[0] = (std::string::size_type)&v19;
  sub_10029A77C((void ***)&v21);
  return v8;
}

void sub_100311304(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, char *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  a17 = &a14;
  sub_10029A77C((void ***)&a17);
  _Unwind_Resume(a1);
}

_QWORD *sub_100311378(uint64_t a1, void *a2, double a3, double a4)
{
  _DWORD *v8;
  uint64_t v9;
  CFStringRef v10;
  int v11;
  double v12;
  unsigned int data;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  double v17;
  id v18;
  NSObject *v19;
  double v20;
  int v21;
  std::string::size_type v22;
  std::string *v23;
  std::string *v24;
  float v25;
  uint64_t v26;
  _QWORD *result;
  uint64_t v28;
  std::string v29;
  std::string v30;
  void *__p;
  _BYTE v32[20];
  __int16 v33;
  std::string *v34;
  __int16 v35;
  double v36;
  _QWORD v37[3];
  _QWORD *v38;

  v37[0] = off_10212EB80;
  v38 = v37;
  *(double *)&v30.__r_.__value_.__l.__data_ = a3;
  *(double *)&v29.__r_.__value_.__l.__data_ = a4;
  v8 = operator new(0xCuLL);
  *(_QWORD *)v32 = v8 + 3;
  *(_QWORD *)&v32[8] = v8 + 3;
  *(_QWORD *)v8 = 0x220000002CLL;
  v8[2] = 35;
  __p = v8;
  v9 = sub_1003106B0(a1, (double *)&v30, (double *)&v29, (uint64_t)&__p, (uint64_t)v37);
  if (__p)
  {
    *(_QWORD *)v32 = __p;
    operator delete(__p);
  }
  sub_1001E4804(&__p);
  LODWORD(v30.__r_.__value_.__l.__data_) = 0;
  v10 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsAnalyticsTriggerMinimumSpectatingDuration", 0x8000100u, kCFAllocatorNull);
  v11 = sub_1000B1180((uint64_t)__p, (uint64_t)v10, &v30);
  CFRelease(v10);
  v12 = (double)v9 / 3600.0;
  data = v30.__r_.__value_.__l.__data_;
  v14 = *(std::__shared_weak_count **)v32;
  if (*(_QWORD *)v32)
  {
    v15 = (unint64_t *)(*(_QWORD *)v32 + 8);
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  v17 = (double)data;
  if (!v11)
    v17 = 1.0;
  if (v12 >= v17)
  {
    v18 = objc_msgSend(a2, "allKeys");
    __p = *(void **)&v12;
    sub_100310A50((uint64_t)v18, a2, v18, (uint64_t)CFSTR("PerHour"), (double *)&__p);
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
  v19 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
  {
    std::to_string(&v30, a3);
    v21 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
    v22 = v30.__r_.__value_.__r.__words[0];
    std::to_string(&v29, a4);
    v23 = &v30;
    if (v21 < 0)
      v23 = (std::string *)v22;
    if ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v24 = &v29;
    else
      v24 = (std::string *)v29.__r_.__value_.__r.__words[0];
    v25 = v12;
    __p = (void *)68289795;
    *(_WORD *)v32 = 2082;
    *(_QWORD *)&v32[2] = "";
    *(_WORD *)&v32[10] = 2082;
    *(_QWORD *)&v32[12] = v23;
    v33 = 2082;
    v34 = v24;
    v35 = 2049;
    v36 = v25;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Calculated microLocation spectating duration\", \"startTime\":%{public, location:escape_only}s, \"stopTime\":%{public, location:escape_only}s, \"duration (hours)\":\"%{private}5f\"}", (uint8_t *)&__p, 0x30u);
    if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v29.__r_.__value_.__l.__data_);
    if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v30.__r_.__value_.__l.__data_);
  }
  else
  {
    v25 = v12;
  }
  *(float *)&v20 = v25;
  objc_msgSend(a2, "setObject:forKeyedSubscript:", +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v20, v29.__r_.__value_.__r.__words[0]), CFSTR("Duration"));
  LODWORD(v26) = vcvtmd_s64_f64(v12);
  objc_msgSend(a2, "setObject:forKeyedSubscript:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v26), CFSTR("DurationBounded"));
  result = v38;
  if (v38 == v37)
  {
    v28 = 4;
    result = v37;
  }
  else
  {
    if (!v38)
      return result;
    v28 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v28))();
}

void sub_1003116C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,char *a28)
{
  char *v29;
  uint64_t v30;

  if (a17 < 0)
    operator delete(__p);
  v29 = a28;
  if (a28 == &a25)
  {
    v30 = 4;
    v29 = &a25;
  }
  else
  {
    if (!a28)
      goto LABEL_8;
    v30 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v29 + 8 * v30))();
LABEL_8:
  _Unwind_Resume(exception_object);
}

_QWORD *sub_100311754(uint64_t a1, void *a2, double a3, double a4)
{
  _QWORD *v8;
  uint64_t v9;
  double v10;
  NSObject *v11;
  double v12;
  double v13;
  int v14;
  std::string::size_type v15;
  std::string *v16;
  std::string *v17;
  float v18;
  uint64_t v19;
  _QWORD *result;
  uint64_t v21;
  std::string v22;
  std::string v23;
  void *__p;
  _BYTE v25[20];
  __int16 v26;
  std::string *v27;
  __int16 v28;
  double v29;
  _QWORD v30[3];
  _QWORD *v31;

  v30[0] = off_10212EC10;
  v31 = v30;
  *(double *)&v23.__r_.__value_.__l.__data_ = a3;
  *(double *)&v22.__r_.__value_.__l.__data_ = a4;
  v8 = operator new(8uLL);
  __p = v8;
  *v8 = 0x320000002CLL;
  *(_QWORD *)v25 = v8 + 1;
  *(_QWORD *)&v25[8] = v8 + 1;
  v9 = sub_1003106B0(a1, (double *)&v23, (double *)&v22, (uint64_t)&__p, (uint64_t)v30);
  if (__p)
  {
    *(_QWORD *)v25 = __p;
    operator delete(__p);
  }
  v10 = (double)v9;
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
  v11 = qword_1022A00F8;
  v12 = v10 / 3600.0;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
  {
    std::to_string(&v23, a3);
    v14 = SHIBYTE(v23.__r_.__value_.__r.__words[2]);
    v15 = v23.__r_.__value_.__r.__words[0];
    std::to_string(&v22, a4);
    v16 = &v23;
    if (v14 < 0)
      v16 = (std::string *)v15;
    if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v17 = &v22;
    else
      v17 = (std::string *)v22.__r_.__value_.__r.__words[0];
    v18 = v12;
    __p = (void *)68289795;
    *(_WORD *)v25 = 2082;
    *(_QWORD *)&v25[2] = "";
    *(_WORD *)&v25[10] = 2082;
    *(_QWORD *)&v25[12] = v16;
    v26 = 2082;
    v27 = v17;
    v28 = 2049;
    v29 = v18;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Calculated microLocation motion spectating duration\", \"startTime\":%{public, location:escape_only}s, \"stopTime\":%{public, location:escape_only}s, \"duration (hours)\":\"%{private}5f\"}", (uint8_t *)&__p, 0x30u);
    if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v22.__r_.__value_.__l.__data_);
    if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v23.__r_.__value_.__l.__data_);
  }
  else
  {
    v18 = v12;
  }
  *(float *)&v13 = v18;
  objc_msgSend(a2, "setObject:forKeyedSubscript:", +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v13, v22.__r_.__value_.__r.__words[0]), CFSTR("MotionDuration"));
  LODWORD(v19) = vcvtmd_s64_f64(v12);
  objc_msgSend(a2, "setObject:forKeyedSubscript:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v19), CFSTR("MotionDurationBounded"));
  result = v31;
  if (v31 == v30)
  {
    v21 = 4;
    result = v30;
  }
  else
  {
    if (!v31)
      return result;
    v21 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v21))();
}

void sub_1003119CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,char *a28)
{
  char *v29;
  uint64_t v30;

  if (a17 < 0)
    operator delete(__p);
  v29 = a28;
  if (a28 == &a25)
  {
    v30 = 4;
    v29 = &a25;
  }
  else
  {
    if (!a28)
      goto LABEL_8;
    v30 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v29 + 8 * v30))();
LABEL_8:
  _Unwind_Resume(exception_object);
}

uint64_t sub_100311A3C(uint64_t a1)
{
  void *v2;
  void **v4;

  sub_1000B0D18((unsigned int *)(a1 + 48));
  v4 = (void **)(a1 + 24);
  sub_100314888(&v4);
  v2 = *(void **)a1;
  if (*(_QWORD *)a1)
  {
    *(_QWORD *)(a1 + 8) = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_100311A8C(id a1)
{
  qword_1022A00F8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_100311AB8()
{
  operator new();
}

void sub_100311AF4()
{
  operator delete();
}

uint64_t sub_100311B18@<X0>(uint64_t result@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t **v3;
  int v6;
  char *v7;
  std::string::size_type v8;
  uint64_t *i;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  std::string::size_type v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  char *v17;
  std::string::size_type v18;

  v3 = *(uint64_t ***)(result + 16);
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)a3 = 0;
  if (v3)
  {
    v6 = *((char *)v3 + 39);
    v7 = v6 >= 0 ? (char *)(v3 + 2) : (char *)v3[2];
    v8 = v6 >= 0 ? *((unsigned __int8 *)v3 + 39) : (std::string::size_type)v3[3];
    result = sub_100259854((std::string *)a3, a3, v7, &v7[v8], v8);
    for (i = *v3; i; i = (uint64_t *)*i)
    {
      v10 = *(unsigned __int8 *)(a3 + 23);
      if ((v10 & 0x80u) == 0)
        v11 = a3;
      else
        v11 = *(_QWORD *)a3;
      if ((v10 & 0x80u) != 0)
        v10 = *(_QWORD *)(a3 + 8);
      v12 = v11 + v10;
      v13 = strlen(a2);
      sub_100259854((std::string *)a3, v12, a2, &a2[v13], v13);
      v14 = *(unsigned __int8 *)(a3 + 23);
      if ((v14 & 0x80u) == 0)
        v15 = a3;
      else
        v15 = *(_QWORD *)a3;
      if ((v14 & 0x80u) != 0)
        v14 = *(_QWORD *)(a3 + 8);
      v16 = *((char *)i + 39);
      if (v16 >= 0)
        v17 = (char *)(i + 2);
      else
        v17 = (char *)i[2];
      if (v16 >= 0)
        v18 = *((unsigned __int8 *)i + 39);
      else
        v18 = i[3];
      result = sub_100259854((std::string *)a3, v15 + v14, v17, &v17[v18], v18);
    }
  }
  return result;
}

void sub_100311C14(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

unsigned __int8 *sub_100311C38(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v3;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  unsigned __int8 **v13;
  unsigned __int8 *i;
  unint64_t v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD v25[3];

  v7 = (_QWORD *)(a1 + 24);
  v8 = sub_10025A024(a1 + 24, (uint64_t)a2);
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v3 = v8;
      if (v8 >= v10)
        v3 = v8 % v10;
    }
    else
    {
      v3 = (v10 - 1) & v8;
    }
    v13 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v3);
    if (v13)
    {
      for (i = *v13; i; i = *(unsigned __int8 **)i)
      {
        v15 = *((_QWORD *)i + 1);
        if (v15 == v9)
        {
          if ((sub_10025A4CC(a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10)
              v15 %= v10;
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v3)
            break;
        }
      }
    }
  }
  sub_100311EB4(a1, v9, a3, (uint64_t)v25);
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    v18 = 1;
    if (v10 >= 3)
      v18 = (v10 & (v10 - 1)) != 0;
    v19 = v18 | (2 * v10);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    sub_10012E444(a1, v21);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v3 = v9 % v10;
      else
        v3 = v9;
    }
    else
    {
      v3 = (v10 - 1) & v9;
    }
  }
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v22)
  {
    *(_QWORD *)v25[0] = *v22;
    *v22 = v25[0];
  }
  else
  {
    *(_QWORD *)v25[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v25[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = a1 + 16;
    if (*(_QWORD *)v25[0])
    {
      v23 = *(_QWORD *)(*(_QWORD *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10)
          v23 %= v10;
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = v25[0];
    }
  }
  i = (unsigned __int8 *)v25[0];
  ++*v7;
  return i;
}

void sub_100311E90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **__p, uint64_t a11)
{
  if (__p)
    sub_1002A20A8((uint64_t)&a11, __p);
  _Unwind_Resume(exception_object);
}

_QWORD *sub_100311EB4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  _QWORD *v8;
  _QWORD *result;

  v7 = a1 + 16;
  v8 = operator new(0x28uLL);
  *(_QWORD *)(a4 + 8) = v7;
  *(_QWORD *)a4 = v8;
  *(_BYTE *)(a4 + 16) = 0;
  *v8 = 0;
  v8[1] = a2;
  result = v8 + 2;
  if (*(char *)(a3 + 23) < 0)
  {
    result = sub_100115CE4(result, *(void **)a3, *(_QWORD *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)result = *(_OWORD *)a3;
    result[2] = *(_QWORD *)(a3 + 16);
  }
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_100311F38(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;

  *v1 = 0;
  sub_1002A20A8(v3, v2);
  _Unwind_Resume(a1);
}

_QWORD *sub_100311F54(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  unint64_t v4;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  _QWORD **v10;
  _QWORD *i;
  unint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  float v15;
  float v16;
  _BOOL8 v17;
  unint64_t v18;
  unint64_t v19;
  size_t v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;

  v7 = *a2;
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v4 = *a2;
      if (v7 >= v8)
        v4 = v7 % v8;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
    v10 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v4);
    if (v10)
    {
      for (i = *v10; i; i = (_QWORD *)*i)
      {
        v12 = i[1];
        if (v12 == v7)
        {
          if (i[2] == v7)
            return i;
        }
        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= v8)
              v12 %= v8;
          }
          else
          {
            v12 &= v8 - 1;
          }
          if (v12 != v4)
            break;
        }
      }
    }
  }
  v13 = (_QWORD *)(a1 + 16);
  i = operator new(0x30uLL);
  *i = 0;
  i[1] = v7;
  v14 = **a4;
  i[5] = 0;
  i[4] = 0;
  i[2] = v14;
  i[3] = i + 4;
  v15 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v16 = *(float *)(a1 + 32);
  if (!v8 || (float)(v16 * (float)v8) < v15)
  {
    v17 = 1;
    if (v8 >= 3)
      v17 = (v8 & (v8 - 1)) != 0;
    v18 = v17 | (2 * v8);
    v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19)
      v20 = v19;
    else
      v20 = v18;
    sub_10012E444(a1, v20);
    v8 = *(_QWORD *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v4 = v7 % v8;
      else
        v4 = v7;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
  }
  v21 = *(_QWORD *)a1;
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v22)
  {
    *i = *v22;
LABEL_38:
    *v22 = i;
    goto LABEL_39;
  }
  *i = *v13;
  *v13 = i;
  *(_QWORD *)(v21 + 8 * v4) = v13;
  if (*i)
  {
    v23 = *(_QWORD *)(*i + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v23 >= v8)
        v23 %= v8;
    }
    else
    {
      v23 &= v8 - 1;
    }
    v22 = (_QWORD *)(*(_QWORD *)a1 + 8 * v23);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_10031218C(_Unwind_Exception *a1)
{
  _QWORD **v1;
  uint64_t v2;

  sub_1003121A8(v2, v1);
  _Unwind_Resume(a1);
}

void sub_1003121A8(uint64_t a1, _QWORD **a2)
{
  if (*(_BYTE *)(a1 + 8))
  {
    sub_100008848((uint64_t)(a2 + 3), a2[4]);
  }
  else if (!a2)
  {
    return;
  }
  operator delete(a2);
}

_QWORD *sub_1003121F0(uint64_t a1, int *a2, _DWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  void **v9;
  _QWORD *v10;
  unint64_t v11;
  float v12;
  float v13;
  _BOOL8 v14;
  unint64_t v15;
  unint64_t v16;
  size_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;

  v6 = *a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = *a2;
      if (v7 <= v6)
        v3 = v6 % v7;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
    v9 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == (_DWORD)v6)
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  v10 = operator new(0x18uLL);
  *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v12 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    v14 = 1;
    if (v7 >= 3)
      v14 = (v7 & (v7 - 1)) != 0;
    v15 = v14 | (2 * v7);
    v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16)
      v17 = v16;
    else
      v17 = v15;
    sub_10012E444(a1, v17);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
  }
  v18 = *(_QWORD *)a1;
  v19 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v19)
  {
    *v10 = *v19;
LABEL_38:
    *v19 = v10;
    goto LABEL_39;
  }
  *v10 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v10;
  *(_QWORD *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    v20 = *(_QWORD *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7)
        v20 %= v7;
    }
    else
    {
      v20 &= v7 - 1;
    }
    v19 = (_QWORD *)(*(_QWORD *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v10;
}

void sub_1003123F4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100312408(uint64_t a1)
{
  void *v2;

  sub_100312440(a1, *(_QWORD ***)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void sub_100312440(uint64_t a1, _QWORD **a2)
{
  _QWORD **v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = *v2;
      sub_100008848((uint64_t)(v2 + 3), v2[4]);
      operator delete(v2);
      v2 = (_QWORD **)v3;
    }
    while (v3);
  }
}

uint64_t sub_100312480(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 240))
  {
    sub_1002DF2E0(a1 + 80);
    if (*(char *)(a1 + 47) < 0)
      operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

void sub_1003124C4()
{
  operator delete();
}

_QWORD *sub_1003124D8(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_10212E900;
  result[1] = v3;
  return result;
}

uint64_t sub_10031250C(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_10212E900;
  a2[1] = v2;
  return result;
}

_QWORD *sub_100312528(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *result;
  uint64_t v8;
  _QWORD v9[3];
  _QWORD *v10;
  _BYTE v11[24];
  _BYTE *v12;

  sub_1002AE164((uint64_t)v9, a2);
  v3 = *(uint64_t **)(a1 + 8);
  v4 = (uint64_t)v10;
  if (!v10)
    goto LABEL_4;
  if (v10 != v9)
  {
    v4 = (*(uint64_t (**)(void))(*v10 + 16))();
LABEL_4:
    v12 = (_BYTE *)v4;
    goto LABEL_6;
  }
  v12 = v11;
  (*(void (**)(_QWORD *, _BYTE *))(v9[0] + 24))(v9, v11);
LABEL_6:
  sub_10030C624(v3, (uint64_t)v11);
  v5 = v12;
  if (v12 == v11)
  {
    v6 = 4;
    v5 = v11;
  }
  else
  {
    if (!v12)
      goto LABEL_11;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_11:
  result = v10;
  if (v10 == v9)
  {
    v8 = 4;
    result = v9;
  }
  else
  {
    if (!v10)
      return result;
    v8 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v8))();
}

void sub_100312634(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  char *v18;
  uint64_t v19;

  v18 = a13;
  if (a13 == &a10)
  {
    v19 = 4;
    v18 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v19 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v18 + 8 * v19))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003126A4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1003126E0()
{
}

void sub_1003126F0()
{
  operator delete();
}

_QWORD *sub_100312704(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_10212E980;
  result[1] = v3;
  return result;
}

uint64_t sub_100312738(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_10212E980;
  a2[1] = v2;
  return result;
}

_QWORD *sub_100312754(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *result;
  uint64_t v8;
  _QWORD v9[3];
  _QWORD *v10;
  _BYTE v11[24];
  _BYTE *v12;

  sub_1002AE164((uint64_t)v9, a2);
  v3 = *(_QWORD *)(a1 + 8);
  v4 = (uint64_t)v10;
  if (!v10)
    goto LABEL_4;
  if (v10 != v9)
  {
    v4 = (*(uint64_t (**)(void))(*v10 + 16))();
LABEL_4:
    v12 = (_BYTE *)v4;
    goto LABEL_6;
  }
  v12 = v11;
  (*(void (**)(_QWORD *, _BYTE *))(v9[0] + 24))(v9, v11);
LABEL_6:
  sub_10030D1B0(v3, (uint64_t)v11);
  v5 = v12;
  if (v12 == v11)
  {
    v6 = 4;
    v5 = v11;
  }
  else
  {
    if (!v12)
      goto LABEL_11;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_11:
  result = v10;
  if (v10 == v9)
  {
    v8 = 4;
    result = v9;
  }
  else
  {
    if (!v10)
      return result;
    v8 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v8))();
}

void sub_100312860(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  char *v18;
  uint64_t v19;

  v18 = a13;
  if (a13 == &a10)
  {
    v19 = 4;
    v18 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v19 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v18 + 8 * v19))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003128D0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10031290C()
{
}

void sub_10031291C()
{
  operator delete();
}

_QWORD *sub_100312930(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_10212EA00;
  result[1] = v3;
  return result;
}

uint64_t sub_100312964(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_10212EA00;
  a2[1] = v2;
  return result;
}

_QWORD *sub_100312980(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *result;
  uint64_t v8;
  _QWORD v9[3];
  _QWORD *v10;
  _BYTE v11[24];
  _BYTE *v12;

  sub_1002AE164((uint64_t)v9, a2);
  v3 = *(_QWORD *)(a1 + 8);
  v4 = (uint64_t)v10;
  if (!v10)
    goto LABEL_4;
  if (v10 != v9)
  {
    v4 = (*(uint64_t (**)(void))(*v10 + 16))();
LABEL_4:
    v12 = (_BYTE *)v4;
    goto LABEL_6;
  }
  v12 = v11;
  (*(void (**)(_QWORD *, _BYTE *))(v9[0] + 24))(v9, v11);
LABEL_6:
  sub_10030E530(v3, (uint64_t)v11);
  v5 = v12;
  if (v12 == v11)
  {
    v6 = 4;
    v5 = v11;
  }
  else
  {
    if (!v12)
      goto LABEL_11;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_11:
  result = v10;
  if (v10 == v9)
  {
    v8 = 4;
    result = v9;
  }
  else
  {
    if (!v10)
      return result;
    v8 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v8))();
}

void sub_100312A8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  char *v18;
  uint64_t v19;

  v18 = a13;
  if (a13 == &a10)
  {
    v19 = 4;
    v18 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v19 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v18 + 8 * v19))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t sub_100312AFC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100312B38()
{
}

void sub_100312B48()
{
  operator delete();
}

_QWORD *sub_100312B5C(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_10212EA80;
  result[1] = v3;
  return result;
}

uint64_t sub_100312B90(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_10212EA80;
  a2[1] = v2;
  return result;
}

_QWORD *sub_100312BAC(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *result;
  uint64_t v8;
  _QWORD v9[3];
  _QWORD *v10;
  _BYTE v11[24];
  _BYTE *v12;

  sub_1002AE164((uint64_t)v9, a2);
  v3 = *(_QWORD **)(a1 + 8);
  v4 = (uint64_t)v10;
  if (!v10)
    goto LABEL_4;
  if (v10 != v9)
  {
    v4 = (*(uint64_t (**)(void))(*v10 + 16))();
LABEL_4:
    v12 = (_BYTE *)v4;
    goto LABEL_6;
  }
  v12 = v11;
  (*(void (**)(_QWORD *, _BYTE *))(v9[0] + 24))(v9, v11);
LABEL_6:
  sub_10030FAC0(v3, (uint64_t)v11);
  v5 = v12;
  if (v12 == v11)
  {
    v6 = 4;
    v5 = v11;
  }
  else
  {
    if (!v12)
      goto LABEL_11;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_11:
  result = v10;
  if (v10 == v9)
  {
    v8 = 4;
    result = v9;
  }
  else
  {
    if (!v10)
      return result;
    v8 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v8))();
}

void sub_100312CB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  char *v18;
  uint64_t v19;

  v18 = a13;
  if (a13 == &a10)
  {
    v19 = 4;
    v18 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v19 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v18 + 8 * v19))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t sub_100312D28(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100312D64()
{
}

void sub_100312D74()
{
  operator delete();
}

_QWORD *sub_100312D88()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = off_10212EB00;
  return result;
}

void sub_100312DAC(uint64_t a1, _QWORD *a2)
{
  *a2 = off_10212EB00;
}

uint64_t sub_100312DC4()
{
  return 0;
}

uint64_t sub_100312DCC(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else
    return 0;
}

_UNKNOWN **sub_100312E08()
{
}

_QWORD *sub_100312E14(_QWORD *a1, unint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_1002720D4(a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 4 * a2);
    a1[1] = &v4[4 * a2];
  }
  return a1;
}

void sub_100312E6C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100312E88(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  char *v25;
  char *v26;
  __int128 v27;
  _QWORD v29[2];
  char *v30;
  char *v31;
  uint64_t v32;

  v5 = a2;
  if (a5 >= 1)
  {
    v11 = a1[2];
    v9 = (uint64_t)(a1 + 2);
    v10 = v11;
    v12 = *(_QWORD *)(v9 - 8);
    if ((uint64_t)(0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v11 - v12) >> 3)) >= a5)
    {
      v20 = v12 - a2;
      if ((uint64_t)(0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v12 - a2) >> 3)) >= a5)
      {
        v21 = a3 + 120 * a5;
      }
      else
      {
        v21 = a3 + 8 * ((uint64_t)(v12 - a2) >> 3);
        a1[1] = sub_100313200(v9, v21, a4, *(_QWORD *)(v9 - 8));
        if (v20 < 1)
          return v5;
      }
      sub_100313090((uint64_t)a1, v5, v12, v5 + 120 * a5);
      sub_100296B2C(a3, v21, v5);
    }
    else
    {
      v13 = *a1;
      v14 = a5 - 0x1111111111111111 * ((uint64_t)(v12 - *a1) >> 3);
      if (v14 > 0x222222222222222)
        sub_100259694();
      v15 = 0xEEEEEEEEEEEEEEEFLL * ((a2 - v13) >> 3);
      v16 = 0xEEEEEEEEEEEEEEEFLL * ((v10 - v13) >> 3);
      v17 = 2 * v16;
      if (2 * v16 <= v14)
        v17 = a5 - 0x1111111111111111 * ((uint64_t)(v12 - *a1) >> 3);
      if (v16 >= 0x111111111111111)
        v18 = 0x222222222222222;
      else
        v18 = v17;
      v32 = v9;
      if (v18)
        v19 = (char *)sub_100313328(v9, v18);
      else
        v19 = 0;
      v22 = 0;
      v23 = &v19[120 * v15];
      v29[0] = v19;
      v29[1] = v23;
      v30 = v23;
      v31 = &v19[120 * v18];
      v24 = 120 * a5;
      v25 = &v23[120 * a5];
      do
      {
        v26 = &v23[v22];
        v27 = *(_OWORD *)(a3 + v22 + 16);
        *(_OWORD *)v26 = *(_OWORD *)(a3 + v22);
        *((_OWORD *)v26 + 1) = v27;
        sub_1002C0A54(&v23[v22 + 32], a3 + v22 + 32);
        *((_DWORD *)v26 + 28) = *(_DWORD *)(a3 + v22 + 112);
        v22 += 120;
      }
      while (v24 != v22);
      v30 = v25;
      v5 = sub_100313150(a1, v29, v5);
      sub_1003134C4((uint64_t)v29);
    }
  }
  return v5;
}

void sub_100313064(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  uint64_t v12;
  uint64_t v13;

  *(_QWORD *)(v12 + 8) = v13;
  _Unwind_Resume(exception_object);
}

uint64_t sub_100313090(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;

  v6 = *(_QWORD *)(a1 + 8);
  v7 = a2 + v6 - a4;
  v8 = v6;
  if (v7 < a3)
  {
    v10 = a2 + 8 * ((v6 - a4) >> 3) + 32;
    v8 = *(_QWORD *)(a1 + 8);
    do
    {
      v11 = *(_OWORD *)(v10 - 16);
      *(_OWORD *)v8 = *(_OWORD *)(v10 - 32);
      *(_OWORD *)(v8 + 16) = v11;
      sub_1002C0A54(v8 + 32, v10);
      v12 = v10 - 32;
      *(_DWORD *)(v8 + 112) = *(_DWORD *)(v10 + 80);
      v8 += 120;
      v10 += 120;
    }
    while (v12 + 120 < a3);
  }
  *(_QWORD *)(a1 + 8) = v8;
  return sub_1003132A0(a2, v7, v6);
}

void sub_100313148(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_100313150(uint64_t *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v6 = a2[1];
  v7 = (uint64_t)(a1 + 2);
  sub_10031336C((uint64_t)(a1 + 2), a3, a3, *a1, *a1, v6, v6);
  a2[1] = v8;
  a2[2] = sub_100313424(v7, a3, a1[1], a2[2]);
  v9 = *a1;
  *a1 = a2[1];
  a2[1] = v9;
  v10 = a1[1];
  a1[1] = a2[2];
  a2[2] = v10;
  v11 = a1[2];
  a1[2] = a2[3];
  a2[3] = v11;
  *a2 = a2[1];
  return v6;
}

uint64_t sub_100313200(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;

  if (a2 != a3)
  {
    v7 = 0;
    do
    {
      v8 = a4 + v7;
      v9 = a2 + v7;
      v10 = *(_OWORD *)(a2 + v7 + 16);
      *(_OWORD *)v8 = *(_OWORD *)(a2 + v7);
      *(_OWORD *)(v8 + 16) = v10;
      sub_1002C0A54(a4 + v7 + 32, a2 + v7 + 32);
      *(_DWORD *)(v8 + 112) = *(_DWORD *)(a2 + v7 + 112);
      v7 += 120;
    }
    while (v9 + 120 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_10031327C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;

  if (v2)
  {
    v4 = v1 - 88;
    do
    {
      sub_1002C0B04((wireless_diagnostics::google::protobuf::MessageLite *)(v4 + v2));
      v2 -= 120;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003132A0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  __int128 v8;

  if (a2 != a1)
  {
    v6 = 0;
    do
    {
      v7 = a3 + v6;
      v8 = *(_OWORD *)(a2 + v6 - 120);
      *(_OWORD *)(v7 - 104) = *(_OWORD *)(a2 + v6 - 104);
      *(_OWORD *)(v7 - 120) = v8;
      sub_1002C18E4(a3 + v6 - 88, a2 + v6 - 88);
      *(_DWORD *)(v7 - 8) = *(_DWORD *)(a2 + v6 - 8);
      v6 -= 120;
    }
    while (a2 + v6 != a1);
  }
  return a2;
}

void *sub_100313328(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x222222222222223)
    sub_10025955C();
  return operator new(120 * a2);
}

uint64_t sub_10031336C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11;
  uint64_t v12;
  __int128 v13;

  if (a3 != a5)
  {
    v11 = 0;
    do
    {
      v12 = a7 + v11;
      v13 = *(_OWORD *)(a3 + v11 - 120);
      *(_OWORD *)(v12 - 104) = *(_OWORD *)(a3 + v11 - 104);
      *(_OWORD *)(v12 - 120) = v13;
      sub_1002C0A54(a7 + v11 - 88, a3 + v11 - 88);
      *(_DWORD *)(v12 - 8) = *(_DWORD *)(a3 + v11 - 8);
      v11 -= 120;
    }
    while (a3 + v11 != a5);
  }
  return a6;
}

void sub_100313400(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;

  if (v2)
  {
    v4 = v1 + 32;
    do
    {
      sub_1002C0B04((wireless_diagnostics::google::protobuf::MessageLite *)(v4 + v2));
      v2 += 120;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100313424(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;

  if (a2 != a3)
  {
    v7 = 0;
    do
    {
      v8 = a4 + v7;
      v9 = a2 + v7;
      v10 = *(_OWORD *)(a2 + v7 + 16);
      *(_OWORD *)v8 = *(_OWORD *)(a2 + v7);
      *(_OWORD *)(v8 + 16) = v10;
      sub_1002C0A54(a4 + v7 + 32, a2 + v7 + 32);
      *(_DWORD *)(v8 + 112) = *(_DWORD *)(a2 + v7 + 112);
      v7 += 120;
    }
    while (v9 + 120 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_1003134A0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;

  if (v2)
  {
    v4 = v1 - 88;
    do
    {
      sub_1002C0B04((wireless_diagnostics::google::protobuf::MessageLite *)(v4 + v2));
      v2 -= 120;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003134C4(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 120;
    sub_1002C0B04((wireless_diagnostics::google::protobuf::MessageLite *)(i - 88));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void sub_100313514(void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;
  char *v7;
  void (**v8)(char *);
  BOOL v9;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      v6 = v4 - 48;
      v7 = v4 - 48;
      do
      {
        v8 = *(void (***)(char *))v7;
        v7 -= 48;
        (*v8)(v6);
        v9 = v6 == v2;
        v6 = v7;
      }
      while (!v9);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1003135A0(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  uint64_t *v17;

  v3 = *a1;
  v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 4);
  v5 = v4 + 1;
  if (v4 + 1 > 0x555555555555555)
    sub_100259694();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 4);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x2AAAAAAAAAAAAAALL)
    v9 = 0x555555555555555;
  else
    v9 = v5;
  v17 = a1 + 2;
  if (v9)
    v10 = (char *)sub_100313718(v7, v9);
  else
    v10 = 0;
  v13 = v10;
  v14 = &v10[48 * v4];
  v16 = &v10[48 * v9];
  sub_1002BD5C4(v14, a2);
  v15 = v14 + 48;
  sub_1003136A4(a1, &v13);
  v11 = a1[1];
  sub_1003137F4((uint64_t)&v13);
  return v11;
}

void sub_100313690(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1003137F4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1003136A4(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = sub_10031375C((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_100313718(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556)
    sub_10025955C();
  return operator new(48 * a2);
}

uint64_t sub_10031375C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v10 = 0;
  v11 = a7 - 48;
  while (a3 + v10 != a5)
  {
    v12 = v11 + v10;
    v10 -= 48;
    sub_1002BD5C4(v12, v10 + a3);
  }
  return a6;
}

uint64_t sub_1003137F4(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  void (**v4)(void);

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    v4 = *(void (***)(void))(i - 48);
    *(_QWORD *)(a1 + 16) = i - 48;
    (*v4)();
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void sub_100313844(void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    sub_100313884((uint64_t *)v2);
    operator delete(**a1);
  }
}

void sub_100313884(uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 72)
  {
    if (*(char *)(i - 49) < 0)
      operator delete(*(void **)(i - 72));
  }
  a1[1] = v2;
}

uint64_t **sub_1003138D0(uint64_t **a1, __int128 *a2)
{
  uint64_t *v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  uint64_t v7;

  v3 = *a1;
  v5 = (*a1)[1];
  v4 = (*a1)[2];
  v6 = *a1;
  if (v5 >= v4)
  {
    v7 = sub_10031399C(v6, a2);
  }
  else
  {
    sub_100313920((uint64_t)v6, a2);
    v7 = v5 + 72;
  }
  v3[1] = v7;
  return a1;
}

__n128 sub_100313920(uint64_t a1, __int128 *a2)
{
  uint64_t v4;
  __int128 v5;
  __n128 result;
  __int128 v7;

  v4 = *(_QWORD *)(a1 + 8);
  if (*((char *)a2 + 23) < 0)
  {
    sub_100115CE4(*(_BYTE **)(a1 + 8), *(void **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v5 = *a2;
    *(_QWORD *)(v4 + 16) = *((_QWORD *)a2 + 2);
    *(_OWORD *)v4 = v5;
  }
  result = *(__n128 *)((char *)a2 + 24);
  v7 = *(__int128 *)((char *)a2 + 40);
  *(_OWORD *)(v4 + 56) = *(__int128 *)((char *)a2 + 56);
  *(_OWORD *)(v4 + 40) = v7;
  *(__n128 *)(v4 + 24) = result;
  *(_QWORD *)(a1 + 8) = v4 + 72;
  return result;
}

void sub_100313994(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_10031399C(uint64_t *a1, __int128 *a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  __int128 v12;
  char *v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  _QWORD v18[2];
  char *v19;
  char *v20;
  uint64_t *v21;

  v3 = *a1;
  v4 = 0x8E38E38E38E38E39 * ((a1[1] - *a1) >> 3);
  v5 = v4 + 1;
  if (v4 + 1 > 0x38E38E38E38E38ELL)
    sub_100259694();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0x8E38E38E38E38E39 * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x1C71C71C71C71C7)
    v9 = 0x38E38E38E38E38ELL;
  else
    v9 = v5;
  v21 = a1 + 2;
  if (v9)
    v10 = (char *)sub_10029D26C(v7, v9);
  else
    v10 = 0;
  v11 = &v10[72 * v4];
  v18[0] = v10;
  v18[1] = v11;
  v19 = v11;
  v20 = &v10[72 * v9];
  if (*((char *)a2 + 23) < 0)
  {
    sub_100115CE4(v11, *(void **)a2, *((_QWORD *)a2 + 1));
    v11 = v19;
  }
  else
  {
    v12 = *a2;
    *((_QWORD *)v11 + 2) = *((_QWORD *)a2 + 2);
    *(_OWORD *)v11 = v12;
  }
  v13 = &v10[72 * v4];
  v14 = *(__int128 *)((char *)a2 + 56);
  v15 = *(__int128 *)((char *)a2 + 24);
  *(_OWORD *)(v13 + 40) = *(__int128 *)((char *)a2 + 40);
  *(_OWORD *)(v13 + 24) = v15;
  *(_OWORD *)(v13 + 56) = v14;
  v19 = v11 + 72;
  sub_100313AF4(a1, v18);
  v16 = a1[1];
  sub_100313C8C((uint64_t)v18);
  return v16;
}

void sub_100313AE0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_100313C8C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100313AF4(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = sub_100313B68((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_100313B68(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  _QWORD v14[3];
  char v15;
  __int128 v16;
  __int128 v17;

  v7 = a7;
  *(_QWORD *)&v17 = a6;
  *((_QWORD *)&v17 + 1) = a7;
  v16 = v17;
  v14[0] = a1;
  v14[1] = &v16;
  v14[2] = &v17;
  if (a3 != a5)
  {
    v9 = a7;
    do
    {
      v10 = *(_OWORD *)(a3 - 72);
      *(_QWORD *)(v9 - 56) = *(_QWORD *)(a3 - 56);
      *(_OWORD *)(v9 - 72) = v10;
      *(_QWORD *)(a3 - 64) = 0;
      *(_QWORD *)(a3 - 56) = 0;
      *(_QWORD *)(a3 - 72) = 0;
      v11 = *(_OWORD *)(a3 - 48);
      v12 = *(_OWORD *)(a3 - 16);
      *(_OWORD *)(v9 - 32) = *(_OWORD *)(a3 - 32);
      *(_OWORD *)(v9 - 16) = v12;
      *(_OWORD *)(v9 - 48) = v11;
      v9 -= 72;
      v7 -= 72;
      a3 -= 72;
    }
    while (a3 != a5);
    *((_QWORD *)&v17 + 1) = v9;
  }
  v15 = 1;
  sub_100313C14((uint64_t)v14);
  return a6;
}

uint64_t sub_100313C14(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    sub_100313C48(a1);
  return a1;
}

void sub_100313C48(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 23) < 0)
      operator delete(*(void **)v1);
    v1 += 72;
  }
}

uint64_t sub_100313C8C(uint64_t a1)
{
  sub_100313CC0(a1, *(void ***)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void sub_100313CC0(uint64_t a1, void **a2)
{
  void **v2;
  void **v5;

  v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      v5 = v2 - 9;
      *(_QWORD *)(a1 + 16) = v2 - 9;
      if (*((char *)v2 - 49) < 0)
      {
        operator delete(*v5);
        v5 = *(void ***)(a1 + 16);
      }
      v2 = v5;
    }
    while (v5 != a2);
  }
}

unsigned __int8 *sub_100313D14(uint64_t a1, unsigned __int8 *a2, uint64_t a3, __int128 **a4)
{
  unint64_t v4;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint8x8_t v12;
  unint64_t v13;
  unsigned __int8 **v14;
  unsigned __int8 *i;
  unint64_t v16;
  float v17;
  float v18;
  _BOOL8 v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  _QWORD *v23;
  unint64_t v24;
  _QWORD v26[3];

  v8 = (_QWORD *)(a1 + 24);
  v9 = sub_10025A024(a1 + 24, (uint64_t)a2);
  v10 = v9;
  v11 = *(_QWORD *)(a1 + 8);
  if (v11)
  {
    v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      v4 = v9;
      if (v9 >= v11)
        v4 = v9 % v11;
    }
    else
    {
      v4 = (v11 - 1) & v9;
    }
    v14 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v4);
    if (v14)
    {
      for (i = *v14; i; i = *(unsigned __int8 **)i)
      {
        v16 = *((_QWORD *)i + 1);
        if (v16 == v10)
        {
          if ((sub_10025A4CC(a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11)
              v16 %= v11;
          }
          else
          {
            v16 &= v11 - 1;
          }
          if (v16 != v4)
            break;
        }
      }
    }
  }
  sub_100313FA8(a1, v10, a4, (uint64_t)v26);
  v17 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v18 = *(float *)(a1 + 32);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    v19 = 1;
    if (v11 >= 3)
      v19 = (v11 & (v11 - 1)) != 0;
    v20 = v19 | (2 * v11);
    v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21)
      v22 = v21;
    else
      v22 = v20;
    sub_10012E444(a1, v22);
    v11 = *(_QWORD *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11)
        v4 = v10 % v11;
      else
        v4 = v10;
    }
    else
    {
      v4 = (v11 - 1) & v10;
    }
  }
  v23 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v23)
  {
    *(_QWORD *)v26[0] = *v23;
    *v23 = v26[0];
  }
  else
  {
    *(_QWORD *)v26[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v26[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v26[0])
    {
      v24 = *(_QWORD *)(*(_QWORD *)v26[0] + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v24 >= v11)
          v24 %= v11;
      }
      else
      {
        v24 &= v11 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v24) = v26[0];
    }
  }
  i = (unsigned __int8 *)v26[0];
  ++*v8;
  return i;
}

void sub_100313F84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void **__p, uint64_t a13)
{
  if (__p)
    sub_1002A20A8((uint64_t)&a13, __p);
  _Unwind_Resume(exception_object);
}

_BYTE *sub_100313FA8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 **a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7;
  _QWORD *v8;
  _BYTE *result;
  __int128 *v10;
  __int128 v11;

  v7 = a1 + 16;
  v8 = operator new(0x30uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *v8 = 0;
  v8[1] = a2;
  result = v8 + 2;
  v10 = *a3;
  if (*((char *)*a3 + 23) < 0)
  {
    result = sub_100115CE4(result, *(void **)v10, *((_QWORD *)v10 + 1));
  }
  else
  {
    v11 = *v10;
    v8[4] = *((_QWORD *)v10 + 2);
    *(_OWORD *)result = v11;
  }
  v8[5] = 0;
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_100314034(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;

  *v1 = 0;
  sub_1002A20A8(v3, v2);
  _Unwind_Resume(a1);
}

void *sub_100314050(uint64_t a1, unsigned __int8 *a2, uint64_t a3, __int128 **a4)
{
  unint64_t v4;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint8x8_t v12;
  unint64_t v13;
  void **v14;
  void *i;
  unint64_t v16;
  _QWORD *v17;
  __int128 *v18;
  __int128 v19;
  float v20;
  float v21;
  _BOOL8 v22;
  unint64_t v23;
  unint64_t v24;
  size_t v25;
  uint64_t v26;
  _QWORD *v27;
  unint64_t v28;

  v8 = (_QWORD *)(a1 + 24);
  v9 = sub_10025A024(a1 + 24, (uint64_t)a2);
  v10 = v9;
  v11 = *(_QWORD *)(a1 + 8);
  if (v11)
  {
    v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      v4 = v9;
      if (v9 >= v11)
        v4 = v9 % v11;
    }
    else
    {
      v4 = (v11 - 1) & v9;
    }
    v14 = *(void ***)(*(_QWORD *)a1 + 8 * v4);
    if (v14)
    {
      for (i = *v14; i; i = *(void **)i)
      {
        v16 = *((_QWORD *)i + 1);
        if (v16 == v10)
        {
          if ((sub_10025A4CC(a1 + 32, (unsigned __int8 *)i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11)
              v16 %= v11;
          }
          else
          {
            v16 &= v11 - 1;
          }
          if (v16 != v4)
            break;
        }
      }
    }
  }
  v17 = (_QWORD *)(a1 + 16);
  i = operator new(0x30uLL);
  *(_QWORD *)i = 0;
  *((_QWORD *)i + 1) = v10;
  v18 = *a4;
  v19 = **a4;
  *((_QWORD *)i + 4) = *((_QWORD *)*a4 + 2);
  *((_OWORD *)i + 1) = v19;
  *((_QWORD *)v18 + 1) = 0;
  *((_QWORD *)v18 + 2) = 0;
  *(_QWORD *)v18 = 0;
  *((_QWORD *)i + 5) = 0;
  v20 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v21 = *(float *)(a1 + 32);
  if (!v11 || (float)(v21 * (float)v11) < v20)
  {
    v22 = 1;
    if (v11 >= 3)
      v22 = (v11 & (v11 - 1)) != 0;
    v23 = v22 | (2 * v11);
    v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24)
      v25 = v24;
    else
      v25 = v23;
    sub_10012E444(a1, v25);
    v11 = *(_QWORD *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11)
        v4 = v10 % v11;
      else
        v4 = v10;
    }
    else
    {
      v4 = (v11 - 1) & v10;
    }
  }
  v26 = *(_QWORD *)a1;
  v27 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v27)
  {
    *(_QWORD *)i = *v27;
LABEL_38:
    *v27 = i;
    goto LABEL_39;
  }
  *(_QWORD *)i = *v17;
  *v17 = i;
  *(_QWORD *)(v26 + 8 * v4) = v17;
  if (*(_QWORD *)i)
  {
    v28 = *(_QWORD *)(*(_QWORD *)i + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v28 >= v11)
        v28 %= v11;
    }
    else
    {
      v28 &= v11 - 1;
    }
    v27 = (_QWORD *)(*(_QWORD *)a1 + 8 * v28);
    goto LABEL_38;
  }
LABEL_39:
  ++*v8;
  return i;
}

void sub_1003142BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  void **v10;
  uint64_t v11;

  sub_1002A20A8(v11, v10);
  _Unwind_Resume(a1);
}

uint64_t *sub_1003142D8(uint64_t *a1, _QWORD *a2)
{
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  uint64_t v16;

  v4 = *a1;
  v5 = *(_QWORD **)(*a1 + 8);
  v6 = (_QWORD *)(*a1 + 16);
  if ((unint64_t)v5 >= *v6)
  {
    v8 = *(_QWORD **)v4;
    v9 = ((uint64_t)v5 - *(_QWORD *)v4) >> 3;
    v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61)
      sub_100259694();
    v11 = *v6 - (_QWORD)v8;
    if (v11 >> 2 > v10)
      v10 = v11 >> 2;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v10;
    if (v12)
    {
      v13 = (char *)sub_10025E6A0((uint64_t)v6, v12);
      v8 = *(_QWORD **)v4;
      v5 = *(_QWORD **)(v4 + 8);
    }
    else
    {
      v13 = 0;
    }
    v14 = &v13[8 * v9];
    v15 = &v13[8 * v12];
    *(_QWORD *)v14 = *a2;
    v7 = v14 + 8;
    while (v5 != v8)
    {
      v16 = *--v5;
      *((_QWORD *)v14 - 1) = v16;
      v14 -= 8;
    }
    *(_QWORD *)v4 = v14;
    *(_QWORD *)(v4 + 8) = v7;
    *(_QWORD *)(v4 + 16) = v15;
    if (v8)
      operator delete(v8);
  }
  else
  {
    *v5 = *a2;
    v7 = v5 + 1;
  }
  *(_QWORD *)(v4 + 8) = v7;
  return a1;
}

void sub_1003143C8()
{
  operator delete();
}

_QWORD *sub_1003143DC()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = off_10212EB80;
  return result;
}

void sub_100314400(uint64_t a1, _QWORD *a2)
{
  *a2 = off_10212EB80;
}

BOOL sub_100314418(uint64_t a1, uint64_t a2)
{
  int v2;
  NSObject *v4;
  uint64_t v5;
  NSObject *v6;
  _BOOL8 result;
  uint64_t v8;
  int v9;
  int v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  uint64_t v14;

  v2 = *(_DWORD *)(a2 + 24);
  if (v2 == 34)
    return 1;
  if (v2 == 44 || v2 == 35)
    return 0;
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
  v4 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
  {
    v5 = *(unsigned int *)(a2 + 24);
    v9 = 68289282;
    v10 = 0;
    v11 = 2082;
    v12 = "";
    v13 = 2050;
    v14 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"got unexpected event type to indicate start/stop spectating\", \"event type\":%{public}lu}", (uint8_t *)&v9, 0x1Cu);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
  }
  v6 = qword_1022A00F8;
  result = os_signpost_enabled((os_log_t)qword_1022A00F8);
  if (result)
  {
    v8 = *(unsigned int *)(a2 + 24);
    v9 = 68289282;
    v10 = 0;
    v11 = 2082;
    v12 = "";
    v13 = 2050;
    v14 = v8;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v6, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "got unexpected event type to indicate start/stop spectating", "{\"msg%{public}.0s\":\"got unexpected event type to indicate start/stop spectating\", \"event type\":%{public}lu}", (uint8_t *)&v9, 0x1Cu);
    return 0;
  }
  return result;
}

uint64_t sub_1003145D0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10031460C()
{
}

void sub_10031461C()
{
  operator delete();
}

_QWORD *sub_100314630()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = off_10212EC10;
  return result;
}

void sub_100314654(uint64_t a1, _QWORD *a2)
{
  *a2 = off_10212EC10;
}

BOOL sub_10031466C(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t v4;
  _BOOL8 result;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  int v10;
  int v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  uint64_t v15;

  v2 = *(_DWORD *)(a2 + 24);
  if (v2 == 44)
    return 0;
  if (v2 == 50)
  {
    if ((*(_BYTE *)(a2 + 327) & 0x20) != 0)
    {
      v4 = *(_QWORD *)(a2 + 272);
      if (!v4)
        v4 = *(_QWORD *)(qword_1023103F8 + 240);
      if (*(_BYTE *)(v4 + 12))
        return 1;
    }
    return 0;
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
  v6 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
  {
    v7 = *(unsigned int *)(a2 + 24);
    v10 = 68289282;
    v11 = 0;
    v12 = 2082;
    v13 = "";
    v14 = 2050;
    v15 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"got unexpected event type to indicate start/stop motion spectating\", \"event type\":%{public}lu}", (uint8_t *)&v10, 0x1Cu);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212E8D0);
  }
  v8 = qword_1022A00F8;
  result = os_signpost_enabled((os_log_t)qword_1022A00F8);
  if (result)
  {
    v9 = *(unsigned int *)(a2 + 24);
    v10 = 68289282;
    v11 = 0;
    v12 = 2082;
    v13 = "";
    v14 = 2050;
    v15 = v9;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v8, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "got unexpected event type to indicate start/stop motion spectating", "{\"msg%{public}.0s\":\"got unexpected event type to indicate start/stop motion spectating\", \"event type\":%{public}lu}", (uint8_t *)&v10, 0x1Cu);
    return 0;
  }
  return result;
}

uint64_t sub_100314840(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10031487C()
{
}

void sub_100314888(void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;
  char *v7;
  void (**v8)(char *);
  BOOL v9;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      v6 = v4 - 88;
      v7 = v4 - 88;
      do
      {
        v8 = *(void (***)(char *))v7;
        v7 -= 88;
        (*v8)(v6);
        v9 = v6 == v2;
        v6 = v7;
      }
      while (!v9);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_100314914(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  uint64_t *v17;

  v3 = *a1;
  v4 = 0x2E8BA2E8BA2E8BA3 * ((a1[1] - *a1) >> 3);
  v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0x2E8BA2E8BA2E8BALL)
    sub_100259694();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0x2E8BA2E8BA2E8BA3 * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x1745D1745D1745DLL)
    v9 = 0x2E8BA2E8BA2E8BALL;
  else
    v9 = v5;
  v17 = a1 + 2;
  if (v9)
    v10 = (char *)sub_100279B30(v7, v9);
  else
    v10 = 0;
  v13 = v10;
  v14 = &v10[88 * v4];
  v16 = &v10[88 * v9];
  sub_1002E0C70(v14, a2);
  v15 = v14 + 88;
  sub_100314A30(a1, &v13);
  v11 = a1[1];
  sub_100314B3C((uint64_t)&v13);
  return v11;
}

void sub_100314A1C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_100314B3C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100314A30(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = sub_100314AA4((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_100314AA4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v10 = 0;
  v11 = a7 - 88;
  while (a3 + v10 != a5)
  {
    v12 = v11 + v10;
    v10 -= 88;
    sub_1002E0C70(v12, v10 + a3);
  }
  return a6;
}

uint64_t sub_100314B3C(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  void (**v4)(void);

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    v4 = *(void (***)(void))(i - 88);
    *(_QWORD *)(a1 + 16) = i - 88;
    (*v4)();
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

_QWORD *sub_100314B8C@<X0>(uint64_t a1@<X1>, float *a2@<X8>)
{
  CFStringRef v4;
  int v5;
  int v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  int v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  char *v22;
  double v23;
  char *v24;
  unint64_t v25;
  char *v26;
  double v27;
  float v28;
  float v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v33;
  std::__shared_weak_count *v34;
  std::__shared_weak_count *v35;
  __int128 v36;
  char v37;
  _QWORD v38[2];
  _BYTE v39[24];
  _BYTE *v40;
  _QWORD v41[3];
  _QWORD *v42;

  sub_1001E4804(&v33);
  LODWORD(v41[0]) = 0;
  v4 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsFingerprintDistanceFunctionType", 0x8000100u, kCFAllocatorNull);
  v5 = sub_1000B1180(v33, (uint64_t)v4, v41);
  CFRelease(v4);
  v6 = v41[0];
  v7 = v34;
  if (v34)
  {
    p_shared_owners = (unint64_t *)&v34->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  if (v5)
    v10 = v6;
  else
    v10 = 4;
  sub_100320440(v10, v38);
  sub_1002708EC((uint64_t)&v33, a1 + 16);
  v36 = *(_OWORD *)(a1 + 56);
  v37 = 1;
  sub_1002984B4(v10);
  if (v37)
    sub_100067AC4((uint64_t)&v33);
  v11 = (uint64_t)v42;
  if (!v42)
    goto LABEL_14;
  if (v42 != v41)
  {
    v11 = (*(uint64_t (**)(_QWORD *))(*v42 + 16))(v42);
LABEL_14:
    v40 = (_BYTE *)v11;
    goto LABEL_16;
  }
  v40 = v39;
  (*(void (**)(_QWORD *, _BYTE *))(v41[0] + 24))(v41, v39);
LABEL_16:
  sub_1002F11E8((_QWORD *)a1, (uint64_t)v39, (char **)&v33);
  v12 = v40;
  if (v40 == v39)
  {
    v13 = 4;
    v12 = v39;
  }
  else
  {
    if (!v40)
      goto LABEL_21;
    v13 = 5;
  }
  (*(void (**)(void))(*v12 + 8 * v13))();
LABEL_21:
  v14 = v34;
  if (v33)
  {
    v15 = 0;
    v16 = 0.0;
    v17 = 3.4028e38;
    v18 = 1.1755e-38;
    v19 = 1.1755e-38;
    v20 = 0.0;
    v21 = 3.4028e38;
    do
    {
      v22 = (char *)(v15 + 1);
      v23 = *((double *)&v34->__vftable + v15 + (((v15 + 1) * v15) >> 1));
      if (v23 > v18)
        v18 = v23;
      if (v23 < v21)
        v21 = v23;
      v24 = (char *)(v15 + 1);
      if ((unint64_t)v22 < v33)
      {
        do
        {
          if (v15 <= (unint64_t)v24)
            v25 = (unint64_t)v24;
          else
            v25 = v15;
          if (v15 >= (unint64_t)v24)
            v26 = v24;
          else
            v26 = (char *)v15;
          v27 = *((double *)&v34->__vftable + (_QWORD)&v26[(v25 + v25 * v25) >> 1]);
          v16 = v27 + v16;
          if (v27 > v19)
            v19 = v27;
          if (v27 < v17)
            v17 = v27;
          ++v24;
        }
        while ((char *)v33 != v24);
      }
      v28 = v23 + v20;
      v20 = v28 / (float)(unint64_t)v33;
      ++v15;
    }
    while (v22 != (char *)v33);
  }
  else
  {
    v20 = 0.0;
    v19 = 1.1755e-38;
    v21 = 3.4028e38;
    v17 = 3.4028e38;
    v16 = 0.0;
    v18 = 1.1755e-38;
  }
  v29 = (float)((unint64_t)((v33 - 1) * v33) >> 1);
  *a2 = v21;
  a2[1] = v18;
  a2[2] = v20;
  a2[3] = v17;
  a2[4] = v19;
  a2[5] = v16 / v29;
  if (v14)
  {
    v35 = v14;
    operator delete(v14);
  }
  v30 = v42;
  if (v42 == v41)
  {
    v31 = 4;
    v30 = v41;
    goto LABEL_48;
  }
  if (v42)
  {
    v31 = 5;
LABEL_48:
    (*(void (**)(void))(*v30 + 8 * v31))();
  }
  return sub_10011A56C(v38);
}

void sub_100314EBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  uint64_t v10;
  _QWORD *v12;
  uint64_t v13;
  va_list va;

  va_start(va, a10);
  v12 = *(_QWORD **)(v10 - 64);
  if (v12 == (_QWORD *)(v10 - 88))
  {
    v13 = 4;
    v12 = (_QWORD *)(v10 - 88);
  }
  else
  {
    if (!v12)
      goto LABEL_6;
    v13 = 5;
  }
  (*(void (**)(void))(*v12 + 8 * v13))();
LABEL_6:
  sub_10011A56C((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100314F70(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;

  v6 = sub_1002E6718((_QWORD *)a1);
  *v6 = off_10212EC90;
  v6[7] = &off_10212ECE8;
  v6[8] = &off_10212ED60;
  v6[9] = &off_10212EDB8;
  v6[10] = &off_10212EE10;
  v6[11] = &off_10212EE68;
  v6[12] = &off_10212EEC0;
  v6[13] = &off_10212EF18;
  v6[14] = &off_10212EF70;
  v6[15] = &off_10212EFC8;
  v6[16] = &off_10212F018;
  v6[17] = &off_10212F058;
  v6[19] = a2;
  v6[20] = a3;
  if (a3)
  {
    *(_WORD *)(a1 + 144) = 0;
    *(_DWORD *)(a1 + 148) = 0;
    *(_QWORD *)(a1 + 168) = 0;
    *(_QWORD *)(a1 + 176) = 0;
    sub_10031557C();
  }
  sub_1018F32F8();
  abort_report_np("%s:%d: assertion failure in %s", "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMiLoCustomLoiRecordingManager.mm", 19, "CLMiLoCustomLoiRecordingManager");
  __break(1u);
}

void sub_10031514C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, _Unwind_Exception *exception_object, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;

  if (a23 < 0)
    operator delete(__p);
  nullsub_34(v25);
  nullsub_34(v24);
  nullsub_34(v30);
  nullsub_34(v29);
  nullsub_34(v28);
  nullsub_34(v27);
  nullsub_34(v26);
  nullsub_34(a14);
  nullsub_34(a15);
  nullsub_34(a16);
  nullsub_34(a17);
  sub_1002E6784(v23);
  _Unwind_Resume(a1);
}

_QWORD *sub_1003151D4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  char *v4;
  _QWORD *result;

  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 152) + 8))(*(_QWORD *)(a1 + 152));
  sub_100315ECC(a1);
  if (*(_BYTE *)(a1 + 144) && !*(_BYTE *)(a1 + 145))
    v4 = "RecordingState";
  else
    v4 = "RecordingPendingState";
  result = sub_1015A2E04((_QWORD *)a2, v4);
  *(_BYTE *)(a2 + 24) = 1;
  return result;
}

void sub_100315240(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  __int128 v5;
  BOOL v6;
  _BOOL4 v10;
  uint64_t v11;
  __int128 v12;
  _BYTE v13[24];

  v4 = *(_QWORD *)(a1 + 8);
  if (*(char *)(v4 + 31) < 0)
  {
    sub_100115CE4(v13, *(void **)(v4 + 8), *(_QWORD *)(v4 + 16));
  }
  else
  {
    v5 = *(_OWORD *)(v4 + 8);
    *(_QWORD *)&v13[16] = *(_QWORD *)(v4 + 24);
    *(_OWORD *)v13 = v5;
  }
  if ((v13[23] & 0x80000000) == 0)
  {
    if (v13[23] != 21)
      goto LABEL_28;
    v6 = *(_QWORD *)v13 == 0x6E6964726F636552 && *(_QWORD *)&v13[8] == 0x676E69646E655067;
    if (!v6 || *(_QWORD *)&v13[13] != 0x6574617453676E69)
      goto LABEL_28;
LABEL_26:
    sub_1015A2E04((_QWORD *)a2, "RecordingState");
    goto LABEL_32;
  }
  if (*(_QWORD *)&v13[8] == 21)
  {
    v10 = **(_QWORD **)v13 != 0x6E6964726F636552
       || *(_QWORD *)(*(_QWORD *)v13 + 8) != 0x676E69646E655067
       || *(_QWORD *)(*(_QWORD *)v13 + 13) != 0x6574617453676E69;
    operator delete(*(void **)v13);
    if (v10)
      goto LABEL_28;
    goto LABEL_26;
  }
  operator delete(*(void **)v13);
LABEL_28:
  v11 = *(_QWORD *)(a1 + 8);
  if (*(char *)(v11 + 31) < 0)
  {
    sub_100115CE4(v13, *(void **)(v11 + 8), *(_QWORD *)(v11 + 16));
  }
  else
  {
    v12 = *(_OWORD *)(v11 + 8);
    *(_QWORD *)&v13[16] = *(_QWORD *)(v11 + 24);
    *(_OWORD *)v13 = v12;
  }
  *(_OWORD *)a2 = *(_OWORD *)v13;
  *(_QWORD *)(a2 + 16) = *(_QWORD *)&v13[16];
LABEL_32:
  *(_BYTE *)(a2 + 24) = 1;
}

double sub_1003153B0@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  __int128 v4;
  double result;
  __int128 v6;
  uint64_t v7;

  v3 = *(_QWORD *)(a1 + 8);
  if (*(char *)(v3 + 31) < 0)
  {
    sub_100115CE4(&v6, *(void **)(v3 + 8), *(_QWORD *)(v3 + 16));
  }
  else
  {
    v4 = *(_OWORD *)(v3 + 8);
    v7 = *(_QWORD *)(v3 + 24);
    v6 = v4;
  }
  result = *(double *)&v6;
  *(_OWORD *)a2 = v6;
  *(_QWORD *)(a2 + 16) = v7;
  *(_BYTE *)(a2 + 24) = 1;
  return result;
}

_QWORD *sub_100315418@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  unsigned int v4;
  CFStringRef v5;
  int v6;
  unsigned int v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  unsigned int v11;
  char *v12;
  _QWORD *result;
  unsigned int v14;
  uint64_t v15;
  std::__shared_weak_count *v16;

  v4 = *(_DWORD *)(a1 + 148) + 1;
  *(_DWORD *)(a1 + 148) = v4;
  sub_1001E4804(&v15);
  v14 = 0;
  v5 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsCustomLoiMaxRecordings", 0x8000100u, kCFAllocatorNull);
  v6 = sub_1000B1180(v15, (uint64_t)v5, &v14);
  CFRelease(v5);
  v7 = v14;
  v8 = v16;
  if (v16)
  {
    p_shared_owners = (unint64_t *)&v16->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  if (v6)
    v11 = v7;
  else
    v11 = 10;
  if (v4 >= v11)
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 152) + 24))(*(_QWORD *)(a1 + 152));
    v12 = "IdleState";
  }
  else
  {
    v12 = "RecordingThrottledState";
  }
  result = sub_1015A2E04((_QWORD *)a2, v12);
  *(_BYTE *)(a2 + 24) = 1;
  return result;
}

void sub_100315534(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  unint64_t *p_shared_owners;
  unint64_t v14;

  if (a12)
  {
    p_shared_owners = (unint64_t *)&a12->__shared_owners_;
    do
      v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))a12->__on_zero_shared)(a12);
      std::__shared_weak_count::__release_weak(a12);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_10031557C()
{
  operator new();
}

void sub_100315680(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1003156E8()
{
  operator new();
}

void sub_1003158D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_100315944()
{
  operator new();
}

void sub_100315B2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_100315BA0()
{
  operator new();
}

void sub_100315D80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *sub_100315DFC(uint64_t a1)
{
  *(_QWORD *)a1 = off_10212EC90;
  *(_DWORD *)(a1 + 148) = 0;
  sub_1003162C4(a1);
  sub_100316044(a1);
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 152) + 16))(*(_QWORD *)(a1 + 152));
  nullsub_34(a1 + 136);
  nullsub_34(a1 + 128);
  nullsub_34(a1 + 120);
  nullsub_34(a1 + 112);
  nullsub_34(a1 + 104);
  nullsub_34(a1 + 96);
  nullsub_34(a1 + 88);
  nullsub_34(a1 + 80);
  nullsub_34(a1 + 72);
  nullsub_34(a1 + 64);
  nullsub_34(a1 + 56);
  return sub_1002E6784((_QWORD *)a1);
}

void sub_100315EA8(uint64_t a1)
{
  sub_100315DFC(a1);
  operator delete();
}

void sub_100315ECC(uint64_t a1)
{
  CFStringRef v2;
  int v3;
  unsigned int v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  int64_t v8;
  dispatch_time_t v9;
  _QWORD v10[5];
  unsigned int v11;
  uint64_t v12;
  std::__shared_weak_count *v13;

  sub_100316044(a1);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_100316078;
  v10[3] = &unk_10212ECA0;
  v10[4] = a1;
  *(_QWORD *)(a1 + 168) = dispatch_block_create(DISPATCH_BLOCK_ASSIGN_CURRENT, v10);
  sub_1001E4804(&v12);
  v11 = 0;
  v2 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsCustomLoiMaxRecordingWindow", 0x8000100u, kCFAllocatorNull);
  v3 = sub_1000B1180(v12, (uint64_t)v2, &v11);
  CFRelease(v2);
  v4 = v11;
  v5 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  if (v3)
    v8 = 1000000000 * v4;
  else
    v8 = 3600000000000;
  v9 = dispatch_time(0, v8);
  dispatch_after(v9, *(dispatch_queue_t *)(a1 + 160), *(dispatch_block_t *)(a1 + 168));
}

void sub_100315FFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  unint64_t *p_shared_owners;
  unint64_t v18;

  if (a16)
  {
    p_shared_owners = (unint64_t *)&a16->__shared_owners_;
    do
      v18 = __ldaxr(p_shared_owners);
    while (__stlxr(v18 - 1, p_shared_owners));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))a16->__on_zero_shared)(a16);
      std::__shared_weak_count::__release_weak(a16);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_100316044(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 168);
  if (v2)
  {
    dispatch_block_cancel(v2);
    _Block_release(*(const void **)(a1 + 168));
    *(_QWORD *)(a1 + 168) = 0;
  }
}

void sub_100316078(uint64_t a1)
{
  uint64_t v1;
  _QWORD v2[3];
  char v3;

  v1 = *(_QWORD *)(a1 + 32);
  sub_100318928(v2);
  sub_1001569F0((_QWORD *)v1, (uint64_t)v2);
  _Block_release(*(const void **)(v1 + 168));
  *(_QWORD *)(v1 + 168) = 0;
  v2[0] = off_10212F0B8;
  if (v3 < 0)
    operator delete((void *)v2[1]);
}

void sub_1003160DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_100316108(uint64_t a1)
{
  *(_QWORD *)a1 = off_10212F0B8;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  return a1;
}

void sub_100316148(uint64_t a1)
{
  CFStringRef v2;
  int v3;
  unsigned int v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  int64_t v8;
  dispatch_time_t v9;
  _QWORD v10[5];
  unsigned int v11;
  uint64_t v12;
  std::__shared_weak_count *v13;

  sub_1003162C4(a1);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_1003162F8;
  v10[3] = &unk_10212ECA0;
  v10[4] = a1;
  *(_QWORD *)(a1 + 176) = dispatch_block_create(DISPATCH_BLOCK_ASSIGN_CURRENT, v10);
  sub_1001E4804(&v12);
  v11 = 0;
  v2 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsCustomLoiWaitBetweenRecordings", 0x8000100u, kCFAllocatorNull);
  v3 = sub_1000B1180(v12, (uint64_t)v2, &v11);
  CFRelease(v2);
  v4 = v11;
  v5 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  if (v3)
    v8 = 1000000000 * v4;
  else
    v8 = 30000000000;
  v9 = dispatch_time(0, v8);
  dispatch_after(v9, *(dispatch_queue_t *)(a1 + 160), *(dispatch_block_t *)(a1 + 176));
}

void sub_10031627C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  unint64_t *p_shared_owners;
  unint64_t v18;

  if (a16)
  {
    p_shared_owners = (unint64_t *)&a16->__shared_owners_;
    do
      v18 = __ldaxr(p_shared_owners);
    while (__stlxr(v18 - 1, p_shared_owners));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))a16->__on_zero_shared)(a16);
      std::__shared_weak_count::__release_weak(a16);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_1003162C4(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 176);
  if (v2)
  {
    dispatch_block_cancel(v2);
    _Block_release(*(const void **)(a1 + 176));
    *(_QWORD *)(a1 + 176) = 0;
  }
}

void sub_1003162F8(uint64_t a1)
{
  uint64_t v1;
  _QWORD v2[3];
  char v3;

  v1 = *(_QWORD *)(a1 + 32);
  sub_1003189B4(v2);
  sub_1001569F0((_QWORD *)v1, (uint64_t)v2);
  _Block_release(*(const void **)(v1 + 176));
  *(_QWORD *)(v1 + 176) = 0;
  v2[0] = off_10212F0B8;
  if (v3 < 0)
    operator delete((void *)v2[1]);
}

void sub_10031635C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *sub_100316388@<X0>(char *lpsrc@<X2>, void **a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t *v7;
  NSObject *v8;
  char *v9;
  __int128 v10;
  int v11;
  void **v12;
  void **v13;
  void **v14;
  NSObject *v15;
  char *v16;
  __int128 v17;
  int v18;
  void **v19;
  void **v20;
  void **v21;
  NSObject *v22;
  char *v23;
  __int128 v24;
  int v25;
  void **v26;
  void **v27;
  void *__p[2];
  char v29;
  void *__dst[2];
  uint64_t v31;
  uint8_t buf[4];
  int v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  void **v37;
  __int16 v38;
  void **v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  const char *v43;

  if (!lpsrc
  {
    v7 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_49;
    while (1)
    {
      v8 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v9 = (char *)a2[1];
        if (v9[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v9 + 1), *((_QWORD *)v9 + 2));
        }
        else
        {
          v10 = *(_OWORD *)(v9 + 8);
          v31 = *((_QWORD *)v9 + 3);
          *(_OWORD *)__dst = v10;
        }
        v11 = SHIBYTE(v31);
        v12 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v13 = __dst;
        if (v11 < 0)
          v13 = v12;
        if (v29 >= 0)
          v14 = __p;
        else
          v14 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v33 = 0;
        v34 = 2082;
        v35 = "";
        v36 = 2081;
        v37 = v13;
        v38 = 2081;
        v39 = v14;
        v40 = 2082;
        v41 = "assert";
        v42 = 2081;
        v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v31) < 0)
          operator delete(__dst[0]);
        if (v7[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212F088);
      }
      v15 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v16 = (char *)a2[1];
        if (v16[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v16 + 1), *((_QWORD *)v16 + 2));
        }
        else
        {
          v17 = *(_OWORD *)(v16 + 8);
          v31 = *((_QWORD *)v16 + 3);
          *(_OWORD *)__dst = v17;
        }
        v18 = SHIBYTE(v31);
        v19 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v20 = __dst;
        if (v18 < 0)
          v20 = v19;
        if (v29 >= 0)
          v21 = __p;
        else
          v21 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v33 = 0;
        v34 = 2082;
        v35 = "";
        v36 = 2081;
        v37 = v20;
        v38 = 2081;
        v39 = v21;
        v40 = 2082;
        v41 = "assert";
        v42 = 2081;
        v43 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v31) < 0)
          operator delete(__dst[0]);
        if (v7[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212F088);
      }
      v22 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v23 = (char *)a2[1];
        if (v23[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v23 + 1), *((_QWORD *)v23 + 2));
        }
        else
        {
          v24 = *(_OWORD *)(v23 + 8);
          v31 = *((_QWORD *)v23 + 3);
          *(_OWORD *)__dst = v24;
        }
        v25 = SHIBYTE(v31);
        v7 = (uint64_t *)__dst[0];
        a2 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v26 = __dst;
        if (v25 < 0)
          v26 = (void **)v7;
        if (v29 >= 0)
          v27 = __p;
        else
          v27 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v33 = 0;
        v34 = 2082;
        v35 = "";
        v36 = 2081;
        v37 = v26;
        v38 = 2081;
        v39 = v27;
        v40 = 2082;
        v41 = "assert";
        v42 = 2081;
        v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v31) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_49:
      dispatch_once(&qword_1022A00F0, &stru_10212F088);
    }
  }
  return sub_1003151D4((uint64_t)a2, a3);
}

void sub_1003167E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_10031680C(uint64_t a1)
{
  nullsub_34(a1);
  operator delete();
}

_QWORD *sub_100316830@<X0>(char *lpsrc@<X2>, void **a2@<X1>, uint64_t a3@<X8>)
{
  _QWORD *result;
  uint64_t *v7;
  NSObject *v8;
  char *v9;
  __int128 v10;
  int v11;
  void **v12;
  void **v13;
  void **v14;
  NSObject *v15;
  char *v16;
  __int128 v17;
  int v18;
  void **v19;
  void **v20;
  void **v21;
  NSObject *v22;
  char *v23;
  __int128 v24;
  int v25;
  void **v26;
  void **v27;
  void *__p[2];
  char v29;
  void *__dst[2];
  uint64_t v31;
  uint8_t buf[4];
  int v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  void **v37;
  __int16 v38;
  void **v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  const char *v43;

  if (!lpsrc
  {
    v7 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_49;
    while (1)
    {
      v8 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v9 = (char *)a2[1];
        if (v9[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v9 + 1), *((_QWORD *)v9 + 2));
        }
        else
        {
          v10 = *(_OWORD *)(v9 + 8);
          v31 = *((_QWORD *)v9 + 3);
          *(_OWORD *)__dst = v10;
        }
        v11 = SHIBYTE(v31);
        v12 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v13 = __dst;
        if (v11 < 0)
          v13 = v12;
        if (v29 >= 0)
          v14 = __p;
        else
          v14 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v33 = 0;
        v34 = 2082;
        v35 = "";
        v36 = 2081;
        v37 = v13;
        v38 = 2081;
        v39 = v14;
        v40 = 2082;
        v41 = "assert";
        v42 = 2081;
        v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v31) < 0)
          operator delete(__dst[0]);
        if (v7[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212F088);
      }
      v15 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v16 = (char *)a2[1];
        if (v16[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v16 + 1), *((_QWORD *)v16 + 2));
        }
        else
        {
          v17 = *(_OWORD *)(v16 + 8);
          v31 = *((_QWORD *)v16 + 3);
          *(_OWORD *)__dst = v17;
        }
        v18 = SHIBYTE(v31);
        v19 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v20 = __dst;
        if (v18 < 0)
          v20 = v19;
        if (v29 >= 0)
          v21 = __p;
        else
          v21 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v33 = 0;
        v34 = 2082;
        v35 = "";
        v36 = 2081;
        v37 = v20;
        v38 = 2081;
        v39 = v21;
        v40 = 2082;
        v41 = "assert";
        v42 = 2081;
        v43 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v31) < 0)
          operator delete(__dst[0]);
        if (v7[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212F088);
      }
      v22 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v23 = (char *)a2[1];
        if (v23[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v23 + 1), *((_QWORD *)v23 + 2));
        }
        else
        {
          v24 = *(_OWORD *)(v23 + 8);
          v31 = *((_QWORD *)v23 + 3);
          *(_OWORD *)__dst = v24;
        }
        v25 = SHIBYTE(v31);
        v7 = (uint64_t *)__dst[0];
        a2 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v26 = __dst;
        if (v25 < 0)
          v26 = (void **)v7;
        if (v29 >= 0)
          v27 = __p;
        else
          v27 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v33 = 0;
        v34 = 2082;
        v35 = "";
        v36 = 2081;
        v37 = v26;
        v38 = 2081;
        v39 = v27;
        v40 = 2082;
        v41 = "assert";
        v42 = 2081;
        v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v31) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_49:
      dispatch_once(&qword_1022A00F0, &stru_10212F088);
    }
  }
  (*(void (**)(void *))(*(_QWORD *)a2[19] + 24))(a2[19]);
  result = sub_1015A2E04((_QWORD *)a3, "IdleState");
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_100316CA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_100316CD4(char *lpsrc@<X2>, void **a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t *v6;
  NSObject *v7;
  char *v8;
  __int128 v9;
  int v10;
  void **v11;
  void **v12;
  void **v13;
  NSObject *v14;
  char *v15;
  __int128 v16;
  int v17;
  void **v18;
  void **v19;
  void **v20;
  NSObject *v21;
  char *v22;
  __int128 v23;
  int v24;
  void **v25;
  void **v26;
  void *__p[2];
  char v28;
  void *__dst[2];
  uint64_t v30;
  uint8_t buf[4];
  int v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  void **v36;
  __int16 v37;
  void **v38;
  __int16 v39;
  const char *v40;
  __int16 v41;
  const char *v42;

  if (!lpsrc
  {
    v6 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_49;
    while (1)
    {
      v7 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v8 = (char *)a2[1];
        if (v8[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v8 + 1), *((_QWORD *)v8 + 2));
        }
        else
        {
          v9 = *(_OWORD *)(v8 + 8);
          v30 = *((_QWORD *)v8 + 3);
          *(_OWORD *)__dst = v9;
        }
        v10 = SHIBYTE(v30);
        v11 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v12 = __dst;
        if (v10 < 0)
          v12 = v11;
        if (v28 >= 0)
          v13 = __p;
        else
          v13 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v32 = 0;
        v33 = 2082;
        v34 = "";
        v35 = 2081;
        v36 = v12;
        v37 = 2081;
        v38 = v13;
        v39 = 2082;
        v40 = "assert";
        v41 = 2081;
        v42 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v28 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v30) < 0)
          operator delete(__dst[0]);
        if (v6[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212F088);
      }
      v14 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v15 = (char *)a2[1];
        if (v15[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v15 + 1), *((_QWORD *)v15 + 2));
        }
        else
        {
          v16 = *(_OWORD *)(v15 + 8);
          v30 = *((_QWORD *)v15 + 3);
          *(_OWORD *)__dst = v16;
        }
        v17 = SHIBYTE(v30);
        v18 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v19 = __dst;
        if (v17 < 0)
          v19 = v18;
        if (v28 >= 0)
          v20 = __p;
        else
          v20 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v32 = 0;
        v33 = 2082;
        v34 = "";
        v35 = 2081;
        v36 = v19;
        v37 = 2081;
        v38 = v20;
        v39 = 2082;
        v40 = "assert";
        v41 = 2081;
        v42 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v28 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v30) < 0)
          operator delete(__dst[0]);
        if (v6[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212F088);
      }
      v21 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v22 = (char *)a2[1];
        if (v22[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v22 + 1), *((_QWORD *)v22 + 2));
        }
        else
        {
          v23 = *(_OWORD *)(v22 + 8);
          v30 = *((_QWORD *)v22 + 3);
          *(_OWORD *)__dst = v23;
        }
        v24 = SHIBYTE(v30);
        v6 = (uint64_t *)__dst[0];
        a2 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v25 = __dst;
        if (v24 < 0)
          v25 = (void **)v6;
        if (v28 >= 0)
          v26 = __p;
        else
          v26 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v32 = 0;
        v33 = 2082;
        v34 = "";
        v35 = 2081;
        v36 = v25;
        v37 = 2081;
        v38 = v26;
        v39 = 2082;
        v40 = "assert";
        v41 = 2081;
        v42 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v28 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v30) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_49:
      dispatch_once(&qword_1022A00F0, &stru_10212F088);
    }
  }
  sub_100315240((uint64_t)a2, a3);
}

void sub_10031712C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double sub_100317158@<D0>(char *lpsrc@<X2>, void **a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t *v7;
  NSObject *v8;
  char *v9;
  __int128 v10;
  int v11;
  void **v12;
  void **v13;
  void **v14;
  NSObject *v15;
  char *v16;
  __int128 v17;
  int v18;
  void **v19;
  void **v20;
  void **v21;
  NSObject *v22;
  char *v23;
  __int128 v24;
  int v25;
  void **v26;
  void **v27;
  void *__p[2];
  char v29;
  void *__dst[2];
  uint64_t v31;
  uint8_t buf[4];
  int v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  void **v37;
  __int16 v38;
  void **v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  const char *v43;

  if (!lpsrc
  {
    v7 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_49;
    while (1)
    {
      v8 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v9 = (char *)a2[1];
        if (v9[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v9 + 1), *((_QWORD *)v9 + 2));
        }
        else
        {
          v10 = *(_OWORD *)(v9 + 8);
          v31 = *((_QWORD *)v9 + 3);
          *(_OWORD *)__dst = v10;
        }
        v11 = SHIBYTE(v31);
        v12 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v13 = __dst;
        if (v11 < 0)
          v13 = v12;
        if (v29 >= 0)
          v14 = __p;
        else
          v14 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v33 = 0;
        v34 = 2082;
        v35 = "";
        v36 = 2081;
        v37 = v13;
        v38 = 2081;
        v39 = v14;
        v40 = 2082;
        v41 = "assert";
        v42 = 2081;
        v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v31) < 0)
          operator delete(__dst[0]);
        if (v7[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212F088);
      }
      v15 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v16 = (char *)a2[1];
        if (v16[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v16 + 1), *((_QWORD *)v16 + 2));
        }
        else
        {
          v17 = *(_OWORD *)(v16 + 8);
          v31 = *((_QWORD *)v16 + 3);
          *(_OWORD *)__dst = v17;
        }
        v18 = SHIBYTE(v31);
        v19 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v20 = __dst;
        if (v18 < 0)
          v20 = v19;
        if (v29 >= 0)
          v21 = __p;
        else
          v21 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v33 = 0;
        v34 = 2082;
        v35 = "";
        v36 = 2081;
        v37 = v20;
        v38 = 2081;
        v39 = v21;
        v40 = 2082;
        v41 = "assert";
        v42 = 2081;
        v43 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v31) < 0)
          operator delete(__dst[0]);
        if (v7[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212F088);
      }
      v22 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v23 = (char *)a2[1];
        if (v23[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v23 + 1), *((_QWORD *)v23 + 2));
        }
        else
        {
          v24 = *(_OWORD *)(v23 + 8);
          v31 = *((_QWORD *)v23 + 3);
          *(_OWORD *)__dst = v24;
        }
        v25 = SHIBYTE(v31);
        v7 = (uint64_t *)__dst[0];
        a2 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v26 = __dst;
        if (v25 < 0)
          v26 = (void **)v7;
        if (v29 >= 0)
          v27 = __p;
        else
          v27 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v33 = 0;
        v34 = 2082;
        v35 = "";
        v36 = 2081;
        v37 = v26;
        v38 = 2081;
        v39 = v27;
        v40 = 2082;
        v41 = "assert";
        v42 = 2081;
        v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v31) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_49:
      dispatch_once(&qword_1022A00F0, &stru_10212F088);
    }
  }
  return sub_1003153B0((uint64_t)a2, a3);
}

void sub_1003175B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *sub_1003175DC@<X0>(char *lpsrc@<X2>, void **a2@<X1>, uint64_t a3@<X8>)
{
  _QWORD *result;
  uint64_t *v7;
  NSObject *v8;
  char *v9;
  __int128 v10;
  int v11;
  void **v12;
  void **v13;
  void **v14;
  NSObject *v15;
  char *v16;
  __int128 v17;
  int v18;
  void **v19;
  void **v20;
  void **v21;
  NSObject *v22;
  char *v23;
  __int128 v24;
  int v25;
  void **v26;
  void **v27;
  void *__p[2];
  char v29;
  void *__dst[2];
  uint64_t v31;
  uint8_t buf[4];
  int v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  void **v37;
  __int16 v38;
  void **v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  const char *v43;

  if (!lpsrc
  {
    v7 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_49;
    while (1)
    {
      v8 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v9 = (char *)a2[1];
        if (v9[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v9 + 1), *((_QWORD *)v9 + 2));
        }
        else
        {
          v10 = *(_OWORD *)(v9 + 8);
          v31 = *((_QWORD *)v9 + 3);
          *(_OWORD *)__dst = v10;
        }
        v11 = SHIBYTE(v31);
        v12 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v13 = __dst;
        if (v11 < 0)
          v13 = v12;
        if (v29 >= 0)
          v14 = __p;
        else
          v14 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v33 = 0;
        v34 = 2082;
        v35 = "";
        v36 = 2081;
        v37 = v13;
        v38 = 2081;
        v39 = v14;
        v40 = 2082;
        v41 = "assert";
        v42 = 2081;
        v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v31) < 0)
          operator delete(__dst[0]);
        if (v7[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212F088);
      }
      v15 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v16 = (char *)a2[1];
        if (v16[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v16 + 1), *((_QWORD *)v16 + 2));
        }
        else
        {
          v17 = *(_OWORD *)(v16 + 8);
          v31 = *((_QWORD *)v16 + 3);
          *(_OWORD *)__dst = v17;
        }
        v18 = SHIBYTE(v31);
        v19 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v20 = __dst;
        if (v18 < 0)
          v20 = v19;
        if (v29 >= 0)
          v21 = __p;
        else
          v21 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v33 = 0;
        v34 = 2082;
        v35 = "";
        v36 = 2081;
        v37 = v20;
        v38 = 2081;
        v39 = v21;
        v40 = 2082;
        v41 = "assert";
        v42 = 2081;
        v43 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v31) < 0)
          operator delete(__dst[0]);
        if (v7[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212F088);
      }
      v22 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v23 = (char *)a2[1];
        if (v23[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v23 + 1), *((_QWORD *)v23 + 2));
        }
        else
        {
          v24 = *(_OWORD *)(v23 + 8);
          v31 = *((_QWORD *)v23 + 3);
          *(_OWORD *)__dst = v24;
        }
        v25 = SHIBYTE(v31);
        v7 = (uint64_t *)__dst[0];
        a2 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v26 = __dst;
        if (v25 < 0)
          v26 = (void **)v7;
        if (v29 >= 0)
          v27 = __p;
        else
          v27 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v33 = 0;
        v34 = 2082;
        v35 = "";
        v36 = 2081;
        v37 = v26;
        v38 = 2081;
        v39 = v27;
        v40 = 2082;
        v41 = "assert";
        v42 = 2081;
        v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v31) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_49:
      dispatch_once(&qword_1022A00F0, &stru_10212F088);
    }
  }
  (*(void (**)(void *))(*(_QWORD *)a2[19] + 24))(a2[19]);
  result = sub_1015A2E04((_QWORD *)a3, "IdleState");
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_100317A54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *sub_100317A80@<X0>(char *lpsrc@<X2>, void **a2@<X1>, uint64_t a3@<X8>)
{
  char *v6;
  _QWORD *result;
  uint64_t *v8;
  NSObject *v9;
  char *v10;
  __int128 v11;
  int v12;
  void **v13;
  void **v14;
  void **v15;
  NSObject *v16;
  char *v17;
  __int128 v18;
  int v19;
  void **v20;
  void **v21;
  void **v22;
  NSObject *v23;
  char *v24;
  __int128 v25;
  int v26;
  void **v27;
  void **v28;
  void *__p[2];
  char v30;
  void *__dst[2];
  uint64_t v32;
  uint8_t buf[4];
  int v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  void **v38;
  __int16 v39;
  void **v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  const char *v44;

  if (!lpsrc
  {
    v8 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_53;
    while (1)
    {
      v9 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v10 = (char *)a2[1];
        if (v10[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v10 + 1), *((_QWORD *)v10 + 2));
        }
        else
        {
          v11 = *(_OWORD *)(v10 + 8);
          v32 = *((_QWORD *)v10 + 3);
          *(_OWORD *)__dst = v11;
        }
        v12 = SHIBYTE(v32);
        v13 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v14 = __dst;
        if (v12 < 0)
          v14 = v13;
        if (v30 >= 0)
          v15 = __p;
        else
          v15 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v14;
        v39 = 2081;
        v40 = v15;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212F088);
      }
      v16 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v17 = (char *)a2[1];
        if (v17[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v17 + 1), *((_QWORD *)v17 + 2));
        }
        else
        {
          v18 = *(_OWORD *)(v17 + 8);
          v32 = *((_QWORD *)v17 + 3);
          *(_OWORD *)__dst = v18;
        }
        v19 = SHIBYTE(v32);
        v20 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v21 = __dst;
        if (v19 < 0)
          v21 = v20;
        if (v30 >= 0)
          v22 = __p;
        else
          v22 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v21;
        v39 = 2081;
        v40 = v22;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212F088);
      }
      v23 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v24 = (char *)a2[1];
        if (v24[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v24 + 1), *((_QWORD *)v24 + 2));
        }
        else
        {
          v25 = *(_OWORD *)(v24 + 8);
          v32 = *((_QWORD *)v24 + 3);
          *(_OWORD *)__dst = v25;
        }
        v26 = SHIBYTE(v32);
        v8 = (uint64_t *)__dst[0];
        a2 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v27 = __dst;
        if (v26 < 0)
          v27 = (void **)v8;
        if (v30 >= 0)
          v28 = __p;
        else
          v28 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v27;
        v39 = 2081;
        v40 = v28;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_53:
      dispatch_once(&qword_1022A00F0, &stru_10212F088);
    }
  }
  if (*((_BYTE *)a2 + 144) && !*((_BYTE *)a2 + 145))
    v6 = "RecordingState";
  else
    v6 = "RecordingPendingState";
  result = sub_1015A2E04((_QWORD *)a3, v6);
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_100317F04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *sub_100317F30@<X0>(char *lpsrc@<X2>, void **a2@<X1>, uint64_t a3@<X8>)
{
  _QWORD *result;
  uint64_t *v7;
  NSObject *v8;
  char *v9;
  __int128 v10;
  int v11;
  void **v12;
  void **v13;
  void **v14;
  NSObject *v15;
  char *v16;
  __int128 v17;
  int v18;
  void **v19;
  void **v20;
  void **v21;
  NSObject *v22;
  char *v23;
  __int128 v24;
  int v25;
  void **v26;
  void **v27;
  void *__p[2];
  char v29;
  void *__dst[2];
  uint64_t v31;
  uint8_t buf[4];
  int v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  void **v37;
  __int16 v38;
  void **v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  const char *v43;

  if (!lpsrc
  {
    v7 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_49;
    while (1)
    {
      v8 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v9 = (char *)a2[1];
        if (v9[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v9 + 1), *((_QWORD *)v9 + 2));
        }
        else
        {
          v10 = *(_OWORD *)(v9 + 8);
          v31 = *((_QWORD *)v9 + 3);
          *(_OWORD *)__dst = v10;
        }
        v11 = SHIBYTE(v31);
        v12 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v13 = __dst;
        if (v11 < 0)
          v13 = v12;
        if (v29 >= 0)
          v14 = __p;
        else
          v14 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v33 = 0;
        v34 = 2082;
        v35 = "";
        v36 = 2081;
        v37 = v13;
        v38 = 2081;
        v39 = v14;
        v40 = 2082;
        v41 = "assert";
        v42 = 2081;
        v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v31) < 0)
          operator delete(__dst[0]);
        if (v7[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212F088);
      }
      v15 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v16 = (char *)a2[1];
        if (v16[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v16 + 1), *((_QWORD *)v16 + 2));
        }
        else
        {
          v17 = *(_OWORD *)(v16 + 8);
          v31 = *((_QWORD *)v16 + 3);
          *(_OWORD *)__dst = v17;
        }
        v18 = SHIBYTE(v31);
        v19 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v20 = __dst;
        if (v18 < 0)
          v20 = v19;
        if (v29 >= 0)
          v21 = __p;
        else
          v21 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v33 = 0;
        v34 = 2082;
        v35 = "";
        v36 = 2081;
        v37 = v20;
        v38 = 2081;
        v39 = v21;
        v40 = 2082;
        v41 = "assert";
        v42 = 2081;
        v43 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v31) < 0)
          operator delete(__dst[0]);
        if (v7[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212F088);
      }
      v22 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v23 = (char *)a2[1];
        if (v23[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v23 + 1), *((_QWORD *)v23 + 2));
        }
        else
        {
          v24 = *(_OWORD *)(v23 + 8);
          v31 = *((_QWORD *)v23 + 3);
          *(_OWORD *)__dst = v24;
        }
        v25 = SHIBYTE(v31);
        v7 = (uint64_t *)__dst[0];
        a2 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v26 = __dst;
        if (v25 < 0)
          v26 = (void **)v7;
        if (v29 >= 0)
          v27 = __p;
        else
          v27 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v33 = 0;
        v34 = 2082;
        v35 = "";
        v36 = 2081;
        v37 = v26;
        v38 = 2081;
        v39 = v27;
        v40 = 2082;
        v41 = "assert";
        v42 = 2081;
        v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v31) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_49:
      dispatch_once(&qword_1022A00F0, &stru_10212F088);
    }
  }
  (*(void (**)(void *))(*(_QWORD *)a2[19] + 24))(a2[19]);
  result = sub_1015A2E04((_QWORD *)a3, "IdleState");
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_1003183A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *sub_1003183D4@<X0>(char *lpsrc@<X2>, void **a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t *v7;
  NSObject *v8;
  char *v9;
  __int128 v10;
  int v11;
  void **v12;
  void **v13;
  void **v14;
  NSObject *v15;
  char *v16;
  __int128 v17;
  int v18;
  void **v19;
  void **v20;
  void **v21;
  NSObject *v22;
  char *v23;
  __int128 v24;
  int v25;
  void **v26;
  void **v27;
  void *__p[2];
  char v29;
  void *__dst[2];
  uint64_t v31;
  uint8_t buf[4];
  int v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  void **v37;
  __int16 v38;
  void **v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  const char *v43;

  if (!lpsrc
  {
    v7 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_49;
    while (1)
    {
      v8 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v9 = (char *)a2[1];
        if (v9[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v9 + 1), *((_QWORD *)v9 + 2));
        }
        else
        {
          v10 = *(_OWORD *)(v9 + 8);
          v31 = *((_QWORD *)v9 + 3);
          *(_OWORD *)__dst = v10;
        }
        v11 = SHIBYTE(v31);
        v12 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v13 = __dst;
        if (v11 < 0)
          v13 = v12;
        if (v29 >= 0)
          v14 = __p;
        else
          v14 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v33 = 0;
        v34 = 2082;
        v35 = "";
        v36 = 2081;
        v37 = v13;
        v38 = 2081;
        v39 = v14;
        v40 = 2082;
        v41 = "assert";
        v42 = 2081;
        v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v31) < 0)
          operator delete(__dst[0]);
        if (v7[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212F088);
      }
      v15 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v16 = (char *)a2[1];
        if (v16[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v16 + 1), *((_QWORD *)v16 + 2));
        }
        else
        {
          v17 = *(_OWORD *)(v16 + 8);
          v31 = *((_QWORD *)v16 + 3);
          *(_OWORD *)__dst = v17;
        }
        v18 = SHIBYTE(v31);
        v19 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v20 = __dst;
        if (v18 < 0)
          v20 = v19;
        if (v29 >= 0)
          v21 = __p;
        else
          v21 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v33 = 0;
        v34 = 2082;
        v35 = "";
        v36 = 2081;
        v37 = v20;
        v38 = 2081;
        v39 = v21;
        v40 = 2082;
        v41 = "assert";
        v42 = 2081;
        v43 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v31) < 0)
          operator delete(__dst[0]);
        if (v7[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212F088);
      }
      v22 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v23 = (char *)a2[1];
        if (v23[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v23 + 1), *((_QWORD *)v23 + 2));
        }
        else
        {
          v24 = *(_OWORD *)(v23 + 8);
          v31 = *((_QWORD *)v23 + 3);
          *(_OWORD *)__dst = v24;
        }
        v25 = SHIBYTE(v31);
        v7 = (uint64_t *)__dst[0];
        a2 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v26 = __dst;
        if (v25 < 0)
          v26 = (void **)v7;
        if (v29 >= 0)
          v27 = __p;
        else
          v27 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v33 = 0;
        v34 = 2082;
        v35 = "";
        v36 = 2081;
        v37 = v26;
        v38 = 2081;
        v39 = v27;
        v40 = 2082;
        v41 = "assert";
        v42 = 2081;
        v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v31) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_49:
      dispatch_once(&qword_1022A00F0, &stru_10212F088);
    }
  }
  return sub_100315418((uint64_t)a2, a3);
}

void sub_10031882C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_100318858(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 148) = 0;
  sub_1003162C4(a2);
  sub_100316044(a2);
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a2 + 152) + 16))(*(_QWORD *)(a2 + 152));
}

uint64_t sub_100318894(uint64_t a1, uint64_t a2)
{
  return (***(uint64_t (****)(_QWORD))(a2 + 152))(*(_QWORD *)(a2 + 152));
}

void sub_1003188A4(uint64_t a1, uint64_t a2)
{
  sub_100316148(a2);
}

void sub_1003188AC(id a1)
{
  qword_1022A00F8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_1003188D8(uint64_t a1)
{
  *(_QWORD *)a1 = off_10212F0B8;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  operator delete();
}

_QWORD *sub_100318928(_QWORD *a1)
{
  std::string *v2;

  *a1 = off_10212F0B8;
  v2 = (std::string *)sub_1015A2E04(a1 + 1, "No Name Given");
  *a1 = off_10212F0D8;
  std::string::assign(v2, "MaxRecordingTimerFiredEvent");
  return a1;
}

void sub_100318990(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  uint64_t v3;
  uint64_t v4;

  v4 = v3;
  *(_QWORD *)v1 = v4;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

_QWORD *sub_1003189B4(_QWORD *a1)
{
  std::string *v2;

  *a1 = off_10212F0B8;
  v2 = (std::string *)sub_1015A2E04(a1 + 1, "No Name Given");
  *a1 = off_10212F0F8;
  std::string::assign(v2, "ThrottleTimerFiredEvent");
  return a1;
}

void sub_100318A1C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  uint64_t v3;
  uint64_t v4;

  v4 = v3;
  *(_QWORD *)v1 = v4;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

_OWORD *sub_100318A40(uint64_t **a1, const void **a2, uint64_t a3, _OWORD **a4)
{
  void **v6;
  _OWORD *v7;
  uint64_t **v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v12;

  v6 = (void **)sub_10019C424((uint64_t)a1, &v12, a2);
  v7 = *v6;
  if (!*v6)
  {
    v8 = (uint64_t **)v6;
    v7 = operator new(0x40uLL);
    v9 = *a4;
    v10 = *((_QWORD *)*a4 + 2);
    v7[2] = **a4;
    *((_QWORD *)v7 + 6) = v10;
    v9[1] = 0;
    v9[2] = 0;
    *v9 = 0;
    *((_QWORD *)v7 + 7) = 0;
    sub_1000145B0(a1, v12, v8, (uint64_t *)v7);
  }
  return v7;
}

uint64_t sub_100318AD8(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_QWORD *)result = off_10212F118;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 80) = 0;
  *(_BYTE *)(result + 90) = 0;
  *(_BYTE *)(result + 96) = 0;
  *(_BYTE *)(result + 104) = 0;
  *(_BYTE *)(result + 112) = 0;
  *(_BYTE *)(result + 120) = 0;
  *(_QWORD *)(result + 128) = a2;
  *(_QWORD *)(result + 136) = a3;
  *(_WORD *)(result + 184) = 0;
  *(_WORD *)(result + 201) = 0;
  *(_QWORD *)(result + 152) = 0;
  *(_QWORD *)(result + 160) = 0;
  *(_QWORD *)(result + 144) = a4;
  *(_BYTE *)(result + 168) = 0;
  *(_DWORD *)(result + 204) = 255;
  return result;
}

uint64_t sub_100318B24(uint64_t a1, void *a2, _BYTE *a3, double *a4)
{
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  int v10;
  _BYTE v11[8];
  _BYTE v12[80];
  uint64_t v13;
  __int128 v14;
  __int128 v15[2];
  uint64_t v16;

  sub_10027842C(a1 + 8, a2, a3, a4, v11);
  if (v11[0])
  {
    v6 = *(uint64_t **)(a1 + 144);
    v10 = 0;
    sub_1000B0C3C(&v10);
    *(_QWORD *)&v14 = sub_1000B0D38((ssize_t)&v10);
    *((_QWORD *)&v14 + 1) = v7;
    v8 = v13;
    if (!v13)
      v8 = *(_QWORD *)(qword_102310400 + 80);
    sub_100318C60(&v14, v8, (uint64_t)v15, *a4);
    sub_1000B0F04(v6, v15);
    sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)&v16);
    sub_1000B0D18((unsigned int *)&v10);
    sub_100318CE8(a1, (uint64_t)v12);
  }
  return sub_1002DF2E0(v12);
}

void sub_100318C20(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1002DF2E0(v1);
  _Unwind_Resume(a1);
}

void sub_100318C60(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  _BYTE v8[304];

  sub_1000B13D8((uint64_t)v8);
  sub_100358BC0((uint64_t)v8, a2);
  sub_1000B0EC8(a3, a1, *(_DWORD *)(a2 + 16), (uint64_t)v8, a4);
  sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_100318CD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100318CE8(uint64_t a1, uint64_t a2)
{
  int v4;
  unsigned int v5;
  uint64_t v6;
  char *v7;
  unsigned __int8 *v8;
  char v9;
  uint64_t v10;
  char *v11;
  char v12;
  __int128 *v14;
  __int128 v15;
  __int128 *v16;
  __int128 v17;
  void *__p[2];
  char v19;
  void *v20[2];
  char v21;
  std::string __str;
  std::string __dst;

  v4 = sub_10031A9D4(a1, a2);
  v5 = sub_10031B138(a1, a2);
  if ((*(_BYTE *)(a2 + 128) & 4) == 0)
    goto LABEL_5;
  v6 = *(_QWORD *)(a2 + 16);
  if (!v6)
    v6 = *(_QWORD *)(qword_102310400 + 16);
  if ((*(_BYTE *)(v6 + 44) & 4) != 0)
  {
    v14 = *(__int128 **)(v6 + 16);
    if (*((char *)v14 + 23) < 0)
    {
      sub_100115CE4(&__dst, *(void **)v14, *((_QWORD *)v14 + 1));
    }
    else
    {
      v15 = *v14;
      __dst.__r_.__value_.__r.__words[2] = *((_QWORD *)v14 + 2);
      *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v15;
    }
  }
  else
  {
LABEL_5:
    sub_1015A2E04(&__dst, "");
  }
  sub_1015A2E04(&__str, "localization");
  sub_1015A2E04(v20, "home");
  if (v4)
    v7 = "success";
  else
    v7 = "fail";
  sub_1015A2E04(__p, v7);
  v8 = (unsigned __int8 *)(a1 + 90);
  v9 = sub_100368AC4(v8);
  sub_1002E9BE8(a2, (uint64_t)&__str, (uint64_t)&__dst, (uint64_t)v20, (uint64_t)__p, v9);
  if (v19 < 0)
    operator delete(__p[0]);
  if (v21 < 0)
    operator delete(v20[0]);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  if ((*(_BYTE *)(a2 + 129) & 4) == 0)
    goto LABEL_19;
  v10 = *(_QWORD *)(a2 + 88);
  if (!v10)
    v10 = *(_QWORD *)(qword_102310400 + 88);
  if ((*(_BYTE *)(v10 + 44) & 4) != 0)
  {
    v16 = *(__int128 **)(v10 + 16);
    if (*((char *)v16 + 23) < 0)
    {
      sub_100115CE4(&__str, *(void **)v16, *((_QWORD *)v16 + 1));
    }
    else
    {
      v17 = *v16;
      __str.__r_.__value_.__r.__words[2] = *((_QWORD *)v16 + 2);
      *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v17;
    }
  }
  else
  {
LABEL_19:
    sub_1015A2E04(&__str, "");
  }
  std::string::operator=(&__dst, &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  sub_1015A2E04(&__str, "recording");
  sub_1015A2E04(v20, "home");
  if (v5)
    v11 = "success";
  else
    v11 = "fail";
  sub_1015A2E04(__p, v11);
  v12 = sub_100368AC4(v8);
  sub_1002E9BE8(a2, (uint64_t)&__str, (uint64_t)&__dst, (uint64_t)v20, (uint64_t)__p, v12);
  if (v19 < 0)
    operator delete(__p[0]);
  if (v21 < 0)
    operator delete(v20[0]);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__dst.__r_.__value_.__l.__data_);
  return v4 | v5;
}

void sub_100318F54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a33 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_100318FD0(uint64_t a1, void *a2, _BYTE *a3, double *a4)
{
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  int v10;
  _BYTE v11[8];
  _BYTE v12[24];
  uint64_t v13;
  __int128 v14;
  __int128 v15[2];
  uint64_t v16;

  sub_1002F53F4(a2, a3, a4, v11);
  if (v11[0])
  {
    v6 = *(uint64_t **)(a1 + 144);
    v10 = 0;
    sub_1000B0C3C(&v10);
    *(_QWORD *)&v14 = sub_1000B0D38((ssize_t)&v10);
    *((_QWORD *)&v14 + 1) = v7;
    v8 = v13;
    if (!v13)
      v8 = *(_QWORD *)(qword_102310400 + 24);
    sub_10031910C(&v14, v8, (uint64_t)v15, *a4);
    sub_1000B0F04(v6, v15);
    sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)&v16);
    sub_1000B0D18((unsigned int *)&v10);
    sub_100318CE8(a1, (uint64_t)v12);
  }
  return sub_1002DF2E0(v12);
}

void sub_1003190CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1002DF2E0(v1);
  _Unwind_Resume(a1);
}

void sub_10031910C(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  _BYTE v8[304];

  sub_1000B13D8((uint64_t)v8);
  sub_100358878((uint64_t)v8, a2);
  sub_1000B0EC8(a3, a1, *(_DWORD *)(a2 + 32), (uint64_t)v8, a4);
  sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_100319180(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100319194(uint64_t a1, uint64_t *a2, double *a3)
{
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v9;
  _BYTE v10[8];
  _BYTE v11[40];
  uint64_t v12;
  __int128 v13;
  __int128 v14[2];
  uint64_t v15;

  sub_1002EC9D4(a2, a3, v10);
  if (v10[0])
  {
    v5 = *(uint64_t **)(a1 + 144);
    v9 = 0;
    sub_1000B0C3C(&v9);
    *(_QWORD *)&v13 = sub_1000B0D38((ssize_t)&v9);
    *((_QWORD *)&v13 + 1) = v6;
    v7 = v12;
    if (!v12)
      v7 = *(_QWORD *)(qword_102310400 + 40);
    sub_1003192D0(&v13, v7, (uint64_t)v14, *a3);
    sub_1000B0F04(v5, v14);
    sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)&v15);
    sub_1000B0D18((unsigned int *)&v9);
    sub_100318CE8(a1, (uint64_t)v11);
  }
  return sub_1002DF2E0(v11);
}

void sub_100319290(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1002DF2E0(v1);
  _Unwind_Resume(a1);
}

void sub_1003192D0(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  _BYTE v8[304];

  sub_1000B13D8((uint64_t)v8);
  sub_100358904((uint64_t)v8, a2);
  sub_1000B0EC8(a3, a1, *(_DWORD *)(a2 + 8), (uint64_t)v8, a4);
  sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_100319344(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100319358(uint64_t a1, int a2, double *a3)
{
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v9;
  _BYTE v10[8];
  _BYTE v11[32];
  uint64_t v12;
  __int128 v13;
  __int128 v14[2];
  uint64_t v15;

  sub_1003687AC((_BYTE *)(a1 + 90), a2, a3, v10);
  v5 = *(uint64_t **)(a1 + 144);
  v9 = 0;
  sub_1000B0C3C(&v9);
  *(_QWORD *)&v13 = sub_1000B0D38((ssize_t)&v9);
  *((_QWORD *)&v13 + 1) = v6;
  v7 = v12;
  if (!v12)
    v7 = *(_QWORD *)(qword_102310400 + 32);
  sub_100319494(&v13, v7, (uint64_t)v14, *a3);
  sub_1000B0F04(v5, v14);
  sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)&v15);
  sub_1000B0D18((unsigned int *)&v9);
  if (v10[0])
    sub_100318CE8(a1, (uint64_t)v11);
  return sub_1002DF2E0(v11);
}

void sub_100319454(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1002DF2E0(v1);
  _Unwind_Resume(a1);
}

void sub_100319494(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  _BYTE v8[304];

  sub_1000B13D8((uint64_t)v8);
  sub_100358C4C((uint64_t)v8, a2);
  sub_1000B0EC8(a3, a1, *(_DWORD *)(a2 + 16), (uint64_t)v8, a4);
  sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_100319508(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_10031951C(uint64_t a1, void *a2, double *a3)
{
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  int v13;
  _BYTE v14[8];
  _BYTE v15[56];
  uint64_t v16;
  uint64_t v17;
  int v18;
  __int128 v19;
  __int128 v20[2];
  uint64_t v21;

  sub_100339574(a2, a3, v14);
  if (v14[0])
  {
    if (v18 == 9)
    {
      v9 = *(uint64_t **)(a1 + 144);
      v13 = 0;
      sub_1000B0C3C(&v13);
      *(_QWORD *)&v19 = sub_1000B0D38((ssize_t)&v13);
      *((_QWORD *)&v19 + 1) = v10;
      v11 = v16;
      if (!v16)
        v11 = *(_QWORD *)(qword_102310400 + 56);
      sub_100319768(&v19, v11, (uint64_t)v20, *a3);
      sub_1000B0F04(v9, v20);
    }
    else
    {
      if (v18 != 10)
      {
LABEL_12:
        v8 = sub_100318CE8(a1, (uint64_t)v15);
        goto LABEL_13;
      }
      v5 = *(uint64_t **)(a1 + 144);
      v13 = 0;
      sub_1000B0C3C(&v13);
      *(_QWORD *)&v19 = sub_1000B0D38((ssize_t)&v13);
      *((_QWORD *)&v19 + 1) = v6;
      v7 = v17;
      if (!v17)
        v7 = *(_QWORD *)(qword_102310400 + 64);
      sub_1003196E0(&v19, v7, (uint64_t)v20, *a3);
      sub_1000B0F04(v5, v20);
    }
    sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)&v21);
    sub_1000B0D18((unsigned int *)&v13);
    goto LABEL_12;
  }
  v8 = 0;
LABEL_13:
  sub_1002DF2E0(v15);
  return v8;
}

void sub_100319694(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, unsigned int a10)
{
  uint64_t v10;
  uint64_t v11;

  sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)(v11 + 32));
  sub_1000B0D18(&a10);
  sub_1002DF2E0(v10);
  _Unwind_Resume(a1);
}

void sub_1003196E0(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  _BYTE v8[304];

  sub_1000B13D8((uint64_t)v8);
  sub_100358B34((uint64_t)v8, a2);
  sub_1000B0EC8(a3, a1, *(_DWORD *)(a2 + 48), (uint64_t)v8, a4);
  sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_100319754(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)&a9);
  _Unwind_Resume(a1);
}

void sub_100319768(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  _BYTE v8[304];

  sub_1000B13D8((uint64_t)v8);
  sub_100358AA8((uint64_t)v8, a2);
  sub_1000B0EC8(a3, a1, *(_DWORD *)(a2 + 64), (uint64_t)v8, a4);
  sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_1003197DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1003197F0(uint64_t a1, double *a2)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  int v8;
  _BYTE v9[8];
  _BYTE v10[48];
  uint64_t v11;
  __int128 v12;
  __int128 v13[2];
  uint64_t v14;

  sub_1003862EC(a2, v9);
  if (v9[0])
  {
    v4 = *(uint64_t **)(a1 + 144);
    v8 = 0;
    sub_1000B0C3C(&v8);
    *(_QWORD *)&v12 = sub_1000B0D38((ssize_t)&v8);
    *((_QWORD *)&v12 + 1) = v5;
    v6 = v11;
    if (!v11)
      v6 = *(_QWORD *)(qword_102310400 + 48);
    sub_10031992C(&v12, v6, (uint64_t)v13, *a2);
    sub_1000B0F04(v4, v13);
    sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)&v14);
    sub_1000B0D18((unsigned int *)&v8);
    sub_100318CE8(a1, (uint64_t)v10);
  }
  return sub_1002DF2E0(v10);
}

void sub_1003198EC(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1002DF2E0(v1);
  _Unwind_Resume(a1);
}

void sub_10031992C(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  _BYTE v8[304];

  sub_1000B13D8((uint64_t)v8);
  sub_100358A1C((uint64_t)v8, a2);
  sub_1000B0EC8(a3, a1, *(_DWORD *)(a2 + 8), (uint64_t)v8, a4);
  sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_1003199A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1003199B4(uint64_t a1, void **a2, void *a3, double *a4)
{
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v11;
  _BYTE v12[8];
  _BYTE v13[88];
  uint64_t v14;
  __int128 v15;
  __int128 v16[2];
  uint64_t v17;

  sub_100339220(a2, a3, a4, v12);
  if (v12[0])
  {
    v6 = *(uint64_t **)(a1 + 144);
    v11 = 0;
    sub_1000B0C3C(&v11);
    *(_QWORD *)&v15 = sub_1000B0D38((ssize_t)&v11);
    *((_QWORD *)&v15 + 1) = v7;
    v8 = v14;
    if (!v14)
      v8 = *(_QWORD *)(qword_102310400 + 88);
    sub_100319B00(&v15, v8, (uint64_t)v16, *a4);
    sub_1000B0F04(v6, v16);
    sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)&v17);
    sub_1000B0D18((unsigned int *)&v11);
    v9 = sub_100318CE8(a1, (uint64_t)v13);
  }
  else
  {
    v9 = 0;
  }
  sub_1002DF2E0(v13);
  return v9;
}

void sub_100319AC0(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1002DF2E0(v1);
  _Unwind_Resume(a1);
}

void sub_100319B00(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  _BYTE v8[304];

  sub_1000B13D8((uint64_t)v8);
  sub_100358CD8((uint64_t)v8, a2);
  sub_1000B0EC8(a3, a1, *(_DWORD *)(a2 + 8), (uint64_t)v8, a4);
  sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_100319B74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100319B88(uint64_t a1, const std::string *a2, double *a3)
{
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v10;
  _BYTE v11[8];
  _BYTE v12[16];
  uint64_t v13;
  __int128 v14;
  __int128 v15[2];
  uint64_t v16;

  sub_10031C458(a2, a3, v11);
  if (v11[0])
  {
    v5 = *(uint64_t **)(a1 + 144);
    v10 = 0;
    sub_1000B0C3C(&v10);
    *(_QWORD *)&v14 = sub_1000B0D38((ssize_t)&v10);
    *((_QWORD *)&v14 + 1) = v6;
    v7 = v13;
    if (!v13)
      v7 = *(_QWORD *)(qword_102310400 + 16);
    sub_100319CD4(&v14, v7, (uint64_t)v15, *a3);
    sub_1000B0F04(v5, v15);
    sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)&v16);
    sub_1000B0D18((unsigned int *)&v10);
    v8 = sub_100318CE8(a1, (uint64_t)v12);
  }
  else
  {
    v8 = 0;
  }
  sub_1002DF2E0(v12);
  return v8;
}

void sub_100319C94(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1002DF2E0(v1);
  _Unwind_Resume(a1);
}

void sub_100319CD4(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  _BYTE v8[304];

  sub_1000B13D8((uint64_t)v8);
  sub_100358990((uint64_t)v8, a2);
  sub_1000B0EC8(a3, a1, *(_DWORD *)(a2 + 8), (uint64_t)v8, a4);
  sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_100319D48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100319D5C(uint64_t a1, uint64_t *a2, _QWORD *a3, _QWORD *a4)
{
  int v5;
  uint64_t *v6;
  uint64_t v7;
  int v8;
  NSObject *v10;
  uint64_t *v11;
  uint64_t *v13;
  const char *v14;
  uint8_t *v15;
  int v16;
  uint64_t *v17;
  uint8_t buf[4];
  uint64_t *v19;

  v5 = *((char *)a2 + 23);
  if (v5 < 0)
  {
    if (a2[1] != 10)
    {
LABEL_10:
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212F180);
      v10 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
      {
        if (*((char *)a2 + 23) >= 0)
          v11 = a2;
        else
          v11 = (uint64_t *)*a2;
        *(_DWORD *)buf = 136315138;
        v19 = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Legacy client do not support labels form any other client than focus-mode ClientReceived: %s", buf, 0xCu);
      }
      if (sub_1001BFF7C(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212F180);
        if (*((char *)a2 + 23) >= 0)
          v13 = a2;
        else
          v13 = (uint64_t *)*a2;
        v16 = 136315138;
        v17 = v13;
        _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 16, "Legacy client do not support labels form any other client than focus-mode ClientReceived: %s", (const char *)&v16);
        v15 = (uint8_t *)v14;
        sub_100512490("Generic", 1, 0, 0, "BOOL CLMicroLocationLegacyClient::donateTruthTagLabel(const std::string &, const boost::uuids::uuid &, const boost::uuids::uuid &)", "%s\n", v14);
        if (v15 != buf)
          free(v15);
      }
      return 0;
    }
    v6 = (uint64_t *)*a2;
  }
  else
  {
    v6 = a2;
    if (v5 != 10)
      goto LABEL_10;
  }
  v7 = *v6;
  v8 = *((unsigned __int16 *)v6 + 4);
  if (v7 != 0x6F6D2D7375636F66 || v8 != 25956)
    goto LABEL_10;
  if (!*(_BYTE *)(a1 + 201))
    return 0;
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 128)
                                                                                           + 72))(*(_QWORD *)(a1 + 128), *(_QWORD *)(a1 + 185), *(_QWORD *)(a1 + 193), *a4, a4[1], *a3, a3[1]);
}

uint64_t sub_100319FDC(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v9;
  uint64_t *v10;
  uint64_t v11;
  int v12;
  NSObject *v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  const char *v23;
  char *v24;
  int v25;
  uint64_t *v26;
  _OWORD buf[102];

  v9 = *((char *)a2 + 23);
  if (v9 < 0)
  {
    if (a2[1] != 10)
    {
LABEL_10:
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212F180);
      v14 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
      {
        if (*((char *)a2 + 23) >= 0)
          v15 = a2;
        else
          v15 = (uint64_t *)*a2;
        LODWORD(buf[0]) = 136315138;
        *(_QWORD *)((char *)buf + 4) = v15;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Legacy client do not support labels form any other client than focus-mode ClientReceived: %s", (uint8_t *)buf, 0xCu);
      }
      if (sub_1001BFF7C(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212F180);
        if (*((char *)a2 + 23) >= 0)
          v22 = a2;
        else
          v22 = (uint64_t *)*a2;
        v25 = 136315138;
        v26 = v22;
        _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 16, "Legacy client do not support labels form any other client than focus-mode ClientReceived: %s", (const char *)&v25);
        v24 = (char *)v23;
        sub_100512490("Generic", 1, 0, 0, "BOOL CLMicroLocationLegacyClient::donateTruthTagLabelForRecordingEventsBetweenDates(const std::string &, const boost::uuids::uuid &, NSDate *, NSDate *)", "%s\n", v23);
        if (v24 != (char *)buf)
          free(v24);
      }
      return 0;
    }
    v10 = (uint64_t *)*a2;
  }
  else
  {
    v10 = a2;
    if (v9 != 10)
      goto LABEL_10;
  }
  v11 = *v10;
  v12 = *((unsigned __int16 *)v10 + 4);
  if (v11 != 0x6F6D2D7375636F66 || v12 != 25956)
    goto LABEL_10;
  if (*(_BYTE *)(a1 + 201))
  {
    v18 = *(_QWORD *)(a1 + 128);
    v19 = *(_QWORD *)(a1 + 185);
    v20 = *(_QWORD *)(a1 + 193);
    v25 = 0;
    sub_1000B0C3C(&v25);
    *(_QWORD *)&buf[0] = sub_1000B0D38((ssize_t)&v25);
    *((_QWORD *)&buf[0] + 1) = v21;
    v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _OWORD *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v18 + 88))(v18, v19, v20, buf, a3, a4, a5);
    sub_1000B0D18((unsigned int *)&v25);
    return v16;
  }
  return 0;
}

void sub_10031A274(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  sub_1000B0D18((unsigned int *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10031A290(uint64_t a1)
{
  return sub_100278F5C(a1 + 8);
}

uint64_t sub_10031A298(uint64_t result, char a2)
{
  *(_BYTE *)(result + 202) = a2;
  return result;
}

BOOL sub_10031A2A0(uint64_t a1, void *a2)
{
  return sub_10033A21C(a1 + 91, a2);
}

void sub_10031A2A8(uint64_t a1)
{
  CFStringRef v2;
  int v3;
  int v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  int v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  void *__p;
  std::__shared_weak_count *v16;
  char v17;
  __int128 v18;
  char v19;

  sub_1001E4804(&__p);
  LOBYTE(v11) = 0;
  v2 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsEnabled", 0x8000100u, kCFAllocatorNull);
  v3 = sub_1001E48E4((uint64_t)__p, (uint64_t)v2, (BOOL *)&v11);
  CFRelease(v2);
  v4 = v11;
  v5 = v16;
  if (v16)
  {
    p_shared_owners = (unint64_t *)&v16->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  if (v4)
    v8 = v3;
  else
    v8 = 0;
  if (v8 == 1)
  {
    if (!*(_BYTE *)(a1 + 184))
    {
      sub_1015A2E04(&__p, "milo-internal-legacy-client-name-unsupervised");
      v14 = 1;
      v9 = operator new(8uLL);
      *v9 = 0;
      v12 = v9 + 1;
      v13 = v9 + 1;
      v11 = v9;
      sub_10031A4F0((_QWORD *)a1, (uint64_t)&__p, &v14, (uint64_t)&v11, (uint64_t *)&v18);
      *(_OWORD *)(a1 + 168) = v18;
      *(_BYTE *)(a1 + 184) = v19;
      operator delete(v9);
      if (v17 < 0)
        operator delete(__p);
    }
    if (!*(_BYTE *)(a1 + 201))
    {
      sub_1015A2E04(&__p, "focus-mode");
      v14 = 2;
      v10 = operator new(8uLL);
      *v10 = 0;
      v12 = v10 + 1;
      v13 = v10 + 1;
      v11 = v10;
      sub_10031A4F0((_QWORD *)a1, (uint64_t)&__p, &v14, (uint64_t)&v11, (uint64_t *)&v18);
      *(_OWORD *)(a1 + 185) = v18;
      *(_BYTE *)(a1 + 201) = v19;
      operator delete(v10);
      if (v17 < 0)
        operator delete(__p);
    }
  }
}

void sub_10031A4A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  void *v19;

  operator delete(v19);
  if (a19 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void sub_10031A4F0(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  void *v26;
  void *v27;
  uint64_t v28;
  void *v29;
  void *v30;
  uint8_t buf[8];
  __int16 v32;
  const char *v33;
  __int16 v34;
  uint64_t v35;
  __int16 v36;
  int v37;
  _BYTE __p[18];
  __int16 v39;
  uint64_t v40;
  __int16 v41;
  uint64_t v42;
  uint64_t v43;

  *(_BYTE *)a5 = 0;
  *((_BYTE *)a5 + 16) = 0;
  v10 = a1[16];
  sub_1015A2E04(__p, "");
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t, _BYTE *))(*(_QWORD *)v10 + 32))(&v29, v10, a2, __p);
  if (SBYTE3(v40) < 0)
    operator delete(*(void **)__p);
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212F180);
  v11 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a2 + 23) >= 0)
      v12 = a2;
    else
      v12 = *(_QWORD *)a2;
    v13 = *a3;
    *(_QWORD *)__p = 68289538;
    *(_WORD *)&__p[8] = 2082;
    *(_QWORD *)&__p[10] = "";
    v39 = 2082;
    v40 = v12;
    v41 = 2050;
    v42 = v13;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMicroLocationLegacyClient: tryCreateServiceAndConnect\", \"clientName\":%{public, location:escape_only}s, \"serviceType\":%{public}lld}", __p, 0x26u);
  }
  if (v29 != v30)
  {
    v14 = *(_OWORD *)v29;
LABEL_19:
    *(_OWORD *)a5 = v14;
    *((_BYTE *)a5 + 16) = 1;
    v17 = a1[16];
    v18 = *a5;
    v19 = a5[1];
    v20 = a1[19];
    v21 = a1[20];
    sub_1015A2E04(__p, "");
    v22 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _BYTE *))(*(_QWORD *)v17 + 40))(v17, a2, v18, v19, v20, v21, __p);
    if (SBYTE3(v40) < 0)
      operator delete(*(void **)__p);
    if (v22 != -1)
    {
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212F180);
      v23 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        *(_QWORD *)__p = 68289282;
        *(_WORD *)&__p[8] = 2082;
        *(_QWORD *)&__p[10] = "";
        v39 = 2050;
        v40 = v22;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMicroLocationLegacyClient: tryCreateServiceAndConnect: failed to connect\", \"errorId\":%{public}lld}", __p, 0x1Cu);
      }
      *((_BYTE *)a5 + 16) = 0;
    }
    goto LABEL_27;
  }
  v15 = a1[16];
  v16 = *a3;
  v27 = 0;
  v28 = 0;
  v26 = 0;
  sub_10025EA00(&v26, *(const void **)a4, *(_QWORD *)(a4 + 8), (uint64_t)(*(_QWORD *)(a4 + 8) - *(_QWORD *)a4) >> 3);
  sub_1015A2E04(buf, "");
  (*(void (**)(_BYTE *__return_ptr, uint64_t, uint64_t, uint64_t, void **, uint8_t *))(*(_QWORD *)v15 + 16))(__p, v15, a2, v16, &v26, buf);
  if (SBYTE3(v35) < 0)
    operator delete(*(void **)buf);
  if (v26)
  {
    v27 = v26;
    operator delete(v26);
  }
  if (v43 == -1 && BYTE2(v42))
  {
    v14 = *(_OWORD *)__p;
    goto LABEL_19;
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212F180);
  v24 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 68289538;
    *(_DWORD *)&buf[4] = 0;
    v32 = 2082;
    v33 = "";
    v34 = 2050;
    v35 = v43;
    v36 = 1026;
    v37 = BYTE2(v42);
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"CLMicroLocationLegacyClient: tryCreateServiceAndConnect: failed to create a new service\", \"errorId\":%{public}lld, \"descriptorHasValue\":%{public}hhd}", buf, 0x22u);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212F180);
  }
  v25 = qword_1022A00F8;
  if (os_signpost_enabled((os_log_t)qword_1022A00F8))
  {
    *(_DWORD *)buf = 68289538;
    *(_DWORD *)&buf[4] = 0;
    v32 = 2082;
    v33 = "";
    v34 = 2050;
    v35 = v43;
    v36 = 1026;
    v37 = BYTE2(v42);
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v25, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLMicroLocationLegacyClient: tryCreateServiceAndConnect: failed to create a new service", "{\"msg%{public}.0s\":\"CLMicroLocationLegacyClient: tryCreateServiceAndConnect: failed to create a new service\", \"errorId\":%{public}lld, \"descriptorHasValue\":%{public}hhd}", buf, 0x22u);
  }
LABEL_27:
  if (v29)
  {
    v30 = v29;
    operator delete(v29);
  }
}

void sub_10031A954(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a20 < 0)
    operator delete(__p);
  if (a9)
    operator delete(a9);
  if (a12)
    operator delete(a12);
  _Unwind_Resume(exception_object);
}

uint64_t sub_10031A9D4(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  int v6;
  double v7;
  uint64_t v8;
  unsigned __int8 v9;
  unsigned __int8 v10;
  CFStringRef v11;
  int v12;
  unsigned int v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  double v17;
  NSObject *v18;
  uint64_t *v19;
  uint64_t v20;
  double Current;
  uint64_t v22;
  NSObject *v23;
  _OWORD *v24;
  char *v25;
  _OWORD *v26;
  char *p_p;
  uint64_t v28;
  uint64_t v29;
  _BYTE *v30;
  uint64_t v31;
  NSObject *v32;
  char *v33;
  char *v34;
  const char *v36;
  uint8_t *v37;
  double v38;
  void *__p;
  __int128 v40;
  _QWORD v41[2];
  void *v42;
  __int128 v43;
  int v44;
  uint8_t buf[8];
  _BYTE v46[10];
  __int16 v47;
  char *v48;
  __int16 v49;
  char *v50;

  v4 = a1 + 96;
  v5 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 128) + 96))(*(_QWORD *)(a1 + 128));
  v6 = sub_100386668(v4, a2, v5);
  v7 = *(double *)(a2 + 8);
  v38 = v7;
  if (!v6)
    return 0;
  v8 = sub_100386CDC(v4);
  v10 = v9;
  sub_1001E4804(buf);
  LODWORD(v42) = 0;
  v11 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsLocalizingThrottleDuration", 0x8000100u, kCFAllocatorNull);
  v12 = sub_1000B1180(*(uint64_t *)buf, (uint64_t)v11, &v42);
  CFRelease(v11);
  v13 = v42;
  v14 = *(std::__shared_weak_count **)v46;
  if (*(_QWORD *)v46)
  {
    v15 = (unint64_t *)(*(_QWORD *)v46 + 8);
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  v17 = 300.0;
  if (v12)
    v17 = (double)v13;
  if (sub_100386B58(v7, v17, v4, v6, v8, v10))
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212F180);
    v18 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "Legacy throttled request", buf, 2u);
    }
    if (sub_1001BFF7C(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212F180);
      LOWORD(v42) = 0;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 2, "Legacy throttled request", &v42, 2);
      v37 = (uint8_t *)v36;
      sub_100512490("Generic", 1, 0, 2, "BOOL CLMicroLocationLegacyClient::requestLocalizationIfPossible(const CLMicroLocationProto::RecordingEvent &)", "%s\n", v36);
      if (v37 != buf)
        free(v37);
    }
    sub_1002BBF28((uint64_t)&v42);
    v44 |= 2u;
    if ((_UNKNOWN *)v43 == &wireless_diagnostics::google::protobuf::internal::kEmptyString)
      operator new();
    std::string::assign((std::string *)v43, "");
    v19 = *(uint64_t **)(a1 + 144);
    LODWORD(v41[0]) = 0;
    sub_1000B0C3C((int *)v41);
    __p = (void *)sub_1000B0D38((ssize_t)v41);
    *(_QWORD *)&v40 = v20;
    Current = j__CFAbsoluteTimeGetCurrent();
    sub_10031B4CC(&__p, (uint64_t)&v42, (uint64_t)buf, Current);
    sub_1000B0F04(v19, (__int128 *)buf);
    sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)((char *)&v50 + 2));
    sub_1000B0D18((unsigned int *)v41);
    sub_1002D8988((wireless_diagnostics::google::protobuf::MessageLite *)&v42);
    return 0;
  }
  if (*(_BYTE *)(a1 + 184))
  {
    *(_DWORD *)buf = 0;
    sub_1000B0C3C((int *)buf);
    v41[0] = sub_1000B0D38((ssize_t)buf);
    v41[1] = v22;
    sub_1000B0D18((unsigned int *)buf);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212F180);
    v23 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      if (!*(_BYTE *)(a1 + 184))
        sub_10028DF3C();
      v24 = operator new(0x28uLL);
      v42 = v24;
      v43 = xmmword_101B97FF0;
      *v24 = 0u;
      v24[1] = 0u;
      *(_QWORD *)((char *)v24 + 29) = 0;
      sub_100261F9C(a1 + 168, v24);
      if (v43 >= 0)
        v25 = (char *)&v42;
      else
        v25 = (char *)v42;
      v26 = operator new(0x28uLL);
      __p = v26;
      v40 = xmmword_101B97FF0;
      *v26 = 0u;
      v26[1] = 0u;
      *(_QWORD *)((char *)v26 + 29) = 0;
      sub_100261F9C((uint64_t)v41, v26);
      p_p = (char *)&__p;
      if (v40 < 0)
        p_p = (char *)__p;
      *(_DWORD *)buf = 68289538;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)v46 = 2082;
      *(_QWORD *)&v46[2] = "";
      v47 = 2082;
      v48 = v25;
      v49 = 2082;
      v50 = p_p;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMicroLocationLegacyClient: request localization for legacy unsupervised\", \"Service ID\":%{public, location:escape_only}s, \"Request ID\":%{public, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(v40) < 0)
        operator delete(__p);
      if (SHIBYTE(v43) < 0)
        operator delete(v42);
    }
    if (!*(_BYTE *)(a1 + 184))
      sub_10028DF3C();
    v28 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD *, double *, BOOL))(**(_QWORD **)(a1 + 128) + 56))(*(_QWORD *)(a1 + 128), *(_QWORD *)(a1 + 168), *(_QWORD *)(a1 + 176), v41, &v38, v6 == 1);
    v29 = v28;
    v30 = (_BYTE *)(a1 + 201);
    if (!*(_BYTE *)(a1 + 201))
    {
      if (!(_DWORD)v28)
        return v29;
LABEL_44:
      sub_100386CA4(v4, (uint64_t *)&v38);
      return 1;
    }
LABEL_37:
    *(_DWORD *)buf = 0;
    sub_1000B0C3C((int *)buf);
    v42 = (void *)sub_1000B0D38((ssize_t)buf);
    *(_QWORD *)&v43 = v31;
    sub_1000B0D18((unsigned int *)buf);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212F180);
    v32 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      if (!*v30)
        sub_10028DF3C();
      v33 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v33 + 29) = 0;
      *(_OWORD *)v33 = 0u;
      *((_OWORD *)v33 + 1) = 0u;
      sub_100261F9C(a1 + 185, v33);
      v34 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v34 + 29) = 0;
      *(_OWORD *)v34 = 0u;
      *((_OWORD *)v34 + 1) = 0u;
      sub_100261F9C((uint64_t)&v42, v34);
      *(_DWORD *)buf = 68289538;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)v46 = 2082;
      *(_QWORD *)&v46[2] = "";
      v47 = 2082;
      v48 = v33;
      v49 = 2082;
      v50 = v34;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMicroLocationLegacyClient: request localization for legacy focus client\", \"Service ID\":%{public, location:escape_only}s, \"Request ID\":%{public, location:escape_only}s}", buf, 0x26u);
      operator delete(v34);
      operator delete(v33);
    }
    if (!*v30)
      sub_10028DF3C();
    if (((v29 | (*(unsigned int (**)(_QWORD, _QWORD, _QWORD, void **, double *, BOOL))(**(_QWORD **)(a1 + 128) + 56))(*(_QWORD *)(a1 + 128), *(_QWORD *)(a1 + 185), *(_QWORD *)(a1 + 193), &v42, &v38, v6 == 1)) & 1) == 0)return 0;
    goto LABEL_44;
  }
  v29 = 0;
  v30 = (_BYTE *)(a1 + 201);
  if (*(_BYTE *)(a1 + 201))
    goto LABEL_37;
  return v29;
}

void sub_10031B084(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,char a26)
{
  void *v26;
  void *v27;

  operator delete(v27);
  operator delete(v26);
  _Unwind_Resume(a1);
}

uint64_t sub_10031B138(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  BOOL v8;
  CFStringRef v9;
  int v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  uint64_t v15;
  CFStringRef v16;
  int v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t v22;
  unsigned __int8 v23;
  uint64_t v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  std::__shared_weak_count *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t result;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  double v38;
  unsigned int v39;
  _BYTE v40[17];
  _BYTE v41[17];
  uint64_t v42;
  std::__shared_weak_count *v43;
  char v44;

  v4 = a1 + 96;
  v5 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 128) + 96))(*(_QWORD *)(a1 + 128));
  v6 = sub_100386668(v4, a2, v5);
  v38 = *(double *)(a2 + 8);
  if (!*(_BYTE *)(a1 + 184))
    return 0;
  v7 = HIDWORD(v6);
  v8 = !*(_BYTE *)(a1 + 201) || HIDWORD(v6) == 0;
  if (v8 || *(_BYTE *)(a1 + 202))
    return 0;
  sub_1001E4804(&v42);
  v39 = 0;
  v9 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsRecordingThrottleDuration", 0x8000100u, kCFAllocatorNull);
  v10 = sub_1000B1180(v42, (uint64_t)v9, &v39);
  CFRelease(v9);
  v11 = v39;
  v12 = v43;
  if (v43)
  {
    p_shared_owners = (unint64_t *)&v43->__shared_owners_;
    do
      v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  if (v10)
    v15 = v11;
  else
    v15 = 1200;
  if (*(_DWORD *)(a1 + 204) == 1)
  {
    sub_1001E4804(&v42);
    v39 = 0;
    v16 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsRecordingThrottleDurationUnstableModel", 0x8000100u, kCFAllocatorNull);
    v17 = sub_1000B1180(v42, (uint64_t)v16, &v39);
    CFRelease(v16);
    v18 = v39;
    v19 = v43;
    if (v43)
    {
      v20 = (unint64_t *)&v43->__shared_owners_;
      do
        v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
    if (v17)
      v15 = v18;
    else
      v15 = 60;
  }
  v22 = sub_100386CE8(v4);
  if (sub_100386B58(v38, (double)v15, v4, v7, v22, v23))
    return 0;
  if ((*(_BYTE *)(a2 + 129) & 4) == 0)
    goto LABEL_31;
  v24 = *(_QWORD *)(a2 + 88);
  if (!v24)
    v24 = *(_QWORD *)(qword_102310400 + 88);
  if ((*(_BYTE *)(v24 + 44) & 8) != 0 && (sub_10035777C(*(uint64_t ***)(v24 + 24), &v42), v44))
  {
    v25 = v42;
    v26 = v43;
  }
  else
  {
LABEL_31:
    LODWORD(v42) = 0;
    sub_1000B0C3C((int *)&v42);
    v25 = sub_1000B0D38((ssize_t)&v42);
    v26 = v27;
    sub_1000B0D18((unsigned int *)&v42);
  }
  if (*(_BYTE *)(a1 + 184))
  {
    v28 = *(_QWORD *)(a1 + 128);
    v29 = *(_QWORD *)(a1 + 168);
    v30 = *(_QWORD *)(a1 + 176);
    LODWORD(v42) = 0;
    sub_1000B0C3C((int *)&v42);
    v31 = sub_1000B0D38((ssize_t)&v42);
    v41[0] = 0;
    v41[16] = 0;
    v33 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _BYTE *, double *))(*(_QWORD *)v28 + 64))(v28, v29, v30, v31, v32, v41, &v38);
    sub_1000B0D18((unsigned int *)&v42);
    if (!*(_BYTE *)(a1 + 201))
    {
      if (!v33)
        return 0;
LABEL_39:
      sub_100386CC0(v4, (uint64_t *)&v38);
      return 1;
    }
LABEL_38:
    v35 = *(_QWORD *)(a1 + 128);
    v36 = *(_QWORD *)(a1 + 185);
    v37 = *(_QWORD *)(a1 + 193);
    v40[0] = 0;
    v40[16] = 0;
    if (((v33 | (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint64_t, std::__shared_weak_count *, _BYTE *, double *))(*(_QWORD *)v35 + 64))(v35, v36, v37, v25, v26, v40, &v38)) & 1) == 0)return 0;
    goto LABEL_39;
  }
  v33 = 0;
  result = 0;
  if (*(_BYTE *)(a1 + 201))
    goto LABEL_38;
  return result;
}

void sub_10031B490(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  sub_1000B0D18((unsigned int *)va);
  _Unwind_Resume(a1);
}

void sub_10031B4CC(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  _BYTE v8[304];

  sub_1000B13D8((uint64_t)v8);
  sub_100359598((uint64_t)v8, a2);
  sub_1000B0EC8(a3, a1, *(_DWORD *)(a2 + 16), (uint64_t)v8, a4);
  sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_10031B540(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)&a9);
  _Unwind_Resume(a1);
}

id sub_10031B554(uint64_t a1, double *a2)
{
  id *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  id v8;

  v4 = *(id **)(a1 + 136);
  sub_1009ADF40(a2, (uint64_t)a2);
  sub_1002ACA78(v4, v5);
  v6 = *(_QWORD *)(a1 + 136);
  v8 = sub_1009ADAF4((uint64_t)a2, v7);
  return sub_1002ACCA4(v6, v8);
}

void sub_10031B5A8(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  _BOOL4 v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  char v16;
  NSObject *v18;
  NSObject *v20;
  CFAbsoluteTime Current;
  uint64_t *v22;
  _QWORD *v23;
  uint64_t v24;
  uint8_t buf[8];
  __int16 v26;
  const char *v27;
  __int16 v28;
  _BOOL4 v29;
  void *v30;
  void *v31;
  void *v32;
  char v33;
  char v34;
  _BYTE v35[40];
  char v36;
  void *__p;
  void *v38;

  v8 = a4[18];
  v7 = a4[19];
  if (v8 == v7)
  {
    v11 = 0;
  }
  else
  {
    v9 = v8 + 4;
    do
    {
      v10 = *(_DWORD *)(v9 - 4);
      v11 = v10 == 3;
      v12 = v10 == 3 || v9 == v7;
      v9 += 4;
    }
    while (!v12);
  }
  v13 = *a4;
  v14 = a4[1];
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212F180);
  v15 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 68289538;
    *(_DWORD *)&buf[4] = 0;
    v26 = 2082;
    v27 = "";
    v28 = 1026;
    v29 = v11;
    LOWORD(v30) = 1026;
    *(_DWORD *)((char *)&v30 + 2) = v13 == v14;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Not publishing to Legacy client\", \"because test FP is invalid\":%{public}hhd, \"because probability vector is empty\":%{public}hhd}", buf, 0x1Eu);
  }
  v16 = v13 == v14 || v11;
  if ((v16 & 1) == 0)
  {
    if (*(_BYTE *)(a1 + 184))
    {
      if (*(_QWORD *)(a1 + 168) == *a2 && *(_QWORD *)(a1 + 176) == a2[1])
      {
        v23 = 0;
        v24 = 0;
        v22 = (uint64_t *)&v23;
        Current = j__CFAbsoluteTimeGetCurrent();
        sub_10031BE80(buf, &xmmword_102310470, (uint64_t)a4);
        sub_10031C108(&v22, (__int128 *)buf);
        if (__p)
        {
          v38 = __p;
          operator delete(__p);
        }
        if (v36)
          sub_1002A1C94((uint64_t)v35);
        if (v34 && v33 < 0)
          operator delete(v32);
        if (v30)
        {
          v31 = v30;
          operator delete(v30);
        }
        if (SHIBYTE(v29) < 0)
          operator delete(*(void **)buf);
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212F180);
        v18 = qword_1022A00F8;
        if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 68289026;
          *(_DWORD *)&buf[4] = 0;
          v26 = 2082;
          v27 = "";
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Legacy client Publishing unsupervised localization results to Biome\"}", buf, 0x12u);
        }
        sub_10031B554(a1, &Current);
        sub_10031C044((uint64_t)&v22, v23);
      }
    }
    if (*(_BYTE *)(a1 + 201))
    {
      if (*(_QWORD *)(a1 + 185) == *a2 && *(_QWORD *)(a1 + 193) == a2[1])
      {
        v23 = 0;
        v24 = 0;
        Current = 0.0;
        v22 = (uint64_t *)&v23;
        Current = j__CFAbsoluteTimeGetCurrent();
        sub_10031BE80(buf, &xmmword_102310488, (uint64_t)a4);
        sub_10031C108(&v22, (__int128 *)buf);
        if (__p)
        {
          v38 = __p;
          operator delete(__p);
        }
        if (v36)
          sub_1002A1C94((uint64_t)v35);
        if (v34 && v33 < 0)
          operator delete(v32);
        if (v30)
        {
          v31 = v30;
          operator delete(v30);
        }
        if (SHIBYTE(v29) < 0)
          operator delete(*(void **)buf);
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212F180);
        v20 = qword_1022A00F8;
        if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 68289026;
          *(_DWORD *)&buf[4] = 0;
          v26 = 2082;
          v27 = "";
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Legacy client Publishing focusMode localization results to Biome\"}", buf, 0x12u);
        }
        sub_10031B554(a1, &Current);
        sub_10031C044((uint64_t)&v22, v23);
      }
    }
  }
}

void sub_10031B9A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, _QWORD *a11)
{
  uint64_t v11;

  sub_10031C044(v11, a11);
  _Unwind_Resume(a1);
}

uint64_t sub_10031B9F8(uint64_t a1)
{
  void *v2;
  void *v3;

  v2 = *(void **)(a1 + 168);
  if (v2)
  {
    *(_QWORD *)(a1 + 176) = v2;
    operator delete(v2);
  }
  if (*(_BYTE *)(a1 + 152))
    sub_1002A1C94(a1 + 112);
  if (*(_BYTE *)(a1 + 104) && *(char *)(a1 + 103) < 0)
    operator delete(*(void **)(a1 + 80));
  v3 = *(void **)(a1 + 24);
  if (v3)
  {
    *(_QWORD *)(a1 + 32) = v3;
    operator delete(v3);
  }
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  return a1;
}

void sub_10031BA70(uint64_t a1, uint64_t *a2)
{
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  BOOL v12;
  int v13;
  int v14;
  uint64_t *v15;
  uint64_t v16;
  double Current;
  int v18;
  _BYTE v19[12];
  int v20;
  int v21;
  __int128 v22;
  uint8_t buf[4];
  int v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  _BOOL4 v28;
  __int16 v29;
  _BOOL4 v30;
  __int16 v31;
  _BOOL4 v32;
  __int16 v33;
  int v34;

  if (*(_BYTE *)(a1 + 184))
  {
    if (*(_QWORD *)(a1 + 168) == a2[4] && *(_QWORD *)(a1 + 176) == a2[5])
    {
      v6 = (_QWORD *)a2[1];
      v5 = (_QWORD *)a2[2];
      if (v6 != v5)
      {
        while (*v6 != 1)
        {
          if (++v6 == v5)
          {
            v6 = (_QWORD *)a2[2];
            break;
          }
        }
      }
      v8 = (_QWORD *)a2[10];
      v7 = (_QWORD *)a2[11];
      if (v8 != v7)
      {
        while (*v8 != 3)
        {
          if (++v8 == v7)
          {
            v8 = (_QWORD *)a2[11];
            break;
          }
        }
      }
      v9 = *a2;
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212F180);
      v10 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        v11 = a2[9];
        *(_DWORD *)buf = 68290050;
        v24 = 0;
        v25 = 2082;
        v26 = "";
        v27 = 1026;
        v28 = v9 == 1;
        v29 = 1026;
        v30 = v6 != v5;
        v31 = 1026;
        v32 = v8 != v7;
        v33 = 1026;
        v34 = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMicroLocationLegacyClient Service Status update\", \"isSuspended\":%{public}hhd, \"isReasonModelUnavailable\":%{public}hhd, \"isQualityReasonLowObservations\":%{public}hhd, \"service quality\":%{public}d}", buf, 0x2Au);
      }
      v12 = v6 != v5 && v9 == 1;
      if (v12 || v8 != v7)
      {
        v13 = 1;
      }
      else if (*a2)
      {
        v13 = 255;
      }
      else
      {
        v13 = 2;
      }
      *(_DWORD *)(a1 + 204) = v13;
      sub_1002BC030((uint64_t)v19);
      v14 = *(_DWORD *)(a1 + 204);
      if (!sub_1002BC6F8(v14))
        __assert_rtn("set_numberofobservationsstate", "microlocation.pb.h", 20901, "::CLMicroLocationProto::NumberOfObservationsStates_IsValid(value)");
      v21 |= 2u;
      v20 = v14;
      v15 = *(uint64_t **)(a1 + 144);
      v18 = 0;
      sub_1000B0C3C(&v18);
      *(_QWORD *)&v22 = sub_1000B0D38((ssize_t)&v18);
      *((_QWORD *)&v22 + 1) = v16;
      Current = j__CFAbsoluteTimeGetCurrent();
      sub_10031BD34(&v22, (uint64_t)v19, (uint64_t)buf, Current);
      sub_1000B0F04(v15, (__int128 *)buf);
      sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)&v32);
      sub_1000B0D18((unsigned int *)&v18);
      sub_1002E1AB0((wireless_diagnostics::google::protobuf::MessageLite *)v19);
    }
  }
}

void sub_10031BCF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, unsigned int a10, char a11)
{
  uint64_t v11;

  sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)(v11 + 32));
  sub_1000B0D18(&a10);
  sub_1002E1AB0((wireless_diagnostics::google::protobuf::MessageLite *)&a11);
  _Unwind_Resume(a1);
}

void sub_10031BD34(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  _BYTE v8[304];

  sub_1000B13D8((uint64_t)v8);
  sub_10035973C((uint64_t)v8, a2);
  sub_1000B0EC8(a3, a1, *(_DWORD *)(a2 + 8), (uint64_t)v8, a4);
  sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_10031BDA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1000B2748((wireless_diagnostics::google::protobuf::MessageLite *)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_10031BDCC(uint64_t a1)
{
  *(_QWORD *)a1 = off_10212F118;
  if (*(_BYTE *)(a1 + 80))
    sub_1002D1518(a1 + 8);
  return a1;
}

void sub_10031BE08(uint64_t a1)
{
  *(_QWORD *)a1 = off_10212F118;
  if (*(_BYTE *)(a1 + 80))
    sub_1002D1518(a1 + 8);
  operator delete();
}

void sub_10031BE54(id a1)
{
  qword_1022A00F8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

_QWORD *sub_10031BE80(_QWORD *__dst, __int128 *a2, uint64_t a3)
{
  __int128 v5;

  if (*((char *)a2 + 23) < 0)
  {
    sub_100115CE4(__dst, *(void **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v5 = *a2;
    __dst[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)__dst = v5;
  }
  sub_10031BEF8((uint64_t)(__dst + 3), a3);
  return __dst;
}

void sub_10031BEDC(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

uint64_t sub_10031BEF8(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  int v5;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  sub_1002A2358((_QWORD *)a1, *(const void **)a2, *(_QWORD *)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 5);
  v4 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 33) = *(_OWORD *)(a2 + 33);
  *(_OWORD *)(a1 + 24) = v4;
  sub_1002A2230(a1 + 56, (__int128 *)(a2 + 56));
  sub_10031BFE8((_BYTE *)(a1 + 88), a2 + 88);
  v5 = *(_DWORD *)(a2 + 136);
  *(_QWORD *)(a1 + 144) = 0;
  *(_DWORD *)(a1 + 136) = v5;
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  sub_10027205C((_QWORD *)(a1 + 144), *(const void **)(a2 + 144), *(_QWORD *)(a2 + 152), (uint64_t)(*(_QWORD *)(a2 + 152) - *(_QWORD *)(a2 + 144)) >> 2);
  return a1;
}

void sub_10031BF94(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  uint64_t v3;
  void *v5;

  if (*(_BYTE *)(v1 + 128))
    sub_1002A1C94(v3);
  if (*(_BYTE *)(v1 + 80) && *(char *)(v1 + 79) < 0)
    operator delete(*v2);
  v5 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

_BYTE *sub_10031BFE8(_BYTE *a1, uint64_t a2)
{
  *a1 = 0;
  a1[40] = 0;
  if (*(_BYTE *)(a2 + 40))
  {
    sub_1002A1D10((uint64_t)a1, a2);
    a1[40] = 1;
  }
  return a1;
}

void sub_10031C028(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(_BYTE *)(v1 + 40))
    sub_1002A1C94(v1);
  _Unwind_Resume(exception_object);
}

void sub_10031C044(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    sub_10031C044(a1, *a2);
    sub_10031C044(a1, a2[1]);
    sub_10031C08C((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void sub_10031C08C(uint64_t a1)
{
  void *v2;
  void *v3;

  v2 = *(void **)(a1 + 168);
  if (v2)
  {
    *(_QWORD *)(a1 + 176) = v2;
    operator delete(v2);
  }
  if (*(_BYTE *)(a1 + 152))
    sub_1002A1C94(a1 + 112);
  if (*(_BYTE *)(a1 + 104) && *(char *)(a1 + 103) < 0)
    operator delete(*(void **)(a1 + 80));
  v3 = *(void **)(a1 + 24);
  if (v3)
  {
    *(_QWORD *)(a1 + 32) = v3;
    operator delete(v3);
  }
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

uint64_t *sub_10031C108(uint64_t **a1, __int128 *a2)
{
  uint64_t *v4;
  uint64_t **v5;
  uint64_t *v6;
  uint64_t v8;
  uint64_t *v9[2];
  char v10;

  v4 = (uint64_t *)(a1 + 1);
  v9[0] = (uint64_t *)operator new(0xE0uLL);
  v9[1] = v4;
  sub_10031C228((uint64_t)(v9[0] + 4), a2);
  v10 = 1;
  v5 = (uint64_t **)sub_10031C1B0((uint64_t)a1, &v8, (const void **)v9[0] + 4);
  sub_1000145B0(a1, v8, v5, v9[0]);
  v6 = v9[0];
  v9[0] = 0;
  sub_10031C314((uint64_t)v9, 0);
  return v6;
}

void sub_10031C198(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_10031C314((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

_QWORD *sub_10031C1B0(uint64_t a1, _QWORD *a2, const void **a3)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v7;
  _QWORD *result;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 8);
  if (v4)
  {
    v7 = a1 + 16;
    do
    {
      while (1)
      {
        v5 = (_QWORD *)v4;
        if (!sub_100279008(v7, a3, (const void **)(v4 + 32)))
          break;
        v4 = *v5;
        result = v5;
        if (!*v5)
          goto LABEL_9;
      }
      v4 = v5[1];
    }
    while (v4);
    result = v5 + 1;
  }
  else
  {
    result = (_QWORD *)(a1 + 8);
  }
LABEL_9:
  *a2 = v5;
  return result;
}

uint64_t sub_10031C228(uint64_t a1, __int128 *a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  uint64_t v8;

  v4 = *a2;
  *(_QWORD *)(a1 + 16) = *((_QWORD *)a2 + 2);
  *(_OWORD *)a1 = v4;
  *((_QWORD *)a2 + 1) = 0;
  *((_QWORD *)a2 + 2) = 0;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + 24) = *(__int128 *)((char *)a2 + 24);
  *(_QWORD *)(a1 + 40) = *((_QWORD *)a2 + 5);
  *((_QWORD *)a2 + 3) = 0;
  *((_QWORD *)a2 + 4) = 0;
  *((_QWORD *)a2 + 5) = 0;
  v5 = a2[3];
  v6 = *(__int128 *)((char *)a2 + 57);
  *(_BYTE *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 57) = v6;
  *(_OWORD *)(a1 + 48) = v5;
  *(_BYTE *)(a1 + 104) = 0;
  if (*((_BYTE *)a2 + 104))
  {
    v7 = a2[5];
    *(_QWORD *)(a1 + 96) = *((_QWORD *)a2 + 12);
    *(_OWORD *)(a1 + 80) = v7;
    *((_QWORD *)a2 + 11) = 0;
    *((_QWORD *)a2 + 12) = 0;
    *((_QWORD *)a2 + 10) = 0;
    *(_BYTE *)(a1 + 104) = 1;
  }
  *(_BYTE *)(a1 + 112) = 0;
  v8 = a1 + 112;
  *(_BYTE *)(a1 + 152) = 0;
  if (*((_BYTE *)a2 + 152))
  {
    sub_10012D080(v8, (uint64_t *)a2 + 14);
    *(_BYTE *)(a1 + 152) = 1;
  }
  *(_DWORD *)(a1 + 160) = *((_DWORD *)a2 + 40);
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  *(_OWORD *)(a1 + 168) = *(__int128 *)((char *)a2 + 168);
  *(_QWORD *)(a1 + 184) = *((_QWORD *)a2 + 23);
  *((_QWORD *)a2 + 21) = 0;
  *((_QWORD *)a2 + 22) = 0;
  *((_QWORD *)a2 + 23) = 0;
  return a1;
}

void sub_10031C314(uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      sub_10031C08C((uint64_t)v2 + 32);
    operator delete(v2);
  }
}

id sub_10031C3CC(uint64_t a1)
{
  id result;

  result = objc_alloc_init(*(Class *)(a1 + 32));
  qword_102301140 = (uint64_t)result;
  return result;
}

void sub_10031C458(const std::string *a1@<X1>, double *a2@<X2>, _BYTE *a3@<X8>)
{
  NSObject *v6;
  const std::string *v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  int v11;
  int v12;
  _BYTE v13[136];
  uint64_t v14;
  int v15;
  std::string *v16;
  int v17;
  uint8_t buf[4];
  int v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  const std::string *v23;

  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212F1A0);
  v6 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    if ((a1->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v7 = a1;
    else
      v7 = (const std::string *)a1->__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 68289282;
    v19 = 0;
    v20 = 2082;
    v21 = "";
    v22 = 2082;
    v23 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMicroLocationLogic: client request localization scan\", \"client\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
  sub_1002BBAF4(&v14);
  v17 |= 4u;
  if (v16 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    operator new();
  std::string::operator=(v16, a1);
  v8 = SHIBYTE(a1->__r_.__value_.__r.__words[2]);
  if (v8 < 0)
  {
    if (a1->__r_.__value_.__l.__size_ != 18)
    {
LABEL_19:
      v12 = 1;
      goto LABEL_26;
    }
    a1 = (const std::string *)a1->__r_.__value_.__r.__words[0];
  }
  else if (v8 != 18)
  {
    goto LABEL_19;
  }
  v9 = 0x4E6F746966696361;
  v10 = bswap64(a1->__r_.__value_.__r.__words[0]);
  if (v10 == 0x4E6F746966696361
    && (v9 = 0x74696F6E43656E74, v10 = bswap64(a1->__r_.__value_.__l.__size_), v10 == 0x74696F6E43656E74)
    && (v10 = bswap32(LOWORD(a1->__r_.__value_.__r.__words[2])) >> 16, v9 = 25970, (_DWORD)v10 == 25970))
  {
    v11 = 0;
  }
  else if (v10 < v9)
  {
    v11 = -1;
  }
  else
  {
    v11 = 1;
  }
  if (v11)
    v12 = 1;
  else
    v12 = 3;
LABEL_26:
  if (!sub_100106170(v12))
    __assert_rtn("set_receivedeventactiontype", "microlocation.pb.h", 12856, "::CLMicroLocationProto::ReceivedEventActionType_IsValid(value)");
  v17 |= 2u;
  v15 = v12;
  sub_10031C740((uint64_t)&v14, 0, 0, 3u, (uint64_t)v13, *a2);
  buf[0] = 1;
  sub_1002DF194(&v20);
  *a3 = buf[0];
  sub_1002DF194(a3 + 8);
  sub_1002DF2E0(&v20);
  sub_1002DF2E0(v13);
  sub_1002CA540((wireless_diagnostics::google::protobuf::MessageLite *)&v14);
}

void sub_10031C700(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  uint64_t v27;

  sub_1002DF2E0(v27);
  sub_1002DF2E0(&a10);
  sub_1002CA540((wireless_diagnostics::google::protobuf::MessageLite *)&a27);
  _Unwind_Resume(a1);
}

void sub_10031C740(uint64_t a1@<X0>, char a2@<W1>, char a3@<W2>, unsigned int a4@<W3>, uint64_t a5@<X8>, double a6@<D0>)
{
  unsigned int v12;
  int v13;
  const char *v14;
  int v15;
  const char *v16;

  sub_1002BBFAC(a5);
  v12 = *(_DWORD *)(a1 + 8);
  if (!sub_1002BC6A4(v12))
  {
    v14 = "::CLMicroLocationProto::EventType_IsValid(value)";
    v15 = 19803;
    v16 = "set_eventtype";
    goto LABEL_6;
  }
  v13 = *(_DWORD *)(a5 + 128);
  *(_DWORD *)(a5 + 72) = v12;
  *(double *)(a5 + 8) = a6;
  *(_BYTE *)(a5 + 77) = a2;
  *(_DWORD *)(a5 + 128) = v13 | 0x2803;
  *(_BYTE *)(a5 + 76) = a3;
  if ((sub_1002BC674(a4) & 1) == 0)
  {
    v14 = "::CLMicroLocationProto::ConfidenceLevel_IsValid(value)";
    v15 = 20312;
    v16 = "set_confidencelevel";
LABEL_6:
    __assert_rtn(v16, "microlocation.pb.h", v15, v14);
  }
  *(_DWORD *)(a5 + 128) |= 0x4000u;
  *(_DWORD *)(a5 + 120) = a4;
  sub_100358274(a5, a1);
}

void sub_10031C824(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1002DF2E0(v1);
  _Unwind_Resume(a1);
}

void sub_10031C838(id a1)
{
  qword_1022A00F8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_10031C864(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _OWORD *v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  char v9;

  *(_QWORD *)a1 = off_10212F1D0;
  *(_QWORD *)(a1 + 8) = off_10212F2B8;
  *(_QWORD *)(a1 + 16) = off_10212F2E8;
  *(_QWORD *)(a1 + 24) = off_10212F320;
  *(_QWORD *)(a1 + 32) = off_10212F370;
  *(_QWORD *)(a1 + 40) = off_10212F3A8;
  *(_QWORD *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  v4 = a1 + 64;
  sub_10031F08C((_BYTE *)(a1 + 64), (uint64_t)&byte_102311440);
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 176) = 0;
  v5 = operator new(0x68uLL);
  *(_OWORD *)(a1 + 184) = 0u;
  *(_QWORD *)(a1 + 176) = (char *)v5 + 104;
  *v5 = xmmword_101B9B430;
  v5[1] = xmmword_101B9B440;
  v5[2] = xmmword_101B9B450;
  v5[3] = xmmword_101B9B460;
  v5[4] = xmmword_101B9B470;
  v5[5] = xmmword_101B9B480;
  *((_QWORD *)v5 + 12) = 13;
  *(_QWORD *)(a1 + 160) = v5;
  *(_QWORD *)(a1 + 168) = (char *)v5 + 104;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 209) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_QWORD *)(a1 + 264) = a2;
  v6 = 0;
  v7 = sub_10031CB34();
  sub_10031F30C((uint64_t)&v9, (uint64_t)&v8, a1 + 160, v4, &v7, (uint64_t)&v6, a1);
}

void sub_10031CA5C(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;

  v7 = *(_QWORD *)(v1 + 256);
  *(_QWORD *)(v1 + 256) = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  v8 = *(_QWORD *)(v1 + 248);
  *(_QWORD *)(v1 + 248) = 0;
  if (v8)
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
  v9 = *(_QWORD *)(v1 + 240);
  *(_QWORD *)(v1 + 240) = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  v10 = *v5;
  *v5 = 0;
  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
  sub_100261F44(v4);
  sub_100261F44(v3);
  v11 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 168) = v11;
    operator delete(v11);
  }
  if (*(_BYTE *)(v1 + 152) && *(char *)(v1 + 95) < 0)
    operator delete(*(void **)(v1 + 72));
  v12 = *(_QWORD *)(v1 + 48);
  *(_QWORD *)(v1 + 48) = 0;
  if (v12)
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
  _Unwind_Resume(a1);
}

uint64_t sub_10031CB34()
{
  CFStringRef v0;
  int v1;
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unsigned int v7;
  uint64_t v8;
  std::__shared_weak_count *v9;

  sub_1001E4804(&v8);
  v7 = 0;
  v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsLocalizingDurationMinimum", 0x8000100u, kCFAllocatorNull);
  v1 = sub_1000B1180(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  v2 = v7;
  v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  if (v1)
    return v2;
  else
    return 1200;
}

void sub_10031CBF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  sub_100261F44((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10031CC10()
{
  CFStringRef v0;
  int v1;
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unsigned int v7;
  uint64_t v8;
  std::__shared_weak_count *v9;

  sub_1001E4804(&v8);
  v7 = 0;
  v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsRecordingDuration", 0x8000100u, kCFAllocatorNull);
  v1 = sub_1000B1180(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  v2 = v7;
  v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  if (v1)
    return v2;
  else
    return 3400;
}

void sub_10031CCD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  sub_100261F44((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10031CCF0(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t result;

  v3 = *a2;
  *a2 = 0;
  result = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 48) = v3;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t sub_10031CD18(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t result;

  v3 = *a2;
  *a2 = 0;
  result = *(_QWORD *)(a1 + 232);
  *(_QWORD *)(a1 + 232) = v3;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t sub_10031CD40(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t result;

  v3 = *a2;
  *a2 = 0;
  result = *(_QWORD *)(a1 + 240);
  *(_QWORD *)(a1 + 240) = v3;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t sub_10031CD68(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t result;

  v3 = *a2;
  *a2 = 0;
  result = *(_QWORD *)(a1 + 248);
  *(_QWORD *)(a1 + 248) = v3;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t sub_10031CD90(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t result;

  v3 = *a2;
  *a2 = 0;
  result = *(_QWORD *)(a1 + 256);
  *(_QWORD *)(a1 + 256) = v3;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_10031CDB8(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  CFStringRef v4;
  char v5;
  int v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  char v10;
  NSObject *v11;
  const char *v12;
  uint8_t *v13;
  NSObject *v14;
  const char *v15;
  uint8_t *v16;
  unsigned __int8 v17[16];
  uint8_t buf[8];
  std::__shared_weak_count *v19;

  *(_BYTE *)(a1 + 224) = *(_BYTE *)a2;
  *(_QWORD *)(a1 + 216) = *(_QWORD *)(a2 + 8);
  v3 = sub_10031D164(a1);
  (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 48) + 32))(*(_QWORD *)(a1 + 48), v3);
  sub_1001E4804(buf);
  v17[0] = 0;
  v4 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsScanWifiRSSIEnabled", 0x8000100u, kCFAllocatorNull);
  v5 = sub_1001E48E4(*(uint64_t *)buf, (uint64_t)v4, (BOOL *)v17);
  CFRelease(v4);
  v6 = v17[0];
  v7 = v19;
  if (v19)
  {
    p_shared_owners = (unint64_t *)&v19->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  if (v6)
    v10 = 0;
  else
    v10 = v5;
  if ((v10 & 1) != 0)
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212F4A8);
    v11 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "SensorsDriver, Not scanning Wifi RSSI because it's not enabled", buf, 2u);
    }
    if (sub_1001BFF7C(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212F4A8);
      *(_WORD *)v17 = 0;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 2, "SensorsDriver, Not scanning Wifi RSSI because it's not enabled", v17, 2);
      v13 = (uint8_t *)v12;
      sub_100512490("Generic", 1, 0, 2, "void CLMicroLocationSensorsDriver::requestWifiScan(const CLMicroLocationSensorsDriver::WifiScanRequestParams &)", "%s\n", v12);
      if (v13 != buf)
        free(v13);
    }
  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212F4A8);
    v14 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "SensorsDriver, wifi, start scanning", buf, 2u);
    }
    if (sub_1001BFF7C(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212F4A8);
      *(_WORD *)v17 = 0;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "SensorsDriver, wifi, start scanning", v17, 2);
      v16 = (uint8_t *)v15;
      sub_100512490("Generic", 1, 0, 2, "void CLMicroLocationSensorsDriver::requestWifiScan(const CLMicroLocationSensorsDriver::WifiScanRequestParams &)", "%s\n", v15);
      if (v16 != buf)
        free(v16);
    }
    (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 48) + 16))(*(_QWORD *)(a1 + 48), *(unsigned __int8 *)(a1 + 224));
  }
}

void sub_10031D144(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  sub_100261F44((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10031D164(uint64_t result)
{
  int v1;

  v1 = *(unsigned __int8 *)(result + 224);
  if (v1 == 1)
    return sub_10031CB34() + (uint64_t)(*(double *)(result + 216) * 1000.0);
  if (v1 == 2)
    return sub_10031CC10();
  if (!*(_BYTE *)(result + 224))
  {
    result = sub_1018F34F0(result);
    return sub_10031CB34() + (uint64_t)(*(double *)(result + 216) * 1000.0);
  }
  return result;
}

uint64_t sub_10031D1C4(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 264) + 16))(*(_QWORD *)(a1 + 264));
}

uint64_t sub_10031D1D4(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 264) + 128))(*(_QWORD *)(a1 + 264));
}

uint64_t sub_10031D1E4(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 264) + 136))(*(_QWORD *)(a1 + 264));
}

uint64_t sub_10031D1F4(uint64_t result)
{
  *(_QWORD *)(result + 216) = 0;
  *(_BYTE *)(result + 224) = 0;
  return result;
}

void sub_10031D200(uint64_t a1, double a2)
{
  uint64_t v2;
  int v5;
  uint64_t *v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  int v11;
  int v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  double v16;

  v5 = *(unsigned __int8 *)(a1 + 224);
  if (v5 == 1)
  {
    v6 = (uint64_t *)(a1 + 184);
  }
  else
  {
    if (v5 != 2)
    {
      if (*(_BYTE *)(a1 + 224))
      {
LABEL_8:
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212F4A8);
        v7 = qword_1022A00F8;
        if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
        {
          v11 = 68289282;
          v12 = 0;
          v13 = 2082;
          v14 = "";
          v15 = 2050;
          v16 = *(double *)&v2;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"SensorDriver, Wifi scan timer stopped but but scanned AP requirements not met, extend timer\", \"by duration (ms)\":%{public}lld}", (uint8_t *)&v11, 0x1Cu);
        }
        return;
      }
      sub_1018F3654();
      __break(1u);
    }
    v6 = (uint64_t *)(a1 + 200);
  }
  v2 = sub_1002771B0(*v6);
  if (v2)
    goto LABEL_8;
  v8 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 264) + 120))(*(_QWORD *)(a1 + 264));
  if (v8)
  {
    v9 = v8;
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212F4A8);
    v10 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      v11 = 68289282;
      v12 = 0;
      v13 = 2082;
      v14 = "";
      v15 = 2050;
      v16 = (double)v9;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"SensorsLogic, WiFi scan extention due to backlight on\", \"backlightOnExtention_s\":\"%{public}.09f\"}", (uint8_t *)&v11, 0x1Cu);
    }
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48), v9);
  }
  else
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 264) + 152))(*(_QWORD *)(a1 + 264));
    (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 48) + 24))(*(_QWORD *)(a1 + 48), *(unsigned __int8 *)(a1 + 224));
    (*(void (**)(_QWORD, double))(**(_QWORD **)(a1 + 264) + 24))(*(_QWORD *)(a1 + 264), a2);
  }
}

uint64_t sub_10031D464(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  void **v3;
  void *__p[2];
  char v6;
  uint8_t buf[4];
  int v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  void **v12;

  if (*(_BYTE *)(a1 + 224))
  {
    v1 = a1;
    if (qword_1022A00F0 == -1)
      goto LABEL_3;
  }
  else
  {
    sub_1018F37C0(qword_1022A00F0 == -1);
    __break(1u);
  }
  dispatch_once(&qword_1022A00F0, &stru_10212F4A8);
LABEL_3:
  v2 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
  {
    sub_1002EC7C4(*(_BYTE *)(v1 + 224), __p);
    if (v6 >= 0)
      v3 = __p;
    else
      v3 = (void **)__p[0];
    *(_DWORD *)buf = 68289282;
    v8 = 0;
    v9 = 2082;
    v10 = "";
    v11 = 2082;
    v12 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"SensorsDriver, received cancel wifi scan\", \"scan activity\":%{public, location:escape_only}s}", buf, 0x1Cu);
    if (v6 < 0)
      operator delete(__p[0]);
  }
  return (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v1 + 48) + 24))(*(_QWORD *)(v1 + 48), *(unsigned __int8 *)(v1 + 224));
}

uint64_t sub_10031D5AC(uint64_t result)
{
  *(_BYTE *)(result + 56) = 1;
  return result;
}

uint64_t sub_10031D5B8(uint64_t a1, uint64_t a2)
{
  sub_10031F180(a1 + 64, a2);
  *(_BYTE *)(a1 + 56) = 1;
  return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 264) + 40))(*(_QWORD *)(a1 + 264), a2);
}

uint64_t sub_10031D5F8@<X0>(_QWORD *a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  result = (*(uint64_t (**)(_QWORD *))(*a1 + 64))(a1);
  v5 = a1[24];
  *a2 = a1[23];
  a2[1] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

uint64_t sub_10031D644@<X0>(_QWORD *a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  result = (*(uint64_t (**)(_QWORD *))(*a1 + 64))(a1);
  v5 = a1[26];
  *a2 = a1[25];
  a2[1] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

void sub_10031D690(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  double v6;
  int v7;
  uint64_t v8;
  int v9;
  double v10;
  const char *v11;
  uint8_t *v12;
  void *__p[3];
  _WORD v14[8];
  uint8_t buf[1640];

  if (*(_BYTE *)(a1 + 56))
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212F4A8);
    v2 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Updating localizing scan strategy", buf, 2u);
    }
    if (sub_1001BFF7C(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212F4A8);
      v14[0] = 0;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 2, "Updating localizing scan strategy", v14, 2);
      v12 = (uint8_t *)v11;
      sub_100512490("Generic", 1, 0, 2, "virtual void CLMicroLocationSensorsDriver::updateWifiScanStrategiesIfNecessary()", "%s\n", v11);
      if (v12 != buf)
        free(v12);
    }
    v3 = *(_QWORD *)(a1 + 184);
    memset(__p, 0, sizeof(__p));
    sub_10025EA00(__p, *(const void **)(a1 + 160), *(_QWORD *)(a1 + 168), (uint64_t)(*(_QWORD *)(a1 + 168) - *(_QWORD *)(a1 + 160)) >> 3);
    sub_10031D974(v3, __p);
  }
  v4 = *(_QWORD *)(a1 + 184);
  v5 = sub_10031CB34();
  v6 = *(double *)(a1 + 216);
  *(double *)(v4 + 192) = (v6 * 1000.0 + (double)v5) / 1000.0;
  sub_1002755D4();
  *(_DWORD *)(v4 + 184) = v7;
  *(double *)(v4 + 176) = v6 + sub_1002757EC();
  sub_100276D3C(v4);
  v8 = *(_QWORD *)(a1 + 200);
  *(double *)(v8 + 192) = (double)sub_10031CC10() / 1000.0;
  sub_100275B90();
  *(_DWORD *)(v8 + 184) = v9;
  sub_100275DA8();
  *(double *)(v8 + 176) = v10 + 0.0;
  sub_100276D3C(v8);
}

void sub_10031D940(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14)
{
  _QWORD *v14;

  if (__p)
  {
    *v14 = __p;
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10031D974(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  void *__p;
  void *v10;
  uint64_t v11;
  _QWORD v12[3];
  _QWORD *v13;

  v3 = *(_QWORD *)(a1 + 280);
  *(_QWORD *)(a1 + 280) = *a2;
  *a2 = v3;
  v4 = *(_QWORD *)(a1 + 288);
  *(_QWORD *)(a1 + 288) = a2[1];
  a2[1] = v4;
  v5 = *(_QWORD *)(a1 + 296);
  *(_QWORD *)(a1 + 296) = a2[2];
  a2[2] = v5;
  sub_10031FC4C((_QWORD *)(a1 + 216), (uint64_t)sub_100275450);
  v10 = 0;
  v11 = 0;
  __p = 0;
  sub_10025EA00(&__p, *(const void **)(a1 + 280), *(_QWORD *)(a1 + 288), (uint64_t)(*(_QWORD *)(a1 + 288) - *(_QWORD *)(a1 + 280)) >> 3);
  v6 = *(_QWORD *)(a1 + 240);
  if (!v6)
    sub_10025FD1C();
  (*(void (**)(_QWORD *__return_ptr, uint64_t, void **))(*(_QWORD *)v6 + 48))(v12, v6, &__p);
  sub_10027839C((_QWORD *)(a1 + 248), (uint64_t)v12);
  v7 = v13;
  if (v13 == v12)
  {
    v8 = 4;
    v7 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_7;
    v8 = 5;
  }
  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_7:
  if (__p)
  {
    v10 = __p;
    operator delete(__p);
  }
  sub_100275238();
  sub_1002756E4();
  operator new();
}

void sub_10031DBA0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21)
{
  if (a16 < 0)
    operator delete(__p);
  if (a17)
    operator delete(a17);
  operator delete();
}

void sub_10031DC24(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  void *__p;
  void *v10;
  uint64_t v11;
  _QWORD v12[3];
  _QWORD *v13;

  v3 = *(_QWORD *)(a1 + 280);
  *(_QWORD *)(a1 + 280) = *a2;
  *a2 = v3;
  v4 = *(_QWORD *)(a1 + 288);
  *(_QWORD *)(a1 + 288) = a2[1];
  a2[1] = v4;
  v5 = *(_QWORD *)(a1 + 296);
  *(_QWORD *)(a1 + 296) = a2[2];
  a2[2] = v5;
  sub_10031FC4C((_QWORD *)(a1 + 216), (uint64_t)sub_100275A0C);
  v10 = 0;
  v11 = 0;
  __p = 0;
  sub_10025EA00(&__p, *(const void **)(a1 + 280), *(_QWORD *)(a1 + 288), (uint64_t)(*(_QWORD *)(a1 + 288) - *(_QWORD *)(a1 + 280)) >> 3);
  v6 = *(_QWORD *)(a1 + 240);
  if (!v6)
    sub_10025FD1C();
  (*(void (**)(_QWORD *__return_ptr, uint64_t, void **))(*(_QWORD *)v6 + 48))(v12, v6, &__p);
  sub_10027839C((_QWORD *)(a1 + 248), (uint64_t)v12);
  v7 = v13;
  if (v13 == v12)
  {
    v8 = 4;
    v7 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_7;
    v8 = 5;
  }
  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_7:
  if (__p)
  {
    v10 = __p;
    operator delete(__p);
  }
  sub_1002757F4();
  sub_100275CA0();
  operator new();
}

void sub_10031DE50(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21)
{
  if (a16 < 0)
    operator delete(__p);
  if (a17)
    operator delete(a17);
  operator delete();
}

uint64_t sub_10031DED4(uint64_t result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *(_QWORD *)(result + 160);
  *(_QWORD *)(result + 160) = *a2;
  *a2 = v2;
  v3 = *(_QWORD *)(result + 168);
  *(_QWORD *)(result + 168) = a2[1];
  a2[1] = v3;
  v4 = *(_QWORD *)(result + 176);
  *(_QWORD *)(result + 176) = a2[2];
  a2[2] = v4;
  *(_BYTE *)(result + 56) = 1;
  return result;
}

uint64_t sub_10031DF10(uint64_t a1)
{
  uint64_t v2;

  v2 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 264) + 32))(*(_QWORD *)(a1 + 264));
  if (v2)
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48), v2);
  return v2;
}

uint64_t sub_10031DF5C(uint64_t a1)
{
  uint64_t v2;

  v2 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 256) + 32))(*(_QWORD *)(a1 + 256));
  if (v2)
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 40) + 40))(*(_QWORD *)(a1 + 40), v2);
  return v2;
}

uint64_t sub_10031DFA8(uint64_t a1)
{
  double Current;
  NSObject *v3;
  _DWORD v5[2];
  __int16 v6;
  const char *v7;
  __int16 v8;
  double v9;

  Current = j__CFAbsoluteTimeGetCurrent();
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212F4A8);
  v3 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
  {
    v5[0] = 68289282;
    v5[1] = 0;
    v6 = 2082;
    v7 = "";
    v8 = 2050;
    v9 = Current;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"CLMicroLocationSensorsDriver, stop wifi scan\", \"now\":\"%{public}.3f\"}", (uint8_t *)v5, 0x1Cu);
  }
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 264) + 152))(*(_QWORD *)(a1 + 264));
  (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 48) + 24))(*(_QWORD *)(a1 + 48), *(unsigned __int8 *)(a1 + 224));
  return (*(uint64_t (**)(_QWORD, double))(**(_QWORD **)(a1 + 264) + 24))(*(_QWORD *)(a1 + 264), Current);
}

uint64_t sub_10031E0D4(uint64_t a1)
{
  return sub_10031DFA8(a1 - 8);
}

uint64_t sub_10031E0DC(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 264) + 48))(*(_QWORD *)(a1 + 264));
}

uint64_t sub_10031E0EC(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 248) + 48))(*(_QWORD *)(a1 + 248));
}

uint64_t sub_10031E0FC(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 264) + 56))(*(_QWORD *)(a1 + 264));
}

uint64_t sub_10031E10C(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 248) + 56))(*(_QWORD *)(a1 + 248));
}

uint64_t sub_10031E11C(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  const char *v6;
  uint8_t *v7;
  _WORD v8[8];
  uint8_t buf[1640];

  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212F4A8);
  v4 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "SensorsDriver, ble, start session", buf, 2u);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212F4A8);
    v8[0] = 0;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "SensorsDriver, ble, start session", v8, 2);
    v7 = (uint8_t *)v6;
    sub_100512490("Generic", 1, 0, 2, "void CLMicroLocationSensorsDriver::startBleRssiSession(const CLMicroLocationUtils::BleScanConfiguration &)", "%s\n", v6);
    if (v7 != buf)
      free(v7);
  }
  if (!*(_BYTE *)(a2 + 9))
  {
    if (*(_BYTE *)(a1 + 224))
      sub_1018F3948();
    *(_BYTE *)(a1 + 224) = *(_BYTE *)(a2 + 8);
  }
  return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 232) + 16))(*(_QWORD *)(a1 + 232), a2);
}

uint64_t sub_10031E2E0(uint64_t a1)
{
  NSObject *v2;
  const char *v4;
  uint8_t *v5;
  _WORD v6[8];
  uint8_t buf[1640];

  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212F4A8);
  v2 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SensorsDriver, ble, stop session", buf, 2u);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212F4A8);
    v6[0] = 0;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "SensorsDriver, ble, stop session", v6, 2);
    v5 = (uint8_t *)v4;
    sub_100512490("Generic", 1, 0, 2, "void CLMicroLocationSensorsDriver::stopBleRssiSession()", "%s\n", v4);
    if (v5 != buf)
      free(v5);
  }
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 232) + 32))(*(_QWORD *)(a1 + 232));
}

uint64_t sub_10031E480(uint64_t a1)
{
  NSObject *v2;
  const char *v4;
  uint8_t *v5;
  _WORD v6[8];
  uint8_t buf[1640];

  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212F4A8);
  v2 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SensorsDriver, ble, request timeout", buf, 2u);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212F4A8);
    v6[0] = 0;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "SensorsDriver, ble, request timeout", v6, 2);
    v5 = (uint8_t *)v4;
    sub_100512490("Generic", 1, 0, 2, "virtual void CLMicroLocationSensorsDriver::onBLEScanRequestTimeout()", "%s\n", v4);
    if (v5 != buf)
      free(v5);
  }
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 264) + 64))(*(_QWORD *)(a1 + 264));
}

uint64_t sub_10031E620(uint64_t a1)
{
  return sub_10031E480(a1 - 16);
}

uint64_t sub_10031E628(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 264) + 72))(*(_QWORD *)(a1 + 264));
}

uint64_t sub_10031E638(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 240) + 72))(*(_QWORD *)(a1 + 240));
}

uint64_t sub_10031E648(uint64_t a1, uint64_t *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  _DWORD v8[2];
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  uint64_t v14;

  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212F4A8);
  v4 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    v5 = *a2;
    v6 = a2[1];
    v8[0] = 68289538;
    v8[1] = 0;
    v9 = 2082;
    v10 = "";
    v11 = 1026;
    v12 = v5;
    v13 = 2050;
    v14 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"SensorsDriver, uwb, set ranging rate\", \"rate\":%{public}d, \"duration\":\"%{public}f\"}", (uint8_t *)v8, 0x22u);
  }
  return (*(uint64_t (**)(_QWORD, uint64_t *))(**(_QWORD **)(a1 + 240) + 32))(*(_QWORD *)(a1 + 240), a2);
}

uint64_t sub_10031E75C(uint64_t a1)
{
  NSObject *v2;
  const char *v4;
  uint8_t *v5;
  _WORD v6[8];
  uint8_t buf[1640];

  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212F4A8);
  v2 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SensorsDriver, uwb, reset ranging rate", buf, 2u);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212F4A8);
    v6[0] = 0;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "SensorsDriver, uwb, reset ranging rate", v6, 2);
    v5 = (uint8_t *)v4;
    sub_100512490("Generic", 1, 0, 2, "void CLMicroLocationSensorsDriver::resetRangingRate()", "%s\n", v4);
    if (v5 != buf)
      free(v5);
  }
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 240) + 40))(*(_QWORD *)(a1 + 240));
}

uint64_t sub_10031E8FC(uint64_t a1)
{
  NSObject *v2;
  const char *v4;
  uint8_t *v5;
  _WORD v6[8];
  uint8_t buf[1640];

  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212F4A8);
  v2 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SensorsDriver, uwb, start session", buf, 2u);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212F4A8);
    v6[0] = 0;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "SensorsDriver, uwb, start session", v6, 2);
    v5 = (uint8_t *)v4;
    sub_100512490("Generic", 1, 0, 2, "void CLMicroLocationSensorsDriver::startRanging()", "%s\n", v4);
    if (v5 != buf)
      free(v5);
  }
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 240) + 16))(*(_QWORD *)(a1 + 240));
}

uint64_t sub_10031EA9C(uint64_t a1)
{
  NSObject *v2;
  const char *v4;
  uint8_t *v5;
  _WORD v6[8];
  uint8_t buf[1640];

  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212F4A8);
  v2 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SensorsDriver, uwb, stop session", buf, 2u);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212F4A8);
    v6[0] = 0;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "SensorsDriver, uwb, stop session", v6, 2);
    v5 = (uint8_t *)v4;
    sub_100512490("Generic", 1, 0, 2, "void CLMicroLocationSensorsDriver::stopRanging()", "%s\n", v4);
    if (v5 != buf)
      free(v5);
  }
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 240) + 24))(*(_QWORD *)(a1 + 240));
}

uint64_t sub_10031EC3C(uint64_t a1)
{
  CFAbsoluteTime Current;

  Current = j__CFAbsoluteTimeGetCurrent();
  return (*(uint64_t (**)(_QWORD, _QWORD, double))(**(_QWORD **)(a1 + 264) + 104))(*(_QWORD *)(a1 + 264), 0, Current);
}

uint64_t sub_10031EC6C(uint64_t a1)
{
  CFAbsoluteTime Current;

  Current = j__CFAbsoluteTimeGetCurrent();
  return (*(uint64_t (**)(_QWORD, _QWORD, double))(**(_QWORD **)(a1 + 240) + 104))(*(_QWORD *)(a1 + 240), 0, Current);
}

uint64_t sub_10031EC9C(uint64_t a1)
{
  CFAbsoluteTime Current;

  Current = j__CFAbsoluteTimeGetCurrent();
  return (*(uint64_t (**)(_QWORD, uint64_t, CFAbsoluteTime))(**(_QWORD **)(a1 + 264) + 104))(*(_QWORD *)(a1 + 264), 1, Current);
}

uint64_t sub_10031ECCC(uint64_t a1)
{
  CFAbsoluteTime Current;

  Current = j__CFAbsoluteTimeGetCurrent();
  return (*(uint64_t (**)(_QWORD, uint64_t, CFAbsoluteTime))(**(_QWORD **)(a1 + 240) + 104))(*(_QWORD *)(a1 + 240), 1, Current);
}

uint64_t sub_10031ECFC(uint64_t a1)
{
  CFAbsoluteTime Current;

  Current = j__CFAbsoluteTimeGetCurrent();
  return (*(uint64_t (**)(_QWORD, uint64_t, CFAbsoluteTime))(**(_QWORD **)(a1 + 264) + 104))(*(_QWORD *)(a1 + 264), 2, Current);
}

uint64_t sub_10031ED2C(uint64_t a1)
{
  CFAbsoluteTime Current;

  Current = j__CFAbsoluteTimeGetCurrent();
  return (*(uint64_t (**)(_QWORD, uint64_t, CFAbsoluteTime))(**(_QWORD **)(a1 + 240) + 104))(*(_QWORD *)(a1 + 240), 2, Current);
}

uint64_t sub_10031ED5C(uint64_t a1)
{
  CFAbsoluteTime Current;

  Current = j__CFAbsoluteTimeGetCurrent();
  return (*(uint64_t (**)(_QWORD, uint64_t, CFAbsoluteTime))(**(_QWORD **)(a1 + 264) + 104))(*(_QWORD *)(a1 + 264), 1, Current);
}

uint64_t sub_10031ED8C(uint64_t a1)
{
  CFAbsoluteTime Current;

  Current = j__CFAbsoluteTimeGetCurrent();
  return (*(uint64_t (**)(_QWORD, uint64_t, CFAbsoluteTime))(**(_QWORD **)(a1 + 240) + 104))(*(_QWORD *)(a1 + 240), 1, Current);
}

uint64_t sub_10031EDBC(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 264) + 112))(*(_QWORD *)(a1 + 264));
}

uint64_t sub_10031EDCC(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 240) + 112))(*(_QWORD *)(a1 + 240));
}

uint64_t sub_10031EDDC(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 264) + 80))(*(_QWORD *)(a1 + 264));
}

uint64_t sub_10031EDEC(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 232) + 80))(*(_QWORD *)(a1 + 232));
}

uint64_t sub_10031EDFC(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 264) + 88))(*(_QWORD *)(a1 + 264));
}

uint64_t sub_10031EE0C(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 232) + 88))(*(_QWORD *)(a1 + 232));
}

uint64_t sub_10031EE1C(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 264) + 80))(*(_QWORD *)(a1 + 264));
}

uint64_t sub_10031EE2C(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 224) + 80))(*(_QWORD *)(a1 + 224));
}

uint64_t sub_10031EE3C(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 264) + 96))(*(_QWORD *)(a1 + 264));
}

uint64_t sub_10031EE4C(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 224) + 96))(*(_QWORD *)(a1 + 224));
}

uint64_t sub_10031EE5C(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 264) + 144))(*(_QWORD *)(a1 + 264));
}

uint64_t sub_10031EE6C(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 232) + 144))(*(_QWORD *)(a1 + 232));
}

uint64_t sub_10031EE7C(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 224) + 144))(*(_QWORD *)(a1 + 224));
}

uint64_t sub_10031EE8C(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 248) + 16))(*(_QWORD *)(a1 + 248));
}

uint64_t sub_10031EE9C(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 248) + 24))(*(_QWORD *)(a1 + 248));
}

uint64_t sub_10031EEAC(uint64_t a1)
{
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 248) + 32))(*(_QWORD *)(a1 + 248));
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 256) + 32))(*(_QWORD *)(a1 + 256));
}

uint64_t sub_10031EEE4(uint64_t a1)
{
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 248) + 40))(*(_QWORD *)(a1 + 248));
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 256) + 40))(*(_QWORD *)(a1 + 256));
}

uint64_t sub_10031EF1C(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 256) + 24))(*(_QWORD *)(a1 + 256));
}

uint64_t sub_10031EF2C(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 256) + 16))(*(_QWORD *)(a1 + 256));
}

uint64_t sub_10031EF3C(uint64_t a1)
{
  int v1;
  uint64_t *v2;
  uint64_t v4;

  v1 = *(unsigned __int8 *)(a1 + 224);
  if (v1 == 1)
  {
    v2 = (uint64_t *)(a1 + 184);
    return sub_100026CC8(*v2);
  }
  if (v1 == 2)
  {
    v2 = (uint64_t *)(a1 + 200);
    return sub_100026CC8(*v2);
  }
  v4 = sub_1018F3AAC();
  return sub_10031EF74(v4);
}

void sub_10031EF78(uint64_t a1)
{
  sub_10031F214(a1);
  operator delete();
}

uint64_t sub_10031EF9C(uint64_t a1)
{
  return sub_10031F214(a1 - 8);
}

void sub_10031EFA4(uint64_t a1)
{
  sub_10031F214(a1 - 8);
  operator delete();
}

uint64_t sub_10031EFCC(uint64_t a1)
{
  return sub_10031F214(a1 - 16);
}

void sub_10031EFD4(uint64_t a1)
{
  sub_10031F214(a1 - 16);
  operator delete();
}

uint64_t sub_10031EFFC(uint64_t a1)
{
  return sub_10031F214(a1 - 24);
}

void sub_10031F004(uint64_t a1)
{
  sub_10031F214(a1 - 24);
  operator delete();
}

uint64_t sub_10031F02C(uint64_t a1)
{
  return sub_10031F214(a1 - 32);
}

void sub_10031F034(uint64_t a1)
{
  sub_10031F214(a1 - 32);
  operator delete();
}

uint64_t sub_10031F05C(uint64_t a1)
{
  return sub_10031F214(a1 - 40);
}

void sub_10031F064(uint64_t a1)
{
  sub_10031F214(a1 - 40);
  operator delete();
}

_BYTE *sub_10031F08C(_BYTE *a1, uint64_t a2)
{
  *a1 = 0;
  a1[88] = 0;
  if (*(_BYTE *)(a2 + 88))
  {
    sub_10031F0E8((uint64_t)a1, a2);
    a1[88] = 1;
  }
  return a1;
}

void sub_10031F0CC(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(_BYTE *)(v1 + 88))
    sub_1018F3C10(v1);
  _Unwind_Resume(exception_object);
}

uint64_t sub_10031F0E8(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  v4 = a1 + 8;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_100115CE4((_BYTE *)v4, *(void **)(a2 + 8), *(_QWORD *)(a2 + 16));
  }
  else
  {
    v5 = *(_OWORD *)(a2 + 8);
    *(_QWORD *)(v4 + 16) = *(_QWORD *)(a2 + 24);
    *(_OWORD *)v4 = v5;
  }
  v6 = *(_OWORD *)(a2 + 32);
  v7 = *(_OWORD *)(a2 + 48);
  v8 = *(_OWORD *)(a2 + 64);
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 48) = v7;
  *(_OWORD *)(a1 + 64) = v8;
  *(_OWORD *)(a1 + 32) = v6;
  return a1;
}

void sub_10031F154(id a1)
{
  qword_1022A00F8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_10031F180(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;

  if (*(unsigned __int8 *)(a1 + 88) == *(unsigned __int8 *)(a2 + 88))
  {
    if (*(_BYTE *)(a1 + 88))
    {
      *(_QWORD *)a1 = *(_QWORD *)a2;
      std::string::operator=((std::string *)(a1 + 8), (const std::string *)(a2 + 8));
      v5 = *(_OWORD *)(a2 + 48);
      v4 = *(_OWORD *)(a2 + 64);
      v6 = *(_OWORD *)(a2 + 32);
      *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
      *(_OWORD *)(a1 + 48) = v5;
      *(_OWORD *)(a1 + 64) = v4;
      *(_OWORD *)(a1 + 32) = v6;
    }
  }
  else if (*(_BYTE *)(a1 + 88))
  {
    if (*(char *)(a1 + 31) < 0)
      operator delete(*(void **)(a1 + 8));
    *(_BYTE *)(a1 + 88) = 0;
  }
  else
  {
    sub_10031F0E8(a1, a2);
    *(_BYTE *)(a1 + 88) = 1;
  }
}

uint64_t sub_10031F214(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;

  *(_QWORD *)a1 = off_10212F1D0;
  *(_QWORD *)(a1 + 8) = off_10212F2B8;
  *(_QWORD *)(a1 + 16) = off_10212F2E8;
  *(_QWORD *)(a1 + 24) = off_10212F320;
  *(_QWORD *)(a1 + 32) = off_10212F370;
  *(_QWORD *)(a1 + 40) = off_10212F3A8;
  v2 = *(_QWORD *)(a1 + 256);
  *(_QWORD *)(a1 + 256) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *(_QWORD *)(a1 + 248);
  *(_QWORD *)(a1 + 248) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = *(_QWORD *)(a1 + 240);
  *(_QWORD *)(a1 + 240) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  v5 = *(_QWORD *)(a1 + 232);
  *(_QWORD *)(a1 + 232) = 0;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  sub_100261F44(a1 + 200);
  sub_100261F44(a1 + 184);
  v6 = *(void **)(a1 + 160);
  if (v6)
  {
    *(_QWORD *)(a1 + 168) = v6;
    operator delete(v6);
  }
  if (*(_BYTE *)(a1 + 152) && *(char *)(a1 + 95) < 0)
    operator delete(*(void **)(a1 + 72));
  v7 = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 48) = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return a1;
}

void sub_10031F30C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7)
{
  _QWORD *v13;

  v13 = operator new(0x148uLL);
  sub_10031F39C(v13, a2, a3, a4, a5, a6, a7);
}

void sub_10031F388(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_10031F39C(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7)
{
  char v7;

  a1[2] = 0;
  *a1 = off_10212F4D8;
  a1[1] = 0;
  sub_10031F468((uint64_t)&v7, (uint64_t)(a1 + 3), a2, a3, a4, a5, a6, a7);
}

void sub_10031F3FC(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_10031F410(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10212F4D8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10031F424(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10212F4D8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete();
}

uint64_t sub_10031F458(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void sub_10031F468(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t a8)
{
  void *__p[3];

  memset(__p, 0, sizeof(__p));
  sub_10025EA00(__p, *(const void **)a4, *(_QWORD *)(a4 + 8), (uint64_t)(*(_QWORD *)(a4 + 8) - *(_QWORD *)a4) >> 3);
  sub_10031F510(a2, (uint64_t)__p, a5, *a6, a8 + 8);
}

void sub_10031F4F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_10031F510(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *__p[2];
  uint64_t v8;
  __int128 __src;
  const char *v10;
  uint64_t v11;

  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)a1 = off_10212A740;
  *(_QWORD *)(a1 + 8) = a5;
  *(_BYTE *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 240) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_BYTE *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 200) = 0;
  *(_QWORD *)(a1 + 208) = 0;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  v10 = "na";
  __src = xmmword_10212F518;
  sub_10031F73C((char *)(a1 + 24), (char *)&__src, (uint64_t)&v11, 1uLL);
  *(_OWORD *)__p = *(_OWORD *)a2;
  v8 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  sub_10031D974(a1, __p);
}

void sub_10031F664(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  uint64_t v10;
  uint64_t *v11;
  void **v12;
  _QWORD **v14;
  void *v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;

  if (__p)
    operator delete(__p);
  v14 = (_QWORD **)(v10 + 272);
  v15 = *(void **)(v10 + 280);
  if (v15)
  {
    *(_QWORD *)(v10 + 288) = v15;
    operator delete(v15);
  }
  v16 = *v14;
  if (*v14 == (_QWORD *)(v10 + 248))
  {
    v17 = 4;
    v16 = (_QWORD *)(v10 + 248);
  }
  else
  {
    if (!v16)
      goto LABEL_10;
    v17 = 5;
  }
  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_10:
  v18 = *(_QWORD **)(v10 + 240);
  if (v18 == (_QWORD *)(v10 + 216))
  {
    v19 = 4;
    v18 = (_QWORD *)(v10 + 216);
  }
  else
  {
    if (!v18)
    {
LABEL_15:
      if (*(_BYTE *)(v10 + 136) && *(char *)(v10 + 79) < 0)
        operator delete(*(void **)(v10 + 56));
      v20 = *v12;
      if (*v12)
      {
        *(_QWORD *)(v10 + 32) = v20;
        operator delete(v20);
      }
      v21 = *v11;
      *v11 = 0;
      if (v21)
        sub_1002773B4((uint64_t)v11, v21);
      _Unwind_Resume(exception_object);
    }
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
  goto LABEL_15;
}

char *sub_10031F73C(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  void **v13;
  char *v14;
  _BYTE *v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - *(_QWORD *)result) >> 3) < a4)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 > 0xAAAAAAAAAAAAAAALL)
      sub_100259694();
    v10 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 3);
    v11 = 2 * v10;
    if (2 * v10 <= a4)
      v11 = a4;
    if (v10 >= 0x555555555555555)
      v12 = 0xAAAAAAAAAAAAAAALL;
    else
      v12 = v11;
    result = sub_100259C18(v7, v12);
    v14 = (char *)v7[1];
    v13 = (void **)(v7 + 1);
    v9 = v14;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v13 = (void **)(result + 8);
  v15 = (_BYTE *)*((_QWORD *)result + 1);
  if (0xAAAAAAAAAAAAAAABLL * ((v15 - v9) >> 3) >= a4)
    goto LABEL_16;
  v16 = &__src[8 * ((v15 - v9) >> 3)];
  if (v15 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v15 - v9);
    v9 = (char *)*v13;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v13 = &v9[v17];
  return result;
}

void sub_10031F874(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7)
{
  _QWORD *v13;

  v13 = operator new(0x148uLL);
  sub_10031F904(v13, a2, a3, a4, a5, a6, a7);
}

void sub_10031F8F0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_10031F904(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7)
{
  char v7;

  a1[2] = 0;
  *a1 = off_10212F4D8;
  a1[1] = 0;
  sub_10031F978((uint64_t)&v7, (uint64_t)(a1 + 3), a2, a3, a4, a5, a6, a7);
}

void sub_10031F964(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_10031F978(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t a8)
{
  void *__p[3];

  memset(__p, 0, sizeof(__p));
  sub_10025EA00(__p, *(const void **)a4, *(_QWORD *)(a4 + 8), (uint64_t)(*(_QWORD *)(a4 + 8) - *(_QWORD *)a4) >> 3);
  sub_10031FA20(a2, (uint64_t)__p, a5, *a6, a8 + 8);
}

void sub_10031FA04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_10031FA20(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *__p[2];
  uint64_t v8;
  __int128 __src;
  const char *v10;
  uint64_t v11;

  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)a1 = off_10212A740;
  *(_QWORD *)(a1 + 8) = a5;
  *(_BYTE *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 240) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_BYTE *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 200) = 0;
  *(_QWORD *)(a1 + 208) = 0;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  v10 = "na";
  __src = xmmword_10212F518;
  sub_10031F73C((char *)(a1 + 24), (char *)&__src, (uint64_t)&v11, 1uLL);
  *(_OWORD *)__p = *(_OWORD *)a2;
  v8 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  sub_10031DC24(a1, __p);
}

void sub_10031FB74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  uint64_t v10;
  uint64_t *v11;
  void **v12;
  _QWORD **v14;
  void *v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;

  if (__p)
    operator delete(__p);
  v14 = (_QWORD **)(v10 + 272);
  v15 = *(void **)(v10 + 280);
  if (v15)
  {
    *(_QWORD *)(v10 + 288) = v15;
    operator delete(v15);
  }
  v16 = *v14;
  if (*v14 == (_QWORD *)(v10 + 248))
  {
    v17 = 4;
    v16 = (_QWORD *)(v10 + 248);
  }
  else
  {
    if (!v16)
      goto LABEL_10;
    v17 = 5;
  }
  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_10:
  v18 = *(_QWORD **)(v10 + 240);
  if (v18 == (_QWORD *)(v10 + 216))
  {
    v19 = 4;
    v18 = (_QWORD *)(v10 + 216);
  }
  else
  {
    if (!v18)
    {
LABEL_15:
      if (*(_BYTE *)(v10 + 136) && *(char *)(v10 + 79) < 0)
        operator delete(*(void **)(v10 + 56));
      v20 = *v12;
      if (*v12)
      {
        *(_QWORD *)(v10 + 32) = v20;
        operator delete(v20);
      }
      v21 = *v11;
      *v11 = 0;
      if (v21)
        sub_1002773B4((uint64_t)v11, v21);
      _Unwind_Resume(exception_object);
    }
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
  goto LABEL_15;
}

_QWORD *sub_10031FC4C(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD v6[3];
  _QWORD *v7;

  v6[0] = off_10212F540;
  v6[1] = a2;
  v7 = v6;
  sub_10031FE08(v6, a1);
  v3 = v7;
  if (v7 == v6)
  {
    v4 = 4;
    v3 = v6;
    goto LABEL_5;
  }
  if (v7)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

_QWORD *sub_10031FCF0(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_10212F540;
  result[1] = v3;
  return result;
}

uint64_t sub_10031FD28(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_10212F540;
  a2[1] = v2;
  return result;
}

void sub_10031FD48(uint64_t a1, uint64_t a2)
{
  sub_10031FD98((void (**)(void **))(a1 + 8), a2);
}

uint64_t sub_10031FD50(uint64_t a1, uint64_t a2)
{
  if (sub_100270DE8(a2, (uint64_t)&off_10212F5C0))
    return a1 + 8;
  else
    return 0;
}

_UNKNOWN **sub_10031FD8C()
{
  return &off_10212F5C0;
}

void sub_10031FD98(void (**a1)(void **), uint64_t a2)
{
  void (*v2)(void **);
  void *__p[2];
  uint64_t v4;

  v2 = *a1;
  *(_OWORD *)__p = *(_OWORD *)a2;
  v4 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  v2(__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_10031FDEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *sub_10031FE08(_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[3];

  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_10031FF70(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  sub_10024F88C(a1);
}

void sub_10031FF7C(_QWORD *a1@<X0>, char **a2@<X8>)
{
  char *v4;
  uint64_t v5;
  _QWORD *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  int v15;

  v4 = 0;
  v5 = 0;
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v6 = a2 + 2;
  do
  {
    if (((*a1 >> v5) & 1) != 0)
    {
      if ((unint64_t)v4 >= *v6)
      {
        v8 = *a2;
        v9 = (v4 - *a2) >> 2;
        v10 = v9 + 1;
        if ((unint64_t)(v9 + 1) >> 62)
          sub_100259694();
        v11 = *v6 - (_QWORD)v8;
        if (v11 >> 1 > v10)
          v10 = v11 >> 1;
        if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL)
          v12 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v12 = v10;
        if (v12)
        {
          v13 = (char *)sub_100260634((uint64_t)v6, v12);
          v8 = *a2;
          v4 = a2[1];
        }
        else
        {
          v13 = 0;
        }
        v14 = &v13[4 * v9];
        *(_DWORD *)v14 = v5;
        v7 = v14 + 4;
        while (v4 != v8)
        {
          v15 = *((_DWORD *)v4 - 1);
          v4 -= 4;
          *((_DWORD *)v14 - 1) = v15;
          v14 -= 4;
        }
        *a2 = v14;
        a2[1] = v7;
        a2[2] = &v13[4 * v12];
        if (v8)
          operator delete(v8);
      }
      else
      {
        *(_DWORD *)v4 = v5;
        v7 = v4 + 4;
      }
      a2[1] = v7;
      v4 = v7;
    }
    ++v5;
  }
  while (v5 != 56);
}

void sub_100320094(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1003200B4(unsigned int a1@<W0>, char **a2@<X8>)
{
  CFStringRef v4;
  _BOOL4 v5;
  _QWORD *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  void *__p;
  _BYTE *v11;
  char *v12;
  _BYTE v13[16];
  _QWORD v14[2];
  uint64_t v15;
  std::__shared_weak_count *v16;

  sub_1001E4804(&v15);
  sub_100119F3C(v14);
  v4 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsRecordingEventsForModel", 0x8000100u, kCFAllocatorNull);
  v5 = sub_100219D08(v15, (uint64_t)v4, v14);
  CFRelease(v4);
  if (v5)
  {
    sub_100525028(v13);
    sub_100320944((uint64_t)v13, &__p);
  }
  v6 = operator new(0x18uLL);
  v12 = (char *)(v6 + 3);
  v6[2] = 30388;
  *(_OWORD *)v6 = xmmword_101B9C850;
  __p = v6;
  v11 = v6 + 3;
  sub_10011A5A8(v14);
  v7 = v16;
  if (v16)
  {
    p_shared_owners = (unint64_t *)&v16->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  if (a1 >= (unint64_t)((v11 - (_BYTE *)__p) >> 3))
  {
    sub_1018F3C24();
    abort_report_np("%s:%d: assertion failure in %s", "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationSettings.mm", 68, "getRecordingEventsForModelType");
    __break(1u);
  }
  else
  {
    v15 = *((_QWORD *)__p + a1);
    sub_10031FF7C(&v15, a2);
    if (__p)
    {
      v11 = __p;
      operator delete(__p);
    }
  }
}

void sub_100320240(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, char a15, uint64_t a16, char a17)
{
  uint64_t v17;

  sub_10011A5A8(&a15);
  sub_10011A5A8(&a17);
  sub_100261F44(v17 - 48);
  _Unwind_Resume(a1);
}

uint64_t sub_100320298()
{
  CFStringRef v0;
  int v1;
  _BOOL4 v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v10;
  uint64_t v11;
  std::__shared_weak_count *v12;

  sub_1001E4804(&v11);
  v10 = 0;
  v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsUseAlternativeSetting", 0x8000100u, kCFAllocatorNull);
  v1 = sub_1001E48E4(v11, (uint64_t)v0, &v10);
  CFRelease(v0);
  v2 = v10;
  v3 = v12;
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  if (v2)
    v6 = v1;
  else
    v6 = 0;
  if (v6 != 1)
    return 1;
  LODWORD(v11) = 0;
  v7 = sub_1001FD94C();
  v8 = 1;
  if ((sub_1001C1194(v7, (uint64_t)CFSTR("kMicroLocationConfigurationSelect"), &v11) & 1) == 0)
  {
    if (arc4random_uniform(2u))
      v8 = 2;
    else
      v8 = 1;
    LODWORD(v11) = v8;
    sub_1003203F4(v8);
  }
  return v8;
}

void sub_1003203AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  unint64_t *p_shared_owners;
  unint64_t v14;

  if (a12)
  {
    p_shared_owners = (unint64_t *)&a12->__shared_owners_;
    do
      v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))a12->__on_zero_shared)(a12);
      std::__shared_weak_count::__release_weak(a12);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003203F4(int a1)
{
  uint64_t v2;
  uint64_t v3;
  int v5;

  v2 = sub_1001FD94C();
  v5 = a1;
  sub_10011B5B8(v2, CFSTR("kMicroLocationConfigurationSelect"), &v5);
  v3 = sub_1001FD94C();
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 944))(v3);
}

void sub_100320440(int a1@<W0>, _QWORD *a2@<X8>)
{
  CFStringRef v3;
  _BOOL4 v4;
  CFStringRef v5;
  _BOOL4 v6;
  CFStringRef v7;
  _BOOL4 v8;
  CFStringRef v9;
  _BOOL4 v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  unint64_t *v14;
  unint64_t *v15;
  unint64_t *v16;
  void *__p[2];
  char v18;
  _QWORD v19[2];
  uint64_t v20;
  std::__shared_weak_count *v21;

  switch(a1)
  {
    case 0:
    case 1:
      sub_1015A2E04(__p, "");
      sub_10038628C(a2, __p);
      if (v18 < 0)
        operator delete(__p[0]);
      return;
    case 2:
      sub_1001E4804(&v20);
      sub_100119F3C(v19);
      v3 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsCombinedEuclideanJaccardParams", 0x8000100u, kCFAllocatorNull);
      v4 = sub_100219D08(v20, (uint64_t)v3, v19);
      CFRelease(v3);
      if (v4)
      {
        sub_100525028(__p);
        sub_100524E68(a2, (uint64_t)__p);
        *a2 = &off_102131AB0;
        sub_10011A5A8(__p);
      }
      else
      {
        sub_1015A2E04(__p, "{\"jaccard_threshold\" : 0.75, \"jaccard_scale_factor\" : 20.0}");
        sub_10038628C(a2, __p);
        if (v18 < 0)
          operator delete(__p[0]);
      }
      sub_10011A5A8(v19);
      v11 = v21;
      if (!v21)
        return;
      p_shared_owners = (unint64_t *)&v21->__shared_owners_;
      do
        v13 = __ldaxr(p_shared_owners);
      while (__stlxr(v13 - 1, p_shared_owners));
      break;
    case 3:
      sub_1001E4804(&v20);
      sub_100119F3C(v19);
      v5 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsTanimotoBaseParams", 0x8000100u, kCFAllocatorNull);
      v6 = sub_100219D08(v20, (uint64_t)v5, v19);
      CFRelease(v5);
      if (v6)
      {
        sub_100525028(__p);
        sub_100524E68(a2, (uint64_t)__p);
        *a2 = &off_102131AB0;
        sub_10011A5A8(__p);
      }
      else
      {
        sub_1015A2E04(__p, "{}");
        sub_10038628C(a2, __p);
        if (v18 < 0)
          operator delete(__p[0]);
      }
      sub_10011A5A8(v19);
      v11 = v21;
      if (!v21)
        return;
      v14 = (unint64_t *)&v21->__shared_owners_;
      do
        v13 = __ldaxr(v14);
      while (__stlxr(v13 - 1, v14));
      break;
    case 4:
      sub_1001E4804(&v20);
      sub_100119F3C(v19);
      v7 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsWeightedEuclideanJaccardParams", 0x8000100u, kCFAllocatorNull);
      v8 = sub_100219D08(v20, (uint64_t)v7, v19);
      CFRelease(v7);
      if (v8)
      {
        sub_100525028(__p);
        sub_100524E68(a2, (uint64_t)__p);
        *a2 = &off_102131AB0;
        sub_10011A5A8(__p);
      }
      else
      {
        sub_1015A2E04(__p, "{\"jaccard_scale_factor\":1.0,\"e2j_kernel_thr\":0.5,\"per_source_params\": {\"value_scale_factor\" :{\"wifi\":0.05,\"ble\":0.025,\"uwb\":0.15}, \"euclidean_weight\":{\"wifi\":3.0,\"ble\":3.0,\"uwb\":50.0}, \"jaccard_pos_weight\":{\"wifi\":2.0,\"ble\":2.0,\"uwb\":2.0},\"jaccard_neg_weight\":{\"wifi\":1.0,\"ble\":5.0,\"uwb\":10.0},\"onesided_jaccard\":{\"wifi\":true,\"ble\":false,\"uwb\":false}}}");
        sub_10038628C(a2, __p);
        if (v18 < 0)
          operator delete(__p[0]);
      }
      sub_10011A5A8(v19);
      v11 = v21;
      if (!v21)
        return;
      v15 = (unint64_t *)&v21->__shared_owners_;
      do
        v13 = __ldaxr(v15);
      while (__stlxr(v13 - 1, v15));
      break;
    case 5:
      sub_1001E4804(&v20);
      sub_100119F3C(v19);
      v9 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsWeightedEuclideanJaccardTwoSidedParams", 0x8000100u, kCFAllocatorNull);
      v10 = sub_100219D08(v20, (uint64_t)v9, v19);
      CFRelease(v9);
      if (v10)
      {
        sub_100525028(__p);
        sub_100524E68(a2, (uint64_t)__p);
        *a2 = &off_102131AB0;
        sub_10011A5A8(__p);
      }
      else
      {
        sub_1015A2E04(__p, "{\"jaccard_scale_factor\":1.0,\"e2j_kernel_thr\":0.5,\"per_source_params\": {\"value_scale_factor\" :{\"wifi\":0.05,\"ble\":0.025,\"uwb\":0.15}, \"euclidean_weight\":{\"wifi\":3.0,\"ble\":3.0,\"uwb\":50.0}, \"jaccard_pos_weight\":{\"wifi\":2.0,\"ble\":2.0,\"uwb\":2.0},\"jaccard_neg_weight\":{\"wifi\":1.0,\"ble\":5.0,\"uwb\":10.0},\"onesided_jaccard\":{\"wifi\":false,\"ble\":false,\"uwb\":false}}}");
        sub_10038628C(a2, __p);
        if (v18 < 0)
          operator delete(__p[0]);
      }
      sub_10011A5A8(v19);
      v11 = v21;
      if (!v21)
        return;
      v16 = (unint64_t *)&v21->__shared_owners_;
      do
        v13 = __ldaxr(v16);
      while (__stlxr(v13 - 1, v16));
      break;
    default:
      sub_1018F3DDC();
  }
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
}

void sub_100320944(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  sub_100320A80((uint64_t)a2, 4uLL);
  v3 = 0;
  v4 = 0;
  v5 = 0;
  sub_100525A8C(a1);
}

void sub_100320A40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, void **a16)
{
  uint64_t v16;
  void *v18;

  a16 = (void **)&a13;
  sub_100259608(&a16);
  v18 = *(void **)v16;
  if (*(_QWORD *)v16)
  {
    *(_QWORD *)(v16 + 8) = v18;
    operator delete(v18);
  }
  _Unwind_Resume(a1);
}

void sub_100320A80(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 8 * a2;
  }
  else
  {
    sub_100320AB0((char **)a1, a2 - v2);
  }
}

void sub_100320AB0(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = *a1;
    v9 = v7 - *a1;
    v10 = a2 + (v9 >> 3);
    if (v10 >> 61)
      sub_100259694();
    v11 = v9 >> 3;
    v12 = v5 - v8;
    if (v12 >> 2 > v10)
      v10 = v12 >> 2;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
      v13 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v13 = v10;
    if (v13)
    {
      v14 = (char *)sub_10025E6A0(v4, v13);
      v8 = *a1;
      v7 = a1[1];
    }
    else
    {
      v14 = 0;
    }
    v15 = &v14[8 * v11];
    v16 = &v14[8 * v13];
    bzero(v15, 8 * a2);
    v17 = &v15[8 * a2];
    if (v7 != v8)
    {
      do
      {
        v18 = *((_QWORD *)v7 - 1);
        v7 -= 8;
        *((_QWORD *)v15 - 1) = v18;
        v15 -= 8;
      }
      while (v7 != v8);
      v8 = *a1;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
      operator delete(v8);
  }
}

void sub_100320BC0(id a1)
{
  qword_1022A00F8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_100320C34(uint64_t a1@<X8>)
{
  unsigned __int8 v2;

  v2 = atomic_load((unsigned __int8 *)&qword_1022A07B0);
  if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_1022A07B0))
  {
    sub_100324AB0((std::string *)&xmmword_1022A0798);
    __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_1022A0798, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_1022A07B0);
  }
  if (byte_1022A07AF < 0)
  {
    sub_100115CE4((_BYTE *)a1, (void *)xmmword_1022A0798, *((unint64_t *)&xmmword_1022A0798 + 1));
  }
  else
  {
    *(_OWORD *)a1 = xmmword_1022A0798;
    *(_QWORD *)(a1 + 16) = unk_1022A07A8;
  }
}

void sub_100320CE4(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_1022A07B0);
  _Unwind_Resume(a1);
}

void sub_100320CFC(uint64_t a1@<X8>)
{
  unsigned __int8 v2;

  v2 = atomic_load((unsigned __int8 *)&qword_1022A07D0);
  if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_1022A07D0))
  {
    sub_1002A7B64((std::string *)&xmmword_1022A07B8);
    __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_1022A07B8, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_1022A07D0);
  }
  if (byte_1022A07CF < 0)
  {
    sub_100115CE4((_BYTE *)a1, (void *)xmmword_1022A07B8, *((unint64_t *)&xmmword_1022A07B8 + 1));
  }
  else
  {
    *(_OWORD *)a1 = xmmword_1022A07B8;
    *(_QWORD *)(a1 + 16) = unk_1022A07C8;
  }
}

void sub_100320DAC(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_1022A07D0);
  _Unwind_Resume(a1);
}

uint64_t sub_100320DC4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, double a7)
{
  int v9;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a3;
  *(double *)(a1 + 16) = a7;
  *(_QWORD *)(a1 + 24) = a4;
  sub_1002C0A54(a1 + 32, a5);
  if ((a6 & 0xFF00000000) != 0)
    v9 = a6;
  else
    v9 = 0;
  *(_DWORD *)(a1 + 112) = v9;
  return a1;
}

void sub_100320E0C(uint64_t a1)
{
  BOOL v2;
  BOOL v3;
  NSObject *v4;
  uint8_t *v5;
  double v6;
  NSObject *v7;
  uint8_t *v8;
  NSObject *v9;
  double v10;
  uint8_t *v11;
  __int128 v12;
  int v13;
  const char *v14;
  uint8_t buf[4];
  const char *v16;

  v2 = sub_1000CC4F4(*(_QWORD *)a1);
  *(_BYTE *)(a1 + 8) = v2;
  if (v2)
  {
    v12 = off_10212F678;
    sub_100634364(*(_QWORD *)a1, "MicroLocationMeasurements", (const char **)&off_10212F6A8, (const std::string::value_type **)&v12, 0);
    v3 = sub_100635B3C(*(_QWORD *)a1, "MicroLocationMeasurements");
    *(_BYTE *)(a1 + 8) = v3;
    if (v3)
    {
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212F688);
      v4 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "MicroLocationMeasurements";
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "Sucessfully created table if necessary: %{public}s", buf, 0xCu);
      }
      if (sub_1001BFF7C(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212F688);
        v13 = 136446210;
        v14 = "MicroLocationMeasurements";
        v6 = _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 2, "Sucessfully created table if necessary: %{public}s", &v13, 12, (_QWORD)v12);
LABEL_19:
        v8 = v5;
        sub_100512490("Generic", 1, 0, 2, "void CLMicroLocationMeasurementTable::initTable()", "%s\n", v6);
LABEL_29:
        if (v8 != buf)
          free(v8);
      }
    }
    else
    {
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212F688);
      v9 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "MicroLocationMeasurements";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Failed to create table: %{public}s", buf, 0xCu);
      }
      if (sub_1001BFF7C(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_10212F688);
        v13 = 136446210;
        v14 = "MicroLocationMeasurements";
        v10 = _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 16, "Failed to create table: %{public}s", &v13, 12);
        v8 = v11;
        sub_100512490("Generic", 1, 0, 0, "void CLMicroLocationMeasurementTable::initTable()", "%s\n", v10);
        goto LABEL_29;
      }
    }
  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212F688);
    v7 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "Database is not connected so we can't intialize our table", buf, 2u);
    }
    if (sub_1001BFF7C(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_10212F688);
      LOWORD(v12) = 0;
      v6 = _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 2, "Database is not connected so we can't intialize our table", &v12, 2, (_QWORD)v12);
      goto LABEL_19;
    }
  }
}

uint64_t sub_100321208(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = a2;
  *(_BYTE *)(a1 + 8) = 0;
  sub_100320E0C(a1);
  return a1;
}

uint64_t sub_100321234(uint64_t a1)
{
  uint64_t v1;
  char *v2;
  NSObject *v3;
  const char *v5;
  uint8_t *v6;
  void *v7;
  uint8_t buf[8];

  if (*(_BYTE *)(a1 + 8))
  {
    v1 = *(_QWORD *)a1;
    if (byte_102301167 >= 0)
      v2 = (char *)&xmmword_102301150;
    else
      v2 = (char *)xmmword_102301150;
    sub_1000CDA68(v1, v2);
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212F688);
  v3 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#Warning Table is not valid so we can't insert or replace", buf, 2u);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212F688);
    LOWORD(v7) = 0;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#Warning Table is not valid so we can't insert or replace", &v7, 2);
    v6 = (uint8_t *)v5;
    sub_100512490("Generic", 1, 0, 2, "BOOL CLMicroLocationMeasurementTable::insertOrReplace(const std::vector<Entry> &)", "%s\n", v5);
    if (v6 != buf)
      free(v6);
  }
  return 0;
}

void sub_100321898(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,std::bad_cast a33)
{
  if (a23 < 0)
    operator delete(__p);
  if (a29 < 0)
    operator delete(a24);
  if (a30)
    (*(void (**)(uint64_t))(*(_QWORD *)a30 + 8))(a30);
  _Unwind_Resume(exception_object);
}

void sub_100321914(uint64_t a1, uint64_t a2, unsigned int a3)
{
  std::string *v6;
  __int128 v7;
  void **v8;
  std::string::size_type v9;
  std::string *v10;
  __int128 v11;
  std::string *v12;
  __int128 v13;
  std::string *v14;
  __int128 v15;
  std::string *v16;
  __int128 v17;
  int v18;
  const std::string::value_type *v19;
  std::string::size_type v20;
  std::string *v21;
  __int128 v22;
  std::string *v23;
  __int128 v24;
  std::string *v25;
  __int128 v26;
  std::string *v27;
  __int128 v28;
  std::string *v29;
  __int128 v30;
  std::string *v31;
  std::string::size_type size;
  std::string *v33;
  __int128 v34;
  std::string *v35;
  __int128 v36;
  std::string *v37;
  __int128 v38;
  char *v39;
  std::string v40;
  void *__p[2];
  unsigned __int8 v42;
  std::string::value_type __s[23];
  char v44;
  std::string v45;
  std::string v46;
  std::string v47;
  std::string v48;
  std::string v49;
  std::string v50;
  std::string v51;
  std::string v52;
  std::string v53;
  std::string v54;
  std::string v55;
  void *v56[2];
  int64_t v57;
  std::string v58;
  std::string v59;

  *((_BYTE *)&v45.__r_.__value_.__s + 23) = 14;
  strcpy((char *)&v45, "SELECT * FROM ");
  v44 = 8;
  strcpy(__s, "(SELECT ");
  v6 = std::string::append(&v45, __s, 8uLL);
  v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v46.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v46.__r_.__value_.__l.__data_ = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  sub_100320C34((uint64_t)__p);
  if ((v42 & 0x80u) == 0)
    v8 = __p;
  else
    v8 = (void **)__p[0];
  if ((v42 & 0x80u) == 0)
    v9 = v42;
  else
    v9 = (std::string::size_type)__p[1];
  v10 = std::string::append(&v46, (const std::string::value_type *)v8, v9);
  v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  v47.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v47.__r_.__value_.__l.__data_ = v11;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  v12 = std::string::append(&v47, " FROM ");
  v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  v48.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v48.__r_.__value_.__l.__data_ = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  v14 = std::string::append(&v48, "MicroLocationMeasurements");
  v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v49.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v49.__r_.__value_.__l.__data_ = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  v16 = std::string::append(&v49, " ");
  v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  v50.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v50.__r_.__value_.__l.__data_ = v17;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  v18 = *(char *)(a2 + 23);
  if (v18 >= 0)
    v19 = (const std::string::value_type *)a2;
  else
    v19 = *(const std::string::value_type **)a2;
  if (v18 >= 0)
    v20 = *(unsigned __int8 *)(a2 + 23);
  else
    v20 = *(_QWORD *)(a2 + 8);
  v21 = std::string::append(&v50, v19, v20);
  v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
  v51.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v51.__r_.__value_.__l.__data_ = v22;
  v21->__r_.__value_.__l.__size_ = 0;
  v21->__r_.__value_.__r.__words[2] = 0;
  v21->__r_.__value_.__r.__words[0] = 0;
  v23 = std::string::append(&v51, " ");
  v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
  v52.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v24;
  v23->__r_.__value_.__l.__size_ = 0;
  v23->__r_.__value_.__r.__words[2] = 0;
  v23->__r_.__value_.__r.__words[0] = 0;
  v25 = std::string::append(&v52, " ORDER BY ");
  v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
  v53.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v26;
  v25->__r_.__value_.__l.__size_ = 0;
  v25->__r_.__value_.__r.__words[2] = 0;
  v25->__r_.__value_.__r.__words[0] = 0;
  v27 = std::string::append(&v53, "ScanCFTimestamp");
  v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
  v54.__r_.__value_.__r.__words[2] = v27->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v54.__r_.__value_.__l.__data_ = v28;
  v27->__r_.__value_.__l.__size_ = 0;
  v27->__r_.__value_.__r.__words[2] = 0;
  v27->__r_.__value_.__r.__words[0] = 0;
  v29 = std::string::append(&v54, " DESC LIMIT ");
  v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
  v59.__r_.__value_.__r.__words[2] = v29->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v59.__r_.__value_.__l.__data_ = v30;
  v29->__r_.__value_.__l.__size_ = 0;
  v29->__r_.__value_.__r.__words[2] = 0;
  v29->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v40, a3);
  if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v31 = &v40;
  else
    v31 = (std::string *)v40.__r_.__value_.__r.__words[0];
  if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v40.__r_.__value_.__r.__words[2]);
  else
    size = v40.__r_.__value_.__l.__size_;
  v33 = std::string::append(&v59, (const std::string::value_type *)v31, size);
  v34 = *(_OWORD *)&v33->__r_.__value_.__l.__data_;
  v55.__r_.__value_.__r.__words[2] = v33->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v55.__r_.__value_.__l.__data_ = v34;
  v33->__r_.__value_.__l.__size_ = 0;
  v33->__r_.__value_.__r.__words[2] = 0;
  v33->__r_.__value_.__r.__words[0] = 0;
  v35 = std::string::append(&v55, ") ORDER BY ");
  v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
  v58.__r_.__value_.__r.__words[2] = v35->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v58.__r_.__value_.__l.__data_ = v36;
  v35->__r_.__value_.__l.__size_ = 0;
  v35->__r_.__value_.__r.__words[2] = 0;
  v35->__r_.__value_.__r.__words[0] = 0;
  v37 = std::string::append(&v58, "ScanCFTimestamp");
  v38 = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
  v57 = v37->__r_.__value_.__r.__words[2];
  *(_OWORD *)v56 = v38;
  v37->__r_.__value_.__l.__size_ = 0;
  v37->__r_.__value_.__r.__words[2] = 0;
  v37->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v58.__r_.__value_.__l.__data_);
  if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v55.__r_.__value_.__l.__data_);
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v40.__r_.__value_.__l.__data_);
  if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v59.__r_.__value_.__l.__data_);
  if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v54.__r_.__value_.__l.__data_);
  if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v53.__r_.__value_.__l.__data_);
  if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v52.__r_.__value_.__l.__data_);
  if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v51.__r_.__value_.__l.__data_);
  if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v50.__r_.__value_.__l.__data_);
  if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v49.__r_.__value_.__l.__data_);
  if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v48.__r_.__value_.__l.__data_);
  if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v47.__r_.__value_.__l.__data_);
  if ((char)v42 < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v46.__r_.__value_.__l.__data_);
  if (v44 < 0)
    operator delete(*(void **)__s);
  if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v45.__r_.__value_.__l.__data_);
  if (v57 >= 0)
    v39 = (char *)v56;
  else
    v39 = (char *)v56[0];
  sub_1000CDA68(a1, v39);
}

void sub_100321E84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55,uint64_t a56,uint64_t a57,uint64_t a58,void *a59,uint64_t a60,uint64_t a61,uint64_t a62,void *__p)
{
  char a68;
  void **buf;
  uint64_t v70;

  buf = &a59;
  sub_100296984(&buf);
  if (v70)
    (*(void (**)(uint64_t))(*(_QWORD *)v70 + 8))(v70);
  if (a68 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void sub_100322078()
{
  JUMPOUT(0x100322080);
}

void sub_100322224()
{
  __cxa_end_catch();
  JUMPOUT(0x10032203CLL);
}

void sub_100322238(void *a1, int a2)
{
  if (a2)
    sub_10024F88C(a1);
  JUMPOUT(0x100322070);
}

void sub_100322248(uint64_t a1@<X0>, _BYTE *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unsigned int a5@<W4>, _QWORD *a6@<X8>)
{
  std::string *v12;
  __int128 v13;
  std::string *v14;
  __int128 v15;
  std::string *v16;
  __int128 v17;
  std::string *v18;
  __int128 v19;
  std::string *v20;
  __int128 v21;
  std::string *v22;
  __int128 v23;
  std::string *v24;
  __int128 v25;
  std::string *v26;
  __int128 v27;
  std::string *v28;
  __int128 v29;
  std::string *v30;
  std::string::size_type size;
  std::string *v32;
  __int128 v33;
  std::string *v34;
  __int128 v35;
  std::string *v36;
  __int128 v37;
  std::string *v38;
  __int128 v39;
  std::string *v40;
  __int128 v41;
  std::string *v42;
  __int128 v43;
  std::string *v44;
  __int128 v45;
  std::string *v46;
  __int128 v47;
  int v48;
  const std::string::value_type *v49;
  std::string::size_type v50;
  std::string *v51;
  __int128 v52;
  std::string *v53;
  __int128 v54;
  std::string *v55;
  __int128 v56;
  std::string *v57;
  __int128 v58;
  int v59;
  const std::string::value_type *v60;
  std::string::size_type v61;
  std::string *v62;
  __int128 v63;
  std::string *v64;
  __int128 v65;
  void **v66;
  std::string::size_type v67;
  std::string *v68;
  __int128 v69;
  std::string *v70;
  __int128 v71;
  NSObject *v72;
  const char *v73;
  uint8_t *v74;
  void *v75[2];
  char v76;
  void *__p[2];
  unsigned __int8 v78;
  std::string v79;
  std::string v80;
  std::string v81;
  std::string v82;
  std::string v83;
  std::string v84;
  std::string v85;
  std::string v86;
  std::string v87;
  std::string v88;
  std::string v89;
  std::string v90;
  std::string v91;
  std::string v92;
  std::string v93;
  std::string v94;
  std::string v95;
  std::string v96;
  std::string v97;
  std::string v98;
  std::string v99;
  std::string v100;
  std::string v101;
  std::string v102;
  std::string v103;
  std::string v104;
  uint8_t buf[16];
  std::string::size_type v106;

  if (*(_BYTE *)(a1 + 8))
  {
    *((_BYTE *)&v80.__r_.__value_.__s + 23) = 7;
    strcpy((char *)&v80, " WHERE ");
    v12 = std::string::append(&v80, "RecordingUUID");
    v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v81.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v81.__r_.__value_.__l.__data_ = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    v14 = std::string::append(&v81, " in ");
    v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    v82.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v82.__r_.__value_.__l.__data_ = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    v16 = std::string::append(&v82, "(SELECT ");
    v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v83.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v83.__r_.__value_.__l.__data_ = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    v18 = std::string::append(&v83, "RecordingUUID");
    v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v84.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v84.__r_.__value_.__l.__data_ = v19;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    v20 = std::string::append(&v84, " FROM ");
    v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
    v85.__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v85.__r_.__value_.__l.__data_ = v21;
    v20->__r_.__value_.__l.__size_ = 0;
    v20->__r_.__value_.__r.__words[2] = 0;
    v20->__r_.__value_.__r.__words[0] = 0;
    v22 = std::string::append(&v85, "MicroLocationRecordingEvents");
    v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
    v86.__r_.__value_.__r.__words[2] = v22->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v86.__r_.__value_.__l.__data_ = v23;
    v22->__r_.__value_.__l.__size_ = 0;
    v22->__r_.__value_.__r.__words[2] = 0;
    v22->__r_.__value_.__r.__words[0] = 0;
    v24 = std::string::append(&v86, " WHERE ");
    v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
    v87.__r_.__value_.__r.__words[2] = v24->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v87.__r_.__value_.__l.__data_ = v25;
    v24->__r_.__value_.__l.__size_ = 0;
    v24->__r_.__value_.__r.__words[2] = 0;
    v24->__r_.__value_.__r.__words[0] = 0;
    v26 = std::string::append(&v87, "EventType");
    v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
    v88.__r_.__value_.__r.__words[2] = v26->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v88.__r_.__value_.__l.__data_ = v27;
    v26->__r_.__value_.__l.__size_ = 0;
    v26->__r_.__value_.__r.__words[2] = 0;
    v26->__r_.__value_.__r.__words[0] = 0;
    v28 = std::string::append(&v88, "=");
    v29 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
    v89.__r_.__value_.__r.__words[2] = v28->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v89.__r_.__value_.__l.__data_ = v29;
    v28->__r_.__value_.__l.__size_ = 0;
    v28->__r_.__value_.__r.__words[2] = 0;
    v28->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v79, 1);
    if ((v79.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v30 = &v79;
    else
      v30 = (std::string *)v79.__r_.__value_.__r.__words[0];
    if ((v79.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(v79.__r_.__value_.__r.__words[2]);
    else
      size = v79.__r_.__value_.__l.__size_;
    v32 = std::string::append(&v89, (const std::string::value_type *)v30, size);
    v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
    v90.__r_.__value_.__r.__words[2] = v32->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v90.__r_.__value_.__l.__data_ = v33;
    v32->__r_.__value_.__l.__size_ = 0;
    v32->__r_.__value_.__r.__words[2] = 0;
    v32->__r_.__value_.__r.__words[0] = 0;
    v34 = std::string::append(&v90, " AND HEX(");
    v35 = *(_OWORD *)&v34->__r_.__value_.__l.__data_;
    v91.__r_.__value_.__r.__words[2] = v34->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v91.__r_.__value_.__l.__data_ = v35;
    v34->__r_.__value_.__l.__size_ = 0;
    v34->__r_.__value_.__r.__words[2] = 0;
    v34->__r_.__value_.__r.__words[0] = 0;
    v36 = std::string::append(&v91, "Event");
    v37 = *(_OWORD *)&v36->__r_.__value_.__l.__data_;
    v92.__r_.__value_.__r.__words[2] = v36->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v92.__r_.__value_.__l.__data_ = v37;
    v36->__r_.__value_.__l.__size_ = 0;
    v36->__r_.__value_.__r.__words[2] = 0;
    v36->__r_.__value_.__r.__words[0] = 0;
    v38 = std::string::append(&v92, ") LIKE ");
    v39 = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
    v93.__r_.__value_.__r.__words[2] = v38->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v93.__r_.__value_.__l.__data_ = v39;
    v38->__r_.__value_.__l.__size_ = 0;
    v38->__r_.__value_.__r.__words[2] = 0;
    v38->__r_.__value_.__r.__words[0] = 0;
    v40 = std::string::append(&v93, "'080111________________1A021002%'");
    v41 = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
    v94.__r_.__value_.__r.__words[2] = v40->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v94.__r_.__value_.__l.__data_ = v41;
    v40->__r_.__value_.__l.__size_ = 0;
    v40->__r_.__value_.__r.__words[2] = 0;
    v40->__r_.__value_.__r.__words[0] = 0;
    v42 = std::string::append(&v94, " AND ");
    v43 = *(_OWORD *)&v42->__r_.__value_.__l.__data_;
    v95.__r_.__value_.__r.__words[2] = v42->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v95.__r_.__value_.__l.__data_ = v43;
    v42->__r_.__value_.__l.__size_ = 0;
    v42->__r_.__value_.__r.__words[2] = 0;
    v42->__r_.__value_.__r.__words[0] = 0;
    v44 = std::string::append(&v95, "RecordingTimestamp");
    v45 = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
    v96.__r_.__value_.__r.__words[2] = v44->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v96.__r_.__value_.__l.__data_ = v45;
    v44->__r_.__value_.__l.__size_ = 0;
    v44->__r_.__value_.__r.__words[2] = 0;
    v44->__r_.__value_.__r.__words[0] = 0;
    v46 = std::string::append(&v96, " > ");
    v47 = *(_OWORD *)&v46->__r_.__value_.__l.__data_;
    v97.__r_.__value_.__r.__words[2] = v46->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v97.__r_.__value_.__l.__data_ = v47;
    v46->__r_.__value_.__l.__size_ = 0;
    v46->__r_.__value_.__r.__words[2] = 0;
    v46->__r_.__value_.__r.__words[0] = 0;
    v48 = *(char *)(a3 + 23);
    if (v48 >= 0)
      v49 = (const std::string::value_type *)a3;
    else
      v49 = *(const std::string::value_type **)a3;
    if (v48 >= 0)
      v50 = *(unsigned __int8 *)(a3 + 23);
    else
      v50 = *(_QWORD *)(a3 + 8);
    v51 = std::string::append(&v97, v49, v50);
    v52 = *(_OWORD *)&v51->__r_.__value_.__l.__data_;
    v98.__r_.__value_.__r.__words[2] = v51->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v98.__r_.__value_.__l.__data_ = v52;
    v51->__r_.__value_.__l.__size_ = 0;
    v51->__r_.__value_.__r.__words[2] = 0;
    v51->__r_.__value_.__r.__words[0] = 0;
    v53 = std::string::append(&v98, " AND ");
    v54 = *(_OWORD *)&v53->__r_.__value_.__l.__data_;
    v99.__r_.__value_.__r.__words[2] = v53->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v99.__r_.__value_.__l.__data_ = v54;
    v53->__r_.__value_.__l.__size_ = 0;
    v53->__r_.__value_.__r.__words[2] = 0;
    v53->__r_.__value_.__r.__words[0] = 0;
    v55 = std::string::append(&v99, "RecordingTimestamp");
    v56 = *(_OWORD *)&v55->__r_.__value_.__l.__data_;
    v100.__r_.__value_.__r.__words[2] = v55->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v100.__r_.__value_.__l.__data_ = v56;
    v55->__r_.__value_.__l.__size_ = 0;
    v55->__r_.__value_.__r.__words[2] = 0;
    v55->__r_.__value_.__r.__words[0] = 0;
    v57 = std::string::append(&v100, "<= ");
    v58 = *(_OWORD *)&v57->__r_.__value_.__l.__data_;
    v101.__r_.__value_.__r.__words[2] = v57->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v101.__r_.__value_.__l.__data_ = v58;
    v57->__r_.__value_.__l.__size_ = 0;
    v57->__r_.__value_.__r.__words[2] = 0;
    v57->__r_.__value_.__r.__words[0] = 0;
    v59 = *(char *)(a4 + 23);
    if (v59 >= 0)
      v60 = (const std::string::value_type *)a4;
    else
      v60 = *(const std::string::value_type **)a4;
    if (v59 >= 0)
      v61 = *(unsigned __int8 *)(a4 + 23);
    else
      v61 = *(_QWORD *)(a4 + 8);
    v62 = std::string::append(&v101, v60, v61);
    v63 = *(_OWORD *)&v62->__r_.__value_.__l.__data_;
    v102.__r_.__value_.__r.__words[2] = v62->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v102.__r_.__value_.__l.__data_ = v63;
    v62->__r_.__value_.__l.__size_ = 0;
    v62->__r_.__value_.__r.__words[2] = 0;
    v62->__r_.__value_.__r.__words[0] = 0;
    v64 = std::string::append(&v102, " AND ");
    v65 = *(_OWORD *)&v64->__r_.__value_.__l.__data_;
    v103.__r_.__value_.__r.__words[2] = v64->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v103.__r_.__value_.__l.__data_ = v65;
    v64->__r_.__value_.__l.__size_ = 0;
    v64->__r_.__value_.__r.__words[2] = 0;
    v64->__r_.__value_.__r.__words[0] = 0;
    sub_1015A2E04(v75, "RtLoiGroupId");
    sub_1002AAC84((const void **)v75, a2, (uint64_t)__p);
    if ((v78 & 0x80u) == 0)
      v66 = __p;
    else
      v66 = (void **)__p[0];
    if ((v78 & 0x80u) == 0)
      v67 = v78;
    else
      v67 = (std::string::size_type)__p[1];
    v68 = std::string::append(&v103, (const std::string::value_type *)v66, v67);
    v69 = *(_OWORD *)&v68->__r_.__value_.__l.__data_;
    v104.__r_.__value_.__r.__words[2] = v68->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v104.__r_.__value_.__l.__data_ = v69;
    v68->__r_.__value_.__l.__size_ = 0;
    v68->__r_.__value_.__r.__words[2] = 0;
    v68->__r_.__value_.__r.__words[0] = 0;
    v70 = std::string::append(&v104, ")");
    v71 = *(_OWORD *)&v70->__r_.__value_.__l.__data_;
    v106 = v70->__r_.__value_.__r.__words[2];
    *(_OWORD *)buf = v71;
    v70->__r_.__value_.__l.__size_ = 0;
    v70->__r_.__value_.__r.__words[2] = 0;
    v70->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v104.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v104.__r_.__value_.__l.__data_);
    if ((char)v78 < 0)
      operator delete(__p[0]);
    if (v76 < 0)
      operator delete(v75[0]);
    if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v103.__r_.__value_.__l.__data_);
    if (SHIBYTE(v102.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v102.__r_.__value_.__l.__data_);
    if (SHIBYTE(v101.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v101.__r_.__value_.__l.__data_);
    if (SHIBYTE(v100.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v100.__r_.__value_.__l.__data_);
    if (SHIBYTE(v99.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v99.__r_.__value_.__l.__data_);
    if (SHIBYTE(v98.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v98.__r_.__value_.__l.__data_);
    if (SHIBYTE(v97.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v97.__r_.__value_.__l.__data_);
    if (SHIBYTE(v96.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v96.__r_.__value_.__l.__data_);
    if (SHIBYTE(v95.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v95.__r_.__value_.__l.__data_);
    if (SHIBYTE(v94.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v94.__r_.__value_.__l.__data_);
    if (SHIBYTE(v93.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v93.__r_.__value_.__l.__data_);
    if (SHIBYTE(v92.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v92.__r_.__value_.__l.__data_);
    if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v91.__r_.__value_.__l.__data_);
    if (SHIBYTE(v90.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v90.__r_.__value_.__l.__data_);
    if (SHIBYTE(v79.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v79.__r_.__value_.__l.__data_);
    if (SHIBYTE(v89.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v89.__r_.__value_.__l.__data_);
    if (SHIBYTE(v88.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v88.__r_.__value_.__l.__data_);
    if (SHIBYTE(v87.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v87.__r_.__value_.__l.__data_);
    if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v86.__r_.__value_.__l.__data_);
    if (SHIBYTE(v85.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v85.__r_.__value_.__l.__data_);
    if (SHIBYTE(v84.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v84.__r_.__value_.__l.__data_);
    if (SHIBYTE(v83.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v83.__r_.__value_.__l.__data_);
    if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v82.__r_.__value_.__l.__data_);
    if (SHIBYTE(v81.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v81.__r_.__value_.__l.__data_);
    if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v80.__r_.__value_.__l.__data_);
    sub_100321914(*(_QWORD *)a1, (uint64_t)buf, a5);
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212F688);
  v72 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "#Warning Table is not valid so we can't select all", buf, 2u);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212F688);
    LOWORD(v104.__r_.__value_.__l.__data_) = 0;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#Warning Table is not valid so we can't select all", &v104, 2);
    v74 = (uint8_t *)v73;
    sub_100512490("Generic", 1, 0, 2, "std::vector<CLMicroLocationMeasurementTable::Entry> CLMicroLocationMeasurementTable::selectLearningMeasurementsAtLoiBetweenTimes(const boost::uuids::uuid &, const std::string &, const std::string &, uint32_t)", "%s\n", v73);
    if (v74 != buf)
      free(v74);
  }
  *a6 = 0;
  a6[1] = 0;
  a6[2] = 0;
}

void sub_100322A6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100322C8C()
{
  JUMPOUT(0x100322B44);
}

void sub_100322C94()
{
  JUMPOUT(0x100322B54);
}

void sub_100322C9C()
{
  JUMPOUT(0x100322B64);
}

void sub_100322CA4()
{
  JUMPOUT(0x100322B74);
}

void sub_100322CAC()
{
  JUMPOUT(0x100322B84);
}

void sub_100322CB4()
{
  JUMPOUT(0x100322B94);
}

void sub_100322CBC()
{
  JUMPOUT(0x100322BA4);
}

void sub_100322CC4()
{
  JUMPOUT(0x100322BB4);
}

void sub_100322CCC()
{
  JUMPOUT(0x100322BC4);
}

void sub_100322CD4()
{
  JUMPOUT(0x100322BD4);
}

void sub_100322CDC()
{
  JUMPOUT(0x100322BE4);
}

void sub_100322CE4()
{
  JUMPOUT(0x100322BF4);
}

void sub_100322CEC()
{
  JUMPOUT(0x100322C04);
}

void sub_100322CF4()
{
  JUMPOUT(0x100322C14);
}

void sub_100322CFC()
{
  JUMPOUT(0x100322C24);
}

void sub_100322D04()
{
  JUMPOUT(0x100322C34);
}

void sub_100322D0C()
{
  JUMPOUT(0x100322C44);
}

void sub_100322D14()
{
  JUMPOUT(0x100322C54);
}

void sub_100322D1C()
{
  JUMPOUT(0x100322C64);
}

void sub_100322D24()
{
  JUMPOUT(0x100322C74);
}

void sub_100322D2C(uint64_t a1@<X0>, uint64_t *a2@<X1>, unsigned int a3@<W2>, _QWORD *a4@<X8>)
{
  uint64_t *v5;
  uint64_t v7;
  std::string *p_p;
  std::string::size_type size;
  std::string *v11;
  __int128 v12;
  std::string *v13;
  __int128 v14;
  uint64_t v15;
  uint64_t i;
  std::string *v17;
  __int128 v18;
  std::string *v19;
  std::string::size_type v20;
  std::string *v21;
  __int128 v22;
  std::string *v23;
  __int128 v24;
  std::string *v25;
  std::string::size_type v26;
  std::string *v27;
  __int128 v28;
  std::string *v29;
  __int128 v30;
  std::string *v31;
  __int128 v32;
  std::string *v33;
  std::string::size_type v34;
  std::string *v35;
  __int128 v36;
  std::string *v37;
  __int128 v38;
  NSObject *v39;
  uint64_t v40;
  const char *v41;
  uint8_t *v42;
  std::string v43;
  std::string v44;
  std::string v45;
  std::string __p;
  std::string v47;
  std::string v48;
  uint8_t buf[16];
  _UNKNOWN **v50;

  if (*(_BYTE *)(a1 + 8))
  {
    v5 = a2;
    v7 = *a2;
    if (*a2 != a2[1])
    {
      *((_BYTE *)&v47.__r_.__value_.__s + 23) = 1;
      LOWORD(v47.__r_.__value_.__l.__data_) = 34;
      memset(&__p, 0, sizeof(__p));
      if ((sub_10026A098(v7, &__p) & 1) != 0)
      {
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          p_p = &__p;
        else
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        else
          size = __p.__r_.__value_.__l.__size_;
        v11 = std::string::append(&v47, (const std::string::value_type *)p_p, size);
        v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
        v48.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v48.__r_.__value_.__l.__data_ = v12;
        v11->__r_.__value_.__l.__size_ = 0;
        v11->__r_.__value_.__r.__words[2] = 0;
        v11->__r_.__value_.__r.__words[0] = 0;
        v13 = std::string::append(&v48, "\"");
        v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
        v43.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v14;
        v13->__r_.__value_.__l.__size_ = 0;
        v13->__r_.__value_.__r.__words[2] = 0;
        v13->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v48.__r_.__value_.__l.__data_);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v47.__r_.__value_.__l.__data_);
        v15 = v5[1];
        for (i = *v5 + 16; i != v15; i += 16)
        {
          *((_BYTE *)&v45.__r_.__value_.__s + 23) = 1;
          LOWORD(v45.__r_.__value_.__l.__data_) = 44;
          v17 = std::string::append(&v45, "\"");
          v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
          __p.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
          *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v18;
          v17->__r_.__value_.__l.__size_ = 0;
          v17->__r_.__value_.__r.__words[2] = 0;
          v17->__r_.__value_.__r.__words[0] = 0;
          memset(&v44, 0, sizeof(v44));
          if ((sub_10026A098(i, &v44) & 1) == 0)
          {
            std::bad_cast::bad_cast((std::bad_cast *)buf);
            *(_QWORD *)buf = &off_10212A508;
            sub_10026A9C8((uint64_t)buf);
          }
          if ((v44.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v19 = &v44;
          else
            v19 = (std::string *)v44.__r_.__value_.__r.__words[0];
          if ((v44.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v20 = HIBYTE(v44.__r_.__value_.__r.__words[2]);
          else
            v20 = v44.__r_.__value_.__l.__size_;
          v21 = std::string::append(&__p, (const std::string::value_type *)v19, v20);
          v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
          v47.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v47.__r_.__value_.__l.__data_ = v22;
          v21->__r_.__value_.__l.__size_ = 0;
          v21->__r_.__value_.__r.__words[2] = 0;
          v21->__r_.__value_.__r.__words[0] = 0;
          v23 = std::string::append(&v47, "\"");
          v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
          v48.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v48.__r_.__value_.__l.__data_ = v24;
          v23->__r_.__value_.__l.__size_ = 0;
          v23->__r_.__value_.__r.__words[2] = 0;
          v23->__r_.__value_.__r.__words[0] = 0;
          if ((v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v25 = &v48;
          else
            v25 = (std::string *)v48.__r_.__value_.__r.__words[0];
          if ((v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v26 = HIBYTE(v48.__r_.__value_.__r.__words[2]);
          else
            v26 = v48.__r_.__value_.__l.__size_;
          std::string::append(&v43, (const std::string::value_type *)v25, v26);
          if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v48.__r_.__value_.__l.__data_);
          if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v47.__r_.__value_.__l.__data_);
          if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v44.__r_.__value_.__l.__data_);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
            operator delete(__p.__r_.__value_.__l.__data_);
          if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v45.__r_.__value_.__l.__data_);
        }
        *((_BYTE *)&v44.__r_.__value_.__s + 23) = 7;
        strcpy((char *)&v44, " WHERE ");
        v27 = std::string::append(&v44, "RecordingUUID");
        v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
        v45.__r_.__value_.__r.__words[2] = v27->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v45.__r_.__value_.__l.__data_ = v28;
        v27->__r_.__value_.__l.__size_ = 0;
        v27->__r_.__value_.__r.__words[2] = 0;
        v27->__r_.__value_.__r.__words[0] = 0;
        v29 = std::string::append(&v45, " in ");
        v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
        __p.__r_.__value_.__r.__words[2] = v29->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v30;
        v29->__r_.__value_.__l.__size_ = 0;
        v29->__r_.__value_.__r.__words[2] = 0;
        v29->__r_.__value_.__r.__words[0] = 0;
        v31 = std::string::append(&__p, "(");
        v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
        v47.__r_.__value_.__r.__words[2] = v31->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v47.__r_.__value_.__l.__data_ = v32;
        v31->__r_.__value_.__l.__size_ = 0;
        v31->__r_.__value_.__r.__words[2] = 0;
        v31->__r_.__value_.__r.__words[0] = 0;
        if ((v43.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v33 = &v43;
        else
          v33 = (std::string *)v43.__r_.__value_.__r.__words[0];
        if ((v43.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v34 = HIBYTE(v43.__r_.__value_.__r.__words[2]);
        else
          v34 = v43.__r_.__value_.__l.__size_;
        v35 = std::string::append(&v47, (const std::string::value_type *)v33, v34);
        v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
        v48.__r_.__value_.__r.__words[2] = v35->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v48.__r_.__value_.__l.__data_ = v36;
        v35->__r_.__value_.__l.__size_ = 0;
        v35->__r_.__value_.__r.__words[2] = 0;
        v35->__r_.__value_.__r.__words[0] = 0;
        v37 = std::string::append(&v48, ")");
        v38 = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
        v50 = (_UNKNOWN **)v37->__r_.__value_.__r.__words[2];
        *(_OWORD *)buf = v38;
        v37->__r_.__value_.__l.__size_ = 0;
        v37->__r_.__value_.__r.__words[2] = 0;
        v37->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v48.__r_.__value_.__l.__data_);
        if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v47.__r_.__value_.__l.__data_);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v45.__r_.__value_.__l.__data_);
        if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v44.__r_.__value_.__l.__data_);
        sub_100321914(*(_QWORD *)a1, (uint64_t)buf, a3);
      }
      std::bad_cast::bad_cast((std::bad_cast *)buf);
      *(_QWORD *)buf = &off_10212A508;
      sub_10026A9C8((uint64_t)buf);
    }
    sub_1018F417C();
    __break(1u);
LABEL_70:
    dispatch_once(&qword_1022A00F0, &stru_10212F688);
LABEL_66:
    v40 = v5[31];
    LOWORD(v48.__r_.__value_.__l.__data_) = 0;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, v40, 0, "#Warning Table is not valid so we can't select all", &v48, 2);
    v42 = (uint8_t *)v41;
    sub_100512490("Generic", 1, 0, 2, "std::vector<CLMicroLocationMeasurementTable::Entry> CLMicroLocationMeasurementTable::selectMeasurementsFromRecordingUUIDs(const std::vector<boost::uuids::uuid> &, uint32_t)", "%s\n", v41);
    if (v42 != buf)
      free(v42);
    goto LABEL_63;
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212F688);
  v5 = &qword_1022A0000;
  v39 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#Warning Table is not valid so we can't select all", buf, 2u);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 == -1)
      goto LABEL_66;
    goto LABEL_70;
  }
LABEL_63:
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
}

void sub_1003232F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,uint64_t a50,void *__p,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  if (a56 < 0)
    operator delete(__p);
  if (a16 < 0)
    operator delete(a11);
  _Unwind_Resume(exception_object);
}

uint64_t sub_100323468(uint64_t a1, unint64_t a2)
{
  std::string *v4;
  __int128 v5;
  std::string *v6;
  __int128 v7;
  std::string *v8;
  __int128 v9;
  std::string *v10;
  __int128 v11;
  std::string *v12;
  __int128 v13;
  std::string *v14;
  __int128 v15;
  std::string *v16;
  __int128 v17;
  std::string *v18;
  __int128 v19;
  std::string *v20;
  __int128 v21;
  std::string *v22;
  __int128 v23;
  std::string *v24;
  __int128 v25;
  std::string *v26;
  std::string::size_type size;
  std::string *v28;
  __int128 v29;
  std::string *v30;
  __int128 v31;
  char *v32;
  NSObject *v33;
  const char *v35;
  std::string *v36;
  std::string v37;
  std::string v38;
  std::string v39;
  std::string v40;
  std::string v41;
  std::string v42;
  std::string v43;
  std::string v44;
  std::string v45;
  std::string v46;
  std::string v47;
  std::string v48;
  std::string v49;
  void *__p[2];
  int64_t v51;
  std::string v52;

  if (*(_BYTE *)(a1 + 8))
  {
    *((_BYTE *)&v38.__r_.__value_.__s + 23) = 12;
    strcpy((char *)&v38, "DELETE FROM ");
    v4 = std::string::append(&v38, "MicroLocationMeasurements");
    v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
    v39.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v39.__r_.__value_.__l.__data_ = v5;
    v4->__r_.__value_.__l.__size_ = 0;
    v4->__r_.__value_.__r.__words[2] = 0;
    v4->__r_.__value_.__r.__words[0] = 0;
    v6 = std::string::append(&v39, " WHERE ");
    v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v40.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v40.__r_.__value_.__l.__data_ = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    v8 = std::string::append(&v40, "ScanCFTimestamp");
    v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v41.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v41.__r_.__value_.__l.__data_ = v9;
    v8->__r_.__value_.__l.__size_ = 0;
    v8->__r_.__value_.__r.__words[2] = 0;
    v8->__r_.__value_.__r.__words[0] = 0;
    v10 = std::string::append(&v41, " IN (");
    v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    v42.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    v12 = std::string::append(&v42, "SELECT ");
    v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v43.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    v14 = std::string::append(&v43, "ScanCFTimestamp");
    v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    v44.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v44.__r_.__value_.__l.__data_ = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    v16 = std::string::append(&v44, " FROM ");
    v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v45.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v45.__r_.__value_.__l.__data_ = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    v18 = std::string::append(&v45, "MicroLocationMeasurements");
    v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v46.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v46.__r_.__value_.__l.__data_ = v19;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    v20 = std::string::append(&v46, " ORDER BY ");
    v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
    v47.__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v47.__r_.__value_.__l.__data_ = v21;
    v20->__r_.__value_.__l.__size_ = 0;
    v20->__r_.__value_.__r.__words[2] = 0;
    v20->__r_.__value_.__r.__words[0] = 0;
    v22 = std::string::append(&v47, "ScanCFTimestamp");
    v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
    v48.__r_.__value_.__r.__words[2] = v22->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v48.__r_.__value_.__l.__data_ = v23;
    v22->__r_.__value_.__l.__size_ = 0;
    v22->__r_.__value_.__r.__words[2] = 0;
    v22->__r_.__value_.__r.__words[0] = 0;
    v24 = std::string::append(&v48, " LIMIT ");
    v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
    v49.__r_.__value_.__r.__words[2] = v24->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v49.__r_.__value_.__l.__data_ = v25;
    v24->__r_.__value_.__l.__size_ = 0;
    v24->__r_.__value_.__r.__words[2] = 0;
    v24->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v37, a2);
    if ((v37.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v26 = &v37;
    else
      v26 = (std::string *)v37.__r_.__value_.__r.__words[0];
    if ((v37.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(v37.__r_.__value_.__r.__words[2]);
    else
      size = v37.__r_.__value_.__l.__size_;
    v28 = std::string::append(&v49, (const std::string::value_type *)v26, size);
    v29 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
    v52.__r_.__value_.__r.__words[2] = v28->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v29;
    v28->__r_.__value_.__l.__size_ = 0;
    v28->__r_.__value_.__r.__words[2] = 0;
    v28->__r_.__value_.__r.__words[0] = 0;
    v30 = std::string::append(&v52, ")");
    v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
    v51 = v30->__r_.__value_.__r.__words[2];
    *(_OWORD *)__p = v31;
    v30->__r_.__value_.__l.__size_ = 0;
    v30->__r_.__value_.__r.__words[2] = 0;
    v30->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v52.__r_.__value_.__l.__data_);
    if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v37.__r_.__value_.__l.__data_);
    if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v49.__r_.__value_.__l.__data_);
    if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v48.__r_.__value_.__l.__data_);
    if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v47.__r_.__value_.__l.__data_);
    if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v46.__r_.__value_.__l.__data_);
    if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v45.__r_.__value_.__l.__data_);
    if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v44.__r_.__value_.__l.__data_);
    if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v43.__r_.__value_.__l.__data_);
    if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v42.__r_.__value_.__l.__data_);
    if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v41.__r_.__value_.__l.__data_);
    if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v40.__r_.__value_.__l.__data_);
    if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v39.__r_.__value_.__l.__data_);
    if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v38.__r_.__value_.__l.__data_);
    if (v51 >= 0)
      v32 = (char *)__p;
    else
      v32 = (char *)__p[0];
    sub_1000CDA68(*(_QWORD *)a1, v32);
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212F688);
  v33 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v52.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#Warning Table is not valid so we can't deleteOldestRows", (uint8_t *)&v52, 2u);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(&v52, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212F688);
    LOWORD(__p[0]) = 0;
    _os_log_send_and_compose_impl(2, 0, &v52, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#Warning Table is not valid so we can't deleteOldestRows", __p, 2);
    v36 = (std::string *)v35;
    sub_100512490("Generic", 1, 0, 2, "BOOL CLMicroLocationMeasurementTable::deleteOldestRows(uint64_t)", "%s\n", v35);
    if (v36 != &v52)
      free(v36);
  }
  return 0;
}

void sub_100323AE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,uint64_t a52,void *a53,uint64_t a54,uint64_t a55,uint64_t a56,void *a57,uint64_t a58,uint64_t a59,uint64_t a60,void *__p,uint64_t a62,int a63)
{
  char a66;
  uint64_t v66;

  if (v66)
    (*(void (**)(uint64_t))(*(_QWORD *)v66 + 8))(v66);
  if (a66 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t sub_100323C70(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  std::string *p_p;
  std::string::size_type size;
  std::string *v7;
  __int128 v8;
  std::string *v9;
  __int128 v10;
  uint64_t v11;
  uint64_t i;
  std::string *v13;
  __int128 v14;
  std::string *v15;
  std::string::size_type v16;
  std::string *v17;
  __int128 v18;
  std::string *v19;
  __int128 v20;
  std::string *v21;
  std::string::size_type v22;
  std::string *v23;
  __int128 v24;
  std::string *v25;
  __int128 v26;
  std::string *v27;
  __int128 v28;
  std::string *v29;
  __int128 v30;
  std::string *v31;
  __int128 v32;
  std::string *v33;
  std::string::size_type v34;
  std::string *v35;
  __int128 v36;
  std::string *v37;
  __int128 v38;
  std::string *v39;
  NSObject *v40;
  const char *v41;
  std::string *v42;
  NSObject *v43;
  const char *v45;
  std::string::value_type v46[8];
  char v47;
  std::string::value_type v48[8];
  char v49;
  std::string::value_type __s[8];
  char v51;
  std::string v52;
  std::string v53;
  std::string v54;
  std::string v55;
  std::string v56;
  std::string __p;
  std::string v58;
  std::string v59;
  std::string v60;

  if (*(_BYTE *)(a1 + 8))
  {
    v4 = *a2;
    if (*a2 != a2[1])
    {
      *((_BYTE *)&v58.__r_.__value_.__s + 23) = 1;
      LOWORD(v58.__r_.__value_.__l.__data_) = 34;
      memset(&__p, 0, sizeof(__p));
      if ((sub_10026A098(v4, &__p) & 1) != 0)
      {
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          p_p = &__p;
        else
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        else
          size = __p.__r_.__value_.__l.__size_;
        v7 = std::string::append(&v58, (const std::string::value_type *)p_p, size);
        v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
        v59.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v59.__r_.__value_.__l.__data_ = v8;
        v7->__r_.__value_.__l.__size_ = 0;
        v7->__r_.__value_.__r.__words[2] = 0;
        v7->__r_.__value_.__r.__words[0] = 0;
        v9 = std::string::append(&v59, "\"");
        v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
        v54.__r_.__value_.__r.__words[2] = v9->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v54.__r_.__value_.__l.__data_ = v10;
        v9->__r_.__value_.__l.__size_ = 0;
        v9->__r_.__value_.__r.__words[2] = 0;
        v9->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v59.__r_.__value_.__l.__data_);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v58.__r_.__value_.__l.__data_);
        v11 = a2[1];
        for (i = *a2 + 16; i != v11; i += 16)
        {
          *((_BYTE *)&v56.__r_.__value_.__s + 23) = 1;
          LOWORD(v56.__r_.__value_.__l.__data_) = 44;
          v13 = std::string::append(&v56, "\"");
          v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
          __p.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
          *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v14;
          v13->__r_.__value_.__l.__size_ = 0;
          v13->__r_.__value_.__r.__words[2] = 0;
          v13->__r_.__value_.__r.__words[0] = 0;
          memset(&v55, 0, sizeof(v55));
          if ((sub_10026A098(i, &v55) & 1) == 0)
          {
            std::bad_cast::bad_cast((std::bad_cast *)&v60);
            v60.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_10212A508;
            sub_10026A9C8((uint64_t)&v60);
          }
          if ((v55.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v15 = &v55;
          else
            v15 = (std::string *)v55.__r_.__value_.__r.__words[0];
          if ((v55.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v16 = HIBYTE(v55.__r_.__value_.__r.__words[2]);
          else
            v16 = v55.__r_.__value_.__l.__size_;
          v17 = std::string::append(&__p, (const std::string::value_type *)v15, v16);
          v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
          v58.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v58.__r_.__value_.__l.__data_ = v18;
          v17->__r_.__value_.__l.__size_ = 0;
          v17->__r_.__value_.__r.__words[2] = 0;
          v17->__r_.__value_.__r.__words[0] = 0;
          v19 = std::string::append(&v58, "\"");
          v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
          v59.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v59.__r_.__value_.__l.__data_ = v20;
          v19->__r_.__value_.__l.__size_ = 0;
          v19->__r_.__value_.__r.__words[2] = 0;
          v19->__r_.__value_.__r.__words[0] = 0;
          if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v21 = &v59;
          else
            v21 = (std::string *)v59.__r_.__value_.__r.__words[0];
          if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v22 = HIBYTE(v59.__r_.__value_.__r.__words[2]);
          else
            v22 = v59.__r_.__value_.__l.__size_;
          std::string::append(&v54, (const std::string::value_type *)v21, v22);
          if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v59.__r_.__value_.__l.__data_);
          if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v58.__r_.__value_.__l.__data_);
          if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v55.__r_.__value_.__l.__data_);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
            operator delete(__p.__r_.__value_.__l.__data_);
          if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v56.__r_.__value_.__l.__data_);
        }
        *((_BYTE *)&v52.__r_.__value_.__s + 23) = 12;
        strcpy((char *)&v52, "DELETE FROM ");
        v23 = std::string::append(&v52, "MicroLocationMeasurements");
        v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
        v53.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v24;
        v23->__r_.__value_.__l.__size_ = 0;
        v23->__r_.__value_.__r.__words[2] = 0;
        v23->__r_.__value_.__r.__words[0] = 0;
        v25 = std::string::append(&v53, " WHERE ");
        v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
        v55.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v55.__r_.__value_.__l.__data_ = v26;
        v25->__r_.__value_.__l.__size_ = 0;
        v25->__r_.__value_.__r.__words[2] = 0;
        v25->__r_.__value_.__r.__words[0] = 0;
        v27 = std::string::append(&v55, "RecordingUUID");
        v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
        v56.__r_.__value_.__r.__words[2] = v27->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v56.__r_.__value_.__l.__data_ = v28;
        v27->__r_.__value_.__l.__size_ = 0;
        v27->__r_.__value_.__r.__words[2] = 0;
        v27->__r_.__value_.__r.__words[0] = 0;
        v51 = 4;
        strcpy(__s, " IN ");
        v29 = std::string::append(&v56, __s, 4uLL);
        v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
        __p.__r_.__value_.__r.__words[2] = v29->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v30;
        v29->__r_.__value_.__l.__size_ = 0;
        v29->__r_.__value_.__r.__words[2] = 0;
        v29->__r_.__value_.__r.__words[0] = 0;
        v49 = 1;
        strcpy(v48, "(");
        v31 = std::string::append(&__p, v48, 1uLL);
        v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
        v58.__r_.__value_.__r.__words[2] = v31->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v58.__r_.__value_.__l.__data_ = v32;
        v31->__r_.__value_.__l.__size_ = 0;
        v31->__r_.__value_.__r.__words[2] = 0;
        v31->__r_.__value_.__r.__words[0] = 0;
        if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v33 = &v54;
        else
          v33 = (std::string *)v54.__r_.__value_.__r.__words[0];
        if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v34 = HIBYTE(v54.__r_.__value_.__r.__words[2]);
        else
          v34 = v54.__r_.__value_.__l.__size_;
        v35 = std::string::append(&v58, (const std::string::value_type *)v33, v34);
        v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
        v60.__r_.__value_.__r.__words[2] = v35->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v60.__r_.__value_.__l.__data_ = v36;
        v35->__r_.__value_.__l.__size_ = 0;
        v35->__r_.__value_.__r.__words[2] = 0;
        v35->__r_.__value_.__r.__words[0] = 0;
        v47 = 1;
        strcpy(v46, ")");
        v37 = std::string::append(&v60, v46, 1uLL);
        v38 = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
        v59.__r_.__value_.__r.__words[2] = v37->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v59.__r_.__value_.__l.__data_ = v38;
        v37->__r_.__value_.__l.__size_ = 0;
        v37->__r_.__value_.__r.__words[2] = 0;
        v37->__r_.__value_.__r.__words[0] = 0;
        if (v47 < 0)
          operator delete(*(void **)v46);
        if (SHIBYTE(v60.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v60.__r_.__value_.__l.__data_);
        if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v58.__r_.__value_.__l.__data_);
        if (v49 < 0)
          operator delete(*(void **)v48);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        if (v51 < 0)
          operator delete(*(void **)__s);
        if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v56.__r_.__value_.__l.__data_);
        if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v55.__r_.__value_.__l.__data_);
        if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v53.__r_.__value_.__l.__data_);
        if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v52.__r_.__value_.__l.__data_);
        if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v39 = &v59;
        else
          v39 = (std::string *)v59.__r_.__value_.__r.__words[0];
        sub_1000CDA68(*(_QWORD *)a1, (char *)v39);
      }
      std::bad_cast::bad_cast((std::bad_cast *)&v60);
      v60.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_10212A508;
      sub_10026A9C8((uint64_t)&v60);
    }
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212F688);
    v43 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v60.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#Warning No UUIDs are passed in to delete measurements entries", (uint8_t *)&v60, 2u);
    }
    if (!sub_1001BFF7C(115, 2))
      return 0;
    bzero(&v60, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212F688);
    LOWORD(v59.__r_.__value_.__l.__data_) = 0;
    _os_log_send_and_compose_impl(2, 0, &v60, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#Warning No UUIDs are passed in to delete measurements entries", &v59, 2);
    v42 = (std::string *)v45;
    sub_100512490("Generic", 1, 0, 2, "BOOL CLMicroLocationMeasurementTable::deleteMeasurementsFromRecordingUUIDs(const std::vector<boost::uuids::uuid> &)", "%s\n", v45);
LABEL_88:
    if (v42 != &v60)
      free(v42);
    return 0;
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_10212F688);
  v40 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v60.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#Warning Table is not valid so we can't delete measurements", (uint8_t *)&v60, 2u);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(&v60, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_10212F688);
    LOWORD(v59.__r_.__value_.__l.__data_) = 0;
    _os_log_send_and_compose_impl(2, 0, &v60, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#Warning Table is not valid so we can't delete measurements", &v59, 2);
    v42 = (std::string *)v41;
    sub_100512490("Generic", 1, 0, 2, "BOOL CLMicroLocationMeasurementTable::deleteMeasurementsFromRecordingUUIDs(const std::vector<boost::uuids::uuid> &)", "%s\n", v41);
    goto LABEL_88;
  }
  return 0;
}

void sub_10032459C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,void *a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,uint64_t a40,uint64_t a41,void *a42,uint64_t a43,uint64_t a44,uint64_t a45,void *a46,uint64_t a47,uint64_t a48,uint64_t a49,void *__p,uint64_t a51,int a52,__int16 a53,char a54,char a55)
{
  uint64_t v55;

  if (v55)
    (*(void (**)(uint64_t))(*(_QWORD *)v55 + 8))(v55);
  if (a55 < 0)
    operator delete(__p);
  if (a32 < 0)
    operator delete(a27);
  _Unwind_Resume(a1);
}

void sub_100324794(id a1)
{
  qword_1022A00F8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

sqlite3_int64 sub_1003247C0(sqlite3_stmt *a1, int a2)
{
  sqlite3_int64 result;
  uint64_t v3;

  result = sqlite3_column_int64(a1, a2);
  if (result < 0)
  {
    v3 = sub_1018F42E4();
    return sub_1003247DC(v3);
  }
  return result;
}

uint64_t sub_1003247DC@<X0>(sqlite3_stmt *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  const void *v6;
  uint64_t v7;
  int v8;
  wireless_diagnostics::google::protobuf::MessageLite *v9;
  uint64_t result;
  std::runtime_error *exception;
  std::string v12;

  v6 = sqlite3_column_blob(a1, a2);
  v7 = sqlite3_column_bytes(a1, a2);
  if (!v6)
  {
    sub_1018F4444(v7);
LABEL_5:
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1015A2E04(&v12, "Unable to parse protobuf");
    std::runtime_error::runtime_error(exception, &v12);
    exception->__vftable = (std::runtime_error_vtbl *)&off_10212AC58;
  }
  v8 = v7;
  sub_1002BB8D0(a3);
  result = wireless_diagnostics::google::protobuf::MessageLite::ParseFromArray(v9, v6, v8);
  if ((result & 1) == 0)
    goto LABEL_5;
  return result;
}

void sub_1003248A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  wireless_diagnostics::google::protobuf::MessageLite *v15;
  void *v16;
  int v17;

  if (a15 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
    {
LABEL_6:
      sub_1002C0B04(v15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v17)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

uint64_t sub_1003248EC(uint64_t *a1, _OWORD *a2, uint64_t *a3, uint64_t *a4, uint64_t a5, int *a6)
{
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  _DWORD *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  _QWORD v25[2];
  char *v26;
  char *v27;
  uint64_t *v28;

  v7 = *a1;
  v8 = 0xEEEEEEEEEEEEEEEFLL * ((a1[1] - *a1) >> 3);
  v9 = v8 + 1;
  if (v8 + 1 > 0x222222222222222)
    sub_100259694();
  v15 = (uint64_t)(a1 + 2);
  v16 = 0xEEEEEEEEEEEEEEEFLL * ((a1[2] - v7) >> 3);
  if (2 * v16 > v9)
    v9 = 2 * v16;
  if (v16 >= 0x111111111111111)
    v17 = 0x222222222222222;
  else
    v17 = v9;
  v28 = a1 + 2;
  if (v17)
    v18 = sub_100313328(v15, v17);
  else
    v18 = 0;
  v19 = (char *)&v18[30 * v8];
  v25[0] = v18;
  v25[1] = v19;
  v26 = v19;
  v27 = (char *)&v18[30 * v17];
  v20 = *a3;
  v21 = *a4;
  v22 = *a6;
  *(_OWORD *)v19 = *a2;
  *((_QWORD *)v19 + 2) = v20;
  *((_QWORD *)v19 + 3) = v21;
  sub_1002C0A54(v19 + 32, a5);
  v18[30 * v8 + 28] = v22;
  v26 += 120;
  sub_100324A3C(a1, v25);
  v23 = a1[1];
  sub_1003134C4((uint64_t)v25);
  return v23;
}

void sub_100324A28(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1003134C4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100324A3C(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = sub_10031336C((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

double sub_100324AB0@<D0>(std::string *a1@<X8>)
{
  double result;
  std::string v3;

  memset(&v3, 0, sizeof(v3));
  sub_100324B10(&v3);
  result = *(double *)&v3.__r_.__value_.__l.__data_;
  *a1 = v3;
  return result;
}

void sub_100324AF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_100324B10(std::string *a1)
{
  sub_100324B54(a1);
  sub_100324C24(a1);
  sub_100324D00(a1);
  sub_100324DDC(a1);
  sub_100324EB8(a1);
  return sub_100269E68(a1);
}

uint64_t sub_100324B54(std::string *a1)
{
  std::string *v2;
  __int128 v3;
  void **v4;
  std::string::size_type v5;
  std::string v7;
  void *__p[2];
  int64_t v9;

  *((_BYTE *)&v7.__r_.__value_.__s + 23) = 0;
  v7.__r_.__value_.__s.__data_[0] = 0;
  v2 = std::string::append(&v7, "RecordingUUID");
  v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0)
    v4 = __p;
  else
    v4 = (void **)__p[0];
  if (v9 >= 0)
    v5 = HIBYTE(v9);
  else
    v5 = (std::string::size_type)__p[1];
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v7.__r_.__value_.__l.__data_);
  return 0;
}

void sub_100324BF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

uint64_t sub_100324C24(std::string *a1)
{
  std::string *v2;
  __int128 v3;
  void **v4;
  std::string::size_type v5;
  std::string v7;
  void *__p[2];
  int64_t v9;

  *((_BYTE *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  v2 = std::string::append(&v7, "ScanCFTimestamp");
  v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0)
    v4 = __p;
  else
    v4 = (void **)__p[0];
  if (v9 >= 0)
    v5 = HIBYTE(v9);
  else
    v5 = (std::string::size_type)__p[1];
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v7.__r_.__value_.__l.__data_);
  return 0;
}

void sub_100324CCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

uint64_t sub_100324D00(std::string *a1)
{
  std::string *v2;
  __int128 v3;
  void **v4;
  std::string::size_type v5;
  std::string v7;
  void *__p[2];
  int64_t v9;

  *((_BYTE *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  v2 = std::string::append(&v7, "ScanMCTimestamp");
  v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0)
    v4 = __p;
  else
    v4 = (void **)__p[0];
  if (v9 >= 0)
    v5 = HIBYTE(v9);
  else
    v5 = (std::string::size_type)__p[1];
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v7.__r_.__value_.__l.__data_);
  return 0;
}

void sub_100324DA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

uint64_t sub_100324DDC(std::string *a1)
{
  std::string *v2;
  __int128 v3;
  void **v4;
  std::string::size_type v5;
  std::string v7;
  void *__p[2];
  int64_t v9;

  *((_BYTE *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  v2 = std::string::append(&v7, "Data");
  v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0)
    v4 = __p;
  else
    v4 = (void **)__p[0];
  if (v9 >= 0)
    v5 = HIBYTE(v9);
  else
    v5 = (std::string::size_type)__p[1];
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v7.__r_.__value_.__l.__data_);
  return 0;
}

void sub_100324E84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

uint64_t sub_100324EB8(std::string *a1)
{
  std::string *v2;
  __int128 v3;
  void **v4;
  std::string::size_type v5;
  std::string v7;
  void *__p[2];
  int64_t v9;

  *((_BYTE *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  v2 = std::string::append(&v7, "Flags");
  v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0)
    v4 = __p;
  else
    v4 = (void **)__p[0];
  if (v9 >= 0)
    v5 = HIBYTE(v9);
  else
    v5 = (std::string::size_type)__p[1];
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v7.__r_.__value_.__l.__data_);
  return 0;
}

void sub_100324F60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

uint64_t sub_100324F94()
{
  std::string *v0;
  __int128 v1;
  std::string *v2;
  __int128 v3;
  void **v4;
  std::string::size_type v5;
  std::string *v6;
  __int128 v7;
  std::string *v8;
  __int128 v9;
  void **v10;
  std::string::size_type v11;
  std::string *v12;
  __int128 v13;
  void *__p[2];
  unsigned __int8 v16;
  void *v17[2];
  unsigned __int8 v18;
  std::string v19;
  std::string v20;
  std::string v21;
  std::string v22;
  std::string v23;

  v19.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x19uLL);
  *(_OWORD *)&v19.__r_.__value_.__r.__words[1] = xmmword_101B980A0;
  strcpy(v19.__r_.__value_.__l.__data_, "INSERT OR REPLACE INTO ");
  v0 = std::string::append(&v19, "MicroLocationMeasurements");
  v1 = *(_OWORD *)&v0->__r_.__value_.__l.__data_;
  v20.__r_.__value_.__r.__words[2] = v0->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v20.__r_.__value_.__l.__data_ = v1;
  v0->__r_.__value_.__l.__size_ = 0;
  v0->__r_.__value_.__r.__words[2] = 0;
  v0->__r_.__value_.__r.__words[0] = 0;
  v2 = std::string::append(&v20, " (");
  v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  v21.__r_.__value_.__r.__words[2] = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v21.__r_.__value_.__l.__data_ = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  sub_100320C34((uint64_t)v17);
  if ((v18 & 0x80u) == 0)
    v4 = v17;
  else
    v4 = (void **)v17[0];
  if ((v18 & 0x80u) == 0)
    v5 = v18;
  else
    v5 = (std::string::size_type)v17[1];
  v6 = std::string::append(&v21, (const std::string::value_type *)v4, v5);
  v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v22.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v22.__r_.__value_.__l.__data_ = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  v8 = std::string::append(&v22, ") ");
  v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v23.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v23.__r_.__value_.__l.__data_ = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  sub_100320CFC((uint64_t)__p);
  if ((v16 & 0x80u) == 0)
    v10 = __p;
  else
    v10 = (void **)__p[0];
  if ((v16 & 0x80u) == 0)
    v11 = v16;
  else
    v11 = (std::string::size_type)__p[1];
  v12 = std::string::append(&v23, (const std::string::value_type *)v10, v11);
  v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  unk_102301160 = *((_QWORD *)&v12->__r_.__value_.__l + 2);
  xmmword_102301150 = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  if ((char)v16 < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v23.__r_.__value_.__l.__data_);
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v22.__r_.__value_.__l.__data_);
  if ((char)v18 < 0)
    operator delete(v17[0]);
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v21.__r_.__value_.__l.__data_);
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v20.__r_.__value_.__l.__data_);
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v19.__r_.__value_.__l.__data_);
  return __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_102301150, (void *)&_mh_execute_header);
}

void sub_100325180(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  uint64_t v40;

  if (a15 < 0)
    operator delete(__p);
  if (*(char *)(v40 - 25) < 0)
    operator delete(*(void **)(v40 - 48));
  if (*(char *)(v40 - 57) < 0)
    operator delete(*(void **)(v40 - 80));
  if (a21 < 0)
    operator delete(a16);
  if (a40 < 0)
    operator delete(a35);
  if (a33 < 0)
    operator delete(a28);
  if (a27 < 0)
    operator delete(a22);
  _Unwind_Resume(exception_object);
}

void sub_10032522C(uint64_t a1, uint64_t a2)
{
  std::string *v2;
  _BYTE v3[15];
  std::string v4;

  std::to_string(&v4, *(_DWORD *)(a2 + 4));
  v2 = std::string::insert(&v4, 0, "LocalizationProcessing_modelType_");
  *(_QWORD *)v3 = v2->__r_.__value_.__l.__size_;
  *(_QWORD *)&v3[7] = *(std::string::size_type *)((char *)&v2->__r_.__value_.__r.__words[1] + 7);
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  operator new();
}

void sub_1003259D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, void **a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,char a32,uint64_t a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44)
{
  uint64_t v44;

  if (a18)
    (*(void (**)(uint64_t))(*(_QWORD *)a18 + 8))(a18);
  sub_100261E8C(v44);
  sub_10029DDD0(&a19, 0);
  _Unwind_Resume(a1);
}

void sub_100325B70(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  __int128 v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 5)
  {
    if (a2 >> 59)
      sub_100259694();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)sub_10025BA00(v3, a2);
    v7 = &v6[v5];
    v9 = &v6[32 * v8];
    v11 = (char *)*a1;
    v10 = (char *)a1[1];
    v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        v13 = *((_OWORD *)v10 - 2);
        *(_OWORD *)(v12 - 20) = *(_OWORD *)(v10 - 20);
        *((_OWORD *)v12 - 2) = v13;
        v12 -= 32;
        v10 -= 32;
      }
      while (v10 != v11);
      v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

uint64_t sub_100325C14(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 32))
  {
    sub_10027839C((_QWORD *)a1, a2);
  }
  else
  {
    sub_100325C88(a1, a2);
    *(_BYTE *)(a1 + 32) = 1;
  }
  return a1;
}

void sub_100325C5C(id a1)
{
  qword_1022A00F8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

uint64_t sub_100325C88(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;

  v3 = (_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(_QWORD *)(a1 + 24) = v4;
  }
  else
  {
    v3 = (_QWORD *)(a1 + 24);
  }
  *v3 = 0;
  return a1;
}

void sub_100325CEC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)a1 = &off_10212F8F8;
  sub_1002E6718((_QWORD *)(a1 + 8));
  *(_QWORD *)a1 = off_10212F828;
  *(_QWORD *)(a1 + 8) = off_10212F890;
  *(_QWORD *)(a1 + 64) = &off_10212F960;
  *(_QWORD *)(a1 + 72) = &off_10212F9B8;
  *(_QWORD *)(a1 + 80) = &off_10212FA10;
  *(_QWORD *)(a1 + 88) = &off_10212FA68;
  *(_QWORD *)(a1 + 96) = &off_10212FAC0;
  *(_QWORD *)(a1 + 104) = &off_10212FB18;
  *(_QWORD *)(a1 + 112) = &off_10212FB70;
  *(_QWORD *)(a1 + 120) = &off_10212FBC8;
  *(_QWORD *)(a1 + 128) = &off_10212FC20;
  *(_QWORD *)(a1 + 136) = &off_10212FC60;
  *(_QWORD *)(a1 + 144) = &off_10212FCA0;
  *(_QWORD *)(a1 + 152) = &off_10212FCE0;
  *(_QWORD *)(a1 + 160) = &off_10212FD38;
  *(_QWORD *)(a1 + 168) = &off_10212FD78;
  *(_QWORD *)(a1 + 176) = &off_10212FDB8;
  *(_QWORD *)(a1 + 184) = &off_10212FDF8;
  *(_QWORD *)(a1 + 192) = &off_10212FE38;
  *(_QWORD *)(a1 + 200) = &off_10212FE78;
  *(_QWORD *)(a1 + 208) = &off_10212FEB8;
  *(_QWORD *)(a1 + 216) = &off_10212FF10;
  *(_QWORD *)(a1 + 224) = &off_10212FF68;
  *(_QWORD *)(a1 + 232) = &off_10212FFC0;
  *(_QWORD *)(a1 + 240) = &off_102130018;
  *(_QWORD *)(a1 + 248) = &off_102130070;
  *(_QWORD *)(a1 + 256) = &off_1021300C8;
  *(_QWORD *)(a1 + 264) = &off_102130108;
  *(_QWORD *)(a1 + 272) = &off_102130148;
  *(_QWORD *)(a1 + 280) = &off_102130188;
  *(_QWORD *)(a1 + 288) = &off_1021301E0;
  *(_QWORD *)(a1 + 296) = &off_102130238;
  *(_QWORD *)(a1 + 304) = &off_102130290;
  *(_QWORD *)(a1 + 312) = a3;
  *(_BYTE *)(a1 + 472) = 0;
  *(_BYTE *)(a1 + 480) = 0;
  *(_BYTE *)(a1 + 484) = 0;
  *(_QWORD *)(a1 + 336) = 0;
  *(_QWORD *)(a1 + 344) = 0;
  *(_QWORD *)(a1 + 328) = a2;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_BYTE *)(a1 + 464) = 0;
  *(_DWORD *)(a1 + 488) = 0;
  sub_10032BC40();
}

void sub_100326070(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, _Unwind_Exception *exception_object, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28)
{
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;

  if (*(char *)(v36 - 89) < 0)
    operator delete(*(void **)(v36 - 112));
  v37 = *(void **)(v32 + 440);
  if (v37)
  {
    *(_QWORD *)(v32 + 448) = v37;
    operator delete(v37);
  }
  if (*(char *)(v32 + 391) < 0)
    operator delete(*(void **)(v32 + 368));
  nullsub_34(v32 + 304);
  nullsub_34(v32 + 296);
  nullsub_34(v32 + 288);
  nullsub_34(v32 + 280);
  nullsub_34(v32 + 272);
  nullsub_34(v32 + 264);
  nullsub_34(v32 + 256);
  nullsub_34(v34);
  nullsub_34(v33);
  nullsub_34(v31);
  nullsub_34(v30);
  nullsub_34(v29);
  nullsub_34(v28);
  nullsub_34(v35);
  nullsub_34(a15);
  nullsub_34(a16);
  nullsub_34(a17);
  nullsub_34(a18);
  nullsub_34(a19);
  nullsub_34(a20);
  nullsub_34(a21);
  nullsub_34(a22);
  nullsub_34(a23);
  nullsub_34(a24);
  nullsub_34(a25);
  nullsub_34(a26);
  nullsub_34(a27);
  nullsub_34(a28);
  nullsub_34(*(_QWORD *)(v36 - 144));
  nullsub_34(*(_QWORD *)(v36 - 136));
  nullsub_34(*(_QWORD *)(v36 - 128));
  sub_1002E6784(*(_QWORD **)(v36 - 120));
  _Unwind_Resume(a1);
}

_QWORD *sub_1003261E0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  NSObject *v6;
  double v7;
  double v8;
  double v9;
  NSObject *v10;
  uint64_t v11;
  __int128 v12;
  NSObject *v13;
  NSObject *v14;
  _QWORD *result;
  BOOL v16;
  _BOOL4 v20;
  const char *v21;
  char *v22;
  _WORD v23[8];
  _BYTE buf[1632];

  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_1021302D8);
  v6 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289026;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = "";
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"LOI Manager: handleVisitEntry\"}", buf, 0x12u);
  }
  objc_msgSend(*(id *)(a2 + 32), "coordinate");
  v8 = v7;
  objc_msgSend(*(id *)(a2 + 32), "coordinate");
  if (sub_100008478(a1, v8, v9))
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v10 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "LOI Manager, requested LOI for current visit location", buf, 2u);
    }
    if (sub_1001BFF7C(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      v23[0] = 0;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "LOI Manager, requested LOI for current visit location", v23, 2);
      v22 = (char *)v21;
      sub_100512490("Generic", 1, 0, 2, "std::optional<std::string> CLMicroLocationLoiManager::VisitEntry(const CLMiLoLoiManagerLoiVisitEntryEvent *)", "%s\n", v21);
      if (v22 != buf)
        free(v22);
    }
    v11 = *(_QWORD *)(a1 + 16);
    if (*(char *)(v11 + 31) < 0)
    {
      sub_100115CE4(buf, *(void **)(v11 + 8), *(_QWORD *)(v11 + 16));
    }
    else
    {
      v12 = *(_OWORD *)(v11 + 8);
      *(_QWORD *)&buf[16] = *(_QWORD *)(v11 + 24);
      *(_OWORD *)buf = v12;
    }
    if ((buf[23] & 0x80000000) != 0)
    {
      if (*(_QWORD *)&buf[8] != 17)
      {
        operator delete(*(void **)buf);
        goto LABEL_48;
      }
      v20 = **(_QWORD **)buf != 0x20656D6F48206E49
         || *(_QWORD *)(*(_QWORD *)buf + 8) != 0x7461745320494F4CLL
         || *(_BYTE *)(*(_QWORD *)buf + 16) != 101;
      operator delete(*(void **)buf);
      if (v20)
        goto LABEL_48;
    }
    else
    {
      if (buf[23] != 17)
        goto LABEL_48;
      v16 = *(_QWORD *)buf == 0x20656D6F48206E49 && *(_QWORD *)&buf[8] == 0x7461745320494F4CLL;
      if (!v16 || buf[16] != 101)
        goto LABEL_48;
    }
    sub_10032DBC0(a1, 1);
LABEL_48:
    result = sub_1015A2E04(buf, "In the process of entering Home LOI");
    goto LABEL_49;
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_1021302D8);
  v13 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 68289026;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = "";
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Failed To request LOI for current visit location\"}", buf, 0x12u);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
  }
  v14 = qword_1022A00F8;
  if (os_signpost_enabled((os_log_t)qword_1022A00F8))
  {
    *(_DWORD *)buf = 68289026;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = "";
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Failed To request LOI for current visit location", "{\"msg%{public}.0s\":\"LOI Manager, Failed To request LOI for current visit location\"}", buf, 0x12u);
  }
  std::string::assign((std::string *)(a1 + 368), "unknown");
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_QWORD *)(a1 + 448) = *(_QWORD *)(a1 + 440);
  if (*(_BYTE *)(a1 + 484))
    *(_BYTE *)(a1 + 484) = 0;
  result = sub_1015A2E04(buf, "Not in Active Location State");
LABEL_49:
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

double sub_100326684@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6;
  NSObject *v7;
  std::string *p_p;
  NSObject *v9;
  std::string *v10;
  uint64_t v11;
  __int128 v12;
  double result;
  std::string __p;
  _BYTE buf[28];

  v6 = a2 + 32;
  if ((sub_10032DCC0(a1, *(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 40)) & 1) != 0)
  {
    sub_10032D110(a1, *(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 40), buf);
  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v7 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_10026A098(v6, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(_QWORD *)buf = &off_10212A508;
        sub_10026A9C8((uint64_t)buf);
      }
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = p_p;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
    v9 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_10026A098(v6, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(_QWORD *)buf = &off_10212A508;
        sub_10026A9C8((uint64_t)buf);
      }
      v10 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v10 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v10;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring", "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    sub_10032DD6C(a1, (uint64_t)CFSTR("Generic Failure"), (uint64_t)CFSTR("Invalid Geofence Entry"));
    v11 = *(_QWORD *)(a1 + 16);
    if (*(char *)(v11 + 31) < 0)
    {
      sub_100115CE4(buf, *(void **)(v11 + 8), *(_QWORD *)(v11 + 16));
    }
    else
    {
      v12 = *(_OWORD *)(v11 + 8);
      *(_QWORD *)&buf[16] = *(_QWORD *)(v11 + 24);
      *(_OWORD *)buf = v12;
    }
  }
  result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_100326984(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, std::bad_cast a16)
{
  std::bad_cast::~bad_cast(&a16);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(a1);
}

double sub_1003269C4@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  NSObject *v4;
  NSObject *v5;
  uint64_t v6;
  __int128 v7;
  double result;
  _BYTE v9[24];

  if (*(_BYTE *)(a1 + 472))
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v4 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
    {
      *(_QWORD *)v9 = 68289026;
      *(_WORD *)&v9[8] = 2082;
      *(_QWORD *)&v9[10] = "";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"LOI Manager, refreshing location on XPC trigger\"}", v9, 0x12u);
    }
    *(_DWORD *)(a1 + 480) = 5;
    *(_BYTE *)(a1 + 484) = 1;
    sub_100008478(a1, *(double *)(a1 + 336), *(double *)(a1 + 344));
    sub_1015A2E04(v9, "In the process of entering Home LOI");
  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v5 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
    {
      *(_QWORD *)v9 = 68289026;
      *(_WORD *)&v9[8] = 2082;
      *(_QWORD *)&v9[10] = "";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"refreshRoutineStateAtLastLocation, won't run, last location not set\"}", v9, 0x12u);
    }
    v6 = *(_QWORD *)(a1 + 16);
    if (*(char *)(v6 + 31) < 0)
    {
      sub_100115CE4(v9, *(void **)(v6 + 8), *(_QWORD *)(v6 + 16));
    }
    else
    {
      v7 = *(_OWORD *)(v6 + 8);
      *(_QWORD *)&v9[16] = *(_QWORD *)(v6 + 24);
      *(_OWORD *)v9 = v7;
    }
  }
  result = *(double *)v9;
  *(_OWORD *)a2 = *(_OWORD *)v9;
  *(_QWORD *)(a2 + 16) = *(_QWORD *)&v9[16];
  *(_BYTE *)(a2 + 24) = 1;
  return result;
}

double sub_100326BA4@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  double result;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;

  *(_DWORD *)(a1 + 480) = *(_DWORD *)(a2 + 32);
  *(_BYTE *)(a1 + 484) = 1;
  if (sub_10032DE38(a1))
  {
    sub_1015A2E04(&v8, "In the process of entering Home LOI");
    result = *(double *)&v8;
    *(_OWORD *)a3 = v8;
    *(_QWORD *)(a3 + 16) = v9;
    *(_BYTE *)(a3 + 24) = 1;
  }
  else
  {
    if (*(_BYTE *)(a1 + 484))
      *(_BYTE *)(a1 + 484) = 0;
    v6 = *(_QWORD *)(a1 + 16);
    if (*(char *)(v6 + 31) < 0)
    {
      sub_100115CE4(&v8, *(void **)(v6 + 8), *(_QWORD *)(v6 + 16));
    }
    else
    {
      v7 = *(_OWORD *)(v6 + 8);
      v9 = *(_QWORD *)(v6 + 24);
      v8 = v7;
    }
    result = *(double *)&v8;
    *(_OWORD *)a3 = v8;
    *(_QWORD *)(a3 + 16) = v9;
    *(_BYTE *)(a3 + 24) = 1;
  }
  return result;
}

double sub_100326C64@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  NSObject *v4;
  double result;
  _BYTE v6[24];

  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_1021302D8);
  v4 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_QWORD *)v6 = 68289026;
    *(_WORD *)&v6[8] = 2082;
    *(_QWORD *)&v6[10] = "";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"LOI Manager: handleVisitExit\"}", v6, 0x12u);
  }
  sub_10032DBC0(a1, 2);
  sub_1015A2E04(v6, "Not in Active Location State");
  result = *(double *)v6;
  *(_OWORD *)a2 = *(_OWORD *)v6;
  *(_QWORD *)(a2 + 16) = *(_QWORD *)&v6[16];
  *(_BYTE *)(a2 + 24) = 1;
  return result;
}

double sub_100326D80@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  NSObject *v6;
  double result;
  const char *v8;
  uint8_t *v9;
  _WORD v10[8];
  uint8_t buf[16];
  uint64_t v12;

  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_1021302D8);
  v6 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#LOI Manager, In Home LOI, exit it before creating custom LOI process", buf, 2u);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v10[0] = 0;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#LOI Manager, In Home LOI, exit it before creating custom LOI process", v10, 2);
    v9 = (uint8_t *)v8;
    sub_100512490("Generic", 1, 0, 2, "std::optional<std::string> CLMicroLocationLoiManager::EnableCustomLoiWhileInHomeLoi(const CLMiLoLoiManagerEnableCustomLoiEvent *)", "%s\n", v8);
    if (v9 != buf)
      free(v9);
  }
  sub_10032DBC0(a1, 9);
  sub_10032D394(a1, *(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 40), buf);
  result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = v12;
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

double sub_100326F58@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6;
  NSObject *v7;
  std::string *p_p;
  NSObject *v9;
  std::string *v10;
  uint64_t v11;
  __int128 v12;
  double result;
  std::string __p;
  _BYTE buf[28];

  v6 = a2 + 32;
  if ((sub_10032DCC0(a1, *(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 40)) & 1) != 0)
  {
    sub_10032DBC0(a1, 10);
    sub_10032D110(a1, *(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 40), buf);
  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v7 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_10026A098(v6, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(_QWORD *)buf = &off_10212A508;
        sub_10026A9C8((uint64_t)buf);
      }
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = p_p;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
    v9 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_10026A098(v6, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(_QWORD *)buf = &off_10212A508;
        sub_10026A9C8((uint64_t)buf);
      }
      v10 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v10 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v10;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring", "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    sub_10032DD6C(a1, (uint64_t)CFSTR("Generic Failure"), (uint64_t)CFSTR("Invalid Geofence Entry"));
    v11 = *(_QWORD *)(a1 + 16);
    if (*(char *)(v11 + 31) < 0)
    {
      sub_100115CE4(buf, *(void **)(v11 + 8), *(_QWORD *)(v11 + 16));
    }
    else
    {
      v12 = *(_OWORD *)(v11 + 8);
      *(_QWORD *)&buf[16] = *(_QWORD *)(v11 + 24);
      *(_OWORD *)buf = v12;
    }
  }
  result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_100327264(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, std::bad_cast a16)
{
  std::bad_cast::~bad_cast(&a16);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(a1);
}

double sub_1003272A4@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  double result;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;

  if (*(_DWORD *)(a2 + 32) == 3)
  {
    *(_DWORD *)(a1 + 480) = 3;
    *(_BYTE *)(a1 + 484) = 1;
    if (sub_10032DE38(a1))
    {
      sub_1015A2E04(&v8, "In the process of entering Home LOI");
      result = *(double *)&v8;
      *(_OWORD *)a3 = v8;
      *(_QWORD *)(a3 + 16) = v9;
      *(_BYTE *)(a3 + 24) = 1;
      return result;
    }
    if (*(_BYTE *)(a1 + 484))
      *(_BYTE *)(a1 + 484) = 0;
  }
  v6 = *(_QWORD *)(a1 + 16);
  if (*(char *)(v6 + 31) < 0)
  {
    sub_100115CE4(&v8, *(void **)(v6 + 8), *(_QWORD *)(v6 + 16));
  }
  else
  {
    v7 = *(_OWORD *)(v6 + 8);
    v9 = *(_QWORD *)(v6 + 24);
    v8 = v7;
  }
  result = *(double *)&v8;
  *(_OWORD *)a3 = v8;
  *(_QWORD *)(a3 + 16) = v9;
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

double sub_100327370@<D0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  NSObject *v6;
  std::string *v7;
  NSObject *v8;
  std::string *v9;
  uint64_t v10;
  NSObject *v11;
  std::string *p_p;
  NSObject *v13;
  std::string *v14;
  __int128 v15;
  NSObject *v16;
  std::string *v17;
  double result;
  std::string __p;
  _BYTE buf[28];
  __int128 v21;

  v21 = *(_OWORD *)(a2 + 32);
  if ((sub_10032DCC0((uint64_t)a1, v21, *((uint64_t *)&v21 + 1)) & 1) == 0)
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v11 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_10026A098((uint64_t)&v21, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(_QWORD *)buf = &off_10212A508;
        sub_10026A9C8((uint64_t)buf);
      }
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = p_p;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
    v13 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_10026A098((uint64_t)&v21, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(_QWORD *)buf = &off_10212A508;
        sub_10026A9C8((uint64_t)buf);
      }
      v14 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v14 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v14;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v13, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring", "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    sub_10032DD6C((uint64_t)a1, (uint64_t)CFSTR("Generic Failure"), (uint64_t)CFSTR("Invalid Geofence Exit"));
    v10 = a1[2];
    if (*(char *)(v10 + 31) < 0)
      goto LABEL_51;
LABEL_41:
    v15 = *(_OWORD *)(v10 + 8);
    *(_QWORD *)&buf[16] = *(_QWORD *)(v10 + 24);
    *(_OWORD *)buf = v15;
    goto LABEL_52;
  }
  if (a1[49] != (_QWORD)v21 || a1[50] != *((_QWORD *)&v21 + 1))
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v6 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_10026A098((uint64_t)&v21, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(_QWORD *)buf = &off_10212A508;
        sub_10026A9C8((uint64_t)buf);
      }
      v7 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v7 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, got geofence exit for an LOI which is not the currently the active LOI, this may happen if we jumped from one geofence to another and the entry for the new geofence arrived first\", \"regionID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
    v8 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_10026A098((uint64_t)&v21, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(_QWORD *)buf = &off_10212A508;
        sub_10026A9C8((uint64_t)buf);
      }
      v9 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v9 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v9;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v8, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, got geofence exit for an LOI which is not the currently the active LOI, this may happen if we jumped from one geofence to another and the entry for the new geofence arrived first", "{\"msg%{public}.0s\":\"#LOI Manager, got geofence exit for an LOI which is not the currently the active LOI, this may happen if we jumped from one geofence to another and the entry for the new geofence arrived first\", \"regionID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    v10 = a1[2];
    if (*(char *)(v10 + 31) < 0)
    {
LABEL_51:
      sub_100115CE4(buf, *(void **)(v10 + 8), *(_QWORD *)(v10 + 16));
      goto LABEL_52;
    }
    goto LABEL_41;
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_1021302D8);
  v16 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    memset(&__p, 0, sizeof(__p));
    if ((sub_10026A098((uint64_t)&v21, &__p) & 1) == 0)
    {
      std::bad_cast::bad_cast((std::bad_cast *)buf);
      *(_QWORD *)buf = &off_10212A508;
      sub_10026A9C8((uint64_t)buf);
    }
    v17 = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v17 = (std::string *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 68289283;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = "";
    *(_WORD *)&buf[18] = 2081;
    *(_QWORD *)&buf[20] = v17;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, got geofence exit for active LOI\", \"regionID\":%{private, location:escape_only}s}", buf, 0x1Cu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  sub_10032DBC0((uint64_t)a1, 11);
  sub_1015A2E04(buf, "Not in Active Location State");
LABEL_52:
  result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_1003279C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, std::bad_cast a16)
{
  std::bad_cast::~bad_cast(&a16);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(a1);
}

double sub_100327A1C@<D0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  NSObject *v5;
  std::string *p_p;
  NSObject *v7;
  std::string *v8;
  NSObject *v10;
  std::string *v11;
  NSObject *v12;
  std::string *v13;
  NSObject *v14;
  std::string *v15;
  uint64_t v16;
  __int128 v17;
  double result;
  std::string __p;
  _BYTE buf[28];
  __int128 v21;

  v21 = *(_OWORD *)(a2 + 32);
  if ((sub_10032DCC0((uint64_t)a1, v21, *((uint64_t *)&v21 + 1)) & 1) == 0)
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v5 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_10026A098((uint64_t)&v21, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(_QWORD *)buf = &off_10212A508;
        sub_10026A9C8((uint64_t)buf);
      }
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = p_p;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
    v7 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_10026A098((uint64_t)&v21, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(_QWORD *)buf = &off_10212A508;
        sub_10026A9C8((uint64_t)buf);
      }
      v8 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v8 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v8;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v7, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring", "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    sub_10032DD6C((uint64_t)a1, (uint64_t)CFSTR("Generic Failure"), (uint64_t)CFSTR("Invalid Geofence Entry"));
  }
  if (a1[49] == (_QWORD)v21 && a1[50] == *((_QWORD *)&v21 + 1))
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v12 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_10026A098((uint64_t)&v21, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(_QWORD *)buf = &off_10212A508;
        sub_10026A9C8((uint64_t)buf);
      }
      v13 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v13 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, got geofence entry for the current active LOI which shouldn't happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
    v14 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_10026A098((uint64_t)&v21, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(_QWORD *)buf = &off_10212A508;
        sub_10026A9C8((uint64_t)buf);
      }
      v15 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v15 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v15;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, got geofence entry for the current active LOI which shouldn't happen... ignoring", "{\"msg%{public}.0s\":\"#LOI Manager, got geofence entry for the current active LOI which shouldn't happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v10 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_10026A098((uint64_t)&v21, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(_QWORD *)buf = &off_10212A508;
        sub_10026A9C8((uint64_t)buf);
      }
      v11 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v11 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, got geofence entry for different valid LOI, entering it\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    sub_10032DBC0((uint64_t)a1, 11);
    sub_10032D2E4((uint64_t)a1, v21, *((uint64_t *)&v21 + 1), 10);
  }
  v16 = a1[2];
  if (*(char *)(v16 + 31) < 0)
  {
    sub_100115CE4(buf, *(void **)(v16 + 8), *(_QWORD *)(v16 + 16));
  }
  else
  {
    v17 = *(_OWORD *)(v16 + 8);
    *(_QWORD *)&buf[16] = *(_QWORD *)(v16 + 24);
    *(_OWORD *)buf = v17;
  }
  result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_100328048(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, std::bad_cast a16)
{
  std::bad_cast::~bad_cast(&a16);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(a1);
}

double sub_1003280A0@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  __int128 v6;
  double result;
  __int128 v8;
  uint64_t v9;

  sub_10032E09C(a1, *(_QWORD *)(a1 + 392), *(_QWORD *)(a1 + 400), a2 + 32);
  sub_10032D2E4(a1, *(_QWORD *)(a1 + 392), *(_QWORD *)(a1 + 400), 10);
  (***(void (****)(_QWORD, uint64_t))(a1 + 328))(*(_QWORD *)(a1 + 328), -1);
  v5 = *(_QWORD *)(a1 + 16);
  if (*(char *)(v5 + 31) < 0)
  {
    sub_100115CE4(&v8, *(void **)(v5 + 8), *(_QWORD *)(v5 + 16));
  }
  else
  {
    v6 = *(_OWORD *)(v5 + 8);
    v9 = *(_QWORD *)(v5 + 24);
    v8 = v6;
  }
  result = *(double *)&v8;
  *(_OWORD *)a3 = v8;
  *(_QWORD *)(a3 + 16) = v9;
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

double sub_100328140@<D0>(_QWORD *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  BOOL v6;
  NSObject *v7;
  uint64_t v8;
  __int128 v9;
  double result;
  void *__p;
  char v12;
  _BYTE buf[24];

  sub_10032D61C((uint64_t)a1, a2[4], a2[5], a2[6], a2[7], (uint64_t)&__p);
  if (v12 < 0)
    operator delete(__p);
  v6 = a1[49] == a2[4] && a1[50] == a2[5];
  if (v6 && sub_10032DB3C((uint64_t)a1, a2[4], a2[5]))
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v7 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 68289026;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, Since we are in the LOI exit LOI\"}", buf, 0x12u);
    }
    sub_10032DBC0((uint64_t)a1, 9);
    sub_1015A2E04(buf, "Not in Active Location State");
  }
  else
  {
    v8 = a1[2];
    if (*(char *)(v8 + 31) < 0)
    {
      sub_100115CE4(buf, *(void **)(v8 + 8), *(_QWORD *)(v8 + 16));
    }
    else
    {
      v9 = *(_OWORD *)(v8 + 8);
      *(_QWORD *)&buf[16] = *(_QWORD *)(v8 + 24);
      *(_OWORD *)buf = v9;
    }
  }
  result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

double sub_1003282D8@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  uint64_t v6;
  double result;
  __int128 v8;
  uint64_t v9;

  v5 = *(_QWORD *)(a2 + 32);
  v6 = *(_QWORD *)(a2 + 40);
  std::string::assign((std::string *)(a1 + 368), "unknown");
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_QWORD *)(a1 + 448) = *(_QWORD *)(a1 + 440);
  if (*(_BYTE *)(a1 + 484))
    *(_BYTE *)(a1 + 484) = 0;
  sub_10032D394(a1, v5, v6, &v8);
  result = *(double *)&v8;
  *(_OWORD *)a3 = v8;
  *(_QWORD *)(a3 + 16) = v9;
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

double sub_100328368@<D0>(uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  NSObject *v6;
  uint64_t v7;
  __int128 v8;
  int v9;
  void **v10;
  void **v11;
  void **v12;
  NSObject *v13;
  uint64_t v14;
  __int128 v15;
  int v16;
  void **v17;
  void **v18;
  void **v19;
  uint64_t v20;
  __int128 v21;
  double result;
  void *__p[2];
  char v24;
  void *__dst[2];
  uint64_t v26;
  _BYTE buf[28];
  __int16 v28;
  void **v29;

  if (*(_BYTE *)(a1 + 488))
  {
    sub_10032DD6C(a1, (uint64_t)CFSTR("Home LOI Entry Failure"), (uint64_t)CFSTR("LOI Fetch Failure"));
    std::string::assign((std::string *)(a1 + 368), "unknown");
    *(_OWORD *)(a1 + 392) = 0u;
    *(_OWORD *)(a1 + 408) = 0u;
    *(_QWORD *)(a1 + 448) = *(_QWORD *)(a1 + 440);
    if (*(_BYTE *)(a1 + 484))
      *(_BYTE *)(a1 + 484) = 0;
    sub_1015A2E04(buf, "Not in Active Location State");
  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v6 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      v7 = *(_QWORD *)(a1 + 16);
      if (*(char *)(v7 + 31) < 0)
      {
        sub_100115CE4(__dst, *(void **)(v7 + 8), *(_QWORD *)(v7 + 16));
      }
      else
      {
        v8 = *(_OWORD *)(v7 + 8);
        v26 = *(_QWORD *)(v7 + 24);
        *(_OWORD *)__dst = v8;
      }
      v9 = SHIBYTE(v26);
      v10 = (void **)__dst[0];
      sub_1002E6448(a2, (uint64_t)__p);
      v11 = __dst;
      if (v9 < 0)
        v11 = v10;
      if (v24 >= 0)
        v12 = __p;
      else
        v12 = (void **)__p[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v11;
      v28 = 2081;
      v29 = v12;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v24 < 0)
        operator delete(__p[0]);
      if (SHIBYTE(v26) < 0)
        operator delete(__dst[0]);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
    v13 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      v14 = *(_QWORD *)(a1 + 16);
      if (*(char *)(v14 + 31) < 0)
      {
        sub_100115CE4(__dst, *(void **)(v14 + 8), *(_QWORD *)(v14 + 16));
      }
      else
      {
        v15 = *(_OWORD *)(v14 + 8);
        v26 = *(_QWORD *)(v14 + 24);
        *(_OWORD *)__dst = v15;
      }
      v16 = SHIBYTE(v26);
      v17 = (void **)__dst[0];
      sub_1002E6448(a2, (uint64_t)__p);
      v18 = __dst;
      if (v16 < 0)
        v18 = v17;
      if (v24 >= 0)
        v19 = __p;
      else
        v19 = (void **)__p[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v18;
      v28 = 2081;
      v29 = v19;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v13, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v24 < 0)
        operator delete(__p[0]);
      if (SHIBYTE(v26) < 0)
        operator delete(__dst[0]);
    }
    v20 = *(_QWORD *)(a1 + 16);
    if (*(char *)(v20 + 31) < 0)
    {
      sub_100115CE4(buf, *(void **)(v20 + 8), *(_QWORD *)(v20 + 16));
    }
    else
    {
      v21 = *(_OWORD *)(v20 + 8);
      *(_QWORD *)&buf[16] = *(_QWORD *)(v20 + 24);
      *(_OWORD *)buf = v21;
    }
  }
  result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_1003286C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1003286F0(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  double v6;
  double v7;
  double v8;
  void **v9;
  char *v10;
  size_t v11;
  uint64_t v12;
  NSObject *v13;
  id v14;
  void **v15;
  int v16;
  _DWORD *v17;
  NSObject *v18;
  uint64_t v19;
  __int128 v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  uint64_t v26;
  int v27;
  void **v28;
  void **v29;
  void **v30;
  NSObject *v31;
  uint64_t v32;
  __int128 v33;
  int v34;
  void **v35;
  void **v36;
  void **v37;
  __int128 v38;
  NSObject *v39;
  const char *v40;
  char *v41;
  const char *v42;
  char *v43;
  const char *v44;
  const char *v45;
  char *v46;
  uint64_t v47;
  void *__p[2];
  char v49;
  void *__dst[2];
  uint64_t v51;
  _BYTE buf[28];
  __int16 v53;
  void **v54;

  if (!*(_BYTE *)(a1 + 488))
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v18 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      v19 = *(_QWORD *)(a1 + 16);
      if (*(char *)(v19 + 31) < 0)
      {
        sub_100115CE4(__dst, *(void **)(v19 + 8), *(_QWORD *)(v19 + 16));
      }
      else
      {
        v20 = *(_OWORD *)(v19 + 8);
        v51 = *(_QWORD *)(v19 + 24);
        *(_OWORD *)__dst = v20;
      }
      v27 = SHIBYTE(v51);
      v28 = (void **)__dst[0];
      sub_1002E6448((char *)a2, (uint64_t)__p);
      v29 = __dst;
      if (v27 < 0)
        v29 = v28;
      if (v49 >= 0)
        v30 = __p;
      else
        v30 = (void **)__p[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v29;
      v53 = 2081;
      v54 = v30;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v49 < 0)
        operator delete(__p[0]);
      if (SHIBYTE(v51) < 0)
        operator delete(__dst[0]);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
    v31 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      v32 = *(_QWORD *)(a1 + 16);
      if (*(char *)(v32 + 31) < 0)
      {
        sub_100115CE4(__dst, *(void **)(v32 + 8), *(_QWORD *)(v32 + 16));
      }
      else
      {
        v33 = *(_OWORD *)(v32 + 8);
        v51 = *(_QWORD *)(v32 + 24);
        *(_OWORD *)__dst = v33;
      }
      v34 = SHIBYTE(v51);
      v35 = (void **)__dst[0];
      sub_1002E6448((char *)a2, (uint64_t)__p);
      v36 = __dst;
      if (v34 < 0)
        v36 = v35;
      if (v49 >= 0)
        v37 = __p;
      else
        v37 = (void **)__p[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v36;
      v53 = 2081;
      v54 = v37;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v31, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v49 < 0)
        operator delete(__p[0]);
      if (SHIBYTE(v51) < 0)
        operator delete(__dst[0]);
    }
    v26 = *(_QWORD *)(a1 + 16);
    if (*(char *)(v26 + 31) < 0)
    {
      sub_100115CE4(buf, *(void **)(v26 + 8), *(_QWORD *)(v26 + 16));
      goto LABEL_81;
    }
    goto LABEL_79;
  }
  if (objc_msgSend(*(id *)(a2 + 32), "_loiIdentifier"))
  {
    objc_msgSend(objc_msgSend(*(id *)(a2 + 32), "referenceLocation"), "coordinate");
    v7 = v6;
    objc_msgSend(objc_msgSend(*(id *)(a2 + 32), "referenceLocation"), "coordinate");
    sub_100229B0C(a1, v7, v8);
    sub_10032E674((uint64_t)objc_msgSend(*(id *)(a2 + 32), "userType"), buf);
    v9 = (void **)(a1 + 368);
    if (*(char *)(a1 + 391) < 0)
      operator delete(*v9);
    *(_OWORD *)v9 = *(_OWORD *)buf;
    *(_QWORD *)(a1 + 384) = *(_QWORD *)&buf[16];
    v10 = (char *)objc_msgSend(objc_msgSend(objc_msgSend(*(id *)(a2 + 32), "_loiIdentifier"), "UUIDString"), "UTF8String");
    v11 = strlen(v10);
    *(_QWORD *)(a1 + 408) = sub_1002B7330((uint64_t)buf, (unsigned __int8 *)v10, (unsigned __int8 *)&v10[v11]);
    *(_QWORD *)(a1 + 416) = v12;
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v13 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
    {
      v14 = objc_msgSend(objc_msgSend(objc_msgSend(*(id *)(a2 + 32), "_loiIdentifier"), "UUIDString"), "UTF8String");
      v15 = (void **)(a1 + 368);
      if (*(char *)(a1 + 391) < 0)
        v15 = (void **)*v9;
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v14;
      v53 = 2081;
      v54 = v15;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"LOI Manager, Retrieved place infernce\", \"LOI ID\":%{private, location:escape_only}s, \"LOI TYPE\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    v16 = *(char *)(a1 + 391);
    if (v16 < 0)
    {
      if (*(_QWORD *)(a1 + 376) != 4)
      {
LABEL_32:
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
        v23 = qword_1022A00F8;
        if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "LOI Manager, Not a Home LOI", buf, 2u);
        }
        if (!sub_1001BFF7C(115, 2))
          goto LABEL_37;
        bzero(buf, 0x65CuLL);
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
        LOWORD(__dst[0]) = 0;
        _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 1, "LOI Manager, Not a Home LOI", __dst, 2);
        v41 = (char *)v44;
        sub_100512490("Generic", 1, 0, 2, "std::optional<std::string> CLMicroLocationLoiManager::SuccessfullyFetchedPlaceInference(const CLMiLoLoiManagerFetchedPlaceInference *)", "%s\n", v44);
LABEL_97:
        if (v41 != buf)
          free(v41);
LABEL_37:
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
        v24 = qword_1022A00F8;
        if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_INFO, "LOI Manager, Returning to Inactive Location State", buf, 2u);
        }
        if (sub_1001BFF7C(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1022A00F0 != -1)
            dispatch_once(&qword_1022A00F0, &stru_1021302D8);
          LOWORD(__dst[0]) = 0;
          LODWORD(v47) = 2;
          _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 1, "LOI Manager, Returning to Inactive Location State", __dst, v47);
          v43 = (char *)v42;
          sub_100512490("Generic", 1, 0, 2, "std::optional<std::string> CLMicroLocationLoiManager::SuccessfullyFetchedPlaceInference(const CLMiLoLoiManagerFetchedPlaceInference *)", "%s\n", v42);
          if (v43 != buf)
            free(v43);
        }
        std::string::assign((std::string *)(a1 + 368), "unknown");
        *(_OWORD *)(a1 + 392) = 0u;
        *(_OWORD *)(a1 + 408) = 0u;
        *(_QWORD *)(a1 + 448) = *(_QWORD *)(a1 + 440);
        if (*(_BYTE *)(a1 + 484))
          *(_BYTE *)(a1 + 484) = 0;
        (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 328) + 32))(*(_QWORD *)(a1 + 328));
        sub_1015A2E04(buf, "Not in Active Location State");
        goto LABEL_81;
      }
      v17 = *v9;
    }
    else
    {
      v17 = (_DWORD *)(a1 + 368);
      if (v16 != 4)
        goto LABEL_32;
    }
    if (*v17 != 1701670760)
      goto LABEL_32;
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v25 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_INFO, "LOI Manager, fetching related LOIs for LOI", buf, 2u);
    }
    if (sub_1001BFF7C(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      LOWORD(__dst[0]) = 0;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 1, "LOI Manager, fetching related LOIs for LOI", __dst, 2);
      v46 = (char *)v45;
      sub_100512490("Generic", 1, 0, 2, "std::optional<std::string> CLMicroLocationLoiManager::SuccessfullyFetchedPlaceInference(const CLMiLoLoiManagerFetchedPlaceInference *)", "%s\n", v45);
      if (v46 != buf)
        free(v46);
    }
    if (!sub_10032E580(a1, (uint64_t)objc_msgSend(*(id *)(a2 + 32), "_loiIdentifier")))
    {
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      v39 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "LOI Manager, Failed To request related LOIs", buf, 2u);
      }
      if (!sub_1001BFF7C(115, 0))
        goto LABEL_37;
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      LOWORD(__dst[0]) = 0;
      LODWORD(v47) = 2;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 16, "LOI Manager, Failed To request related LOIs", __dst, v47);
      v41 = (char *)v40;
      sub_100512490("Generic", 1, 0, 0, "std::optional<std::string> CLMicroLocationLoiManager::SuccessfullyFetchedPlaceInference(const CLMiLoLoiManagerFetchedPlaceInference *)", "%s\n", v40);
      goto LABEL_97;
    }
    *(_WORD *)(a1 + 488) = 256;
    v26 = *(_QWORD *)(a1 + 16);
    if (*(char *)(v26 + 31) < 0)
    {
      sub_100115CE4(buf, *(void **)(v26 + 8), *(_QWORD *)(v26 + 16));
      goto LABEL_81;
    }
LABEL_79:
    v38 = *(_OWORD *)(v26 + 8);
    *(_QWORD *)&buf[16] = *(_QWORD *)(v26 + 24);
    *(_OWORD *)buf = v38;
    goto LABEL_81;
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_1021302D8);
  v21 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 68289026;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = "";
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, received nil LOI Identifier from place inference, possibly because there is no active user on macOS, we will start leeching and wait for next location update\"}", buf, 0x12u);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
  }
  v22 = qword_1022A00F8;
  if (os_signpost_enabled((os_log_t)qword_1022A00F8))
  {
    *(_DWORD *)buf = 68289026;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = "";
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v22, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, received nil LOI Identifier from place inference, possibly because there is no active user on macOS, we will start leeching and wait for next location update", "{\"msg%{public}.0s\":\"LOI Manager, received nil LOI Identifier from place inference, possibly because there is no active user on macOS, we will start leeching and wait for next location update\"}", buf, 0x12u);
  }
  std::string::assign((std::string *)(a1 + 368), "unknown");
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_QWORD *)(a1 + 448) = *(_QWORD *)(a1 + 440);
  if (*(_BYTE *)(a1 + 484))
    *(_BYTE *)(a1 + 484) = 0;
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 328) + 32))(*(_QWORD *)(a1 + 328));
  sub_1015A2E04(buf, "Not in Active Location State");
LABEL_81:
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
}

void sub_100329214(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double sub_10032923C@<D0>(uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  NSObject *v6;
  NSObject *v7;
  uint64_t v8;
  __int128 v9;
  int v10;
  void **v11;
  void **v12;
  void **v13;
  NSObject *v14;
  uint64_t v15;
  __int128 v16;
  int v17;
  void **v18;
  void **v19;
  void **v20;
  uint64_t v21;
  __int128 v22;
  double result;
  const char *v24;
  char *v25;
  void *__p[2];
  char v27;
  void *__dst[2];
  uint64_t v29;
  _BYTE buf[28];
  __int16 v31;
  void **v32;

  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_1021302D8);
  v6 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "LOI Manager, Failed To fetch place inferences", buf, 2u);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    LOWORD(__dst[0]) = 0;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 1, "LOI Manager, Failed To fetch place inferences", __dst, 2);
    v25 = (char *)v24;
    sub_100512490("Generic", 1, 0, 2, "std::optional<std::string> CLMicroLocationLoiManager::FailedToFetchedPlaceInference(const CLMiLoLoiManagerFailedToFetchPlaceInference *)", "%s\n", v24);
    if (v25 != buf)
      free(v25);
  }
  if (*(_BYTE *)(a1 + 488))
  {
    sub_10032DD6C(a1, (uint64_t)CFSTR("Home LOI Entry Failure"), (uint64_t)CFSTR("Place Inference Fetch Failure"));
    std::string::assign((std::string *)(a1 + 368), "unknown");
    *(_OWORD *)(a1 + 392) = 0u;
    *(_OWORD *)(a1 + 408) = 0u;
    *(_QWORD *)(a1 + 448) = *(_QWORD *)(a1 + 440);
    if (*(_BYTE *)(a1 + 484))
      *(_BYTE *)(a1 + 484) = 0;
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 328) + 32))(*(_QWORD *)(a1 + 328));
    sub_1015A2E04(buf, "Not in Active Location State");
  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v7 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      v8 = *(_QWORD *)(a1 + 16);
      if (*(char *)(v8 + 31) < 0)
      {
        sub_100115CE4(__dst, *(void **)(v8 + 8), *(_QWORD *)(v8 + 16));
      }
      else
      {
        v9 = *(_OWORD *)(v8 + 8);
        v29 = *(_QWORD *)(v8 + 24);
        *(_OWORD *)__dst = v9;
      }
      v10 = SHIBYTE(v29);
      v11 = (void **)__dst[0];
      sub_1002E6448(a2, (uint64_t)__p);
      v12 = __dst;
      if (v10 < 0)
        v12 = v11;
      if (v27 >= 0)
        v13 = __p;
      else
        v13 = (void **)__p[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v12;
      v31 = 2081;
      v32 = v13;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v27 < 0)
        operator delete(__p[0]);
      if (SHIBYTE(v29) < 0)
        operator delete(__dst[0]);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
    v14 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      v15 = *(_QWORD *)(a1 + 16);
      if (*(char *)(v15 + 31) < 0)
      {
        sub_100115CE4(__dst, *(void **)(v15 + 8), *(_QWORD *)(v15 + 16));
      }
      else
      {
        v16 = *(_OWORD *)(v15 + 8);
        v29 = *(_QWORD *)(v15 + 24);
        *(_OWORD *)__dst = v16;
      }
      v17 = SHIBYTE(v29);
      v18 = (void **)__dst[0];
      sub_1002E6448(a2, (uint64_t)__p);
      v19 = __dst;
      if (v17 < 0)
        v19 = v18;
      if (v27 >= 0)
        v20 = __p;
      else
        v20 = (void **)__p[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v19;
      v31 = 2081;
      v32 = v20;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v27 < 0)
        operator delete(__p[0]);
      if (SHIBYTE(v29) < 0)
        operator delete(__dst[0]);
    }
    v21 = *(_QWORD *)(a1 + 16);
    if (*(char *)(v21 + 31) < 0)
    {
      sub_100115CE4(buf, *(void **)(v21 + 8), *(_QWORD *)(v21 + 16));
    }
    else
    {
      v22 = *(_OWORD *)(v21 + 8);
      *(_QWORD *)&buf[16] = *(_QWORD *)(v21 + 24);
      *(_OWORD *)buf = v22;
    }
  }
  result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_1003296D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double sub_1003296FC@<D0>(uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  _OWORD *v6;
  uint64_t v7;
  _OWORD *v8;
  NSObject *v9;
  std::string *p_p;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v17;
  int v18;
  std::string::size_type v19;
  std::string *v20;
  void **v21;
  NSObject *v22;
  uint64_t v23;
  __int128 v24;
  int v25;
  std::string::size_type v26;
  std::string *v27;
  void **v28;
  uint64_t v29;
  __int128 v30;
  double result;
  void *v32[2];
  uint64_t v33;
  void *v34[2];
  char v35;
  std::string __p;
  _BYTE buf[28];
  __int16 v38;
  void **v39;

  if (*(_BYTE *)(a1 + 489))
  {
    v6 = (_OWORD *)(a1 + 368);
    *(_QWORD *)(a1 + 392) = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, char *))(**(_QWORD **)(a1 + 328) + 24))(*(_QWORD *)(a1 + 328), a1 + 368, a1 + 408, a2 + 32);
    *(_QWORD *)(a1 + 400) = v7;
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v8 = (_OWORD *)(a1 + 392);
    v9 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_10026A098(a1 + 392, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(_QWORD *)buf = &off_10212A508;
        sub_10026A9C8((uint64_t)buf);
      }
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = p_p;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"LOI Manager, Fetched LOI Group ID\", \"LOI Group ID \":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (*(_BYTE *)v8)
    {
LABEL_11:
      (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 328) + 40))(*(_QWORD *)(a1 + 328));
      if (*(_BYTE *)(a1 + 484))
      {
        v11 = *(unsigned int *)(a1 + 480);
        *(_BYTE *)(a1 + 484) = 0;
      }
      else
      {
        v11 = 1;
      }
      v17 = *(_QWORD *)(a1 + 328);
      if (*(char *)(a1 + 391) < 0)
      {
        sub_100115CE4(v32, *(void **)(a1 + 368), *(_QWORD *)(a1 + 376));
      }
      else
      {
        *(_OWORD *)v32 = *v6;
        v33 = *(_QWORD *)(a1 + 384);
      }
      (*(void (**)(uint64_t, void **, _QWORD, _QWORD, uint64_t))(*(_QWORD *)v17 + 16))(v17, v32, *(_QWORD *)(a1 + 392), *(_QWORD *)(a1 + 400), v11);
      if (SHIBYTE(v33) < 0)
        operator delete(v32[0]);
      sub_1015A2E04(buf, "In Home LOI State");
    }
    else
    {
      v15 = 0;
      while (v15 != 15)
      {
        if (*(unsigned __int8 *)(a1 + 393 + v15++))
        {
          if ((unint64_t)(v15 - 1) < 0xF)
            goto LABEL_11;
          break;
        }
      }
      std::string::assign((std::string *)(a1 + 368), "unknown");
      *v8 = 0u;
      *(_OWORD *)(a1 + 408) = 0u;
      *(_QWORD *)(a1 + 448) = *(_QWORD *)(a1 + 440);
      if (*(_BYTE *)(a1 + 484))
        *(_BYTE *)(a1 + 484) = 0;
      sub_1015A2E04(buf, "Not in Active Location State");
    }
  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v12 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      v13 = *(_QWORD *)(a1 + 16);
      if (*(char *)(v13 + 31) < 0)
      {
        sub_100115CE4(&__p, *(void **)(v13 + 8), *(_QWORD *)(v13 + 16));
      }
      else
      {
        v14 = *(_OWORD *)(v13 + 8);
        __p.__r_.__value_.__r.__words[2] = *(_QWORD *)(v13 + 24);
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v14;
      }
      v18 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
      v19 = __p.__r_.__value_.__r.__words[0];
      sub_1002E6448(a2, (uint64_t)v34);
      v20 = &__p;
      if (v18 < 0)
        v20 = (std::string *)v19;
      if (v35 >= 0)
        v21 = v34;
      else
        v21 = (void **)v34[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v20;
      v38 = 2081;
      v39 = v21;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v35 < 0)
        operator delete(v34[0]);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
    v22 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      v23 = *(_QWORD *)(a1 + 16);
      if (*(char *)(v23 + 31) < 0)
      {
        sub_100115CE4(&__p, *(void **)(v23 + 8), *(_QWORD *)(v23 + 16));
      }
      else
      {
        v24 = *(_OWORD *)(v23 + 8);
        __p.__r_.__value_.__r.__words[2] = *(_QWORD *)(v23 + 24);
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v24;
      }
      v25 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
      v26 = __p.__r_.__value_.__r.__words[0];
      sub_1002E6448(a2, (uint64_t)v34);
      v27 = &__p;
      if (v25 < 0)
        v27 = (std::string *)v26;
      if (v35 >= 0)
        v28 = v34;
      else
        v28 = (void **)v34[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v27;
      v38 = 2081;
      v39 = v28;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v22, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v35 < 0)
        operator delete(v34[0]);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    v29 = *(_QWORD *)(a1 + 16);
    if (*(char *)(v29 + 31) < 0)
    {
      sub_100115CE4(buf, *(void **)(v29 + 8), *(_QWORD *)(v29 + 16));
    }
    else
    {
      v30 = *(_OWORD *)(v29 + 8);
      *(_QWORD *)&buf[16] = *(_QWORD *)(v29 + 24);
      *(_OWORD *)buf = v30;
    }
  }
  result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_100329C34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,std::bad_cast a25)
{
  if (a23 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double sub_100329C84@<D0>(uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  NSObject *v6;
  uint64_t v7;
  __int128 v8;
  int v9;
  void **v10;
  void **v11;
  void **v12;
  NSObject *v13;
  uint64_t v14;
  __int128 v15;
  int v16;
  void **v17;
  void **v18;
  void **v19;
  uint64_t v20;
  __int128 v21;
  double result;
  void *__p[2];
  char v24;
  void *__dst[2];
  uint64_t v26;
  _BYTE buf[28];
  __int16 v28;
  void **v29;

  if (*(_BYTE *)(a1 + 489))
  {
    sub_10032DD6C(a1, (uint64_t)CFSTR("Home LOI Entry Failure"), (uint64_t)CFSTR("Related LOI Fetch Failure"));
    std::string::assign((std::string *)(a1 + 368), "unknown");
    *(_OWORD *)(a1 + 392) = 0u;
    *(_OWORD *)(a1 + 408) = 0u;
    *(_QWORD *)(a1 + 448) = *(_QWORD *)(a1 + 440);
    if (*(_BYTE *)(a1 + 484))
      *(_BYTE *)(a1 + 484) = 0;
    sub_1015A2E04(buf, "Not in Active Location State");
  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v6 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      v7 = *(_QWORD *)(a1 + 16);
      if (*(char *)(v7 + 31) < 0)
      {
        sub_100115CE4(__dst, *(void **)(v7 + 8), *(_QWORD *)(v7 + 16));
      }
      else
      {
        v8 = *(_OWORD *)(v7 + 8);
        v26 = *(_QWORD *)(v7 + 24);
        *(_OWORD *)__dst = v8;
      }
      v9 = SHIBYTE(v26);
      v10 = (void **)__dst[0];
      sub_1002E6448(a2, (uint64_t)__p);
      v11 = __dst;
      if (v9 < 0)
        v11 = v10;
      if (v24 >= 0)
        v12 = __p;
      else
        v12 = (void **)__p[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v11;
      v28 = 2081;
      v29 = v12;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v24 < 0)
        operator delete(__p[0]);
      if (SHIBYTE(v26) < 0)
        operator delete(__dst[0]);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
    v13 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      v14 = *(_QWORD *)(a1 + 16);
      if (*(char *)(v14 + 31) < 0)
      {
        sub_100115CE4(__dst, *(void **)(v14 + 8), *(_QWORD *)(v14 + 16));
      }
      else
      {
        v15 = *(_OWORD *)(v14 + 8);
        v26 = *(_QWORD *)(v14 + 24);
        *(_OWORD *)__dst = v15;
      }
      v16 = SHIBYTE(v26);
      v17 = (void **)__dst[0];
      sub_1002E6448(a2, (uint64_t)__p);
      v18 = __dst;
      if (v16 < 0)
        v18 = v17;
      if (v24 >= 0)
        v19 = __p;
      else
        v19 = (void **)__p[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v18;
      v28 = 2081;
      v29 = v19;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v13, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v24 < 0)
        operator delete(__p[0]);
      if (SHIBYTE(v26) < 0)
        operator delete(__dst[0]);
    }
    v20 = *(_QWORD *)(a1 + 16);
    if (*(char *)(v20 + 31) < 0)
    {
      sub_100115CE4(buf, *(void **)(v20 + 8), *(_QWORD *)(v20 + 16));
    }
    else
    {
      v21 = *(_OWORD *)(v20 + 8);
      *(_QWORD *)&buf[16] = *(_QWORD *)(v20 + 24);
      *(_OWORD *)buf = v21;
    }
  }
  result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_100329FE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double sub_10032A00C@<D0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  __int128 *v6;
  __int128 *v7;
  _QWORD *v8;
  NSObject *v10;
  std::string *p_p;
  _OWORD *v12;
  unint64_t v13;
  _OWORD *v14;
  _OWORD *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  NSObject *v22;
  std::string *v23;
  NSObject *v24;
  std::string *v25;
  uint64_t v26;
  char *v27;
  char *v28;
  char *v29;
  char *v30;
  __int128 v31;
  double result;
  std::string __p;
  _BYTE buf[28];
  __int128 v35;

  v6 = (__int128 *)a1[55];
  v7 = (__int128 *)a1[56];
  if (v6 == v7)
  {
LABEL_8:
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v10 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_10026A098(a2 + 32, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(_QWORD *)buf = &off_10212A508;
        sub_10026A9C8((uint64_t)buf);
      }
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = p_p;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"LOI Manager, Adding new service to list of servies that have requested to enable custom LOI\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    v12 = (_OWORD *)(a2 + 32);
    v14 = (_OWORD *)a1[56];
    v13 = a1[57];
    if ((unint64_t)v14 >= v13)
    {
      v16 = a1[55];
      v17 = ((uint64_t)v14 - v16) >> 4;
      v18 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 60)
        sub_100259694();
      v19 = v13 - v16;
      if (v19 >> 3 > v18)
        v18 = v19 >> 3;
      if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF0)
        v20 = 0xFFFFFFFFFFFFFFFLL;
      else
        v20 = v18;
      if (v20)
        v21 = (char *)sub_10028E224((uint64_t)(a1 + 57), v20);
      else
        v21 = 0;
      v27 = &v21[16 * v17];
      v28 = &v21[16 * v20];
      *(_OWORD *)v27 = *v12;
      v15 = v27 + 16;
      v30 = (char *)a1[55];
      v29 = (char *)a1[56];
      if (v29 != v30)
      {
        do
        {
          *((_OWORD *)v27 - 1) = *((_OWORD *)v29 - 1);
          v27 -= 16;
          v29 -= 16;
        }
        while (v29 != v30);
        v29 = (char *)a1[55];
      }
      a1[55] = v27;
      a1[56] = v15;
      a1[57] = v28;
      if (v29)
        operator delete(v29);
    }
    else
    {
      *v14 = *v12;
      v15 = v14 + 1;
    }
    a1[56] = v15;
    v26 = a1[2];
    if (*(char *)(v26 + 31) < 0)
    {
LABEL_52:
      sub_100115CE4(buf, *(void **)(v26 + 8), *(_QWORD *)(v26 + 16));
      goto LABEL_53;
    }
  }
  else
  {
    v8 = (_QWORD *)(a2 + 32);
    while (1)
    {
      v35 = *v6;
      if ((_QWORD)v35 == *v8 && *((_QWORD *)&v35 + 1) == *(_QWORD *)(a2 + 40))
        break;
      if (++v6 == v7)
        goto LABEL_8;
    }
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v22 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_10026A098((uint64_t)v8, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(_QWORD *)buf = &off_10212A508;
        sub_10026A9C8((uint64_t)buf);
      }
      v23 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v23 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v23;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, got enable custom LOI request from the same service, ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
    v24 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_10026A098((uint64_t)v8, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(_QWORD *)buf = &off_10212A508;
        sub_10026A9C8((uint64_t)buf);
      }
      v25 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v25 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v25;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v24, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, got enable custom LOI request from the same service, ignoring", "{\"msg%{public}.0s\":\"#LOI Manager, got enable custom LOI request from the same service, ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    v26 = a1[2];
    if (*(char *)(v26 + 31) < 0)
      goto LABEL_52;
  }
  v31 = *(_OWORD *)(v26 + 8);
  *(_QWORD *)&buf[16] = *(_QWORD *)(v26 + 24);
  *(_OWORD *)buf = v31;
LABEL_53:
  result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_10032A4FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, std::bad_cast a16)
{
  std::bad_cast::~bad_cast(&a16);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(a1);
}

double sub_10032A544@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6;
  std::string *v7;
  NSString *v8;
  NSObject *v9;
  std::string *v10;
  NSObject *v11;
  std::string *p_p;
  _OWORD *v13;
  _OWORD *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  NSObject *v19;
  NSObject *v20;
  double result;
  std::string __p;
  _BYTE buf[28];
  __int128 v24;

  v24 = *(_OWORD *)(a2 + 32);
  if ((_QWORD)v24 == *(_QWORD *)(a1 + 408) && *((_QWORD *)&v24 + 1) == *(_QWORD *)(a1 + 416))
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v11 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_10026A098((uint64_t)&v24, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(_QWORD *)buf = &off_10212A508;
        sub_10026A9C8((uint64_t)buf);
      }
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = p_p;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, got geofence entry for LOI\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    sub_10032E914(a1);
    v13 = *(_OWORD **)(a1 + 440);
    v14 = *(_OWORD **)(a1 + 448);
    while (v13 != v14)
    {
      *(_OWORD *)buf = *v13;
      sub_10032E09C(a1, v24, *((uint64_t *)&v24 + 1), (uint64_t)buf);
      ++v13;
    }
    v15 = -1;
  }
  else
  {
    v6 = a1 + 408;
    if (*(_BYTE *)(a1 + 408))
    {
LABEL_6:
      memset(&__p, 0, sizeof(__p));
      if ((sub_10026A098(v6, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(_QWORD *)buf = &off_10212A508;
        sub_10026A9C8((uint64_t)buf);
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v7 = &__p;
      else
        v7 = (std::string *)__p.__r_.__value_.__r.__words[0];
      v8 = -[NSString uppercaseString](+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v7), "uppercaseString");
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      v9 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        v10 = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v10 = (std::string *)__p.__r_.__value_.__r.__words[0];
        *(_DWORD *)buf = 68289283;
        *(_DWORD *)&buf[4] = 0;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2081;
        *(_QWORD *)&buf[20] = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, Disabling geofence that we were trying to enable for custom LOI since we are failing the request\", \"loiID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      }
      objc_msgSend(*(id *)(a1 + 320), "removeGeofenceWithRegionId:", v8);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    else
    {
      v16 = 0;
      while (v16 != 15)
      {
        v17 = v16;
        if (*(unsigned __int8 *)(a1 + 409 + v16++))
        {
          if (v17 <= 0xE)
            goto LABEL_6;
          break;
        }
      }
    }
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v19 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 68289026;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, Error: tried to enable custom LOI at an active custom LOI\"}", buf, 0x12u);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
    v20 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      *(_DWORD *)buf = 68289026;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v20, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, Error: tried to enable custom LOI at an active custom LOI", "{\"msg%{public}.0s\":\"#LOI Manager, Error: tried to enable custom LOI at an active custom LOI\"}", buf, 0x12u);
    }
    v15 = 35;
  }
  std::string::assign((std::string *)(a1 + 368), "unknown");
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_QWORD *)(a1 + 448) = *(_QWORD *)(a1 + 440);
  if (*(_BYTE *)(a1 + 484))
    *(_BYTE *)(a1 + 484) = 0;
  sub_10032D2E4(a1, v24, *((uint64_t *)&v24 + 1), 10);
  (***(void (****)(_QWORD, uint64_t))(a1 + 328))(*(_QWORD *)(a1 + 328), v15);
  sub_1015A2E04(buf, "In Custom LOI State");
  result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_10032AA08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, std::bad_cast a16)
{
  std::bad_cast::~bad_cast(&a16);
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

double sub_10032AA48@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  void **v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  __int128 v17;
  int v18;
  void **v19;
  void **v20;
  void **v21;
  NSObject *v22;
  uint64_t v23;
  __int128 v24;
  int v25;
  void **v26;
  void **v27;
  void **v28;
  __int128 v29;
  double result;
  void *__p[2];
  char v32;
  void *__dst[2];
  uint64_t v34;
  _BYTE buf[28];
  __int16 v36;
  void **v37;

  if (!*(_BYTE *)(a1 + 490))
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v15 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      v16 = *(_QWORD *)(a1 + 16);
      if (*(char *)(v16 + 31) < 0)
      {
        sub_100115CE4(__dst, *(void **)(v16 + 8), *(_QWORD *)(v16 + 16));
      }
      else
      {
        v17 = *(_OWORD *)(v16 + 8);
        v34 = *(_QWORD *)(v16 + 24);
        *(_OWORD *)__dst = v17;
      }
      v18 = SHIBYTE(v34);
      v19 = (void **)__dst[0];
      sub_1002E6448((char *)a2, (uint64_t)__p);
      v20 = __dst;
      if (v18 < 0)
        v20 = v19;
      if (v32 >= 0)
        v21 = __p;
      else
        v21 = (void **)__p[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v20;
      v36 = 2081;
      v37 = v21;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v32 < 0)
        operator delete(__p[0]);
      if (SHIBYTE(v34) < 0)
        operator delete(__dst[0]);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
    v22 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      v23 = *(_QWORD *)(a1 + 16);
      if (*(char *)(v23 + 31) < 0)
      {
        sub_100115CE4(__dst, *(void **)(v23 + 8), *(_QWORD *)(v23 + 16));
      }
      else
      {
        v24 = *(_OWORD *)(v23 + 8);
        v34 = *(_QWORD *)(v23 + 24);
        *(_OWORD *)__dst = v24;
      }
      v25 = SHIBYTE(v34);
      v26 = (void **)__dst[0];
      sub_1002E6448((char *)a2, (uint64_t)__p);
      v27 = __dst;
      if (v25 < 0)
        v27 = v26;
      if (v32 >= 0)
        v28 = __p;
      else
        v28 = (void **)__p[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v27;
      v36 = 2081;
      v37 = v28;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v22, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v32 < 0)
        operator delete(__p[0]);
      if (SHIBYTE(v34) < 0)
        operator delete(__dst[0]);
    }
    v14 = *(_QWORD *)(a1 + 16);
    if (*(char *)(v14 + 31) < 0)
    {
      sub_100115CE4(buf, *(void **)(v14 + 8), *(_QWORD *)(v14 + 16));
      goto LABEL_40;
    }
    goto LABEL_39;
  }
  v6 = *(void **)(a2 + 32);
  objc_msgSend(v6, "coordinate");
  *(_QWORD *)(a1 + 336) = v7;
  objc_msgSend(v6, "coordinate");
  *(_QWORD *)(a1 + 344) = v8;
  objc_msgSend(*(id *)(a1 + 320), "removeGeofencesNearLocationWithLatitude:andLongitude:", *(double *)(a1 + 336));
  objc_msgSend(v6, "horizontalAccuracy");
  *(_QWORD *)(a1 + 352) = v9;
  objc_msgSend(v6, "verticalAccuracy");
  *(_QWORD *)(a1 + 360) = v10;
  *(_QWORD *)(a1 + 408) = 0;
  *(_QWORD *)(a1 + 416) = 0;
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_1021302D8);
  v11 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    v12 = *(_QWORD *)(a1 + 336);
    v13 = *(void ***)(a1 + 344);
    *(_DWORD *)buf = 68289539;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = "";
    *(_WORD *)&buf[18] = 2049;
    *(_QWORD *)&buf[20] = v12;
    v36 = 2049;
    v37 = v13;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, got location update to enable custom geofence\", \"latitude\":\"%{private}7f\", \"longitude\":\"%{private}7f\"}", buf, 0x26u);
  }
  objc_msgSend(*(id *)(a1 + 320), "setGeofenceAtLocation:", v6);
  *(_WORD *)(a1 + 490) = 256;
  v14 = *(_QWORD *)(a1 + 16);
  if ((*(char *)(v14 + 31) & 0x80000000) == 0)
  {
LABEL_39:
    v29 = *(_OWORD *)(v14 + 8);
    *(_QWORD *)&buf[16] = *(_QWORD *)(v14 + 24);
    *(_OWORD *)buf = v29;
    goto LABEL_40;
  }
  sub_100115CE4(buf, *(void **)(v14 + 8), *(_QWORD *)(v14 + 16));
LABEL_40:
  result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_10032AE58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double sub_10032AE80@<D0>(uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  uint64_t v9;
  __int128 v10;
  int v11;
  void **v12;
  void **v13;
  void **v14;
  NSObject *v15;
  uint64_t v16;
  __int128 v17;
  int v18;
  void **v19;
  void **v20;
  void **v21;
  uint64_t v22;
  __int128 v23;
  double result;
  void *__p[2];
  char v26;
  void *__dst[2];
  uint64_t v28;
  _BYTE buf[28];
  __int16 v30;
  void **v31;

  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_1021302D8);
  v6 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 68289026;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = "";
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, failed to get current location to enable MiLo... aborting request\"}", buf, 0x12u);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
  }
  v7 = qword_1022A00F8;
  if (os_signpost_enabled((os_log_t)qword_1022A00F8))
  {
    *(_DWORD *)buf = 68289026;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = "";
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v7, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, failed to get current location to enable MiLo... aborting request", "{\"msg%{public}.0s\":\"#LOI Manager, failed to get current location to enable MiLo... aborting request\"}", buf, 0x12u);
  }
  if (*(_BYTE *)(a1 + 490))
  {
    sub_10032DD6C(a1, (uint64_t)CFSTR("Custom LOI Entry Failure"), (uint64_t)CFSTR("Failed to get current Location"));
    (***(void (****)(_QWORD, uint64_t))(a1 + 328))(*(_QWORD *)(a1 + 328), 35);
    std::string::assign((std::string *)(a1 + 368), "unknown");
    *(_OWORD *)(a1 + 392) = 0u;
    *(_OWORD *)(a1 + 408) = 0u;
    *(_QWORD *)(a1 + 448) = *(_QWORD *)(a1 + 440);
    if (*(_BYTE *)(a1 + 484))
      *(_BYTE *)(a1 + 484) = 0;
    sub_1015A2E04(buf, "Not in Active Location State");
  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v8 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      v9 = *(_QWORD *)(a1 + 16);
      if (*(char *)(v9 + 31) < 0)
      {
        sub_100115CE4(__dst, *(void **)(v9 + 8), *(_QWORD *)(v9 + 16));
      }
      else
      {
        v10 = *(_OWORD *)(v9 + 8);
        v28 = *(_QWORD *)(v9 + 24);
        *(_OWORD *)__dst = v10;
      }
      v11 = SHIBYTE(v28);
      v12 = (void **)__dst[0];
      sub_1002E6448(a2, (uint64_t)__p);
      v13 = __dst;
      if (v11 < 0)
        v13 = v12;
      if (v26 >= 0)
        v14 = __p;
      else
        v14 = (void **)__p[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v13;
      v30 = 2081;
      v31 = v14;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v26 < 0)
        operator delete(__p[0]);
      if (SHIBYTE(v28) < 0)
        operator delete(__dst[0]);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
    v15 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      v16 = *(_QWORD *)(a1 + 16);
      if (*(char *)(v16 + 31) < 0)
      {
        sub_100115CE4(__dst, *(void **)(v16 + 8), *(_QWORD *)(v16 + 16));
      }
      else
      {
        v17 = *(_OWORD *)(v16 + 8);
        v28 = *(_QWORD *)(v16 + 24);
        *(_OWORD *)__dst = v17;
      }
      v18 = SHIBYTE(v28);
      v19 = (void **)__dst[0];
      sub_1002E6448(a2, (uint64_t)__p);
      v20 = __dst;
      if (v18 < 0)
        v20 = v19;
      if (v26 >= 0)
        v21 = __p;
      else
        v21 = (void **)__p[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v20;
      v30 = 2081;
      v31 = v21;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v26 < 0)
        operator delete(__p[0]);
      if (SHIBYTE(v28) < 0)
        operator delete(__dst[0]);
    }
    v22 = *(_QWORD *)(a1 + 16);
    if (*(char *)(v22 + 31) < 0)
    {
      sub_100115CE4(buf, *(void **)(v22 + 8), *(_QWORD *)(v22 + 16));
    }
    else
    {
      v23 = *(_OWORD *)(v22 + 8);
      *(_QWORD *)&buf[16] = *(_QWORD *)(v22 + 24);
      *(_OWORD *)buf = v23;
    }
  }
  result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_10032B300(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double sub_10032B328@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  NSObject *v6;
  std::string *v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  __int128 v11;
  int v12;
  std::string::size_type v13;
  std::string *p_p;
  void **v15;
  NSObject *v16;
  uint64_t v17;
  __int128 v18;
  int v19;
  std::string::size_type v20;
  std::string *v21;
  void **v22;
  __int128 v23;
  double result;
  void *v25[2];
  char v26;
  std::string __p;
  _BYTE buf[28];
  __int16 v29;
  void **v30;

  if (!*(_BYTE *)(a1 + 491))
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v9 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      v10 = *(_QWORD *)(a1 + 16);
      if (*(char *)(v10 + 31) < 0)
      {
        sub_100115CE4(&__p, *(void **)(v10 + 8), *(_QWORD *)(v10 + 16));
      }
      else
      {
        v11 = *(_OWORD *)(v10 + 8);
        __p.__r_.__value_.__r.__words[2] = *(_QWORD *)(v10 + 24);
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v11;
      }
      v12 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
      v13 = __p.__r_.__value_.__r.__words[0];
      sub_1002E6448((char *)a2, (uint64_t)v25);
      p_p = &__p;
      if (v12 < 0)
        p_p = (std::string *)v13;
      if (v26 >= 0)
        v15 = v25;
      else
        v15 = (void **)v25[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = p_p;
      v29 = 2081;
      v30 = v15;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v26 < 0)
        operator delete(v25[0]);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
    v16 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      v17 = *(_QWORD *)(a1 + 16);
      if (*(char *)(v17 + 31) < 0)
      {
        sub_100115CE4(&__p, *(void **)(v17 + 8), *(_QWORD *)(v17 + 16));
      }
      else
      {
        v18 = *(_OWORD *)(v17 + 8);
        __p.__r_.__value_.__r.__words[2] = *(_QWORD *)(v17 + 24);
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v18;
      }
      v19 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
      v20 = __p.__r_.__value_.__r.__words[0];
      sub_1002E6448((char *)a2, (uint64_t)v25);
      v21 = &__p;
      if (v19 < 0)
        v21 = (std::string *)v20;
      if (v26 >= 0)
        v22 = v25;
      else
        v22 = (void **)v25[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v21;
      v29 = 2081;
      v30 = v22;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v26 < 0)
        operator delete(v25[0]);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    v8 = *(_QWORD *)(a1 + 16);
    if (*(char *)(v8 + 31) < 0)
    {
      sub_100115CE4(buf, *(void **)(v8 + 8), *(_QWORD *)(v8 + 16));
      goto LABEL_44;
    }
    goto LABEL_43;
  }
  *(_OWORD *)(a1 + 408) = *(_OWORD *)(a2 + 32);
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_1021302D8);
  v6 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    memset(&__p, 0, sizeof(__p));
    if ((sub_10026A098(a1 + 408, &__p) & 1) == 0)
    {
      std::bad_cast::bad_cast((std::bad_cast *)buf);
      *(_QWORD *)buf = &off_10212A508;
      sub_10026A9C8((uint64_t)buf);
    }
    v7 = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v7 = (std::string *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 68289283;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = "";
    *(_WORD *)&buf[18] = 2081;
    *(_QWORD *)&buf[20] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, successfully set geofence, now waiting on fence entry update\", \"geofenceId\":%{private, location:escape_only}s}", buf, 0x1Cu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  v8 = *(_QWORD *)(a1 + 16);
  if ((*(char *)(v8 + 31) & 0x80000000) == 0)
  {
LABEL_43:
    v23 = *(_OWORD *)(v8 + 8);
    *(_QWORD *)&buf[16] = *(_QWORD *)(v8 + 24);
    *(_OWORD *)buf = v23;
    goto LABEL_44;
  }
  sub_100115CE4(buf, *(void **)(v8 + 8), *(_QWORD *)(v8 + 16));
LABEL_44:
  result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_10032B75C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, std::bad_cast a20)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double sub_10032B798@<D0>(uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  uint64_t v9;
  __int128 v10;
  int v11;
  void **v12;
  void **v13;
  void **v14;
  NSObject *v15;
  uint64_t v16;
  __int128 v17;
  int v18;
  void **v19;
  void **v20;
  void **v21;
  uint64_t v22;
  __int128 v23;
  double result;
  void *__p[2];
  char v26;
  void *__dst[2];
  uint64_t v28;
  _BYTE buf[28];
  __int16 v30;
  void **v31;

  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_1021302D8);
  v6 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 68289026;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = "";
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, failed to set geofence at current location to enable MiLo, failing custom loi request\"}", buf, 0x12u);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
  }
  v7 = qword_1022A00F8;
  if (os_signpost_enabled((os_log_t)qword_1022A00F8))
  {
    *(_DWORD *)buf = 68289026;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = "";
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v7, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, failed to set geofence at current location to enable MiLo, failing custom loi request", "{\"msg%{public}.0s\":\"#LOI Manager, failed to set geofence at current location to enable MiLo, failing custom loi request\"}", buf, 0x12u);
  }
  if (*(_BYTE *)(a1 + 491))
  {
    sub_10032DD6C(a1, (uint64_t)CFSTR("Custom LOI Entry Failure"), (uint64_t)CFSTR("Failed to set geofence"));
    (***(void (****)(_QWORD, uint64_t))(a1 + 328))(*(_QWORD *)(a1 + 328), 35);
    std::string::assign((std::string *)(a1 + 368), "unknown");
    *(_OWORD *)(a1 + 392) = 0u;
    *(_OWORD *)(a1 + 408) = 0u;
    *(_QWORD *)(a1 + 448) = *(_QWORD *)(a1 + 440);
    if (*(_BYTE *)(a1 + 484))
      *(_BYTE *)(a1 + 484) = 0;
    sub_1015A2E04(buf, "Not in Active Location State");
  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v8 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      v9 = *(_QWORD *)(a1 + 16);
      if (*(char *)(v9 + 31) < 0)
      {
        sub_100115CE4(__dst, *(void **)(v9 + 8), *(_QWORD *)(v9 + 16));
      }
      else
      {
        v10 = *(_OWORD *)(v9 + 8);
        v28 = *(_QWORD *)(v9 + 24);
        *(_OWORD *)__dst = v10;
      }
      v11 = SHIBYTE(v28);
      v12 = (void **)__dst[0];
      sub_1002E6448(a2, (uint64_t)__p);
      v13 = __dst;
      if (v11 < 0)
        v13 = v12;
      if (v26 >= 0)
        v14 = __p;
      else
        v14 = (void **)__p[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v13;
      v30 = 2081;
      v31 = v14;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v26 < 0)
        operator delete(__p[0]);
      if (SHIBYTE(v28) < 0)
        operator delete(__dst[0]);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
    v15 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      v16 = *(_QWORD *)(a1 + 16);
      if (*(char *)(v16 + 31) < 0)
      {
        sub_100115CE4(__dst, *(void **)(v16 + 8), *(_QWORD *)(v16 + 16));
      }
      else
      {
        v17 = *(_OWORD *)(v16 + 8);
        v28 = *(_QWORD *)(v16 + 24);
        *(_OWORD *)__dst = v17;
      }
      v18 = SHIBYTE(v28);
      v19 = (void **)__dst[0];
      sub_1002E6448(a2, (uint64_t)__p);
      v20 = __dst;
      if (v18 < 0)
        v20 = v19;
      if (v26 >= 0)
        v21 = __p;
      else
        v21 = (void **)__p[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v20;
      v30 = 2081;
      v31 = v21;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (v26 < 0)
        operator delete(__p[0]);
      if (SHIBYTE(v28) < 0)
        operator delete(__dst[0]);
    }
    v22 = *(_QWORD *)(a1 + 16);
    if (*(char *)(v22 + 31) < 0)
    {
      sub_100115CE4(buf, *(void **)(v22 + 8), *(_QWORD *)(v22 + 16));
    }
    else
    {
      v23 = *(_OWORD *)(v22 + 8);
      *(_QWORD *)&buf[16] = *(_QWORD *)(v22 + 24);
      *(_OWORD *)buf = v23;
    }
  }
  result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_10032BC18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_10032BC40()
{
  operator new();
}

void sub_10032BEBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_10032BF38()
{
  operator new();
}

void sub_10032C1B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_10032C230()
{
  operator new();
}

void sub_10032C414(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_10032C488()
{
  operator new();
}

void sub_10032C7A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_10032C808()
{
  operator delete();
}

void sub_10032C828()
{
  operator new();
}

void sub_10032CAAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_10032CB2C(uint64_t a1)
{
  _QWORD *v2;
  void *v3;

  *(_QWORD *)a1 = off_10212F828;
  *(_QWORD *)(a1 + 8) = off_10212F890;
  v2 = (_QWORD *)(a1 + 8);
  v3 = *(void **)(a1 + 440);
  if (v3)
  {
    *(_QWORD *)(a1 + 448) = v3;
    operator delete(v3);
  }
  if (*(char *)(a1 + 391) < 0)
    operator delete(*(void **)(a1 + 368));
  nullsub_34(a1 + 304);
  nullsub_34(a1 + 296);
  nullsub_34(a1 + 288);
  nullsub_34(a1 + 280);
  nullsub_34(a1 + 272);
  nullsub_34(a1 + 264);
  nullsub_34(a1 + 256);
  nullsub_34(a1 + 248);
  nullsub_34(a1 + 240);
  nullsub_34(a1 + 232);
  nullsub_34(a1 + 224);
  nullsub_34(a1 + 216);
  nullsub_34(a1 + 208);
  nullsub_34(a1 + 200);
  nullsub_34(a1 + 192);
  nullsub_34(a1 + 184);
  nullsub_34(a1 + 176);
  nullsub_34(a1 + 168);
  nullsub_34(a1 + 160);
  nullsub_34(a1 + 152);
  nullsub_34(a1 + 144);
  nullsub_34(a1 + 136);
  nullsub_34(a1 + 128);
  nullsub_34(a1 + 120);
  nullsub_34(a1 + 112);
  nullsub_34(a1 + 104);
  nullsub_34(a1 + 96);
  nullsub_34(a1 + 88);
  nullsub_34(a1 + 80);
  nullsub_34(a1 + 72);
  nullsub_34(a1 + 64);
  sub_1002E6784(v2);
  return a1;
}

uint64_t sub_10032CC88(uint64_t a1)
{
  return sub_10032CB2C(a1 - 8);
}

void sub_10032CC90(uint64_t a1)
{
  sub_10032CB2C(a1);
  operator delete();
}

void sub_10032CCB4(uint64_t a1)
{
  sub_10032CB2C(a1 - 8);
  operator delete();
}

id sub_10032CCDC(uint64_t a1, void *a2)
{
  NSObject *v4;
  id v5;
  const char *v7;
  uint8_t *v8;
  _WORD v9[8];
  uint8_t buf[1640];

  if (!a2)
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v4 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_FAULT, "FAULT: Tried to initialize LOI Manager with a nil LOI Bridge Object", buf, 2u);
    }
    if (sub_1001BFF7C(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      v9[0] = 0;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 17, "FAULT: Tried to initialize LOI Manager with a nil LOI Bridge Object", v9, 2);
      v8 = (uint8_t *)v7;
      sub_100512490("Generic", 1, 0, 0, "void CLMicroLocationLoiManager::setupWithLoiBridge(id<CLMicroLocationLoiBridgeProtocol>)", "%s\n", v7);
      if (v8 != buf)
        free(v8);
    }
  }
  v5 = a2;
  *(_QWORD *)(a1 + 320) = v5;
  return objc_msgSend(v5, "setMicroLocationLoiClient:", a1);
}

void sub_10032CE84(uint64_t a1, __int128 *a2)
{
  std::string *v4;
  uint64_t (**v5)();
  void *__p;
  char v7;
  __int128 v8;

  v4 = (std::string *)sub_1015A2E04(&__p, "No Name Given");
  v5 = off_102130308;
  v8 = *a2;
  std::string::assign(v4, "Enable Custom LOI");
  sub_1001569F0((_QWORD *)(a1 + 8), (uint64_t)&v5);
  v5 = off_10212F0B8;
  if (v7 < 0)
    operator delete(__p);
}

void sub_10032CF4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_10032CF7C(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  std::string *v8;
  uint64_t (**v9)();
  void *__p;
  char v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;

  v8 = (std::string *)sub_1015A2E04(&__p, "No Name Given");
  v9 = off_102130328;
  v12 = a2;
  v13 = a3;
  v14 = *a4;
  std::string::assign(v8, "Disable Custom LOI");
  sub_1001569F0((_QWORD *)(a1 + 8), (uint64_t)&v9);
  v9 = off_10212F0B8;
  if (v11 < 0)
    operator delete(__p);
}

void sub_10032D058(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_10032D08C(uint64_t a1)
{
  _QWORD v2[3];
  char v3;

  sub_10033875C(v2);
  sub_1001569F0((_QWORD *)(a1 + 8), (uint64_t)v2);
  v2[0] = off_10212F0B8;
  if (v3 < 0)
    operator delete((void *)v2[1]);
}

void sub_10032D0E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *sub_10032D110@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  NSObject *v8;
  std::string *p_p;
  std::string __p;
  uint8_t buf[8];
  _BYTE v13[20];
  uint64_t v14;
  uint64_t v15;

  v4 = a3;
  v5 = a2;
  v14 = a2;
  v15 = a3;
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_1021302D8);
  v8 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    memset(&__p, 0, sizeof(__p));
    if ((sub_10026A098((uint64_t)&v14, &__p) & 1) == 0)
    {
      std::bad_cast::bad_cast((std::bad_cast *)buf);
      *(_QWORD *)buf = &off_10212A508;
      sub_10026A9C8((uint64_t)buf);
    }
    p_p = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 68289283;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)v13 = 2082;
    *(_QWORD *)&v13[2] = "";
    *(_WORD *)&v13[10] = 2081;
    *(_QWORD *)&v13[12] = p_p;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, got geofence entry event for valid LOI\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    v5 = v14;
    v4 = v15;
  }
  sub_10032D2E4(a1, v5, v4, 10);
  return sub_1015A2E04(a4, "In Custom LOI State");
}

void sub_10032D2B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, std::bad_cast a16)
{
  std::bad_cast::~bad_cast(&a16);
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void sub_10032D2E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::string __p;

  sub_10032EA94(a1, (uint64_t)CFSTR("Custom Loi"), (uint64_t)CFSTR("Entry"));
  sub_1015A2E04(&__p, "custom");
  sub_10032E9DC(a1, a2, a3, &__p, a4);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  sub_10032EB30(a1, a2, a3);
}

void sub_10032D378(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *sub_10032D394@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  NSObject *v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  const char *v23;
  uint8_t *v24;
  __int16 v25[8];
  uint8_t buf[1640];

  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_1021302D8);
  v8 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#LOI Manager, kick off creating custom LOI process", buf, 2u);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v25[0] = 0;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#LOI Manager, kick off creating custom LOI process", v25, 2);
    v24 = (uint8_t *)v23;
    sub_100512490("Generic", 1, 0, 2, "std::string CLMicroLocationLoiManager::handleEnableCustomLoi(CLMiLoService::ServiceUuid)", "%s\n", v23);
    if (v24 != buf)
      free(v24);
  }
  objc_msgSend(*(id *)(a1 + 320), "getCurrentLocation");
  v10 = *(_QWORD **)(a1 + 448);
  v9 = *(_QWORD *)(a1 + 456);
  if ((unint64_t)v10 >= v9)
  {
    v12 = *(_QWORD *)(a1 + 440);
    v13 = ((uint64_t)v10 - v12) >> 4;
    v14 = v13 + 1;
    if ((unint64_t)(v13 + 1) >> 60)
      sub_100259694();
    v15 = v9 - v12;
    if (v15 >> 3 > v14)
      v14 = v15 >> 3;
    if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF0)
      v16 = 0xFFFFFFFFFFFFFFFLL;
    else
      v16 = v14;
    if (v16)
      v17 = (char *)sub_10028E224(a1 + 456, v16);
    else
      v17 = 0;
    v18 = &v17[16 * v13];
    v19 = &v17[16 * v16];
    *(_QWORD *)v18 = a2;
    *((_QWORD *)v18 + 1) = a3;
    v11 = v18 + 16;
    v21 = *(char **)(a1 + 440);
    v20 = *(char **)(a1 + 448);
    if (v20 != v21)
    {
      do
      {
        *((_OWORD *)v18 - 1) = *((_OWORD *)v20 - 1);
        v18 -= 16;
        v20 -= 16;
      }
      while (v20 != v21);
      v20 = *(char **)(a1 + 440);
    }
    *(_QWORD *)(a1 + 440) = v18;
    *(_QWORD *)(a1 + 448) = v11;
    *(_QWORD *)(a1 + 456) = v19;
    if (v20)
      operator delete(v20);
  }
  else
  {
    *v10 = a2;
    v10[1] = a3;
    v11 = v10 + 2;
  }
  *(_QWORD *)(a1 + 448) = v11;
  *(_QWORD *)(a1 + 408) = 0;
  *(_QWORD *)(a1 + 416) = 0;
  return sub_1015A2E04(a4, "In the process of entering Custom LOI");
}

void *sub_10032D61C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  std::string *v10;
  NSString *v11;
  NSObject *v12;
  std::string *v13;
  std::string *p_p;
  void *result;
  uint64_t v16;
  __int128 v17;
  std::string __p;
  std::string v19;
  uint8_t buf[8];
  _BYTE v21[20];
  __int16 v22;
  std::string *v23;
  _QWORD v24[2];
  _QWORD v25[2];

  v25[0] = a2;
  v25[1] = a3;
  v24[0] = a4;
  v24[1] = a5;
  sub_10032D8FC(a1, a2, a3, (uint64_t)v24);
  if (sub_10032DB3C(a1, a2, a3))
  {
    memset(&v19, 0, sizeof(v19));
    if ((sub_10026A098((uint64_t)v25, &v19) & 1) == 0)
    {
      std::bad_cast::bad_cast((std::bad_cast *)buf);
      *(_QWORD *)buf = &off_10212A508;
      sub_10026A9C8((uint64_t)buf);
    }
    memset(&__p, 0, sizeof(__p));
    if ((sub_10026A098((uint64_t)v24, &__p) & 1) == 0)
    {
      std::bad_cast::bad_cast((std::bad_cast *)buf);
      *(_QWORD *)buf = &off_10212A508;
      sub_10026A9C8((uint64_t)buf);
    }
    if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v10 = &v19;
    else
      v10 = (std::string *)v19.__r_.__value_.__r.__words[0];
    v11 = -[NSString uppercaseString](+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v10), "uppercaseString");
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v12 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      v13 = &v19;
      if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v13 = (std::string *)v19.__r_.__value_.__r.__words[0];
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)v21 = 2082;
      *(_QWORD *)&v21[2] = "";
      *(_WORD *)&v21[10] = 2081;
      *(_QWORD *)&v21[12] = v13;
      v22 = 2081;
      v23 = p_p;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, No More services monitoring this LOI, disable geofence for LOI\", \"loiID\":%{private, location:escape_only}s, \"Service Id\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    objc_msgSend(*(id *)(a1 + 320), "removeGeofenceWithRegionId:", v11);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v19.__r_.__value_.__l.__data_);
  }
  result = (void *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 328) + 8))(*(_QWORD *)(a1 + 328), -1);
  v16 = *(_QWORD *)(a1 + 16);
  if (*(char *)(v16 + 31) < 0)
    return sub_100115CE4((_BYTE *)a6, *(void **)(v16 + 8), *(_QWORD *)(v16 + 16));
  v17 = *(_OWORD *)(v16 + 8);
  *(_QWORD *)(a6 + 16) = *(_QWORD *)(v16 + 24);
  *(_OWORD *)a6 = v17;
  return result;
}

void sub_10032D89C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,std::bad_cast a21)
{
  std::bad_cast::~bad_cast(&a21);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  _Unwind_Resume(a1);
}

void sub_10032D8FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  NSObject *v5;
  std::string *p_p;
  std::string *v7;
  std::string __p;
  std::string v9;
  std::bad_cast v10;
  _UNKNOWN **v11;
  _UNKNOWN **v12;
  uint8_t buf[8];
  _BYTE v14[20];
  __int16 v15;
  std::string *v16;
  _QWORD v17[2];

  v17[0] = a2;
  v17[1] = a3;
  memset(&v9, 0, sizeof(v9));
  if ((sub_10026A098(a4, &v9) & 1) == 0)
  {
    std::bad_cast::bad_cast((std::bad_cast *)buf);
    *(_QWORD *)buf = &off_10212A508;
    sub_10026A9C8((uint64_t)buf);
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_1021302D8);
  v5 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
  {
    memset(&__p, 0, sizeof(__p));
    if ((sub_10026A098((uint64_t)v17, &__p) & 1) == 0)
    {
      std::bad_cast::bad_cast(&v10);
      v10.__vftable = (std::bad_cast_vtbl *)&off_10212A508;
      sub_10026A9C8((uint64_t)&v10);
    }
    p_p = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    v7 = &v9;
    if ((v9.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v7 = (std::string *)v9.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 68289539;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)v14 = 2082;
    *(_QWORD *)&v14[2] = "";
    *(_WORD *)&v14[10] = 2081;
    *(_QWORD *)&v14[12] = p_p;
    v15 = 2081;
    v16 = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"#LOI Manager, Removing LOI to Service ID mapping\", \"Location ID\":%{private, location:escape_only}s, \"Service ID\":%{private, location:escape_only}s}", buf, 0x26u);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  sub_10028424C(*(_QWORD *)(a1 + 312), (uint64_t)&v9, (uint64_t)v17);
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v9.__r_.__value_.__l.__data_);
}

void sub_10032DAE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,std::bad_cast a22,uint64_t a23,uint64_t a24,std::bad_cast a25)
{
  std::bad_cast::~bad_cast(&a22);
  if (a15 < 0)
    operator delete(__p);
  if (a21 < 0)
    operator delete(a16);
  _Unwind_Resume(a1);
}

BOOL sub_10032DB3C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _BOOL8 v3;
  _QWORD v5[3];
  void **v6;
  _QWORD v7[2];

  v7[0] = a2;
  v7[1] = a3;
  sub_100284264(*(_QWORD *)(a1 + 312), (uint64_t)v7, v5);
  v3 = v5[1] == v5[0];
  v6 = (void **)v5;
  sub_100259608(&v6);
  return v3;
}

void sub_10032DBC0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *__p[2];
  uint64_t v8;

  if ((_DWORD)a2 == 11)
    sub_10032EA94(a1, (uint64_t)CFSTR("Custom Loi"), (uint64_t)CFSTR("Exit"));
  std::string::assign((std::string *)(a1 + 368), "unknown");
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_QWORD *)(a1 + 448) = *(_QWORD *)(a1 + 440);
  if (*(_BYTE *)(a1 + 484))
    *(_BYTE *)(a1 + 484) = 0;
  v4 = *(_QWORD *)(a1 + 328);
  if (*(char *)(a1 + 391) < 0)
  {
    sub_100115CE4(__p, *(void **)(a1 + 368), *(_QWORD *)(a1 + 376));
    v6 = *(_QWORD *)(a1 + 392);
    v5 = *(_QWORD *)(a1 + 400);
  }
  else
  {
    v5 = 0;
    v6 = 0;
    *(_OWORD *)__p = *(_OWORD *)(a1 + 368);
    v8 = *(_QWORD *)(a1 + 384);
  }
  (*(void (**)(uint64_t, void **, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v4 + 16))(v4, __p, v6, v5, a2);
  if (SHIBYTE(v8) < 0)
    operator delete(__p[0]);
}

void sub_10032DCA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_10032DCC0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  char v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v8;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;

  v12 = a2;
  v13 = a3;
  sub_100284530(*(_QWORD *)(a1 + 312), &v10);
  if (v10 == v11)
  {
    v3 = 0;
    if (!v10)
      return v3 & 1;
    goto LABEL_11;
  }
  v3 = 0;
  v4 = v10;
  do
  {
    v5 = *v4;
    v6 = v4[1];
    v4 += 2;
    v8 = v12 == v5 && v13 == v6;
    v3 |= v8;
  }
  while (v4 != v11);
  if (v10)
LABEL_11:
    operator delete(v10);
  return v3 & 1;
}

void sub_10032DD6C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  _QWORD *v4;
  NSDictionary *v5;
  _QWORD v6[4];
  _QWORD v7[4];

  v6[0] = CFSTR("loiRelatedFailureOccurred");
  v6[1] = CFSTR("failureType");
  v7[0] = &off_10221B030;
  v7[1] = a2;
  v7[2] = a3;
  v6[2] = CFSTR("failureReason");
  v6[3] = CFSTR("fsmStateDuringFailure");
  v3 = *(_QWORD *)(a1 + 16);
  v4 = (_QWORD *)(v3 + 8);
  if (*(char *)(v3 + 31) < 0)
    v4 = (_QWORD *)*v4;
  v7[3] = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v4);
  v5 = +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v7, v6, 4);
  sub_10032EC70((uint64_t)v5, CFSTR("com.apple.MicroLocation.LOIFailures"), (uint64_t)v5);
}

BOOL sub_10032DE38(uint64_t a1)
{
  NSObject *v2;
  void **v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  void *__p[2];
  char v9;
  uint8_t buf[4];
  int v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  void **v15;

  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_1021302D8);
  v2 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    if (!*(_BYTE *)(a1 + 484))
      sub_10028DF3C();
    sub_100357644(*(_DWORD *)(a1 + 480), __p);
    if (v9 >= 0)
      v3 = __p;
    else
      v3 = (void **)__p[0];
    *(_DWORD *)buf = 68289283;
    v11 = 0;
    v12 = 2082;
    v13 = "";
    v14 = 2081;
    v15 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"LOI Manager, Attempting to fetch place inference\", \"Reason:\":%{private, location:escape_only}s}", buf, 0x1Cu);
    if (v9 < 0)
      operator delete(__p[0]);
  }
  v4 = *(_QWORD *)(a1 + 320);
  if (v4)
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 328) + 40))(*(_QWORD *)(a1 + 328));
    objc_msgSend(*(id *)(a1 + 320), "fetchPlaceInferenceAtCurrentLocation");
  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v5 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 68289026;
      v11 = 0;
      v12 = 2082;
      v13 = "";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#Warning LOI Bridge not setup.\"}", buf, 0x12u);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
    v6 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      *(_DWORD *)buf = 68289026;
      v11 = 0;
      v12 = 2082;
      v13 = "";
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v6, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#Warning LOI Bridge not setup.", "{\"msg%{public}.0s\":\"#Warning LOI Bridge not setup.\"}", buf, 0x12u);
    }
  }
  return v4 != 0;
}

void sub_10032E09C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  NSObject *v5;
  std::string *p_p;
  std::string *v7;
  std::string __p;
  std::string v9;
  std::bad_cast v10;
  _UNKNOWN **v11;
  _UNKNOWN **v12;
  uint8_t buf[8];
  _BYTE v14[20];
  __int16 v15;
  std::string *v16;
  _QWORD v17[2];

  v17[0] = a2;
  v17[1] = a3;
  memset(&v9, 0, sizeof(v9));
  if ((sub_10026A098(a4, &v9) & 1) == 0)
  {
    std::bad_cast::bad_cast((std::bad_cast *)buf);
    *(_QWORD *)buf = &off_10212A508;
    sub_10026A9C8((uint64_t)buf);
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_1021302D8);
  v5 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
  {
    memset(&__p, 0, sizeof(__p));
    if ((sub_10026A098((uint64_t)v17, &__p) & 1) == 0)
    {
      std::bad_cast::bad_cast(&v10);
      v10.__vftable = (std::bad_cast_vtbl *)&off_10212A508;
      sub_10026A9C8((uint64_t)&v10);
    }
    p_p = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    v7 = &v9;
    if ((v9.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v7 = (std::string *)v9.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 68289539;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)v14 = 2082;
    *(_QWORD *)&v14[2] = "";
    *(_WORD *)&v14[10] = 2081;
    *(_QWORD *)&v14[12] = p_p;
    v15 = 2081;
    v16 = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"#LOI Manager, Adding LOI to Service ID mapping\", \"Location ID\":%{private, location:escape_only}s, \"Service ID\":%{private, location:escape_only}s}", buf, 0x26u);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  sub_100283F80(*(_QWORD *)(a1 + 312), (uint64_t)&v9, (uint64_t)v17);
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v9.__r_.__value_.__l.__data_);
}

void sub_10032E284(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,std::bad_cast a22,uint64_t a23,uint64_t a24,std::bad_cast a25)
{
  std::bad_cast::~bad_cast(&a22);
  if (a15 < 0)
    operator delete(__p);
  if (a21 < 0)
    operator delete(a16);
  _Unwind_Resume(a1);
}

_QWORD *sub_10032E2DC@<X0>(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  char *v3;
  NSObject *v4;
  _QWORD *result;
  const char *v6;
  uint8_t *v7;
  _WORD v8[8];
  uint8_t buf[1640];

  switch(a1)
  {
    case -1:
      v3 = "other";
      goto LABEL_13;
    case 0:
      v3 = "home";
      goto LABEL_13;
    case 1:
      v3 = "work";
      goto LABEL_13;
    case 2:
      v3 = "school";
      goto LABEL_13;
    case 3:
      v3 = "gym";
LABEL_13:
      result = sub_1015A2E04(a2, v3);
      break;
    default:
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      v4 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#Warning Please update this switch statement.", buf, 2u);
      }
      if (sub_1001BFF7C(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
        v8[0] = 0;
        _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#Warning Please update this switch statement.", v8, 2);
        v7 = (uint8_t *)v6;
        sub_100512490("Generic", 1, 0, 2, "std::string CLMicroLocationLoiManager::convertRTLocationOfInterestTypeToString(RTLocationOfInterestType)", "%s\n", v6);
        if (v7 != buf)
          free(v7);
      }
      result = sub_1015A2E04(a2, "none");
      break;
  }
  return result;
}

BOOL sub_10032E580(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  NSObject *v3;
  _DWORD v5[2];
  __int16 v6;
  const char *v7;

  v2 = *(_QWORD *)(a1 + 320);
  if (v2)
  {
    objc_msgSend(*(id *)(a1 + 320), "fetchRelatedLoisForLoi:", a2);
  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v3 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      v5[0] = 68289026;
      v5[1] = 0;
      v6 = 2082;
      v7 = "";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#Warning LOI Bridge not setup.\"}", (uint8_t *)v5, 0x12u);
    }
  }
  return v2 != 0;
}

_QWORD *sub_10032E674@<X0>(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  char *v3;
  NSObject *v4;
  _QWORD *result;
  const char *v6;
  uint8_t *v7;
  _WORD v8[8];
  uint8_t buf[1640];

  switch(a1)
  {
    case 0:
      v3 = "other";
      goto LABEL_13;
    case 1:
      v3 = "home";
      goto LABEL_13;
    case 2:
      v3 = "work";
      goto LABEL_13;
    case 3:
      v3 = "school";
      goto LABEL_13;
    case 4:
      v3 = "gym";
LABEL_13:
      result = sub_1015A2E04(a2, v3);
      break;
    default:
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      v4 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#Warning Please update this switch statement.", buf, 2u);
      }
      if (sub_1001BFF7C(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
        v8[0] = 0;
        _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#Warning Please update this switch statement.", v8, 2);
        v7 = (uint8_t *)v6;
        sub_100512490("Generic", 1, 0, 2, "std::string CLMicroLocationLoiManager::convertPlaceInferenceUserPlaceTypeToString(_CLPlaceInferenceUserSpecificPlaceType)", "%s\n", v6);
        if (v7 != buf)
          free(v7);
      }
      result = sub_1015A2E04(a2, "none");
      break;
  }
  return result;
}

void sub_10032E914(uint64_t a1)
{
  NSDictionary *v2;
  _QWORD v3[3];
  _QWORD v4[3];

  v4[0] = &off_10221B030;
  v3[0] = CFSTR("createdCustomLoi");
  v3[1] = CFSTR("geofenceLocationHorizontalAccuracy");
  v4[1] = +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", *(double *)(a1 + 352));
  v3[2] = CFSTR("geofenceLocationVerticalAccuracy");
  v4[2] = +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", *(double *)(a1 + 360));
  v2 = +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v4, v3, 3);
  sub_10032EC70((uint64_t)v2, CFSTR("com.apple.MicroLocation.CustomLoiCreation"), (uint64_t)v2);
}

void sub_10032E9DC(uint64_t a1, uint64_t a2, uint64_t a3, std::string *__str, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  void *__p[2];
  uint64_t v10;

  *(_QWORD *)(a1 + 392) = a2;
  *(_QWORD *)(a1 + 400) = a3;
  v7 = a1 + 368;
  std::string::operator=((std::string *)(a1 + 368), __str);
  v8 = *(_QWORD *)(a1 + 328);
  if (*(char *)(a1 + 391) < 0)
  {
    sub_100115CE4(__p, *(void **)(a1 + 368), *(_QWORD *)(a1 + 376));
  }
  else
  {
    *(_OWORD *)__p = *(_OWORD *)v7;
    v10 = *(_QWORD *)(v7 + 16);
  }
  (*(void (**)(uint64_t, void **, _QWORD, _QWORD, uint64_t))(*(_QWORD *)v8 + 16))(v8, __p, *(_QWORD *)(a1 + 392), *(_QWORD *)(a1 + 400), a5);
  if (SHIBYTE(v10) < 0)
    operator delete(__p[0]);
}

void sub_10032EA78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_10032EA94(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSDictionary *v3;
  _QWORD v4[3];
  _QWORD v5[3];

  v4[0] = CFSTR("customLoiVisitOccurred");
  v4[1] = CFSTR("loiType");
  v5[0] = &off_10221B030;
  v5[1] = a2;
  v4[2] = CFSTR("visitEventType");
  v5[2] = a3;
  v3 = +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v5, v4, 3);
  sub_10032EC70((uint64_t)v3, CFSTR("com.apple.MicroLocation.CustomLoiVisitEvent"), (uint64_t)v3);
}

void sub_10032EB30(uint64_t a1, uint64_t a2, uint64_t a3)
{
  char *v4;
  uint64_t v5;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  uint64_t v10;
  void *__p[2];
  char v12;
  void *v13;
  char *v14;
  char *v15;
  __int128 v16;

  *(_QWORD *)&v16 = a2;
  *((_QWORD *)&v16 + 1) = a3;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v4 = (char *)sub_10028E224((uint64_t)&v15, 1uLL);
  v6 = &v4[16 * v5];
  *(_OWORD *)v4 = v16;
  v7 = v4 + 16;
  v9 = (char *)v13;
  v8 = v14;
  if (v14 != v13)
  {
    do
    {
      *((_OWORD *)v4 - 1) = *((_OWORD *)v8 - 1);
      v4 -= 16;
      v8 -= 16;
    }
    while (v8 != v9);
    v8 = (char *)v13;
  }
  v13 = v4;
  v14 = v7;
  v15 = v6;
  if (v8)
    operator delete(v8);
  v14 = v7;
  v10 = *(_QWORD *)(a1 + 312);
  sub_1015A2E04(__p, "custom");
  sub_100286CA8(v10, (uint64_t)&v16, (uint64_t)&v13, (uint64_t)__p);
  if (v12 < 0)
    operator delete(__p[0]);
  if (v13)
  {
    v14 = (char *)v13;
    operator delete(v13);
  }
}

void sub_10032EC38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17)
{
  if (a15 < 0)
    operator delete(__p);
  if (a16)
    operator delete(a16);
  _Unwind_Resume(exception_object);
}

void sub_10032EC70(uint64_t a1, void *a2, uint64_t a3)
{
  CFStringRef v5;
  char v6;
  int v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  char v11;
  NSObject *v12;
  const char *v13;
  uint8_t *v14;
  NSObject *v15;
  id v16;
  unsigned __int8 v17[16];
  uint8_t buf[8];
  _BYTE v19[10];
  __int16 v20;
  id v21;
  __int16 v22;
  uint64_t v23;

  sub_1001E4804(buf);
  v17[0] = 0;
  v5 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsAnalyticsSendEventEnabled", 0x8000100u, kCFAllocatorNull);
  v6 = sub_1001E48E4(*(uint64_t *)buf, (uint64_t)v5, (BOOL *)v17);
  CFRelease(v5);
  v7 = v17[0];
  v8 = *(std::__shared_weak_count **)v19;
  if (*(_QWORD *)v19)
  {
    v9 = (unint64_t *)(*(_QWORD *)v19 + 8);
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  if (v7)
    v11 = 0;
  else
    v11 = v6;
  if ((v11 & 1) != 0)
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v12 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#LOI Manager, CoreAnalytics Disabled", buf, 2u);
    }
    if (sub_1001BFF7C(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      *(_WORD *)v17 = 0;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#LOI Manager, CoreAnalytics Disabled", v17, 2);
      v14 = (uint8_t *)v13;
      sub_100512490("Generic", 1, 0, 2, "void CLMicroLocationLoiManager::sendCoreAnalyticsEvent(NSString *, NSDictionary *)", "%s\n", v13);
      if (v14 != buf)
        free(v14);
    }
  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v15 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
    {
      v16 = objc_msgSend(a2, "UTF8String");
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)v19 = 2082;
      *(_QWORD *)&v19[2] = "";
      v20 = 2081;
      v21 = v16;
      v22 = 2113;
      v23 = a3;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"#LOI Manager, sending core analytics\", \"event\":%{private, location:escape_only}s, \"eventFields\":%{private, location:escape_only}@}", buf, 0x26u);
    }
    AnalyticsSendEvent(a2, a3);
  }
}

void sub_10032EF48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  sub_100261F44((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10032EF68(uint64_t a1, void *a2)
{
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;
  const char *v7;
  uint8_t *v8;
  const char *v9;
  uint8_t *v10;
  const char *v11;
  uint8_t *v12;
  uint64_t v13;
  _WORD v14[8];
  uint8_t buf[8];
  std::string __p;
  id v17;

  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_1021302D8);
  v4 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "LOI Manager, handleVisitNotification", buf, 2u);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v14[0] = 0;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "LOI Manager, handleVisitNotification", v14, 2);
    v8 = (uint8_t *)v7;
    sub_100512490("Generic", 1, 0, 2, "virtual void CLMicroLocationLoiManager::handleVisitNotification(CLVisit *)", "%s\n", v7);
    if (v8 != buf)
      free(v8);
  }
  if (objc_msgSend(a2, "hasDepartureDate"))
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v5 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "LOI Manager, Received visit exit", buf, 2u);
    }
    if (sub_1001BFF7C(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      v14[0] = 0;
      LODWORD(v13) = 2;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "LOI Manager, Received visit exit", v14, v13);
      v10 = (uint8_t *)v9;
      sub_100512490("Generic", 1, 0, 2, "virtual void CLMicroLocationLoiManager::handleVisitNotification(CLVisit *)", "%s\n", v9);
      if (v10 != buf)
        free(v10);
    }
    *(_QWORD *)buf = off_10212F0B8;
    sub_1015A2E04(&__p, "No Name Given");
    *(_QWORD *)buf = off_102130388;
    v17 = a2;
    std::string::assign(&__p, "LOI Visit Exit");
    sub_1001569F0((_QWORD *)(a1 + 8), (uint64_t)buf);
    *(_QWORD *)buf = off_102130388;

  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v6 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "LOI Manager, Received visit entry", buf, 2u);
    }
    if (sub_1001BFF7C(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      v14[0] = 0;
      LODWORD(v13) = 2;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "LOI Manager, Received visit entry", v14, v13);
      v12 = (uint8_t *)v11;
      sub_100512490("Generic", 1, 0, 2, "virtual void CLMicroLocationLoiManager::handleVisitNotification(CLVisit *)", "%s\n", v11);
      if (v12 != buf)
        free(v12);
    }
    *(_QWORD *)buf = off_10212F0B8;
    sub_1015A2E04(&__p, "No Name Given");
    *(_QWORD *)buf = off_1021303A8;
    v17 = a2;
    std::string::assign(&__p, "LOI Visit Entry");
    sub_1001569F0((_QWORD *)(a1 + 8), (uint64_t)buf);
    *(_QWORD *)buf = off_1021303A8;

  }
  *(_QWORD *)buf = off_10212F0B8;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_10032F44C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a2)
    sub_10024F88C(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t sub_10032F4B0(uint64_t a1)
{
  *(_QWORD *)a1 = off_102130388;

  *(_QWORD *)a1 = off_10212F0B8;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  return a1;
}

uint64_t sub_10032F50C(uint64_t a1)
{
  *(_QWORD *)a1 = off_1021303A8;

  *(_QWORD *)a1 = off_10212F0B8;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  return a1;
}

void sub_10032F568(uint64_t a1, void *a2, void *a3)
{
  NSObject *v6;
  NSObject *v7;
  id v8;
  id v9;
  NSObject *v10;
  const char *v11;
  uint8_t *v12;
  NSObject *v13;
  const char *v14;
  _WORD v15[8];
  uint8_t buf[8];
  std::string __p;
  id v18;

  if (a3)
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v6 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      LOWORD(__p.__r_.__value_.__l.__data_) = 2082;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 2) = (std::string::size_type)"";
      WORD1(__p.__r_.__value_.__r.__words[1]) = 2081;
      *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 4) = (std::string::size_type)objc_msgSend(objc_msgSend(a3, "description"), "UTF8String");
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Bridge, Failed To fetch place inferences\", \"Error:\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
    v7 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      v8 = objc_msgSend(objc_msgSend(a3, "description"), "UTF8String");
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      LOWORD(__p.__r_.__value_.__l.__data_) = 2082;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 2) = (std::string::size_type)"";
      WORD1(__p.__r_.__value_.__r.__words[1]) = 2081;
      *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 4) = (std::string::size_type)v8;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v7, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Bridge, Failed To fetch place inferences", "{\"msg%{public}.0s\":\"LOI Bridge, Failed To fetch place inferences\", \"Error:\":%{private, location:escape_only}s}", buf, 0x1Cu);
    }
  }
  if (!objc_msgSend(a2, "count"))
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v10 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "LOI Bridge, received no place inferences, we will start leeching and wait for next location update", buf, 2u);
    }
    if (!sub_1001BFF7C(115, 2))
      goto LABEL_25;
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v15[0] = 0;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "LOI Bridge, received no place inferences, we will start leeching and wait for next location update", v15, 2);
    v12 = (uint8_t *)v11;
    sub_100512490("Generic", 1, 0, 2, "virtual void CLMicroLocationLoiManager::handleFetchedPlaceInferences(NSArray<_CLPlaceInference *> *, NSError *)", "%s\n", v11);
    goto LABEL_31;
  }
  v9 = objc_msgSend(a2, "objectAtIndexedSubscript:", 0);
  if (objc_msgSend(v9, "_loiIdentifier"))
  {
    *(_QWORD *)buf = off_10212F0B8;
    sub_1015A2E04(&__p, "No Name Given");
    *(_QWORD *)buf = off_1021303E8;
    v18 = v9;
    std::string::assign(&__p, "Fetched Place Inference For Current Location");
    sub_1001569F0((_QWORD *)(a1 + 8), (uint64_t)buf);
    sub_100338970((uint64_t)buf);
    return;
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_1021302D8);
  v13 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "LOI Bridge, received nil LOI Identifier, possibly because there is no active user on macOS, we will start leeching and wait for next location update", buf, 2u);
  }
  if (sub_1001BFF7C(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v15[0] = 0;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 16, "LOI Bridge, received nil LOI Identifier, possibly because there is no active user on macOS, we will start leeching and wait for next location update", v15, 2);
    v12 = (uint8_t *)v14;
    sub_100512490("Generic", 1, 0, 0, "virtual void CLMicroLocationLoiManager::handleFetchedPlaceInferences(NSArray<_CLPlaceInference *> *, NSError *)", "%s\n", v14);
LABEL_31:
    if (v12 != buf)
      free(v12);
  }
LABEL_25:
  sub_1003388C0(buf);
  sub_1001569F0((_QWORD *)(a1 + 8), (uint64_t)buf);
  *(_QWORD *)buf = off_10212F0B8;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_10032FA34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  sub_100338970((uint64_t)&a13);
  _Unwind_Resume(a1);
}

uint64_t sub_10032FA88(uint64_t a1)
{
  *(_QWORD *)a1 = off_102130428;

  *(_QWORD *)a1 = off_10212F0B8;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  return a1;
}

void sub_10032FAE4(uint64_t a1, void *a2, std::string::size_type a3)
{
  NSObject *v5;
  NSObject *v6;
  void *v7;
  id v9;
  uint64_t v10;
  void *i;
  char *v12;
  size_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char *v24;
  uint64_t *v25;
  _QWORD *v26;
  _QWORD *v27;
  char *v28;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  void *__p;
  uint64_t *v35;
  unint64_t v36;
  uint8_t buf[8];
  std::string v38;
  _QWORD v39[4];
  _BYTE v40[128];

  if (a3)
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v5 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      LOWORD(v38.__r_.__value_.__l.__data_) = 2082;
      *(std::string::size_type *)((char *)v38.__r_.__value_.__r.__words + 2) = (std::string::size_type)"";
      WORD1(v38.__r_.__value_.__r.__words[1]) = 2113;
      *(std::string::size_type *)((char *)&v38.__r_.__value_.__r.__words[1] + 4) = a3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#Warning LOI Manager, Error retrieving related LOIs for Loi\", \"error\":%{private, location:escape_only}@}", buf, 0x1Cu);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
    v6 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      LOWORD(v38.__r_.__value_.__l.__data_) = 2082;
      *(std::string::size_type *)((char *)v38.__r_.__value_.__r.__words + 2) = (std::string::size_type)"";
      WORD1(v38.__r_.__value_.__r.__words[1]) = 2113;
      *(std::string::size_type *)((char *)&v38.__r_.__value_.__r.__words[1] + 4) = a3;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v6, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#Warning LOI Manager, Error retrieving related LOIs for Loi", "{\"msg%{public}.0s\":\"#Warning LOI Manager, Error retrieving related LOIs for Loi\", \"error\":%{private, location:escape_only}@}", buf, 0x1Cu);
    }
    sub_100338AC4(buf);
    sub_1001569F0((_QWORD *)(a1 + 8), (uint64_t)buf);
    *(_QWORD *)buf = off_10212F0B8;
    if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0)
    {
      v7 = (void *)v38.__r_.__value_.__r.__words[0];
LABEL_36:
      operator delete(v7);
    }
  }
  else
  {
    __p = 0;
    v35 = 0;
    v36 = 0;
    v30 = 0u;
    v31 = 0u;
    v32 = 0u;
    v33 = 0u;
    v9 = objc_msgSend(a2, "countByEnumeratingWithState:objects:count:", &v30, v40, 16);
    if (v9)
    {
      v10 = *(_QWORD *)v31;
      do
      {
        for (i = 0; i != v9; i = (char *)i + 1)
        {
          if (*(_QWORD *)v31 != v10)
            objc_enumerationMutation(a2);
          v12 = (char *)objc_msgSend(objc_msgSend(*(id *)(*((_QWORD *)&v30 + 1) + 8 * (_QWORD)i), "UUIDString"), "UTF8String");
          v13 = strlen(v12);
          v14 = sub_1002B7330((uint64_t)buf, (unsigned __int8 *)v12, (unsigned __int8 *)&v12[v13]);
          v16 = v14;
          v17 = v15;
          v18 = v35;
          if ((unint64_t)v35 >= v36)
          {
            v20 = ((char *)v35 - (_BYTE *)__p) >> 4;
            v21 = v20 + 1;
            if ((unint64_t)(v20 + 1) >> 60)
              sub_100259694();
            v22 = v36 - (_QWORD)__p;
            if ((uint64_t)(v36 - (_QWORD)__p) >> 3 > v21)
              v21 = v22 >> 3;
            if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF0)
              v23 = 0xFFFFFFFFFFFFFFFLL;
            else
              v23 = v21;
            if (v23)
              v24 = (char *)sub_10028E224((uint64_t)&v36, v23);
            else
              v24 = 0;
            v25 = (uint64_t *)&v24[16 * v20];
            *v25 = v16;
            v25[1] = v17;
            v27 = __p;
            v26 = v35;
            v28 = (char *)v25;
            if (v35 != __p)
            {
              do
              {
                *((_OWORD *)v28 - 1) = *((_OWORD *)v26 - 1);
                v28 -= 16;
                v26 -= 2;
              }
              while (v26 != v27);
              v26 = __p;
            }
            v19 = v25 + 2;
            __p = v28;
            v35 = v25 + 2;
            v36 = (unint64_t)&v24[16 * v23];
            if (v26)
              operator delete(v26);
          }
          else
          {
            *v35 = v14;
            v18[1] = v15;
            v19 = v18 + 2;
          }
          v35 = v19;
        }
        v9 = objc_msgSend(a2, "countByEnumeratingWithState:objects:count:", &v30, v40, 16);
      }
      while (v9);
    }
    *(_QWORD *)buf = off_10212F0B8;
    sub_1015A2E04(&v38, "No Name Given");
    *(_QWORD *)buf = off_102130468;
    memset(v39, 0, 24);
    sub_1002F3538((char *)v39, (char *)__p, (uint64_t)v35, ((char *)v35 - (_BYTE *)__p) >> 4);
    std::string::assign(&v38, "Got Related LOIs");
    sub_1001569F0((_QWORD *)(a1 + 8), (uint64_t)buf);
    sub_100338B74((uint64_t)buf);
    v7 = __p;
    if (__p)
    {
      v35 = (uint64_t *)__p;
      goto LABEL_36;
    }
  }
}

void sub_10032FED0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31)
{
  sub_100338B74((uint64_t)&a23);
  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void sub_10032FF70(uint64_t a1, void *a2, uint64_t a3)
{
  NSObject *v5;
  NSObject *v6;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _DWORD v12[2];
  __int16 v13;
  const char *v14;
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  uint64_t v18;
  uint8_t buf[8];
  _BYTE __p[10];
  __int16 v21;
  uint64_t v22;
  char v23;

  if (a3)
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v5 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 68289282;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)__p = 2082;
      *(_QWORD *)&__p[2] = "";
      v21 = 2114;
      v22 = a3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, failed to get current location to enable MiLo\", \"Error\":%{public, location:escape_only}@}", buf, 0x1Cu);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
    v6 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      *(_DWORD *)buf = 68289282;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)__p = 2082;
      *(_QWORD *)&__p[2] = "";
      v21 = 2114;
      v22 = a3;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v6, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, failed to get current location to enable MiLo", "{\"msg%{public}.0s\":\"#LOI Manager, failed to get current location to enable MiLo\", \"Error\":%{public, location:escape_only}@}", buf, 0x1Cu);
    }
    sub_100338BD4(buf);
    sub_1001569F0((_QWORD *)(a1 + 8), (uint64_t)buf);
    *(_QWORD *)buf = off_10212F0B8;
    if (v23 < 0)
      operator delete(*(void **)__p);
  }
  else
  {
    sub_100338C60(buf, a2);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v8 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      objc_msgSend(a2, "coordinate");
      v10 = v9;
      objc_msgSend(a2, "coordinate");
      v12[0] = 68289539;
      v12[1] = 0;
      v13 = 2082;
      v14 = "";
      v15 = 2049;
      v16 = v10;
      v17 = 2049;
      v18 = v11;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, got location update\", \"latitude\":\"%{private}7f\", \"longitude\":\"%{private}7f\"}", (uint8_t *)v12, 0x26u);
    }
    sub_1001569F0((_QWORD *)(a1 + 8), (uint64_t)buf);
    sub_100338D1C((uint64_t)buf);
  }
}

void sub_100330214(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  sub_100338D1C((uint64_t)&a15);
  _Unwind_Resume(a1);
}

void sub_100330268(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  NSObject *v7;
  NSObject *v8;
  std::string *v11;
  uint64_t (**v12)();
  void *__p;
  char v14;
  uint64_t v15;
  uint64_t v16;
  uint8_t buf[4];
  int v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  uint64_t v22;

  if (a5)
  {
    sub_100338D78(&v12);
    sub_1001569F0((_QWORD *)(a1 + 8), (uint64_t)&v12);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v7 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 68289282;
      v18 = 0;
      v19 = 2082;
      v20 = "";
      v21 = 2114;
      v22 = a5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, failed to set geofence at current location to enable MiLo\", \"Error\":%{public, location:escape_only}@}", buf, 0x1Cu);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
    v8 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      *(_DWORD *)buf = 68289282;
      v18 = 0;
      v19 = 2082;
      v20 = "";
      v21 = 2114;
      v22 = a5;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v8, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, failed to set geofence at current location to enable MiLo", "{\"msg%{public}.0s\":\"#LOI Manager, failed to set geofence at current location to enable MiLo\", \"Error\":%{public, location:escape_only}@}", buf, 0x1Cu);
    }
  }
  else
  {
    v11 = (std::string *)sub_1015A2E04(&__p, "No Name Given");
    v12 = off_1021304E8;
    v15 = a3;
    v16 = a4;
    std::string::assign(v11, "Started Process of Activaing Geofence");
    sub_1001569F0((_QWORD *)(a1 + 8), (uint64_t)&v12);
  }
  v12 = off_10212F0B8;
  if (v14 < 0)
    operator delete(__p);
}

void sub_100330488(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1003304CC(uint64_t a1, void *a2, uint64_t a3)
{
  NSObject *v6;
  id v7;
  uint64_t v8;
  uint64_t v9;
  std::string *v10;
  NSObject *v11;
  id v12;
  NSObject *v13;
  id v14;
  uint64_t v15;
  uint64_t v16;
  std::string *v17;
  void *__p;
  _BYTE v19[10];
  __int16 v20;
  id v21;
  __int16 v22;
  _BYTE v23[10];
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char v27;

  sub_1015A2E04(&__p, (char *)objc_msgSend(a2, "UTF8String"));
  sub_100357708((uint64_t)&__p, (uint64_t)&v25);
  if (SBYTE3(v21) < 0)
    operator delete(__p);
  if (v27)
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v6 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      v7 = objc_msgSend(a2, "UTF8String");
      __p = (void *)68289539;
      *(_WORD *)v19 = 2082;
      *(_QWORD *)&v19[2] = "";
      v20 = 2081;
      v21 = v7;
      v22 = 1025;
      *(_DWORD *)v23 = a3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"LOI Manager, Got Geofence update\", \"Geofence Id\":%{private, location:escape_only}s, \"State\":%{private}d}", (uint8_t *)&__p, 0x22u);
    }
    if (a3 == 1)
    {
      if (!v27)
        sub_10028DF3C();
      v8 = v25;
      v9 = v26;
      __p = off_10212F0B8;
      v10 = (std::string *)sub_1015A2E04(v19, "No Name Given");
      __p = off_102130508;
      *(_QWORD *)&v23[2] = v8;
      v24 = v9;
      std::string::assign(v10, "Geofence Entry");
      sub_1001569F0((_QWORD *)(a1 + 8), (uint64_t)&__p);
    }
    else
    {
      if (!v27)
        sub_10028DF3C();
      v15 = v25;
      v16 = v26;
      __p = off_10212F0B8;
      v17 = (std::string *)sub_1015A2E04(v19, "No Name Given");
      __p = &off_102130528;
      *(_QWORD *)&v23[2] = v15;
      v24 = v16;
      std::string::assign(v17, "Geofence Exit");
      sub_1001569F0((_QWORD *)(a1 + 8), (uint64_t)&__p);
    }
    __p = off_10212F0B8;
    if ((v23[1] & 0x80000000) != 0)
      operator delete(*(void **)v19);
  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v11 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      v12 = objc_msgSend(a2, "UTF8String");
      __p = (void *)68289539;
      *(_WORD *)v19 = 2082;
      *(_QWORD *)&v19[2] = "";
      v20 = 2081;
      v21 = v12;
      v22 = 1025;
      *(_DWORD *)v23 = a3;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got invalid geofence ID\", \"Geofence Id\":%{private, location:escape_only}s, \"State\":%{private}d}", (uint8_t *)&__p, 0x22u);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
    v13 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      v14 = objc_msgSend(a2, "UTF8String");
      __p = (void *)68289539;
      *(_WORD *)v19 = 2082;
      *(_QWORD *)&v19[2] = "";
      v20 = 2081;
      v21 = v14;
      v22 = 1025;
      *(_DWORD *)v23 = a3;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v13, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got invalid geofence ID", "{\"msg%{public}.0s\":\"LOI Manager, Got invalid geofence ID\", \"Geofence Id\":%{private, location:escape_only}s, \"State\":%{private}d}", (uint8_t *)&__p, 0x22u);
    }
  }
}

void sub_10033084C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_100330898(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject *v5;
  NSObject *v6;
  NSObject *v7;
  int v8;
  int v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  uint64_t v13;
  __int16 v14;
  uint64_t v15;

  if (a3)
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v5 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      v8 = 68289539;
      v9 = 0;
      v10 = 2082;
      v11 = "";
      v12 = 2113;
      v13 = a2;
      v14 = 2113;
      v15 = a3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, Failed to RemoveGeofence\", \"regionId\":%{private, location:escape_only}@, \"error\":%{private, location:escape_only}@}", (uint8_t *)&v8, 0x26u);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
    v6 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      v8 = 68289539;
      v9 = 0;
      v10 = 2082;
      v11 = "";
      v12 = 2113;
      v13 = a2;
      v14 = 2113;
      v15 = a3;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v6, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, Failed to RemoveGeofence", "{\"msg%{public}.0s\":\"#LOI Manager, Failed to RemoveGeofence\", \"regionId\":%{private, location:escape_only}@, \"error\":%{private, location:escape_only}@}", (uint8_t *)&v8, 0x26u);
    }
  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    v7 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      v8 = 68289539;
      v9 = 0;
      v10 = 2082;
      v11 = "";
      v12 = 2113;
      v13 = a2;
      v14 = 2113;
      v15 = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, didRemoveGeofenceWithId\", \"regionId\":%{private, location:escape_only}@, \"error\":%{private, location:escape_only}@}", (uint8_t *)&v8, 0x26u);
    }
  }
}

_QWORD *sub_100330AD4@<X0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void **v5;
  void *v6;
  uint64_t *v8;
  NSObject *v9;
  char *v10;
  __int128 v11;
  int v12;
  void **v13;
  void **v14;
  void **v15;
  NSObject *v16;
  char *v17;
  __int128 v18;
  int v19;
  void **v20;
  void **v21;
  void **v22;
  NSObject *v23;
  char *v24;
  __int128 v25;
  int v26;
  void **v27;
  void **v28;
  void *__p[2];
  char v30;
  void *__dst[2];
  uint64_t v32;
  uint8_t buf[4];
  int v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  void **v38;
  __int16 v39;
  void **v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  const char *v44;

  if (a2)
    v5 = (void **)(a2 - 8);
  else
    v5 = 0;
  if (!lpsrc
  {
    v8 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_52;
    while (1)
    {
      v9 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v10 + 1), *((_QWORD *)v10 + 2));
        }
        else
        {
          v11 = *(_OWORD *)(v10 + 8);
          v32 = *((_QWORD *)v10 + 3);
          *(_OWORD *)__dst = v11;
        }
        v12 = SHIBYTE(v32);
        v13 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v14 = __dst;
        if (v12 < 0)
          v14 = v13;
        if (v30 >= 0)
          v15 = __p;
        else
          v15 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v14;
        v39 = 2081;
        v40 = v15;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v16 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v17 + 1), *((_QWORD *)v17 + 2));
        }
        else
        {
          v18 = *(_OWORD *)(v17 + 8);
          v32 = *((_QWORD *)v17 + 3);
          *(_OWORD *)__dst = v18;
        }
        v19 = SHIBYTE(v32);
        v20 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v21 = __dst;
        if (v19 < 0)
          v21 = v20;
        if (v30 >= 0)
          v22 = __p;
        else
          v22 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v21;
        v39 = 2081;
        v40 = v22;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v23 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v24 + 1), *((_QWORD *)v24 + 2));
        }
        else
        {
          v25 = *(_OWORD *)(v24 + 8);
          v32 = *((_QWORD *)v24 + 3);
          *(_OWORD *)__dst = v25;
        }
        v26 = SHIBYTE(v32);
        v8 = (uint64_t *)__dst[0];
        v5 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v27 = __dst;
        if (v26 < 0)
          v27 = (void **)v8;
        if (v30 >= 0)
          v28 = __p;
        else
          v28 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v27;
        v39 = 2081;
        v40 = v28;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
  }
  return sub_1003261E0((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_100330F38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double sub_100330F64@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void **v5;
  _QWORD *v6;
  double result;
  uint64_t *v8;
  NSObject *v9;
  char *v10;
  __int128 v11;
  int v12;
  void **v13;
  void **v14;
  void **v15;
  NSObject *v16;
  char *v17;
  __int128 v18;
  int v19;
  void **v20;
  void **v21;
  void **v22;
  NSObject *v23;
  char *v24;
  __int128 v25;
  int v26;
  void **v27;
  void **v28;
  void *__p[2];
  char v30;
  void *__dst[2];
  uint64_t v32;
  _BYTE buf[28];
  __int16 v34;
  void **v35;
  __int16 v36;
  const char *v37;
  __int16 v38;
  const char *v39;

  if (a2)
    v5 = (void **)(a2 - 8);
  else
    v5 = 0;
  if (!lpsrc
  {
    v8 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_52;
    while (1)
    {
      v9 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v10 + 1), *((_QWORD *)v10 + 2));
        }
        else
        {
          v11 = *(_OWORD *)(v10 + 8);
          v32 = *((_QWORD *)v10 + 3);
          *(_OWORD *)__dst = v11;
        }
        v12 = SHIBYTE(v32);
        v13 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v14 = __dst;
        if (v12 < 0)
          v14 = v13;
        if (v30 >= 0)
          v15 = __p;
        else
          v15 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        *(_DWORD *)&buf[4] = 0;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2081;
        *(_QWORD *)&buf[20] = v14;
        v34 = 2081;
        v35 = v15;
        v36 = 2082;
        v37 = "assert";
        v38 = 2081;
        v39 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v16 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v17 + 1), *((_QWORD *)v17 + 2));
        }
        else
        {
          v18 = *(_OWORD *)(v17 + 8);
          v32 = *((_QWORD *)v17 + 3);
          *(_OWORD *)__dst = v18;
        }
        v19 = SHIBYTE(v32);
        v20 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v21 = __dst;
        if (v19 < 0)
          v21 = v20;
        if (v30 >= 0)
          v22 = __p;
        else
          v22 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        *(_DWORD *)&buf[4] = 0;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2081;
        *(_QWORD *)&buf[20] = v21;
        v34 = 2081;
        v35 = v22;
        v36 = 2082;
        v37 = "assert";
        v38 = 2081;
        v39 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v23 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v24 + 1), *((_QWORD *)v24 + 2));
        }
        else
        {
          v25 = *(_OWORD *)(v24 + 8);
          v32 = *((_QWORD *)v24 + 3);
          *(_OWORD *)__dst = v25;
        }
        v26 = SHIBYTE(v32);
        v8 = (uint64_t *)__dst[0];
        v5 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v27 = __dst;
        if (v26 < 0)
          v27 = (void **)v8;
        if (v30 >= 0)
          v28 = __p;
        else
          v28 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        *(_DWORD *)&buf[4] = 0;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2081;
        *(_QWORD *)&buf[20] = v27;
        v34 = 2081;
        v35 = v28;
        v36 = 2082;
        v37 = "assert";
        v38 = 2081;
        v39 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
  }
  sub_10032D394((uint64_t)v5, v6[4], v6[5], buf);
  result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_1003313E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double sub_100331410@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void **v5;
  uint64_t *v6;
  double result;
  uint64_t *v8;
  NSObject *v9;
  char *v10;
  __int128 v11;
  int v12;
  void **v13;
  void **v14;
  void **v15;
  NSObject *v16;
  char *v17;
  __int128 v18;
  int v19;
  void **v20;
  void **v21;
  void **v22;
  NSObject *v23;
  char *v24;
  __int128 v25;
  int v26;
  void **v27;
  void **v28;
  void *__p[2];
  char v30;
  void *__dst[2];
  uint64_t v32;
  _BYTE buf[28];
  __int16 v34;
  void **v35;
  __int16 v36;
  const char *v37;
  __int16 v38;
  const char *v39;

  if (a2)
    v5 = (void **)(a2 - 8);
  else
    v5 = 0;
  if (!lpsrc
  {
    v8 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_52;
    while (1)
    {
      v9 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v10 + 1), *((_QWORD *)v10 + 2));
        }
        else
        {
          v11 = *(_OWORD *)(v10 + 8);
          v32 = *((_QWORD *)v10 + 3);
          *(_OWORD *)__dst = v11;
        }
        v12 = SHIBYTE(v32);
        v13 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v14 = __dst;
        if (v12 < 0)
          v14 = v13;
        if (v30 >= 0)
          v15 = __p;
        else
          v15 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        *(_DWORD *)&buf[4] = 0;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2081;
        *(_QWORD *)&buf[20] = v14;
        v34 = 2081;
        v35 = v15;
        v36 = 2082;
        v37 = "assert";
        v38 = 2081;
        v39 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v16 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v17 + 1), *((_QWORD *)v17 + 2));
        }
        else
        {
          v18 = *(_OWORD *)(v17 + 8);
          v32 = *((_QWORD *)v17 + 3);
          *(_OWORD *)__dst = v18;
        }
        v19 = SHIBYTE(v32);
        v20 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v21 = __dst;
        if (v19 < 0)
          v21 = v20;
        if (v30 >= 0)
          v22 = __p;
        else
          v22 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        *(_DWORD *)&buf[4] = 0;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2081;
        *(_QWORD *)&buf[20] = v21;
        v34 = 2081;
        v35 = v22;
        v36 = 2082;
        v37 = "assert";
        v38 = 2081;
        v39 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v23 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v24 + 1), *((_QWORD *)v24 + 2));
        }
        else
        {
          v25 = *(_OWORD *)(v24 + 8);
          v32 = *((_QWORD *)v24 + 3);
          *(_OWORD *)__dst = v25;
        }
        v26 = SHIBYTE(v32);
        v8 = (uint64_t *)__dst[0];
        v5 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v27 = __dst;
        if (v26 < 0)
          v27 = (void **)v8;
        if (v30 >= 0)
          v28 = __p;
        else
          v28 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        *(_DWORD *)&buf[4] = 0;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2081;
        *(_QWORD *)&buf[20] = v27;
        v34 = 2081;
        v35 = v28;
        v36 = 2082;
        v37 = "assert";
        v38 = 2081;
        v39 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
  }
  sub_10032D61C((uint64_t)v5, v6[4], v6[5], v6[6], v6[7], (uint64_t)buf);
  result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_100331894(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double sub_1003318C0@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void **v5;
  void *v6;
  uint64_t *v8;
  NSObject *v9;
  char *v10;
  __int128 v11;
  int v12;
  void **v13;
  void **v14;
  void **v15;
  NSObject *v16;
  char *v17;
  __int128 v18;
  int v19;
  void **v20;
  void **v21;
  void **v22;
  NSObject *v23;
  char *v24;
  __int128 v25;
  int v26;
  void **v27;
  void **v28;
  void *__p[2];
  char v30;
  void *__dst[2];
  uint64_t v32;
  uint8_t buf[4];
  int v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  void **v38;
  __int16 v39;
  void **v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  const char *v44;

  if (a2)
    v5 = (void **)(a2 - 8);
  else
    v5 = 0;
  if (!lpsrc
  {
    v8 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_52;
    while (1)
    {
      v9 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v10 + 1), *((_QWORD *)v10 + 2));
        }
        else
        {
          v11 = *(_OWORD *)(v10 + 8);
          v32 = *((_QWORD *)v10 + 3);
          *(_OWORD *)__dst = v11;
        }
        v12 = SHIBYTE(v32);
        v13 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v14 = __dst;
        if (v12 < 0)
          v14 = v13;
        if (v30 >= 0)
          v15 = __p;
        else
          v15 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v14;
        v39 = 2081;
        v40 = v15;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v16 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v17 + 1), *((_QWORD *)v17 + 2));
        }
        else
        {
          v18 = *(_OWORD *)(v17 + 8);
          v32 = *((_QWORD *)v17 + 3);
          *(_OWORD *)__dst = v18;
        }
        v19 = SHIBYTE(v32);
        v20 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v21 = __dst;
        if (v19 < 0)
          v21 = v20;
        if (v30 >= 0)
          v22 = __p;
        else
          v22 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v21;
        v39 = 2081;
        v40 = v22;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v23 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v24 + 1), *((_QWORD *)v24 + 2));
        }
        else
        {
          v25 = *(_OWORD *)(v24 + 8);
          v32 = *((_QWORD *)v24 + 3);
          *(_OWORD *)__dst = v25;
        }
        v26 = SHIBYTE(v32);
        v8 = (uint64_t *)__dst[0];
        v5 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v27 = __dst;
        if (v26 < 0)
          v27 = (void **)v8;
        if (v30 >= 0)
          v28 = __p;
        else
          v28 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v27;
        v39 = 2081;
        v40 = v28;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
  }
  return sub_100326684((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_100331D24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double sub_100331D50@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void **v5;
  uint64_t *v7;
  NSObject *v8;
  char *v9;
  __int128 v10;
  int v11;
  void **v12;
  void **v13;
  void **v14;
  NSObject *v15;
  char *v16;
  __int128 v17;
  int v18;
  void **v19;
  void **v20;
  void **v21;
  NSObject *v22;
  char *v23;
  __int128 v24;
  int v25;
  void **v26;
  void **v27;
  void *__p[2];
  char v29;
  void *__dst[2];
  uint64_t v31;
  uint8_t buf[4];
  int v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  void **v37;
  __int16 v38;
  void **v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  const char *v43;

  if (a2)
    v5 = (void **)(a2 - 8);
  else
    v5 = 0;
  if (!lpsrc
  {
    v7 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_52;
    while (1)
    {
      v8 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v9 = (char *)v5[2];
        if (v9[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v9 + 1), *((_QWORD *)v9 + 2));
        }
        else
        {
          v10 = *(_OWORD *)(v9 + 8);
          v31 = *((_QWORD *)v9 + 3);
          *(_OWORD *)__dst = v10;
        }
        v11 = SHIBYTE(v31);
        v12 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v13 = __dst;
        if (v11 < 0)
          v13 = v12;
        if (v29 >= 0)
          v14 = __p;
        else
          v14 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v33 = 0;
        v34 = 2082;
        v35 = "";
        v36 = 2081;
        v37 = v13;
        v38 = 2081;
        v39 = v14;
        v40 = 2082;
        v41 = "assert";
        v42 = 2081;
        v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v31) < 0)
          operator delete(__dst[0]);
        if (v7[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v15 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v16 = (char *)v5[2];
        if (v16[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v16 + 1), *((_QWORD *)v16 + 2));
        }
        else
        {
          v17 = *(_OWORD *)(v16 + 8);
          v31 = *((_QWORD *)v16 + 3);
          *(_OWORD *)__dst = v17;
        }
        v18 = SHIBYTE(v31);
        v19 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v20 = __dst;
        if (v18 < 0)
          v20 = v19;
        if (v29 >= 0)
          v21 = __p;
        else
          v21 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v33 = 0;
        v34 = 2082;
        v35 = "";
        v36 = 2081;
        v37 = v20;
        v38 = 2081;
        v39 = v21;
        v40 = 2082;
        v41 = "assert";
        v42 = 2081;
        v43 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v31) < 0)
          operator delete(__dst[0]);
        if (v7[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v22 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v23 = (char *)v5[2];
        if (v23[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v23 + 1), *((_QWORD *)v23 + 2));
        }
        else
        {
          v24 = *(_OWORD *)(v23 + 8);
          v31 = *((_QWORD *)v23 + 3);
          *(_OWORD *)__dst = v24;
        }
        v25 = SHIBYTE(v31);
        v7 = (uint64_t *)__dst[0];
        v5 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v26 = __dst;
        if (v25 < 0)
          v26 = (void **)v7;
        if (v29 >= 0)
          v27 = __p;
        else
          v27 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v33 = 0;
        v34 = 2082;
        v35 = "";
        v36 = 2081;
        v37 = v26;
        v38 = 2081;
        v39 = v27;
        v40 = 2082;
        v41 = "assert";
        v42 = 2081;
        v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v31) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
  }
  return sub_1003269C4((uint64_t)v5, a3);
}

void sub_1003321B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double sub_1003321DC@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void **v5;
  void *v6;
  uint64_t *v8;
  NSObject *v9;
  char *v10;
  __int128 v11;
  int v12;
  void **v13;
  void **v14;
  void **v15;
  NSObject *v16;
  char *v17;
  __int128 v18;
  int v19;
  void **v20;
  void **v21;
  void **v22;
  NSObject *v23;
  char *v24;
  __int128 v25;
  int v26;
  void **v27;
  void **v28;
  void *__p[2];
  char v30;
  void *__dst[2];
  uint64_t v32;
  uint8_t buf[4];
  int v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  void **v38;
  __int16 v39;
  void **v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  const char *v44;

  if (a2)
    v5 = (void **)(a2 - 8);
  else
    v5 = 0;
  if (!lpsrc
  {
    v8 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_52;
    while (1)
    {
      v9 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v10 + 1), *((_QWORD *)v10 + 2));
        }
        else
        {
          v11 = *(_OWORD *)(v10 + 8);
          v32 = *((_QWORD *)v10 + 3);
          *(_OWORD *)__dst = v11;
        }
        v12 = SHIBYTE(v32);
        v13 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v14 = __dst;
        if (v12 < 0)
          v14 = v13;
        if (v30 >= 0)
          v15 = __p;
        else
          v15 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v14;
        v39 = 2081;
        v40 = v15;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v16 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v17 + 1), *((_QWORD *)v17 + 2));
        }
        else
        {
          v18 = *(_OWORD *)(v17 + 8);
          v32 = *((_QWORD *)v17 + 3);
          *(_OWORD *)__dst = v18;
        }
        v19 = SHIBYTE(v32);
        v20 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v21 = __dst;
        if (v19 < 0)
          v21 = v20;
        if (v30 >= 0)
          v22 = __p;
        else
          v22 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v21;
        v39 = 2081;
        v40 = v22;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v23 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v24 + 1), *((_QWORD *)v24 + 2));
        }
        else
        {
          v25 = *(_OWORD *)(v24 + 8);
          v32 = *((_QWORD *)v24 + 3);
          *(_OWORD *)__dst = v25;
        }
        v26 = SHIBYTE(v32);
        v8 = (uint64_t *)__dst[0];
        v5 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v27 = __dst;
        if (v26 < 0)
          v27 = (void **)v8;
        if (v30 >= 0)
          v28 = __p;
        else
          v28 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v27;
        v39 = 2081;
        v40 = v28;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
  }
  return sub_100326BA4((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_100332640(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double sub_10033266C@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void **v5;
  uint64_t *v7;
  NSObject *v8;
  char *v9;
  __int128 v10;
  int v11;
  void **v12;
  void **v13;
  void **v14;
  NSObject *v15;
  char *v16;
  __int128 v17;
  int v18;
  void **v19;
  void **v20;
  void **v21;
  NSObject *v22;
  char *v23;
  __int128 v24;
  int v25;
  void **v26;
  void **v27;
  void *__p[2];
  char v29;
  void *__dst[2];
  uint64_t v31;
  uint8_t buf[4];
  int v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  void **v37;
  __int16 v38;
  void **v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  const char *v43;

  if (a2)
    v5 = (void **)(a2 - 8);
  else
    v5 = 0;
  if (!lpsrc
  {
    v7 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_52;
    while (1)
    {
      v8 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v9 = (char *)v5[2];
        if (v9[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v9 + 1), *((_QWORD *)v9 + 2));
        }
        else
        {
          v10 = *(_OWORD *)(v9 + 8);
          v31 = *((_QWORD *)v9 + 3);
          *(_OWORD *)__dst = v10;
        }
        v11 = SHIBYTE(v31);
        v12 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v13 = __dst;
        if (v11 < 0)
          v13 = v12;
        if (v29 >= 0)
          v14 = __p;
        else
          v14 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v33 = 0;
        v34 = 2082;
        v35 = "";
        v36 = 2081;
        v37 = v13;
        v38 = 2081;
        v39 = v14;
        v40 = 2082;
        v41 = "assert";
        v42 = 2081;
        v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v31) < 0)
          operator delete(__dst[0]);
        if (v7[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v15 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v16 = (char *)v5[2];
        if (v16[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v16 + 1), *((_QWORD *)v16 + 2));
        }
        else
        {
          v17 = *(_OWORD *)(v16 + 8);
          v31 = *((_QWORD *)v16 + 3);
          *(_OWORD *)__dst = v17;
        }
        v18 = SHIBYTE(v31);
        v19 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v20 = __dst;
        if (v18 < 0)
          v20 = v19;
        if (v29 >= 0)
          v21 = __p;
        else
          v21 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v33 = 0;
        v34 = 2082;
        v35 = "";
        v36 = 2081;
        v37 = v20;
        v38 = 2081;
        v39 = v21;
        v40 = 2082;
        v41 = "assert";
        v42 = 2081;
        v43 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v31) < 0)
          operator delete(__dst[0]);
        if (v7[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v22 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v23 = (char *)v5[2];
        if (v23[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v23 + 1), *((_QWORD *)v23 + 2));
        }
        else
        {
          v24 = *(_OWORD *)(v23 + 8);
          v31 = *((_QWORD *)v23 + 3);
          *(_OWORD *)__dst = v24;
        }
        v25 = SHIBYTE(v31);
        v7 = (uint64_t *)__dst[0];
        v5 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v26 = __dst;
        if (v25 < 0)
          v26 = (void **)v7;
        if (v29 >= 0)
          v27 = __p;
        else
          v27 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v33 = 0;
        v34 = 2082;
        v35 = "";
        v36 = 2081;
        v37 = v26;
        v38 = 2081;
        v39 = v27;
        v40 = 2082;
        v41 = "assert";
        v42 = 2081;
        v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v31) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
  }
  return sub_100326C64((uint64_t)v5, a3);
}

void sub_100332ACC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double sub_100332AF8@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void **v5;
  void *v6;
  uint64_t *v8;
  NSObject *v9;
  char *v10;
  __int128 v11;
  int v12;
  void **v13;
  void **v14;
  void **v15;
  NSObject *v16;
  char *v17;
  __int128 v18;
  int v19;
  void **v20;
  void **v21;
  void **v22;
  NSObject *v23;
  char *v24;
  __int128 v25;
  int v26;
  void **v27;
  void **v28;
  void *__p[2];
  char v30;
  void *__dst[2];
  uint64_t v32;
  uint8_t buf[4];
  int v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  void **v38;
  __int16 v39;
  void **v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  const char *v44;

  if (a2)
    v5 = (void **)(a2 - 8);
  else
    v5 = 0;
  if (!lpsrc
  {
    v8 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_52;
    while (1)
    {
      v9 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v10 + 1), *((_QWORD *)v10 + 2));
        }
        else
        {
          v11 = *(_OWORD *)(v10 + 8);
          v32 = *((_QWORD *)v10 + 3);
          *(_OWORD *)__dst = v11;
        }
        v12 = SHIBYTE(v32);
        v13 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v14 = __dst;
        if (v12 < 0)
          v14 = v13;
        if (v30 >= 0)
          v15 = __p;
        else
          v15 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v14;
        v39 = 2081;
        v40 = v15;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v16 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v17 + 1), *((_QWORD *)v17 + 2));
        }
        else
        {
          v18 = *(_OWORD *)(v17 + 8);
          v32 = *((_QWORD *)v17 + 3);
          *(_OWORD *)__dst = v18;
        }
        v19 = SHIBYTE(v32);
        v20 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v21 = __dst;
        if (v19 < 0)
          v21 = v20;
        if (v30 >= 0)
          v22 = __p;
        else
          v22 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v21;
        v39 = 2081;
        v40 = v22;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v23 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v24 + 1), *((_QWORD *)v24 + 2));
        }
        else
        {
          v25 = *(_OWORD *)(v24 + 8);
          v32 = *((_QWORD *)v24 + 3);
          *(_OWORD *)__dst = v25;
        }
        v26 = SHIBYTE(v32);
        v8 = (uint64_t *)__dst[0];
        v5 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v27 = __dst;
        if (v26 < 0)
          v27 = (void **)v8;
        if (v30 >= 0)
          v28 = __p;
        else
          v28 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v27;
        v39 = 2081;
        v40 = v28;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
  }
  return sub_100326D80((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_100332F5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double sub_100332F88@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void **v5;
  void *v6;
  uint64_t *v8;
  NSObject *v9;
  char *v10;
  __int128 v11;
  int v12;
  void **v13;
  void **v14;
  void **v15;
  NSObject *v16;
  char *v17;
  __int128 v18;
  int v19;
  void **v20;
  void **v21;
  void **v22;
  NSObject *v23;
  char *v24;
  __int128 v25;
  int v26;
  void **v27;
  void **v28;
  void *__p[2];
  char v30;
  void *__dst[2];
  uint64_t v32;
  uint8_t buf[4];
  int v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  void **v38;
  __int16 v39;
  void **v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  const char *v44;

  if (a2)
    v5 = (void **)(a2 - 8);
  else
    v5 = 0;
  if (!lpsrc
  {
    v8 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_52;
    while (1)
    {
      v9 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v10 + 1), *((_QWORD *)v10 + 2));
        }
        else
        {
          v11 = *(_OWORD *)(v10 + 8);
          v32 = *((_QWORD *)v10 + 3);
          *(_OWORD *)__dst = v11;
        }
        v12 = SHIBYTE(v32);
        v13 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v14 = __dst;
        if (v12 < 0)
          v14 = v13;
        if (v30 >= 0)
          v15 = __p;
        else
          v15 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v14;
        v39 = 2081;
        v40 = v15;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v16 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v17 + 1), *((_QWORD *)v17 + 2));
        }
        else
        {
          v18 = *(_OWORD *)(v17 + 8);
          v32 = *((_QWORD *)v17 + 3);
          *(_OWORD *)__dst = v18;
        }
        v19 = SHIBYTE(v32);
        v20 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v21 = __dst;
        if (v19 < 0)
          v21 = v20;
        if (v30 >= 0)
          v22 = __p;
        else
          v22 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v21;
        v39 = 2081;
        v40 = v22;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v23 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v24 + 1), *((_QWORD *)v24 + 2));
        }
        else
        {
          v25 = *(_OWORD *)(v24 + 8);
          v32 = *((_QWORD *)v24 + 3);
          *(_OWORD *)__dst = v25;
        }
        v26 = SHIBYTE(v32);
        v8 = (uint64_t *)__dst[0];
        v5 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v27 = __dst;
        if (v26 < 0)
          v27 = (void **)v8;
        if (v30 >= 0)
          v28 = __p;
        else
          v28 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v27;
        v39 = 2081;
        v40 = v28;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
  }
  return sub_100326F58((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_1003333EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double sub_100333418@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void **v5;
  void *v6;
  uint64_t *v8;
  NSObject *v9;
  char *v10;
  __int128 v11;
  int v12;
  void **v13;
  void **v14;
  void **v15;
  NSObject *v16;
  char *v17;
  __int128 v18;
  int v19;
  void **v20;
  void **v21;
  void **v22;
  NSObject *v23;
  char *v24;
  __int128 v25;
  int v26;
  void **v27;
  void **v28;
  void *__p[2];
  char v30;
  void *__dst[2];
  uint64_t v32;
  uint8_t buf[4];
  int v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  void **v38;
  __int16 v39;
  void **v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  const char *v44;

  if (a2)
    v5 = (void **)(a2 - 8);
  else
    v5 = 0;
  if (!lpsrc
  {
    v8 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_52;
    while (1)
    {
      v9 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v10 + 1), *((_QWORD *)v10 + 2));
        }
        else
        {
          v11 = *(_OWORD *)(v10 + 8);
          v32 = *((_QWORD *)v10 + 3);
          *(_OWORD *)__dst = v11;
        }
        v12 = SHIBYTE(v32);
        v13 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v14 = __dst;
        if (v12 < 0)
          v14 = v13;
        if (v30 >= 0)
          v15 = __p;
        else
          v15 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v14;
        v39 = 2081;
        v40 = v15;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v16 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v17 + 1), *((_QWORD *)v17 + 2));
        }
        else
        {
          v18 = *(_OWORD *)(v17 + 8);
          v32 = *((_QWORD *)v17 + 3);
          *(_OWORD *)__dst = v18;
        }
        v19 = SHIBYTE(v32);
        v20 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v21 = __dst;
        if (v19 < 0)
          v21 = v20;
        if (v30 >= 0)
          v22 = __p;
        else
          v22 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v21;
        v39 = 2081;
        v40 = v22;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v23 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v24 + 1), *((_QWORD *)v24 + 2));
        }
        else
        {
          v25 = *(_OWORD *)(v24 + 8);
          v32 = *((_QWORD *)v24 + 3);
          *(_OWORD *)__dst = v25;
        }
        v26 = SHIBYTE(v32);
        v8 = (uint64_t *)__dst[0];
        v5 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v27 = __dst;
        if (v26 < 0)
          v27 = (void **)v8;
        if (v30 >= 0)
          v28 = __p;
        else
          v28 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v27;
        v39 = 2081;
        v40 = v28;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
  }
  return sub_1003272A4((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_10033387C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double sub_1003338A8@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void **v5;
  void *v6;
  uint64_t *v8;
  NSObject *v9;
  char *v10;
  __int128 v11;
  int v12;
  void **v13;
  void **v14;
  void **v15;
  NSObject *v16;
  char *v17;
  __int128 v18;
  int v19;
  void **v20;
  void **v21;
  void **v22;
  NSObject *v23;
  char *v24;
  __int128 v25;
  int v26;
  void **v27;
  void **v28;
  void *__p[2];
  char v30;
  void *__dst[2];
  uint64_t v32;
  uint8_t buf[4];
  int v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  void **v38;
  __int16 v39;
  void **v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  const char *v44;

  if (a2)
    v5 = (void **)(a2 - 8);
  else
    v5 = 0;
  if (!lpsrc
  {
    v8 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_52;
    while (1)
    {
      v9 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v10 + 1), *((_QWORD *)v10 + 2));
        }
        else
        {
          v11 = *(_OWORD *)(v10 + 8);
          v32 = *((_QWORD *)v10 + 3);
          *(_OWORD *)__dst = v11;
        }
        v12 = SHIBYTE(v32);
        v13 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v14 = __dst;
        if (v12 < 0)
          v14 = v13;
        if (v30 >= 0)
          v15 = __p;
        else
          v15 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v14;
        v39 = 2081;
        v40 = v15;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v16 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v17 + 1), *((_QWORD *)v17 + 2));
        }
        else
        {
          v18 = *(_OWORD *)(v17 + 8);
          v32 = *((_QWORD *)v17 + 3);
          *(_OWORD *)__dst = v18;
        }
        v19 = SHIBYTE(v32);
        v20 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v21 = __dst;
        if (v19 < 0)
          v21 = v20;
        if (v30 >= 0)
          v22 = __p;
        else
          v22 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v21;
        v39 = 2081;
        v40 = v22;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v23 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v24 + 1), *((_QWORD *)v24 + 2));
        }
        else
        {
          v25 = *(_OWORD *)(v24 + 8);
          v32 = *((_QWORD *)v24 + 3);
          *(_OWORD *)__dst = v25;
        }
        v26 = SHIBYTE(v32);
        v8 = (uint64_t *)__dst[0];
        v5 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v27 = __dst;
        if (v26 < 0)
          v27 = (void **)v8;
        if (v30 >= 0)
          v28 = __p;
        else
          v28 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v27;
        v39 = 2081;
        v40 = v28;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
  }
  return sub_100327370(v5, (uint64_t)v6, a3);
}

void sub_100333D0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double sub_100333D38@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void **v5;
  void *v6;
  uint64_t *v8;
  NSObject *v9;
  char *v10;
  __int128 v11;
  int v12;
  void **v13;
  void **v14;
  void **v15;
  NSObject *v16;
  char *v17;
  __int128 v18;
  int v19;
  void **v20;
  void **v21;
  void **v22;
  NSObject *v23;
  char *v24;
  __int128 v25;
  int v26;
  void **v27;
  void **v28;
  void *__p[2];
  char v30;
  void *__dst[2];
  uint64_t v32;
  uint8_t buf[4];
  int v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  void **v38;
  __int16 v39;
  void **v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  const char *v44;

  if (a2)
    v5 = (void **)(a2 - 8);
  else
    v5 = 0;
  if (!lpsrc
  {
    v8 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_52;
    while (1)
    {
      v9 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v10 + 1), *((_QWORD *)v10 + 2));
        }
        else
        {
          v11 = *(_OWORD *)(v10 + 8);
          v32 = *((_QWORD *)v10 + 3);
          *(_OWORD *)__dst = v11;
        }
        v12 = SHIBYTE(v32);
        v13 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v14 = __dst;
        if (v12 < 0)
          v14 = v13;
        if (v30 >= 0)
          v15 = __p;
        else
          v15 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v14;
        v39 = 2081;
        v40 = v15;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v16 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v17 + 1), *((_QWORD *)v17 + 2));
        }
        else
        {
          v18 = *(_OWORD *)(v17 + 8);
          v32 = *((_QWORD *)v17 + 3);
          *(_OWORD *)__dst = v18;
        }
        v19 = SHIBYTE(v32);
        v20 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v21 = __dst;
        if (v19 < 0)
          v21 = v20;
        if (v30 >= 0)
          v22 = __p;
        else
          v22 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v21;
        v39 = 2081;
        v40 = v22;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v23 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v24 + 1), *((_QWORD *)v24 + 2));
        }
        else
        {
          v25 = *(_OWORD *)(v24 + 8);
          v32 = *((_QWORD *)v24 + 3);
          *(_OWORD *)__dst = v25;
        }
        v26 = SHIBYTE(v32);
        v8 = (uint64_t *)__dst[0];
        v5 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v27 = __dst;
        if (v26 < 0)
          v27 = (void **)v8;
        if (v30 >= 0)
          v28 = __p;
        else
          v28 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v27;
        v39 = 2081;
        v40 = v28;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
  }
  return sub_100327A1C(v5, (uint64_t)v6, a3);
}

void sub_10033419C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double sub_1003341C8@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void **v5;
  void *v6;
  uint64_t *v8;
  NSObject *v9;
  char *v10;
  __int128 v11;
  int v12;
  void **v13;
  void **v14;
  void **v15;
  NSObject *v16;
  char *v17;
  __int128 v18;
  int v19;
  void **v20;
  void **v21;
  void **v22;
  NSObject *v23;
  char *v24;
  __int128 v25;
  int v26;
  void **v27;
  void **v28;
  void *__p[2];
  char v30;
  void *__dst[2];
  uint64_t v32;
  uint8_t buf[4];
  int v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  void **v38;
  __int16 v39;
  void **v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  const char *v44;

  if (a2)
    v5 = (void **)(a2 - 8);
  else
    v5 = 0;
  if (!lpsrc
  {
    v8 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_52;
    while (1)
    {
      v9 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v10 + 1), *((_QWORD *)v10 + 2));
        }
        else
        {
          v11 = *(_OWORD *)(v10 + 8);
          v32 = *((_QWORD *)v10 + 3);
          *(_OWORD *)__dst = v11;
        }
        v12 = SHIBYTE(v32);
        v13 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v14 = __dst;
        if (v12 < 0)
          v14 = v13;
        if (v30 >= 0)
          v15 = __p;
        else
          v15 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v14;
        v39 = 2081;
        v40 = v15;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v16 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v17 + 1), *((_QWORD *)v17 + 2));
        }
        else
        {
          v18 = *(_OWORD *)(v17 + 8);
          v32 = *((_QWORD *)v17 + 3);
          *(_OWORD *)__dst = v18;
        }
        v19 = SHIBYTE(v32);
        v20 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v21 = __dst;
        if (v19 < 0)
          v21 = v20;
        if (v30 >= 0)
          v22 = __p;
        else
          v22 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v21;
        v39 = 2081;
        v40 = v22;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v23 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v24 + 1), *((_QWORD *)v24 + 2));
        }
        else
        {
          v25 = *(_OWORD *)(v24 + 8);
          v32 = *((_QWORD *)v24 + 3);
          *(_OWORD *)__dst = v25;
        }
        v26 = SHIBYTE(v32);
        v8 = (uint64_t *)__dst[0];
        v5 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v27 = __dst;
        if (v26 < 0)
          v27 = (void **)v8;
        if (v30 >= 0)
          v28 = __p;
        else
          v28 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v27;
        v39 = 2081;
        v40 = v28;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
  }
  return sub_1003280A0((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_10033462C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double sub_100334658@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void **v5;
  uint64_t *v6;
  uint64_t *v8;
  NSObject *v9;
  char *v10;
  __int128 v11;
  int v12;
  void **v13;
  void **v14;
  void **v15;
  NSObject *v16;
  char *v17;
  __int128 v18;
  int v19;
  void **v20;
  void **v21;
  void **v22;
  NSObject *v23;
  char *v24;
  __int128 v25;
  int v26;
  void **v27;
  void **v28;
  void *__p[2];
  char v30;
  void *__dst[2];
  uint64_t v32;
  uint8_t buf[4];
  int v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  void **v38;
  __int16 v39;
  void **v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  const char *v44;

  if (a2)
    v5 = (void **)(a2 - 8);
  else
    v5 = 0;
  if (!lpsrc
  {
    v8 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_52;
    while (1)
    {
      v9 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v10 + 1), *((_QWORD *)v10 + 2));
        }
        else
        {
          v11 = *(_OWORD *)(v10 + 8);
          v32 = *((_QWORD *)v10 + 3);
          *(_OWORD *)__dst = v11;
        }
        v12 = SHIBYTE(v32);
        v13 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v14 = __dst;
        if (v12 < 0)
          v14 = v13;
        if (v30 >= 0)
          v15 = __p;
        else
          v15 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v14;
        v39 = 2081;
        v40 = v15;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v16 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v17 + 1), *((_QWORD *)v17 + 2));
        }
        else
        {
          v18 = *(_OWORD *)(v17 + 8);
          v32 = *((_QWORD *)v17 + 3);
          *(_OWORD *)__dst = v18;
        }
        v19 = SHIBYTE(v32);
        v20 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v21 = __dst;
        if (v19 < 0)
          v21 = v20;
        if (v30 >= 0)
          v22 = __p;
        else
          v22 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v21;
        v39 = 2081;
        v40 = v22;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v23 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v24 + 1), *((_QWORD *)v24 + 2));
        }
        else
        {
          v25 = *(_OWORD *)(v24 + 8);
          v32 = *((_QWORD *)v24 + 3);
          *(_OWORD *)__dst = v25;
        }
        v26 = SHIBYTE(v32);
        v8 = (uint64_t *)__dst[0];
        v5 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v27 = __dst;
        if (v26 < 0)
          v27 = (void **)v8;
        if (v30 >= 0)
          v28 = __p;
        else
          v28 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v27;
        v39 = 2081;
        v40 = v28;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
  }
  return sub_100328140(v5, v6, a3);
}

void sub_100334ABC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double sub_100334AE8@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void **v5;
  void *v6;
  uint64_t *v8;
  NSObject *v9;
  char *v10;
  __int128 v11;
  int v12;
  void **v13;
  void **v14;
  void **v15;
  NSObject *v16;
  char *v17;
  __int128 v18;
  int v19;
  void **v20;
  void **v21;
  void **v22;
  NSObject *v23;
  char *v24;
  __int128 v25;
  int v26;
  void **v27;
  void **v28;
  void *__p[2];
  char v30;
  void *__dst[2];
  uint64_t v32;
  uint8_t buf[4];
  int v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  void **v38;
  __int16 v39;
  void **v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  const char *v44;

  if (a2)
    v5 = (void **)(a2 - 8);
  else
    v5 = 0;
  if (!lpsrc
  {
    v8 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_52;
    while (1)
    {
      v9 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v10 + 1), *((_QWORD *)v10 + 2));
        }
        else
        {
          v11 = *(_OWORD *)(v10 + 8);
          v32 = *((_QWORD *)v10 + 3);
          *(_OWORD *)__dst = v11;
        }
        v12 = SHIBYTE(v32);
        v13 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v14 = __dst;
        if (v12 < 0)
          v14 = v13;
        if (v30 >= 0)
          v15 = __p;
        else
          v15 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v14;
        v39 = 2081;
        v40 = v15;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v16 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v17 + 1), *((_QWORD *)v17 + 2));
        }
        else
        {
          v18 = *(_OWORD *)(v17 + 8);
          v32 = *((_QWORD *)v17 + 3);
          *(_OWORD *)__dst = v18;
        }
        v19 = SHIBYTE(v32);
        v20 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v21 = __dst;
        if (v19 < 0)
          v21 = v20;
        if (v30 >= 0)
          v22 = __p;
        else
          v22 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v21;
        v39 = 2081;
        v40 = v22;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v23 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v24 + 1), *((_QWORD *)v24 + 2));
        }
        else
        {
          v25 = *(_OWORD *)(v24 + 8);
          v32 = *((_QWORD *)v24 + 3);
          *(_OWORD *)__dst = v25;
        }
        v26 = SHIBYTE(v32);
        v8 = (uint64_t *)__dst[0];
        v5 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v27 = __dst;
        if (v26 < 0)
          v27 = (void **)v8;
        if (v30 >= 0)
          v28 = __p;
        else
          v28 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v27;
        v39 = 2081;
        v40 = v28;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
  }
  return sub_1003282D8((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_100334F4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double sub_100334F78@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void **v5;
  _QWORD *v6;
  double result;
  uint64_t *v8;
  NSObject *v9;
  char *v10;
  __int128 v11;
  int v12;
  void **v13;
  void **v14;
  void **v15;
  NSObject *v16;
  char *v17;
  __int128 v18;
  int v19;
  void **v20;
  void **v21;
  void **v22;
  NSObject *v23;
  char *v24;
  __int128 v25;
  int v26;
  void **v27;
  void **v28;
  void *__p[2];
  char v30;
  void *__dst[2];
  uint64_t v32;
  _BYTE buf[28];
  __int16 v34;
  void **v35;
  __int16 v36;
  const char *v37;
  __int16 v38;
  const char *v39;

  if (a2)
    v5 = (void **)(a2 - 8);
  else
    v5 = 0;
  if (!lpsrc
  {
    v8 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_52;
    while (1)
    {
      v9 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v10 + 1), *((_QWORD *)v10 + 2));
        }
        else
        {
          v11 = *(_OWORD *)(v10 + 8);
          v32 = *((_QWORD *)v10 + 3);
          *(_OWORD *)__dst = v11;
        }
        v12 = SHIBYTE(v32);
        v13 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v14 = __dst;
        if (v12 < 0)
          v14 = v13;
        if (v30 >= 0)
          v15 = __p;
        else
          v15 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        *(_DWORD *)&buf[4] = 0;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2081;
        *(_QWORD *)&buf[20] = v14;
        v34 = 2081;
        v35 = v15;
        v36 = 2082;
        v37 = "assert";
        v38 = 2081;
        v39 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v16 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v17 + 1), *((_QWORD *)v17 + 2));
        }
        else
        {
          v18 = *(_OWORD *)(v17 + 8);
          v32 = *((_QWORD *)v17 + 3);
          *(_OWORD *)__dst = v18;
        }
        v19 = SHIBYTE(v32);
        v20 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v21 = __dst;
        if (v19 < 0)
          v21 = v20;
        if (v30 >= 0)
          v22 = __p;
        else
          v22 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        *(_DWORD *)&buf[4] = 0;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2081;
        *(_QWORD *)&buf[20] = v21;
        v34 = 2081;
        v35 = v22;
        v36 = 2082;
        v37 = "assert";
        v38 = 2081;
        v39 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v23 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v24 + 1), *((_QWORD *)v24 + 2));
        }
        else
        {
          v25 = *(_OWORD *)(v24 + 8);
          v32 = *((_QWORD *)v24 + 3);
          *(_OWORD *)__dst = v25;
        }
        v26 = SHIBYTE(v32);
        v8 = (uint64_t *)__dst[0];
        v5 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v27 = __dst;
        if (v26 < 0)
          v27 = (void **)v8;
        if (v30 >= 0)
          v28 = __p;
        else
          v28 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        *(_DWORD *)&buf[4] = 0;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2081;
        *(_QWORD *)&buf[20] = v27;
        v34 = 2081;
        v35 = v28;
        v36 = 2082;
        v37 = "assert";
        v38 = 2081;
        v39 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
  }
  sub_10032D110((uint64_t)v5, v6[4], v6[5], buf);
  result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_1003353F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double sub_100335424@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void **v5;
  char *v6;
  uint64_t *v8;
  NSObject *v9;
  char *v10;
  __int128 v11;
  int v12;
  void **v13;
  void **v14;
  void **v15;
  NSObject *v16;
  char *v17;
  __int128 v18;
  int v19;
  void **v20;
  void **v21;
  void **v22;
  NSObject *v23;
  char *v24;
  __int128 v25;
  int v26;
  void **v27;
  void **v28;
  void *__p[2];
  char v30;
  void *__dst[2];
  uint64_t v32;
  uint8_t buf[4];
  int v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  void **v38;
  __int16 v39;
  void **v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  const char *v44;

  if (a2)
    v5 = (void **)(a2 - 8);
  else
    v5 = 0;
  if (!lpsrc
  {
    v8 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_52;
    while (1)
    {
      v9 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v10 + 1), *((_QWORD *)v10 + 2));
        }
        else
        {
          v11 = *(_OWORD *)(v10 + 8);
          v32 = *((_QWORD *)v10 + 3);
          *(_OWORD *)__dst = v11;
        }
        v12 = SHIBYTE(v32);
        v13 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v14 = __dst;
        if (v12 < 0)
          v14 = v13;
        if (v30 >= 0)
          v15 = __p;
        else
          v15 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v14;
        v39 = 2081;
        v40 = v15;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v16 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v17 + 1), *((_QWORD *)v17 + 2));
        }
        else
        {
          v18 = *(_OWORD *)(v17 + 8);
          v32 = *((_QWORD *)v17 + 3);
          *(_OWORD *)__dst = v18;
        }
        v19 = SHIBYTE(v32);
        v20 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v21 = __dst;
        if (v19 < 0)
          v21 = v20;
        if (v30 >= 0)
          v22 = __p;
        else
          v22 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v21;
        v39 = 2081;
        v40 = v22;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v23 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v24 + 1), *((_QWORD *)v24 + 2));
        }
        else
        {
          v25 = *(_OWORD *)(v24 + 8);
          v32 = *((_QWORD *)v24 + 3);
          *(_OWORD *)__dst = v25;
        }
        v26 = SHIBYTE(v32);
        v8 = (uint64_t *)__dst[0];
        v5 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v27 = __dst;
        if (v26 < 0)
          v27 = (void **)v8;
        if (v30 >= 0)
          v28 = __p;
        else
          v28 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v27;
        v39 = 2081;
        v40 = v28;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
  }
  return sub_100328368((uint64_t)v5, v6, a3);
}

void sub_100335888(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1003358B4(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void **v5;
  void *v6;
  uint64_t *v7;
  NSObject *v8;
  char *v9;
  __int128 v10;
  int v11;
  void **v12;
  void **v13;
  void **v14;
  NSObject *v15;
  char *v16;
  __int128 v17;
  int v18;
  void **v19;
  void **v20;
  void **v21;
  NSObject *v22;
  char *v23;
  __int128 v24;
  int v25;
  void **v26;
  void **v27;
  void *__p[2];
  char v29;
  void *__dst[2];
  uint64_t v31;
  uint8_t buf[4];
  int v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  void **v37;
  __int16 v38;
  void **v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  const char *v43;

  if (a2)
    v5 = (void **)(a2 - 8);
  else
    v5 = 0;
  if (!lpsrc
  {
    v7 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_52;
    while (1)
    {
      v8 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v9 = (char *)v5[2];
        if (v9[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v9 + 1), *((_QWORD *)v9 + 2));
        }
        else
        {
          v10 = *(_OWORD *)(v9 + 8);
          v31 = *((_QWORD *)v9 + 3);
          *(_OWORD *)__dst = v10;
        }
        v11 = SHIBYTE(v31);
        v12 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v13 = __dst;
        if (v11 < 0)
          v13 = v12;
        if (v29 >= 0)
          v14 = __p;
        else
          v14 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v33 = 0;
        v34 = 2082;
        v35 = "";
        v36 = 2081;
        v37 = v13;
        v38 = 2081;
        v39 = v14;
        v40 = 2082;
        v41 = "assert";
        v42 = 2081;
        v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v31) < 0)
          operator delete(__dst[0]);
        if (v7[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v15 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v16 = (char *)v5[2];
        if (v16[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v16 + 1), *((_QWORD *)v16 + 2));
        }
        else
        {
          v17 = *(_OWORD *)(v16 + 8);
          v31 = *((_QWORD *)v16 + 3);
          *(_OWORD *)__dst = v17;
        }
        v18 = SHIBYTE(v31);
        v19 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v20 = __dst;
        if (v18 < 0)
          v20 = v19;
        if (v29 >= 0)
          v21 = __p;
        else
          v21 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v33 = 0;
        v34 = 2082;
        v35 = "";
        v36 = 2081;
        v37 = v20;
        v38 = 2081;
        v39 = v21;
        v40 = 2082;
        v41 = "assert";
        v42 = 2081;
        v43 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v31) < 0)
          operator delete(__dst[0]);
        if (v7[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v22 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v23 = (char *)v5[2];
        if (v23[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v23 + 1), *((_QWORD *)v23 + 2));
        }
        else
        {
          v24 = *(_OWORD *)(v23 + 8);
          v31 = *((_QWORD *)v23 + 3);
          *(_OWORD *)__dst = v24;
        }
        v25 = SHIBYTE(v31);
        v7 = (uint64_t *)__dst[0];
        v5 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v26 = __dst;
        if (v25 < 0)
          v26 = (void **)v7;
        if (v29 >= 0)
          v27 = __p;
        else
          v27 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v33 = 0;
        v34 = 2082;
        v35 = "";
        v36 = 2081;
        v37 = v26;
        v38 = 2081;
        v39 = v27;
        v40 = 2082;
        v41 = "assert";
        v42 = 2081;
        v43 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v29 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v31) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
  }
  sub_1003286F0((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_100335D18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double sub_100335D44@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void **v5;
  char *v6;
  uint64_t *v8;
  NSObject *v9;
  char *v10;
  __int128 v11;
  int v12;
  void **v13;
  void **v14;
  void **v15;
  NSObject *v16;
  char *v17;
  __int128 v18;
  int v19;
  void **v20;
  void **v21;
  void **v22;
  NSObject *v23;
  char *v24;
  __int128 v25;
  int v26;
  void **v27;
  void **v28;
  void *__p[2];
  char v30;
  void *__dst[2];
  uint64_t v32;
  uint8_t buf[4];
  int v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  void **v38;
  __int16 v39;
  void **v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  const char *v44;

  if (a2)
    v5 = (void **)(a2 - 8);
  else
    v5 = 0;
  if (!lpsrc
  {
    v8 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_52;
    while (1)
    {
      v9 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v10 + 1), *((_QWORD *)v10 + 2));
        }
        else
        {
          v11 = *(_OWORD *)(v10 + 8);
          v32 = *((_QWORD *)v10 + 3);
          *(_OWORD *)__dst = v11;
        }
        v12 = SHIBYTE(v32);
        v13 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v14 = __dst;
        if (v12 < 0)
          v14 = v13;
        if (v30 >= 0)
          v15 = __p;
        else
          v15 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v14;
        v39 = 2081;
        v40 = v15;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v16 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v17 + 1), *((_QWORD *)v17 + 2));
        }
        else
        {
          v18 = *(_OWORD *)(v17 + 8);
          v32 = *((_QWORD *)v17 + 3);
          *(_OWORD *)__dst = v18;
        }
        v19 = SHIBYTE(v32);
        v20 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v21 = __dst;
        if (v19 < 0)
          v21 = v20;
        if (v30 >= 0)
          v22 = __p;
        else
          v22 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v21;
        v39 = 2081;
        v40 = v22;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v23 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v24 + 1), *((_QWORD *)v24 + 2));
        }
        else
        {
          v25 = *(_OWORD *)(v24 + 8);
          v32 = *((_QWORD *)v24 + 3);
          *(_OWORD *)__dst = v25;
        }
        v26 = SHIBYTE(v32);
        v8 = (uint64_t *)__dst[0];
        v5 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v27 = __dst;
        if (v26 < 0)
          v27 = (void **)v8;
        if (v30 >= 0)
          v28 = __p;
        else
          v28 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v27;
        v39 = 2081;
        v40 = v28;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
  }
  return sub_10032923C((uint64_t)v5, v6, a3);
}

void sub_1003361A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double sub_1003361D4@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void **v5;
  char *v6;
  uint64_t *v8;
  NSObject *v9;
  char *v10;
  __int128 v11;
  int v12;
  void **v13;
  void **v14;
  void **v15;
  NSObject *v16;
  char *v17;
  __int128 v18;
  int v19;
  void **v20;
  void **v21;
  void **v22;
  NSObject *v23;
  char *v24;
  __int128 v25;
  int v26;
  void **v27;
  void **v28;
  void *__p[2];
  char v30;
  void *__dst[2];
  uint64_t v32;
  uint8_t buf[4];
  int v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  void **v38;
  __int16 v39;
  void **v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  const char *v44;

  if (a2)
    v5 = (void **)(a2 - 8);
  else
    v5 = 0;
  if (!lpsrc
  {
    v8 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_52;
    while (1)
    {
      v9 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v10 + 1), *((_QWORD *)v10 + 2));
        }
        else
        {
          v11 = *(_OWORD *)(v10 + 8);
          v32 = *((_QWORD *)v10 + 3);
          *(_OWORD *)__dst = v11;
        }
        v12 = SHIBYTE(v32);
        v13 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v14 = __dst;
        if (v12 < 0)
          v14 = v13;
        if (v30 >= 0)
          v15 = __p;
        else
          v15 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v14;
        v39 = 2081;
        v40 = v15;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v16 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v17 + 1), *((_QWORD *)v17 + 2));
        }
        else
        {
          v18 = *(_OWORD *)(v17 + 8);
          v32 = *((_QWORD *)v17 + 3);
          *(_OWORD *)__dst = v18;
        }
        v19 = SHIBYTE(v32);
        v20 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v21 = __dst;
        if (v19 < 0)
          v21 = v20;
        if (v30 >= 0)
          v22 = __p;
        else
          v22 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v21;
        v39 = 2081;
        v40 = v22;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v23 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v24 + 1), *((_QWORD *)v24 + 2));
        }
        else
        {
          v25 = *(_OWORD *)(v24 + 8);
          v32 = *((_QWORD *)v24 + 3);
          *(_OWORD *)__dst = v25;
        }
        v26 = SHIBYTE(v32);
        v8 = (uint64_t *)__dst[0];
        v5 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v27 = __dst;
        if (v26 < 0)
          v27 = (void **)v8;
        if (v30 >= 0)
          v28 = __p;
        else
          v28 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v27;
        v39 = 2081;
        v40 = v28;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
  }
  return sub_1003296FC((uint64_t)v5, v6, a3);
}

void sub_100336638(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double sub_100336664@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void **v5;
  char *v6;
  uint64_t *v8;
  NSObject *v9;
  char *v10;
  __int128 v11;
  int v12;
  void **v13;
  void **v14;
  void **v15;
  NSObject *v16;
  char *v17;
  __int128 v18;
  int v19;
  void **v20;
  void **v21;
  void **v22;
  NSObject *v23;
  char *v24;
  __int128 v25;
  int v26;
  void **v27;
  void **v28;
  void *__p[2];
  char v30;
  void *__dst[2];
  uint64_t v32;
  uint8_t buf[4];
  int v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  void **v38;
  __int16 v39;
  void **v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  const char *v44;

  if (a2)
    v5 = (void **)(a2 - 8);
  else
    v5 = 0;
  if (!lpsrc
  {
    v8 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_52;
    while (1)
    {
      v9 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v10 + 1), *((_QWORD *)v10 + 2));
        }
        else
        {
          v11 = *(_OWORD *)(v10 + 8);
          v32 = *((_QWORD *)v10 + 3);
          *(_OWORD *)__dst = v11;
        }
        v12 = SHIBYTE(v32);
        v13 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v14 = __dst;
        if (v12 < 0)
          v14 = v13;
        if (v30 >= 0)
          v15 = __p;
        else
          v15 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v14;
        v39 = 2081;
        v40 = v15;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v16 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v17 + 1), *((_QWORD *)v17 + 2));
        }
        else
        {
          v18 = *(_OWORD *)(v17 + 8);
          v32 = *((_QWORD *)v17 + 3);
          *(_OWORD *)__dst = v18;
        }
        v19 = SHIBYTE(v32);
        v20 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v21 = __dst;
        if (v19 < 0)
          v21 = v20;
        if (v30 >= 0)
          v22 = __p;
        else
          v22 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v21;
        v39 = 2081;
        v40 = v22;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v23 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v24 + 1), *((_QWORD *)v24 + 2));
        }
        else
        {
          v25 = *(_OWORD *)(v24 + 8);
          v32 = *((_QWORD *)v24 + 3);
          *(_OWORD *)__dst = v25;
        }
        v26 = SHIBYTE(v32);
        v8 = (uint64_t *)__dst[0];
        v5 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v27 = __dst;
        if (v26 < 0)
          v27 = (void **)v8;
        if (v30 >= 0)
          v28 = __p;
        else
          v28 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v27;
        v39 = 2081;
        v40 = v28;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
  }
  return sub_100329C84((uint64_t)v5, v6, a3);
}

void sub_100336AC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_100336AF4(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2 - 8;
  if (!a2)
    v2 = 0;
  *(_WORD *)(v2 + 490) = 1;
}

double sub_100336B0C@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void **v5;
  void *v6;
  uint64_t *v8;
  NSObject *v9;
  char *v10;
  __int128 v11;
  int v12;
  void **v13;
  void **v14;
  void **v15;
  NSObject *v16;
  char *v17;
  __int128 v18;
  int v19;
  void **v20;
  void **v21;
  void **v22;
  NSObject *v23;
  char *v24;
  __int128 v25;
  int v26;
  void **v27;
  void **v28;
  void *__p[2];
  char v30;
  void *__dst[2];
  uint64_t v32;
  uint8_t buf[4];
  int v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  void **v38;
  __int16 v39;
  void **v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  const char *v44;

  if (a2)
    v5 = (void **)(a2 - 8);
  else
    v5 = 0;
  if (!lpsrc
  {
    v8 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_52;
    while (1)
    {
      v9 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v10 + 1), *((_QWORD *)v10 + 2));
        }
        else
        {
          v11 = *(_OWORD *)(v10 + 8);
          v32 = *((_QWORD *)v10 + 3);
          *(_OWORD *)__dst = v11;
        }
        v12 = SHIBYTE(v32);
        v13 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v14 = __dst;
        if (v12 < 0)
          v14 = v13;
        if (v30 >= 0)
          v15 = __p;
        else
          v15 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v14;
        v39 = 2081;
        v40 = v15;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v16 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v17 + 1), *((_QWORD *)v17 + 2));
        }
        else
        {
          v18 = *(_OWORD *)(v17 + 8);
          v32 = *((_QWORD *)v17 + 3);
          *(_OWORD *)__dst = v18;
        }
        v19 = SHIBYTE(v32);
        v20 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v21 = __dst;
        if (v19 < 0)
          v21 = v20;
        if (v30 >= 0)
          v22 = __p;
        else
          v22 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v21;
        v39 = 2081;
        v40 = v22;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v23 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v24 + 1), *((_QWORD *)v24 + 2));
        }
        else
        {
          v25 = *(_OWORD *)(v24 + 8);
          v32 = *((_QWORD *)v24 + 3);
          *(_OWORD *)__dst = v25;
        }
        v26 = SHIBYTE(v32);
        v8 = (uint64_t *)__dst[0];
        v5 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v27 = __dst;
        if (v26 < 0)
          v27 = (void **)v8;
        if (v30 >= 0)
          v28 = __p;
        else
          v28 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v27;
        v39 = 2081;
        v40 = v28;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
  }
  return sub_10032A00C(v5, (uint64_t)v6, a3);
}

void sub_100336F70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double sub_100336F9C@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void **v5;
  void *v6;
  uint64_t *v8;
  NSObject *v9;
  char *v10;
  __int128 v11;
  int v12;
  void **v13;
  void **v14;
  void **v15;
  NSObject *v16;
  char *v17;
  __int128 v18;
  int v19;
  void **v20;
  void **v21;
  void **v22;
  NSObject *v23;
  char *v24;
  __int128 v25;
  int v26;
  void **v27;
  void **v28;
  void *__p[2];
  char v30;
  void *__dst[2];
  uint64_t v32;
  uint8_t buf[4];
  int v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  void **v38;
  __int16 v39;
  void **v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  const char *v44;

  if (a2)
    v5 = (void **)(a2 - 8);
  else
    v5 = 0;
  if (!lpsrc
  {
    v8 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_52;
    while (1)
    {
      v9 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v10 + 1), *((_QWORD *)v10 + 2));
        }
        else
        {
          v11 = *(_OWORD *)(v10 + 8);
          v32 = *((_QWORD *)v10 + 3);
          *(_OWORD *)__dst = v11;
        }
        v12 = SHIBYTE(v32);
        v13 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v14 = __dst;
        if (v12 < 0)
          v14 = v13;
        if (v30 >= 0)
          v15 = __p;
        else
          v15 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v14;
        v39 = 2081;
        v40 = v15;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v16 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v17 + 1), *((_QWORD *)v17 + 2));
        }
        else
        {
          v18 = *(_OWORD *)(v17 + 8);
          v32 = *((_QWORD *)v17 + 3);
          *(_OWORD *)__dst = v18;
        }
        v19 = SHIBYTE(v32);
        v20 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v21 = __dst;
        if (v19 < 0)
          v21 = v20;
        if (v30 >= 0)
          v22 = __p;
        else
          v22 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v21;
        v39 = 2081;
        v40 = v22;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v23 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v24 + 1), *((_QWORD *)v24 + 2));
        }
        else
        {
          v25 = *(_OWORD *)(v24 + 8);
          v32 = *((_QWORD *)v24 + 3);
          *(_OWORD *)__dst = v25;
        }
        v26 = SHIBYTE(v32);
        v8 = (uint64_t *)__dst[0];
        v5 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v27 = __dst;
        if (v26 < 0)
          v27 = (void **)v8;
        if (v30 >= 0)
          v28 = __p;
        else
          v28 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v27;
        v39 = 2081;
        v40 = v28;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
  }
  return sub_10032A544((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_100337400(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double sub_10033742C@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void **v5;
  void *v6;
  uint64_t *v8;
  NSObject *v9;
  char *v10;
  __int128 v11;
  int v12;
  void **v13;
  void **v14;
  void **v15;
  NSObject *v16;
  char *v17;
  __int128 v18;
  int v19;
  void **v20;
  void **v21;
  void **v22;
  NSObject *v23;
  char *v24;
  __int128 v25;
  int v26;
  void **v27;
  void **v28;
  void *__p[2];
  char v30;
  void *__dst[2];
  uint64_t v32;
  uint8_t buf[4];
  int v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  void **v38;
  __int16 v39;
  void **v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  const char *v44;

  if (a2)
    v5 = (void **)(a2 - 8);
  else
    v5 = 0;
  if (!lpsrc
  {
    v8 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_52;
    while (1)
    {
      v9 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v10 + 1), *((_QWORD *)v10 + 2));
        }
        else
        {
          v11 = *(_OWORD *)(v10 + 8);
          v32 = *((_QWORD *)v10 + 3);
          *(_OWORD *)__dst = v11;
        }
        v12 = SHIBYTE(v32);
        v13 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v14 = __dst;
        if (v12 < 0)
          v14 = v13;
        if (v30 >= 0)
          v15 = __p;
        else
          v15 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v14;
        v39 = 2081;
        v40 = v15;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v16 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v17 + 1), *((_QWORD *)v17 + 2));
        }
        else
        {
          v18 = *(_OWORD *)(v17 + 8);
          v32 = *((_QWORD *)v17 + 3);
          *(_OWORD *)__dst = v18;
        }
        v19 = SHIBYTE(v32);
        v20 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v21 = __dst;
        if (v19 < 0)
          v21 = v20;
        if (v30 >= 0)
          v22 = __p;
        else
          v22 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v21;
        v39 = 2081;
        v40 = v22;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v23 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v24 + 1), *((_QWORD *)v24 + 2));
        }
        else
        {
          v25 = *(_OWORD *)(v24 + 8);
          v32 = *((_QWORD *)v24 + 3);
          *(_OWORD *)__dst = v25;
        }
        v26 = SHIBYTE(v32);
        v8 = (uint64_t *)__dst[0];
        v5 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v27 = __dst;
        if (v26 < 0)
          v27 = (void **)v8;
        if (v30 >= 0)
          v28 = __p;
        else
          v28 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v27;
        v39 = 2081;
        v40 = v28;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
  }
  return sub_10032AA48((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_100337890(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double sub_1003378BC@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void **v5;
  char *v6;
  uint64_t *v8;
  NSObject *v9;
  char *v10;
  __int128 v11;
  int v12;
  void **v13;
  void **v14;
  void **v15;
  NSObject *v16;
  char *v17;
  __int128 v18;
  int v19;
  void **v20;
  void **v21;
  void **v22;
  NSObject *v23;
  char *v24;
  __int128 v25;
  int v26;
  void **v27;
  void **v28;
  void *__p[2];
  char v30;
  void *__dst[2];
  uint64_t v32;
  uint8_t buf[4];
  int v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  void **v38;
  __int16 v39;
  void **v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  const char *v44;

  if (a2)
    v5 = (void **)(a2 - 8);
  else
    v5 = 0;
  if (!lpsrc
  {
    v8 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_52;
    while (1)
    {
      v9 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v10 + 1), *((_QWORD *)v10 + 2));
        }
        else
        {
          v11 = *(_OWORD *)(v10 + 8);
          v32 = *((_QWORD *)v10 + 3);
          *(_OWORD *)__dst = v11;
        }
        v12 = SHIBYTE(v32);
        v13 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v14 = __dst;
        if (v12 < 0)
          v14 = v13;
        if (v30 >= 0)
          v15 = __p;
        else
          v15 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v14;
        v39 = 2081;
        v40 = v15;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v16 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v17 + 1), *((_QWORD *)v17 + 2));
        }
        else
        {
          v18 = *(_OWORD *)(v17 + 8);
          v32 = *((_QWORD *)v17 + 3);
          *(_OWORD *)__dst = v18;
        }
        v19 = SHIBYTE(v32);
        v20 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v21 = __dst;
        if (v19 < 0)
          v21 = v20;
        if (v30 >= 0)
          v22 = __p;
        else
          v22 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v21;
        v39 = 2081;
        v40 = v22;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v23 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v24 + 1), *((_QWORD *)v24 + 2));
        }
        else
        {
          v25 = *(_OWORD *)(v24 + 8);
          v32 = *((_QWORD *)v24 + 3);
          *(_OWORD *)__dst = v25;
        }
        v26 = SHIBYTE(v32);
        v8 = (uint64_t *)__dst[0];
        v5 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v27 = __dst;
        if (v26 < 0)
          v27 = (void **)v8;
        if (v30 >= 0)
          v28 = __p;
        else
          v28 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v27;
        v39 = 2081;
        v40 = v28;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
  }
  return sub_10032AE80((uint64_t)v5, v6, a3);
}

void sub_100337D20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double sub_100337D4C@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void **v5;
  void *v6;
  uint64_t *v8;
  NSObject *v9;
  char *v10;
  __int128 v11;
  int v12;
  void **v13;
  void **v14;
  void **v15;
  NSObject *v16;
  char *v17;
  __int128 v18;
  int v19;
  void **v20;
  void **v21;
  void **v22;
  NSObject *v23;
  char *v24;
  __int128 v25;
  int v26;
  void **v27;
  void **v28;
  void *__p[2];
  char v30;
  void *__dst[2];
  uint64_t v32;
  uint8_t buf[4];
  int v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  void **v38;
  __int16 v39;
  void **v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  const char *v44;

  if (a2)
    v5 = (void **)(a2 - 8);
  else
    v5 = 0;
  if (!lpsrc
  {
    v8 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_52;
    while (1)
    {
      v9 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v10 + 1), *((_QWORD *)v10 + 2));
        }
        else
        {
          v11 = *(_OWORD *)(v10 + 8);
          v32 = *((_QWORD *)v10 + 3);
          *(_OWORD *)__dst = v11;
        }
        v12 = SHIBYTE(v32);
        v13 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v14 = __dst;
        if (v12 < 0)
          v14 = v13;
        if (v30 >= 0)
          v15 = __p;
        else
          v15 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v14;
        v39 = 2081;
        v40 = v15;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v16 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v17 + 1), *((_QWORD *)v17 + 2));
        }
        else
        {
          v18 = *(_OWORD *)(v17 + 8);
          v32 = *((_QWORD *)v17 + 3);
          *(_OWORD *)__dst = v18;
        }
        v19 = SHIBYTE(v32);
        v20 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v21 = __dst;
        if (v19 < 0)
          v21 = v20;
        if (v30 >= 0)
          v22 = __p;
        else
          v22 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v21;
        v39 = 2081;
        v40 = v22;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v23 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v24 + 1), *((_QWORD *)v24 + 2));
        }
        else
        {
          v25 = *(_OWORD *)(v24 + 8);
          v32 = *((_QWORD *)v24 + 3);
          *(_OWORD *)__dst = v25;
        }
        v26 = SHIBYTE(v32);
        v8 = (uint64_t *)__dst[0];
        v5 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v27 = __dst;
        if (v26 < 0)
          v27 = (void **)v8;
        if (v30 >= 0)
          v28 = __p;
        else
          v28 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v27;
        v39 = 2081;
        v40 = v28;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
  }
  return sub_10032B328((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_1003381B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double sub_1003381DC@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void **v5;
  char *v6;
  uint64_t *v8;
  NSObject *v9;
  char *v10;
  __int128 v11;
  int v12;
  void **v13;
  void **v14;
  void **v15;
  NSObject *v16;
  char *v17;
  __int128 v18;
  int v19;
  void **v20;
  void **v21;
  void **v22;
  NSObject *v23;
  char *v24;
  __int128 v25;
  int v26;
  void **v27;
  void **v28;
  void *__p[2];
  char v30;
  void *__dst[2];
  uint64_t v32;
  uint8_t buf[4];
  int v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  void **v38;
  __int16 v39;
  void **v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  const char *v44;

  if (a2)
    v5 = (void **)(a2 - 8);
  else
    v5 = 0;
  if (!lpsrc
  {
    v8 = &qword_1022A0000;
    if (qword_1022A00F0 != -1)
      goto LABEL_52;
    while (1)
    {
      v9 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v10 + 1), *((_QWORD *)v10 + 2));
        }
        else
        {
          v11 = *(_OWORD *)(v10 + 8);
          v32 = *((_QWORD *)v10 + 3);
          *(_OWORD *)__dst = v11;
        }
        v12 = SHIBYTE(v32);
        v13 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v14 = __dst;
        if (v12 < 0)
          v14 = v13;
        if (v30 >= 0)
          v15 = __p;
        else
          v15 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v14;
        v39 = 2081;
        v40 = v15;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v16 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v17 + 1), *((_QWORD *)v17 + 2));
        }
        else
        {
          v18 = *(_OWORD *)(v17 + 8);
          v32 = *((_QWORD *)v17 + 3);
          *(_OWORD *)__dst = v18;
        }
        v19 = SHIBYTE(v32);
        v20 = (void **)__dst[0];
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v21 = __dst;
        if (v19 < 0)
          v21 = v20;
        if (v30 >= 0)
          v22 = __p;
        else
          v22 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v21;
        v39 = 2081;
        v40 = v22;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
        if (v8[30] != -1)
          dispatch_once(&qword_1022A00F0, &stru_1021302D8);
      }
      v23 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_100115CE4(__dst, *((void **)v24 + 1), *((_QWORD *)v24 + 2));
        }
        else
        {
          v25 = *(_OWORD *)(v24 + 8);
          v32 = *((_QWORD *)v24 + 3);
          *(_OWORD *)__dst = v25;
        }
        v26 = SHIBYTE(v32);
        v8 = (uint64_t *)__dst[0];
        v5 = __p;
        sub_1002E6448(lpsrc, (uint64_t)__p);
        v27 = __dst;
        if (v26 < 0)
          v27 = (void **)v8;
        if (v30 >= 0)
          v28 = __p;
        else
          v28 = (void **)__p[0];
        *(_DWORD *)buf = 68290051;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 2081;
        v38 = v27;
        v39 = 2081;
        v40 = v28;
        v41 = 2082;
        v42 = "assert";
        v43 = 2081;
        v44 = "derivedEventData != __null";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v30 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v32) < 0)
          operator delete(__dst[0]);
      }
      sub_1018F34BC();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1022A00F0, &stru_1021302D8);
    }
  }
  return sub_10032B798((uint64_t)v5, v6, a3);
}

void sub_100338640(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_10033866C(id a1)
{
  qword_1022A00F8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_100338698(uint64_t a1)
{
  *(_QWORD *)a1 = off_10212F0B8;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  operator delete();
}

void sub_1003386E8(uint64_t a1)
{
  *(_QWORD *)a1 = off_10212F0B8;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  operator delete();
}

void sub_100338738(uint64_t a1)
{
  sub_100156994(a1);
  operator delete();
}

_QWORD *sub_10033875C(_QWORD *a1)
{
  std::string *v2;

  *a1 = off_10212F0B8;
  v2 = (std::string *)sub_1015A2E04(a1 + 1, "No Name Given");
  *a1 = off_102130368;
  std::string::assign(v2, "Refresh Location on regular interval");
  return a1;
}

void sub_1003387C4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  uint64_t v3;
  uint64_t v4;

  v4 = v3;
  *(_QWORD *)v1 = v4;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

void sub_1003387E8(uint64_t a1)
{
  *(_QWORD *)a1 = off_102130388;

  *(_QWORD *)a1 = off_10212F0B8;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  operator delete();
}

void sub_100338854(uint64_t a1)
{
  *(_QWORD *)a1 = off_1021303A8;

  *(_QWORD *)a1 = off_10212F0B8;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  operator delete();
}

_QWORD *sub_1003388C0(_QWORD *a1)
{
  std::string *v2;

  *a1 = off_10212F0B8;
  v2 = (std::string *)sub_1015A2E04(a1 + 1, "No Name Given");
  *a1 = off_1021303C8;
  std::string::assign(v2, "Failed To Fetched Place Inference");
  return a1;
}

void sub_100338928(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  uint64_t v3;
  uint64_t v4;

  v4 = v3;
  *(_QWORD *)v1 = v4;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

void sub_10033894C(uint64_t a1)
{
  sub_100338970(a1);
  operator delete();
}

uint64_t sub_100338970(uint64_t a1)
{
  *(_QWORD *)a1 = off_1021303E8;

  *(_QWORD *)a1 = off_10212F0B8;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  return a1;
}

_QWORD *sub_1003389CC(_QWORD *a1)
{
  std::string *v2;

  *a1 = off_10212F0B8;
  v2 = (std::string *)sub_1015A2E04(a1 + 1, "No Name Given");
  *a1 = off_102130408;
  std::string::assign(v2, "Failed to Get LOI Event");
  return a1;
}

void sub_100338A34(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  uint64_t v3;
  uint64_t v4;

  v4 = v3;
  *(_QWORD *)v1 = v4;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

void sub_100338A58(uint64_t a1)
{
  *(_QWORD *)a1 = off_102130428;

  *(_QWORD *)a1 = off_10212F0B8;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  operator delete();
}

_QWORD *sub_100338AC4(_QWORD *a1)
{
  std::string *v2;

  *a1 = off_10212F0B8;
  v2 = (std::string *)sub_1015A2E04(a1 + 1, "No Name Given");
  *a1 = off_102130448;
  std::string::assign(v2, "Failed to Get Related LOIs");
  return a1;
}

void sub_100338B2C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  uint64_t v3;
  uint64_t v4;

  v4 = v3;
  *(_QWORD *)v1 = v4;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

void sub_100338B50(uint64_t a1)
{
  sub_100338B74(a1);
  operator delete();
}

uint64_t sub_100338B74(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = off_102130468;
  v2 = *(void **)(a1 + 32);
  if (v2)
  {
    *(_QWORD *)(a1 + 40) = v2;
    operator delete(v2);
  }
  *(_QWORD *)a1 = off_10212F0B8;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  return a1;
}

_QWORD *sub_100338BD4(_QWORD *a1)
{
  std::string *v2;

  *a1 = off_10212F0B8;
  v2 = (std::string *)sub_1015A2E04(a1 + 1, "No Name Given");
  *a1 = off_102130488;
  std::string::assign(v2, "Failed To Get Location Update");
  return a1;
}

void sub_100338C3C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  uint64_t v3;
  uint64_t v4;

  v4 = v3;
  *(_QWORD *)v1 = v4;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

_QWORD *sub_100338C60(_QWORD *a1, void *a2)
{
  std::string *v4;

  *a1 = off_10212F0B8;
  v4 = (std::string *)(a1 + 1);
  sub_1015A2E04(a1 + 1, "No Name Given");
  *a1 = off_1021304A8;
  a1[4] = a2;
  std::string::assign(v4, "Got Location Update");
  return a1;
}

void sub_100338CD8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  uint64_t v3;

  *(_QWORD *)v1 = v3;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

void sub_100338CF8(uint64_t a1)
{
  sub_100338D1C(a1);
  operator delete();
}

uint64_t sub_100338D1C(uint64_t a1)
{
  *(_QWORD *)a1 = off_1021304A8;

  *(_QWORD *)a1 = off_10212F0B8;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  return a1;
}

_QWORD *sub_100338D78(_QWORD *a1)
{
  std::string *v2;

  *a1 = off_10212F0B8;
  v2 = (std::string *)sub_1015A2E04(a1 + 1, "No Name Given");
  *a1 = off_1021304C8;
  std::string::assign(v2, "Failed To Set Geofence");
  return a1;
}

void sub_100338DE0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  uint64_t v3;
  uint64_t v4;

  v4 = v3;
  *(_QWORD *)v1 = v4;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

std::runtime_error *sub_100338E04(std::runtime_error *a1, const std::string *a2)
{
  std::runtime_error *result;

  result = std::runtime_error::runtime_error(a1, a2);
  result->__vftable = (std::runtime_error_vtbl *)&off_10212E4E8;
  return result;
}

void sub_100338E28(unsigned int a1)
{
  if (a1 < 2)
  {
    if (a1)
      sub_100339044();
    sub_100338E94();
  }
  sub_1018F45AC();
}

void sub_100338E94()
{
  operator new();
}

void sub_100338FB4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  char *v17;
  char *v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;

  v18 = a13;
  if (a13 == v17)
  {
    v19 = 4;
    v18 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v19 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v18 + 8 * v19))();
LABEL_6:
  v20 = a17;
  if (a17 == &a14)
  {
    v21 = 4;
    v20 = &a14;
  }
  else
  {
    if (!a17)
      goto LABEL_11;
    v21 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v20 + 8 * v21))();
LABEL_11:
  operator delete();
}

void sub_100339044()
{
  operator new();
}

void sub_100339164(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  char *v17;
  char *v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;

  v18 = a13;
  if (a13 == v17)
  {
    v19 = 4;
    v18 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v19 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v18 + 8 * v19))();
LABEL_6:
  v20 = a17;
  if (a17 == &a14)
  {
    v21 = 4;
    v20 = &a14;
  }
  else
  {
    if (!a17)
      goto LABEL_11;
    v21 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v20 + 8 * v21))();
LABEL_11:
  operator delete();
}

void sub_1003391F4(id a1)
{
  qword_1022A00F8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_100339220(void **a1@<X1>, void *a2@<X2>, double *a3@<X3>, _BYTE *a4@<X8>)
{
  NSObject *v8;
  void *v9;
  _BYTE v10[136];
  __int128 __p;
  void *v12;
  char v13;
  uint8_t v14[48];
  uint8_t buf[4];
  int v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  void *v20;

  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130558);
  v8 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a1 + 23) >= 0)
      v9 = a1;
    else
      v9 = *a1;
    *(_DWORD *)buf = 68289282;
    v16 = 0;
    v17 = 2082;
    v18 = "";
    v19 = 2082;
    v20 = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMicroLocationLegacyEventRecordingRequest: client request recording scan\", \"client\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
  if (*((char *)a1 + 23) < 0)
  {
    sub_100115CE4(&__p, *a1, (unint64_t)a1[1]);
  }
  else
  {
    __p = *(_OWORD *)a1;
    v12 = a1[2];
  }
  v13 = 1;
  sub_10035996C((uint64_t)&__p, a2, (uint64_t)v14);
  if (v13 && SHIBYTE(v12) < 0)
    operator delete((void *)__p);
  sub_100339450((uint64_t)v14, 0, 0, 3u, (uint64_t)v10, *a3);
  buf[0] = 1;
  sub_1002DF194(&v17);
  *a4 = buf[0];
  sub_1002DF194(a4 + 8);
  sub_1002DF2E0(&v17);
  sub_1002DF2E0(v10);
  sub_1002CAF70((wireless_diagnostics::google::protobuf::MessageLite *)v14);
}

void sub_1003393F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  _Unwind_Resume(exception_object);
}

void sub_100339430(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,char a33)
{
  if (a33)
  {
    if (a32 < 0)
      operator delete(__p);
  }
  JUMPOUT(0x100339428);
}

void sub_100339450(uint64_t a1@<X0>, char a2@<W1>, char a3@<W2>, unsigned int a4@<W3>, uint64_t a5@<X8>, double a6@<D0>)
{
  unsigned int v12;
  int v13;
  const char *v14;
  int v15;
  const char *v16;

  sub_1002BBFAC(a5);
  v12 = *(_DWORD *)(a1 + 8);
  if (!sub_1002BC6A4(v12))
  {
    v14 = "::CLMicroLocationProto::EventType_IsValid(value)";
    v15 = 19803;
    v16 = "set_eventtype";
    goto LABEL_6;
  }
  v13 = *(_DWORD *)(a5 + 128);
  *(_DWORD *)(a5 + 72) = v12;
  *(double *)(a5 + 8) = a6;
  *(_BYTE *)(a5 + 77) = a2;
  *(_DWORD *)(a5 + 128) = v13 | 0x2803;
  *(_BYTE *)(a5 + 76) = a3;
  if ((sub_1002BC674(a4) & 1) == 0)
  {
    v14 = "::CLMicroLocationProto::ConfidenceLevel_IsValid(value)";
    v15 = 20312;
    v16 = "set_confidencelevel";
LABEL_6:
    __assert_rtn(v16, "microlocation.pb.h", v15, v14);
  }
  *(_DWORD *)(a5 + 128) |= 0x4000u;
  *(_DWORD *)(a5 + 120) = a4;
  sub_100358760(a5, a1);
}

void sub_100339534(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1002DF2E0(v1);
  _Unwind_Resume(a1);
}

void sub_100339548(id a1)
{
  qword_1022A00F8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_100339574(void *a1@<X1>, double *a2@<X2>, _BYTE *a3@<X8>)
{
  if (objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("private.HomeKit.scene.actionSetUUID")))
    sub_1003395D4(a1, a2, a3);
  else
    sub_100339B6C(a1, a2, a3);
}

void sub_1003395D4(void *a1@<X1>, double *a2@<X2>, _BYTE *a3@<X8>)
{
  unsigned __int8 v6;
  unsigned __int8 v7;
  const std::string::value_type *v8;
  const std::string::value_type *v9;
  const std::string::value_type *v10;
  const std::string::value_type *v11;
  const std::string::value_type *v12;
  const std::string::value_type *v13;
  NSObject *v14;
  std::string *v15;
  std::string *v16;
  std::string *v17;
  std::string *v18;
  std::string *v19;
  std::string *v20;
  _BYTE v21[136];
  _BYTE v22[8];
  std::string *v23;
  std::string *v24;
  std::string *v25;
  std::string *v26;
  unsigned __int8 v27;
  unsigned __int8 v28;
  std::string *v29;
  std::string *v30;
  int v31;
  uint64_t buf;
  __int16 v33;
  const char *v34;
  __int16 v35;
  std::string *v36;
  __int16 v37;
  std::string *v38;
  __int16 v39;
  std::string *v40;
  __int16 v41;
  std::string *v42;
  __int16 v43;
  std::string *v44;
  __int16 v45;
  std::string *v46;
  __int16 v47;
  int v48;
  __int16 v49;
  int v50;

  sub_1002BBC44((uint64_t)v22);
  if (objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("shouldTriggerLocalizationScan")))
  {
    v6 = objc_msgSend(objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("shouldTriggerLocalizationScan")), "BOOLValue");
    v31 |= 0x100u;
    v27 = v6;
  }
  if (objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("shouldTriggerRecordingScan")))
  {
    v7 = objc_msgSend(objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("shouldTriggerRecordingScan")), "BOOLValue");
    v31 |= 0x200u;
    v28 = v7;
  }
  if (objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("private.HomeKit.scene.actionSetUUID")))
  {
    v8 = (const std::string::value_type *)objc_msgSend(objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("private.HomeKit.scene.actionSetUUID")), "UTF8String");
    v31 |= 2u;
    if (v23 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      operator new();
    std::string::assign(v23, v8);
  }
  if (objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("private.HomeKit.scene.actionSetName")))
  {
    v9 = (const std::string::value_type *)objc_msgSend(objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("private.HomeKit.scene.actionSetName")), "UTF8String");
    v31 |= 4u;
    if (v24 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      operator new();
    std::string::assign(v24, v9);
  }
  if (objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("private.HomeKit.scene.actionSetType")))
  {
    v10 = (const std::string::value_type *)objc_msgSend(objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("private.HomeKit.scene.actionSetType")), "UTF8String");
    v31 |= 8u;
    if (v25 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      operator new();
    std::string::assign(v25, v10);
  }
  if (objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("private.HomeKit.scene.clientName")))
  {
    v11 = (const std::string::value_type *)objc_msgSend(objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("private.HomeKit.scene.clientName")), "UTF8String");
    v31 |= 0x20u;
    if (v26 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      operator new();
    std::string::assign(v26, v11);
  }
  if (objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("private.HomeKit.scene.source")))
  {
    v12 = (const std::string::value_type *)objc_msgSend(objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("private.HomeKit.scene.source")), "UTF8String");
    v31 |= 0x80u;
    if (v29 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      operator new();
    std::string::assign(v29, v12);
  }
  if (objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("private.HomeKit.scene.homeName")))
  {
    v13 = (const std::string::value_type *)objc_msgSend(objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("private.HomeKit.scene.homeName")), "UTF8String");
    v31 |= 0x400u;
    if (v30 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      operator new();
    std::string::assign(v30, v13);
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130578);
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
  {
    v14 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
    {
      v15 = v23;
      if (SHIBYTE(v23->__r_.__value_.__r.__words[2]) < 0)
        v15 = (std::string *)v23->__r_.__value_.__r.__words[0];
      v16 = v24;
      if (SHIBYTE(v24->__r_.__value_.__r.__words[2]) < 0)
        v16 = (std::string *)v24->__r_.__value_.__r.__words[0];
      v17 = v25;
      if (SHIBYTE(v25->__r_.__value_.__r.__words[2]) < 0)
        v17 = (std::string *)v25->__r_.__value_.__r.__words[0];
      v18 = v26;
      if (SHIBYTE(v26->__r_.__value_.__r.__words[2]) < 0)
        v18 = (std::string *)v26->__r_.__value_.__r.__words[0];
      v19 = v29;
      if (SHIBYTE(v29->__r_.__value_.__r.__words[2]) < 0)
        v19 = (std::string *)v29->__r_.__value_.__r.__words[0];
      v20 = v30;
      if (SHIBYTE(v30->__r_.__value_.__r.__words[2]) < 0)
        v20 = (std::string *)v30->__r_.__value_.__r.__words[0];
      buf = 68291075;
      v33 = 2082;
      v34 = "";
      v35 = 2081;
      v36 = v15;
      v37 = 2081;
      v38 = v16;
      v39 = 2081;
      v40 = v17;
      v41 = 2081;
      v42 = v18;
      v43 = 2081;
      v44 = v19;
      v45 = 2081;
      v46 = v20;
      v47 = 1025;
      v48 = v27;
      v49 = 1025;
      v50 = v28;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"HomeKit Scene\", \"actionSetUUID\":%{private, location:escape_only}s, \"actionSetName\":%{private, location:escape_only}s, \"actionSetType\":%{private, location:escape_only}s, \"clientName\":%{private, location:escape_only}s, \"source\":%{private, location:escape_only}s, \"homeName\":%{private, location:escape_only}s, \"triggerLocalization\":%{private}hhd, \"triggerRecording\":%{private}hhd}", (uint8_t *)&buf, 0x5Au);
    }
  }
  sub_10033A280((uint64_t)v22, 0, 0, 3u, (uint64_t)v21, *a2);
  LOBYTE(buf) = 1;
  sub_1002DF194(&v33);
  *a3 = buf;
  sub_1002DF194(a3 + 8);
  sub_1002DF2E0(&v33);
  sub_1002DF2E0(v21);
  sub_1002CFBCC((wireless_diagnostics::google::protobuf::MessageLite *)v22);
}

void sub_100339B2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  uint64_t v26;

  sub_1002DF2E0(v26);
  sub_1002DF2E0(&a9);
  sub_1002CFBCC((wireless_diagnostics::google::protobuf::MessageLite *)&a26);
  _Unwind_Resume(a1);
}

void sub_100339B6C(void *a1@<X1>, double *a2@<X2>, _BYTE *a3@<X8>)
{
  unsigned __int8 v6;
  unsigned __int8 v7;
  const std::string::value_type *v8;
  const std::string::value_type *v9;
  const std::string::value_type *v10;
  const std::string::value_type *v11;
  const std::string::value_type *v12;
  const std::string::value_type *v13;
  const std::string::value_type *v14;
  const std::string::value_type *v15;
  NSObject *v16;
  std::string *v17;
  std::string *v18;
  std::string *v19;
  std::string *v20;
  std::string *v21;
  std::string *v22;
  std::string *v23;
  std::string *v24;
  _BYTE v25[136];
  _BYTE v26[8];
  std::string *v27;
  std::string *v28;
  std::string *v29;
  unsigned __int8 v30;
  unsigned __int8 v31;
  std::string *v32;
  std::string *v33;
  std::string *v34;
  std::string *v35;
  std::string *v36;
  int v37;
  uint8_t buf[4];
  int v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  std::string *v43;
  __int16 v44;
  std::string *v45;
  __int16 v46;
  std::string *v47;
  __int16 v48;
  std::string *v49;
  __int16 v50;
  std::string *v51;
  __int16 v52;
  std::string *v53;
  __int16 v54;
  std::string *v55;
  __int16 v56;
  std::string *v57;
  __int16 v58;
  int v59;
  __int16 v60;
  int v61;

  sub_1002BBC08((uint64_t)v26);
  if (objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("shouldTriggerLocalizationScan")))
  {
    v6 = objc_msgSend(objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("shouldTriggerLocalizationScan")), "BOOLValue");
    v37 |= 0x400u;
    v30 = v6;
  }
  if (objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("shouldTriggerRecordingScan")))
  {
    v7 = objc_msgSend(objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("shouldTriggerRecordingScan")), "BOOLValue");
    v37 |= 0x800u;
    v31 = v7;
  }
  if (objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("private.HomeKit.accessory.accessoryUUID")))
  {
    v8 = (const std::string::value_type *)objc_msgSend(objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("private.HomeKit.accessory.accessoryUUID")), "UTF8String");
    v37 |= 2u;
    if (v27 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      operator new();
    std::string::assign(v27, v8);
  }
  if (objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("private.HomeKit.accessory.serviceType")))
  {
    v9 = (const std::string::value_type *)objc_msgSend(objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("private.HomeKit.accessory.serviceType")), "UTF8String");
    v37 |= 0x10u;
    if (v28 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      operator new();
    std::string::assign(v28, v9);
  }
  if (objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("private.HomeKit.accessory.characteristicType")))
  {
    v10 = (const std::string::value_type *)objc_msgSend(objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("private.HomeKit.accessory.characteristicType")), "UTF8String");
    v37 |= 0x20u;
    if (v29 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      operator new();
    std::string::assign(v29, v10);
  }
  if (objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("private.HomeKit.accessory.source")))
  {
    v11 = (const std::string::value_type *)objc_msgSend(objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("private.HomeKit.accessory.source")), "UTF8String");
    v37 |= 0x100u;
    if (v32 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      operator new();
    std::string::assign(v32, v11);
  }
  if (objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("private.HomeKit.accessory.stateString")))
  {
    v12 = (const std::string::value_type *)objc_msgSend(objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("private.HomeKit.accessory.stateString")), "UTF8String");
    v37 |= 0x1000u;
    if (v34 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      operator new();
    std::string::assign(v34, v12);
  }
  if (objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("private.HomeKit.accessory.serviceUUID")))
  {
    v13 = (const std::string::value_type *)objc_msgSend(objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("private.HomeKit.accessory.serviceUUID")), "UTF8String");
    v37 |= 0x200u;
    if (v33 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      operator new();
    std::string::assign(v33, v13);
  }
  if (objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("private.HomeKit.accessory.serviceGroupUUID")))
  {
    v14 = (const std::string::value_type *)objc_msgSend(objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("private.HomeKit.accessory.serviceGroupUUID")), "UTF8String");
    v37 |= 0x2000u;
    if (v35 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      operator new();
    std::string::assign(v35, v14);
  }
  if (objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("private.HomeKit.accessory.roomUUID")))
  {
    v15 = (const std::string::value_type *)objc_msgSend(objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("private.HomeKit.accessory.roomUUID")), "UTF8String");
    v37 |= 0x4000u;
    if (v36 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      operator new();
    std::string::assign(v36, v15);
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130578);
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
  {
    v16 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
    {
      v17 = v27;
      if (SHIBYTE(v27->__r_.__value_.__r.__words[2]) < 0)
        v17 = (std::string *)v27->__r_.__value_.__r.__words[0];
      v18 = v34;
      if (SHIBYTE(v34->__r_.__value_.__r.__words[2]) < 0)
        v18 = (std::string *)v34->__r_.__value_.__r.__words[0];
      v19 = v33;
      if (SHIBYTE(v33->__r_.__value_.__r.__words[2]) < 0)
        v19 = (std::string *)v33->__r_.__value_.__r.__words[0];
      v20 = v35;
      if (SHIBYTE(v35->__r_.__value_.__r.__words[2]) < 0)
        v20 = (std::string *)v35->__r_.__value_.__r.__words[0];
      v21 = v28;
      if (SHIBYTE(v28->__r_.__value_.__r.__words[2]) < 0)
        v21 = (std::string *)v28->__r_.__value_.__r.__words[0];
      v22 = v29;
      if (SHIBYTE(v29->__r_.__value_.__r.__words[2]) < 0)
        v22 = (std::string *)v29->__r_.__value_.__r.__words[0];
      v23 = v32;
      if (SHIBYTE(v32->__r_.__value_.__r.__words[2]) < 0)
        v23 = (std::string *)v32->__r_.__value_.__r.__words[0];
      v24 = v36;
      if (SHIBYTE(v36->__r_.__value_.__r.__words[2]) < 0)
        v24 = (std::string *)v36->__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68291587;
      v40 = 2082;
      v39 = 0;
      v41 = "";
      v42 = 2081;
      v43 = v17;
      v44 = 2081;
      v45 = v18;
      v46 = 2081;
      v47 = v19;
      v48 = 2081;
      v49 = v20;
      v50 = 2081;
      v51 = v21;
      v52 = 2081;
      v53 = v22;
      v54 = 2081;
      v55 = v23;
      v56 = 2081;
      v57 = v24;
      v58 = 1025;
      v59 = v30;
      v60 = 1025;
      v61 = v31;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"HomeKit Accessory\", \"accessoryUUID\":%{private, location:escape_only}s, \"accessoryState\":%{private, location:escape_only}s, \"serviceUUID\":%{private, location:escape_only}s, \"serviceGroupUUID\":%{private, location:escape_only}s, \"serviceType\":%{private, location:escape_only}s, \"characteristicType\":%{private, location:escape_only}s, \"source\":%{private, location:escape_only}s, \"roomUUID\":%{private, location:escape_only}s, \"triggerLocalization\":%{private}hhd, \"triggerRecording\":%{private}hhd}", buf, 0x6Eu);
    }
  }
  sub_10033A378((uint64_t)v26, 0, 0, 3u, (uint64_t)v25, *a2);
  buf[0] = 1;
  sub_1002DF194(&v40);
  *a3 = buf[0];
  sub_1002DF194(a3 + 8);
  sub_1002DF2E0(&v40);
  sub_1002DF2E0(v25);
  sub_1002CE284((wireless_diagnostics::google::protobuf::MessageLite *)v26);
}

void sub_10033A1DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  uint64_t v26;

  sub_1002DF2E0(v26);
  sub_1002DF2E0(&a9);
  sub_1002CE284((wireless_diagnostics::google::protobuf::MessageLite *)&a26);
  _Unwind_Resume(a1);
}

BOOL sub_10033A21C(uint64_t a1, void *a2)
{
  if (!a2)
    return 0;
  if (objc_msgSend(a2, "objectForKeyedSubscript:", CFSTR("private.HomeKit.accessory.accessoryUUID")))
    return 1;
  return objc_msgSend(a2, "objectForKeyedSubscript:", CFSTR("private.HomeKit.scene.actionSetUUID")) != 0;
}

void sub_10033A280(uint64_t a1@<X0>, char a2@<W1>, char a3@<W2>, unsigned int a4@<W3>, uint64_t a5@<X8>, double a6@<D0>)
{
  unsigned int v12;
  int v13;
  const char *v14;
  int v15;
  const char *v16;

  sub_1002BBFAC(a5);
  v12 = *(_DWORD *)(a1 + 48);
  if (!sub_1002BC6A4(v12))
  {
    v14 = "::CLMicroLocationProto::EventType_IsValid(value)";
    v15 = 19803;
    v16 = "set_eventtype";
    goto LABEL_6;
  }
  v13 = *(_DWORD *)(a5 + 128);
  *(_DWORD *)(a5 + 72) = v12;
  *(double *)(a5 + 8) = a6;
  *(_BYTE *)(a5 + 77) = a2;
  *(_DWORD *)(a5 + 128) = v13 | 0x2803;
  *(_BYTE *)(a5 + 76) = a3;
  if ((sub_1002BC674(a4) & 1) == 0)
  {
    v14 = "::CLMicroLocationProto::ConfidenceLevel_IsValid(value)";
    v15 = 20312;
    v16 = "set_confidencelevel";
LABEL_6:
    __assert_rtn(v16, "microlocation.pb.h", v15, v14);
  }
  *(_DWORD *)(a5 + 128) |= 0x4000u;
  *(_DWORD *)(a5 + 120) = a4;
  sub_100358418(a5, a1);
}

void sub_10033A364(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1002DF2E0(v1);
  _Unwind_Resume(a1);
}

void sub_10033A378(uint64_t a1@<X0>, char a2@<W1>, char a3@<W2>, unsigned int a4@<W3>, uint64_t a5@<X8>, double a6@<D0>)
{
  unsigned int v12;
  int v13;
  const char *v14;
  int v15;
  const char *v16;

  sub_1002BBFAC(a5);
  v12 = *(_DWORD *)(a1 + 64);
  if (!sub_1002BC6A4(v12))
  {
    v14 = "::CLMicroLocationProto::EventType_IsValid(value)";
    v15 = 19803;
    v16 = "set_eventtype";
    goto LABEL_6;
  }
  v13 = *(_DWORD *)(a5 + 128);
  *(_DWORD *)(a5 + 72) = v12;
  *(double *)(a5 + 8) = a6;
  *(_BYTE *)(a5 + 77) = a2;
  *(_DWORD *)(a5 + 128) = v13 | 0x2803;
  *(_BYTE *)(a5 + 76) = a3;
  if ((sub_1002BC674(a4) & 1) == 0)
  {
    v14 = "::CLMicroLocationProto::ConfidenceLevel_IsValid(value)";
    v15 = 20312;
    v16 = "set_confidencelevel";
LABEL_6:
    __assert_rtn(v16, "microlocation.pb.h", v15, v14);
  }
  *(_DWORD *)(a5 + 128) |= 0x4000u;
  *(_DWORD *)(a5 + 120) = a4;
  sub_10035838C(a5, a1);
}

void sub_10033A45C(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1002DF2E0(v1);
  _Unwind_Resume(a1);
}

void sub_10033A470(id a1)
{
  qword_1022A00F8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

double sub_10033A49C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_QWORD *)a1 = off_1021305A8;
  *(_WORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = a1 + 40;
  *(_QWORD *)(a1 + 48) = a1 + 40;
  result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_QWORD *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 96) = 1065353216;
  *(_QWORD *)(a1 + 104) = a3;
  *(_BYTE *)(a1 + 112) = 0;
  *(_BYTE *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 144) = a2;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_DWORD *)(a1 + 184) = 1065353216;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  return result;
}

void sub_10033A4FC(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void **a4@<X8>)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t *v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  _OWORD *v13;
  void *p_p;
  uint64_t *v15;
  uint64_t *v16;
  _QWORD *v17;
  void **v18;
  void *__p;
  __int128 v20;
  uint64_t *v21;
  uint64_t *v22;
  void **v23;
  uint8_t buf[8];
  __int16 v25;
  const char *v26;
  __int16 v27;
  uint64_t v28;
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  void *v32;

  sub_100284834(*(_QWORD *)(a1 + 104), a2, a3, &v21);
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130670);
  v6 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a2 + 23) >= 0)
      v7 = a2;
    else
      v7 = *(_QWORD *)a2;
    *(_DWORD *)buf = 68289538;
    *(_DWORD *)&buf[4] = 0;
    v25 = 2082;
    v26 = "";
    v27 = 2082;
    v28 = v7;
    v29 = 2050;
    v30 = 0x2E8BA2E8BA2E8BA3 * (v22 - v21);
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager Client queried services\", \"ClientId\":%{public, location:escape_only}s, \"NumServicesFound\":%{public}llu}", buf, 0x26u);
  }
  v9 = v21;
  v8 = v22;
  if (v21 != v22)
  {
    v18 = a4;
    do
    {
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130670);
      v10 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a2 + 23) >= 0)
          v11 = a2;
        else
          v11 = *(_QWORD *)a2;
        v12 = *v9;
        v13 = operator new(0x28uLL);
        __p = v13;
        v20 = xmmword_101B97FF0;
        *v13 = 0u;
        v13[1] = 0u;
        *(_QWORD *)((char *)v13 + 29) = 0;
        sub_100261F9C((uint64_t)(v9 + 1), v13);
        p_p = &__p;
        if (v20 < 0)
          p_p = __p;
        *(_DWORD *)buf = 68289794;
        *(_DWORD *)&buf[4] = 0;
        v25 = 2082;
        v26 = "";
        v27 = 2082;
        v28 = v11;
        v29 = 2050;
        v30 = v12;
        v31 = 2082;
        v32 = p_p;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager Client query result\", \"ClientId\":%{public, location:escape_only}s, \"ServiceType\":%{public}llu, \"ServiceUuid\":%{public, location:escape_only}s}", buf, 0x30u);
        if (SHIBYTE(v20) < 0)
          operator delete(__p);
      }
      v9 += 11;
    }
    while (v9 != v8);
    v15 = v21;
    v16 = v22;
    v23 = v18;
    while (v15 != v16)
    {
      v17 = v15 + 1;
      sub_100346E0C((__n128 *)buf, (__n128 *)(v15 + 1), *v15, *((unsigned int *)v15 + 14));
      sub_100341284(&v23, buf);
      v15 = v17 + 10;
    }
  }
  *(_QWORD *)buf = &v21;
  sub_100302A1C((void ***)buf);
}

void sub_10033A7D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  _Unwind_Resume(exception_object);
}

void sub_10033A828(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  unint64_t v12;
  uint64_t *v13;
  uint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  double Current;
  NSObject *v25;
  uint64_t v26;
  char *v27;
  __int128 v28;
  uint64_t v29;
  NSObject *v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  char *v34;
  unint64_t v35;
  uint64_t *v36;
  uint64_t *v37;
  char **v38;
  char v39;
  _BYTE buf[40];
  unint64_t v41;
  __int16 v42;
  char *v43;
  void *__p;
  char v45;
  __n128 v46;

  if (sub_1000A1914(*(_QWORD *)(a1 + 104)))
  {
    sub_100284834(*(_QWORD *)(a1 + 104), a2, a5, &v36);
    v12 = sub_10034E720(a4);
    v35 = v12;
    v13 = v36;
    v14 = v37;
    if (v36 == v37)
    {
      v15 = 0;
    }
    else
    {
      v15 = 0;
      do
      {
        *(_QWORD *)buf = sub_100346FF8(v13[7]);
        v12 = sub_100341378(&v35, 0, (uint64_t)&v35, 0x20u, buf);
        v16 = *v13;
        v13 += 11;
        if (v16 == a3)
          v17 = v12;
        else
          v17 = 0;
        v15 += v17;
      }
      while (v13 != v14);
    }
    if (sub_10033AD68(v12, a3, v15))
    {
      *(_DWORD *)buf = 0;
      sub_1000B0C3C((int *)buf);
      v20 = sub_1000B0D38((ssize_t)buf);
      v22 = v21;
      v46.n128_u64[0] = v20;
      v46.n128_u64[1] = v21;
      sub_1000B0D18((unsigned int *)buf);
      v23 = *(_QWORD *)(a1 + 104);
      Current = j__CFAbsoluteTimeGetCurrent();
      sub_10034FB50((uint64_t)buf, v20, v22, a3, (__int128 *)a2, v35, (__int128 *)a5, Current);
      v32 = 0;
      v33 = 0;
      v34 = 0;
      v38 = &v32;
      v39 = 0;
      v32 = (char *)operator new(0x58uLL);
      v33 = (uint64_t)v32;
      v34 = v32 + 88;
      v33 = sub_100341444((uint64_t)&v34, (uint64_t)buf, (uint64_t)&v46, (uint64_t)v32);
      sub_10033B268(v23);
      v38 = &v32;
      sub_100302A1C((void ***)&v38);
      if (v45 < 0)
        operator delete(__p);
      if (SBYTE5(v43) < 0)
        operator delete(*(void **)&buf[32]);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130670);
      v25 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a2 + 23) >= 0)
          v26 = a2;
        else
          v26 = *(_QWORD *)a2;
        if (*(char *)(a5 + 23) < 0)
          a5 = *(_QWORD *)a5;
        v27 = (char *)operator new(0x28uLL);
        *(_QWORD *)(v27 + 29) = 0;
        *(_OWORD *)v27 = 0u;
        *((_OWORD *)v27 + 1) = 0u;
        sub_100261F9C((uint64_t)&v46, v27);
        *(_DWORD *)buf = 68290050;
        *(_DWORD *)&buf[4] = 0;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2082;
        *(_QWORD *)&buf[20] = v26;
        *(_WORD *)&buf[28] = 2082;
        *(_QWORD *)&buf[30] = a5;
        *(_WORD *)&buf[38] = 2050;
        v41 = a3;
        v42 = 2082;
        v43 = v27;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager new service created for client\", \"ClientId\":%{public, location:escape_only}s, \"UserId\":%{public, location:escape_only}s, \"ServiceType\":%{public}llu, \"ServiceUuid\":%{public, location:escape_only}s}", buf, 0x3Au);
        operator delete(v27);
      }
      sub_100346E0C((__n128 *)buf, &v46, a3, v35);
      v28 = *(_OWORD *)&buf[16];
      *(_OWORD *)a6 = *(_OWORD *)buf;
      *(_OWORD *)(a6 + 16) = v28;
      *(_BYTE *)(a6 + 32) = 1;
      v29 = -1;
    }
    else
    {
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130670);
      v30 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a2 + 23) >= 0)
          v31 = a2;
        else
          v31 = *(_QWORD *)a2;
        *(_DWORD *)buf = 68289794;
        *(_DWORD *)&buf[4] = 0;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2082;
        *(_QWORD *)&buf[20] = v31;
        *(_WORD *)&buf[28] = 2050;
        *(_QWORD *)&buf[30] = a3;
        *(_WORD *)&buf[38] = 2050;
        v41 = v15;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager Client tried to create service, failed since not allowed\", \"ClientId\":%{public, location:escape_only}s, \"ServiceType\":%{public}llu, \"NumIdenticalServices\":%{public}llu}", buf, 0x30u);
      }
      *(_BYTE *)a6 = 0;
      *(_BYTE *)(a6 + 32) = 0;
      v29 = 21;
    }
    *(_QWORD *)(a6 + 40) = v29;
    *(_QWORD *)buf = &v36;
    sub_100302A1C((void ***)buf);
  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130670);
    v18 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0)
        v19 = a2;
      else
        v19 = *(_QWORD *)a2;
      *(_DWORD *)buf = 68289538;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2082;
      *(_QWORD *)&buf[20] = v19;
      *(_WORD *)&buf[28] = 2050;
      *(_QWORD *)&buf[30] = a3;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager cannot create service since database is not available\", \"ClientId\":%{public, location:escape_only}s, \"ServiceType\":%{public}llu}", buf, 0x26u);
    }
    *(_BYTE *)a6 = 0;
    *(_BYTE *)(a6 + 32) = 0;
    *(_QWORD *)(a6 + 40) = 22;
  }
}

void sub_10033ACCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char *a19)
{
  void *v19;

  operator delete(v19);
  a19 = &a14;
  sub_100302A1C((void ***)&a19);
  _Unwind_Resume(a1);
}

BOOL sub_10033AD68(uint64_t a1, uint64_t a2, unint64_t a3)
{
  CFStringRef v5;
  int v6;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  CFStringRef v11;
  unint64_t *v12;
  CFStringRef v13;
  unint64_t *v14;
  CFStringRef v15;
  int v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  _BOOL8 v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v23;
  unsigned int v25;
  uint8_t buf[8];
  _BYTE v27[10];
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  unint64_t v31;
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  _BOOL4 v35;

  switch(a2)
  {
    case 1:
      sub_1001E4804(buf);
      v25 = 0;
      v5 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsMaximumNumberOfCreatedUnsupervisedServicesPerClient", 0x8000100u, kCFAllocatorNull);
      v6 = sub_1000B1180(*(uint64_t *)buf, (uint64_t)v5, &v25);
      CFRelease(v5);
      v7 = v25;
      v8 = *(std::__shared_weak_count **)v27;
      if (!*(_QWORD *)v27)
        goto LABEL_15;
      v9 = (unint64_t *)(*(_QWORD *)v27 + 8);
      do
        v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      break;
    case 2:
      sub_1001E4804(buf);
      v25 = 0;
      v11 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsMaximumNumberOfCreatedBinaryRoiServicesPerClient", 0x8000100u, kCFAllocatorNull);
      v6 = sub_1000B1180(*(uint64_t *)buf, (uint64_t)v11, &v25);
      CFRelease(v11);
      v7 = v25;
      v8 = *(std::__shared_weak_count **)v27;
      if (!*(_QWORD *)v27)
        goto LABEL_15;
      v12 = (unint64_t *)(*(_QWORD *)v27 + 8);
      do
        v10 = __ldaxr(v12);
      while (__stlxr(v10 - 1, v12));
      break;
    case 3:
      sub_1001E4804(buf);
      v25 = 0;
      v13 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsMaximumNumberOfCreatedMulticlassServicesPerClient", 0x8000100u, kCFAllocatorNull);
      v6 = sub_1000B1180(*(uint64_t *)buf, (uint64_t)v13, &v25);
      CFRelease(v13);
      v7 = v25;
      v8 = *(std::__shared_weak_count **)v27;
      if (!*(_QWORD *)v27)
        goto LABEL_15;
      v14 = (unint64_t *)(*(_QWORD *)v27 + 8);
      do
        v10 = __ldaxr(v14);
      while (__stlxr(v10 - 1, v14));
      break;
    case 4:
      sub_1001E4804(buf);
      v25 = 0;
      v15 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsMaximumNumberOfCreatedSimilarityListServicesPerClient", 0x8000100u, kCFAllocatorNull);
      v16 = sub_1000B1180(*(uint64_t *)buf, (uint64_t)v15, &v25);
      CFRelease(v15);
      v7 = v25;
      v17 = *(std::__shared_weak_count **)v27;
      if (*(_QWORD *)v27)
      {
        v18 = (unint64_t *)(*(_QWORD *)v27 + 8);
        do
          v19 = __ldaxr(v18);
        while (__stlxr(v19 - 1, v18));
        if (!v19)
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
      }
      if (!v16)
        v7 = 50;
      goto LABEL_25;
    default:
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130670);
      v22 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 68289282;
        *(_DWORD *)&buf[4] = 0;
        *(_WORD *)v27 = 2082;
        *(_QWORD *)&v27[2] = "";
        v28 = 2050;
        v29 = a2;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"unhandled serviceType\", \"ServiceType\":%{public}lu}", buf, 0x1Cu);
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_102130670);
      }
      v23 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        *(_DWORD *)buf = 68289282;
        *(_DWORD *)&buf[4] = 0;
        *(_WORD *)v27 = 2082;
        *(_QWORD *)&v27[2] = "";
        v28 = 2050;
        v29 = a2;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v23, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "unhandled serviceType", "{\"msg%{public}.0s\":\"unhandled serviceType\", \"ServiceType\":%{public}lu}", buf, 0x1Cu);
      }
      return 0;
  }
  if (!v10)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
LABEL_15:
  if (!v6)
    v7 = 1;
LABEL_25:
  v20 = v7 > a3;
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130670);
  v21 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68290050;
    *(_WORD *)v27 = 2082;
    *(_DWORD *)&buf[4] = 0;
    *(_QWORD *)&v27[2] = "";
    v28 = 2050;
    v29 = a2;
    v30 = 2050;
    v31 = v7;
    v32 = 2050;
    v33 = a3;
    v34 = 1026;
    v35 = v7 > a3;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager::isNewServiceAllowed\", \"ServiceType\":%{public}lu, \"Allowed\":%{public}lu, \"AlreadyCreated\":%{public}lu, \"Verdict\":%{public}hhd}", buf, 0x36u);
  }
  return v20;
}

void sub_10033B220(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  sub_100261F44((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10033B268(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v5;
  const char *v6;
  uint8_t *v7;
  _WORD v8[8];
  uint8_t buf[1640];

  if (sub_1000CC4F4(a1 + 72))
  {
    v2 = *(_QWORD *)(a1 + 264);
    if (!v2)
      operator new();
    v3 = sub_10035045C(v2);
    sub_100341620(a1);
    return v3;
  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130670);
    v5 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#Warning Can't insert because the database is invalid", buf, 2u);
    }
    if (sub_1001BFF7C(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130670);
      v8[0] = 0;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#Warning Can't insert because the database is invalid", v8, 2);
      v7 = (uint8_t *)v6;
      sub_100512490("Generic", 1, 0, 2, "BOOL CLMicroLocationDatabase::insertOrReplace(const std::vector<TableEntry> &) [TableEntry = CLMiLoServiceTable::Entry]", "%s\n", v6);
      if (v7 != buf)
        free(v7);
    }
    return 0;
  }
}

void sub_10033B498()
{
  operator delete();
}

uint64_t sub_10033B4C4(uint64_t a1)
{
  if (*(char *)(a1 + 87) < 0)
    operator delete(*(void **)(a1 + 64));
  if (*(char *)(a1 + 55) < 0)
    operator delete(*(void **)(a1 + 32));
  return a1;
}

unint64_t sub_10033B504@<X0>(uint64_t a1@<X0>, unsigned __int8 *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unsigned __int8 *a5@<X4>, __n128 *a6@<X8>)
{
  unint64_t result;
  char v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int8 *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned __int8 *v22;
  __n128 v23;
  __n128 v24[2];
  unint64_t v25[4];
  _QWORD v26[2];
  unsigned __int8 v27;
  unsigned int v28;
  _QWORD v29[2];
  unsigned __int8 v30;
  char v31;
  __n128 v32;

  v32.n128_u64[0] = a3;
  v32.n128_u64[1] = a4;
  result = sub_10033B764(a1, a3, a4);
  if (v13)
  {
    a6->n128_u8[0] = 0;
    a6[2].n128_u8[0] = 0;
    a6[2].n128_u64[1] = 23;
    return result;
  }
  sub_100284E80(*(_QWORD *)(a1 + 104), a3, a4, v25);
  if (v31)
  {
    v14 = a2[23];
    if ((v14 & 0x80u) == 0)
      v15 = a2[23];
    else
      v15 = *((_QWORD *)a2 + 1);
    v16 = v27;
    if ((v27 & 0x80u) != 0)
      v16 = v26[1];
    if (v15 != v16)
      goto LABEL_35;
    if ((v27 & 0x80u) == 0)
      v17 = (unsigned __int8 *)v26;
    else
      v17 = (unsigned __int8 *)v26[0];
    if ((v14 & 0x80) != 0)
    {
      if (memcmp(*(const void **)a2, v17, *((_QWORD *)a2 + 1)))
        goto LABEL_35;
    }
    else if (a2[23])
    {
      while (*a2 == *v17)
      {
        ++a2;
        ++v17;
        if (!--v14)
          goto LABEL_20;
      }
      goto LABEL_35;
    }
LABEL_20:
    v19 = a5[23];
    if ((v19 & 0x80u) == 0)
      v20 = a5[23];
    else
      v20 = *((_QWORD *)a5 + 1);
    v21 = v30;
    if ((v30 & 0x80u) != 0)
      v21 = v29[1];
    if (v20 == v21)
    {
      if ((v30 & 0x80u) == 0)
        v22 = (unsigned __int8 *)v29;
      else
        v22 = (unsigned __int8 *)v29[0];
      if ((v19 & 0x80) == 0)
      {
        if (a5[23])
        {
          while (*a5 == *v22)
          {
            ++a5;
            ++v22;
            if (!--v19)
              goto LABEL_37;
          }
          goto LABEL_35;
        }
LABEL_37:
        if (sub_100285194(*(_QWORD *)(a1 + 104), a3, a4))
        {
          if (!v31)
            sub_10028DF3C();
          sub_100346E0C(v24, &v32, v25[0], v28);
          v23 = v24[1];
          *a6 = v24[0];
          a6[1] = v23;
          a6[2].n128_u8[0] = 1;
          v18 = -1;
        }
        else
        {
          a6->n128_u8[0] = 0;
          a6[2].n128_u8[0] = 0;
          v18 = 26;
        }
        goto LABEL_36;
      }
      if (!memcmp(*(const void **)a5, v22, *((_QWORD *)a5 + 1)))
        goto LABEL_37;
    }
LABEL_35:
    a6->n128_u8[0] = 0;
    a6[2].n128_u8[0] = 0;
    v18 = 25;
    goto LABEL_36;
  }
  a6->n128_u8[0] = 0;
  a6[2].n128_u8[0] = 0;
  v18 = 24;
LABEL_36:
  a6[2].n128_u64[1] = v18;
  return sub_1003407A4((uint64_t)v25);
}

void sub_10033B744(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  sub_1003407A4((uint64_t)va);
  _Unwind_Resume(a1);
}

unint64_t sub_10033B764(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned __int8 v6;
  uint64_t v7;
  uint64_t v8;

  v4 = a1 + 40;
  v5 = *(_QWORD *)(a1 + 48);
  if (v5 == a1 + 40)
    return 0;
  v6 = 0;
  do
  {
    v7 = sub_100347144(v5 + 16);
    if (v7 == a2 && v8 == a3)
    {
      v6 = v5 + 16;
      v3 = (unint64_t)(v5 + 16) >> 8;
    }
    v5 = *(_QWORD *)(v5 + 8);
  }
  while (v5 != v4);
  return v6 | (v3 << 8);
}

uint64_t sub_10033B834(uint64_t *a1, size_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, const void **a7)
{
  NSObject *v10;
  size_t *v11;
  _OWORD *v12;
  void **v13;
  void **v14;
  _OWORD *v15;
  void *p_p;
  size_t v17;
  void *v18;
  const void *v19;
  char v20;
  NSObject *v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  size_t v25;
  int v26;
  uint64_t v27;
  unsigned __int8 **v28;
  size_t *v29;
  NSObject *v30;
  char *v31;
  NSObject *v32;
  char *v33;
  uint64_t v34;
  size_t v35;
  unsigned __int8 **v36;
  void **v37;
  NSObject *v38;
  void **v39;
  void **v40;
  void *v41;
  uint64_t v42;
  const void *v43;
  const void *v44;
  unsigned __int8 *v45;
  const void **v46;
  NSObject *v47;
  char *v48;
  void **v49;
  void *v50;
  _QWORD *v51;
  uint64_t *v53;
  uint64_t v54;
  unsigned __int8 *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unsigned __int8 **v59;
  void **v60;
  unint64_t v61;
  void *v62;
  NSObject *v63;
  int v64;
  size_t *v65;
  size_t *v66;
  void **v67;
  NSObject *v68;
  int v69;
  size_t *v70;
  size_t *v71;
  void **v72;
  _QWORD *v73;
  char v74;
  CLOSTransaction *v75;
  NSObject *v76;
  size_t *v77;
  int v78;
  void **v79;
  void **v80;
  void **v81;
  NSObject *v82;
  int v83;
  void **v84;
  void **v85;
  void **v86;
  void *v87[2];
  char v88;
  void *v89[2];
  char v90;
  void *__p;
  size_t __n[2];
  uint8_t buf[4];
  int v94;
  __int16 v95;
  const char *v96;
  __int16 v97;
  size_t *v98;
  __int16 v99;
  void **v100;
  __int16 v101;
  void **v102;
  __int16 v103;
  void *v104;
  __int16 v105;
  _QWORD *v106;
  void **v107;
  __int128 v108;
  unsigned __int8 *v109;
  uint64_t v110;
  unsigned __int8 v111;
  _QWORD v112[2];
  unsigned __int8 v113;
  char v114;
  __int128 v115;
  __int128 v116;

  *(_QWORD *)&v116 = a3;
  *((_QWORD *)&v116 + 1) = a4;
  *(_QWORD *)&v115 = a5;
  *((_QWORD *)&v115 + 1) = a6;
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130670);
  v10 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0)
      v11 = a2;
    else
      v11 = (size_t *)*a2;
    v12 = operator new(0x28uLL);
    v107 = (void **)v12;
    v108 = xmmword_101B97FF0;
    *v12 = 0u;
    v12[1] = 0u;
    *(_QWORD *)((char *)v12 + 29) = 0;
    sub_100261F9C((uint64_t)&v116, v12);
    if (v108 >= 0)
      v13 = (void **)&v107;
    else
      v13 = v107;
    if (*((char *)a7 + 23) >= 0)
      v14 = (void **)a7;
    else
      v14 = (void **)*a7;
    v15 = operator new(0x28uLL);
    __p = v15;
    *(_OWORD *)__n = xmmword_101B97FF0;
    *v15 = 0u;
    v15[1] = 0u;
    *(_QWORD *)((char *)v15 + 29) = 0;
    sub_100261F9C((uint64_t)&v115, v15);
    p_p = &__p;
    if ((__n[1] & 0x8000000000000000) != 0)
      p_p = __p;
    *(_DWORD *)buf = 68290050;
    v94 = 0;
    v95 = 2082;
    v96 = "";
    v97 = 2082;
    v98 = v11;
    v99 = 2082;
    v100 = v13;
    v101 = 2082;
    v102 = v14;
    v103 = 2082;
    v104 = p_p;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager connection parameters: \", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s, \"UserID\":%{public, location:escape_only}s, \"connectionToken\":%{public, location:escape_only}s}", buf, 0x3Au);
    if (SHIBYTE(__n[1]) < 0)
      operator delete(__p);
    if (SHIBYTE(v108) < 0)
      operator delete(v107);
  }
  if (*((char *)a7 + 23) >= 0)
    v17 = *((unsigned __int8 *)a7 + 23);
  else
    v17 = (size_t)a7[1];
  v18 = &__p;
  sub_100259584((uint64_t)&__p, v17 + 20);
  if ((__n[1] & 0x8000000000000000) != 0)
    v18 = __p;
  if (v17)
  {
    if (*((char *)a7 + 23) >= 0)
      v19 = a7;
    else
      v19 = *a7;
    memmove(v18, v19, v17);
  }
  strcpy((char *)v18 + v17, ":com.apple.locationd");
  sub_10033B764((uint64_t)a1, v116, *((uint64_t *)&v116 + 1));
  if (v20)
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130670);
    v21 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a2 + 23) < 0)
        a2 = (size_t *)*a2;
      v22 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v22 + 29) = 0;
      *(_OWORD *)v22 = 0u;
      *((_OWORD *)v22 + 1) = 0u;
      sub_100261F9C((uint64_t)&v116, v22);
      *(_DWORD *)buf = 68289538;
      v94 = 0;
      v95 = 2082;
      v96 = "";
      v97 = 2082;
      v98 = a2;
      v99 = 2082;
      v100 = (void **)v22;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager cannot connect to service since service already has active connection\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s}", buf, 0x26u);
      operator delete(v22);
    }
    v23 = 18;
    goto LABEL_132;
  }
  if (sub_1000A1914(a1[13]))
  {
    sub_100284E80(a1[13], v116, *((uint64_t *)&v116 + 1), &v107);
    if (!v114)
    {
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130670);
      v32 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)a2 + 23) < 0)
          a2 = (size_t *)*a2;
        v33 = (char *)operator new(0x28uLL);
        *(_QWORD *)(v33 + 29) = 0;
        *(_OWORD *)v33 = 0u;
        *((_OWORD *)v33 + 1) = 0u;
        sub_100261F9C((uint64_t)&v116, v33);
        *(_DWORD *)buf = 68289538;
        v94 = 0;
        v95 = 2082;
        v96 = "";
        v97 = 2082;
        v98 = a2;
        v99 = 2082;
        v100 = (void **)v33;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager cannot connect to service since service not found in database\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s}", buf, 0x26u);
        operator delete(v33);
      }
      v23 = 19;
      goto LABEL_131;
    }
    v24 = *((unsigned __int8 *)a2 + 23);
    if ((v24 & 0x80u) == 0)
      v25 = *((unsigned __int8 *)a2 + 23);
    else
      v25 = a2[1];
    v26 = (char)v111;
    if ((v111 & 0x80u) == 0)
      v27 = v111;
    else
      v27 = v110;
    if (v25 == v27)
    {
      if ((v111 & 0x80u) == 0)
        v28 = &v109;
      else
        v28 = (unsigned __int8 **)v109;
      if ((v24 & 0x80) != 0)
      {
        if (!memcmp((const void *)*a2, v28, a2[1]))
          goto LABEL_97;
      }
      else
      {
        if (!*((_BYTE *)a2 + 23))
          goto LABEL_97;
        v29 = a2;
        while (*(unsigned __int8 *)v29 == *(unsigned __int8 *)v28)
        {
          v29 = (size_t *)((char *)v29 + 1);
          v28 = (unsigned __int8 **)((char *)v28 + 1);
          if (!--v24)
            goto LABEL_97;
        }
      }
    }
    v34 = HIBYTE(__n[1]);
    if ((__n[1] & 0x8000000000000000) == 0)
      v35 = HIBYTE(__n[1]);
    else
      v35 = __n[0];
    if (v35 == v27)
    {
      if (v26 >= 0)
        v36 = &v109;
      else
        v36 = (unsigned __int8 **)v109;
      if ((__n[1] & 0x8000000000000000) == 0)
      {
        if (HIBYTE(__n[1]))
        {
          v37 = &__p;
          while (*(unsigned __int8 *)v37 == *(unsigned __int8 *)v36)
          {
            v37 = (void **)((char *)v37 + 1);
            v36 = (unsigned __int8 **)((char *)v36 + 1);
            if (!--v34)
              goto LABEL_97;
          }
          goto LABEL_84;
        }
LABEL_97:
        v42 = *((unsigned __int8 *)a7 + 23);
        if ((v42 & 0x80u) == 0)
          v43 = (const void *)*((unsigned __int8 *)a7 + 23);
        else
          v43 = a7[1];
        v44 = (const void *)v113;
        if ((v113 & 0x80u) != 0)
          v44 = (const void *)v112[1];
        if (v43 == v44)
        {
          if ((v113 & 0x80u) == 0)
            v45 = (unsigned __int8 *)v112;
          else
            v45 = (unsigned __int8 *)v112[0];
          if ((v42 & 0x80) == 0)
          {
            if (*((_BYTE *)a7 + 23))
            {
              v46 = a7;
              while (*(unsigned __int8 *)v46 == *v45)
              {
                v46 = (const void **)((char *)v46 + 1);
                ++v45;
                if (!--v42)
                  goto LABEL_135;
              }
              goto LABEL_113;
            }
            goto LABEL_135;
          }
          if (!memcmp(*a7, v45, (size_t)a7[1]))
          {
LABEL_135:
            v53 = (uint64_t *)a1[6];
            if (v53 == a1 + 5)
            {
              v54 = 0;
LABEL_156:
              switch((unint64_t)v107)
              {
                case 1uLL:
                  v61 = sub_10033C7BC();
                  goto LABEL_161;
                case 2uLL:
                  v61 = sub_10033C894();
                  goto LABEL_161;
                case 3uLL:
                  v61 = sub_10033C96C();
                  goto LABEL_161;
                case 4uLL:
                  v61 = sub_10033CA44();
LABEL_161:
                  v62 = (void *)(v54 + 1);
                  if (v54 + 1 <= v61)
                  {
                    if (qword_1022A00F0 != -1)
                      dispatch_once(&qword_1022A00F0, &stru_102130670);
                    v68 = qword_1022A00F8;
                    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
                    {
                      v69 = *((char *)a2 + 23);
                      v70 = (size_t *)*a2;
                      sub_1002F822C((uint64_t)&v116, (uint64_t)v89);
                      v71 = v69 >= 0 ? a2 : v70;
                      v72 = v90 >= 0 ? v89 : (void **)v89[0];
                      *(_DWORD *)buf = 68290050;
                      v94 = 0;
                      v95 = 2082;
                      v96 = "";
                      v97 = 2082;
                      v98 = v71;
                      v99 = 2082;
                      v100 = v72;
                      v101 = 2050;
                      v102 = (void **)v107;
                      v103 = 2050;
                      v104 = v62;
                      _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager client connected to service\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s, \"ServiceType\":%{public}lu, \"NumberOfConnectionsToServiceType\":%{public}lu}", buf, 0x3Au);
                      if (v90 < 0)
                        operator delete(v89[0]);
                    }
                    if (!v114)
                      sub_10028DF3C();
                    sub_100347010((uint64_t)buf, (uint64_t)a1, (uint64_t)&v107, (uint64_t)(a1 + 1));
                    v73 = sub_10033CB20(a1 + 5, (__int128 *)buf);
                    sub_10033CB6C((uint64_t)buf);
                    sub_100341E9C((uint64_t)(a1 + 8), &v116, &v116, &v115);
                    if (v74)
                    {
                      v75 = -[CLOSTransaction initWithDescription:]([CLOSTransaction alloc], "initWithDescription:", "com.apple.locationd.microlocation-service-connect");
                      sub_10033CBCC((uint64_t)a1, (uint64_t)v73);
                      sub_10033CC10((uint64_t)a1, v73);
                      sub_10033CFE0((uint64_t)a1);

                      v23 = -1;
                    }
                    else
                    {
                      if (qword_1022A00F0 != -1)
                        dispatch_once(&qword_1022A00F0, &stru_102130670);
                      v76 = qword_1022A00F8;
                      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
                      {
                        if (*((char *)a2 + 23) >= 0)
                          v77 = a2;
                        else
                          v77 = (size_t *)*a2;
                        sub_1002F822C((uint64_t)&v116, (uint64_t)v89);
                        v78 = v90;
                        v79 = (void **)v89[0];
                        sub_1002F822C((uint64_t)&v115, (uint64_t)v87);
                        v80 = v89;
                        if (v78 < 0)
                          v80 = v79;
                        if (v88 >= 0)
                          v81 = v87;
                        else
                          v81 = (void **)v87[0];
                        *(_DWORD *)buf = 68289794;
                        v94 = 0;
                        v95 = 2082;
                        v96 = "";
                        v97 = 2082;
                        v98 = v77;
                        v99 = 2082;
                        v100 = v80;
                        v101 = 2082;
                        v102 = v81;
                        _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"MiLoServiceManager, failed to insert to fServiceIdToConnectionIdMap\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s, \"ConnectionToken\":%{public, location:escape_only}s}", buf, 0x30u);
                        if (v88 < 0)
                          operator delete(v87[0]);
                        if (v90 < 0)
                          operator delete(v89[0]);
                        if (qword_1022A00F0 != -1)
                          dispatch_once(&qword_1022A00F0, &stru_102130670);
                      }
                      v82 = qword_1022A00F8;
                      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
                      {
                        if (*((char *)a2 + 23) < 0)
                          a2 = (size_t *)*a2;
                        sub_1002F822C((uint64_t)&v116, (uint64_t)v89);
                        v83 = v90;
                        v84 = (void **)v89[0];
                        sub_1002F822C((uint64_t)&v115, (uint64_t)v87);
                        v85 = v89;
                        if (v83 < 0)
                          v85 = v84;
                        if (v88 >= 0)
                          v86 = v87;
                        else
                          v86 = (void **)v87[0];
                        *(_DWORD *)buf = 68289794;
                        v94 = 0;
                        v95 = 2082;
                        v96 = "";
                        v97 = 2082;
                        v98 = a2;
                        v99 = 2082;
                        v100 = v85;
                        v101 = 2082;
                        v102 = v86;
                        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v82, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "MiLoServiceManager, failed to insert to fServiceIdToConnectionIdMap", "{\"msg%{public}.0s\":\"MiLoServiceManager, failed to insert to fServiceIdToConnectionIdMap\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s, \"ConnectionToken\":%{public, location:escape_only}s}", buf, 0x30u);
                        if (v88 < 0)
                          operator delete(v87[0]);
                        if (v90 < 0)
                          operator delete(v89[0]);
                      }
                      v23 = 0;
                    }
                  }
                  else
                  {
                    if (qword_1022A00F0 != -1)
                      dispatch_once(&qword_1022A00F0, &stru_102130670);
                    v63 = qword_1022A00F8;
                    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
                    {
                      v64 = *((char *)a2 + 23);
                      v65 = (size_t *)*a2;
                      sub_1002F822C((uint64_t)&v116, (uint64_t)v89);
                      v66 = v64 >= 0 ? a2 : v65;
                      v67 = v90 >= 0 ? v89 : (void **)v89[0];
                      *(_DWORD *)buf = 68289794;
                      v94 = 0;
                      v95 = 2082;
                      v96 = "";
                      v97 = 2082;
                      v98 = v66;
                      v99 = 2082;
                      v100 = v67;
                      v101 = 2050;
                      v102 = (void **)v107;
                      _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager cannot connect to service since client has maxed out number of connections\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s, \"ServiceType\":%{public}lu}", buf, 0x30u);
                      if (v90 < 0)
                        operator delete(v89[0]);
                    }
                    v23 = 32;
                  }
                  break;
                default:
                  v23 = 3;
                  break;
              }
              goto LABEL_131;
            }
            v54 = 0;
            while (1)
            {
              v55 = (unsigned __int8 *)sub_100347150((uint64_t)(v53 + 2));
              v56 = v55[23];
              if ((v56 & 0x80u) == 0)
                v57 = v55[23];
              else
                v57 = *((_QWORD *)v55 + 1);
              v58 = v111;
              if ((v111 & 0x80u) != 0)
                v58 = v110;
              if (v57 != v58)
                goto LABEL_153;
              v59 = (v111 & 0x80u) == 0 ? &v109 : (unsigned __int8 **)v109;
              if ((v56 & 0x80) == 0)
                break;
              if (!memcmp(*(const void **)v55, v59, *((_QWORD *)v55 + 1)))
                goto LABEL_152;
LABEL_153:
              v53 = (uint64_t *)v53[1];
              if (v53 == a1 + 5)
                goto LABEL_156;
            }
            if (v55[23])
            {
              while (*v55 == *(unsigned __int8 *)v59)
              {
                ++v55;
                v59 = (unsigned __int8 **)((char *)v59 + 1);
                if (!--v56)
                  goto LABEL_152;
              }
              goto LABEL_153;
            }
LABEL_152:
            v60 = (void **)sub_1003471B4((uint64_t)(v53 + 2));
            v54 += v60 == v107;
            goto LABEL_153;
          }
        }
LABEL_113:
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_102130670);
        v47 = qword_1022A00F8;
        if (!os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
          goto LABEL_130;
        if (*((char *)a2 + 23) < 0)
          a2 = (size_t *)*a2;
        v48 = (char *)operator new(0x28uLL);
        *(_QWORD *)(v48 + 29) = 0;
        *(_OWORD *)v48 = 0u;
        *((_OWORD *)v48 + 1) = 0u;
        sub_100261F9C((uint64_t)&v116, v48);
        if (!v114)
          sub_10028DF3C();
        if ((v111 & 0x80u) == 0)
          v49 = (void **)&v109;
        else
          v49 = (void **)v109;
        if (*((char *)a7 + 23) >= 0)
          v50 = a7;
        else
          v50 = (void *)*a7;
        if ((v113 & 0x80u) == 0)
          v51 = v112;
        else
          v51 = (_QWORD *)v112[0];
        *(_DWORD *)buf = 68290306;
        v94 = 0;
        v95 = 2082;
        v96 = "";
        v97 = 2082;
        v98 = a2;
        v99 = 2082;
        v100 = (void **)v48;
        v101 = 2082;
        v102 = v49;
        v103 = 2082;
        v104 = v50;
        v105 = 2082;
        v106 = v51;
        _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager cannot connect to service because client's user mismatched with service\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s, \"ExpectedClientId\":%{public, location:escape_only}s, \"UserID\":%{public, location:escape_only}s, \"ExpectedUserID\":%{public, location:escape_only}s}", buf, 0x44u);
        v41 = v48;
LABEL_129:
        operator delete(v41);
LABEL_130:
        v23 = 20;
LABEL_131:
        sub_1003407A4((uint64_t)&v107);
        goto LABEL_132;
      }
      if (!memcmp(__p, v36, __n[0]))
        goto LABEL_97;
    }
LABEL_84:
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130670);
    v38 = qword_1022A00F8;
    if (!os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      goto LABEL_130;
    if (*((char *)a2 + 23) < 0)
      a2 = (size_t *)*a2;
    sub_1002F822C((uint64_t)&v116, (uint64_t)v89);
    if (!v114)
      sub_10028DF3C();
    v39 = v89;
    if (v90 < 0)
      v39 = (void **)v89[0];
    v40 = (v111 & 0x80u) == 0 ? (void **)&v109 : (void **)v109;
    *(_DWORD *)buf = 68289794;
    v94 = 0;
    v95 = 2082;
    v96 = "";
    v97 = 2082;
    v98 = a2;
    v99 = 2082;
    v100 = v39;
    v101 = 2082;
    v102 = v40;
    _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager cannot connect to service since client unauthorised to connect\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s, \"ExpectedClientId\":%{public, location:escape_only}s}", buf, 0x30u);
    if ((v90 & 0x80000000) == 0)
      goto LABEL_130;
    v41 = v89[0];
    goto LABEL_129;
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130670);
  v30 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) < 0)
      a2 = (size_t *)*a2;
    v31 = (char *)operator new(0x28uLL);
    *(_QWORD *)(v31 + 29) = 0;
    *(_OWORD *)v31 = 0u;
    *((_OWORD *)v31 + 1) = 0u;
    sub_100261F9C((uint64_t)&v116, v31);
    *(_DWORD *)buf = 68289538;
    v94 = 0;
    v95 = 2082;
    v96 = "";
    v97 = 2082;
    v98 = a2;
    v99 = 2082;
    v100 = (void **)v31;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager cannot connect to service since database is not available\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s}", buf, 0x26u);
    operator delete(v31);
  }
  v23 = 33;
LABEL_132:
  if (SHIBYTE(__n[1]) < 0)
    operator delete(__p);
  return v23;
}

void sub_10033C6AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  uint64_t v27;

  if (a20 < 0)
    operator delete(__p);
  sub_1003407A4(v27 - 224);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

uint64_t sub_10033C7BC()
{
  CFStringRef v0;
  int v1;
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unsigned int v7;
  uint64_t v8;
  std::__shared_weak_count *v9;

  sub_1001E4804(&v8);
  v7 = 0;
  v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsMaximumNumberOfConnectedUnsupervisedServicesPerClient", 0x8000100u, kCFAllocatorNull);
  v1 = sub_1000B1180(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  v2 = v7;
  v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  if (v1)
    return v2;
  else
    return 1;
}

void sub_10033C87C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  sub_100261F44((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10033C894()
{
  CFStringRef v0;
  int v1;
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unsigned int v7;
  uint64_t v8;
  std::__shared_weak_count *v9;

  sub_1001E4804(&v8);
  v7 = 0;
  v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsMaximumNumberOfConnectedBinaryRoiServicesPerClient", 0x8000100u, kCFAllocatorNull);
  v1 = sub_1000B1180(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  v2 = v7;
  v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  if (v1)
    return v2;
  else
    return 1;
}

void sub_10033C954(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  sub_100261F44((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10033C96C()
{
  CFStringRef v0;
  int v1;
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unsigned int v7;
  uint64_t v8;
  std::__shared_weak_count *v9;

  sub_1001E4804(&v8);
  v7 = 0;
  v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsMaximumNumberOfConnectedMulticlassServicesPerClient", 0x8000100u, kCFAllocatorNull);
  v1 = sub_1000B1180(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  v2 = v7;
  v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  if (v1)
    return v2;
  else
    return 1;
}

void sub_10033CA2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  sub_100261F44((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10033CA44()
{
  CFStringRef v0;
  int v1;
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unsigned int v7;
  uint64_t v8;
  std::__shared_weak_count *v9;

  sub_1001E4804(&v8);
  v7 = 0;
  v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsMaximumNumberOfConnectedSimilarityListServicesPerClient", 0x8000100u, kCFAllocatorNull);
  v1 = sub_1000B1180(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  v2 = v7;
  v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  if (v1)
    return v2;
  else
    return 10;
}

void sub_10033CB08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  sub_100261F44((uint64_t)va);
  _Unwind_Resume(a1);
}

_QWORD *sub_10033CB20(uint64_t *a1, __int128 *a2)
{
  _QWORD *v3;
  uint64_t v4;

  v3 = sub_100341BD8((uint64_t)a1, 0, 0, a2);
  v4 = *a1;
  *v3 = *a1;
  v3[1] = a1;
  *(_QWORD *)(v4 + 8) = v3;
  *a1 = (uint64_t)v3;
  ++a1[2];
  return v3 + 2;
}

uint64_t sub_10033CB6C(uint64_t a1)
{
  sub_1003407EC((_QWORD *)(a1 + 376));
  sub_1003407EC((_QWORD *)(a1 + 304));
  sub_100340880(a1 + 112);
  sub_100261F44(a1 + 96);
  if (*(char *)(a1 + 87) < 0)
    operator delete(*(void **)(a1 + 64));
  if (*(char *)(a1 + 63) < 0)
    operator delete(*(void **)(a1 + 40));
  return a1;
}

uint64_t sub_10033CBCC(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  double Current;

  v2 = *(_QWORD *)(a1 + 104);
  v3 = sub_100347144(a2);
  v5 = v4;
  Current = j__CFAbsoluteTimeGetCurrent();
  return sub_1002859C8(v2, v3, v5, Current);
}

void sub_10033CC10(uint64_t a1, _QWORD *a2)
{
  unint64_t *v4;
  CFStringRef v5;
  char v6;
  int v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  char v11;
  int v12;
  __int128 v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  __int128 v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  uint64_t v39;
  std::__shared_weak_count *v40;
  __int128 v41;
  __int128 v42;

  v4 = (unint64_t *)(a1 + 112);
  if (!*(_BYTE *)(a1 + 136) || !sub_1003471C4((uint64_t)a2, *v4))
    goto LABEL_16;
  if (!*(_BYTE *)(a1 + 136))
    sub_10028DF3C();
  if (*v4 != 2)
  {
    v42 = 0uLL;
    goto LABEL_19;
  }
  sub_1001E4804(&v42);
  LOBYTE(v41) = 0;
  v5 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsEnableServiceInCustomLOI", 0x8000100u, kCFAllocatorNull);
  v6 = sub_1001E48E4(v42, (uint64_t)v5, (BOOL *)&v41);
  CFRelease(v5);
  v7 = v41;
  v8 = (std::__shared_weak_count *)*((_QWORD *)&v42 + 1);
  if (*((_QWORD *)&v42 + 1))
  {
    v9 = (unint64_t *)(*((_QWORD *)&v42 + 1) + 8);
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  v11 = v7 ? v6 : 0;
  if ((v11 & 1) == 0)
  {
LABEL_16:
    sub_10033D6EC(a1, (uint64_t)a2);
LABEL_17:
    sub_10034D4D4(a2, v4);
    return;
  }
  v12 = *(unsigned __int8 *)(a1 + 136);
  v42 = 0uLL;
  if (!v12)
    sub_10028DF3C();
LABEL_19:
  sub_10033F42C(a1, (uint64_t)a2, &v41);
  v13 = v41;
  v41 = 0uLL;
  v14 = (std::__shared_weak_count *)*((_QWORD *)&v42 + 1);
  v42 = v13;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      v16 = __ldaxr(p_shared_owners);
    while (__stlxr(v16 - 1, p_shared_owners));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  v17 = (std::__shared_weak_count *)*((_QWORD *)&v41 + 1);
  if (*((_QWORD *)&v41 + 1))
  {
    v18 = (unint64_t *)(*((_QWORD *)&v41 + 1) + 8);
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  v20 = v42;
  if ((_QWORD)v42)
    goto LABEL_42;
  if (!*(_BYTE *)(a1 + 136))
    sub_10028DF3C();
  sub_10033E1C8((uint64_t)a2, *(_QWORD *)(a1 + 104), a1 + 152, (uint64_t *)v4, &v41);
  v21 = v41;
  v41 = 0uLL;
  v22 = (std::__shared_weak_count *)*((_QWORD *)&v42 + 1);
  v42 = v21;
  if (v22)
  {
    v23 = (unint64_t *)&v22->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
  v25 = (std::__shared_weak_count *)*((_QWORD *)&v41 + 1);
  if (*((_QWORD *)&v41 + 1))
  {
    v26 = (unint64_t *)(*((_QWORD *)&v41 + 1) + 8);
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  sub_10033F68C((char **)(a1 + 16), &v42);
  v20 = v42;
  if ((_QWORD)v42)
  {
LABEL_42:
    v39 = v20;
    v40 = (std::__shared_weak_count *)*((_QWORD *)&v42 + 1);
    if (*((_QWORD *)&v42 + 1))
    {
      v28 = (unint64_t *)(*((_QWORD *)&v42 + 1) + 8);
      do
        v29 = __ldxr(v28);
      while (__stxr(v29 + 1, v28));
    }
    sub_100348FBC((uint64_t)a2, &v39);
    v30 = v40;
    if (v40)
    {
      v31 = (unint64_t *)&v40->__shared_owners_;
      do
        v32 = __ldaxr(v31);
      while (__stlxr(v32 - 1, v31));
      if (!v32)
      {
        ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
        std::__shared_weak_count::__release_weak(v30);
      }
    }
    v33 = (std::__shared_weak_count *)*((_QWORD *)&v42 + 1);
    v42 = 0uLL;
    if (v33)
    {
      v34 = (unint64_t *)&v33->__shared_owners_;
      do
        v35 = __ldaxr(v34);
      while (__stlxr(v35 - 1, v34));
      if (!v35)
      {
        ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
        std::__shared_weak_count::__release_weak(v33);
      }
      v36 = (std::__shared_weak_count *)*((_QWORD *)&v42 + 1);
      if (*((_QWORD *)&v42 + 1))
      {
        v37 = (unint64_t *)(*((_QWORD *)&v42 + 1) + 8);
        do
          v38 = __ldaxr(v37);
        while (__stlxr(v38 - 1, v37));
        if (!v38)
        {
          ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
          std::__shared_weak_count::__release_weak(v36);
        }
      }
    }
    goto LABEL_17;
  }
  sub_1018F4784();
  abort_report_np("%s:%d: assertion failure in %s", "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/ServiceManager/CLMiLoServiceManager.mm", 679, "enterLocationPerService");
  __break(1u);
}

void sub_10033CFA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  sub_100261F44((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10033CFE0(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  int v4;

  v2 = a1 + 40;
  v3 = *(_QWORD *)(a1 + 48);
  if (v3 == a1 + 40)
  {
    LOBYTE(v4) = 0;
  }
  else
  {
    v4 = 0;
    do
    {
      v4 |= sub_10034B350(v3 + 16);
      v3 = *(_QWORD *)(v3 + 8);
    }
    while (v3 != v2);
  }
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 8) + 64))(*(_QWORD *)(a1 + 144) + 8, v4 & 1);
}

uint64_t sub_10033D048(_QWORD *a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5)
{
  unint64_t v8;
  char v9;
  uint64_t v10;
  unsigned __int8 *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  unsigned __int8 *v16;
  NSObject *v17;
  char *v18;
  NSObject *v20;
  char *v21;
  int v22;
  unsigned __int8 *v23;
  uint64_t v24;
  unsigned __int8 *v25;
  uint64_t v26;
  void *v27;
  unsigned __int8 *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  unsigned __int8 *v33;
  NSObject *v34;
  char *v35;
  unsigned __int8 *v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  int v40;
  unsigned __int8 *v41;
  uint64_t v42;
  unsigned __int8 *v43;
  uint64_t v44;
  uint64_t v45;
  NSObject *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  double Current;
  unsigned int v52;
  __int128 *v53;
  uint64_t v54;
  __int128 *v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  uint64_t v59;
  char *v60;
  char **v61;
  char v62;
  uint8_t buf[4];
  int v64;
  __int16 v65;
  const char *v66;
  __int16 v67;
  char *v68;
  __int16 v69;
  _BYTE v70[10];
  uint64_t v71;
  __int16 v72;
  unsigned __int8 *v73;
  __int16 v74;
  _QWORD __p[3];
  char v76;
  uint64_t v77;
  _QWORD v78[2];

  v78[0] = a3;
  v78[1] = a4;
  v8 = sub_10033B764((uint64_t)a1, a3, a4);
  if (v9)
  {
    v10 = v8;
    v11 = (unsigned __int8 *)sub_100347150(v8);
    v12 = v11[23];
    if ((v12 & 0x80u) == 0)
      v13 = v11[23];
    else
      v13 = *((_QWORD *)v11 + 1);
    v14 = a2[23];
    v15 = (char)v14;
    if ((v14 & 0x80u) != 0)
      v14 = *((_QWORD *)a2 + 1);
    if (v13 == v14)
    {
      if (v15 >= 0)
        v16 = a2;
      else
        v16 = *(unsigned __int8 **)a2;
      if ((v12 & 0x80) == 0)
      {
        if (v11[23])
        {
          while (*v11 == *v16)
          {
            ++v11;
            ++v16;
            if (!--v12)
              goto LABEL_32;
          }
          goto LABEL_22;
        }
LABEL_32:
        v28 = (unsigned __int8 *)sub_100347158(v10);
        v29 = v28[23];
        if ((v29 & 0x80u) == 0)
          v30 = v28[23];
        else
          v30 = *((_QWORD *)v28 + 1);
        v31 = a5[23];
        v32 = (char)v31;
        if ((v31 & 0x80u) != 0)
          v31 = *((_QWORD *)a5 + 1);
        if (v30 == v31)
        {
          if (v32 >= 0)
            v33 = a5;
          else
            v33 = *(unsigned __int8 **)a5;
          if ((v29 & 0x80) == 0)
          {
            if (v28[23])
            {
              while (*v28 == *v33)
              {
                ++v28;
                ++v33;
                if (!--v29)
                  goto LABEL_65;
              }
              goto LABEL_47;
            }
            goto LABEL_65;
          }
          if (!memcmp(*(const void **)v28, v33, *((_QWORD *)v28 + 1)))
          {
LABEL_65:
            if (qword_1022A00F0 != -1)
              dispatch_once(&qword_1022A00F0, &stru_102130670);
            v46 = qword_1022A00F8;
            if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 68289026;
              v64 = 0;
              v65 = 2082;
              v66 = "";
              _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager::disconnect, releasing model and updating service time\"}", buf, 0x12u);
            }
            sub_10033D6EC((uint64_t)a1, v10);
            v47 = a1[13];
            v48 = sub_100347144(v10);
            v50 = v49;
            Current = j__CFAbsoluteTimeGetCurrent();
            v52 = sub_1003471B4(v10);
            v53 = (__int128 *)sub_100347150(v10);
            v54 = sub_1003471BC(v10);
            v55 = (__int128 *)sub_100347158(v10);
            sub_10034FB50((uint64_t)buf, v48, v50, v52, v53, v54, v55, Current);
            v58 = 0;
            v59 = 0;
            v60 = 0;
            v61 = &v58;
            v62 = 0;
            v58 = (char *)operator new(0x58uLL);
            v59 = (uint64_t)v58;
            v60 = v58 + 88;
            v59 = sub_100341444((uint64_t)&v60, (uint64_t)buf, (uint64_t)&v77, (uint64_t)v58);
            sub_10033B268(v47);
            v61 = &v58;
            sub_100302A1C((void ***)&v61);
            if (v76 < 0)
              operator delete(*(void **)((char *)__p + 4));
            if (SBYTE5(v73) < 0)
              operator delete(*(void **)&v70[2]);
            v56 = sub_100347144(v10);
            sub_10033D904(a1, v56, v57);
            return -1;
          }
        }
LABEL_47:
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_102130670);
        v34 = qword_1022A00F8;
        if (!os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
          return 28;
        v35 = (char *)operator new(0x28uLL);
        *(_OWORD *)v35 = 0u;
        *((_OWORD *)v35 + 1) = 0u;
        *(_QWORD *)(v35 + 29) = 0;
        sub_100261F9C((uint64_t)v78, v35);
        if ((a2[23] & 0x80u) == 0)
          v36 = a2;
        else
          v36 = *(unsigned __int8 **)a2;
        v37 = sub_100347150(v10);
        v38 = *(char *)(v37 + 23);
        v39 = *(_QWORD *)v37;
        v40 = (char)a5[23];
        v41 = *(unsigned __int8 **)a5;
        v42 = sub_100347158(v10);
        if (v40 >= 0)
          v43 = a5;
        else
          v43 = v41;
        if (v38 >= 0)
          v44 = v37;
        else
          v44 = v39;
        if (*(char *)(v42 + 23) >= 0)
          v45 = v42;
        else
          v45 = *(_QWORD *)v42;
        *(_DWORD *)buf = 68290307;
        v64 = 0;
        v65 = 2082;
        v66 = "";
        v67 = 2081;
        v68 = v35;
        v69 = 2081;
        *(_QWORD *)v70 = v36;
        *(_WORD *)&v70[8] = 2081;
        v71 = v44;
        v72 = 2081;
        v73 = v43;
        v74 = 2081;
        __p[0] = v45;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager::disconnect, failed because not authorized to disconnect from this service created by another user\", \"ServiceUUID\":%{private, location:escape_only}s, \"clientId\":%{private, location:escape_only}s, \"loadedServiceClientId\":%{private, location:escape_only}s, \"userId\":%{private, location:escape_only}s, \"loadedServiceUserId\":%{private, location:escape_only}s}", buf, 0x44u);
        v27 = v35;
LABEL_63:
        operator delete(v27);
        return 28;
      }
      if (!memcmp(*(const void **)v11, v16, *((_QWORD *)v11 + 1)))
        goto LABEL_32;
    }
LABEL_22:
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130670);
    v20 = qword_1022A00F8;
    if (!os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      return 28;
    v21 = (char *)operator new(0x28uLL);
    *(_OWORD *)v21 = 0u;
    *((_OWORD *)v21 + 1) = 0u;
    *(_QWORD *)(v21 + 29) = 0;
    sub_100261F9C((uint64_t)v78, v21);
    v22 = (char)a2[23];
    v23 = *(unsigned __int8 **)a2;
    v24 = sub_100347150(v10);
    if (v22 >= 0)
      v25 = a2;
    else
      v25 = v23;
    if (*(char *)(v24 + 23) >= 0)
      v26 = v24;
    else
      v26 = *(_QWORD *)v24;
    *(_DWORD *)buf = 68289795;
    v64 = 0;
    v65 = 2082;
    v66 = "";
    v67 = 2081;
    v68 = v21;
    v69 = 2081;
    *(_QWORD *)v70 = v25;
    *(_WORD *)&v70[8] = 2081;
    v71 = v26;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager::disconnect, failed because not authorized to disconnect from this service\", \"ServiceUUID\":%{private, location:escape_only}s, \"clientId\":%{private, location:escape_only}s, \"loadedServiceClientId\":%{private, location:escape_only}s}", buf, 0x30u);
    v27 = v21;
    goto LABEL_63;
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130670);
  v17 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    v18 = (char *)operator new(0x28uLL);
    *(_OWORD *)v18 = 0u;
    *((_OWORD *)v18 + 1) = 0u;
    *(_QWORD *)(v18 + 29) = 0;
    sub_100261F9C((uint64_t)v78, v18);
    *(_DWORD *)buf = 68289283;
    v64 = 0;
    v65 = 2082;
    v66 = "";
    v67 = 2081;
    v68 = v18;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager::disconnect, failed because not connected to this service\", \"ServiceUUID\":%{private, location:escape_only}s}", buf, 0x1Cu);
    operator delete(v18);
  }
  return 27;
}

void sub_10033D678(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  void **v6;
  va_list va;
  uint64_t v8;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v6 = va_arg(va1, void **);
  v8 = va_arg(va1, _QWORD);
  sub_100302A1C((void ***)va);
  sub_10033B4C4((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_10033D6EC(uint64_t a1, uint64_t a2)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  char *v17;
  _QWORD v18[2];
  uint8_t buf[4];
  int v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  char *v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  uint64_t v28;

  v5 = *(_QWORD *)(a1 + 16);
  v6 = *(_QWORD *)(a1 + 24);
  v4 = (uint64_t *)(a1 + 16);
  sub_100349978(a2);
  v8 = *v4;
  v7 = v4[1];
  if (*v4 == v7)
  {
    v7 = *v4;
  }
  else
  {
    v9 = v8 + 16;
    while (1)
    {
      v10 = *(_QWORD *)(v9 - 8);
      if (v10)
      {
        if (!*(_QWORD *)(v10 + 8))
          break;
      }
      v11 = v9 == v7;
      v9 += 16;
      if (v11)
      {
        v8 = v4[1];
        goto LABEL_16;
      }
    }
    v8 = v9 - 16;
    if (v9 - 16 != v7 && v9 != v7)
    {
      do
      {
        v12 = *(_QWORD *)(v9 + 8);
        if (!v12 || *(_QWORD *)(v12 + 8))
        {
          sub_1002B7674(v8, (__int128 *)v9);
          v8 += 16;
        }
        v9 += 16;
      }
      while (v9 != v7);
      v7 = *(_QWORD *)(a1 + 24);
    }
  }
LABEL_16:
  sub_10033E12C((uint64_t)v4, v8, v7);
  v14 = *(_QWORD *)(a1 + 16);
  v13 = *(_QWORD *)(a1 + 24);
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130670);
  v15 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    v18[0] = sub_100347144(a2);
    v18[1] = v16;
    v17 = (char *)operator new(0x28uLL);
    *(_OWORD *)v17 = 0u;
    *((_OWORD *)v17 + 1) = 0u;
    *(_QWORD *)(v17 + 29) = 0;
    sub_100261F9C((uint64_t)v18, v17);
    *(_DWORD *)buf = 68289795;
    v20 = 0;
    v21 = 2082;
    v22 = "";
    v23 = 2081;
    v24 = v17;
    v25 = 2050;
    v26 = (v6 - v5) >> 4;
    v27 = 2050;
    v28 = (v13 - v14) >> 4;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager::releaseModel, released model\", \"ServiceUUID\":%{private, location:escape_only}s, \"NumModelsBefore\":%{public}lu, \"NumModelsAfter\":%{public}lu}", buf, 0x30u);
    operator delete(v17);
  }
}

void sub_10033D8F0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_10033D904(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v8;
  _QWORD v10[2];
  uint64_t v11;
  uint64_t v12;

  v10[0] = a2;
  v10[1] = a3;
  v4 = a1 + 5;
  v5 = (uint64_t *)a1[6];
  v11 = a2;
  v12 = a3;
  while (v5 != v4)
  {
    if (sub_100347144((uint64_t)(v5 + 2)) == v11 && v6 == v12)
    {
      v4 = v5;
      break;
    }
    v5 = (uint64_t *)v5[1];
  }
  v8 = *v4;
  *(_QWORD *)(v8 + 8) = v4[1];
  *(_QWORD *)v4[1] = v8;
  --a1[7];
  sub_100341220((uint64_t)(v4 + 2));
  operator delete(v4);
  return sub_1002B2F00(a1 + 8, v10);
}

void sub_10033D9D4(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  char v8;
  int v9;

  v7 = sub_10033DA3C(a2);
  if (v8)
  {
    v9 = *(unsigned __int8 *)(a1 + 136);
    *(_QWORD *)(a1 + 112) = v7;
    *(_QWORD *)(a1 + 120) = a3;
    *(_QWORD *)(a1 + 128) = a4;
    if (!v9)
      *(_BYTE *)(a1 + 136) = 1;
  }
  else if (*(_BYTE *)(a1 + 136))
  {
    *(_BYTE *)(a1 + 136) = 0;
  }
  sub_10033DB70((_QWORD *)a1);
}

uint64_t sub_10033DA3C(uint64_t *a1)
{
  int v1;
  uint64_t v3;

  if ((*((char *)a1 + 23) & 0x80000000) == 0)
  {
    v1 = *((unsigned __int8 *)a1 + 23);
    if (v1 != 4)
    {
      if (v1 != 6)
        return 30;
      if (*(_DWORD *)a1 != 1953723747 || *((_WORD *)a1 + 2) != 28015)
      {
LABEL_25:
        if (v1 == 4)
          goto LABEL_26;
        return 30;
      }
      return 2;
    }
    if (*(_DWORD *)a1 != 1701670760)
    {
      if (*(_DWORD *)a1 != 1802661751)
        goto LABEL_25;
      return 1;
    }
    return 0;
  }
  v3 = a1[1];
  if (v3 == 4)
  {
    if (*(_DWORD *)*a1 == 1701670760)
      return 0;
    if (*(_DWORD *)*a1 == 1802661751)
      return 1;
    v3 = a1[1];
  }
  if (v3 == 6)
  {
    if (*(_DWORD *)*a1 == 1953723747 && *(_WORD *)(*a1 + 4) == 28015)
      return 2;
    v3 = a1[1];
  }
  if (v3 != 4)
    return 30;
  a1 = (uint64_t *)*a1;
LABEL_26:
  if (*(_DWORD *)a1 != 1701736302)
    return 30;
  return 0;
}

void sub_10033DB70(_QWORD *a1)
{
  _QWORD *i;
  CLOSTransaction *v3;

  v3 = -[CLOSTransaction initWithDescription:]([CLOSTransaction alloc], "initWithDescription:", "com.apple.locationd.microlocation-update-all-models");
  sub_10033DBF0(a1);
  for (i = (_QWORD *)a1[6]; i != a1 + 5; i = (_QWORD *)i[1])
    sub_10033CC10((uint64_t)a1, i + 2);
  sub_10033CFE0((uint64_t)a1);

}

uint64_t sub_10033DBF0(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *i;
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v2 = a1 + 5;
  for (i = (_QWORD *)a1[6]; i != v2; i = (_QWORD *)i[1])
    sub_10033D6EC((uint64_t)a1, (uint64_t)(i + 2));
  v5 = a1[2];
  result = a1[3];
  if (v5 != result)
  {
    v6 = a1[2];
    do
    {
      v7 = *(_QWORD *)(v6 + 8);
      if (!v7 || *(_QWORD *)(v7 + 8))
        sub_1018F4904();
      v6 += 16;
    }
    while (v6 != result);
    for (; result != v5; result = sub_100261F44(result - 16))
      ;
  }
  a1[3] = v5;
  return result;
}

uint64_t sub_10033DC84(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4, uint64_t a5, int a6)
{
  uint64_t *v9;
  char v10;

  v9 = (uint64_t *)sub_10033B764(a1, a2, a3);
  if (v10)
    return sub_10034BC78(v9, a4, a5, a6);
  else
    return 0;
}

BOOL sub_10033DCDC(uint64_t a1, uint64_t *a2, int a3)
{
  _QWORD *v4;
  unsigned __int8 v5;
  uint64_t v6;

  v4 = (_QWORD *)sub_10033B764(a1, *a2, a2[1]);
  v6 = v5;
  if (v5)
    sub_10034E5B8(v4, a3);
  return v6 != 0;
}

BOOL sub_10033DD1C(uint64_t a1, uint64_t *a2)
{
  _BYTE *v2;
  unsigned __int8 v3;
  uint64_t v4;

  v2 = (_BYTE *)sub_10033B764(a1, *a2, a2[1]);
  v4 = v3;
  if (v3)
    sub_10034E5D0(v2);
  return v4 != 0;
}

void sub_10033DD54(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  uint64_t v5;
  int64x2_t *v6;
  int64x2_t *v7;
  uint64_t v11;
  char v12;
  uint64_t i;

  v6 = (int64x2_t *)(a1 + 40);
  v7 = *(int64x2_t **)(a1 + 48);
  if (v7 != (int64x2_t *)(a1 + 40))
  {
    do
    {
      v5 &= 0xFFFFFFFFFFFFFF00;
      v4 &= 0xFFFFFFFFFFFFFF00;
      v11 = sub_100348FAC((uint64_t)v7[1].i64);
      if (v12)
      {
        for (i = *a2; i != a2[1]; i += 216)
        {
          if (*(_OWORD *)(i + 168) == *(_OWORD *)(v11 + 352))
          {
            v5 = i;
            v4 = v4 & 0xFFFFFFFFFFFFFF00 | 1;
          }
        }
      }
      sub_100347730(v7 + 1, v5, v4, a3, a4);
      v7 = (int64x2_t *)v7->i64[1];
    }
    while (v7 != v6);
  }
}

void sub_10033DE58(uint64_t a1)
{
  uint64_t v1;
  uint64_t i;

  v1 = a1 + 40;
  for (i = *(_QWORD *)(a1 + 48); i != v1; i = *(_QWORD *)(i + 8))
    sub_100348A28(i + 16);
}

void sub_10033DE90(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = a1 + 40;
  v3 = *(_QWORD *)(a1 + 48);
  if (v3 != a1 + 40)
  {
    do
    {
      sub_100348A30((uint64_t *)(v3 + 16), a2);
      v3 = *(_QWORD *)(v3 + 8);
    }
    while (v3 != v2);
  }
}

uint64_t sub_10033DEDC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t *v9;
  char v10;
  __int128 v12;

  *(_QWORD *)&v12 = a4;
  *((_QWORD *)&v12 + 1) = a5;
  v9 = (uint64_t *)sub_10033B764(a1, a2, a3);
  if (v10)
    return sub_10034C0F4(v9, &v12, a6, a7);
  else
    return 0;
}

BOOL sub_10033DF58(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  _QWORD *v7;
  unsigned __int8 v8;
  uint64_t v9;
  _QWORD v11[2];
  _QWORD v12[2];

  v12[0] = a4;
  v12[1] = a5;
  v11[0] = a6;
  v11[1] = a7;
  v7 = (_QWORD *)sub_10033B764(a1, a2, a3);
  v9 = v8;
  if (v8)
    sub_10034D58C(v7, v12, v11);
  return v9 != 0;
}

BOOL sub_10033DFCC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  _QWORD *v11;
  unsigned __int8 v12;
  uint64_t v13;

  v11 = (_QWORD *)sub_10033B764(a1, a2, a3);
  v13 = v12;
  if (v12)
    sub_10034E2DC(v11, a4, a5, a6, a7);
  return v13 != 0;
}

uint64_t sub_10033E02C(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 8) + 32))(*(_QWORD *)(a1 + 144) + 8);
}

uint64_t sub_10033E03C(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 8) + 48))(*(_QWORD *)(a1 + 144) + 8);
}

uint64_t sub_10033E04C(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 8) + 56))(*(_QWORD *)(a1 + 144) + 8);
}

uint64_t sub_10033E05C(uint64_t a1)
{
  return a1 + 16;
}

uint64_t sub_10033E064@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t v5;
  uint64_t i;
  uint64_t v7;

  v5 = result + 40;
  for (i = *(_QWORD *)(result + 48); ; i = *(_QWORD *)(i + 8))
  {
    if (i == v5)
    {
      *a4 = 0;
      a4[1] = 0;
      return result;
    }
    result = sub_100347144(i + 16);
    if (result == a2 && v7 == a3)
      break;
  }
  return sub_100348F88(i + 16, a4);
}

uint64_t sub_10033E12C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (a2 != a3)
  {
    v5 = a3;
    v6 = *(_QWORD *)(a1 + 8);
    if (a3 == v6)
    {
      v8 = a2;
    }
    else
    {
      v7 = 16 * ((a3 - a2) >> 4);
      v8 = a2;
      do
      {
        sub_1002B7674(v8, (__int128 *)(v8 + v7));
        v8 += 16;
      }
      while (v8 + v7 != v6);
      v5 = *(_QWORD *)(a1 + 8);
    }
    while (v5 != v8)
      v5 = sub_100261F44(v5 - 16);
    *(_QWORD *)(a1 + 8) = v8;
  }
  return a2;
}

uint64_t sub_10033E1C8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X3>, _QWORD *a5@<X8>)
{
  uint64_t v9;
  int v10;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v17;
  std::string::size_type v18;
  NSObject *v19;
  std::string *v20;
  char *v21;
  char *v22;
  char *v23;
  void *v24;
  void *v25;
  uint64_t v26;
  std::string::size_type v27;
  NSObject *v28;
  std::string *v29;
  char *v30;
  char *v31;
  char *v32;
  NSObject *v33;
  std::string *v34;
  _OWORD *v35;
  std::string *v36;
  char *v37;
  std::string *v38;
  std::string *v39;
  void ***v40;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  double Current;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  double v53;
  void *__dst[2];
  uint64_t v56;
  char v57;
  std::string v58[8];
  int v59;
  void **v60;
  char v61;
  void *v62[2];
  uint64_t v63;
  void *v64;
  __int128 v65;
  uint64_t v66;
  void *v67;
  char v68;
  char v69;
  __int128 v70;
  uint64_t v71;
  _BYTE __p[28];
  __int16 v73;
  std::string *v74;
  __int16 v75;
  char *v76;
  __int16 v77;
  std::string *v78;
  __int16 v79;
  char *v80;
  __int16 v81;
  void *v82;
  void *v83;
  char v84;
  char v85[24];
  __int128 v86;
  void *v87;
  void *v88;
  void *v89;
  char v90;
  std::string v91;
  int v92;
  int v93;
  uint64_t v94;
  int v95;
  __int128 v96;
  uint64_t v97;
  char v98[24];
  char v99;
  void *v100;
  void *v101;
  void *v102;
  char v103;
  __int128 v104;
  double v105;
  unsigned int v106;
  uint64_t v107;
  std::string v108;
  char v109;
  uint64_t v110[2];
  char v111;

  LOBYTE(v104) = 0;
  v111 = 0;
  if (sub_1003471B4(a1) == 1)
  {
    sub_10027F418(a2, 0, a4[1], a4[2], __p);
    sub_100300D1C((uint64_t)&v104, (uint64_t)__p);
    sub_1002708A4((uint64_t)__p);
    if (!v111)
      goto LABEL_15;
    if (!v109)
    {
      sub_1003471A4(a1, __p);
      if (!v111)
        sub_10028DF3C();
      sub_1003408F0(&v108, (const std::string *)__p);
      if ((__p[23] & 0x80000000) != 0)
        operator delete(*(void **)__p);
      if (!v111)
        sub_10028DF3C();
      sub_100300804(__p, &v104);
      memset(&v91, 0, sizeof(v91));
      LOBYTE(v65) = 0;
      v91.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x118uLL);
      v91.__r_.__value_.__l.__size_ = v91.__r_.__value_.__r.__words[0];
      v91.__r_.__value_.__r.__words[2] = v91.__r_.__value_.__r.__words[0] + 280;
      v91.__r_.__value_.__l.__size_ = (std::string::size_type)sub_100300880((uint64_t)&v91.__r_.__value_.__r.__words[2], (__int128 *)__p, &v86, v91.__r_.__value_.__l.__data_);
      sub_1003002D8(a2);
      v64 = &v91;
      sub_1003009DC((void ***)&v64);
      if (v85[0] && v84 < 0)
        operator delete(v83);
      sub_1002C8104((char *)&v74 + 2);
    }
  }
  else
  {
    sub_10034C434(a1, &v91);
    sub_10027FD8C(a2, (uint64_t)&v91, a4[1], a4[2], __p);
    sub_100300D1C((uint64_t)&v104, (uint64_t)__p);
    sub_1002708A4((uint64_t)__p);
    if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v91.__r_.__value_.__l.__data_);
  }
  if (v111)
  {
LABEL_97:
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130670);
    v33 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      if (!v111 || !v109)
        sub_10028DF3C();
      if ((v108.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v34 = &v108;
      else
        v34 = (std::string *)v108.__r_.__value_.__r.__words[0];
      v35 = operator new(0x28uLL);
      v64 = v35;
      v65 = xmmword_101B97FF0;
      *v35 = 0u;
      v35[1] = 0u;
      *(_QWORD *)((char *)v35 + 29) = 0;
      sub_100261F9C((uint64_t)&v104, v35);
      if (v65 >= 0)
        v36 = (std::string *)&v64;
      else
        v36 = (std::string *)v64;
      if (!v111)
        sub_10028DF3C();
      v37 = (char *)v106;
      memset(v58, 0, 24);
      if ((sub_10026A098((uint64_t)v110, v58) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)&v91);
        v91.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_10212A508;
        sub_10026A9C8((uint64_t)&v91);
      }
      v38 = v58;
      if ((v58[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v38 = (std::string *)v58[0].__r_.__value_.__r.__words[0];
      *(_QWORD *)__p = 68290051;
      *(_WORD *)&__p[8] = 2082;
      *(_QWORD *)&__p[10] = "";
      *(_WORD *)&__p[18] = 2082;
      *(_QWORD *)&__p[20] = v34;
      v73 = 2082;
      v74 = v36;
      v75 = 2050;
      v76 = v37;
      v77 = 2081;
      v78 = v38;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager loaded model from DB:\", \"ClientId\":%{public, location:escape_only}s, \"ModelUuid\":%{public, location:escape_only}s, \"ModelType\":%{public}lld, \"LOI ID\":%{private, location:escape_only}s}", __p, 0x3Au);
      if (SHIBYTE(v58[0].__r_.__value_.__r.__words[2]) < 0)
        operator delete(v58[0].__r_.__value_.__l.__data_);
      if (SHIBYTE(v65) < 0)
        operator delete(v64);
    }
    if (!v111)
      sub_10028DF3C();
    sub_1002EDC8C((uint64_t)&v107, a3, (uint64_t)__p);
    if (!v111)
      sub_10028DF3C();
    sub_1003471A4(a1, &v91);
    if (!v111)
      sub_10028DF3C();
    sub_100346E1C(a1, (uint64_t)&v64);
    if (!v111)
      sub_10028DF3C();
    sub_1003420FC((unsigned int *)__p, (uint64_t *)&v104, (__int128 *)&v91, v110, (__int128 *)&v64, &v105, a5);
    if (SHIBYTE(v65) < 0)
      operator delete(v64);
    if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v91.__r_.__value_.__l.__data_);
    if (v90 < 0)
      operator delete(v89);
    if (v87)
    {
      v88 = v87;
      operator delete(v87);
    }
    v39 = (std::string *)__p;
    sub_100270738((uint64_t)v85);
    v91.__r_.__value_.__r.__words[0] = (std::string::size_type)&v83;
    v40 = (void ***)&v91;
    goto LABEL_129;
  }
LABEL_15:
  if (sub_1003471B4(a1) != 2)
    goto LABEL_25;
  v9 = sub_100347150(a1);
  v10 = *(char *)(v9 + 23);
  if (v10 < 0)
  {
    if (*(_QWORD *)(v9 + 8) != 10)
      goto LABEL_25;
    v9 = *(_QWORD *)v9;
  }
  else if (v10 != 10)
  {
    goto LABEL_25;
  }
  if (*(_QWORD *)v9 != 0x6F6D2D7375636F66 || *(_WORD *)(v9 + 8) != 25956)
  {
LABEL_25:
    if (sub_1003471B4(a1) != 4)
      goto LABEL_96;
    v13 = a4[1];
    v12 = a4[2];
    *(_QWORD *)&v70 = v13;
    *((_QWORD *)&v70 + 1) = v12;
    sub_10027F418(a2, 2u, v13, v12, &v91);
    sub_1015A2E04(&v64, "");
    if ((_BYTE)v13)
    {
LABEL_27:
      v14 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v14 + 29) = 0;
      *(_OWORD *)v14 = 0u;
      *((_OWORD *)v14 + 1) = 0u;
      sub_100261F9C((uint64_t)&v70, v14);
      if (SHIBYTE(v65) < 0)
        operator delete(v64);
      v64 = v14;
      v65 = xmmword_101B97FF0;
    }
    else
    {
      v15 = 1;
      while (v15 != 16)
      {
        if (*((unsigned __int8 *)&v70 + v15++))
        {
          if ((unint64_t)(v15 - 2) <= 0xE)
            goto LABEL_27;
          break;
        }
      }
    }
    if (v99)
    {
      sub_10034C434(a1, (std::string *)__p);
      if (!v99)
        sub_10028DF3C();
      if (v98[0])
      {
        if (SHIBYTE(v97) < 0)
          operator delete((void *)v96);
        v96 = *(_OWORD *)__p;
        v97 = *(_QWORD *)&__p[16];
      }
      else
      {
        v96 = *(_OWORD *)__p;
        v97 = *(_QWORD *)&__p[16];
        v98[0] = 1;
      }
      if (v99)
      {
        if (v94)
        {
          sub_1002C72D0(v94);
          v95 &= ~0x400u;
          if (!v99)
            sub_10028DF3C();
        }
        else
        {
          v95 &= ~0x400u;
        }
        *(_OWORD *)v62 = *(_OWORD *)&v91.__r_.__value_.__l.__data_;
        *(_DWORD *)__p = 0;
        sub_1000B0C3C((int *)__p);
        v17 = sub_1000B0D38((ssize_t)__p);
        if (!v99)
          sub_10028DF3C();
        v91.__r_.__value_.__r.__words[0] = v17;
        v91.__r_.__value_.__l.__size_ = v18;
        sub_1000B0D18((unsigned int *)__p);
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_102130670);
        v19 = qword_1022A00F8;
        if (!os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
          goto LABEL_93;
        sub_10034C434(a1, v58);
        if ((v58[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v20 = v58;
        else
          v20 = (std::string *)v58[0].__r_.__value_.__r.__words[0];
        if (!v99 || !v98[0])
          sub_10028DF3C();
        if (v97 >= 0)
          v21 = (char *)&v96;
        else
          v21 = (char *)v96;
        v22 = (char *)operator new(0x28uLL);
        *(_QWORD *)(v22 + 29) = 0;
        *(_OWORD *)v22 = 0u;
        *((_OWORD *)v22 + 1) = 0u;
        sub_100261F9C((uint64_t)v62, v22);
        if (!v99)
          sub_10028DF3C();
        v23 = (char *)operator new(0x28uLL);
        *(_QWORD *)(v23 + 29) = 0;
        *(_OWORD *)v23 = 0u;
        *((_OWORD *)v23 + 1) = 0u;
        sub_100261F9C((uint64_t)&v91, v23);
        v24 = &v64;
        if (v65 < 0)
          v24 = v64;
        *(_QWORD *)__p = 68290562;
        *(_WORD *)&__p[8] = 2082;
        *(_QWORD *)&__p[10] = "";
        *(_WORD *)&__p[18] = 2082;
        *(_QWORD *)&__p[20] = "LSL";
        v73 = 2082;
        v74 = v20;
        v75 = 2082;
        v76 = v21;
        v77 = 2082;
        v78 = (std::string *)v22;
        v79 = 2082;
        v80 = v23;
        v81 = 2082;
        v82 = v24;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager::findInstantModelForServiceOfTypeLSL, new LSL service looking for unsupervised model\", \"FoundModelType\":%{public, location:escape_only}s, \"ServiceId\":%{public, location:escape_only}s, \"UsingModelOf\":%{public, location:escape_only}s, \"OriginalLSLModelUUID\":%{public, location:escape_only}s, \"UsedModelUUID\":%{public, location:escape_only}s, \"AtLoi\":%{public, location:escape_only}s}", __p, 0x4Eu);
        operator delete(v23);
        v25 = v22;
        goto LABEL_91;
      }
    }
    else
    {
      sub_10027F418(a2, 0, v70, *((uint64_t *)&v70 + 1), __p);
      sub_100300D1C((uint64_t)&v91, (uint64_t)__p);
      sub_1002708A4((uint64_t)__p);
      if (!v99)
      {
LABEL_93:
        if (SHIBYTE(v65) < 0)
          operator delete(v64);
        sub_100300D1C((uint64_t)&v104, (uint64_t)&v91);
        sub_1002708A4((uint64_t)&v91);
        goto LABEL_96;
      }
      sub_10034C434(a1, (std::string *)__p);
      if (!v99)
        sub_10028DF3C();
      if (v98[0])
      {
        if (SHIBYTE(v97) < 0)
          operator delete((void *)v96);
        v96 = *(_OWORD *)__p;
        v97 = *(_QWORD *)&__p[16];
      }
      else
      {
        v96 = *(_OWORD *)__p;
        v97 = *(_QWORD *)&__p[16];
        v98[0] = 1;
      }
      if (v99)
      {
        v92 = 2;
        if (!sub_10002A324(2u))
          __assert_rtn("set_modeltype", "microlocation.pb.h", 12283, "::CLMicroLocationProto::Model_ModelType_IsValid(value)");
        v95 |= 0x10u;
        v93 = 2;
        if (!v99)
          sub_10028DF3C();
        *(_OWORD *)v62 = *(_OWORD *)&v91.__r_.__value_.__l.__data_;
        *(_DWORD *)__p = 0;
        sub_1000B0C3C((int *)__p);
        v26 = sub_1000B0D38((ssize_t)__p);
        if (!v99)
          sub_10028DF3C();
        v91.__r_.__value_.__r.__words[0] = v26;
        v91.__r_.__value_.__l.__size_ = v27;
        sub_1000B0D18((unsigned int *)__p);
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_102130670);
        v28 = qword_1022A00F8;
        if (!os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
          goto LABEL_93;
        v29 = v58;
        sub_10034C434(a1, v58);
        if ((v58[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v29 = (std::string *)v58[0].__r_.__value_.__r.__words[0];
        v30 = (char *)operator new(0x28uLL);
        *(_QWORD *)(v30 + 29) = 0;
        *(_OWORD *)v30 = 0u;
        *((_OWORD *)v30 + 1) = 0u;
        sub_100261F9C((uint64_t)v62, v30);
        if (!v99)
          sub_10028DF3C();
        v31 = (char *)operator new(0x28uLL);
        *(_QWORD *)(v31 + 29) = 0;
        *(_OWORD *)v31 = 0u;
        *((_OWORD *)v31 + 1) = 0u;
        sub_100261F9C((uint64_t)&v91, v31);
        v32 = (char *)&v64;
        if (v65 < 0)
          v32 = (char *)v64;
        *(_QWORD *)__p = 68290306;
        *(_WORD *)&__p[8] = 2082;
        *(_QWORD *)&__p[10] = "";
        *(_WORD *)&__p[18] = 2082;
        *(_QWORD *)&__p[20] = "unsupervised";
        v73 = 2082;
        v74 = v29;
        v75 = 2082;
        v76 = v30;
        v77 = 2082;
        v78 = (std::string *)v31;
        v79 = 2082;
        v80 = v32;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager::findInstantModelForServiceOfTypeLSL, new LSL service looking for unsupervised model\", \"FoundModelType\":%{public, location:escape_only}s, \"ServiceId\":%{public, location:escape_only}s, \"OriginalUnsupervisedModelUUID\":%{public, location:escape_only}s, \"UsedModelUUID\":%{public, location:escape_only}s, \"AtLoi\":%{public, location:escape_only}s}", __p, 0x44u);
        operator delete(v31);
        v25 = v30;
LABEL_91:
        operator delete(v25);
        if (SHIBYTE(v58[0].__r_.__value_.__r.__words[2]) < 0)
          operator delete(v58[0].__r_.__value_.__l.__data_);
        goto LABEL_93;
      }
    }
    sub_10028DF3C();
  }
  sub_1015A2E04(&v91, "focus-mode");
  sub_10027FD8C(a2, (uint64_t)&v91, a4[1], a4[2], __p);
  sub_100300D1C((uint64_t)&v104, (uint64_t)__p);
  sub_1002708A4((uint64_t)__p);
  if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v91.__r_.__value_.__l.__data_);
  if (!v111)
    goto LABEL_130;
  sub_10034C434(a1, (std::string *)__p);
  if (!v111)
    sub_10028DF3C();
  if (v109)
  {
    if (SHIBYTE(v108.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v108.__r_.__value_.__l.__data_);
    v108 = *(std::string *)__p;
  }
  else
  {
    v108 = *(std::string *)__p;
    v109 = 1;
  }
  if (!v111)
    sub_10028DF3C();
  sub_100300804(__p, &v104);
  memset(&v91, 0, sizeof(v91));
  v64 = &v91;
  LOBYTE(v65) = 0;
  v91.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x118uLL);
  v91.__r_.__value_.__l.__size_ = v91.__r_.__value_.__r.__words[0];
  v91.__r_.__value_.__r.__words[2] = v91.__r_.__value_.__r.__words[0] + 280;
  v91.__r_.__value_.__l.__size_ = (std::string::size_type)sub_100300880((uint64_t)&v91.__r_.__value_.__r.__words[2], (__int128 *)__p, &v86, v91.__r_.__value_.__l.__data_);
  sub_1003002D8(a2);
  v64 = &v91;
  sub_1003009DC((void ***)&v64);
  if (v85[0] && v84 < 0)
    operator delete(v83);
  sub_1002C8104((char *)&v74 + 2);
LABEL_96:
  if (v111)
    goto LABEL_97;
LABEL_130:
  sub_1002ECF2C(&v91);
  v42 = sub_1003471B4(a1);
  HIDWORD(v91.__r_.__value_.__r.__words[0]) = sub_10034AE88(v42, *a4);
  v43 = sub_1003471B4(a1);
  LODWORD(v91.__r_.__value_.__l.__data_) = sub_10034AED0(v43, *a4);
  LODWORD(v70) = 0;
  sub_1000B0C3C((int *)&v70);
  v44 = sub_1000B0D38((ssize_t)&v70);
  v46 = v45;
  sub_1003471A4(a1, &v64);
  v47 = a4[1];
  v48 = a4[2];
  sub_100346E1C(a1, (uint64_t)v58);
  Current = j__CFAbsoluteTimeGetCurrent();
  sub_100340958((uint64_t)__p, (unsigned int *)&v91, v44, v46, (__int128 *)&v64, v47, v48, (__int128 *)v58, Current);
  if (SHIBYTE(v58[0].__r_.__value_.__r.__words[2]) < 0)
    operator delete(v58[0].__r_.__value_.__l.__data_);
  if (SHIBYTE(v65) < 0)
    operator delete(v64);
  sub_1000B0D18((unsigned int *)&v70);
  v59 = 0;
  sub_1000B0C3C(&v59);
  v50 = sub_1000B0D38((ssize_t)&v59);
  v52 = v51;
  v53 = j__CFAbsoluteTimeGetCurrent();
  sub_1002ECF30((uint64_t)__p, (uint64_t)v58);
  sub_1003471A4(a1, v62);
  if (SHIBYTE(v63) < 0)
  {
    sub_100115CE4(__dst, v62[0], (unint64_t)v62[1]);
  }
  else
  {
    *(_OWORD *)__dst = *(_OWORD *)v62;
    v56 = v63;
  }
  v57 = 1;
  sub_1003A828C((uint64_t)&v64, v50, v52, (uint64_t)v58, (uint64_t)__dst, a4[1], a4[2], v53);
  v70 = 0uLL;
  v71 = 0;
  v60 = (void **)&v70;
  v61 = 0;
  *(_QWORD *)&v70 = operator new(0x118uLL);
  *((_QWORD *)&v70 + 1) = v70;
  v71 = v70 + 280;
  *((_QWORD *)&v70 + 1) = sub_100300880((uint64_t)&v71, (__int128 *)&v64, &v70, (_OWORD *)v70);
  sub_1003002D8(a2);
  v60 = (void **)&v70;
  sub_1003009DC(&v60);
  if (v69 && v68 < 0)
    operator delete(v67);
  sub_1002C8104(&v66);
  if (v57 && SHIBYTE(v56) < 0)
    operator delete(__dst[0]);
  if (SHIBYTE(v63) < 0)
    operator delete(v62[0]);
  sub_1002C8104(v58);
  sub_1000B0D18((unsigned int *)&v59);
  sub_10034224C((uint64_t)__p, a5);
  sub_10034105C((uint64_t)__p);
  if (v103 < 0)
    operator delete(v102);
  if (v100)
  {
    v101 = v100;
    operator delete(v100);
  }
  v39 = &v91;
  sub_100270738((uint64_t)v98);
  *(_QWORD *)__p = &v96;
  v40 = (void ***)__p;
LABEL_129:
  sub_1002707B4(v40);
  sub_100270824((uint64_t)&v39[3]);
  sub_100067AC4((uint64_t)&v39->__r_.__value_.__r.__words[2]);
  return sub_1002708A4((uint64_t)&v104);
}

void sub_10033F0DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,void *a46,uint64_t a47,uint64_t a48,uint64_t a49,void *a50,uint64_t a51,int a52,__int16 a53,char a54,char a55)
{
  void *v55;
  void *v56;

  operator delete(v56);
  operator delete(v55);
  if (a20 < 0)
    operator delete(__p);
  if (a55 < 0)
    operator delete(a50);
  sub_1002708A4((uint64_t)&STACK[0x488]);
  sub_1002708A4((uint64_t)&STACK[0x5E8]);
  _Unwind_Resume(a1);
}

_QWORD *sub_10033F42C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  _QWORD *result;
  uint64_t v16;
  _BYTE v17[24];
  _BYTE *v18;
  _QWORD v19[3];
  _QWORD *v20;
  _QWORD v21[3];
  _QWORD *v22;

  v22 = v21;
  v19[0] = off_102130780;
  v19[1] = a2;
  v20 = v19;
  v21[0] = off_1021306F0;
  v5 = *(_QWORD **)(a1 + 16);
  v6 = *(_QWORD **)(a1 + 24);
  if (sub_1003471B4(a2) == 1)
    v7 = v21;
  else
    v7 = v19;
  sub_100270E34((uint64_t)v17, (uint64_t)v7);
  if (v5 != v6)
  {
    while (1)
    {
      if (!v18)
        sub_10025FD1C();
      if (((*(uint64_t (**)(_BYTE *, _QWORD *))(*(_QWORD *)v18 + 48))(v18, v5) & 1) != 0)
        break;
      v5 += 2;
      if (v5 == v6)
      {
        v5 = v6;
        break;
      }
    }
  }
  v8 = v18;
  if (v18 == v17)
  {
    v9 = 4;
    v8 = v17;
  }
  else
  {
    if (!v18)
      goto LABEL_14;
    v9 = 5;
  }
  (*(void (**)(void))(*v8 + 8 * v9))();
LABEL_14:
  if (v5 == *(_QWORD **)(a1 + 24))
  {
    *a3 = 0;
    a3[1] = 0;
  }
  else
  {
    *a3 = *v5;
    v10 = v5[1];
    a3[1] = v10;
    if (v10)
    {
      v11 = (unint64_t *)(v10 + 8);
      do
        v12 = __ldxr(v11);
      while (__stxr(v12 + 1, v11));
    }
  }
  v13 = v20;
  if (v20 == v19)
  {
    v14 = 4;
    v13 = v19;
  }
  else
  {
    if (!v20)
      goto LABEL_25;
    v14 = 5;
  }
  (*(void (**)(void))(*v13 + 8 * v14))();
LABEL_25:
  result = v22;
  if (v22 == v21)
  {
    v16 = 4;
    result = v21;
  }
  else
  {
    if (!v22)
      return result;
    v16 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v16))();
}

void sub_10033F5DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, char *a19, char a20,uint64_t a21,uint64_t a22,char *a23)
{
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;

  v24 = a19;
  if (a19 == &a16)
  {
    v25 = 4;
    v24 = &a16;
  }
  else
  {
    if (!a19)
      goto LABEL_6;
    v25 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v24 + 8 * v25))();
LABEL_6:
  v26 = a23;
  if (a23 == &a20)
  {
    v27 = 4;
    v26 = &a20;
  }
  else
  {
    if (!a23)
      goto LABEL_11;
    v27 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v26 + 8 * v27))();
LABEL_11:
  sub_100261F44((uint64_t)&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_10033F68C(char **a1, __int128 *a2)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  char *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  __int128 v19;
  unint64_t *v20;
  unint64_t v21;
  char *v22;
  char *v23;
  char *v24;
  __int128 v25;
  int64x2_t v26;
  char *v27;
  uint64_t v28;
  int64x2_t v29;
  char *v30;
  uint64_t v31;

  v6 = (unint64_t)a1[2];
  result = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(result - 8);
  if ((unint64_t)v7 >= v6)
  {
    v12 = (v7 - *a1) >> 4;
    v13 = v12 + 1;
    if ((unint64_t)(v12 + 1) >> 60)
      sub_100259694();
    v14 = v5 - (_QWORD)*a1;
    if (v14 >> 3 > v13)
      v13 = v14 >> 3;
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0)
      v15 = 0xFFFFFFFFFFFFFFFLL;
    else
      v15 = v13;
    v31 = result;
    v16 = (char *)sub_10028E224(result, v15);
    v18 = &v16[16 * v12];
    v19 = *a2;
    *(_OWORD *)v18 = *a2;
    if (*((_QWORD *)&v19 + 1))
    {
      v20 = (unint64_t *)(*((_QWORD *)&v19 + 1) + 8);
      do
        v21 = __ldxr(v20);
      while (__stxr(v21 + 1, v20));
    }
    v23 = *a1;
    v22 = a1[1];
    if (v22 == *a1)
    {
      v26 = vdupq_n_s64((unint64_t)v22);
      v24 = &v16[16 * v12];
    }
    else
    {
      v24 = &v16[16 * v12];
      do
      {
        v25 = *((_OWORD *)v22 - 1);
        v22 -= 16;
        *((_OWORD *)v24 - 1) = v25;
        v24 -= 16;
        *(_QWORD *)v22 = 0;
        *((_QWORD *)v22 + 1) = 0;
      }
      while (v22 != v23);
      v26 = *(int64x2_t *)a1;
    }
    v11 = v18 + 16;
    *a1 = v24;
    a1[1] = v18 + 16;
    v29 = v26;
    v27 = a1[2];
    a1[2] = &v16[16 * v17];
    v30 = v27;
    v28 = v26.i64[0];
    result = sub_100014F20((uint64_t)&v28);
  }
  else
  {
    *(_QWORD *)v7 = *(_QWORD *)a2;
    v8 = *((_QWORD *)a2 + 1);
    *((_QWORD *)v7 + 1) = v8;
    if (v8)
    {
      v9 = (unint64_t *)(v8 + 8);
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
    v11 = v7 + 16;
  }
  a1[1] = v11;
  return result;
}

void sub_10033F7CC(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = a1 + 40;
  v3 = *(_QWORD *)(a1 + 48);
  if (v3 != a1 + 40)
  {
    do
    {
      sub_10034C490((_QWORD *)(v3 + 16), a2);
      v3 = *(_QWORD *)(v3 + 8);
    }
    while (v3 != v2);
  }
}

uint64_t sub_10033F818(uint64_t a1, uint64_t a2, uint64_t *a3, __int128 *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v10;
  char v11;

  v6 = *(_QWORD *)(a1 + 144);
  v7 = *a3;
  v8 = a3[1];
  v10 = *a4;
  v11 = *((_BYTE *)a4 + 16);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, __int128 *, uint64_t, uint64_t))(*(_QWORD *)(v6 + 8) + 24))(v6 + 8, a2, v7, v8, &v10, a5, a6);
}

uint64_t sub_10033F894(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  __int128 v9;

  *(_QWORD *)&v9 = a2;
  v9 = *((_OWORD *)sub_100273930(a1 + 64, a2, (uint64_t)&unk_101B9EB60, (_OWORD **)&v9) + 2);
  return (*(uint64_t (**)(_QWORD, _QWORD *, uint64_t, uint64_t, __int128 *))(**(_QWORD **)(a1 + 144) + 40))(*(_QWORD *)(a1 + 144), a2, a3, a4, &v9);
}

uint64_t sub_10033F93C(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  __int128 v9;

  *(_QWORD *)&v9 = a2;
  v9 = *((_OWORD *)sub_100273930(a1 + 64, a2, (uint64_t)&unk_101B9EB60, (_OWORD **)&v9) + 2);
  return (*(uint64_t (**)(_QWORD, _QWORD *, uint64_t, uint64_t, __int128 *))(**(_QWORD **)(a1 + 144) + 24))(*(_QWORD *)(a1 + 144), a2, a3, a4, &v9);
}

uint64_t sub_10033F9E4(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  __int128 v9;

  *(_QWORD *)&v9 = a2;
  v9 = *((_OWORD *)sub_100273930(a1 + 64, a2, (uint64_t)&unk_101B9EB60, (_OWORD **)&v9) + 2);
  return (*(uint64_t (**)(_QWORD, _QWORD *, uint64_t, uint64_t, __int128 *))(**(_QWORD **)(a1 + 144) + 32))(*(_QWORD *)(a1 + 144), a2, a3, a4, &v9);
}

uint64_t sub_10033FA8C(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  __int128 v8;

  *(_QWORD *)&v8 = a2;
  v8 = *((_OWORD *)sub_100273930(a1 + 64, a2, (uint64_t)&unk_101B9EB60, (_OWORD **)&v8) + 2);
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, __int128 *))(**(_QWORD **)(a1 + 144) + 48))(*(_QWORD *)(a1 + 144), a3, a4, &v8);
}

uint64_t sub_10033FB2C(uint64_t a1, uint64_t a2, uint64_t *a3, __int128 *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v9;
  char v10;

  v5 = *(_QWORD *)(a1 + 144);
  v6 = *a3;
  v7 = a3[1];
  v10 = *((_BYTE *)a4 + 16);
  v9 = *a4;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, __int128 *, uint64_t))(*(_QWORD *)(v5 + 8) + 16))(v5 + 8, a2, v6, v7, &v9, a5);
}

uint64_t sub_10033FBA4(uint64_t a1, uint64_t a2)
{
  __int128 v5;

  *(_QWORD *)&v5 = a2 + 32;
  v5 = *((_OWORD *)sub_100273930(a1 + 64, (_QWORD *)(a2 + 32), (uint64_t)&unk_101B9EB60, (_OWORD **)&v5) + 2);
  return (*(uint64_t (**)(_QWORD, uint64_t, __int128 *))(**(_QWORD **)(a1 + 144) + 16))(*(_QWORD *)(a1 + 144), a2, &v5);
}

uint64_t sub_10033FC38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _OWORD *a5)
{
  uint64_t v6;
  uint64_t v7;
  NSObject *v9;
  char *v10;
  char *v11;
  _QWORD *v12;
  char v13;
  _DWORD v15[2];
  __int16 v16;
  const char *v17;
  __int16 v18;
  char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;

  v6 = a4;
  v7 = a3;
  v22 = a3;
  v23 = a4;
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130670);
  v9 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    v10 = (char *)operator new(0x28uLL);
    *(_OWORD *)v10 = 0u;
    *((_OWORD *)v10 + 1) = 0u;
    *(_QWORD *)(v10 + 29) = 0;
    sub_100261F9C((uint64_t)&v22, v10);
    v11 = (char *)operator new(0x28uLL);
    *(_QWORD *)(v11 + 29) = 0;
    *(_OWORD *)v11 = 0u;
    *((_OWORD *)v11 + 1) = 0u;
    sub_100261F9C((uint64_t)a5, v11);
    v15[0] = 68289538;
    v15[1] = 0;
    v16 = 2082;
    v17 = "";
    v18 = 2082;
    v19 = v10;
    v20 = 2082;
    v21 = v11;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager::requestMicroLocationLearning\", \"serviceId\":%{public, location:escape_only}s, \"requestId\":%{public, location:escape_only}s}", (uint8_t *)v15, 0x26u);
    operator delete(v11);
    operator delete(v10);
    v7 = v22;
    v6 = v23;
  }
  v12 = (_QWORD *)sub_10033B764(a1, v7, v6);
  if (v13)
    return sub_10034E77C(v12, a5);
  else
    return 0;
}

void sub_10033FDC4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  operator delete(v2);
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_10033FDF4(_QWORD *a1)
{
  _QWORD *i;

  sub_10033DB70(a1);
  for (i = (_QWORD *)a1[6]; i != a1 + 5; i = (_QWORD *)i[1])
  {
    sub_10033CBCC((uint64_t)a1, (uint64_t)(i + 2));
    sub_10034E970((uint64_t)(i + 2));
  }
}

void sub_10033FE4C(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  _OWORD *v3;
  uint64_t v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *__p;
  void *v10;

  v1 = a1 + 40;
  v2 = *(_QWORD *)(a1 + 48);
  if (v2 != a1 + 40)
  {
    v3 = (_OWORD *)(a1 + 112);
    do
    {
      sub_10034C5F4(v2 + 16, v3, &v4);
      if (__p)
      {
        v10 = __p;
        operator delete(__p);
      }
      if (v7)
      {
        v8 = v7;
        operator delete(v7);
      }
      if (v5)
      {
        v6 = v5;
        operator delete(v5);
      }
      v2 = *(_QWORD *)(v2 + 8);
    }
    while (v2 != v1);
  }
}

void sub_10033FF04(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;

  v3 = a1 + 40;
  v4 = *(_QWORD *)(a1 + 48);
  if (v4 != a1 + 40)
  {
    do
    {
      sub_10034EB00((uint64_t *)(v4 + 16), a2, a3);
      v4 = *(_QWORD *)(v4 + 8);
    }
    while (v4 != v3);
  }
}

uint64_t sub_10033FF58(uint64_t a1, char a2, char a3)
{
  uint64_t v4;
  uint64_t v5;

  *(_BYTE *)(a1 + 8) = a2;
  *(_BYTE *)(a1 + 9) = a3;
  v4 = a1 + 40;
  v5 = *(_QWORD *)(a1 + 48);
  if (v5 != a1 + 40)
  {
    do
    {
      sub_10034E778(v5 + 16);
      sub_10034D4D4((_QWORD *)(v5 + 16), (_OWORD *)(a1 + 112));
      v5 = *(_QWORD *)(v5 + 8);
    }
    while (v5 != v4);
  }
  return sub_10033CFE0(a1);
}

uint64_t sub_10033FFC8(uint64_t a1)
{
  NSObject *v2;
  _DWORD v4[2];
  __int16 v5;
  const char *v6;

  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130670);
  v2 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    v4[0] = 68289026;
    v4[1] = 0;
    v5 = 2082;
    v6 = "";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager::triggerLearning\"}", (uint8_t *)v4, 0x12u);
  }
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 8) + 40))(*(_QWORD *)(a1 + 144) + 8);
}

void sub_1003400B0(uint64_t a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  sub_1002B8A4C(*(_QWORD *)(a1 + 104), a2, a3);
}

uint64_t sub_1003400B8(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 8) + 72))(*(_QWORD *)(a1 + 144) + 8);
}

uint64_t sub_1003400C8(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 8) + 80))(*(_QWORD *)(a1 + 144) + 8);
}

void sub_1003400D8(uint64_t a1@<X0>, uint64_t a2@<X1>, const void **a3@<X2>, _QWORD *a4@<X8>, double a5@<D0>)
{
  sub_1002B93F4(*(_QWORD *)(a1 + 104), a2, a3, a1 + 112, a4, a5);
}

void sub_1003400E8(uint64_t a1@<X0>, _QWORD *a2@<X1>, _BYTE *a3@<X8>)
{
  sub_100282D7C(*(_QWORD *)(a1 + 104), a2, a3);
}

uint64_t sub_1003400F0(_QWORD *a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v8;
  NSObject *v10;
  char *v11;
  unint64_t v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  _BYTE v19[32];
  uint64_t v20[4];

  v20[0] = a2;
  v20[1] = a3;
  v4 = a1 + 5;
  v5 = (_QWORD *)a1[6];
  *(_QWORD *)v19 = a2;
  *(_QWORD *)&v19[8] = a3;
  if (v5 == a1 + 5)
    goto LABEL_7;
  while (*(_QWORD *)v19 != sub_100347144((uint64_t)(v5 + 2)) || *(_QWORD *)&v19[8] != v8)
  {
    v5 = (_QWORD *)v5[1];
    if (v5 == v4)
      goto LABEL_7;
  }
  if (v5 == v4)
LABEL_7:
    sub_1018F4A94();
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130670);
  v10 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
  {
    v11 = (char *)operator new(0x28uLL);
    *(_OWORD *)v11 = 0u;
    *((_OWORD *)v11 + 1) = 0u;
    *(_QWORD *)(v11 + 29) = 0;
    sub_100261F9C((uint64_t)v20, v11);
    *(_QWORD *)v19 = 68289282;
    *(_WORD *)&v19[8] = 2082;
    *(_QWORD *)&v19[10] = "";
    *(_WORD *)&v19[18] = 2082;
    *(_QWORD *)&v19[20] = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"enableMiLoAtCurrentLocation for service\", \"serviceId\":%{public, location:escape_only}s}", v19, 0x1Cu);
    operator delete(v11);
  }
  *(_OWORD *)v19 = *a4;
  *(_OWORD *)&v19[16] = *(_OWORD *)v20;
  sub_100342CF4(a1 + 24, (uint64_t)v19);
  v12 = sub_10033B764((uint64_t)a1, v20[0], v20[1]);
  if (v13)
  {
    v14 = v12;
    if ((sub_1003471C4(v12, 2uLL) & 1) == 0)
    {
      sub_1003471F4(v14, 2uLL);
      v15 = a1[13];
      v16 = *(_OWORD *)v20;
      v17 = sub_1003471BC(v14);
      sub_100285CE0(v15, v16, *((uint64_t *)&v16 + 1), v17);
    }
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)(a1[18] + 8) + 88))(a1[18] + 8, v20);
}

void sub_1003402DC(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1003402F8(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  _BOOL4 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  _OWORD *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  _OWORD *v16;
  void *p_p;
  uint64_t *v18;
  char v19;
  void *__p;
  __int128 v21;
  void *v22;
  __int128 v23;
  uint8_t buf[8];
  __int16 v25;
  const char *v26;
  __int16 v27;
  _BYTE v28[10];
  void *v29;
  __int128 v30;

  if (*(_QWORD *)(a1 + 232))
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130670);
    v4 = qword_1022A00F8;
    v5 = os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT);
    v6 = *(_QWORD *)(a1 + 232);
    if (v5)
    {
      *(_DWORD *)buf = 68289538;
      *(_DWORD *)&buf[4] = 0;
      v25 = 2082;
      v26 = "";
      v27 = 1026;
      *(_DWORD *)v28 = v6 != 0;
      *(_WORD *)&v28[4] = 1026;
      *(_DWORD *)&v28[6] = a2 == -1;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager releasing create custom LOI at current location requests: \", \"NumRequests\":%{public}hhd, \"Success\":%{public}hhd}", buf, 0x1Eu);
      v6 = *(_QWORD *)(a1 + 232);
    }
    if (v6)
    {
      v7 = a1 + 192;
      do
      {
        v8 = *(_QWORD *)(*(_QWORD *)(a1 + 200) + ((*(_QWORD *)(a1 + 224) >> 4) & 0xFFFFFFFFFFFFFF8));
        v9 = *(_QWORD *)(a1 + 224) & 0x7FLL;
        v10 = v8 + 32 * v9;
        *(_QWORD *)buf = v10 + 16;
        v30 = *((_OWORD *)sub_100273930(a1 + 64, (_QWORD *)(v10 + 16), (uint64_t)&unk_101B9EB60, (_OWORD **)buf) + 2);
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_102130670);
        v11 = qword_1022A00F8;
        if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
        {
          v12 = operator new(0x28uLL);
          v13 = v7;
          v14 = a2;
          v22 = v12;
          v23 = xmmword_101B97FF0;
          *v12 = 0u;
          v12[1] = 0u;
          *(_QWORD *)((char *)v12 + 29) = 0;
          sub_100261F9C(v10 + 16, v12);
          if (v23 >= 0)
            v15 = &v22;
          else
            v15 = v22;
          v16 = operator new(0x28uLL);
          __p = v16;
          v21 = xmmword_101B97FF0;
          *v16 = 0u;
          v16[1] = 0u;
          *(_QWORD *)((char *)v16 + 29) = 0;
          sub_100261F9C(v10, v16);
          p_p = &__p;
          if (v21 < 0)
            p_p = __p;
          *(_DWORD *)buf = 68289538;
          *(_DWORD *)&buf[4] = 0;
          v25 = 2082;
          v26 = "";
          v27 = 2082;
          *(_QWORD *)v28 = v15;
          *(_WORD *)&v28[8] = 2082;
          v29 = p_p;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"enableMiLoAtCurrentLocation completed for service\", \"serviceId\":%{public, location:escape_only}s, \"requestId\":%{public, location:escape_only}s}", buf, 0x26u);
          if (SHIBYTE(v21) < 0)
            operator delete(__p);
          a2 = v14;
          if (SHIBYTE(v23) < 0)
            operator delete(v22);
          v7 = v13;
        }
        v18 = (uint64_t *)sub_10033B764(a1, *(_QWORD *)(v10 + 16), *(_QWORD *)(v8 + 32 * v9 + 24));
        if (v19)
          sub_100348CEC(v18);
        (*(void (**)(_QWORD, uint64_t, uint64_t, __int128 *))(**(_QWORD **)(a1 + 144) + 56))(*(_QWORD *)(a1 + 144), a2, v10, &v30);
        *(int64x2_t *)(a1 + 224) = vaddq_s64(*(int64x2_t *)(a1 + 224), (int64x2_t)xmmword_101B9DFC0);
        sub_1003432C8(v7, 1);
      }
      while (*(_QWORD *)(a1 + 232));
    }
  }
}

void sub_10034065C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  void *v25;

  operator delete(v25);
  if (a25 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

_QWORD *sub_10034069C(_QWORD *a1)
{
  void **v2;
  void **v4;

  *a1 = off_1021305A8;
  v2 = (void **)(a1 + 2);
  sub_10034111C(a1 + 24);
  sub_100300C78((uint64_t)(a1 + 19));
  sub_100067AC4((uint64_t)(a1 + 8));
  sub_1003411B0(a1 + 5);
  v4 = v2;
  sub_1002A3684(&v4);
  return a1;
}

void sub_100340700(_QWORD *a1)
{
  void **v2;
  void **v3;

  *a1 = off_1021305A8;
  v2 = (void **)(a1 + 2);
  sub_10034111C(a1 + 24);
  sub_100300C78((uint64_t)(a1 + 19));
  sub_100067AC4((uint64_t)(a1 + 8));
  sub_1003411B0(a1 + 5);
  v3 = v2;
  sub_1002A3684(&v3);
  operator delete();
}

void sub_100340778(id a1)
{
  qword_1022A00F8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

uint64_t sub_1003407A4(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 88))
  {
    if (*(char *)(a1 + 87) < 0)
      operator delete(*(void **)(a1 + 64));
    if (*(char *)(a1 + 55) < 0)
      operator delete(*(void **)(a1 + 32));
  }
  return a1;
}

uint64_t sub_1003407EC(_QWORD *a1)
{
  void **v2;
  void **v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  void *v7;

  v2 = (void **)a1[1];
  v3 = (void **)a1[2];
  a1[5] = 0;
  v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v3 = (void **)a1[2];
      v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  v5 = v4 >> 3;
  if (v5 == 1)
  {
    v6 = 62;
  }
  else
  {
    if (v5 != 2)
      goto LABEL_9;
    v6 = 124;
  }
  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    v7 = *v2++;
    operator delete(v7);
  }
  return sub_10002E778((uint64_t)a1);
}

uint64_t sub_100340880(uint64_t a1)
{
  void *v2;
  void *v3;

  if (*(_BYTE *)(a1 + 184))
  {
    v2 = *(void **)(a1 + 144);
    if (v2)
    {
      *(_QWORD *)(a1 + 152) = v2;
      operator delete(v2);
    }
    if (*(_BYTE *)(a1 + 128))
      sub_1002A1C94(a1 + 88);
    if (*(_BYTE *)(a1 + 80) && *(char *)(a1 + 79) < 0)
      operator delete(*(void **)(a1 + 56));
    v3 = *(void **)a1;
    if (*(_QWORD *)a1)
    {
      *(_QWORD *)(a1 + 8) = v3;
      operator delete(v3);
    }
  }
  return a1;
}

std::string *sub_1003408F0(std::string *__dst, const std::string *a2)
{
  __int128 v3;

  if (__dst[1].__r_.__value_.__s.__data_[0])
  {
    std::string::operator=(__dst, a2);
  }
  else
  {
    if (SHIBYTE(a2->__r_.__value_.__r.__words[2]) < 0)
    {
      sub_100115CE4(__dst, a2->__r_.__value_.__l.__data_, a2->__r_.__value_.__l.__size_);
    }
    else
    {
      v3 = *(_OWORD *)&a2->__r_.__value_.__l.__data_;
      __dst->__r_.__value_.__r.__words[2] = a2->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__dst->__r_.__value_.__l.__data_ = v3;
    }
    __dst[1].__r_.__value_.__s.__data_[0] = 1;
  }
  return __dst;
}

uint64_t sub_100340958(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, __int128 *a5, uint64_t a6, uint64_t a7, __int128 *a8, double a9)
{
  uint64_t v18;
  __int128 v19;
  _BYTE *v20;
  __int128 v21;

  v18 = sub_100340A84(a1, (uint64_t)a2);
  *(_QWORD *)(v18 + 352) = a3;
  *(_QWORD *)(v18 + 360) = a4;
  if (*((char *)a5 + 23) < 0)
  {
    sub_100115CE4((_BYTE *)(v18 + 368), *(void **)a5, *((_QWORD *)a5 + 1));
  }
  else
  {
    v19 = *a5;
    *(_QWORD *)(v18 + 384) = *((_QWORD *)a5 + 2);
    *(_OWORD *)(v18 + 368) = v19;
  }
  *(_BYTE *)(a1 + 392) = 1;
  *(_QWORD *)(a1 + 400) = a6;
  *(_QWORD *)(a1 + 408) = a7;
  sub_100263270(a1 + 416, (unsigned __int8 *)a8, *a2);
  v20 = (_BYTE *)(a1 + 464);
  if (*((char *)a8 + 23) < 0)
  {
    sub_100115CE4(v20, *(void **)a8, *((_QWORD *)a8 + 1));
  }
  else
  {
    v21 = *a8;
    *(_QWORD *)(a1 + 480) = *((_QWORD *)a8 + 2);
    *(_OWORD *)v20 = v21;
  }
  *(double *)(a1 + 488) = a9;
  *(_BYTE *)(a1 + 496) = 0;
  *(_BYTE *)(a1 + 536) = 0;
  return a1;
}

void sub_100340A40(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  uint64_t v3;

  sub_100261EE4(v3);
  if (*(_BYTE *)(v1 + 392))
  {
    if (*(char *)(v1 + 391) < 0)
      operator delete(*v2);
  }
  sub_10026E1B8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100340A84(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  __int128 v5;
  _BYTE *v6;
  __int128 v7;

  *(_OWORD *)a1 = *(_OWORD *)a2;
  sub_1002708EC(a1 + 16, a2 + 16);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  sub_100340BE4((_BYTE *)(a1 + 72), a2 + 72);
  v4 = *(_OWORD *)(a2 + 200);
  v5 = *(_OWORD *)(a2 + 212);
  *(_QWORD *)(a1 + 232) = 0;
  *(_OWORD *)(a1 + 212) = v5;
  *(_OWORD *)(a1 + 200) = v4;
  *(_QWORD *)(a1 + 240) = 0;
  *(_QWORD *)(a1 + 248) = 0;
  sub_100340C38((char *)(a1 + 232), *(_QWORD *)(a2 + 232), *(_QWORD *)(a2 + 240), (uint64_t)(*(_QWORD *)(a2 + 240) - *(_QWORD *)(a2 + 232)) >> 5);
  sub_100340CE0(a1 + 256, a2 + 256);
  *(_QWORD *)(a1 + 296) = *(_QWORD *)(a2 + 296);
  *(_QWORD *)(a1 + 304) = 0;
  *(_QWORD *)(a1 + 312) = 0;
  *(_QWORD *)(a1 + 320) = 0;
  sub_10027205C((_QWORD *)(a1 + 304), *(const void **)(a2 + 304), *(_QWORD *)(a2 + 312), (uint64_t)(*(_QWORD *)(a2 + 312) - *(_QWORD *)(a2 + 304)) >> 2);
  v6 = (_BYTE *)(a1 + 328);
  if (*(char *)(a2 + 351) < 0)
  {
    sub_100115CE4(v6, *(void **)(a2 + 328), *(_QWORD *)(a2 + 336));
  }
  else
  {
    v7 = *(_OWORD *)(a2 + 328);
    *(_QWORD *)(a1 + 344) = *(_QWORD *)(a2 + 344);
    *(_OWORD *)v6 = v7;
  }
  return a1;
}

void sub_100340B84(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void **v6;
  void *v8;
  va_list va;

  va_start(va, a2);
  v8 = *v6;
  if (*v6)
  {
    *(_QWORD *)(v4 + 312) = v8;
    operator delete(v8);
  }
  sub_100270738(v5);
  sub_1002707B4((void ***)va);
  sub_100270824(v3);
  sub_100067AC4(v2);
  _Unwind_Resume(a1);
}

_BYTE *sub_100340BE4(_BYTE *a1, uint64_t a2)
{
  *a1 = 0;
  a1[120] = 0;
  if (*(_BYTE *)(a2 + 120))
  {
    sub_1002F36BC((uint64_t)a1, a2);
    a1[120] = 1;
  }
  return a1;
}

void sub_100340C24(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_100270824(v1);
  _Unwind_Resume(a1);
}

char *sub_100340C38(char *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  char *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  if (a4)
  {
    v6 = result;
    result = sub_1002A23D0(result, a4);
    v7 = *((_QWORD *)v6 + 1);
    while (a2 != a3)
    {
      *(_QWORD *)v7 = *(_QWORD *)a2;
      v8 = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(v7 + 8) = v8;
      if (v8)
      {
        v9 = (unint64_t *)(v8 + 8);
        do
          v10 = __ldxr(v9);
        while (__stxr(v10 + 1, v9));
      }
      *(_OWORD *)(v7 + 16) = *(_OWORD *)(a2 + 16);
      a2 += 32;
      v7 += 32;
    }
    *((_QWORD *)v6 + 1) = v7;
  }
  return result;
}

void sub_100340CCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  sub_1002707B4(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100340CE0(uint64_t a1, uint64_t a2)
{
  _QWORD *i;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  sub_10012E444(a1, *(_QWORD *)(a2 + 8));
  for (i = *(_QWORD **)(a2 + 16); i; i = (_QWORD *)*i)
    sub_100340D54(a1, i + 2, (uint64_t)(i + 2));
  return a1;
}

void sub_100340D3C(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_100270738(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_100340D54(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  _QWORD *v9;
  _QWORD *result;
  unint64_t v11;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  _QWORD *v19;
  unint64_t v20;
  _QWORD *v21;

  v5 = 0;
  v6 = 0;
  do
    v6 ^= (v6 << 6) + (v6 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + v5++);
  while (v5 != 16);
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = v6;
      if (v6 >= v7)
        v3 = v6 % v7;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
    v9 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      result = (_QWORD *)*v9;
      if (*v9)
      {
        do
        {
          v11 = result[1];
          if (v11 == v6)
          {
            if (result[2] == *a2 && result[3] == a2[1])
              return result;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          result = (_QWORD *)*result;
        }
        while (result);
      }
    }
  }
  sub_100340FC0(a1, v6, a3, (uint64_t)&v21);
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    v15 = 1;
    if (v7 >= 3)
      v15 = (v7 & (v7 - 1)) != 0;
    v16 = v15 | (2 * v7);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      v18 = v17;
    else
      v18 = v16;
    sub_10012E444(a1, v18);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v6 >= v7)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
  }
  v19 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v19)
  {
    *v21 = *v19;
    *v19 = v21;
  }
  else
  {
    *v21 = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v21;
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = a1 + 16;
    if (*v21)
    {
      v20 = *(_QWORD *)(*v21 + 8);
      if ((v7 & (v7 - 1)) != 0)
      {
        if (v20 >= v7)
          v20 %= v7;
      }
      else
      {
        v20 &= v7 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v20) = v21;
    }
  }
  result = v21;
  ++*(_QWORD *)(a1 + 24);
  return result;
}

void sub_100340F9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _QWORD *__p, uint64_t a11)
{
  if (__p)
    sub_1002F3AAC((uint64_t)&a11, __p);
  _Unwind_Resume(exception_object);
}

_QWORD *sub_100340FC0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  _QWORD *v8;
  _QWORD *result;

  v7 = a1 + 16;
  v8 = operator new(0x38uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *v8 = 0;
  v8[1] = a2;
  *((_OWORD *)v8 + 1) = *(_OWORD *)a3;
  v8[5] = 0;
  v8[6] = 0;
  v8[4] = 0;
  result = sub_1002AE804(v8 + 4, *(const void **)(a3 + 16), *(_QWORD *)(a3 + 24), (uint64_t)(*(_QWORD *)(a3 + 24) - *(_QWORD *)(a3 + 16)) >> 4);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_100341040(_Unwind_Exception *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;

  *v1 = 0;
  sub_1002F3AAC(v3, v2);
  _Unwind_Resume(a1);
}

uint64_t sub_10034105C(uint64_t a1)
{
  void *v2;
  void **v4;

  if (*(_BYTE *)(a1 + 536))
    sub_100300B8C(a1 + 496);
  if (*(char *)(a1 + 487) < 0)
    operator delete(*(void **)(a1 + 464));
  sub_10011A56C((_QWORD *)(a1 + 440));
  sub_100008848(a1 + 416, *(_QWORD **)(a1 + 424));
  if (*(_BYTE *)(a1 + 392) && *(char *)(a1 + 391) < 0)
    operator delete(*(void **)(a1 + 368));
  if (*(char *)(a1 + 351) < 0)
    operator delete(*(void **)(a1 + 328));
  v2 = *(void **)(a1 + 304);
  if (v2)
  {
    *(_QWORD *)(a1 + 312) = v2;
    operator delete(v2);
  }
  sub_100270738(a1 + 256);
  v4 = (void **)(a1 + 232);
  sub_1002707B4(&v4);
  sub_100270824(a1 + 72);
  sub_100067AC4(a1 + 16);
  return a1;
}

uint64_t sub_10034111C(_QWORD *a1)
{
  void **v2;
  void **v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  void *v7;

  v2 = (void **)a1[1];
  v3 = (void **)a1[2];
  a1[5] = 0;
  v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v3 = (void **)a1[2];
      v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  v5 = v4 >> 3;
  if (v5 == 1)
  {
    v6 = 64;
  }
  else
  {
    if (v5 != 2)
      goto LABEL_9;
    v6 = 128;
  }
  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    v7 = *v2++;
    operator delete(v7);
  }
  return sub_10002E778((uint64_t)a1);
}

void sub_1003411B0(uint64_t *a1)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t *v5;

  if (a1[2])
  {
    v2 = *a1;
    v3 = (uint64_t *)a1[1];
    v4 = *v3;
    *(_QWORD *)(v4 + 8) = *(_QWORD *)(*a1 + 8);
    **(_QWORD **)(v2 + 8) = v4;
    a1[2] = 0;
    if (v3 != a1)
    {
      do
      {
        v5 = (uint64_t *)v3[1];
        sub_100341220((uint64_t)(v3 + 2));
        operator delete(v3);
        v3 = v5;
      }
      while (v5 != a1);
    }
  }
}

void sub_100341220(uint64_t a1)
{
  sub_1003407EC((_QWORD *)(a1 + 376));
  sub_1003407EC((_QWORD *)(a1 + 304));
  sub_100340880(a1 + 112);
  sub_100261F44(a1 + 96);
  if (*(char *)(a1 + 87) < 0)
    operator delete(*(void **)(a1 + 64));
  if (*(char *)(a1 + 63) < 0)
    operator delete(*(void **)(a1 + 40));
}

void ***sub_100341284(void ***a1, _OWORD *a2)
{
  void **v4;
  _OWORD *v5;
  void **v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  __int128 v10;
  _OWORD *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  __int128 v19;
  char *v20;
  char *v21;
  __int128 v22;

  v4 = *a1;
  v5 = (*a1)[1];
  v6 = *a1;
  v9 = (unint64_t)v6[2];
  v7 = (uint64_t)(v6 + 2);
  v8 = v9;
  if ((unint64_t)v5 >= v9)
  {
    v12 = ((char *)v5 - (_BYTE *)*v4) >> 5;
    v13 = v12 + 1;
    if ((unint64_t)(v12 + 1) >> 59)
      sub_100259694();
    v14 = v8 - (_QWORD)*v4;
    if (v14 >> 4 > v13)
      v13 = v14 >> 4;
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFE0)
      v15 = 0x7FFFFFFFFFFFFFFLL;
    else
      v15 = v13;
    if (v15)
      v16 = (char *)sub_10025BA00(v7, v15);
    else
      v16 = 0;
    v17 = &v16[32 * v12];
    v18 = &v16[32 * v15];
    v19 = a2[1];
    *(_OWORD *)v17 = *a2;
    *((_OWORD *)v17 + 1) = v19;
    v11 = v17 + 32;
    v21 = (char *)*v4;
    v20 = (char *)v4[1];
    if (v20 != *v4)
    {
      do
      {
        v22 = *((_OWORD *)v20 - 1);
        *((_OWORD *)v17 - 2) = *((_OWORD *)v20 - 2);
        *((_OWORD *)v17 - 1) = v22;
        v17 -= 32;
        v20 -= 32;
      }
      while (v20 != v21);
      v20 = (char *)*v4;
    }
    *v4 = v17;
    v4[1] = v11;
    v4[2] = v18;
    if (v20)
      operator delete(v20);
  }
  else
  {
    v10 = a2[1];
    *v5 = *a2;
    v5[1] = v10;
    v11 = v5 + 2;
  }
  v4[1] = v11;
  return a1;
}

uint64_t sub_100341378(_QWORD *a1, unsigned int a2, uint64_t a3, unsigned int a4, _QWORD *a5)
{
  int64_t v5;
  unint64_t v6;
  uint64_t v7;
  BOOL v8;

  v5 = a4 - (unint64_t)a2 + 8 * (a3 - (_QWORD)a1);
  if (v5 >= 1)
  {
    if (a2)
    {
      if (v5 >= (unint64_t)(64 - a2))
        v6 = 64 - a2;
      else
        v6 = a4 - (unint64_t)a2 + 8 * (a3 - (_QWORD)a1);
      if (((0xFFFFFFFFFFFFFFFFLL >> (64 - a2 - v6)) & (-1 << a2) & (*a1 ^ *a5)) != 0)
        return 0;
      v5 -= v6;
      ++a5;
      ++a1;
    }
    if (v5 >= 64)
    {
      while (*a5 == *a1)
      {
        v7 = v5 - 64;
        ++a1;
        ++a5;
        v8 = v5 <= 127;
        v5 -= 64;
        if (v8)
          goto LABEL_14;
      }
      return 0;
    }
    v7 = v5;
LABEL_14:
    if (v7 >= 1 && (*a1 ^ *a5) << -(char)v7)
      return 0;
  }
  return 1;
}

uint64_t sub_100341444(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v6;
  _QWORD v9[3];
  char v10;
  uint64_t v11;
  uint64_t v12;

  v4 = a4;
  v11 = a4;
  v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  v10 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      sub_1003414EC(a1, v4, v6);
      v6 += 88;
      v4 = v12 + 88;
      v12 += 88;
    }
    while (v6 != a3);
  }
  v10 = 1;
  sub_10034159C((uint64_t)v9);
  return v4;
}

void sub_1003414D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_10034159C((uint64_t)&a9);
  _Unwind_Resume(a1);
}

_BYTE *sub_1003414EC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 v5;
  _BYTE *v6;
  __int128 v7;
  _BYTE *result;
  __int128 v9;

  v5 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v5;
  v6 = (_BYTE *)(a2 + 32);
  if (*(char *)(a3 + 55) < 0)
  {
    sub_100115CE4(v6, *(void **)(a3 + 32), *(_QWORD *)(a3 + 40));
  }
  else
  {
    v7 = *(_OWORD *)(a3 + 32);
    *(_QWORD *)(a2 + 48) = *(_QWORD *)(a3 + 48);
    *(_OWORD *)v6 = v7;
  }
  *(_QWORD *)(a2 + 56) = *(_QWORD *)(a3 + 56);
  result = (_BYTE *)(a2 + 64);
  if (*(char *)(a3 + 87) < 0)
    return sub_100115CE4(result, *(void **)(a3 + 64), *(_QWORD *)(a3 + 72));
  v9 = *(_OWORD *)(a3 + 64);
  *(_QWORD *)(a2 + 80) = *(_QWORD *)(a3 + 80);
  *(_OWORD *)result = v9;
  return result;
}

void sub_100341580(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 55) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

uint64_t sub_10034159C(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    sub_1003415D0((uint64_t *)a1);
  return a1;
}

void sub_1003415D0(uint64_t *a1)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = (uint64_t *)a1[1];
  v1 = (uint64_t *)a1[2];
  v3 = *v1;
  v4 = *v2;
  if (*v1 != *v2)
  {
    v5 = *a1;
    do
    {
      v3 -= 88;
      sub_100302AA0(v5, v3);
    }
    while (v3 != v4);
  }
}

uint64_t sub_100341620(uint64_t a1)
{
  unsigned int v2;
  NSObject *v3;
  uint64_t result;
  uint64_t v5;
  const char *v6;
  uint8_t *v7;
  int v8;
  const char *v9;
  uint8_t buf[4];
  const char *v11;

  v2 = sub_100308ED8(a1);
  if (sub_1003419D8() > v2)
    return 1;
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130670);
  v3 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446210;
    v11 = "MiLoServices";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s has been written to more than expected. Clearing up disk space. If this log is seen often that indicates a serious problem", buf, 0xCu);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130670);
    v8 = 136446210;
    v9 = "MiLoServices";
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "%{public}s has been written to more than expected. Clearing up disk space. If this log is seen often that indicates a serious problem", &v8, 12);
    v7 = (uint8_t *)v6;
    sub_100512490("Generic", 1, 0, 2, "BOOL CLMicroLocationDatabase::freeSpaceIfFull() [Table = CLMiLoServiceTable]", "%s\n", v6);
    if (v7 != buf)
      free(v7);
  }
  result = sub_100341814(a1);
  if ((_DWORD)result)
  {
    if (*(uint64_t *)(a1 + 160) <= 0)
      v5 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v5 = *(_QWORD *)(a1 + 160);
    sub_100053048(a1 + 72, v5);
    return 1;
  }
  return result;
}

uint64_t sub_100341814(uint64_t a1)
{
  unsigned int v2;
  unsigned int v4;
  unint64_t v5;
  unint64_t v6;
  NSObject *v7;
  _DWORD v8[2];
  __int16 v9;
  const char *v10;
  __int16 v11;
  unint64_t v12;
  __int16 v13;
  const char *v14;

  v2 = sub_100308ED8(a1);
  if (sub_1003419D8() <= v2)
  {
    v4 = sub_100308ED8(a1);
    v5 = v4 - (unint64_t)sub_1003419D8();
    v6 = v5 + sub_100341AB4();
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130670);
    v7 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
    {
      v8[0] = 68289538;
      v8[1] = 0;
      v9 = 2082;
      v10 = "";
      v11 = 2050;
      v12 = v6;
      v13 = 2082;
      v14 = "MiLoServices";
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Free up database space\", \"Rows to delete\":%{public}llu, \"Table name\":%{public, location:escape_only}s}", (uint8_t *)v8, 0x26u);
    }
    if (!*(_QWORD *)(a1 + 264))
      operator new();
    sub_100355108();
  }
  return 1;
}

void sub_1003419AC()
{
  operator delete();
}

uint64_t sub_1003419D8()
{
  CFStringRef v0;
  int v1;
  unsigned int v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unsigned int v7;
  uint64_t v8;
  std::__shared_weak_count *v9;

  sub_1001E4804(&v8);
  v7 = 0;
  v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsServicesTableMaxRows", 0x8000100u, kCFAllocatorNull);
  v1 = sub_1000B1180(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  v2 = v7;
  v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  if (v1)
    return v2;
  else
    return 256;
}

void sub_100341A9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  sub_100261F44((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100341AB4()
{
  unsigned int v0;
  float v1;

  v0 = sub_1003419D8();
  sub_100341AF8();
  if (v1 < 0.0 || v1 > 1.0)
    sub_1018F4C24();
  return (float)(v1 * (float)v0);
}

void sub_100341AF8()
{
  CFStringRef v0;
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;
  int v4;
  uint64_t v5;
  std::__shared_weak_count *v6;

  sub_1001E4804(&v5);
  v4 = 0;
  v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsDatabaseFreeSpacePercentage", 0x8000100u, kCFAllocatorNull);
  sub_10052688C(v5, (uint64_t)v0, (float *)&v4);
  CFRelease(v0);
  v1 = v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void sub_100341BC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  sub_100261F44((uint64_t)va);
  _Unwind_Resume(a1);
}

_QWORD *sub_100341BD8(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  _QWORD *v7;

  v7 = operator new(0x1E0uLL);
  *v7 = a2;
  v7[1] = a3;
  sub_100341C34((uint64_t)(v7 + 2), a4);
  return v7;
}

void sub_100341C20(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100341C34(uint64_t a1, __int128 *a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  _BYTE *v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;

  v4 = *a2;
  v5 = a2[1];
  *(_QWORD *)(a1 + 32) = *((_QWORD *)a2 + 4);
  *(_OWORD *)a1 = v4;
  *(_OWORD *)(a1 + 16) = v5;
  if (*((char *)a2 + 63) < 0)
  {
    sub_100115CE4((_BYTE *)(a1 + 40), *((void **)a2 + 5), *((_QWORD *)a2 + 6));
  }
  else
  {
    v6 = *(__int128 *)((char *)a2 + 40);
    *(_QWORD *)(a1 + 56) = *((_QWORD *)a2 + 7);
    *(_OWORD *)(a1 + 40) = v6;
  }
  v7 = (_BYTE *)(a1 + 64);
  if (*((char *)a2 + 87) < 0)
  {
    sub_100115CE4(v7, *((void **)a2 + 8), *((_QWORD *)a2 + 9));
  }
  else
  {
    v8 = a2[4];
    *(_QWORD *)(a1 + 80) = *((_QWORD *)a2 + 10);
    *(_OWORD *)v7 = v8;
  }
  *(_QWORD *)(a1 + 88) = *((_QWORD *)a2 + 11);
  *(_OWORD *)(a1 + 96) = a2[6];
  *((_QWORD *)a2 + 12) = 0;
  *((_QWORD *)a2 + 13) = 0;
  *(_BYTE *)(a1 + 112) = 0;
  *(_BYTE *)(a1 + 296) = 0;
  if (*((_BYTE *)a2 + 296))
  {
    sub_100341DC0(a1 + 112, (uint64_t)(a2 + 7));
    *(_BYTE *)(a1 + 296) = 1;
  }
  *(_QWORD *)(a1 + 304) = *((_QWORD *)a2 + 38);
  *(_QWORD *)(a1 + 312) = *((_QWORD *)a2 + 39);
  *(_QWORD *)(a1 + 320) = *((_QWORD *)a2 + 40);
  *(_QWORD *)(a1 + 328) = *((_QWORD *)a2 + 41);
  a2[19] = 0u;
  a2[20] = 0u;
  *(_QWORD *)(a1 + 336) = *((_QWORD *)a2 + 42);
  *(_QWORD *)(a1 + 344) = *((_QWORD *)a2 + 43);
  *((_QWORD *)a2 + 42) = 0;
  *((_QWORD *)a2 + 43) = 0;
  v9 = a2[22];
  *(_BYTE *)(a1 + 368) = *((_BYTE *)a2 + 368);
  *(_OWORD *)(a1 + 352) = v9;
  *(_QWORD *)(a1 + 376) = *((_QWORD *)a2 + 47);
  *(_QWORD *)(a1 + 384) = *((_QWORD *)a2 + 48);
  *(_QWORD *)(a1 + 392) = *((_QWORD *)a2 + 49);
  *(_QWORD *)(a1 + 400) = *((_QWORD *)a2 + 50);
  *(__int128 *)((char *)a2 + 376) = 0u;
  *(__int128 *)((char *)a2 + 392) = 0u;
  *(_QWORD *)(a1 + 408) = *((_QWORD *)a2 + 51);
  *(_QWORD *)(a1 + 416) = *((_QWORD *)a2 + 52);
  *((_QWORD *)a2 + 51) = 0;
  *((_QWORD *)a2 + 52) = 0;
  v10 = *(__int128 *)((char *)a2 + 424);
  v11 = *(__int128 *)((char *)a2 + 440);
  *(_WORD *)(a1 + 456) = *((_WORD *)a2 + 228);
  *(_OWORD *)(a1 + 424) = v10;
  *(_OWORD *)(a1 + 440) = v11;
  return a1;
}

void sub_100341DA4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 63) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

uint64_t sub_100341DC0(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  v4 = *(_OWORD *)(a2 + 24);
  v5 = *(_OWORD *)(a2 + 33);
  *(_BYTE *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 33) = v5;
  *(_OWORD *)(a1 + 24) = v4;
  *(_BYTE *)(a1 + 80) = 0;
  if (*(_BYTE *)(a2 + 80))
  {
    v6 = *(_OWORD *)(a2 + 56);
    *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
    *(_OWORD *)(a1 + 56) = v6;
    *(_QWORD *)(a2 + 64) = 0;
    *(_QWORD *)(a2 + 72) = 0;
    *(_QWORD *)(a2 + 56) = 0;
    *(_BYTE *)(a1 + 80) = 1;
  }
  *(_BYTE *)(a1 + 88) = 0;
  v7 = a1 + 88;
  *(_BYTE *)(a1 + 128) = 0;
  if (*(_BYTE *)(a2 + 128))
  {
    sub_10012D080(v7, (uint64_t *)(a2 + 88));
    *(_BYTE *)(a1 + 128) = 1;
  }
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a2 + 136);
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 144) = *(_OWORD *)(a2 + 144);
  *(_QWORD *)(a1 + 160) = *(_QWORD *)(a2 + 160);
  *(_QWORD *)(a2 + 144) = 0;
  *(_QWORD *)(a2 + 152) = 0;
  *(_QWORD *)(a2 + 160) = 0;
  *(_OWORD *)(a1 + 168) = *(_OWORD *)(a2 + 168);
  return a1;
}

_QWORD *sub_100341E9C(uint64_t a1, _QWORD *a2, _OWORD *a3, __int128 *a4)
{
  unint64_t v4;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  void **v12;
  _QWORD *v13;
  unint64_t v14;
  __int128 v16;
  float v17;
  float v18;
  _BOOL8 v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  uint64_t v23;
  _QWORD *v24;
  unint64_t v25;

  v8 = 0;
  v9 = 0;
  do
    v9 ^= (v9 << 6) + (v9 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + v8++);
  while (v8 != 16);
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      v4 = v9;
      if (v9 >= v10)
        v4 = v9 % v10;
    }
    else
    {
      v4 = (v10 - 1) & v9;
    }
    v12 = *(void ***)(*(_QWORD *)a1 + 8 * v4);
    if (v12)
    {
      v13 = *v12;
      if (*v12)
      {
        do
        {
          v14 = v13[1];
          if (v14 == v9)
          {
            if (v13[2] == *a2 && v13[3] == a2[1])
              return v13;
          }
          else
          {
            if (v11.u32[0] > 1uLL)
            {
              if (v14 >= v10)
                v14 %= v10;
            }
            else
            {
              v14 &= v10 - 1;
            }
            if (v14 != v4)
              break;
          }
          v13 = (_QWORD *)*v13;
        }
        while (v13);
      }
    }
  }
  v13 = operator new(0x30uLL);
  *v13 = 0;
  v13[1] = v9;
  v16 = *a4;
  *((_OWORD *)v13 + 1) = *a3;
  *((_OWORD *)v13 + 2) = v16;
  v17 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v18 = *(float *)(a1 + 32);
  if (!v10 || (float)(v18 * (float)v10) < v17)
  {
    v19 = 1;
    if (v10 >= 3)
      v19 = (v10 & (v10 - 1)) != 0;
    v20 = v19 | (2 * v10);
    v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21)
      v22 = v21;
    else
      v22 = v20;
    sub_10012E444(a1, v22);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v4 = v9 % v10;
      else
        v4 = v9;
    }
    else
    {
      v4 = (v10 - 1) & v9;
    }
  }
  v23 = *(_QWORD *)a1;
  v24 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v24)
  {
    *v13 = *v24;
LABEL_44:
    *v24 = v13;
    goto LABEL_45;
  }
  *v13 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v13;
  *(_QWORD *)(v23 + 8 * v4) = a1 + 16;
  if (*v13)
  {
    v25 = *(_QWORD *)(*v13 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v25 >= v10)
        v25 %= v10;
    }
    else
    {
      v25 &= v10 - 1;
    }
    v24 = (_QWORD *)(*(_QWORD *)a1 + 8 * v25);
    goto LABEL_44;
  }
LABEL_45:
  ++*(_QWORD *)(a1 + 24);
  return v13;
}

void sub_1003420E8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1003420FC@<X0>(unsigned int *a1@<X1>, uint64_t *a2@<X2>, __int128 *a3@<X3>, uint64_t *a4@<X4>, __int128 *a5@<X5>, double *a6@<X6>, _QWORD *a7@<X8>)
{
  _QWORD *v14;
  _QWORD *result;

  v14 = operator new(0x238uLL);
  result = sub_10034218C(v14, a1, a2, a3, a4, a5, a6);
  *a7 = v14 + 3;
  a7[1] = v14;
  return result;
}

void sub_100342178(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_10034218C(_QWORD *a1, unsigned int *a2, uint64_t *a3, __int128 *a4, uint64_t *a5, __int128 *a6, double *a7)
{
  a1[2] = 0;
  *a1 = off_1021306A0;
  a1[1] = 0;
  sub_100340958((uint64_t)(a1 + 3), a2, *a3, a3[1], a4, *a5, a5[1], a6, *a7);
  return a1;
}

void sub_1003421E4(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1003421F8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1021306A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10034220C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1021306A0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete();
}

uint64_t sub_100342240(uint64_t a1)
{
  return sub_10034105C(a1 + 24);
}

_QWORD *sub_10034224C@<X0>(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *result;

  v4 = operator new(0x238uLL);
  result = sub_1003422A4(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_100342290(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1003422A4(_QWORD *a1, uint64_t a2)
{
  a1[2] = 0;
  *a1 = off_1021306A0;
  a1[1] = 0;
  sub_1003422F0((uint64_t)(a1 + 3), a2);
  return a1;
}

void sub_1003422DC(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1003422F0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  __int128 v5;

  v4 = sub_100340A84(a1, a2);
  *(_OWORD *)(v4 + 352) = *(_OWORD *)(a2 + 352);
  sub_1002A2230(v4 + 368, (__int128 *)(a2 + 368));
  *(_OWORD *)(a1 + 400) = *(_OWORD *)(a2 + 400);
  sub_100342430((uint64_t *)(a1 + 416), a2 + 416);
  sub_100524E68((_QWORD *)(a1 + 440), a2 + 440);
  *(_QWORD *)(a1 + 440) = &off_102131AB0;
  *(_QWORD *)(a1 + 456) = *(_QWORD *)(a2 + 456);
  if (*(char *)(a2 + 487) < 0)
  {
    sub_100115CE4((_BYTE *)(a1 + 464), *(void **)(a2 + 464), *(_QWORD *)(a2 + 472));
  }
  else
  {
    v5 = *(_OWORD *)(a2 + 464);
    *(_QWORD *)(a1 + 480) = *(_QWORD *)(a2 + 480);
    *(_OWORD *)(a1 + 464) = v5;
  }
  *(_QWORD *)(a1 + 488) = *(_QWORD *)(a2 + 488);
  sub_100342734((_BYTE *)(a1 + 496), a2 + 496);
  return a1;
}

void sub_1003423C0(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  uint64_t v3;

  sub_100261EE4(v3);
  if (*(_BYTE *)(v1 + 392))
  {
    if (*(char *)(v1 + 391) < 0)
      operator delete(*v2);
  }
  sub_10026E1B8(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_100342430(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_100342484(a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_10034246C(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_100008848(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_100342484(uint64_t *result, int *a2, int *a3)
{
  int *v4;
  uint64_t **v5;
  uint64_t *v6;
  int *v7;
  int *v8;
  BOOL v9;

  if (a2 != a3)
  {
    v4 = a2;
    v5 = (uint64_t **)result;
    v6 = result + 1;
    do
    {
      result = sub_100342508(v5, v6, v4 + 8, (_OWORD *)v4 + 2);
      v7 = (int *)*((_QWORD *)v4 + 1);
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = *(int **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (int *)*((_QWORD *)v4 + 2);
          v9 = *(_QWORD *)v8 == (_QWORD)v4;
          v4 = v8;
        }
        while (!v9);
      }
      v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_100342508(uint64_t **a1, uint64_t *a2, int *a3, _OWORD *a4)
{
  uint64_t *v6;
  uint64_t *v7;
  uint64_t **v8;
  uint64_t v10;
  uint64_t *v11;

  v6 = sub_10034258C(a1, a2, &v11, &v10, a3);
  v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    v8 = (uint64_t **)v6;
    v7 = (uint64_t *)operator new(0x30uLL);
    *((_OWORD *)v7 + 2) = *a4;
    sub_1000145B0(a1, (uint64_t)v11, v8, v7);
  }
  return v7;
}

uint64_t *sub_10034258C(_QWORD *a1, uint64_t *a2, uint64_t **a3, uint64_t *a4, int *a5)
{
  uint64_t *v5;
  int v6;
  int v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  BOOL v14;
  int v15;
  uint64_t v16;
  uint64_t *v17;
  int v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  int v22;

  v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *a5, v7 = *((_DWORD *)a2 + 8), *a5 < v7))
  {
    v8 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      v9 = (uint64_t *)*a2;
      do
      {
        v10 = v9;
        v9 = (uint64_t *)v9[1];
      }
      while (v9);
    }
    else
    {
      v13 = a2;
      do
      {
        v10 = (uint64_t *)v13[2];
        v14 = *v10 == (_QWORD)v13;
        v13 = v10;
      }
      while (v14);
    }
    v15 = *a5;
    if (*((_DWORD *)v10 + 8) < *a5)
      goto LABEL_17;
    v16 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v17 = (uint64_t *)v16;
          v18 = *(_DWORD *)(v16 + 32);
          if (v15 >= v18)
            break;
          v16 = *v17;
          v5 = v17;
          if (!*v17)
            goto LABEL_29;
        }
        if (v18 >= v15)
          break;
        v5 = v17 + 1;
        v16 = v17[1];
      }
      while (v16);
    }
    else
    {
      v17 = a1 + 1;
    }
LABEL_29:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = (uint64_t)a2;
    return a4;
  }
  v11 = a2[1];
  if (v11)
  {
    v12 = (uint64_t *)a2[1];
    do
    {
      a4 = v12;
      v12 = (uint64_t *)*v12;
    }
    while (v12);
  }
  else
  {
    v19 = a2;
    do
    {
      a4 = (uint64_t *)v19[2];
      v14 = *a4 == (_QWORD)v19;
      v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= *((_DWORD *)a4 + 8))
  {
    v20 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v21 = (uint64_t *)v20;
          v22 = *(_DWORD *)(v20 + 32);
          if (v6 >= v22)
            break;
          v20 = *v21;
          v5 = v21;
          if (!*v21)
            goto LABEL_48;
        }
        if (v22 >= v6)
          break;
        v5 = v21 + 1;
        v20 = v21[1];
      }
      while (v20);
    }
    else
    {
      v21 = a1 + 1;
    }
LABEL_48:
    *a3 = v21;
    return v5;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

_BYTE *sub_100342734(_BYTE *a1, uint64_t a2)
{
  *a1 = 0;
  a1[40] = 0;
  if (*(_BYTE *)(a2 + 40))
  {
    sub_100342790((uint64_t)a1, a2);
    a1[40] = 1;
  }
  return a1;
}

void sub_100342774(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(_BYTE *)(v1 + 40))
    sub_100300B8C(v1);
  _Unwind_Resume(exception_object);
}

uint64_t sub_100342790(uint64_t a1, uint64_t a2)
{
  _QWORD *i;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  sub_10012E444(a1, *(_QWORD *)(a2 + 8));
  for (i = *(_QWORD **)(a2 + 16); i; i = (_QWORD *)*i)
    sub_100342804(a1, i + 2, (_OWORD *)i + 1);
  return a1;
}

void sub_1003427EC(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_100300B8C(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_100342804(uint64_t a1, _QWORD *a2, _OWORD *a3)
{
  unint64_t v3;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  _QWORD *v19;
  unint64_t v20;
  _QWORD v22[3];

  v5 = 0;
  v6 = 0;
  do
    v6 ^= (v6 << 6) + (v6 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + v5++);
  while (v5 != 16);
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = v6;
      if (v6 >= v7)
        v3 = v6 % v7;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
    v9 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      v10 = (_QWORD *)*v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == v6)
          {
            if (v10[2] == *a2 && v10[3] == a2[1])
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  sub_100342A80(a1, v6, a3, (uint64_t)v22);
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    v15 = 1;
    if (v7 >= 3)
      v15 = (v7 & (v7 - 1)) != 0;
    v16 = v15 | (2 * v7);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      v18 = v17;
    else
      v18 = v16;
    sub_10012E444(a1, v18);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v6 >= v7)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
  }
  v19 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v19)
  {
    *(_QWORD *)v22[0] = *v19;
    *v19 = v22[0];
  }
  else
  {
    *(_QWORD *)v22[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v22[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = a1 + 16;
    if (*(_QWORD *)v22[0])
    {
      v20 = *(_QWORD *)(*(_QWORD *)v22[0] + 8);
      if ((v7 & (v7 - 1)) != 0)
      {
        if (v20 >= v7)
          v20 %= v7;
      }
      else
      {
        v20 &= v7 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v20) = v22[0];
    }
  }
  v10 = (_QWORD *)v22[0];
  v22[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  sub_100342AF8((uint64_t)v22, 0);
  return v10;
}

void sub_100342A68(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_100342AF8((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_100342A80@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  _QWORD *v8;
  uint64_t result;

  v7 = a1 + 16;
  v8 = operator new(0x48uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *v8 = 0;
  v8[1] = a2;
  *((_OWORD *)v8 + 1) = *a3;
  result = sub_1002A1D10((uint64_t)(v8 + 4), (uint64_t)(a3 + 1));
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_100342AE0(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_100342AF8(v1, 0);
  _Unwind_Resume(a1);
}

void sub_100342AF8(uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      sub_1002A1C94((uint64_t)v2 + 32);
    operator delete(v2);
  }
}

void sub_100342B40()
{
  operator delete();
}

_QWORD *sub_100342B54()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = off_1021306F0;
  return result;
}

void sub_100342B78(uint64_t a1, _QWORD *a2)
{
  *a2 = off_1021306F0;
}

BOOL sub_100342B90(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(*(_QWORD *)a2 + 4) == 0;
}

uint64_t sub_100342BA4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100342BE0()
{
}

void sub_100342BF0()
{
  operator delete();
}

_QWORD *sub_100342C04(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_102130780;
  result[1] = v3;
  return result;
}

uint64_t sub_100342C38(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_102130780;
  a2[1] = v2;
  return result;
}

BOOL sub_100342C54(uint64_t a1, _QWORD *a2)
{
  unsigned __int8 *v2;
  _BOOL8 v3;
  std::string __p;

  v2 = (unsigned __int8 *)(*a2 + 368);
  sub_10034C434(*(_QWORD *)(a1 + 8), &__p);
  v3 = sub_1002E6B90(v2, (unsigned __int8 *)&__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return v3;
}

uint64_t sub_100342CAC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100342CE8()
{
}

__n128 sub_100342CF4(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  _OWORD *v8;
  __n128 result;
  __int128 v10;

  v4 = a1[2];
  v5 = a1[1];
  v6 = 16 * (v4 - v5) - 1;
  if (v4 == v5)
    v6 = 0;
  v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100342D80(a1);
    v5 = a1[1];
    v7 = a1[5] + a1[4];
  }
  v8 = (_OWORD *)(*(_QWORD *)(v5 + ((v7 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v7 & 0x7F));
  result = *(__n128 *)a2;
  v10 = *(_OWORD *)(a2 + 16);
  *v8 = *(_OWORD *)a2;
  v8[1] = v10;
  ++a1[5];
  return result;
}

void sub_100342D80(_QWORD *a1)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  uint64_t v5;
  char *v6;
  _QWORD *v7;
  char *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  int64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  char *v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  unint64_t v33;
  char *v34;
  char *v35;
  uint64_t v36;
  char *v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  char *v43;
  _QWORD *v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  void *v53;
  __int128 v54;
  __int128 v55;
  _QWORD *v56;

  v2 = a1[4];
  v3 = v2 >= 0x80;
  v4 = v2 - 128;
  if (v3)
  {
    v5 = (uint64_t)(a1 + 3);
    v6 = (char *)a1[3];
    a1[4] = v4;
    v7 = (_QWORD *)a1[1];
    v8 = (char *)a1[2];
    v11 = *v7;
    v9 = (char *)(v7 + 1);
    v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(_QWORD *)v8 = v10;
      a1[2] += 8;
      return;
    }
    v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1)
        v33 = 1;
      else
        v33 = (uint64_t)&v8[-*a1] >> 2;
      v34 = (char *)sub_10025E6A0(v5, v33);
      v35 = &v34[8 * (v33 >> 2)];
      v37 = &v34[8 * v36];
      v38 = (uint64_t *)a1[1];
      v8 = v35;
      v39 = a1[2] - (_QWORD)v38;
      if (v39)
      {
        v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        v40 = 8 * (v39 >> 3);
        v41 = &v34[8 * (v33 >> 2)];
        do
        {
          v42 = *v38++;
          *(_QWORD *)v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    v13 = v12 >> 3;
    v14 = v12 >> 3 < -1;
    v15 = (v12 >> 3) + 2;
    if (v14)
      v16 = v15;
    else
      v16 = v13 + 1;
    v17 = -(v16 >> 1);
    v18 = v16 >> 1;
    v19 = &v9[-8 * v18];
    v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      v9 = (char *)a1[1];
    }
    v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  v21 = a1[2];
  v22 = (v21 - a1[1]) >> 3;
  v23 = a1[3];
  v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(_QWORD *)&v54 = operator new(0x1000uLL);
      sub_100212218(a1, &v54);
      return;
    }
    *(_QWORD *)&v54 = operator new(0x1000uLL);
    sub_100343094((uint64_t)a1, &v54);
    v44 = (_QWORD *)a1[1];
    v8 = (char *)a1[2];
    v45 = *v44;
    v9 = (char *)(v44 + 1);
    v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3])
      goto LABEL_33;
    v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1)
        v46 = 1;
      else
        v46 = (uint64_t)&v8[-*a1] >> 2;
      v34 = (char *)sub_10025E6A0((uint64_t)(a1 + 3), v46);
      v35 = &v34[8 * (v46 >> 2)];
      v37 = &v34[8 * v47];
      v48 = (uint64_t *)a1[1];
      v8 = v35;
      v49 = a1[2] - (_QWORD)v48;
      if (v49)
      {
        v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        v50 = 8 * (v49 >> 3);
        v51 = &v34[8 * (v46 >> 2)];
        do
        {
          v52 = *v48++;
          *(_QWORD *)v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1)
    v25 = 1;
  else
    v25 = v24 >> 2;
  v56 = a1 + 3;
  *(_QWORD *)&v54 = sub_10025E6A0((uint64_t)(a1 + 3), v25);
  *((_QWORD *)&v54 + 1) = v54 + 8 * v22;
  *(_QWORD *)&v55 = *((_QWORD *)&v54 + 1);
  *((_QWORD *)&v55 + 1) = v54 + 8 * v26;
  v53 = operator new(0x1000uLL);
  sub_10003732C(&v54, &v53);
  v27 = (_QWORD *)a1[2];
  v28 = -7 - (_QWORD)v27;
  while (v27 != (_QWORD *)a1[1])
  {
    --v27;
    v28 += 8;
    sub_1003431B0((uint64_t)&v54, v27);
  }
  v29 = (char *)*a1;
  v30 = v54;
  v31 = v55;
  *(_QWORD *)&v54 = *a1;
  *((_QWORD *)&v54 + 1) = v27;
  v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  v55 = v32;
  if (v27 != (_QWORD *)v32)
    *(_QWORD *)&v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  if (v29)
    operator delete(v29);
}

void sub_100343048(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  void *v13;

  operator delete(v13);
  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void sub_100343094(uint64_t a1, _QWORD *a2)
{
  char *v4;
  char *v5;
  uint64_t v6;
  _BYTE *v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t *v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  char *v22;

  v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    v6 = a1 + 24;
    v7 = *(_BYTE **)(a1 + 24);
    v8 = *(_BYTE **)(a1 + 16);
    if (v8 >= v7)
    {
      if (v7 == v4)
        v12 = 1;
      else
        v12 = (v7 - v4) >> 2;
      v13 = 2 * v12;
      v14 = (char *)sub_10025E6A0(v6, v12);
      v5 = &v14[(v13 + 6) & 0xFFFFFFFFFFFFFFF8];
      v16 = *(uint64_t **)(a1 + 8);
      v17 = v5;
      v18 = *(_QWORD *)(a1 + 16) - (_QWORD)v16;
      if (v18)
      {
        v17 = &v5[v18 & 0xFFFFFFFFFFFFFFF8];
        v19 = 8 * (v18 >> 3);
        v20 = v5;
        do
        {
          v21 = *v16++;
          *(_QWORD *)v20 = v21;
          v20 += 8;
          v19 -= 8;
        }
        while (v19);
      }
      v22 = *(char **)a1;
      *(_QWORD *)a1 = v14;
      *(_QWORD *)(a1 + 8) = v5;
      *(_QWORD *)(a1 + 16) = v17;
      *(_QWORD *)(a1 + 24) = &v14[8 * v15];
      if (v22)
      {
        operator delete(v22);
        v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      v9 = (v7 - v8) >> 3;
      if (v9 >= -1)
        v10 = v9 + 1;
      else
        v10 = v9 + 2;
      v11 = v10 >> 1;
      v5 = &v4[8 * (v10 >> 1)];
      if (v8 != v4)
      {
        memmove(&v4[8 * (v10 >> 1)], v4, v8 - v4);
        v4 = *(char **)(a1 + 16);
      }
      *(_QWORD *)(a1 + 8) = v5;
      *(_QWORD *)(a1 + 16) = &v4[8 * v11];
    }
  }
  else
  {
    v5 = *(char **)(a1 + 8);
  }
  *((_QWORD *)v5 - 1) = *a2;
  *(_QWORD *)(a1 + 8) -= 8;
}

void sub_1003431B0(uint64_t a1, _QWORD *a2)
{
  char *v4;
  char *v5;
  _BYTE *v6;
  _BYTE *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;

  v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    v6 = *(_BYTE **)(a1 + 16);
    v7 = *(_BYTE **)(a1 + 24);
    if (v6 >= v7)
    {
      if (v7 == v4)
        v11 = 1;
      else
        v11 = (v7 - v4) >> 2;
      v12 = 2 * v11;
      v13 = (char *)sub_10025E6A0(*(_QWORD *)(a1 + 32), v11);
      v5 = &v13[(v12 + 6) & 0xFFFFFFFFFFFFFFF8];
      v15 = *(uint64_t **)(a1 + 8);
      v16 = v5;
      v17 = *(_QWORD *)(a1 + 16) - (_QWORD)v15;
      if (v17)
      {
        v16 = &v5[v17 & 0xFFFFFFFFFFFFFFF8];
        v18 = 8 * (v17 >> 3);
        v19 = v5;
        do
        {
          v20 = *v15++;
          *(_QWORD *)v19 = v20;
          v19 += 8;
          v18 -= 8;
        }
        while (v18);
      }
      v21 = *(char **)a1;
      *(_QWORD *)a1 = v13;
      *(_QWORD *)(a1 + 8) = v5;
      *(_QWORD *)(a1 + 16) = v16;
      *(_QWORD *)(a1 + 24) = &v13[8 * v14];
      if (v21)
      {
        operator delete(v21);
        v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      v8 = (v7 - v6) >> 3;
      if (v8 >= -1)
        v9 = v8 + 1;
      else
        v9 = v8 + 2;
      v10 = v9 >> 1;
      v5 = &v4[8 * (v9 >> 1)];
      if (v6 != v4)
      {
        memmove(&v4[8 * (v9 >> 1)], v4, v6 - v4);
        v4 = *(char **)(a1 + 16);
      }
      *(_QWORD *)(a1 + 8) = v5;
      *(_QWORD *)(a1 + 16) = &v4[8 * v10];
    }
  }
  else
  {
    v5 = *(char **)(a1 + 8);
  }
  *((_QWORD *)v5 - 1) = *a2;
  *(_QWORD *)(a1 + 8) -= 8;
}

uint64_t sub_1003432C8(uint64_t a1, int a2)
{
  unint64_t v2;
  int v4;

  v2 = *(_QWORD *)(a1 + 32);
  if (v2 < 0x80)
    a2 = 1;
  if (v2 < 0x100)
    v4 = a2;
  else
    v4 = 0;
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(_QWORD *)(a1 + 8) += 8;
    *(_QWORD *)(a1 + 32) -= 128;
  }
  return v4 ^ 1u;
}

BOOL sub_100343324()
{
  NSObject *v0;

  return os_signpost_enabled(v0);
}

void sub_10034332C(uint64_t a1, xpc_object_t xdict)
{
  xpc_dictionary_set_BOOL(xdict, *(const char **)(a1 + 8), *(_BYTE *)a1);
}

void sub_100343340(uint64_t a1, xpc_object_t xdict)
{
  xpc_dictionary_set_int64(xdict, *(const char **)(a1 + 8), *(_QWORD *)a1);
}

void sub_100343350(const char **a1, xpc_object_t xdict)
{
  xpc_dictionary_set_string(xdict, a1[1], *a1);
}

uint64_t sub_100343360(uint64_t result, char a2)
{
  *(_BYTE *)result = a2;
  *(_QWORD *)(result + 8) = XPC_ACTIVITY_ALLOW_BATTERY;
  return result;
}

uint64_t sub_100343378(uint64_t result, char a2)
{
  *(_BYTE *)result = a2;
  *(_QWORD *)(result + 8) = XPC_ACTIVITY_REQUIRE_SCREEN_SLEEP;
  return result;
}

_QWORD *sub_100343390(_QWORD *result, uint64_t a2)
{
  *result = a2;
  result[1] = XPC_ACTIVITY_INTERVAL;
  return result;
}

_QWORD *sub_1003433A4(_QWORD *result, uint64_t a2)
{
  *result = a2;
  result[1] = XPC_ACTIVITY_PRIORITY;
  return result;
}

void **sub_1003433B8(void **a1)
{
  void *v2;

  v2 = *a1;
  if (v2)
    xpc_release(v2);
  return a1;
}

uint64_t sub_1003433EC(uint64_t a1, __int128 *a2, void **a3, uint64_t a4)
{
  __int128 v7;
  int v8;
  const std::string::value_type *v9;
  std::string::size_type v10;
  std::string *v11;
  __int128 v12;
  void **v13;
  void *v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  std::string v23;
  void *__p[2];
  int64_t v25;
  uint64_t v26;
  _QWORD v27[3];
  _QWORD *v28;
  _QWORD handler[5];
  _BYTE v30[24];
  _BYTE *v31;

  v7 = *a2;
  *(_QWORD *)(a1 + 16) = *((_QWORD *)a2 + 2);
  *(_OWORD *)a1 = v7;
  *((_QWORD *)a2 + 1) = 0;
  *((_QWORD *)a2 + 2) = 0;
  *(_QWORD *)a2 = 0;
  *((_BYTE *)&v23.__r_.__value_.__s + 23) = 20;
  strcpy((char *)&v23, "com.apple.locationd.");
  v8 = *(char *)(a1 + 23);
  if (v8 >= 0)
    v9 = (const std::string::value_type *)a1;
  else
    v9 = *(const std::string::value_type **)a1;
  if (v8 >= 0)
    v10 = *(unsigned __int8 *)(a1 + 23);
  else
    v10 = *(_QWORD *)(a1 + 8);
  v11 = std::string::append(&v23, v9, v10);
  v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  v25 = v11->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v12;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  if (v25 >= 0)
    v13 = __p;
  else
    v13 = (void **)__p[0];
  v14 = *a3;
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3321888768;
  handler[2] = sub_1003436BC;
  handler[3] = &unk_1021307F0;
  v26 = a1;
  v15 = v27;
  sub_100270E34((uint64_t)v27, a4);
  v18 = (uint64_t)v28;
  handler[4] = v26;
  v19 = v30;
  if (!v28)
    goto LABEL_13;
  if (v28 != v27)
  {
    v18 = (*(uint64_t (**)(_QWORD *, uint64_t, uint64_t))(*v28 + 16))(v28, v16, v17);
LABEL_13:
    v31 = (_BYTE *)v18;
    goto LABEL_15;
  }
  v31 = v30;
  (*(void (**)(_QWORD *, _BYTE *))(v27[0] + 24))(v27, v30);
LABEL_15:
  xpc_activity_register((const char *)v13, v14, handler);
  if (v28 == v27)
  {
    v20 = 4;
  }
  else
  {
    if (!v28)
      goto LABEL_20;
    v20 = 5;
    v15 = v28;
  }
  (*(void (**)(_QWORD *))(*v15 + 8 * v20))(v15);
LABEL_20:
  if (SHIBYTE(v25) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v23.__r_.__value_.__l.__data_);
  if (v31 == v30)
  {
    v21 = 4;
    goto LABEL_28;
  }
  if (v31)
  {
    v21 = 5;
    v19 = v31;
LABEL_28:
    (*(void (**)(_QWORD *))(*v19 + 8 * v21))(v19);
  }
  return a1;
}

void sub_100343608(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,_QWORD *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35)
{
  uint64_t v35;
  _QWORD *v36;
  uint64_t v38;

  if (a26 == v36)
  {
    v38 = 4;
  }
  else
  {
    if (!a26)
      goto LABEL_6;
    v38 = 5;
    v36 = a26;
  }
  (*(void (**)(_QWORD *))(*v36 + 8 * v38))(v36);
LABEL_6:
  if (a21 < 0)
    operator delete(__p);
  if (a14 < 0)
    operator delete(a9);
  if (*(char *)(v35 + 23) < 0)
    operator delete(*(void **)v35);
  _Unwind_Resume(exception_object);
}

void sub_1003436BC(uint64_t a1, xpc_activity_t activity)
{
  uint64_t *v4;
  xpc_activity_state_t state;
  NSObject *v6;
  uint64_t *v7;
  const char *v8;
  char *v9;
  uint64_t v10;
  xpc_activity_t v11;
  int v12;
  uint64_t *v13;
  uint8_t buf[1640];

  v4 = *(uint64_t **)(a1 + 32);
  v11 = activity;
  state = xpc_activity_get_state(activity);
  if (state == 2)
  {
    sub_100343960(&v11, 4);
    *(_QWORD *)buf = activity;
    v10 = *(_QWORD *)(a1 + 64);
    if (!v10)
      sub_10025FD1C();
    (*(void (**)(uint64_t, uint8_t *))(*(_QWORD *)v10 + 48))(v10, buf);
  }
  else if (!state)
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130820);
    v6 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
    {
      v7 = v4;
      if (*((char *)v4 + 23) < 0)
        v7 = (uint64_t *)*v4;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "Checking in for %{public}s", buf, 0xCu);
    }
    if (sub_1001BFF7C(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130820);
      if (*((char *)v4 + 23) < 0)
        v4 = (uint64_t *)*v4;
      v12 = 136446210;
      v13 = v4;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 2, "Checking in for %{public}s", &v12, 12);
      v9 = (char *)v8;
      sub_100512490("Generic", 1, 0, 2, "auto CLMicroLocationXPCActivityHelpers::XPCRegistration::XPCRegistration(std::string, const XPCCriteria &, XPCActivityHandler)::(anonymous class)::operator()(xpc_activity_t) const", "%s\n", v8);
      if (v9 != (char *)buf)
        free(v9);
    }
  }
}

uint64_t sub_1003438CC(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  return sub_100270E34(a1 + 40, a2 + 40);
}

_QWORD *sub_1003438E0(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 40);
  result = *(_QWORD **)(a1 + 64);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

const char *sub_100343918(const char *a1)
{
  const char *v1;

  v1 = a1;
  if (a1[23] < 0)
    a1 = *(const char **)a1;
  xpc_activity_unregister(a1);
  if (v1[23] < 0)
    operator delete(*(void **)v1);
  return v1;
}

void sub_100343960(xpc_activity_t *a1, xpc_activity_state_t a2)
{
  NSObject *v4;
  xpc_activity_state_t state;
  uint64_t v6;
  xpc_activity_state_t v7;
  const char *v8;
  uint8_t *v9;
  int v10;
  xpc_activity_state_t v11;
  __int16 v12;
  xpc_activity_state_t v13;
  uint8_t buf[4];
  xpc_activity_state_t v15;
  __int16 v16;
  xpc_activity_state_t v17;

  if (!xpc_activity_set_state(*a1, a2))
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130820);
    v4 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      state = xpc_activity_get_state(*a1);
      *(_DWORD *)buf = 134349312;
      v15 = a2;
      v16 = 2050;
      v17 = state;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#Warning Unable to mark activity as %{public}ld. current state is %{public}ld", buf, 0x16u);
    }
    if (sub_1001BFF7C(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130820);
      v6 = qword_1022A00F8;
      v7 = xpc_activity_get_state(*a1);
      v10 = 134349312;
      v11 = a2;
      v12 = 2050;
      v13 = v7;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, v6, 0, "#Warning Unable to mark activity as %{public}ld. current state is %{public}ld", &v10, 22);
      v9 = (uint8_t *)v8;
      sub_100512490("Generic", 1, 0, 2, "void CLMicroLocationXPCActivityHelpers::XPCActivity::setState(xpc_activity_state_t)", "%s\n", v8);
      if (v9 != buf)
        free(v9);
    }
  }
}

BOOL sub_100343B44(xpc_activity_t *a1)
{
  return xpc_activity_should_defer(*a1);
}

void sub_100343B4C(xpc_activity_t *a1)
{
  sub_100343960(a1, 5);
}

void sub_100343B54(xpc_activity_t *a1)
{
  sub_100343960(a1, 3);
}

void sub_100343B5C(id a1)
{
  qword_1022A00F8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

BOOL sub_100343B88(uint64_t a1, uint64_t a2)
{
  return HIDWORD(a1) > HIDWORD(a2);
}

_QWORD *sub_100343B9C(_QWORD *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  unsigned int v5;
  unsigned int *v6;

  v2 = *a2;
  v3 = a2[1];
  if (*a2 != v3)
  {
    v4 = result;
    do
    {
      v5 = *(_DWORD *)(v2 + 32);
      if (!sub_100270BB8(v4, &v5))
      {
        v6 = &v5;
        *((_DWORD *)sub_1000A6778((uint64_t)v4, &v5, (uint64_t)&unk_101B9EB60, &v6) + 5) = 0;
      }
      v6 = &v5;
      result = sub_1000A6778((uint64_t)v4, &v5, (uint64_t)&unk_101B9EB60, &v6);
      ++*((_DWORD *)result + 5);
      v2 += 48;
    }
    while (v2 != v3);
  }
  return result;
}

BOOL sub_100343C54(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24) == 0;
}

uint64_t sub_100343C64@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  _QWORD *v3;
  uint64_t *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  _QWORD *v16;
  int i;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char *v24;
  uint64_t v25;
  int *v26;
  char *v27;
  char *v28;
  int *v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  BOOL v33;
  uint64_t v34;
  BOOL (*v36)(uint64_t, uint64_t);

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v3 = *(_QWORD **)(a1 + 16);
  if (v3)
  {
    v4 = 0;
    v5 = a2 + 2;
    do
    {
      if ((unint64_t)v4 >= *v5)
      {
        v6 = ((uint64_t)v4 - *a2) >> 3;
        if ((unint64_t)(v6 + 1) >> 61)
          sub_100259694();
        v7 = *v5 - *a2;
        v8 = v7 >> 2;
        if (v7 >> 2 <= (unint64_t)(v6 + 1))
          v8 = v6 + 1;
        if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF8)
          v9 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v9 = v8;
        v10 = (char *)sub_10025E6A0((uint64_t)(a2 + 2), v9);
        v12 = &v10[8 * v6];
        *(_QWORD *)v12 = v3[2];
        v4 = (uint64_t *)(v12 + 8);
        v14 = (char *)*a2;
        v13 = (char *)a2[1];
        if (v13 != (char *)*a2)
        {
          do
          {
            v15 = *((_QWORD *)v13 - 1);
            v13 -= 8;
            *((_QWORD *)v12 - 1) = v15;
            v12 -= 8;
          }
          while (v13 != v14);
          v13 = (char *)*a2;
        }
        *a2 = (uint64_t)v12;
        a2[1] = (uint64_t)v4;
        a2[2] = (uint64_t)&v10[8 * v11];
        if (v13)
          operator delete(v13);
      }
      else
      {
        *v4++ = v3[2];
      }
      a2[1] = (uint64_t)v4;
      v3 = (_QWORD *)*v3;
    }
    while (v3);
  }
  else
  {
    v4 = 0;
  }
  v16 = a2 + 2;
  for (i = 1; i != 14; ++i)
  {
    v18 = *a2;
    v19 = (uint64_t *)*a2;
    if ((uint64_t *)*a2 == v4)
    {
LABEL_23:
      if ((unint64_t)v4 >= *v16)
      {
        v20 = ((uint64_t)v4 - v18) >> 3;
        if ((unint64_t)(v20 + 1) >> 61)
          sub_100259694();
        v21 = *v16 - v18;
        v22 = v21 >> 2;
        if (v21 >> 2 <= (unint64_t)(v20 + 1))
          v22 = v20 + 1;
        if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF8)
          v23 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v23 = v22;
        v24 = (char *)sub_10025E6A0((uint64_t)(a2 + 2), v23);
        v26 = (int *)&v24[8 * v20];
        *v26 = i;
        v26[1] = 0;
        v28 = (char *)*a2;
        v27 = (char *)a2[1];
        v29 = v26;
        if (v27 != (char *)*a2)
        {
          do
          {
            v30 = *((_QWORD *)v27 - 1);
            v27 -= 8;
            *((_QWORD *)v29 - 1) = v30;
            v29 -= 2;
          }
          while (v27 != v28);
          v27 = (char *)*a2;
        }
        v4 = (uint64_t *)(v26 + 2);
        *a2 = (uint64_t)v29;
        a2[1] = (uint64_t)(v26 + 2);
        a2[2] = (uint64_t)&v24[8 * v25];
        if (v27)
          operator delete(v27);
      }
      else
      {
        *(_DWORD *)v4 = i;
        *((_DWORD *)v4++ + 1) = 0;
      }
      a2[1] = (uint64_t)v4;
    }
    else
    {
      while (*(_DWORD *)v19 != i)
      {
        if (++v19 == v4)
          goto LABEL_23;
      }
    }
  }
  v31 = *a2;
  v32 = 126 - 2 * __clz(((uint64_t)v4 - *a2) >> 3);
  v33 = v4 == (uint64_t *)*a2;
  v36 = sub_100343B88;
  if (v33)
    v34 = 0;
  else
    v34 = v32;
  return sub_100344080(v31, v4, (uint64_t (**)(uint64_t, uint64_t))&v36, v34, 1);
}

void sub_100343E90(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100343EBC(uint64_t a1@<X0>, void **a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t *v6;
  int v7;
  int v8;
  unint64_t v9;
  _DWORD *v10;
  _DWORD *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  uint64_t v22;
  _DWORD v23[4];
  int v24;

  if (*(_DWORD *)(a1 + 40))
    sub_1018F4DAC();
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v3 = *(_QWORD *)(a1 + 16);
  if (!v3)
    v3 = *(_QWORD *)(qword_102310460 + 16);
  v4 = *(int *)(v3 + 16);
  if ((_DWORD)v4)
  {
    v5 = *(uint64_t **)(v3 + 8);
    v6 = &v5[v4];
    do
    {
      sub_1002E3420((uint64_t)v23, *v5);
      v7 = v24;
      if ((v24 - 14) >= 0xFFFFFFF3)
      {
        v8 = v23[2];
        v10 = a2[1];
        v9 = (unint64_t)a2[2];
        if ((unint64_t)v10 >= v9)
        {
          v12 = ((char *)v10 - (_BYTE *)*a2) >> 3;
          v13 = v12 + 1;
          if ((unint64_t)(v12 + 1) >> 61)
            sub_100259694();
          v14 = v9 - (_QWORD)*a2;
          if (v14 >> 2 > v13)
            v13 = v14 >> 2;
          if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8)
            v15 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v15 = v13;
          v16 = (char *)sub_10025E6A0((uint64_t)(a2 + 2), v15);
          v18 = &v16[8 * v12];
          *(_DWORD *)v18 = v7;
          *((_DWORD *)v18 + 1) = v8;
          v20 = (char *)*a2;
          v19 = (char *)a2[1];
          v21 = v18;
          if (v19 != *a2)
          {
            do
            {
              v22 = *((_QWORD *)v19 - 1);
              v19 -= 8;
              *((_QWORD *)v21 - 1) = v22;
              v21 -= 8;
            }
            while (v19 != v20);
            v19 = (char *)*a2;
          }
          v11 = v18 + 8;
          *a2 = v21;
          a2[1] = v18 + 8;
          a2[2] = &v16[8 * v17];
          if (v19)
            operator delete(v19);
        }
        else
        {
          *v10 = v24;
          v10[1] = v8;
          v11 = v10 + 2;
        }
        a2[1] = v11;
      }
      sub_1002E3424((wireless_diagnostics::google::protobuf::MessageLite *)v23);
      ++v5;
    }
    while (v5 != v6);
  }
}

void sub_100344024(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;
  void *v11;

  sub_1002E3424((wireless_diagnostics::google::protobuf::MessageLite *)&a9);
  v11 = *(void **)v9;
  if (*(_QWORD *)v9)
  {
    *(_QWORD *)(v9 + 8) = v11;
    operator delete(v11);
  }
  _Unwind_Resume(a1);
}

void sub_100344054(id a1)
{
  qword_1022A00F8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

uint64_t sub_100344080(uint64_t result, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t), uint64_t a4, char a5)
{
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t *v17;
  char v18;
  BOOL v19;
  uint64_t v20;

  v8 = (uint64_t *)result;
LABEL_2:
  v9 = v8;
LABEL_3:
  v10 = 1 - a4;
  while (2)
  {
    v8 = v9;
    v11 = v10;
    v12 = (char *)a2 - (char *)v9;
    v13 = a2 - v9;
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        result = (*a3)(*(a2 - 1), *v9);
        if ((_DWORD)result)
        {
          v20 = *v9;
          *v9 = *(a2 - 1);
          *(a2 - 1) = v20;
        }
        return result;
      case 3uLL:
        return sub_100344514(v9, v9 + 1, a2 - 1, (unsigned int (**)(_QWORD))a3);
      case 4uLL:
        return sub_1003449C8(v9, v9 + 1, v9 + 2, a2 - 1, (unsigned int (**)(_QWORD))a3);
      case 5uLL:
        return sub_100344A78(v9, v9 + 1, v9 + 2, v9 + 3, a2 - 1, (unsigned int (**)(_QWORD))a3);
      default:
        if (v12 <= 191)
        {
          if ((a5 & 1) != 0)
            return sub_1003443C0((uint64_t)v9, a2, a3);
          else
            return sub_100344480((uint64_t)v9, a2, a3);
        }
        if (v11 != 1)
        {
          v14 = v13 >> 1;
          v15 = &v9[v13 >> 1];
          if ((unint64_t)v12 < 0x401)
          {
            sub_100344514(&v9[v13 >> 1], v9, a2 - 1, (unsigned int (**)(_QWORD))a3);
            if ((a5 & 1) != 0)
              goto LABEL_12;
          }
          else
          {
            sub_100344514(v9, &v9[v13 >> 1], a2 - 1, (unsigned int (**)(_QWORD))a3);
            sub_100344514(v9 + 1, v15 - 1, a2 - 2, (unsigned int (**)(_QWORD))a3);
            sub_100344514(v9 + 2, &v9[v14 + 1], a2 - 3, (unsigned int (**)(_QWORD))a3);
            sub_100344514(v15 - 1, v15, &v9[v14 + 1], (unsigned int (**)(_QWORD))a3);
            v16 = *v9;
            *v9 = *v15;
            *v15 = v16;
            if ((a5 & 1) != 0)
              goto LABEL_12;
          }
          if (((*a3)(*(v9 - 1), *v9) & 1) == 0)
          {
            result = (uint64_t)sub_100344600(v9, a2, a3);
            v9 = (uint64_t *)result;
            goto LABEL_17;
          }
LABEL_12:
          v17 = sub_10034470C(v9, a2, a3);
          if ((v18 & 1) == 0)
            goto LABEL_15;
          v19 = sub_100344824(v9, v17, (unsigned int (**)(_QWORD))a3);
          v9 = v17 + 1;
          result = sub_100344824(v17 + 1, a2, (unsigned int (**)(_QWORD))a3);
          if (!(_DWORD)result)
          {
            v10 = v11 + 1;
            if (v19)
              continue;
LABEL_15:
            result = sub_100344080(v8, v17, a3, -v11, a5 & 1);
            v9 = v17 + 1;
LABEL_17:
            a5 = 0;
            a4 = -v11;
            goto LABEL_3;
          }
          a4 = -v11;
          a2 = v17;
          if (v19)
            return result;
          goto LABEL_2;
        }
        if (v9 != a2)
          return (uint64_t)sub_100344B50((char *)v9, (char *)a2, a2, a3);
        return result;
    }
  }
}

uint64_t sub_1003443C0(uint64_t result, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  _QWORD *v4;
  uint64_t *v5;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;

  if ((uint64_t *)result != a2)
  {
    v4 = (_QWORD *)result;
    v5 = (uint64_t *)(result + 8);
    if ((uint64_t *)(result + 8) != a2)
    {
      v7 = 0;
      v8 = (uint64_t *)result;
      do
      {
        v10 = *v8;
        v9 = v8[1];
        v8 = v5;
        result = (*a3)(v9, v10);
        if ((_DWORD)result)
        {
          v11 = *v8;
          v12 = v7;
          while (1)
          {
            *(_QWORD *)((char *)v4 + v12 + 8) = *(_QWORD *)((char *)v4 + v12);
            if (!v12)
              break;
            result = (*a3)(v11, *(_QWORD *)((char *)v4 + v12 - 8));
            v12 -= 8;
            if ((result & 1) == 0)
            {
              v13 = (_QWORD *)((char *)v4 + v12 + 8);
              goto LABEL_10;
            }
          }
          v13 = v4;
LABEL_10:
          *v13 = v11;
        }
        v5 = v8 + 1;
        v7 += 8;
      }
      while (v8 + 1 != a2);
    }
  }
  return result;
}

uint64_t sub_100344480(uint64_t result, _QWORD *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  _QWORD *v4;
  _QWORD *i;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;

  if ((_QWORD *)result != a2)
  {
    v4 = (_QWORD *)result;
    for (i = (_QWORD *)(result + 8); v4 + 1 != a2; i = v4 + 1)
    {
      v8 = *v4;
      v7 = v4[1];
      v4 = i;
      result = (*a3)(v7, v8);
      if ((_DWORD)result)
      {
        v9 = *v4;
        v10 = v4;
        do
        {
          v11 = v10;
          v12 = *--v10;
          *v11 = v12;
          result = (*a3)(v9, *(v11 - 2));
        }
        while ((result & 1) != 0);
        *v10 = v9;
      }
    }
  }
  return result;
}

uint64_t sub_100344514(_QWORD *a1, _QWORD *a2, _QWORD *a3, unsigned int (**a4)(_QWORD))
{
  char v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v8 = ((uint64_t (*)(_QWORD, _QWORD))*a4)(*a2, *a1);
  result = ((uint64_t (*)(_QWORD, _QWORD))*a4)(*a3, *a2);
  if ((v8 & 1) == 0)
  {
    if (!(_DWORD)result)
      return result;
    v11 = *a2;
    *a2 = *a3;
    *a3 = v11;
    if (!((unsigned int (*)(_QWORD, _QWORD))*a4)(*a2, *a1))
      return 1;
    v12 = *a1;
    *a1 = *a2;
    *a2 = v12;
    return 2;
  }
  v10 = *a1;
  if (!(_DWORD)result)
  {
    *a1 = *a2;
    *a2 = v10;
    if (!(*a4)(*a3))
      return 1;
    v13 = *a2;
    *a2 = *a3;
    *a3 = v13;
    return 2;
  }
  *a1 = *a3;
  *a3 = v10;
  return 1;
}

uint64_t *sub_100344600(uint64_t *a1, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  uint64_t *v4;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v4 = a2;
  v6 = *a1;
  if (((*a3)(*a1, *(a2 - 1)) & 1) != 0)
  {
    v7 = a1;
    do
    {
      v8 = v7[1];
      ++v7;
    }
    while (((*a3)(v6, v8) & 1) == 0);
  }
  else
  {
    v9 = a1 + 1;
    do
    {
      v7 = v9;
      if (v9 >= v4)
        break;
      ++v9;
    }
    while (!(*a3)(v6, *v7));
  }
  if (v7 < v4)
  {
    do
      v10 = *--v4;
    while (((*a3)(v6, v10) & 1) != 0);
  }
  while (v7 < v4)
  {
    v11 = *v7;
    *v7 = *v4;
    *v4 = v11;
    do
    {
      v12 = v7[1];
      ++v7;
    }
    while (!(*a3)(v6, v12));
    do
      v13 = *--v4;
    while (((*a3)(v6, v13) & 1) != 0);
  }
  if (v7 - 1 != a1)
    *a1 = *(v7 - 1);
  *(v7 - 1) = v6;
  return v7;
}

uint64_t *sub_10034470C(uint64_t *a1, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  uint64_t v6;
  uint64_t v7;
  char v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v6 = 0;
  v7 = *a1;
  do
    v8 = (*a3)(a1[++v6], v7);
  while ((v8 & 1) != 0);
  v9 = &a1[v6];
  v10 = &a1[v6 - 1];
  if (v6 == 1)
  {
    do
    {
      if (v9 >= a2)
        break;
      v12 = *--a2;
    }
    while (((*a3)(v12, v7) & 1) == 0);
  }
  else
  {
    do
      v11 = *--a2;
    while (!(*a3)(v11, v7));
  }
  if (v9 < a2)
  {
    v13 = &a1[v6];
    v14 = a2;
    do
    {
      v15 = *v13;
      *v13 = *v14;
      *v14 = v15;
      do
      {
        v16 = v13[1];
        ++v13;
      }
      while (((*a3)(v16, v7) & 1) != 0);
      do
        v17 = *--v14;
      while (!(*a3)(v17, v7));
    }
    while (v13 < v14);
    v10 = v13 - 1;
  }
  if (v10 != a1)
    *a1 = *v10;
  *v10 = v7;
  return v10;
}

BOOL sub_100344824(_QWORD *a1, _QWORD *a2, unsigned int (**a3)(_QWORD))
{
  uint64_t v6;
  _BOOL8 result;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  _QWORD *v16;

  v6 = a2 - a1;
  result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (((unsigned int (*)(_QWORD, _QWORD))*a3)(*(a2 - 1), *a1))
      {
        v8 = *a1;
        *a1 = *(a2 - 1);
        *(a2 - 1) = v8;
      }
      return 1;
    case 3:
      sub_100344514(a1, a1 + 1, a2 - 1, a3);
      return 1;
    case 4:
      sub_1003449C8(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      sub_100344A78(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1;
    default:
      v9 = a1 + 2;
      sub_100344514(a1, a1 + 1, a1 + 2, a3);
      v10 = a1 + 3;
      if (a1 + 3 == a2)
        return 1;
      v11 = 0;
      v12 = 0;
      break;
  }
  while (1)
  {
    if (((unsigned int (*)(_QWORD, _QWORD))*a3)(*v10, *v9))
    {
      v13 = *v10;
      v14 = v11;
      while (1)
      {
        v15 = (char *)a1 + v14;
        *(_QWORD *)((char *)a1 + v14 + 24) = *(_QWORD *)((char *)a1 + v14 + 16);
        if (v14 == -16)
          break;
        v14 -= 8;
        if ((((uint64_t (*)(uint64_t, _QWORD))*a3)(v13, *((_QWORD *)v15 + 1)) & 1) == 0)
        {
          v16 = (_QWORD *)((char *)a1 + v14 + 24);
          goto LABEL_12;
        }
      }
      v16 = a1;
LABEL_12:
      *v16 = v13;
      if (++v12 == 8)
        return v10 + 1 == a2;
    }
    v9 = v10;
    v11 += 8;
    if (++v10 == a2)
      return 1;
  }
}

uint64_t sub_1003449C8(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, unsigned int (**a5)(_QWORD))
{
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  sub_100344514(a1, a2, a3, a5);
  result = ((uint64_t (*)(_QWORD, _QWORD))*a5)(*a4, *a3);
  if ((_DWORD)result)
  {
    v11 = *a3;
    *a3 = *a4;
    *a4 = v11;
    result = ((uint64_t (*)(_QWORD, _QWORD))*a5)(*a3, *a2);
    if ((_DWORD)result)
    {
      v12 = *a2;
      *a2 = *a3;
      *a3 = v12;
      result = ((uint64_t (*)(_QWORD, _QWORD))*a5)(*a2, *a1);
      if ((_DWORD)result)
      {
        v13 = *a1;
        *a1 = *a2;
        *a2 = v13;
      }
    }
  }
  return result;
}

uint64_t sub_100344A78(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, unsigned int (**a6)(_QWORD))
{
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  sub_1003449C8(a1, a2, a3, a4, a6);
  result = ((uint64_t (*)(_QWORD, _QWORD))*a6)(*a5, *a4);
  if ((_DWORD)result)
  {
    v13 = *a4;
    *a4 = *a5;
    *a5 = v13;
    result = ((uint64_t (*)(_QWORD, _QWORD))*a6)(*a4, *a3);
    if ((_DWORD)result)
    {
      v14 = *a3;
      *a3 = *a4;
      *a4 = v14;
      result = ((uint64_t (*)(_QWORD, _QWORD))*a6)(*a3, *a2);
      if ((_DWORD)result)
      {
        v15 = *a2;
        *a2 = *a3;
        *a3 = v15;
        result = ((uint64_t (*)(_QWORD, _QWORD))*a6)(*a2, *a1);
        if ((_DWORD)result)
        {
          v16 = *a1;
          *a1 = *a2;
          *a2 = v16;
        }
      }
    }
  }
  return result;
}

uint64_t *sub_100344B50(char *a1, char *a2, uint64_t *a3, uint64_t (**a4)(uint64_t, uint64_t))
{
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  char *v19;

  if (a1 != a2)
  {
    v8 = a2 - a1;
    v9 = (a2 - a1) >> 3;
    if (a2 - a1 >= 9)
    {
      v10 = (unint64_t)(v9 - 2) >> 1;
      v11 = v10 + 1;
      v12 = &a1[8 * v10];
      do
      {
        sub_100344CA4((uint64_t)a1, (unsigned int (**)(_QWORD, _QWORD))a4, v9, v12);
        v12 -= 8;
        --v11;
      }
      while (v11);
    }
    v13 = a2;
    if (a2 != (char *)a3)
    {
      v14 = (uint64_t *)a2;
      do
      {
        if ((*a4)(*v14, *(_QWORD *)a1))
        {
          v15 = *v14;
          *v14 = *(_QWORD *)a1;
          *(_QWORD *)a1 = v15;
          sub_100344CA4((uint64_t)a1, (unsigned int (**)(_QWORD, _QWORD))a4, v9, a1);
        }
        ++v14;
      }
      while (v14 != a3);
      v13 = (char *)a3;
    }
    if (v8 >= 9)
    {
      v16 = (unint64_t)v8 >> 3;
      v17 = a2 - 8;
      do
      {
        v18 = *(_QWORD *)a1;
        v19 = (char *)sub_100344DC4(a1, (unsigned int (**)(_QWORD, _QWORD))a4, v16);
        if (v17 == v19)
        {
          *(_QWORD *)v19 = v18;
        }
        else
        {
          *(_QWORD *)v19 = *(_QWORD *)v17;
          *(_QWORD *)v17 = v18;
          sub_100344E70((uint64_t)a1, (uint64_t)(v19 + 8), a4, (v19 + 8 - a1) >> 3);
        }
        v17 -= 8;
      }
      while (v16-- > 2);
    }
    return (uint64_t *)v13;
  }
  return a3;
}

uint64_t sub_100344CA4(uint64_t result, unsigned int (**a2)(_QWORD, _QWORD), uint64_t a3, _QWORD *a4)
{
  unint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  int64_t v7;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;

  v4 = a3 - 2;
  if (a3 >= 2)
  {
    v5 = a4;
    v6 = result;
    v7 = v4 >> 1;
    if ((uint64_t)(v4 >> 1) >= ((uint64_t)a4 - result) >> 3)
    {
      v10 = ((uint64_t)a4 - result) >> 2;
      v11 = v10 + 1;
      v12 = (_QWORD *)(result + 8 * (v10 + 1));
      v13 = v10 + 2;
      if (v10 + 2 < a3 && (*a2)(*v12, v12[1]))
      {
        ++v12;
        v11 = v13;
      }
      result = ((uint64_t (*)(_QWORD, _QWORD))*a2)(*v12, *v5);
      if ((result & 1) == 0)
      {
        v14 = *v5;
        do
        {
          v15 = v12;
          *v5 = *v12;
          if (v7 < v11)
            break;
          v16 = (2 * v11) | 1;
          v12 = (_QWORD *)(v6 + 8 * v16);
          if (2 * v11 + 2 < a3)
          {
            if ((*a2)(*v12, v12[1]))
            {
              ++v12;
              v16 = 2 * v11 + 2;
            }
          }
          result = ((uint64_t (*)(_QWORD, uint64_t))*a2)(*v12, v14);
          v5 = v15;
          v11 = v16;
        }
        while (!(_DWORD)result);
        *v15 = v14;
      }
    }
  }
  return result;
}

_QWORD *sub_100344DC4(_QWORD *a1, unsigned int (**a2)(_QWORD, _QWORD), uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;

  v6 = 0;
  v7 = a3 - 2;
  if (a3 < 2)
    v7 = a3 - 1;
  v8 = v7 >> 1;
  do
  {
    v9 = &a1[v6 + 1];
    v10 = (2 * v6) | 1;
    v11 = 2 * v6 + 2;
    if (v11 < a3 && (*a2)(a1[v6 + 1], a1[v6 + 2]))
    {
      ++v9;
      v10 = v11;
    }
    *a1 = *v9;
    a1 = v9;
    v6 = v10;
  }
  while (v10 <= v8);
  return v9;
}

uint64_t sub_100344E70(uint64_t result, uint64_t a2, uint64_t (**a3)(uint64_t, uint64_t), uint64_t a4)
{
  unint64_t v4;
  uint64_t v6;
  unint64_t v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t *v11;

  v4 = a4 - 2;
  if (a4 >= 2)
  {
    v6 = result;
    v7 = v4 >> 1;
    v8 = (uint64_t *)(result + 8 * (v4 >> 1));
    v9 = (uint64_t *)(a2 - 8);
    result = (*a3)(*v8, *(_QWORD *)(a2 - 8));
    if ((_DWORD)result)
    {
      v10 = *v9;
      do
      {
        v11 = v8;
        *v9 = *v8;
        if (!v7)
          break;
        v7 = (v7 - 1) >> 1;
        v8 = (uint64_t *)(v6 + 8 * v7);
        result = (*a3)(*v8, v10);
        v9 = v11;
      }
      while ((result & 1) != 0);
      *v11 = v10;
    }
  }
  return result;
}

double sub_100344F0C(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8))
    sub_1018F4F80();
  return (float)(*(float *)(a1 + 12) - *(float *)(a2 + 12));
}

void sub_100344F40(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  double v15;
  double v16;
  double *v17;
  uint64_t v18;
  double v19;
  double v20;
  double v21;
  uint64_t v22;

  v12 = *a3;
  if (*((_BYTE *)a3 + 8))
    v12 = (~*(_BYTE *)(a1 + 56) & ~*(_DWORD *)(a2 + 56)) & v12 & 0x7F;
  v22 = v12;
  v13 = *(_QWORD **)(a1 + 16);
  if (v13)
  {
    v14 = 0;
    v15 = 0.0;
    v16 = 0.0;
    do
    {
      v17 = (double *)sub_100345964((_QWORD *)a2, (uint64_t)(v13 + 2));
      if (v17)
      {
        v18 = (uint64_t)(v17 + 2);
        if (sub_1003451F4(&v22, a6, (uint64_t)(v13 + 2), v17[2]))
        {
          v19 = (*(double (**)(uint64_t, _QWORD *))(*(_QWORD *)a5 + 16))(a5, v13 + 2);
          v20 = (*(double (**)(uint64_t, _QWORD *))(*(_QWORD *)a4 + 16))(a4, v13 + 2);
          v21 = sub_100344F0C((uint64_t)(v13 + 2), v18);
          v16 = v16 + v20 * v21 * (v20 * v21) * v19;
          ++v14;
          v15 = v15 + v19;
        }
      }
      v13 = (_QWORD *)*v13;
    }
    while (v13);
  }
  else
  {
    v14 = 0;
    v16 = 0.0;
    v15 = 0.0;
  }
  *(double *)a7 = v16;
  *(double *)(a7 + 8) = v15;
  *(_QWORD *)(a7 + 16) = v14;
}

uint64_t sub_100345080(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  double *v9;
  uint64_t v11;

  v6 = *a3;
  if (*((_BYTE *)a3 + 8))
    v6 = (~*(_BYTE *)(a1 + 56) & ~*(_DWORD *)(a2 + 56)) & v6 & 0x7F;
  v11 = v6;
  v7 = *(_QWORD **)(a1 + 16);
  if (!v7)
    return 0;
  v8 = 0;
  do
  {
    v9 = (double *)sub_100345964((_QWORD *)a2, (uint64_t)(v7 + 2));
    if (v9)
      v8 += sub_1003451F4(&v11, a4, (uint64_t)(v7 + 2), v9[2]);
    v7 = (_QWORD *)*v7;
  }
  while (v7);
  return v8;
}

uint64_t sub_10034512C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *i;
  uint64_t v14;

  v9 = *a4;
  if (*((_BYTE *)a4 + 8))
    v9 = (~*(_BYTE *)(a1 + 56) & ~*(_DWORD *)(a2 + 56)) & v9 & 0x7F;
  v14 = v9;
  v10 = *(_QWORD **)(a1 + 16);
  if (v10)
  {
    v11 = 0;
    do
    {
      v11 += sub_1003451F4(&v14, a5, (uint64_t)(v10 + 2), *(double *)(a2 + 144));
      v10 = (_QWORD *)*v10;
    }
    while (v10);
  }
  else
  {
    v11 = 0;
  }
  for (i = *(_QWORD **)(a2 + 16); i; i = (_QWORD *)*i)
    v11 += sub_1003451F4(&v14, a5, (uint64_t)(i + 2), *(double *)(a1 + 144));
  return v11 - a3;
}

BOOL sub_1003451F4(_QWORD *a1, uint64_t a2, uint64_t a3, double a4)
{
  unsigned int v4;
  double v6;

  v6 = a4;
  v4 = *(_DWORD *)(a3 + 8);
  if (v4 >= 7)
    sub_100263950("bitset test argument out of range");
  return ((*a1 >> v4) & 1) != 0 && (!*(_BYTE *)(a2 + 56) || (sub_1003A3D40(a2, a3, &v6) & 1) != 0);
}

double sub_100345260(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v13;
  _QWORD *v14;
  double v15;
  double v16;
  _QWORD *i;
  uint64_t v19;

  v13 = *a3;
  if (*((_BYTE *)a3 + 8))
    v13 = (~*(_BYTE *)(a1 + 56) & ~*(_DWORD *)(a2 + 56)) & v13 & 0x7F;
  v19 = v13;
  v14 = *(_QWORD **)(a1 + 16);
  if (v14)
  {
    v15 = 0.0;
    v16 = 0.0;
    do
    {
      if (sub_1003451F4(&v19, a7, (uint64_t)(v14 + 2), *(double *)(a2 + 144)))
      {
        if (sub_100345964((_QWORD *)a2, (uint64_t)(v14 + 2)))
          v16 = v16 + (*(double (**)(uint64_t, _QWORD *))(*(_QWORD *)a4 + 16))(a4, v14 + 2);
        else
          v15 = v15 + (*(double (**)(uint64_t, _QWORD *))(*(_QWORD *)a5 + 16))(a5, v14 + 2);
      }
      v14 = (_QWORD *)*v14;
    }
    while (v14);
  }
  else
  {
    v15 = 0.0;
  }
  for (i = *(_QWORD **)(a2 + 16); i; i = (_QWORD *)*i)
  {
    if (sub_1003451F4(&v19, a7, (uint64_t)(i + 2), *(double *)(a1 + 144))
      && !sub_100345964((_QWORD *)a1, (uint64_t)(i + 2))
      && ((*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)a6 + 16))(a6, i + 2) & 1) == 0)
    {
      v15 = v15 + (*(double (**)(uint64_t, _QWORD *))(*(_QWORD *)a5 + 16))(a5, i + 2);
    }
  }
  return v15;
}

double sub_1003453D8(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  double v5[2];
  unint64_t v6;

  sub_100344F40(a1, a2, a3, (uint64_t)&off_1022A07D8, (uint64_t)&off_1022A07F8, a4, (uint64_t)v5);
  if (v6)
    return sqrt(v5[0] / (double)v6);
  else
    return 1.79769313e308;
}

double sub_100345430(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;

  v8 = sub_100345080(a1, a2, a3, a4);
  v9 = sub_10034512C(a1, a2, v8, a3, a4);
  if (v9)
    return (double)(unint64_t)(v9 - v8) / (double)(unint64_t)v9;
  else
    return 1.79769313e308;
}

uint64_t sub_1003454A8(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  _QWORD v9[3];

  sub_100344F40(a1, a2, a3, (uint64_t)&off_1022A07D8, (uint64_t)&off_1022A07F8, a4, (uint64_t)v9);
  return sub_10034512C(a1, a2, v9[2], a3, a4);
}

double sub_100345594(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8, double a9, double a10, uint64_t a11)
{
  double v19;
  double v20;
  double v21;
  NSObject *v22;
  const char *v24;
  uint8_t *v25;
  __int16 v26;
  double v27;
  double v28;
  uint64_t v29;
  uint8_t buf[1640];

  if (!(*(_QWORD *)(a1 + 24) | *(_QWORD *)(a2 + 24)))
    return 1.79769313e308;
  sub_100344F40(a1, a2, a8, a3, a4, a11, (uint64_t)&v27);
  if (!v29)
    return a9;
  v19 = sub_100345260(a1, a2, a8, a5, a6, a7, a11);
  if (v28 == 0.0 || v20 == 0.0)
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130860);
    v22 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "euclidean denominator or jaccardDenominator are 0, this can only happen if weights are 0, check configuration!", buf, 2u);
    }
    if (sub_1001BFF7C(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130860);
      v26 = 0;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 16, "euclidean denominator or jaccardDenominator are 0, this can only happen if weights are 0, check configuration!", &v26, 2);
      v25 = (uint8_t *)v24;
      sub_100512490("Generic", 1, 0, 0, "double CLMicroLocationFingerprintDistanceFunction::weightedEuclideanJaccardDistance(const CLMicroLocationFingerprint &, const CLMicroLocationFingerprint &, double, double, const CLMicroLocationUtils::Weights<double> &, const CLMicroLocationUtils::Weights<double> &, const CLMicroLocationUtils::Weights<double> &, const CLMicroLocationUtils::Weights<double> &, const CLMicroLocationUtils::Weights<BOOL> &, const EnabledTechnologiesConfig &, const std::optional<CLMicroLocationAnchorAppearanceMap> &)", "%s\n", v24);
      if (v25 != buf)
        free(v25);
    }
    return 1.79769313e308;
  }
  if (a10 <= 0.0 || a10 > 1.0)
    sub_1018F50EC();
  v21 = v28 / (v28 + v20);
  if (a10 < 1.0)
    v21 = fmin(v21 / a10, 1.0);
  return v19 / v20 * a9 * (1.0 - v21) + sqrt(v27 / (double)(unint64_t)v28) * v21;
}

void sub_100345824(_QWORD *a1, _QWORD *a2, long double a3)
{
  float *v6;
  double v7;
  double v8;
  double v9;
  double v10;
  float *v11;
  long double v12;
  float *i;
  long double v14;

  v6 = (float *)a1[2];
  if (v6)
  {
    v7 = 0.0;
    v8 = 0.0;
    v9 = 0.0;
    do
    {
      v10 = pow(a3, v6[7]);
      v11 = (float *)sub_100345964(a2, (uint64_t)(v6 + 4));
      if (v11)
      {
        v12 = pow(a3, v11[7]);
        v8 = v8 + v10 * v12;
        v9 = v9 + v12 * v12;
      }
      v7 = v7 + v10 * v10;
      v6 = *(float **)v6;
    }
    while (v6);
  }
  else
  {
    v9 = 0.0;
  }
  for (i = (float *)a2[2]; i; i = *(float **)i)
  {
    if (!sub_100345964(a1, (uint64_t)(i + 4)))
    {
      v14 = pow(a3, i[7]);
      v9 = v9 + v14 * v14;
    }
  }
}

void sub_100345938(id a1)
{
  qword_1022A00F8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

_QWORD *sub_100345964(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;
  int8x8_t v5;
  unint64_t v6;
  uint8x8_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;

  v4 = sub_10038F5D0((uint64_t)(a1 + 3), a2);
  v5 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v5)
    return 0;
  v6 = v4;
  v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *(_QWORD *)&v5)
      v9 = v4 % *(_QWORD *)&v5;
  }
  else
  {
    v9 = (*(_QWORD *)&v5 - 1) & v4;
  }
  v10 = *(_QWORD **)(*a1 + 8 * v9);
  if (!v10)
    return 0;
  v11 = (_QWORD *)*v10;
  if (*v10)
  {
    v12 = (uint64_t)(a1 + 4);
    do
    {
      v13 = v11[1];
      if (v6 == v13)
      {
        if ((sub_10038F62C(v12, (uint64_t)(v11 + 2), a2) & 1) != 0)
          return v11;
      }
      else
      {
        if (v8 > 1)
        {
          if (v13 >= *(_QWORD *)&v5)
            v13 %= *(_QWORD *)&v5;
        }
        else
        {
          v13 &= *(_QWORD *)&v5 - 1;
        }
        if (v13 != v9)
          return 0;
      }
      v11 = (_QWORD *)*v11;
    }
    while (v11);
  }
  return v11;
}

uint64_t sub_100345A64(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  unint64_t v6;
  _DWORD *v7;
  int *v8;
  int v9;
  int v10;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  sub_10025EA00((_QWORD *)a1, *(const void **)a2, *(_QWORD *)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 3);
  *(_DWORD *)(a1 + 24) = 0;
  v4 = sub_100312E14((_QWORD *)(a1 + 32), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 3);
  v5 = *(_QWORD *)(a2 + 8) - *(_QWORD *)a2;
  if (v5)
  {
    v6 = v5 >> 3;
    v7 = (_DWORD *)*v4;
    if (v6 <= 1)
      v6 = 1;
    v8 = (int *)(*(_QWORD *)a2 + 4);
    do
    {
      v9 = *v8;
      v8 += 2;
      v10 = *(_DWORD *)(a1 + 24) + v9;
      *(_DWORD *)(a1 + 24) = v10;
      *v7++ = v10;
      --v6;
    }
    while (v6);
  }
  return a1;
}

void sub_100345AF8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100345B18@<X0>(uint64_t *result@<X0>, unint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  int *v4;
  unint64_t v5;
  uint64_t v6;
  int v7;
  _QWORD *v8;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v4 = (int *)*result;
  v5 = (result[1] - *result) >> 3;
  if (v5 >= a2)
    v5 = a2;
  v8 = a3;
  if (v5)
  {
    v6 = 8 * v5;
    do
    {
      v7 = *v4;
      result = sub_1002F4DA8((uint64_t *)&v8, &v7);
      v4 += 2;
      v6 -= 8;
    }
    while (v6);
  }
  return result;
}

void sub_100345B8C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t sub_100345BA8(__int32 **a1, __int32 **a2)
{
  __int32 *v2;
  __int32 *v3;
  __int32 *v5;
  __int32 *v6;
  __int32 *v7;
  const mach_header_64 *v8;
  uint64_t v9;

  v2 = *a1;
  v3 = a1[1];
  if (*a1 == v3)
  {
LABEL_8:
    v8 = 0;
    v9 = 0;
  }
  else
  {
    v5 = a2[1];
    while (1)
    {
      v6 = wmemchr(*a2, *v2, v5 - *a2);
      v7 = v6 ? v6 : v5;
      v5 = a2[1];
      if (v7 == v5)
        break;
      v2 += 2;
      if (v2 == v3)
        goto LABEL_8;
    }
    v9 = *v2;
    v8 = &_mh_execute_header;
  }
  return v9 | (unint64_t)v8;
}

uint64_t sub_100345C28(uint64_t *a1, __int32 **a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  __int32 *v6;
  __int32 *v7;
  __int32 *v8;
  uint64_t v9;

  v2 = *a1;
  v3 = a1[1];
  if (*a1 == v3)
    return 0;
  v5 = 0;
  v6 = a2[1];
  do
  {
    v7 = wmemchr(*a2, *(_DWORD *)v2, v6 - *a2);
    if (v7)
      v8 = v7;
    else
      v8 = v6;
    v6 = a2[1];
    if (v8 == v6)
      v9 = 0;
    else
      v9 = *(unsigned int *)(v2 + 4);
    v5 += v9;
    v2 += 8;
  }
  while (v2 != v3);
  return v5;
}

void sub_100345CB0(int **a1@<X0>, int **a2@<X1>, unint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  int *v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v9;
  uint64_t v10;
  int *v11;
  void *__p;
  uint64_t *v13;
  uint64_t v14;
  void *v15;
  uint64_t *v16;
  uint64_t v17;
  int v18;
  uint64_t *v19[3];

  v15 = 0;
  v16 = 0;
  v17 = 0;
  __p = 0;
  v13 = 0;
  v14 = 0;
  a4[1] = 0;
  a4[2] = 0;
  *a4 = 0;
  v5 = *a1;
  if (((char *)a2[1] - (char *)*a2) >> 3 >= (unint64_t)(((char *)a1[1] - (char *)*a1) >> 3))
    v6 = ((char *)a1[1] - (char *)*a1) >> 3;
  else
    v6 = ((char *)a2[1] - (char *)*a2) >> 3;
  if (v6 >= a3)
    v7 = a3;
  else
    v7 = v6;
  v19[0] = (uint64_t *)&v15;
  if (v7)
  {
    v9 = 8 * v7;
    v10 = 8 * v7;
    do
    {
      v18 = *v5;
      sub_1002F4DA8((uint64_t *)v19, &v18);
      v5 += 2;
      v10 -= 8;
    }
    while (v10);
    v11 = *a2;
    v19[0] = (uint64_t *)&__p;
    do
    {
      v18 = *v11;
      sub_1002F4DA8((uint64_t *)v19, &v18);
      v11 += 2;
      v9 -= 8;
    }
    while (v9);
  }
  std::__sort<std::__less<unsigned int,unsigned int> &,unsigned int *>(v15, v16, v19);
  std::__sort<std::__less<unsigned int,unsigned int> &,unsigned int *>(__p, v13, v19);
  sub_100345E68((uint64_t *)v15, v16, (uint64_t *)__p, v13, (uint64_t)a4, v19);
  if (__p)
  {
    v13 = (uint64_t *)__p;
    operator delete(__p);
  }
  if (v15)
  {
    v16 = (uint64_t *)v15;
    operator delete(v15);
  }
}

void sub_100345DDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  uint64_t v13;
  void *v15;

  v15 = *(void **)v13;
  if (*(_QWORD *)v13)
  {
    *(_QWORD *)(v13 + 8) = v15;
    operator delete(v15);
  }
  if (__p)
    operator delete(__p);
  if (a12)
    operator delete(a12);
  _Unwind_Resume(exception_object);
}

unint64_t sub_100345E24(uint64_t a1, __int32 **a2)
{
  uint64_t v3;
  unsigned int v4;

  v3 = sub_100345C28((uint64_t *)a1, a2);
  v4 = *(_DWORD *)(a1 + 24);
  if (v4)
    return COERCE_UNSIGNED_INT((float)(unint64_t)v3 / (float)v4) | (unint64_t)&_mh_execute_header;
  else
    return 0;
}

uint64_t *sub_100345E68@<X0>(uint64_t *result@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t *a4@<X3>, uint64_t a5@<X4>, uint64_t **a6@<X8>)
{
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;

  v11 = a5;
  if (result != a2)
  {
    v9 = a3;
    if (a3 != a4)
    {
      v10 = result;
      do
      {
        if (*(_DWORD *)v10 >= *(_DWORD *)v9)
        {
          if (*(_DWORD *)v9 >= *(_DWORD *)v10)
          {
            result = sub_1002F4DA8(&v11, v10);
            v10 = (uint64_t *)((char *)v10 + 4);
          }
          v9 = (uint64_t *)((char *)v9 + 4);
        }
        else
        {
          v10 = (uint64_t *)((char *)v10 + 4);
        }
      }
      while (v10 != a2 && v9 != a4);
      a5 = v11;
    }
  }
  *a6 = a2;
  a6[1] = a4;
  a6[2] = (uint64_t *)a5;
  return result;
}

BOOL sub_100345F10(_QWORD *a1, _QWORD *a2)
{
  return *a1 != *a2 || a1[1] != a2[1];
}

uint64_t sub_100345F3C(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*a1 + 24))(*a1, a1[1]);
}

uint64_t sub_100345F50(uint64_t result)
{
  ++*(_QWORD *)(result + 8);
  return result;
}

_QWORD *sub_100345F60(_QWORD *result, uint64_t *a2)
{
  uint64_t v2;

  v2 = *a2;
  *a2 = 0;
  *result = v2;
  return result;
}

uint64_t sub_100345F70(_QWORD *a1, unint64_t a2)
{
  if ((*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 16))(*a1) <= a2)
    sub_1018F5258();
  return (*(uint64_t (**)(_QWORD, unint64_t))(*(_QWORD *)*a1 + 24))(*a1, a2);
}

uint64_t sub_100345FC0(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 16))(*a1);
}

BOOL sub_100345FD0(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 16))(*a1) == 0;
}

uint64_t sub_100345FF8(uint64_t a1)
{
  return *(_QWORD *)a1;
}

uint64_t sub_100346004(_QWORD *a1)
{
  uint64_t v1;

  v1 = *a1;
  (*(void (**)(_QWORD))(*(_QWORD *)*a1 + 16))(*a1);
  return v1;
}

void sub_100346038(id a1)
{
  qword_1022A00F8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

uint64_t sub_10034609C@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  double v13;
  double v14;
  CFStringRef v15;
  int v16;
  unsigned int v17;
  std::__shared_weak_count *v18;
  unint64_t *p_shared_owners;
  unint64_t v20;
  uint64_t v21;
  uint64_t result;
  _QWORD v23[2];
  uint64_t *v24;
  _QWORD v25[2];
  uint64_t v26;
  std::__shared_weak_count *v27;

  if (sub_1002EFEB8(a1))
  {
    if (*(_BYTE *)(a3 + 32))
    {
      *(_QWORD *)a5 = 0;
      *(_QWORD *)(a5 + 8) = 0;
      *(_QWORD *)(a5 + 16) = 0;
      *(_DWORD *)(a5 + 24) = 3;
      *(_BYTE *)(a5 + 80) = 0;
      *(_QWORD *)(a5 + 40) = 0;
      *(_QWORD *)(a5 + 48) = 0;
      *(_QWORD *)(a5 + 32) = 0;
      *(_BYTE *)(a5 + 56) = 0;
      v25[0] = 0;
      v25[1] = 0;
      v24 = v25;
      v11 = *(_QWORD **)(a1 + 232);
      v10 = *(_QWORD **)(a1 + 240);
      while (v11 != v10)
      {
        v12 = *(_QWORD *)(a3 + 24);
        if (!v12)
          sub_10025FD1C();
        v26 = (*(double (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v12 + 48))(v12, *v11, a2);
        sub_10009E97C(&v24, (double *)&v26);
        v11 += 4;
      }
      v13 = sub_100263814(a4);
      v14 = sub_10026383C(a4);
      sub_1001E4804(&v26);
      LODWORD(v23[0]) = 0;
      v15 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsNullSpaceDistanceReductionFunction", 0x8000100u, kCFAllocatorNull);
      v16 = sub_1000B1180(v26, (uint64_t)v15, v23);
      CFRelease(v15);
      v17 = v23[0];
      v18 = v27;
      if (v27)
      {
        p_shared_owners = (unint64_t *)&v27->__shared_owners_;
        do
          v20 = __ldaxr(p_shared_owners);
        while (__stlxr(v20 - 1, p_shared_owners));
        if (!v20)
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
      }
      if (v16)
        v21 = v17;
      else
        v21 = 5;
      sub_1003465E0(v21, 0, (uint64_t)&v26, v13, v14);
      sub_100263868(a4, v23);
      sub_10029822C((uint64_t)v23);
    }
    result = sub_1018F5428();
  }
  else
  {
    result = sub_1018F5594();
  }
  __break(1u);
  return result;
}

void sub_100346508(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, _QWORD *a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,char *a21)
{
  uint64_t v21;
  char *v23;
  uint64_t v24;

  if (a14)
    (*(void (**)(uint64_t))(*(_QWORD *)a14 + 8))(a14);
  v23 = a21;
  if (a21 == &a18)
  {
    v24 = 4;
    v23 = &a18;
  }
  else
  {
    if (!a21)
      goto LABEL_8;
    v24 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v23 + 8 * v24))();
LABEL_8:
  sub_100008848((uint64_t)&a15, a16);
  sub_100261E8C(v21);
  _Unwind_Resume(a1);
}

void sub_1003465E0(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>, double a4@<D0>, double a5@<D1>)
{
  void *v5;
  void *v6;

  switch((int)a1)
  {
    case 0:
      if (a2 == 1)
      {
        v5 = sub_10034677C;
      }
      else if (a2)
      {
LABEL_5:
        v5 = sub_1003467F8;
      }
      else
      {
        v5 = sub_100346758;
      }
      goto LABEL_23;
    case 1:
      goto LABEL_5;
    case 2:
      if (a2 == 1)
      {
        v5 = sub_1003468BC;
      }
      else
      {
        if (a2)
          goto LABEL_17;
        v5 = sub_100346870;
      }
      goto LABEL_23;
    case 3:
      if (!a2)
      {
        v5 = sub_100346938;
LABEL_23:
        *(_QWORD *)a3 = off_102130950;
        *(_QWORD *)(a3 + 8) = v5;
        goto LABEL_24;
      }
      if (a2 != 1)
      {
LABEL_17:
        *(_QWORD *)(a3 + 24) = 0;
        return;
      }
      a1 = sub_1018F58D8();
LABEL_12:
      if (!a2)
      {
        v5 = sub_100346984;
        goto LABEL_23;
      }
      if (a2 != 1)
        goto LABEL_17;
      a1 = sub_1018F5A44(a1);
LABEL_15:
      if (!a2)
      {
        *(_QWORD *)a3 = off_102130A00;
        *(double *)(a3 + 8) = a4;
        *(double *)(a3 + 16) = a5;
LABEL_24:
        *(_QWORD *)(a3 + 24) = a3;
        return;
      }
      if (a2 != 1)
        goto LABEL_17;
      v6 = (void *)sub_1018F5BB0(a1);
      sub_10034672C(v6);
      return;
    case 4:
      goto LABEL_12;
    case 5:
      goto LABEL_15;
    default:
      sub_1018F5700();
  }
}

void sub_10034672C(id a1)
{
  qword_1022A00F8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

double sub_100346758(_QWORD *a1)
{
  if (!a1[2])
    sub_1018F5D1C();
  return *(double *)(*a1 + 32);
}

double sub_10034677C(_QWORD *a1)
{
  double *v1;
  double *v2;
  double *v3;
  double *v4;
  double *v5;
  double *v6;
  BOOL v7;

  if (!a1[2])
    sub_1018F5D44();
  v3 = (double *)*a1;
  v1 = (double *)(a1 + 1);
  v2 = v3;
  if (v3 != v1)
  {
    v4 = v2;
    while (1)
    {
      v5 = (double *)*((_QWORD *)v4 + 1);
      v6 = v4;
      if (v5)
      {
        do
        {
          v4 = v5;
          v5 = *(double **)v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          v4 = (double *)*((_QWORD *)v6 + 2);
          v7 = *(_QWORD *)v4 == (_QWORD)v6;
          v6 = v4;
        }
        while (!v7);
      }
      if (v4 == v1)
        break;
      if (v4[4] < v2[4])
        v2 = v4;
    }
  }
  return v2[4];
}

double sub_1003467F8(_QWORD *a1)
{
  unint64_t v1;
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  double v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  BOOL v9;

  v1 = a1[2];
  if (!v1)
    sub_1018F5D6C();
  v4 = (_QWORD *)*a1;
  v2 = a1 + 1;
  v3 = v4;
  v5 = 0.0;
  if (v4 != v2)
  {
    do
    {
      v6 = (_QWORD *)v3[1];
      v7 = v3;
      if (v6)
      {
        do
        {
          v8 = v6;
          v6 = (_QWORD *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          v8 = (_QWORD *)v7[2];
          v9 = *v8 == (_QWORD)v7;
          v7 = v8;
        }
        while (!v9);
      }
      v5 = v5 + *((double *)v3 + 4);
      v3 = v8;
    }
    while (v8 != v2);
  }
  return v5 / (double)v1;
}

double sub_100346870(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  BOOL v5;

  if (!*(_QWORD *)(a1 + 16))
    sub_1018F5D94();
  v3 = *(_QWORD *)(a1 + 8);
  v1 = a1 + 8;
  v2 = v3;
  if (v3)
  {
    do
    {
      v4 = v2;
      v2 = *(_QWORD *)(v2 + 8);
    }
    while (v2);
  }
  else
  {
    do
    {
      v4 = *(_QWORD *)(v1 + 16);
      v5 = *(_QWORD *)v4 == v1;
      v1 = v4;
    }
    while (v5);
  }
  return *(double *)(v4 + 32);
}

double sub_1003468BC(_QWORD *a1)
{
  double *v1;
  double *v2;
  double *v3;
  double *v4;
  double *v5;
  double *v6;
  BOOL v7;

  if (!a1[2])
    sub_1018F5DBC();
  v3 = (double *)*a1;
  v1 = (double *)(a1 + 1);
  v2 = v3;
  if (v3 != v1)
  {
    v4 = v2;
    while (1)
    {
      v5 = (double *)*((_QWORD *)v4 + 1);
      v6 = v4;
      if (v5)
      {
        do
        {
          v4 = v5;
          v5 = *(double **)v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          v4 = (double *)*((_QWORD *)v6 + 2);
          v7 = *(_QWORD *)v4 == (_QWORD)v6;
          v6 = v4;
        }
        while (!v7);
      }
      if (v4 == v1)
        break;
      if (v2[4] < v4[4])
        v2 = v4;
    }
  }
  return v2[4];
}

double sub_100346938(uint64_t a1)
{
  unint64_t v1;
  double *v3;

  v1 = *(_QWORD *)(a1 + 16);
  if (!v1)
    sub_1018F5DE4();
  v3 = *(double **)a1;
  sub_100346A7C((_QWORD **)&v3, llround((double)v1 * 0.25));
  return v3[4];
}

double sub_100346984(uint64_t a1)
{
  unint64_t v1;
  double *v3;

  v1 = *(_QWORD *)(a1 + 16);
  if (!v1)
    sub_1018F5E0C();
  v3 = *(double **)a1;
  sub_100346A7C((_QWORD **)&v3, llround((double)v1 * 0.5));
  return v3[4];
}

_QWORD *sub_1003469D0(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_102130950;
  result[1] = v3;
  return result;
}

uint64_t sub_100346A08(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_102130950;
  a2[1] = v2;
  return result;
}

uint64_t sub_100346A28(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
}

uint64_t sub_100346A34(uint64_t a1, uint64_t a2)
{
  if (sub_100270DE8(a2, (uint64_t)&off_1021309D0))
    return a1 + 8;
  else
    return 0;
}

_UNKNOWN **sub_100346A70()
{
  return &off_1021309D0;
}

_QWORD **sub_100346A7C(_QWORD **result, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  BOOL v5;
  _QWORD *v7;
  _QWORD *v8;

  if (a2 < 0)
  {
    v7 = *result;
    do
    {
      v8 = (_QWORD *)*v7;
      if (*v7)
      {
        do
        {
          v4 = v8;
          v8 = (_QWORD *)v8[1];
        }
        while (v8);
      }
      else
      {
        do
        {
          v4 = (_QWORD *)v7[2];
          v5 = *v4 == (_QWORD)v7;
          v7 = v4;
        }
        while (v5);
      }
      v7 = v4;
    }
    while (!__CFADD__(a2++, 1));
  }
  else
  {
    if (!a2)
      return result;
    v2 = *result;
    do
    {
      v3 = (_QWORD *)v2[1];
      if (v3)
      {
        do
        {
          v4 = v3;
          v3 = (_QWORD *)*v3;
        }
        while (v3);
      }
      else
      {
        do
        {
          v4 = (_QWORD *)v2[2];
          v5 = *v4 == (_QWORD)v2;
          v2 = v4;
        }
        while (!v5);
      }
      v2 = v4;
    }
    while (a2-- > 1);
  }
  *result = v4;
  return result;
}

__n128 sub_100346B08(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = off_102130A00;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100346B44(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = off_102130A00;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

double sub_100346B68(uint64_t a1, uint64_t a2)
{
  return sub_100346BBC(a2, *(double *)(a1 + 8), *(double *)(a1 + 16));
}

uint64_t sub_100346B74(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100346BB0()
{
}

double sub_100346BBC(uint64_t a1, double a2, double a3)
{
  unint64_t v3;
  BOOL v4;
  BOOL v5;
  uint64_t v6;
  int64_t v7;
  uint64_t v8;
  double *v9;
  double v10;
  double *v11;
  double *v12;
  double *v13;
  BOOL v14;
  double *v16;

  v3 = *(_QWORD *)(a1 + 16);
  if (!v3)
    sub_1018F5E34();
  if (a3 > 1.0 || (a2 >= 0.0 ? (v4 = a2 > 1.0) : (v4 = 1), !v4 ? (v5 = a3 < a2) : (v5 = 1), v5))
    sub_1018F5E5C();
  v6 = llround(floor((double)v3 * a2));
  v7 = llround(ceil((double)v3 * a3));
  v8 = v7 - v6;
  if (v7 <= v6)
    sub_1018F5E84();
  v16 = *(double **)a1;
  sub_100346A7C((_QWORD **)&v16, v6);
  v9 = v16;
  sub_100346A7C((_QWORD **)&v16, v8);
  v10 = 0.0;
  if (v9 != v16)
  {
    do
    {
      v11 = (double *)*((_QWORD *)v9 + 1);
      v12 = v9;
      if (v11)
      {
        do
        {
          v13 = v11;
          v11 = *(double **)v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          v13 = (double *)*((_QWORD *)v12 + 2);
          v14 = *(_QWORD *)v13 == (_QWORD)v12;
          v12 = v13;
        }
        while (!v14);
      }
      v10 = v10 + v9[4];
      v9 = v13;
    }
    while (v13 != v16);
  }
  return v10 / (double)v8;
}

uint64_t sub_100346CB0(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = a1 + 8;
  sub_100346D04((char *)a1, *(_QWORD **)a2, (_QWORD *)(a2 + 8));
  return a1;
}

void sub_100346CEC(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_100008848(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

char *sub_100346D04(char *result, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v4;
  uint64_t **v5;
  double *v6;
  _QWORD *v7;
  _QWORD *v8;
  BOOL v9;

  if (a2 != a3)
  {
    v4 = a2;
    v5 = (uint64_t **)result;
    v6 = (double *)(result + 8);
    do
    {
      result = (char *)sub_100346D84(v5, v6, v4 + 4);
      v7 = (_QWORD *)v4[1];
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = (_QWORD *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (_QWORD *)v4[2];
          v9 = *v8 == (_QWORD)v4;
          v4 = v8;
        }
        while (!v9);
      }
      v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

void *sub_100346D84(uint64_t **a1, double *a2, _QWORD *a3)
{
  void *v6;
  double *v7;
  double *v9;

  v6 = operator new(0x28uLL);
  *((_QWORD *)v6 + 4) = *a3;
  v7 = sub_1002F3F54(a1, a2, &v9, (double *)v6 + 4);
  sub_1000145B0(a1, (uint64_t)v9, (uint64_t **)v7, (uint64_t *)v6);
  return v6;
}

void sub_100346DF8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

__n128 sub_100346E0C(__n128 *a1, __n128 *a2, unint64_t a3, unint64_t a4)
{
  __n128 result;

  result = *a2;
  *a1 = *a2;
  a1[1].n128_u64[0] = a3;
  a1[1].n128_u64[1] = a4;
  return result;
}

void *sub_100346E1C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  void *result;
  uint64_t v3;
  __int128 *v4;

  v3 = *(_QWORD *)(a1 + 24);
  result = (void *)(a1 + 24);
  switch(v3)
  {
    case 1:
      v4 = &xmmword_102310470;
      break;
    case 2:
    case 3:
      v4 = &xmmword_102310488;
      break;
    case 4:
      v4 = &xmmword_1023104B8;
      break;
    default:
      sub_1018F5EAC();
  }
  if (*((char *)v4 + 23) < 0)
    return sub_100115CE4((_BYTE *)a2, *(void **)v4, *((_QWORD *)v4 + 1));
  *(_OWORD *)a2 = *v4;
  *(_QWORD *)(a2 + 16) = *((_QWORD *)v4 + 2);
  return result;
}

uint64_t sub_100346EA0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, __int128 *a8, uint64_t a9)
{
  __int128 v11;
  _BYTE *v12;
  __int128 v13;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a3;
  *(_QWORD *)(a1 + 16) = a4;
  *(_QWORD *)(a1 + 24) = a5;
  *(_QWORD *)(a1 + 32) = a6;
  if (*((char *)a7 + 23) < 0)
  {
    sub_100115CE4((_BYTE *)(a1 + 40), *(void **)a7, *((_QWORD *)a7 + 1));
  }
  else
  {
    v11 = *a7;
    *(_QWORD *)(a1 + 56) = *((_QWORD *)a7 + 2);
    *(_OWORD *)(a1 + 40) = v11;
  }
  v12 = (_BYTE *)(a1 + 64);
  if (*((char *)a8 + 23) < 0)
  {
    sub_100115CE4(v12, *(void **)a8, *((_QWORD *)a8 + 1));
  }
  else
  {
    v13 = *a8;
    *(_QWORD *)(a1 + 80) = *((_QWORD *)a8 + 2);
    *(_OWORD *)v12 = v13;
  }
  *(_BYTE *)(a1 + 296) = 0;
  *(_BYTE *)(a1 + 368) = 0;
  *(_BYTE *)(a1 + 440) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_BYTE *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_BYTE *)(a1 + 352) = 0;
  *(_BYTE *)(a1 + 424) = 0;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_QWORD *)(a1 + 448) = a9;
  *(_WORD *)(a1 + 456) = 0;
  *(_QWORD *)(a1 + 88) = 1;
  sub_100346F9C((_QWORD *)(a1 + 96));
  return a1;
}

void sub_100346F80(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 63) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

void sub_100346F9C(_QWORD *a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = (std::__shared_weak_count *)a1[1];
  *a1 = 0;
  a1[1] = 0;
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

unint64_t sub_100346FF8(unint64_t result)
{
  if (HIDWORD(result))
    sub_1018F6028();
  return result;
}

uint64_t sub_100347010(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  void *__p[2];
  uint64_t v14;
  void *__dst[2];
  uint64_t v16;

  v9 = *(_QWORD *)(a3 + 8);
  v8 = *(_QWORD *)(a3 + 16);
  v10 = *(_QWORD *)a3;
  v11 = *(_QWORD *)(a3 + 56);
  sub_100346FF8(v11);
  if (*(char *)(a3 + 55) < 0)
  {
    sub_100115CE4(__dst, *(void **)(a3 + 32), *(_QWORD *)(a3 + 40));
  }
  else
  {
    *(_OWORD *)__dst = *(_OWORD *)(a3 + 32);
    v16 = *(_QWORD *)(a3 + 48);
  }
  if (*(char *)(a3 + 87) < 0)
  {
    sub_100115CE4(__p, *(void **)(a3 + 64), *(_QWORD *)(a3 + 72));
  }
  else
  {
    *(_OWORD *)__p = *(_OWORD *)(a3 + 64);
    v14 = *(_QWORD *)(a3 + 80);
  }
  sub_100346EA0(a1, a2, v9, v8, v10, v11, (__int128 *)__dst, (__int128 *)__p, a4);
  if (SHIBYTE(v14) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v16) < 0)
    operator delete(__dst[0]);
  return a1;
}

void sub_100347110(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_100347144(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t sub_100347150(uint64_t a1)
{
  return a1 + 40;
}

uint64_t sub_100347158(uint64_t a1)
{
  return a1 + 64;
}

_QWORD *sub_100347160@<X0>(_QWORD *result@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  if (result == (_QWORD *)1)
    return sub_1015A2E04(a3, "kMiLoClientIdentifierUnsupervisedShared");
  if (*(char *)(a2 + 23) < 0)
    return sub_100115CE4(a3, *(void **)a2, *(_QWORD *)(a2 + 8));
  *(_OWORD *)a3 = *(_OWORD *)a2;
  a3[2] = *(_QWORD *)(a2 + 16);
  return result;
}

_QWORD *sub_1003471A4@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  return sub_100347160(*(_QWORD **)(a1 + 24), a1 + 40, a2);
}

uint64_t sub_1003471B4(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

uint64_t sub_1003471BC(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

uint64_t sub_1003471C4(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x20)
    sub_100263950("bitset test argument out of range");
  return (*(_QWORD *)(a1 + 32) >> a2) & 1;
}

uint64_t sub_1003471F4(uint64_t result, unint64_t a2)
{
  if (a2 >= 0x20)
    sub_100263950("bitset set argument out of range");
  *(_QWORD *)(result + 32) |= 1 << a2;
  return result;
}

void sub_10034722C(char *a1, _OWORD *a2)
{
  _QWORD *v4;
  int v5;
  NSObject *v6;
  _OWORD *v7;
  char *p_p;
  char *v9;
  char *v10;
  uint64_t v11;
  NSObject *v12;
  char *v13;
  _QWORD *v14;
  char *v15;
  NSObject *v16;
  char *v17;
  _QWORD *v18;
  char *v19;
  void *__p;
  __int128 v21;
  _BYTE buf[18];
  __int16 v23;
  char *v24;
  __int16 v25;
  _QWORD *v26;
  __int16 v27;
  char *v28;
  __int16 v29;
  char *v30;
  __int16 v31;
  int v32;

  if (a1[296])
  {
    v4 = a1 + 40;
    v5 = (*(uint64_t (**)(void))(**(_QWORD **)a1 + 88))();
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130A70);
    v6 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      v7 = operator new(0x28uLL);
      __p = v7;
      v21 = xmmword_101B97FF0;
      *v7 = 0u;
      v7[1] = 0u;
      *(_QWORD *)((char *)v7 + 29) = 0;
      sub_100261F9C((uint64_t)(a1 + 8), v7);
      if (v21 >= 0)
        p_p = (char *)&__p;
      else
        p_p = (char *)__p;
      if (a1[63] < 0)
        v4 = (_QWORD *)*v4;
      if (!a1[296])
        sub_10028DF3C();
      v9 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v9 + 29) = 0;
      *(_OWORD *)v9 = 0u;
      *((_OWORD *)v9 + 1) = 0u;
      sub_100261F9C((uint64_t)(a1 + 280), v9);
      v10 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v10 + 29) = 0;
      *(_OWORD *)v10 = 0u;
      *((_OWORD *)v10 + 1) = 0u;
      sub_100261F9C((uint64_t)a2, v10);
      *(_DWORD *)buf = 68290306;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      v23 = 2082;
      v24 = p_p;
      v25 = 2082;
      v26 = v4;
      v27 = 2082;
      v28 = v9;
      v29 = 2082;
      v30 = v10;
      v31 = 1026;
      v32 = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService sending cached results to client: \", \"ServiceId\":%{public, location:escape_only}s, \"ClientId\":%{public, location:escape_only}s, \"Cached LocalizationId\":%{public, location:escape_only}s, \"RequestId\":%{public, location:escape_only}s, \"Succeeded to save trigger\":%{public}hhd}", buf, 0x40u);
      operator delete(v10);
      operator delete(v9);
      if (SHIBYTE(v21) < 0)
        operator delete(__p);
    }
    v11 = *(_QWORD *)a1;
    *(_OWORD *)buf = *a2;
    buf[16] = 1;
    if (!a1[296])
      sub_10028DF3C();
    (*(void (**)(uint64_t, char *, _BYTE *, char *))(*(_QWORD *)v11 + 32))(v11, a1 + 8, buf, a1 + 112);
  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130A70);
    v12 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      v13 = (char *)operator new(0x28uLL);
      *(_OWORD *)v13 = 0u;
      *((_OWORD *)v13 + 1) = 0u;
      *(_QWORD *)(v13 + 29) = 0;
      sub_100261F9C((uint64_t)(a1 + 8), v13);
      v14 = a1 + 40;
      if (a1[63] < 0)
        v14 = (_QWORD *)*v14;
      v15 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v15 + 29) = 0;
      *(_OWORD *)v15 = 0u;
      *((_OWORD *)v15 + 1) = 0u;
      sub_100261F9C((uint64_t)a2, v15);
      *(_DWORD *)buf = 68289794;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      v23 = 2082;
      v24 = v13;
      v25 = 2082;
      v26 = v14;
      v27 = 2082;
      v28 = v15;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"CLMiLoService tried to send cached results to client but no cache available:\", \"ServiceId\":%{public, location:escape_only}s, \"ClientId\":%{public, location:escape_only}s, \"RequestId\":%{public, location:escape_only}s}", buf, 0x30u);
      operator delete(v15);
      operator delete(v13);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130A70);
    }
    v16 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      v17 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v17 + 29) = 0;
      *(_OWORD *)v17 = 0u;
      *((_OWORD *)v17 + 1) = 0u;
      sub_100261F9C((uint64_t)(a1 + 8), v17);
      v18 = a1 + 40;
      if (a1[63] < 0)
        v18 = (_QWORD *)*v18;
      v19 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v19 + 29) = 0;
      *(_OWORD *)v19 = 0u;
      *((_OWORD *)v19 + 1) = 0u;
      sub_100261F9C((uint64_t)a2, v19);
      *(_DWORD *)buf = 68289794;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      v23 = 2082;
      v24 = v17;
      v25 = 2082;
      v26 = v18;
      v27 = 2082;
      v28 = v19;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLMiLoService tried to send cached results to client but no cache available:", "{\"msg%{public}.0s\":\"CLMiLoService tried to send cached results to client but no cache available:\", \"ServiceId\":%{public, location:escape_only}s, \"ClientId\":%{public, location:escape_only}s, \"RequestId\":%{public, location:escape_only}s}", buf, 0x30u);
      operator delete(v19);
      operator delete(v17);
    }
  }
}

void sub_1003476A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  void *v15;
  void *v16;

  operator delete(v15);
  operator delete(v16);
  _Unwind_Resume(a1);
}

void sub_100347730(int64x2_t *a1, uint64_t a2, unsigned __int8 a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  __int128 v8;
  BOOL v9;
  NSObject *v10;
  _OWORD *v11;
  char *v12;
  _OWORD *v13;
  char *v14;
  uint64_t v15;
  NSObject *v16;
  _OWORD *v17;
  char *v18;
  _OWORD *v19;
  char *v20;
  _OWORD *v21;
  char *v22;
  NSObject *v23;
  char *v24;
  char *v25;
  char *v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t *v29;
  NSObject *v30;
  _OWORD *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  char *v35;
  _OWORD *v36;
  uint64_t *v37;
  char *v38;
  _OWORD *v39;
  char *v40;
  uint64_t v41;
  uint64_t i64;
  void *v43;
  __int128 v44;
  void *v45;
  __int128 v46;
  void *v47;
  __int128 v48;
  void *v49[9];
  char v50;
  char v51;
  _BYTE v52[56];
  void *v53;
  void *v54;
  __int128 v55;
  _BYTE buf[18];
  __int16 v57;
  char *v58;
  __int16 v59;
  char *v60;
  __int16 v61;
  char *v62;
  void *v63;
  char v64;
  char v65;
  _BYTE v66[56];
  void *__p;
  void *v68;
  __int128 v69;
  __int128 v70;

  *(_QWORD *)&v70 = a4;
  *((_QWORD *)&v70 + 1) = a5;
  if (!a1[5].i64[1])
  {
    v7 = a3;
    if (a3 && (!a1[28].i8[9] || !a1[28].i8[8] || (sub_100348114() & 1) == 0))
    {
      sub_10031BEF8((uint64_t)v49, a2);
      v8 = v70;
      sub_10031BEF8((uint64_t)buf, (uint64_t)v49);
      v69 = v8;
      sub_1003481F0((uint64_t)a1[7].i64, (uint64_t)buf);
      if (__p)
      {
        v68 = __p;
        operator delete(__p);
      }
      if (v66[40])
        sub_1002A1C94((uint64_t)v66);
      if (v65 && v64 < 0)
        operator delete(v63);
      if (*(_QWORD *)buf)
      {
        *(_QWORD *)&buf[8] = *(_QWORD *)buf;
        operator delete(*(void **)buf);
      }
      if (v53)
      {
        v54 = v53;
        operator delete(v53);
      }
      if (v52[40])
        sub_1002A1C94((uint64_t)v52);
      if (v51 && v50 < 0)
        operator delete(v49[7]);
      if (v49[0])
      {
        v49[1] = v49[0];
        operator delete(v49[0]);
      }
    }
    i64 = (uint64_t)a1[22].i64;
    if (a1[23].i8[0] && (a1[22].i64[0] == (_QWORD)v70 ? (v9 = a1[22].i64[1] == *((_QWORD *)&v70 + 1)) : (v9 = 0), v9))
    {
      a1[23].i8[0] = 0;
      if (v7)
      {
        if (a1[21].i64[1])
        {
          v27 = (uint64_t)a1[19].i64;
          v28 = &qword_1022A0000;
          v29 = &qword_1022A0000;
          do
          {
            v55 = *(_OWORD *)(*(_QWORD *)(a1[19].i64[1] + 8 * (a1[21].i64[0] / 0x7CuLL)) + 33
                                                                                         * (a1[21].i64[0] % 0x7CuLL));
            if (v28[30] != -1)
              dispatch_once(&qword_1022A00F0, &stru_102130A70);
            v30 = v29[31];
            if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
            {
              v31 = operator new(0x28uLL);
              v32 = v27;
              v33 = a2;
              v47 = v31;
              v48 = xmmword_101B97FF0;
              *v31 = 0u;
              v31[1] = 0u;
              *(_QWORD *)((char *)v31 + 29) = 0;
              sub_100261F9C((uint64_t)&a1->i64[1], v31);
              v34 = v29;
              if (v48 >= 0)
                v35 = (char *)&v47;
              else
                v35 = (char *)v47;
              v36 = operator new(0x28uLL);
              v37 = v28;
              v45 = v36;
              v46 = xmmword_101B97FF0;
              *v36 = 0u;
              v36[1] = 0u;
              *(_QWORD *)((char *)v36 + 29) = 0;
              sub_100261F9C((uint64_t)&v70, v36);
              if (v46 >= 0)
                v38 = (char *)&v45;
              else
                v38 = (char *)v45;
              v39 = operator new(0x28uLL);
              v43 = v39;
              v44 = xmmword_101B97FF0;
              *v39 = 0u;
              v39[1] = 0u;
              *(_QWORD *)((char *)v39 + 29) = 0;
              sub_100261F9C((uint64_t)&v55, v39);
              v40 = (char *)&v43;
              if (v44 < 0)
                v40 = (char *)v43;
              *(_DWORD *)buf = 68289794;
              *(_DWORD *)&buf[4] = 0;
              *(_WORD *)&buf[8] = 2082;
              *(_QWORD *)&buf[10] = "";
              v57 = 2082;
              v58 = v35;
              v59 = 2082;
              v60 = v38;
              v61 = 2082;
              v62 = v40;
              _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService received localization results, sending results to client: \", \"ServiceId\":%{public, location:escape_only}s, \"LocalizationId\":%{public, location:escape_only}s, \"RequestId\":%{public, location:escape_only}s}", buf, 0x30u);
              if (SHIBYTE(v44) < 0)
                operator delete(v43);
              v28 = v37;
              if (SHIBYTE(v46) < 0)
                operator delete(v45);
              v29 = v34;
              if (SHIBYTE(v48) < 0)
                operator delete(v47);
              a2 = v33;
              v27 = v32;
            }
            v41 = a1->i64[0];
            *(_OWORD *)buf = v55;
            buf[16] = 1;
            (*(void (**)(uint64_t, uint64_t *, _BYTE *, uint64_t))(*(_QWORD *)v41 + 32))(v41, &a1->i64[1], buf, a2);
            a1[21] = vaddq_s64(a1[21], (int64x2_t)xmmword_101B9DFC0);
            sub_10034EE18(v27, 1);
          }
          while (a1[21].i64[1]);
        }
      }
      else
      {
        sub_10034828C(a1, 3);
      }
    }
    else if (v7 && a1[28].i8[9])
    {
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130A70);
      v10 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        v11 = operator new(0x28uLL);
        v47 = v11;
        v48 = xmmword_101B97FF0;
        *v11 = 0u;
        v11[1] = 0u;
        *(_QWORD *)((char *)v11 + 29) = 0;
        sub_100261F9C((uint64_t)&a1->i64[1], v11);
        if (v48 >= 0)
          v12 = (char *)&v47;
        else
          v12 = (char *)v47;
        v13 = operator new(0x28uLL);
        v45 = v13;
        v46 = xmmword_101B97FF0;
        *v13 = 0u;
        v13[1] = 0u;
        *(_QWORD *)((char *)v13 + 29) = 0;
        sub_100261F9C((uint64_t)&v70, v13);
        v14 = (char *)&v45;
        if (v46 < 0)
          v14 = (char *)v45;
        *(_DWORD *)buf = 68289538;
        *(_DWORD *)&buf[4] = 0;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = "";
        v57 = 2082;
        v58 = v12;
        v59 = 2082;
        v60 = v14;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService received localization results, reporting to client with service updating params\", \"ServiceId\":%{public, location:escape_only}s, \"LocalizationId\":%{public, location:escape_only}s}", buf, 0x26u);
        if (SHIBYTE(v46) < 0)
          operator delete(v45);
        if (SHIBYTE(v48) < 0)
          operator delete(v47);
      }
      v15 = a1->i64[0];
      *(_OWORD *)buf = v70;
      buf[16] = 1;
      (*(void (**)(uint64_t, uint64_t *, _BYTE *, uint64_t))(*(_QWORD *)v15 + 32))(v15, &a1->i64[1], buf, a2);
    }
    if (a1[23].i8[0])
    {
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130A70);
      v16 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
      {
        v17 = operator new(0x28uLL);
        v47 = v17;
        v48 = xmmword_101B97FF0;
        *v17 = 0u;
        v17[1] = 0u;
        *(_QWORD *)((char *)v17 + 29) = 0;
        sub_100261F9C((uint64_t)&a1->i64[1], v17);
        if (v48 >= 0)
          v18 = (char *)&v47;
        else
          v18 = (char *)v47;
        if (!a1[23].i8[0])
          sub_10028DF3C();
        v19 = operator new(0x28uLL);
        v45 = v19;
        v46 = xmmword_101B97FF0;
        *v19 = 0u;
        v19[1] = 0u;
        *(_QWORD *)((char *)v19 + 29) = 0;
        sub_100261F9C(i64, v19);
        if (v46 >= 0)
          v20 = (char *)&v45;
        else
          v20 = (char *)v45;
        v21 = operator new(0x28uLL);
        v43 = v21;
        v44 = xmmword_101B97FF0;
        *v21 = 0u;
        v21[1] = 0u;
        *(_QWORD *)((char *)v21 + 29) = 0;
        sub_100261F9C((uint64_t)&v70, v21);
        v22 = (char *)&v43;
        if (v44 < 0)
          v22 = (char *)v43;
        *(_DWORD *)buf = 68289794;
        *(_DWORD *)&buf[4] = 0;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = "";
        v57 = 2082;
        v58 = v18;
        v59 = 2082;
        v60 = v20;
        v61 = 2082;
        v62 = v22;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"CLMiLoService received localization results with unexpected / unmatching ID\", \"ServiceId\":%{public, location:escape_only}s, \"Expected localization ID\":%{public, location:escape_only}s, \"Received trigger ID\":%{public, location:escape_only}s}", buf, 0x30u);
        if (SHIBYTE(v44) < 0)
          operator delete(v43);
        if (SHIBYTE(v46) < 0)
          operator delete(v45);
        if (SHIBYTE(v48) < 0)
          operator delete(v47);
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_102130A70);
      }
      v23 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v24 = (char *)operator new(0x28uLL);
        *(_QWORD *)(v24 + 29) = 0;
        *(_OWORD *)v24 = 0u;
        *((_OWORD *)v24 + 1) = 0u;
        sub_100261F9C((uint64_t)&a1->i64[1], v24);
        if (!a1[23].i8[0])
          sub_10028DF3C();
        v25 = (char *)operator new(0x28uLL);
        *(_QWORD *)(v25 + 29) = 0;
        *(_OWORD *)v25 = 0u;
        *((_OWORD *)v25 + 1) = 0u;
        sub_100261F9C(i64, v25);
        v26 = (char *)operator new(0x28uLL);
        *(_QWORD *)(v26 + 29) = 0;
        *(_OWORD *)v26 = 0u;
        *((_OWORD *)v26 + 1) = 0u;
        sub_100261F9C((uint64_t)&v70, v26);
        *(_DWORD *)buf = 68289794;
        *(_DWORD *)&buf[4] = 0;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = "";
        v57 = 2082;
        v58 = v24;
        v59 = 2082;
        v60 = v25;
        v61 = 2082;
        v62 = v26;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v23, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLMiLoService received localization results with unexpected / unmatching ID", "{\"msg%{public}.0s\":\"CLMiLoService received localization results with unexpected / unmatching ID\", \"ServiceId\":%{public, location:escape_only}s, \"Expected localization ID\":%{public, location:escape_only}s, \"Received trigger ID\":%{public, location:escape_only}s}", buf, 0x30u);
        operator delete(v26);
        operator delete(v25);
        operator delete(v24);
      }
      if (a1[23].i8[0])
        a1[23].i8[0] = 0;
      sub_10034828C(a1, 3);
    }
    sub_10034871C(a1);
  }
}

void sub_100348014(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55)
{
  void *v55;

  operator delete(v55);
  if (a31 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t sub_100348114()
{
  CFStringRef v0;
  int v1;
  _BOOL4 v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  BOOL v7;
  uint64_t v8;
  std::__shared_weak_count *v9;

  sub_1001E4804(&v8);
  v7 = 0;
  v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsForcePredictionForLowLatencyServiceEnabled", 0x8000100u, kCFAllocatorNull);
  v1 = sub_1001E48E4(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  v2 = v7;
  v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  if (v2)
    return 1;
  else
    return v1 ^ 1u;
}

void sub_1003481D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  sub_100261F44((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1003481F0(uint64_t a1, uint64_t a2)
{
  __int128 v4;

  if (*(_BYTE *)(a1 + 184))
  {
    sub_100006898(a1, (__n128 *)a2);
    v4 = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(a1 + 33) = *(_OWORD *)(a2 + 33);
    *(_OWORD *)(a1 + 24) = v4;
    sub_10034ED7C(a1 + 56, (__n128 *)(a2 + 56));
    sub_1002A20F4(a1 + 88, a2 + 88);
    *(_DWORD *)(a1 + 136) = *(_DWORD *)(a2 + 136);
    sub_100006898(a1 + 144, (__n128 *)(a2 + 144));
    *(_OWORD *)(a1 + 168) = *(_OWORD *)(a2 + 168);
  }
  else
  {
    sub_100341DC0(a1, a2);
    *(_BYTE *)(a1 + 184) = 1;
  }
  return a1;
}

void sub_10034828C(int64x2_t *a1, int a2)
{
  uint64_t v4;
  NSObject *v5;
  char *v6;
  _BYTE *v7;
  _BOOL4 v8;
  unint64_t v9;
  int v10;
  _DWORD *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  void *v21;
  uint64_t v22;
  __int128 v23;
  char v24;
  char v25;
  __int128 v26;
  uint64_t v27;
  void *v28;
  void *v29;
  uint64_t v30;
  _BYTE __p[24];
  char v32;
  uint8_t buf[8];
  _BYTE v34[10];
  __int16 v35;
  _BYTE *v36;
  __int16 v37;
  _BOOL4 v38;
  __int16 v39;
  _BOOL4 v40;
  void *v41;
  char v42;
  char v43;
  _BYTE v44[56];
  void *v45;
  void *v46;

  v4 = 29;
  if (!a2)
    v4 = -1;
  v19 = v4;
  if (a1[21].i64[1])
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130A70);
    v5 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      v6 = (char *)operator new(0x28uLL);
      *(_QWORD *)__p = v6;
      *(_OWORD *)&__p[8] = xmmword_101B97FF0;
      *(_OWORD *)v6 = 0u;
      *((_OWORD *)v6 + 1) = 0u;
      *(_QWORD *)(v6 + 29) = 0;
      sub_100261F9C((uint64_t)&a1->i64[1], v6);
      v7 = __p;
      if (__p[23] < 0)
        v7 = *(_BYTE **)__p;
      v8 = a1[21].i64[1] != 0;
      *(_DWORD *)buf = 68289794;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)v34 = 2082;
      *(_QWORD *)&v34[2] = "";
      v35 = 2082;
      v36 = v7;
      v37 = 1026;
      v38 = v8;
      v39 = 1026;
      v40 = a2 == 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService releasing prediction requsts: \", \"ServiceId\":%{public, location:escape_only}s, \"NumRequests\":%{public}hhd, \"Success\":%{public}hhd}", buf, 0x28u);
      if ((__p[23] & 0x80000000) != 0)
        operator delete(*(void **)__p);
    }
  }
  if ((sub_1002EC974(a2) & 0xFF00000000) != 0)
  {
    v9 = sub_1002EC974(a2);
    v10 = v9;
    if ((v9 & 0xFF00000000) == 0)
      sub_10028DF3C();
    v11 = operator new(4uLL);
    *v11 = v10;
    v12 = (uint64_t)(v11 + 1);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  while (a1[21].i64[1])
  {
    v13 = a1[21].u64[0];
    v14 = *(_QWORD *)(a1[19].i64[1] + 8 * (v13 / 0x7C));
    v15 = v13 % 0x7C;
    if (!a2)
    {
      v16 = v14 + 33 * v15;
      if (*(_BYTE *)(v16 + 32))
      {
        sub_10034B6B0(a1->i64, (_QWORD *)v16, (_OWORD *)(v16 + 16));
        v17 = a1[21].u64[0];
        v14 = *(_QWORD *)(a1[19].i64[1] + 8 * (v17 / 0x7C));
        v15 = v17 % 0x7C;
      }
    }
    (*(void (**)(uint64_t, uint64_t *, unint64_t, uint64_t))(*(_QWORD *)a1->i64[0] + 40))(a1->i64[0], &a1->i64[1], v14 + 33 * v15, v19);
    v29 = 0;
    v30 = 0;
    v27 = 0;
    v28 = 0;
    v26 = 0uLL;
    LOBYTE(v23) = 0;
    v25 = 0;
    __p[0] = 0;
    v32 = 0;
    v21 = 0;
    v22 = 0;
    v20 = 0;
    sub_10027205C(&v20, v11, v12, (v12 - (uint64_t)v11) >> 2);
    sub_1002A2278((uint64_t)buf, (uint64_t)&v28, &v26, 0, &v23, (uint64_t)__p, 0, (uint64_t)&v20);
    if (v20)
    {
      v21 = v20;
      operator delete(v20);
    }
    if (v32)
      sub_1002A1C94((uint64_t)__p);
    if (v25 && v24 < 0)
      operator delete((void *)v23);
    if (v28)
    {
      v29 = v28;
      operator delete(v28);
    }
    v18 = a1->i64[0];
    *(_OWORD *)__p = *(_OWORD *)(*(_QWORD *)(a1[19].i64[1] + 8 * (a1[21].i64[0] / 0x7CuLL))
                               + 33 * (a1[21].i64[0] % 0x7CuLL));
    __p[16] = 1;
    (*(void (**)(uint64_t, uint64_t *, _BYTE *, uint8_t *))(*(_QWORD *)v18 + 32))(v18, &a1->i64[1], __p, buf);
    a1[21] = vaddq_s64(a1[21], (int64x2_t)xmmword_101B9DFC0);
    sub_10034EE18((uint64_t)a1[19].i64, 1);
    if (v45)
    {
      v46 = v45;
      operator delete(v45);
    }
    if (v44[40])
      sub_1002A1C94((uint64_t)v44);
    if (v43 && v42 < 0)
      operator delete(v41);
    if (*(_QWORD *)buf)
    {
      *(_QWORD *)v34 = *(_QWORD *)buf;
      operator delete(*(void **)buf);
    }
  }
  if (v11)
    operator delete(v11);
}

void sub_10034869C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,int a34,__int16 a35,char a36,char a37)
{
  void *v37;

  operator delete(v37);
  _Unwind_Resume(a1);
}

void sub_10034871C(_QWORD *a1)
{
  unint64_t v1;
  NSObject *v2;
  NSObject *v3;
  NSObject *v4;
  NSObject *v6;
  char *v7;
  int v8;
  int v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  char *v13;

  v1 = a1[3];
  if (v1 >= 4)
  {
    if (v1 == 4)
    {
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130A70);
      v6 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        v7 = (char *)operator new(0x28uLL);
        *(_OWORD *)v7 = 0u;
        *((_OWORD *)v7 + 1) = 0u;
        *(_QWORD *)(v7 + 29) = 0;
        sub_100261F9C((uint64_t)(a1 + 1), v7);
        v8 = 68289283;
        v9 = 0;
        v10 = 2082;
        v11 = "";
        v12 = 2081;
        v13 = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"applying model with recent changes\", \"ServiceUUID\":%{private, location:escape_only}s}", (uint8_t *)&v8, 0x1Cu);
        operator delete(v7);
      }
      sub_1003499C0(a1);
    }
    else if (v1 == 5)
    {
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130A70);
      v3 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
      {
        v8 = 68289026;
        v9 = 0;
        v10 = 2082;
        v11 = "";
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"applyRecentChangesToModel, received invalid serviceType = CLMiLoServiceTypeMax\"}", (uint8_t *)&v8, 0x12u);
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_102130A70);
      }
      v4 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v8 = 68289026;
        v9 = 0;
        v10 = 2082;
        v11 = "";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "applyRecentChangesToModel, received invalid serviceType = CLMiLoServiceTypeMax", "{\"msg%{public}.0s\":\"applyRecentChangesToModel, received invalid serviceType = CLMiLoServiceTypeMax\"}", (uint8_t *)&v8, 0x12u);
      }
    }
  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130A70);
    v2 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
    {
      v8 = 68289282;
      v9 = 0;
      v10 = 2082;
      v11 = "";
      v12 = 2050;
      v13 = (char *)v1;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"applying model with recent changes is not applicable\", \"Service Type\":%{public}lu}", (uint8_t *)&v8, 0x1Cu);
    }
  }
}

void sub_100348A0C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_100348A28(uint64_t a1)
{
  sub_10034EE74(a1 + 112);
}

void sub_100348A30(uint64_t *a1, int a2)
{
  NSObject *v4;
  _OWORD *v5;
  void *p_p;
  _QWORD *v7;
  _DWORD *v8;
  uint64_t v9;
  void *v10;
  void *v11;
  _DWORD *v12;
  __int128 v13;
  char v14;
  char v15;
  __int128 v16;
  uint64_t v17;
  void *v18;
  void *v19;
  uint64_t v20;
  void *__p;
  __int128 v22;
  char v23;
  uint8_t buf[8];
  _BYTE v25[10];
  __int16 v26;
  void *v27;
  __int16 v28;
  _QWORD *v29;
  void *v30;
  char v31;
  char v32;
  _BYTE v33[56];
  void *v34;
  void *v35;

  if (!a1[11] && *((_BYTE *)a1 + 457))
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130A70);
    v4 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      v5 = operator new(0x28uLL);
      __p = v5;
      v22 = xmmword_101B97FF0;
      *v5 = 0u;
      v5[1] = 0u;
      *(_QWORD *)((char *)v5 + 29) = 0;
      sub_100261F9C((uint64_t)(a1 + 1), v5);
      p_p = __p;
      if (v22 >= 0)
        p_p = &__p;
      v7 = a1 + 5;
      if (*((char *)a1 + 63) < 0)
        v7 = (_QWORD *)*v7;
      *(_DWORD *)buf = 68289538;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)v25 = 2082;
      *(_QWORD *)&v25[2] = "";
      v26 = 2082;
      v27 = p_p;
      v28 = 2082;
      v29 = v7;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService sending invalid confidence empty results to client: \", \"ServiceId\":%{public, location:escape_only}s, \"ClientId\":%{public, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(v22) < 0)
        operator delete(__p);
    }
    v19 = 0;
    v20 = 0;
    v17 = 0;
    v18 = 0;
    v16 = 0uLL;
    LOBYTE(v13) = 0;
    v15 = 0;
    LOBYTE(__p) = 0;
    v23 = 0;
    v8 = operator new(4uLL);
    v10 = v8;
    *v8 = a2;
    v11 = v8 + 1;
    v12 = v8 + 1;
    sub_1002A2278((uint64_t)buf, (uint64_t)&v18, &v16, 0, &v13, (uint64_t)&__p, 0, (uint64_t)&v10);
    if (v10)
    {
      v11 = v10;
      operator delete(v10);
    }
    if (v23)
      sub_1002A1C94((uint64_t)&__p);
    if (v15 && v14 < 0)
      operator delete((void *)v13);
    if (v18)
    {
      v19 = v18;
      operator delete(v18);
    }
    v9 = *a1;
    __p = 0;
    *(_QWORD *)&v22 = 0;
    BYTE8(v22) = 1;
    (*(void (**)(uint64_t, uint64_t *, void **, uint8_t *))(*(_QWORD *)v9 + 32))(v9, a1 + 1, &__p, buf);
    if (v34)
    {
      v35 = v34;
      operator delete(v34);
    }
    if (v33[40])
      sub_1002A1C94((uint64_t)v33);
    if (v32 && v31 < 0)
      operator delete(v30);
    if (*(_QWORD *)buf)
    {
      *(_QWORD *)v25 = *(_QWORD *)buf;
      operator delete(*(void **)buf);
    }
  }
}

void sub_100348CC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  void *v29;

  operator delete(v29);
  _Unwind_Resume(a1);
}

void sub_100348CEC(uint64_t *a1)
{
  NSObject *v2;
  char *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  void *__p;
  void *v9;
  uint64_t v10;
  __int128 v11;
  char v12;
  char v13;
  __int128 v14;
  uint64_t v15;
  void *v16;
  void *v17;
  uint64_t v18;
  _QWORD v19[2];
  char v20;
  char v21;
  void *buf;
  _BYTE v23[10];
  __int16 v24;
  char *v25;
  __int16 v26;
  _QWORD *v27;
  void *v28;
  char v29;
  char v30;
  _BYTE v31[56];
  void *v32;
  void *v33;

  if (!a1[11])
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130A70);
    v2 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      v3 = (char *)operator new(0x28uLL);
      *(_OWORD *)v3 = 0u;
      *((_OWORD *)v3 + 1) = 0u;
      *(_QWORD *)(v3 + 29) = 0;
      sub_100261F9C((uint64_t)(a1 + 1), v3);
      v4 = a1 + 5;
      if (*((char *)a1 + 63) < 0)
        v4 = (_QWORD *)*v4;
      buf = (void *)68289538;
      *(_WORD *)v23 = 2082;
      *(_QWORD *)&v23[2] = "";
      v24 = 2082;
      v25 = v3;
      v26 = 2082;
      v27 = v4;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService sending initial empty prediction to BlueAtlas client: \", \"ServiceId\":%{public, location:escape_only}s, \"ClientId\":%{public, location:escape_only}s}", (uint8_t *)&buf, 0x26u);
      operator delete(v3);
    }
    v17 = 0;
    v18 = 0;
    v15 = 0;
    v16 = 0;
    v14 = 0uLL;
    LOBYTE(v11) = 0;
    v13 = 0;
    LOBYTE(v19[0]) = 0;
    v21 = 0;
    v9 = 0;
    v10 = 0;
    __p = 0;
    sub_1002A2278((uint64_t)&buf, (uint64_t)&v16, &v14, 0, &v11, (uint64_t)v19, 1, (uint64_t)&__p);
    if (__p)
    {
      v9 = __p;
      operator delete(__p);
    }
    if (v21)
      sub_1002A1C94((uint64_t)v19);
    if (v13 && v12 < 0)
      operator delete((void *)v11);
    if (v16)
    {
      v17 = v16;
      operator delete(v16);
    }
    v5 = *a1;
    v7 = 0;
    sub_1000B0C3C(&v7);
    v19[0] = sub_1000B0D38((ssize_t)&v7);
    v19[1] = v6;
    v20 = 1;
    (*(void (**)(uint64_t, uint64_t *, _QWORD *, void **))(*(_QWORD *)v5 + 32))(v5, a1 + 1, v19, &buf);
    sub_1000B0D18((unsigned int *)&v7);
    if (v32)
    {
      v33 = v32;
      operator delete(v32);
    }
    if (v31[40])
      sub_1002A1C94((uint64_t)v31);
    if (v30 && v29 < 0)
      operator delete(v28);
    if (buf)
    {
      *(_QWORD *)v23 = buf;
      operator delete(buf);
    }
  }
}

void sub_100348F54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  void *v30;

  operator delete(v30);
  _Unwind_Resume(a1);
}

uint64_t sub_100348F88@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(result + 104);
  *a2 = *(_QWORD *)(result + 96);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t sub_100348FAC(uint64_t a1)
{
  return *(_QWORD *)(a1 + 96);
}

void sub_100348FBC(uint64_t a1, uint64_t *a2)
{
  NSObject *v4;
  char *v5;
  uint64_t v6;
  char *v7;
  _DWORD v8[2];
  __int16 v9;
  const char *v10;
  __int16 v11;
  char *v12;
  __int16 v13;
  char *v14;

  if (!*a2)
    sub_1018F61CC(qword_1022A00F0 == -1);
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130A70);
  v4 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    v5 = (char *)operator new(0x28uLL);
    *(_OWORD *)v5 = 0u;
    *((_OWORD *)v5 + 1) = 0u;
    *(_QWORD *)(v5 + 29) = 0;
    sub_100261F9C(a1 + 8, v5);
    v6 = *a2;
    v7 = (char *)operator new(0x28uLL);
    *(_QWORD *)(v7 + 29) = 0;
    *(_OWORD *)v7 = 0u;
    *((_OWORD *)v7 + 1) = 0u;
    sub_100261F9C(v6 + 352, v7);
    v8[0] = 68289538;
    v8[1] = 0;
    v9 = 2082;
    v10 = "";
    v11 = 2082;
    v12 = v5;
    v13 = 2082;
    v14 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Model updated: \", \"ServiceId\":%{public, location:escape_only}s, \"ModelId\":%{public, location:escape_only}s}", (uint8_t *)v8, 0x26u);
    operator delete(v7);
    operator delete(v5);
  }
  sub_100349198((_QWORD *)(a1 + 96), a2);
  sub_10034871C((_QWORD *)a1);
  sub_100349210((_QWORD *)a1);
  sub_1003496E0(a1);
  if (*(_BYTE *)(a1 + 457))
    sub_100349764((_QWORD *)a1, *(unsigned __int8 *)(a1 + 456));
}

void sub_100349168(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  operator delete(v2);
  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_100349198(_QWORD *a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;

  v4 = *a2;
  v3 = a2[1];
  if (v3)
  {
    v5 = (unint64_t *)(v3 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = (std::__shared_weak_count *)a1[1];
  *a1 = v4;
  a1[1] = v3;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  return a1;
}

_QWORD *sub_100349210(_QWORD *result)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  NSObject *v4;
  NSObject *v5;
  char *v6;
  const char *v7;
  uint64_t v8;
  NSObject *v9;
  const char *v10;
  uint8_t *v11;
  _WORD v12[8];
  uint8_t buf[4];
  int v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  char *v18;
  _QWORD v19[11];
  uint64_t v20;
  char v21;
  char v22;

  v1 = result[12];
  if (v1)
  {
    v2 = result;
    v3 = v1 + 352;
    (*(void (**)(_QWORD *__return_ptr, _QWORD, uint64_t))(*(_QWORD *)*result + 120))(v19, *result, v1 + 352);
    if (v22)
    {
      if ((v21 & 0x10) == 0)
      {
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_102130A70);
        v4 = qword_1022A00F8;
        if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "ClusterAnchorValueStatistics has no data", buf, 2u);
        }
        if (!sub_1001BFF7C(115, 0))
          return (_QWORD *)sub_1002FFD68((uint64_t)v19);
        bzero(buf, 0x65CuLL);
        if (qword_1022A00F0 == -1)
          goto LABEL_24;
LABEL_33:
        dispatch_once(&qword_1022A00F0, &stru_102130A70);
LABEL_24:
        v12[0] = 0;
        _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 16, "ClusterAnchorValueStatistics has no data", v12, 2);
        v11 = (uint8_t *)v10;
        sub_100512490("Generic", 1, 0, 0, "void CLMiLoService::loadAnchorValueStatistics()", "%s\n", v10);
        if (v11 != buf)
          free(v11);
        return (_QWORD *)sub_1002FFD68((uint64_t)v19);
      }
      v8 = v20;
      if (!v20)
        v8 = *(_QWORD *)(qword_102310460 + 32);
      if ((*(_BYTE *)(v8 + 32) & 2) == 0)
      {
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_102130A70);
        v9 = qword_1022A00F8;
        if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "ClusterAnchorValueStatistics has no data", buf, 2u);
        }
        if (!sub_1001BFF7C(115, 0))
          return (_QWORD *)sub_1002FFD68((uint64_t)v19);
        bzero(buf, 0x65CuLL);
        if (qword_1022A00F0 == -1)
          goto LABEL_24;
        goto LABEL_33;
      }
      sub_10034AE4C(v2[12] + 496);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130A70);
      v5 = qword_1022A00F8;
      if (!os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
        return (_QWORD *)sub_1002FFD68((uint64_t)v19);
      v6 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v6 + 29) = 0;
      *(_OWORD *)v6 = 0u;
      *((_OWORD *)v6 + 1) = 0u;
      sub_100261F9C(v3, v6);
      *(_DWORD *)buf = 68289282;
      v14 = 0;
      v15 = 2082;
      v16 = "";
      v17 = 2082;
      v18 = v6;
      v7 = "{\"msg%{public}.0s\":\"ClusterAnchorValueStatistics loaded for model\", \"ModelUUID\":%{public, location:escape_only}s}";
    }
    else
    {
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130A70);
      v5 = qword_1022A00F8;
      if (!os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
        return (_QWORD *)sub_1002FFD68((uint64_t)v19);
      v6 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v6 + 29) = 0;
      *(_OWORD *)v6 = 0u;
      *((_OWORD *)v6 + 1) = 0u;
      sub_100261F9C(v3, v6);
      *(_DWORD *)buf = 68289282;
      v14 = 0;
      v15 = 2082;
      v16 = "";
      v17 = 2082;
      v18 = v6;
      v7 = "{\"msg%{public}.0s\":\"no AnchorValueStatistics for model\", \"ModelUUID\":%{public, location:escape_only}s}";
    }
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v7, buf, 0x1Cu);
    operator delete(v6);
    return (_QWORD *)sub_1002FFD68((uint64_t)v19);
  }
  return result;
}

void sub_100349698(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1002FFD68(v1 - 160);
  _Unwind_Resume(a1);
}

void sub_1003496E0(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *(_QWORD *)(a1 + 88);
  if (v1 != 2)
  {
    v3 = *(_QWORD *)(a1 + 96);
    if (v3 && sub_1002EFEB8(v3) && **(_BYTE **)(a1 + 448))
    {
      *(_QWORD *)(a1 + 88) = 0;
      if (v1)
        sub_10034B380(a1, v1);
    }
    else
    {
      *(_QWORD *)(a1 + 88) = 1;
      if (v1 != 1)
        sub_10034B4C8((int64x2_t *)a1, v1);
    }
  }
}

void sub_100349764(_QWORD *a1, int a2)
{
  uint64_t v2;
  NSObject *v3;
  char *v4;
  const char *v5;
  uint64_t v6;
  int v7;
  int v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  char *v12;

  if (*((_BYTE *)a1 + 457))
  {
    if (a2 && !a1[11])
    {
      v6 = (uint64_t)(a1 + 1);
      (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)*a1 + 128))(*a1, a1 + 1);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130A70);
      v3 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v4 = (char *)operator new(0x28uLL);
        *(_OWORD *)v4 = 0u;
        *((_OWORD *)v4 + 1) = 0u;
        *(_QWORD *)(v4 + 29) = 0;
        sub_100261F9C(v6, v4);
        v7 = 68289283;
        v8 = 0;
        v9 = 2082;
        v10 = "";
        v11 = 2081;
        v12 = v4;
        v5 = "{\"msg%{public}.0s\":\"Enabling Low Latency updates for Service:\", \"ServiceId\":%{private, location:escape_only}s}";
        goto LABEL_8;
      }
    }
    else
    {
      v2 = (uint64_t)(a1 + 1);
      (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)*a1 + 136))(*a1, a1 + 1);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130A70);
      v3 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
      {
        v4 = (char *)operator new(0x28uLL);
        *(_OWORD *)v4 = 0u;
        *((_OWORD *)v4 + 1) = 0u;
        *(_QWORD *)(v4 + 29) = 0;
        sub_100261F9C(v2, v4);
        v7 = 68289283;
        v8 = 0;
        v9 = 2082;
        v10 = "";
        v11 = 2081;
        v12 = v4;
        v5 = "{\"msg%{public}.0s\":\"Enabling Legacy updates for Service:\", \"ServiceId\":%{private, location:escape_only}s}";
LABEL_8:
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, v5, (uint8_t *)&v7, 0x1Cu);
        operator delete(v4);
      }
    }
  }
}

void sub_100349960(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_100349978(uint64_t a1)
{
  sub_100346F9C((_QWORD *)(a1 + 96));
  sub_1003496E0(a1);
  if (*(_BYTE *)(a1 + 457))
    sub_100349764((_QWORD *)a1, 0);
}

void sub_1003499C0(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  double v4;
  uint64_t v5;
  char *v6;
  double Current;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  NSObject *v18;
  char *v19;
  _BYTE *v20;
  _OWORD *v21;
  char *p_p;
  NSObject *v23;
  char *v24;
  _BYTE *v25;
  _OWORD *v26;
  char *v27;
  char *v28;
  char *v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  char *v34;
  char *v35;
  char *v36;
  char *v37;
  char *v38;
  char *v39;
  char *v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  char *v45;
  char *v46;
  char *v47;
  char *v48;
  char *v49;
  NSObject *v50;
  NSObject *v51;
  const char *v52;
  const char *v53;
  NSObject *v54;
  uint64_t v55;
  NSObject *v56;
  NSObject *v57;
  char *v58;
  _BYTE *v59;
  _OWORD *v60;
  void *v61;
  uint64_t v62;
  _OWORD *v63;
  void *v64;
  CFStringRef v65;
  int v66;
  unsigned int v67;
  std::__shared_weak_count *v68;
  unint64_t *v69;
  unint64_t v70;
  unsigned int v71;
  char *v72;
  uint64_t v73;
  unsigned int v74;
  unsigned int v75;
  _QWORD *v76;
  _QWORD *v77;
  char *v78;
  NSObject *v79;
  char *v80;
  _BYTE *v81;
  _OWORD *v82;
  char *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  _OWORD *v87;
  uint64_t v88;
  unint64_t v89;
  uint64_t v90;
  unint64_t v91;
  char *v92;
  char *v93;
  char *v94;
  char *v95;
  char *v96;
  NSObject *v97;
  char *v98;
  NSObject *v99;
  uint64_t v100;
  _QWORD *v101;
  uint64_t v102;
  __int128 v103;
  __int128 v104;
  void *v105;
  __int128 v106;
  void *v107;
  __int128 v108;
  void *__p;
  __int128 v110;
  void *v111;
  char *v112;
  char *v113;
  void *v114;
  char *v115;
  char *v116;
  uint64_t v117;
  uint64_t v118;
  _BYTE v119[24];
  _BYTE buf[18];
  __int16 v121;
  uint64_t v122;
  __int16 v123;
  char *v124;
  __int16 v125;
  void *v126;
  __int16 v127;
  void *v128;
  _BYTE v129[24];

  v1 = a1[12];
  if (v1)
  {
    if (*(_BYTE *)(v1 + 192))
    {
      v3 = 176;
      if (!*(_BYTE *)(v1 + 184))
        v3 = 488;
      v4 = *(double *)(v1 + v3);
      v5 = *a1;
      *(_OWORD *)buf = *(_OWORD *)(a1 + 1);
      v6 = (char *)(a1 + 5);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, _BYTE *, _QWORD *, double))(*(_QWORD *)v5 + 112))(&v117, v5, buf, a1 + 5, v4);
      if (v117 == v118)
      {
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_102130A70);
        v56 = qword_1022A00F8;
        if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
        {
          *(_QWORD *)buf = 68289026;
          *(_WORD *)&buf[8] = 2082;
          *(_QWORD *)&buf[10] = "";
          _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"applyRecentLabelsToLSL, no label entries for model\"}", buf, 0x12u);
        }
        goto LABEL_186;
      }
      Current = j__CFAbsoluteTimeGetCurrent();
      v8 = a1[12];
      if (!*(_BYTE *)(v8 + 184))
        *(_BYTE *)(v8 + 184) = 1;
      *(double *)(v8 + 176) = Current;
      v102 = a1[12];
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130A70);
      v9 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        v10 = (uint64_t)(*(_QWORD *)(v102 + 104) - *(_QWORD *)(v102 + 96)) >> 4;
        *(_QWORD *)buf = 68289282;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = "";
        v121 = 2050;
        v122 = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"applyRecentLabelsToLSL, number of LSL items\", \"before update\":%{public}lu}", buf, 0x1Cu);
      }
      v114 = 0;
      v115 = 0;
      v116 = 0;
      v111 = 0;
      v112 = 0;
      v113 = 0;
      v11 = v117;
      v12 = v118;
      v13 = "fication_T &, const NotificationData_T &, BOOL, int, BOOL) [Notification_T = CLMotionHintLogger_Type::Notification, NotificationData_T = CLMotionHintLogger_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]";
      v101 = a1;
      if (v117 != v118)
      {
        do
        {
          v15 = *(_QWORD **)(v102 + 96);
          v14 = *(_QWORD **)(v102 + 104);
          v16 = (_QWORD *)(v11 + 40);
          if (v15 != v14)
          {
            while (*v15 != *v16 || v15[1] != *(_QWORD *)(v11 + 48))
            {
              v15 += 2;
              if (v15 == v14)
              {
                v15 = *(_QWORD **)(v102 + 104);
                break;
              }
            }
          }
          if (v15 == v14)
          {
            v28 = v115;
            if (v115 >= v116)
            {
              v30 = (v115 - (_BYTE *)v114) >> 4;
              v31 = v30 + 1;
              if ((unint64_t)(v30 + 1) >> 60)
                goto LABEL_188;
              v32 = v116 - (_BYTE *)v114;
              if ((v116 - (_BYTE *)v114) >> 3 > v31)
                v31 = v32 >> 3;
              if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF0)
                v33 = 0xFFFFFFFFFFFFFFFLL;
              else
                v33 = v31;
              if (v33)
                v34 = (char *)sub_10028E224((uint64_t)&v116, v33);
              else
                v34 = 0;
              v35 = &v34[16 * v30];
              *(_OWORD *)v35 = *(_OWORD *)v16;
              v37 = (char *)v114;
              v36 = v115;
              v38 = v35;
              if (v115 != v114)
              {
                do
                {
                  *((_OWORD *)v38 - 1) = *((_OWORD *)v36 - 1);
                  v38 -= 16;
                  v36 -= 16;
                }
                while (v36 != v37);
                v36 = (char *)v114;
              }
              v29 = v35 + 16;
              v114 = v38;
              v115 = v35 + 16;
              v116 = &v34[16 * v33];
              if (v36)
                operator delete(v36);
            }
            else
            {
              *(_OWORD *)v115 = *(_OWORD *)v16;
              v29 = v28 + 16;
            }
            v115 = v29;
            v39 = v112;
            if (v112 >= v113)
            {
              v41 = (v112 - (_BYTE *)v111) >> 4;
              v42 = v41 + 1;
              if ((unint64_t)(v41 + 1) >> 60)
LABEL_188:
                sub_100259694();
              v43 = v113 - (_BYTE *)v111;
              if ((v113 - (_BYTE *)v111) >> 3 > v42)
                v42 = v43 >> 3;
              if ((unint64_t)v43 >= 0x7FFFFFFFFFFFFFF0)
                v44 = 0xFFFFFFFFFFFFFFFLL;
              else
                v44 = v42;
              if (v44)
                v45 = (char *)sub_10028E224((uint64_t)&v113, v44);
              else
                v45 = 0;
              v46 = &v45[16 * v41];
              *(_OWORD *)v46 = *(_OWORD *)v11;
              v48 = (char *)v111;
              v47 = v112;
              v49 = v46;
              if (v112 != v111)
              {
                do
                {
                  *((_OWORD *)v49 - 1) = *((_OWORD *)v47 - 1);
                  v49 -= 16;
                  v47 -= 16;
                }
                while (v47 != v48);
                v47 = (char *)v111;
              }
              v40 = v46 + 16;
              v111 = v49;
              v112 = v46 + 16;
              v113 = &v45[16 * v44];
              if (v47)
                operator delete(v47);
            }
            else
            {
              *(_OWORD *)v112 = *(_OWORD *)v11;
              v40 = v39 + 16;
            }
            v112 = v40;
          }
          else
          {
            if (qword_1022A00F0 != -1)
              dispatch_once(&qword_1022A00F0, &stru_102130A70);
            v18 = qword_1022A00F8;
            if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
            {
              v19 = (char *)operator new(0x28uLL);
              *(_QWORD *)v129 = v19;
              *(_OWORD *)&v129[8] = xmmword_101B97FF0;
              *(_OWORD *)v19 = 0u;
              *((_OWORD *)v19 + 1) = 0u;
              *(_QWORD *)(v19 + 29) = 0;
              sub_100261F9C(v11 + 40, v19);
              if (v129[23] >= 0)
                v20 = v129;
              else
                v20 = *(_BYTE **)v129;
              v21 = operator new(0x28uLL);
              __p = v21;
              v110 = xmmword_101B97FF0;
              *v21 = 0u;
              v21[1] = 0u;
              *(_QWORD *)((char *)v21 + 29) = 0;
              sub_100261F9C(v11, v21);
              if (v110 >= 0)
                p_p = (char *)&__p;
              else
                p_p = (char *)__p;
              *(_QWORD *)buf = 68289538;
              *(_WORD *)&buf[8] = 2082;
              *(_QWORD *)&buf[10] = "";
              v121 = 2082;
              v122 = (uint64_t)v20;
              v123 = 2082;
              v124 = p_p;
              _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"CLMiLoService::applyRecentLabelsToLSL, tried to apply a label which is already in the LSL\", \"LabelUUID\":%{public, location:escape_only}s, \"TriggerUUID\":%{public, location:escape_only}s}", buf, 0x26u);
              if (SHIBYTE(v110) < 0)
                operator delete(__p);
              if ((v129[23] & 0x80000000) != 0)
                operator delete(*(void **)v129);
              if (qword_1022A00F0 != -1)
                dispatch_once(&qword_1022A00F0, &stru_102130A70);
            }
            v23 = qword_1022A00F8;
            if (os_signpost_enabled((os_log_t)qword_1022A00F8))
            {
              v24 = (char *)operator new(0x28uLL);
              *(_QWORD *)v129 = v24;
              *(_OWORD *)&v129[8] = xmmword_101B97FF0;
              *(_OWORD *)v24 = 0u;
              *((_OWORD *)v24 + 1) = 0u;
              *(_QWORD *)(v24 + 29) = 0;
              sub_100261F9C(v11 + 40, v24);
              if (v129[23] >= 0)
                v25 = v129;
              else
                v25 = *(_BYTE **)v129;
              v26 = operator new(0x28uLL);
              __p = v26;
              v110 = xmmword_101B97FF0;
              *v26 = 0u;
              v26[1] = 0u;
              *(_QWORD *)((char *)v26 + 29) = 0;
              sub_100261F9C(v11, v26);
              if (v110 >= 0)
                v27 = (char *)&__p;
              else
                v27 = (char *)__p;
              *(_QWORD *)buf = 68289538;
              *(_WORD *)&buf[8] = 2082;
              *(_QWORD *)&buf[10] = "";
              v121 = 2082;
              v122 = (uint64_t)v25;
              v123 = 2082;
              v124 = v27;
              _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v23, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLMiLoService::applyRecentLabelsToLSL, tried to apply a label which is already in the LSL", "{\"msg%{public}.0s\":\"CLMiLoService::applyRecentLabelsToLSL, tried to apply a label which is already in the LSL\", \"LabelUUID\":%{public, location:escape_only}s, \"TriggerUUID\":%{public, location:escape_only}s}", buf, 0x26u);
              if (SHIBYTE(v110) < 0)
                operator delete(__p);
              if ((v129[23] & 0x80000000) != 0)
                operator delete(*(void **)v129);
            }
          }
          v11 += 64;
        }
        while (v11 != v12);
        v11 = v117;
        v55 = v118;
        v6 = (char *)(a1 + 5);
        if (v118 == v117)
        {
          v13 = "fication_T &, const NotificationData_T &, BOOL, int, BOOL) [Notification_T = CLMotionHintLogger_Type::Notification, NotificationData_T = CLMotionHintLogger_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]";
        }
        else
        {
          v13 = "virtual void CLNotifier<CLMotionHintLogger_Type::Notification, CLMotionHintLogger_Type::NotificationData"
                ">::notifyClientsWithData(const Notification_T &, const NotificationData_T &, BOOL, int, BOOL) [Notificat"
                "ion_T = CLMotionHintLogger_Type::Notification, NotificationData_T = CLMotionHintLogger_Type::Notificatio"
                "nData, NotificationInfo_T = char, RegistrationInfo_T = char]"
              + 139;
          do
          {
            if (*(char *)(v55 - 25) < 0)
              operator delete(*(void **)(v55 - 48));
            v55 -= 64;
          }
          while (v55 != v11);
        }
      }
      v118 = v11;
      sub_10034EC78(&v117);
      if (v115 == v114)
      {
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_102130A70);
        v97 = qword_1022A00F8;
        if (!os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
          goto LABEL_180;
        if (*((char *)a1 + 63) < 0)
          v6 = *(char **)v6;
        *(_OWORD *)v129 = *(_OWORD *)(a1 + 1);
        v98 = (char *)operator new(0x28uLL);
        *(_QWORD *)(v98 + 29) = 0;
        *(_OWORD *)v98 = 0u;
        *((_OWORD *)v98 + 1) = 0u;
        sub_100261F9C((uint64_t)v129, v98);
        *(_QWORD *)buf = 68289539;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = "";
        v121 = 2081;
        v122 = (uint64_t)v6;
        v123 = 2081;
        v124 = v98;
        _os_log_impl((void *)&_mh_execute_header, v97, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"applyRecentLabelsToLSL, no labels from database to apply to LSL\", \"ClientID\":%{private, location:escape_only}s, \"ClientUUID\":%{private, location:escape_only}s}", buf, 0x26u);
        operator delete(v98);
      }
      else
      {
        (*(void (**)(_BYTE *__return_ptr, _QWORD, void **))(*(_QWORD *)*a1 + 104))(v129, *a1, &v111);
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_102130A70);
        v57 = qword_1022A00F8;
        if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
        {
          if (*((char *)a1 + 63) < 0)
            v6 = *(char **)v6;
          v59 = v114;
          v58 = v115;
          *(_OWORD *)v119 = *(_OWORD *)(a1 + 1);
          v60 = operator new(0x28uLL);
          __p = v60;
          v103 = *((_OWORD *)v13 + 255);
          v110 = v103;
          *v60 = 0u;
          v60[1] = 0u;
          *(_QWORD *)((char *)v60 + 29) = 0;
          sub_100261F9C((uint64_t)v119, v60);
          if (v110 >= 0)
            v61 = &__p;
          else
            v61 = __p;
          v62 = a1[12];
          v63 = operator new(0x28uLL);
          v107 = v63;
          v108 = v103;
          *v63 = 0u;
          v63[1] = 0u;
          *(_QWORD *)((char *)v63 + 29) = 0;
          sub_100261F9C(v62 + 352, v63);
          v64 = &v107;
          if (v108 < 0)
            v64 = v107;
          *(_DWORD *)buf = 68290051;
          *(_DWORD *)&buf[4] = 0;
          *(_WORD *)&buf[8] = 2082;
          *(_QWORD *)&buf[10] = "";
          v121 = 2050;
          v122 = (v58 - v59) >> 4;
          v123 = 2081;
          v124 = v6;
          v125 = 2081;
          v126 = v61;
          v127 = 2081;
          v128 = v64;
          _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"applyRecentLabelsToLSL, found labels from database to apply to LSL\", \"NumLabels\":%{public}lu, \"ClientID\":%{private, location:escape_only}s, \"ClientUUID\":%{private, location:escape_only}s, \"ModelUUID\":%{private, location:escape_only}s}", buf, 0x3Au);
          if (SHIBYTE(v108) < 0)
            operator delete(v107);
          if (SHIBYTE(v110) < 0)
            operator delete(__p);
        }
        __p = 0;
        v110 = 0uLL;
        v107 = 0;
        v108 = 0uLL;
        sub_1001E4804(buf);
        *(_DWORD *)v119 = 0;
        v65 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsSimilarityListMaxNumberOfItems", 0x8000100u, kCFAllocatorNull);
        v66 = sub_1001C1194(*(uint64_t *)buf, (uint64_t)v65, v119);
        CFRelease(v65);
        v67 = *(_DWORD *)v119;
        v68 = *(std::__shared_weak_count **)&buf[8];
        if (*(_QWORD *)&buf[8])
        {
          v69 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
          do
            v70 = __ldaxr(v69);
          while (__stlxr(v70 - 1, v69));
          if (!v70)
          {
            ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
            std::__shared_weak_count::__release_weak(v68);
          }
        }
        if (v66)
          v71 = v67;
        else
          v71 = 1000;
        v72 = (char *)v114;
        if (v115 != v114)
        {
          v73 = 0;
          v74 = 0;
          v75 = 0;
          v104 = *((_OWORD *)v13 + 255);
          while (1)
          {
            v76 = (char *)v111 + 16 * v73;
            v77 = sub_1002710E8(v129, v76);
            if (qword_1022A00F0 != -1)
              dispatch_once(&qword_1022A00F0, &stru_102130A70);
            v78 = &v72[16 * v73];
            v79 = qword_1022A00F8;
            if (!os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
              goto LABEL_144;
            v80 = (char *)operator new(0x28uLL);
            *(_QWORD *)v119 = v80;
            *(_OWORD *)&v119[8] = v104;
            *(_OWORD *)v80 = 0u;
            *((_OWORD *)v80 + 1) = 0u;
            *(_QWORD *)(v80 + 29) = 0;
            sub_100261F9C((uint64_t)v78, v80);
            if (v119[23] >= 0)
              v81 = v119;
            else
              v81 = *(_BYTE **)v119;
            v82 = operator new(0x28uLL);
            v105 = v82;
            v106 = v104;
            *v82 = 0u;
            v82[1] = 0u;
            *(_QWORD *)((char *)v82 + 29) = 0;
            sub_100261F9C((uint64_t)v76, v82);
            v83 = (char *)&v105;
            if (v106 < 0)
              v83 = (char *)v105;
            *(_QWORD *)buf = 68289795;
            *(_WORD *)&buf[8] = 2082;
            *(_QWORD *)&buf[10] = "";
            v121 = 2081;
            v122 = (uint64_t)v81;
            v123 = 2081;
            v124 = v83;
            v125 = 1026;
            LODWORD(v126) = v77 != 0;
            _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"applyRecentLabelsToLSL, per label info\", \"LabelUUID\":%{private, location:escape_only}s, \"TriggerUUID\":%{private, location:escape_only}s, \"validFingerprint\":%{public}hhd}", buf, 0x2Cu);
            if (SHIBYTE(v106) < 0)
              operator delete(v105);
            if ((v119[23] & 0x80000000) != 0)
            {
              operator delete(*(void **)v119);
              if (v77)
              {
LABEL_145:
                v84 = v110;
                if ((unint64_t)v110 >= *((_QWORD *)&v110 + 1))
                {
                  v85 = sub_100274488((uint64_t *)&__p, (uint64_t)(v77 + 4));
                }
                else
                {
                  sub_100274594((uint64_t)&v110 + 8, v110, (uint64_t)(v77 + 4));
                  v85 = v84 + 192;
                }
                *(_QWORD *)&v110 = v85;
                v86 = v108;
                if ((unint64_t)v108 >= *((_QWORD *)&v108 + 1))
                {
                  v88 = (uint64_t)(v108 - (_QWORD)v107) >> 4;
                  v89 = v88 + 1;
                  if ((unint64_t)(v88 + 1) >> 60)
                    sub_100259694();
                  v90 = *((_QWORD *)&v108 + 1) - (_QWORD)v107;
                  if ((uint64_t)(*((_QWORD *)&v108 + 1) - (_QWORD)v107) >> 3 > v89)
                    v89 = v90 >> 3;
                  if ((unint64_t)v90 >= 0x7FFFFFFFFFFFFFF0)
                    v91 = 0xFFFFFFFFFFFFFFFLL;
                  else
                    v91 = v89;
                  if (v91)
                    v92 = (char *)sub_10028E224((uint64_t)&v108 + 8, v91);
                  else
                    v92 = 0;
                  v93 = &v92[16 * v88];
                  *(_OWORD *)v93 = *(_OWORD *)v78;
                  v95 = (char *)v107;
                  v94 = (char *)v108;
                  v96 = v93;
                  if ((void *)v108 != v107)
                  {
                    do
                    {
                      *((_OWORD *)v96 - 1) = *((_OWORD *)v94 - 1);
                      v96 -= 16;
                      v94 -= 16;
                    }
                    while (v94 != v95);
                    v94 = (char *)v107;
                  }
                  v87 = v93 + 16;
                  v107 = v96;
                  *(_QWORD *)&v108 = v93 + 16;
                  *((_QWORD *)&v108 + 1) = &v92[16 * v91];
                  if (v94)
                    operator delete(v94);
                }
                else
                {
                  *(_OWORD *)v108 = *(_OWORD *)v78;
                  v87 = (_OWORD *)(v86 + 16);
                }
                *(_QWORD *)&v108 = v87;
                ++v75;
              }
            }
            else
            {
LABEL_144:
              if (v77)
                goto LABEL_145;
            }
            if (v75 < v71)
            {
              v72 = (char *)v114;
              v73 = ++v74;
              if (v74 < (unint64_t)((v115 - (_BYTE *)v114) >> 4))
                continue;
            }
            break;
          }
        }
        sub_1002F2034(v101[12] + 72, v101[12], &__p, &v107);
        if (v107)
        {
          *(_QWORD *)&v108 = v107;
          operator delete(v107);
        }
        *(_QWORD *)buf = &__p;
        sub_100274134((void ***)buf);
        sub_1002B971C((uint64_t)v129);
      }
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130A70);
LABEL_180:
      v99 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        v100 = (uint64_t)(*(_QWORD *)(v102 + 104) - *(_QWORD *)(v102 + 96)) >> 4;
        *(_QWORD *)buf = 68289282;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = "";
        v121 = 2050;
        v122 = v100;
        _os_log_impl((void *)&_mh_execute_header, v99, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"applyRecentLabelsToLSL, number of LSL items\", \"after update\":%{public}lu}", buf, 0x1Cu);
      }
      if (v111)
      {
        v112 = (char *)v111;
        operator delete(v111);
      }
      if (v114)
      {
        v115 = (char *)v114;
        operator delete(v114);
      }
LABEL_186:
      *(_QWORD *)buf = &v117;
      sub_1002699DC((void ***)buf);
      return;
    }
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130A70);
    v54 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      *(_QWORD *)buf = 68289026;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"applyRecentLabelsToLSL, model has no location similarity list\"}", buf, 0x12u);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130A70);
    }
    v51 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      *(_QWORD *)buf = 68289026;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      v52 = "applyRecentLabelsToLSL, model has no location similarity list";
      v53 = "{\"msg%{public}.0s\":\"applyRecentLabelsToLSL, model has no location similarity list\"}";
      goto LABEL_96;
    }
  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130A70);
    v50 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      *(_QWORD *)buf = 68289026;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"applyRecentLabelsToLSL, no current model\"}", buf, 0x12u);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130A70);
    }
    v51 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      *(_QWORD *)buf = 68289026;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      v52 = "applyRecentLabelsToLSL, no current model";
      v53 = "{\"msg%{public}.0s\":\"applyRecentLabelsToLSL, no current model\"}";
LABEL_96:
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v51, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, v52, v53, buf, 0x12u);
    }
  }
}

void sub_10034AA64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *__p,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  void *v45;
  uint64_t v46;

  operator delete(v45);
  if (__p)
    operator delete(__p);
  if (a34)
    operator delete(a34);
  *(_QWORD *)(v46 - 144) = &a37;
  sub_1002699DC((void ***)(v46 - 144));
  _Unwind_Resume(a1);
}

uint64_t sub_10034ABDC(int a1, int a2)
{
  NSObject *v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  NSObject *v9;
  const char *v10;
  uint8_t *v11;
  _WORD v12[8];
  uint8_t buf[4];
  int v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;

  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130A70);
  v4 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289538;
    v14 = 0;
    v15 = 2082;
    v16 = "";
    v17 = 1026;
    v18 = a1;
    v19 = 1026;
    v20 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"internalToExternalServiceQuality\", \"qualityLevel\":%{public}d, \"candidateQualityLevel\":%{public}d}", buf, 0x1Eu);
  }
  if (a1 == 3)
  {
    v5 = 29;
    if (a2 != 3)
      v5 = 30;
    v6 = a2 == 1;
    v7 = 28;
    goto LABEL_13;
  }
  if (a1 == 1)
  {
    v5 = 9;
    if (a2 != 3)
      v5 = 10;
    v6 = a2 == 1;
    v7 = 8;
LABEL_13:
    if (v6)
      return v7;
    else
      return v5;
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130A70);
  v9 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Service Quality is invalid", buf, 2u);
  }
  if (sub_1001BFF7C(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130A70);
    v12[0] = 0;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 16, "Service Quality is invalid", v12, 2);
    v11 = (uint8_t *)v10;
    sub_100512490("Generic", 1, 0, 0, "static CLMiLoServiceQuality CLMiLoService::internalToExternalServiceQuality(CLMicroLocationProto::Model_ModelQualityLevel, CLMicroLocationProto::Model_ModelQualityLevel)", "%s\n", v10);
    if (v11 != buf)
      free(v11);
  }
  return 0;
}

uint64_t sub_10034AE4C(uint64_t a1)
{
  uint64_t result;

  if (*(_BYTE *)(a1 + 40))
    *(_BYTE *)(sub_100300B8C(a1) + 40) = 0;
  result = sub_1003A4440();
  *(_BYTE *)(result + 40) = 1;
  return result;
}

uint64_t sub_10034AE88(uint64_t a1, uint64_t a2)
{
  if ((unint64_t)(a1 - 2) < 2)
    return 1;
  if (a1 == 1)
    return 0;
  if (a1 != 4)
    sub_1018F6370();
  if (a2 == 2)
    return 3;
  else
    return 2;
}

uint64_t sub_10034AED0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t result;
  NSObject *v4;
  int v5;
  int v6;
  const char *v7;
  uint8_t *v8;
  _WORD v9[8];
  uint8_t buf[1640];

  v2 = a1 - 1;
  result = 4;
  switch(v2)
  {
    case 0:
      goto LABEL_12;
    case 1:
      return result;
    case 2:
      result = 3;
      break;
    case 3:
      if (a2 == 2)
      {
        result = 5;
      }
      else
      {
LABEL_12:
        v6 = sub_10034B278();
        result = sub_10034B0DC(v6);
      }
      break;
    default:
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130A70);
      v4 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Get generation algorithm: Unknown service type", buf, 2u);
      }
      if (sub_1001BFF7C(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_102130A70);
        v9[0] = 0;
        _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 16, "Get generation algorithm: Unknown service type", v9, 2);
        v8 = (uint8_t *)v7;
        sub_100512490("Generic", 1, 0, 0, "static CLMicroLocationProto::Model_GenerationAlgorithm CLMiLoService::generationAlgorithmByServiceAndLocationType(CLMiLoServiceType, CLMiLoLocationTypeEnum)", "%s\n", v7);
        if (v8 != buf)
          free(v8);
      }
      v5 = sub_10034B278();
      result = sub_10034B0DC(v5);
      break;
  }
  return result;
}

uint64_t sub_10034B0DC(int a1)
{
  NSObject *v1;
  const char *v3;
  uint8_t *v4;
  _WORD v5[8];
  uint8_t buf[1640];

  if (a1 == 1)
    return 2;
  if (a1)
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130A70);
    v1 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "Get generation algorithm: Unknown learner type", buf, 2u);
    }
    if (sub_1001BFF7C(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130A70);
      v5[0] = 0;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 16, "Get generation algorithm: Unknown learner type", v5, 2);
      v4 = (uint8_t *)v3;
      sub_100512490("Generic", 1, 0, 0, "auto CLMiLoService::generationAlgorithmByServiceAndLocationType(CLMiLoServiceType, CLMiLoLocationTypeEnum)::(anonymous class)::operator()(CLMicroLocationAlgorithms::LearnerType) const", "%s\n", v3);
      if (v4 != buf)
        free(v4);
    }
  }
  return 1;
}

uint64_t sub_10034B278()
{
  CFStringRef v0;
  int v1;
  unsigned int v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unsigned int v7;
  uint64_t v8;
  std::__shared_weak_count *v9;

  sub_1001E4804(&v8);
  v7 = 0;
  v0 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsLearnerAlgorithm", 0x8000100u, kCFAllocatorNull);
  v1 = sub_1000B1180(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  v2 = v7;
  v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  if (v1)
    return v2;
  else
    return 0;
}

void sub_10034B338(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  sub_100261F44((uint64_t)va);
  _Unwind_Resume(a1);
}

BOOL sub_10034B350(uint64_t a1)
{
  return *(_QWORD *)(a1 + 96) && *(_QWORD *)(a1 + 88) != 2 && **(_BYTE **)(a1 + 448) != 0;
}

void sub_10034B380(uint64_t a1, int a2)
{
  NSObject *v4;
  char *v5;
  _DWORD v6[2];
  __int16 v7;
  const char *v8;
  __int16 v9;
  char *v10;
  __int16 v11;
  int v12;

  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130A70);
  v4 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    v5 = (char *)operator new(0x28uLL);
    *(_OWORD *)v5 = 0u;
    *((_OWORD *)v5 + 1) = 0u;
    *(_QWORD *)(v5 + 29) = 0;
    sub_100261F9C(a1 + 8, v5);
    v6[0] = 68289538;
    v6[1] = 0;
    v7 = 2082;
    v8 = "";
    v9 = 2082;
    v10 = v5;
    v11 = 1026;
    v12 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService state changed to running: \", \"ServiceId\":%{public, location:escape_only}s, \"Previous state\":%{public}u}", (uint8_t *)v6, 0x22u);
    operator delete(v5);
  }
  *(_QWORD *)(a1 + 88) = 0;
}

void sub_10034B4B4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_10034B4C8(int64x2_t *a1, int a2)
{
  NSObject *v4;
  char *v5;
  _DWORD v6[2];
  __int16 v7;
  const char *v8;
  __int16 v9;
  char *v10;
  __int16 v11;
  int v12;

  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130A70);
  v4 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    v5 = (char *)operator new(0x28uLL);
    *(_OWORD *)v5 = 0u;
    *((_OWORD *)v5 + 1) = 0u;
    *(_QWORD *)(v5 + 29) = 0;
    sub_100261F9C((uint64_t)&a1->i64[1], v5);
    v6[0] = 68289538;
    v6[1] = 0;
    v7 = 2082;
    v8 = "";
    v9 = 2082;
    v10 = v5;
    v11 = 1026;
    v12 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService state changed to suspended: \", \"ServiceId\":%{public, location:escape_only}s, \"Previous state\":%{public}u}", (uint8_t *)v6, 0x22u);
    operator delete(v5);
  }
  sub_10034B61C(a1);
}

void sub_10034B600(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_10034B61C(int64x2_t *a1)
{
  int v2;
  _QWORD v3[3];
  uint64_t *v4;
  _QWORD *v5[2];
  int v6;

  sub_10034828C(a1, 1);
  v5[0] = 0;
  v5[1] = 0;
  memset(v3, 0, sizeof(v3));
  v4 = (uint64_t *)v5;
  v6 = 2;
  v2 = 2;
  sub_1000C6190(&v4, &v2, &v2);
  sub_10034BA18(a1, (uint64_t)v3);
  sub_100008848((uint64_t)&v4, v5[0]);
}

void sub_10034B694(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, _QWORD *a14)
{
  uint64_t v14;

  sub_100008848(v14, a14);
  _Unwind_Resume(a1);
}

void sub_10034B6B0(uint64_t *a1, _QWORD *a2, _OWORD *a3)
{
  unint64_t v4;
  NSObject *v5;
  char *v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v11;
  char *v12;
  char *v13;
  int v14;
  int v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  char *v19;
  __int16 v20;
  char *v21;

  v4 = a1[3];
  if (v4 >= 4)
  {
    if (v4 == 4)
    {
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130A70);
      v11 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        v12 = (char *)operator new(0x28uLL);
        *(_OWORD *)v12 = 0u;
        *((_OWORD *)v12 + 1) = 0u;
        *(_QWORD *)(v12 + 29) = 0;
        sub_100261F9C((uint64_t)a2, v12);
        v13 = (char *)operator new(0x28uLL);
        *(_QWORD *)(v13 + 29) = 0;
        *(_OWORD *)v13 = 0u;
        *((_OWORD *)v13 + 1) = 0u;
        sub_100261F9C((uint64_t)a3, v13);
        v14 = 68289538;
        v15 = 0;
        v16 = 2082;
        v17 = "";
        v18 = 2082;
        v19 = v12;
        v20 = 2082;
        v21 = v13;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"adding a label to the LSL out of learning flow\", \"Trigger UUID\":%{public, location:escape_only}s, \"Label UUID\":%{public, location:escape_only}s}", (uint8_t *)&v14, 0x26u);
        operator delete(v13);
        operator delete(v12);
      }
      sub_10034D854(a1, a2, a3);
    }
    else if (v4 == 5)
    {
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130A70);
      v7 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
      {
        v14 = 68289026;
        v15 = 0;
        v16 = 2082;
        v17 = "";
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"should not call addNewTruthLabelToModelIfAppropriate with CLMiLoServiceTypeMax\"}", (uint8_t *)&v14, 0x12u);
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_102130A70);
      }
      v8 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v14 = 68289026;
        v15 = 0;
        v16 = 2082;
        v17 = "";
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v8, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "should not call addNewTruthLabelToModelIfAppropriate with CLMiLoServiceTypeMax", "{\"msg%{public}.0s\":\"should not call addNewTruthLabelToModelIfAppropriate with CLMiLoServiceTypeMax\"}", (uint8_t *)&v14, 0x12u);
      }
    }
  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130A70);
    v5 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
    {
      v6 = (char *)*((unsigned int *)a1 + 6);
      v14 = 68289282;
      v15 = 0;
      v16 = 2082;
      v17 = "";
      v18 = 2050;
      v19 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"not adding new truth label out of learning flow\", \"ServiceType\":%{public}lu}", (uint8_t *)&v14, 0x1Cu);
    }
  }
}

void sub_10034B9E8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  operator delete(v2);
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_10034BA18(_QWORD *a1, uint64_t a2)
{
  int v2;
  uint64_t v3;
  NSObject *v6;
  char *v7;
  _BOOL4 v8;
  unint64_t v9;
  uint8_t buf[4];
  int v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  char *v15;
  __int16 v16;
  _BOOL4 v17;
  __int16 v18;
  _BOOL4 v19;

  v2 = *(_DWORD *)(a2 + 48);
  if (v2)
    v3 = 12;
  else
    v3 = -1;
  if (a1[52])
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130A70);
    v6 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      v7 = (char *)operator new(0x28uLL);
      *(_OWORD *)v7 = 0u;
      *((_OWORD *)v7 + 1) = 0u;
      *(_QWORD *)(v7 + 29) = 0;
      sub_100261F9C((uint64_t)(a1 + 1), v7);
      v8 = a1[52] != 0;
      *(_DWORD *)buf = 68289794;
      v11 = 0;
      v12 = 2082;
      v13 = "";
      v14 = 2082;
      v15 = v7;
      v16 = 1026;
      v17 = v8;
      v18 = 1026;
      v19 = v2 == 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService releasing observation requsts: \", \"ServiceId\":%{public, location:escape_only}s, \"NumRequests\":%{public}hhd, \"Success\":%{public}hhd}", buf, 0x28u);
      operator delete(v7);
    }
    while (a1[52])
    {
      v9 = *(_QWORD *)(a1[48] + 8 * (a1[51] / 0x7CuLL)) + 33 * (a1[51] % 0x7CuLL);
      if (!v2)
      {
        if (*(_BYTE *)(v9 + 32))
          sub_10034B6B0(a1, (_QWORD *)(*(_QWORD *)(a1[48] + 8 * (a1[51] / 0x7CuLL)) + 33 * (a1[51] % 0x7CuLL)), (_OWORD *)(v9 + 16));
      }
      (*(void (**)(_QWORD, _QWORD *, unint64_t, uint64_t))(*(_QWORD *)*a1 + 40))(*a1, a1 + 1, v9, v3);
      (*(void (**)(_QWORD, _QWORD *, unint64_t, uint64_t))(*(_QWORD *)*a1 + 48))(*a1, a1 + 1, v9, a2);
      *(int64x2_t *)(a1 + 51) = vaddq_s64(*(int64x2_t *)(a1 + 51), (int64x2_t)xmmword_101B9DFC0);
      sub_10034EE18((uint64_t)(a1 + 47), 1);
    }
  }
}

void sub_10034BC5C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10034BC78(uint64_t *a1, _OWORD *a2, uint64_t a3, int a4)
{
  _BOOL8 v8;
  int v9;
  uint64_t v10;
  NSObject *v11;
  char *v12;
  char *v13;
  int v14;
  char *v15;
  NSObject *v16;
  char *v17;
  const char *v18;
  int v19;
  int v20;
  int v21;
  uint64_t v23;
  int v24;
  _BYTE v25[18];
  __int16 v26;
  const char *v27;
  __int16 v28;
  char *v29;
  __int16 v30;
  char *v31;
  __int16 v32;
  int v33;
  __int16 v34;
  _BOOL4 v35;
  __int16 v36;
  int v37;
  __int16 v38;
  int v39;
  __int16 v40;
  int v41;
  __int16 v42;
  int v43;
  _BYTE __p[24];

  v8 = (a4 & 1) != 0 || *((_BYTE *)a1 + 296) == 0;
  if (sub_100348114())
  {
    v9 = *((unsigned __int8 *)a1 + 457);
    if (*((_BYTE *)a1 + 457))
      v9 = *((unsigned __int8 *)a1 + 456);
    v8 |= v9;
  }
  if (a1[11])
    goto LABEL_9;
  if (!*((_BYTE *)a1 + 368))
  {
    v23 = *a1;
    v25[0] = 0;
    v25[16] = 0;
    (*(void (**)(_BYTE *__return_ptr, uint64_t, uint64_t *, _OWORD *, _BYTE *, uint64_t, _BOOL8))(*(_QWORD *)v23 + 16))(__p, v23, a1 + 5, a2, v25, a3, v8);
    if (__p[17])
    {
      sub_10034722C((char *)a1, a2);
    }
    else
    {
      if (!__p[16])
      {
LABEL_9:
        v10 = 0;
        goto LABEL_10;
      }
      v24 = *((unsigned __int8 *)a1 + 368);
      *((_OWORD *)a1 + 22) = *(_OWORD *)__p;
      if (!v24)
        *((_BYTE *)a1 + 368) = 1;
      *(_OWORD *)v25 = *a2;
      v25[16] = 0;
      BYTE2(v29) = 0;
      sub_10034EEE4(a1 + 38, (uint64_t)v25);
    }
    v10 = 1;
LABEL_10:
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130A70);
    goto LABEL_12;
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130A70);
  v16 = qword_1022A00F8;
  v10 = 0;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    if (*((_BYTE *)a1 + 368))
    {
      v17 = (char *)operator new(0x28uLL);
      *(_QWORD *)__p = v17;
      *(_OWORD *)&__p[8] = xmmword_101B97FF0;
      *(_OWORD *)v17 = 0u;
      *((_OWORD *)v17 + 1) = 0u;
      *(_QWORD *)(v17 + 29) = 0;
      sub_100261F9C((uint64_t)(a1 + 44), v17);
      v18 = __p;
      if (__p[23] < 0)
        v18 = *(const char **)__p;
      *(_QWORD *)v25 = 68289282;
      *(_WORD *)&v25[8] = 2082;
      *(_QWORD *)&v25[10] = "";
      v26 = 2082;
      v27 = v18;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService reject prediction request because other request in progress\", \"LocalizationId\":%{public, location:escape_only}s}", v25, 0x1Cu);
      if ((__p[23] & 0x80000000) != 0)
        operator delete(*(void **)__p);
    }
    else
    {
      *(_QWORD *)v25 = 68289282;
      *(_WORD *)&v25[8] = 2082;
      *(_QWORD *)&v25[10] = "";
      v26 = 2082;
      v27 = "None";
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService reject prediction request because other request in progress\", \"LocalizationId\":%{public, location:escape_only}s}", v25, 0x1Cu);
    }
    goto LABEL_9;
  }
LABEL_12:
  v11 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    v12 = (char *)operator new(0x28uLL);
    *(_QWORD *)(v12 + 29) = 0;
    *(_OWORD *)v12 = 0u;
    *((_OWORD *)v12 + 1) = 0u;
    sub_100261F9C((uint64_t)(a1 + 1), v12);
    v13 = (char *)operator new(0x28uLL);
    *(_QWORD *)(v13 + 29) = 0;
    *(_OWORD *)v13 = 0u;
    *((_OWORD *)v13 + 1) = 0u;
    sub_100261F9C((uint64_t)a2, v13);
    v14 = *((unsigned __int8 *)a1 + 368);
    if (*((_BYTE *)a1 + 368))
    {
      v15 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v15 + 29) = 0;
      *(_OWORD *)v15 = 0u;
      *((_OWORD *)v15 + 1) = 0u;
      sub_100261F9C((uint64_t)(a1 + 44), v15);
    }
    else
    {
      v15 = "None";
    }
    v19 = *((_DWORD *)a1 + 22);
    v20 = *((unsigned __int8 *)a1 + 457);
    if (*((_BYTE *)a1 + 457))
      v20 = *((unsigned __int8 *)a1 + 456);
    v21 = *((unsigned __int8 *)a1 + 296);
    *(_QWORD *)v25 = 68291330;
    *(_WORD *)&v25[8] = 2082;
    *(_QWORD *)&v25[10] = "";
    v26 = 2082;
    v27 = v12;
    v28 = 2082;
    v29 = v13;
    v30 = 2082;
    v31 = v15;
    v32 = 1026;
    v33 = v19;
    v34 = 1026;
    v35 = v8;
    v36 = 1026;
    v37 = a4;
    v38 = 1026;
    v39 = v20;
    v40 = 1026;
    v41 = v21;
    v42 = 1026;
    v43 = v10;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService received prediction request: \", \"ServiceId\":%{public, location:escape_only}s, \"RequestId\":%{public, location:escape_only}s, \"LocalizationId\":%{public, location:escape_only}s, \"State\":%{public}u, \"force verdict\":%{public}hhd, \"isForcedRequest\":%{public}hhd, \"Is low latency\":%{public}hhd, \"Has valid cache\":%{public}hhd, \"Success\":%{public}hhd}", v25, 0x54u);
    if (v14)
      operator delete(v15);
    operator delete(v13);
    operator delete(v12);
  }
  return v10;
}

void sub_10034C0A4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10034C0F4(uint64_t *a1, _OWORD *a2, uint64_t a3, uint64_t a4)
{
  const void *v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v18;
  _BYTE __p[38];
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  __int128 v26;

  if (!a1[12] || a1[11] == 2 || !*(_BYTE *)a1[56])
  {
    v10 = 0;
    goto LABEL_8;
  }
  v8 = (const void *)*a1;
  v26 = *(_OWORD *)(a1 + 1);
  sub_1002B8598((const void **)a1 + 5, (uint64_t)&v26, (std::string *)__p);
  v9 = (*(uint64_t (**)(const void *, _BYTE *, _OWORD *, uint64_t, uint64_t))(*(_QWORD *)v8 + 24))(v8, __p, a2, a3, a4);
  v10 = v9;
  if ((__p[23] & 0x80000000) != 0)
  {
    operator delete(*(void **)__p);
    if (!(_DWORD)v10)
      goto LABEL_8;
  }
  else if (!(_DWORD)v9)
  {
    goto LABEL_8;
  }
  v18 = *(_OWORD *)a3;
  *(_OWORD *)__p = *a2;
  *(_OWORD *)&__p[16] = v18;
  __p[32] = *(_BYTE *)(a3 + 16);
  sub_10034EEE4(a1 + 47, (uint64_t)__p);
  v10 = 1;
LABEL_8:
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130A70);
  v11 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    v12 = (char *)operator new(0x28uLL);
    *(_QWORD *)(v12 + 29) = 0;
    *(_OWORD *)v12 = 0u;
    *((_OWORD *)v12 + 1) = 0u;
    sub_100261F9C((uint64_t)(a1 + 1), v12);
    v13 = (char *)operator new(0x28uLL);
    *(_QWORD *)(v13 + 29) = 0;
    *(_OWORD *)v13 = 0u;
    *((_OWORD *)v13 + 1) = 0u;
    sub_100261F9C((uint64_t)a2, v13);
    if (*(_BYTE *)(a3 + 16))
    {
      v14 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v14 + 29) = 0;
      *(_OWORD *)v14 = 0u;
      *((_OWORD *)v14 + 1) = 0u;
      sub_100261F9C(a3, v14);
      v15 = a1[11];
      *(_QWORD *)__p = 68290306;
      *(_WORD *)&__p[8] = 2082;
      *(_QWORD *)&__p[10] = "";
      *(_WORD *)&__p[18] = 2082;
      *(_QWORD *)&__p[20] = v12;
      *(_WORD *)&__p[28] = 2082;
      *(_QWORD *)&__p[30] = v13;
      v20 = 2082;
      v21 = v14;
      v22 = 1026;
      v23 = v15;
      v24 = 1026;
      v25 = v10;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService received observation request: \", \"ServiceId\":%{public, location:escape_only}s, \"RequestId\":%{public, location:escape_only}s, \"PlaceId\":%{public, location:escape_only}s, \"State\":%{public}u, \"Success\":%{public}hhd}", __p, 0x3Cu);
      operator delete(v14);
    }
    else
    {
      v16 = a1[11];
      *(_QWORD *)__p = 68290306;
      *(_WORD *)&__p[8] = 2082;
      *(_QWORD *)&__p[10] = "";
      *(_WORD *)&__p[18] = 2082;
      *(_QWORD *)&__p[20] = v12;
      *(_WORD *)&__p[28] = 2082;
      *(_QWORD *)&__p[30] = v13;
      v20 = 2082;
      v21 = "None";
      v22 = 1026;
      v23 = v16;
      v24 = 1026;
      v25 = v10;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService received observation request: \", \"ServiceId\":%{public, location:escape_only}s, \"RequestId\":%{public, location:escape_only}s, \"PlaceId\":%{public, location:escape_only}s, \"State\":%{public}u, \"Success\":%{public}hhd}", __p, 0x3Cu);
    }
    operator delete(v13);
    operator delete(v12);
  }
  return v10;
}

void sub_10034C3DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_10034C434(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  __int128 v2;

  v2 = *(_OWORD *)(a1 + 8);
  sub_1002B8598((const void **)(a1 + 40), (uint64_t)&v2, a2);
}

void sub_10034C490(_QWORD *a1, uint64_t a2)
{
  NSObject *v4;
  char *v5;
  _BOOL4 v6;
  _DWORD v7[2];
  __int16 v8;
  const char *v9;
  __int16 v10;
  char *v11;
  __int16 v12;
  _BOOL4 v13;

  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130A70);
  v4 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    v5 = (char *)operator new(0x28uLL);
    *(_OWORD *)v5 = 0u;
    *((_OWORD *)v5 + 1) = 0u;
    *(_QWORD *)(v5 + 29) = 0;
    sub_100261F9C((uint64_t)(a1 + 1), v5);
    v6 = *(_DWORD *)(a2 + 48) == 0;
    v7[0] = 68289538;
    v7[1] = 0;
    v8 = 2082;
    v9 = "";
    v10 = 2082;
    v11 = v5;
    v12 = 1026;
    v13 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService received recording stop: \", \"ServiceId\":%{public, location:escape_only}s, \"Success\":%{public}hhd}", (uint8_t *)v7, 0x22u);
    operator delete(v5);
  }
  sub_10034BA18(a1, a2);
}

void sub_10034C5D8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_10034C5F4(uint64_t a1@<X0>, _OWORD *a2@<X1>, uint64_t *a3@<X8>)
{
  void **v6;
  _QWORD *v7;
  uint64_t v8;
  void **v9;
  void *v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  _QWORD *v14;
  _QWORD *v15;
  char *v16;
  char *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  unint64_t v21;
  _QWORD *v22;
  char *v23;
  char *v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;
  char *v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  char *v35;
  char *v36;
  char *v37;
  uint64_t v38;
  char *v39;
  char *v40;
  uint64_t v41;
  _QWORD *v42;
  char *v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  char *v48;
  char *v49;
  char *v50;
  uint64_t v51;
  NSObject *v52;
  _OWORD *v53;
  void *p_p;
  uint64_t v55;
  unsigned __int8 *v56;
  int v57;
  __int128 v58;
  uint64_t v59;
  int v60;
  int v61;
  unint64_t v62;
  unint64_t v63;
  char *v64;
  _QWORD *v65;
  char *v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  unint64_t v70;
  char *v71;
  char *v72;
  char *v73;
  uint64_t v74;
  _QWORD *v75;
  uint64_t v76;
  _DWORD *v77;
  _DWORD *v78;
  uint64_t v79;
  void *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t *v83;
  uint64_t *i;
  void *v85;
  uint64_t v86;
  _QWORD *v87;
  uint64_t *v88;
  uint64_t *j;
  uint8_t *v90;
  uint64_t v91;
  _QWORD *v92;
  _OWORD *v93;
  char *v94;
  NSObject *v95;
  _OWORD *v96;
  void *v97;
  _QWORD *v98;
  int v99;
  int v100;
  void **v101;
  int v102;
  void **v103;
  void **v104;
  void **v105;
  void **v106;
  void **v107;
  void *v108;
  void **v109;
  void **v110;
  int v111;
  int v112;
  int v113;
  int v114;
  int v115;
  int v116;
  int v117;
  int v118;
  int v119;
  int v120;
  uint64_t v121;
  uint64_t v122;
  void *v123;
  void *v124[2];
  char v125;
  void *v126[2];
  char v127;
  void *v128;
  __int128 v129;
  void *v130[2];
  char v131;
  void *v132[2];
  char v133;
  void *v134;
  __int128 v135;
  void *v136[2];
  char v137;
  void *__p;
  __int128 v139;
  _QWORD v140[10];
  char v141;
  uint64_t v142;
  void *v143[2];
  char v144;
  uint8_t v145[8];
  _BYTE v146[10];
  __int16 v147;
  void *v148;
  __int16 v149;
  _QWORD *v150;
  __int16 v151;
  int v152;
  __int16 v153;
  void **v154;
  __int16 v155;
  void **v156;
  __int16 v157;
  void **v158;
  __int16 v159;
  void **v160;
  __int16 v161;
  void *v162;
  __int16 v163;
  void **v164;
  __int16 v165;
  void **v166;
  __int16 v167;
  int v168;
  __int16 v169;
  int v170;
  __int16 v171;
  int v172;
  __int16 v173;
  int v174;
  __int16 v175;
  int v176;
  __int16 v177;
  int v178;
  __int16 v179;
  int v180;
  __int16 v181;
  int v182;
  __int16 v183;
  int v184;
  __int16 v185;
  int v186;
  uint8_t buf[34];
  __int16 v188;
  int v189;
  __int16 v190;
  int v191;
  void *v192;
  char v193;
  uint64_t v194;

  a3[1] = 0;
  v6 = (void **)(a3 + 1);
  a3[2] = 0;
  a3[3] = 0;
  a3[7] = 0;
  *((_BYTE *)a3 + 64) = 0;
  *((_BYTE *)a3 + 68) = 0;
  v8 = *(_QWORD *)(a1 + 88);
  v7 = *(_QWORD **)(a1 + 96);
  *a3 = v8;
  *((_OWORD *)a3 + 5) = 0u;
  v9 = (void **)(a3 + 10);
  *((_BYTE *)a3 + 152) = 0;
  *((_OWORD *)a3 + 6) = 0u;
  *((_OWORD *)a3 + 7) = 0u;
  *((_BYTE *)a3 + 128) = 0;
  *(_OWORD *)((char *)a3 + 164) = 0u;
  *(_OWORD *)((char *)a3 + 180) = 0u;
  *((_DWORD *)a3 + 49) = 0;
  if (!v7)
  {
    v15 = sub_10025E6A0((uint64_t)(a3 + 3), 1uLL);
    v16 = (char *)a3[1];
    v17 = (char *)a3[2];
    v19 = &v15[v18];
    *v15 = 0;
    v14 = v15 + 1;
    while (v17 != v16)
    {
      v20 = *((_QWORD *)v17 - 1);
      v17 -= 8;
      *--v15 = v20;
    }
    a3[1] = (uint64_t)v15;
    a3[2] = (uint64_t)v14;
    a3[3] = (uint64_t)v19;
    if (!v16)
      goto LABEL_13;
    goto LABEL_12;
  }
  sub_1002EFDD8(v7, (uint64_t)buf);
  v10 = (void *)a3[13];
  if (v10)
  {
    a3[14] = (uint64_t)v10;
    operator delete(v10);
    a3[13] = 0;
    a3[14] = 0;
    a3[15] = 0;
  }
  *(_OWORD *)(a3 + 13) = *(_OWORD *)buf;
  a3[15] = *(_QWORD *)&buf[16];
  v11 = *(_QWORD *)(a1 + 96);
  if (!v11 || !sub_1002EFEB8(v11))
  {
    v12 = a3[3];
    v13 = (char *)a3[2];
    if ((unint64_t)v13 < v12)
    {
      *(_QWORD *)v13 = 1;
      v14 = v13 + 8;
LABEL_13:
      a3[2] = (uint64_t)v14;
      goto LABEL_14;
    }
    v16 = (char *)*v6;
    v25 = (v13 - (_BYTE *)*v6) >> 3;
    v26 = v25 + 1;
    if ((unint64_t)(v25 + 1) >> 61)
      sub_100259694();
    v27 = v12 - (_QWORD)v16;
    if (v27 >> 2 > v26)
      v26 = v27 >> 2;
    if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF8)
      v28 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v28 = v26;
    if (v28)
    {
      v29 = (char *)sub_10025E6A0((uint64_t)(a3 + 3), v28);
      v16 = (char *)a3[1];
      v13 = (char *)a3[2];
    }
    else
    {
      v29 = 0;
    }
    v36 = &v29[8 * v25];
    v37 = &v29[8 * v28];
    *(_QWORD *)v36 = 1;
    v14 = v36 + 8;
    while (v13 != v16)
    {
      v38 = *((_QWORD *)v13 - 1);
      v13 -= 8;
      *((_QWORD *)v36 - 1) = v38;
      v36 -= 8;
    }
    a3[1] = (uint64_t)v36;
    a3[2] = (uint64_t)v14;
    a3[3] = (uint64_t)v37;
    if (!v16)
      goto LABEL_13;
LABEL_12:
    operator delete(v16);
    goto LABEL_13;
  }
LABEL_14:
  if (!**(_BYTE **)(a1 + 448))
  {
    v22 = a3 + 3;
    v21 = a3[3];
    v23 = (char *)a3[2];
    if ((unint64_t)v23 >= v21)
    {
      v30 = (char *)*v6;
      v31 = (v23 - (_BYTE *)*v6) >> 3;
      v32 = v31 + 1;
      if ((unint64_t)(v31 + 1) >> 61)
        sub_100259694();
      v33 = v21 - (_QWORD)v30;
      if (v33 >> 2 > v32)
        v32 = v33 >> 2;
      if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8)
        v34 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v34 = v32;
      if (v34)
      {
        v35 = (char *)sub_10025E6A0((uint64_t)(a3 + 3), v34);
        v30 = (char *)a3[1];
        v23 = (char *)a3[2];
      }
      else
      {
        v35 = 0;
      }
      v39 = &v35[8 * v31];
      v40 = &v35[8 * v34];
      *(_QWORD *)v39 = 4;
      v24 = v39 + 8;
      while (v23 != v30)
      {
        v41 = *((_QWORD *)v23 - 1);
        v23 -= 8;
        *((_QWORD *)v39 - 1) = v41;
        v39 -= 8;
      }
      a3[1] = (uint64_t)v39;
      a3[2] = (uint64_t)v24;
      a3[3] = (uint64_t)v40;
      if (v30)
        operator delete(v30);
    }
    else
    {
      *(_QWORD *)v23 = 4;
      v24 = v23 + 8;
    }
    a3[2] = (uint64_t)v24;
    if (*(_BYTE *)(*(_QWORD *)(a1 + 448) + 1))
    {
      if ((unint64_t)v24 >= *v22)
      {
        v43 = (char *)*v6;
        v44 = (v24 - (_BYTE *)*v6) >> 3;
        v45 = v44 + 1;
        if ((unint64_t)(v44 + 1) >> 61)
          sub_100259694();
        v46 = *v22 - (_QWORD)v43;
        if (v46 >> 2 > v45)
          v45 = v46 >> 2;
        if ((unint64_t)v46 >= 0x7FFFFFFFFFFFFFF8)
          v47 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v47 = v45;
        if (v47)
        {
          v48 = (char *)sub_10025E6A0((uint64_t)(a3 + 3), v47);
          v43 = (char *)a3[1];
          v24 = (char *)a3[2];
        }
        else
        {
          v48 = 0;
        }
        v49 = &v48[8 * v44];
        v50 = &v48[8 * v47];
        *(_QWORD *)v49 = 2;
        v42 = v49 + 8;
        while (v24 != v43)
        {
          v51 = *((_QWORD *)v24 - 1);
          v24 -= 8;
          *((_QWORD *)v49 - 1) = v51;
          v49 -= 8;
        }
        a3[1] = (uint64_t)v49;
        a3[2] = (uint64_t)v42;
        a3[3] = (uint64_t)v50;
        if (v43)
          operator delete(v43);
      }
      else
      {
        *(_QWORD *)v24 = 2;
        v42 = v24 + 8;
      }
      a3[2] = (uint64_t)v42;
    }
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130A70);
    v52 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      v53 = operator new(0x28uLL);
      __p = v53;
      v139 = xmmword_101B97FF0;
      *v53 = 0u;
      v53[1] = 0u;
      *(_QWORD *)((char *)v53 + 29) = 0;
      sub_100261F9C(a1 + 8, v53);
      p_p = &__p;
      if (v139 < 0)
        p_p = __p;
      v55 = *a3;
      v56 = *(unsigned __int8 **)(a1 + 448);
      v57 = *v56;
      LODWORD(v56) = v56[1];
      *(_DWORD *)buf = 68290050;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2082;
      *(_QWORD *)&buf[20] = p_p;
      *(_WORD *)&buf[28] = 1026;
      *(_DWORD *)&buf[30] = v55;
      v188 = 1026;
      v189 = v57;
      v190 = 1026;
      v191 = (int)v56;
      _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService send status to client, MiLo Unavailable: \", \"ServiceId\":%{public, location:escape_only}s, \"State\":%{public}u, \"isMiLoEnabled\":%{public}hhd, \"isLowPowerMode\":%{public}hhd}", buf, 0x2Eu);
      if (SHIBYTE(v139) < 0)
        operator delete(__p);
    }
  }
  if (*a3)
  {
    if (*a3 == 1 && a3[1] == a3[2])
    {
      sub_1018F6678(buf);
LABEL_176:
      abort_report_np("%s:%d: assertion failure in %s", "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/ServiceManager/CLMiLoService.mm", *(_DWORD *)buf, "getCurrentStatus");
      __break(1u);
      return;
    }
  }
  else if (a3[1] != a3[2])
  {
    sub_1018F6508(buf);
    goto LABEL_176;
  }
  v58 = *(_OWORD *)(a1 + 24);
  *((_OWORD *)a3 + 2) = *(_OWORD *)(a1 + 8);
  *((_OWORD *)a3 + 3) = v58;
  a3[9] = 0;
  sub_10034F2B0((char *)a3 + 80, 0, 0, 0);
  v59 = *(_QWORD *)(a1 + 96);
  if (v59)
  {
    v60 = sub_1002ED910(v59);
    v61 = sub_1002ED918(*(_QWORD *)(a1 + 96));
    v62 = sub_10034ABDC(v60, v61);
    a3[9] = v62;
    if (v62 <= 0xA)
    {
      v63 = a3[12];
      v64 = (char *)a3[11];
      if ((unint64_t)v64 >= v63)
      {
        v66 = (char *)*v9;
        v67 = (v64 - (_BYTE *)*v9) >> 3;
        v68 = v67 + 1;
        if ((unint64_t)(v67 + 1) >> 61)
          sub_100259694();
        v69 = v63 - (_QWORD)v66;
        if (v69 >> 2 > v68)
          v68 = v69 >> 2;
        if ((unint64_t)v69 >= 0x7FFFFFFFFFFFFFF8)
          v70 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v70 = v68;
        if (v70)
        {
          v71 = (char *)sub_10025E6A0((uint64_t)(a3 + 12), v70);
          v66 = (char *)a3[10];
          v64 = (char *)a3[11];
        }
        else
        {
          v71 = 0;
        }
        v72 = &v71[8 * v67];
        v73 = &v71[8 * v70];
        *(_QWORD *)v72 = 3;
        v65 = v72 + 8;
        while (v64 != v66)
        {
          v74 = *((_QWORD *)v64 - 1);
          v64 -= 8;
          *((_QWORD *)v72 - 1) = v74;
          v72 -= 8;
        }
        a3[10] = (uint64_t)v72;
        a3[11] = (uint64_t)v65;
        a3[12] = (uint64_t)v73;
        if (v66)
          operator delete(v66);
      }
      else
      {
        *(_QWORD *)v64 = 3;
        v65 = v64 + 8;
      }
      a3[11] = (uint64_t)v65;
      v75 = (_QWORD *)sub_1002ED920(*(_QWORD *)(a1 + 96));
      if (v75[1] != *v75)
      {
        v76 = sub_1002ED920(*(_QWORD *)(a1 + 96));
        v77 = *(_DWORD **)v76;
        v78 = *(_DWORD **)(v76 + 8);
        *(_QWORD *)buf = a3 + 10;
        while (v77 != v78)
        {
          v79 = (*v77 - 1);
          if (v79 < 8)
            v80 = (void *)(v79 + 1);
          else
            v80 = 0;
          __p = v80;
          sub_1003142D8((uint64_t *)buf, &__p);
          ++v77;
        }
      }
    }
    *((_DWORD *)a3 + 40) = sub_1002ED634(*(_QWORD *)(a1 + 96));
    v81 = *(_QWORD *)(a1 + 96);
    *((_DWORD *)a3 + 42) = *(_DWORD *)(v81 + 204);
    *((_DWORD *)a3 + 45) = sub_1002EECE0(v81);
    v82 = *(_QWORD *)(a1 + 96);
    *((_DWORD *)a3 + 46) = (*(_QWORD *)(v82 + 240) - *(_QWORD *)(v82 + 232)) >> 5;
    *(uint64_t *)((char *)a3 + 188) = *(_QWORD *)(v82 + 216);
    *((_DWORD *)a3 + 49) = *(_DWORD *)(v82 + 224);
    *((_DWORD *)a3 + 41) = *(_DWORD *)(v82 + 200);
    *(uint64_t *)((char *)a3 + 172) = *(_QWORD *)(v82 + 208);
  }
  *((_OWORD *)a3 + 8) = *a2;
  *(_OWORD *)((char *)a3 + 137) = *(_OWORD *)((char *)a2 + 9);
  sub_100263E50((uint64_t)buf);
  v83 = (uint64_t *)a3[1];
  for (i = (uint64_t *)a3[2]; v83 != i; ++v83)
  {
    sub_10034D394(*v83, &__p);
    if (v139 >= 0)
      v85 = &__p;
    else
      v85 = __p;
    if (v139 >= 0)
      v86 = HIBYTE(v139);
    else
      v86 = v139;
    v87 = sub_100263F7C(&buf[16], (uint64_t)v85, v86);
    sub_100263F7C(v87, (uint64_t)" ", 1);
    if (SHIBYTE(v139) < 0)
      operator delete(__p);
  }
  std::stringbuf::str(v143, &buf[24]);
  sub_100263E50((uint64_t)&__p);
  v88 = (uint64_t *)a3[10];
  for (j = (uint64_t *)a3[11]; v88 != j; ++v88)
  {
    sub_10034D3A8(*v88, v145);
    if (SBYTE3(v148) >= 0)
      v90 = v145;
    else
      v90 = *(uint8_t **)v145;
    if (SBYTE3(v148) >= 0)
      v91 = BYTE3(v148);
    else
      v91 = *(_QWORD *)v146;
    v92 = sub_100263F7C((_QWORD *)&v139 + 1, (uint64_t)v90, v91);
    sub_100263F7C(v92, (uint64_t)" ", 1);
    if (SBYTE3(v148) < 0)
      operator delete(*(void **)v145);
  }
  std::stringbuf::str(v136, v140);
  if (*((_BYTE *)a3 + 152))
  {
    v93 = operator new(0x28uLL);
    v134 = v93;
    v135 = xmmword_101B97FF0;
    *v93 = 0u;
    v93[1] = 0u;
    *(_QWORD *)((char *)v93 + 29) = 0;
    sub_100261F9C((uint64_t)(a3 + 17), v93);
  }
  else
  {
    sub_1015A2E04(&v134, "None");
  }
  if (*((_BYTE *)a3 + 152))
    sub_10034D3BC(a3[16], v132);
  else
    sub_1015A2E04(v132, "None");
  if (*(_BYTE *)(a1 + 457))
  {
    if (*(_BYTE *)(a1 + 456))
      v94 = "low latency";
    else
      v94 = "not low latency";
  }
  else
  {
    v94 = "stopped";
  }
  sub_1015A2E04(v130, v94);
  if (qword_1022A0100 != -1)
    dispatch_once(&qword_1022A0100, &stru_102130A90);
  v95 = qword_1022A0108;
  if (os_log_type_enabled((os_log_t)qword_1022A0108, OS_LOG_TYPE_DEFAULT))
  {
    v96 = operator new(0x28uLL);
    v128 = v96;
    v129 = xmmword_101B97FF0;
    *v96 = 0u;
    v96[1] = 0u;
    *(_QWORD *)((char *)v96 + 29) = 0;
    sub_100261F9C(a1 + 8, v96);
    if (v129 >= 0)
      v97 = &v128;
    else
      v97 = v128;
    v98 = (_QWORD *)(a1 + 40);
    if (*(char *)(a1 + 63) < 0)
      v98 = (_QWORD *)*v98;
    v99 = *(_DWORD *)(a1 + 24);
    sub_1015A2E04(v126, (&off_102130B20)[*a3]);
    v100 = v127;
    v101 = (void **)v126[0];
    v102 = v144;
    v103 = (void **)v143[0];
    sub_10034D400(a3[9], v124);
    v104 = v143;
    if (v102 < 0)
      v104 = v103;
    v105 = (void **)v124[0];
    v106 = v126;
    if (v100 < 0)
      v106 = v101;
    v107 = (void **)v136[0];
    if (v125 >= 0)
      v105 = v124;
    if (v137 >= 0)
      v107 = v136;
    v108 = &v134;
    if (v135 < 0)
      v108 = v134;
    v109 = (void **)v132[0];
    if (v133 >= 0)
      v109 = v132;
    v110 = v130;
    if (v131 < 0)
      v110 = (void **)v130[0];
    v111 = *((_DWORD *)a3 + 40);
    v112 = *((_DWORD *)a3 + 41);
    v114 = *((_DWORD *)a3 + 42);
    v113 = *((_DWORD *)a3 + 43);
    v115 = *((_DWORD *)a3 + 44);
    v116 = *((_DWORD *)a3 + 45);
    v117 = *((_DWORD *)a3 + 46);
    v118 = *((_DWORD *)a3 + 47);
    v119 = *((_DWORD *)a3 + 48);
    v120 = *((_DWORD *)a3 + 49);
    *(_DWORD *)v145 = 68294147;
    *(_DWORD *)&v145[4] = 0;
    *(_WORD *)v146 = 2082;
    *(_QWORD *)&v146[2] = "";
    v147 = 2082;
    v148 = v97;
    v149 = 2082;
    v150 = v98;
    v151 = 1026;
    v152 = v99;
    v153 = 2082;
    v154 = v106;
    v155 = 2082;
    v156 = v104;
    v157 = 2082;
    v158 = v105;
    v159 = 2082;
    v160 = v107;
    v161 = 2081;
    v162 = v108;
    v163 = 2081;
    v164 = v109;
    v165 = 2082;
    v166 = v110;
    v167 = 1026;
    v168 = v111;
    v169 = 1026;
    v170 = v112;
    v171 = 1026;
    v172 = v114;
    v173 = 1026;
    v174 = v115;
    v175 = 1026;
    v176 = v113;
    v177 = 1026;
    v178 = v116;
    v179 = 1026;
    v180 = v117;
    v181 = 1026;
    v182 = v118;
    v183 = 1026;
    v184 = v119;
    v185 = 1026;
    v186 = v120;
    _os_log_impl((void *)&_mh_execute_header, v95, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService send status to client: \", \"ServiceId\":%{public, location:escape_only}s, \"ClientId\":%{public, location:escape_only}s, \"Service Type\":%{public}u, \"State\":%{public, location:escape_only}s, \"Suspend Reasons\":%{public, location:escape_only}s, \"Quality\":%{public, location:escape_only}s, \"Quality Reasons\":%{public, location:escape_only}s, \"Current LOI ID\":%{private, location:escape_only}s, \"Current LOI Type\":%{private, location:escape_only}s, \"Updates Status:\":%{public, location:escape_only}s, \"Number of clusters learned in model\":%{public}u, \"Number of Recording triggers at current LOI\":%{public}u, \"Number of Input Valid Fingerprints\":%{public}u, \"Number of Input Valid Fingerprints Labeled\":%{public}u, \"Number of Input Valid Fingerprints Unlabeled\":%{public}u, \"Number of Fingerprints Before Pruning\":%{public}u, \"Number of Fingerprints After Pruning\":%{public}u, \"Number of WiFi Access Points\":%{public}u, \"Number of Ble Sources\":%{public}u, \"Number of Uwb Sources\":%{public}u}", v145, 0xAEu);
    if (v125 < 0)
      operator delete(v124[0]);
    if (v127 < 0)
      operator delete(v126[0]);
    if (SHIBYTE(v129) < 0)
      operator delete(v128);
  }
  if (v131 < 0)
    operator delete(v130[0]);
  if (v133 < 0)
    operator delete(v132[0]);
  if (SHIBYTE(v135) < 0)
    operator delete(v134);
  if (v137 < 0)
    operator delete(v136[0]);
  *(void **)((char *)&__p
  *((_QWORD *)&v139 + 1) = v122;
  if (v141 < 0)
    operator delete((void *)v140[8]);
  std::streambuf::~streambuf(v140);
  std::ios::~ios(&v142);
  if (v144 < 0)
    operator delete(v143[0]);
  *(_QWORD *)buf = v121;
  *(_QWORD *)&buf[*(_QWORD *)(v121 - 24)] = v123;
  *(_QWORD *)&buf[16] = v122;
  if (v193 < 0)
    operator delete(v192);
  std::streambuf::~streambuf(&buf[24]);
  std::ios::~ios(&v194);
}

void sub_10034D230(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void *v2;

  operator delete(v2);
  sub_10034D484(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_10034D394@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  return sub_1015A2E04(a2, (&off_102130AB0)[a1]);
}

_QWORD *sub_10034D3A8@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  return sub_1015A2E04(a2, (&off_102130AD8)[a1]);
}

_QWORD *sub_10034D3BC@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  const char *v4;
  const char *v5;
  char *v6;

  v4 = "Home";
  v5 = "Custom";
  if (a1 != 2)
    v5 = "Other";
  if (a1)
    v4 = "Work";
  if (a1 <= 1)
    v6 = (char *)v4;
  else
    v6 = (char *)v5;
  return sub_1015A2E04(a2, v6);
}

_QWORD *sub_10034D400@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  const char *v4;
  const char *v5;
  const char *v6;
  const char *v7;
  char *v8;

  v4 = "Low";
  v5 = "HighCandidateHigh";
  if (a1 != 29)
    v5 = "High";
  v6 = "Medium";
  if (a1 != 20)
    v6 = "HighCandidateLow";
  if (a1 <= 28)
    v5 = v6;
  if (a1 == 9)
    v4 = "LowCandidateHigh";
  v7 = "Invalid";
  if (a1)
    v7 = "LowCandidateLow";
  if (a1 <= 8)
    v4 = v7;
  if (a1 <= 19)
    v8 = (char *)v4;
  else
    v8 = (char *)v5;
  return sub_1015A2E04(a2, v8);
}

_QWORD *sub_10034D484(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = (void *)a1[13];
  if (v2)
  {
    a1[14] = v2;
    operator delete(v2);
  }
  v3 = (void *)a1[10];
  if (v3)
  {
    a1[11] = v3;
    operator delete(v3);
  }
  v4 = (void *)a1[1];
  if (v4)
  {
    a1[2] = v4;
    operator delete(v4);
  }
  return a1;
}

void sub_10034D4D4(_QWORD *a1, _OWORD *a2)
{
  uint64_t v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *__p;
  void *v9;

  sub_10034C5F4((uint64_t)a1, a2, &v3);
  (*(void (**)(_QWORD, uint64_t *))(*(_QWORD *)*a1 + 64))(*a1, &v3);
  if (__p)
  {
    v9 = __p;
    operator delete(__p);
  }
  if (v6)
  {
    v7 = v6;
    operator delete(v6);
  }
  if (v4)
  {
    v5 = v4;
    operator delete(v4);
  }
}

void sub_10034D570(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_10034D484(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_10034D58C(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  NSObject *v10;
  char *v11;
  char *v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  void *__p;
  __int16 v18;
  const char *v19;
  __int16 v20;
  char *v21;
  __int16 v22;
  char *v23;
  __int16 v24;
  char *v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;
  __int128 v30;

  if ((unint64_t)(a1[3] - 2) <= 2 && a1[12] && a1[11] != 2 && *(_BYTE *)a1[56])
  {
    v6 = *a1;
    v30 = *(_OWORD *)(a1 + 1);
    sub_1002B8598((const void **)a1 + 5, (uint64_t)&v30, (std::string *)&__p);
    v7 = (*(uint64_t (**)(uint64_t, void **, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v6 + 72))(v6, &__p, *a2, a2[1], *a3, a3[1]);
    v8 = v7;
    if (SBYTE3(v21) < 0)
    {
      operator delete(__p);
      if (v8)
        goto LABEL_7;
    }
    else if (v7)
    {
LABEL_7:
      sub_10034B6B0(a1, a2, a3);
      v9 = 1;
      goto LABEL_10;
    }
  }
  v9 = 0;
LABEL_10:
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130A70);
  v10 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    v11 = (char *)operator new(0x28uLL);
    *(_QWORD *)(v11 + 29) = 0;
    *(_OWORD *)v11 = 0u;
    *((_OWORD *)v11 + 1) = 0u;
    sub_100261F9C((uint64_t)(a1 + 1), v11);
    v12 = (char *)operator new(0x28uLL);
    *(_QWORD *)(v12 + 29) = 0;
    *(_OWORD *)v12 = 0u;
    *((_OWORD *)v12 + 1) = 0u;
    sub_100261F9C((uint64_t)a2, v12);
    v13 = (char *)operator new(0x28uLL);
    *(_QWORD *)(v13 + 29) = 0;
    *(_OWORD *)v13 = 0u;
    *((_OWORD *)v13 + 1) = 0u;
    sub_100261F9C((uint64_t)a3, v13);
    v14 = a1[11];
    __p = (void *)68290306;
    v18 = 2082;
    v19 = "";
    v20 = 2082;
    v21 = v11;
    v22 = 2082;
    v23 = v12;
    v24 = 2082;
    v25 = v13;
    v26 = 1026;
    v27 = v14;
    v28 = 1026;
    v29 = v9;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService label observation request: \", \"ServiceId\":%{public, location:escape_only}s, \"RequestId\":%{public, location:escape_only}s, \"PlaceId\":%{public, location:escape_only}s, \"State\":%{public}u, \"Success\":%{public}hhd}", (uint8_t *)&__p, 0x3Cu);
    operator delete(v13);
    operator delete(v12);
    operator delete(v11);
  }
  if (v9)
    v15 = -1;
  else
    v15 = 13;
  return (*(uint64_t (**)(_QWORD, _QWORD *, _QWORD *, uint64_t))(*(_QWORD *)*a1 + 40))(*a1, a1 + 1, a2, v15);
}

void sub_10034D7FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_10034D854(uint64_t *a1, _QWORD *a2, _OWORD *a3)
{
  NSObject *v7;
  _OWORD *v8;
  void *p_p;
  uint64_t v10;
  NSObject *v11;
  _OWORD *v12;
  void *v13;
  _OWORD *v14;
  char *v15;
  _OWORD *v16;
  void *v17;
  uint64_t v18;
  _OWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  _OWORD *v23;
  NSObject *v24;
  NSObject *v25;
  NSObject *v26;
  char *v27;
  uint64_t v28;
  char *v29;
  NSObject *v30;
  char *v31;
  uint64_t v32;
  char *v33;
  NSObject *v34;
  char *v35;
  char *v36;
  char *v37;
  void *__p;
  __int128 v39;
  void *v40;
  __int128 v41;
  void *v42;
  __int128 v43;
  uint8_t buf[8];
  _BYTE v45[20];
  __int16 v46;
  char *v47;
  __int16 v48;
  __int128 v49;
  uint64_t v50;
  _BYTE v51[40];
  _BYTE v52[56];
  int v53;
  void *v54;
  void *v55;
  uint64_t v56;
  uint64_t v57;

  if (*((_BYTE *)a1 + 368))
  {
    if (a1[44] == *a2 && a1[45] == a2[1])
    {
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130A70);
      v7 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        v8 = operator new(0x28uLL);
        __p = v8;
        v39 = xmmword_101B97FF0;
        *v8 = 0u;
        v8[1] = 0u;
        *(_QWORD *)((char *)v8 + 29) = 0;
        sub_100261F9C((uint64_t)a2, v8);
        p_p = &__p;
        if (v39 < 0)
          p_p = __p;
        *(_DWORD *)buf = 68289282;
        *(_DWORD *)&buf[4] = 0;
        *(_WORD *)v45 = 2082;
        *(_QWORD *)&v45[2] = "";
        *(_WORD *)&v45[10] = 2082;
        *(_QWORD *)&v45[12] = p_p;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Attempting to apply truth label for a currently running localization\", \"TriggerUUID\":%{public, location:escape_only}s}", buf, 0x1Cu);
        if (SHIBYTE(v39) < 0)
          operator delete(__p);
      }
    }
  }
  v10 = a1[12];
  if (v10)
  {
    if (*(_BYTE *)(v10 + 192))
    {
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130A70);
      v11 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
      {
        v12 = operator new(0x28uLL);
        __p = v12;
        v39 = xmmword_101B97FF0;
        *v12 = 0u;
        v12[1] = 0u;
        *(_QWORD *)((char *)v12 + 29) = 0;
        sub_100261F9C((uint64_t)(a1 + 1), v12);
        if (v39 >= 0)
          v13 = &__p;
        else
          v13 = __p;
        v14 = operator new(0x28uLL);
        v42 = v14;
        v43 = xmmword_101B97FF0;
        *v14 = 0u;
        v14[1] = 0u;
        *(_QWORD *)((char *)v14 + 29) = 0;
        sub_100261F9C((uint64_t)a2, v14);
        if (v43 >= 0)
          v15 = (char *)&v42;
        else
          v15 = (char *)v42;
        v16 = operator new(0x28uLL);
        v40 = v16;
        v41 = xmmword_101B97FF0;
        *v16 = 0u;
        v16[1] = 0u;
        *(_QWORD *)((char *)v16 + 29) = 0;
        sub_100261F9C((uint64_t)a3, v16);
        v17 = &v40;
        if (v41 < 0)
          v17 = v40;
        *(_DWORD *)buf = 68289795;
        *(_DWORD *)&buf[4] = 0;
        *(_WORD *)v45 = 2082;
        *(_QWORD *)&v45[2] = "";
        *(_WORD *)&v45[10] = 2081;
        *(_QWORD *)&v45[12] = v13;
        v46 = 2082;
        v47 = v15;
        v48 = 2082;
        *(_QWORD *)&v49 = v17;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"service is appending an event to similarity list\", \"ServiceUUID\":%{private, location:escape_only}s, \"TriggerUUID\":%{public, location:escape_only}s, \"LabelUUID\":%{public, location:escape_only}s}", buf, 0x30u);
        if (SHIBYTE(v41) < 0)
          operator delete(v40);
        if (SHIBYTE(v43) < 0)
          operator delete(v42);
        if (SHIBYTE(v39) < 0)
          operator delete(__p);
      }
      v18 = *a1;
      v19 = operator new(0x10uLL);
      *(_QWORD *)buf = v19;
      *(_QWORD *)&v45[8] = v19 + 1;
      *v19 = *(_OWORD *)a2;
      *(_QWORD *)v45 = v19 + 1;
      (*(void (**)(void **__return_ptr, uint64_t, uint8_t *))(*(_QWORD *)v18 + 104))(&__p, v18, buf);
      if (*(_QWORD *)buf)
      {
        *(_QWORD *)v45 = *(_QWORD *)buf;
        operator delete(*(void **)buf);
      }
      v20 = sub_1002710E8(&__p, a2);
      v21 = v20;
      if (v20)
      {
        v22 = a1[12];
        sub_100271670((uint64_t)buf, (uint64_t)(v20 + 4));
        v49 = *(_OWORD *)(v21 + 9);
        v50 = v21[11];
        sub_100271B34((uint64_t)v51, (uint64_t)(v21 + 12));
        sub_100271DC4((uint64_t)v52, (uint64_t)(v21 + 17));
        *(_OWORD *)&v52[40] = *((_OWORD *)v21 + 11);
        v53 = *((_DWORD *)v21 + 48);
        v55 = 0;
        v56 = 0;
        v54 = 0;
        sub_10027205C(&v54, (const void *)v21[25], v21[26], (uint64_t)(v21[26] - v21[25]) >> 2);
        v42 = 0;
        v43 = 0uLL;
        v40 = &v42;
        LOBYTE(v41) = 0;
        v42 = operator new(0xC0uLL);
        *(_QWORD *)&v43 = v42;
        *((_QWORD *)&v43 + 1) = (char *)v42 + 192;
        *(_QWORD *)&v43 = sub_10034F3B8((uint64_t)&v43 + 8, (uint64_t)buf, (uint64_t)&v57, (uint64_t)v42);
        v23 = operator new(0x10uLL);
        *(_QWORD *)&v41 = v23 + 1;
        *((_QWORD *)&v41 + 1) = v23 + 1;
        *v23 = *a3;
        v40 = v23;
        sub_1002F2034(v22 + 72, v22, &v42, &v40);
        if (v40)
        {
          *(_QWORD *)&v41 = v40;
          operator delete(v40);
        }
        v40 = &v42;
        sub_100274134((void ***)&v40);
        if (v54)
        {
          v55 = v54;
          operator delete(v54);
        }
        sub_100067AC4((uint64_t)v52);
        sub_100067AC4((uint64_t)v51);
        sub_100271390((uint64_t)buf);
      }
      else
      {
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_102130A70);
        v34 = qword_1022A00F8;
        if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
        {
          v35 = (char *)operator new(0x28uLL);
          *(_QWORD *)(v35 + 29) = 0;
          *(_OWORD *)v35 = 0u;
          *((_OWORD *)v35 + 1) = 0u;
          sub_100261F9C((uint64_t)(a1 + 1), v35);
          v36 = (char *)operator new(0x28uLL);
          *(_QWORD *)(v36 + 29) = 0;
          *(_OWORD *)v36 = 0u;
          *((_OWORD *)v36 + 1) = 0u;
          sub_100261F9C((uint64_t)a2, v36);
          v37 = (char *)operator new(0x28uLL);
          *(_QWORD *)(v37 + 29) = 0;
          *(_OWORD *)v37 = 0u;
          *((_OWORD *)v37 + 1) = 0u;
          sub_100261F9C((uint64_t)a3, v37);
          *(_DWORD *)buf = 68289795;
          *(_DWORD *)&buf[4] = 0;
          *(_WORD *)v45 = 2082;
          *(_QWORD *)&v45[2] = "";
          *(_WORD *)&v45[10] = 2081;
          *(_QWORD *)&v45[12] = v35;
          v46 = 2082;
          v47 = v36;
          v48 = 2082;
          *(_QWORD *)&v49 = v37;
          _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"event not appended to similarity list, fingerprint not created!\", \"ServiceUUID\":%{private, location:escape_only}s, \"TriggerUUID\":%{public, location:escape_only}s, \"LabelUUID\":%{public, location:escape_only}s}", buf, 0x30u);
          operator delete(v37);
          operator delete(v36);
          operator delete(v35);
        }
      }
      sub_1002B971C((uint64_t)&__p);
    }
    else
    {
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130A70);
      v26 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
      {
        v27 = (char *)operator new(0x28uLL);
        *(_QWORD *)(v27 + 29) = 0;
        *(_OWORD *)v27 = 0u;
        *((_OWORD *)v27 + 1) = 0u;
        sub_100261F9C((uint64_t)(a1 + 1), v27);
        v28 = a1[12];
        v29 = (char *)operator new(0x28uLL);
        *(_QWORD *)(v29 + 29) = 0;
        *(_OWORD *)v29 = 0u;
        *((_OWORD *)v29 + 1) = 0u;
        sub_100261F9C(v28 + 352, v29);
        *(_DWORD *)buf = 68289539;
        *(_DWORD *)&buf[4] = 0;
        *(_WORD *)v45 = 2082;
        *(_QWORD *)&v45[2] = "";
        *(_WORD *)&v45[10] = 2081;
        *(_QWORD *)&v45[12] = v27;
        v46 = 2081;
        v47 = v29;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"when appending event to similarity list, model has no similarity list!\", \"ServiceUUID\":%{private, location:escape_only}s, \"ModelUUID\":%{private, location:escape_only}s}", buf, 0x26u);
        operator delete(v29);
        operator delete(v27);
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_102130A70);
      }
      v30 = qword_1022A00F8;
      if (os_signpost_enabled((os_log_t)qword_1022A00F8))
      {
        v31 = (char *)operator new(0x28uLL);
        *(_QWORD *)(v31 + 29) = 0;
        *(_OWORD *)v31 = 0u;
        *((_OWORD *)v31 + 1) = 0u;
        sub_100261F9C((uint64_t)(a1 + 1), v31);
        v32 = a1[12];
        v33 = (char *)operator new(0x28uLL);
        *(_QWORD *)(v33 + 29) = 0;
        *(_OWORD *)v33 = 0u;
        *((_OWORD *)v33 + 1) = 0u;
        sub_100261F9C(v32 + 352, v33);
        *(_DWORD *)buf = 68289539;
        *(_DWORD *)&buf[4] = 0;
        *(_WORD *)v45 = 2082;
        *(_QWORD *)&v45[2] = "";
        *(_WORD *)&v45[10] = 2081;
        *(_QWORD *)&v45[12] = v31;
        v46 = 2081;
        v47 = v33;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v30, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "when appending event to similarity list, model has no similarity list!", "{\"msg%{public}.0s\":\"when appending event to similarity list, model has no similarity list!\", \"ServiceUUID\":%{private, location:escape_only}s, \"ModelUUID\":%{private, location:escape_only}s}", buf, 0x26u);
        operator delete(v33);
        operator delete(v31);
      }
    }
  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130A70);
    v24 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 68289026;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)v45 = 2082;
      *(_QWORD *)&v45[2] = "";
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"when appending event to similarity list, service has no current model!\"}", buf, 0x12u);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130A70);
    }
    v25 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      *(_DWORD *)buf = 68289026;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)v45 = 2082;
      *(_QWORD *)&v45[2] = "";
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v25, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "when appending event to similarity list, service has no current model!", "{\"msg%{public}.0s\":\"when appending event to similarity list, service has no current model!\"}", buf, 0x12u);
    }
  }
}

void sub_10034E160(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30)
{
  void *v30;
  void *v31;
  void *v32;

  operator delete(v31);
  operator delete(v30);
  operator delete(v32);
  sub_1002B971C((uint64_t)&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_10034E2DC(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  BOOL v9;
  int v10;
  NSObject *v11;
  char *v12;
  uint64_t v13;
  char *v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  const void *v21;
  int v22;
  void *__p;
  __int16 v24;
  const char *v25;
  __int16 v26;
  char *v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  char *v31;
  __int16 v32;
  char *v33;
  __int16 v34;
  int v35;
  __int16 v36;
  int v37;
  __int128 v38;

  v8 = a1[3];
  if ((unint64_t)(v8 - 2) > 2
    || !a1[12]
    || a1[11] == 2
    || ((v8 & 0xFFFFFFFFFFFFFFFELL) == 2 ? (v9 = *(_BYTE *)a1[56] == 0) : (v9 = 1), v9))
  {
    v10 = 0;
  }
  else
  {
    v21 = (const void *)*a1;
    v38 = *(_OWORD *)(a1 + 1);
    sub_1002B8598((const void **)a1 + 5, (uint64_t)&v38, (std::string *)&__p);
    v22 = (*(uint64_t (**)(const void *, void **, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v21 + 80))(v21, &__p, a3, a4, a5);
    v10 = v22;
    if (SBYTE3(v27) < 0)
      operator delete(__p);
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130A70);
  v11 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    v12 = (char *)operator new(0x28uLL);
    *(_QWORD *)(v12 + 29) = 0;
    *(_OWORD *)v12 = 0u;
    *((_OWORD *)v12 + 1) = 0u;
    sub_100261F9C((uint64_t)(a1 + 1), v12);
    v13 = *((unsigned int *)a1 + 6);
    v14 = (char *)operator new(0x28uLL);
    *(_QWORD *)(v14 + 29) = 0;
    *(_OWORD *)v14 = 0u;
    *((_OWORD *)v14 + 1) = 0u;
    sub_100261F9C(a2, v14);
    v15 = (char *)operator new(0x28uLL);
    *(_QWORD *)(v15 + 29) = 0;
    *(_OWORD *)v15 = 0u;
    *((_OWORD *)v15 + 1) = 0u;
    sub_100261F9C(a3, v15);
    v16 = a1[11];
    __p = (void *)68290562;
    v24 = 2082;
    v25 = "";
    v26 = 2082;
    v27 = v12;
    v28 = 2050;
    v29 = v13;
    v30 = 2082;
    v31 = v14;
    v32 = 2082;
    v33 = v15;
    v34 = 1026;
    v35 = v16;
    v36 = 1026;
    v37 = v10;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService label observation request Between dates: \", \"ServiceId\":%{public, location:escape_only}s, \"ServiceType\":%{public}lu, \"RequestId\":%{public, location:escape_only}s, \"PlaceId\":%{public, location:escape_only}s, \"State\":%{public}u, \"Success\":%{public}hhd}", (uint8_t *)&__p, 0x46u);
    operator delete(v15);
    operator delete(v14);
    operator delete(v12);
  }
  if (v10)
    v17 = -1;
  else
    v17 = 14;
  return (*(uint64_t (**)(_QWORD, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)*a1 + 40))(*a1, a1 + 1, a2, v17);
}

void sub_10034E560(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_10034E5B8(_QWORD *a1, int a2)
{
  if (!*((_BYTE *)a1 + 457))
    *((_BYTE *)a1 + 457) = 1;
  *((_BYTE *)a1 + 456) = a2;
  sub_100349764(a1, a2);
}

void sub_10034E5D0(_BYTE *a1)
{
  uint64_t v2;
  NSObject *v3;
  char *v4;
  _DWORD v5[2];
  __int16 v6;
  const char *v7;
  __int16 v8;
  char *v9;

  v2 = (uint64_t)(a1 + 8);
  (*(void (**)(_QWORD, _BYTE *))(**(_QWORD **)a1 + 136))(*(_QWORD *)a1, a1 + 8);
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130A70);
  v3 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
  {
    v4 = (char *)operator new(0x28uLL);
    *(_OWORD *)v4 = 0u;
    *((_OWORD *)v4 + 1) = 0u;
    *(_QWORD *)(v4 + 29) = 0;
    sub_100261F9C(v2, v4);
    v5[0] = 68289283;
    v5[1] = 0;
    v6 = 2082;
    v7 = "";
    v8 = 2081;
    v9 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Disabling Low Latency updates if exist for Service:\", \"ServiceId\":%{private, location:escape_only}s}", (uint8_t *)v5, 0x1Cu);
    operator delete(v4);
  }
  if (a1[457])
    a1[457] = 0;
}

void sub_10034E70C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10034E720(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t result;

  v1 = *(_QWORD **)a1;
  v2 = *(_QWORD **)(a1 + 8);
  if (*(_QWORD **)a1 == v2)
    return 0;
  result = 0;
  do
  {
    if (*v1 >= 0x20uLL)
      sub_100263950("bitset set argument out of range");
    result |= 1 << *v1++;
  }
  while (v1 != v2);
  return result;
}

uint64_t sub_10034E77C(_QWORD *a1, _OWORD *a2)
{
  uint64_t v4;
  unint64_t v5;
  int v6;
  uint64_t v7;
  NSObject *v8;
  char *v9;
  uint64_t v10;
  _DWORD v12[2];
  __int16 v13;
  const char *v14;
  __int16 v15;
  char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  __int16 v21;
  uint64_t v22;

  if (*((_BYTE *)a1 + 440))
  {
    v4 = 31;
    (*(void (**)(void))(*(_QWORD *)*a1 + 40))();
  }
  else
  {
    v4 = -1;
  }
  v5 = a1[11];
  if (v5 >= 2)
  {
    if (v5 == 2)
    {
      v4 = 6;
      (*(void (**)(_QWORD, _QWORD *, _OWORD *, uint64_t))(*(_QWORD *)*a1 + 40))(*a1, a1 + 1, a2, 6);
    }
    v7 = 0;
  }
  else
  {
    v6 = *((unsigned __int8 *)a1 + 440);
    *(_OWORD *)(a1 + 53) = *a2;
    if (!v6)
      *((_BYTE *)a1 + 440) = 1;
    (*(void (**)(_QWORD))(*(_QWORD *)*a1 + 96))(*a1);
    v7 = 1;
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130A70);
  v8 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    v9 = (char *)operator new(0x28uLL);
    *(_OWORD *)v9 = 0u;
    *((_OWORD *)v9 + 1) = 0u;
    *(_QWORD *)(v9 + 29) = 0;
    sub_100261F9C((uint64_t)a2, v9);
    v10 = a1[11];
    v12[0] = 68290050;
    v12[1] = 0;
    v13 = 2082;
    v14 = "";
    v15 = 2082;
    v16 = v9;
    v17 = 1026;
    v18 = v7;
    v19 = 1026;
    v20 = v10;
    v21 = 2050;
    v22 = v4;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService::requestMicroLocationLearning\", \"RequestId\":%{public, location:escape_only}s, \"Will Start\":%{public}hhd, \"State\":%{public}u, \"Error Code\":%{public}ld}", (uint8_t *)v12, 0x32u);
    operator delete(v9);
  }
  return v7;
}

void sub_10034E95C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10034E970(uint64_t result)
{
  _BYTE *v1;
  uint64_t v2;
  NSObject *v3;
  char *v4;
  _DWORD v5[2];
  __int16 v6;
  const char *v7;
  __int16 v8;
  char *v9;
  __int16 v10;
  uint64_t v11;

  if (*(_BYTE *)(result + 440))
  {
    v1 = (_BYTE *)result;
    v2 = result + 424;
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130A70);
    v3 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      if (!v1[440])
        sub_10028DF3C();
      v4 = (char *)operator new(0x28uLL);
      *(_OWORD *)v4 = 0u;
      *((_OWORD *)v4 + 1) = 0u;
      *(_QWORD *)(v4 + 29) = 0;
      sub_100261F9C(v2, v4);
      v5[0] = 68289538;
      v5[1] = 0;
      v6 = 2082;
      v7 = "";
      v8 = 2082;
      v9 = v4;
      v10 = 2050;
      v11 = -1;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService::onLearningCompleted send completion to client\", \"RequestId\":%{public, location:escape_only}s, \"Error Code\":%{public}ld}", (uint8_t *)v5, 0x26u);
      operator delete(v4);
    }
    if (!v1[440])
      sub_10028DF3C();
    result = (*(uint64_t (**)(_QWORD, _BYTE *, uint64_t, uint64_t))(**(_QWORD **)v1 + 40))(*(_QWORD *)v1, v1 + 8, v2, -1);
    if (v1[440])
      v1[440] = 0;
  }
  return result;
}

void sub_10034EAE4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_10034EB00(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  NSObject *v4;
  uint64_t v5;
  _OWORD *v6;
  void *__p;
  __int128 v8;
  _QWORD v9[2];

  v9[0] = a2;
  v9[1] = a3;
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130A70);
  v4 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    __p = (void *)68289026;
    LOWORD(v8) = 2082;
    *(_QWORD *)((char *)&v8 + 2) = "";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoService::onLocalizationStart send event to client\"}", (uint8_t *)&__p, 0x12u);
  }
  v5 = *a1;
  v6 = operator new(0x28uLL);
  __p = v6;
  v8 = xmmword_101B97FF0;
  *v6 = 0u;
  v6[1] = 0u;
  *(_QWORD *)((char *)v6 + 29) = 0;
  sub_100261F9C((uint64_t)v9, v6);
  (*(void (**)(uint64_t, uint64_t *, _QWORD, void **))(*(_QWORD *)v5 + 56))(v5, a1 + 1, 0, &__p);
  if (SHIBYTE(v8) < 0)
    operator delete(__p);
}

void sub_10034EC48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_10034EC78(uint64_t *a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;

  v3 = a1[2];
  result = (uint64_t)(a1 + 2);
  v4 = *a1;
  v5 = a1[1];
  v6 = (v5 - *a1) >> 6;
  if (v6 < (v3 - *a1) >> 6)
  {
    v13 = result;
    if (v5 == v4)
    {
      v7 = 0;
      v8 = 0;
    }
    else
    {
      v7 = (char *)sub_1002697F0(result, v6);
    }
    v9 = v7;
    v10 = &v7[64 * v6];
    v11 = v10;
    v12 = &v7[64 * v8];
    sub_10026977C(a1, &v9);
    return sub_100269954((uint64_t)&v9);
  }
  return result;
}

void sub_10034ECFC(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x10034ECECLL);
}

void sub_10034ED24(id a1)
{
  qword_1022A00F8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_10034ED50(id a1)
{
  qword_1022A0108 = (uint64_t)os_log_create("com.apple.locationd.Position", "MicrolocationQE");
}

__n128 sub_10034ED7C(uint64_t a1, __n128 *a2)
{
  __n128 result;

  if (*(unsigned __int8 *)(a1 + 24) == a2[1].n128_u8[8])
  {
    if (*(_BYTE *)(a1 + 24))
    {
      if (*(char *)(a1 + 23) < 0)
        operator delete(*(void **)a1);
      result = *a2;
      *(_QWORD *)(a1 + 16) = a2[1].n128_u64[0];
      *(__n128 *)a1 = result;
      a2[1].n128_u8[7] = 0;
      a2->n128_u8[0] = 0;
    }
  }
  else if (*(_BYTE *)(a1 + 24))
  {
    if (*(char *)(a1 + 23) < 0)
      operator delete(*(void **)a1);
    *(_BYTE *)(a1 + 24) = 0;
  }
  else
  {
    result = *a2;
    *(_QWORD *)(a1 + 16) = a2[1].n128_u64[0];
    *(__n128 *)a1 = result;
    a2->n128_u64[1] = 0;
    a2[1].n128_u64[0] = 0;
    a2->n128_u64[0] = 0;
    *(_BYTE *)(a1 + 24) = 1;
  }
  return result;
}

uint64_t sub_10034EE18(uint64_t a1, int a2)
{
  unint64_t v2;
  int v4;

  v2 = *(_QWORD *)(a1 + 32);
  if (v2 < 0x7C)
    a2 = 1;
  if (v2 < 0xF8)
    v4 = a2;
  else
    v4 = 0;
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(_QWORD *)(a1 + 8) += 8;
    *(_QWORD *)(a1 + 32) -= 124;
  }
  return v4 ^ 1u;
}

void sub_10034EE74(uint64_t a1)
{
  void *v2;
  void *v3;

  if (*(_BYTE *)(a1 + 184))
  {
    v2 = *(void **)(a1 + 144);
    if (v2)
    {
      *(_QWORD *)(a1 + 152) = v2;
      operator delete(v2);
    }
    if (*(_BYTE *)(a1 + 128))
      sub_1002A1C94(a1 + 88);
    if (*(_BYTE *)(a1 + 80) && *(char *)(a1 + 79) < 0)
      operator delete(*(void **)(a1 + 56));
    v3 = *(void **)a1;
    if (*(_QWORD *)a1)
    {
      *(_QWORD *)(a1 + 8) = v3;
      operator delete(v3);
    }
    *(_BYTE *)(a1 + 184) = 0;
  }
}

__n128 sub_10034EEE4(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  __n128 result;
  __int128 v10;

  v4 = a1[2];
  v5 = a1[1];
  v6 = 124 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5)
    v6 = 0;
  v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_10034EF9C(a1);
    v5 = a1[1];
    v7 = a1[5] + a1[4];
  }
  v8 = *(_QWORD *)(v5 + 8 * (v7 / 0x7C)) + 33 * (v7 % 0x7C);
  result = *(__n128 *)a2;
  v10 = *(_OWORD *)(a2 + 16);
  *(_BYTE *)(v8 + 32) = *(_BYTE *)(a2 + 32);
  *(__n128 *)v8 = result;
  *(_OWORD *)(v8 + 16) = v10;
  ++a1[5];
  return result;
}

void sub_10034EF9C(_QWORD *a1)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  uint64_t v5;
  char *v6;
  _QWORD *v7;
  char *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  int64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  char *v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  unint64_t v33;
  char *v34;
  char *v35;
  uint64_t v36;
  char *v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  char *v43;
  _QWORD *v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  void *v53;
  __int128 v54;
  __int128 v55;
  _QWORD *v56;

  v2 = a1[4];
  v3 = v2 >= 0x7C;
  v4 = v2 - 124;
  if (v3)
  {
    v5 = (uint64_t)(a1 + 3);
    v6 = (char *)a1[3];
    a1[4] = v4;
    v7 = (_QWORD *)a1[1];
    v8 = (char *)a1[2];
    v11 = *v7;
    v9 = (char *)(v7 + 1);
    v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(_QWORD *)v8 = v10;
      a1[2] += 8;
      return;
    }
    v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1)
        v33 = 1;
      else
        v33 = (uint64_t)&v8[-*a1] >> 2;
      v34 = (char *)sub_10025E6A0(v5, v33);
      v35 = &v34[8 * (v33 >> 2)];
      v37 = &v34[8 * v36];
      v38 = (uint64_t *)a1[1];
      v8 = v35;
      v39 = a1[2] - (_QWORD)v38;
      if (v39)
      {
        v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        v40 = 8 * (v39 >> 3);
        v41 = &v34[8 * (v33 >> 2)];
        do
        {
          v42 = *v38++;
          *(_QWORD *)v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    v13 = v12 >> 3;
    v14 = v12 >> 3 < -1;
    v15 = (v12 >> 3) + 2;
    if (v14)
      v16 = v15;
    else
      v16 = v13 + 1;
    v17 = -(v16 >> 1);
    v18 = v16 >> 1;
    v19 = &v9[-8 * v18];
    v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      v9 = (char *)a1[1];
    }
    v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  v21 = a1[2];
  v22 = (v21 - a1[1]) >> 3;
  v23 = a1[3];
  v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(_QWORD *)&v54 = operator new(0xFFCuLL);
      sub_100212218(a1, &v54);
      return;
    }
    *(_QWORD *)&v54 = operator new(0xFFCuLL);
    sub_100343094((uint64_t)a1, &v54);
    v44 = (_QWORD *)a1[1];
    v8 = (char *)a1[2];
    v45 = *v44;
    v9 = (char *)(v44 + 1);
    v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3])
      goto LABEL_33;
    v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1)
        v46 = 1;
      else
        v46 = (uint64_t)&v8[-*a1] >> 2;
      v34 = (char *)sub_10025E6A0((uint64_t)(a1 + 3), v46);
      v35 = &v34[8 * (v46 >> 2)];
      v37 = &v34[8 * v47];
      v48 = (uint64_t *)a1[1];
      v8 = v35;
      v49 = a1[2] - (_QWORD)v48;
      if (v49)
      {
        v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        v50 = 8 * (v49 >> 3);
        v51 = &v34[8 * (v46 >> 2)];
        do
        {
          v52 = *v48++;
          *(_QWORD *)v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1)
    v25 = 1;
  else
    v25 = v24 >> 2;
  v56 = a1 + 3;
  *(_QWORD *)&v54 = sub_10025E6A0((uint64_t)(a1 + 3), v25);
  *((_QWORD *)&v54 + 1) = v54 + 8 * v22;
  *(_QWORD *)&v55 = *((_QWORD *)&v54 + 1);
  *((_QWORD *)&v55 + 1) = v54 + 8 * v26;
  v53 = operator new(0xFFCuLL);
  sub_10003732C(&v54, &v53);
  v27 = (_QWORD *)a1[2];
  v28 = -7 - (_QWORD)v27;
  while (v27 != (_QWORD *)a1[1])
  {
    --v27;
    v28 += 8;
    sub_1003431B0((uint64_t)&v54, v27);
  }
  v29 = (char *)*a1;
  v30 = v54;
  v31 = v55;
  *(_QWORD *)&v54 = *a1;
  *((_QWORD *)&v54 + 1) = v27;
  v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  v55 = v32;
  if (v27 != (_QWORD *)v32)
    *(_QWORD *)&v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  if (v29)
    operator delete(v29);
}

void sub_10034F264(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  void *v13;

  operator delete(v13);
  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

char *sub_10034F2B0(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 3)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 61)
      sub_100259694();
    v10 = v8 >> 2;
    if (v8 >> 2 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = sub_10025E660(v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 3;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[8 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

uint64_t sub_10034F3B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v6;
  _QWORD v9[3];
  char v10;
  uint64_t v11;
  uint64_t v12;

  v4 = a4;
  v11 = a4;
  v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  v10 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      sub_100274594(a1, v4, v6);
      v6 += 192;
      v4 = v12 + 192;
      v12 += 192;
    }
    while (v6 != a3);
  }
  v10 = 1;
  sub_10034F460((uint64_t)v9);
  return v4;
}

void sub_10034F44C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_10034F460((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_10034F460(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    sub_10034F494((uint64_t *)a1);
  return a1;
}

uint64_t *sub_10034F494(uint64_t *result)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = (uint64_t *)result[1];
  v1 = (uint64_t *)result[2];
  v3 = *v1;
  v4 = *v2;
  if (*v1 != *v2)
  {
    v5 = *result;
    do
    {
      v3 -= 192;
      result = (uint64_t *)sub_100271310(v5, v3);
    }
    while (v3 != v4);
  }
  return result;
}

BOOL sub_10034F4E4(NSObject *a1)
{
  return os_log_type_enabled(a1, OS_LOG_TYPE_FAULT);
}

void sub_10034F4EC(uint64_t a1@<X8>)
{
  unsigned __int8 v2;

  v2 = atomic_load((unsigned __int8 *)&qword_1022A0830);
  if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_1022A0830))
  {
    sub_1003567BC((std::string *)&xmmword_1022A0818);
    __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_1022A0818, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_1022A0830);
  }
  if (byte_1022A082F < 0)
  {
    sub_100115CE4((_BYTE *)a1, (void *)xmmword_1022A0818, *((unint64_t *)&xmmword_1022A0818 + 1));
  }
  else
  {
    *(_OWORD *)a1 = xmmword_1022A0818;
    *(_QWORD *)(a1 + 16) = unk_1022A0828;
  }
}

void sub_10034F59C(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_1022A0830);
  _Unwind_Resume(a1);
}

void sub_10034F5B4(uint64_t a1@<X8>)
{
  unsigned __int8 v2;

  v2 = atomic_load((unsigned __int8 *)&qword_1022A0850);
  if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_1022A0850))
  {
    sub_100356CA8((std::string *)&xmmword_1022A0838);
    __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_1022A0838, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_1022A0850);
  }
  if (byte_1022A084F < 0)
  {
    sub_100115CE4((_BYTE *)a1, (void *)xmmword_1022A0838, *((unint64_t *)&xmmword_1022A0838 + 1));
  }
  else
  {
    *(_OWORD *)a1 = xmmword_1022A0838;
    *(_QWORD *)(a1 + 16) = unk_1022A0848;
  }
}

void sub_10034F664(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_1022A0850);
  _Unwind_Resume(a1);
}

void sub_10034F67C(uint64_t a1)
{
  BOOL v2;
  BOOL v3;
  NSObject *v4;
  uint8_t *v5;
  double v6;
  NSObject *v7;
  uint8_t *v8;
  NSObject *v9;
  double v10;
  uint8_t *v11;
  int v12;
  const char *v13;
  uint8_t buf[4];
  const char *v15;

  v2 = sub_1000CC4F4(*(_QWORD *)a1);
  *(_BYTE *)(a1 + 8) = v2;
  if (v2)
  {
    sub_10034FB54((uint64_t *)a1);
    sub_100634364(*(_QWORD *)a1, "MiLoServices", (const char **)&off_102130B58, 0, 0);
    v3 = sub_100635B3C(*(_QWORD *)a1, "MiLoServices");
    *(_BYTE *)(a1 + 8) = v3;
    if (v3)
    {
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130B38);
      v4 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136315138;
        v15 = "MiLoServices";
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "Sucessfully created table if necessary: %s", buf, 0xCu);
      }
      if (sub_1001BFF7C(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_102130B38);
        v6 = _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 2, "Sucessfully created table if necessary: %s", &v12);
LABEL_19:
        v8 = v5;
        sub_100512490("Generic", 1, 0, 2, "void CLMiLoServiceTable::initTable()", "%s\n", v6);
LABEL_29:
        if (v8 != buf)
          free(v8);
      }
    }
    else
    {
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130B38);
      v9 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "MiLoServices";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Failed to create table: %{public}s", buf, 0xCu);
      }
      if (sub_1001BFF7C(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_102130B38);
        v12 = 136446210;
        v13 = "MiLoServices";
        v10 = _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 16, "Failed to create table: %{public}s", &v12, 12);
        v8 = v11;
        sub_100512490("Generic", 1, 0, 0, "void CLMiLoServiceTable::initTable()", "%s\n", v10);
        goto LABEL_29;
      }
    }
  }
  else
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130B38);
    v7 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "Database is not connected so we can't intialize our table", buf, 2u);
    }
    if (sub_1001BFF7C(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130B38);
      v6 = _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 2, "Database is not connected so we can't intialize our table");
      goto LABEL_19;
    }
  }
}

uint64_t sub_10034FA70(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = a2;
  *(_BYTE *)(a1 + 8) = 0;
  sub_10034F67C(a1);
  return a1;
}

uint64_t sub_10034FA9C(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, __int128 *a5, uint64_t a6, __int128 *a7, double a8)
{
  __int128 v11;
  _BYTE *v12;
  __int128 v13;

  *(_QWORD *)a1 = a4;
  *(_QWORD *)(a1 + 8) = a2;
  *(_QWORD *)(a1 + 16) = a3;
  *(double *)(a1 + 24) = a8;
  if (*((char *)a5 + 23) < 0)
  {
    sub_100115CE4((_BYTE *)(a1 + 32), *(void **)a5, *((_QWORD *)a5 + 1));
  }
  else
  {
    v11 = *a5;
    *(_QWORD *)(a1 + 48) = *((_QWORD *)a5 + 2);
    *(_OWORD *)(a1 + 32) = v11;
  }
  *(_QWORD *)(a1 + 56) = a6;
  v12 = (_BYTE *)(a1 + 64);
  if (*((char *)a7 + 23) < 0)
  {
    sub_100115CE4(v12, *(void **)a7, *((_QWORD *)a7 + 1));
  }
  else
  {
    v13 = *a7;
    *(_QWORD *)(a1 + 80) = *((_QWORD *)a7 + 2);
    *(_OWORD *)v12 = v13;
  }
  return a1;
}

void sub_10034FB34(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 55) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

BOOL sub_10034FB54(uint64_t *a1)
{
  _BOOL8 result;

  result = sub_100635B3C(*a1, "MiLoServices");
  if (result)
    return sub_1002639C4(*a1, (uint64_t *)&off_102130B58, 7, "MiLoServices");
  return result;
}

void sub_10034FBA8(uint64_t a1, uint64_t a2, unsigned int a3)
{
  std::string *v6;
  __int128 v7;
  void **v8;
  std::string::size_type v9;
  std::string *v10;
  __int128 v11;
  std::string *v12;
  __int128 v13;
  std::string *v14;
  __int128 v15;
  std::string *v16;
  __int128 v17;
  int v18;
  const std::string::value_type *v19;
  std::string::size_type v20;
  std::string *v21;
  __int128 v22;
  std::string *v23;
  __int128 v24;
  std::string *v25;
  std::string::size_type size;
  std::string *v27;
  __int128 v28;
  std::string *v29;
  __int128 v30;
  char *v31;
  std::string::value_type v32[8];
  char v33;
  std::string v34;
  std::string::value_type v35[8];
  char v36;
  void *__p[2];
  unsigned __int8 v38;
  std::string::value_type __s[8];
  char v40;
  std::string v41;
  std::string v42;
  std::string v43;
  std::string v44;
  std::string v45;
  std::string v46;
  void *v47[2];
  int64_t v48;
  std::string v49;
  std::string v50;
  std::string v51;

  *((_BYTE *)&v41.__r_.__value_.__s + 23) = 15;
  strcpy((char *)&v41, "SELECT * FROM (");
  v40 = 7;
  strcpy(__s, "SELECT ");
  v6 = std::string::append(&v41, __s, 7uLL);
  v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v42.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  sub_10034F4EC((uint64_t)__p);
  if ((v38 & 0x80u) == 0)
    v8 = __p;
  else
    v8 = (void **)__p[0];
  if ((v38 & 0x80u) == 0)
    v9 = v38;
  else
    v9 = (std::string::size_type)__p[1];
  v10 = std::string::append(&v42, (const std::string::value_type *)v8, v9);
  v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  v43.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v11;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  v12 = std::string::append(&v43, " FROM ");
  v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  v44.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v44.__r_.__value_.__l.__data_ = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  v14 = std::string::append(&v44, "MiLoServices");
  v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v45.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v45.__r_.__value_.__l.__data_ = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  v16 = std::string::append(&v45, " ");
  v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  v50.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v50.__r_.__value_.__l.__data_ = v17;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  v18 = *(char *)(a2 + 23);
  if (v18 >= 0)
    v19 = (const std::string::value_type *)a2;
  else
    v19 = *(const std::string::value_type **)a2;
  if (v18 >= 0)
    v20 = *(unsigned __int8 *)(a2 + 23);
  else
    v20 = *(_QWORD *)(a2 + 8);
  v21 = std::string::append(&v50, v19, v20);
  v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
  v51.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v51.__r_.__value_.__l.__data_ = v22;
  v21->__r_.__value_.__l.__size_ = 0;
  v21->__r_.__value_.__r.__words[2] = 0;
  v21->__r_.__value_.__r.__words[0] = 0;
  v36 = 7;
  strcpy(v35, " LIMIT ");
  v23 = std::string::append(&v51, v35, 7uLL);
  v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
  v46.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v46.__r_.__value_.__l.__data_ = v24;
  v23->__r_.__value_.__l.__size_ = 0;
  v23->__r_.__value_.__r.__words[2] = 0;
  v23->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v34, a3);
  if ((v34.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v25 = &v34;
  else
    v25 = (std::string *)v34.__r_.__value_.__r.__words[0];
  if ((v34.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v34.__r_.__value_.__r.__words[2]);
  else
    size = v34.__r_.__value_.__l.__size_;
  v27 = std::string::append(&v46, (const std::string::value_type *)v25, size);
  v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
  v49.__r_.__value_.__r.__words[2] = v27->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v49.__r_.__value_.__l.__data_ = v28;
  v27->__r_.__value_.__l.__size_ = 0;
  v27->__r_.__value_.__r.__words[2] = 0;
  v27->__r_.__value_.__r.__words[0] = 0;
  v33 = 1;
  strcpy(v32, ")");
  v29 = std::string::append(&v49, v32, 1uLL);
  v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
  v48 = v29->__r_.__value_.__r.__words[2];
  *(_OWORD *)v47 = v30;
  v29->__r_.__value_.__l.__size_ = 0;
  v29->__r_.__value_.__r.__words[2] = 0;
  v29->__r_.__value_.__r.__words[0] = 0;
  if (v33 < 0)
    operator delete(*(void **)v32);
  if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v49.__r_.__value_.__l.__data_);
  if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v34.__r_.__value_.__l.__data_);
  if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v46.__r_.__value_.__l.__data_);
  if (v36 < 0)
    operator delete(*(void **)v35);
  if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v51.__r_.__value_.__l.__data_);
  if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v50.__r_.__value_.__l.__data_);
  if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v45.__r_.__value_.__l.__data_);
  if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v44.__r_.__value_.__l.__data_);
  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v43.__r_.__value_.__l.__data_);
  if ((char)v38 < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v42.__r_.__value_.__l.__data_);
  if (v40 < 0)
    operator delete(*(void **)__s);
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v41.__r_.__value_.__l.__data_);
  if (v48 >= 0)
    v31 = (char *)v47;
  else
    v31 = (char *)v47[0];
  sub_1000CDA68(a1, v31);
}

void sub_1003500B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,uint64_t a47,uint64_t a48,void *__p,uint64_t a50,int a51,__int16 a52,char a53,char a54,uint64_t a55,void **buf)
{
  uint64_t v56;

  buf = &a45;
  sub_100302A1C(&buf);
  if (v56)
    (*(void (**)(uint64_t))(*(_QWORD *)v56 + 8))(v56);
  if (a54 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t sub_10035045C(uint64_t a1)
{
  uint64_t v1;
  char *v2;
  NSObject *v3;
  const char *v5;
  uint8_t *v6;
  void *__p;
  uint8_t buf[8];

  if (*(_BYTE *)(a1 + 8))
  {
    v1 = *(_QWORD *)a1;
    if (byte_10230117F >= 0)
      v2 = (char *)&xmmword_102301168;
    else
      v2 = (char *)xmmword_102301168;
    sub_1000CDA68(v1, v2);
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130B38);
  v3 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#Warning Table is not valid so we can't insert or replace", buf, 2u);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130B38);
    LOWORD(__p) = 0;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#Warning Table is not valid so we can't insert or replace", &__p, 2);
    v6 = (uint8_t *)v5;
    sub_100512490("Generic", 1, 0, 2, "BOOL CLMiLoServiceTable::insertOrReplace(const std::vector<CLMiLoServiceTable::Entry> &)", "%s\n", v5);
    if (v6 != buf)
      free(v6);
  }
  return 0;
}

void sub_100350A7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,std::bad_cast a26)
{
  if (a22 < 0)
    operator delete(__p);
  if (a23)
    (*(void (**)(uint64_t))(*(_QWORD *)a23 + 8))(a23);
  _Unwind_Resume(exception_object);
}

void sub_100350AE0(uint64_t a1@<X0>, std::string::size_type a2@<X1>, uint64_t a3@<X2>, unsigned int a4@<W3>, _QWORD *a5@<X8>)
{
  std::string *v10;
  __int128 v11;
  std::string *v12;
  __int128 v13;
  int v14;
  const std::string::value_type *v15;
  std::string::size_type v16;
  std::string *v17;
  __int128 v18;
  std::string *v19;
  __int128 v20;
  std::string *v21;
  __int128 v22;
  std::string *v23;
  __int128 v24;
  std::string *v25;
  __int128 v26;
  int v27;
  const std::string::value_type *v28;
  std::string::size_type v29;
  std::string *v30;
  __int128 v31;
  std::string *v32;
  __int128 v33;
  NSObject *v34;
  const std::string::value_type *v35;
  std::string::size_type v36;
  const char *v37;
  void **v38;
  std::string::value_type v39[8];
  char v40;
  std::string::value_type v41[8];
  char v42;
  std::string::value_type v43[8];
  char v44;
  std::string::value_type v45[8];
  char v46;
  std::string::value_type __s[8];
  char v48;
  std::string v49;
  std::string v50;
  std::string v51;
  std::string v52;
  std::string v53;
  std::string v54;
  std::string v55;
  std::string v56;
  std::string v57;
  void *__p[2];
  std::string::size_type v59;

  if (*(_BYTE *)(a1 + 8))
  {
    *((_BYTE *)&v49.__r_.__value_.__s + 23) = 6;
    strcpy((char *)&v49, "WHERE ");
    v10 = std::string::append(&v49, "ClientID");
    v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    v50.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v50.__r_.__value_.__l.__data_ = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    v48 = 2;
    strcpy(__s, "=\"");
    v12 = std::string::append(&v50, __s, 2uLL);
    v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v51.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v51.__r_.__value_.__l.__data_ = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    v14 = *(char *)(a2 + 23);
    if (v14 >= 0)
      v15 = (const std::string::value_type *)a2;
    else
      v15 = *(const std::string::value_type **)a2;
    if (v14 >= 0)
      v16 = *(unsigned __int8 *)(a2 + 23);
    else
      v16 = *(_QWORD *)(a2 + 8);
    v17 = std::string::append(&v51, v15, v16);
    v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
    v52.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v18;
    v17->__r_.__value_.__l.__size_ = 0;
    v17->__r_.__value_.__r.__words[2] = 0;
    v17->__r_.__value_.__r.__words[0] = 0;
    v46 = 1;
    strcpy(v45, "\"");
    v19 = std::string::append(&v52, v45, 1uLL);
    v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
    v53.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v20;
    v19->__r_.__value_.__l.__size_ = 0;
    v19->__r_.__value_.__r.__words[2] = 0;
    v19->__r_.__value_.__r.__words[0] = 0;
    v44 = 5;
    strcpy(v43, " AND ");
    v21 = std::string::append(&v53, v43, 5uLL);
    v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
    v54.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v54.__r_.__value_.__l.__data_ = v22;
    v21->__r_.__value_.__l.__size_ = 0;
    v21->__r_.__value_.__r.__words[2] = 0;
    v21->__r_.__value_.__r.__words[0] = 0;
    v23 = std::string::append(&v54, "UserId");
    v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
    v55.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v55.__r_.__value_.__l.__data_ = v24;
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__words[2] = 0;
    v23->__r_.__value_.__r.__words[0] = 0;
    v42 = 2;
    strcpy(v41, "=\"");
    v25 = std::string::append(&v55, v41, 2uLL);
    v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
    v56.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v56.__r_.__value_.__l.__data_ = v26;
    v25->__r_.__value_.__l.__size_ = 0;
    v25->__r_.__value_.__r.__words[2] = 0;
    v25->__r_.__value_.__r.__words[0] = 0;
    v27 = *(char *)(a3 + 23);
    if (v27 >= 0)
      v28 = (const std::string::value_type *)a3;
    else
      v28 = *(const std::string::value_type **)a3;
    if (v27 >= 0)
      v29 = *(unsigned __int8 *)(a3 + 23);
    else
      v29 = *(_QWORD *)(a3 + 8);
    v30 = std::string::append(&v56, v28, v29);
    v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
    v57.__r_.__value_.__r.__words[2] = v30->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v57.__r_.__value_.__l.__data_ = v31;
    v30->__r_.__value_.__l.__size_ = 0;
    v30->__r_.__value_.__r.__words[2] = 0;
    v30->__r_.__value_.__r.__words[0] = 0;
    v40 = 1;
    strcpy(v39, "\"");
    v32 = std::string::append(&v57, v39, 1uLL);
    v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
    v59 = v32->__r_.__value_.__r.__words[2];
    *(_OWORD *)__p = v33;
    v32->__r_.__value_.__l.__size_ = 0;
    v32->__r_.__value_.__r.__words[2] = 0;
    v32->__r_.__value_.__r.__words[0] = 0;
    if (v40 < 0)
      operator delete(*(void **)v39);
    if (SHIBYTE(v57.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v57.__r_.__value_.__l.__data_);
    if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v56.__r_.__value_.__l.__data_);
    if (v42 < 0)
      operator delete(*(void **)v41);
    if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v55.__r_.__value_.__l.__data_);
    if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v54.__r_.__value_.__l.__data_);
    if (v44 < 0)
      operator delete(*(void **)v43);
    if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v53.__r_.__value_.__l.__data_);
    if (v46 < 0)
      operator delete(*(void **)v45);
    if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v52.__r_.__value_.__l.__data_);
    if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v51.__r_.__value_.__l.__data_);
    if (v48 < 0)
      operator delete(*(void **)__s);
    if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v50.__r_.__value_.__l.__data_);
    if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v49.__r_.__value_.__l.__data_);
    sub_10034FBA8(*(_QWORD *)a1, (uint64_t)__p, a4);
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130B38);
  v34 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a2 + 23) >= 0)
      v35 = (const std::string::value_type *)a2;
    else
      v35 = *(const std::string::value_type **)a2;
    LODWORD(__p[0]) = 136315138;
    *(void **)((char *)__p + 4) = (void *)v35;
    _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#Warning Table is not valid so we can't get the services for client ID %s", (uint8_t *)__p, 0xCu);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130B38);
    if (*(char *)(a2 + 23) >= 0)
      v36 = a2;
    else
      v36 = *(_QWORD *)a2;
    LODWORD(v57.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v57.__r_.__value_.__r.__words + 4) = v36;
    _os_log_send_and_compose_impl(2, 0, __p, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#Warning Table is not valid so we can't get the services for client ID %s", (const char *)&v57);
    v38 = (void **)v37;
    sub_100512490("Generic", 1, 0, 2, "std::vector<CLMiLoServiceTable::Entry> CLMiLoServiceTable::getAllServicesForClientAndUserId(const std::string &, const std::string &, uint32_t)", "%s\n", v37);
    if (v38 != __p)
      free(v38);
  }
  *a5 = 0;
  a5[1] = 0;
  a5[2] = 0;
}

void sub_100350FE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100351128()
{
  JUMPOUT(0x100351110);
}

void sub_100351130(uint64_t a1@<X0>, unsigned int a2@<W1>, unsigned int a3@<W2>, _QWORD *a4@<X8>)
{
  std::string *v8;
  __int128 v9;
  std::string *v10;
  __int128 v11;
  std::string *v12;
  std::string::size_type size;
  std::string *v14;
  __int128 v15;
  NSObject *v16;
  std::string *v17;
  uint64_t v18;
  std::string *v19;
  std::string *v20;
  std::string *v21;
  std::string v22;
  std::string::value_type __s[8];
  char v24;
  std::string v25;
  std::string v26;
  std::string v27;
  std::string __p[68];

  if (*(_BYTE *)(a1 + 8))
  {
    *((_BYTE *)&v25.__r_.__value_.__s + 23) = 6;
    strcpy((char *)&v25, "WHERE ");
    v8 = std::string::append(&v25, "ServiceType");
    v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v26.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v26.__r_.__value_.__l.__data_ = v9;
    v8->__r_.__value_.__l.__size_ = 0;
    v8->__r_.__value_.__r.__words[2] = 0;
    v8->__r_.__value_.__r.__words[0] = 0;
    v24 = 2;
    strcpy(__s, "= ");
    v10 = std::string::append(&v26, __s, 2uLL);
    v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    v27.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v27.__r_.__value_.__l.__data_ = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v22, a2);
    if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v12 = &v22;
    else
      v12 = (std::string *)v22.__r_.__value_.__r.__words[0];
    if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(v22.__r_.__value_.__r.__words[2]);
    else
      size = v22.__r_.__value_.__l.__size_;
    v14 = std::string::append(&v27, (const std::string::value_type *)v12, size);
    v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    __p[0].__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__p[0].__r_.__value_.__l.__data_ = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v22.__r_.__value_.__l.__data_);
    if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v27.__r_.__value_.__l.__data_);
    if (v24 < 0)
      operator delete(*(void **)__s);
    if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v26.__r_.__value_.__l.__data_);
    if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v25.__r_.__value_.__l.__data_);
    sub_10034FBA8(*(_QWORD *)a1, (uint64_t)__p, a3);
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130B38);
  v16 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    std::to_string(__p, a2);
    v17 = (__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? __p
        : (std::string *)__p[0].__r_.__value_.__r.__words[0];
    LODWORD(v27.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v27.__r_.__value_.__r.__words + 4) = (std::string::size_type)v17;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#Warning Table is not valid so we can't get the services for service Type %s", (uint8_t *)&v27, 0xCu);
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p[0].__r_.__value_.__l.__data_);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130B38);
    v18 = qword_1022A00F8;
    std::to_string(&v27, a2);
    if ((v27.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v19 = &v27;
    else
      v19 = (std::string *)v27.__r_.__value_.__r.__words[0];
    LODWORD(v26.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v26.__r_.__value_.__r.__words + 4) = (std::string::size_type)v19;
    _os_log_send_and_compose_impl(2, 0, __p, 1628, &_mh_execute_header, v18, 0, "#Warning Table is not valid so we can't get the services for service Type %s", (const char *)&v26);
    v21 = v20;
    if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v27.__r_.__value_.__l.__data_);
    sub_100512490("Generic", 1, 0, 2, "std::vector<CLMiLoServiceTable::Entry> CLMiLoServiceTable::getAllServicesForServiceType(uint32_t, uint32_t)", "%s\n", (const char *)v21);
    if (v21 != __p)
      free(v21);
  }
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
}

void sub_1003514A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,void *__p,uint64_t a45,int a46,__int16 a47,char a48,char a49)
{
  _Unwind_Resume(exception_object);
}

void sub_100351534(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _BYTE *a4@<X8>)
{
  std::string *v6;
  __int128 v7;
  std::string *v8;
  __int128 v9;
  std::string *p_p;
  std::string::size_type size;
  std::string *v12;
  __int128 v13;
  std::string *v14;
  __int128 v15;
  NSObject *v16;
  std::string *v17;
  std::string *v18;
  const char *v19;
  char *v20;
  std::string v21;
  std::string v22;
  std::string v23;
  std::string __p;
  std::string v25;
  __int128 buf;
  _UNKNOWN **v27;
  _QWORD v28[2];

  v28[0] = a2;
  v28[1] = a3;
  memset(&__p, 0, sizeof(__p));
  if ((sub_10026A098((uint64_t)v28, &__p) & 1) == 0)
  {
    std::bad_cast::bad_cast((std::bad_cast *)&buf);
    *(_QWORD *)&buf = &off_10212A508;
    sub_10026A9C8((uint64_t)&buf);
  }
  if (*(_BYTE *)(a1 + 8))
  {
    *((_BYTE *)&v21.__r_.__value_.__s + 23) = 6;
    strcpy((char *)&v21, "WHERE ");
    v6 = std::string::append(&v21, "ServiceUUID");
    v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v22.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v22.__r_.__value_.__l.__data_ = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    v8 = std::string::append(&v22, "= \"");
    v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v23.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v23.__r_.__value_.__l.__data_ = v9;
    v8->__r_.__value_.__l.__size_ = 0;
    v8->__r_.__value_.__r.__words[2] = 0;
    v8->__r_.__value_.__r.__words[0] = 0;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_p = &__p;
    else
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    else
      size = __p.__r_.__value_.__l.__size_;
    v12 = std::string::append(&v23, (const std::string::value_type *)p_p, size);
    v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v25.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v25.__r_.__value_.__l.__data_ = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    v14 = std::string::append(&v25, "\"");
    v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    v27 = (_UNKNOWN **)v14->__r_.__value_.__r.__words[2];
    buf = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v25.__r_.__value_.__l.__data_);
    if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v23.__r_.__value_.__l.__data_);
    if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v22.__r_.__value_.__l.__data_);
    if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v21.__r_.__value_.__l.__data_);
    sub_10034FBA8(*(_QWORD *)a1, (uint64_t)&buf, 1u);
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130B38);
  v16 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    v17 = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v17 = (std::string *)__p.__r_.__value_.__r.__words[0];
    LODWORD(buf) = 136315138;
    *(_QWORD *)((char *)&buf + 4) = v17;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#Warning Table is not valid so we can't get the services for UUID %s", (uint8_t *)&buf, 0xCu);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(&buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130B38);
    v18 = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v18 = (std::string *)__p.__r_.__value_.__r.__words[0];
    LODWORD(v25.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v25.__r_.__value_.__r.__words + 4) = (std::string::size_type)v18;
    _os_log_send_and_compose_impl(2, 0, &buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#Warning Table is not valid so we can't get the services for UUID %s", (const char *)&v25);
    v20 = (char *)v19;
    sub_100512490("Generic", 1, 0, 2, "std::optional<CLMiLoServiceTable::Entry> CLMiLoServiceTable::getServiceByUuid(boost::uuids::uuid)", "%s\n", v19);
    if (v20 != (char *)&buf)
      free(v20);
  }
  *a4 = 0;
  a4[88] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_1003518EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,std::bad_cast a44,uint64_t a45,int a46,__int16 a47,char a48,char a49)
{
  if (a36 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003519AC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  std::string *v4;
  __int128 v5;
  std::string *v6;
  __int128 v7;
  std::string *v8;
  __int128 v9;
  std::string *v10;
  __int128 v11;
  std::string *v12;
  __int128 v13;
  std::string *p_p;
  std::string::size_type size;
  std::string *v16;
  __int128 v17;
  std::string *v18;
  __int128 v19;
  char *v20;
  NSObject *v21;
  const char *v23;
  std::string::value_type *v24;
  std::string __p;
  std::string::value_type v26[8];
  char v27;
  std::string::value_type __s[8];
  char v29;
  std::string v30;
  std::string v31;
  std::string v32;
  std::string v33;
  std::string v34;
  std::string v35;
  std::string v36;
  void *v37[2];
  int64_t v38;
  std::string::value_type v39[8];
  _UNKNOWN **v40;
  _UNKNOWN **v41;
  _QWORD v42[2];

  v42[0] = a2;
  v42[1] = a3;
  if (*(_BYTE *)(a1 + 8))
  {
    *((_BYTE *)&v30.__r_.__value_.__s + 23) = 12;
    strcpy((char *)&v30, "DELETE FROM ");
    v4 = std::string::append(&v30, "MiLoServices");
    v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v5;
    v4->__r_.__value_.__l.__size_ = 0;
    v4->__r_.__value_.__r.__words[2] = 0;
    v4->__r_.__value_.__r.__words[0] = 0;
    v6 = std::string::append(&v31, " WHERE ");
    v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    v8 = std::string::append(&v32, "ServiceUUID");
    v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v33.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v33.__r_.__value_.__l.__data_ = v9;
    v8->__r_.__value_.__l.__size_ = 0;
    v8->__r_.__value_.__r.__words[2] = 0;
    v8->__r_.__value_.__r.__words[0] = 0;
    v29 = 4;
    strcpy(__s, " IN ");
    v10 = std::string::append(&v33, __s, 4uLL);
    v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    v34.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v34.__r_.__value_.__l.__data_ = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    v27 = 2;
    strcpy(v26, "(\"");
    v12 = std::string::append(&v34, v26, 2uLL);
    v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v35.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v35.__r_.__value_.__l.__data_ = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    memset(&__p, 0, sizeof(__p));
    if ((sub_10026A098((uint64_t)v42, &__p) & 1) != 0)
    {
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        p_p = &__p;
      else
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      else
        size = __p.__r_.__value_.__l.__size_;
      v16 = std::string::append(&v35, (const std::string::value_type *)p_p, size);
      v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
      v36.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v36.__r_.__value_.__l.__data_ = v17;
      v16->__r_.__value_.__l.__size_ = 0;
      v16->__r_.__value_.__r.__words[2] = 0;
      v16->__r_.__value_.__r.__words[0] = 0;
      HIBYTE(v41) = 2;
      strcpy(v39, "\")");
      v18 = std::string::append(&v36, v39, 2uLL);
      v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
      v38 = v18->__r_.__value_.__r.__words[2];
      *(_OWORD *)v37 = v19;
      v18->__r_.__value_.__l.__size_ = 0;
      v18->__r_.__value_.__r.__words[2] = 0;
      v18->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v41) < 0)
        operator delete(*(void **)v39);
      if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v36.__r_.__value_.__l.__data_);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v35.__r_.__value_.__l.__data_);
      if (v27 < 0)
        operator delete(*(void **)v26);
      if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v34.__r_.__value_.__l.__data_);
      if (v29 < 0)
        operator delete(*(void **)__s);
      if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v33.__r_.__value_.__l.__data_);
      if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v32.__r_.__value_.__l.__data_);
      if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v31.__r_.__value_.__l.__data_);
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v30.__r_.__value_.__l.__data_);
      if (v38 >= 0)
        v20 = (char *)v37;
      else
        v20 = (char *)v37[0];
      sub_1000CDA68(*(_QWORD *)a1, v20);
    }
    std::bad_cast::bad_cast((std::bad_cast *)v39);
    *(_QWORD *)v39 = &off_10212A508;
    sub_10026A9C8((uint64_t)v39);
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130B38);
  v21 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v39 = 0;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#Warning Table is not valid so we can't Service", (uint8_t *)v39, 2u);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(v39, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130B38);
    LOWORD(v37[0]) = 0;
    _os_log_send_and_compose_impl(2, 0, v39, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#Warning Table is not valid so we can't Service", v37, 2);
    v24 = (std::string::value_type *)v23;
    sub_100512490("Generic", 1, 0, 2, "BOOL CLMiLoServiceTable::deleteServiceForUuid(boost::uuids::uuid)", "%s\n", v23);
    if (v24 != v39)
      free(v24);
  }
  return 0;
}

void sub_100351F88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,uint64_t a45,uint64_t a46,void *__p,uint64_t a48,int a49,__int16 a50,char a51,char a52)
{
  uint64_t v52;

  if (v52)
    (*(void (**)(uint64_t))(*(_QWORD *)v52 + 8))(v52);
  if (a52 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t sub_1003520C4(uint64_t a1, uint64_t *a2)
{
  std::string *v4;
  __int128 v5;
  std::string *v6;
  __int128 v7;
  std::string *v8;
  __int128 v9;
  std::string *v10;
  __int128 v11;
  std::string *v12;
  std::string::size_type size;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  std::string *v17;
  __int128 v18;
  std::string *v19;
  std::string::size_type v20;
  unint64_t v21;
  std::string *v23;
  NSObject *v24;
  const char *v26;
  std::string *v27;
  std::string::value_type v28[8];
  char v29;
  std::string::value_type __s[23];
  char v31;
  std::string v32;
  std::string v33;
  std::string v34;
  std::string v35;
  std::string v36;

  if (*(_BYTE *)(a1 + 8))
  {
    *((_BYTE *)&v36.__r_.__value_.__s + 23) = 12;
    strcpy((char *)&v36, "DELETE FROM ");
    v4 = std::string::append(&v36, "MiLoServices");
    v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
    v35.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v35.__r_.__value_.__l.__data_ = v5;
    v4->__r_.__value_.__l.__size_ = 0;
    v4->__r_.__value_.__r.__words[2] = 0;
    v4->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v36.__r_.__value_.__l.__data_);
    if (a2[1] != *a2)
    {
      *((_BYTE *)&v32.__r_.__value_.__s + 23) = 7;
      strcpy((char *)&v32, " WHERE ");
      v6 = std::string::append(&v32, "ClientID");
      v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
      v33.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v33.__r_.__value_.__l.__data_ = v7;
      v6->__r_.__value_.__l.__size_ = 0;
      v6->__r_.__value_.__r.__words[2] = 0;
      v6->__r_.__value_.__r.__words[0] = 0;
      v31 = 8;
      strcpy(__s, " NOT IN ");
      v8 = std::string::append(&v33, __s, 8uLL);
      v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
      v34.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v34.__r_.__value_.__l.__data_ = v9;
      v8->__r_.__value_.__l.__size_ = 0;
      v8->__r_.__value_.__r.__words[2] = 0;
      v8->__r_.__value_.__r.__words[0] = 0;
      v29 = 1;
      strcpy(v28, "(");
      v10 = std::string::append(&v34, v28, 1uLL);
      v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
      v36.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v36.__r_.__value_.__l.__data_ = v11;
      v10->__r_.__value_.__l.__size_ = 0;
      v10->__r_.__value_.__r.__words[2] = 0;
      v10->__r_.__value_.__r.__words[0] = 0;
      if ((v36.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v12 = &v36;
      else
        v12 = (std::string *)v36.__r_.__value_.__r.__words[0];
      if ((v36.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        size = HIBYTE(v36.__r_.__value_.__r.__words[2]);
      else
        size = v36.__r_.__value_.__l.__size_;
      std::string::append(&v35, (const std::string::value_type *)v12, size);
      if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v36.__r_.__value_.__l.__data_);
      if (v29 < 0)
        operator delete(*(void **)v28);
      if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v34.__r_.__value_.__l.__data_);
      if (v31 < 0)
        operator delete(*(void **)__s);
      if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v33.__r_.__value_.__l.__data_);
      if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v32.__r_.__value_.__l.__data_);
      v14 = *a2;
      if (a2[1] != *a2)
      {
        v15 = 0;
        v16 = 1;
        do
        {
          std::operator+<char>(&v34, "\"", v14 + 24 * v15);
          v17 = std::string::append(&v34, "\"");
          v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
          v36.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v36.__r_.__value_.__l.__data_ = v18;
          v17->__r_.__value_.__l.__size_ = 0;
          v17->__r_.__value_.__r.__words[2] = 0;
          v17->__r_.__value_.__r.__words[0] = 0;
          if ((v36.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v19 = &v36;
          else
            v19 = (std::string *)v36.__r_.__value_.__r.__words[0];
          if ((v36.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v20 = HIBYTE(v36.__r_.__value_.__r.__words[2]);
          else
            v20 = v36.__r_.__value_.__l.__size_;
          std::string::append(&v35, (const std::string::value_type *)v19, v20);
          if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v36.__r_.__value_.__l.__data_);
          if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v34.__r_.__value_.__l.__data_);
          v14 = *a2;
          v21 = 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3);
          if (v21 - 1 != v15)
          {
            std::string::append(&v35, ", ");
            v14 = *a2;
            v21 = 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3);
          }
          v15 = v16;
        }
        while (v21 > v16++);
      }
      std::string::append(&v35, ")");
    }
    if ((v35.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v23 = &v35;
    else
      v23 = (std::string *)v35.__r_.__value_.__r.__words[0];
    sub_1000CDA68(*(_QWORD *)a1, (char *)v23);
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130B38);
  v24 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v36.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#Warning Table is not valid so all services will not be deleted", (uint8_t *)&v36, 2u);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(&v36, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130B38);
    LOWORD(v35.__r_.__value_.__l.__data_) = 0;
    _os_log_send_and_compose_impl(2, 0, &v36, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#Warning Table is not valid so all services will not be deleted", &v35, 2);
    v27 = (std::string *)v26;
    sub_100512490("Generic", 1, 0, 2, "BOOL CLMiLoServiceTable::deleteAllServices(const std::vector<std::string> &)", "%s\n", v26);
    if (v27 != &v36)
      free(v27);
  }
  return 0;
}

void sub_1003526DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,void *__p,uint64_t a45,int a46,__int16 a47,char a48,char a49,uint64_t a50,void *a51,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  uint64_t v56;

  if (v56)
    (*(void (**)(uint64_t))(*(_QWORD *)v56 + 8))(v56);
  if (a49 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003527EC(uint64_t a1)
{
  NSObject *v1;
  const char *v3;
  uint8_t *v4;
  void *__p[2];
  __int128 v6;
  uint8_t buf[18];

  if (*(_BYTE *)(a1 + 8))
    sub_100354894((uint64_t *)a1, &v6);
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130B38);
  v1 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#Warning Table is not valid so service maintenance will not run and nothing will be deleted", buf, 2u);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130B38);
    LOWORD(__p[0]) = 0;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#Warning Table is not valid so service maintenance will not run and nothing will be deleted", __p, 2);
    v4 = (uint8_t *)v3;
    sub_100512490("Generic", 1, 0, 2, "BOOL CLMiLoServiceTable::deleteOldestsServicesPerClientAboveMaxCount()", "%s\n", v3);
    if (v4 != buf)
      free(v4);
  }
  return 0;
}

void sub_1003542A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  if (SLOBYTE(STACK[0x4B7]) < 0)
    operator delete((void *)STACK[0x4A0]);
  sub_1002FDAA0((uint64_t)&STACK[0x340]);
  STACK[0x4C0] = (unint64_t)&STACK[0x430];
  sub_100356ECC((void ***)&STACK[0x4C0]);
  if (SLOBYTE(STACK[0x45F]) < 0)
    operator delete((void *)STACK[0x448]);
  STACK[0x4C0] = (unint64_t)&STACK[0x460];
  sub_100356DFC((void ***)&STACK[0x4C0]);
  _Unwind_Resume(a1);
}

void sub_100354894(uint64_t *a1@<X0>, _QWORD *a2@<X8>)
{
  std::string *v3;
  __int128 v4;
  std::string *v5;
  __int128 v6;
  std::string *v7;
  __int128 v8;
  std::string *v9;
  __int128 v10;
  char *v11;
  std::string *v12;
  __int128 v13;
  std::string *v14;
  __int128 v15;
  std::string *v16;
  __int128 v17;
  std::string *v18;
  __int128 v19;
  std::string *v20;
  __int128 v21;
  std::string *v22;
  __int128 v23;
  char *p_p;
  std::string::value_type v25[8];
  char v26;
  std::string::value_type __s[23];
  char v28;
  std::string v29;
  std::string v30;
  std::string v31;
  std::string v32;
  std::string v33;
  std::string v34;
  std::string v35;
  std::string v36;
  __int128 __p;
  int64_t v38;
  std::string __dst;
  std::string v40;

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  *((_BYTE *)&v29.__r_.__value_.__s + 23) = 7;
  strcpy((char *)&v29, "SELECT ");
  v3 = std::string::append(&v29, "ClientID");
  v4 = *(_OWORD *)&v3->__r_.__value_.__l.__data_;
  v30.__r_.__value_.__r.__words[2] = v3->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v4;
  v3->__r_.__value_.__l.__size_ = 0;
  v3->__r_.__value_.__r.__words[2] = 0;
  v3->__r_.__value_.__r.__words[0] = 0;
  v5 = std::string::append(&v30, ", ");
  v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
  v31.__r_.__value_.__r.__words[2] = v5->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v6;
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  v7 = std::string::append(&v31, "ServiceType");
  v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
  v32.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v32.__r_.__value_.__l.__data_ = v8;
  v7->__r_.__value_.__l.__size_ = 0;
  v7->__r_.__value_.__r.__words[2] = 0;
  v7->__r_.__value_.__r.__words[0] = 0;
  v9 = std::string::append(&v32, ", ");
  v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
  v33.__r_.__value_.__r.__words[2] = v9->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v33.__r_.__value_.__l.__data_ = v10;
  v9->__r_.__value_.__l.__size_ = 0;
  v9->__r_.__value_.__r.__words[2] = 0;
  v9->__r_.__value_.__r.__words[0] = 0;
  v11 = (char *)operator new(0x20uLL);
  strcpy(v11, "COUNT(*) as RowCount FROM ");
  v12 = std::string::append(&v33, v11, 0x1AuLL);
  v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  v34.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v34.__r_.__value_.__l.__data_ = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  v14 = std::string::append(&v34, "MiLoServices");
  v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v35.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v35.__r_.__value_.__l.__data_ = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  v28 = 10;
  strcpy(__s, " GROUP BY ");
  v16 = std::string::append(&v35, __s, 0xAuLL);
  v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  v36.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v36.__r_.__value_.__l.__data_ = v17;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  v18 = std::string::append(&v36, "ClientID");
  v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
  v40.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v40.__r_.__value_.__l.__data_ = v19;
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  v26 = 2;
  strcpy(v25, ", ");
  v20 = std::string::append(&v40, v25, 2uLL);
  v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
  __dst.__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v21;
  v20->__r_.__value_.__l.__size_ = 0;
  v20->__r_.__value_.__r.__words[2] = 0;
  v20->__r_.__value_.__r.__words[0] = 0;
  v22 = std::string::append(&__dst, "ServiceType");
  v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
  v38 = v22->__r_.__value_.__r.__words[2];
  __p = v23;
  v22->__r_.__value_.__l.__size_ = 0;
  v22->__r_.__value_.__r.__words[2] = 0;
  v22->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__dst.__r_.__value_.__l.__data_);
  if (v26 < 0)
    operator delete(*(void **)v25);
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v40.__r_.__value_.__l.__data_);
  if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v36.__r_.__value_.__l.__data_);
  if (v28 < 0)
    operator delete(*(void **)__s);
  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v35.__r_.__value_.__l.__data_);
  if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v34.__r_.__value_.__l.__data_);
  operator delete(v11);
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v33.__r_.__value_.__l.__data_);
  if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v32.__r_.__value_.__l.__data_);
  if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v31.__r_.__value_.__l.__data_);
  if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v30.__r_.__value_.__l.__data_);
  if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v29.__r_.__value_.__l.__data_);
  if (v38 >= 0)
    p_p = (char *)&__p;
  else
    p_p = (char *)__p;
  sub_1000CDA68(*a1, p_p);
}

void sub_100354D14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,uint64_t a47,uint64_t a48,void *__p,uint64_t a50,int a51,__int16 a52,char a53,char a54,uint64_t a55,uint64_t buf)
{
  if (a54 < 0)
    operator delete(__p);
  sub_100356DFC((void ***)&buf);
  _Unwind_Resume(a1);
}

char *sub_100355074(char *__dst, __int128 *a2, __int128 *a3)
{
  __int128 v5;
  _BYTE *v6;
  __int128 v7;

  if (*((char *)a2 + 23) < 0)
  {
    sub_100115CE4(__dst, *(void **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v5 = *a2;
    *((_QWORD *)__dst + 2) = *((_QWORD *)a2 + 2);
    *(_OWORD *)__dst = v5;
  }
  v6 = __dst + 24;
  if (*((char *)a3 + 23) < 0)
  {
    sub_100115CE4(v6, *(void **)a3, *((_QWORD *)a3 + 1));
  }
  else
  {
    v7 = *a3;
    *((_QWORD *)__dst + 5) = *((_QWORD *)a3 + 2);
    *(_OWORD *)v6 = v7;
  }
  return __dst;
}

void sub_1003550EC(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void sub_100355108()
{
  NSObject *v0;
  NSObject *v1;
  NSObject *v2;
  uint8_t buf[4];
  int v4;
  __int16 v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  const char *v10;

  if (qword_1022A00F0 != -1)
    goto LABEL_11;
  while (1)
  {
    v0 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      v4 = 0;
      v5 = 2082;
      v6 = "";
      v7 = 2082;
      v8 = "assert";
      v9 = 2081;
      v10 = "false";
      _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Delete Olders rows in service table. Should never be here!\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130B38);
    }
    v1 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      *(_DWORD *)buf = 68289539;
      v4 = 0;
      v5 = 2082;
      v6 = "";
      v7 = 2082;
      v8 = "assert";
      v9 = 2081;
      v10 = "false";
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v1, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Delete Olders rows in service table. Should never be here!", "{\"msg%{public}.0s\":\"Delete Olders rows in service table. Should never be here!\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130B38);
    }
    v2 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      v4 = 0;
      v5 = 2082;
      v6 = "";
      v7 = 2082;
      v8 = "assert";
      v9 = 2081;
      v10 = "false";
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Delete Olders rows in service table. Should never be here!\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    abort_report_np("%s:%d: assertion failure in %s", "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/ServiceManager/CLMiLoServiceTable.mm", 349, "deleteOldestRows");
LABEL_11:
    dispatch_once(&qword_1022A00F0, &stru_102130B38);
  }
}

uint64_t sub_100355328(uint64_t a1, uint64_t a2, uint64_t a3, double a4)
{
  std::string *v6;
  __int128 v7;
  std::string *v8;
  __int128 v9;
  std::string *v10;
  std::string::size_type size;
  std::string *v12;
  __int128 v13;
  std::string *v14;
  __int128 v15;
  std::string *v16;
  __int128 v17;
  std::string *v18;
  __int128 v19;
  std::string *v20;
  __int128 v21;
  std::string *v22;
  __int128 v23;
  std::string *v24;
  std::string::size_type v25;
  std::string *v26;
  __int128 v27;
  void **v28;
  std::string::size_type v29;
  std::string *v30;
  __int128 v31;
  std::string *v32;
  NSObject *v33;
  const char *v35;
  std::string *v36;
  std::string v37;
  std::string v38;
  std::string v39;
  std::string v40;
  std::string v41;
  std::string v42;
  std::string v43;
  void *__p[2];
  int64_t v45;
  std::string v46;
  std::string v47;
  _QWORD v48[2];

  v48[0] = a2;
  v48[1] = a3;
  if (*(_BYTE *)(a1 + 8))
  {
    memset(&v46, 0, sizeof(v46));
    if ((sub_10026A098((uint64_t)v48, &v46) & 1) != 0)
    {
      *((_BYTE *)&v41.__r_.__value_.__s + 23) = 7;
      strcpy((char *)&v41, " WHERE ");
      v6 = std::string::append(&v41, "ServiceUUID");
      v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
      v42.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v7;
      v6->__r_.__value_.__l.__size_ = 0;
      v6->__r_.__value_.__r.__words[2] = 0;
      v6->__r_.__value_.__r.__words[0] = 0;
      v8 = std::string::append(&v42, "= \"");
      v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
      v43.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v9;
      v8->__r_.__value_.__l.__size_ = 0;
      v8->__r_.__value_.__r.__words[2] = 0;
      v8->__r_.__value_.__r.__words[0] = 0;
      if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v10 = &v46;
      else
        v10 = (std::string *)v46.__r_.__value_.__r.__words[0];
      if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        size = HIBYTE(v46.__r_.__value_.__r.__words[2]);
      else
        size = v46.__r_.__value_.__l.__size_;
      v12 = std::string::append(&v43, (const std::string::value_type *)v10, size);
      v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
      v47.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v47.__r_.__value_.__l.__data_ = v13;
      v12->__r_.__value_.__l.__size_ = 0;
      v12->__r_.__value_.__r.__words[2] = 0;
      v12->__r_.__value_.__r.__words[0] = 0;
      v14 = std::string::append(&v47, "\"");
      v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
      v45 = v14->__r_.__value_.__r.__words[2];
      *(_OWORD *)__p = v15;
      v14->__r_.__value_.__l.__size_ = 0;
      v14->__r_.__value_.__r.__words[2] = 0;
      v14->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v47.__r_.__value_.__l.__data_);
      if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v43.__r_.__value_.__l.__data_);
      if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v42.__r_.__value_.__l.__data_);
      if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v41.__r_.__value_.__l.__data_);
      *((_BYTE *)&v38.__r_.__value_.__s + 23) = 7;
      strcpy((char *)&v38, "UPDATE ");
      v16 = std::string::append(&v38, "MiLoServices");
      v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
      v39.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v39.__r_.__value_.__l.__data_ = v17;
      v16->__r_.__value_.__l.__size_ = 0;
      v16->__r_.__value_.__r.__words[2] = 0;
      v16->__r_.__value_.__r.__words[0] = 0;
      v18 = std::string::append(&v39, " SET ");
      v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
      v40.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v40.__r_.__value_.__l.__data_ = v19;
      v18->__r_.__value_.__l.__size_ = 0;
      v18->__r_.__value_.__r.__words[2] = 0;
      v18->__r_.__value_.__r.__words[0] = 0;
      v20 = std::string::append(&v40, "LastActiveTimestamp");
      v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
      v41.__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v41.__r_.__value_.__l.__data_ = v21;
      v20->__r_.__value_.__l.__size_ = 0;
      v20->__r_.__value_.__r.__words[2] = 0;
      v20->__r_.__value_.__r.__words[0] = 0;
      v22 = std::string::append(&v41, "=");
      v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
      v42.__r_.__value_.__r.__words[2] = v22->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v23;
      v22->__r_.__value_.__l.__size_ = 0;
      v22->__r_.__value_.__r.__words[2] = 0;
      v22->__r_.__value_.__r.__words[0] = 0;
      std::to_string(&v37, a4);
      if ((v37.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v24 = &v37;
      else
        v24 = (std::string *)v37.__r_.__value_.__r.__words[0];
      if ((v37.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v25 = HIBYTE(v37.__r_.__value_.__r.__words[2]);
      else
        v25 = v37.__r_.__value_.__l.__size_;
      v26 = std::string::append(&v42, (const std::string::value_type *)v24, v25);
      v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
      v47.__r_.__value_.__r.__words[2] = v26->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v47.__r_.__value_.__l.__data_ = v27;
      v26->__r_.__value_.__l.__size_ = 0;
      v26->__r_.__value_.__r.__words[2] = 0;
      v26->__r_.__value_.__r.__words[0] = 0;
      if (v45 >= 0)
        v28 = __p;
      else
        v28 = (void **)__p[0];
      if (v45 >= 0)
        v29 = HIBYTE(v45);
      else
        v29 = (std::string::size_type)__p[1];
      v30 = std::string::append(&v47, (const std::string::value_type *)v28, v29);
      v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
      v43.__r_.__value_.__r.__words[2] = v30->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v31;
      v30->__r_.__value_.__l.__size_ = 0;
      v30->__r_.__value_.__r.__words[2] = 0;
      v30->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v47.__r_.__value_.__l.__data_);
      if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v37.__r_.__value_.__l.__data_);
      if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v42.__r_.__value_.__l.__data_);
      if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v41.__r_.__value_.__l.__data_);
      if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v40.__r_.__value_.__l.__data_);
      if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v39.__r_.__value_.__l.__data_);
      if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v38.__r_.__value_.__l.__data_);
      if ((v43.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v32 = &v43;
      else
        v32 = (std::string *)v43.__r_.__value_.__r.__words[0];
      sub_1000CDA68(*(_QWORD *)a1, (char *)v32);
    }
    std::bad_cast::bad_cast((std::bad_cast *)&v47);
    v47.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_10212A508;
    sub_10026A9C8((uint64_t)&v47);
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130B38);
  v33 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v47.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#Warning Table is not valid so we can't update service", (uint8_t *)&v47, 2u);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(&v47, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130B38);
    LOWORD(v46.__r_.__value_.__l.__data_) = 0;
    _os_log_send_and_compose_impl(2, 0, &v47, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#Warning Table is not valid so we can't update service", &v46, 2);
    v36 = (std::string *)v35;
    sub_100512490("Generic", 1, 0, 2, "BOOL CLMiLoServiceTable::updateServiceLastActiveTime(boost::uuids::uuid, cl::chrono::CFAbsoluteTimeClock::time_point)", "%s\n", v35);
    if (v36 != &v47)
      free(v36);
  }
  return 0;
}

void sub_1003559BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52)
{
  uint64_t v52;

  if (v52)
    (*(void (**)(uint64_t))(*(_QWORD *)v52 + 8))(v52);
  if (a38 < 0)
    operator delete(__p);
  if (a45 < 0)
    operator delete(a40);
  if (a52 < 0)
    operator delete(a47);
  _Unwind_Resume(a1);
}

uint64_t sub_100355B38(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  std::string *v6;
  __int128 v7;
  std::string *v8;
  __int128 v9;
  std::string *v10;
  std::string::size_type size;
  std::string *v12;
  __int128 v13;
  std::string *v14;
  __int128 v15;
  std::string *v16;
  __int128 v17;
  std::string *v18;
  __int128 v19;
  std::string *v20;
  __int128 v21;
  std::string *v22;
  __int128 v23;
  std::string *v24;
  std::string::size_type v25;
  std::string *v26;
  __int128 v27;
  void **v28;
  std::string::size_type v29;
  std::string *v30;
  __int128 v31;
  std::string *v32;
  NSObject *v33;
  const char *v35;
  std::string *v36;
  std::string v37;
  std::string v38;
  std::string v39;
  std::string v40;
  std::string v41;
  std::string v42;
  std::string v43;
  void *__p[2];
  int64_t v45;
  std::string v46;
  std::string v47;
  _QWORD v48[2];

  v48[0] = a2;
  v48[1] = a3;
  if (*(_BYTE *)(a1 + 8))
  {
    memset(&v46, 0, sizeof(v46));
    if ((sub_10026A098((uint64_t)v48, &v46) & 1) != 0)
    {
      *((_BYTE *)&v41.__r_.__value_.__s + 23) = 7;
      strcpy((char *)&v41, " WHERE ");
      v6 = std::string::append(&v41, "ServiceUUID");
      v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
      v42.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v7;
      v6->__r_.__value_.__l.__size_ = 0;
      v6->__r_.__value_.__r.__words[2] = 0;
      v6->__r_.__value_.__r.__words[0] = 0;
      v8 = std::string::append(&v42, "= \"");
      v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
      v43.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v9;
      v8->__r_.__value_.__l.__size_ = 0;
      v8->__r_.__value_.__r.__words[2] = 0;
      v8->__r_.__value_.__r.__words[0] = 0;
      if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v10 = &v46;
      else
        v10 = (std::string *)v46.__r_.__value_.__r.__words[0];
      if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        size = HIBYTE(v46.__r_.__value_.__r.__words[2]);
      else
        size = v46.__r_.__value_.__l.__size_;
      v12 = std::string::append(&v43, (const std::string::value_type *)v10, size);
      v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
      v47.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v47.__r_.__value_.__l.__data_ = v13;
      v12->__r_.__value_.__l.__size_ = 0;
      v12->__r_.__value_.__r.__words[2] = 0;
      v12->__r_.__value_.__r.__words[0] = 0;
      v14 = std::string::append(&v47, "\"");
      v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
      v45 = v14->__r_.__value_.__r.__words[2];
      *(_OWORD *)__p = v15;
      v14->__r_.__value_.__l.__size_ = 0;
      v14->__r_.__value_.__r.__words[2] = 0;
      v14->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v47.__r_.__value_.__l.__data_);
      if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v43.__r_.__value_.__l.__data_);
      if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v42.__r_.__value_.__l.__data_);
      if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v41.__r_.__value_.__l.__data_);
      *((_BYTE *)&v38.__r_.__value_.__s + 23) = 7;
      strcpy((char *)&v38, "UPDATE ");
      v16 = std::string::append(&v38, "MiLoServices");
      v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
      v39.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v39.__r_.__value_.__l.__data_ = v17;
      v16->__r_.__value_.__l.__size_ = 0;
      v16->__r_.__value_.__r.__words[2] = 0;
      v16->__r_.__value_.__r.__words[0] = 0;
      v18 = std::string::append(&v39, " SET ");
      v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
      v40.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v40.__r_.__value_.__l.__data_ = v19;
      v18->__r_.__value_.__l.__size_ = 0;
      v18->__r_.__value_.__r.__words[2] = 0;
      v18->__r_.__value_.__r.__words[0] = 0;
      v20 = std::string::append(&v40, "LocationTypes");
      v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
      v41.__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v41.__r_.__value_.__l.__data_ = v21;
      v20->__r_.__value_.__l.__size_ = 0;
      v20->__r_.__value_.__r.__words[2] = 0;
      v20->__r_.__value_.__r.__words[0] = 0;
      v22 = std::string::append(&v41, "=");
      v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
      v42.__r_.__value_.__r.__words[2] = v22->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v23;
      v22->__r_.__value_.__l.__size_ = 0;
      v22->__r_.__value_.__r.__words[2] = 0;
      v22->__r_.__value_.__r.__words[0] = 0;
      std::to_string(&v37, a4);
      if ((v37.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v24 = &v37;
      else
        v24 = (std::string *)v37.__r_.__value_.__r.__words[0];
      if ((v37.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v25 = HIBYTE(v37.__r_.__value_.__r.__words[2]);
      else
        v25 = v37.__r_.__value_.__l.__size_;
      v26 = std::string::append(&v42, (const std::string::value_type *)v24, v25);
      v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
      v47.__r_.__value_.__r.__words[2] = v26->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v47.__r_.__value_.__l.__data_ = v27;
      v26->__r_.__value_.__l.__size_ = 0;
      v26->__r_.__value_.__r.__words[2] = 0;
      v26->__r_.__value_.__r.__words[0] = 0;
      if (v45 >= 0)
        v28 = __p;
      else
        v28 = (void **)__p[0];
      if (v45 >= 0)
        v29 = HIBYTE(v45);
      else
        v29 = (std::string::size_type)__p[1];
      v30 = std::string::append(&v47, (const std::string::value_type *)v28, v29);
      v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
      v43.__r_.__value_.__r.__words[2] = v30->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v31;
      v30->__r_.__value_.__l.__size_ = 0;
      v30->__r_.__value_.__r.__words[2] = 0;
      v30->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v47.__r_.__value_.__l.__data_);
      if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v37.__r_.__value_.__l.__data_);
      if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v42.__r_.__value_.__l.__data_);
      if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v41.__r_.__value_.__l.__data_);
      if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v40.__r_.__value_.__l.__data_);
      if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v39.__r_.__value_.__l.__data_);
      if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v38.__r_.__value_.__l.__data_);
      if ((v43.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v32 = &v43;
      else
        v32 = (std::string *)v43.__r_.__value_.__r.__words[0];
      sub_1000CDA68(*(_QWORD *)a1, (char *)v32);
    }
    std::bad_cast::bad_cast((std::bad_cast *)&v47);
    v47.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_10212A508;
    sub_10026A9C8((uint64_t)&v47);
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130B38);
  v33 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v47.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#Warning Table is not valid so we can't update service", (uint8_t *)&v47, 2u);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(&v47, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130B38);
    LOWORD(v46.__r_.__value_.__l.__data_) = 0;
    _os_log_send_and_compose_impl(2, 0, &v47, 1628, &_mh_execute_header, qword_1022A00F8, 0, "#Warning Table is not valid so we can't update service", &v46, 2);
    v36 = (std::string *)v35;
    sub_100512490("Generic", 1, 0, 2, "BOOL CLMiLoServiceTable::updateServiceLocationTypes(boost::uuids::uuid, uint64_t)", "%s\n", v35);
    if (v36 != &v47)
      free(v36);
  }
  return 0;
}

void sub_1003561C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52)
{
  uint64_t v52;

  if (v52)
    (*(void (**)(uint64_t))(*(_QWORD *)v52 + 8))(v52);
  if (a38 < 0)
    operator delete(__p);
  if (a45 < 0)
    operator delete(a40);
  if (a52 < 0)
    operator delete(a47);
  _Unwind_Resume(a1);
}

void sub_100356340(id a1)
{
  qword_1022A00F8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

uint64_t sub_10035636C(uint64_t *a1, uint64_t *a2, double *a3, unsigned int *a4, __int128 *a5, uint64_t *a6, __int128 *a7)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  char *v20;
  uint64_t v21;
  void *v23;
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t *v27;

  v8 = *a1;
  v9 = 0x2E8BA2E8BA2E8BA3 * ((a1[1] - *a1) >> 3);
  v10 = v9 + 1;
  if ((unint64_t)(v9 + 1) > 0x2E8BA2E8BA2E8BALL)
    sub_100259694();
  v17 = (uint64_t)(a1 + 2);
  v18 = 0x2E8BA2E8BA2E8BA3 * ((a1[2] - v8) >> 3);
  if (2 * v18 > v10)
    v10 = 2 * v18;
  if (v18 >= 0x1745D1745D1745DLL)
    v19 = 0x2E8BA2E8BA2E8BALL;
  else
    v19 = v10;
  v27 = a1 + 2;
  if (v19)
    v20 = (char *)sub_100279B30(v17, v19);
  else
    v20 = 0;
  v23 = v20;
  v24 = &v20[88 * v9];
  v25 = (uint64_t)v24;
  v26 = &v20[88 * v19];
  sub_10034FA9C((uint64_t)v24, *a2, a2[1], *a4, a5, *a6, a7, *a3);
  v25 = (uint64_t)(v24 + 88);
  sub_1003564C0(a1, &v23);
  v21 = a1[1];
  sub_10035668C(&v23);
  return v21;
}

void sub_1003564AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_10035668C((void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1003564C0(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = sub_100356534((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_100356534(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  _QWORD v14[3];
  char v15;
  __int128 v16;
  __int128 v17;

  v7 = a7;
  *(_QWORD *)&v17 = a6;
  *((_QWORD *)&v17 + 1) = a7;
  v16 = v17;
  v14[0] = a1;
  v14[1] = &v16;
  v14[2] = &v17;
  if (a3 == a5)
  {
    v12 = a6;
  }
  else
  {
    v8 = a7;
    do
    {
      v9 = *(_OWORD *)(a3 - 88);
      *(_OWORD *)(v8 - 72) = *(_OWORD *)(a3 - 72);
      *(_OWORD *)(v8 - 88) = v9;
      v10 = *(_OWORD *)(a3 - 56);
      *(_QWORD *)(v8 - 40) = *(_QWORD *)(a3 - 40);
      *(_OWORD *)(v8 - 56) = v10;
      *(_QWORD *)(a3 - 48) = 0;
      *(_QWORD *)(a3 - 40) = 0;
      *(_QWORD *)(a3 - 56) = 0;
      *(_QWORD *)(v8 - 32) = *(_QWORD *)(a3 - 32);
      v11 = *(_OWORD *)(a3 - 24);
      *(_QWORD *)(v8 - 8) = *(_QWORD *)(a3 - 8);
      *(_OWORD *)(v8 - 24) = v11;
      v8 -= 88;
      *(_QWORD *)(a3 - 16) = 0;
      *(_QWORD *)(a3 - 8) = 0;
      *(_QWORD *)(a3 - 24) = 0;
      v7 -= 88;
      a3 -= 88;
    }
    while (a3 != a5);
    *((_QWORD *)&v17 + 1) = v8;
    v12 = v17;
  }
  v15 = 1;
  sub_100356608((uint64_t)v14);
  return v12;
}

uint64_t sub_100356608(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    sub_10035663C((uint64_t *)a1);
  return a1;
}

void sub_10035663C(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(_QWORD *)(a1[2] + 8);
  v2 = *(_QWORD *)(a1[1] + 8);
  if (v1 != v2)
  {
    v3 = *a1;
    do
    {
      sub_100302AA0(v3, v1);
      v1 += 88;
    }
    while (v1 != v2);
  }
}

void **sub_10035668C(void **a1)
{
  sub_1003566BC(a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void sub_1003566BC(_QWORD *a1)
{
  uint64_t i;
  uint64_t v2;
  uint64_t v4;

  v2 = a1[1];
  for (i = a1[2]; i != v2; i = a1[2])
  {
    v4 = a1[4];
    a1[2] = i - 88;
    sub_100302AA0(v4, i - 88);
  }
}

uint64_t sub_100356700(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  __int128 v5;
  _BYTE *v6;
  __int128 v7;

  v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  if (*(char *)(a2 + 55) < 0)
  {
    sub_100115CE4((_BYTE *)(a1 + 32), *(void **)(a2 + 32), *(_QWORD *)(a2 + 40));
  }
  else
  {
    v5 = *(_OWORD *)(a2 + 32);
    *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = v5;
  }
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  v6 = (_BYTE *)(a1 + 64);
  if (*(char *)(a2 + 87) < 0)
  {
    sub_100115CE4(v6, *(void **)(a2 + 64), *(_QWORD *)(a2 + 72));
  }
  else
  {
    v7 = *(_OWORD *)(a2 + 64);
    *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
    *(_OWORD *)v6 = v7;
  }
  *(_BYTE *)(a1 + 88) = 1;
  return a1;
}

void sub_1003567A0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 55) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

double sub_1003567BC@<D0>(std::string *a1@<X8>)
{
  double result;
  std::string v3;

  memset(&v3, 0, sizeof(v3));
  sub_10035681C(&v3);
  result = *(double *)&v3.__r_.__value_.__l.__data_;
  *a1 = v3;
  return result;
}

void sub_100356800(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_10035681C(std::string *a1)
{
  sub_100356868(a1);
  sub_100356938(a1);
  sub_100356A14(a1);
  sub_100269BD4(a1);
  sub_100356AF0(a1);
  sub_100269E68(a1);
  return sub_100356BCC(a1);
}

uint64_t sub_100356868(std::string *a1)
{
  std::string *v2;
  __int128 v3;
  void **v4;
  std::string::size_type v5;
  std::string v7;
  void *__p[2];
  int64_t v9;

  *((_BYTE *)&v7.__r_.__value_.__s + 23) = 0;
  v7.__r_.__value_.__s.__data_[0] = 0;
  v2 = std::string::append(&v7, "ServiceUUID");
  v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0)
    v4 = __p;
  else
    v4 = (void **)__p[0];
  if (v9 >= 0)
    v5 = HIBYTE(v9);
  else
    v5 = (std::string::size_type)__p[1];
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v7.__r_.__value_.__l.__data_);
  return 0;
}

void sub_100356904(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

uint64_t sub_100356938(std::string *a1)
{
  std::string *v2;
  __int128 v3;
  void **v4;
  std::string::size_type v5;
  std::string v7;
  void *__p[2];
  int64_t v9;

  *((_BYTE *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  v2 = std::string::append(&v7, "LastActiveTimestamp");
  v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0)
    v4 = __p;
  else
    v4 = (void **)__p[0];
  if (v9 >= 0)
    v5 = HIBYTE(v9);
  else
    v5 = (std::string::size_type)__p[1];
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v7.__r_.__value_.__l.__data_);
  return 0;
}

void sub_1003569E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

uint64_t sub_100356A14(std::string *a1)
{
  std::string *v2;
  __int128 v3;
  void **v4;
  std::string::size_type v5;
  std::string v7;
  void *__p[2];
  int64_t v9;

  *((_BYTE *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  v2 = std::string::append(&v7, "ServiceType");
  v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0)
    v4 = __p;
  else
    v4 = (void **)__p[0];
  if (v9 >= 0)
    v5 = HIBYTE(v9);
  else
    v5 = (std::string::size_type)__p[1];
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v7.__r_.__value_.__l.__data_);
  return 0;
}

void sub_100356ABC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

uint64_t sub_100356AF0(std::string *a1)
{
  std::string *v2;
  __int128 v3;
  void **v4;
  std::string::size_type v5;
  std::string v7;
  void *__p[2];
  int64_t v9;

  *((_BYTE *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  v2 = std::string::append(&v7, "LocationTypes");
  v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0)
    v4 = __p;
  else
    v4 = (void **)__p[0];
  if (v9 >= 0)
    v5 = HIBYTE(v9);
  else
    v5 = (std::string::size_type)__p[1];
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v7.__r_.__value_.__l.__data_);
  return 0;
}

void sub_100356B98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

uint64_t sub_100356BCC(std::string *a1)
{
  std::string *v2;
  __int128 v3;
  void **v4;
  std::string::size_type v5;
  std::string v7;
  void *__p[2];
  int64_t v9;

  *((_BYTE *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  v2 = std::string::append(&v7, "UserId");
  v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0)
    v4 = __p;
  else
    v4 = (void **)__p[0];
  if (v9 >= 0)
    v5 = HIBYTE(v9);
  else
    v5 = (std::string::size_type)__p[1];
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v7.__r_.__value_.__l.__data_);
  return 0;
}

void sub_100356C74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

double sub_100356CA8@<D0>(std::string *a1@<X8>)
{
  uint64_t v2;
  std::string *v3;
  __int128 v4;
  void **v5;
  std::string::size_type v6;
  double result;
  std::string v8;
  void *__p[2];
  int64_t v10;
  std::string v11;

  sub_1015A2E04(&v11, "VALUES (");
  v2 = 7;
  do
  {
    if (v2 == 7)
    {
      *((_BYTE *)&v8.__r_.__value_.__s + 23) = 0;
      v8.__r_.__value_.__s.__data_[0] = 0;
    }
    else
    {
      *((_BYTE *)&v8.__r_.__value_.__s + 23) = 2;
      strcpy((char *)&v8, ", ");
    }
    v3 = std::string::append(&v8, "?");
    v4 = *(_OWORD *)&v3->__r_.__value_.__l.__data_;
    v10 = v3->__r_.__value_.__r.__words[2];
    *(_OWORD *)__p = v4;
    v3->__r_.__value_.__l.__size_ = 0;
    v3->__r_.__value_.__r.__words[2] = 0;
    v3->__r_.__value_.__r.__words[0] = 0;
    if (v10 >= 0)
      v5 = __p;
    else
      v5 = (void **)__p[0];
    if (v10 >= 0)
      v6 = HIBYTE(v10);
    else
      v6 = (std::string::size_type)__p[1];
    std::string::append(&v11, (const std::string::value_type *)v5, v6);
    if (SHIBYTE(v10) < 0)
      operator delete(__p[0]);
    if (SHIBYTE(v8.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v8.__r_.__value_.__l.__data_);
    --v2;
  }
  while (v2);
  std::string::append(&v11, ")");
  result = *(double *)&v11.__r_.__value_.__l.__data_;
  *a1 = v11;
  return result;
}

void sub_100356DB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_100356DFC(void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    sub_100356E3C((uint64_t *)v2);
    operator delete(**a1);
  }
}

void sub_100356E3C(uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 40)
  {
    if (*(char *)(i - 17) < 0)
      operator delete(*(void **)(i - 40));
  }
  a1[1] = v2;
}

void sub_100356E88(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

void sub_100356ECC(void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 48;
        sub_100356E88(v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_100356F3C(uint64_t *a1)
{
  if (*a1)
  {
    sub_100356E3C(a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

__n128 sub_100356F74(uint64_t a1, __int128 *a2)
{
  uint64_t v4;
  __int128 v5;
  __n128 result;

  v4 = *(_QWORD *)(a1 + 8);
  if (*((char *)a2 + 23) < 0)
  {
    sub_100115CE4(*(_BYTE **)(a1 + 8), *(void **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v5 = *a2;
    *(_QWORD *)(v4 + 16) = *((_QWORD *)a2 + 2);
    *(_OWORD *)v4 = v5;
  }
  result = *(__n128 *)((char *)a2 + 24);
  *(__n128 *)(v4 + 24) = result;
  *(_QWORD *)(a1 + 8) = v4 + 40;
  return result;
}

void sub_100356FD8(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_100356FE0(uint64_t *a1, __int128 *a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  __int128 v12;
  uint64_t v13;
  _QWORD v15[2];
  char *v16;
  char *v17;
  uint64_t *v18;

  v3 = *a1;
  v4 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 3);
  v5 = v4 + 1;
  if (v4 + 1 > 0x666666666666666)
    sub_100259694();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0xCCCCCCCCCCCCCCCDLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x333333333333333)
    v9 = 0x666666666666666;
  else
    v9 = v5;
  v18 = a1 + 2;
  if (v9)
    v10 = (char *)sub_100357184(v7, v9);
  else
    v10 = 0;
  v11 = &v10[40 * v4];
  v15[0] = v10;
  v15[1] = v11;
  v16 = v11;
  v17 = &v10[40 * v9];
  if (*((char *)a2 + 23) < 0)
  {
    sub_100115CE4(v11, *(void **)a2, *((_QWORD *)a2 + 1));
    v11 = v16;
  }
  else
  {
    v12 = *a2;
    *((_QWORD *)v11 + 2) = *((_QWORD *)a2 + 2);
    *(_OWORD *)v11 = v12;
  }
  *(_OWORD *)&v10[40 * v4 + 24] = *(__int128 *)((char *)a2 + 24);
  v16 = v11 + 40;
  sub_100357110(a1, v15);
  v13 = a1[1];
  sub_1003572E8((uint64_t)v15);
  return v13;
}

void sub_1003570FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1003572E8((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100357110(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = sub_1003571C8((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_100357184(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x666666666666667)
    sub_10025955C();
  return operator new(40 * a2);
}

uint64_t sub_1003571C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  _QWORD v11[3];
  char v12;
  __int128 v13;
  __int128 v14;

  v7 = a7;
  *(_QWORD *)&v14 = a6;
  *((_QWORD *)&v14 + 1) = a7;
  v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    v9 = a6;
  }
  else
  {
    do
    {
      v8 = *(_OWORD *)(a3 - 40);
      *(_QWORD *)(v7 - 24) = *(_QWORD *)(a3 - 24);
      *(_OWORD *)(v7 - 40) = v8;
      *(_QWORD *)(a3 - 32) = 0;
      *(_QWORD *)(a3 - 24) = 0;
      *(_QWORD *)(a3 - 40) = 0;
      *(_OWORD *)(v7 - 16) = *(_OWORD *)(a3 - 16);
      v7 = *((_QWORD *)&v14 + 1) - 40;
      *((_QWORD *)&v14 + 1) -= 40;
      a3 -= 40;
    }
    while (a3 != a5);
    v9 = v14;
  }
  v12 = 1;
  sub_100357270((uint64_t)v11);
  return v9;
}

uint64_t sub_100357270(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    sub_1003572A4(a1);
  return a1;
}

void sub_1003572A4(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 23) < 0)
      operator delete(*(void **)v1);
    v1 += 40;
  }
}

uint64_t sub_1003572E8(uint64_t a1)
{
  sub_10035731C(a1, *(void ***)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void sub_10035731C(uint64_t a1, void **a2)
{
  void **v2;
  void **v5;

  v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      v5 = v2 - 5;
      *(_QWORD *)(a1 + 16) = v2 - 5;
      if (*((char *)v2 - 17) < 0)
      {
        operator delete(*v5);
        v5 = *(void ***)(a1 + 16);
      }
      v2 = v5;
    }
    while (v5 != a2);
  }
}

uint64_t sub_100357370()
{
  std::string *v0;
  __int128 v1;
  std::string *v2;
  __int128 v3;
  void **v4;
  std::string::size_type v5;
  std::string *v6;
  __int128 v7;
  std::string *v8;
  __int128 v9;
  void **v10;
  std::string::size_type v11;
  std::string *v12;
  __int128 v13;
  void *__p[2];
  unsigned __int8 v16;
  void *v17[2];
  unsigned __int8 v18;
  std::string v19;
  std::string v20;
  std::string v21;
  std::string v22;
  std::string v23;

  v19.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x19uLL);
  *(_OWORD *)&v19.__r_.__value_.__r.__words[1] = xmmword_101B980A0;
  strcpy(v19.__r_.__value_.__l.__data_, "INSERT OR REPLACE INTO ");
  v0 = std::string::append(&v19, "MiLoServices");
  v1 = *(_OWORD *)&v0->__r_.__value_.__l.__data_;
  v20.__r_.__value_.__r.__words[2] = v0->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v20.__r_.__value_.__l.__data_ = v1;
  v0->__r_.__value_.__l.__size_ = 0;
  v0->__r_.__value_.__r.__words[2] = 0;
  v0->__r_.__value_.__r.__words[0] = 0;
  v2 = std::string::append(&v20, " (");
  v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  v21.__r_.__value_.__r.__words[2] = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v21.__r_.__value_.__l.__data_ = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  sub_10034F4EC((uint64_t)v17);
  if ((v18 & 0x80u) == 0)
    v4 = v17;
  else
    v4 = (void **)v17[0];
  if ((v18 & 0x80u) == 0)
    v5 = v18;
  else
    v5 = (std::string::size_type)v17[1];
  v6 = std::string::append(&v21, (const std::string::value_type *)v4, v5);
  v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v22.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v22.__r_.__value_.__l.__data_ = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  v8 = std::string::append(&v22, ") ");
  v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v23.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v23.__r_.__value_.__l.__data_ = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  sub_10034F5B4((uint64_t)__p);
  if ((v16 & 0x80u) == 0)
    v10 = __p;
  else
    v10 = (void **)__p[0];
  if ((v16 & 0x80u) == 0)
    v11 = v16;
  else
    v11 = (std::string::size_type)__p[1];
  v12 = std::string::append(&v23, (const std::string::value_type *)v10, v11);
  v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  unk_102301178 = *((_QWORD *)&v12->__r_.__value_.__l + 2);
  xmmword_102301168 = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  if ((char)v16 < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v23.__r_.__value_.__l.__data_);
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v22.__r_.__value_.__l.__data_);
  if ((char)v18 < 0)
    operator delete(v17[0]);
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v21.__r_.__value_.__l.__data_);
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v20.__r_.__value_.__l.__data_);
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v19.__r_.__value_.__l.__data_);
  return __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_102301168, (void *)&_mh_execute_header);
}

void sub_10035755C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  uint64_t v40;

  if (a15 < 0)
    operator delete(__p);
  if (*(char *)(v40 - 25) < 0)
    operator delete(*(void **)(v40 - 48));
  if (*(char *)(v40 - 57) < 0)
    operator delete(*(void **)(v40 - 80));
  if (a21 < 0)
    operator delete(a16);
  if (a40 < 0)
    operator delete(a35);
  if (a33 < 0)
    operator delete(a28);
  if (a27 < 0)
    operator delete(a22);
  _Unwind_Resume(exception_object);
}

_QWORD *sub_100357608@<X0>(_DWORD *a1@<X0>, _QWORD *a2@<X8>)
{
  char *v2;

  if (*a1)
    v2 = "recording";
  else
    v2 = "localization";
  return sub_1015A2E04(a2, v2);
}

_QWORD *sub_10035762C@<X0>(int *a1@<X0>, _QWORD *a2@<X8>)
{
  return sub_1015A2E04(a2, off_102130D20[*a1]);
}

_QWORD *sub_100357644@<X0>(int a1@<W0>, _QWORD *a2@<X8>)
{
  return sub_1015A2E04(a2, off_102130D50[a1 - 1]);
}

void sub_10035765C(int *a1@<X0>, uint64_t a2@<X8>)
{
  float v4;
  int v5;
  uint64_t v6;
  _BYTE v7[8];
  uint64_t v8;
  float v9;
  uint64_t v10;
  int v11;
  int v12;

  sub_1002BB860((uint64_t)v7);
  v8 = *((_QWORD *)a1 + 7);
  v4 = (float)a1[8];
  v12 |= 6u;
  v9 = v4;
  v6 = *(_QWORD *)a1;
  v10 = sub_100129380((uint64_t)&v6);
  v5 = a1[10];
  v12 |= 0x18u;
  v11 = v5;
  sub_1002BD5C4(a2, v7);
  *(_BYTE *)(a2 + 48) = 1;
  sub_1002BD5C8((wireless_diagnostics::google::protobuf::MessageLite *)v7);
}

void sub_1003576F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  sub_1002BD5C8((wireless_diagnostics::google::protobuf::MessageLite *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100357708@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  unsigned __int8 *v4;
  uint64_t result;
  uint64_t v6;
  char v7;

  v3 = *(unsigned __int8 *)(a1 + 23);
  if ((v3 & 0x80u) == 0)
    v4 = (unsigned __int8 *)a1;
  else
    v4 = *(unsigned __int8 **)a1;
  if ((v3 & 0x80u) != 0)
    v3 = *(_QWORD *)(a1 + 8);
  result = sub_100268D2C((uint64_t)&v7, v4, &v4[v3]);
  *(_QWORD *)a2 = result;
  *(_QWORD *)(a2 + 8) = v6;
  *(_BYTE *)(a2 + 16) = 1;
  return result;
}

uint64_t **sub_10035777C@<X0>(uint64_t **result@<X0>, _BYTE *a2@<X8>)
{
  int v2;
  char v3;

  v2 = *((char *)result + 23);
  if (v2 < 0)
  {
    if (result[1] != (uint64_t *)16)
    {
LABEL_7:
      v3 = 0;
      *a2 = 0;
      goto LABEL_8;
    }
    result = (uint64_t **)*result;
  }
  else if (v2 != 16)
  {
    goto LABEL_7;
  }
  *(_OWORD *)a2 = *(_OWORD *)result;
  v3 = 1;
LABEL_8:
  a2[16] = v3;
  return result;
}

id sub_1003577C0@<X0>(id result@<X0>, uint64_t a2@<X8>)
{
  char v3;
  __int128 v4;

  if (result)
  {
    v4 = 0uLL;
    result = objc_msgSend(result, "getUUIDBytes:", &v4);
    *(_OWORD *)a2 = v4;
    v3 = 1;
  }
  else
  {
    v3 = 0;
    *(_BYTE *)a2 = 0;
  }
  *(_BYTE *)(a2 + 16) = v3;
  return result;
}

void sub_10035783C(id *a1@<X0>, _BYTE *a2@<X8>)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  id v7;
  const std::string::value_type *v8;
  NSObject *v9;
  const char *v10;
  void **v11;
  __int16 v12;
  _BYTE v13[8];
  uint64_t v14;
  float v15;
  id v16;
  std::string *v17;
  std::string *v18;
  unsigned int v19;
  int v20;
  void *__p[2];
  char v22;
  std::string::value_type __s[17];

  sub_1002BB834((uint64_t)v13);
  if (!*a1 || !objc_msgSend(*a1, "idsDeviceID"))
  {
LABEL_17:
    *a2 = 0;
    a2[72] = 0;
    goto LABEL_22;
  }
  objc_msgSend(*a1, "bleAdvertisementTimestamp");
  v20 |= 2u;
  v14 = v4;
  v5 = objc_msgSend(*a1, "bleRSSI");
  v20 |= 4u;
  v15 = (float)v5;
  v6 = objc_msgSend(*a1, "bleChannel");
  v20 |= 0x10u;
  v19 = v6;
  v7 = objc_msgSend(*a1, "discoveryFlags");
  v20 |= 0x20u;
  v16 = v7;
  sub_1015A2E04(__p, (char *)objc_msgSend(objc_msgSend(*a1, "idsDeviceID"), "UTF8String"));
  sub_100357708((uint64_t)__p, (uint64_t)__s);
  if (v22 < 0)
    operator delete(__p[0]);
  if (!__s[16])
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130D00);
    v9 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Invalid CBDevice IDS UUID", (uint8_t *)__p, 2u);
    }
    if (sub_1001BFF7C(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130D00);
      v12 = 0;
      _os_log_send_and_compose_impl(2, 0, __p, 1628, &_mh_execute_header, qword_1022A00F8, 16, "Invalid CBDevice IDS UUID", &v12, 2);
      v11 = (void **)v10;
      sub_100512490("Generic", 1, 0, 0, "static std::optional<CLMicroLocationProto::BleLeechedBeacons> CLMicroLocationProtobufHelper::protobufFromNative(const CLMicroLocationBleWrapperForCBDevice &)", "%s\n", v10);
      if (v11 != __p)
        free(v11);
    }
    goto LABEL_17;
  }
  v20 |= 0x80u;
  if (v18 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    operator new();
  std::string::assign(v18, __s, 0x10uLL);
  if (objc_msgSend(*a1, "model"))
  {
    v8 = (const std::string::value_type *)objc_msgSend(objc_msgSend(*a1, "model"), "UTF8String");
    v20 |= 0x40u;
    if (v17 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      operator new();
    std::string::assign(v17, v8);
  }
  else
  {
    v20 |= 0x40u;
    if (v17 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      operator new();
    std::string::assign(v17, "Undefined Model");
  }
  sub_1002BC9C4((uint64_t)a2, (uint64_t)v13);
  a2[72] = 1;
LABEL_22:
  sub_1002BCAA8((wireless_diagnostics::google::protobuf::MessageLite *)v13);
}

void sub_100357BAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  sub_1002BCAA8((wireless_diagnostics::google::protobuf::MessageLite *)&a12);
  _Unwind_Resume(a1);
}

void sub_100357BEC(uint64_t *a1@<X0>, _BYTE *a2@<X8>)
{
  int v4;
  _DWORD *v5;
  int v6;
  int v7;
  int v8;
  int v9;
  char v10;
  NSObject *v11;
  const char *v12;
  void **v13;
  _WORD v14[8];
  _BYTE v15[8];
  uint64_t v16;
  int v17;
  _DWORD *v18;
  std::string *v19;
  int v20;
  uint64_t v21;
  int v22;
  void *__p[2];
  uint64_t v24;
  std::string::value_type __s[17];

  if (*((_BYTE *)a1 + 68) == 1)
  {
    sub_1002BB89C((uint64_t)v15);
    v16 = *a1;
    v4 = *((_DWORD *)a1 + 2);
    v22 |= 6u;
    v17 = v4;
    if (*((char *)a1 + 55) < 0)
    {
      sub_100115CE4(__p, (void *)a1[4], a1[5]);
    }
    else
    {
      *(_OWORD *)__p = *((_OWORD *)a1 + 2);
      v24 = a1[6];
    }
    sub_100357708((uint64_t)__p, (uint64_t)__s);
    if (SHIBYTE(v24) < 0)
      operator delete(__p[0]);
    if (__s[16])
    {
      v22 |= 0x10u;
      if (v19 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
        operator new();
      std::string::assign(v19, __s, 0x10uLL);
      v22 |= 8u;
      v5 = v18;
      if (!v18)
        operator new();
      v6 = *((_DWORD *)a1 + 4);
      v18[6] |= 1u;
      v5[2] = v6;
      v22 |= 8u;
      v7 = *((_DWORD *)a1 + 5);
      v5[6] |= 2u;
      v5[3] = v7;
      v22 |= 8u;
      v8 = *((_DWORD *)a1 + 6);
      v5[6] |= 4u;
      v5[4] = v8;
      v9 = *((unsigned __int8 *)a1 + 56);
      if (!sub_1002BC6C0(v9))
        __assert_rtn("set_devicetype", "microlocation.pb.h", 9831, "::CLMicroLocationProto::UwbRange_DeviceType_IsValid(value)");
      v20 = v9;
      v22 |= 0xE0u;
      v21 = *(uint64_t *)((char *)a1 + 60);
      sub_1002BE2EC(a2, v15);
      v10 = 1;
    }
    else
    {
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130D00);
      v11 = qword_1022A00F8;
      if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Invalid UwbRange IDS UUID", (uint8_t *)__p, 2u);
      }
      if (sub_1001BFF7C(115, 0))
      {
        bzero(__p, 0x65CuLL);
        if (qword_1022A00F0 != -1)
          dispatch_once(&qword_1022A00F0, &stru_102130D00);
        v14[0] = 0;
        _os_log_send_and_compose_impl(2, 0, __p, 1628, &_mh_execute_header, qword_1022A00F8, 16, "Invalid UwbRange IDS UUID", v14, 2);
        v13 = (void **)v12;
        sub_100512490("Generic", 1, 0, 0, "static std::optional<CLMicroLocationProto::UwbRange> CLMicroLocationProtobufHelper::protobufFromNative(const CLHomeNearbyObjectInternal &)", "%s\n", v12);
        if (v13 != __p)
          free(v13);
      }
      v10 = 0;
      *a2 = 0;
    }
    a2[64] = v10;
    sub_1002BE378((wireless_diagnostics::google::protobuf::MessageLite *)v15);
  }
  else
  {
    *a2 = 0;
    a2[64] = 0;
  }
}

void sub_100357F5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  sub_1002BE378((wireless_diagnostics::google::protobuf::MessageLite *)&a13);
  _Unwind_Resume(a1);
}

void sub_100357FB8(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 72) |= 4u;
  v2 = *(_QWORD *)(a1 + 16);
  if (!v2)
    operator new();
  sub_1002BDB30(v2, a2);
}

void sub_100358020()
{
  operator delete();
}

void sub_100358044(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 72) |= 0x40u;
  v2 = *(_QWORD *)(a1 + 48);
  if (!v2)
    operator new();
  sub_1002BD3E0(v2, a2);
}

void sub_1003580AC()
{
  operator delete();
}

float sub_1003580D0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 72) |= 0x80u;
  v2 = *(_QWORD *)(a1 + 56);
  if (!v2)
    operator new();
  return sub_1002BEC8C(v2, a2);
}

void sub_100358138()
{
  operator delete();
}

void sub_10035815C(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 128) |= 8u;
  v2 = *(_QWORD *)(a1 + 24);
  if (!v2)
    operator new();
  sub_1002CC1E8(v2, a2);
}

void sub_1003581C4()
{
  operator delete();
}

void sub_1003581E8(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 128) |= 0x20u;
  v2 = *(_QWORD *)(a1 + 40);
  if (!v2)
    operator new();
  sub_1002CCBDC(v2, a2);
}

void sub_100358250()
{
  operator delete();
}

void sub_100358274(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 128) |= 4u;
  v2 = *(_QWORD *)(a1 + 16);
  if (!v2)
    operator new();
  sub_1002CAD10(v2, a2);
}

void sub_1003582DC()
{
  operator delete();
}

void sub_100358300(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 128) |= 0x40u;
  v2 = *(_QWORD *)(a1 + 48);
  if (!v2)
    operator new();
  sub_1002CD9E0(v2, a2);
}

void sub_100358368()
{
  operator delete();
}

void sub_10035838C(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 128) |= 0x80u;
  v2 = *(_QWORD *)(a1 + 56);
  if (!v2)
    operator new();
  sub_1002CF578(v2, a2);
}

void sub_1003583F4()
{
  operator delete();
}

void sub_100358418(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 128) |= 0x100u;
  v2 = *(_QWORD *)(a1 + 64);
  if (!v2)
    operator new();
  sub_1002D09FC(v2, a2);
}

void sub_100358480()
{
  operator delete();
}

void sub_1003584A4(uint64_t a1, uint64_t a2)
{
  _DWORD *v2;

  *(_DWORD *)(a1 + 48) |= 4u;
  v2 = *(_DWORD **)(a1 + 16);
  if (!v2)
    operator new();
  sub_1002E3E40(v2, a2);
}

void sub_10035850C()
{
  operator delete();
}

void sub_100358530(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 48) |= 8u;
  v2 = *(_QWORD *)(a1 + 24);
  if (!v2)
    operator new();
  sub_1002E44BC(v2, a2);
}

void sub_100358598()
{
  operator delete();
}

void sub_1003585BC(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 48) |= 0x10u;
  v2 = *(_QWORD *)(a1 + 32);
  if (!v2)
    operator new();
  sub_1002E4D5C(v2, a2);
}

void sub_100358624()
{
  operator delete();
}

void sub_100358648(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 128) |= 0x200u;
  v2 = *(_QWORD *)(a1 + 80);
  if (!v2)
    operator new();
  sub_1002D1F68(v2, a2);
}

void sub_1003586B0()
{
  operator delete();
}

void sub_1003586D4(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 128) |= 0x10u;
  v2 = *(_QWORD *)(a1 + 32);
  if (!v2)
    operator new();
  sub_1002CC7F8(v2, a2);
}

void sub_10035873C()
{
  operator delete();
}

void sub_100358760(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 128) |= 0x400u;
  v2 = *(_QWORD *)(a1 + 88);
  if (!v2)
    operator new();
  sub_1002CB748(v2, a2);
}

void sub_1003587C8()
{
  operator delete();
}

void sub_1003587EC(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 128) |= 0x1000u;
  v2 = *(_QWORD *)(a1 + 96);
  if (!v2)
    operator new();
  sub_1002CD5FC(v2, a2);
}

void sub_100358854()
{
  operator delete();
}

void sub_100358878(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 292) |= 2u;
  v2 = *(_QWORD *)(a1 + 16);
  if (!v2)
    operator new();
  sub_1002CC1E8(v2, a2);
}

void sub_1003588E0()
{
  operator delete();
}

void sub_100358904(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 292) |= 8u;
  v2 = *(_QWORD *)(a1 + 32);
  if (!v2)
    operator new();
  sub_1002CCBDC(v2, a2);
}

void sub_10035896C()
{
  operator delete();
}

void sub_100358990(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 292) |= 1u;
  v2 = *(_QWORD *)(a1 + 8);
  if (!v2)
    operator new();
  sub_1002CAD10(v2, a2);
}

void sub_1003589F8()
{
  operator delete();
}

void sub_100358A1C(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 292) |= 0x10u;
  v2 = *(_QWORD *)(a1 + 40);
  if (!v2)
    operator new();
  sub_1002CD9E0(v2, a2);
}

void sub_100358A84()
{
  operator delete();
}

void sub_100358AA8(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 292) |= 0x20u;
  v2 = *(_QWORD *)(a1 + 48);
  if (!v2)
    operator new();
  sub_1002CF578(v2, a2);
}

void sub_100358B10()
{
  operator delete();
}

void sub_100358B34(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 292) |= 0x40u;
  v2 = *(_QWORD *)(a1 + 56);
  if (!v2)
    operator new();
  sub_1002D09FC(v2, a2);
}

void sub_100358B9C()
{
  operator delete();
}

void sub_100358BC0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 292) |= 0x80u;
  v2 = *(_QWORD *)(a1 + 64);
  if (!v2)
    operator new();
  sub_1002D1F68(v2, a2);
}

void sub_100358C28()
{
  operator delete();
}

void sub_100358C4C(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 292) |= 4u;
  v2 = *(_QWORD *)(a1 + 24);
  if (!v2)
    operator new();
  sub_1002CC7F8(v2, a2);
}

void sub_100358CB4()
{
  operator delete();
}

void sub_100358CD8(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 292) |= 0x100u;
  v2 = *(_QWORD *)(a1 + 72);
  if (!v2)
    operator new();
  sub_1002CB748(v2, a2);
}

void sub_100358D40()
{
  operator delete();
}

void sub_100358D64(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 292) |= 0x400u;
  v2 = *(_QWORD *)(a1 + 88);
  if (!v2)
    operator new();
  sub_1002D234C(v2, a2);
}

void sub_100358DCC()
{
  operator delete();
}

void sub_100358DF0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 292) |= 0x800u;
  v2 = *(_QWORD *)(a1 + 96);
  if (!v2)
    operator new();
  sub_1002D2730(v2, a2);
}

void sub_100358E58()
{
  operator delete();
}

void sub_100358E7C(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 292) |= 0x1000u;
  v2 = *(_QWORD *)(a1 + 104);
  if (!v2)
    operator new();
  sub_1002D2B14(v2, a2);
}

void sub_100358EE4()
{
  operator delete();
}

void sub_100358F08(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 292) |= 0x2000u;
  v2 = *(_QWORD *)(a1 + 112);
  if (!v2)
    operator new();
  sub_1002D2EF8(v2, a2);
}

void sub_100358F70()
{
  operator delete();
}

void sub_100358F94(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 292) |= 0x4000u;
  v2 = *(_QWORD *)(a1 + 120);
  if (!v2)
    operator new();
  sub_1002D32DC(v2, a2);
}

void sub_100358FFC()
{
  operator delete();
}

void sub_100359020(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 292) |= 0x8000u;
  v2 = *(_QWORD *)(a1 + 128);
  if (!v2)
    operator new();
  sub_1002D39CC(v2, a2);
}

void sub_100359088()
{
  operator delete();
}

void sub_1003590AC(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 292) |= 0x10000u;
  v2 = *(_QWORD *)(a1 + 136);
  if (!v2)
    operator new();
  sub_1002D4218(v2, a2);
}

void sub_100359114()
{
  operator delete();
}

void sub_100359138(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 292) |= 0x20000u;
  v2 = *(_QWORD *)(a1 + 144);
  if (!v2)
    operator new();
  sub_1002D49BC(v2, a2);
}

void sub_1003591A0()
{
  operator delete();
}

void sub_1003591C4(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 292) |= 0x40000u;
  v2 = *(_QWORD *)(a1 + 152);
  if (!v2)
    operator new();
  sub_1002D5160(v2, a2);
}

void sub_10035922C()
{
  operator delete();
}

void sub_100359250(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 292) |= 0x80000u;
  v2 = *(_QWORD *)(a1 + 160);
  if (!v2)
    operator new();
  sub_1002D5A90(v2, a2);
}

void sub_1003592B8()
{
  operator delete();
}

void sub_1003592DC(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 292) |= 0x100000u;
  v2 = *(_QWORD *)(a1 + 168);
  if (!v2)
    operator new();
  sub_1002D6234(v2, a2);
}

void sub_100359344()
{
  operator delete();
}

void sub_100359368(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 292) |= 0x200000u;
  v2 = *(_QWORD *)(a1 + 176);
  if (!v2)
    operator new();
  sub_1002D6E14(v2, a2);
}

void sub_1003593D0()
{
  operator delete();
}

void sub_1003593F4(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 292) |= 0x400000u;
  v2 = *(_QWORD *)(a1 + 184);
  if (!v2)
    operator new();
  sub_1002D7754(v2, a2);
}

void sub_10035945C()
{
  operator delete();
}

void sub_100359480(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 292) |= 0x800000u;
  v2 = *(_QWORD *)(a1 + 192);
  if (!v2)
    operator new();
  sub_1002D7D64(v2, a2);
}

void sub_1003594E8()
{
  operator delete();
}

void sub_10035950C(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 292) |= 0x1000000u;
  v2 = *(_QWORD *)(a1 + 200);
  if (!v2)
    operator new();
  sub_1002D8808(v2, a2);
}

void sub_100359574()
{
  operator delete();
}

void sub_100359598(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 292) |= 0x2000000u;
  v2 = *(_QWORD *)(a1 + 208);
  if (!v2)
    operator new();
  sub_1002D8E18(v2, a2);
}

void sub_100359600()
{
  operator delete();
}

void sub_100359624(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 292) |= 0x4000000u;
  v2 = *(_QWORD *)(a1 + 216);
  if (!v2)
    operator new();
  sub_1002D9A1C(v2, a2);
}

void sub_10035968C()
{
  operator delete();
}

void sub_1003596B0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 292) |= 0x8000000u;
  v2 = *(_QWORD *)(a1 + 224);
  if (!v2)
    operator new();
  sub_1002E1A58(v2, a2);
}

void sub_100359718()
{
  operator delete();
}

void sub_10035973C(uint64_t a1, uint64_t a2)
{
  _DWORD *v2;

  *(_DWORD *)(a1 + 292) |= 0x10000000u;
  v2 = *(_DWORD **)(a1 + 232);
  if (!v2)
    operator new();
  sub_1002E1E84(v2, a2);
}

void sub_1003597A4()
{
  operator delete();
}

void sub_1003597C8(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 292) |= 0x20000000u;
  v2 = *(_QWORD *)(a1 + 240);
  if (!v2)
    operator new();
  sub_1002E2274(v2, a2);
}

void sub_100359830()
{
  operator delete();
}

void sub_100359854(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 292) |= 0x40000000u;
  v2 = *(_QWORD *)(a1 + 248);
  if (!v2)
    operator new();
  sub_1002E29CC(v2, a2);
}

void sub_1003598BC()
{
  operator delete();
}

void sub_1003598E0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 296) |= 4u;
  v2 = *(_QWORD *)(a1 + 280);
  if (!v2)
    operator new();
  sub_1002DA02C(v2, a2);
}

void sub_100359948()
{
  operator delete();
}

void sub_10035996C(uint64_t a1@<X0>, id a2@<X1>, uint64_t a3@<X8>)
{
  const char *v6;
  std::string *v7;
  int v8;
  id v9;
  std::string *v10;
  std::string *v11;
  NSObject *v12;
  const char *v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  _BYTE v17[10];
  __int16 v18;
  const char *v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  const char *v25;

  sub_1002BBB1C((_QWORD *)a3);
  if (*(_BYTE *)(a1 + 24))
  {
    v6 = (const char *)a1;
    if (*(char *)(a1 + 23) < 0)
      v6 = *(const char **)a1;
    *(_DWORD *)(a3 + 44) |= 4u;
    v7 = *(std::string **)(a3 + 16);
    if (v7 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      operator new();
    std::string::operator=(v7, (const std::string *)a1);
    if (a2)
      goto LABEL_7;
LABEL_15:
    v9 = 0;
    v8 = 1;
    goto LABEL_22;
  }
  v6 = "";
  if (!a2)
    goto LABEL_15;
LABEL_7:
  if (objc_msgSend(objc_msgSend(a2, "objectForKey:", CFSTR("private.MicroLocation.forced.recordingRequest")), "BOOLValue"))v8 = 2;
  else
    v8 = 1;
  if (objc_msgSend(a2, "objectForKey:", CFSTR("private.MicroLocation.truthtag.identifier")))
  {
    v9 = objc_msgSend(a2, "objectForKeyedSubscript:", CFSTR("private.MicroLocation.truthtag.identifier"));
    v16 = 0;
    *(_QWORD *)v17 = 0;
    objc_msgSend(v9, "getUUIDBytes:", &v16);
    *(_DWORD *)(a3 + 44) |= 0x10u;
    v10 = *(std::string **)(a3 + 32);
    if (v10 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      operator new();
    std::string::assign(v10, (const std::string::value_type *)&v16, 0x10uLL);
  }
  else
  {
    v9 = 0;
  }
  if (objc_msgSend(a2, "objectForKey:", CFSTR("private.MicroLocation.recordingTriggerUUID")))
  {
    a2 = objc_msgSend(a2, "objectForKeyedSubscript:", CFSTR("private.MicroLocation.recordingTriggerUUID"));
    v16 = 0;
    *(_QWORD *)v17 = 0;
    objc_msgSend(a2, "getUUIDBytes:", &v16);
    *(_DWORD *)(a3 + 44) |= 8u;
    v11 = *(std::string **)(a3 + 24);
    if (v11 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
      operator new();
    std::string::assign(v11, (const std::string::value_type *)&v16, 0x10uLL);
  }
  else
  {
    a2 = 0;
  }
LABEL_22:
  if (!sub_1002BC6C0(v8))
    __assert_rtn("set_recordingrequesttype", "microlocation.pb.h", 13116, "::CLMicroLocationProto::RecordingRequestType_IsValid(value)");
  *(_DWORD *)(a3 + 44) |= 2u;
  *(_DWORD *)(a3 + 12) = v8;
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130D00);
  v12 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEBUG))
  {
    if (v8 == 2)
      v13 = "YES";
    else
      v13 = "NO";
    if (v9)
      v14 = (const char *)objc_msgSend(objc_msgSend(v9, "UUIDString"), "UTF8String");
    else
      v14 = "";
    if (a2)
      v15 = (const char *)objc_msgSend(objc_msgSend(a2, "UUIDString"), "UTF8String");
    else
      v15 = "";
    v16 = 68290051;
    *(_WORD *)v17 = 2082;
    *(_QWORD *)&v17[2] = "";
    v18 = 2082;
    v19 = v6;
    v20 = 2082;
    v21 = v13;
    v22 = 2081;
    v23 = v14;
    v24 = 2082;
    v25 = v15;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"client request, recording scan\", \"client\":%{public, location:escape_only}s, \"forced?\":%{public, location:escape_only}s, \"truth label\":%{private, location:escape_only}s, \"recording trigger UUID\":%{public, location:escape_only}s}", (uint8_t *)&v16, 0x3Au);
  }
}

void sub_100359CD4(_Unwind_Exception *a1)
{
  wireless_diagnostics::google::protobuf::MessageLite *v1;

  sub_1002CAF70(v1);
  _Unwind_Resume(a1);
}

id sub_100359CF8(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  id v6;
  id v7;
  id v8;
  id v9;
  void *v10;
  id v11;
  id v12;
  void *v13;
  uint64_t v15;
  uint64_t v16;
  _QWORD v17[2];

  v17[0] = a2;
  v17[1] = a3;
  v6 = objc_msgSend(objc_alloc((Class)NSUUID), "initWithUUIDBytes:", v17);
  if (*(_BYTE *)(a4 + 16))
  {
    v7 = objc_alloc((Class)NSUUID);
    if (!*(_BYTE *)(a4 + 16))
      sub_10028DF3C();
    v8 = objc_msgSend(v7, "initWithUUIDBytes:", a4);
    v9 = objc_alloc((Class)NSDictionary);
    if (a1)
      v10 = &__kCFBooleanTrue;
    else
      v10 = &__kCFBooleanFalse;
    v11 = objc_msgSend(v9, "initWithObjectsAndKeys:", v10, CFSTR("private.MicroLocation.forced.recordingRequest"), v6, CFSTR("private.MicroLocation.recordingTriggerUUID"), v8, CFSTR("private.MicroLocation.truthtag.identifier"), 0);
  }
  else
  {
    v12 = objc_alloc((Class)NSDictionary);
    if (a1)
      v13 = &__kCFBooleanTrue;
    else
      v13 = &__kCFBooleanFalse;
    v11 = objc_msgSend(v12, "initWithObjectsAndKeys:", v13, CFSTR("private.MicroLocation.forced.recordingRequest"), v6, CFSTR("private.MicroLocation.recordingTriggerUUID"), 0, v15, v16);
  }
  return v11;
}

uint64_t sub_100359E44@<X0>(uint64_t result@<X0>, _BYTE *a2@<X8>)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t **v5;
  int v6;
  char v7;

  v2 = *(_DWORD *)(result + 128);
  if ((v2 & 4) == 0)
    goto LABEL_8;
  v3 = *(_QWORD *)(result + 16);
  if (!v3)
    v3 = *(_QWORD *)(qword_102310400 + 16);
  if ((*(_BYTE *)(v3 + 44) & 8) != 0)
  {
    v5 = *(uint64_t ***)(v3 + 24);
  }
  else
  {
LABEL_8:
    if ((v2 & 0x400) == 0)
      goto LABEL_17;
    v4 = *(_QWORD *)(result + 88);
    if (!v4)
      v4 = *(_QWORD *)(qword_102310400 + 88);
    if ((*(_BYTE *)(v4 + 44) & 8) == 0)
      goto LABEL_17;
    v5 = *(uint64_t ***)(v4 + 24);
  }
  v6 = *((char *)v5 + 23);
  if (v6 < 0)
  {
    if (v5[1] != (uint64_t *)16)
    {
LABEL_17:
      v7 = 0;
      *a2 = 0;
      goto LABEL_18;
    }
    v5 = (uint64_t **)*v5;
  }
  else if (v6 != 16)
  {
    goto LABEL_17;
  }
  *(_OWORD *)a2 = *(_OWORD *)v5;
  v7 = 1;
LABEL_18:
  a2[16] = v7;
  return result;
}

CFAbsoluteTime sub_100359EE0(uint64_t a1)
{
  NSObject *v1;
  const char *v3;
  uint8_t *v4;
  _WORD v5[8];
  uint8_t buf[1640];

  if ((*(_BYTE *)(a1 + 128) & 2) != 0)
    return *(double *)(a1 + 8);
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130D00);
  v1 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "Event Received without Timestamp!", buf, 2u);
  }
  if (sub_1001BFF7C(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130D00);
    v5[0] = 0;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 16, "Event Received without Timestamp!", v5, 2);
    v4 = (uint8_t *)v3;
    sub_100512490("Generic", 1, 0, 0, "static cl::chrono::CFAbsoluteTimeClock::time_point CLMicroLocationProtobufHelper::getEventReceivedTS(const CLMicroLocationProto::RecordingEvent &)", "%s\n", v3);
    if (v4 != buf)
      free(v4);
  }
  return j__CFAbsoluteTimeGetCurrent();
}

void sub_10035A078(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  int v4;
  uint64_t v5;
  _QWORD v6[8];
  int v7;
  int v8;

  sub_1002BB8D0((uint64_t)v6);
  v4 = *(_DWORD *)(a1 + 16);
  if (!sub_1002BC664(v4))
    __assert_rtn("set_datatype", "microlocation.pb.h", 10437, "::CLMicroLocationProto::DataType_IsValid(value)");
  v5 = *(_QWORD *)(a1 + 8);
  v7 = v4;
  v8 |= 3u;
  v6[1] = v5;
  sub_100357FB8((uint64_t)v6, a1);
  sub_1002C0A54(a2, v6);
  *(_BYTE *)(a2 + 80) = 1;
  sub_1002C0B04((wireless_diagnostics::google::protobuf::MessageLite *)v6);
}

void sub_10035A124(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1002C0B04((wireless_diagnostics::google::protobuf::MessageLite *)&a9);
  _Unwind_Resume(a1);
}

double sub_10035A138(uint64_t a1)
{
  uint64_t v1;
  double result;

  switch(*(_DWORD *)(a1 + 64))
  {
    case 1:
      v1 = *(_QWORD *)(a1 + 16);
      if (!v1)
        v1 = *(_QWORD *)(qword_102310298 + 16);
      goto LABEL_14;
    case 2:
      v1 = *(_QWORD *)(a1 + 24);
      if (!v1)
        v1 = *(_QWORD *)(qword_102310298 + 24);
      goto LABEL_14;
    case 3:
      v1 = *(_QWORD *)(a1 + 32);
      if (!v1)
        v1 = *(_QWORD *)(qword_102310298 + 32);
      goto LABEL_14;
    case 4:
      v1 = *(_QWORD *)(a1 + 40);
      if (!v1)
        v1 = *(_QWORD *)(qword_102310298 + 40);
      goto LABEL_14;
    case 5:
      v1 = *(_QWORD *)(a1 + 48);
      if (!v1)
        v1 = *(_QWORD *)(qword_102310298 + 48);
      goto LABEL_14;
    case 6:
      v1 = *(_QWORD *)(a1 + 56);
      if (!v1)
        v1 = *(_QWORD *)(qword_102310298 + 56);
LABEL_14:
      result = *(float *)(v1 + 20);
      break;
    default:
      return result;
  }
  return result;
}

uint64_t sub_10035A214@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v4;

  v4 = nullsub_34(a1);
  return sub_1000C2348(&v4, a2);
}

_BYTE *sub_10035A24C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  char *v4;

  v4 = (char *)operator new(0x28uLL);
  *(_QWORD *)a2 = v4;
  *(_OWORD *)(a2 + 8) = xmmword_101B97FF0;
  *(_OWORD *)v4 = 0u;
  *((_OWORD *)v4 + 1) = 0u;
  *(_QWORD *)(v4 + 29) = 0;
  return sub_100261F9C(a1, v4);
}

void sub_10035A2A8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

double sub_10035A2BC(int a1)
{
  double result;

  result = -110.0;
  if (((a1 - 2) & 0xFFFFFFFB) == 0)
    return 20.0;
  return result;
}

void *sub_10035A2D8@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  __int128 *v2;
  __int128 *v3;

  if (((_DWORD)result - 2) >= 2)
  {
    if ((_DWORD)result == 1)
    {
      if ((byte_10231049F & 0x80000000) == 0)
      {
        v2 = &xmmword_102310488;
        goto LABEL_9;
      }
      v3 = &xmmword_102310488;
    }
    else
    {
      if ((byte_102310487 & 0x80000000) == 0)
      {
        v2 = &xmmword_102310470;
        goto LABEL_9;
      }
      v3 = &xmmword_102310470;
    }
  }
  else
  {
    if ((byte_1023104CF & 0x80000000) == 0)
    {
      v2 = &xmmword_1023104B8;
LABEL_9:
      *(_OWORD *)a2 = *v2;
      *(_QWORD *)(a2 + 16) = *((_QWORD *)v2 + 2);
      return result;
    }
    v3 = &xmmword_1023104B8;
  }
  return sub_100115CE4((_BYTE *)a2, *(void **)v3, *((_QWORD *)v3 + 1));
}

uint64_t sub_10035A370(uint64_t *a1)
{
  int v1;
  uint64_t *v2;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v14;
  int v15;
  NSObject *v17;
  uint64_t *v18;
  NSObject *v19;
  uint64_t *v20;
  NSObject *v21;
  uint64_t *v22;
  uint8_t buf[4];
  int v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  uint64_t *v29;
  __int16 v30;
  const char *v31;
  __int16 v32;
  const char *v33;

  v1 = *((unsigned __int8 *)a1 + 23);
  if (*((char *)a1 + 23) < 0)
  {
    v7 = a1[1];
    if (v7 != 15)
      goto LABEL_35;
    v8 = (uint64_t *)*a1;
    if (*(_QWORD *)*a1 == 0x5F4C41434947414DLL && *(_QWORD *)(*a1 + 7) == 0x53544E454D4F4D5FLL)
      return 0;
    v10 = *v8;
    v11 = *(uint64_t *)((char *)v8 + 7);
    if (v10 == 0x5055535F494D4553 && v11 == 0x4445534956524550)
      return 1;
    v7 = a1[1];
    if (v7 != 15)
      goto LABEL_35;
    if (*(_QWORD *)*a1 == 0x4952414C494D4953 && *(_QWORD *)(*a1 + 7) == 0x5453494C5F595449)
      return 2;
    if ((v1 & 0x80) == 0)
    {
      v2 = a1;
      if (v1 != 10)
        goto LABEL_45;
    }
    else
    {
LABEL_35:
      if (v7 != 10)
        goto LABEL_45;
      v2 = (uint64_t *)*a1;
    }
  }
  else
  {
    v2 = a1;
    if (v1 != 10)
    {
      if (v1 != 15)
        goto LABEL_45;
      if (*a1 != 0x5F4C41434947414DLL || *(uint64_t *)((char *)a1 + 7) != 0x53544E454D4F4D5FLL)
      {
        if (*a1 != 0x5055535F494D4553 || *(uint64_t *)((char *)a1 + 7) != 0x4445534956524550)
        {
          if (*a1 != 0x4952414C494D4953 || *(uint64_t *)((char *)a1 + 7) != 0x5453494C5F595449)
            goto LABEL_45;
          return 2;
        }
        return 1;
      }
      return 0;
    }
  }
  v14 = *v2;
  v15 = *((unsigned __int16 *)v2 + 4);
  if (v14 != 0x4C54415F45554C42 || v15 != 21313)
  {
LABEL_45:
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130D00);
    v17 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_FAULT))
    {
      v18 = a1;
      if (*((char *)a1 + 23) < 0)
        v18 = (uint64_t *)*a1;
      *(_DWORD *)buf = 68289795;
      v25 = 0;
      v26 = 2082;
      v27 = "";
      v28 = 2081;
      v29 = v18;
      v30 = 2082;
      v31 = "assert";
      v32 = 2081;
      v33 = "false";
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Can't find a model type that corresponds to string\", \"string\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x30u);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130D00);
    }
    v19 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      v20 = a1;
      if (*((char *)a1 + 23) < 0)
        v20 = (uint64_t *)*a1;
      *(_DWORD *)buf = 68289795;
      v25 = 0;
      v26 = 2082;
      v27 = "";
      v28 = 2081;
      v29 = v20;
      v30 = 2082;
      v31 = "assert";
      v32 = 2081;
      v33 = "false";
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v19, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Can't find a model type that corresponds to string", "{\"msg%{public}.0s\":\"Can't find a model type that corresponds to string\", \"string\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x30u);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130D00);
    }
    v21 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_INFO))
    {
      v22 = a1;
      if (*((char *)a1 + 23) < 0)
        v22 = (uint64_t *)*a1;
      *(_DWORD *)buf = 68289795;
      v25 = 0;
      v26 = 2082;
      v27 = "";
      v28 = 2081;
      v29 = v22;
      v30 = 2082;
      v31 = "assert";
      v32 = 2081;
      v33 = "false";
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Can't find a model type that corresponds to string\", \"string\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x30u);
    }
    abort_report_np("%s:%d: assertion failure in %s", "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationProtobufHelper.mm", 988, "modelTypeFromString");
    __break(1u);
  }
  return 3;
}

_QWORD *sub_10035A840@<X0>(int a1@<W0>, _QWORD *a2@<X8>)
{
  return sub_1015A2E04(a2, off_102130DA8[a1]);
}

void sub_10035A854(void *a1, unsigned __int8 **a2, uint64_t a3)
{
  unsigned __int8 **v4;
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  NSObject *global_queue;
  _QWORD block[6];
  char v10;
  const char *v11;

  v4 = a2;
  v6 = *a2;
  v7 = a2[1];
  v11 = (const char *)objc_msgSend(a1, "UTF8String");
  LOBYTE(v4) = sub_10035ADB0(v6, v7, &v11) != v4[1];
  global_queue = dispatch_get_global_queue(0, 0);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10035A904;
  block[3] = &unk_102130CE0;
  v10 = (char)v4;
  block[4] = a1;
  block[5] = a3;
  dispatch_async(global_queue, block);
}

void sub_10035A904(uint64_t a1)
{
  uint64_t v2;
  unsigned __int8 v3;
  int v4;
  char v5;
  uint64_t v6;
  _BYTE v7[24];
  _BYTE v8[16];
  int v9;

  sub_1002BBADC((uint64_t)v8);
  if (objc_opt_class(AVSystemController, v2))
  {
    v3 = objc_msgSend(+[AVSystemController sharedAVSystemController](AVSystemController, "sharedAVSystemController"), "hasRouteSharingPolicyLongFormVideo:", *(_QWORD *)(a1 + 32));
    v4 = v9 | 1;
    v8[8] = v3;
  }
  else
  {
    v4 = v9;
  }
  v5 = *(_BYTE *)(a1 + 48);
  v9 = v4 | 2;
  v8[9] = v5;
  v6 = *(_QWORD *)(a1 + 40);
  sub_1002C9EEC(v7, v8);
  (*(void (**)(uint64_t, _BYTE *))(v6 + 16))(v6, v7);
  sub_1002C9EF0((wireless_diagnostics::google::protobuf::MessageLite *)v7);
  sub_1002C9EF0((wireless_diagnostics::google::protobuf::MessageLite *)v8);
}

void sub_10035A9A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  sub_1002C9EF0((wireless_diagnostics::google::protobuf::MessageLite *)&a9);
  sub_1002C9EF0((wireless_diagnostics::google::protobuf::MessageLite *)&a12);
  _Unwind_Resume(a1);
}

const __CFString *sub_10035A9C8(uint64_t a1)
{
  int v1;
  const __CFString *result;

  v1 = *(_DWORD *)(a1 + 72);
  result = CFSTR("receivedEventAction");
  switch(v1)
  {
    case 1:
      return result;
    case 2:
      result = CFSTR("appLaunch");
      break;
    case 3:
    case 6:
    case 8:
    case 11:
      goto LABEL_6;
    case 4:
      result = CFSTR("backlightOn");
      break;
    case 5:
      result = CFSTR("batteryChargerConnected");
      break;
    case 7:
      result = CFSTR("forcedRecording");
      break;
    case 9:
      result = CFSTR("homekitAccessory");
      break;
    case 10:
      result = CFSTR("homekitScene");
      break;
    case 12:
      result = CFSTR("nowPlaying");
      break;
    case 13:
      result = CFSTR("recordingRequest");
      break;
    case 14:
      result = CFSTR("truthLabelDonation");
      break;
    default:
      if (v1 == 42)
      {
        result = CFSTR("RequestObservation");
      }
      else if (v1 == 43)
      {
        result = CFSTR("RequestPrediction");
      }
      else
      {
LABEL_6:
        result = CFSTR("triggerInvalid");
      }
      break;
  }
  return result;
}

_QWORD *sub_10035AA98@<X0>(int a1@<W0>, _QWORD *a2@<X8>)
{
  return sub_1015A2E04(a2, off_102130DC8[a1]);
}

uint64_t sub_10035AAAC(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 64) == 1)
    return (*(unsigned __int8 *)(a1 + 81) >> 4) & 1;
  else
    return 0;
}

uint64_t sub_10035AACC(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 64) == 1)
    return *(unsigned __int8 *)(a1 + 81) >> 7;
  else
    return 0;
}

void sub_10035AAEC(_QWORD *a1@<X0>, uint64_t *a2@<X8>)
{
  int *v4;
  int *v5;
  unint64_t v6;
  uint64_t v7;
  int *v8;
  _BYTE v9[80];
  char v10;

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  sub_10035AC0C(a2, 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(a1[1] - *a1) >> 3));
  v4 = (int *)a1[1];
  if ((int *)*a1 != v4)
  {
    v5 = (int *)(*a1 + 48);
    do
    {
      sub_10035A078((uint64_t)(v5 - 12), (uint64_t)v9);
      if (v10)
      {
        v6 = a2[1];
        if (v6 >= a2[2])
        {
          v7 = sub_10035AED4(a2, (uint64_t)v9, v5);
        }
        else
        {
          sub_10035AFF8(a2[1], (uint64_t)v9, *v5);
          v7 = v6 + 88;
          a2[1] = v6 + 88;
        }
        a2[1] = v7;
        if (v10)
          sub_1002C0B04((wireless_diagnostics::google::protobuf::MessageLite *)v9);
      }
      v8 = v5 + 2;
      v5 += 14;
    }
    while (v8 != v4);
  }
}

void sub_10035ABCC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1002A1A78((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10035AC0C(uint64_t *a1, unint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v7[5];

  v4 = a1[2];
  result = (uint64_t)(a1 + 2);
  if (0x2E8BA2E8BA2E8BA3 * ((v4 - *a1) >> 3) < a2)
  {
    if (a2 >= 0x2E8BA2E8BA2E8BBLL)
      sub_100259694();
    v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = sub_100279B30(result, a2);
    v7[1] = v7[0] + v5;
    v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 88 * v6;
    sub_10035AE60(a1, v7);
    return sub_1002A2E9C((uint64_t)v7);
  }
  return result;
}

void sub_10035ACB4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1002A2E9C((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10035ACC8(id a1)
{
  qword_1022A00F8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

_QWORD *sub_10035ACF4(_QWORD *__dst, void *__src, size_t __len)
{
  void *v6;
  size_t v7;
  size_t v8;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
    sub_1002594D4();
  if (__len >= 0x17)
  {
    v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v7 = __len | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    __dst[1] = __len;
    __dst[2] = v8 | 0x8000000000000000;
    *__dst = v6;
  }
  else
  {
    *((_BYTE *)__dst + 23) = __len;
    v6 = __dst;
    if (!__len)
      goto LABEL_9;
  }
  memmove(v6, __src, __len);
LABEL_9:
  *((_BYTE *)v6 + __len) = 0;
  return __dst;
}

void sub_10035AD9C()
{
  sub_100263950("basic_string");
}

unsigned __int8 *sub_10035ADB0(unsigned __int8 *a1, unsigned __int8 *a2, const char **a3)
{
  unsigned __int8 *v3;
  const char *v5;
  size_t v6;
  unsigned __int8 *v7;

  v3 = a1;
  if (a1 != a2)
  {
    v5 = *a3;
    v6 = strlen(*a3);
    while (1)
    {
      if ((char)v3[23] < 0)
      {
        if (v6 == *((_QWORD *)v3 + 1))
        {
          if (v6 == -1)
LABEL_14:
            sub_10035AD9C();
          v7 = *(unsigned __int8 **)v3;
LABEL_10:
          if (!memcmp(v7, v5, v6))
            return v3;
        }
      }
      else if (v6 == v3[23])
      {
        v7 = v3;
        if (v6 == -1)
          goto LABEL_14;
        goto LABEL_10;
      }
      v3 += 24;
      if (v3 == a2)
        return a2;
    }
  }
  return v3;
}

uint64_t sub_10035AE60(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = sub_1002A2D64((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_10035AED4(uint64_t *a1, uint64_t a2, int *a3)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  uint64_t v13;
  char *v15;
  char *v16;
  uint64_t v17;
  char *v18;
  uint64_t *v19;

  v4 = *a1;
  v5 = 0x2E8BA2E8BA2E8BA3 * ((a1[1] - *a1) >> 3);
  v6 = v5 + 1;
  if ((unint64_t)(v5 + 1) > 0x2E8BA2E8BA2E8BALL)
    sub_100259694();
  v9 = (uint64_t)(a1 + 2);
  v10 = 0x2E8BA2E8BA2E8BA3 * ((a1[2] - v4) >> 3);
  if (2 * v10 > v6)
    v6 = 2 * v10;
  if (v10 >= 0x1745D1745D1745DLL)
    v11 = 0x2E8BA2E8BA2E8BALL;
  else
    v11 = v6;
  v19 = a1 + 2;
  if (v11)
    v12 = (char *)sub_100279B30(v9, v11);
  else
    v12 = 0;
  v15 = v12;
  v16 = &v12[88 * v5];
  v17 = (uint64_t)v16;
  v18 = &v12[88 * v11];
  sub_10035AFF8((uint64_t)v16, a2, *a3);
  v17 = (uint64_t)(v16 + 88);
  sub_10035AE60(a1, &v15);
  v13 = a1[1];
  sub_1002A2E9C((uint64_t)&v15);
  return v13;
}

void sub_10035AFE4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1002A2E9C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10035AFF8(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6;

  sub_1002BB8D0(a1);
  *(_DWORD *)(v6 + 80) = a3;
  sub_1002C192C(v6, a2);
  return a1;
}

void sub_10035B038(_Unwind_Exception *a1)
{
  wireless_diagnostics::google::protobuf::MessageLite *v1;

  sub_1002C0B04(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10035B04C()
{
  sub_1015A2E04(&xmmword_102310470, "com.apple.magicalmoments");
  __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_102310470, (void *)&_mh_execute_header);
  sub_1015A2E04(&xmmword_102310488, "com.apple.microlocation.semisupervised");
  __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_102310488, (void *)&_mh_execute_header);
  sub_1015A2E04(&qword_1023104A0, "com.apple.microlocation.homeloi");
  __cxa_atexit((void (*)(void *))&std::string::~string, &qword_1023104A0, (void *)&_mh_execute_header);
  sub_1015A2E04(&xmmword_1023104B8, "com.apple.microlocation.similarity");
  return __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_1023104B8, (void *)&_mh_execute_header);
}

void sub_10035B118(uint64_t a1, int a2)
{
  NSObject *v4;
  const char *v5;
  const char *v6;
  const char *v7;
  uint8_t *v8;
  int v9;
  const char *v10;
  uint8_t buf[4];
  const char *v12;

  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130EE8);
  v4 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    v5 = "not running";
    if (a2)
      v5 = "running";
    *(_DWORD *)buf = 136446210;
    v12 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "BLE spyscan session set to %{public}s", buf, 0xCu);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130EE8);
    v6 = "not running";
    if (a2)
      v6 = "running";
    v9 = 136446210;
    v10 = v6;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "BLE spyscan session set to %{public}s", &v9, 12);
    v8 = (uint8_t *)v7;
    sub_100512490("Generic", 1, 0, 2, "void CLMicroLocationSensorsLogic::State::setBleSpyscanSessionRunning(BOOL)", "%s\n", v7);
    if (v8 != buf)
      free(v8);
  }
  *(_BYTE *)(a1 + 160) = a2;
}

void sub_10035B2F8(uint64_t a1, int a2)
{
  NSObject *v4;
  const char *v5;
  const char *v6;
  const char *v7;
  uint8_t *v8;
  int v9;
  const char *v10;
  uint8_t buf[4];
  const char *v12;

  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130EE8);
  v4 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    v5 = "stopped";
    if (a2)
      v5 = "running";
    *(_DWORD *)buf = 136446210;
    v12 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Ranging session set to %{public}s", buf, 0xCu);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130EE8);
    v6 = "stopped";
    if (a2)
      v6 = "running";
    v9 = 136446210;
    v10 = v6;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "Ranging session set to %{public}s", &v9, 12);
    v8 = (uint8_t *)v7;
    sub_100512490("Generic", 1, 0, 2, "void CLMicroLocationSensorsLogic::State::setRangingSessionRunning(BOOL)", "%s\n", v7);
    if (v8 != buf)
      free(v8);
  }
  *(_BYTE *)(a1 + 161) = a2;
}

void sub_10035B4D8(uint64_t a1, int a2)
{
  NSObject *v4;
  const char *v5;
  const char *v6;
  const char *v7;
  uint8_t *v8;
  int v9;
  const char *v10;
  uint8_t buf[4];
  const char *v12;

  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130EE8);
  v4 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    v5 = "stopped";
    if (a2)
      v5 = "running";
    *(_DWORD *)buf = 136446210;
    v12 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Motion fence set to %{public}s", buf, 0xCu);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130EE8);
    v6 = "stopped";
    if (a2)
      v6 = "running";
    v9 = 136446210;
    v10 = v6;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "Motion fence set to %{public}s", &v9, 12);
    v8 = (uint8_t *)v7;
    sub_100512490("Generic", 1, 0, 2, "void CLMicroLocationSensorsLogic::State::setMotionSessionState(BOOL)", "%s\n", v7);
    if (v8 != buf)
      free(v8);
  }
  *(_BYTE *)(a1 + 162) = a2;
}

void sub_10035B6B8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)a1 = off_102130E20;
  sub_1002BBFAC(a1 + 8);
  *(_BYTE *)(a1 + 145) = 2;
  *(_BYTE *)(a1 + 152) = 0;
  *(_BYTE *)(a1 + 160) = 0;
  *(_WORD *)(a1 + 168) = 0;
  *(_BYTE *)(a1 + 170) = 0;
  sub_10031F08C((_BYTE *)(a1 + 176), (uint64_t)&byte_102311440);
  *(_WORD *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 288) = 0xFFEFFFFFFFFFFFFFLL;
  *(_BYTE *)(a1 + 296) = 0;
  *(_QWORD *)(a1 + 304) = a2;
  *(_QWORD *)(a1 + 312) = a3;
  sub_10031CCEC(a1 + 320, a1);
}

void sub_10035BA84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,uint64_t a23,uint64_t a24)
{
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  sub_100261F44((uint64_t)&a22);
  sub_1003649B0(v26 + 816);
  a24 = v26 + 784;
  sub_100364928((void ***)&a24);
  sub_10035BB84(v28);
  sub_10035BB84(v27);
  sub_1003648B8((void ***)&a24);
  sub_10031F214(v25);
  sub_10035BBC0(v24);
  _Unwind_Resume(a1);
}

void sub_10035BB6C()
{
  JUMPOUT(0x10035BB54);
}

uint64_t sub_10035BB84(uint64_t a1)
{
  if (*(char *)(a1 + 55) < 0)
    operator delete(*(void **)(a1 + 32));
  sub_100364238(a1 + 8, *(_QWORD **)(a1 + 16));
  return a1;
}

uint64_t sub_10035BBC0(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 256) && *(char *)(a1 + 199) < 0)
    operator delete(*(void **)(a1 + 176));
  return sub_1002DF2E0(a1);
}

uint64_t sub_10035BBFC(uint64_t a1)
{
  NSObject *v2;
  const char *v4;
  uint8_t *v5;
  _WORD v6[8];
  uint8_t buf[8];

  *(_QWORD *)a1 = off_102130E20;
  if (*(_BYTE *)(a1 + 808) == 1 || *(_BYTE *)(a1 + 809) == 1)
  {
    sub_10031E2E0(a1 + 320);
    *(_WORD *)(a1 + 808) = 0;
  }
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130EE8);
  v2 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "CLMicroLocationSensorsLogic: DTOR", buf, 2u);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130EE8);
    v6[0] = 0;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "CLMicroLocationSensorsLogic: DTOR", v6, 2);
    v5 = (uint8_t *)v4;
    sub_100512490("Generic", 1, 0, 2, "virtual CLMicroLocationSensorsLogic::~CLMicroLocationSensorsLogic()", "%s\n", v4);
    if (v5 != buf)
      free(v5);
  }
  sub_1003649B0(a1 + 816);
  *(_QWORD *)buf = a1 + 784;
  sub_100364928((void ***)buf);
  if (*(char *)(a1 + 767) < 0)
    operator delete(*(void **)(a1 + 744));
  sub_100364238(a1 + 720, *(_QWORD **)(a1 + 728));
  if (*(char *)(a1 + 703) < 0)
    operator delete(*(void **)(a1 + 680));
  sub_100364238(a1 + 656, *(_QWORD **)(a1 + 664));
  *(_QWORD *)buf = a1 + 608;
  sub_1003648B8((void ***)buf);
  sub_10031F214(a1 + 320);
  if (*(_BYTE *)(a1 + 264) && *(char *)(a1 + 207) < 0)
    operator delete(*(void **)(a1 + 184));
  sub_1002DF2E0(a1 + 8);
  return a1;
}

void sub_10035BE48(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  sub_10024F88C(a1);
}

void sub_10035BE58(uint64_t a1)
{
  sub_10035BBFC(a1);
  operator delete();
}

uint64_t sub_10035BE7C(uint64_t a1)
{
  return sub_10031D5AC(a1 + 320);
}

uint64_t sub_10035BE84(_BYTE *a1)
{
  NSObject *v2;
  int v3;
  uint64_t result;
  const char *v5;
  uint8_t *v6;
  _WORD v7[8];
  uint8_t buf[1640];

  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130EE8);
  v2 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "cancel a requested Ble and WiFi scan", buf, 2u);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130EE8);
    v7[0] = 0;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "cancel a requested Ble and WiFi scan", v7, 2);
    v6 = (uint8_t *)v5;
    sub_100512490("Generic", 1, 0, 2, "void CLMicroLocationSensorsLogic::onRecordingOrLocalizingInterrupted()", "%s\n", v5);
    if (v6 != buf)
      free(v6);
  }
  if (a1[809] == 1)
  {
    v3 = a1[808];
    sub_10031E2E0((uint64_t)(a1 + 320));
    *((_WORD *)a1 + 404) = 0;
    if (v3 == 2)
      sub_10035C060((uint64_t)a1);
  }
  result = sub_10031D464((uint64_t)(a1 + 320));
  if (a1[296])
  {
    result = sub_10031E75C((uint64_t)(a1 + 320));
    a1[296] = 0;
  }
  return result;
}

void sub_10035C060(uint64_t a1)
{
  char v2;
  __n128 v3;
  uint64_t v4;
  _QWORD v5[3];
  _BYTE v6[16];
  uint64_t v7;
  uint64_t v8;
  __n128 *v9;

  v2 = sub_10035CB1C(a1);
  memset(v5, 0, sizeof(v5));
  sub_100364A90(v5, *(id **)(a1 + 784), *(id **)(a1 + 792), (uint64_t)(*(_QWORD *)(a1 + 792) - *(_QWORD *)(a1 + 784)) >> 3);
  v3 = 0uLL;
  v4 = 0;
  sub_1002EC7DC((uint64_t)v6, 0, 1, v2, (uint64_t)v5, &v3, 0.0);
  v9 = &v3;
  sub_100259608((void ***)&v9);
  v9 = (__n128 *)v5;
  sub_100364928((void ***)&v9);
  sub_10035CDF4(a1, (uint64_t)v6);
  v9 = (__n128 *)&v8;
  sub_100259608((void ***)&v9);
  v9 = (__n128 *)&v7;
  sub_100364928((void ***)&v9);
}

void sub_10035C12C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  sub_10035D0EC((uint64_t)va);
  _Unwind_Resume(a1);
}

_QWORD *sub_10035C160(_QWORD *result, void *a2, uint64_t a3)
{
  _QWORD *v5;

  if (a2)
  {
    v5 = result;
    objc_msgSend(a2, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", (uint64_t)(v5[99] - v5[98]) >> 3), CFSTR("BleIdentitiesFamilyCount"));
    objc_msgSend(a2, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v5[105]), CFSTR("BleIdentitiesSameAccountCount"));
    objc_msgSend(a2, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v5[105] + ((uint64_t)(v5[99] - v5[98]) >> 3)), CFSTR("BleIdentitiesTotal"));
    return objc_msgSend(a2, "setObject:forKeyedSubscript:", +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", a3), CFSTR("BleIsScanRequested"));
  }
  return result;
}

void sub_10035C230(uint64_t a1, _QWORD *a2)
{
  CFStringRef v3;
  int v4;
  int v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  std::__shared_weak_count *v12;

  *(_QWORD *)(a1 + 872) = *a2;
  sub_1001E4804(&v11);
  v10 = 0;
  v3 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsBleActiveScanRate", 0x8000100u, kCFAllocatorNull);
  v4 = sub_1001C1194(v11, (uint64_t)v3, &v10);
  CFRelease(v3);
  v5 = v10;
  v6 = v12;
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  if (v4)
    v9 = v5;
  else
    v9 = 40;
  *(_DWORD *)(a1 + 880) = v9;
}

void sub_10035C304(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  unint64_t *p_shared_owners;
  unint64_t v14;

  if (a12)
  {
    p_shared_owners = (unint64_t *)&a12->__shared_owners_;
    do
      v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))a12->__on_zero_shared)(a12);
      std::__shared_weak_count::__release_weak(a12);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_10035C34C(uint64_t a1)
{
  uint64_t *v2;
  _QWORD *v3;
  _BYTE v4[16];
  void *v5;
  void *v6;
  void *__p;
  char v8;

  v2 = (uint64_t *)sub_10031EF3C(a1 + 320);
  sub_100278210((uint64_t)v4, v2);
  v3 = (_QWORD *)sub_10033E05C((uint64_t)v4);
  *(double *)(a1 + 864) = *(double *)(a1 + 864) + (double)(unint64_t)((uint64_t)(v3[1] - *v3) >> 2) * 0.11;
  if (v8 < 0)
    operator delete(__p);
  if (v5)
  {
    v6 = v5;
    operator delete(v5);
  }
}

void sub_10035C3D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_10027740C((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_10035C3E8(_QWORD *a1, uint64_t a2, char a3, uint64_t *a4, void *a5)
{
  uint64_t v9;
  NSObject *v10;
  void *p_p;
  uint64_t v12;
  CFStringRef v13;
  char v14;
  int v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  char v19;
  CFStringRef v20;
  int v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  CFStringRef v26;
  int v27;
  void *v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  double v32;
  _QWORD *v33;
  char *v34;
  CFStringRef v35;
  int v36;
  double v37;
  std::__shared_weak_count *v38;
  unint64_t *p_shared_owners;
  unint64_t v40;
  char v41;
  int v42;
  CFStringRef v43;
  char v44;
  int v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  char v49;
  uint64_t v50;
  __n128 v51;
  uint64_t v52;
  void *v53[3];
  void *__p;
  __int128 *v55;
  uint64_t v56;
  void **i;
  std::__shared_weak_count *v58;
  double v59;
  uint8_t buf[8];
  _BYTE v61[20];
  __int16 v62;
  uint64_t v63;
  uint64_t v64;

  sub_1002E0BA0((uint64_t)(a1 + 1), a2);
  *((_BYTE *)a1 + 144) = a3;
  *((_BYTE *)a1 + 145) = 0;
  v9 = *a4;
  if (!*((_BYTE *)a1 + 160))
    *((_BYTE *)a1 + 160) = 1;
  a1[19] = v9;
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130EE8);
  v10 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    sub_1002EC7C4(a3, &__p);
    if (!*((_BYTE *)a1 + 160))
      sub_10028DF3C();
    p_p = &__p;
    if (v56 < 0)
      p_p = __p;
    v12 = a1[19];
    *(_DWORD *)buf = 68289538;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)v61 = 2082;
    *(_QWORD *)&v61[2] = "";
    *(_WORD *)&v61[10] = 2082;
    *(_QWORD *)&v61[12] = p_p;
    v62 = 2050;
    v63 = v12;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"SensorsLogic, started activity\", \"ActivityType\":%{public, location:escape_only}s, \"recOrLocStartTime_s\":\"%{public}.09f\"}", buf, 0x26u);
    if (SHIBYTE(v56) < 0)
      operator delete(__p);
  }
  sub_1001E4804(buf);
  LOBYTE(__p) = 0;
  v13 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsUwbRangeRequestedUpdateRateEnabled", 0x8000100u, kCFAllocatorNull);
  v14 = sub_1001E48E4(*(uint64_t *)buf, (uint64_t)v13, (BOOL *)&__p);
  CFRelease(v13);
  v15 = __p;
  v16 = *(std::__shared_weak_count **)v61;
  if (*(_QWORD *)v61)
  {
    v17 = (unint64_t *)(*(_QWORD *)v61 + 8);
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  if (v15)
    v19 = 0;
  else
    v19 = v14;
  if ((v19 & 1) == 0)
  {
    sub_1001E4804(buf);
    LODWORD(__p) = 0;
    v20 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsUwbRangeRequestedUpdateRate", 0x8000100u, kCFAllocatorNull);
    v21 = sub_1001C1194(*(uint64_t *)buf, (uint64_t)v20, &__p);
    CFRelease(v20);
    v22 = (int)__p;
    v23 = *(std::__shared_weak_count **)v61;
    if (*(_QWORD *)v61)
    {
      v24 = (unint64_t *)(*(_QWORD *)v61 + 8);
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }
    if (!v21)
      v22 = 1;
    sub_1001E4804(buf);
    *(double *)&__p = 0.0;
    v26 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsUwbRangeRequestedUpdateDuration", 0x8000100u, kCFAllocatorNull);
    v27 = sub_1001FD9FC(*(uint64_t *)buf, (uint64_t)v26, &__p);
    CFRelease(v26);
    v28 = __p;
    v29 = *(std::__shared_weak_count **)v61;
    if (*(_QWORD *)v61)
    {
      v30 = (unint64_t *)(*(_QWORD *)v61 + 8);
      do
        v31 = __ldaxr(v30);
      while (__stlxr(v31 - 1, v30));
      if (!v31)
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
    }
    v32 = 2.5;
    if (v27)
      v32 = *(double *)&v28;
    *(_QWORD *)buf = v22;
    *(double *)v61 = v32;
    sub_10031E648((uint64_t)(a1 + 40), (uint64_t *)buf);
    *((_BYTE *)a1 + 296) = 1;
  }
  *(double *)&__p = 0.0;
  v55 = 0;
  v33 = (_QWORD *)a1[104];
  v56 = 0;
  for (i = &__p; v33; v33 = (_QWORD *)*v33)
  {
    v34 = (char *)operator new(0x28uLL);
    *(_QWORD *)buf = v34;
    *(_OWORD *)v61 = xmmword_101B97FF0;
    *(_OWORD *)v34 = 0u;
    *((_OWORD *)v34 + 1) = 0u;
    *(_QWORD *)(v34 + 29) = 0;
    sub_100261F9C((uint64_t)(v33 + 2), v34);
    sub_1002EB978((uint64_t **)&i, (__int128 *)buf);
    if ((v61[15] & 0x80000000) != 0)
      operator delete(*(void **)buf);
  }
  sub_1001E4804(&i);
  v59 = 0.0;
  v35 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsBleRequestedScanLength", 0x8000100u, kCFAllocatorNull);
  v36 = sub_1001FD9FC((uint64_t)i, (uint64_t)v35, &v59);
  CFRelease(v35);
  v37 = v59;
  v38 = v58;
  if (v58)
  {
    p_shared_owners = (unint64_t *)&v58->__shared_owners_;
    do
      v40 = __ldaxr(p_shared_owners);
    while (__stlxr(v40 - 1, p_shared_owners));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }
  if (!v36)
    v37 = 1.6;
  v41 = sub_10035CB1C((uint64_t)a1);
  memset(v53, 0, sizeof(v53));
  sub_100364A90(v53, (id *)a1[98], (id *)a1[99], (uint64_t)(a1[99] - a1[98]) >> 3);
  v51 = 0uLL;
  v52 = 0;
  sub_100259B94((char *)&v51, (__int128 *)__p, v55, 0xAAAAAAAAAAAAAAABLL * (((char *)v55 - (_BYTE *)__p) >> 3));
  sub_1002EC7DC((uint64_t)buf, a3, 0, v41, (uint64_t)v53, &v51, v37);
  i = (void **)&v51;
  sub_100259608(&i);
  i = v53;
  sub_100364928(&i);
  v42 = *((unsigned __int8 *)a1 + 808);
  sub_1001E4804(&i);
  LOBYTE(v59) = 0;
  v43 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsBleRequestedScanEnabled", 0x8000100u, kCFAllocatorNull);
  v44 = sub_1001E48E4((uint64_t)i, (uint64_t)v43, (BOOL *)&v59);
  CFRelease(v43);
  v45 = LOBYTE(v59);
  v46 = v58;
  if (v58)
  {
    v47 = (unint64_t *)&v58->__shared_owners_;
    do
      v48 = __ldaxr(v47);
    while (__stlxr(v48 - 1, v47));
    if (!v48)
    {
      ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
      std::__shared_weak_count::__release_weak(v46);
    }
  }
  if (v45)
    v49 = 0;
  else
    v49 = v44;
  if ((v49 & 1) != 0 || !sub_10035CB1C((uint64_t)a1) && __p == v55)
  {
    sub_10035CC58((uint64_t)a1, v42 == 1);
    (*(void (**)(_QWORD *))(*a1 + 64))(a1);
    v50 = 0;
  }
  else
  {
    sub_10031E2E0((uint64_t)(a1 + 40));
    *((_WORD *)a1 + 404) = 0;
    sub_10035CC58((uint64_t)a1, v42 == 1);
    sub_10035CDF4((uint64_t)a1, (uint64_t)buf);
    v50 = 1;
  }
  sub_10035C160(a1, a5, v50);
  i = (void **)&v64;
  sub_100259608(&i);
  i = (void **)&v61[8];
  sub_100364928(&i);
  *(_QWORD *)buf = &__p;
  sub_100259608((void ***)buf);
}

void sub_10035CA30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  sub_100261F44((uint64_t)&a26);
  _Unwind_Resume(a1);
}

BOOL sub_10035CB1C(uint64_t a1)
{
  _BOOL8 v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  _DWORD v7[2];
  __int16 v8;
  const char *v9;
  __int16 v10;
  _BOOL4 v11;
  __int16 v12;
  uint64_t v13;
  __int16 v14;
  uint64_t v15;

  v2 = *(_QWORD *)(a1 + 784) != *(_QWORD *)(a1 + 792) && *(_BYTE *)(a1 + 170) != 0;
  if (qword_1022A00F0 != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130EE8);
  v3 = qword_1022A00F8;
  if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
  {
    v4 = (uint64_t)(*(_QWORD *)(a1 + 792) - *(_QWORD *)(a1 + 784)) >> 3;
    v5 = *(unsigned __int8 *)(a1 + 170);
    v7[0] = 68289794;
    v7[1] = 0;
    v8 = 2082;
    v9 = "";
    v10 = 1026;
    v11 = v2;
    v12 = 2050;
    v13 = v4;
    v14 = 2050;
    v15 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"SensorsLogic, shouldScanNearbyInfoV2\", \"should scan?\":%{public}hhd, \"num of entries in oObkey\":%{public}lu, \"is motion session running?\":%{public}lu}", (uint8_t *)v7, 0x2Cu);
  }
  return v2;
}

void sub_10035CC58(uint64_t a1, int a2)
{
  NSObject *v3;
  const char *v4;
  uint8_t *v5;
  _WORD v6[8];
  uint8_t buf[1640];

  if (a2)
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130EE8);
    v3 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "setting BLE background-scan session status to paused", buf, 2u);
    }
    if (sub_1001BFF7C(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130EE8);
      v6[0] = 0;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "setting BLE background-scan session status to paused", v6, 2);
      v5 = (uint8_t *)v4;
      sub_100512490("Generic", 1, 0, 2, "void CLMicroLocationSensorsLogic::pauseBackgroundBleSessionIfNeeded(const BOOL)", "%s\n", v4);
      if (v5 != buf)
        free(v5);
    }
    *(_BYTE *)(a1 + 808) = 2;
  }
}

uint64_t sub_10035CDF4(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  NSObject *v5;
  const char *v7;
  uint8_t *v8;
  const char *v9;
  uint8_t *v10;
  _WORD v11[8];
  uint8_t buf[1640];

  if (*(_BYTE *)(a2 + 9))
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130EE8);
    v4 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Register for BLE background-scan session", buf, 2u);
    }
    if (sub_1001BFF7C(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130EE8);
      v11[0] = 0;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "Register for BLE background-scan session", v11, 2);
      v8 = (uint8_t *)v7;
      sub_100512490("Generic", 1, 0, 2, "void CLMicroLocationSensorsLogic::startBleRssiSession(const CLMicroLocationUtils::BleScanConfiguration &)", "%s\n", v7);
      if (v8 != buf)
        free(v8);
    }
    *(_BYTE *)(a1 + 808) = 1;
  }
  else
  {
    sub_10035C230(a1, (_QWORD *)a2);
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130EE8);
    v5 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Register for BLE initiated-scan session", buf, 2u);
    }
    if (sub_1001BFF7C(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130EE8);
      v11[0] = 0;
      _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, qword_1022A00F8, 0, "Register for BLE initiated-scan session", v11, 2);
      v10 = (uint8_t *)v9;
      sub_100512490("Generic", 1, 0, 2, "void CLMicroLocationSensorsLogic::startBleRssiSession(const CLMicroLocationUtils::BleScanConfiguration &)", "%s\n", v9);
      if (v10 != buf)
        free(v10);
    }
    *(_BYTE *)(a1 + 809) = 1;
  }
  return sub_10031E11C(a1 + 320, a2);
}

uint64_t sub_10035D0EC(uint64_t a1)
{
  void **v3;

  v3 = (void **)(a1 + 40);
  sub_100259608(&v3);
  v3 = (void **)(a1 + 16);
  sub_100364928(&v3);
  return a1;
}

void sub_10035D134(uint64_t a1)
{
  void **v2[3];
  uint64_t v3[3];
  void ***v4;

  if (*(_BYTE *)(a1 + 296))
  {
    sub_10031E75C(a1 + 320);
    *(_BYTE *)(a1 + 296) = 0;
  }
  sub_10035D200(a1, v3);
  sub_10037E1EC(*(uint64_t **)(a1 + 304), v3);
  sub_10035E1B8(a1, (uint64_t *)v2);
  sub_10037E1EC(*(uint64_t **)(a1 + 304), (uint64_t *)v2);
  if (*(_BYTE *)(a1 + 160))
    *(_BYTE *)(a1 + 160) = 0;
  v4 = v2;
  sub_1002A1A78((void ***)&v4);
  v2[0] = (void **)v3;
  sub_1002A1A78(v2);
}

void sub_10035D1CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, char a13)
{
  uint64_t v13;
  uint64_t v14;

  *(_QWORD *)(v14 - 24) = v13;
  sub_1002A1A78((void ***)(v14 - 24));
  a10 = (void **)&a13;
  sub_1002A1A78(&a10);
  _Unwind_Resume(a1);
}

void sub_10035D200(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  double Current;
  double v5;
  double v6;
  double v7;
  uint64_t *v8;
  uint64_t *v9;
  double v10;
  NSObject *v11;
  unint64_t v12;
  double v13;
  NSObject *v14;
  NSObject *v15;
  NSObject *v16;
  CFStringRef v17;
  double v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  double v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  double v26;
  float v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  uint8x8_t v35;
  unint64_t v36;
  _QWORD *v37;
  _QWORD *v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unsigned __int8 *v47;
  unsigned __int8 *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  unsigned __int8 *v53;
  _QWORD *v54;
  float v55;
  _BOOL4 v56;
  unint64_t v57;
  unint64_t v58;
  int8x8_t prime;
  void *v60;
  void *v61;
  uint64_t v62;
  _QWORD **v63;
  unint64_t v64;
  uint8x8_t v65;
  unint64_t v66;
  uint8x8_t v67;
  uint64_t v68;
  _QWORD *i;
  unint64_t v70;
  _QWORD *v71;
  _QWORD *v72;
  unint64_t v73;
  void *v74;
  _QWORD *v75;
  unint64_t v76;
  uint64_t v77;
  NSObject *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  NSObject *v83;
  uint64_t v84;
  int v85;
  _OWORD *v86;
  const char *v87;
  uint64_t v88;
  uint64_t *v89;
  uint64_t *v90;
  uint64_t v91;
  uint64_t v92;
  const char *v93;
  char *v94;
  uint64_t *v95;
  void *v96;
  __int128 v97;
  void *__p[2];
  __int128 v99;
  float v100;
  uint64_t v101;
  uint64_t v102;
  char v103;
  double v104;
  _BYTE v105[24];
  __int16 v106;
  const char *v107;
  __int16 v108;
  uint64_t *v109;
  __int16 v110;
  uint64_t v111;
  uint8_t v112[17];
  _BYTE buf[28];
  __int16 v114;
  double v115;
  uint64_t v116;

  if (!*(_BYTE *)(a1 + 160))
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130EE8);
    v14 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 68289026;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"CLMicroLocationSensorsLogic::getBleMeasurements, fState.fStartTime is nullopt!\"}", buf, 0x12u);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130EE8);
    }
    v15 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      *(_DWORD *)buf = 68289026;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLMicroLocationSensorsLogic::getBleMeasurements, fState.fStartTime is nullopt!", "{\"msg%{public}.0s\":\"CLMicroLocationSensorsLogic::getBleMeasurements, fState.fStartTime is nullopt!\"}", buf, 0x12u);
    }
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    return;
  }
  Current = j__CFAbsoluteTimeGetCurrent();
  if (!*(_BYTE *)(a1 + 160))
    sub_10028DF3C();
  v5 = Current;
  v6 = Current - *(double *)(a1 + 152);
  sub_10035EC58();
  v104 = 0.0;
  v8 = &qword_1022A0000;
  v9 = &qword_1022A0000;
  if (v6 < v7)
  {
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130EE8);
    v16 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 68289282;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2050;
      *(double *)&buf[20] = v6;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"BLE Scan duration\", \"duration\":\"%{public}.5f\"}", buf, 0x1Cu);
    }
    if (!*(_BYTE *)(a1 + 160))
      sub_10028DF3C();
    sub_1001E4804(buf);
    *(_QWORD *)v105 = 0;
    v17 = CFStringCreateWithCStringNoCopy(0, "MicroLocationsBleScanMaximalAgeForValidityFromScanStart", 0x8000100u, kCFAllocatorNull);
    v12 = sub_1001FD9FC(*(uint64_t *)buf, (uint64_t)v17, v105);
    CFRelease(v17);
    v18 = *(double *)v105;
    v19 = *(std::__shared_weak_count **)&buf[8];
    if (*(_QWORD *)&buf[8])
    {
      v20 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
      do
        v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
    v22 = 1.0;
    if ((_DWORD)v12)
      v22 = v18;
    v13 = *(double *)(a1 + 152) - v22;
  }
  else
  {
    v10 = v7;
    if (qword_1022A00F0 != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130EE8);
    v11 = qword_1022A00F8;
    if (os_log_type_enabled((os_log_t)qword_1022A00F8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 68289538;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2050;
      *(double *)&buf[20] = v6;
      v114 = 2050;
      v115 = v10;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Scan duration is exceeded threshold\", \"duration\":\"%{public}.5f\", \"threshold\":\"%{public}.5f\"}", buf, 0x26u);
      if (qword_1022A00F0 != -1)
        dispatch_once(&qword_1022A00F0, &stru_102130EE8);
    }
    v12 = qword_1022A00F8;
    if (os_signpost_enabled((os_log_t)qword_1022A00F8))
    {
      *(_DWORD *)buf = 68289538;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2050;
      *(double *)&buf[20] = v6;
      v114 = 2050;
      v115 = v10;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, (os_log_t)v12, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Scan duration is exceeded threshold", "{\"msg%{public}.0s\":\"Scan duration is exceeded threshold\", \"duration\":\"%{public}.5f\", \"threshold\":\"%{public}.5f\"}", buf, 0x26u);
    }
    v13 = v5 - v10;
  }
  v104 = v13;
  v103 = 0;
  sub_10035ED34(a1 + 648, &v104, &v103, &v101);
  *(_OWORD *)__p = 0u;
  v99 = 0u;
  v100 = 1.0;
  v23 = v101;
  v24 = v102;
  v95 = a2;
  if (v101 == v102)
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    goto LABEL_162;
  }
  do
  {
    if ((*(_BYTE *)(v23 + 72) & 0x40) == 0)
      goto LABEL_143;
    v25 = *(_QWORD *)(v23 + 48);
    if (!v25)
      v25 = *(_QWORD *)(qword_102310298 + 48);
    v26 = *(double *)(v25 + 8);
    v27 = *(float *)(v25 + 20);
    v28 = sub_100115F1C((uint64_t)v105, *(char **)(v25 + 48));
    v29 = 0xC6A4A7935BD1E995 * LODWORD(v27);
    if (v27 == 0.0)
      v29 = 0;
    v30 = 0xC6A4A7935BD1E995 * (v29 ^ (v29 >> 47));
    v31 = 0xC6A4A7935BD1E995 * *(_QWORD *)&v26;
    if (v26 == 0.0)
      v31 = 0;
    v32 = (0xC6A4A7935BD1E995 * (v30 ^ (0x35A98F4D286A90B9 * (v31 ^ (v31 >> 47)) + 3864292196u)) + 3864292196u) ^ (0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v28) ^ ((0xC6A4A7935BD1E995 * v28) >> 47)));
    v33 = 0xC6A4A7935BD1E995 * v32 + 3864292196u;
    v34 = (unint64_t)__p[1];
    if (__p[1])
    {
      v35 = (uint8x8_t)vcnt_s8((int8x8_t)__p[1]);
      v35.i16[0] = vaddlv_u8(v35);
      v36 = v35.u32[0];
      if (v35.u32[0] > 1uLL)
      {
        v12 = 0xC6A4A7935BD1E995 * v32 + 3864292196u;
        if ((void *)v33 >= __p[1])
          v12 = v33 % (unint64_t)__p[1];
      }
      else
      {
        v12 = ((unint64_t)__p[1] - 1) & v33;
      }
      v37 = (_QWORD *)*((_QWORD *)__p[0] + v12);
      if (v37)
      {
        v38 = (_QWORD *)*v37;
        if (*v37)
        {
          v39 = qword_102310298;
          while (1)
          {
            v40 = v38[1];
            if (v40 == v33)
              break;
            if (v36 > 1)
            {
              if ((void *)v40 >= __p[1])
                v40 %= (unint64_t)__p[1];
            }
            else
            {
              v40 &= (unint64_t)__p[1] - 1;
            }
            if (v40 != v12)
              goto LABEL_87;
LABEL_81:
            v38 = (_QWORD *)*v38;
            if (!v38)
              goto LABEL_87;
          }
          v41 = *(_QWORD *)(v38[2] + 48);
          v42 = v41;
          if (!v41)
            v42 = *(_QWORD *)(v39 + 48);
          v43 = *(_QWORD *)(v23 + 48);
          v44 = v43;
          if (!v43)
            v44 = *(_QWORD *)(v39 + 48);
          if (*(double *)(v42 + 8) != *(double *)(v44 + 8))
            goto LABEL_81;
          v45 = *(_QWORD *)(v38[2] + 48);
          if (!v41)
            v45 = *(_QWORD *)(v39 + 48);
          v46 = *(_QWORD *)(v23 + 48);
          if (!v43)
            v46 = *(_QWORD *)(v39 + 48);
          if (*(float *)(v45 + 20) != *(float *)(v46 + 20))
            goto LABEL_81;
          if (v41)
          {
            if (v43)
              goto LABEL_62;
          }
          else
          {
            v41 = *(_QWORD *)(v39 + 48);
            if (v43)
              goto LABEL_62;
          }
          v43 = *(_QWORD *)(v39 + 48);
LABEL_62:
          v47 = *(unsigned __int8 **)(v41 + 48);
          v48 = *(unsigned __int8 **)(v43 + 48);
          v49 = v47[23];
          if ((v49 & 0x80u) == 0)
            v50 = v47[23];
          else
            v50 = *((_QWORD *)v47 + 1);
          v51 = v48[23];
          v52 = (char)v51;
          if ((v51 & 0x80u) != 0)
            v51 = *((_QWORD *)v48 + 1);
          if (v50 == v51)
          {
            if (v52 >= 0)
              v53 = v48;
            else
              v53 = *(unsigned __int8 **)v48;
            if ((v49 & 0x80) != 0)
            {
              if (!memcmp(*(const void **)v47, v53, *((_QWORD *)v47 + 1)))
                goto LABEL_143;
            }
            else
            {
              if (!v47[23])
                goto LABEL_143;
              while (*v47 == *v53)
              {
                ++v47;
                ++v53;
                if (!--v49)
                  goto LABEL_143;
              }
            }
          }
          goto LABEL_81;
        }
      }
    }
LABEL_87:
    v54 = operator new(0x18uLL);
    *v54 = 0;
    v54[1] = v33;
    v54[2] = v23;
    v55 = (float)(unint64_t)(*((_QWORD *)&v99 + 1) + 1);
    if (!v34 || (float)(v100 * (float)v34) < v55)
    {
      v56 = (v34 & (v34 - 1)) == 0;
      if (v34 < 3)
        v56 = 0;
      v57 = (2 * v34) | !v56;
      v58 = vcvtps_u32_f32(v55 / v100);
      if (v57 <= v58)
        prime = (int8x8_t)v58;
      else
        prime = (int8x8_t)v57;
      if (*(_QWORD *)&prime == 1)
      {
        prime = (int8x8_t)2;
      }
      else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
      {
        prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
        v34 = (unint64_t)__p[1];
      }
      if (*(_QWORD *)&prime > v34)
        goto LABEL_99;
      if (*(_QWORD *)&prime < v34)
      {
        v66 = vcvtps_u32_f32((float)*((unint64_t *)&v99 + 1) / v100);
        if (v34 < 3 || (v67 = (uint8x8_t)vcnt_s8((int8x8_t)v34), v67.i16[0] = vaddlv_u8(v67), v67.u32[0] > 1uLL))
        {
          v66 = std::__next_prime(v66);
        }
        else
        {
          v68 = 1 << -(char)__clz(v66 - 1);
          if (v66 >= 2)
            v66 = v68;
        }
        if (*(_QWORD *)&prime <= v66)
          prime = (int8x8_t)v66;
        if (*(_QWORD *)&prime >= v34)
        {
          v34 = (unint64_t)__p[1];
        }
        else
        {
          if (prime)
          {
LABEL_99:
            if (*(_QWORD *)&prime >> 61)
              sub_10025955C();
            v60 = operator new(8 * *(_QWORD *)&prime);
            v61 = __p[0];
            __p[0] = v60;
            if (v61)
              operator delete(v61);
            v62 = 0;
            __p[1] = (void *)prime;
            do
              *((_QWORD *)__p[0] + v62++) = 0;
            while (*(_QWORD *)&prime != v62);
            v63 = (_QWORD **)v99;
            if ((_QWORD)v99)
            {
              v64 = *(_QWORD *)(v99 + 8);
              v65 = (uint8x8_t)vcnt_s8(prime);
              v65.i16[0] = vaddlv_u8(v65);
              if (v65.u32[0] > 1uLL)
              {
                if (v64 >= *(_QWORD *)&prime)
                  v64 %= *(_QWORD *)&prime;
              }
              else
              {
                v64 &= *(_QWORD *)&prime - 1;
              }
              *((_QWORD *)__p[0] + v64) = &v99;
              for (i = *v63; i; v64 = v70)
              {
                v70 = i[1];
                if (v65.u32[0] > 1uLL)
                {
                  if (v70 >= *(_QWORD *)&prime)
                    v70 %= *(_QWORD *)&prime;
                }
                else
                {
                  v70 &= *(_QWORD *)&prime - 1;
                }
                if (v70 != v64)
                {
                  if (!*((_QWORD *)__p[0] + v70))
                  {
                    *((_QWORD *)__p[0] + v70) = v63;
                    goto LABEL_124;
                  }
                  *v63 = (_QWORD *)*i;
                  *i = **((_QWORD **)__p[0] + v70);
                  **((_QWORD **)__p[0] + v70) = i;
                  i = v63;
                }
                v70 = v64;
LABEL_124:
                v63 = (_QWORD **)i;
                i = (_QWORD *)*i;
              }
            }
            v34 = (unint64_t)prime;
            goto LABEL_128;
          }
          v74 = __p[0];
          __p[0] = 0;
          if (v74)
            operator delete(v74);
          v34 = 0;
          __p[1] = 0;
        }
      }
LABEL_128:
      if ((v34 & (v34 - 1)) != 0)
      {
        if (v33 >= v34)
          v12 = v33 % v34;
        else
          v12 = v33;
      }
      else
      {
        v12 = (v34 - 1) & v33;
      }
    }
    v71 = __p[0];
    v72 = (_QWORD *)*((_QWORD *)__p[0] + v12);
    if (v72)
    {
      *v54 = *v72;
LABEL_141:
      *v72 = v54;
      goto LABEL_142;
    }
    *v54 = v99;
    *(_QWORD *)&v99 = v54;
    v71[v12] = &v99;
    if (*v54)
    {
      v73 = *(_QWORD *)(*v54 + 8);
      if ((v34 & (v34 - 1)) != 0)
      {
        if (v73 >= v34)
          v73 %= v34;
      }
      else
      {
        v73 &= v34 - 1;
      }
      v72 = (char *)__p[0] + 8 * v73;
      goto LABEL_141;
    }
LABEL_142:
    ++*((_QWORD *)&v99 + 1);
LABEL_143:
    v23 += 80;
  }
  while (v23 != v24);
  v75 = (_QWORD *)v99;
  a2 = v95;
  v95[1] = 0;
  v95[2] = 0;
  *v95 = 0;
  v9 = &qword_1022A0000;
  v8 = &qword_1022A0000;
  if (v75)
  {
    v76 = 0;
    do
    {
      v77 = v75[2];
      if (v76 >= v95[2])
      {
        v76 = sub_100364FBC(v95, v77);
      }
      else
      {
        sub_1002C0A54(v76, v77);
        *(_DWORD *)(v76 + 80) = 0;
        v76 += 88;
        v95[1] = v76;
      }
      v95[1] = v76;
      v75 = (_QWORD *)*v75;
    }
    while (v75);
  }
LABEL_162:
  if (v8[30] != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130EE8);
  v78 = v9[31];
  if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
  {
    v79 = 0x2E8BA2E8BA2E8BA3 * ((a2[1] - *a2) >> 3);
    *(_DWORD *)buf = 134218240;
    *(_QWORD *)&buf[4] = 0xCCCCCCCCCCCCCCCDLL * ((v102 - v101) >> 4);
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = v79;
    _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_DEFAULT, "Read BLE spyscan buffer in Logic!. read %lu measurements (%lu unique)", buf, 0x16u);
  }
  if (sub_1001BFF7C(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (v8[30] != -1)
      dispatch_once(&qword_1022A00F0, &stru_102130EE8);
    v91 = v9[31];
    v92 = 0x2E8BA2E8BA2E8BA3 * ((a2[1] - *a2) >> 3);
    *(_DWORD *)v105 = 134218240;
    *(_QWORD *)&v105[4] = 0xCCCCCCCCCCCCCCCDLL * ((v102 - v101) >> 4);
    *(_WORD *)&v105[12] = 2048;
    *(_QWORD *)&v105[14] = v92;
    _os_log_send_and_compose_impl(2, 0, buf, 1628, &_mh_execute_header, v91, 0, "Read BLE spyscan buffer in Logic!. read %lu measurements (%lu unique)", v105, 22);
    v94 = (char *)v93;
    sub_100512490("Generic", 1, 0, 2, "std::vector<CLMiLoProtobufWrapper::Measurement> CLMicroLocationSensorsLogic::getBleMeasurements()", "%s\n", v93);
    if (v94 != buf)
      free(v94);
  }
  if (v8[30] != -1)
    dispatch_once(&qword_1022A00F0, &stru_102130EE8);
  if (os_log_type_enabled((os_log_t)v9[31], OS_LOG_TYPE_DEBUG))
  {
    v80 = *v95;
    v81 = v95[1];
    if (*v95 != v81)
    {
      do
      {
        sub_1002C0A54(buf, v80);
        v82 = v116;
        if (!v116)
          v82 = *(_QWORD *)(qword_102310298 + 48);
        sub_10035777C(*(uint64_t ***)(v82 + 48), v112);
        if (qword_1022A0100 != -1)
          dispatch_once(&qword_1022A0100, &stru_102130F08);
        v83 = qword_1022A0108;
        if (os_log_type_enabled((os_log_t)qword_1022A0108, OS_LOG_TYPE_DEBUG))
        {
          v84 = v116;
          if (!v116)
            v84 = *(_QWORD *)(qword_102310298 + 48);
          v85 = (int)*(float *)(v84 + 20);
          if (v112[16])
          {
            v86 = operator new(0x28uLL);
            v96 = v86;
            v97 = xmmword_101B97FF0;
            *v86 = 0u;
            v86[1] = 0u;
            *(_QWORD *)((char *)v86 + 29) = 0;
            sub_100261F9C((uint64_t)v112, v86);
            v87 = (const char *)&v96;
            if (v97 < 0)
              v87 = (const char *)v96;
            v88 = v116;
            if (!v116)
              v88 = *(_QWORD *)(qword_102310298 + 48);
            v89 = *(uint64_t **)(v88 + 40);
            if (*((char *)v89 + 23) < 0)
              v89 = (uint64_t *)*v89;
            *(_DWORD *)v105 = 68290051;
            *(_DWORD *)&v105[4] = 0;
            *(_WORD *)&v105[8] = 2082;
            *(_QWORD *)&v105[10] = "";
            *(_WORD *)&v105[18] = 1025;
            *(_DWORD *)&v105[20] = v85;
            v106 = 2081;
            v107 = v87;
            v108 = 2081;
            v109 = v89;
            v110 = 2050;
            v111 = *(_QWORD *)&buf[8];
            _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"BLE cached scan\", \"rssi\":%{private}d, \"uuid\":%{private, location:escape_only}s, \"model\":%{private, location:escape_only}s, \"time_s\":\"%{public}.09f\"}", v105, 0x36u);
            if (SHIBYTE(v97) < 0)
              operator delete(v96);
          }
          else
          {
            v90 = *(uint64_t **)(v84 + 40);
            if (*((char *)v90 + 23) < 0)
              v90 = (uint64_t *)*v90;
            *(_DWORD *)v105 = 68290051;
            *(_DWORD *)&v105[4] = 0;
            *(_WORD *)&v105[8] = 2082;
            *(_QWORD *)&v105[10] = "";
            *(_WORD *)&v105[18] = 1025;
            *(_DWORD *)&v105[20] = v85;
            v106 = 2081;
            v107 = "not available";
            v108 = 2081;
            v109 = v90;
            v110 = 2050;
            v111 = *(_QWORD *)&buf[8];
            _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"BLE cached scan\", \"rssi\":%{private}d, \"uuid\":%{private, location:escape_only}s, \"model\":%{private, location:escape_only}s, \"time_s\":\"%{public}.09f\"}", v105, 0x36u);
          }
        }
        sub_1002C0B04((wireless_diagnostics::google::protobuf::MessageLite *)buf);
        v80 += 88;
      }
      while (v80 != v81);
    }
  }
  if (v103)
  {
    sub_1015A2E04(buf, "BLE spyscan buffer overflow");
    sub_10038AA2C((uint64_t *)buf);
    if ((buf[23] & 0x80000000) != 0)
      operator delete(*(void **)buf);
  }
  sub_100067AC4((uint64_t)__p);
  *(_QWORD *)buf = &v101;
  sub_100364F30((void ***)buf);
}

