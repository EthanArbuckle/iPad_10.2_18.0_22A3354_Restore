void llvm::APIntOps::GreatestCommonDivisor(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  _DWORD *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  int v11;
  int64_t v12;
  BOOL v13;
  unint64_t v14;
  int v15;
  int v16;
  int64_t v17;
  unint64_t v18;
  int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  char *v25;
  unint64_t v26;
  unsigned int v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  _BOOL4 v36;
  unint64_t v37;
  unint64_t v38;
  llvm::APInt *v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  _BOOL4 v45;
  unint64_t v46;

  v6 = (_DWORD *)(a1 + 8);
  v7 = *(unsigned int *)(a1 + 8);
  if (v7 > 0x40)
  {
    v8 = *(_QWORD *)a1;
    v9 = *(_QWORD *)a2;
    if (memcmp(*(const void **)a1, *(const void **)a2, ((unint64_t)(v7 + 63) >> 3) & 0x3FFFFFF8))
    {
      v11 = 0;
      v12 = (unint64_t)(v7 + 63) >> 6;
      do
      {
        v13 = v12-- < 1;
        if (v13)
          break;
        v14 = *(_QWORD *)(v8 + 8 * v12);
        v11 += __clz(v14);
      }
      while (!v14);
      v15 = v7 | 0xFFFFFFC0;
      if ((v7 & 0x3F) == 0)
        v15 = 0;
      if (v11 + v15 != (_DWORD)v7)
        goto LABEL_4;
      goto LABEL_14;
    }
LABEL_21:
    *(_DWORD *)(a3 + 8) = v7;
    goto LABEL_22;
  }
  v8 = *(_QWORD *)a1;
  v9 = *(_QWORD *)a2;
  if (*(_QWORD *)a1 == *(_QWORD *)a2)
    goto LABEL_21;
  if (v8)
  {
LABEL_4:
    v10 = *(unsigned int *)(a2 + 8);
    if (v10 > 0x40)
    {
      v16 = 0;
      v17 = (unint64_t)(v10 + 63) >> 6;
      do
      {
        v13 = v17-- < 1;
        if (v13)
          break;
        v18 = *(_QWORD *)(v9 + 8 * v17);
        v16 += __clz(v18);
      }
      while (!v18);
      v19 = v10 | 0xFFFFFFC0;
      if ((v10 & 0x3F) == 0)
        v19 = 0;
      if (v16 + v19 == (_DWORD)v10)
        goto LABEL_21;
    }
    else if (!v9)
    {
      goto LABEL_21;
    }
    v20 = sub_1C5DC82B8(a1);
    v21 = sub_1C5DC82B8(a2);
    v22 = v21;
    v23 = v20 - v21;
    if (v20 <= v21)
    {
      v24 = v21 - v20;
      if (v21 > v20)
      {
        if (v10 > 0x40)
        {
          llvm::APInt::tcShiftRight((llvm::APInt *)v9, (unint64_t *)((unint64_t)(v10 + 63) >> 6), v24);
        }
        else if ((_DWORD)v10 == v24)
        {
          *(_QWORD *)a2 = 0;
        }
        else
        {
          *(_QWORD *)a2 = v9 >> v24;
        }
      }
      v22 = v20;
    }
    else if (v7 > 0x40)
    {
      llvm::APInt::tcShiftRight((llvm::APInt *)v8, (unint64_t *)((unint64_t)(v7 + 63) >> 6), v23);
    }
    else if ((_DWORD)v7 == v23)
    {
      *(_QWORD *)a1 = 0;
    }
    else
    {
      *(_QWORD *)a1 = v8 >> v23;
    }
    while (1)
    {
      v7 = *v6;
      if (v7 > 0x40)
        break;
      v8 = *(_QWORD *)a1;
      v25 = *(char **)a2;
      if (*(_QWORD *)a1 == *(_QWORD *)a2)
        goto LABEL_21;
      if (*(_QWORD *)a1 <= *(_QWORD *)a2)
      {
LABEL_56:
        v7 = *(unsigned int *)(a2 + 8);
        if (v7 >= 0x41)
        {
          v40 = 0;
          v41 = (unint64_t)(v7 + 63) >> 6;
          v42 = v41;
          do
          {
            v43 = *(_QWORD *)v8;
            v8 += 8;
            v44 = *(_QWORD *)v25 - v43;
            v45 = *(_QWORD *)v25 < v43;
            v46 = *(_QWORD *)v25 + ~v43;
            if (v40)
            {
              v40 = v46 >= *(_QWORD *)v25;
            }
            else
            {
              v46 = v44;
              v40 = v45;
            }
            *(_QWORD *)v25 = v46;
            v25 += 8;
            --v42;
          }
          while (v42);
          *(_QWORD *)(*(_QWORD *)a2 + 8 * (v41 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v7;
          v7 = *(unsigned int *)(a2 + 8);
          v27 = sub_1C5DC82B8(a2) - v22;
          if (v7 <= 0x40)
            goto LABEL_60;
          v39 = *(llvm::APInt **)a2;
LABEL_65:
          llvm::APInt::tcShiftRight(v39, (unint64_t *)((unint64_t)(v7 + 63) >> 6), v27);
        }
        else
        {
          v38 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v7;
          if (!(_DWORD)v7)
            v38 = 0;
          *(_QWORD *)a2 = v38 & (unint64_t)&v25[-v8];
          v27 = sub_1C5DC82B8(a2) - v22;
LABEL_60:
          if ((_DWORD)v7 == v27)
            *(_QWORD *)a2 = 0;
          else
            *(_QWORD *)a2 >>= v27;
        }
      }
      else
      {
        v26 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v7;
        if (!(_DWORD)v7)
          v26 = 0;
        *(_QWORD *)a1 = v26 & (*(_QWORD *)a1 - *(_QWORD *)a2);
        v27 = sub_1C5DC82B8(a1) - v22;
LABEL_42:
        if ((_DWORD)v7 == v27)
          *(_QWORD *)a1 = 0;
        else
          *(_QWORD *)a1 >>= v27;
      }
    }
    v8 = *(_QWORD *)a1;
    v28 = v7 + 63;
    v25 = *(char **)a2;
    if (!memcmp(*(const void **)a1, *(const void **)a2, ((unint64_t)(v7 + 63) >> 3) & 0x3FFFFFF8))
      goto LABEL_21;
    v29 = 8 * (v28 >> 6);
    while (v29)
    {
      v30 = *(_QWORD *)(v8 + v29 - 8);
      v31 = *(_QWORD *)&v25[v29 - 8];
      v29 -= 8;
      if (v30 != v31)
      {
        if (v30 <= v31)
          goto LABEL_56;
        v32 = 0;
        v33 = v28 >> 6;
        do
        {
          v34 = *(_QWORD *)v25;
          v25 += 8;
          v35 = *(_QWORD *)v8 - v34;
          v36 = *(_QWORD *)v8 < v34;
          v37 = *(_QWORD *)v8 + ~v34;
          if (v32)
          {
            v32 = v37 >= *(_QWORD *)v8;
          }
          else
          {
            v37 = v35;
            v32 = v36;
          }
          *(_QWORD *)v8 = v37;
          v8 += 8;
          --v33;
        }
        while (v33);
        *(_QWORD *)(*(_QWORD *)a1 + 8 * ((v28 >> 6) - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v7;
        v7 = *(unsigned int *)(a1 + 8);
        v27 = sub_1C5DC82B8(a1) - v22;
        if (v7 > 0x40)
        {
          v39 = *(llvm::APInt **)a1;
          goto LABEL_65;
        }
        goto LABEL_42;
      }
    }
    goto LABEL_56;
  }
LABEL_14:
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a2 + 8);
  v8 = v9;
  v6 = (_DWORD *)(a2 + 8);
LABEL_22:
  *(_QWORD *)a3 = v8;
  *v6 = 0;
}

uint64_t sub_1C5DC82B8(uint64_t a1)
{
  uint64_t v1;
  unsigned int v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  v1 = *(unsigned int *)(a1 + 8);
  if (v1 >= 0x41)
  {
    v3 = 0;
    v4 = (unint64_t)(v1 + 63) >> 6;
    v5 = *(unint64_t **)a1;
    v2 = (_DWORD)v4 << 6;
    v6 = v4 << 6;
    while (!*v5)
    {
      ++v5;
      v3 += 64;
      if (v6 == v3)
        goto LABEL_8;
    }
    v2 = __clz(__rbit64(*v5)) + v3;
  }
  else
  {
    v2 = __clz(__rbit64(*(_QWORD *)a1));
  }
LABEL_8:
  if (v1 >= v2)
    return v2;
  else
    return v1;
}

llvm::APInt *llvm::APIntOps::RoundDoubleToAPInt@<X0>(llvm::APIntOps *this@<X0>, double a2@<D0>, llvm::APInt *a3@<X8>)
{
  unsigned int v3;
  unint64_t v6;
  llvm::APInt *v7;
  uint64_t v8;
  unint64_t v9;
  llvm::APInt *result;
  unsigned int v11;
  unint64_t v12;
  unint64_t v13;
  void *v14;
  size_t v15;
  void *v16;
  unsigned int v17;
  void *__src;
  unsigned int v19;
  unint64_t v20;
  unsigned int v21;

  v3 = this;
  v6 = (*(_QWORD *)&a2 >> 52) & 0x7FFLL;
  if (v6 <= 0x3FE)
    goto LABEL_2;
  v9 = *(_QWORD *)&a2 & 0xFFFFFFFFFFFFFLL | 0x10000000000000;
  if (v6 > 0x432)
  {
    if (v6 - 1075 >= this)
    {
LABEL_2:
      v7 = a3;
      v8 = 0;
      return sub_1C4832EA4(v7, v3, v8, 0);
    }
    sub_1C4832EA4((llvm::APInt *)&__src, this, v9, 0);
    result = (llvm::APInt *)sub_1C4888094((uint64_t)&__src, (int)v6 - 1075);
    v11 = v19;
    if ((*(_QWORD *)&a2 & 0x8000000000000000) != 0)
    {
      v17 = v19;
      if (v19 > 0x40)
      {
        v15 = (((unint64_t)v19 + 63) >> 3) & 0x3FFFFFF8;
        v16 = (void *)operator new[]();
        memcpy(v16, __src, v15);
        llvm::APInt::flipAllBitsSlowCase((uint64_t)&v16);
      }
      else
      {
        if (v19)
          v13 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v19;
        else
          v13 = 0;
        v16 = (void *)(v13 & ~(unint64_t)__src);
      }
      result = (llvm::APInt *)llvm::APInt::operator++((uint64_t)&v16);
      *((_DWORD *)a3 + 2) = v17;
      *(_QWORD *)a3 = v16;
      v17 = 0;
    }
    else
    {
      *((_DWORD *)a3 + 2) = v19;
      if (v11 > 0x40)
      {
        v14 = (void *)operator new[]();
        *(_QWORD *)a3 = v14;
        result = (llvm::APInt *)memcpy(v14, __src, (((unint64_t)*((unsigned int *)a3 + 2) + 63) >> 3) & 0x3FFFFFF8);
      }
      else
      {
        *(_QWORD *)a3 = __src;
      }
    }
    if (v19 >= 0x41)
    {
      result = (llvm::APInt *)__src;
      if (__src)
        return (llvm::APInt *)MEMORY[0x1CAA32F9C](__src, 0x1000C8000313F17);
    }
  }
  else
  {
    v8 = v9 >> (51 - (*(_QWORD *)&a2 >> 52));
    if ((*(_QWORD *)&a2 & 0x8000000000000000) == 0)
    {
      v7 = a3;
      return sub_1C4832EA4(v7, v3, v8, 0);
    }
    sub_1C4832EA4((llvm::APInt *)&v20, this, v8, 0);
    if (v21 > 0x40)
    {
      llvm::APInt::flipAllBitsSlowCase((uint64_t)&v20);
    }
    else
    {
      if (v21)
        v12 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v21;
      else
        v12 = 0;
      v20 = v12 & ~v20;
    }
    result = (llvm::APInt *)llvm::APInt::operator++((uint64_t)&v20);
    *((_DWORD *)a3 + 2) = v21;
    *(_QWORD *)a3 = v20;
  }
  return result;
}

double llvm::APInt::roundToDouble(llvm::APInt *this, int a2)
{
  llvm::APInt *v3;
  uint64_t v4;
  unsigned int v5;
  double v6;
  unsigned int v7;
  unint64_t v8;
  unint64_t v9;
  int v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  unint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  BOOL v20;
  unint64_t v21;
  void *v23;
  unsigned int v24;

  v3 = this;
  LODWORD(v4) = *((_DWORD *)this + 2);
  if (v4 < 0x41 || (v5 = v4 - sub_1C5DCDAB0((uint64_t)this), v4 = *((unsigned int *)v3 + 2), v5 <= 0x40))
  {
    if (a2)
    {
      if (v4 >= 0x41)
        v3 = *(llvm::APInt **)v3;
      return (double)((uint64_t)(*(_QWORD *)v3 << -(char)v4) >> -(char)v4);
    }
    else
    {
      if (v4 >= 0x41)
        v3 = *(llvm::APInt **)v3;
      return (double)*(unint64_t *)v3;
    }
  }
  if (a2)
  {
    v7 = v4 - 1;
    if (v4 <= 0x40)
    {
      v8 = *(_QWORD *)v3;
      if (((*(_QWORD *)v3 >> v7) & 1) == 0)
      {
        v10 = 0;
        goto LABEL_31;
      }
      v24 = *((_DWORD *)v3 + 2);
      v9 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v4;
      if (!(_DWORD)v4)
        v9 = 0;
      v23 = (void *)(v9 & ~v8);
      goto LABEL_20;
    }
    if (((*(_QWORD *)(*(_QWORD *)v3 + 8 * (v7 >> 6)) >> v7) & 1) != 0)
    {
      v24 = *((_DWORD *)v3 + 2);
      v23 = (void *)operator new[]();
      memcpy(v23, *(const void **)v3, ((unint64_t)(v4 + 63) >> 3) & 0x3FFFFFF8);
      llvm::APInt::flipAllBitsSlowCase((uint64_t)&v23);
LABEL_20:
      llvm::APInt::operator++((uint64_t)&v23);
      v4 = v24;
      v8 = (unint64_t)v23;
      v24 = 0;
      if (v4 < 0x41)
      {
        v10 = 1;
        goto LABEL_31;
      }
      v11 = v4 + 63;
      v10 = 1;
LABEL_24:
      v12 = 0;
      v13 = v11 >> 6;
      do
      {
        if (v13-- < 1)
          break;
        v15 = *(_QWORD *)(v8 + 8 * v13);
        v12 += __clz(v15);
      }
      while (!v15);
      v16 = v4 | 0xFFFFFFC0;
      if ((v4 & 0x3F) == 0)
        v16 = 0;
      v17 = v12 + v16;
      goto LABEL_32;
    }
LABEL_22:
    v11 = v4 + 63;
    v8 = operator new[]();
    memcpy((void *)v8, *(const void **)v3, ((unint64_t)(v4 + 63) >> 3) & 0x3FFFFFF8);
    v10 = 0;
    goto LABEL_24;
  }
  if (v4 > 0x40)
    goto LABEL_22;
  v10 = 0;
  v8 = *(_QWORD *)v3;
LABEL_31:
  v17 = v4 + __clz(v8) - 64;
LABEL_32:
  v18 = (v4 - v17);
  if (v18 < 0x400)
  {
    if ((v18 - 1) > 0x3F)
    {
      v19 = (*(_QWORD *)(v8 + 8 * (((v18 - 1) >> 6) - 1)) >> ((v18 & 0x3Fu) + 11)) | (*(_QWORD *)(v8 + 8 * ((v18 - 1) >> 6)) << (52 - (v18 & 0x3Fu)));
    }
    else
    {
      v19 = *(_QWORD *)v8;
      if (v18 >= 0x35)
        v19 = *(_QWORD *)v8 >> (v18 - 52);
    }
    v20 = v10 == 0;
    v21 = 0x8000000000000000;
    if (v20)
      v21 = 0;
    *(_QWORD *)&v6 = v19 | v21 | ((v18 << 52) + 0x3FF0000000000000);
  }
  else if ((v10 & a2) != 0)
  {
    v6 = -INFINITY;
  }
  else
  {
    v6 = INFINITY;
  }
  if (v4 >= 0x41 && v8)
    MEMORY[0x1CAA32F9C](v8, 0x1000C8000313F17);
  return v6;
}

llvm::APInt *llvm::APInt::trunc@<X0>(llvm::APInt *this@<X0>, unsigned int a2@<W1>, llvm::APInt *a3@<X8>)
{
  uint64_t *v4;
  unsigned int v6;
  llvm::APInt *result;
  uint64_t v8;
  int v9;

  v4 = (uint64_t *)this;
  v6 = *((_DWORD *)this + 2);
  if (a2 > 0x40)
  {
    if (v6 == a2)
    {
      return (llvm::APInt *)sub_1C5DD14E0((uint64_t)a3, (uint64_t)this);
    }
    else
    {
      result = (llvm::APInt *)operator new[]();
      v8 = 0;
      *((_DWORD *)a3 + 2) = a2;
      *(_QWORD *)a3 = result;
      do
      {
        *(_QWORD *)(*(_QWORD *)a3 + v8) = *(_QWORD *)(*v4 + v8);
        v8 += 8;
      }
      while (8 * (a2 >> 6) != v8);
      v9 = -a2 & 0x3F;
      if (v9)
        *(_QWORD *)(*(_QWORD *)a3 + 8 * (a2 >> 6)) = *(_QWORD *)(*v4 + 8 * (a2 >> 6)) & (0xFFFFFFFFFFFFFFFFLL >> v9);
    }
  }
  else
  {
    if (v6 >= 0x41)
      v4 = *(uint64_t **)this;
    return sub_1C4832EA4(a3, a2, *v4, 0);
  }
  return result;
}

llvm::APInt *llvm::APInt::truncUSat@<X0>(llvm::APInt *this@<X0>, unsigned int a2@<W1>, llvm::APInt *a3@<X8>)
{
  int v6;

  v6 = *((_DWORD *)this + 2);
  if (v6 - sub_1C5DCDAB0((uint64_t)this) <= a2)
    return llvm::APInt::trunc(this, a2, a3);
  else
    return sub_1C4832EA4(a3, a2, -1, 1);
}

llvm::APInt *llvm::APInt::truncSSat@<X0>(llvm::APInt *this@<X0>, unsigned int a2@<W1>, llvm::APInt *a3@<X8>)
{
  llvm::APInt *v4;
  int v6;
  unsigned int v7;
  unsigned int v8;
  unint64_t v9;
  unsigned int v10;
  llvm::APInt *result;
  uint64_t v12;

  v4 = this;
  v6 = *((_DWORD *)this + 2);
  if (v6 - sub_1C4959174(this) + 1 <= a2)
    return llvm::APInt::trunc(v4, a2, a3);
  v7 = *((_DWORD *)v4 + 2);
  v8 = v7 - 1;
  if (v7 >= 0x41)
    v4 = (llvm::APInt *)(*(_QWORD *)v4 + 8 * (v8 >> 6));
  v9 = *(_QWORD *)v4;
  v10 = a2 - 1;
  if (((v9 >> v8) & 1) != 0)
  {
    result = sub_1C4832EA4(a3, a2, 0, 0);
    if (*((_DWORD *)a3 + 2) >= 0x41u)
      a3 = (llvm::APInt *)(*(_QWORD *)a3 + 8 * (v10 >> 6));
    v12 = *(_QWORD *)a3 | (1 << v10);
  }
  else
  {
    result = sub_1C4832EA4(a3, a2, -1, 1);
    if (*((_DWORD *)a3 + 2) >= 0x41u)
      a3 = (llvm::APInt *)(*(_QWORD *)a3 + 8 * (v10 >> 6));
    v12 = *(_QWORD *)a3 & ~(1 << v10);
  }
  *(_QWORD *)a3 = v12;
  return result;
}

llvm::APInt *llvm::APInt::sext@<X0>(llvm::APInt *this@<X0>, unsigned int a2@<W1>, llvm::APInt *a3@<X8>)
{
  llvm::APInt *v4;
  llvm::APInt *result;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  llvm::APInt *v11;
  unint64_t v12;
  unsigned int v13;
  int v14;

  v4 = this;
  if (a2 <= 0x40)
    return sub_1C4832EA4(a3, a2, (uint64_t)(*(_QWORD *)this << -*((_BYTE *)this + 8)) >> -*((_BYTE *)this + 8), 0);
  if (*((_DWORD *)this + 2) == a2)
    return (llvm::APInt *)sub_1C5DD14E0((uint64_t)a3, (uint64_t)this);
  v7 = a2 + 63;
  v8 = (_QWORD *)operator new[]();
  v9 = v8;
  *((_DWORD *)a3 + 2) = a2;
  *(_QWORD *)a3 = v8;
  v10 = *((unsigned int *)v4 + 2);
  v11 = v4;
  if (v10 >= 0x41)
    v11 = *(llvm::APInt **)v4;
  memcpy(v8, v11, ((unint64_t)(v10 + 63) >> 3) & 0x3FFFFFF8);
  v12 = (unint64_t)(v10 + 63) >> 6;
  v9[(v12 - 1)] = (uint64_t)(v9[(v12 - 1)] << -(char)v10) >> -(char)v10;
  v13 = v10 - 1;
  if (v10 >= 0x41)
    v4 = (llvm::APInt *)(*(_QWORD *)v4 + 8 * (v13 >> 6));
  if (((*(_QWORD *)v4 >> v13) & 1) != 0)
    v14 = -1;
  else
    v14 = 0;
  result = (llvm::APInt *)memset(&v9[v12], v14, 8 * ((v7 >> 6) - v12));
  v9[(v7 >> 6) - 1] &= 0xFFFFFFFFFFFFFFFFLL >> -(char)a2;
  return result;
}

void llvm::APInt::zext(llvm::APInt *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  llvm::APInt *v4;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  char *v9;
  char *v10;
  uint64_t v11;
  unint64_t v12;

  v4 = this;
  if (a2 > 0x40)
  {
    if (*((_DWORD *)this + 2) == a2)
    {
      sub_1C5DD14E0(a3, (uint64_t)this);
    }
    else
    {
      v8 = a2 + 63;
      v9 = (char *)operator new[]();
      v10 = v9;
      *(_DWORD *)(a3 + 8) = a2;
      *(_QWORD *)a3 = v9;
      v11 = *((unsigned int *)v4 + 2);
      if (v11 >= 0x41)
        v4 = *(llvm::APInt **)v4;
      v12 = v11 + 63;
      memcpy(v9, v4, ((unint64_t)(v11 + 63) >> 3) & 0x3FFFFFF8);
      bzero(&v10[8 * (v12 >> 6)], 8 * ((v8 >> 6) - (v12 >> 6)));
    }
  }
  else
  {
    v6 = *(_QWORD *)this;
    *(_DWORD *)(a3 + 8) = a2;
    v7 = 0xFFFFFFFFFFFFFFFFLL >> -(char)a2;
    if (!a2)
      v7 = 0;
    *(_QWORD *)a3 = v7 & v6;
  }
}

void llvm::APInt::zextOrTrunc(llvm::APInt *this@<X0>, unsigned int a2@<W1>, llvm::APInt *a3@<X8>)
{
  unsigned int v3;

  v3 = *((_DWORD *)this + 2);
  if (v3 >= a2)
  {
    if (v3 > a2)
      llvm::APInt::trunc(this, a2, a3);
    else
      sub_1C5DD14E0((uint64_t)a3, (uint64_t)this);
  }
  else
  {
    llvm::APInt::zext(this, a2, (uint64_t)a3);
  }
}

llvm::APInt *llvm::APInt::sextOrTrunc@<X0>(llvm::APInt *this@<X0>, unsigned int a2@<W1>, llvm::APInt *a3@<X8>)
{
  unsigned int v3;

  v3 = *((_DWORD *)this + 2);
  if (v3 < a2)
    return llvm::APInt::sext(this, a2, a3);
  if (v3 > a2)
    return llvm::APInt::trunc(this, a2, a3);
  return (llvm::APInt *)sub_1C5DD14E0((uint64_t)a3, (uint64_t)this);
}

llvm::APInt *llvm::APInt::sextOrSelf@<X0>(llvm::APInt *this@<X0>, unsigned int a2@<W1>, llvm::APInt *a3@<X8>)
{
  if (*((_DWORD *)this + 2) < a2)
    return llvm::APInt::sext(this, a2, a3);
  else
    return (llvm::APInt *)sub_1C5DD14E0((uint64_t)a3, (uint64_t)this);
}

uint64_t *llvm::APInt::ashrInPlace(llvm::APInt *this, uint64_t ***a2)
{
  uint64_t *result;
  unsigned int v4;
  char v5;
  uint64_t v6;
  unint64_t v7;

  result = sub_1C47EE5B8(a2, *((unsigned int *)this + 2));
  v4 = *((_DWORD *)this + 2);
  if (v4 > 0x40)
    return (uint64_t *)llvm::APInt::ashrSlowCase((unsigned int *)this, result);
  v5 = (char)result;
  if (v4 == (_DWORD)result)
    v5 = 63;
  v6 = (uint64_t)(*(_QWORD *)this << -(char)v4) >> -(char)v4 >> v5;
  if (v4)
    v7 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v4;
  else
    v7 = 0;
  *(_QWORD *)this = v7 & v6;
  return result;
}

unsigned int *llvm::APInt::ashrSlowCase(unsigned int *this, unsigned int a2)
{
  unsigned int *v2;
  uint64_t v3;
  unsigned int v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned int v7;
  unint64_t v8;
  unsigned int v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  unint64_t v16;

  if (a2)
  {
    v2 = this;
    v3 = this[2];
    v4 = v3 - 1;
    v5 = this;
    if (v3 >= 0x41)
      v5 = (_QWORD *)(*(_QWORD *)this + 8 * (v4 >> 6));
    v6 = *v5 & (1 << v4);
    v7 = a2 >> 6;
    v8 = (unint64_t)(v3 + 63) >> 6;
    v9 = v8 - (a2 >> 6);
    if ((_DWORD)v8 != a2 >> 6)
    {
      v10 = (v8 - 1);
      *(_QWORD *)(*(_QWORD *)this + 8 * v10) = (uint64_t)(*(_QWORD *)(*(_QWORD *)this
                                                                                   + 8 * v10) << -(char)v3) >> -(char)v3;
      v11 = a2 & 0x3F;
      if ((a2 & 0x3F) != 0)
      {
        v12 = v9 - 1;
        if (v9 == 1)
        {
          v12 = 0;
        }
        else
        {
          v13 = 0;
          do
          {
            *(_QWORD *)(*(_QWORD *)this + 8 * v13) = (*(_QWORD *)(*(_QWORD *)this
                                                                + 8 * ((a2 >> 6) + v13 + 1)) << (64 - v11)) | (*(_QWORD *)(*(_QWORD *)this + 8 * ((a2 >> 6) + v13)) >> v11);
            ++v13;
          }
          while (v12 != v13);
        }
        *(_QWORD *)(*(_QWORD *)this + 8 * v12) = *(_QWORD *)(*(_QWORD *)this + 8 * v10) >> v11;
        *(_QWORD *)(*(_QWORD *)this + 8 * v12) = (uint64_t)(*(_QWORD *)(*(_QWORD *)this + 8 * v12) << v11) >> v11;
      }
      else
      {
        memmove(*(void **)this, (const void *)(*(_QWORD *)this + 8 * v7), 8 * v9);
      }
    }
    if (v6)
      v14 = -1;
    else
      v14 = 0;
    this = (unsigned int *)memset((void *)(*(_QWORD *)v2 + 8 * v9), v14, 8 * v7);
    v15 = v2[2];
    if ((_DWORD)v15)
    {
      v16 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v15;
      if (v15 >= 0x41)
        v2 = (unsigned int *)(*(_QWORD *)v2 + 8 * (((unint64_t)(v15 + 63) >> 6) - 1));
    }
    else
    {
      v16 = 0;
    }
    *(_QWORD *)v2 &= v16;
  }
  return this;
}

void llvm::APInt::lshrInPlace(llvm::APInt **this, uint64_t ***a2)
{
  unsigned int v3;
  uint64_t v4;

  v3 = sub_1C47EE5B8(a2, *((unsigned int *)this + 2));
  v4 = *((unsigned int *)this + 2);
  if (v4 > 0x40)
  {
    llvm::APInt::tcShiftRight(*this, (unint64_t *)((unint64_t)(v4 + 63) >> 6), v3);
  }
  else if ((_DWORD)v4 == v3)
  {
    *this = 0;
  }
  else
  {
    *this = (llvm::APInt *)((unint64_t)*this >> v3);
  }
}

void llvm::APInt::lshrSlowCase(llvm::APInt **this, unsigned int a2)
{
  llvm::APInt::tcShiftRight(*this, (unint64_t *)(((unint64_t)*((unsigned int *)this + 2) + 63) >> 6), a2);
}

void llvm::APInt::tcShiftRight(llvm::APInt *this, unint64_t *a2, unsigned int a3)
{
  unsigned int v4;
  uint64_t v5;
  char v6;
  uint64_t v7;
  unsigned int v8;
  _QWORD *v9;
  uint64_t v10;

  if (a3)
  {
    if (a3 >> 6 >= a2)
      v4 = a2;
    else
      v4 = a3 >> 6;
    v5 = a2 - v4;
    v6 = a3 & 0x3F;
    if ((a3 & 0x3F) != 0)
    {
      if (a3 >> 6 < a2)
      {
        v7 = *((_QWORD *)this + v4) >> v6;
        *(_QWORD *)this = v7;
        if ((_DWORD)v5 != 1)
        {
          v8 = v4 + 1;
          v9 = (_QWORD *)((char *)this + 8);
          v10 = 1 - v5;
          do
          {
            *(v9 - 1) = (*((_QWORD *)this + v8) << (64 - v6)) | v7;
            v7 = *((_QWORD *)this + v8) >> v6;
            *v9++ = v7;
            ++v8;
          }
          while (!__CFADD__(v10++, 1));
        }
      }
    }
    else
    {
      memmove(this, (char *)this + 8 * v4, (8 * v5));
    }
    bzero((char *)this + 8 * v5, 8 * v4);
  }
}

uint64_t llvm::APInt::operator<<=(uint64_t a1, uint64_t ***this)
{
  unsigned int v3;

  v3 = sub_1C47EE5B8(this, *(unsigned int *)(a1 + 8));
  sub_1C4888094(a1, v3);
  return a1;
}

void llvm::APInt::shlSlowCase(llvm::APInt **this, unsigned int a2)
{
  llvm::APInt **v2;
  uint64_t v3;
  unint64_t v4;

  v2 = this;
  llvm::APInt::tcShiftLeft(*this, (unint64_t *)(((unint64_t)*((unsigned int *)this + 2) + 63) >> 6), a2);
  v3 = *((unsigned int *)v2 + 2);
  v4 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v3;
  if (v3 <= 0x40)
  {
    if (!(_DWORD)v3)
      v4 = 0;
  }
  else
  {
    v2 = (llvm::APInt **)((char *)*v2 + 8 * ((unint64_t)(v3 + 63) >> 6) - 8);
  }
  *v2 = (llvm::APInt *)((unint64_t)*v2 & v4);
}

void llvm::APInt::tcShiftLeft(llvm::APInt *this, unint64_t *a2, unsigned int a3)
{
  unsigned int v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  unint64_t *v9;
  _QWORD *v10;
  unint64_t v11;

  if (a3)
  {
    if (a3 >> 6 >= a2)
      v4 = a2;
    else
      v4 = a3 >> 6;
    v5 = a3 & 0x3F;
    if ((a3 & 0x3F) != 0)
    {
      if (a3 >> 6 < a2)
      {
        v6 = a2 - 1;
        v7 = *((_QWORD *)this + v6 - v4) << (a3 & 0x3F);
        v8 = (char *)this + 8 * v6;
        *(_QWORD *)v8 = v7;
        if (v6 > v4)
        {
          v9 = (unint64_t *)((char *)this + 8 * a2 + 8 * (uint64_t)-v4 - 16);
          v10 = (_QWORD *)((char *)this + 8 * ((_DWORD)a2 - 2));
          do
          {
            v11 = *v9--;
            *(_QWORD *)v8 = (v11 >> (64 - v5)) | v7;
            v7 = *((_QWORD *)this + v6 - v4 - 1) << v5;
            v8 = (char *)this + 8 * (v6 - 1);
            *v10-- = v7;
            --v6;
          }
          while (v4 < v6);
        }
      }
    }
    else
    {
      memmove((char *)this + 8 * v4, this, 8 * (a2 - v4));
    }
    bzero(this, 8 * v4);
  }
}

uint64_t *sub_1C5DC9258(uint64_t *a1, const void **this)
{
  uint64_t *v2;
  uint64_t v4;
  void *v5;
  uint64_t v7;
  unsigned int v8;
  uint64_t **v9;
  unsigned int v10;
  uint64_t **v11;
  unsigned int v12;

  v2 = a1;
  if (!(_DWORD)a1)
    return v2;
  v4 = *((unsigned int *)this + 2);
  v12 = v4;
  if (v4 > 0x40)
  {
    v5 = (void *)operator new[]();
    memcpy(v5, *this, ((unint64_t)(v4 + 63) >> 3) & 0x3FFFFFF8);
    v11 = (uint64_t **)v5;
    if (v4 >= v2)
      goto LABEL_8;
    llvm::APInt::zext((llvm::APInt *)this, v2, (uint64_t)&v9);
    MEMORY[0x1CAA32F9C](v5, 0x1000C8000313F17);
  }
  else
  {
    v11 = (uint64_t **)*this;
    if (v4 >= a1)
      goto LABEL_8;
    llvm::APInt::zext((llvm::APInt *)this, a1, (uint64_t)&v9);
  }
  v11 = v9;
  LODWORD(v4) = v10;
  v12 = v10;
LABEL_8:
  sub_1C4832EA4((llvm::APInt *)&v7, v4, v2, 0);
  llvm::APInt::urem((llvm::APInt *)&v11, (const llvm::APInt *)&v7, (llvm::APInt *)&v9);
  if (v12 >= 0x41 && v11)
    MEMORY[0x1CAA32F9C](v11, 0x1000C8000313F17);
  v11 = v9;
  v12 = v10;
  v10 = 0;
  if (v8 >= 0x41 && v7)
    MEMORY[0x1CAA32F9C](v7, 0x1000C8000313F17);
  v2 = sub_1C47EE5B8(&v11, v2);
  if (v12 >= 0x41 && v11)
    MEMORY[0x1CAA32F9C](v11, 0x1000C8000313F17);
  return v2;
}

uint64_t llvm::APInt::rotr@<X0>(llvm::APInt *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t result;
  unsigned int v10;
  unint64_t v11;
  size_t v12;
  _QWORD *v13;
  uint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  unsigned int v20;

  v5 = *((_DWORD *)this + 2);
  if (!v5)
    return sub_1C5DD14E0(a3, (uint64_t)this);
  v6 = a2 % v5;
  if (!(a2 % v5))
    return sub_1C5DD14E0(a3, (uint64_t)this);
  sub_1C5CEB1E4((uint64_t)this, v6, (uint64_t)&v19);
  v7 = *((unsigned int *)this + 2);
  v8 = v7 - v6;
  v18 = *((_DWORD *)this + 2);
  if (v7 > 0x40)
  {
    v12 = ((unint64_t)(v7 + 63) >> 3) & 0x3FFFFFF8;
    v17 = operator new[]();
    memcpy((void *)v17, *(const void **)this, v12);
  }
  else
  {
    v17 = *(_QWORD *)this;
  }
  result = sub_1C4888094((uint64_t)&v17, v8);
  v10 = v18;
  if (v18 > 0x40)
  {
    v13 = (_QWORD *)v17;
    v14 = (uint64_t *)v19;
    v15 = ((unint64_t)v18 + 63) >> 6;
    do
    {
      v16 = *v14++;
      *v13++ |= v16;
      --v15;
    }
    while (v15);
    v11 = v17;
  }
  else
  {
    v11 = v17 | v19;
  }
  *(_DWORD *)(a3 + 8) = v10;
  *(_QWORD *)a3 = v11;
  if (v20 >= 0x41)
  {
    result = v19;
    if (v19)
      return MEMORY[0x1CAA32F9C](v19, 0x1000C8000313F17);
  }
  return result;
}

uint64_t llvm::APInt::nearestLogBase2(llvm::APInt *this)
{
  llvm::APInt *v1;
  uint64_t v2;
  int v4;
  unsigned int v5;
  int v6;
  int64_t v7;
  unint64_t v9;
  int v10;

  v1 = this;
  v2 = *((unsigned int *)this + 2);
  if ((_DWORD)v2 == 1)
    return (*(_DWORD *)this - 1);
  if (v2 > 0x40)
  {
    v6 = 0;
    v7 = (unint64_t)(v2 + 63) >> 6;
    do
    {
      if (v7-- < 1)
        break;
      v9 = *(_QWORD *)(*(_QWORD *)this + 8 * v7);
      v6 += __clz(v9);
    }
    while (!v9);
    v10 = v2 | 0xFFFFFFC0;
    if ((v2 & 0x3F) == 0)
      v10 = 0;
    if (v6 + v10 != (_DWORD)v2)
      goto LABEL_5;
    return 0xFFFFFFFFLL;
  }
  if (!*(_QWORD *)this)
    return 0xFFFFFFFFLL;
LABEL_5:
  v4 = v2 + ~sub_1C5DCDAB0((uint64_t)this);
  v5 = v4 - 1;
  if (*((_DWORD *)v1 + 2) >= 0x41u)
    v1 = (llvm::APInt *)(*(_QWORD *)v1 + 8 * (v5 >> 6));
  return v4 + ((*(_QWORD *)v1 >> v5) & 1);
}

void llvm::APInt::sqrt(llvm::APInt *this@<X0>, llvm::APInt *a2@<X8>)
{
  unsigned int *v2;
  int v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  llvm::APInt *v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  char *v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unsigned int v16;
  unint64_t v17;
  unint64_t *v18;
  BOOL v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t *v24;
  uint64_t *v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  _BOOL4 v30;
  unsigned int v31;
  void *v32;
  unsigned int v33;
  void *v34;
  uint64_t v35;
  char *v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unsigned int v40;
  unint64_t v41;
  void *v42;
  unint64_t v43;
  uint64_t v44;
  unint64_t *v45;
  unint64_t *v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  _BOOL4 v50;
  unint64_t v51;
  uint64_t v52;
  unint64_t v53;
  char *v54;
  uint64_t v55;
  unint64_t v56;
  unint64_t *v57;
  unint64_t *v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  _BOOL4 v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  unint64_t v66;
  void **v67;
  size_t v68;
  void *v69;
  unsigned int v70;
  void *v71;
  unsigned int v72;
  void *v73;
  unsigned int v74;
  char *v75;
  unsigned int v76;
  char *v77;
  unsigned int v78;
  unint64_t *v79;
  unsigned int v80;
  void *__src;
  unsigned int v82;
  char *v83;
  unsigned int v84;
  uint64_t v85;
  unsigned int v86;
  char *v87;
  unsigned int v88;
  char *v89;
  unsigned int v90;
  char *v91;
  unsigned int v92;

  v2 = (unsigned int *)this;
  v4 = *((_DWORD *)this + 2);
  v5 = v4 - sub_1C5DCDAB0((uint64_t)this);
  if (v5 <= 5)
  {
    v6 = v2[2];
    if (v6 >= 0x41)
      v2 = *(unsigned int **)v2;
    v7 = byte_1C866F2A1[*(_QWORD *)v2];
    v8 = a2;
LABEL_9:
    sub_1C4832EA4(v8, v6, v7, 0);
    return;
  }
  v9 = v2[2];
  if (v5 <= 0x33)
  {
    if (v9 >= 0x41)
      v2 = *(unsigned int **)v2;
    v7 = vcvtad_u64_f64(sqrt((double)*(unint64_t *)v2));
    v8 = a2;
    v6 = v9;
    goto LABEL_9;
  }
  sub_1C4832EA4((llvm::APInt *)&v91, v2[2], 16, 0);
  sub_1C4832EA4((llvm::APInt *)&v89, v2[2], 1, 0);
  sub_1C4832EA4((llvm::APInt *)&v87, v2[2], 0, 0);
  sub_1C4832EA4((llvm::APInt *)&v85, v2[2], 2, 0);
  v10 = 4;
  if (v9 >= 5)
  {
    while (1)
    {
      v11 = v2[2];
      if (v11 > 0x40)
        break;
      v12 = v91;
      if (*(_QWORD *)v2 <= (unint64_t)v91)
        goto LABEL_25;
LABEL_18:
      v84 = v92;
      if (v92 > 0x40)
      {
        v83 = (char *)operator new[]();
        memcpy(v83, v91, (((unint64_t)v84 + 63) >> 3) & 0x3FFFFFF8);
      }
      else
      {
        v83 = v12;
      }
      sub_1C4888094((uint64_t)&v83, 2u);
      if (v92 >= 0x41 && v91)
        MEMORY[0x1CAA32F9C](v91, 0x1000C8000313F17);
      v10 += 2;
      v91 = v83;
      v92 = v84;
      if (v10 >= v9)
        goto LABEL_25;
    }
    v12 = v91;
    v13 = ((unint64_t)(v11 + 63) >> 3) & 0x3FFFFFF8;
    while (v13)
    {
      v14 = *(_QWORD *)(*(_QWORD *)v2 - 8 + v13);
      v15 = *(_QWORD *)&v91[v13 - 8];
      v13 -= 8;
      if (v14 != v15)
      {
        if (v14 <= v15)
          break;
        goto LABEL_18;
      }
    }
  }
LABEL_25:
  v84 = v90;
  if (v90 > 0x40)
  {
    v83 = (char *)operator new[]();
    memcpy(v83, v89, (((unint64_t)v84 + 63) >> 3) & 0x3FFFFFF8);
  }
  else
  {
    v83 = v89;
  }
  sub_1C4888094((uint64_t)&v83, v10 >> 1);
  if (v90 >= 0x41 && v89)
    MEMORY[0x1CAA32F9C](v89, 0x1000C8000313F17);
  v89 = v83;
  v90 = v84;
  while (1)
  {
    llvm::APInt::udiv((llvm::APInt *)v2, (const llvm::APInt *)&v89, (llvm::APInt *)&v79);
    v16 = v80;
    if (v80 >= 0x41)
    {
      v23 = 0;
      v24 = v79;
      v25 = (uint64_t *)v89;
      v26 = ((unint64_t)v80 + 63) >> 6;
      v27 = v26;
      do
      {
        v28 = *v25++;
        v29 = v28 + *v24;
        v30 = v29 + 1 <= *v24;
        if (v23)
        {
          ++v29;
          v23 = v30;
        }
        else
        {
          v23 = v29 < *v24;
        }
        *v24++ = v29;
        --v27;
      }
      while (v27);
      v79[(v26 - 1)] &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v16;
      v16 = v80;
      v18 = v79;
    }
    else
    {
      v17 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v80;
      if (!v80)
        v17 = 0;
      v18 = (unint64_t *)(v17 & (unint64_t)&v89[(_QWORD)v79]);
      v79 = v18;
    }
    v82 = v16;
    __src = v18;
    v80 = 0;
    llvm::APInt::udiv((llvm::APInt *)&__src, (const llvm::APInt *)&v85, (llvm::APInt *)&v83);
    if (v88 >= 0x41 && v87)
      MEMORY[0x1CAA32F9C](v87, 0x1000C8000313F17);
    v87 = v83;
    v88 = v84;
    v84 = 0;
    if (v82 >= 0x41 && __src)
      MEMORY[0x1CAA32F9C](__src, 0x1000C8000313F17);
    if (v80 >= 0x41 && v79)
      MEMORY[0x1CAA32F9C](v79, 0x1000C8000313F17);
    if (v90 > 0x40)
      break;
    v19 = v89 > v87;
LABEL_50:
    if (!v19)
      goto LABEL_59;
    sub_1C63817D4((void **)&v89, (uint64_t)&v87);
  }
  v20 = (((unint64_t)v90 + 63) >> 3) & 0x3FFFFFF8;
  while (v20)
  {
    v21 = *(_QWORD *)&v89[v20 - 8];
    v22 = *(_QWORD *)&v87[v20 - 8];
    v20 -= 8;
    v19 = v21 > v22;
    if (v21 != v22)
      goto LABEL_50;
  }
LABEL_59:
  llvm::APInt::operator*((uint64_t)&v89, &v89, (uint64_t)&v83);
  v76 = v90;
  if (v90 > 0x40)
  {
    v75 = (char *)operator new[]();
    memcpy(v75, v89, (((unint64_t)v76 + 63) >> 3) & 0x3FFFFFF8);
  }
  else
  {
    v75 = v89;
  }
  llvm::APInt::operator+=((uint64_t)&v75, 1uLL);
  v31 = v76;
  v78 = v76;
  v32 = v75;
  v77 = v75;
  v76 = 0;
  v72 = v90;
  if (v90 > 0x40)
  {
    v71 = (void *)operator new[]();
    memcpy(v71, v89, (((unint64_t)v72 + 63) >> 3) & 0x3FFFFFF8);
  }
  else
  {
    v71 = v89;
  }
  llvm::APInt::operator+=((uint64_t)&v71, 1uLL);
  v33 = v72;
  v74 = v72;
  v34 = v71;
  v73 = v71;
  v72 = 0;
  llvm::APInt::operator*((uint64_t)&v77, &v73, (uint64_t)&__src);
  if (v33 >= 0x41 && v34)
    MEMORY[0x1CAA32F9C](v34, 0x1000C8000313F17);
  if (v72 >= 0x41 && v71)
    MEMORY[0x1CAA32F9C](v71, 0x1000C8000313F17);
  if (v31 >= 0x41 && v32)
    MEMORY[0x1CAA32F9C](v32, 0x1000C8000313F17);
  if (v76 >= 0x41 && v75)
    MEMORY[0x1CAA32F9C](v75, 0x1000C8000313F17);
  v35 = v2[2];
  if (v35 > 0x40)
  {
    v36 = v83;
    v37 = ((unint64_t)(v35 + 63) >> 3) & 0x3FFFFFF8;
    while (v37)
    {
      v38 = *(_QWORD *)(*(_QWORD *)v2 - 8 + v37);
      v39 = *(_QWORD *)&v83[v37 - 8];
      v37 -= 8;
      if (v38 != v39)
      {
        if (v38 <= v39)
          goto LABEL_88;
        break;
      }
    }
LABEL_84:
    v40 = v82;
    if (v82 >= 0x41)
    {
      v43 = v82 + 63;
      v42 = (void *)operator new[]();
      memcpy(v42, __src, (v43 >> 3) & 0x3FFFFFF8);
      v44 = 0;
      v45 = (unint64_t *)v42;
      v46 = (unint64_t *)v36;
      v47 = v43 >> 6;
      do
      {
        v48 = *v46++;
        v49 = *v45 - v48;
        v50 = *v45 < v48;
        v51 = *v45 + ~v48;
        if (v44)
        {
          v44 = v51 >= *v45;
        }
        else
        {
          v51 = v49;
          v44 = v50;
        }
        *v45++ = v51;
        --v47;
      }
      while (v47);
      *((_QWORD *)v42 + (v43 >> 6) - 1) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v40;
    }
    else
    {
      v41 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v82;
      if (!v82)
        v41 = 0;
      v42 = (void *)(v41 & ((_BYTE *)__src - v36));
    }
    v74 = v40;
    v73 = v42;
    llvm::APInt::udiv((llvm::APInt *)&v73, (const llvm::APInt *)&v85, (llvm::APInt *)&v77);
    if (v74 >= 0x41 && v73)
      MEMORY[0x1CAA32F9C](v73, 0x1000C8000313F17);
    v52 = v2[2];
    if (v52 >= 0x41)
    {
      v54 = (char *)operator new[]();
      memcpy(v54, *(const void **)v2, ((unint64_t)(v52 + 63) >> 3) & 0x3FFFFFF8);
      v55 = 0;
      v56 = (unint64_t)(v52 + 63) >> 6;
      v57 = (unint64_t *)v54;
      v58 = (unint64_t *)v36;
      v59 = v56;
      do
      {
        v60 = *v58++;
        v61 = *v57 - v60;
        v62 = *v57 < v60;
        v63 = *v57 + ~v60;
        if (v55)
        {
          v55 = v63 >= *v57;
        }
        else
        {
          v63 = v61;
          v55 = v62;
        }
        *v57++ = v63;
        --v59;
      }
      while (v59);
      *(_QWORD *)&v54[8 * (v56 - 1)] &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v52;
      v64 = 8 * v56;
      while (v64)
      {
        v65 = *(_QWORD *)&v54[v64 - 8];
        v66 = *(_QWORD *)&v77[v64 - 8];
        v64 -= 8;
        if (v65 != v66)
        {
          if (v65 <= v66)
            goto LABEL_114;
          break;
        }
      }
    }
    else
    {
      v53 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v52;
      if (!(_DWORD)v52)
        v53 = 0;
      v54 = (char *)(v53 & (*(_QWORD *)v2 - (_QWORD)v36));
      if (v54 < v77)
      {
LABEL_114:
        v67 = (void **)&v89;
LABEL_117:
        *((_DWORD *)a2 + 2) = *((_DWORD *)v67 + 2);
        *(_QWORD *)a2 = *v67;
        *((_DWORD *)v67 + 2) = 0;
        if (v52 >= 0x41 && v54)
          MEMORY[0x1CAA32F9C](v54, 0x1000C8000313F17);
        if (v78 >= 0x41 && v77)
          MEMORY[0x1CAA32F9C](v77, 0x1000C8000313F17);
        goto LABEL_123;
      }
    }
    v70 = v90;
    if (v90 > 0x40)
    {
      v68 = (((unint64_t)v90 + 63) >> 3) & 0x3FFFFFF8;
      v69 = (void *)operator new[]();
      memcpy(v69, v89, v68);
    }
    else
    {
      v69 = v89;
    }
    v67 = &v69;
    llvm::APInt::operator+=((uint64_t)&v69, 1uLL);
    goto LABEL_117;
  }
  v36 = v83;
  if (*(_QWORD *)v2 >= (unint64_t)v83)
    goto LABEL_84;
LABEL_88:
  *((_DWORD *)a2 + 2) = v90;
  *(_QWORD *)a2 = v89;
  v90 = 0;
  v40 = v82;
LABEL_123:
  if (v40 >= 0x41 && __src)
    MEMORY[0x1CAA32F9C](__src, 0x1000C8000313F17);
  if (v84 >= 0x41 && v36)
    MEMORY[0x1CAA32F9C](v36, 0x1000C8000313F17);
  if (v86 >= 0x41 && v85)
    MEMORY[0x1CAA32F9C](v85, 0x1000C8000313F17);
  if (v88 >= 0x41 && v87)
    MEMORY[0x1CAA32F9C](v87, 0x1000C8000313F17);
  if (v90 >= 0x41 && v89)
    MEMORY[0x1CAA32F9C](v89, 0x1000C8000313F17);
  if (v92 >= 0x41 && v91)
    MEMORY[0x1CAA32F9C](v91, 0x1000C8000313F17);
}

void llvm::APInt::udiv(llvm::APInt *this@<X0>, const llvm::APInt *a2@<X1>, llvm::APInt *a3@<X8>)
{
  unsigned int v6;
  uint64_t v7;
  llvm::APInt *v8;
  unsigned int v9;
  const unint64_t *v10;
  int v11;
  int v12;
  uint64_t v13;
  const unint64_t *v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t *v22;

  v6 = *((_DWORD *)this + 2);
  if (v6 <= 0x40)
  {
    v7 = *(_QWORD *)this / *(_QWORD *)a2;
    v8 = a3;
    v9 = v6;
LABEL_21:
    sub_1C4832EA4(v8, v9, v7, 0);
    return;
  }
  v10 = (const unint64_t *)(((unint64_t)(v6 - sub_1C5DCDAB0((uint64_t)this)) + 63) >> 6);
  v11 = *((_DWORD *)a2 + 2);
  v12 = sub_1C5DCDAB0((uint64_t)a2);
  if (!(_DWORD)v10)
  {
    v9 = *((_DWORD *)this + 2);
    v8 = a3;
LABEL_20:
    v7 = 0;
    goto LABEL_21;
  }
  v13 = (v11 - v12);
  if ((_DWORD)v13 == 1)
  {
    sub_1C5DD14E0((uint64_t)a3, (uint64_t)this);
    return;
  }
  v14 = (const unint64_t *)((unint64_t)(v13 + 63) >> 6);
  v15 = *((unsigned int *)this + 2);
  if (v10 < v14)
    goto LABEL_19;
  if (v15 > 0x40)
  {
    v16 = *(_QWORD **)this;
    v17 = *(_QWORD **)a2;
    v18 = (unint64_t)(v15 + 63) >> 3;
    v19 = v18 & 0x3FFFFFF8;
    while (v19)
    {
      v20 = *(_QWORD *)((char *)v16 + v19 - 8);
      v21 = *(_QWORD *)((char *)v17 + v19 - 8);
      v19 -= 8;
      if (v20 != v21)
      {
        if (v20 <= v21)
          goto LABEL_19;
        break;
      }
    }
    if (!memcmp(*(const void **)this, *(const void **)a2, v18 & 0x3FFFFFF8))
      goto LABEL_11;
    goto LABEL_17;
  }
  v16 = *(_QWORD **)this;
  v17 = *(_QWORD **)a2;
  if (*(_QWORD *)this < *(_QWORD *)a2)
  {
LABEL_19:
    v8 = a3;
    v9 = *((_DWORD *)this + 2);
    goto LABEL_20;
  }
  if (*(_QWORD *)this == *(_QWORD *)a2)
  {
LABEL_11:
    v8 = a3;
    v9 = v15;
    v7 = 1;
    goto LABEL_21;
  }
LABEL_17:
  if ((_DWORD)v10 == 1)
  {
    v7 = *v16 / *v17;
    v8 = a3;
    v9 = v15;
    goto LABEL_21;
  }
  sub_1C4832EA4(a3, v15, 0, 0);
  llvm::APInt::divide(*(llvm::APInt **)this, v10, *(uint64_t **)a2, v14, *(unint64_t **)a3, 0, v22);
}

uint64_t llvm::APInt::multiplicativeInverse@<X0>(llvm::APInt *this@<X0>, const void **a2@<X1>, llvm::APInt *a3@<X8>)
{
  uint64_t v5;
  void *v6;
  size_t v7;
  uint64_t v8;
  void *v9;
  size_t v10;
  uint64_t result;
  llvm::APInt *v12;
  uint64_t i;
  void **v14;
  unsigned int v15;
  _DWORD *v16;
  unsigned int v17;
  void **v18;
  _BYTE *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  _BOOL8 v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  _BOOL4 v29;
  unint64_t v30;
  _BOOL4 v31;
  void **v32;
  unsigned int v33;
  _BYTE *v34;
  _DWORD *v35;
  uint64_t v36;
  unsigned int v37;
  unsigned int v38;
  unint64_t *v39;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t *v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  _BOOL4 v48;
  uint64_t j;
  uint64_t k;
  uint64_t v52;
  unsigned int v53;
  uint64_t v54;
  unsigned int v55;
  _BYTE v56[16];
  _BYTE v57[16];
  void *v58;
  int v59;
  void *v60;
  _DWORD v61[2];
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  v5 = *((unsigned int *)a2 + 2);
  v59 = v5;
  if (v5 > 0x40)
  {
    v7 = ((unint64_t)(v5 + 63) >> 3) & 0x3FFFFFF8;
    v6 = (void *)operator new[]();
    memcpy(v6, *a2, v7);
  }
  else
  {
    v6 = (void *)*a2;
  }
  v58 = v6;
  v8 = *((unsigned int *)this + 2);
  v61[0] = v8;
  if (v8 > 0x40)
  {
    v10 = ((unint64_t)(v8 + 63) >> 3) & 0x3FFFFFF8;
    v9 = (void *)operator new[]();
    memcpy(v9, *(const void **)this, v10);
    LODWORD(v8) = *((_DWORD *)this + 2);
  }
  else
  {
    v9 = *(void **)this;
  }
  v60 = v9;
  sub_1C4832EA4((llvm::APInt *)v56, v8, 0, 0);
  sub_1C4832EA4((llvm::APInt *)v57, *((_DWORD *)this + 2), 1, 0);
  result = (uint64_t)sub_1C4832EA4((llvm::APInt *)&v54, *((_DWORD *)this + 2), 0, 0);
  for (i = 0; ; i ^= 1uLL)
  {
    v14 = &v58 + 2 * (i ^ 1);
    v17 = *((_DWORD *)v14 + 2);
    v16 = v14 + 1;
    v15 = v17;
    v18 = &v58 + 2 * (i ^ 1);
    if (v17 < 0x41)
      break;
    result = sub_1C5DCDAB0((uint64_t)(&v58 + 2 * (i ^ 1)));
    if (v15 - result <= 0x40)
    {
      v18 = &v58 + 2 * (i ^ 1);
      if (*v16 >= 0x41u)
        v18 = (void **)*(&v58 + 2 * (i ^ 1));
      break;
    }
LABEL_14:
    llvm::APInt::udivrem((llvm::APInt **)&v58 + 2 * i, (const llvm::APInt *)(&v58 + 2 * (i ^ 1)), (const llvm::APInt *)&v54, (llvm::APInt *)(&v58 + 2 * i), v12);
    llvm::APInt::operator*((uint64_t)&v56[16 * (i ^ 1)], &v54, (uint64_t)&v52);
    v19 = &v56[16 * i];
    v20 = *((unsigned int *)v19 + 2);
    if (v20 >= 0x41)
    {
      v22 = 0;
      v23 = 0;
      v24 = *(_QWORD *)v19;
      result = v52;
      v25 = (unint64_t)(v20 + 63) >> 6;
      do
      {
        v26 = *(_QWORD *)(v24 + v22);
        v27 = *(_QWORD *)(result + v22);
        v28 = v26 - v27;
        v29 = v26 < v27;
        v30 = v26 + ~v27;
        v31 = v30 >= v26;
        if (v23)
        {
          v23 = v31;
        }
        else
        {
          v30 = v28;
          v23 = v29;
        }
        *(_QWORD *)(v24 + v22) = v30;
        v22 += 8;
      }
      while (8 * v25 != v22);
      *(_QWORD *)(*(_QWORD *)v19 + 8 * (v25 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v20;
    }
    else
    {
      result = v52;
      if ((_DWORD)v20)
        v21 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v20;
      else
        v21 = 0;
      *(_QWORD *)v19 = v21 & (*(_QWORD *)v19 - v52);
    }
    if (v53 >= 0x41 && result)
      result = MEMORY[0x1CAA32F9C](result, 0x1000C8000313F17);
  }
  if (*v18)
    goto LABEL_14;
  v32 = &v58 + 2 * i;
  v33 = *((_DWORD *)v32 + 2);
  if (v33 < 0x41)
    goto LABEL_33;
  result = sub_1C5DCDAB0((uint64_t)(&v58 + 2 * i));
  if (v33 - result > 0x40)
    goto LABEL_39;
  if (*((_DWORD *)v32 + 2) >= 0x41u)
    v32 = (void **)*v32;
LABEL_33:
  if (*v32 == (void *)1)
  {
    v34 = &v56[16 * i];
    v37 = *((_DWORD *)v34 + 2);
    v35 = v34 + 8;
    v36 = v37;
    v38 = v37 - 1;
    if (v37 > 0x40)
    {
      v39 = *(unint64_t **)v34;
      if (((*(_QWORD *)(*(_QWORD *)v34 + 8 * (v38 >> 6)) >> v38) & 1) != 0)
      {
        v42 = 0;
        v43 = (uint64_t *)*a2;
        v44 = (unint64_t)(v36 + 63) >> 6;
        v45 = v44;
        do
        {
          v46 = *v43++;
          v47 = v46 + *v39;
          result = v47 < *v39;
          v48 = v47 + 1 <= *v39;
          if (v42)
          {
            ++v47;
            v42 = v48;
          }
          else
          {
            v42 = v47 < *v39;
          }
          *v39++ = v47;
          --v45;
        }
        while (v45);
        *(_QWORD *)(*(_QWORD *)v34 + 8 * (v44 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v36;
        LODWORD(v36) = *v35;
        v39 = *(unint64_t **)v34;
      }
    }
    else
    {
      v39 = *(unint64_t **)v34;
      if (((*(_QWORD *)v34 >> v38) & 1) != 0)
      {
        v40 = (unint64_t)v39 + (_QWORD)*a2;
        v41 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v36;
        if (!(_DWORD)v36)
          v41 = 0;
        v39 = (unint64_t *)(v41 & v40);
        *(_QWORD *)v34 = v39;
      }
    }
    *((_DWORD *)a3 + 2) = v36;
    *(_QWORD *)a3 = v39;
    *v35 = 0;
  }
  else
  {
LABEL_39:
    result = (uint64_t)sub_1C4832EA4(a3, *((_DWORD *)this + 2), 0, 0);
  }
  if (v55 >= 0x41)
  {
    result = v54;
    if (v54)
      result = MEMORY[0x1CAA32F9C](v54, 0x1000C8000313F17);
  }
  for (j = 0; j != -32; j -= 16)
  {
    if (*(_DWORD *)&v57[j + 8] >= 0x41u)
    {
      result = *(_QWORD *)&v56[j + 16];
      if (result)
        result = MEMORY[0x1CAA32F9C](result, 0x1000C8000313F17);
    }
  }
  for (k = 0; k != -8; k -= 4)
  {
    if (v61[k] >= 0x41u)
    {
      result = *(_QWORD *)&v61[k - 2];
      if (result)
        result = MEMORY[0x1CAA32F9C](result, 0x1000C8000313F17);
    }
  }
  return result;
}

void llvm::APInt::udivrem(llvm::APInt **this, const llvm::APInt *a2, const llvm::APInt *a3, llvm::APInt *a4, llvm::APInt *a5)
{
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  llvm::APInt *v21;
  char *v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t *v27;
  llvm::APInt *v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  void *v34;
  unint64_t v35;
  void *v36;
  size_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  int v42;

  v9 = *((unsigned int *)this + 2);
  if (v9 <= 0x40)
  {
    v10 = (unint64_t)*this % *(_QWORD *)a2;
    sub_1C4832EA4((llvm::APInt *)&v41, v9, (unint64_t)*this / *(_QWORD *)a2, 0);
    if (*((_DWORD *)a3 + 2) >= 0x41u && *(_QWORD *)a3)
      MEMORY[0x1CAA32F9C](*(_QWORD *)a3, 0x1000C8000313F17);
    *(_QWORD *)a3 = v41;
    *((_DWORD *)a3 + 2) = v42;
    v11 = v9;
    v12 = v10;
LABEL_18:
    sub_1C4832EA4((llvm::APInt *)&v41, v11, v12, 0);
    if (*((_DWORD *)a4 + 2) >= 0x41u)
    {
      if (*(_QWORD *)a4)
        MEMORY[0x1CAA32F9C](*(_QWORD *)a4, 0x1000C8000313F17);
    }
    *(_QWORD *)a4 = v41;
    *((_DWORD *)a4 + 2) = v42;
    return;
  }
  v13 = ((unint64_t)(v9 - sub_1C5DCDAB0((uint64_t)this)) + 63) >> 6;
  v14 = *((_DWORD *)a2 + 2);
  v15 = sub_1C5DCDAB0((uint64_t)a2);
  if (!(_DWORD)v13)
  {
    v19 = v9;
    v20 = 0;
LABEL_14:
    sub_1C4832EA4((llvm::APInt *)&v41, v19, v20, 0);
    if (*((_DWORD *)a3 + 2) >= 0x41u && *(_QWORD *)a3)
      MEMORY[0x1CAA32F9C](*(_QWORD *)a3, 0x1000C8000313F17);
    *(_QWORD *)a3 = v41;
    *((_DWORD *)a3 + 2) = v42;
    v11 = v9;
    v12 = 0;
    goto LABEL_18;
  }
  v16 = (v14 - v15);
  v17 = (unint64_t)(v16 + 63) >> 6;
  if ((_DWORD)v16 == 1)
  {
    sub_1C63817D4((void **)a3, (uint64_t)this);
    sub_1C4832EA4((llvm::APInt *)&v41, v9, 0, 0);
    if (*((_DWORD *)a4 + 2) >= 0x41u && *(_QWORD *)a4)
      MEMORY[0x1CAA32F9C](*(_QWORD *)a4, 0x1000C8000313F17);
    *(_QWORD *)a4 = v41;
    *((_DWORD *)a4 + 2) = v42;
  }
  if (v13 >= v17)
  {
    v18 = *((unsigned int *)this + 2);
    if (v18 > 0x40)
    {
      v21 = *this;
      v22 = *(char **)a2;
      v23 = (unint64_t)(v18 + 63) >> 3;
      v24 = v23 & 0x3FFFFFF8;
      while (v24)
      {
        v25 = *(_QWORD *)((char *)v21 + v24 - 8);
        v26 = *(_QWORD *)&v22[v24 - 8];
        v24 -= 8;
        if (v25 != v26)
        {
          if (v25 <= v26)
            goto LABEL_42;
          break;
        }
      }
      if (!memcmp(v21, v22, v23 & 0x3FFFFFF8))
        goto LABEL_12;
      goto LABEL_27;
    }
    if ((unint64_t)*this >= *(_QWORD *)a2)
    {
      if (*this == *(llvm::APInt **)a2)
      {
LABEL_12:
        v19 = v9;
        v20 = 1;
        goto LABEL_14;
      }
LABEL_27:
      llvm::APInt::reallocate((uint64_t)a3, v9);
      llvm::APInt::reallocate((uint64_t)a4, v9);
      v28 = *this;
      if ((_DWORD)v13 == 1)
      {
        v29 = *(_QWORD *)v28;
        v30 = **(_QWORD **)a2;
        v31 = *((unsigned int *)a3 + 2);
        v32 = *(_QWORD *)v28 / v30;
        if (v31 > 0x40)
        {
          **(_QWORD **)a3 = v32;
          bzero((void *)(*(_QWORD *)a3 + 8), (((unint64_t)(v31 + 63) >> 3) - 8) & 0xFFFFFFF8);
        }
        else
        {
          if ((_DWORD)v31)
            v33 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v31;
          else
            v33 = 0;
          *(_QWORD *)a3 = v33 & v32;
        }
        v38 = v29 - v32 * v30;
        v39 = *((unsigned int *)a4 + 2);
        if (v39 <= 0x40)
        {
          if ((_DWORD)v39)
            v40 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v39;
          else
            v40 = 0;
          *(_QWORD *)a4 = v40 & v38;
          return;
        }
        **(_QWORD **)a4 = v38;
        v36 = (void *)(*(_QWORD *)a4 + 8);
        v37 = (((unint64_t)(v39 + 63) >> 3) - 8) & 0xFFFFFFF8;
      }
      else
      {
        llvm::APInt::divide(v28, (const unint64_t *)v13, *(uint64_t **)a2, (const unint64_t *)v17, *(unint64_t **)a3, *(unint64_t **)a4, v27);
        v34 = (void *)(*(_QWORD *)a3 + 8 * v13);
        v35 = (unint64_t)(v9 + 63) >> 6;
        bzero(v34, (8 * (v35 - v13)));
        v36 = (void *)(*(_QWORD *)a4 + 8 * v17);
        v37 = (8 * (v35 - v17));
      }
      bzero(v36, v37);
      return;
    }
  }
LABEL_42:
  sub_1C63817D4((void **)a4, (uint64_t)this);
  sub_1C4832EA4((llvm::APInt *)&v41, v9, 0, 0);
  if (*((_DWORD *)a3 + 2) >= 0x41u && *(_QWORD *)a3)
    MEMORY[0x1CAA32F9C](*(_QWORD *)a3, 0x1000C8000313F17);
  *(_QWORD *)a3 = v41;
  *((_DWORD *)a3 + 2) = v42;
}

void llvm::APInt::divide(llvm::APInt *this, const unint64_t *a2, uint64_t *a3, const unint64_t *a4, unint64_t *a5, unint64_t *a6, unint64_t *a7)
{
  unint64_t *v7;
  uint64_t v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  uint64_t v15;
  size_t v16;
  unsigned int *v17;
  int v18;
  _DWORD *v19;
  _DWORD *v20;
  _DWORD *v21;
  _DWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  BOOL v35;
  unint64_t v36;
  unsigned int v37;
  int v38;
  unsigned int v39;
  int *v40;
  uint64_t v41;
  unsigned int v42;
  unsigned int v43;
  uint64_t v44;
  int *v45;
  unsigned int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  uint64_t v62;
  int v63;
  unsigned int v64;
  unsigned int v65;
  unsigned int v66;
  unsigned int v67;
  int v68;
  unsigned int v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  size_t v73;
  int v74;
  unsigned int v75;
  const unint64_t *v76;
  _DWORD v77[128];
  uint64_t v78;

  v7 = a6;
  v78 = *MEMORY[0x1E0C80C00];
  v11 = (2 * (_DWORD)a4);
  v12 = (2 * (_DWORD)a2);
  v75 = a2;
  v76 = a4;
  if (a6)
    v13 = 4;
  else
    v13 = 3;
  v74 = v12 - 2 * (_DWORD)a4;
  v14 = (v13 * v11 + 2 * v74) | 1;
  v15 = (2 * (_DWORD)a2) | 1u;
  v16 = 4 * v15;
  if (v14 > 0x80)
  {
    v73 = 4 * v15;
    v21 = (_DWORD *)operator new[]();
    v17 = (unsigned int *)operator new[]();
    v19 = (_DWORD *)operator new[]();
    if (v7)
      v22 = (_DWORD *)operator new[]();
    else
      v22 = 0;
    v16 = v73;
  }
  else
  {
    v17 = &v77[v15];
    v18 = v11 + v15;
    v19 = &v77[v18];
    v20 = &v77[(v18 + v12)];
    v21 = v77;
    if (a6)
      v22 = v20;
    else
      v22 = 0;
  }
  bzero(v21, v16);
  if (v75)
  {
    v23 = 0;
    do
    {
      v24 = *(_QWORD *)this;
      this = (llvm::APInt *)((char *)this + 8);
      v21[v23] = v24;
      v21[(v23 + 1)] = HIDWORD(v24);
      v23 += 2;
    }
    while (2 * v75 != v23);
  }
  v21[v12] = 0;
  bzero(v17, 4 * v11);
  if ((_DWORD)v76)
  {
    v25 = 0;
    v26 = 2 * v76;
    do
    {
      v27 = *a3++;
      v17[v25] = v27;
      v17[(v25 + 1)] = HIDWORD(v27);
      v25 += 2;
    }
    while (v26 != v25);
  }
  bzero(v19, 4 * v12);
  if (v7)
    bzero(v22, 4 * v11);
  if ((_DWORD)v11)
  {
    while (!v17[v11 - 1])
    {
      if (!--v11)
        goto LABEL_26;
    }
    LODWORD(v12) = v12 - v11;
  }
  else
  {
    LODWORD(v12) = v74;
  }
LABEL_26:
  if ((_DWORD)v11 + (_DWORD)v12)
  {
    v28 = (v11 + v12);
    while (!v21[v28 - 1])
    {
      LODWORD(v12) = v12 - 1;
      if (!(--v28 * 4))
      {
        LODWORD(v12) = -(int)v11;
        break;
      }
    }
  }
  v29 = (v11 - 1);
  if ((_DWORD)v11 != 1)
  {
    v37 = __clz(v17[v29]);
    v38 = v12 + v11;
    if (!v37)
    {
      v42 = 0;
      goto LABEL_56;
    }
    if (v38)
    {
      v39 = 0;
      v40 = v21;
      v41 = (v12 + v11);
      do
      {
        v42 = *v40 >> (32 - v37);
        *v40 = (*v40 << v37) | v39;
        ++v40;
        v39 = v42;
        --v41;
      }
      while (v41);
      if (!(_DWORD)v11)
      {
LABEL_56:
        v21[v38] = v42;
        v47 = (v11 - 2);
        v48 = (int)v12;
        do
        {
          v49 = (v11 + v48);
          v50 = v21[(v49 - 1)] | ((unint64_t)v21[v49] << 32);
          v51 = v17[v29];
          v52 = v50 / v51;
          v53 = v50 % v51;
          if (v50 / v51 == 0x100000000
            || (v54 = v50 / v51, v52 * v17[v47] > (v21[(v49 - 2)] | (v53 << 32))))
          {
            v54 = v52 - 1;
            v55 = v53 + v51;
            if (!HIDWORD(v55)
              && (v52 == 0x100000001 || v54 * v17[v47] > (v21[(v49 - 2)] | (v55 << 32))))
            {
              v54 = v52 - 2;
            }
          }
          if ((_DWORD)v11)
          {
            v56 = 0;
            v57 = 0;
            do
            {
              v58 = v54 * v17[v56];
              v59 = v21[(v48 + v56)] - (v57 + v58);
              v21[(v48 + v56)] = v59;
              v60 = HIDWORD(v58) - HIDWORD(v59);
              v57 = v60;
              ++v56;
            }
            while (v11 != v56);
            v61 = v21[v49];
            v21[v49] = v61 - v60;
            v19[v48] = v54;
            if (v60 > v61)
            {
              v62 = 0;
              LOBYTE(v63) = 0;
              v19[v48] = v54 - 1;
              do
              {
                v64 = v17[v62];
                v65 = v21[(v48 + v62)];
                if (v64 >= v65)
                  v66 = v21[(v48 + v62)];
                else
                  v66 = v17[v62];
                v67 = v64 + (v63 & 1) + v65;
                v21[(v48 + v62)] = v67;
                if (v67 >= v66)
                  v63 = v63 & (v67 == v66);
                else
                  v63 = 1;
                ++v62;
              }
              while (v11 != v62);
              v21[v49] += v63;
            }
          }
          else
          {
            v19[v48] = v54;
          }
          v35 = v48-- <= 0;
        }
        while (!v35);
        if (v22)
        {
          if (v37)
          {
            if ((v29 & 0x80000000) == 0)
            {
              v68 = 0;
              do
              {
                v69 = v21[v29];
                v22[v29] = (v69 >> v37) | v68;
                v68 = v69 << (32 - v37);
                v35 = v29-- <= 0;
              }
              while (!v35);
            }
          }
          else if ((v29 & 0x80000000) == 0)
          {
            do
            {
              v22[v29] = v21[v29];
              v35 = v29-- <= 0;
            }
            while (!v35);
          }
        }
        goto LABEL_89;
      }
    }
    else
    {
      v42 = 0;
      if (!(_DWORD)v11)
        goto LABEL_56;
    }
    v43 = 0;
    v44 = v11;
    v45 = (int *)v17;
    do
    {
      v46 = *v45 >> (32 - v37);
      *v45 = (*v45 << v37) | v43;
      ++v45;
      v43 = v46;
      --v44;
    }
    while (v44);
    goto LABEL_56;
  }
  v30 = 0;
  if ((v12 & 0x80000000) == 0)
  {
    v31 = *v17;
    v32 = v12;
    do
    {
      v33 = v30;
      v30 = v21[v32];
      v34 = v30 | (v33 << 32);
      if (v34)
      {
        if (v34 >= v31)
        {
          if (v34 == v31)
          {
            v30 = 0;
            v19[v32] = 1;
          }
          else
          {
            v36 = v34 / v31;
            v19[v32] = v36;
            v30 = (v30 - v31 * v36);
          }
          goto LABEL_41;
        }
      }
      else
      {
        v30 = 0;
      }
      v19[v32] = 0;
LABEL_41:
      v35 = v32-- <= 0;
    }
    while (!v35);
  }
  if (v22)
    *v22 = v30;
LABEL_89:
  if (v75 && a5)
  {
    v70 = 0;
    do
    {
      *a5++ = v19[v70] | ((unint64_t)v19[(v70 + 1)] << 32);
      v70 += 2;
    }
    while (2 * v75 != v70);
  }
  if ((_DWORD)v76 && v7)
  {
    v71 = 0;
    v72 = 2 * v76;
    do
    {
      *v7++ = v22[v71] | ((unint64_t)v22[(v71 + 1)] << 32);
      v71 += 2;
    }
    while (v72 != v71);
  }
  if (v21 != v77)
  {
    MEMORY[0x1CAA32F9C](v21, 0x1000C8052888210);
    MEMORY[0x1CAA32F9C](v17, 0x1000C8052888210);
    MEMORY[0x1CAA32F9C](v19, 0x1000C8052888210);
    if (v22)
      MEMORY[0x1CAA32F9C](v22, 0x1000C8052888210);
  }
}

void llvm::APInt::udiv(llvm::APInt *this@<X0>, unint64_t a2@<X1>, llvm::APInt *a3@<X8>)
{
  unsigned int v6;
  uint64_t v7;
  llvm::APInt *v8;
  unsigned int v9;
  const unint64_t *v10;
  unsigned int v11;
  llvm::APInt *v12;
  unsigned int v13;
  unsigned int v14;
  llvm::APInt *v15;
  unint64_t *v16;
  unint64_t v17;

  v17 = a2;
  v6 = *((_DWORD *)this + 2);
  if (v6 <= 0x40)
  {
    v7 = *(_QWORD *)this / a2;
    v8 = a3;
    v9 = v6;
LABEL_11:
    sub_1C4832EA4(v8, v9, v7, 0);
    return;
  }
  v10 = (const unint64_t *)(((unint64_t)(v6 - sub_1C5DCDAB0((uint64_t)this)) + 63) >> 6);
  if (!(_DWORD)v10)
  {
    v9 = *((_DWORD *)this + 2);
    v8 = a3;
LABEL_10:
    v7 = 0;
    goto LABEL_11;
  }
  if (a2 == 1)
  {
    sub_1C5DD14E0((uint64_t)a3, (uint64_t)this);
    return;
  }
  v11 = *((_DWORD *)this + 2);
  v12 = this;
  if (v11 < 0x41)
    goto LABEL_8;
  v13 = v11 - sub_1C5DCDAB0((uint64_t)this);
  v11 = *((_DWORD *)this + 2);
  if (v13 <= 0x40)
  {
    if (v11 >= 0x41)
      v12 = *(llvm::APInt **)this;
    else
      v12 = this;
LABEL_8:
    if (*(_QWORD *)v12 < a2)
    {
      v8 = a3;
      v9 = v11;
      goto LABEL_10;
    }
  }
  if (v11 < 0x41)
    goto LABEL_18;
  v14 = v11 - sub_1C5DCDAB0((uint64_t)this);
  v11 = *((_DWORD *)this + 2);
  if (v14 > 0x40)
    goto LABEL_21;
  if (v11 >= 0x41)
    v15 = *(llvm::APInt **)this;
  else
LABEL_18:
    v15 = this;
  if (*(_QWORD *)v15 == a2)
  {
    v8 = a3;
    v9 = v11;
    v7 = 1;
    goto LABEL_11;
  }
LABEL_21:
  if ((_DWORD)v10 == 1)
  {
    v7 = **(_QWORD **)this / a2;
    v8 = a3;
    v9 = v11;
    goto LABEL_11;
  }
  sub_1C4832EA4(a3, v11, 0, 0);
  llvm::APInt::divide(*(llvm::APInt **)this, v10, (uint64_t *)&v17, (const unint64_t *)1, *(unint64_t **)a3, 0, v16);
}

void llvm::APInt::sdiv(llvm::APInt *this@<X0>, const void **a2@<X1>, llvm::APInt *a3@<X8>)
{
  uint64_t v6;
  unsigned int v7;
  llvm::APInt *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  const void **v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  size_t v17;
  uint64_t v18;
  unint64_t v19;
  size_t v20;
  void *v21;
  size_t v22;
  unint64_t v23;
  size_t v24;
  unint64_t v25;
  void *v26;
  unsigned int v27;
  unint64_t v28;
  unsigned int v29;
  void *v30;
  unsigned int v31;
  unint64_t v32;
  unsigned int v33;
  void *v34;
  unsigned int v35;
  void *v36;
  unsigned int v37;
  void *v38;
  unsigned int v39;
  void *v40;
  unsigned int v41;

  v6 = *((unsigned int *)this + 2);
  v7 = v6 - 1;
  v8 = this;
  if (v6 >= 0x41)
    v8 = (llvm::APInt *)(*(_QWORD *)this + 8 * (v7 >> 6));
  v9 = *(_QWORD *)v8;
  v10 = *((unsigned int *)a2 + 2);
  v11 = (unint64_t)*a2;
  v12 = (const void **)((char *)*a2 + 8 * ((v10 - 1) >> 6));
  if (v10 < 0x41)
    v12 = a2;
  v13 = (1 << (v10 - 1)) & (unint64_t)*v12;
  if (((v9 >> v7) & 1) != 0)
  {
    if (v13)
    {
      v39 = *((_DWORD *)this + 2);
      if (v6 > 0x40)
      {
        v17 = ((unint64_t)(v6 + 63) >> 3) & 0x3FFFFFF8;
        v38 = (void *)operator new[]();
        memcpy(v38, *(const void **)this, v17);
        llvm::APInt::flipAllBitsSlowCase((uint64_t)&v38);
      }
      else
      {
        if ((_DWORD)v6)
          v14 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v6;
        else
          v14 = 0;
        v38 = (void *)(v14 & ~*(_QWORD *)this);
      }
      llvm::APInt::operator++((uint64_t)&v38);
      v41 = v39;
      v40 = v38;
      v39 = 0;
      v18 = *((unsigned int *)a2 + 2);
      v35 = v18;
      if (v18 > 0x40)
      {
        v20 = ((unint64_t)(v18 + 63) >> 3) & 0x3FFFFFF8;
        v34 = (void *)operator new[]();
        memcpy(v34, *a2, v20);
        llvm::APInt::flipAllBitsSlowCase((uint64_t)&v34);
      }
      else
      {
        if ((_DWORD)v18)
          v19 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v18;
        else
          v19 = 0;
        v34 = (void *)(v19 & ~(unint64_t)*a2);
      }
      llvm::APInt::operator++((uint64_t)&v34);
      v37 = v35;
      v36 = v34;
      v35 = 0;
      llvm::APInt::udiv((llvm::APInt *)&v40, (const llvm::APInt *)&v36, a3);
      if (v37 >= 0x41 && v36)
        MEMORY[0x1CAA32F9C](v36, 0x1000C8000313F17);
      if (v35 >= 0x41 && v34)
        MEMORY[0x1CAA32F9C](v34, 0x1000C8000313F17);
      if (v41 >= 0x41 && v40)
        MEMORY[0x1CAA32F9C](v40, 0x1000C8000313F17);
      if (v39 < 0x41)
        return;
      v21 = v38;
      if (!v38)
        return;
LABEL_62:
      MEMORY[0x1CAA32F9C](v21, 0x1000C8000313F17);
      return;
    }
    v31 = *((_DWORD *)this + 2);
    if (v6 > 0x40)
    {
      v24 = ((unint64_t)(v6 + 63) >> 3) & 0x3FFFFFF8;
      v30 = (void *)operator new[]();
      memcpy(v30, *(const void **)this, v24);
      llvm::APInt::flipAllBitsSlowCase((uint64_t)&v30);
    }
    else
    {
      if ((_DWORD)v6)
        v16 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v6;
      else
        v16 = 0;
      v30 = (void *)(v16 & ~*(_QWORD *)this);
    }
    llvm::APInt::operator++((uint64_t)&v30);
    v41 = v31;
    v40 = v30;
    v31 = 0;
    llvm::APInt::udiv((llvm::APInt *)&v40, (const llvm::APInt *)a2, (llvm::APInt *)&v32);
    if (v33 > 0x40)
    {
      llvm::APInt::flipAllBitsSlowCase((uint64_t)&v32);
    }
    else
    {
      if (v33)
        v25 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v33;
      else
        v25 = 0;
      v32 = v25 & ~v32;
    }
    llvm::APInt::operator++((uint64_t)&v32);
    *((_DWORD *)a3 + 2) = v33;
    *(_QWORD *)a3 = v32;
    v33 = 0;
    if (v41 >= 0x41 && v40)
      MEMORY[0x1CAA32F9C](v40, 0x1000C8000313F17);
    if (v31 >= 0x41)
    {
      v21 = v30;
      if (v30)
        goto LABEL_62;
    }
  }
  else
  {
    if (!v13)
    {
      llvm::APInt::udiv(this, (const llvm::APInt *)a2, a3);
      return;
    }
    v27 = *((_DWORD *)a2 + 2);
    if (v10 > 0x40)
    {
      v22 = ((unint64_t)(v10 + 63) >> 3) & 0x3FFFFFF8;
      v26 = (void *)operator new[]();
      memcpy(v26, *a2, v22);
      llvm::APInt::flipAllBitsSlowCase((uint64_t)&v26);
    }
    else
    {
      if ((_DWORD)v10)
        v15 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v10;
      else
        v15 = 0;
      v26 = (void *)(v15 & ~v11);
    }
    llvm::APInt::operator++((uint64_t)&v26);
    v41 = v27;
    v40 = v26;
    v27 = 0;
    llvm::APInt::udiv(this, (const llvm::APInt *)&v40, (llvm::APInt *)&v28);
    if (v29 > 0x40)
    {
      llvm::APInt::flipAllBitsSlowCase((uint64_t)&v28);
    }
    else
    {
      if (v29)
        v23 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v29;
      else
        v23 = 0;
      v28 = v23 & ~v28;
    }
    llvm::APInt::operator++((uint64_t)&v28);
    *((_DWORD *)a3 + 2) = v29;
    *(_QWORD *)a3 = v28;
    v29 = 0;
    if (v41 >= 0x41 && v40)
      MEMORY[0x1CAA32F9C](v40, 0x1000C8000313F17);
    if (v27 >= 0x41)
    {
      v21 = v26;
      if (v26)
        goto LABEL_62;
    }
  }
}

void llvm::APInt::sdiv(llvm::APInt *this@<X0>, unint64_t a2@<X1>, llvm::APInt *a3@<X8>)
{
  uint64_t v6;
  unsigned int v7;
  llvm::APInt *v8;
  unint64_t v9;
  unint64_t v10;
  size_t v11;
  unint64_t v12;
  void *v13;
  unint64_t v14;
  size_t v15;
  unint64_t v16;
  unsigned int v17;
  void *v18;
  unsigned int v19;
  unint64_t v20;
  unsigned int v21;
  void *v22;
  unsigned int v23;
  void *v24;
  unsigned int v25;

  v6 = *((unsigned int *)this + 2);
  v7 = v6 - 1;
  v8 = this;
  if (v6 >= 0x41)
    v8 = (llvm::APInt *)(*(_QWORD *)this + 8 * (v7 >> 6));
  if (((*(_QWORD *)v8 >> v7) & 1) != 0)
  {
    if ((a2 & 0x8000000000000000) == 0)
    {
      v19 = *((_DWORD *)this + 2);
      if (v6 > 0x40)
      {
        v11 = ((unint64_t)(v6 + 63) >> 3) & 0x3FFFFFF8;
        v18 = (void *)operator new[]();
        memcpy(v18, *(const void **)this, v11);
        llvm::APInt::flipAllBitsSlowCase((uint64_t)&v18);
      }
      else
      {
        if ((_DWORD)v6)
          v9 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v6;
        else
          v9 = 0;
        v18 = (void *)(v9 & ~*(_QWORD *)this);
      }
      llvm::APInt::operator++((uint64_t)&v18);
      v25 = v19;
      v24 = v18;
      v19 = 0;
      llvm::APInt::udiv((llvm::APInt *)&v24, a2, (llvm::APInt *)&v20);
      if (v21 > 0x40)
      {
        llvm::APInt::flipAllBitsSlowCase((uint64_t)&v20);
      }
      else
      {
        if (v21)
          v12 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v21;
        else
          v12 = 0;
        v20 = v12 & ~v20;
      }
      llvm::APInt::operator++((uint64_t)&v20);
      *((_DWORD *)a3 + 2) = v21;
      *(_QWORD *)a3 = v20;
      v21 = 0;
      if (v25 >= 0x41 && v24)
        MEMORY[0x1CAA32F9C](v24, 0x1000C8000313F17);
      if (v19 < 0x41)
        return;
      v13 = v18;
      if (!v18)
        return;
LABEL_41:
      MEMORY[0x1CAA32F9C](v13, 0x1000C8000313F17);
      return;
    }
    v23 = *((_DWORD *)this + 2);
    if (v6 > 0x40)
    {
      v15 = ((unint64_t)(v6 + 63) >> 3) & 0x3FFFFFF8;
      v22 = (void *)operator new[]();
      memcpy(v22, *(const void **)this, v15);
      llvm::APInt::flipAllBitsSlowCase((uint64_t)&v22);
    }
    else
    {
      if ((_DWORD)v6)
        v10 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v6;
      else
        v10 = 0;
      v22 = (void *)(v10 & ~*(_QWORD *)this);
    }
    llvm::APInt::operator++((uint64_t)&v22);
    v25 = v23;
    v24 = v22;
    v23 = 0;
    llvm::APInt::udiv((llvm::APInt *)&v24, -(uint64_t)a2, a3);
    if (v25 >= 0x41 && v24)
      MEMORY[0x1CAA32F9C](v24, 0x1000C8000313F17);
    if (v23 >= 0x41)
    {
      v13 = v22;
      if (v22)
        goto LABEL_41;
    }
  }
  else if ((a2 & 0x8000000000000000) != 0)
  {
    llvm::APInt::udiv(this, -(uint64_t)a2, (llvm::APInt *)&v16);
    if (v17 > 0x40)
    {
      llvm::APInt::flipAllBitsSlowCase((uint64_t)&v16);
    }
    else
    {
      if (v17)
        v14 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v17;
      else
        v14 = 0;
      v16 = v14 & ~v16;
    }
    llvm::APInt::operator++((uint64_t)&v16);
    *((_DWORD *)a3 + 2) = v17;
    *(_QWORD *)a3 = v16;
  }
  else
  {
    llvm::APInt::udiv(this, a2, a3);
  }
}

void llvm::APInt::urem(llvm::APInt *this@<X0>, const llvm::APInt *a2@<X1>, llvm::APInt *a3@<X8>)
{
  unsigned int v6;
  uint64_t v7;
  llvm::APInt *v8;
  unsigned int v9;
  const unint64_t *v10;
  int v11;
  int v12;
  uint64_t v13;
  const unint64_t *v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t *v22;

  v6 = *((_DWORD *)this + 2);
  if (v6 <= 0x40)
  {
    v7 = *(_QWORD *)this % *(_QWORD *)a2;
    v8 = a3;
    v9 = v6;
LABEL_7:
    sub_1C4832EA4(v8, v9, v7, 0);
    return;
  }
  v10 = (const unint64_t *)(((unint64_t)(v6 - sub_1C5DCDAB0((uint64_t)this)) + 63) >> 6);
  v11 = *((_DWORD *)a2 + 2);
  v12 = sub_1C5DCDAB0((uint64_t)a2);
  if (!(_DWORD)v10 || (v13 = (v11 - v12), (_DWORD)v13 == 1))
  {
    v9 = *((_DWORD *)this + 2);
    v8 = a3;
LABEL_6:
    v7 = 0;
    goto LABEL_7;
  }
  v14 = (const unint64_t *)((unint64_t)(v13 + 63) >> 6);
  if (v10 < v14)
    goto LABEL_20;
  v15 = *((unsigned int *)this + 2);
  if (v15 <= 0x40)
  {
    v16 = *(_QWORD **)this;
    v17 = *(_QWORD **)a2;
    if (*(_QWORD *)this >= *(_QWORD *)a2)
    {
      if (*(_QWORD *)this == *(_QWORD *)a2)
      {
LABEL_12:
        v8 = a3;
        v9 = v15;
        goto LABEL_6;
      }
      goto LABEL_18;
    }
LABEL_20:
    sub_1C5DD14E0((uint64_t)a3, (uint64_t)this);
    return;
  }
  v16 = *(_QWORD **)this;
  v17 = *(_QWORD **)a2;
  v18 = (unint64_t)(v15 + 63) >> 3;
  v19 = v18 & 0x3FFFFFF8;
  while (v19)
  {
    v20 = *(_QWORD *)((char *)v16 + v19 - 8);
    v21 = *(_QWORD *)((char *)v17 + v19 - 8);
    v19 -= 8;
    if (v20 != v21)
    {
      if (v20 <= v21)
        goto LABEL_20;
      break;
    }
  }
  if (!memcmp(*(const void **)this, *(const void **)a2, v18 & 0x3FFFFFF8))
    goto LABEL_12;
LABEL_18:
  if ((_DWORD)v10 == 1)
  {
    v7 = *v16 % *v17;
    v8 = a3;
    v9 = v15;
    goto LABEL_7;
  }
  sub_1C4832EA4(a3, v15, 0, 0);
  llvm::APInt::divide(*(llvm::APInt **)this, v10, *(uint64_t **)a2, v14, 0, *(unint64_t **)a3, v22);
}

unint64_t llvm::APInt::urem(uint64_t **this, unint64_t a2)
{
  unsigned int v4;
  unint64_t v5;
  unint64_t result;
  unint64_t *v7;
  int v8;
  const unint64_t *v9;
  unsigned int v10;
  uint64_t **v11;
  unsigned int v12;
  unsigned int v13;
  unint64_t v14;
  unint64_t v15;

  v15 = a2;
  v4 = *((_DWORD *)this + 2);
  if (v4 <= 0x40)
  {
    v5 = (unint64_t)*this;
    return v5 % a2;
  }
  v8 = sub_1C5DCDAB0((uint64_t)this);
  result = 0;
  if (a2 == 1)
    return result;
  v9 = (const unint64_t *)(((unint64_t)(v4 - v8) + 63) >> 6);
  if (!(_DWORD)v9)
    return result;
  v10 = *((_DWORD *)this + 2);
  if (v10 >= 0x41)
  {
    v12 = v10 - sub_1C5DCDAB0((uint64_t)this);
    v13 = *((_DWORD *)this + 2);
    if (v12 > 0x40)
    {
      v11 = this;
      if (v13 < 0x41)
        goto LABEL_18;
    }
    else
    {
      if (v13 <= 0x40)
        goto LABEL_8;
      result = **this;
      if (result < a2)
        return result;
    }
    if (v13 - sub_1C5DCDAB0((uint64_t)this) > 0x40)
    {
LABEL_20:
      if ((_DWORD)v9 != 1)
      {
        v14 = 0;
        llvm::APInt::divide((llvm::APInt *)*this, v9, (uint64_t *)&v15, (const unint64_t *)1, 0, &v14, v7);
        return v14;
      }
      v5 = **this;
      return v5 % a2;
    }
    v11 = this;
    if (*((_DWORD *)this + 2) >= 0x41u)
      v11 = (uint64_t **)*this;
LABEL_18:
    if (*v11 == (uint64_t *)a2)
      return 0;
    goto LABEL_20;
  }
LABEL_8:
  result = (unint64_t)*this;
  v11 = this;
  if ((unint64_t)*this >= a2)
    goto LABEL_18;
  return result;
}

void llvm::APInt::srem(llvm::APInt *this@<X0>, const void **a2@<X1>, llvm::APInt *a3@<X8>)
{
  uint64_t v6;
  unsigned int v7;
  llvm::APInt *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  const void **v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  size_t v17;
  uint64_t v18;
  unint64_t v19;
  size_t v20;
  unint64_t v21;
  void *v22;
  size_t v23;
  size_t v24;
  unint64_t v25;
  void *v26;
  unsigned int v27;
  void *v28;
  unsigned int v29;
  unint64_t v30;
  unsigned int v31;
  void *v32;
  unsigned int v33;
  void *v34;
  unsigned int v35;
  void *v36;
  unsigned int v37;
  void *v38;
  unsigned int v39;
  unint64_t v40;
  unsigned int v41;

  v6 = *((unsigned int *)this + 2);
  v7 = v6 - 1;
  v8 = this;
  if (v6 >= 0x41)
    v8 = (llvm::APInt *)(*(_QWORD *)this + 8 * (v7 >> 6));
  v9 = *(_QWORD *)v8;
  v10 = *((unsigned int *)a2 + 2);
  v11 = (unint64_t)*a2;
  v12 = (const void **)((char *)*a2 + 8 * ((v10 - 1) >> 6));
  if (v10 < 0x41)
    v12 = a2;
  v13 = (1 << (v10 - 1)) & (unint64_t)*v12;
  if (((v9 >> v7) & 1) != 0)
  {
    if (v13)
    {
      v37 = *((_DWORD *)this + 2);
      if (v6 > 0x40)
      {
        v17 = ((unint64_t)(v6 + 63) >> 3) & 0x3FFFFFF8;
        v36 = (void *)operator new[]();
        memcpy(v36, *(const void **)this, v17);
        llvm::APInt::flipAllBitsSlowCase((uint64_t)&v36);
      }
      else
      {
        if ((_DWORD)v6)
          v14 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v6;
        else
          v14 = 0;
        v36 = (void *)(v14 & ~*(_QWORD *)this);
      }
      llvm::APInt::operator++((uint64_t)&v36);
      v39 = v37;
      v38 = v36;
      v37 = 0;
      v18 = *((unsigned int *)a2 + 2);
      v33 = v18;
      if (v18 > 0x40)
      {
        v20 = ((unint64_t)(v18 + 63) >> 3) & 0x3FFFFFF8;
        v32 = (void *)operator new[]();
        memcpy(v32, *a2, v20);
        llvm::APInt::flipAllBitsSlowCase((uint64_t)&v32);
      }
      else
      {
        if ((_DWORD)v18)
          v19 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v18;
        else
          v19 = 0;
        v32 = (void *)(v19 & ~(unint64_t)*a2);
      }
      llvm::APInt::operator++((uint64_t)&v32);
      v35 = v33;
      v34 = v32;
      v33 = 0;
      llvm::APInt::urem((llvm::APInt *)&v38, (const llvm::APInt *)&v34, (llvm::APInt *)&v40);
      if (v41 > 0x40)
      {
        llvm::APInt::flipAllBitsSlowCase((uint64_t)&v40);
      }
      else
      {
        if (v41)
          v21 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v41;
        else
          v21 = 0;
        v40 = v21 & ~v40;
      }
      llvm::APInt::operator++((uint64_t)&v40);
      *((_DWORD *)a3 + 2) = v41;
      *(_QWORD *)a3 = v40;
      v41 = 0;
      if (v35 >= 0x41 && v34)
        MEMORY[0x1CAA32F9C](v34, 0x1000C8000313F17);
      if (v33 >= 0x41 && v32)
        MEMORY[0x1CAA32F9C](v32, 0x1000C8000313F17);
      if (v39 >= 0x41 && v38)
        MEMORY[0x1CAA32F9C](v38, 0x1000C8000313F17);
      if (v37 < 0x41)
        return;
      v22 = v36;
      if (!v36)
        return;
LABEL_62:
      MEMORY[0x1CAA32F9C](v22, 0x1000C8000313F17);
      return;
    }
    v29 = *((_DWORD *)this + 2);
    if (v6 > 0x40)
    {
      v24 = ((unint64_t)(v6 + 63) >> 3) & 0x3FFFFFF8;
      v28 = (void *)operator new[]();
      memcpy(v28, *(const void **)this, v24);
      llvm::APInt::flipAllBitsSlowCase((uint64_t)&v28);
    }
    else
    {
      if ((_DWORD)v6)
        v16 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v6;
      else
        v16 = 0;
      v28 = (void *)(v16 & ~*(_QWORD *)this);
    }
    llvm::APInt::operator++((uint64_t)&v28);
    v39 = v29;
    v38 = v28;
    v29 = 0;
    llvm::APInt::urem((llvm::APInt *)&v38, (const llvm::APInt *)a2, (llvm::APInt *)&v30);
    if (v31 > 0x40)
    {
      llvm::APInt::flipAllBitsSlowCase((uint64_t)&v30);
    }
    else
    {
      if (v31)
        v25 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v31;
      else
        v25 = 0;
      v30 = v25 & ~v30;
    }
    llvm::APInt::operator++((uint64_t)&v30);
    *((_DWORD *)a3 + 2) = v31;
    *(_QWORD *)a3 = v30;
    v31 = 0;
    if (v39 >= 0x41 && v38)
      MEMORY[0x1CAA32F9C](v38, 0x1000C8000313F17);
    if (v29 >= 0x41)
    {
      v22 = v28;
      if (v28)
        goto LABEL_62;
    }
  }
  else
  {
    if (!v13)
    {
      llvm::APInt::urem(this, (const llvm::APInt *)a2, a3);
      return;
    }
    v27 = *((_DWORD *)a2 + 2);
    if (v10 > 0x40)
    {
      v23 = ((unint64_t)(v10 + 63) >> 3) & 0x3FFFFFF8;
      v26 = (void *)operator new[]();
      memcpy(v26, *a2, v23);
      llvm::APInt::flipAllBitsSlowCase((uint64_t)&v26);
    }
    else
    {
      if ((_DWORD)v10)
        v15 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v10;
      else
        v15 = 0;
      v26 = (void *)(v15 & ~v11);
    }
    llvm::APInt::operator++((uint64_t)&v26);
    v39 = v27;
    v38 = v26;
    v27 = 0;
    llvm::APInt::urem(this, (const llvm::APInt *)&v38, a3);
    if (v39 >= 0x41 && v38)
      MEMORY[0x1CAA32F9C](v38, 0x1000C8000313F17);
    if (v27 >= 0x41)
    {
      v22 = v26;
      if (v26)
        goto LABEL_62;
    }
  }
}

unint64_t llvm::APInt::srem(llvm::APInt *this, unint64_t a2)
{
  unint64_t v2;
  uint64_t v4;
  unsigned int v5;
  llvm::APInt *v6;
  unint64_t v7;
  unint64_t v8;
  size_t v9;
  unint64_t v10;
  uint64_t v11;
  void *v12;
  size_t v14;
  unint64_t v15;
  void *v16;
  unsigned int v17;
  void *v18;
  unsigned int v19;
  uint64_t *v20;
  unsigned int v21;

  v2 = a2;
  v4 = *((unsigned int *)this + 2);
  v5 = v4 - 1;
  v6 = this;
  if (v4 >= 0x41)
    v6 = (llvm::APInt *)(*(_QWORD *)this + 8 * (v5 >> 6));
  if (((*(_QWORD *)v6 >> v5) & 1) != 0)
  {
    if ((a2 & 0x8000000000000000) != 0)
    {
      v19 = *((_DWORD *)this + 2);
      if (v4 > 0x40)
      {
        v14 = ((unint64_t)(v4 + 63) >> 3) & 0x3FFFFFF8;
        v18 = (void *)operator new[]();
        memcpy(v18, *(const void **)this, v14);
        llvm::APInt::flipAllBitsSlowCase((uint64_t)&v18);
      }
      else
      {
        if ((_DWORD)v4)
          v8 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v4;
        else
          v8 = 0;
        v18 = (void *)(v8 & ~*(_QWORD *)this);
      }
      llvm::APInt::operator++((uint64_t)&v18);
      v21 = v19;
      v20 = (uint64_t *)v18;
      v19 = 0;
      v15 = llvm::APInt::urem(&v20, -(uint64_t)v2);
      if (v21 >= 0x41 && v20)
        MEMORY[0x1CAA32F9C](v20, 0x1000C8000313F17);
      v11 = -(uint64_t)v15;
      if (v19 < 0x41)
        return v11;
      v12 = v18;
      if (!v18)
        return v11;
    }
    else
    {
      v17 = *((_DWORD *)this + 2);
      if (v4 > 0x40)
      {
        v9 = ((unint64_t)(v4 + 63) >> 3) & 0x3FFFFFF8;
        v16 = (void *)operator new[]();
        memcpy(v16, *(const void **)this, v9);
        llvm::APInt::flipAllBitsSlowCase((uint64_t)&v16);
      }
      else
      {
        if ((_DWORD)v4)
          v7 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v4;
        else
          v7 = 0;
        v16 = (void *)(v7 & ~*(_QWORD *)this);
      }
      llvm::APInt::operator++((uint64_t)&v16);
      v21 = v17;
      v20 = (uint64_t *)v16;
      v17 = 0;
      v10 = llvm::APInt::urem(&v20, v2);
      if (v21 >= 0x41 && v20)
        MEMORY[0x1CAA32F9C](v20, 0x1000C8000313F17);
      v11 = -(uint64_t)v10;
      if (v17 < 0x41)
        return v11;
      v12 = v16;
      if (!v16)
        return v11;
    }
    MEMORY[0x1CAA32F9C](v12, 0x1000C8000313F17);
    return v11;
  }
  if ((a2 & 0x8000000000000000) != 0)
    a2 = -(uint64_t)a2;
  return llvm::APInt::urem((uint64_t **)this, a2);
}

void llvm::APInt::udivrem(llvm::APInt *this, unint64_t a2, unint64_t *a3, llvm::APInt *a4, unint64_t *a5)
{
  uint64_t v9;
  unint64_t v10;
  unsigned int v11;
  unsigned int v12;
  llvm::APInt *v13;
  unint64_t v14;
  unint64_t *v15;
  llvm::APInt *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  const llvm::APInt **v21;
  unsigned int v22;
  uint64_t v23;
  unsigned int v24;
  unint64_t v25;
  unint64_t v26;
  int v27;
  unint64_t v28;

  v28 = a2;
  v9 = *((unsigned int *)this + 2);
  if (v9 <= 0x40)
  {
    v25 = *(_QWORD *)this / a2;
    *(_QWORD *)a4 = *(_QWORD *)this % a2;
    v24 = v9;
  }
  else
  {
    v10 = ((unint64_t)(v9 - sub_1C5DCDAB0((uint64_t)this)) + 63) >> 6;
    if (!(_DWORD)v10)
    {
      v22 = v9;
      v23 = 0;
LABEL_33:
      sub_1C4832EA4((llvm::APInt *)&v26, v22, v23, 0);
      if (*((_DWORD *)a3 + 2) >= 0x41u && *a3)
        MEMORY[0x1CAA32F9C](*a3, 0x1000C8000313F17);
      *a3 = v26;
      *((_DWORD *)a3 + 2) = v27;
      goto LABEL_37;
    }
    if (a2 == 1)
    {
      sub_1C63817D4((void **)a3, (uint64_t)this);
LABEL_37:
      *(_QWORD *)a4 = 0;
      return;
    }
    v11 = *((_DWORD *)this + 2);
    if (v11 >= 0x41)
    {
      v12 = v11 - sub_1C5DCDAB0((uint64_t)this);
      v11 = *((_DWORD *)this + 2);
      if (v12 > 0x40)
        goto LABEL_9;
    }
    v13 = *(llvm::APInt **)this;
    if (v11 < 0x41)
      v13 = this;
    v14 = *(_QWORD *)v13;
    if (v14 >= a2)
    {
LABEL_9:
      if (v11 >= 0x41)
      {
        if (v11 - sub_1C5DCDAB0((uint64_t)this) > 0x40)
        {
LABEL_11:
          llvm::APInt::reallocate((uint64_t)a3, v9);
          v16 = *(llvm::APInt **)this;
          if ((_DWORD)v10 == 1)
          {
            v17 = *(_QWORD *)v16;
            v18 = *((unsigned int *)a3 + 2);
            v19 = *(_QWORD *)v16 / a2;
            if (v18 > 0x40)
            {
              *(_QWORD *)*a3 = v19;
              bzero((void *)(*a3 + 8), (((unint64_t)(v18 + 63) >> 3) - 8) & 0xFFFFFFF8);
            }
            else
            {
              if ((_DWORD)v18)
                v20 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v18;
              else
                v20 = 0;
              *a3 = v20 & v19;
            }
            *(_QWORD *)a4 = v17 - v19 * a2;
          }
          else
          {
            llvm::APInt::divide(v16, (const unint64_t *)v10, (uint64_t *)&v28, (const unint64_t *)1, (unint64_t *)*a3, (unint64_t *)a4, v15);
            bzero((void *)(*a3 + 8 * v10), 8 * (((unint64_t)(v9 + 63) >> 6) - v10));
          }
          return;
        }
        v11 = *((_DWORD *)this + 2);
      }
      v21 = *(const llvm::APInt ***)this;
      if (v11 < 0x41)
        v21 = (const llvm::APInt **)this;
      if (*v21 != (const llvm::APInt *)a2)
        goto LABEL_11;
      v22 = v9;
      v23 = 1;
      goto LABEL_33;
    }
    *(_QWORD *)a4 = v14;
    v24 = v9;
    v25 = 0;
  }
  sub_1C4832EA4((llvm::APInt *)&v26, v24, v25, 0);
  if (*((_DWORD *)a3 + 2) >= 0x41u && *a3)
    MEMORY[0x1CAA32F9C](*a3, 0x1000C8000313F17);
  *a3 = v26;
  *((_DWORD *)a3 + 2) = v27;
}

void llvm::APInt::sdivrem(llvm::APInt *this, const void **a2, const llvm::APInt *a3, llvm::APInt *a4, llvm::APInt *a5)
{
  uint64_t v9;
  uint64_t v10;
  llvm::APInt *v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  const void **v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  llvm::APInt *v19;
  unsigned int v20;
  unint64_t v21;
  unsigned int v22;
  unint64_t v23;
  llvm::APInt *v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  llvm::APInt *v29;
  unint64_t v30;
  llvm::APInt *v31;
  unsigned int v32;
  unint64_t v33;
  size_t v34;
  size_t v35;
  size_t v36;
  size_t v37;
  void *v38;
  unsigned int v39;
  void *v40;
  unsigned int v41;
  void *v42;
  unsigned int v43;
  void *v44;
  unsigned int v45;
  void *v46;
  unsigned int v47;
  llvm::APInt *v48;
  unsigned int v49;

  v9 = *((unsigned int *)this + 2);
  v10 = *(_QWORD *)this;
  v11 = (llvm::APInt *)(*(_QWORD *)this + 8 * ((v9 - 1) >> 6));
  if (v9 < 0x41)
    v11 = this;
  v12 = *(_QWORD *)v11;
  v13 = *((unsigned int *)a2 + 2);
  v14 = (unint64_t)*a2;
  v15 = (const void **)((char *)*a2 + 8 * ((v13 - 1) >> 6));
  if (v13 < 0x41)
    v15 = a2;
  v16 = (1 << (v13 - 1)) & (unint64_t)*v15;
  if (((v12 >> (v9 - 1)) & 1) != 0)
  {
    if (v16)
    {
      v47 = *((_DWORD *)this + 2);
      if (v9 > 0x40)
      {
        v35 = ((unint64_t)(v9 + 63) >> 3) & 0x3FFFFFF8;
        v46 = (void *)operator new[]();
        memcpy(v46, *(const void **)this, v35);
        llvm::APInt::flipAllBitsSlowCase((uint64_t)&v46);
      }
      else
      {
        v25 = ~v10;
        if ((_DWORD)v9)
          v26 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v9;
        else
          v26 = 0;
        v46 = (void *)(v26 & v25);
      }
      llvm::APInt::operator++((uint64_t)&v46);
      v49 = v47;
      v48 = (llvm::APInt *)v46;
      v47 = 0;
      v27 = *((unsigned int *)a2 + 2);
      v43 = v27;
      if (v27 > 0x40)
      {
        v36 = ((unint64_t)(v27 + 63) >> 3) & 0x3FFFFFF8;
        v42 = (void *)operator new[]();
        memcpy(v42, *a2, v36);
        llvm::APInt::flipAllBitsSlowCase((uint64_t)&v42);
      }
      else
      {
        if ((_DWORD)v27)
          v28 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v27;
        else
          v28 = 0;
        v42 = (void *)(v28 & ~(unint64_t)*a2);
      }
      llvm::APInt::operator++((uint64_t)&v42);
      v45 = v43;
      v44 = v42;
      v43 = 0;
      llvm::APInt::udivrem(&v48, (const llvm::APInt *)&v44, a3, a4, v29);
      if (v45 >= 0x41 && v44)
        MEMORY[0x1CAA32F9C](v44, 0x1000C8000313F17);
      if (v43 >= 0x41 && v42)
        MEMORY[0x1CAA32F9C](v42, 0x1000C8000313F17);
      if (v49 >= 0x41 && v48)
        MEMORY[0x1CAA32F9C](v48, 0x1000C8000313F17);
      if (v47 >= 0x41 && v46)
        MEMORY[0x1CAA32F9C](v46, 0x1000C8000313F17);
    }
    else
    {
      v41 = *((_DWORD *)this + 2);
      if (v9 > 0x40)
      {
        v34 = ((unint64_t)(v9 + 63) >> 3) & 0x3FFFFFF8;
        v40 = (void *)operator new[]();
        memcpy(v40, *(const void **)this, v34);
        llvm::APInt::flipAllBitsSlowCase((uint64_t)&v40);
      }
      else
      {
        v17 = ~v10;
        if ((_DWORD)v9)
          v18 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v9;
        else
          v18 = 0;
        v40 = (void *)(v18 & v17);
      }
      llvm::APInt::operator++((uint64_t)&v40);
      v49 = v41;
      v48 = (llvm::APInt *)v40;
      v41 = 0;
      llvm::APInt::udivrem(&v48, (const llvm::APInt *)a2, a3, a4, v19);
      if (v49 >= 0x41 && v48)
        MEMORY[0x1CAA32F9C](v48, 0x1000C8000313F17);
      if (v41 >= 0x41 && v40)
        MEMORY[0x1CAA32F9C](v40, 0x1000C8000313F17);
      v20 = *((_DWORD *)a3 + 2);
      if (v20 > 0x40)
      {
        llvm::APInt::flipAllBitsSlowCase((uint64_t)a3);
      }
      else
      {
        if (v20)
          v21 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v20;
        else
          v21 = 0;
        *(_QWORD *)a3 = v21 & ~*(_QWORD *)a3;
      }
      llvm::APInt::operator++((uint64_t)a3);
    }
    v22 = *((_DWORD *)a4 + 2);
    if (v22 > 0x40)
    {
      llvm::APInt::flipAllBitsSlowCase((uint64_t)a4);
    }
    else
    {
      if (v22)
        v23 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v22;
      else
        v23 = 0;
      *(_QWORD *)a4 = v23 & ~*(_QWORD *)a4;
    }
    v24 = a4;
  }
  else
  {
    if (!v16)
    {
      llvm::APInt::udivrem((llvm::APInt **)this, (const llvm::APInt *)a2, a3, a4, a5);
      return;
    }
    v39 = *((_DWORD *)a2 + 2);
    if (v13 > 0x40)
    {
      v37 = ((unint64_t)(v13 + 63) >> 3) & 0x3FFFFFF8;
      v38 = (void *)operator new[]();
      memcpy(v38, *a2, v37);
      llvm::APInt::flipAllBitsSlowCase((uint64_t)&v38);
    }
    else
    {
      v30 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v13;
      if (!(_DWORD)v13)
        v30 = 0;
      v38 = (void *)(v30 & ~v14);
    }
    llvm::APInt::operator++((uint64_t)&v38);
    v49 = v39;
    v48 = (llvm::APInt *)v38;
    v39 = 0;
    llvm::APInt::udivrem((llvm::APInt **)this, (const llvm::APInt *)&v48, a3, a4, v31);
    if (v49 >= 0x41 && v48)
      MEMORY[0x1CAA32F9C](v48, 0x1000C8000313F17);
    if (v39 >= 0x41 && v38)
      MEMORY[0x1CAA32F9C](v38, 0x1000C8000313F17);
    v32 = *((_DWORD *)a3 + 2);
    if (v32 > 0x40)
    {
      llvm::APInt::flipAllBitsSlowCase((uint64_t)a3);
    }
    else
    {
      if (v32)
        v33 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v32;
      else
        v33 = 0;
      *(_QWORD *)a3 = v33 & ~*(_QWORD *)a3;
    }
    v24 = a3;
  }
  llvm::APInt::operator++((uint64_t)v24);
}

void llvm::APInt::sdivrem(llvm::APInt *this, uint64_t a2, uint64_t a3, llvm::APInt *a4, unint64_t *a5)
{
  uint64_t v9;
  uint64_t v10;
  llvm::APInt *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  size_t v16;
  unint64_t *v17;
  unsigned int v18;
  unint64_t v19;
  unsigned int v20;
  unint64_t v21;
  size_t v22;
  unint64_t *v23;
  void *v24;
  unsigned int v25;
  void *v26;
  unsigned int v27;
  void *v28;
  unsigned int v29;
  uint64_t v30;

  v30 = *(_QWORD *)a4;
  v9 = *((unsigned int *)this + 2);
  v10 = *(_QWORD *)this;
  v11 = (llvm::APInt *)(*(_QWORD *)this + 8 * ((v9 - 1) >> 6));
  if (v9 < 0x41)
    v11 = this;
  if (((*(_QWORD *)v11 >> (v9 - 1)) & 1) != 0)
  {
    if (a2 < 0)
    {
      v27 = *((_DWORD *)this + 2);
      if (v9 > 0x40)
      {
        v22 = ((unint64_t)(v9 + 63) >> 3) & 0x3FFFFFF8;
        v26 = (void *)operator new[]();
        memcpy(v26, *(const void **)this, v22);
        llvm::APInt::flipAllBitsSlowCase((uint64_t)&v26);
      }
      else
      {
        v14 = ~v10;
        if ((_DWORD)v9)
          v15 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v9;
        else
          v15 = 0;
        v26 = (void *)(v15 & v14);
      }
      llvm::APInt::operator++((uint64_t)&v26);
      v29 = v27;
      v28 = v26;
      v27 = 0;
      llvm::APInt::udivrem((llvm::APInt *)&v28, -a2, (unint64_t *)a3, (llvm::APInt *)&v30, v23);
      if (v29 >= 0x41 && v28)
        MEMORY[0x1CAA32F9C](v28, 0x1000C8000313F17);
      if (v27 >= 0x41 && v26)
        MEMORY[0x1CAA32F9C](v26, 0x1000C8000313F17);
    }
    else
    {
      v25 = *((_DWORD *)this + 2);
      if (v9 > 0x40)
      {
        v16 = ((unint64_t)(v9 + 63) >> 3) & 0x3FFFFFF8;
        v24 = (void *)operator new[]();
        memcpy(v24, *(const void **)this, v16);
        llvm::APInt::flipAllBitsSlowCase((uint64_t)&v24);
      }
      else
      {
        v12 = ~v10;
        if ((_DWORD)v9)
          v13 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v9;
        else
          v13 = 0;
        v24 = (void *)(v13 & v12);
      }
      llvm::APInt::operator++((uint64_t)&v24);
      v29 = v25;
      v28 = v24;
      v25 = 0;
      llvm::APInt::udivrem((llvm::APInt *)&v28, a2, (unint64_t *)a3, (llvm::APInt *)&v30, v17);
      if (v29 >= 0x41 && v28)
        MEMORY[0x1CAA32F9C](v28, 0x1000C8000313F17);
      if (v25 >= 0x41 && v24)
        MEMORY[0x1CAA32F9C](v24, 0x1000C8000313F17);
      v18 = *(_DWORD *)(a3 + 8);
      if (v18 > 0x40)
      {
        llvm::APInt::flipAllBitsSlowCase(a3);
      }
      else
      {
        if (v18)
          v19 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v18;
        else
          v19 = 0;
        *(_QWORD *)a3 = v19 & ~*(_QWORD *)a3;
      }
      llvm::APInt::operator++(a3);
    }
    v30 = -v30;
  }
  else if (a2 < 0)
  {
    llvm::APInt::udivrem(this, -a2, (unint64_t *)a3, (llvm::APInt *)&v30, a5);
    v20 = *(_DWORD *)(a3 + 8);
    if (v20 > 0x40)
    {
      llvm::APInt::flipAllBitsSlowCase(a3);
    }
    else
    {
      if (v20)
        v21 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v20;
      else
        v21 = 0;
      *(_QWORD *)a3 = v21 & ~*(_QWORD *)a3;
    }
    llvm::APInt::operator++(a3);
  }
  else
  {
    llvm::APInt::udivrem(this, a2, (unint64_t *)a3, (llvm::APInt *)&v30, a5);
  }
  *(_QWORD *)a4 = v30;
}

const void **llvm::APInt::sadd_ov@<X0>(const void **this@<X0>, const llvm::APInt *a2@<X1>, BOOL *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v6;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  unsigned int v14;
  uint64_t v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _BOOL4 v20;
  _BOOL4 v21;
  unsigned int v22;
  char v23;
  unint64_t v24;
  _BOOL4 v25;
  unsigned int v26;
  const llvm::APInt *v27;
  BOOL v28;
  char *v29;

  v6 = (uint64_t)this;
  v8 = *((unsigned int *)this + 2);
  if (v8 < 0x41)
  {
    v9 = (unint64_t)*this;
    v10 = *(_QWORD *)a2;
    v11 = (unint64_t)*this + *(_QWORD *)a2;
    v12 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v8;
    if (!(_DWORD)v8)
      v12 = 0;
    v13 = (char *)(v12 & v11);
    *(_DWORD *)(a4 + 8) = v8;
    *(_QWORD *)a4 = v12 & v11;
    v14 = v8 - 1;
    goto LABEL_11;
  }
  v13 = (char *)operator new[]();
  v9 = *(_QWORD *)v6;
  this = (const void **)memcpy(v13, *(const void **)v6, ((unint64_t)(v8 + 63) >> 3) & 0x3FFFFFF8);
  v15 = 0;
  v16 = 0;
  v10 = *(_QWORD *)a2;
  v17 = (unint64_t)(v8 + 63) >> 6;
  do
  {
    v18 = *(_QWORD *)&v13[v15];
    v19 = *(_QWORD *)(v10 + v15) + v18;
    v20 = v19 < v18;
    v21 = v19 + 1 <= v18;
    if (v16)
    {
      ++v19;
      v16 = v21;
    }
    else
    {
      v16 = v20;
    }
    *(_QWORD *)&v13[v15] = v19;
    v15 += 8;
  }
  while (8 * v17 != v15);
  *(_QWORD *)&v13[8 * (v17 - 1)] &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v8;
  v22 = *(_DWORD *)(v6 + 8);
  *(_DWORD *)(a4 + 8) = v8;
  *(_QWORD *)a4 = v13;
  v14 = v22 - 1;
  if (v22 < 0x41)
  {
LABEL_11:
    v23 = 1;
    v24 = v9;
    goto LABEL_13;
  }
  v23 = 0;
  v24 = *(_QWORD *)(v9 + 8 * (v14 >> 6));
LABEL_13:
  v25 = (v24 & (1 << v14)) == 0;
  v26 = *((_DWORD *)a2 + 2);
  v27 = (const llvm::APInt *)(v10 + 8 * ((v26 - 1) >> 6));
  if (v26 < 0x41)
    v27 = a2;
  if (((v25 ^ (((*(_QWORD *)v27 >> (v26 - 1)) & 1) == 0)) & 1) != 0)
  {
    v28 = 0;
  }
  else
  {
    v29 = &v13[8 * ((v8 - 1) >> 6)];
    if (v8 < 0x41)
      v29 = (char *)a4;
    if ((v23 & 1) == 0)
      v9 = *(_QWORD *)(v9 + 8 * (v14 >> 6));
    v28 = ((*(_QWORD *)v29 & (1 << (v8 - 1))) == 0) ^ ((v9 & (1 << v14)) == 0);
  }
  *a3 = v28;
  return this;
}

const void **llvm::APInt::uadd_ov@<X0>(const void **this@<X0>, uint64_t **a2@<X1>, BOOL *a3@<X2>, uint64_t a4@<X8>)
{
  const void **v6;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t *v14;
  unint64_t v15;
  unint64_t *v16;
  uint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  _BOOL4 v21;
  uint64_t *v22;
  unint64_t v23;
  unint64_t v24;

  v6 = this;
  v8 = *((unsigned int *)this + 2);
  if (v8 >= 0x41)
  {
    v12 = (char *)operator new[]();
    this = (const void **)memcpy(v12, *v6, ((unint64_t)(v8 + 63) >> 3) & 0x3FFFFFF8);
    v13 = 0;
    v14 = *a2;
    v15 = (unint64_t)(v8 + 63) >> 6;
    v16 = (unint64_t *)v12;
    v17 = *a2;
    v18 = v15;
    do
    {
      v19 = *v17++;
      v20 = v19 + *v16;
      v21 = v20 + 1 <= *v16;
      if (v13)
      {
        ++v20;
        v13 = v21;
      }
      else
      {
        v13 = v20 < *v16;
      }
      *v16++ = v20;
      --v18;
    }
    while (v18);
    *(_QWORD *)&v12[8 * (v15 - 1)] &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v8;
    *(_DWORD *)(a4 + 8) = v8;
    *(_QWORD *)a4 = v12;
    v22 = v14 - 1;
    v11 = 8 * v15;
    while (v11)
    {
      v23 = *(_QWORD *)&v12[v11 - 8];
      v24 = *(uint64_t *)((char *)v22 + v11);
      v11 -= 8;
      if (v23 != v24)
      {
        LOBYTE(v11) = v23 <= v24;
        break;
      }
    }
  }
  else
  {
    v9 = (unint64_t)*a2;
    v10 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v8;
    if (!(_DWORD)v8)
      v10 = 0;
    v11 = v10 & ((unint64_t)*this + (_QWORD)*a2);
    *(_DWORD *)(a4 + 8) = v8;
    *(_QWORD *)a4 = v11;
    LOBYTE(v11) = v11 < v9;
  }
  *a3 = v11;
  return this;
}

const void **llvm::APInt::ssub_ov@<X0>(const void **this@<X0>, const llvm::APInt *a2@<X1>, BOOL *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v6;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  unsigned int v14;
  uint64_t v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  _BOOL4 v21;
  unint64_t v22;
  _BOOL4 v23;
  unsigned int v24;
  char v25;
  unint64_t v26;
  _BOOL4 v27;
  unsigned int v28;
  const llvm::APInt *v29;
  char *v30;
  BOOL v31;

  v6 = (uint64_t)this;
  v8 = *((unsigned int *)this + 2);
  if (v8 < 0x41)
  {
    v9 = (unint64_t)*this;
    v10 = *(_QWORD *)a2;
    v11 = (unint64_t)*this - *(_QWORD *)a2;
    v12 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v8;
    if (!(_DWORD)v8)
      v12 = 0;
    v13 = (char *)(v12 & v11);
    *(_DWORD *)(a4 + 8) = v8;
    *(_QWORD *)a4 = v12 & v11;
    v14 = v8 - 1;
    goto LABEL_11;
  }
  v13 = (char *)operator new[]();
  v9 = *(_QWORD *)v6;
  this = (const void **)memcpy(v13, *(const void **)v6, ((unint64_t)(v8 + 63) >> 3) & 0x3FFFFFF8);
  v15 = 0;
  v16 = 0;
  v10 = *(_QWORD *)a2;
  v17 = (unint64_t)(v8 + 63) >> 6;
  do
  {
    v18 = *(_QWORD *)&v13[v15];
    v19 = *(_QWORD *)(v10 + v15);
    v20 = v18 - v19;
    v21 = v18 < v19;
    v22 = v18 + ~v19;
    v23 = v22 >= v18;
    if (v16)
    {
      v16 = v23;
    }
    else
    {
      v22 = v20;
      v16 = v21;
    }
    *(_QWORD *)&v13[v15] = v22;
    v15 += 8;
  }
  while (8 * v17 != v15);
  *(_QWORD *)&v13[8 * (v17 - 1)] &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v8;
  v24 = *(_DWORD *)(v6 + 8);
  *(_DWORD *)(a4 + 8) = v8;
  *(_QWORD *)a4 = v13;
  v14 = v24 - 1;
  if (v24 < 0x41)
  {
LABEL_11:
    v25 = 1;
    v26 = v9;
    goto LABEL_13;
  }
  v25 = 0;
  v26 = *(_QWORD *)(v9 + 8 * (v14 >> 6));
LABEL_13:
  v27 = (v26 & (1 << v14)) == 0;
  v28 = *((_DWORD *)a2 + 2);
  v29 = (const llvm::APInt *)(v10 + 8 * ((v28 - 1) >> 6));
  if (v28 < 0x41)
    v29 = a2;
  if (v27 == (((*(_QWORD *)v29 >> (v28 - 1)) & 1) == 0))
  {
    v31 = 0;
  }
  else
  {
    v30 = &v13[8 * ((v8 - 1) >> 6)];
    if (v8 < 0x41)
      v30 = (char *)a4;
    if ((v25 & 1) == 0)
      v9 = *(_QWORD *)(v9 + 8 * (v14 >> 6));
    v31 = ((*(_QWORD *)v30 & (1 << (v8 - 1))) == 0) ^ ((v9 & (1 << v14)) == 0);
  }
  *a3 = v31;
  return this;
}

const void **llvm::APInt::usub_ov@<X0>(const void **this@<X0>, unint64_t **a2@<X1>, BOOL *a3@<X2>, uint64_t a4@<X8>)
{
  const void **v6;
  uint64_t v8;
  const void *v9;
  unint64_t v10;
  unint64_t v11;
  BOOL v12;
  char *v13;
  char *v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  _BOOL4 v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;

  v6 = this;
  v8 = *((unsigned int *)this + 2);
  if (v8 >= 0x41)
  {
    v13 = (char *)operator new[]();
    v14 = (char *)*v6;
    this = (const void **)memcpy(v13, v14, ((unint64_t)(v8 + 63) >> 3) & 0x3FFFFFF8);
    v15 = 0;
    v16 = *a2;
    v17 = (unint64_t)(v8 + 63) >> 6;
    v18 = (unint64_t *)v13;
    v19 = v17;
    do
    {
      v20 = *v16++;
      v21 = *v18 - v20;
      v22 = *v18 < v20;
      v23 = *v18 + ~v20;
      if (v15)
      {
        v15 = v23 >= *v18;
      }
      else
      {
        v23 = v21;
        v15 = v22;
      }
      *v18++ = v23;
      --v19;
    }
    while (v19);
    *(_QWORD *)&v13[8 * (v17 - 1)] &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v8;
    *(_DWORD *)(a4 + 8) = v8;
    *(_QWORD *)a4 = v13;
    v24 = 8 * v17;
    while (v24)
    {
      v25 = *(_QWORD *)&v13[v24 - 8];
      v26 = *(_QWORD *)&v14[v24 - 8];
      v24 -= 8;
      v12 = v25 > v26;
      if (v25 != v26)
        goto LABEL_13;
    }
  }
  else
  {
    v9 = *this;
    v10 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v8;
    if (!(_DWORD)v8)
      v10 = 0;
    v11 = v10 & ((_BYTE *)*this - (_BYTE *)*a2);
    *(_DWORD *)(a4 + 8) = v8;
    *(_QWORD *)a4 = v11;
    v12 = v11 > (unint64_t)v9;
LABEL_13:
    LOBYTE(v24) = v12;
  }
  *a3 = v24;
  return this;
}

void llvm::APInt::sdiv_ov(llvm::APInt *this@<X0>, const void **a2@<X1>, BOOL *a3@<X2>, llvm::APInt *a4@<X8>)
{
  _BOOL4 v8;

  v8 = sub_1C535BACC((uint64_t)this);
  if (v8)
    LOBYTE(v8) = sub_1C5DCD6E4((uint64_t)a2);
  *a3 = v8;
  llvm::APInt::sdiv(this, a2, a4);
}

BOOL sub_1C5DCD6E4(uint64_t a1)
{
  uint64_t v1;
  uint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  int v7;
  unint64_t v8;

  v1 = *(unsigned int *)(a1 + 8);
  if (!(_DWORD)v1)
    return 1;
  if (v1 >= 0x41)
  {
    v4 = 0;
    v5 = (unint64_t)(v1 + 63) >> 6;
    v6 = *(_QWORD **)a1;
    v7 = (_DWORD)v5 << 6;
    v8 = v5 << 6;
    while (*v6 == -1)
    {
      ++v6;
      v4 += 64;
      if (v8 == v4)
        return v7 == (_DWORD)v1;
    }
    v7 = __clz(__rbit64(~*v6)) + v4;
    return v7 == (_DWORD)v1;
  }
  else
  {
    return *(_QWORD *)a1 == 0xFFFFFFFFFFFFFFFFLL >> -(char)v1;
  }
}

uint64_t llvm::APInt::smul_ov@<X0>(const void **this@<X0>, const llvm::APInt *a2@<X1>, BOOL *a3@<X2>, llvm::APInt *a4@<X8>)
{
  uint64_t result;
  unsigned int v9;
  const llvm::APInt *v10;
  void *__s1;
  unsigned int v12;

  result = llvm::APInt::operator*((uint64_t)this, a2, (uint64_t)a4);
  v9 = *((_DWORD *)a2 + 2);
  if (v9 >= 0x41)
  {
    result = sub_1C5DCDAB0((uint64_t)a2);
    if (v9 - result > 0x40)
      goto LABEL_7;
    v9 = *((_DWORD *)a2 + 2);
  }
  v10 = *(const llvm::APInt **)a2;
  if (v9 < 0x41)
    v10 = a2;
  if (!*(_QWORD *)v10)
  {
    *a3 = 0;
    return result;
  }
LABEL_7:
  llvm::APInt::sdiv(a4, (const void **)a2, (llvm::APInt *)&__s1);
  if (v12 > 0x40)
  {
    if (!memcmp(__s1, *this, (((unint64_t)v12 + 63) >> 3) & 0x3FFFFFF8))
    {
LABEL_9:
      result = sub_1C535BACC((uint64_t)this);
      if ((_DWORD)result)
        result = sub_1C5DCD6E4((uint64_t)a2);
      goto LABEL_13;
    }
  }
  else if (__s1 == *this)
  {
    goto LABEL_9;
  }
  result = 1;
LABEL_13:
  *a3 = result;
  if (v12 >= 0x41)
  {
    result = (uint64_t)__s1;
    if (__s1)
      return MEMORY[0x1CAA32F9C](__s1, 0x1000C8000313F17);
  }
  return result;
}

uint64_t llvm::APInt::umul_ov@<X0>(llvm::APInt *this@<X0>, uint64_t **a2@<X1>, BOOL *a3@<X2>, uint64_t a4@<X8>)
{
  llvm::APInt *v6;
  int v8;
  unsigned int v9;
  char v10;
  _QWORD *v11;
  uint64_t result;
  uint64_t v13;
  uint64_t *v14;
  unint64_t v15;
  unint64_t *v16;
  uint64_t v17;
  unint64_t *v18;
  uint64_t *v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  _BOOL4 v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unsigned int v30;

  v6 = this;
  v8 = sub_1C5DCDAB0((uint64_t)this);
  if (v8 + sub_1C5DCDAB0((uint64_t)a2) + 2 <= *((_DWORD *)v6 + 2))
  {
    *a3 = 1;
    return llvm::APInt::operator*((uint64_t)v6, a2, a4);
  }
  sub_1C5CEB1E4((uint64_t)v6, 1u, (uint64_t)&v29);
  llvm::APInt::operator*((uint64_t)&v29, a2, a4);
  if (v30 >= 0x41 && v29)
    MEMORY[0x1CAA32F9C](v29, 0x1000C8000313F17);
  v9 = *(_DWORD *)(a4 + 8);
  v10 = v9 - 1;
  if (v9 >= 0x41)
    v11 = (_QWORD *)(*(_QWORD *)a4 + 8 * ((v9 - 1) >> 6));
  else
    v11 = (_QWORD *)a4;
  *a3 = (*v11 >> v10) & 1;
  result = sub_1C4888094(a4, 1u);
  if (*((_DWORD *)v6 + 2) >= 0x41u)
    v6 = *(llvm::APInt **)v6;
  if ((*(_BYTE *)v6 & 1) != 0)
  {
    v13 = *(unsigned int *)(a4 + 8);
    if (v13 < 0x41)
    {
      v14 = *a2;
      if ((_DWORD)v13)
        v15 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v13;
      else
        v15 = 0;
      v16 = (unint64_t *)(v15 & ((unint64_t)*a2 + *(_QWORD *)a4));
      *(_QWORD *)a4 = v16;
LABEL_16:
      if (v16 < (unint64_t *)v14)
LABEL_17:
        *a3 = 1;
      return result;
    }
    v17 = 0;
    v18 = *(unint64_t **)a4;
    v19 = *a2;
    v20 = (unint64_t)(v13 + 63) >> 6;
    v21 = v20;
    do
    {
      v22 = *v19++;
      v23 = v22 + *v18;
      v24 = v23 + 1 <= *v18;
      if (v17)
      {
        ++v23;
        v17 = v24;
      }
      else
      {
        v17 = v23 < *v18;
      }
      *v18++ = v23;
      --v21;
    }
    while (v21);
    *(_QWORD *)(*(_QWORD *)a4 + 8 * (v20 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v13;
    v25 = *(unsigned int *)(a4 + 8);
    if (v25 <= 0x40)
    {
      v16 = *(unint64_t **)a4;
      v14 = *a2;
      goto LABEL_16;
    }
    v26 = ((unint64_t)(v25 + 63) >> 3) & 0x3FFFFFF8;
    while (v26)
    {
      v27 = *(_QWORD *)(*(_QWORD *)a4 - 8 + v26);
      v28 = *(uint64_t *)((char *)*a2 + v26 - 8);
      v26 -= 8;
      if (v27 != v28)
      {
        if (v27 <= v28)
          goto LABEL_17;
        return result;
      }
    }
  }
  return result;
}

uint64_t sub_1C5DCDAB0(uint64_t a1)
{
  uint64_t v1;
  int v3;
  int64_t v4;
  unint64_t v6;
  int v7;

  v1 = *(unsigned int *)(a1 + 8);
  if (v1 <= 0x40)
    return v1 + __clz(*(_QWORD *)a1) - 64;
  v3 = 0;
  v4 = (unint64_t)(v1 + 63) >> 6;
  do
  {
    if (v4-- < 1)
      break;
    v6 = *(_QWORD *)(*(_QWORD *)a1 + 8 * v4);
    v3 += __clz(v6);
  }
  while (!v6);
  if ((v1 & 0x3F) != 0)
    v7 = v1 | 0xFFFFFFC0;
  else
    v7 = 0;
  return (v3 + v7);
}

llvm::APInt *llvm::APInt::sshl_ov@<X0>(llvm::APInt *this@<X0>, const llvm::APInt *a2@<X1>, BOOL *a3@<X2>, unsigned int *a4@<X8>)
{
  unint64_t v8;
  unsigned int v9;
  unsigned int v10;
  const llvm::APInt *v11;
  BOOL v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  const llvm::APInt *v17;
  BOOL v18;
  unsigned int v19;

  v8 = *((unsigned int *)this + 2);
  v9 = *((_DWORD *)a2 + 2);
  if (v9 >= 0x41)
  {
    if (v9 - sub_1C5DCDAB0((uint64_t)a2) > 0x40)
    {
      *a3 = 1;
      v10 = *((_DWORD *)this + 2);
      return sub_1C4832EA4((llvm::APInt *)a4, v10, 0, 0);
    }
    v9 = *((_DWORD *)a2 + 2);
    v10 = *((_DWORD *)this + 2);
  }
  else
  {
    v10 = *((_DWORD *)this + 2);
  }
  v11 = *(const llvm::APInt **)a2;
  if (v9 < 0x41)
    v11 = a2;
  v12 = *(_QWORD *)v11 >= v8;
  *a3 = v12;
  if (v12)
    return sub_1C4832EA4((llvm::APInt *)a4, v10, 0, 0);
  v13 = v10 - 1;
  if (v10 > 0x40)
  {
    if (((*(_QWORD *)(*(_QWORD *)this + 8 * (v13 >> 6)) >> v13) & 1) != 0)
    {
      v15 = llvm::APInt::countLeadingOnesSlowCase(this);
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  if (((*(_QWORD *)this >> v13) & 1) == 0)
  {
LABEL_17:
    v15 = sub_1C5DCDAB0((uint64_t)this);
    v9 = *((_DWORD *)a2 + 2);
    goto LABEL_18;
  }
  v14 = __clz(~(*(_QWORD *)this << -(char)v10));
  if (v10)
    v15 = v14;
  else
    v15 = 0;
LABEL_18:
  if (v9 < 0x41)
  {
LABEL_21:
    v17 = *(const llvm::APInt **)a2;
    if (v9 < 0x41)
      v17 = a2;
    v18 = *(_QWORD *)v17 >= (unint64_t)v15;
    goto LABEL_25;
  }
  if (v9 - sub_1C5DCDAB0((uint64_t)a2) <= 0x40)
  {
    v9 = *((_DWORD *)a2 + 2);
    goto LABEL_21;
  }
  v18 = 1;
LABEL_25:
  *a3 = v18;
  sub_1C5DD14E0((uint64_t)a4, (uint64_t)this);
  v19 = sub_1C47EE5B8((uint64_t ***)a2, a4[2]);
  return (llvm::APInt *)sub_1C4888094((uint64_t)a4, v19);
}

llvm::APInt *llvm::APInt::ushl_ov@<X0>(llvm::APInt *this@<X0>, const llvm::APInt *a2@<X1>, BOOL *a3@<X2>, unsigned int *a4@<X8>)
{
  unint64_t v8;
  unsigned int v9;
  const llvm::APInt *v10;
  BOOL v11;
  unsigned int v12;
  unsigned int v13;
  BOOL v14;
  const llvm::APInt *v16;
  unsigned int v17;

  v8 = *((unsigned int *)this + 2);
  v9 = *((_DWORD *)a2 + 2);
  if (v9 >= 0x41)
  {
    if (v9 - sub_1C5DCDAB0((uint64_t)a2) > 0x40)
    {
      *a3 = 1;
      return sub_1C4832EA4((llvm::APInt *)a4, *((_DWORD *)this + 2), 0, 0);
    }
    v9 = *((_DWORD *)a2 + 2);
  }
  v10 = *(const llvm::APInt **)a2;
  if (v9 < 0x41)
    v10 = a2;
  v11 = *(_QWORD *)v10 >= v8;
  *a3 = v11;
  if (v11)
    return sub_1C4832EA4((llvm::APInt *)a4, *((_DWORD *)this + 2), 0, 0);
  v12 = sub_1C5DCDAB0((uint64_t)this);
  v13 = *((_DWORD *)a2 + 2);
  if (v13 < 0x41)
  {
LABEL_13:
    v16 = *(const llvm::APInt **)a2;
    if (v13 < 0x41)
      v16 = a2;
    v14 = *(_QWORD *)v16 > (unint64_t)v12;
    goto LABEL_16;
  }
  if (v13 - sub_1C5DCDAB0((uint64_t)a2) <= 0x40)
  {
    v13 = *((_DWORD *)a2 + 2);
    goto LABEL_13;
  }
  v14 = 1;
LABEL_16:
  *a3 = v14;
  sub_1C5DD14E0((uint64_t)a4, (uint64_t)this);
  v17 = sub_1C47EE5B8((uint64_t ***)a2, a4[2]);
  return (llvm::APInt *)sub_1C4888094((uint64_t)a4, v17);
}

void *llvm::APInt::sadd_sat@<X0>(const void **this@<X0>, const llvm::APInt *a2@<X1>, llvm::APInt *a3@<X8>)
{
  const void **v3;
  void *result;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  unsigned int v11;
  BOOL v12;

  v3 = this;
  v12 = 0;
  result = llvm::APInt::sadd_ov(this, a2, &v12, (uint64_t)&v10);
  if (v12)
  {
    v6 = *((_DWORD *)v3 + 2);
    v7 = v6 - 1;
    if (v6 >= 0x41)
      v3 = (const void **)((char *)*v3 + 8 * (v7 >> 6));
    v8 = 1 << v7;
    if (((unint64_t)*v3 & (1 << v7)) != 0)
    {
      result = sub_1C4832EA4(a3, v6, 0, 0);
      if (*((_DWORD *)a3 + 2) >= 0x41u)
        a3 = (llvm::APInt *)(*(_QWORD *)a3 + 8 * (v7 >> 6));
      v9 = *(_QWORD *)a3 | v8;
    }
    else
    {
      result = sub_1C4832EA4(a3, v6, -1, 1);
      if (*((_DWORD *)a3 + 2) >= 0x41u)
        a3 = (llvm::APInt *)(*(_QWORD *)a3 + 8 * (v7 >> 6));
      v9 = *(_QWORD *)a3 & ~v8;
    }
    *(_QWORD *)a3 = v9;
  }
  else
  {
    *((_DWORD *)a3 + 2) = v11;
    *(_QWORD *)a3 = v10;
    v11 = 0;
  }
  if (v11 >= 0x41)
  {
    result = v10;
    if (v10)
      JUMPOUT(0x1CAA32F9CLL);
  }
  return result;
}

void *llvm::APInt::uadd_sat@<X0>(llvm::APInt *this@<X0>, uint64_t **a2@<X1>, llvm::APInt *a3@<X8>)
{
  void *result;
  void *v6;
  unsigned int v7;
  BOOL v8;

  v8 = 0;
  result = llvm::APInt::uadd_ov((const void **)this, a2, &v8, (uint64_t)&v6);
  if (v8)
  {
    result = sub_1C4832EA4(a3, *((_DWORD *)this + 2), -1, 1);
    if (v7 >= 0x41)
    {
      result = v6;
      if (v6)
        JUMPOUT(0x1CAA32F9CLL);
    }
  }
  else
  {
    *((_DWORD *)a3 + 2) = v7;
    *(_QWORD *)a3 = v6;
  }
  return result;
}

void *llvm::APInt::ssub_sat@<X0>(const void **this@<X0>, const llvm::APInt *a2@<X1>, llvm::APInt *a3@<X8>)
{
  const void **v3;
  void *result;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  unsigned int v11;
  BOOL v12;

  v3 = this;
  v12 = 0;
  result = llvm::APInt::ssub_ov(this, a2, &v12, (uint64_t)&v10);
  if (v12)
  {
    v6 = *((_DWORD *)v3 + 2);
    v7 = v6 - 1;
    if (v6 >= 0x41)
      v3 = (const void **)((char *)*v3 + 8 * (v7 >> 6));
    v8 = 1 << v7;
    if (((unint64_t)*v3 & (1 << v7)) != 0)
    {
      result = sub_1C4832EA4(a3, v6, 0, 0);
      if (*((_DWORD *)a3 + 2) >= 0x41u)
        a3 = (llvm::APInt *)(*(_QWORD *)a3 + 8 * (v7 >> 6));
      v9 = *(_QWORD *)a3 | v8;
    }
    else
    {
      result = sub_1C4832EA4(a3, v6, -1, 1);
      if (*((_DWORD *)a3 + 2) >= 0x41u)
        a3 = (llvm::APInt *)(*(_QWORD *)a3 + 8 * (v7 >> 6));
      v9 = *(_QWORD *)a3 & ~v8;
    }
    *(_QWORD *)a3 = v9;
  }
  else
  {
    *((_DWORD *)a3 + 2) = v11;
    *(_QWORD *)a3 = v10;
    v11 = 0;
  }
  if (v11 >= 0x41)
  {
    result = v10;
    if (v10)
      JUMPOUT(0x1CAA32F9CLL);
  }
  return result;
}

void *llvm::APInt::usub_sat@<X0>(llvm::APInt *this@<X0>, unint64_t **a2@<X1>, llvm::APInt *a3@<X8>)
{
  void *result;
  void *v6;
  unsigned int v7;
  BOOL v8;

  v8 = 0;
  result = llvm::APInt::usub_ov((const void **)this, a2, &v8, (uint64_t)&v6);
  if (v8)
  {
    result = sub_1C4832EA4(a3, *((_DWORD *)this + 2), 0, 0);
    if (v7 >= 0x41)
    {
      result = v6;
      if (v6)
        JUMPOUT(0x1CAA32F9CLL);
    }
  }
  else
  {
    *((_DWORD *)a3 + 2) = v7;
    *(_QWORD *)a3 = v6;
  }
  return result;
}

uint64_t llvm::APInt::smul_sat@<X0>(const void **this@<X0>, const llvm::APInt *a2@<X1>, llvm::APInt *a3@<X8>)
{
  const void **v4;
  uint64_t result;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  char v11;
  const llvm::APInt *v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  BOOL v16;

  v4 = this;
  v16 = 0;
  result = llvm::APInt::smul_ov(this, a2, &v16, (llvm::APInt *)&v14);
  if (v16)
  {
    v7 = *((_DWORD *)v4 + 2);
    v8 = v7 - 1;
    if (v7 >= 0x41)
      v4 = (const void **)((char *)*v4 + 8 * (v8 >> 6));
    v9 = 1 << v8;
    v10 = *((_DWORD *)a2 + 2);
    v11 = v10 - 1;
    if (v10 >= 0x41)
      v12 = (const llvm::APInt *)(*(_QWORD *)a2 + 8 * ((v10 - 1) >> 6));
    else
      v12 = a2;
    if ((((unint64_t)*v4 & (1 << v8)) != 0) == ((*(_QWORD *)v12 >> v11) & 1))
    {
      result = (uint64_t)sub_1C4832EA4(a3, v7, -1, 1);
      if (*((_DWORD *)a3 + 2) >= 0x41u)
        a3 = (llvm::APInt *)(*(_QWORD *)a3 + 8 * (v8 >> 6));
      v13 = *(_QWORD *)a3 & ~v9;
    }
    else
    {
      result = (uint64_t)sub_1C4832EA4(a3, v7, 0, 0);
      if (*((_DWORD *)a3 + 2) >= 0x41u)
        a3 = (llvm::APInt *)(*(_QWORD *)a3 + 8 * (v8 >> 6));
      v13 = *(_QWORD *)a3 | v9;
    }
    *(_QWORD *)a3 = v13;
  }
  else
  {
    *((_DWORD *)a3 + 2) = v15;
    *(_QWORD *)a3 = v14;
    v15 = 0;
  }
  if (v15 >= 0x41)
  {
    result = v14;
    if (v14)
      return MEMORY[0x1CAA32F9C](v14, 0x1000C8000313F17);
  }
  return result;
}

uint64_t llvm::APInt::umul_sat@<X0>(llvm::APInt *this@<X0>, uint64_t **a2@<X1>, llvm::APInt *a3@<X8>)
{
  uint64_t result;
  uint64_t v6;
  unsigned int v7;
  BOOL v8;

  v8 = 0;
  result = llvm::APInt::umul_ov(this, a2, &v8, (uint64_t)&v6);
  if (v8)
  {
    result = (uint64_t)sub_1C4832EA4(a3, *((_DWORD *)this + 2), -1, 1);
    if (v7 >= 0x41)
    {
      result = v6;
      if (v6)
        return MEMORY[0x1CAA32F9C](v6, 0x1000C8000313F17);
    }
  }
  else
  {
    *((_DWORD *)a3 + 2) = v7;
    *(_QWORD *)a3 = v6;
  }
  return result;
}

llvm::APInt *llvm::APInt::sshl_sat@<X0>(llvm::APInt *this@<X0>, const llvm::APInt *a2@<X1>, llvm::APInt *a3@<X8>)
{
  llvm::APInt *v3;
  llvm::APInt *result;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  llvm::APInt *v10;
  unsigned int v11;
  BOOL v12;

  v3 = this;
  v12 = 0;
  result = llvm::APInt::sshl_ov(this, a2, &v12, (unsigned int *)&v10);
  if (v12)
  {
    v6 = *((_DWORD *)v3 + 2);
    v7 = v6 - 1;
    if (v6 >= 0x41)
      v3 = (llvm::APInt *)(*(_QWORD *)v3 + 8 * (v7 >> 6));
    v8 = 1 << v7;
    if ((*(_QWORD *)v3 & (1 << v7)) != 0)
    {
      result = sub_1C4832EA4(a3, v6, 0, 0);
      if (*((_DWORD *)a3 + 2) >= 0x41u)
        a3 = (llvm::APInt *)(*(_QWORD *)a3 + 8 * (v7 >> 6));
      v9 = *(_QWORD *)a3 | v8;
    }
    else
    {
      result = sub_1C4832EA4(a3, v6, -1, 1);
      if (*((_DWORD *)a3 + 2) >= 0x41u)
        a3 = (llvm::APInt *)(*(_QWORD *)a3 + 8 * (v7 >> 6));
      v9 = *(_QWORD *)a3 & ~v8;
    }
    *(_QWORD *)a3 = v9;
  }
  else
  {
    *((_DWORD *)a3 + 2) = v11;
    *(_QWORD *)a3 = v10;
    v11 = 0;
  }
  if (v11 >= 0x41)
  {
    result = v10;
    if (v10)
      return (llvm::APInt *)MEMORY[0x1CAA32F9C](v10, 0x1000C8000313F17);
  }
  return result;
}

void llvm::APInt::toString(uint64_t a1, _QWORD *a2, unsigned int a3, int a4, int a5)
{
  unint64_t v9;
  const char *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  unsigned __int8 *v16;
  int v17;
  int v18;
  int64_t v19;
  BOOL v20;
  unint64_t v21;
  int v22;
  char v23;
  uint64_t v24;
  unsigned __int8 *v25;
  int v26;
  uint64_t v27;
  BOOL v28;
  uint64_t v29;
  size_t v30;
  unint64_t v31;
  unint64_t *v32;
  unsigned int v33;
  unsigned int v34;
  uint64_t v35;
  char v36;
  uint64_t v37;
  unsigned __int8 *v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  int v43;
  unsigned int v44;
  unsigned int v45;
  uint64_t v46;
  int v47;
  int64_t v48;
  unint64_t v49;
  unsigned int v50;
  char v51;
  uint64_t v52;
  uint64_t i;
  _BYTE *v54;
  unint64_t v55;
  char v56;
  int v57;
  int64_t v58;
  unint64_t v59;
  unsigned int v60;
  char v61;
  uint64_t v62;
  uint64_t v63;
  llvm::APInt *v64;
  unsigned int v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  if (a5)
  {
    HIDWORD(v9) = a3;
    LODWORD(v9) = a3 - 2;
    v10 = off_1E819D218[(int)(v9 >> 1)];
  }
  else
  {
    v10 = "";
  }
  v11 = *(unsigned int *)(a1 + 8);
  if (v11 <= 0x40)
  {
    v12 = *(_QWORD *)a1;
    if (*(_QWORD *)a1)
    {
      if (a4)
      {
        v12 = (uint64_t)(v12 << -(char)v11) >> -(char)v11;
        if ((v12 & 0x8000000000000000) != 0)
        {
          v13 = a2[1];
          if ((unint64_t)(v13 + 1) > a2[2])
          {
            llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a2, a2 + 3, v13 + 1, 1);
            v13 = a2[1];
          }
          *(_BYTE *)(*a2 + v13) = 45;
          ++a2[1];
          v12 = -(uint64_t)v12;
        }
      }
      v14 = *v10;
      if (*v10)
      {
        v15 = a2[1];
        v16 = (unsigned __int8 *)(v10 + 1);
        do
        {
          if ((unint64_t)(v15 + 1) > a2[2])
          {
            llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a2, a2 + 3, v15 + 1, 1);
            v15 = a2[1];
          }
          *(_BYTE *)(*a2 + v15) = v14;
          v15 = a2[1] + 1;
          a2[1] = v15;
          v17 = *v16++;
          v14 = v17;
        }
        while (v17);
      }
      if (v12)
      {
        v27 = 64;
        do
        {
          *((_BYTE *)&v64 + v27--) = a0123456789abcd_3[v12 % a3];
          v28 = v12 >= a3;
          v12 /= a3;
        }
        while (v28);
        v29 = v27 + 1;
      }
      else
      {
        v29 = 65;
      }
      v41 = a2[1];
      v42 = v41 + 65 - v29;
      if (a2[2] < v42)
      {
        llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a2, a2 + 3, v42, 1);
        v41 = a2[1];
      }
      if (v29 != 65)
      {
        memcpy((void *)(*a2 + v41), (char *)&v64 + v29, 65 - v29);
        v41 = a2[1];
      }
      v40 = v41 + 65 - v29;
LABEL_56:
      a2[1] = v40;
      return;
    }
LABEL_23:
    v23 = *v10;
    if (*v10)
    {
      v24 = a2[1];
      v25 = (unsigned __int8 *)(v10 + 1);
      do
      {
        if ((unint64_t)(v24 + 1) > a2[2])
        {
          llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a2, a2 + 3, v24 + 1, 1);
          v24 = a2[1];
        }
        *(_BYTE *)(*a2 + v24) = v23;
        v24 = a2[1] + 1;
        a2[1] = v24;
        v26 = *v25++;
        v23 = v26;
      }
      while (v26);
    }
    else
    {
      v24 = a2[1];
    }
    if ((unint64_t)(v24 + 1) > a2[2])
    {
      llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a2, a2 + 3, v24 + 1, 1);
      v24 = a2[1];
    }
    *(_BYTE *)(*a2 + v24) = 48;
    v40 = a2[1] + 1;
    goto LABEL_56;
  }
  v18 = 0;
  v19 = (unint64_t)(v11 + 63) >> 6;
  do
  {
    v20 = v19-- < 1;
    if (v20)
      break;
    v21 = *(_QWORD *)(*(_QWORD *)a1 + 8 * v19);
    v18 += __clz(v21);
  }
  while (!v21);
  v22 = v11 | 0xFFFFFFC0;
  if ((v11 & 0x3F) == 0)
    v22 = 0;
  if (v18 + v22 == (_DWORD)v11)
    goto LABEL_23;
  v65 = *(_DWORD *)(a1 + 8);
  v30 = ((unint64_t)(v11 + 63) >> 3) & 0x3FFFFFF8;
  v64 = (llvm::APInt *)operator new[]();
  v31 = *(_QWORD *)a1;
  memcpy(v64, *(const void **)a1, v30);
  if (a4)
  {
    v33 = *(_DWORD *)(a1 + 8);
    v34 = v33 - 1;
    if (v33 >= 0x41)
      v31 = *(_QWORD *)(v31 + 8 * (v34 >> 6));
    if (((v31 >> v34) & 1) != 0)
    {
      llvm::APInt::flipAllBitsSlowCase((uint64_t)&v64);
      llvm::APInt::operator++((uint64_t)&v64);
      v35 = a2[1];
      if ((unint64_t)(v35 + 1) > a2[2])
      {
        llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a2, a2 + 3, v35 + 1, 1);
        v35 = a2[1];
      }
      *(_BYTE *)(*a2 + v35) = 45;
      ++a2[1];
    }
  }
  v36 = *v10;
  if (*v10)
  {
    v37 = a2[1];
    v38 = (unsigned __int8 *)(v10 + 1);
    do
    {
      if ((unint64_t)(v37 + 1) > a2[2])
      {
        llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a2, a2 + 3, v37 + 1, 1);
        v37 = a2[1];
      }
      *(_BYTE *)(*a2 + v37) = v36;
      v37 = a2[1] + 1;
      a2[1] = v37;
      v39 = *v38++;
      v36 = v39;
    }
    while (v39);
  }
  else
  {
    v37 = a2[1];
  }
  if (a3 == 2 || a3 == 8)
  {
    if (a3 == 8)
      v43 = 3;
    else
      v43 = 1;
    goto LABEL_66;
  }
  if (a3 == 16)
  {
    v43 = 4;
LABEL_66:
    v44 = v43;
    while (1)
    {
      v45 = v65;
      if (v65 > 0x40)
      {
        v47 = 0;
        v48 = ((unint64_t)v65 + 63) >> 6;
        do
        {
          v20 = v48-- < 1;
          if (v20)
            break;
          v49 = *((_QWORD *)v64 + v48);
          v47 += __clz(v49);
        }
        while (!v49);
        v50 = v65 | 0xFFFFFFC0;
        if ((v65 & 0x3F) == 0)
          v50 = 0;
        if (v47 + v50 == v65)
        {
LABEL_84:
          i = a2[1];
          goto LABEL_85;
        }
        v46 = *(_QWORD *)v64;
      }
      else
      {
        LODWORD(v46) = (_DWORD)v64;
        if (!v64)
          goto LABEL_84;
      }
      v51 = a0123456789abcd_3[v46 & (a3 - 1)];
      v52 = a2[1];
      if ((unint64_t)(v52 + 1) > a2[2])
      {
        llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a2, a2 + 3, v52 + 1, 1);
        v52 = a2[1];
      }
      *(_BYTE *)(*a2 + v52) = v51;
      ++a2[1];
      if (v65 > 0x40)
      {
        llvm::APInt::tcShiftRight(v64, (unint64_t *)(((unint64_t)v65 + 63) >> 6), v44);
      }
      else if (v65 == v44)
      {
        v64 = 0;
      }
      else
      {
        v64 = (llvm::APInt *)((unint64_t)v64 >> v44);
      }
    }
  }
  for (i = v37; ; a2[1] = i)
  {
    v45 = v65;
    if (v65 > 0x40)
      break;
    if (!v64)
      goto LABEL_85;
LABEL_104:
    v63 = 0;
    llvm::APInt::udivrem((llvm::APInt *)&v64, a3, (unint64_t *)&v64, (llvm::APInt *)&v63, v32);
    v61 = a0123456789abcd_3[v63];
    v62 = a2[1];
    if ((unint64_t)(v62 + 1) > a2[2])
    {
      llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a2, a2 + 3, v62 + 1, 1);
      v62 = a2[1];
    }
    *(_BYTE *)(*a2 + v62) = v61;
    i = a2[1] + 1;
  }
  v57 = 0;
  v58 = ((unint64_t)v65 + 63) >> 6;
  do
  {
    v20 = v58-- < 1;
    if (v20)
      break;
    v59 = *((_QWORD *)v64 + v58);
    v57 += __clz(v59);
  }
  while (!v59);
  v60 = v65 | 0xFFFFFFC0;
  if ((v65 & 0x3F) == 0)
    v60 = 0;
  if (v57 + v60 != v65)
    goto LABEL_104;
LABEL_85:
  if (v37 != i)
  {
    v54 = (_BYTE *)(*a2 + i - 1);
    if (*a2 + (unint64_t)v37 < (unint64_t)v54)
    {
      v55 = v37 + *a2 + 1;
      do
      {
        v56 = *(_BYTE *)(v55 - 1);
        *(_BYTE *)(v55 - 1) = *v54;
        *v54-- = v56;
        v28 = v55++ >= (unint64_t)v54;
      }
      while (!v28);
      v45 = v65;
    }
  }
  if (v45 >= 0x41 && v64)
    MEMORY[0x1CAA32F9C](v64, 0x1000C8000313F17);
}

void llvm::APInt::print(llvm::APInt *this, llvm::raw_ostream *a2, int a3)
{
  void *v4;
  __int128 v5;
  _QWORD v6[6];

  v6[5] = *MEMORY[0x1E0C80C00];
  v4 = v6;
  v5 = xmmword_1C64638D0;
  llvm::APInt::toString((uint64_t)this, &v4, 0xAu, a3, 0);
  llvm::raw_ostream::write(a2, (const char *)v4, v5);
  if (v4 != v6)
    free(v4);
}

void llvm::APInt::tcSet(llvm::APInt *this, unint64_t *a2, unsigned int a3)
{
  *(_QWORD *)this = a2;
  if (a3 >= 2)
    bzero((char *)this + 8, 8 * (a3 - 2) + 8);
}

_QWORD *llvm::APInt::tcAssign(_QWORD *this, unint64_t *a2, const unint64_t *a3)
{
  uint64_t v3;
  uint64_t v4;

  if ((_DWORD)a3)
  {
    v3 = a3;
    do
    {
      v4 = *a2++;
      *this++ = v4;
      --v3;
    }
    while (v3);
  }
  return this;
}

BOOL llvm::APInt::tcIsZero(llvm::APInt *this, const unint64_t *a2)
{
  uint64_t v3;
  unint64_t v4;

  if (!(_DWORD)a2)
    return 1;
  if (*(_QWORD *)this)
    return 0;
  v3 = 1;
  do
  {
    v4 = v3;
    if (a2 == v3)
      break;
  }
  while (!*((_QWORD *)this + v3++));
  return v4 >= a2;
}

uint64_t llvm::APInt::tcExtractBit(llvm::APInt *this, const unint64_t *a2)
{
  return (*((_QWORD *)this + (a2 >> 6)) >> (char)a2) & 1;
}

uint64_t llvm::APInt::tcSetBit(uint64_t this, unint64_t *a2)
{
  *(_QWORD *)(this + 8 * (a2 >> 6)) |= 1 << (char)a2;
  return this;
}

uint64_t llvm::APInt::tcLSB(llvm::APInt *this, const unint64_t *a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;

  if (!(_DWORD)a2)
    return 0xFFFFFFFFLL;
  v2 = 0;
  while (1)
  {
    v4 = *(_QWORD *)this;
    this = (llvm::APInt *)((char *)this + 8);
    v3 = v4;
    if (v4)
      break;
    v2 -= 64;
    if (!(((unint64_t)a2 << 6) + v2))
      return 0xFFFFFFFFLL;
  }
  return __clz(__rbit64(v3)) - v2;
}

uint64_t llvm::APInt::tcMSB(llvm::APInt *this, const unint64_t *a2)
{
  int v2;
  unsigned int v3;
  unint64_t v4;

  v2 = 64 - ((_DWORD)a2 << 6);
  v3 = (_DWORD)a2 - 1;
  do
  {
    v4 = *((_QWORD *)this + v3);
    if (v4)
      return (__clz(v4) - v2) ^ 0x3F;
    v2 += 64;
    --v3;
  }
  while (v3 != -1);
  return 0xFFFFFFFFLL;
}

void llvm::APInt::tcExtract(llvm::APInt *this, unint64_t *a2, uint64_t a3, const unint64_t *a4, unsigned int a5)
{
  unsigned int v5;
  unsigned int v7;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t *v12;
  uint64_t v13;
  llvm::APInt *v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unint64_t v19;

  v5 = a4;
  v7 = a2;
  v9 = (_DWORD)a4 + 63;
  v10 = ((_DWORD)a4 + 63) >> 6;
  v11 = a5 >> 6;
  if (((_DWORD)a4 + 63) >= 0x40)
  {
    v12 = (uint64_t *)(a3 + 8 * v11);
    if (v10 <= 1)
      v13 = 1;
    else
      v13 = v10;
    v14 = this;
    do
    {
      v15 = *v12++;
      *(_QWORD *)v14 = v15;
      v14 = (llvm::APInt *)((char *)v14 + 8);
      --v13;
    }
    while (v13);
  }
  v16 = a5 & 0x3F;
  llvm::APInt::tcShiftRight(this, (unint64_t *)(v9 >> 6), v16);
  v17 = (v9 & 0xFFFFFFC0) - v16;
  if (v17 >= v5)
  {
    if (v17 <= v5 || (v5 & 0x3F) == 0)
      goto LABEL_13;
    v18 = v10 - 1;
    v19 = *((_QWORD *)this + v10 - 1) & (0xFFFFFFFFFFFFFFFFLL >> -(v5 & 0x3F));
  }
  else
  {
    v18 = v10 - 1;
    v19 = ((*(_QWORD *)(a3 + 8 * (v11 + v10)) & (0xFFFFFFFFFFFFFFFFLL >> (v17 - v5))) << v17) | *((_QWORD *)this + v10 - 1);
  }
  *((_QWORD *)this + v18) = v19;
LABEL_13:
  if (v10 < v7)
    bzero((char *)this + ((v9 >> 3) & 0x1FFFFFF8), 8 * (~v10 + v7) + 8);
}

uint64_t *llvm::APInt::tcNegate(uint64_t *this, unint64_t *a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  BOOL v6;

  if ((_DWORD)a2)
  {
    v2 = this;
    v3 = a2;
    do
    {
      *v2 = ~*v2;
      ++v2;
      --v3;
    }
    while (v3);
    v4 = a2 - 1;
    do
    {
      v5 = *this + 1;
      *this++ = v5;
      if (v5)
        v6 = 1;
      else
        v6 = v4 == 0;
      --v4;
    }
    while (!v6);
  }
  return this;
}

void llvm::APInt::tcFullMultiply(llvm::APInt *this, unint64_t *a2, const unint64_t **a3, const unint64_t *a4, const unint64_t *a5)
{
  llvm::APInt *v7;
  const unint64_t *v8;
  unint64_t *v9;
  const unint64_t *v10;

  v7 = this;
  do
  {
    v8 = a5;
    a5 = a4;
    v9 = (unint64_t *)a3;
    a3 = (const unint64_t **)a2;
    a2 = v9;
    a4 = v8;
  }
  while (a5 > v8);
  *(_QWORD *)this = 0;
  if (v8 >= 2)
    bzero((char *)this + 8, 8 * ((_DWORD)v8 - 2) + 8);
  if ((_DWORD)a5)
  {
    a5 = (const unint64_t *)a5;
    do
    {
      v10 = *a3++;
      llvm::APInt::tcMultiplyPart(v7, v9, v10, 0, v8, (_DWORD)v8 + 1, 1);
      v7 = (llvm::APInt *)((char *)v7 + 8);
      a5 = (const unint64_t *)((char *)a5 - 1);
    }
    while (a5);
  }
}

uint64_t llvm::APInt::tcDivide(llvm::APInt *this, unint64_t *a2, unint64_t *a3, llvm::APInt *a4, unint64_t *a5)
{
  unsigned int v5;
  int v9;
  int i;
  unint64_t v11;
  int v12;
  BOOL v13;
  int v14;
  unsigned int v16;
  unsigned int v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t *v26;
  llvm::APInt *v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  _BOOL4 v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t *v34;
  uint64_t v35;
  unint64_t v36;
  int v37;

  v5 = a5;
  v9 = (_DWORD)a5 - 1;
  for (i = 64 - ((_DWORD)a5 << 6); ; i += 64)
  {
    v11 = a2[v9];
    if (v11)
      break;
    if (--v9 == -1)
      return 1;
  }
  v12 = (__clz(v11) - i) ^ 0x3F;
  v13 = __CFADD__(v12, 1);
  v14 = v12 + 1;
  if (v13)
    return 1;
  v16 = ((_DWORD)a5 << 6) - v14;
  v17 = v16 >> 6;
  v18 = 1 << v16;
  if ((_DWORD)a5)
  {
    v19 = 0;
    v20 = a5;
    do
    {
      *(_QWORD *)((char *)a4 + v19 * 8) = a2[v19];
      ++v19;
    }
    while (a5 != v19);
    llvm::APInt::tcShiftLeft(a4, a5, v16);
    v21 = 0;
    do
    {
      a3[v21] = *(_QWORD *)((char *)this + v21 * 8);
      ++v21;
    }
    while (v5 != v21);
    *(_QWORD *)this = 0;
    if (v5 >= 2)
      bzero((char *)this + 8, 8 * (v5 - 2) + 8);
  }
  else
  {
    llvm::APInt::tcShiftLeft(a4, 0, v16);
    v20 = 0;
    *(_QWORD *)this = 0;
  }
  while (2)
  {
    v22 = v20;
    while (v22 * 8)
    {
      v23 = a3[v22 - 1];
      v24 = *(_QWORD *)((char *)a4 + v22 * 8 - 8);
      --v22;
      if (v23 != v24)
      {
        if (v23 <= v24)
          goto LABEL_27;
        break;
      }
    }
    if (v5)
    {
      v25 = 0;
      v26 = a3;
      v27 = a4;
      v28 = v20;
      do
      {
        v29 = *(_QWORD *)v27;
        v27 = (llvm::APInt *)((char *)v27 + 8);
        v30 = *v26 - v29;
        v31 = *v26 < v29;
        v32 = *v26 + ~v29;
        if (v25)
        {
          v25 = v32 >= *v26;
        }
        else
        {
          v32 = v30;
          v25 = v31;
        }
        *v26++ = v32;
        --v28;
      }
      while (v28);
    }
    *((_QWORD *)this + v17) |= v18;
LABEL_27:
    if (v16)
    {
      if (v5)
      {
        v33 = *(_QWORD *)a4 >> 1;
        *(_QWORD *)a4 = v33;
        if (v5 != 1)
        {
          v34 = (unint64_t *)((char *)a4 + 8);
          v35 = v20 - 1;
          do
          {
            v36 = *v34;
            *(v34 - 1) = v33 | (*v34 << 63);
            v33 = v36 >> 1;
            *v34++ = v36 >> 1;
            --v35;
          }
          while (v35);
        }
      }
      --v16;
      v37 = v18 < 2;
      if (v18 >= 2)
        v18 >>= 1;
      else
        v18 = 0x8000000000000000;
      v17 -= v37;
      continue;
    }
    return 0;
  }
}

void llvm::APIntOps::RoundingUDiv(llvm::APInt *a1@<X0>, const llvm::APInt *a2@<X1>, unsigned int a3@<W2>, llvm::APInt *a4@<X4>, llvm::APInt *a5@<X8>)
{
  unsigned int v6;
  int v7;
  int64_t v8;
  unint64_t v10;
  unsigned int v11;
  size_t v12;
  void *v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;
  void *__src;
  unsigned int v18;

  if (a3 <= 1)
  {
    llvm::APInt::udiv(a1, a2, a5);
    return;
  }
  v18 = 1;
  __src = 0;
  v16 = 1;
  v15 = 0;
  llvm::APInt::udivrem((llvm::APInt **)a1, a2, (const llvm::APInt *)&__src, (llvm::APInt *)&v15, a4);
  v6 = v16;
  if (v16 > 0x40)
  {
    v7 = 0;
    v8 = ((unint64_t)v16 + 63) >> 6;
    do
    {
      if (v8-- < 1)
        break;
      v10 = *(_QWORD *)(v15 + 8 * v8);
      v7 += __clz(v10);
    }
    while (!v10);
    v11 = v16 | 0xFFFFFFC0;
    if ((v16 & 0x3F) == 0)
      v11 = 0;
    if (v7 + v11 != v16)
      goto LABEL_5;
  }
  else if (v15)
  {
LABEL_5:
    v14 = v18;
    if (v18 > 0x40)
    {
      v12 = (((unint64_t)v18 + 63) >> 3) & 0x3FFFFFF8;
      v13 = (void *)operator new[]();
      memcpy(v13, __src, v12);
    }
    else
    {
      v13 = __src;
    }
    llvm::APInt::operator+=((uint64_t)&v13, 1uLL);
    *((_DWORD *)a5 + 2) = v14;
    *(_QWORD *)a5 = v13;
    v14 = 0;
    v6 = v16;
    goto LABEL_16;
  }
  *((_DWORD *)a5 + 2) = v18;
  *(_QWORD *)a5 = __src;
  v18 = 0;
LABEL_16:
  if (v6 >= 0x41 && v15)
    MEMORY[0x1CAA32F9C](v15, 0x1000C8000313F17);
  if (v18 >= 0x41)
  {
    if (__src)
      MEMORY[0x1CAA32F9C](__src, 0x1000C8000313F17);
  }
}

void llvm::APIntOps::RoundingSDiv(const void **a1@<X1>, llvm::APInt *a2@<X0>, int a3@<W2>, llvm::APInt *a4@<X4>, llvm::APInt *a5@<X8>)
{
  uint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  unint64_t v11;
  unsigned int v12;
  char v13;
  const void **v14;
  char v15;
  int v16;
  int64_t v17;
  unint64_t v19;
  unsigned int v20;
  void **p_src;
  size_t v22;
  unsigned int v23;
  size_t v24;
  void *v25;
  unsigned int v26;
  void *v27;
  unsigned int v28;
  uint64_t v29;
  unsigned int v30;
  void *__src;
  unsigned int v32;

  if (a3 == 1)
  {
    llvm::APInt::sdiv(a2, a1, a5);
    return;
  }
  v32 = 1;
  __src = 0;
  v30 = 1;
  v29 = 0;
  llvm::APInt::sdivrem(a2, a1, (const llvm::APInt *)&__src, (llvm::APInt *)&v29, a4);
  if (v30 <= 0x40)
  {
    v8 = v29;
    if (v29)
      goto LABEL_5;
LABEL_20:
    *((_DWORD *)a5 + 2) = v32;
LABEL_25:
    p_src = &__src;
    goto LABEL_31;
  }
  v16 = 0;
  v17 = ((unint64_t)v30 + 63) >> 6;
  v8 = v29;
  do
  {
    if (v17-- < 1)
      break;
    v19 = *(_QWORD *)(v29 + 8 * v17);
    v16 += __clz(v19);
  }
  while (!v19);
  v20 = v30 | 0xFFFFFFC0;
  if ((v30 & 0x3F) == 0)
    v20 = 0;
  if (v16 + v20 == v30)
    goto LABEL_20;
LABEL_5:
  v9 = (uint64_t *)(v8 + 8 * ((v30 - 1) >> 6));
  v10 = &v29;
  if (v30 >= 0x41)
    v10 = v9;
  v11 = (unint64_t)*v10 >> (v30 - 1);
  v12 = *((_DWORD *)a1 + 2);
  v13 = v12 - 1;
  if (v12 >= 0x41)
    v14 = (const void **)((char *)*a1 + 8 * ((v12 - 1) >> 6));
  else
    v14 = a1;
  v15 = v11 ^ ((unint64_t)*v14 >> v13);
  if (!a3)
  {
    if ((v15 & 1) != 0)
    {
      v28 = v32;
      if (v32 > 0x40)
      {
        v24 = (((unint64_t)v32 + 63) >> 3) & 0x3FFFFFF8;
        v27 = (void *)operator new[]();
        memcpy(v27, __src, v24);
      }
      else
      {
        v27 = __src;
      }
      p_src = &v27;
      llvm::APInt::operator-=((uint64_t)&v27, 1uLL);
      v23 = v28;
      goto LABEL_30;
    }
    goto LABEL_24;
  }
  if ((v15 & 1) != 0)
  {
LABEL_24:
    *((_DWORD *)a5 + 2) = v32;
    goto LABEL_25;
  }
  v26 = v32;
  if (v32 > 0x40)
  {
    v22 = (((unint64_t)v32 + 63) >> 3) & 0x3FFFFFF8;
    v25 = (void *)operator new[]();
    memcpy(v25, __src, v22);
  }
  else
  {
    v25 = __src;
  }
  p_src = &v25;
  llvm::APInt::operator+=((uint64_t)&v25, 1uLL);
  v23 = v26;
LABEL_30:
  *((_DWORD *)a5 + 2) = v23;
LABEL_31:
  *(_QWORD *)a5 = *p_src;
  *((_DWORD *)p_src + 2) = 0;
  if (v30 >= 0x41 && v29)
    MEMORY[0x1CAA32F9C](v29, 0x1000C8000313F17);
  if (v32 >= 0x41)
  {
    if (__src)
      MEMORY[0x1CAA32F9C](__src, 0x1000C8000313F17);
  }
}

void llvm::APIntOps::SolveQuadraticEquationWrap(llvm::APInt *a1@<X0>, llvm::APInt *a2@<X1>, unint64_t *a3@<X2>, unsigned int a4@<W3>, uint64_t a5@<X8>)
{
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unint64_t v16;
  int v17;
  int64_t v18;
  BOOL v19;
  unint64_t v20;
  unsigned int v21;
  int v22;
  unsigned int v23;
  unint64_t v24;
  unsigned int v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  unint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  unint64_t v33;
  unsigned int v34;
  unsigned int v35;
  llvm::APInt *v36;
  unsigned int v37;
  char *v38;
  unint64_t v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  int v44;
  unint64_t v45;
  unint64_t v46;
  unsigned int v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t *v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  char *v55;
  unint64_t v56;
  uint64_t *v57;
  uint64_t v58;
  unint64_t v59;
  const void *v60;
  unint64_t v61;
  unsigned int v62;
  unint64_t v63;
  unint64_t v64;
  unsigned int v65;
  _QWORD *v66;
  _BOOL4 v67;
  _BOOL4 v68;
  char *v69;
  size_t v70;
  int v71;
  uint64_t v72;
  unsigned int v73;
  const void **v74;
  unsigned int v75;
  unsigned int v76;
  uint64_t v77;
  unint64_t v78;
  unsigned int v79;
  uint64_t *v80;
  unint64_t v81;
  llvm::APInt *v82;
  uint64_t v83;
  unint64_t *v84;
  unint64_t v85;
  void *v86;
  unsigned int v87;
  unint64_t v88;
  llvm::APInt *v89;
  unsigned int v90;
  unint64_t v91;
  unint64_t v92;
  unsigned int v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  uint64_t v97;
  unint64_t v98;
  unint64_t v99;
  unint64_t v100;
  uint64_t v101;
  unint64_t v102;
  unint64_t v103;
  unint64_t *v104;
  unint64_t v105;
  uint64_t v106;
  unsigned int v107;
  unint64_t v108;
  BOOL v109;
  int v110;
  int64_t v111;
  unint64_t v112;
  unsigned int v113;
  int v114;
  int64_t v115;
  unint64_t v116;
  int v117;
  int v118;
  BOOL v119;
  int v120;
  int64_t v121;
  unint64_t v122;
  int v123;
  int v124;
  char v125;
  unint64_t v126;
  unint64_t v127;
  unint64_t v128;
  unint64_t v129;
  unsigned int v130;
  unint64_t v131;
  uint64_t v132;
  unint64_t v133;
  unint64_t *v134;
  uint64_t v135;
  unsigned int v136;
  const void **v137;
  unint64_t v138;
  uint64_t v139;
  unint64_t v140;
  unint64_t v141;
  uint64_t v142;
  unint64_t v143;
  unint64_t v144;
  unint64_t v145;
  _BOOL4 v146;
  unint64_t v147;
  uint64_t v148;
  unint64_t *v149;
  unint64_t *v150;
  unint64_t v151;
  unint64_t v152;
  unint64_t v153;
  unint64_t v154;
  _BOOL4 v155;
  unint64_t v156;
  uint64_t v157;
  unint64_t *v158;
  unint64_t v159;
  unint64_t *v160;
  unint64_t v161;
  unint64_t v162;
  unint64_t v163;
  _BOOL4 v164;
  unint64_t v165;
  uint64_t v166;
  unint64_t *v167;
  uint64_t *v168;
  unint64_t v169;
  unint64_t v170;
  uint64_t v171;
  unint64_t v172;
  _BOOL4 v173;
  uint64_t v174;
  uint64_t *v175;
  unint64_t v176;
  unint64_t *v177;
  unint64_t v178;
  uint64_t v179;
  unint64_t v180;
  _BOOL4 v181;
  uint64_t v182;
  unint64_t *v183;
  uint64_t *v184;
  unint64_t v185;
  unint64_t v186;
  uint64_t v187;
  unint64_t v188;
  _BOOL4 v189;
  uint64_t v190;
  _BOOL8 v191;
  unint64_t v192;
  unint64_t v193;
  unint64_t v194;
  _BOOL4 v195;
  _BOOL4 v196;
  uint64_t v197;
  unint64_t v198;
  uint64_t v199;
  uint64_t *v200;
  unint64_t *v201;
  unint64_t v202;
  uint64_t v203;
  unint64_t v204;
  _BOOL4 v205;
  uint64_t v206;
  uint64_t *v207;
  unint64_t *v208;
  uint64_t v209;
  unint64_t v210;
  _BOOL4 v211;
  uint64_t v212;
  unint64_t *v213;
  uint64_t *v214;
  unint64_t v215;
  unint64_t v216;
  uint64_t v217;
  unint64_t v218;
  _BOOL4 v219;
  uint64_t v220;
  uint64_t *v221;
  unint64_t v222;
  unint64_t *v223;
  unint64_t v224;
  uint64_t v225;
  unint64_t v226;
  _BOOL4 v227;
  uint64_t v228;
  unint64_t *v229;
  unint64_t v230;
  uint64_t *v231;
  unint64_t v232;
  uint64_t v233;
  unint64_t v234;
  _BOOL4 v235;
  uint64_t v236;
  unint64_t *v237;
  unsigned int v238;
  unint64_t *v239;
  unsigned int v240;
  void *v241;
  unsigned int v242;
  uint64_t v243;
  unsigned int v244;
  unint64_t v245;
  unsigned int v246;
  void *v247;
  unsigned int v248;
  unint64_t *v249;
  unsigned int v250;
  uint64_t v251;
  unsigned int v252;
  uint64_t v253;
  unsigned int v254;
  const void *v255;
  unint64_t v256;
  unsigned int v257;
  unint64_t v258;
  unsigned int v259;
  unint64_t v260;
  unint64_t v261;
  unsigned int v262;
  unint64_t v263;
  unsigned int v264;
  unint64_t v265;
  unsigned int v266;
  uint64_t *v267;
  unsigned int v268;
  const void *v269;
  const void *v270;
  unsigned int v271;
  unint64_t v272;
  unsigned int v273;

  v10 = *((_DWORD *)a1 + 2);
  v11 = *((_DWORD *)a3 + 2);
  if (v11 < a4)
  {
    llvm::APInt::sext((llvm::APInt *)a3, a4, (llvm::APInt *)&v272);
  }
  else if (v11 > a4)
  {
    llvm::APInt::trunc((llvm::APInt *)a3, a4, (llvm::APInt *)&v272);
  }
  else
  {
    sub_1C5DD14E0((uint64_t)&v272, (uint64_t)a3);
  }
  v12 = v273;
  if (v273 <= 0x40)
  {
    if (v272)
      goto LABEL_6;
LABEL_28:
    sub_1C4832EA4((llvm::APInt *)&v272, v10, 0, 0);
    *(_DWORD *)(a5 + 8) = v273;
    *(_QWORD *)a5 = v272;
    *(_BYTE *)(a5 + 16) = 1;
    return;
  }
  v17 = 0;
  v18 = ((unint64_t)v273 + 63) >> 6;
  do
  {
    v19 = v18-- < 1;
    if (v19)
      break;
    v20 = *(_QWORD *)(v272 + 8 * v18);
    v17 += __clz(v20);
  }
  while (!v20);
  v21 = v273 | 0xFFFFFFC0;
  if ((v273 & 0x3F) == 0)
    v21 = 0;
  v22 = v17 + v21;
  if (v272)
    MEMORY[0x1CAA32F9C](v272, 0x1000C8000313F17);
  if (v22 == v12)
    goto LABEL_28;
LABEL_6:
  v13 = 3 * v10;
  llvm::APInt::sext(a1, v13, (llvm::APInt *)&v272);
  if (*((_DWORD *)a1 + 2) >= 0x41u && *(_QWORD *)a1)
    MEMORY[0x1CAA32F9C](*(_QWORD *)a1, 0x1000C8000313F17);
  *(_QWORD *)a1 = v272;
  *((_DWORD *)a1 + 2) = v273;
  llvm::APInt::sext(a2, v13, (llvm::APInt *)&v272);
  if (*((_DWORD *)a2 + 2) >= 0x41u && *(_QWORD *)a2)
    MEMORY[0x1CAA32F9C](*(_QWORD *)a2, 0x1000C8000313F17);
  *(_QWORD *)a2 = v272;
  *((_DWORD *)a2 + 2) = v273;
  llvm::APInt::sext((llvm::APInt *)a3, v13, (llvm::APInt *)&v272);
  if (*((_DWORD *)a3 + 2) >= 0x41u && *a3)
    MEMORY[0x1CAA32F9C](*a3, 0x1000C8000313F17);
  *a3 = v272;
  *((_DWORD *)a3 + 2) = v273;
  v14 = *((_DWORD *)a1 + 2);
  v15 = v14 - 1;
  if (v14 > 0x40)
  {
    if (((*(_QWORD *)(*(_QWORD *)a1 + 8 * (v15 >> 6)) >> v15) & 1) == 0)
      goto LABEL_40;
    llvm::APInt::flipAllBitsSlowCase((uint64_t)a1);
  }
  else
  {
    if (((*(_QWORD *)a1 >> v15) & 1) == 0)
      goto LABEL_40;
    if (v14)
      v16 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v14;
    else
      v16 = 0;
    *(_QWORD *)a1 = v16 & ~*(_QWORD *)a1;
  }
  llvm::APInt::operator++((uint64_t)a1);
  v23 = *((_DWORD *)a2 + 2);
  if (v23 > 0x40)
  {
    llvm::APInt::flipAllBitsSlowCase((uint64_t)a2);
  }
  else
  {
    if (v23)
      v24 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v23;
    else
      v24 = 0;
    *(_QWORD *)a2 = v24 & ~*(_QWORD *)a2;
  }
  llvm::APInt::operator++((uint64_t)a2);
  v25 = *((_DWORD *)a3 + 2);
  if (v25 > 0x40)
  {
    llvm::APInt::flipAllBitsSlowCase((uint64_t)a3);
  }
  else
  {
    if (v25)
      v26 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v25;
    else
      v26 = 0;
    *a3 = v26 & ~*a3;
  }
  llvm::APInt::operator++((uint64_t)a3);
LABEL_40:
  sub_1C4832EA4((llvm::APInt *)&v272, v13, 0, 0);
  v27 = 1 << a4;
  if (v273 > 0x40)
    *(_QWORD *)(v272 + 8 * (a4 >> 6)) |= v27;
  else
    v272 |= v27;
  v28 = *((unsigned int *)a1 + 2);
  if (v28 > 0x40)
  {
    v29 = (char *)operator new[]();
    memcpy(v29, *(const void **)a1, ((unint64_t)(v28 + 63) >> 3) & 0x3FFFFFF8);
    v33 = (unint64_t)(v28 + 63) >> 6;
    llvm::APInt::tcMultiplyPart((llvm::APInt *)v29, (unint64_t *)v29, (const unint64_t *)2, 0, v33, v33, 0);
    v30 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v28;
    v31 = (uint64_t *)&v29[8 * (v33 - 1)];
    v32 = *v31;
  }
  else
  {
    v29 = (char *)(2 * *(_QWORD *)a1);
    v30 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v28;
    if (!(_DWORD)v28)
      v30 = 0;
    v31 = (uint64_t *)&v269;
    v32 = 2 * *(_QWORD *)a1;
  }
  v269 = v29;
  *v31 = v30 & v32;
  v271 = v28;
  v270 = v269;
  llvm::APInt::operator*((uint64_t)a2, a2, (uint64_t)&v267);
  v34 = *((_DWORD *)a2 + 2);
  v35 = v34 - 1;
  v36 = a2;
  if (v34 >= 0x41)
    v36 = (llvm::APInt *)(*(_QWORD *)a2 + 8 * (v35 >> 6));
  v236 = a5;
  if (((*(_QWORD *)v36 >> v35) & 1) != 0)
  {
    v37 = v271;
    if (v271 > 0x40)
    {
      v45 = v271 + 63;
      v38 = (char *)operator new[]();
      memcpy(v38, v270, (v45 >> 3) & 0x3FFFFFF8);
      llvm::APInt::tcMultiplyPart((llvm::APInt *)v38, (unint64_t *)v38, (const unint64_t *)2, 0, v45 >> 6, v45 >> 6, 0);
      v39 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v37;
      v40 = (uint64_t *)&v38[8 * (v45 >> 6) - 8];
      v41 = *v40;
    }
    else
    {
      v38 = (char *)(2 * (_QWORD)v270);
      v39 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v271;
      if (!v271)
        v39 = 0;
      v40 = (uint64_t *)&v260;
      v41 = 2 * (_QWORD)v270;
    }
    v260 = (unint64_t)v38;
    *v40 = v39 & v41;
    v262 = v37;
    v261 = v260;
    llvm::APInt::udiv((llvm::APInt *)&v267, (const llvm::APInt *)&v261, (llvm::APInt *)&v263);
    if (v264 > 0x40)
    {
      llvm::APInt::flipAllBitsSlowCase((uint64_t)&v263);
    }
    else
    {
      if (v264)
        v46 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v264;
      else
        v46 = 0;
      v263 = v46 & ~v263;
    }
    llvm::APInt::operator++((uint64_t)&v263);
    v47 = v264;
    if (v264 >= 0x41)
    {
      v212 = 0;
      v213 = (unint64_t *)v263;
      v214 = (uint64_t *)*a3;
      v215 = ((unint64_t)v264 + 63) >> 6;
      v216 = v215;
      do
      {
        v217 = *v214++;
        v218 = v217 + *v213;
        v219 = v218 + 1 <= *v213;
        if (v212)
        {
          ++v218;
          v212 = v219;
        }
        else
        {
          v212 = v218 < *v213;
        }
        *v213++ = v218;
        --v216;
      }
      while (v216);
      *(_QWORD *)(v263 + 8 * (v215 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v47;
      v47 = v264;
      v49 = v263;
    }
    else
    {
      if (v264)
        v48 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v264;
      else
        v48 = 0;
      v49 = v48 & (v263 + *a3);
      v263 = v49;
    }
    v266 = v47;
    v265 = v49;
    v264 = 0;
    if (v262 >= 0x41 && v261)
      MEMORY[0x1CAA32F9C](v261, 0x1000C8000313F17);
    sub_1C5DD0E08((uint64_t)&v263, (uint64_t)&v265, (unsigned int *)&v272);
    if (v266 >= 0x41 && v265)
      MEMORY[0x1CAA32F9C](v265, 0x1000C8000313F17);
    v50 = (unint64_t *)v263;
    v265 = v263;
    v266 = v264;
    v51 = *((unsigned int *)a3 + 2);
    if (v51 <= 0x40)
    {
      v52 = *a3;
      if ((uint64_t)(*a3 << -(char)v51) >> -(char)v51 <= (uint64_t)(v263 << -(char)v51) >> -(char)v51)
      {
        if ((_DWORD)v51)
          v53 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v51;
        else
          v53 = 0;
        v44 = 0;
        *a3 = v53 & (v52 - v263);
        goto LABEL_83;
      }
      v257 = *((_DWORD *)a3 + 2);
      goto LABEL_253;
    }
    v134 = (unint64_t *)*a3;
    v135 = *(_QWORD *)(*a3 + 8 * ((v51 - 1) >> 6)) & (1 << (v51 - 1));
    v136 = v264 - 1;
    v137 = (const void **)&v265;
    if (v264 >= 0x41)
      v137 = (const void **)(v263 + 8 * (v136 >> 6));
    if ((v135 != 0) == (((unint64_t)*v137 >> v136) & 1))
    {
      v138 = (unint64_t)(v51 + 63) >> 6;
      v139 = v138;
      while (v139 * 8)
      {
        v140 = v134[v139 - 1];
        v141 = *(_QWORD *)(v263 - 8 + v139 * 8);
        --v139;
        if (v140 != v141)
        {
          if (v140 <= v141)
            break;
          v257 = *((_DWORD *)a3 + 2);
          goto LABEL_284;
        }
      }
    }
    else
    {
      if (!v135)
      {
        v257 = *((_DWORD *)a3 + 2);
LABEL_284:
        v52 = operator new[]();
        v256 = v52;
        memcpy((void *)v52, (const void *)*a3, (((unint64_t)v257 + 63) >> 3) & 0x3FFFFFF8);
        LODWORD(v51) = v257;
        if (v257 > 0x40)
        {
          llvm::APInt::flipAllBitsSlowCase((uint64_t)&v256);
          goto LABEL_256;
        }
LABEL_253:
        if ((_DWORD)v51)
          v128 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v51;
        else
          v128 = 0;
        v256 = v128 & ~v52;
LABEL_256:
        llvm::APInt::operator++((uint64_t)&v256);
        v264 = v257;
        v263 = v256;
        v257 = 0;
        sub_1C5DD0E08((uint64_t)&v258, (uint64_t)&v263, (unsigned int *)&v272);
        if (v259 > 0x40)
        {
          llvm::APInt::flipAllBitsSlowCase((uint64_t)&v258);
        }
        else
        {
          if (v259)
            v129 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v259;
          else
            v129 = 0;
          v258 = v129 & ~v258;
        }
        llvm::APInt::operator++((uint64_t)&v258);
        v130 = v259;
        v131 = v258;
        v259 = 0;
        v132 = *((unsigned int *)a3 + 2);
        if (v132 >= 0x41)
        {
          v157 = 0;
          v158 = (unint64_t *)*a3;
          v159 = (unint64_t)(v132 + 63) >> 6;
          v160 = (unint64_t *)v258;
          v161 = v159;
          do
          {
            v162 = *v160++;
            v163 = *v158 - v162;
            v164 = *v158 < v162;
            v165 = *v158 + ~v162;
            if (v157)
            {
              v157 = v165 >= *v158;
            }
            else
            {
              v165 = v163;
              v157 = v164;
            }
            *v158++ = v165;
            --v161;
          }
          while (v161);
          *(_QWORD *)(*a3 + 8 * (v159 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v132;
        }
        else
        {
          if ((_DWORD)v132)
            v133 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v132;
          else
            v133 = 0;
          *a3 = v133 & (*a3 - v258);
        }
        if (v130 >= 0x41 && v131)
          MEMORY[0x1CAA32F9C](v131, 0x1000C8000313F17);
        if (v259 >= 0x41 && v258)
          MEMORY[0x1CAA32F9C](v258, 0x1000C8000313F17);
        if (v264 >= 0x41 && v263)
          MEMORY[0x1CAA32F9C](v263, 0x1000C8000313F17);
        if (v257 >= 0x41 && v256)
          MEMORY[0x1CAA32F9C](v256, 0x1000C8000313F17);
        v44 = 1;
        goto LABEL_83;
      }
      v138 = (unint64_t)(v51 + 63) >> 6;
    }
    v142 = 0;
    v143 = v138;
    do
    {
      v144 = *v50++;
      v145 = *v134 - v144;
      v146 = *v134 < v144;
      v147 = *v134 + ~v144;
      if (v142)
      {
        v142 = v147 >= *v134;
      }
      else
      {
        v147 = v145;
        v142 = v146;
      }
      *v134++ = v147;
      --v143;
    }
    while (v143);
    v44 = 0;
    *(_QWORD *)(*a3 + 8 * (v138 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v51;
LABEL_83:
    if (v266 >= 0x41 && v265)
      MEMORY[0x1CAA32F9C](v265, 0x1000C8000313F17);
    goto LABEL_87;
  }
  llvm::APInt::srem((llvm::APInt *)a3, (const void **)&v272, (llvm::APInt *)&v265);
  if (*((_DWORD *)a3 + 2) >= 0x41u && *a3)
    MEMORY[0x1CAA32F9C](*a3, 0x1000C8000313F17);
  *a3 = v265;
  *((_DWORD *)a3 + 2) = v266;
  if (sub_1C49591DC((llvm::APInt *)a3))
  {
    v42 = *((unsigned int *)a3 + 2);
    if (v42 >= 0x41)
    {
      v148 = 0;
      v149 = (unint64_t *)*a3;
      v150 = (unint64_t *)v272;
      v151 = (unint64_t)(v42 + 63) >> 6;
      v152 = v151;
      do
      {
        v153 = *v150++;
        v154 = *v149 - v153;
        v155 = *v149 < v153;
        v156 = *v149 + ~v153;
        if (v148)
        {
          v148 = v156 >= *v149;
        }
        else
        {
          v156 = v154;
          v148 = v155;
        }
        *v149++ = v156;
        --v152;
      }
      while (v152);
      v44 = 0;
      *(_QWORD *)(*a3 + 8 * (v151 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v42;
    }
    else
    {
      if ((_DWORD)v42)
        v43 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v42;
      else
        v43 = 0;
      v44 = 0;
      *a3 = v43 & (*a3 - v272);
    }
  }
  else
  {
    v44 = 0;
  }
LABEL_87:
  v54 = *((unsigned int *)a1 + 2);
  if (v54 > 0x40)
  {
    v55 = (char *)operator new[]();
    memcpy(v55, *(const void **)a1, ((unint64_t)(v54 + 63) >> 3) & 0x3FFFFFF8);
    v59 = (unint64_t)(v54 + 63) >> 6;
    llvm::APInt::tcMultiplyPart((llvm::APInt *)v55, (unint64_t *)v55, (const unint64_t *)4, 0, v59, v59, 0);
    v56 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v54;
    v57 = (uint64_t *)&v55[8 * (v59 - 1)];
    v58 = *v57;
  }
  else
  {
    v55 = (char *)(4 * *(_QWORD *)a1);
    v56 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v54;
    if (!(_DWORD)v54)
      v56 = 0;
    v57 = (uint64_t *)&v255;
    v58 = 4 * *(_QWORD *)a1;
  }
  v255 = v55;
  *v57 = v56 & v58;
  v262 = v54;
  v60 = v255;
  v261 = (unint64_t)v255;
  llvm::APInt::operator*((uint64_t)&v261, a3, (uint64_t)&v263);
  if (v264 > 0x40)
  {
    llvm::APInt::flipAllBitsSlowCase((uint64_t)&v263);
  }
  else
  {
    if (v264)
      v61 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v264;
    else
      v61 = 0;
    v263 = v61 & ~v263;
  }
  llvm::APInt::operator++((uint64_t)&v263);
  v62 = v264;
  if (v264 >= 0x41)
  {
    v166 = 0;
    v167 = (unint64_t *)v263;
    v168 = v267;
    v169 = ((unint64_t)v264 + 63) >> 6;
    v170 = v169;
    do
    {
      v171 = *v168++;
      v172 = v171 + *v167;
      v173 = v172 + 1 <= *v167;
      if (v166)
      {
        ++v172;
        v166 = v173;
      }
      else
      {
        v166 = v172 < *v167;
      }
      *v167++ = v172;
      --v170;
    }
    while (v170);
    *(_QWORD *)(v263 + 8 * (v169 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v62;
    v62 = v264;
    v64 = v263;
  }
  else
  {
    if (v264)
      v63 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v264;
    else
      v63 = 0;
    v64 = v63 & ((unint64_t)v267 + v263);
    v263 = v64;
  }
  v266 = v62;
  v265 = v64;
  v264 = 0;
  if (v54 >= 0x41 && v60)
    MEMORY[0x1CAA32F9C](v60, 0x1000C8000313F17);
  llvm::APInt::sqrt((llvm::APInt *)&v265, (llvm::APInt *)&v263);
  llvm::APInt::operator*((uint64_t)&v263, &v263, (uint64_t)&v261);
  v65 = v262;
  if (v262 <= 0x40)
  {
    v66 = (_QWORD *)v261;
    v67 = v261 == v265;
    v68 = v261 != v265;
    if ((uint64_t)(v261 << -(char)v262) >> -(char)v262 <= (uint64_t)(v265 << -(char)v262) >> -(char)v262)
      goto LABEL_112;
LABEL_111:
    llvm::APInt::operator-=((uint64_t)&v263, 1uLL);
    goto LABEL_112;
  }
  v66 = (_QWORD *)v261;
  v69 = (char *)v265;
  v70 = (((unint64_t)v262 + 63) >> 3) & 0x3FFFFFF8;
  v71 = memcmp((const void *)v261, (const void *)v265, v70);
  v68 = v71 != 0;
  v72 = v66[(v65 - 1) >> 6] & (1 << (v65 - 1));
  v73 = v266 - 1;
  if (v266 >= 0x41)
    v74 = (const void **)&v69[8 * (v73 >> 6)];
  else
    v74 = (const void **)&v265;
  if ((v72 != 0) != (((unint64_t)*v74 >> v73) & 1))
  {
    v67 = v71 == 0;
    if (v72)
      goto LABEL_112;
    goto LABEL_111;
  }
  v67 = v71 == 0;
  while (v70)
  {
    v126 = *(_QWORD *)((char *)v66 + v70 - 8);
    v127 = *(_QWORD *)&v69[v70 - 8];
    v70 -= 8;
    if (v126 != v127)
    {
      if (v126 <= v127)
        break;
      goto LABEL_111;
    }
  }
LABEL_112:
  v254 = 1;
  v253 = 0;
  v252 = 1;
  v251 = 0;
  if (v44)
  {
    v75 = *((_DWORD *)a2 + 2);
    v248 = v75;
    if (v75 > 0x40)
    {
      v247 = (void *)operator new[]();
      memcpy(v247, *(const void **)a2, (((unint64_t)v248 + 63) >> 3) & 0x3FFFFFF8);
      llvm::APInt::flipAllBitsSlowCase((uint64_t)&v247);
    }
    else
    {
      v78 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v75;
      if (!v75)
        v78 = 0;
      v247 = (void *)(v78 & ~*(_QWORD *)a2);
    }
    llvm::APInt::operator++((uint64_t)&v247);
    v79 = v248;
    v80 = (uint64_t *)v247;
    v248 = 0;
    v244 = v264;
    v77 = v236;
    if (v264 > 0x40)
    {
      v243 = operator new[]();
      memcpy((void *)v243, (const void *)v263, (((unint64_t)v244 + 63) >> 3) & 0x3FFFFFF8);
    }
    else
    {
      v243 = v263;
    }
    llvm::APInt::operator+=((uint64_t)&v243, v68);
    v87 = v244;
    v246 = v244;
    v245 = v243;
    v244 = 0;
    if (v246 > 0x40)
    {
      llvm::APInt::flipAllBitsSlowCase((uint64_t)&v245);
    }
    else
    {
      if (v87)
        v88 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v87;
      else
        v88 = 0;
      v245 = v88 & ~v243;
    }
    llvm::APInt::operator++((uint64_t)&v245);
    v90 = v246;
    if (v246 >= 0x41)
    {
      v228 = 0;
      v229 = (unint64_t *)v245;
      v230 = ((unint64_t)v246 + 63) >> 6;
      v231 = v80;
      v232 = v230;
      do
      {
        v233 = *v231++;
        v234 = v233 + *v229;
        v235 = v234 + 1 <= *v229;
        if (v228)
        {
          ++v234;
          v228 = v235;
        }
        else
        {
          v228 = v234 < *v229;
        }
        *v229++ = v234;
        --v232;
      }
      while (v232);
      *(_QWORD *)(v245 + 8 * (v230 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v90;
      v90 = v246;
      v92 = v245;
      v77 = v236;
    }
    else
    {
      if (v246)
        v91 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v246;
      else
        v91 = 0;
      v92 = v91 & ((unint64_t)v80 + v245);
      v245 = v92;
    }
    v250 = v90;
    v249 = (unint64_t *)v92;
    v246 = 0;
    llvm::APInt::sdivrem((llvm::APInt *)&v249, &v270, (const llvm::APInt *)&v253, (llvm::APInt *)&v251, v89);
    if (v250 >= 0x41 && v249)
      MEMORY[0x1CAA32F9C](v249, 0x1000C8000313F17);
    if (v246 >= 0x41 && v245)
      MEMORY[0x1CAA32F9C](v245, 0x1000C8000313F17);
    if (v244 >= 0x41 && v243)
      MEMORY[0x1CAA32F9C](v243, 0x1000C8000313F17);
    if (v79 >= 0x41 && v80)
      MEMORY[0x1CAA32F9C](v80, 0x1000C8000313F17);
    if (v248 >= 0x41)
    {
      v86 = v247;
      if (v247)
LABEL_160:
        MEMORY[0x1CAA32F9C](v86, 0x1000C8000313F17);
    }
  }
  else
  {
    v76 = *((_DWORD *)a2 + 2);
    v242 = v76;
    if (v76 > 0x40)
    {
      v241 = (void *)operator new[]();
      memcpy(v241, *(const void **)a2, (((unint64_t)v242 + 63) >> 3) & 0x3FFFFFF8);
      v77 = v236;
      llvm::APInt::flipAllBitsSlowCase((uint64_t)&v241);
    }
    else
    {
      v77 = v236;
      v81 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v76;
      if (!v76)
        v81 = 0;
      v241 = (void *)(v81 & ~*(_QWORD *)a2);
    }
    llvm::APInt::operator++((uint64_t)&v241);
    v83 = v242;
    v84 = (unint64_t *)v241;
    v242 = 0;
    if (v83 >= 0x41)
    {
      v220 = 0;
      v221 = (uint64_t *)v263;
      v222 = (unint64_t)(v83 + 63) >> 6;
      v223 = (unint64_t *)v241;
      v224 = v222;
      do
      {
        v225 = *v221++;
        v226 = v225 + *v223;
        v227 = v226 + 1 <= *v223;
        if (v220)
        {
          ++v226;
          v220 = v227;
        }
        else
        {
          v220 = v226 < *v223;
        }
        *v223++ = v226;
        --v224;
      }
      while (v224);
      v84[(v222 - 1)] &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v83;
      v77 = v236;
    }
    else
    {
      if ((_DWORD)v83)
        v85 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v83;
      else
        v85 = 0;
      v84 = (unint64_t *)(v85 & ((unint64_t)v241 + v263));
    }
    v250 = v83;
    v249 = v84;
    llvm::APInt::sdivrem((llvm::APInt *)&v249, &v270, (const llvm::APInt *)&v253, (llvm::APInt *)&v251, v82);
    if (v250 >= 0x41 && v249)
      MEMORY[0x1CAA32F9C](v249, 0x1000C8000313F17);
    if (v242 >= 0x41)
    {
      v86 = v241;
      if (v241)
        goto LABEL_160;
    }
  }
  if (!v67)
  {
LABEL_164:
    llvm::APInt::operator*((uint64_t)a1, &v253, (uint64_t)&v237);
    v93 = v238;
    if (v238 >= 0x41)
    {
      v174 = 0;
      v96 = (unint64_t)v237;
      v175 = *(uint64_t **)a2;
      v176 = ((unint64_t)v238 + 63) >> 6;
      v177 = v237;
      v178 = v176;
      do
      {
        v179 = *v175++;
        v180 = v179 + *v177;
        v181 = v180 + 1 <= *v177;
        if (v174)
        {
          ++v180;
          v174 = v181;
        }
        else
        {
          v174 = v180 < *v177;
        }
        *v177++ = v180;
        --v178;
      }
      while (v178);
      *(_QWORD *)(v96 + 8 * (v176 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v93;
      v77 = v236;
    }
    else
    {
      v94 = (unint64_t)v237 + *(_QWORD *)a2;
      v95 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v238;
      if (!v238)
        v95 = 0;
      v96 = v95 & v94;
      v237 = (unint64_t *)(v95 & v94);
    }
    v250 = v93;
    v249 = (unint64_t *)v96;
    v238 = 0;
    llvm::APInt::operator*((uint64_t)&v249, &v253, (uint64_t)&v239);
    v97 = v240;
    if (v240 >= 0x41)
    {
      v182 = 0;
      v183 = v239;
      v184 = (uint64_t *)*a3;
      v185 = ((unint64_t)v240 + 63) >> 6;
      v100 = (unint64_t)v239;
      v186 = v185;
      do
      {
        v187 = *v184++;
        v188 = v187 + *v183;
        v189 = v188 + 1 <= *v183;
        if (v182)
        {
          ++v188;
          v182 = v189;
        }
        else
        {
          v182 = v188 < *v183;
        }
        *v183++ = v188;
        --v186;
      }
      while (v186);
      *(_QWORD *)(v100 + 8 * (v185 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v97;
      v77 = v236;
    }
    else
    {
      v98 = (unint64_t)v239 + *a3;
      v99 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v240;
      if (!v240)
        v99 = 0;
      v100 = v99 & v98;
      v239 = (unint64_t *)(v99 & v98);
    }
    v240 = 0;
    if (v93 >= 0x41 && v96)
      MEMORY[0x1CAA32F9C](v96, 0x1000C8000313F17);
    llvm::APInt::operator*((uint64_t)&v270, &v253, (uint64_t)&v249);
    v101 = v250;
    if (v250 >= 0x41)
    {
      v190 = 0;
      v191 = 0;
      v104 = v249;
      v192 = ((unint64_t)v250 + 63) >> 6;
      do
      {
        v193 = v104[v190];
        v194 = *(_QWORD *)(v100 + v190 * 8) + v193;
        v195 = v194 < v193;
        v196 = v194 + 1 <= v193;
        if (v191)
        {
          ++v194;
          v191 = v196;
        }
        else
        {
          v191 = v195;
        }
        v104[v190++] = v194;
      }
      while (v192 != v190);
      v197 = 0;
      v198 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v101;
      v199 = (v192 - 1);
      v104[v199] &= v198;
      v200 = *(uint64_t **)a1;
      v201 = v104;
      v202 = (unint64_t)(v101 + 63) >> 6;
      do
      {
        v203 = *v200++;
        v204 = v203 + *v201;
        v205 = v204 + 1 <= *v201;
        if (v197)
        {
          ++v204;
          v197 = v205;
        }
        else
        {
          v197 = v204 < *v201;
        }
        *v201++ = v204;
        --v202;
      }
      while (v202);
      v206 = 0;
      v104[v199] &= v198;
      v207 = *(uint64_t **)a2;
      v208 = v104;
      do
      {
        v209 = *v207++;
        v210 = v209 + *v208;
        v211 = v210 + 1 <= *v208;
        if (v206)
        {
          ++v210;
          v206 = v211;
        }
        else
        {
          v206 = v210 < *v208;
        }
        *v208++ = v210;
        --v192;
      }
      while (v192);
      v104[v199] &= v198;
      v77 = v236;
    }
    else
    {
      if (v250)
      {
        v102 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v250;
        v103 = (((((unint64_t)v249 + v100) & v102) + *(_QWORD *)a1) & v102) + *(_QWORD *)a2;
      }
      else
      {
        v102 = 0;
        v103 = *(_QWORD *)a2;
      }
      v104 = (unint64_t *)(v102 & v103);
    }
    v105 = v100;
    if (v97 >= 0x41)
      v105 = *(_QWORD *)(v100 + 8 * ((v97 - 1) >> 6));
    v106 = v105 & (1 << (v97 - 1));
    v107 = v101 - 1;
    v108 = (unint64_t)v104;
    if (v101 >= 0x41)
      v108 = v104[v107 >> 6];
    if ((((v106 != 0) ^ (v108 >> v107)) & 1) != 0)
      goto LABEL_214;
    if (v97 > 0x40)
    {
      v114 = 0;
      v115 = (unint64_t)(v97 + 63) >> 6;
      do
      {
        v19 = v115-- < 1;
        if (v19)
          break;
        v116 = *(_QWORD *)(v100 + 8 * v115);
        v114 += __clz(v116);
      }
      while (!v116);
      v117 = v97 | 0xFFFFFFC0;
      if ((v97 & 0x3F) == 0)
        v117 = 0;
      v109 = v114 + v117 == (_DWORD)v97;
    }
    else
    {
      v109 = v100 == 0;
    }
    v118 = v109;
    if (v101 > 0x40)
    {
      v120 = 0;
      v121 = (unint64_t)(v101 + 63) >> 6;
      do
      {
        v19 = v121-- < 1;
        if (v19)
          break;
        v122 = v104[v121];
        v120 += __clz(v122);
      }
      while (!v122);
      v123 = v101 | 0xFFFFFFC0;
      if ((v101 & 0x3F) == 0)
        v123 = 0;
      v119 = v120 + v123 == (_DWORD)v101;
    }
    else
    {
      v119 = v104 == 0;
    }
    v124 = v119;
    if (v118 == v124)
    {
      v125 = 0;
      *(_BYTE *)v77 = 0;
    }
    else
    {
LABEL_214:
      v125 = 1;
      llvm::APInt::operator+=((uint64_t)&v253, 1uLL);
      *(_DWORD *)(v77 + 8) = v254;
      *(_QWORD *)v77 = v253;
      v254 = 0;
    }
    *(_BYTE *)(v77 + 16) = v125;
    if (v101 >= 0x41 && v104)
      MEMORY[0x1CAA32F9C](v104, 0x1000C8000313F17);
    if (v97 >= 0x41 && v100)
      MEMORY[0x1CAA32F9C](v100, 0x1000C8000313F17);
    goto LABEL_222;
  }
  if (v252 > 0x40)
  {
    v110 = 0;
    v111 = ((unint64_t)v252 + 63) >> 6;
    do
    {
      v19 = v111-- < 1;
      if (v19)
        break;
      v112 = *(_QWORD *)(v251 + 8 * v111);
      v110 += __clz(v112);
    }
    while (!v112);
    v113 = v252 | 0xFFFFFFC0;
    if ((v252 & 0x3F) == 0)
      v113 = 0;
    if (v110 + v113 != v252)
      goto LABEL_164;
  }
  else if (v251)
  {
    goto LABEL_164;
  }
  *(_DWORD *)(v77 + 8) = v254;
  *(_QWORD *)v77 = v253;
  v254 = 0;
  *(_BYTE *)(v77 + 16) = 1;
LABEL_222:
  if (v252 >= 0x41 && v251)
    MEMORY[0x1CAA32F9C](v251, 0x1000C8000313F17);
  if (v254 >= 0x41 && v253)
    MEMORY[0x1CAA32F9C](v253, 0x1000C8000313F17);
  if (v65 >= 0x41 && v66)
    MEMORY[0x1CAA32F9C](v66, 0x1000C8000313F17);
  if (v264 >= 0x41 && v263)
    MEMORY[0x1CAA32F9C](v263, 0x1000C8000313F17);
  if (v266 >= 0x41 && v265)
    MEMORY[0x1CAA32F9C](v265, 0x1000C8000313F17);
  if (v268 >= 0x41 && v267)
    MEMORY[0x1CAA32F9C](v267, 0x1000C8000313F17);
  if (v271 >= 0x41 && v270)
    MEMORY[0x1CAA32F9C](v270, 0x1000C8000313F17);
  if (v273 >= 0x41)
  {
    if (v272)
      MEMORY[0x1CAA32F9C](v272, 0x1000C8000313F17);
  }
}

void sub_1C5DD0E08(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  _QWORD *v6;
  uint64_t v7;
  char *v8;
  _QWORD *v9;
  unint64_t v10;
  unint64_t v11;
  void *v12;
  int v13;
  int64_t v14;
  unint64_t v16;
  unsigned int v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  void *v22;
  uint64_t v23;
  uint64_t *v24;
  unint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  _BOOL4 v30;
  uint64_t v31;
  unint64_t *v32;
  unint64_t v33;
  unint64_t *v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  _BOOL4 v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t *v43;
  unint64_t *v44;
  uint64_t v45;
  unint64_t v46;
  _BOOL4 v47;
  uint64_t v48;
  unsigned int v49;
  _QWORD *v50;
  unsigned int v51;

  sub_1C4DA6CE8((const void **)a2, (uint64_t)&v48);
  llvm::APInt::urem((llvm::APInt *)&v48, (const llvm::APInt *)a3, (llvm::APInt *)&v50);
  if (v49 >= 0x41 && v48)
    MEMORY[0x1CAA32F9C](v48, 0x1000C8000313F17);
  if (v51 > 0x40)
  {
    v13 = 0;
    v14 = ((unint64_t)v51 + 63) >> 6;
    v6 = v50;
    do
    {
      if (v14-- < 1)
        break;
      v16 = v50[v14];
      v13 += __clz(v16);
    }
    while (!v16);
    v17 = v51 | 0xFFFFFFC0;
    if ((v51 & 0x3F) == 0)
      v17 = 0;
    if (v13 + v17 != v51)
      goto LABEL_6;
LABEL_19:
    sub_1C5DD14E0(a1, a2);
    goto LABEL_46;
  }
  v6 = v50;
  if (!v50)
    goto LABEL_19;
LABEL_6:
  v7 = *(unsigned int *)(a2 + 8);
  v8 = *(char **)a2;
  v9 = (_QWORD *)(*(_QWORD *)a2 + 8 * ((v7 - 1) >> 6));
  if (v7 < 0x41)
    v9 = (_QWORD *)a2;
  if (((*v9 >> (v7 - 1)) & 1) != 0)
  {
    if (v7 >= 0x41)
    {
      v12 = (void *)operator new[]();
      memcpy(v12, *(const void **)a2, ((unint64_t)(v7 + 63) >> 3) & 0x3FFFFFF8);
      v23 = 0;
      v24 = v50;
      v25 = (unint64_t)(v7 + 63) >> 6;
      v26 = (unint64_t *)v12;
      v27 = v25;
      do
      {
        v28 = *v24++;
        v29 = v28 + *v26;
        v30 = v29 + 1 <= *v26;
        if (v23)
        {
          ++v29;
          v23 = v30;
        }
        else
        {
          v23 = v29 < *v26;
        }
        *v26++ = v29;
        --v27;
      }
      while (v27);
      *((_QWORD *)v12 + (v25 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v7;
    }
    else
    {
      v10 = (unint64_t)&v8[(_QWORD)v6];
      v11 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v7;
      if (!(_DWORD)v7)
        v11 = 0;
      v12 = (void *)(v11 & v10);
    }
    *(_DWORD *)(a1 + 8) = v7;
    *(_QWORD *)a1 = v12;
  }
  else
  {
    v18 = a3[2];
    if (v18 >= 0x41)
    {
      v22 = (void *)operator new[]();
      memcpy(v22, *(const void **)a3, ((unint64_t)(v18 + 63) >> 3) & 0x3FFFFFF8);
      v31 = 0;
      v32 = v50;
      v33 = (unint64_t)(v18 + 63) >> 6;
      v34 = (unint64_t *)v22;
      v35 = v33;
      do
      {
        v36 = *v32++;
        v37 = *v34 - v36;
        v38 = *v34 < v36;
        v39 = *v34 + ~v36;
        if (v31)
        {
          v31 = v39 >= *v34;
        }
        else
        {
          v39 = v37;
          v31 = v38;
        }
        *v34++ = v39;
        --v35;
      }
      while (v35);
      v40 = 0;
      v41 = (v33 - 1);
      v42 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v18;
      *((_QWORD *)v22 + v41) &= v42;
      v43 = *(uint64_t **)a2;
      v44 = (unint64_t *)v22;
      do
      {
        v45 = *v43++;
        v46 = v45 + *v44;
        v47 = v46 + 1 <= *v44;
        if (v40)
        {
          ++v46;
          v40 = v47;
        }
        else
        {
          v40 = v46 < *v44;
        }
        *v44++ = v46;
        --v33;
      }
      while (v33);
      *((_QWORD *)v22 + v41) &= v42;
    }
    else
    {
      v19 = (*(_QWORD *)a3 - (_QWORD)v6) & (0xFFFFFFFFFFFFFFFFLL >> -(char)v18);
      if (!(_DWORD)v18)
        v19 = 0;
      v20 = (unint64_t)&v8[v19];
      if ((_DWORD)v18)
        v21 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v18;
      else
        v21 = 0;
      v22 = (void *)(v20 & v21);
    }
    *(_DWORD *)(a1 + 8) = v18;
    *(_QWORD *)a1 = v22;
  }
LABEL_46:
  if (v51 >= 0x41)
  {
    if (v50)
      MEMORY[0x1CAA32F9C](v50, 0x1000C8000313F17);
  }
}

uint64_t llvm::APIntOps::GetMostSignificantDifferentBit(const void **this, const void **a2, const llvm::APInt *a3)
{
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  unsigned int v9;
  unint64_t v10;
  char *v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  int v15;
  unint64_t v17;
  int v18;

  v5 = *((unsigned int *)this + 2);
  if (v5 > 0x40)
  {
    v10 = v5 + 63;
    if (!memcmp(*this, *a2, ((unint64_t)(v5 + 63) >> 3) & 0x3FFFFFF8))
    {
      v7 = 0;
      LOBYTE(v8) = 0;
      v9 = 0;
    }
    else
    {
      v11 = (char *)operator new[]();
      memcpy(v11, *this, ((unint64_t)(v5 + 63) >> 3) & 0x3FFFFFF8);
      v12 = 0;
      v13 = (char *)*a2;
      v14 = v10 >> 6;
      do
      {
        *(_QWORD *)&v11[v12] ^= *(_QWORD *)&v13[v12];
        v12 += 8;
      }
      while (8 * (v10 >> 6) != v12);
      v15 = 0;
      do
      {
        if (v14-- < 1)
          break;
        v17 = *(_QWORD *)&v11[8 * v14];
        v15 += __clz(v17);
      }
      while (!v17);
      v18 = v5 | 0xFFFFFFC0;
      if ((v5 & 0x3F) == 0)
        v18 = 0;
      v8 = v5 + ~(v15 + v18);
      v9 = v8 & 0xFFFFFF00;
      MEMORY[0x1CAA32F9C](v11, 0x1000C8000313F17);
      v7 = 0x100000000;
    }
  }
  else
  {
    v6 = v5 + ~(v5 + __clz((unint64_t)*a2 ^ (unint64_t)*this) - 64);
    if (*this == *a2)
      v7 = 0;
    else
      v7 = 0x100000000;
    if (*this == *a2)
      LOBYTE(v8) = 0;
    else
      LOBYTE(v8) = v6;
    if (*this == *a2)
      v9 = 0;
    else
      v9 = v6 & 0xFFFFFF00;
  }
  return v7 | v9 | v8;
}

void llvm::APIntOps::ScaleBitMask(llvm::APIntOps *this@<X0>, const llvm::APInt *a2@<X1>, llvm::APInt *a3@<X8>)
{
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  int v8;
  int64_t v9;
  BOOL v10;
  unint64_t v11;
  int v12;
  unsigned int v13;
  int v14;
  llvm::APIntOps *v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  llvm::APInt *v20;
  int v21;
  int64_t v22;
  unint64_t v23;
  unsigned int v24;
  int v25;
  uint64_t v26;
  unsigned int v27;

  v5 = *((_DWORD *)this + 2);
  if (v5 == (_DWORD)a2)
  {
    sub_1C5DD14E0((uint64_t)a3, (uint64_t)this);
    return;
  }
  v6 = a2;
  sub_1C4832EA4(a3, a2, 0, 0);
  v7 = *((unsigned int *)this + 2);
  if (v7 <= 0x40)
  {
    if (!*(_QWORD *)this)
      return;
    goto LABEL_12;
  }
  v8 = 0;
  v9 = (unint64_t)(v7 + 63) >> 6;
  do
  {
    v10 = v9-- < 1;
    if (v10)
      break;
    v11 = *(_QWORD *)(*(_QWORD *)this + 8 * v9);
    v8 += __clz(v11);
  }
  while (!v11);
  v12 = v7 | 0xFFFFFFC0;
  if ((v7 & 0x3F) == 0)
    v12 = 0;
  if (v8 + v12 != (_DWORD)v7)
  {
LABEL_12:
    if (v5 < v6)
    {
      if (v5)
      {
        v13 = 0;
        v14 = v6 / v5;
        do
        {
          if (*((_DWORD *)this + 2) >= 0x41u)
            v15 = (llvm::APIntOps *)(*(_QWORD *)this + 8 * (v13 >> 6));
          else
            v15 = this;
          if (((*(_QWORD *)v15 >> v13) & 1) != 0)
          {
            v16 = v13 * v14;
            sub_1C4912E54(a3, v16, ++v13 * v14);
          }
          else
          {
            ++v13;
          }
        }
        while (v13 != v5);
      }
      return;
    }
    if (!v6)
      return;
    v17 = 0;
    v18 = v5 / v6;
    while (1)
    {
      llvm::APInt::extractBits(this, v18, v17 * v18, (unsigned int *)&v26);
      v19 = v27;
      if (v27 > 0x40)
        break;
      if (v26)
        goto LABEL_27;
LABEL_31:
      if (++v17 == v6)
        return;
    }
    v21 = 0;
    v22 = ((unint64_t)v27 + 63) >> 6;
    do
    {
      v10 = v22-- < 1;
      if (v10)
        break;
      v23 = *(_QWORD *)(v26 + 8 * v22);
      v21 += __clz(v23);
    }
    while (!v23);
    v24 = v27 | 0xFFFFFFC0;
    if ((v27 & 0x3F) == 0)
      v24 = 0;
    v25 = v21 + v24;
    if (v26)
      MEMORY[0x1CAA32F9C](v26, 0x1000C8000313F17);
    if (v25 == v19)
      goto LABEL_31;
LABEL_27:
    if (*((_DWORD *)a3 + 2) >= 0x41u)
      v20 = (llvm::APInt *)(*(_QWORD *)a3 + 8 * (v17 >> 6));
    else
      v20 = a3;
    *(_QWORD *)v20 |= 1 << v17;
    goto LABEL_31;
  }
}

void *llvm::StoreIntToMemory(llvm **this, const llvm::APInt *__dst, size_t __n)
{
  llvm *v4;

  if (*((_DWORD *)this + 2) >= 0x41u)
    v4 = *this;
  else
    v4 = (llvm *)this;
  return memcpy(__dst, v4, __n);
}

void *llvm::LoadIntFromMemory(llvm *this, llvm::APInt *a2, size_t __n)
{
  if (*((_DWORD *)this + 2) >= 0x41u)
    this = *(llvm **)this;
  return memcpy(this, a2, __n);
}

uint64_t sub_1C5DD14E0(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  void *v5;

  v4 = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 8) = v4;
  if (v4 > 0x40)
  {
    v5 = (void *)operator new[]();
    *(_QWORD *)a1 = v5;
    memcpy(v5, *(const void **)a2, (((unint64_t)*(unsigned int *)(a1 + 8) + 63) >> 3) & 0x3FFFFFF8);
  }
  else
  {
    *(_QWORD *)a1 = *(_QWORD *)a2;
  }
  return a1;
}

uint64_t *llvm::APSInt::APSInt(uint64_t *a1, char *a2, uint64_t a3)
{
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  void *v9;
  int v10;
  int v11;
  int64_t v12;
  unint64_t v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  char v18;
  uint64_t v19;
  char v20;
  void *v22;
  unsigned int v23;
  void *__src;
  unsigned int v25;

  *((_DWORD *)a1 + 2) = 1;
  *a1 = 0;
  v5 = (a3 << 6) / 0x13uLL + 2;
  v25 = v5;
  llvm::APInt::fromString((uint64_t)&__src, (uint64_t)a2, a2, a3, 0xAu);
  v6 = v25;
  if (*a2 == 45)
  {
    v7 = v6 - sub_1C4959174((llvm::APInt *)&__src) + 1;
    if (v7 >= v5)
    {
      v6 = v25;
    }
    else
    {
      if (v7 <= 1)
        v8 = 1;
      else
        v8 = v7;
      llvm::APInt::trunc((llvm::APInt *)&__src, v8, (llvm::APInt *)&v22);
      if (v25 >= 0x41 && __src)
        MEMORY[0x1CAA32F9C](__src, 0x1000C8000313F17);
      __src = v22;
      v6 = v23;
      v25 = v23;
    }
    if (v6 > 0x40)
    {
      v9 = (void *)operator new[]();
      memcpy(v9, __src, (((unint64_t)v6 + 63) >> 3) & 0x3FFFFFF8);
    }
    else
    {
      v9 = __src;
    }
    if (*((_DWORD *)a1 + 2) < 0x41u)
    {
      v18 = 0;
      goto LABEL_38;
    }
    v20 = 0;
    v18 = 0;
    v19 = *a1;
    if (!*a1)
      goto LABEL_38;
LABEL_37:
    MEMORY[0x1CAA32F9C](v19, 0x1000C8000313F17);
    v18 = v20;
    goto LABEL_38;
  }
  if (v25 > 0x40)
  {
    v11 = 0;
    v12 = ((unint64_t)v25 + 63) >> 6;
    v9 = __src;
    do
    {
      if (v12-- < 1)
        break;
      v14 = *((_QWORD *)__src + v12);
      v11 += __clz(v14);
    }
    while (!v14);
    v15 = v25 | 0xFFFFFFC0;
    if ((v25 & 0x3F) == 0)
      v15 = 0;
    v10 = v11 + v15;
  }
  else
  {
    v9 = __src;
    v10 = v25 + __clz((unint64_t)__src) - 64;
  }
  v16 = v25 - v10;
  if (v16 < v5)
  {
    if (v16 <= 1)
      v17 = 1;
    else
      v17 = v16;
    llvm::APInt::trunc((llvm::APInt *)&__src, v17, (llvm::APInt *)&v22);
    if (v25 >= 0x41 && __src)
      MEMORY[0x1CAA32F9C](__src, 0x1000C8000313F17);
    v9 = v22;
    __src = v22;
    v6 = v23;
    v25 = v23;
  }
  if (v6 >= 0x41)
  {
    v9 = (void *)operator new[]();
    memcpy(v9, __src, (((unint64_t)v6 + 63) >> 3) & 0x3FFFFFF8);
  }
  if (*((_DWORD *)a1 + 2) >= 0x41u)
  {
    v19 = *a1;
    v20 = 1;
    v18 = 1;
    if (!*a1)
      goto LABEL_38;
    goto LABEL_37;
  }
  v18 = 1;
LABEL_38:
  *a1 = (uint64_t)v9;
  *((_DWORD *)a1 + 2) = v6;
  *((_BYTE *)a1 + 12) = v18;
  if (v25 >= 0x41 && __src)
    MEMORY[0x1CAA32F9C](__src, 0x1000C8000313F17);
  return a1;
}

uint64_t llvm::APSInt::Profile(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  int v7;

  v2 = *(unsigned __int8 *)(a1 + 12);
  v3 = *(unsigned int *)(a2 + 8);
  if (v3 >= *(_DWORD *)(a2 + 12))
  {
    v7 = *(unsigned __int8 *)(a1 + 12);
    v5 = a2;
    v6 = a1;
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2, a2 + 16, v3 + 1, 4);
    v2 = v7;
    a2 = v5;
    a1 = v6;
    LODWORD(v3) = *(_DWORD *)(v5 + 8);
  }
  *(_DWORD *)(*(_QWORD *)a2 + 4 * v3) = v2;
  ++*(_DWORD *)(a2 + 8);
  return llvm::APInt::Profile(a1, a2);
}

void llvm::ARMAttributeParser::ABI_align_needed(_QWORD *a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  unint64_t ULEB128;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  unint64_t v10;
  BOOL v11;
  std::string *v12;
  std::string::size_type v13;
  std::string *v14;
  void *v15;
  char v16;
  void *p_p;
  uint64_t v18;
  std::string v19;
  void *__p;
  __int128 v21;
  std::string v22;
  _QWORD v23[3];

  v23[2] = *MEMORY[0x1E0C80C00];
  ULEB128 = llvm::DataExtractor::getULEB128(a1 + 16, a1 + 19, a1 + 20);
  v7 = ULEB128;
  __p = 0;
  v21 = 0uLL;
  if (ULEB128 <= 3)
  {
    v8 = off_1E819DB50[ULEB128];
LABEL_13:
    MEMORY[0x1CAA32ABC](&__p, v8);
    goto LABEL_14;
  }
  if (ULEB128 > 0xC)
  {
    v8 = "Invalid";
    goto LABEL_13;
  }
  v9 = 0;
  v10 = 1 << ULEB128;
  do
  {
    v22.__r_.__value_.__s.__data_[v9-- + 20] = (v10 % 0xA) | 0x30;
    v11 = v10 > 9;
    v10 /= 0xAuLL;
  }
  while (v11);
  sub_1C4E61270(&v19, &v22.__r_.__value_.__s.__data_[v9 + 21], &v22.__r_.__value_.__s.__data_[21], -v9);
  v12 = std::string::insert(&v19, 0, "8-byte alignment, ");
  v13 = v12->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v22.__r_.__value_.__l.__data_ = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  v22.__r_.__value_.__r.__words[2] = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  v14 = std::string::append(&v22, "-byte extended alignment");
  v15 = (void *)v14->__r_.__value_.__r.__words[0];
  v23[0] = v14->__r_.__value_.__l.__size_;
  *(_QWORD *)((char *)v23 + 7) = *(std::string::size_type *)((char *)&v14->__r_.__value_.__r.__words[1] + 7);
  v16 = HIBYTE(v14->__r_.__value_.__r.__words[2]);
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v21) < 0)
    operator delete(__p);
  __p = v15;
  *(_QWORD *)&v21 = v23[0];
  *(_QWORD *)((char *)&v21 + 7) = *(_QWORD *)((char *)v23 + 7);
  HIBYTE(v21) = v16;
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v22.__r_.__value_.__l.__data_);
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v19.__r_.__value_.__l.__data_);
LABEL_14:
  if (v21 >= 0)
    p_p = &__p;
  else
    p_p = __p;
  if (v21 >= 0)
    v18 = HIBYTE(v21) & 0x7F;
  else
    v18 = v21;
  llvm::ELFAttributeParser::printAttribute(a1, a2, v7, (uint64_t)p_p, v18);
  *a3 = 0;
  if (SHIBYTE(v21) < 0)
    operator delete(__p);
}

void llvm::ARMAttributeParser::ABI_align_preserved(_QWORD *a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  unint64_t ULEB128;
  uint64_t v7;
  const char *v8;
  size_t v9;
  std::string::size_type v10;
  void *p_dst;
  char *v12;
  uint64_t v13;
  unint64_t v14;
  BOOL v15;
  void **v16;
  std::string::size_type v17;
  std::string *v18;
  std::string::size_type v19;
  std::string *v20;
  std::string::size_type v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  std::string *p_p;
  uint64_t size;
  void *v27[4];
  void *v28[2];
  char v29;
  std::string v30;
  std::string __p;
  _QWORD v32[2];
  std::string __dst;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  ULEB128 = llvm::DataExtractor::getULEB128(a1 + 16, a1 + 19, a1 + 20);
  v7 = ULEB128;
  memset(&__p, 0, sizeof(__p));
  if (ULEB128 <= 3)
  {
    v8 = off_1E819DB70[ULEB128];
    v9 = strlen(v8);
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      abort();
    v10 = v9;
    if (v9 >= 0x17)
    {
      v23 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v9 | 7) != 0x17)
        v23 = v9 | 7;
      v24 = v23 + 1;
      p_dst = operator new(v23 + 1);
      __dst.__r_.__value_.__l.__size_ = v10;
      __dst.__r_.__value_.__r.__words[2] = v24 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v9;
      p_dst = &__dst;
      if (!v9)
        goto LABEL_30;
    }
    memmove(p_dst, v8, v10);
LABEL_30:
    *((_BYTE *)p_dst + v10) = 0;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    __p = __dst;
    goto LABEL_33;
  }
  if (ULEB128 > 0xC)
  {
    MEMORY[0x1CAA32ABC](&__p, "Invalid");
  }
  else
  {
    v12 = (char *)operator new(0x20uLL);
    v13 = 0;
    v30.__r_.__value_.__r.__words[0] = (std::string::size_type)v12;
    *(_OWORD *)&v30.__r_.__value_.__r.__words[1] = xmmword_1C640C690;
    strcpy(v12, "8-byte stack alignment, ");
    v14 = 1 << v7;
    do
    {
      __dst.__r_.__value_.__s.__data_[v13-- + 20] = (v14 % 0xA) | 0x30;
      v15 = v14 > 9;
      v14 /= 0xAuLL;
    }
    while (v15);
    sub_1C4E61270(v28, &__dst.__r_.__value_.__s.__data_[v13 + 21], &__dst.__r_.__value_.__s.__data_[21], -v13);
    if (v29 >= 0)
      v16 = v28;
    else
      v16 = (void **)v28[0];
    if (v29 >= 0)
      v17 = v29 & 0x7F;
    else
      v17 = (std::string::size_type)v28[1];
    v18 = std::string::append(&v30, (const std::string::value_type *)v16, v17);
    v19 = v18->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    __dst.__r_.__value_.__r.__words[2] = v19;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    HIBYTE(v27[2]) = 20;
    strcpy((char *)v27, "-byte data alignment");
    v20 = std::string::append(&__dst, (const std::string::value_type *)v27, 0x14uLL);
    v21 = v20->__r_.__value_.__r.__words[0];
    v32[0] = v20->__r_.__value_.__l.__size_;
    *(_QWORD *)((char *)v32 + 7) = *(std::string::size_type *)((char *)&v20->__r_.__value_.__r.__words[1] + 7);
    v22 = HIBYTE(v20->__r_.__value_.__r.__words[2]);
    v20->__r_.__value_.__l.__size_ = 0;
    v20->__r_.__value_.__r.__words[2] = 0;
    v20->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    __p.__r_.__value_.__r.__words[0] = v21;
    __p.__r_.__value_.__l.__size_ = v32[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(_QWORD *)((char *)v32 + 7);
    *((_BYTE *)&__p.__r_.__value_.__s + 23) = v22;
    if (SHIBYTE(v27[2]) < 0)
      operator delete(v27[0]);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__dst.__r_.__value_.__l.__data_);
    if (v29 < 0)
      operator delete(v28[0]);
    if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v30.__r_.__value_.__l.__data_);
  }
LABEL_33:
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = *((_BYTE *)&__p.__r_.__value_.__s + 23) & 0x7F;
  else
    size = __p.__r_.__value_.__l.__size_;
  llvm::ELFAttributeParser::printAttribute(a1, a2, v7, (uint64_t)p_p, size);
  *a3 = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

uint64_t llvm::ARMAttributeParser::handler@<X0>(uint64_t this@<X0>, BOOL *a2@<X2>, uint64_t a3@<X1>, _QWORD *a4@<X8>)
{
  uint64_t v6;

  v6 = 0;
  *a2 = 0;
  while (llvm::ARMAttributeParser::displayRoutines[v6] != a3)
  {
    v6 += 6;
    if (v6 == 258)
      goto LABEL_7;
  }
  this = (*(uint64_t (**)(uint64_t))&llvm::ARMAttributeParser::displayRoutines[v6 + 2])(this);
  if (*a4)
    return this;
  *a2 = 1;
LABEL_7:
  *a4 = 0;
  return this;
}

unint64_t llvm::ARM::WinEH::SavedRegisterMask(uint64_t a1)
{
  unsigned int v1;
  int v2;
  unint64_t v3;
  unsigned int v4;
  int v5;

  v1 = *(_DWORD *)(a1 + 4);
  v2 = (v1 >> 10) & 0x800 | (v1 >> 6) & 0x4000;
  v3 = (unint64_t)~(-1 << ((BYTE2(v1) + 1) & 7)) << 40;
  if ((v1 & 0x80000) == 0)
  {
    v2 |= (32 << (BYTE2(v1) & 7)) - 16;
    v3 = 0;
  }
  v4 = v1 >> 22;
  v5 = v2 | (((2 << (BYTE2(v1) & 7)) + 0xFFFF) << (~(v1 >> 22) & 3));
  if ((v4 & 4) == 0)
    LOWORD(v5) = v2;
  if (v4 < 0x3F4)
    LOWORD(v5) = v2;
  return v3 | (unsigned __int16)v5;
}

llvm::raw_ostream *llvm::PrintRecyclerStats(llvm *this, unint64_t a2, unint64_t a3)
{
  llvm::raw_ostream *v6;
  llvm::raw_ostream *v7;
  void *v8;
  _BYTE *v9;
  void *v10;
  _BYTE *v11;
  void *v12;
  llvm::raw_ostream *result;
  _BYTE *v14;

  v6 = (llvm::raw_ostream *)llvm::errs(this);
  v7 = v6;
  v8 = (void *)*((_QWORD *)v6 + 4);
  if (*((_QWORD *)v6 + 3) - (_QWORD)v8 > 0x16uLL)
  {
    qmemcpy(v8, "Recycler element size: ", 23);
    *((_QWORD *)v6 + 4) += 23;
  }
  else
  {
    llvm::raw_ostream::write(v6, "Recycler element size: ", 0x17uLL);
  }
  sub_1C5E21910(v7, (unint64_t)this, 0, 0, 0);
  v9 = (_BYTE *)*((_QWORD *)v7 + 4);
  if ((unint64_t)v9 >= *((_QWORD *)v7 + 3))
  {
    llvm::raw_ostream::write(v7, 10);
  }
  else
  {
    *((_QWORD *)v7 + 4) = v9 + 1;
    *v9 = 10;
  }
  v10 = (void *)*((_QWORD *)v7 + 4);
  if (*((_QWORD *)v7 + 3) - (_QWORD)v10 > 0x1BuLL)
  {
    qmemcpy(v10, "Recycler element alignment: ", 28);
    *((_QWORD *)v7 + 4) += 28;
  }
  else
  {
    llvm::raw_ostream::write(v7, "Recycler element alignment: ", 0x1CuLL);
  }
  sub_1C5E21910(v7, a2, 0, 0, 0);
  v11 = (_BYTE *)*((_QWORD *)v7 + 4);
  if ((unint64_t)v11 >= *((_QWORD *)v7 + 3))
  {
    llvm::raw_ostream::write(v7, 10);
  }
  else
  {
    *((_QWORD *)v7 + 4) = v11 + 1;
    *v11 = 10;
  }
  v12 = (void *)*((_QWORD *)v7 + 4);
  if (*((_QWORD *)v7 + 3) - (_QWORD)v12 > 0x26uLL)
  {
    qmemcpy(v12, "Number of elements free for recycling: ", 39);
    *((_QWORD *)v7 + 4) += 39;
  }
  else
  {
    llvm::raw_ostream::write(v7, "Number of elements free for recycling: ", 0x27uLL);
  }
  result = sub_1C5E21910(v7, a3, 0, 0, 0);
  v14 = (_BYTE *)*((_QWORD *)v7 + 4);
  if ((unint64_t)v14 >= *((_QWORD *)v7 + 3))
    return llvm::raw_ostream::write(v7, 10);
  *((_QWORD *)v7 + 4) = v14 + 1;
  *v14 = 10;
  return result;
}

void llvm::decodeBase64(uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t *a3@<X2>, uint64_t *a4@<X8>)
{
  _BYTE *v5;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  int v16;
  int v17;
  unint64_t v18;
  _BYTE *v19;
  unint64_t v20;
  _BYTE *v21;
  unint64_t v22;
  unint64_t v23;
  size_t v24;
  char *v25;
  char *v26;
  _BYTE *v27;
  _BYTE *v28;
  char v29;
  int v30;
  unint64_t v31;
  _BYTE *v32;
  unint64_t v33;
  _BYTE *v34;
  unint64_t v35;
  unint64_t v36;
  size_t v37;
  unint64_t v38;
  char *v39;
  char *v40;
  _BYTE *v41;
  _BYTE *v42;
  char v43;
  char v44;
  unint64_t v45;
  unint64_t v46;
  _BYTE *v47;
  unint64_t v48;
  unint64_t v49;
  size_t v50;
  unint64_t v51;
  char *v52;
  char *v53;
  _BYTE *v54;
  _BYTE *v55;
  char v56;
  const std::error_category *v57;
  void **v58;
  uint64_t v59;
  size_t v60;
  size_t v61;
  size_t v62;
  uint64_t *v63;
  unint64_t v64;
  unsigned __int8 v65;
  unsigned __int8 v66;
  unsigned __int8 v67;
  char v68;
  uint64_t v69;
  const std::error_category *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  char v74;
  uint64_t v75;
  int v76;
  void **v77;
  void *__p[2];
  uint64_t v79;
  _BYTE *v80[2];
  char v81;
  unint64_t v82;
  __int16 v83;

  v5 = (_BYTE *)*a3;
  a3[1] = *a3;
  if (!a2)
  {
LABEL_75:
    *a4 = 0;
    return;
  }
  if ((a2 & 3) != 0)
  {
    v69 = 92;
    v70 = std::generic_category();
    v80[0] = "Base64 encoded strings must be a multiple of 4 bytes in length";
    sub_1C5DF1730(v80, &v69, a4);
    return;
  }
  v9 = 0;
  v10 = a2 - 2;
  v11 = a2 - 1;
  v12 = a2 - 2;
LABEL_5:
  v13 = 0;
  while (1)
  {
    v14 = *(unsigned __int8 *)(a1 + v9 + v13);
    if (v14 > 0x7A)
    {
      v15 = v9 + v13;
      goto LABEL_77;
    }
    v15 = v13 + v9;
    v16 = a456789[v14];
    if ((_DWORD)v14 != 61 || v16 == 64)
    {
      if (v16 == 64)
        goto LABEL_77;
      goto LABEL_14;
    }
    if (v15 < v10)
      goto LABEL_77;
    if (v12 == v13 && *(_BYTE *)(a1 + v11) != 61)
      break;
LABEL_14:
    *(&v65 + v13++) = v16;
    if (v13 == 4)
    {
      v63 = a4;
      v64 = v11;
      v17 = (4 * v65) | (v66 >> 4) & 3;
      v18 = a3[2];
      if ((unint64_t)v5 >= v18)
      {
        v20 = *a3;
        v21 = &v5[-*a3];
        v22 = (unint64_t)(v21 + 1);
        if ((uint64_t)(v21 + 1) < 0)
          goto LABEL_81;
        v23 = v18 - v20;
        if (2 * v23 > v22)
          v22 = 2 * v23;
        if (v23 >= 0x3FFFFFFFFFFFFFFFLL)
          v24 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v24 = v22;
        if (v24)
        {
          v60 = v24;
          v25 = (char *)operator new(v24);
          v24 = v60;
        }
        else
        {
          v25 = 0;
        }
        v26 = &v21[(_QWORD)v25];
        v27 = &v21[(_QWORD)v25];
        *v27 = v17;
        v19 = v27 + 1;
        if (v5 != (_BYTE *)v20)
        {
          v28 = &v5[~v20];
          do
          {
            v29 = *--v5;
            (v28--)[(_QWORD)v25] = v29;
          }
          while (v5 != (_BYTE *)v20);
          v5 = (_BYTE *)*a3;
          v26 = v25;
        }
        *a3 = (unint64_t)v26;
        a3[1] = (unint64_t)v19;
        a3[2] = (unint64_t)&v25[v24];
        if (v5)
          operator delete(v5);
        v11 = v64;
      }
      else
      {
        *v5 = v17;
        v19 = v5 + 1;
      }
      a3[1] = (unint64_t)v19;
      v30 = (16 * v66) | (v67 >> 2) & 0xF;
      v31 = a3[2];
      if ((unint64_t)v19 < v31)
      {
        *v19 = v30;
        v32 = v19 + 1;
        goto LABEL_52;
      }
      v33 = *a3;
      v34 = &v19[-*a3];
      v35 = (unint64_t)(v34 + 1);
      if ((uint64_t)(v34 + 1) < 0)
        goto LABEL_81;
      v36 = v31 - v33;
      if (2 * v36 > v35)
        v35 = 2 * v36;
      if (v36 >= 0x3FFFFFFFFFFFFFFFLL)
        v37 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v37 = v35;
      if (v37)
      {
        v61 = v37;
        v38 = (unint64_t)operator new(v37);
        v37 = v61;
      }
      else
      {
        v38 = 0;
      }
      v39 = &v34[v38];
      v40 = (char *)(v38 + v37);
      v41 = &v34[v38];
      *v41 = v30;
      v32 = v41 + 1;
      if (v19 == (_BYTE *)v33)
      {
        *a3 = (unint64_t)v39;
        a3[1] = (unint64_t)v32;
        a3[2] = (unint64_t)v40;
      }
      else
      {
        v42 = &v19[~v33];
        do
        {
          v43 = *--v19;
          (v42--)[v38] = v43;
        }
        while (v19 != (_BYTE *)v33);
        v19 = (_BYTE *)*a3;
        *a3 = v38;
        a3[1] = (unint64_t)v32;
        a3[2] = (unint64_t)v40;
        if (!v19)
          goto LABEL_51;
      }
      operator delete(v19);
LABEL_51:
      v11 = v64;
LABEL_52:
      a3[1] = (unint64_t)v32;
      v44 = v68 & 0x3F | (v67 << 6);
      v45 = a3[2];
      if ((unint64_t)v32 < v45)
      {
        *v32 = v44;
        v5 = v32 + 1;
        a4 = v63;
        goto LABEL_71;
      }
      v46 = *a3;
      v47 = &v32[-*a3];
      v48 = (unint64_t)(v47 + 1);
      if ((uint64_t)(v47 + 1) < 0)
LABEL_81:
        abort();
      v49 = v45 - v46;
      if (2 * v49 > v48)
        v48 = 2 * v49;
      if (v49 >= 0x3FFFFFFFFFFFFFFFLL)
        v50 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v50 = v48;
      if (v50)
      {
        v62 = v50;
        v51 = (unint64_t)operator new(v50);
        v50 = v62;
      }
      else
      {
        v51 = 0;
      }
      v52 = &v47[v51];
      v53 = (char *)(v51 + v50);
      v54 = &v47[v51];
      *v54 = v44;
      v5 = v54 + 1;
      if (v32 == (_BYTE *)v46)
      {
        *a3 = (unint64_t)v52;
        a3[1] = (unint64_t)v5;
        a3[2] = (unint64_t)v53;
        a4 = v63;
      }
      else
      {
        v55 = &v32[~v46];
        a4 = v63;
        do
        {
          v56 = *--v32;
          (v55--)[v51] = v56;
        }
        while (v32 != (_BYTE *)v46);
        v32 = (_BYTE *)*a3;
        *a3 = v51;
        a3[1] = (unint64_t)v5;
        a3[2] = (unint64_t)v53;
        if (!v32)
          goto LABEL_70;
      }
      operator delete(v32);
LABEL_70:
      v11 = v64;
LABEL_71:
      a3[1] = (unint64_t)v5;
      v9 += 4;
      v12 -= 4;
      if (v9 >= a2)
      {
        if (*(_BYTE *)(a1 + v11) == 61)
        {
          a3[1] = (unint64_t)(v5 - 1);
          if (*(_BYTE *)(a1 + v10) == 61)
            a3[1] = (unint64_t)(v5 - 2);
        }
        goto LABEL_75;
      }
      goto LABEL_5;
    }
  }
  v15 = a2 - 2;
LABEL_77:
  v57 = std::generic_category();
  __p[0] = 0;
  __p[1] = 0;
  v79 = 0;
  LODWORD(v70) = 0;
  v74 = 0;
  v75 = 0;
  v69 = (uint64_t)&unk_1E81A7208;
  v77 = __p;
  v76 = 0;
  v72 = 0;
  v73 = 0;
  v71 = 0;
  v80[0] = &off_1E819DBC8;
  v80[1] = "Invalid Base64 character %#2.2x at index %llu";
  v81 = v14;
  v82 = v15;
  llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v69, (uint64_t)v80);
  v58 = v77;
  v59 = operator new();
  v83 = 260;
  v80[0] = v58;
  *(_QWORD *)v59 = off_1E81A0C88;
  llvm::Twine::str((llvm::Twine *)v80, (_QWORD *)(v59 + 8));
  *(_QWORD *)(v59 + 32) = 92;
  *(_QWORD *)(v59 + 40) = v57;
  *(_BYTE *)(v59 + 48) = 1;
  *a4 = v59;
  v69 = (uint64_t)off_1E81A6E70;
  if (v76 == 1 && v71)
    MEMORY[0x1CAA32F9C](v71, 0x1000C8077774924);
  if (SHIBYTE(v79) < 0)
    operator delete(__p[0]);
}

uint64_t llvm::BinaryStreamError::BinaryStreamError(uint64_t a1, unsigned int a2)
{
  return llvm::BinaryStreamError::BinaryStreamError(a1, a2, "", 0);
}

{
  return llvm::BinaryStreamError::BinaryStreamError(a1, a2, "", 0);
}

uint64_t llvm::BinaryStreamError::BinaryStreamError(uint64_t a1, unsigned int a2, const std::string::value_type *a3, std::string::size_type a4)
{
  std::string *v8;

  *(_QWORD *)a1 = off_1E819DBE8;
  *(_QWORD *)(a1 + 8) = 0;
  v8 = (std::string *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 32) = a2;
  MEMORY[0x1CAA32ABC](a1 + 8, "Stream Error: ");
  if (a2 <= 4)
    std::string::append(v8, off_1E819DC28[a2]);
  if (a4)
  {
    std::string::append(v8, "  ");
    std::string::append(v8, a3, a4);
  }
  return a1;
}

uint64_t llvm::BinaryStreamError::BinaryStreamError(uint64_t a1, const std::string::value_type *a2, std::string::size_type a3)
{
  return llvm::BinaryStreamError::BinaryStreamError(a1, 0, a2, a3);
}

{
  return llvm::BinaryStreamError::BinaryStreamError(a1, 0, a2, a3);
}

char *llvm::BinaryStreamError::getErrorMessage(llvm::BinaryStreamError *this)
{
  char *v1;
  uint64_t v2;
  uint64_t v3;

  v3 = *((_QWORD *)this + 1);
  v1 = (char *)this + 8;
  v2 = v3;
  if (v1[23] >= 0)
    return v1;
  return (char *)v2;
}

uint64_t sub_1C5DD26B8(uint64_t a1)
{
  *(_QWORD *)a1 = off_1E819DBE8;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  return a1;
}

void sub_1C5DD26F4(uint64_t a1)
{
  *(_QWORD *)a1 = off_1E819DBE8;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  JUMPOUT(0x1CAA32FC0);
}

__n128 llvm::BinaryStreamReader::BinaryStreamReader(uint64_t a1, __n128 *a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  __n128 result;

  v3 = a2->n128_u64[0];
  v2 = a2->n128_i64[1];
  *(_QWORD *)a1 = &unk_1E8185470;
  *(_QWORD *)(a1 + 8) = v3;
  *(_QWORD *)(a1 + 16) = v2;
  if (v2)
  {
    v4 = (unint64_t *)(v2 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  result = a2[1];
  *(__n128 *)(a1 + 40) = a2[2];
  *(__n128 *)(a1 + 24) = result;
  *(_QWORD *)(a1 + 56) = 0;
  return result;
}

{
  uint64_t v2;
  unint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  __n128 result;

  v3 = a2->n128_u64[0];
  v2 = a2->n128_i64[1];
  *(_QWORD *)a1 = &unk_1E8185470;
  *(_QWORD *)(a1 + 8) = v3;
  *(_QWORD *)(a1 + 16) = v2;
  if (v2)
  {
    v4 = (unint64_t *)(v2 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  result = a2[1];
  *(__n128 *)(a1 + 40) = a2[2];
  *(__n128 *)(a1 + 24) = result;
  *(_QWORD *)(a1 + 56) = 0;
  return result;
}

_QWORD *llvm::BinaryStreamReader::BinaryStreamReader(_QWORD *a1, uint64_t a2)
{
  *a1 = &unk_1E8185470;
  llvm::BinaryStreamRef::BinaryStreamRef((uint64_t)(a1 + 1), a2);
  a1[7] = 0;
  return a1;
}

{
  *a1 = &unk_1E8185470;
  llvm::BinaryStreamRef::BinaryStreamRef((uint64_t)(a1 + 1), a2);
  a1[7] = 0;
  return a1;
}

_QWORD *llvm::BinaryStreamReader::BinaryStreamReader(_QWORD *a1, std::__shared_weak_count_vtbl *a2, uint64_t a3, int a4)
{
  *a1 = &unk_1E8185470;
  llvm::BinaryStreamRef::BinaryStreamRef(a1 + 1, a2, a3, a4);
  a1[7] = 0;
  return a1;
}

{
  *a1 = &unk_1E8185470;
  llvm::BinaryStreamRef::BinaryStreamRef(a1 + 1, a2, a3, a4);
  a1[7] = 0;
  return a1;
}

{
  *a1 = &unk_1E8185470;
  llvm::BinaryStreamRef::BinaryStreamRef(a1 + 1, a2, a3, a4);
  a1[7] = 0;
  return a1;
}

{
  *a1 = &unk_1E8185470;
  llvm::BinaryStreamRef::BinaryStreamRef(a1 + 1, a2, a3, a4);
  a1[7] = 0;
  return a1;
}

uint64_t llvm::BinaryStreamReader::readLongestContiguousChunk@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result;

  result = llvm::BinaryStreamRef::readLongestContiguousChunk(a1 + 8, *(_QWORD *)(a1 + 56), a2, a3);
  if (!*a3)
  {
    *(_QWORD *)(a1 + 56) += *(_QWORD *)(a2 + 8);
    *a3 = 0;
  }
  return result;
}

void llvm::BinaryStreamReader::readULEB128(llvm::BinaryStreamReader *this@<X0>, unint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  char *v6;
  char v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unsigned int v12;
  _QWORD *v13;
  char v14;
  uint64_t v15;
  _QWORD v16[2];
  void *v17;
  __int128 v18;
  _QWORD v19[3];

  v19[2] = *MEMORY[0x1E0C80C00];
  v16[1] = 0;
  v17 = v19;
  v18 = xmmword_1C85FA040;
  v6 = (char *)this + 8;
  v16[0] = 0;
  do
  {
    llvm::BinaryStreamRef::readBytes((uint64_t)v6, *((_QWORD *)this + 7), 1, (uint64_t)v16, a3);
    if (*a3)
    {
      v13 = v17;
      goto LABEL_15;
    }
    ++*((_QWORD *)this + 7);
    *a3 = 0;
    v7 = *(_BYTE *)v16[0];
    v8 = v18;
    if ((unint64_t)(v18 + 1) > *((_QWORD *)&v18 + 1))
    {
      llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v17, v19, v18 + 1, 1);
      v8 = v18;
    }
    *((_BYTE *)v17 + v8) = v7;
    v9 = v18 + 1;
    *(_QWORD *)&v18 = v18 + 1;
  }
  while (*(char *)v16[0] < 0);
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = v17;
  while (v9 != v10)
  {
    v14 = *((_BYTE *)v17 + v10);
    v15 = v14 & 0x7F;
    if (v12 >= 0x40 && (v14 & 0x7F) != 0)
      break;
    if ((unint64_t)(v15 << v12) >> v12 != v15)
      break;
    v11 += v15 << v12;
    v12 += 7;
    ++v10;
    if ((v14 & 0x80) == 0)
      goto LABEL_14;
  }
  v11 = 0;
LABEL_14:
  *a2 = v11;
  *a3 = 0;
LABEL_15:
  if (v13 != v19)
    free(v13);
}

void llvm::BinaryStreamReader::readSLEB128(llvm::BinaryStreamReader *this@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  char *v6;
  char v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  _QWORD *v13;
  char v14;
  uint64_t v15;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;
  _QWORD v20[2];
  void *v21;
  __int128 v22;
  _QWORD v23[3];

  v23[2] = *MEMORY[0x1E0C80C00];
  v20[1] = 0;
  v21 = v23;
  v22 = xmmword_1C85FA040;
  v6 = (char *)this + 8;
  v20[0] = 0;
  do
  {
    llvm::BinaryStreamRef::readBytes((uint64_t)v6, *((_QWORD *)this + 7), 1, (uint64_t)v20, a3);
    if (*a3)
    {
      v13 = v21;
      goto LABEL_26;
    }
    ++*((_QWORD *)this + 7);
    *a3 = 0;
    v7 = *(_BYTE *)v20[0];
    v8 = v22;
    if ((unint64_t)(v22 + 1) > *((_QWORD *)&v22 + 1))
    {
      llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v21, v23, v22 + 1, 1);
      v8 = v22;
    }
    *((_BYTE *)v21 + v8) = v7;
    v9 = v22 + 1;
    *(_QWORD *)&v22 = v22 + 1;
  }
  while (*(char *)v20[0] < 0);
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = v21;
  do
  {
    if (v9 == v10)
    {
LABEL_18:
      v17 = 0;
      goto LABEL_25;
    }
    v14 = *((_BYTE *)v21 + v10);
    v15 = v14 & 0x7F;
    if (v12 >= 0x40)
    {
      if (((v11 >> 63) & 0x7F) != v15)
        goto LABEL_18;
    }
    else if (v12 == 63 && (_DWORD)v15 != 127 && (_DWORD)v15 != 0)
    {
      goto LABEL_18;
    }
    v11 |= v15 << v12;
    v12 += 7;
    ++v10;
  }
  while (v14 < 0);
  v18 = (v14 & 0x40) == 0 || v12 > 0x3F;
  v19 = -1 << v12;
  if (v18)
    v19 = 0;
  v17 = v11 | v19;
LABEL_25:
  *a2 = v17;
  *a3 = 0;
LABEL_26:
  if (v13 != v23)
    free(v13);
}

uint64_t llvm::BinaryStreamReader::readCString@<X0>(llvm::BinaryStreamReader *this@<X0>, llvm::StringRef *a2@<X1>, uint64_t *a3@<X8>)
{
  unint64_t v6;
  char *v7;
  uint64_t result;
  unint64_t v9;
  size_t v10;
  unint64_t v11;
  _BYTE *v12;
  _BYTE *v13;
  int64_t v14;
  unint64_t v16;
  void *__s;
  size_t __n;

  v6 = *((_QWORD *)this + 7);
  v7 = (char *)this + 8;
  __s = 0;
  __n = 0;
  result = llvm::BinaryStreamRef::readLongestContiguousChunk((uint64_t)this + 8, v6, (uint64_t)&__s, a3);
  if (!*a3)
  {
    v9 = v6;
    while (1)
    {
      v10 = __n;
      v11 = *((_QWORD *)this + 7) + __n;
      *((_QWORD *)this + 7) = v11;
      *a3 = 0;
      if (v10)
      {
        v12 = __s;
        v13 = memchr(__s, 0, v10);
        v14 = v13 - v12;
        if (v13 && v14 != -1)
          break;
      }
      __s = 0;
      __n = 0;
      result = llvm::BinaryStreamRef::readLongestContiguousChunk((uint64_t)v7, v11, (uint64_t)&__s, a3);
      v9 = v11;
      if (*a3)
        return result;
    }
    v16 = v14 + v9;
    *((_QWORD *)this + 7) = v6;
    result = llvm::BinaryStreamReader::readFixedString(this, a2, (int)v14 + (int)v9 - (int)v6, a3);
    if (!*a3)
    {
      *((_QWORD *)this + 7) = v16 + 1;
      *a3 = 0;
    }
  }
  return result;
}

uint64_t llvm::BinaryStreamReader::readWideString@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v6;
  uint64_t result;
  unsigned int v8;
  uint64_t v9;
  _WORD *v10;

  v6 = *(_QWORD *)(a1 + 56);
  v10 = 0;
  result = sub_1C5DD2E14(a1, &v10, a3);
  if (!*a3)
  {
    v8 = 0;
    while (*v10)
    {
      ++v8;
      result = sub_1C5DD2E14(a1, &v10, a3);
      if (*a3)
        return result;
    }
    v9 = *(_QWORD *)(a1 + 56);
    *(_QWORD *)(a1 + 56) = v6;
    result = sub_1C59A0758(a1, a2, v8, a3);
    if (!*a3)
    {
      *(_QWORD *)(a1 + 56) = v9;
      *a3 = 0;
    }
  }
  return result;
}

uint64_t sub_1C5DD2E14@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result;
  _QWORD v7[2];

  v7[0] = 0;
  v7[1] = 0;
  result = llvm::BinaryStreamRef::readBytes(a1 + 8, *(_QWORD *)(a1 + 56), 2, (uint64_t)v7, a3);
  if (!*a3)
  {
    *(_QWORD *)(a1 + 56) += 2;
    *a2 = v7[0];
    *a3 = 0;
  }
  return result;
}

uint64_t llvm::BinaryStreamReader::readStreamRef@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v6;
  uint64_t v7;

  if (*(_BYTE *)(a1 + 48))
  {
    v6 = *(_QWORD *)(a1 + 40);
  }
  else
  {
    v7 = *(_QWORD *)(a1 + 24);
    if (v7)
      v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 40))(v7) - *(_QWORD *)(a1 + 32);
    else
      LODWORD(v6) = 0;
  }
  return llvm::BinaryStreamReader::readStreamRef(a1, a2, (int)v6 - *(_DWORD *)(a1 + 56), a3);
}

uint64_t llvm::BinaryStreamReader::readStreamRef@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned int a3@<W2>, uint64_t *a4@<X8>)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t result;
  __int128 v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  __int128 v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  _OWORD v21[3];

  if (*(_BYTE *)(a1 + 48))
  {
    v8 = *(_QWORD *)(a1 + 40);
  }
  else
  {
    v9 = *(_QWORD *)(a1 + 24);
    if (v9)
      v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 40))(v9) - *(_QWORD *)(a1 + 32);
    else
      v8 = 0;
  }
  v10 = *(_QWORD *)(a1 + 56);
  if (v8 - v10 >= a3)
  {
    sub_1C5DD3054(a1 + 8, v10, a3, (uint64_t)v21);
    v13 = v21[0];
    v21[0] = 0uLL;
    v14 = *(std::__shared_weak_count **)(a2 + 8);
    *(_OWORD *)a2 = v13;
    if (v14)
    {
      p_shared_owners = (unint64_t *)&v14->__shared_owners_;
      do
        v16 = __ldaxr(p_shared_owners);
      while (__stlxr(v16 - 1, p_shared_owners));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
    v17 = v21[2];
    *(_OWORD *)(a2 + 16) = v21[1];
    *(_OWORD *)(a2 + 32) = v17;
    v18 = (std::__shared_weak_count *)*((_QWORD *)&v21[0] + 1);
    if (*((_QWORD *)&v21[0] + 1))
    {
      v19 = (unint64_t *)(*((_QWORD *)&v21[0] + 1) + 8);
      do
        v20 = __ldaxr(v19);
      while (__stlxr(v20 - 1, v19));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
    }
    result = 0;
    *(_QWORD *)(a1 + 56) += a3;
  }
  else
  {
    v11 = operator new();
    result = llvm::BinaryStreamError::BinaryStreamError(v11, 1u, "", 0);
  }
  *a4 = result;
  return result;
}

void sub_1C5DD3054(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;

  sub_1C5DD356C(a1, a2, (uint64_t)&v11);
  if (v16)
  {
    v6 = v15;
  }
  else if (v13)
  {
    v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v13 + 40))(v13);
    v6 = v7 - v14;
  }
  else
  {
    v6 = 0;
  }
  sub_1C5DD362C((uint64_t)&v11, v6 - a3, a4);
  v8 = v12;
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

uint64_t llvm::BinaryStreamReader::readSubstream@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, unsigned int a3@<W2>, uint64_t *a4@<X8>)
{
  *a2 = *(_QWORD *)(a1 + 56);
  return llvm::BinaryStreamReader::readStreamRef(a1, (uint64_t)(a2 + 1), a3, a4);
}

uint64_t llvm::BinaryStreamReader::padToAlignment@<X0>(llvm::BinaryStreamReader *this@<X0>, unsigned int a2@<W1>, _QWORD *a3@<X8>)
{
  return llvm::BinaryStreamReader::skip(this, ((*((_QWORD *)this + 7) + (unint64_t)a2 - 1) / a2) * a2 - *((_QWORD *)this + 7), a3);
}

void llvm::BinaryStreamReader::split(llvm::BinaryStreamReader *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  char v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  unsigned __int8 v13;
  char v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  __int128 v18;
  std::__shared_weak_count *v19;
  unint64_t *p_shared_owners;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  __int128 v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t *v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  __int128 v37;
  unint64_t *v38;
  unint64_t v39;
  unint64_t *v40;
  unint64_t v41;
  unint64_t *v42;
  unint64_t v43;
  unint64_t *v44;
  unint64_t v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  unint64_t v49;
  _BYTE v50[7];
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  _DWORD v56[2];
  __int128 v57;
  __int128 v58;
  __int128 v59;

  sub_1C5DD356C((uint64_t)this + 8, *((_QWORD *)this + 7), (uint64_t)&v57);
  v5 = v58;
  if (!(_QWORD)v58)
  {
    v7 = 0;
    v8 = 0;
    LOBYTE(v9) = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    memset(v56, 0, 7);
    if (!BYTE8(v59))
      goto LABEL_16;
LABEL_5:
    v49 = v10;
    v13 = v9;
    v9 = v59;
    v14 = v5;
    goto LABEL_20;
  }
  if (BYTE8(v59))
    v6 = v59;
  else
    v6 = (*(uint64_t (**)(void))(*(_QWORD *)v58 + 40))() - *((_QWORD *)&v58 + 1);
  if (v6 >= a2)
    v6 = a2;
  v11 = (std::__shared_weak_count *)*((_QWORD *)&v57 + 1);
  v12 = v57;
  if (*((_QWORD *)&v57 + 1))
  {
    v15 = (unint64_t *)(*((_QWORD *)&v57 + 1) + 8);
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  v10 = *((_QWORD *)&v58 + 1);
  v7 = v58;
  v9 = v59;
  v8 = (unint64_t)v59 >> 8;
  v14 = BYTE8(v59);
  v56[0] = *(_DWORD *)((char *)&v59 + 9);
  *(_DWORD *)((char *)v56 + 3) = HIDWORD(v59);
  if (v6)
  {
    v10 = *((_QWORD *)&v58 + 1) + v6;
    if (BYTE8(v59))
    {
      v49 = *((_QWORD *)&v58 + 1) + v6;
      v13 = v59 - v6;
      v8 = ((unint64_t)v59 - v6) >> 8;
      goto LABEL_20;
    }
    goto LABEL_17;
  }
  v5 = BYTE8(v59);
  if (BYTE8(v59))
    goto LABEL_5;
LABEL_16:
  v14 = v5;
LABEL_17:
  v49 = v10;
  if (v7)
  {
    v17 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 40))(v7);
    v13 = v9;
    v9 = v17 - *((_QWORD *)&v58 + 1);
  }
  else
  {
    v13 = v9;
    v9 = 0;
  }
LABEL_20:
  sub_1C5DD362C((uint64_t)&v57, v9 - a2, (uint64_t)&v53);
  v18 = v53;
  v53 = 0uLL;
  v19 = (std::__shared_weak_count *)*((_QWORD *)&v57 + 1);
  v57 = v18;
  if (v19)
  {
    p_shared_owners = (unint64_t *)&v19->__shared_owners_;
    do
      v21 = __ldaxr(p_shared_owners);
    while (__stlxr(v21 - 1, p_shared_owners));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  v58 = v54;
  v59 = v55;
  v22 = (std::__shared_weak_count *)*((_QWORD *)&v53 + 1);
  if (*((_QWORD *)&v53 + 1))
  {
    v23 = (unint64_t *)(*((_QWORD *)&v53 + 1) + 8);
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
  v25 = v57;
  if (*((_QWORD *)&v57 + 1))
  {
    v26 = (unint64_t *)(*((_QWORD *)&v57 + 1) + 8);
    do
      v27 = __ldxr(v26);
    while (__stxr(v27 + 1, v26));
    v51 = v58;
    v52 = v59;
    do
      v28 = __ldxr(v26);
    while (__stxr(v28 + 1, v26));
    v53 = v51;
    v54 = v52;
    do
      v29 = __ldaxr(v26);
    while (__stlxr(v29 - 1, v26));
    if (!v29)
    {
      (*(void (**)(_QWORD))(**((_QWORD **)&v25 + 1) + 16))(*((_QWORD *)&v25 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v25 + 1));
    }
  }
  else
  {
    v53 = v58;
    v54 = v59;
  }
  v30 = v13 | (v8 << 8);
  if (v11)
  {
    v31 = (unint64_t *)&v11->__shared_owners_;
    do
      v32 = __ldxr(v31);
    while (__stxr(v32 + 1, v31));
    do
      v33 = __ldxr(v31);
    while (__stxr(v33 + 1, v31));
    *(_DWORD *)v50 = v56[0];
    *(_DWORD *)&v50[3] = *(_DWORD *)((char *)v56 + 3);
    do
      v34 = __ldaxr(v31);
    while (__stlxr(v34 - 1, v31));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  else
  {
    *(_DWORD *)v50 = v56[0];
    *(_DWORD *)&v50[3] = *(_DWORD *)((char *)v56 + 3);
  }
  *(_QWORD *)a3 = &unk_1E8185470;
  *(_OWORD *)(a3 + 8) = v25;
  if (*((_QWORD *)&v25 + 1))
  {
    v35 = (unint64_t *)(*((_QWORD *)&v25 + 1) + 8);
    do
      v36 = __ldxr(v35);
    while (__stxr(v36 + 1, v35));
  }
  v37 = v54;
  *(_OWORD *)(a3 + 24) = v53;
  *(_OWORD *)(a3 + 40) = v37;
  *(_QWORD *)(a3 + 56) = 0;
  *(_QWORD *)(a3 + 64) = &unk_1E8185470;
  *(_QWORD *)(a3 + 72) = v12;
  *(_QWORD *)(a3 + 80) = v11;
  if (v11)
  {
    v38 = (unint64_t *)&v11->__shared_owners_;
    do
      v39 = __ldxr(v38);
    while (__stxr(v39 + 1, v38));
  }
  *(_QWORD *)(a3 + 88) = v7;
  *(_QWORD *)(a3 + 96) = v49;
  *(_QWORD *)(a3 + 104) = v30;
  *(_BYTE *)(a3 + 112) = v14;
  *(_DWORD *)(a3 + 113) = *(_DWORD *)v50;
  *(_DWORD *)(a3 + 116) = *(_DWORD *)&v50[3];
  *(_QWORD *)(a3 + 120) = 0;
  if (v11)
  {
    v40 = (unint64_t *)&v11->__shared_owners_;
    do
      v41 = __ldaxr(v40);
    while (__stlxr(v41 - 1, v40));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  if (*((_QWORD *)&v25 + 1))
  {
    v42 = (unint64_t *)(*((_QWORD *)&v25 + 1) + 8);
    do
      v43 = __ldaxr(v42);
    while (__stlxr(v43 - 1, v42));
    if (!v43)
    {
      (*(void (**)(_QWORD))(**((_QWORD **)&v25 + 1) + 16))(*((_QWORD *)&v25 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v25 + 1));
    }
  }
  if (v11)
  {
    v44 = (unint64_t *)&v11->__shared_owners_;
    do
      v45 = __ldaxr(v44);
    while (__stlxr(v45 - 1, v44));
    if (!v45)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  v46 = (std::__shared_weak_count *)*((_QWORD *)&v57 + 1);
  if (*((_QWORD *)&v57 + 1))
  {
    v47 = (unint64_t *)(*((_QWORD *)&v57 + 1) + 8);
    do
      v48 = __ldaxr(v47);
    while (__stlxr(v48 - 1, v47));
    if (!v48)
    {
      ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
      std::__shared_weak_count::__release_weak(v46);
    }
  }
}

uint64_t sub_1C5DD356C@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t result;
  _OWORD *v6;
  unint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  __int128 v12;

  v6 = (_OWORD *)(a1 + 16);
  result = *(_QWORD *)(a1 + 16);
  if (result)
  {
    if (*(_BYTE *)(a1 + 40))
    {
      v8 = *(_QWORD *)(a1 + 32);
    }
    else
    {
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
      v8 = result - *(_QWORD *)(a1 + 24);
    }
    if (v8 >= a2)
      v8 = a2;
    v9 = *(_QWORD *)(a1 + 8);
    *(_QWORD *)a3 = *(_QWORD *)a1;
    *(_QWORD *)(a3 + 8) = v9;
    if (v9)
    {
      v10 = (unint64_t *)(v9 + 8);
      do
        v11 = __ldxr(v10);
      while (__stxr(v11 + 1, v10));
    }
    v12 = v6[1];
    *(_OWORD *)(a3 + 16) = *v6;
    *(_OWORD *)(a3 + 32) = v12;
    if (v8)
    {
      *(_QWORD *)(a3 + 24) += v8;
      if (*(_BYTE *)(a3 + 40))
        *(_QWORD *)(a3 + 32) -= v8;
    }
  }
  else
  {
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
  }
  return result;
}

uint64_t sub_1C5DD362C@<X0>(uint64_t result@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  _OWORD *v4;
  uint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  __int128 v10;
  unint64_t v11;
  uint64_t v12;

  v4 = (_OWORD *)(result + 16);
  if (*(_QWORD *)(result + 16))
  {
    v6 = result;
    v7 = *(_QWORD *)(result + 8);
    *(_QWORD *)a3 = *(_QWORD *)result;
    *(_QWORD *)(a3 + 8) = v7;
    if (v7)
    {
      v8 = (unint64_t *)(v7 + 8);
      do
        v9 = __ldxr(v8);
      while (__stxr(v9 + 1, v8));
    }
    v10 = *(_OWORD *)(result + 32);
    *(_OWORD *)(a3 + 16) = *v4;
    *(_OWORD *)(a3 + 32) = v10;
    if (*(_BYTE *)(result + 40))
    {
      v11 = *(_QWORD *)(result + 32);
    }
    else
    {
      result = *(_QWORD *)v4;
      if (*(_QWORD *)v4)
      {
        result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
        v11 = result - *(_QWORD *)(v6 + 24);
      }
      else
      {
        v11 = 0;
      }
    }
    if (v11 < a2)
      a2 = v11;
    if (a2)
    {
      if (*(_BYTE *)(a3 + 40))
      {
        v12 = *(_QWORD *)(a3 + 32);
      }
      else
      {
        if (*(_BYTE *)(v6 + 40))
        {
          v12 = *(_QWORD *)(v6 + 32);
        }
        else
        {
          result = *(_QWORD *)v4;
          if (*(_QWORD *)v4)
          {
            result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
            v12 = result - *(_QWORD *)(v6 + 24);
          }
          else
          {
            v12 = 0;
          }
        }
        *(_BYTE *)(a3 + 40) = 1;
      }
      *(_QWORD *)(a3 + 32) = v12 - a2;
    }
  }
  else
  {
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
  }
  return result;
}

_QWORD *llvm::BinaryStreamRef::BinaryStreamRef(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *result = 0;
  result[1] = 0;
  result[2] = a2;
  result[3] = a3;
  result[4] = a4;
  result[5] = a5;
  return result;
}

{
  *result = 0;
  result[1] = 0;
  result[2] = a2;
  result[3] = a3;
  result[4] = a4;
  result[5] = a5;
  return result;
}

_QWORD *llvm::BinaryStreamRef::BinaryStreamRef(_QWORD *a1, std::__shared_weak_count_vtbl *a2, uint64_t a3, int a4)
{
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  unint64_t v12;

  v8 = (std::__shared_weak_count *)operator new(0x40uLL);
  v9 = v8;
  v8->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v8->__shared_owners_;
  v8->__shared_weak_owners_ = 0;
  v8->__vftable = (std::__shared_weak_count_vtbl *)&off_1E819DC60;
  v8[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1E819DC98;
  v8[1].__shared_owners_ = (uint64_t)&unk_1E818AD00;
  LODWORD(v8[1].__shared_weak_owners_) = a4;
  v8[2].__vftable = a2;
  v8[2].__shared_owners_ = a3;
  *a1 = v8 + 1;
  a1[1] = v8;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  a1[2] = v8 + 1;
  a1[3] = 0;
  a1[4] = a3;
  a1[5] = 1;
  do
    v12 = __ldaxr(p_shared_owners);
  while (__stlxr(v12 - 1, p_shared_owners));
  if (!v12)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v9);
  }
  return a1;
}

_QWORD *llvm::WritableBinaryStreamRef::WritableBinaryStreamRef(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *result = 0;
  result[1] = 0;
  result[2] = a2;
  result[3] = a3;
  result[4] = a4;
  result[5] = a5;
  return result;
}

{
  *result = 0;
  result[1] = 0;
  result[2] = a2;
  result[3] = a3;
  result[4] = a4;
  result[5] = a5;
  return result;
}

__n128 llvm::WritableBinaryStreamRef::operator llvm::BinaryStreamRef@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v3;
  __n128 result;

  v2 = *(_QWORD *)(a1 + 16);
  v3 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = v2;
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(a2 + 24) = result;
  *(_QWORD *)(a2 + 40) = v3;
  return result;
}

uint64_t llvm::WritableBinaryStreamRef::commit(llvm::WritableBinaryStreamRef *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 64))(*((_QWORD *)this + 2));
}

void sub_1C5DD3888(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E819DC60;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1C5DD3898(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E819DC60;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C5DD38C8(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void sub_1C5DD38DC()
{
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C5DD38F0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t sub_1C5DD38F8@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t result;

  result = sub_1C62DE234(a1 + 8, a2, a3, a5);
  if (!*a5)
  {
    *a4 = *(_QWORD *)(a1 + 24) + a2;
    a4[1] = a3;
    *a5 = 0;
  }
  return result;
}

uint64_t sub_1C5DD3954@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _QWORD *a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t result;
  unint64_t v9;

  result = sub_1C62DE234(a1 + 8, a2, 1, a4);
  if (!*a4)
  {
    v9 = *(_QWORD *)(a1 + 32) - a2;
    *a3 = *(_QWORD *)(a1 + 24) + a2;
    a3[1] = v9;
    *a4 = 0;
  }
  return result;
}

uint64_t sub_1C5DD39AC(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

void sub_1C5DD39B4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E819DCE0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1C5DD39C4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E819DCE0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C5DD39F4(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void sub_1C5DD3A08()
{
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C5DD3A1C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 40);
}

uint64_t sub_1C5DD3A24@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t result;

  result = sub_1C62DE234(a1 + 32, a2, a3, a5);
  if (!*a5)
  {
    *a4 = *(_QWORD *)(a1 + 48) + a2;
    a4[1] = a3;
    *a5 = 0;
  }
  return result;
}

uint64_t sub_1C5DD3A80@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _QWORD *a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t result;
  unint64_t v9;

  result = sub_1C62DE234(a1 + 32, a2, 1, a4);
  if (!*a4)
  {
    v9 = *(_QWORD *)(a1 + 56) - a2;
    *a3 = *(_QWORD *)(a1 + 48) + a2;
    a3[1] = v9;
    *a4 = 0;
  }
  return result;
}

uint64_t sub_1C5DD3AD8(uint64_t a1)
{
  return *(_QWORD *)(a1 + 56);
}

unint64_t sub_1C5DD3AE0@<X0>(unint64_t result@<X0>, unint64_t a2@<X1>, const void *a3@<X2>, size_t a4@<X3>, uint64_t *a5@<X8>)
{
  unint64_t v9;

  if (!a4)
    goto LABEL_2;
  v9 = result;
  result = sub_1C6383150(result + 8, a2, a4, a5);
  if (!*a5)
  {
    result = (unint64_t)memcpy((void *)(*(_QWORD *)(v9 + 16) + a2), a3, a4);
LABEL_2:
    *a5 = 0;
  }
  return result;
}

void sub_1C5DD3B54(_QWORD *a1@<X8>)
{
  *a1 = 0;
}

__n128 llvm::BinaryStreamWriter::BinaryStreamWriter(uint64_t a1, __n128 *a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  __n128 result;

  v3 = a2->n128_u64[0];
  v2 = a2->n128_i64[1];
  *(_QWORD *)a1 = &unk_1E819DDC8;
  *(_QWORD *)(a1 + 8) = v3;
  *(_QWORD *)(a1 + 16) = v2;
  if (v2)
  {
    v4 = (unint64_t *)(v2 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  result = a2[1];
  *(__n128 *)(a1 + 40) = a2[2];
  *(__n128 *)(a1 + 24) = result;
  *(_QWORD *)(a1 + 56) = 0;
  return result;
}

{
  uint64_t v2;
  unint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  __n128 result;

  v3 = a2->n128_u64[0];
  v2 = a2->n128_i64[1];
  *(_QWORD *)a1 = &unk_1E819DDC8;
  *(_QWORD *)(a1 + 8) = v3;
  *(_QWORD *)(a1 + 16) = v2;
  if (v2)
  {
    v4 = (unint64_t *)(v2 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  result = a2[1];
  *(__n128 *)(a1 + 40) = a2[2];
  *(__n128 *)(a1 + 24) = result;
  *(_QWORD *)(a1 + 56) = 0;
  return result;
}

_QWORD *llvm::BinaryStreamWriter::BinaryStreamWriter(_QWORD *a1, uint64_t a2)
{
  *a1 = &unk_1E819DDC8;
  llvm::BinaryStreamRef::BinaryStreamRef((uint64_t)(a1 + 1), a2);
  a1[7] = 0;
  return a1;
}

{
  *a1 = &unk_1E819DDC8;
  llvm::BinaryStreamRef::BinaryStreamRef((uint64_t)(a1 + 1), a2);
  a1[7] = 0;
  return a1;
}

_QWORD *llvm::BinaryStreamWriter::BinaryStreamWriter(_QWORD *a1, std::__shared_weak_count_vtbl *a2, std::__shared_weak_count_vtbl *a3, int a4)
{
  *a1 = &unk_1E819DDC8;
  llvm::WritableBinaryStreamRef::WritableBinaryStreamRef(a1 + 1, a2, a3, a4);
  a1[7] = 0;
  return a1;
}

{
  *a1 = &unk_1E819DDC8;
  llvm::WritableBinaryStreamRef::WritableBinaryStreamRef(a1 + 1, a2, a3, a4);
  a1[7] = 0;
  return a1;
}

uint64_t llvm::BinaryStreamWriter::writeULEB128@<X0>(llvm::BinaryStreamWriter *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v5;
  BOOL v6;
  uint64_t result;
  uint64_t v8;
  __int16 v9;
  uint64_t v10;

  v5 = 0;
  v10 = *MEMORY[0x1E0C80C00];
  v9 = 0;
  v8 = 0;
  do
  {
    v6 = a2 > 0x7F;
    *((_BYTE *)&v8 + v5++) = a2 & 0x7F | ((a2 > 0x7F) << 7);
    a2 >>= 7;
  }
  while (v6);
  result = llvm::WritableBinaryStreamRef::writeBytes((uint64_t)this + 8, *((_QWORD *)this + 7), (uint64_t)&v8, v5, a3);
  if (!*a3)
  {
    *((_QWORD *)this + 7) += v5;
    *a3 = 0;
  }
  return result;
}

uint64_t llvm::BinaryStreamWriter::writeSLEB128@<X0>(llvm::BinaryStreamWriter *this@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t *v5;
  char v6;
  uint64_t v7;
  int v8;
  char v9;
  uint64_t v10;
  uint64_t result;
  uint64_t v12;
  __int16 v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  v12 = 0;
  v5 = &v12;
  while (1)
  {
    v6 = a2 & 0x7F;
    if ((unint64_t)a2 <= 0x3F)
      break;
    v7 = ((unint64_t)a2 >> 6) & 1;
    a2 >>= 7;
    v8 = (a2 == -1) & v7;
    if (v8)
      v9 = 0;
    else
      v9 = 0x80;
    *(_BYTE *)v5 = v9 | v6;
    v5 = (uint64_t *)((char *)v5 + 1);
    if (v8)
      goto LABEL_9;
  }
  *(_BYTE *)v5 = v6;
  LODWORD(v5) = (_DWORD)v5 + 1;
LABEL_9:
  v10 = v5 - &v12;
  result = llvm::WritableBinaryStreamRef::writeBytes((uint64_t)this + 8, *((_QWORD *)this + 7), (uint64_t)&v12, v10, a3);
  if (!*a3)
  {
    *((_QWORD *)this + 7) += v10;
    *a3 = 0;
  }
  return result;
}

uint64_t llvm::BinaryStreamWriter::writeFixedString@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t result;

  result = llvm::WritableBinaryStreamRef::writeBytes(a1 + 8, *(_QWORD *)(a1 + 56), a2, a3, a4);
  if (!*a4)
  {
    *(_QWORD *)(a1 + 56) += a3;
    *a4 = 0;
  }
  return result;
}

void llvm::BinaryStreamWriter::writeStreamRef(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  __int128 v16;
  __int128 v17;

  v5 = (std::__shared_weak_count *)a2[1];
  v14 = *a2;
  v15 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v8 = *((_OWORD *)a2 + 2);
  v16 = *((_OWORD *)a2 + 1);
  v17 = v8;
  if (*((_BYTE *)a2 + 40))
  {
    v9 = a2[4];
  }
  else
  {
    v10 = a2[2];
    if (v10)
      v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 40))(v10) - a2[3];
    else
      v9 = 0;
  }
  llvm::BinaryStreamWriter::writeStreamRef(a1, (uint64_t)&v14, v9, a3);
  v11 = v15;
  if (v15)
  {
    v12 = (unint64_t *)&v15->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
}

void llvm::BinaryStreamWriter::writeStreamRef(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  __int128 v21;
  __int128 v22;
  _QWORD v23[2];
  std::__shared_weak_count *v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;

  sub_1C5DD3054(a2, 0, a3, (uint64_t)&v19);
  v23[0] = &unk_1E8185470;
  v23[1] = v19;
  v24 = v20;
  if (v20)
  {
    p_shared_owners = (unint64_t *)&v20->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
    v8 = v20;
    v25 = v21;
    v26 = v22;
    v27 = 0;
    if (v20)
    {
      v9 = (unint64_t *)&v20->__shared_owners_;
      do
        v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
  }
  else
  {
    v25 = v21;
    v26 = v22;
    v27 = 0;
  }
  while (1)
  {
    if (BYTE8(v26))
    {
      v11 = v26;
    }
    else if ((_QWORD)v25)
    {
      v12 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v25 + 40))(v25);
      v11 = v12 - *((_QWORD *)&v25 + 1);
    }
    else
    {
      v11 = 0;
    }
    if (v11 == v27)
      break;
    v17 = 0;
    v18 = 0;
    llvm::BinaryStreamReader::readLongestContiguousChunk((uint64_t)v23, (uint64_t)&v17, a4);
    if (*a4)
      goto LABEL_20;
    v13 = v18;
    llvm::WritableBinaryStreamRef::writeBytes(a1 + 8, *(_QWORD *)(a1 + 56), v17, v18, a4);
    if (*a4)
      goto LABEL_20;
    *(_QWORD *)(a1 + 56) += v13;
    *a4 = 0;
  }
  *a4 = 0;
LABEL_20:
  v23[0] = &unk_1E8185470;
  v14 = v24;
  if (v24)
  {
    v15 = (unint64_t *)&v24->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
}

void llvm::BinaryStreamWriter::split(llvm::BinaryStreamWriter *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  __int128 v14;
  uint64_t v15;
  int v16;
  unint64_t v17;
  char v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  unsigned __int8 v24;
  __int128 v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  __int128 v32;
  unint64_t *v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t *v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t *v42;
  unint64_t v43;
  __int128 v44;
  unint64_t *v45;
  unint64_t v46;
  unint64_t *v47;
  unint64_t v48;
  unint64_t *v49;
  unint64_t v50;
  unint64_t *v51;
  unint64_t v52;
  std::__shared_weak_count *v53;
  unint64_t *v54;
  unint64_t v55;
  char v56;
  _BYTE v57[7];
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  _DWORD v63[2];
  __int128 v64;
  __int128 v65;
  __int128 v66;

  v7 = (char *)this + 24;
  v6 = *((_QWORD *)this + 3);
  if (v6)
  {
    v8 = *((_QWORD *)v7 + 4);
    if (*((_BYTE *)this + 48))
      v9 = *((_QWORD *)this + 5);
    else
      v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6) - *((_QWORD *)this + 4);
    if (v9 >= v8)
      v9 = v8;
    v11 = *((_QWORD *)this + 1);
    v10 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
    *(_QWORD *)&v64 = v11;
    *((_QWORD *)&v64 + 1) = v10;
    if (v10)
    {
      p_shared_owners = (unint64_t *)&v10->__shared_owners_;
      do
        v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
    }
    v14 = *((_OWORD *)v7 + 1);
    v65 = *(_OWORD *)v7;
    v66 = v14;
    if (v9)
    {
      *((_QWORD *)&v65 + 1) += v9;
      if (BYTE8(v66))
        *(_QWORD *)&v66 = v66 - v9;
    }
  }
  else
  {
    v10 = 0;
    v11 = 0;
    v66 = 0u;
    v64 = 0u;
    v65 = 0u;
  }
  v15 = v65;
  if (!(_QWORD)v65)
  {
    v18 = 0;
    v19 = 0;
    LOBYTE(v20) = 0;
    v21 = 0;
    v10 = 0;
    v11 = 0;
    memset(v63, 0, 7);
    v16 = BYTE8(v66);
LABEL_28:
    v56 = v18;
    if (v16)
    {
      v24 = v20;
      v20 = v66;
      goto LABEL_34;
    }
    if (!(_QWORD)v65)
    {
      v24 = v20;
      v20 = 0;
      goto LABEL_34;
    }
LABEL_33:
    v24 = v20;
    v20 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v65 + 40))(v65) - *((_QWORD *)&v65 + 1);
    goto LABEL_34;
  }
  v16 = BYTE8(v66);
  if (BYTE8(v66))
    v17 = v66;
  else
    v17 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v65 + 40))(v65) - *((_QWORD *)&v65 + 1);
  if (v17 >= a2)
    v17 = a2;
  if (v10)
  {
    v22 = (unint64_t *)&v10->__shared_owners_;
    do
      v23 = __ldxr(v22);
    while (__stxr(v23 + 1, v22));
  }
  v21 = *((_QWORD *)&v65 + 1);
  v20 = v66;
  v19 = (unint64_t)v66 >> 8;
  v63[0] = *(_DWORD *)((char *)&v66 + 9);
  *(_DWORD *)((char *)v63 + 3) = HIDWORD(v66);
  if (!v17)
  {
    v18 = BYTE8(v66);
    goto LABEL_28;
  }
  v21 = *((_QWORD *)&v65 + 1) + v17;
  if (!BYTE8(v66))
  {
    v56 = 0;
    goto LABEL_33;
  }
  v24 = v66 - v17;
  v19 = ((unint64_t)v66 - v17) >> 8;
  v56 = 1;
LABEL_34:
  sub_1C5DD362C((uint64_t)&v64, v20 - a2, (uint64_t)&v60);
  v25 = v60;
  v60 = 0uLL;
  v26 = (std::__shared_weak_count *)*((_QWORD *)&v64 + 1);
  v64 = v25;
  if (v26)
  {
    v27 = (unint64_t *)&v26->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
  v65 = v61;
  v66 = v62;
  v29 = (std::__shared_weak_count *)*((_QWORD *)&v60 + 1);
  if (*((_QWORD *)&v60 + 1))
  {
    v30 = (unint64_t *)(*((_QWORD *)&v60 + 1) + 8);
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  v32 = v64;
  if (*((_QWORD *)&v64 + 1))
  {
    v33 = (unint64_t *)(*((_QWORD *)&v64 + 1) + 8);
    do
      v34 = __ldxr(v33);
    while (__stxr(v34 + 1, v33));
    v58 = v65;
    v59 = v66;
    do
      v35 = __ldxr(v33);
    while (__stxr(v35 + 1, v33));
    v60 = v58;
    v61 = v59;
    do
      v36 = __ldaxr(v33);
    while (__stlxr(v36 - 1, v33));
    if (!v36)
    {
      (*(void (**)(_QWORD))(**((_QWORD **)&v32 + 1) + 16))(*((_QWORD *)&v32 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v32 + 1));
    }
  }
  else
  {
    v60 = v65;
    v61 = v66;
  }
  v37 = v24 | (v19 << 8);
  if (v10)
  {
    v38 = (unint64_t *)&v10->__shared_owners_;
    do
      v39 = __ldxr(v38);
    while (__stxr(v39 + 1, v38));
    do
      v40 = __ldxr(v38);
    while (__stxr(v40 + 1, v38));
    *(_DWORD *)v57 = v63[0];
    *(_DWORD *)&v57[3] = *(_DWORD *)((char *)v63 + 3);
    do
      v41 = __ldaxr(v38);
    while (__stlxr(v41 - 1, v38));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  else
  {
    *(_DWORD *)v57 = v63[0];
    *(_DWORD *)&v57[3] = *(_DWORD *)((char *)v63 + 3);
  }
  *(_QWORD *)a3 = &unk_1E819DDC8;
  *(_OWORD *)(a3 + 8) = v32;
  if (*((_QWORD *)&v32 + 1))
  {
    v42 = (unint64_t *)(*((_QWORD *)&v32 + 1) + 8);
    do
      v43 = __ldxr(v42);
    while (__stxr(v43 + 1, v42));
  }
  v44 = v61;
  *(_OWORD *)(a3 + 24) = v60;
  *(_OWORD *)(a3 + 40) = v44;
  *(_QWORD *)(a3 + 56) = 0;
  *(_QWORD *)(a3 + 64) = &unk_1E819DDC8;
  *(_QWORD *)(a3 + 72) = v11;
  *(_QWORD *)(a3 + 80) = v10;
  if (v10)
  {
    v45 = (unint64_t *)&v10->__shared_owners_;
    do
      v46 = __ldxr(v45);
    while (__stxr(v46 + 1, v45));
  }
  *(_QWORD *)(a3 + 88) = v15;
  *(_QWORD *)(a3 + 96) = v21;
  *(_QWORD *)(a3 + 104) = v37;
  *(_BYTE *)(a3 + 112) = v56;
  *(_DWORD *)(a3 + 113) = *(_DWORD *)v57;
  *(_DWORD *)(a3 + 116) = *(_DWORD *)&v57[3];
  *(_QWORD *)(a3 + 120) = 0;
  if (v10)
  {
    v47 = (unint64_t *)&v10->__shared_owners_;
    do
      v48 = __ldaxr(v47);
    while (__stlxr(v48 - 1, v47));
    if (!v48)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  if (*((_QWORD *)&v32 + 1))
  {
    v49 = (unint64_t *)(*((_QWORD *)&v32 + 1) + 8);
    do
      v50 = __ldaxr(v49);
    while (__stlxr(v50 - 1, v49));
    if (!v50)
    {
      (*(void (**)(_QWORD))(**((_QWORD **)&v32 + 1) + 16))(*((_QWORD *)&v32 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v32 + 1));
    }
  }
  if (v10)
  {
    v51 = (unint64_t *)&v10->__shared_owners_;
    do
      v52 = __ldaxr(v51);
    while (__stlxr(v52 - 1, v51));
    if (!v52)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  v53 = (std::__shared_weak_count *)*((_QWORD *)&v64 + 1);
  if (*((_QWORD *)&v64 + 1))
  {
    v54 = (unint64_t *)(*((_QWORD *)&v64 + 1) + 8);
    do
      v55 = __ldaxr(v54);
    while (__stlxr(v55 - 1, v54));
    if (!v55)
    {
      ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
      std::__shared_weak_count::__release_weak(v53);
    }
  }
}

uint64_t llvm::BinaryStreamWriter::padToAlignment@<X0>(llvm::BinaryStreamWriter *this@<X0>, unsigned int a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;

  v5 = (*((_QWORD *)this + 7) + (unint64_t)a2 - 1) / a2 * a2;
  if (*((_BYTE *)this + 48))
  {
    v6 = *((_QWORD *)this + 5);
  }
  else
  {
    v7 = *((_QWORD *)this + 3);
    if (v7)
      v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 40))(v7) - *((_QWORD *)this + 4);
    else
      v6 = 0;
  }
  if (v5 <= v6)
  {
    while (*((_QWORD *)this + 7) < v5)
    {
      result = sub_1C5DD4680((uint64_t)this, 0, a3);
      if (*a3)
        return result;
    }
    result = 0;
  }
  else
  {
    v8 = operator new();
    result = llvm::BinaryStreamError::BinaryStreamError(v8, 1u, "", 0);
  }
  *a3 = result;
  return result;
}

uint64_t sub_1C5DD4680@<X0>(uint64_t a1@<X0>, char a2@<W1>, uint64_t *a3@<X8>)
{
  uint64_t v6;
  uint64_t result;
  char v8;

  v6 = a1 + 8;
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 16))(*(_QWORD *)(a1 + 24));
  v8 = a2;
  result = llvm::WritableBinaryStreamRef::writeBytes(v6, *(_QWORD *)(a1 + 56), (uint64_t)&v8, 1, a3);
  if (!*a3)
  {
    ++*(_QWORD *)(a1 + 56);
    *a3 = 0;
  }
  return result;
}

void llvm::Bisector<std::string>::resetAndStartLearning(uint64_t a1)
{
  sub_1C5DD4728(a1);
  *(_DWORD *)(a1 + 56) = 0;
  *(_BYTE *)(a1 + 120) = 1;
}

void sub_1C5DD4728(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t i;

  v2 = (_QWORD *)(a1 + 8);
  sub_1C47653C0(a1, *(char **)(a1 + 8));
  *(_QWORD *)a1 = v2;
  *(_QWORD *)(a1 + 16) = 0;
  *v2 = 0;
  v3 = *(_QWORD *)(a1 + 24);
  for (i = *(_QWORD *)(a1 + 32); i != v3; i -= 32)
  {
    if (*(char *)(i - 9) < 0)
      operator delete(*(void **)(i - 32));
  }
  *(_QWORD *)(a1 + 32) = v3;
}

_BYTE *llvm::Bisector<std::string>::startBisect(_BYTE *result)
{
  _BYTE *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64x2_t v9;
  int64x2_t v10;
  BOOL *v11;
  int64x2_t v12;
  int32x2_t v13;

  v1 = result;
  result[120] = 0;
  v2 = (*((_QWORD *)result + 4) - *((_QWORD *)result + 3)) >> 6;
  v3 = *((unsigned int *)result + 14);
  if (v3 >= *((_DWORD *)result + 15))
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(result + 48), (uint64_t)(result + 64), v3 + 1, 4);
    LODWORD(v3) = *((_DWORD *)v1 + 14);
  }
  *(_DWORD *)(*((_QWORD *)v1 + 6) + 4 * v3) = v2;
  ++*((_DWORD *)v1 + 14);
  v4 = *((_QWORD *)v1 + 3);
  v5 = *((_QWORD *)v1 + 4) - v4;
  v6 = (unint64_t)v5 >> 5;
  if (v5 >= 1)
  {
    v7 = 0;
    if (v6 <= 1)
      v8 = 1;
    else
      v8 = v6;
    v9 = (uint64x2_t)vdupq_n_s64(v8 - 1);
    v10 = (int64x2_t)xmmword_1C64632D0;
    v11 = (BOOL *)(v4 + 56);
    v12 = vdupq_n_s64(2uLL);
    do
    {
      v13 = vmovn_s64((int64x2_t)vcgeq_u64(v9, (uint64x2_t)v10));
      if ((v13.i8[0] & 1) != 0)
        *(v11 - 32) = v7 < (int)v2;
      if ((v13.i8[4] & 1) != 0)
        *v11 = v7 + 1 < (int)v2;
      v7 += 2;
      v10 = vaddq_s64(v10, v12);
      v11 += 64;
    }
    while (((v8 + 1) & 0xFFFFFFFFFFFFFFELL) != v7);
  }
  *((_DWORD *)v1 + 28) = v6;
  *((_DWORD *)v1 + 29) = 0;
  return result;
}

uint64_t llvm::Bisector<std::string>::updateMapForNewCounter(uint64_t result, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64x2_t v7;
  int64x2_t v8;
  BOOL *v9;
  int64x2_t v10;
  int32x2_t v11;

  v2 = *(_QWORD *)(result + 24);
  v3 = *(_QWORD *)(result + 32) - v2;
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = (unint64_t)v3 >> 5;
    if (v5 <= 1)
      v6 = 1;
    else
      v6 = v5;
    v7 = (uint64x2_t)vdupq_n_s64(v6 - 1);
    v8 = (int64x2_t)xmmword_1C64632D0;
    v9 = (BOOL *)(v2 + 56);
    v10 = vdupq_n_s64(2uLL);
    do
    {
      v11 = vmovn_s64((int64x2_t)vcgeq_u64(v7, (uint64x2_t)v8));
      if ((v11.i8[0] & 1) != 0)
        *(v9 - 32) = v4 < a2;
      if ((v11.i8[4] & 1) != 0)
        *v9 = v4 + 1 < a2;
      v4 += 2;
      v8 = vaddq_s64(v8, v10);
      v9 += 64;
    }
    while (((v6 + 1) & 0xFFFFFFFFFFFFFFELL) != v4);
  }
  return result;
}

void llvm::Bisector<std::string>::learnKey(uint64_t a1, uint64_t a2)
{
  void *__p[2];
  uint64_t v4;
  char v5;

  if (*(char *)(a2 + 23) < 0)
  {
    sub_1C47EBC30(__p, *(void **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)__p = *(_OWORD *)a2;
    v4 = *(_QWORD *)(a2 + 16);
  }
  v5 = 1;
  sub_1C5DD4990(a1, (__int128 *)__p);
  if (SHIBYTE(v4) < 0)
    operator delete(__p[0]);
}

void sub_1C5DD4990(uint64_t a1, __int128 *a2)
{
  uint64_t **v4;
  uint64_t **v5;
  char *v6;
  _BYTE *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  __int128 v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  char *v21;
  void **v22;
  void **v23;
  char *v24;
  __int128 v25;
  void **v26;
  __int128 v27;
  uint64_t v28;
  void *__p[2];
  uint64_t v30;
  int v31;

  if (*((char *)a2 + 23) < 0)
  {
    sub_1C47EBC30(&v27, *(void **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v27 = *a2;
    v28 = *((_QWORD *)a2 + 2);
  }
  *(_OWORD *)__p = v27;
  v30 = v28;
  v31 = 0;
  v4 = (uint64_t **)sub_1C4768D58(a1, &v27, (const void **)__p);
  if (!*v4)
  {
    v5 = v4;
    v6 = (char *)operator new(0x40uLL);
    v7 = v6 + 32;
    if (SHIBYTE(v30) < 0)
    {
      sub_1C47EBC30(v7, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      *(_OWORD *)v7 = *(_OWORD *)__p;
      *((_QWORD *)v6 + 6) = v30;
    }
    *((_DWORD *)v6 + 14) = v31;
    v8 = v27;
    *(_QWORD *)v6 = 0;
    *((_QWORD *)v6 + 1) = 0;
    *((_QWORD *)v6 + 2) = v8;
    *v5 = (uint64_t *)v6;
    v9 = **(_QWORD **)a1;
    v10 = (uint64_t *)v6;
    if (v9)
    {
      *(_QWORD *)a1 = v9;
      v10 = *v5;
    }
    sub_1C4768E74(*(uint64_t **)(a1 + 8), v10);
    ++*(_QWORD *)(a1 + 16);
    v11 = *(_QWORD *)(a1 + 32);
    v12 = *(_QWORD *)(a1 + 40);
    if (v11 >= v12)
    {
      v15 = *(_QWORD *)(a1 + 24);
      v16 = (uint64_t)(v11 - v15) >> 5;
      v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 59)
        abort();
      v18 = v12 - v15;
      if (v18 >> 4 > v17)
        v17 = v18 >> 4;
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFE0)
        v19 = 0x7FFFFFFFFFFFFFFLL;
      else
        v19 = v17;
      if (v19 >> 59)
        sub_1C4764EE4();
      v20 = (char *)operator new(32 * v19);
      v21 = &v20[32 * v16];
      *(_OWORD *)v21 = *a2;
      *((_QWORD *)v21 + 2) = *((_QWORD *)a2 + 2);
      *(_QWORD *)a2 = 0;
      *((_QWORD *)a2 + 1) = 0;
      *((_QWORD *)a2 + 2) = 0;
      v21[24] = *((_BYTE *)a2 + 24);
      v22 = *(void ***)(a1 + 24);
      v23 = *(void ***)(a1 + 32);
      if (v23 == v22)
      {
        v14 = v21 + 32;
        *(_QWORD *)(a1 + 24) = v21;
        *(_QWORD *)(a1 + 32) = v21 + 32;
        *(_QWORD *)(a1 + 40) = &v20[32 * v19];
      }
      else
      {
        v24 = &v20[32 * v16];
        do
        {
          v25 = *((_OWORD *)v23 - 2);
          *((_QWORD *)v24 - 2) = *(v23 - 2);
          *((_OWORD *)v24 - 2) = v25;
          *(v23 - 3) = 0;
          *(v23 - 2) = 0;
          *(v23 - 4) = 0;
          *(v24 - 8) = *((_BYTE *)v23 - 8);
          v24 -= 32;
          v23 -= 4;
        }
        while (v23 != v22);
        v23 = *(void ***)(a1 + 24);
        v26 = *(void ***)(a1 + 32);
        v14 = v21 + 32;
        *(_QWORD *)(a1 + 24) = v24;
        *(_QWORD *)(a1 + 32) = v21 + 32;
        *(_QWORD *)(a1 + 40) = &v20[32 * v19];
        while (v26 != v23)
        {
          if (*((char *)v26 - 9) < 0)
            operator delete(*(v26 - 4));
          v26 -= 4;
        }
      }
      if (v23)
        operator delete(v23);
    }
    else
    {
      v13 = *a2;
      *(_QWORD *)(v11 + 16) = *((_QWORD *)a2 + 2);
      *(_OWORD *)v11 = v13;
      *((_QWORD *)a2 + 1) = 0;
      *((_QWORD *)a2 + 2) = 0;
      *(_QWORD *)a2 = 0;
      *(_BYTE *)(v11 + 24) = *((_BYTE *)a2 + 24);
      v14 = (char *)(v11 + 32);
    }
    *(_QWORD *)(a1 + 32) = v14;
    *((_DWORD *)v6 + 14) = ((unint64_t)&v14[-*(_QWORD *)(a1 + 24)] >> 5) - 1;
  }
  if (SHIBYTE(v30) < 0)
    operator delete(__p[0]);
}

BOOL llvm::Bisector<std::string>::shouldPerformActionOnKey(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;

  v3 = sub_1C61CE594(a1, a2);
  return a1 + 8 != v3 && *(_BYTE *)(*(_QWORD *)(a1 + 24) + 32 * *(unsigned int *)(v3 + 56) + 24) != 0;
}

void llvm::Bisector<std::string>::finishBisectionRound(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  __int128 v12;
  BOOL v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64x2_t v21;
  int64x2_t v22;
  BOOL *v23;
  int64x2_t v24;
  int32x2_t v25;
  char v26;
  _BYTE *v27;
  uint64_t v28;
  char v29;

  v7 = *(_QWORD *)(a1 + 48);
  v5 = a1 + 48;
  v6 = v7;
  v8 = *(unsigned int *)(v5 + 8);
  v9 = *(_DWORD *)(v7 + 4 * v8 - 4);
  if (a2)
  {
    *(_DWORD *)(a1 + 116) = v9;
    v10 = *(_DWORD *)(a1 + 112);
  }
  else
  {
    *(_DWORD *)(a1 + 112) = v9;
    v10 = v9;
    v9 = *(_DWORD *)(a1 + 116);
  }
  if (v9 + 1 != v10)
  {
    v13 = __OFADD__(v9, v10);
    v14 = v9 + v10;
    if (v14 < 0 != v13)
      ++v14;
    v15 = v14 >> 1;
    if (v8 >= *(_DWORD *)(a1 + 60))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v5, a1 + 64, v8 + 1, 4);
      v6 = *(_QWORD *)(a1 + 48);
      v8 = *(unsigned int *)(a1 + 56);
    }
    *(_DWORD *)(v6 + 4 * v8) = v15;
    ++*(_DWORD *)(a1 + 56);
    v16 = *(_QWORD *)(a1 + 24);
    v17 = *(_QWORD *)(a1 + 32) - v16;
    if (v17 >= 1)
    {
      v18 = 0;
      v19 = (unint64_t)v17 >> 5;
      if (v19 <= 1)
        v20 = 1;
      else
        v20 = v19;
      v21 = (uint64x2_t)vdupq_n_s64(v20 - 1);
      v22 = (int64x2_t)xmmword_1C64632D0;
      v23 = (BOOL *)(v16 + 56);
      v24 = vdupq_n_s64(2uLL);
      do
      {
        v25 = vmovn_s64((int64x2_t)vcgeq_u64(v21, (uint64x2_t)v22));
        if ((v25.i8[0] & 1) != 0)
          *(v23 - 32) = v18 < v15;
        if ((v25.i8[4] & 1) != 0)
          *v23 = v18 + 1 < v15;
        v18 += 2;
        v22 = vaddq_s64(v22, v24);
        v23 += 64;
      }
      while (((v20 + 1) & 0xFFFFFFFFFFFFFFELL) != v18);
    }
    v26 = *(_BYTE *)(a1 + 151);
    if (v26 < 0)
    {
      if (*(_QWORD *)(a1 + 136))
        goto LABEL_23;
    }
    else if (*(_BYTE *)(a1 + 151))
    {
LABEL_23:
      if (v26 >= 0)
        v27 = (_BYTE *)(a1 + 128);
      else
        v27 = *(_BYTE **)(a1 + 128);
      if (v26 >= 0)
        v28 = *(unsigned __int8 *)(a1 + 151);
      else
        v28 = *(_QWORD *)(a1 + 136);
      llvm::Bisector<std::string>::serializeToFile(a1, v27, v28);
    }
    v29 = 0;
    *(_BYTE *)a3 = 0;
    goto LABEL_33;
  }
  v11 = *(_QWORD *)(a1 + 24) + 32 * v9;
  if (*(char *)(v11 + 23) < 0)
  {
    sub_1C47EBC30((_BYTE *)a3, *(void **)v11, *(_QWORD *)(v11 + 8));
  }
  else
  {
    v12 = *(_OWORD *)v11;
    *(_QWORD *)(a3 + 16) = *(_QWORD *)(v11 + 16);
    *(_OWORD *)a3 = v12;
  }
  v29 = 1;
LABEL_33:
  *(_BYTE *)(a3 + 24) = v29;
}

void llvm::Bisector<std::string>::serializeToFile(uint64_t a1, _BYTE *a2, uint64_t a3)
{
  unsigned __int16 *v6;
  unsigned __int16 *v7;
  __int128 *v8;
  __int128 *v9;
  __int128 v10;
  char v11;
  char *v12;
  void **v13;
  void **v14;
  uint64_t v15;
  int *v16;
  int *v17;
  void *v18;
  void **v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char *v24;
  __n128 v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  void **v29;
  void *v30;
  char v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  void **v39;
  void **v40;
  char *v41;
  void *__p[2];
  uint64_t v43;
  unsigned __int16 *v44;
  unsigned __int16 *v45;
  unint64_t v46;
  unsigned __int16 *v47;
  unsigned __int16 *v48;
  unsigned __int16 *v49;
  void *v50;
  void *v51;
  int v52;
  _BYTE v53[96];
  int v54;
  const std::error_category *v55;
  void *v56[3];
  int v57;
  uint64_t v58[3];
  void *v59[4];
  uint64_t v60[3];
  void *v61[4];
  uint64_t v62[3];
  void *v63[4];
  uint64_t v64[3];
  void *v65[4];
  uint64_t v66[3];
  void *v67[4];
  uint64_t v68[3];
  void *v69[4];
  void *v70;
  char v71;
  void *v72[4];
  void *v73[4];
  void *v74[4];
  void *v75;
  unsigned __int16 *v76;
  unsigned __int16 *v77;
  unint64_t v78;
  void *v79[6];

  v79[4] = *(void **)MEMORY[0x1E0C80C00];
  v54 = 0;
  v55 = std::system_category();
  llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)v53, a2, a3, (uint64_t)&v54);
  if (v54)
    llvm::report_fatal_error((llvm *)"Could not open file for saving", (const char *)1);
  v6 = 0;
  v7 = 0;
  v50 = 0;
  v51 = 0;
  v52 = 0;
  v47 = 0;
  v48 = 0;
  v49 = 0;
  v44 = 0;
  v45 = 0;
  v46 = 0;
  v8 = *(__int128 **)(a1 + 24);
  v9 = *(__int128 **)(a1 + 32);
  if (v8 != v9)
  {
    v6 = 0;
    v7 = 0;
    do
    {
      if (*((char *)v8 + 23) < 0)
      {
        sub_1C47EBC30(__p, *(void **)v8, *((_QWORD *)v8 + 1));
      }
      else
      {
        v10 = *v8;
        v43 = *((_QWORD *)v8 + 2);
        *(_OWORD *)__p = v10;
      }
      sub_1C4D673F4((uint64_t)v79, (unint64_t)__p);
      if (SHIBYTE(v43) < 0)
        operator delete(__p[0]);
      if (v7 >= v49)
      {
        v7 = sub_1C5DD5AD4(&v47, (unsigned __int16 *)v79);
      }
      else
      {
        llvm::json::Value::copyFrom(v7, (unsigned __int16 *)v79);
        v7 += 16;
        v6 = v45;
      }
      v48 = v7;
      v11 = *((_BYTE *)v8 + 24);
      LOWORD(v75) = 1;
      LOBYTE(v76) = v11;
      if ((unint64_t)v6 >= v46)
      {
        v6 = sub_1C5DD5AD4(&v44, (unsigned __int16 *)&v75);
      }
      else
      {
        llvm::json::Value::copyFrom(v6, (unsigned __int16 *)&v75);
        v6 += 16;
      }
      v45 = v6;
      llvm::json::Value::destroy(&v75);
      llvm::json::Value::destroy(v79);
      v8 += 2;
    }
    while (v8 != v9);
  }
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v39 = 0;
  v40 = 0;
  v41 = 0;
  v15 = *(unsigned int *)(a1 + 56);
  if ((_DWORD)v15)
  {
    v13 = 0;
    v38 = a1;
    v16 = *(int **)(a1 + 48);
    v17 = &v16[v15];
    do
    {
      v18 = (void *)*v16;
      if (v13 >= (void **)v41)
      {
        v19 = v39;
        v20 = ((char *)v13 - (char *)v39) >> 5;
        v21 = v20 + 1;
        if ((unint64_t)(v20 + 1) >> 59)
          abort();
        v22 = v41 - (char *)v39;
        if ((v41 - (char *)v39) >> 4 > v21)
          v21 = v22 >> 4;
        if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFE0)
          v23 = 0x7FFFFFFFFFFFFFFLL;
        else
          v23 = v21;
        if (v23 >> 59)
          sub_1C4764EE4();
        v24 = (char *)operator new(32 * v23);
        v26 = (uint64_t)&v24[32 * v20];
        v27 = &v24[32 * v23];
        *(_WORD *)v26 = 3;
        *(_QWORD *)(v26 + 8) = v18;
        v28 = v26 + 32;
        if (v13 == v19)
        {
          v39 = (void **)v26;
          v40 = (void **)(v26 + 32);
          v41 = &v24[32 * v23];
        }
        else
        {
          do
          {
            v26 -= 32;
            v13 -= 4;
            v25 = llvm::json::Value::moveFrom(v26, (unsigned __int16 *)v13, v25);
          }
          while (v13 != v19);
          v13 = v39;
          v29 = v40;
          v39 = (void **)v26;
          v40 = (void **)v28;
          v41 = v27;
          while (v29 != v13)
          {
            v29 -= 4;
            llvm::json::Value::destroy(v29);
          }
        }
        if (v13)
          operator delete(v13);
        v13 = (void **)v28;
      }
      else
      {
        *(_WORD *)v13 = 3;
        v13[1] = v18;
        v13 += 4;
      }
      v40 = v13;
      ++v16;
    }
    while (v16 != v17);
    v7 = v48;
    v6 = v45;
    a1 = v38;
    v14 = v39;
    v12 = v41;
  }
  LOWORD(v79[0]) = 8;
  v79[1] = v47;
  v79[2] = v7;
  v79[3] = v49;
  v48 = 0;
  v49 = 0;
  LOWORD(v75) = 8;
  v76 = v44;
  v77 = v6;
  v78 = v46;
  v46 = 0;
  v47 = 0;
  v44 = 0;
  v45 = 0;
  LOWORD(v74[0]) = 8;
  v74[1] = v14;
  v74[2] = v13;
  v74[3] = v12;
  v39 = 0;
  v40 = 0;
  v41 = 0;
  LOWORD(v73[0]) = 3;
  v30 = (void *)*(int *)(a1 + 116);
  v73[1] = (void *)*(int *)(a1 + 112);
  LOWORD(v72[0]) = 3;
  v72[1] = v30;
  v31 = *(_BYTE *)(a1 + 120);
  LOWORD(v70) = 1;
  v71 = v31;
  sub_1C4D655B0(v68, "key_state_strings", 0x11uLL);
  llvm::json::Value::copyFrom(v69, (unsigned __int16 *)v79);
  sub_1C63834CC((uint64_t)v56, (uint64_t)&v50, (uint64_t)v68, (unsigned __int16 *)v69);
  llvm::json::Value::destroy(v69);
  v32 = v68[0];
  v68[0] = 0;
  if (v32)
  {
    if (*(char *)(v32 + 23) < 0)
      operator delete(*(void **)v32);
    MEMORY[0x1CAA32FC0](v32, 0x1012C40EC159624);
  }
  sub_1C4D655B0(v66, "key_state_BOOLs", 0xFuLL);
  llvm::json::Value::copyFrom(v67, (unsigned __int16 *)&v75);
  sub_1C63834CC((uint64_t)v56, (uint64_t)&v50, (uint64_t)v66, (unsigned __int16 *)v67);
  llvm::json::Value::destroy(v67);
  v33 = v66[0];
  v66[0] = 0;
  if (v33)
  {
    if (*(char *)(v33 + 23) < 0)
      operator delete(*(void **)v33);
    MEMORY[0x1CAA32FC0](v33, 0x1012C40EC159624);
  }
  sub_1C4D655B0(v64, "bisect_history", 0xEuLL);
  llvm::json::Value::copyFrom(v65, (unsigned __int16 *)v74);
  sub_1C63834CC((uint64_t)v56, (uint64_t)&v50, (uint64_t)v64, (unsigned __int16 *)v65);
  llvm::json::Value::destroy(v65);
  v34 = v64[0];
  v64[0] = 0;
  if (v34)
  {
    if (*(char *)(v34 + 23) < 0)
      operator delete(*(void **)v34);
    MEMORY[0x1CAA32FC0](v34, 0x1012C40EC159624);
  }
  sub_1C4D655B0(v62, "last_fail_counter", 0x11uLL);
  llvm::json::Value::copyFrom(v63, (unsigned __int16 *)v73);
  sub_1C63834CC((uint64_t)v56, (uint64_t)&v50, (uint64_t)v62, (unsigned __int16 *)v63);
  llvm::json::Value::destroy(v63);
  v35 = v62[0];
  v62[0] = 0;
  if (v35)
  {
    if (*(char *)(v35 + 23) < 0)
      operator delete(*(void **)v35);
    MEMORY[0x1CAA32FC0](v35, 0x1012C40EC159624);
  }
  sub_1C4D655B0(v60, "last_pass_counter", 0x11uLL);
  llvm::json::Value::copyFrom(v61, (unsigned __int16 *)v72);
  sub_1C63834CC((uint64_t)v56, (uint64_t)&v50, (uint64_t)v60, (unsigned __int16 *)v61);
  llvm::json::Value::destroy(v61);
  v36 = v60[0];
  v60[0] = 0;
  if (v36)
  {
    if (*(char *)(v36 + 23) < 0)
      operator delete(*(void **)v36);
    MEMORY[0x1CAA32FC0](v36, 0x1012C40EC159624);
  }
  sub_1C4D655B0(v58, "learning_mode", 0xDuLL);
  llvm::json::Value::copyFrom(v59, (unsigned __int16 *)&v70);
  sub_1C63834CC((uint64_t)v56, (uint64_t)&v50, (uint64_t)v58, (unsigned __int16 *)v59);
  llvm::json::Value::destroy(v59);
  v37 = v58[0];
  v58[0] = 0;
  if (v37)
  {
    if (*(char *)(v37 + 23) < 0)
      operator delete(*(void **)v37);
    MEMORY[0x1CAA32FC0](v37, 0x1012C40EC159624);
  }
  LOWORD(v56[0]) = 7;
  v56[1] = v50;
  v56[2] = v51;
  v50 = 0;
  v51 = 0;
  v57 = v52;
  v52 = 0;
  sub_1C6383434((uint64_t)v53, (uint64_t)v56);
  llvm::json::Value::destroy(v56);
  llvm::raw_fd_ostream::close((llvm::raw_fd_ostream *)v53);
  llvm::json::Value::destroy(&v70);
  llvm::json::Value::destroy(v72);
  llvm::json::Value::destroy(v73);
  llvm::json::Value::destroy(v74);
  llvm::json::Value::destroy(&v75);
  llvm::json::Value::destroy(v79);
  v79[0] = &v39;
  sub_1C4D66218((void ***)v79);
  v79[0] = &v44;
  sub_1C4D66218((void ***)v79);
  v79[0] = &v47;
  sub_1C4D66218((void ***)v79);
  sub_1C4D65F7C((uint64_t *)&v50);
  MEMORY[0x1CAA32FB4](v50, 8);
  llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)v53);
}

{
  __ZN4llvm8BisectorINSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEE15serializeToFileENS_9StringRefE(a1, a2, a3);
}

uint64_t llvm::Bisector<std::string>::getNumKeys(uint64_t a1)
{
  return (*(_QWORD *)(a1 + 32) - *(_QWORD *)(a1 + 24)) >> 5;
}

uint64_t llvm::Bisector<std::string>::getCurrentCounterKey(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24) + 32 * *(int *)(*(_QWORD *)(a1 + 48) + 4 * *(unsigned int *)(a1 + 56) - 4) - 32;
}

uint64_t llvm::Bisector<std::string>::getLastFailCounter(uint64_t a1)
{
  return *(unsigned int *)(a1 + 112);
}

uint64_t llvm::Bisector<std::string>::getLastPassCounter(uint64_t a1)
{
  return *(unsigned int *)(a1 + 116);
}

BOOL llvm::Bisector<std::string>::isBisecting(uint64_t a1)
{
  return *(_BYTE *)(a1 + 120) == 0;
}

void llvm::Bisector<std::string>::loadFromFile(uint64_t a1, void *a2, uint64_t a3)
{
  unint64_t v3;
  size_t v4;
  const unsigned __int8 *v6;
  uint64_t Array;
  uint64_t *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t *v12;
  int Integer;
  char v14;
  int v15;
  int v16;
  char v17;
  int v18;
  unsigned __int16 Boolean;
  __n128 v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unsigned int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  unsigned __int8 *v28;
  unsigned __int8 *v29;
  char v30;
  unsigned __int8 *v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  __n128 v35;
  __int16 v36;
  __int128 *p_dst;
  uint64_t v38;
  uint64_t v39;
  char v40;
  uint64_t v41;
  unint64_t v42;
  unsigned int v43;
  int v44;
  int v45;
  uint64_t v46;
  void *v47;
  char *v48;
  char v49;
  int v50;
  __int128 __dst;
  unint64_t v52;
  void *v53;
  char v54;
  void *v55;
  _QWORD v56[2];
  unsigned __int8 v57;
  void *v58;
  _QWORD v59[3];
  __int16 v60;
  uint64_t v61;
  char v62;
  __int128 v63;
  unint64_t v64;
  char v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  v60 = 261;
  v58 = a2;
  v59[0] = a3;
  sub_1C5E1F6CC((unsigned __int8 *)&v58, 0xFFFFFFFFFFFFFFFFLL, 0, 1, 1, 0, (uint64_t)&v61);
  if ((v62 & 1) != 0)
  {
    v48 = "Cannot open json file";
    goto LABEL_75;
  }
  sub_1C5DD4728(a1);
  *(_DWORD *)(a1 + 56) = 0;
  *(_BYTE *)(a1 + 120) = 1;
  llvm::json::parse(*(unsigned __int8 **)(v61 + 8), *(_QWORD *)(v61 + 16) - *(_QWORD *)(v61 + 8), v6, (uint64_t)&v58);
  if ((v60 & 1) != 0)
  {
    v48 = "Could not parse json";
    goto LABEL_75;
  }
  if ((unsigned __int16)v58 != 7)
  {
    v48 = "JSON: Top level object should be an object/dict";
    goto LABEL_75;
  }
  Array = llvm::json::Object::getArray((uint64_t)v59, (uint64_t)"key_state_strings", 17);
  if (!Array)
  {
    v48 = "JSON: key_state_strings key not found";
    goto LABEL_75;
  }
  v8 = (uint64_t *)Array;
  v9 = llvm::json::Object::getArray((uint64_t)v59, (uint64_t)"key_state_BOOLs", 15);
  if (!v9)
  {
    v48 = "JSON: key_state_BOOLs key not found";
    goto LABEL_75;
  }
  v10 = (_QWORD *)v9;
  v11 = llvm::json::Object::getArray((uint64_t)v59, (uint64_t)"bisect_history", 14);
  if (!v11)
  {
    v48 = "JSON: bisect_history key not found";
    goto LABEL_75;
  }
  v12 = (uint64_t *)v11;
  Integer = llvm::json::Object::getInteger((uint64_t)v59, (uint64_t)"last_fail_counter", 17);
  if (!v14)
  {
    v48 = "JSON: last_fail_counter key not found";
    goto LABEL_75;
  }
  v15 = Integer;
  v16 = llvm::json::Object::getInteger((uint64_t)v59, (uint64_t)"last_pass_counter", 17);
  if (!v17)
  {
    v48 = "JSON: last_pass_counter key not found";
    goto LABEL_75;
  }
  v18 = v16;
  Boolean = llvm::json::Object::getBoolean((uint64_t)v59, (uint64_t)"learning_mode", 13);
  if (Boolean <= 0xFFu)
  {
    v48 = "JSON: learning_mode key not found";
    goto LABEL_75;
  }
  v50 = v15;
  v21 = *v8;
  v22 = v8[1];
  if (v22 - *v8 != v10[1] - *v10)
  {
    v48 = "key_state_strings and key_state_BOOLs have different sizes";
LABEL_75:
    llvm::report_fatal_error((llvm *)v48, (const char *)1);
  }
  v49 = Boolean;
  if (v22 != v21)
  {
    v23 = 0;
    v24 = 1;
    while (1)
    {
      v25 = *(unsigned __int16 *)(v21 + 32 * v23);
      if (v25 == 6)
        break;
      if (v25 == 5)
      {
        v34 = v21 + 32 * v23;
        v31 = *(unsigned __int8 **)(v34 + 8);
        v33 = *(_QWORD *)(v34 + 16);
LABEL_22:
        sub_1C4D67324((uint64_t)&v63, v31, v33);
        goto LABEL_23;
      }
      LOWORD(v63) = 0;
LABEL_23:
      llvm::json::Value::moveFrom((uint64_t)&v55, (unsigned __int16 *)&v63, v20);
      llvm::json::Value::destroy((void **)&v63);
      if (*(_WORD *)(*v10 + 32 * v23) == 1)
      {
        BYTE8(v63) = *(_BYTE *)(*v10 + 32 * v23 + 8);
        v36 = 1;
      }
      else
      {
        v36 = 0;
      }
      LOWORD(v63) = v36;
      llvm::json::Value::moveFrom((uint64_t)&v53, (unsigned __int16 *)&v63, v35);
      llvm::json::Value::destroy((void **)&v63);
      if ((unsigned __int16)v55 == 6)
      {
        if (((char)v57 & 0x80000000) == 0)
        {
          v4 = v57;
          v3 = (unint64_t)v56;
          goto LABEL_31;
        }
      }
      else if ((unsigned __int16)v55 != 5)
      {
        v3 &= 0xFFFFFFFFFFFFFF00;
        if (!v3)
        {
LABEL_42:
          __dst = 0uLL;
          v52 = 0;
          goto LABEL_43;
        }
        goto LABEL_30;
      }
      v3 = v56[0];
      v4 = v56[1];
      if (!v56[0])
        goto LABEL_42;
LABEL_30:
      if (v4 >= 0x7FFFFFFFFFFFFFF8)
        abort();
LABEL_31:
      if (v4 >= 0x17)
      {
        v38 = (v4 & 0x7FFFFFFFFFFFFFF8) + 8;
        if ((v4 | 7) != 0x17)
          v38 = v4 | 7;
        v39 = v38 + 1;
        p_dst = (__int128 *)operator new(v38 + 1);
        *((_QWORD *)&__dst + 1) = v4;
        v52 = v39 | 0x8000000000000000;
        *(_QWORD *)&__dst = p_dst;
      }
      else
      {
        HIBYTE(v52) = v4;
        p_dst = &__dst;
        if (!v4)
          goto LABEL_38;
      }
      memmove(p_dst, (const void *)v3, v4);
LABEL_38:
      *((_BYTE *)p_dst + v4) = 0;
LABEL_43:
      if ((unsigned __int16)v53 == 1)
        v40 = v54;
      else
        v40 = 0;
      v63 = __dst;
      v64 = v52;
      v65 = v40;
      sub_1C5DD4990(a1, &v63);
      if (SHIBYTE(v64) < 0)
        operator delete((void *)v63);
      llvm::json::Value::destroy(&v53);
      llvm::json::Value::destroy(&v55);
      v23 = v24;
      v21 = *v8;
      ++v24;
      if (v23 >= (v8[1] - *v8) >> 5)
        goto LABEL_49;
    }
    v26 = v21 + 32 * v23;
    v29 = *(unsigned __int8 **)(v26 + 8);
    v27 = v26 + 8;
    v28 = v29;
    v30 = *(_BYTE *)(v27 + 23);
    if (v30 >= 0)
      v31 = (unsigned __int8 *)v27;
    else
      v31 = v28;
    v32 = *(_QWORD *)(v27 + 8);
    if (v30 >= 0)
      v33 = v30 & 0x7F;
    else
      v33 = v32;
    goto LABEL_22;
  }
LABEL_49:
  v41 = *v12;
  if (v12[1] != *v12)
  {
    v42 = 0;
    v43 = 1;
    do
    {
      v44 = sub_1C5DD5A44((unsigned __int16 *)(v41 + 32 * v42));
      v45 = v44;
      v46 = *(unsigned int *)(a1 + 56);
      if (v46 >= *(_DWORD *)(a1 + 60))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 48, a1 + 64, v46 + 1, 4);
        *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * *(unsigned int *)(a1 + 56)) = v45;
      }
      else
      {
        *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * v46) = v44;
      }
      ++*(_DWORD *)(a1 + 56);
      v42 = v43;
      v41 = *v12;
      ++v43;
    }
    while (v42 < (v12[1] - *v12) >> 5);
  }
  *(_DWORD *)(a1 + 112) = v50;
  *(_DWORD *)(a1 + 116) = v18;
  *(_BYTE *)(a1 + 120) = v49;
  if ((v60 & 1) != 0)
  {
    v47 = v58;
    v58 = 0;
    if (v47)
      (*(void (**)(void *))(*(_QWORD *)v47 + 8))(v47);
  }
  else
  {
    llvm::json::Value::destroy(&v58);
  }
  if ((v62 & 1) == 0)
  {
    if (v61)
      (*(void (**)(uint64_t))(*(_QWORD *)v61 + 8))(v61);
  }
}

unint64_t sub_1C5DD5A44(unsigned __int16 *a1)
{
  int v1;
  uint64_t v2;
  unint64_t v3;
  BOOL v5;
  long double __y;

  v1 = *a1;
  if (v1 == 3)
  {
    v2 = *((_QWORD *)a1 + 1);
  }
  else
  {
    if (v1 != 2
      || (__y = *((double *)a1 + 1), modf(__y, &__y) != 0.0)
      || (__y >= -9.22337204e18 ? (v5 = __y > 9.22337204e18) : (v5 = 1), v5))
    {
      LOBYTE(v2) = 0;
      v3 = 0;
      return v3 | v2;
    }
    v2 = (uint64_t)__y;
  }
  v3 = v2 & 0xFFFFFFFFFFFFFF00;
  return v3 | v2;
}

unsigned __int16 *sub_1C5DD5AD4(unsigned __int16 **a1, unsigned __int16 *a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v6;
  unint64_t v7;
  char *v8;
  char *v9;
  unsigned __int16 *v10;
  __n128 v11;
  unsigned __int16 *v12;
  unsigned __int16 *v13;
  unsigned __int16 *v14;
  void **v15;

  v2 = ((char *)a1[1] - (char *)*a1) >> 5;
  v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 59)
    abort();
  v6 = (char *)a1[2] - (char *)*a1;
  if (v6 >> 4 > v3)
    v3 = v6 >> 4;
  if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFE0)
    v7 = 0x7FFFFFFFFFFFFFFLL;
  else
    v7 = v3;
  if (v7)
  {
    if (v7 >> 59)
      sub_1C4764EE4();
    v8 = (char *)operator new(32 * v7);
  }
  else
  {
    v8 = 0;
  }
  v9 = &v8[32 * v2];
  v10 = (unsigned __int16 *)&v8[32 * v7];
  llvm::json::Value::copyFrom(v9, a2);
  v12 = (unsigned __int16 *)(v9 + 32);
  v14 = *a1;
  v13 = a1[1];
  if (v13 == *a1)
  {
    *a1 = (unsigned __int16 *)v9;
    a1[1] = v12;
    a1[2] = v10;
  }
  else
  {
    do
    {
      v9 -= 32;
      v13 -= 16;
      v11 = llvm::json::Value::moveFrom((uint64_t)v9, v13, v11);
    }
    while (v13 != v14);
    v13 = *a1;
    v15 = (void **)a1[1];
    *a1 = (unsigned __int16 *)v9;
    a1[1] = v12;
    a1[2] = v10;
    while (v15 != (void **)v13)
    {
      v15 -= 4;
      llvm::json::Value::destroy(v15);
    }
  }
  if (v13)
    operator delete(v13);
  return v12;
}

unint64_t llvm::BlockFrequency::operator*(uint64_t *a1, int a2)
{
  uint64_t v2;
  int v4;

  v2 = *a1;
  v4 = a2;
  return llvm::BranchProbability::scale((llvm::BranchProbability *)&v4, v2);
}

uint64_t *llvm::BlockFrequency::operator+=(uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = a2 + *result;
  if (__CFADD__(a2, *result))
    v2 = -1;
  *result = v2;
  return result;
}

uint64_t llvm::BlockFrequency::operator+(_QWORD *a1, uint64_t a2)
{
  if (__CFADD__(a2, *a1))
    return -1;
  else
    return a2 + *a1;
}

_QWORD *llvm::BlockFrequency::operator>>=(_QWORD *result, char a2)
{
  *result = (*result >> a2) | (*result >> a2 == 0);
  return result;
}

_DWORD *llvm::BranchProbability::BranchProbability(_DWORD *this, unint64_t a2, unsigned int a3)
{
  if (a3 != 0x80000000)
    a2 = ((a3 >> 1) | ((unint64_t)a2 << 31)) / a3;
  *this = a2;
  return this;
}

{
  if (a3 != 0x80000000)
    a2 = ((a3 >> 1) | ((unint64_t)a2 << 31)) / a3;
  *this = a2;
  return this;
}

uint64_t llvm::BranchProbability::getBranchProbability(unint64_t this, unint64_t a2)
{
  unint64_t v2;
  uint64_t result;
  unint64_t v4;
  unint64_t v5;

  v2 = HIDWORD(a2);
  if (HIDWORD(a2))
  {
    LOBYTE(v2) = 0;
    v4 = a2;
    do
    {
      a2 = v4 >> 1;
      LOBYTE(v2) = v2 + 1;
      v5 = v4 >> 33;
      v4 >>= 1;
    }
    while (v5);
  }
  result = this >> v2;
  if (a2 != 0x80000000)
    return (((unint64_t)result << 31) | (a2 >> 1)) / a2;
  return result;
}

unint64_t llvm::BranchProbability::scale(llvm::BranchProbability *this, uint64_t a2)
{
  unsigned int v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;

  if (a2)
  {
    v2 = *(_DWORD *)this;
    if (*(_DWORD *)this != 0x80000000)
    {
      v3 = a2 * (unint64_t)v2;
      v4 = HIDWORD(v3) + HIDWORD(a2) * (unint64_t)v2;
      v5 = (((unint64_t)(v4 < HIDWORD(a2) * v2) << 32) + HIDWORD(a2) * (unint64_t)v2) & 0xFFFFFFFF00000000 | v4;
      if ((v5 & 0x8000000000000000) != 0)
        return -1;
      else
        return ((v3 & 0x80000000 | ((v4 & 0x7FFFFFFF) << 32)) >> 31) | ((unint64_t)(v5 >> 31) << 32);
    }
  }
  return a2;
}

unint64_t llvm::BranchProbability::scaleByInverse(llvm::BranchProbability *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v7;
  BOOL v8;
  unint64_t v9;

  if (!a2)
    return a2;
  v2 = *(unsigned int *)this;
  if ((_DWORD)v2 == 0x80000000)
    return a2;
  v3 = a2 >> 33;
  if (((a2 >> 1) & 0x80000000) > (a2 >> 1))
    LODWORD(v3) = v3 + 1;
  v4 = (a2 >> 1) | ((unint64_t)v3 << 32);
  v5 = v4 / v2;
  if ((v4 / v2) >> 32)
    return -1;
  v7 = ((a2 << 31) & 0x80000000 | ((unint64_t)(v4 % v2) << 32)) / v2;
  v8 = __CFADD__(v7, v5 << 32);
  v9 = v7 + (v5 << 32);
  if (v8)
    return -1;
  else
    return v9;
}

void llvm::parseCachePruningPolicy(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  const char *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  const char **v18;
  unint64_t v19;
  const char **v20;
  unint64_t v21;
  unsigned int v23;
  unint64_t v24;
  unint64_t v25;
  const char **v26;
  int v27;
  int v28;
  unsigned int v29;
  unsigned int v33;
  unint64_t v34;
  unint64_t v35;
  const char **v36;
  int v37;
  int v38;
  unsigned int v39;
  unint64_t v41;
  __darwin_ct_rune_t v42;
  uint64_t v43;
  unsigned int v44;
  unint64_t v45;
  unint64_t v46;
  const char **v47;
  int v48;
  int v49;
  unsigned int v50;
  unint64_t v51;
  const char *v52;
  unint64_t v54;
  uint64_t v55;
  const char **v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  const char *v60;
  void *v61;
  unint64_t v62;
  __int16 v63;
  const char *v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t v67;
  const char **v68;
  unint64_t v69;
  const char *v70;
  __int16 v71;
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  v64 = "";
  v65 = 0;
  v4 = 1000000;
  v66 = a1;
  v67 = a2;
  if (!a2)
  {
    LODWORD(v7) = 75;
    v59 = 604800;
    v57 = 0;
    v58 = 1200;
LABEL_119:
    *(_BYTE *)(a3 + 48) &= ~1u;
    *(_QWORD *)a3 = v58;
    *(_BYTE *)(a3 + 8) = 1;
    *(_QWORD *)(a3 + 16) = v59;
    *(_DWORD *)(a3 + 24) = v7;
    *(_QWORD *)(a3 + 32) = v57;
    *(_QWORD *)(a3 + 40) = v4;
    return;
  }
  v5 = a2;
  v6 = a1;
  LODWORD(v7) = 75;
  v57 = 0;
  v58 = 1200;
  v59 = 604800;
  while (2)
  {
    LOBYTE(v68) = 58;
    v8 = llvm::StringRef::find(&v66, (char *)&v68, 1uLL, 0);
    if (v5 >= v8)
      v9 = v8;
    else
      v9 = v5;
    if (v5 >= v8 + 1)
      v10 = v8 + 1;
    else
      v10 = v5;
    v11 = v6 + v10;
    v12 = v5 - v10;
    v13 = (const char *)v6;
    if (v8 == -1)
      v14 = v5;
    else
      v14 = v9;
    if (v8 == -1)
      v6 = 0;
    else
      v6 = v11;
    v64 = v13;
    v65 = v14;
    if (v8 == -1)
      v5 = 0;
    else
      v5 = v12;
    v66 = v6;
    v67 = v5;
    LOBYTE(v68) = 61;
    v15 = llvm::StringRef::find((uint64_t *)&v64, (char *)&v68, 1uLL, 0);
    if (v14 >= v15)
      v16 = v15;
    else
      v16 = v14;
    if (v14 >= v15 + 1)
      v17 = v15 + 1;
    else
      v17 = v14;
    v18 = (const char **)&v13[v17];
    v19 = v14 - v17;
    if (v15 == -1)
    {
      v16 = v14;
      v20 = 0;
    }
    else
    {
      v20 = v18;
    }
    if (v15 == -1)
      v21 = 0;
    else
      v21 = v19;
    switch(v16)
    {
      case 0xAuLL:
        if (*(_QWORD *)v13 != 0x69735F6568636163 || *((_WORD *)v13 + 4) != 25978)
          goto LABEL_121;
        if (*((_BYTE *)v20 + v21 - 1) != 37)
        {
          v63 = 1283;
          v60 = "'";
          v61 = v20;
          v62 = v21;
          v52 = "' must be a percentage";
          goto LABEL_122;
        }
        if (v21 >= v21 - 1)
          --v21;
        v68 = v20;
        v69 = v21;
        v23 = sub_1C5E3D4C0((uint64_t)&v68);
        v24 = v69;
        if (!v69)
          goto LABEL_120;
        v25 = 0;
        v26 = v68;
        do
        {
          v27 = *(unsigned __int8 *)v26;
          if ((v27 - 48) >= 0xA)
          {
            if ((v27 - 97) >= 0x1A)
            {
              if ((v27 - 65) > 0x19)
                goto LABEL_120;
              v28 = -55;
            }
            else
            {
              v28 = -87;
            }
          }
          else
          {
            v28 = -48;
          }
          v29 = v28 + v27;
          if (v29 >= v23)
            goto LABEL_120;
          v7 = v25 * v23 + v29;
          if (v7 / v23 < v25)
            goto LABEL_120;
          v26 = (const char **)((char *)v26 + 1);
          v25 = v25 * v23 + v29;
          --v24;
        }
        while (v24);
        if (v7 <= 0x64)
          goto LABEL_89;
        v63 = 1283;
        v60 = "'";
        v61 = v20;
        v62 = v21;
        v52 = "' must be between 0 and 100";
        goto LABEL_122;
      case 0xBuLL:
        if (*(_QWORD *)v13 != 0x66615F656E757270 || *(_QWORD *)(v13 + 3) != 0x72657466615F656ELL)
          goto LABEL_121;
        sub_1C5DD6454((uint64_t)&v68, v20, v21);
        if ((v69 & 1) != 0)
          goto LABEL_125;
        v59 = (uint64_t)v68;
        if (!v5)
          goto LABEL_119;
        continue;
      case 0xEuLL:
        if (*(_QWORD *)v13 != 0x6E695F656E757270 || *(_QWORD *)(v13 + 6) != 0x6C61767265746E69)
          goto LABEL_121;
        sub_1C5DD6454((uint64_t)&v68, v20, v21);
        if ((v69 & 1) != 0)
        {
LABEL_125:
          v56 = v68;
          *(_BYTE *)(a3 + 48) |= 1u;
          *(_QWORD *)a3 = v56;
          return;
        }
        v58 = (uint64_t)v68;
        if (!v5)
          goto LABEL_119;
        continue;
      case 0x10uLL:
        if (*(_QWORD *)v13 == 0x69735F6568636163 && *((_QWORD *)v13 + 1) == 0x73657479625F657ALL)
        {
          v41 = v21 - 1;
          v42 = __tolower(*((char *)v20 + v21 - 1));
          switch(v42)
          {
            case 'g':
              if (v21 >= v41)
                --v21;
              v43 = 0x40000000;
              break;
            case 'm':
              if (v21 >= v41)
                --v21;
              v43 = 0x100000;
              break;
            case 'k':
              if (v21 >= v41)
                --v21;
              v43 = 1024;
              break;
            default:
              v43 = 1;
              break;
          }
          v68 = v20;
          v69 = v21;
          v44 = sub_1C5E3D4C0((uint64_t)&v68);
          v45 = v69;
          if (!v69)
          {
LABEL_120:
            v63 = 1283;
            v60 = "'";
            v61 = v20;
            v62 = v21;
            v52 = "' not an integer";
            goto LABEL_122;
          }
          v46 = 0;
          v47 = v68;
          do
          {
            v48 = *(unsigned __int8 *)v47;
            if ((v48 - 48) >= 0xA)
            {
              if ((v48 - 97) >= 0x1A)
              {
                if ((v48 - 65) > 0x19)
                  goto LABEL_120;
                v49 = -55;
              }
              else
              {
                v49 = -87;
              }
            }
            else
            {
              v49 = -48;
            }
            v50 = v49 + v48;
            if (v50 >= v44)
              goto LABEL_120;
            v51 = v46 * v44 + v50;
            if (v51 / v44 < v46)
              goto LABEL_120;
            v47 = (const char **)((char *)v47 + 1);
            v46 = v51;
            --v45;
          }
          while (v45);
          v57 = v51 * v43;
          if (!v5)
            goto LABEL_119;
          continue;
        }
        if (*(_QWORD *)v13 == 0x69735F6568636163 && *((_QWORD *)v13 + 1) == 0x73656C69665F657ALL)
        {
          v68 = v20;
          v69 = v21;
          v33 = sub_1C5E3D4C0((uint64_t)&v68);
          v34 = v69;
          if (!v69)
            goto LABEL_120;
          v35 = 0;
          v36 = v68;
          do
          {
            v37 = *(unsigned __int8 *)v36;
            if ((v37 - 48) >= 0xA)
            {
              if ((v37 - 97) >= 0x1A)
              {
                if ((v37 - 65) > 0x19)
                  goto LABEL_120;
                v38 = -55;
              }
              else
              {
                v38 = -87;
              }
            }
            else
            {
              v38 = -48;
            }
            v39 = v38 + v37;
            if (v39 >= v33)
              goto LABEL_120;
            v4 = v35 * v33 + v39;
            if (v4 / v33 < v35)
              goto LABEL_120;
            v36 = (const char **)((char *)v36 + 1);
            v35 = v35 * v33 + v39;
            --v34;
          }
          while (v34);
LABEL_89:
          if (!v5)
            goto LABEL_119;
          continue;
        }
LABEL_121:
        v63 = 1283;
        v60 = "Unknown key: '";
        v61 = (void *)v13;
        v62 = v16;
        v52 = "'";
LABEL_122:
        v68 = &v60;
        v70 = v52;
        v71 = 770;
        if (!atomic_load(qword_1ED836B58))
          llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED836B58, (void *(*)(void))sub_1C5DF15F0, (void (*)(void *))sub_1C5DF1624);
        v54 = qword_1ED836B58[0];
        v55 = operator new();
        *(_QWORD *)v55 = off_1E81A0C88;
        llvm::Twine::str((llvm::Twine *)&v68, (_QWORD *)(v55 + 8));
        *(_QWORD *)(v55 + 32) = 3;
        *(_QWORD *)(v55 + 40) = v54;
        *(_BYTE *)(v55 + 48) = 1;
        *(_BYTE *)(a3 + 48) |= 1u;
        *(_QWORD *)a3 = v55;
        return;
      default:
        goto LABEL_121;
    }
  }
}

void sub_1C5DD6454(uint64_t a1, const char **a2, unint64_t a3)
{
  unint64_t v6;
  unint64_t v7;
  unsigned int v8;
  unint64_t v9;
  unint64_t v10;
  const char **v11;
  int v12;
  int v13;
  unsigned int v14;
  unint64_t v15;
  int v16;
  unint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  const char *v22;
  const char *v24;
  const char **v25;
  unint64_t v26;
  __int16 v27;
  const char **v28;
  unint64_t v29;
  const char *v30;
  __int16 v31;

  if (!a3)
  {
    if (!atomic_load(qword_1ED836B58))
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED836B58, (void *(*)(void))sub_1C5DF15F0, (void (*)(void *))sub_1C5DF1624);
    v18 = qword_1ED836B58[0];
    v19 = (_QWORD *)operator new();
    v20 = v19;
    v28 = (const char **)"Duration must not be empty";
    v31 = 259;
    goto LABEL_32;
  }
  v6 = a3 - 1;
  if (a3 >= a3 - 1)
    v7 = a3 - 1;
  else
    v7 = a3;
  v28 = a2;
  v29 = v7;
  v8 = sub_1C5E3D4C0((uint64_t)&v28);
  v9 = v29;
  if (v29)
  {
    v10 = 0;
    v11 = v28;
    do
    {
      v12 = *(unsigned __int8 *)v11;
      if ((v12 - 48) >= 0xA)
      {
        if ((v12 - 97) >= 0x1A)
        {
          if ((v12 - 65) > 0x19)
            goto LABEL_28;
          v13 = -55;
        }
        else
        {
          v13 = -87;
        }
      }
      else
      {
        v13 = -48;
      }
      v14 = v13 + v12;
      if (v14 >= v8)
        goto LABEL_28;
      v15 = v10 * v8 + v14;
      if (v15 / v8 < v10)
        goto LABEL_28;
      v11 = (const char **)((char *)v11 + 1);
      v10 = v15;
      --v9;
    }
    while (v9);
    v16 = *((char *)a2 + v6);
    switch(v16)
    {
      case 'h':
        *(_BYTE *)(a1 + 8) &= ~1u;
        v21 = 3600 * v15;
        break;
      case 'm':
        *(_BYTE *)(a1 + 8) &= ~1u;
        v21 = 60 * v15;
        break;
      case 's':
        *(_BYTE *)(a1 + 8) &= ~1u;
        *(_QWORD *)a1 = v15;
        return;
      default:
        v27 = 1283;
        v24 = "'";
        v25 = a2;
        v26 = a3;
        v22 = "' must end with one of 's', 'm' or 'h'";
        goto LABEL_29;
    }
    *(_QWORD *)a1 = v21;
    return;
  }
LABEL_28:
  v27 = 1283;
  v24 = "'";
  v25 = a2;
  v26 = v7;
  v22 = "' not an integer";
LABEL_29:
  v28 = &v24;
  v30 = v22;
  v31 = 770;
  if (!atomic_load(qword_1ED836B58))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED836B58, (void *(*)(void))sub_1C5DF15F0, (void (*)(void *))sub_1C5DF1624);
  v18 = qword_1ED836B58[0];
  v19 = (_QWORD *)operator new();
  v20 = v19;
LABEL_32:
  *v19 = off_1E81A0C88;
  llvm::Twine::str((llvm::Twine *)&v28, v19 + 1);
  v20[4] = 3;
  v20[5] = v18;
  *((_BYTE *)v20 + 48) = 1;
  *(_BYTE *)(a1 + 8) |= 1u;
  *(_QWORD *)a1 = v20;
}

uint64_t llvm::pruneCache(char *a1, unint64_t a2, uint64_t a3)
{
  uint64_t v3;
  unsigned int v8;
  uint64_t v9;
  _BYTE *v10;
  std::chrono::system_clock::time_point v11;
  const char *v12;
  int v13;
  int v14;
  const std::error_category *v15;
  const std::error_category *v16;
  const std::error_category *v17;
  uint64_t v18;
  __darwin_ino64_t v19;
  const void *v20;
  __darwin_ino64_t st_ino;
  stat *v22;
  char st_gid_high;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  BOOL v27;
  stat *p_dst;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  DIR **v32;
  char v33;
  int v34;
  DIR *v35;
  DIR *v36;
  BOOL v37;
  uint64_t st_uid;
  std::chrono::system_clock::time_point v40;
  uint64_t v41;
  __int128 v42;
  uint64_t *v43;
  uint64_t **v44;
  uint64_t **v45;
  uint64_t *v46;
  uint64_t *v47;
  uint64_t *v48;
  _OWORD *v49;
  __int128 v50;
  uint64_t *v51;
  const std::error_category *v52;
  std::__shared_weak_count *v53;
  unint64_t *p_shared_owners;
  unint64_t v55;
  std::__shared_weak_count *v56;
  unint64_t *v57;
  unint64_t v58;
  uint64_t **v59;
  unint64_t v60;
  unint64_t v61;
  BOOL v62;
  uint64_t **v63;
  uint64_t *v64;
  uint64_t **v65;
  uint64_t v66;
  unsigned int v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  uint64_t *v73;
  uint64_t **v74;
  uint64_t **v75;
  __darwin_time_t tv_sec;
  uint64_t v77;
  std::__shared_weak_count *v78;
  char v79;
  DIR **v80;
  std::__shared_weak_count *v81;
  unint64_t v82;
  const std::error_category *v83;
  uint64_t **v84;
  uint64_t *v85;
  unint64_t v86;
  time_t __t[2];
  _BYTE v88[28];
  uint64_t v89;
  __int16 v90;
  uint64_t v91;
  char v92;
  __int128 *v93;
  uint64_t *v94;
  __int128 *v95;
  uint64_t *v96;
  char *v97;
  uint64_t *p_p;
  __int128 v99;
  __int128 __p;
  DIR *v101;
  _BYTE v102[24];
  _BYTE v103[128];
  stat __dst;
  char *v105;
  __int128 v106;
  uint64_t v107;
  __int16 v108;
  uint64_t v109;

  v109 = *MEMORY[0x1E0C80C00];
  if (!a2)
    return 0;
  v92 = 0;
  v108 = 261;
  v105 = a1;
  *(_QWORD *)&v106 = a2;
  v3 = 0;
  if (!llvm::sys::fs::is_directory((llvm::sys::fs *)&v105, (const llvm::Twine *)&v92, (BOOL *)a3) && v92)
  {
    v8 = *(_DWORD *)(a3 + 24);
    if (v8 >= 0x64)
      v8 = 100;
    *(_DWORD *)(a3 + 24) = v8;
    if (!*(_QWORD *)(a3 + 16) && !v8 && !*(_QWORD *)(a3 + 32) && !*(_QWORD *)(a3 + 40))
      return 0;
    *(_QWORD *)v102 = v103;
    *(_OWORD *)&v102[8] = xmmword_1C85F20B0;
    if (a2 >= 0x81)
    {
      llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)v102, v103, a2, 1);
      v10 = *(_BYTE **)v102;
      v9 = *(_QWORD *)&v102[8];
    }
    else
    {
      v9 = 0;
      v10 = v103;
    }
    memcpy(&v10[v9], a1, a2);
    *(_QWORD *)&v102[8] += a2;
    v105 = "llvmcache.timestamp";
    v108 = 259;
    LOWORD(__dst.st_atimespec.tv_sec) = 257;
    *(_WORD *)&v88[16] = 257;
    LOWORD(v101) = 257;
    llvm::sys::path::append(v102, 0, (_QWORD **)&v105, &__dst, (_QWORD **)__t, (void ***)&v99);
    *(_OWORD *)__t = 0u;
    memset(v88, 0, sizeof(v88));
    v89 = 0xFFFFLL;
    v90 = 0;
    v91 = 0;
    v11.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
    LOWORD(v101) = 261;
    v99 = *(_OWORD *)v102;
    v105 = (char *)&v107;
    v106 = xmmword_1C85F20B0;
    v12 = (const char *)llvm::Twine::toNullTerminatedStringRef((unsigned __int8 *)&v99, (uint64_t)&v105);
    v13 = stat(v12, &__dst);
    v14 = sub_1C5E7F828(v13, &__dst.st_dev, (uint64_t)__t);
    v16 = v15;
    if (v105 == (char *)&v107)
    {
      if (v14)
      {
LABEL_16:
        v17 = std::generic_category();
        v3 = 0;
        if (v14 == 2 && v17 == v16)
          goto LABEL_27;
        goto LABEL_25;
      }
    }
    else
    {
      free(v105);
      if (v14)
        goto LABEL_16;
    }
    if (*(_BYTE *)(a3 + 8))
    {
      if (!*(_QWORD *)a3
        || (v18 = *(unsigned int *)&v88[4],
            1000000000 * *(_QWORD *)a3 < 1000
                                         * (v11.__d_.__rep_ - std::chrono::system_clock::from_time_t(__t[1]).__d_.__rep_)
                                         - v18))
      {
LABEL_27:
        v20 = *(const void **)v102;
        v19 = *(_QWORD *)&v102[8];
        std::system_category();
        if (!v20)
        {
          st_ino = 0;
          v22 = 0;
          st_gid_high = 0;
          memset(&__dst, 0, 24);
LABEL_38:
          v27 = st_gid_high < 0;
          if (st_gid_high >= 0)
            p_dst = &__dst;
          else
            p_dst = v22;
          v29 = st_gid_high & 0x7F;
          if (v27)
            v30 = st_ino;
          else
            v30 = v29;
          llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)&v105, p_dst, v30, (uint64_t)&v99, 0);
          if (SHIBYTE(__dst.st_gid) < 0)
            operator delete(*(void **)&__dst.st_dev);
          llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)&v105);
          v85 = 0;
          v86 = 0;
          v84 = &v85;
          LODWORD(v82) = 0;
          v83 = std::system_category();
          v105 = (char *)&v107;
          LOWORD(__dst.st_atimespec.tv_sec) = 261;
          *(_QWORD *)&__dst.st_dev = a1;
          __dst.st_ino = a2;
          v106 = xmmword_1C85F20B0;
          llvm::Twine::toVector((uint64_t)&__dst, (uint64_t)&v105);
          llvm::sys::path::native(&v105, 0);
          LOWORD(__dst.st_atimespec.tv_sec) = 261;
          *(_QWORD *)&__dst.st_dev = v105;
          __dst.st_ino = v106;
          sub_1C61D4808((uint64_t)&v80, (const char **)&__dst, &v82, 1);
          v77 = 0;
          v78 = 0;
          v79 = 1;
          v31 = 0;
          if (!sub_1C5057AF4((uint64_t *)&v80, &v77) && !(_DWORD)v82)
          {
            v31 = 0;
            do
            {
              v32 = (DIR **)v80[1];
              v33 = *((_BYTE *)v80 + 31);
              v34 = v33;
              if (v33 >= 0)
                v32 = v80 + 1;
              v35 = v80[2];
              v36 = (DIR *)(v33 & 0x7F);
              if (v34 >= 0)
                v35 = v36;
              *(_QWORD *)&__dst.st_uid = 0;
              *(_QWORD *)&__dst.st_rdev = 0;
              *(_QWORD *)&__dst.st_dev = v32;
              __dst.st_ino = (__darwin_ino64_t)v35;
              __dst.st_atimespec.tv_sec = (__darwin_time_t)v35;
              LODWORD(__dst.st_atimespec.tv_nsec) = 0;
              llvm::sys::path::reverse_iterator::operator++((uint64_t)&__dst);
              if (*(_QWORD *)&__dst.st_rdev >= 0xAuLL)
              {
                v37 = **(_QWORD **)&__dst.st_uid == 0x686361636D766C6CLL
                   && *(_WORD *)(*(_QWORD *)&__dst.st_uid + 8) == 11621;
                if (v37)
                {
LABEL_65:
                  llvm::sys::fs::directory_entry::status((llvm::sys::fs::directory_entry *)(v80 + 1), (uint64_t)&__dst);
                  if ((__dst.st_mtimespec.tv_sec & 1) == 0)
                  {
                    st_uid = __dst.st_uid;
                    v40.__d_.__rep_ = std::chrono::system_clock::from_time_t(*(time_t *)&__dst.st_dev).__d_.__rep_;
                    v41 = *(_QWORD *)(a3 + 16);
                    if (v41 && 1000000000 * v41 < 1000 * v11.__d_.__rep_ - (st_uid + 1000 * v40.__d_.__rep_))
                    {
                      LOWORD(v101) = 260;
                      *(_QWORD *)&v99 = v80 + 1;
                      llvm::sys::fs::remove((llvm::sys::fs *)&v99, (const llvm::Twine *)1);
                    }
                    else
                    {
                      *(_QWORD *)&v99 = st_uid + 1000 * v40.__d_.__rep_;
                      *((_QWORD *)&v99 + 1) = __dst.st_atimespec.tv_sec;
                      tv_sec = __dst.st_atimespec.tv_sec;
                      if (*((char *)v80 + 31) < 0)
                      {
                        sub_1C47EBC30(&__p, v80[1], (unint64_t)v80[2]);
                      }
                      else
                      {
                        v42 = *(_OWORD *)(v80 + 1);
                        v101 = v80[3];
                        __p = v42;
                      }
                      v43 = v85;
                      v44 = &v85;
                      v45 = &v85;
                      if (!v85)
                        goto LABEL_81;
                      v45 = &v85;
                      while (1)
                      {
                        while (1)
                        {
                          v44 = (uint64_t **)v43;
                          v46 = v43 + 4;
                          v47 = v43 + 5;
                          v96 = (uint64_t *)&v99;
                          v97 = (char *)(v43 + 5);
                          p_p = (uint64_t *)&__p;
                          v48 = v43 + 6;
                          v93 = (__int128 *)(v43 + 4);
                          v94 = (uint64_t *)&v99 + 1;
                          v95 = (__int128 *)(v43 + 6);
                          if (!sub_1C5DD7048(&v96, (uint64_t **)&v93))
                            break;
                          v43 = *v44;
                          v45 = v44;
                          if (!*v44)
                            goto LABEL_81;
                        }
                        v96 = v46;
                        v97 = (char *)&v99 + 8;
                        p_p = v48;
                        v93 = &v99;
                        v94 = v47;
                        v95 = &__p;
                        if (!sub_1C5DD7048(&v96, (uint64_t **)&v93))
                          break;
                        v45 = v44 + 1;
                        v43 = v44[1];
                        if (!v43)
                          goto LABEL_81;
                      }
                      if (!*v45)
                      {
LABEL_81:
                        v49 = operator new(0x48uLL);
                        v50 = __p;
                        v49[2] = v99;
                        v49[3] = v50;
                        *((_QWORD *)v49 + 8) = v101;
                        __p = 0uLL;
                        v101 = 0;
                        *(_QWORD *)v49 = 0;
                        *((_QWORD *)v49 + 1) = 0;
                        *((_QWORD *)v49 + 2) = v44;
                        *v45 = (uint64_t *)v49;
                        if (*v84)
                        {
                          v84 = (uint64_t **)*v84;
                          v51 = *v45;
                        }
                        else
                        {
                          v51 = (uint64_t *)v49;
                        }
                        sub_1C4768E74(v85, v51);
                        ++v86;
                      }
                      if (SHIBYTE(v101) < 0)
                        operator delete((void *)__p);
                      v31 += tv_sec;
                    }
                  }
                  goto LABEL_88;
                }
              }
              else if (*(_QWORD *)&__dst.st_rdev < 5uLL)
              {
                goto LABEL_88;
              }
              if (**(_DWORD **)&__dst.st_uid == 1852401748 && *(_BYTE *)(*(_QWORD *)&__dst.st_uid + 4) == 45)
                goto LABEL_65;
LABEL_88:
              v82 = llvm::sys::fs::detail::directory_iterator_increment(v80);
              v83 = v52;
            }
            while (!sub_1C5057AF4((uint64_t *)&v80, &v77) && !(_DWORD)v82);
          }
          v53 = v78;
          if (v78)
          {
            p_shared_owners = (unint64_t *)&v78->__shared_owners_;
            do
              v55 = __ldaxr(p_shared_owners);
            while (__stlxr(v55 - 1, p_shared_owners));
            if (!v55)
            {
              ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
              std::__shared_weak_count::__release_weak(v53);
            }
          }
          v56 = v81;
          if (v81)
          {
            v57 = (unint64_t *)&v81->__shared_owners_;
            do
              v58 = __ldaxr(v57);
            while (__stlxr(v58 - 1, v57));
            if (!v58)
            {
              ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
              std::__shared_weak_count::__release_weak(v56);
            }
          }
          v59 = v84;
          v60 = v86;
          v61 = *(_QWORD *)(a3 + 40);
          if (v61)
            v62 = v86 > v61;
          else
            v62 = 0;
          if (v62)
          {
            do
            {
              LOWORD(__dst.st_atimespec.tv_sec) = 260;
              *(_QWORD *)&__dst.st_dev = v59 + 6;
              llvm::sys::fs::remove((llvm::sys::fs *)&__dst, (const llvm::Twine *)1);
              v64 = v59[1];
              v65 = v59;
              if (v64)
              {
                do
                {
                  v63 = (uint64_t **)v64;
                  v64 = (uint64_t *)*v64;
                }
                while (v64);
              }
              else
              {
                do
                {
                  v63 = (uint64_t **)v65[2];
                  v37 = *v63 == (uint64_t *)v65;
                  v65 = v63;
                }
                while (!v37);
              }
              v31 -= (unint64_t)v59[5];
              --v60;
              v59 = v63;
            }
            while (v60 > *(_QWORD *)(a3 + 40));
          }
          else
          {
            v63 = v84;
          }
          if (*(_DWORD *)(a3 + 24) || *(_QWORD *)(a3 + 32))
          {
            LOWORD(__dst.st_atimespec.tv_sec) = 261;
            *(_QWORD *)&__dst.st_dev = a1;
            __dst.st_ino = a2;
            llvm::sys::fs::disk_space((llvm::sys::fs *)&__dst, (uint64_t)&v99);
            if ((BYTE8(__p) & 1) != 0)
              llvm::report_fatal_error((llvm *)"Can't get available size", (const char *)1);
            v66 = *((_QWORD *)&v99 + 1);
            v67 = *(_DWORD *)(a3 + 24);
            if (!v67)
            {
              v67 = 100;
              *(_DWORD *)(a3 + 24) = 100;
            }
            v68 = v66 + v31;
            v69 = *(_QWORD *)(a3 + 32);
            if (!v69)
            {
              *(_QWORD *)(a3 + 32) = v68;
              v69 = v68;
            }
            v70 = v68 * v67;
            if (v69 >= v70 / 0x64)
              v71 = v70 / 0x64;
            else
              v71 = v69;
            if (v31 > v71 && v63 != &v85)
            {
              do
              {
                LOWORD(__dst.st_atimespec.tv_sec) = 260;
                *(_QWORD *)&__dst.st_dev = v63 + 6;
                llvm::sys::fs::remove((llvm::sys::fs *)&__dst, (const llvm::Twine *)1);
                v73 = v63[1];
                v74 = v63;
                if (v73)
                {
                  do
                  {
                    v75 = (uint64_t **)v73;
                    v73 = (uint64_t *)*v73;
                  }
                  while (v73);
                }
                else
                {
                  do
                  {
                    v75 = (uint64_t **)v74[2];
                    v37 = *v75 == (uint64_t *)v74;
                    v74 = v75;
                  }
                  while (!v37);
                }
                v31 -= (unint64_t)v63[5];
                if (v31 <= v71)
                  break;
                v63 = v75;
              }
              while (v75 != &v85);
            }
          }
          if (v105 != (char *)&v107)
            free(v105);
          sub_1C5DD7000((char *)v85);
          v3 = 1;
          goto LABEL_25;
        }
        if (v19 >= 0x7FFFFFFFFFFFFFF8)
          abort();
        if (v19 >= 0x17)
        {
          v25 = (v19 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v19 | 7) != 0x17)
            v25 = v19 | 7;
          v26 = v25 + 1;
          v24 = operator new(v25 + 1);
          __dst.st_ino = v19;
          *(_QWORD *)&__dst.st_uid = v26 | 0x8000000000000000;
          *(_QWORD *)&__dst.st_dev = v24;
        }
        else
        {
          HIBYTE(__dst.st_gid) = v19;
          v24 = &__dst;
          if (!v19)
            goto LABEL_37;
        }
        memmove(v24, v20, v19);
LABEL_37:
        *((_BYTE *)v24 + v19) = 0;
        st_gid_high = HIBYTE(__dst.st_gid);
        v22 = *(stat **)&__dst.st_dev;
        st_ino = __dst.st_ino;
        goto LABEL_38;
      }
    }
    v3 = 0;
LABEL_25:
    if (*(_BYTE **)v102 != v103)
      free(*(void **)v102);
  }
  return v3;
}

void sub_1C5DD7000(char *a1)
{
  if (a1)
  {
    sub_1C5DD7000(*(_QWORD *)a1);
    sub_1C5DD7000(*((_QWORD *)a1 + 1));
    if (a1[71] < 0)
      operator delete(*((void **)a1 + 6));
    operator delete(a1);
  }
}

BOOL sub_1C5DD7048(uint64_t **a1, uint64_t **a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v5;
  unint64_t v6;
  const void **v7;
  uint64_t *v8;
  char v9;
  size_t v10;
  const void **v11;
  int v12;
  size_t v13;
  size_t v14;
  uint64_t *v15;
  size_t v16;
  int v17;

  v2 = **a1;
  v3 = **a2;
  if (v2 < v3)
    return 1;
  if (v3 < v2)
    return 0;
  v5 = *a1[1];
  v6 = *a2[1];
  if (v5 < v6)
    return 1;
  if (v6 < v5)
    return 0;
  v7 = (const void **)a1[2];
  v8 = a2[2];
  v9 = *((_BYTE *)v8 + 23);
  if (*((char *)v7 + 23) < 0)
  {
    v11 = v7;
    v7 = (const void **)*v7;
    v10 = (size_t)v11[1];
  }
  else
  {
    v10 = *((unsigned __int8 *)v7 + 23);
  }
  v12 = v9;
  v13 = v9 & 0x7F;
  if (v12 >= 0)
    v14 = v13;
  else
    v14 = v8[1];
  if (v12 >= 0)
    v15 = a2[2];
  else
    v15 = (uint64_t *)*v8;
  if (v14 >= v10)
    v16 = v10;
  else
    v16 = v14;
  v17 = memcmp(v7, v15, v16);
  if (v17)
    return v17 < 0;
  else
    return v10 < v14;
}

void llvm::localCache(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X3>, uint64_t a5@<X8>)
{
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  __int128 v16;
  _BYTE v17[64];
  _QWORD v18[3];
  _QWORD *v19;
  void *v20;
  __int128 v21;
  _BYTE v22[64];
  void *v23;
  __int128 v24;
  _BYTE v25[64];
  void *v26;
  __int128 v27;
  _BYTE v28[64];
  void *v29;
  __int128 v30;
  _BYTE v31[25];
  void *v32;
  __int128 v33;
  _BYTE v34[64];
  void *v35;
  __int128 v36;
  _BYTE v37[64];
  _QWORD v38[3];
  _QWORD *v39;
  void *v40;
  __int128 v41;
  _BYTE v42[64];
  void *v43;
  __int128 v44;
  _QWORD v45[10];

  v45[8] = *MEMORY[0x1E0C80C00];
  v32 = v34;
  v33 = xmmword_1C64638C0;
  v29 = v31;
  v30 = xmmword_1C64638C0;
  v26 = v28;
  v27 = xmmword_1C64638C0;
  llvm::Twine::toVector(a1, (uint64_t)&v32);
  llvm::Twine::toVector(a2, (uint64_t)&v29);
  llvm::Twine::toVector(a3, (uint64_t)&v26);
  v15 = v17;
  v16 = xmmword_1C64638C0;
  if ((_QWORD)v27)
    sub_1C50502AC((uint64_t)&v15, (uint64_t)&v26);
  v9 = v18;
  v10 = (_QWORD *)a4[3];
  if (v10)
  {
    if (v10 == a4)
    {
      v19 = v18;
      (*(void (**)(_QWORD *, _QWORD *))(*a4 + 24))(a4, v18);
    }
    else
    {
      v19 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v10 + 16))(v10);
    }
  }
  else
  {
    v19 = 0;
  }
  v20 = v22;
  v21 = xmmword_1C64638C0;
  if ((_QWORD)v30)
    sub_1C50502AC((uint64_t)&v20, (uint64_t)&v29);
  v23 = v25;
  v24 = xmmword_1C64638C0;
  if ((_QWORD)v33)
    sub_1C50502AC((uint64_t)&v23, (uint64_t)&v32);
  *(_BYTE *)(a5 + 32) &= ~1u;
  v35 = v37;
  v36 = xmmword_1C64638C0;
  if ((_QWORD)v16)
    sub_1C4FE6ED8((uint64_t)&v35, (uint64_t)&v15);
  v11 = v38;
  if (v19)
  {
    if (v19 == v18)
    {
      v39 = v38;
      (*(void (**)(_QWORD *, _QWORD *))(v18[0] + 24))(v18, v38);
    }
    else
    {
      v39 = v19;
      v19 = 0;
    }
  }
  else
  {
    v39 = 0;
  }
  v40 = v42;
  v41 = xmmword_1C64638C0;
  if ((_QWORD)v21)
    sub_1C4FE6ED8((uint64_t)&v40, (uint64_t)&v20);
  v43 = v45;
  v44 = xmmword_1C64638C0;
  if ((_QWORD)v24)
    sub_1C4FE6ED8((uint64_t)&v43, (uint64_t)&v23);
  *(_QWORD *)(a5 + 24) = 0;
  v12 = (char *)operator new(0x130uLL);
  *(_QWORD *)v12 = &off_1E819DE08;
  *((_QWORD *)v12 + 1) = v12 + 32;
  *((_OWORD *)v12 + 1) = xmmword_1C64638C0;
  if ((_QWORD)v36)
    sub_1C4FE6ED8((uint64_t)(v12 + 8), (uint64_t)&v35);
  if (v39)
  {
    if (v39 == v38)
    {
      *((_QWORD *)v12 + 15) = v12 + 96;
      (*(void (**)(_QWORD *))(v38[0] + 24))(v38);
    }
    else
    {
      *((_QWORD *)v12 + 15) = v39;
      v39 = 0;
    }
  }
  else
  {
    *((_QWORD *)v12 + 15) = 0;
  }
  *((_QWORD *)v12 + 16) = v12 + 152;
  *(_OWORD *)(v12 + 136) = xmmword_1C64638C0;
  if ((_QWORD)v41)
    sub_1C4FE6ED8((uint64_t)(v12 + 128), (uint64_t)&v40);
  *((_QWORD *)v12 + 27) = v12 + 240;
  *((_OWORD *)v12 + 14) = xmmword_1C64638C0;
  if ((_QWORD)v44)
    sub_1C4FE6ED8((uint64_t)(v12 + 216), (uint64_t)&v43);
  *(_QWORD *)(a5 + 24) = v12;
  if (v43 != v45)
    free(v43);
  if (v40 != v42)
    free(v40);
  if (v39 == v38)
  {
    v13 = 4;
  }
  else
  {
    if (!v39)
      goto LABEL_43;
    v13 = 5;
    v11 = v39;
  }
  (*(void (**)(_QWORD *))(*v11 + 8 * v13))(v11);
LABEL_43:
  if (v35 != v37)
    free(v35);
  if (v23 != v25)
    free(v23);
  if (v20 != v22)
    free(v20);
  if (v19 == v18)
  {
    v14 = 4;
  }
  else
  {
    if (!v19)
      goto LABEL_54;
    v14 = 5;
    v9 = v19;
  }
  (*(void (**)(_QWORD *))(*v9 + 8 * v14))(v9);
LABEL_54:
  if (v15 != v17)
    free(v15);
  if (v26 != v28)
    free(v26);
  if (v29 != v31)
    free(v29);
  if (v32 != v34)
    free(v32);
}

_QWORD *sub_1C5DD755C(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;

  *a1 = &off_1E819DE08;
  v2 = (_QWORD *)a1[27];
  if (v2 != a1 + 30)
    free(v2);
  v3 = (_QWORD *)a1[16];
  if (v3 != a1 + 19)
    free(v3);
  v4 = (_QWORD *)a1[15];
  if (v4 == a1 + 12)
  {
    v5 = 4;
    v4 = a1 + 12;
  }
  else
  {
    if (!v4)
      goto LABEL_10;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_10:
  v6 = (_QWORD *)a1[1];
  if (v6 != a1 + 4)
    free(v6);
  return a1;
}

void sub_1C5DD75F4(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;

  *a1 = &off_1E819DE08;
  v2 = (_QWORD *)a1[27];
  if (v2 != a1 + 30)
    free(v2);
  v3 = (_QWORD *)a1[16];
  if (v3 != a1 + 19)
    free(v3);
  v4 = (_QWORD *)a1[15];
  if (v4 == a1 + 12)
  {
    v5 = 4;
    v4 = a1 + 12;
  }
  else
  {
    if (!v4)
      goto LABEL_10;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_10:
  v6 = (_QWORD *)a1[1];
  if (v6 != a1 + 4)
    free(v6);
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C5DD769C(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *v2;

  v1 = (_QWORD *)(a1 + 8);
  v2 = operator new(0x130uLL);
  *v2 = &off_1E819DE08;
  sub_1C5DD7FA4((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t sub_1C5DD76DC(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E819DE08;
  return sub_1C5DD7FA4((uint64_t)(a2 + 1), (_QWORD *)(a1 + 8));
}

void sub_1C5DD76F8(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;

  v2 = (_QWORD *)a1[27];
  if (v2 != a1 + 30)
    free(v2);
  v3 = (_QWORD *)a1[16];
  if (v3 != a1 + 19)
    free(v3);
  v4 = (_QWORD *)a1[15];
  if (v4 == a1 + 12)
  {
    v5 = 4;
    v4 = a1 + 12;
  }
  else
  {
    if (!v4)
      goto LABEL_10;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_10:
  v6 = (_QWORD *)a1[1];
  if (v6 != a1 + 4)
    free(v6);
}

void sub_1C5DD7788(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;

  v2 = (_QWORD *)__p[27];
  if (v2 != __p + 30)
    free(v2);
  v3 = (_QWORD *)__p[16];
  if (v3 != __p + 19)
    free(v3);
  v4 = (_QWORD *)__p[15];
  if (v4 == __p + 12)
  {
    v5 = 4;
    v4 = __p + 12;
  }
  else
  {
    if (!v4)
      goto LABEL_10;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_10:
  v6 = (_QWORD *)__p[1];
  if (v6 != __p + 4)
    free(v6);
  operator delete(__p);
}

void sub_1C5DD7814(_QWORD *a1@<X0>, int *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  int v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  llvm::sys::Process *v12;
  uint64_t v13;
  void *v14;
  _QWORD *v15;
  uint64_t v16;
  const std::error_category *v17;
  const std::error_category *v18;
  _QWORD *v19;
  _QWORD *v20;
  void **v21;
  _QWORD *v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  std::string v29;
  _QWORD v30[4];
  __int16 v31;
  uint64_t v32;
  _QWORD *v33;
  std::error_code v34;
  void **v35[4];
  __int16 v36;
  void *__p[2];
  char v38;
  void **v39;
  uint64_t v40[2];
  void *v41;
  __int128 v42;
  uint64_t v43;
  __int16 v44;
  void *v45;
  __int128 v46;
  _BYTE v47[64];
  void *v48;
  __int128 v49;
  _BYTE v50[64];
  _QWORD v51[3];
  _QWORD *v52;
  void *v53;
  __int128 v54;
  _BYTE v55[64];
  int v56[2];
  char v57;
  void *v58;
  __int128 v59;
  _WORD v60[32];
  void *v61;
  __int128 v62;
  _BYTE v63[64];
  void *v64;
  __int128 v65;
  uint64_t v66;
  __int16 v67;
  void *v68;
  __int128 v69;
  _BYTE v70[64];
  void *v71;
  __int128 v72;
  _BYTE v73[64];
  _QWORD v74[3];
  _QWORD *v75;
  void *v76;
  __int128 v77;
  _QWORD v78[10];

  v78[8] = *MEMORY[0x1E0C80C00];
  v5 = *a2;
  v6 = *a3;
  v7 = a3[1];
  v61 = v63;
  v62 = xmmword_1C64638C0;
  v8 = (void *)a1[1];
  v9 = a1[2];
  v10 = (uint64_t)(a1 + 1);
  v67 = 261;
  v64 = v8;
  *(_QWORD *)&v65 = v9;
  v44 = 1283;
  v41 = "llvmcache-";
  *((_QWORD *)&v42 + 1) = v6;
  v43 = v7;
  v60[4] = 257;
  v36 = 257;
  llvm::sys::path::append(&v61, 0, (_QWORD **)&v64, (_QWORD **)&v41, (_QWORD **)&v58, v35);
  v58 = v60;
  v59 = xmmword_1C64638C0;
  v67 = 261;
  v64 = v61;
  *(_QWORD *)&v65 = v62;
  llvm::sys::fs::openNativeFileForRead((unsigned __int8 *)&v64, 32, &v58, (uint64_t)v56);
  std::system_category();
  v11 = v57;
  if ((v57 & 1) != 0)
  {
    v15 = *(_QWORD **)v56;
    *(_QWORD *)v56 = 0;
    v33 = v15;
    v16 = llvm::errorToErrorCode(&v33);
    v18 = v17;
    *(_QWORD *)&v34.__val_ = v16;
    v34.__cat_ = v17;
    if (v33)
      (*(void (**)(_QWORD *))(*v33 + 8))(v33);
LABEL_10:
    if ((v18 != std::generic_category() || (_DWORD)v16 != 2) && (v18 != std::generic_category() || (_DWORD)v16 != 13))
    {
      v30[0] = "Failed to open cache file ";
      v30[2] = v61;
      v30[3] = v62;
      v31 = 1283;
      v35[0] = (void **)v30;
      v35[2] = (void **)": ";
      v36 = 770;
      std::error_code::message(&v29, &v34);
      v41 = v35;
      *((_QWORD *)&v42 + 1) = &v29;
      v44 = 1026;
      v64 = &v41;
      *((_QWORD *)&v65 + 1) = "\n";
      v67 = 770;
      llvm::Twine::str((llvm::Twine *)&v64, __p);
      if (v38 >= 0)
        v21 = __p;
      else
        v21 = (void **)__p[0];
      v40[0] = v16;
      v40[1] = (uint64_t)v18;
      v39 = v21;
      sub_1C5DF1730((_BYTE **)&v39, v40, &v32);
      if (v38 < 0)
        operator delete(__p[0]);
      *(_BYTE *)(a4 + 32) |= 1u;
      *(_QWORD *)a4 = v32;
      v32 = 0;
      if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v29.__r_.__value_.__l.__data_);
      goto LABEL_86;
    }
    v41 = &v43;
    v42 = xmmword_1C64638C0;
    if (a1[2])
      sub_1C50502AC((uint64_t)&v41, v10);
    v45 = v47;
    v46 = xmmword_1C64638C0;
    if (a1[17])
      sub_1C50502AC((uint64_t)&v45, (uint64_t)(a1 + 16));
    v48 = v50;
    v49 = xmmword_1C64638C0;
    if (a1[28])
      sub_1C50502AC((uint64_t)&v48, (uint64_t)(a1 + 27));
    v19 = v51;
    v20 = (_QWORD *)a1[15];
    if (v20)
    {
      if (v20 == a1 + 12)
      {
        v52 = v51;
        (*(void (**)(_QWORD *, _QWORD *))(*v20 + 24))(v20, v51);
      }
      else
      {
        v52 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v20 + 16))(v20);
      }
    }
    else
    {
      v52 = 0;
    }
    v53 = v55;
    v54 = xmmword_1C64638C0;
    if ((_QWORD)v62)
      sub_1C50502AC((uint64_t)&v53, (uint64_t)&v61);
    *(_BYTE *)(a4 + 32) &= ~1u;
    v64 = &v66;
    v65 = xmmword_1C64638C0;
    if ((_QWORD)v42)
      sub_1C4FE6ED8((uint64_t)&v64, (uint64_t)&v41);
    v68 = v70;
    v69 = xmmword_1C64638C0;
    if ((_QWORD)v46)
      sub_1C4FE6ED8((uint64_t)&v68, (uint64_t)&v45);
    v71 = v73;
    v72 = xmmword_1C64638C0;
    if ((_QWORD)v49)
      sub_1C4FE6ED8((uint64_t)&v71, (uint64_t)&v48);
    v22 = v74;
    if (v52)
    {
      if (v52 == v51)
      {
        v75 = v74;
        (*(void (**)(_QWORD *, _QWORD *))(v51[0] + 24))(v51, v74);
      }
      else
      {
        v75 = v52;
        v52 = 0;
      }
    }
    else
    {
      v75 = 0;
    }
    v76 = v78;
    v77 = xmmword_1C64638C0;
    if ((_QWORD)v54)
      sub_1C4FE6ED8((uint64_t)&v76, (uint64_t)&v53);
    *(_QWORD *)(a4 + 24) = 0;
    v23 = (char *)operator new(0x188uLL);
    *(_QWORD *)v23 = &off_1E819DE50;
    *((_QWORD *)v23 + 1) = v23 + 32;
    *((_OWORD *)v23 + 1) = xmmword_1C64638C0;
    if ((_QWORD)v65)
      sub_1C4FE6ED8((uint64_t)(v23 + 8), (uint64_t)&v64);
    *((_QWORD *)v23 + 12) = v23 + 120;
    *(_OWORD *)(v23 + 104) = xmmword_1C64638C0;
    if ((_QWORD)v69)
      sub_1C4FE6ED8((uint64_t)(v23 + 96), (uint64_t)&v68);
    *((_QWORD *)v23 + 23) = v23 + 208;
    *((_OWORD *)v23 + 12) = xmmword_1C64638C0;
    if ((_QWORD)v72)
      sub_1C4FE6ED8((uint64_t)(v23 + 184), (uint64_t)&v71);
    if (v75)
    {
      if (v75 == v74)
      {
        *((_QWORD *)v23 + 37) = v23 + 272;
        (*(void (**)(_QWORD *))(v74[0] + 24))(v74);
      }
      else
      {
        *((_QWORD *)v23 + 37) = v75;
        v75 = 0;
      }
    }
    else
    {
      *((_QWORD *)v23 + 37) = 0;
    }
    *((_QWORD *)v23 + 38) = v23 + 328;
    *((_QWORD *)v23 + 39) = 0;
    *((_QWORD *)v23 + 40) = 64;
    if ((_QWORD)v77)
      sub_1C4FE6ED8((uint64_t)(v23 + 304), (uint64_t)&v76);
    *(_QWORD *)(a4 + 24) = v23;
    if (v76 != v78)
      free(v76);
    if (v75 == v74)
    {
      v24 = 4;
    }
    else
    {
      if (!v75)
        goto LABEL_67;
      v24 = 5;
      v22 = v75;
    }
    (*(void (**)(_QWORD *))(*v22 + 8 * v24))(v22);
LABEL_67:
    if (v71 != v73)
      free(v71);
    if (v68 != v70)
      free(v68);
    if (v64 != &v66)
      free(v64);
    if (v53 != v55)
      free(v53);
    if (v52 == v51)
    {
      v25 = 4;
    }
    else
    {
      if (!v52)
      {
LABEL_80:
        if (v48 != v50)
          free(v48);
        if (v45 != v47)
          free(v45);
        if (v41 != &v43)
          free(v41);
LABEL_86:
        if ((v11 & 1) != 0 && *(_QWORD *)v56)
          (*(void (**)(_QWORD))(**(_QWORD **)v56 + 8))(*(_QWORD *)v56);
        goto LABEL_89;
      }
      v25 = 5;
      v19 = v52;
    }
    (*(void (**)(_QWORD *))(*v19 + 8 * v25))(v19);
    goto LABEL_80;
  }
  v12 = (llvm::sys::Process *)v56[0];
  v67 = 261;
  v64 = v61;
  *(_QWORD *)&v65 = v62;
  sub_1C5E1FFD0(v56[0], (uint64_t)&v64, 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0, 0, 0, (uint64_t)&v41);
  v56[0] = -1;
  llvm::sys::Process::SafelyCloseFileDescriptor(v12);
  if ((BYTE8(v42) & 1) != 0)
  {
    v16 = (uint64_t)v41;
    v18 = (const std::error_category *)v42;
    *(_QWORD *)&v34.__val_ = v41;
    v34.__cat_ = (const std::error_category *)v42;
    goto LABEL_10;
  }
  v64 = v41;
  LODWORD(v35[0]) = v5;
  v13 = a1[15];
  if (!v13)
  {
    sub_1C485C2F0();
    sub_1C5DD7FA4(v26, v27);
    return;
  }
  (*(void (**)(uint64_t, void ***, void **))(*(_QWORD *)v13 + 48))(v13, v35, &v64);
  v14 = v64;
  v64 = 0;
  if (v14)
    (*(void (**)(void *))(*(_QWORD *)v14 + 8))(v14);
  *(_BYTE *)(a4 + 32) &= ~1u;
  *(_QWORD *)(a4 + 24) = 0;
LABEL_89:
  if (v58 != v60)
    free(v58);
  if (v61 != v63)
    free(v61);
}

uint64_t sub_1C5DD7FA4(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;

  *(_QWORD *)a1 = a1 + 24;
  *(_OWORD *)(a1 + 8) = xmmword_1C64638C0;
  if (a2[1])
    sub_1C50502AC(a1, (uint64_t)a2);
  v4 = (_QWORD *)a2[14];
  if (v4)
  {
    if (v4 == a2 + 11)
    {
      *(_QWORD *)(a1 + 112) = a1 + 88;
      (*(void (**)(_QWORD))(*(_QWORD *)a2[14] + 24))(a2[14]);
    }
    else
    {
      *(_QWORD *)(a1 + 112) = (*(uint64_t (**)(_QWORD *))(*v4 + 16))(v4);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 112) = 0;
  }
  *(_QWORD *)(a1 + 120) = a1 + 144;
  *(_OWORD *)(a1 + 128) = xmmword_1C64638C0;
  if (a2[16])
    sub_1C50502AC(a1 + 120, (uint64_t)(a2 + 15));
  *(_QWORD *)(a1 + 208) = a1 + 232;
  *(_OWORD *)(a1 + 216) = xmmword_1C64638C0;
  if (a2[27])
    sub_1C50502AC(a1 + 208, (uint64_t)(a2 + 26));
  return a1;
}

_QWORD *sub_1C5DD808C(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;

  *a1 = &off_1E819DE50;
  v2 = (_QWORD *)a1[38];
  if (v2 != a1 + 41)
    free(v2);
  v3 = (_QWORD *)a1[37];
  if (v3 == a1 + 34)
  {
    v4 = 4;
    v3 = a1 + 34;
  }
  else
  {
    if (!v3)
      goto LABEL_8;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_8:
  v5 = (_QWORD *)a1[23];
  if (v5 != a1 + 26)
    free(v5);
  v6 = (_QWORD *)a1[12];
  if (v6 != a1 + 15)
    free(v6);
  v7 = (_QWORD *)a1[1];
  if (v7 != a1 + 4)
    free(v7);
  return a1;
}

void sub_1C5DD8138(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;

  *a1 = &off_1E819DE50;
  v2 = (_QWORD *)a1[38];
  if (v2 != a1 + 41)
    free(v2);
  v3 = (_QWORD *)a1[37];
  if (v3 == a1 + 34)
  {
    v4 = 4;
    v3 = a1 + 34;
  }
  else
  {
    if (!v3)
      goto LABEL_8;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_8:
  v5 = (_QWORD *)a1[23];
  if (v5 != a1 + 26)
    free(v5);
  v6 = (_QWORD *)a1[12];
  if (v6 != a1 + 15)
    free(v6);
  v7 = (_QWORD *)a1[1];
  if (v7 != a1 + 4)
    free(v7);
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C5DD81F4(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *v2;

  v1 = (_QWORD *)(a1 + 8);
  v2 = operator new(0x188uLL);
  *v2 = &off_1E819DE50;
  sub_1C5DD88F0((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t sub_1C5DD8234(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E819DE50;
  return sub_1C5DD88F0((uint64_t)(a2 + 1), (_QWORD *)(a1 + 8));
}

void sub_1C5DD8250(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;

  v2 = (_QWORD *)a1[38];
  if (v2 != a1 + 41)
    free(v2);
  v3 = (_QWORD *)a1[37];
  if (v3 == a1 + 34)
  {
    v4 = 4;
    v3 = a1 + 34;
  }
  else
  {
    if (!v3)
      goto LABEL_8;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_8:
  v5 = (_QWORD *)a1[23];
  if (v5 != a1 + 26)
    free(v5);
  v6 = (_QWORD *)a1[12];
  if (v6 != a1 + 15)
    free(v6);
  v7 = (_QWORD *)a1[1];
  if (v7 != a1 + 4)
    free(v7);
}

void sub_1C5DD82F4(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;

  v2 = (_QWORD *)__p[38];
  if (v2 != __p + 41)
    free(v2);
  v3 = (_QWORD *)__p[37];
  if (v3 == __p + 34)
  {
    v4 = 4;
    v3 = __p + 34;
  }
  else
  {
    if (!v3)
      goto LABEL_8;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_8:
  v5 = (_QWORD *)__p[23];
  if (v5 != __p + 26)
    free(v5);
  v6 = (_QWORD *)__p[12];
  if (v6 != __p + 15)
    free(v6);
  v7 = (_QWORD *)__p[1];
  if (v7 != __p + 4)
    free(v7);
  operator delete(__p);
}

void sub_1C5DD8394(_QWORD *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>)
{
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t directories;
  uint64_t v9;
  _QWORD *v10;
  void *v11;
  void ***v12;
  uint64_t v13;
  uint64_t v14;
  size_t v15;
  const void *v16;
  void ***v17;
  const std::error_category *v18;
  char *v19;
  std::string *v20;
  std::string::size_type v21;
  unint64_t v22;
  uint64_t v23;
  _BYTE *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  void *v29;
  char v30;
  int v31;
  unint64_t v32;
  void **v33;
  int v34;
  uint64_t v35;
  void ****v36;
  uint64_t v37;
  void (**v38)(void ****, uint64_t);
  int v39;
  char *v40;
  char *v41;
  std::string v42;
  void *v43[2];
  std::string::size_type v44;
  uint64_t v45;
  void **__dst;
  size_t v47;
  unint64_t v48;
  uint64_t v49;
  __int16 v50;
  _BYTE *v51;
  uint64_t v52[2];
  char *v53;
  void *v54;
  _BYTE v55[15];
  char v56;
  int v57;
  char v58;
  _BYTE __p[15];
  char v60;
  __int16 v61;
  void ***p_dst;
  uint64_t v63;
  const char *v64;
  void ****p_p_dst;
  __int16 v66;
  void ***v67;
  __int128 v68;
  _WORD v69[32];
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  v5 = *a2;
  v69[4] = 261;
  v6 = a1[2];
  v67 = (void ***)a1[1];
  *(_QWORD *)&v68 = v6;
  directories = llvm::sys::fs::create_directories((unsigned __int8 **)&v67, 1, 504);
  if ((_DWORD)directories)
  {
    v9 = v7;
    v10 = (_QWORD *)operator new();
    *v10 = &off_1E81A0D28;
    v10[1] = directories;
    v10[2] = v9;
    *(_BYTE *)(a3 + 8) |= 1u;
    *(_QWORD *)a3 = v10;
    return;
  }
  v67 = (void ***)v69;
  v68 = xmmword_1C64638C0;
  LOWORD(v57) = 261;
  v11 = (void *)a1[2];
  v53 = (char *)a1[1];
  v54 = v11;
  v12 = (void ***)a1[12];
  v13 = a1[13];
  v66 = 773;
  p_dst = v12;
  v63 = v13;
  v64 = "-%%%%%%.tmp.o";
  v50 = 257;
  v61 = 257;
  llvm::sys::path::append(&v67, 0, (_QWORD **)&v53, &p_dst, &__dst, (void ***)__p);
  v66 = 261;
  p_dst = v67;
  v63 = v68;
  llvm::sys::fs::TempFile::create((uint64_t)&p_dst, 384, 0, (uint64_t)&v53);
  if ((v58 & 1) != 0)
  {
    v18 = std::generic_category();
    if ((v58 & 1) != 0)
    {
      v19 = v53;
      v53 = 0;
    }
    else
    {
      v19 = 0;
    }
    v41 = v19;
    sub_1C61D2548(&v41, &v42);
    v20 = std::string::append(&v42, ": ");
    v21 = v20->__r_.__value_.__r.__words[2];
    *(_OWORD *)v43 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
    v44 = v21;
    v20->__r_.__value_.__l.__size_ = 0;
    v20->__r_.__value_.__r.__words[2] = 0;
    v20->__r_.__value_.__r.__words[0] = 0;
    v22 = a1[23];
    v23 = a1[24];
    __dst = v43;
    v48 = v22;
    v49 = v23;
    v50 = 1284;
    p_dst = &__dst;
    v64 = ": Can't get a temporary file";
    v66 = 770;
    llvm::Twine::str((llvm::Twine *)&p_dst, __p);
    if (v60 >= 0)
      v24 = __p;
    else
      v24 = *(_BYTE **)__p;
    v52[0] = 5;
    v52[1] = (uint64_t)v18;
    v51 = v24;
    sub_1C5DF1730(&v51, v52, &v45);
    if (v60 < 0)
      operator delete(*(void **)__p);
    *(_BYTE *)(a3 + 8) |= 1u;
    *(_QWORD *)a3 = v45;
    v45 = 0;
    if (SHIBYTE(v44) < 0)
      operator delete(v43[0]);
    if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v42.__r_.__value_.__l.__data_);
    if (v41)
      (*(void (**)(char *))(*(_QWORD *)v41 + 8))(v41);
    goto LABEL_47;
  }
  v14 = operator new();
  llvm::raw_fd_ostream::raw_fd_ostream(v14, v57, 0, 0, 0);
  v15 = a1[39];
  if (v15 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v16 = (const void *)a1[38];
  if (v15 >= 0x17)
  {
    v25 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v15 | 7) != 0x17)
      v25 = v15 | 7;
    v26 = v25 + 1;
    v17 = (void ***)operator new(v25 + 1);
    v47 = v15;
    v48 = v26 | 0x8000000000000000;
    __dst = (void **)v17;
    goto LABEL_26;
  }
  HIBYTE(v48) = a1[39];
  v17 = &__dst;
  if (v15)
LABEL_26:
    memmove(v17, v16, v15);
  *((_BYTE *)v17 + v15) = 0;
  v27 = operator new();
  v28 = (_QWORD *)a1[37];
  if (v28)
  {
    if (v28 == a1 + 34)
    {
      p_p_dst = &p_dst;
      (*(void (**)(_QWORD *, void ****))(*v28 + 24))(v28, &p_dst);
    }
    else
    {
      p_p_dst = (void ****)(*(uint64_t (**)(_QWORD *))(*v28 + 16))(v28);
    }
  }
  else
  {
    p_p_dst = 0;
  }
  v29 = v54;
  *(_QWORD *)__p = *(_QWORD *)v55;
  *(_QWORD *)&__p[7] = *(_QWORD *)&v55[7];
  v30 = v56;
  v56 = 0;
  LOBYTE(v54) = 0;
  v31 = v57;
  LOBYTE(v53) = 1;
  v57 = -1;
  v33 = __dst;
  v32 = v47;
  LODWORD(v43[0]) = v48;
  *(_DWORD *)((char *)v43 + 3) = *(_DWORD *)((char *)&v48 + 3);
  v34 = SHIBYTE(v48);
  __dst = 0;
  v47 = 0;
  v48 = 0;
  *(_QWORD *)v27 = &unk_1E817ECC0;
  *(_QWORD *)(v27 + 8) = v14;
  if (v34 < 0)
  {
    sub_1C47EBC30((_BYTE *)(v27 + 16), v33, v32);
    operator delete(v33);
  }
  else
  {
    *(_QWORD *)(v27 + 16) = v33;
    *(_QWORD *)(v27 + 24) = v32;
    *(_DWORD *)(v27 + 32) = v43[0];
    *(_DWORD *)(v27 + 35) = *(_DWORD *)((char *)v43 + 3);
    *(_BYTE *)(v27 + 39) = v34;
  }
  *(_QWORD *)v27 = &off_1E819DE98;
  v35 = v27 + 40;
  if (p_p_dst)
  {
    if (p_p_dst == &p_dst)
    {
      *(_QWORD *)(v27 + 64) = v35;
      ((void (*)(void ****))p_dst[3])(&p_dst);
      v36 = p_p_dst;
    }
    else
    {
      v36 = 0;
      *(_QWORD *)(v27 + 64) = p_p_dst;
      p_p_dst = 0;
    }
  }
  else
  {
    v36 = 0;
    *(_QWORD *)(v27 + 64) = 0;
  }
  *(_BYTE *)(v27 + 72) = 0;
  v37 = *(_QWORD *)__p;
  *(_QWORD *)(v27 + 80) = v29;
  *(_QWORD *)(v27 + 88) = v37;
  *(_QWORD *)(v27 + 95) = *(_QWORD *)&__p[7];
  *(_BYTE *)(v27 + 103) = v30;
  *(_DWORD *)(v27 + 104) = v31;
  *(_DWORD *)(v27 + 112) = v5;
  if (v36 == &p_dst)
  {
    v38 = (void (**)(void ****, uint64_t))(p_dst + 4);
    v36 = &p_dst;
LABEL_44:
    (*v38)(v36, v35);
    v39 = SHIBYTE(v48);
    *(_BYTE *)(a3 + 8) &= ~1u;
    *(_QWORD *)a3 = v27;
    if (v39 < 0)
      operator delete(__dst);
    goto LABEL_47;
  }
  if (v36)
  {
    v38 = (void (**)(void ****, uint64_t))(*v36 + 5);
    goto LABEL_44;
  }
  *(_BYTE *)(a3 + 8) &= ~1u;
  *(_QWORD *)a3 = v27;
LABEL_47:
  if ((v58 & 1) != 0)
  {
    v40 = v53;
    v53 = 0;
    if (v40)
      (*(void (**)(char *))(*(_QWORD *)v40 + 8))(v40);
  }
  else if (v56 < 0)
  {
    operator delete(v54);
  }
  if (v67 != (void ***)v69)
    free(v67);
}

uint64_t sub_1C5DD88F0(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;

  *(_QWORD *)a1 = a1 + 24;
  *(_OWORD *)(a1 + 8) = xmmword_1C64638C0;
  if (a2[1])
    sub_1C50502AC(a1, (uint64_t)a2);
  *(_QWORD *)(a1 + 88) = a1 + 112;
  *(_OWORD *)(a1 + 96) = xmmword_1C64638C0;
  if (a2[12])
    sub_1C50502AC(a1 + 88, (uint64_t)(a2 + 11));
  *(_QWORD *)(a1 + 176) = a1 + 200;
  *(_OWORD *)(a1 + 184) = xmmword_1C64638C0;
  if (a2[23])
    sub_1C50502AC(a1 + 176, (uint64_t)(a2 + 22));
  v4 = (_QWORD *)a2[36];
  if (v4)
  {
    if (v4 == a2 + 33)
    {
      *(_QWORD *)(a1 + 288) = a1 + 264;
      (*(void (**)(_QWORD))(*(_QWORD *)a2[36] + 24))(a2[36]);
    }
    else
    {
      *(_QWORD *)(a1 + 288) = (*(uint64_t (**)(_QWORD *))(*v4 + 16))(v4);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 288) = 0;
  }
  *(_QWORD *)(a1 + 296) = a1 + 320;
  *(_OWORD *)(a1 + 304) = xmmword_1C64638C0;
  if (a2[38])
    sub_1C50502AC(a1 + 296, (uint64_t)(a2 + 37));
  return a1;
}

uint64_t sub_1C5DD89FC(uint64_t a1)
{
  uint64_t v2;
  int v3;
  const llvm::Twine *v4;
  char *v5;
  uint64_t *v6;
  uint64_t *v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  char **v12;
  uint64_t v13;
  char **v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  const std::error_category *v20;
  uint64_t *v21;
  const char *v22;
  __int16 v23;
  char *v24;
  std::string v25;
  std::string *v26;
  __int16 v27;
  std::error_code v28;
  __int16 v29;
  std::string v30;
  __int16 v31;
  char *v32;
  uint64_t v33[4];
  __int16 v34;
  uint64_t v35[4];
  __int16 v36;
  uint64_t v37[4];
  __int16 v38;
  uint64_t v39[4];
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  char *v43[5];
  char *v44[5];
  uint64_t v45[5];
  char **v46[4];
  __int16 v47;
  _QWORD v48[2];
  char v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = &off_1E819DE98;
  *(_QWORD *)(a1 + 8) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *(_DWORD *)(a1 + 104);
  v47 = 260;
  v46[0] = (char **)(a1 + 16);
  sub_1C5E1FFD0(v3, (uint64_t)v46, 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0, 0, 0, (uint64_t)v48);
  if ((v49 & 1) != 0)
  {
    v41[0] = (uint64_t)"Failed to open new cache file ";
    v42 = 259;
    v40 = 260;
    v39[0] = a1 + 80;
    sub_1C6131AAC(v41, v39, (uint64_t)v43);
    v37[0] = (uint64_t)": ";
    v38 = 259;
    sub_1C6131AAC((uint64_t *)v43, v37, (uint64_t)v44);
    *(_QWORD *)&v28.__val_ = sub_1C63837A4(v48);
    v28.__cat_ = v20;
    std::error_code::message(&v30, &v28);
    v36 = 260;
    v35[0] = (uint64_t)&v30;
    sub_1C6131AAC((uint64_t *)v44, v35, (uint64_t)v45);
    v33[0] = (uint64_t)"\n";
    v34 = 259;
    v21 = v33;
    goto LABEL_44;
  }
  v47 = 260;
  v46[0] = (char **)(a1 + 16);
  llvm::sys::fs::TempFile::keep((llvm::sys::fs::TempFile *)(a1 + 72), (const llvm::Twine *)v46, v4, &v32);
  v5 = v32;
  v32 = 0;
  v46[0] = (char **)v48;
  v46[1] = (char **)a1;
  if (!v5)
  {
    v32 = 0;
    goto LABEL_23;
  }
  if ((*(unsigned int (**)(char *, void *))(*(_QWORD *)v5 + 48))(v5, &llvm::ErrorList::ID))
  {
    v6 = (uint64_t *)*((_QWORD *)v5 + 1);
    v7 = (uint64_t *)*((_QWORD *)v5 + 2);
    if (v6 == v7)
    {
      v8 = 0;
    }
    else
    {
      v8 = 0;
      do
      {
        v44[0] = v8;
        v9 = *v6;
        *v6 = 0;
        v41[0] = v9;
        sub_1C5DD8E9C(v43, v41, v46);
        sub_1C6174794(v44, v43, v45);
        v8 = (char *)v45[0];
        v45[0] = 0;
        if (v43[0])
          (*(void (**)(char *))(*(_QWORD *)v43[0] + 8))(v43[0]);
        v10 = v41[0];
        v41[0] = 0;
        if (v10)
          (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
        if (v44[0])
          (*(void (**)(char *))(*(_QWORD *)v44[0] + 8))(v44[0]);
        ++v6;
      }
      while (v6 != v7);
    }
    v37[0] = (uint64_t)v8;
    goto LABEL_21;
  }
  v39[0] = (uint64_t)v5;
  sub_1C5DD8E9C(v37, v39, v46);
  v5 = (char *)v39[0];
  if (v39[0])
LABEL_21:
    (*(void (**)(char *))(*(_QWORD *)v5 + 8))(v5);
  v32 = (char *)v37[0];
  if (v37[0])
  {
    v37[0] = (uint64_t)"Failed to rename temporary file ";
    v38 = 259;
    v36 = 260;
    v35[0] = a1 + 80;
    sub_1C6131AAC(v37, v35, (uint64_t)v39);
    v33[0] = (uint64_t)" to ";
    v34 = 259;
    sub_1C6131AAC(v39, v33, (uint64_t)v41);
    v31 = 260;
    v30.__r_.__value_.__r.__words[0] = a1 + 16;
    sub_1C6131AAC(v41, (uint64_t *)&v30, (uint64_t)v43);
    *(_QWORD *)&v28.__val_ = ": ";
    v29 = 259;
    sub_1C6131AAC((uint64_t *)v43, (uint64_t *)&v28.__val_, (uint64_t)v44);
    v24 = v32;
    v32 = 0;
    sub_1C61D2548(&v24, &v25);
    v27 = 260;
    v26 = &v25;
    sub_1C6131AAC((uint64_t *)v44, (uint64_t *)&v26, (uint64_t)v45);
    v22 = "\n";
    v23 = 259;
    v21 = (uint64_t *)&v22;
LABEL_44:
    sub_1C6131AAC(v45, v21, (uint64_t)v46);
    llvm::report_fatal_error((uint64_t)v46, 1);
  }
LABEL_23:
  v11 = *(_DWORD *)(a1 + 112);
  v12 = (char **)v48[0];
  v48[0] = 0;
  v46[0] = v12;
  LODWORD(v45[0]) = v11;
  v13 = *(_QWORD *)(a1 + 64);
  if (!v13)
    sub_1C485C2F0();
  (*(void (**)(uint64_t, uint64_t *, char ***))(*(_QWORD *)v13 + 48))(v13, v45, v46);
  v14 = v46[0];
  v46[0] = 0;
  if (v14)
    (*((void (**)(char **))*v14 + 1))(v14);
  if (v32)
    (*(void (**)(char *))(*(_QWORD *)v32 + 8))(v32);
  if ((v49 & 1) == 0)
  {
    v15 = v48[0];
    v48[0] = 0;
    if (v15)
      (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
  }
  if (*(char *)(a1 + 103) < 0)
    operator delete(*(void **)(a1 + 80));
  v16 = *(_QWORD **)(a1 + 64);
  if (v16 == (_QWORD *)(a1 + 40))
  {
    v17 = 4;
    v16 = (_QWORD *)(a1 + 40);
  }
  else
  {
    if (!v16)
      goto LABEL_38;
    v17 = 5;
  }
  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_38:
  *(_QWORD *)a1 = &unk_1E817ECC0;
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  v18 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = 0;
  if (v18)
    (*(void (**)(uint64_t))(*(_QWORD *)v18 + 8))(v18);
  return a1;
}

void sub_1C5DD8E78(uint64_t a1)
{
  sub_1C5DD89FC(a1);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C5DD8E9C(_QWORD *a1, _QWORD *a2, char ***a3)
{
  uint64_t result;
  uint64_t v7;
  char **v8;
  uint64_t v9;
  const std::error_category *v10;
  const std::error_category *v11;
  _QWORD *v13;
  char *v14;
  const void *v15;
  size_t v16;
  char *v17;
  char **v18;
  char v19;
  char *v20;
  char *v21;
  char *v22;
  char *v23[4];
  __int16 v24;
  char *v25[2];
  char v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  result = (*(uint64_t (**)(_QWORD, void *))(*(_QWORD *)*a2 + 48))(*a2, &llvm::ECError::ID);
  v7 = *a2;
  *a2 = 0;
  if ((_DWORD)result)
  {
    v8 = a3[1];
    v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 32))(v7);
    v11 = v10;
    if (std::generic_category() == v10 && v9 == 13)
    {
      v14 = **a3;
      v15 = (const void *)*((_QWORD *)v14 + 1);
      v16 = *((_QWORD *)v14 + 2) - (_QWORD)v15;
      v24 = 260;
      v23[0] = (char *)(v8 + 2);
      sub_1C5E1F4D0(v15, v16, (uint64_t)v23, (uint64_t)v25);
      if ((v26 & 1) != 0)
        v17 = 0;
      else
        v17 = v25[0];
      v18 = *a3;
      v19 = *((_BYTE *)v18 + 16);
      if ((v19 & 1) == 0)
      {
        v20 = *v18;
        *v18 = 0;
        if (v20)
        {
          (*(void (**)(char *))(*(_QWORD *)v20 + 8))(v20);
          v19 = *((_BYTE *)v18 + 16);
        }
      }
      *((_BYTE *)v18 + 16) = v19 & 0xFE;
      *v18 = v17;
      llvm::sys::fs::TempFile::discard((llvm::sys::fs::TempFile *)(v8 + 9), &v22);
      v21 = v22;
      v22 = 0;
      v25[0] = v21;
      sub_1C4D62BD4(v25, v23);
      if (v25[0])
        (*(void (**)(char *))(*(_QWORD *)v25[0] + 8))(v25[0]);
      v13 = v22;
      if (!v22)
        goto LABEL_8;
      (*(void (**)(char *))(*(_QWORD *)v22 + 8))(v22);
    }
    else if ((_DWORD)v9)
    {
      v13 = (_QWORD *)operator new();
      *v13 = &off_1E81A0D28;
      v13[1] = v9;
      v13[2] = v11;
LABEL_8:
      *a1 = v13;
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
    }
    v13 = 0;
    goto LABEL_8;
  }
  *a1 = v7;
  return result;
}

llvm::raw_ostream *llvm::circular_raw_ostream::write_impl(llvm::raw_ostream *this, const char *a2, size_t a3)
{
  size_t v3;
  llvm::raw_ostream *v5;
  uint64_t v6;
  llvm::raw_ostream *v7;
  unsigned int v8;
  size_t v9;

  v3 = a3;
  v5 = this;
  v6 = *((_QWORD *)this + 10);
  if (!v6)
    return llvm::raw_ostream::write(*((llvm::raw_ostream **)this + 8), a2, a3);
  if (a3)
  {
    v7 = (llvm::raw_ostream *)*((_QWORD *)this + 11);
    this = (llvm::raw_ostream *)*((_QWORD *)this + 12);
    do
    {
      v8 = (_DWORD)v7 - (_DWORD)this + v6;
      if (v8 >= v3)
        v9 = v3;
      else
        v9 = v8;
      memcpy(this, a2, v9);
      v7 = (llvm::raw_ostream *)*((_QWORD *)v5 + 11);
      this = (llvm::raw_ostream *)(*((_QWORD *)v5 + 12) + v9);
      *((_QWORD *)v5 + 12) = this;
      v6 = *((_QWORD *)v5 + 10);
      if (this == (llvm::raw_ostream *)((char *)v7 + v6))
      {
        *((_QWORD *)v5 + 12) = v7;
        *((_BYTE *)v5 + 104) = 1;
        this = v7;
      }
      v3 -= v9;
    }
    while (v3);
  }
  return this;
}

llvm::raw_ostream *llvm::circular_raw_ostream::flushBufferWithBanner(llvm::raw_ostream *this)
{
  uint64_t v1;
  llvm::raw_ostream *v2;
  const char *v3;
  size_t v4;

  if (*((_QWORD *)this + 10))
  {
    v1 = (uint64_t)this;
    v2 = (llvm::raw_ostream *)*((_QWORD *)this + 8);
    v3 = (const char *)*((_QWORD *)this + 14);
    v4 = strlen(v3);
    llvm::raw_ostream::write(v2, v3, v4);
    if (*(_BYTE *)(v1 + 104))
      llvm::raw_ostream::write(*(llvm::raw_ostream **)(v1 + 64), *(const char **)(v1 + 96), *(_QWORD *)(v1 + 88) + *(_QWORD *)(v1 + 80) - *(_QWORD *)(v1 + 96));
    this = llvm::raw_ostream::write(*(llvm::raw_ostream **)(v1 + 64), *(const char **)(v1 + 88), *(_QWORD *)(v1 + 96) - *(_QWORD *)(v1 + 88));
    *(_QWORD *)(v1 + 96) = *(_QWORD *)(v1 + 88);
    *(_BYTE *)(v1 + 104) = 0;
  }
  return this;
}

void sub_1C5DD91AC(llvm::circular_raw_ostream *a1)
{
  sub_1C5DD9234(a1);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C5DD91D0(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 64) + 48))(*(_QWORD *)(a1 + 64));
}

uint64_t sub_1C5DD91E0(uint64_t a1)
{
  _QWORD *v1;

  v1 = *(_QWORD **)(a1 + 64);
  return (*(uint64_t (**)(_QWORD *))(*v1 + 80))(v1) + v1[4] - (v1[2] + v1[4]) + v1[2];
}

llvm::circular_raw_ostream *sub_1C5DD9234(llvm::circular_raw_ostream *this)
{
  const char *v2;
  const char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;

  *(_QWORD *)this = &off_1E819DEB8;
  v2 = (const char *)*((_QWORD *)this + 4);
  v3 = (const char *)*((_QWORD *)this + 2);
  if (v2 != v3)
  {
    *((_QWORD *)this + 4) = v3;
    llvm::raw_ostream::flush_tied_then_write(this, v3, v2 - v3);
  }
  llvm::circular_raw_ostream::flushBufferWithBanner(this);
  v4 = *((_QWORD *)this + 8);
  if (v4 && *((_BYTE *)this + 72))
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  v5 = *((_QWORD *)this + 11);
  if (v5)
    MEMORY[0x1CAA32F9C](v5, 0x1000C8077774924);
  *(_QWORD *)this = off_1E81A6E70;
  if (*((_DWORD *)this + 14) == 1)
  {
    v7 = *((_QWORD *)this + 2);
    if (v7)
      MEMORY[0x1CAA32F9C](v7, 0x1000C8077774924);
  }
  return this;
}

void llvm::format_provider<std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>,void>::format(_QWORD *a1, llvm::raw_ostream *a2, const char *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  int v9;
  unint64_t v10;
  int v11;
  unint64_t v12;
  char *v14;
  int v15;
  uint64_t v16;
  void **v17;
  const char *p_t;
  size_t v19;
  void *v20;
  void (**v22)(llvm::raw_ostream *__hidden);
  int v23;
  char *v24;
  unint64_t v25;
  char *v26;
  char v27;
  uint64_t v28;
  int v29;
  void **v30;
  void *__p[2];
  uint64_t v32;
  tm v33;
  std::chrono::system_clock::time_point __t;
  const char *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v6 = *a1 / 1000000000;
  v7 = *a1 % 1000000000;
  memset(&v33, 0, sizeof(v33));
  __t.__d_.__rep_ = 1000000 * v6;
  __t.__d_.__rep_ = std::chrono::system_clock::to_time_t(&__t);
  localtime_r(&__t.__d_.__rep_, &v33);
  v8 = 0;
  v9 = 0;
  if (a4)
  {
    v10 = a4;
  }
  else
  {
    a3 = "%Y-%m-%d %H:%M:%S.%N";
    v10 = 20;
  }
  __p[0] = 0;
  __p[1] = 0;
  v32 = 0;
  v23 = 0;
  v27 = 0;
  v28 = 0;
  v22 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
  v30 = __p;
  v29 = 0;
  v25 = 0;
  v26 = 0;
  v24 = 0;
  do
  {
    v11 = a3[v8];
    v12 = (v9 + 1);
    if (v11 == 37 && v10 > v12)
    {
      v15 = a3[v12];
      if (v15 > 77)
      {
        if (v15 == 78)
        {
          __t.__d_.__rep_ = (std::chrono::duration<long long, std::ratio<1, 1000000>>::rep)&unk_1E819DF30;
          v35 = "%.6lu";
          v36 = v7;
          goto LABEL_25;
        }
        if (v15 == 102)
        {
          __t.__d_.__rep_ = (std::chrono::duration<long long, std::ratio<1, 1000000>>::rep)&unk_1E819DF30;
          v35 = "%.6lu";
          v36 = v7 / 1000;
          goto LABEL_25;
        }
      }
      else
      {
        if (v15 == 37)
        {
          if (v25 - (unint64_t)v26 > 1)
          {
            *(_WORD *)v26 = 9509;
            v26 += 2;
          }
          else
          {
            llvm::raw_ostream::write((llvm::raw_ostream *)&v22, "%%", 2uLL);
          }
          goto LABEL_13;
        }
        if (v15 == 76)
        {
          __t.__d_.__rep_ = (std::chrono::duration<long long, std::ratio<1, 1000000>>::rep)&unk_1E819DF30;
          v35 = "%.3lu";
          v36 = v7 / 1000000;
LABEL_25:
          llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v22, (uint64_t)&__t);
          goto LABEL_13;
        }
      }
    }
    v14 = v26;
    if ((unint64_t)v26 >= v25)
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v22, v11);
    }
    else
    {
      ++v26;
      *v14 = v11;
    }
    LODWORD(v12) = v9;
LABEL_13:
    v8 = (v12 + 1);
    v9 = v12 + 1;
  }
  while (v10 > v8);
  v16 = v26 - v24;
  if (v26 != v24)
  {
    v26 = v24;
    llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)&v22, v24, v16);
  }
  if (v32 >= 0)
    v17 = __p;
  else
    v17 = (void **)__p[0];
  if (strftime((char *)&__t, 0x100uLL, (const char *)v17, &v33))
    p_t = (const char *)&__t;
  else
    p_t = "BAD-DATE-FORMAT";
  v19 = strlen(p_t);
  v20 = (void *)*((_QWORD *)a2 + 4);
  if (v19 <= *((_QWORD *)a2 + 3) - (_QWORD)v20)
  {
    if (v19)
    {
      memcpy(v20, p_t, v19);
      *((_QWORD *)a2 + 4) += v19;
    }
  }
  else
  {
    llvm::raw_ostream::write(a2, p_t, v19);
  }
  v22 = off_1E81A6E70;
  if (v29 == 1 && v24)
    MEMORY[0x1CAA32F9C](v24, 0x1000C8077774924);
  if (SHIBYTE(v32) < 0)
    operator delete(__p[0]);
}

double llvm::CodeGenCoverage::CodeGenCoverage(llvm::CodeGenCoverage *this)
{
  double result;

  *(_QWORD *)this = (char *)this + 16;
  *(_QWORD *)&result = 0x600000000;
  *((_QWORD *)this + 1) = 0x600000000;
  *((_DWORD *)this + 16) = 0;
  return result;
}

{
  double result;

  *(_QWORD *)this = (char *)this + 16;
  *(_QWORD *)&result = 0x600000000;
  *((_QWORD *)this + 1) = 0x600000000;
  *((_DWORD *)this + 16) = 0;
  return result;
}

uint64_t llvm::CodeGenCoverage::isCovered(llvm::CodeGenCoverage *this, unint64_t a2)
{
  if (*((unsigned int *)this + 16) <= a2)
    return 0;
  else
    return (*(_QWORD *)(*(_QWORD *)this + 8 * (a2 >> 6)) >> a2) & 1;
}

uint64_t llvm::CodeGenCoverage::covered@<X0>(llvm::CodeGenCoverage *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;

  result = sub_1C476B7EC((uint64_t)this);
  *a2 = this;
  a2[1] = result;
  a2[2] = this;
  a2[3] = 0xFFFFFFFFLL;
  return result;
}

uint64_t llvm::CodeGenCoverage::parse(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  const char *v4;
  const char *v5;
  const void *v7;
  _BOOL4 v10;
  uint64_t v11;
  uint64_t v12;
  const char *v14;
  size_t v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v21;
  int v23;
  uint64_t v24;
  unsigned int v25;
  int v26;
  unsigned int v27;
  unint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t result;
  uint64_t v32;
  _BOOL4 v33;

  v4 = *(const char **)(a2 + 8);
  v5 = *(const char **)(a2 + 16);
  if (v4 == v5)
    return 1;
  v7 = a3;
  v10 = a4 == 0;
  v32 = a1 + 16;
  v33 = v10;
  do
  {
    v11 = 0;
    do
      v12 = v11;
    while (v4[v11++]);
    v14 = &v4[v11];
    if (&v4[v11] == v5)
      return 0;
    if (v4)
    {
      v15 = strlen(v4);
      v10 = a4 == v15;
      if (a4)
      {
        if (a4 == v15)
          v10 = memcmp(v7, v4, a4) == 0;
      }
    }
    if (v5 - v4 - v11 < 8)
      return 0;
    v16 = ~(unint64_t)&v4[v12];
    v17 = (unint64_t *)&v4[v11];
    while (1)
    {
      v19 = *v17++;
      v18 = v19;
      if (v19 == -1 || !v10)
        break;
      if (v18 >= *(unsigned int *)(a1 + 64))
      {
        v23 = *(_DWORD *)(a1 + 64) & 0x3F;
        v24 = *(unsigned int *)(a1 + 8);
        if (v23)
          *(_QWORD *)(*(_QWORD *)a1 + 8 * v24 - 8) &= ~(-1 << v23);
        v25 = v24;
        LOBYTE(v26) = v18 + 1;
        *(_DWORD *)(a1 + 64) = v18 + 1;
        v27 = v18 + 64;
        if ((_DWORD)v24 != (v18 + 64) >> 6)
        {
          v28 = v27 >> 6;
          if (v24 > v28)
          {
            *(_DWORD *)(a1 + 8) = v28;
            v25 = v27 >> 6;
          }
          else
          {
            v29 = v24;
            if (v28 > *(_DWORD *)(a1 + 12))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod(a1, v32, v28, 8);
              v29 = *(unsigned int *)(a1 + 8);
              v25 = *(_DWORD *)(a1 + 8);
            }
            if (v28 != v24)
              bzero((void *)(*(_QWORD *)a1 + 8 * v29), 8 * (v28 - v24));
            v25 += v28 - v24;
            *(_DWORD *)(a1 + 8) = v25;
            v26 = *(_DWORD *)(a1 + 64);
          }
        }
        v21 = *(_QWORD *)a1;
        v30 = v26 & 0x3F;
        if (v30)
          *(_QWORD *)(v21 + 8 * v25 - 8) &= ~(-1 << v30);
      }
      else
      {
        v21 = *(_QWORD *)a1;
      }
      result = 1;
      *(_QWORD *)(v21 + 8 * (v18 >> 6)) |= 1 << v18;
      v5 = *(const char **)(a2 + 16);
      if (v17 == (unint64_t *)v5)
        return result;
LABEL_36:
      v16 -= 8;
      v14 = (const char *)v17;
      if ((uint64_t)&v5[v16] < 8)
        return 0;
    }
    if (v18 != -1 && v17 != (unint64_t *)v5)
      goto LABEL_36;
    v4 = v14 + 8;
    result = 1;
    v7 = a3;
    v10 = v33;
  }
  while (v14 + 8 != v5);
  return result;
}

BOOL llvm::CodeGenCoverage::emit(uint64_t a1, void (**a2)(llvm::raw_ostream *__hidden this), const std::error_category *a3, const void *a4, size_t a5)
{
  pid_t v11;
  unint64_t v12;
  int v13;
  __int128 v14;
  std::string *v15;
  std::string *v16;
  std::string::value_type *v17;
  std::string::size_type v18;
  int v19;
  std::string::size_type v20;
  void *v21;
  unsigned int v22;
  unsigned int i;
  char v24[8];
  char v25[8];
  char v26[8];
  void *__p[2];
  void *v28;
  void (**v29)(llvm::raw_ostream *__hidden);
  const std::error_category *v30;
  void **v31;
  uint64_t v32;
  uint64_t v33;
  char v34;
  uint64_t v35;
  int v36;
  void **v37;
  void *v38;
  std::string::size_type v39;
  uint64_t v40;

  if (!a3 || !*(_DWORD *)(a1 + 64))
    return 1;
  std::recursive_mutex::lock(&stru_1ED8259E8);
  v11 = getpid();
  v38 = 0;
  v39 = 0;
  v40 = 0;
  LODWORD(v30) = 0;
  v34 = 0;
  v35 = 0;
  v29 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
  v37 = &v38;
  v36 = 0;
  v32 = 0;
  v33 = 0;
  v31 = 0;
  v12 = v11;
  if (v11 < 0)
  {
    v12 = -(uint64_t)v11;
    v13 = 1;
  }
  else
  {
    v13 = 0;
  }
  sub_1C5E21910((llvm::raw_ostream *)&v29, v12, 0, 0, v13);
  if (*((char *)v37 + 23) < 0)
  {
    sub_1C47EBC30(__p, *v37, (unint64_t)v37[1]);
  }
  else
  {
    v14 = *(_OWORD *)v37;
    v28 = v37[2];
    *(_OWORD *)__p = v14;
  }
  v29 = off_1E81A6E70;
  if (v36 == 1 && v31)
    MEMORY[0x1CAA32F9C](v31, 0x1000C8077774924);
  if (SHIBYTE(v40) < 0)
    operator delete(v38);
  v29 = a2;
  v30 = a3;
  v31 = __p;
  LOWORD(v33) = 1029;
  llvm::Twine::str((llvm::Twine *)&v29, &v38);
  LODWORD(v29) = 0;
  v30 = std::system_category();
  v15 = (std::string *)operator new();
  v16 = v15;
  if (v40 >= 0)
    v17 = (std::string::value_type *)&v38;
  else
    v17 = (std::string::value_type *)v38;
  if (v40 >= 0)
    v18 = HIBYTE(v40) & 0x7F;
  else
    v18 = v39;
  llvm::ToolOutputFile::ToolOutputFile(v15, v17, v18, (uint64_t)&v29, 4);
  v19 = (int)v29;
  if (!(_DWORD)v29)
  {
    *(_QWORD *)v25 = -1;
    *(_QWORD *)v26 = 0;
    v20 = v16[5].__r_.__value_.__r.__words[2];
    v21 = *(void **)(v20 + 32);
    if (a5 <= *(_QWORD *)(v20 + 24) - (_QWORD)v21)
    {
      if (a5)
      {
        memcpy(v21, a4, a5);
        *(_QWORD *)(v20 + 32) += a5;
      }
    }
    else
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)v16[5].__r_.__value_.__r.__words[2], (const char *)a4, a5);
    }
    llvm::raw_ostream::write((llvm::raw_ostream *)v16[5].__r_.__value_.__r.__words[2], v26, 1uLL);
    v22 = sub_1C476B7EC(a1);
    if (v22 != -1)
    {
      for (i = v22; i != -1; i = sub_1C476BA0C((_QWORD *)a1, i + 1, *(_DWORD *)(a1 + 64), 1u))
      {
        *(_QWORD *)v24 = i;
        llvm::raw_ostream::write((llvm::raw_ostream *)v16[5].__r_.__value_.__r.__words[2], v24, 8uLL);
      }
    }
    llvm::raw_ostream::write((llvm::raw_ostream *)v16[5].__r_.__value_.__r.__words[2], v25, 8uLL);
    v16[1].__r_.__value_.__s.__data_[0] = 1;
  }
  *(_QWORD *)v26 = 0;
  sub_1C49C7E54((uint64_t)v26, v16);
  if (SHIBYTE(v40) < 0)
    operator delete(v38);
  if (SHIBYTE(v28) < 0)
    operator delete(__p[0]);
  std::recursive_mutex::unlock(&stru_1ED8259E8);
  return !v19;
}

uint64_t llvm::CodeGenCoverage::reset(uint64_t this)
{
  uint64_t v1;

  if ((*(_DWORD *)(this + 64) & 0x3F) != 0)
  {
    v1 = *(unsigned int *)(this + 8);
    *(_QWORD *)(*(_QWORD *)this + 8 * v1 - 8) &= ~(-1 << (*(_DWORD *)(this + 64) & 0x3F));
  }
  else
  {
    LODWORD(v1) = *(_DWORD *)(this + 8);
  }
  *(_DWORD *)(this + 64) = 0;
  if ((_DWORD)v1)
    *(_DWORD *)(this + 8) = 0;
  return this;
}

uint64_t sub_1C5DD9C78()
{
  MEMORY[0x1CAA32CE4](&stru_1ED8259E8);
  dword_1ED825A28 = 0;
  return __cxa_atexit((void (*)(void *))std::recursive_mutex::~recursive_mutex, &stru_1ED8259E8, &dword_1C475E000);
}

_QWORD *llvm::cl::basic_parser<BOOL>::basic_parser(_QWORD *result)
{
  *result = &unk_1E819DF50;
  return result;
}

{
  *result = &unk_1E819DF50;
  return result;
}

_QWORD *llvm::cl::basic_parser<llvm::cl::BOOLOrDefault>::basic_parser(_QWORD *result)
{
  *result = &unk_1E819DF80;
  return result;
}

{
  *result = &unk_1E819DF80;
  return result;
}

_QWORD *llvm::cl::basic_parser<int>::basic_parser(_QWORD *result)
{
  *result = &unk_1E819DFB0;
  return result;
}

{
  *result = &unk_1E819DFB0;
  return result;
}

_QWORD *llvm::cl::basic_parser<long>::basic_parser(_QWORD *result)
{
  *result = &unk_1E819DFE0;
  return result;
}

{
  *result = &unk_1E819DFE0;
  return result;
}

_QWORD *llvm::cl::basic_parser<long long>::basic_parser(_QWORD *result)
{
  *result = &unk_1E819E010;
  return result;
}

{
  *result = &unk_1E819E010;
  return result;
}

_QWORD *llvm::cl::basic_parser<unsigned int>::basic_parser(_QWORD *result)
{
  *result = &unk_1E819E040;
  return result;
}

{
  *result = &unk_1E819E040;
  return result;
}

_QWORD *llvm::cl::basic_parser<unsigned long>::basic_parser(_QWORD *result)
{
  *result = &unk_1E819E070;
  return result;
}

{
  *result = &unk_1E819E070;
  return result;
}

_QWORD *llvm::cl::basic_parser<unsigned long long>::basic_parser(_QWORD *result)
{
  *result = &unk_1E819E0A0;
  return result;
}

{
  *result = &unk_1E819E0A0;
  return result;
}

_QWORD *llvm::cl::basic_parser<double>::basic_parser(_QWORD *result)
{
  *result = &unk_1E819E0D0;
  return result;
}

{
  *result = &unk_1E819E0D0;
  return result;
}

_QWORD *llvm::cl::basic_parser<float>::basic_parser(_QWORD *result)
{
  *result = &unk_1E819E100;
  return result;
}

{
  *result = &unk_1E819E100;
  return result;
}

_QWORD *llvm::cl::basic_parser<std::string>::basic_parser(_QWORD *result)
{
  *result = &unk_1E819E130;
  return result;
}

{
  *result = &unk_1E819E130;
  return result;
}

_QWORD *llvm::cl::basic_parser<char>::basic_parser(_QWORD *result)
{
  *result = &unk_1E819E160;
  return result;
}

{
  *result = &unk_1E819E160;
  return result;
}

uint64_t llvm::cl::parser<unsigned int>::parse(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6, _DWORD *a7)
{
  llvm *v11;
  uint64_t v12;
  unint64_t v13;
  unsigned __int8 *v14;
  int v15;
  int v16;
  unsigned int v17;
  unint64_t v18;
  uint64_t result;
  llvm::raw_ostream *v20;
  _QWORD v21[4];
  __int16 v22;
  unsigned __int8 *v23;
  uint64_t v24;
  const char *v25;
  __int16 v26;

  v23 = a5;
  v24 = a6;
  v11 = (llvm *)sub_1C5E3D4C0((uint64_t)&v23);
  v12 = v24;
  if (v24)
  {
    v13 = 0;
    v14 = v23;
    while (1)
    {
      v15 = *v14;
      if ((v15 - 48) >= 0xA)
      {
        if ((v15 - 97) >= 0x1A)
        {
          if ((v15 - 65) > 0x19)
            break;
          v16 = -55;
        }
        else
        {
          v16 = -87;
        }
      }
      else
      {
        v16 = -48;
      }
      v17 = v16 + v15;
      if (v17 >= v11)
        break;
      v18 = v13 * v11 + v17;
      if (v18 / v11 < v13)
        break;
      ++v14;
      v13 = v18;
      if (!--v12)
      {
        if (HIDWORD(v18))
          break;
        result = 0;
        *a7 = v18;
        return result;
      }
    }
  }
  v22 = 1283;
  v21[0] = "'";
  v21[2] = a5;
  v21[3] = a6;
  v23 = (unsigned __int8 *)v21;
  v25 = "' value invalid for uint argument!";
  v26 = 770;
  v20 = (llvm::raw_ostream *)llvm::errs(v11);
  llvm::cl::Option::error(a2, (llvm::Twine *)&v23, 0, 0, v20);
  return 1;
}

uint64_t llvm::cl::opt<unsigned int,false,llvm::cl::parser<unsigned int>>::setDefault(uint64_t result)
{
  int v1;

  v1 = *(unsigned __int8 *)(result + 148);
  if (*(_BYTE *)(result + 148))
    v1 = *(_DWORD *)(result + 144);
  *(_DWORD *)(result + 128) = v1;
  return result;
}

void llvm::cl::Option::addArgument(llvm::cl::Option *this)
{
  if (!atomic_load((unint64_t *)&qword_1ED836A48))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1ED836A48, (void *(*)(void))sub_1C5DE673C, (void (*)(void *))sub_1C5DE6840);
  sub_1C5DDAC70(qword_1ED836A48, (uint64_t)this, 0);
  *((_WORD *)this + 5) |= 0x4000u;
}

uint64_t llvm::cl::opt<unsigned int,false,llvm::cl::parser<unsigned int>>::setInitialValue(uint64_t result, _DWORD *a2)
{
  *(_DWORD *)(result + 128) = *a2;
  *(_BYTE *)(result + 148) = 1;
  *(_DWORD *)(result + 144) = *a2;
  return result;
}

uint64_t llvm::cl::opt<unsigned int,false,llvm::cl::parser<unsigned int>>::getParser(uint64_t a1)
{
  return a1 + 152;
}

uint64_t llvm::cl::opt<unsigned int,false,llvm::cl::parser<unsigned int>>::setCallback(uint64_t a1, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t result;
  uint64_t (**v8)(void);
  _QWORD v9[3];
  _QWORD *v10;
  _QWORD v11[4];

  v11[3] = *MEMORY[0x1E0C80C00];
  v3 = (_QWORD *)(a1 + 160);
  v4 = (_QWORD *)a2[3];
  if (v4)
  {
    if (v4 == a2)
    {
      v10 = v9;
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, v9);
    }
    else
    {
      v10 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v4 + 16))(v4);
    }
  }
  else
  {
    v10 = 0;
  }
  if (v9 != v3)
  {
    v5 = v10;
    v6 = *(_QWORD **)(a1 + 184);
    if (v10 == v9)
    {
      if (v6 == v3)
      {
        (*(void (**)(_QWORD *, _QWORD *))(v9[0] + 24))(v9, v11);
        (*(void (**)(_QWORD *))(*v10 + 32))(v10);
        v10 = 0;
        (*(void (**)(_QWORD, _QWORD *))(**(_QWORD **)(a1 + 184) + 24))(*(_QWORD *)(a1 + 184), v9);
        (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 184) + 32))(*(_QWORD *)(a1 + 184));
        *(_QWORD *)(a1 + 184) = 0;
        v10 = v9;
        (*(void (**)(_QWORD *, _QWORD *))(v11[0] + 24))(v11, v3);
        (*(void (**)(_QWORD *))(v11[0] + 32))(v11);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(v9[0] + 24))(v9, v3);
        (*(void (**)(_QWORD *))(*v10 + 32))(v10);
        v10 = *(_QWORD **)(a1 + 184);
      }
      *(_QWORD *)(a1 + 184) = v3;
    }
    else if (v6 == v3)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*(_QWORD *)(a1 + 160) + 24))(v3, v9);
      (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 184) + 32))(*(_QWORD *)(a1 + 184));
      *(_QWORD *)(a1 + 184) = v10;
      v10 = v9;
    }
    else
    {
      v10 = *(_QWORD **)(a1 + 184);
      *(_QWORD *)(a1 + 184) = v5;
    }
  }
  result = (uint64_t)v10;
  if (v10 == v9)
  {
    v8 = (uint64_t (**)(void))(v9[0] + 32);
  }
  else
  {
    if (!v10)
      return result;
    v8 = (uint64_t (**)(void))(*v10 + 40);
  }
  return (*v8)();
}

uint64_t llvm::cl::opt<int,false,llvm::cl::parser<int>>::setDefault(uint64_t result)
{
  int v1;

  v1 = *(unsigned __int8 *)(result + 148);
  if (*(_BYTE *)(result + 148))
    v1 = *(_DWORD *)(result + 144);
  *(_DWORD *)(result + 128) = v1;
  return result;
}

uint64_t llvm::cl::opt<int,false,llvm::cl::parser<int>>::setInitialValue(uint64_t result, _DWORD *a2)
{
  *(_DWORD *)(result + 128) = *a2;
  *(_BYTE *)(result + 148) = 1;
  *(_DWORD *)(result + 144) = *a2;
  return result;
}

uint64_t llvm::cl::opt<int,false,llvm::cl::parser<int>>::getParser(uint64_t a1)
{
  return a1 + 152;
}

_QWORD *llvm::cl::opt<int,false,llvm::cl::parser<int>>::setCallback(uint64_t a1, _QWORD *a2)
{
  return sub_1C624578C((_QWORD *)(a1 + 160), a2);
}

uint64_t llvm::cl::opt<std::string,false,llvm::cl::parser<std::string>>::handleOccurrence(uint64_t a1, __int16 a2, int a3, int a4, void *__src, size_t __len)
{
  std::string *p_dst;
  size_t v11;
  size_t v12;
  uint64_t v13;
  std::string __p;
  std::string __dst;

  memset(&__p, 0, sizeof(__p));
  if (!__src)
  {
    memset(&__dst, 0, sizeof(__dst));
    goto LABEL_13;
  }
  if (__len >= 0x7FFFFFFFFFFFFFF8)
    goto LABEL_18;
  if (__len >= 0x17)
  {
    v11 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v11 = __len | 7;
    v12 = v11 + 1;
    p_dst = (std::string *)operator new(v11 + 1);
    __dst.__r_.__value_.__l.__size_ = __len;
    __dst.__r_.__value_.__r.__words[2] = v12 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_10;
  }
  *((_BYTE *)&__dst.__r_.__value_.__s + 23) = __len;
  p_dst = &__dst;
  if (__len)
LABEL_10:
    memmove(p_dst, __src, __len);
  p_dst->__r_.__value_.__s.__data_[__len] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
LABEL_13:
  __p = __dst;
  std::string::operator=((std::string *)(a1 + 128), &__p);
  *(_WORD *)(a1 + 12) = a2;
  v13 = *(_QWORD *)(a1 + 224);
  if (!v13)
  {
    sub_1C485C2F0();
LABEL_18:
    abort();
  }
  (*(void (**)(uint64_t, std::string *))(*(_QWORD *)v13 + 48))(v13, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return 0;
}

void llvm::cl::opt<std::string,false,llvm::cl::parser<std::string>>::setDefault(uint64_t a1)
{
  std::string *v2;
  std::string __str;

  v2 = (std::string *)(a1 + 128);
  if (*(_BYTE *)(a1 + 184))
  {
    std::string::operator=(v2, (const std::string *)(a1 + 160));
  }
  else
  {
    memset(&__str, 0, sizeof(__str));
    std::string::operator=(v2, &__str);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__str.__r_.__value_.__l.__data_);
  }
}

std::string *llvm::cl::opt<std::string,false,llvm::cl::parser<std::string>>::setInitialValue(uint64_t a1, const std::string *a2)
{
  std::string::operator=((std::string *)(a1 + 128), a2);
  *(_BYTE *)(a1 + 184) = 1;
  return std::string::operator=((std::string *)(a1 + 160), a2);
}

uint64_t llvm::cl::opt<std::string,false,llvm::cl::parser<std::string>>::getParser(uint64_t a1)
{
  return a1 + 192;
}

uint64_t llvm::cl::opt<std::string,false,llvm::cl::parser<std::string>>::setCallback(uint64_t a1, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t result;
  uint64_t (**v8)(void);
  _QWORD v9[3];
  _QWORD *v10;
  _QWORD v11[4];

  v11[3] = *MEMORY[0x1E0C80C00];
  v3 = (_QWORD *)(a1 + 200);
  v4 = (_QWORD *)a2[3];
  if (v4)
  {
    if (v4 == a2)
    {
      v10 = v9;
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, v9);
    }
    else
    {
      v10 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v4 + 16))(v4);
    }
  }
  else
  {
    v10 = 0;
  }
  if (v9 != v3)
  {
    v5 = v10;
    v6 = *(_QWORD **)(a1 + 224);
    if (v10 == v9)
    {
      if (v6 == v3)
      {
        (*(void (**)(_QWORD *, _QWORD *))(v9[0] + 24))(v9, v11);
        (*(void (**)(_QWORD *))(*v10 + 32))(v10);
        v10 = 0;
        (*(void (**)(_QWORD, _QWORD *))(**(_QWORD **)(a1 + 224) + 24))(*(_QWORD *)(a1 + 224), v9);
        (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224));
        *(_QWORD *)(a1 + 224) = 0;
        v10 = v9;
        (*(void (**)(_QWORD *, _QWORD *))(v11[0] + 24))(v11, v3);
        (*(void (**)(_QWORD *))(v11[0] + 32))(v11);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(v9[0] + 24))(v9, v3);
        (*(void (**)(_QWORD *))(*v10 + 32))(v10);
        v10 = *(_QWORD **)(a1 + 224);
      }
      *(_QWORD *)(a1 + 224) = v3;
    }
    else if (v6 == v3)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*(_QWORD *)(a1 + 200) + 24))(v3, v9);
      (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224));
      *(_QWORD *)(a1 + 224) = v10;
      v10 = v9;
    }
    else
    {
      v10 = *(_QWORD **)(a1 + 224);
      *(_QWORD *)(a1 + 224) = v5;
    }
  }
  result = (uint64_t)v10;
  if (v10 == v9)
  {
    v8 = (uint64_t (**)(void))(v9[0] + 32);
  }
  else
  {
    if (!v10)
      return result;
    v8 = (uint64_t (**)(void))(*v10 + 40);
  }
  return (*v8)();
}

uint64_t llvm::cl::opt<char,false,llvm::cl::parser<char>>::handleOccurrence(uint64_t a1, __int16 a2, uint64_t a3, uint64_t a4, char *a5)
{
  uint64_t v5;
  char v7;

  v7 = *a5;
  *(_BYTE *)(a1 + 128) = v7;
  *(_WORD *)(a1 + 12) = a2;
  v5 = *(_QWORD *)(a1 + 184);
  if (v5)
  {
    (*(void (**)(uint64_t, char *))(*(_QWORD *)v5 + 48))(v5, &v7);
    return 0;
  }
  else
  {
    sub_1C485C2F0();
    return llvm::cl::opt<char,false,llvm::cl::parser<char>>::getValueExpectedFlagDefault();
  }
}

uint64_t llvm::cl::opt<char,false,llvm::cl::parser<char>>::getValueExpectedFlagDefault()
{
  return 2;
}

uint64_t llvm::cl::opt<char,false,llvm::cl::parser<char>>::getOptionWidth(uint64_t a1)
{
  return llvm::cl::basic_parser_impl::getOptionWidth(a1 + 152, a1);
}

llvm::raw_ostream *llvm::cl::opt<char,false,llvm::cl::parser<char>>::printOptionInfo(uint64_t a1, unsigned int a2)
{
  return llvm::cl::basic_parser_impl::printOptionInfo((llvm::cl::basic_parser_impl *)(a1 + 152), (const llvm::cl::Option *)a1, a2);
}

void llvm::cl::opt<char,false,llvm::cl::parser<char>>::printOptionValue(uint64_t a1, int a2, int a3)
{
  int v3;
  uint64_t (**v4)();
  __int16 v5;

  if (a3)
  {
    LOBYTE(v3) = *(_BYTE *)(a1 + 128);
LABEL_5:
    v5 = *(_WORD *)(a1 + 144);
    v4 = &off_1E819E878;
    llvm::cl::parser<char>::printOptionDiff((llvm::cl::basic_parser_impl *)a1, (const llvm::cl::Option *)a1, v3, (uint64_t)&v4, a2);
    return;
  }
  if (*(_BYTE *)(a1 + 145))
  {
    v3 = *(unsigned __int8 *)(a1 + 128);
    if (*(unsigned __int8 *)(a1 + 144) != v3)
      goto LABEL_5;
  }
}

_BYTE *llvm::cl::opt<char,false,llvm::cl::parser<char>>::setDefault(_BYTE *result)
{
  char v1;

  v1 = result[145];
  if (v1)
    v1 = result[144];
  result[128] = v1;
  return result;
}

_BYTE *llvm::cl::opt<char,false,llvm::cl::parser<char>>::setInitialValue(_BYTE *result, _BYTE *a2)
{
  result[128] = *a2;
  result[145] = 1;
  result[144] = *a2;
  return result;
}

uint64_t llvm::cl::opt<char,false,llvm::cl::parser<char>>::getParser(uint64_t a1)
{
  return a1 + 152;
}

uint64_t llvm::cl::opt<char,false,llvm::cl::parser<char>>::setCallback(uint64_t a1, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t result;
  uint64_t (**v8)(void);
  _QWORD v9[3];
  _QWORD *v10;
  _QWORD v11[4];

  v11[3] = *MEMORY[0x1E0C80C00];
  v3 = (_QWORD *)(a1 + 160);
  v4 = (_QWORD *)a2[3];
  if (v4)
  {
    if (v4 == a2)
    {
      v10 = v9;
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, v9);
    }
    else
    {
      v10 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v4 + 16))(v4);
    }
  }
  else
  {
    v10 = 0;
  }
  if (v9 != v3)
  {
    v5 = v10;
    v6 = *(_QWORD **)(a1 + 184);
    if (v10 == v9)
    {
      if (v6 == v3)
      {
        (*(void (**)(_QWORD *, _QWORD *))(v9[0] + 24))(v9, v11);
        (*(void (**)(_QWORD *))(*v10 + 32))(v10);
        v10 = 0;
        (*(void (**)(_QWORD, _QWORD *))(**(_QWORD **)(a1 + 184) + 24))(*(_QWORD *)(a1 + 184), v9);
        (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 184) + 32))(*(_QWORD *)(a1 + 184));
        *(_QWORD *)(a1 + 184) = 0;
        v10 = v9;
        (*(void (**)(_QWORD *, _QWORD *))(v11[0] + 24))(v11, v3);
        (*(void (**)(_QWORD *))(v11[0] + 32))(v11);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(v9[0] + 24))(v9, v3);
        (*(void (**)(_QWORD *))(*v10 + 32))(v10);
        v10 = *(_QWORD **)(a1 + 184);
      }
      *(_QWORD *)(a1 + 184) = v3;
    }
    else if (v6 == v3)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*(_QWORD *)(a1 + 160) + 24))(v3, v9);
      (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 184) + 32))(*(_QWORD *)(a1 + 184));
      *(_QWORD *)(a1 + 184) = v10;
      v10 = v9;
    }
    else
    {
      v10 = *(_QWORD **)(a1 + 184);
      *(_QWORD *)(a1 + 184) = v5;
    }
  }
  result = (uint64_t)v10;
  if (v10 == v9)
  {
    v8 = (uint64_t (**)(void))(v9[0] + 32);
  }
  else
  {
    if (!v10)
      return result;
    v8 = (uint64_t (**)(void))(*v10 + 40);
  }
  return (*v8)();
}

_BYTE *llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>::setDefault(_BYTE *result)
{
  char v1;

  v1 = result[145];
  if (v1)
    v1 = result[144];
  result[128] = v1;
  return result;
}

_BYTE *llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>::setInitialValue(_BYTE *result, _BYTE *a2)
{
  result[128] = *a2;
  result[145] = 1;
  result[144] = *a2;
  return result;
}

uint64_t llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>::getParser(uint64_t a1)
{
  return a1 + 152;
}

_QWORD *llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>::setCallback(uint64_t a1, _QWORD *a2)
{
  return sub_1C4D7BD48((_QWORD *)(a1 + 160), a2);
}

void llvm::cl::AddLiteralOption(uint64_t a1, unsigned __int8 *a2, size_t a3)
{
  size_t v3;
  unsigned __int8 *v4;
  uint64_t v5;
  uint64_t *v7;
  unsigned int v8;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t *i;
  size_t v16;
  unsigned __int8 *v17;
  uint64_t *v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  size_t v22;
  unsigned __int8 *v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v27;
  uint64_t v28;

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if (!atomic_load((unint64_t *)&qword_1ED836A48))
  {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1ED836A48, (void *(*)(void))sub_1C5DE673C, (void (*)(void *))sub_1C5DE6840);
    v5 = a1;
    v4 = a2;
    v3 = a3;
  }
  v7 = (uint64_t *)qword_1ED836A48;
  v8 = *(_DWORD *)(v5 + 108);
  if (v8 == *(_DWORD *)(v5 + 112))
  {
    if (!atomic_load(llvm::cl::TopLevelSubCommand))
    {
      v25 = qword_1ED836A48;
      v28 = v5;
      v16 = v3;
      v17 = v4;
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)llvm::cl::TopLevelSubCommand, (void *(*)(void))sub_1C6386064, (void (*)(void *))sub_1C63860D8);
      v7 = (uint64_t *)v25;
      v5 = v28;
      v4 = v17;
      v3 = v16;
    }
    sub_1C5DE38FC(v7, v5, llvm::cl::TopLevelSubCommand[0], v4, v3);
  }
  else
  {
    v23 = v4;
    v24 = (uint64_t *)qword_1ED836A48;
    v22 = v3;
    v13 = *(uint64_t **)(v5 + 88);
    v12 = *(uint64_t **)(v5 + 96);
    v27 = v5;
    LODWORD(v5) = *(_DWORD *)(v5 + 104);
    if (v12 == v13)
      v5 = v8;
    else
      v5 = v5;
    if ((_DWORD)v5)
    {
      v14 = 8 * v5;
      for (i = v12; (unint64_t)*i >= 0xFFFFFFFFFFFFFFFELL; ++i)
      {
        v14 -= 8;
        if (!v14)
          return;
      }
    }
    else
    {
      i = v12;
    }
    v18 = &v12[v5];
    if (i != v18)
    {
      v19 = *i;
LABEL_18:
      sub_1C5DE38FC(v24, v27, v19, v23, v22);
      v20 = (unint64_t *)(i + 1);
      while (v20 != (unint64_t *)v18)
      {
        v21 = *v20++;
        v19 = v21;
        if (v21 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          i = (uint64_t *)(v20 - 1);
          goto LABEL_18;
        }
      }
    }
  }
}

_QWORD *llvm::cl::extrahelp::extrahelp(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v7;
  unint64_t v8;
  char *v9;
  _QWORD *v10;
  char *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;

  *a1 = a2;
  a1[1] = a3;
  if (!atomic_load((unint64_t *)&qword_1ED836A48))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1ED836A48, (void *(*)(void))sub_1C5DE673C, (void (*)(void *))sub_1C5DE6840);
  v7 = (_QWORD *)qword_1ED836A48;
  v9 = *(char **)(qword_1ED836A48 + 48);
  v8 = *(_QWORD *)(qword_1ED836A48 + 56);
  if ((unint64_t)v9 >= v8)
  {
    v11 = *(char **)(qword_1ED836A48 + 40);
    v12 = (v9 - v11) >> 4;
    v13 = v12 + 1;
    if ((unint64_t)(v12 + 1) >> 60)
      abort();
    v14 = v8 - (_QWORD)v11;
    if (v14 >> 3 > v13)
      v13 = v14 >> 3;
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0)
      v15 = 0xFFFFFFFFFFFFFFFLL;
    else
      v15 = v13;
    if (v15)
    {
      if (v15 >> 60)
        sub_1C4764EE4();
      v16 = (char *)operator new(16 * v15);
    }
    else
    {
      v16 = 0;
    }
    v17 = &v16[16 * v12];
    *(_QWORD *)v17 = a2;
    *((_QWORD *)v17 + 1) = a3;
    v10 = v17 + 16;
    if (v9 != v11)
    {
      do
      {
        *((_OWORD *)v17 - 1) = *((_OWORD *)v9 - 1);
        v17 -= 16;
        v9 -= 16;
      }
      while (v9 != v11);
      v9 = (char *)v7[5];
    }
    v7[5] = v17;
    v7[6] = v10;
    v7[7] = &v16[16 * v15];
    if (v9)
      operator delete(v9);
  }
  else
  {
    *(_QWORD *)v9 = a2;
    *((_QWORD *)v9 + 1) = a3;
    v10 = v9 + 16;
  }
  v7[6] = v10;
  return a1;
}

void sub_1C5DDAC70(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *i;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;

  if ((a3 & 1) == 0 && (*(_WORD *)(a2 + 10) & 0x2000) != 0)
  {
    v11 = *(unsigned int *)(a1 + 72);
    if (v11 >= *(_DWORD *)(a1 + 76))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 64, a1 + 80, v11 + 1, 8);
      LODWORD(v11) = *(_DWORD *)(a1 + 72);
    }
    *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v11) = a2;
    ++*(_DWORD *)(a1 + 72);
  }
  else if (*(_DWORD *)(a2 + 108) == *(_DWORD *)(a2 + 112))
  {
    if (!atomic_load(llvm::cl::TopLevelSubCommand))
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)llvm::cl::TopLevelSubCommand, (void *(*)(void))sub_1C6386064, (void (*)(void *))sub_1C63860D8);
    sub_1C5DE3C90(a1, a2, llvm::cl::TopLevelSubCommand[0]);
  }
  else
  {
    v6 = *(_QWORD *)(a2 + 96);
    v7 = 104;
    if (v6 == *(_QWORD *)(a2 + 88))
      v7 = 108;
    v8 = *(unsigned int *)(a2 + v7);
    if ((_DWORD)v8)
    {
      v9 = 8 * v8;
      for (i = *(uint64_t **)(a2 + 96); (unint64_t)*i >= 0xFFFFFFFFFFFFFFFELL; ++i)
      {
        v9 -= 8;
        if (!v9)
          return;
      }
    }
    else
    {
      i = *(uint64_t **)(a2 + 96);
    }
    v12 = (_QWORD *)(v6 + 8 * v8);
    if (i != v12)
    {
      v13 = *i;
LABEL_20:
      sub_1C5DE3C90(a1, a2, v13);
      v14 = (unint64_t *)(i + 1);
      while (v14 != v12)
      {
        v15 = *v14++;
        v13 = v15;
        if (v15 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          i = (uint64_t *)(v14 - 1);
          goto LABEL_20;
        }
      }
    }
  }
}

uint64_t llvm::cl::Option::setArgStr(uint64_t result, unsigned __int8 *a2, size_t a3)
{
  uint64_t *v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  unsigned __int8 *v24;
  size_t v25;
  uint64_t v26;

  if ((*(_WORD *)(result + 10) & 0x4000) != 0)
  {
    v24 = a2;
    v25 = a3;
    v26 = result;
    if (!atomic_load((unint64_t *)&qword_1ED836A48))
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1ED836A48, (void *(*)(void))sub_1C5DE673C, (void (*)(void *))sub_1C5DE6840);
    v4 = (uint64_t *)qword_1ED836A48;
    if (*(_DWORD *)(v26 + 108) == *(_DWORD *)(v26 + 112))
    {
      if (!atomic_load(llvm::cl::TopLevelSubCommand))
        llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)llvm::cl::TopLevelSubCommand, (void *(*)(void))sub_1C6386064, (void (*)(void *))sub_1C63860D8);
      sub_1C5DE4490(v4, v26, v24, v25, llvm::cl::TopLevelSubCommand[0]);
      a2 = v24;
      a3 = v25;
      result = v26;
    }
    else if (sub_1C638615C(v26))
    {
      v6 = v4[35];
      v7 = 288;
      if (v6 == v4[34])
        v7 = 292;
      v8 = *(unsigned int *)((char *)v4 + v7);
      if ((_DWORD)v8)
      {
        v9 = 8 * v8;
        v10 = (uint64_t *)v4[35];
        a3 = v25;
        result = v26;
        a2 = v24;
        while ((unint64_t)*v10 >= 0xFFFFFFFFFFFFFFFELL)
        {
          ++v10;
          v9 -= 8;
          if (!v9)
            goto LABEL_2;
        }
      }
      else
      {
        v10 = (uint64_t *)v4[35];
      }
      v16 = (_QWORD *)(v6 + 8 * v8);
      a3 = v25;
      result = v26;
      a2 = v24;
      if (v10 != v16)
      {
        v17 = *v10;
LABEL_29:
        sub_1C5DE4490(v4, v26, v24, v25, v17);
        v18 = (unint64_t *)(v10 + 1);
        while (1)
        {
          a3 = v25;
          result = v26;
          a2 = v24;
          if (v18 == v16)
            break;
          v19 = *v18++;
          v17 = v19;
          if (v19 <= 0xFFFFFFFFFFFFFFFDLL)
          {
            v10 = (uint64_t *)(v18 - 1);
            goto LABEL_29;
          }
        }
      }
    }
    else
    {
      v11 = *(_QWORD *)(v26 + 96);
      v12 = 104;
      if (v11 == *(_QWORD *)(v26 + 88))
        v12 = 108;
      v13 = *(unsigned int *)(v26 + v12);
      if ((_DWORD)v13)
      {
        v14 = 8 * v13;
        v15 = *(uint64_t **)(v26 + 96);
        a3 = v25;
        result = v26;
        a2 = v24;
        while ((unint64_t)*v15 >= 0xFFFFFFFFFFFFFFFELL)
        {
          ++v15;
          v14 -= 8;
          if (!v14)
            goto LABEL_2;
        }
      }
      else
      {
        v15 = *(uint64_t **)(v26 + 96);
      }
      v20 = (_QWORD *)(v11 + 8 * v13);
      a3 = v25;
      result = v26;
      a2 = v24;
      if (v15 != v20)
      {
        v21 = *v15;
LABEL_36:
        sub_1C5DE4490(v4, v26, v24, v25, v21);
        v22 = (unint64_t *)(v15 + 1);
        while (1)
        {
          a3 = v25;
          result = v26;
          a2 = v24;
          if (v22 == v20)
            break;
          v23 = *v22++;
          v21 = v23;
          if (v23 <= 0xFFFFFFFFFFFFFFFDLL)
          {
            v15 = (uint64_t *)(v22 - 1);
            goto LABEL_36;
          }
        }
      }
    }
  }
LABEL_2:
  *(_QWORD *)(result + 16) = a2;
  *(_QWORD *)(result + 24) = a3;
  if (a3 == 1)
    *(_WORD *)(result + 10) |= 0x1000u;
  return result;
}

void *llvm::cl::Option::addCategory(llvm::cl::Option *this, llvm::cl::OptionCategory *a2)
{
  uint64_t *GeneralCategory;
  uint64_t *v5;
  void *result;
  llvm::cl::OptionCategory **v7;
  uint64_t v8;
  llvm::cl::OptionCategory **v9;
  uint64_t v10;

  GeneralCategory = llvm::cl::getGeneralCategory(this);
  if (a2 == (llvm::cl::OptionCategory *)&qword_1ED836A20
    || (v5 = (uint64_t *)**((_QWORD **)this + 8),
        result = llvm::cl::getGeneralCategory((llvm::cl *)GeneralCategory),
        v5 != &qword_1ED836A20))
  {
    result = (char *)this + 64;
    v7 = (llvm::cl::OptionCategory **)*((_QWORD *)this + 8);
    v8 = *((unsigned int *)this + 18);
    v9 = v7;
    if ((_DWORD)v8)
    {
      v10 = 8 * v8;
      v9 = (llvm::cl::OptionCategory **)*((_QWORD *)this + 8);
      while (*v9 != a2)
      {
        ++v9;
        v10 -= 8;
        if (!v10)
        {
          v9 = &v7[v8];
          break;
        }
      }
    }
    if (v8 == v9 - v7)
    {
      if (v8 >= *((_DWORD *)this + 19))
      {
        result = llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)result, (uint64_t)this + 80, v8 + 1, 8);
        v7 = (llvm::cl::OptionCategory **)*((_QWORD *)this + 8);
        v8 = *((unsigned int *)this + 18);
      }
      v7[v8] = a2;
      ++*((_DWORD *)this + 18);
    }
  }
  else
  {
    **((_QWORD **)this + 8) = a2;
  }
  return result;
}

uint64_t *llvm::cl::getGeneralCategory(llvm::cl *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&qword_1ED836A40);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_1ED836A40))
  {
    qword_1ED836A20 = (uint64_t)"General options";
    *(_QWORD *)algn_1ED836A28 = 15;
    qword_1ED836A30 = (uint64_t)&unk_1C876C4D5;
    unk_1ED836A38 = 0;
    llvm::cl::OptionCategory::registerCategory((llvm::cl::OptionCategory *)&qword_1ED836A20);
    __cxa_guard_release(&qword_1ED836A40);
  }
  return &qword_1ED836A20;
}

void llvm::cl::Option::reset(llvm::cl::Option *this)
{
  *((_WORD *)this + 4) = 0;
  (*(void (**)(llvm::cl::Option *))(*(_QWORD *)this + 64))(this);
  if ((*((_WORD *)this + 5) & 0x2000) != 0)
    llvm::cl::Option::removeArgument(this);
}

void llvm::cl::SubCommand::registerSubCommand(llvm::cl::SubCommand *this)
{
  if (!atomic_load((unint64_t *)&qword_1ED836A48))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1ED836A48, (void *(*)(void))sub_1C5DE673C, (void (*)(void *))sub_1C5DE6840);
  sub_1C5DDB1E0((uint64_t *)qword_1ED836A48, (uint64_t)this);
}

void sub_1C5DDB1E0(uint64_t *a1, uint64_t a2)
{
  uint64_t v6;
  uint64_t *i;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int16 v12;
  int v13;
  int v14;
  BOOL v15;
  uint64_t v16;
  BOOL v17;

  sub_1C4774094((llvm::SmallPtrSetImplBase *)(a1 + 34), a2);
  if (!atomic_load((unint64_t *)&llvm::cl::AllSubCommands))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&llvm::cl::AllSubCommands, (void *(*)(void))sub_1C6386064, (void (*)(void *))sub_1C63860D8);
  if (llvm::cl::AllSubCommands != a2)
  {
    if (!atomic_load((unint64_t *)&llvm::cl::AllSubCommands))
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&llvm::cl::AllSubCommands, (void *(*)(void))sub_1C6386064, (void (*)(void *))sub_1C63860D8);
    v6 = *(unsigned int *)(llvm::cl::AllSubCommands + 136);
    if ((_DWORD)v6)
    {
      for (i = *(uint64_t **)(llvm::cl::AllSubCommands + 128); !*i || *i == -8; ++i)
        ;
    }
    else
    {
      i = *(uint64_t **)(llvm::cl::AllSubCommands + 128);
    }
    v9 = *(_QWORD *)(llvm::cl::AllSubCommands + 128) + 8 * v6;
    if (i != (uint64_t *)v9)
    {
      v10 = *i;
      do
      {
        v11 = *(_QWORD *)(v10 + 8);
        v12 = *(_WORD *)(v11 + 10);
        if ((v12 & 7) == 4
          || ((v13 = v12 & 0x180, v14 = v12 & 0x800, v13 != 128) ? (v15 = v14 == 0) : (v15 = 0),
              !v15 || *(_QWORD *)(v11 + 24)))
        {
          sub_1C5DE3C90((uint64_t)a1, v11, a2);
        }
        else
        {
          sub_1C5DE38FC(a1, v11, a2, (unsigned __int8 *)(v10 + 16), *(_QWORD *)v10);
        }
        do
        {
          v16 = i[1];
          ++i;
          v10 = v16;
          if (v16)
            v17 = v10 == -8;
          else
            v17 = 1;
        }
        while (v17);
      }
      while (i != (uint64_t *)v9);
    }
  }
}

_QWORD *llvm::cl::SubCommand::unregisterSubCommand(llvm::cl::SubCommand *this)
{
  uint64_t v3;
  _QWORD *result;
  uint64_t v5;
  uint64_t v6;

  if (!atomic_load((unint64_t *)&qword_1ED836A48))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1ED836A48, (void *(*)(void))sub_1C5DE673C, (void (*)(void *))sub_1C5DE6840);
  v3 = qword_1ED836A48;
  result = sub_1C477672C(qword_1ED836A48 + 272, (uint64_t)this);
  v5 = *(_QWORD *)(v3 + 280);
  v6 = 288;
  if (v5 == *(_QWORD *)(v3 + 272))
    v6 = 292;
  if (result != (_QWORD *)(v5 + 8 * *(unsigned int *)(v3 + v6)))
  {
    *result = -2;
    ++*(_DWORD *)(v3 + 296);
  }
  return result;
}

uint64_t llvm::cl::SubCommand::reset(llvm::cl::SubCommand *this)
{
  uint64_t result;

  *((_DWORD *)this + 10) = 0;
  *((_DWORD *)this + 22) = 0;
  result = sub_1C62A23BC((uint64_t)this + 128);
  *((_QWORD *)this + 20) = 0;
  return result;
}

BOOL llvm::cl::SubCommand::operator BOOL(uint64_t a1)
{
  if (!atomic_load((unint64_t *)&qword_1ED836A48))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1ED836A48, (void *(*)(void))sub_1C5DE673C, (void (*)(void *))sub_1C5DE6840);
  return *(_QWORD *)(qword_1ED836A48 + 336) == a1;
}

uint64_t llvm::cl::ProvidePositionalOption(uint64_t a1, _BYTE *a2, size_t a3, int a4)
{
  int v5;

  v5 = a4;
  return sub_1C5DDB478((unsigned __int16 *)a1, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), a2, a3, 0, 0, &v5);
}

uint64_t sub_1C5DDB478(unsigned __int16 *a1, uint64_t a2, uint64_t a3, _BYTE *__s, size_t __n, int a6, uint64_t a7, _DWORD *a8)
{
  int v16;
  uint64_t result;
  char v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  _BYTE *v24;
  size_t v25;
  const char *v26;
  __int16 v27;
  llvm::raw_ostream *v28;
  _QWORD v29[4];
  __int16 v30;
  _QWORD v31[4];
  __int16 v32;

  v16 = a1[7];
  result = (a1[5] >> 3) & 3;
  if (!(_DWORD)result)
    result = (*(uint64_t (**)(unsigned __int16 *))(*(_QWORD *)a1 + 8))(a1);
  if ((_DWORD)result == 3)
  {
    if (!v16)
    {
      if (__s)
      {
        v29[0] = "does not allow a value! '";
        v29[2] = __s;
        v29[3] = __n;
        v30 = 1283;
        v31[0] = v29;
        v31[2] = "' specified.";
        v27 = 770;
LABEL_35:
        v32 = v27;
        v28 = (llvm::raw_ostream *)llvm::errs((llvm *)result);
        llvm::cl::Option::error(a1, (llvm::Twine *)v31, 0, 0, v28);
        return 1;
      }
      return sub_1C5DE46E0(a1, *a8, a2, a3, __s, __n, 0);
    }
    v26 = "multi-valued option specified with ValueDisallowed modifier!";
LABEL_34:
    v31[0] = v26;
    v27 = 259;
    goto LABEL_35;
  }
  if ((_DWORD)result != 2 || __s)
  {
    if (v16)
      goto LABEL_7;
    return sub_1C5DE46E0(a1, *a8, a2, a3, __s, __n, 0);
  }
  v19 = (int)*a8 + 1;
  if ((int)v19 >= a6 || (~a1[5] & 0x180) == 0)
  {
    v26 = "requires a value!";
    goto LABEL_34;
  }
  *a8 = v19;
  __s = *(_BYTE **)(a7 + 8 * v19);
  if (!__s)
  {
    if (v16)
      goto LABEL_20;
    __n = 0;
    __s = 0;
    return sub_1C5DE46E0(a1, *a8, a2, a3, __s, __n, 0);
  }
  result = strlen(*(const char **)(a7 + 8 * v19));
  __n = result;
  if (!v16)
    return sub_1C5DE46E0(a1, *a8, a2, a3, __s, __n, 0);
LABEL_7:
  if (!__s)
  {
LABEL_20:
    v18 = 0;
LABEL_21:
    v20 = v16 - 1;
    while (1)
    {
      v21 = v20;
      v22 = (int)*a8;
      v23 = v22 + 1;
      if ((int)v22 + 1 >= a6)
        break;
      *a8 = v23;
      v24 = *(_BYTE **)(a7 + 8 * v23);
      if (v24)
        v25 = strlen(*(const char **)(a7 + 8 * v23));
      else
        v25 = 0;
      result = sub_1C5DE46E0(a1, v23, a2, a3, v24, v25, v18 & 1);
      if ((result & 1) == 0)
      {
        v20 = v21 - 1;
        v18 = 1;
        if (v21)
          continue;
      }
      return result;
    }
    v26 = "not enough values!";
    goto LABEL_34;
  }
  result = sub_1C5DE46E0(a1, *a8, a2, a3, __s, __n, 0);
  if ((result & 1) == 0)
  {
    --v16;
    v18 = 1;
    if (!v16)
      return 0;
    goto LABEL_21;
  }
  return 1;
}

void sub_1C5DDB6D0(uint64_t a1, unint64_t a2, uint64_t *a3, void (*a4)(uint64_t, _BYTE *, size_t), uint64_t a5, int a6, void (*a7)(uint64_t), uint64_t a8)
{
  int v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  size_t v17;
  void *v18;
  _BYTE *v19;
  _BYTE *v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  size_t v24;
  uint64_t v25;
  unsigned int v26;
  BOOL v27;
  int v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  _BYTE *v32;
  uint64_t v33;
  size_t v34;
  _BYTE *v35;
  size_t v36;
  uint64_t v37;
  size_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  _QWORD *v42;
  size_t v43;
  _BYTE *v44;
  _BYTE *v45;
  unint64_t v46;
  int v47;
  size_t v48;
  size_t v49;
  unint64_t v51;
  void *v55;
  __int128 v56;
  _QWORD v57[18];

  v57[16] = *MEMORY[0x1E0C80C00];
  v55 = v57;
  v56 = xmmword_1C85F20B0;
  if (!a2)
    return;
  v12 = 0;
  v13 = 0;
  v51 = a2 - 1;
  do
  {
    if (v12 == 2)
    {
      v21 = *(unsigned __int8 *)(a1 + v13);
      if (v21 == 92)
      {
        v13 = sub_1C5DE4800(a1, a2, v13, &v55);
      }
      else
      {
        if (v21 == 34)
        {
          if (v13 >= v51 || *(_BYTE *)(a1 + v13 + 1) != 34)
            goto LABEL_39;
          v22 = v56;
          if ((unint64_t)(v56 + 1) > *((_QWORD *)&v56 + 1))
          {
            llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v55, v57, v56 + 1, 1);
            v22 = v56;
          }
          *((_BYTE *)v55 + v22) = 34;
          *(_QWORD *)&v56 = v56 + 1;
          v12 = 2;
          ++v13;
          goto LABEL_40;
        }
        v23 = v56;
        if ((unint64_t)(v56 + 1) > *((_QWORD *)&v56 + 1))
        {
          llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v55, v57, v56 + 1, 1);
          v23 = v56;
        }
        *((_BYTE *)v55 + v23) = v21;
        v24 = v56 + 1;
LABEL_31:
        *(_QWORD *)&v56 = v24;
      }
LABEL_33:
      v12 = 2;
      goto LABEL_40;
    }
    if (v12 == 1)
    {
      v16 = *(unsigned __int8 *)(a1 + v13);
      if (v16 <= 0x22)
      {
        if (((1 << v16) & 0x100002601) != 0)
        {
          v18 = v55;
          v17 = v56;
          v19 = (_BYTE *)sub_1C484358C(*a3, v56 + 1, 0);
          v20 = v19;
          if (v17)
            memcpy(v19, v18, v17);
          v20[v17] = 0;
          a4(a5, v20, v17);
          *(_QWORD *)&v56 = 0;
          if (*(_BYTE *)(a1 + v13) != 10)
            goto LABEL_19;
LABEL_18:
          a7(a8);
LABEL_19:
          v12 = 0;
          goto LABEL_40;
        }
        if (v16 == 34)
          goto LABEL_33;
      }
      if ((_DWORD)v16 == 92)
        goto LABEL_35;
      v25 = v56;
      if ((unint64_t)(v56 + 1) > *((_QWORD *)&v56 + 1))
      {
        llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v55, v57, v56 + 1, 1);
        v25 = v56;
      }
      *((_BYTE *)v55 + v25) = v16;
      *(_QWORD *)&v56 = v56 + 1;
LABEL_39:
      v12 = 1;
      goto LABEL_40;
    }
    if (v13 >= a2)
      goto LABEL_19;
    v14 = v13;
    while (1)
    {
      v15 = *(unsigned __int8 *)(a1 + v14);
      if (v15 > 0x20)
        break;
      if (((1 << v15) & 0x100002201) == 0)
      {
        if (v15 != 10)
          break;
        a7(a8);
      }
      if (a2 == ++v14)
      {
        v12 = 0;
        v13 = a2;
        goto LABEL_40;
      }
    }
    v13 = v14;
    if (v14 >= a2)
    {
      v28 = 0;
      v13 = v14;
    }
    else
    {
      while (1)
      {
        v26 = *(unsigned __int8 *)(a1 + v13);
        v27 = v26 > 0x22 || ((1 << v26) & 0x500002601) == 0;
        if (!v27 || v26 == 92)
          break;
        if (++v13 >= a2)
        {
          v28 = 0;
          v13 = a2;
          goto LABEL_53;
        }
      }
      v28 = 1;
    }
LABEL_53:
    if (a2 >= v14)
      v29 = v14;
    else
      v29 = a2;
    if (v29 <= v13)
      v30 = v13;
    else
      v30 = v29;
    if (a2 >= v30)
      v31 = v30;
    else
      v31 = a2;
    v32 = (_BYTE *)(a1 + v29);
    if (v28)
    {
      v33 = *(unsigned __int8 *)(a1 + v13);
      if (v33 > 0x22)
        goto LABEL_78;
      if (((1 << v33) & 0x100002601) == 0)
      {
        if (v33 == 34)
        {
          v36 = v31 - v29;
          v37 = v56;
          if (*((_QWORD *)&v56 + 1) < (unint64_t)v56 + v31 - v29)
          {
            v48 = v31 - v29;
            v40 = v31;
            llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v55, v57, v56 + v31 - v29, 1);
            v31 = v40;
            v36 = v48;
            v37 = v56;
          }
          if (v31 != v29)
          {
            memcpy((char *)v55 + v37, (const void *)(a1 + v29), v36);
            v37 = v56;
          }
          v24 = v37 + v36;
          goto LABEL_31;
        }
LABEL_78:
        v38 = v31 - v29;
        v39 = v56;
        if (*((_QWORD *)&v56 + 1) < (unint64_t)v56 + v31 - v29)
        {
          v49 = v31 - v29;
          v41 = v31;
          llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v55, v57, v56 + v31 - v29, 1);
          v31 = v41;
          v38 = v49;
          v39 = v56;
        }
        if (v31 != v29)
        {
          memcpy((char *)v55 + v39, (const void *)(a1 + v29), v38);
          v39 = v56;
        }
        *(_QWORD *)&v56 = v39 + v38;
LABEL_35:
        v13 = sub_1C5DE4800(a1, a2, v13, &v55);
        goto LABEL_39;
      }
    }
    v47 = v28;
    v34 = v31 - v29;
    if (a6)
    {
      v46 = v31;
      v35 = (_BYTE *)sub_1C484358C(*a3, v34 + 1, 0);
      v32 = v35;
      if (v46 != v29)
        memcpy(v35, (const void *)(a1 + v29), v34);
      v32[v34] = 0;
    }
    a4(a5, v32, v34);
    v12 = v47;
    if (v47)
    {
      if (*(_BYTE *)(a1 + v13) != 10)
        goto LABEL_19;
      goto LABEL_18;
    }
LABEL_40:
    ++v13;
  }
  while (v13 < a2);
  v42 = v55;
  if (v12 == 1)
  {
    v43 = v56;
    v44 = (_BYTE *)sub_1C484358C(*a3, v56 + 1, 0);
    v45 = v44;
    if (v43)
      memcpy(v44, v42, v43);
    v45[v43] = 0;
    a4(a5, v45, v43);
    v42 = v55;
  }
  if (v42 != v57)
    free(v42);
}

void llvm::cl::TokenizeWindowsCommandLineNoCopy(uint64_t a1, unint64_t a2, uint64_t *a3, uint64_t a4)
{
  char v4;
  uint64_t v5;

  v5 = a4;
  sub_1C5DDB6D0(a1, a2, a3, (void (*)(uint64_t, _BYTE *, size_t))sub_1C5DE6990, (uint64_t)&v5, 0, (void (*)(uint64_t))nullsub_1407, (uint64_t)&v4);
}

uint64_t llvm::cl::ExpandResponseFiles(uint64_t *a1, void (*a2)(std::string *, unint64_t, uint64_t *, uint64_t, uint64_t), unsigned int *a3, unsigned int a4, char a5, unsigned __int8 a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  void **v15;
  _BYTE *v16;
  _BYTE *v17;
  int v18;
  char v19;
  uint64_t v20;
  unint64_t v21;
  const void *v22;
  char v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  char v27;
  _BOOL4 v29;
  unint64_t v30;
  unint64_t v31;
  _QWORD *v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  size_t v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  size_t v41;
  size_t v42;
  __n128 *p_dst;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  char *v50;
  char v51;
  uint64_t v52;
  uint64_t v60;
  char *v61[4];
  __int16 v62;
  _QWORD *v63[4];
  __int16 v64;
  void *__p;
  __int128 v66;
  _QWORD v67[16];
  void *v68;
  uint64_t v69;
  _BYTE v70[96];
  void *__src;
  uint64_t v72;
  _BYTE v73[8];
  uint64_t v74;
  uint64_t v75;
  char v76;
  __n128 __dst;
  unint64_t v78;
  unint64_t v79;
  uint64_t v80;
  char v81;
  uint64_t v82;

  v82 = *MEMORY[0x1E0C80C00];
  v68 = v70;
  v69 = 0x300000000;
  HIBYTE(v66) = 0;
  LOBYTE(__p) = 0;
  v67[0] = a3[2];
  sub_1C5DDC320((uint64_t)&v68, (__n128 *)&__p);
  if (SHIBYTE(v66) < 0)
    operator delete(__p);
  if (!a3[2])
  {
    LOBYTE(v12) = 1;
    goto LABEL_96;
  }
  v10 = 0;
  v11 = 0;
  v12 = 1;
  do
  {
    v13 = v68;
    LODWORD(v14) = v69;
    if (*((_QWORD *)v68 + 4 * v69 - 1) == v10)
    {
      do
      {
        v14 = (v14 - 1);
        LODWORD(v69) = v14;
        v15 = (void **)&v13[4 * v14];
        if (*((char *)v15 + 23) < 0)
        {
          operator delete(*v15);
          v13 = v68;
          v14 = v69;
        }
      }
      while (v13[4 * v14 - 1] == v10);
    }
    v16 = *(_BYTE **)(*(_QWORD *)a3 + 8 * v10);
    if (!v16 || *v16 != 64)
    {
      ++v11;
      goto LABEL_75;
    }
    __p = v67;
    v66 = xmmword_1C85F20B0;
    LOWORD(v80) = 257;
    v18 = v16[1];
    v17 = v16 + 1;
    if (v18)
    {
      __dst.n128_u64[0] = (unint64_t)v17;
      v19 = 3;
    }
    else
    {
      v19 = 1;
    }
    LOBYTE(v80) = v19;
    v60 = v12;
    if ((llvm::sys::path::is_absolute((const char **)&__dst, 0) & 1) != 0)
      goto LABEL_28;
    if (!*(_BYTE *)(a7 + 16))
    {
      llvm::sys::fs::current_path((uint64_t)&__p);
      goto LABEL_22;
    }
    v20 = 0;
    v22 = *(const void **)a7;
    v21 = *(_QWORD *)(a7 + 8);
    *(_QWORD *)&v66 = 0;
    if (*((_QWORD *)&v66 + 1) < v21)
    {
      llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&__p, v67, v21, 1);
      v20 = v66;
      if (!v21)
        goto LABEL_20;
LABEL_19:
      memcpy((char *)__p + v20, v22, v21);
      v20 = v66;
      goto LABEL_20;
    }
    if (v21)
      goto LABEL_19;
LABEL_20:
    *(_QWORD *)&v66 = v20 + v21;
LABEL_22:
    LOWORD(v80) = 257;
    if (*v17)
    {
      __dst.n128_u64[0] = (unint64_t)v17;
      v23 = 3;
    }
    else
    {
      v23 = 1;
    }
    LOBYTE(v80) = v23;
    LOWORD(v75) = 257;
    v64 = 257;
    v62 = 257;
    llvm::sys::path::append(&__p, 0, &__dst, (_QWORD **)&__src, v63, (void ***)v61);
    v24 = v66;
    if ((unint64_t)(v66 + 1) > *((_QWORD *)&v66 + 1))
    {
      llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&__p, v67, v66 + 1, 1);
      v24 = v66;
    }
    *((_BYTE *)__p + v24) = 0;
    v17 = __p;
LABEL_28:
    v25 = (char *)v68 + 32;
    v26 = 32 * v69 - 32;
    while (v26)
    {
      LOWORD(v75) = 257;
      if (*v17)
      {
        __src = v17;
        v27 = 3;
      }
      else
      {
        v27 = 1;
      }
      LOBYTE(v75) = v27;
      (*(void (**)(__n128 *__return_ptr, uint64_t, void **))(*(_QWORD *)a8 + 16))(&__dst, a8, &__src);
      if ((v81 & 1) != 0)
      {
        v30 = __dst.n128_u64[0];
        if (__dst.n128_u32[0])
        {
          v31 = __dst.n128_u64[1];
          v32 = (_QWORD *)operator new();
          *v32 = &off_1E81A0D28;
          v32[1] = v30;
          v32[2] = v31;
        }
        else
        {
          v32 = 0;
        }
        v63[0] = v32;
        sub_1C4D62BD4((char **)v63, (char **)&__src);
        if (v63[0])
          (*(void (**)(_QWORD *))(*v63[0] + 8))(v63[0]);
        v29 = 0;
        goto LABEL_55;
      }
      v64 = 260;
      v63[0] = v25;
      (*(void (**)(void **__return_ptr, uint64_t, _QWORD **))(*(_QWORD *)a8 + 16))(&__src, a8, v63);
      if ((v76 & 1) != 0)
      {
        v33 = __src;
        if ((_DWORD)__src)
        {
          v34 = v72;
          v35 = operator new();
          *(_QWORD *)v35 = &off_1E81A0D28;
          *(_QWORD *)(v35 + 8) = v33;
          *(_QWORD *)(v35 + 16) = v34;
        }
        else
        {
          v35 = 0;
        }
        v61[0] = (char *)v35;
        sub_1C4D62BD4(v61, (char **)v63);
        if (v61[0])
          (*(void (**)(char *))(*(_QWORD *)v61[0] + 8))(v61[0]);
        v29 = 0;
        if ((v76 & 1) != 0)
          goto LABEL_55;
LABEL_53:
        if ((v73[7] & 0x80000000) != 0)
          operator delete(__src);
        goto LABEL_55;
      }
      v29 = v79 == v74 && v80 == v75;
      if ((v76 & 1) == 0)
        goto LABEL_53;
LABEL_55:
      if ((v81 & 1) == 0 && SHIBYTE(v78) < 0)
        operator delete((void *)__dst.n128_u64[0]);
      v25 += 4;
      v26 -= 32;
      if (v29)
      {
        v12 = 0;
        ++v11;
        goto LABEL_73;
      }
    }
    __src = v73;
    v72 = 0;
    if (v17)
      v36 = strlen(v17);
    else
      v36 = 0;
    sub_1C5DDC488(v61, v17, v36, a1, a2, (uint64_t)&__src, a4, a5, a6, a8);
    v37 = v61[0];
    if (!v61[0])
    {
      if ((_DWORD)v69)
      {
        v38 = v72 - 1;
        v39 = 32 * v69;
        v40 = (char *)v68 + 24;
        do
        {
          *v40 += v38;
          v40 += 4;
          v39 -= 32;
        }
        while (v39);
      }
      v41 = strlen(v17);
      if (v41 >= 0x7FFFFFFFFFFFFFF8)
        abort();
      v42 = v41;
      if (v41 >= 0x17)
      {
        v44 = (v41 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v41 | 7) != 0x17)
          v44 = v41 | 7;
        v45 = v44 + 1;
        p_dst = (__n128 *)operator new(v44 + 1);
        __dst.n128_u64[1] = v42;
        v78 = v45 | 0x8000000000000000;
        __dst.n128_u64[0] = (unint64_t)p_dst;
      }
      else
      {
        HIBYTE(v78) = v41;
        p_dst = &__dst;
        if (!v41)
          goto LABEL_88;
      }
      memmove(p_dst, v17, v42);
LABEL_88:
      p_dst->n128_u8[v42] = 0;
      v79 = v72 + (unint64_t)v11;
      sub_1C5DDC320((uint64_t)&v68, &__dst);
      if (SHIBYTE(v78) < 0)
        operator delete((void *)__dst.n128_u64[0]);
      v46 = *(_QWORD *)a3;
      v47 = *(_QWORD *)a3 + 8 * v11;
      v48 = a3[2];
      v49 = *(_QWORD *)a3 + 8 * v48;
      if (v49 != v47 + 8)
      {
        memmove((void *)v47, (const void *)(v47 + 8), v49 - (v47 + 8));
        LODWORD(v48) = a3[2];
        v46 = *(_QWORD *)a3;
      }
      a3[2] = v48 - 1;
      sub_1C6384A98(a3, v46 + 8 * v11, (uint64_t *)__src, (uint64_t *)__src + v72);
      v12 = v60;
      goto LABEL_71;
    }
    v61[0] = 0;
    v63[0] = v37;
    sub_1C4D62BD4((char **)v63, (char **)&__dst);
    if (v63[0])
      (*(void (**)(_QWORD *))(*v63[0] + 8))(v63[0]);
    if (v61[0])
      (*(void (**)(char *))(*(_QWORD *)v61[0] + 8))(v61[0]);
    v12 = 0;
    ++v11;
LABEL_71:
    if (__src != v73)
      free(__src);
LABEL_73:
    if (__p != v67)
      free(__p);
LABEL_75:
    v10 = v11;
  }
  while (a3[2] != v11);
LABEL_96:
  v50 = (char *)v68;
  if ((_DWORD)v69)
  {
    v51 = v12;
    v52 = 32 * v69;
    do
    {
      if (v50[v52 - 9] < 0)
        operator delete(*(void **)&v50[v52 - 32]);
      v52 -= 32;
    }
    while (v52);
    v50 = (char *)v68;
    LOBYTE(v12) = v51;
  }
  if (v50 != v70)
    free(v50);
  return v12 & 1;
}

__n128 sub_1C5DDC320(uint64_t a1, __n128 *a2)
{
  uint64_t v4;
  __n128 *v5;
  __n128 *v6;
  __n128 result;
  unint64_t v8;
  unint64_t n128_u64;
  _BOOL4 v11;
  uint64_t v12;
  __n128 *v13;
  __n128 *v14;
  uint64_t v15;
  __n128 *v16;
  __n128 *v17;
  __n128 v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  unint64_t v22;

  v4 = *(unsigned int *)(a1 + 8);
  v5 = *(__n128 **)a1;
  if (v4 >= *(_DWORD *)(a1 + 12))
  {
    v8 = v4 + 1;
    n128_u64 = (unint64_t)v5[2 * v4].n128_u64;
    v11 = v5 <= a2 && n128_u64 > (unint64_t)a2;
    if (v11)
      v12 = ((char *)a2 - (char *)v5) >> 5;
    else
      v12 = -1;
    v22 = 0;
    v13 = (__n128 *)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, v8, 32, &v22);
    v5 = v13;
    v14 = *(__n128 **)a1;
    v15 = *(unsigned int *)(a1 + 8);
    if ((_DWORD)v15)
    {
      v16 = &v14[2 * v15];
      v17 = v13;
      do
      {
        v18 = *v14;
        v17[1].n128_u64[0] = v14[1].n128_u64[0];
        *v17 = v18;
        v14->n128_u64[1] = 0;
        v14[1].n128_u64[0] = 0;
        v14->n128_u64[0] = 0;
        v17[1].n128_u64[1] = v14[1].n128_u64[1];
        v14 += 2;
        v17 += 2;
      }
      while (v14 != v16);
      v14 = *(__n128 **)a1;
      v19 = *(unsigned int *)(a1 + 8);
      if ((_DWORD)v19)
      {
        v20 = 2 * v19;
        do
        {
          if (v14[v20 - 1].n128_i8[7] < 0)
            operator delete((void *)v14[v20 - 2].n128_u64[0]);
          v20 -= 2;
        }
        while (v20 * 16);
        v14 = *(__n128 **)a1;
      }
    }
    v21 = v22;
    if (v14 != (__n128 *)(a1 + 16))
      free(v14);
    *(_QWORD *)a1 = v5;
    *(_DWORD *)(a1 + 12) = v21;
    if (v11)
      a2 = &v5[2 * v12];
    v4 = *(unsigned int *)(a1 + 8);
  }
  v6 = &v5[2 * v4];
  result = *a2;
  v6[1].n128_u64[0] = a2[1].n128_u64[0];
  *v6 = result;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  a2->n128_u64[0] = 0;
  v6[1].n128_u64[1] = a2[1].n128_u64[1];
  ++*(_DWORD *)(a1 + 8);
  return result;
}

void sub_1C5DDC488(_QWORD *a1, const char *a2, unint64_t a3, uint64_t *a4, void (*a5)(std::string *, unint64_t, uint64_t *, uint64_t, uint64_t), uint64_t a6, uint64_t a7, char a8, unsigned __int8 a9, uint64_t a10)
{
  unsigned __int8 *v15;
  std::string *p_p;
  unint64_t size;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;
  uint64_t v24;
  int v25;
  const char **v26;
  const char **v27;
  size_t v28;
  size_t v29;
  const char *v30;
  size_t v31;
  uint64_t v32;
  uint64_t v33;
  size_t v34;
  size_t v35;
  size_t v36;
  const char *v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  const void *v43;
  char *v44;
  const char *v45;
  const char *v46;
  size_t v47;
  uint64_t v48;
  size_t v49;
  const void *v50;
  char *v51;
  const char *v52;
  uint64_t v53;
  const std::error_category *v54;
  unint64_t v55;
  const char **v56;
  std::string __p;
  void **v60[4];
  __int16 v61;
  _QWORD *v62[4];
  __int16 v63;
  _QWORD *v64[4];
  __int16 v65;
  const char *v66;
  unint64_t v67;
  __int16 v68;
  uint64_t v69[2];
  _QWORD v70[2];
  char v71;
  uint64_t v72;
  __int128 v73;
  char v74[8];
  __int16 v75;
  uint64_t v76;

  v15 = (unsigned __int8 *)a2;
  v76 = *MEMORY[0x1E0C80C00];
  v75 = 261;
  v72 = (uint64_t)a2;
  *(_QWORD *)&v73 = a3;
  llvm::vfs::FileSystem::getBufferForFile(a10, (uint64_t)&v72, -1, 1, 0, 0, (uint64_t)v70);
  if ((v71 & 1) != 0)
  {
    v20 = v70[0];
    if (LODWORD(v70[0]))
    {
      v21 = v70[1];
      v22 = (_QWORD *)operator new();
      *v22 = &off_1E81A0D28;
      v22[1] = v20;
      v22[2] = v21;
    }
    else
    {
      v22 = 0;
    }
    *a1 = v22;
    goto LABEL_82;
  }
  p_p = *(std::string **)(v70[0] + 8);
  size = *(_QWORD *)(v70[0] + 16) - (_QWORD)p_p;
  memset(&__p, 0, sizeof(__p));
  if (size < 2)
    goto LABEL_24;
  v18 = p_p->__r_.__value_.__s.__data_[0];
  if (v18 == 255)
  {
    v19 = 254;
  }
  else
  {
    if (v18 != 254)
      goto LABEL_18;
    v19 = 255;
  }
  if (p_p->__r_.__value_.__s.__data_[1] == v19)
  {
    if (!llvm::convertUTF16ToUTF8String((unsigned __int16 *)p_p, size, &__p))
    {
      v54 = std::generic_category();
      v72 = 92;
      *(_QWORD *)&v73 = v54;
      v66 = "Could not convert UTF16 to UTF8";
      sub_1C5DF1730((_BYTE **)&v66, &v72, a1);
      goto LABEL_80;
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_p = &__p;
    else
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = *((_BYTE *)&__p.__r_.__value_.__s + 23) & 0x7F;
    else
      size = __p.__r_.__value_.__l.__size_;
    goto LABEL_24;
  }
LABEL_18:
  if (size < 3)
  {
    size = 2;
  }
  else if (v18 == 239
         && p_p->__r_.__value_.__s.__data_[1] == 187
         && p_p->__r_.__value_.__s.__data_[2] == 191)
  {
    p_p = (std::string *)((char *)p_p + 3);
    size -= 3;
  }
LABEL_24:
  a5(p_p, size, a4, a6, a7);
  if ((a8 & 1) == 0)
    goto LABEL_79;
  v23 = sub_1C5E7BE8C(v15, a3, 0);
  v24 = *(unsigned int *)(a6 + 8);
  if (!(_DWORD)v24)
    goto LABEL_79;
  v25 = a9;
  v26 = *(const char ***)a6;
  v27 = &v26[v24];
  if (a3 >= v23)
    v28 = v23;
  else
    v28 = a3;
  if (v23 == -1)
  {
    v15 = 0;
    v29 = 0;
  }
  else
  {
    v29 = v28;
  }
  v55 = v29 + 1;
  v56 = v27;
  do
  {
    v30 = *v26;
    if (!*v26)
      goto LABEL_75;
    if (!v25)
      goto LABEL_66;
    v69[0] = (uint64_t)*v26;
    v31 = strlen(v30);
    v69[1] = v31;
    v72 = (uint64_t)v74;
    v73 = xmmword_1C85F20B0;
    v32 = llvm::StringRef::find(v69, "<CFGDIR>", 8uLL, 0);
    if (v32 == -1)
      goto LABEL_63;
    v33 = v32;
    v34 = 0;
    v35 = 0;
    do
    {
      if (v31 >= v35)
        v36 = v35;
      else
        v36 = v31;
      v37 = &v30[v36];
      v38 = v31 - v36;
      if (v38 >= v33 - v35)
        v39 = v33 - v35;
      else
        v39 = v38;
      if (v34)
      {
        v68 = 261;
        v66 = v37;
        v67 = v39;
        v65 = 257;
        v63 = 257;
        v61 = 257;
        llvm::sys::path::append(&v72, 0, (_QWORD **)&v66, v64, v62, v60);
        v40 = v73;
        goto LABEL_49;
      }
      *(_QWORD *)&v73 = 0;
      if (*((_QWORD *)&v73 + 1) < v39)
      {
        llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v72, v74, v39, 1);
        v41 = v73;
LABEL_47:
        memcpy((void *)(v72 + v41), v37, v39);
        v42 = v73;
        goto LABEL_48;
      }
      v41 = 0;
      v42 = 0;
      if (v39)
        goto LABEL_47;
LABEL_48:
      v40 = v42 + v39;
      *(_QWORD *)&v73 = v42 + v39;
LABEL_49:
      if (*((_QWORD *)&v73 + 1) >= v40 + v29)
      {
        if (!v29)
          goto LABEL_52;
LABEL_51:
        memcpy((void *)(v72 + v40), v15, v29);
        v40 = v73;
        goto LABEL_52;
      }
      llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v72, v74, v40 + v29, 1);
      v40 = v73;
      if (v29)
        goto LABEL_51;
LABEL_52:
      v34 = v40 + v29;
      *(_QWORD *)&v73 = v40 + v29;
      v35 = v33 + 8;
      v33 = llvm::StringRef::find(v69, "<CFGDIR>", 8uLL, v33 + 8);
    }
    while (v33 != -1);
    if (v34)
    {
      if (v31 > v35)
      {
        v68 = 261;
        v66 = &v30[v35];
        v67 = v31 - v35;
        v65 = 257;
        v63 = 257;
        v61 = 257;
        llvm::sys::path::append(&v72, 0, (_QWORD **)&v66, v64, v62, v60);
        v34 = v73;
      }
      v43 = (const void *)v72;
      v44 = (char *)sub_1C484358C(*a4, v34 + 1, 0);
      v45 = v44;
      if (v34)
        memcpy(v44, v43, v34);
      v45[v34] = 0;
      *v26 = v45;
    }
LABEL_63:
    if ((char *)v72 != v74)
      free((void *)v72);
    v30 = *v26;
    v25 = a9;
    v27 = v56;
LABEL_66:
    if (*v30 == 64)
    {
      v46 = v30 + 1;
      v47 = strlen(v30 + 1);
      v75 = 261;
      v72 = (uint64_t)v46;
      *(_QWORD *)&v73 = v47;
      if ((llvm::sys::path::is_absolute((const char **)&v72, 0) & 1) == 0)
      {
        v72 = (uint64_t)v74;
        v74[0] = 64;
        v73 = xmmword_1C85FBF70;
        if (v55 >= 0x81)
        {
          llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v72, v74, v55, 1);
          v48 = v73;
          if (v29)
          {
LABEL_70:
            memcpy((void *)(v72 + v48), v15, v29);
            v48 = v73;
          }
        }
        else
        {
          v48 = 1;
          if (v29)
            goto LABEL_70;
        }
        *(_QWORD *)&v73 = v48 + v29;
        v68 = 261;
        v66 = v46;
        v67 = v47;
        v65 = 257;
        v63 = 257;
        v61 = 257;
        llvm::sys::path::append(&v72, 0, (_QWORD **)&v66, v64, v62, v60);
        v50 = (const void *)v72;
        v49 = v73;
        v51 = (char *)sub_1C484358C(*a4, v73 + 1, 0);
        v52 = v51;
        if (v49)
          memcpy(v51, v50, v49);
        v52[v49] = 0;
        *v26 = v52;
        if ((char *)v72 != v74)
          free((void *)v72);
      }
    }
LABEL_75:
    ++v26;
  }
  while (v26 != v27);
LABEL_79:
  *a1 = 0;
LABEL_80:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
LABEL_82:
  if ((v71 & 1) == 0)
  {
    v53 = v70[0];
    v70[0] = 0;
    if (v53)
      (*(void (**)(uint64_t))(*(_QWORD *)v53 + 8))(v53);
  }
}

uint64_t llvm::cl::expandResponseFiles(int a1, uint64_t a2, const char *a3, uint64_t *a4, unsigned int *a5)
{
  void (*v10)(std::string *, unint64_t, uint64_t *, uint64_t, uint64_t);
  size_t v11;
  __n128 v12;
  void **v13;
  void *v14;
  __int128 v16;
  char v17;
  void *v18[2];
  char v19;
  void **v20;
  __int16 v21;
  void *__p[2];
  char v23;
  char v24;
  int v25;

  llvm::sys::getProcessTriple((uint64_t)v18);
  v21 = 260;
  v20 = v18;
  llvm::Triple::Triple((uint64_t)__p, (llvm::Twine *)&v20);
  if (v25 == 15)
    v10 = (void (*)(std::string *, unint64_t, uint64_t *, uint64_t, uint64_t))llvm::cl::TokenizeWindowsCommandLine;
  else
    v10 = (void (*)(std::string *, unint64_t, uint64_t *, uint64_t, uint64_t))llvm::cl::TokenizeGNUCommandLine;
  if (v23 < 0)
    operator delete(__p[0]);
  if (v19 < 0)
    operator delete(v18[0]);
  if (a3)
  {
    v11 = strlen(a3);
    v12.n128_f64[0] = llvm::sys::Process::GetEnv(a3, v11, (uint64_t)__p);
    if (v24)
    {
      if (v23 >= 0)
        v13 = __p;
      else
        v13 = (void **)__p[0];
      if (v23 >= 0)
        v14 = (void *)(v23 & 0x7F);
      else
        v14 = __p[1];
      ((void (*)(void **, void *, uint64_t *, unsigned int *, _QWORD, __n128))v10)(v13, v14, a4, a5, 0, v12);
      if (v24 && v23 < 0)
        operator delete(__p[0]);
    }
  }
  sub_1C486AF08(a5, (_BYTE *)(a2 + 8), (_BYTE *)(a2 + 8 * a1));
  LOBYTE(v16) = 0;
  v17 = 0;
  return llvm::cl::ExpandResponseFiles(a4, v10, a5, 0, 0, 0, &v16);
}

BOOL llvm::cl::ParseCommandLineOptions(llvm *a1, _QWORD *a2, uint64_t a3, uint64_t a4, llvm::raw_ostream *a5, const char *a6, int a7)
{
  int v12;
  unsigned int v13;
  size_t v14;
  void **v15;
  void *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  unint64_t *v20;
  _QWORD *v22;
  uint64_t v23;
  void (*v24)(std::string *, unint64_t, uint64_t *, uint64_t, uint64_t);
  const char *v25;
  void *v26;
  unint64_t v27;
  void *v28;
  void *v29;
  void *v30;
  size_t v31;
  size_t v32;
  llvm::raw_ostream *v33;
  uint64_t v34;
  _BYTE *v36;
  uint64_t v37;
  uint64_t v38;
  size_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t *v44;
  unint64_t *v45;
  llvm::ManagedStaticBase *v46;
  unint64_t v47;
  unint64_t *v49;
  llvm::ManagedStaticBase *v50;
  uint64_t v51;
  unint64_t *v53;
  llvm::ManagedStaticBase *v54;
  unint64_t *v55;
  unint64_t v56;
  uint64_t v60;
  uint64_t *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unsigned int v66;
  char v67;
  uint64_t v68;
  uint64_t v69;
  int v70;
  llvm::raw_ostream *v71;
  char v72;
  BOOL v73;
  const char *v74;
  size_t v75;
  size_t v76;
  llvm::raw_ostream *v77;
  void *v78;
  _DWORD *v79;
  const void *v80;
  unint64_t v81;
  llvm::raw_ostream *v82;
  llvm::raw_ostream *v83;
  const char **v84;
  int v85;
  llvm::raw_ostream *v86;
  unsigned __int16 *v87;
  char *v88;
  int v89;
  size_t v90;
  void *v91;
  char *v92;
  __int128 v93;
  int v94;
  const char **v95;
  void *v96;
  char *v97;
  __int128 v98;
  int v99;
  size_t v100;
  BOOL v101;
  int v102;
  int v103;
  _WORD *v104;
  uint64_t v105;
  size_t v106;
  BOOL v107;
  char v108;
  size_t v109;
  unsigned __int8 *v110;
  uint64_t v111;
  size_t v112;
  int v113;
  uint64_t v114;
  unsigned __int8 *v115;
  int v116;
  unsigned int v117;
  uint64_t v118;
  uint64_t v119;
  int v120;
  int i;
  uint64_t v122;
  _QWORD *v123;
  int v124;
  BOOL v125;
  const char *v126;
  size_t v127;
  size_t v128;
  void *v129;
  _WORD *v130;
  const char *v131;
  unint64_t v132;
  _BYTE *v133;
  const char *v134;
  unint64_t v135;
  char v136;
  BOOL v137;
  const char *v138;
  size_t v139;
  size_t v140;
  _OWORD *v141;
  void **v142;
  void *v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  BOOL v148;
  unsigned int v149;
  uint64_t v150;
  size_t v151;
  uint64_t v152;
  uint64_t v153;
  int v154;
  int v155;
  int j;
  uint64_t v157;
  _QWORD *v158;
  unsigned int v159;
  unint64_t v160;
  uint64_t v161;
  unsigned __int8 *v162;
  int v163;
  llvm *v164;
  uint64_t v165;
  unint64_t v166;
  int v167;
  unint64_t v168;
  unsigned __int8 *v169;
  int v170;
  unsigned int v171;
  uint64_t v172;
  uint64_t v173;
  int v174;
  int k;
  uint64_t v176;
  _QWORD *v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  BOOL v181;
  unsigned int v182;
  uint64_t v183;
  size_t v184;
  uint64_t v185;
  uint64_t v186;
  int v187;
  int v188;
  int m;
  uint64_t v190;
  _QWORD *v191;
  size_t v192;
  unint64_t v193;
  _QWORD *v194;
  uint64_t v195;
  const char *v196;
  size_t v197;
  unsigned __int8 *v198;
  unint64_t v199;
  unint64_t v200;
  unint64_t v201;
  unsigned __int8 *v202;
  size_t v203;
  uint64_t v204;
  uint64_t *n;
  uint64_t v207;
  unsigned int v208;
  uint64_t v209;
  _WORD *v210;
  uint64_t v211;
  unsigned __int8 *v212;
  _WORD *v213;
  uint64_t v214;
  uint64_t v215;
  _QWORD *v216;
  int v217;
  void **v218;
  unint64_t v219;
  _BOOL4 v220;
  unint64_t *v221;
  uint64_t v222;
  unsigned int v223;
  unsigned int v224;
  size_t v225;
  const void *v226;
  void *v227;
  unint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  BOOL v232;
  llvm::raw_ostream *v233;
  unsigned int v234;
  char v235;
  BOOL v236;
  const char *v237;
  size_t v238;
  size_t v239;
  void *v240;
  void *v241;
  uint64_t v242;
  unint64_t v243;
  const char *v244;
  const char *v245;
  llvm::raw_ostream *v246;
  size_t v247;
  uint64_t v248;
  char v249;
  uint64_t v250;
  unsigned int v251;
  uint64_t v252;
  char v253;
  char *v254;
  _BYTE *v255;
  size_t v256;
  uint64_t v258;
  _BYTE *v259;
  size_t v260;
  char v261;
  BOOL v262;
  const char *v263;
  size_t v264;
  size_t v265;
  void *v266;
  uint64_t v267;
  void *v268;
  _QWORD *v269;
  const char *v270;
  unint64_t v271;
  uint64_t v272;
  uint64_t *ii;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  BOOL v279;
  llvm::raw_ostream *v280;
  uint64_t v282;
  unsigned int v283;
  __int16 v284;
  char *v285;
  _BYTE *v286;
  size_t v287;
  unsigned int v288;
  uint64_t v289;
  __int16 v290;
  char *v291;
  _BYTE *v292;
  size_t v293;
  uint64_t v294;
  char *v295;
  _BYTE *v296;
  size_t v297;
  unsigned __int8 *v298;
  const char **v299;
  unint64_t v300;
  BOOL v301;
  unint64_t v302;
  size_t v303;
  int v304;
  void *v306;
  llvm::raw_ostream *v307;
  uint64_t v308;
  uint64_t v309;
  unint64_t v310;
  int v311;
  uint64_t v312;
  size_t __n;
  int __na;
  size_t __nb;
  char v316;
  unsigned int v317;
  uint64_t v318;
  uint64_t v319;
  _WORD *v320;
  int v321;
  int v322[2];
  uint64_t v323;
  _BOOL4 v324;
  uint64_t v325;
  _QWORD *v326;
  void *__s1;
  size_t v328;
  unsigned __int8 *v329;
  size_t v330;
  void *v331[2];
  int64_t v332;
  unsigned int v333;
  __int128 v334;
  char v335;
  _QWORD *v336;
  _QWORD v337[4];
  __int16 v338;
  void *__dst[2];
  unint64_t v340;
  size_t v341;
  __int16 v342;
  __int128 v343;
  int64_t v344;
  unsigned __int8 *v345;
  unint64_t v346;
  _QWORD v347[4];
  _QWORD v348[6];
  _QWORD v349[2];
  void *v350;
  uint64_t v351;
  _QWORD v352[20];
  void *v353;
  uint64_t v354;
  _WORD v355[48];
  _QWORD v356[4];
  _QWORD v357[6];
  _QWORD v358[2];
  void *v359;
  uint64_t v360;
  _BYTE v361[160];
  void *__p[2];
  void *__src;
  size_t __len;
  void *v365;
  int v366;
  uint64_t v367;

  v12 = (int)a1;
  v367 = *MEMORY[0x1E0C80C00];
  sub_1C5DDEC70(a1);
  v347[0] = 0;
  v347[1] = 0;
  v347[2] = v348;
  v347[3] = 0x400000000;
  v348[4] = v349;
  v348[5] = 0;
  v13 = 1;
  v349[0] = 0;
  v349[1] = 1;
  v350 = v352;
  v326 = v347;
  v352[0] = *a2;
  v351 = 0x1400000001;
  if (a6)
  {
    v14 = strlen(a6);
    llvm::sys::Process::GetEnv(a6, v14, (uint64_t)__p);
    if ((_BYTE)__len)
    {
      v15 = SHIBYTE(__src) >= 0 ? __p : (void **)__p[0];
      v16 = SHIBYTE(__src) >= 0 ? (void *)(HIBYTE(__src) & 0x7F) : __p[1];
      llvm::cl::TokenizeGNUCommandLine((uint64_t)v15, (unint64_t)v16, (uint64_t *)&v326, (uint64_t)&v350, 0);
      if ((_BYTE)__len)
      {
        if (SHIBYTE(__src) < 0)
          operator delete(__p[0]);
      }
    }
    v13 = v351;
  }
  if (v12 >= 2)
  {
    v17 = v12 - 1;
    v18 = a2 + 1;
    do
    {
      v19 = *v18;
      if (v13 >= HIDWORD(v351))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v350, (uint64_t)v352, v13 + 1, 8);
        v13 = v351;
      }
      *((_QWORD *)v350 + v13) = v19;
      v13 = v351 + 1;
      LODWORD(v351) = v351 + 1;
      ++v18;
      --v17;
    }
    while (v17);
  }
  v20 = (unint64_t *)&qword_1ED836A48;
  if (!atomic_load((unint64_t *)&qword_1ED836A48))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1ED836A48, (void *(*)(void))sub_1C5DE673C, (void (*)(void *))sub_1C5DE6840);
  v22 = &unk_1ED836000;
  v23 = qword_1ED836A48;
  v359 = v361;
  v360 = 0x1400000000;
  sub_1C486AF08((unsigned int *)&v359, v350, (_BYTE *)v350 + 8 * (int)v13);
  v356[1] = 0;
  v356[0] = 0;
  v356[2] = v357;
  v356[3] = 0x400000000;
  v357[4] = v358;
  v357[5] = 0;
  v358[0] = 0;
  v358[1] = 1;
  v336 = v356;
  llvm::sys::getProcessTriple((uint64_t)__dst);
  v355[8] = 260;
  v353 = __dst;
  llvm::Triple::Triple((uint64_t)__p, (llvm::Twine *)&v353);
  if (HIDWORD(v365) == 15)
    v24 = (void (*)(std::string *, unint64_t, uint64_t *, uint64_t, uint64_t))llvm::cl::TokenizeWindowsCommandLine;
  else
    v24 = (void (*)(std::string *, unint64_t, uint64_t *, uint64_t, uint64_t))llvm::cl::TokenizeGNUCommandLine;
  LOBYTE(v334) = 0;
  v335 = 0;
  llvm::cl::ExpandResponseFiles((uint64_t *)&v336, v24, (unsigned int *)&v359, 0, 0, 0, &v334);
  if (SHIBYTE(__src) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v340) < 0)
    operator delete(__dst[0]);
  v311 = v360;
  v306 = v359;
  v25 = *(const char **)v359;
  if (*(_QWORD *)v359)
    v26 = (void *)strlen(*(const char **)v359);
  else
    v26 = 0;
  __len = 0;
  __src = 0;
  __p[0] = (void *)v25;
  __p[1] = v26;
  v365 = v26;
  v366 = 0;
  v27 = llvm::sys::path::reverse_iterator::operator++((uint64_t)__p);
  v28 = (void *)__len;
  if (__len > 0x7FFFFFFFFFFFFFF7)
LABEL_550:
    abort();
  v312 = v23;
  v29 = __src;
  if (__len >= 0x17)
  {
    v31 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v31 = __len | 7;
    v32 = v31 + 1;
    v30 = operator new(v31 + 1);
    __src = (void *)(v32 | 0x8000000000000000);
    __p[0] = v30;
    __p[1] = v28;
    goto LABEL_37;
  }
  HIBYTE(__src) = __len;
  v30 = __p;
  if (__len)
LABEL_37:
    v27 = (unint64_t)memmove(v30, v29, (size_t)v28);
  v33 = a5;
  *((_BYTE *)v28 + (_QWORD)v30) = 0;
  v34 = v312;
  if (*(char *)(v312 + 23) < 0)
    operator delete(*(void **)v312);
  v304 = a7;
  *(_OWORD *)v312 = *(_OWORD *)__p;
  *(_QWORD *)(v312 + 16) = __src;
  *(_QWORD *)(v312 + 24) = a3;
  *(_QWORD *)(v312 + 32) = a4;
  v307 = a5;
  if (!a5)
  {
    v27 = (unint64_t)llvm::errs((llvm *)v27);
    v307 = (llvm::raw_ostream *)v27;
  }
  if (!atomic_load(llvm::cl::TopLevelSubCommand))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)llvm::cl::TopLevelSubCommand, (void *(*)(void))sub_1C6386064, (void (*)(void *))sub_1C63860D8);
  if (v311 >= 2)
  {
    v36 = (_BYTE *)*((_QWORD *)v306 + 1);
    if (*v36 != 45)
    {
      v27 = strlen(*((const char **)v306 + 1));
      if (v27)
      {
        v39 = v27;
        v40 = *(_QWORD *)(v312 + 280);
        v41 = 288;
        if (v40 == *(_QWORD *)(v312 + 272))
          v41 = 292;
        v42 = *(unsigned int *)(v312 + v41);
        if ((_DWORD)v42)
        {
          v43 = 8 * v42;
          v44 = *(unint64_t **)(v312 + 280);
          while (*v44 >= 0xFFFFFFFFFFFFFFFELL)
          {
            ++v44;
            v43 -= 8;
            if (!v43)
              goto LABEL_71;
          }
        }
        else
        {
          v44 = *(unint64_t **)(v312 + 280);
        }
        v45 = (unint64_t *)(v40 + 8 * v42);
        if (v44 != v45)
        {
          v46 = (llvm::ManagedStaticBase *)&llvm::cl::AllSubCommands;
          v47 = *v44;
LABEL_58:
          if (!atomic_load((unint64_t *)v46))
          {
            v49 = v20;
            v50 = v46;
            llvm::ManagedStaticBase::RegisterManagedStatic(v46, (void *(*)(void))sub_1C6386064, (void (*)(void *))sub_1C63860D8);
            v46 = v50;
            v20 = v49;
            v22 = (_QWORD *)&unk_1ED836000;
          }
          if (v47 != llvm::cl::AllSubCommands)
          {
            v51 = *(_QWORD *)(v47 + 8);
            if (v51 && v51 == v39)
            {
              v53 = v20;
              v54 = v46;
              v27 = memcmp(*(const void **)v47, v36, v39);
              v46 = v54;
              v20 = v53;
              v22 = (_QWORD *)&unk_1ED836000;
              if (!(_DWORD)v27)
                goto LABEL_74;
            }
          }
          v55 = v44 + 1;
          while (v55 != v45)
          {
            v56 = *v55++;
            v47 = v56;
            if (v56 <= 0xFFFFFFFFFFFFFFFDLL)
            {
              v44 = v55 - 1;
              goto LABEL_58;
            }
          }
        }
      }
LABEL_71:
      if (!atomic_load(llvm::cl::TopLevelSubCommand))
        llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)llvm::cl::TopLevelSubCommand, (void *(*)(void))sub_1C6386064, (void (*)(void *))sub_1C63860D8);
      v47 = llvm::cl::TopLevelSubCommand[0];
LABEL_74:
      if (!atomic_load(llvm::cl::TopLevelSubCommand))
        llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)llvm::cl::TopLevelSubCommand, (void *(*)(void))sub_1C6386064, (void (*)(void *))sub_1C63860D8);
      v38 = v47;
      if (v47 == llvm::cl::TopLevelSubCommand[0])
        v37 = 1;
      else
        v37 = 2;
      v33 = a5;
      v34 = v312;
      goto LABEL_80;
    }
  }
  v37 = 1;
  v38 = llvm::cl::TopLevelSubCommand[0];
LABEL_80:
  if (!atomic_load(v20))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1ED836A48, (void *(*)(void))sub_1C5DE673C, (void (*)(void *))sub_1C5DE6840);
  *(_QWORD *)(v22[329] + 336) = v38;
  v60 = *(unsigned int *)(v34 + 72);
  if ((_DWORD)v60)
  {
    v61 = *(uint64_t **)(v34 + 64);
    v62 = 8 * v60;
    do
    {
      v63 = *v61++;
      sub_1C5DDAC70(v34, v63, 1);
      v62 -= 8;
    }
    while (v62);
  }
  v64 = *(unsigned int *)(v38 + 40);
  v325 = v38;
  if (!(_DWORD)v64)
  {
    v321 = 0;
    v301 = 0;
    v66 = 0;
    v84 = (const char **)v306;
    v85 = v311;
    goto LABEL_124;
  }
  v65 = 0;
  v66 = 0;
  v67 = 0;
  v321 = 0;
  v68 = 8 * v64;
  do
  {
    v69 = *(_QWORD *)(*(_QWORD *)(v325 + 32) + v65);
    if ((*(_WORD *)(v69 + 10) & 6) == 2)
    {
      ++v66;
      goto LABEL_116;
    }
    if (*(_QWORD *)(v325 + 160))
    {
      v70 = v321;
      if (*(_DWORD *)(v325 + 40) >= 2u)
        v70 = 1;
      v321 = v70;
      if (!v33 && *(_DWORD *)(v325 + 40) >= 2u)
      {
        __p[0] = "error - this positional option will never be matched, because it does not Require a value, and a cl::Co"
                 "nsumeAfter option is active!";
        LOWORD(v365) = 259;
        v71 = (llvm::raw_ostream *)llvm::errs((llvm *)v27);
        v27 = llvm::cl::Option::error((_QWORD *)v69, (llvm::Twine *)__p, 0, 0, v71);
LABEL_115:
        v321 = 1;
      }
    }
    else if ((v67 & 1) != 0 && !*(_QWORD *)(v69 + 24))
    {
      if (!v33)
      {
        __p[0] = "error - option can never match, because another positional argument will match an unbounded number of v"
                 "alues, and this option does not require a value!";
        LOWORD(v365) = 259;
        v83 = (llvm::raw_ostream *)llvm::errs((llvm *)v27);
        llvm::cl::Option::error((_QWORD *)v69, (llvm::Twine *)__p, 0, 0, v83);
      }
      v72 = *(_BYTE *)(v34 + 23);
      v73 = v72 < 0;
      if (v72 >= 0)
        v74 = (const char *)v34;
      else
        v74 = *(const char **)v34;
      v75 = v72 & 0x7F;
      if (v73)
        v76 = *(_QWORD *)(v34 + 8);
      else
        v76 = v75;
      v77 = llvm::raw_ostream::write(v307, v74, v76);
      v78 = (void *)*((_QWORD *)v77 + 4);
      if (*((_QWORD *)v77 + 3) - (_QWORD)v78 > 0x1CuLL)
      {
        qmemcpy(v78, ": CommandLine Error: Option '", 29);
        v79 = (_DWORD *)(*((_QWORD *)v77 + 4) + 29);
        *((_QWORD *)v77 + 4) = v79;
      }
      else
      {
        v77 = llvm::raw_ostream::write(v77, ": CommandLine Error: Option '", 0x1DuLL);
        v79 = (_DWORD *)*((_QWORD *)v77 + 4);
      }
      v80 = *(const void **)(v69 + 16);
      v81 = *(_QWORD *)(v69 + 24);
      if (v81 <= *((_QWORD *)v77 + 3) - (_QWORD)v79)
      {
        if (v81)
        {
          memcpy(v79, v80, *(_QWORD *)(v69 + 24));
          v82 = v307;
          v79 = (_DWORD *)(*((_QWORD *)v307 + 4) + v81);
          *((_QWORD *)v307 + 4) = v79;
        }
        else
        {
          v82 = v307;
        }
      }
      else
      {
        v82 = llvm::raw_ostream::write(v77, (const char *)v80, *(_QWORD *)(v69 + 24));
        v79 = (_DWORD *)*((_QWORD *)v82 + 4);
      }
      v34 = v312;
      if (*((_QWORD *)v82 + 3) - (_QWORD)v79 > 0x13uLL)
      {
        v79[4] = 169963637;
        *(_OWORD *)v79 = *(_OWORD *)"' is all messed up!\n";
        *((_QWORD *)v82 + 4) += 20;
      }
      else
      {
        v82 = llvm::raw_ostream::write(v82, "' is all messed up!\n", 0x14uLL);
      }
      v27 = (unint64_t)sub_1C5E21910(v82, *(unsigned int *)(v325 + 40), 0, 0, 0);
      goto LABEL_115;
    }
LABEL_116:
    v67 |= (*(_WORD *)(v69 + 10) & 5) == 1;
    v65 += 8;
  }
  while (v68 != v65);
  v84 = (const char **)v306;
  v85 = v311;
  if ((v67 & 1) != 0)
  {
    v301 = 1;
    v38 = v325;
  }
  else
  {
    v38 = v325;
    v301 = *(_QWORD *)(v325 + 160) != 0;
  }
LABEL_124:
  v353 = v355;
  v354 = 0x400000000;
  v333 = v37;
  v86 = v307;
  if ((int)v37 >= v85)
  {
    v234 = 0;
    goto LABEL_439;
  }
  v87 = 0;
  v316 = 0;
  v299 = v84 + 1;
  v317 = v66;
  while (2)
  {
    v331[0] = 0;
    v331[1] = 0;
    v332 = 0;
    v329 = 0;
    v330 = 0;
    __s1 = &unk_1C876C4D5;
    v328 = 0;
    *(_QWORD *)v322 = v87;
    v323 = (int)v37;
    v88 = (char *)v84[(int)v37];
    if (*v88 != 45 || (v89 = v88[1], (v88[1] == 0) | v316 & 1))
    {
      if (v87)
      {
        v90 = strlen(v84[(int)v37]);
        LODWORD(__p[0]) = v37;
        v27 = sub_1C5DDB478(v87, *((_QWORD *)v87 + 2), *((_QWORD *)v87 + 3), v88, v90, 0, 0, __p);
        goto LABEL_174;
      }
      if (*(_DWORD *)(v38 + 40))
      {
        v91 = (void *)strlen(v84[(int)v37]);
        __p[0] = (void *)v84[(int)v37];
        __p[1] = v91;
        LODWORD(__src) = v37;
        v27 = sub_1C4926708((uint64_t)&v353, (unint64_t)__p, 1);
        v92 = (char *)v353 + 24 * v354;
        v93 = *(_OWORD *)v27;
        *((_QWORD *)v92 + 2) = *(_QWORD *)(v27 + 16);
        *(_OWORD *)v92 = v93;
        LODWORD(v354) = v354 + 1;
        if (v354 >= v66 && *(_QWORD *)(v38 + 160))
        {
          v94 = v37 + 1;
          if ((int)v37 + 1 < v85)
          {
            v95 = &v299[(int)v37];
            do
            {
              if (*v95)
                v96 = (void *)strlen(*v95);
              else
                v96 = 0;
              __p[0] = (void *)*v95;
              __p[1] = v96;
              LODWORD(__src) = v94;
              v27 = sub_1C4926708((uint64_t)&v353, (unint64_t)__p, 1);
              v97 = (char *)v353 + 24 * v354;
              v98 = *(_OWORD *)v27;
              *((_QWORD *)v97 + 2) = *(_QWORD *)(v27 + 16);
              *(_OWORD *)v97 = v98;
              LODWORD(v354) = v354 + 1;
              ++v94;
              ++v95;
            }
            while (v85 != v94);
            v94 = v85;
          }
          v87 = 0;
          v333 = v94;
          v99 = 7;
          goto LABEL_345;
        }
        v87 = 0;
LABEL_174:
        v99 = 9;
        goto LABEL_345;
      }
      v104 = 0;
LABEL_161:
      v105 = *(unsigned int *)(v38 + 88);
      if ((_DWORD)v105)
      {
        v37 = v333;
        v323 = (int)v333;
        v34 = v312;
        goto LABEL_338;
      }
      v124 = *(unsigned __int8 *)(v312 + 23);
      v125 = (v124 & 0x80u) != 0;
      if ((v124 & 0x80u) == 0)
        v126 = (const char *)v312;
      else
        v126 = *(const char **)v312;
      v127 = v124 & 0x7F;
      if (v125)
        v128 = *(_QWORD *)(v312 + 8);
      else
        v128 = v127;
      v27 = (unint64_t)llvm::raw_ostream::write(v86, v126, v128);
      v129 = (void *)*((_QWORD *)v86 + 4);
      if (*((_QWORD *)v86 + 3) - (_QWORD)v129 > 0x20uLL)
      {
        qmemcpy(v129, ": Unknown command line argument '", 33);
        v130 = (_WORD *)(*((_QWORD *)v86 + 4) + 33);
        *((_QWORD *)v86 + 4) = v130;
      }
      else
      {
        v27 = (unint64_t)llvm::raw_ostream::write(v86, ": Unknown command line argument '", 0x21uLL);
        v130 = (_WORD *)*((_QWORD *)v86 + 4);
      }
      v131 = v84[v333];
      if (v131)
      {
        v27 = strlen(v84[v333]);
        v132 = v27;
        if (v27 <= *((_QWORD *)v86 + 3) - (_QWORD)v130)
        {
          if (v27)
          {
            v27 = (unint64_t)memcpy(v130, v131, v27);
            v130 = (_WORD *)(*((_QWORD *)v86 + 4) + v132);
            *((_QWORD *)v86 + 4) = v130;
          }
        }
        else
        {
          v27 = (unint64_t)llvm::raw_ostream::write(v86, v131, v27);
          v130 = (_WORD *)*((_QWORD *)v86 + 4);
        }
      }
      if (*((_QWORD *)v86 + 3) - (_QWORD)v130 > 9uLL)
      {
        v130[4] = 10016;
        *(_QWORD *)v130 = *(_QWORD *)"'.  Try: '";
        v133 = (_BYTE *)(*((_QWORD *)v86 + 4) + 10);
        *((_QWORD *)v86 + 4) = v133;
      }
      else
      {
        v27 = (unint64_t)llvm::raw_ostream::write(v86, "'.  Try: '", 0xAuLL);
        v133 = (_BYTE *)*((_QWORD *)v86 + 4);
      }
      v134 = *v84;
      if (*v84)
      {
        v27 = strlen(*v84);
        v135 = v27;
        if (v27 <= *((_QWORD *)v86 + 3) - (_QWORD)v133)
        {
          if (v27)
          {
            v27 = (unint64_t)memcpy(v133, v134, v27);
            v133 = (_BYTE *)(*((_QWORD *)v86 + 4) + v135);
            *((_QWORD *)v86 + 4) = v133;
          }
        }
        else
        {
          v27 = (unint64_t)llvm::raw_ostream::write(v86, v134, v27);
          v133 = (_BYTE *)*((_QWORD *)v86 + 4);
        }
      }
      if (*((_QWORD *)v86 + 3) - (_QWORD)v133 > 8uLL)
      {
        v133[8] = 10;
        *(_QWORD *)v133 = *(_QWORD *)" --help'\n";
        *((_QWORD *)v86 + 4) += 9;
      }
      else
      {
        v27 = (unint64_t)llvm::raw_ostream::write(v86, " --help'\n", 9uLL);
      }
      v87 = *(unsigned __int16 **)v322;
      if (!v104)
      {
        v99 = 9;
        v321 = 1;
        v34 = v312;
        goto LABEL_345;
      }
      v34 = v312;
      v136 = *(_BYTE *)(v312 + 23);
      v137 = v136 < 0;
      if (v136 >= 0)
        v138 = (const char *)v312;
      else
        v138 = *(const char **)v312;
      v139 = v136 & 0x7F;
      if (v137)
        v140 = *(_QWORD *)(v312 + 8);
      else
        v140 = v139;
      llvm::raw_ostream::write(v86, v138, v140);
      v141 = (_OWORD *)*((_QWORD *)v86 + 4);
      if (*((_QWORD *)v86 + 3) - (_QWORD)v141 > 0xFuLL)
      {
        *v141 = *(_OWORD *)": Did you mean '";
        *((_QWORD *)v86 + 4) += 16;
      }
      else
      {
        llvm::raw_ostream::write(v86, ": Did you mean '", 0x10uLL);
      }
      v142 = (void **)v331[0];
      if (v332 >= 0)
        v142 = v331;
      v143 = (void *)(HIBYTE(v332) & 0x7F);
      if (v332 < 0)
        v143 = v331[1];
      __p[0] = v142;
      __p[1] = v143;
      __src = 0;
      v27 = (unint64_t)sub_1C5DDED60(v86, (uint64_t)__p);
      v144 = *((_QWORD *)v86 + 4);
      if ((unint64_t)(*((_QWORD *)v86 + 3) - v144) > 2)
      {
        *(_BYTE *)(v144 + 2) = 10;
        *(_WORD *)v144 = 16167;
        *((_QWORD *)v86 + 4) += 3;
      }
      else
      {
        v27 = (unint64_t)llvm::raw_ostream::write(v86, "'?\n", 3uLL);
      }
      v99 = 9;
LABEL_225:
      v321 = 1;
      goto LABEL_345;
    }
    if (v89 == 45 && !v88[2])
    {
      v316 = 1;
      v99 = 9;
      goto LABEL_344;
    }
    if (v87 && (v87[5] & 0x400) != 0)
    {
      v106 = strlen(v88 + 1);
      __s1 = v88 + 1;
      v328 = v106;
      v107 = v89 != 45 || v106 == 0;
      v108 = v107;
      if (!v107)
      {
        __s1 = v88 + 2;
        v328 = v106 - 1;
      }
      v27 = sub_1C5DE4980(v38, (uint64_t)&__s1, &v329, v304, v108 ^ 1u);
      if (!v27 || (v87 = (unsigned __int16 *)v27, (*(_WORD *)(v27 + 10) & 0x180) != 0x80))
      {
        v109 = strlen(v88);
        LODWORD(__p[0]) = v37;
        v87 = *(unsigned __int16 **)v322;
        v27 = sub_1C5DDB478(*(unsigned __int16 **)v322, *(_QWORD *)(*(_QWORD *)v322 + 16), *(_QWORD *)(*(_QWORD *)v322 + 24), v88, v109, 0, 0, __p);
        v316 = 0;
        goto LABEL_174;
      }
      goto LABEL_155;
    }
    v100 = strlen(v88 + 1);
    __s1 = v88 + 1;
    v328 = v100;
    v101 = v89 != 45 || v100 == 0;
    v102 = v101;
    if (!v101)
    {
      __s1 = v88 + 2;
      v328 = v100 - 1;
    }
    v103 = v102 ^ 1;
    v27 = sub_1C5DE4980(v38, (uint64_t)&__s1, &v329, v304, v102 ^ 1u);
    if (v27)
    {
      v87 = (unsigned __int16 *)v27;
LABEL_155:
      if ((v87[5] & 0x180) != 0x80)
      {
        v27 = sub_1C5DDB478(v87, (uint64_t)__s1, v328, v329, v330, v85, (uint64_t)v84, &v333);
        v99 = 0;
        v316 = 0;
        v321 |= v27;
        goto LABEL_344;
      }
      v99 = 0;
      if ((v87[5] & 0x400) == 0 || !v330)
      {
        v316 = 0;
        goto LABEL_345;
      }
      __p[0] = "This argument does not take a value.\n"
               "\tInstead, it consumes any positional arguments until the next recognized option.";
      LOWORD(v365) = 259;
      v27 = llvm::cl::Option::error(v87, (llvm::Twine *)__p, 0, 0, v86);
      v99 = 0;
      v316 = 0;
      goto LABEL_225;
    }
    if ((v103 & v304 & 1) != 0)
    {
      v302 = v328;
      goto LABEL_337;
    }
    __n = v328;
    if (v328 == 1)
    {
      v302 = 1;
      goto LABEL_337;
    }
    v110 = (unsigned __int8 *)__s1;
    v111 = *(unsigned int *)(v38 + 136);
    v318 = v111;
    if ((_DWORD)v111)
    {
      v112 = v328;
      if (v328)
      {
        v113 = 0;
        v114 = v328;
        v115 = (unsigned __int8 *)__s1;
        do
        {
          v116 = *v115++;
          v113 = 33 * v113 + v116;
          --v114;
        }
        while (v114);
      }
      else
      {
        v113 = 0;
      }
      v117 = v111 - 1;
      v118 = *(_QWORD *)(v38 + 128);
      v119 = v118 + 8 * v111;
      v120 = 1;
      for (i = v113; ; i = v122 + v120++)
      {
        v122 = i & v117;
        v123 = *(_QWORD **)(v118 + 8 * v122);
        if (v123 != (_QWORD *)-8)
        {
          if (!v123)
            goto LABEL_235;
          if (*(_DWORD *)(v119 + 8 + 4 * v122) == v113 && v112 == *v123)
          {
            if (!v112)
              break;
            v27 = memcmp(v110, (char *)v123 + *(unsigned int *)(v325 + 148), v112);
            if (!(_DWORD)v27)
              break;
          }
        }
      }
      if ((_DWORD)v122 == -1)
      {
LABEL_235:
        v111 = v318;
        v146 = v318;
        goto LABEL_236;
      }
      v145 = v118 + 8 * (int)v122;
      v111 = v318;
      if ((int)v122 != v318 && (*(_WORD *)(*(_QWORD *)(*(_QWORD *)v145 + 8) + 10) & 0x1100) == 0)
        v145 = v119;
      v146 = v318;
    }
    else
    {
      v146 = 0;
      v118 = *(_QWORD *)(v38 + 128);
      v112 = v328;
LABEL_236:
      v145 = v118 + 8 * v146;
    }
    v147 = v118 + 8 * v146;
    v148 = v145 == v147;
    if (v145 == v147 && v112 >= 2)
    {
      v308 = v146;
      v149 = v111 - 1;
      v150 = v118 + 8 * v111 + 8;
      v151 = v112;
      do
      {
        if (v151 >= v151 - 1)
          --v151;
        v152 = v145;
        if ((_DWORD)v111)
        {
          v153 = 0;
          v154 = 0;
          do
            v154 = 33 * v154 + v110[v153++];
          while (v151 != v153);
          v155 = 1;
          for (j = v154; ; j = v157 + v155++)
          {
            v157 = j & v149;
            v158 = *(_QWORD **)(v118 + 8 * v157);
            if (v158 != (_QWORD *)-8)
            {
              if (!v158)
              {
                v152 = v145;
                LODWORD(v111) = v318;
                goto LABEL_253;
              }
              if (*(_DWORD *)(v150 + 4 * v157) == v154 && v151 == *v158)
              {
                v27 = memcmp(v110, (char *)v158 + *(unsigned int *)(v325 + 148), v151);
                if (!(_DWORD)v27)
                  break;
              }
            }
          }
          v152 = v145;
          LODWORD(v111) = v318;
          if ((_DWORD)v157 != -1)
          {
            v152 = v118 + 8 * (int)v157;
            if (v308 != (int)v157 && (*(_WORD *)(*(_QWORD *)(*(_QWORD *)v152 + 8) + 10) & 0x1100) == 0)
              v152 = v145;
          }
        }
LABEL_253:
        v148 = v152 == v145;
      }
      while (v152 == v145 && v151 > 1);
    }
    else
    {
      v152 = v145;
      v151 = v112;
    }
    if (v148)
    {
      v34 = v312;
      v302 = __n;
      v38 = v325;
      v84 = (const char **)v306;
      v86 = v307;
      v85 = v311;
      v66 = v317;
      goto LABEL_337;
    }
    v87 = *(unsigned __int16 **)(*(_QWORD *)v152 + 8);
    v159 = v87[5];
    v34 = v312;
    v86 = v307;
    v85 = v311;
    v66 = v317;
    if ((v159 & 0x1100) == 0)
    {
      v302 = __n;
      v38 = v325;
LABEL_333:
      v84 = (const char **)v306;
      goto LABEL_337;
    }
    v160 = __n - v151;
    if (__n < v151)
      v160 = 0;
    v302 = v160;
    if (__n >= v151)
      v161 = v151;
    else
      v161 = __n;
    v328 = v161;
    if (v151 >= __n)
    {
      v162 = 0;
      v38 = v325;
      goto LABEL_432;
    }
    v162 = &v110[v151];
    while (2)
    {
      v163 = (v159 >> 7) & 3;
      if (v163 == 3)
        goto LABEL_431;
      v38 = v325;
      if (v163 == 2)
      {
        v328 = v161;
        if (*v162 != 61)
          goto LABEL_432;
        goto LABEL_430;
      }
      if (*v162 == 61)
      {
        v328 = v161;
LABEL_430:
        ++v162;
        --v302;
        goto LABEL_432;
      }
      v164 = (llvm *)((v159 >> 3) & 3);
      if (!(_DWORD)v164)
        v164 = (llvm *)(*(uint64_t (**)(unsigned __int16 *))(*(_QWORD *)v87 + 8))(v87);
      if ((_DWORD)v164 == 2)
      {
        v328 = v161;
        __p[0] = "may not occur within a group!";
        LOWORD(v365) = 259;
        v233 = (llvm::raw_ostream *)llvm::errs(v164);
        llvm::cl::Option::error(v87, (llvm::Twine *)__p, 0, 0, v233);
        v321 = 1;
        v302 = v161;
        goto LABEL_333;
      }
      LODWORD(__p[0]) = 0;
      v27 = sub_1C5DDB478(v87, (uint64_t)v110, v161, 0, 0, 0, 0, __p);
      __s1 = v162;
      v165 = *(unsigned int *)(v325 + 136);
      v319 = v165;
      __na = v27;
      if (!(_DWORD)v165)
      {
        v178 = 0;
        v172 = *(_QWORD *)(v325 + 128);
        v166 = v302;
        goto LABEL_291;
      }
      v166 = v302;
      if (v302)
      {
        v167 = 0;
        v168 = v302;
        v169 = v162;
        do
        {
          v170 = *v169++;
          v167 = 33 * v167 + v170;
          --v168;
        }
        while (v168);
      }
      else
      {
        v167 = 0;
      }
      v171 = v165 - 1;
      v172 = *(_QWORD *)(v325 + 128);
      v173 = v172 + 8 * v165;
      v174 = 1;
      for (k = v167; ; k = v176 + v174++)
      {
        v176 = k & v171;
        v177 = *(_QWORD **)(v172 + 8 * v176);
        if (v177 != (_QWORD *)-8)
        {
          if (!v177)
          {
            v165 = v319;
            v178 = v319;
            v66 = v317;
            goto LABEL_291;
          }
          if (*(_DWORD *)(v173 + 8 + 4 * v176) == v167 && v302 == *v177)
          {
            if (!v302)
              break;
            v27 = memcmp(v162, (char *)v177 + *(unsigned int *)(v325 + 148), v302);
            if (!(_DWORD)v27)
              break;
          }
        }
      }
      v66 = v317;
      if ((_DWORD)v176 == -1)
      {
        v165 = v319;
        v178 = v319;
LABEL_291:
        v179 = v172 + 8 * v178;
        goto LABEL_292;
      }
      v179 = v172 + 8 * (int)v176;
      v165 = v319;
      if ((int)v176 != v319 && (*(_WORD *)(*(_QWORD *)(*(_QWORD *)v179 + 8) + 10) & 0x1000) == 0)
        v179 = v173;
      v178 = v319;
LABEL_292:
      v180 = v172 + 8 * v178;
      v181 = v179 == v180;
      if (v179 == v180 && v166 >= 2)
      {
        v309 = v178;
        v182 = v165 - 1;
        v183 = v172 + 8 * v165 + 8;
        v184 = v166;
        do
        {
          if (v184 >= v184 - 1)
            --v184;
          v185 = v179;
          if ((_DWORD)v165)
          {
            v186 = 0;
            v187 = 0;
            do
              v187 = 33 * v187 + v162[v186++];
            while (v184 != v186);
            v188 = 1;
            for (m = v187; ; m = v190 + v188++)
            {
              v190 = m & v182;
              v191 = *(_QWORD **)(v172 + 8 * v190);
              if (v191 != (_QWORD *)-8)
              {
                if (!v191)
                {
                  v185 = v179;
                  v66 = v317;
                  LODWORD(v165) = v319;
                  goto LABEL_308;
                }
                if (*(_DWORD *)(v183 + 4 * v190) == v187 && v184 == *v191)
                {
                  v27 = memcmp(v162, (char *)v191 + *(unsigned int *)(v325 + 148), v184);
                  if (!(_DWORD)v27)
                    break;
                }
              }
            }
            v185 = v179;
            v66 = v317;
            LODWORD(v165) = v319;
            if ((_DWORD)v190 != -1)
            {
              v185 = v172 + 8 * (int)v190;
              if (v309 != (int)v190 && (*(_WORD *)(*(_QWORD *)(*(_QWORD *)v185 + 8) + 10) & 0x1000) == 0)
                v185 = v179;
            }
          }
LABEL_308:
          v181 = v185 == v179;
        }
        while (v185 == v179 && v184 > 1);
      }
      else
      {
        v185 = v179;
        v184 = v166;
      }
      v321 |= __na;
      if (!v181)
      {
        v87 = *(unsigned __int16 **)(*(_QWORD *)v185 + 8);
        v159 = v87[5];
        if ((v159 & 0x1000) != 0)
        {
          __s1 = v162;
          v110 = v162;
          v162 += v184;
          v192 = v302;
          v193 = v302 - v184;
          if (v302 >= v184)
          {
            v161 = v184;
          }
          else
          {
            v193 = 0;
            v161 = v302;
          }
          v302 = v193;
          v34 = v312;
          v86 = v307;
          v85 = v311;
          if (v184 < v192)
            continue;
          v162 = 0;
          v302 = v193;
LABEL_431:
          v38 = v325;
          v328 = v161;
LABEL_432:
          v329 = v162;
          v330 = v302;
          v84 = (const char **)v306;
          goto LABEL_155;
        }
      }
      break;
    }
    v328 = v302;
    v34 = v312;
    v38 = v325;
    v84 = (const char **)v306;
    v86 = v307;
    v85 = v311;
LABEL_337:
    v105 = *(unsigned int *)(v38 + 88);
    if (!(_DWORD)v105)
    {
      v198 = (unsigned __int8 *)__s1;
      v345 = (unsigned __int8 *)__s1;
      v346 = v302;
      if (!v302)
        goto LABEL_418;
      LOBYTE(__p[0]) = 61;
      v199 = llvm::StringRef::find((uint64_t *)&v345, (char *)__p, 1uLL, 0);
      if (v302 >= v199)
        v200 = v199;
      else
        v200 = v302;
      if (v302 >= v199 + 1)
        v201 = v199 + 1;
      else
        v201 = v302;
      v202 = &v198[v201];
      v203 = v302 - v201;
      if (v199 == -1)
        v202 = 0;
      v310 = (unint64_t)v202;
      if (v199 == -1)
        v203 = 0;
      __nb = v203;
      if (v199 == -1)
        v200 = v302;
      v300 = v200;
      v204 = *(unsigned int *)(v38 + 136);
      if ((_DWORD)v204)
      {
        for (n = *(uint64_t **)(v38 + 128); !*n || *n == -8; ++n)
          ;
      }
      else
      {
        n = *(uint64_t **)(v38 + 128);
      }
      v207 = *(_QWORD *)(v38 + 128) + 8 * v204;
      if (n == (uint64_t *)v207)
      {
LABEL_418:
        v104 = 0;
LABEL_419:
        v86 = v307;
        goto LABEL_161;
      }
      v104 = 0;
      v208 = 0;
      v209 = *n;
      v298 = v198;
      v303 = v207;
      while (1)
      {
        v210 = *(_WORD **)(v209 + 8);
        if ((v210[5] & 0x60) != 0x40)
        {
          __p[0] = &__src;
          __p[1] = (void *)0x1000000000;
          (*(void (**)(_WORD *, void **))(*(_QWORD *)v210 + 72))(v210, __p);
          v211 = *((_QWORD *)v210 + 3);
          if (v211)
          {
            v212 = v198;
            v213 = v210;
            v214 = *((_QWORD *)v210 + 2);
            v215 = LODWORD(__p[1]);
            if (LODWORD(__p[1]) >= (unint64_t)HIDWORD(__p[1]))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)__p, (uint64_t)&__src, LODWORD(__p[1]) + 1, 16);
              v215 = LODWORD(__p[1]);
            }
            v216 = (char *)__p[0] + 16 * v215;
            *v216 = v214;
            v216[1] = v211;
            ++LODWORD(__p[1]);
            v210 = v213;
            v198 = v212;
            v85 = v311;
          }
          v217 = ((unsigned __int16)v210[5] >> 3) & 3;
          if (!v217)
            v217 = (*(uint64_t (**)(_WORD *))(*(_QWORD *)v210 + 8))(v210);
          v218 = (void **)__p[0];
          if (LODWORD(__p[1]))
          {
            v320 = v210;
            if (v217 == 3)
              v219 = v346;
            else
              v219 = v300;
            if (v217 == 3)
            {
              v198 = v345;
              v220 = 1;
            }
            else
            {
              v220 = __nb == 0;
            }
            v324 = v220;
            v221 = (unint64_t *)((char *)__p[0] + 8);
            v222 = 16 * LODWORD(__p[1]);
            while (1)
            {
              v223 = sub_1C5E3C880(*(v221 - 1), *v221, v198, v219, 1, v208);
              v224 = v223;
              if (!v104 || v223 < v208)
                break;
LABEL_407:
              v221 += 2;
              v222 -= 16;
              if (!v222)
              {
                v218 = (void **)__p[0];
                v84 = (const char **)v306;
                v85 = v311;
                v198 = v298;
                goto LABEL_409;
              }
            }
            if (!v324)
            {
              v228 = *v221;
              v337[0] = *(v221 - 1);
              v337[1] = v228;
              v337[2] = "=";
              v338 = 773;
              __dst[0] = v337;
              v340 = v310;
              v341 = __nb;
              v342 = 1282;
              llvm::Twine::str((llvm::Twine *)__dst, &v343);
              if (SHIBYTE(v332) < 0)
                operator delete(v331[0]);
              *(_OWORD *)v331 = v343;
              v332 = v344;
              v208 = v224;
              v104 = v320;
              goto LABEL_407;
            }
            v225 = *v221;
            if (*v221 > 0x7FFFFFFFFFFFFFF7)
              goto LABEL_550;
            v226 = (const void *)*(v221 - 1);
            if (v225 >= 0x17)
            {
              v229 = (v225 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v225 | 7) != 0x17)
                v229 = v225 | 7;
              v230 = v229 + 1;
              v227 = operator new(v229 + 1);
              __dst[1] = (void *)v225;
              v340 = v230 | 0x8000000000000000;
              __dst[0] = v227;
            }
            else
            {
              HIBYTE(v340) = *v221;
              v227 = __dst;
              if (!v225)
                goto LABEL_404;
            }
            memmove(v227, v226, v225);
LABEL_404:
            v38 = v325;
            *((_BYTE *)v227 + v225) = 0;
            if (SHIBYTE(v332) < 0)
              operator delete(v331[0]);
            *(_OWORD *)v331 = *(_OWORD *)__dst;
            v332 = v340;
            v208 = v224;
            v104 = v320;
            v66 = v317;
            goto LABEL_407;
          }
LABEL_409:
          if (v218 != &__src)
            free(v218);
          v207 = v303;
        }
        do
        {
          v231 = n[1];
          ++n;
          v209 = v231;
          if (v231)
            v232 = v209 == -8;
          else
            v232 = 1;
        }
        while (v232);
        if (n == (uint64_t *)v207)
          goto LABEL_419;
      }
    }
LABEL_338:
    v194 = *(_QWORD **)(v38 + 80);
    v195 = 8 * v105;
    do
    {
      v196 = v84[v323];
      if (v196)
        v197 = strlen(v84[v323]);
      else
        v197 = 0;
      v27 = (*(uint64_t (**)(_QWORD, uint64_t, void *, _QWORD, const char *, size_t, _QWORD))(*(_QWORD *)*v194 + 80))(*v194, v37, &unk_1C876C4D5, 0, v196, v197, 0);
      ++v194;
      v195 -= 8;
    }
    while (v195);
    v99 = 9;
    v85 = v311;
LABEL_344:
    v87 = *(unsigned __int16 **)v322;
LABEL_345:
    if (SHIBYTE(v332) < 0)
      operator delete(v331[0]);
    if (v99 == 9 || !v99)
    {
      v37 = v333 + 1;
      v333 = v37;
      if ((int)v37 < v85)
        continue;
    }
    break;
  }
  v234 = v354;
LABEL_439:
  if (v234 < v66)
  {
    v235 = *(_BYTE *)(v34 + 23);
    v236 = v235 < 0;
    if (v235 >= 0)
      v237 = (const char *)v34;
    else
      v237 = *(const char **)v34;
    v238 = v235 & 0x7F;
    if (v236)
      v239 = *(_QWORD *)(v34 + 8);
    else
      v239 = v238;
    llvm::raw_ostream::write(v86, v237, v239);
    v240 = (void *)*((_QWORD *)v86 + 4);
    if (*((_QWORD *)v86 + 3) - (_QWORD)v240 > 0x39uLL)
    {
      qmemcpy(v240, ": Not enough positional command line arguments specified!\n", 58);
      v241 = (void *)(*((_QWORD *)v86 + 4) + 58);
      *((_QWORD *)v86 + 4) = v241;
    }
    else
    {
      llvm::raw_ostream::write(v86, ": Not enough positional command line arguments specified!\n", 0x3AuLL);
      v241 = (void *)*((_QWORD *)v86 + 4);
    }
    if (*((_QWORD *)v86 + 3) - (_QWORD)v241 > 0x15uLL)
    {
      qmemcpy(v241, "Must specify at least ", 22);
      *((_QWORD *)v86 + 4) += 22;
    }
    else
    {
      llvm::raw_ostream::write(v86, "Must specify at least ", 0x16uLL);
    }
    sub_1C5E21910(v86, v66, 0, 0, 0);
    v242 = *((_QWORD *)v86 + 4);
    if ((unint64_t)(*((_QWORD *)v86 + 3) - v242) > 0x13)
    {
      *(_DWORD *)(v242 + 16) = 1953391981;
      *(_OWORD *)v242 = *(_OWORD *)" positional argument";
      v27 = *((_QWORD *)v86 + 4) + 20;
      *((_QWORD *)v86 + 4) = v27;
    }
    else
    {
      llvm::raw_ostream::write(v86, " positional argument", 0x14uLL);
      v27 = *((_QWORD *)v86 + 4);
    }
    v243 = v66 > 1;
    if (*((_QWORD *)v86 + 3) - v27 >= v243)
    {
      if (v66 >= 2)
      {
        memcpy((void *)v27, "s", v66 > 1);
        v27 = *((_QWORD *)v86 + 4) + v243;
        *((_QWORD *)v86 + 4) = v27;
      }
    }
    else
    {
      if (v66 <= 1)
        v244 = (const char *)&unk_1C876C4D5;
      else
        v244 = "s";
      llvm::raw_ostream::write(v86, v244, v66 > 1);
      v27 = *((_QWORD *)v86 + 4);
    }
    if (*((_QWORD *)v86 + 3) - v27 <= 6)
    {
      v245 = ": See: ";
      v246 = v86;
      v247 = 7;
      goto LABEL_487;
    }
    *(_DWORD *)(v27 + 3) = 540697957;
    *(_DWORD *)v27 = 1699946554;
    v269 = (_QWORD *)(*((_QWORD *)v86 + 4) + 7);
LABEL_549:
    *((_QWORD *)v86 + 4) = v269;
    goto LABEL_488;
  }
  v248 = *(unsigned int *)(v38 + 40);
  v249 = v301;
  if (v234 <= v248)
    v249 = 1;
  if ((v249 & 1) != 0)
  {
    if (*(_QWORD *)(v38 + 160))
    {
      if (!(_DWORD)v248)
      {
        v251 = 0;
        v253 = v321;
        goto LABEL_534;
      }
      v250 = 0;
      v251 = 0;
      v252 = 8 * v248;
      v253 = v321;
      do
      {
        v27 = *(_QWORD *)(*(_QWORD *)(v38 + 32) + v250);
        if ((*(_WORD *)(v27 + 10) & 6) == 2)
        {
          v254 = (char *)v353 + 24 * v251;
          v255 = *(_BYTE **)v254;
          v256 = *((_QWORD *)v254 + 1);
          LODWORD(__p[0]) = *((_DWORD *)v254 + 4);
          v27 = sub_1C5DDB478((unsigned __int16 *)v27, *(_QWORD *)(v27 + 16), *(_QWORD *)(v27 + 24), v255, v256, 0, 0, __p);
          v253 |= v27;
          ++v251;
        }
        v250 += 8;
      }
      while (v252 != v250);
      v234 = v354;
      if (*(_DWORD *)(v38 + 40) == 1 && v251 == 0)
      {
        if ((_DWORD)v354)
        {
          v258 = **(_QWORD **)(v38 + 32);
          v259 = *(_BYTE **)v353;
          v260 = *((_QWORD *)v353 + 1);
          LODWORD(__p[0]) = *((_DWORD *)v353 + 4);
          v27 = sub_1C5DDB478((unsigned __int16 *)v258, *(_QWORD *)(v258 + 16), *(_QWORD *)(v258 + 24), v259, v260, 0, 0, __p);
          v253 |= v27;
          v251 = 1;
          v234 = v354;
          goto LABEL_534;
        }
      }
      else
      {
LABEL_534:
        if (v234 != v251)
        {
          do
          {
            v294 = *(_QWORD *)(v38 + 160);
            v295 = (char *)v353 + 24 * v251;
            v296 = *(_BYTE **)v295;
            v297 = *((_QWORD *)v295 + 1);
            LODWORD(__p[0]) = *((_DWORD *)v295 + 4);
            v27 = sub_1C5DDB478((unsigned __int16 *)v294, *(_QWORD *)(v294 + 16), *(_QWORD *)(v294 + 24), v296, v297, 0, 0, __p);
            v253 |= v27;
            ++v251;
          }
          while (v251 != (_DWORD)v354);
        }
      }
    }
    else
    {
      if ((_DWORD)v248)
      {
        v282 = 0;
        v283 = 0;
        do
        {
          v27 = *(_QWORD *)(*(_QWORD *)(v38 + 32) + 8 * v282);
          v284 = *(_WORD *)(v27 + 10);
          if ((v284 & 6) == 2)
          {
            v285 = (char *)v353 + 24 * v283;
            v286 = *(_BYTE **)v285;
            v287 = *((_QWORD *)v285 + 1);
            LODWORD(__p[0]) = *((_DWORD *)v285 + 4);
            v27 = sub_1C5DDB478((unsigned __int16 *)v27, *(_QWORD *)(v27 + 16), *(_QWORD *)(v27 + 24), v286, v287, 0, 0, __p);
            ++v283;
            --v66;
            v284 = *(_WORD *)(*(_QWORD *)(*(_QWORD *)(v38 + 32) + 8 * v282) + 10);
          }
          if (v234 - v283 > v66 && (v284 & 7) != 2)
          {
            v288 = v234 - 1 - v283;
            do
            {
              v289 = *(_QWORD *)(*(_QWORD *)(v38 + 32) + 8 * v282);
              v290 = *(_WORD *)(v289 + 10);
              v291 = (char *)v353 + 24 * v283;
              v292 = *(_BYTE **)v291;
              v293 = *((_QWORD *)v291 + 1);
              LODWORD(__p[0]) = *((_DWORD *)v291 + 4);
              v27 = sub_1C5DDB478((unsigned __int16 *)v289, *(_QWORD *)(v289 + 16), *(_QWORD *)(v289 + 24), v292, v293, 0, 0, __p);
              ++v283;
              if (v288 <= v66)
                break;
              --v288;
            }
            while ((v290 & 7) != 0);
          }
          ++v282;
        }
        while (v282 != v248);
      }
      v253 = v321;
    }
  }
  else
  {
    v261 = *(_BYTE *)(v34 + 23);
    v262 = v261 < 0;
    if (v261 >= 0)
      v263 = (const char *)v34;
    else
      v263 = *(const char **)v34;
    v264 = v261 & 0x7F;
    if (v262)
      v265 = *(_QWORD *)(v34 + 8);
    else
      v265 = v264;
    llvm::raw_ostream::write(v86, v263, v265);
    v266 = (void *)*((_QWORD *)v86 + 4);
    if (*((_QWORD *)v86 + 3) - (_QWORD)v266 > 0x2AuLL)
    {
      qmemcpy(v266, ": Too many positional arguments specified!\n", 43);
      v267 = *((_QWORD *)v86 + 4) + 43;
      *((_QWORD *)v86 + 4) = v267;
    }
    else
    {
      llvm::raw_ostream::write(v86, ": Too many positional arguments specified!\n", 0x2BuLL);
      v267 = *((_QWORD *)v86 + 4);
    }
    if ((unint64_t)(*((_QWORD *)v86 + 3) - v267) > 0x13)
    {
      *(_DWORD *)(v267 + 16) = 544502639;
      *(_OWORD *)v267 = *(_OWORD *)"Can specify at most ";
      *((_QWORD *)v86 + 4) += 20;
    }
    else
    {
      llvm::raw_ostream::write(v86, "Can specify at most ", 0x14uLL);
    }
    v27 = (unint64_t)sub_1C5E21910(v86, *(unsigned int *)(v38 + 40), 0, 0, 0);
    v268 = (void *)*((_QWORD *)v86 + 4);
    if (*((_QWORD *)v86 + 3) - (_QWORD)v268 > 0x1BuLL)
    {
      qmemcpy(v268, " positional arguments: See: ", 28);
      v269 = (_QWORD *)(*((_QWORD *)v86 + 4) + 28);
      goto LABEL_549;
    }
    v245 = " positional arguments: See: ";
    v246 = v86;
    v247 = 28;
LABEL_487:
    v27 = (unint64_t)llvm::raw_ostream::write(v246, v245, v247);
    v269 = (_QWORD *)*((_QWORD *)v86 + 4);
LABEL_488:
    v270 = *v84;
    if (*v84)
    {
      v27 = strlen(*v84);
      v271 = v27;
      if (v27 <= *((_QWORD *)v86 + 3) - (_QWORD)v269)
      {
        if (v27)
        {
          v27 = (unint64_t)memcpy(v269, v270, v27);
          v269 = (_QWORD *)(*((_QWORD *)v86 + 4) + v271);
          *((_QWORD *)v86 + 4) = v269;
        }
      }
      else
      {
        v27 = (unint64_t)llvm::raw_ostream::write(v86, v270, v27);
        v269 = (_QWORD *)*((_QWORD *)v86 + 4);
      }
    }
    if (*((_QWORD *)v86 + 3) - (_QWORD)v269 > 7uLL)
    {
      *v269 = 0xA706C65682D2D20;
      *((_QWORD *)v86 + 4) += 8;
    }
    else
    {
      v27 = (unint64_t)llvm::raw_ostream::write(v86, " --help\n", 8uLL);
    }
    v253 = 1;
  }
  v272 = *(unsigned int *)(v38 + 136);
  if ((_DWORD)v272)
  {
    for (ii = *(uint64_t **)(v38 + 128); !*ii || *ii == -8; ++ii)
      ;
  }
  else
  {
    ii = *(uint64_t **)(v38 + 128);
  }
  v275 = *(_QWORD *)(v38 + 128) + 8 * v272;
  if (ii != (uint64_t *)v275)
  {
    v276 = *ii;
    do
    {
      v277 = *(_QWORD *)(v276 + 8);
      if ((*(_WORD *)(v277 + 10) & 6) == 2 && !*(_WORD *)(v277 + 8))
      {
        __p[0] = "must be specified at least once!";
        LOWORD(v365) = 259;
        v280 = (llvm::raw_ostream *)llvm::errs((llvm *)v27);
        v27 = llvm::cl::Option::error((_QWORD *)v277, (llvm::Twine *)__p, 0, 0, v280);
        v253 = 1;
      }
      do
      {
        v278 = ii[1];
        ++ii;
        v276 = v278;
        if (v278)
          v279 = v276 == -8;
        else
          v279 = 1;
      }
      while (v279);
    }
    while (ii != (uint64_t *)v275);
  }
  *(_QWORD *)(v312 + 48) = *(_QWORD *)(v312 + 40);
  if (!a5 && v253)
    exit(1);
  if (v353 != v355)
    free(v353);
  sub_1C4926AE8((uint64_t)v356);
  if (v359 != v361)
    free(v359);
  sub_1C4926AE8((uint64_t)v347);
  if (v350 != v352)
    free(v350);
  return v253 == 0;
}

void sub_1C5DDEC70(llvm *a1)
{
  llvm *v2;
  llvm *v3;
  llvm *v4;

  if (!atomic_load(qword_1ED825A30))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED825A30, (void *(*)(void))sub_1C5DE4BF0, (void (*)(void *))sub_1C5DE5210);
  llvm::initDebugCounterOptions(a1);
  llvm::initSignalsOptions(v2);
  llvm::initStatisticOptions(v3);
  llvm::initTimerOptions(v4);
  if (!atomic_load(qword_1ED836E58))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED836E58, (void *(*)(void))sub_1C5E503A8, (void (*)(void *))sub_1C6394640);
  if (!atomic_load(qword_1ED836E80))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED836E80, (void *(*)(void))sub_1C5E6609C, (void (*)(void *))sub_1C639AE44);
  if (!atomic_load(qword_1ED836BD0))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED836BD0, (void *(*)(void))sub_1C5E29F68, (void (*)(void *))sub_1C638DA60);
}

llvm::raw_ostream *sub_1C5DDED60(llvm::raw_ostream *a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  const char *v8;
  size_t v9;
  const void *v10;
  size_t v11;
  void *v12;
  void *v14;
  __int128 v15;
  _QWORD v16[2];

  v16[1] = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a2 + 8);
  v5 = *(_QWORD *)(a2 + 16);
  v14 = v16;
  v15 = xmmword_1C6464ED0;
  v6 = 0;
  if (v5)
  {
    do
    {
      if ((unint64_t)(v6 + 1) > *((_QWORD *)&v15 + 1))
      {
        llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v14, v16, v6 + 1, 1);
        v6 = v15;
      }
      *((_BYTE *)v14 + v6) = 32;
      v6 = v15 + 1;
      *(_QWORD *)&v15 = v15 + 1;
      --v5;
    }
    while (v5);
    v7 = *((_QWORD *)&v15 + 1);
  }
  else
  {
    v7 = 8;
  }
  if (v4 <= 1)
    v8 = "-";
  else
    v8 = "--";
  if (v4 <= 1)
    v9 = 1;
  else
    v9 = 2;
  if (v7 < v6 + v9)
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v14, v16, v6 + v9, 1);
    v6 = v15;
  }
  memcpy((char *)v14 + v6, v8, v9);
  *(_QWORD *)&v15 = v15 + v9;
  llvm::raw_ostream::write(a1, (const char *)v14, v15);
  v10 = *(const void **)a2;
  v11 = *(_QWORD *)(a2 + 8);
  v12 = (void *)*((_QWORD *)a1 + 4);
  if (v11 <= *((_QWORD *)a1 + 3) - (_QWORD)v12)
  {
    if (v11)
    {
      memcpy(v12, v10, v11);
      *((_QWORD *)a1 + 4) += v11;
    }
  }
  else
  {
    llvm::raw_ostream::write(a1, (const char *)v10, v11);
  }
  if (v14 != v16)
    free(v14);
  return a1;
}

llvm::raw_ostream *llvm::cl::Option::printHelpStr(uint64_t a1, unint64_t a2, unsigned int a3, int a4)
{
  llvm *v8;
  uint64_t v9;
  size_t v10;
  unint64_t v11;
  char *v12;
  llvm::raw_ostream *v13;
  llvm::raw_ostream *v14;
  uint64_t v15;
  llvm::raw_ostream *result;
  llvm *v17;
  size_t v18;
  uint64_t v19;
  const void *v20;
  size_t v21;
  char *v22;
  llvm::raw_ostream *v23;
  llvm::raw_ostream *v24;
  uint64_t v25;
  __int128 v26;
  uint64_t v27;
  size_t v28;
  __int128 v29;
  char v30;

  *(_QWORD *)&v29 = a1;
  *((_QWORD *)&v29 + 1) = a2;
  v30 = 10;
  v8 = (llvm *)llvm::StringRef::find((uint64_t *)&v29, &v30, 1uLL, 0);
  if (v8 == (llvm *)-1)
  {
    v9 = 0;
    v10 = 0;
    v26 = v29;
  }
  else
  {
    if (a2 >= (unint64_t)v8)
      v11 = (unint64_t)v8;
    else
      v11 = a2;
    if (a2 >= (unint64_t)v8 + 1)
      v12 = (char *)v8 + 1;
    else
      v12 = (char *)a2;
    v9 = (uint64_t)&v12[a1];
    v10 = a2 - (_QWORD)v12;
    *(_QWORD *)&v26 = a1;
    *((_QWORD *)&v26 + 1) = v11;
  }
  v27 = v9;
  v28 = v10;
  v13 = (llvm::raw_ostream *)llvm::outs(v8);
  v14 = llvm::raw_ostream::indent(v13, a3 - a4);
  v15 = *((_QWORD *)v14 + 4);
  if ((unint64_t)(*((_QWORD *)v14 + 3) - v15) > 2)
  {
    *(_BYTE *)(v15 + 2) = 32;
    *(_WORD *)v15 = 11552;
    result = (llvm::raw_ostream *)(*((_QWORD *)v13 + 4) + 3);
    *((_QWORD *)v13 + 4) = result;
  }
  else
  {
    llvm::raw_ostream::write(v13, " - ", 3uLL);
    result = (llvm::raw_ostream *)*((_QWORD *)v13 + 4);
  }
  if (*((_QWORD *)&v26 + 1) <= *((_QWORD *)v13 + 3) - (_QWORD)result)
  {
    if (*((_QWORD *)&v26 + 1))
    {
      memcpy(result, (const void *)v26, *((size_t *)&v26 + 1));
      result = (llvm::raw_ostream *)(*((_QWORD *)v13 + 4) + *((_QWORD *)&v26 + 1));
      *((_QWORD *)v13 + 4) = result;
    }
  }
  else
  {
    llvm::raw_ostream::write(v13, (const char *)v26, *((size_t *)&v26 + 1));
    result = (llvm::raw_ostream *)*((_QWORD *)v13 + 4);
  }
  if (*((llvm::raw_ostream **)v13 + 3) == result)
  {
    result = llvm::raw_ostream::write(v13, "\n", 1uLL);
    if (!v10)
      return result;
  }
  else
  {
    *(_BYTE *)result = 10;
    ++*((_QWORD *)v13 + 4);
    v10 = v28;
    if (!v28)
      return result;
  }
  do
  {
    v30 = 10;
    v17 = (llvm *)llvm::StringRef::find(&v27, &v30, 1uLL, 0);
    if (v17 == (llvm *)-1)
    {
      v18 = 0;
      v19 = 0;
      v20 = (const void *)v27;
    }
    else
    {
      if (v10 >= (unint64_t)v17)
        v21 = (size_t)v17;
      else
        v21 = v10;
      v20 = (const void *)v27;
      if (v10 >= (unint64_t)v17 + 1)
        v22 = (char *)v17 + 1;
      else
        v22 = (char *)v10;
      v19 = (uint64_t)&v22[v27];
      v18 = v10 - (_QWORD)v22;
      v10 = v21;
    }
    v27 = v19;
    v28 = v18;
    v23 = (llvm::raw_ostream *)llvm::outs(v17);
    v24 = llvm::raw_ostream::indent(v23, a3);
    v25 = *((_QWORD *)v24 + 3);
    result = (llvm::raw_ostream *)*((_QWORD *)v24 + 4);
    if (v10 <= v25 - (uint64_t)result)
    {
      if (v10)
      {
        memcpy(result, v20, v10);
        result = (llvm::raw_ostream *)(*((_QWORD *)v23 + 4) + v10);
        *((_QWORD *)v23 + 4) = result;
      }
    }
    else
    {
      llvm::raw_ostream::write(v23, (const char *)v20, v10);
      result = (llvm::raw_ostream *)*((_QWORD *)v23 + 4);
    }
    if (*((llvm::raw_ostream **)v23 + 3) == result)
    {
      result = llvm::raw_ostream::write(v23, "\n", 1uLL);
    }
    else
    {
      *(_BYTE *)result = 10;
      ++*((_QWORD *)v23 + 4);
    }
    v10 = v18;
  }
  while (v18);
  return result;
}

llvm::raw_ostream *llvm::cl::Option::printEnumValHelpStr(uint64_t a1, unint64_t a2, int a3, int a4)
{
  llvm *v8;
  uint64_t v9;
  size_t v10;
  unint64_t v11;
  char *v12;
  llvm::raw_ostream *v13;
  llvm::raw_ostream *v14;
  uint64_t v15;
  _WORD *v16;
  llvm::raw_ostream *result;
  unsigned int v18;
  llvm *v19;
  size_t v20;
  uint64_t v21;
  const void *v22;
  size_t v23;
  char *v24;
  llvm::raw_ostream *v25;
  llvm::raw_ostream *v26;
  uint64_t v27;
  __int128 v28;
  uint64_t v29;
  size_t v30;
  __int128 v31;
  char v32;

  *(_QWORD *)&v31 = a1;
  *((_QWORD *)&v31 + 1) = a2;
  v32 = 10;
  v8 = (llvm *)llvm::StringRef::find((uint64_t *)&v31, &v32, 1uLL, 0);
  if (v8 == (llvm *)-1)
  {
    v9 = 0;
    v10 = 0;
    v28 = v31;
  }
  else
  {
    if (a2 >= (unint64_t)v8)
      v11 = (unint64_t)v8;
    else
      v11 = a2;
    if (a2 >= (unint64_t)v8 + 1)
      v12 = (char *)v8 + 1;
    else
      v12 = (char *)a2;
    v9 = (uint64_t)&v12[a1];
    v10 = a2 - (_QWORD)v12;
    *(_QWORD *)&v28 = a1;
    *((_QWORD *)&v28 + 1) = v11;
  }
  v29 = v9;
  v30 = v10;
  v13 = (llvm::raw_ostream *)llvm::outs(v8);
  v14 = llvm::raw_ostream::indent(v13, a3 - a4);
  v15 = *((_QWORD *)v14 + 4);
  if ((unint64_t)(*((_QWORD *)v14 + 3) - v15) > 2)
  {
    *(_BYTE *)(v15 + 2) = 32;
    *(_WORD *)v15 = 11552;
    v16 = (_WORD *)(*((_QWORD *)v13 + 4) + 3);
    *((_QWORD *)v13 + 4) = v16;
  }
  else
  {
    llvm::raw_ostream::write(v13, " - ", 3uLL);
    v16 = (_WORD *)*((_QWORD *)v13 + 4);
  }
  if (*((_QWORD *)v13 + 3) - (_QWORD)v16 > 1uLL)
  {
    *v16 = 8224;
    result = (llvm::raw_ostream *)(*((_QWORD *)v13 + 4) + 2);
    *((_QWORD *)v13 + 4) = result;
  }
  else
  {
    llvm::raw_ostream::write(v13, "  ", 2uLL);
    result = (llvm::raw_ostream *)*((_QWORD *)v13 + 4);
  }
  if (*((_QWORD *)&v28 + 1) <= *((_QWORD *)v13 + 3) - (_QWORD)result)
  {
    if (*((_QWORD *)&v28 + 1))
    {
      memcpy(result, (const void *)v28, *((size_t *)&v28 + 1));
      result = (llvm::raw_ostream *)(*((_QWORD *)v13 + 4) + *((_QWORD *)&v28 + 1));
      *((_QWORD *)v13 + 4) = result;
    }
  }
  else
  {
    llvm::raw_ostream::write(v13, (const char *)v28, *((size_t *)&v28 + 1));
    result = (llvm::raw_ostream *)*((_QWORD *)v13 + 4);
  }
  if (*((llvm::raw_ostream **)v13 + 3) == result)
  {
    result = llvm::raw_ostream::write(v13, "\n", 1uLL);
    if (!v10)
      return result;
  }
  else
  {
    *(_BYTE *)result = 10;
    ++*((_QWORD *)v13 + 4);
    v10 = v30;
    if (!v30)
      return result;
  }
  v18 = a3 + 2;
  do
  {
    v32 = 10;
    v19 = (llvm *)llvm::StringRef::find(&v29, &v32, 1uLL, 0);
    if (v19 == (llvm *)-1)
    {
      v20 = 0;
      v21 = 0;
      v22 = (const void *)v29;
    }
    else
    {
      if (v10 >= (unint64_t)v19)
        v23 = (size_t)v19;
      else
        v23 = v10;
      v22 = (const void *)v29;
      if (v10 >= (unint64_t)v19 + 1)
        v24 = (char *)v19 + 1;
      else
        v24 = (char *)v10;
      v21 = (uint64_t)&v24[v29];
      v20 = v10 - (_QWORD)v24;
      v10 = v23;
    }
    v29 = v21;
    v30 = v20;
    v25 = (llvm::raw_ostream *)llvm::outs(v19);
    v26 = llvm::raw_ostream::indent(v25, v18);
    v27 = *((_QWORD *)v26 + 3);
    result = (llvm::raw_ostream *)*((_QWORD *)v26 + 4);
    if (v10 <= v27 - (uint64_t)result)
    {
      if (v10)
      {
        memcpy(result, v22, v10);
        result = (llvm::raw_ostream *)(*((_QWORD *)v25 + 4) + v10);
        *((_QWORD *)v25 + 4) = result;
      }
    }
    else
    {
      llvm::raw_ostream::write(v25, (const char *)v22, v10);
      result = (llvm::raw_ostream *)*((_QWORD *)v25 + 4);
    }
    if (*((llvm::raw_ostream **)v25 + 3) == result)
    {
      result = llvm::raw_ostream::write(v25, "\n", 1uLL);
    }
    else
    {
      *(_BYTE *)result = 10;
      ++*((_QWORD *)v25 + 4);
    }
    v10 = v20;
  }
  while (v20);
  return result;
}

uint64_t llvm::cl::parser<long>::parse(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t *a4, unint64_t a5, unint64_t a6, _QWORD *a7)
{
  llvm *v11;
  uint64_t v12;
  llvm::raw_ostream *v14;
  unint64_t v15[4];
  __int16 v16;
  unint64_t *v17;
  unint64_t v18;
  const char *v19;
  __int16 v20;

  v15[0] = 0;
  v17 = (unint64_t *)a5;
  v18 = a6;
  llvm::consumeSignedInteger((llvm *)&v17, 0, v15, a4);
  if (v18)
    v12 = 1;
  else
    v12 = v11;
  if ((v12 & 1) != 0)
  {
    v16 = 1283;
    v15[0] = (unint64_t)"'";
    v15[2] = a5;
    v15[3] = a6;
    v17 = v15;
    v19 = "' value invalid for long argument!";
    v20 = 770;
    v14 = (llvm::raw_ostream *)llvm::errs(v11);
    llvm::cl::Option::error(a2, (llvm::Twine *)&v17, 0, 0, v14);
  }
  else
  {
    *a7 = v15[0];
  }
  return v12;
}

uint64_t llvm::cl::parser<long long>::parse(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t *a4, unint64_t a5, unint64_t a6, _QWORD *a7)
{
  llvm *v11;
  uint64_t v12;
  llvm::raw_ostream *v14;
  unint64_t v15[4];
  __int16 v16;
  unint64_t *v17;
  unint64_t v18;
  const char *v19;
  __int16 v20;

  v15[0] = 0;
  v17 = (unint64_t *)a5;
  v18 = a6;
  llvm::consumeSignedInteger((llvm *)&v17, 0, v15, a4);
  if (v18)
    v12 = 1;
  else
    v12 = v11;
  if ((v12 & 1) != 0)
  {
    v16 = 1283;
    v15[0] = (unint64_t)"'";
    v15[2] = a5;
    v15[3] = a6;
    v17 = v15;
    v19 = "' value invalid for llong argument!";
    v20 = 770;
    v14 = (llvm::raw_ostream *)llvm::errs(v11);
    llvm::cl::Option::error(a2, (llvm::Twine *)&v17, 0, 0, v14);
  }
  else
  {
    *a7 = v15[0];
  }
  return v12;
}

BOOL sub_1C5DDF5D0(_QWORD *a1, uint64_t a2, uint64_t a3, double *a4)
{
  _BOOL8 v7;
  _BOOL4 v8;
  llvm::raw_ostream *v10;
  _QWORD v11[4];
  __int16 v12;
  _QWORD v13[4];
  __int16 v14;

  v14 = 261;
  v13[0] = a2;
  v13[1] = a3;
  v7 = sub_1C6386234((unsigned __int8 *)v13, a4);
  v8 = v7;
  if (!v7)
  {
    v12 = 1283;
    v11[0] = "'";
    v11[2] = a2;
    v11[3] = a3;
    v13[0] = v11;
    v13[2] = "' value invalid for floating point argument!";
    v14 = 770;
    v10 = (llvm::raw_ostream *)llvm::errs((llvm *)v7);
    llvm::cl::Option::error(a1, (llvm::Twine *)v13, 0, 0, v10);
  }
  return !v8;
}

uint64_t llvm::cl::generic_parser_base::findOption(uint64_t a1, const void *a2, size_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const void *v9;
  uint64_t v10;

  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if (!(_DWORD)v6)
    return 0;
  v7 = v6;
  v8 = 0;
  while (1)
  {
    v9 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 24))(a1, v8);
    if (v10 == a3 && (!a3 || !memcmp(v9, a2, a3)))
      break;
    v8 = (v8 + 1);
    if ((_DWORD)v7 == (_DWORD)v8)
      return v7;
  }
  return v8;
}

unint64_t llvm::cl::generic_parser_base::getOptionWidth(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v5;
  unint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  BOOL v15;
  unint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;

  v3 = *(_QWORD *)(a2 + 24);
  if (v3)
  {
    v15 = v3 == 1;
    v5 = v3 + 15;
    if (v15)
      v6 = 15;
    else
      v6 = v5;
    v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    if (v7)
    {
      v8 = v7;
      v9 = 0;
      do
      {
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 24))(a1, v9);
        v11 = v10;
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 32))(a1, v9);
        v13 = v12;
        v14 = (*(unsigned __int16 *)(a2 + 10) >> 3) & 3;
        if (!v14)
          v14 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 8))(a2);
        v15 = v14 == 1 && v11 == 0;
        if (!v15 || v13 != 0)
        {
          v17 = v11 + 8;
          if (!v11)
            v17 = 15;
          if (v6 <= v17)
            v6 = v17;
        }
        v9 = (v9 + 1);
      }
      while (v8 != (_DWORD)v9);
    }
  }
  else
  {
    v18 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    if (v18)
    {
      v19 = v18;
      v20 = 0;
      v6 = 0;
      do
      {
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 24))(a1, v20);
        if (v6 <= v21 + 8)
          v6 = v21 + 8;
        v20 = (v20 + 1);
      }
      while (v19 != (_DWORD)v20);
    }
    else
    {
      return 0;
    }
  }
  return v6;
}

void llvm::cl::parser<BOOL>::printOptionDiff(llvm::cl::basic_parser_impl *a1, const llvm::cl::Option *a2, unsigned int a3, uint64_t a4, int a5)
{
  llvm *v7;
  llvm::raw_ostream *v8;
  _WORD *v9;
  const char *v10;
  size_t v11;
  llvm *v12;
  unint64_t v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  llvm::raw_ostream *v17;
  llvm::raw_ostream *v18;
  uint64_t v19;
  int v20;
  llvm::raw_ostream *v21;
  uint64_t v22;
  llvm::raw_ostream *v23;
  _WORD *v24;
  void (**v25)(llvm::raw_ostream *__hidden);
  int v26;
  llvm *v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  int v32;
  void **v33;
  char *v34;
  size_t v35;
  uint64_t v36;

  llvm::cl::basic_parser_impl::printOptionName(a1, a2, a5);
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v26 = 0;
  v30 = 0;
  v31 = 0;
  v25 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
  v33 = (void **)&v34;
  v32 = 0;
  v28 = 0;
  v29 = 0;
  v27 = 0;
  v7 = sub_1C5E21910((llvm::raw_ostream *)&v25, a3, 0, 0, 0);
  v25 = off_1E81A6E70;
  if (v32 == 1)
  {
    v7 = v27;
    if (v27)
      v7 = (llvm *)MEMORY[0x1CAA32F9C](v27, 0x1000C8077774924);
  }
  v8 = (llvm::raw_ostream *)llvm::outs(v7);
  v9 = (_WORD *)*((_QWORD *)v8 + 4);
  if (*((_QWORD *)v8 + 3) - (_QWORD)v9 > 1uLL)
  {
    *v9 = 8253;
    *((_QWORD *)v8 + 4) += 2;
  }
  else
  {
    v8 = llvm::raw_ostream::write(v8, "= ", 2uLL);
  }
  if (v36 >= 0)
    v10 = (const char *)&v34;
  else
    v10 = v34;
  if (v36 >= 0)
    v11 = HIBYTE(v36) & 0x7F;
  else
    v11 = v35;
  v12 = llvm::raw_ostream::write(v8, v10, v11);
  if (v36 >= 0)
    v13 = HIBYTE(v36) & 0x78;
  else
    v13 = v35;
  v14 = HIBYTE(v36) & 0x7F;
  if (v36 < 0)
    v14 = v35;
  v15 = 8 - v14;
  if (v13 >= 8)
    v16 = 0;
  else
    v16 = v15;
  v17 = (llvm::raw_ostream *)llvm::outs(v12);
  v18 = llvm::raw_ostream::indent(v17, v16);
  v19 = *((_QWORD *)v18 + 4);
  if ((unint64_t)(*((_QWORD *)v18 + 3) - v19) > 0xA)
  {
    *(_DWORD *)(v19 + 7) = 540701804;
    *(_QWORD *)v19 = *(_QWORD *)" (default: ";
    *((_QWORD *)v18 + 4) += 11;
  }
  else
  {
    v18 = llvm::raw_ostream::write(v18, " (default: ", 0xBuLL);
  }
  v20 = *(unsigned __int8 *)(a4 + 9);
  v21 = (llvm::raw_ostream *)llvm::outs(v18);
  if (v20)
  {
    v21 = sub_1C5E21910(v21, *(unsigned __int8 *)(a4 + 8), 0, 0, 0);
  }
  else
  {
    v22 = *((_QWORD *)v21 + 4);
    if ((unint64_t)(*((_QWORD *)v21 + 3) - v22) > 0xB)
    {
      *(_DWORD *)(v22 + 8) = 712273013;
      *(_QWORD *)v22 = *(_QWORD *)"*no default*";
      *((_QWORD *)v21 + 4) += 12;
    }
    else
    {
      v21 = llvm::raw_ostream::write(v21, "*no default*", 0xCuLL);
    }
  }
  v23 = (llvm::raw_ostream *)llvm::outs(v21);
  v24 = (_WORD *)*((_QWORD *)v23 + 4);
  if (*((_QWORD *)v23 + 3) - (_QWORD)v24 > 1uLL)
  {
    *v24 = 2601;
    *((_QWORD *)v23 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(v23, ")\n", 2uLL);
  }
  if (SHIBYTE(v36) < 0)
    operator delete(v34);
}

void llvm::cl::parser<llvm::cl::BOOLOrDefault>::printOptionDiff(llvm::cl::basic_parser_impl *a1, const llvm::cl::Option *a2, int a3, uint64_t a4, int a5)
{
  unint64_t v7;
  int v8;
  llvm *v9;
  llvm::raw_ostream *v10;
  _WORD *v11;
  const char *v12;
  size_t v13;
  llvm *v14;
  unint64_t v15;
  int v16;
  unsigned int v17;
  unsigned int v18;
  llvm::raw_ostream *v19;
  llvm::raw_ostream *v20;
  uint64_t v21;
  int v22;
  llvm::raw_ostream *v23;
  uint64_t v24;
  unint64_t v25;
  int v26;
  llvm::raw_ostream *v27;
  _WORD *v28;
  void (**v29)(llvm::raw_ostream *__hidden);
  int v30;
  llvm *v31;
  uint64_t v32;
  uint64_t v33;
  char v34;
  uint64_t v35;
  int v36;
  void **v37;
  char *v38;
  size_t v39;
  uint64_t v40;

  llvm::cl::basic_parser_impl::printOptionName(a1, a2, a5);
  v38 = 0;
  v39 = 0;
  v40 = 0;
  v30 = 0;
  v34 = 0;
  v35 = 0;
  v29 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
  v37 = (void **)&v38;
  v36 = 0;
  v7 = a3;
  v32 = 0;
  v33 = 0;
  v31 = 0;
  if (a3 < 0)
  {
    v7 = -(uint64_t)a3;
    v8 = 1;
  }
  else
  {
    v8 = 0;
  }
  v9 = sub_1C5E21910((llvm::raw_ostream *)&v29, v7, 0, 0, v8);
  v29 = off_1E81A6E70;
  if (v36 == 1)
  {
    v9 = v31;
    if (v31)
      v9 = (llvm *)MEMORY[0x1CAA32F9C](v31, 0x1000C8077774924);
  }
  v10 = (llvm::raw_ostream *)llvm::outs(v9);
  v11 = (_WORD *)*((_QWORD *)v10 + 4);
  if (*((_QWORD *)v10 + 3) - (_QWORD)v11 > 1uLL)
  {
    *v11 = 8253;
    *((_QWORD *)v10 + 4) += 2;
  }
  else
  {
    v10 = llvm::raw_ostream::write(v10, "= ", 2uLL);
  }
  if (v40 >= 0)
    v12 = (const char *)&v38;
  else
    v12 = v38;
  if (v40 >= 0)
    v13 = HIBYTE(v40) & 0x7F;
  else
    v13 = v39;
  v14 = llvm::raw_ostream::write(v10, v12, v13);
  if (v40 >= 0)
    v15 = HIBYTE(v40) & 0x78;
  else
    v15 = v39;
  v16 = HIBYTE(v40) & 0x7F;
  if (v40 < 0)
    v16 = v39;
  v17 = 8 - v16;
  if (v15 >= 8)
    v18 = 0;
  else
    v18 = v17;
  v19 = (llvm::raw_ostream *)llvm::outs(v14);
  v20 = llvm::raw_ostream::indent(v19, v18);
  v21 = *((_QWORD *)v20 + 4);
  if ((unint64_t)(*((_QWORD *)v20 + 3) - v21) > 0xA)
  {
    *(_DWORD *)(v21 + 7) = 540701804;
    *(_QWORD *)v21 = *(_QWORD *)" (default: ";
    *((_QWORD *)v20 + 4) += 11;
  }
  else
  {
    v20 = llvm::raw_ostream::write(v20, " (default: ", 0xBuLL);
  }
  v22 = *(unsigned __int8 *)(a4 + 12);
  v23 = (llvm::raw_ostream *)llvm::outs(v20);
  if (v22)
  {
    v25 = *(int *)(a4 + 8);
    if ((v25 & 0x80000000) != 0)
    {
      v25 = -(uint64_t)v25;
      v26 = 1;
    }
    else
    {
      v26 = 0;
    }
    v23 = sub_1C5E21910(v23, v25, 0, 0, v26);
  }
  else
  {
    v24 = *((_QWORD *)v23 + 4);
    if ((unint64_t)(*((_QWORD *)v23 + 3) - v24) > 0xB)
    {
      *(_DWORD *)(v24 + 8) = 712273013;
      *(_QWORD *)v24 = *(_QWORD *)"*no default*";
      *((_QWORD *)v23 + 4) += 12;
    }
    else
    {
      v23 = llvm::raw_ostream::write(v23, "*no default*", 0xCuLL);
    }
  }
  v27 = (llvm::raw_ostream *)llvm::outs(v23);
  v28 = (_WORD *)*((_QWORD *)v27 + 4);
  if (*((_QWORD *)v27 + 3) - (_QWORD)v28 > 1uLL)
  {
    *v28 = 2601;
    *((_QWORD *)v27 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(v27, ")\n", 2uLL);
  }
  if (SHIBYTE(v40) < 0)
    operator delete(v38);
}

void llvm::cl::parser<int>::printOptionDiff(llvm::cl::basic_parser_impl *a1, const llvm::cl::Option *a2, int a3, uint64_t a4, int a5)
{
  unint64_t v7;
  int v8;
  llvm *v9;
  llvm::raw_ostream *v10;
  _WORD *v11;
  const char *v12;
  size_t v13;
  llvm *v14;
  unint64_t v15;
  int v16;
  unsigned int v17;
  unsigned int v18;
  llvm::raw_ostream *v19;
  llvm::raw_ostream *v20;
  uint64_t v21;
  int v22;
  llvm::raw_ostream *v23;
  uint64_t v24;
  unint64_t v25;
  int v26;
  llvm::raw_ostream *v27;
  _WORD *v28;
  void (**v29)(llvm::raw_ostream *__hidden);
  int v30;
  llvm *v31;
  uint64_t v32;
  uint64_t v33;
  char v34;
  uint64_t v35;
  int v36;
  void **v37;
  char *v38;
  size_t v39;
  uint64_t v40;

  llvm::cl::basic_parser_impl::printOptionName(a1, a2, a5);
  v38 = 0;
  v39 = 0;
  v40 = 0;
  v30 = 0;
  v34 = 0;
  v35 = 0;
  v29 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
  v37 = (void **)&v38;
  v36 = 0;
  v7 = a3;
  v32 = 0;
  v33 = 0;
  v31 = 0;
  if (a3 < 0)
  {
    v7 = -(uint64_t)a3;
    v8 = 1;
  }
  else
  {
    v8 = 0;
  }
  v9 = sub_1C5E21910((llvm::raw_ostream *)&v29, v7, 0, 0, v8);
  v29 = off_1E81A6E70;
  if (v36 == 1)
  {
    v9 = v31;
    if (v31)
      v9 = (llvm *)MEMORY[0x1CAA32F9C](v31, 0x1000C8077774924);
  }
  v10 = (llvm::raw_ostream *)llvm::outs(v9);
  v11 = (_WORD *)*((_QWORD *)v10 + 4);
  if (*((_QWORD *)v10 + 3) - (_QWORD)v11 > 1uLL)
  {
    *v11 = 8253;
    *((_QWORD *)v10 + 4) += 2;
  }
  else
  {
    v10 = llvm::raw_ostream::write(v10, "= ", 2uLL);
  }
  if (v40 >= 0)
    v12 = (const char *)&v38;
  else
    v12 = v38;
  if (v40 >= 0)
    v13 = HIBYTE(v40) & 0x7F;
  else
    v13 = v39;
  v14 = llvm::raw_ostream::write(v10, v12, v13);
  if (v40 >= 0)
    v15 = HIBYTE(v40) & 0x78;
  else
    v15 = v39;
  v16 = HIBYTE(v40) & 0x7F;
  if (v40 < 0)
    v16 = v39;
  v17 = 8 - v16;
  if (v15 >= 8)
    v18 = 0;
  else
    v18 = v17;
  v19 = (llvm::raw_ostream *)llvm::outs(v14);
  v20 = llvm::raw_ostream::indent(v19, v18);
  v21 = *((_QWORD *)v20 + 4);
  if ((unint64_t)(*((_QWORD *)v20 + 3) - v21) > 0xA)
  {
    *(_DWORD *)(v21 + 7) = 540701804;
    *(_QWORD *)v21 = *(_QWORD *)" (default: ";
    *((_QWORD *)v20 + 4) += 11;
  }
  else
  {
    v20 = llvm::raw_ostream::write(v20, " (default: ", 0xBuLL);
  }
  v22 = *(unsigned __int8 *)(a4 + 12);
  v23 = (llvm::raw_ostream *)llvm::outs(v20);
  if (v22)
  {
    v25 = *(int *)(a4 + 8);
    if ((v25 & 0x80000000) != 0)
    {
      v25 = -(uint64_t)v25;
      v26 = 1;
    }
    else
    {
      v26 = 0;
    }
    v23 = sub_1C5E21910(v23, v25, 0, 0, v26);
  }
  else
  {
    v24 = *((_QWORD *)v23 + 4);
    if ((unint64_t)(*((_QWORD *)v23 + 3) - v24) > 0xB)
    {
      *(_DWORD *)(v24 + 8) = 712273013;
      *(_QWORD *)v24 = *(_QWORD *)"*no default*";
      *((_QWORD *)v23 + 4) += 12;
    }
    else
    {
      v23 = llvm::raw_ostream::write(v23, "*no default*", 0xCuLL);
    }
  }
  v27 = (llvm::raw_ostream *)llvm::outs(v23);
  v28 = (_WORD *)*((_QWORD *)v27 + 4);
  if (*((_QWORD *)v27 + 3) - (_QWORD)v28 > 1uLL)
  {
    *v28 = 2601;
    *((_QWORD *)v27 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(v27, ")\n", 2uLL);
  }
  if (SHIBYTE(v40) < 0)
    operator delete(v38);
}

void llvm::cl::parser<long>::printOptionDiff(llvm::cl::basic_parser_impl *a1, const llvm::cl::Option *a2, unint64_t a3, uint64_t a4, int a5)
{
  unint64_t v7;
  int v8;
  llvm *v9;
  llvm::raw_ostream *v10;
  _WORD *v11;
  const char *v12;
  size_t v13;
  llvm *v14;
  unint64_t v15;
  int v16;
  unsigned int v17;
  unsigned int v18;
  llvm::raw_ostream *v19;
  llvm::raw_ostream *v20;
  uint64_t v21;
  int v22;
  llvm::raw_ostream *v23;
  uint64_t v24;
  unint64_t v25;
  int v26;
  llvm::raw_ostream *v27;
  _WORD *v28;
  void (**v29)(llvm::raw_ostream *__hidden);
  int v30;
  llvm *v31;
  uint64_t v32;
  uint64_t v33;
  char v34;
  uint64_t v35;
  int v36;
  void **v37;
  char *v38;
  size_t v39;
  uint64_t v40;

  llvm::cl::basic_parser_impl::printOptionName(a1, a2, a5);
  v38 = 0;
  v39 = 0;
  v40 = 0;
  v30 = 0;
  v34 = 0;
  v35 = 0;
  v29 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
  v37 = (void **)&v38;
  v36 = 0;
  v32 = 0;
  v33 = 0;
  v31 = 0;
  if ((a3 & 0x8000000000000000) != 0)
  {
    v7 = -(uint64_t)a3;
    v8 = 1;
  }
  else
  {
    v7 = a3;
    v8 = 0;
  }
  v9 = sub_1C5E21910((llvm::raw_ostream *)&v29, v7, 0, 0, v8);
  v29 = off_1E81A6E70;
  if (v36 == 1)
  {
    v9 = v31;
    if (v31)
      v9 = (llvm *)MEMORY[0x1CAA32F9C](v31, 0x1000C8077774924);
  }
  v10 = (llvm::raw_ostream *)llvm::outs(v9);
  v11 = (_WORD *)*((_QWORD *)v10 + 4);
  if (*((_QWORD *)v10 + 3) - (_QWORD)v11 > 1uLL)
  {
    *v11 = 8253;
    *((_QWORD *)v10 + 4) += 2;
  }
  else
  {
    v10 = llvm::raw_ostream::write(v10, "= ", 2uLL);
  }
  if (v40 >= 0)
    v12 = (const char *)&v38;
  else
    v12 = v38;
  if (v40 >= 0)
    v13 = HIBYTE(v40) & 0x7F;
  else
    v13 = v39;
  v14 = llvm::raw_ostream::write(v10, v12, v13);
  if (v40 >= 0)
    v15 = HIBYTE(v40) & 0x78;
  else
    v15 = v39;
  v16 = HIBYTE(v40) & 0x7F;
  if (v40 < 0)
    v16 = v39;
  v17 = 8 - v16;
  if (v15 >= 8)
    v18 = 0;
  else
    v18 = v17;
  v19 = (llvm::raw_ostream *)llvm::outs(v14);
  v20 = llvm::raw_ostream::indent(v19, v18);
  v21 = *((_QWORD *)v20 + 4);
  if ((unint64_t)(*((_QWORD *)v20 + 3) - v21) > 0xA)
  {
    *(_DWORD *)(v21 + 7) = 540701804;
    *(_QWORD *)v21 = *(_QWORD *)" (default: ";
    *((_QWORD *)v20 + 4) += 11;
  }
  else
  {
    v20 = llvm::raw_ostream::write(v20, " (default: ", 0xBuLL);
  }
  v22 = *(unsigned __int8 *)(a4 + 16);
  v23 = (llvm::raw_ostream *)llvm::outs(v20);
  if (v22)
  {
    v25 = *(_QWORD *)(a4 + 8);
    if ((v25 & 0x8000000000000000) != 0)
    {
      v25 = -(uint64_t)v25;
      v26 = 1;
    }
    else
    {
      v26 = 0;
    }
    v23 = sub_1C5E21910(v23, v25, 0, 0, v26);
  }
  else
  {
    v24 = *((_QWORD *)v23 + 4);
    if ((unint64_t)(*((_QWORD *)v23 + 3) - v24) > 0xB)
    {
      *(_DWORD *)(v24 + 8) = 712273013;
      *(_QWORD *)v24 = *(_QWORD *)"*no default*";
      *((_QWORD *)v23 + 4) += 12;
    }
    else
    {
      v23 = llvm::raw_ostream::write(v23, "*no default*", 0xCuLL);
    }
  }
  v27 = (llvm::raw_ostream *)llvm::outs(v23);
  v28 = (_WORD *)*((_QWORD *)v27 + 4);
  if (*((_QWORD *)v27 + 3) - (_QWORD)v28 > 1uLL)
  {
    *v28 = 2601;
    *((_QWORD *)v27 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(v27, ")\n", 2uLL);
  }
  if (SHIBYTE(v40) < 0)
    operator delete(v38);
}

void llvm::cl::parser<long long>::printOptionDiff(llvm::cl::basic_parser_impl *a1, const llvm::cl::Option *a2, unint64_t a3, uint64_t a4, int a5)
{
  llvm *v7;
  llvm::raw_ostream *v8;
  _WORD *v9;
  const char *v10;
  size_t v11;
  llvm *v12;
  unint64_t v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  llvm::raw_ostream *v17;
  llvm::raw_ostream *v18;
  uint64_t v19;
  int v20;
  llvm::raw_ostream *v21;
  uint64_t v22;
  llvm::raw_ostream *v23;
  _WORD *v24;
  void (**v25)(llvm::raw_ostream *__hidden);
  int v26;
  llvm *v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  int v32;
  void **v33;
  char *v34;
  size_t v35;
  uint64_t v36;

  llvm::cl::basic_parser_impl::printOptionName(a1, a2, a5);
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v26 = 0;
  v30 = 0;
  v31 = 0;
  v25 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
  v33 = (void **)&v34;
  v32 = 0;
  v28 = 0;
  v29 = 0;
  v27 = 0;
  v7 = llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v25, a3);
  v25 = off_1E81A6E70;
  if (v32 == 1)
  {
    v7 = v27;
    if (v27)
      v7 = (llvm *)MEMORY[0x1CAA32F9C](v27, 0x1000C8077774924);
  }
  v8 = (llvm::raw_ostream *)llvm::outs(v7);
  v9 = (_WORD *)*((_QWORD *)v8 + 4);
  if (*((_QWORD *)v8 + 3) - (_QWORD)v9 > 1uLL)
  {
    *v9 = 8253;
    *((_QWORD *)v8 + 4) += 2;
  }
  else
  {
    v8 = llvm::raw_ostream::write(v8, "= ", 2uLL);
  }
  if (v36 >= 0)
    v10 = (const char *)&v34;
  else
    v10 = v34;
  if (v36 >= 0)
    v11 = HIBYTE(v36) & 0x7F;
  else
    v11 = v35;
  v12 = llvm::raw_ostream::write(v8, v10, v11);
  if (v36 >= 0)
    v13 = HIBYTE(v36) & 0x78;
  else
    v13 = v35;
  v14 = HIBYTE(v36) & 0x7F;
  if (v36 < 0)
    v14 = v35;
  v15 = 8 - v14;
  if (v13 >= 8)
    v16 = 0;
  else
    v16 = v15;
  v17 = (llvm::raw_ostream *)llvm::outs(v12);
  v18 = llvm::raw_ostream::indent(v17, v16);
  v19 = *((_QWORD *)v18 + 4);
  if ((unint64_t)(*((_QWORD *)v18 + 3) - v19) > 0xA)
  {
    *(_DWORD *)(v19 + 7) = 540701804;
    *(_QWORD *)v19 = *(_QWORD *)" (default: ";
    *((_QWORD *)v18 + 4) += 11;
  }
  else
  {
    v18 = llvm::raw_ostream::write(v18, " (default: ", 0xBuLL);
  }
  v20 = *(unsigned __int8 *)(a4 + 16);
  v21 = (llvm::raw_ostream *)llvm::outs(v18);
  if (v20)
  {
    v21 = llvm::raw_ostream::operator<<(v21, *(_QWORD *)(a4 + 8));
  }
  else
  {
    v22 = *((_QWORD *)v21 + 4);
    if ((unint64_t)(*((_QWORD *)v21 + 3) - v22) > 0xB)
    {
      *(_DWORD *)(v22 + 8) = 712273013;
      *(_QWORD *)v22 = *(_QWORD *)"*no default*";
      *((_QWORD *)v21 + 4) += 12;
    }
    else
    {
      v21 = llvm::raw_ostream::write(v21, "*no default*", 0xCuLL);
    }
  }
  v23 = (llvm::raw_ostream *)llvm::outs(v21);
  v24 = (_WORD *)*((_QWORD *)v23 + 4);
  if (*((_QWORD *)v23 + 3) - (_QWORD)v24 > 1uLL)
  {
    *v24 = 2601;
    *((_QWORD *)v23 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(v23, ")\n", 2uLL);
  }
  if (SHIBYTE(v36) < 0)
    operator delete(v34);
}

void llvm::cl::parser<unsigned int>::printOptionDiff(llvm::cl::basic_parser_impl *a1, const llvm::cl::Option *a2, unsigned int a3, uint64_t a4, int a5)
{
  llvm *v7;
  llvm::raw_ostream *v8;
  _WORD *v9;
  const char *v10;
  size_t v11;
  llvm *v12;
  unint64_t v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  llvm::raw_ostream *v17;
  llvm::raw_ostream *v18;
  uint64_t v19;
  int v20;
  llvm::raw_ostream *v21;
  uint64_t v22;
  llvm::raw_ostream *v23;
  _WORD *v24;
  void (**v25)(llvm::raw_ostream *__hidden);
  int v26;
  llvm *v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  int v32;
  void **v33;
  char *v34;
  size_t v35;
  uint64_t v36;

  llvm::cl::basic_parser_impl::printOptionName(a1, a2, a5);
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v26 = 0;
  v30 = 0;
  v31 = 0;
  v25 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
  v33 = (void **)&v34;
  v32 = 0;
  v28 = 0;
  v29 = 0;
  v27 = 0;
  v7 = sub_1C5E21910((llvm::raw_ostream *)&v25, a3, 0, 0, 0);
  v25 = off_1E81A6E70;
  if (v32 == 1)
  {
    v7 = v27;
    if (v27)
      v7 = (llvm *)MEMORY[0x1CAA32F9C](v27, 0x1000C8077774924);
  }
  v8 = (llvm::raw_ostream *)llvm::outs(v7);
  v9 = (_WORD *)*((_QWORD *)v8 + 4);
  if (*((_QWORD *)v8 + 3) - (_QWORD)v9 > 1uLL)
  {
    *v9 = 8253;
    *((_QWORD *)v8 + 4) += 2;
  }
  else
  {
    v8 = llvm::raw_ostream::write(v8, "= ", 2uLL);
  }
  if (v36 >= 0)
    v10 = (const char *)&v34;
  else
    v10 = v34;
  if (v36 >= 0)
    v11 = HIBYTE(v36) & 0x7F;
  else
    v11 = v35;
  v12 = llvm::raw_ostream::write(v8, v10, v11);
  if (v36 >= 0)
    v13 = HIBYTE(v36) & 0x78;
  else
    v13 = v35;
  v14 = HIBYTE(v36) & 0x7F;
  if (v36 < 0)
    v14 = v35;
  v15 = 8 - v14;
  if (v13 >= 8)
    v16 = 0;
  else
    v16 = v15;
  v17 = (llvm::raw_ostream *)llvm::outs(v12);
  v18 = llvm::raw_ostream::indent(v17, v16);
  v19 = *((_QWORD *)v18 + 4);
  if ((unint64_t)(*((_QWORD *)v18 + 3) - v19) > 0xA)
  {
    *(_DWORD *)(v19 + 7) = 540701804;
    *(_QWORD *)v19 = *(_QWORD *)" (default: ";
    *((_QWORD *)v18 + 4) += 11;
  }
  else
  {
    v18 = llvm::raw_ostream::write(v18, " (default: ", 0xBuLL);
  }
  v20 = *(unsigned __int8 *)(a4 + 12);
  v21 = (llvm::raw_ostream *)llvm::outs(v18);
  if (v20)
  {
    v21 = sub_1C5E21910(v21, *(unsigned int *)(a4 + 8), 0, 0, 0);
  }
  else
  {
    v22 = *((_QWORD *)v21 + 4);
    if ((unint64_t)(*((_QWORD *)v21 + 3) - v22) > 0xB)
    {
      *(_DWORD *)(v22 + 8) = 712273013;
      *(_QWORD *)v22 = *(_QWORD *)"*no default*";
      *((_QWORD *)v21 + 4) += 12;
    }
    else
    {
      v21 = llvm::raw_ostream::write(v21, "*no default*", 0xCuLL);
    }
  }
  v23 = (llvm::raw_ostream *)llvm::outs(v21);
  v24 = (_WORD *)*((_QWORD *)v23 + 4);
  if (*((_QWORD *)v23 + 3) - (_QWORD)v24 > 1uLL)
  {
    *v24 = 2601;
    *((_QWORD *)v23 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(v23, ")\n", 2uLL);
  }
  if (SHIBYTE(v36) < 0)
    operator delete(v34);
}

void llvm::cl::parser<unsigned long>::printOptionDiff(llvm::cl::basic_parser_impl *a1, const llvm::cl::Option *a2, unint64_t a3, uint64_t a4, int a5)
{
  llvm *v7;
  llvm::raw_ostream *v8;
  _WORD *v9;
  const char *v10;
  size_t v11;
  llvm *v12;
  unint64_t v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  llvm::raw_ostream *v17;
  llvm::raw_ostream *v18;
  uint64_t v19;
  int v20;
  llvm::raw_ostream *v21;
  uint64_t v22;
  llvm::raw_ostream *v23;
  _WORD *v24;
  void (**v25)(llvm::raw_ostream *__hidden);
  int v26;
  llvm *v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  int v32;
  void **v33;
  char *v34;
  size_t v35;
  uint64_t v36;

  llvm::cl::basic_parser_impl::printOptionName(a1, a2, a5);
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v26 = 0;
  v30 = 0;
  v31 = 0;
  v25 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
  v33 = (void **)&v34;
  v32 = 0;
  v28 = 0;
  v29 = 0;
  v27 = 0;
  v7 = sub_1C5E21910((llvm::raw_ostream *)&v25, a3, 0, 0, 0);
  v25 = off_1E81A6E70;
  if (v32 == 1)
  {
    v7 = v27;
    if (v27)
      v7 = (llvm *)MEMORY[0x1CAA32F9C](v27, 0x1000C8077774924);
  }
  v8 = (llvm::raw_ostream *)llvm::outs(v7);
  v9 = (_WORD *)*((_QWORD *)v8 + 4);
  if (*((_QWORD *)v8 + 3) - (_QWORD)v9 > 1uLL)
  {
    *v9 = 8253;
    *((_QWORD *)v8 + 4) += 2;
  }
  else
  {
    v8 = llvm::raw_ostream::write(v8, "= ", 2uLL);
  }
  if (v36 >= 0)
    v10 = (const char *)&v34;
  else
    v10 = v34;
  if (v36 >= 0)
    v11 = HIBYTE(v36) & 0x7F;
  else
    v11 = v35;
  v12 = llvm::raw_ostream::write(v8, v10, v11);
  if (v36 >= 0)
    v13 = HIBYTE(v36) & 0x78;
  else
    v13 = v35;
  v14 = HIBYTE(v36) & 0x7F;
  if (v36 < 0)
    v14 = v35;
  v15 = 8 - v14;
  if (v13 >= 8)
    v16 = 0;
  else
    v16 = v15;
  v17 = (llvm::raw_ostream *)llvm::outs(v12);
  v18 = llvm::raw_ostream::indent(v17, v16);
  v19 = *((_QWORD *)v18 + 4);
  if ((unint64_t)(*((_QWORD *)v18 + 3) - v19) > 0xA)
  {
    *(_DWORD *)(v19 + 7) = 540701804;
    *(_QWORD *)v19 = *(_QWORD *)" (default: ";
    *((_QWORD *)v18 + 4) += 11;
  }
  else
  {
    v18 = llvm::raw_ostream::write(v18, " (default: ", 0xBuLL);
  }
  v20 = *(unsigned __int8 *)(a4 + 16);
  v21 = (llvm::raw_ostream *)llvm::outs(v18);
  if (v20)
  {
    v21 = sub_1C5E21910(v21, *(_QWORD *)(a4 + 8), 0, 0, 0);
  }
  else
  {
    v22 = *((_QWORD *)v21 + 4);
    if ((unint64_t)(*((_QWORD *)v21 + 3) - v22) > 0xB)
    {
      *(_DWORD *)(v22 + 8) = 712273013;
      *(_QWORD *)v22 = *(_QWORD *)"*no default*";
      *((_QWORD *)v21 + 4) += 12;
    }
    else
    {
      v21 = llvm::raw_ostream::write(v21, "*no default*", 0xCuLL);
    }
  }
  v23 = (llvm::raw_ostream *)llvm::outs(v21);
  v24 = (_WORD *)*((_QWORD *)v23 + 4);
  if (*((_QWORD *)v23 + 3) - (_QWORD)v24 > 1uLL)
  {
    *v24 = 2601;
    *((_QWORD *)v23 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(v23, ")\n", 2uLL);
  }
  if (SHIBYTE(v36) < 0)
    operator delete(v34);
}

void llvm::cl::parser<unsigned long long>::printOptionDiff(llvm::cl::basic_parser_impl *a1, const llvm::cl::Option *a2, unint64_t a3, uint64_t a4, int a5)
{
  llvm *v7;
  llvm::raw_ostream *v8;
  _WORD *v9;
  const char *v10;
  size_t v11;
  llvm *v12;
  unint64_t v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  llvm::raw_ostream *v17;
  llvm::raw_ostream *v18;
  uint64_t v19;
  int v20;
  llvm::raw_ostream *v21;
  uint64_t v22;
  llvm::raw_ostream *v23;
  _WORD *v24;
  void (**v25)(llvm::raw_ostream *__hidden);
  int v26;
  llvm *v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  int v32;
  void **v33;
  char *v34;
  size_t v35;
  uint64_t v36;

  llvm::cl::basic_parser_impl::printOptionName(a1, a2, a5);
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v26 = 0;
  v30 = 0;
  v31 = 0;
  v25 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
  v33 = (void **)&v34;
  v32 = 0;
  v28 = 0;
  v29 = 0;
  v27 = 0;
  v7 = sub_1C5E21910((llvm::raw_ostream *)&v25, a3, 0, 0, 0);
  v25 = off_1E81A6E70;
  if (v32 == 1)
  {
    v7 = v27;
    if (v27)
      v7 = (llvm *)MEMORY[0x1CAA32F9C](v27, 0x1000C8077774924);
  }
  v8 = (llvm::raw_ostream *)llvm::outs(v7);
  v9 = (_WORD *)*((_QWORD *)v8 + 4);
  if (*((_QWORD *)v8 + 3) - (_QWORD)v9 > 1uLL)
  {
    *v9 = 8253;
    *((_QWORD *)v8 + 4) += 2;
  }
  else
  {
    v8 = llvm::raw_ostream::write(v8, "= ", 2uLL);
  }
  if (v36 >= 0)
    v10 = (const char *)&v34;
  else
    v10 = v34;
  if (v36 >= 0)
    v11 = HIBYTE(v36) & 0x7F;
  else
    v11 = v35;
  v12 = llvm::raw_ostream::write(v8, v10, v11);
  if (v36 >= 0)
    v13 = HIBYTE(v36) & 0x78;
  else
    v13 = v35;
  v14 = HIBYTE(v36) & 0x7F;
  if (v36 < 0)
    v14 = v35;
  v15 = 8 - v14;
  if (v13 >= 8)
    v16 = 0;
  else
    v16 = v15;
  v17 = (llvm::raw_ostream *)llvm::outs(v12);
  v18 = llvm::raw_ostream::indent(v17, v16);
  v19 = *((_QWORD *)v18 + 4);
  if ((unint64_t)(*((_QWORD *)v18 + 3) - v19) > 0xA)
  {
    *(_DWORD *)(v19 + 7) = 540701804;
    *(_QWORD *)v19 = *(_QWORD *)" (default: ";
    *((_QWORD *)v18 + 4) += 11;
  }
  else
  {
    v18 = llvm::raw_ostream::write(v18, " (default: ", 0xBuLL);
  }
  v20 = *(unsigned __int8 *)(a4 + 16);
  v21 = (llvm::raw_ostream *)llvm::outs(v18);
  if (v20)
  {
    v21 = sub_1C5E21910(v21, *(_QWORD *)(a4 + 8), 0, 0, 0);
  }
  else
  {
    v22 = *((_QWORD *)v21 + 4);
    if ((unint64_t)(*((_QWORD *)v21 + 3) - v22) > 0xB)
    {
      *(_DWORD *)(v22 + 8) = 712273013;
      *(_QWORD *)v22 = *(_QWORD *)"*no default*";
      *((_QWORD *)v21 + 4) += 12;
    }
    else
    {
      v21 = llvm::raw_ostream::write(v21, "*no default*", 0xCuLL);
    }
  }
  v23 = (llvm::raw_ostream *)llvm::outs(v21);
  v24 = (_WORD *)*((_QWORD *)v23 + 4);
  if (*((_QWORD *)v23 + 3) - (_QWORD)v24 > 1uLL)
  {
    *v24 = 2601;
    *((_QWORD *)v23 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(v23, ")\n", 2uLL);
  }
  if (SHIBYTE(v36) < 0)
    operator delete(v34);
}

void llvm::cl::parser<double>::printOptionDiff(llvm::cl::basic_parser_impl *a1, const llvm::cl::Option *a2, uint64_t a3, int a4, double a5)
{
  llvm *v7;
  llvm::raw_ostream *v8;
  _WORD *v9;
  const char *v10;
  size_t v11;
  llvm *v12;
  unint64_t v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  llvm::raw_ostream *v17;
  llvm::raw_ostream *v18;
  uint64_t v19;
  int v20;
  llvm::raw_ostream *v21;
  uint64_t v22;
  llvm::raw_ostream *v23;
  _WORD *v24;
  void (**v25)(llvm::raw_ostream *__hidden);
  int v26;
  llvm *v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  int v32;
  void **v33;
  char *v34;
  size_t v35;
  uint64_t v36;

  llvm::cl::basic_parser_impl::printOptionName(a1, a2, a4);
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v26 = 0;
  v30 = 0;
  v31 = 0;
  v25 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
  v33 = (void **)&v34;
  v32 = 0;
  v28 = 0;
  v29 = 0;
  v27 = 0;
  llvm::write_double((llvm::raw_ostream *)&v25, 0, 0, 0, a5);
  v25 = off_1E81A6E70;
  if (v32 == 1)
  {
    v7 = v27;
    if (v27)
      v7 = (llvm *)MEMORY[0x1CAA32F9C](v27, 0x1000C8077774924);
  }
  v8 = (llvm::raw_ostream *)llvm::outs(v7);
  v9 = (_WORD *)*((_QWORD *)v8 + 4);
  if (*((_QWORD *)v8 + 3) - (_QWORD)v9 > 1uLL)
  {
    *v9 = 8253;
    *((_QWORD *)v8 + 4) += 2;
  }
  else
  {
    v8 = llvm::raw_ostream::write(v8, "= ", 2uLL);
  }
  if (v36 >= 0)
    v10 = (const char *)&v34;
  else
    v10 = v34;
  if (v36 >= 0)
    v11 = HIBYTE(v36) & 0x7F;
  else
    v11 = v35;
  v12 = llvm::raw_ostream::write(v8, v10, v11);
  if (v36 >= 0)
    v13 = HIBYTE(v36) & 0x78;
  else
    v13 = v35;
  v14 = HIBYTE(v36) & 0x7F;
  if (v36 < 0)
    v14 = v35;
  v15 = 8 - v14;
  if (v13 >= 8)
    v16 = 0;
  else
    v16 = v15;
  v17 = (llvm::raw_ostream *)llvm::outs(v12);
  v18 = llvm::raw_ostream::indent(v17, v16);
  v19 = *((_QWORD *)v18 + 4);
  if ((unint64_t)(*((_QWORD *)v18 + 3) - v19) > 0xA)
  {
    *(_DWORD *)(v19 + 7) = 540701804;
    *(_QWORD *)v19 = *(_QWORD *)" (default: ";
    *((_QWORD *)v18 + 4) += 11;
  }
  else
  {
    v18 = llvm::raw_ostream::write(v18, " (default: ", 0xBuLL);
  }
  v20 = *(unsigned __int8 *)(a3 + 16);
  v21 = (llvm::raw_ostream *)llvm::outs(v18);
  if (v20)
  {
    llvm::write_double(v21, 0, 0, 0, *(double *)(a3 + 8));
  }
  else
  {
    v22 = *((_QWORD *)v21 + 4);
    if ((unint64_t)(*((_QWORD *)v21 + 3) - v22) > 0xB)
    {
      *(_DWORD *)(v22 + 8) = 712273013;
      *(_QWORD *)v22 = *(_QWORD *)"*no default*";
      *((_QWORD *)v21 + 4) += 12;
    }
    else
    {
      v21 = llvm::raw_ostream::write(v21, "*no default*", 0xCuLL);
    }
  }
  v23 = (llvm::raw_ostream *)llvm::outs(v21);
  v24 = (_WORD *)*((_QWORD *)v23 + 4);
  if (*((_QWORD *)v23 + 3) - (_QWORD)v24 > 1uLL)
  {
    *v24 = 2601;
    *((_QWORD *)v23 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(v23, ")\n", 2uLL);
  }
  if (SHIBYTE(v36) < 0)
    operator delete(v34);
}

void llvm::cl::parser<float>::printOptionDiff(llvm::cl::basic_parser_impl *a1, const llvm::cl::Option *a2, uint64_t a3, int a4, float a5)
{
  llvm *v7;
  llvm::raw_ostream *v8;
  _WORD *v9;
  const char *v10;
  size_t v11;
  llvm *v12;
  unint64_t v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  llvm::raw_ostream *v17;
  llvm::raw_ostream *v18;
  uint64_t v19;
  int v20;
  llvm::raw_ostream *v21;
  uint64_t v22;
  llvm::raw_ostream *v23;
  _WORD *v24;
  void (**v25)(llvm::raw_ostream *__hidden);
  int v26;
  llvm *v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  int v32;
  void **v33;
  char *v34;
  size_t v35;
  uint64_t v36;

  llvm::cl::basic_parser_impl::printOptionName(a1, a2, a4);
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v26 = 0;
  v30 = 0;
  v31 = 0;
  v25 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
  v33 = (void **)&v34;
  v32 = 0;
  v28 = 0;
  v29 = 0;
  v27 = 0;
  llvm::write_double((llvm::raw_ostream *)&v25, 0, 0, 0, a5);
  v25 = off_1E81A6E70;
  if (v32 == 1)
  {
    v7 = v27;
    if (v27)
      v7 = (llvm *)MEMORY[0x1CAA32F9C](v27, 0x1000C8077774924);
  }
  v8 = (llvm::raw_ostream *)llvm::outs(v7);
  v9 = (_WORD *)*((_QWORD *)v8 + 4);
  if (*((_QWORD *)v8 + 3) - (_QWORD)v9 > 1uLL)
  {
    *v9 = 8253;
    *((_QWORD *)v8 + 4) += 2;
  }
  else
  {
    v8 = llvm::raw_ostream::write(v8, "= ", 2uLL);
  }
  if (v36 >= 0)
    v10 = (const char *)&v34;
  else
    v10 = v34;
  if (v36 >= 0)
    v11 = HIBYTE(v36) & 0x7F;
  else
    v11 = v35;
  v12 = llvm::raw_ostream::write(v8, v10, v11);
  if (v36 >= 0)
    v13 = HIBYTE(v36) & 0x78;
  else
    v13 = v35;
  v14 = HIBYTE(v36) & 0x7F;
  if (v36 < 0)
    v14 = v35;
  v15 = 8 - v14;
  if (v13 >= 8)
    v16 = 0;
  else
    v16 = v15;
  v17 = (llvm::raw_ostream *)llvm::outs(v12);
  v18 = llvm::raw_ostream::indent(v17, v16);
  v19 = *((_QWORD *)v18 + 4);
  if ((unint64_t)(*((_QWORD *)v18 + 3) - v19) > 0xA)
  {
    *(_DWORD *)(v19 + 7) = 540701804;
    *(_QWORD *)v19 = *(_QWORD *)" (default: ";
    *((_QWORD *)v18 + 4) += 11;
  }
  else
  {
    v18 = llvm::raw_ostream::write(v18, " (default: ", 0xBuLL);
  }
  v20 = *(unsigned __int8 *)(a3 + 12);
  v21 = (llvm::raw_ostream *)llvm::outs(v18);
  if (v20)
  {
    llvm::write_double(v21, 0, 0, 0, *(float *)(a3 + 8));
  }
  else
  {
    v22 = *((_QWORD *)v21 + 4);
    if ((unint64_t)(*((_QWORD *)v21 + 3) - v22) > 0xB)
    {
      *(_DWORD *)(v22 + 8) = 712273013;
      *(_QWORD *)v22 = *(_QWORD *)"*no default*";
      *((_QWORD *)v21 + 4) += 12;
    }
    else
    {
      v21 = llvm::raw_ostream::write(v21, "*no default*", 0xCuLL);
    }
  }
  v23 = (llvm::raw_ostream *)llvm::outs(v21);
  v24 = (_WORD *)*((_QWORD *)v23 + 4);
  if (*((_QWORD *)v23 + 3) - (_QWORD)v24 > 1uLL)
  {
    *v24 = 2601;
    *((_QWORD *)v23 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(v23, ")\n", 2uLL);
  }
  if (SHIBYTE(v36) < 0)
    operator delete(v34);
}

void llvm::cl::parser<char>::printOptionDiff(llvm::cl::basic_parser_impl *a1, const llvm::cl::Option *a2, char a3, uint64_t a4, int a5)
{
  llvm *v7;
  llvm::raw_ostream *v8;
  _WORD *v9;
  const char *v10;
  size_t v11;
  llvm *v12;
  unint64_t v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  llvm::raw_ostream *v17;
  llvm::raw_ostream *v18;
  uint64_t v19;
  int v20;
  llvm::raw_ostream *v21;
  unint64_t v22;
  char v23;
  llvm::raw_ostream *v24;
  _WORD *v25;
  void (**v26)(llvm::raw_ostream *__hidden);
  int v27;
  llvm *v28;
  uint64_t v29;
  uint64_t v30;
  char v31;
  uint64_t v32;
  int v33;
  void **v34;
  char *v35;
  size_t v36;
  uint64_t v37;

  llvm::cl::basic_parser_impl::printOptionName(a1, a2, a5);
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v27 = 0;
  v31 = 0;
  v32 = 0;
  v26 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
  v34 = (void **)&v35;
  v33 = 0;
  v29 = 0;
  v30 = 0;
  v28 = 0;
  v7 = llvm::raw_ostream::write((llvm::raw_ostream *)&v26, a3);
  v26 = off_1E81A6E70;
  if (v33 == 1)
  {
    v7 = v28;
    if (v28)
      v7 = (llvm *)MEMORY[0x1CAA32F9C](v28, 0x1000C8077774924);
  }
  v8 = (llvm::raw_ostream *)llvm::outs(v7);
  v9 = (_WORD *)*((_QWORD *)v8 + 4);
  if (*((_QWORD *)v8 + 3) - (_QWORD)v9 > 1uLL)
  {
    *v9 = 8253;
    *((_QWORD *)v8 + 4) += 2;
  }
  else
  {
    v8 = llvm::raw_ostream::write(v8, "= ", 2uLL);
  }
  if (v37 >= 0)
    v10 = (const char *)&v35;
  else
    v10 = v35;
  if (v37 >= 0)
    v11 = HIBYTE(v37) & 0x7F;
  else
    v11 = v36;
  v12 = llvm::raw_ostream::write(v8, v10, v11);
  if (v37 >= 0)
    v13 = HIBYTE(v37) & 0x78;
  else
    v13 = v36;
  v14 = HIBYTE(v37) & 0x7F;
  if (v37 < 0)
    v14 = v36;
  v15 = 8 - v14;
  if (v13 >= 8)
    v16 = 0;
  else
    v16 = v15;
  v17 = (llvm::raw_ostream *)llvm::outs(v12);
  v18 = llvm::raw_ostream::indent(v17, v16);
  v19 = *((_QWORD *)v18 + 4);
  if ((unint64_t)(*((_QWORD *)v18 + 3) - v19) > 0xA)
  {
    *(_DWORD *)(v19 + 7) = 540701804;
    *(_QWORD *)v19 = *(_QWORD *)" (default: ";
    *((_QWORD *)v18 + 4) += 11;
  }
  else
  {
    v18 = llvm::raw_ostream::write(v18, " (default: ", 0xBuLL);
  }
  v20 = *(unsigned __int8 *)(a4 + 9);
  v21 = (llvm::raw_ostream *)llvm::outs(v18);
  v22 = *((_QWORD *)v21 + 4);
  if (v20)
  {
    v23 = *(_BYTE *)(a4 + 8);
    if (v22 >= *((_QWORD *)v21 + 3))
    {
      v21 = llvm::raw_ostream::write(v21, v23);
    }
    else
    {
      *((_QWORD *)v21 + 4) = v22 + 1;
      *(_BYTE *)v22 = v23;
    }
  }
  else if (*((_QWORD *)v21 + 3) - v22 > 0xB)
  {
    *(_DWORD *)(v22 + 8) = 712273013;
    *(_QWORD *)v22 = *(_QWORD *)"*no default*";
    *((_QWORD *)v21 + 4) += 12;
  }
  else
  {
    v21 = llvm::raw_ostream::write(v21, "*no default*", 0xCuLL);
  }
  v24 = (llvm::raw_ostream *)llvm::outs(v21);
  v25 = (_WORD *)*((_QWORD *)v24 + 4);
  if (*((_QWORD *)v24 + 3) - (_QWORD)v25 > 1uLL)
  {
    *v25 = 2601;
    *((_QWORD *)v24 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(v24, ")\n", 2uLL);
  }
  if (SHIBYTE(v37) < 0)
    operator delete(v35);
}

void llvm::cl::PrintOptionValues(llvm::cl *this)
{
  uint64_t v2;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v13;
  uint64_t v14;
  _QWORD v15[257];

  v15[256] = *MEMORY[0x1E0C80C00];
  if (!atomic_load((unint64_t *)&qword_1ED836A48))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1ED836A48, (void *(*)(void))sub_1C5DE673C, (void (*)(void *))sub_1C5DE6840);
  v2 = qword_1ED836A48;
  if (!atomic_load(qword_1ED825A30))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED825A30, (void *(*)(void))sub_1C5DE4BF0, (void (*)(void *))sub_1C5DE5210);
  if (*(_BYTE *)(qword_1ED825A30[0] + 1128))
    goto LABEL_9;
  if (!atomic_load(qword_1ED825A30))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED825A30, (void *(*)(void))sub_1C5DE4BF0, (void (*)(void *))sub_1C5DE5210);
  if (*(_BYTE *)(qword_1ED825A30[0] + 1320))
  {
LABEL_9:
    v13 = v15;
    v14 = 0x8000000000;
    sub_1C5DE6510(*(_QWORD **)(*(_QWORD *)(v2 + 336) + 128), *(_DWORD *)(*(_QWORD *)(v2 + 336) + 136), (uint64_t)&v13, 1);
    if ((_DWORD)v14)
    {
      v5 = 0;
      v6 = 0;
      v7 = 16 * v14;
      do
      {
        v8 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)((char *)v13 + v5 + 8) + 40))(*(_QWORD *)((char *)v13 + v5 + 8));
        if (v6 <= v8)
          v6 = v8;
        v5 += 16;
      }
      while (v7 != v5);
      if ((_DWORD)v14)
      {
        v9 = 0;
        v10 = 16 * v14;
        do
        {
          v11 = *(_QWORD *)((char *)v13 + v9 + 8);
          if (!atomic_load(qword_1ED825A30))
            llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED825A30, (void *(*)(void))sub_1C5DE4BF0, (void (*)(void *))sub_1C5DE5210);
          (*(void (**)(uint64_t, unint64_t, _QWORD))(*(_QWORD *)v11 + 56))(v11, v6, *(unsigned __int8 *)(qword_1ED825A30[0] + 1320));
          v9 += 16;
        }
        while (v10 != v9);
      }
    }
    if (v13 != v15)
      free(v13);
  }
}

void llvm::cl::PrintHelpMessage(llvm::cl *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  unint64_t v7;

  if ((this & 1) != 0 || (a2 & 1) != 0)
  {
    if (!(_DWORD)a2 || (this & 1) != 0)
    {
      v7 = atomic_load(qword_1ED825A30);
      if (!(_DWORD)this || (a2 & 1) != 0)
      {
        if (!v7)
          llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED825A30, (void *(*)(void))sub_1C5DE4BF0, (void (*)(void *))sub_1C5DE5210);
        v5 = qword_1ED825A30[0] + 48;
      }
      else
      {
        if (!v7)
          llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED825A30, (void *(*)(void))sub_1C5DE4BF0, (void (*)(void *))sub_1C5DE5210);
        v5 = qword_1ED825A30[0] + 16;
      }
    }
    else
    {
      if (!atomic_load(qword_1ED825A30))
        llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED825A30, (void *(*)(void))sub_1C5DE4BF0, (void (*)(void *))sub_1C5DE5210);
      v5 = qword_1ED825A30[0] + 32;
    }
  }
  else
  {
    if (!atomic_load(qword_1ED825A30))
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED825A30, (void *(*)(void))sub_1C5DE4BF0, (void (*)(void *))sub_1C5DE5210);
    v5 = qword_1ED825A30[0];
  }
  sub_1C5DE1664(v5, a2, a3, a4);
}

unint64_t sub_1C5DE1620()
{
  if (!atomic_load(qword_1ED825A30))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED825A30, (void *(*)(void))sub_1C5DE4BF0, (void (*)(void *))sub_1C5DE5210);
  return qword_1ED825A30[0];
}

void sub_1C5DE1664(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v6;
  llvm *v7;
  uint64_t v9;
  unsigned int *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t *v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  unint64_t *v19;
  unint64_t v20;
  llvm::raw_ostream *v22;
  llvm::raw_ostream *v23;
  uint64_t v24;
  const void *v26;
  unint64_t v27;
  llvm::raw_ostream *v29;
  llvm::raw_ostream *v30;
  _DWORD *v31;
  char v33;
  const char *v34;
  size_t v35;
  llvm *v36;
  void *v37;
  _QWORD *v38;
  uint64_t v39;
  llvm::raw_ostream *v40;
  llvm::raw_ostream *v41;
  uint64_t v42;
  _BYTE *v43;
  const void *v44;
  unint64_t v45;
  const void *v46;
  unint64_t v47;
  llvm::raw_ostream *v48;
  llvm::raw_ostream *v49;
  _DWORD *v50;
  char v52;
  const char *v53;
  size_t v54;
  _BYTE *v55;
  const void *v56;
  unint64_t v57;
  uint64_t v58;
  llvm::raw_ostream *v59;
  llvm::raw_ostream *v60;
  _BYTE *v61;
  uint64_t v62;
  const void *v63;
  size_t v64;
  uint64_t v65;
  uint64_t v66;
  _QWORD *v67;
  llvm::raw_ostream *v68;
  llvm::raw_ostream *v69;
  uint64_t v70;
  const void *v71;
  unint64_t v72;
  llvm::raw_ostream *v73;
  llvm::raw_ostream *v74;
  _BYTE *v75;
  const void *v76;
  unint64_t v77;
  uint64_t v79;
  llvm *v80;
  const char **v81;
  const char *v82;
  llvm *v83;
  llvm::raw_ostream *v84;
  _WORD *v85;
  llvm::raw_ostream *v86;
  void *v87;
  llvm::raw_ostream *v88;
  _BYTE *v89;
  llvm::raw_ostream *v90;
  llvm::raw_ostream *v91;
  _QWORD *v92;
  char v94;
  const char *v95;
  size_t v96;
  void *v97;
  llvm::raw_ostream *v98;
  _WORD *v99;
  llvm::raw_ostream *v100;
  uint64_t v101;
  uint64_t v102;
  llvm::raw_ostream *v103;
  uint64_t v104;
  llvm *v105;
  uint64_t v107;
  uint64_t v108;
  llvm::raw_ostream *v109;
  const void *v110;
  unint64_t v111;
  uint64_t v113;
  char *v114;
  llvm::raw_ostream *v115;
  llvm::raw_ostream *v116;
  _WORD *v117;
  const void *v118;
  size_t v119;
  llvm::raw_ostream *v120;
  int v121;
  llvm *v122;
  llvm::raw_ostream *v123;
  llvm::raw_ostream *v124;
  uint64_t v125;
  const void *v126;
  unint64_t v127;
  _BYTE *v128;
  uint64_t (***v129)(_QWORD, void **, llvm::raw_ostream *);
  void *__base;
  size_t __nel;
  _BYTE v132[2048];
  void *v133;
  uint64_t v134;
  _QWORD v135[258];

  v4 = MEMORY[0x1E0C80A78](a1, a2, a3, a4);
  v135[256] = *MEMORY[0x1E0C80C00];
  if (!atomic_load((unint64_t *)&qword_1ED836A48))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1ED836A48, (void *(*)(void))sub_1C5DE673C, (void (*)(void *))sub_1C5DE6840);
  v6 = *(_QWORD *)(qword_1ED836A48 + 336);
  v133 = v135;
  v134 = 0x8000000000;
  sub_1C5DE6510(*(_QWORD **)(v6 + 128), *(_DWORD *)(v6 + 136), (uint64_t)&v133, *(unsigned __int8 *)(v4 + 8));
  __base = v132;
  __nel = 0x8000000000;
  if (!atomic_load((unint64_t *)&qword_1ED836A48))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1ED836A48, (void *(*)(void))sub_1C5DE673C, (void (*)(void *))sub_1C5DE6840);
  v129 = (uint64_t (***)(_QWORD, void **, llvm::raw_ostream *))v4;
  v9 = *(_QWORD *)(qword_1ED836A48 + 280);
  v10 = (unsigned int *)(qword_1ED836A48 + 288);
  if (v9 == *(_QWORD *)(qword_1ED836A48 + 272))
    v10 = (unsigned int *)(qword_1ED836A48 + 292);
  v11 = *v10;
  if ((_DWORD)v11)
  {
    v12 = 8 * v11;
    v13 = *(unint64_t **)(qword_1ED836A48 + 280);
    while (*v13 >= 0xFFFFFFFFFFFFFFFELL)
    {
      ++v13;
      v12 -= 8;
      if (!v12)
        goto LABEL_23;
    }
  }
  else
  {
    v13 = *(unint64_t **)(qword_1ED836A48 + 280);
  }
  v14 = (unint64_t *)(v9 + 8 * v11);
  if (v13 != v14)
  {
    v15 = (uint64_t *)*v13;
LABEL_15:
    if (v15[1])
    {
      v16 = *v15;
      v17 = __nel;
      if (__nel >= (unint64_t)HIDWORD(__nel))
      {
        v7 = (llvm *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__base, (uint64_t)v132, __nel + 1, 16);
        v17 = __nel;
      }
      v18 = (char *)__base + 16 * v17;
      *v18 = v16;
      v18[1] = v15;
      LODWORD(__nel) = __nel + 1;
    }
    v19 = v13 + 1;
    while (v19 != v14)
    {
      v20 = *v19++;
      v15 = (uint64_t *)v20;
      if (v20 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        v13 = v19 - 1;
        goto LABEL_15;
      }
    }
  }
LABEL_23:
  if (__nel >= 2)
    qsort(__base, __nel, 0x10uLL, (int (__cdecl *)(const void *, const void *))sub_1C5DE6678);
  if (!atomic_load((unint64_t *)&qword_1ED836A48))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1ED836A48, (void *(*)(void))sub_1C5DE673C, (void (*)(void *))sub_1C5DE6840);
  if (*(_QWORD *)(qword_1ED836A48 + 32))
  {
    v22 = (llvm::raw_ostream *)llvm::outs(v7);
    v23 = v22;
    v24 = *((_QWORD *)v22 + 4);
    if ((unint64_t)(*((_QWORD *)v22 + 3) - v24) > 9)
    {
      *(_WORD *)(v24 + 8) = 8250;
      *(_QWORD *)v24 = *(_QWORD *)"OVERVIEW: ";
      *((_QWORD *)v22 + 4) += 10;
    }
    else
    {
      llvm::raw_ostream::write(v22, "OVERVIEW: ", 0xAuLL);
    }
    if (!atomic_load((unint64_t *)&qword_1ED836A48))
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1ED836A48, (void *(*)(void))sub_1C5DE673C, (void (*)(void *))sub_1C5DE6840);
    v26 = *(const void **)(qword_1ED836A48 + 24);
    v27 = *(_QWORD *)(qword_1ED836A48 + 32);
    v7 = (llvm *)*((_QWORD *)v23 + 4);
    if (v27 <= *((_QWORD *)v23 + 3) - (_QWORD)v7)
    {
      if (v27)
      {
        memcpy(v7, v26, *(_QWORD *)(qword_1ED836A48 + 32));
        v7 = (llvm *)(*((_QWORD *)v23 + 4) + v27);
        *((_QWORD *)v23 + 4) = v7;
      }
    }
    else
    {
      llvm::raw_ostream::write(v23, (const char *)v26, *(_QWORD *)(qword_1ED836A48 + 32));
      v7 = (llvm *)*((_QWORD *)v23 + 4);
    }
    if (*((llvm **)v23 + 3) == v7)
    {
      v7 = llvm::raw_ostream::write(v23, "\n", 1uLL);
    }
    else
    {
      *(_BYTE *)v7 = 10;
      ++*((_QWORD *)v23 + 4);
    }
  }
  if (!atomic_load(llvm::cl::TopLevelSubCommand))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)llvm::cl::TopLevelSubCommand, (void *(*)(void))sub_1C6386064, (void (*)(void *))sub_1C63860D8);
  if (v6 == llvm::cl::TopLevelSubCommand[0])
  {
    v29 = (llvm::raw_ostream *)llvm::outs(v7);
    v30 = v29;
    v31 = (_DWORD *)*((_QWORD *)v29 + 4);
    if (*((_QWORD *)v29 + 3) - (_QWORD)v31 > 6uLL)
    {
      *(_DWORD *)((char *)v31 + 3) = 540689735;
      *v31 = 1195463509;
      *((_QWORD *)v29 + 4) += 7;
    }
    else
    {
      llvm::raw_ostream::write(v29, "USAGE: ", 7uLL);
    }
    if (!atomic_load((unint64_t *)&qword_1ED836A48))
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1ED836A48, (void *(*)(void))sub_1C5DE673C, (void (*)(void *))sub_1C5DE6840);
    v33 = *(_BYTE *)(qword_1ED836A48 + 23);
    if (v33 >= 0)
      v34 = (const char *)qword_1ED836A48;
    else
      v34 = *(const char **)qword_1ED836A48;
    if (v33 >= 0)
      v35 = v33 & 0x7F;
    else
      v35 = *(_QWORD *)(qword_1ED836A48 + 8);
    v36 = llvm::raw_ostream::write(v30, v34, v35);
    if (__nel >= 3)
    {
      v36 = (llvm *)llvm::outs(v36);
      v37 = (void *)*((_QWORD *)v36 + 4);
      if (*((_QWORD *)v36 + 3) - (_QWORD)v37 > 0xCuLL)
      {
        qmemcpy(v37, " [subcommand]", 13);
        *((_QWORD *)v36 + 4) += 13;
      }
      else
      {
        v36 = llvm::raw_ostream::write(v36, " [subcommand]", 0xDuLL);
      }
    }
    v38 = llvm::outs(v36);
    v39 = v38[4];
    if ((unint64_t)(v38[3] - v39) <= 9)
      goto LABEL_89;
    *(_WORD *)(v39 + 8) = 23923;
    *(_QWORD *)v39 = *(_QWORD *)" [options]";
    v38[4] += 10;
  }
  else
  {
    if (*(_QWORD *)(v6 + 24))
    {
      v40 = (llvm::raw_ostream *)llvm::outs(v7);
      v41 = v40;
      v42 = *((_QWORD *)v40 + 4);
      if ((unint64_t)(*((_QWORD *)v40 + 3) - v42) > 0xB)
      {
        *(_DWORD *)(v42 + 8) = 656426062;
        *(_QWORD *)v42 = *(_QWORD *)"SUBCOMMAND '";
        v43 = (_BYTE *)(*((_QWORD *)v40 + 4) + 12);
        *((_QWORD *)v41 + 4) = v43;
      }
      else
      {
        llvm::raw_ostream::write(v40, "SUBCOMMAND '", 0xCuLL);
        v43 = (_BYTE *)*((_QWORD *)v41 + 4);
      }
      v44 = *(const void **)v6;
      v45 = *(_QWORD *)(v6 + 8);
      if (v45 <= *((_QWORD *)v41 + 3) - (_QWORD)v43)
      {
        if (v45)
        {
          memcpy(v43, v44, *(_QWORD *)(v6 + 8));
          v43 = (_BYTE *)(*((_QWORD *)v41 + 4) + v45);
          *((_QWORD *)v41 + 4) = v43;
        }
      }
      else
      {
        llvm::raw_ostream::write(v41, (const char *)v44, *(_QWORD *)(v6 + 8));
        v43 = (_BYTE *)*((_QWORD *)v41 + 4);
      }
      if (*((_QWORD *)v41 + 3) - (_QWORD)v43 > 2uLL)
      {
        v43[2] = 32;
        *(_WORD *)v43 = 14887;
        v7 = (llvm *)(*((_QWORD *)v41 + 4) + 3);
        *((_QWORD *)v41 + 4) = v7;
      }
      else
      {
        llvm::raw_ostream::write(v41, "': ", 3uLL);
        v7 = (llvm *)*((_QWORD *)v41 + 4);
      }
      v46 = *(const void **)(v6 + 16);
      v47 = *(_QWORD *)(v6 + 24);
      if (v47 <= *((_QWORD *)v41 + 3) - (_QWORD)v7)
      {
        if (v47)
        {
          memcpy(v7, v46, *(_QWORD *)(v6 + 24));
          v7 = (llvm *)(*((_QWORD *)v41 + 4) + v47);
          *((_QWORD *)v41 + 4) = v7;
        }
      }
      else
      {
        llvm::raw_ostream::write(v41, (const char *)v46, *(_QWORD *)(v6 + 24));
        v7 = (llvm *)*((_QWORD *)v41 + 4);
      }
      if (*((_QWORD *)v41 + 3) - (_QWORD)v7 > 1uLL)
      {
        *(_WORD *)v7 = 2570;
        *((_QWORD *)v41 + 4) += 2;
      }
      else
      {
        v7 = llvm::raw_ostream::write(v41, "\n\n", 2uLL);
      }
    }
    v48 = (llvm::raw_ostream *)llvm::outs(v7);
    v49 = v48;
    v50 = (_DWORD *)*((_QWORD *)v48 + 4);
    if (*((_QWORD *)v48 + 3) - (_QWORD)v50 > 6uLL)
    {
      *(_DWORD *)((char *)v50 + 3) = 540689735;
      *v50 = 1195463509;
      *((_QWORD *)v48 + 4) += 7;
    }
    else
    {
      llvm::raw_ostream::write(v48, "USAGE: ", 7uLL);
    }
    if (!atomic_load((unint64_t *)&qword_1ED836A48))
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1ED836A48, (void *(*)(void))sub_1C5DE673C, (void (*)(void *))sub_1C5DE6840);
    v52 = *(_BYTE *)(qword_1ED836A48 + 23);
    if (v52 >= 0)
      v53 = (const char *)qword_1ED836A48;
    else
      v53 = *(const char **)qword_1ED836A48;
    if (v52 >= 0)
      v54 = v52 & 0x7F;
    else
      v54 = *(_QWORD *)(qword_1ED836A48 + 8);
    llvm::raw_ostream::write(v49, v53, v54);
    v55 = (_BYTE *)*((_QWORD *)v49 + 4);
    if (*((_BYTE **)v49 + 3) == v55)
    {
      llvm::raw_ostream::write(v49, " ", 1uLL);
      v38 = (_QWORD *)*((_QWORD *)v49 + 4);
    }
    else
    {
      *v55 = 32;
      v38 = (_QWORD *)(*((_QWORD *)v49 + 4) + 1);
      *((_QWORD *)v49 + 4) = v38;
    }
    v56 = *(const void **)v6;
    v57 = *(_QWORD *)(v6 + 8);
    if (v57 <= *((_QWORD *)v49 + 3) - (_QWORD)v38)
    {
      if (v57)
      {
        memcpy(v38, v56, *(_QWORD *)(v6 + 8));
        v38 = (_QWORD *)(*((_QWORD *)v49 + 4) + v57);
        *((_QWORD *)v49 + 4) = v38;
      }
    }
    else
    {
      llvm::raw_ostream::write(v49, (const char *)v56, *(_QWORD *)(v6 + 8));
      v38 = (_QWORD *)*((_QWORD *)v49 + 4);
    }
    if (*((_QWORD *)v49 + 3) - (_QWORD)v38 <= 9uLL)
    {
      v38 = v49;
LABEL_89:
      v38 = llvm::raw_ostream::write((llvm::raw_ostream *)v38, " [options]", 0xAuLL);
      goto LABEL_90;
    }
    *((_WORD *)v38 + 4) = 23923;
    *v38 = *(_QWORD *)" [options]";
    *((_QWORD *)v49 + 4) += 10;
  }
LABEL_90:
  v58 = *(unsigned int *)(v6 + 40);
  if ((_DWORD)v58)
  {
    v65 = *(_QWORD *)(v6 + 32);
    v66 = 8 * v58;
    do
    {
      v67 = *(_QWORD **)v65;
      if (*(_QWORD *)(*(_QWORD *)v65 + 24))
      {
        v68 = (llvm::raw_ostream *)llvm::outs((llvm *)v38);
        v69 = v68;
        v70 = *((_QWORD *)v68 + 4);
        if ((unint64_t)(*((_QWORD *)v68 + 3) - v70) > 2)
        {
          *(_BYTE *)(v70 + 2) = 45;
          *(_WORD *)v70 = 11552;
          v38 = (_QWORD *)(*((_QWORD *)v68 + 4) + 3);
          *((_QWORD *)v69 + 4) = v38;
        }
        else
        {
          llvm::raw_ostream::write(v68, " --", 3uLL);
          v38 = (_QWORD *)*((_QWORD *)v69 + 4);
        }
        v71 = (const void *)v67[2];
        v72 = v67[3];
        if (v72 <= *((_QWORD *)v69 + 3) - (_QWORD)v38)
        {
          if (v72)
          {
            v38 = memcpy(v38, v71, v67[3]);
            *((_QWORD *)v69 + 4) += v72;
          }
        }
        else
        {
          v38 = llvm::raw_ostream::write(v69, (const char *)v71, v67[3]);
        }
      }
      v73 = (llvm::raw_ostream *)llvm::outs((llvm *)v38);
      v74 = v73;
      v75 = (_BYTE *)*((_QWORD *)v73 + 4);
      if (*((_BYTE **)v73 + 3) == v75)
      {
        llvm::raw_ostream::write(v73, " ", 1uLL);
        v38 = (_QWORD *)*((_QWORD *)v74 + 4);
      }
      else
      {
        *v75 = 32;
        v38 = (_QWORD *)(*((_QWORD *)v73 + 4) + 1);
        *((_QWORD *)v74 + 4) = v38;
      }
      v76 = (const void *)v67[4];
      v77 = v67[5];
      if (v77 <= *((_QWORD *)v74 + 3) - (_QWORD)v38)
      {
        if (v77)
        {
          v38 = memcpy(v38, v76, v67[5]);
          *((_QWORD *)v74 + 4) += v77;
        }
      }
      else
      {
        v38 = llvm::raw_ostream::write(v74, (const char *)v76, v67[5]);
      }
      v65 += 8;
      v66 -= 8;
    }
    while (v66);
  }
  if (*(_QWORD *)(v6 + 160))
  {
    v59 = (llvm::raw_ostream *)llvm::outs((llvm *)v38);
    v60 = v59;
    v61 = (_BYTE *)*((_QWORD *)v59 + 4);
    if (*((_BYTE **)v59 + 3) == v61)
    {
      llvm::raw_ostream::write(v59, " ", 1uLL);
      v38 = (_QWORD *)*((_QWORD *)v60 + 4);
    }
    else
    {
      *v61 = 32;
      v38 = (_QWORD *)(*((_QWORD *)v59 + 4) + 1);
      *((_QWORD *)v60 + 4) = v38;
    }
    v62 = *(_QWORD *)(v6 + 160);
    v63 = *(const void **)(v62 + 32);
    v64 = *(_QWORD *)(v62 + 40);
    if (v64 <= *((_QWORD *)v60 + 3) - (_QWORD)v38)
    {
      if (v64)
      {
        v38 = memcpy(v38, v63, v64);
        *((_QWORD *)v60 + 4) += v64;
      }
    }
    else
    {
      v38 = llvm::raw_ostream::write(v60, (const char *)v63, v64);
    }
  }
  if (!atomic_load(llvm::cl::TopLevelSubCommand))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)llvm::cl::TopLevelSubCommand, (void *(*)(void))sub_1C6386064, (void (*)(void *))sub_1C63860D8);
  if (v6 == llvm::cl::TopLevelSubCommand[0])
  {
    v79 = __nel;
    if ((_DWORD)__nel)
    {
      v80 = 0;
      v81 = (const char **)__base;
      do
      {
        v82 = *v81;
        v81 += 2;
        v83 = (llvm *)strlen(v82);
        if (v80 <= v83)
          v80 = v83;
        --v79;
      }
      while (v79);
      v84 = (llvm::raw_ostream *)llvm::outs(v83);
      v85 = (_WORD *)*((_QWORD *)v84 + 4);
      if (*((_QWORD *)v84 + 3) - (_QWORD)v85 > 1uLL)
      {
        *v85 = 2570;
        *((_QWORD *)v84 + 4) += 2;
      }
      else
      {
        v84 = llvm::raw_ostream::write(v84, "\n\n", 2uLL);
      }
      v86 = (llvm::raw_ostream *)llvm::outs(v84);
      v87 = (void *)*((_QWORD *)v86 + 4);
      if (*((_QWORD *)v86 + 3) - (_QWORD)v87 > 0xDuLL)
      {
        qmemcpy(v87, "SUBCOMMANDS:\n\n", 14);
        *((_QWORD *)v86 + 4) += 14;
      }
      else
      {
        v86 = llvm::raw_ostream::write(v86, "SUBCOMMANDS:\n\n", 0xEuLL);
      }
      if ((_DWORD)__nel)
      {
        v113 = 16 * __nel;
        v114 = (char *)__base + 8;
        do
        {
          v115 = (llvm::raw_ostream *)llvm::outs(v86);
          v116 = v115;
          v117 = (_WORD *)*((_QWORD *)v115 + 4);
          if (*((_QWORD *)v115 + 3) - (_QWORD)v117 > 1uLL)
          {
            *v117 = 8224;
            *((_QWORD *)v115 + 4) += 2;
          }
          else
          {
            v115 = llvm::raw_ostream::write(v115, "  ", 2uLL);
          }
          v118 = (const void *)*((_QWORD *)v114 - 1);
          if (v118)
          {
            v119 = strlen(*((const char **)v114 - 1));
            v115 = (llvm::raw_ostream *)*((_QWORD *)v116 + 4);
            if (v119 <= *((_QWORD *)v116 + 3) - (_QWORD)v115)
            {
              if (v119)
              {
                v115 = (llvm::raw_ostream *)memcpy(v115, v118, v119);
                *((_QWORD *)v116 + 4) += v119;
              }
            }
            else
            {
              v115 = llvm::raw_ostream::write(v116, (const char *)v118, v119);
            }
          }
          if (*(_QWORD *)(*(_QWORD *)v114 + 24))
          {
            v120 = (llvm::raw_ostream *)llvm::outs(v115);
            v121 = strlen(*((const char **)v114 - 1));
            v122 = llvm::raw_ostream::indent(v120, (int)v80 - v121);
            v123 = (llvm::raw_ostream *)llvm::outs(v122);
            v124 = v123;
            v125 = *((_QWORD *)v123 + 4);
            if ((unint64_t)(*((_QWORD *)v123 + 3) - v125) > 2)
            {
              *(_BYTE *)(v125 + 2) = 32;
              *(_WORD *)v125 = 11552;
              v115 = (llvm::raw_ostream *)(*((_QWORD *)v123 + 4) + 3);
              *((_QWORD *)v124 + 4) = v115;
            }
            else
            {
              llvm::raw_ostream::write(v123, " - ", 3uLL);
              v115 = (llvm::raw_ostream *)*((_QWORD *)v124 + 4);
            }
            v126 = *(const void **)(*(_QWORD *)v114 + 16);
            v127 = *(_QWORD *)(*(_QWORD *)v114 + 24);
            if (v127 <= *((_QWORD *)v124 + 3) - (_QWORD)v115)
            {
              if (v127)
              {
                v115 = (llvm::raw_ostream *)memcpy(v115, v126, *(_QWORD *)(*(_QWORD *)v114 + 24));
                *((_QWORD *)v124 + 4) += v127;
              }
            }
            else
            {
              v115 = llvm::raw_ostream::write(v124, (const char *)v126, *(_QWORD *)(*(_QWORD *)v114 + 24));
            }
          }
          v86 = (llvm::raw_ostream *)llvm::outs(v115);
          v128 = (_BYTE *)*((_QWORD *)v86 + 4);
          if (*((_BYTE **)v86 + 3) == v128)
          {
            v86 = llvm::raw_ostream::write(v86, "\n", 1uLL);
          }
          else
          {
            *v128 = 10;
            ++*((_QWORD *)v86 + 4);
          }
          v114 += 16;
          v113 -= 16;
        }
        while (v113);
      }
      v88 = (llvm::raw_ostream *)llvm::outs(v86);
      v89 = (_BYTE *)*((_QWORD *)v88 + 4);
      if (*((_BYTE **)v88 + 3) == v89)
      {
        v88 = llvm::raw_ostream::write(v88, "\n", 1uLL);
      }
      else
      {
        *v89 = 10;
        ++*((_QWORD *)v88 + 4);
      }
      v90 = (llvm::raw_ostream *)llvm::outs(v88);
      v91 = v90;
      v92 = (_QWORD *)*((_QWORD *)v90 + 4);
      if (*((_QWORD *)v90 + 3) - (_QWORD)v92 > 7uLL)
      {
        *v92 = 0x2220657079542020;
        *((_QWORD *)v90 + 4) += 8;
      }
      else
      {
        llvm::raw_ostream::write(v90, "  Type \"", 8uLL);
      }
      if (!atomic_load((unint64_t *)&qword_1ED836A48))
        llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1ED836A48, (void *(*)(void))sub_1C5DE673C, (void (*)(void *))sub_1C5DE6840);
      v94 = *(_BYTE *)(qword_1ED836A48 + 23);
      if (v94 >= 0)
        v95 = (const char *)qword_1ED836A48;
      else
        v95 = *(const char **)qword_1ED836A48;
      if (v94 >= 0)
        v96 = v94 & 0x7F;
      else
        v96 = *(_QWORD *)(qword_1ED836A48 + 8);
      v38 = llvm::raw_ostream::write(v91, v95, v96);
      v97 = (void *)*((_QWORD *)v91 + 4);
      if (*((_QWORD *)v91 + 3) - (_QWORD)v97 > 0x3EuLL)
      {
        qmemcpy(v97, " <subcommand> --help\" to get more help on a specific subcommand", 63);
        *((_QWORD *)v91 + 4) += 63;
      }
      else
      {
        v38 = llvm::raw_ostream::write(v91, " <subcommand> --help\" to get more help on a specific subcommand", 0x3FuLL);
      }
    }
  }
  v98 = (llvm::raw_ostream *)llvm::outs((llvm *)v38);
  v99 = (_WORD *)*((_QWORD *)v98 + 4);
  if (*((_QWORD *)v98 + 3) - (_QWORD)v99 > 1uLL)
  {
    *v99 = 2570;
    *((_QWORD *)v98 + 4) += 2;
  }
  else
  {
    v98 = llvm::raw_ostream::write(v98, "\n\n", 2uLL);
  }
  if ((_DWORD)v134)
  {
    v101 = 0;
    v100 = 0;
    v102 = 16 * v134;
    do
    {
      v98 = (llvm::raw_ostream *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)((char *)v133 + v101 + 8) + 40))(*(_QWORD *)((char *)v133 + v101 + 8));
      if (v100 <= v98)
        v100 = v98;
      v101 += 16;
    }
    while (v102 != v101);
  }
  else
  {
    v100 = 0;
  }
  v103 = (llvm::raw_ostream *)llvm::outs(v98);
  v104 = *((_QWORD *)v103 + 4);
  if ((unint64_t)(*((_QWORD *)v103 + 3) - v104) > 8)
  {
    *(_BYTE *)(v104 + 8) = 10;
    *(_QWORD *)v104 = *(_QWORD *)"OPTIONS:\n";
    *((_QWORD *)v103 + 4) += 9;
  }
  else
  {
    llvm::raw_ostream::write(v103, "OPTIONS:\n", 9uLL);
  }
  v105 = (llvm *)(**v129)(v129, &v133, v100);
  if (!atomic_load((unint64_t *)&qword_1ED836A48))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1ED836A48, (void *(*)(void))sub_1C5DE673C, (void (*)(void *))sub_1C5DE6840);
  v107 = *(_QWORD *)(qword_1ED836A48 + 40);
  v108 = *(_QWORD *)(qword_1ED836A48 + 48);
  while (v107 != v108)
  {
    v109 = (llvm::raw_ostream *)llvm::outs(v105);
    v110 = *(const void **)v107;
    v111 = *(_QWORD *)(v107 + 8);
    v105 = (llvm *)*((_QWORD *)v109 + 4);
    if (v111 <= *((_QWORD *)v109 + 3) - (_QWORD)v105)
    {
      if (v111)
      {
        v105 = (llvm *)memcpy(v105, v110, *(_QWORD *)(v107 + 8));
        *((_QWORD *)v109 + 4) += v111;
      }
    }
    else
    {
      v105 = llvm::raw_ostream::write(v109, (const char *)v110, *(_QWORD *)(v107 + 8));
    }
    v107 += 16;
  }
  if (!atomic_load((unint64_t *)&qword_1ED836A48))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1ED836A48, (void *(*)(void))sub_1C5DE673C, (void (*)(void *))sub_1C5DE6840);
  *(_QWORD *)(qword_1ED836A48 + 48) = *(_QWORD *)(qword_1ED836A48 + 40);
  if (__base != v132)
    free(__base);
  if (v133 != v135)
    free(v133);
}

void sub_1C5DE2540(llvm *a1)
{
  llvm::raw_ostream *v1;
  llvm::raw_ostream *v2;
  void *v3;
  _DWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  const char *HostCPUName;
  unint64_t v10;
  const char *v11;
  size_t v12;
  void ***p_dst;
  uint64_t v14;
  uint64_t v15;
  size_t v16;
  unint64_t v17;
  void **v18;
  size_t v19;
  _WORD *v20;
  uint64_t v21;
  void **v22;
  size_t v23;
  _BYTE *v24;
  uint64_t v25;
  const char *v26;
  size_t v27;
  _BYTE *v28;
  void *__p[2];
  char v30;
  void **__dst;
  size_t v32;
  int64_t v33;

  v1 = (llvm::raw_ostream *)llvm::outs(a1);
  v2 = v1;
  v3 = (void *)*((_QWORD *)v1 + 4);
  if (*((_QWORD *)v1 + 3) - (_QWORD)v3 > 0x1AuLL)
  {
    qmemcpy(v3, "LLVM (http://llvm.org/):\n  ", 27);
    v4 = (_DWORD *)(*((_QWORD *)v1 + 4) + 27);
    *((_QWORD *)v1 + 4) = v4;
  }
  else
  {
    v1 = llvm::raw_ostream::write(v1, "LLVM (http://llvm.org/):\n  ", 0x1BuLL);
    v4 = (_DWORD *)*((_QWORD *)v2 + 4);
  }
  if (*((_QWORD *)v2 + 3) - (_QWORD)v4 > 3uLL)
  {
    *v4 = 1297501260;
    v5 = *((_QWORD *)v2 + 4) + 4;
    *((_QWORD *)v2 + 4) = v5;
  }
  else
  {
    v1 = llvm::raw_ostream::write(v2, "LLVM", 4uLL);
    v5 = *((_QWORD *)v2 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v2 + 3) - v5) > 8)
  {
    *(_BYTE *)(v5 + 8) = 32;
    *(_QWORD *)v5 = *(_QWORD *)" version ";
    v6 = *((_QWORD *)v2 + 4) + 9;
    *((_QWORD *)v2 + 4) = v6;
  }
  else
  {
    v1 = llvm::raw_ostream::write(v2, " version ", 9uLL);
    v6 = *((_QWORD *)v2 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v2 + 3) - v6) > 8)
  {
    *(_BYTE *)(v6 + 8) = 52;
    *(_QWORD *)v6 = *(_QWORD *)"32023.334";
    v7 = *((_QWORD *)v2 + 4) + 9;
    *((_QWORD *)v2 + 4) = v7;
  }
  else
  {
    v1 = llvm::raw_ostream::write(v2, "32023.334", 9uLL);
    v7 = *((_QWORD *)v2 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v2 + 3) - v7) > 2)
  {
    *(_BYTE *)(v7 + 2) = 32;
    *(_WORD *)v7 = 8202;
    v8 = (void *)(*((_QWORD *)v2 + 4) + 3);
    *((_QWORD *)v2 + 4) = v8;
  }
  else
  {
    v1 = llvm::raw_ostream::write(v2, "\n  ", 3uLL);
    v8 = (void *)*((_QWORD *)v2 + 4);
  }
  if (*((_QWORD *)v2 + 3) - (_QWORD)v8 > 0xEuLL)
  {
    qmemcpy(v8, "Optimized build", 15);
    *((_QWORD *)v2 + 4) += 15;
  }
  else
  {
    v1 = llvm::raw_ostream::write(v2, "Optimized build", 0xFuLL);
  }
  HostCPUName = llvm::sys::getHostCPUName(v1);
  if (v10 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v11 = HostCPUName;
  v12 = v10;
  if (v10 >= 0x17)
  {
    v14 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v10 | 7) != 0x17)
      v14 = v10 | 7;
    v15 = v14 + 1;
    p_dst = (void ***)operator new(v14 + 1);
    v32 = v12;
    v33 = v15 | 0x8000000000000000;
    __dst = (void **)p_dst;
    goto LABEL_20;
  }
  HIBYTE(v33) = v10;
  p_dst = &__dst;
  if (v10)
LABEL_20:
    memmove(p_dst, v11, v12);
  *((_BYTE *)p_dst + v12) = 0;
  if (v33 >= 0)
    v16 = HIBYTE(v33) & 0x7F;
  else
    v16 = v32;
  if (v16 == 7)
  {
    v17 = v33 >= 0 ? HIBYTE(v33) : v32;
    v18 = v33 >= 0 ? (void **)&__dst : __dst;
    v19 = v17 >= 7 ? 7 : v17;
    if (!memcmp(v18, "generic", v19) && v17 == 7)
      MEMORY[0x1CAA32ABC](&__dst, "(unknown)");
  }
  v20 = (_WORD *)*((_QWORD *)v2 + 4);
  if (*((_QWORD *)v2 + 3) - (_QWORD)v20 > 1uLL)
  {
    *v20 = 2606;
    v21 = *((_QWORD *)v2 + 4) + 2;
    *((_QWORD *)v2 + 4) = v21;
  }
  else
  {
    llvm::raw_ostream::write(v2, ".\n", 2uLL);
    v21 = *((_QWORD *)v2 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v2 + 3) - v21) > 0x11)
  {
    *(_WORD *)(v21 + 16) = 8250;
    *(_OWORD *)v21 = *(_OWORD *)"  Default target: ";
    *((_QWORD *)v2 + 4) += 18;
  }
  else
  {
    llvm::raw_ostream::write(v2, "  Default target: ", 0x12uLL);
  }
  llvm::sys::getDefaultTargetTriple((uint64_t)__p);
  if (v30 >= 0)
    v22 = __p;
  else
    v22 = (void **)__p[0];
  if (v30 >= 0)
    v23 = v30 & 0x7F;
  else
    v23 = (size_t)__p[1];
  llvm::raw_ostream::write(v2, (const char *)v22, v23);
  v24 = (_BYTE *)*((_QWORD *)v2 + 4);
  if ((unint64_t)v24 >= *((_QWORD *)v2 + 3))
  {
    llvm::raw_ostream::write(v2, 10);
  }
  else
  {
    *((_QWORD *)v2 + 4) = v24 + 1;
    *v24 = 10;
  }
  v25 = *((_QWORD *)v2 + 4);
  if ((unint64_t)(*((_QWORD *)v2 + 3) - v25) > 0xB)
  {
    *(_DWORD *)(v25 + 8) = 540693840;
    *(_QWORD *)v25 = *(_QWORD *)"  Host CPU: ";
    *((_QWORD *)v2 + 4) += 12;
  }
  else
  {
    llvm::raw_ostream::write(v2, "  Host CPU: ", 0xCuLL);
  }
  if (v33 >= 0)
    v26 = (const char *)&__dst;
  else
    v26 = (const char *)__dst;
  if (v33 >= 0)
    v27 = HIBYTE(v33) & 0x7F;
  else
    v27 = v32;
  llvm::raw_ostream::write(v2, v26, v27);
  if (v30 < 0)
    operator delete(__p[0]);
  v28 = (_BYTE *)*((_QWORD *)v2 + 4);
  if ((unint64_t)v28 >= *((_QWORD *)v2 + 3))
  {
    llvm::raw_ostream::write(v2, 10);
  }
  else
  {
    *((_QWORD *)v2 + 4) = v28 + 1;
    *v28 = 10;
  }
  if (SHIBYTE(v33) < 0)
    operator delete(__dst);
}

uint64_t llvm::cl::SetVersionPrinter(_QWORD *a1)
{
  unint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t result;
  uint64_t (**v9)(void);
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[4];

  v12[3] = *MEMORY[0x1E0C80C00];
  if (!atomic_load(qword_1ED825A30))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED825A30, (void *(*)(void))sub_1C5DE4BF0, (void (*)(void *))sub_1C5DE5210);
  v3 = qword_1ED825A30[0];
  v4 = (_QWORD *)(qword_1ED825A30[0] + 1384);
  v5 = (_QWORD *)a1[3];
  if (v5)
  {
    if (v5 == a1)
    {
      v11 = v10;
      (*(void (**)(_QWORD *, _QWORD *))(*a1 + 24))(a1, v10);
    }
    else
    {
      v11 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v5 + 16))(v5);
    }
  }
  else
  {
    v11 = 0;
  }
  if (v10 != v4)
  {
    v6 = v11;
    v7 = *(_QWORD **)(v3 + 1408);
    if (v11 == v10)
    {
      if (v7 == v4)
      {
        (*(void (**)(_QWORD *, _QWORD *))(v10[0] + 24))(v10, v12);
        (*(void (**)(_QWORD *))(*v11 + 32))(v11);
        v11 = 0;
        (*(void (**)(_QWORD, _QWORD *))(**(_QWORD **)(v3 + 1408) + 24))(*(_QWORD *)(v3 + 1408), v10);
        (*(void (**)(_QWORD))(**(_QWORD **)(v3 + 1408) + 32))(*(_QWORD *)(v3 + 1408));
        *(_QWORD *)(v3 + 1408) = 0;
        v11 = v10;
        (*(void (**)(_QWORD *, _QWORD *))(v12[0] + 24))(v12, v4);
        (*(void (**)(_QWORD *))(v12[0] + 32))(v12);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(v10[0] + 24))(v10, v4);
        (*(void (**)(_QWORD *))(*v11 + 32))(v11);
        v11 = *(_QWORD **)(v3 + 1408);
      }
      *(_QWORD *)(v3 + 1408) = v4;
    }
    else if (v7 == v4)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*(_QWORD *)(v3 + 1384) + 24))(v4, v10);
      (*(void (**)(_QWORD))(**(_QWORD **)(v3 + 1408) + 32))(*(_QWORD *)(v3 + 1408));
      *(_QWORD *)(v3 + 1408) = v11;
      v11 = v10;
    }
    else
    {
      v11 = *(_QWORD **)(v3 + 1408);
      *(_QWORD *)(v3 + 1408) = v6;
    }
  }
  result = (uint64_t)v11;
  if (v11 == v10)
  {
    v9 = (uint64_t (**)(void))(v10[0] + 32);
  }
  else
  {
    if (!v11)
      return result;
    v9 = (uint64_t (**)(void))(*v11 + 40);
  }
  return (*v9)();
}

uint64_t sub_1C5DE2BF8(_QWORD *a1, _QWORD *a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t result;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  _QWORD *v14;
  _QWORD v15[5];

  v4 = a1[2];
  v5 = a1[1];
  if (v5 >= v4)
  {
    v8 = (uint64_t)(v5 - *a1) >> 5;
    if ((unint64_t)(v8 + 1) >> 59)
      abort();
    v9 = v4 - *a1;
    v10 = v9 >> 4;
    if (v9 >> 4 <= (unint64_t)(v8 + 1))
      v10 = v8 + 1;
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFE0)
      v11 = 0x7FFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v15[4] = a1 + 2;
    if (v11)
    {
      if (v11 >> 59)
        sub_1C4764EE4();
      v12 = (char *)operator new(32 * v11);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[32 * v8];
    v15[0] = v12;
    v15[1] = v13;
    v15[3] = &v12[32 * v11];
    v14 = (_QWORD *)a2[3];
    if (v14)
    {
      if (v14 == a2)
      {
        *((_QWORD *)v13 + 3) = v13;
        (*(void (**)(_QWORD *, char *))(*a2 + 24))(a2, v13);
      }
      else
      {
        *((_QWORD *)v13 + 3) = (*(uint64_t (**)(_QWORD *))(*v14 + 16))(v14);
      }
    }
    else
    {
      *((_QWORD *)v13 + 3) = 0;
    }
    v15[2] = v13 + 32;
    sub_1C63865B0(a1, v15);
    v7 = a1[1];
    result = sub_1C6386688((uint64_t)v15);
  }
  else
  {
    result = a2[3];
    if (result)
    {
      if ((_QWORD *)result == a2)
      {
        *(_QWORD *)(v5 + 24) = v5;
        result = (*(uint64_t (**)(_QWORD, unint64_t))(*(_QWORD *)a2[3] + 24))(a2[3], v5);
      }
      else
      {
        result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
        *(_QWORD *)(v5 + 24) = result;
      }
    }
    else
    {
      *(_QWORD *)(v5 + 24) = 0;
    }
    v7 = v5 + 32;
  }
  a1[1] = v7;
  return result;
}

uint64_t llvm::cl::getRegisteredOptions(llvm::cl *this, llvm::cl::SubCommand *a2)
{
  sub_1C5DDEC70(this);
  if (!atomic_load((unint64_t *)&qword_1ED836A48))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1ED836A48, (void *(*)(void))sub_1C5DE673C, (void (*)(void *))sub_1C5DE6840);
  return (uint64_t)this + 128;
}

void llvm::cl::getRegisteredSubcommands(_QWORD *a1@<X8>)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;

  if (!atomic_load((unint64_t *)&qword_1ED836A48))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1ED836A48, (void *(*)(void))sub_1C5DE673C, (void (*)(void *))sub_1C5DE6840);
  v4 = *(_QWORD **)(qword_1ED836A48 + 280);
  v5 = 288;
  if (v4 == *(_QWORD **)(qword_1ED836A48 + 272))
    v5 = 292;
  v6 = *(unsigned int *)(qword_1ED836A48 + v5);
  v7 = &v4[v6];
  if ((_DWORD)v6)
  {
    v8 = 8 * v6;
    while (*v4 >= 0xFFFFFFFFFFFFFFFELL)
    {
      ++v4;
      v8 -= 8;
      if (!v8)
      {
        v4 = v7;
        break;
      }
    }
  }
  *a1 = v4;
  a1[1] = v7;
  a1[2] = v7;
  a1[3] = v7;
}

void llvm::cl::HideUnrelatedOptions(llvm::cl *this, llvm::cl::OptionCategory *a2, llvm::cl::SubCommand *a3)
{
  uint64_t v5;
  uint64_t *i;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  llvm::cl **v11;
  llvm::cl **v12;
  char v13;
  llvm::cl *v14;
  uint64_t v16;
  BOOL v17;
  uint64_t v18;

  sub_1C5DDEC70(this);
  v5 = *((unsigned int *)a2 + 34);
  if ((_DWORD)v5)
  {
    for (i = (uint64_t *)*((_QWORD *)a2 + 16); !*i || *i == -8; ++i)
      ;
  }
  else
  {
    i = (uint64_t *)*((_QWORD *)a2 + 16);
  }
  v18 = *((_QWORD *)a2 + 16) + 8 * v5;
  if (i != (uint64_t *)v18)
  {
    v8 = *i;
    do
    {
      v9 = *(_QWORD *)(v8 + 8);
      v10 = *(unsigned int *)(v9 + 72);
      if ((_DWORD)v10)
      {
        v11 = *(llvm::cl ***)(v9 + 64);
        v12 = &v11[v10];
        v13 = 1;
        do
        {
          while (1)
          {
            v14 = *v11;
            if (*v11 != this)
            {
              if (!atomic_load(qword_1ED825A30))
                llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED825A30, (void *(*)(void))sub_1C5DE4BF0, (void (*)(void *))sub_1C5DE5210);
              if (v14 != (llvm::cl *)(qword_1ED825A30[0] + 96))
                break;
            }
            v13 = 0;
            if (++v11 == v12)
              goto LABEL_25;
          }
          ++v11;
        }
        while (v11 != v12);
        if ((v13 & 1) == 0)
          goto LABEL_25;
        v9 = *(_QWORD *)(v8 + 8);
      }
      *(_WORD *)(v9 + 10) = *(_WORD *)(v9 + 10) & 0xFF9F | 0x40;
      do
      {
LABEL_25:
        v16 = i[1];
        ++i;
        v8 = v16;
        if (v16)
          v17 = v8 == -8;
        else
          v17 = 1;
      }
      while (v17);
    }
    while (i != (uint64_t *)v18);
  }
}

void llvm::cl::HideUnrelatedOptions(llvm *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t *i;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v18;
  BOOL v19;
  uint64_t v20;
  char v21;

  sub_1C5DDEC70(a1);
  v6 = *(unsigned int *)(a3 + 136);
  if ((_DWORD)v6)
  {
    for (i = *(uint64_t **)(a3 + 128); !*i || *i == -8; ++i)
      ;
  }
  else
  {
    i = *(uint64_t **)(a3 + 128);
  }
  v20 = *(_QWORD *)(a3 + 128) + 8 * v6;
  if (i != (uint64_t *)v20)
  {
    v9 = *i;
    do
    {
      v10 = *(_QWORD *)(v9 + 8);
      v11 = *(unsigned int *)(v10 + 72);
      if ((_DWORD)v11)
      {
        v12 = *(uint64_t **)(v10 + 64);
        v13 = &v12[v11];
        v21 = 1;
        do
        {
          while (1)
          {
            if (a2)
            {
              v14 = 8 * a2;
              v15 = (char *)a1;
              while (*(_QWORD *)v15 != *v12)
              {
                v15 += 8;
                v14 -= 8;
                if (!v14)
                {
                  v15 = (char *)a1 + 8 * a2;
                  break;
                }
              }
            }
            else
            {
              v15 = (char *)a1;
            }
            if (a2 == (v15 - (char *)a1) >> 3)
            {
              v16 = *v12;
              if (!atomic_load(qword_1ED825A30))
                llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED825A30, (void *(*)(void))sub_1C5DE4BF0, (void (*)(void *))sub_1C5DE5210);
              if (v16 != qword_1ED825A30[0] + 96)
                break;
            }
            v21 = 0;
            if (++v12 == v13)
              goto LABEL_31;
          }
          ++v12;
        }
        while (v12 != v13);
        if ((v21 & 1) == 0)
          goto LABEL_31;
        v10 = *(_QWORD *)(v9 + 8);
      }
      *(_WORD *)(v10 + 10) = *(_WORD *)(v10 + 10) & 0xFF9F | 0x40;
      do
      {
LABEL_31:
        v18 = i[1];
        ++i;
        v9 = v18;
        if (v18)
          v19 = v9 == -8;
        else
          v19 = 1;
      }
      while (v19);
    }
    while (i != (uint64_t *)v20);
  }
}

void llvm::cl::ResetCommandLineParser(llvm::cl *this)
{
  uint64_t v2;
  void *v3;
  void *v4;
  unint64_t v6;
  uint64_t v8;
  uint64_t v11;
  uint64_t v13;
  unsigned int v15;
  int v16;
  unsigned int v17;
  void *v18;
  unsigned int v19;
  int v20;
  unsigned int v21;
  void *v22;

  if (!atomic_load((unint64_t *)&qword_1ED836A48))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1ED836A48, (void *(*)(void))sub_1C5DE673C, (void (*)(void *))sub_1C5DE6840);
  v2 = qword_1ED836A48;
  *(_QWORD *)(qword_1ED836A48 + 336) = 0;
  if (*(char *)(v2 + 23) < 0)
  {
    **(_BYTE **)v2 = 0;
    *(_QWORD *)(v2 + 8) = 0;
  }
  else
  {
    *(_BYTE *)v2 = 0;
    *(_BYTE *)(v2 + 23) = 0;
  }
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 48) = *(_QWORD *)(v2 + 40);
  v3 = *(void **)(v2 + 120);
  if (v3 == *(void **)(v2 + 112))
    goto LABEL_7;
  v11 = *(unsigned int *)(v2 + 128);
  if (v11 < 0x21 || 4 * (*(_DWORD *)(v2 + 132) - *(_DWORD *)(v2 + 136)) >= v11)
  {
    memset(v3, 255, 8 * v11);
LABEL_7:
    *(_DWORD *)(v2 + 132) = 0;
    *(_DWORD *)(v2 + 136) = 0;
    goto LABEL_8;
  }
  free(v3);
  v15 = *(_DWORD *)(v2 + 132) - *(_DWORD *)(v2 + 136);
  v16 = 1 << (33 - __clz(v15 - 1));
  *(_DWORD *)(v2 + 132) = 0;
  *(_DWORD *)(v2 + 136) = 0;
  if (v15 <= 0x10)
    v17 = 32;
  else
    v17 = v16;
  *(_DWORD *)(v2 + 128) = v17;
  v18 = malloc_type_malloc(8 * v17, 0x4065EBACuLL);
  if (!v18)
    goto LABEL_41;
  *(_QWORD *)(v2 + 120) = v18;
  memset(v18, 255, 8 * *(unsigned int *)(v2 + 128));
LABEL_8:
  sub_1C5DE3414(v2);
  v4 = *(void **)(v2 + 280);
  if (v4 == *(void **)(v2 + 272))
  {
LABEL_9:
    *(_QWORD *)(v2 + 292) = 0;
    goto LABEL_10;
  }
  v13 = *(unsigned int *)(v2 + 288);
  if (v13 < 0x21 || 4 * (*(_DWORD *)(v2 + 292) - *(_DWORD *)(v2 + 296)) >= v13)
  {
    memset(v4, 255, 8 * v13);
    goto LABEL_9;
  }
  free(v4);
  v19 = *(_DWORD *)(v2 + 292) - *(_DWORD *)(v2 + 296);
  v20 = 1 << (33 - __clz(v19 - 1));
  if (v19 <= 0x10)
    v21 = 32;
  else
    v21 = v20;
  *(_DWORD *)(v2 + 288) = v21;
  *(_QWORD *)(v2 + 292) = 0;
  v22 = malloc_type_malloc(8 * v21, 0x4065EBACuLL);
  if (!v22)
LABEL_41:
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  *(_QWORD *)(v2 + 280) = v22;
  memset(v22, 255, 8 * *(unsigned int *)(v2 + 288));
LABEL_10:
  if (!atomic_load(llvm::cl::TopLevelSubCommand))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)llvm::cl::TopLevelSubCommand, (void *(*)(void))sub_1C6386064, (void (*)(void *))sub_1C63860D8);
  v6 = llvm::cl::TopLevelSubCommand[0];
  *(_DWORD *)(llvm::cl::TopLevelSubCommand[0] + 40) = 0;
  *(_DWORD *)(v6 + 88) = 0;
  sub_1C62A23BC(v6 + 128);
  *(_QWORD *)(v6 + 160) = 0;
  if (!atomic_load((unint64_t *)&llvm::cl::AllSubCommands))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&llvm::cl::AllSubCommands, (void *(*)(void))sub_1C6386064, (void (*)(void *))sub_1C63860D8);
  v8 = llvm::cl::AllSubCommands;
  *(_DWORD *)(llvm::cl::AllSubCommands + 40) = 0;
  *(_DWORD *)(v8 + 88) = 0;
  sub_1C62A23BC(v8 + 128);
  *(_QWORD *)(v8 + 160) = 0;
  if (!atomic_load(llvm::cl::TopLevelSubCommand))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)llvm::cl::TopLevelSubCommand, (void *(*)(void))sub_1C6386064, (void (*)(void *))sub_1C63860D8);
  sub_1C5DDB1E0((uint64_t *)v2, llvm::cl::TopLevelSubCommand[0]);
  if (!atomic_load((unint64_t *)&llvm::cl::AllSubCommands))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&llvm::cl::AllSubCommands, (void *(*)(void))sub_1C6386064, (void (*)(void *))sub_1C63860D8);
  sub_1C5DDB1E0((uint64_t *)v2, llvm::cl::AllSubCommands);
  *(_DWORD *)(v2 + 72) = 0;
}

void sub_1C5DE3414(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *i;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t *j;
  uint64_t v11;
  uint64_t v12;
  llvm::cl::Option *v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  llvm::cl::Option **v17;
  uint64_t v18;
  llvm::cl::Option *v19;
  uint64_t v20;
  llvm::cl::Option **v21;
  uint64_t v22;
  llvm::cl::Option *v23;
  llvm::cl::Option *v24;
  unint64_t *v25;
  unint64_t v26;

  v1 = *(_QWORD *)(a1 + 280);
  v2 = 288;
  if (v1 == *(_QWORD *)(a1 + 272))
    v2 = 292;
  v3 = *(unsigned int *)(a1 + v2);
  if ((_DWORD)v3)
  {
    v4 = 8 * v3;
    for (i = *(unint64_t **)(a1 + 280); *i >= 0xFFFFFFFFFFFFFFFELL; ++i)
    {
      v4 -= 8;
      if (!v4)
        return;
    }
  }
  else
  {
    i = *(unint64_t **)(a1 + 280);
  }
  v6 = (unint64_t *)(v1 + 8 * v3);
  if (i != v6)
  {
    v7 = *i;
LABEL_11:
    v8 = *(unsigned int *)(v7 + 136);
    if ((_DWORD)v8)
    {
      for (j = *(uint64_t **)(v7 + 128); !*j || *j == -8; ++j)
        ;
    }
    else
    {
      j = *(uint64_t **)(v7 + 128);
    }
    v11 = *(_QWORD *)(v7 + 128) + 8 * v8;
    if (j != (uint64_t *)v11)
    {
      v12 = *j;
      do
      {
        v13 = *(llvm::cl::Option **)(v12 + 8);
        *((_WORD *)v13 + 4) = 0;
        (*(void (**)(llvm::cl::Option *))(*(_QWORD *)v13 + 64))(v13);
        if ((*((_WORD *)v13 + 5) & 0x2000) != 0)
          llvm::cl::Option::removeArgument(v13);
        do
        {
          v14 = j[1];
          ++j;
          v12 = v14;
          if (v14)
            v15 = v12 == -8;
          else
            v15 = 1;
        }
        while (v15);
      }
      while (j != (uint64_t *)v11);
    }
    v16 = *(unsigned int *)(v7 + 40);
    if ((_DWORD)v16)
    {
      v17 = *(llvm::cl::Option ***)(v7 + 32);
      v18 = 8 * v16;
      do
      {
        v19 = *v17;
        *((_WORD *)v19 + 4) = 0;
        (*(void (**)(llvm::cl::Option *))(*(_QWORD *)v19 + 64))(v19);
        if ((*((_WORD *)v19 + 5) & 0x2000) != 0)
          llvm::cl::Option::removeArgument(v19);
        ++v17;
        v18 -= 8;
      }
      while (v18);
    }
    v20 = *(unsigned int *)(v7 + 88);
    if ((_DWORD)v20)
    {
      v21 = *(llvm::cl::Option ***)(v7 + 80);
      v22 = 8 * v20;
      do
      {
        v23 = *v21;
        *((_WORD *)v23 + 4) = 0;
        (*(void (**)(llvm::cl::Option *))(*(_QWORD *)v23 + 64))(v23);
        if ((*((_WORD *)v23 + 5) & 0x2000) != 0)
          llvm::cl::Option::removeArgument(v23);
        ++v21;
        v22 -= 8;
      }
      while (v22);
    }
    v24 = *(llvm::cl::Option **)(v7 + 160);
    if (v24)
    {
      *((_WORD *)v24 + 4) = 0;
      (*(void (**)(llvm::cl::Option *))(*(_QWORD *)v24 + 64))(v24);
      if ((*((_WORD *)v24 + 5) & 0x2000) != 0)
        llvm::cl::Option::removeArgument(v24);
    }
    v25 = i + 1;
    while (v25 != v6)
    {
      v26 = *v25++;
      v7 = v26;
      if (v26 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        i = v25 - 1;
        goto LABEL_11;
      }
    }
  }
}

BOOL LLVMParseCommandLineOptions(llvm *a1, _QWORD *a2, char *__s)
{
  llvm *v5;
  uint64_t v6;
  uint64_t *v7;

  v5 = a1;
  if (__s)
  {
    a1 = (llvm *)strlen(__s);
    v6 = (uint64_t)a1;
  }
  else
  {
    v6 = 0;
  }
  v7 = llvm::nulls(a1);
  return llvm::cl::ParseCommandLineOptions(v5, a2, (uint64_t)__s, v6, (llvm::raw_ostream *)v7, 0, 0);
}

void sub_1C5DE366C()
{
  JUMPOUT(0x1CAA32FC0);
}

const char *sub_1C5DE3680()
{
  return "value";
}

void sub_1C5DE3694()
{
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5DE36AC()
{
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5DE36C4()
{
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5DE36DC()
{
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5DE36F4()
{
  JUMPOUT(0x1CAA32FC0);
}

const char *sub_1C5DE3708()
{
  return "long";
}

void sub_1C5DE371C()
{
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5DE3734()
{
  JUMPOUT(0x1CAA32FC0);
}

const char *sub_1C5DE3748()
{
  return "long";
}

void sub_1C5DE375C()
{
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5DE3774()
{
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5DE378C()
{
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5DE37A4()
{
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5DE37BC()
{
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5DE37D4()
{
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5DE37EC()
{
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5DE3804()
{
  JUMPOUT(0x1CAA32FC0);
}

const char *sub_1C5DE3818()
{
  return "char";
}

_QWORD *sub_1C5DE3828(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = &unk_1E819E4E8;
  v2 = a1 + 20;
  v3 = (_QWORD *)a1[23];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return sub_1C47A80D0(a1);
}

void sub_1C5DE3888(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = &unk_1E819E4E8;
  v2 = a1 + 20;
  v3 = (_QWORD *)a1[23];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
    {
LABEL_6:
      sub_1C47A80D0(a1);
      JUMPOUT(0x1CAA32FC0);
    }
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
  goto LABEL_6;
}

void sub_1C5DE38FC(uint64_t *a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4, size_t a5)
{
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t *i;
  unint64_t *v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  llvm::raw_ostream *v21;
  llvm::raw_ostream *v22;
  llvm::raw_ostream *v23;
  llvm::raw_ostream *v24;
  uint64_t v25;

  if (!*(_QWORD *)(a2 + 24))
  {
    v25 = a2;
    v10 = sub_1C5DE3A80((llvm::StringMapImpl *)(a3 + 128), a4, a5, &v25);
    if ((v10 & 1) == 0)
    {
      v21 = (llvm::raw_ostream *)llvm::errs((llvm *)v10);
      v22 = sub_1C620429C(v21, a1);
      v23 = sub_1C4816AD8(v22, ": CommandLine Error: Option '");
      v24 = sub_1C6245B98(v23, a4, a5);
      sub_1C4816AD8(v24, "' registered more than once!\n");
      llvm::report_fatal_error((llvm *)"inconsistency in registered CommandLine options", (const char *)1);
    }
    if (!atomic_load((unint64_t *)&llvm::cl::AllSubCommands))
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&llvm::cl::AllSubCommands, (void *(*)(void))sub_1C6386064, (void (*)(void *))sub_1C63860D8);
    if (llvm::cl::AllSubCommands == a3)
    {
      v12 = a1[35];
      v13 = 288;
      if (v12 == a1[34])
        v13 = 292;
      v14 = *(unsigned int *)((char *)a1 + v13);
      if ((_DWORD)v14)
      {
        v15 = 8 * v14;
        for (i = (unint64_t *)a1[35]; *i >= 0xFFFFFFFFFFFFFFFELL; ++i)
        {
          v15 -= 8;
          if (!v15)
            return;
        }
      }
      else
      {
        i = (unint64_t *)a1[35];
      }
      v17 = (unint64_t *)(v12 + 8 * v14);
      if (i != v17)
      {
        v18 = *i;
LABEL_17:
        if (v18 != a3)
          sub_1C5DE38FC(a1, a2, v18, a4, a5);
        v19 = i + 1;
        while (v19 != v17)
        {
          v20 = *v19++;
          v18 = v20;
          if (v20 <= 0xFFFFFFFFFFFFFFFDLL)
          {
            i = v19 - 1;
            goto LABEL_17;
          }
        }
      }
    }
  }
}

uint64_t sub_1C5DE3A80(llvm::StringMapImpl *a1, unsigned __int8 *a2, size_t __n, uint64_t *a4)
{
  unsigned int v7;
  int v8;
  size_t v9;
  unsigned __int8 *v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  char *v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t result;
  _QWORD *v28;
  uint64_t *v29;

  v7 = *((_DWORD *)a1 + 2);
  if (!v7)
  {
    *((_DWORD *)a1 + 3) = 0;
    *((_DWORD *)a1 + 4) = 0;
    v28 = malloc_type_calloc(0x11uLL, 0xCuLL, 0x6D9A4F0CuLL);
    if (!v28)
      llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    v28[16] = 2;
    *(_QWORD *)a1 = v28;
    v7 = 16;
    *((_DWORD *)a1 + 2) = 16;
  }
  v29 = a4;
  v8 = 0;
  if (__n)
  {
    v9 = __n;
    v10 = a2;
    do
    {
      v11 = *v10++;
      v8 = 33 * v8 + v11;
      --v9;
    }
    while (v9);
  }
  v12 = *(_QWORD *)a1;
  v13 = v7 - 1;
  v14 = *(_QWORD *)a1 + 8 * v7 + 8;
  v15 = -1;
  v16 = 1;
  v17 = v8;
  while (1)
  {
    v18 = v17 & v13;
    v19 = *(_QWORD **)(v12 + 8 * v18);
    if (!v19)
      break;
    if (v19 == (_QWORD *)-8)
    {
      if (v15 == -1)
        v15 = v17 & v13;
    }
    else if (*(_DWORD *)(v14 + 4 * v18) == v8
           && __n == *v19
           && (!__n || !memcmp(a2, (char *)v19 + *((unsigned int *)a1 + 5), __n)))
    {
      goto LABEL_17;
    }
    v17 = v16 + v18;
    ++v16;
  }
  v20 = v15;
  if (v15 == -1)
  {
    v20 = v18;
    v18 = v18;
  }
  else
  {
    v18 = v15;
  }
  *(_DWORD *)(v14 + 4 * v20) = v8;
  v19 = *(_QWORD **)(v12 + 8 * v18);
LABEL_17:
  if (v19)
  {
    if (v19 != (_QWORD *)-8)
      return 0;
    --*((_DWORD *)a1 + 4);
  }
  v21 = operator new(__n + 17, (std::align_val_t)8uLL);
  v22 = v21;
  v23 = (char *)(v21 + 2);
  if (__n)
    memcpy(v21 + 2, a2, __n);
  v23[__n] = 0;
  v24 = *v29;
  *v22 = __n;
  v22[1] = v24;
  *(_QWORD *)(v12 + 8 * v18) = v22;
  ++*((_DWORD *)a1 + 3);
  v25 = (_QWORD *)(*(_QWORD *)a1 + 8 * llvm::StringMapImpl::RehashTable(a1, v18));
  result = 1;
  while (!*v25 || *v25 == -8)
    ++v25;
  return result;
}

void sub_1C5DE3C90(uint64_t a1, uint64_t a2, uint64_t a3)
{
  size_t v5;
  llvm::raw_ostream *v6;
  llvm::raw_ostream *v7;
  char v8;
  BOOL v9;
  const char *v10;
  size_t v11;
  size_t v12;
  llvm::raw_ostream *v13;
  void *v14;
  const void *v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  unsigned __int8 *v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  _QWORD *v24;
  __int16 v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t *i;
  unint64_t *v34;
  unint64_t v35;
  unint64_t *v36;
  unint64_t v37;
  llvm::raw_ostream *v38;
  uint64_t v39;
  uint64_t v40;
  const char *v41;
  __int16 v42;
  __int128 v43;
  uint64_t v44;

  v40 = a1;
  v5 = *(_QWORD *)(a2 + 24);
  if (!v5)
    goto LABEL_30;
  if ((*(_WORD *)(a2 + 10) & 0x2000) == 0)
    goto LABEL_3;
  v39 = *(unsigned int *)(a3 + 136);
  if (!(_DWORD)v39)
    goto LABEL_3;
  v17 = 0;
  v18 = 0;
  v19 = *(unsigned __int8 **)(a2 + 16);
  do
    v18 = 33 * v18 + v19[v17++];
  while (v5 != v17);
  v20 = *(_QWORD *)(a3 + 128);
  v21 = 1;
  v22 = v18;
  while (1)
  {
    v23 = v22 & (v39 - 1);
    v24 = *(_QWORD **)(v20 + 8 * v23);
    if (v24 != (_QWORD *)-8)
    {
      if (!v24)
        goto LABEL_3;
      if (*(_DWORD *)(v20 + 8 * v39 + 8 + 4 * v23) == v18
        && v5 == *v24
        && !memcmp(v19, (char *)v24 + *(unsigned int *)(a3 + 148), v5))
      {
        break;
      }
    }
    v22 = v21 + v23;
    ++v21;
  }
  if ((_DWORD)v23 == -1 || (int)v23 == v39)
  {
LABEL_3:
    v43 = *(_OWORD *)(a2 + 16);
    v44 = a2;
    a1 = sub_1C5DE3A80((llvm::StringMapImpl *)(a3 + 128), (unsigned __int8 *)v43, *((size_t *)&v43 + 1), &v44);
    if ((a1 & 1) != 0)
    {
      LODWORD(v5) = 0;
    }
    else
    {
      v6 = (llvm::raw_ostream *)llvm::errs((llvm *)a1);
      v7 = v6;
      v8 = *(_BYTE *)(v40 + 23);
      v9 = v8 < 0;
      if (v8 >= 0)
        v10 = (const char *)v40;
      else
        v10 = *(const char **)v40;
      v11 = v8 & 0x7F;
      if (v9)
        v12 = *(_QWORD *)(v40 + 8);
      else
        v12 = v11;
      v13 = llvm::raw_ostream::write(v6, v10, v12);
      v14 = (void *)*((_QWORD *)v13 + 4);
      if (*((_QWORD *)v13 + 3) - (_QWORD)v14 > 0x1CuLL)
      {
        qmemcpy(v14, ": CommandLine Error: Option '", 29);
        a1 = *((_QWORD *)v7 + 4) + 29;
        *((_QWORD *)v7 + 4) = a1;
      }
      else
      {
        llvm::raw_ostream::write(v7, ": CommandLine Error: Option '", 0x1DuLL);
        a1 = *((_QWORD *)v7 + 4);
      }
      v15 = *(const void **)(a2 + 16);
      v16 = *(_QWORD *)(a2 + 24);
      if (v16 <= *((_QWORD *)v7 + 3) - a1)
      {
        if (v16)
        {
          memcpy((void *)a1, v15, *(_QWORD *)(a2 + 24));
          a1 = *((_QWORD *)v7 + 4) + v16;
          *((_QWORD *)v7 + 4) = a1;
        }
      }
      else
      {
        llvm::raw_ostream::write(v7, (const char *)v15, *(_QWORD *)(a2 + 24));
        a1 = *((_QWORD *)v7 + 4);
      }
      if ((unint64_t)(*((_QWORD *)v7 + 3) - a1) > 0x1C)
      {
        qmemcpy((void *)a1, "' registered more than once!\n", 29);
        *((_QWORD *)v7 + 4) += 29;
      }
      else
      {
        a1 = (uint64_t)llvm::raw_ostream::write(v7, "' registered more than once!\n", 0x1DuLL);
      }
      LODWORD(v5) = 1;
    }
LABEL_30:
    v25 = *(_WORD *)(a2 + 10);
    if ((v25 & 0x180) == 0x80)
    {
      v26 = *(unsigned int *)(a3 + 40);
      if (v26 >= *(_DWORD *)(a3 + 44))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a3 + 32, a3 + 48, v26 + 1, 8);
        LODWORD(v26) = *(_DWORD *)(a3 + 40);
      }
      *(_QWORD *)(*(_QWORD *)(a3 + 32) + 8 * v26) = a2;
      ++*(_DWORD *)(a3 + 40);
      if ((v5 & 1) != 0)
        goto LABEL_69;
      goto LABEL_45;
    }
    if ((*(_WORD *)(a2 + 10) & 0x800) != 0)
    {
      v27 = *(unsigned int *)(a3 + 88);
      if (v27 >= *(_DWORD *)(a3 + 92))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a3 + 80, a3 + 96, v27 + 1, 8);
        LODWORD(v27) = *(_DWORD *)(a3 + 88);
      }
      *(_QWORD *)(*(_QWORD *)(a3 + 80) + 8 * v27) = a2;
      ++*(_DWORD *)(a3 + 88);
      if ((v5 & 1) != 0)
        goto LABEL_69;
    }
    else if ((v25 & 7) == 4)
    {
      if (*(_QWORD *)(a3 + 160))
      {
        v41 = "Cannot specify more than one option with cl::ConsumeAfter!";
        v42 = 259;
        v38 = (llvm::raw_ostream *)llvm::errs((llvm *)a1);
        llvm::cl::Option::error((_QWORD *)a2, (llvm::Twine *)&v41, 0, 0, v38);
        *(_QWORD *)(a3 + 160) = a2;
        goto LABEL_69;
      }
      *(_QWORD *)(a3 + 160) = a2;
      if ((v5 & 1) != 0)
LABEL_69:
        llvm::report_fatal_error((llvm *)"inconsistency in registered CommandLine options", (const char *)1);
    }
    else if ((_DWORD)v5)
    {
      goto LABEL_69;
    }
LABEL_45:
    if (!atomic_load((unint64_t *)&llvm::cl::AllSubCommands))
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&llvm::cl::AllSubCommands, (void *(*)(void))sub_1C6386064, (void (*)(void *))sub_1C63860D8);
    if (llvm::cl::AllSubCommands == a3)
    {
      v29 = *(_QWORD *)(v40 + 280);
      v30 = 288;
      if (v29 == *(_QWORD *)(v40 + 272))
        v30 = 292;
      v31 = *(unsigned int *)(v40 + v30);
      if ((_DWORD)v31)
      {
        v32 = 8 * v31;
        for (i = *(unint64_t **)(v40 + 280); *i >= 0xFFFFFFFFFFFFFFFELL; ++i)
        {
          v32 -= 8;
          if (!v32)
            return;
        }
      }
      else
      {
        i = *(unint64_t **)(v40 + 280);
      }
      v34 = (unint64_t *)(v29 + 8 * v31);
      if (i != v34)
      {
        v35 = *i;
LABEL_59:
        if (v35 != a3)
          sub_1C5DE3C90(v40, a2);
        v36 = i + 1;
        while (v36 != v34)
        {
          v37 = *v36++;
          v35 = v37;
          if (v37 <= 0xFFFFFFFFFFFFFFFDLL)
          {
            i = v36 - 1;
            goto LABEL_59;
          }
        }
      }
    }
  }
}

void sub_1C5DE40A8(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  const void **v8;
  uint64_t v9;
  size_t v10;
  const void *v11;
  int v12;
  char *v13;
  unsigned __int8 *v14;
  int v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  _QWORD *v20;
  int v21;
  uint64_t v22;
  size_t **v23;
  size_t *v24;
  size_t v25;
  int v26;
  size_t v27;
  unsigned __int8 *v28;
  int v29;
  unsigned int v30;
  uint64_t v31;
  int v32;
  int v33;
  uint64_t v34;
  _QWORD *v35;
  int v36;
  uint64_t v37;
  _QWORD *v38;
  size_t v39;
  _QWORD *v40;
  _QWORD *v41;
  uint64_t v42;
  _QWORD *v43;
  size_t v44;
  _QWORD *v45;
  _QWORD *v46;
  _QWORD *v47;
  const void **v48;
  uint64_t v49;
  uint64_t v50;
  void *v52;
  uint64_t v53;
  _QWORD v54[34];

  v54[32] = *MEMORY[0x1E0C80C00];
  v52 = v54;
  v53 = 0x1000000000;
  (*(void (**)(_QWORD *, void **))(*a1 + 72))(a1, &v52);
  v3 = a1[3];
  v4 = v53;
  v47 = a1;
  if (v3)
  {
    v5 = a1[2];
    v6 = a2;
    if (v53 >= HIDWORD(v53))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v52, (uint64_t)v54, v53 + 1, 16);
      v6 = a2;
      v4 = v53;
    }
    v7 = (char *)v52 + 16 * v4;
    *v7 = v5;
    v7[1] = v3;
    v4 = v53 + 1;
    LODWORD(v53) = v4;
    if (!v4)
      goto LABEL_44;
  }
  else
  {
    v6 = a2;
    if (!(_DWORD)v53)
      goto LABEL_44;
  }
  v8 = (const void **)v52;
  v48 = (const void **)((char *)v52 + 16 * v4);
  v49 = *(_QWORD *)(v6 + 128) + 8 * *(unsigned int *)(v6 + 136);
  do
  {
    v9 = *(unsigned int *)(v6 + 136);
    if ((_DWORD)v9)
    {
      v11 = *v8;
      v10 = (size_t)v8[1];
      v12 = 0;
      if (v10)
      {
        v13 = (char *)v8[1];
        v14 = (unsigned __int8 *)*v8;
        do
        {
          v15 = *v14++;
          v12 = 33 * v12 + v15;
          --v13;
        }
        while (v13);
      }
      v16 = *(_QWORD *)(v6 + 128);
      v17 = 1;
      v18 = v12;
      while (1)
      {
        v19 = v18 & (v9 - 1);
        v20 = *(_QWORD **)(v16 + 8 * v19);
        if (v20 != (_QWORD *)-8)
        {
          if (!v20)
          {
            v22 = v9;
            goto LABEL_21;
          }
          if (*(_DWORD *)(v16 + 8 * v9 + 8 + 4 * v19) == v12 && v10 == *v20)
          {
            if (!v10)
              break;
            v21 = memcmp(v11, (char *)v20 + *(unsigned int *)(v6 + 148), v10);
            v6 = a2;
            if (!v21)
              break;
          }
        }
        v18 = v17 + v19;
        ++v17;
      }
      v22 = (int)v19;
      if ((_DWORD)v19 == -1)
        v22 = v9;
    }
    else
    {
      v22 = 0;
      v16 = *(_QWORD *)(v6 + 128);
    }
LABEL_21:
    v23 = (size_t **)(v16 + 8 * v22);
    if (v23 != (size_t **)v49)
    {
      v24 = *v23;
      if ((_QWORD *)(*v23)[1] == v47)
      {
        if ((_DWORD)v9)
        {
          v50 = *(unsigned int *)(v6 + 148);
          v25 = *v24;
          if (*v24)
          {
            v26 = 0;
            v27 = *v24;
            v28 = (unsigned __int8 *)v24 + v50;
            do
            {
              v29 = *v28++;
              v26 = 33 * v26 + v29;
              --v27;
            }
            while (v27);
          }
          else
          {
            v26 = 0;
          }
          v30 = v9 - 1;
          v31 = v16 + 8 * v9 + 8;
          v32 = 1;
          v33 = v26;
          while (1)
          {
            v34 = v33 & v30;
            v35 = *(_QWORD **)(v16 + 8 * v34);
            if (v35 != (_QWORD *)-8)
            {
              if (!v35)
                goto LABEL_39;
              if (*(_DWORD *)(v31 + 4 * v34) == v26 && v25 == *v35)
              {
                if (!v25)
                  break;
                v36 = memcmp((char *)v24 + v50, (char *)v35 + v50, v25);
                v6 = a2;
                if (!v36)
                  break;
              }
            }
            v33 = v32 + v34;
            ++v32;
          }
          *(_QWORD *)(v16 + 8 * (int)v34) = -8;
          *(int32x2_t *)(v6 + 140) = vadd_s32(*(int32x2_t *)(v6 + 140), (int32x2_t)0x1FFFFFFFFLL);
        }
LABEL_39:
        MEMORY[0x1CAA32FB4](v24, 8);
        v6 = a2;
      }
    }
    v8 += 2;
  }
  while (v8 != v48);
LABEL_44:
  if ((*((_WORD *)v47 + 5) & 0x180) == 0x80)
  {
    v37 = *(unsigned int *)(v6 + 40);
    if ((_DWORD)v37)
    {
      v38 = *(_QWORD **)(v6 + 32);
      v39 = 8 * v37 - 8;
      v40 = v38;
      while (1)
      {
        v41 = (_QWORD *)*v40++;
        if (v41 == v47)
          break;
        v39 -= 8;
        v38 = v40;
        if (v39 == -8)
          goto LABEL_64;
      }
      if (v39)
      {
        memmove(v38, v38 + 1, v39);
        v6 = a2;
        LODWORD(v37) = *(_DWORD *)(a2 + 40);
      }
      *(_DWORD *)(v6 + 40) = v37 - 1;
    }
  }
  else if ((*((_WORD *)v47 + 5) & 0x800) != 0)
  {
    v42 = *(unsigned int *)(v6 + 88);
    if ((_DWORD)v42)
    {
      v43 = *(_QWORD **)(v6 + 80);
      v44 = 8 * v42 - 8;
      v45 = v43;
      while (1)
      {
        v46 = (_QWORD *)*v45++;
        if (v46 == v47)
          break;
        v44 -= 8;
        v43 = v45;
        if (v44 == -8)
          goto LABEL_64;
      }
      if (v44)
      {
        memmove(v43, v43 + 1, v44);
        v6 = a2;
        LODWORD(v42) = *(_DWORD *)(a2 + 88);
      }
      *(_DWORD *)(v6 + 88) = v42 - 1;
    }
  }
  else if (*(_QWORD **)(v6 + 160) == v47)
  {
    *(_QWORD *)(v6 + 160) = 0;
  }
LABEL_64:
  if (v52 != v54)
    free(v52);
}

uint64_t sub_1C5DE4490(uint64_t *a1, uint64_t a2, unsigned __int8 *a3, size_t __n, uint64_t a5)
{
  uint64_t result;
  uint64_t v9;
  size_t v10;
  unsigned __int8 *v11;
  uint64_t v12;
  int v13;
  size_t v14;
  unsigned __int8 *v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  size_t *v26;
  unsigned __int8 *v27;
  size_t v28;
  int v29;
  size_t v30;
  unsigned __int8 *v31;
  int v32;
  int v33;
  int v34;
  uint64_t v35;
  _QWORD *v36;
  uint64_t v37;
  int v38;
  llvm::raw_ostream *v39;
  llvm::raw_ostream *v40;
  llvm::raw_ostream *v41;
  llvm::raw_ostream *v42;
  uint64_t v43;
  uint64_t v44;

  v44 = a2;
  result = sub_1C5DE3A80((llvm::StringMapImpl *)(a5 + 128), a3, __n, &v44);
  if ((result & 1) == 0)
  {
    v39 = (llvm::raw_ostream *)llvm::errs((llvm *)result);
    v40 = sub_1C620429C(v39, a1);
    v41 = sub_1C4816AD8(v40, ": CommandLine Error: Option '");
    v42 = sub_1C6245B98(v41, *(const void **)(a2 + 16), *(_QWORD *)(a2 + 24));
    sub_1C4816AD8(v42, "' registered more than once!\n");
    llvm::report_fatal_error((llvm *)"inconsistency in registered CommandLine options", (const char *)1);
  }
  v43 = *(unsigned int *)(a5 + 136);
  if ((_DWORD)v43)
  {
    v9 = a5;
    v12 = a2 + 16;
    v11 = *(unsigned __int8 **)(a2 + 16);
    v10 = *(_QWORD *)(v12 + 8);
    v13 = 0;
    if (v10)
    {
      v14 = v10;
      v15 = v11;
      do
      {
        v16 = *v15++;
        v13 = 33 * v13 + v16;
        --v14;
      }
      while (v14);
    }
    v17 = v43 - 1;
    v18 = *(_QWORD *)(a5 + 128);
    v19 = v18 + 8 * v43 + 8;
    v20 = 1;
    v21 = v13;
    while (1)
    {
      v22 = v21 & v17;
      v23 = *(_QWORD **)(v18 + 8 * v22);
      if (v23 != (_QWORD *)-8)
      {
        if (!v23)
          return result;
        if (*(_DWORD *)(v19 + 4 * v22) == v13 && v10 == *v23)
        {
          v24 = *(unsigned int *)(v9 + 148);
          if (!v10)
            break;
          v25 = v9;
          result = memcmp(v11, (char *)v23 + v24, v10);
          v9 = v25;
          if (!(_DWORD)result)
            break;
        }
      }
      v21 = v20 + v22;
      ++v20;
    }
    if ((_DWORD)v22 != -1 && (int)v22 != v43)
    {
      v26 = *(size_t **)(v18 + 8 * (int)v22);
      v27 = (unsigned __int8 *)v26 + v24;
      v28 = *v26;
      v29 = 0;
      if (*v26)
      {
        v30 = *v26;
        v31 = v27;
        do
        {
          v32 = *v31++;
          v29 = 33 * v29 + v32;
          --v30;
        }
        while (v30);
      }
      v33 = 1;
      v34 = v29;
      while (1)
      {
        v35 = v34 & v17;
        v36 = *(_QWORD **)(v18 + 8 * v35);
        if (v36 != (_QWORD *)-8)
        {
          if (!v36)
            goto LABEL_31;
          if (*(_DWORD *)(v19 + 4 * v35) == v29 && v28 == *v36)
          {
            if (!v28)
              break;
            v37 = v9;
            v38 = memcmp(v27, (char *)v36 + v24, v28);
            v9 = v37;
            if (!v38)
              break;
          }
        }
        v34 = v33 + v35;
        ++v33;
      }
      *(_QWORD *)(v18 + 8 * (int)v35) = -8;
      *(int32x2_t *)(v9 + 140) = vadd_s32(*(int32x2_t *)(v9 + 140), (int32x2_t)0x1FFFFFFFFLL);
LABEL_31:
      JUMPOUT(0x1CAA32FB4);
    }
  }
  return result;
}

uint64_t sub_1C5DE46E0(_WORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, _BYTE *__s, size_t __n, uint64_t a7)
{
  size_t v8;
  _BYTE *v9;
  _BYTE *v14;
  unint64_t v15;
  unint64_t v16;
  size_t v17;
  _BYTE *v18;

  v8 = __n;
  v9 = __s;
  if ((a1[5] & 0x200) == 0)
    return (*(uint64_t (**)(_WORD *, uint64_t, uint64_t, uint64_t, _BYTE *, size_t, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, a3, a4, v9, v8, a7);
  if (!__n)
    return (*(uint64_t (**)(_WORD *, uint64_t, uint64_t, uint64_t, _BYTE *, size_t, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, a3, a4, v9, v8, a7);
  v14 = memchr(__s, 44, __n);
  if (!v14)
    return (*(uint64_t (**)(_WORD *, uint64_t, uint64_t, uint64_t, _BYTE *, size_t, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, a3, a4, v9, v8, a7);
  v15 = v14 - v9;
  if (v14 - v9 == -1)
    return (*(uint64_t (**)(_WORD *, uint64_t, uint64_t, uint64_t, _BYTE *, size_t, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, a3, a4, v9, v8, a7);
  while (1)
  {
    v16 = v8 >= v15 ? v15 : v8;
    if (((*(uint64_t (**)(_WORD *, uint64_t, uint64_t, uint64_t, _BYTE *, unint64_t, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, a3, a4, v9, v16, a7) & 1) != 0)break;
    if (v8 >= v15 + 1)
      v17 = v15 + 1;
    else
      v17 = v8;
    v9 += v17;
    v8 -= v17;
    if (v8)
    {
      v18 = memchr(v9, 44, v8);
      v15 = v18 - v9;
      if (v18 && v15 != -1)
        continue;
    }
    return (*(uint64_t (**)(_WORD *, uint64_t, uint64_t, uint64_t, _BYTE *, size_t, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, a3, a4, v9, v8, a7);
  }
  return 1;
}

uint64_t sub_1C5DE4800(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  size_t v14;
  uint64_t v15;
  unint64_t v16;

  v6 = 0;
  v7 = a2 - 1;
  v8 = a2 - a3;
  do
  {
    if (!(a3 - a2 + 1 + v6))
      goto LABEL_11;
    v9 = *(unsigned __int8 *)(a3 + a1 + 1 + v6++);
  }
  while (v9 == 92);
  if (v9 != 34)
  {
    v7 = a3 + v6 - 1;
    v8 = v6;
LABEL_11:
    v14 = v8;
    v12 = a4 + 1;
    v15 = a4[1];
    v16 = v15 + v8;
    if (v16 > a4[2])
    {
      llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a4, a4 + 3, v16, 1);
      v15 = a4[1];
    }
    memset((void *)(*a4 + v15), 92, v14);
    goto LABEL_18;
  }
  v10 = v6 >> 1;
  v11 = a4[1];
  v12 = a4 + 1;
  if ((unint64_t)(v11 + v10) > a4[2])
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a4, a4 + 3, v11 + v10, 1);
    v11 = a4[1];
  }
  v7 = a3 + v6;
  if ((_DWORD)v6 == 1)
  {
    v13 = v11 + v10;
    *v12 = v13;
  }
  else
  {
    memset((void *)(*a4 + v11), 92, v6 >> 1);
    v13 = a4[1] + v10;
    a4[1] = v13;
    if ((v6 & 1) == 0)
      return --v7;
  }
  if ((unint64_t)(v13 + 1) > a4[2])
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a4, a4 + 3, v13 + 1, 1);
    v13 = a4[1];
  }
  *(_BYTE *)(*a4 + v13) = 34;
  v14 = 1;
LABEL_18:
  *v12 += v14;
  return v7;
}

uint64_t sub_1C5DE4980(uint64_t a1, uint64_t a2, _QWORD *a3, int a4, char a5)
{
  size_t v5;
  unsigned __int8 *v10;
  _BYTE *v11;
  size_t v12;
  BOOL v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  uint64_t v21;
  _QWORD *v22;
  size_t v23;
  uint64_t v24;
  int v25;
  size_t v26;
  unsigned __int8 *v27;
  int v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  int i;
  uint64_t v35;
  _QWORD *v36;
  uint64_t result;
  uint64_t v38;
  size_t v39;
  unint64_t v40;
  BOOL v41;
  unint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  int v47;

  v5 = *(_QWORD *)(a2 + 8);
  if (!v5)
    return 0;
  v10 = *(unsigned __int8 **)a2;
  v11 = memchr(*(void **)a2, 61, v5);
  v12 = v11 - v10;
  if (v11)
    v13 = v12 == -1;
  else
    v13 = 1;
  v47 = a4;
  if (!v13)
  {
    if (v5 >= v12)
      v23 = v11 - v10;
    else
      v23 = v5;
    v24 = *(unsigned int *)(a1 + 136);
    if (!(_DWORD)v24)
      return 0;
    v43 = a3;
    v44 = a2;
    v42 = v11 - v10;
    v25 = 0;
    if (v23)
    {
      v26 = v23;
      v27 = v10;
      do
      {
        v28 = *v27++;
        v25 = 33 * v25 + v28;
        --v26;
      }
      while (v26);
    }
    v29 = v24 - 1;
    v30 = *(_QWORD *)(a1 + 128);
    v45 = *(unsigned int *)(a1 + 136);
    v31 = v30 + 8 * v24 + 8;
    v32 = *(unsigned int *)(a1 + 148);
    v33 = 1;
    for (i = v25; ; i = v35 + v33++)
    {
      v35 = i & v29;
      v36 = *(_QWORD **)(v30 + 8 * v35);
      if (v36 != (_QWORD *)-8)
      {
        if (!v36)
          return 0;
        if (*(_DWORD *)(v31 + 4 * v35) == v25 && v23 == *v36 && (!v23 || !memcmp(v10, (char *)v36 + v32, v23)))
          break;
      }
    }
    if ((_DWORD)v35 == -1)
      return 0;
    if ((int)v35 == v45)
      return 0;
    v38 = v30 + 8 * (int)v35;
    if ((~*(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)v38 + 8) + 10) & 0x180) == 0)
      return 0;
    if (v5 >= v42 + 1)
      v39 = v42 + 1;
    else
      v39 = v5;
    *v43 = &v10[v39];
    v43[1] = v5 - v39;
    v40 = *(_QWORD *)(v44 + 8);
    if (v40 >= v42)
      v40 = v42;
    *(_QWORD *)(v44 + 8) = v40;
    goto LABEL_44;
  }
  v14 = *(unsigned int *)(a1 + 136);
  if (!(_DWORD)v14)
    return 0;
  v15 = 0;
  v16 = 0;
  do
    v16 = 33 * v16 + v10[v15++];
  while (v5 != v15);
  v17 = *(_QWORD *)(a1 + 128);
  v18 = *(unsigned int *)(a1 + 148);
  v19 = 1;
  v20 = v16;
  while (1)
  {
    v21 = v20 & (v14 - 1);
    v22 = *(_QWORD **)(v17 + 8 * v21);
    if (v22 != (_QWORD *)-8)
    {
      if (!v22)
        return 0;
      if (*(_DWORD *)(v17 + 8 * v14 + 8 + 4 * v21) == v16 && v5 == *v22 && !memcmp(v10, (char *)v22 + v18, v5))
        break;
    }
    v20 = v19 + v21;
    ++v19;
  }
  result = 0;
  if ((_DWORD)v21 == -1 || (int)v21 == v14)
    return result;
  v38 = v17 + 8 * (int)v21;
LABEL_44:
  result = *(_QWORD *)(*(_QWORD *)v38 + 8);
  if (result)
    v41 = v47 == 0;
  else
    v41 = 1;
  if (!v41 && (a5 & 1) == 0 && (*(_WORD *)(result + 10) & 0x1000) == 0)
    return 0;
  return result;
}

_QWORD *sub_1C5DE4BF0()
{
  _QWORD *v0;
  uint64_t v2;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v14;
  llvm *v15;
  llvm::raw_ostream *v17;
  uint64_t v18;
  char v19;
  llvm::cl::OptionCategory *v20;
  char *v21;
  int v22;
  _OWORD v23[2];
  __int16 v24;

  v0 = (_QWORD *)operator new();
  bzero(v0, 0x660uLL);
  *v0 = off_1E819E5B8;
  v0[2] = off_1E819E5B8;
  *((_BYTE *)v0 + 24) = 1;
  v0[4] = off_1E819E5E0;
  *((_BYTE *)v0 + 56) = 1;
  v0[6] = off_1E819E5E0;
  v0[10] = v0 + 2;
  v0[8] = v0;
  v0[9] = v0 + 4;
  v0[12] = "Generic Options";
  v0[11] = v0 + 6;
  v0[13] = 15;
  v0[14] = &unk_1C876C4D5;
  llvm::cl::OptionCategory::registerCategory((llvm::cl::OptionCategory *)(v0 + 12));
  *(_QWORD *)&v23[0] = v0;
  LODWORD(v18) = 1;
  v22 = 3;
  v21 = (char *)(v0 + 12);
  if (!atomic_load((unint64_t *)&llvm::cl::AllSubCommands))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&llvm::cl::AllSubCommands, (void *(*)(void))sub_1C6386064, (void (*)(void *))sub_1C63860D8);
  v20 = (llvm::cl::OptionCategory *)llvm::cl::AllSubCommands;
  v2 = sub_1C47AD050((uint64_t)(v0 + 16), 0, 0);
  v0[32] = 0;
  v0[33] = &off_1E819E670;
  v0[16] = off_1E819E608;
  v0[34] = &off_1E819E9A0;
  v0[35] = &off_1E819E690;
  v0[38] = v0 + 35;
  llvm::cl::Option::setArgStr(v2, "help-list", 9uLL);
  sub_1C5DE5DA4((llvm::cl::Option *)(v0 + 16), (uint64_t)"Display list of available options (--help-list-hidden for more)", 63, v23, &v18, &v22, (llvm::cl::OptionCategory **)&v21, (uint64_t *)&v20);
  llvm::cl::Option::addArgument((llvm::cl::Option *)(v0 + 16));
  *(_QWORD *)&v23[0] = v0 + 2;
  LODWORD(v18) = 1;
  v22 = 3;
  v21 = (char *)(v0 + 12);
  if (!atomic_load((unint64_t *)&llvm::cl::AllSubCommands))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&llvm::cl::AllSubCommands, (void *(*)(void))sub_1C6386064, (void (*)(void *))sub_1C63860D8);
  v20 = (llvm::cl::OptionCategory *)llvm::cl::AllSubCommands;
  v4 = sub_1C47AD050((uint64_t)(v0 + 39), 0, 0);
  v0[55] = 0;
  v0[56] = &off_1E819E670;
  v0[39] = off_1E819E608;
  v0[57] = &off_1E819E9A0;
  v0[58] = &off_1E819E690;
  v0[61] = v0 + 58;
  llvm::cl::Option::setArgStr(v4, "help-list-hidden", 0x10uLL);
  sub_1C5DE5DA4((llvm::cl::Option *)(v0 + 39), (uint64_t)"Display list of all available options", 37, v23, &v18, &v22, (llvm::cl::OptionCategory **)&v21, (uint64_t *)&v20);
  llvm::cl::Option::addArgument((llvm::cl::Option *)(v0 + 39));
  if (!atomic_load((unint64_t *)&llvm::cl::AllSubCommands))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&llvm::cl::AllSubCommands, (void *(*)(void))sub_1C6386064, (void (*)(void *))sub_1C63860D8);
  v6 = llvm::cl::AllSubCommands;
  v7 = sub_1C47AD050((uint64_t)(v0 + 62), 0, 0);
  v0[78] = 0;
  v0[79] = &off_1E819E740;
  v0[62] = off_1E819E6D8;
  v0[80] = &off_1E819E9A0;
  v0[81] = &off_1E819E760;
  v0[84] = v0 + 81;
  llvm::cl::Option::setArgStr(v7, "help", 4uLL);
  v0[66] = "Display available options (--help-hidden for more)";
  v0[67] = 50;
  sub_1C5DE614C((llvm *)(v0 + 8), v0 + 62);
  *((_WORD *)v0 + 253) |= 0x18u;
  llvm::cl::Option::addCategory((llvm::cl::Option *)(v0 + 62), (llvm::cl::OptionCategory *)(v0 + 12));
  sub_1C4774094((llvm::SmallPtrSetImplBase *)(v0 + 73), v6);
  llvm::cl::Option::addArgument((llvm::cl::Option *)(v0 + 62));
  v8 = sub_1C47AD050((uint64_t)(v0 + 85), 0, 1);
  v0[85] = off_1E819E550;
  v0[101] = 0;
  llvm::cl::Option::setArgStr(v8, "h", 1uLL);
  v0[89] = "Alias for --help";
  v0[90] = 16;
  sub_1C62C1CFC(v0 + 85, (uint64_t)(v0 + 62));
  *((_WORD *)v0 + 345) |= 0x2000u;
  sub_1C62C1BEC((llvm *)(v0 + 85));
  if (!atomic_load((unint64_t *)&llvm::cl::AllSubCommands))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&llvm::cl::AllSubCommands, (void *(*)(void))sub_1C6386064, (void (*)(void *))sub_1C63860D8);
  v10 = llvm::cl::AllSubCommands;
  v11 = sub_1C47AD050((uint64_t)(v0 + 102), 0, 0);
  v0[118] = 0;
  v0[119] = &off_1E819E740;
  v0[102] = off_1E819E6D8;
  v0[120] = &off_1E819E9A0;
  v0[121] = &off_1E819E760;
  v0[124] = v0 + 121;
  llvm::cl::Option::setArgStr(v11, "help-hidden", 0xBuLL);
  v0[106] = "Display all available options";
  v0[107] = 29;
  sub_1C5DE614C((llvm *)(v0 + 10), v0 + 102);
  *((_WORD *)v0 + 413) = *((_WORD *)v0 + 413) & 0xFF87 | 0x38;
  llvm::cl::Option::addCategory((llvm::cl::Option *)(v0 + 102), (llvm::cl::OptionCategory *)(v0 + 12));
  sub_1C4774094((llvm::SmallPtrSetImplBase *)(v0 + 113), v10);
  llvm::cl::Option::addArgument((llvm::cl::Option *)(v0 + 102));
  *(_QWORD *)&v23[0] = "Print non-default options after command line parsing";
  *((_QWORD *)&v23[0] + 1) = 52;
  v22 = 1;
  v19 = 0;
  v20 = (llvm::cl::OptionCategory *)(v0 + 12);
  v21 = &v19;
  if (!atomic_load((unint64_t *)&llvm::cl::AllSubCommands))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&llvm::cl::AllSubCommands, (void *(*)(void))sub_1C6386064, (void (*)(void *))sub_1C63860D8);
  v18 = llvm::cl::AllSubCommands;
  sub_1C63862E0((llvm::cl::Option *)(v0 + 125), v23, &v22, &v21, &v20, &v18);
  *(_QWORD *)&v23[0] = "Print all option values after command line parsing";
  *((_QWORD *)&v23[0] + 1) = 50;
  v22 = 1;
  v19 = 0;
  v20 = (llvm::cl::OptionCategory *)(v0 + 12);
  v21 = &v19;
  if (!atomic_load((unint64_t *)&llvm::cl::AllSubCommands))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&llvm::cl::AllSubCommands, (void *(*)(void))sub_1C6386064, (void (*)(void *))sub_1C63860D8);
  v18 = llvm::cl::AllSubCommands;
  sub_1C6386438((llvm::cl::Option *)(v0 + 149), v23, &v22, &v21, &v20, &v18);
  *((_OWORD *)v0 + 89) = 0u;
  *((_OWORD *)v0 + 88) = 0u;
  v14 = sub_1C47AD050((uint64_t)(v0 + 181), 0, 0);
  v0[197] = 0;
  v0[198] = &off_1E819E810;
  v0[181] = off_1E819E7A8;
  v0[199] = &off_1E819E9A0;
  v0[200] = &off_1E819E830;
  v0[203] = v0 + 200;
  v15 = (llvm *)llvm::cl::Option::setArgStr(v14, "version", 7uLL);
  v0[185] = "Display the version of this program";
  v0[186] = 35;
  if (v0[197])
  {
    *(_QWORD *)&v23[0] = "cl::location(x) specified more than once!";
    v24 = 259;
    v17 = (llvm::raw_ostream *)llvm::errs(v15);
    llvm::cl::Option::error(v0 + 181, (llvm::Twine *)v23, 0, 0, v17);
  }
  else
  {
    v0[197] = v0 + 180;
  }
  *((_WORD *)v0 + 729) |= 0x18u;
  llvm::cl::Option::addCategory((llvm::cl::Option *)(v0 + 181), (llvm::cl::OptionCategory *)(v0 + 12));
  llvm::cl::Option::addArgument((llvm::cl::Option *)(v0 + 181));
  return v0;
}

_QWORD *sub_1C5DE5210(_QWORD *result)
{
  _QWORD *v1;
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;

  if (result)
  {
    v1 = result;
    v2 = result + 181;
    result[181] = off_1E819E7A8;
    v3 = result + 200;
    v4 = (_QWORD *)result[203];
    if (v4 == v3)
    {
      v5 = 4;
      v4 = v3;
    }
    else
    {
      if (!v4)
      {
LABEL_8:
        sub_1C47A80D0(v2);
        v6 = v1[177];
        if (!v6)
          goto LABEL_18;
        v7 = v1[178];
        v8 = (void *)v1[177];
        if (v7 == v6)
          goto LABEL_17;
        while (1)
        {
          v9 = v7 - 32;
          v10 = *(_QWORD **)(v7 - 8);
          if ((_QWORD *)(v7 - 32) == v10)
            break;
          if (v10)
          {
            v11 = 5;
LABEL_14:
            (*(void (**)(void))(*v10 + 8 * v11))();
          }
          v7 = v9;
          if (v9 == v6)
          {
            v8 = (void *)v1[177];
LABEL_17:
            v1[178] = v6;
            operator delete(v8);
LABEL_18:
            v12 = (_QWORD *)v1[176];
            if (v12 == v1 + 173)
            {
              v13 = 4;
              v12 = v1 + 173;
LABEL_22:
              (*(void (**)(void))(*v12 + 8 * v13))();
            }
            else if (v12)
            {
              v13 = 5;
              goto LABEL_22;
            }
            v1[149] = &unk_1E819E898;
            v14 = (_QWORD *)v1[172];
            if (v14 == v1 + 169)
            {
              v15 = 4;
              v14 = v1 + 169;
LABEL_27:
              (*(void (**)(void))(*v14 + 8 * v15))();
            }
            else if (v14)
            {
              v15 = 5;
              goto LABEL_27;
            }
            sub_1C47A80D0(v1 + 149);
            v1[125] = &unk_1E819E898;
            v16 = (_QWORD *)v1[148];
            if (v16 == v1 + 145)
            {
              v17 = 4;
              v16 = v1 + 145;
LABEL_32:
              (*(void (**)(void))(*v16 + 8 * v17))();
            }
            else if (v16)
            {
              v17 = 5;
              goto LABEL_32;
            }
            sub_1C47A80D0(v1 + 125);
            v1[102] = off_1E819E6D8;
            v18 = (_QWORD *)v1[124];
            if (v18 == v1 + 121)
            {
              v19 = 4;
              v18 = v1 + 121;
LABEL_37:
              (*(void (**)(void))(*v18 + 8 * v19))();
            }
            else if (v18)
            {
              v19 = 5;
              goto LABEL_37;
            }
            sub_1C47A80D0(v1 + 102);
            sub_1C47A80D0(v1 + 85);
            v1[62] = off_1E819E6D8;
            v20 = (_QWORD *)v1[84];
            if (v20 == v1 + 81)
            {
              v21 = 4;
              v20 = v1 + 81;
LABEL_42:
              (*(void (**)(void))(*v20 + 8 * v21))();
            }
            else if (v20)
            {
              v21 = 5;
              goto LABEL_42;
            }
            sub_1C47A80D0(v1 + 62);
            v1[39] = off_1E819E608;
            v22 = (_QWORD *)v1[61];
            if (v22 == v1 + 58)
            {
              v23 = 4;
              v22 = v1 + 58;
LABEL_47:
              (*(void (**)(void))(*v22 + 8 * v23))();
            }
            else if (v22)
            {
              v23 = 5;
              goto LABEL_47;
            }
            sub_1C47A80D0(v1 + 39);
            v1[16] = off_1E819E608;
            v24 = (_QWORD *)v1[38];
            if (v24 == v1 + 35)
            {
              v25 = 4;
              v24 = v1 + 35;
LABEL_52:
              (*(void (**)(void))(*v24 + 8 * v25))();
            }
            else if (v24)
            {
              v25 = 5;
              goto LABEL_52;
            }
            sub_1C47A80D0(v1 + 16);
            JUMPOUT(0x1CAA32FC0);
          }
        }
        v10 = (_QWORD *)(v7 - 32);
        v11 = 4;
        goto LABEL_14;
      }
      v5 = 5;
    }
    (*(void (**)(void))(*v4 + 8 * v5))();
    goto LABEL_8;
  }
  return result;
}

uint64_t sub_1C5DE54D0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;

  v3 = *(unsigned int *)(a2 + 8);
  if ((_DWORD)v3)
  {
    v6 = 0;
    v7 = 16 * v3;
    do
    {
      result = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(*(_QWORD *)a2 + v6 + 8) + 48))(*(_QWORD *)(*(_QWORD *)a2 + v6 + 8), a3);
      v6 += 16;
    }
    while (v7 != v6);
  }
  return result;
}

void sub_1C5DE5534()
{
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5DE5548(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t *v10;
  char *v11;
  char *v12;
  char *v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  char *v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t i;
  uint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t *v28;
  _QWORD *v29;
  _QWORD *v30;
  unint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  _QWORD *v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  char *v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t *j;
  uint64_t v44;
  llvm *v45;
  uint64_t v46;
  uint64_t v47;
  BOOL v48;
  llvm *v49;
  llvm::raw_ostream *v50;
  _BYTE *v51;
  llvm::raw_ostream *v52;
  const void *v53;
  unint64_t v54;
  llvm::raw_ostream *v55;
  uint64_t v56;
  uint64_t v57;
  llvm::raw_ostream *v58;
  llvm::raw_ostream *v59;
  _BYTE *v60;
  const char *v61;
  size_t v62;
  const void *v63;
  unint64_t v64;
  uint64_t *v65;
  uint64_t *v66;
  uint64_t v67;
  llvm::raw_ostream *v68;
  void *v69;
  uint64_t v70;
  uint64_t *__p;
  uint64_t v72;
  uint64_t *v74;
  uint64_t v76;
  uint64_t v77[2];
  unsigned int v78;

  v77[0] = 0;
  v77[1] = 0;
  v78 = 0;
  if (!atomic_load((unint64_t *)&qword_1ED836A48))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1ED836A48, (void *(*)(void))sub_1C5DE673C, (void (*)(void *))sub_1C5DE6840);
  v5 = *(_QWORD *)(qword_1ED836A48 + 120);
  v6 = 128;
  if (v5 == *(_QWORD *)(qword_1ED836A48 + 112))
    v6 = 132;
  v7 = *(unsigned int *)(qword_1ED836A48 + v6);
  v72 = a3;
  if ((_DWORD)v7)
  {
    v8 = 8 * v7;
    v9 = *(unint64_t **)(qword_1ED836A48 + 120);
    while (*v9 >= 0xFFFFFFFFFFFFFFFELL)
    {
      ++v9;
      v8 -= 8;
      if (!v8)
        goto LABEL_35;
    }
  }
  else
  {
    v9 = *(unint64_t **)(qword_1ED836A48 + 120);
  }
  v10 = (unint64_t *)(v5 + 8 * v7);
  if (v9 == v10)
  {
LABEL_35:
    v74 = 0;
    v11 = 0;
  }
  else
  {
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = *v9;
LABEL_13:
    if (v12 >= v13)
    {
      v15 = (v12 - v11) >> 3;
      v16 = v15 + 1;
      if ((unint64_t)(v15 + 1) >> 61)
LABEL_102:
        abort();
      if ((v13 - v11) >> 2 > v16)
        v16 = (v13 - v11) >> 2;
      if ((unint64_t)(v13 - v11) >= 0x7FFFFFFFFFFFFFF8)
        v17 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v17 = v16;
      if (v17)
      {
        if (v17 >> 61)
LABEL_103:
          sub_1C4764EE4();
        v18 = (char *)operator new(8 * v17);
      }
      else
      {
        v18 = 0;
      }
      v19 = (unint64_t *)&v18[8 * v15];
      *v19 = v14;
      v74 = (uint64_t *)(v19 + 1);
      while (v12 != v11)
      {
        v20 = *((_QWORD *)v12 - 1);
        v12 -= 8;
        *--v19 = v20;
      }
      v13 = &v18[8 * v17];
      if (v11)
        operator delete(v11);
      v11 = (char *)v19;
    }
    else
    {
      *(_QWORD *)v12 = v14;
      v74 = (uint64_t *)(v12 + 8);
    }
    v21 = v9 + 1;
    while (v21 != v10)
    {
      v22 = *v21++;
      v14 = v22;
      if (v22 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        v9 = v21 - 1;
        v12 = (char *)v74;
        goto LABEL_13;
      }
    }
  }
  if ((char *)v74 - v11 >= 16)
    qsort(v11, (unint64_t)((char *)v74 - v11) >> 3, 8uLL, (int (__cdecl *)(const void *, const void *))sub_1C5DE5AF4);
  __p = (uint64_t *)v11;
  v23 = *(unsigned int *)(a2 + 8);
  if ((_DWORD)v23)
  {
    for (i = 0; i != v23; ++i)
    {
      v25 = *(_QWORD *)(*(_QWORD *)a2 + 16 * i + 8);
      v26 = *(unsigned int *)(v25 + 72);
      if ((_DWORD)v26)
      {
        v27 = *(uint64_t **)(v25 + 64);
        v28 = &v27[v26];
        do
        {
          v29 = sub_1C61D0AA8((uint64_t)v77, v27);
          v30 = v29;
          v32 = (_QWORD *)v29[2];
          v31 = v29[3];
          if ((unint64_t)v32 >= v31)
          {
            v34 = (_QWORD *)v29[1];
            v35 = v32 - v34;
            v36 = v35 + 1;
            if ((unint64_t)(v35 + 1) >> 61)
              goto LABEL_102;
            v37 = v31 - (_QWORD)v34;
            if (v37 >> 2 > v36)
              v36 = v37 >> 2;
            if ((unint64_t)v37 >= 0x7FFFFFFFFFFFFFF8)
              v38 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v38 = v36;
            if (v38)
            {
              if (v38 >> 61)
                goto LABEL_103;
              v39 = (char *)operator new(8 * v38);
            }
            else
            {
              v39 = 0;
            }
            v40 = &v39[8 * v35];
            *(_QWORD *)v40 = v25;
            v33 = v40 + 8;
            if (v32 != v34)
            {
              do
              {
                v41 = *--v32;
                *((_QWORD *)v40 - 1) = v41;
                v40 -= 8;
              }
              while (v32 != v34);
              v32 = (_QWORD *)v30[1];
            }
            v30[1] = v40;
            v30[2] = v33;
            v30[3] = &v39[8 * v38];
            if (v32)
              operator delete(v32);
          }
          else
          {
            *v32 = v25;
            v33 = v32 + 1;
          }
          v30[2] = v33;
          ++v27;
        }
        while (v27 != v28);
      }
    }
  }
  if (__p != v74)
  {
    for (j = __p; j != v74; ++j)
    {
      v76 = 0;
      v44 = *j;
      v76 = *j;
      v45 = (llvm *)sub_1C61D0AA8((uint64_t)v77, &v76);
      v47 = *((_QWORD *)v45 + 1);
      v46 = *((_QWORD *)v45 + 2);
      if (*(_BYTE *)(a1 + 8))
        v48 = 0;
      else
        v48 = v47 == v46;
      if (v48)
        continue;
      v49 = v45;
      v50 = (llvm::raw_ostream *)llvm::outs(v45);
      v51 = (_BYTE *)*((_QWORD *)v50 + 4);
      if (*((_BYTE **)v50 + 3) == v51)
      {
        v50 = llvm::raw_ostream::write(v50, "\n", 1uLL);
      }
      else
      {
        *v51 = 10;
        ++*((_QWORD *)v50 + 4);
      }
      v52 = (llvm::raw_ostream *)llvm::outs(v50);
      v53 = *(const void **)v44;
      v54 = *(_QWORD *)(v44 + 8);
      v55 = (llvm::raw_ostream *)*((_QWORD *)v52 + 4);
      if (v54 <= *((_QWORD *)v52 + 3) - (_QWORD)v55)
      {
        if (v54)
        {
          memcpy(v55, v53, *(_QWORD *)(v44 + 8));
          v55 = (llvm::raw_ostream *)(*((_QWORD *)v52 + 4) + v54);
          *((_QWORD *)v52 + 4) = v55;
        }
      }
      else
      {
        llvm::raw_ostream::write(v52, (const char *)v53, *(_QWORD *)(v44 + 8));
        v55 = (llvm::raw_ostream *)*((_QWORD *)v52 + 4);
      }
      v56 = v72;
      if (*((_QWORD *)v52 + 3) - (_QWORD)v55 > 1uLL)
      {
        *(_WORD *)v55 = 2618;
        *((_QWORD *)v52 + 4) += 2;
      }
      else
      {
        v55 = llvm::raw_ostream::write(v52, ":\n", 2uLL);
      }
      v57 = *(_QWORD *)(v44 + 24);
      v58 = (llvm::raw_ostream *)llvm::outs(v55);
      v59 = v58;
      if (v57)
      {
        v63 = *(const void **)(v44 + 16);
        v64 = *(_QWORD *)(v44 + 24);
        v58 = (llvm::raw_ostream *)*((_QWORD *)v58 + 4);
        if (v64 <= *((_QWORD *)v59 + 3) - (_QWORD)v58)
        {
          if (v64)
          {
            memcpy(v58, v63, *(_QWORD *)(v44 + 24));
            v58 = (llvm::raw_ostream *)(*((_QWORD *)v59 + 4) + v64);
            *((_QWORD *)v59 + 4) = v58;
          }
        }
        else
        {
          llvm::raw_ostream::write(v59, (const char *)v63, *(_QWORD *)(v44 + 24));
          v58 = (llvm::raw_ostream *)*((_QWORD *)v59 + 4);
        }
        v56 = v72;
        if (*((_QWORD *)v59 + 3) - (_QWORD)v58 <= 1uLL)
        {
          v58 = v59;
          v61 = "\n\n";
          v62 = 2;
          goto LABEL_86;
        }
        *(_WORD *)v58 = 2570;
        v70 = *((_QWORD *)v59 + 4) + 2;
      }
      else
      {
        v60 = (_BYTE *)*((_QWORD *)v58 + 4);
        if (*((_BYTE **)v58 + 3) == v60)
        {
          v61 = "\n";
          v62 = 1;
LABEL_86:
          v58 = llvm::raw_ostream::write(v58, v61, v62);
          goto LABEL_87;
        }
        *v60 = 10;
        v70 = *((_QWORD *)v58 + 4) + 1;
      }
      *((_QWORD *)v59 + 4) = v70;
LABEL_87:
      if (v47 == v46)
      {
        v68 = (llvm::raw_ostream *)llvm::outs(v58);
        v69 = (void *)*((_QWORD *)v68 + 4);
        if (*((_QWORD *)v68 + 3) - (_QWORD)v69 > 0x26uLL)
        {
          qmemcpy(v69, "  This option category has no options.\n", 39);
          *((_QWORD *)v68 + 4) += 39;
        }
        else
        {
          llvm::raw_ostream::write(v68, "  This option category has no options.\n", 0x27uLL);
        }
      }
      else
      {
        v65 = (uint64_t *)*((_QWORD *)v49 + 1);
        v66 = (uint64_t *)*((_QWORD *)v49 + 2);
        while (v65 != v66)
        {
          v67 = *v65++;
          (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v67 + 48))(v67, v56);
        }
      }
    }
  }
  v42 = v77[0];
  sub_1C62B4210(v77[0], v78);
  MEMORY[0x1CAA32FB4](v42, 8);
  if (__p)
    operator delete(__p);
}

void sub_1C5DE5AE0()
{
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C5DE5AF4(const void ***a1, const void ***a2)
{
  const void *v2;
  const void *v3;
  size_t v4;
  int v5;
  unsigned int v7;

  v2 = (*a1)[1];
  v3 = (*a2)[1];
  if (v3 >= v2)
    v4 = (size_t)(*a1)[1];
  else
    v4 = (size_t)(*a2)[1];
  if (v4)
  {
    v5 = memcmp(**a1, **a2, v4);
    if (v5)
      return (v5 >> 31) | 1u;
  }
  if (v2 < v3)
    v7 = -1;
  else
    v7 = 1;
  if (v2 == v3)
    return 0;
  else
    return v7;
}

uint64_t sub_1C5DE5B54(uint64_t a1, __int16 a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char v14;

  v14 = 0;
  v11 = llvm::cl::parser<BOOL>::parse(a1, (_QWORD *)a1, a3, a4, a5, a6, &v14);
  if ((v11 & 1) != 0)
    return v11;
  if (v14)
  {
    sub_1C5DE1664(*(_QWORD *)(a1 + 128), v8, v9, v10);
    exit(0);
  }
  *(_WORD *)(a1 + 12) = a2;
  v12 = *(_QWORD *)(a1 + 176);
  if (v12)
  {
    (*(void (**)(uint64_t, char *))(*(_QWORD *)v12 + 48))(v12, &v14);
    return v11;
  }
  sub_1C485C2F0();
  return sub_1C5DE5BD8();
}

uint64_t sub_1C5DE5BD8()
{
  return 1;
}

_QWORD *sub_1C5DE5BE0(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = off_1E819E608;
  v2 = a1 + 19;
  v3 = (_QWORD *)a1[22];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return sub_1C47A80D0(a1);
}

void sub_1C5DE5C3C(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = off_1E819E608;
  v2 = a1 + 19;
  v3 = (_QWORD *)a1[22];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
    {
LABEL_6:
      sub_1C47A80D0(a1);
      JUMPOUT(0x1CAA32FC0);
    }
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
  goto LABEL_6;
}

uint64_t sub_1C5DE5CAC(uint64_t a1)
{
  return llvm::cl::basic_parser_impl::getOptionWidth(a1 + 144, a1);
}

llvm::raw_ostream *sub_1C5DE5CB8(uint64_t a1, unsigned int a2)
{
  return llvm::cl::basic_parser_impl::printOptionInfo((llvm::cl::basic_parser_impl *)(a1 + 144), (const llvm::cl::Option *)a1, a2);
}

llvm::raw_ostream *sub_1C5DE5CC8(llvm::raw_ostream *result, int a2, int a3)
{
  llvm *v3;
  void *v4;

  if (a3)
  {
    v3 = llvm::cl::basic_parser_impl::printOptionName(result, result, a2);
    result = (llvm::raw_ostream *)llvm::outs(v3);
    v4 = (void *)*((_QWORD *)result + 4);
    if (*((_QWORD *)result + 3) - (_QWORD)v4 > 0x1DuLL)
    {
      qmemcpy(v4, "= *cannot print option value*\n", 30);
      *((_QWORD *)result + 4) += 30;
    }
    else
    {
      return llvm::raw_ostream::write(result, "= *cannot print option value*\n", 0x1EuLL);
    }
  }
  return result;
}

uint64_t sub_1C5DE5D44()
{
  return 0;
}

void sub_1C5DE5D50()
{
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C5DE5D64()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E819E690;
  return result;
}

void sub_1C5DE5D88(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E819E690;
}

_QWORD *sub_1C5DE5DA4(llvm::cl::Option *this, uint64_t a2, uint64_t a3, _QWORD *a4, _WORD *a5, _WORD *a6, llvm::cl::OptionCategory **a7, uint64_t *a8)
{
  __int16 v13;
  llvm::raw_ostream *v15;
  const char *v16;
  __int16 v17;

  *((_QWORD *)this + 4) = a2;
  *((_QWORD *)this + 5) = a3;
  if (*((_QWORD *)this + 16))
  {
    v16 = "cl::location(x) specified more than once!";
    v17 = 259;
    v15 = (llvm::raw_ostream *)llvm::errs(this);
    llvm::cl::Option::error(this, (llvm::Twine *)&v16, 0, 0, v15);
  }
  else
  {
    *((_QWORD *)this + 16) = *a4;
  }
  v13 = *((_WORD *)this + 5) & 0xFF9F | (32 * (*a5 & 3));
  *((_WORD *)this + 5) = v13;
  *((_WORD *)this + 5) = (8 * (*a6 & 3)) | v13 & 0xFFE7;
  llvm::cl::Option::addCategory(this, *a7);
  return sub_1C4774094((llvm::cl::Option *)((char *)this + 88), *a8);
}

uint64_t *sub_1C5DE5E6C(uint64_t a1, __int16 a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v16;
  char v17;

  v17 = 0;
  v11 = (uint64_t *)llvm::cl::parser<BOOL>::parse(a1, (_QWORD *)a1, a3, a4, a5, a6, &v17);
  if ((v11 & 1) == 0)
  {
    if (v17)
    {
      v11 = *(uint64_t **)(a1 + 128);
      if (!atomic_load((unint64_t *)&qword_1ED836A48))
        llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1ED836A48, (void *(*)(void))sub_1C5DE673C, (void (*)(void *))sub_1C5DE6840);
      if ((*(_DWORD *)(qword_1ED836A48 + 132) - *(_DWORD *)(qword_1ED836A48 + 136)) >= 2)
      {
        if (!atomic_load(qword_1ED825A30))
          llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED825A30, (void *(*)(void))sub_1C5DE4BF0, (void (*)(void *))sub_1C5DE5210);
        *(_WORD *)(qword_1ED825A30[0] + 138) &= 0xFF9Fu;
        v16 = v11[1];
LABEL_14:
        sub_1C5DE1664(v16, v8, v9, v10);
        exit(0);
      }
    }
    else
    {
      *(_WORD *)(a1 + 12) = a2;
      v12 = *(_QWORD *)(a1 + 176);
      if (v12)
      {
        (*(void (**)(uint64_t, char *))(*(_QWORD *)v12 + 48))(v12, &v17);
        return v11;
      }
      sub_1C485C2F0();
    }
    v16 = *v11;
    goto LABEL_14;
  }
  return v11;
}

uint64_t sub_1C5DE5F80()
{
  return 1;
}

_QWORD *sub_1C5DE5F88(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = off_1E819E6D8;
  v2 = a1 + 19;
  v3 = (_QWORD *)a1[22];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return sub_1C47A80D0(a1);
}

void sub_1C5DE5FE4(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = off_1E819E6D8;
  v2 = a1 + 19;
  v3 = (_QWORD *)a1[22];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
    {
LABEL_6:
      sub_1C47A80D0(a1);
      JUMPOUT(0x1CAA32FC0);
    }
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
  goto LABEL_6;
}

uint64_t sub_1C5DE6054(uint64_t a1)
{
  return llvm::cl::basic_parser_impl::getOptionWidth(a1 + 144, a1);
}

llvm::raw_ostream *sub_1C5DE6060(uint64_t a1, unsigned int a2)
{
  return llvm::cl::basic_parser_impl::printOptionInfo((llvm::cl::basic_parser_impl *)(a1 + 144), (const llvm::cl::Option *)a1, a2);
}

llvm::raw_ostream *sub_1C5DE6070(llvm::raw_ostream *result, int a2, int a3)
{
  llvm *v3;
  void *v4;

  if (a3)
  {
    v3 = llvm::cl::basic_parser_impl::printOptionName(result, result, a2);
    result = (llvm::raw_ostream *)llvm::outs(v3);
    v4 = (void *)*((_QWORD *)result + 4);
    if (*((_QWORD *)result + 3) - (_QWORD)v4 > 0x1DuLL)
    {
      qmemcpy(v4, "= *cannot print option value*\n", 30);
      *((_QWORD *)result + 4) += 30;
    }
    else
    {
      return llvm::raw_ostream::write(result, "= *cannot print option value*\n", 0x1EuLL);
    }
  }
  return result;
}

uint64_t sub_1C5DE60EC()
{
  return 0;
}

void sub_1C5DE60F8()
{
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C5DE610C()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E819E760;
  return result;
}

void sub_1C5DE6130(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E819E760;
}

llvm *sub_1C5DE614C(llvm *result, _QWORD *a2)
{
  llvm::raw_ostream *v3;
  const char *v4;
  __int16 v5;

  if (a2[16])
  {
    v4 = "cl::location(x) specified more than once!";
    v5 = 259;
    v3 = (llvm::raw_ostream *)llvm::errs(result);
    return (llvm *)llvm::cl::Option::error(a2, (llvm::Twine *)&v4, 0, 0, v3);
  }
  else
  {
    a2[16] = result;
  }
  return result;
}

uint64_t sub_1C5DE61B0(uint64_t a1, __int16 a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  llvm *v13;
  llvm::raw_ostream *v15;
  _BYTE *v16;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t *v22;
  char v23;

  v23 = 0;
  v8 = llvm::cl::parser<BOOL>::parse(a1, (_QWORD *)a1, a3, a4, a5, a6, &v23);
  v9 = v8;
  if ((v8 & 1) == 0)
  {
    if (v23)
    {
      if (!atomic_load(qword_1ED825A30))
        llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED825A30, (void *(*)(void))sub_1C5DE4BF0, (void (*)(void *))sub_1C5DE5210);
      if (!*(_QWORD *)(qword_1ED825A30[0] + 1408))
      {
        sub_1C5DE2540((llvm *)v8);
        if (!atomic_load(qword_1ED825A30))
          llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED825A30, (void *(*)(void))sub_1C5DE4BF0, (void (*)(void *))sub_1C5DE5210);
        if (*(_QWORD *)(qword_1ED825A30[0] + 1416) != *(_QWORD *)(qword_1ED825A30[0] + 1424))
        {
          v15 = (llvm::raw_ostream *)llvm::outs(v13);
          v16 = (_BYTE *)*((_QWORD *)v15 + 4);
          if ((unint64_t)v16 >= *((_QWORD *)v15 + 3))
          {
            v15 = llvm::raw_ostream::write(v15, 10);
          }
          else
          {
            *((_QWORD *)v15 + 4) = v16 + 1;
            *v16 = 10;
          }
          if (!atomic_load(qword_1ED825A30))
            llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED825A30, (void *(*)(void))sub_1C5DE4BF0, (void (*)(void *))sub_1C5DE5210);
          v18 = *(_QWORD *)(qword_1ED825A30[0] + 1416);
          v19 = *(_QWORD *)(qword_1ED825A30[0] + 1424);
          while (v18 != v19)
          {
            v20 = llvm::outs(v15);
            v21 = *(_QWORD *)(v18 + 24);
            if (!v21)
              goto LABEL_21;
            v15 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t, void *))(*(_QWORD *)v21 + 48))(v21, v20);
            v18 += 32;
          }
        }
LABEL_23:
        exit(0);
      }
    }
    else
    {
      *(_WORD *)(a1 + 12) = a2;
      v10 = *(_QWORD *)(a1 + 176);
      if (v10)
      {
        (*(void (**)(uint64_t, char *))(*(_QWORD *)v10 + 48))(v10, &v23);
        return v9;
      }
LABEL_21:
      sub_1C485C2F0();
    }
    v22 = (uint64_t *)sub_1C5DE1620();
    llvm::outs((llvm *)v22);
    sub_1C6386590(v22[176]);
    goto LABEL_23;
  }
  return v9;
}

uint64_t sub_1C5DE6344()
{
  return 1;
}

_QWORD *sub_1C5DE634C(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = off_1E819E7A8;
  v2 = a1 + 19;
  v3 = (_QWORD *)a1[22];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return sub_1C47A80D0(a1);
}

void sub_1C5DE63A8(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = off_1E819E7A8;
  v2 = a1 + 19;
  v3 = (_QWORD *)a1[22];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
    {
LABEL_6:
      sub_1C47A80D0(a1);
      JUMPOUT(0x1CAA32FC0);
    }
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
  goto LABEL_6;
}

uint64_t sub_1C5DE6418(uint64_t a1)
{
  return llvm::cl::basic_parser_impl::getOptionWidth(a1 + 144, a1);
}

llvm::raw_ostream *sub_1C5DE6424(uint64_t a1, unsigned int a2)
{
  return llvm::cl::basic_parser_impl::printOptionInfo((llvm::cl::basic_parser_impl *)(a1 + 144), (const llvm::cl::Option *)a1, a2);
}

llvm::raw_ostream *sub_1C5DE6434(llvm::raw_ostream *result, int a2, int a3)
{
  llvm *v3;
  void *v4;

  if (a3)
  {
    v3 = llvm::cl::basic_parser_impl::printOptionName(result, result, a2);
    result = (llvm::raw_ostream *)llvm::outs(v3);
    v4 = (void *)*((_QWORD *)result + 4);
    if (*((_QWORD *)result + 3) - (_QWORD)v4 > 0x1DuLL)
    {
      qmemcpy(v4, "= *cannot print option value*\n", 30);
      *((_QWORD *)result + 4) += 30;
    }
    else
    {
      return llvm::raw_ostream::write(result, "= *cannot print option value*\n", 0x1EuLL);
    }
  }
  return result;
}

uint64_t sub_1C5DE64B0()
{
  return 0;
}

void sub_1C5DE64BC()
{
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C5DE64D0()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E819E830;
  return result;
}

void sub_1C5DE64F4(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E819E830;
}

void sub_1C5DE6510(_QWORD *a1, int a2, uint64_t a3, int a4)
{
  _QWORD *i;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  char v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  BOOL v20;
  size_t v21;
  _BYTE *v22;
  _BYTE *v23;
  uint64_t v24;
  int v25;
  _BYTE v26[256];

  v22 = v26;
  v23 = v26;
  v24 = 32;
  v25 = 0;
  i = a1;
  if (a2)
  {
    for (i = a1; !*i || *i == -8; ++i)
      ;
  }
  v8 = &a1[a2];
  if (i != v8)
  {
    v9 = *i;
    do
    {
      v10 = *(_QWORD *)(v9 + 8);
      v11 = (*(unsigned __int16 *)(v10 + 10) >> 5) & 3;
      if (v11 == 1)
        v12 = a4;
      else
        v12 = 1;
      if (v11 != 2 && v12 != 0)
      {
        sub_1C4774094((llvm::SmallPtrSetImplBase *)&v22, v10);
        if (v14)
        {
          v15 = *i;
          v16 = *(_QWORD *)(*i + 8);
          v17 = *(unsigned int *)(a3 + 8);
          if (v17 >= *(unsigned int *)(a3 + 12))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod(a3, a3 + 16, v17 + 1, 16);
            v17 = *(unsigned int *)(a3 + 8);
          }
          v18 = (_QWORD *)(*(_QWORD *)a3 + 16 * v17);
          *v18 = v15 + 16;
          v18[1] = v16;
          ++*(_DWORD *)(a3 + 8);
        }
      }
      do
      {
        v19 = i[1];
        ++i;
        v9 = v19;
        if (v19)
          v20 = v9 == -8;
        else
          v20 = 1;
      }
      while (v20);
    }
    while (i != v8);
  }
  v21 = *(unsigned int *)(a3 + 8);
  if (v21 >= 2)
    qsort(*(void **)a3, v21, 0x10uLL, (int (__cdecl *)(const void *, const void *))sub_1C5DE666C);
  if (v23 != v22)
    free(v23);
}

uint64_t sub_1C5DE666C(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2);
}

uint64_t sub_1C5DE6678(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2);
}

_QWORD *sub_1C5DE6684(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *(_QWORD *)a1 = &unk_1E819E480;
  v2 = (_QWORD *)(a1 + 200);
  v3 = *(_QWORD **)(a1 + 224);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
LABEL_3:
    (*(void (**)(void))(*v3 + 8 * v4))();
    goto LABEL_4;
  }
  if (v3)
  {
    v4 = 5;
    goto LABEL_3;
  }
LABEL_4:
  *(_QWORD *)(a1 + 152) = &off_1E7FA8D20;
  if (*(char *)(a1 + 183) < 0)
    operator delete(*(void **)(a1 + 160));
  if (*(char *)(a1 + 151) < 0)
    operator delete(*(void **)(a1 + 128));
  return sub_1C47A80D0((_QWORD *)a1);
}

BOOL sub_1C5DE6710(uint64_t a1, uint64_t a2)
{
  return *(_BYTE *)(a2 + 9) && *(_BYTE *)(a1 + 9) && *(unsigned __int8 *)(a1 + 8) != *(unsigned __int8 *)(a2 + 8);
}

uint64_t sub_1C5DE673C()
{
  uint64_t v0;

  v0 = operator new();
  *(_OWORD *)v0 = 0u;
  *(_OWORD *)(v0 + 16) = 0u;
  *(_OWORD *)(v0 + 32) = 0u;
  *(_OWORD *)(v0 + 48) = 0u;
  *(_QWORD *)(v0 + 64) = v0 + 80;
  *(_QWORD *)(v0 + 72) = 0x400000000;
  *(_QWORD *)(v0 + 112) = v0 + 144;
  *(_QWORD *)(v0 + 120) = v0 + 144;
  *(_QWORD *)(v0 + 128) = 16;
  *(_DWORD *)(v0 + 136) = 0;
  *(_QWORD *)(v0 + 272) = v0 + 304;
  *(_QWORD *)(v0 + 280) = v0 + 304;
  *(_QWORD *)(v0 + 288) = 4;
  *(_DWORD *)(v0 + 296) = 0;
  *(_QWORD *)(v0 + 336) = 0;
  if (!atomic_load(llvm::cl::TopLevelSubCommand))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)llvm::cl::TopLevelSubCommand, (void *(*)(void))sub_1C6386064, (void (*)(void *))sub_1C63860D8);
  sub_1C5DDB1E0((uint64_t *)v0, llvm::cl::TopLevelSubCommand[0]);
  if (!atomic_load((unint64_t *)&llvm::cl::AllSubCommands))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&llvm::cl::AllSubCommands, (void *(*)(void))sub_1C6386064, (void (*)(void *))sub_1C63860D8);
  sub_1C5DDB1E0((uint64_t *)v0, llvm::cl::AllSubCommands);
  return v0;
}

uint64_t sub_1C5DE6840(uint64_t result)
{
  uint64_t v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  if (result)
  {
    v1 = result;
    v2 = *(void **)(result + 280);
    if (v2 != *(void **)(v1 + 272))
      free(v2);
    v3 = *(void **)(v1 + 120);
    if (v3 != *(void **)(v1 + 112))
      free(v3);
    v4 = *(void **)(v1 + 64);
    if (v4 != (void *)(v1 + 80))
      free(v4);
    v5 = *(void **)(v1 + 40);
    if (v5)
    {
      *(_QWORD *)(v1 + 48) = v5;
      operator delete(v5);
    }
    if (*(char *)(v1 + 23) < 0)
      operator delete(*(void **)v1);
    JUMPOUT(0x1CAA32FC0);
  }
  return result;
}

uint64_t *sub_1C5DE68D0(uint64_t *result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = *result;
  v4 = *(unsigned int *)(*result + 8);
  if (v4 >= *(_DWORD *)(*result + 12))
  {
    result = (uint64_t *)llvm::SmallVectorBase<unsigned int>::grow_pod(*result, v3 + 16, v4 + 1, 8);
    LODWORD(v4) = *(_DWORD *)(v3 + 8);
  }
  *(_QWORD *)(*(_QWORD *)v3 + 8 * v4) = a2;
  ++*(_DWORD *)(v3 + 8);
  return result;
}

_QWORD *sub_1C5DE692C(_QWORD *result)
{
  uint64_t v1;
  uint64_t v2;

  if (*(_BYTE *)*result)
  {
    v1 = result[1];
    v2 = *(unsigned int *)(v1 + 8);
    if (v2 >= *(_DWORD *)(v1 + 12))
    {
      result = llvm::SmallVectorBase<unsigned int>::grow_pod(result[1], v1 + 16, v2 + 1, 8);
      LODWORD(v2) = *(_DWORD *)(v1 + 8);
    }
    *(_QWORD *)(*(_QWORD *)v1 + 8 * v2) = 0;
    ++*(_DWORD *)(v1 + 8);
  }
  return result;
}

uint64_t *sub_1C5DE6990(uint64_t *result, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;

  v5 = *result;
  v6 = *(unsigned int *)(*result + 8);
  if (v6 >= *(_DWORD *)(*result + 12))
  {
    result = (uint64_t *)llvm::SmallVectorBase<unsigned int>::grow_pod(*result, v5 + 16, v6 + 1, 16);
    LODWORD(v6) = *(_DWORD *)(v5 + 8);
  }
  v7 = (_QWORD *)(*(_QWORD *)v5 + 16 * v6);
  *v7 = a2;
  v7[1] = a3;
  ++*(_DWORD *)(v5 + 8);
  return result;
}

uint64_t llvm::crc32(uint64_t result, char *a2, uint64_t a3)
{
  unsigned int v3;
  char v4;

  if (a3)
  {
    v3 = ~(_DWORD)result;
    do
    {
      v4 = *a2++;
      v3 = dword_1C866F364[(v4 ^ v3)] ^ (v3 >> 8);
      --a3;
    }
    while (a3);
    return ~v3;
  }
  return result;
}

uint64_t llvm::ConvertUTF32toUTF16(unsigned int **a1, unint64_t a2, _WORD **a3, unint64_t a4, int a5)
{
  unsigned int *v5;
  _WORD *v6;
  uint64_t v7;
  unsigned int *v8;
  unsigned int v9;

  v5 = *a1;
  v6 = *a3;
  if ((unint64_t)*a1 >= a2)
  {
    v7 = 0;
    goto LABEL_20;
  }
  v7 = 0;
  v8 = *a1;
  while ((unint64_t)v6 < a4)
  {
    v5 = v8 + 1;
    v9 = *v8;
    if (!HIWORD(*v8))
    {
      if (v9 >> 11 != 27)
      {
        *v6++ = v9;
        goto LABEL_15;
      }
      if (!a5)
      {
        v7 = 3;
        goto LABEL_19;
      }
      goto LABEL_10;
    }
    if (v9 >= 0x110000)
    {
      if (!a5)
      {
        v7 = 3;
        goto LABEL_15;
      }
LABEL_10:
      *v6++ = -3;
      goto LABEL_15;
    }
    if ((unint64_t)(v6 + 1) >= a4)
      break;
    *v6 = ((v9 + 67043328) >> 10) - 10240;
    v6[1] = v9 & 0x3FF | 0xDC00;
    v6 += 2;
LABEL_15:
    ++v8;
    if ((unint64_t)v5 >= a2)
      goto LABEL_20;
  }
  v7 = 2;
LABEL_19:
  v5 = v8;
LABEL_20:
  *a1 = v5;
  *a3 = v6;
  return v7;
}

uint64_t llvm::ConvertUTF16toUTF32(unint64_t *a1, unint64_t a2, int **a3, unint64_t a4, int a5)
{
  unsigned __int16 *v5;
  int *v6;
  unsigned __int16 *v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;

  v5 = (unsigned __int16 *)*a1;
  v6 = *a3;
  if (*a1 < a2)
  {
    v7 = (unsigned __int16 *)*a1;
    while (1)
    {
      v9 = *v7++;
      v8 = v9;
      v10 = v9 & 0xFC00;
      if (v10 == 55296)
      {
        if ((unint64_t)v7 >= a2)
        {
          v12 = 1;
          goto LABEL_18;
        }
        v11 = *v7;
        if ((v11 & 0xFC00) == 0xDC00)
        {
          v8 = v11 + (v8 << 10) - 56613888;
          v7 = v5 + 2;
        }
        else if (!a5)
        {
          goto LABEL_16;
        }
      }
      else if (!a5 && v10 == 56320)
      {
LABEL_16:
        v12 = 3;
        goto LABEL_18;
      }
      if ((unint64_t)v6 >= a4)
      {
        v12 = 2;
        goto LABEL_18;
      }
      *v6++ = v8;
      v5 = v7;
      if ((unint64_t)v7 >= a2)
      {
        v12 = 0;
        v5 = v7;
        goto LABEL_18;
      }
    }
  }
  v12 = 0;
LABEL_18:
  *a1 = (unint64_t)v5;
  *a3 = v6;
  return v12;
}

uint64_t llvm::ConvertUTF16toUTF8(unint64_t *a1, unint64_t a2, uint64_t *a3, unint64_t a4, int a5)
{
  unsigned __int16 *v5;
  unint64_t v6;
  unsigned __int16 *v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  int v11;
  __int16 v12;
  unsigned __int16 v13;
  unint64_t v14;
  uint64_t v15;

  v5 = (unsigned __int16 *)*a1;
  v6 = *a3;
  if (*a1 < a2)
  {
    v7 = (unsigned __int16 *)*a1;
    while (1)
    {
      v9 = *v7++;
      v8 = v9;
      v10 = v9 & 0xFC00;
      if (v10 == 55296)
      {
        if ((unint64_t)v7 >= a2)
        {
          v15 = 1;
          goto LABEL_31;
        }
        v11 = *v7;
        if ((v11 & 0xFC00) == 0xDC00)
        {
          v8 = v11 + (v8 << 10) - 56613888;
          v7 = v5 + 2;
        }
        else if (!a5)
        {
          goto LABEL_29;
        }
      }
      else if (!a5 && v10 == 56320)
      {
LABEL_29:
        v15 = 3;
        goto LABEL_31;
      }
      if (v8 < 0x10000)
        v12 = 3;
      else
        v12 = 4;
      if (v8 < 0x800)
        v12 = 2;
      if (v8 >= 0x80)
        v13 = v12;
      else
        v13 = 1;
      v14 = v6 + v13;
      if (v14 > a4)
      {
        v15 = 2;
        goto LABEL_31;
      }
      switch(v13)
      {
        case 1u:
          goto LABEL_24;
        case 2u:
          goto LABEL_23;
        case 3u:
          goto LABEL_22;
        case 4u:
          *(_BYTE *)--v14 = v8 & 0x3F | 0x80;
          v8 >>= 6;
LABEL_22:
          *(_BYTE *)--v14 = v8 & 0x3F | 0x80;
          v8 >>= 6;
LABEL_23:
          *(_BYTE *)--v14 = v8 & 0x3F | 0x80;
          v8 >>= 6;
LABEL_24:
          *(_BYTE *)--v14 = byte_1C866F77C[v13] | v8;
          break;
        default:
          break;
      }
      v6 = v14 + v13;
      v5 = v7;
      if ((unint64_t)v7 >= a2)
      {
        v15 = 0;
        v5 = v7;
        goto LABEL_31;
      }
    }
  }
  v15 = 0;
LABEL_31:
  *a1 = (unint64_t)v5;
  *a3 = v6;
  return v15;
}

BOOL llvm::isLegalUTF8Sequence(llvm *this, const unsigned __int8 *a2, const unsigned __int8 *a3)
{
  uint64_t v4;

  v4 = byte_1C866F783[*(unsigned __int8 *)this] + 1;
  return a2 - (const unsigned __int8 *)this >= v4 && sub_1C5DE6D58((unsigned __int8 *)this, v4);
}

BOOL sub_1C5DE6D58(unsigned __int8 *a1, int a2)
{
  unsigned __int8 *v2;
  unsigned int v3;
  int v5;
  int v6;
  int v7;
  unsigned int v8;

  v2 = &a1[a2];
  switch(a2)
  {
    case 1:
      v3 = *a1;
      goto LABEL_3;
    case 2:
      goto LABEL_7;
    case 3:
      goto LABEL_6;
    case 4:
      v5 = (char)*--v2;
      if (v5 > -65)
        return 0;
LABEL_6:
      v6 = (char)*--v2;
      if (v6 > -65)
        return 0;
LABEL_7:
      v7 = (char)*(v2 - 1);
      if (v7 > -65)
        return 0;
      v8 = v7;
      v3 = *a1;
      if (v3 > 0xEF)
      {
        if (v3 == 240)
        {
          if (v8 >= 0x90)
          {
            v3 = 240;
            return v3 < 0xF5;
          }
          return 0;
        }
        if (v3 == 244)
        {
          if (v8 <= 0x8F)
          {
            v3 = 244;
            return v3 < 0xF5;
          }
          return 0;
        }
      }
      else
      {
        if (v3 == 224)
        {
          if (v8 >= 0xA0)
          {
            v3 = 224;
            return v3 < 0xF5;
          }
          return 0;
        }
        if (v3 == 237)
        {
          if (v8 <= 0x9F)
          {
            v3 = 237;
            return v3 < 0xF5;
          }
          return 0;
        }
      }
LABEL_3:
      if ((char)v3 >= -62)
        return v3 < 0xF5;
      return 0;
    default:
      return 0;
  }
}

uint64_t llvm::getNumBytesForUTF8(llvm *this)
{
  return (byte_1C866F783[this] + 1);
}

BOOL llvm::isLegalUTF8String(unsigned __int8 **this, const unsigned __int8 **a2, const unsigned __int8 *a3)
{
  unsigned __int8 *v3;
  uint64_t v6;
  _BOOL8 result;

  v3 = *this;
  if (*this == (unsigned __int8 *)a2)
    return 1;
  while (1)
  {
    v6 = byte_1C866F783[*v3] + 1;
    if ((char *)a2 - (char *)v3 < v6)
      break;
    result = sub_1C5DE6D58(v3, byte_1C866F783[*v3] + 1);
    if (!result)
      return result;
    v3 += v6;
    *this = v3;
    if (v3 == (unsigned __int8 *)a2)
      return 1;
  }
  return 0;
}

uint64_t llvm::ConvertUTF8toUTF32Partial(unint64_t *a1, unsigned __int8 *a2, unsigned int **a3, unint64_t a4, int a5)
{
  return sub_1C5DE6EDC(a1, a2, a3, a4, a5, 1);
}

uint64_t sub_1C5DE6EDC(unint64_t *a1, unsigned __int8 *a2, unsigned int **a3, unint64_t a4, int a5, int a6)
{
  unsigned __int8 *v6;
  unsigned int *v7;
  uint64_t v10;
  BOOL v11;
  char v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  unsigned int v23;
  BOOL v24;
  uint64_t v26;
  int v27;
  BOOL v28;
  char *v29;

  v6 = (unsigned __int8 *)*a1;
  v7 = *a3;
  if (*a1 >= (unint64_t)a2)
  {
    v10 = 0;
    goto LABEL_64;
  }
  v10 = 0;
  if (a5)
    v11 = a6 == 0;
  else
    v11 = 0;
  v12 = !v11;
  while (1)
  {
    v13 = *v6;
    if (a2 - v6 <= (unsigned __int16)byte_1C866F783[v13])
    {
      if ((v12 & 1) != 0)
      {
        v10 = 1;
        goto LABEL_64;
      }
      goto LABEL_28;
    }
    if ((unint64_t)v7 >= a4)
    {
      v10 = 2;
      goto LABEL_64;
    }
    v14 = (unsigned __int16)byte_1C866F783[v13];
    v15 = (unsigned __int16)byte_1C866F783[v13] + 1;
    if (sub_1C5DE6D58(v6, v15))
      break;
    if (!a5)
      goto LABEL_66;
LABEL_28:
    if (v6 == a2)
    {
      v26 = 0;
      goto LABEL_48;
    }
    if ((v13 + 62) < 0x1Eu || v6 + 1 == a2)
    {
LABEL_34:
      v26 = 1;
      goto LABEL_48;
    }
    v27 = (char)v6[1];
    if ((_DWORD)v13 == 224)
    {
      v26 = 1;
      if ((v27 & 0xFFFFFFE0) == 0xFFFFFFA0)
        v26 = 2;
      goto LABEL_48;
    }
    if ((v13 + 31) <= 0xBu)
      goto LABEL_44;
    if ((_DWORD)v13 == 237)
    {
      v28 = v27 < -96;
      goto LABEL_45;
    }
    if ((v13 & 0xFE) == 0xEE)
    {
LABEL_44:
      v28 = v27 < -64;
LABEL_45:
      v26 = 1;
LABEL_46:
      if (v28)
        ++v26;
      goto LABEL_48;
    }
    v29 = (char *)(v6 + 2);
    if ((_DWORD)v13 == 240)
    {
      if ((v27 + 112) > 0x2F)
        goto LABEL_34;
    }
    else if ((v13 + 15) > 2u)
    {
      if ((_DWORD)v13 != 244)
        goto LABEL_34;
      v26 = 1;
      if (v27 > -113)
        goto LABEL_48;
    }
    else if (v27 > -65)
    {
      goto LABEL_34;
    }
    if (v29 != (char *)a2)
    {
      v28 = *v29 < -64;
      v26 = 2;
      goto LABEL_46;
    }
    v26 = 2;
LABEL_48:
    v6 += v26;
LABEL_49:
    v10 = 3;
    v23 = 65533;
LABEL_50:
    *v7++ = v23;
    if (v6 >= a2)
      goto LABEL_64;
  }
  v16 = 0;
  v17 = v14;
  switch((int)v14)
  {
    case 0:
      goto LABEL_17;
    case 1:
      goto LABEL_16;
    case 2:
      goto LABEL_15;
    case 3:
      goto LABEL_14;
    case 4:
      goto LABEL_13;
    case 5:
      v16 = (_DWORD)v13 << 6;
      v18 = *++v6;
      LODWORD(v13) = v18;
LABEL_13:
      v19 = *++v6;
      v16 = (v16 + (_DWORD)v13) << 6;
      LODWORD(v13) = v19;
LABEL_14:
      v20 = *++v6;
      v16 = (v16 + (_DWORD)v13) << 6;
      LODWORD(v13) = v20;
LABEL_15:
      v21 = *++v6;
      v16 = (v16 + (_DWORD)v13) << 6;
      LODWORD(v13) = v21;
LABEL_16:
      v22 = *++v6;
      v17 = (v16 + (_DWORD)v13) << 6;
      LODWORD(v13) = v22;
LABEL_17:
      ++v6;
      v16 = v17 + v13;
      break;
    default:
      break;
  }
  v23 = v16 - dword_1C866F884[v14];
  if (HIWORD(v23) > 0x10u)
    goto LABEL_49;
  v24 = (v23 & 0xFFFFF800) == 55296;
  if ((v23 & 0xFFFFF800) == 0xD800)
    v23 = 65533;
  if (a5 || !v24)
    goto LABEL_50;
  v6 -= v15;
LABEL_66:
  v10 = 3;
LABEL_64:
  *a1 = (unint64_t)v6;
  *a3 = v7;
  return v10;
}

uint64_t llvm::ConvertUTF8toUTF32(unint64_t *a1, unsigned __int8 *a2, unsigned int **a3, unint64_t a4, int a5)
{
  return sub_1C5DE6EDC(a1, a2, a3, a4, a5, 0);
}

BOOL llvm::ConvertUTF8toWide(int a1, unsigned __int8 *a2, size_t a3, void **a4, _QWORD *a5)
{
  int v9;
  _WORD *v10;
  _WORD *v12;
  unsigned __int8 *v13;

  switch(a1)
  {
    case 1:
      v13 = a2;
      if (!llvm::isLegalUTF8String(&v13, (const unsigned __int8 **)&a2[a3], (const unsigned __int8 *)a3))
      {
        *a5 = v13;
        v9 = 3;
        return v9 == 0;
      }
      memcpy(*a4, a2, a3);
      v9 = 0;
      v10 = (char *)*a4 + a3;
      goto LABEL_4;
    case 2:
      v12 = *a4;
      v13 = a2;
      v9 = llvm::ConvertUTF8toUTF16(&v13, (unint64_t)&a2[a3], &v12, (unint64_t)&v12[a3], 0);
      if (v9)
      {
LABEL_8:
        *a5 = v13;
        return v9 == 0;
      }
      break;
    case 4:
      v12 = *a4;
      v13 = a2;
      v9 = sub_1C5DE6EDC((unint64_t *)&v13, &a2[a3], (unsigned int **)&v12, (unint64_t)&v12[2 * a3], 0, 0);
      if (v9)
        goto LABEL_8;
      break;
    default:
      v9 = 0;
      return v9 == 0;
  }
  v10 = v12;
LABEL_4:
  *a4 = v10;
  return v9 == 0;
}

BOOL llvm::convertUTF16ToUTF8String(unsigned __int16 *a1, int64_t a2, std::string *this)
{
  unsigned __int16 *v5;
  unint64_t v6;
  int v7;
  unsigned __int16 *v9;
  unint64_t v10;
  _BOOL8 v11;
  char v12;
  BOOL v13;
  std::string *v14;
  std::string::size_type size;
  std::string::size_type v16;
  int v17;
  std::string *v18;
  int v19;
  std::string::size_type v20;
  std::string *v21;
  std::string::size_type v22;
  std::string *v24;
  unsigned __int16 *v25;

  if ((a2 & 1) != 0)
    return 0;
  if (!a2)
    return 1;
  v5 = a1;
  v25 = a1;
  v6 = (unint64_t)a1 + a2;
  v7 = *a1;
  if (v7 == 65534)
  {
    if (a2 < 1)
    {
      v6 = 0;
      v9 = 0;
    }
    else
    {
      v9 = (unsigned __int16 *)operator new(a2);
      memcpy(v9, v5, v6 - (_QWORD)v5);
      v10 = 0;
      v6 = (unint64_t)v9 + a2;
      do
      {
        v9[v10 / 2] = bswap32(v9[v10 / 2]) >> 16;
        v10 += 2;
      }
      while (a2 != v10);
    }
    v25 = v9;
    v7 = *v9;
    v5 = v9;
  }
  else
  {
    v9 = 0;
  }
  if (v7 == 65279)
    v25 = v5 + 1;
  std::string::resize(this, (4 * a2) | 1, 0);
  v12 = HIBYTE(this->__r_.__value_.__r.__words[2]);
  v13 = v12 < 0;
  v14 = (std::string *)this->__r_.__value_.__r.__words[0];
  size = this->__r_.__value_.__l.__size_;
  if (v12 >= 0)
    v14 = this;
  v24 = v14;
  v16 = v12 & 0x7F;
  if (v13)
    v16 = size;
  v17 = llvm::ConvertUTF16toUTF8((unint64_t *)&v25, v6, (uint64_t *)&v24, (unint64_t)v14 + v16, 0);
  v11 = v17 == 0;
  if (v17)
  {
    if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
    {
      *this->__r_.__value_.__l.__data_ = 0;
      this->__r_.__value_.__l.__size_ = 0;
    }
    else
    {
      this->__r_.__value_.__s.__data_[0] = 0;
      *((_BYTE *)&this->__r_.__value_.__s + 23) = 0;
    }
  }
  else
  {
    if ((this->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v18 = this;
    else
      v18 = (std::string *)this->__r_.__value_.__r.__words[0];
    std::string::resize(this, (char *)v24 - (char *)v18, 0);
    std::string::push_back(this, 0);
    v19 = SHIBYTE(this->__r_.__value_.__r.__words[2]);
    v20 = this->__r_.__value_.__l.__size_;
    if (v19 < 0)
    {
      v21 = (std::string *)this->__r_.__value_.__r.__words[0];
    }
    else
    {
      v20 = HIBYTE(this->__r_.__value_.__r.__words[2]);
      v21 = this;
    }
    v22 = v20 - 1;
    if (v19 < 0)
      this->__r_.__value_.__l.__size_ = v22;
    else
      *((_BYTE *)&this->__r_.__value_.__s + 23) = v22 & 0x7F;
    v21->__r_.__value_.__s.__data_[v22] = 0;
  }
  if (v9)
    operator delete(v9);
  return v11;
}

BOOL llvm::convertUTF16ToUTF8String(unsigned __int16 *a1, uint64_t a2, std::string *a3)
{
  return llvm::convertUTF16ToUTF8String(a1, 2 * a2, a3);
}

BOOL llvm::convertUTF32ToUTF8String(unsigned int *__src, uint64_t a2, std::string *this)
{
  _BOOL8 v3;
  unsigned int *v7;
  char *v8;
  unsigned int v9;
  unsigned int *v10;
  char v11;
  BOOL v12;
  std::string *v13;
  std::string::size_type size;
  std::string::size_type v15;
  int v16;
  std::string *v17;
  int v18;
  std::string::size_type v19;
  std::string *v20;
  std::string::size_type v21;
  std::string *v22;
  void *__p;
  char *v24;
  uint64_t v25;
  unsigned int *v26;

  if ((a2 & 3) != 0)
    return 0;
  if (!a2)
    return 1;
  v7 = __src;
  v25 = 0;
  v26 = __src;
  v8 = (char *)__src + a2;
  __p = 0;
  v24 = 0;
  v9 = *__src;
  if (*__src == -131072)
  {
    sub_1C5DE7A20((char **)&__p, 0, (char *)__src, v8, a2 >> 2);
    v7 = (unsigned int *)__p;
    v8 = v24;
    if (__p != v24)
    {
      v10 = (unsigned int *)__p;
      do
      {
        *v10 = bswap32(*v10);
        ++v10;
      }
      while (v10 != (unsigned int *)v8);
    }
    v26 = v7;
    v9 = *v7;
  }
  if (v9 == 65279)
    v26 = v7 + 1;
  std::string::resize(this, (4 * a2) | 1, 0);
  v11 = HIBYTE(this->__r_.__value_.__r.__words[2]);
  v12 = v11 < 0;
  v13 = (std::string *)this->__r_.__value_.__r.__words[0];
  size = this->__r_.__value_.__l.__size_;
  if (v11 >= 0)
    v13 = this;
  v22 = v13;
  v15 = v11 & 0x7F;
  if (v12)
    v15 = size;
  v16 = llvm::ConvertUTF32toUTF8(&v26, (unint64_t)v8, (uint64_t *)&v22, (unint64_t)v13 + v15, 0);
  v3 = v16 == 0;
  if (v16)
  {
    if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
    {
      *this->__r_.__value_.__l.__data_ = 0;
      this->__r_.__value_.__l.__size_ = 0;
    }
    else
    {
      this->__r_.__value_.__s.__data_[0] = 0;
      *((_BYTE *)&this->__r_.__value_.__s + 23) = 0;
    }
  }
  else
  {
    if ((this->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v17 = this;
    else
      v17 = (std::string *)this->__r_.__value_.__r.__words[0];
    std::string::resize(this, (char *)v22 - (char *)v17, 0);
    std::string::push_back(this, 0);
    v18 = SHIBYTE(this->__r_.__value_.__r.__words[2]);
    v19 = this->__r_.__value_.__l.__size_;
    if (v18 < 0)
    {
      v20 = (std::string *)this->__r_.__value_.__r.__words[0];
    }
    else
    {
      v19 = HIBYTE(this->__r_.__value_.__r.__words[2]);
      v20 = this;
    }
    v21 = v19 - 1;
    if (v18 < 0)
      this->__r_.__value_.__l.__size_ = v21;
    else
      *((_BYTE *)&this->__r_.__value_.__s + 23) = v21 & 0x7F;
    v20->__r_.__value_.__s.__data_[v21] = 0;
  }
  if (__p)
  {
    v24 = (char *)__p;
    operator delete(__p);
  }
  return v3;
}

BOOL llvm::convertUTF32ToUTF8String(unsigned int *a1, uint64_t a2, std::string *a3)
{
  return llvm::convertUTF32ToUTF8String(a1, 4 * a2, a3);
}

uint64_t llvm::convertUTF8ToUTF16String(unsigned __int8 *a1, uint64_t a2, _QWORD *a3)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  unint64_t v16;
  unint64_t v17;
  unsigned int v18;
  unint64_t v19;
  unsigned int v20;
  _WORD *v21;
  unsigned __int8 *v22;

  if (a2)
  {
    v22 = a1;
    v5 = (unint64_t)&a1[a2];
    v6 = a2 + 1;
    v7 = a3[1];
    if (v7 != v6)
    {
      if (v7 <= v6)
      {
        v16 = v5;
        v19 = v6;
        if (a3[2] < v6)
        {
          llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a3, a3 + 3, v6, 2);
          v7 = a3[1];
        }
        v5 = v16;
        v6 = v19;
        if (v19 != v7)
        {
          bzero((void *)(*a3 + 2 * v7), 2 * (v19 - v7));
          v5 = v16;
          v6 = v19;
        }
      }
      a3[1] = v6;
    }
    v21 = (_WORD *)*a3;
    v8 = llvm::ConvertUTF8toUTF16(&v22, v5, &v21, (unint64_t)&v21[v6], 0);
    result = v8 == 0;
    if (v8)
    {
      v10 = 0;
    }
    else
    {
      v12 = a3[1];
      v13 = (uint64_t)v21 - *a3;
      v14 = v13 >> 1;
      if (v12 != v13 >> 1)
      {
        if (v12 <= v14)
        {
          v15 = (char *)v21 - *a3;
          v17 = v13 >> 1;
          v20 = result;
          if (a3[2] < v14)
          {
            llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a3, a3 + 3, v17, 2);
            v12 = a3[1];
          }
          v14 = v17;
          result = v20;
          if (v12 != v17)
          {
            bzero((void *)(*a3 + 2 * v12), (size_t)&v15[-2 * v12]);
            v14 = v17;
            result = v20;
          }
        }
        a3[1] = v14;
      }
      if (v14 + 1 > a3[2])
      {
        v18 = result;
        llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a3, a3 + 3, v14 + 1, 2);
        result = v18;
        v14 = a3[1];
      }
      *(_WORD *)(*a3 + 2 * v14) = 0;
      v10 = a3[1];
    }
    a3[1] = v10;
  }
  else
  {
    v11 = a3[1];
    if ((unint64_t)(v11 + 1) > a3[2])
    {
      llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a3, a3 + 3, v11 + 1, 2);
      v11 = a3[1];
    }
    *(_WORD *)(*a3 + 2 * v11) = 0;
    return 1;
  }
  return result;
}

BOOL llvm::ConvertUTF8toWide(unint64_t a1, uint64_t a2, std::wstring *this)
{
  std::wstring *v6;
  int v7;
  int v8;
  std::wstring *v9;
  char *v11;
  unint64_t v12;

  std::wstring::resize(this, a2 + 1, 0);
  if ((this->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v6 = this;
  else
    v6 = (std::wstring *)this->__r_.__value_.__r.__words[0];
  v11 = (char *)v6;
  v12 = a1;
  v7 = sub_1C5DE6EDC(&v12, (unsigned __int8 *)(a1 + a2), (unsigned int **)&v11, (unint64_t)v6 + 4 * a2, 0, 0);
  v8 = SHIBYTE(this->__r_.__value_.__r.__words[2]);
  if (v7)
  {
    if (v8 < 0)
    {
      *this->__r_.__value_.__l.__data_ = 0;
      this->__r_.__value_.__l.__size_ = 0;
    }
    else
    {
      this->__r_.__value_.__s.__data_[0] = 0;
      *((_BYTE *)&this->__r_.__value_.__s + 23) = 0;
    }
  }
  else
  {
    if (v8 >= 0)
      v9 = this;
    else
      v9 = (std::wstring *)this->__r_.__value_.__r.__words[0];
    std::wstring::resize(this, (v11 - (char *)v9) >> 2, 0);
  }
  return v7 == 0;
}

BOOL llvm::ConvertUTF8toWide(const char *a1, uint64_t a2)
{
  size_t v4;

  if (a1)
  {
    v4 = strlen(a1);
    return llvm::ConvertUTF8toWide((unint64_t)a1, v4, (std::wstring *)a2);
  }
  else
  {
    if (*(char *)(a2 + 23) < 0)
    {
      **(_DWORD **)a2 = 0;
      *(_QWORD *)(a2 + 8) = 0;
    }
    else
    {
      *(_DWORD *)a2 = 0;
      *(_BYTE *)(a2 + 23) = 0;
    }
    return 1;
  }
}

BOOL llvm::convertWideToUTF8(uint64_t a1, std::string *this)
{
  char v3;
  BOOL v4;
  unsigned int *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  char v9;
  BOOL v10;
  std::string *v11;
  std::string::size_type size;
  std::string::size_type v13;
  int v14;
  std::string *v15;
  std::string *v17;
  unsigned int *v18;

  v3 = *(_BYTE *)(a1 + 23);
  v4 = v3 < 0;
  v5 = *(unsigned int **)a1;
  v6 = *(_QWORD *)(a1 + 8);
  if (v3 >= 0)
    v5 = (unsigned int *)a1;
  v18 = v5;
  v7 = v3 & 0x7F;
  if (v4)
    v7 = v6;
  v8 = (unint64_t)&v5[v7];
  std::string::resize(this, 4 * v7, 0);
  v9 = HIBYTE(this->__r_.__value_.__r.__words[2]);
  v10 = v9 < 0;
  v11 = (std::string *)this->__r_.__value_.__r.__words[0];
  size = this->__r_.__value_.__l.__size_;
  if (v9 >= 0)
    v11 = this;
  v17 = v11;
  v13 = v9 & 0x7F;
  if (v10)
    v13 = size;
  v14 = llvm::ConvertUTF32toUTF8(&v18, v8, (uint64_t *)&v17, (unint64_t)v11 + v13, 0);
  if (v14)
  {
    if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
    {
      *this->__r_.__value_.__l.__data_ = 0;
      this->__r_.__value_.__l.__size_ = 0;
    }
    else
    {
      this->__r_.__value_.__s.__data_[0] = 0;
      *((_BYTE *)&this->__r_.__value_.__s + 23) = 0;
    }
  }
  else
  {
    if ((this->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v15 = this;
    else
      v15 = (std::string *)this->__r_.__value_.__r.__words[0];
    std::string::resize(this, (char *)v17 - (char *)v15, 0);
  }
  return v14 == 0;
}

char *sub_1C5DE7A20(char **a1, char *a2, char *__src, char *a4, uint64_t a5)
{
  char *v5;
  uint64_t v6;
  char *v7;
  char *v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  int64_t v19;
  char *v20;
  char *v21;
  int *v22;
  char *v23;
  int v24;
  char *v25;
  unint64_t v26;
  char *v27;
  uint64_t v28;
  char *v29;
  size_t v30;
  unint64_t v32;

  v5 = *a1;
  v6 = a2 - *a1;
  v7 = &(*a1)[v6 & 0xFFFFFFFFFFFFFFFCLL];
  if (a5 < 1)
    return v7;
  v12 = (unint64_t)a1[1];
  v11 = a1[2];
  if (a5 > (uint64_t)&v11[-v12] >> 2)
  {
    v13 = a5 + ((uint64_t)(v12 - (_QWORD)v5) >> 2);
    if (v13 >> 62)
      abort();
    v15 = v11 - v5;
    if (v15 >> 1 > v13)
      v13 = v15 >> 1;
    if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFFCLL)
      v13 = 0x3FFFFFFFFFFFFFFFLL;
    v32 = v13;
    if (v13)
    {
      if (v13 >> 62)
        sub_1C4764EE4();
      v16 = (char *)operator new(4 * v13);
    }
    else
    {
      v16 = 0;
    }
    v25 = &v16[4 * (v6 >> 2)];
    memcpy(v25, __src, 4 * a5);
    v26 = (v6 & 0xFFFFFFFFFFFFFFFCLL) + 4 * a5;
    v27 = v25;
    if (v5 != a2)
    {
      v28 = 4 * (v6 >> 2);
      do
      {
        *(_DWORD *)&v16[v28 - 4] = *(_DWORD *)&v5[v28 - 4];
        v28 -= 4;
      }
      while (v28);
      v25 = v16;
    }
    v29 = &v16[v26];
    v30 = v12 - (_QWORD)v7;
    if (v30)
      memmove(v29, v7, v30);
    *a1 = v25;
    a1[1] = &v29[v30];
    a1[2] = &v16[4 * v32];
    if (v5)
      operator delete(v5);
    return v27;
  }
  v17 = (uint64_t)(v12 - (_QWORD)v7) >> 2;
  if (v17 >= a5)
  {
    v18 = &__src[4 * a5];
    v20 = a1[1];
LABEL_17:
    v21 = &v7[4 * a5];
    v22 = (int *)&v20[-4 * a5];
    v23 = v20;
    if ((unint64_t)v22 < v12)
    {
      v23 = v20;
      do
      {
        v24 = *v22++;
        *(_DWORD *)v23 = v24;
        v23 += 4;
      }
      while ((unint64_t)v22 < v12);
    }
    a1[1] = v23;
    if (v20 != v21)
      memmove(&v20[-4 * ((v20 - v21) >> 2)], v7, v20 - v21);
    if (v18 != __src)
      memmove(v7, __src, v18 - __src);
    return v7;
  }
  v18 = &__src[4 * v17];
  v19 = a4 - v18;
  if (a4 != v18)
    memmove(a1[1], &__src[4 * v17], a4 - v18);
  v20 = (char *)(v12 + v19);
  a1[1] = (char *)(v12 + v19);
  if ((uint64_t)(v12 - (_QWORD)v7) >= 1)
    goto LABEL_17;
  return v7;
}

uint64_t llvm::CrashRecoveryContext::CrashRecoveryContext(uint64_t this)
{
  *(_DWORD *)(this + 20) = 0;
  *(_BYTE *)(this + 24) = 0;
  *(_QWORD *)this = 0;
  *(_QWORD *)(this + 8) = 0;
  *(_BYTE *)(this + 16) = 0;
  return this;
}

{
  *(_DWORD *)(this + 20) = 0;
  *(_BYTE *)(this + 24) = 0;
  *(_QWORD *)this = 0;
  *(_QWORD *)(this + 8) = 0;
  *(_BYTE *)(this + 16) = 0;
  return this;
}

void llvm::CrashRecoveryContext::~CrashRecoveryContext(llvm::CrashRecoveryContext *this)
{
  uint64_t v2;
  void *v4;
  uint64_t v6;
  uint64_t v8;

  v2 = *((_QWORD *)this + 1);
  if (!atomic_load(qword_1ED825A50))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED825A50, (void *(*)(void))sub_1C6386E98, (void (*)(void *))sub_1C6386EF8);
  v4 = pthread_getspecific(*(_QWORD *)(qword_1ED825A50[0] + 8));
  if (!atomic_load(qword_1ED825A50))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED825A50, (void *(*)(void))sub_1C6386E98, (void (*)(void *))sub_1C6386EF8);
  pthread_setspecific(*(_QWORD *)(qword_1ED825A50[0] + 8), this);
  if (v2)
  {
    do
    {
      v6 = *(_QWORD *)(v2 + 32);
      *(_BYTE *)(v2 + 16) = 1;
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 16))(v2);
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
      v2 = v6;
    }
    while (v6);
  }
  if (!atomic_load(qword_1ED825A50))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED825A50, (void *(*)(void))sub_1C6386E98, (void (*)(void *))sub_1C6386EF8);
  pthread_setspecific(*(_QWORD *)(qword_1ED825A50[0] + 8), v4);
  v8 = *(_QWORD *)this;
  if (*(_QWORD *)this)
  {
    if ((*(_BYTE *)(v8 + 208) & 2) == 0)
    {
      if (!atomic_load((unint64_t *)&qword_1ED825A68))
        llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1ED825A68, (void *(*)(void))sub_1C5DE819C, (void (*)(void *))sub_1C5DE81FC);
      pthread_setspecific(*(_QWORD *)(qword_1ED825A68 + 8), *(const void **)v8);
    }
    if (*(char *)(v8 + 239) < 0)
      operator delete(*(void **)(v8 + 216));
    MEMORY[0x1CAA32FC0](v8, 0x1072C40897D38BCLL);
  }
}

BOOL llvm::CrashRecoveryContext::isRecoveringFromCrash(llvm::CrashRecoveryContext *this)
{
  if (!atomic_load(qword_1ED825A50))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED825A50, (void *(*)(void))sub_1C6386E98, (void (*)(void *))sub_1C6386EF8);
  return pthread_getspecific(*(_QWORD *)(qword_1ED825A50[0] + 8)) != 0;
}

const char *llvm::CrashRecoveryContext::getStacktrace(llvm::CrashRecoveryContext *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  if (!*((_BYTE *)this + 16))
    return "";
  v1 = *(_QWORD *)this;
  if (!*(_QWORD *)this)
    return "";
  v4 = *(_QWORD *)(v1 + 216);
  v2 = v1 + 216;
  v3 = v4;
  if (*(char *)(v2 + 23) >= 0)
    return (const char *)v2;
  else
    return (const char *)v3;
}

uint64_t llvm::CrashRecoveryContext::RunSafely(uint64_t a1, void (*a2)(uint64_t), uint64_t a3)
{
  uint64_t v6;
  char v7;
  char v10;

  if (byte_1ED825A48 == 1)
  {
    v6 = operator new();
    *(_QWORD *)(v6 + 8) = a1;
    v7 = *(_BYTE *)(v6 + 208);
    *(_BYTE *)(v6 + 208) = v7 & 0xFE;
    *(_BYTE *)(v6 + 208) = v7 & 0xF0;
    *(_QWORD *)(v6 + 224) = 0;
    *(_QWORD *)(v6 + 232) = 0;
    *(_QWORD *)(v6 + 216) = 0;
    if (!atomic_load((unint64_t *)&qword_1ED825A68))
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1ED825A68, (void *(*)(void))sub_1C5DE819C, (void (*)(void *))sub_1C5DE81FC);
    *(_QWORD *)v6 = pthread_getspecific(*(_QWORD *)(qword_1ED825A68 + 8));
    if (!atomic_load((unint64_t *)&qword_1ED825A68))
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1ED825A68, (void *(*)(void))sub_1C5DE819C, (void (*)(void *))sub_1C5DE81FC);
    pthread_setspecific(*(_QWORD *)(qword_1ED825A68 + 8), (const void *)v6);
    v10 = *(_BYTE *)(a1 + 16) ? *(_BYTE *)(v6 + 208) | 4 : *(_BYTE *)(v6 + 208);
    *(_QWORD *)a1 = v6;
    *(_BYTE *)(v6 + 208) = v10 | 8;
    if (setjmp((int *)(v6 + 16)))
      return 0;
  }
  a2(a3);
  return 1;
}

__int32 *sub_1C5DE7FB4(uint64_t a1, int a2, llvm::sys *a3)
{
  __int32 *result;
  uint64_t v8;

  if (!atomic_load((unint64_t *)&qword_1ED825A68))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1ED825A68, (void *(*)(void))sub_1C5DE819C, (void (*)(void *))sub_1C5DE81FC);
  result = (__int32 *)pthread_setspecific(*(_QWORD *)(qword_1ED825A68 + 8), *(const void **)a1);
  *(_BYTE *)(a1 + 208) |= 1u;
  v8 = *(_QWORD *)(a1 + 8);
  if (*(_BYTE *)(v8 + 24))
  {
    result = llvm::sys::CleanupOnSignal(a3);
    v8 = *(_QWORD *)(a1 + 8);
  }
  *(_DWORD *)(v8 + 20) = a2;
  if ((*(_BYTE *)(a1 + 208) & 8) != 0)
    longjmp((int *)(a1 + 16), 1);
  return result;
}

BOOL llvm::CrashRecoveryContext::throwIfCrash(llvm::CrashRecoveryContext *this)
{
  int v1;

  v1 = (int)this;
  if ((int)this >= 129)
  {
    llvm::sys::unregisterHandlers(this);
    raise(v1 - 128);
  }
  return v1 > 128;
}

uint64_t sub_1C5DE8094(uint64_t a1)
{
  uint64_t result;

  if (*(_BYTE *)(a1 + 24))
    setpriority(3, 0, 4096);
  result = llvm::CrashRecoveryContext::RunSafely(*(_QWORD *)(a1 + 16), *(void (**)(uint64_t))a1, *(_QWORD *)(a1 + 8));
  *(_BYTE *)(a1 + 25) = result;
  return result;
}

__int32 *sub_1C5DE80D8(int a1)
{
  void *v3;
  uint64_t v4;
  sigset_t v5;
  int v6;
  sigset_t v8;

  if (!atomic_load((unint64_t *)&qword_1ED825A68))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1ED825A68, (void *(*)(void))sub_1C5DE819C, (void (*)(void *))sub_1C5DE81FC);
  v3 = pthread_getspecific(*(_QWORD *)(qword_1ED825A68 + 8));
  if (v3)
  {
    v4 = (uint64_t)v3;
    v5 = 1 << (a1 - 1);
    if (a1 > 32)
      v5 = 0;
    v8 = v5;
    sigprocmask(2, &v8, 0);
    if (a1 == 13)
      v6 = 74;
    else
      v6 = a1 + 128;
    return sub_1C5DE7FB4(v4, v6, (llvm::sys *)a1);
  }
  else
  {
    llvm::CrashRecoveryContext::Disable(0);
    return (__int32 *)raise(a1);
  }
}

_QWORD *sub_1C5DE819C()
{
  _QWORD *v0;

  v0 = (_QWORD *)operator new();
  *v0 = &off_1E81A7D60;
  v0[1] = 0;
  pthread_key_create(v0 + 1, 0);
  *v0 = &off_1E819EA90;
  return v0;
}

uint64_t sub_1C5DE81FC(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *sub_1C5DE8210(_QWORD *a1)
{
  *a1 = &off_1E81A7D60;
  pthread_key_delete(a1[1]);
  return a1;
}

void sub_1C5DE8248(_QWORD *a1)
{
  *a1 = &off_1E81A7D60;
  pthread_key_delete(a1[1]);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C5DE8290(uint64_t a1)
{
  (*(void (**)(_QWORD))a1)(*(_QWORD *)(a1 + 8));
  MEMORY[0x1CAA32FC0](a1, 0xA0C40BD48D6D6);
  return 0;
}

_UNKNOWN **llvm::CSKYAttrs::getCSKYAttributeTags(llvm::CSKYAttrs *this)
{
  return &off_1E819EAC0;
}

void llvm::CSKYAttributeParser::dspVersion(llvm::CSKYAttributeParser *this@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  llvm::ELFAttributeParser::parseStringAttribute(this, "Tag_CSKY_DSP_VERSION", a2, (uint64_t)&off_1EF8EE800, 3uLL, a3);
}

void llvm::CSKYAttributeParser::vdspVersion(llvm::CSKYAttributeParser *this@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  llvm::ELFAttributeParser::parseStringAttribute(this, "Tag_CSKY_VDSP_VERSION", a2, (uint64_t)&off_1EF8EE818, 3uLL, a3);
}

void llvm::CSKYAttributeParser::fpuVersion(llvm::CSKYAttributeParser *this@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  llvm::ELFAttributeParser::parseStringAttribute(this, "Tag_CSKY_FPU_VERSION", a2, (uint64_t)&off_1EF8EE830, 4uLL, a3);
}

void llvm::CSKYAttributeParser::fpuABI(llvm::CSKYAttributeParser *this@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  llvm::ELFAttributeParser::parseStringAttribute(this, "Tag_CSKY_FPU_ABI", a2, (uint64_t)&off_1EF8EE850, 4uLL, a3);
}

void llvm::CSKYAttributeParser::fpuRounding(llvm::CSKYAttributeParser *this@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  llvm::ELFAttributeParser::parseStringAttribute(this, "Tag_CSKY_FPU_ROUNDING", a2, (uint64_t)&off_1EF8EE870, 2uLL, a3);
}

void llvm::CSKYAttributeParser::fpuDenormal(llvm::CSKYAttributeParser *this@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  llvm::ELFAttributeParser::parseStringAttribute(this, "Tag_CSKY_FPU_DENORMAL", a2, (uint64_t)&off_1EF8EE880, 2uLL, a3);
}

void llvm::CSKYAttributeParser::fpuException(llvm::CSKYAttributeParser *this@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  llvm::ELFAttributeParser::parseStringAttribute(this, "Tag_CSKY_FPU_EXCEPTION", a2, (uint64_t)&off_1EF8EE890, 2uLL, a3);
}

void llvm::CSKYAttributeParser::fpuHardFP(llvm::CSKYAttributeParser *this@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t ULEB128;
  int v7;
  const std::string::value_type *v8;
  const std::string::value_type *v9;
  uint64_t size;
  std::string *v11;
  const std::error_category *v12;
  void **v13;
  _QWORD v14[4];
  __int16 v15;
  std::string v16;
  uint64_t v17;
  void *__p[2];
  char v19;
  void **v20;
  uint64_t v21[2];

  ULEB128 = llvm::DataExtractor::getULEB128((uint64_t *)this + 16, (uint64_t *)this + 19, (_QWORD *)this + 20);
  v17 = ULEB128;
  memset(&v16, 0, sizeof(v16));
  if ((ULEB128 & 1) != 0)
  {
    std::string::append(&v16, 0, 0);
    std::string::append(&v16, "Half");
    v7 = 0;
  }
  else
  {
    v7 = 1;
  }
  if ((ULEB128 & 2) != 0)
  {
    if ((ULEB128 & 1) != 0)
      v8 = " ";
    else
      v8 = 0;
    std::string::append(&v16, v8, ULEB128 & 1);
    std::string::append(&v16, "Single");
    v7 = 0;
  }
  if ((ULEB128 & 4) != 0)
  {
    if (v7)
      v9 = 0;
    else
      v9 = " ";
    std::string::append(&v16, v9, v7 == 0);
    std::string::append(&v16, "Double");
  }
  if ((v16.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = *((_BYTE *)&v16.__r_.__value_.__s + 23) & 0x7F;
  else
    size = v16.__r_.__value_.__l.__size_;
  if (size)
  {
    if ((v16.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v11 = &v16;
    else
      v11 = (std::string *)v16.__r_.__value_.__r.__words[0];
    llvm::ELFAttributeParser::printAttribute(this, a2, ULEB128, (uint64_t)v11, size);
    *a3 = 0;
  }
  else
  {
    llvm::ELFAttributeParser::printAttribute(this, a2, ULEB128, (uint64_t)"", 0);
    v12 = std::generic_category();
    v14[0] = "unknown Tag_CSKY_FPU_HARDFP value: ";
    v14[2] = &v17;
    v15 = 3075;
    llvm::Twine::str((llvm::Twine *)v14, __p);
    if (v19 >= 0)
      v13 = __p;
    else
      v13 = (void **)__p[0];
    v21[0] = 22;
    v21[1] = (uint64_t)v12;
    v20 = v13;
    sub_1C5DF1730((_BYTE **)&v20, v21, a3);
    if (v19 < 0)
      operator delete(__p[0]);
  }
  if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v16.__r_.__value_.__l.__data_);
}

uint64_t llvm::CSKYAttributeParser::handler@<X0>(uint64_t this@<X0>, BOOL *a2@<X2>, uint64_t a3@<X1>, _QWORD *a4@<X8>)
{
  uint64_t v6;

  v6 = 0;
  *a2 = 0;
  while (llvm::CSKYAttributeParser::displayRoutines[v6] != a3)
  {
    v6 += 6;
    if (v6 == 78)
      goto LABEL_7;
  }
  this = (*(uint64_t (**)(uint64_t))&llvm::CSKYAttributeParser::displayRoutines[v6 + 2])(this);
  if (*a4)
    return this;
  *a2 = 1;
LABEL_7:
  *a4 = 0;
  return this;
}

void sub_1C5DE85D0(_QWORD *a1)
{
  sub_1C62CD8A8(a1);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t llvm::CSKY::getFPUFeatures(int a1)
{
  BOOL v1;
  uint64_t v2;

  v1 = a1 >= 9 || a1 == 0;
  v2 = !v1;
  if (!v1)
    __asm { BR              X10 }
  return v2;
}

void *llvm::CSKY::getDefaultCPU(void *__s2, size_t __n)
{
  int *i;
  int *v5;

  for (i = &dword_1E819ED90; ; i += 8)
  {
    v5 = i - 4;
    if (*((_QWORD *)i - 1) == __n && (!__n || !memcmp(*((const void **)i - 2), __s2, __n)))
      break;
    if (v5 + 8 == (int *)&off_1E819EF00)
      return 0;
  }
  if (*i)
    return __s2;
  return 0;
}

uint64_t llvm::CSKY::parseArchExt(void *__s1, size_t __n)
{
  uint64_t *i;
  uint64_t *v5;

  for (i = &qword_1E81A0150; ; i += 5)
  {
    v5 = i - 2;
    if (__n == *(i - 1) && (!__n || !memcmp(__s1, (const void *)*(i - 2), __n)))
      break;
    if (v5 + 5 == (uint64_t *)&off_1E81A0938)
      return 0;
  }
  return *i;
}

void *llvm::CSKY::fillValidCPUArchList(void *result)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  char **v4;
  char *v5;
  char *v6;
  unint64_t v7;
  char **v8;

  v1 = (uint64_t)result;
  v2 = (uint64_t)result + 16;
  v3 = 0x1FFFFFFFFFFFFDB8uLL;
  do
  {
    v4 = &(&off_1E819EF00)[v3];
    if (LODWORD((&off_1E819EF00)[v3 + 586]))
    {
      v5 = v4[584];
      v6 = v4[585];
      v7 = *(unsigned int *)(v1 + 8);
      if (v7 >= *(unsigned int *)(v1 + 12))
      {
        result = llvm::SmallVectorBase<unsigned int>::grow_pod(v1, v2, v7 + 1, 16);
        v7 = *(unsigned int *)(v1 + 8);
      }
      v8 = (char **)(*(_QWORD *)v1 + 16 * v7);
      *v8 = v5;
      v8[1] = v6;
      ++*(_DWORD *)(v1 + 8);
    }
    v3 += 4;
  }
  while (v3 * 8);
  return result;
}

char *llvm::CSKY::getFPUName(llvm::CSKY *this)
{
  if (this <= 8)
    return (&off_1E81A0938)[3 * this];
  else
    return 0;
}

uint64_t llvm::CSKY::getFPUVersion(llvm::CSKY *this)
{
  if (this <= 8)
    return *((unsigned int *)&off_1E81A0938 + 6 * this + 5);
  else
    return 0;
}

uint64_t llvm::CSKY::getDefaultExtensions(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unsigned int v3;
  uint64_t v4;
  BOOL v18;
  BOOL v36;
  uint64_t v37;
  BOOL v46;
  unsigned int v53;
  BOOL v56;
  BOOL v68;
  BOOL v69;
  BOOL v78;
  BOOL v79;
  BOOL v80;
  uint64_t v84;
  uint64_t v86;
  BOOL v101;
  BOOL v102;
  BOOL v104;
  BOOL v105;
  uint64_t v120;
  unint64_t v121;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;

  switch(a2)
  {
    case 4:
      if (*(_DWORD *)a1 == 825243749)
        goto LABEL_206;
      v2 = 0x18002600000;
      if (*(_DWORD *)a1 == 842020965 || *(_DWORD *)a1 == 842020979)
        goto LABEL_513;
      v2 = 0x3F8006602000;
      if (*(_DWORD *)a1 == 858798195 || *(_DWORD *)a1 == 858798181)
        goto LABEL_496;
      if (*(_DWORD *)a1 == 892352617)
      {
        v2 = 0x3F80AE602000;
        goto LABEL_513;
      }
      v2 = 0xC7810B672000;
      if (*(_DWORD *)a1 == 925907043 || *(_DWORD *)a1 == 925907058)
        goto LABEL_513;
      if (*(_DWORD *)a1 == 808532067)
        goto LABEL_521;
      if (*(_DWORD *)a1 != 808859747)
        return 0;
      goto LABEL_12;
    case 5:
      if (*(_DWORD *)a1 == 809003875 && *(_BYTE *)(a1 + 4) == 49)
        goto LABEL_206;
      v2 = 0x18002600000;
      if (*(_DWORD *)a1 == 809003875 && *(_BYTE *)(a1 + 4) == 50)
        goto LABEL_513;
      if (*(_DWORD *)a1 == 842020965 && *(_BYTE *)(a1 + 4) == 116)
        goto LABEL_513;
      if (*(_DWORD *)a1 == 842020979 && *(_BYTE *)(a1 + 4) == 116)
        goto LABEL_513;
      if (*(_DWORD *)a1 == 809003875 && *(_BYTE *)(a1 + 4) == 51)
      {
        v2 = 0x78002602000;
        goto LABEL_513;
      }
      v2 = 0x3F8006602000;
      if (*(_DWORD *)a1 == 858798195 && *(_BYTE *)(a1 + 4) == 116)
        goto LABEL_496;
      if (*(_DWORD *)a1 == 858798181 && *(_BYTE *)(a1 + 4) == 116)
        goto LABEL_496;
      if (*(_DWORD *)a1 == 809003875 && *(_BYTE *)(a1 + 4) == 52)
        goto LABEL_513;
      if (*(_DWORD *)a1 == 875575397 && *(_BYTE *)(a1 + 4) == 100)
      {
        v4 = 0;
        goto LABEL_525;
      }
      if (*(_DWORD *)a1 == 875575397 && *(_BYTE *)(a1 + 4) == 102)
        goto LABEL_502;
      v2 = 0x3F80AE602000;
      if (*(_DWORD *)a1 == 809003875 && *(_BYTE *)(a1 + 4) == 53)
        goto LABEL_513;
      if (*(_DWORD *)a1 == 892352617 && *(_BYTE *)(a1 + 4) == 102)
        goto LABEL_502;
      v2 = 0xC7810B672000;
      if (*(_DWORD *)a1 == 809003875 && *(_BYTE *)(a1 + 4) == 55)
        goto LABEL_513;
      v18 = *(_DWORD *)a1 == 925907043 && *(_BYTE *)(a1 + 4) == 102;
      v2 = 0xC7810B672F00;
      if (v18)
        goto LABEL_523;
      if (*(_DWORD *)a1 == 925907058 && *(_BYTE *)(a1 + 4) == 102)
        goto LABEL_523;
      v2 = 0x1C7810B672300;
      if (*(_DWORD *)a1 == 825781091 && *(_BYTE *)(a1 + 4) == 48)
        goto LABEL_531;
      if (*(_DWORD *)a1 == 808532067 && *(_BYTE *)(a1 + 4) == 116)
        goto LABEL_523;
      if (*(_DWORD *)a1 == 808532067 && *(_BYTE *)(a1 + 4) == 118)
      {
        v124 = 0xC7C10B672300;
        goto LABEL_522;
      }
      if (*(_DWORD *)a1 == 909667171 && *(_BYTE *)(a1 + 4) == 48)
      {
        v53 = 258224128;
        goto LABEL_538;
      }
      if (*(_DWORD *)a1 != 808859747 || *(_BYTE *)(a1 + 4) != 118)
        return 0;
      goto LABEL_95;
    case 6:
      if (*(_DWORD *)a1 == 809003875 && *(_WORD *)(a1 + 4) == 29745)
      {
LABEL_206:
        v2 = 0x8000600000;
        goto LABEL_513;
      }
      v2 = 0x18002600000;
      if (*(_DWORD *)a1 == 809003875 && *(_WORD *)(a1 + 4) == 29746)
        goto LABEL_513;
      if (*(_DWORD *)a1 == 809003875 && *(_WORD *)(a1 + 4) == 27186)
      {
        v4 = 0;
        v2 = 0x18002E00000;
        return v4 | v2;
      }
      v2 = 0x78002602000;
      if (*(_DWORD *)a1 == 809003875 && *(_WORD *)(a1 + 4) == 26675)
        goto LABEL_513;
      if (*(_DWORD *)a1 == 809003875 && *(_WORD *)(a1 + 4) == 29747)
        goto LABEL_513;
      if (*(_DWORD *)a1 == 809003875 && *(_WORD *)(a1 + 4) == 26163)
        goto LABEL_502;
      if (*(_DWORD *)a1 == 809003875 && *(_WORD *)(a1 + 4) == 25907)
        goto LABEL_516;
      if (*(_DWORD *)a1 == 809003875 && *(_WORD *)(a1 + 4) == 29491)
        goto LABEL_513;
      v2 = 0x3F8006602000;
      if (*(_DWORD *)a1 == 809003875 && *(_WORD *)(a1 + 4) == 26676)
        goto LABEL_513;
      if (*(_DWORD *)a1 == 809003875 && *(_WORD *)(a1 + 4) == 29748)
        goto LABEL_513;
      if (*(_DWORD *)a1 == 809003875 && *(_WORD *)(a1 + 4) == 26164)
        goto LABEL_502;
      v36 = *(_DWORD *)a1 == 809003875 && *(_WORD *)(a1 + 4) == 25908;
      v37 = 0x3F800E682000;
      if (v36)
        goto LABEL_503;
      if (*(_DWORD *)a1 == 875575397 && *(_WORD *)(a1 + 4) == 29796)
        goto LABEL_503;
      if (*(_DWORD *)a1 == 875575397 && *(_WORD *)(a1 + 4) == 29798)
        goto LABEL_502;
      if (*(_DWORD *)a1 == 875575397 && *(_WORD *)(a1 + 4) == 26212)
        goto LABEL_533;
      v2 = 0x3F80AE602000;
      if (*(_DWORD *)a1 == 809003875 && *(_WORD *)(a1 + 4) == 25909)
        goto LABEL_532;
      if (*(_DWORD *)a1 == 809003875 && *(_WORD *)(a1 + 4) == 26165)
        goto LABEL_502;
      if (*(_DWORD *)a1 == 809003875 && *(_WORD *)(a1 + 4) == 29749)
        goto LABEL_513;
      v2 = 0xC7810B672000;
      if (*(_DWORD *)a1 == 809003875 && *(_WORD *)(a1 + 4) == 25911)
        goto LABEL_496;
      if (*(_DWORD *)a1 == 809003875 && *(_WORD *)(a1 + 4) == 26167)
      {
        v2 = 0xC7810B672F00;
        goto LABEL_523;
      }
      v46 = *(_DWORD *)a1 == 825781091 && *(_WORD *)(a1 + 4) == 25904;
      v2 = 0x1C7810B672000;
      if (v46)
        goto LABEL_513;
      if (*(_DWORD *)a1 == 825781091 && *(_WORD *)(a1 + 4) == 26160)
      {
        v4 = 14;
        v125 = 0xC7810B672300;
        goto LABEL_541;
      }
      if (*(_DWORD *)a1 == 825781091 && *(_WORD *)(a1 + 4) == 29744)
        goto LABEL_513;
      v2 = 0x1C7C10B672300;
      if (*(_DWORD *)a1 == 825781091 && *(_WORD *)(a1 + 4) == 30256)
        goto LABEL_531;
      if (*(_DWORD *)a1 == 808532067 && *(_WORD *)(a1 + 4) == 30324)
        goto LABEL_523;
      if (*(_DWORD *)a1 == 909667171 && *(_WORD *)(a1 + 4) == 26160)
      {
LABEL_12:
        v3 = 258224128;
        goto LABEL_13;
      }
      if (*(_DWORD *)a1 != 909667171 || *(_WORD *)(a1 + 4) != 30256)
        return 0;
      v53 = -815517696;
LABEL_538:
      v2 = (v53 | 0x3FF8100000000) - 4096;
      goto LABEL_513;
    case 7:
      v2 = 0x78002602000;
      if (*(_DWORD *)a1 == 809003875 && *(_DWORD *)(a1 + 3) == 1952985904)
        goto LABEL_513;
      if (*(_DWORD *)a1 == 809003875 && *(_DWORD *)(a1 + 3) == 1751528240)
        goto LABEL_502;
      v56 = *(_DWORD *)a1 == 809003875 && *(_DWORD *)(a1 + 3) == 1751462704;
      v37 = 0x78002672000;
      if (v56)
        goto LABEL_503;
      if (*(_DWORD *)a1 == 809003875 && *(_DWORD *)(a1 + 3) == 1952789296)
        goto LABEL_503;
      if (*(_DWORD *)a1 == 809003875 && *(_DWORD *)(a1 + 3) == 1717908272)
      {
        v2 = 0x78002672500;
LABEL_511:
        v4 = 2;
        return v4 | v2;
      }
      if (*(_DWORD *)a1 == 809003875 && *(_DWORD *)(a1 + 3) == 1952854832)
        goto LABEL_502;
      if (*(_DWORD *)a1 == 809003875 && *(_DWORD *)(a1 + 3) == 829567792)
      {
LABEL_500:
        v4 = 0;
        v120 = 40378368;
LABEL_501:
        v2 = v120 & 0xFFFF0000FFFFFFFFLL | 0x2F8000000000;
        return v4 | v2;
      }
      if (*(_DWORD *)a1 == 809003875 && *(_DWORD *)(a1 + 3) == 846345008)
      {
        v4 = 0;
        v2 = 0x3F8006682000;
        return v4 | v2;
      }
      if (*(_DWORD *)a1 == 809003875 && *(_DWORD *)(a1 + 3) == 863122224)
      {
        v4 = 0;
        v2 = 0x3F8006682000;
        return v4 | v2;
      }
      if (*(_DWORD *)a1 == 809003875 && *(_DWORD *)(a1 + 3) == 1953706800)
        goto LABEL_513;
      if (*(_DWORD *)a1 == 809003875 && *(_DWORD *)(a1 + 3) == 1702048560)
      {
LABEL_516:
        v4 = 0;
        v2 = 0x78002672000;
        return v4 | v2;
      }
      if (*(_DWORD *)a1 == 809003875 && *(_DWORD *)(a1 + 3) == 1718825776)
      {
LABEL_502:
        v2 += 1280;
        goto LABEL_511;
      }
      if (*(_DWORD *)a1 == 809003875 && *(_DWORD *)(a1 + 3) == 1952986160)
      {
        v4 = 1;
        v121 = 106962944;
LABEL_519:
        v2 = v121 & 0xFFFF0000FFFFFFFFLL | 0x3F8000000000;
        return v4 | v2;
      }
      if (*(_DWORD *)a1 == 809003875 && *(_DWORD *)(a1 + 3) == 1751528496)
        goto LABEL_528;
      v68 = *(_DWORD *)a1 == 809003875 && *(_DWORD *)(a1 + 3) == 1751462960;
      v2 = 0x3F800E682000;
      if (v68 || (*(_DWORD *)a1 == 809003875 ? (v69 = *(_DWORD *)(a1 + 3) == 1952789552) : (v69 = 0), v69))
      {
LABEL_496:
        v4 = 0;
        return v4 | v2;
      }
      if (*(_DWORD *)a1 == 809003875 && *(_DWORD *)(a1 + 3) == 1717908528)
        goto LABEL_533;
      if (*(_DWORD *)a1 == 809003875 && *(_DWORD *)(a1 + 3) == 1952855088)
      {
LABEL_528:
        v2 = 0x3F8006602500;
        goto LABEL_511;
      }
      if (*(_DWORD *)a1 == 875575397 && *(_DWORD *)(a1 + 3) == 1952867380)
      {
LABEL_533:
        v2 = 0x3F800E682500;
        goto LABEL_511;
      }
      if (*(_DWORD *)a1 == 809003875 && *(_DWORD *)(a1 + 3) == 1717908784)
      {
LABEL_536:
        v2 = 0x3F80AE682500;
        goto LABEL_511;
      }
      v2 = 0x3F80AE602000;
      if (*(_DWORD *)a1 == 809003875 && *(_DWORD *)(a1 + 3) == 1952789808)
      {
LABEL_532:
        v4 = 0;
        v2 = 0x3F80AE682000;
        return v4 | v2;
      }
      if (*(_DWORD *)a1 == 809003875 && *(_DWORD *)(a1 + 3) == 1952855344)
        goto LABEL_502;
      if (*(_DWORD *)a1 == 809003875 && *(_DWORD *)(a1 + 3) == 1717909296)
      {
        v2 = 0xC7810B672F00;
        goto LABEL_523;
      }
      v2 = 0x1C7810B672300;
      if (*(_DWORD *)a1 == 825781091 && *(_DWORD *)(a1 + 3) == 1952788529)
      {
LABEL_531:
        v2 -= 768;
LABEL_513:
        v4 = 1;
        return v4 | v2;
      }
      v78 = *(_DWORD *)a1 == 825781091 && *(_DWORD *)(a1 + 3) == 1717907505;
      if (v78 || (*(_DWORD *)a1 == 825781091 ? (v79 = *(_DWORD *)(a1 + 3) == 1952854065) : (v79 = 0), v79))
      {
LABEL_523:
        v4 = 14;
        return v4 | v2;
      }
      v80 = *(_DWORD *)a1 == 825781091 && *(_DWORD *)(a1 + 3) == 1986342961;
      v2 = 0x1C7C10B672000;
      if (v80)
        goto LABEL_513;
      if (*(_DWORD *)a1 == 825781091 && *(_DWORD *)(a1 + 3) == 1987326001)
        goto LABEL_513;
      if (*(_DWORD *)a1 == 825781091 && *(_DWORD *)(a1 + 3) == 1986408497)
      {
        v4 = 14;
        v125 = 0xC7C10B672300;
LABEL_541:
        v2 = v125 & 0xFFFFFFFFFFFFLL | 0x1000000000000;
        return v4 | v2;
      }
      if (*(_DWORD *)a1 == 909667171 && *(_DWORD *)(a1 + 3) == 1986408502)
      {
LABEL_95:
        v3 = -815517696;
LABEL_13:
        v2 = v3 | 0x3FF8100000000;
        v4 = 240;
        return v4 | v2;
      }
      v2 = 0;
      v4 = 0;
      v84 = 0;
      if (*(_DWORD *)a1 == 1635151465 && *(_DWORD *)(a1 + 3) == 1684630625)
        return v4 | v2;
      return v84;
    case 8:
      if (*(_QWORD *)a1 == 0x7468653330386B63)
      {
        v4 = 0;
        v2 = 0x78002672000;
        return v4 | v2;
      }
      v2 = 0x78002672500;
      if (*(_QWORD *)a1 == 0x6866653330386B63 || *(_QWORD *)a1 == 0x7466653330386B63)
        goto LABEL_511;
      v86 = 0x2F8002682000;
      switch(*(_QWORD *)a1)
      {
        case 0x3172683330386B63:
          goto LABEL_500;
        case 0x3272683330386B63:
LABEL_504:
          v4 = 0;
          v2 = 0x3F8006682000;
          return v4 | v2;
        case 0x3372683330386B63:
LABEL_507:
          v4 = 0;
          v2 = 0x3F8006682000;
          return v4 | v2;
        case 0x3172743330386B63:
          goto LABEL_500;
      }
      v37 = 0x3F8006682000;
      switch(*(_QWORD *)a1)
      {
        case 0x3272743330386B63:
        case 0x3372743330386B63:
LABEL_503:
          v4 = 0;
          v2 = v37;
          return v4 | v2;
        case 0x3172663330386B63:
          goto LABEL_505;
        case 0x3272663330386B63:
        case 0x3372663330386B63:
          goto LABEL_508;
        case 0x3172653330386B63:
LABEL_497:
          v4 = 0;
          v120 = 175054848;
          goto LABEL_501;
        case 0x3272653330386B63:
        case 0x3372653330386B63:
LABEL_517:
          v4 = 0;
          v123 = 0x2000;
          goto LABEL_518;
        case 0x6665733330386B63:
          goto LABEL_511;
        case 0x7468653430386B63:
          v4 = 0;
LABEL_525:
          v2 = 0x3F800E682000;
          return v4 | v2;
      }
      v2 = 0x3F800E682500;
      switch(*(_QWORD *)a1)
      {
        case 0x6866653430386B63:
        case 0x7466653430386B63:
          goto LABEL_511;
        case 0x7466653530386B63:
          goto LABEL_536;
        case 0x7466653031386B63:
LABEL_521:
          v124 = 0xC7810B672300;
LABEL_522:
          v2 = v124 & 0xFFFFFFFFFFFFLL | 0x1000000000000;
          goto LABEL_523;
      }
      v2 = 0x1C7C10B672300;
      if (*(_QWORD *)a1 == 0x7674653031386B63)
        goto LABEL_531;
      if (*(_QWORD *)a1 == 0x7666653031386B63
        || *(_QWORD *)a1 == 0x7674663031386B63
        || *(_QWORD *)a1 == 0x7674666530313863)
      {
        goto LABEL_523;
      }
      return 0;
    case 9:
      v2 = 0x78002672500;
      if (*(_QWORD *)a1 == 0x6866653330386B63 && *(_BYTE *)(a1 + 8) == 116)
        goto LABEL_511;
      v86 = 0x2F8002682000;
      if (*(_QWORD *)a1 == 0x7274683330386B63 && *(_BYTE *)(a1 + 8) == 49)
        goto LABEL_500;
      if (*(_QWORD *)a1 == 0x7274683330386B63 && *(_BYTE *)(a1 + 8) == 50)
        goto LABEL_504;
      if (*(_QWORD *)a1 == 0x7274683330386B63 && *(_BYTE *)(a1 + 8) == 51)
        goto LABEL_507;
      if (*(_QWORD *)a1 == 0x7268663330386B63 && *(_BYTE *)(a1 + 8) == 49)
        goto LABEL_505;
      if (*(_QWORD *)a1 == 0x7268663330386B63 && *(_BYTE *)(a1 + 8) == 50)
        goto LABEL_508;
      if (*(_QWORD *)a1 == 0x7268663330386B63 && *(_BYTE *)(a1 + 8) == 51)
        goto LABEL_508;
      if (*(_QWORD *)a1 == 0x7268653330386B63 && *(_BYTE *)(a1 + 8) == 49)
        goto LABEL_497;
      if (*(_QWORD *)a1 == 0x7268653330386B63 && *(_BYTE *)(a1 + 8) == 50)
        goto LABEL_517;
      if (*(_QWORD *)a1 == 0x7268653330386B63 && *(_BYTE *)(a1 + 8) == 51)
        goto LABEL_517;
      if (*(_QWORD *)a1 == 0x7274653330386B63 && *(_BYTE *)(a1 + 8) == 49)
        goto LABEL_497;
      if (*(_QWORD *)a1 == 0x7274653330386B63 && *(_BYTE *)(a1 + 8) == 50)
        goto LABEL_517;
      if (*(_QWORD *)a1 == 0x7274653330386B63 && *(_BYTE *)(a1 + 8) == 51)
        goto LABEL_517;
      if (*(_QWORD *)a1 == 0x7266653330386B63 && *(_BYTE *)(a1 + 8) == 49)
      {
        v2 = 0x2F800A6F2500;
        goto LABEL_511;
      }
      v101 = *(_QWORD *)a1 == 0x7266653330386B63 && *(_BYTE *)(a1 + 8) == 50;
      if (v101 || (*(_QWORD *)a1 == 0x7266653330386B63 ? (v102 = *(_BYTE *)(a1 + 8) == 51) : (v102 = 0), v102))
      {
        v4 = 2;
        v123 = 9472;
LABEL_518:
        v121 = v123 & 0xFFFFFFFF0000FFFFLL | 0xE6F0000;
        goto LABEL_519;
      }
      if (*(_QWORD *)a1 == 0x7274663330386B63 && *(_BYTE *)(a1 + 8) == 49)
      {
LABEL_505:
        v2 = v86 + 1280;
        goto LABEL_511;
      }
      v104 = *(_QWORD *)a1 == 0x7274663330386B63 && *(_BYTE *)(a1 + 8) == 50;
      if (v104 || (*(_QWORD *)a1 == 0x7274663330386B63 ? (v105 = *(_BYTE *)(a1 + 8) == 51) : (v105 = 0), v105))
      {
LABEL_508:
        v4 = 2;
        v121 = 107488512;
        goto LABEL_519;
      }
      if (*(_QWORD *)a1 == 0x6665733330386B63 && *(_BYTE *)(a1 + 8) == 116)
        goto LABEL_511;
      if (*(_QWORD *)a1 == 0x6866653430386B63 && *(_BYTE *)(a1 + 8) == 116)
        goto LABEL_533;
      return 0;
    case 10:
      v86 = 0x2F800A6F2000;
      if (*(_QWORD *)a1 == 0x7468653330386B63 && *(_WORD *)(a1 + 8) == 12658)
        goto LABEL_497;
      v2 = 0x3F800E6F2000;
      if (*(_QWORD *)a1 == 0x7468653330386B63 && *(_WORD *)(a1 + 8) == 12914)
        goto LABEL_496;
      if (*(_QWORD *)a1 == 0x7468653330386B63 && *(_WORD *)(a1 + 8) == 13170)
        goto LABEL_496;
      if (*(_QWORD *)a1 == 0x6866653330386B63 && *(_WORD *)(a1 + 8) == 12658)
        goto LABEL_505;
      v2 = 0x3F800E6F2500;
      if (*(_QWORD *)a1 == 0x6866653330386B63 && *(_WORD *)(a1 + 8) == 12914)
        goto LABEL_511;
      if (*(_QWORD *)a1 == 0x6866653330386B63 && *(_WORD *)(a1 + 8) == 13170)
        goto LABEL_511;
      if (*(_QWORD *)a1 == 0x7466653330386B63 && *(_WORD *)(a1 + 8) == 12658)
        goto LABEL_505;
      if ((*(_QWORD *)a1 != 0x7466653330386B63 || *(_WORD *)(a1 + 8) != 12914)
        && (*(_QWORD *)a1 != 0x7466653330386B63 || *(_WORD *)(a1 + 8) != 13170))
      {
        return 0;
      }
      goto LABEL_511;
    case 11:
      if (*(_QWORD *)a1 == 0x6866653330386B63 && *(_QWORD *)(a1 + 3) == 0x3172746866653330)
      {
        v2 = 0x2F800A6F2500;
      }
      else
      {
        v2 = 0x3F800E6F2500;
        if ((*(_QWORD *)a1 != 0x6866653330386B63 || *(_QWORD *)(a1 + 3) != 0x3272746866653330)
          && (*(_QWORD *)a1 != 0x6866653330386B63 || *(_QWORD *)(a1 + 3) != 0x3372746866653330))
        {
          return 0;
        }
      }
      goto LABEL_511;
    default:
      return 0;
  }
}

char *llvm::CSKY::getArchExtName(llvm::CSKY *this)
{
  uint64_t v1;

  v1 = 0;
  while ((&off_1E81A0140)[v1 + 2] != (char *)this)
  {
    v1 += 5;
    if (v1 == 255)
      return 0;
  }
  return (&off_1E81A0140)[v1];
}

char *llvm::CSKY::getArchExtFeature(char *__s1, size_t __n)
{
  size_t v2;
  char *v3;
  _BOOL4 v4;
  int v5;
  uint64_t v6;
  char **v7;
  char *v8;
  char **v9;
  uint64_t v10;

  v2 = __n;
  v3 = __s1;
  if (__n >= 2)
  {
    v5 = *(unsigned __int16 *)__s1;
    v4 = v5 == 28526;
    if (v5 == 28526)
    {
      v2 = __n - 2;
      v3 = __s1 + 2;
    }
  }
  else
  {
    v4 = 0;
  }
  v6 = 0;
  while (1)
  {
    v7 = &(&off_1E81A0140)[v6];
    if ((&off_1E81A0140)[v6 + 3])
    {
      if ((char *)v2 == v7[1] && (!v2 || !memcmp(v3, *v7, v2)))
        break;
    }
    v6 += 5;
    if (v6 == 255)
      return 0;
  }
  v9 = &(&off_1E81A0140)[v6];
  v10 = 3;
  if (v4)
    v10 = 4;
  v8 = v9[v10];
  if (v8)
    strlen(v9[v10]);
  return v8;
}

BOOL llvm::CSKY::getExtensionFeatures(uint64_t a1, char ***a2)
{
  char **v4;
  char *v5;
  size_t v6;
  size_t v7;
  unint64_t v8;
  char **v9;
  char **v10;
  char **v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char **v17;
  char **v18;

  if (a1)
  {
    v4 = &off_1E81A0140;
    do
    {
      if (((unint64_t)v4[2] & ~a1) == 0)
      {
        v5 = v4[3];
        if (v5)
        {
          v6 = strlen(v4[3]);
          v7 = v6;
          v9 = a2[1];
          v8 = (unint64_t)a2[2];
          if ((unint64_t)v9 >= v8)
          {
            v11 = *a2;
            v12 = ((char *)v9 - (char *)*a2) >> 4;
            v13 = v12 + 1;
            if ((unint64_t)(v12 + 1) >> 60)
              abort();
            v14 = v8 - (_QWORD)v11;
            if (v14 >> 3 > v13)
              v13 = v14 >> 3;
            if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0)
              v15 = 0xFFFFFFFFFFFFFFFLL;
            else
              v15 = v13;
            if (v15)
            {
              if (v15 >> 60)
                sub_1C4764EE4();
              v16 = (char *)operator new(16 * v15);
            }
            else
            {
              v16 = 0;
            }
            v17 = (char **)&v16[16 * v12];
            *v17 = v5;
            v17[1] = (char *)v7;
            v18 = v17;
            if (v9 != v11)
            {
              do
              {
                *((_OWORD *)v18 - 1) = *((_OWORD *)v9 - 1);
                v18 -= 2;
                v9 -= 2;
              }
              while (v9 != v11);
              v9 = *a2;
            }
            v10 = v17 + 2;
            *a2 = v18;
            a2[1] = v17 + 2;
            a2[2] = (char **)&v16[16 * v15];
            if (v9)
              operator delete(v9);
          }
          else
          {
            *v9 = v5;
            v9[1] = (char *)v6;
            v10 = v9 + 2;
          }
          a2[1] = v10;
        }
      }
      v4 += 5;
    }
    while (v4 != &off_1E81A0938);
  }
  return a1 != 0;
}

BOOL llvm::DataExtractor::prepareRead(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v7;
  _BOOL8 v8;
  unint64_t v9;
  const std::error_category *v10;
  unint64_t v11;
  void **v12;
  uint64_t v13;
  uint64_t v14;
  void **v15;
  void (**v17)(llvm::raw_ostream *__hidden);
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  uint64_t v23;
  int v24;
  void **v25;
  void *__p[2];
  uint64_t v27;
  uint64_t (**v28)(llvm::format_object_base *__hidden);
  const char *v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;

  v7 = a3 + a2;
  if (__CFADD__(a3, a2))
  {
    v8 = 0;
    if (!a4)
      return v8;
  }
  else
  {
    v8 = *(_QWORD *)(a1 + 8) > (unint64_t)(v7 - 1);
    if (!a4)
      return v8;
  }
  if (!v8)
  {
    v9 = *(_QWORD *)(a1 + 8);
    v10 = std::generic_category();
    v11 = *(_QWORD *)(a1 + 8);
    __p[0] = 0;
    __p[1] = 0;
    v27 = 0;
    v18 = 0;
    v22 = 0;
    v23 = 0;
    v17 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
    v25 = __p;
    v24 = 0;
    v20 = 0;
    v21 = 0;
    v19 = 0;
    if (v9 >= a2)
    {
      v28 = &off_1E81A0A20;
      v29 = "unexpected end of data at offset 0x%zx while reading [0x%llx, 0x%llx)";
      v30 = v11;
      v31 = a2;
      v32 = v7;
      llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v17, (uint64_t)&v28);
      v15 = v25;
      v13 = operator new();
      LOWORD(v32) = 260;
      v28 = (uint64_t (**)(llvm::format_object_base *__hidden))v15;
      *(_QWORD *)v13 = off_1E81A0C88;
      llvm::Twine::str((llvm::Twine *)&v28, (_QWORD *)(v13 + 8));
      v14 = 92;
    }
    else
    {
      v28 = &off_1E81A0A40;
      v29 = "offset 0x%llx is beyond the end of data at 0x%zx";
      v30 = a2;
      v31 = v11;
      llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v17, (uint64_t)&v28);
      v12 = v25;
      v13 = operator new();
      LOWORD(v32) = 260;
      v28 = (uint64_t (**)(llvm::format_object_base *__hidden))v12;
      *(_QWORD *)v13 = off_1E81A0C88;
      llvm::Twine::str((llvm::Twine *)&v28, (_QWORD *)(v13 + 8));
      v14 = 22;
    }
    *(_QWORD *)(v13 + 32) = v14;
    *(_QWORD *)(v13 + 40) = v10;
    *(_BYTE *)(v13 + 48) = 1;
    v17 = off_1E81A6E70;
    if (v24 == 1 && v19)
      MEMORY[0x1CAA32F9C](v19, 0x1000C8077774924);
    if (SHIBYTE(v27) < 0)
      operator delete(__p[0]);
    *a4 = v13;
  }
  return v8;
}

uint64_t sub_1C5DEAEAC(_QWORD *a1, unint64_t *a2, uint64_t *a3)
{
  unint64_t v6;
  uint64_t result;

  if (a3 && *a3)
    return 0;
  v6 = *a2;
  result = llvm::DataExtractor::prepareRead((uint64_t)a1, *a2, 1, a3);
  if ((_DWORD)result)
  {
    result = *(unsigned __int8 *)(*a1 + v6);
    ++*a2;
  }
  if (a3)
  {
    if (!*a3)
      *a3 = 0;
  }
  return result;
}

_BYTE *llvm::DataExtractor::getU8(llvm::DataExtractor *this, unint64_t *a2, unsigned __int8 *a3, unsigned int a4)
{
  return sub_1C6387118(this, a2, a3, a4, 0);
}

unsigned __int16 *llvm::DataExtractor::getU16(llvm::DataExtractor *this, unint64_t *a2, unsigned __int16 *a3, unsigned int a4)
{
  unint64_t v4;
  unsigned __int16 *v6;
  uint64_t v8;
  unsigned __int16 *v9;

  v4 = *a2;
  if (__CFADD__(*a2, 2 * a4) || *((_QWORD *)this + 1) <= *a2 + 2 * a4 - 1)
    return 0;
  v6 = a3;
  if (a4)
  {
    v8 = 2 * a4;
    v9 = a3;
    do
    {
      *v9++ = sub_1C63871E8((uint64_t)this, a2, 0);
      v4 += 2;
      v8 -= 2;
    }
    while (v8);
  }
  *a2 = v4;
  return v6;
}

unsigned int *llvm::DataExtractor::getU32(llvm::DataExtractor *this, unint64_t *a2, unsigned int *a3, unsigned int a4)
{
  unint64_t v4;
  unsigned int *v6;
  uint64_t v8;
  unsigned int *v9;

  v4 = *a2;
  if (__CFADD__(*a2, 4 * a4) || *((_QWORD *)this + 1) <= *a2 + 4 * a4 - 1)
    return 0;
  v6 = a3;
  if (a4)
  {
    v8 = 4 * a4;
    v9 = a3;
    do
    {
      *v9++ = sub_1C6387364((uint64_t)this, a2, 0);
      v4 += 4;
      v8 -= 4;
    }
    while (v8);
  }
  *a2 = v4;
  return v6;
}

unint64_t *llvm::DataExtractor::getU64(llvm::DataExtractor *this, unint64_t *a2, unint64_t *a3, unsigned int a4)
{
  unint64_t v4;
  unint64_t *v6;
  uint64_t v8;
  unint64_t *v9;

  v4 = *a2;
  if (__CFADD__(*a2, 8 * a4) || *((_QWORD *)this + 1) <= *a2 + 8 * a4 - 1)
    return 0;
  v6 = a3;
  if (a4)
  {
    v8 = 8 * a4;
    v9 = a3;
    do
    {
      *v9++ = sub_1C63873F8((uint64_t)this, a2, 0);
      v4 += 8;
      v8 -= 8;
    }
    while (v8);
  }
  *a2 = v4;
  return v6;
}

uint64_t llvm::DataExtractor::getSigned(llvm::DataExtractor *this, unint64_t *a2, int a3)
{
  return ((uint64_t (*)(llvm::DataExtractor *, unint64_t *))((char *)sub_1C5DEB0F8
                                                                            + 4 * byte_1C866F8CC[a3 - 1]))(this, a2);
}

uint64_t sub_1C5DEB0F8(_QWORD *a1, unint64_t *a2)
{
  unint64_t v2;
  uint64_t result;

  v2 = *a2;
  if (*a2 == -1 || a1[1] <= v2)
    return 0;
  result = *(char *)(*a1 + v2);
  *a2 = v2 + 1;
  return result;
}

void *llvm::DataExtractor::getCStrRef(uint64_t *a1, unint64_t *a2, uint64_t *a3)
{
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  void *v8;
  char *v9;
  char *v10;
  BOOL v11;
  const std::error_category *v12;
  void **v13;
  uint64_t v14;
  void (**v16)(llvm::raw_ostream *__hidden);
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char v21;
  uint64_t v22;
  int v23;
  void **v24;
  void *__p[2];
  uint64_t v26;
  _QWORD v27[4];
  __int16 v28;

  if (a3 && *a3)
    return 0;
  v5 = *a2;
  v6 = a1[1];
  if (v6 <= *a2
    || ((v7 = *a1, v8 = (void *)(*a1 + v5), v9 = (char *)memchr(v8, 0, v6 - *a2), v10 = &v9[-v7], v9)
      ? (v11 = v10 + 1 == 0)
      : (v11 = 1),
        v11))
  {
    if (a3)
    {
      v12 = std::generic_category();
      __p[0] = 0;
      __p[1] = 0;
      v26 = 0;
      v17 = 0;
      v21 = 0;
      v22 = 0;
      v16 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
      v24 = __p;
      v23 = 0;
      v19 = 0;
      v20 = 0;
      v18 = 0;
      v27[0] = &unk_1E8133270;
      v27[1] = "no null terminated string at offset 0x%llx";
      v27[2] = v5;
      llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v16, (uint64_t)v27);
      v13 = v24;
      v14 = operator new();
      v28 = 260;
      v27[0] = v13;
      *(_QWORD *)v14 = off_1E81A0C88;
      llvm::Twine::str((llvm::Twine *)v27, (_QWORD *)(v14 + 8));
      *(_QWORD *)(v14 + 32) = 92;
      *(_QWORD *)(v14 + 40) = v12;
      *(_BYTE *)(v14 + 48) = 1;
      v16 = off_1E81A6E70;
      if (v23 == 1 && v18)
        MEMORY[0x1CAA32F9C](v18, 0x1000C8077774924);
      if (SHIBYTE(v26) < 0)
        operator delete(__p[0]);
      v8 = 0;
      goto LABEL_14;
    }
    return 0;
  }
  *a2 = (unint64_t)(v10 + 1);
  if (a3 && !*a3)
  {
    v14 = 0;
LABEL_14:
    *a3 = v14;
  }
  return v8;
}

uint64_t llvm::DataExtractor::getFixedLengthString(_QWORD *a1, unint64_t *a2, unint64_t a3, unsigned __int8 *a4, uint64_t a5)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v11[2];

  v5 = *a2;
  v6 = *a2 + a3;
  if (__CFADD__(*a2, a3) || (v7 = a1[1], v7 <= v6 - 1))
  {
    v9 = 0;
    v8 = 0;
  }
  else
  {
    if (v7 < v5)
      v5 = a1[1];
    v8 = *a1 + v5;
    v9 = v7 - v5;
    if (v9 >= a3)
      v9 = a3;
    *a2 = v6;
  }
  v11[0] = v8;
  v11[1] = v9;
  return sub_1C534E9D8(v11, a4, a5);
}

unint64_t llvm::DataExtractor::getBytes(_QWORD *a1, unint64_t *a2, uint64_t a3, uint64_t *a4)
{
  unint64_t result;
  unint64_t v9;

  if (a4 && *a4)
    return 0;
  if (!llvm::DataExtractor::prepareRead((uint64_t)a1, *a2, a3, a4))
  {
    result = 0;
    if (!a4)
      return result;
    goto LABEL_11;
  }
  if (a1[1] >= *a2)
    v9 = *a2;
  else
    v9 = a1[1];
  result = *a1 + v9;
  *a2 += a3;
  if (a4)
  {
LABEL_11:
    if (!*a4)
      *a4 = 0;
  }
  return result;
}

uint64_t llvm::DataExtractor::getULEB128(uint64_t *a1, uint64_t *a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  char v11;
  uint64_t v12;
  const std::error_category *v13;
  uint64_t v14;
  uint64_t *v15;
  _QWORD *v16;
  uint64_t v17;
  const char *v18;

  v4 = *a1;
  v3 = a1[1];
  if (a3 && *a3)
    return 0;
  v5 = 0;
  result = 0;
  v7 = 0;
  v8 = v4 + *a2;
  v9 = v3 - *a2;
  v10 = "malformed uleb128, extends past end";
  while (v9 != v5)
  {
    v11 = *(_BYTE *)(v8 + v5);
    v12 = v11 & 0x7F;
    if (v7 >= 0x40 && (v11 & 0x7F) != 0 || (unint64_t)(v12 << v7) >> v7 != v12)
    {
      v15 = a2;
      v16 = a3;
      v10 = "uleb128 too big for uint64";
      goto LABEL_11;
    }
    result += v12 << v7;
    v7 += 7;
    ++v5;
    if ((v11 & 0x80) == 0)
    {
      *a2 += v5;
      if (!a3)
        return result;
      v16 = a3;
      v14 = *a3;
      goto LABEL_13;
    }
  }
  v15 = a2;
  v16 = a3;
LABEL_11:
  v18 = v10;
  if (!v16)
    return 0;
  v13 = std::generic_category();
  sub_1C5DEB71C(92, (uint64_t)v13, (uint64_t)"unable to decode LEB128 at offset 0x%8.8llx: %s", v15, (uint64_t *)&v18, &v17);
  result = 0;
  v14 = v17;
  *v16 = v17;
LABEL_13:
  if (!v14)
    *v16 = 0;
  return result;
}

uint64_t llvm::DataExtractor::getSLEB128(_QWORD *a1, uint64_t *a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  const char *v6;
  char v7;
  uint64_t v8;
  BOOL v9;
  uint64_t v10;
  uint64_t result;
  const std::error_category *v13;
  uint64_t v14;
  uint64_t *v15;
  _QWORD *v16;
  uint64_t v17;
  const char *v18;

  if (a3 && *a3)
    return 0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = "malformed sleb128, extends past end";
  do
  {
    if (a1[1] - *a2 == v3)
    {
      v15 = a2;
      v16 = a3;
      goto LABEL_24;
    }
    v7 = *(_BYTE *)(*a1 + *a2 + v3);
    v8 = v7 & 0x7F;
    if (v5 >= 0x40)
    {
      if (((v4 >> 63) & 0x7F) != v8)
        goto LABEL_23;
    }
    else if (v5 == 63 && (_DWORD)v8 != 127 && (_DWORD)v8 != 0)
    {
LABEL_23:
      v15 = a2;
      v16 = a3;
      v6 = "sleb128 too big for int64";
LABEL_24:
      v18 = v6;
      if (!v16)
        return 0;
      v13 = std::generic_category();
      sub_1C5DEB71C(92, (uint64_t)v13, (uint64_t)"unable to decode LEB128 at offset 0x%8.8llx: %s", v15, (uint64_t *)&v18, &v17);
      result = 0;
      v14 = v17;
      *v16 = v17;
LABEL_26:
      if (!v14)
        *v16 = 0;
      return result;
    }
    v4 |= v8 << v5;
    v5 += 7;
    ++v3;
  }
  while (v7 < 0);
  v9 = (v7 & 0x40) == 0 || v5 > 0x3F;
  v10 = -1 << v5;
  if (v9)
    v10 = 0;
  result = v4 | v10;
  *a2 += v3;
  if (a3)
  {
    v16 = a3;
    v14 = *a3;
    goto LABEL_26;
  }
  return result;
}

void sub_1C5DEB71C(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X3>, uint64_t *a5@<X4>, uint64_t *a6@<X8>)
{
  uint64_t v9;
  uint64_t v10;
  void **v11;
  uint64_t v12;
  void (**v13)(llvm::raw_ostream *__hidden);
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  uint64_t v19;
  int v20;
  void **v21;
  void *__p[2];
  uint64_t v23;
  _QWORD v24[4];
  __int16 v25;

  __p[0] = 0;
  __p[1] = 0;
  v23 = 0;
  v14 = 0;
  v18 = 0;
  v19 = 0;
  v13 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
  v21 = __p;
  v20 = 0;
  v16 = 0;
  v17 = 0;
  v15 = 0;
  v9 = *a4;
  v10 = *a5;
  v24[0] = &unk_1E8169880;
  v24[1] = a3;
  v24[2] = v9;
  v24[3] = v10;
  llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v13, (uint64_t)v24);
  v11 = v21;
  v12 = operator new();
  v25 = 260;
  v24[0] = v11;
  *(_QWORD *)v12 = off_1E81A0C88;
  llvm::Twine::str((llvm::Twine *)v24, (_QWORD *)(v12 + 8));
  *(_QWORD *)(v12 + 32) = a1;
  *(_QWORD *)(v12 + 40) = a2;
  *(_BYTE *)(v12 + 48) = 1;
  *a6 = v12;
  v13 = off_1E81A6E70;
  if (v20 == 1 && v15)
    MEMORY[0x1CAA32F9C](v15, 0x1000C8077774924);
  if (SHIBYTE(v23) < 0)
    operator delete(__p[0]);
}

uint64_t llvm::isCurrentDebugType(llvm *this, const char *a2)
{
  const void **v5;
  const void **v6;
  size_t v7;
  size_t v8;
  size_t v9;
  const void *v10;
  size_t v11;

  if (!atomic_load(qword_1EF8F5800))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EF8F5800, (void *(*)(void))sub_1C5DEBCE0, (void (*)(void *))sub_1C5DEBD10);
  if (*(_QWORD *)qword_1EF8F5800[0] != *(_QWORD *)(qword_1EF8F5800[0] + 8))
  {
    if (!atomic_load(qword_1EF8F5800))
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EF8F5800, (void *(*)(void))sub_1C5DEBCE0, (void (*)(void *))sub_1C5DEBD10);
    v5 = *(const void ***)qword_1EF8F5800[0];
    v6 = *(const void ***)(qword_1EF8F5800[0] + 8);
    if (*(const void ***)qword_1EF8F5800[0] == v6)
      return 0;
    v7 = strlen((const char *)this);
    while (1)
    {
      v8 = *((unsigned __int8 *)v5 + 23);
      v9 = (v8 & 0x80u) == 0 ? v8 & 0x7F : (size_t)v5[1];
      if (v7 == v9)
      {
        if ((v8 & 0x80) != 0)
        {
          if (v7 == -1)
LABEL_27:
            abort();
          v10 = *v5;
          v8 = (size_t)v5[1];
        }
        else
        {
          v10 = v5;
          if (v7 == -1)
            goto LABEL_27;
        }
        v11 = v8 >= v7 ? v7 : v8;
        if (!memcmp(v10, this, v11) && v8 == v7)
          break;
      }
      v5 += 3;
      if (v5 == v6)
        return 0;
    }
  }
  return 1;
}

void llvm::setCurrentDebugType(llvm *this, const char *a2)
{
  llvm *v2;

  v2 = this;
  llvm::setCurrentDebugTypes((llvm *)&v2, (const char **)1);
}

void llvm::setCurrentDebugTypes(llvm *this, const char **a2)
{
  int v2;
  llvm::ManagedStaticBase *v4;
  _QWORD *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t i;
  uint64_t j;
  char **v12;
  const char *v13;
  size_t v14;
  void *v15;
  void *v16;
  uint64_t v17;
  llvm::ManagedStaticBase *v18;
  _QWORD *v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  char *v31;
  char *v32;
  __int128 v33;
  char *v34;
  char v35;
  char *v36;
  char *v37;
  void *__p[2];
  unint64_t v39;
  _QWORD v40[5];

  v2 = (int)a2;
  v4 = (llvm::ManagedStaticBase *)qword_1EF8F5800;
  if (!atomic_load(qword_1EF8F5800))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EF8F5800, (void *(*)(void))sub_1C5DEBCE0, (void (*)(void *))sub_1C5DEBD10);
  v6 = &unk_1EF8F5000;
  v7 = qword_1EF8F5800[0];
  v8 = *(_QWORD *)qword_1EF8F5800[0];
  for (i = *(_QWORD *)(qword_1EF8F5800[0] + 8); i != v8; i -= 24)
  {
    if (*(char *)(i - 1) < 0)
      operator delete(*(void **)(i - 24));
  }
  *(_QWORD *)(v7 + 8) = v8;
  if (v2)
  {
    for (j = 0; j != v2; ++j)
    {
      if (!atomic_load((unint64_t *)v4))
        llvm::ManagedStaticBase::RegisterManagedStatic(v4, (void *(*)(void))sub_1C5DEBCE0, (void (*)(void *))sub_1C5DEBD10);
      v12 = (char **)v6[256];
      v13 = (const char *)*((_QWORD *)this + j);
      v14 = strlen(v13);
      if (v14 >= 0x7FFFFFFFFFFFFFF8)
LABEL_41:
        abort();
      v15 = (void *)v14;
      if (v14 >= 0x17)
      {
        v17 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v14 | 7) != 0x17)
          v17 = v14 | 7;
        v18 = v4;
        v19 = v6;
        v20 = v17 + 1;
        v16 = operator new(v17 + 1);
        v21 = v20 | 0x8000000000000000;
        v6 = v19;
        v4 = v18;
        __p[1] = v15;
        v39 = v21;
        __p[0] = v16;
      }
      else
      {
        HIBYTE(v39) = v14;
        v16 = __p;
        if (!v14)
          goto LABEL_20;
      }
      memmove(v16, v13, (size_t)v15);
LABEL_20:
      *((_BYTE *)v15 + (_QWORD)v16) = 0;
      v22 = (unint64_t)v12[2];
      v23 = (unint64_t)v12[1];
      if (v23 >= v22)
      {
        v24 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v23 - (_QWORD)*v12) >> 3);
        v25 = v24 + 1;
        if (v24 + 1 > 0xAAAAAAAAAAAAAAALL)
          goto LABEL_41;
        v26 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v22 - (_QWORD)*v12) >> 3);
        if (2 * v26 > v25)
          v25 = 2 * v26;
        if (v26 >= 0x555555555555555)
          v27 = 0xAAAAAAAAAAAAAAALL;
        else
          v27 = v25;
        v40[4] = v12 + 2;
        if (v27)
        {
          if (v27 > 0xAAAAAAAAAAAAAAALL)
            sub_1C4764EE4();
          v28 = (char *)operator new(24 * v27);
        }
        else
        {
          v28 = 0;
        }
        v29 = &v28[24 * v24];
        *((_QWORD *)v29 + 2) = v39;
        *(_OWORD *)v29 = *(_OWORD *)__p;
        __p[1] = 0;
        v39 = 0;
        __p[0] = 0;
        v31 = *v12;
        v30 = v12[1];
        if (v30 == *v12)
        {
          v35 = 0;
          v34 = v12[1];
          v32 = v29;
        }
        else
        {
          v32 = &v28[24 * v24];
          do
          {
            v33 = *(_OWORD *)(v30 - 24);
            *((_QWORD *)v32 - 1) = *((_QWORD *)v30 - 1);
            *(_OWORD *)(v32 - 24) = v33;
            v32 -= 24;
            *((_QWORD *)v30 - 2) = 0;
            *((_QWORD *)v30 - 1) = 0;
            *((_QWORD *)v30 - 3) = 0;
            v30 -= 24;
          }
          while (v30 != v31);
          v34 = *v12;
          v30 = v12[1];
          v35 = HIBYTE(v39);
        }
        v36 = v29 + 24;
        *v12 = v32;
        v40[0] = v34;
        v40[1] = v34;
        v12[1] = v29 + 24;
        v40[2] = v30;
        v37 = v12[2];
        v12[2] = &v28[24 * v27];
        v40[3] = v37;
        sub_1C4D868F0((uint64_t)v40);
        v12[1] = v36;
        if (v35 < 0)
          operator delete(__p[0]);
      }
      else
      {
        *(_OWORD *)v23 = *(_OWORD *)__p;
        *(_QWORD *)(v23 + 16) = v39;
        v12[1] = (char *)(v23 + 24);
      }
    }
  }
}

void sub_1C5DEBC80()
{
  unsigned __int8 v0;

  v0 = atomic_load((unsigned __int8 *)&qword_1ED825AF8);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1ED825AF8))
    {
      qword_1EF8F72C0 = 0;
      __cxa_atexit((void (*)(void *))sub_1C6387728, &qword_1EF8F72A8, &dword_1C475E000);
      __cxa_guard_release(&qword_1ED825AF8);
    }
  }
}

_QWORD *sub_1C5DEBCE0()
{
  _QWORD *result;

  result = (_QWORD *)operator new();
  result[1] = 0;
  result[2] = 0;
  *result = 0;
  return result;
}

void **sub_1C5DEBD10(void **result)
{
  void **v1;
  void **v2;

  if (result)
  {
    v1 = result;
    v2 = result;
    sub_1C4765410(&v2);
    return (void **)MEMORY[0x1CAA32FC0](v1, 0x20C40960023A9);
  }
  return result;
}

uint64_t *sub_1C5DEBD5C(uint64_t *result)
{
  uint64_t *v1;
  uint64_t v2;
  _QWORD v3[4];

  v3[3] = *MEMORY[0x1E0C80C00];
  if (result != &qword_1EF8F72A8)
  {
    v1 = result;
    v2 = result[3];
    if ((uint64_t *)v2 == result)
    {
      if ((uint64_t *)qword_1EF8F72C0 == &qword_1EF8F72A8)
      {
        (*(void (**)(uint64_t *, _QWORD *))(*result + 24))(result, v3);
        (*(void (**)(uint64_t))(*(_QWORD *)v1[3] + 32))(v1[3]);
        v1[3] = 0;
        (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)qword_1EF8F72C0 + 24))(qword_1EF8F72C0, v1);
        (*(void (**)(uint64_t))(*(_QWORD *)qword_1EF8F72C0 + 32))(qword_1EF8F72C0);
        qword_1EF8F72C0 = 0;
        v1[3] = (uint64_t)v1;
        (*(void (**)(_QWORD *, uint64_t *))(v3[0] + 24))(v3, &qword_1EF8F72A8);
        result = (uint64_t *)(*(uint64_t (**)(_QWORD *))(v3[0] + 32))(v3);
      }
      else
      {
        (*(void (**)(uint64_t *, uint64_t *))(*result + 24))(result, &qword_1EF8F72A8);
        result = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v1[3] + 32))(v1[3]);
        v1[3] = qword_1EF8F72C0;
      }
      qword_1EF8F72C0 = (uint64_t)&qword_1EF8F72A8;
    }
    else if ((uint64_t *)qword_1EF8F72C0 == &qword_1EF8F72A8)
    {
      (*(void (**)(uint64_t *, uint64_t *))(qword_1EF8F72A8 + 24))(&qword_1EF8F72A8, result);
      result = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)qword_1EF8F72C0 + 32))(qword_1EF8F72C0);
      qword_1EF8F72C0 = v1[3];
      v1[3] = (uint64_t)v1;
    }
    else
    {
      result[3] = qword_1EF8F72C0;
      qword_1EF8F72C0 = v2;
    }
  }
  return result;
}

uint64_t _ZTWN4llvm24ThisThreadsStreamIDTokenE()
{
  return off_1EF8EEB38();
}

void llvm::DebugCounter::print(llvm::DebugCounter *this, llvm::raw_ostream *a2)
{
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  size_t v10;
  uint64_t v12;
  void *v13;
  const void **v14;
  const void **v15;
  size_t v16;
  const void *v17;
  void **p_dst;
  uint64_t v19;
  uint64_t v20;
  _DWORD *v21;
  int v22;
  _BYTE *v23;
  char v24;
  BOOL v25;
  size_t v26;
  size_t v27;
  uint64_t v28;
  llvm::raw_ostream *v29;
  _DWORD *v30;
  _BYTE *v31;
  _DWORD *v32;
  _BYTE *v33;
  _DWORD *v34;
  _WORD *v35;
  _QWORD *v36;
  uint64_t *v37;
  char v38;
  int v39;
  uint64_t v40;
  void **__dst;
  size_t v42;
  unint64_t v43;
  int v44;
  void *__base;
  uint64_t v46;
  _QWORD v47[34];

  v47[32] = *MEMORY[0x1E0C80C00];
  v4 = (uint64_t *)*((_QWORD *)this + 6);
  v5 = (uint64_t *)*((_QWORD *)this + 7);
  __base = v47;
  v46 = 0x1000000000;
  v6 = v5 - v4;
  v7 = -1431655765 * v6;
  if (0xAAAAAAAAAAAAAAABLL * v6 >= 0x11)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__base, (uint64_t)v47, 0xAAAAAAAAAAAAAAABLL * v6, 16);
    v8 = v46;
    v9 = v46;
  }
  else
  {
    v8 = 0;
    v9 = 0;
  }
  if (v4 != v5)
  {
    v36 = (char *)__base + 16 * v8;
    do
    {
      if (*((char *)v4 + 23) >= 0)
        v37 = v4;
      else
        v37 = (uint64_t *)*v4;
      *v36 = v37;
      v38 = *((_BYTE *)v4 + 23);
      v39 = v38;
      v40 = v38 & 0x7F;
      if (v39 < 0)
        v40 = v4[1];
      v36[1] = v40;
      v4 += 3;
      v36 += 2;
    }
    while (v4 != v5);
  }
  v10 = (v9 + v7);
  LODWORD(v46) = v10;
  if (v10 >= 2)
    qsort(__base, v10, 0x10uLL, (int (__cdecl *)(const void *, const void *))sub_1C61B5604);
  if (!atomic_load(qword_1ED836B40))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED836B40, (void *(*)(void))sub_1C6387C7C, (void (*)(void *))sub_1C6387CC8);
  v12 = qword_1ED836B40[0];
  v13 = (void *)*((_QWORD *)a2 + 4);
  if (*((_QWORD *)a2 + 3) - (_QWORD)v13 > 0x14uLL)
  {
    qmemcpy(v13, "Counters and values:\n", 21);
    *((_QWORD *)a2 + 4) += 21;
  }
  else
  {
    llvm::raw_ostream::write(a2, "Counters and values:\n", 0x15uLL);
  }
  v14 = (const void **)__base;
  if ((_DWORD)v46)
  {
    v15 = (const void **)((char *)__base + 16 * v46);
    while (1)
    {
      v44 = 0;
      v16 = (size_t)v14[1];
      if (v16 >= 0x7FFFFFFFFFFFFFF8)
        abort();
      v17 = *v14;
      if (v16 >= 0x17)
      {
        v19 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v16 | 7) != 0x17)
          v19 = v16 | 7;
        v20 = v19 + 1;
        p_dst = (void **)operator new(v19 + 1);
        v42 = v16;
        v43 = v20 | 0x8000000000000000;
        __dst = p_dst;
      }
      else
      {
        HIBYTE(v43) = v14[1];
        p_dst = (void **)&__dst;
        if (!v16)
          goto LABEL_20;
      }
      memmove(p_dst, v17, v16);
LABEL_20:
      *((_BYTE *)p_dst + v16) = 0;
      v21 = (_DWORD *)sub_1C61CE594((uint64_t)this + 24, &__dst);
      v22 = 0;
      if ((_DWORD *)((char *)this + 32) != v21)
        v22 = v21[14];
      if (SHIBYTE(v43) < 0)
        operator delete(__dst);
      v44 = v22;
      v23 = (_BYTE *)(*((_QWORD *)this + 6) + 24 * (v22 - 1));
      v24 = v23[23];
      v25 = v24 < 0;
      v26 = *((_QWORD *)v23 + 1);
      if (v24 < 0)
        v23 = *(_BYTE **)v23;
      v27 = v24 & 0x7F;
      if (v25)
        v27 = v26;
      __dst = (void **)v23;
      v42 = v27;
      v43 = 0x100000020;
      llvm::raw_ostream::operator<<(a2, (uint64_t)&__dst);
      v28 = *((_QWORD *)a2 + 4);
      if ((unint64_t)(*((_QWORD *)a2 + 3) - v28) > 2)
      {
        *(_BYTE *)(v28 + 2) = 123;
        *(_WORD *)v28 = 8250;
        *((_QWORD *)a2 + 4) += 3;
        v29 = a2;
      }
      else
      {
        v29 = llvm::raw_ostream::write(a2, ": {", 3uLL);
      }
      v30 = sub_1C4D9B074(v12, &v44);
      llvm::raw_ostream::operator<<(v29, *((_QWORD *)v30 + 1));
      v31 = (_BYTE *)*((_QWORD *)v29 + 4);
      if (*((_BYTE **)v29 + 3) == v31)
      {
        v29 = llvm::raw_ostream::write(v29, ",", 1uLL);
      }
      else
      {
        *v31 = 44;
        ++*((_QWORD *)v29 + 4);
      }
      v32 = sub_1C4D9B074(v12, &v44);
      llvm::raw_ostream::operator<<(v29, *((_QWORD *)v32 + 2));
      v33 = (_BYTE *)*((_QWORD *)v29 + 4);
      if (*((_BYTE **)v29 + 3) == v33)
      {
        v29 = llvm::raw_ostream::write(v29, ",", 1uLL);
      }
      else
      {
        *v33 = 44;
        ++*((_QWORD *)v29 + 4);
      }
      v34 = sub_1C4D9B074(v12, &v44);
      llvm::raw_ostream::operator<<(v29, *((_QWORD *)v34 + 3));
      v35 = (_WORD *)*((_QWORD *)v29 + 4);
      if (*((_QWORD *)v29 + 3) - (_QWORD)v35 > 1uLL)
      {
        *v35 = 2685;
        *((_QWORD *)v29 + 4) += 2;
      }
      else
      {
        llvm::raw_ostream::write(v29, "}\n", 2uLL);
      }
      v14 += 2;
      if (v14 == v15)
      {
        v14 = (const void **)__base;
        break;
      }
    }
  }
  if (v14 != v47)
    free(v14);
}

void llvm::DebugCounter::~DebugCounter(char **this)
{
  char *v2;
  void **v3;

  v2 = (char *)(this + 3);
  v3 = (void **)(this + 6);
  sub_1C4765410(&v3);
  sub_1C47653C0((uint64_t)v2, this[4]);
  sub_1C5DED1C8((uint64_t *)this);
}

{
  char *v2;
  void **v3;

  v2 = (char *)(this + 3);
  v3 = (void **)(this + 6);
  sub_1C4765410(&v3);
  sub_1C47653C0((uint64_t)v2, this[4]);
  sub_1C5DED1C8((uint64_t *)this);
}

unint64_t llvm::DebugCounter::instance(llvm::DebugCounter *this)
{
  if (!atomic_load(qword_1ED836B40))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED836B40, (void *(*)(void))sub_1C6387C7C, (void (*)(void *))sub_1C6387CC8);
  return qword_1ED836B40[0];
}

llvm::raw_ostream *llvm::DebugCounter::push_back(llvm::raw_ostream *result, char **a2)
{
  char v2;
  int v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  void *v8;
  llvm *v9;
  uint64_t *v10;
  size_t v11;
  char *v12;
  size_t v13;
  char *v14;
  llvm *v15;
  unint64_t v16;
  char *v17;
  int v19;
  int v20;
  BOOL v21;
  llvm::raw_ostream *v22;
  llvm::raw_ostream *v23;
  uint64_t v24;
  llvm::raw_ostream *v25;
  uint64_t v26;
  char v27;
  BOOL v28;
  const char *v29;
  size_t v30;
  size_t v31;
  void *v32;
  const char *v33;
  size_t v34;
  llvm::raw_ostream *v35;
  llvm::raw_ostream *v36;
  uint64_t v37;
  void *v38;
  size_t v39;
  void *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  llvm *v44;
  int v45;
  void *p_p;
  uint64_t v48;
  uint64_t v49;
  int v50;
  llvm::raw_ostream *v52;
  uint64_t v53;
  void *__p;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;

  v2 = *((_BYTE *)a2 + 23);
  v3 = v2;
  v4 = v2 & 0x7F;
  if (v3 >= 0)
    v5 = v4;
  else
    v5 = (unint64_t)a2[1];
  if (v5)
  {
    v7 = (uint64_t)result;
    if (v3 >= 0)
      v8 = a2;
    else
      v8 = *a2;
    __p = v8;
    v55 = v5;
    LOBYTE(v57) = 61;
    v9 = (llvm *)llvm::StringRef::find((uint64_t *)&__p, (char *)&v57, 1uLL, 0);
    if (v9 == (llvm *)-1
      || (v5 >= (unint64_t)v9 ? (v11 = (size_t)v9) : (v11 = v5),
          v5 >= (unint64_t)v9 + 1 ? (v12 = (char *)v9 + 1) : (v12 = (char *)v5),
          v5 <= (unint64_t)v9 + 1))
    {
      v25 = (llvm::raw_ostream *)llvm::errs(v9);
      v26 = *((_QWORD *)v25 + 4);
      if ((unint64_t)(*((_QWORD *)v25 + 3) - v26) > 0x13)
      {
        *(_DWORD *)(v26 + 16) = 540701295;
        *(_OWORD *)v26 = *(_OWORD *)"DebugCounter Error: ";
        *((_QWORD *)v25 + 4) += 20;
      }
      else
      {
        v25 = llvm::raw_ostream::write(v25, "DebugCounter Error: ", 0x14uLL);
      }
      v27 = *((_BYTE *)a2 + 23);
      v28 = v27 < 0;
      if (v27 >= 0)
        v29 = (const char *)a2;
      else
        v29 = *a2;
      v30 = v27 & 0x7F;
      if (v28)
        v31 = (size_t)a2[1];
      else
        v31 = v30;
      result = llvm::raw_ostream::write(v25, v29, v31);
      v32 = (void *)*((_QWORD *)result + 4);
      if (*((_QWORD *)result + 3) - (_QWORD)v32 > 0x19uLL)
      {
        qmemcpy(v32, " does not have an = in it\n", 26);
        *((_QWORD *)result + 4) += 26;
        return result;
      }
      v33 = " does not have an = in it\n";
      v34 = 26;
      return llvm::raw_ostream::write(result, v33, v34);
    }
    v13 = v5 - (_QWORD)v12;
    v57 = 0;
    v14 = &v12[(_QWORD)v8];
    __p = &v12[(_QWORD)v8];
    v55 = v13;
    llvm::consumeSignedInteger((llvm *)&__p, 0, &v57, v10);
    if ((v15 & 1) != 0 || v55)
    {
      v35 = (llvm::raw_ostream *)llvm::errs(v15);
      v36 = v35;
      v37 = *((_QWORD *)v35 + 4);
      if ((unint64_t)(*((_QWORD *)v35 + 3) - v37) > 0x13)
      {
        *(_DWORD *)(v37 + 16) = 540701295;
        *(_OWORD *)v37 = *(_OWORD *)"DebugCounter Error: ";
        v38 = (void *)(*((_QWORD *)v35 + 4) + 20);
        *((_QWORD *)v36 + 4) = v38;
      }
      else
      {
        v36 = llvm::raw_ostream::write(v35, "DebugCounter Error: ", 0x14uLL);
        v38 = (void *)*((_QWORD *)v36 + 4);
      }
      if (v13 <= *((_QWORD *)v36 + 3) - (_QWORD)v38)
      {
        result = (llvm::raw_ostream *)memcpy(v38, v14, v13);
        v39 = *((_QWORD *)v36 + 4) + v13;
        *((_QWORD *)v36 + 4) = v39;
      }
      else
      {
        result = llvm::raw_ostream::write(v36, v14, v13);
        v36 = result;
        v39 = *((_QWORD *)result + 4);
      }
      if (*((_QWORD *)v36 + 3) - v39 > 0x10)
      {
        *(_BYTE *)(v39 + 16) = 10;
        *(_OWORD *)v39 = *(_OWORD *)" is not a number\n";
        *((_QWORD *)v36 + 4) += 17;
        return result;
      }
      v33 = " is not a number\n";
      result = v36;
      v34 = 17;
      return llvm::raw_ostream::write(result, v33, v34);
    }
    if (v11 < 5)
      goto LABEL_28;
    v16 = v57;
    v17 = (char *)v8 + v11;
    if (*(_DWORD *)((char *)v8 + v11 - 5) != 1768649517 || *((char *)v8 + v11 - 1) != 112)
    {
      if (v11 < 6
        || ((v19 = *(_DWORD *)(v17 - 6), v20 = *((unsigned __int16 *)v17 - 1), v19 == 1970234157)
          ? (v21 = v20 == 29806)
          : (v21 = 0),
            !v21))
      {
LABEL_28:
        v22 = (llvm::raw_ostream *)llvm::errs(v15);
        v23 = v22;
        v24 = *((_QWORD *)v22 + 4);
        if ((unint64_t)(*((_QWORD *)v22 + 3) - v24) > 0x13)
        {
          *(_DWORD *)(v24 + 16) = 540701295;
          *(_OWORD *)v24 = *(_OWORD *)"DebugCounter Error: ";
          result = (llvm::raw_ostream *)(*((_QWORD *)v22 + 4) + 20);
          *((_QWORD *)v23 + 4) = result;
        }
        else
        {
          v23 = llvm::raw_ostream::write(v22, "DebugCounter Error: ", 0x14uLL);
          result = (llvm::raw_ostream *)*((_QWORD *)v23 + 4);
        }
        if (v11 <= *((_QWORD *)v23 + 3) - (_QWORD)result)
        {
          if (v11)
          {
            memcpy(result, v8, v11);
            result = (llvm::raw_ostream *)(*((_QWORD *)v23 + 4) + v11);
            *((_QWORD *)v23 + 4) = result;
          }
        }
        else
        {
          v23 = llvm::raw_ostream::write(v23, (const char *)v8, v11);
          result = (llvm::raw_ostream *)*((_QWORD *)v23 + 4);
        }
        if (*((_QWORD *)v23 + 3) - (_QWORD)result <= 0x22uLL)
        {
          v33 = " does not end with -skip or -count\n";
          result = v23;
          v34 = 35;
          return llvm::raw_ostream::write(result, v33, v34);
        }
        qmemcpy(result, " does not end with -skip or -count\n", 35);
        v41 = *((_QWORD *)v23 + 4) + 35;
        goto LABEL_67;
      }
      if (v11 >= v11 - 6)
        v11 -= 6;
      if (v11 <= 0x7FFFFFFFFFFFFFF7)
      {
        if (v11 >= 0x17)
        {
          v48 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v11 | 7) != 0x17)
            v48 = v11 | 7;
          v49 = v48 + 1;
          p_p = operator new(v48 + 1);
          v55 = v11;
          v56 = v49 | 0x8000000000000000;
          __p = p_p;
        }
        else
        {
          HIBYTE(v56) = v11;
          p_p = &__p;
          if (!v11)
          {
LABEL_91:
            *((_BYTE *)p_p + v11) = 0;
            v44 = (llvm *)sub_1C61CE594(v7 + 24, &__p);
            if ((llvm *)(v7 + 32) == v44)
              v50 = 0;
            else
              v50 = *((_DWORD *)v44 + 14);
            if (SHIBYTE(v56) < 0)
              operator delete(__p);
            LODWORD(v57) = v50;
            if (v50)
            {
              if (!atomic_load(qword_1ED836B40))
                llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED836B40, (void *(*)(void))sub_1C6387C7C, (void (*)(void *))sub_1C6387CC8);
              *(_BYTE *)(qword_1ED836B40[0] + 72) = 1;
              result = (llvm::raw_ostream *)sub_1C4D9B074(v7, &v57);
              *((_QWORD *)result + 3) = v16;
LABEL_100:
              *((_BYTE *)result + 32) = 1;
              return result;
            }
            goto LABEL_101;
          }
        }
        memmove(p_p, v8, v11);
        goto LABEL_91;
      }
LABEL_111:
      abort();
    }
    if (v11 >= v11 - 5)
      v11 -= 5;
    if (v11 > 0x7FFFFFFFFFFFFFF7)
      goto LABEL_111;
    if (v11 >= 0x17)
    {
      v42 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v11 | 7) != 0x17)
        v42 = v11 | 7;
      v43 = v42 + 1;
      v40 = operator new(v42 + 1);
      v55 = v11;
      v56 = v43 | 0x8000000000000000;
      __p = v40;
    }
    else
    {
      HIBYTE(v56) = v11;
      v40 = &__p;
      if (!v11)
      {
LABEL_72:
        *((_BYTE *)v40 + v11) = 0;
        v44 = (llvm *)sub_1C61CE594(v7 + 24, &__p);
        if ((llvm *)(v7 + 32) == v44)
          v45 = 0;
        else
          v45 = *((_DWORD *)v44 + 14);
        if (SHIBYTE(v56) < 0)
          operator delete(__p);
        LODWORD(v57) = v45;
        if (v45)
        {
          if (!atomic_load(qword_1ED836B40))
            llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED836B40, (void *(*)(void))sub_1C6387C7C, (void (*)(void *))sub_1C6387CC8);
          *(_BYTE *)(qword_1ED836B40[0] + 72) = 1;
          result = (llvm::raw_ostream *)sub_1C4D9B074(v7, &v57);
          *((_QWORD *)result + 2) = v16;
          goto LABEL_100;
        }
LABEL_101:
        v52 = (llvm::raw_ostream *)llvm::errs(v44);
        v23 = v52;
        v53 = *((_QWORD *)v52 + 4);
        if ((unint64_t)(*((_QWORD *)v52 + 3) - v53) > 0x13)
        {
          *(_DWORD *)(v53 + 16) = 540701295;
          *(_OWORD *)v53 = *(_OWORD *)"DebugCounter Error: ";
          result = (llvm::raw_ostream *)(*((_QWORD *)v52 + 4) + 20);
          *((_QWORD *)v23 + 4) = result;
        }
        else
        {
          v23 = llvm::raw_ostream::write(v52, "DebugCounter Error: ", 0x14uLL);
          result = (llvm::raw_ostream *)*((_QWORD *)v23 + 4);
        }
        if (v11 <= *((_QWORD *)v23 + 3) - (_QWORD)result)
        {
          if (v11)
          {
            memcpy(result, v8, v11);
            result = (llvm::raw_ostream *)(*((_QWORD *)v23 + 4) + v11);
            *((_QWORD *)v23 + 4) = result;
          }
        }
        else
        {
          v23 = llvm::raw_ostream::write(v23, (const char *)v8, v11);
          result = (llvm::raw_ostream *)*((_QWORD *)v23 + 4);
        }
        if (*((_QWORD *)v23 + 3) - (_QWORD)result <= 0x1CuLL)
        {
          v33 = " is not a registered counter\n";
          result = v23;
          v34 = 29;
          return llvm::raw_ostream::write(result, v33, v34);
        }
        qmemcpy(result, " is not a registered counter\n", 29);
        v41 = *((_QWORD *)v23 + 4) + 29;
LABEL_67:
        *((_QWORD *)v23 + 4) = v41;
        return result;
      }
    }
    memmove(v40, v8, v11);
    goto LABEL_72;
  }
  return result;
}

llvm::cl::Option *sub_1C5DECA90()
{
  llvm::cl::Option *v0;
  llvm::cl::Option *result;
  unint64_t v3;
  int v4;
  int v5;
  __int128 v6;
  int v7;

  v0 = (llvm::cl::Option *)operator new();
  v7 = 1;
  *(_QWORD *)&v6 = "Comma separated list of debug counter skip and count";
  *((_QWORD *)&v6 + 1) = 52;
  v4 = 1;
  v5 = 1;
  if (!atomic_load(qword_1ED836B40))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED836B40, (void *(*)(void))sub_1C6387C7C, (void (*)(void *))sub_1C6387CC8);
  v3 = qword_1ED836B40[0];
  result = sub_1C63878EC(v0, &v7, &v6, &v5, &v4, (uint64_t *)&v3);
  *(_QWORD *)v0 = &off_1E81A0A60;
  return result;
}

uint64_t sub_1C5DECB48(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 32))(result);
  return result;
}

uint64_t sub_1C5DECB5C(uint64_t a1, int a2, int a3, int a4, void *__src, size_t __len)
{
  __int128 *p_dst;
  size_t v11;
  size_t v12;
  unint64_t v13;
  char *v14;
  _DWORD *v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  char *v22;
  int v23;
  uint64_t v24;
  void *__p[2];
  unint64_t v27;
  __int128 __dst;
  unint64_t v29;

  __p[0] = 0;
  __p[1] = 0;
  v27 = 0;
  if (!__src)
  {
    __dst = 0uLL;
    v29 = 0;
    goto LABEL_13;
  }
  if (__len >= 0x7FFFFFFFFFFFFFF8)
    goto LABEL_34;
  if (__len >= 0x17)
  {
    v11 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v11 = __len | 7;
    v12 = v11 + 1;
    p_dst = (__int128 *)operator new(v11 + 1);
    *((_QWORD *)&__dst + 1) = __len;
    v29 = v12 | 0x8000000000000000;
    *(_QWORD *)&__dst = p_dst;
    goto LABEL_10;
  }
  HIBYTE(v29) = __len;
  p_dst = &__dst;
  if (__len)
LABEL_10:
    memmove(p_dst, __src, __len);
  *((_BYTE *)p_dst + __len) = 0;
  if (SHIBYTE(v27) < 0)
    operator delete(__p[0]);
LABEL_13:
  *(_OWORD *)__p = __dst;
  v27 = v29;
  llvm::DebugCounter::push_back(*(llvm::raw_ostream **)(a1 + 128), (char **)__p);
  *(_WORD *)(a1 + 12) = a2;
  v14 = *(char **)(a1 + 144);
  v13 = *(_QWORD *)(a1 + 152);
  if ((unint64_t)v14 >= v13)
  {
    v16 = *(char **)(a1 + 136);
    v17 = (v14 - v16) >> 2;
    v18 = v17 + 1;
    if (!((unint64_t)(v17 + 1) >> 62))
    {
      v19 = v13 - (_QWORD)v16;
      if (v19 >> 1 > v18)
        v18 = v19 >> 1;
      if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFFCLL)
        v20 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v20 = v18;
      if (v20)
      {
        if (v20 >> 62)
          goto LABEL_36;
        v21 = (char *)operator new(4 * v20);
      }
      else
      {
        v21 = 0;
      }
      v22 = &v21[4 * v17];
      *(_DWORD *)v22 = a2;
      v15 = v22 + 4;
      while (v14 != v16)
      {
        v23 = *((_DWORD *)v14 - 1);
        v14 -= 4;
        *((_DWORD *)v22 - 1) = v23;
        v22 -= 4;
      }
      *(_QWORD *)(a1 + 136) = v22;
      *(_QWORD *)(a1 + 144) = v15;
      *(_QWORD *)(a1 + 152) = &v21[4 * v20];
      if (v16)
        operator delete(v16);
      goto LABEL_30;
    }
LABEL_34:
    abort();
  }
  *(_DWORD *)v14 = a2;
  v15 = v14 + 4;
LABEL_30:
  *(_QWORD *)(a1 + 144) = v15;
  v24 = *(_QWORD *)(a1 + 192);
  if (!v24)
  {
    sub_1C485C2F0();
LABEL_36:
    sub_1C4764EE4();
  }
  (*(void (**)(uint64_t, void **))(*(_QWORD *)v24 + 48))(v24, __p);
  if (SHIBYTE(v27) < 0)
    operator delete(__p[0]);
  return 0;
}

void sub_1C5DECD30(_QWORD *a1)
{
  sub_1C6387B40(a1);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5DECD54(llvm *a1, unsigned int a2)
{
  llvm::raw_ostream *v4;
  llvm::raw_ostream *v5;
  uint64_t v6;
  void *v7;
  const void *v8;
  unint64_t v9;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  unint64_t v14;
  llvm *v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  unsigned int v20;
  unint64_t v21;
  int v22;
  __int128 v23;
  __int128 v24;
  __int128 *v25;
  __int128 v26;
  int v27;
  llvm::raw_ostream *v28;
  uint64_t v29;
  unsigned int v30;
  void **v31;
  size_t v32;
  llvm *v33;
  llvm::raw_ostream *v34;
  llvm::raw_ostream *v35;
  uint64_t v36;
  const char *p_p;
  size_t v38;
  llvm::raw_ostream *v39;
  _BYTE *v40;
  int v41;
  uint64_t v42;
  int v43;
  void *v44[2];
  uint64_t v45;
  __int128 __p;
  uint64_t v47;
  _BYTE v48[32];
  __int128 v49;
  uint64_t v50;

  v4 = (llvm::raw_ostream *)llvm::outs(a1);
  v5 = v4;
  v6 = *((_QWORD *)v4 + 4);
  if ((unint64_t)(*((_QWORD *)v4 + 3) - v6) > 2)
  {
    *(_BYTE *)(v6 + 2) = 45;
    *(_WORD *)v6 = 8224;
    v7 = (void *)(*((_QWORD *)v4 + 4) + 3);
    *((_QWORD *)v5 + 4) = v7;
  }
  else
  {
    v5 = llvm::raw_ostream::write(v4, "  -", 3uLL);
    v7 = (void *)*((_QWORD *)v5 + 4);
  }
  v8 = (const void *)*((_QWORD *)a1 + 2);
  v9 = *((_QWORD *)a1 + 3);
  if (v9 <= *((_QWORD *)v5 + 3) - (_QWORD)v7)
  {
    if (v9)
    {
      memcpy(v7, v8, *((_QWORD *)a1 + 3));
      *((_QWORD *)v5 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v5, (const char *)v8, *((_QWORD *)a1 + 3));
  }
  llvm::cl::Option::printHelpStr(*((_QWORD *)a1 + 4), *((_QWORD *)a1 + 5), a2, *((_QWORD *)a1 + 3) + 6);
  if (!atomic_load(qword_1ED836B40))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED836B40, (void *(*)(void))sub_1C6387C7C, (void (*)(void *))sub_1C6387CC8);
  v11 = qword_1ED836B40[0];
  v12 = *(_QWORD **)(qword_1ED836B40[0] + 48);
  v13 = *(_QWORD **)(qword_1ED836B40[0] + 56);
  if (v12 != v13)
  {
    v14 = qword_1ED836B40[0] + 32;
    while (1)
    {
      v15 = (llvm *)sub_1C61CE594(v11 + 24, v12);
      if ((llvm *)v14 == v15)
        v16 = 0;
      else
        v16 = *((_DWORD *)v15 + 14);
      v17 = *(_QWORD *)(v11 + 48);
      v18 = *(_DWORD *)(v11 + 16);
      if (!v18)
        goto LABEL_15;
      v19 = *(_QWORD *)v11;
      v20 = v18 - 1;
      v21 = *(_QWORD *)v11 + ((unint64_t)(v20 & (37 * v16)) << 6);
      v22 = *(_DWORD *)v21;
      if (*(_DWORD *)v21 != v16)
        break;
LABEL_17:
      v23 = *(_OWORD *)(v21 + 8);
      *(_OWORD *)&v48[9] = *(_OWORD *)(v21 + 17);
      *(_OWORD *)v48 = v23;
      if (*(char *)(v21 + 63) < 0)
      {
        v15 = (llvm *)sub_1C47EBC30(&v49, *(void **)(v21 + 40), *(_QWORD *)(v21 + 48));
      }
      else
      {
        v24 = *(_OWORD *)(v21 + 40);
        v50 = *(_QWORD *)(v21 + 56);
        v49 = v24;
      }
LABEL_20:
      v25 = (__int128 *)(v17 + 24 * (v16 - 1));
      if (*((char *)v25 + 23) < 0)
      {
        v15 = (llvm *)sub_1C47EBC30(v44, *(void **)v25, *((_QWORD *)v25 + 1));
      }
      else
      {
        v26 = *v25;
        v45 = *((_QWORD *)v25 + 2);
        *(_OWORD *)v44 = v26;
      }
      __p = v49;
      v47 = v50;
      if (v45 >= 0)
        v27 = HIBYTE(v45) & 0x7F;
      else
        v27 = (int)v44[1];
      v28 = (llvm::raw_ostream *)llvm::outs(v15);
      v29 = *((_QWORD *)v28 + 4);
      if ((unint64_t)(*((_QWORD *)v28 + 3) - v29) > 4)
      {
        *(_BYTE *)(v29 + 4) = 61;
        *(_DWORD *)v29 = 538976288;
        *((_QWORD *)v28 + 4) += 5;
      }
      else
      {
        v28 = llvm::raw_ostream::write(v28, "    =", 5uLL);
      }
      v30 = a2 - v27;
      if (v45 >= 0)
        v31 = v44;
      else
        v31 = (void **)v44[0];
      if (v45 >= 0)
        v32 = HIBYTE(v45) & 0x7F;
      else
        v32 = (size_t)v44[1];
      v33 = llvm::raw_ostream::write(v28, (const char *)v31, v32);
      v34 = (llvm::raw_ostream *)llvm::outs(v33);
      v35 = llvm::raw_ostream::indent(v34, v30 - 8);
      v36 = *((_QWORD *)v35 + 4);
      if ((unint64_t)(*((_QWORD *)v35 + 3) - v36) > 4)
      {
        *(_BYTE *)(v36 + 4) = 32;
        *(_DWORD *)v36 = 538979616;
        *((_QWORD *)v35 + 4) += 5;
      }
      else
      {
        v35 = llvm::raw_ostream::write(v35, " -   ", 5uLL);
      }
      if (v47 >= 0)
        p_p = (const char *)&__p;
      else
        p_p = (const char *)__p;
      if (v47 >= 0)
        v38 = HIBYTE(v47) & 0x7F;
      else
        v38 = *((_QWORD *)&__p + 1);
      v39 = llvm::raw_ostream::write(v35, p_p, v38);
      v40 = (_BYTE *)*((_QWORD *)v39 + 4);
      if ((unint64_t)v40 >= *((_QWORD *)v39 + 3))
      {
        llvm::raw_ostream::write(v39, 10);
      }
      else
      {
        *((_QWORD *)v39 + 4) = v40 + 1;
        *v40 = 10;
      }
      if (SHIBYTE(v47) < 0)
        operator delete((void *)__p);
      if (SHIBYTE(v45) < 0)
        operator delete(v44[0]);
      v12 += 3;
      if (v12 == v13)
        return;
    }
    v41 = 1;
    LODWORD(v42) = v20 & (37 * v16);
    while (v22 != -1)
    {
      v43 = v42 + v41++;
      v42 = v43 & v20;
      v22 = *(_DWORD *)(v19 + ((unint64_t)v42 << 6));
      if (v22 == v16)
      {
        v21 = v19 + (v42 << 6);
        goto LABEL_17;
      }
    }
LABEL_15:
    *(_OWORD *)v48 = 0u;
    *(_OWORD *)&v48[16] = 0xFFFFFFFFFFFFFFFFLL;
    v50 = 0;
    v49 = 0uLL;
    goto LABEL_20;
  }
}

__n128 sub_1C5DED104(uint64_t a1, char *__s, _WORD *a3, _BYTE **a4, _BYTE **a5, _WORD *a6, __n128 *a7)
{
  size_t v14;
  _BYTE *v15;
  __n128 result;

  v14 = strlen(__s);
  llvm::cl::Option::setArgStr(a1, (unsigned __int8 *)__s, v14);
  *(_WORD *)(a1 + 10) = (32 * (*a3 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  sub_1C4EB7838((llvm *)(a1 + 128), (_QWORD *)a1, *a4);
  v15 = *a5;
  **(_BYTE **)(a1 + 128) = **a5;
  *(_BYTE *)(a1 + 145) = 1;
  *(_BYTE *)(a1 + 144) = *v15;
  *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 10) & 0xFFF8 | *a6 & 7;
  result = *a7;
  *(__n128 *)(a1 + 32) = *a7;
  return result;
}

uint64_t *sub_1C5DED1C8(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *((unsigned int *)a1 + 4);
  v3 = *a1;
  if ((_DWORD)v2)
  {
    v4 = v2 << 6;
    v5 = v3 + 40;
    do
    {
      if (*(_DWORD *)(v5 - 40) <= 0xFFFFFFFD && *(char *)(v5 + 23) < 0)
        operator delete(*(void **)v5);
      v5 += 64;
      v4 -= 64;
    }
    while (v4);
    v3 = *a1;
  }
  MEMORY[0x1CAA32FB4](v3, 8);
  return a1;
}

void llvm::DeltaAlgorithm::~DeltaAlgorithm(llvm::DeltaAlgorithm *this)
{
  *(_QWORD *)this = &off_1E81A0B78;
  sub_1C5DEDA3C((uint64_t)this + 8, *((_QWORD **)this + 2));
}

uint64_t llvm::DeltaAlgorithm::GetTestResult(uint64_t a1, _QWORD **a2)
{
  uint64_t v4;

  v4 = a1 + 8;
  if (!sub_1C5DEDA88(a1 + 8, a2))
  {
    if (((*(uint64_t (**)(uint64_t, _QWORD **))(*(_QWORD *)a1 + 8))(a1, a2) & 1) != 0)
      return 1;
    sub_1C5DEDBBC(v4, a2, a2);
  }
  return 0;
}

void llvm::DeltaAlgorithm::Split(uint64_t a1, _QWORD *a2, uint64_t *a3)
{
  unsigned int *v4;
  unsigned int *v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t **v8;
  unsigned int *v9;
  unsigned int *v10;
  BOOL v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD **v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD **v19;
  _QWORD *v20;
  uint64_t v21;

  v20 = 0;
  v21 = 0;
  v18 = 0;
  v19 = &v20;
  v16 = &v17;
  v17 = 0;
  v4 = (unsigned int *)*a2;
  v5 = (unsigned int *)(a2 + 1);
  if ((_QWORD *)*a2 != a2 + 1)
  {
    v6 = 0;
    v7 = a2[2] >> 1;
    do
    {
      if (v6 >= v7)
        v8 = (uint64_t **)&v16;
      else
        v8 = (uint64_t **)&v19;
      sub_1C4778ED8(v8, v4 + 7, v4 + 7);
      v9 = (unsigned int *)*((_QWORD *)v4 + 1);
      if (v9)
      {
        do
        {
          v10 = v9;
          v9 = *(unsigned int **)v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          v10 = (unsigned int *)*((_QWORD *)v4 + 2);
          v11 = *(_QWORD *)v10 == (_QWORD)v4;
          v4 = v10;
        }
        while (!v11);
      }
      ++v6;
      v4 = v10;
    }
    while (v10 != v5);
    if (v21)
    {
      v12 = a3[1];
      if (v12 >= a3[2])
        v13 = sub_1C5DEDD1C(a3, &v19);
      else
        v13 = sub_1C5220D38(v12, &v19) + 24;
      a3[1] = v13;
    }
  }
  if (v18)
  {
    v14 = a3[1];
    if (v14 >= a3[2])
      v15 = sub_1C5DEDD1C(a3, &v16);
    else
      v15 = sub_1C5220D38(v14, &v16) + 24;
    a3[1] = v15;
  }
  sub_1C47655E8((uint64_t)&v16, v17);
  sub_1C47655E8((uint64_t)&v19, v20);
}

void llvm::DeltaAlgorithm::Delta(void (***a1)(_QWORD)@<X0>, _QWORD *a2@<X1>, uint64_t *a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  void **v22;

  (**a1)(a1);
  if (0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 3) > 1)
  {
    v20 = 0;
    v21 = 0;
    v19 = &v20;
    v8 = llvm::DeltaAlgorithm::Search((uint64_t)a1, a2, a3, (uint64_t)&v19);
    if ((_DWORD)v8)
    {
      v9 = v20;
      *a4 = v19;
      a4[1] = v9;
      v10 = a4 + 1;
      v11 = v21;
      a4[2] = v21;
      if (v11)
      {
        v9[2] = v10;
        v19 = &v20;
        v20 = 0;
        v21 = 0;
        v9 = 0;
      }
      else
      {
        *a4 = v10;
      }
    }
    else
    {
      v16 = 0;
      v17 = 0;
      v18 = 0;
      v12 = (_QWORD *)*a3;
      v13 = (_QWORD *)a3[1];
      if ((_QWORD *)*a3 == v13)
      {
        v15 = 0;
        v14 = *a3;
      }
      else
      {
        do
        {
          llvm::DeltaAlgorithm::Split(v8, v12, &v16);
          v12 += 3;
        }
        while (v12 != v13);
        v12 = (_QWORD *)*a3;
        v14 = a3[1];
        v15 = v17 - v16;
      }
      if (v15 == v14 - (_QWORD)v12)
        sub_1C5220D38((uint64_t)a4, a2);
      else
        llvm::DeltaAlgorithm::Delta(a4, a1, a2, &v16);
      v22 = (void **)&v16;
      sub_1C5DEDE94(&v22);
      v9 = v20;
    }
    sub_1C47655E8((uint64_t)&v19, v9);
  }
  else
  {
    sub_1C5220D38((uint64_t)a4, a2);
  }
}

uint64_t llvm::DeltaAlgorithm::Search(uint64_t a1, _QWORD *a2, uint64_t *a3, uint64_t a4)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v9;
  uint64_t TestResult;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t *v13;
  unsigned int v14;
  unsigned int v15;
  _DWORD *v16;
  uint64_t *v17;
  BOOL v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  _QWORD *v24;
  _QWORD *v25;
  _QWORD *v26;
  _DWORD *v27;
  uint64_t *v28;
  _QWORD *v29;
  _QWORD *v30;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  uint64_t v37;
  char **v39;
  _QWORD *v40;
  uint64_t v41;
  char *v42;
  _QWORD *v43;
  uint64_t v44;
  _QWORD *v45;
  _QWORD *v46;
  uint64_t v47;

  v4 = (_QWORD *)*a3;
  v5 = (_QWORD *)a3[1];
  if ((_QWORD *)*a3 == v5)
    return 0;
  v9 = a2 + 1;
  while (1)
  {
    TestResult = llvm::DeltaAlgorithm::GetTestResult(a1, (_QWORD **)v4);
    if ((_DWORD)TestResult)
      break;
    if (0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 3) >= 3)
    {
      v46 = 0;
      v47 = 0;
      v45 = &v46;
      v11 = (_QWORD *)*a2;
      if ((_QWORD *)*a2 != v9)
      {
        v12 = (_QWORD *)*v4;
        v13 = (uint64_t *)&v46;
        while (v12 != v4 + 1)
        {
          v14 = *((_DWORD *)v11 + 7);
          v15 = *((_DWORD *)v12 + 7);
          if (v14 >= v15)
          {
            if (v15 >= v14)
            {
              v23 = (_QWORD *)v11[1];
              if (v23)
              {
                do
                {
                  v24 = v23;
                  v23 = (_QWORD *)*v23;
                }
                while (v23);
              }
              else
              {
                do
                {
                  v24 = (_QWORD *)v11[2];
                  v18 = *v24 == (_QWORD)v11;
                  v11 = v24;
                }
                while (!v18);
              }
              v25 = (_QWORD *)v12[1];
              if (v25)
              {
                do
                {
                  v12 = v25;
                  v25 = (_QWORD *)*v25;
                }
                while (v25);
              }
              else
              {
                do
                {
                  v26 = v12;
                  v12 = (_QWORD *)v12[2];
                }
                while ((_QWORD *)*v12 != v26);
              }
              v11 = v24;
            }
            else
            {
              v21 = (_QWORD *)v12[1];
              if (v21)
              {
                do
                {
                  v12 = v21;
                  v21 = (_QWORD *)*v21;
                }
                while (v21);
              }
              else
              {
                do
                {
                  v22 = v12;
                  v12 = (_QWORD *)v12[2];
                }
                while ((_QWORD *)*v12 != v22);
              }
            }
          }
          else
          {
            v16 = sub_1C5220DCC(&v45, v13, (unsigned int *)v11 + 7, (_DWORD *)v11 + 7);
            v17 = (uint64_t *)*((_QWORD *)v16 + 1);
            if (v17)
            {
              do
              {
                v13 = v17;
                v17 = (uint64_t *)*v17;
              }
              while (v17);
            }
            else
            {
              do
              {
                v13 = (uint64_t *)*((_QWORD *)v16 + 2);
                v18 = *v13 == (_QWORD)v16;
                v16 = v13;
              }
              while (!v18);
            }
            v19 = (_QWORD *)v11[1];
            if (v19)
            {
              do
              {
                v11 = v19;
                v19 = (_QWORD *)*v19;
              }
              while (v19);
            }
            else
            {
              do
              {
                v20 = v11;
                v11 = (_QWORD *)v11[2];
              }
              while ((_QWORD *)*v11 != v20);
            }
          }
          if (v11 == v9)
            goto LABEL_48;
        }
        do
        {
          v27 = sub_1C5220DCC(&v45, v13, (unsigned int *)v11 + 7, (_DWORD *)v11 + 7);
          v28 = (uint64_t *)*((_QWORD *)v27 + 1);
          if (v28)
          {
            do
            {
              v13 = v28;
              v28 = (uint64_t *)*v28;
            }
            while (v28);
          }
          else
          {
            do
            {
              v13 = (uint64_t *)*((_QWORD *)v27 + 2);
              v18 = *v13 == (_QWORD)v27;
              v27 = v13;
            }
            while (!v18);
          }
          v29 = (_QWORD *)v11[1];
          if (v29)
          {
            do
            {
              v30 = v29;
              v29 = (_QWORD *)*v29;
            }
            while (v29);
          }
          else
          {
            do
            {
              v30 = (_QWORD *)v11[2];
              v18 = *v30 == (_QWORD)v11;
              v11 = v30;
            }
            while (!v18);
          }
          v11 = v30;
        }
        while (v30 != v9);
      }
LABEL_48:
      if (llvm::DeltaAlgorithm::GetTestResult(a1, &v45))
      {
        v42 = 0;
        v43 = 0;
        v44 = 0;
        sub_1C5DEDF0C(&v42, 0, (_QWORD *)*a3, v4, 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v4 - *a3) >> 3));
        sub_1C5DEDF0C(&v42, (uint64_t)v43, v4 + 3, (_QWORD *)a3[1], 0xAAAAAAAAAAAAAAABLL * ((a3[1] - (uint64_t)(v4 + 3)) >> 3));
        llvm::DeltaAlgorithm::Delta(&v39, a1, &v45, &v42);
        v35 = a4 + 8;
        sub_1C47655E8(a4, *(_QWORD **)(a4 + 8));
        v36 = v40;
        *(_QWORD *)a4 = v39;
        *(_QWORD *)(a4 + 8) = v36;
        v37 = v41;
        *(_QWORD *)(a4 + 16) = v41;
        if (v37)
        {
          v36[2] = v35;
          v39 = (char **)&v40;
          v40 = 0;
          v41 = 0;
          v36 = 0;
        }
        else
        {
          *(_QWORD *)a4 = v35;
        }
        sub_1C47655E8((uint64_t)&v39, v36);
        v39 = &v42;
        sub_1C5DEDE94((void ***)&v39);
        sub_1C47655E8((uint64_t)&v45, v46);
        return 1;
      }
      sub_1C47655E8((uint64_t)&v45, v46);
    }
    v4 += 3;
    if (v4 == v5)
      return 0;
  }
  v45 = 0;
  v46 = 0;
  v47 = 0;
  llvm::DeltaAlgorithm::Split(TestResult, v4, (uint64_t *)&v45);
  llvm::DeltaAlgorithm::Delta(&v42, a1, v4, &v45);
  v32 = a4 + 8;
  sub_1C47655E8(a4, *(_QWORD **)(a4 + 8));
  v33 = v43;
  *(_QWORD *)a4 = v42;
  *(_QWORD *)(a4 + 8) = v33;
  v34 = v44;
  *(_QWORD *)(a4 + 16) = v44;
  if (v34)
  {
    v33[2] = v32;
    v42 = (char *)&v43;
    v43 = 0;
    v44 = 0;
    v33 = 0;
  }
  else
  {
    *(_QWORD *)a4 = v32;
  }
  sub_1C47655E8((uint64_t)&v42, v33);
  v42 = (char *)&v45;
  sub_1C5DEDE94((void ***)&v42);
  return 1;
}

void llvm::DeltaAlgorithm::Run(void (***a1)(_QWORD)@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  int TestResult;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  void **v11;

  v9 = 0;
  v10 = 0;
  v8 = &v9;
  TestResult = llvm::DeltaAlgorithm::GetTestResult((uint64_t)a1, &v8);
  sub_1C47655E8((uint64_t)&v8, v9);
  if (TestResult)
  {
    a3[2] = 0;
    a3[1] = 0;
    *a3 = a3 + 1;
  }
  else
  {
    v8 = 0;
    v9 = 0;
    v10 = 0;
    llvm::DeltaAlgorithm::Split(v7, a2, (uint64_t *)&v8);
    llvm::DeltaAlgorithm::Delta(a1, a2, (uint64_t *)&v8, a3);
    v11 = (void **)&v8;
    sub_1C5DEDE94(&v11);
  }
}

void sub_1C5DEDA3C(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    sub_1C5DEDA3C(a1, *a2);
    sub_1C5DEDA3C(a1, a2[1]);
    sub_1C47655E8((uint64_t)(a2 + 4), (_QWORD *)a2[5]);
    operator delete(a2);
  }
}

uint64_t sub_1C5DEDA88(uint64_t a1, _QWORD **a2)
{
  uint64_t **v2;
  _QWORD *v4;
  uint64_t v5;

  v2 = *(uint64_t ***)(a1 + 8);
  if (v2)
  {
    v4 = a2 + 1;
    v5 = 1;
    do
    {
      if ((sub_1C5DEDB1C(*a2, v4, v2[4], v2 + 5) & 1) == 0)
      {
        if (!sub_1C5DEDB1C(v2[4], v2 + 5, *a2, v4))
          return v5;
        ++v2;
      }
      v2 = (uint64_t **)*v2;
    }
    while (v2);
  }
  return 0;
}

uint64_t sub_1C5DEDB1C(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  unsigned int v4;
  unsigned int v5;
  _QWORD *v6;
  _QWORD *v7;
  BOOL v8;
  _QWORD *v9;
  _QWORD *v10;

  if (a3 == a4)
    return 0;
  while (a1 != a2)
  {
    v4 = *((_DWORD *)a1 + 7);
    v5 = *((_DWORD *)a3 + 7);
    if (v4 < v5)
      break;
    if (v5 >= v4)
    {
      v6 = (_QWORD *)a1[1];
      v7 = a1;
      if (v6)
      {
        do
        {
          a1 = v6;
          v6 = (_QWORD *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          a1 = (_QWORD *)v7[2];
          v8 = *a1 == (_QWORD)v7;
          v7 = a1;
        }
        while (!v8);
      }
      v9 = (_QWORD *)a3[1];
      if (v9)
      {
        do
        {
          v10 = v9;
          v9 = (_QWORD *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          v10 = (_QWORD *)a3[2];
          v8 = *v10 == (_QWORD)a3;
          a3 = v10;
        }
        while (!v8);
      }
      a3 = v10;
      if (v10 != a4)
        continue;
    }
    return 0;
  }
  return 1;
}

uint64_t *sub_1C5DEDBBC(uint64_t a1, _QWORD **a2, _QWORD *a3)
{
  uint64_t *v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v12;

  v5 = sub_1C5DEDC68(a1, &v12, a2);
  v6 = (uint64_t *)*v5;
  if (!*v5)
  {
    v7 = v5;
    v6 = (uint64_t *)operator new(0x38uLL);
    sub_1C5220D38((uint64_t)(v6 + 4), a3);
    v8 = v12;
    *v6 = 0;
    v6[1] = 0;
    v6[2] = v8;
    *v7 = (uint64_t)v6;
    v9 = **(_QWORD **)a1;
    v10 = v6;
    if (v9)
    {
      *(_QWORD *)a1 = v9;
      v10 = (uint64_t *)*v7;
    }
    sub_1C4768E74(*(uint64_t **)(a1 + 8), v10);
    ++*(_QWORD *)(a1 + 16);
  }
  return v6;
}

uint64_t *sub_1C5DEDC68(uint64_t a1, _QWORD *a2, _QWORD **a3)
{
  uint64_t *v4;
  uint64_t *v5;
  _QWORD *v7;
  uint64_t *v8;
  _QWORD *v9;

  v5 = (uint64_t *)(a1 + 8);
  v4 = *(uint64_t **)(a1 + 8);
  if (v4)
  {
    v7 = a3 + 1;
    do
    {
      while (1)
      {
        v8 = v4;
        v9 = v4 + 5;
        if (!sub_1C5DEDB1C(*a3, v7, (_QWORD *)v4[4], v4 + 5))
          break;
        v4 = (uint64_t *)*v8;
        v5 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (!sub_1C5DEDB1C((_QWORD *)v8[4], v9, *a3, v7))
        break;
      v5 = v8 + 1;
      v4 = (uint64_t *)v8[1];
    }
    while (v4);
  }
  else
  {
    v8 = (uint64_t *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

uint64_t sub_1C5DEDD1C(uint64_t *a1, _QWORD *a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v6;
  char *v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  char *v20;

  v2 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  v3 = v2 + 1;
  if (v2 + 1 > 0xAAAAAAAAAAAAAAALL)
    abort();
  if (0x5555555555555556 * ((a1[2] - *a1) >> 3) > v3)
    v3 = 0x5555555555555556 * ((a1[2] - *a1) >> 3);
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 3) >= 0x555555555555555)
    v6 = 0xAAAAAAAAAAAAAAALL;
  else
    v6 = v3;
  if (v6)
  {
    if (v6 > 0xAAAAAAAAAAAAAAALL)
      sub_1C4764EE4();
    v7 = (char *)operator new(24 * v6);
  }
  else
  {
    v7 = 0;
  }
  v8 = &v7[24 * v6];
  v9 = sub_1C5220D38((uint64_t)&v7[24 * v2], a2);
  v10 = v9 + 24;
  v11 = (char *)*a1;
  v12 = (char *)a1[1];
  if (v12 == (char *)*a1)
  {
    *a1 = v9;
    a1[1] = v10;
    a1[2] = (uint64_t)v8;
    if (!v12)
      return v10;
    goto LABEL_20;
  }
  v13 = 0;
  do
  {
    v14 = v9 + v13;
    *(_QWORD *)(v14 - 24) = *(_QWORD *)&v12[v13 - 24];
    v15 = &v12[v13 - 16];
    v16 = *(_QWORD *)v15;
    *(_QWORD *)(v9 + v13 - 16) = *(_QWORD *)v15;
    v17 = v9 + v13 - 16;
    v18 = *(_QWORD *)&v12[v13 - 8];
    *(_QWORD *)(v14 - 8) = v18;
    if (v18)
    {
      *(_QWORD *)(v16 + 16) = v17;
      *(_QWORD *)&v12[v13 - 24] = v15;
      *(_QWORD *)v15 = 0;
      *(_QWORD *)&v12[v13 - 8] = 0;
    }
    else
    {
      *(_QWORD *)(v14 - 24) = v17;
    }
    v13 -= 24;
  }
  while (&v12[v13] != v11);
  v12 = (char *)*a1;
  v19 = (char *)a1[1];
  *a1 = v9 + v13;
  a1[1] = v10;
  a1[2] = (uint64_t)v8;
  if (v19 != v12)
  {
    do
    {
      v20 = v19 - 24;
      sub_1C47655E8((uint64_t)(v19 - 24), *((_QWORD **)v19 - 2));
      v19 = v20;
    }
    while (v20 != v12);
  }
  if (v12)
LABEL_20:
    operator delete(v12);
  return v10;
}

void sub_1C5DEDE94(void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 24;
        sub_1C47655E8((uint64_t)(v4 - 24), *((_QWORD **)v4 - 2));
        v4 = v6;
      }
      while (v6 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1C5DEDF0C(char **a1, uint64_t a2, _QWORD *a3, _QWORD *a4, uint64_t a5)
{
  _QWORD *v6;
  char *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  char *v17;
  _QWORD *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  unint64_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  uint64_t *v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  char *v37;
  _QWORD *v38;
  uint64_t v39;
  _QWORD *v40;
  _QWORD *v41;
  uint64_t *v42;
  uint64_t v43;
  uint64_t **v44;
  uint64_t v45;
  _QWORD *v46;
  _QWORD *v47;
  unsigned int v48;
  uint64_t *v49;
  uint64_t *v50;
  uint64_t *v51;
  uint64_t v52;
  _QWORD *v53;
  _QWORD *v54;
  BOOL v55;
  _QWORD *v56;
  uint64_t ***v57;
  unsigned int v58;
  uint64_t *v59;
  uint64_t *v60;
  uint64_t **v61;
  uint64_t **v62;
  uint64_t **v63;
  uint64_t v64;
  _QWORD *v65;
  _QWORD *v66;
  uint64_t v67;
  char *v68;
  uint64_t v69;
  uint64_t v70;
  char *v71;
  uint64_t v72;
  char *v73;
  char *v74;
  char *v75;
  uint64_t *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  char *v80;
  char *v81;
  uint64_t v82;
  char *v83;
  uint64_t *v84;
  uint64_t *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  char *v89;
  uint64_t v90;
  _QWORD *v91;
  _QWORD *v92;
  char *v93;

  if (a5 < 1)
    return;
  v6 = a3;
  v8 = *a1;
  v9 = a1[1];
  v10 = (a2 - (uint64_t)*a1) / 24;
  v11 = (uint64_t)&(*a1)[24 * v10];
  v12 = a1[2];
  if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((v12 - v9) >> 3)) < a5)
  {
    v13 = a5 - 0x5555555555555555 * ((v9 - v8) >> 3);
    if (v13 > 0xAAAAAAAAAAAAAAALL)
      abort();
    v14 = 0xAAAAAAAAAAAAAAABLL * ((v12 - v8) >> 3);
    if (2 * v14 > v13)
      v13 = 2 * v14;
    if (v14 >= 0x555555555555555)
      v15 = 0xAAAAAAAAAAAAAAALL;
    else
      v15 = v13;
    if (v15)
    {
      if (v15 > 0xAAAAAAAAAAAAAAALL)
        sub_1C4764EE4();
      v16 = v10;
      v17 = (char *)operator new(24 * v15);
      v10 = v16;
    }
    else
    {
      v17 = 0;
    }
    v67 = v10;
    v68 = &v17[24 * v10];
    v93 = &v68[24 * a5];
    v69 = 24 * a5;
    v70 = (uint64_t)v68;
    do
    {
      v70 = sub_1C5220D38(v70, v6) + 24;
      v6 += 3;
      v69 -= 24;
    }
    while (v69);
    v71 = *a1;
    if (*a1 != (char *)v11)
    {
      v72 = 24 * v67;
      v73 = v17;
      v74 = v8;
      do
      {
        v75 = &v73[v72];
        *((_QWORD *)v75 - 3) = *(_QWORD *)&v74[v72 - 24];
        v76 = (uint64_t *)&v74[v72 - 16];
        v77 = *v76;
        *(_QWORD *)&v73[v72 - 16] = *v76;
        v78 = (uint64_t)&v73[v72 - 16];
        v79 = *(_QWORD *)&v74[v72 - 8];
        *((_QWORD *)v75 - 1) = v79;
        if (v79)
        {
          *(_QWORD *)(v77 + 16) = v78;
          *(_QWORD *)&v74[v72 - 24] = v76;
          *v76 = 0;
          *(_QWORD *)&v74[v72 - 8] = 0;
        }
        else
        {
          *((_QWORD *)v75 - 3) = v78;
        }
        v74 -= 24;
        v73 -= 24;
      }
      while (&v74[v72] != v71);
      v68 = &v73[24 * v67];
    }
    v80 = a1[1];
    v81 = v93;
    if (v80 != (char *)v11)
    {
      v82 = 24 * v67;
      v83 = &v17[24 * a5];
      do
      {
        v84 = (uint64_t *)&v83[v82];
        *v84 = *(_QWORD *)&v8[24 * v67];
        v85 = (uint64_t *)&v8[v82 + 8];
        v86 = *v85;
        *(_QWORD *)&v83[v82 + 8] = *v85;
        v87 = (uint64_t)&v83[v82 + 8];
        v88 = *(_QWORD *)&v8[v82 + 16];
        v84[2] = v88;
        if (v88)
        {
          *(_QWORD *)(v86 + 16) = v87;
          *(_QWORD *)&v8[24 * v67] = v85;
          *v85 = 0;
          *(_QWORD *)&v8[v82 + 16] = 0;
        }
        else
        {
          *v84 = v87;
        }
        v8 += 24;
        v83 += 24;
      }
      while (&v8[v82] != v80);
      v11 = (uint64_t)a1[1];
      v81 = &v83[24 * v67];
    }
    v89 = *a1;
    *a1 = v68;
    a1[1] = v81;
    for (a1[2] = &v17[24 * v15]; (char *)v11 != v89; v11 -= 24)
      sub_1C47655E8(v11 - 24, *(_QWORD **)(v11 - 16));
    if (v89)
      operator delete(v89);
    return;
  }
  if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v9[-v11] >> 3)) >= a5)
  {
    v23 = &a3[3 * a5];
    v20 = v9;
  }
  else
  {
    v19 = &a3[(uint64_t)&v9[-v11] >> 3];
    v90 = v10;
    v91 = v19;
    v20 = a1[1];
    if (v19 != a4)
    {
      v21 = (uint64_t)a1[1];
      do
      {
        v22 = sub_1C5220D38(v21, v19);
        v19 += 3;
        v21 = v22 + 24;
        v20 += 24;
      }
      while (v19 != a4);
    }
    a1[1] = v20;
    v23 = v91;
    if ((uint64_t)&v9[-v11] < 1)
      return;
    v10 = v90;
  }
  v24 = v11 + 24 * a5;
  v25 = (unint64_t)&v20[-24 * a5];
  v26 = v20;
  if (v25 < (unint64_t)v9)
  {
    v27 = 0;
    v28 = &v8[24 * v10 + 8 * ((uint64_t)&v20[-v24] >> 3)];
    do
    {
      v29 = (uint64_t *)&v20[v27];
      *v29 = *(_QWORD *)&v28[v27];
      v30 = &v28[v27 + 8];
      v31 = *(_QWORD *)v30;
      *(_QWORD *)&v20[v27 + 8] = *(_QWORD *)v30;
      v32 = (uint64_t)&v20[v27 + 8];
      v33 = *(_QWORD *)&v28[v27 + 16];
      v29[2] = v33;
      if (v33)
      {
        *(_QWORD *)(v31 + 16) = v32;
        *(_QWORD *)&v28[v27] = v30;
        *(_QWORD *)v30 = 0;
        *(_QWORD *)&v28[v27 + 16] = 0;
      }
      else
      {
        *v29 = v32;
      }
      v27 += 24;
    }
    while (&v28[v27] < v9);
    v26 = &v20[v27];
  }
  v92 = v23;
  a1[1] = v26;
  if (v20 != (char *)v24)
  {
    v34 = 0;
    v35 = &v8[24 * v10 + 8 * ((uint64_t)&v20[-v24] >> 3)];
    v36 = -8 * ((uint64_t)&v20[-v24] >> 3);
    do
    {
      v37 = &v20[v34 - 16];
      sub_1C47655E8((uint64_t)&v20[v34 - 24], *(_QWORD **)v37);
      *(_QWORD *)&v20[v34 - 24] = *(_QWORD *)(v25 + v34 - 24);
      v38 = *(_QWORD **)&v35[v34 - 16];
      *(_QWORD *)v37 = v38;
      v39 = *(_QWORD *)&v35[v34 - 8];
      *(_QWORD *)&v20[v34 - 8] = v39;
      if (v39)
      {
        v38[2] = v37;
        *(_QWORD *)(v25 + v34 - 24) = v25 + v34 - 16;
        *(_QWORD *)&v35[v34 - 16] = 0;
        *(_QWORD *)&v35[v34 - 8] = 0;
      }
      else
      {
        *(_QWORD *)&v20[v34 - 24] = v37;
      }
      v34 -= 24;
    }
    while (v36 != v34);
  }
  for (; v6 != v92; v11 += 24)
  {
    if ((_QWORD *)v11 != v6)
    {
      v40 = v6 + 1;
      v41 = (_QWORD *)*v6;
      if (!*(_QWORD *)(v11 + 16))
        goto LABEL_59;
      v42 = *(uint64_t **)v11;
      v44 = (uint64_t **)(v11 + 8);
      v43 = *(_QWORD *)(v11 + 8);
      *(_QWORD *)v11 = v11 + 8;
      *(_QWORD *)(v43 + 16) = 0;
      *(_QWORD *)(v11 + 16) = 0;
      *(_QWORD *)(v11 + 8) = 0;
      v45 = v42[1] ? v42[1] : (uint64_t)v42;
      if (v45)
      {
        v46 = sub_1C4FCE18C(v45);
        if (v41 == v40)
        {
          v47 = (_QWORD *)v45;
          v54 = v41;
        }
        else
        {
          do
          {
            v47 = v46;
            v48 = *((_DWORD *)v41 + 7);
            *(_DWORD *)(v45 + 28) = v48;
            v49 = *v44;
            v50 = (uint64_t *)(v11 + 8);
            v51 = (uint64_t *)(v11 + 8);
            if (*v44)
            {
              do
              {
                while (1)
                {
                  v50 = v49;
                  if (v48 >= *((_DWORD *)v49 + 7))
                    break;
                  v49 = (uint64_t *)*v49;
                  v51 = v50;
                  if (!*v50)
                    goto LABEL_46;
                }
                v49 = (uint64_t *)v49[1];
              }
              while (v49);
              v51 = v50 + 1;
            }
LABEL_46:
            *(_QWORD *)v45 = 0;
            *(_QWORD *)(v45 + 8) = 0;
            *(_QWORD *)(v45 + 16) = v50;
            *v51 = v45;
            v52 = **(_QWORD **)v11;
            if (v52)
            {
              *(_QWORD *)v11 = v52;
              v45 = *v51;
            }
            sub_1C4768E74(*(uint64_t **)(v11 + 8), (uint64_t *)v45);
            ++*(_QWORD *)(v11 + 16);
            if (v46)
              v46 = sub_1C4FCE18C((uint64_t)v46);
            else
              v46 = 0;
            v53 = (_QWORD *)v41[1];
            if (v53)
            {
              do
              {
                v54 = v53;
                v53 = (_QWORD *)*v53;
              }
              while (v53);
            }
            else
            {
              do
              {
                v54 = (_QWORD *)v41[2];
                v55 = *v54 == (_QWORD)v41;
                v41 = v54;
              }
              while (!v55);
            }
            if (!v47)
              break;
            v41 = v54;
            v45 = (uint64_t)v47;
          }
          while (v54 != v40);
        }
        sub_1C47655E8(v11, v47);
        if (v46)
        {
          do
          {
            v56 = v46;
            v46 = (_QWORD *)v46[2];
          }
          while (v46);
          sub_1C47655E8(v11, v56);
        }
      }
      else
      {
LABEL_59:
        v54 = v41;
      }
      if (v54 != v40)
      {
        v57 = (uint64_t ***)(v11 + 8);
        do
        {
          v58 = *((_DWORD *)v54 + 7);
          v59 = (uint64_t *)operator new(0x20uLL);
          v60 = v59;
          *((_DWORD *)v59 + 7) = v58;
          v61 = *v57;
          v62 = (uint64_t **)(v11 + 8);
          v63 = (uint64_t **)(v11 + 8);
          if (*v57)
          {
            do
            {
              while (1)
              {
                v62 = v61;
                if (*((_DWORD *)v61 + 7) <= v58)
                  break;
                v61 = (uint64_t **)*v61;
                v63 = v62;
                if (!*v62)
                  goto LABEL_72;
              }
              v61 = (uint64_t **)v61[1];
            }
            while (v61);
            v63 = v62 + 1;
          }
LABEL_72:
          *v59 = 0;
          v59[1] = 0;
          v59[2] = (uint64_t)v62;
          *v63 = v59;
          v64 = **(_QWORD **)v11;
          if (v64)
          {
            *(_QWORD *)v11 = v64;
            v60 = *v63;
          }
          sub_1C4768E74(*(uint64_t **)(v11 + 8), v60);
          ++*(_QWORD *)(v11 + 16);
          v65 = (_QWORD *)v54[1];
          if (v65)
          {
            do
            {
              v66 = v65;
              v65 = (_QWORD *)*v65;
            }
            while (v65);
          }
          else
          {
            do
            {
              v66 = (_QWORD *)v54[2];
              v55 = *v66 == (_QWORD)v54;
              v54 = v66;
            }
            while (!v55);
          }
          v54 = v66;
        }
        while (v66 != v40);
      }
    }
    v6 += 3;
  }
}

void llvm::DAGDeltaAlgorithm::Run(uint64_t a1@<X0>, _QWORD *a2@<X1>, unsigned int **a3@<X2>, uint64_t a4@<X8>)
{
  _QWORD *v6;
  _QWORD *v7;
  unsigned int v8;
  _QWORD *v9;
  _QWORD *v10;
  BOOL v11;
  unsigned int *v12;
  unsigned int *v13;
  _DWORD *v14;
  uint64_t **v15;
  uint64_t **v16;
  uint64_t *v17;
  unsigned int *v18;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  unsigned int *v26;
  unsigned int v27;
  uint64_t **v28;
  uint64_t **v29;
  uint64_t *v30;
  char *v31;
  uint64_t *v32;
  uint64_t *v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;
  char *v38;
  char *v39;
  int v40;
  _QWORD *v41;
  unsigned int v42;
  uint64_t *v43;
  unsigned int *v44;
  unsigned int *v45;
  unsigned int *v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  unint64_t v50;
  char *v51;
  unsigned int *v52;
  unsigned int v53;
  _QWORD *v54;
  _QWORD *v55;
  int64_t v56;
  unsigned int *v57;
  char *v58;
  unsigned int *v59;
  unsigned int *v60;
  unsigned int v61;
  uint64_t **v62;
  unsigned int *v63;
  uint64_t *v64;
  uint64_t **v65;
  uint64_t **v66;
  uint64_t **v67;
  uint64_t *v68;
  _QWORD **v69;
  uint64_t *v70;
  uint64_t *v71;
  uint64_t *v72;
  unsigned int *v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  char *v77;
  unsigned int *v78;
  unsigned int v79;
  _QWORD *v80;
  uint64_t v81;
  unsigned int v82;
  uint64_t *v83;
  uint64_t **v84;
  uint64_t **v85;
  unsigned int v86;
  _QWORD *v87;
  _DWORD *v88;
  uint64_t *v89;
  _QWORD *v90;
  _QWORD *v91;
  _QWORD *v92;
  uint64_t *v93;
  uint64_t **v94;
  uint64_t **v95;
  uint64_t *v96;
  uint64_t *v97;
  _QWORD *v98;
  _QWORD *v99;
  unsigned int *v100;
  uint64_t v101;
  uint64_t *v102;
  unsigned int *v103;
  unsigned int *v104;
  unsigned int *v105;
  unsigned int *v106;
  unsigned int v107;
  unsigned int *v108;
  uint64_t *v109;
  unsigned int *v110;
  unsigned int *v111;
  _QWORD *v112;
  uint64_t v114;
  uint64_t v115;
  void *__p;
  unsigned int *v117;
  unsigned int *v118;
  _QWORD **v119;
  _QWORD *v120[2];
  uint64_t *v121;
  _QWORD *v122[2];
  uint64_t *v123;
  _QWORD *v124[2];
  uint64_t **v125;
  uint64_t *v126;
  uint64_t v127;
  uint64_t *v128;
  _QWORD *v129[2];
  unsigned int *v130;
  _QWORD *v131[2];
  uint64_t (**v132)();
  _QWORD **v133;
  _QWORD *v134;
  uint64_t v135;
  uint64_t *v136;
  uint64_t v137;
  _QWORD *v138;
  _QWORD *v139;
  uint64_t v140;
  unsigned int v141[3];

  v115 = a1;
  __p = 0;
  v117 = 0;
  v118 = 0;
  v119 = v120;
  v120[0] = 0;
  v122[0] = 0;
  v122[1] = 0;
  v120[1] = 0;
  v121 = (uint64_t *)v122;
  v123 = (uint64_t *)v124;
  v124[0] = 0;
  v126 = 0;
  v127 = 0;
  v124[1] = 0;
  v125 = &v126;
  v129[0] = 0;
  v129[1] = 0;
  v128 = (uint64_t *)v129;
  v7 = a2 + 1;
  v6 = (_QWORD *)*a2;
  if ((_QWORD *)*a2 != a2 + 1)
  {
    do
    {
      LODWORD(v132) = *((_DWORD *)v6 + 7);
      v8 = v132;
      v134 = 0;
      v135 = 0;
      v133 = 0;
      sub_1C5DEF018((uint64_t *)&v121, v132, (uint64_t)&v132);
      if (v133)
        operator delete(v133);
      LODWORD(v132) = v8;
      v134 = 0;
      v135 = 0;
      v133 = 0;
      sub_1C5DEF018((uint64_t *)&v123, v8, (uint64_t)&v132);
      if (v133)
        operator delete(v133);
      v9 = (_QWORD *)v6[1];
      if (v9)
      {
        do
        {
          v10 = v9;
          v9 = (_QWORD *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          v10 = (_QWORD *)v6[2];
          v11 = *v10 == (_QWORD)v6;
          v6 = v10;
        }
        while (!v11);
      }
      v6 = v10;
    }
    while (v10 != v7);
  }
  v112 = v7;
  v13 = *a3;
  v12 = a3[1];
  v114 = a4;
  if (*a3 != v12)
  {
    do
    {
      v14 = v13 + 1;
      v15 = sub_1C4FD085C(&v121, v13[1], v13 + 1);
      v16 = v15;
      v18 = (unsigned int *)v15[6];
      v17 = v15[7];
      if (v18 >= (unsigned int *)v17)
      {
        v20 = v15[5];
        v21 = ((char *)v18 - (char *)v20) >> 2;
        v22 = v21 + 1;
        if ((unint64_t)(v21 + 1) >> 62)
          goto LABEL_172;
        v23 = (char *)v17 - (char *)v20;
        if (v23 >> 1 > v22)
          v22 = v23 >> 1;
        if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFFCLL)
          v24 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v24 = v22;
        if (v24)
        {
          if (v24 >> 62)
            goto LABEL_173;
          v25 = (char *)operator new(4 * v24);
        }
        else
        {
          v25 = 0;
        }
        v26 = (unsigned int *)&v25[4 * v21];
        *v26 = *v13;
        v19 = (uint64_t *)(v26 + 1);
        while (v18 != (unsigned int *)v20)
        {
          v27 = *--v18;
          *--v26 = v27;
        }
        v16[5] = (uint64_t *)v26;
        v16[6] = v19;
        v16[7] = (uint64_t *)&v25[4 * v24];
        if (v20)
          operator delete(v20);
      }
      else
      {
        *v18 = *v13;
        v19 = (uint64_t *)(v18 + 1);
      }
      v16[6] = v19;
      v28 = sub_1C4FD085C(&v123, *v13, v13);
      v29 = v28;
      v31 = (char *)v28[6];
      v30 = v28[7];
      if (v31 >= (char *)v30)
      {
        v33 = v28[5];
        v34 = (v31 - (char *)v33) >> 2;
        v35 = v34 + 1;
        if ((unint64_t)(v34 + 1) >> 62)
          goto LABEL_172;
        v36 = (char *)v30 - (char *)v33;
        if (v36 >> 1 > v35)
          v35 = v36 >> 1;
        if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFFCLL)
          v37 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v37 = v35;
        if (v37)
        {
          if (v37 >> 62)
LABEL_173:
            sub_1C4764EE4();
          v38 = (char *)operator new(4 * v37);
        }
        else
        {
          v38 = 0;
        }
        v39 = &v38[4 * v34];
        *(_DWORD *)v39 = *v14;
        v32 = (uint64_t *)(v39 + 4);
        while (v31 != (char *)v33)
        {
          v40 = *((_DWORD *)v31 - 1);
          v31 -= 4;
          *((_DWORD *)v39 - 1) = v40;
          v39 -= 4;
        }
        v29[5] = (uint64_t *)v39;
        v29[6] = v32;
        v29[7] = (uint64_t *)&v38[4 * v37];
        if (v33)
          operator delete(v33);
      }
      else
      {
        *(_DWORD *)v31 = *v14;
        v32 = (uint64_t *)(v31 + 4);
      }
      v29[6] = v32;
      v13 += 2;
    }
    while (v13 != v12);
  }
  v41 = (_QWORD *)*a2;
  if ((_QWORD *)*a2 != v112)
  {
    do
    {
      LODWORD(v132) = *((_DWORD *)v41 + 7);
      v42 = v132;
      v43 = sub_1C4FD085C(&v123, v132, &v132)[5];
      LODWORD(v132) = v42;
      if (v43 == sub_1C4FD085C(&v123, v42, &v132)[6])
      {
        v44 = v117;
        if (v117 >= v118)
        {
          v46 = (unsigned int *)__p;
          v47 = ((char *)v117 - (_BYTE *)__p) >> 2;
          v48 = v47 + 1;
          if ((unint64_t)(v47 + 1) >> 62)
            goto LABEL_172;
          v49 = (char *)v118 - (_BYTE *)__p;
          if (((char *)v118 - (_BYTE *)__p) >> 1 > v48)
            v48 = v49 >> 1;
          if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFFCLL)
            v50 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v50 = v48;
          if (v50)
          {
            if (v50 >> 62)
              goto LABEL_173;
            v51 = (char *)operator new(4 * v50);
          }
          else
          {
            v51 = 0;
          }
          v52 = (unsigned int *)&v51[4 * v47];
          *v52 = v42;
          v45 = v52 + 1;
          while (v44 != v46)
          {
            v53 = *--v44;
            *--v52 = v53;
          }
          __p = v52;
          v117 = v45;
          v118 = (unsigned int *)&v51[4 * v50];
          if (v46)
            operator delete(v46);
        }
        else
        {
          *v117 = v42;
          v45 = v44 + 1;
        }
        v117 = v45;
      }
      v54 = (_QWORD *)v41[1];
      if (v54)
      {
        do
        {
          v55 = v54;
          v54 = (_QWORD *)*v54;
        }
        while (v54);
      }
      else
      {
        do
        {
          v55 = (_QWORD *)v41[2];
          v11 = *v55 == (_QWORD)v41;
          v41 = v55;
        }
        while (!v11);
      }
      v41 = v55;
    }
    while (v55 != v112);
  }
  v56 = (char *)v117 - (_BYTE *)__p;
  if (v117 == __p)
  {
    v57 = 0;
  }
  else
  {
    if (v56 < 0)
LABEL_172:
      abort();
    v57 = (unsigned int *)operator new((char *)v117 - (_BYTE *)__p);
    v58 = (char *)&v57[v56 >> 2];
    memmove(v57, __p, v56);
    v59 = (unsigned int *)v58;
    do
    {
      LODWORD(v138) = 0;
      v61 = *(v59 - 1);
      v60 = v59 - 1;
      LODWORD(v138) = v61;
      v62 = sub_1C5221B54(&v128, v61, &v138);
      LODWORD(v132) = (_DWORD)v138;
      v63 = (unsigned int *)sub_1C4FD085C(&v121, v138, &v132)[5];
      LODWORD(v132) = (_DWORD)v138;
      v64 = sub_1C4FD085C(&v121, v138, &v132)[6];
      if (v63 == (unsigned int *)v64)
      {
        v73 = v60;
      }
      else
      {
        v65 = v62 + 6;
        do
        {
          v66 = sub_1C5221B54(&v128, *v63, v63);
          sub_1C4778ED8(v66 + 5, (unsigned int *)&v138, &v138);
          v67 = sub_1C5221B54(&v128, *v63, v63);
          v68 = v62[5];
          if (v68 != (uint64_t *)v65)
          {
            v69 = v67 + 5;
            v70 = (uint64_t *)(v67 + 6);
            do
            {
              sub_1C5220DCC(v69, v70, (unsigned int *)v68 + 7, (_DWORD *)v68 + 7);
              v71 = (uint64_t *)v68[1];
              if (v71)
              {
                do
                {
                  v72 = v71;
                  v71 = (uint64_t *)*v71;
                }
                while (v71);
              }
              else
              {
                do
                {
                  v72 = (uint64_t *)v68[2];
                  v11 = *v72 == (_QWORD)v68;
                  v68 = v72;
                }
                while (!v11);
              }
              v68 = v72;
            }
            while (v72 != (uint64_t *)v65);
          }
          if (v60 >= (unsigned int *)v58)
          {
            v74 = v60 - v57;
            v75 = v74 + 1;
            if ((unint64_t)(v74 + 1) >> 62)
              goto LABEL_172;
            if ((v58 - (char *)v57) >> 1 > v75)
              v75 = (v58 - (char *)v57) >> 1;
            if ((unint64_t)(v58 - (char *)v57) >= 0x7FFFFFFFFFFFFFFCLL)
              v76 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v76 = v75;
            if (v76)
            {
              if (v76 >> 62)
                goto LABEL_173;
              v77 = (char *)operator new(4 * v76);
            }
            else
            {
              v77 = 0;
            }
            v78 = (unsigned int *)&v77[4 * v74];
            *v78 = *v63;
            v73 = v78 + 1;
            while (v60 != v57)
            {
              v79 = *--v60;
              *--v78 = v79;
            }
            v58 = &v77[4 * v76];
            if (v57)
              operator delete(v57);
            v57 = v78;
          }
          else
          {
            *v60 = *v63;
            v73 = v60 + 1;
          }
          ++v63;
          v60 = v73;
        }
        while (v63 != (unsigned int *)v64);
      }
      v59 = v73;
    }
    while (v57 != v73);
  }
  v80 = (_QWORD *)*a2;
  v81 = v114;
  if ((_QWORD *)*a2 != v112)
  {
    do
    {
      v82 = *((_DWORD *)v80 + 7);
      v139 = 0;
      v140 = 0;
      v138 = &v139;
      LODWORD(v132) = v82;
      v134 = 0;
      v135 = 0;
      v133 = &v134;
      v83 = v126;
      v84 = &v126;
LABEL_113:
      v85 = v84;
      if (v83)
      {
        while (1)
        {
          v84 = (uint64_t **)v83;
          v86 = *((_DWORD *)v83 + 8);
          if (v86 > v82)
          {
            v83 = *v84;
            goto LABEL_113;
          }
          if (v86 >= v82)
            break;
          v83 = v84[1];
          if (!v83)
          {
            v85 = v84 + 1;
            goto LABEL_120;
          }
        }
        v87 = 0;
      }
      else
      {
LABEL_120:
        v88 = operator new(0x40uLL);
        v88[8] = v82;
        *((_QWORD *)v88 + 7) = 0;
        *((_QWORD *)v88 + 6) = 0;
        *((_QWORD *)v88 + 5) = v88 + 12;
        *(_QWORD *)v88 = 0;
        *((_QWORD *)v88 + 1) = 0;
        *((_QWORD *)v88 + 2) = v84;
        *v85 = (uint64_t *)v88;
        if (*v125)
        {
          v125 = (uint64_t **)*v125;
          v89 = *v85;
        }
        else
        {
          v89 = (uint64_t *)v88;
        }
        sub_1C4768E74(v126, v89);
        ++v127;
        v87 = v134;
      }
      sub_1C47655E8((uint64_t)&v133, v87);
      sub_1C47655E8((uint64_t)&v138, v139);
      v90 = (_QWORD *)v80[1];
      if (v90)
      {
        do
        {
          v91 = v90;
          v90 = (_QWORD *)*v90;
        }
        while (v90);
      }
      else
      {
        do
        {
          v91 = (_QWORD *)v80[2];
          v11 = *v91 == (_QWORD)v80;
          v80 = v91;
        }
        while (!v11);
      }
      v80 = v91;
    }
    while (v91 != v112);
    v81 = v114;
    v92 = (_QWORD *)*a2;
    if ((_QWORD *)*a2 != v112)
    {
      do
      {
        LODWORD(v138) = *((_DWORD *)v92 + 7);
        LODWORD(v132) = (_DWORD)v138;
        v93 = sub_1C5221B54(&v128, v138, &v132)[5];
        LODWORD(v132) = (_DWORD)v138;
        v94 = sub_1C5221B54(&v128, v138, &v132) + 6;
        if (v93 != (uint64_t *)v94)
        {
          do
          {
            v95 = sub_1C5221B54((uint64_t **)&v125, *((_DWORD *)v93 + 7), (_DWORD *)v93 + 7);
            sub_1C4778ED8(v95 + 5, (unsigned int *)&v138, &v138);
            v96 = (uint64_t *)v93[1];
            if (v96)
            {
              do
              {
                v97 = v96;
                v96 = (uint64_t *)*v96;
              }
              while (v96);
            }
            else
            {
              do
              {
                v97 = (uint64_t *)v93[2];
                v11 = *v97 == (_QWORD)v93;
                v93 = v97;
              }
              while (!v11);
            }
            v93 = v97;
          }
          while (v97 != (uint64_t *)v94);
        }
        v98 = (_QWORD *)v92[1];
        if (v98)
        {
          do
          {
            v99 = v98;
            v98 = (_QWORD *)*v98;
          }
          while (v98);
        }
        else
        {
          do
          {
            v99 = (_QWORD *)v92[2];
            v11 = *v99 == (_QWORD)v92;
            v92 = v99;
          }
          while (!v11);
        }
        v92 = v99;
      }
      while (v99 != v112);
    }
  }
  if (v57)
    operator delete(v57);
  v100 = (unsigned int *)__p;
  v139 = 0;
  v140 = 0;
  v138 = &v139;
  if (__p == v117)
  {
    *(_QWORD *)(v81 + 16) = 0;
    *(_QWORD *)(v81 + 8) = 0;
    *(_QWORD *)v81 = v81 + 8;
  }
  else
  {
    do
    {
      sub_1C5220DCC(&v138, (uint64_t *)&v139, v100, v100);
      ++v100;
    }
    while (v100 != v117);
    v101 = v140;
    *(_QWORD *)(v81 + 8) = 0;
    v102 = (uint64_t *)(v81 + 8);
    *(_QWORD *)(v81 + 16) = 0;
    *(_QWORD *)v81 = v81 + 8;
    if (v101)
    {
      do
      {
        v134 = 0;
        v135 = 0;
        v132 = off_1E81A0BE0;
        v133 = &v134;
        v136 = &v115;
        v137 = v81;
        llvm::DeltaAlgorithm::Run((void (***)(_QWORD))&v132, &v138, &v130);
        v103 = v130;
        if (v130 != (unsigned int *)v131)
        {
          do
          {
            sub_1C5220DCC((_QWORD **)v81, v102, v103 + 7, v103 + 7);
            v104 = (unsigned int *)*((_QWORD *)v103 + 1);
            if (v104)
            {
              do
              {
                v105 = v104;
                v104 = *(unsigned int **)v104;
              }
              while (v104);
            }
            else
            {
              do
              {
                v105 = (unsigned int *)*((_QWORD *)v103 + 2);
                v11 = *(_QWORD *)v105 == (_QWORD)v103;
                v103 = v105;
              }
              while (!v11);
            }
            v103 = v105;
          }
          while (v105 != (unsigned int *)v131);
        }
        sub_1C47655E8((uint64_t)&v138, v139);
        v139 = 0;
        v140 = 0;
        v138 = &v139;
        v106 = v130;
        if (v130 != (unsigned int *)v131)
        {
          do
          {
            v141[0] = v106[7];
            v107 = v141[0];
            v108 = (unsigned int *)sub_1C4FD085C(&v121, v141[0], v141)[5];
            v141[0] = v107;
            v109 = sub_1C4FD085C(&v121, v107, v141)[6];
            while (v108 != (unsigned int *)v109)
            {
              sub_1C5220DCC(&v138, (uint64_t *)&v139, v108, v108);
              ++v108;
            }
            v110 = (unsigned int *)*((_QWORD *)v106 + 1);
            if (v110)
            {
              do
              {
                v111 = v110;
                v110 = *(unsigned int **)v110;
              }
              while (v110);
            }
            else
            {
              do
              {
                v111 = (unsigned int *)*((_QWORD *)v106 + 2);
                v11 = *(_QWORD *)v111 == (_QWORD)v106;
                v106 = v111;
              }
              while (!v11);
            }
            v106 = v111;
          }
          while (v111 != (unsigned int *)v131);
        }
        sub_1C47655E8((uint64_t)&v130, v131[0]);
        v132 = &off_1E81A0B78;
        sub_1C5DEDA3C((uint64_t)&v133, v134);
        v81 = v114;
      }
      while (v140);
    }
  }
  sub_1C47655E8((uint64_t)&v138, v139);
  sub_1C5DEF350(v129[0]);
  sub_1C5DEF350(v126);
  sub_1C5245168(v124[0]);
  sub_1C5245168(v122[0]);
  sub_1C5DEDA3C((uint64_t)&v119, v120[0]);
  if (__p)
  {
    v117 = (unsigned int *)__p;
    operator delete(__p);
  }
}

uint64_t *sub_1C5DEF018(uint64_t *result, unsigned int a2, uint64_t a3)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t **v6;
  _QWORD *v7;
  unsigned int v8;
  char *v9;
  uint64_t v10;
  uint64_t *v11;

  v4 = result;
  v6 = (uint64_t **)(result + 1);
  v5 = result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (_QWORD *)v5;
        v8 = *(_DWORD *)(v5 + 32);
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = (uint64_t **)v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = (uint64_t **)(v7 + 1);
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = result + 1;
LABEL_9:
    v9 = (char *)operator new(0x40uLL);
    *((_DWORD *)v9 + 8) = *(_DWORD *)a3;
    *(_OWORD *)(v9 + 40) = *(_OWORD *)(a3 + 8);
    *((_QWORD *)v9 + 7) = *(_QWORD *)(a3 + 24);
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    *(_QWORD *)(a3 + 24) = 0;
    *(_QWORD *)v9 = 0;
    *((_QWORD *)v9 + 1) = 0;
    *((_QWORD *)v9 + 2) = v7;
    *v6 = (uint64_t *)v9;
    v10 = *(_QWORD *)*v4;
    if (v10)
    {
      *v4 = v10;
      v11 = *v6;
    }
    else
    {
      v11 = (uint64_t *)v9;
    }
    result = sub_1C4768E74((uint64_t *)v4[1], v11);
    ++v4[2];
  }
  return result;
}

uint64_t sub_1C5DEF0E8(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E81A0B78;
  sub_1C5DEDA3C(a1 + 8, *(_QWORD **)(a1 + 16));
  return a1;
}

uint64_t sub_1C5DEF120(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, _QWORD))(***(_QWORD ***)(a1 + 32) + 24))(**(_QWORD **)(a1 + 32), a2, a3, *(_QWORD *)(a1 + 40));
}

uint64_t sub_1C5DEF134(uint64_t a1, _QWORD *a2)
{
  uint64_t **v3;
  unsigned int *v4;
  unsigned int *v5;
  unsigned int *v6;
  unsigned int *v7;
  BOOL v8;
  unsigned int v9;
  uint64_t *v10;
  uint64_t **v11;
  uint64_t *v12;
  uint64_t *v13;
  unsigned int *v14;
  unsigned int *v15;
  uint64_t v16;
  _QWORD *v18;
  _QWORD *v19[2];
  unsigned int v20;

  v3 = *(uint64_t ***)(a1 + 32);
  sub_1C5220D38((uint64_t)&v18, *(_QWORD **)(a1 + 40));
  v4 = (unsigned int *)(a2 + 1);
  v5 = (unsigned int *)*a2;
  if ((_QWORD *)*a2 != a2 + 1)
  {
    do
    {
      sub_1C5220DCC(&v18, (uint64_t *)v19, v5 + 7, v5 + 7);
      v6 = (unsigned int *)*((_QWORD *)v5 + 1);
      if (v6)
      {
        do
        {
          v7 = v6;
          v6 = *(unsigned int **)v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          v7 = (unsigned int *)*((_QWORD *)v5 + 2);
          v8 = *(_QWORD *)v7 == (_QWORD)v5;
          v5 = v7;
        }
        while (!v8);
      }
      v5 = v7;
    }
    while (v7 != v4);
    v5 = (unsigned int *)*a2;
  }
  if (v5 != v4)
  {
    do
    {
      v20 = v5[7];
      v9 = v20;
      v10 = sub_1C5221B54(v3 + 13, v20, &v20)[5];
      v20 = v9;
      v11 = sub_1C5221B54(v3 + 13, v9, &v20) + 6;
      if (v10 != (uint64_t *)v11)
      {
        do
        {
          sub_1C5220DCC(&v18, (uint64_t *)v19, (unsigned int *)v10 + 7, (_DWORD *)v10 + 7);
          v12 = (uint64_t *)v10[1];
          if (v12)
          {
            do
            {
              v13 = v12;
              v12 = (uint64_t *)*v12;
            }
            while (v12);
          }
          else
          {
            do
            {
              v13 = (uint64_t *)v10[2];
              v8 = *v13 == (_QWORD)v10;
              v10 = v13;
            }
            while (!v8);
          }
          v10 = v13;
        }
        while (v13 != (uint64_t *)v11);
      }
      v14 = (unsigned int *)*((_QWORD *)v5 + 1);
      if (v14)
      {
        do
        {
          v15 = v14;
          v14 = *(unsigned int **)v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          v15 = (unsigned int *)*((_QWORD *)v5 + 2);
          v8 = *(_QWORD *)v15 == (_QWORD)v5;
          v5 = v15;
        }
        while (!v8);
      }
      v5 = v15;
    }
    while (v15 != v4);
  }
  if (sub_1C5DEDA88((uint64_t)(v3 + 4), &v18))
    goto LABEL_27;
  if (((*(uint64_t (**)(uint64_t *, _QWORD **))(**v3 + 32))(*v3, &v18) & 1) == 0)
  {
    sub_1C5DEDBBC((uint64_t)(v3 + 4), &v18, &v18);
LABEL_27:
    v16 = 0;
    goto LABEL_28;
  }
  v16 = 1;
LABEL_28:
  sub_1C47655E8((uint64_t)&v18, v19[0]);
  return v16;
}

void sub_1C5DEF308(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E81A0B78;
  sub_1C5DEDA3C(a1 + 8, *(_QWORD **)(a1 + 16));
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5DEF350(_QWORD *a1)
{
  if (a1)
  {
    sub_1C5DEF350(*a1);
    sub_1C5DEF350(a1[1]);
    sub_1C47655E8((uint64_t)(a1 + 5), (_QWORD *)a1[6]);
    operator delete(a1);
  }
}

unsigned int *llvm::caseFoldingDjbHash(unsigned int *result, char *a2, uint64_t a3)
{
  uint64_t v3;
  char *v4;
  unsigned int *v5;
  char *v6;
  char v7;
  int v8;
  int64_t v9;
  int v10;
  int64_t v11;
  unsigned __int8 *v12;
  int v13;
  _BYTE v14[4];
  char *v15;
  unsigned int *v16;
  unsigned int v17;
  llvm::sys::unicode *v18;

  v3 = a3;
  if (!a2)
    return (unsigned int *)v3;
  v4 = a2;
  v5 = result;
  v6 = 0;
  v7 = 1;
  LODWORD(result) = a3;
  do
  {
    v8 = v6[(_QWORD)v5];
    if ((v8 - 65) < 0x1A)
      v8 += 32;
    result = (unsigned int *)(v8 + 33 * (_DWORD)result);
    v7 &= (v6++)[(_QWORD)v5] >= 0;
  }
  while (a2 != v6);
  if ((v7 & 1) == 0)
  {
    do
    {
      v17 = 0;
      v15 = (char *)&v17;
      v16 = v5;
      sub_1C5DE6EDC((unint64_t *)&v16, (unsigned __int8 *)&v4[(_QWORD)v5], (unsigned int **)&v15, (unint64_t)&v18, 1, 0);
      if ((unint64_t)v4 >= (char *)v16 - (char *)v5)
        v9 = (char *)v16 - (char *)v5;
      else
        v9 = (int64_t)v4;
      if ((v17 & 0xFFFFFFFE) == 0x130)
        v10 = 105;
      else
        v10 = llvm::sys::unicode::foldCharSimple((llvm::sys::unicode *)v17);
      v17 = v10;
      v15 = v14;
      v16 = &v17;
      llvm::ConvertUTF32toUTF8(&v16, (unint64_t)&v18, (uint64_t *)&v15, (unint64_t)&v15, 0);
      v11 = v15 - v14;
      if (v15 != v14)
      {
        v12 = v14;
        do
        {
          v13 = *v12++;
          v3 = (33 * v3 + v13);
          --v11;
        }
        while (v11);
      }
      v5 = (unsigned int *)((char *)v5 + v9);
      v4 -= v9;
    }
    while (v4);
    return (unsigned int *)v3;
  }
  return result;
}

_QWORD *llvm::ELFAttributeParser::printAttribute(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _QWORD *result;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  const char *v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;

  v20 = a2 | (unint64_t)(a3 << 32);
  result = sub_1C5DF073C((uint64_t)(a1 + 3), (unsigned int *)&v20, &v20);
  v11 = a1[13];
  if (v11)
  {
    v12 = a1[15];
    if (v12)
    {
      v13 = (_QWORD *)(a1[14] + 16);
      v14 = 24 * v12;
      v15 = "";
      while (*((_DWORD *)v13 - 4) != (_DWORD)a2)
      {
        v13 += 3;
        v14 -= 24;
        if (!v14)
        {
          v16 = 0;
          goto LABEL_11;
        }
      }
      v18 = *(v13 - 1);
      v17 = *v13;
      v19 = 4;
      if (v17 < 4)
        v19 = v17;
      v15 = (const char *)(v18 + v19);
      v16 = v17 - v19;
    }
    else
    {
      v16 = 0;
      v15 = "";
    }
LABEL_11:
    (*(void (**)(_QWORD, const char *, uint64_t))(*(_QWORD *)v11 + 208))(a1[13], "Attribute", 9);
    (*(void (**)(_QWORD, const char *, uint64_t, uint64_t))(*(_QWORD *)a1[13] + 24))(a1[13], "Tag", 3, a2);
    (*(void (**)(_QWORD, const char *, uint64_t, uint64_t))(*(_QWORD *)a1[13] + 24))(a1[13], "Value", 5, a3);
    if (v16)
      (*(void (**)(_QWORD, const char *, uint64_t, const char *, unint64_t))(*(_QWORD *)a1[13] + 192))(a1[13], "TagName", 7, v15, v16);
    if (a5)
      (*(void (**)(_QWORD, const char *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1[13] + 192))(a1[13], "Description", 11, a4, a5);
    return (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v11 + 216))(v11);
  }
  return result;
}

uint64_t llvm::ELFAttributeParser::parseIndexList(uint64_t *a1, _QWORD *a2)
{
  uint64_t *v4;
  uint64_t *v5;
  _QWORD *v6;
  uint64_t result;
  BOOL v8;
  char v9;
  uint64_t v10;
  BOOL v11;

  v4 = a1 + 16;
  v5 = a1 + 19;
  v6 = a1 + 20;
  result = llvm::DataExtractor::getULEB128(a1 + 16, a1 + 19, a1 + 20);
  if (a1[20])
    v8 = 1;
  else
    v8 = result == 0;
  if (!v8)
  {
    v9 = result;
    do
    {
      v10 = a2[1];
      if ((unint64_t)(v10 + 1) > a2[2])
      {
        llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a2, a2 + 3, v10 + 1, 1);
        v10 = a2[1];
      }
      *(_BYTE *)(*a2 + v10) = v9;
      ++a2[1];
      result = llvm::DataExtractor::getULEB128(v4, v5, v6);
      v9 = result;
      if (*v6)
        v11 = 1;
      else
        v11 = result == 0;
    }
    while (!v11);
  }
  return result;
}

void llvm::ELFAttributeParser::parseSubsection(llvm::ELFAttributeParser *this@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v5;
  char *v6;
  _QWORD *v7;
  char *CStrRef;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  int v12;
  void *v13;
  _QWORD *v14;
  size_t v15;
  BOOL v16;
  unint64_t v17;
  _QWORD *v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const std::error_category *v23;
  void **v24;
  BOOL v25;
  const char *v26;
  uint64_t v27;
  uint64_t v28;
  const std::error_category *v29;
  void **v30;
  void **v31;
  const std::error_category *v32;
  void ***v33;
  uint64_t v34;
  const char *v35;
  char *v36;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40[2];
  unint64_t v41;
  __int16 v42;
  void *__p[2];
  const char *v44;
  __int16 v45;
  _QWORD v46[2];
  uint64_t *v47;
  unint64_t v48;
  __int16 v49;
  void *v50[2];
  char v51;
  void **v52;
  _BYTE *v53[2];
  void **v54;
  __int128 v55;
  _QWORD v56[3];

  v56[1] = *MEMORY[0x1E0C80C00];
  v6 = (char *)this + 152;
  v5 = *((_QWORD *)this + 19);
  v7 = (_QWORD *)((char *)this + 160);
  v36 = (char *)this + 128;
  CStrRef = (char *)llvm::DataExtractor::getCStrRef((uint64_t *)this + 16, (unint64_t *)this + 19, (uint64_t *)this + 20);
  v10 = v9;
  v11 = *((_QWORD *)v6 - 6);
  if (v11)
  {
    (*(void (**)(uint64_t, const char *, uint64_t, uint64_t))(*(_QWORD *)v11 + 24))(v11, "SectionLength", 13, a2);
    (*(void (**)(_QWORD, const char *, uint64_t, char *, unint64_t))(**((_QWORD **)this + 13) + 192))(*((_QWORD *)this + 13), "Vendor", 6, CStrRef, v10);
  }
  sub_1C5E3DEA4(v46, CStrRef, (uint64_t (*)(_QWORD))sub_1C5E3C6A8, &CStrRef[v10], (uint64_t)sub_1C5E3C6A8, v10);
  v12 = SHIBYTE(v47);
  v13 = (void *)v46[0];
  if (SHIBYTE(v47) >= 0)
    v14 = v46;
  else
    v14 = (_QWORD *)v46[0];
  if (SHIBYTE(v47) >= 0)
    v15 = HIBYTE(v47) & 0x7F;
  else
    v15 = v46[1];
  if (v15 == *((_QWORD *)this + 2))
  {
    if (v15)
    {
      v16 = memcmp(v14, *((const void **)this + 1), v15) != 0;
      if (v12 < 0)
        goto LABEL_12;
LABEL_42:
      if (!v16)
        goto LABEL_13;
      goto LABEL_43;
    }
    v16 = 0;
    if ((SHIBYTE(v47) & 0x80000000) == 0)
      goto LABEL_42;
  }
  else
  {
    v16 = 1;
    if ((SHIBYTE(v47) & 0x80000000) == 0)
      goto LABEL_42;
  }
LABEL_12:
  operator delete(v13);
  if (!v16)
  {
LABEL_13:
    v17 = v5 + a2 - 4;
    v18 = v36;
    while (1)
    {
      if (*(_QWORD *)v6 >= v17)
      {
        *a3 = 0;
        return;
      }
      v19 = sub_1C5DEAEAC(v18, (unint64_t *)v6, (uint64_t *)v6 + 1);
      v20 = sub_1C6387364((uint64_t)v18, (unint64_t *)v6, (uint64_t *)v6 + 1);
      if (*v7)
      {
        *a3 = *v7;
        *v7 = 0;
        return;
      }
      v21 = v20;
      v22 = *((_QWORD *)this + 13);
      if (v22)
      {
        sub_1C638A378(v22, v19);
        (*(void (**)(_QWORD, const char *, uint64_t, uint64_t))(**((_QWORD **)this + 13) + 24))(*((_QWORD *)this + 13), "Size", 4, v21);
      }
      if (v21 <= 4)
      {
        v32 = std::generic_category();
        v40[0] = (uint64_t)"invalid attribute size ";
        v41 = v21;
        v42 = 2051;
        __p[0] = v40;
        v44 = " at offset 0x";
        v45 = 770;
        v52 = (void **)(*(_QWORD *)v6 - 5);
        v46[0] = __p;
        v47 = (uint64_t *)&v52;
        v49 = 3586;
        llvm::Twine::str((llvm::Twine *)v46, &v54);
        if (v55 >= 0)
          v33 = &v54;
        else
          v33 = (void ***)v54;
        v50[0] = (void *)22;
        v50[1] = (void *)v32;
        v53[0] = v33;
        sub_1C5DF1730(v53, (uint64_t *)v50, a3);
        if (SHIBYTE(v55) < 0)
        {
          v31 = v54;
LABEL_48:
          operator delete(v31);
        }
        return;
      }
      v54 = (void **)v56;
      v55 = xmmword_1C6464ED0;
      if (v19 == 1)
        break;
      if (v19 == 2)
      {
        v34 = 8;
        v35 = "Sections";
        v26 = "SectionAttributes";
        v27 = 17;
        goto LABEL_34;
      }
      if (v19 == 3)
      {
        v34 = 7;
        v35 = "Symbols";
        v26 = "SymbolAttributes";
        v27 = 16;
LABEL_34:
        llvm::ELFAttributeParser::parseIndexList((uint64_t *)this, &v54);
LABEL_35:
        v28 = *((_QWORD *)this + 13);
        if (v28)
        {
          (*(void (**)(_QWORD, const char *, uint64_t))(*(_QWORD *)v28 + 208))(*((_QWORD *)this + 13), v26, v27);
          if ((_QWORD)v55)
            (*(void (**)(_QWORD, const char *, uint64_t, void **))(**((_QWORD **)this + 13) + 136))(*((_QWORD *)this + 13), v35, v34, v54);
          llvm::ELFAttributeParser::parseAttributeList(this, v21 - 5, a3);
          v25 = *a3 != 0;
          (*(void (**)(uint64_t))(*(_QWORD *)v28 + 216))(v28);
        }
        else
        {
          llvm::ELFAttributeParser::parseAttributeList(this, v21 - 5, a3);
          v25 = *a3 != 0;
        }
        v18 = v36;
        goto LABEL_27;
      }
      v23 = std::generic_category();
      v39 = v19;
      v40[0] = (uint64_t)"unrecognized tag 0x";
      v41 = (unint64_t)&v39;
      v42 = 3587;
      __p[0] = v40;
      v44 = " at offset 0x";
      v45 = 770;
      v38 = *(_QWORD *)v6 - 5;
      v46[0] = __p;
      v47 = &v38;
      v49 = 3586;
      llvm::Twine::str((llvm::Twine *)v46, v50);
      v24 = v50;
      if (v51 < 0)
        v24 = (void **)v50[0];
      v53[0] = (_BYTE *)22;
      v53[1] = v23;
      v52 = v24;
      sub_1C5DF1730((_BYTE **)&v52, (uint64_t *)v53, a3);
      if (v51 < 0)
        operator delete(v50[0]);
      v25 = 1;
LABEL_27:
      if (v54 != v56)
        free(v54);
      if (v25)
        return;
    }
    v34 = 0;
    v35 = 0;
    v26 = "FileAttributes";
    v27 = 14;
    goto LABEL_35;
  }
LABEL_43:
  v29 = std::generic_category();
  v49 = 1283;
  v46[0] = "unrecognized vendor-name: ";
  v47 = (uint64_t *)CStrRef;
  v48 = v10;
  llvm::Twine::str((llvm::Twine *)v46, __p);
  if (SHIBYTE(v44) >= 0)
    v30 = __p;
  else
    v30 = (void **)__p[0];
  v40[0] = 22;
  v40[1] = (uint64_t)v29;
  v54 = v30;
  sub_1C5DF1730((_BYTE **)&v54, v40, a3);
  if (SHIBYTE(v44) < 0)
  {
    v31 = (void **)__p[0];
    goto LABEL_48;
  }
}

void *llvm::ELFAttributeParser::parse@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, int a4@<W3>, _QWORD *a5@<X8>)
{
  uint64_t v8;
  _QWORD *v9;
  void **v10;
  unsigned int v11;
  void *v12;
  unsigned int v13;
  const std::error_category *v14;
  unint64_t v15;
  char *v16;
  BOOL v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  llvm::raw_ostream *v22;
  llvm::raw_ostream *v23;
  _QWORD *v24;
  uint64_t v25;
  _DWORD *v26;
  int v27;
  BOOL v28;
  int v29;
  llvm::raw_ostream *v30;
  _WORD *v31;
  std::string *v32;
  std::string::size_type v33;
  void **v34;
  void *v35;
  void *v36;
  void *result;
  const std::error_category *v38;
  unint64_t v39;
  char *v40;
  char v41;
  char *v42;
  std::string *v43;
  uint64_t v44[2];
  char v45;
  int v46;
  __int16 v47;
  __int128 v48;
  void *v49[2];
  std::string::size_type v50;
  __int16 v51;
  void *__p[2];
  const char *v53;
  __int16 v54;
  std::string v55;
  std::string *v56;
  _BYTE *v57[2];
  char *v58[2];
  __int128 v59;
  __int16 v60;
  int v61;
  __int16 v62;
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)(a1 + 128) = a2;
  *(_QWORD *)(a1 + 136) = a3;
  v8 = a1 + 128;
  *(_WORD *)(a1 + 144) = a4 == 1;
  v9 = (_QWORD *)(a1 + 152);
  v10 = (void **)(a1 + 160);
  v11 = sub_1C5DEAEAC((_QWORD *)(a1 + 128), (unint64_t *)(a1 + 152), (uint64_t *)(a1 + 160));
  if (v11 == 65)
  {
    if (*(_QWORD *)(a1 + 136) == *(_QWORD *)(a1 + 152))
    {
LABEL_3:
      v12 = *v10;
    }
    else
    {
      LODWORD(v18) = 0;
      while (1)
      {
        v19 = sub_1C6387364(v8, (unint64_t *)(v8 + 24), (uint64_t *)(v8 + 32));
        v12 = *v10;
        if (*v10)
          break;
        v20 = v19;
        v21 = *(_QWORD *)(a1 + 104);
        if (v21)
        {
          v22 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v21 + 248))(v21);
          v23 = v22;
          v24 = (_QWORD *)*((_QWORD *)v22 + 4);
          if (*((_QWORD *)v22 + 3) - (_QWORD)v24 > 7uLL)
          {
            *v24 = 0x206E6F6974636553;
            *((_QWORD *)v22 + 4) += 8;
          }
          else
          {
            v23 = llvm::raw_ostream::write(v22, "Section ", 8uLL);
          }
          v18 = (v18 + 1);
          sub_1C5E21910(v23, v18, 0, 0, 0);
          v25 = *((_QWORD *)v23 + 4);
          if ((unint64_t)(*((_QWORD *)v23 + 3) - v25) > 2)
          {
            *(_BYTE *)(v25 + 2) = 10;
            *(_WORD *)v25 = 31520;
            *((_QWORD *)v23 + 4) += 3;
          }
          else
          {
            llvm::raw_ostream::write(v23, " {\n", 3uLL);
          }
          ++*(_DWORD *)(*(_QWORD *)(a1 + 104) + 16);
        }
        if (v20 <= 3 || *v9 + (unint64_t)v20 - 4 > a3)
        {
          v38 = std::generic_category();
          v49[0] = "invalid section length ";
          v50 = v20;
          v51 = 2051;
          __p[0] = v49;
          v53 = " at offset 0x";
          v54 = 770;
          v39 = *v9 - 4;
          if (*v9 == 4)
          {
            v40 = (char *)&v59;
            LOBYTE(v59) = 48;
          }
          else
          {
            v40 = (char *)&v59 + 1;
            do
            {
              *--v40 = a0123456789abcd_6[v39 & 0xF];
              v17 = v39 > 0xF;
              v39 >>= 4;
            }
            while (v17);
          }
          sub_1C4E61270(v44, v40, (char *)&v59 + 1, (char *)&v59 + 1 - v40);
          v41 = v54;
          if (v54 == 1)
          {
            v58[0] = (char *)v44;
            v59 = v48;
            v60 = 260;
            v61 = v46;
            v62 = v47;
          }
          else if ((_BYTE)v54)
          {
            if (HIBYTE(v54) != 1)
              v41 = 2;
            v42 = (char *)__p;
            if (HIBYTE(v54) == 1)
              v42 = (char *)__p[0];
            v58[0] = v42;
            v58[1] = (char *)__p[1];
            *(_QWORD *)&v59 = v44;
            LOBYTE(v60) = v41;
            HIBYTE(v60) = 4;
          }
          else
          {
            v60 = 256;
          }
          llvm::Twine::str((llvm::Twine *)v58, &v55);
          if ((v55.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v43 = &v55;
          else
            v43 = (std::string *)v55.__r_.__value_.__r.__words[0];
          v57[0] = (_BYTE *)22;
          v57[1] = v38;
          v56 = v43;
          sub_1C5DF1730((_BYTE **)&v56, (uint64_t *)v57, a5);
          if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v55.__r_.__value_.__l.__data_);
          if (v45 < 0)
          {
            v35 = (void *)v44[0];
            goto LABEL_41;
          }
          goto LABEL_42;
        }
        llvm::ELFAttributeParser::parseSubsection((llvm::ELFAttributeParser *)a1, v20, a5);
        if (*a5)
          goto LABEL_42;
        v26 = *(_DWORD **)(a1 + 104);
        if (v26)
        {
          v27 = v26[4];
          v28 = __OFSUB__(v27, 1);
          v29 = v27 - 1;
          if ((v29 < 0) ^ v28 | (v29 == 0))
            v29 = 0;
          v26[4] = v29;
          v30 = (llvm::raw_ostream *)(*(uint64_t (**)(_DWORD *))(*(_QWORD *)v26 + 248))(v26);
          v31 = (_WORD *)*((_QWORD *)v30 + 4);
          if (*((_QWORD *)v30 + 3) - (_QWORD)v31 > 1uLL)
          {
            *v31 = 2685;
            *((_QWORD *)v30 + 4) += 2;
          }
          else
          {
            llvm::raw_ostream::write(v30, "}\n", 2uLL);
          }
        }
        if (*(_QWORD *)(a1 + 136) == *(_QWORD *)(a1 + 152))
          goto LABEL_3;
      }
    }
    *a5 = v12;
    *v10 = 0;
  }
  else
  {
    v13 = v11;
    v14 = std::generic_category();
    if (v13)
    {
      v15 = v13;
      v16 = (char *)&v59 + 1;
      do
      {
        *--v16 = a0123456789abcd_6[v15 & 0xF];
        v17 = v15 > 0xF;
        v15 >>= 4;
      }
      while (v17);
    }
    else
    {
      v16 = (char *)&v59;
      LOBYTE(v59) = 48;
    }
    sub_1C4E61270(&v55, v16, (char *)&v59 + 1, (char *)&v59 + 1 - v16);
    v32 = std::string::insert(&v55, 0, "unrecognized format-version: 0x");
    v33 = v32->__r_.__value_.__r.__words[2];
    *(_OWORD *)v49 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
    v50 = v33;
    v32->__r_.__value_.__l.__size_ = 0;
    v32->__r_.__value_.__r.__words[2] = 0;
    v32->__r_.__value_.__r.__words[0] = 0;
    v60 = 260;
    v58[0] = (char *)v49;
    llvm::Twine::str((llvm::Twine *)v58, __p);
    if (SHIBYTE(v53) >= 0)
      v34 = __p;
    else
      v34 = (void **)__p[0];
    v44[0] = 22;
    v44[1] = (uint64_t)v14;
    v57[0] = v34;
    sub_1C5DF1730(v57, v44, a5);
    if (SHIBYTE(v53) < 0)
      operator delete(__p[0]);
    if (SHIBYTE(v50) < 0)
      operator delete(v49[0]);
    if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0)
    {
      v35 = (void *)v55.__r_.__value_.__r.__words[0];
LABEL_41:
      operator delete(v35);
    }
  }
LABEL_42:
  v36 = *v10;
  *v10 = 0;
  __p[0] = v36;
  sub_1C4D62BD4((char **)__p, v58);
  result = __p[0];
  if (__p[0])
    return (void *)(*(uint64_t (**)(void *))(*(_QWORD *)__p[0] + 8))(__p[0]);
  return result;
}

void sub_1C5DF0164(uint64_t a1, unsigned int a2, int a3, int a4)
{
  unint64_t v4;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  uint64_t **v11;
  uint64_t *i;
  unint64_t v13;
  _QWORD *v14;
  float v15;
  float v16;
  _BOOL8 v17;
  unint64_t v18;
  unint64_t v19;
  size_t v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;

  v8 = a2;
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      v4 = a2;
      if (v9 <= a2)
        v4 = a2 % v9;
    }
    else
    {
      v4 = ((_DWORD)v9 - 1) & a2;
    }
    v11 = *(uint64_t ***)(*(_QWORD *)a1 + 8 * v4);
    if (v11)
    {
      for (i = *v11; i; i = (uint64_t *)*i)
      {
        v13 = i[1];
        if (v13 == a2)
        {
          if (*((_DWORD *)i + 4) == a2)
            return;
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9)
              v13 %= v9;
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v4)
            break;
        }
      }
    }
  }
  v14 = operator new(0x18uLL);
  *v14 = 0;
  v14[1] = v8;
  *((_DWORD *)v14 + 4) = a3;
  *((_DWORD *)v14 + 5) = a4;
  v15 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v16 = *(float *)(a1 + 32);
  if (!v9 || (float)(v16 * (float)v9) < v15)
  {
    v17 = 1;
    if (v9 >= 3)
      v17 = (v9 & (v9 - 1)) != 0;
    v18 = v17 | (2 * v9);
    v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19)
      v20 = v19;
    else
      v20 = v18;
    sub_1C5221594(a1, v20);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v9 <= v8)
        v4 = v8 % v9;
      else
        v4 = v8;
    }
    else
    {
      v4 = ((_DWORD)v9 - 1) & v8;
    }
  }
  v21 = *(_QWORD *)a1;
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v22)
  {
    *v14 = *v22;
LABEL_38:
    *v22 = v14;
    goto LABEL_39;
  }
  *v14 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v14;
  *(_QWORD *)(v21 + 8 * v4) = a1 + 16;
  if (*v14)
  {
    v23 = *(_QWORD *)(*v14 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v23 >= v9)
        v23 %= v9;
    }
    else
    {
      v23 &= v9 - 1;
    }
    v22 = (_QWORD *)(*(_QWORD *)a1 + 8 * v23);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
}

void sub_1C5DF0364(float *a1, unsigned int a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  uint64_t **v9;
  uint64_t *i;
  unint64_t v11;
  char *v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  int8x8_t prime;
  void *v19;
  _QWORD *v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;
  uint8x8_t v24;
  unint64_t v25;
  uint8x8_t v26;
  uint64_t v27;
  _QWORD *v28;
  unint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  unint64_t v32;
  _QWORD *v33;

  v6 = a2;
  v7 = *((_QWORD *)a1 + 1);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & a2;
    }
    v9 = *(uint64_t ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      for (i = *v9; i; i = (uint64_t *)*i)
      {
        v11 = i[1];
        if (v11 == a2)
        {
          if (*((_DWORD *)i + 4) == a2)
            return;
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7)
              v11 %= v7;
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3)
            break;
        }
      }
    }
  }
  v12 = (char *)operator new(0x28uLL);
  *(_QWORD *)v12 = 0;
  *((_QWORD *)v12 + 1) = v6;
  *((_DWORD *)v12 + 4) = *(_DWORD *)a3;
  *(_OWORD *)(v12 + 24) = *(_OWORD *)(a3 + 8);
  v13 = (float)(unint64_t)(*((_QWORD *)a1 + 3) + 1);
  v14 = a1[8];
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    v15 = 1;
    if (v7 >= 3)
      v15 = (v7 & (v7 - 1)) != 0;
    v16 = v15 | (2 * v7);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      prime = (int8x8_t)v17;
    else
      prime = (int8x8_t)v16;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v7 = *((_QWORD *)a1 + 1);
    }
    if (*(_QWORD *)&prime > v7)
      goto LABEL_30;
    if (*(_QWORD *)&prime < v7)
    {
      v25 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v7 < 3 || (v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
      {
        v25 = std::__next_prime(v25);
      }
      else
      {
        v27 = 1 << -(char)__clz(v25 - 1);
        if (v25 >= 2)
          v25 = v27;
      }
      if (*(_QWORD *)&prime <= v25)
        prime = (int8x8_t)v25;
      if (*(_QWORD *)&prime >= v7)
      {
        v7 = *((_QWORD *)a1 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(_QWORD *)&prime >> 61)
            sub_1C4764EE4();
          v19 = operator new(8 * *(_QWORD *)&prime);
          v20 = *(_QWORD **)a1;
          *(_QWORD *)a1 = v19;
          if (v20)
            operator delete(v20);
          v21 = 0;
          *((int8x8_t *)a1 + 1) = prime;
          do
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v21++) = 0;
          while (*(_QWORD *)&prime != v21);
          v22 = (_QWORD *)*((_QWORD *)a1 + 2);
          if (v22)
          {
            v23 = v22[1];
            v24 = (uint8x8_t)vcnt_s8(prime);
            v24.i16[0] = vaddlv_u8(v24);
            if (v24.u32[0] > 1uLL)
            {
              if (v23 >= *(_QWORD *)&prime)
                v23 %= *(_QWORD *)&prime;
            }
            else
            {
              v23 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = a1 + 4;
            v28 = (_QWORD *)*v22;
            if (*v22)
            {
              do
              {
                v29 = v28[1];
                if (v24.u32[0] > 1uLL)
                {
                  if (v29 >= *(_QWORD *)&prime)
                    v29 %= *(_QWORD *)&prime;
                }
                else
                {
                  v29 &= *(_QWORD *)&prime - 1;
                }
                if (v29 != v23)
                {
                  if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v29))
                  {
                    *(_QWORD *)(*(_QWORD *)a1 + 8 * v29) = v22;
                    goto LABEL_55;
                  }
                  *v22 = *v28;
                  *v28 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v29);
                  **(_QWORD **)(*(_QWORD *)a1 + 8 * v29) = v28;
                  v28 = v22;
                }
                v29 = v23;
LABEL_55:
                v22 = v28;
                v28 = (_QWORD *)*v28;
                v23 = v29;
              }
              while (v28);
            }
          }
          v7 = (unint64_t)prime;
          goto LABEL_59;
        }
        v33 = *(_QWORD **)a1;
        *(_QWORD *)a1 = 0;
        if (v33)
          operator delete(v33);
        v7 = 0;
        *((_QWORD *)a1 + 1) = 0;
      }
    }
LABEL_59:
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & v6;
    }
  }
  v30 = *(_QWORD **)a1;
  v31 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v31)
  {
    *(_QWORD *)v12 = *v31;
LABEL_72:
    *v31 = v12;
    goto LABEL_73;
  }
  *(_QWORD *)v12 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = v12;
  v30[v3] = a1 + 4;
  if (*(_QWORD *)v12)
  {
    v32 = *(_QWORD *)(*(_QWORD *)v12 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7)
        v32 %= v7;
    }
    else
    {
      v32 &= v7 - 1;
    }
    v31 = (_QWORD *)(*(_QWORD *)a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  ++*((_QWORD *)a1 + 3);
}

_QWORD *sub_1C5DF073C(uint64_t a1, unsigned int *a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  void **v9;
  _QWORD *v10;
  unint64_t v11;
  float v12;
  float v13;
  _BOOL8 v14;
  unint64_t v15;
  unint64_t v16;
  size_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;

  v6 = *a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = *a2;
      if (v7 <= v6)
        v3 = v6 % v7;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & v6;
    }
    v9 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == (_DWORD)v6)
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  v10 = operator new(0x18uLL);
  *v10 = 0;
  v10[1] = v6;
  v10[2] = *a3;
  v12 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    v14 = 1;
    if (v7 >= 3)
      v14 = (v7 & (v7 - 1)) != 0;
    v15 = v14 | (2 * v7);
    v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16)
      v17 = v16;
    else
      v17 = v15;
    sub_1C5221594(a1, v17);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & v6;
    }
  }
  v18 = *(_QWORD *)a1;
  v19 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v19)
  {
    *v10 = *v19;
LABEL_38:
    *v19 = v10;
    goto LABEL_39;
  }
  *v10 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v10;
  *(_QWORD *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    v20 = *(_QWORD *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7)
        v20 %= v7;
    }
    else
    {
      v20 &= v7 - 1;
    }
    v19 = (_QWORD *)(*(_QWORD *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v10;
}

const char *llvm::ELFAttrs::attrTypeAsString(int a1, uint64_t a2, uint64_t a3, char a4)
{
  _QWORD *v5;
  uint64_t v6;
  const char *result;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;

  if (!a3)
    return "";
  v5 = (_QWORD *)(a2 + 16);
  v6 = 24 * a3;
  result = "";
  while (*((_DWORD *)v5 - 4) != a1)
  {
    v5 += 3;
    v6 -= 24;
    if (!v6)
      return result;
  }
  v8 = *(v5 - 1);
  v9 = *v5;
  v10 = 4;
  if (v9 < 4)
    v10 = v9;
  if ((a4 & 1) != 0)
    return (const char *)v8;
  else
    return (const char *)(v8 + v10);
}

uint64_t llvm::ELFAttrs::attrTypeFromString(_DWORD *__s2, size_t __n, uint64_t a3, uint64_t a4)
{
  unint64_t v6;
  unint64_t *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (__n >= 4)
  {
    v6 = 4 * (*__s2 != 1600610644);
    if (!a4)
    {
LABEL_13:
      v10 = 0;
      v11 = 0;
      return v11 | v10;
    }
  }
  else
  {
    v6 = 4;
    if (!a4)
      goto LABEL_13;
  }
  v7 = (unint64_t *)(a3 + 16);
  v8 = 24 * a4;
  while (1)
  {
    v9 = *v7 >= v6 ? v6 : *v7;
    if (*v7 - v9 == __n && (!__n || !memcmp((const void *)(*(v7 - 1) + v9), __s2, __n)))
      break;
    v7 += 3;
    v8 -= 24;
    if (!v8)
      goto LABEL_13;
  }
  v11 = *((unsigned int *)v7 - 4);
  v10 = 0x100000000;
  return v11 | v10;
}

void llvm::logAllUnhandledErrors(_QWORD *a1, llvm::raw_ostream *a2, uint64_t a3)
{
  uint64_t v6;
  _QWORD *v7;
  char **v8;
  char **v9;
  char *v10;
  char *v11;
  _BYTE *v12;
  _BYTE *v13;
  char *v14;
  char *v15;
  char *v16;

  if (*a1)
  {
    llvm::Twine::printOneChild((uint64_t)a1, a2, *(_QWORD *)a3, *(_QWORD *)(a3 + 8), *(_BYTE *)(a3 + 32));
    llvm::Twine::printOneChild(v6, a2, *(_QWORD *)(a3 + 16), *(_QWORD *)(a3 + 24), *(_BYTE *)(a3 + 33));
    v7 = (_QWORD *)*a1;
    *a1 = 0;
    if (v7)
    {
      if ((*(unsigned int (**)(_QWORD *, void *))(*v7 + 48))(v7, &llvm::ErrorList::ID))
      {
        v8 = (char **)v7[1];
        v9 = (char **)v7[2];
        if (v8 != v9)
        {
          v10 = 0;
          do
          {
            v15 = v10;
            v11 = *v8;
            *v8 = 0;
            if ((*(unsigned int (**)(char *, void *))(*(_QWORD *)v11 + 48))(v11, &llvm::ErrorInfoBase::ID))
            {
              (*(void (**)(char *, llvm::raw_ostream *))(*(_QWORD *)v11 + 16))(v11, a2);
              v12 = (_BYTE *)*((_QWORD *)a2 + 4);
              if (*((_BYTE **)a2 + 3) == v12)
              {
                llvm::raw_ostream::write(a2, "\n", 1uLL);
              }
              else
              {
                *v12 = 10;
                ++*((_QWORD *)a2 + 4);
              }
              v14 = 0;
              (*(void (**)(char *))(*(_QWORD *)v11 + 8))(v11);
            }
            else
            {
              v14 = v11;
            }
            sub_1C6174794(&v15, &v14, &v16);
            v10 = v16;
            v16 = 0;
            if (v14)
              (*(void (**)(char *))(*(_QWORD *)v14 + 8))(v14);
            if (v15)
              (*(void (**)(char *))(*(_QWORD *)v15 + 8))(v15);
            ++v8;
          }
          while (v8 != v9);
        }
      }
      else
      {
        if (!(*(unsigned int (**)(_QWORD *, void *))(*v7 + 48))(v7, &llvm::ErrorInfoBase::ID))
          return;
        (*(void (**)(_QWORD *, llvm::raw_ostream *))(*v7 + 16))(v7, a2);
        v13 = (_BYTE *)*((_QWORD *)a2 + 4);
        if (*((_BYTE **)a2 + 3) == v13)
        {
          llvm::raw_ostream::write(a2, "\n", 1uLL);
        }
        else
        {
          *v13 = 10;
          ++*((_QWORD *)a2 + 4);
        }
      }
      (*(void (**)(_QWORD *))(*v7 + 8))(v7);
    }
  }
}

uint64_t llvm::inconvertibleErrorCode(llvm *this)
{
  if (!atomic_load(qword_1ED836B58))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED836B58, (void *(*)(void))sub_1C5DF15F0, (void (*)(void *))sub_1C5DF1624);
  return 3;
}

uint64_t llvm::FileError::convertToErrorCode(llvm::FileError *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 6) + 32))(*((_QWORD *)this + 6));
  v3 = v2;
  if (!atomic_load(qword_1ED836B58))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED836B58, (void *(*)(void))sub_1C5DF15F0, (void (*)(void *))sub_1C5DF1624);
  if (v3 == qword_1ED836B58[0] && v1 == 3)
  {
    if (!atomic_load(qword_1ED836B58))
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED836B58, (void *(*)(void))sub_1C5DF15F0, (void (*)(void *))sub_1C5DF1624);
    return 2;
  }
  return v1;
}

_QWORD *llvm::errorCodeToError@<X0>(llvm *this@<X0>, std::error_code a2@<0:X1, 8:X2>, _QWORD *a3@<X8>)
{
  uint64_t v5;
  _QWORD *result;

  if ((_DWORD)this)
  {
    v5 = *(_QWORD *)&a2.__val_;
    result = (_QWORD *)operator new();
    *result = &off_1E81A0D28;
    result[1] = this;
    result[2] = v5;
  }
  else
  {
    result = 0;
  }
  *a3 = result;
  return result;
}

uint64_t llvm::errorToErrorCode(_QWORD **a1)
{
  _QWORD *v2;
  char **v3;
  char **v4;
  std::string::size_type v5;
  char *v6;
  const std::error_category *v7;
  const std::error_category *v8;
  std::string v12;
  _QWORD v13[4];
  __int16 v14;
  std::error_code v15;
  char *v16;

  v15.__val_ = 0;
  v15.__cat_ = std::system_category();
  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if ((*(unsigned int (**)(_QWORD *, void *))(*v2 + 48))(v2, &llvm::ErrorList::ID))
    {
      v3 = (char **)v2[1];
      v4 = (char **)v2[2];
      if (v3 != v4)
      {
        v5 = 0;
        do
        {
          v12.__r_.__value_.__r.__words[0] = v5;
          v6 = *v3;
          *v3 = 0;
          if ((*(unsigned int (**)(char *, void *))(*(_QWORD *)v6 + 48))(v6, &llvm::ErrorInfoBase::ID))
          {
            *(_QWORD *)&v15.__val_ = (*(uint64_t (**)(char *))(*(_QWORD *)v6 + 32))(v6);
            v15.__cat_ = v7;
            (*(void (**)(char *))(*(_QWORD *)v6 + 8))(v6);
            v6 = 0;
          }
          v16 = v6;
          sub_1C6174794(&v12.__r_.__value_.__l.__data_, &v16, v13);
          v5 = v13[0];
          v13[0] = 0;
          if (v16)
            (*(void (**)(char *))(*(_QWORD *)v16 + 8))(v16);
          if (v12.__r_.__value_.__r.__words[0])
            (*(void (**)(std::string::size_type))(*(_QWORD *)v12.__r_.__value_.__l.__data_ + 8))(v12.__r_.__value_.__r.__words[0]);
          ++v3;
        }
        while (v3 != v4);
      }
    }
    else
    {
      if (!(*(unsigned int (**)(_QWORD *, void *))(*v2 + 48))(v2, &llvm::ErrorInfoBase::ID))
        goto LABEL_16;
      *(_QWORD *)&v15.__val_ = (*(uint64_t (**)(_QWORD *))(*v2 + 32))(v2);
      v15.__cat_ = v8;
    }
    (*(void (**)(_QWORD *))(*v2 + 8))(v2);
  }
LABEL_16:
  if (!atomic_load(qword_1ED836B58))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED836B58, (void *(*)(void))sub_1C5DF15F0, (void (*)(void *))sub_1C5DF1624);
  if (v15.__cat_ == (const std::error_category *)qword_1ED836B58[0] && v15.__val_ == 3)
  {
    std::error_code::message(&v12, &v15);
    v14 = 260;
    v13[0] = &v12;
    llvm::report_fatal_error((uint64_t)v13, 1);
  }
  return *(_QWORD *)&v15.__val_;
}

uint64_t llvm::StringError::StringError(uint64_t a1, uint64_t a2, uint64_t a3, llvm::Twine *a4)
{
  *(_QWORD *)a1 = off_1E81A0C88;
  llvm::Twine::str(a4, (_QWORD *)(a1 + 8));
  *(_QWORD *)(a1 + 32) = a2;
  *(_QWORD *)(a1 + 40) = a3;
  *(_BYTE *)(a1 + 48) = 0;
  return a1;
}

uint64_t llvm::StringError::StringError(uint64_t a1, llvm::Twine *a2, uint64_t a3, uint64_t a4)
{
  *(_QWORD *)a1 = off_1E81A0C88;
  llvm::Twine::str(a2, (_QWORD *)(a1 + 8));
  *(_QWORD *)(a1 + 32) = a3;
  *(_QWORD *)(a1 + 40) = a4;
  *(_BYTE *)(a1 + 48) = 1;
  return a1;
}

{
  *(_QWORD *)a1 = off_1E81A0C88;
  llvm::Twine::str(a2, (_QWORD *)(a1 + 8));
  *(_QWORD *)(a1 + 32) = a3;
  *(_QWORD *)(a1 + 40) = a4;
  *(_BYTE *)(a1 + 48) = 1;
  return a1;
}

void llvm::StringError::log(llvm::StringError *this, llvm::raw_ostream *a2)
{
  char v4;
  int v5;
  const char *v6;
  size_t v7;
  size_t v8;
  std::string *v9;
  size_t size;
  std::string *v11;
  size_t v12;
  std::string v13;

  if (*((_BYTE *)this + 48))
  {
    v4 = *((_BYTE *)this + 31);
    v5 = v4;
    if (v4 >= 0)
      v6 = (char *)this + 8;
    else
      v6 = (const char *)*((_QWORD *)this + 1);
    v7 = v4 & 0x7F;
    if (v5 >= 0)
      v8 = v7;
    else
      v8 = *((_QWORD *)this + 2);
    llvm::raw_ostream::write(a2, v6, v8);
  }
  else
  {
    std::error_code::message(&v13, (const std::error_code *)this + 2);
    if ((v13.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v9 = &v13;
    else
      v9 = (std::string *)v13.__r_.__value_.__r.__words[0];
    if ((v13.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = *((_BYTE *)&v13.__r_.__value_.__s + 23) & 0x7F;
    else
      size = v13.__r_.__value_.__l.__size_;
    llvm::raw_ostream::write(a2, (const char *)v9, size);
    if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v13.__r_.__value_.__l.__data_);
    if (*((char *)this + 31) < 0)
    {
      if (!*((_QWORD *)this + 2))
        return;
    }
    else if (!*((_BYTE *)this + 31))
    {
      return;
    }
    std::operator+<char>();
    if ((v13.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v11 = &v13;
    else
      v11 = (std::string *)v13.__r_.__value_.__r.__words[0];
    if ((v13.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v12 = *((_BYTE *)&v13.__r_.__value_.__s + 23) & 0x7F;
    else
      v12 = v13.__r_.__value_.__l.__size_;
    llvm::raw_ostream::write(a2, (const char *)v11, v12);
    if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v13.__r_.__value_.__l.__data_);
  }
}

void llvm::report_fatal_error(uint64_t *a1)
{
  _WORD v1[20];
  uint64_t v2;
  _QWORD *v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  uint64_t v9;
  int v10;
  _QWORD *v11;
  _QWORD v12[3];

  memset(v12, 0, sizeof(v12));
  v4 = 0;
  v8 = 0;
  v9 = 0;
  v11 = v12;
  v10 = 0;
  v6 = 0;
  v7 = 0;
  v5 = 0;
  v2 = *a1;
  v3 = &unk_1E81A7208;
  *a1 = 0;
  v1[16] = 257;
  llvm::logAllUnhandledErrors(&v2, (llvm::raw_ostream *)&v3, (uint64_t)v1);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  sub_1C638A4B8((uint64_t)&v3);
  LOWORD(v7) = 260;
  v3 = v12;
  llvm::report_fatal_error((uint64_t)&v3, 1);
}

uint64_t LLVMGetErrorTypeId(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
}

char *LLVMConsumeError(char *a1)
{
  char *result;
  char *v2;
  char *v3;

  v2 = a1;
  sub_1C4D62BD4(&v2, &v3);
  result = v2;
  if (v2)
    return (char *)(*(uint64_t (**)(char *))(*(_QWORD *)v2 + 8))(v2);
  return result;
}

_BYTE *LLVMGetErrorMessage(char *a1)
{
  _BYTE *v1;
  _BYTE *v2;
  int v3;
  void *v4;
  std::string *v5;
  std::string::size_type size;
  char *v8;
  std::string v9;

  v8 = a1;
  sub_1C61D2548(&v8, &v9);
  if (v8)
    (*(void (**)(char *))(*(_QWORD *)v8 + 8))(v8);
  v1 = (_BYTE *)operator new[]();
  v2 = v1;
  v3 = SHIBYTE(v9.__r_.__value_.__r.__words[2]);
  v4 = (void *)v9.__r_.__value_.__r.__words[0];
  if ((v9.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v5 = &v9;
  else
    v5 = (std::string *)v9.__r_.__value_.__r.__words[0];
  if ((v9.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v9.__r_.__value_.__r.__words[2]);
  else
    size = v9.__r_.__value_.__l.__size_;
  memcpy(v1, v5, size);
  v2[size] = 0;
  if (v3 < 0)
    operator delete(v4);
  return v2;
}

uint64_t LLVMDisposeErrorMessage(uint64_t result)
{
  if (result)
    JUMPOUT(0x1CAA32F9CLL);
  return result;
}

void *LLVMGetStringErrorTypeId()
{
  return &llvm::StringError::ID;
}

_QWORD *LLVMCreateStringError(_BYTE *a1)
{
  unint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  char v6;
  _BYTE *v8;
  char v9;
  char v10;

  if (!atomic_load(qword_1ED836B58))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED836B58, (void *(*)(void))sub_1C5DF15F0, (void (*)(void *))sub_1C5DF1624);
  v3 = qword_1ED836B58[0];
  v4 = (_QWORD *)operator new();
  v5 = v4;
  v10 = 1;
  if (*a1)
  {
    v8 = a1;
    v6 = 3;
  }
  else
  {
    v6 = 1;
  }
  v9 = v6;
  *v4 = off_1E81A0C88;
  llvm::Twine::str((llvm::Twine *)&v8, v4 + 1);
  v5[4] = 3;
  v5[5] = v3;
  *((_BYTE *)v5 + 48) = 1;
  return v5;
}

BOOL sub_1C5DF1460(uint64_t a1, void *a2)
{
  return a2 == &llvm::ErrorInfoBase::ID;
}

void sub_1C5DF1474()
{
  JUMPOUT(0x1CAA32FC0);
}

BOOL sub_1C5DF1488(uint64_t a1, void *a2)
{
  return a2 == &llvm::ECError::ID || a2 == &llvm::ErrorInfoBase::ID;
}

uint64_t sub_1C5DF14A8(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 48) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  return a1;
}

void sub_1C5DF14F0(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 48) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C5DF1548(uint64_t a1)
{
  *(_QWORD *)a1 = off_1E81A0C88;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  return a1;
}

void sub_1C5DF1584(uint64_t a1)
{
  *(_QWORD *)a1 = off_1E81A0C88;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  JUMPOUT(0x1CAA32FC0);
}

BOOL sub_1C5DF15D0(uint64_t a1, void *a2)
{
  return a2 == &llvm::StringError::ID || a2 == &llvm::ErrorInfoBase::ID;
}

_QWORD *sub_1C5DF15F0()
{
  _QWORD *result;

  result = (_QWORD *)operator new();
  *result = &off_1E81A0D78;
  return result;
}

uint64_t sub_1C5DF1624(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1C5DF163C(std::error_category *a1)
{
  std::error_category::~error_category(a1);
  JUMPOUT(0x1CAA32FC0);
}

const char *sub_1C5DF1660()
{
  return "Error";
}

void sub_1C5DF166C(int a1@<W1>, uint64_t a2@<X8>)
{
  char *v3;

  if (a1 == 3)
  {
    v3 = (char *)operator new(0x80uLL);
    *(_QWORD *)a2 = v3;
    *(_OWORD *)(a2 + 8) = xmmword_1C866F8E0;
    strcpy(v3, "Inconvertible error value. An error has occurred that could not be converted to a known std::error_code. Please file a bug.");
  }
  else if (a1 == 2)
  {
    strcpy((char *)a2, "A file error occurred.");
    *(_BYTE *)(a2 + 23) = 22;
  }
  else
  {
    *(_BYTE *)(a2 + 23) = 15;
    strcpy((char *)a2, "Multiple errors");
  }
}

void sub_1C5DF1730(_BYTE **a1@<X0>, uint64_t *a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *v7;
  _BYTE *v8;
  char v9;
  uint64_t v10;
  uint64_t v11;
  _BYTE *v12;
  char v13;
  char v14;

  v6 = (_QWORD *)operator new();
  v7 = v6;
  v8 = *a1;
  v14 = 1;
  if (*v8)
  {
    v12 = v8;
    v9 = 3;
  }
  else
  {
    v9 = 1;
  }
  v13 = v9;
  v11 = *a2;
  v10 = a2[1];
  *v6 = off_1E81A0C88;
  llvm::Twine::str((llvm::Twine *)&v12, v6 + 1);
  v7[4] = v11;
  v7[5] = v10;
  *((_BYTE *)v7 + 48) = 1;
  *a3 = v7;
}

void llvm::report_fatal_error(uint64_t a1, uint64_t a2)
{
  uint64_t (*v4)(uint64_t, void *, uint64_t);
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  llvm::sys *v9;
  void *p_p;
  _QWORD v11[2];
  uint64_t v12;
  _BYTE *v13;
  _BYTE *v14;
  int v15;
  uint64_t v16;
  void *__p;
  __int128 v18;
  _BYTE v19[64];

  std::mutex::lock(&stru_1ED7EAED0);
  v4 = (uint64_t (*)(uint64_t, void *, uint64_t))off_1ED836B70;
  v5 = qword_1ED836B78;
  std::mutex::unlock(&stru_1ED7EAED0);
  if (v4)
  {
    llvm::Twine::str((llvm::Twine *)a1, &__p);
    if (v18 >= 0)
      p_p = &__p;
    else
      p_p = __p;
    v9 = (llvm::sys *)v4(v5, p_p, a2);
    if (SHIBYTE(v18) < 0)
      operator delete(__p);
  }
  else
  {
    __p = v19;
    v18 = xmmword_1C64638C0;
    v6 = sub_1C613932C((uint64_t)v11, (uint64_t)&__p);
    v7 = v14;
    if ((unint64_t)(v13 - v14) > 0xB)
    {
      *((_DWORD *)v14 + 2) = 540693071;
      *v7 = *(_QWORD *)"LLVM ERROR: ";
      v14 += 12;
    }
    else
    {
      v6 = (uint64_t)llvm::raw_ostream::write((llvm::raw_ostream *)v11, "LLVM ERROR: ", 0xCuLL);
    }
    llvm::Twine::printOneChild(v6, (llvm::raw_ostream *)v11, *(_QWORD *)a1, *(_QWORD *)(a1 + 8), *(_BYTE *)(a1 + 32));
    llvm::Twine::printOneChild(v8, (llvm::raw_ostream *)v11, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), *(_BYTE *)(a1 + 33));
    if (v13 == v14)
      llvm::raw_ostream::write((llvm::raw_ostream *)v11, "\n", 1uLL);
    else
      *v14++ = 10;
    write(2, *(const void **)v16, *(_QWORD *)(v16 + 8));
    v11[0] = off_1E81A6E70;
    if (v15 == 1 && v12)
      MEMORY[0x1CAA32F9C](v12, 0x1000C8077774924);
    v9 = (llvm::sys *)__p;
    if (__p != v19)
      free(__p);
  }
  llvm::sys::RunInterruptHandlers(v9);
  abort();
}

void llvm::install_bad_alloc_error_handler(llvm *this, void (*a2)(void *, const char *, BOOL), void *a3)
{
  std::mutex::lock(&stru_1EF8EE8A0);
  off_1EF8F72E0 = this;
  qword_1EF8F72E8 = (uint64_t)a2;
  std::mutex::unlock(&stru_1EF8EE8A0);
}

void llvm::remove_bad_alloc_error_handler(llvm *this)
{
  std::mutex::lock(&stru_1EF8EE8A0);
  off_1EF8F72E0 = 0;
  qword_1EF8F72E8 = 0;
  std::mutex::unlock(&stru_1EF8EE8A0);
}

void sub_1C5DF1A1C()
{
  llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
}

void LLVMInstallFatalErrorHandler(uint64_t a1)
{
  std::mutex::lock(&stru_1ED7EAED0);
  off_1ED836B70 = sub_1C5DF1A7C;
  qword_1ED836B78 = a1;
  std::mutex::unlock(&stru_1ED7EAED0);
}

uint64_t sub_1C5DF1A7C(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

void LLVMResetFatalErrorHandler()
{
  std::mutex::lock(&stru_1ED7EAED0);
  off_1ED836B70 = 0;
  qword_1ED836B78 = 0;
  std::mutex::unlock(&stru_1ED7EAED0);
}

uint64_t sub_1C5DF1AC4()
{
  void (*v0)(void *);

  v0 = (void (*)(void *))MEMORY[0x1E0DE4AB8];
  __cxa_atexit((void (*)(void *))MEMORY[0x1E0DE4AB8], &stru_1ED7EAED0, &dword_1C475E000);
  return __cxa_atexit(v0, &stru_1EF8EE8A0, &dword_1C475E000);
}

BOOL sub_1C5DF1B18(uint64_t a1, void *a2)
{
  return a2 == &llvm::RTTIRoot::ID;
}

double llvm::FileCollectorBase::FileCollectorBase(llvm::FileCollectorBase *this)
{
  double result;

  *(_QWORD *)this = off_1E81A0E98;
  *((_QWORD *)this + 1) = 850045863;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *(_OWORD *)((char *)this + 76) = 0u;
  *((_DWORD *)this + 23) = 8;
  return result;
}

void llvm::FileCollectorBase::~FileCollectorBase(llvm::FileCollectorBase *this)
{
  std::mutex *v1;

  *(_QWORD *)this = off_1E81A0E98;
  v1 = (std::mutex *)((char *)this + 8);
  sub_1C4F02264((uint64_t)this + 72);
  std::mutex::~mutex(v1);
}

void llvm::FileCollectorBase::addFile(uint64_t a1, llvm::Twine *a2)
{
  std::mutex *v4;
  char v5;
  size_t v6;
  unsigned __int8 *v7;
  char v8;
  void *p_p;
  size_t v10;
  void *__p;
  size_t v12;
  char v13;

  v4 = (std::mutex *)(a1 + 8);
  std::mutex::lock((std::mutex *)(a1 + 8));
  llvm::Twine::str(a2, &__p);
  v5 = v13;
  if (v13 >= 0)
    v6 = v13 & 0x7F;
  else
    v6 = v12;
  if (v6)
  {
    v7 = v13 >= 0 ? (unsigned __int8 *)&__p : (unsigned __int8 *)__p;
    sub_1C4F024D8((llvm::StringMapImpl *)(a1 + 72), v7, v6);
    v5 = v13;
    if ((v8 & 1) != 0)
    {
      if (v13 >= 0)
        p_p = &__p;
      else
        p_p = __p;
      if (v13 >= 0)
        v10 = v13 & 0x7F;
      else
        v10 = v12;
      (*(void (**)(uint64_t, void *, size_t))(*(_QWORD *)a1 + 16))(a1, p_p, v10);
      v5 = v13;
    }
  }
  if (v5 < 0)
    operator delete(__p);
  std::mutex::unlock(v4);
}

uint64_t llvm::FileCollectorBase::addDirectory(uint64_t a1, uint64_t a2)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t result;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  int v14;
  const std::error_category *v15;

  v14 = 0;
  v15 = std::system_category();
  llvm::vfs::getRealFileSystem(&v11);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, uint64_t *, int *))(*(_QWORD *)a1 + 24))(&v12, a1, a2, &v11, &v14);
  v4 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  result = v11;
  if (v11)
  {
    v8 = (unsigned int *)(v11 + 8);
    do
    {
      v9 = __ldaxr(v8);
      v10 = v9 - 1;
    }
    while (__stlxr(v10, v8));
    if (!v10)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

double llvm::FileCollector::FileCollector(uint64_t a1, __int128 *a2, __int128 *a3)
{
  double result;
  __int128 v4;
  __int128 v5;

  result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 76) = 0u;
  *(_DWORD *)(a1 + 92) = 8;
  *(_QWORD *)a1 = off_1E81A0EC8;
  *(_QWORD *)(a1 + 8) = 850045863;
  v4 = *a2;
  *(_QWORD *)(a1 + 120) = *((_QWORD *)a2 + 2);
  *(_OWORD *)(a1 + 104) = v4;
  *((_QWORD *)a2 + 1) = 0;
  *((_QWORD *)a2 + 2) = 0;
  *(_QWORD *)a2 = 0;
  v5 = *a3;
  *(_QWORD *)(a1 + 144) = *((_QWORD *)a3 + 2);
  *(_OWORD *)(a1 + 128) = v5;
  *((_QWORD *)a3 + 1) = 0;
  *((_QWORD *)a3 + 2) = 0;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 174) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 212) = 0u;
  *(_DWORD *)(a1 + 228) = 32;
  return result;
}

{
  double result;
  __int128 v4;
  __int128 v5;

  result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 76) = 0u;
  *(_DWORD *)(a1 + 92) = 8;
  *(_QWORD *)a1 = off_1E81A0EC8;
  *(_QWORD *)(a1 + 8) = 850045863;
  v4 = *a2;
  *(_QWORD *)(a1 + 120) = *((_QWORD *)a2 + 2);
  *(_OWORD *)(a1 + 104) = v4;
  *((_QWORD *)a2 + 1) = 0;
  *((_QWORD *)a2 + 2) = 0;
  *(_QWORD *)a2 = 0;
  v5 = *a3;
  *(_QWORD *)(a1 + 144) = *((_QWORD *)a3 + 2);
  *(_OWORD *)(a1 + 128) = v5;
  *((_QWORD *)a3 + 1) = 0;
  *((_QWORD *)a3 + 2) = 0;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 174) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 212) = 0u;
  *(_DWORD *)(a1 + 228) = 32;
  return result;
}

void llvm::FileCollector::PathCanonicalizer::updateWithRealPath(unsigned int *a1, _QWORD *a2)
{
  unsigned __int8 *v3;
  unint64_t v4;
  unint64_t v5;
  size_t v6;
  size_t v7;
  unsigned __int8 *v8;
  uint64_t v9;
  int v10;
  size_t v11;
  unsigned __int8 *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  const void *v22;
  const void *v23;
  char v24;
  const void *v25;
  unint64_t v26;
  unint64_t v27;
  size_t v28;
  size_t v29;
  _QWORD *v30;
  uint64_t v31;
  _QWORD *v32;
  size_t v33;
  size_t v34;
  void *v35;
  __int128 *p_dst;
  size_t v37;
  size_t v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  size_t v42;
  void **v44;
  __int16 v45;
  _QWORD *v46;
  __int16 v47;
  _QWORD *v48;
  __int16 v49;
  __int128 __dst;
  unint64_t v51;
  __int16 v52;
  void *__src;
  size_t __len[2];
  _QWORD v55[2];
  int v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v3 = (unsigned __int8 *)*a2;
  v4 = a2[1];
  __len[1] = 0;
  v55[0] = 0;
  __src = v3;
  __len[0] = v4;
  v55[1] = v4;
  v56 = 0;
  llvm::sys::path::reverse_iterator::operator++((uint64_t)&__src);
  v41 = v55[0];
  v42 = __len[1];
  v5 = sub_1C5E7BE8C(v3, v4, 0);
  if (v4 >= v5)
    v6 = v5;
  else
    v6 = v4;
  if (v5 == -1)
    v7 = 0;
  else
    v7 = v6;
  if (v5 == -1)
    v8 = 0;
  else
    v8 = v3;
  __src = v55;
  *(_OWORD *)__len = xmmword_1C64638F0;
  v9 = a1[2];
  if (!(_DWORD)v9)
    goto LABEL_34;
  v10 = 0;
  if (v7)
  {
    v11 = v7;
    v12 = v8;
    do
    {
      v13 = *v12++;
      v10 = 33 * v10 + v13;
      --v11;
    }
    while (v11);
  }
  v14 = *(_QWORD *)a1;
  v15 = *(_QWORD *)a1 + 8 * v9 + 8;
  v16 = 1;
  v17 = v10;
  while (1)
  {
    v18 = v17 & (v9 - 1);
    v19 = *(_QWORD **)(v14 + 8 * v18);
    if (v19 != (_QWORD *)-8)
    {
      if (!v19)
        goto LABEL_34;
      if (*(_DWORD *)(v15 + 4 * v18) == v10 && v7 == *v19 && (!v7 || !memcmp(v8, (char *)v19 + a1[5], v7)))
        break;
    }
    v17 = v16 + v18;
    ++v16;
  }
  if ((_DWORD)v18 == -1 || (int)v18 == v9)
  {
LABEL_34:
    v52 = 261;
    *(_QWORD *)&__dst = v8;
    *((_QWORD *)&__dst + 1) = v7;
    if (llvm::sys::fs::real_path((unsigned __int8 *)&__dst, &__src, 0))
      goto LABEL_47;
    v34 = __len[0];
    if (__len[0] >= 0x7FFFFFFFFFFFFFF8)
      abort();
    v35 = __src;
    if (__len[0] >= 0x17)
    {
      v37 = (__len[0] & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((__len[0] | 7) != 0x17)
        v37 = __len[0] | 7;
      v38 = v37 + 1;
      p_dst = (__int128 *)operator new(v37 + 1);
      *((_QWORD *)&__dst + 1) = v34;
      v51 = v38 | 0x8000000000000000;
      *(_QWORD *)&__dst = p_dst;
      v33 = v42;
      v32 = a2;
    }
    else
    {
      HIBYTE(v51) = __len[0];
      p_dst = &__dst;
      v33 = v42;
      v32 = a2;
      if (!__len[0])
        goto LABEL_43;
    }
    memmove(p_dst, v35, v34);
LABEL_43:
    *((_BYTE *)p_dst + v34) = 0;
    v39 = sub_1C5426790((llvm::StringMapImpl *)a1, v8, v7);
    v40 = *v39 + 8;
    if (*(char *)(*v39 + 31) < 0)
      operator delete(*(void **)v40);
    *(_OWORD *)v40 = __dst;
    *(_QWORD *)(v40 + 16) = v51;
    v31 = v41;
    goto LABEL_46;
  }
  v20 = *(_QWORD *)(v14 + 8 * (int)v18);
  v23 = *(const void **)(v20 + 8);
  v21 = v20 + 8;
  v22 = v23;
  v24 = *(_BYTE *)(v21 + 23);
  if (v24 >= 0)
    v25 = (const void *)v21;
  else
    v25 = v22;
  v26 = *(_QWORD *)(v21 + 8);
  if (v24 >= 0)
    v27 = v24 & 0x7F;
  else
    v27 = v26;
  if (v27 >= 0x101)
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&__src, v55, v27, 1);
    v30 = __src;
    v28 = __len[0];
    v31 = v41;
    goto LABEL_32;
  }
  v28 = 0;
  v29 = 0;
  v30 = v55;
  v31 = v41;
  if (v27)
  {
LABEL_32:
    memcpy((char *)v30 + v28, v25, v27);
    v29 = __len[0];
  }
  __len[0] = v29 + v27;
  v33 = v42;
  v32 = a2;
LABEL_46:
  v52 = 261;
  *(_QWORD *)&__dst = v33;
  *((_QWORD *)&__dst + 1) = v31;
  v49 = 257;
  v47 = 257;
  v45 = 257;
  llvm::sys::path::append(&__src, 0, (_QWORD **)&__dst, &v48, &v46, &v44);
  sub_1C5DF216C(v32, &__src);
LABEL_47:
  if (__src != v55)
    free(__src);
}

_QWORD *sub_1C5DF216C(_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t i;
  _QWORD *v13;
  char v14;
  unint64_t v15;
  unint64_t v16;

  if (result != a2)
  {
    v3 = result;
    v4 = *result;
    if ((_QWORD *)*result == result + 3 || (_QWORD *)*a2 == a2 + 3)
    {
      v8 = a2[1];
      if (result[2] < v8)
        result = llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)result, result + 3, v8, 1);
      v9 = v3[1];
      if (a2[2] < v9)
      {
        result = llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a2, a2 + 3, v9, 1);
        v9 = v3[1];
      }
      v10 = a2[1];
      if (v9 >= v10)
        v11 = a2[1];
      else
        v11 = v9;
      if (v11)
      {
        for (i = 0; i != v11; ++i)
        {
          v13 = (_QWORD *)*a2;
          v14 = *(_BYTE *)(*v3 + i);
          *(_BYTE *)(*v3 + i) = *(_BYTE *)(*a2 + i);
          *((_BYTE *)v13 + i) = v14;
        }
        v9 = v3[1];
        v10 = a2[1];
      }
      v15 = v9 - v10;
      if (v9 <= v10)
      {
        v16 = v10 - v9;
        if (v10 > v9)
        {
          if (v11 != v10)
          {
            result = memcpy((void *)(*v3 + v9), (const void *)(*a2 + v11), *a2 + v10 - (*a2 + v11));
            v9 = v3[1];
          }
          v3[1] = v16 + v9;
          a2[1] = v11;
        }
      }
      else
      {
        if (v11 != v9)
        {
          result = memcpy((void *)(*a2 + v10), (const void *)(*v3 + v11), *v3 + v9 - (*v3 + v11));
          v10 = a2[1];
        }
        a2[1] = v15 + v10;
        v3[1] = v11;
      }
    }
    else
    {
      v5 = result[1];
      v6 = a2[1];
      *result = *a2;
      result[1] = v6;
      *a2 = v4;
      a2[1] = v5;
      v7 = result[2];
      result[2] = a2[2];
      a2[2] = v7;
    }
  }
  return result;
}

void llvm::FileCollector::addFileImpl(uint64_t a1, _BYTE *a2, uint64_t a3)
{
  char v4;
  const void *v5;
  unint64_t v6;
  _BYTE *v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char *v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  BOOL *v18;
  int is_directory;
  uint64_t v20;
  void **v21;
  __int16 v22;
  _QWORD *v23[4];
  __int16 v24;
  _QWORD *v25[4];
  __int16 v26;
  char *v27;
  uint64_t v28;
  __int16 v29;
  void *v30;
  __int128 v31;
  _BYTE v32[256];
  void *v33;
  unint64_t v34;
  uint64_t v35;
  void *v36;
  uint64_t v37;
  _QWORD v38[33];

  v38[32] = *MEMORY[0x1E0C80C00];
  llvm::FileCollector::PathCanonicalizer::canonicalize((unsigned int *)(a1 + 208), a2, a3, (uint64_t)&v33);
  v4 = *(_BYTE *)(a1 + 127);
  if (v4 >= 0)
    v5 = (const void *)(a1 + 104);
  else
    v5 = *(const void **)(a1 + 104);
  if (v4 >= 0)
    v6 = v4 & 0x7F;
  else
    v6 = *(_QWORD *)(a1 + 112);
  v7 = v32;
  v30 = v32;
  v31 = xmmword_1C64638F0;
  if (v6 >= 0x101)
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v30, v32, v6, 1);
    v7 = v30;
    v8 = v31;
  }
  else
  {
    v8 = 0;
    v9 = 0;
    if (!v6)
      goto LABEL_10;
  }
  memcpy(&v7[v8], v5, v6);
  v9 = v31;
LABEL_10:
  *(_QWORD *)&v31 = v9 + v6;
  v10 = (char *)v33;
  v11 = v34;
  llvm::sys::path::root_path((unint64_t)v33, v34, 0);
  v29 = 261;
  if (v11 >= v12)
    v13 = v12;
  else
    v13 = v11;
  v27 = &v10[v13];
  v28 = v11 - v13;
  v26 = 257;
  v24 = 257;
  v22 = 257;
  llvm::sys::path::append(&v30, 0, (_QWORD **)&v27, v25, v23, &v21);
  v14 = (char *)v36;
  v15 = v37;
  v17 = v30;
  v16 = (_QWORD *)v31;
  v29 = 261;
  v27 = (char *)v36;
  v28 = v37;
  LOBYTE(v25[0]) = 0;
  is_directory = llvm::sys::fs::is_directory((llvm::sys::fs *)&v27, (const llvm::Twine *)v25, v18);
  v20 = a1 + 152;
  if (is_directory || !LOBYTE(v25[0]))
  {
    llvm::vfs::YAMLVFSWriter::addFileMapping(v20, (uint64_t)v14, v15, (uint64_t)v17, (uint64_t)v16);
  }
  else
  {
    v27 = v14;
    v28 = v15;
    v25[0] = v17;
    v25[1] = v16;
    LOBYTE(v23[0]) = 1;
    sub_1C6397D84(v20, (uint64_t)&v27, (uint64_t)v25, (char *)v23);
  }
  if (v30 != v32)
    free(v30);
  if (v36 != v38)
    free(v36);
  if (v33 != &v35)
    free(v33);
}

void llvm::FileCollector::addDirectoryImpl(uint64_t a1@<X0>, llvm::Twine *a2@<X1>, _QWORD *a3@<X2>, _QWORD *a4@<X3>, _OWORD *a5@<X8>)
{
  BOOL v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  uint64_t v14;
  char v15;
  int v16;
  std::__shared_weak_count *v17;
  std::__shared_weak_count *v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  __int16 v24;
  __int128 v25;

  (*(void (**)(__int128 *__return_ptr))(*(_QWORD *)*a3 + 32))(&v25);
  if (*(_DWORD *)a4)
    goto LABEL_18;
  llvm::FileCollectorBase::addFile(a1, a2);
  if (*(_DWORD *)a4)
    goto LABEL_18;
  while (1)
  {
    v22 = 0;
    v23 = 0;
    v10 = sub_1C5DF3038((uint64_t *)&v25, &v22);
    v11 = v23;
    if (v23)
    {
      p_shared_owners = (unint64_t *)&v23->__shared_owners_;
      do
        v13 = __ldaxr(p_shared_owners);
      while (__stlxr(v13 - 1, p_shared_owners));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
    if (v10)
      break;
    if ((*(_DWORD *)(v25 + 32) - 2) <= 2)
    {
      v14 = *(_QWORD *)(v25 + 8);
      v15 = *(_BYTE *)(v25 + 31);
      v16 = v15;
      if (v15 >= 0)
        v14 = v25 + 8;
      v17 = *(std::__shared_weak_count **)(v25 + 16);
      v18 = (std::__shared_weak_count *)(v15 & 0x7F);
      if (v16 >= 0)
        v17 = v18;
      v24 = 261;
      v22 = v14;
      v23 = v17;
      llvm::FileCollectorBase::addFile(a1, (llvm::Twine *)&v22);
    }
    sub_1C5DF267C(&v25, a4);
    if (*(_DWORD *)a4)
      goto LABEL_18;
  }
  if (*(_DWORD *)a4)
  {
LABEL_18:
    *a5 = v25;
  }
  else
  {
    (*(void (**)(_QWORD, llvm::Twine *, _QWORD *))(*(_QWORD *)*a3 + 32))(*a3, a2, a4);
    v19 = (std::__shared_weak_count *)*((_QWORD *)&v25 + 1);
    if (*((_QWORD *)&v25 + 1))
    {
      v20 = (unint64_t *)(*((_QWORD *)&v25 + 1) + 8);
      do
        v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
  }
}

_QWORD *sub_1C5DF267C(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  char v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;

  *a2 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 16))(*a1);
  a2[1] = v4;
  v5 = *(_BYTE *)(*a1 + 31);
  v6 = v5;
  v7 = *(_QWORD *)(*a1 + 16);
  v8 = v5 & 0x7F;
  if (v6 >= 0)
    v7 = v8;
  if (!v7)
  {
    v10 = (std::__shared_weak_count *)a1[1];
    *a1 = 0;
    a1[1] = 0;
    if (v10)
    {
      p_shared_owners = (unint64_t *)&v10->__shared_owners_;
      do
        v12 = __ldaxr(p_shared_owners);
      while (__stlxr(v12 - 1, p_shared_owners));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
  }
  return a1;
}

unint64_t llvm::FileCollector::copyFiles(llvm::FileCollector *this, char a2)
{
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  int v11;
  unint64_t v12;
  int v13;
  char v14;
  BOOL v15;
  unsigned __int8 *v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unsigned __int8 *v21;
  unint64_t v22;
  const llvm::Twine *v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  char v27;
  BOOL v28;
  unsigned __int8 *v29;
  uint64_t v30;
  llvm::sys::Process *st_dev;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  std::chrono::system_clock::time_point v35;
  uint64_t v36;
  std::mutex *v38;
  uint64_t v39[4];
  __int16 v40;
  time_t __t[2];
  _DWORD v42[7];
  stat v43;
  unsigned __int8 *v44;
  __int128 v45;
  uint64_t v46;
  __int16 v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v47 = 260;
  v44 = (unsigned __int8 *)this + 104;
  v4 = llvm::sys::fs::create_directories(&v44, 1, 504);
  v5 = v4;
  if ((_DWORD)v4)
  {
    v6 = HIDWORD(v4);
  }
  else
  {
    v38 = (std::mutex *)((char *)this + 8);
    std::mutex::lock((std::mutex *)((char *)this + 8));
    v7 = *((_QWORD *)this + 19);
    v8 = *((_QWORD *)this + 20);
    if (v7 != v8)
    {
      v9 = v7 + 24;
      while (1)
      {
        *(_OWORD *)__t = 0u;
        memset(v42, 0, sizeof(v42));
        v40 = 260;
        v39[0] = v9 - 24;
        v44 = (unsigned __int8 *)&v46;
        v45 = xmmword_1C85F20B0;
        v10 = (const char *)llvm::Twine::toNullTerminatedStringRef((unsigned __int8 *)v39, (uint64_t)&v44);
        v11 = stat(v10, &v43);
        v12 = sub_1C5E7F828(v11, &v43.st_dev, (uint64_t)__t);
        if (v44 != (unsigned __int8 *)&v46)
          free(v44);
        v6 = HIDWORD(v12);
        if ((_DWORD)v12)
        {
          if ((a2 & 1) != 0)
            goto LABEL_48;
        }
        else
        {
          v13 = v42[6];
          if (v42[6] != 1)
          {
            v14 = *(_BYTE *)(v9 + 23);
            v15 = v14 < 0;
            if (v14 >= 0)
              v16 = (unsigned __int8 *)v9;
            else
              v16 = *(unsigned __int8 **)v9;
            v17 = v14 & 0x7F;
            if (v15)
              v18 = *(_QWORD *)(v9 + 8);
            else
              v18 = v17;
            v19 = sub_1C5E7BE8C(v16, v18, 0);
            if (v18 >= v19)
              v20 = v19;
            else
              v20 = v18;
            if (v19 == -1)
              v20 = 0;
            v47 = 261;
            if (v19 == -1)
              v21 = 0;
            else
              v21 = v16;
            v44 = v21;
            *(_QWORD *)&v45 = v20;
            v22 = llvm::sys::fs::create_directories(&v44, 1, 504);
            LODWORD(v12) = v22;
            if ((_DWORD)v22 && (a2 & 1) != 0)
            {
              v6 = HIDWORD(v22);
              goto LABEL_48;
            }
            if (v13 == 3)
            {
              v47 = 260;
              v44 = (unsigned __int8 *)v9;
              v24 = llvm::sys::fs::create_directories(&v44, 1, 504);
              LODWORD(v12) = v24;
              v6 = HIDWORD(v24);
              if ((_DWORD)v24 && (a2 & 1) != 0)
                goto LABEL_48;
            }
            else
            {
              v47 = 260;
              v44 = (unsigned __int8 *)(v9 - 24);
              LOWORD(v43.st_atimespec.tv_sec) = 260;
              *(_QWORD *)&v43.st_dev = v9;
              v25 = llvm::sys::fs::copy_file((llvm::sys::fs *)&v44, (const llvm::Twine *)&v43, v23);
              LODWORD(v12) = v25;
              v6 = HIDWORD(v25);
              if ((_DWORD)v25 && (a2 & 1) != 0)
                goto LABEL_48;
              v47 = 260;
              v44 = (unsigned __int8 *)(v9 - 24);
              llvm::sys::fs::getPermissions((llvm::sys::fs *)&v44, (uint64_t)&v43);
              if ((v43.st_uid & 1) == 0)
              {
                v47 = 260;
                v44 = (unsigned __int8 *)v9;
                v26 = llvm::sys::fs::setPermissions((unsigned __int8 *)&v44, v43.st_dev);
                LODWORD(v12) = v26;
                v6 = HIDWORD(v26);
                if ((_DWORD)v26)
                {
                  if ((a2 & 1) != 0)
                    goto LABEL_48;
                }
              }
              v27 = *(_BYTE *)(v9 + 23);
              v28 = v27 < 0;
              v29 = *(unsigned __int8 **)v9;
              if (v27 >= 0)
                v29 = (unsigned __int8 *)v9;
              v30 = v27 & 0x7F;
              if (v28)
                v30 = *(_QWORD *)(v9 + 8);
              v43.st_dev = 0;
              v47 = 261;
              v44 = v29;
              *(_QWORD *)&v45 = v30;
              if (!llvm::sys::fs::openFile((unsigned __int8 *)&v44, &v43.st_dev, 2, 2, 0, 438))
              {
                st_dev = (llvm::sys::Process *)v43.st_dev;
                v32 = v42[0];
                v33 = v32 + 1000 * std::chrono::system_clock::from_time_t(__t[0]).__d_.__rep_;
                v34 = v42[1];
                v35.__d_.__rep_ = std::chrono::system_clock::from_time_t(__t[1]).__d_.__rep_;
                if (!llvm::sys::fs::setLastAccessAndModificationTime((int)st_dev, v33, v34 + 1000 * v35.__d_.__rep_)&& !llvm::sys::Process::SafelyCloseFileDescriptor(st_dev))
                {
                  std::system_category();
                }
              }
            }
          }
        }
        v36 = v9 + 32;
        v9 += 56;
        if (v36 == v8)
          goto LABEL_47;
      }
    }
    v6 = 0;
LABEL_47:
    std::system_category();
    LODWORD(v12) = 0;
LABEL_48:
    std::mutex::unlock(v38);
    v5 = v12;
  }
  return v5 | (v6 << 32);
}

unint64_t llvm::FileCollector::writeMapping(uint64_t a1, _BYTE *a2, uint64_t a3)
{
  std::mutex *v6;
  char v7;
  int v8;
  const void *v9;
  size_t v10;
  size_t v11;
  _BYTE *v12;
  uint64_t v13;
  uint64_t v14;
  void **v15;
  char v16;
  BOOL v17;
  void *v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  const void *v25;
  size_t v26;
  char v27;
  const void *p_p;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  std::mutex *v35;
  void *__p;
  unint64_t v37;
  char v38;
  __int16 v39;
  void *__s2;
  __int128 v41;
  _BYTE v42[9];
  void *v43;
  __int128 v44;
  _BYTE v45[256];
  _BYTE __dst[24];
  _QWORD v47[34];

  v47[32] = *MEMORY[0x1E0C80C00];
  v6 = (std::mutex *)(a1 + 8);
  std::mutex::lock((std::mutex *)(a1 + 8));
  v7 = *(_BYTE *)(a1 + 151);
  v8 = v7;
  if (v7 >= 0)
    v9 = (const void *)(a1 + 128);
  else
    v9 = *(const void **)(a1 + 128);
  v10 = v7 & 0x7F;
  if (v8 >= 0)
    v11 = v10;
  else
    v11 = *(_QWORD *)(a1 + 136);
  if (!*(_BYTE *)(a1 + 179))
    *(_BYTE *)(a1 + 179) = 1;
  *(_BYTE *)(a1 + 178) = 1;
  if (!v9)
  {
    memset(__dst, 0, sizeof(__dst));
    goto LABEL_20;
  }
  if (v11 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  if (v11 >= 0x17)
  {
    v13 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v11 | 7) != 0x17)
      v13 = v11 | 7;
    v14 = v13 + 1;
    v12 = operator new(v13 + 1);
    *(_QWORD *)&__dst[16] = v14 | 0x8000000000000000;
    *(_QWORD *)__dst = v12;
    *(_QWORD *)&__dst[8] = v11;
  }
  else
  {
    __dst[23] = v11;
    v12 = __dst;
    if (!v11)
      goto LABEL_19;
  }
  memmove(v12, v9, v11);
LABEL_19:
  v12[v11] = 0;
LABEL_20:
  v15 = (void **)(a1 + 184);
  if (*(char *)(a1 + 207) < 0)
    operator delete(*v15);
  *(_OWORD *)v15 = *(_OWORD *)__dst;
  *(_QWORD *)(a1 + 200) = *(_QWORD *)&__dst[16];
  v16 = *(_BYTE *)(a1 + 151);
  v17 = v16 < 0;
  if (v16 >= 0)
    v18 = (void *)(a1 + 128);
  else
    v18 = *(void **)(a1 + 128);
  v19 = v16 & 0x7F;
  if (v17)
    v20 = *(_QWORD *)(a1 + 136);
  else
    v20 = v19;
  *(_QWORD *)__dst = v47;
  *(_OWORD *)&__dst[8] = xmmword_1C64638F0;
  if (v20 >= 0x101)
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)__dst, v47, v20, 1);
    v21 = *(_QWORD *)&__dst[8];
    v23 = *(_QWORD **)__dst;
  }
  else
  {
    v21 = 0;
    v22 = 0;
    v23 = v47;
    if (!v20)
      goto LABEL_31;
  }
  memcpy((char *)v23 + v21, v18, v20);
  v22 = *(_QWORD *)&__dst[8];
LABEL_31:
  *(_QWORD *)&__dst[8] = v22 + v20;
  v43 = v45;
  v44 = xmmword_1C64638F0;
  __s2 = v42;
  v41 = xmmword_1C64638F0;
  v39 = 261;
  __p = v18;
  v37 = v20;
  if (llvm::sys::fs::real_path((unsigned __int8 *)&__p, __dst, 0))
    goto LABEL_48;
  v35 = v6;
  v24 = a3;
  v25 = *(const void **)__dst;
  v26 = *(_QWORD *)&__dst[8];
  sub_1C5E3DEA4(&__p, *(char **)__dst, (uint64_t (*)(_QWORD))sub_1C6392230, (char *)(*(_QWORD *)__dst + *(_QWORD *)&__dst[8]), (uint64_t)sub_1C6392230, *(unint64_t *)&__dst[8]);
  v27 = v38;
  if (v38 >= 0)
    p_p = &__p;
  else
    p_p = __p;
  if (v38 >= 0)
    v29 = v38 & 0x7F;
  else
    v29 = v37;
  *(_QWORD *)&v44 = 0;
  if (*((_QWORD *)&v44 + 1) < v29)
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v43, v45, v29, 1);
    v30 = v44;
    goto LABEL_40;
  }
  v30 = 0;
  if (v29)
  {
LABEL_40:
    memcpy((char *)v43 + v30, p_p, v29);
    v30 = v44;
    v27 = v38;
  }
  v31 = v30 + v29;
  *(_QWORD *)&v44 = v31;
  a3 = v24;
  if (v27 < 0)
  {
    operator delete(__p);
    v31 = v44;
  }
  v39 = 261;
  __p = v43;
  v37 = v31;
  v6 = v35;
  if (!llvm::sys::fs::real_path((unsigned __int8 *)&__p, &__s2, 0) && v26 == (_QWORD)v41)
  {
    if (!v26)
      goto LABEL_49;
    if (!memcmp(v25, __s2, v26))
    {
      LOBYTE(v26) = 0;
      goto LABEL_49;
    }
  }
LABEL_48:
  LOBYTE(v26) = 1;
LABEL_49:
  if (__s2 != v42)
    free(__s2);
  if (v43 != v45)
    free(v43);
  if (*(_QWORD **)__dst != v47)
    free(*(void **)__dst);
  if (!*(_BYTE *)(a1 + 177))
    *(_BYTE *)(a1 + 177) = 1;
  *(_BYTE *)(a1 + 176) = v26;
  if (!*(_BYTE *)(a1 + 181))
    *(_BYTE *)(a1 + 181) = 1;
  *(_BYTE *)(a1 + 180) = 0;
  LODWORD(v43) = 0;
  *(_QWORD *)&v44 = std::system_category();
  llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)__dst, a2, a3, (uint64_t)&v43, 3);
  if ((_DWORD)v43)
  {
    v32 = (unint64_t)v43 & 0xFFFFFFFF00000000;
    v33 = v43;
  }
  else
  {
    llvm::vfs::YAMLVFSWriter::write((llvm::vfs::YAMLVFSWriter *)(a1 + 152), (llvm::raw_ostream *)__dst);
    std::system_category();
    v33 = 0;
    v32 = 0;
  }
  llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)__dst);
  std::mutex::unlock(v6);
  return v32 | v33;
}

unsigned int *llvm::FileCollector::createCollectorVFS@<X0>(uint64_t *a1@<X0>, __int128 *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  unsigned int *result;
  unsigned int v10;

  v6 = operator new();
  v7 = *a1;
  *a1 = 0;
  v8 = *a2;
  *(_QWORD *)v6 = &off_1E81A0EF8;
  *(_QWORD *)(v6 + 16) = v7;
  *(_OWORD *)(v6 + 24) = v8;
  *a3 = v6;
  *(_DWORD *)(v6 + 8) = 0;
  result = (unsigned int *)(v6 + 8);
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  do
    v10 = __ldxr(result);
  while (__stxr(v10 + 1, result));
  return result;
}

uint64_t sub_1C5DF2EF8(uint64_t a1)
{
  void **v3;

  *(_QWORD *)a1 = off_1E81A0EC8;
  sub_1C58F7164(a1 + 208);
  if (*(char *)(a1 + 207) < 0)
    operator delete(*(void **)(a1 + 184));
  v3 = (void **)(a1 + 152);
  sub_1C5DF3418(&v3);
  if (*(char *)(a1 + 151) < 0)
    operator delete(*(void **)(a1 + 128));
  if (*(char *)(a1 + 127) < 0)
    operator delete(*(void **)(a1 + 104));
  *(_QWORD *)a1 = off_1E81A0E98;
  sub_1C4F02264(a1 + 72);
  std::mutex::~mutex((std::mutex *)(a1 + 8));
  return a1;
}

void sub_1C5DF2F90(uint64_t a1)
{
  void **v2;

  *(_QWORD *)a1 = off_1E81A0EC8;
  sub_1C58F7164(a1 + 208);
  if (*(char *)(a1 + 207) < 0)
    operator delete(*(void **)(a1 + 184));
  v2 = (void **)(a1 + 152);
  sub_1C5DF3418(&v2);
  if (*(char *)(a1 + 151) < 0)
    operator delete(*(void **)(a1 + 128));
  if (*(char *)(a1 + 127) < 0)
    operator delete(*(void **)(a1 + 104));
  *(_QWORD *)a1 = off_1E81A0E98;
  sub_1C4F02264(a1 + 72);
  std::mutex::~mutex((std::mutex *)(a1 + 8));
  JUMPOUT(0x1CAA32FC0);
}

BOOL sub_1C5DF3038(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  _BOOL8 result;
  BOOL v5;
  uint64_t v6;
  const void *v7;
  const void *v8;
  char v9;
  const void *v10;
  size_t v11;
  size_t v12;
  uint64_t v13;
  const void *v14;
  const void *v15;
  char v16;
  const void *v17;
  uint64_t v18;

  v2 = *a1;
  v3 = *a2;
  result = (*a1 | *a2) == 0;
  if (v2)
    v5 = v3 == 0;
  else
    v5 = 1;
  if (!v5)
  {
    v8 = *(const void **)(v2 + 8);
    v6 = v2 + 8;
    v7 = v8;
    v9 = *(_BYTE *)(v6 + 23);
    if (v9 >= 0)
      v10 = (const void *)v6;
    else
      v10 = v7;
    v11 = *(_QWORD *)(v6 + 8);
    if (v9 >= 0)
      v12 = v9 & 0x7F;
    else
      v12 = v11;
    v15 = *(const void **)(v3 + 8);
    v13 = v3 + 8;
    v14 = v15;
    v16 = *(_BYTE *)(v13 + 23);
    if (v16 >= 0)
      v17 = (const void *)v13;
    else
      v17 = v14;
    v18 = *(_QWORD *)(v13 + 8);
    if (v16 >= 0)
      v18 = v16 & 0x7F;
    if (v12 == v18)
      return !v12 || memcmp(v10, v17, v12) == 0;
    else
      return 0;
  }
  return result;
}

_QWORD *sub_1C5DF30D4(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  unsigned int *v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int v8;

  *a1 = &off_1E81A0EF8;
  v2 = (std::__shared_weak_count *)a1[4];
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  v5 = (unsigned int *)a1[2];
  if (v5)
  {
    v6 = v5 + 2;
    do
    {
      v7 = __ldaxr(v6);
      v8 = v7 - 1;
    }
    while (__stlxr(v8, v6));
    if (!v8)
      (*(void (**)(unsigned int *))(*(_QWORD *)v5 + 8))(v5);
  }
  return a1;
}

void sub_1C5DF3164(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  unsigned int *v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int v8;

  *a1 = &off_1E81A0EF8;
  v2 = (std::__shared_weak_count *)a1[4];
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  v5 = (unsigned int *)a1[2];
  if (v5)
  {
    v6 = v5 + 2;
    do
    {
      v7 = __ldaxr(v6);
      v8 = v7 - 1;
    }
    while (__stlxr(v8, v6));
    if (!v8)
      (*(void (**)(unsigned int *))(*(_QWORD *)v5 + 8))(v5);
  }
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5DF3204(uint64_t a1@<X0>, llvm::Twine *a2@<X1>, uint64_t a3@<X8>)
{
  (*(void (**)(_QWORD *__return_ptr))(**(_QWORD **)(a1 + 16) + 16))((_QWORD *)a3);
  if ((*(_BYTE *)(a3 + 80) & 1) == 0 && *(_DWORD *)(a3 + 64) >= 2u)
    llvm::FileCollectorBase::addFile(*(_QWORD *)(a1 + 24), a2);
}

void sub_1C5DF3270(uint64_t a1@<X0>, llvm::Twine *a2@<X1>, uint64_t a3@<X8>)
{
  (*(void (**)(_QWORD *__return_ptr))(**(_QWORD **)(a1 + 16) + 24))((_QWORD *)a3);
  if ((*(_BYTE *)(a3 + 16) & 1) == 0)
  {
    if (*(_QWORD *)a3)
      llvm::FileCollectorBase::addFile(*(_QWORD *)(a1 + 24), a2);
  }
}

uint64_t sub_1C5DF32D8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int *v6;
  unsigned int v7;
  uint64_t result;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;

  v4 = *(_QWORD *)(a1 + 24);
  v5 = *(_QWORD *)(a1 + 16);
  v12 = v5;
  if (v5)
  {
    v6 = (unsigned int *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t))(*(_QWORD *)v4 + 24))(v4, a2, &v12, a3);
  result = v12;
  if (v12)
  {
    v9 = (unsigned int *)(v12 + 8);
    do
    {
      v10 = __ldaxr(v9);
      v11 = v10 - 1;
    }
    while (__stlxr(v11, v9));
    if (!v11)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

uint64_t sub_1C5DF3358(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 40))(*(_QWORD *)(a1 + 16));
}

uint64_t sub_1C5DF3368(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 48))(*(_QWORD *)(a1 + 16));
}

uint64_t sub_1C5DF3378(uint64_t a1, llvm::Twine *a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[4];
  __int16 v11;

  v6 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 56))(*(_QWORD *)(a1 + 16));
  if (!(_DWORD)v6)
  {
    llvm::FileCollectorBase::addFile(*(_QWORD *)(a1 + 24), a2);
    v7 = a3[1];
    if (v7)
    {
      v8 = *(_QWORD *)(a1 + 24);
      v11 = 261;
      v10[0] = *a3;
      v10[1] = v7;
      llvm::FileCollectorBase::addFile(v8, (llvm::Twine *)v10);
    }
  }
  return v6;
}

uint64_t sub_1C5DF3408(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 80))(*(_QWORD *)(a1 + 16));
}

void sub_1C5DF3418(void ***a1)
{
  void **v1;
  void **v2;
  void **v4;
  void *v5;

  v1 = *a1;
  v2 = (void **)**a1;
  if (v2)
  {
    v4 = (void **)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        if (*((char *)v4 - 9) < 0)
          operator delete(*(v4 - 4));
        if (*((char *)v4 - 33) < 0)
          operator delete(*(v4 - 7));
        v4 -= 7;
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t llvm::DiffFilesWithTolerance(std::string::size_type a1, std::string::size_type a2, std::string::size_type a3, std::string::size_type a4, uint64_t a5, double a6, double a7)
{
  char v12;
  _QWORD *v13;
  uint64_t v14;
  int v15;
  _QWORD *v16;
  std::string::value_type *v17;
  _BYTE *v18;
  char *v19;
  _BYTE *v20;
  std::string::value_type *v21;
  char *v22;
  std::string::value_type *v23;
  char *v24;
  int v26;
  int v27;
  unsigned int v28;
  int v31;
  std::error_code v32;
  std::string v33;
  __int16 v34;
  std::error_code v35;
  unsigned __int8 v36;
  std::error_code v37;
  char v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v34 = 261;
  v33.__r_.__value_.__r.__words[0] = a1;
  v33.__r_.__value_.__l.__size_ = a2;
  sub_1C5E1F6CC((unsigned __int8 *)&v33, 0xFFFFFFFFFFFFFFFFLL, 0, 0, 1, 0, (uint64_t)&v37);
  v12 = v38;
  if ((v38 & 1) != 0)
  {
    v13 = *(_QWORD **)&v37.__val_;
    v35 = v37;
    if (v37.__val_)
    {
      if (a5)
      {
        std::error_code::message(&v33, &v35);
        if (*(char *)(a5 + 23) < 0)
          operator delete(*(void **)a5);
        *(std::string *)a5 = v33;
      }
      return 2;
    }
  }
  else
  {
    std::system_category();
    v13 = *(_QWORD **)&v37.__val_;
  }
  v34 = 261;
  v33.__r_.__value_.__r.__words[0] = a3;
  v33.__r_.__value_.__l.__size_ = a4;
  sub_1C5E1F6CC((unsigned __int8 *)&v33, 0xFFFFFFFFFFFFFFFFLL, 0, 0, 1, 0, (uint64_t)&v35);
  v15 = v36;
  if ((v36 & 1) == 0)
  {
    std::system_category();
    v16 = *(_QWORD **)&v35.__val_;
    goto LABEL_17;
  }
  v16 = *(_QWORD **)&v35.__val_;
  v32 = v35;
  if (!v35.__val_)
  {
LABEL_17:
    v18 = (_BYTE *)v13[1];
    v17 = (std::string::value_type *)v13[2];
    v20 = (_BYTE *)v16[1];
    v19 = (char *)v16[2];
    v33.__r_.__value_.__r.__words[0] = (std::string::size_type)v18;
    *(_QWORD *)&v32.__val_ = v20;
    if (v17 - v18 != v19 - v20 || memcmp(v18, v20, v17 - v18))
    {
      if (a6 == 0.0 && a7 == 0.0)
      {
        if (a5)
          MEMORY[0x1CAA32ABC](a5, "Files differ without tolerance allowance");
        v14 = 1;
        goto LABEL_51;
      }
      while (1)
      {
        v23 = (std::string::value_type *)v33.__r_.__value_.__r.__words[0];
        v24 = *(char **)&v32.__val_;
        if (v33.__r_.__value_.__r.__words[0] >= (unint64_t)v17)
          break;
        v31 = v15;
        v21 = &v17[-v33.__r_.__value_.__r.__words[0]];
        v22 = *(char **)&v32.__val_;
        while (1)
        {
          if (v22 >= v19)
          {
            v24 = v22;
            goto LABEL_33;
          }
          if (*v23 != *v22)
            break;
          ++v23;
          ++v22;
          if (!--v21)
          {
            v24 = &v17[*(_QWORD *)&v32.__val_ - v33.__r_.__value_.__r.__words[0]];
            v23 = v17;
LABEL_33:
            LOBYTE(v15) = v31;
            goto LABEL_34;
          }
        }
        v33.__r_.__value_.__r.__words[0] = (std::string::size_type)sub_1C5DF387C(v23, (unint64_t)v18);
        *(_QWORD *)&v32.__val_ = sub_1C5DF387C(v22, (unint64_t)v20);
        v14 = 1;
        v15 = v31;
        if ((sub_1C5DF396C(&v33.__r_.__value_.__l.__data_, (const char **)&v32, v17, v19, (std::string *)a5, a6, a7) & 1) != 0)
          goto LABEL_51;
      }
LABEL_34:
      v33.__r_.__value_.__r.__words[0] = (std::string::size_type)v23;
      *(_QWORD *)&v32.__val_ = v24;
      if (v23 < v17 || v24 < v19)
      {
        if (v23 >= v17)
        {
          v26 = *(v23 - 1);
          if ((v26 - 48) < 0xA
            || v26 == 46
            || v26 == 43
            || *(v23 - 1) == 45
            || ((v26 - 68) & 0xFFFFFFDE) == 0)
          {
            v33.__r_.__value_.__r.__words[0] = (std::string::size_type)--v23;
          }
        }
        if (v24 >= v19)
        {
          v27 = *(v24 - 1);
          if ((v27 - 48) < 0xA
            || v27 == 46
            || v27 == 43
            || *(v24 - 1) == 45
            || ((v27 - 68) & 0xFFFFFFDE) == 0)
          {
            *(_QWORD *)&v32.__val_ = --v24;
          }
        }
        v33.__r_.__value_.__r.__words[0] = (std::string::size_type)sub_1C5DF387C(v23, (unint64_t)v18);
        *(_QWORD *)&v32.__val_ = sub_1C5DF387C(v24, (unint64_t)v20);
        v28 = sub_1C5DF396C(&v33.__r_.__value_.__l.__data_, (const char **)&v32, v17, v19, (std::string *)a5, a6, a7);
        if (v33.__r_.__value_.__r.__words[0] >= (unint64_t)v17
          && *(_QWORD *)&v32.__val_ >= (unint64_t)v19)
        {
          v14 = v28;
        }
        else
        {
          v14 = 1;
        }
        goto LABEL_51;
      }
    }
    v14 = 0;
LABEL_51:
    if ((v15 & 1) == 0 && v16)
      (*(void (**)(_QWORD *))(*v16 + 8))(v16);
    goto LABEL_54;
  }
  if (a5)
  {
    std::error_code::message(&v33, &v32);
    if (*(char *)(a5 + 23) < 0)
      operator delete(*(void **)a5);
    *(std::string *)a5 = v33;
  }
  v14 = 2;
LABEL_54:
  if ((v12 & 1) == 0 && v13)
    (*(void (**)(_QWORD *))(*v13 + 8))(v13);
  return v14;
}

_BYTE *sub_1C5DF387C(_BYTE *result, unint64_t a2)
{
  int v2;
  unsigned __int8 v3;
  _BYTE *i;
  int v5;

  v2 = (char)*result;
  if ((v2 - 48) < 0xA || v2 == 46 || v2 == 43 || *result == 45)
  {
    if ((unint64_t)result <= a2)
      return result;
    goto LABEL_3;
  }
  if ((unint64_t)result > a2 && ((v2 - 68) & 0xFFFFFFDE) == 0)
  {
LABEL_3:
    v3 = 0;
    for (i = result - 1; ; --i)
    {
      v5 = (char)*i;
      if ((v5 - 48) >= 0xA && v5 != 46)
      {
        if (v5 == 43 || *i == 45)
          goto LABEL_7;
        if (((v5 - 68) & 0xFFFFFFDE) != 0)
          return i + 1;
      }
      if (((v5 == 46) & v3) != 0)
        return result;
      v3 |= v5 == 46;
LABEL_7:
      --result;
      if ((unint64_t)i <= a2)
        return result;
      if ((v5 == 45 || *i == 43) && (((char)*(i - 1) - 68) & 0xFFFFFFDE) != 0)
        return i;
    }
  }
  return result;
}

uint64_t sub_1C5DF396C(std::string::value_type **a1, const char **a2, std::string::value_type *a3, char *a4, std::string *a5, double a6, double a7)
{
  std::string::value_type *i;
  int v13;
  char *j;
  int v15;
  char *v16;
  int v17;
  double v18;
  double v19;
  int v20;
  char *v21;
  unint64_t v22;
  char *v23;
  char v24;
  uint64_t v25;
  char *v26;
  int v27;
  const char *v28;
  unint64_t v29;
  char *v30;
  char v31;
  uint64_t v32;
  char *v33;
  char *v34;
  double v35;
  double v36;
  uint64_t result;
  double v38;
  _DWORD *v39;
  _BYTE *v40;
  _QWORD *v41;
  _QWORD *v42;
  _BYTE *v43;
  unint64_t v44;
  _BYTE *v45;
  char *v46;
  char *v47;
  char *v48;
  __int128 v49;
  unint64_t v50;
  unint64_t v51;
  char v52;
  uint64_t v53;
  int v54;
  std::string *v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v46 = 0;
  v47 = 0;
  for (i = *a1; ; *a1 = i)
  {
    v13 = *i;
    if ((v13 - 9) >= 5 && v13 != 32)
      break;
    if (i == a3)
      break;
    ++i;
  }
  for (j = (char *)*a2; ; *a2 = j)
  {
    v15 = *j;
    if ((v15 - 9) >= 5 && v15 != 32)
      break;
    if (j == a4)
    {
      j = a4;
      break;
    }
    ++j;
  }
  v16 = *a1;
  v17 = **a1;
  if (((v17 - 48) < 0xA || v17 == 46 || v17 == 43 || **a1 == 45 || ((v17 - 68) & 0xFFFFFFDE) == 0)
    && (((char)v15 - 48) < 0xA
     || (char)v15 == 46
     || (char)v15 == 43
     || v15 == 45
     || (((char)v15 - 68) & 0xFFFFFFDE) == 0))
  {
    v18 = strtod(v16, &v47);
    v19 = strtod(*a2, &v46);
    v20 = *v47;
    if ((v20 | 0x20) == 0x64)
    {
      v21 = *a1;
      v22 = (unint64_t)&(*a1)[~(unint64_t)v47];
      v23 = v47 + 1;
      while (((char)v20 - 48) < 0xA
           || (char)v20 == 46
           || (char)v20 == 43
           || v20 == 45
           || (((char)v20 - 68) & 0xFFFFFFDE) == 0)
      {
        v24 = *v23++;
        LOBYTE(v20) = v24;
        --v22;
      }
      v48 = (char *)&v50;
      v49 = xmmword_1C8667FB0;
      if ((unint64_t)-(uint64_t)v22 >= 0xC9)
      {
        llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v48, &v50, -(uint64_t)v22, 1);
        v26 = v48;
        v25 = v49;
      }
      else
      {
        v25 = 0;
        v26 = (char *)&v50;
      }
      if (v23 != v21)
      {
        memcpy(&v26[v25], v21, -(uint64_t)v22);
        v26 = v48;
        v25 = v49;
      }
      *(_QWORD *)&v49 = v25 - v22;
      v26[(_DWORD)v47 - *(_DWORD *)a1] = 101;
      v18 = strtod(v48, &v47);
      v47 = &(*a1)[v47 - v48];
      if (v48 != (char *)&v50)
        free(v48);
    }
    v27 = *v46;
    if ((v27 | 0x20) == 0x64)
    {
      v28 = *a2;
      v29 = (unint64_t)&(*a2)[~(unint64_t)v46];
      v30 = v46 + 1;
      while (((char)v27 - 48) < 0xA
           || (char)v27 == 46
           || (char)v27 == 43
           || v27 == 45
           || (((char)v27 - 68) & 0xFFFFFFDE) == 0)
      {
        v31 = *v30++;
        LOBYTE(v27) = v31;
        --v29;
      }
      v48 = (char *)&v50;
      v49 = xmmword_1C8667FB0;
      if ((unint64_t)-(uint64_t)v29 >= 0xC9)
      {
        llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v48, &v50, -(uint64_t)v29, 1);
        v33 = v48;
        v32 = v49;
      }
      else
      {
        v32 = 0;
        v33 = (char *)&v50;
      }
      if (v30 != v28)
      {
        memcpy(&v33[v32], v28, -(uint64_t)v29);
        v33 = v48;
        v32 = v49;
      }
      *(_QWORD *)&v49 = v32 - v29;
      v33[(_DWORD)v46 - *(_DWORD *)a2] = 101;
      v19 = strtod(v48, &v46);
      v46 = (char *)&(*a2)[v46 - v48];
      if (v48 != (char *)&v50)
        free(v48);
    }
  }
  else
  {
    v46 = j;
    v47 = v16;
    v19 = 0.0;
    v18 = 0.0;
  }
  if (v47 == *a1 || (v34 = v46, v46 == *a2))
  {
    if (a5)
    {
      MEMORY[0x1CAA32ABC](a5, "FP Comparison failed, not a numeric difference between '");
      std::string::push_back(a5, **a1);
      std::string::append(a5, "' and '");
      std::string::push_back(a5, **a2);
      std::string::append(a5, "'");
    }
    return 1;
  }
  v35 = vabdd_f64(v18, v19);
  if (v35 > a6)
  {
    if (v19 == 0.0)
    {
      if (v18 == 0.0)
      {
        v38 = 0.0;
        goto LABEL_64;
      }
      v36 = v19 / v18;
    }
    else
    {
      v36 = v18 / v19;
    }
    v38 = fabs(v36 + -1.0);
LABEL_64:
    if (v38 <= a7)
      goto LABEL_65;
    if (a5)
    {
      LODWORD(v49) = 0;
      v52 = 0;
      v53 = 0;
      v48 = (char *)&unk_1E81A7208;
      v55 = a5;
      v54 = 0;
      v50 = 0;
      v51 = 0;
      *((_QWORD *)&v49 + 1) = 0;
      llvm::raw_ostream::write((llvm::raw_ostream *)&v48, "Compared: ", 0xAuLL);
      llvm::write_double((llvm::raw_ostream *)&v48, 0, 0, 0, v18);
      v39 = (_DWORD *)v51;
      if (v50 - v51 > 4)
      {
        *(_BYTE *)(v51 + 4) = 32;
        *v39 = 1684955424;
        v51 += 5;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v48, " and ", 5uLL);
      }
      llvm::write_double((llvm::raw_ostream *)&v48, 0, 0, 0, v19);
      v40 = (_BYTE *)v51;
      if (v51 >= v50)
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v48, 10);
      }
      else
      {
        ++v51;
        *v40 = 10;
      }
      v41 = (_QWORD *)v51;
      if (v50 - v51 > 0xB)
      {
        *(_DWORD *)(v51 + 8) = 540876902;
        *v41 = *(_QWORD *)"abs. diff = ";
        v51 += 12;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v48, "abs. diff = ", 0xCuLL);
      }
      llvm::write_double((llvm::raw_ostream *)&v48, 0, 0, 0, v35);
      v42 = (_QWORD *)v51;
      if (v50 - v51 > 0xB)
      {
        *(_DWORD *)(v51 + 8) = 540876902;
        *v42 = *(_QWORD *)" rel.diff = ";
        v51 += 12;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v48, " rel.diff = ", 0xCuLL);
      }
      llvm::write_double((llvm::raw_ostream *)&v48, 0, 0, 0, v38);
      v43 = (_BYTE *)v51;
      if (v51 >= v50)
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v48, 10);
      }
      else
      {
        ++v51;
        *v43 = 10;
      }
      v44 = v51;
      if (v50 - v51 > 0x1A)
      {
        *(_OWORD *)v51 = *(_OWORD *)"Out of tolerance: rel/abs: ";
        *(_OWORD *)(v44 + 11) = *(_OWORD *)"rance: rel/abs: ";
        v51 += 27;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v48, "Out of tolerance: rel/abs: ", 0x1BuLL);
      }
      llvm::write_double((llvm::raw_ostream *)&v48, 0, 0, 0, a7);
      v45 = (_BYTE *)v51;
      if (v51 >= v50)
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v48, 47);
      }
      else
      {
        ++v51;
        *v45 = 47;
      }
      llvm::write_double((llvm::raw_ostream *)&v48, 0, 0, 0, a6);
      v48 = (char *)off_1E81A6E70;
      if (v54 == 1)
      {
        if (*((_QWORD *)&v49 + 1))
          MEMORY[0x1CAA32F9C](*((_QWORD *)&v49 + 1), 0x1000C8077774924);
      }
    }
    return 1;
  }
LABEL_65:
  result = 0;
  *a1 = v47;
  *a2 = v34;
  return result;
}

void sub_1C5DF40EC()
{
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C5DF4100(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E81A0FC8;
  result[1] = v3;
  return result;
}

uint64_t sub_1C5DF4134(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E81A0FC8;
  a2[1] = v2;
  return result;
}

llvm::raw_ostream *sub_1C5DF4150@<X0>(llvm::raw_ostream *this@<X1>, uint64_t a2@<X0>, _QWORD *a3@<X8>)
{
  llvm::raw_ostream *result;

  result = llvm::raw_ostream::write(this, **(const char ***)(a2 + 8), *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8));
  *a3 = 0;
  return result;
}

void llvm::FileOutputBuffer::create(const char *a1@<X0>, __darwin_ino64_t a2@<X1>, size_t a3@<X2>, char a4@<W3>, uint64_t a5@<X8>)
{
  const char *v10;
  size_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  const char *v15;
  int v16;
  uint64_t *v17;
  const std::error_category *v18;
  _QWORD *v19;
  llvm::sys::fs *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __darwin_ino64_t st_ino;
  char v25;
  int tv_sec;
  void *v27;
  size_t v28;
  int v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  int v33;
  char v34;
  __darwin_ino64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t *v39;
  uint64_t v40;
  char *v41;
  _QWORD *v42;
  char *v43;
  size_t v44;
  int v45;
  void *v46;
  size_t v47;
  void *v48;
  int v49;
  __int16 v50;
  _BYTE v51[44];
  uint64_t v52;
  __int16 v53;
  uint64_t v54;
  char *v55;
  char *v56;
  stat v57;
  _BYTE v58[15];
  uint64_t *v59;
  __int128 v60;
  uint64_t v61;
  unsigned int v62;
  char v63;
  uint64_t v64;

  v64 = *MEMORY[0x1E0C80C00];
  if (a2 == 1 && *a1 == 45)
  {
    v10 = "-";
    v11 = 1;
    v12 = a3;
    v13 = 0;
LABEL_21:
    sub_1C5DF46CC((uint64_t)&v59, v10, v11, v12, v13);
    *(_BYTE *)(a5 + 8) = *(_BYTE *)(a5 + 8) & 0xFE | v60 & 1;
    *(_QWORD *)a5 = v59;
    return;
  }
  if ((a4 & 1) != 0)
    v14 = 511;
  else
    v14 = 438;
  if (!a3)
  {
    v10 = a1;
    v11 = a2;
    v12 = 0;
LABEL_20:
    v13 = v14;
    goto LABEL_21;
  }
  memset(v51, 0, sizeof(v51));
  v52 = 0xFFFFLL;
  v53 = 0;
  v54 = 0;
  v50 = 261;
  v47 = (size_t)a1;
  v48 = (void *)a2;
  v59 = &v61;
  v60 = xmmword_1C85F20B0;
  v15 = (const char *)llvm::Twine::toNullTerminatedStringRef((unsigned __int8 *)&v47, (uint64_t)&v59);
  v16 = stat(v15, &v57);
  sub_1C5E7F828(v16, &v57.st_dev, (uint64_t)v51);
  if (v59 != &v61)
    free(v59);
  if (*(_DWORD *)&v51[40] >= 3u)
  {
    if (*(_DWORD *)&v51[40] == 3)
    {
      v18 = std::generic_category();
      v19 = (_QWORD *)operator new();
      *v19 = &off_1E81A0D28;
      v19[1] = 21;
      v19[2] = v18;
      *(_BYTE *)(a5 + 8) |= 1u;
      *(_QWORD *)a5 = v19;
      return;
    }
    goto LABEL_19;
  }
  if ((a4 & 2) != 0)
  {
LABEL_19:
    v10 = a1;
    v11 = a2;
    v12 = a3;
    goto LABEL_20;
  }
  LOWORD(v57.st_atimespec.tv_sec) = 773;
  *(_QWORD *)&v57.st_dev = a1;
  v57.st_ino = a2;
  *(_QWORD *)&v57.st_uid = ".tmp%%%%%%%";
  llvm::sys::fs::TempFile::create((uint64_t)&v57, v14, 0, (uint64_t)&v59);
  if ((v63 & 1) != 0)
  {
    v17 = v59;
    v59 = 0;
    *(_BYTE *)(a5 + 8) |= 1u;
    *(_QWORD *)a5 = v17;
LABEL_39:
    v39 = v59;
    v59 = 0;
    if (v39)
      (*(void (**)(uint64_t *))(*v39 + 8))(v39);
    return;
  }
  LOBYTE(v57.st_dev) = 0;
  *(_OWORD *)&v57.st_ino = v60;
  *(_QWORD *)&v57.st_rdev = v61;
  HIBYTE(v61) = 0;
  LOBYTE(v60) = 0;
  v20 = (llvm::sys::fs *)v62;
  LODWORD(v57.st_atimespec.tv_sec) = v62;
  LOBYTE(v59) = 1;
  v62 = -1;
  v22 = llvm::sys::fs::resize_file(v20, a3);
  if (!(_DWORD)v22)
  {
    std::system_category();
    v47 = a3;
    v48 = 0;
    v49 = 1;
    if (llvm::sys::fs::mapped_file_region::init(&v47, v57.st_atimespec.tv_sec, 0, 1))
    {
      v47 = 0;
      v48 = 0;
      v49 = 0;
      llvm::sys::fs::TempFile::discard((llvm::sys::fs::TempFile *)&v57, &v55);
      v43 = v55;
      v55 = 0;
      v56 = v43;
      sub_1C4D62BD4(&v56, (char **)v58);
      if (v56)
        (*(void (**)(char *))(*(_QWORD *)v56 + 8))(v56);
      if (v55)
        (*(void (**)(char *))(*(_QWORD *)v55 + 8))(v55);
      sub_1C5DF46CC((uint64_t)v58, a1, a2, a3, v14);
      *(_BYTE *)(a5 + 8) = *(_BYTE *)(a5 + 8) & 0xFE | v58[8] & 1;
      *(_QWORD *)a5 = *(_QWORD *)v58;
      goto LABEL_34;
    }
    v23 = operator new();
    st_ino = v57.st_ino;
    *(_QWORD *)v58 = *(_QWORD *)&v57.st_uid;
    *(_QWORD *)&v58[7] = *(_QWORD *)((char *)&v57.st_gid + 3);
    v25 = *((_BYTE *)&v57.st_rdev + 7);
    *((_BYTE *)&v57.st_rdev + 7) = 0;
    LOBYTE(v57.st_ino) = 0;
    tv_sec = v57.st_atimespec.tv_sec;
    LOBYTE(v57.st_dev) = 1;
    LODWORD(v57.st_atimespec.tv_sec) = -1;
    v28 = v47;
    v27 = v48;
    v29 = v49;
    v47 = 0;
    v48 = 0;
    v49 = 0;
    if (a2 >= 0x7FFFFFFFFFFFFFF8)
      abort();
    v30 = v23;
    v45 = v29;
    v46 = v27;
    if (a2 >= 0x17)
    {
      v32 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((a2 | 7) != 0x17)
        v32 = a2 | 7;
      v44 = v28;
      v33 = tv_sec;
      v34 = v25;
      v35 = st_ino;
      v36 = v32 + 1;
      v31 = operator new(v32 + 1);
      v37 = v36 | 0x8000000000000000;
      st_ino = v35;
      v25 = v34;
      tv_sec = v33;
      v28 = v44;
      *(_QWORD *)(v30 + 16) = a2;
      *(_QWORD *)(v30 + 24) = v37;
      *(_QWORD *)(v30 + 8) = v31;
    }
    else
    {
      v31 = (void *)(v23 + 8);
      *(_BYTE *)(v23 + 31) = a2;
      if (!a2)
        goto LABEL_33;
    }
    memmove(v31, a1, a2);
LABEL_33:
    *((_BYTE *)v31 + a2) = 0;
    *(_QWORD *)v30 = off_1E81A10B8;
    *(_QWORD *)(v30 + 32) = v28;
    *(_QWORD *)(v30 + 40) = v46;
    *(_DWORD *)(v30 + 48) = v45;
    *(_BYTE *)(v30 + 56) = 0;
    v38 = *(_QWORD *)v58;
    *(_QWORD *)(v30 + 64) = st_ino;
    *(_QWORD *)(v30 + 72) = v38;
    *(_QWORD *)(v30 + 79) = *(_QWORD *)&v58[7];
    *(_BYTE *)(v30 + 87) = v25;
    *(_DWORD *)(v30 + 88) = tv_sec;
    *(_BYTE *)(a5 + 8) &= ~1u;
    *(_QWORD *)a5 = v30;
LABEL_34:
    if (v48)
      munmap(v48, v47);
    goto LABEL_36;
  }
  v40 = v21;
  llvm::sys::fs::TempFile::discard((llvm::sys::fs::TempFile *)&v57, &v56);
  v41 = v56;
  v56 = 0;
  *(_QWORD *)v58 = v41;
  sub_1C4D62BD4((char **)v58, (char **)&v47);
  if (*(_QWORD *)v58)
    (*(void (**)(_QWORD))(**(_QWORD **)v58 + 8))(*(_QWORD *)v58);
  if (v56)
    (*(void (**)(char *))(*(_QWORD *)v56 + 8))(v56);
  v42 = (_QWORD *)operator new();
  *v42 = &off_1E81A0D28;
  v42[1] = v22;
  v42[2] = v40;
  *(_BYTE *)(a5 + 8) |= 1u;
  *(_QWORD *)a5 = v42;
LABEL_36:
  if (*((char *)&v57.st_rdev + 7) < 0)
    operator delete((void *)v57.st_ino);
  if ((v63 & 1) != 0)
    goto LABEL_39;
  if (SHIBYTE(v61) < 0)
    operator delete((void *)v60);
}

uint64_t sub_1C5DF46CC(uint64_t a1, const void *a2, size_t a3, uint64_t a4, int a5)
{
  uint64_t v10;
  const std::error_category *v11;
  uint64_t result;
  uint64_t v13;
  char v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  const std::error_category *v21;
  __int128 v22;
  uint64_t v23;

  LODWORD(v20) = 0;
  v21 = std::system_category();
  llvm::sys::Memory::allocateMappedMemory(a4, 0, 50331648, (uint64_t)&v20, (uint64_t)&v18);
  if (!(_DWORD)v20)
  {
    result = operator new();
    v22 = v18;
    v23 = v19;
    if (a3 >= 0x7FFFFFFFFFFFFFF8)
      abort();
    v13 = result;
    if (a3 >= 0x17)
    {
      v16 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((a3 | 7) != 0x17)
        v16 = a3 | 7;
      v17 = v16 + 1;
      v15 = operator new(v16 + 1);
      *(_QWORD *)(v13 + 16) = a3;
      *(_QWORD *)(v13 + 24) = v17 | 0x8000000000000000;
      *(_QWORD *)(v13 + 8) = v15;
    }
    else
    {
      v15 = (void *)(result + 8);
      *(_BYTE *)(result + 31) = a3;
      if (!a3)
        goto LABEL_11;
    }
    result = (uint64_t)memmove(v15, a2, a3);
LABEL_11:
    *((_BYTE *)v15 + a3) = 0;
    *(_QWORD *)v13 = off_1E81A1028;
    *(_OWORD *)(v13 + 32) = v22;
    *(_QWORD *)(v13 + 48) = v23;
    *(_QWORD *)(v13 + 56) = a4;
    *(_DWORD *)(v13 + 64) = a5;
    v14 = *(_BYTE *)(a1 + 8) & 0xFE;
    goto LABEL_12;
  }
  v10 = v20;
  v11 = v21;
  result = operator new();
  v13 = result;
  *(_QWORD *)result = &off_1E81A0D28;
  *(_QWORD *)(result + 8) = v10;
  *(_QWORD *)(result + 16) = v11;
  v14 = *(_BYTE *)(a1 + 8) | 1;
LABEL_12:
  *(_BYTE *)(a1 + 8) = v14;
  *(_QWORD *)a1 = v13;
  return result;
}

uint64_t sub_1C5DF485C(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

uint64_t sub_1C5DF4864(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32) + *(_QWORD *)(a1 + 56);
}

uint64_t sub_1C5DF4874(uint64_t a1)
{
  return *(_QWORD *)(a1 + 56);
}

void sub_1C5DF487C(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  const void **v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const void *v8;
  llvm *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const void *v14;
  size_t v15;
  llvm::raw_ostream *v16;
  const void *v17;
  size_t v18;
  void *v19;
  llvm::raw_ostream *v20;
  const char *v21;
  const char *v22;
  _QWORD v23[4];
  char *v24;
  int v25;

  v4 = (const void **)(a1 + 8);
  v5 = *(unsigned __int8 *)(a1 + 31);
  v6 = *(_QWORD *)(a1 + 16);
  if ((v5 & 0x80u) == 0)
    v7 = v5 & 0x7F;
  else
    v7 = *(_QWORD *)(a1 + 16);
  if (v7 != 1)
    goto LABEL_9;
  v8 = (const void *)(a1 + 8);
  if ((v5 & 0x80) != 0)
  {
    v8 = *v4;
    v5 = v6;
  }
  v9 = (llvm *)memcmp(v8, "-", v5 != 0);
  if (v5 == 1 && !(_DWORD)v9)
  {
    v16 = (llvm::raw_ostream *)llvm::outs(v9);
    v17 = *(const void **)(a1 + 32);
    v18 = *(_QWORD *)(a1 + 56);
    v19 = (void *)*((_QWORD *)v16 + 4);
    if (v18 <= *((_QWORD *)v16 + 3) - (_QWORD)v19)
    {
      if (v18)
      {
        v19 = memcpy(v19, v17, v18);
        *((_QWORD *)v16 + 4) += v18;
      }
    }
    else
    {
      v19 = llvm::raw_ostream::write(v16, (const char *)v17, v18);
    }
    v20 = (llvm::raw_ostream *)llvm::outs((llvm *)v19);
    v21 = (const char *)*((_QWORD *)v20 + 4);
    v22 = (const char *)*((_QWORD *)v20 + 2);
    if (v21 != v22)
    {
      *((_QWORD *)v20 + 4) = v22;
      llvm::raw_ostream::flush_tied_then_write(v20, v22, v21 - v22);
    }
    *a2 = 0;
  }
  else
  {
LABEL_9:
    v25 = 0;
    std::system_category();
    LOWORD(v24) = 260;
    v23[0] = v4;
    v11 = llvm::sys::fs::openFile((unsigned __int8 *)v23, &v25, 0, 2, 0, *(unsigned int *)(a1 + 64));
    if ((_DWORD)v11)
    {
      v12 = v10;
      v13 = (_QWORD *)operator new();
      *v13 = &off_1E81A0D28;
      v13[1] = v11;
      v13[2] = v12;
      *a2 = v13;
    }
    else
    {
      llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)v23, v25, 1, 1, 0);
      v14 = *(const void **)(a1 + 32);
      v15 = *(_QWORD *)(a1 + 56);
      if (v15 <= v23[3] - (_QWORD)v24)
      {
        if (v15)
        {
          memcpy(v24, v14, v15);
          v24 += v15;
        }
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)v23, (const char *)v14, v15);
      }
      *a2 = 0;
      llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)v23);
    }
  }
}

uint64_t sub_1C5DF4A40(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)a1 = off_1E81A1028;
  v3 = *(_QWORD *)(a1 + 32);
  v2 = a1 + 32;
  if (v3)
    llvm::sys::Memory::releaseMappedMemory(v2);
  *(_QWORD *)a1 = &unk_1E81A1070;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  return a1;
}

void sub_1C5DF4A98(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)a1 = off_1E81A1028;
  v3 = *(_QWORD *)(a1 + 32);
  v2 = a1 + 32;
  if (v3)
    llvm::sys::Memory::releaseMappedMemory(v2);
  *(_QWORD *)a1 = &unk_1E81A1070;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C5DF4B00(uint64_t a1)
{
  return *(_QWORD *)(a1 + 40);
}

uint64_t sub_1C5DF4B08(uint64_t a1)
{
  return *(_QWORD *)(a1 + 40) + *(_QWORD *)(a1 + 32);
}

uint64_t sub_1C5DF4B14(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

_QWORD *sub_1C5DF4B1C@<X0>(uint64_t a1@<X0>, const llvm::Twine *a2@<X2>, _QWORD *a3@<X8>)
{
  uint64_t v5;
  void *v6;
  _QWORD v8[4];
  __int16 v9;

  v5 = a1 + 32;
  v6 = *(void **)(a1 + 40);
  if (v6)
    munmap(v6, *(_QWORD *)v5);
  *(_QWORD *)v5 = 0;
  *(_QWORD *)(v5 + 8) = 0;
  *(_DWORD *)(v5 + 16) = 0;
  v9 = 260;
  v8[0] = a1 + 8;
  return llvm::sys::fs::TempFile::keep((llvm::sys::fs::TempFile *)(a1 + 56), (const llvm::Twine *)v8, a2, a3);
}

uint64_t sub_1C5DF4B88(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  char *v4;
  void *v5;
  char *v7;
  char *v8;
  char *v9;

  *(_QWORD *)a1 = off_1E81A10B8;
  v2 = a1 + 32;
  v3 = *(void **)(a1 + 40);
  if (v3)
    munmap(v3, *(_QWORD *)v2);
  *(_QWORD *)v2 = 0;
  *(_QWORD *)(v2 + 8) = 0;
  *(_DWORD *)(v2 + 16) = 0;
  llvm::sys::fs::TempFile::discard((llvm::sys::fs::TempFile *)(a1 + 56), &v7);
  v4 = v7;
  v7 = 0;
  v8 = v4;
  sub_1C4D62BD4(&v8, &v9);
  if (v8)
    (*(void (**)(char *))(*(_QWORD *)v8 + 8))(v8);
  if (v7)
    (*(void (**)(char *))(*(_QWORD *)v7 + 8))(v7);
  if (*(char *)(a1 + 87) < 0)
    operator delete(*(void **)(a1 + 64));
  v5 = *(void **)(a1 + 40);
  if (v5)
    munmap(v5, *(_QWORD *)v2);
  *(_QWORD *)a1 = &unk_1E81A1070;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  return a1;
}

void sub_1C5DF4C64(uint64_t a1)
{
  sub_1C5DF4B88(a1);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C5DF4C88(uint64_t a1)
{
  char *v1;
  uint64_t result;
  char *v3;
  char *v4;
  char *v5;

  llvm::sys::fs::TempFile::discard((llvm::sys::fs::TempFile *)(a1 + 56), &v3);
  v1 = v3;
  v3 = 0;
  v4 = v1;
  sub_1C4D62BD4(&v4, &v5);
  if (v4)
    (*(void (**)(char *))(*(_QWORD *)v4 + 8))(v4);
  result = (uint64_t)v3;
  if (v3)
    return (*(uint64_t (**)(char *))(*(_QWORD *)v3 + 8))(v3);
  return result;
}

BOOL llvm::FoldingSetNodeIDRef::operator==(uint64_t a1, const void *a2, uint64_t a3)
{
  return *(_QWORD *)(a1 + 8) == a3 && memcmp(*(const void **)a1, a2, 4 * a3) == 0;
}

BOOL llvm::FoldingSetNodeIDRef::operator<(uint64_t a1, const void *a2, unint64_t a3)
{
  unint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  if (v3 == a3)
    return memcmp(*(const void **)a1, a2, 4 * a3) >> 31;
  else
    return v3 < a3;
}

unsigned int *llvm::FoldingSetNodeID::AddString(unsigned int *result, unsigned __int8 *a2, unsigned int a3)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  unsigned int i;
  int v13;
  unsigned int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;

  v5 = (uint64_t)result;
  v6 = result[2];
  v7 = result[3];
  v8 = v6 + (((unint64_t)a3 + 3) >> 2) + 1;
  if (v8 > v7)
  {
    result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)result, (uint64_t)(result + 4), v8, 4);
    LODWORD(v6) = *(_DWORD *)(v5 + 8);
    LODWORD(v7) = *(_DWORD *)(v5 + 12);
  }
  if (v6 >= v7)
  {
    result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod(v5, v5 + 16, v6 + 1, 4);
    LODWORD(v6) = *(_DWORD *)(v5 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v5 + 4 * v6) = a3;
  v9 = *(_DWORD *)(v5 + 8) + 1;
  *(_DWORD *)(v5 + 8) = v9;
  if (a3)
  {
    if ((a2 & 3) != 0)
    {
      for (i = 4; i <= a3; i += 4)
      {
        v16 = a2[i - 1];
        v17 = a2[i - 2];
        v18 = a2[i - 3];
        v19 = a2[i - 4];
        if (v9 >= *(_DWORD *)(v5 + 12))
        {
          v21 = a2[i - 1];
          v22 = a2[i - 3];
          v20 = a2[i - 4];
          result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod(v5, v5 + 16, v9 + 1, 4);
          v19 = v20;
          v16 = v21;
          v18 = v22;
          v9 = *(_DWORD *)(v5 + 8);
        }
        *(_DWORD *)(*(_QWORD *)v5 + 4 * v9) = (v16 << 24) | (v17 << 16) | (v18 << 8) | v19;
        v9 = *(_DWORD *)(v5 + 8) + 1;
        *(_DWORD *)(v5 + 8) = v9;
      }
    }
    else
    {
      v10 = a3 >> 2;
      v11 = v10 + v9;
      if (v11 > *(unsigned int *)(v5 + 12))
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod(v5, v5 + 16, v11, 4);
        v9 = *(_DWORD *)(v5 + 8);
      }
      if (a3 >> 2)
      {
        result = (unsigned int *)memcpy((void *)(*(_QWORD *)v5 + 4 * v9), a2, 4 * v10);
        v9 = *(_DWORD *)(v5 + 8);
      }
      v9 += (unint64_t)(4 * v10) >> 2;
      *(_DWORD *)(v5 + 8) = v9;
      i = (a3 & 0xFFFFFFFC) + 4;
    }
    v13 = 0;
    v14 = i - a3;
    if (i - a3 != 3)
    {
      if (v14 != 2)
      {
        if (v14 != 1)
          return result;
        v13 = a2[a3 - 3] << 16;
      }
      v13 |= a2[a3 - 2] << 8;
    }
    v15 = v13 | a2[a3 - 1];
    if (v9 >= *(_DWORD *)(v5 + 12))
    {
      result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod(v5, v5 + 16, v9 + 1, 4);
      v9 = *(_DWORD *)(v5 + 8);
    }
    *(_DWORD *)(*(_QWORD *)v5 + 4 * v9) = v15;
    ++*(_DWORD *)(v5 + 8);
  }
  return result;
}

unsigned int *llvm::FoldingSetNodeID::AddNodeID(unsigned int *result, uint64_t a2)
{
  unsigned int *v2;
  const void *v3;
  uint64_t v4;
  uint64_t v5;

  v2 = result;
  v3 = *(const void **)a2;
  v4 = *(unsigned int *)(a2 + 8);
  v5 = result[2];
  if (v5 + v4 > (unint64_t)result[3])
  {
    result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)result, (uint64_t)(result + 4), v5 + v4, 4);
    LODWORD(v5) = v2[2];
  }
  if ((_DWORD)v4)
  {
    result = (unsigned int *)memcpy((void *)(*(_QWORD *)v2 + 4 * v5), v3, 4 * v4);
    LODWORD(v5) = v2[2];
  }
  v2[2] = v5 + v4;
  return result;
}

BOOL llvm::FoldingSetNodeID::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(unsigned int *)(a2 + 8);
  return (_DWORD)v2 == *(_DWORD *)(a1 + 8) && memcmp(*(const void **)a1, *(const void **)a2, 4 * v2) == 0;
}

BOOL llvm::FoldingSetNodeID::operator==(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(unsigned int *)(a1 + 8);
  return a3 == v3 && memcmp(*(const void **)a1, a2, 4 * v3) == 0;
}

BOOL llvm::FoldingSetNodeID::operator<(uint64_t a1, const void *a2, unint64_t a3)
{
  unint64_t v3;

  v3 = *(unsigned int *)(a1 + 8);
  if (a3 == v3)
    return memcmp(*(const void **)a1, a2, 4 * v3) >> 31;
  else
    return a3 > v3;
}

unint64_t llvm::FoldingSetNodeID::Intern(uint64_t a1, uint64_t a2)
{
  unint64_t result;
  uint64_t v4;
  int *v5;
  uint64_t v6;
  _DWORD *v7;
  int v8;

  result = sub_1C484358C(a2, 4 * *(unsigned int *)(a1 + 8), 2);
  v4 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v4)
  {
    v5 = *(int **)a1;
    v6 = 4 * v4;
    v7 = (_DWORD *)result;
    do
    {
      v8 = *v5++;
      *v7++ = v8;
      v6 -= 4;
    }
    while (v6);
  }
  return result;
}

llvm::FoldingSetBase *llvm::FoldingSetBase::FoldingSetBase(llvm::FoldingSetBase *this, char a2)
{
  unsigned int v3;
  _QWORD *v4;

  v3 = 1 << a2;
  *((_DWORD *)this + 2) = 1 << a2;
  v4 = malloc_type_calloc(((1 << a2) + 1), 8uLL, 0x6D9A4F0CuLL);
  if (!v4)
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  v4[v3] = -1;
  *(_QWORD *)this = v4;
  *((_DWORD *)this + 3) = 0;
  return this;
}

{
  unsigned int v3;
  _QWORD *v4;

  v3 = 1 << a2;
  *((_DWORD *)this + 2) = 1 << a2;
  v4 = malloc_type_calloc(((1 << a2) + 1), 8uLL, 0x6D9A4F0CuLL);
  if (!v4)
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  v4[v3] = -1;
  *(_QWORD *)this = v4;
  *((_DWORD *)this + 3) = 0;
  return this;
}

double llvm::FoldingSetBase::FoldingSetBase(uint64_t a1, uint64_t a2)
{
  double result;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  result = *(double *)(a2 + 8);
  *(double *)(a1 + 8) = result;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  return result;
}

{
  double result;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  result = *(double *)(a2 + 8);
  *(double *)(a1 + 8) = result;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  return result;
}

uint64_t llvm::FoldingSetBase::operator=(uint64_t a1, _QWORD *a2)
{
  free(*(void **)a1);
  *(_QWORD *)a1 = *a2;
  *(_QWORD *)(a1 + 8) = a2[1];
  *a2 = 0;
  a2[1] = 0;
  return a1;
}

void llvm::FoldingSetBase::~FoldingSetBase(void **this)
{
  free(*this);
}

{
  free(*this);
}

void llvm::FoldingSetBase::clear(void **this)
{
  bzero(*this, 8 * *((unsigned int *)this + 2));
  *((_QWORD *)*this + *((unsigned int *)this + 2)) = -1;
  *((_DWORD *)this + 3) = 0;
}

void llvm::FoldingSetBase::GrowBucketCount(uint64_t a1, int a2, uint64_t a3)
{
  _QWORD *v6;
  uint64_t v7;
  int v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t *v12;
  BOOL v13;
  uint64_t *v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  _QWORD *v21;
  unsigned int v22;
  _QWORD *v23;
  int v24;
  _BYTE *v25;
  _QWORD *v26;
  _QWORD *v27;
  _BYTE *v28;
  uint64_t v29;
  _BYTE v30[128];
  void *v31[2];
  _QWORD v32[18];

  v32[16] = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD **)a1;
  v7 = *(unsigned int *)(a1 + 8);
  v8 = a2 + 1;
  v9 = malloc_type_calloc((a2 + 1), 8uLL, 0x6D9A4F0CuLL);
  if (!v9 && (v8 || (v9 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0))
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  v9[a2] = -1;
  *(_QWORD *)a1 = v9;
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 12) = 0;
  v28 = v30;
  v29 = 0x2000000000;
  if (!(_DWORD)v7)
    goto LABEL_21;
  v10 = 0;
  v11 = v32;
  do
  {
    v12 = (uint64_t *)v6[v10];
    if (v12)
      v13 = (v6[v10] & 1) == 0;
    else
      v13 = 0;
    if (v13)
    {
      do
      {
        v14 = (uint64_t *)*v12;
        *v12 = 0;
        v15 = (*(uint64_t (**)(uint64_t, uint64_t *, _BYTE **))(a3 + 16))(a1, v12, &v28);
        v16 = *(_DWORD *)(a1 + 8);
        v17 = *(_DWORD *)(a1 + 12) + 1;
        if (v17 > 2 * v16)
        {
          llvm::FoldingSetBase::GrowBucketCount(a1, (2 * v16), a3);
          v31[0] = v11;
          v31[1] = (void *)0x2000000000;
          v20 = (*(uint64_t (**)(uint64_t, uint64_t *, void **))(a3 + 16))(a1, v12, v31);
          v21 = v11;
          v22 = v20;
          v23 = *(_QWORD **)a1;
          v24 = *(_DWORD *)(a1 + 8);
          v27 = v21;
          if (v31[0] != v21)
          {
            v26 = *(_QWORD **)a1;
            free(v31[0]);
            v23 = v26;
          }
          v18 = (uint64_t)&v23[(v24 - 1) & v22];
          v17 = *(_DWORD *)(a1 + 12) + 1;
          v11 = v27;
        }
        else
        {
          v18 = *(_QWORD *)a1 + 8 * ((v16 - 1) & v15);
        }
        *(_DWORD *)(a1 + 12) = v17;
        v19 = *(_QWORD *)v18;
        if (!*(_QWORD *)v18)
          v19 = v18 | 1;
        *v12 = v19;
        *(_QWORD *)v18 = v12;
        LODWORD(v29) = 0;
        if (!v14)
          break;
        v12 = v14;
      }
      while ((v14 & 1) == 0);
    }
    ++v10;
  }
  while (v10 != v7);
  v25 = v28;
  free(v6);
  v6 = v25;
  if (v25 != v30)
LABEL_21:
    free(v6);
}

void llvm::FoldingSetBase::InsertNode(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v10;
  void *v11[2];
  _QWORD v12[17];

  v12[16] = *MEMORY[0x1E0C80C00];
  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(a1 + 12) + 1;
  if (v7 > 2 * v6)
  {
    llvm::FoldingSetBase::GrowBucketCount(a1, 2 * v6, a4);
    v11[0] = v12;
    v11[1] = (void *)0x2000000000;
    a3 = *(_QWORD *)a1
       + 8
       * ((*(_DWORD *)(a1 + 8) - 1) & (*(unsigned int (**)(uint64_t, uint64_t *, void **))(a4 + 16))(a1, a2, v11));
    if (v11[0] != v12)
    {
      v10 = a3;
      free(v11[0]);
      a3 = v10;
    }
    v7 = *(_DWORD *)(a1 + 12) + 1;
  }
  *(_DWORD *)(a1 + 12) = v7;
  v8 = *(_QWORD *)a3;
  if (!*(_QWORD *)a3)
    v8 = a3 | 1;
  *a2 = v8;
  *(_QWORD *)a3 = a2;
}

void llvm::FoldingSetBase::GrowHashTable(uint64_t a1, uint64_t a2)
{
  llvm::FoldingSetBase::GrowBucketCount(a1, 2 * *(_DWORD *)(a1 + 8), a2);
}

void llvm::FoldingSetBase::reserve(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3;
  int v4;

  if (a2 >= 2 * *(_DWORD *)(a1 + 8))
  {
    v3 = 1 << ~__clz(a2);
    if (a2)
      v4 = v3;
    else
      v4 = 0;
    llvm::FoldingSetBase::GrowBucketCount(a1, v4, a3);
  }
}

_QWORD *llvm::FoldingSetBase::FindNodeOrInsertPos(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  unint64_t v8;
  _QWORD **v9;
  _QWORD *v10;
  void *v13;
  uint64_t v14;
  _QWORD v15[17];

  v15[16] = *MEMORY[0x1E0C80C00];
  v8 = sub_1C4F5AB38(*(_QWORD **)a2, *(_QWORD *)a2 + 4 * *(unsigned int *)(a2 + 8));
  v9 = (_QWORD **)(*(_QWORD *)a1 + 8 * ((*(_DWORD *)(a1 + 8) - 1) & v8));
  v10 = *v9;
  *a3 = 0;
  v13 = v15;
  v14 = 0x2000000000;
  while (v10 && (v10 & 1) == 0)
  {
    if (((*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, unint64_t, void **))(a4 + 8))(a1, v10, a2, v8, &v13) & 1) != 0)goto LABEL_9;
    LODWORD(v14) = 0;
    v10 = (_QWORD *)*v10;
  }
  v10 = 0;
  *a3 = v9;
LABEL_9:
  if (v13 != v15)
    free(v13);
  return v10;
}

BOOL llvm::FoldingSetBase::RemoveNode(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  unint64_t v3;
  unint64_t *v4;

  v2 = (_QWORD *)*a2;
  if (*a2)
  {
    --*(_DWORD *)(a1 + 12);
    *a2 = 0;
    v3 = (unint64_t)v2;
    do
    {
      v4 = (unint64_t *)v3;
      if (!v3 || (v3 & 1) != 0)
        v4 = (unint64_t *)(v3 & 0xFFFFFFFFFFFFFFFELL);
      v3 = *v4;
    }
    while ((_QWORD *)*v4 != a2);
    *v4 = (unint64_t)v2;
  }
  return v2 != 0;
}

_QWORD *llvm::FoldingSetBase::GetOrInsertNode(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  unint64_t v6;
  int v7;
  uint64_t v8;
  _QWORD *v9;
  BOOL v10;
  BOOL v11;
  unsigned int v12;
  uint64_t v13;
  void *v15;
  uint64_t v16;
  _BYTE v17[128];
  void *v18;
  uint64_t v19;
  _QWORD v20[17];

  v20[16] = *MEMORY[0x1E0C80C00];
  v15 = v17;
  v16 = 0x2000000000;
  (*(void (**)(uint64_t, uint64_t *, void **))a3)(a1, a2, &v15);
  v6 = sub_1C4F5AB38(v15, (uint64_t)v15 + 4 * v16);
  v7 = *(_DWORD *)(a1 + 8);
  v8 = *(_QWORD *)a1 + 8 * ((v7 - 1) & v6);
  v9 = *(_QWORD **)v8;
  v18 = v20;
  v19 = 0x2000000000;
  if (v9)
    v10 = (v9 & 1) == 0;
  else
    v10 = 0;
  if (!v10)
    goto LABEL_17;
  while (((*(uint64_t (**)(uint64_t, _QWORD *, void **, unint64_t, void **))(a3 + 8))(a1, v9, &v15, v6, &v18) & 1) == 0)
  {
    LODWORD(v19) = 0;
    v9 = (_QWORD *)*v9;
    if (v9)
      v11 = (v9 & 1) == 0;
    else
      v11 = 0;
    if (!v11)
    {
      v9 = 0;
      goto LABEL_13;
    }
  }
  v8 = 0;
LABEL_13:
  if (v18 != v20)
    free(v18);
  if (!v9)
  {
    v7 = *(_DWORD *)(a1 + 8);
LABEL_17:
    v12 = *(_DWORD *)(a1 + 12) + 1;
    if (v12 > 2 * v7)
    {
      llvm::FoldingSetBase::GrowBucketCount(a1, 2 * v7, a3);
      v18 = v20;
      v19 = 0x2000000000;
      v8 = *(_QWORD *)a1
         + 8
         * ((*(_DWORD *)(a1 + 8) - 1) & (*(unsigned int (**)(uint64_t, uint64_t *, void **))(a3 + 16))(a1, a2, &v18));
      if (v18 != v20)
        free(v18);
      v12 = *(_DWORD *)(a1 + 12) + 1;
    }
    *(_DWORD *)(a1 + 12) = v12;
    v13 = *(_QWORD *)v8;
    if (!*(_QWORD *)v8)
      v13 = v8 | 1;
    *a2 = v13;
    *(_QWORD *)v8 = a2;
    v9 = a2;
  }
  if (v15 != v17)
    free(v15);
  return v9;
}

unint64_t *llvm::FoldingSetIteratorImpl::FoldingSetIteratorImpl(unint64_t *this, void **a2)
{
  unint64_t v2;

  while (1)
  {
    v2 = (unint64_t)*a2;
    if (*a2)
    {
      if (v2 == -1)
        break;
      if (v2 && ((unint64_t)*a2 & 1) == 0)
        break;
    }
    ++a2;
  }
  *this = v2;
  return this;
}

{
  unint64_t v2;

  while (1)
  {
    v2 = (unint64_t)*a2;
    if (*a2)
    {
      if (v2 == -1)
        break;
      if (v2 && ((unint64_t)*a2 & 1) == 0)
        break;
    }
    ++a2;
  }
  *this = v2;
  return this;
}

unint64_t **llvm::FoldingSetIteratorImpl::advance(unint64_t **this)
{
  unint64_t v1;
  BOOL v2;
  unint64_t *i;

  v1 = **this;
  if (v1)
    v2 = (**this & 1) == 0;
  else
    v2 = 0;
  if (!v2)
  {
    for (i = (unint64_t *)((v1 & 0xFFFFFFFFFFFFFFFELL) + 8); ; ++i)
    {
      v1 = *i;
      if (*i)
      {
        if (v1 == -1)
          break;
        if (v1 && (*i & 1) == 0)
          break;
      }
    }
  }
  *this = (unint64_t *)v1;
  return this;
}

void ***llvm::FoldingSetBucketIteratorImpl::FoldingSetBucketIteratorImpl(void ***this, void **a2)
{
  void **v2;
  void **v3;

  if (((unint64_t)*a2 & 1) != 0)
    v2 = a2;
  else
    v2 = (void **)*a2;
  if (*a2)
    v3 = v2;
  else
    v3 = a2;
  *this = v3;
  return this;
}

{
  void **v2;
  void **v3;

  if (((unint64_t)*a2 & 1) != 0)
    v2 = a2;
  else
    v2 = (void **)*a2;
  if (*a2)
    v3 = v2;
  else
    v3 = a2;
  *this = v3;
  return this;
}

void llvm::PrintfStyleFormatReader::refillSpecifierQueue(llvm::PrintfStyleFormatReader *this)
{
  char *i;
  char *v3;
  uint64_t v4;
  void **v5;
  uint64_t v6;
  unsigned __int8 *v7;
  unint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  unsigned __int8 *v14;
  int v15;
  unsigned __int8 *v16;
  unsigned int v17;
  int v18;
  int v19;
  uint64_t v20;
  int v21;
  _BYTE *v22;
  unint64_t v23;
  char *v24;
  char *v25;
  char v26;
  uint64_t v28;
  __int128 v29;
  unint64_t v30;
  unint64_t v31;
  char *v32;
  char *v33;
  unint64_t v34;
  char v35;
  unint64_t v36;
  unint64_t v37;
  void *v38;
  __int128 v39;
  _BYTE v40[8];

  for (i = *(char **)this; ; *(_QWORD *)this = i)
  {
    v3 = strchr(i, 37);
    if (!v3)
    {
      v4 = *((_QWORD *)this + 2);
      if ((unint64_t)(v4 + 1) > *((_QWORD *)this + 3))
      {
        llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)this + 8, (char *)this + 32, v4 + 1, 1);
        v4 = *((_QWORD *)this + 2);
      }
      *(_BYTE *)(*((_QWORD *)this + 1) + v4) = 0;
      ++*((_QWORD *)this + 2);
      return;
    }
    *(_QWORD *)this = v3 + 1;
    if (v3[1] != 37)
      break;
    i = v3 + 2;
  }
  v5 = (void **)((char *)this + 8);
  v6 = *((_QWORD *)this + 2);
  if ((unint64_t)(v6 + 1) > *((_QWORD *)this + 3))
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)this + 8, (char *)this + 32, v6 + 1, 1);
    v6 = *((_QWORD *)this + 2);
  }
  *(_BYTE *)(*((_QWORD *)this + 1) + v6) = 1;
  ++*((_QWORD *)this + 2);
  v38 = v40;
  v39 = xmmword_1C8668E60;
  v7 = (unsigned __int8 *)(*(_QWORD *)this + 1);
  v8 = 0x129C2FA010000E2;
  while (1)
  {
    v9 = (char)*(v7 - 1);
    if (v9 <= 42)
      break;
    if (v9 != 43 && v9 != 45)
    {
      if (v9 != 48)
        goto LABEL_20;
      v8 &= 0x12082F2010000E2uLL;
    }
LABEL_19:
    *(_QWORD *)this = v7++;
  }
  if (v9 == 32)
    goto LABEL_19;
  if (v9 == 35)
  {
    v8 &= 0x10000E2010000E2uLL;
    goto LABEL_19;
  }
LABEL_20:
  v10 = *(v7 - 1);
  if (v10 == 42)
  {
    v40[0] = 3;
    v11 = 1;
    *(_QWORD *)&v39 = 1;
    *(_QWORD *)this = v7;
    v10 = *v7;
  }
  else
  {
    if ((v10 - 48) <= 9)
    {
      do
      {
        *(_QWORD *)this = v7;
        v12 = *v7++;
        v10 = v12;
      }
      while ((v12 - 48) < 0xA);
    }
    v11 = 0;
    --v7;
  }
  if (v10 == 46)
  {
    v8 &= 0x12882F2010000E2uLL;
    *(_QWORD *)this = v7 + 1;
    v13 = v7[1];
    if (v13 == 42)
    {
      v40[v11++] = 3;
      *(_QWORD *)&v39 = v11;
      v7 += 2;
      *(_QWORD *)this = v7;
    }
    else if ((v13 - 48) > 9)
    {
      ++v7;
    }
    else
    {
      v14 = v7 + 2;
      do
      {
        *(_QWORD *)this = v14;
        v15 = *v14++;
      }
      while ((v15 - 48) < 0xA);
      v7 = v14 - 1;
    }
  }
  v16 = v7 + 1;
  v17 = 2;
  while (2)
  {
    v18 = (char)*(v16 - 1);
    if (v18 <= 107)
    {
      switch(v18)
      {
        case 'L':
          v19 = 8;
          goto LABEL_51;
        case 'h':
          if (v17 != 1)
          {
            v19 = 1;
            goto LABEL_51;
          }
          v19 = 0;
          break;
        case 'j':
          v19 = 5;
LABEL_51:
          if (v17 != 2)
            goto LABEL_85;
          break;
        default:
          goto LABEL_53;
      }
LABEL_52:
      *(_QWORD *)this = v16++;
      v17 = v19;
      continue;
    }
    break;
  }
  switch(v18)
  {
    case 'l':
      if (v17 != 3)
      {
        v19 = 3;
        goto LABEL_51;
      }
      v19 = 4;
      goto LABEL_52;
    case 't':
      v19 = 7;
      goto LABEL_51;
    case 'z':
      v19 = 6;
      goto LABEL_51;
  }
LABEL_53:
  if (*(v16 - 1))
  {
    *(_QWORD *)this = v16;
    if ((char)v18 >= 64 && ((v8 >> v18) & 1) != 0)
    {
      v20 = 0;
      switch(v18)
      {
        case 'X':
        case 'd':
        case 'i':
        case 'o':
        case 'u':
        case 'x':
          goto LABEL_61;
        case 'Y':
        case 'Z':
        case '[':
        case '\\':
        case ']':
        case '^':
        case '_':
        case 'b':
        case 'h':
        case 'j':
        case 'k':
        case 'l':
        case 'm':
        case 'q':
        case 'r':
        case 't':
        case 'v':
        case 'w':
          break;
        case 'a':
        case 'e':
        case 'f':
        case 'g':
          goto LABEL_60;
        case 'c':
          v20 = 2;
          goto LABEL_61;
        case 'n':
          v20 = 5;
          goto LABEL_61;
        case 'p':
          v20 = 4;
          goto LABEL_61;
        case 's':
          v20 = 3;
          goto LABEL_61;
        default:
          if ((v18 - 69) < 3 || v18 == 65)
          {
LABEL_60:
            v20 = 1;
LABEL_61:
            v21 = byte_1C866F911[(v20 | (8 * v20)) + v17];
            if (v21 != 1)
            {
              v40[v11] = v21;
              v22 = v38;
              v23 = v39 + 1;
              *(_QWORD *)&v39 = v23;
              if (v23)
              {
                v24 = (char *)v38 + v23 - 1;
                if (v38 < v24)
                {
                  v25 = (char *)v38 + 1;
                  do
                  {
                    v26 = *(v25 - 1);
                    *(v25 - 1) = *v24;
                    *v24-- = v26;
                  }
                  while (v25++ < v24);
                }
              }
              if (&v38 != v5)
              {
                if (v22 == v40
                  || *((llvm::PrintfStyleFormatReader **)this + 1) == (llvm::PrintfStyleFormatReader *)((char *)this + 32))
                {
                  if (*((_QWORD *)&v39 + 1) < *((_QWORD *)this + 2))
                  {
                    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v38, v40, *((_QWORD *)this + 2), 1);
                    v23 = v39;
                  }
                  if (*((_QWORD *)this + 3) < v23)
                  {
                    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)this + 8, (char *)this + 32, v23, 1);
                    v23 = v39;
                  }
                  v30 = *((_QWORD *)this + 2);
                  if (v23 >= v30)
                    v31 = *((_QWORD *)this + 2);
                  else
                    v31 = v23;
                  if (v31)
                  {
                    v32 = (char *)v38;
                    v33 = (char *)*v5;
                    v34 = v31;
                    do
                    {
                      v35 = *v32;
                      *v32++ = *v33;
                      *v33++ = v35;
                      --v34;
                    }
                    while (v34);
                  }
                  v36 = v23 - v30;
                  if (v23 <= v30)
                  {
                    v37 = v30 - v23;
                    if (v30 > v23)
                    {
                      memcpy((char *)v38 + v23, (const void *)(*((_QWORD *)this + 1) + v31), v30 - v31);
                      *(_QWORD *)&v39 = v37 + v39;
                      *((_QWORD *)this + 2) = v31;
                    }
                  }
                  else
                  {
                    memcpy((void *)(*((_QWORD *)this + 1) + v30), (char *)v38 + v31, v23 - v31);
                    *((_QWORD *)this + 2) += v36;
                    *(_QWORD *)&v39 = v31;
                  }
                }
                else
                {
                  v38 = (void *)*((_QWORD *)this + 1);
                  v28 = *((_QWORD *)&v39 + 1);
                  v29 = *((_OWORD *)this + 1);
                  *((_QWORD *)this + 1) = v22;
                  *((_QWORD *)this + 2) = v23;
                  v39 = v29;
                  *((_QWORD *)this + 3) = v28;
                }
              }
            }
          }
          break;
      }
    }
  }
LABEL_85:
  if (v38 != v40)
    free(v38);
}

llvm::PrintfStyleFormatReader *llvm::PrintfStyleFormatReader::ensureCompatible(llvm::PrintfStyleFormatReader *this, char *a2, const char *a3)
{
  llvm::PrintfStyleFormatReader *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  const char *v10;
  void *v11;
  __int128 v12;
  uint64_t v13;
  llvm::PrintfStyleFormatReader *v14;
  void *v15;
  __int128 v16;
  uint64_t v17;

  v4 = this;
  v5 = 0;
  v14 = this;
  v15 = &v17;
  v16 = xmmword_1C8668E60;
  v10 = a2;
  v11 = &v13;
  v12 = xmmword_1C8668E60;
  while (1)
  {
    v6 = v16;
    if (!(_QWORD)v16)
    {
      llvm::PrintfStyleFormatReader::refillSpecifierQueue((llvm::PrintfStyleFormatReader *)&v14);
      v6 = v16;
      v5 = v12;
    }
    v7 = *((char *)v15 + v6 - 1);
    *(_QWORD *)&v16 = v6 - 1;
    if (!v5)
    {
      llvm::PrintfStyleFormatReader::refillSpecifierQueue((llvm::PrintfStyleFormatReader *)&v10);
      v5 = v12;
    }
    v8 = *((char *)v11 + --v5);
    *(_QWORD *)&v12 = v5;
    if (v7 != v8)
      break;
    if (!v7)
    {
      v4 = (llvm::PrintfStyleFormatReader *)a2;
      break;
    }
  }
  if (v11 != &v13)
    free(v11);
  if (v15 != &v17)
    free(v15);
  return v4;
}

uint64_t llvm::formatted_raw_ostream::UpdatePosition(uint64_t this, char *a2, uint64_t a3)
{
  char *v3;
  uint64_t v4;
  int *v5;
  _DWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  int v11;
  int v12;
  char *v13;
  unint64_t v14;
  uint64_t v15;
  const char *v16;
  _DWORD *v17[2];

  v3 = a2;
  v4 = this;
  v5 = (int *)(this + 72);
  v6 = (_DWORD *)(this + 76);
  v17[0] = (_DWORD *)(this + 76);
  v17[1] = (_DWORD *)(this + 72);
  v7 = (_QWORD *)(this + 88);
  v8 = *(_QWORD *)(this + 96);
  if (v8)
  {
    v14 = (byte_1C866F783[*(unsigned __int8 *)*v7] + 1) - v8;
    v15 = a3 - v14;
    if (a3 < v14)
    {
      v13 = &a2[a3];
      return (uint64_t)sub_1C52C2F74(v7, v3, v13);
    }
    v16 = &a2[v14];
    sub_1C52C2F74((_QWORD *)(this + 88), a2, &a2[v14]);
    this = sub_1C5DF621C(v17, *(char **)(v4 + 88), *(_QWORD *)(v4 + 96));
    *(_QWORD *)(v4 + 96) = 0;
    a3 = v15;
    v3 = (char *)v16;
  }
  if (a3 >= 1)
  {
    v9 = &v3[a3];
    do
    {
      v10 = (byte_1C866F783[*v3] + 1);
      if (v10 > (int)v9 - (int)v3)
      {
        v13 = v9;
        *(_QWORD *)(v4 + 96) = 0;
        return (uint64_t)sub_1C52C2F74(v7, v3, v13);
      }
      this = llvm::sys::unicode::columnWidthUTF8((uint64_t)v3, (byte_1C866F783[*v3] + 1));
      if ((_DWORD)this != -1)
        *v5 += this;
      if (v10 <= 1)
      {
        v11 = *v3;
        switch(v11)
        {
          case 9:
            v12 = (-*v5 & 7) + *v5;
            goto LABEL_16;
          case 13:
            v12 = 0;
            goto LABEL_16;
          case 10:
            v12 = 0;
            ++*v6;
LABEL_16:
            *v5 = v12;
            break;
        }
      }
      v3 += v10;
    }
    while (v3 < v9);
  }
  return this;
}

uint64_t sub_1C5DF621C(_DWORD **a1, char *a2, unint64_t a3)
{
  uint64_t result;
  int v7;

  result = llvm::sys::unicode::columnWidthUTF8((uint64_t)a2, a3);
  if ((_DWORD)result != -1)
    *a1[1] += result;
  if (a3 <= 1)
  {
    v7 = *a2;
    if (v7 == 9)
    {
      *a1[1] += -*a1[1] & 7;
    }
    else
    {
      if (v7 != 13)
      {
        if (v7 != 10)
          return result;
        ++**a1;
      }
      *a1[1] = 0;
    }
  }
  return result;
}

uint64_t llvm::formatted_raw_ostream::ComputePosition(llvm::formatted_raw_ostream *this, char *a2, uint64_t a3)
{
  char *v5;
  const char *v6;
  uint64_t result;

  v5 = (char *)*((_QWORD *)this + 10);
  v6 = &a2[a3];
  if (v5 < a2 || v5 > v6)
    v5 = a2;
  else
    a3 = v6 - v5;
  result = llvm::formatted_raw_ostream::UpdatePosition((uint64_t)this, v5, a3);
  *((_QWORD *)this + 10) = v6;
  return result;
}

llvm::raw_ostream *llvm::formatted_raw_ostream::PadToColumn(llvm::formatted_raw_ostream *this, int a2)
{
  char *v4;
  char *v5;
  unint64_t v6;
  char *v8;
  unint64_t v9;
  unsigned int v11;
  uint64_t v13;
  uint64_t v14;
  llvm::formatted_raw_ostream *v15;

  v4 = (char *)*((_QWORD *)this + 2);
  v5 = (char *)*((_QWORD *)this + 4);
  v6 = *((_QWORD *)this + 10);
  if (v6 < (unint64_t)v4 || v6 > (unint64_t)v5)
  {
    v13 = v5 - v4;
  }
  else
  {
    v13 = (uint64_t)&v5[-v6];
    v4 = (char *)*((_QWORD *)this + 10);
  }
  llvm::formatted_raw_ostream::UpdatePosition((uint64_t)this, v4, v13);
  *((_QWORD *)this + 10) = v5;
  v8 = (char *)*((_QWORD *)this + 2);
  v9 = *((_QWORD *)this + 4);
  if (v5 < v8 || (unint64_t)v5 > v9)
  {
    v14 = v9 - (_QWORD)v8;
    v15 = this;
  }
  else
  {
    v14 = v9 - (_QWORD)v5;
    v15 = this;
    v8 = v5;
  }
  llvm::formatted_raw_ostream::UpdatePosition((uint64_t)v15, v8, v14);
  *((_QWORD *)this + 10) = v9;
  if (a2 - *((_DWORD *)this + 18) <= 1)
    v11 = 1;
  else
    v11 = a2 - *((_DWORD *)this + 18);
  return llvm::raw_ostream::indent(this, v11);
}

llvm::raw_ostream *llvm::formatted_raw_ostream::write_impl(llvm::formatted_raw_ostream *this, char *a2, uint64_t a3)
{
  size_t v3;
  char *v6;
  const char *v7;
  llvm::raw_ostream *result;

  v3 = a3;
  v6 = (char *)*((_QWORD *)this + 10);
  v7 = &a2[a3];
  if (v6 < a2 || v6 > v7)
    v6 = a2;
  else
    a3 = v7 - v6;
  llvm::formatted_raw_ostream::UpdatePosition((uint64_t)this, v6, a3);
  *((_QWORD *)this + 10) = v7;
  result = llvm::raw_ostream::write(*((llvm::raw_ostream **)this + 8), a2, v3);
  *((_QWORD *)this + 10) = 0;
  return result;
}

uint64_t *llvm::fouts(llvm *this)
{
  unsigned __int8 v1;
  llvm *v3;
  void *v4;

  v1 = atomic_load((unsigned __int8 *)&qword_1ED825B00);
  if ((v1 & 1) == 0)
  {
    v3 = (llvm *)__cxa_guard_acquire(&qword_1ED825B00);
    if ((_DWORD)v3)
    {
      v4 = llvm::outs(v3);
      dword_1ED825B20 = 0;
      byte_1ED825B40 = 0;
      qword_1ED825B48 = 0;
      dword_1ED825B50 = 1;
      qword_1ED825B30 = 0;
      unk_1ED825B38 = 0;
      qword_1ED825B28 = 0;
      qword_1ED825B18 = (uint64_t)&off_1E81A1100;
      qword_1ED825B58 = 0;
      unk_1ED825B60 = 0;
      qword_1ED825B70 = (uint64_t)&unk_1ED825B88;
      unk_1ED825B78 = xmmword_1C6612EF0;
      sub_1C4D685DC((uint64_t)&qword_1ED825B18, (uint64_t)v4);
      __cxa_atexit((void (*)(void *))sub_1C638AE54, &qword_1ED825B18, &dword_1C475E000);
      __cxa_guard_release(&qword_1ED825B00);
    }
  }
  return &qword_1ED825B18;
}

uint64_t sub_1C5DF64EC(uint64_t a1)
{
  dword_1ED825C10 = 0;
  byte_1ED825C30 = 0;
  qword_1ED825C38 = 0;
  dword_1ED825C40 = 1;
  qword_1ED825C20 = 0;
  unk_1ED825C28 = 0;
  qword_1ED825C18 = 0;
  qword_1ED825C08 = (uint64_t)&off_1E81A1100;
  qword_1ED825C48 = 0;
  unk_1ED825C50 = 0;
  qword_1ED825C60 = (uint64_t)algn_1ED825C78;
  xmmword_1ED825C68 = xmmword_1C6612EF0;
  return sub_1C4D685DC((uint64_t)&qword_1ED825C08, a1);
}

uint64_t *llvm::ferrs(llvm *this)
{
  unsigned __int8 v1;
  llvm *v3;
  void *v4;

  v1 = atomic_load((unsigned __int8 *)&qword_1ED825B08);
  if ((v1 & 1) == 0)
  {
    v3 = (llvm *)__cxa_guard_acquire(&qword_1ED825B08);
    if ((_DWORD)v3)
    {
      v4 = llvm::errs(v3);
      dword_1ED825B98 = 0;
      byte_1ED825BB8 = 0;
      qword_1ED825BC0 = 0;
      dword_1ED825BC8 = 1;
      qword_1ED825BA8 = 0;
      unk_1ED825BB0 = 0;
      qword_1ED825BA0 = 0;
      qword_1ED825B90 = (uint64_t)&off_1E81A1100;
      qword_1ED825BD0 = 0;
      unk_1ED825BD8 = 0;
      qword_1ED825BE8 = (uint64_t)&unk_1ED825C00;
      unk_1ED825BF0 = xmmword_1C6612EF0;
      sub_1C4D685DC((uint64_t)&qword_1ED825B90, (uint64_t)v4);
      __cxa_atexit((void (*)(void *))sub_1C638AE54, &qword_1ED825B90, &dword_1C475E000);
      __cxa_guard_release(&qword_1ED825B08);
    }
  }
  return &qword_1ED825B90;
}

uint64_t llvm::formatv_object_base::consumeFieldLayout(_QWORD *a1, int *a2, unint64_t *a3, _BYTE *a4)
{
  uint64_t v4;
  unint64_t v7;
  _BYTE *v8;
  char *v9;
  int v10;
  int v11;
  uint64_t result;
  unint64_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  unint64_t v17;
  unsigned __int8 *v18;
  unsigned __int8 *v19;
  uint64_t v20;
  int v21;
  int v22;
  unsigned int v23;
  unint64_t v24;
  int v25;
  int v26;

  *a2 = 2;
  *a3 = 0;
  *a4 = 32;
  v4 = a1[1];
  if (!v4)
    return 1;
  v7 = v4 - 1;
  if (!v7)
    goto LABEL_14;
  v8 = (_BYTE *)*a1;
  v9 = (char *)(*a1 + 1);
  v10 = *v9;
  switch(v10)
  {
    case '+':
      v11 = 2;
      goto LABEL_10;
    case '-':
      v11 = 0;
      goto LABEL_10;
    case '=':
      v11 = 1;
LABEL_10:
      *a4 = *v8;
      *a2 = v11;
      v13 = a1[1];
      v14 = 2;
      if (v13 < 2)
        v14 = a1[1];
      v9 = (char *)(*a1 + v14);
      v7 = v13 - v14;
      goto LABEL_13;
  }
  v25 = (char)*v8;
  switch(v25)
  {
    case '+':
      v26 = 2;
      break;
    case '-':
      v26 = 0;
      break;
    case '=':
      v26 = 1;
      break;
    default:
      goto LABEL_14;
  }
  *a2 = v26;
LABEL_13:
  *a1 = v9;
  a1[1] = v7;
LABEL_14:
  v15 = sub_1C5E3D4C0((uint64_t)a1);
  v16 = a1[1];
  if (!v16)
    return 0;
  v17 = 0;
  v18 = (unsigned __int8 *)*a1;
  v19 = (unsigned __int8 *)(*a1 + v16);
  v20 = a1[1];
  while (1)
  {
    v21 = *v18;
    if ((v21 - 48) < 0xA)
    {
      v22 = -48;
      goto LABEL_18;
    }
    if ((v21 - 97) < 0x1A)
    {
      v22 = -87;
      goto LABEL_18;
    }
    if ((v21 - 65) > 0x19)
      break;
    v22 = -55;
LABEL_18:
    v23 = v22 + v21;
    if (v23 >= v15)
      break;
    v24 = v17 * v15 + v23;
    if (v24 / v15 < v17)
      return 0;
    ++v18;
    v17 = v24;
    if (!--v20)
      goto LABEL_34;
  }
  v24 = v17;
  v19 = v18;
LABEL_34:
  if (v16 != v20)
  {
    *a1 = v19;
    a1[1] = v20;
    result = 1;
    *a3 = v24;
    return result;
  }
  return 0;
}

double llvm::formatv_object_base::splitLiteralAndReplacement@<D0>(_BYTE *a1@<X0>, size_t a2@<X1>, uint64_t a3@<X8>)
{
  size_t v5;
  uint64_t v6;
  int v7;
  unint64_t v8;
  _BYTE *v9;
  unint64_t v10;
  _BYTE *v11;
  double result;
  size_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  size_t v17;
  _BYTE *v18;
  unint64_t v19;
  _BYTE *v20;
  size_t v21;
  unint64_t v22;
  unint64_t v23;
  __int128 v24;
  __int128 v25;
  _OWORD v26[2];
  __int128 v27;
  __int128 v28;
  char v29;

  if (a2)
  {
    v5 = a2;
    while (1)
    {
      if (*a1 != 123)
      {
        v18 = memchr(a1, 123, v5);
        v19 = v18 - a1;
        *(_DWORD *)a3 = 2;
        if (!v18)
          v19 = -1;
        if (v5 < v19)
          v19 = v5;
        *(_QWORD *)(a3 + 8) = a1;
        *(_QWORD *)(a3 + 16) = v19;
        v20 = &a1[v19];
        v21 = v5 - v19;
        *(_QWORD *)(a3 + 24) = 0;
        *(_QWORD *)(a3 + 32) = 0;
        goto LABEL_43;
      }
      v6 = 1;
      while (v5 != v6)
      {
        v7 = a1[v6++];
        if (v7 != 123)
        {
          v8 = v6 - 1;
          goto LABEL_9;
        }
      }
      v8 = -1;
LABEL_9:
      if (v5 < v8)
        v8 = v5;
      if (v8 >= 2)
      {
        *(_DWORD *)a3 = 2;
        v22 = v8 >> 1;
        if (v5 < v8 >> 1)
          v22 = v5;
        *(_QWORD *)(a3 + 8) = a1;
        *(_QWORD *)(a3 + 16) = v22;
        v23 = v8 & 0xFFFFFFFFFFFFFFFELL;
        if (v5 < v23)
          v23 = v5;
        v20 = &a1[v23];
        *(_QWORD *)(a3 + 24) = 0;
        *(_QWORD *)(a3 + 32) = 0;
        v21 = v5 - v23;
LABEL_43:
        *(_DWORD *)(a3 + 40) = 2;
        *(_BYTE *)(a3 + 44) = 0;
        *(_QWORD *)(a3 + 48) = 0;
        *(_QWORD *)(a3 + 56) = 0;
        *(_QWORD *)(a3 + 64) = v20;
        *(_QWORD *)(a3 + 72) = v21;
        return result;
      }
      v9 = memchr(a1, 125, v5);
      if (!v9 || (v10 = v9 - a1, v9 - a1 == -1))
      {
        *(_DWORD *)a3 = 2;
        *(_QWORD *)(a3 + 8) = a1;
        *(_QWORD *)(a3 + 16) = v5;
        goto LABEL_28;
      }
      if (v5 >= 2)
      {
        v11 = memchr(a1 + 1, 123, v5 - 1);
        if (v11)
        {
          v13 = v11 - a1;
          if (v11 - a1 < v10)
            break;
        }
      }
      if (v10 <= 1)
        v14 = 1;
      else
        v14 = v10;
      if (v5 < v14)
        v14 = v5;
      v15 = (uint64_t)(a1 + 1);
      v16 = v14 - 1;
      if (v5 >= v10 + 1)
        v17 = v10 + 1;
      else
        v17 = v5;
      a1 += v17;
      v5 -= v17;
      llvm::formatv_object_base::parseReplacementItem(v15, v16, (uint64_t)v26);
      if (v29)
      {
        v24 = v26[1];
        *(_OWORD *)a3 = v26[0];
        *(_OWORD *)(a3 + 16) = v24;
        result = *(double *)&v27;
        v25 = v28;
        *(_OWORD *)(a3 + 32) = v27;
        *(_OWORD *)(a3 + 48) = v25;
        *(_QWORD *)(a3 + 64) = a1;
        *(_QWORD *)(a3 + 72) = v5;
        return result;
      }
      if (!v5)
        goto LABEL_27;
    }
    *(_DWORD *)a3 = 2;
    if (v5 < v13)
      v13 = v5;
    *(_QWORD *)(a3 + 8) = a1;
    *(_QWORD *)(a3 + 16) = v13;
    *(_QWORD *)(a3 + 24) = 0;
    *(_QWORD *)(a3 + 32) = 0;
    *(_DWORD *)(a3 + 40) = 2;
    *(_BYTE *)(a3 + 44) = 0;
    *(_QWORD *)(a3 + 48) = 0;
    *(_QWORD *)(a3 + 56) = 0;
    *(_QWORD *)(a3 + 64) = &a1[v13];
    *(_QWORD *)(a3 + 72) = v5 - v13;
  }
  else
  {
LABEL_27:
    *(_DWORD *)a3 = 2;
    *(_QWORD *)(a3 + 8) = a1;
    *(_QWORD *)(a3 + 16) = 0;
LABEL_28:
    *(_QWORD *)(a3 + 24) = 0;
    *(_QWORD *)(a3 + 32) = 0;
    *(_DWORD *)(a3 + 40) = 2;
    *(_BYTE *)(a3 + 44) = 0;
    result = 0.0;
    *(_OWORD *)(a3 + 48) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
  }
  return result;
}

uint64_t llvm::GPUBaseInfo::getArchFromTriple(const std::string *a1)
{
  if (!std::string::compare(a1, 0, 4uLL, "agx1"))
    return 27;
  if (!std::string::compare(a1, 0, 4uLL, "agx2"))
    return 28;
  if (!std::string::compare(a1, 0, 4uLL, "agx3"))
    return 29;
  return 0;
}

BOOL llvm::GPUBaseInfo::getArchAllowsMergeAttributes(uint64_t a1)
{
  int v1;
  std::string __p;

  if (*(char *)(a1 + 23) < 0)
    sub_1C47EBC30(&__p, *(void **)a1, *(_QWORD *)(a1 + 8));
  else
    __p = *(std::string *)a1;
  if (!std::string::compare(&__p, 0, 4uLL, "agx1"))
  {
    v1 = 26;
  }
  else
  {
    v1 = 28;
    if (std::string::compare(&__p, 0, 4uLL, "agx2"))
    {
      if (!std::string::compare(&__p, 0, 4uLL, "agx3"))
        v1 = 28;
      else
        v1 = 0;
    }
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return v1 != 28;
}

void llvm::GlobPattern::create(_BYTE *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v6;
  unint64_t v7;
  unsigned __int8 *v8;
  int v9;
  int v10;
  int v11;
  _QWORD *v12;
  _BYTE *v13;
  uint64_t v14;
  int v15;
  _QWORD *v16;
  int v17;
  _BYTE *v18;
  _QWORD *v19;
  uint64_t v20;
  unsigned __int8 *v21;
  _BYTE *v22;
  uint64_t v23;
  unsigned __int8 *v24;
  unint64_t v25;
  unint64_t v26;
  int v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  int v32;
  unint64_t v33;
  _BYTE *v34;
  _QWORD *v35;
  const std::error_category *v36;
  uint64_t v37;
  void *v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  void *v42;
  __int128 v43;
  __int128 v44;
  void *v45;
  char v46;
  __int128 v47;
  unint64_t v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;
  void *__src;
  uint64_t v55;
  _BYTE v56[48];
  int v57;
  char v58;
  void *v59;
  uint64_t v60;
  _QWORD v61[2];
  __int16 v62;
  int v63;
  char v64;
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  LOBYTE(v50) = 0;
  BYTE8(v50) = 0;
  BYTE8(v51) = 0;
  LOBYTE(v52) = 0;
  LOBYTE(v53) = 0;
  v48 = 0;
  v47 = 0uLL;
  LOBYTE(v49) = 0;
  v59 = a1;
  v60 = a2;
  if (llvm::StringRef::find_first_of(&v59, "?*[\\", 4, 0) == -1)
  {
    LOBYTE(v50) = 1;
    *(_QWORD *)&v49 = a1;
    *((_QWORD *)&v49 + 1) = a2;
    goto LABEL_100;
  }
  if (a2)
  {
    if (a1[a2 - 1] == 42
      && (a2 < 2 || *(_WORD *)&a1[a2 - 2] != 10844)
      && (a2 >= a2 - 1 ? (v6 = a2 - 1) : (v6 = a2),
          v59 = a1,
          v60 = v6,
          llvm::StringRef::find_first_of(&v59, "?*[\\", 4, 0) == -1))
    {
      BYTE8(v51) = 1;
      *((_QWORD *)&v50 + 1) = a1;
      *(_QWORD *)&v51 = v6;
    }
    else
    {
      if (*a1 != 42)
        goto LABEL_12;
      v59 = a1 + 1;
      v60 = a2 - 1;
      if (llvm::StringRef::find_first_of(&v59, "?*[\\", 4, 0) != -1)
        goto LABEL_12;
      LOBYTE(v53) = 1;
      *(_QWORD *)&v52 = a1 + 1;
      *((_QWORD *)&v52 + 1) = a2 - 1;
    }
LABEL_100:
    *(_BYTE *)(a3 + 96) &= ~1u;
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    *(_QWORD *)a3 = 0;
    goto LABEL_102;
  }
LABEL_12:
  v46 = *(_BYTE *)(a3 + 96);
  if (a2)
  {
    v7 = a2;
    v8 = a1;
    while (1)
    {
      v9 = (char)*v8;
      if (v9 <= 90)
      {
        if (v9 == 42)
        {
          v58 &= ~1u;
          __src = v56;
          v55 = 0x600000000;
          v57 = 0;
          --v7;
          ++v8;
          goto LABEL_63;
        }
        if (v9 == 63)
        {
          v59 = v61;
          v60 = 0x600000000;
          sub_1C4765AA4((char *)&v59, 4uLL, -1);
          v10 = 256;
          v63 = 256;
          v58 &= ~1u;
          __src = v56;
          v55 = 0x600000000;
          v11 = v60;
          v12 = v59;
          if ((_DWORD)v60)
          {
            if (v59 == v61)
            {
              v13 = v56;
              v14 = v60;
              v12 = v61;
              if (v60 < 7uLL)
                goto LABEL_20;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, (uint64_t)v56, v60, 8);
              v14 = v60;
              v12 = v59;
              if ((_DWORD)v60)
              {
                v13 = __src;
LABEL_20:
                memcpy(v13, v12, 8 * v14);
                v12 = v59;
              }
              LODWORD(v55) = v11;
              v10 = v63;
            }
            else
            {
              __src = v59;
              v55 = v60;
              v59 = v61;
              HIDWORD(v60) = 0;
              v10 = 256;
              v12 = v61;
            }
            LODWORD(v60) = 0;
          }
          v57 = v10;
          if (v12 != v61)
            free(v12);
          ++v8;
          --v7;
          goto LABEL_63;
        }
LABEL_29:
        v59 = v61;
        v60 = 0x600000000;
        sub_1C4765AA4((char *)&v59, 4uLL, 0);
        v15 = 256;
        v63 = 256;
        v16 = v59;
        *(_QWORD *)((char *)v59 + (((unint64_t)*v8 >> 3) & 0x18)) |= 1 << *v8;
        if (v7)
          ++v8;
        v58 &= ~1u;
        __src = v56;
        v55 = 0x600000000;
        v17 = v60;
        if ((_DWORD)v60)
        {
          if (v16 == v61)
          {
            v18 = v56;
            v19 = v61;
            v20 = v60;
            if (v60 < 7uLL)
              goto LABEL_34;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, (uint64_t)v56, v60, 8);
            v20 = v60;
            if ((_DWORD)v60)
            {
              v19 = v59;
              v18 = __src;
LABEL_34:
              memcpy(v18, v19, 8 * v20);
            }
            LODWORD(v55) = v17;
            v15 = v63;
            v16 = v59;
          }
          else
          {
            __src = v16;
            v55 = v60;
            v59 = v61;
            HIDWORD(v60) = 0;
            v15 = 256;
            v16 = v61;
          }
          LODWORD(v60) = 0;
        }
        v57 = v15;
        if (v16 != v61)
          free(v16);
        v7 -= v7 != 0;
        goto LABEL_63;
      }
      if (v9 != 91)
      {
        if (v9 == 92)
        {
          ++v8;
          --v7;
        }
        goto LABEL_29;
      }
      if (v7 < 3 || (v21 = v8 + 2, (v22 = memchr(v8 + 2, 93, v7 - 2)) == 0) || (v23 = v22 - v8, v22 - v8 == -1))
      {
        v62 = 1283;
        v59 = "invalid glob pattern: ";
        v61[0] = a1;
        v61[1] = a2;
        v35 = (_QWORD *)operator new();
        v36 = std::generic_category();
        *v35 = off_1E81A0C88;
        llvm::Twine::str((llvm::Twine *)&v59, v35 + 1);
        v35[4] = 22;
        v35[5] = v36;
        *((_BYTE *)v35 + 48) = 1;
        v58 |= 1u;
        __src = v35;
        goto LABEL_63;
      }
      v24 = v8 + 1;
      if (v7 - 1 >= v23 - 1)
        v25 = v23 - 1;
      else
        v25 = v7 - 1;
      if (v7 >= v23 + 1)
        v26 = v23 + 1;
      else
        v26 = v7;
      v8 += v26;
      v7 -= v26;
      if (!v25 || (v27 = *v24, v27 != 94) && v27 != 33)
      {
        sub_1C5DF7344((uint64_t)&__src, v24, v25, (uint64_t)a1, a2);
        goto LABEL_63;
      }
      sub_1C5DF7344((uint64_t)&v59, v21, v25 - 1, (uint64_t)a1, a2);
      v28 = v59;
      if ((v64 & 1) != 0)
      {
        v58 |= 1u;
        __src = v59;
        goto LABEL_63;
      }
      v29 = v60;
      if ((_DWORD)v60)
      {
        v30 = 8 * v60;
        v31 = v59;
        do
        {
          *v31 = ~*v31;
          ++v31;
          v30 -= 8;
        }
        while (v30);
      }
      v32 = v63;
      if ((v63 & 0x3F) != 0)
        v28[v29 - 1] &= ~(-1 << (v63 & 0x3F));
      v58 &= ~1u;
      __src = v56;
      v55 = 0x600000000;
      if ((_DWORD)v29)
        break;
LABEL_90:
      v57 = v32;
      if ((v64 & 1) != 0)
      {
        v59 = 0;
        if (v28)
          (*(void (**)(_QWORD *))(*v28 + 8))(v28);
      }
      else if (v28 != v61)
      {
        free(v28);
      }
LABEL_63:
      if ((v58 & 1) != 0)
      {
        v45 = __src;
        *(_BYTE *)(a3 + 96) = v46 | 1;
        *(_QWORD *)a3 = v45;
        goto LABEL_103;
      }
      v37 = *((_QWORD *)&v47 + 1);
      if (*((_QWORD *)&v47 + 1) < v48)
      {
        v38 = (void *)(*((_QWORD *)&v47 + 1) + 16);
        **((_QWORD **)&v47 + 1) = *((_QWORD *)&v47 + 1) + 16;
        *(_QWORD *)(v37 + 8) = 0x600000000;
        if ((void **)v37 != &__src)
        {
          v39 = v55;
          if ((_DWORD)v55)
          {
            if (v55 < 7uLL)
            {
              v40 = v55;
              goto LABEL_72;
            }
            llvm::SmallVectorBase<unsigned int>::grow_pod(v37, v37 + 16, v55, 8);
            v40 = v55;
            if ((_DWORD)v55)
            {
              v38 = *(void **)v37;
LABEL_72:
              memcpy(v38, __src, 8 * v40);
            }
            *(_DWORD *)(v37 + 8) = v39;
          }
        }
        *(_DWORD *)(v37 + 64) = v57;
        v41 = v37 + 72;
        goto LABEL_75;
      }
      v41 = sub_1C476BAB0((uint64_t *)&v47, (uint64_t)&__src);
LABEL_75:
      *((_QWORD *)&v47 + 1) = v41;
      v42 = __src;
      if ((v58 & 1) != 0)
      {
        __src = 0;
        if (v42)
          (*(void (**)(void *))(*(_QWORD *)v42 + 8))(v42);
      }
      else if (__src != v56)
      {
        free(__src);
      }
      if (!v7)
        goto LABEL_101;
    }
    if (v29 >= 7)
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, (uint64_t)v56, v29, 8);
      v33 = v60;
      if (!(_DWORD)v60)
      {
LABEL_89:
        LODWORD(v55) = v29;
        v32 = v63;
        v28 = v59;
        goto LABEL_90;
      }
      v28 = v59;
      v34 = __src;
    }
    else
    {
      v33 = v29;
      v34 = v56;
    }
    memcpy(v34, v28, 8 * v33);
    goto LABEL_89;
  }
LABEL_101:
  *(_BYTE *)(a3 + 96) = v46 & 0xFE;
  *(_OWORD *)a3 = v47;
  *(_QWORD *)(a3 + 16) = v48;
LABEL_102:
  v43 = v49;
  *(_OWORD *)(a3 + 40) = v50;
  v44 = v52;
  *(_OWORD *)(a3 + 56) = v51;
  *(_OWORD *)(a3 + 72) = v44;
  v47 = 0uLL;
  v48 = 0;
  *(_QWORD *)(a3 + 88) = v53;
  *(_OWORD *)(a3 + 24) = v43;
LABEL_103:
  v59 = &v47;
  sub_1C476B22C((void ***)&v59);
}

uint64_t llvm::GlobPattern::matchOne(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _DWORD *i;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (a3)
  {
    v6 = 0;
    v7 = a5 - a3;
    v8 = a2 + 72;
    for (i = (_DWORD *)(a2 + 64); *i; i += 18)
    {
      if (a5 == v6
        || ((*(_QWORD *)(*((_QWORD *)i - 8) + (((unint64_t)*(unsigned __int8 *)(a4 + v6) >> 3) & 0x18)) >> *(_BYTE *)(a4 + v6)) & 1) == 0)
      {
        return 0;
      }
      ++v6;
      v8 += 72;
      if (a3 == v6)
        return v7 == 0;
    }
    if (a3 - 1 == v6)
      return 1;
    if (a5 == v6)
      return 0;
    v11 = ~v6 + a3;
    v12 = a4 + v6;
    v13 = a5 - v6;
    do
    {
      result = llvm::GlobPattern::matchOne(a1, v8, v11, v12, v13);
      if ((result & 1) != 0)
        break;
      ++v12;
      --v13;
    }
    while (v13);
  }
  else
  {
    v7 = a5;
    return v7 == 0;
  }
  return result;
}

void sub_1C5DF7344(uint64_t a1, unsigned __int8 *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  _QWORD *v10;
  unint64_t v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  char *v15;
  unsigned int v16;
  void *v17;
  int v18;
  int v19;
  _BYTE *v20;
  unsigned int v21;
  uint64_t v22;
  const std::error_category *v23;
  int v24;
  _QWORD v25[4];
  __int16 v26;
  void *v27;
  uint64_t v28;
  _BYTE v29[48];
  int v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v27 = v29;
  v28 = 0x600000000;
  sub_1C4765AA4((char *)&v27, 4uLL, 0);
  v30 = 256;
  if (a3 < 3)
  {
LABEL_10:
    if (a3)
    {
      v15 = (char *)v27;
      do
      {
        v16 = *a2++;
        *(_QWORD *)&v15[((unint64_t)v16 >> 3) & 0x18] |= 1 << v16;
        --a3;
      }
      while (a3);
    }
    *(_BYTE *)(a1 + 72) &= ~1u;
    v17 = (void *)(a1 + 16);
    *(_QWORD *)a1 = a1 + 16;
    *(_QWORD *)(a1 + 8) = 0x600000000;
    v18 = v28;
    v19 = 256;
    if (!(_DWORD)v28 || &v27 == (void **)a1)
      goto LABEL_21;
    if (v27 != v29)
    {
      *(_QWORD *)a1 = v27;
      v24 = HIDWORD(v28);
      *(_DWORD *)(a1 + 8) = v18;
      *(_DWORD *)(a1 + 12) = v24;
      v27 = v29;
      HIDWORD(v28) = 0;
      v19 = 256;
      goto LABEL_20;
    }
    if (v28 >= 7)
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, a1 + 16, v28, 8);
      v21 = v28;
      if (!(_DWORD)v28)
        goto LABEL_19;
      v20 = v27;
      v17 = *(void **)a1;
    }
    else
    {
      v20 = v29;
      v21 = v28;
    }
    memcpy(v17, v20, 8 * v21);
LABEL_19:
    *(_DWORD *)(a1 + 8) = v18;
    v19 = v30;
LABEL_20:
    LODWORD(v28) = 0;
LABEL_21:
    *(_DWORD *)(a1 + 64) = v19;
    goto LABEL_22;
  }
  v10 = v27;
  while (1)
  {
    v11 = *a2;
    if (a2[1] == 45)
      break;
    *(_QWORD *)((char *)v10 + ((v11 >> 3) & 0x18)) |= 1 << v11;
    v14 = -1;
    ++a2;
LABEL_9:
    a3 += v14;
    if (a3 <= 2)
      goto LABEL_10;
  }
  v12 = a2[2];
  if (v11 <= v12)
  {
    v13 = v12 + 1;
    do
    {
      v10[v11 >> 6] |= 1 << v11;
      LODWORD(v11) = v11 + 1;
    }
    while (v13 != (_DWORD)v11);
    a2 += 3;
    v14 = -3;
    goto LABEL_9;
  }
  v26 = 1283;
  v25[0] = "invalid glob pattern: ";
  v25[2] = a4;
  v25[3] = a5;
  v22 = operator new();
  v23 = std::generic_category();
  *(_QWORD *)v22 = off_1E81A0C88;
  llvm::Twine::str((llvm::Twine *)v25, (_QWORD *)(v22 + 8));
  *(_QWORD *)(v22 + 32) = 22;
  *(_QWORD *)(v22 + 40) = v23;
  *(_BYTE *)(v22 + 48) = 1;
  *(_BYTE *)(a1 + 72) |= 1u;
  *(_QWORD *)a1 = v22;
LABEL_22:
  if (v27 != v29)
    free(v27);
}

char *llvm::DOT::EscapeString@<X0>(char *result@<X0>, std::string *a2@<X8>)
{
  char v3;
  BOOL v4;
  BOOL v5;
  std::string::size_type size;
  std::string::size_type v7;
  unsigned int v8;
  std::string *v9;
  int v10;
  uint64_t v11;
  int v12;
  std::string::const_iterator v13;
  std::string *v14;
  std::string::const_iterator v15;
  char v16;
  std::string::const_iterator v17;
  std::string *v18;

  if (result[23] < 0)
  {
    result = (char *)sub_1C47EBC30(a2, *(void **)result, *((_QWORD *)result + 1));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)result;
    a2->__r_.__value_.__r.__words[2] = *((_QWORD *)result + 2);
  }
  v3 = HIBYTE(a2->__r_.__value_.__r.__words[2]);
  v4 = v3 < 0;
  v5 = v4;
  size = v3 & 0x7F;
  if (v4)
    size = a2->__r_.__value_.__l.__size_;
  if (size)
  {
    v7 = 0;
    v8 = 0;
    do
    {
      if (v5)
        v9 = (std::string *)a2->__r_.__value_.__r.__words[0];
      else
        v9 = a2;
      v10 = v9->__r_.__value_.__s.__data_[v7];
      if (v10 <= 61)
      {
        if (v10 <= 33)
        {
          if (v10 == 9)
          {
            v17.__i_ = (char *)v9 + v7;
            result = std::string::insert(a2, v17, 32).__i_;
            ++v8;
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v18 = a2;
            else
              v18 = (std::string *)a2->__r_.__value_.__r.__words[0];
            v18->__r_.__value_.__s.__data_[v8] = 32;
          }
          else if (v10 == 10)
          {
            v13.__i_ = (char *)v9 + v7;
            result = std::string::insert(a2, v13, 92).__i_;
            ++v8;
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v14 = a2;
            else
              v14 = (std::string *)a2->__r_.__value_.__r.__words[0];
            v14->__r_.__value_.__s.__data_[v8] = 110;
          }
          goto LABEL_28;
        }
        if (v10 == 34 || v10 == 60)
          goto LABEL_27;
      }
      else
      {
        if ((v10 - 123) < 3 || v10 == 62)
          goto LABEL_27;
        if (v10 == 92)
        {
          v11 = v8 + 1;
          if (size == v11)
            goto LABEL_27;
          v12 = v9->__r_.__value_.__s.__data_[v11];
          if ((v12 - 123) >= 3)
          {
            if (v12 == 108)
              goto LABEL_28;
LABEL_27:
            v15.__i_ = (char *)v9 + v7;
            result = std::string::insert(a2, v15, 92).__i_;
            ++v8;
            goto LABEL_28;
          }
          result = (char *)std::string::erase(a2, v7, 1uLL);
        }
      }
LABEL_28:
      v7 = v8 + 1;
      v16 = HIBYTE(a2->__r_.__value_.__r.__words[2]);
      v4 = v16 < 0;
      v5 = v4;
      size = v16 & 0x7F;
      if (v4)
        size = a2->__r_.__value_.__l.__size_;
      ++v8;
    }
    while (size != v7);
  }
  return result;
}

const char *llvm::DOT::getColorString(llvm::DOT *this)
{
  const char *v1;

  v1 = off_1E81A1198[this % 0x14];
  strlen(v1);
  return v1;
}

void llvm::createGraphFilename(llvm::Twine *a1@<X0>, int *a2@<X1>, _BYTE *a3@<X8>)
{
  std::string::size_type size;
  std::string::size_type v6;
  std::string *p_dst;
  std::string::size_type v8;
  llvm *v9;
  int v10;
  const std::error_category *v11;
  llvm::raw_ostream *v12;
  llvm::raw_ostream *v13;
  uint64_t v14;
  unint64_t v15;
  std::string *v16;
  size_t v17;
  llvm::raw_ostream *v18;
  _BYTE *v19;
  llvm::raw_ostream *v20;
  uint64_t v21;
  size_t v22;
  void *v23;
  size_t v24;
  size_t v25;
  _BYTE *v26;
  std::string v27;
  __int16 v28;
  std::error_code v29;
  std::string __dst;
  std::string __p;
  std::string __str;
  void *__src;
  size_t __len[2];
  _QWORD v35[17];

  v35[16] = *MEMORY[0x1E0C80C00];
  *a2 = -1;
  __src = v35;
  *(_OWORD *)__len = xmmword_1C85F20B0;
  llvm::Twine::str(a1, &__str);
  size = *((_BYTE *)&__str.__r_.__value_.__s + 23) & 0x7F;
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = __str.__r_.__value_.__l.__size_;
  if (size >= 0x8C)
    v6 = 140;
  else
    v6 = size;
  std::string::basic_string(&v27, &__str, 0, v6, (std::allocator<char> *)&__p);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  __str = v27;
  if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0)
    sub_1C47EBC30(&__dst, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
  else
    __dst = __str;
  p_dst = &__dst;
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
  v8 = *((_BYTE *)&__dst.__r_.__value_.__s + 23) & 0x7F;
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v8 = __dst.__r_.__value_.__l.__size_;
  for (; v8; --v8)
  {
    if (p_dst->__r_.__value_.__s.__data_[0] == 47)
      p_dst->__r_.__value_.__s.__data_[0] = 95;
    p_dst = (std::string *)((char *)p_dst + 1);
  }
  __p = __dst;
  memset(&__dst, 0, sizeof(__dst));
  v28 = 260;
  v27.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p;
  v9 = (llvm *)sub_1C5E7DA50((uint64_t *)&v27, (__int128 *)"dot", 3, a2, &__src, 1, 0);
  v10 = (int)v9;
  *(_QWORD *)&v29.__val_ = v9;
  v29.__cat_ = v11;
  v12 = (llvm::raw_ostream *)llvm::errs(v9);
  v13 = v12;
  v14 = *((_QWORD *)v12 + 4);
  v15 = *((_QWORD *)v12 + 3) - v14;
  if (!v10)
  {
    if (v15 > 8)
    {
      *(_BYTE *)(v14 + 8) = 39;
      *(_QWORD *)v14 = *(_QWORD *)"Writing '";
      *((_QWORD *)v12 + 4) += 9;
    }
    else
    {
      v13 = llvm::raw_ostream::write(v12, "Writing '", 9uLL);
    }
    v20 = llvm::raw_ostream::write(v13, (const char *)__src, __len[0]);
    v21 = *((_QWORD *)v20 + 4);
    if ((unint64_t)(*((_QWORD *)v20 + 3) - v21) > 4)
    {
      *(_BYTE *)(v21 + 4) = 32;
      *(_DWORD *)v21 = 774778407;
      *((_QWORD *)v20 + 4) += 5;
    }
    else
    {
      llvm::raw_ostream::write(v20, "'... ", 5uLL);
    }
    v22 = __len[0];
    if (__len[0] >= 0x7FFFFFFFFFFFFFF8)
      abort();
    v23 = __src;
    if (__len[0] >= 0x17)
    {
      v24 = (__len[0] & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((__len[0] | 7) != 0x17)
        v24 = __len[0] | 7;
      v25 = v24 + 1;
      v26 = operator new(v24 + 1);
      *((_QWORD *)a3 + 1) = v22;
      *((_QWORD *)a3 + 2) = v25 | 0x8000000000000000;
      *(_QWORD *)a3 = v26;
      a3 = v26;
    }
    else
    {
      a3[23] = __len[0];
      if (!v22)
        goto LABEL_45;
    }
    memmove(a3, v23, v22);
LABEL_45:
    a3[v22] = 0;
    goto LABEL_46;
  }
  if (v15 > 6)
  {
    *(_DWORD *)(v14 + 3) = 540701295;
    *(_DWORD *)v14 = 1869771333;
    *((_QWORD *)v12 + 4) += 7;
  }
  else
  {
    v13 = llvm::raw_ostream::write(v12, "Error: ", 7uLL);
  }
  std::error_code::message(&v27, &v29);
  if ((v27.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v16 = &v27;
  else
    v16 = (std::string *)v27.__r_.__value_.__r.__words[0];
  if ((v27.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v17 = *((_BYTE *)&v27.__r_.__value_.__s + 23) & 0x7F;
  else
    v17 = v27.__r_.__value_.__l.__size_;
  v18 = llvm::raw_ostream::write(v13, (const char *)v16, v17);
  v19 = (_BYTE *)*((_QWORD *)v18 + 4);
  if (*((_BYTE **)v18 + 3) == v19)
  {
    llvm::raw_ostream::write(v18, "\n", 1uLL);
  }
  else
  {
    *v19 = 10;
    ++*((_QWORD *)v18 + 4);
  }
  if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v27.__r_.__value_.__l.__data_);
  a3[23] = 0;
  *a3 = 0;
LABEL_46:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  if (__src != v35)
    free(__src);
}

uint64_t llvm::DisplayGraph(void *__src, size_t __len, int a3, int a4)
{
  void ***p_dst;
  size_t v9;
  size_t v10;
  std::string *v11;
  std::string::size_type size;
  _QWORD *v13;
  void **v14;
  size_t v15;
  _QWORD *v16;
  llvm *v17;
  llvm::raw_ostream *v18;
  void *v19;
  std::string *v20;
  std::string::size_type v21;
  void **v22;
  size_t v23;
  int v24;
  std::string *v25;
  std::string::size_type v26;
  _QWORD *v27;
  void ***v28;
  size_t v29;
  _QWORD *v30;
  llvm *v31;
  llvm::raw_ostream *v32;
  void *v33;
  std::string *v34;
  std::string::size_type v35;
  void ***v36;
  size_t v37;
  uint64_t v38;
  void *v39;
  std::string *v40;
  std::string::size_type v41;
  _QWORD *v42;
  void ***v43;
  size_t v44;
  _QWORD *v45;
  _QWORD *v46;
  __int128 v47;
  const char *v48;
  llvm *v49;
  llvm::raw_ostream *v50;
  void *v51;
  std::string *v52;
  std::string::size_type v53;
  void ***v54;
  size_t v55;
  int v56;
  const char *v57;
  size_t v58;
  size_t v59;
  const char *v60;
  size_t v61;
  char *p_p;
  void ***v63;
  char *v64;
  std::string *v65;
  std::string::size_type v66;
  _QWORD *v67;
  _OWORD *v68;
  _OWORD *v69;
  const char *v70;
  uint64_t v71;
  _QWORD *v72;
  __int128 v73;
  void ***v74;
  size_t v75;
  _QWORD *v76;
  __int128 v77;
  __int128 v78;
  llvm *v79;
  size_t v80;
  void *v81;
  llvm::raw_ostream *v82;
  uint64_t v83;
  std::string *v84;
  size_t v85;
  llvm::raw_ostream *v86;
  void *v87;
  std::string *v88;
  std::string::size_type v89;
  void ***v90;
  size_t v91;
  std::string *v92;
  std::string::size_type v93;
  char v94;
  BOOL v95;
  void *v96;
  size_t v97;
  uint64_t v98;
  size_t v99;
  uint64_t v100;
  std::string *v101;
  llvm *v102;
  std::string::size_type v103;
  _QWORD *v104;
  void ***v105;
  size_t v106;
  _QWORD *v107;
  llvm *v108;
  llvm::raw_ostream *v109;
  void *v110;
  std::string *v111;
  std::string::size_type v112;
  void ***v113;
  size_t v114;
  void *v115;
  llvm::raw_ostream *v116;
  void *v117;
  llvm::raw_ostream *v118;
  const char *v119;
  size_t v120;
  llvm::raw_ostream *v121;
  _BYTE *v122;
  void *v123;
  void *v124;
  std::string *v125;
  std::string::size_type v126;
  const void *v127;
  size_t v128;
  void *__p;
  size_t v131;
  char v132;
  std::string v133;
  void *v134;
  size_t v135;
  uint64_t v136;
  std::string v137;
  void *v138;
  uint64_t v139;
  uint64_t v140;
  void **__dst;
  size_t v142;
  int64_t v143;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
    abort();
  if (__len >= 0x17)
  {
    v9 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v9 = __len | 7;
    v10 = v9 + 1;
    p_dst = (void ***)operator new(v9 + 1);
    v142 = __len;
    v143 = v10 | 0x8000000000000000;
    __dst = (void **)p_dst;
  }
  else
  {
    HIBYTE(v143) = __len;
    p_dst = &__dst;
    if (!__len)
      goto LABEL_9;
  }
  memmove(p_dst, __src, __len);
LABEL_9:
  *((_BYTE *)p_dst + __len) = 0;
  v138 = 0;
  v139 = 0;
  v140 = 0;
  memset(&v137, 0, sizeof(v137));
  v134 = 0;
  v135 = 0;
  v136 = 0;
  v11 = &v137;
  if (sub_1C5DF87D4((uint64_t)&v134, (uint64_t)"xdg-open", 8, &v137))
  {
    if ((v137.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    {
      size = *((_BYTE *)&v137.__r_.__value_.__s + 23) & 0x7F;
    }
    else
    {
      size = v137.__r_.__value_.__l.__size_;
      v11 = (std::string *)v137.__r_.__value_.__r.__words[0];
    }
    v13 = operator new(0x10uLL);
    *v13 = v11;
    v13[1] = size;
    v14 = v143 >= 0 ? (void **)&__dst : __dst;
    v15 = v143 >= 0 ? HIBYTE(v143) & 0x7F : v142;
    v16 = operator new(0x20uLL);
    v16[2] = v14;
    v16[3] = v15;
    *(_OWORD *)v16 = *(_OWORD *)v13;
    operator delete(v13);
    v18 = (llvm::raw_ostream *)llvm::errs(v17);
    v19 = (void *)*((_QWORD *)v18 + 4);
    if (*((_QWORD *)v18 + 3) - (_QWORD)v19 > 0x1CuLL)
    {
      qmemcpy(v19, "Trying 'xdg-open' program... ", 29);
      *((_QWORD *)v18 + 4) += 29;
    }
    else
    {
      llvm::raw_ostream::write(v18, "Trying 'xdg-open' program... ", 0x1DuLL);
    }
    v20 = (v137.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &v137
        : (std::string *)v137.__r_.__value_.__r.__words[0];
    v21 = (v137.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? *((_BYTE *)&v137.__r_.__value_.__s + 23) & 0x7F
        : v137.__r_.__value_.__l.__size_;
    v22 = v143 >= 0 ? (void **)&__dst : __dst;
    v23 = v143 >= 0 ? HIBYTE(v143) & 0x7F : v142;
    v24 = sub_1C5DF8A54(v20, v21, (uint64_t)v16, (uint64_t)(v16 + 4), v22, v23, a3, (uint64_t)&v138);
    operator delete(v16);
    if (!v24)
    {
      v38 = 0;
      goto LABEL_237;
    }
  }
  if (sub_1C5DF87D4((uint64_t)&v134, (uint64_t)"Graphviz", 8, &v137))
  {
    if ((v137.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v25 = &v137;
    else
      v25 = (std::string *)v137.__r_.__value_.__r.__words[0];
    if ((v137.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v26 = *((_BYTE *)&v137.__r_.__value_.__s + 23) & 0x7F;
    else
      v26 = v137.__r_.__value_.__l.__size_;
    v27 = operator new(0x10uLL);
    *v27 = v25;
    v27[1] = v26;
    if (v143 >= 0)
      v28 = &__dst;
    else
      v28 = (void ***)__dst;
    if (v143 >= 0)
      v29 = HIBYTE(v143) & 0x7F;
    else
      v29 = v142;
    v30 = operator new(0x20uLL);
    v30[2] = v28;
    v30[3] = v29;
    *(_OWORD *)v30 = *(_OWORD *)v27;
    operator delete(v27);
    v32 = (llvm::raw_ostream *)llvm::errs(v31);
    v33 = (void *)*((_QWORD *)v32 + 4);
    if (*((_QWORD *)v32 + 3) - (_QWORD)v33 > 0x1DuLL)
    {
      qmemcpy(v33, "Running 'Graphviz' program... ", 30);
      *((_QWORD *)v32 + 4) += 30;
    }
    else
    {
      llvm::raw_ostream::write(v32, "Running 'Graphviz' program... ", 0x1EuLL);
    }
    if ((v137.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v34 = &v137;
    else
      v34 = (std::string *)v137.__r_.__value_.__r.__words[0];
    if ((v137.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v35 = *((_BYTE *)&v137.__r_.__value_.__s + 23) & 0x7F;
    else
      v35 = v137.__r_.__value_.__l.__size_;
    if (v143 >= 0)
      v36 = &__dst;
    else
      v36 = (void ***)__dst;
    if (v143 >= 0)
      v37 = HIBYTE(v143) & 0x7F;
    else
      v37 = v142;
    v38 = sub_1C5DF8A54(v34, v35, (uint64_t)v30, (uint64_t)(v30 + 4), v36, v37, a3, (uint64_t)&v138);
    v39 = v30;
    goto LABEL_236;
  }
  if (sub_1C5DF87D4((uint64_t)&v134, (uint64_t)"xdot|xdot.py", 12, &v137))
  {
    if ((v137.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v40 = &v137;
    else
      v40 = (std::string *)v137.__r_.__value_.__r.__words[0];
    if ((v137.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v41 = *((_BYTE *)&v137.__r_.__value_.__s + 23) & 0x7F;
    else
      v41 = v137.__r_.__value_.__l.__size_;
    v42 = operator new(0x10uLL);
    *v42 = v40;
    v42[1] = v41;
    if (v143 >= 0)
      v43 = &__dst;
    else
      v43 = (void ***)__dst;
    if (v143 >= 0)
      v44 = HIBYTE(v143) & 0x7F;
    else
      v44 = v142;
    v45 = operator new(0x20uLL);
    v45[2] = v43;
    v45[3] = v44;
    *(_OWORD *)v45 = *(_OWORD *)v42;
    operator delete(v42);
    v46 = operator new(0x40uLL);
    v46[4] = "-f";
    v46[5] = 2;
    v47 = *((_OWORD *)v45 + 1);
    *(_OWORD *)v46 = *(_OWORD *)v45;
    *((_OWORD *)v46 + 1) = v47;
    operator delete(v45);
    v48 = off_1E81A1238[a4];
    v49 = (llvm *)strlen(v48);
    v46[6] = v48;
    v46[7] = v49;
    v50 = (llvm::raw_ostream *)llvm::errs(v49);
    v51 = (void *)*((_QWORD *)v50 + 4);
    if (*((_QWORD *)v50 + 3) - (_QWORD)v51 > 0x1CuLL)
    {
      qmemcpy(v51, "Running 'xdot.py' program... ", 29);
      *((_QWORD *)v50 + 4) += 29;
    }
    else
    {
      llvm::raw_ostream::write(v50, "Running 'xdot.py' program... ", 0x1DuLL);
    }
    if ((v137.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v52 = &v137;
    else
      v52 = (std::string *)v137.__r_.__value_.__r.__words[0];
    if ((v137.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v53 = *((_BYTE *)&v137.__r_.__value_.__s + 23) & 0x7F;
    else
      v53 = v137.__r_.__value_.__l.__size_;
    if (v143 >= 0)
      v54 = &__dst;
    else
      v54 = (void ***)__dst;
    if (v143 >= 0)
      v55 = HIBYTE(v143) & 0x7F;
    else
      v55 = v142;
    v38 = sub_1C5DF8A54(v52, v53, (uint64_t)v46, (uint64_t)(v46 + 8), v54, v55, a3, (uint64_t)&v138);
    v39 = v46;
    goto LABEL_236;
  }
  if ((sub_1C5DF87D4((uint64_t)&v134, (uint64_t)"open", 4, &v137) & 1) != 0)
  {
    v56 = 1;
  }
  else if ((sub_1C5DF87D4((uint64_t)&v134, (uint64_t)"gv", 2, &v137) & 1) != 0)
  {
    v56 = 3;
  }
  else
  {
    if ((sub_1C5DF87D4((uint64_t)&v134, (uint64_t)"xdg-open", 8, &v137) & 1) == 0)
    {
      memset(&v133, 0, sizeof(v133));
      goto LABEL_170;
    }
    v56 = 2;
  }
  memset(&v133, 0, sizeof(v133));
  v57 = off_1E81A1238[a4];
  v58 = strlen(v57);
  if ((sub_1C5DF87D4((uint64_t)&v134, (uint64_t)v57, v58, &v133) & 1) != 0
    || sub_1C5DF87D4((uint64_t)&v134, (uint64_t)"dot|fdp|neato|twopi|circo", 25, &v133))
  {
    if (v143 >= 0)
      v59 = HIBYTE(v143) & 0x7F;
    else
      v59 = v142;
    if (v56 == 1)
      v60 = ".pdf";
    else
      v60 = ".ps";
    if (v56 == 1)
      v61 = 4;
    else
      v61 = 3;
    sub_1C484371C((uint64_t)&__p, v59 + v61);
    if (v132 >= 0)
      p_p = (char *)&__p;
    else
      p_p = (char *)__p;
    if (v59)
    {
      if (v143 >= 0)
        v63 = &__dst;
      else
        v63 = (void ***)__dst;
      memmove(p_p, v63, v59);
    }
    v64 = &p_p[v59];
    memcpy(v64, v60, v61);
    v64[v61] = 0;
    if ((v133.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v65 = &v133;
    else
      v65 = (std::string *)v133.__r_.__value_.__r.__words[0];
    if ((v133.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v66 = *((_BYTE *)&v133.__r_.__value_.__s + 23) & 0x7F;
    else
      v66 = v133.__r_.__value_.__l.__size_;
    v67 = operator new(0x10uLL);
    *v67 = v65;
    v67[1] = v66;
    v68 = operator new(0x20uLL);
    v69 = v68;
    v70 = "-Tps";
    if (v56 == 1)
      v70 = "-Tpdf";
    v71 = 4;
    if (v56 == 1)
      v71 = 5;
    *((_QWORD *)v68 + 2) = v70;
    *((_QWORD *)v68 + 3) = v71;
    *v68 = *(_OWORD *)v67;
    operator delete(v67);
    v72 = operator new(0x40uLL);
    v72[4] = "-Nfontname=Courier";
    v72[5] = 18;
    v73 = v69[1];
    *(_OWORD *)v72 = *v69;
    *((_OWORD *)v72 + 1) = v73;
    operator delete(v69);
    v72[6] = "-Gsize=7.5,10";
    v72[7] = 13;
    if (v143 >= 0)
      v74 = &__dst;
    else
      v74 = (void ***)__dst;
    if (v143 >= 0)
      v75 = HIBYTE(v143) & 0x7F;
    else
      v75 = v142;
    v76 = operator new(0x80uLL);
    v76[8] = v74;
    v76[9] = v75;
    v77 = *((_OWORD *)v72 + 1);
    *(_OWORD *)v76 = *(_OWORD *)v72;
    *((_OWORD *)v76 + 1) = v77;
    v78 = *((_OWORD *)v72 + 3);
    *((_OWORD *)v76 + 2) = *((_OWORD *)v72 + 2);
    *((_OWORD *)v76 + 3) = v78;
    operator delete(v72);
    v76[10] = "-o";
    v76[11] = 2;
    v80 = v132 & 0x7F;
    if (v132 >= 0)
    {
      v81 = &__p;
    }
    else
    {
      v80 = v131;
      v81 = __p;
    }
    v76[12] = v81;
    v76[13] = v80;
    v82 = (llvm::raw_ostream *)llvm::errs(v79);
    v83 = *((_QWORD *)v82 + 4);
    if ((unint64_t)(*((_QWORD *)v82 + 3) - v83) > 8)
    {
      *(_BYTE *)(v83 + 8) = 39;
      *(_QWORD *)v83 = *(_QWORD *)"Running '";
      *((_QWORD *)v82 + 4) += 9;
    }
    else
    {
      v82 = llvm::raw_ostream::write(v82, "Running '", 9uLL);
    }
    if ((v133.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v84 = &v133;
    else
      v84 = (std::string *)v133.__r_.__value_.__r.__words[0];
    if ((v133.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v85 = *((_BYTE *)&v133.__r_.__value_.__s + 23) & 0x7F;
    else
      v85 = v133.__r_.__value_.__l.__size_;
    v86 = llvm::raw_ostream::write(v82, (const char *)v84, v85);
    v87 = (void *)*((_QWORD *)v86 + 4);
    if (*((_QWORD *)v86 + 3) - (_QWORD)v87 > 0xCuLL)
    {
      qmemcpy(v87, "' program... ", 13);
      *((_QWORD *)v86 + 4) += 13;
    }
    else
    {
      llvm::raw_ostream::write(v86, "' program... ", 0xDuLL);
    }
    if ((v133.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v88 = &v133;
    else
      v88 = (std::string *)v133.__r_.__value_.__r.__words[0];
    if ((v133.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v89 = *((_BYTE *)&v133.__r_.__value_.__s + 23) & 0x7F;
    else
      v89 = v133.__r_.__value_.__l.__size_;
    if (v143 >= 0)
      v90 = &__dst;
    else
      v90 = (void ***)__dst;
    if (v143 >= 0)
      v91 = HIBYTE(v143) & 0x7F;
    else
      v91 = v142;
    v38 = 1;
    if ((sub_1C5DF8A54(v88, v89, (uint64_t)v76, (uint64_t)(v76 + 14), v90, v91, 1, (uint64_t)&v138) & 1) == 0)
    {
      v92 = &v137;
      if ((v137.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v92 = (std::string *)v137.__r_.__value_.__r.__words[0];
      v93 = *((_BYTE *)&v137.__r_.__value_.__s + 23) & 0x7F;
      if ((v137.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v93 = v137.__r_.__value_.__l.__size_;
      *v76 = v92;
      v76[1] = v93;
      if (v56 == 3)
      {
        v76[2] = "--spartan";
        v76[3] = 9;
        v123 = &__p;
        if (v132 < 0)
          v123 = __p;
        v99 = v132 & 0x7F;
        if (v132 < 0)
          v99 = v131;
        v76[4] = v123;
        v100 = 3;
        v98 = 2;
      }
      else if (v56 == 2)
      {
        a3 = 0;
        v99 = v132 & 0x7F;
        if (v132 < 0)
          v99 = v131;
        v124 = &__p;
        if (v132 < 0)
          v124 = __p;
        v76[2] = v124;
        v100 = 2;
        v98 = 1;
      }
      else
      {
        v94 = v132;
        v95 = v132 < 0;
        v96 = __p;
        v97 = v131;
        if (v132 >= 0)
          v96 = &__p;
        v98 = 2;
        v76[2] = "-W";
        v76[3] = 2;
        v99 = v94 & 0x7F;
        if (v95)
          v99 = v97;
        v76[4] = v96;
        v100 = 3;
      }
      v76[2 * v98 + 1] = v99;
      if (SHIBYTE(v140) < 0)
      {
        *(_BYTE *)v138 = 0;
        v139 = 0;
      }
      else
      {
        LOBYTE(v138) = 0;
        HIBYTE(v140) = 0;
      }
      if ((v137.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v125 = &v137;
      else
        v125 = (std::string *)v137.__r_.__value_.__r.__words[0];
      if ((v137.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v126 = *((_BYTE *)&v137.__r_.__value_.__s + 23) & 0x7F;
      else
        v126 = v137.__r_.__value_.__l.__size_;
      if (v132 >= 0)
        v127 = &__p;
      else
        v127 = __p;
      if (v132 >= 0)
        v128 = v132 & 0x7F;
      else
        v128 = v131;
      v38 = sub_1C5DF8A54(v125, v126, (uint64_t)v76, (uint64_t)&v76[2 * v100], v127, v128, a3, (uint64_t)&v138);
    }
    operator delete(v76);
    if ((v132 & 0x80000000) == 0)
      goto LABEL_234;
    v115 = __p;
    goto LABEL_233;
  }
LABEL_170:
  v101 = &v137;
  v102 = (llvm *)sub_1C5DF87D4((uint64_t)&v134, (uint64_t)"dotty", 5, &v137);
  if (!(_DWORD)v102)
  {
    v116 = (llvm::raw_ostream *)llvm::errs(v102);
    v117 = (void *)*((_QWORD *)v116 + 4);
    if (*((_QWORD *)v116 + 3) - (_QWORD)v117 > 0x33uLL)
    {
      qmemcpy(v117, "Error: Couldn't find a usable graph viewer program:\n", 52);
      *((_QWORD *)v116 + 4) += 52;
    }
    else
    {
      v116 = llvm::raw_ostream::write(v116, "Error: Couldn't find a usable graph viewer program:\n", 0x34uLL);
    }
    v118 = (llvm::raw_ostream *)llvm::errs(v116);
    if (v136 >= 0)
      v119 = (const char *)&v134;
    else
      v119 = (const char *)v134;
    if (v136 >= 0)
      v120 = HIBYTE(v136) & 0x7F;
    else
      v120 = v135;
    v121 = llvm::raw_ostream::write(v118, v119, v120);
    v122 = (_BYTE *)*((_QWORD *)v121 + 4);
    if (*((_BYTE **)v121 + 3) == v122)
    {
      v38 = 1;
      llvm::raw_ostream::write(v121, "\n", 1uLL);
    }
    else
    {
      *v122 = 10;
      ++*((_QWORD *)v121 + 4);
      v38 = 1;
    }
    goto LABEL_234;
  }
  if ((v137.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    v103 = *((_BYTE *)&v137.__r_.__value_.__s + 23) & 0x7F;
  }
  else
  {
    v103 = v137.__r_.__value_.__l.__size_;
    v101 = (std::string *)v137.__r_.__value_.__r.__words[0];
  }
  v104 = operator new(0x10uLL);
  *v104 = v101;
  v104[1] = v103;
  if (v143 >= 0)
    v105 = &__dst;
  else
    v105 = (void ***)__dst;
  if (v143 >= 0)
    v106 = HIBYTE(v143) & 0x7F;
  else
    v106 = v142;
  v107 = operator new(0x20uLL);
  v107[2] = v105;
  v107[3] = v106;
  *(_OWORD *)v107 = *(_OWORD *)v104;
  operator delete(v104);
  v109 = (llvm::raw_ostream *)llvm::errs(v108);
  v110 = (void *)*((_QWORD *)v109 + 4);
  if (*((_QWORD *)v109 + 3) - (_QWORD)v110 > 0x1AuLL)
  {
    qmemcpy(v110, "Running 'dotty' program... ", 27);
    *((_QWORD *)v109 + 4) += 27;
  }
  else
  {
    llvm::raw_ostream::write(v109, "Running 'dotty' program... ", 0x1BuLL);
  }
  if ((v137.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v111 = &v137;
  else
    v111 = (std::string *)v137.__r_.__value_.__r.__words[0];
  if ((v137.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v112 = *((_BYTE *)&v137.__r_.__value_.__s + 23) & 0x7F;
  else
    v112 = v137.__r_.__value_.__l.__size_;
  if (v143 >= 0)
    v113 = &__dst;
  else
    v113 = (void ***)__dst;
  if (v143 >= 0)
    v114 = HIBYTE(v143) & 0x7F;
  else
    v114 = v142;
  v38 = sub_1C5DF8A54(v111, v112, (uint64_t)v107, (uint64_t)(v107 + 4), v113, v114, a3, (uint64_t)&v138);
  v115 = v107;
LABEL_233:
  operator delete(v115);
LABEL_234:
  if ((SHIBYTE(v133.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    goto LABEL_237;
  v39 = (void *)v133.__r_.__value_.__r.__words[0];
LABEL_236:
  operator delete(v39);
LABEL_237:
  if (SHIBYTE(v136) < 0)
    operator delete(v134);
  if (SHIBYTE(v137.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v137.__r_.__value_.__l.__data_);
  if (SHIBYTE(v140) < 0)
    operator delete(v138);
  if (SHIBYTE(v143) < 0)
    operator delete(__dst);
  return v38;
}

uint64_t sub_1C5DF87D4(uint64_t a1, uint64_t a2, uint64_t a3, std::string *a4)
{
  const void **v5;
  const void **v6;
  size_t v7;
  const void *v8;
  _QWORD *v9;
  llvm::raw_ostream *v10;
  void *v11;
  uint64_t *v12;
  _WORD *v13;
  uint64_t v14;
  void (**v16)(llvm::raw_ostream *__hidden);
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  _QWORD v25[2];
  std::string __str;
  char v27;
  void *v28;
  uint64_t v29;
  _QWORD v30[18];

  v30[16] = *MEMORY[0x1E0C80C00];
  v25[0] = a2;
  v25[1] = a3;
  v17 = 0;
  v21 = 0;
  v22 = 0;
  v16 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
  v24 = a1;
  v23 = 0;
  v19 = 0;
  v20 = 0;
  v18 = 0;
  v28 = v30;
  v29 = 0x800000000;
  llvm::StringRef::split((char *)v25, (uint64_t)&v28, 124, -1, 1);
  if ((_DWORD)v29)
  {
    v5 = (const void **)v28;
    v6 = (const void **)((char *)v28 + 16 * v29);
    while (1)
    {
      v8 = *v5;
      v7 = (size_t)v5[1];
      llvm::sys::findProgramByName((void *)*v5, v7, 0, 0, (uint64_t)&__str);
      if ((v27 & 1) == 0)
        break;
      v9 = (_QWORD *)v20;
      if ((unint64_t)(v19 - v20) > 8)
      {
        *(_BYTE *)(v20 + 8) = 39;
        *v9 = *(_QWORD *)"  Tried '";
        v11 = (void *)(v20 + 9);
        v20 += 9;
        v10 = (llvm::raw_ostream *)&v16;
        v12 = &v20;
      }
      else
      {
        v10 = llvm::raw_ostream::write((llvm::raw_ostream *)&v16, "  Tried '", 9uLL);
        v12 = (uint64_t *)((char *)v10 + 32);
        v11 = (void *)*((_QWORD *)v10 + 4);
      }
      if (v7 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
      {
        if (v7)
        {
          memcpy(v11, v8, v7);
          *v12 += v7;
        }
      }
      else
      {
        v10 = llvm::raw_ostream::write(v10, (const char *)v8, v7);
      }
      v13 = (_WORD *)*((_QWORD *)v10 + 4);
      if (*((_QWORD *)v10 + 3) - (_QWORD)v13 > 1uLL)
      {
        *v13 = 2599;
        *((_QWORD *)v10 + 4) += 2;
      }
      else
      {
        llvm::raw_ostream::write(v10, "'\n", 2uLL);
      }
      v5 += 2;
      if (v5 == v6)
        goto LABEL_16;
    }
    std::string::operator=(a4, &__str);
    if ((v27 & 1) == 0 && SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__str.__r_.__value_.__l.__data_);
    v14 = 1;
  }
  else
  {
LABEL_16:
    v14 = 0;
  }
  if (v28 != v30)
    free(v28);
  v16 = off_1E81A6E70;
  if (v23 == 1 && v18)
    MEMORY[0x1CAA32F9C](v18, 0x1000C8077774924);
  return v14;
}

uint64_t sub_1C5DF8A54(const void *a1, std::string::size_type a2, uint64_t a3, uint64_t a4, const void *a5, size_t a6, int a7, uint64_t a8)
{
  _BOOL8 v11;
  llvm::raw_ostream *v12;
  llvm::raw_ostream *v13;
  void *v14;
  _BYTE *v15;
  const char *v16;
  llvm::raw_ostream *v17;
  size_t v18;
  uint64_t v19;
  llvm *v21;
  llvm::raw_ostream *v22;
  _DWORD *v23;
  char v24;
  BOOL v25;
  const char *v26;
  size_t v27;
  size_t v28;
  llvm::raw_ostream *v29;
  _BYTE *v30;
  llvm *v31;
  _QWORD *v32;
  _QWORD v33[2];
  char v34;
  __int16 v35;
  __int128 v36;
  char v37;
  pid_t v38[4];

  if (!a7)
  {
    LOBYTE(v33[0]) = 0;
    v34 = 0;
    v11 = sub_1C5E81FD4(v38, a1, a2, a3, (a4 - a3) >> 4, (uint64_t)v33, 0, 0, 0, a8);
    v12 = (llvm::raw_ostream *)llvm::errs((llvm *)v11);
    v13 = v12;
    v14 = (void *)*((_QWORD *)v12 + 4);
    if (*((_QWORD *)v12 + 3) - (_QWORD)v14 > 0x1DuLL)
    {
      qmemcpy(v14, "Remember to erase graph file: ", 30);
      v15 = (_BYTE *)(*((_QWORD *)v12 + 4) + 30);
      *((_QWORD *)v13 + 4) = v15;
    }
    else
    {
      v13 = llvm::raw_ostream::write(v12, "Remember to erase graph file: ", 0x1EuLL);
      v15 = (_BYTE *)*((_QWORD *)v13 + 4);
    }
    if (a6 <= *((_QWORD *)v13 + 3) - (_QWORD)v15)
    {
      if (a6)
      {
        memcpy(v15, a5, a6);
        v15 = (_BYTE *)(*((_QWORD *)v13 + 4) + a6);
        *((_QWORD *)v13 + 4) = v15;
      }
    }
    else
    {
      v13 = llvm::raw_ostream::write(v13, (const char *)a5, a6);
      v15 = (_BYTE *)*((_QWORD *)v13 + 4);
    }
    if (*((_BYTE **)v13 + 3) != v15)
    {
      v19 = 0;
      *v15 = 10;
      ++*((_QWORD *)v13 + 4);
      return v19;
    }
    v16 = "\n";
    v17 = v13;
    v18 = 1;
    goto LABEL_10;
  }
  LOBYTE(v36) = 0;
  v37 = 0;
  v21 = (llvm *)llvm::sys::ExecuteAndWait(a1, a2, a3, (a4 - a3) >> 4, &v36, 0, 0, 0, 0, a8, 0, 0);
  if (!(_DWORD)v21)
  {
    v35 = 261;
    v33[0] = a5;
    v33[1] = a6;
    v31 = (llvm *)llvm::sys::fs::remove((llvm::sys::fs *)v33, (const llvm::Twine *)1);
    v17 = (llvm::raw_ostream *)llvm::errs(v31);
    v32 = (_QWORD *)*((_QWORD *)v17 + 4);
    if (*((_QWORD *)v17 + 3) - (_QWORD)v32 > 7uLL)
    {
      v19 = 0;
      *v32 = 0xA202E656E6F6420;
      *((_QWORD *)v17 + 4) += 8;
      return v19;
    }
    v16 = " done. \n";
    v18 = 8;
LABEL_10:
    llvm::raw_ostream::write(v17, v16, v18);
    return 0;
  }
  v22 = (llvm::raw_ostream *)llvm::errs(v21);
  v23 = (_DWORD *)*((_QWORD *)v22 + 4);
  if (*((_QWORD *)v22 + 3) - (_QWORD)v23 > 6uLL)
  {
    *(_DWORD *)((char *)v23 + 3) = 540701295;
    *v23 = 1869771333;
    *((_QWORD *)v22 + 4) += 7;
  }
  else
  {
    v22 = llvm::raw_ostream::write(v22, "Error: ", 7uLL);
  }
  v24 = *(_BYTE *)(a8 + 23);
  v25 = v24 < 0;
  if (v24 >= 0)
    v26 = (const char *)a8;
  else
    v26 = *(const char **)a8;
  v27 = v24 & 0x7F;
  if (v25)
    v28 = *(_QWORD *)(a8 + 8);
  else
    v28 = v27;
  v29 = llvm::raw_ostream::write(v22, v26, v28);
  v30 = (_BYTE *)*((_QWORD *)v29 + 4);
  if (*((_BYTE **)v29 + 3) == v30)
  {
    v19 = 1;
    llvm::raw_ostream::write(v29, "\n", 1uLL);
  }
  else
  {
    *v30 = 10;
    ++*((_QWORD *)v29 + 4);
    return 1;
  }
  return v19;
}

uint64_t llvm::set_fixed_execution_hash_seed(uint64_t this)
{
  llvm::hashing::detail::fixed_seed_override = this;
  return this;
}

_DWORD *llvm::IntEqClasses::grow(_DWORD *this, unsigned int a2)
{
  _DWORD *v3;
  unsigned int i;
  unsigned int v5;
  unsigned int v6;

  v3 = this;
  if (this[3] < a2)
    this = llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)this, (uint64_t)(this + 4), a2, 4);
  for (i = v3[2]; i < a2; v3[2] = i)
  {
    v5 = i;
    if (i >= v3[3])
    {
      v6 = i;
      this = llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v3, (uint64_t)(v3 + 4), i + 1, 4);
      i = v6;
      v5 = v3[2];
    }
    *(_DWORD *)(*(_QWORD *)v3 + 4 * v5) = i;
    i = v3[2] + 1;
  }
  return this;
}

unint64_t llvm::IntEqClasses::join(llvm::IntEqClasses *this, unsigned int a2, unsigned int a3)
{
  uint64_t v3;
  unint64_t result;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;

  v3 = *(_QWORD *)this;
  result = *(unsigned int *)(*(_QWORD *)this + 4 * a2);
  v5 = *(unsigned int *)(v3 + 4 * a3);
  if (result != v5)
  {
    v6 = a2;
    v7 = a3;
    do
    {
      if (result < v5)
      {
        *(_DWORD *)(v3 + 4 * v7) = result;
        v7 = v5;
        v5 = *(unsigned int *)(v3 + 4 * v5);
      }
      else
      {
        *(_DWORD *)(v3 + 4 * v6) = v5;
        v6 = result;
        result = *(unsigned int *)(v3 + 4 * result);
      }
    }
    while (result != v5);
  }
  return result;
}

uint64_t llvm::IntEqClasses::findLeader(llvm::IntEqClasses *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;

  v2 = a2;
  v3 = *(_QWORD *)this;
  do
  {
    result = v2;
    v2 = *(unsigned int *)(v3 + 4 * v2);
  }
  while (result != v2);
  return result;
}

uint64_t *llvm::IntEqClasses::compress(uint64_t *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;

  if (!*((_DWORD *)this + 12))
  {
    v1 = *((unsigned int *)this + 2);
    if ((_DWORD)v1)
    {
      v2 = 0;
      v3 = *this;
      do
      {
        v4 = *(unsigned int *)(v3 + 4 * v2);
        if (v2 == v4)
        {
          v5 = *((_DWORD *)this + 12);
          *((_DWORD *)this + 12) = v5 + 1;
        }
        else
        {
          v5 = *(_DWORD *)(v3 + 4 * v4);
        }
        *(_DWORD *)(v3 + 4 * v2++) = v5;
      }
      while (v1 != v2);
    }
  }
  return this;
}

void llvm::IntEqClasses::uncompress(llvm::IntEqClasses *this)
{
  uint64_t v2;
  uint64_t i;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  void *v8;
  uint64_t v9;
  _QWORD v10[5];

  v10[4] = *MEMORY[0x1E0C80C00];
  if (*((_DWORD *)this + 12))
  {
    v8 = v10;
    v9 = 0x800000000;
    v2 = *((unsigned int *)this + 2);
    if ((_DWORD)v2)
    {
      for (i = 0; i != v2; ++i)
      {
        v4 = *(_QWORD *)this;
        v5 = *(unsigned int *)(*(_QWORD *)this + 4 * i);
        if (v9 <= v5)
        {
          *(_DWORD *)(v4 + 4 * i) = i;
          v6 = v9;
          if (v9 >= (unint64_t)HIDWORD(v9))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v8, (uint64_t)v10, v9 + 1, 4);
            v6 = v9;
          }
          *((_DWORD *)v8 + v6) = i;
          LODWORD(v9) = v9 + 1;
        }
        else
        {
          *(_DWORD *)(v4 + 4 * i) = *((_DWORD *)v8 + v5);
        }
      }
      v7 = v8;
      *((_DWORD *)this + 12) = 0;
      if (v7 != v10)
        free(v7);
    }
    else
    {
      *((_DWORD *)this + 12) = 0;
    }
  }
}

uint64_t llvm::IntervalMapImpl::Path::replaceRoot(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v8;

  v4 = *(_QWORD **)a1;
  *v4 = a2;
  *((_DWORD *)v4 + 2) = a3;
  *((_DWORD *)v4 + 3) = a4;
  v5 = *(_QWORD *)(**(_QWORD **)a1 + 8 * *(unsigned int *)(*(_QWORD *)a1 + 12));
  v6 = *(_QWORD *)a1 + 16;
  *(_QWORD *)&v8 = v5 & 0xFFFFFFFFFFFFFFC0;
  *((_QWORD *)&v8 + 1) = (a4 & 0xFFFFFFFF00000000 | v5 & 0x3F) + 1;
  return sub_1C5DF93CC(a1, v6, &v8);
}

uint64_t llvm::IntervalMapImpl::Path::getLeftSibling(llvm::IntervalMapImpl::Path *this, int a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  int v5;
  int v6;
  uint64_t result;
  int v8;

  if (!a2)
    return 0;
  v2 = *(_QWORD *)this;
  v3 = -1;
  while (1)
  {
    v4 = (a2 + v3);
    if (!(a2 + v3))
      break;
    v5 = *(_DWORD *)(v2 + 16 * v4 + 12);
    --v3;
    if (v5)
    {
      v6 = a2 + v3 + 2;
      goto LABEL_10;
    }
  }
  v5 = *(_DWORD *)(v2 + 12);
  if (!v5)
    return 0;
  v6 = 1;
LABEL_10:
  result = *(_QWORD *)(*(_QWORD *)(v2 + 16 * v4) + 8 * (v5 - 1));
  if (v6 != a2)
  {
    v8 = a2 - v6;
    do
    {
      result = *(_QWORD *)((result & 0xFFFFFFFFFFFFFFC0) + 8 * (result & 0x3F));
      --v8;
    }
    while (v8);
  }
  return result;
}

void llvm::IntervalMapImpl::Path::moveLeft(llvm::IntervalMapImpl::Path *this, unsigned int a2)
{
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  int v17;
  unsigned int v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v4 = *((unsigned int *)this + 2);
  if (!(_DWORD)v4 || *(_DWORD *)(*(_QWORD *)this + 12) >= *(_DWORD *)(*(_QWORD *)this + 8))
  {
    v12 = a2 + 1;
    if ((int)v4 - 1 >= a2 || v4 >= v12)
    {
      v21 = *((unsigned int *)this + 2);
      if ((int)v4 - 1 >= a2 || (v20 = a2 + 1, (_DWORD)v21 == (_DWORD)v20))
      {
        v5 = 0;
        goto LABEL_5;
      }
      if (v21 > v20)
      {
        v18 = a2 + 1;
        goto LABEL_15;
      }
      v4 = *((unsigned int *)this + 2);
      if (v20 > *((_DWORD *)this + 3))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)this, (uint64_t)this + 16, v20, 16);
        v4 = *((unsigned int *)this + 2);
      }
      v15 = (void *)(*(_QWORD *)this + 16 * v4);
      LODWORD(v12) = v20;
      LODWORD(v4) = v21;
      v16 = v20 - v21;
    }
    else
    {
      v14 = *((unsigned int *)this + 2);
      if (v12 > *((_DWORD *)this + 3))
      {
        v22 = *((unsigned int *)this + 2);
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)this, (uint64_t)this + 16, a2 + 1, 16);
        v12 = a2 + 1;
        v4 = v22;
        v14 = *((unsigned int *)this + 2);
      }
      v15 = (void *)(*(_QWORD *)this + 16 * v14);
      v16 = v12 - v4;
    }
    v17 = v12 - v4;
    bzero(v15, 16 * v16);
    v18 = v17 + *((_DWORD *)this + 2);
LABEL_15:
    v5 = 0;
    *((_DWORD *)this + 2) = v18;
    goto LABEL_5;
  }
  v5 = a2;
  do
    --v5;
  while (!*(_DWORD *)(*(_QWORD *)this + 16 * v5 + 12));
LABEL_5:
  v6 = *(_QWORD *)this;
  v7 = *(_QWORD *)this + 16 * v5;
  v8 = *(_DWORD *)(v7 + 12) - 1;
  *(_DWORD *)(v7 + 12) = v8;
  v9 = *(_QWORD *)(*(_QWORD *)v7 + 8 * v8);
  v10 = v5 + 1;
  if (v10 != a2)
  {
    do
    {
      v19 = *(_QWORD *)this + 16 * v10;
      *(_QWORD *)v19 = v9 & 0xFFFFFFFFFFFFFFC0;
      *(_DWORD *)(v19 + 8) = (v9 & 0x3F) + 1;
      *(_DWORD *)(v19 + 12) = v9 & 0x3F;
      v9 = *(_QWORD *)((v9 & 0xFFFFFFFFFFFFFFC0) + 8 * (v9 & 0x3F));
      ++v10;
    }
    while (a2 != v10);
    v6 = *(_QWORD *)this;
  }
  v11 = v6 + 16 * a2;
  *(_QWORD *)v11 = v9 & 0xFFFFFFFFFFFFFFC0;
  *(_DWORD *)(v11 + 8) = (v9 & 0x3F) + 1;
  *(_DWORD *)(v11 + 12) = v9 & 0x3F;
}

uint64_t llvm::IntervalMapImpl::Path::getRightSibling(llvm::IntervalMapImpl::Path *this, int a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  uint64_t result;
  int v9;

  if (!a2)
    return 0;
  v2 = *(_QWORD *)this;
  v3 = -1;
  while (1)
  {
    v4 = (a2 + v3);
    if (!(a2 + v3))
      break;
    v5 = *(_DWORD *)(v2 + 16 * v4 + 12);
    v6 = *(_DWORD *)(v2 + 16 * v4 + 8) - 1;
    --v3;
    if (v5 != v6)
    {
      v7 = a2 + v3 + 2;
      goto LABEL_7;
    }
  }
  v5 = *(_DWORD *)(v2 + 12);
  v6 = *(_DWORD *)(v2 + 8) - 1;
  v7 = 1;
LABEL_7:
  if (v5 == v6)
    return 0;
  result = *(_QWORD *)(*(_QWORD *)(v2 + 16 * v4) + 8 * (v5 + 1));
  if (v7 != a2)
  {
    v9 = a2 - v7;
    do
    {
      result = *(_QWORD *)(result & 0xFFFFFFFFFFFFFFC0);
      --v9;
    }
    while (v9);
  }
  return result;
}

uint64_t *llvm::IntervalMapImpl::Path::moveRight(uint64_t *this, unsigned int a2)
{
  int v2;
  uint64_t v3;
  unsigned int v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t *v11;
  uint64_t v12;

  v2 = 0;
  v3 = *this;
  v4 = a2 - 1;
  while (1)
  {
    v5 = v2;
    v6 = v4 + v2;
    if (!(v4 + v2))
      break;
    v8 = *(_DWORD *)(v3 + 16 * v6 + 8);
    v7 = *(_DWORD *)(v3 + 16 * v6 + 12);
    --v2;
    if (v7 != v8 - 1)
      goto LABEL_6;
  }
  v6 = 0;
  v8 = *(_DWORD *)(v3 + 8);
  v7 = *(_DWORD *)(v3 + 12);
LABEL_6:
  v9 = v7 + 1;
  *(_DWORD *)(v3 + 16 * v6 + 12) = v9;
  if (v9 != v8)
  {
    v10 = *(_QWORD *)(*(_QWORD *)(v3 + 16 * v6) + 8 * v9);
    if (v5)
    {
      do
      {
        v12 = *this + 16 * (a2 + v5);
        *(_QWORD *)v12 = v10 & 0xFFFFFFFFFFFFFFC0;
        *(_DWORD *)(v12 + 8) = (v10 & 0x3F) + 1;
        *(_DWORD *)(v12 + 12) = 0;
        v10 = *(_QWORD *)(v10 & 0xFFFFFFFFFFFFFFC0);
      }
      while (!__CFADD__(v5++, 1));
      v3 = *this;
    }
    v11 = (unint64_t *)(v3 + 16 * a2);
    *v11 = v10 & 0xFFFFFFFFFFFFFFC0;
    v11[1] = (v10 & 0x3F) + 1;
  }
  return this;
}

unint64_t llvm::IntervalMapImpl::distribute(llvm::IntervalMapImpl *this, int a2, unsigned int a3, unsigned int a4, const unsigned int *a5, unsigned int *a6, int a7)
{
  unint64_t v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unint64_t v12;
  unsigned int v13;
  unsigned int v14;

  if ((_DWORD)this)
  {
    v7 = 0;
    v8 = 0;
    LODWORD(v9) = 0;
    v10 = this;
    v11 = (a7 + a2) / this;
    v12 = (a7 + a2) % this;
    do
    {
      if (v7 >= v12)
        v13 = v11;
      else
        v13 = v11 + 1;
      a5[v7] = v13;
      v14 = (_DWORD)a6 - v8;
      v8 += v13;
      if ((_DWORD)this == (_DWORD)v10 && v8 > a6)
      {
        LODWORD(this) = v7;
        v9 = v14;
      }
      else
      {
        v9 = v9;
      }
      ++v7;
    }
    while (v10 != v7);
    if ((a7 & 1) != 0)
      --a5[this];
  }
  else
  {
    v9 = 0;
  }
  return this | (unint64_t)(v9 << 32);
}

uint64_t sub_1C5DF93CC(uint64_t a1, uint64_t a2, __int128 *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 *v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  unsigned int v12;
  __int128 v14;

  v5 = *(_QWORD *)a1;
  v6 = *(unsigned int *)(a1 + 8);
  if (*(_QWORD *)a1 + 16 * v6 == a2)
  {
    v11 = *a3;
    if (v6 >= *(_DWORD *)(a1 + 12))
    {
      v14 = *a3;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, a1 + 16, v6 + 1, 16);
      v11 = v14;
      v5 = *(_QWORD *)a1;
      v6 = *(unsigned int *)(a1 + 8);
    }
    *(_OWORD *)(v5 + 16 * v6) = v11;
    v12 = *(_DWORD *)(a1 + 8) + 1;
    *(_DWORD *)(a1 + 8) = v12;
    return *(_QWORD *)a1 + 16 * v12 - 16;
  }
  else
  {
    v7 = (a2 - v5) >> 4;
    if (v6 >= *(_DWORD *)(a1 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, a1 + 16, v6 + 1, 16);
      v5 = *(_QWORD *)a1;
      v6 = *(unsigned int *)(a1 + 8);
    }
    v8 = (__int128 *)(v5 + 16 * v7);
    *(_OWORD *)(v5 + 16 * v6) = *(_OWORD *)(v5 + 16 * v6 - 16);
    v9 = *(unsigned int *)(a1 + 8);
    v10 = *(_QWORD *)a1 + 16 * v9 - 16;
    if ((__int128 *)v10 != v8)
    {
      memmove(v8 + 1, v8, v10 - (_QWORD)v8);
      LODWORD(v9) = *(_DWORD *)(a1 + 8);
    }
    *(_DWORD *)(a1 + 8) = v9 + 1;
    *v8 = *a3;
  }
  return (uint64_t)v8;
}

llvm::ItaniumManglingCanonicalizer *llvm::ItaniumManglingCanonicalizer::ItaniumManglingCanonicalizer(llvm::ItaniumManglingCanonicalizer *this)
{
  uint64_t v2;

  v2 = operator new();
  *(_QWORD *)this = sub_1C638B66C(v2);
  return this;
}

{
  uint64_t v2;

  v2 = operator new();
  *(_QWORD *)this = sub_1C638B66C(v2);
  return this;
}

void llvm::ItaniumManglingCanonicalizer::~ItaniumManglingCanonicalizer(llvm::ItaniumManglingCanonicalizer *this)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)this;
  if (v1)
  {
    v2 = sub_1C638B7F0(v1);
    MEMORY[0x1CAA32FC0](v2, 0x10F0C408BC9DC32);
  }
}

{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)this;
  if (v1)
  {
    v2 = sub_1C638B7F0(v1);
    MEMORY[0x1CAA32FC0](v2, 0x10F0C408BC9DC32);
  }
}

uint64_t sub_1C5DF956C(uint64_t a1, char *__s2, uint64_t a3)
{
  uint64_t *v3;
  uint64_t v4;
  int v5;
  uint64_t result;

  v3 = *(uint64_t **)a1;
  v4 = **(_QWORD **)a1;
  *(_QWORD *)v4 = __s2;
  *(_QWORD *)(v4 + 8) = &__s2[a3];
  *(_QWORD *)(v4 + 24) = *(_QWORD *)(v4 + 16);
  *(_QWORD *)(v4 + 304) = *(_QWORD *)(v4 + 296);
  *(_QWORD *)(v4 + 672) = *(_QWORD *)(v4 + 664);
  *(_QWORD *)(v4 + 784) = -1;
  *(_WORD *)(v4 + 776) = 1;
  *(_QWORD *)(v4 + 792) = 0;
  *(_DWORD *)(v4 + 800) = 0;
  *(_QWORD *)(v4 + 920) = 0;
  v5 = **(_DWORD **)(a1 + 8);
  if (v5 == 2)
  {
    result = sub_1C5DFC50C((unsigned __int8 **)v4);
    goto LABEL_11;
  }
  if (v5 == 1)
  {
LABEL_8:
    result = sub_1C5DF9EB0(v4);
    goto LABEL_11;
  }
  result = 0;
  if (v5)
    goto LABEL_11;
  if (!a3)
    goto LABEL_10;
  if (a3 != 2 || strncmp("St", __s2, 2uLL))
  {
    if (*__s2 == 83)
      goto LABEL_8;
LABEL_10:
    result = sub_1C5DFC098(v4, 0);
    goto LABEL_11;
  }
  *(_QWORD *)v4 = __s2 + 2;
  result = sub_1C5DF9BE8(v4, "std");
LABEL_11:
  if (*(_QWORD *)(*v3 + 8) != *(_QWORD *)*v3)
    return 0;
  return result;
}

uint64_t sub_1C5DF9694(uint64_t a1, char *__s2, unint64_t a3, char a4)
{
  BOOL v6;
  BOOL v7;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  unsigned __int8 *v15;
  int v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int *v20;
  BOOL v21;
  int v22;
  unsigned __int8 *v23;
  unsigned __int8 *v24;
  char *v25;
  char *v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unsigned int v30;
  int v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  unsigned int *v35;
  void *v36;
  __int128 v37;
  uint64_t v38;
  __int128 v39;
  _QWORD v40[17];

  v40[16] = *MEMORY[0x1E0C80C00];
  *(_BYTE *)(a1 + 937) = a4;
  *(_QWORD *)a1 = __s2;
  *(_QWORD *)(a1 + 8) = &__s2[a3];
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 304) = *(_QWORD *)(a1 + 296);
  *(_QWORD *)(a1 + 672) = *(_QWORD *)(a1 + 664);
  *(_QWORD *)(a1 + 784) = -1;
  *(_WORD *)(a1 + 776) = 1;
  *(_QWORD *)(a1 + 792) = 0;
  *(_DWORD *)(a1 + 800) = 0;
  *(_QWORD *)(a1 + 920) = 0;
  if (a3 < 2
    || *(_WORD *)__s2 != 23135
    && (a3 < 3
     || (*(_WORD *)__s2 == 24415 ? (v6 = __s2[2] == 90) : (v6 = 0),
         !v6
      && (a3 < 4
       || *(_DWORD *)__s2 != 1516199775
       && (a3 < 5 || (*(_DWORD *)__s2 == 1600085855 ? (v7 = __s2[4] == 90) : (v7 = 0), !v7))))))
  {
    *(_QWORD *)&v39 = __s2;
    *((_QWORD *)&v39 + 1) = &__s2[a3];
    return sub_1C5E04030(a1, &v39);
  }
  v10 = 2;
  if (strncmp("_Z", __s2, 2uLL))
  {
    if (a3 < 3)
    {
LABEL_23:
      result = sub_1C5DF9EB0(a1);
      if (*(_QWORD *)(a1 + 8) != *(_QWORD *)a1)
        return 0;
      return result;
    }
    v10 = 3;
    if (strncmp("__Z", __s2, 3uLL))
    {
      if (a3 < 4)
        goto LABEL_23;
      v11 = 4;
      if (strncmp("___Z", __s2, 4uLL))
      {
        if (a3 < 5)
          goto LABEL_23;
        v11 = 5;
        if (strncmp("____Z", __s2, 5uLL))
          goto LABEL_23;
      }
      *(_QWORD *)a1 = &__s2[v11];
      result = sub_1C5DFC50C((unsigned __int8 **)a1);
      *(_QWORD *)&v39 = result;
      if (!result)
        return result;
      v23 = *(unsigned __int8 **)a1;
      v24 = *(unsigned __int8 **)(a1 + 8);
      if ((unint64_t)&v24[-*(_QWORD *)a1] < 0xD || strncmp("_block_invoke", *(const char **)a1, 0xDuLL))
        return 0;
      *(_QWORD *)a1 = v23 + 13;
      if (v23 + 13 == v24 || v23[13] != 95)
      {
        sub_1C54C21F4((char **)a1, 0);
      }
      else
      {
        *(_QWORD *)a1 = v23 + 14;
        v25 = sub_1C54C21F4((char **)a1, 0);
        if (v25 == v26)
          return 0;
      }
      v27 = *(_QWORD *)(a1 + 8);
      if (v27 != *(_QWORD *)a1)
      {
        if (**(_BYTE **)a1 != 46)
          return 0;
        *(_QWORD *)a1 = v27;
      }
      return sub_1C5E119F8(a1, "invocation function for block in ", (uint64_t *)&v39);
    }
  }
  *(_QWORD *)a1 = &__s2[v10];
  result = sub_1C5DFC50C((unsigned __int8 **)a1);
  if (!result)
    return result;
  v12 = result;
  v13 = *(unsigned __int8 **)a1;
  v14 = *(unsigned __int8 **)(a1 + 8);
  v15 = &v14[-*(_QWORD *)a1];
  if (v14 == *(unsigned __int8 **)a1)
  {
    v13 = *(unsigned __int8 **)(a1 + 8);
  }
  else if (*v13 == 46)
  {
    v16 = *(unsigned __int8 *)(a1 + 937);
    v36 = (char *)&v37 + 8;
    v38 = result;
    v37 = xmmword_1C866F950;
    llvm::FoldingSetNodeID::AddString((unsigned int *)&v36, v13, v15);
    v17 = sub_1C4F5AB38(v36, (uint64_t)v36 + 4 * v37);
    v19 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v17);
    v20 = *(unsigned int **)v19;
    *(_QWORD *)&v39 = v40;
    *((_QWORD *)&v39 + 1) = 0x2000000000;
    if (v20 && (v20 & 1) == 0)
    {
      while (1)
      {
        LOBYTE(v17) = sub_1C5DFE6F4(v17, v20, (uint64_t)&v36, v18, (unsigned int *)&v39);
        if ((v17 & 1) != 0)
          break;
        DWORD2(v39) = 0;
        v20 = *(unsigned int **)v20;
        if (v20)
          v21 = (v20 & 1) == 0;
        else
          v21 = 0;
        if (!v21)
        {
          v20 = 0;
          goto LABEL_39;
        }
      }
      v19 = 0;
LABEL_39:
      if ((_QWORD *)v39 == v40)
      {
        if (v20)
        {
LABEL_41:
          v22 = 0;
          v12 = (uint64_t)(v20 + 2);
LABEL_62:
          if (v36 != (char *)&v37 + 8)
            free(v36);
          if (v22)
          {
            *(_QWORD *)(a1 + 920) = v12;
          }
          else if (v12)
          {
            *(_QWORD *)&v39 = 0;
            v33 = sub_1C627E01C(a1 + 944, v12, &v39);
            v34 = 0;
            if (v33)
              v34 = *(_QWORD *)(v39 + 8);
            if (v34)
              v12 = v34;
            if (v12 == *(_QWORD *)(a1 + 928))
              *(_BYTE *)(a1 + 936) = 1;
          }
          v13 = *(unsigned __int8 **)(a1 + 8);
          *(_QWORD *)a1 = v13;
          v14 = v13;
          goto LABEL_68;
        }
      }
      else
      {
        free((void *)v39);
        if (v20)
          goto LABEL_41;
      }
    }
    v22 = 1;
    if (v16)
    {
      v28 = sub_1C484358C(a1 + 808, 48, 3);
      *(_QWORD *)v28 = 0;
      *(_QWORD *)(v28 + 8) = &unk_1E816C130;
      v29 = v28 + 8;
      *(_BYTE *)(v28 + 16) = 1;
      *(_WORD *)(v28 + 17) = *(_WORD *)(v28 + 17) & 0xF000 | 0x540;
      *(_QWORD *)(v28 + 24) = v12;
      *(_QWORD *)(v28 + 32) = v13;
      *(_QWORD *)(v28 + 40) = v14;
      v30 = *(_DWORD *)(a1 + 916) + 1;
      v31 = *(_DWORD *)(a1 + 912);
      if (v30 > 2 * v31)
      {
        v35 = (unsigned int *)v28;
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v31, (uint64_t)off_1E81A1260);
        *(_QWORD *)&v39 = v40;
        *((_QWORD *)&v39 + 1) = 0x2000000000;
        sub_1C5DFE788(v35, (unsigned int *)&v39);
        v19 = *(_QWORD *)(a1 + 904)
            + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38((_QWORD *)v39, v39 + 4 * DWORD2(v39)));
        if ((_QWORD *)v39 != v40)
          free((void *)v39);
        v30 = *(_DWORD *)(a1 + 916) + 1;
        v28 = (unint64_t)v35;
      }
      *(_DWORD *)(a1 + 916) = v30;
      v32 = *(_QWORD *)v19;
      if (!*(_QWORD *)v19)
        v32 = v19 | 1;
      *(_QWORD *)v28 = v32;
      *(_QWORD *)v19 = v28;
      v12 = v29;
    }
    else
    {
      v12 = 0;
    }
    goto LABEL_62;
  }
LABEL_68:
  if (v14 == v13)
    return v12;
  else
    return 0;
}

uint64_t sub_1C5DF9BE8(uint64_t a1, char *__s)
{
  int v4;
  unsigned int v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int *v9;
  BOOL v10;
  BOOL v11;
  int v12;
  uint64_t v13;
  unint64_t v14;
  size_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  int v20;
  uint64_t v21;
  void *v22;
  unsigned int v23[34];
  void *v24;
  uint64_t v25;
  _QWORD v26[17];

  v26[16] = *MEMORY[0x1E0C80C00];
  v4 = *(unsigned __int8 *)(a1 + 937);
  v22 = &v23[2];
  *(_OWORD *)v23 = xmmword_1C866F960;
  v5 = strlen(__s);
  llvm::FoldingSetNodeID::AddString((unsigned int *)&v22, (unsigned __int8 *)__s, v5);
  v6 = sub_1C4F5AB38(v22, (uint64_t)v22 + 4 * v23[0]);
  v8 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v6);
  v9 = *(unsigned int **)v8;
  v24 = v26;
  v25 = 0x2000000000;
  if (v9)
    v10 = (v9 & 1) == 0;
  else
    v10 = 0;
  if (!v10)
    goto LABEL_17;
  while (1)
  {
    LOBYTE(v6) = sub_1C5DFE6F4(v6, v9, (uint64_t)&v22, v7, (unsigned int *)&v24);
    if ((v6 & 1) != 0)
      break;
    LODWORD(v25) = 0;
    v9 = *(unsigned int **)v9;
    if (v9)
      v11 = (v9 & 1) == 0;
    else
      v11 = 0;
    if (!v11)
    {
      v9 = 0;
      goto LABEL_13;
    }
  }
  v8 = 0;
LABEL_13:
  if (v24 == v26)
  {
    if (v9)
    {
LABEL_15:
      v12 = 0;
      v13 = (uint64_t)(v9 + 2);
      goto LABEL_24;
    }
  }
  else
  {
    free(v24);
    if (v9)
      goto LABEL_15;
  }
LABEL_17:
  if (v4)
  {
    v14 = sub_1C484358C(a1 + 808, 40, 3);
    *(_QWORD *)v14 = 0;
    v15 = strlen(__s);
    *(_QWORD *)(v14 + 8) = &unk_1E816A8B0;
    v13 = v14 + 8;
    *(_BYTE *)(v14 + 16) = 7;
    *(_WORD *)(v14 + 17) = *(_WORD *)(v14 + 17) & 0xF000 | 0x540;
    *(_QWORD *)(v14 + 24) = __s;
    *(_QWORD *)(v14 + 32) = &__s[v15];
    v16 = *(_DWORD *)(a1 + 916) + 1;
    v17 = *(_DWORD *)(a1 + 912);
    if (v16 > 2 * v17)
    {
      llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v17, (uint64_t)off_1E81A1260);
      v24 = v26;
      v25 = 0x2000000000;
      sub_1C5DFE788((unsigned int *)v14, (unsigned int *)&v24);
      v8 = *(_QWORD *)(a1 + 904)
         + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v24, (uint64_t)v24 + 4 * v25));
      if (v24 != v26)
        free(v24);
      v16 = *(_DWORD *)(a1 + 916) + 1;
    }
    *(_DWORD *)(a1 + 916) = v16;
    v18 = *(_QWORD *)v8;
    if (!*(_QWORD *)v8)
      v18 = v8 | 1;
    *(_QWORD *)v14 = v18;
    *(_QWORD *)v8 = v14;
  }
  else
  {
    v13 = 0;
  }
  v12 = 1;
LABEL_24:
  if (v22 != &v23[2])
    free(v22);
  if (v12)
  {
    *(_QWORD *)(a1 + 920) = v13;
  }
  else if (v13)
  {
    v24 = 0;
    v20 = sub_1C627E01C(a1 + 944, v13, &v24);
    v21 = 0;
    if (v20)
      v21 = *((_QWORD *)v24 + 1);
    if (v21)
      v13 = v21;
    if (v13 == *(_QWORD *)(a1 + 928))
      *(_BYTE *)(a1 + 936) = 1;
  }
  return v13;
}

uint64_t sub_1C5DF9EB0(uint64_t a1)
{
  uint64_t v1;
  char *v2;
  char *v3;
  unint64_t v4;
  int v5;
  unint64_t v6;
  _BOOL4 v7;
  unint64_t v8;
  _BOOL4 v9;
  unint64_t v10;
  int v11;
  unint64_t v12;
  BOOL v13;
  uint64_t v14;
  int v15;
  const char *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int *v20;
  BOOL v21;
  BOOL v22;
  char *v23;
  unsigned int v24;
  int v25;
  uint64_t v27;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  int v32;
  unint64_t v33;
  uint64_t v34;
  BOOL v35;
  BOOL v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int *v43;
  BOOL v44;
  BOOL v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  unint64_t v49;
  uint64_t v50;
  BOOL v51;
  BOOL v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unsigned int *v61;
  BOOL v62;
  BOOL v63;
  char v64;
  char *v65;
  char *v66;
  uint64_t *v67;
  int v68;
  int v69;
  unint64_t v70;
  uint64_t v71;
  BOOL v72;
  BOOL v73;
  uint64_t v74;
  uint64_t v75;
  int v76;
  unint64_t v77;
  uint64_t v78;
  uint64_t v79;
  BOOL v80;
  BOOL v81;
  uint64_t v82;
  int v83;
  unint64_t v84;
  unsigned int *v85;
  char *v86;
  int v87;
  unint64_t v88;
  unsigned int *v89;
  char *v90;
  int v91;
  unint64_t v92;
  char v93;
  unsigned int v94;
  int v95;
  uint64_t v96;
  unsigned int v97;
  uint64_t v98;
  uint64_t v100;
  uint64_t v101;
  char *v102;
  uint64_t v103;
  uint64_t v104;
  int v105;
  unint64_t v106;
  uint64_t v107;
  BOOL v108;
  unint64_t v109;
  char v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  const char *v114;
  uint64_t v115;
  int v116;
  char *v117;
  char *v118;
  uint64_t *v119;
  int v120;
  int v121;
  BOOL v122;
  uint64_t v123;
  unsigned int v124;
  uint64_t v125;
  uint64_t v126;
  char *v127;
  char *v128;
  uint64_t v129;
  int v130;
  unint64_t v131;
  uint64_t v132;
  uint64_t v133;
  unsigned int *v134;
  BOOL v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  char *v139;
  int v140;
  unint64_t v141;
  uint64_t v142;
  uint64_t v143;
  unsigned int *v144;
  BOOL v145;
  int v146;
  unint64_t v147;
  uint64_t v148;
  uint64_t v149;
  BOOL v150;
  unint64_t v151;
  unsigned int v152;
  int v153;
  uint64_t v154;
  int v155;
  uint64_t v156;
  uint64_t v157;
  int v158;
  unint64_t v159;
  uint64_t v160;
  BOOL v161;
  char *v162;
  uint64_t *v163;
  uint64_t *v164;
  unsigned int v165;
  int v166;
  uint64_t v167;
  unsigned int v168;
  int v169;
  uint64_t v170;
  int v171;
  unsigned int v172;
  int v173;
  uint64_t v174;
  int v175;
  uint64_t v176;
  unsigned int *v177;
  unint64_t v178;
  unsigned int v179;
  int v180;
  uint64_t v181;
  int v182;
  uint64_t v183;
  unint64_t v184;
  unsigned int v185;
  int v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  void *v190;
  __int128 v191;
  uint64_t v192;
  _BOOL8 v193;
  _BYTE v194[104];
  __int128 v195;
  _QWORD v196[17];

  v1 = a1;
  v196[16] = *MEMORY[0x1E0C80C00];
  v188 = 0;
  v2 = *(char **)a1;
  v3 = *(char **)(a1 + 8);
  v4 = (unint64_t)&v3[-*(_QWORD *)a1];
  if (v3 == *(char **)a1)
  {
LABEL_116:
    v14 = sub_1C5E08468(a1);
LABEL_117:
    v27 = v14;
    goto LABEL_118;
  }
  v5 = *v2;
  switch(*v2)
  {
    case 'A':
      if (v5 != 65)
        return 0;
      *(_QWORD *)a1 = v2 + 1;
      if (v3 == v2 + 1)
      {
        if ((*(_BYTE *)(MEMORY[0x1E0C80978] + 61) & 4) != 0)
        {
LABEL_214:
          *(_QWORD *)&v195 = sub_1C54C21F4((char **)a1, 0);
          *((_QWORD *)&v195 + 1) = v101;
          v100 = sub_1C5E04030(v1, &v195);
          if (!v100)
            return 0;
LABEL_215:
          v102 = *(char **)v1;
          if (*(_QWORD *)v1 == *(_QWORD *)(v1 + 8) || *v102 != 95)
            return 0;
          v30 = v100;
          v31 = v102 + 1;
LABEL_218:
          *(_QWORD *)v1 = v31;
          v103 = sub_1C5DF9EB0(v1);
          if (!v103)
            return 0;
          v104 = v103;
          v105 = *(unsigned __int8 *)(v1 + 937);
          v190 = (char *)&v191 + 8;
          v192 = v103;
          v193 = v30;
          v191 = xmmword_1C866F9A0;
          v106 = sub_1C4F5AB38((_QWORD *)&v191 + 1, (uint64_t)v194);
          v60 = *(_QWORD *)(v1 + 904) + 8 * ((*(_DWORD *)(v1 + 912) - 1) & v106);
          v61 = *(unsigned int **)v60;
          *(_QWORD *)&v195 = v196;
          *((_QWORD *)&v195 + 1) = 0x2000000000;
          if (v61 && (v61 & 1) == 0)
          {
            while (1)
            {
              LOBYTE(v106) = sub_1C5DFE6F4(v106, v61, (uint64_t)&v190, v107, (unsigned int *)&v195);
              if ((v106 & 1) != 0)
                break;
              DWORD2(v195) = 0;
              v61 = *(unsigned int **)v61;
              if (v61)
                v108 = (v61 & 1) == 0;
              else
                v108 = 0;
              if (!v108)
              {
                v61 = 0;
                goto LABEL_249;
              }
            }
            v60 = 0;
LABEL_249:
            if ((_QWORD *)v195 == v196)
            {
              if (v61)
                goto LABEL_251;
            }
            else
            {
              free((void *)v195);
              if (v61)
                goto LABEL_251;
            }
          }
          if (!v105)
            goto LABEL_403;
          v109 = sub_1C484358C(v1 + 808, 40, 3);
          *(_QWORD *)v109 = 0;
          *(_QWORD *)(v109 + 8) = &unk_1E816C4F8;
          v27 = v109 + 8;
          *(_BYTE *)(v109 + 16) = 14;
          *(_WORD *)(v109 + 17) = *(_WORD *)(v109 + 17) & 0xF000 | 0x400;
          *(_QWORD *)(v109 + 24) = v104;
          *(_QWORD *)(v109 + 32) = v30;
LABEL_399:
          v172 = *(_DWORD *)(v1 + 916) + 1;
          v173 = *(_DWORD *)(v1 + 912);
          if (v172 > 2 * v173)
          {
            v177 = (unsigned int *)v109;
            llvm::FoldingSetBase::GrowBucketCount(v1 + 904, 2 * v173, (uint64_t)off_1E81A1260);
            *(_QWORD *)&v195 = v196;
            *((_QWORD *)&v195 + 1) = 0x2000000000;
            sub_1C5DFE788(v177, (unsigned int *)&v195);
            v60 = *(_QWORD *)(v1 + 904)
                + 8
                * ((*(_DWORD *)(v1 + 912) - 1) & sub_1C4F5AB38((_QWORD *)v195, v195 + 4 * DWORD2(v195)));
            if ((_QWORD *)v195 != v196)
              free((void *)v195);
            v172 = *(_DWORD *)(v1 + 916) + 1;
            v109 = (unint64_t)v177;
          }
          *(_DWORD *)(v1 + 916) = v172;
          v174 = *(_QWORD *)v60;
          if (!*(_QWORD *)v60)
            v174 = v60 | 1;
          *(_QWORD *)v109 = v174;
          *(_QWORD *)v60 = v109;
LABEL_404:
          v120 = 1;
LABEL_405:
          if (v190 != (char *)&v191 + 8)
            free(v190);
          if (v120)
          {
LABEL_408:
            *(_QWORD *)(v1 + 920) = v27;
            goto LABEL_118;
          }
          goto LABEL_409;
        }
      }
      else if ((v2[1] & 0x80000000) == 0)
      {
        v29 = v2[1];
        if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v29 + 60) & 0x400) == 0)
        {
          if ((_DWORD)v29 == 95)
          {
            v30 = 0;
            v31 = v2 + 2;
            goto LABEL_218;
          }
          goto LABEL_212;
        }
        goto LABEL_214;
      }
LABEL_212:
      v100 = sub_1C5E042EC(a1);
      if (!v100)
        return 0;
      goto LABEL_215;
    case 'C':
      *(_QWORD *)a1 = v2 + 1;
      v37 = sub_1C5DF9EB0(a1);
      if (!v37)
        return 0;
      v38 = v37;
      v39 = *(unsigned __int8 *)(v1 + 937);
      v190 = (char *)&v191 + 8;
      v192 = v37;
      v191 = xmmword_1C866F970;
      llvm::FoldingSetNodeID::AddString((unsigned int *)&v190, " complex", 8u);
      v40 = sub_1C4F5AB38(v190, (uint64_t)v190 + 4 * v191);
      v42 = *(_QWORD *)(v1 + 904) + 8 * ((*(_DWORD *)(v1 + 912) - 1) & v40);
      v43 = *(unsigned int **)v42;
      *(_QWORD *)&v195 = v196;
      *((_QWORD *)&v195 + 1) = 0x2000000000;
      if (v43)
        v44 = (v43 & 1) == 0;
      else
        v44 = 0;
      if (!v44)
        goto LABEL_188;
      while (1)
      {
        LOBYTE(v40) = sub_1C5DFE6F4(v40, v43, (uint64_t)&v190, v41, (unsigned int *)&v195);
        if ((v40 & 1) != 0)
          break;
        DWORD2(v195) = 0;
        v43 = *(unsigned int **)v43;
        if (v43)
          v45 = (v43 & 1) == 0;
        else
          v45 = 0;
        if (!v45)
        {
          v43 = 0;
          goto LABEL_186;
        }
      }
      v42 = 0;
LABEL_186:
      if ((_QWORD *)v195 == v196)
      {
        if (v43)
          goto LABEL_193;
      }
      else
      {
        free((void *)v195);
        if (v43)
          goto LABEL_193;
      }
LABEL_188:
      if (!v39)
        goto LABEL_376;
      v88 = sub_1C484358C(v1 + 808, 48, 3);
      v89 = (unsigned int *)v88;
      *(_QWORD *)v88 = 0;
      *(_QWORD *)(v88 + 8) = &unk_1E816C6B0;
      v27 = v88 + 8;
      *(_BYTE *)(v88 + 16) = 5;
      *(_WORD *)(v88 + 17) = *(_WORD *)(v88 + 17) & 0xF000 | 0x540;
      *(_QWORD *)(v88 + 24) = v38;
      *(_QWORD *)(v88 + 32) = " complex";
      v90 = "";
      goto LABEL_372;
    case 'D':
      if (v4 < 2)
        return 0;
      v27 = 0;
      v68 = v2[1];
      switch(v2[1])
      {
        case 'O':
        case 'o':
        case 'w':
        case 'x':
          goto LABEL_210;
        case 'P':
        case 'Q':
        case 'R':
        case 'S':
        case 'V':
        case 'W':
        case 'X':
        case 'Y':
        case 'Z':
        case '[':
        case '\\':
        case ']':
        case '^':
        case '_':
        case 'b':
        case 'g':
        case 'j':
        case 'k':
        case 'l':
        case 'm':
        case 'q':
        case 'r':
          return v27;
        case 'T':
        case 't':
          v14 = sub_1C5E07E04(a1);
          goto LABEL_117;
        case 'U':
          goto LABEL_252;
        case 'a':
          *(_QWORD *)a1 = v2 + 2;
          v23 = "auto";
          return sub_1C5DF9BE8(a1, v23);
        case 'c':
          *(_QWORD *)a1 = v2 + 2;
          v23 = "decltype(auto)";
          return sub_1C5DF9BE8(a1, v23);
        case 'd':
          *(_QWORD *)a1 = v2 + 2;
          v23 = "decimal64";
          return sub_1C5DF9BE8(a1, v23);
        case 'e':
          *(_QWORD *)a1 = v2 + 2;
          v23 = "decimal128";
          return sub_1C5DF9BE8(a1, v23);
        case 'f':
          *(_QWORD *)a1 = v2 + 2;
          v23 = "decimal32";
          return sub_1C5DF9BE8(a1, v23);
        case 'h':
          *(_QWORD *)a1 = v2 + 2;
          v23 = "half";
          return sub_1C5DF9BE8(a1, v23);
        case 'i':
          *(_QWORD *)a1 = v2 + 2;
          v23 = "char32_t";
          return sub_1C5DF9BE8(a1, v23);
        case 'n':
          *(_QWORD *)a1 = v2 + 2;
          v23 = "std::nullptr_t";
          return sub_1C5DF9BE8(a1, v23);
        case 'p':
          *(_QWORD *)a1 = v2 + 2;
          *(_QWORD *)&v195 = sub_1C5DF9EB0(a1);
          if (!(_QWORD)v195)
            return 0;
          v14 = sub_1C5E081BC(v1, (uint64_t *)&v195);
          goto LABEL_117;
        case 's':
          *(_QWORD *)a1 = v2 + 2;
          v23 = "char16_t";
          return sub_1C5DF9BE8(a1, v23);
        case 'u':
          *(_QWORD *)a1 = v2 + 2;
          v23 = "char8_t";
          return sub_1C5DF9BE8(a1, v23);
        case 'v':
          if (strncmp("Dv", v2, 2uLL))
            return 0;
          *(_QWORD *)v1 = v2 + 2;
          if (v3 == v2 + 2 || v2[2] < 49)
            goto LABEL_333;
          v124 = v2[2];
          if (v124 > 0x39)
          {
            if (v124 != 95)
            {
LABEL_333:
              *(_QWORD *)&v195 = sub_1C5E042EC(v1);
              if ((_QWORD)v195)
              {
                v162 = *(char **)v1;
                if (*(_QWORD *)v1 != *(_QWORD *)(v1 + 8) && *v162 == 95)
                {
                  *(_QWORD *)v1 = v162 + 1;
                  v190 = (void *)sub_1C5DF9EB0(v1);
                  if (v190)
                  {
                    v163 = (uint64_t *)&v190;
                    v164 = (uint64_t *)&v195;
LABEL_338:
                    v14 = sub_1C5E0FBD8(v1, v163, v164);
                    goto LABEL_117;
                  }
                }
              }
LABEL_366:
              v27 = 0;
              goto LABEL_118;
            }
            *(_QWORD *)v1 = v2 + 3;
            v156 = sub_1C5DF9EB0(v1);
            if (!v156)
              return 0;
            v157 = v156;
            v158 = *(unsigned __int8 *)(v1 + 937);
            v190 = (char *)&v191 + 8;
            v192 = v156;
            v193 = 0;
            v191 = xmmword_1C866F9B0;
            v159 = sub_1C4F5AB38((_QWORD *)&v191 + 1, (uint64_t)v194);
            v79 = *(_QWORD *)(v1 + 904) + 8 * ((*(_DWORD *)(v1 + 912) - 1) & v159);
            v61 = *(unsigned int **)v79;
            *(_QWORD *)&v195 = v196;
            *((_QWORD *)&v195 + 1) = 0x2000000000;
            if (v61 && (v61 & 1) == 0)
            {
              while (1)
              {
                LOBYTE(v159) = sub_1C5DFE6F4(v159, v61, (uint64_t)&v190, v160, (unsigned int *)&v195);
                if ((v159 & 1) != 0)
                  break;
                DWORD2(v195) = 0;
                v61 = *(unsigned int **)v61;
                if (v61)
                  v161 = (v61 & 1) == 0;
                else
                  v161 = 0;
                if (!v161)
                {
                  v61 = 0;
                  goto LABEL_340;
                }
              }
              v79 = 0;
LABEL_340:
              if ((_QWORD *)v195 == v196)
              {
                if (!v61)
                  goto LABEL_342;
LABEL_251:
                v120 = 0;
                v27 = (uint64_t)(v61 + 2);
                goto LABEL_405;
              }
              free((void *)v195);
              if (v61)
                goto LABEL_251;
            }
LABEL_342:
            if (v158)
            {
              v92 = sub_1C484358C(v1 + 808, 40, 3);
              *(_QWORD *)v92 = 0;
              *(_QWORD *)(v92 + 8) = &unk_1E816C4A0;
              v27 = v92 + 8;
              *(_BYTE *)(v92 + 16) = 27;
              *(_WORD *)(v92 + 17) = *(_WORD *)(v92 + 17) & 0xF000 | 0x540;
              *(_QWORD *)(v92 + 24) = v157;
              *(_QWORD *)(v92 + 32) = 0;
LABEL_199:
              v94 = *(_DWORD *)(v1 + 916) + 1;
              v95 = *(_DWORD *)(v1 + 912);
              if (v94 > 2 * v95)
              {
                llvm::FoldingSetBase::GrowBucketCount(v1 + 904, 2 * v95, (uint64_t)off_1E81A1260);
                *(_QWORD *)&v195 = v196;
                *((_QWORD *)&v195 + 1) = 0x2000000000;
                sub_1C5DFE788((unsigned int *)v92, (unsigned int *)&v195);
                v79 = *(_QWORD *)(v1 + 904)
                    + 8
                    * ((*(_DWORD *)(v1 + 912) - 1) & sub_1C4F5AB38((_QWORD *)v195, v195 + 4 * DWORD2(v195)));
                if ((_QWORD *)v195 != v196)
                  free((void *)v195);
                v94 = *(_DWORD *)(v1 + 916) + 1;
              }
              *(_DWORD *)(v1 + 916) = v94;
              v96 = *(_QWORD *)v79;
              if (!*(_QWORD *)v79)
                v96 = v79 | 1;
              *(_QWORD *)v92 = v96;
              *(_QWORD *)v79 = v92;
            }
            else
            {
LABEL_403:
              v27 = 0;
            }
            goto LABEL_404;
          }
          *(_QWORD *)&v195 = sub_1C54C21F4((char **)v1, 0);
          *((_QWORD *)&v195 + 1) = v125;
          v126 = sub_1C5E04030(v1, &v195);
          v189 = v126;
          if (!v126)
            goto LABEL_366;
          v127 = *(char **)v1;
          v128 = *(char **)(v1 + 8);
          if (*(char **)v1 == v128 || *v127 != 95)
            goto LABEL_366;
          *(_QWORD *)v1 = v127 + 1;
          if (v127 + 1 == v128 || v127[1] != 112)
          {
            *(_QWORD *)&v195 = sub_1C5DF9EB0(v1);
            if ((_QWORD)v195)
            {
              v163 = (uint64_t *)&v195;
              v164 = &v189;
              goto LABEL_338;
            }
            goto LABEL_366;
          }
          v129 = v126;
          *(_QWORD *)v1 = v127 + 2;
          v130 = *(unsigned __int8 *)(v1 + 937);
          v190 = (char *)&v191 + 8;
          v192 = v126;
          v191 = xmmword_1C866F9C0;
          v131 = sub_1C4F5AB38((_QWORD *)&v191 + 1, (uint64_t)&v193);
          v133 = *(_QWORD *)(v1 + 904) + 8 * ((*(_DWORD *)(v1 + 912) - 1) & v131);
          v134 = *(unsigned int **)v133;
          *(_QWORD *)&v195 = v196;
          *((_QWORD *)&v195 + 1) = 0x2000000000;
          if (v134 && (v134 & 1) == 0)
          {
            while (1)
            {
              LOBYTE(v131) = sub_1C5DFE6F4(v131, v134, (uint64_t)&v190, v132, (unsigned int *)&v195);
              if ((v131 & 1) != 0)
                break;
              DWORD2(v195) = 0;
              v134 = *(unsigned int **)v134;
              if (v134)
                v135 = (v134 & 1) == 0;
              else
                v135 = 0;
              if (!v135)
              {
                v134 = 0;
                goto LABEL_391;
              }
            }
            v133 = 0;
LABEL_391:
            if ((_QWORD *)v195 == v196)
            {
              if (v134)
              {
LABEL_393:
                v171 = 0;
                v27 = (uint64_t)(v134 + 2);
                goto LABEL_455;
              }
            }
            else
            {
              free((void *)v195);
              if (v134)
                goto LABEL_393;
            }
          }
          if (v130)
          {
            v184 = sub_1C484358C(v1 + 808, 32, 3);
            *(_QWORD *)v184 = 0;
            *(_QWORD *)(v184 + 8) = &unk_1E816C448;
            v27 = v184 + 8;
            *(_BYTE *)(v184 + 16) = 28;
            *(_WORD *)(v184 + 17) = *(_WORD *)(v184 + 17) & 0xF000 | 0x540;
            *(_QWORD *)(v184 + 24) = v129;
            v185 = *(_DWORD *)(v1 + 916) + 1;
            v186 = *(_DWORD *)(v1 + 912);
            if (v185 > 2 * v186)
            {
              llvm::FoldingSetBase::GrowBucketCount(v1 + 904, 2 * v186, (uint64_t)off_1E81A1260);
              *(_QWORD *)&v195 = v196;
              *((_QWORD *)&v195 + 1) = 0x2000000000;
              sub_1C5DFE788((unsigned int *)v184, (unsigned int *)&v195);
              v133 = *(_QWORD *)(v1 + 904)
                   + 8
                   * ((*(_DWORD *)(v1 + 912) - 1) & sub_1C4F5AB38((_QWORD *)v195, v195 + 4 * DWORD2(v195)));
              if ((_QWORD *)v195 != v196)
                free((void *)v195);
              v185 = *(_DWORD *)(v1 + 916) + 1;
            }
            *(_DWORD *)(v1 + 916) = v185;
            v187 = *(_QWORD *)v133;
            if (!*(_QWORD *)v133)
              v187 = v133 | 1;
            *(_QWORD *)v184 = v187;
            *(_QWORD *)v133 = v184;
          }
          else
          {
            v27 = 0;
          }
          v171 = 1;
LABEL_455:
          if (v190 != (char *)&v191 + 8)
            free(v190);
          if (v171)
            goto LABEL_408;
          if (v27)
            goto LABEL_410;
LABEL_118:
          if (v27)
          {
LABEL_119:
            v67 = *(uint64_t **)(v1 + 304);
            if (v67 == *(uint64_t **)(v1 + 312))
            {
              sub_1C625449C(v1 + 296, ((uint64_t)v67 - *(_QWORD *)(v1 + 296)) >> 2);
              v67 = *(uint64_t **)(v1 + 304);
            }
            *(_QWORD *)(v1 + 304) = v67 + 1;
            *v67 = v27;
          }
          return v27;
        default:
          if (v68 != 66)
          {
            if (v68 != 70)
              return v27;
            *(_QWORD *)a1 = v2 + 2;
            *(_QWORD *)&v195 = sub_1C54C21F4((char **)a1, 0);
            *((_QWORD *)&v195 + 1) = v111;
            v112 = sub_1C5E04030(v1, &v195);
            if (!v112)
              return 0;
            v113 = v112;
            v114 = (const char *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v112 + 48))(v112);
            if (v115 - (_QWORD)v114 == 2)
            {
              v116 = strncmp(v114, "16", 2uLL);
              v117 = *(char **)v1;
              v118 = *(char **)(v1 + 8);
              if (!v116)
              {
                if (v117 == v118)
                  return 0;
                if (*v117 == 98)
                {
                  *(_QWORD *)v1 = v117 + 1;
                  v23 = "__bf16";
                  goto LABEL_48;
                }
              }
            }
            else
            {
              v117 = *(char **)v1;
              v118 = *(char **)(v1 + 8);
            }
            if (v117 == v118 || *v117 != 95)
              return 0;
            *(_QWORD *)v1 = v117 + 1;
            v146 = *(unsigned __int8 *)(v1 + 937);
            v190 = (char *)&v191 + 8;
            v192 = v113;
            v191 = xmmword_1C866F9E0;
            v147 = sub_1C4F5AB38((_QWORD *)&v191 + 1, (uint64_t)&v193);
            v149 = *(_QWORD *)(v1 + 904) + 8 * ((*(_DWORD *)(v1 + 912) - 1) & v147);
            v144 = *(unsigned int **)v149;
            *(_QWORD *)&v195 = v196;
            *((_QWORD *)&v195 + 1) = 0x2000000000;
            if (v144 && (v144 & 1) == 0)
            {
              while (1)
              {
                LOBYTE(v147) = sub_1C5DFE6F4(v147, v144, (uint64_t)&v190, v148, (unsigned int *)&v195);
                if ((v147 & 1) != 0)
                  break;
                DWORD2(v195) = 0;
                v144 = *(unsigned int **)v144;
                if (v144)
                  v150 = (v144 & 1) == 0;
                else
                  v150 = 0;
                if (!v150)
                {
                  v144 = 0;
                  goto LABEL_319;
                }
              }
              v149 = 0;
LABEL_319:
              if ((_QWORD *)v195 == v196)
              {
                if (v144)
                  goto LABEL_321;
              }
              else
              {
                free((void *)v195);
                if (v144)
                  goto LABEL_321;
              }
            }
            if (v146)
            {
              v178 = sub_1C484358C(v1 + 808, 32, 3);
              *(_QWORD *)v178 = 0;
              *(_QWORD *)(v178 + 8) = &unk_1E816C398;
              v27 = v178 + 8;
              *(_BYTE *)(v178 + 16) = 29;
              *(_WORD *)(v178 + 17) = *(_WORD *)(v178 + 17) & 0xF000 | 0x540;
              *(_QWORD *)(v178 + 24) = v113;
              v179 = *(_DWORD *)(v1 + 916) + 1;
              v180 = *(_DWORD *)(v1 + 912);
              if (v179 > 2 * v180)
              {
                llvm::FoldingSetBase::GrowBucketCount(v1 + 904, 2 * v180, (uint64_t)off_1E81A1260);
                *(_QWORD *)&v195 = v196;
                *((_QWORD *)&v195 + 1) = 0x2000000000;
                sub_1C5DFE788((unsigned int *)v178, (unsigned int *)&v195);
                v149 = *(_QWORD *)(v1 + 904)
                     + 8
                     * ((*(_DWORD *)(v1 + 912) - 1) & sub_1C4F5AB38((_QWORD *)v195, v195 + 4 * DWORD2(v195)));
                if ((_QWORD *)v195 != v196)
                  free((void *)v195);
                v179 = *(_DWORD *)(v1 + 916) + 1;
              }
              *(_DWORD *)(v1 + 916) = v179;
              v181 = *(_QWORD *)v149;
              if (!*(_QWORD *)v149)
                v181 = v149 | 1;
              *(_QWORD *)v178 = v181;
              *(_QWORD *)v149 = v178;
LABEL_431:
              v155 = 1;
LABEL_432:
              if (v190 != (char *)&v191 + 8)
                free(v190);
              if (v155)
                goto LABEL_360;
              goto LABEL_435;
            }
            goto LABEL_430;
          }
LABEL_252:
          v121 = v2[1];
          v122 = v121 == 66;
          *(_QWORD *)a1 = v2 + 2;
          if (v3 == v2 + 2)
          {
            v123 = 0;
          }
          else
          {
            if (v2[2] < 0)
              goto LABEL_286;
            v123 = v2[2];
          }
          if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v123 + 60) & 0x400) != 0)
          {
            *(_QWORD *)&v195 = sub_1C54C21F4((char **)a1, 0);
            *((_QWORD *)&v195 + 1) = v137;
            v136 = sub_1C5E04030(v1, &v195);
            goto LABEL_288;
          }
LABEL_286:
          v136 = sub_1C5E042EC(a1);
LABEL_288:
          v138 = v136;
          if (!v136)
            return 0;
          v139 = *(char **)v1;
          if (*(_QWORD *)v1 == *(_QWORD *)(v1 + 8) || *v139 != 95)
            return 0;
          *(_QWORD *)v1 = v139 + 1;
          v140 = *(unsigned __int8 *)(v1 + 937);
          v190 = (char *)&v191 + 8;
          v192 = v136;
          v193 = v121 == 66;
          v191 = xmmword_1C866F9D0;
          v141 = sub_1C4F5AB38((_QWORD *)&v191 + 1, (uint64_t)v194);
          v143 = *(_QWORD *)(v1 + 904) + 8 * ((*(_DWORD *)(v1 + 912) - 1) & v141);
          v144 = *(unsigned int **)v143;
          *(_QWORD *)&v195 = v196;
          *((_QWORD *)&v195 + 1) = 0x2000000000;
          if (v144 && (v144 & 1) == 0)
          {
            while (1)
            {
              LOBYTE(v141) = sub_1C5DFE6F4(v141, v144, (uint64_t)&v190, v142, (unsigned int *)&v195);
              if ((v141 & 1) != 0)
                break;
              DWORD2(v195) = 0;
              v144 = *(unsigned int **)v144;
              if (v144)
                v145 = (v144 & 1) == 0;
              else
                v145 = 0;
              if (!v145)
              {
                v144 = 0;
                goto LABEL_311;
              }
            }
            v143 = 0;
LABEL_311:
            if ((_QWORD *)v195 == v196)
            {
              if (v144)
              {
LABEL_321:
                v155 = 0;
                v27 = (uint64_t)(v144 + 2);
                goto LABEL_432;
              }
            }
            else
            {
              free((void *)v195);
              if (v144)
                goto LABEL_321;
            }
          }
          if (v140)
          {
            v151 = sub_1C484358C(v1 + 808, 40, 3);
            *(_QWORD *)v151 = 0;
            *(_QWORD *)(v151 + 8) = &unk_1E816C3F0;
            v27 = v151 + 8;
            *(_BYTE *)(v151 + 16) = 30;
            *(_WORD *)(v151 + 17) = *(_WORD *)(v151 + 17) & 0xF000 | 0x540;
            *(_QWORD *)(v151 + 24) = v138;
            *(_BYTE *)(v151 + 32) = v122;
            v152 = *(_DWORD *)(v1 + 916) + 1;
            v153 = *(_DWORD *)(v1 + 912);
            if (v152 > 2 * v153)
            {
              llvm::FoldingSetBase::GrowBucketCount(v1 + 904, 2 * v153, (uint64_t)off_1E81A1260);
              *(_QWORD *)&v195 = v196;
              *((_QWORD *)&v195 + 1) = 0x2000000000;
              sub_1C5DFE788((unsigned int *)v151, (unsigned int *)&v195);
              v143 = *(_QWORD *)(v1 + 904)
                   + 8
                   * ((*(_DWORD *)(v1 + 912) - 1) & sub_1C4F5AB38((_QWORD *)v195, v195 + 4 * DWORD2(v195)));
              if ((_QWORD *)v195 != v196)
                free((void *)v195);
              v152 = *(_DWORD *)(v1 + 916) + 1;
            }
            *(_DWORD *)(v1 + 916) = v152;
            v154 = *(_QWORD *)v143;
            if (!*(_QWORD *)v143)
              v154 = v143 | 1;
            *(_QWORD *)v151 = v154;
            *(_QWORD *)v143 = v151;
            goto LABEL_431;
          }
LABEL_430:
          v27 = 0;
          goto LABEL_431;
      }
    case 'F':
      goto LABEL_210;
    case 'G':
      *(_QWORD *)a1 = v2 + 1;
      v46 = sub_1C5DF9EB0(a1);
      if (!v46)
        return 0;
      v47 = v46;
      v48 = *(unsigned __int8 *)(v1 + 937);
      v190 = (char *)&v191 + 8;
      v192 = v46;
      v191 = xmmword_1C866F970;
      llvm::FoldingSetNodeID::AddString((unsigned int *)&v190, " imaginary", 0xAu);
      v49 = sub_1C4F5AB38(v190, (uint64_t)v190 + 4 * v191);
      v42 = *(_QWORD *)(v1 + 904) + 8 * ((*(_DWORD *)(v1 + 912) - 1) & v49);
      v43 = *(unsigned int **)v42;
      *(_QWORD *)&v195 = v196;
      *((_QWORD *)&v195 + 1) = 0x2000000000;
      if (v43)
        v51 = (v43 & 1) == 0;
      else
        v51 = 0;
      if (!v51)
        goto LABEL_370;
      while (1)
      {
        LOBYTE(v49) = sub_1C5DFE6F4(v49, v43, (uint64_t)&v190, v50, (unsigned int *)&v195);
        if ((v49 & 1) != 0)
          break;
        DWORD2(v195) = 0;
        v43 = *(unsigned int **)v43;
        if (v43)
          v52 = (v43 & 1) == 0;
        else
          v52 = 0;
        if (!v52)
        {
          v43 = 0;
          goto LABEL_191;
        }
      }
      v42 = 0;
LABEL_191:
      if ((_QWORD *)v195 == v196)
      {
        if (v43)
        {
LABEL_193:
          v91 = 0;
          v27 = (uint64_t)(v43 + 2);
          goto LABEL_378;
        }
      }
      else
      {
        free((void *)v195);
        if (v43)
          goto LABEL_193;
      }
LABEL_370:
      if (v48)
      {
        v88 = sub_1C484358C(v1 + 808, 48, 3);
        v89 = (unsigned int *)v88;
        *(_QWORD *)v88 = 0;
        *(_QWORD *)(v88 + 8) = &unk_1E816C6B0;
        v27 = v88 + 8;
        *(_BYTE *)(v88 + 16) = 5;
        *(_WORD *)(v88 + 17) = *(_WORD *)(v88 + 17) & 0xF000 | 0x540;
        *(_QWORD *)(v88 + 24) = v47;
        *(_QWORD *)(v88 + 32) = " imaginary";
        v90 = "";
LABEL_372:
        *(_QWORD *)(v88 + 40) = v90;
        v168 = *(_DWORD *)(v1 + 916) + 1;
        v169 = *(_DWORD *)(v1 + 912);
        if (v168 > 2 * v169)
        {
          llvm::FoldingSetBase::GrowBucketCount(v1 + 904, 2 * v169, (uint64_t)off_1E81A1260);
          *(_QWORD *)&v195 = v196;
          *((_QWORD *)&v195 + 1) = 0x2000000000;
          sub_1C5DFE788(v89, (unsigned int *)&v195);
          v42 = *(_QWORD *)(v1 + 904)
              + 8
              * ((*(_DWORD *)(v1 + 912) - 1) & sub_1C4F5AB38((_QWORD *)v195, v195 + 4 * DWORD2(v195)));
          if ((_QWORD *)v195 != v196)
            free((void *)v195);
          v168 = *(_DWORD *)(v1 + 916) + 1;
        }
        *(_DWORD *)(v1 + 916) = v168;
        v170 = *(_QWORD *)v42;
        if (!*(_QWORD *)v42)
          v170 = v42 | 1;
        *(_QWORD *)v89 = v170;
        *(_QWORD *)v42 = v89;
      }
      else
      {
LABEL_376:
        v27 = 0;
      }
      v91 = 1;
LABEL_378:
      if (v190 != (char *)&v191 + 8)
        free(v190);
      if (v91)
        goto LABEL_408;
LABEL_409:
      if (!v27)
        return v27;
LABEL_410:
      *(_QWORD *)&v195 = 0;
      v175 = sub_1C627E01C(v1 + 944, v27, &v195);
      v176 = 0;
      if (v175)
        v176 = *(_QWORD *)(v195 + 8);
      if (v176)
        v27 = v176;
      if (v27 == *(_QWORD *)(v1 + 928))
        *(_BYTE *)(v1 + 936) = 1;
      goto LABEL_118;
    case 'K':
    case 'V':
    case 'r':
      v6 = v5 == 114;
      v7 = v4 > v6 && v2[v6] == 86;
      v8 = v7 + (unint64_t)v6;
      v9 = v4 > v8 && v2[v8] == 75;
      v10 = v8 + v9;
      if (v4 <= v10)
        goto LABEL_15;
      v11 = v2[v10];
      if (v11 != 70)
      {
        v12 = v10 + 1;
        v13 = v11 == 68 && v4 > v12;
        if (!v13)
          goto LABEL_15;
        v97 = v2[v12] - 79;
        v13 = v97 > 0x29;
        v98 = (1 << v97) & 0x30100000001;
        if (v13 || v98 == 0)
          goto LABEL_15;
      }
LABEL_210:
      v14 = sub_1C5E02B94(a1);
      goto LABEL_117;
    case 'M':
      if (v5 != 77)
        return 0;
      *(_QWORD *)a1 = v2 + 1;
      v53 = sub_1C5DF9EB0(a1);
      if (!v53)
        return 0;
      v54 = v53;
      v55 = sub_1C5DF9EB0(v1);
      if (!v55)
        return 0;
      v56 = v55;
      v57 = *(unsigned __int8 *)(v1 + 937);
      v190 = (char *)&v191 + 8;
      v192 = v54;
      v193 = v55;
      v191 = xmmword_1C866F990;
      v58 = sub_1C4F5AB38((_QWORD *)&v191 + 1, (uint64_t)v194);
      v60 = *(_QWORD *)(v1 + 904) + 8 * ((*(_DWORD *)(v1 + 912) - 1) & v58);
      v61 = *(unsigned int **)v60;
      *(_QWORD *)&v195 = v196;
      *((_QWORD *)&v195 + 1) = 0x2000000000;
      if (v61)
        v62 = (v61 & 1) == 0;
      else
        v62 = 0;
      if (!v62)
        goto LABEL_233;
      while (1)
      {
        LOBYTE(v58) = sub_1C5DFE6F4(v58, v61, (uint64_t)&v190, v59, (unsigned int *)&v195);
        if ((v58 & 1) != 0)
          break;
        DWORD2(v195) = 0;
        v61 = *(unsigned int **)v61;
        if (v61)
          v63 = (v61 & 1) == 0;
        else
          v63 = 0;
        if (!v63)
        {
          v61 = 0;
          goto LABEL_231;
        }
      }
      v60 = 0;
LABEL_231:
      if ((_QWORD *)v195 == v196)
      {
        if (v61)
          goto LABEL_251;
      }
      else
      {
        free((void *)v195);
        if (v61)
          goto LABEL_251;
      }
LABEL_233:
      if (!v57)
        goto LABEL_403;
      v109 = sub_1C484358C(v1 + 808, 40, 3);
      *(_QWORD *)v109 = 0;
      v110 = *(_WORD *)(v56 + 9);
      *(_QWORD *)(v109 + 8) = &unk_1E816C550;
      v27 = v109 + 8;
      *(_BYTE *)(v109 + 16) = 13;
      *(_WORD *)(v109 + 17) = v110 & 0xC0 | 0x500 | *(_WORD *)(v109 + 17) & 0xF000;
      *(_QWORD *)(v109 + 24) = v54;
      *(_QWORD *)(v109 + 32) = v56;
      goto LABEL_399;
    case 'O':
      *(_QWORD *)a1 = v2 + 1;
      *(_QWORD *)&v195 = sub_1C5DF9EB0(a1);
      if (!(_QWORD)v195)
        return 0;
      LODWORD(v190) = 1;
      goto LABEL_146;
    case 'P':
      *(_QWORD *)a1 = v2 + 1;
      v74 = sub_1C5DF9EB0(a1);
      if (!v74)
        return 0;
      v75 = v74;
      v76 = *(unsigned __int8 *)(v1 + 937);
      v190 = (char *)&v191 + 8;
      v192 = v74;
      v191 = xmmword_1C866F980;
      v77 = sub_1C4F5AB38((_QWORD *)&v191 + 1, (uint64_t)&v193);
      v79 = *(_QWORD *)(v1 + 904) + 8 * ((*(_DWORD *)(v1 + 912) - 1) & v77);
      v61 = *(unsigned int **)v79;
      *(_QWORD *)&v195 = v196;
      *((_QWORD *)&v195 + 1) = 0x2000000000;
      if (v61)
        v80 = (v61 & 1) == 0;
      else
        v80 = 0;
      if (!v80)
        goto LABEL_197;
      while (1)
      {
        LOBYTE(v77) = sub_1C5DFE6F4(v77, v61, (uint64_t)&v190, v78, (unsigned int *)&v195);
        if ((v77 & 1) != 0)
          break;
        DWORD2(v195) = 0;
        v61 = *(unsigned int **)v61;
        if (v61)
          v81 = (v61 & 1) == 0;
        else
          v81 = 0;
        if (!v81)
        {
          v61 = 0;
          goto LABEL_195;
        }
      }
      v79 = 0;
LABEL_195:
      if ((_QWORD *)v195 == v196)
      {
        if (v61)
          goto LABEL_251;
      }
      else
      {
        free((void *)v195);
        if (v61)
          goto LABEL_251;
      }
LABEL_197:
      if (!v76)
        goto LABEL_403;
      v92 = sub_1C484358C(v1 + 808, 32, 3);
      *(_QWORD *)v92 = 0;
      v93 = *(_WORD *)(v75 + 9);
      *(_QWORD *)(v92 + 8) = &unk_1E816C600;
      v27 = v92 + 8;
      *(_BYTE *)(v92 + 16) = 11;
      *(_WORD *)(v92 + 17) = v93 & 0xC0 | 0x500 | *(_WORD *)(v92 + 17) & 0xF000;
      *(_QWORD *)(v92 + 24) = v75;
      goto LABEL_199;
    case 'R':
      *(_QWORD *)a1 = v2 + 1;
      *(_QWORD *)&v195 = sub_1C5DF9EB0(a1);
      if (!(_QWORD)v195)
        return 0;
      LODWORD(v190) = 0;
LABEL_146:
      v14 = sub_1C5E094E4(v1, (unint64_t *)&v195, (int *)&v190);
      goto LABEL_117;
    case 'S':
      if (v4 >= 2 && v2[1] == 116)
        goto LABEL_116;
      LOBYTE(v190) = 0;
      v82 = sub_1C5E097C4((const char **)a1, 0, &v190);
      v188 = v82;
      if (!v82)
        return 0;
      v27 = v82;
      if (*(_QWORD *)(v1 + 8) == *(_QWORD *)v1)
      {
        v83 = v190;
      }
      else
      {
        v83 = v190;
        if (**(_BYTE **)v1 == 73)
        {
          if ((_BYTE)v190)
          {
            if (!*(_BYTE *)(v1 + 776))
              return v27;
          }
          else
          {
            v119 = *(uint64_t **)(v1 + 304);
            if (v119 == *(uint64_t **)(v1 + 312))
            {
              sub_1C625449C(v1 + 296, ((uint64_t)v119 - *(_QWORD *)(v1 + 296)) >> 2);
              v119 = *(uint64_t **)(v1 + 304);
            }
            *(_QWORD *)(v1 + 304) = v119 + 1;
            *v119 = v27;
          }
LABEL_246:
          *(_QWORD *)&v195 = sub_1C5E08AA8(v1, 0);
          if ((_QWORD)v195)
          {
            v14 = sub_1C5E09218(v1, &v188, (uint64_t *)&v195);
            goto LABEL_117;
          }
          return 0;
        }
      }
      if (v83)
        return v27;
      goto LABEL_119;
    case 'T':
      if (v4 >= 2)
      {
        v24 = v2[1] - 101;
        v13 = v24 > 0x10;
        v25 = (1 << v24) & 0x14001;
        if (!v13 && v25 != 0)
          goto LABEL_116;
      }
      v27 = sub_1C5E08860(a1);
      v188 = v27;
      if (!v27)
        return v27;
      if (*(_BYTE *)(v1 + 776) && *(_QWORD *)(v1 + 8) != *(_QWORD *)v1 && **(_BYTE **)v1 == 73)
        goto LABEL_246;
      goto LABEL_119;
    case 'U':
LABEL_15:
      v14 = sub_1C5E037CC(a1);
      goto LABEL_117;
    case 'a':
      *(_QWORD *)a1 = v2 + 1;
      v23 = "signed char";
      return sub_1C5DF9BE8(a1, v23);
    case 'b':
      *(_QWORD *)a1 = v2 + 1;
      v23 = "BOOL";
      return sub_1C5DF9BE8(a1, v23);
    case 'c':
      *(_QWORD *)a1 = v2 + 1;
      v23 = "char";
      return sub_1C5DF9BE8(a1, v23);
    case 'd':
      *(_QWORD *)a1 = v2 + 1;
      v23 = "double";
LABEL_48:
      a1 = v1;
      return sub_1C5DF9BE8(a1, v23);
    case 'e':
      *(_QWORD *)a1 = v2 + 1;
      v23 = "long double";
      return sub_1C5DF9BE8(a1, v23);
    case 'f':
      *(_QWORD *)a1 = v2 + 1;
      v23 = "float";
      return sub_1C5DF9BE8(a1, v23);
    case 'g':
      *(_QWORD *)a1 = v2 + 1;
      v23 = "__float128";
      return sub_1C5DF9BE8(a1, v23);
    case 'h':
      *(_QWORD *)a1 = v2 + 1;
      v23 = "unsigned char";
      return sub_1C5DF9BE8(a1, v23);
    case 'i':
      *(_QWORD *)a1 = v2 + 1;
      v23 = "int";
      return sub_1C5DF9BE8(a1, v23);
    case 'j':
      *(_QWORD *)a1 = v2 + 1;
      v69 = *(unsigned __int8 *)(a1 + 937);
      v190 = (char *)&v191 + 8;
      v191 = xmmword_1C866F960;
      v16 = "unsigned int";
      llvm::FoldingSetNodeID::AddString((unsigned int *)&v190, "unsigned int", 0xCu);
      v70 = sub_1C4F5AB38(v190, (uint64_t)v190 + 4 * v191);
      v19 = *(_QWORD *)(v1 + 904) + 8 * ((*(_DWORD *)(v1 + 912) - 1) & v70);
      v20 = *(unsigned int **)v19;
      *(_QWORD *)&v195 = v196;
      *((_QWORD *)&v195 + 1) = 0x2000000000;
      if (v20)
        v72 = (v20 & 1) == 0;
      else
        v72 = 0;
      if (!v72)
        goto LABEL_349;
      while (1)
      {
        LOBYTE(v70) = sub_1C5DFE6F4(v70, v20, (uint64_t)&v190, v71, (unsigned int *)&v195);
        if ((v70 & 1) != 0)
          break;
        DWORD2(v195) = 0;
        v20 = *(unsigned int **)v20;
        if (v20)
          v73 = (v20 & 1) == 0;
        else
          v73 = 0;
        if (!v73)
        {
          v20 = 0;
          goto LABEL_182;
        }
      }
      v19 = 0;
LABEL_182:
      if ((_QWORD *)v195 == v196)
      {
        if (v20)
          goto LABEL_184;
      }
      else
      {
        free((void *)v195);
        if (v20)
          goto LABEL_184;
      }
LABEL_349:
      if (!v69)
        goto LABEL_355;
      v84 = sub_1C484358C(v1 + 808, 40, 3);
      v85 = (unsigned int *)v84;
      *(_QWORD *)v84 = 0;
      *(_QWORD *)(v84 + 8) = &unk_1E816A8B0;
      v27 = v84 + 8;
      *(_BYTE *)(v84 + 16) = 7;
      *(_WORD *)(v84 + 17) = *(_WORD *)(v84 + 17) & 0xF000 | 0x540;
      v86 = "";
      goto LABEL_351;
    case 'l':
      *(_QWORD *)a1 = v2 + 1;
      v23 = "long";
      return sub_1C5DF9BE8(a1, v23);
    case 'm':
      *(_QWORD *)a1 = v2 + 1;
      v23 = "unsigned long";
      return sub_1C5DF9BE8(a1, v23);
    case 'n':
      *(_QWORD *)a1 = v2 + 1;
      v23 = "__int128";
      return sub_1C5DF9BE8(a1, v23);
    case 'o':
      *(_QWORD *)a1 = v2 + 1;
      v32 = *(unsigned __int8 *)(a1 + 937);
      v190 = (char *)&v191 + 8;
      v191 = xmmword_1C866F960;
      v16 = "unsigned __int128";
      llvm::FoldingSetNodeID::AddString((unsigned int *)&v190, "unsigned __int128", 0x11u);
      v33 = sub_1C4F5AB38(v190, (uint64_t)v190 + 4 * v191);
      v19 = *(_QWORD *)(v1 + 904) + 8 * ((*(_DWORD *)(v1 + 912) - 1) & v33);
      v20 = *(unsigned int **)v19;
      *(_QWORD *)&v195 = v196;
      *((_QWORD *)&v195 + 1) = 0x2000000000;
      if (v20)
        v35 = (v20 & 1) == 0;
      else
        v35 = 0;
      if (!v35)
        goto LABEL_179;
      while (1)
      {
        LOBYTE(v33) = sub_1C5DFE6F4(v33, v20, (uint64_t)&v190, v34, (unsigned int *)&v195);
        if ((v33 & 1) != 0)
          break;
        DWORD2(v195) = 0;
        v20 = *(unsigned int **)v20;
        if (v20)
          v36 = (v20 & 1) == 0;
        else
          v36 = 0;
        if (!v36)
        {
          v20 = 0;
          goto LABEL_177;
        }
      }
      v19 = 0;
LABEL_177:
      if ((_QWORD *)v195 == v196)
      {
        if (v20)
          goto LABEL_184;
      }
      else
      {
        free((void *)v195);
        if (v20)
          goto LABEL_184;
      }
LABEL_179:
      if (!v32)
        goto LABEL_355;
      v84 = sub_1C484358C(v1 + 808, 40, 3);
      v85 = (unsigned int *)v84;
      *(_QWORD *)v84 = 0;
      *(_QWORD *)(v84 + 8) = &unk_1E816A8B0;
      v27 = v84 + 8;
      *(_BYTE *)(v84 + 16) = 7;
      *(_WORD *)(v84 + 17) = *(_WORD *)(v84 + 17) & 0xF000 | 0x540;
      v86 = "";
      goto LABEL_351;
    case 's':
      *(_QWORD *)a1 = v2 + 1;
      v23 = "short";
      return sub_1C5DF9BE8(a1, v23);
    case 't':
      *(_QWORD *)a1 = v2 + 1;
      v23 = "unsigned short";
      return sub_1C5DF9BE8(a1, v23);
    case 'u':
      *(_QWORD *)a1 = v2 + 1;
      v190 = 0;
      v64 = sub_1C54C42B4((unsigned __int8 **)a1, (uint64_t *)&v190);
      v65 = 0;
      v66 = 0;
      if ((v64 & 1) == 0)
      {
        v66 = *(char **)v1;
        if (*(_QWORD *)(v1 + 8) - *(_QWORD *)v1 >= (unint64_t)v190)
        {
          v65 = (char *)v190 + (_QWORD)v66;
          *(_QWORD *)v1 = (char *)v190 + (_QWORD)v66;
        }
        else
        {
          v65 = 0;
          v66 = 0;
        }
      }
      *(_QWORD *)&v195 = v66;
      *((_QWORD *)&v195 + 1) = v65;
      if (v65 == v66)
        return 0;
      v14 = sub_1C5E04030(v1, &v195);
      goto LABEL_117;
    case 'v':
      *(_QWORD *)a1 = v2 + 1;
      v23 = "void";
      return sub_1C5DF9BE8(a1, v23);
    case 'w':
      *(_QWORD *)a1 = v2 + 1;
      v23 = "wchar_t";
      return sub_1C5DF9BE8(a1, v23);
    case 'x':
      *(_QWORD *)a1 = v2 + 1;
      v23 = "long long";
      return sub_1C5DF9BE8(a1, v23);
    case 'y':
      *(_QWORD *)a1 = v2 + 1;
      v15 = *(unsigned __int8 *)(a1 + 937);
      v190 = (char *)&v191 + 8;
      v191 = xmmword_1C866F960;
      v16 = "unsigned long long";
      llvm::FoldingSetNodeID::AddString((unsigned int *)&v190, "unsigned long long", 0x12u);
      v17 = sub_1C4F5AB38(v190, (uint64_t)v190 + 4 * v191);
      v19 = *(_QWORD *)(v1 + 904) + 8 * ((*(_DWORD *)(v1 + 912) - 1) & v17);
      v20 = *(unsigned int **)v19;
      *(_QWORD *)&v195 = v196;
      *((_QWORD *)&v195 + 1) = 0x2000000000;
      if (v20)
        v21 = (v20 & 1) == 0;
      else
        v21 = 0;
      if (!v21)
        goto LABEL_174;
      while (1)
      {
        LOBYTE(v17) = sub_1C5DFE6F4(v17, v20, (uint64_t)&v190, v18, (unsigned int *)&v195);
        if ((v17 & 1) != 0)
          break;
        DWORD2(v195) = 0;
        v20 = *(unsigned int **)v20;
        if (v20)
          v22 = (v20 & 1) == 0;
        else
          v22 = 0;
        if (!v22)
        {
          v20 = 0;
          goto LABEL_172;
        }
      }
      v19 = 0;
LABEL_172:
      if ((_QWORD *)v195 == v196)
      {
        if (!v20)
        {
LABEL_174:
          if (v15)
          {
            v84 = sub_1C484358C(v1 + 808, 40, 3);
            v85 = (unsigned int *)v84;
            *(_QWORD *)v84 = 0;
            *(_QWORD *)(v84 + 8) = &unk_1E816A8B0;
            v27 = v84 + 8;
            *(_BYTE *)(v84 + 16) = 7;
            *(_WORD *)(v84 + 17) = *(_WORD *)(v84 + 17) & 0xF000 | 0x540;
            v86 = "";
LABEL_351:
            *(_QWORD *)(v84 + 24) = v16;
            *(_QWORD *)(v84 + 32) = v86;
            v165 = *(_DWORD *)(v1 + 916) + 1;
            v166 = *(_DWORD *)(v1 + 912);
            if (v165 > 2 * v166)
            {
              llvm::FoldingSetBase::GrowBucketCount(v1 + 904, 2 * v166, (uint64_t)off_1E81A1260);
              *(_QWORD *)&v195 = v196;
              *((_QWORD *)&v195 + 1) = 0x2000000000;
              sub_1C5DFE788(v85, (unsigned int *)&v195);
              v19 = *(_QWORD *)(v1 + 904)
                  + 8
                  * ((*(_DWORD *)(v1 + 912) - 1) & sub_1C4F5AB38((_QWORD *)v195, v195 + 4 * DWORD2(v195)));
              if ((_QWORD *)v195 != v196)
                free((void *)v195);
              v165 = *(_DWORD *)(v1 + 916) + 1;
            }
            *(_DWORD *)(v1 + 916) = v165;
            v167 = *(_QWORD *)v19;
            if (!*(_QWORD *)v19)
              v167 = v19 | 1;
            *(_QWORD *)v85 = v167;
            *(_QWORD *)v19 = v85;
          }
          else
          {
LABEL_355:
            v27 = 0;
          }
          v87 = 1;
LABEL_357:
          if (v190 != (char *)&v191 + 8)
            free(v190);
          if (v87)
          {
LABEL_360:
            *(_QWORD *)(v1 + 920) = v27;
            return v27;
          }
LABEL_435:
          if (v27)
          {
            *(_QWORD *)&v195 = 0;
            v182 = sub_1C627E01C(v1 + 944, v27, &v195);
            v183 = 0;
            if (v182)
              v183 = *(_QWORD *)(v195 + 8);
            if (v183)
              v27 = v183;
            if (v27 == *(_QWORD *)(v1 + 928))
              *(_BYTE *)(v1 + 936) = 1;
          }
          return v27;
        }
      }
      else
      {
        free((void *)v195);
        if (!v20)
          goto LABEL_174;
      }
LABEL_184:
      v87 = 0;
      v27 = (uint64_t)(v20 + 2);
      goto LABEL_357;
    case 'z':
      *(_QWORD *)a1 = v2 + 1;
      v23 = "...";
      return sub_1C5DF9BE8(a1, v23);
    default:
      goto LABEL_116;
  }
}

uint64_t sub_1C5DFC098(uint64_t a1, uint64_t a2)
{
  char *v4;
  int v5;
  int v6;
  char *v7;
  char *v8;
  int v9;
  char v10;
  uint64_t v11;
  uint64_t *v12;
  const char *v14;
  const char *v15;
  char *v16;
  int v17;
  const char *v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t *v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  char v29;
  uint64_t v30;
  uint64_t v31;

  v4 = *(char **)a1;
  if (*(_QWORD *)(a1 + 8) == *(_QWORD *)a1)
    goto LABEL_11;
  v5 = *v4;
  if (v5 == 90)
  {
    *(_QWORD *)a1 = v4 + 1;
    v31 = sub_1C5DFC50C(a1);
    if (!v31)
      return 0;
    v16 = *(char **)a1;
    v15 = *(const char **)(a1 + 8);
    if (*(const char **)a1 == v15 || *v16 != 69)
      return 0;
    *(_QWORD *)a1 = v16 + 1;
    if (v16 + 1 == v15)
      goto LABEL_31;
    v17 = v16[1];
    if (v17 == 100)
    {
      *(_QWORD *)a1 = v16 + 2;
      sub_1C54C21F4((char **)a1, 1);
      v26 = *(char **)a1;
      if (*(_QWORD *)a1 == *(_QWORD *)(a1 + 8) || *v26 != 95)
        return 0;
      *(_QWORD *)a1 = v26 + 1;
      v27 = sub_1C5DFC098(a1, a2);
    }
    else
    {
      if (v17 != 115)
      {
LABEL_31:
        v30 = sub_1C5DFC098(a1, a2);
        if (!v30)
          return 0;
        *(_QWORD *)a1 = llvm::itanium_demangle::parse_discriminator(*(const char **)a1, *(const char **)(a1 + 8), v18);
        return sub_1C5E111AC(a1, &v31, &v30);
      }
      *(_QWORD *)a1 = v16 + 2;
      *(_QWORD *)a1 = llvm::itanium_demangle::parse_discriminator(v16 + 2, v15, v14);
      v27 = sub_1C5DF9BE8(a1, "string literal");
    }
    v30 = v27;
    if (!v27)
      return 0;
    return sub_1C5E111AC(a1, &v31, &v30);
  }
  if (v5 != 78)
  {
LABEL_11:
    v29 = 0;
    v11 = sub_1C5E097C4((const char **)a1, (_BYTE *)a2, &v29);
    v31 = v11;
    if (!v11)
      return v11;
    if (*(_QWORD *)(a1 + 8) == *(_QWORD *)a1 || **(_BYTE **)a1 != 73)
    {
      if (!v29)
        return v11;
      return 0;
    }
    if (!v29)
    {
      v12 = *(uint64_t **)(a1 + 304);
      if (v12 == *(uint64_t **)(a1 + 312))
      {
        sub_1C625449C(a1 + 296, ((uint64_t)v12 - *(_QWORD *)(a1 + 296)) >> 2);
        v12 = *(uint64_t **)(a1 + 304);
      }
      *(_QWORD *)(a1 + 304) = v12 + 1;
      *v12 = v11;
    }
    v30 = sub_1C5E08AA8(a1, a2 != 0);
    if (!v30)
      return 0;
    if (a2)
      *(_BYTE *)(a2 + 1) = 1;
    return sub_1C5E09218(a1, &v31, &v30);
  }
  *(_QWORD *)a1 = v4 + 1;
  v6 = sub_1C54C4768(a1);
  if (a2)
    *(_DWORD *)(a2 + 4) = v6;
  v7 = *(char **)a1;
  v8 = *(char **)(a1 + 8);
  if (*(char **)a1 == v8)
    goto LABEL_33;
  v9 = *v7;
  if (v9 == 82)
  {
    *(_QWORD *)a1 = ++v7;
    if (a2)
    {
      v10 = 1;
      goto LABEL_37;
    }
    goto LABEL_38;
  }
  if (v9 != 79)
  {
LABEL_33:
    if (a2)
    {
      v10 = 0;
      goto LABEL_37;
    }
  }
  else
  {
    *(_QWORD *)a1 = ++v7;
    if (a2)
    {
      v10 = 2;
LABEL_37:
      *(_BYTE *)(a2 + 8) = v10;
    }
  }
LABEL_38:
  v11 = 0;
  v31 = 0;
  while (v7 == v8 || *v7 != 69)
  {
    if (a2)
      *(_BYTE *)(a2 + 1) = 0;
    if (v7 == v8)
    {
LABEL_61:
      v19 = 0;
LABEL_62:
      v21 = sub_1C5E0FEA4(a1, (_BYTE *)a2, v11, v19);
      goto LABEL_63;
    }
    v19 = 0;
    v20 = *v7;
    if (v20 > 0x52)
    {
      if (v20 != 83)
      {
        if (v20 != 84)
          goto LABEL_62;
        if (v11)
          return 0;
        v21 = sub_1C5E08860(a1);
        goto LABEL_63;
      }
      if ((unint64_t)(v8 - v7) >= 2 && v7[1] == 116)
      {
        *(_QWORD *)a1 = v7 + 2;
        v24 = sub_1C5DF9BE8(a1, "std");
      }
      else
      {
        v24 = sub_1C5E0ED94(a1);
      }
      v19 = v24;
      if (!v24)
        return 0;
      if (*(_BYTE *)(v24 + 8) == 25)
        goto LABEL_62;
      if (v11)
        return 0;
      v31 = v24;
      v11 = v24;
      v7 = *(char **)a1;
      v8 = *(char **)(a1 + 8);
    }
    else
    {
      if (v20 == 68)
      {
        if ((unint64_t)(v8 - v7) < 2 || (v7[1] | 0x20) != 0x74)
          goto LABEL_61;
        if (v11)
          return 0;
        v21 = sub_1C5E07E04(a1);
      }
      else
      {
        if (v20 != 73)
          goto LABEL_62;
        if (!v11)
          return v11;
        v30 = sub_1C5E08AA8(a1, a2 != 0);
        if (!v30 || *(_BYTE *)(v11 + 8) == 41)
          return 0;
        if (a2)
          *(_BYTE *)(a2 + 1) = 1;
        v21 = sub_1C5E09218(a1, &v31, &v30);
      }
LABEL_63:
      v11 = v21;
      v31 = v21;
      if (!v21)
        return v11;
      v22 = *(uint64_t **)(a1 + 304);
      if (v22 == *(uint64_t **)(a1 + 312))
      {
        sub_1C625449C(a1 + 296, ((uint64_t)v22 - *(_QWORD *)(a1 + 296)) >> 2);
        v22 = *(uint64_t **)(a1 + 304);
      }
      *(_QWORD *)(a1 + 304) = v22 + 1;
      *v22 = v11;
      v7 = *(char **)a1;
      v23 = *(char **)(a1 + 8);
      v8 = *(char **)a1;
      if (*(char **)a1 != v23)
      {
        v8 = *(char **)(a1 + 8);
        if (*v7 == 77)
        {
          *(_QWORD *)a1 = ++v7;
          v8 = v23;
        }
      }
    }
  }
  *(_QWORD *)a1 = v7 + 1;
  if (v11)
  {
    v25 = *(_QWORD *)(a1 + 304);
    if (*(_QWORD *)(a1 + 296) != v25)
    {
      *(_QWORD *)(a1 + 304) = v25 - 8;
      return v11;
    }
    return 0;
  }
  return v11;
}

uint64_t sub_1C5DFC50C(unsigned __int8 **a1)
{
  char *v2;
  unsigned __int8 *v3;
  unsigned __int8 *v4;
  unint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int *v14;
  BOOL v15;
  uint64_t v16;
  unint64_t v17;
  unsigned __int8 *v18;
  unint64_t v19;
  BOOL v20;
  unint64_t v21;
  unsigned __int8 *v22;
  unsigned __int8 *v23;
  unint64_t v24;
  uint64_t v25;
  unsigned __int8 *v26;
  unsigned __int8 *v27;
  unint64_t v28;
  unsigned int v29;
  uint64_t v30;
  unsigned __int8 *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unsigned __int8 *v36;
  int v37;
  uint64_t v38;
  unsigned int v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  BOOL v43;
  uint64_t v44;
  unsigned int v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  BOOL v49;
  uint64_t v50;
  int v51;
  unsigned __int8 *v52;
  uint64_t v53;
  unsigned int v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  uint64_t v58;
  BOOL v59;
  uint64_t v60;
  unsigned int v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  BOOL v65;
  unsigned __int8 *v66;
  _BOOL4 v67;
  uint64_t v68;
  uint64_t v70;
  unsigned int v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t v74;
  uint64_t v75;
  unsigned int *v76;
  BOOL v77;
  unsigned int v78;
  uint64_t v79;
  unint64_t v80;
  uint64_t v81;
  BOOL v82;
  uint64_t v83;
  unsigned int v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  BOOL v88;
  uint64_t v89;
  uint64_t v90;
  char *v91;
  char *v92;
  unsigned __int8 *v93;
  uint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  uint64_t v98;
  unsigned int *v99;
  BOOL v100;
  uint64_t v101;
  unsigned int v102;
  uint64_t v103;
  unint64_t v104;
  uint64_t v105;
  BOOL v106;
  uint64_t v107;
  unsigned int v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  BOOL v112;
  uint64_t v113;
  unsigned int v114;
  uint64_t v115;
  unint64_t v116;
  uint64_t v117;
  BOOL v118;
  uint64_t v119;
  unsigned int v120;
  uint64_t v121;
  unint64_t v122;
  uint64_t v123;
  BOOL v124;
  unint64_t v125;
  const char *v126;
  char *v127;
  unint64_t v128;
  const char *v129;
  char *v130;
  unint64_t v131;
  unsigned int v132;
  int v133;
  uint64_t v134;
  unsigned int v135;
  int v136;
  uint64_t v137;
  int v138;
  unsigned __int8 *v139;
  uint64_t v140;
  unsigned __int8 *v141;
  uint64_t *v142;
  uint64_t *v143;
  uint64_t v144;
  unint64_t v145;
  uint64_t v146;
  uint64_t v147;
  unsigned int *v148;
  BOOL v149;
  BOOL v150;
  unsigned int v151;
  int v152;
  uint64_t v153;
  int v154;
  unint64_t v155;
  unsigned int v156;
  int v157;
  uint64_t v158;
  int v159;
  unint64_t v160;
  unsigned int v161;
  int v162;
  uint64_t v163;
  unsigned int *v164;
  unsigned int *v165;
  void *v166;
  int v167;
  uint64_t v168;
  unsigned __int8 *v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  unsigned __int8 *v174;
  unsigned int v175;
  uint64_t v176;
  unsigned __int8 *v178;
  unsigned __int8 *v179;
  _QWORD *v180;
  _QWORD *v181;
  int v182;
  uint64_t v183;
  unsigned int *v184;
  uint64_t v185;
  int v186;
  uint64_t v187;
  int v188;
  uint64_t *v189;
  int v190;
  int v191;
  int v192;
  int v193;
  int v194;
  int v195;
  int v196;
  int v197;
  int v198;
  int v199;
  int v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  char v204[8];
  unint64_t v205;
  char *v206;
  void *v207[3];
  _OWORD v208[2];
  void *v209[3];
  _BYTE v210[64];
  void *v211;
  __int128 v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  _QWORD *v216;
  uint64_t v217;
  _QWORD v218[18];

  v218[16] = *MEMORY[0x1E0C80C00];
  v206 = (char *)a1;
  v207[0] = v208;
  v207[1] = v208;
  v207[2] = v209;
  memset(v208, 0, sizeof(v208));
  v209[0] = v210;
  v209[1] = v210;
  v209[2] = &v211;
  memset(v210, 0, sizeof(v210));
  sub_1C6253D78((char *)v207, (uint64_t)(a1 + 83));
  sub_1C6253E58((char *)v209, (uint64_t)(v206 + 576));
  v2 = v206;
  *((_QWORD *)v206 + 84) = *((_QWORD *)v206 + 83);
  *((_QWORD *)v2 + 73) = *((_QWORD *)v2 + 72);
  v3 = *a1;
  v4 = a1[1];
  v5 = v4 - *a1;
  if (v4 == *a1)
    goto LABEL_20;
  v6 = *v3;
  if (v6 == 71)
  {
    if (v5 < 2)
      goto LABEL_113;
    v37 = (char)v3[1];
    if (v37 != 73)
    {
      if (v37 == 82)
      {
        *a1 = v3 + 2;
        v50 = sub_1C5DFC098((uint64_t)a1, 0);
        v16 = 0;
        if (!v50)
          goto LABEL_114;
        v8 = v50;
        v51 = sub_1C54C3F6C(a1, &v203);
        v52 = *a1;
        if (*a1 == a1[1] || *v52 != 95)
        {
          if (!v51)
            goto LABEL_113;
        }
        else
        {
          *a1 = v52 + 1;
        }
        v200 = *((unsigned __int8 *)a1 + 937);
        v211 = (char *)&v212 + 8;
        v212 = xmmword_1C866F9F0;
        llvm::FoldingSetNodeID::AddString((unsigned int *)&v211, "reference temporary for ", 0x18u);
        v120 = v212;
        if (v212 >= DWORD1(v212))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v211, (uint64_t)&v212 + 8, v212 + 1, 4);
          v120 = v212;
        }
        *((_DWORD *)v211 + v120) = v8;
        v121 = (v212 + 1);
        LODWORD(v212) = v121;
        if (v121 >= DWORD1(v212))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v211, (uint64_t)&v212 + 8, v121 + 1, 4);
          LODWORD(v121) = v212;
        }
        *((_DWORD *)v211 + v121) = HIDWORD(v8);
        LODWORD(v212) = v212 + 1;
        v122 = sub_1C4F5AB38(v211, (uint64_t)v211 + 4 * v212);
        v13 = (uint64_t)&a1[113][8 * ((*((_DWORD *)a1 + 228) - 1) & v122)];
        v14 = *(unsigned int **)v13;
        v216 = v218;
        v217 = 0x2000000000;
        if (v14 && (v14 & 1) == 0)
        {
          while (1)
          {
            LOBYTE(v122) = sub_1C5DFE6F4(v122, v14, (uint64_t)&v211, v123, (unsigned int *)&v216);
            if ((v122 & 1) != 0)
              break;
            LODWORD(v217) = 0;
            v14 = *(unsigned int **)v14;
            if (v14)
              v124 = (v14 & 1) == 0;
            else
              v124 = 0;
            if (!v124)
            {
              v14 = 0;
              goto LABEL_248;
            }
          }
          v13 = 0;
LABEL_248:
          if (v216 == v218)
          {
            if (v14)
              goto LABEL_372;
          }
          else
          {
            free(v216);
            if (v14)
              goto LABEL_372;
          }
        }
        if (v200)
        {
          v128 = sub_1C484358C((uint64_t)(a1 + 101), 48, 3);
          *(_QWORD *)v128 = 0;
          *(_QWORD *)(v128 + 8) = &unk_1E816A800;
          v16 = v128 + 8;
          *(_BYTE *)(v128 + 16) = 20;
          *(_WORD *)(v128 + 17) = *(_WORD *)(v128 + 17) & 0xF000 | 0x540;
          v129 = "reference temporary for ";
          v130 = "";
          goto LABEL_307;
        }
LABEL_287:
        v16 = 0;
LABEL_311:
        v154 = 1;
        goto LABEL_373;
      }
      if (v37 != 86)
        goto LABEL_113;
      *a1 = v3 + 2;
      v38 = sub_1C5DFC098((uint64_t)a1, 0);
      v16 = 0;
      if (!v38)
        goto LABEL_114;
      v8 = v38;
      v191 = *((unsigned __int8 *)a1 + 937);
      v211 = (char *)&v212 + 8;
      v212 = xmmword_1C866F9F0;
      llvm::FoldingSetNodeID::AddString((unsigned int *)&v211, "guard variable for ", 0x13u);
      v39 = v212;
      if (v212 >= DWORD1(v212))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v211, (uint64_t)&v212 + 8, v212 + 1, 4);
        v39 = v212;
      }
      *((_DWORD *)v211 + v39) = v8;
      v40 = (v212 + 1);
      LODWORD(v212) = v40;
      if (v40 >= DWORD1(v212))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v211, (uint64_t)&v212 + 8, v40 + 1, 4);
        LODWORD(v40) = v212;
      }
      *((_DWORD *)v211 + v40) = HIDWORD(v8);
      LODWORD(v212) = v212 + 1;
      v41 = sub_1C4F5AB38(v211, (uint64_t)v211 + 4 * v212);
      v13 = (uint64_t)&a1[113][8 * ((*((_DWORD *)a1 + 228) - 1) & v41)];
      v14 = *(unsigned int **)v13;
      v216 = v218;
      v217 = 0x2000000000;
      if (v14 && (v14 & 1) == 0)
      {
        while (1)
        {
          LOBYTE(v41) = sub_1C5DFE6F4(v41, v14, (uint64_t)&v211, v42, (unsigned int *)&v216);
          if ((v41 & 1) != 0)
            break;
          LODWORD(v217) = 0;
          v14 = *(unsigned int **)v14;
          if (v14)
            v43 = (v14 & 1) == 0;
          else
            v43 = 0;
          if (!v43)
          {
            v14 = 0;
            goto LABEL_235;
          }
        }
        v13 = 0;
LABEL_235:
        if (v216 == v218)
        {
          if (!v14)
            goto LABEL_237;
LABEL_372:
          v154 = 0;
          v16 = (uint64_t)(v14 + 2);
LABEL_373:
          if (v211 != (char *)&v212 + 8)
            free(v211);
          if (!v154)
            goto LABEL_345;
          goto LABEL_376;
        }
        free(v216);
        if (v14)
          goto LABEL_372;
      }
LABEL_237:
      if (v191)
      {
        v128 = sub_1C484358C((uint64_t)(a1 + 101), 48, 3);
        *(_QWORD *)v128 = 0;
        *(_QWORD *)(v128 + 8) = &unk_1E816A800;
        v16 = v128 + 8;
        *(_BYTE *)(v128 + 16) = 20;
        *(_WORD *)(v128 + 17) = *(_WORD *)(v128 + 17) & 0xF000 | 0x540;
        v129 = "guard variable for ";
        v130 = "";
LABEL_307:
        *(_QWORD *)(v128 + 24) = v129;
        *(_QWORD *)(v128 + 32) = v130;
        *(_QWORD *)(v128 + 40) = v8;
        v151 = *((_DWORD *)a1 + 229) + 1;
        v152 = *((_DWORD *)a1 + 228);
        if (v151 > 2 * v152)
        {
          v164 = (unsigned int *)v128;
          llvm::FoldingSetBase::GrowBucketCount((uint64_t)(a1 + 113), 2 * v152, (uint64_t)off_1E81A1260);
          v216 = v218;
          v217 = 0x2000000000;
          sub_1C5DFE788(v164, (unsigned int *)&v216);
          v13 = (uint64_t)&a1[113][8
                                * ((*((_DWORD *)a1 + 228) - 1) & sub_1C4F5AB38(v216, (uint64_t)v216 + 4 * v217))];
          if (v216 != v218)
            free(v216);
          v151 = *((_DWORD *)a1 + 229) + 1;
          v128 = (unint64_t)v164;
        }
        *((_DWORD *)a1 + 229) = v151;
        v153 = *(_QWORD *)v13;
        if (!*(_QWORD *)v13)
          v153 = v13 | 1;
        *(_QWORD *)v128 = v153;
        *(_QWORD *)v13 = v128;
        goto LABEL_311;
      }
      goto LABEL_287;
    }
    *a1 = v3 + 2;
    v203 = 0;
    v16 = 0;
    if ((sub_1C5E10B28((uint64_t)a1, &v203) & 1) != 0)
      goto LABEL_114;
    v53 = v203;
    if (!v203)
      goto LABEL_114;
    v193 = *((unsigned __int8 *)a1 + 937);
    v211 = (char *)&v212 + 8;
    v212 = xmmword_1C866F9F0;
    llvm::FoldingSetNodeID::AddString((unsigned int *)&v211, "initializer for module ", 0x17u);
    v54 = v212;
    if (v212 >= DWORD1(v212))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v211, (uint64_t)&v212 + 8, v212 + 1, 4);
      v54 = v212;
    }
    *((_DWORD *)v211 + v54) = v53;
    v55 = (v212 + 1);
    LODWORD(v212) = v55;
    if (v55 >= DWORD1(v212))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v211, (uint64_t)&v212 + 8, v55 + 1, 4);
      LODWORD(v55) = v212;
    }
    *((_DWORD *)v211 + v55) = HIDWORD(v53);
    LODWORD(v212) = v212 + 1;
    v56 = sub_1C4F5AB38(v211, (uint64_t)v211 + 4 * v212);
    v58 = (uint64_t)&a1[113][8 * ((*((_DWORD *)a1 + 228) - 1) & v56)];
    v14 = *(unsigned int **)v58;
    v216 = v218;
    v217 = 0x2000000000;
    if (v14 && (v14 & 1) == 0)
    {
      while (1)
      {
        LOBYTE(v56) = sub_1C5DFE6F4(v56, v14, (uint64_t)&v211, v57, (unsigned int *)&v216);
        if ((v56 & 1) != 0)
          break;
        LODWORD(v217) = 0;
        v14 = *(unsigned int **)v14;
        if (v14)
          v59 = (v14 & 1) == 0;
        else
          v59 = 0;
        if (!v59)
        {
          v14 = 0;
          goto LABEL_240;
        }
      }
      v58 = 0;
LABEL_240:
      if (v216 == v218)
      {
        if (v14)
          goto LABEL_372;
      }
      else
      {
        free(v216);
        if (v14)
          goto LABEL_372;
      }
    }
    if (v193)
    {
      v131 = sub_1C484358C((uint64_t)(a1 + 101), 48, 3);
      *(_QWORD *)v131 = 0;
      *(_QWORD *)(v131 + 8) = &unk_1E816A800;
      v16 = v131 + 8;
      *(_BYTE *)(v131 + 16) = 20;
      *(_WORD *)(v131 + 17) = *(_WORD *)(v131 + 17) & 0xF000 | 0x540;
      *(_QWORD *)(v131 + 24) = "initializer for module ";
      *(_QWORD *)(v131 + 32) = "";
      *(_QWORD *)(v131 + 40) = v53;
      v132 = *((_DWORD *)a1 + 229) + 1;
      v133 = *((_DWORD *)a1 + 228);
      if (v132 > 2 * v133)
      {
        llvm::FoldingSetBase::GrowBucketCount((uint64_t)(a1 + 113), 2 * v133, (uint64_t)off_1E81A1260);
        v216 = v218;
        v217 = 0x2000000000;
        sub_1C5DFE788((unsigned int *)v131, (unsigned int *)&v216);
        v58 = (uint64_t)&a1[113][8
                              * ((*((_DWORD *)a1 + 228) - 1) & sub_1C4F5AB38(v216, (uint64_t)v216 + 4 * v217))];
        if (v216 != v218)
          free(v216);
        v132 = *((_DWORD *)a1 + 229) + 1;
      }
      *((_DWORD *)a1 + 229) = v132;
      v134 = *(_QWORD *)v58;
      if (!*(_QWORD *)v58)
        v134 = v58 | 1;
      *(_QWORD *)v131 = v134;
      *(_QWORD *)v58 = v131;
      goto LABEL_311;
    }
    goto LABEL_287;
  }
  if (v6 == 84)
  {
    if (v5 >= 2)
    {
      switch(v3[1])
      {
        case 'A':
          *a1 = v3 + 2;
          v44 = sub_1C5E0B790(a1);
          if (!v44)
            goto LABEL_113;
          v8 = v44;
          v192 = *((unsigned __int8 *)a1 + 937);
          v211 = (char *)&v212 + 8;
          v212 = xmmword_1C866F9F0;
          llvm::FoldingSetNodeID::AddString((unsigned int *)&v211, "template parameter object for ", 0x1Eu);
          v45 = v212;
          if (v212 >= DWORD1(v212))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v211, (uint64_t)&v212 + 8, v212 + 1, 4);
            v45 = v212;
          }
          *((_DWORD *)v211 + v45) = v8;
          v46 = (v212 + 1);
          LODWORD(v212) = v46;
          if (v46 >= DWORD1(v212))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v211, (uint64_t)&v212 + 8, v46 + 1, 4);
            LODWORD(v46) = v212;
          }
          *((_DWORD *)v211 + v46) = HIDWORD(v8);
          LODWORD(v212) = v212 + 1;
          v47 = sub_1C4F5AB38(v211, (uint64_t)v211 + 4 * v212);
          v13 = (uint64_t)&a1[113][8 * ((*((_DWORD *)a1 + 228) - 1) & v47)];
          v14 = *(unsigned int **)v13;
          v216 = v218;
          v217 = 0x2000000000;
          if (!v14 || (v14 & 1) != 0)
            goto LABEL_266;
          while (1)
          {
            LOBYTE(v47) = sub_1C5DFE6F4(v47, v14, (uint64_t)&v211, v48, (unsigned int *)&v216);
            if ((v47 & 1) != 0)
              break;
            LODWORD(v217) = 0;
            v14 = *(unsigned int **)v14;
            if (v14)
              v49 = (v14 & 1) == 0;
            else
              v49 = 0;
            if (!v49)
            {
              v14 = 0;
              goto LABEL_264;
            }
          }
          v13 = 0;
LABEL_264:
          if (v216 == v218)
          {
            if (v14)
              goto LABEL_372;
          }
          else
          {
            free(v216);
            if (v14)
              goto LABEL_372;
          }
LABEL_266:
          if (!v192)
            goto LABEL_287;
          v128 = sub_1C484358C((uint64_t)(a1 + 101), 48, 3);
          *(_QWORD *)v128 = 0;
          *(_QWORD *)(v128 + 8) = &unk_1E816A800;
          v16 = v128 + 8;
          *(_BYTE *)(v128 + 16) = 20;
          *(_WORD *)(v128 + 17) = *(_WORD *)(v128 + 17) & 0xF000 | 0x540;
          v129 = "template parameter object for ";
          v130 = "";
          goto LABEL_307;
        case 'B':
        case 'D':
        case 'E':
        case 'F':
        case 'G':
          break;
        case 'C':
          *a1 = v3 + 2;
          v89 = sub_1C5DF9EB0(a1);
          if (!v89)
            goto LABEL_113;
          v90 = v89;
          v91 = sub_1C54C21F4((char **)a1, 1);
          if (v91 == v92)
            goto LABEL_113;
          v93 = *a1;
          if (*a1 == a1[1])
            goto LABEL_113;
          if (*v93 != 95)
            goto LABEL_113;
          *a1 = v93 + 1;
          v94 = sub_1C5DF9EB0(a1);
          if (!v94)
            goto LABEL_113;
          v95 = v94;
          v188 = *((unsigned __int8 *)a1 + 937);
          v211 = (char *)&v212 + 8;
          v213 = v94;
          v214 = v90;
          v212 = xmmword_1C866FA00;
          v96 = sub_1C4F5AB38((_QWORD *)&v212 + 1, (uint64_t)&v215);
          v98 = (uint64_t)&a1[113][8 * ((*((_DWORD *)a1 + 228) - 1) & v96)];
          v99 = *(unsigned int **)v98;
          v216 = v218;
          v217 = 0x2000000000;
          if (!v99 || (v99 & 1) != 0)
            goto LABEL_325;
          while (1)
          {
            LOBYTE(v96) = sub_1C5DFE6F4(v96, v99, (uint64_t)&v211, v97, (unsigned int *)&v216);
            if ((v96 & 1) != 0)
              break;
            LODWORD(v217) = 0;
            v99 = *(unsigned int **)v99;
            if (v99)
              v100 = (v99 & 1) == 0;
            else
              v100 = 0;
            if (!v100)
            {
              v99 = 0;
              goto LABEL_323;
            }
          }
          v98 = 0;
LABEL_323:
          if (v216 == v218)
          {
            if (!v99)
            {
LABEL_325:
              if (v188)
              {
                v160 = sub_1C484358C((uint64_t)(a1 + 101), 40, 3);
                *(_QWORD *)v160 = 0;
                *(_QWORD *)(v160 + 8) = &unk_1E816A858;
                v16 = v160 + 8;
                *(_BYTE *)(v160 + 16) = 21;
                *(_WORD *)(v160 + 17) = *(_WORD *)(v160 + 17) & 0xF000 | 0x540;
                *(_QWORD *)(v160 + 24) = v95;
                *(_QWORD *)(v160 + 32) = v90;
                v161 = *((_DWORD *)a1 + 229) + 1;
                v162 = *((_DWORD *)a1 + 228);
                if (v161 > 2 * v162)
                {
                  v184 = (unsigned int *)v160;
                  llvm::FoldingSetBase::GrowBucketCount((uint64_t)(a1 + 113), 2 * v162, (uint64_t)off_1E81A1260);
                  v216 = v218;
                  v217 = 0x2000000000;
                  sub_1C5DFE788(v184, (unsigned int *)&v216);
                  v98 = (uint64_t)&a1[113][8
                                        * ((*((_DWORD *)a1 + 228) - 1) & sub_1C4F5AB38(v216, (uint64_t)v216+ 4 * v217))];
                  if (v216 != v218)
                    free(v216);
                  v161 = *((_DWORD *)a1 + 229) + 1;
                  v160 = (unint64_t)v184;
                }
                *((_DWORD *)a1 + 229) = v161;
                v163 = *(_QWORD *)v98;
                if (!*(_QWORD *)v98)
                  v163 = v98 | 1;
                *(_QWORD *)v160 = v163;
                *(_QWORD *)v98 = v160;
              }
              else
              {
                v16 = 0;
              }
              v138 = 1;
LABEL_418:
              v166 = v211;
              if (v211 == (char *)&v212 + 8)
              {
LABEL_344:
                if (!v138)
                {
LABEL_345:
                  if (v16)
                  {
                    v216 = 0;
                    v167 = sub_1C627E01C((uint64_t)(a1 + 118), v16, &v216);
                    v168 = 0;
                    if (v167)
                      v168 = v216[1];
                    if (v168)
                      v16 = v168;
                    if ((unsigned __int8 *)v16 == a1[116])
                      *((_BYTE *)a1 + 936) = 1;
                  }
                  goto LABEL_114;
                }
LABEL_376:
                a1[115] = (unsigned __int8 *)v16;
                goto LABEL_114;
              }
LABEL_343:
              free(v166);
              goto LABEL_344;
            }
          }
          else
          {
            free(v216);
            if (!v99)
              goto LABEL_325;
          }
          v138 = 0;
          v16 = (uint64_t)(v99 + 2);
          goto LABEL_418;
        case 'H':
          *a1 = v3 + 2;
          v83 = sub_1C5DFC098((uint64_t)a1, 0);
          v16 = 0;
          if (!v83)
            goto LABEL_114;
          v8 = v83;
          v196 = *((unsigned __int8 *)a1 + 937);
          v211 = (char *)&v212 + 8;
          v212 = xmmword_1C866F9F0;
          llvm::FoldingSetNodeID::AddString((unsigned int *)&v211, "thread-local initialization routine for ", 0x28u);
          v84 = v212;
          if (v212 >= DWORD1(v212))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v211, (uint64_t)&v212 + 8, v212 + 1, 4);
            v84 = v212;
          }
          *((_DWORD *)v211 + v84) = v8;
          v85 = (v212 + 1);
          LODWORD(v212) = v85;
          if (v85 >= DWORD1(v212))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v211, (uint64_t)&v212 + 8, v85 + 1, 4);
            LODWORD(v85) = v212;
          }
          *((_DWORD *)v211 + v85) = HIDWORD(v8);
          LODWORD(v212) = v212 + 1;
          v86 = sub_1C4F5AB38(v211, (uint64_t)v211 + 4 * v212);
          v13 = (uint64_t)&a1[113][8 * ((*((_DWORD *)a1 + 228) - 1) & v86)];
          v14 = *(unsigned int **)v13;
          v216 = v218;
          v217 = 0x2000000000;
          if (!v14 || (v14 & 1) != 0)
            goto LABEL_261;
          while (1)
          {
            LOBYTE(v86) = sub_1C5DFE6F4(v86, v14, (uint64_t)&v211, v87, (unsigned int *)&v216);
            if ((v86 & 1) != 0)
              break;
            LODWORD(v217) = 0;
            v14 = *(unsigned int **)v14;
            if (v14)
              v88 = (v14 & 1) == 0;
            else
              v88 = 0;
            if (!v88)
            {
              v14 = 0;
              goto LABEL_259;
            }
          }
          v13 = 0;
LABEL_259:
          if (v216 == v218)
          {
            if (v14)
              goto LABEL_372;
          }
          else
          {
            free(v216);
            if (v14)
              goto LABEL_372;
          }
LABEL_261:
          if (!v196)
            goto LABEL_287;
          v128 = sub_1C484358C((uint64_t)(a1 + 101), 48, 3);
          *(_QWORD *)v128 = 0;
          *(_QWORD *)(v128 + 8) = &unk_1E816A800;
          v16 = v128 + 8;
          *(_BYTE *)(v128 + 16) = 20;
          *(_WORD *)(v128 + 17) = *(_WORD *)(v128 + 17) & 0xF000 | 0x540;
          v129 = "thread-local initialization routine for ";
          v130 = "";
          goto LABEL_307;
        case 'I':
          *a1 = v3 + 2;
          v101 = sub_1C5DF9EB0(a1);
          if (!v101)
            goto LABEL_113;
          v8 = v101;
          v197 = *((unsigned __int8 *)a1 + 937);
          v211 = (char *)&v212 + 8;
          v212 = xmmword_1C866F9F0;
          llvm::FoldingSetNodeID::AddString((unsigned int *)&v211, "typeinfo for ", 0xDu);
          v102 = v212;
          if (v212 >= DWORD1(v212))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v211, (uint64_t)&v212 + 8, v212 + 1, 4);
            v102 = v212;
          }
          *((_DWORD *)v211 + v102) = v8;
          v103 = (v212 + 1);
          LODWORD(v212) = v103;
          if (v103 >= DWORD1(v212))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v211, (uint64_t)&v212 + 8, v103 + 1, 4);
            LODWORD(v103) = v212;
          }
          *((_DWORD *)v211 + v103) = HIDWORD(v8);
          LODWORD(v212) = v212 + 1;
          v104 = sub_1C4F5AB38(v211, (uint64_t)v211 + 4 * v212);
          v13 = (uint64_t)&a1[113][8 * ((*((_DWORD *)a1 + 228) - 1) & v104)];
          v14 = *(unsigned int **)v13;
          v216 = v218;
          v217 = 0x2000000000;
          if (!v14 || (v14 & 1) != 0)
            goto LABEL_271;
          while (1)
          {
            LOBYTE(v104) = sub_1C5DFE6F4(v104, v14, (uint64_t)&v211, v105, (unsigned int *)&v216);
            if ((v104 & 1) != 0)
              break;
            LODWORD(v217) = 0;
            v14 = *(unsigned int **)v14;
            if (v14)
              v106 = (v14 & 1) == 0;
            else
              v106 = 0;
            if (!v106)
            {
              v14 = 0;
              goto LABEL_269;
            }
          }
          v13 = 0;
LABEL_269:
          if (v216 == v218)
          {
            if (v14)
              goto LABEL_372;
          }
          else
          {
            free(v216);
            if (v14)
              goto LABEL_372;
          }
LABEL_271:
          if (!v197)
            goto LABEL_287;
          v128 = sub_1C484358C((uint64_t)(a1 + 101), 48, 3);
          *(_QWORD *)v128 = 0;
          *(_QWORD *)(v128 + 8) = &unk_1E816A800;
          v16 = v128 + 8;
          *(_BYTE *)(v128 + 16) = 20;
          *(_WORD *)(v128 + 17) = *(_WORD *)(v128 + 17) & 0xF000 | 0x540;
          v129 = "typeinfo for ";
          v130 = "";
          goto LABEL_307;
        default:
          switch(v3[1])
          {
            case 'S':
              *a1 = v3 + 2;
              v7 = sub_1C5DF9EB0(a1);
              if (!v7)
                goto LABEL_113;
              v8 = v7;
              v190 = *((unsigned __int8 *)a1 + 937);
              v211 = (char *)&v212 + 8;
              v212 = xmmword_1C866F9F0;
              llvm::FoldingSetNodeID::AddString((unsigned int *)&v211, "typeinfo name for ", 0x12u);
              v9 = v212;
              if (v212 >= DWORD1(v212))
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v211, (uint64_t)&v212 + 8, v212 + 1, 4);
                v9 = v212;
              }
              *((_DWORD *)v211 + v9) = v8;
              v10 = (v212 + 1);
              LODWORD(v212) = v10;
              if (v10 >= DWORD1(v212))
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v211, (uint64_t)&v212 + 8, v10 + 1, 4);
                LODWORD(v10) = v212;
              }
              *((_DWORD *)v211 + v10) = HIDWORD(v8);
              LODWORD(v212) = v212 + 1;
              v11 = sub_1C4F5AB38(v211, (uint64_t)v211 + 4 * v212);
              v13 = (uint64_t)&a1[113][8 * ((*((_DWORD *)a1 + 228) - 1) & v11)];
              v14 = *(unsigned int **)v13;
              v216 = v218;
              v217 = 0x2000000000;
              if (!v14 || (v14 & 1) != 0)
                goto LABEL_281;
              while (1)
              {
                LOBYTE(v11) = sub_1C5DFE6F4(v11, v14, (uint64_t)&v211, v12, (unsigned int *)&v216);
                if ((v11 & 1) != 0)
                  break;
                LODWORD(v217) = 0;
                v14 = *(unsigned int **)v14;
                if (v14)
                  v15 = (v14 & 1) == 0;
                else
                  v15 = 0;
                if (!v15)
                {
                  v14 = 0;
                  goto LABEL_279;
                }
              }
              v13 = 0;
LABEL_279:
              if (v216 == v218)
              {
                if (v14)
                  goto LABEL_372;
              }
              else
              {
                free(v216);
                if (v14)
                  goto LABEL_372;
              }
LABEL_281:
              if (!v190)
                goto LABEL_287;
              v128 = sub_1C484358C((uint64_t)(a1 + 101), 48, 3);
              *(_QWORD *)v128 = 0;
              *(_QWORD *)(v128 + 8) = &unk_1E816A800;
              v16 = v128 + 8;
              *(_BYTE *)(v128 + 16) = 20;
              *(_WORD *)(v128 + 17) = *(_WORD *)(v128 + 17) & 0xF000 | 0x540;
              v129 = "typeinfo name for ";
              v130 = "";
              goto LABEL_307;
            case 'T':
              *a1 = v3 + 2;
              v113 = sub_1C5DF9EB0(a1);
              if (!v113)
                goto LABEL_113;
              v8 = v113;
              v199 = *((unsigned __int8 *)a1 + 937);
              v211 = (char *)&v212 + 8;
              v212 = xmmword_1C866F9F0;
              llvm::FoldingSetNodeID::AddString((unsigned int *)&v211, "VTT for ", 8u);
              v114 = v212;
              if (v212 >= DWORD1(v212))
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v211, (uint64_t)&v212 + 8, v212 + 1, 4);
                v114 = v212;
              }
              *((_DWORD *)v211 + v114) = v8;
              v115 = (v212 + 1);
              LODWORD(v212) = v115;
              if (v115 >= DWORD1(v212))
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v211, (uint64_t)&v212 + 8, v115 + 1, 4);
                LODWORD(v115) = v212;
              }
              *((_DWORD *)v211 + v115) = HIDWORD(v8);
              LODWORD(v212) = v212 + 1;
              v116 = sub_1C4F5AB38(v211, (uint64_t)v211 + 4 * v212);
              v13 = (uint64_t)&a1[113][8 * ((*((_DWORD *)a1 + 228) - 1) & v116)];
              v14 = *(unsigned int **)v13;
              v216 = v218;
              v217 = 0x2000000000;
              if (!v14 || (v14 & 1) != 0)
                goto LABEL_286;
              while (1)
              {
                LOBYTE(v116) = sub_1C5DFE6F4(v116, v14, (uint64_t)&v211, v117, (unsigned int *)&v216);
                if ((v116 & 1) != 0)
                  break;
                LODWORD(v217) = 0;
                v14 = *(unsigned int **)v14;
                if (v14)
                  v118 = (v14 & 1) == 0;
                else
                  v118 = 0;
                if (!v118)
                {
                  v14 = 0;
                  goto LABEL_284;
                }
              }
              v13 = 0;
LABEL_284:
              if (v216 == v218)
              {
                if (v14)
                  goto LABEL_372;
              }
              else
              {
                free(v216);
                if (v14)
                  goto LABEL_372;
              }
LABEL_286:
              if (!v199)
                goto LABEL_287;
              v128 = sub_1C484358C((uint64_t)(a1 + 101), 48, 3);
              *(_QWORD *)v128 = 0;
              *(_QWORD *)(v128 + 8) = &unk_1E816A800;
              v16 = v128 + 8;
              *(_BYTE *)(v128 + 16) = 20;
              *(_WORD *)(v128 + 17) = *(_WORD *)(v128 + 17) & 0xF000 | 0x540;
              v129 = "VTT for ";
              v130 = "";
              goto LABEL_307;
            case 'U':
              goto LABEL_108;
            case 'V':
              *a1 = v3 + 2;
              v107 = sub_1C5DF9EB0(a1);
              if (!v107)
                goto LABEL_113;
              v8 = v107;
              v198 = *((unsigned __int8 *)a1 + 937);
              v211 = (char *)&v212 + 8;
              v212 = xmmword_1C866F9F0;
              llvm::FoldingSetNodeID::AddString((unsigned int *)&v211, "vtable for ", 0xBu);
              v108 = v212;
              if (v212 >= DWORD1(v212))
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v211, (uint64_t)&v212 + 8, v212 + 1, 4);
                v108 = v212;
              }
              *((_DWORD *)v211 + v108) = v8;
              v109 = (v212 + 1);
              LODWORD(v212) = v109;
              if (v109 >= DWORD1(v212))
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v211, (uint64_t)&v212 + 8, v109 + 1, 4);
                LODWORD(v109) = v212;
              }
              *((_DWORD *)v211 + v109) = HIDWORD(v8);
              LODWORD(v212) = v212 + 1;
              v110 = sub_1C4F5AB38(v211, (uint64_t)v211 + 4 * v212);
              v13 = (uint64_t)&a1[113][8 * ((*((_DWORD *)a1 + 228) - 1) & v110)];
              v14 = *(unsigned int **)v13;
              v216 = v218;
              v217 = 0x2000000000;
              if (!v14 || (v14 & 1) != 0)
                goto LABEL_276;
              while (1)
              {
                LOBYTE(v110) = sub_1C5DFE6F4(v110, v14, (uint64_t)&v211, v111, (unsigned int *)&v216);
                if ((v110 & 1) != 0)
                  break;
                LODWORD(v217) = 0;
                v14 = *(unsigned int **)v14;
                if (v14)
                  v112 = (v14 & 1) == 0;
                else
                  v112 = 0;
                if (!v112)
                {
                  v14 = 0;
                  goto LABEL_274;
                }
              }
              v13 = 0;
LABEL_274:
              if (v216 == v218)
              {
                if (v14)
                  goto LABEL_372;
              }
              else
              {
                free(v216);
                if (v14)
                  goto LABEL_372;
              }
LABEL_276:
              if (!v198)
                goto LABEL_287;
              v128 = sub_1C484358C((uint64_t)(a1 + 101), 48, 3);
              *(_QWORD *)v128 = 0;
              *(_QWORD *)(v128 + 8) = &unk_1E816A800;
              v16 = v128 + 8;
              *(_BYTE *)(v128 + 16) = 20;
              *(_WORD *)(v128 + 17) = *(_WORD *)(v128 + 17) & 0xF000 | 0x540;
              v129 = "vtable for ";
              v130 = "";
              goto LABEL_307;
            case 'W':
              *a1 = v3 + 2;
              v16 = 0;
              v216 = (_QWORD *)sub_1C5DFC098((uint64_t)a1, 0);
              if (!v216)
                goto LABEL_114;
              v119 = sub_1C5E119F8((uint64_t)a1, "thread-local wrapper routine for ", (uint64_t *)&v216);
              goto LABEL_403;
            default:
              if (v3[1] != 99)
                goto LABEL_108;
              *a1 = v3 + 2;
              if ((sub_1C54C3E9C((uint64_t)a1) & 1) != 0)
                goto LABEL_113;
              if ((sub_1C54C3E9C((uint64_t)a1) & 1) != 0)
                goto LABEL_113;
              v60 = sub_1C5DFC50C(a1);
              if (!v60)
                goto LABEL_113;
              v8 = v60;
              v194 = *((unsigned __int8 *)a1 + 937);
              v211 = (char *)&v212 + 8;
              v212 = xmmword_1C866F9F0;
              llvm::FoldingSetNodeID::AddString((unsigned int *)&v211, "covariant return thunk to ", 0x1Au);
              v61 = v212;
              if (v212 >= DWORD1(v212))
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v211, (uint64_t)&v212 + 8, v212 + 1, 4);
                v61 = v212;
              }
              *((_DWORD *)v211 + v61) = v8;
              v62 = (v212 + 1);
              LODWORD(v212) = v62;
              if (v62 >= DWORD1(v212))
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v211, (uint64_t)&v212 + 8, v62 + 1, 4);
                LODWORD(v62) = v212;
              }
              *((_DWORD *)v211 + v62) = HIDWORD(v8);
              LODWORD(v212) = v212 + 1;
              v63 = sub_1C4F5AB38(v211, (uint64_t)v211 + 4 * v212);
              v13 = (uint64_t)&a1[113][8 * ((*((_DWORD *)a1 + 228) - 1) & v63)];
              v14 = *(unsigned int **)v13;
              v216 = v218;
              v217 = 0x2000000000;
              if (!v14 || (v14 & 1) != 0)
                goto LABEL_320;
              break;
          }
          while (1)
          {
            LOBYTE(v63) = sub_1C5DFE6F4(v63, v14, (uint64_t)&v211, v64, (unsigned int *)&v216);
            if ((v63 & 1) != 0)
              break;
            LODWORD(v217) = 0;
            v14 = *(unsigned int **)v14;
            if (v14)
              v65 = (v14 & 1) == 0;
            else
              v65 = 0;
            if (!v65)
            {
              v14 = 0;
              goto LABEL_318;
            }
          }
          v13 = 0;
LABEL_318:
          if (v216 == v218)
          {
            if (v14)
              goto LABEL_372;
          }
          else
          {
            free(v216);
            if (v14)
              goto LABEL_372;
          }
LABEL_320:
          if (!v194)
            goto LABEL_287;
          v128 = sub_1C484358C((uint64_t)(a1 + 101), 48, 3);
          *(_QWORD *)v128 = 0;
          *(_QWORD *)(v128 + 8) = &unk_1E816A800;
          v16 = v128 + 8;
          *(_BYTE *)(v128 + 16) = 20;
          *(_WORD *)(v128 + 17) = *(_WORD *)(v128 + 17) & 0xF000 | 0x540;
          v129 = "covariant return thunk to ";
          v130 = "";
          goto LABEL_307;
      }
    }
LABEL_108:
    v66 = v3 + 1;
    *a1 = v66;
    v67 = v4 != v66 && *v66 == 118;
    if ((sub_1C54C3E9C((uint64_t)a1) & 1) != 0 || (v68 = sub_1C5DFC50C(a1)) == 0)
    {
LABEL_113:
      v16 = 0;
      goto LABEL_114;
    }
    v70 = v68;
    v195 = *((unsigned __int8 *)a1 + 937);
    v187 = (uint64_t)(a1 + 101);
    if (v67)
    {
      v211 = (char *)&v212 + 8;
      v212 = xmmword_1C866F9F0;
      llvm::FoldingSetNodeID::AddString((unsigned int *)&v211, "virtual thunk to ", 0x11u);
      v71 = v212;
      if (v212 >= DWORD1(v212))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v211, (uint64_t)&v212 + 8, v212 + 1, 4);
        v71 = v212;
      }
      *((_DWORD *)v211 + v71) = v70;
      v72 = (v212 + 1);
      LODWORD(v212) = v72;
      if (v72 >= DWORD1(v212))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v211, (uint64_t)&v212 + 8, v72 + 1, 4);
        LODWORD(v72) = v212;
      }
      *((_DWORD *)v211 + v72) = HIDWORD(v70);
      LODWORD(v212) = v212 + 1;
      v73 = sub_1C4F5AB38(v211, (uint64_t)v211 + 4 * v212);
      v75 = (uint64_t)&a1[113][8 * ((*((_DWORD *)a1 + 228) - 1) & v73)];
      v76 = *(unsigned int **)v75;
      v216 = v218;
      v217 = 0x2000000000;
      if (v76 && (v76 & 1) == 0)
      {
        while (1)
        {
          LOBYTE(v73) = sub_1C5DFE6F4(v73, v76, (uint64_t)&v211, v74, (unsigned int *)&v216);
          if ((v73 & 1) != 0)
            break;
          LODWORD(v217) = 0;
          v76 = *(unsigned int **)v76;
          if (v76)
            v77 = (v76 & 1) == 0;
          else
            v77 = 0;
          if (!v77)
          {
            v76 = 0;
            goto LABEL_225;
          }
        }
        v75 = 0;
LABEL_225:
        if (v216 == v218)
        {
          if (!v76)
            goto LABEL_227;
LABEL_341:
          v138 = 0;
          v16 = (uint64_t)(v76 + 2);
LABEL_342:
          v166 = v211;
          if (v211 == (char *)&v212 + 8)
            goto LABEL_344;
          goto LABEL_343;
        }
        free(v216);
        if (v76)
          goto LABEL_341;
      }
LABEL_227:
      if (v195)
      {
        v125 = sub_1C484358C(v187, 48, 3);
        *(_QWORD *)v125 = 0;
        *(_QWORD *)(v125 + 8) = &unk_1E816A800;
        v16 = v125 + 8;
        *(_BYTE *)(v125 + 16) = 20;
        *(_WORD *)(v125 + 17) = *(_WORD *)(v125 + 17) & 0xF000 | 0x540;
        v126 = "virtual thunk to ";
        v127 = "";
LABEL_253:
        *(_QWORD *)(v125 + 24) = v126;
        *(_QWORD *)(v125 + 32) = v127;
        *(_QWORD *)(v125 + 40) = v70;
        v135 = *((_DWORD *)a1 + 229) + 1;
        v136 = *((_DWORD *)a1 + 228);
        if (v135 > 2 * v136)
        {
          v165 = (unsigned int *)v125;
          llvm::FoldingSetBase::GrowBucketCount((uint64_t)(a1 + 113), 2 * v136, (uint64_t)off_1E81A1260);
          v216 = v218;
          v217 = 0x2000000000;
          sub_1C5DFE788(v165, (unsigned int *)&v216);
          v75 = (uint64_t)&a1[113][8
                                * ((*((_DWORD *)a1 + 228) - 1) & sub_1C4F5AB38(v216, (uint64_t)v216 + 4 * v217))];
          if (v216 != v218)
            free(v216);
          v135 = *((_DWORD *)a1 + 229) + 1;
          v125 = (unint64_t)v165;
        }
        *((_DWORD *)a1 + 229) = v135;
        v137 = *(_QWORD *)v75;
        if (!*(_QWORD *)v75)
          v137 = v75 | 1;
        *(_QWORD *)v125 = v137;
        *(_QWORD *)v75 = v125;
        goto LABEL_257;
      }
      goto LABEL_233;
    }
    v211 = (char *)&v212 + 8;
    v212 = xmmword_1C866F9F0;
    llvm::FoldingSetNodeID::AddString((unsigned int *)&v211, "non-virtual thunk to ", 0x15u);
    v78 = v212;
    if (v212 >= DWORD1(v212))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v211, (uint64_t)&v212 + 8, v212 + 1, 4);
      v78 = v212;
    }
    *((_DWORD *)v211 + v78) = v70;
    v79 = (v212 + 1);
    LODWORD(v212) = v79;
    if (v79 >= DWORD1(v212))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v211, (uint64_t)&v212 + 8, v79 + 1, 4);
      LODWORD(v79) = v212;
    }
    *((_DWORD *)v211 + v79) = HIDWORD(v70);
    LODWORD(v212) = v212 + 1;
    v80 = sub_1C4F5AB38(v211, (uint64_t)v211 + 4 * v212);
    v75 = (uint64_t)&a1[113][8 * ((*((_DWORD *)a1 + 228) - 1) & v80)];
    v76 = *(unsigned int **)v75;
    v216 = v218;
    v217 = 0x2000000000;
    if (v76 && (v76 & 1) == 0)
    {
      while (1)
      {
        LOBYTE(v80) = sub_1C5DFE6F4(v80, v76, (uint64_t)&v211, v81, (unsigned int *)&v216);
        if ((v80 & 1) != 0)
          break;
        LODWORD(v217) = 0;
        v76 = *(unsigned int **)v76;
        if (v76)
          v82 = (v76 & 1) == 0;
        else
          v82 = 0;
        if (!v82)
        {
          v76 = 0;
          goto LABEL_230;
        }
      }
      v75 = 0;
LABEL_230:
      if (v216 == v218)
      {
        if (v76)
          goto LABEL_341;
      }
      else
      {
        free(v216);
        if (v76)
          goto LABEL_341;
      }
    }
    if (v195)
    {
      v125 = sub_1C484358C(v187, 48, 3);
      *(_QWORD *)v125 = 0;
      *(_QWORD *)(v125 + 8) = &unk_1E816A800;
      v16 = v125 + 8;
      *(_BYTE *)(v125 + 16) = 20;
      *(_WORD *)(v125 + 17) = *(_WORD *)(v125 + 17) & 0xF000 | 0x540;
      v126 = "non-virtual thunk to ";
      v127 = "";
      goto LABEL_253;
    }
LABEL_233:
    v16 = 0;
LABEL_257:
    v138 = 1;
    goto LABEL_342;
  }
LABEL_20:
  LOWORD(v203) = 0;
  HIDWORD(v203) = 0;
  v204[0] = 0;
  v205 = (a1[91] - a1[90]) >> 3;
  v16 = sub_1C5DFC098((uint64_t)a1, (uint64_t)&v203);
  v202 = v16;
  if (!v16)
    goto LABEL_114;
  v17 = v205;
  v18 = a1[90];
  v19 = (a1[91] - v18) >> 3;
  v20 = v19 > v205;
  v21 = v19 - v205;
  if (v20)
  {
    v22 = a1[83];
    if (v22 != a1[84])
    {
      v23 = &v18[8 * v205];
      while (*(_QWORD *)v22)
      {
        v24 = *(_QWORD *)(*(_QWORD *)v23 + 16);
        v25 = **(_QWORD **)v22;
        if (v24 >= (*(_QWORD *)(*(_QWORD *)v22 + 8) - v25) >> 3)
          break;
        *(_QWORD *)(*(_QWORD *)v23 + 24) = *(_QWORD *)(v25 + 8 * v24);
        v23 += 8;
        if (!--v21)
          goto LABEL_28;
      }
    }
    goto LABEL_113;
  }
LABEL_28:
  a1[91] = &v18[8 * v17];
  v26 = *a1;
  v27 = a1[1];
  v28 = v27 - *a1;
  if (v27 == *a1)
    goto LABEL_114;
  v29 = *v26 - 46;
  v20 = v29 > 0x31;
  v30 = (1 << v29) & 0x2000000800001;
  if (!v20 && v30 != 0)
    goto LABEL_114;
  v201 = 0;
  if (v28 >= 0xD && !strncmp("Ua9enable_ifI", (const char *)v26, 0xDuLL))
  {
    v32 = v26 + 13;
    *a1 = v26 + 13;
    v33 = (a1[3] - a1[2]) >> 3;
    while (v32 == v27 || *v32 != 69)
    {
      v34 = sub_1C5E0B790(a1);
      if (!v34)
        goto LABEL_113;
      v35 = v34;
      v36 = a1[3];
      if (v36 == a1[4])
      {
        sub_1C625449C((uint64_t)(a1 + 2), (v36 - a1[2]) >> 2);
        v36 = a1[3];
      }
      a1[3] = v36 + 8;
      *(_QWORD *)v36 = v35;
      v32 = *a1;
      v27 = a1[1];
    }
    *a1 = v32 + 1;
    v139 = a1[3];
    v140 = v33;
    v141 = &a1[2][8 * v33];
    v142 = (uint64_t *)sub_1C484358C((uint64_t)(a1 + 101), v139 - v141, 3);
    v143 = v142;
    v144 = v139 - v141;
    v189 = v142;
    if (v139 != v141)
    {
      memmove(v142, v141, v139 - v141);
      v143 = v189;
    }
    a1[3] = &a1[2][8 * v140];
    v186 = *((unsigned __int8 *)a1 + 937);
    v211 = (char *)&v212 + 8;
    *(_QWORD *)&v212 = 0x2000000000;
    v185 = v144 >> 3;
    sub_1C5E0169C(&v211, 9, v143, v144 >> 3);
    v145 = sub_1C4F5AB38(v211, (uint64_t)v211 + 4 * v212);
    v147 = (uint64_t)&a1[113][8 * ((*((_DWORD *)a1 + 228) - 1) & v145)];
    v148 = *(unsigned int **)v147;
    v216 = v218;
    v217 = 0x2000000000;
    if (v148)
      v149 = (v148 & 1) == 0;
    else
      v149 = 0;
    if (!v149)
      goto LABEL_304;
    while (1)
    {
      LOBYTE(v145) = sub_1C5DFE6F4(v145, v148, (uint64_t)&v211, v146, (unsigned int *)&v216);
      if ((v145 & 1) != 0)
        break;
      LODWORD(v217) = 0;
      v148 = *(unsigned int **)v148;
      if (v148)
        v150 = (v148 & 1) == 0;
      else
        v150 = 0;
      if (!v150)
      {
        v148 = 0;
        goto LABEL_302;
      }
    }
    v147 = 0;
LABEL_302:
    if (v216 == v218)
    {
      if (!v148)
      {
LABEL_304:
        if (v186)
        {
          v155 = sub_1C484358C((uint64_t)(a1 + 101), 40, 3);
          *(_QWORD *)v155 = 0;
          *(_QWORD *)(v155 + 8) = &unk_1E816C080;
          v16 = v155 + 8;
          *(_BYTE *)(v155 + 16) = 9;
          *(_WORD *)(v155 + 17) = *(_WORD *)(v155 + 17) & 0xF000 | 0x540;
          *(_QWORD *)(v155 + 24) = v189;
          *(_QWORD *)(v155 + 32) = v185;
          v156 = *((_DWORD *)a1 + 229) + 1;
          v157 = *((_DWORD *)a1 + 228);
          if (v156 > 2 * v157)
          {
            llvm::FoldingSetBase::GrowBucketCount((uint64_t)(a1 + 113), 2 * v157, (uint64_t)off_1E81A1260);
            v216 = v218;
            v217 = 0x2000000000;
            sub_1C5DFE788((unsigned int *)v155, (unsigned int *)&v216);
            v147 = (uint64_t)&a1[113][8
                                   * ((*((_DWORD *)a1 + 228) - 1) & sub_1C4F5AB38(v216, (uint64_t)v216+ 4 * v217))];
            if (v216 != v218)
              free(v216);
            v156 = *((_DWORD *)a1 + 229) + 1;
          }
          *((_DWORD *)a1 + 229) = v156;
          v158 = *(_QWORD *)v147;
          if (!*(_QWORD *)v147)
            v158 = v147 | 1;
          *(_QWORD *)v155 = v158;
          *(_QWORD *)v147 = v155;
        }
        else
        {
          v16 = 0;
        }
        v159 = 1;
        goto LABEL_379;
      }
    }
    else
    {
      free(v216);
      if (!v148)
        goto LABEL_304;
    }
    v159 = 0;
    v16 = (uint64_t)(v148 + 2);
LABEL_379:
    if (v211 != (char *)&v212 + 8)
      free(v211);
    if (v159)
    {
      a1[115] = (unsigned __int8 *)v16;
    }
    else
    {
      if (!v16)
        goto LABEL_114;
      v216 = 0;
      v182 = sub_1C627E01C((uint64_t)(a1 + 118), v16, &v216);
      v183 = 0;
      if (v182)
        v183 = v216[1];
      if (v183)
        v16 = v183;
      if ((unsigned __int8 *)v16 == a1[116])
        *((_BYTE *)a1 + 936) = 1;
    }
    v201 = v16;
    if (!v16)
      goto LABEL_114;
  }
  v211 = 0;
  if (!(_BYTE)v203)
  {
    if (BYTE1(v203))
    {
      v211 = (void *)sub_1C5DF9EB0(a1);
      if (!v211)
        goto LABEL_113;
    }
  }
  v169 = *a1;
  if (*a1 == a1[1] || *v169 != 118)
  {
    v171 = (a1[3] - a1[2]) >> 3;
    while (1)
    {
      v172 = sub_1C5DF9EB0(a1);
      if (!v172)
        goto LABEL_113;
      v173 = v172;
      v174 = a1[3];
      if (v174 == a1[4])
      {
        sub_1C625449C((uint64_t)(a1 + 2), (v174 - a1[2]) >> 2);
        v174 = a1[3];
      }
      a1[3] = v174 + 8;
      *(_QWORD *)v174 = v173;
      if (a1[1] != *a1)
      {
        v175 = **a1 - 46;
        v20 = v175 > 0x31;
        v176 = (1 << v175) & 0x2000000800001;
        if (v20 || v176 == 0)
          continue;
      }
      v178 = a1[3];
      v179 = &a1[2][8 * v171];
      v180 = (_QWORD *)sub_1C484358C((uint64_t)(a1 + 101), v178 - v179, 3);
      v181 = v180;
      if (v178 != v179)
        memmove(v180, v179, v178 - v179);
      a1[3] = &a1[2][8 * v171];
      v216 = v181;
      v217 = (v178 - v179) >> 3;
      v170 = (uint64_t)a1;
      goto LABEL_402;
    }
  }
  *a1 = v169 + 1;
  v216 = 0;
  v217 = 0;
  v170 = (uint64_t)a1;
LABEL_402:
  v119 = sub_1C5E11478(v170, (uint64_t *)&v211, &v202, (uint64_t)&v216, &v201, (int *)&v203 + 1, v204);
LABEL_403:
  v16 = v119;
LABEL_114:
  sub_1C6253D78(v206 + 664, (uint64_t)v207);
  sub_1C6253E58(v206 + 576, (uint64_t)v209);
  if (v209[0] != v210)
    free(v209[0]);
  if (v207[0] != v208)
    free(v207[0]);
  return v16;
}

unsigned int *sub_1C5DFE6E8(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  return sub_1C5DFE788(a2, a3);
}

BOOL sub_1C5DFE6F4(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, unsigned int *a5)
{
  uint64_t v7;

  sub_1C5DFE788(a2, a5);
  v7 = *(unsigned int *)(a3 + 8);
  return (_DWORD)v7 == a5[2] && memcmp(*(const void **)a5, *(const void **)a3, 4 * v7) == 0;
}

unint64_t sub_1C5DFE750(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  sub_1C5DFE788(a2, a3);
  return sub_1C4F5AB38(*(_QWORD **)a3, *(_QWORD *)a3 + 4 * a3[2]);
}

unsigned int *sub_1C5DFE788(unsigned int *result, unsigned int *a2)
{
  uint64_t *v3;
  uint64_t v4;
  unsigned int *v5;
  int v6;
  unsigned __int8 *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unsigned __int8 *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  unsigned __int8 *v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  unsigned __int8 *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  unsigned int v48;
  uint64_t v49;
  unsigned int v50;
  uint64_t v51;
  unsigned int v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  _QWORD *v58;
  uint64_t v59;
  uint64_t v60;
  unsigned int v61;
  int v62;
  uint64_t v63;
  unsigned int v64;
  uint64_t v65;
  unsigned int v66;
  uint64_t v67;
  unsigned int v68;
  uint64_t v69;
  unsigned int v70;
  uint64_t v71;
  unsigned int v72;
  uint64_t v73;
  unsigned int v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unsigned int v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t *v84;
  uint64_t v85;
  uint64_t v86;
  unsigned int v87;
  uint64_t v88;
  unsigned int v89;
  uint64_t v90;
  unsigned int v91;
  uint64_t v92;
  unsigned int v93;
  uint64_t v94;
  unsigned int v95;
  uint64_t v96;
  unsigned int v97;
  uint64_t v98;
  unsigned int v99;
  uint64_t v100;
  unsigned int v101;
  uint64_t v102;
  unsigned int v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  unsigned int v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  unsigned int v111;
  uint64_t v112;
  uint64_t v113;
  unsigned int v114;
  uint64_t v115;
  unint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  int v120;
  unsigned int v121;
  uint64_t v122;
  int v123;
  uint64_t v124;
  unsigned int v125;
  uint64_t v126;
  unsigned int v127;
  uint64_t v128;
  unsigned int v129;
  uint64_t v130;
  unsigned int v131;
  uint64_t v132;
  unsigned int v133;
  uint64_t v134;
  unsigned int v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  int v139;
  uint64_t v140;
  int v141;
  uint64_t v142;
  unsigned int v143;
  uint64_t v144;
  unsigned int v145;
  uint64_t v146;
  unsigned int v147;
  uint64_t v148;
  unsigned int v149;
  uint64_t v150;
  unsigned int v151;
  uint64_t v152;
  unsigned int v153;
  uint64_t v154;
  unsigned int v155;
  uint64_t v156;
  int v157;
  uint64_t v158;
  unsigned __int8 *v159;
  uint64_t v160;
  uint64_t v161;
  int v162;
  unsigned int *v163;
  int v164;
  uint64_t v165;
  uint64_t v166;
  int v167;
  uint64_t v168;
  unsigned int v169;
  uint64_t v170;
  unsigned __int8 *v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  unsigned int v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  unsigned int v179;
  uint64_t v180;
  unsigned int v181;
  uint64_t v182;
  unsigned int v183;
  uint64_t v184;
  unsigned int v185;
  uint64_t v186;
  unsigned int v187;
  uint64_t v188;
  unsigned int v189;
  uint64_t v190;
  unsigned int v191;
  uint64_t v192;
  unsigned int v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  unsigned __int8 *v197;
  uint64_t v198;
  uint64_t *v199;
  uint64_t v200;
  int v201;
  uint64_t v202;
  unsigned int v203;
  uint64_t v204;
  unsigned int v205;
  uint64_t v206;
  unsigned int v207;
  uint64_t v208;
  unsigned int v209;
  uint64_t v210;
  unsigned int v211;
  uint64_t v212;
  uint64_t v213;
  unsigned int v214;
  uint64_t v215;
  unsigned int v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  unsigned int v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  unsigned __int8 *v225;
  uint64_t v226;
  int v227;
  uint64_t v228;
  unsigned int v229;
  uint64_t v230;
  uint64_t v231;
  unsigned int v232;
  uint64_t v233;
  unsigned int v234;
  uint64_t v235;
  uint64_t v236;
  unsigned __int8 *v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  unsigned int v241;
  uint64_t v242;
  uint64_t v243;
  unsigned int v244;
  uint64_t v245;
  unsigned int v246;
  uint64_t v247;
  unsigned int v248;
  uint64_t v249;
  unsigned int v250;
  uint64_t v251;
  __int16 v252;
  uint64_t v253;
  uint64_t *v254;
  uint64_t v255;
  int v256;
  unsigned int *v257;
  int v258;
  uint64_t v259;
  uint64_t v260;
  unsigned int v261;
  uint64_t v262;
  unsigned int v263;
  uint64_t v264;
  unsigned int v265;
  uint64_t v266;
  unsigned int v267;
  uint64_t v268;
  unsigned int v269;
  uint64_t v270;
  uint64_t v271;
  unsigned int v272;
  uint64_t v273;
  uint64_t *v274;
  uint64_t v275;
  uint64_t v276;
  unsigned int v277;
  uint64_t v278;
  unsigned int v279;
  uint64_t v280;
  unsigned int v281;
  uint64_t v282;
  unsigned int v283;
  uint64_t v284;
  unsigned int v285;
  uint64_t v286;
  unsigned int v287;
  uint64_t v288;
  uint64_t v289;
  unsigned int v290;
  uint64_t v291;
  int v292;
  unsigned __int8 *v293;
  uint64_t v294;
  uint64_t v295;
  unsigned int v296;
  uint64_t v297;
  unsigned int v298;
  uint64_t v299;
  unsigned int v300;
  uint64_t v301;
  uint64_t v302;
  unsigned int v303;
  uint64_t v304;
  unsigned int v305;
  unsigned int v306;
  uint64_t v307;
  unsigned int v308;
  uint64_t v309;
  unsigned int v310;
  uint64_t v311;
  unsigned int v312;
  unsigned int *v313;
  unsigned __int8 *v314;
  uint64_t v315;
  uint64_t v316;
  unsigned int v317;
  uint64_t v318;
  unsigned int v319;
  uint64_t v320;
  unsigned int v321;
  uint64_t v322;
  unsigned int v323;
  uint64_t v324;
  unsigned int v325;
  uint64_t v326;
  unsigned int v327;
  uint64_t v328;
  unsigned int v329;
  uint64_t v330;
  uint64_t v331;
  uint64_t v332;
  unsigned int v333;
  uint64_t v334;
  unsigned int v335;
  uint64_t v336;
  unsigned int v337;
  uint64_t v338;
  unsigned int v339;
  uint64_t v340;
  unsigned int v341;
  uint64_t v342;
  unsigned int v343;
  uint64_t v344;
  unsigned int v345;
  uint64_t v346;
  unsigned int v347;
  uint64_t v348;
  unsigned int v349;
  uint64_t v350;
  unsigned int v351;
  uint64_t v352;
  unsigned __int8 *v353;
  unsigned __int8 *v354;
  unsigned __int8 *v355;
  unsigned __int8 *v356;
  unsigned __int8 *v357;
  unsigned __int8 *v358;
  unsigned __int8 *v359;
  _QWORD *v360;
  uint64_t v361;
  uint64_t v362;
  unsigned __int8 *v363;
  unsigned __int8 *v364;
  uint64_t v365;
  unsigned __int8 *v366;
  unsigned __int8 *v367;
  int v368;
  int v369;
  unsigned int v370;
  uint64_t v371;
  unsigned int v372;
  unsigned __int8 *v373;
  unsigned __int8 *v374;
  unsigned __int8 *v375;
  unsigned __int8 *v376;
  _QWORD *v377;
  uint64_t v378;
  uint64_t v379;
  unsigned __int8 *v380;
  unsigned __int8 *v381;
  int v382;
  unsigned __int8 *v383;
  unsigned __int8 *v384;
  int v385;
  unsigned int v386;
  int v387;
  unint64_t v388;
  unint64_t v389;
  unsigned int v390;
  unsigned int v391;
  uint64_t v392;
  uint64_t v393;
  uint64_t v394;
  unsigned __int8 *v395;
  unsigned __int8 *v396;
  uint64_t v397;
  uint64_t v398;
  unsigned __int8 *v399;
  unsigned __int8 *v400;
  int v401;
  _QWORD *v402;
  _QWORD *v403;
  uint64_t v404;
  uint64_t v405;
  _QWORD *v406;
  _QWORD *v407;
  uint64_t v408;
  uint64_t v409;
  uint64_t v410;
  uint64_t v411;
  uint64_t v412;
  _QWORD *v413;
  _QWORD *v414;
  uint64_t v415;
  uint64_t v416;
  uint64_t v417;
  uint64_t v418;
  int v419;
  int v420;
  int v421;
  unsigned int v422;
  unsigned int v423;
  int v424;
  int v425;
  unsigned __int8 *v426;
  int v427;
  int v428;
  int v429;
  unsigned int v430;
  unsigned int v431;
  unsigned int v432;
  unsigned int v433;
  uint64_t v434;
  int v435;
  int v436;
  uint64_t v437;
  unsigned __int8 *v438;
  unsigned __int8 *v439;
  unsigned __int8 *v440;
  unsigned __int8 *v441;
  unsigned __int8 *v442;
  int v443;
  int v444;
  int v445;
  unsigned int v446;
  unsigned int v447;
  unsigned int v448;
  unsigned int v449;
  int v450;
  int v451;
  int v452;
  int v453;
  unsigned __int8 *v454;
  unsigned __int8 *v455;
  unsigned __int8 *v456;

  switch(*((_BYTE *)result + 16))
  {
    case 0:
      v3 = (uint64_t *)*((_QWORD *)result + 3);
      v4 = *((_QWORD *)result + 4);
      v5 = a2;
      v6 = 0;
      return sub_1C5E0169C(v5, v6, v3, v4);
    case 1:
      v8 = *((_QWORD *)result + 3);
      v7 = (unsigned __int8 *)*((_QWORD *)result + 4);
      v9 = *((_QWORD *)result + 5);
      v10 = a2[2];
      if (v10 >= a2[3])
      {
        v354 = (unsigned __int8 *)*((_QWORD *)result + 4);
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v10 + 1, 4);
        v7 = v354;
        LODWORD(v10) = a2[2];
      }
      v11 = *(_QWORD *)a2;
      v12 = 1;
      goto LABEL_396;
    case 2:
      v14 = *((_QWORD *)result + 3);
      v13 = (unsigned __int8 *)*((_QWORD *)result + 4);
      v16 = *((_QWORD *)result + 5);
      v15 = *((_QWORD *)result + 6);
      v17 = a2[2];
      if (v17 >= a2[3])
      {
        v355 = (unsigned __int8 *)*((_QWORD *)result + 4);
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v17 + 1, 4);
        v13 = v355;
        LODWORD(v17) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v17) = 2;
      v18 = a2[3];
      v19 = a2[2] + 1;
      a2[2] = v19;
      if (v19 >= v18)
      {
        v375 = v13;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v19 + 1, 4);
        v13 = v375;
        LODWORD(v19) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v19) = 0;
      v20 = a2[3];
      v21 = a2[2] + 1;
      a2[2] = v21;
      if (v21 >= v20)
      {
        v356 = v13;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v21 + 1, 4);
        v13 = v356;
        LODWORD(v21) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v21) = v14;
      v22 = a2[3];
      v23 = a2[2] + 1;
      a2[2] = v23;
      if (v23 >= v22)
      {
        v376 = v13;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v23 + 1, 4);
        v13 = v376;
        LODWORD(v23) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v23) = HIDWORD(v14);
      ++a2[2];
      result = llvm::FoldingSetNodeID::AddString(a2, v13, (int)v16 - (int)v13);
      v24 = a2[2];
      v25 = a2[3];
      goto LABEL_387;
    case 3:
      v26 = *((_QWORD *)result + 3);
      v27 = result[5];
      v28 = a2[2];
      if (v28 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v28 + 1, 4);
        LODWORD(v28) = a2[2];
      }
      v29 = *(_QWORD *)a2;
      v30 = 3;
      goto LABEL_146;
    case 4:
      v15 = *((_QWORD *)result + 3);
      v31 = a2[2];
      if (v31 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v31 + 1, 4);
        LODWORD(v31) = a2[2];
      }
      v32 = *(_QWORD *)a2;
      v33 = 4;
      goto LABEL_382;
    case 5:
      v8 = *((_QWORD *)result + 3);
      v7 = (unsigned __int8 *)*((_QWORD *)result + 4);
      v9 = *((_QWORD *)result + 5);
      v10 = a2[2];
      if (v10 >= a2[3])
      {
        v357 = (unsigned __int8 *)*((_QWORD *)result + 4);
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v10 + 1, 4);
        v7 = v357;
        LODWORD(v10) = a2[2];
      }
      v11 = *(_QWORD *)a2;
      v12 = 5;
      goto LABEL_396;
    case 6:
      v34 = (unsigned __int8 *)*((_QWORD *)result + 3);
      v35 = *((_QWORD *)result + 4);
      v36 = *((_QWORD *)result + 5);
      v37 = a2[2];
      if (v37 >= a2[3])
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v37 + 1, 4);
        LODWORD(v37) = a2[2];
      }
      v38 = *(_QWORD *)a2;
      v39 = 6;
      goto LABEL_109;
    case 7:
      v40 = (unsigned __int8 *)*((_QWORD *)result + 3);
      v41 = *((_QWORD *)result + 4);
      v42 = a2[2];
      if (v42 >= a2[3])
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v42 + 1, 4);
        LODWORD(v42) = a2[2];
      }
      v43 = *(_QWORD *)a2;
      v44 = 7;
      goto LABEL_417;
    case 8:
      v8 = *((_QWORD *)result + 3);
      v7 = (unsigned __int8 *)*((_QWORD *)result + 4);
      v9 = *((_QWORD *)result + 5);
      v10 = a2[2];
      if (v10 >= a2[3])
      {
        v358 = (unsigned __int8 *)*((_QWORD *)result + 4);
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v10 + 1, 4);
        v7 = v358;
        LODWORD(v10) = a2[2];
      }
      v11 = *(_QWORD *)a2;
      v12 = 8;
      goto LABEL_396;
    case 9:
      v3 = (uint64_t *)*((_QWORD *)result + 3);
      v4 = *((_QWORD *)result + 4);
      v5 = a2;
      v6 = 9;
      return sub_1C5E0169C(v5, v6, v3, v4);
    case 0xA:
      v8 = *((_QWORD *)result + 3);
      v7 = (unsigned __int8 *)*((_QWORD *)result + 4);
      v9 = *((_QWORD *)result + 5);
      v10 = a2[2];
      if (v10 >= a2[3])
      {
        v359 = (unsigned __int8 *)*((_QWORD *)result + 4);
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v10 + 1, 4);
        v7 = v359;
        LODWORD(v10) = a2[2];
      }
      v11 = *(_QWORD *)a2;
      v12 = 10;
      goto LABEL_396;
    case 0xB:
      v15 = *((_QWORD *)result + 3);
      v31 = a2[2];
      if (v31 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v31 + 1, 4);
        LODWORD(v31) = a2[2];
      }
      v32 = *(_QWORD *)a2;
      v33 = 11;
      goto LABEL_382;
    case 0xC:
      v45 = *((_QWORD *)result + 3);
      v46 = result[8];
      v47 = a2[2];
      if (v47 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v47 + 1, 4);
        LODWORD(v47) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v47) = 12;
      v48 = a2[3];
      v49 = a2[2] + 1;
      a2[2] = v49;
      if (v49 >= v48)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v49 + 1, 4);
        LODWORD(v49) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v49) = 0;
      v50 = a2[3];
      v51 = a2[2] + 1;
      a2[2] = v51;
      if (v51 >= v50)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v51 + 1, 4);
        LODWORD(v51) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v51) = v45;
      v52 = a2[3];
      v53 = a2[2] + 1;
      a2[2] = v53;
      if (v53 >= v52)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v53 + 1, 4);
        LODWORD(v53) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v53) = HIDWORD(v45);
      goto LABEL_210;
    case 0xD:
      v54 = *((_QWORD *)result + 3);
      v15 = *((_QWORD *)result + 4);
      v55 = a2[2];
      if (v55 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v55 + 1, 4);
        LODWORD(v55) = a2[2];
      }
      v56 = *(_QWORD *)a2;
      v57 = 13;
      goto LABEL_177;
    case 0xE:
      v54 = *((_QWORD *)result + 3);
      v15 = *((_QWORD *)result + 4);
      v55 = a2[2];
      if (v55 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v55 + 1, 4);
        LODWORD(v55) = a2[2];
      }
      v56 = *(_QWORD *)a2;
      v57 = 14;
      goto LABEL_177;
    case 0xF:
      v59 = *((_QWORD *)result + 3);
      v58 = (_QWORD *)*((_QWORD *)result + 4);
      v60 = *((_QWORD *)result + 5);
      v61 = result[12];
      v62 = *((unsigned __int8 *)result + 52);
      v15 = *((_QWORD *)result + 7);
      v63 = a2[2];
      if (v63 >= a2[3])
      {
        v427 = *((unsigned __int8 *)result + 52);
        v406 = (_QWORD *)*((_QWORD *)result + 4);
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v63 + 1, 4);
        v58 = v406;
        v62 = v427;
        LODWORD(v63) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v63) = 15;
      v64 = a2[3];
      v65 = a2[2] + 1;
      a2[2] = v65;
      if (v65 >= v64)
      {
        v443 = v62;
        v413 = v58;
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v65 + 1, 4);
        v58 = v413;
        v62 = v443;
        LODWORD(v65) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v65) = 0;
      v66 = a2[3];
      v67 = a2[2] + 1;
      a2[2] = v67;
      if (v67 >= v66)
      {
        v428 = v62;
        v407 = v58;
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v67 + 1, 4);
        v58 = v407;
        v62 = v428;
        LODWORD(v67) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v67) = v59;
      v68 = a2[3];
      v69 = a2[2] + 1;
      a2[2] = v69;
      if (v69 >= v68)
      {
        v444 = v62;
        v414 = v58;
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v69 + 1, 4);
        v58 = v414;
        v62 = v444;
        LODWORD(v69) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v69) = HIDWORD(v59);
      v70 = a2[3];
      v71 = a2[2] + 1;
      a2[2] = v71;
      if (v71 >= v70)
      {
        v429 = v62;
        v360 = v58;
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v71 + 1, 4);
        v58 = v360;
        v62 = v429;
        LODWORD(v71) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v71) = v60;
      v72 = a2[3];
      v73 = a2[2] + 1;
      a2[2] = v73;
      if (v73 >= v72)
      {
        v445 = v62;
        v377 = v58;
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v73 + 1, 4);
        v58 = v377;
        v62 = v445;
        LODWORD(v73) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v73) = HIDWORD(v60);
      v74 = a2[2] + 1;
      a2[2] = v74;
      if (v60)
      {
        v75 = (uint64_t)(a2 + 4);
        v76 = 8 * v60;
        do
        {
          v77 = *v58;
          if (v74 >= a2[3])
          {
            v388 = v15;
            v402 = v58;
            v80 = v75;
            v420 = v62;
            result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, v75, v74 + 1, 4);
            v62 = v420;
            v75 = v80;
            v15 = v388;
            v58 = v402;
            v74 = a2[2];
          }
          *(_DWORD *)(*(_QWORD *)a2 + 4 * v74) = v77;
          v78 = a2[3];
          v79 = a2[2] + 1;
          a2[2] = v79;
          if (v79 >= v78)
          {
            v389 = v15;
            v403 = v58;
            v81 = v75;
            v421 = v62;
            result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, v75, v79 + 1, 4);
            v62 = v421;
            v75 = v81;
            v15 = v389;
            v58 = v403;
            LODWORD(v79) = a2[2];
          }
          *(_DWORD *)(*(_QWORD *)a2 + 4 * v79) = HIDWORD(v77);
          v74 = a2[2] + 1;
          a2[2] = v74;
          ++v58;
          v76 -= 8;
        }
        while (v76);
      }
      if (v74 >= a2[3])
      {
        v368 = v62;
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v74 + 1, 4);
        v62 = v368;
        v74 = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v74) = v61;
      v339 = a2[3];
      v340 = a2[2] + 1;
      a2[2] = v340;
      if (v340 >= v339)
      {
        v385 = v62;
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v340 + 1, 4);
        v62 = v385;
        LODWORD(v340) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v340) = 0;
      v341 = a2[3];
      v342 = a2[2] + 1;
      a2[2] = v342;
      if (v342 >= v341)
      {
        v369 = v62;
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v342 + 1, 4);
        v62 = v369;
        LODWORD(v342) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v342) = v62;
      goto LABEL_383;
    case 0x10:
      v15 = *((_QWORD *)result + 3);
      v31 = a2[2];
      if (v31 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v31 + 1, 4);
        LODWORD(v31) = a2[2];
      }
      v32 = *(_QWORD *)a2;
      v33 = 16;
      goto LABEL_382;
    case 0x11:
      v3 = (uint64_t *)*((_QWORD *)result + 3);
      v4 = *((_QWORD *)result + 4);
      v5 = a2;
      v6 = 17;
      return sub_1C5E0169C(v5, v6, v3, v4);
    case 0x12:
      v83 = *((_QWORD *)result + 3);
      v82 = *((_QWORD *)result + 4);
      v84 = (uint64_t *)*((_QWORD *)result + 5);
      v85 = *((_QWORD *)result + 6);
      v86 = *((_QWORD *)result + 7);
      v87 = result[16];
      v27 = *((unsigned __int8 *)result + 68);
      v88 = a2[2];
      if (v88 >= a2[3])
      {
        v430 = result[16];
        v392 = *((_QWORD *)result + 4);
        v408 = *((_QWORD *)result + 7);
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v88 + 1, 4);
        v82 = v392;
        v86 = v408;
        v87 = v430;
        LODWORD(v88) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v88) = 18;
      v89 = a2[3];
      v90 = a2[2] + 1;
      a2[2] = v90;
      if (v90 >= v89)
      {
        v446 = v87;
        v397 = v82;
        v415 = v86;
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v90 + 1, 4);
        v82 = v397;
        v86 = v415;
        v87 = v446;
        LODWORD(v90) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v90) = 0;
      v91 = a2[3];
      v92 = a2[2] + 1;
      a2[2] = v92;
      if (v92 >= v91)
      {
        v431 = v87;
        v393 = v82;
        v409 = v86;
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v92 + 1, 4);
        v82 = v393;
        v86 = v409;
        v87 = v431;
        LODWORD(v92) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v92) = v83;
      v93 = a2[3];
      v94 = a2[2] + 1;
      a2[2] = v94;
      if (v94 >= v93)
      {
        v447 = v87;
        v398 = v82;
        v416 = v86;
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v94 + 1, 4);
        v82 = v398;
        v86 = v416;
        v87 = v447;
        LODWORD(v94) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v94) = HIDWORD(v83);
      v95 = a2[3];
      v96 = a2[2] + 1;
      a2[2] = v96;
      if (v96 >= v95)
      {
        v432 = v87;
        v361 = v86;
        v394 = v82;
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v96 + 1, 4);
        v82 = v394;
        v86 = v361;
        v87 = v432;
        LODWORD(v96) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v96) = v82;
      v97 = a2[3];
      v98 = a2[2] + 1;
      a2[2] = v98;
      if (v98 >= v97)
      {
        v448 = v87;
        v378 = v86;
        v401 = HIDWORD(v82);
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v98 + 1, 4);
        HIDWORD(v82) = v401;
        v86 = v378;
        v87 = v448;
        LODWORD(v98) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v98) = HIDWORD(v82);
      v99 = a2[3];
      v100 = a2[2] + 1;
      a2[2] = v100;
      if (v100 >= v99)
      {
        v433 = v87;
        v362 = v86;
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v100 + 1, 4);
        v86 = v362;
        v87 = v433;
        LODWORD(v100) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v100) = v85;
      v101 = a2[3];
      v102 = a2[2] + 1;
      a2[2] = v102;
      if (v102 >= v101)
      {
        v449 = v87;
        v379 = v86;
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v102 + 1, 4);
        v86 = v379;
        v87 = v449;
        LODWORD(v102) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v102) = HIDWORD(v85);
      v103 = a2[2] + 1;
      a2[2] = v103;
      if (v85)
      {
        v104 = (uint64_t)(a2 + 4);
        v105 = 8 * v85;
        do
        {
          v106 = *v84;
          if (v103 >= a2[3])
          {
            v390 = v27;
            v109 = v104;
            v422 = v87;
            v404 = v86;
            result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, v104, v103 + 1, 4);
            v86 = v404;
            v87 = v422;
            v104 = v109;
            v27 = v390;
            v103 = a2[2];
          }
          *(_DWORD *)(*(_QWORD *)a2 + 4 * v103) = v106;
          v107 = a2[3];
          v108 = a2[2] + 1;
          a2[2] = v108;
          if (v108 >= v107)
          {
            v391 = v27;
            v110 = v104;
            v423 = v87;
            v405 = v86;
            result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, v104, v108 + 1, 4);
            v86 = v405;
            v87 = v423;
            v104 = v110;
            v27 = v391;
            LODWORD(v108) = a2[2];
          }
          *(_DWORD *)(*(_QWORD *)a2 + 4 * v108) = HIDWORD(v106);
          v103 = a2[2] + 1;
          a2[2] = v103;
          ++v84;
          v105 -= 8;
        }
        while (v105);
      }
      if (v103 >= a2[3])
      {
        v370 = v87;
        v371 = v86;
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v103 + 1, 4);
        v86 = v371;
        v87 = v370;
        v103 = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v103) = v86;
      v343 = a2[3];
      v344 = a2[2] + 1;
      a2[2] = v344;
      if (v344 >= v343)
      {
        v386 = v87;
        v387 = HIDWORD(v86);
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v344 + 1, 4);
        HIDWORD(v86) = v387;
        v87 = v386;
        LODWORD(v344) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v344) = HIDWORD(v86);
      v345 = a2[3];
      v346 = a2[2] + 1;
      a2[2] = v346;
      if (v346 >= v345)
      {
        v372 = v87;
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v346 + 1, 4);
        v87 = v372;
        LODWORD(v346) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v346) = v87;
      goto LABEL_460;
    case 0x13:
      v15 = *((_QWORD *)result + 3);
      v31 = a2[2];
      if (v31 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v31 + 1, 4);
        LODWORD(v31) = a2[2];
      }
      v32 = *(_QWORD *)a2;
      v33 = 19;
      goto LABEL_382;
    case 0x14:
      v34 = (unsigned __int8 *)*((_QWORD *)result + 3);
      v35 = *((_QWORD *)result + 4);
      v36 = *((_QWORD *)result + 5);
      v37 = a2[2];
      if (v37 >= a2[3])
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v37 + 1, 4);
        LODWORD(v37) = a2[2];
      }
      v38 = *(_QWORD *)a2;
      v39 = 20;
LABEL_109:
      *(_DWORD *)(v38 + 4 * v37) = v39;
      v111 = a2[3];
      v112 = a2[2] + 1;
      a2[2] = v112;
      if (v112 >= v111)
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v112 + 1, 4);
        LODWORD(v112) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v112) = 0;
      ++a2[2];
      result = llvm::FoldingSetNodeID::AddString(a2, v34, (int)v35 - (int)v34);
      v113 = a2[2];
      if (v113 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v113 + 1, 4);
        LODWORD(v113) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v113) = v36;
      v114 = a2[3];
      v115 = a2[2] + 1;
      a2[2] = v115;
      if (v115 >= v114)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v115 + 1, 4);
        LODWORD(v115) = a2[2];
      }
      v116 = HIDWORD(v36);
      goto LABEL_392;
    case 0x15:
      v54 = *((_QWORD *)result + 3);
      v15 = *((_QWORD *)result + 4);
      v55 = a2[2];
      if (v55 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v55 + 1, 4);
        LODWORD(v55) = a2[2];
      }
      v56 = *(_QWORD *)a2;
      v57 = 21;
      goto LABEL_177;
    case 0x16:
      v54 = *((_QWORD *)result + 3);
      v15 = *((_QWORD *)result + 4);
      v55 = a2[2];
      if (v55 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v55 + 1, 4);
        LODWORD(v55) = a2[2];
      }
      v56 = *(_QWORD *)a2;
      v57 = 22;
      goto LABEL_177;
    case 0x17:
      v54 = *((_QWORD *)result + 3);
      v15 = *((_QWORD *)result + 4);
      v55 = a2[2];
      if (v55 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v55 + 1, 4);
        LODWORD(v55) = a2[2];
      }
      v56 = *(_QWORD *)a2;
      v57 = 23;
      goto LABEL_177;
    case 0x18:
      v54 = *((_QWORD *)result + 3);
      v15 = *((_QWORD *)result + 4);
      v55 = a2[2];
      if (v55 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v55 + 1, 4);
        LODWORD(v55) = a2[2];
      }
      v56 = *(_QWORD *)a2;
      v57 = 24;
      goto LABEL_177;
    case 0x19:
      v117 = *((_QWORD *)result + 3);
      v26 = *((_QWORD *)result + 4);
      v27 = *((unsigned __int8 *)result + 40);
      v118 = a2[2];
      if (v118 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v118 + 1, 4);
        LODWORD(v118) = a2[2];
      }
      v119 = *(_QWORD *)a2;
      v120 = 25;
      goto LABEL_425;
    case 0x1A:
      v54 = *((_QWORD *)result + 3);
      v15 = *((_QWORD *)result + 4);
      v55 = a2[2];
      if (v55 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v55 + 1, 4);
        LODWORD(v55) = a2[2];
      }
      v56 = *(_QWORD *)a2;
      v57 = 26;
      goto LABEL_177;
    case 0x1B:
      v54 = *((_QWORD *)result + 3);
      v15 = *((_QWORD *)result + 4);
      v55 = a2[2];
      if (v55 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v55 + 1, 4);
        LODWORD(v55) = a2[2];
      }
      v56 = *(_QWORD *)a2;
      v57 = 27;
      goto LABEL_177;
    case 0x1C:
      v15 = *((_QWORD *)result + 3);
      v31 = a2[2];
      if (v31 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v31 + 1, 4);
        LODWORD(v31) = a2[2];
      }
      v32 = *(_QWORD *)a2;
      v33 = 28;
      goto LABEL_382;
    case 0x1D:
      v15 = *((_QWORD *)result + 3);
      v31 = a2[2];
      if (v31 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v31 + 1, 4);
        LODWORD(v31) = a2[2];
      }
      v32 = *(_QWORD *)a2;
      v33 = 29;
      goto LABEL_382;
    case 0x1E:
      v26 = *((_QWORD *)result + 3);
      v27 = *((unsigned __int8 *)result + 32);
      v28 = a2[2];
      if (v28 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v28 + 1, 4);
        LODWORD(v28) = a2[2];
      }
      v29 = *(_QWORD *)a2;
      v30 = 30;
LABEL_146:
      *(_DWORD *)(v29 + 4 * v28) = v30;
      v121 = a2[3];
      v122 = a2[2] + 1;
      a2[2] = v122;
      if (v122 >= v121)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v122 + 1, 4);
        LODWORD(v122) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v122) = 0;
      goto LABEL_432;
    case 0x1F:
      v123 = result[5];
      v27 = result[6];
      v124 = a2[2];
      if (v124 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v124 + 1, 4);
        LODWORD(v124) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v124) = 31;
      v125 = a2[3];
      v126 = a2[2] + 1;
      a2[2] = v126;
      if (v126 >= v125)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v126 + 1, 4);
        LODWORD(v126) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v126) = 0;
      v127 = a2[3];
      v128 = a2[2] + 1;
      a2[2] = v128;
      if (v128 >= v127)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v128 + 1, 4);
        LODWORD(v128) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v128) = v123;
      v129 = a2[3];
      v130 = a2[2] + 1;
      a2[2] = v130;
      if (v130 >= v129)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v130 + 1, 4);
        LODWORD(v130) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v130) = v123 >> 31;
      goto LABEL_463;
    case 0x20:
      v15 = *((_QWORD *)result + 3);
      v31 = a2[2];
      if (v31 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v31 + 1, 4);
        LODWORD(v31) = a2[2];
      }
      v32 = *(_QWORD *)a2;
      v33 = 32;
      goto LABEL_382;
    case 0x21:
      v54 = *((_QWORD *)result + 3);
      v15 = *((_QWORD *)result + 4);
      v55 = a2[2];
      if (v55 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v55 + 1, 4);
        LODWORD(v55) = a2[2];
      }
      v56 = *(_QWORD *)a2;
      v57 = 33;
      goto LABEL_177;
    case 0x22:
      return sub_1C5E01858(a2, 34, *((_QWORD *)result + 3), *((uint64_t **)result + 4), *((_QWORD *)result + 5));
    case 0x23:
      v15 = *((_QWORD *)result + 3);
      v31 = a2[2];
      if (v31 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v31 + 1, 4);
        LODWORD(v31) = a2[2];
      }
      v32 = *(_QWORD *)a2;
      v33 = 35;
      goto LABEL_382;
    case 0x24:
      v3 = (uint64_t *)*((_QWORD *)result + 3);
      v4 = *((_QWORD *)result + 4);
      v5 = a2;
      v6 = 36;
      return sub_1C5E0169C(v5, v6, v3, v4);
    case 0x25:
      v3 = (uint64_t *)*((_QWORD *)result + 3);
      v4 = *((_QWORD *)result + 4);
      v5 = a2;
      v6 = 37;
      return sub_1C5E0169C(v5, v6, v3, v4);
    case 0x26:
      v15 = *((_QWORD *)result + 3);
      v31 = a2[2];
      if (v31 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v31 + 1, 4);
        LODWORD(v31) = a2[2];
      }
      v32 = *(_QWORD *)a2;
      v33 = 38;
      goto LABEL_382;
    case 0x27:
      v3 = (uint64_t *)*((_QWORD *)result + 3);
      v4 = *((_QWORD *)result + 4);
      v5 = a2;
      v6 = 39;
      return sub_1C5E0169C(v5, v6, v3, v4);
    case 0x29:
      v54 = *((_QWORD *)result + 3);
      v15 = *((_QWORD *)result + 4);
      v55 = a2[2];
      if (v55 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v55 + 1, 4);
        LODWORD(v55) = a2[2];
      }
      v56 = *(_QWORD *)a2;
      v57 = 41;
LABEL_177:
      *(_DWORD *)(v56 + 4 * v55) = v57;
      v131 = a2[3];
      v132 = a2[2] + 1;
      a2[2] = v132;
      if (v132 >= v131)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v132 + 1, 4);
        LODWORD(v132) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v132) = 0;
      goto LABEL_180;
    case 0x2A:
      v15 = *((_QWORD *)result + 3);
      v31 = a2[2];
      if (v31 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v31 + 1, 4);
        LODWORD(v31) = a2[2];
      }
      v32 = *(_QWORD *)a2;
      v33 = 42;
      goto LABEL_382;
    case 0x2B:
      v46 = result[5];
      v137 = a2[2];
      if (v137 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v137 + 1, 4);
        LODWORD(v137) = a2[2];
      }
      v138 = *(_QWORD *)a2;
      v139 = 43;
      goto LABEL_195;
    case 0x2C:
      v46 = result[5];
      v137 = a2[2];
      if (v137 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v137 + 1, 4);
        LODWORD(v137) = a2[2];
      }
      v138 = *(_QWORD *)a2;
      v139 = 44;
LABEL_195:
      *(_DWORD *)(v138 + 4 * v137) = v139;
      goto LABEL_207;
    case 0x2D:
      v140 = *((_QWORD *)result + 3);
      v141 = *((unsigned __int8 *)result + 32);
      v46 = result[9];
      v142 = a2[2];
      if (v142 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v142 + 1, 4);
        LODWORD(v142) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v142) = 45;
      v143 = a2[3];
      v144 = a2[2] + 1;
      a2[2] = v144;
      if (v144 >= v143)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v144 + 1, 4);
        LODWORD(v144) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v144) = 0;
      v145 = a2[3];
      v146 = a2[2] + 1;
      a2[2] = v146;
      if (v146 >= v145)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v146 + 1, 4);
        LODWORD(v146) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v146) = v140;
      v147 = a2[3];
      v148 = a2[2] + 1;
      a2[2] = v148;
      if (v148 >= v147)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v148 + 1, 4);
        LODWORD(v148) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v148) = HIDWORD(v140);
      v149 = a2[3];
      v150 = a2[2] + 1;
      a2[2] = v150;
      if (v150 >= v149)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v150 + 1, 4);
        LODWORD(v150) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v150) = v141;
LABEL_207:
      v151 = a2[3];
      v152 = a2[2] + 1;
      a2[2] = v152;
      if (v152 >= v151)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v152 + 1, 4);
        LODWORD(v152) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v152) = 0;
LABEL_210:
      v153 = a2[3];
      v154 = a2[2] + 1;
      a2[2] = v154;
      if (v154 >= v153)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v154 + 1, 4);
        LODWORD(v154) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v154) = v46;
      v155 = a2[3];
      v156 = a2[2] + 1;
      a2[2] = v156;
      if (v156 >= v155)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v156 + 1, 4);
        LODWORD(v156) = a2[2];
      }
      v157 = v46 >> 31;
      goto LABEL_340;
    case 0x2E:
      v15 = *((_QWORD *)result + 3);
      v31 = a2[2];
      if (v31 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v31 + 1, 4);
        LODWORD(v31) = a2[2];
      }
      v32 = *(_QWORD *)a2;
      v33 = 46;
      goto LABEL_382;
    case 0x2F:
      v40 = (unsigned __int8 *)*((_QWORD *)result + 3);
      v41 = *((_QWORD *)result + 4);
      v42 = a2[2];
      if (v42 >= a2[3])
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v42 + 1, 4);
        LODWORD(v42) = a2[2];
      }
      v43 = *(_QWORD *)a2;
      v44 = 47;
      goto LABEL_417;
    case 0x30:
      return sub_1C5E01A94(a2, *((uint64_t **)result + 3), *((_QWORD *)result + 4), *((uint64_t **)result + 5), *((_QWORD *)result + 6), *((unsigned __int8 **)result + 7), *((_QWORD *)result + 8));
    case 0x31:
      v3 = (uint64_t *)*((_QWORD *)result + 3);
      v4 = *((_QWORD *)result + 4);
      v5 = a2;
      v6 = 49;
      return sub_1C5E0169C(v5, v6, v3, v4);
    case 0x32:
      v158 = *((_QWORD *)result + 3);
      v159 = (unsigned __int8 *)*((_QWORD *)result + 4);
      v160 = *((_QWORD *)result + 5);
      v161 = *((_QWORD *)result + 6);
      v162 = *(unsigned __int16 *)((char *)result + 17) << 26 >> 26;
      v163 = a2;
      v164 = 50;
      return (unsigned int *)sub_1C5E01D94(v163, v164, v158, v159, v160, v161, v162);
    case 0x33:
      v166 = *((_QWORD *)result + 3);
      v165 = *((_QWORD *)result + 4);
      v167 = *(unsigned __int16 *)((char *)result + 17);
      v168 = a2[2];
      if (v168 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v168 + 1, 4);
        LODWORD(v168) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v168) = 51;
      v169 = a2[3];
      v170 = a2[2] + 1;
      a2[2] = v170;
      if (v170 >= v169)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v170 + 1, 4);
        LODWORD(v170) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v170) = 0;
      goto LABEL_244;
    case 0x34:
      v172 = *((_QWORD *)result + 3);
      v171 = (unsigned __int8 *)*((_QWORD *)result + 4);
      v173 = *((_QWORD *)result + 5);
      v167 = *(unsigned __int16 *)((char *)result + 17);
      v174 = a2[2];
      if (v174 >= a2[3])
      {
        v363 = (unsigned __int8 *)*((_QWORD *)result + 4);
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v174 + 1, 4);
        v171 = v363;
        LODWORD(v174) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v174) = 52;
      v175 = a2[3];
      v176 = a2[2] + 1;
      a2[2] = v176;
      if (v176 >= v175)
      {
        v380 = v171;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v176 + 1, 4);
        v171 = v380;
        LODWORD(v176) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v176) = 0;
      goto LABEL_329;
    case 0x35:
      v177 = *((_QWORD *)result + 3);
      v166 = *((_QWORD *)result + 4);
      v165 = *((_QWORD *)result + 5);
      v167 = *(unsigned __int16 *)((char *)result + 17);
      v178 = a2[2];
      if (v178 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v178 + 1, 4);
        LODWORD(v178) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v178) = 53;
      v179 = a2[3];
      v180 = a2[2] + 1;
      a2[2] = v180;
      if (v180 >= v179)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v180 + 1, 4);
        LODWORD(v180) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v180) = 0;
      v181 = a2[3];
      v182 = a2[2] + 1;
      a2[2] = v182;
      if (v182 >= v181)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v182 + 1, 4);
        LODWORD(v182) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v182) = v177;
      v183 = a2[3];
      v184 = a2[2] + 1;
      a2[2] = v184;
      if (v184 >= v183)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v184 + 1, 4);
        LODWORD(v184) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v184) = HIDWORD(v177);
LABEL_244:
      v185 = a2[3];
      v186 = a2[2] + 1;
      a2[2] = v186;
      if (v186 >= v185)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v186 + 1, 4);
        LODWORD(v186) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v186) = v166;
      v187 = a2[3];
      v188 = a2[2] + 1;
      a2[2] = v188;
      if (v188 >= v187)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v188 + 1, 4);
        LODWORD(v188) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v188) = HIDWORD(v166);
      v189 = a2[3];
      v190 = a2[2] + 1;
      a2[2] = v190;
      if (v190 >= v189)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v190 + 1, 4);
        LODWORD(v190) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v190) = v165;
      v191 = a2[3];
      v192 = a2[2] + 1;
      a2[2] = v192;
      if (v192 >= v191)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v192 + 1, 4);
        LODWORD(v192) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v192) = HIDWORD(v165);
      v193 = a2[3];
      v194 = a2[2] + 1;
      a2[2] = v194;
      if (v194 >= v193)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v194 + 1, 4);
        LODWORD(v194) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v194) = v167 << 26 >> 26;
      goto LABEL_336;
    case 0x36:
      v158 = *((_QWORD *)result + 3);
      v159 = (unsigned __int8 *)*((_QWORD *)result + 4);
      v160 = *((_QWORD *)result + 5);
      v161 = *((_QWORD *)result + 6);
      v162 = *(unsigned __int16 *)((char *)result + 17) << 26 >> 26;
      v163 = a2;
      v164 = 54;
      return (unsigned int *)sub_1C5E01D94(v163, v164, v158, v159, v160, v161, v162);
    case 0x37:
      v196 = *((_QWORD *)result + 3);
      v195 = *((_QWORD *)result + 4);
      v197 = (unsigned __int8 *)*((_QWORD *)result + 5);
      v198 = *((_QWORD *)result + 6);
      v199 = (uint64_t *)*((_QWORD *)result + 7);
      v200 = *((_QWORD *)result + 8);
      v201 = *((unsigned __int8 *)result + 72);
      v202 = a2[2];
      if (v202 >= a2[3])
      {
        v410 = *((_QWORD *)result + 4);
        v434 = *((_QWORD *)result + 6);
        v395 = (unsigned __int8 *)*((_QWORD *)result + 5);
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v202 + 1, 4);
        v195 = v410;
        LODWORD(v198) = v434;
        v197 = v395;
        LODWORD(v202) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v202) = 55;
      v203 = a2[3];
      v204 = a2[2] + 1;
      a2[2] = v204;
      if (v204 >= v203)
      {
        v417 = v195;
        v450 = v198;
        v399 = v197;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v204 + 1, 4);
        v195 = v417;
        LODWORD(v198) = v450;
        v197 = v399;
        LODWORD(v204) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v204) = 0;
      v205 = a2[3];
      v206 = a2[2] + 1;
      a2[2] = v206;
      if (v206 >= v205)
      {
        v411 = v195;
        v435 = v198;
        v396 = v197;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v206 + 1, 4);
        v195 = v411;
        LODWORD(v198) = v435;
        v197 = v396;
        LODWORD(v206) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v206) = v196;
      v207 = a2[3];
      v208 = a2[2] + 1;
      a2[2] = v208;
      if (v208 >= v207)
      {
        v418 = v195;
        v451 = v198;
        v400 = v197;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v208 + 1, 4);
        v195 = v418;
        LODWORD(v198) = v451;
        v197 = v400;
        LODWORD(v208) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v208) = HIDWORD(v196);
      v209 = a2[3];
      v210 = a2[2] + 1;
      a2[2] = v210;
      if (v210 >= v209)
      {
        v412 = v195;
        v436 = v198;
        v364 = v197;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v210 + 1, 4);
        v195 = v412;
        LODWORD(v198) = v436;
        v197 = v364;
        LODWORD(v210) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v210) = v195;
      v211 = a2[3];
      v212 = a2[2] + 1;
      a2[2] = v212;
      if (v212 >= v211)
      {
        v419 = HIDWORD(v195);
        v452 = v198;
        v381 = v197;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v212 + 1, 4);
        HIDWORD(v195) = v419;
        LODWORD(v198) = v452;
        v197 = v381;
        LODWORD(v212) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v212) = HIDWORD(v195);
      ++a2[2];
      result = llvm::FoldingSetNodeID::AddString(a2, v197, (int)v198 - (int)v197);
      v213 = a2[2];
      if (v213 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v213 + 1, 4);
        LODWORD(v213) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v213) = v200;
      v214 = a2[3];
      v215 = a2[2] + 1;
      a2[2] = v215;
      if (v215 >= v214)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v215 + 1, 4);
        LODWORD(v215) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v215) = HIDWORD(v200);
      v216 = a2[2] + 1;
      a2[2] = v216;
      if (v200)
      {
        v217 = (uint64_t)(a2 + 4);
        v218 = 8 * v200;
        do
        {
          v219 = *v199;
          if (v216 >= a2[3])
          {
            v424 = v201;
            v222 = v217;
            result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, v217, v216 + 1, 4);
            v217 = v222;
            v201 = v424;
            v216 = a2[2];
          }
          *(_DWORD *)(*(_QWORD *)a2 + 4 * v216) = v219;
          v220 = a2[3];
          v221 = a2[2] + 1;
          a2[2] = v221;
          if (v221 >= v220)
          {
            v425 = v201;
            v223 = v217;
            result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, v217, v221 + 1, 4);
            v217 = v223;
            v201 = v425;
            LODWORD(v221) = a2[2];
          }
          *(_DWORD *)(*(_QWORD *)a2 + 4 * v221) = HIDWORD(v219);
          v216 = a2[2] + 1;
          a2[2] = v216;
          ++v199;
          v218 -= 8;
        }
        while (v218);
      }
      if (v216 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v216 + 1, 4);
        v216 = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v216) = v201;
      goto LABEL_466;
    case 0x38:
      v225 = (unsigned __int8 *)*((_QWORD *)result + 3);
      v224 = *((_QWORD *)result + 4);
      v226 = *((_QWORD *)result + 5);
      v227 = *(unsigned __int16 *)((char *)result + 17);
      v228 = a2[2];
      if (v228 >= a2[3])
      {
        v365 = *((_QWORD *)result + 4);
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v228 + 1, 4);
        LODWORD(v224) = v365;
        LODWORD(v228) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v228) = 56;
      v229 = a2[3];
      v230 = a2[2] + 1;
      a2[2] = v230;
      if (v230 >= v229)
      {
        v382 = v224;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v230 + 1, 4);
        LODWORD(v224) = v382;
        LODWORD(v230) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v230) = 0;
      ++a2[2];
      result = llvm::FoldingSetNodeID::AddString(a2, v225, (int)v224 - (int)v225);
      v231 = a2[2];
      if (v231 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v231 + 1, 4);
        LODWORD(v231) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v231) = v226;
      v232 = a2[3];
      v233 = a2[2] + 1;
      a2[2] = v233;
      if (v233 >= v232)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v233 + 1, 4);
        LODWORD(v233) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v233) = HIDWORD(v226);
      v234 = a2[3];
      v235 = a2[2] + 1;
      a2[2] = v235;
      if (v235 >= v234)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v235 + 1, 4);
        LODWORD(v235) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v235) = v227 << 26 >> 26;
      goto LABEL_307;
    case 0x39:
      v237 = (unsigned __int8 *)*((_QWORD *)result + 3);
      v236 = *((_QWORD *)result + 4);
      v239 = *((_QWORD *)result + 5);
      v238 = *((_QWORD *)result + 6);
      v227 = *(unsigned __int16 *)((char *)result + 17);
      v240 = a2[2];
      if (v240 >= a2[3])
      {
        v437 = *((_QWORD *)result + 4);
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v240 + 1, 4);
        LODWORD(v236) = v437;
        LODWORD(v240) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v240) = 57;
      v241 = a2[3];
      v242 = a2[2] + 1;
      a2[2] = v242;
      if (v242 >= v241)
      {
        v453 = v236;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v242 + 1, 4);
        LODWORD(v236) = v453;
        LODWORD(v242) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v242) = 0;
      ++a2[2];
      result = llvm::FoldingSetNodeID::AddString(a2, v237, (int)v236 - (int)v237);
      v243 = a2[2];
      if (v243 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v243 + 1, 4);
        LODWORD(v243) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v243) = v239;
      v244 = a2[3];
      v245 = a2[2] + 1;
      a2[2] = v245;
      if (v245 >= v244)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v245 + 1, 4);
        LODWORD(v245) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v245) = HIDWORD(v239);
      v246 = a2[3];
      v247 = a2[2] + 1;
      a2[2] = v247;
      if (v247 >= v246)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v247 + 1, 4);
        LODWORD(v247) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v247) = v238;
      v248 = a2[3];
      v249 = a2[2] + 1;
      a2[2] = v249;
      if (v249 >= v248)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v249 + 1, 4);
        LODWORD(v249) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v249) = HIDWORD(v238);
      v250 = a2[3];
      v251 = a2[2] + 1;
      a2[2] = v251;
      if (v251 >= v250)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v251 + 1, 4);
        LODWORD(v251) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v251) = v227 << 26 >> 26;
LABEL_307:
      v252 = (_WORD)v227 << 10;
      goto LABEL_337;
    case 0x3A:
      v15 = *((_QWORD *)result + 3);
      v31 = a2[2];
      if (v31 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v31 + 1, 4);
        LODWORD(v31) = a2[2];
      }
      v32 = *(_QWORD *)a2;
      v33 = 58;
      goto LABEL_382;
    case 0x3B:
      v253 = *((_QWORD *)result + 3);
      v254 = (uint64_t *)*((_QWORD *)result + 4);
      v255 = *((_QWORD *)result + 5);
      v256 = *(unsigned __int16 *)((char *)result + 17) << 26 >> 26;
      v257 = a2;
      v258 = 59;
      return sub_1C5E01FCC(v257, v258, v253, v254, v255, v256);
    case 0x3C:
      return sub_1C5E02288(a2, *((uint64_t **)result + 3), *((_QWORD *)result + 4), *((_QWORD *)result + 5), *((uint64_t **)result + 6), *((_QWORD *)result + 7), *((unsigned __int8 *)result + 64), *((unsigned __int8 *)result + 65), *(unsigned __int16 *)((char *)result + 17) << 26 >> 26);
    case 0x3D:
      return sub_1C5E02754(a2, *((_QWORD *)result + 3), *((unsigned __int8 *)result + 32), *((unsigned __int8 *)result + 33), *(unsigned __int16 *)((char *)result + 17) << 26 >> 26);
    case 0x3E:
      return (unsigned int *)sub_1C5E029D0(a2, 62, *((unsigned __int8 **)result + 3), *((_QWORD *)result + 4), *((_QWORD *)result + 5), *(unsigned __int16 *)((char *)result + 17) << 26 >> 26);
    case 0x3F:
      v40 = (unsigned __int8 *)*((_QWORD *)result + 3);
      v41 = *((_QWORD *)result + 4);
      v42 = a2[2];
      if (v42 >= a2[3])
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v42 + 1, 4);
        LODWORD(v42) = a2[2];
      }
      v43 = *(_QWORD *)a2;
      v44 = 63;
      goto LABEL_417;
    case 0x40:
      v253 = *((_QWORD *)result + 3);
      v254 = (uint64_t *)*((_QWORD *)result + 4);
      v255 = *((_QWORD *)result + 5);
      v256 = *(unsigned __int16 *)((char *)result + 17) << 26 >> 26;
      v257 = a2;
      v258 = 64;
      return sub_1C5E01FCC(v257, v258, v253, v254, v255, v256);
    case 0x41:
      v259 = *((_QWORD *)result + 3);
      v172 = *((_QWORD *)result + 4);
      v171 = (unsigned __int8 *)*((_QWORD *)result + 5);
      v173 = *((_QWORD *)result + 6);
      v167 = *(unsigned __int16 *)((char *)result + 17);
      v260 = a2[2];
      if (v260 >= a2[3])
      {
        v438 = (unsigned __int8 *)*((_QWORD *)result + 5);
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v260 + 1, 4);
        v171 = v438;
        LODWORD(v260) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v260) = 65;
      v261 = a2[3];
      v262 = a2[2] + 1;
      a2[2] = v262;
      if (v262 >= v261)
      {
        v454 = v171;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v262 + 1, 4);
        v171 = v454;
        LODWORD(v262) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v262) = 0;
      v263 = a2[3];
      v264 = a2[2] + 1;
      a2[2] = v264;
      if (v264 >= v263)
      {
        v439 = v171;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v264 + 1, 4);
        v171 = v439;
        LODWORD(v264) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v264) = v259;
      v265 = a2[3];
      v266 = a2[2] + 1;
      a2[2] = v266;
      if (v266 >= v265)
      {
        v455 = v171;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v266 + 1, 4);
        v171 = v455;
        LODWORD(v266) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v266) = HIDWORD(v259);
LABEL_329:
      v267 = a2[3];
      v268 = a2[2] + 1;
      a2[2] = v268;
      if (v268 >= v267)
      {
        v426 = v171;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v268 + 1, 4);
        v171 = v426;
        LODWORD(v268) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v268) = v172;
      v269 = a2[3];
      v270 = a2[2] + 1;
      a2[2] = v270;
      if (v270 >= v269)
      {
        v442 = v171;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v270 + 1, 4);
        v171 = v442;
        LODWORD(v270) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v270) = HIDWORD(v172);
      ++a2[2];
      result = llvm::FoldingSetNodeID::AddString(a2, v171, (int)v173 - (int)v171);
      v271 = a2[2];
      if (v271 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v271 + 1, 4);
        LODWORD(v271) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v271) = v167 << 26 >> 26;
LABEL_336:
      v252 = (_WORD)v167 << 10;
LABEL_337:
      v272 = a2[3];
      v156 = a2[2] + 1;
      a2[2] = v156;
      if (v156 >= v272)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v156 + 1, 4);
        LODWORD(v156) = a2[2];
      }
      v157 = v252 >> 15;
LABEL_340:
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v156) = v157;
      goto LABEL_469;
    case 0x42:
      v273 = *((_QWORD *)result + 3);
      v274 = (uint64_t *)*((_QWORD *)result + 4);
      v275 = *((_QWORD *)result + 5);
      v276 = a2[2];
      if (v276 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v276 + 1, 4);
        LODWORD(v276) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v276) = 66;
      v277 = a2[3];
      v278 = a2[2] + 1;
      a2[2] = v278;
      if (v278 >= v277)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v278 + 1, 4);
        LODWORD(v278) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v278) = 0;
      v279 = a2[3];
      v280 = a2[2] + 1;
      a2[2] = v280;
      if (v280 >= v279)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v280 + 1, 4);
        LODWORD(v280) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v280) = v273;
      v281 = a2[3];
      v282 = a2[2] + 1;
      a2[2] = v282;
      if (v282 >= v281)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v282 + 1, 4);
        LODWORD(v282) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v282) = HIDWORD(v273);
      v283 = a2[3];
      v284 = a2[2] + 1;
      a2[2] = v284;
      if (v284 >= v283)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v284 + 1, 4);
        LODWORD(v284) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v284) = v275;
      v285 = a2[3];
      v286 = a2[2] + 1;
      a2[2] = v286;
      if (v286 >= v285)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v286 + 1, 4);
        LODWORD(v286) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v286) = HIDWORD(v275);
      v287 = a2[2] + 1;
      a2[2] = v287;
      if (v275)
      {
        v288 = 8 * v275;
        do
        {
          v289 = *v274;
          if (v287 >= a2[3])
          {
            result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v287 + 1, 4);
            v287 = a2[2];
          }
          *(_DWORD *)(*(_QWORD *)a2 + 4 * v287) = v289;
          v290 = a2[3];
          v291 = a2[2] + 1;
          a2[2] = v291;
          if (v291 >= v290)
          {
            result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v291 + 1, 4);
            LODWORD(v291) = a2[2];
          }
          *(_DWORD *)(*(_QWORD *)a2 + 4 * v291) = HIDWORD(v289);
          v287 = a2[2] + 1;
          a2[2] = v287;
          ++v274;
          v288 -= 8;
        }
        while (v288);
      }
      return result;
    case 0x43:
      v292 = *((unsigned __int8 *)result + 56);
      v293 = (unsigned __int8 *)*((_QWORD *)result + 5);
      v294 = *((_QWORD *)result + 6);
      v54 = *((_QWORD *)result + 3);
      v15 = *((_QWORD *)result + 4);
      v295 = a2[2];
      if (v295 >= a2[3])
      {
        v440 = (unsigned __int8 *)*((_QWORD *)result + 5);
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v295 + 1, 4);
        v293 = v440;
        LODWORD(v295) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v295) = 67;
      v296 = a2[3];
      v297 = a2[2] + 1;
      a2[2] = v297;
      if (v297 >= v296)
      {
        v456 = v293;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v297 + 1, 4);
        v293 = v456;
        LODWORD(v297) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v297) = 0;
      v298 = a2[3];
      v299 = a2[2] + 1;
      a2[2] = v299;
      if (v299 >= v298)
      {
        v441 = v293;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v299 + 1, 4);
        v293 = v441;
        LODWORD(v299) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v299) = v292;
      v300 = a2[3];
      v301 = a2[2] + 1;
      a2[2] = v301;
      if (v301 >= v300)
      {
        v383 = v293;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v301 + 1, 4);
        v293 = v383;
        LODWORD(v301) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v301) = 0;
      ++a2[2];
      result = llvm::FoldingSetNodeID::AddString(a2, v293, (int)v294 - (int)v293);
      v134 = a2[2];
      v133 = a2[3];
      goto LABEL_181;
    case 0x44:
      v15 = *((_QWORD *)result + 3);
      v31 = a2[2];
      if (v31 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v31 + 1, 4);
        LODWORD(v31) = a2[2];
      }
      v32 = *(_QWORD *)a2;
      v33 = 68;
      goto LABEL_382;
    case 0x45:
      v27 = *((unsigned __int8 *)result + 19);
      v302 = a2[2];
      if (v302 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v302 + 1, 4);
        LODWORD(v302) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v302) = 69;
LABEL_460:
      v347 = a2[3];
      v348 = a2[2] + 1;
      a2[2] = v348;
      if (v348 >= v347)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v348 + 1, 4);
        LODWORD(v348) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v348) = 0;
      goto LABEL_463;
    case 0x46:
      v15 = *((_QWORD *)result + 3);
      v31 = a2[2];
      if (v31 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v31 + 1, 4);
        LODWORD(v31) = a2[2];
      }
      v32 = *(_QWORD *)a2;
      v33 = 70;
      goto LABEL_382;
    case 0x47:
      v15 = *((_QWORD *)result + 3);
      v31 = a2[2];
      if (v31 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v31 + 1, 4);
        LODWORD(v31) = a2[2];
      }
      v32 = *(_QWORD *)a2;
      v33 = 71;
LABEL_382:
      *(_DWORD *)(v32 + 4 * v31) = v33;
LABEL_383:
      v303 = a2[3];
      v304 = a2[2] + 1;
      a2[2] = v304;
      if (v304 >= v303)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v304 + 1, 4);
        LODWORD(v304) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v304) = 0;
      goto LABEL_386;
    case 0x48:
      v8 = *((_QWORD *)result + 3);
      v7 = (unsigned __int8 *)*((_QWORD *)result + 4);
      v9 = *((_QWORD *)result + 5);
      v10 = a2[2];
      if (v10 >= a2[3])
      {
        v366 = (unsigned __int8 *)*((_QWORD *)result + 4);
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v10 + 1, 4);
        v7 = v366;
        LODWORD(v10) = a2[2];
      }
      v11 = *(_QWORD *)a2;
      v12 = 72;
LABEL_396:
      *(_DWORD *)(v11 + 4 * v10) = v12;
      v306 = a2[3];
      v307 = a2[2] + 1;
      a2[2] = v307;
      if (v307 >= v306)
      {
        v373 = v7;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v307 + 1, 4);
        v7 = v373;
        LODWORD(v307) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v307) = 0;
      v308 = a2[3];
      v309 = a2[2] + 1;
      a2[2] = v309;
      if (v309 >= v308)
      {
        v353 = v7;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v309 + 1, 4);
        v7 = v353;
        LODWORD(v309) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v309) = v8;
      v310 = a2[3];
      v311 = a2[2] + 1;
      a2[2] = v311;
      if (v311 >= v310)
      {
        v374 = v7;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v311 + 1, 4);
        v7 = v374;
        LODWORD(v311) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v311) = HIDWORD(v8);
      ++a2[2];
      v312 = v9 - (_DWORD)v7;
      v313 = a2;
      return llvm::FoldingSetNodeID::AddString(v313, v7, v312);
    case 0x49:
      v314 = (unsigned __int8 *)*((_QWORD *)result + 3);
      v315 = *((_QWORD *)result + 4);
      v40 = (unsigned __int8 *)*((_QWORD *)result + 5);
      v41 = *((_QWORD *)result + 6);
      v316 = a2[2];
      if (v316 >= a2[3])
      {
        v367 = (unsigned __int8 *)*((_QWORD *)result + 3);
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v316 + 1, 4);
        v314 = v367;
        LODWORD(v316) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v316) = 73;
      v317 = a2[3];
      v318 = a2[2] + 1;
      a2[2] = v318;
      if (v318 >= v317)
      {
        v384 = v314;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v318 + 1, 4);
        v314 = v384;
        LODWORD(v318) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v318) = 0;
      ++a2[2];
      llvm::FoldingSetNodeID::AddString(a2, v314, v315 - (_DWORD)v314);
      goto LABEL_420;
    case 0x4A:
      v40 = (unsigned __int8 *)*((_QWORD *)result + 3);
      v41 = *((_QWORD *)result + 4);
      v42 = a2[2];
      if (v42 >= a2[3])
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v42 + 1, 4);
        LODWORD(v42) = a2[2];
      }
      v43 = *(_QWORD *)a2;
      v44 = 74;
      goto LABEL_417;
    case 0x4B:
      v40 = (unsigned __int8 *)*((_QWORD *)result + 3);
      v41 = *((_QWORD *)result + 4);
      v42 = a2[2];
      if (v42 >= a2[3])
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v42 + 1, 4);
        LODWORD(v42) = a2[2];
      }
      v43 = *(_QWORD *)a2;
      v44 = 75;
      goto LABEL_417;
    case 0x4C:
      v40 = (unsigned __int8 *)*((_QWORD *)result + 3);
      v41 = *((_QWORD *)result + 4);
      v42 = a2[2];
      if (v42 >= a2[3])
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v42 + 1, 4);
        LODWORD(v42) = a2[2];
      }
      v43 = *(_QWORD *)a2;
      v44 = 76;
LABEL_417:
      *(_DWORD *)(v43 + 4 * v42) = v44;
      v319 = a2[3];
      v320 = a2[2] + 1;
      a2[2] = v320;
      if (v320 >= v319)
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v320 + 1, 4);
        LODWORD(v320) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v320) = 0;
      ++a2[2];
LABEL_420:
      v312 = v41 - (_DWORD)v40;
      v313 = a2;
      v7 = v40;
      return llvm::FoldingSetNodeID::AddString(v313, v7, v312);
    case 0x4D:
      v117 = *((_QWORD *)result + 3);
      v26 = *((_QWORD *)result + 4);
      v27 = *((unsigned __int8 *)result + 40);
      v118 = a2[2];
      if (v118 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v118 + 1, 4);
        LODWORD(v118) = a2[2];
      }
      v119 = *(_QWORD *)a2;
      v120 = 77;
LABEL_425:
      *(_DWORD *)(v119 + 4 * v118) = v120;
      v321 = a2[3];
      v322 = a2[2] + 1;
      a2[2] = v322;
      if (v322 >= v321)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v322 + 1, 4);
        LODWORD(v322) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v322) = 0;
      v323 = a2[3];
      v324 = a2[2] + 1;
      a2[2] = v324;
      if (v324 >= v323)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v324 + 1, 4);
        LODWORD(v324) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v324) = v117;
      v325 = a2[3];
      v326 = a2[2] + 1;
      a2[2] = v326;
      if (v326 >= v325)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v326 + 1, 4);
        LODWORD(v326) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v326) = HIDWORD(v117);
LABEL_432:
      v327 = a2[3];
      v328 = a2[2] + 1;
      a2[2] = v328;
      if (v328 >= v327)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v328 + 1, 4);
        LODWORD(v328) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v328) = v26;
      v329 = a2[3];
      v330 = a2[2] + 1;
      a2[2] = v330;
      if (v330 >= v329)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v330 + 1, 4);
        LODWORD(v330) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v330) = HIDWORD(v26);
LABEL_463:
      v349 = a2[3];
      v350 = a2[2] + 1;
      a2[2] = v350;
      if (v350 >= v349)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v350 + 1, 4);
        LODWORD(v350) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v350) = v27;
LABEL_466:
      v351 = a2[3];
      v352 = a2[2] + 1;
      a2[2] = v352;
      if (v352 >= v351)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v352 + 1, 4);
        LODWORD(v352) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v352) = 0;
      goto LABEL_469;
    case 0x4E:
      v331 = *((_QWORD *)result + 3);
      v54 = *((_QWORD *)result + 4);
      v15 = *((_QWORD *)result + 5);
      v332 = a2[2];
      if (v332 >= a2[3])
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v332 + 1, 4);
        LODWORD(v332) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v332) = 78;
      v333 = a2[3];
      v334 = a2[2] + 1;
      a2[2] = v334;
      if (v334 >= v333)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v334 + 1, 4);
        LODWORD(v334) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v334) = 0;
      v335 = a2[3];
      v336 = a2[2] + 1;
      a2[2] = v336;
      if (v336 >= v335)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v336 + 1, 4);
        LODWORD(v336) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v336) = v331;
      v337 = a2[3];
      v338 = a2[2] + 1;
      a2[2] = v338;
      if (v338 >= v337)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v338 + 1, 4);
        LODWORD(v338) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v338) = HIDWORD(v331);
LABEL_180:
      v133 = a2[3];
      v134 = a2[2] + 1;
      a2[2] = v134;
LABEL_181:
      if (v134 >= v133)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v134 + 1, 4);
        LODWORD(v134) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v134) = v54;
      v135 = a2[3];
      v136 = a2[2] + 1;
      a2[2] = v136;
      if (v136 >= v135)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v136 + 1, 4);
        LODWORD(v136) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v136) = HIDWORD(v54);
LABEL_386:
      v25 = a2[3];
      v24 = a2[2] + 1;
      a2[2] = v24;
LABEL_387:
      if (v24 >= v25)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v24 + 1, 4);
        LODWORD(v24) = a2[2];
      }
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v24) = v15;
      v305 = a2[3];
      v115 = a2[2] + 1;
      a2[2] = v115;
      if (v115 >= v305)
      {
        result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, (uint64_t)(a2 + 4), v115 + 1, 4);
        LODWORD(v115) = a2[2];
      }
      v116 = HIDWORD(v15);
LABEL_392:
      *(_DWORD *)(*(_QWORD *)a2 + 4 * v115) = v116;
LABEL_469:
      ++a2[2];
      break;
    default:
      return result;
  }
  return result;
}

_DWORD *sub_1C5E0169C(_DWORD *result, int a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;

  v7 = (uint64_t)result;
  v8 = result[2];
  if (v8 >= result[3])
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)result, (uint64_t)(result + 4), v8 + 1, 4);
    LODWORD(v8) = *(_DWORD *)(v7 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v7 + 4 * v8) = a2;
  v9 = *(_DWORD *)(v7 + 12);
  v10 = (*(_DWORD *)(v7 + 8) + 1);
  *(_DWORD *)(v7 + 8) = v10;
  if (v10 >= v9)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v7, v7 + 16, v10 + 1, 4);
    LODWORD(v10) = *(_DWORD *)(v7 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v7 + 4 * v10) = 0;
  v11 = *(_DWORD *)(v7 + 12);
  v12 = (*(_DWORD *)(v7 + 8) + 1);
  *(_DWORD *)(v7 + 8) = v12;
  if (v12 >= v11)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v7, v7 + 16, v12 + 1, 4);
    LODWORD(v12) = *(_DWORD *)(v7 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v7 + 4 * v12) = a4;
  v13 = *(_DWORD *)(v7 + 12);
  v14 = (*(_DWORD *)(v7 + 8) + 1);
  *(_DWORD *)(v7 + 8) = v14;
  if (v14 >= v13)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v7, v7 + 16, v14 + 1, 4);
    LODWORD(v14) = *(_DWORD *)(v7 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v7 + 4 * v14) = HIDWORD(a4);
  v15 = *(_DWORD *)(v7 + 8) + 1;
  *(_DWORD *)(v7 + 8) = v15;
  if (a4)
  {
    v16 = 8 * a4;
    do
    {
      v17 = *a3;
      if (v15 >= *(_DWORD *)(v7 + 12))
      {
        result = llvm::SmallVectorBase<unsigned int>::grow_pod(v7, v7 + 16, v15 + 1, 4);
        v15 = *(_DWORD *)(v7 + 8);
      }
      *(_DWORD *)(*(_QWORD *)v7 + 4 * v15) = v17;
      v18 = *(_DWORD *)(v7 + 12);
      v19 = (*(_DWORD *)(v7 + 8) + 1);
      *(_DWORD *)(v7 + 8) = v19;
      if (v19 >= v18)
      {
        result = llvm::SmallVectorBase<unsigned int>::grow_pod(v7, v7 + 16, v19 + 1, 4);
        LODWORD(v19) = *(_DWORD *)(v7 + 8);
      }
      *(_DWORD *)(*(_QWORD *)v7 + 4 * v19) = HIDWORD(v17);
      v15 = *(_DWORD *)(v7 + 8) + 1;
      *(_DWORD *)(v7 + 8) = v15;
      ++a3;
      v16 -= 8;
    }
    while (v16);
  }
  return result;
}

_DWORD *sub_1C5E01858(_DWORD *result, int a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  int v25;

  v8 = (uint64_t)result;
  v9 = result[2];
  if (v9 >= result[3])
  {
    v25 = a2;
    result = llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)result, (uint64_t)(result + 4), v9 + 1, 4);
    a2 = v25;
    LODWORD(v9) = *(_DWORD *)(v8 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v8 + 4 * v9) = a2;
  v10 = *(_DWORD *)(v8 + 12);
  v11 = (*(_DWORD *)(v8 + 8) + 1);
  *(_DWORD *)(v8 + 8) = v11;
  if (v11 >= v10)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v8, v8 + 16, v11 + 1, 4);
    LODWORD(v11) = *(_DWORD *)(v8 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v8 + 4 * v11) = 0;
  v12 = *(_DWORD *)(v8 + 12);
  v13 = (*(_DWORD *)(v8 + 8) + 1);
  *(_DWORD *)(v8 + 8) = v13;
  if (v13 >= v12)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v8, v8 + 16, v13 + 1, 4);
    LODWORD(v13) = *(_DWORD *)(v8 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v8 + 4 * v13) = a3;
  v14 = *(_DWORD *)(v8 + 12);
  v15 = (*(_DWORD *)(v8 + 8) + 1);
  *(_DWORD *)(v8 + 8) = v15;
  if (v15 >= v14)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v8, v8 + 16, v15 + 1, 4);
    LODWORD(v15) = *(_DWORD *)(v8 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v8 + 4 * v15) = HIDWORD(a3);
  v16 = *(_DWORD *)(v8 + 12);
  v17 = (*(_DWORD *)(v8 + 8) + 1);
  *(_DWORD *)(v8 + 8) = v17;
  if (v17 >= v16)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v8, v8 + 16, v17 + 1, 4);
    LODWORD(v17) = *(_DWORD *)(v8 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v8 + 4 * v17) = a5;
  v18 = *(_DWORD *)(v8 + 12);
  v19 = (*(_DWORD *)(v8 + 8) + 1);
  *(_DWORD *)(v8 + 8) = v19;
  if (v19 >= v18)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v8, v8 + 16, v19 + 1, 4);
    LODWORD(v19) = *(_DWORD *)(v8 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v8 + 4 * v19) = HIDWORD(a5);
  v20 = *(_DWORD *)(v8 + 8) + 1;
  *(_DWORD *)(v8 + 8) = v20;
  if (a5)
  {
    v21 = 8 * a5;
    do
    {
      v22 = *a4;
      if (v20 >= *(_DWORD *)(v8 + 12))
      {
        result = llvm::SmallVectorBase<unsigned int>::grow_pod(v8, v8 + 16, v20 + 1, 4);
        v20 = *(_DWORD *)(v8 + 8);
      }
      *(_DWORD *)(*(_QWORD *)v8 + 4 * v20) = v22;
      v23 = *(_DWORD *)(v8 + 12);
      v24 = (*(_DWORD *)(v8 + 8) + 1);
      *(_DWORD *)(v8 + 8) = v24;
      if (v24 >= v23)
      {
        result = llvm::SmallVectorBase<unsigned int>::grow_pod(v8, v8 + 16, v24 + 1, 4);
        LODWORD(v24) = *(_DWORD *)(v8 + 8);
      }
      *(_DWORD *)(*(_QWORD *)v8 + 4 * v24) = HIDWORD(v22);
      v20 = *(_DWORD *)(v8 + 8) + 1;
      *(_DWORD *)(v8 + 8) = v20;
      ++a4;
      v21 -= 8;
    }
    while (v21);
  }
  return result;
}

unsigned int *sub_1C5E01A94(unsigned int *a1, uint64_t *a2, uint64_t a3, uint64_t *a4, uint64_t a5, unsigned __int8 *a6, int a7)
{
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;

  v14 = a1[2];
  if (v14 >= a1[3])
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, (uint64_t)(a1 + 4), v14 + 1, 4);
    LODWORD(v14) = a1[2];
  }
  *(_DWORD *)(*(_QWORD *)a1 + 4 * v14) = 48;
  v15 = a1[3];
  v16 = a1[2] + 1;
  a1[2] = v16;
  if (v16 >= v15)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, (uint64_t)(a1 + 4), v16 + 1, 4);
    LODWORD(v16) = a1[2];
  }
  *(_DWORD *)(*(_QWORD *)a1 + 4 * v16) = 0;
  v17 = a1[3];
  v18 = a1[2] + 1;
  a1[2] = v18;
  if (v18 >= v17)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, (uint64_t)(a1 + 4), v18 + 1, 4);
    LODWORD(v18) = a1[2];
  }
  *(_DWORD *)(*(_QWORD *)a1 + 4 * v18) = a3;
  v19 = a1[3];
  v20 = a1[2] + 1;
  a1[2] = v20;
  if (v20 >= v19)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, (uint64_t)(a1 + 4), v20 + 1, 4);
    LODWORD(v20) = a1[2];
  }
  *(_DWORD *)(*(_QWORD *)a1 + 4 * v20) = HIDWORD(a3);
  v21 = a1[2] + 1;
  a1[2] = v21;
  if (a3)
  {
    v22 = 8 * a3;
    do
    {
      v23 = *a2;
      if (v21 >= a1[3])
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, (uint64_t)(a1 + 4), v21 + 1, 4);
        v21 = a1[2];
      }
      *(_DWORD *)(*(_QWORD *)a1 + 4 * v21) = v23;
      v24 = a1[3];
      v25 = a1[2] + 1;
      a1[2] = v25;
      if (v25 >= v24)
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, (uint64_t)(a1 + 4), v25 + 1, 4);
        LODWORD(v25) = a1[2];
      }
      *(_DWORD *)(*(_QWORD *)a1 + 4 * v25) = HIDWORD(v23);
      v21 = a1[2] + 1;
      a1[2] = v21;
      ++a2;
      v22 -= 8;
    }
    while (v22);
  }
  if (v21 >= a1[3])
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, (uint64_t)(a1 + 4), v21 + 1, 4);
    v21 = a1[2];
  }
  *(_DWORD *)(*(_QWORD *)a1 + 4 * v21) = a5;
  v26 = a1[3];
  v27 = a1[2] + 1;
  a1[2] = v27;
  if (v27 >= v26)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, (uint64_t)(a1 + 4), v27 + 1, 4);
    LODWORD(v27) = a1[2];
  }
  *(_DWORD *)(*(_QWORD *)a1 + 4 * v27) = HIDWORD(a5);
  v28 = a1[2] + 1;
  a1[2] = v28;
  if (a5)
  {
    v29 = 8 * a5;
    do
    {
      v30 = *a4;
      if (v28 >= a1[3])
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, (uint64_t)(a1 + 4), v28 + 1, 4);
        v28 = a1[2];
      }
      *(_DWORD *)(*(_QWORD *)a1 + 4 * v28) = v30;
      v31 = a1[3];
      v32 = a1[2] + 1;
      a1[2] = v32;
      if (v32 >= v31)
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, (uint64_t)(a1 + 4), v32 + 1, 4);
        LODWORD(v32) = a1[2];
      }
      *(_DWORD *)(*(_QWORD *)a1 + 4 * v32) = HIDWORD(v30);
      v28 = a1[2] + 1;
      a1[2] = v28;
      ++a4;
      v29 -= 8;
    }
    while (v29);
  }
  return llvm::FoldingSetNodeID::AddString(a1, a6, a7 - (int)a6);
}

void *sub_1C5E01D94(unsigned int *a1, int a2, uint64_t a3, unsigned __int8 *a4, int a5, uint64_t a6, int a7)
{
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  void *result;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t v27;
  int v28;

  v13 = a1[2];
  if (v13 >= a1[3])
  {
    v28 = a2;
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, (uint64_t)(a1 + 4), v13 + 1, 4);
    a2 = v28;
    LODWORD(v13) = a1[2];
  }
  *(_DWORD *)(*(_QWORD *)a1 + 4 * v13) = a2;
  v14 = a1[3];
  v15 = a1[2] + 1;
  a1[2] = v15;
  if (v15 >= v14)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, (uint64_t)(a1 + 4), v15 + 1, 4);
    LODWORD(v15) = a1[2];
  }
  *(_DWORD *)(*(_QWORD *)a1 + 4 * v15) = 0;
  v16 = a1[3];
  v17 = a1[2] + 1;
  a1[2] = v17;
  if (v17 >= v16)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, (uint64_t)(a1 + 4), v17 + 1, 4);
    LODWORD(v17) = a1[2];
  }
  *(_DWORD *)(*(_QWORD *)a1 + 4 * v17) = a3;
  v18 = a1[3];
  v19 = a1[2] + 1;
  a1[2] = v19;
  if (v19 >= v18)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, (uint64_t)(a1 + 4), v19 + 1, 4);
    LODWORD(v19) = a1[2];
  }
  *(_DWORD *)(*(_QWORD *)a1 + 4 * v19) = HIDWORD(a3);
  ++a1[2];
  result = llvm::FoldingSetNodeID::AddString(a1, a4, a5 - (int)a4);
  v21 = a1[2];
  if (v21 >= a1[3])
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, (uint64_t)(a1 + 4), v21 + 1, 4);
    LODWORD(v21) = a1[2];
  }
  *(_DWORD *)(*(_QWORD *)a1 + 4 * v21) = a6;
  v22 = a1[3];
  v23 = a1[2] + 1;
  a1[2] = v23;
  if (v23 >= v22)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, (uint64_t)(a1 + 4), v23 + 1, 4);
    LODWORD(v23) = a1[2];
  }
  *(_DWORD *)(*(_QWORD *)a1 + 4 * v23) = HIDWORD(a6);
  v24 = a1[3];
  v25 = a1[2] + 1;
  a1[2] = v25;
  if (v25 >= v24)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, (uint64_t)(a1 + 4), v25 + 1, 4);
    LODWORD(v25) = a1[2];
  }
  *(_DWORD *)(*(_QWORD *)a1 + 4 * v25) = a7;
  v26 = a1[3];
  v27 = a1[2] + 1;
  a1[2] = v27;
  if (v27 >= v26)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, (uint64_t)(a1 + 4), v27 + 1, 4);
    LODWORD(v27) = a1[2];
  }
  *(_DWORD *)(*(_QWORD *)a1 + 4 * v27) = a7 >> 31;
  ++a1[2];
  return result;
}

_DWORD *sub_1C5E01FCC(_DWORD *result, int a2, uint64_t a3, uint64_t *a4, uint64_t a5, int a6)
{
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  int v29;

  v10 = (uint64_t)result;
  v11 = result[2];
  if (v11 >= result[3])
  {
    v29 = a2;
    result = llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)result, (uint64_t)(result + 4), v11 + 1, 4);
    a2 = v29;
    LODWORD(v11) = *(_DWORD *)(v10 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v10 + 4 * v11) = a2;
  v12 = *(_DWORD *)(v10 + 12);
  v13 = (*(_DWORD *)(v10 + 8) + 1);
  *(_DWORD *)(v10 + 8) = v13;
  if (v13 >= v12)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v10, v10 + 16, v13 + 1, 4);
    LODWORD(v13) = *(_DWORD *)(v10 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v10 + 4 * v13) = 0;
  v14 = *(_DWORD *)(v10 + 12);
  v15 = (*(_DWORD *)(v10 + 8) + 1);
  *(_DWORD *)(v10 + 8) = v15;
  if (v15 >= v14)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v10, v10 + 16, v15 + 1, 4);
    LODWORD(v15) = *(_DWORD *)(v10 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v10 + 4 * v15) = a3;
  v16 = *(_DWORD *)(v10 + 12);
  v17 = (*(_DWORD *)(v10 + 8) + 1);
  *(_DWORD *)(v10 + 8) = v17;
  if (v17 >= v16)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v10, v10 + 16, v17 + 1, 4);
    LODWORD(v17) = *(_DWORD *)(v10 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v10 + 4 * v17) = HIDWORD(a3);
  v18 = *(_DWORD *)(v10 + 12);
  v19 = (*(_DWORD *)(v10 + 8) + 1);
  *(_DWORD *)(v10 + 8) = v19;
  if (v19 >= v18)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v10, v10 + 16, v19 + 1, 4);
    LODWORD(v19) = *(_DWORD *)(v10 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v10 + 4 * v19) = a5;
  v20 = *(_DWORD *)(v10 + 12);
  v21 = (*(_DWORD *)(v10 + 8) + 1);
  *(_DWORD *)(v10 + 8) = v21;
  if (v21 >= v20)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v10, v10 + 16, v21 + 1, 4);
    LODWORD(v21) = *(_DWORD *)(v10 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v10 + 4 * v21) = HIDWORD(a5);
  v22 = *(_DWORD *)(v10 + 8) + 1;
  *(_DWORD *)(v10 + 8) = v22;
  if (a5)
  {
    v23 = 8 * a5;
    do
    {
      v24 = *a4;
      if (v22 >= *(_DWORD *)(v10 + 12))
      {
        result = llvm::SmallVectorBase<unsigned int>::grow_pod(v10, v10 + 16, v22 + 1, 4);
        v22 = *(_DWORD *)(v10 + 8);
      }
      *(_DWORD *)(*(_QWORD *)v10 + 4 * v22) = v24;
      v25 = *(_DWORD *)(v10 + 12);
      v26 = (*(_DWORD *)(v10 + 8) + 1);
      *(_DWORD *)(v10 + 8) = v26;
      if (v26 >= v25)
      {
        result = llvm::SmallVectorBase<unsigned int>::grow_pod(v10, v10 + 16, v26 + 1, 4);
        LODWORD(v26) = *(_DWORD *)(v10 + 8);
      }
      *(_DWORD *)(*(_QWORD *)v10 + 4 * v26) = HIDWORD(v24);
      v22 = *(_DWORD *)(v10 + 8) + 1;
      *(_DWORD *)(v10 + 8) = v22;
      ++a4;
      v23 -= 8;
    }
    while (v23);
  }
  if (v22 >= *(_DWORD *)(v10 + 12))
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v10, v10 + 16, v22 + 1, 4);
    v22 = *(_DWORD *)(v10 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v10 + 4 * v22) = a6;
  v27 = *(_DWORD *)(v10 + 12);
  v28 = (*(_DWORD *)(v10 + 8) + 1);
  *(_DWORD *)(v10 + 8) = v28;
  if (v28 >= v27)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v10, v10 + 16, v28 + 1, 4);
    LODWORD(v28) = *(_DWORD *)(v10 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v10 + 4 * v28) = a6 >> 31;
  ++*(_DWORD *)(v10 + 8);
  return result;
}

_DWORD *sub_1C5E02288(_DWORD *result, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, int a7, int a8, int a9)
{
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  unsigned int v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  unsigned int v33;
  uint64_t v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  uint64_t v39;
  unsigned int v40;
  uint64_t v41;
  unsigned int v42;
  uint64_t v43;
  unsigned int v44;
  uint64_t v45;
  unsigned int v46;
  uint64_t v47;
  unsigned int v48;
  uint64_t v49;

  v16 = (uint64_t)result;
  v17 = result[2];
  if (v17 >= result[3])
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)result, (uint64_t)(result + 4), v17 + 1, 4);
    LODWORD(v17) = *(_DWORD *)(v16 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v16 + 4 * v17) = 60;
  v18 = *(_DWORD *)(v16 + 12);
  v19 = (*(_DWORD *)(v16 + 8) + 1);
  *(_DWORD *)(v16 + 8) = v19;
  if (v19 >= v18)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v16, v16 + 16, v19 + 1, 4);
    LODWORD(v19) = *(_DWORD *)(v16 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v16 + 4 * v19) = 0;
  v20 = *(_DWORD *)(v16 + 12);
  v21 = (*(_DWORD *)(v16 + 8) + 1);
  *(_DWORD *)(v16 + 8) = v21;
  if (v21 >= v20)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v16, v16 + 16, v21 + 1, 4);
    LODWORD(v21) = *(_DWORD *)(v16 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v16 + 4 * v21) = a3;
  v22 = *(_DWORD *)(v16 + 12);
  v23 = (*(_DWORD *)(v16 + 8) + 1);
  *(_DWORD *)(v16 + 8) = v23;
  if (v23 >= v22)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v16, v16 + 16, v23 + 1, 4);
    LODWORD(v23) = *(_DWORD *)(v16 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v16 + 4 * v23) = HIDWORD(a3);
  v24 = *(_DWORD *)(v16 + 8) + 1;
  *(_DWORD *)(v16 + 8) = v24;
  if (a3)
  {
    v25 = 8 * a3;
    do
    {
      v26 = *a2;
      if (v24 >= *(_DWORD *)(v16 + 12))
      {
        result = llvm::SmallVectorBase<unsigned int>::grow_pod(v16, v16 + 16, v24 + 1, 4);
        v24 = *(_DWORD *)(v16 + 8);
      }
      *(_DWORD *)(*(_QWORD *)v16 + 4 * v24) = v26;
      v27 = *(_DWORD *)(v16 + 12);
      v28 = (*(_DWORD *)(v16 + 8) + 1);
      *(_DWORD *)(v16 + 8) = v28;
      if (v28 >= v27)
      {
        result = llvm::SmallVectorBase<unsigned int>::grow_pod(v16, v16 + 16, v28 + 1, 4);
        LODWORD(v28) = *(_DWORD *)(v16 + 8);
      }
      *(_DWORD *)(*(_QWORD *)v16 + 4 * v28) = HIDWORD(v26);
      v24 = *(_DWORD *)(v16 + 8) + 1;
      *(_DWORD *)(v16 + 8) = v24;
      ++a2;
      v25 -= 8;
    }
    while (v25);
  }
  if (v24 >= *(_DWORD *)(v16 + 12))
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v16, v16 + 16, v24 + 1, 4);
    v24 = *(_DWORD *)(v16 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v16 + 4 * v24) = a4;
  v29 = *(_DWORD *)(v16 + 12);
  v30 = (*(_DWORD *)(v16 + 8) + 1);
  *(_DWORD *)(v16 + 8) = v30;
  if (v30 >= v29)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v16, v16 + 16, v30 + 1, 4);
    LODWORD(v30) = *(_DWORD *)(v16 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v16 + 4 * v30) = HIDWORD(a4);
  v31 = *(_DWORD *)(v16 + 12);
  v32 = (*(_DWORD *)(v16 + 8) + 1);
  *(_DWORD *)(v16 + 8) = v32;
  if (v32 >= v31)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v16, v16 + 16, v32 + 1, 4);
    LODWORD(v32) = *(_DWORD *)(v16 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v16 + 4 * v32) = a6;
  v33 = *(_DWORD *)(v16 + 12);
  v34 = (*(_DWORD *)(v16 + 8) + 1);
  *(_DWORD *)(v16 + 8) = v34;
  if (v34 >= v33)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v16, v16 + 16, v34 + 1, 4);
    LODWORD(v34) = *(_DWORD *)(v16 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v16 + 4 * v34) = HIDWORD(a6);
  v35 = *(_DWORD *)(v16 + 8) + 1;
  *(_DWORD *)(v16 + 8) = v35;
  if (a6)
  {
    v36 = 8 * a6;
    do
    {
      v37 = *a5;
      if (v35 >= *(_DWORD *)(v16 + 12))
      {
        result = llvm::SmallVectorBase<unsigned int>::grow_pod(v16, v16 + 16, v35 + 1, 4);
        v35 = *(_DWORD *)(v16 + 8);
      }
      *(_DWORD *)(*(_QWORD *)v16 + 4 * v35) = v37;
      v38 = *(_DWORD *)(v16 + 12);
      v39 = (*(_DWORD *)(v16 + 8) + 1);
      *(_DWORD *)(v16 + 8) = v39;
      if (v39 >= v38)
      {
        result = llvm::SmallVectorBase<unsigned int>::grow_pod(v16, v16 + 16, v39 + 1, 4);
        LODWORD(v39) = *(_DWORD *)(v16 + 8);
      }
      *(_DWORD *)(*(_QWORD *)v16 + 4 * v39) = HIDWORD(v37);
      v35 = *(_DWORD *)(v16 + 8) + 1;
      *(_DWORD *)(v16 + 8) = v35;
      ++a5;
      v36 -= 8;
    }
    while (v36);
  }
  if (v35 >= *(_DWORD *)(v16 + 12))
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v16, v16 + 16, v35 + 1, 4);
    v35 = *(_DWORD *)(v16 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v16 + 4 * v35) = a7;
  v40 = *(_DWORD *)(v16 + 12);
  v41 = (*(_DWORD *)(v16 + 8) + 1);
  *(_DWORD *)(v16 + 8) = v41;
  if (v41 >= v40)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v16, v16 + 16, v41 + 1, 4);
    LODWORD(v41) = *(_DWORD *)(v16 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v16 + 4 * v41) = 0;
  v42 = *(_DWORD *)(v16 + 12);
  v43 = (*(_DWORD *)(v16 + 8) + 1);
  *(_DWORD *)(v16 + 8) = v43;
  if (v43 >= v42)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v16, v16 + 16, v43 + 1, 4);
    LODWORD(v43) = *(_DWORD *)(v16 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v16 + 4 * v43) = a8;
  v44 = *(_DWORD *)(v16 + 12);
  v45 = (*(_DWORD *)(v16 + 8) + 1);
  *(_DWORD *)(v16 + 8) = v45;
  if (v45 >= v44)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v16, v16 + 16, v45 + 1, 4);
    LODWORD(v45) = *(_DWORD *)(v16 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v16 + 4 * v45) = 0;
  v46 = *(_DWORD *)(v16 + 12);
  v47 = (*(_DWORD *)(v16 + 8) + 1);
  *(_DWORD *)(v16 + 8) = v47;
  if (v47 >= v46)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v16, v16 + 16, v47 + 1, 4);
    LODWORD(v47) = *(_DWORD *)(v16 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v16 + 4 * v47) = a9;
  v48 = *(_DWORD *)(v16 + 12);
  v49 = (*(_DWORD *)(v16 + 8) + 1);
  *(_DWORD *)(v16 + 8) = v49;
  if (v49 >= v48)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v16, v16 + 16, v49 + 1, 4);
    LODWORD(v49) = *(_DWORD *)(v16 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v16 + 4 * v49) = a9 >> 31;
  ++*(_DWORD *)(v16 + 8);
  return result;
}

_DWORD *sub_1C5E02754(_DWORD *result, uint64_t a2, int a3, int a4, int a5)
{
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;

  v9 = (uint64_t)result;
  v10 = result[2];
  if (v10 >= result[3])
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)result, (uint64_t)(result + 4), v10 + 1, 4);
    LODWORD(v10) = *(_DWORD *)(v9 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v9 + 4 * v10) = 61;
  v11 = *(_DWORD *)(v9 + 12);
  v12 = (*(_DWORD *)(v9 + 8) + 1);
  *(_DWORD *)(v9 + 8) = v12;
  if (v12 >= v11)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v9, v9 + 16, v12 + 1, 4);
    LODWORD(v12) = *(_DWORD *)(v9 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v9 + 4 * v12) = 0;
  v13 = *(_DWORD *)(v9 + 12);
  v14 = (*(_DWORD *)(v9 + 8) + 1);
  *(_DWORD *)(v9 + 8) = v14;
  if (v14 >= v13)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v9, v9 + 16, v14 + 1, 4);
    LODWORD(v14) = *(_DWORD *)(v9 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v9 + 4 * v14) = a2;
  v15 = *(_DWORD *)(v9 + 12);
  v16 = (*(_DWORD *)(v9 + 8) + 1);
  *(_DWORD *)(v9 + 8) = v16;
  if (v16 >= v15)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v9, v9 + 16, v16 + 1, 4);
    LODWORD(v16) = *(_DWORD *)(v9 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v9 + 4 * v16) = HIDWORD(a2);
  v17 = *(_DWORD *)(v9 + 12);
  v18 = (*(_DWORD *)(v9 + 8) + 1);
  *(_DWORD *)(v9 + 8) = v18;
  if (v18 >= v17)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v9, v9 + 16, v18 + 1, 4);
    LODWORD(v18) = *(_DWORD *)(v9 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v9 + 4 * v18) = a3;
  v19 = *(_DWORD *)(v9 + 12);
  v20 = (*(_DWORD *)(v9 + 8) + 1);
  *(_DWORD *)(v9 + 8) = v20;
  if (v20 >= v19)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v9, v9 + 16, v20 + 1, 4);
    LODWORD(v20) = *(_DWORD *)(v9 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v9 + 4 * v20) = 0;
  v21 = *(_DWORD *)(v9 + 12);
  v22 = (*(_DWORD *)(v9 + 8) + 1);
  *(_DWORD *)(v9 + 8) = v22;
  if (v22 >= v21)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v9, v9 + 16, v22 + 1, 4);
    LODWORD(v22) = *(_DWORD *)(v9 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v9 + 4 * v22) = a4;
  v23 = *(_DWORD *)(v9 + 12);
  v24 = (*(_DWORD *)(v9 + 8) + 1);
  *(_DWORD *)(v9 + 8) = v24;
  if (v24 >= v23)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v9, v9 + 16, v24 + 1, 4);
    LODWORD(v24) = *(_DWORD *)(v9 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v9 + 4 * v24) = 0;
  v25 = *(_DWORD *)(v9 + 12);
  v26 = (*(_DWORD *)(v9 + 8) + 1);
  *(_DWORD *)(v9 + 8) = v26;
  if (v26 >= v25)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v9, v9 + 16, v26 + 1, 4);
    LODWORD(v26) = *(_DWORD *)(v9 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v9 + 4 * v26) = a5;
  v27 = *(_DWORD *)(v9 + 12);
  v28 = (*(_DWORD *)(v9 + 8) + 1);
  *(_DWORD *)(v9 + 8) = v28;
  if (v28 >= v27)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v9, v9 + 16, v28 + 1, 4);
    LODWORD(v28) = *(_DWORD *)(v9 + 8);
  }
  *(_DWORD *)(*(_QWORD *)v9 + 4 * v28) = a5 >> 31;
  ++*(_DWORD *)(v9 + 8);
  return result;
}

void *sub_1C5E029D0(unsigned int *a1, int a2, unsigned __int8 *a3, int a4, uint64_t a5, int a6)
{
  unsigned __int8 *v8;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  void *result;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  int v21;
  int v22;
  int v23;
  unsigned __int8 *v25;

  v8 = a3;
  v10 = a1[2];
  if (v10 >= a1[3])
  {
    v21 = a2;
    v22 = a4;
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, (uint64_t)(a1 + 4), v10 + 1, 4);
    a2 = v21;
    a4 = v22;
    v8 = a3;
    LODWORD(v10) = a1[2];
  }
  *(_DWORD *)(*(_QWORD *)a1 + 4 * v10) = a2;
  v11 = a1[3];
  v12 = a1[2] + 1;
  a1[2] = v12;
  if (v12 >= v11)
  {
    v23 = a4;
    v25 = v8;
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, (uint64_t)(a1 + 4), v12 + 1, 4);
    a4 = v23;
    v8 = v25;
    LODWORD(v12) = a1[2];
  }
  *(_DWORD *)(*(_QWORD *)a1 + 4 * v12) = 0;
  ++a1[2];
  result = llvm::FoldingSetNodeID::AddString(a1, v8, a4 - (int)v8);
  v14 = a1[2];
  if (v14 >= a1[3])
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, (uint64_t)(a1 + 4), v14 + 1, 4);
    LODWORD(v14) = a1[2];
  }
  *(_DWORD *)(*(_QWORD *)a1 + 4 * v14) = a5;
  v15 = a1[3];
  v16 = a1[2] + 1;
  a1[2] = v16;
  if (v16 >= v15)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, (uint64_t)(a1 + 4), v16 + 1, 4);
    LODWORD(v16) = a1[2];
  }
  *(_DWORD *)(*(_QWORD *)a1 + 4 * v16) = HIDWORD(a5);
  v17 = a1[3];
  v18 = a1[2] + 1;
  a1[2] = v18;
  if (v18 >= v17)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, (uint64_t)(a1 + 4), v18 + 1, 4);
    LODWORD(v18) = a1[2];
  }
  *(_DWORD *)(*(_QWORD *)a1 + 4 * v18) = a6;
  v19 = a1[3];
  v20 = a1[2] + 1;
  a1[2] = v20;
  if (v20 >= v19)
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, (uint64_t)(a1 + 4), v20 + 1, 4);
    LODWORD(v20) = a1[2];
  }
  *(_DWORD *)(*(_QWORD *)a1 + 4 * v20) = a6 >> 31;
  ++a1[2];
  return result;
}

uint64_t sub_1C5E02B94(uint64_t a1)
{
  int v2;
  const char *v3;
  const char *v4;
  uint64_t v5;
  const char *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  const char *v25;
  uint64_t v26;
  int v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int *v31;
  BOOL v32;
  BOOL v33;
  uint64_t v34;
  const void *v35;
  uint64_t *v36;
  uint64_t *v37;
  int64_t v38;
  uint64_t v39;
  int v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unsigned int *v44;
  BOOL v45;
  BOOL v46;
  _BYTE *v47;
  _BYTE *v48;
  uint64_t *v49;
  uint64_t *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unsigned int *v66;
  BOOL v67;
  int v68;
  uint64_t v69;
  int v70;
  unint64_t v71;
  unsigned int v72;
  int v73;
  uint64_t v74;
  int v75;
  uint64_t v76;
  unsigned int *v77;
  unint64_t v78;
  unsigned int v79;
  int v80;
  uint64_t v81;
  void *v82;
  int v84;
  uint64_t v85;
  unint64_t v86;
  unsigned int v87;
  int v88;
  uint64_t v89;
  int v90;
  int v91;
  void *v92;
  __int128 v93;
  uint64_t v94;
  uint64_t v95[14];
  void *v96;
  uint64_t v97;
  _QWORD v98[18];

  v98[16] = *MEMORY[0x1E0C80C00];
  v2 = sub_1C54C4768(a1);
  v3 = *(const char **)a1;
  v4 = *(const char **)(a1 + 8);
  if ((unint64_t)&v4[-*(_QWORD *)a1] < 2)
    goto LABEL_2;
  if (!strncmp("Do", *(const char **)a1, 2uLL))
  {
    *(_QWORD *)a1 = v3 + 2;
    v5 = sub_1C5DF9BE8(a1, "noexcept");
    if (v5)
      goto LABEL_3;
    return 0;
  }
  if (!strncmp("DO", v3, 2uLL))
  {
    *(_QWORD *)a1 = v3 + 2;
    v24 = sub_1C5E042EC(a1);
    if (!v24)
      return 0;
    v25 = *(const char **)a1;
    if (*(_QWORD *)a1 == *(_QWORD *)(a1 + 8) || *v25 != 69)
      return 0;
    v26 = v24;
    *(_QWORD *)a1 = v25 + 1;
    v27 = *(unsigned __int8 *)(a1 + 937);
    v92 = (char *)&v93 + 8;
    v94 = v24;
    v93 = xmmword_1C866FA10;
    v28 = sub_1C4F5AB38((_QWORD *)&v93 + 1, (uint64_t)v95);
    v30 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v28);
    v31 = *(unsigned int **)v30;
    v96 = v98;
    v97 = 0x2000000000;
    if (v31)
      v32 = (v31 & 1) == 0;
    else
      v32 = 0;
    if (!v32)
      goto LABEL_154;
    while (1)
    {
      LOBYTE(v28) = sub_1C5DFE6F4(v28, v31, (uint64_t)&v92, v29, (unsigned int *)&v96);
      if ((v28 & 1) != 0)
        break;
      LODWORD(v97) = 0;
      v31 = *(unsigned int **)v31;
      if (v31)
        v33 = (v31 & 1) == 0;
      else
        v33 = 0;
      if (!v33)
      {
        v31 = 0;
        goto LABEL_105;
      }
    }
    v30 = 0;
LABEL_105:
    if (v96 == v98)
    {
      if (v31)
      {
LABEL_107:
        v70 = 0;
        v5 = (uint64_t)(v31 + 2);
        goto LABEL_161;
      }
    }
    else
    {
      free(v96);
      if (v31)
        goto LABEL_107;
    }
LABEL_154:
    if (v27)
    {
      v86 = sub_1C484358C(a1 + 808, 32, 3);
      *(_QWORD *)v86 = 0;
      *(_QWORD *)(v86 + 8) = &unk_1E816C188;
      v5 = v86 + 8;
      *(_BYTE *)(v86 + 16) = 16;
      *(_WORD *)(v86 + 17) = *(_WORD *)(v86 + 17) & 0xF000 | 0x540;
      *(_QWORD *)(v86 + 24) = v26;
      v87 = *(_DWORD *)(a1 + 916) + 1;
      v88 = *(_DWORD *)(a1 + 912);
      if (v87 > 2 * v88)
      {
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v88, (uint64_t)off_1E81A1260);
        v96 = v98;
        v97 = 0x2000000000;
        sub_1C5DFE788((unsigned int *)v86, (unsigned int *)&v96);
        v30 = *(_QWORD *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v96, (uint64_t)v96 + 4 * v97));
        if (v96 != v98)
          free(v96);
        v87 = *(_DWORD *)(a1 + 916) + 1;
      }
      *(_DWORD *)(a1 + 916) = v87;
      v89 = *(_QWORD *)v30;
      if (!*(_QWORD *)v30)
        v89 = v30 | 1;
      *(_QWORD *)v86 = v89;
      *(_QWORD *)v30 = v86;
    }
    else
    {
      v5 = 0;
    }
    v70 = 1;
LABEL_161:
    v82 = v92;
    if (v92 == (char *)&v93 + 8)
      goto LABEL_140;
    goto LABEL_139;
  }
  if (!strncmp("Dw", v3, 2uLL))
  {
    v19 = v3 + 2;
    *(_QWORD *)a1 = v3 + 2;
    v20 = (uint64_t)(*(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16)) >> 3;
    while (v19 == v4 || *v19 != 69)
    {
      v21 = sub_1C5DF9EB0(a1);
      if (!v21)
        return 0;
      v22 = v21;
      v23 = *(uint64_t **)(a1 + 24);
      if (v23 == *(uint64_t **)(a1 + 32))
      {
        sub_1C625449C(a1 + 16, ((uint64_t)v23 - *(_QWORD *)(a1 + 16)) >> 2);
        v23 = *(uint64_t **)(a1 + 24);
      }
      *(_QWORD *)(a1 + 24) = v23 + 1;
      *v23 = v22;
      v19 = *(const char **)a1;
      v4 = *(const char **)(a1 + 8);
    }
    *(_QWORD *)a1 = v19 + 1;
    v34 = *(_QWORD *)(a1 + 24);
    v35 = (const void *)(*(_QWORD *)(a1 + 16) + 8 * v20);
    v36 = (uint64_t *)sub_1C484358C(a1 + 808, v34 - (_QWORD)v35, 3);
    v37 = v36;
    v38 = v34 - (_QWORD)v35;
    if (v38)
      memmove(v36, v35, v38);
    v39 = v38 >> 3;
    *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 16) + 8 * v20;
    v40 = *(unsigned __int8 *)(a1 + 937);
    v92 = (char *)&v93 + 8;
    *(_QWORD *)&v93 = 0x2000000000;
    sub_1C5E0169C(&v92, 17, v37, v38 >> 3);
    v41 = sub_1C4F5AB38(v92, (uint64_t)v92 + 4 * v93);
    v43 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v41);
    v44 = *(unsigned int **)v43;
    v96 = v98;
    v97 = 0x2000000000;
    if (v44)
      v45 = (v44 & 1) == 0;
    else
      v45 = 0;
    if (!v45)
      goto LABEL_131;
    while (1)
    {
      LOBYTE(v41) = sub_1C5DFE6F4(v41, v44, (uint64_t)&v92, v42, (unsigned int *)&v96);
      if ((v41 & 1) != 0)
        break;
      LODWORD(v97) = 0;
      v44 = *(unsigned int **)v44;
      if (v44)
        v46 = (v44 & 1) == 0;
      else
        v46 = 0;
      if (!v46)
      {
        v44 = 0;
        goto LABEL_101;
      }
    }
    v43 = 0;
LABEL_101:
    if (v96 == v98)
    {
      if (v44)
      {
LABEL_103:
        v70 = 0;
        v5 = (uint64_t)(v44 + 2);
        goto LABEL_138;
      }
    }
    else
    {
      free(v96);
      if (v44)
        goto LABEL_103;
    }
LABEL_131:
    if (v40)
    {
      v78 = sub_1C484358C(a1 + 808, 40, 3);
      *(_QWORD *)v78 = 0;
      *(_QWORD *)(v78 + 8) = &unk_1E816C1E0;
      v5 = v78 + 8;
      *(_BYTE *)(v78 + 16) = 17;
      *(_WORD *)(v78 + 17) = *(_WORD *)(v78 + 17) & 0xF000 | 0x540;
      *(_QWORD *)(v78 + 24) = v37;
      *(_QWORD *)(v78 + 32) = v39;
      v79 = *(_DWORD *)(a1 + 916) + 1;
      v80 = *(_DWORD *)(a1 + 912);
      if (v79 > 2 * v80)
      {
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v80, (uint64_t)off_1E81A1260);
        v96 = v98;
        v97 = 0x2000000000;
        sub_1C5DFE788((unsigned int *)v78, (unsigned int *)&v96);
        v43 = *(_QWORD *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v96, (uint64_t)v96 + 4 * v97));
        if (v96 != v98)
          free(v96);
        v79 = *(_DWORD *)(a1 + 916) + 1;
      }
      *(_DWORD *)(a1 + 916) = v79;
      v81 = *(_QWORD *)v43;
      if (!*(_QWORD *)v43)
        v81 = v43 | 1;
      *(_QWORD *)v78 = v81;
      *(_QWORD *)v43 = v78;
    }
    else
    {
      v5 = 0;
    }
    v70 = 1;
LABEL_138:
    v82 = v92;
    if (v92 == (char *)&v93 + 8)
    {
LABEL_140:
      if (v70)
      {
        *(_QWORD *)(a1 + 920) = v5;
      }
      else
      {
        if (!v5)
          return 0;
        v96 = 0;
        v84 = sub_1C627E01C(a1 + 944, v5, &v96);
        v85 = 0;
        if (v84)
          v85 = *((_QWORD *)v96 + 1);
        if (v85)
          v5 = v85;
        if (v5 == *(_QWORD *)(a1 + 928))
          *(_BYTE *)(a1 + 936) = 1;
      }
      if (v5)
        goto LABEL_3;
      return 0;
    }
LABEL_139:
    free(v82);
    goto LABEL_140;
  }
LABEL_2:
  v5 = 0;
LABEL_3:
  v7 = *(const char **)a1;
  v6 = *(const char **)(a1 + 8);
  if ((unint64_t)&v6[-*(_QWORD *)a1] >= 2 && !strncmp("Dx", *(const char **)a1, 2uLL))
  {
    v7 += 2;
    *(_QWORD *)a1 = v7;
  }
  if (v7 == v6 || *v7 != 70)
    return 0;
  *(_QWORD *)a1 = v7 + 1;
  if (v7 + 1 != v6 && v7[1] == 89)
    *(_QWORD *)a1 = v7 + 2;
  v8 = sub_1C5DF9EB0(a1);
  if (!v8)
    return 0;
  v9 = v8;
  v91 = v2;
  v10 = (uint64_t)(*(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16)) >> 3;
  v11 = 2;
  while (1)
  {
    while (1)
    {
      v13 = *(const char **)a1;
      v12 = *(_QWORD *)(a1 + 8);
      if (*(_QWORD *)a1 != v12)
        break;
LABEL_16:
      if ((unint64_t)(v12 - (_QWORD)v13) >= 2)
      {
        if (!strncmp("RE", *(const char **)a1, 2uLL))
        {
          v15 = 1;
          goto LABEL_66;
        }
        v15 = 2;
        if (!strncmp("OE", v13, 2uLL))
        {
          v11 = 2;
          goto LABEL_66;
        }
      }
      v16 = sub_1C5DF9EB0(a1);
      if (!v16)
        return 0;
      v17 = v16;
      v18 = *(uint64_t **)(a1 + 24);
      if (v18 == *(uint64_t **)(a1 + 32))
      {
        sub_1C625449C(a1 + 16, ((uint64_t)v18 - *(_QWORD *)(a1 + 16)) >> 2);
        v18 = *(uint64_t **)(a1 + 24);
      }
      *(_QWORD *)(a1 + 24) = v18 + 1;
      *v18 = v17;
    }
    v14 = *(unsigned __int8 *)v13;
    if (v14 != 118)
      break;
    *(_QWORD *)a1 = v13 + 1;
  }
  if (v14 != 69)
    goto LABEL_16;
  v15 = 0;
  v11 = 1;
LABEL_66:
  *(_QWORD *)a1 = &v13[v11];
  v47 = *(_BYTE **)(a1 + 24);
  v48 = (_BYTE *)(*(_QWORD *)(a1 + 16) + 8 * v10);
  v49 = (uint64_t *)sub_1C484358C(a1 + 808, v47 - v48, 3);
  v50 = v49;
  v51 = v47 - v48;
  if (v47 != v48)
    memmove(v49, v48, v47 - v48);
  v52 = v51 >> 3;
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 16) + 8 * v10;
  v90 = *(unsigned __int8 *)(a1 + 937);
  v92 = (char *)&v93 + 8;
  v94 = v9;
  v95[0] = v51 >> 3;
  v93 = xmmword_1C866FA20;
  if (v47 == v48)
  {
    LODWORD(v54) = 6;
  }
  else
  {
    v53 = 8 * v52;
    LODWORD(v54) = 6;
    v55 = v50;
    do
    {
      v56 = *v55;
      if (v54 >= DWORD1(v93))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, (uint64_t)&v93 + 8, v54 + 1, 4);
        LODWORD(v54) = v93;
      }
      *((_DWORD *)v92 + v54) = v56;
      v57 = (v93 + 1);
      LODWORD(v93) = v57;
      if (v57 >= DWORD1(v93))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, (uint64_t)&v93 + 8, v57 + 1, 4);
        LODWORD(v57) = v93;
      }
      *((_DWORD *)v92 + v57) = HIDWORD(v56);
      v54 = (v93 + 1);
      LODWORD(v93) = v93 + 1;
      ++v55;
      v53 -= 8;
    }
    while (v53);
    if (v54 >= DWORD1(v93))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, (uint64_t)&v93 + 8, v54 + 1, 4);
      LODWORD(v54) = v93;
    }
  }
  *((_DWORD *)v92 + v54) = v91;
  v58 = (v93 + 1);
  LODWORD(v93) = v58;
  if (v58 >= DWORD1(v93))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, (uint64_t)&v93 + 8, v58 + 1, 4);
    LODWORD(v58) = v93;
  }
  *((_DWORD *)v92 + v58) = 0;
  v59 = (v93 + 1);
  LODWORD(v93) = v59;
  if (v59 >= DWORD1(v93))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, (uint64_t)&v93 + 8, v59 + 1, 4);
    LODWORD(v59) = v93;
  }
  *((_DWORD *)v92 + v59) = v15;
  v60 = (v93 + 1);
  LODWORD(v93) = v60;
  if (v60 >= DWORD1(v93))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, (uint64_t)&v93 + 8, v60 + 1, 4);
    LODWORD(v60) = v93;
  }
  *((_DWORD *)v92 + v60) = 0;
  v61 = (v93 + 1);
  LODWORD(v93) = v61;
  if (v61 >= DWORD1(v93))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, (uint64_t)&v93 + 8, v61 + 1, 4);
    LODWORD(v61) = v93;
  }
  *((_DWORD *)v92 + v61) = v5;
  v62 = (v93 + 1);
  LODWORD(v93) = v62;
  if (v62 >= DWORD1(v93))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, (uint64_t)&v93 + 8, v62 + 1, 4);
    LODWORD(v62) = v93;
  }
  *((_DWORD *)v92 + v62) = HIDWORD(v5);
  LODWORD(v93) = v93 + 1;
  v63 = sub_1C4F5AB38(v92, (uint64_t)v92 + 4 * v93);
  v65 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v63);
  v66 = *(unsigned int **)v65;
  v96 = v98;
  v97 = 0x2000000000;
  if (!v66 || (v66 & 1) != 0)
    goto LABEL_109;
  while (1)
  {
    LOBYTE(v63) = sub_1C5DFE6F4(v63, v66, (uint64_t)&v92, v64, (unsigned int *)&v96);
    if ((v63 & 1) != 0)
      break;
    LODWORD(v97) = 0;
    v66 = *(unsigned int **)v66;
    if (v66)
      v67 = (v66 & 1) == 0;
    else
      v67 = 0;
    if (!v67)
    {
      v66 = 0;
      goto LABEL_97;
    }
  }
  v65 = 0;
LABEL_97:
  if (v96 == v98)
  {
    if (v66)
      goto LABEL_99;
LABEL_109:
    if (v90)
    {
      v71 = sub_1C484358C(a1 + 808, 64, 3);
      *(_QWORD *)v71 = 0;
      *(_QWORD *)(v71 + 8) = &unk_1E816C238;
      v69 = v71 + 8;
      *(_BYTE *)(v71 + 16) = 15;
      *(_WORD *)(v71 + 17) = *(_WORD *)(v71 + 17) & 0xF000 | 0x100;
      *(_QWORD *)(v71 + 24) = v9;
      *(_QWORD *)(v71 + 32) = v50;
      *(_QWORD *)(v71 + 40) = v52;
      *(_DWORD *)(v71 + 48) = v91;
      *(_BYTE *)(v71 + 52) = v15;
      *(_QWORD *)(v71 + 56) = v5;
      v72 = *(_DWORD *)(a1 + 916) + 1;
      v73 = *(_DWORD *)(a1 + 912);
      if (v72 > 2 * v73)
      {
        v77 = (unsigned int *)v71;
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v73, (uint64_t)off_1E81A1260);
        v96 = v98;
        v97 = 0x2000000000;
        sub_1C5DFE788(v77, (unsigned int *)&v96);
        v65 = *(_QWORD *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v96, (uint64_t)v96 + 4 * v97));
        if (v96 != v98)
          free(v96);
        v72 = *(_DWORD *)(a1 + 916) + 1;
        v71 = (unint64_t)v77;
      }
      *(_DWORD *)(a1 + 916) = v72;
      v74 = *(_QWORD *)v65;
      if (!*(_QWORD *)v65)
        v74 = v65 | 1;
      *(_QWORD *)v71 = v74;
      *(_QWORD *)v65 = v71;
    }
    else
    {
      v69 = 0;
    }
    v68 = 1;
  }
  else
  {
    free(v96);
    if (!v66)
      goto LABEL_109;
LABEL_99:
    v68 = 0;
    v69 = (uint64_t)(v66 + 2);
  }
  if (v92 != (char *)&v93 + 8)
    free(v92);
  if (v68)
  {
    *(_QWORD *)(a1 + 920) = v69;
  }
  else if (v69)
  {
    v96 = 0;
    v75 = sub_1C627E01C(a1 + 944, v69, &v96);
    v76 = 0;
    if (v75)
      v76 = *((_QWORD *)v96 + 1);
    if (v76)
      v69 = v76;
    if (v69 == *(_QWORD *)(a1 + 928))
      *(_BYTE *)(a1 + 936) = 1;
  }
  return v69;
}

uint64_t sub_1C5E037CC(uint64_t a1)
{
  unsigned __int8 *v2;
  unsigned __int8 *v3;
  unsigned __int8 *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;
  BOOL v13;
  BOOL v14;
  int v15;
  unsigned __int8 *v16;
  unsigned __int8 *v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  unsigned int v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int *v28;
  BOOL v29;
  unsigned __int8 *v30;
  unsigned __int8 *v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int *v38;
  BOOL v39;
  int v40;
  unint64_t v41;
  __int16 v42;
  unsigned int v43;
  int v44;
  uint64_t v45;
  unint64_t v46;
  unsigned int v47;
  int v48;
  uint64_t v49;
  unsigned int *v50;
  unint64_t v51;
  unsigned int v52;
  int v53;
  uint64_t v54;
  int v56;
  uint64_t v57;
  void *v58;
  __int128 v59;
  uint64_t v60;
  int v61;
  int v62;
  uint64_t v63;
  void *v64;
  uint64_t v65;
  _QWORD v66[18];

  v66[16] = *MEMORY[0x1E0C80C00];
  v2 = *(unsigned __int8 **)a1;
  if (*(_QWORD *)a1 == *(_QWORD *)(a1 + 8) || *v2 != 85)
  {
    v5 = sub_1C54C4768(a1);
    v6 = sub_1C5DF9EB0(a1);
    v7 = v6;
    if (!v6 || !v5)
      return v7;
    v8 = *(unsigned __int8 *)(a1 + 937);
    v58 = (char *)&v59 + 8;
    v60 = v6;
    v61 = v5;
    v62 = 0;
    v59 = xmmword_1C866FA50;
    v9 = sub_1C4F5AB38((_QWORD *)&v59 + 1, (uint64_t)&v63);
    v11 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v9);
    v12 = *(unsigned int **)v11;
    v64 = v66;
    v65 = 0x2000000000;
    if (v12)
      v13 = (v12 & 1) == 0;
    else
      v13 = 0;
    if (!v13)
    {
LABEL_73:
      if (v8)
      {
        v41 = sub_1C484358C(a1 + 808, 32, 3);
        *(_QWORD *)v41 = 0;
        v42 = *(_WORD *)(v7 + 9);
        *(_QWORD *)(v41 + 8) = &unk_1E816C340;
        *(_BYTE *)(v41 + 16) = 3;
        *(_WORD *)(v41 + 17) = *(_WORD *)(v41 + 17) & 0xF000 | v42 & 0xFC0;
        *(_DWORD *)(v41 + 20) = v5;
        *(_QWORD *)(v41 + 24) = v7;
        v43 = *(_DWORD *)(a1 + 916) + 1;
        v44 = *(_DWORD *)(a1 + 912);
        if (v43 > 2 * v44)
        {
          llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v44, (uint64_t)off_1E81A1260);
          v64 = v66;
          v65 = 0x2000000000;
          sub_1C5DFE788((unsigned int *)v41, (unsigned int *)&v64);
          v11 = *(_QWORD *)(a1 + 904)
              + 8
              * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v64, (uint64_t)v64 + 4 * v65));
          if (v64 != v66)
            free(v64);
          v43 = *(_DWORD *)(a1 + 916) + 1;
        }
        *(_DWORD *)(a1 + 916) = v43;
        v45 = *(_QWORD *)v11;
        if (!*(_QWORD *)v11)
          v45 = v11 | 1;
        *(_QWORD *)v41 = v45;
        *(_QWORD *)v11 = v41;
        v15 = 1;
        v7 = v41 + 8;
LABEL_89:
        if (v58 != (char *)&v59 + 8)
          free(v58);
        if (v15)
        {
LABEL_92:
          *(_QWORD *)(a1 + 920) = v7;
          return v7;
        }
        goto LABEL_107;
      }
      goto LABEL_87;
    }
    while (1)
    {
      LOBYTE(v9) = sub_1C5DFE6F4(v9, v12, (uint64_t)&v58, v10, (unsigned int *)&v64);
      if ((v9 & 1) != 0)
        break;
      LODWORD(v65) = 0;
      v12 = *(unsigned int **)v12;
      if (v12)
        v14 = (v12 & 1) == 0;
      else
        v14 = 0;
      if (!v14)
      {
        v12 = 0;
        goto LABEL_20;
      }
    }
    v11 = 0;
LABEL_20:
    if (v64 == v66)
    {
      if (!v12)
        goto LABEL_73;
    }
    else
    {
      free(v64);
      if (!v12)
        goto LABEL_73;
    }
    v15 = 0;
    v7 = (uint64_t)(v12 + 2);
    goto LABEL_89;
  }
  *(_QWORD *)a1 = v2 + 1;
  v64 = 0;
  v3 = 0;
  v4 = 0;
  if ((sub_1C54C42B4((unsigned __int8 **)a1, (uint64_t *)&v64) & 1) == 0)
  {
    v4 = *(unsigned __int8 **)a1;
    if (*(_QWORD *)(a1 + 8) - *(_QWORD *)a1 >= (unint64_t)v64)
    {
      v3 = (unsigned __int8 *)v64 + (_QWORD)v4;
      *(_QWORD *)a1 = (char *)v64 + (_QWORD)v4;
    }
    else
    {
      v3 = 0;
      v4 = 0;
    }
  }
  if (v4 == v3)
    return 0;
  if ((unint64_t)(v3 - v4) <= 8)
  {
    v16 = *(unsigned __int8 **)a1;
    v17 = *(unsigned __int8 **)(a1 + 8);
LABEL_28:
    if (v17 == v16 || *v16 != 73)
    {
      v19 = 0;
    }
    else
    {
      v19 = sub_1C5E08AA8(a1, 0);
      if (!v19)
        return 0;
    }
    v20 = sub_1C5E037CC(a1);
    if (!v20)
      return 0;
    v21 = v20;
    v22 = *(unsigned __int8 *)(a1 + 937);
    v58 = (char *)&v59 + 8;
    v60 = v20;
    v59 = xmmword_1C866FA40;
    llvm::FoldingSetNodeID::AddString((unsigned int *)&v58, v4, (_DWORD)v3 - (_DWORD)v4);
    v23 = v59;
    if (v59 >= DWORD1(v59))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v58, (uint64_t)&v59 + 8, v59 + 1, 4);
      v23 = v59;
    }
    *((_DWORD *)v58 + v23) = v19;
    v24 = (v59 + 1);
    LODWORD(v59) = v24;
    if (v24 >= DWORD1(v59))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v58, (uint64_t)&v59 + 8, v24 + 1, 4);
      LODWORD(v24) = v59;
    }
    *((_DWORD *)v58 + v24) = HIDWORD(v19);
    LODWORD(v59) = v59 + 1;
    v25 = sub_1C4F5AB38(v58, (uint64_t)v58 + 4 * v59);
    v27 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v25);
    v28 = *(unsigned int **)v27;
    v64 = v66;
    v65 = 0x2000000000;
    if (v28 && (v28 & 1) == 0)
    {
      while (1)
      {
        LOBYTE(v25) = sub_1C5DFE6F4(v25, v28, (uint64_t)&v58, v26, (unsigned int *)&v64);
        if ((v25 & 1) != 0)
          break;
        LODWORD(v65) = 0;
        v28 = *(unsigned int **)v28;
        if (v28)
          v29 = (v28 & 1) == 0;
        else
          v29 = 0;
        if (!v29)
        {
          v28 = 0;
          goto LABEL_47;
        }
      }
      v27 = 0;
LABEL_47:
      if (v64 == v66)
      {
        if (v28)
        {
LABEL_49:
          v15 = 0;
          v7 = (uint64_t)(v28 + 2);
          goto LABEL_89;
        }
      }
      else
      {
        free(v64);
        if (v28)
          goto LABEL_49;
      }
    }
    if (v22)
    {
      v46 = sub_1C484358C(a1 + 808, 56, 3);
      *(_QWORD *)v46 = 0;
      *(_QWORD *)(v46 + 8) = &unk_1E816C2E8;
      v7 = v46 + 8;
      *(_BYTE *)(v46 + 16) = 2;
      *(_WORD *)(v46 + 17) = *(_WORD *)(v46 + 17) & 0xF000 | 0x540;
      *(_QWORD *)(v46 + 24) = v21;
      *(_QWORD *)(v46 + 32) = v4;
      *(_QWORD *)(v46 + 40) = v3;
      *(_QWORD *)(v46 + 48) = v19;
      v47 = *(_DWORD *)(a1 + 916) + 1;
      v48 = *(_DWORD *)(a1 + 912);
      if (v47 > 2 * v48)
      {
        v50 = (unsigned int *)v46;
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v48, (uint64_t)off_1E81A1260);
        v64 = v66;
        v65 = 0x2000000000;
        sub_1C5DFE788(v50, (unsigned int *)&v64);
        v27 = *(_QWORD *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v64, (uint64_t)v64 + 4 * v65));
        if (v64 != v66)
          free(v64);
        v47 = *(_DWORD *)(a1 + 916) + 1;
        v46 = (unint64_t)v50;
      }
      *(_DWORD *)(a1 + 916) = v47;
      v49 = *(_QWORD *)v27;
      if (!*(_QWORD *)v27)
        v49 = v27 | 1;
      *(_QWORD *)v46 = v49;
      *(_QWORD *)v27 = v46;
      goto LABEL_88;
    }
LABEL_87:
    v7 = 0;
LABEL_88:
    v15 = 1;
    goto LABEL_89;
  }
  v18 = strncmp("objcproto", (const char *)v4, 9uLL);
  v16 = *(unsigned __int8 **)a1;
  v17 = *(unsigned __int8 **)(a1 + 8);
  if (v18)
    goto LABEL_28;
  *(_QWORD *)a1 = v4 + 9;
  *(_QWORD *)(a1 + 8) = v3;
  v64 = 0;
  v30 = 0;
  v31 = 0;
  if ((sub_1C54C42B4((unsigned __int8 **)a1, (uint64_t *)&v64) & 1) == 0)
  {
    if (*(_QWORD *)(a1 + 8) - *(_QWORD *)a1 >= (unint64_t)v64)
      v30 = (unsigned __int8 *)v64 + *(_QWORD *)a1;
    else
      v30 = 0;
    if (*(_QWORD *)(a1 + 8) - *(_QWORD *)a1 >= (unint64_t)v64)
      v31 = *(unsigned __int8 **)a1;
    else
      v31 = 0;
  }
  *(_QWORD *)a1 = v16;
  *(_QWORD *)(a1 + 8) = v17;
  if (v31 == v30)
    return 0;
  v32 = sub_1C5E037CC(a1);
  if (!v32)
    return 0;
  v33 = v32;
  v34 = *(unsigned __int8 *)(a1 + 937);
  v58 = (char *)&v59 + 8;
  v60 = v32;
  v59 = xmmword_1C866FA30;
  llvm::FoldingSetNodeID::AddString((unsigned int *)&v58, v31, (_DWORD)v30 - (_DWORD)v31);
  v35 = sub_1C4F5AB38(v58, (uint64_t)v58 + 4 * v59);
  v37 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v35);
  v38 = *(unsigned int **)v37;
  v64 = v66;
  v65 = 0x2000000000;
  if (v38 && (v38 & 1) == 0)
  {
    while (1)
    {
      LOBYTE(v35) = sub_1C5DFE6F4(v35, v38, (uint64_t)&v58, v36, (unsigned int *)&v64);
      if ((v35 & 1) != 0)
        break;
      LODWORD(v65) = 0;
      v38 = *(unsigned int **)v38;
      if (v38)
        v39 = (v38 & 1) == 0;
      else
        v39 = 0;
      if (!v39)
      {
        v38 = 0;
        goto LABEL_69;
      }
    }
    v37 = 0;
LABEL_69:
    if (v64 == v66)
    {
      if (v38)
      {
LABEL_71:
        v40 = 0;
        v7 = (uint64_t)(v38 + 2);
        goto LABEL_104;
      }
    }
    else
    {
      free(v64);
      if (v38)
        goto LABEL_71;
    }
  }
  if (v34)
  {
    v51 = sub_1C484358C(a1 + 808, 48, 3);
    *(_QWORD *)v51 = 0;
    *(_QWORD *)(v51 + 8) = &unk_1E816C290;
    v7 = v51 + 8;
    *(_BYTE *)(v51 + 16) = 10;
    *(_WORD *)(v51 + 17) = *(_WORD *)(v51 + 17) & 0xF000 | 0x540;
    *(_QWORD *)(v51 + 24) = v33;
    *(_QWORD *)(v51 + 32) = v31;
    *(_QWORD *)(v51 + 40) = v30;
    v52 = *(_DWORD *)(a1 + 916) + 1;
    v53 = *(_DWORD *)(a1 + 912);
    if (v52 > 2 * v53)
    {
      llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v53, (uint64_t)off_1E81A1260);
      v64 = v66;
      v65 = 0x2000000000;
      sub_1C5DFE788((unsigned int *)v51, (unsigned int *)&v64);
      v37 = *(_QWORD *)(a1 + 904)
          + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v64, (uint64_t)v64 + 4 * v65));
      if (v64 != v66)
        free(v64);
      v52 = *(_DWORD *)(a1 + 916) + 1;
    }
    *(_DWORD *)(a1 + 916) = v52;
    v54 = *(_QWORD *)v37;
    if (!*(_QWORD *)v37)
      v54 = v37 | 1;
    *(_QWORD *)v51 = v54;
    *(_QWORD *)v37 = v51;
  }
  else
  {
    v7 = 0;
  }
  v40 = 1;
LABEL_104:
  if (v58 != (char *)&v59 + 8)
    free(v58);
  if (v40)
    goto LABEL_92;
LABEL_107:
  if (v7)
  {
    v64 = 0;
    v56 = sub_1C627E01C(a1 + 944, v7, &v64);
    v57 = 0;
    if (v56)
      v57 = *((_QWORD *)v64 + 1);
    if (v57)
      v7 = v57;
    if (v7 == *(_QWORD *)(a1 + 928))
      *(_BYTE *)(a1 + 936) = 1;
  }
  return v7;
}

uint64_t sub_1C5E04030(uint64_t a1, __int128 *a2)
{
  int v4;
  unsigned __int8 *v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int *v10;
  BOOL v11;
  BOOL v12;
  int v13;
  uint64_t v14;
  unint64_t v15;
  __int128 v16;
  unsigned int v17;
  int v18;
  uint64_t v19;
  int v21;
  uint64_t v22;
  void *v23;
  unsigned int v24[34];
  void *v25;
  uint64_t v26;
  _QWORD v27[17];

  v27[16] = *MEMORY[0x1E0C80C00];
  v4 = *(unsigned __int8 *)(a1 + 937);
  v23 = &v24[2];
  v5 = *(unsigned __int8 **)a2;
  v6 = *((_QWORD *)a2 + 1);
  *(_OWORD *)v24 = xmmword_1C866F960;
  llvm::FoldingSetNodeID::AddString((unsigned int *)&v23, v5, v6 - (_DWORD)v5);
  v7 = sub_1C4F5AB38(v23, (uint64_t)v23 + 4 * v24[0]);
  v9 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v7);
  v10 = *(unsigned int **)v9;
  v25 = v27;
  v26 = 0x2000000000;
  if (v10)
    v11 = (v10 & 1) == 0;
  else
    v11 = 0;
  if (!v11)
    goto LABEL_17;
  while (1)
  {
    LOBYTE(v7) = sub_1C5DFE6F4(v7, v10, (uint64_t)&v23, v8, (unsigned int *)&v25);
    if ((v7 & 1) != 0)
      break;
    LODWORD(v26) = 0;
    v10 = *(unsigned int **)v10;
    if (v10)
      v12 = (v10 & 1) == 0;
    else
      v12 = 0;
    if (!v12)
    {
      v10 = 0;
      goto LABEL_13;
    }
  }
  v9 = 0;
LABEL_13:
  if (v25 == v27)
  {
    if (v10)
    {
LABEL_15:
      v13 = 0;
      v14 = (uint64_t)(v10 + 2);
      goto LABEL_24;
    }
  }
  else
  {
    free(v25);
    if (v10)
      goto LABEL_15;
  }
LABEL_17:
  if (v4)
  {
    v15 = sub_1C484358C(a1 + 808, 40, 3);
    *(_QWORD *)v15 = 0;
    *(_QWORD *)(v15 + 8) = &unk_1E816A8B0;
    v14 = v15 + 8;
    *(_BYTE *)(v15 + 16) = 7;
    v16 = *a2;
    *(_WORD *)(v15 + 17) = *(_WORD *)(v15 + 17) & 0xF000 | 0x540;
    *(_OWORD *)(v15 + 24) = v16;
    v17 = *(_DWORD *)(a1 + 916) + 1;
    v18 = *(_DWORD *)(a1 + 912);
    if (v17 > 2 * v18)
    {
      llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v18, (uint64_t)off_1E81A1260);
      v25 = v27;
      v26 = 0x2000000000;
      sub_1C5DFE788((unsigned int *)v15, (unsigned int *)&v25);
      v9 = *(_QWORD *)(a1 + 904)
         + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v25, (uint64_t)v25 + 4 * v26));
      if (v25 != v27)
        free(v25);
      v17 = *(_DWORD *)(a1 + 916) + 1;
    }
    *(_DWORD *)(a1 + 916) = v17;
    v19 = *(_QWORD *)v9;
    if (!*(_QWORD *)v9)
      v19 = v9 | 1;
    *(_QWORD *)v15 = v19;
    *(_QWORD *)v9 = v15;
  }
  else
  {
    v14 = 0;
  }
  v13 = 1;
LABEL_24:
  if (v23 != &v24[2])
    free(v23);
  if (v13)
  {
    *(_QWORD *)(a1 + 920) = v14;
  }
  else if (v14)
  {
    v25 = 0;
    v21 = sub_1C627E01C(a1 + 944, v14, &v25);
    v22 = 0;
    if (v21)
      v22 = *((_QWORD *)v25 + 1);
    if (v22)
      v14 = v22;
    if (v14 == *(_QWORD *)(a1 + 928))
      *(_BYTE *)(a1 + 936) = 1;
  }
  return v14;
}

uint64_t sub_1C5E042EC(uint64_t a1)
{
  unsigned __int8 *v2;
  int v3;
  char *v4;
  char *v5;
  const char *v6;
  size_t v7;
  uint64_t v8;
  unsigned __int8 *v9;
  uint64_t v10;
  unsigned __int8 *v11;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  unint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  int v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int *v26;
  BOOL v27;
  char v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned __int8 *v32;
  int v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int *v43;
  BOOL v44;
  BOOL v45;
  uint64_t v46;
  uint64_t v47;
  unsigned int v48;
  int v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unsigned int *v53;
  BOOL v54;
  BOOL v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unsigned int v60;
  int v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unsigned int *v65;
  BOOL v66;
  BOOL v67;
  uint64_t v68;
  unsigned __int8 *v69;
  uint64_t *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  unsigned int v77;
  int v78;
  unint64_t v79;
  uint64_t v80;
  uint64_t v81;
  BOOL v82;
  uint64_t v83;
  unsigned __int8 *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t *v87;
  char *v88;
  int v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  unsigned int v93;
  int v94;
  unsigned int v95;
  uint64_t v96;
  unint64_t v97;
  uint64_t v98;
  uint64_t v99;
  unsigned int *v100;
  BOOL v101;
  void *v102;
  const char *v103;
  uint64_t v104;
  uint64_t v105;
  unsigned __int8 *v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t *v109;
  uint64_t v110;
  unsigned __int8 *v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t *v114;
  _BYTE *v115;
  _BYTE *v116;
  uint64_t *v117;
  uint64_t *v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  unsigned __int8 *v122;
  unsigned __int8 *v123;
  int v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t *v128;
  int v129;
  unint64_t v130;
  unsigned int v131;
  int v132;
  uint64_t v133;
  uint64_t v134;
  const void *v135;
  void *v136;
  void *v137;
  int64_t v138;
  int v139;
  unint64_t v141;
  unsigned int v142;
  int v143;
  uint64_t v144;
  unsigned __int8 *v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t *v149;
  uint64_t v150;
  const void *v151;
  uint64_t *v152;
  uint64_t *v153;
  int64_t v154;
  uint64_t v155;
  unsigned int v156;
  int v157;
  unint64_t v158;
  uint64_t v159;
  uint64_t v160;
  unsigned int *v161;
  BOOL v162;
  BOOL v163;
  int v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  unsigned __int8 *v169;
  uint64_t v170;
  unsigned __int8 *v171;
  unsigned __int8 *v172;
  uint64_t v173;
  int v174;
  unsigned int v175;
  uint64_t v176;
  unint64_t v177;
  uint64_t v178;
  uint64_t v179;
  BOOL v180;
  int v181;
  unsigned int v182;
  int v183;
  uint64_t v184;
  uint64_t v185;
  int v186;
  unsigned int v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  unint64_t v191;
  uint64_t v192;
  BOOL v193;
  _BYTE *v194;
  _BYTE *v195;
  uint64_t *v196;
  uint64_t *v197;
  uint64_t v198;
  uint64_t v199;
  int v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t *v203;
  uint64_t v204;
  uint64_t v205;
  _BYTE *v206;
  _BYTE *v207;
  uint64_t *v208;
  uint64_t *v209;
  uint64_t v210;
  unsigned int v211;
  unint64_t v212;
  uint64_t v213;
  uint64_t v214;
  unsigned int *v215;
  BOOL v216;
  BOOL v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  char *v222;
  uint64_t v223;
  unsigned __int8 *v224;
  unsigned __int8 *v225;
  unsigned __int8 *v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  int v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t *v234;
  _QWORD *v235;
  char *v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  unint64_t v240;
  uint64_t v241;
  uint64_t v242;
  unsigned int *v243;
  BOOL v244;
  BOOL v245;
  uint64_t v246;
  uint64_t v247;
  int v248;
  unint64_t v249;
  uint64_t v250;
  uint64_t v251;
  BOOL v252;
  _BOOL4 v253;
  uint64_t v254;
  uint64_t v255;
  const char *v256;
  size_t v257;
  unsigned __int8 *v258;
  uint64_t v259;
  const char *v260;
  unsigned int v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  unint64_t v265;
  uint64_t v266;
  uint64_t v267;
  BOOL v268;
  unint64_t v269;
  unsigned int v270;
  int v271;
  uint64_t v272;
  uint64_t *v273;
  unsigned __int8 *v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t *v278;
  unint64_t v279;
  unsigned int v280;
  int v281;
  uint64_t v282;
  uint64_t v283;
  _BYTE *v284;
  _BYTE *v285;
  _QWORD *v286;
  _QWORD *v287;
  uint64_t v288;
  unsigned int v289;
  uint64_t v290;
  unsigned int v291;
  uint64_t v292;
  uint64_t *v293;
  uint64_t v294;
  uint64_t v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  unsigned __int8 *v299;
  uint64_t v300;
  uint64_t v301;
  uint64_t *v302;
  uint64_t v303;
  const void *v304;
  uint64_t *v305;
  uint64_t *v306;
  int64_t v307;
  uint64_t v308;
  int v309;
  unint64_t v310;
  uint64_t v311;
  uint64_t v312;
  unsigned int *v313;
  BOOL v314;
  BOOL v315;
  uint64_t v316;
  int v317;
  unint64_t v318;
  uint64_t v319;
  BOOL v320;
  int v321;
  uint64_t v322;
  unint64_t v323;
  uint64_t v324;
  uint64_t v325;
  unsigned int *v326;
  BOOL v327;
  BOOL v328;
  uint64_t v329;
  unint64_t v330;
  unsigned int *v331;
  char v332;
  uint64_t v333;
  const void *v334;
  uint64_t *v335;
  uint64_t *v336;
  int64_t v337;
  uint64_t v338;
  int v339;
  unint64_t v340;
  uint64_t v341;
  unsigned int *v342;
  BOOL v343;
  BOOL v344;
  unsigned int v345;
  int v346;
  uint64_t v347;
  uint64_t v348;
  _BYTE *v349;
  _BYTE *v350;
  void *v351;
  void *v352;
  uint64_t i;
  unsigned __int8 *v354;
  int v355;
  uint64_t v356;
  void *v357;
  uint64_t v358;
  unsigned __int8 *v359;
  unint64_t v360;
  unsigned int v361;
  int v362;
  uint64_t v363;
  _OWORD *v364;
  unint64_t v365;
  unsigned int v366;
  int v367;
  uint64_t v368;
  unint64_t v369;
  unsigned int v370;
  int v371;
  uint64_t v372;
  uint64_t *v373;
  unint64_t v374;
  unsigned int v375;
  int v376;
  uint64_t v377;
  unint64_t v378;
  unsigned int v379;
  int v380;
  uint64_t v381;
  unint64_t v382;
  unsigned int v383;
  int v384;
  uint64_t v385;
  int v386;
  uint64_t v387;
  unint64_t v388;
  unsigned int v389;
  int v390;
  uint64_t v391;
  unsigned int *v392;
  unint64_t v393;
  unsigned int v394;
  int v395;
  uint64_t v396;
  int v397;
  uint64_t v398;
  unint64_t v399;
  unsigned int v400;
  int v401;
  uint64_t v402;
  uint64_t v403;
  int v404;
  int v405;
  _QWORD *v406;
  uint64_t v407;
  BOOL v408;
  uint64_t *v409;
  int v410;
  uint64_t v411;
  uint64_t v412;
  void *v413;
  __int128 v414;
  uint64_t v415;
  uint64_t v416;
  uint64_t v417;
  _DWORD v418[2];
  uint64_t v419;
  __int128 v420;
  _QWORD v421[18];

  v421[16] = *MEMORY[0x1E0C80C00];
  v2 = *(unsigned __int8 **)a1;
  if (*(_QWORD *)(a1 + 8) - *(_QWORD *)a1 >= 2uLL && !strncmp("gs", (const char *)v2, 2uLL))
  {
    *(_QWORD *)a1 = v2 + 2;
    v3 = 1;
  }
  else
  {
    v3 = 0;
  }
  v4 = sub_1C5E098BC((unsigned __int8 **)a1);
  if (v4)
  {
    v5 = v4;
    v6 = (const char *)*((_QWORD *)v4 + 1);
    v7 = strlen(v6);
    v8 = 8;
    if (v7 < 8)
      v8 = v7;
    v9 = (unsigned __int8 *)&v6[v8];
    if (v7 >= 9 && *v9 == 32)
      ++v9;
    while (2)
    {
      v6 += v7;
      v10 = 0;
      switch(v5[2])
      {
        case 0:
          return sub_1C5E09964(a1, v9, (uint64_t)v6, v5[3] >> 1);
        case 1:
          v11 = *(unsigned __int8 **)a1;
          if (*(_QWORD *)a1 != *(_QWORD *)(a1 + 8) && *v11 == 95)
          {
            *(_QWORD *)a1 = v11 + 1;
            return sub_1C5E09964(a1, v9, (uint64_t)v6, v5[3] >> 1);
          }
          v91 = sub_1C5E042EC(a1);
          if (!v91)
            return 0;
          v92 = v91;
          v93 = v5[3];
          v94 = *(unsigned __int8 *)(a1 + 937);
          v413 = (char *)&v414 + 8;
          v415 = v91;
          v414 = xmmword_1C866FA90;
          llvm::FoldingSetNodeID::AddString((unsigned int *)&v413, v9, (_DWORD)v6 - (_DWORD)v9);
          v95 = v414;
          if (v414 >= DWORD1(v414))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v413, (uint64_t)&v414 + 8, v414 + 1, 4);
            v95 = v414;
          }
          *((_DWORD *)v413 + v95) = (char)v93 >> 1;
          v96 = (v414 + 1);
          LODWORD(v414) = v96;
          if (v96 >= DWORD1(v414))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v413, (uint64_t)&v414 + 8, v96 + 1, 4);
            LODWORD(v96) = v414;
          }
          *((_DWORD *)v413 + v96) = (char)v93 >> 7;
          LODWORD(v414) = v414 + 1;
          v97 = sub_1C4F5AB38(v413, (uint64_t)v413 + 4 * v414);
          v99 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v97);
          v100 = *(unsigned int **)v99;
          *(_QWORD *)&v420 = v421;
          *((_QWORD *)&v420 + 1) = 0x2000000000;
          if (!v100 || (v100 & 1) != 0)
            goto LABEL_174;
          while (1)
          {
            LOBYTE(v97) = sub_1C5DFE6F4(v97, v100, (uint64_t)&v413, v98, (unsigned int *)&v420);
            if ((v97 & 1) != 0)
              break;
            DWORD2(v420) = 0;
            v100 = *(unsigned int **)v100;
            if (v100)
              v101 = (v100 & 1) == 0;
            else
              v101 = 0;
            if (!v101)
            {
              v100 = 0;
              goto LABEL_172;
            }
          }
          v99 = 0;
LABEL_172:
          if ((_QWORD *)v420 == v421)
          {
            if (!v100)
              goto LABEL_174;
          }
          else
          {
            free((void *)v420);
            if (!v100)
            {
LABEL_174:
              if (v94)
              {
                v130 = sub_1C484358C(a1 + 808, 48, 3);
                *(_QWORD *)v130 = 0;
                *(_QWORD *)(v130 + 8) = &unk_1E816AE48;
                v10 = v130 + 8;
                *(_BYTE *)(v130 + 16) = 52;
                *(_WORD *)(v130 + 17) = *(_WORD *)(v130 + 17) & 0xF000 | (v93 >> 1) | 0x540;
                *(_QWORD *)(v130 + 24) = v92;
                *(_QWORD *)(v130 + 32) = v9;
                *(_QWORD *)(v130 + 40) = v6;
                v131 = *(_DWORD *)(a1 + 916) + 1;
                v132 = *(_DWORD *)(a1 + 912);
                if (v131 > 2 * v132)
                {
                  llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v132, (uint64_t)off_1E81A1260);
                  *(_QWORD *)&v420 = v421;
                  *((_QWORD *)&v420 + 1) = 0x2000000000;
                  sub_1C5DFE788((unsigned int *)v130, (unsigned int *)&v420);
                  v99 = *(_QWORD *)(a1 + 904)
                      + 8
                      * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38((_QWORD *)v420, v420 + 4 * DWORD2(v420)));
                  if ((_QWORD *)v420 != v421)
                    free((void *)v420);
                  v131 = *(_DWORD *)(a1 + 916) + 1;
                }
                *(_DWORD *)(a1 + 916) = v131;
                v133 = *(_QWORD *)v99;
                if (!*(_QWORD *)v99)
                  v133 = v99 | 1;
                *(_QWORD *)v130 = v133;
                *(_QWORD *)v99 = v130;
              }
              else
              {
                v10 = 0;
              }
              v129 = 1;
LABEL_571:
              v364 = v413;
              if (v413 != (char *)&v414 + 8)
                break;
LABEL_723:
              if (v129)
              {
LABEL_724:
                *(_QWORD *)(a1 + 920) = v10;
                return v10;
              }
LABEL_641:
              if (v10)
              {
                *(_QWORD *)&v420 = 0;
                v386 = sub_1C627E01C(a1 + 944, v10, &v420);
                v387 = 0;
                if (v386)
                  v387 = *(_QWORD *)(v420 + 8);
                if (v387)
                  v10 = v387;
                if (v10 == *(_QWORD *)(a1 + 928))
                  *(_BYTE *)(a1 + 936) = 1;
              }
              return v10;
            }
          }
          v129 = 0;
          v10 = (uint64_t)(v100 + 2);
          goto LABEL_571;
        case 2:
          v34 = v5[3];
          v35 = sub_1C5E042EC(a1);
          if (!v35)
            return 0;
          v36 = v35;
          v37 = sub_1C5E042EC(a1);
          if (!v37)
            return 0;
          v38 = v37;
          v39 = *(unsigned __int8 *)(a1 + 937);
          v413 = (char *)&v414 + 8;
          *(_QWORD *)&v414 = 0x2000000000;
          sub_1C5E01D94((unsigned int *)&v413, 50, v36, v9, (int)v6, v37, (char)v34 >> 1);
          v40 = sub_1C4F5AB38(v413, (uint64_t)v413 + 4 * v414);
          v42 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v40);
          v43 = *(unsigned int **)v42;
          *(_QWORD *)&v420 = v421;
          *((_QWORD *)&v420 + 1) = 0x2000000000;
          if (v43)
            v44 = (v43 & 1) == 0;
          else
            v44 = 0;
          if (!v44)
            goto LABEL_576;
          while (1)
          {
            LOBYTE(v40) = sub_1C5DFE6F4(v40, v43, (uint64_t)&v413, v41, (unsigned int *)&v420);
            if ((v40 & 1) != 0)
              break;
            DWORD2(v420) = 0;
            v43 = *(unsigned int **)v43;
            if (v43)
              v45 = (v43 & 1) == 0;
            else
              v45 = 0;
            if (!v45)
            {
              v43 = 0;
              goto LABEL_195;
            }
          }
          v42 = 0;
LABEL_195:
          if ((_QWORD *)v420 == v421)
          {
            if (v43)
            {
LABEL_197:
              v129 = 0;
              v10 = (uint64_t)(v43 + 2);
              goto LABEL_583;
            }
          }
          else
          {
            free((void *)v420);
            if (v43)
              goto LABEL_197;
          }
LABEL_576:
          if (v39)
          {
            v365 = sub_1C484358C(a1 + 808, 56, 3);
            *(_QWORD *)v365 = 0;
            *(_QWORD *)(v365 + 8) = &unk_1E816AD98;
            v10 = v365 + 8;
            *(_BYTE *)(v365 + 16) = 50;
            *(_WORD *)(v365 + 17) = *(_WORD *)(v365 + 17) & 0xF000 | (v34 >> 1) | 0x540;
            *(_QWORD *)(v365 + 24) = v36;
            *(_QWORD *)(v365 + 32) = v9;
            *(_QWORD *)(v365 + 40) = v6;
            *(_QWORD *)(v365 + 48) = v38;
            v366 = *(_DWORD *)(a1 + 916) + 1;
            v367 = *(_DWORD *)(a1 + 912);
            if (v366 > 2 * v367)
            {
              llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v367, (uint64_t)off_1E81A1260);
              *(_QWORD *)&v420 = v421;
              *((_QWORD *)&v420 + 1) = 0x2000000000;
              sub_1C5DFE788((unsigned int *)v365, (unsigned int *)&v420);
              v42 = *(_QWORD *)(a1 + 904)
                  + 8
                  * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38((_QWORD *)v420, v420 + 4 * DWORD2(v420)));
              if ((_QWORD *)v420 != v421)
                free((void *)v420);
              v366 = *(_DWORD *)(a1 + 916) + 1;
            }
            *(_DWORD *)(a1 + 916) = v366;
            v368 = *(_QWORD *)v42;
            if (!*(_QWORD *)v42)
              v368 = v42 | 1;
            *(_QWORD *)v365 = v368;
            *(_QWORD *)v42 = v365;
          }
          else
          {
            v10 = 0;
          }
          v129 = 1;
LABEL_583:
          v364 = v413;
          goto LABEL_622;
        case 3:
          v17 = sub_1C5E042EC(a1);
          if (!v17)
            return 0;
          v18 = v17;
          v19 = sub_1C5E042EC(a1);
          if (!v19)
            return 0;
          v20 = v19;
          v21 = v5[3];
          v22 = *(unsigned __int8 *)(a1 + 937);
          v413 = (char *)&v414 + 8;
          v415 = v18;
          v416 = v19;
          v417 = (char)v21 >> 1;
          v414 = xmmword_1C866FA80;
          v23 = sub_1C4F5AB38((_QWORD *)&v414 + 1, (uint64_t)v418);
          v25 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v23);
          v26 = *(unsigned int **)v25;
          *(_QWORD *)&v420 = v421;
          *((_QWORD *)&v420 + 1) = 0x2000000000;
          if (!v26 || (v26 & 1) != 0)
            goto LABEL_188;
          while (1)
          {
            LOBYTE(v23) = sub_1C5DFE6F4(v23, v26, (uint64_t)&v413, v24, (unsigned int *)&v420);
            if ((v23 & 1) != 0)
              break;
            DWORD2(v420) = 0;
            v26 = *(unsigned int **)v26;
            if (v26)
              v27 = (v26 & 1) == 0;
            else
              v27 = 0;
            if (!v27)
            {
              v26 = 0;
              goto LABEL_186;
            }
          }
          v25 = 0;
LABEL_186:
          if ((_QWORD *)v420 == v421)
          {
            if (v26)
              goto LABEL_227;
          }
          else
          {
            free((void *)v420);
            if (v26)
              goto LABEL_227;
          }
LABEL_188:
          if (!v22)
            goto LABEL_636;
          v141 = sub_1C484358C(a1 + 808, 40, 3);
          *(_QWORD *)v141 = 0;
          *(_QWORD *)(v141 + 8) = &unk_1E816AEA0;
          v10 = v141 + 8;
          *(_BYTE *)(v141 + 16) = 51;
          *(_WORD *)(v141 + 17) = *(_WORD *)(v141 + 17) & 0xF000 | (v21 >> 1) | 0x540;
          *(_QWORD *)(v141 + 24) = v18;
          *(_QWORD *)(v141 + 32) = v20;
          goto LABEL_190;
        case 4:
          v56 = sub_1C5E042EC(a1);
          if (!v56)
            return 0;
          v57 = v56;
          v58 = sub_1C5E042EC(a1);
          if (!v58)
            return 0;
          v59 = v58;
          v60 = v5[3];
          v61 = *(unsigned __int8 *)(a1 + 937);
          v413 = (char *)&v414 + 8;
          *(_QWORD *)&v414 = 0x2000000000;
          sub_1C5E01D94((unsigned int *)&v413, 54, v57, v9, (int)v6, v58, (char)v60 >> 1);
          v62 = sub_1C4F5AB38(v413, (uint64_t)v413 + 4 * v414);
          v64 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v62);
          v65 = *(unsigned int **)v64;
          *(_QWORD *)&v420 = v421;
          *((_QWORD *)&v420 + 1) = 0x2000000000;
          if (v65)
            v66 = (v65 & 1) == 0;
          else
            v66 = 0;
          if (!v66)
            goto LABEL_585;
          while (1)
          {
            LOBYTE(v62) = sub_1C5DFE6F4(v62, v65, (uint64_t)&v413, v63, (unsigned int *)&v420);
            if ((v62 & 1) != 0)
              break;
            DWORD2(v420) = 0;
            v65 = *(unsigned int **)v65;
            if (v65)
              v67 = (v65 & 1) == 0;
            else
              v67 = 0;
            if (!v67)
            {
              v65 = 0;
              goto LABEL_199;
            }
          }
          v64 = 0;
LABEL_199:
          if ((_QWORD *)v420 == v421)
          {
            if (v65)
            {
LABEL_201:
              v129 = 0;
              v10 = (uint64_t)(v65 + 2);
              goto LABEL_621;
            }
          }
          else
          {
            free((void *)v420);
            if (v65)
              goto LABEL_201;
          }
LABEL_585:
          if (!v61)
            goto LABEL_619;
          v369 = sub_1C484358C(a1 + 808, 56, 3);
          *(_QWORD *)v369 = 0;
          *(_QWORD *)(v369 + 8) = &unk_1E816AEF8;
          v10 = v369 + 8;
          *(_BYTE *)(v369 + 16) = 54;
          *(_WORD *)(v369 + 17) = *(_WORD *)(v369 + 17) & 0xF000 | (v60 >> 1) | 0x540;
          *(_QWORD *)(v369 + 24) = v57;
          *(_QWORD *)(v369 + 32) = v9;
          *(_QWORD *)(v369 + 40) = v6;
          *(_QWORD *)(v369 + 48) = v59;
          v370 = *(_DWORD *)(a1 + 916) + 1;
          v371 = *(_DWORD *)(a1 + 912);
          if (v370 > 2 * v371)
          {
            llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v371, (uint64_t)off_1E81A1260);
            *(_QWORD *)&v420 = v421;
            *((_QWORD *)&v420 + 1) = 0x2000000000;
            sub_1C5DFE788((unsigned int *)v369, (unsigned int *)&v420);
            v64 = *(_QWORD *)(a1 + 904)
                + 8
                * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38((_QWORD *)v420, v420 + 4 * DWORD2(v420)));
            if ((_QWORD *)v420 != v421)
              free((void *)v420);
            v370 = *(_DWORD *)(a1 + 916) + 1;
          }
          *(_DWORD *)(a1 + 916) = v370;
          v372 = *(_QWORD *)v64;
          if (!*(_QWORD *)v64)
            v372 = v64 | 1;
          *(_QWORD *)v369 = v372;
          *(_QWORD *)v64 = v369;
          goto LABEL_620;
        case 5:
          v68 = (uint64_t)(*(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16)) >> 3;
          while (2)
          {
            v69 = *(unsigned __int8 **)a1;
            if (*(_QWORD *)a1 == *(_QWORD *)(a1 + 8) || *v69 != 95)
            {
              v10 = sub_1C5E042EC(a1);
              if (v10)
              {
                v70 = *(uint64_t **)(a1 + 24);
                if (v70 == *(uint64_t **)(a1 + 32))
                {
                  sub_1C625449C(a1 + 16, ((uint64_t)v70 - *(_QWORD *)(a1 + 16)) >> 2);
                  v70 = *(uint64_t **)(a1 + 24);
                }
                *(_QWORD *)(a1 + 24) = v70 + 1;
                *v70 = v10;
                continue;
              }
              return v10;
            }
            break;
          }
          *(_QWORD *)a1 = v69 + 1;
          v115 = *(_BYTE **)(a1 + 24);
          v116 = (_BYTE *)(*(_QWORD *)(a1 + 16) + 8 * v68);
          v117 = (uint64_t *)sub_1C484358C(a1 + 808, v115 - v116, 3);
          v118 = v117;
          v119 = v115 - v116;
          if (v115 != v116)
            memmove(v117, v116, v115 - v116);
          *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 16) + 8 * v68;
          v120 = sub_1C5DF9EB0(a1);
          if (!v120)
            return 0;
          v121 = v120;
          v123 = *(unsigned __int8 **)a1;
          v122 = *(unsigned __int8 **)(a1 + 8);
          v409 = v118;
          if ((unint64_t)&v122[-*(_QWORD *)a1] >= 2 && !strncmp("pi", (const char *)v123, 2uLL))
          {
            v123 += 2;
            *(_QWORD *)a1 = v123;
            v124 = 1;
          }
          else
          {
            v124 = 0;
          }
          v407 = v119 >> 3;
          v125 = (uint64_t)(*(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16)) >> 3;
          while (v123 == v122 || *v123 != 69)
          {
            if (!v124)
              return 0;
            v126 = sub_1C5E042EC(a1);
            if (!v126)
              return 0;
            v127 = v126;
            v128 = *(uint64_t **)(a1 + 24);
            if (v128 == *(uint64_t **)(a1 + 32))
            {
              sub_1C625449C(a1 + 16, ((uint64_t)v128 - *(_QWORD *)(a1 + 16)) >> 2);
              v128 = *(uint64_t **)(a1 + 24);
            }
            *(_QWORD *)(a1 + 24) = v128 + 1;
            *v128 = v127;
            v123 = *(unsigned __int8 **)a1;
            v122 = *(unsigned __int8 **)(a1 + 8);
          }
          *(_QWORD *)a1 = v123 + 1;
          v206 = *(_BYTE **)(a1 + 24);
          v207 = (_BYTE *)(*(_QWORD *)(a1 + 16) + 8 * v125);
          v208 = (uint64_t *)sub_1C484358C(a1 + 808, v206 - v207, 3);
          v209 = v208;
          v210 = v206 - v207;
          if (v206 != v207)
            memmove(v208, v207, v206 - v207);
          *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 16) + 8 * v125;
          v211 = v5[3];
          v405 = *(unsigned __int8 *)(a1 + 937);
          v413 = (char *)&v414 + 8;
          *(_QWORD *)&v414 = 0x2000000000;
          v403 = v210 >> 3;
          sub_1C5E02288(&v413, v409, v407, v121, v209, v210 >> 3, v3, v211 & 1, (char)v211 >> 1);
          v212 = sub_1C4F5AB38(v413, (uint64_t)v413 + 4 * v414);
          v214 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v212);
          v215 = *(unsigned int **)v214;
          *(_QWORD *)&v420 = v421;
          *((_QWORD *)&v420 + 1) = 0x2000000000;
          if (v215)
            v216 = (v215 & 1) == 0;
          else
            v216 = 0;
          if (!v216)
            goto LABEL_649;
          while (1)
          {
            LOBYTE(v212) = sub_1C5DFE6F4(v212, v215, (uint64_t)&v413, v213, (unsigned int *)&v420);
            if ((v212 & 1) != 0)
              break;
            DWORD2(v420) = 0;
            v215 = *(unsigned int **)v215;
            if (v215)
              v217 = (v215 & 1) == 0;
            else
              v217 = 0;
            if (!v217)
            {
              v215 = 0;
              goto LABEL_311;
            }
          }
          v214 = 0;
LABEL_311:
          if ((_QWORD *)v420 == v421)
          {
            if (v215)
            {
LABEL_313:
              v129 = 0;
              v10 = (uint64_t)(v215 + 2);
              goto LABEL_721;
            }
          }
          else
          {
            free((void *)v420);
            if (v215)
              goto LABEL_313;
          }
LABEL_649:
          if (!v405)
            goto LABEL_719;
          v388 = sub_1C484358C(a1 + 808, 72, 3);
          *(_QWORD *)v388 = 0;
          *(_QWORD *)(v388 + 8) = &unk_1E816AF50;
          v10 = v388 + 8;
          *(_BYTE *)(v388 + 16) = 60;
          *(_WORD *)(v388 + 17) = *(_WORD *)(v388 + 17) & 0xF000 | (v211 >> 1) | 0x540;
          *(_QWORD *)(v388 + 24) = v409;
          *(_QWORD *)(v388 + 32) = v407;
          *(_QWORD *)(v388 + 40) = v121;
          *(_QWORD *)(v388 + 48) = v209;
          *(_QWORD *)(v388 + 56) = v403;
          *(_BYTE *)(v388 + 64) = v3;
          *(_BYTE *)(v388 + 65) = v211 & 1;
          v389 = *(_DWORD *)(a1 + 916) + 1;
          v390 = *(_DWORD *)(a1 + 912);
          if (v389 > 2 * v390)
          {
            v392 = (unsigned int *)v388;
            llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v390, (uint64_t)off_1E81A1260);
            *(_QWORD *)&v420 = v421;
            *((_QWORD *)&v420 + 1) = 0x2000000000;
            sub_1C5DFE788(v392, (unsigned int *)&v420);
            v214 = *(_QWORD *)(a1 + 904)
                 + 8
                 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38((_QWORD *)v420, v420 + 4 * DWORD2(v420)));
            if ((_QWORD *)v420 != v421)
              free((void *)v420);
            v389 = *(_DWORD *)(a1 + 916) + 1;
            v388 = (unint64_t)v392;
          }
          *(_DWORD *)(a1 + 916) = v389;
          v391 = *(_QWORD *)v214;
          if (!*(_QWORD *)v214)
            v391 = v214 | 1;
          *(_QWORD *)v388 = v391;
          *(_QWORD *)v214 = v388;
          goto LABEL_720;
        case 6:
          v46 = sub_1C5E042EC(a1);
          if (!v46)
            return 0;
          v47 = v46;
          v48 = v5[3];
          v49 = *(unsigned __int8 *)(a1 + 937);
          v413 = (char *)&v414 + 8;
          *(_QWORD *)&v414 = 0x2000000000;
          sub_1C5E02754(&v413, v46, v3, v48 & 1, (char)v48 >> 1);
          v50 = sub_1C4F5AB38(v413, (uint64_t)v413 + 4 * v414);
          v52 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v50);
          v53 = *(unsigned int **)v52;
          *(_QWORD *)&v420 = v421;
          *((_QWORD *)&v420 + 1) = 0x2000000000;
          if (v53)
            v54 = (v53 & 1) == 0;
          else
            v54 = 0;
          if (!v54)
            goto LABEL_558;
          while (1)
          {
            LOBYTE(v50) = sub_1C5DFE6F4(v50, v53, (uint64_t)&v413, v51, (unsigned int *)&v420);
            if ((v50 & 1) != 0)
              break;
            DWORD2(v420) = 0;
            v53 = *(unsigned int **)v53;
            if (v53)
              v55 = (v53 & 1) == 0;
            else
              v55 = 0;
            if (!v55)
            {
              v53 = 0;
              goto LABEL_168;
            }
          }
          v52 = 0;
LABEL_168:
          if ((_QWORD *)v420 == v421)
          {
            if (v53)
            {
LABEL_170:
              v129 = 0;
              v10 = (uint64_t)(v53 + 2);
              goto LABEL_721;
            }
          }
          else
          {
            free((void *)v420);
            if (v53)
              goto LABEL_170;
          }
LABEL_558:
          if (!v49)
            goto LABEL_719;
          v360 = sub_1C484358C(a1 + 808, 40, 3);
          *(_QWORD *)v360 = 0;
          *(_QWORD *)(v360 + 8) = &unk_1E816AFA8;
          v10 = v360 + 8;
          *(_BYTE *)(v360 + 16) = 61;
          *(_WORD *)(v360 + 17) = *(_WORD *)(v360 + 17) & 0xF000 | (v48 >> 1) | 0x540;
          *(_QWORD *)(v360 + 24) = v47;
          *(_BYTE *)(v360 + 32) = v3;
          *(_BYTE *)(v360 + 33) = v48 & 1;
          goto LABEL_560;
        case 7:
          v413 = (void *)sub_1C5E042EC(a1);
          if (!v413)
            return 0;
          v83 = (uint64_t)(*(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16)) >> 3;
          while (2)
          {
            v84 = *(unsigned __int8 **)a1;
            if (*(_QWORD *)a1 != *(_QWORD *)(a1 + 8) && *v84 == 69)
            {
              *(_QWORD *)a1 = v84 + 1;
              v134 = *(_QWORD *)(a1 + 24);
              v135 = (const void *)(*(_QWORD *)(a1 + 16) + 8 * v83);
              v136 = (void *)sub_1C484358C(a1 + 808, v134 - (_QWORD)v135, 3);
              v137 = v136;
              v138 = v134 - (_QWORD)v135;
              if (v138)
                memmove(v136, v135, v138);
              *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 16) + 8 * v83;
              *(_QWORD *)&v420 = v137;
              *((_QWORD *)&v420 + 1) = v138 >> 3;
              v139 = v5[3] >> 1;
              goto LABEL_182;
            }
            v85 = sub_1C5E042EC(a1);
            if (v85)
            {
              v86 = v85;
              v87 = *(uint64_t **)(a1 + 24);
              if (v87 == *(uint64_t **)(a1 + 32))
              {
                sub_1C625449C(a1 + 16, ((uint64_t)v87 - *(_QWORD *)(a1 + 16)) >> 2);
                v87 = *(uint64_t **)(a1 + 24);
              }
              *(_QWORD *)(a1 + 24) = v87 + 1;
              *v87 = v86;
              continue;
            }
            return 0;
          }
        case 8:
          v28 = *(_BYTE *)(a1 + 776);
          *(_BYTE *)(a1 + 776) = 0;
          v29 = sub_1C5DF9EB0(a1);
          *(_BYTE *)(a1 + 776) = v28;
          if (!v29)
            return 0;
          v30 = v29;
          v31 = *(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16);
          v32 = *(unsigned __int8 **)a1;
          if (*(_QWORD *)a1 == *(_QWORD *)(a1 + 8) || *v32 != 95)
          {
            v33 = 0;
          }
          else
          {
            *(_QWORD *)a1 = v32 + 1;
            v33 = 1;
          }
          v110 = v31 >> 3;
          while (1)
          {
            v111 = *(unsigned __int8 **)a1;
            if (*(_QWORD *)a1 != *(_QWORD *)(a1 + 8) && *v111 == 69)
              break;
            v112 = sub_1C5E042EC(a1);
            if (!v112)
              return 0;
            v113 = v112;
            v114 = *(uint64_t **)(a1 + 24);
            if (v114 == *(uint64_t **)(a1 + 32))
            {
              sub_1C625449C(a1 + 16, ((uint64_t)v114 - *(_QWORD *)(a1 + 16)) >> 2);
              v114 = *(uint64_t **)(a1 + 24);
            }
            *(_QWORD *)(a1 + 24) = v114 + 1;
            *v114 = v113;
            if ((v33 & 1) == 0)
              goto LABEL_210;
          }
          *(_QWORD *)a1 = v111 + 1;
LABEL_210:
          v150 = *(_QWORD *)(a1 + 24);
          v151 = (const void *)(*(_QWORD *)(a1 + 16) + 8 * v110);
          v152 = (uint64_t *)sub_1C484358C(a1 + 808, v150 - (_QWORD)v151, 3);
          v153 = v152;
          v154 = v150 - (_QWORD)v151;
          if (v154)
            memmove(v152, v151, v154);
          *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 16) + 8 * v110;
          if (((v154 != 8) & ~v33) != 0)
            return 0;
          v155 = v154 >> 3;
          v156 = v5[3];
          v157 = *(unsigned __int8 *)(a1 + 937);
          v413 = (char *)&v414 + 8;
          *(_QWORD *)&v414 = 0x2000000000;
          sub_1C5E01FCC(&v413, 64, v30, v153, v155, (char)v156 >> 1);
          v158 = sub_1C4F5AB38(v413, (uint64_t)v413 + 4 * v414);
          v160 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v158);
          v161 = *(unsigned int **)v160;
          *(_QWORD *)&v420 = v421;
          *((_QWORD *)&v420 + 1) = 0x2000000000;
          if (v161)
            v162 = (v161 & 1) == 0;
          else
            v162 = 0;
          if (!v162)
            goto LABEL_614;
          while (1)
          {
            LOBYTE(v158) = sub_1C5DFE6F4(v158, v161, (uint64_t)&v413, v159, (unsigned int *)&v420);
            if ((v158 & 1) != 0)
              break;
            DWORD2(v420) = 0;
            v161 = *(unsigned int **)v161;
            if (v161)
              v163 = (v161 & 1) == 0;
            else
              v163 = 0;
            if (!v163)
            {
              v161 = 0;
              goto LABEL_229;
            }
          }
          v160 = 0;
LABEL_229:
          if ((_QWORD *)v420 == v421)
          {
            if (v161)
            {
LABEL_231:
              v129 = 0;
              v10 = (uint64_t)(v161 + 2);
              goto LABEL_621;
            }
          }
          else
          {
            free((void *)v420);
            if (v161)
              goto LABEL_231;
          }
LABEL_614:
          if (v157)
          {
            v378 = sub_1C484358C(a1 + 808, 48, 3);
            *(_QWORD *)v378 = 0;
            *(_QWORD *)(v378 + 8) = &unk_1E816B058;
            v10 = v378 + 8;
            *(_BYTE *)(v378 + 16) = 64;
            *(_WORD *)(v378 + 17) = *(_WORD *)(v378 + 17) & 0xF000 | (v156 >> 1) | 0x540;
            *(_QWORD *)(v378 + 24) = v30;
            *(_QWORD *)(v378 + 32) = v153;
            *(_QWORD *)(v378 + 40) = v155;
            v379 = *(_DWORD *)(a1 + 916) + 1;
            v380 = *(_DWORD *)(a1 + 912);
            if (v379 > 2 * v380)
            {
              llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v380, (uint64_t)off_1E81A1260);
              *(_QWORD *)&v420 = v421;
              *((_QWORD *)&v420 + 1) = 0x2000000000;
              sub_1C5DFE788((unsigned int *)v378, (unsigned int *)&v420);
              v160 = *(_QWORD *)(a1 + 904)
                   + 8
                   * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38((_QWORD *)v420, v420 + 4 * DWORD2(v420)));
              if ((_QWORD *)v420 != v421)
                free((void *)v420);
              v379 = *(_DWORD *)(a1 + 916) + 1;
            }
            *(_DWORD *)(a1 + 916) = v379;
            v381 = *(_QWORD *)v160;
            if (!*(_QWORD *)v160)
              v381 = v160 | 1;
            *(_QWORD *)v378 = v381;
            *(_QWORD *)v160 = v378;
          }
          else
          {
LABEL_619:
            v10 = 0;
          }
LABEL_620:
          v129 = 1;
LABEL_621:
          v364 = v413;
LABEL_622:
          if (v364 == (__int128 *)((char *)&v414 + 8))
            goto LABEL_723;
          break;
        case 9:
          v71 = sub_1C5E042EC(a1);
          if (!v71)
            return 0;
          v72 = v71;
          v73 = sub_1C5E042EC(a1);
          if (!v73)
            return 0;
          v74 = v73;
          v75 = sub_1C5E042EC(a1);
          if (!v75)
            return 0;
          v76 = v75;
          v77 = v5[3];
          v78 = *(unsigned __int8 *)(a1 + 937);
          v413 = (char *)&v414 + 8;
          v415 = v72;
          v416 = v74;
          v417 = v75;
          v418[0] = (char)v77 >> 1;
          v418[1] = (char)v77 >> 31;
          v414 = xmmword_1C866FA70;
          v79 = sub_1C4F5AB38((_QWORD *)&v414 + 1, (uint64_t)&v419);
          v81 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v79);
          v26 = *(unsigned int **)v81;
          *(_QWORD *)&v420 = v421;
          *((_QWORD *)&v420 + 1) = 0x2000000000;
          if (!v26 || (v26 & 1) != 0)
            goto LABEL_608;
          while (1)
          {
            LOBYTE(v79) = sub_1C5DFE6F4(v79, v26, (uint64_t)&v413, v80, (unsigned int *)&v420);
            if ((v79 & 1) != 0)
              break;
            DWORD2(v420) = 0;
            v26 = *(unsigned int **)v26;
            if (v26)
              v82 = (v26 & 1) == 0;
            else
              v82 = 0;
            if (!v82)
            {
              v26 = 0;
              goto LABEL_225;
            }
          }
          v81 = 0;
LABEL_225:
          if ((_QWORD *)v420 == v421)
          {
            if (v26)
              goto LABEL_227;
          }
          else
          {
            free((void *)v420);
            if (v26)
              goto LABEL_227;
          }
LABEL_608:
          if (!v78)
            goto LABEL_636;
          v374 = sub_1C484358C(a1 + 808, 48, 3);
          *(_QWORD *)v374 = 0;
          *(_QWORD *)(v374 + 8) = &unk_1E816B0B0;
          v10 = v374 + 8;
          *(_BYTE *)(v374 + 16) = 53;
          *(_WORD *)(v374 + 17) = *(_WORD *)(v374 + 17) & 0xF000 | (v77 >> 1) | 0x540;
          *(_QWORD *)(v374 + 24) = v72;
          *(_QWORD *)(v374 + 32) = v74;
          *(_QWORD *)(v374 + 40) = v76;
          v375 = *(_DWORD *)(a1 + 916) + 1;
          v376 = *(_DWORD *)(a1 + 912);
          if (v375 > 2 * v376)
          {
            llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v376, (uint64_t)off_1E81A1260);
            *(_QWORD *)&v420 = v421;
            *((_QWORD *)&v420 + 1) = 0x2000000000;
            sub_1C5DFE788((unsigned int *)v374, (unsigned int *)&v420);
            v81 = *(_QWORD *)(a1 + 904)
                + 8
                * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38((_QWORD *)v420, v420 + 4 * DWORD2(v420)));
            if ((_QWORD *)v420 != v421)
              free((void *)v420);
            v375 = *(_DWORD *)(a1 + 916) + 1;
          }
          *(_DWORD *)(a1 + 916) = v375;
          v377 = *(_QWORD *)v81;
          if (!*(_QWORD *)v81)
            v377 = v81 | 1;
          *(_QWORD *)v374 = v377;
          *(_QWORD *)v81 = v374;
          goto LABEL_637;
        case 10:
          return v10;
        default:
          continue;
      }
      break;
    }
LABEL_722:
    free(v364);
    goto LABEL_723;
  }
  v13 = *(unsigned __int8 **)a1;
  v14 = *(unsigned __int8 **)(a1 + 8);
  v15 = (unint64_t)&v14[-*(_QWORD *)a1];
  if (v15 < 2)
    return 0;
  v16 = *v13;
  if (v16 == 76)
    return sub_1C5E09F20(a1);
  if (v14 != v13 && v16 == 84)
    return sub_1C5E08860(a1);
  if (v14 != v13 && v16 == 102)
  {
    v88 = (char *)(v13 + 1);
    v89 = v13[1];
    if (v89 == 112)
      return sub_1C5E0AF04(a1);
    if (v89 == 76)
    {
      if (v15 < 3)
      {
        v90 = 0;
LABEL_249:
        if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v90 + 60) & 0x400) == 0)
          goto LABEL_250;
        return sub_1C5E0AF04(a1);
      }
      if (((char)v13[2] & 0x80000000) == 0)
      {
        v90 = v13[2];
        goto LABEL_249;
      }
    }
LABEL_250:
    *(_QWORD *)a1 = v88;
    if (v14 == (unsigned __int8 *)v88)
      return 0;
    v10 = 0;
    v181 = *v88;
    if (v181 > 107)
    {
      if (v181 == 108)
      {
        v183 = 0;
        v182 = 1;
      }
      else
      {
        if (v181 != 114)
          return v10;
        v182 = 0;
        v183 = 0;
      }
    }
    else
    {
      if (v181 == 76)
      {
        v182 = 1;
      }
      else
      {
        if (v181 != 82)
          return v10;
        v182 = 0;
      }
      v183 = 1;
    }
    *(_QWORD *)a1 = v13 + 2;
    v236 = sub_1C5E098BC((unsigned __int8 **)a1);
    v10 = (uint64_t)v236;
    if (!v236)
      return v10;
    if (v236[2] != 2)
      return 0;
    v237 = sub_1C5E042EC(a1);
    if (!v237)
      return 0;
    v238 = v237;
    if (v183)
    {
      v239 = sub_1C5E042EC(a1);
      if (!v239)
        return 0;
    }
    else
    {
      v239 = 0;
    }
    v253 = v239 != 0;
    if ((v182 & v253) != 0)
      v254 = v238;
    else
      v254 = v239;
    if ((v182 & v253) != 0)
      v255 = v239;
    else
      v255 = v238;
    v256 = *(const char **)(v10 + 8);
    v257 = strlen(v256);
    v258 = (unsigned __int8 *)v256;
    if (*(unsigned __int8 *)(v10 + 2) <= 0xAu)
    {
      v259 = 8;
      if (v257 < 8)
        v259 = v257;
      v258 = (unsigned __int8 *)&v256[v259];
      if (v257 >= 9 && *v258 == 32)
        ++v258;
    }
    v260 = &v256[v257];
    v410 = *(unsigned __int8 *)(a1 + 937);
    v413 = (char *)&v414 + 8;
    v415 = v182;
    v414 = xmmword_1C866FB00;
    llvm::FoldingSetNodeID::AddString((unsigned int *)&v413, v258, (_DWORD)v256 + v257 - (_DWORD)v258);
    v261 = v414;
    if (v414 >= DWORD1(v414))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v413, (uint64_t)&v414 + 8, v414 + 1, 4);
      v261 = v414;
    }
    *((_DWORD *)v413 + v261) = v255;
    v262 = (v414 + 1);
    LODWORD(v414) = v262;
    if (v262 >= DWORD1(v414))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v413, (uint64_t)&v414 + 8, v262 + 1, 4);
      LODWORD(v262) = v414;
    }
    *((_DWORD *)v413 + v262) = HIDWORD(v255);
    v263 = (v414 + 1);
    LODWORD(v414) = v263;
    if (v263 >= DWORD1(v414))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v413, (uint64_t)&v414 + 8, v263 + 1, 4);
      LODWORD(v263) = v414;
    }
    *((_DWORD *)v413 + v263) = v254;
    v264 = (v414 + 1);
    LODWORD(v414) = v264;
    if (v264 >= DWORD1(v414))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v413, (uint64_t)&v414 + 8, v264 + 1, 4);
      LODWORD(v264) = v414;
    }
    *((_DWORD *)v413 + v264) = HIDWORD(v254);
    LODWORD(v414) = v414 + 1;
    v265 = sub_1C4F5AB38(v413, (uint64_t)v413 + 4 * v414);
    v267 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v265);
    v26 = *(unsigned int **)v267;
    *(_QWORD *)&v420 = v421;
    *((_QWORD *)&v420 + 1) = 0x2000000000;
    if (v26 && (v26 & 1) == 0)
    {
      while (1)
      {
        LOBYTE(v265) = sub_1C5DFE6F4(v265, v26, (uint64_t)&v413, v266, (unsigned int *)&v420);
        if ((v265 & 1) != 0)
          break;
        DWORD2(v420) = 0;
        v26 = *(unsigned int **)v26;
        if (v26)
          v268 = (v26 & 1) == 0;
        else
          v268 = 0;
        if (!v268)
        {
          v26 = 0;
          goto LABEL_387;
        }
      }
      v267 = 0;
LABEL_387:
      if ((_QWORD *)v420 == v421)
      {
        if (!v26)
          goto LABEL_389;
LABEL_227:
        v164 = 0;
        v10 = (uint64_t)(v26 + 2);
        goto LABEL_638;
      }
      free((void *)v420);
      if (v26)
        goto LABEL_227;
    }
LABEL_389:
    if (v410)
    {
      v269 = sub_1C484358C(a1 + 808, 64, 3);
      *(_QWORD *)v269 = 0;
      *(_QWORD *)(v269 + 8) = &unk_1E816B738;
      v10 = v269 + 8;
      *(_BYTE *)(v269 + 16) = 67;
      *(_WORD *)(v269 + 17) = *(_WORD *)(v269 + 17) & 0xF000 | 0x540;
      *(_QWORD *)(v269 + 24) = v255;
      *(_QWORD *)(v269 + 32) = v254;
      *(_QWORD *)(v269 + 40) = v258;
      *(_QWORD *)(v269 + 48) = v260;
      *(_BYTE *)(v269 + 56) = v182;
      v270 = *(_DWORD *)(a1 + 916) + 1;
      v271 = *(_DWORD *)(a1 + 912);
      if (v270 > 2 * v271)
      {
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v271, (uint64_t)off_1E81A1260);
        *(_QWORD *)&v420 = v421;
        *((_QWORD *)&v420 + 1) = 0x2000000000;
        sub_1C5DFE788((unsigned int *)v269, (unsigned int *)&v420);
        v267 = *(_QWORD *)(a1 + 904)
             + 8
             * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38((_QWORD *)v420, v420 + 4 * DWORD2(v420)));
        if ((_QWORD *)v420 != v421)
          free((void *)v420);
        v270 = *(_DWORD *)(a1 + 916) + 1;
      }
      *(_DWORD *)(a1 + 916) = v270;
      v272 = *(_QWORD *)v267;
      if (!*(_QWORD *)v267)
        v272 = v267 | 1;
      *(_QWORD *)v269 = v272;
      *(_QWORD *)v267 = v269;
      goto LABEL_637;
    }
LABEL_636:
    v10 = 0;
LABEL_637:
    v164 = 1;
LABEL_638:
    if (v413 != (char *)&v414 + 8)
      free(v413);
    if (v164)
      goto LABEL_724;
    goto LABEL_641;
  }
  if (!strncmp("il", *(const char **)a1, 2uLL))
  {
    v145 = v13 + 2;
    *(_QWORD *)a1 = v13 + 2;
    v146 = (uint64_t)(*(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16)) >> 3;
    while (v145 == v14 || *v145 != 69)
    {
      v147 = sub_1C5E0B040(a1);
      if (!v147)
        return 0;
      v148 = v147;
      v149 = *(uint64_t **)(a1 + 24);
      if (v149 == *(uint64_t **)(a1 + 32))
      {
        sub_1C625449C(a1 + 16, ((uint64_t)v149 - *(_QWORD *)(a1 + 16)) >> 2);
        v149 = *(uint64_t **)(a1 + 24);
      }
      *(_QWORD *)(a1 + 24) = v149 + 1;
      *v149 = v148;
      v145 = *(unsigned __int8 **)a1;
      v14 = *(unsigned __int8 **)(a1 + 8);
    }
    *(_QWORD *)a1 = v145 + 1;
    v194 = *(_BYTE **)(a1 + 24);
    v195 = (_BYTE *)(*(_QWORD *)(a1 + 16) + 8 * v146);
    v196 = (uint64_t *)sub_1C484358C(a1 + 808, v194 - v195, 3);
    v197 = v196;
    v198 = v194 - v195;
    if (v194 != v195)
      memmove(v196, v195, v194 - v195);
    v199 = v198 >> 3;
    *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 16) + 8 * v146;
    v200 = *(unsigned __int8 *)(a1 + 937);
    v413 = (char *)&v414 + 8;
    v415 = 0;
    v416 = v198 >> 3;
    v414 = xmmword_1C866FAF0;
    if (v194 == v195)
    {
      v202 = 6;
      v235 = (_QWORD *)&v414 + 1;
    }
    else
    {
      v201 = 8 * v199;
      LODWORD(v202) = 6;
      v203 = v197;
      do
      {
        v204 = *v203;
        if (v202 >= DWORD1(v414))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v413, (uint64_t)&v414 + 8, v202 + 1, 4);
          LODWORD(v202) = v414;
        }
        *((_DWORD *)v413 + v202) = v204;
        v205 = (v414 + 1);
        LODWORD(v414) = v205;
        if (v205 >= DWORD1(v414))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v413, (uint64_t)&v414 + 8, v205 + 1, 4);
          LODWORD(v205) = v414;
        }
        *((_DWORD *)v413 + v205) = HIDWORD(v204);
        v202 = (v414 + 1);
        LODWORD(v414) = v414 + 1;
        ++v203;
        v201 -= 8;
      }
      while (v201);
      v235 = v413;
    }
    v240 = sub_1C4F5AB38(v235, (uint64_t)v235 + 4 * v202);
    v242 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v240);
    v243 = *(unsigned int **)v242;
    *(_QWORD *)&v420 = v421;
    *((_QWORD *)&v420 + 1) = 0x2000000000;
    if (v243)
      v244 = (v243 & 1) == 0;
    else
      v244 = 0;
    if (!v244)
    {
LABEL_631:
      if (v200)
      {
        v382 = sub_1C484358C(a1 + 808, 48, 3);
        *(_QWORD *)v382 = 0;
        *(_QWORD *)(v382 + 8) = &unk_1E816B898;
        v10 = v382 + 8;
        *(_BYTE *)(v382 + 16) = 66;
        *(_WORD *)(v382 + 17) = *(_WORD *)(v382 + 17) & 0xF000 | 0x540;
        *(_QWORD *)(v382 + 24) = 0;
        *(_QWORD *)(v382 + 32) = v197;
        *(_QWORD *)(v382 + 40) = v199;
        v383 = *(_DWORD *)(a1 + 916) + 1;
        v384 = *(_DWORD *)(a1 + 912);
        if (v383 > 2 * v384)
        {
          llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v384, (uint64_t)off_1E81A1260);
          *(_QWORD *)&v420 = v421;
          *((_QWORD *)&v420 + 1) = 0x2000000000;
          sub_1C5DFE788((unsigned int *)v382, (unsigned int *)&v420);
          v242 = *(_QWORD *)(a1 + 904)
               + 8
               * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38((_QWORD *)v420, v420 + 4 * DWORD2(v420)));
          if ((_QWORD *)v420 != v421)
            free((void *)v420);
          v383 = *(_DWORD *)(a1 + 916) + 1;
        }
        *(_DWORD *)(a1 + 916) = v383;
        v385 = *(_QWORD *)v242;
        if (!*(_QWORD *)v242)
          v385 = v242 | 1;
        *(_QWORD *)v382 = v385;
        *(_QWORD *)v242 = v382;
        goto LABEL_637;
      }
      goto LABEL_636;
    }
    while (1)
    {
      LOBYTE(v240) = sub_1C5DFE6F4(v240, v243, (uint64_t)&v413, v241, (unsigned int *)&v420);
      if ((v240 & 1) != 0)
        break;
      DWORD2(v420) = 0;
      v243 = *(unsigned int **)v243;
      if (v243)
        v245 = (v243 & 1) == 0;
      else
        v245 = 0;
      if (!v245)
      {
        v243 = 0;
        goto LABEL_338;
      }
    }
    v242 = 0;
LABEL_338:
    if ((_QWORD *)v420 == v421)
    {
      if (!v243)
        goto LABEL_631;
    }
    else
    {
      free((void *)v420);
      if (!v243)
        goto LABEL_631;
    }
    v164 = 0;
    v10 = (uint64_t)(v243 + 2);
    goto LABEL_638;
  }
  if (!strncmp("mc", (const char *)v13, 2uLL))
  {
    *(_QWORD *)a1 = v13 + 2;
    v165 = sub_1C5DF9EB0(a1);
    if (!v165)
      return 0;
    v166 = v165;
    v167 = sub_1C5E042EC(a1);
    if (!v167)
      return 0;
    v168 = v167;
    v169 = (unsigned __int8 *)sub_1C54C21F4((char **)a1, 1);
    v171 = *(unsigned __int8 **)a1;
    if (*(_QWORD *)a1 == *(_QWORD *)(a1 + 8) || *v171 != 69)
      return 0;
    v172 = v169;
    v173 = v170;
    *(_QWORD *)a1 = v171 + 1;
    v174 = *(unsigned __int8 *)(a1 + 937);
    v413 = (char *)&v414 + 8;
    v415 = v166;
    v416 = v168;
    v414 = xmmword_1C866FAE0;
    llvm::FoldingSetNodeID::AddString((unsigned int *)&v413, v169, v170 - (_DWORD)v169);
    v175 = v414;
    if (v414 >= DWORD1(v414))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v413, (uint64_t)&v414 + 8, v414 + 1, 4);
      v175 = v414;
    }
    *((_DWORD *)v413 + v175) = 2;
    v176 = (v414 + 1);
    LODWORD(v414) = v176;
    if (v176 >= DWORD1(v414))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v413, (uint64_t)&v414 + 8, v176 + 1, 4);
      LODWORD(v176) = v414;
    }
    *((_DWORD *)v413 + v176) = 0;
    LODWORD(v414) = v414 + 1;
    v177 = sub_1C4F5AB38(v413, (uint64_t)v413 + 4 * v414);
    v179 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v177);
    v26 = *(unsigned int **)v179;
    *(_QWORD *)&v420 = v421;
    *((_QWORD *)&v420 + 1) = 0x2000000000;
    if (v26 && (v26 & 1) == 0)
    {
      while (1)
      {
        LOBYTE(v177) = sub_1C5DFE6F4(v177, v26, (uint64_t)&v413, v178, (unsigned int *)&v420);
        if ((v177 & 1) != 0)
          break;
        DWORD2(v420) = 0;
        v26 = *(unsigned int **)v26;
        if (v26)
          v180 = (v26 & 1) == 0;
        else
          v180 = 0;
        if (!v180)
        {
          v26 = 0;
          goto LABEL_405;
        }
      }
      v179 = 0;
LABEL_405:
      if ((_QWORD *)v420 == v421)
      {
        if (v26)
          goto LABEL_227;
      }
      else
      {
        free((void *)v420);
        if (v26)
          goto LABEL_227;
      }
    }
    if (v174)
    {
      v279 = sub_1C484358C(a1 + 808, 56, 3);
      *(_QWORD *)v279 = 0;
      *(_QWORD *)(v279 + 8) = &unk_1E816B8F0;
      v10 = v279 + 8;
      *(_BYTE *)(v279 + 16) = 65;
      *(_WORD *)(v279 + 17) = *(_WORD *)(v279 + 17) & 0xF000 | 0x542;
      *(_QWORD *)(v279 + 24) = v166;
      *(_QWORD *)(v279 + 32) = v168;
      *(_QWORD *)(v279 + 40) = v172;
      *(_QWORD *)(v279 + 48) = v173;
      v280 = *(_DWORD *)(a1 + 916) + 1;
      v281 = *(_DWORD *)(a1 + 912);
      if (v280 > 2 * v281)
      {
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v281, (uint64_t)off_1E81A1260);
        *(_QWORD *)&v420 = v421;
        *((_QWORD *)&v420 + 1) = 0x2000000000;
        sub_1C5DFE788((unsigned int *)v279, (unsigned int *)&v420);
        v179 = *(_QWORD *)(a1 + 904)
             + 8
             * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38((_QWORD *)v420, v420 + 4 * DWORD2(v420)));
        if ((_QWORD *)v420 != v421)
          free((void *)v420);
        v280 = *(_DWORD *)(a1 + 916) + 1;
      }
      *(_DWORD *)(a1 + 916) = v280;
      v282 = *(_QWORD *)v179;
      if (!*(_QWORD *)v179)
        v282 = v179 | 1;
      *(_QWORD *)v279 = v282;
      *(_QWORD *)v179 = v279;
      goto LABEL_637;
    }
    goto LABEL_636;
  }
  if (!strncmp("nx", (const char *)v13, 2uLL))
  {
    *(_QWORD *)a1 = v13 + 2;
    v184 = sub_1C5E042EC(a1);
    if (v184)
    {
      v185 = v184;
      v186 = *(unsigned __int8 *)(a1 + 937);
      v413 = (char *)&v414 + 8;
      v414 = xmmword_1C866FAD0;
      llvm::FoldingSetNodeID::AddString((unsigned int *)&v413, "noexcept ", 9u);
      v187 = v414;
      if (v414 >= DWORD1(v414))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v413, (uint64_t)&v414 + 8, v414 + 1, 4);
        v187 = v414;
      }
      *((_DWORD *)v413 + v187) = v185;
      v188 = (v414 + 1);
      LODWORD(v414) = v188;
      if (v188 >= DWORD1(v414))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v413, (uint64_t)&v414 + 8, v188 + 1, 4);
        LODWORD(v188) = v414;
      }
      *((_DWORD *)v413 + v188) = HIDWORD(v185);
      v189 = (v414 + 1);
      LODWORD(v414) = v189;
      if (v189 >= DWORD1(v414))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v413, (uint64_t)&v414 + 8, v189 + 1, 4);
        LODWORD(v189) = v414;
      }
      *((_DWORD *)v413 + v189) = 2;
      v190 = (v414 + 1);
      LODWORD(v414) = v190;
      if (v190 >= DWORD1(v414))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v413, (uint64_t)&v414 + 8, v190 + 1, 4);
        LODWORD(v190) = v414;
      }
      *((_DWORD *)v413 + v190) = 0;
      LODWORD(v414) = v414 + 1;
      v191 = sub_1C4F5AB38(v413, (uint64_t)v413 + 4 * v414);
      v25 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v191);
      v26 = *(unsigned int **)v25;
      *(_QWORD *)&v420 = v421;
      *((_QWORD *)&v420 + 1) = 0x2000000000;
      if (v26 && (v26 & 1) == 0)
      {
        while (1)
        {
          LOBYTE(v191) = sub_1C5DFE6F4(v191, v26, (uint64_t)&v413, v192, (unsigned int *)&v420);
          if ((v191 & 1) != 0)
            break;
          DWORD2(v420) = 0;
          v26 = *(unsigned int **)v26;
          if (v26)
            v193 = (v26 & 1) == 0;
          else
            v193 = 0;
          if (!v193)
          {
            v26 = 0;
            goto LABEL_342;
          }
        }
        v25 = 0;
LABEL_342:
        if ((_QWORD *)v420 == v421)
        {
          if (v26)
            goto LABEL_227;
        }
        else
        {
          free((void *)v420);
          if (v26)
            goto LABEL_227;
        }
      }
      if (v186)
      {
        v141 = sub_1C484358C(a1 + 808, 64, 3);
        *(_QWORD *)(v141 + 8) = &unk_1E816B160;
        v10 = v141 + 8;
        *(_QWORD *)v141 = 0;
        *(_BYTE *)(v141 + 16) = 56;
        *(_WORD *)(v141 + 17) = *(_WORD *)(v141 + 17) & 0xF000 | 0x542;
        *(_QWORD *)(v141 + 24) = "noexcept ";
        *(_QWORD *)(v141 + 32) = "";
        *(_QWORD *)(v141 + 48) = 0;
        *(_QWORD *)(v141 + 56) = 0;
        *(_QWORD *)(v141 + 40) = v185;
LABEL_190:
        v142 = *(_DWORD *)(a1 + 916) + 1;
        v143 = *(_DWORD *)(a1 + 912);
        if (v142 > 2 * v143)
        {
          llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v143, (uint64_t)off_1E81A1260);
          *(_QWORD *)&v420 = v421;
          *((_QWORD *)&v420 + 1) = 0x2000000000;
          sub_1C5DFE788((unsigned int *)v141, (unsigned int *)&v420);
          v25 = *(_QWORD *)(a1 + 904)
              + 8
              * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38((_QWORD *)v420, v420 + 4 * DWORD2(v420)));
          if ((_QWORD *)v420 != v421)
            free((void *)v420);
          v142 = *(_DWORD *)(a1 + 916) + 1;
        }
        *(_DWORD *)(a1 + 916) = v142;
        v144 = *(_QWORD *)v25;
        if (!*(_QWORD *)v25)
          v144 = v25 | 1;
        *(_QWORD *)v141 = v144;
        *(_QWORD *)v25 = v141;
        goto LABEL_637;
      }
      goto LABEL_636;
    }
    return 0;
  }
  if (!strncmp("so", (const char *)v13, 2uLL))
  {
    *(_QWORD *)a1 = v13 + 2;
    v218 = sub_1C5DF9EB0(a1);
    if (!v218)
      return 0;
    v219 = v218;
    v220 = sub_1C5E042EC(a1);
    if (!v220)
      return 0;
    v221 = v220;
    v222 = sub_1C54C21F4((char **)a1, 1);
    v224 = *(unsigned __int8 **)a1;
    v225 = *(unsigned __int8 **)(a1 + 8);
    if (*(unsigned __int8 **)a1 == v225)
      return 0;
    v226 = (unsigned __int8 *)v222;
    v227 = v223;
    v228 = *(_QWORD *)(a1 + 16);
    v229 = *(_QWORD *)(a1 + 24);
    while (1)
    {
      v230 = *v224;
      if (v230 != 95)
        break;
      *(_QWORD *)a1 = v224 + 1;
      *(_QWORD *)&v420 = sub_1C54C21F4((char **)a1, 0);
      *((_QWORD *)&v420 + 1) = v231;
      v232 = sub_1C5E04030(a1, &v420);
      if (v232)
      {
        v233 = v232;
        v234 = *(uint64_t **)(a1 + 24);
        if (v234 == *(uint64_t **)(a1 + 32))
        {
          sub_1C625449C(a1 + 16, ((uint64_t)v234 - *(_QWORD *)(a1 + 16)) >> 2);
          v234 = *(uint64_t **)(a1 + 24);
        }
        *(_QWORD *)(a1 + 24) = v234 + 1;
        *v234 = v233;
        v224 = *(unsigned __int8 **)a1;
        v225 = *(unsigned __int8 **)(a1 + 8);
        if (*(unsigned __int8 **)a1 != v225)
          continue;
      }
      return 0;
    }
    if (v230 == 112)
      *(_QWORD *)a1 = ++v224;
    if (v224 == v225)
      return 0;
    v408 = v230 == 112;
    v411 = v227;
    if (*v224 != 69)
      return 0;
    v283 = (v229 - v228) >> 3;
    *(_QWORD *)a1 = v224 + 1;
    v284 = *(_BYTE **)(a1 + 24);
    v285 = (_BYTE *)(*(_QWORD *)(a1 + 16) + 8 * v283);
    v286 = (_QWORD *)sub_1C484358C(a1 + 808, v284 - v285, 3);
    v287 = v286;
    if (v284 != v285)
      memmove(v286, v285, v284 - v285);
    v406 = v287;
    v288 = (v284 - v285) >> 3;
    *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 16) + 8 * v283;
    v404 = *(unsigned __int8 *)(a1 + 937);
    v413 = (char *)&v414 + 8;
    v415 = v219;
    v416 = v221;
    v414 = xmmword_1C866FAC0;
    llvm::FoldingSetNodeID::AddString((unsigned int *)&v413, v226, v411 - (_DWORD)v226);
    v289 = v414;
    if (v414 >= DWORD1(v414))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v413, (uint64_t)&v414 + 8, v414 + 1, 4);
      v289 = v414;
    }
    *((_DWORD *)v413 + v289) = v288;
    v290 = (v414 + 1);
    LODWORD(v414) = v290;
    if (v290 >= DWORD1(v414))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v413, (uint64_t)&v414 + 8, v290 + 1, 4);
      LODWORD(v290) = v414;
    }
    *((_DWORD *)v413 + v290) = HIDWORD(v288);
    v291 = v414 + 1;
    LODWORD(v414) = v414 + 1;
    if (v284 != v285)
    {
      v292 = 8 * v288;
      v293 = v287;
      do
      {
        v294 = *v293;
        if (v291 >= DWORD1(v414))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v413, (uint64_t)&v414 + 8, v291 + 1, 4);
          v291 = v414;
        }
        *((_DWORD *)v413 + v291) = v294;
        v295 = (v414 + 1);
        LODWORD(v414) = v295;
        if (v295 >= DWORD1(v414))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v413, (uint64_t)&v414 + 8, v295 + 1, 4);
          LODWORD(v295) = v414;
        }
        *((_DWORD *)v413 + v295) = HIDWORD(v294);
        v291 = v414 + 1;
        LODWORD(v414) = v414 + 1;
        ++v293;
        v292 -= 8;
      }
      while (v292);
    }
    if (v291 >= DWORD1(v414))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v413, (uint64_t)&v414 + 8, v291 + 1, 4);
      v291 = v414;
    }
    *((_DWORD *)v413 + v291) = v230 == 112;
    v322 = (v414 + 1);
    LODWORD(v414) = v322;
    if (v322 >= DWORD1(v414))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v413, (uint64_t)&v414 + 8, v322 + 1, 4);
      LODWORD(v322) = v414;
    }
    *((_DWORD *)v413 + v322) = 0;
    LODWORD(v414) = v414 + 1;
    v323 = sub_1C4F5AB38(v413, (uint64_t)v413 + 4 * v414);
    v325 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v323);
    v326 = *(unsigned int **)v325;
    *(_QWORD *)&v420 = v421;
    *((_QWORD *)&v420 + 1) = 0x2000000000;
    if (v326)
      v327 = (v326 & 1) == 0;
    else
      v327 = 0;
    if (!v327)
      goto LABEL_702;
    while (1)
    {
      LOBYTE(v323) = sub_1C5DFE6F4(v323, v326, (uint64_t)&v413, v324, (unsigned int *)&v420);
      if ((v323 & 1) != 0)
        break;
      DWORD2(v420) = 0;
      v326 = *(unsigned int **)v326;
      if (v326)
        v328 = (v326 & 1) == 0;
      else
        v328 = 0;
      if (!v328)
      {
        v326 = 0;
        goto LABEL_505;
      }
    }
    v325 = 0;
LABEL_505:
    if ((_QWORD *)v420 == v421)
    {
      if (v326)
      {
LABEL_507:
        v129 = 0;
        v10 = (uint64_t)(v326 + 2);
        goto LABEL_709;
      }
    }
    else
    {
      free((void *)v420);
      if (v326)
        goto LABEL_507;
    }
LABEL_702:
    if (v404)
    {
      v399 = sub_1C484358C(a1 + 808, 80, 3);
      *(_QWORD *)v399 = 0;
      *(_QWORD *)(v399 + 8) = &unk_1E816B948;
      v10 = v399 + 8;
      *(_BYTE *)(v399 + 16) = 55;
      *(_WORD *)(v399 + 17) = *(_WORD *)(v399 + 17) & 0xF000 | 0x540;
      *(_QWORD *)(v399 + 24) = v219;
      *(_QWORD *)(v399 + 32) = v221;
      *(_QWORD *)(v399 + 40) = v226;
      *(_QWORD *)(v399 + 48) = v411;
      *(_QWORD *)(v399 + 56) = v406;
      *(_QWORD *)(v399 + 64) = v288;
      *(_BYTE *)(v399 + 72) = v408;
      v400 = *(_DWORD *)(a1 + 916) + 1;
      v401 = *(_DWORD *)(a1 + 912);
      if (v400 > 2 * v401)
      {
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v401, (uint64_t)off_1E81A1260);
        *(_QWORD *)&v420 = v421;
        *((_QWORD *)&v420 + 1) = 0x2000000000;
        sub_1C5DFE788((unsigned int *)v399, (unsigned int *)&v420);
        v325 = *(_QWORD *)(a1 + 904)
             + 8
             * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38((_QWORD *)v420, v420 + 4 * DWORD2(v420)));
        if ((_QWORD *)v420 != v421)
          free((void *)v420);
        v400 = *(_DWORD *)(a1 + 916) + 1;
      }
      *(_DWORD *)(a1 + 916) = v400;
      v402 = *(_QWORD *)v325;
      if (!*(_QWORD *)v325)
        v402 = v325 | 1;
      *(_QWORD *)v399 = v402;
      *(_QWORD *)v325 = v399;
    }
    else
    {
      v10 = 0;
    }
    v129 = 1;
LABEL_709:
    v364 = v413;
    if (v413 == (char *)&v414 + 8)
      goto LABEL_723;
    goto LABEL_722;
  }
  if (!strncmp("sp", (const char *)v13, 2uLL))
  {
    *(_QWORD *)a1 = v13 + 2;
    *(_QWORD *)&v420 = sub_1C5E042EC(a1);
    if (!(_QWORD)v420)
      return 0;
    return sub_1C5E081BC(a1, (uint64_t *)&v420);
  }
  if (!strncmp("sZ", (const char *)v13, 2uLL))
  {
    *(_QWORD *)a1 = v13 + 2;
    if (v14 != v13 + 2 && v13[2] == 84)
    {
      v246 = sub_1C5E08860(a1);
      if (!v246)
        return 0;
      v247 = v246;
      v248 = *(unsigned __int8 *)(a1 + 937);
      v413 = (char *)&v414 + 8;
      v415 = v246;
      v414 = xmmword_1C866FAB0;
      v249 = sub_1C4F5AB38((_QWORD *)&v414 + 1, (uint64_t)&v416);
      v251 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v249);
      v26 = *(unsigned int **)v251;
      *(_QWORD *)&v420 = v421;
      *((_QWORD *)&v420 + 1) = 0x2000000000;
      if (v26 && (v26 & 1) == 0)
      {
        while (1)
        {
          LOBYTE(v249) = sub_1C5DFE6F4(v249, v26, (uint64_t)&v413, v250, (unsigned int *)&v420);
          if ((v249 & 1) != 0)
            break;
          DWORD2(v420) = 0;
          v26 = *(unsigned int **)v26;
          if (v26)
            v252 = (v26 & 1) == 0;
          else
            v252 = 0;
          if (!v252)
          {
            v26 = 0;
            goto LABEL_487;
          }
        }
        v251 = 0;
LABEL_487:
        if ((_QWORD *)v420 == v421)
        {
          if (v26)
            goto LABEL_227;
        }
        else
        {
          free((void *)v420);
          if (v26)
            goto LABEL_227;
        }
      }
      if (!v248)
        goto LABEL_636;
      v330 = sub_1C484358C(a1 + 808, 32, 3);
      v331 = (unsigned int *)v330;
      *(_QWORD *)v330 = 0;
      *(_QWORD *)(v330 + 8) = &unk_1E816B9A0;
      v10 = v330 + 8;
      v332 = 58;
      goto LABEL_513;
    }
    *(_QWORD *)&v420 = sub_1C5E0AF04(a1);
    if (!(_QWORD)v420)
      return 0;
    v273 = (uint64_t *)&v420;
    return sub_1C5E0B444(a1, v273);
  }
  if (!strncmp("sP", (const char *)v13, 2uLL))
  {
    v274 = v13 + 2;
    *(_QWORD *)a1 = v13 + 2;
    v275 = (uint64_t)(*(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16)) >> 3;
    while (v274 == v14 || *v274 != 69)
    {
      v276 = sub_1C5E0B790(a1);
      if (!v276)
        return 0;
      v277 = v276;
      v278 = *(uint64_t **)(a1 + 24);
      if (v278 == *(uint64_t **)(a1 + 32))
      {
        sub_1C625449C(a1 + 16, ((uint64_t)v278 - *(_QWORD *)(a1 + 16)) >> 2);
        v278 = *(uint64_t **)(a1 + 24);
      }
      *(_QWORD *)(a1 + 24) = v278 + 1;
      *v278 = v277;
      v274 = *(unsigned __int8 **)a1;
      v14 = *(unsigned __int8 **)(a1 + 8);
    }
    *(_QWORD *)a1 = v274 + 1;
    v412 = 0;
    v303 = *(_QWORD *)(a1 + 24);
    v304 = (const void *)(*(_QWORD *)(a1 + 16) + 8 * v275);
    v305 = (uint64_t *)sub_1C484358C(a1 + 808, v303 - (_QWORD)v304, 3);
    v306 = v305;
    v307 = v303 - (_QWORD)v304;
    if (v307)
      memmove(v305, v304, v307);
    v308 = v307 >> 3;
    *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 16) + 8 * v275;
    v309 = *(unsigned __int8 *)(a1 + 937);
    v413 = (char *)&v414 + 8;
    *(_QWORD *)&v414 = 0x2000000000;
    sub_1C5E0169C(&v413, 0, v306, v307 >> 3);
    v310 = sub_1C4F5AB38(v413, (uint64_t)v413 + 4 * v414);
    v312 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v310);
    v313 = *(unsigned int **)v312;
    *(_QWORD *)&v420 = v421;
    *((_QWORD *)&v420 + 1) = 0x2000000000;
    if (v313)
      v314 = (v313 & 1) == 0;
    else
      v314 = 0;
    if (!v314)
      goto LABEL_673;
    while (1)
    {
      LOBYTE(v310) = sub_1C5DFE6F4(v310, v313, (uint64_t)&v413, v311, (unsigned int *)&v420);
      if ((v310 & 1) != 0)
        break;
      DWORD2(v420) = 0;
      v313 = *(unsigned int **)v313;
      if (v313)
        v315 = (v313 & 1) == 0;
      else
        v315 = 0;
      if (!v315)
      {
        v313 = 0;
        goto LABEL_462;
      }
    }
    v312 = 0;
LABEL_462:
    if ((_QWORD *)v420 == v421)
    {
      if (v313)
      {
LABEL_464:
        v321 = 0;
        v10 = (uint64_t)(v313 + 2);
LABEL_680:
        if (v413 != (char *)&v414 + 8)
          free(v413);
        if (v321)
        {
          *(_QWORD *)(a1 + 920) = v10;
        }
        else
        {
          if (!v10)
            return v10;
          *(_QWORD *)&v420 = 0;
          v397 = sub_1C627E01C(a1 + 944, v10, &v420);
          v398 = 0;
          if (v397)
            v398 = *(_QWORD *)(v420 + 8);
          if (v398)
            v10 = v398;
          if (v10 == *(_QWORD *)(a1 + 928))
            *(_BYTE *)(a1 + 936) = 1;
        }
        v412 = v10;
        if (!v10)
          return v10;
        v273 = &v412;
        return sub_1C5E0B444(a1, v273);
      }
    }
    else
    {
      free((void *)v420);
      if (v313)
        goto LABEL_464;
    }
LABEL_673:
    if (v309)
    {
      v393 = sub_1C484358C(a1 + 808, 40, 3);
      *(_QWORD *)v393 = 0;
      *(_QWORD *)(v393 + 8) = &unk_1E816B9F8;
      v10 = v393 + 8;
      *(_BYTE *)(v393 + 16) = 0;
      *(_WORD *)(v393 + 17) = *(_WORD *)(v393 + 17) & 0xF000 | 0x540;
      *(_QWORD *)(v393 + 24) = v306;
      *(_QWORD *)(v393 + 32) = v308;
      v394 = *(_DWORD *)(a1 + 916) + 1;
      v395 = *(_DWORD *)(a1 + 912);
      if (v394 > 2 * v395)
      {
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v395, (uint64_t)off_1E81A1260);
        *(_QWORD *)&v420 = v421;
        *((_QWORD *)&v420 + 1) = 0x2000000000;
        sub_1C5DFE788((unsigned int *)v393, (unsigned int *)&v420);
        v312 = *(_QWORD *)(a1 + 904)
             + 8
             * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38((_QWORD *)v420, v420 + 4 * DWORD2(v420)));
        if ((_QWORD *)v420 != v421)
          free((void *)v420);
        v394 = *(_DWORD *)(a1 + 916) + 1;
      }
      *(_DWORD *)(a1 + 916) = v394;
      v396 = *(_QWORD *)v312;
      if (!*(_QWORD *)v312)
        v396 = v312 | 1;
      *(_QWORD *)v393 = v396;
      *(_QWORD *)v312 = v393;
    }
    else
    {
      v10 = 0;
    }
    v321 = 1;
    goto LABEL_680;
  }
  if (!strncmp("tl", (const char *)v13, 2uLL))
  {
    *(_QWORD *)a1 = v13 + 2;
    v296 = sub_1C5DF9EB0(a1);
    if (!v296)
      return 0;
    v297 = v296;
    v298 = (uint64_t)(*(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16)) >> 3;
    while (1)
    {
      v299 = *(unsigned __int8 **)a1;
      if (*(_QWORD *)a1 != *(_QWORD *)(a1 + 8) && *v299 == 69)
        break;
      v300 = sub_1C5E0B040(a1);
      if (!v300)
        return 0;
      v301 = v300;
      v302 = *(uint64_t **)(a1 + 24);
      if (v302 == *(uint64_t **)(a1 + 32))
      {
        sub_1C625449C(a1 + 16, ((uint64_t)v302 - *(_QWORD *)(a1 + 16)) >> 2);
        v302 = *(uint64_t **)(a1 + 24);
      }
      *(_QWORD *)(a1 + 24) = v302 + 1;
      *v302 = v301;
    }
    *(_QWORD *)a1 = v299 + 1;
    v333 = *(_QWORD *)(a1 + 24);
    v334 = (const void *)(*(_QWORD *)(a1 + 16) + 8 * v298);
    v335 = (uint64_t *)sub_1C484358C(a1 + 808, v333 - (_QWORD)v334, 3);
    v336 = v335;
    v337 = v333 - (_QWORD)v334;
    if (v337)
      memmove(v335, v334, v337);
    v338 = v337 >> 3;
    *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 16) + 8 * v298;
    v339 = *(unsigned __int8 *)(a1 + 937);
    v413 = (char *)&v414 + 8;
    *(_QWORD *)&v414 = 0x2000000000;
    sub_1C5E01858(&v413, 66, v297, v336, v337 >> 3);
    v340 = sub_1C4F5AB38(v413, (uint64_t)v413 + 4 * v414);
    v52 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v340);
    v342 = *(unsigned int **)v52;
    *(_QWORD *)&v420 = v421;
    *((_QWORD *)&v420 + 1) = 0x2000000000;
    if (v342)
      v343 = (v342 & 1) == 0;
    else
      v343 = 0;
    if (!v343)
      goto LABEL_717;
    while (1)
    {
      LOBYTE(v340) = sub_1C5DFE6F4(v340, v342, (uint64_t)&v413, v341, (unsigned int *)&v420);
      if ((v340 & 1) != 0)
        break;
      DWORD2(v420) = 0;
      v342 = *(unsigned int **)v342;
      if (v342)
        v344 = (v342 & 1) == 0;
      else
        v344 = 0;
      if (!v344)
      {
        v342 = 0;
        goto LABEL_518;
      }
    }
    v52 = 0;
LABEL_518:
    if ((_QWORD *)v420 == v421)
    {
      if (v342)
      {
LABEL_520:
        v129 = 0;
        v10 = (uint64_t)(v342 + 2);
LABEL_721:
        v364 = v413;
        if (v413 == (char *)&v414 + 8)
          goto LABEL_723;
        goto LABEL_722;
      }
    }
    else
    {
      free((void *)v420);
      if (v342)
        goto LABEL_520;
    }
LABEL_717:
    if (v339)
    {
      v360 = sub_1C484358C(a1 + 808, 48, 3);
      *(_QWORD *)v360 = 0;
      *(_QWORD *)(v360 + 8) = &unk_1E816B898;
      v10 = v360 + 8;
      *(_BYTE *)(v360 + 16) = 66;
      *(_WORD *)(v360 + 17) = *(_WORD *)(v360 + 17) & 0xF000 | 0x540;
      *(_QWORD *)(v360 + 24) = v297;
      *(_QWORD *)(v360 + 32) = v336;
      *(_QWORD *)(v360 + 40) = v338;
LABEL_560:
      v361 = *(_DWORD *)(a1 + 916) + 1;
      v362 = *(_DWORD *)(a1 + 912);
      if (v361 > 2 * v362)
      {
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v362, (uint64_t)off_1E81A1260);
        *(_QWORD *)&v420 = v421;
        *((_QWORD *)&v420 + 1) = 0x2000000000;
        sub_1C5DFE788((unsigned int *)v360, (unsigned int *)&v420);
        v52 = *(_QWORD *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38((_QWORD *)v420, v420 + 4 * DWORD2(v420)));
        if ((_QWORD *)v420 != v421)
          free((void *)v420);
        v361 = *(_DWORD *)(a1 + 916) + 1;
      }
      *(_DWORD *)(a1 + 916) = v361;
      v363 = *(_QWORD *)v52;
      if (!*(_QWORD *)v52)
        v363 = v52 | 1;
      *(_QWORD *)v360 = v363;
      *(_QWORD *)v52 = v360;
    }
    else
    {
LABEL_719:
      v10 = 0;
    }
LABEL_720:
    v129 = 1;
    goto LABEL_721;
  }
  if (strncmp("tr", (const char *)v13, 2uLL))
  {
    if (strncmp("tw", (const char *)v13, 2uLL))
    {
      if (v14 != v13 && v16 == 117)
      {
        *(_QWORD *)a1 = v13 + 1;
        v102 = (void *)sub_1C5E0BC2C(a1);
        v413 = v102;
        if (v102)
        {
          v103 = (const char *)(*(uint64_t (**)(void *))(*(_QWORD *)v102 + 48))(v102);
          if (v104 - (_QWORD)v103 == 8 && !strncmp(v103, "__uuidof", 8uLL))
          {
            v354 = *(unsigned __int8 **)a1;
            if (*(_QWORD *)a1 != *(_QWORD *)(a1 + 8))
            {
              v355 = *v354;
              if (v355 == 122)
              {
                *(_QWORD *)a1 = v354 + 1;
                v356 = sub_1C5E042EC(a1);
                goto LABEL_603;
              }
              if (v355 == 116)
              {
                *(_QWORD *)a1 = v354 + 1;
                v356 = sub_1C5DF9EB0(a1);
LABEL_603:
                v10 = v356;
                if (!v356)
                  return v10;
                v373 = *(uint64_t **)(a1 + 24);
                v105 = (uint64_t)v373 - *(_QWORD *)(a1 + 16);
                if (v373 == *(uint64_t **)(a1 + 32))
                {
                  sub_1C625449C(a1 + 16, v105 >> 2);
                  v373 = *(uint64_t **)(a1 + 24);
                }
                *(_QWORD *)(a1 + 24) = v373 + 1;
                *v373 = v10;
                goto LABEL_525;
              }
            }
          }
          v105 = *(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16);
          while (1)
          {
            v106 = *(unsigned __int8 **)a1;
            if (*(_QWORD *)a1 != *(_QWORD *)(a1 + 8) && *v106 == 69)
              break;
            v107 = sub_1C5E0B790(a1);
            if (!v107)
              return 0;
            v108 = v107;
            v109 = *(uint64_t **)(a1 + 24);
            if (v109 == *(uint64_t **)(a1 + 32))
            {
              sub_1C625449C(a1 + 16, ((uint64_t)v109 - *(_QWORD *)(a1 + 16)) >> 2);
              v109 = *(uint64_t **)(a1 + 24);
            }
            *(_QWORD *)(a1 + 24) = v109 + 1;
            *v109 = v108;
          }
          *(_QWORD *)a1 = v106 + 1;
LABEL_525:
          v349 = *(_BYTE **)(a1 + 24);
          v350 = (_BYTE *)(*(_QWORD *)(a1 + 16) + v105);
          v351 = (void *)sub_1C484358C(a1 + 808, v349 - v350, 3);
          v352 = v351;
          if (v349 != v350)
            memmove(v351, v350, v349 - v350);
          *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 16) + 8 * (v105 >> 3);
          *(_QWORD *)&v420 = v352;
          *((_QWORD *)&v420 + 1) = (v349 - v350) >> 3;
          v139 = 1;
LABEL_182:
          LODWORD(v412) = v139;
          return sub_1C5E09C48(a1, (uint64_t *)&v413, &v420, (int *)&v412);
        }
        return 0;
      }
      *(_QWORD *)&v420 = 0;
      if (v15 >= 3 && !strncmp("srN", (const char *)v13, 3uLL))
      {
        *(_QWORD *)a1 = v13 + 3;
        *(_QWORD *)&v420 = sub_1C5E0E2FC((unsigned __int8 **)a1);
        if ((_QWORD)v420)
        {
          if (*(_QWORD *)(a1 + 8) == *(_QWORD *)a1 || **(_BYTE **)a1 != 73)
            goto LABEL_726;
          v413 = (void *)sub_1C5E08AA8(a1, 0);
          if (v413)
          {
            for (i = sub_1C5E09218(a1, (uint64_t *)&v420, (uint64_t *)&v413);
                  ;
                  i = sub_1C5E0E408(a1, (uint64_t *)&v420, (uint64_t *)&v413))
            {
              *(_QWORD *)&v420 = i;
              if (!i)
                break;
LABEL_726:
              v359 = *(unsigned __int8 **)a1;
              if (*(_QWORD *)a1 != *(_QWORD *)(a1 + 8) && *v359 == 69)
              {
LABEL_730:
                *(_QWORD *)a1 = v359 + 1;
                goto LABEL_731;
              }
              v413 = (void *)sub_1C5E0E39C((_QWORD *)a1);
              if (!v413)
                return 0;
            }
          }
        }
        return 0;
      }
      if (strncmp("sr", (const char *)v13, 2uLL))
      {
        v329 = sub_1C5E0E6D4(a1);
        v10 = v329;
        *(_QWORD *)&v420 = v329;
        if (!v3 || !v329)
          return v10;
        return sub_1C5E0EAE8(a1, (uint64_t *)&v420);
      }
      *(_QWORD *)a1 = v13 + 2;
      if (v14 == v13 + 2)
      {
        v348 = 0;
      }
      else
      {
        if ((char)v13[2] < 0)
          goto LABEL_539;
        v348 = v13[2];
      }
      if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v348 + 60) & 0x400) == 0)
      {
LABEL_539:
        *(_QWORD *)&v420 = sub_1C5E0E2FC((unsigned __int8 **)a1);
        if (!(_QWORD)v420)
          return 0;
        if (*(_QWORD *)(a1 + 8) != *(_QWORD *)a1 && **(_BYTE **)a1 == 73)
        {
          v413 = (void *)sub_1C5E08AA8(a1, 0);
          if (!v413)
            return 0;
          *(_QWORD *)&v420 = sub_1C5E09218(a1, (uint64_t *)&v420, (uint64_t *)&v413);
          if (!(_QWORD)v420)
            return 0;
        }
LABEL_731:
        v413 = (void *)sub_1C5E0E6D4(a1);
        if (!v413)
          return 0;
        return sub_1C5E0E408(a1, (uint64_t *)&v420, (uint64_t *)&v413);
      }
      v357 = (void *)sub_1C5E0E39C((_QWORD *)a1);
      v413 = v357;
      if (!v357)
        return 0;
      v10 = 0;
      while (1)
      {
        if (v10)
        {
          v358 = sub_1C5E0E408(a1, (uint64_t *)&v420, (uint64_t *)&v413);
        }
        else
        {
          if (!v3)
          {
            *(_QWORD *)&v420 = v357;
            v10 = (uint64_t)v357;
            goto LABEL_552;
          }
          v358 = sub_1C5E0EAE8(a1, (uint64_t *)&v413);
        }
        v10 = v358;
        *(_QWORD *)&v420 = v358;
        if (!v358)
          return v10;
LABEL_552:
        v359 = *(unsigned __int8 **)a1;
        if (*(_QWORD *)a1 != *(_QWORD *)(a1 + 8) && *v359 == 69)
          goto LABEL_730;
        v357 = (void *)sub_1C5E0E39C((_QWORD *)a1);
        v413 = v357;
        if (!v357)
          return 0;
      }
    }
    *(_QWORD *)a1 = v13 + 2;
    v316 = sub_1C5E042EC(a1);
    if (!v316)
      return 0;
    v247 = v316;
    v317 = *(unsigned __int8 *)(a1 + 937);
    v413 = (char *)&v414 + 8;
    v415 = v316;
    v414 = xmmword_1C866FAA0;
    v318 = sub_1C4F5AB38((_QWORD *)&v414 + 1, (uint64_t)&v416);
    v251 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v318);
    v26 = *(unsigned int **)v251;
    *(_QWORD *)&v420 = v421;
    *((_QWORD *)&v420 + 1) = 0x2000000000;
    if (v26 && (v26 & 1) == 0)
    {
      while (1)
      {
        LOBYTE(v318) = sub_1C5DFE6F4(v318, v26, (uint64_t)&v413, v319, (unsigned int *)&v420);
        if ((v318 & 1) != 0)
          break;
        DWORD2(v420) = 0;
        v26 = *(unsigned int **)v26;
        if (v26)
          v320 = (v26 & 1) == 0;
        else
          v320 = 0;
        if (!v320)
        {
          v26 = 0;
          goto LABEL_509;
        }
      }
      v251 = 0;
LABEL_509:
      if ((_QWORD *)v420 == v421)
      {
        if (v26)
          goto LABEL_227;
      }
      else
      {
        free((void *)v420);
        if (v26)
          goto LABEL_227;
      }
    }
    if (!v317)
      goto LABEL_636;
    v330 = sub_1C484358C(a1 + 808, 32, 3);
    v331 = (unsigned int *)v330;
    *(_QWORD *)v330 = 0;
    *(_QWORD *)(v330 + 8) = &unk_1E816BA50;
    v10 = v330 + 8;
    v332 = 68;
LABEL_513:
    *(_BYTE *)(v330 + 16) = v332;
    *(_WORD *)(v330 + 17) = *(_WORD *)(v330 + 17) & 0xF000 | 0x540;
    *(_QWORD *)(v330 + 24) = v247;
    v345 = *(_DWORD *)(a1 + 916) + 1;
    v346 = *(_DWORD *)(a1 + 912);
    if (v345 > 2 * v346)
    {
      llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v346, (uint64_t)off_1E81A1260);
      *(_QWORD *)&v420 = v421;
      *((_QWORD *)&v420 + 1) = 0x2000000000;
      sub_1C5DFE788(v331, (unsigned int *)&v420);
      v251 = *(_QWORD *)(a1 + 904)
           + 8
           * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38((_QWORD *)v420, v420 + 4 * DWORD2(v420)));
      if ((_QWORD *)v420 != v421)
        free((void *)v420);
      v345 = *(_DWORD *)(a1 + 916) + 1;
    }
    *(_DWORD *)(a1 + 916) = v345;
    v347 = *(_QWORD *)v251;
    if (!*(_QWORD *)v251)
      v347 = v251 | 1;
    *(_QWORD *)v331 = v347;
    *(_QWORD *)v251 = v331;
    goto LABEL_637;
  }
  *(_QWORD *)a1 = v13 + 2;
  return sub_1C5DF9BE8(a1, "throw");
}

uint64_t sub_1C5E07E04(uint64_t a1)
{
  _BYTE *v1;
  _BYTE *v2;
  uint64_t v4;
  _BYTE *v5;
  uint64_t v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int *v13;
  BOOL v14;
  uint64_t v15;
  int v17;
  unint64_t v18;
  unsigned int v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  unsigned int *v24;
  void *v25;
  unsigned int v26[34];
  void *v27;
  uint64_t v28;
  _QWORD v29[17];

  v29[16] = *MEMORY[0x1E0C80C00];
  v1 = *(_BYTE **)a1;
  v2 = *(_BYTE **)(a1 + 8);
  if (*(_BYTE **)a1 == v2)
    return 0;
  if (*v1 != 68)
    return 0;
  *(_QWORD *)a1 = v1 + 1;
  if (v1 + 1 == v2)
    return 0;
  if ((v1[1] | 0x20) != 0x74)
    return 0;
  *(_QWORD *)a1 = v1 + 2;
  v4 = sub_1C5E042EC(a1);
  if (!v4)
    return 0;
  v5 = *(_BYTE **)a1;
  if (*(_QWORD *)a1 == *(_QWORD *)(a1 + 8) || *v5 != 69)
    return 0;
  v6 = v4;
  *(_QWORD *)a1 = v5 + 1;
  v7 = *(unsigned __int8 *)(a1 + 937);
  v25 = &v26[2];
  *(_OWORD *)v26 = xmmword_1C866FAD0;
  llvm::FoldingSetNodeID::AddString((unsigned int *)&v25, "decltype", 8u);
  v8 = v26[0];
  if (v26[0] >= v26[1])
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, (uint64_t)&v26[2], v26[0] + 1, 4);
    v8 = v26[0];
  }
  *((_DWORD *)v25 + v8) = v6;
  v9 = v26[0] + 1;
  v26[0] = v9;
  if (v9 >= v26[1])
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, (uint64_t)&v26[2], v9 + 1, 4);
    LODWORD(v9) = v26[0];
  }
  *((_DWORD *)v25 + v9) = HIDWORD(v6);
  ++v26[0];
  v10 = sub_1C4F5AB38(v25, (uint64_t)v25 + 4 * v26[0]);
  v12 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v10);
  v13 = *(unsigned int **)v12;
  v27 = v29;
  v28 = 0x2000000000;
  if (!v13 || (v13 & 1) != 0)
    goto LABEL_27;
  while (1)
  {
    LOBYTE(v10) = sub_1C5DFE6F4(v10, v13, (uint64_t)&v25, v11, (unsigned int *)&v27);
    if ((v10 & 1) != 0)
      break;
    LODWORD(v28) = 0;
    v13 = *(unsigned int **)v13;
    if (v13)
      v14 = (v13 & 1) == 0;
    else
      v14 = 0;
    if (!v14)
    {
      v13 = 0;
      goto LABEL_23;
    }
  }
  v12 = 0;
LABEL_23:
  if (v27 != v29)
  {
    free(v27);
    if (v13)
      goto LABEL_25;
LABEL_27:
    if (v7)
    {
      v18 = sub_1C484358C(a1 + 808, 64, 3);
      *(_QWORD *)(v18 + 8) = &unk_1E816B160;
      v15 = v18 + 8;
      *(_QWORD *)v18 = 0;
      *(_BYTE *)(v18 + 16) = 56;
      *(_WORD *)(v18 + 17) = *(_WORD *)(v18 + 17) & 0xF000 | 0x540;
      *(_QWORD *)(v18 + 24) = "decltype";
      *(_QWORD *)(v18 + 32) = "";
      *(_QWORD *)(v18 + 48) = 0;
      *(_QWORD *)(v18 + 56) = 0;
      *(_QWORD *)(v18 + 40) = v6;
      v19 = *(_DWORD *)(a1 + 916) + 1;
      v20 = *(_DWORD *)(a1 + 912);
      if (v19 > 2 * v20)
      {
        v24 = (unsigned int *)v18;
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v20, (uint64_t)off_1E81A1260);
        v27 = v29;
        v28 = 0x2000000000;
        sub_1C5DFE788(v24, (unsigned int *)&v27);
        v12 = *(_QWORD *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v27, (uint64_t)v27 + 4 * v28));
        if (v27 != v29)
          free(v27);
        v19 = *(_DWORD *)(a1 + 916) + 1;
        v18 = (unint64_t)v24;
      }
      *(_DWORD *)(a1 + 916) = v19;
      v21 = *(_QWORD *)v12;
      if (!*(_QWORD *)v12)
        v21 = v12 | 1;
      *(_QWORD *)v18 = v21;
      *(_QWORD *)v12 = v18;
    }
    else
    {
      v15 = 0;
    }
    v17 = 1;
    goto LABEL_34;
  }
  if (!v13)
    goto LABEL_27;
LABEL_25:
  v17 = 0;
  v15 = (uint64_t)(v13 + 2);
LABEL_34:
  if (v25 != &v26[2])
    free(v25);
  if (v17)
  {
    *(_QWORD *)(a1 + 920) = v15;
  }
  else if (v15)
  {
    v27 = 0;
    v22 = sub_1C627E01C(a1 + 944, v15, &v27);
    v23 = 0;
    if (v22)
      v23 = *((_QWORD *)v27 + 1);
    if (v23)
      v15 = v23;
    if (v15 == *(_QWORD *)(a1 + 928))
      *(_BYTE *)(a1 + 936) = 1;
  }
  return v15;
}

uint64_t sub_1C5E081BC(uint64_t a1, uint64_t *a2)
{
  int v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  BOOL v9;
  BOOL v10;
  int v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  int v19;
  uint64_t v20;
  void *v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  _QWORD v27[17];

  v27[16] = *MEMORY[0x1E0C80C00];
  v4 = *(unsigned __int8 *)(a1 + 937);
  v21 = (char *)&v22 + 8;
  v23 = *a2;
  v22 = xmmword_1C866FB10;
  v5 = sub_1C4F5AB38((_QWORD *)&v22 + 1, (uint64_t)&v24);
  v7 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v5);
  v8 = *(unsigned int **)v7;
  v25 = v27;
  v26 = 0x2000000000;
  if (v8)
    v9 = (v8 & 1) == 0;
  else
    v9 = 0;
  if (!v9)
    goto LABEL_17;
  while (1)
  {
    LOBYTE(v5) = sub_1C5DFE6F4(v5, v8, (uint64_t)&v21, v6, (unsigned int *)&v25);
    if ((v5 & 1) != 0)
      break;
    LODWORD(v26) = 0;
    v8 = *(unsigned int **)v8;
    if (v8)
      v10 = (v8 & 1) == 0;
    else
      v10 = 0;
    if (!v10)
    {
      v8 = 0;
      goto LABEL_13;
    }
  }
  v7 = 0;
LABEL_13:
  if (v25 == v27)
  {
    if (v8)
    {
LABEL_15:
      v11 = 0;
      v12 = (uint64_t)(v8 + 2);
      goto LABEL_24;
    }
  }
  else
  {
    free(v25);
    if (v8)
      goto LABEL_15;
  }
LABEL_17:
  if (v4)
  {
    v13 = sub_1C484358C(a1 + 808, 32, 3);
    *(_QWORD *)v13 = 0;
    *(_QWORD *)(v13 + 8) = &unk_1E816B790;
    v12 = v13 + 8;
    v14 = *a2;
    *(_BYTE *)(v13 + 16) = 38;
    *(_WORD *)(v13 + 17) = *(_WORD *)(v13 + 17) & 0xF000 | 0x540;
    *(_QWORD *)(v13 + 24) = v14;
    v15 = *(_DWORD *)(a1 + 916) + 1;
    v16 = *(_DWORD *)(a1 + 912);
    if (v15 > 2 * v16)
    {
      llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v16, (uint64_t)off_1E81A1260);
      v25 = v27;
      v26 = 0x2000000000;
      sub_1C5DFE788((unsigned int *)v13, (unsigned int *)&v25);
      v7 = *(_QWORD *)(a1 + 904)
         + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v25, (uint64_t)v25 + 4 * v26));
      if (v25 != v27)
        free(v25);
      v15 = *(_DWORD *)(a1 + 916) + 1;
    }
    *(_DWORD *)(a1 + 916) = v15;
    v17 = *(_QWORD *)v7;
    if (!*(_QWORD *)v7)
      v17 = v7 | 1;
    *(_QWORD *)v13 = v17;
    *(_QWORD *)v7 = v13;
  }
  else
  {
    v12 = 0;
  }
  v11 = 1;
LABEL_24:
  if (v21 != (char *)&v22 + 8)
    free(v21);
  if (v11)
  {
    *(_QWORD *)(a1 + 920) = v12;
  }
  else if (v12)
  {
    v25 = 0;
    v19 = sub_1C627E01C(a1 + 944, v12, &v25);
    v20 = 0;
    if (v19)
      v20 = *((_QWORD *)v25 + 1);
    if (v20)
      v12 = v20;
    if (v12 == *(_QWORD *)(a1 + 928))
      *(_BYTE *)(a1 + 936) = 1;
  }
  return v12;
}

uint64_t sub_1C5E08468(uint64_t a1)
{
  const char *v2;
  char *v3;
  char *v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;
  BOOL v13;
  BOOL v14;
  int v15;
  unint64_t v16;
  uint64_t v17;
  unsigned int v18;
  int v19;
  uint64_t v20;
  int v22;
  uint64_t v23;
  unsigned int *v24;
  void *v25;
  unsigned int v26[34];
  void *v27;
  uint64_t v28;
  _QWORD v29[17];

  v29[16] = *MEMORY[0x1E0C80C00];
  v2 = *(const char **)a1;
  if (*(_QWORD *)(a1 + 8) - *(_QWORD *)a1 < 2uLL)
    goto LABEL_2;
  if (!strncmp("Ts", v2, 2uLL))
  {
    v3 = "struct";
    v4 = "";
    goto LABEL_9;
  }
  if (!strncmp("Tu", v2, 2uLL))
  {
    v3 = "union";
    v4 = "";
    goto LABEL_9;
  }
  if (!strncmp("Te", v2, 2uLL))
  {
    v3 = "enum";
    v4 = "";
LABEL_9:
    *(_QWORD *)a1 = v2 + 2;
    goto LABEL_10;
  }
LABEL_2:
  v3 = 0;
  v4 = 0;
LABEL_10:
  v5 = sub_1C5DFC098(a1, 0);
  if (!v5 || v3 == v4)
    return v5;
  v6 = *(unsigned __int8 *)(a1 + 937);
  v25 = &v26[2];
  *(_OWORD *)v26 = xmmword_1C866FB20;
  llvm::FoldingSetNodeID::AddString((unsigned int *)&v25, (unsigned __int8 *)v3, (_DWORD)v4 - (_DWORD)v3);
  v7 = v26[0];
  if (v26[0] >= v26[1])
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, (uint64_t)&v26[2], v26[0] + 1, 4);
    v7 = v26[0];
  }
  *((_DWORD *)v25 + v7) = v5;
  v8 = v26[0] + 1;
  v26[0] = v8;
  if (v8 >= v26[1])
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, (uint64_t)&v26[2], v8 + 1, 4);
    LODWORD(v8) = v26[0];
  }
  *((_DWORD *)v25 + v8) = HIDWORD(v5);
  ++v26[0];
  v9 = sub_1C4F5AB38(v25, (uint64_t)v25 + 4 * v26[0]);
  v11 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v9);
  v12 = *(unsigned int **)v11;
  v27 = v29;
  v28 = 0x2000000000;
  if (v12)
    v13 = (v12 & 1) == 0;
  else
    v13 = 0;
  if (!v13)
    goto LABEL_32;
  while (1)
  {
    LOBYTE(v9) = sub_1C5DFE6F4(v9, v12, (uint64_t)&v25, v10, (unsigned int *)&v27);
    if ((v9 & 1) != 0)
      break;
    LODWORD(v28) = 0;
    v12 = *(unsigned int **)v12;
    if (v12)
      v14 = (v12 & 1) == 0;
    else
      v14 = 0;
    if (!v14)
    {
      v12 = 0;
      goto LABEL_28;
    }
  }
  v11 = 0;
LABEL_28:
  if (v27 != v29)
  {
    free(v27);
    if (v12)
      goto LABEL_30;
LABEL_32:
    if (v6)
    {
      v16 = sub_1C484358C(a1 + 808, 48, 3);
      *(_QWORD *)v16 = 0;
      *(_QWORD *)(v16 + 8) = &unk_1E816C5A8;
      v17 = v16 + 8;
      *(_BYTE *)(v16 + 16) = 6;
      *(_WORD *)(v16 + 17) = *(_WORD *)(v16 + 17) & 0xF000 | 0x540;
      *(_QWORD *)(v16 + 24) = v3;
      *(_QWORD *)(v16 + 32) = v4;
      *(_QWORD *)(v16 + 40) = v5;
      v18 = *(_DWORD *)(a1 + 916) + 1;
      v19 = *(_DWORD *)(a1 + 912);
      if (v18 > 2 * v19)
      {
        v24 = (unsigned int *)v16;
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v19, (uint64_t)off_1E81A1260);
        v27 = v29;
        v28 = 0x2000000000;
        sub_1C5DFE788(v24, (unsigned int *)&v27);
        v11 = *(_QWORD *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v27, (uint64_t)v27 + 4 * v28));
        if (v27 != v29)
          free(v27);
        v18 = *(_DWORD *)(a1 + 916) + 1;
        v16 = (unint64_t)v24;
      }
      *(_DWORD *)(a1 + 916) = v18;
      v20 = *(_QWORD *)v11;
      if (!*(_QWORD *)v11)
        v20 = v11 | 1;
      *(_QWORD *)v16 = v20;
      *(_QWORD *)v11 = v16;
      v15 = 1;
      v5 = v17;
    }
    else
    {
      v5 = 0;
      v15 = 1;
    }
    goto LABEL_38;
  }
  if (!v12)
    goto LABEL_32;
LABEL_30:
  v15 = 0;
  v5 = (uint64_t)(v12 + 2);
LABEL_38:
  if (v25 != &v26[2])
    free(v25);
  if (v15)
  {
    *(_QWORD *)(a1 + 920) = v5;
  }
  else if (v5)
  {
    v27 = 0;
    v22 = sub_1C627E01C(a1 + 944, v5, &v27);
    v23 = 0;
    if (v22)
      v23 = *((_QWORD *)v27 + 1);
    if (v23)
      v5 = v23;
    if (v5 == *(_QWORD *)(a1 + 928))
      *(_BYTE *)(a1 + 936) = 1;
  }
  return v5;
}

uint64_t sub_1C5E08860(uint64_t a1)
{
  unsigned __int8 *v1;
  unsigned __int8 *v2;
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t *v9;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;

  v2 = *(unsigned __int8 **)a1;
  v1 = *(unsigned __int8 **)(a1 + 8);
  if (*(unsigned __int8 **)a1 == v1 || *v2 != 84)
    return 0;
  v4 = v2 + 1;
  *(_QWORD *)a1 = v2 + 1;
  v18 = 0;
  if (v2 + 1 == v1)
  {
    v6 = 0;
    v17 = 0;
    goto LABEL_14;
  }
  if (*v4 == 76)
  {
    *(_QWORD *)a1 = v2 + 2;
    if ((sub_1C54C42B4((unsigned __int8 **)a1, &v18) & 1) != 0)
      return 0;
    v5 = *(unsigned __int8 **)a1;
    v1 = *(unsigned __int8 **)(a1 + 8);
    if (*(unsigned __int8 **)a1 == v1 || *v5 != 95)
      return 0;
    v6 = v18 + 1;
    v4 = v5 + 1;
    *(_QWORD *)a1 = v4;
  }
  else
  {
    v6 = 0;
  }
  v17 = 0;
  if (v4 == v1 || *v4 != 95)
  {
LABEL_14:
    if ((sub_1C54C42B4((unsigned __int8 **)a1, &v17) & 1) == 0)
    {
      v4 = *(unsigned __int8 **)a1;
      if (*(_QWORD *)a1 != *(_QWORD *)(a1 + 8) && *v4 == 95)
      {
        v7 = v17 + 1;
        goto LABEL_18;
      }
    }
    return 0;
  }
  v7 = 0;
LABEL_18:
  *(_QWORD *)a1 = v4 + 1;
  if (!*(_BYTE *)(a1 + 777) || v6)
  {
    v11 = *(_QWORD **)(a1 + 672);
    v12 = *(_QWORD *)(a1 + 664);
    v13 = (uint64_t)v11 - v12;
    if (v6 < ((uint64_t)v11 - v12) >> 3
      && (v14 = *(_QWORD **)(v12 + 8 * v6)) != 0
      && (v16 = v14, v15 = *v14, v7 < (v16[1] - v15) >> 3))
    {
      return *(_QWORD *)(v15 + 8 * v7);
    }
    else
    {
      v8 = 0;
      if (v6 <= v13 >> 3 && *(_QWORD *)(a1 + 784) == v6)
      {
        if (v6 == v13 >> 3)
        {
          if (v11 == *(_QWORD **)(a1 + 680))
          {
            sub_1C625449C(a1 + 664, v13 >> 2);
            v11 = *(_QWORD **)(a1 + 672);
          }
          *(_QWORD *)(a1 + 672) = v11 + 1;
          *v11 = 0;
        }
        return sub_1C5DF9BE8(a1, "auto");
      }
    }
  }
  else
  {
    v8 = sub_1C484358C(a1 + 808, 40, 3);
    *(_BYTE *)(v8 + 8) = 40;
    *(_WORD *)(v8 + 9) = *(_WORD *)(v8 + 9) & 0xF000 | 0xA80;
    *(_QWORD *)v8 = &unk_1E816A960;
    *(_QWORD *)(v8 + 16) = v7;
    *(_QWORD *)(v8 + 24) = 0;
    *(_BYTE *)(v8 + 32) = 0;
    *(_QWORD *)(a1 + 920) = v8;
    v9 = *(unint64_t **)(a1 + 728);
    if (v9 == *(unint64_t **)(a1 + 736))
    {
      sub_1C625449C(a1 + 720, ((uint64_t)v9 - *(_QWORD *)(a1 + 720)) >> 2);
      v9 = *(unint64_t **)(a1 + 728);
    }
    *(_QWORD *)(a1 + 728) = v9 + 1;
    *v9 = v8;
  }
  return v8;
}

uint64_t sub_1C5E08AA8(uint64_t a1, int a2)
{
  _BYTE *v2;
  _QWORD *v5;
  void **v6;
  void **v7;
  _BYTE *v8;
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  _BYTE *v14;
  int64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int *v23;
  BOOL v24;
  int v25;
  _QWORD *v26;
  uint64_t *v27;
  char v28;
  unsigned int v29;
  int v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  unsigned int v34;
  int v35;
  uint64_t v36;
  uint64_t v38;
  const void *v39;
  uint64_t v40;
  uint64_t *v41;
  uint64_t *v42;
  int64_t v43;
  int v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unsigned int *v48;
  BOOL v49;
  BOOL v50;
  int v51;
  unint64_t v52;
  unsigned int v53;
  int v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  unsigned int *v60;
  void **v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void *v66;
  __int128 v67;
  _BYTE v68[32];
  void *v69;
  uint64_t v70;
  _BYTE v71[128];
  _QWORD *v72;
  uint64_t v73;
  _QWORD v74[18];

  v74[16] = *MEMORY[0x1E0C80C00];
  v2 = *(_BYTE **)a1;
  if (*(_QWORD *)a1 == *(_QWORD *)(a1 + 8) || *v2 != 73)
    return 0;
  *(_QWORD *)a1 = v2 + 1;
  if (a2)
  {
    v5 = *(_QWORD **)(a1 + 664);
    *(_QWORD *)(a1 + 672) = v5;
    if (v5 == *(_QWORD **)(a1 + 680))
    {
      sub_1C625449C(a1 + 664, 0);
      v5 = *(_QWORD **)(a1 + 672);
    }
    *(_QWORD *)(a1 + 672) = v5 + 1;
    *v5 = a1 + 576;
    *(_QWORD *)(a1 + 584) = *(_QWORD *)(a1 + 576);
  }
  v6 = (void **)(a1 + 664);
  v7 = &v69;
  v8 = (_BYTE *)(a1 + 688);
  v65 = (uint64_t)(*(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16)) >> 3;
  v9 = a1 + 808;
  v63 = a1 + 904;
  v64 = a1 + 944;
  while (1)
  {
    v10 = *(_BYTE **)a1;
    if (*(_QWORD *)a1 != *(_QWORD *)(a1 + 8) && *v10 == 69)
      break;
    if (a2)
    {
      v66 = v68;
      *((_QWORD *)&v67 + 1) = v7;
      memset(v68, 0, sizeof(v68));
      if (*v6 == v8)
      {
        v14 = *(_BYTE **)(a1 + 672);
        v15 = v14 - v8;
        if (v14 != v8)
          memcpy(v68, (const void *)(a1 + 688), v14 - v8);
        *(_QWORD *)&v67 = &v68[v15];
        *(_QWORD *)(a1 + 672) = v8;
      }
      else
      {
        v66 = *v6;
        v67 = *(_OWORD *)(a1 + 672);
        *(_QWORD *)(a1 + 664) = v8;
        *(_QWORD *)(a1 + 672) = v8;
        *(_QWORD *)(a1 + 680) = a1 + 720;
      }
      v16 = sub_1C5E0B790(a1);
      sub_1C6253D78((char *)(a1 + 664), (uint64_t)&v66);
      if (!v16)
        goto LABEL_49;
      v17 = *(uint64_t **)(a1 + 24);
      if (v17 == *(uint64_t **)(a1 + 32))
      {
        sub_1C625449C(a1 + 16, ((uint64_t)v17 - *(_QWORD *)(a1 + 16)) >> 2);
        v17 = *(uint64_t **)(a1 + 24);
      }
      *(_QWORD *)(a1 + 24) = v17 + 1;
      *v17 = v16;
      if (*(_BYTE *)(v16 + 8) != 37)
      {
LABEL_45:
        v26 = *(_QWORD **)(*(_QWORD *)(a1 + 672) - 8);
        v27 = (uint64_t *)v26[1];
        if (v27 == (uint64_t *)v26[2])
        {
          sub_1C625449C(*(_QWORD *)(*(_QWORD *)(a1 + 672) - 8), ((uint64_t)v27 - *v26) >> 2);
          v27 = (uint64_t *)v26[1];
        }
        v26[1] = v27 + 1;
        *v27 = v16;
        v28 = 1;
        goto LABEL_50;
      }
      v61 = v7;
      v62 = v9;
      v18 = *(uint64_t **)(v16 + 16);
      v19 = *(_QWORD *)(v16 + 24);
      v59 = *(unsigned __int8 *)(a1 + 937);
      v69 = v71;
      v70 = 0x2000000000;
      sub_1C5E0169C(&v69, 36, v18, v19);
      v20 = sub_1C4F5AB38(v69, (uint64_t)v69 + 4 * v70);
      v22 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v20);
      v23 = *(unsigned int **)v22;
      v72 = v74;
      v73 = 0x2000000000;
      if (v23 && (v23 & 1) == 0)
      {
        while (1)
        {
          LOBYTE(v20) = sub_1C5DFE6F4(v20, v23, (uint64_t)&v69, v21, (unsigned int *)&v72);
          if ((v20 & 1) != 0)
            break;
          LODWORD(v73) = 0;
          v23 = *(unsigned int **)v23;
          if (v23)
            v24 = (v23 & 1) == 0;
          else
            v24 = 0;
          if (!v24)
          {
            v23 = 0;
            goto LABEL_33;
          }
        }
        v22 = 0;
LABEL_33:
        if (v72 == v74)
        {
          if (v23)
            goto LABEL_35;
        }
        else
        {
          free(v72);
          if (v23)
          {
LABEL_35:
            v25 = 0;
            v16 = (uint64_t)(v23 + 2);
            goto LABEL_40;
          }
        }
      }
      if (v59)
      {
        v60 = (unsigned int *)sub_1C484358C(v62, 40, 3);
        *(_QWORD *)v60 = 0;
        v16 = (uint64_t)(v60 + 2);
        sub_1C6257EB4((uint64_t)(v60 + 2), (uint64_t)v18, v19);
        v29 = *(_DWORD *)(a1 + 916) + 1;
        v30 = *(_DWORD *)(a1 + 912);
        if (v29 > 2 * v30)
        {
          llvm::FoldingSetBase::GrowBucketCount(v63, 2 * v30, (uint64_t)off_1E81A1260);
          v72 = v74;
          v73 = 0x2000000000;
          sub_1C5DFE788(v60, (unsigned int *)&v72);
          v34 = sub_1C4F5AB38(v72, (uint64_t)v72 + 4 * v73);
          v58 = *(_QWORD *)(a1 + 904);
          v35 = *(_DWORD *)(a1 + 912);
          if (v72 != v74)
            free(v72);
          v22 = v58 + 8 * ((v35 - 1) & v34);
          v29 = *(_DWORD *)(a1 + 916) + 1;
        }
        *(_DWORD *)(a1 + 916) = v29;
        v31 = *(_QWORD *)v22;
        if (!*(_QWORD *)v22)
          v31 = v22 | 1;
        *(_QWORD *)v60 = v31;
        *(_QWORD *)v22 = v60;
      }
      else
      {
        v16 = 0;
      }
      v25 = 1;
LABEL_40:
      v7 = v61;
      v9 = v62;
      if (v69 != v71)
        free(v69);
      if (v25)
      {
        *(_QWORD *)(a1 + 920) = v16;
      }
      else
      {
        if (!v16)
          goto LABEL_49;
        v72 = 0;
        v32 = sub_1C627E01C(v64, v16, &v72);
        v33 = 0;
        if (v32)
          v33 = v72[1];
        if (v33)
          v16 = v33;
        if (v16 == *(_QWORD *)(a1 + 928))
          *(_BYTE *)(a1 + 936) = 1;
      }
      if (v16)
        goto LABEL_45;
LABEL_49:
      v28 = 0;
LABEL_50:
      if (v66 != v68)
        free(v66);
      if ((v28 & 1) == 0)
        return 0;
    }
    else
    {
      v11 = sub_1C5E0B790(a1);
      if (!v11)
        return 0;
      v12 = v11;
      v13 = *(uint64_t **)(a1 + 24);
      if (v13 == *(uint64_t **)(a1 + 32))
      {
        sub_1C625449C(a1 + 16, ((uint64_t)v13 - *(_QWORD *)(a1 + 16)) >> 2);
        v13 = *(uint64_t **)(a1 + 24);
      }
      *(_QWORD *)(a1 + 24) = v13 + 1;
      *v13 = v12;
    }
  }
  *(_QWORD *)a1 = v10 + 1;
  v38 = *(_QWORD *)(a1 + 24);
  v39 = (const void *)(*(_QWORD *)(a1 + 16) + 8 * v65);
  v40 = v9;
  v41 = (uint64_t *)sub_1C484358C(v9, v38 - (_QWORD)v39, 3);
  v42 = v41;
  v43 = v38 - (_QWORD)v39;
  if (v43)
    memmove(v41, v39, v43);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 16) + 8 * v65;
  v44 = *(unsigned __int8 *)(a1 + 937);
  v69 = v71;
  v70 = 0x2000000000;
  sub_1C5E0169C(&v69, 39, v42, v43 >> 3);
  v45 = sub_1C4F5AB38(v69, (uint64_t)v69 + 4 * v70);
  v47 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v45);
  v48 = *(unsigned int **)v47;
  v72 = v74;
  v73 = 0x2000000000;
  if (v48)
    v49 = (v48 & 1) == 0;
  else
    v49 = 0;
  if (v49)
  {
    while (1)
    {
      LOBYTE(v45) = sub_1C5DFE6F4(v45, v48, (uint64_t)&v69, v46, (unsigned int *)&v72);
      if ((v45 & 1) != 0)
        break;
      LODWORD(v73) = 0;
      v48 = *(unsigned int **)v48;
      if (v48)
        v50 = (v48 & 1) == 0;
      else
        v50 = 0;
      if (!v50)
      {
        v48 = 0;
        goto LABEL_83;
      }
    }
    v47 = 0;
LABEL_83:
    if (v72 == v74)
    {
      if (!v48)
        goto LABEL_87;
    }
    else
    {
      free(v72);
      if (!v48)
        goto LABEL_87;
    }
    v51 = 0;
    v36 = (uint64_t)(v48 + 2);
  }
  else
  {
LABEL_87:
    if (v44)
    {
      v52 = sub_1C484358C(v40, 40, 3);
      *(_QWORD *)v52 = 0;
      *(_QWORD *)(v52 + 8) = &unk_1E816BF78;
      v36 = v52 + 8;
      *(_BYTE *)(v52 + 16) = 39;
      *(_WORD *)(v52 + 17) = *(_WORD *)(v52 + 17) & 0xF000 | 0x540;
      *(_QWORD *)(v52 + 24) = v42;
      *(_QWORD *)(v52 + 32) = v43 >> 3;
      v53 = *(_DWORD *)(a1 + 916) + 1;
      v54 = *(_DWORD *)(a1 + 912);
      if (v53 > 2 * v54)
      {
        llvm::FoldingSetBase::GrowBucketCount(v63, 2 * v54, (uint64_t)off_1E81A1260);
        v72 = v74;
        v73 = 0x2000000000;
        sub_1C5DFE788((unsigned int *)v52, (unsigned int *)&v72);
        v47 = *(_QWORD *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v72, (uint64_t)v72 + 4 * v73));
        if (v72 != v74)
          free(v72);
        v53 = *(_DWORD *)(a1 + 916) + 1;
      }
      *(_DWORD *)(a1 + 916) = v53;
      v55 = *(_QWORD *)v47;
      if (!*(_QWORD *)v47)
        v55 = v47 | 1;
      *(_QWORD *)v52 = v55;
      *(_QWORD *)v47 = v52;
    }
    else
    {
      v36 = 0;
    }
    v51 = 1;
  }
  if (v69 != v71)
    free(v69);
  if (v51)
  {
    *(_QWORD *)(a1 + 920) = v36;
  }
  else if (v36)
  {
    v72 = 0;
    v56 = sub_1C627E01C(v64, v36, &v72);
    v57 = 0;
    if (v56)
      v57 = v72[1];
    if (v57)
      v36 = v57;
    if (v36 == *(_QWORD *)(a1 + 928))
      *(_BYTE *)(a1 + 936) = 1;
  }
  return v36;
}

uint64_t sub_1C5E09218(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  int v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;
  BOOL v13;
  BOOL v14;
  int v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  int v21;
  uint64_t v22;
  int v24;
  uint64_t v25;
  void *v26;
  __int128 v27;
  int v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  _QWORD v34[17];

  v34[16] = *MEMORY[0x1E0C80C00];
  v6 = *(unsigned __int8 *)(a1 + 937);
  v26 = (char *)&v27 + 8;
  v7 = *a3;
  v8 = HIDWORD(*a2);
  v28 = *a2;
  v29 = v8;
  v30 = v7;
  v27 = xmmword_1C866FB30;
  v9 = sub_1C4F5AB38((_QWORD *)&v27 + 1, (uint64_t)&v31);
  v11 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v9);
  v12 = *(unsigned int **)v11;
  v32 = v34;
  v33 = 0x2000000000;
  if (v12)
    v13 = (v12 & 1) == 0;
  else
    v13 = 0;
  if (!v13)
    goto LABEL_17;
  while (1)
  {
    LOBYTE(v9) = sub_1C5DFE6F4(v9, v12, (uint64_t)&v26, v10, (unsigned int *)&v32);
    if ((v9 & 1) != 0)
      break;
    LODWORD(v33) = 0;
    v12 = *(unsigned int **)v12;
    if (v12)
      v14 = (v12 & 1) == 0;
    else
      v14 = 0;
    if (!v14)
    {
      v12 = 0;
      goto LABEL_13;
    }
  }
  v11 = 0;
LABEL_13:
  if (v32 == v34)
  {
    if (v12)
    {
LABEL_15:
      v15 = 0;
      v16 = (uint64_t)(v12 + 2);
      goto LABEL_24;
    }
  }
  else
  {
    free(v32);
    if (v12)
      goto LABEL_15;
  }
LABEL_17:
  if (v6)
  {
    v17 = sub_1C484358C(a1 + 808, 40, 3);
    *(_QWORD *)v17 = 0;
    *(_QWORD *)(v17 + 8) = &unk_1E816BFD0;
    v16 = v17 + 8;
    v18 = *a2;
    v19 = *a3;
    *(_BYTE *)(v17 + 16) = 41;
    *(_WORD *)(v17 + 17) = *(_WORD *)(v17 + 17) & 0xF000 | 0x540;
    *(_QWORD *)(v17 + 24) = v18;
    *(_QWORD *)(v17 + 32) = v19;
    v20 = *(_DWORD *)(a1 + 916) + 1;
    v21 = *(_DWORD *)(a1 + 912);
    if (v20 > 2 * v21)
    {
      llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v21, (uint64_t)off_1E81A1260);
      v32 = v34;
      v33 = 0x2000000000;
      sub_1C5DFE788((unsigned int *)v17, (unsigned int *)&v32);
      v11 = *(_QWORD *)(a1 + 904)
          + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v32, (uint64_t)v32 + 4 * v33));
      if (v32 != v34)
        free(v32);
      v20 = *(_DWORD *)(a1 + 916) + 1;
    }
    *(_DWORD *)(a1 + 916) = v20;
    v22 = *(_QWORD *)v11;
    if (!*(_QWORD *)v11)
      v22 = v11 | 1;
    *(_QWORD *)v17 = v22;
    *(_QWORD *)v11 = v17;
  }
  else
  {
    v16 = 0;
  }
  v15 = 1;
LABEL_24:
  if (v26 != (char *)&v27 + 8)
    free(v26);
  if (v15)
  {
    *(_QWORD *)(a1 + 920) = v16;
  }
  else if (v16)
  {
    v32 = 0;
    v24 = sub_1C627E01C(a1 + 944, v16, &v32);
    v25 = 0;
    if (v24)
      v25 = *((_QWORD *)v32 + 1);
    if (v25)
      v16 = v25;
    if (v16 == *(_QWORD *)(a1 + 928))
      *(_BYTE *)(a1 + 936) = 1;
  }
  return v16;
}

uint64_t sub_1C5E094E4(uint64_t a1, unint64_t *a2, int *a3)
{
  int v6;
  int v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;
  BOOL v13;
  BOOL v14;
  int v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  char v19;
  int v20;
  unsigned int v21;
  int v22;
  uint64_t v23;
  int v25;
  uint64_t v26;
  void *v27;
  __int128 v28;
  int v29;
  int v30;
  int v31;
  int v32;
  uint64_t v33;
  void *v34;
  uint64_t v35;
  _QWORD v36[17];

  v36[16] = *MEMORY[0x1E0C80C00];
  v6 = *(unsigned __int8 *)(a1 + 937);
  v27 = (char *)&v28 + 8;
  v7 = *a3;
  v8 = HIDWORD(*a2);
  v29 = *a2;
  v30 = v8;
  v31 = v7;
  v32 = v7 >> 31;
  v28 = xmmword_1C866FB40;
  v9 = sub_1C4F5AB38((_QWORD *)&v28 + 1, (uint64_t)&v33);
  v11 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v9);
  v12 = *(unsigned int **)v11;
  v34 = v36;
  v35 = 0x2000000000;
  if (v12)
    v13 = (v12 & 1) == 0;
  else
    v13 = 0;
  if (!v13)
    goto LABEL_17;
  while (1)
  {
    LOBYTE(v9) = sub_1C5DFE6F4(v9, v12, (uint64_t)&v27, v10, (unsigned int *)&v34);
    if ((v9 & 1) != 0)
      break;
    LODWORD(v35) = 0;
    v12 = *(unsigned int **)v12;
    if (v12)
      v14 = (v12 & 1) == 0;
    else
      v14 = 0;
    if (!v14)
    {
      v12 = 0;
      goto LABEL_13;
    }
  }
  v11 = 0;
LABEL_13:
  if (v34 == v36)
  {
    if (v12)
    {
LABEL_15:
      v15 = 0;
      v16 = (uint64_t)(v12 + 2);
      goto LABEL_24;
    }
  }
  else
  {
    free(v34);
    if (v12)
      goto LABEL_15;
  }
LABEL_17:
  if (v6)
  {
    v17 = sub_1C484358C(a1 + 808, 40, 3);
    *(_QWORD *)v17 = 0;
    v18 = *a2;
    v19 = *(_WORD *)(*a2 + 9);
    *(_QWORD *)(v17 + 8) = &unk_1E816C658;
    v16 = v17 + 8;
    v20 = *a3;
    *(_BYTE *)(v17 + 16) = 12;
    *(_WORD *)(v17 + 17) = v19 & 0xC0 | *(_WORD *)(v17 + 17) & 0xF000 | 0x500;
    *(_QWORD *)(v17 + 24) = v18;
    *(_DWORD *)(v17 + 32) = v20;
    *(_BYTE *)(v17 + 36) = 0;
    v21 = *(_DWORD *)(a1 + 916) + 1;
    v22 = *(_DWORD *)(a1 + 912);
    if (v21 > 2 * v22)
    {
      llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v22, (uint64_t)off_1E81A1260);
      v34 = v36;
      v35 = 0x2000000000;
      sub_1C5DFE788((unsigned int *)v17, (unsigned int *)&v34);
      v11 = *(_QWORD *)(a1 + 904)
          + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v34, (uint64_t)v34 + 4 * v35));
      if (v34 != v36)
        free(v34);
      v21 = *(_DWORD *)(a1 + 916) + 1;
    }
    *(_DWORD *)(a1 + 916) = v21;
    v23 = *(_QWORD *)v11;
    if (!*(_QWORD *)v11)
      v23 = v11 | 1;
    *(_QWORD *)v17 = v23;
    *(_QWORD *)v11 = v17;
  }
  else
  {
    v16 = 0;
  }
  v15 = 1;
LABEL_24:
  if (v27 != (char *)&v28 + 8)
    free(v27);
  if (v15)
  {
    *(_QWORD *)(a1 + 920) = v16;
  }
  else if (v16)
  {
    v34 = 0;
    v25 = sub_1C627E01C(a1 + 944, v16, &v34);
    v26 = 0;
    if (v25)
      v26 = *((_QWORD *)v34 + 1);
    if (v26)
      v16 = v26;
    if (v16 == *(_QWORD *)(a1 + 928))
      *(_BYTE *)(a1 + 936) = 1;
  }
  return v16;
}

uint64_t sub_1C5E097C4(const char **a1, _BYTE *a2, _BYTE *a3)
{
  const char *v6;
  const char *v7;
  uint64_t v8;
  uint64_t result;
  uint64_t v10;

  v6 = *a1;
  v7 = a1[1];
  if ((unint64_t)(v7 - *a1) >= 2 && !strncmp("St", v6, 2uLL))
  {
    *a1 = v6 + 2;
    result = sub_1C5DF9BE8((uint64_t)a1, "std");
    if (!result)
      return result;
    v8 = result;
    v6 = *a1;
    v7 = a1[1];
  }
  else
  {
    v8 = 0;
  }
  if (v7 == v6 || *v6 != 83)
  {
    v10 = 0;
    return sub_1C5E0FEA4((uint64_t)a1, a2, v8, v10);
  }
  result = sub_1C5E0ED94((uint64_t)a1);
  if (!result)
    return result;
  v10 = result;
  if (*(_BYTE *)(result + 8) == 25)
    return sub_1C5E0FEA4((uint64_t)a1, a2, v8, v10);
  result = 0;
  if (a3)
  {
    if (!v8)
    {
      *a3 = 1;
      return v10;
    }
  }
  return result;
}

char *sub_1C5E098BC(unsigned __int8 **a1)
{
  unsigned __int8 *v1;
  int v3;
  char *result;
  unint64_t v5;
  unint64_t v6;
  char *v7;

  v1 = *a1;
  if ((unint64_t)(a1[1] - *a1) < 2)
    return 0;
  v3 = *v1;
  result = &byte_1E81A1278;
  v5 = 62;
  do
  {
    v6 = v5 >> 1;
    v7 = &result[16 * (v5 >> 1)];
    if (*v7 < (char)v3 || *v7 == v3 && v7[1] < (char)v1[1])
    {
      result = v7 + 16;
      v6 = v5 + ~v6;
    }
    v5 = v6;
  }
  while (v6);
  if (result == (char *)&unk_1E81A1658 || *result != v3 || result[1] != v1[1])
    return 0;
  *a1 = v1 + 2;
  return result;
}

uint64_t sub_1C5E09964(uint64_t a1, unsigned __int8 *a2, uint64_t a3, int a4)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int *v14;
  BOOL v15;
  BOOL v16;
  uint64_t v17;
  int v18;
  unint64_t v19;
  unsigned int v20;
  int v21;
  uint64_t v22;
  int v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  _BYTE v28[128];
  void *v29;
  uint64_t v30;
  _QWORD v31[18];

  v31[16] = *MEMORY[0x1E0C80C00];
  v8 = sub_1C5E042EC(a1);
  if (!v8)
    return 0;
  v9 = v8;
  v10 = *(unsigned __int8 *)(a1 + 937);
  v26 = v28;
  v27 = 0x2000000000;
  sub_1C5E029D0((unsigned int *)&v26, 62, a2, a3, v8, a4);
  v11 = sub_1C4F5AB38(v26, (uint64_t)v26 + 4 * v27);
  v13 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v11);
  v14 = *(unsigned int **)v13;
  v29 = v31;
  v30 = 0x2000000000;
  if (v14)
    v15 = (v14 & 1) == 0;
  else
    v15 = 0;
  if (!v15)
    goto LABEL_19;
  while (1)
  {
    LOBYTE(v11) = sub_1C5DFE6F4(v11, v14, (uint64_t)&v26, v12, (unsigned int *)&v29);
    if ((v11 & 1) != 0)
      break;
    LODWORD(v30) = 0;
    v14 = *(unsigned int **)v14;
    if (v14)
      v16 = (v14 & 1) == 0;
    else
      v16 = 0;
    if (!v16)
    {
      v14 = 0;
      goto LABEL_15;
    }
  }
  v13 = 0;
LABEL_15:
  if (v29 != v31)
  {
    free(v29);
    if (v14)
      goto LABEL_17;
LABEL_19:
    if (v10)
    {
      v19 = sub_1C484358C(a1 + 808, 48, 3);
      *(_QWORD *)v19 = 0;
      *(_QWORD *)(v19 + 8) = &unk_1E816ADF0;
      v17 = v19 + 8;
      *(_BYTE *)(v19 + 16) = 62;
      *(_WORD *)(v19 + 17) = *(_WORD *)(v19 + 17) & 0xF000 | a4 & 0x3F | 0x540;
      *(_QWORD *)(v19 + 24) = a2;
      *(_QWORD *)(v19 + 32) = a3;
      *(_QWORD *)(v19 + 40) = v9;
      v20 = *(_DWORD *)(a1 + 916) + 1;
      v21 = *(_DWORD *)(a1 + 912);
      if (v20 > 2 * v21)
      {
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v21, (uint64_t)off_1E81A1260);
        v29 = v31;
        v30 = 0x2000000000;
        sub_1C5DFE788((unsigned int *)v19, (unsigned int *)&v29);
        v13 = *(_QWORD *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v29, (uint64_t)v29 + 4 * v30));
        if (v29 != v31)
          free(v29);
        v20 = *(_DWORD *)(a1 + 916) + 1;
      }
      *(_DWORD *)(a1 + 916) = v20;
      v22 = *(_QWORD *)v13;
      if (!*(_QWORD *)v13)
        v22 = v13 | 1;
      *(_QWORD *)v19 = v22;
      *(_QWORD *)v13 = v19;
    }
    else
    {
      v17 = 0;
    }
    v18 = 1;
    goto LABEL_26;
  }
  if (!v14)
    goto LABEL_19;
LABEL_17:
  v18 = 0;
  v17 = (uint64_t)(v14 + 2);
LABEL_26:
  if (v26 != v28)
    free(v26);
  if (v18)
  {
    *(_QWORD *)(a1 + 920) = v17;
  }
  else if (v17)
  {
    v29 = 0;
    v24 = sub_1C627E01C(a1 + 944, v17, &v29);
    v25 = 0;
    if (v24)
      v25 = *((_QWORD *)v29 + 1);
    if (v25)
      v17 = v25;
    if (v17 == *(_QWORD *)(a1 + 928))
      *(_BYTE *)(a1 + 936) = 1;
  }
  return v17;
}

uint64_t sub_1C5E09C48(uint64_t a1, uint64_t *a2, __int128 *a3, int *a4)
{
  int v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;
  BOOL v13;
  BOOL v14;
  int v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  char v19;
  __int128 v20;
  unsigned int v21;
  int v22;
  uint64_t v23;
  int v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  _BYTE v29[128];
  void *v30;
  uint64_t v31;
  _QWORD v32[17];

  v32[16] = *MEMORY[0x1E0C80C00];
  v8 = *(unsigned __int8 *)(a1 + 937);
  v27 = v29;
  v28 = 0x2000000000;
  sub_1C5E01FCC(&v27, 59, *a2, *(uint64_t **)a3, *((_QWORD *)a3 + 1), *a4);
  v9 = sub_1C4F5AB38(v27, (uint64_t)v27 + 4 * v28);
  v11 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v9);
  v12 = *(unsigned int **)v11;
  v30 = v32;
  v31 = 0x2000000000;
  if (v12)
    v13 = (v12 & 1) == 0;
  else
    v13 = 0;
  if (!v13)
    goto LABEL_17;
  while (1)
  {
    LOBYTE(v9) = sub_1C5DFE6F4(v9, v12, (uint64_t)&v27, v10, (unsigned int *)&v30);
    if ((v9 & 1) != 0)
      break;
    LODWORD(v31) = 0;
    v12 = *(unsigned int **)v12;
    if (v12)
      v14 = (v12 & 1) == 0;
    else
      v14 = 0;
    if (!v14)
    {
      v12 = 0;
      goto LABEL_13;
    }
  }
  v11 = 0;
LABEL_13:
  if (v30 == v32)
  {
    if (v12)
    {
LABEL_15:
      v15 = 0;
      v16 = (uint64_t)(v12 + 2);
      goto LABEL_24;
    }
  }
  else
  {
    free(v30);
    if (v12)
      goto LABEL_15;
  }
LABEL_17:
  if (v8)
  {
    v17 = sub_1C484358C(a1 + 808, 48, 3);
    *(_QWORD *)(v17 + 8) = &unk_1E816B000;
    v16 = v17 + 8;
    *(_QWORD *)v17 = 0;
    v18 = *a2;
    v19 = *(_WORD *)a4;
    *(_BYTE *)(v17 + 16) = 59;
    v20 = *a3;
    *(_WORD *)(v17 + 17) = *(_WORD *)(v17 + 17) & 0xF000 | v19 & 0x3F | 0x540;
    *(_QWORD *)(v17 + 24) = v18;
    *(_OWORD *)(v17 + 32) = v20;
    v21 = *(_DWORD *)(a1 + 916) + 1;
    v22 = *(_DWORD *)(a1 + 912);
    if (v21 > 2 * v22)
    {
      llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v22, (uint64_t)off_1E81A1260);
      v30 = v32;
      v31 = 0x2000000000;
      sub_1C5DFE788((unsigned int *)v17, (unsigned int *)&v30);
      v11 = *(_QWORD *)(a1 + 904)
          + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v30, (uint64_t)v30 + 4 * v31));
      if (v30 != v32)
        free(v30);
      v21 = *(_DWORD *)(a1 + 916) + 1;
    }
    *(_DWORD *)(a1 + 916) = v21;
    v23 = *(_QWORD *)v11;
    if (!*(_QWORD *)v11)
      v23 = v11 | 1;
    *(_QWORD *)v17 = v23;
    *(_QWORD *)v11 = v17;
  }
  else
  {
    v16 = 0;
  }
  v15 = 1;
LABEL_24:
  if (v27 != v29)
    free(v27);
  if (v15)
  {
    *(_QWORD *)(a1 + 920) = v16;
  }
  else if (v16)
  {
    v30 = 0;
    v25 = sub_1C627E01C(a1 + 944, v16, &v30);
    v26 = 0;
    if (v25)
      v26 = *((_QWORD *)v30 + 1);
    if (v26)
      v16 = v26;
    if (v16 == *(_QWORD *)(a1 + 928))
      *(_BYTE *)(a1 + 936) = 1;
  }
  return v16;
}

uint64_t sub_1C5E09F20(uint64_t a1)
{
  _BYTE *v1;
  unsigned __int8 *v2;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned __int8 *v7;
  uint64_t v8;
  int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int *v13;
  BOOL v14;
  BOOL v15;
  uint64_t v16;
  uint64_t v17;
  unsigned __int8 *v18;
  unsigned __int8 *v19;
  unsigned __int8 *v20;
  unsigned __int8 *v21;
  unsigned __int8 *v22;
  int v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int *v27;
  BOOL v28;
  BOOL v29;
  int v30;
  char *v31;
  char *v32;
  unsigned __int8 *v33;
  uint64_t v34;
  _BYTE *v35;
  int v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unsigned int *v40;
  BOOL v41;
  BOOL v42;
  unsigned __int8 *v44;
  uint64_t v45;
  unsigned __int8 *v46;
  int v47;
  unint64_t v48;
  uint64_t v49;
  BOOL v50;
  uint64_t v51;
  int v52;
  unint64_t v53;
  uint64_t v54;
  BOOL v55;
  BOOL v56;
  uint64_t v57;
  int v58;
  unint64_t v59;
  uint64_t v60;
  BOOL v61;
  BOOL v62;
  int v63;
  unint64_t v64;
  unsigned int *v65;
  char v66;
  unint64_t v67;
  unsigned int *v68;
  char v69;
  unint64_t v70;
  unsigned int v71;
  int v72;
  uint64_t v73;
  void *v74;
  unsigned int *v75;
  unsigned int v76;
  int v77;
  uint64_t v78;
  int v79;
  uint64_t v80;
  unsigned int v81;
  int v82;
  uint64_t v83;
  void *v84;
  __int128 v85;
  uint64_t v86;
  _BYTE v87[112];
  void *v88;
  uint64_t v89;
  _QWORD v90[17];

  v90[16] = *MEMORY[0x1E0C80C00];
  v2 = *(unsigned __int8 **)a1;
  v1 = *(_BYTE **)(a1 + 8);
  if (*(_BYTE **)a1 != v1 && *v2 == 76)
  {
    *(_QWORD *)a1 = v2 + 1;
    v4 = v1 - (v2 + 1);
    if (v1 != v2 + 1)
    {
      v5 = 0;
      switch(v2[1])
      {
        case 'A':
          v6 = sub_1C5DF9EB0(a1);
          if (!v6)
            return 0;
          v7 = *(unsigned __int8 **)a1;
          if (*(_QWORD *)a1 == *(_QWORD *)(a1 + 8) || *v7 != 69)
            return 0;
          v8 = v6;
          *(_QWORD *)a1 = v7 + 1;
          v9 = *(unsigned __int8 *)(a1 + 937);
          v84 = (char *)&v85 + 8;
          v86 = v6;
          v85 = xmmword_1C866FB60;
          v10 = sub_1C4F5AB38((_QWORD *)&v85 + 1, (uint64_t)v87);
          v12 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v10);
          v13 = *(unsigned int **)v12;
          v88 = v90;
          v89 = 0x2000000000;
          if (v13)
            v14 = (v13 & 1) == 0;
          else
            v14 = 0;
          if (!v14)
            goto LABEL_178;
          while (1)
          {
            LOBYTE(v10) = sub_1C5DFE6F4(v10, v13, (uint64_t)&v84, v11, (unsigned int *)&v88);
            if ((v10 & 1) != 0)
              break;
            LODWORD(v89) = 0;
            v13 = *(unsigned int **)v13;
            if (v13)
              v15 = (v13 & 1) == 0;
            else
              v15 = 0;
            if (!v15)
            {
              v13 = 0;
              goto LABEL_140;
            }
          }
          v12 = 0;
LABEL_140:
          if (v88 == v90)
          {
            if (v13)
              goto LABEL_142;
          }
          else
          {
            free(v88);
            if (v13)
              goto LABEL_142;
          }
LABEL_178:
          if (!v9)
            goto LABEL_184;
          v67 = sub_1C484358C(a1 + 808, 32, 3);
          v68 = (unsigned int *)v67;
          *(_QWORD *)v67 = 0;
          *(_QWORD *)(v67 + 8) = &unk_1E816B370;
          v5 = v67 + 8;
          v69 = 70;
          goto LABEL_180;
        case 'D':
          if (v4 < 3 || strncmp("DnE", (const char *)v2 + 1, 3uLL))
            return 0;
          *(_QWORD *)a1 = v2 + 4;
          return sub_1C5DF9BE8(a1, "nullptr");
        case 'T':
          return v5;
        case 'U':
          if (v4 < 2)
            return 0;
          if (v2[2] != 108)
            return 0;
          v45 = sub_1C5E0C534(a1, 0);
          if (!v45)
            return 0;
          v46 = *(unsigned __int8 **)a1;
          if (*(_QWORD *)a1 == *(_QWORD *)(a1 + 8) || *v46 != 69)
            return 0;
          v8 = v45;
          *(_QWORD *)a1 = v46 + 1;
          v47 = *(unsigned __int8 *)(a1 + 937);
          v84 = (char *)&v85 + 8;
          v86 = v45;
          v85 = xmmword_1C866FB50;
          v48 = sub_1C4F5AB38((_QWORD *)&v85 + 1, (uint64_t)v87);
          v12 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v48);
          v13 = *(unsigned int **)v12;
          v88 = v90;
          v89 = 0x2000000000;
          if (!v13 || (v13 & 1) != 0)
            goto LABEL_160;
          while (1)
          {
            LOBYTE(v48) = sub_1C5DFE6F4(v48, v13, (uint64_t)&v84, v49, (unsigned int *)&v88);
            if ((v48 & 1) != 0)
              break;
            LODWORD(v89) = 0;
            v13 = *(unsigned int **)v13;
            if (v13)
              v50 = (v13 & 1) == 0;
            else
              v50 = 0;
            if (!v50)
            {
              v13 = 0;
              goto LABEL_158;
            }
          }
          v12 = 0;
LABEL_158:
          if (v88 == v90)
          {
            if (!v13)
            {
LABEL_160:
              if (v47)
              {
                v67 = sub_1C484358C(a1 + 808, 32, 3);
                v68 = (unsigned int *)v67;
                *(_QWORD *)v67 = 0;
                *(_QWORD *)(v67 + 8) = &unk_1E816B630;
                v5 = v67 + 8;
                v69 = 71;
LABEL_180:
                *(_BYTE *)(v67 + 16) = v69;
                *(_WORD *)(v67 + 17) = *(_WORD *)(v67 + 17) & 0xF000 | 0x540;
                *(_QWORD *)(v67 + 24) = v8;
                v76 = *(_DWORD *)(a1 + 916) + 1;
                v77 = *(_DWORD *)(a1 + 912);
                if (v76 > 2 * v77)
                {
                  llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v77, (uint64_t)off_1E81A1260);
                  v88 = v90;
                  v89 = 0x2000000000;
                  sub_1C5DFE788(v68, (unsigned int *)&v88);
                  v12 = *(_QWORD *)(a1 + 904)
                      + 8
                      * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v88, (uint64_t)v88 + 4 * v89));
                  if (v88 != v90)
                    free(v88);
                  v76 = *(_DWORD *)(a1 + 916) + 1;
                }
                *(_DWORD *)(a1 + 916) = v76;
                v78 = *(_QWORD *)v12;
                if (!*(_QWORD *)v12)
                  v78 = v12 | 1;
                *(_QWORD *)v68 = v78;
                *(_QWORD *)v12 = v68;
              }
              else
              {
LABEL_184:
                v5 = 0;
              }
              v63 = 1;
LABEL_186:
              if (v84 != (char *)&v85 + 8)
                free(v84);
              if (!v63)
              {
LABEL_189:
                if (v5)
                {
                  v88 = 0;
                  v79 = sub_1C627E01C(a1 + 944, v5, &v88);
                  v80 = 0;
                  if (v79)
                    v80 = *((_QWORD *)v88 + 1);
                  if (v80)
                    v5 = v80;
                  if (v5 == *(_QWORD *)(a1 + 928))
                    *(_BYTE *)(a1 + 936) = 1;
                }
                return v5;
              }
              goto LABEL_173;
            }
          }
          else
          {
            free(v88);
            if (!v13)
              goto LABEL_160;
          }
LABEL_142:
          v63 = 0;
          v5 = (uint64_t)(v13 + 2);
          goto LABEL_186;
        case '_':
          if (v4 < 2 || strncmp("_Z", (const char *)v2 + 1, 2uLL))
            return 0;
          *(_QWORD *)a1 = v2 + 3;
          v5 = sub_1C5DFC50C((unsigned __int8 **)a1);
          if (!v5)
            return v5;
          v44 = *(unsigned __int8 **)a1;
          if (*(_QWORD *)a1 == *(_QWORD *)(a1 + 8) || *v44 != 69)
            return 0;
          *(_QWORD *)a1 = v44 + 1;
          return v5;
        case 'a':
          *(_QWORD *)a1 = v2 + 2;
          v31 = "signed char";
          v32 = "";
          return sub_1C5E0BF60(a1, (unsigned __int8 *)v31, (uint64_t)v32);
        case 'b':
          if (v4 < 3)
            return 0;
          if (!strncmp("b0E", (const char *)v2 + 1, 3uLL))
          {
            *(_QWORD *)a1 = v2 + 4;
            LODWORD(v88) = 0;
          }
          else
          {
            if (strncmp("b1E", (const char *)v2 + 1, 3uLL))
              return 0;
            *(_QWORD *)a1 = v2 + 4;
            LODWORD(v88) = 1;
          }
          return sub_1C5E0C27C(a1, &v88);
        case 'c':
          *(_QWORD *)a1 = v2 + 2;
          v31 = "char";
          v32 = "";
          return sub_1C5E0BF60(a1, (unsigned __int8 *)v31, (uint64_t)v32);
        case 'd':
          v33 = v2 + 2;
          *(_QWORD *)a1 = v2 + 2;
          if ((unint64_t)(v1 - (v2 + 2)) < 0x11)
            return 0;
          v51 = 0;
          v35 = v2 + 18;
          while (((char)v33[v51] & 0x80000000) == 0
               && (*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v33[v51] + 60) & 0x10000) != 0)
          {
            if (++v51 == 16)
            {
              *(_QWORD *)a1 = v35;
              if (v35 == v1 || *v35 != 69)
                return 0;
              *(_QWORD *)a1 = v2 + 19;
              v52 = *(unsigned __int8 *)(a1 + 937);
              v84 = (char *)&v85 + 8;
              v85 = xmmword_1C866FB80;
              llvm::FoldingSetNodeID::AddString((unsigned int *)&v84, v33, 0x10u);
              v53 = sub_1C4F5AB38(v84, (uint64_t)v84 + 4 * v85);
              v39 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v53);
              v40 = *(unsigned int **)v39;
              v88 = v90;
              v89 = 0x2000000000;
              if (v40)
                v55 = (v40 & 1) == 0;
              else
                v55 = 0;
              if (v55)
              {
                while (1)
                {
                  LOBYTE(v53) = sub_1C5DFE6F4(v53, v40, (uint64_t)&v84, v54, (unsigned int *)&v88);
                  if ((v53 & 1) != 0)
                    break;
                  LODWORD(v89) = 0;
                  v40 = *(unsigned int **)v40;
                  if (v40)
                    v56 = (v40 & 1) == 0;
                  else
                    v56 = 0;
                  if (!v56)
                  {
                    v40 = 0;
                    goto LABEL_149;
                  }
                }
                v39 = 0;
LABEL_149:
                if (v88 == v90)
                {
                  if (v40)
                    goto LABEL_156;
                }
                else
                {
                  free(v88);
                  if (v40)
                    goto LABEL_156;
                }
              }
              if (!v52)
                goto LABEL_210;
              v64 = sub_1C484358C(a1 + 808, 40, 3);
              v65 = (unsigned int *)v64;
              *(_QWORD *)v64 = 0;
              *(_QWORD *)(v64 + 8) = &unk_1E816B2C0;
              v5 = v64 + 8;
              v66 = 75;
              goto LABEL_206;
            }
          }
          return 0;
        case 'e':
          v33 = v2 + 2;
          *(_QWORD *)a1 = v2 + 2;
          if ((unint64_t)(v1 - (v2 + 2)) < 0x21)
            return 0;
          v57 = 0;
          v35 = v2 + 34;
          while (((char)v33[v57] & 0x80000000) == 0
               && (*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v33[v57] + 60) & 0x10000) != 0)
          {
            if (++v57 == 32)
            {
              *(_QWORD *)a1 = v35;
              if (v35 == v1 || *v35 != 69)
                return 0;
              *(_QWORD *)a1 = v2 + 35;
              v58 = *(unsigned __int8 *)(a1 + 937);
              v84 = (char *)&v85 + 8;
              v85 = xmmword_1C866FB70;
              llvm::FoldingSetNodeID::AddString((unsigned int *)&v84, v33, 0x20u);
              v59 = sub_1C4F5AB38(v84, (uint64_t)v84 + 4 * v85);
              v39 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v59);
              v40 = *(unsigned int **)v39;
              v88 = v90;
              v89 = 0x2000000000;
              if (v40)
                v61 = (v40 & 1) == 0;
              else
                v61 = 0;
              if (v61)
              {
                while (1)
                {
                  LOBYTE(v59) = sub_1C5DFE6F4(v59, v40, (uint64_t)&v84, v60, (unsigned int *)&v88);
                  if ((v59 & 1) != 0)
                    break;
                  LODWORD(v89) = 0;
                  v40 = *(unsigned int **)v40;
                  if (v40)
                    v62 = (v40 & 1) == 0;
                  else
                    v62 = 0;
                  if (!v62)
                  {
                    v40 = 0;
                    goto LABEL_154;
                  }
                }
                v39 = 0;
LABEL_154:
                if (v88 == v90)
                {
                  if (v40)
                    goto LABEL_156;
                }
                else
                {
                  free(v88);
                  if (v40)
                    goto LABEL_156;
                }
              }
              if (v58)
              {
                v64 = sub_1C484358C(a1 + 808, 40, 3);
                v65 = (unsigned int *)v64;
                *(_QWORD *)v64 = 0;
                *(_QWORD *)(v64 + 8) = &unk_1E816B318;
                v5 = v64 + 8;
                v66 = 76;
                goto LABEL_206;
              }
              goto LABEL_210;
            }
          }
          return 0;
        case 'f':
          v33 = v2 + 2;
          *(_QWORD *)a1 = v2 + 2;
          if ((unint64_t)(v1 - (v2 + 2)) < 9)
            return 0;
          v34 = 0;
          v35 = v2 + 10;
          do
          {
            if ((char)v33[v34] < 0 || (*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v33[v34] + 60) & 0x10000) == 0)
              return 0;
            ++v34;
          }
          while (v34 != 8);
          *(_QWORD *)a1 = v35;
          if (v35 == v1 || *v35 != 69)
            return 0;
          *(_QWORD *)a1 = v2 + 11;
          v36 = *(unsigned __int8 *)(a1 + 937);
          v84 = (char *)&v85 + 8;
          v85 = xmmword_1C866FB90;
          llvm::FoldingSetNodeID::AddString((unsigned int *)&v84, v33, 8u);
          v37 = sub_1C4F5AB38(v84, (uint64_t)v84 + 4 * v85);
          v39 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v37);
          v40 = *(unsigned int **)v39;
          v88 = v90;
          v89 = 0x2000000000;
          if (v40)
            v41 = (v40 & 1) == 0;
          else
            v41 = 0;
          if (!v41)
            goto LABEL_146;
          while (1)
          {
            LOBYTE(v37) = sub_1C5DFE6F4(v37, v40, (uint64_t)&v84, v38, (unsigned int *)&v88);
            if ((v37 & 1) != 0)
              break;
            LODWORD(v89) = 0;
            v40 = *(unsigned int **)v40;
            if (v40)
              v42 = (v40 & 1) == 0;
            else
              v42 = 0;
            if (!v42)
            {
              v40 = 0;
              goto LABEL_144;
            }
          }
          v39 = 0;
LABEL_144:
          if (v88 == v90)
          {
            if (!v40)
            {
LABEL_146:
              if (v36)
              {
                v64 = sub_1C484358C(a1 + 808, 40, 3);
                v65 = (unsigned int *)v64;
                *(_QWORD *)v64 = 0;
                *(_QWORD *)(v64 + 8) = &unk_1E816B268;
                v5 = v64 + 8;
                v66 = 74;
LABEL_206:
                *(_BYTE *)(v64 + 16) = v66;
                *(_WORD *)(v64 + 17) = *(_WORD *)(v64 + 17) & 0xF000 | 0x540;
                *(_QWORD *)(v64 + 24) = v33;
                *(_QWORD *)(v64 + 32) = v35;
                v81 = *(_DWORD *)(a1 + 916) + 1;
                v82 = *(_DWORD *)(a1 + 912);
                if (v81 > 2 * v82)
                {
                  llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v82, (uint64_t)off_1E81A1260);
                  v88 = v90;
                  v89 = 0x2000000000;
                  sub_1C5DFE788(v65, (unsigned int *)&v88);
                  v39 = *(_QWORD *)(a1 + 904)
                      + 8
                      * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v88, (uint64_t)v88 + 4 * v89));
                  if (v88 != v90)
                    free(v88);
                  v81 = *(_DWORD *)(a1 + 916) + 1;
                }
                *(_DWORD *)(a1 + 916) = v81;
                v83 = *(_QWORD *)v39;
                if (!*(_QWORD *)v39)
                  v83 = v39 | 1;
                *(_QWORD *)v65 = v83;
                *(_QWORD *)v39 = v65;
              }
              else
              {
LABEL_210:
                v5 = 0;
              }
              v30 = 1;
LABEL_212:
              v74 = v84;
              if (v84 != (char *)&v85 + 8)
                goto LABEL_171;
              goto LABEL_172;
            }
          }
          else
          {
            free(v88);
            if (!v40)
              goto LABEL_146;
          }
LABEL_156:
          v30 = 0;
          v5 = (uint64_t)(v40 + 2);
          goto LABEL_212;
        case 'h':
          *(_QWORD *)a1 = v2 + 2;
          v31 = "unsigned char";
          v32 = "";
          return sub_1C5E0BF60(a1, (unsigned __int8 *)v31, (uint64_t)v32);
        case 'i':
          *(_QWORD *)a1 = v2 + 2;
          v31 = "";
          v32 = "";
          return sub_1C5E0BF60(a1, (unsigned __int8 *)v31, (uint64_t)v32);
        case 'j':
          *(_QWORD *)a1 = v2 + 2;
          v31 = "u";
          goto LABEL_92;
        case 'l':
          *(_QWORD *)a1 = v2 + 2;
          v31 = "l";
LABEL_92:
          v32 = v31 + 1;
          return sub_1C5E0BF60(a1, (unsigned __int8 *)v31, (uint64_t)v32);
        case 'm':
          *(_QWORD *)a1 = v2 + 2;
          v31 = "ul";
          goto LABEL_94;
        case 'n':
          *(_QWORD *)a1 = v2 + 2;
          v31 = "__int128";
          v32 = "";
          return sub_1C5E0BF60(a1, (unsigned __int8 *)v31, (uint64_t)v32);
        case 'o':
          *(_QWORD *)a1 = v2 + 2;
          v31 = "unsigned __int128";
          v32 = "";
          return sub_1C5E0BF60(a1, (unsigned __int8 *)v31, (uint64_t)v32);
        case 's':
          *(_QWORD *)a1 = v2 + 2;
          v31 = "short";
          v32 = "";
          return sub_1C5E0BF60(a1, (unsigned __int8 *)v31, (uint64_t)v32);
        case 't':
          *(_QWORD *)a1 = v2 + 2;
          v31 = "unsigned short";
          v32 = "";
          return sub_1C5E0BF60(a1, (unsigned __int8 *)v31, (uint64_t)v32);
        case 'w':
          *(_QWORD *)a1 = v2 + 2;
          v31 = "wchar_t";
          v32 = "";
          return sub_1C5E0BF60(a1, (unsigned __int8 *)v31, (uint64_t)v32);
        case 'x':
          *(_QWORD *)a1 = v2 + 2;
          v31 = "ll";
LABEL_94:
          v32 = v31 + 2;
          return sub_1C5E0BF60(a1, (unsigned __int8 *)v31, (uint64_t)v32);
        case 'y':
          *(_QWORD *)a1 = v2 + 2;
          v31 = "ull";
          v32 = "";
          return sub_1C5E0BF60(a1, (unsigned __int8 *)v31, (uint64_t)v32);
        default:
          break;
      }
    }
    v16 = sub_1C5DF9EB0(a1);
    if (v16)
    {
      v17 = v16;
      v18 = (unsigned __int8 *)sub_1C54C21F4((char **)a1, 1);
      if (v19 != v18)
      {
        v20 = *(unsigned __int8 **)a1;
        if (*(_QWORD *)a1 != *(_QWORD *)(a1 + 8) && *v20 == 69)
        {
          v21 = v18;
          v22 = v19;
          *(_QWORD *)a1 = v20 + 1;
          v23 = *(unsigned __int8 *)(a1 + 937);
          v84 = (char *)&v85 + 8;
          v86 = v17;
          v85 = xmmword_1C866FBA0;
          llvm::FoldingSetNodeID::AddString((unsigned int *)&v84, v18, (_DWORD)v19 - (_DWORD)v18);
          v24 = sub_1C4F5AB38(v84, (uint64_t)v84 + 4 * v85);
          v26 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v24);
          v27 = *(unsigned int **)v26;
          v88 = v90;
          v89 = 0x2000000000;
          if (v27)
            v28 = (v27 & 1) == 0;
          else
            v28 = 0;
          if (!v28)
            goto LABEL_163;
          while (1)
          {
            LOBYTE(v24) = sub_1C5DFE6F4(v24, v27, (uint64_t)&v84, v25, (unsigned int *)&v88);
            if ((v24 & 1) != 0)
              break;
            LODWORD(v89) = 0;
            v27 = *(unsigned int **)v27;
            if (v27)
              v29 = (v27 & 1) == 0;
            else
              v29 = 0;
            if (!v29)
            {
              v27 = 0;
              goto LABEL_35;
            }
          }
          v26 = 0;
LABEL_35:
          if (v88 == v90)
          {
            if (v27)
            {
LABEL_37:
              v30 = 0;
              v5 = (uint64_t)(v27 + 2);
              goto LABEL_170;
            }
          }
          else
          {
            free(v88);
            if (v27)
              goto LABEL_37;
          }
LABEL_163:
          if (v23)
          {
            v70 = sub_1C484358C(a1 + 808, 48, 3);
            *(_QWORD *)v70 = 0;
            *(_QWORD *)(v70 + 8) = &unk_1E816B688;
            v5 = v70 + 8;
            *(_BYTE *)(v70 + 16) = 72;
            *(_WORD *)(v70 + 17) = *(_WORD *)(v70 + 17) & 0xF000 | 0x540;
            *(_QWORD *)(v70 + 24) = v17;
            *(_QWORD *)(v70 + 32) = v21;
            *(_QWORD *)(v70 + 40) = v22;
            v71 = *(_DWORD *)(a1 + 916) + 1;
            v72 = *(_DWORD *)(a1 + 912);
            if (v71 > 2 * v72)
            {
              v75 = (unsigned int *)v70;
              llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v72, (uint64_t)off_1E81A1260);
              v88 = v90;
              v89 = 0x2000000000;
              sub_1C5DFE788(v75, (unsigned int *)&v88);
              v26 = *(_QWORD *)(a1 + 904)
                  + 8
                  * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v88, (uint64_t)v88 + 4 * v89));
              if (v88 != v90)
                free(v88);
              v71 = *(_DWORD *)(a1 + 916) + 1;
              v70 = (unint64_t)v75;
            }
            *(_DWORD *)(a1 + 916) = v71;
            v73 = *(_QWORD *)v26;
            if (!*(_QWORD *)v26)
              v73 = v26 | 1;
            *(_QWORD *)v70 = v73;
            *(_QWORD *)v26 = v70;
          }
          else
          {
            v5 = 0;
          }
          v30 = 1;
LABEL_170:
          v74 = v84;
          if (v84 != (char *)&v85 + 8)
LABEL_171:
            free(v74);
LABEL_172:
          if (!v30)
            goto LABEL_189;
LABEL_173:
          *(_QWORD *)(a1 + 920) = v5;
          return v5;
        }
      }
    }
  }
  return 0;
}

uint64_t sub_1C5E0AF04(uint64_t a1)
{
  const char *v2;
  unint64_t v3;
  char *v4;
  char *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  __int128 v11;

  v2 = *(const char **)a1;
  v3 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if (v3 >= 3)
  {
    if (!strncmp("fpT", v2, 3uLL))
    {
      *(_QWORD *)a1 = v2 + 3;
      return sub_1C5DF9BE8(a1, "this");
    }
LABEL_5:
    if (!strncmp("fp", v2, 2uLL))
    {
      v7 = (char *)(v2 + 2);
    }
    else
    {
      if (strncmp("fL", v2, 2uLL))
        return 0;
      *(_QWORD *)a1 = v2 + 2;
      v4 = sub_1C54C21F4((char **)a1, 0);
      if (v4 == v5)
        return 0;
      v6 = *(char **)a1;
      if (*(_QWORD *)a1 == *(_QWORD *)(a1 + 8) || *v6 != 112)
        return 0;
      v7 = v6 + 1;
    }
    *(_QWORD *)a1 = v7;
    sub_1C54C4768(a1);
    *(_QWORD *)&v11 = sub_1C54C21F4((char **)a1, 0);
    *((_QWORD *)&v11 + 1) = v8;
    v9 = *(char **)a1;
    if (*(_QWORD *)a1 != *(_QWORD *)(a1 + 8) && *v9 == 95)
    {
      *(_QWORD *)a1 = v9 + 1;
      return sub_1C5E0DD60(a1, &v11);
    }
    return 0;
  }
  if (v3 == 2)
    goto LABEL_5;
  return 0;
}

uint64_t sub_1C5E0B040(uint64_t a1)
{
  _BYTE *v2;
  int v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int *v16;
  BOOL v17;
  BOOL v18;
  int v19;
  unint64_t v20;
  unsigned int v21;
  int v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  unsigned int *v26;
  char v27;
  void *v28;
  __int128 v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  uint64_t v35;
  _QWORD v36[18];

  v36[16] = *MEMORY[0x1E0C80C00];
  v2 = *(_BYTE **)a1;
  if (*(_QWORD *)(a1 + 8) - *(_QWORD *)a1 < 2uLL || *v2 != 100)
    return sub_1C5E042EC(a1);
  v3 = (char)v2[1];
  if (v3 == 88)
  {
    *(_QWORD *)a1 = v2 + 2;
    v6 = sub_1C5E042EC(a1);
    if (!v6)
      return 0;
    v7 = v6;
    v8 = sub_1C5E042EC(a1);
    if (!v8)
      return 0;
    v9 = v8;
    v10 = sub_1C5E0B040(a1);
    if (!v10)
      return 0;
    v11 = v10;
    v12 = *(unsigned __int8 *)(a1 + 937);
    v28 = (char *)&v29 + 8;
    v30 = v7;
    v31 = v9;
    v32 = v10;
    v29 = xmmword_1C866FBB0;
    v13 = sub_1C4F5AB38((_QWORD *)&v29 + 1, (uint64_t)&v33);
    v15 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v13);
    v16 = *(unsigned int **)v15;
    v34 = v36;
    v35 = 0x2000000000;
    if (v16)
      v17 = (v16 & 1) == 0;
    else
      v17 = 0;
    if (!v17)
      goto LABEL_35;
    while (1)
    {
      LOBYTE(v13) = sub_1C5DFE6F4(v13, v16, (uint64_t)&v28, v14, (unsigned int *)&v34);
      if ((v13 & 1) != 0)
        break;
      LODWORD(v35) = 0;
      v16 = *(unsigned int **)v16;
      if (v16)
        v18 = (v16 & 1) == 0;
      else
        v18 = 0;
      if (!v18)
      {
        v16 = 0;
        goto LABEL_31;
      }
    }
    v15 = 0;
LABEL_31:
    if (v34 == v36)
    {
      if (v16)
      {
LABEL_33:
        v19 = 0;
        v5 = (uint64_t)(v16 + 2);
LABEL_42:
        if (v28 != (char *)&v29 + 8)
          free(v28);
        if (v19)
        {
          *(_QWORD *)(a1 + 920) = v5;
        }
        else if (v5)
        {
          v34 = 0;
          v24 = sub_1C627E01C(a1 + 944, v5, &v34);
          v25 = 0;
          if (v24)
            v25 = v34[1];
          if (v25)
            v5 = v25;
          if (v5 == *(_QWORD *)(a1 + 928))
            *(_BYTE *)(a1 + 936) = 1;
        }
        return v5;
      }
    }
    else
    {
      free(v34);
      if (v16)
        goto LABEL_33;
    }
LABEL_35:
    if (v12)
    {
      v20 = sub_1C484358C(a1 + 808, 48, 3);
      *(_QWORD *)v20 = 0;
      *(_QWORD *)(v20 + 8) = &unk_1E816B840;
      v5 = v20 + 8;
      *(_BYTE *)(v20 + 16) = 78;
      *(_WORD *)(v20 + 17) = *(_WORD *)(v20 + 17) & 0xF000 | 0x540;
      *(_QWORD *)(v20 + 24) = v7;
      *(_QWORD *)(v20 + 32) = v9;
      *(_QWORD *)(v20 + 40) = v11;
      v21 = *(_DWORD *)(a1 + 916) + 1;
      v22 = *(_DWORD *)(a1 + 912);
      if (v21 > 2 * v22)
      {
        v26 = (unsigned int *)v20;
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v22, (uint64_t)off_1E81A1260);
        v34 = v36;
        v35 = 0x2000000000;
        sub_1C5DFE788(v26, (unsigned int *)&v34);
        v15 = *(_QWORD *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v34, (uint64_t)v34 + 4 * v35));
        if (v34 != v36)
          free(v34);
        v21 = *(_DWORD *)(a1 + 916) + 1;
        v20 = (unint64_t)v26;
      }
      *(_DWORD *)(a1 + 916) = v21;
      v23 = *(_QWORD *)v15;
      if (!*(_QWORD *)v15)
        v23 = v15 | 1;
      *(_QWORD *)v20 = v23;
      *(_QWORD *)v15 = v20;
    }
    else
    {
      v5 = 0;
    }
    v19 = 1;
    goto LABEL_42;
  }
  if (v3 == 120)
  {
    *(_QWORD *)a1 = v2 + 2;
    v34 = (_QWORD *)sub_1C5E042EC(a1);
    if (v34)
    {
      v28 = (void *)sub_1C5E0B040(a1);
      if (v28)
      {
        v27 = 1;
        return sub_1C5E0E01C(a1, (uint64_t *)&v34, (uint64_t *)&v28, &v27);
      }
    }
    return 0;
  }
  if (v3 != 105)
    return sub_1C5E042EC(a1);
  *(_QWORD *)a1 = v2 + 2;
  v34 = (_QWORD *)sub_1C5E0BC2C(a1);
  if (!v34)
    return 0;
  v28 = (void *)sub_1C5E0B040(a1);
  if (!v28)
    return 0;
  v27 = 0;
  return sub_1C5E0E01C(a1, (uint64_t *)&v34, (uint64_t *)&v28, &v27);
}

uint64_t sub_1C5E0B444(uint64_t a1, uint64_t *a2)
{
  int v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int *v11;
  BOOL v12;
  BOOL v13;
  int v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unsigned int v18;
  int v19;
  uint64_t v20;
  int v22;
  uint64_t v23;
  void *v24;
  unsigned int v25[34];
  void *v26;
  uint64_t v27;
  _QWORD v28[17];

  v28[16] = *MEMORY[0x1E0C80C00];
  v4 = *(unsigned __int8 *)(a1 + 937);
  v24 = &v25[2];
  v5 = *a2;
  *(_OWORD *)v25 = xmmword_1C866FAD0;
  llvm::FoldingSetNodeID::AddString((unsigned int *)&v24, "sizeof... ", 0xAu);
  v6 = v25[0];
  if (v25[0] >= v25[1])
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v24, (uint64_t)&v25[2], v25[0] + 1, 4);
    v6 = v25[0];
  }
  *((_DWORD *)v24 + v6) = v5;
  v7 = v25[0] + 1;
  v25[0] = v7;
  if (v7 >= v25[1])
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v24, (uint64_t)&v25[2], v7 + 1, 4);
    LODWORD(v7) = v25[0];
  }
  *((_DWORD *)v24 + v7) = HIDWORD(v5);
  ++v25[0];
  v8 = sub_1C4F5AB38(v24, (uint64_t)v24 + 4 * v25[0]);
  v10 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v8);
  v11 = *(unsigned int **)v10;
  v26 = v28;
  v27 = 0x2000000000;
  if (v11)
    v12 = (v11 & 1) == 0;
  else
    v12 = 0;
  if (!v12)
    goto LABEL_21;
  while (1)
  {
    LOBYTE(v8) = sub_1C5DFE6F4(v8, v11, (uint64_t)&v24, v9, (unsigned int *)&v26);
    if ((v8 & 1) != 0)
      break;
    LODWORD(v27) = 0;
    v11 = *(unsigned int **)v11;
    if (v11)
      v13 = (v11 & 1) == 0;
    else
      v13 = 0;
    if (!v13)
    {
      v11 = 0;
      goto LABEL_17;
    }
  }
  v10 = 0;
LABEL_17:
  if (v26 == v28)
  {
    if (v11)
    {
LABEL_19:
      v14 = 0;
      v15 = (uint64_t)(v11 + 2);
      goto LABEL_28;
    }
  }
  else
  {
    free(v26);
    if (v11)
      goto LABEL_19;
  }
LABEL_21:
  if (v4)
  {
    v16 = sub_1C484358C(a1 + 808, 64, 3);
    *(_QWORD *)v16 = 0;
    *(_QWORD *)(v16 + 8) = &unk_1E816B160;
    v15 = v16 + 8;
    v17 = *a2;
    *(_BYTE *)(v16 + 16) = 56;
    *(_WORD *)(v16 + 17) = *(_WORD *)(v16 + 17) & 0xF000 | 0x540;
    *(_QWORD *)(v16 + 24) = "sizeof... ";
    *(_QWORD *)(v16 + 32) = "";
    *(_QWORD *)(v16 + 48) = 0;
    *(_QWORD *)(v16 + 56) = 0;
    *(_QWORD *)(v16 + 40) = v17;
    v18 = *(_DWORD *)(a1 + 916) + 1;
    v19 = *(_DWORD *)(a1 + 912);
    if (v18 > 2 * v19)
    {
      llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v19, (uint64_t)off_1E81A1260);
      v26 = v28;
      v27 = 0x2000000000;
      sub_1C5DFE788((unsigned int *)v16, (unsigned int *)&v26);
      v10 = *(_QWORD *)(a1 + 904)
          + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v26, (uint64_t)v26 + 4 * v27));
      if (v26 != v28)
        free(v26);
      v18 = *(_DWORD *)(a1 + 916) + 1;
    }
    *(_DWORD *)(a1 + 916) = v18;
    v20 = *(_QWORD *)v10;
    if (!*(_QWORD *)v10)
      v20 = v10 | 1;
    *(_QWORD *)v16 = v20;
    *(_QWORD *)v10 = v16;
  }
  else
  {
    v15 = 0;
  }
  v14 = 1;
LABEL_28:
  if (v24 != &v25[2])
    free(v24);
  if (v14)
  {
    *(_QWORD *)(a1 + 920) = v15;
  }
  else if (v15)
  {
    v26 = 0;
    v22 = sub_1C627E01C(a1 + 944, v15, &v26);
    v23 = 0;
    if (v22)
      v23 = *((_QWORD *)v26 + 1);
    if (v23)
      v15 = v23;
    if (v15 == *(_QWORD *)(a1 + 928))
      *(_BYTE *)(a1 + 936) = 1;
  }
  return v15;
}

uint64_t sub_1C5E0B790(uint64_t a1)
{
  unsigned __int8 *v2;
  unsigned __int8 *v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  unsigned __int8 *v7;
  unsigned __int8 *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  const void *v15;
  uint64_t *v16;
  uint64_t *v17;
  int64_t v18;
  uint64_t v19;
  int v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int *v24;
  BOOL v25;
  BOOL v26;
  int v27;
  unint64_t v28;
  unsigned int v29;
  int v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  unsigned int *v34;
  void *v35;
  uint64_t v36;
  _BYTE v37[128];
  void *v38;
  uint64_t v39;
  _QWORD v40[17];

  v40[16] = *MEMORY[0x1E0C80C00];
  v3 = *(unsigned __int8 **)a1;
  v2 = *(unsigned __int8 **)(a1 + 8);
  if (v2 == *(unsigned __int8 **)a1)
    return sub_1C5DF9EB0(a1);
  v4 = (char)*v3;
  if (v4 == 74)
  {
    v9 = v3 + 1;
    *(_QWORD *)a1 = v9;
    v10 = (uint64_t)(*(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16)) >> 3;
    while (v9 == v2 || *v9 != 69)
    {
      v11 = sub_1C5E0B790(a1);
      if (!v11)
        return 0;
      v12 = v11;
      v13 = *(uint64_t **)(a1 + 24);
      if (v13 == *(uint64_t **)(a1 + 32))
      {
        sub_1C625449C(a1 + 16, ((uint64_t)v13 - *(_QWORD *)(a1 + 16)) >> 2);
        v13 = *(uint64_t **)(a1 + 24);
      }
      *(_QWORD *)(a1 + 24) = v13 + 1;
      *v13 = v12;
      v9 = *(unsigned __int8 **)a1;
      v2 = *(unsigned __int8 **)(a1 + 8);
    }
    *(_QWORD *)a1 = v9 + 1;
    v14 = *(_QWORD *)(a1 + 24);
    v15 = (const void *)(*(_QWORD *)(a1 + 16) + 8 * v10);
    v16 = (uint64_t *)sub_1C484358C(a1 + 808, v14 - (_QWORD)v15, 3);
    v17 = v16;
    v18 = v14 - (_QWORD)v15;
    if (v18)
      memmove(v16, v15, v18);
    v19 = v18 >> 3;
    *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 16) + 8 * v10;
    v20 = *(unsigned __int8 *)(a1 + 937);
    v35 = v37;
    v36 = 0x2000000000;
    sub_1C5E0169C(&v35, 37, v17, v18 >> 3);
    v21 = sub_1C4F5AB38(v35, (uint64_t)v35 + 4 * v36);
    v23 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v21);
    v24 = *(unsigned int **)v23;
    v38 = v40;
    v39 = 0x2000000000;
    if (v24)
      v25 = (v24 & 1) == 0;
    else
      v25 = 0;
    if (!v25)
      goto LABEL_42;
    while (1)
    {
      LOBYTE(v21) = sub_1C5DFE6F4(v21, v24, (uint64_t)&v35, v22, (unsigned int *)&v38);
      if ((v21 & 1) != 0)
        break;
      LODWORD(v39) = 0;
      v24 = *(unsigned int **)v24;
      if (v24)
        v26 = (v24 & 1) == 0;
      else
        v26 = 0;
      if (!v26)
      {
        v24 = 0;
        goto LABEL_38;
      }
    }
    v23 = 0;
LABEL_38:
    if (v38 == v40)
    {
      if (v24)
      {
LABEL_40:
        v27 = 0;
        v6 = (uint64_t)(v24 + 2);
LABEL_49:
        if (v35 != v37)
          free(v35);
        if (v27)
        {
          *(_QWORD *)(a1 + 920) = v6;
        }
        else if (v6)
        {
          v38 = 0;
          v32 = sub_1C627E01C(a1 + 944, v6, &v38);
          v33 = 0;
          if (v32)
            v33 = *((_QWORD *)v38 + 1);
          if (v33)
            v6 = v33;
          if (v6 == *(_QWORD *)(a1 + 928))
            *(_BYTE *)(a1 + 936) = 1;
        }
        return v6;
      }
    }
    else
    {
      free(v38);
      if (v24)
        goto LABEL_40;
    }
LABEL_42:
    if (v20)
    {
      v28 = sub_1C484358C(a1 + 808, 40, 3);
      *(_QWORD *)v28 = 0;
      *(_QWORD *)(v28 + 8) = &unk_1E816C028;
      v6 = v28 + 8;
      *(_BYTE *)(v28 + 16) = 37;
      *(_WORD *)(v28 + 17) = *(_WORD *)(v28 + 17) & 0xF000 | 0x540;
      *(_QWORD *)(v28 + 24) = v17;
      *(_QWORD *)(v28 + 32) = v19;
      v29 = *(_DWORD *)(a1 + 916) + 1;
      v30 = *(_DWORD *)(a1 + 912);
      if (v29 > 2 * v30)
      {
        v34 = (unsigned int *)v28;
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v30, (uint64_t)off_1E81A1260);
        v38 = v40;
        v39 = 0x2000000000;
        sub_1C5DFE788(v34, (unsigned int *)&v38);
        v23 = *(_QWORD *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v38, (uint64_t)v38 + 4 * v39));
        if (v38 != v40)
          free(v38);
        v29 = *(_DWORD *)(a1 + 916) + 1;
        v28 = (unint64_t)v34;
      }
      *(_DWORD *)(a1 + 916) = v29;
      v31 = *(_QWORD *)v23;
      if (!*(_QWORD *)v23)
        v31 = v23 | 1;
      *(_QWORD *)v28 = v31;
      *(_QWORD *)v23 = v28;
    }
    else
    {
      v6 = 0;
    }
    v27 = 1;
    goto LABEL_49;
  }
  if (v4 != 76)
  {
    if (v4 == 88)
    {
      *(_QWORD *)a1 = v3 + 1;
      v5 = sub_1C5E042EC(a1);
      goto LABEL_6;
    }
    return sub_1C5DF9EB0(a1);
  }
  if ((unint64_t)&v2[-*(_QWORD *)a1] >= 2 && v3[1] == 90)
  {
    *(_QWORD *)a1 = v3 + 2;
    v5 = sub_1C5DFC50C((unsigned __int8 **)a1);
LABEL_6:
    v6 = v5;
    if (v5)
    {
      v7 = *(unsigned __int8 **)a1;
      if (*(_QWORD *)a1 == *(_QWORD *)(a1 + 8) || *v7 != 69)
        return 0;
      else
        *(_QWORD *)a1 = v7 + 1;
    }
    return v6;
  }
  return sub_1C5E09F20(a1);
}

uint64_t sub_1C5E0BC2C(uint64_t a1)
{
  uint64_t v2;
  unsigned __int8 *v3;
  unint64_t v4;
  int v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int *v10;
  BOOL v11;
  BOOL v12;
  int v13;
  unint64_t v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  unsigned int *v20;
  __int128 v21;
  unint64_t v22;
  void *v23;
  unsigned int v24[34];
  void *v25;
  uint64_t v26;
  _QWORD v27[17];

  v27[16] = *MEMORY[0x1E0C80C00];
  v22 = 0;
  v2 = 0;
  if ((sub_1C54C42B4((unsigned __int8 **)a1, (uint64_t *)&v22) & 1) != 0)
    return v2;
  v3 = *(unsigned __int8 **)a1;
  v4 = v22;
  if (v22 - 1 >= *(_QWORD *)(a1 + 8) - *(_QWORD *)a1)
    return 0;
  *(_QWORD *)&v21 = *(_QWORD *)a1;
  *((_QWORD *)&v21 + 1) = &v3[v22];
  *(_QWORD *)a1 = &v3[v22];
  if (v4 < 0xA || strncmp("_GLOBAL__N", (const char *)v3, 0xAuLL))
    return sub_1C5E04030(a1, &v21);
  v6 = *(unsigned __int8 *)(a1 + 937);
  v23 = &v24[2];
  *(_OWORD *)v24 = xmmword_1C866F960;
  llvm::FoldingSetNodeID::AddString((unsigned int *)&v23, "(anonymous namespace)", 0x15u);
  v7 = sub_1C4F5AB38(v23, (uint64_t)v23 + 4 * v24[0]);
  v9 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v7);
  v10 = *(unsigned int **)v9;
  v25 = v27;
  v26 = 0x2000000000;
  if (v10)
    v11 = (v10 & 1) == 0;
  else
    v11 = 0;
  if (!v11)
    goto LABEL_24;
  while (1)
  {
    LOBYTE(v7) = sub_1C5DFE6F4(v7, v10, (uint64_t)&v23, v8, (unsigned int *)&v25);
    if ((v7 & 1) != 0)
      break;
    LODWORD(v26) = 0;
    v10 = *(unsigned int **)v10;
    if (v10)
      v12 = (v10 & 1) == 0;
    else
      v12 = 0;
    if (!v12)
    {
      v10 = 0;
      goto LABEL_20;
    }
  }
  v9 = 0;
LABEL_20:
  if (v25 != v27)
  {
    free(v25);
    if (v10)
      goto LABEL_22;
LABEL_24:
    if (v6)
    {
      v14 = sub_1C484358C(a1 + 808, 40, 3);
      *(_QWORD *)v14 = 0;
      *(_QWORD *)(v14 + 8) = &unk_1E816A8B0;
      v2 = v14 + 8;
      *(_BYTE *)(v14 + 16) = 7;
      *(_WORD *)(v14 + 17) = *(_WORD *)(v14 + 17) & 0xF000 | 0x540;
      *(_QWORD *)(v14 + 24) = "(anonymous namespace)";
      *(_QWORD *)(v14 + 32) = "";
      v15 = *(_DWORD *)(a1 + 916) + 1;
      v16 = *(_DWORD *)(a1 + 912);
      if (v15 > 2 * v16)
      {
        v20 = (unsigned int *)v14;
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v16, (uint64_t)off_1E81A1260);
        v25 = v27;
        v26 = 0x2000000000;
        sub_1C5DFE788(v20, (unsigned int *)&v25);
        v9 = *(_QWORD *)(a1 + 904)
           + 8
           * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v25, (uint64_t)v25 + 4 * v26));
        if (v25 != v27)
          free(v25);
        v15 = *(_DWORD *)(a1 + 916) + 1;
        v14 = (unint64_t)v20;
      }
      *(_DWORD *)(a1 + 916) = v15;
      v17 = *(_QWORD *)v9;
      if (!*(_QWORD *)v9)
        v17 = v9 | 1;
      *(_QWORD *)v14 = v17;
      *(_QWORD *)v9 = v14;
    }
    else
    {
      v2 = 0;
    }
    v13 = 1;
    goto LABEL_31;
  }
  if (!v10)
    goto LABEL_24;
LABEL_22:
  v13 = 0;
  v2 = (uint64_t)(v10 + 2);
LABEL_31:
  if (v23 != &v24[2])
    free(v23);
  if (v13)
  {
    *(_QWORD *)(a1 + 920) = v2;
  }
  else if (v2)
  {
    v25 = 0;
    v18 = sub_1C627E01C(a1 + 944, v2, &v25);
    v19 = 0;
    if (v18)
      v19 = *((_QWORD *)v25 + 1);
    if (v19)
      v2 = v19;
    if (v2 == *(_QWORD *)(a1 + 928))
      *(_BYTE *)(a1 + 936) = 1;
  }
  return v2;
}

uint64_t sub_1C5E0BF60(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  char *v6;
  char *v7;
  char *v8;
  unsigned __int8 *v9;
  char *v10;
  int v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  BOOL v16;
  BOOL v17;
  uint64_t v18;
  int v20;
  unint64_t v21;
  unsigned int v22;
  int v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  unsigned int *v27;
  void *v28;
  unsigned int v29[34];
  void *v30;
  uint64_t v31;
  _QWORD v32[18];

  v32[16] = *MEMORY[0x1E0C80C00];
  v6 = sub_1C54C21F4((char **)a1, 1);
  if (v6 == v7)
    return 0;
  v8 = *(char **)a1;
  if (*(_QWORD *)a1 == *(_QWORD *)(a1 + 8) || *v8 != 69)
    return 0;
  v9 = (unsigned __int8 *)v6;
  v10 = v7;
  *(_QWORD *)a1 = v8 + 1;
  v11 = *(unsigned __int8 *)(a1 + 937);
  v28 = &v29[2];
  *(_OWORD *)v29 = xmmword_1C866FBC0;
  llvm::FoldingSetNodeID::AddString((unsigned int *)&v28, a2, a3 - (_DWORD)a2);
  llvm::FoldingSetNodeID::AddString((unsigned int *)&v28, v9, (_DWORD)v10 - (_DWORD)v9);
  v12 = sub_1C4F5AB38(v28, (uint64_t)v28 + 4 * v29[0]);
  v14 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v12);
  v15 = *(unsigned int **)v14;
  v30 = v32;
  v31 = 0x2000000000;
  if (v15)
    v16 = (v15 & 1) == 0;
  else
    v16 = 0;
  if (!v16)
    goto LABEL_22;
  while (1)
  {
    LOBYTE(v12) = sub_1C5DFE6F4(v12, v15, (uint64_t)&v28, v13, (unsigned int *)&v30);
    if ((v12 & 1) != 0)
      break;
    LODWORD(v31) = 0;
    v15 = *(unsigned int **)v15;
    if (v15)
      v17 = (v15 & 1) == 0;
    else
      v17 = 0;
    if (!v17)
    {
      v15 = 0;
      goto LABEL_18;
    }
  }
  v14 = 0;
LABEL_18:
  if (v30 != v32)
  {
    free(v30);
    if (v15)
      goto LABEL_20;
LABEL_22:
    if (v11)
    {
      v21 = sub_1C484358C(a1 + 808, 56, 3);
      *(_QWORD *)v21 = 0;
      *(_QWORD *)(v21 + 8) = &unk_1E816B1B8;
      v18 = v21 + 8;
      *(_BYTE *)(v21 + 16) = 73;
      *(_WORD *)(v21 + 17) = *(_WORD *)(v21 + 17) & 0xF000 | 0x540;
      *(_QWORD *)(v21 + 24) = a2;
      *(_QWORD *)(v21 + 32) = a3;
      *(_QWORD *)(v21 + 40) = v9;
      *(_QWORD *)(v21 + 48) = v10;
      v22 = *(_DWORD *)(a1 + 916) + 1;
      v23 = *(_DWORD *)(a1 + 912);
      if (v22 > 2 * v23)
      {
        v27 = (unsigned int *)v21;
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v23, (uint64_t)off_1E81A1260);
        v30 = v32;
        v31 = 0x2000000000;
        sub_1C5DFE788(v27, (unsigned int *)&v30);
        v14 = *(_QWORD *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v30, (uint64_t)v30 + 4 * v31));
        if (v30 != v32)
          free(v30);
        v22 = *(_DWORD *)(a1 + 916) + 1;
        v21 = (unint64_t)v27;
      }
      *(_DWORD *)(a1 + 916) = v22;
      v24 = *(_QWORD *)v14;
      if (!*(_QWORD *)v14)
        v24 = v14 | 1;
      *(_QWORD *)v21 = v24;
      *(_QWORD *)v14 = v21;
    }
    else
    {
      v18 = 0;
    }
    v20 = 1;
    goto LABEL_29;
  }
  if (!v15)
    goto LABEL_22;
LABEL_20:
  v20 = 0;
  v18 = (uint64_t)(v15 + 2);
LABEL_29:
  if (v28 != &v29[2])
    free(v28);
  if (v20)
  {
    *(_QWORD *)(a1 + 920) = v18;
  }
  else if (v18)
  {
    v30 = 0;
    v25 = sub_1C627E01C(a1 + 944, v18, &v30);
    v26 = 0;
    if (v25)
      v26 = *((_QWORD *)v30 + 1);
    if (v26)
      v18 = v26;
    if (v18 == *(_QWORD *)(a1 + 928))
      *(_BYTE *)(a1 + 936) = 1;
  }
  return v18;
}

uint64_t sub_1C5E0C27C(uint64_t a1, _DWORD *a2)
{
  int v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  BOOL v9;
  BOOL v10;
  int v11;
  uint64_t v12;
  unint64_t v13;
  BOOL v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  int v19;
  uint64_t v20;
  void *v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  _QWORD v27[17];

  v27[16] = *MEMORY[0x1E0C80C00];
  v4 = *(unsigned __int8 *)(a1 + 937);
  v21 = (char *)&v22 + 8;
  LODWORD(v23) = *a2;
  v23 = (int)v23;
  v22 = xmmword_1C866FBD0;
  v5 = sub_1C4F5AB38((_QWORD *)&v22 + 1, (uint64_t)&v24);
  v7 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v5);
  v8 = *(unsigned int **)v7;
  v25 = v27;
  v26 = 0x2000000000;
  if (v8)
    v9 = (v8 & 1) == 0;
  else
    v9 = 0;
  if (!v9)
    goto LABEL_17;
  while (1)
  {
    LOBYTE(v5) = sub_1C5DFE6F4(v5, v8, (uint64_t)&v21, v6, (unsigned int *)&v25);
    if ((v5 & 1) != 0)
      break;
    LODWORD(v26) = 0;
    v8 = *(unsigned int **)v8;
    if (v8)
      v10 = (v8 & 1) == 0;
    else
      v10 = 0;
    if (!v10)
    {
      v8 = 0;
      goto LABEL_13;
    }
  }
  v7 = 0;
LABEL_13:
  if (v25 == v27)
  {
    if (v8)
    {
LABEL_15:
      v11 = 0;
      v12 = (uint64_t)(v8 + 2);
      goto LABEL_24;
    }
  }
  else
  {
    free(v25);
    if (v8)
      goto LABEL_15;
  }
LABEL_17:
  if (v4)
  {
    v13 = sub_1C484358C(a1 + 808, 24, 3);
    *(_QWORD *)v13 = 0;
    *(_QWORD *)(v13 + 8) = &unk_1E816B210;
    v12 = v13 + 8;
    v14 = *a2 != 0;
    *(_BYTE *)(v13 + 16) = 69;
    *(_WORD *)(v13 + 17) = *(_WORD *)(v13 + 17) & 0xF000 | 0x540;
    *(_BYTE *)(v13 + 19) = v14;
    v15 = *(_DWORD *)(a1 + 916) + 1;
    v16 = *(_DWORD *)(a1 + 912);
    if (v15 > 2 * v16)
    {
      llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v16, (uint64_t)off_1E81A1260);
      v25 = v27;
      v26 = 0x2000000000;
      sub_1C5DFE788((unsigned int *)v13, (unsigned int *)&v25);
      v7 = *(_QWORD *)(a1 + 904)
         + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v25, (uint64_t)v25 + 4 * v26));
      if (v25 != v27)
        free(v25);
      v15 = *(_DWORD *)(a1 + 916) + 1;
    }
    *(_DWORD *)(a1 + 916) = v15;
    v17 = *(_QWORD *)v7;
    if (!*(_QWORD *)v7)
      v17 = v7 | 1;
    *(_QWORD *)v13 = v17;
    *(_QWORD *)v7 = v13;
  }
  else
  {
    v12 = 0;
  }
  v11 = 1;
LABEL_24:
  if (v21 != (char *)&v22 + 8)
    free(v21);
  if (v11)
  {
    *(_QWORD *)(a1 + 920) = v12;
  }
  else if (v12)
  {
    v25 = 0;
    v19 = sub_1C627E01C(a1 + 944, v12, &v25);
    v20 = 0;
    if (v19)
      v20 = *((_QWORD *)v25 + 1);
    if (v20)
      v12 = v20;
    if (v12 == *(_QWORD *)(a1 + 928))
      *(_BYTE *)(a1 + 936) = 1;
  }
  return v12;
}

uint64_t sub_1C5E0C534(uint64_t a1, uint64_t a2)
{
  const char *v3;
  uint64_t v4;
  char *v6;
  int v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int *v11;
  BOOL v12;
  unsigned __int8 *v13;
  uint64_t v14;
  char *v15;
  unsigned __int8 *v16;
  uint64_t v17;
  int v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int *v22;
  BOOL v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  char v30;
  _BYTE *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  _BYTE *v36;
  uint64_t v37;
  _BYTE *v38;
  uint64_t v39;
  uint64_t *v40;
  uint64_t *v41;
  uint64_t v42;
  _BYTE *v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t *v47;
  char *v48;
  int v49;
  char *v50;
  _BYTE *v51;
  uint64_t *v52;
  uint64_t *v53;
  uint64_t v54;
  unsigned __int8 *v55;
  uint64_t v56;
  char *v57;
  unsigned __int8 *v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unsigned int *v63;
  BOOL v64;
  BOOL v65;
  int v66;
  int v67;
  unint64_t v68;
  unsigned int v69;
  int v70;
  uint64_t v71;
  unint64_t v72;
  unsigned int v73;
  int v74;
  uint64_t v75;
  int v76;
  uint64_t v77;
  unint64_t v78;
  unsigned int v79;
  int v80;
  uint64_t v81;
  int v82;
  uint64_t v83;
  unsigned int *v84;
  uint64_t v85;
  int v86;
  _QWORD v87[2];
  void *v88;
  uint64_t v89;
  void *v90;
  unsigned int v91[34];
  _QWORD *v92;
  uint64_t v93;
  _QWORD v94[18];

  v94[16] = *MEMORY[0x1E0C80C00];
  if (a2)
    *(_QWORD *)(a1 + 672) = *(_QWORD *)(a1 + 664);
  v3 = *(const char **)a1;
  if (*(_QWORD *)(a1 + 8) - *(_QWORD *)a1 < 2uLL)
    return 0;
  if (!strncmp("Ut", *(const char **)a1, 2uLL))
  {
    *(_QWORD *)a1 = v3 + 2;
    v13 = (unsigned __int8 *)sub_1C54C21F4((char **)a1, 0);
    v15 = *(char **)a1;
    if (*(_QWORD *)a1 == *(_QWORD *)(a1 + 8) || *v15 != 95)
      return 0;
    v16 = v13;
    v17 = v14;
    *(_QWORD *)a1 = v15 + 1;
    v18 = *(unsigned __int8 *)(a1 + 937);
    v90 = &v91[2];
    *(_OWORD *)v91 = xmmword_1C866FBE0;
    llvm::FoldingSetNodeID::AddString((unsigned int *)&v90, v13, v14 - (_DWORD)v13);
    v19 = sub_1C4F5AB38(v90, (uint64_t)v90 + 4 * v91[0]);
    v21 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v19);
    v22 = *(unsigned int **)v21;
    v92 = v94;
    v93 = 0x2000000000;
    if (v22)
      v23 = (v22 & 1) == 0;
    else
      v23 = 0;
    if (!v23)
      goto LABEL_92;
    while (1)
    {
      LOBYTE(v19) = sub_1C5DFE6F4(v19, v22, (uint64_t)&v90, v20, (unsigned int *)&v92);
      if ((v19 & 1) != 0)
        break;
      LODWORD(v93) = 0;
      v22 = *(unsigned int **)v22;
      if (v22)
        v24 = (v22 & 1) == 0;
      else
        v24 = 0;
      if (!v24)
      {
        v22 = 0;
        goto LABEL_59;
      }
    }
    v21 = 0;
LABEL_59:
    if (v92 == v94)
    {
      if (v22)
      {
LABEL_61:
        v49 = 0;
        v4 = (uint64_t)(v22 + 2);
        goto LABEL_99;
      }
    }
    else
    {
      free(v92);
      if (v22)
        goto LABEL_61;
    }
LABEL_92:
    if (v18)
    {
      v68 = sub_1C484358C(a1 + 808, 40, 3);
      *(_QWORD *)v68 = 0;
      *(_QWORD *)(v68 + 8) = &unk_1E816B3C8;
      v4 = v68 + 8;
      *(_BYTE *)(v68 + 16) = 47;
      *(_WORD *)(v68 + 17) = *(_WORD *)(v68 + 17) & 0xF000 | 0x540;
      *(_QWORD *)(v68 + 24) = v16;
      *(_QWORD *)(v68 + 32) = v17;
      v69 = *(_DWORD *)(a1 + 916) + 1;
      v70 = *(_DWORD *)(a1 + 912);
      if (v69 > 2 * v70)
      {
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v70, (uint64_t)off_1E81A1260);
        v92 = v94;
        v93 = 0x2000000000;
        sub_1C5DFE788((unsigned int *)v68, (unsigned int *)&v92);
        v21 = *(_QWORD *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v92, (uint64_t)v92 + 4 * v93));
        if (v92 != v94)
          free(v92);
        v69 = *(_DWORD *)(a1 + 916) + 1;
      }
      *(_DWORD *)(a1 + 916) = v69;
      v71 = *(_QWORD *)v21;
      if (!*(_QWORD *)v21)
        v71 = v21 | 1;
      *(_QWORD *)v68 = v71;
      *(_QWORD *)v21 = v68;
    }
    else
    {
      v4 = 0;
    }
    v49 = 1;
LABEL_99:
    if (v90 != &v91[2])
      free(v90);
    if (!v49)
      goto LABEL_117;
    goto LABEL_102;
  }
  if (strncmp("Ul", v3, 2uLL))
  {
    if (!strncmp("Ub", v3, 2uLL))
    {
      *(_QWORD *)a1 = v3 + 2;
      sub_1C54C21F4((char **)a1, 0);
      v6 = *(char **)a1;
      if (*(_QWORD *)a1 != *(_QWORD *)(a1 + 8) && *v6 == 95)
      {
        *(_QWORD *)a1 = v6 + 1;
        v7 = *(unsigned __int8 *)(a1 + 937);
        v90 = &v91[2];
        *(_OWORD *)v91 = xmmword_1C866F960;
        llvm::FoldingSetNodeID::AddString((unsigned int *)&v90, "'block-literal'", 0xFu);
        v8 = sub_1C4F5AB38(v90, (uint64_t)v90 + 4 * v91[0]);
        v10 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v8);
        v11 = *(unsigned int **)v10;
        v92 = v94;
        v93 = 0x2000000000;
        if (v11 && (v11 & 1) == 0)
        {
          while (1)
          {
            LOBYTE(v8) = sub_1C5DFE6F4(v8, v11, (uint64_t)&v90, v9, (unsigned int *)&v92);
            if ((v8 & 1) != 0)
              break;
            LODWORD(v93) = 0;
            v11 = *(unsigned int **)v11;
            if (v11)
              v12 = (v11 & 1) == 0;
            else
              v12 = 0;
            if (!v12)
            {
              v11 = 0;
              goto LABEL_84;
            }
          }
          v10 = 0;
LABEL_84:
          if (v92 == v94)
          {
            if (v11)
            {
LABEL_86:
              v66 = 0;
              v4 = (uint64_t)(v11 + 2);
              goto LABEL_114;
            }
          }
          else
          {
            free(v92);
            if (v11)
              goto LABEL_86;
          }
        }
        if (v7)
        {
          v72 = sub_1C484358C(a1 + 808, 40, 3);
          *(_QWORD *)v72 = 0;
          *(_QWORD *)(v72 + 8) = &unk_1E816A8B0;
          v4 = v72 + 8;
          *(_BYTE *)(v72 + 16) = 7;
          *(_WORD *)(v72 + 17) = *(_WORD *)(v72 + 17) & 0xF000 | 0x540;
          *(_QWORD *)(v72 + 24) = "'block-literal'";
          *(_QWORD *)(v72 + 32) = "";
          v73 = *(_DWORD *)(a1 + 916) + 1;
          v74 = *(_DWORD *)(a1 + 912);
          if (v73 > 2 * v74)
          {
            llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v74, (uint64_t)off_1E81A1260);
            v92 = v94;
            v93 = 0x2000000000;
            sub_1C5DFE788((unsigned int *)v72, (unsigned int *)&v92);
            v10 = *(_QWORD *)(a1 + 904)
                + 8
                * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v92, (uint64_t)v92 + 4 * v93));
            if (v92 != v94)
              free(v92);
            v73 = *(_DWORD *)(a1 + 916) + 1;
          }
          *(_DWORD *)(a1 + 916) = v73;
          v75 = *(_QWORD *)v10;
          if (!*(_QWORD *)v10)
            v75 = v10 | 1;
          *(_QWORD *)v72 = v75;
          *(_QWORD *)v10 = v72;
        }
        else
        {
          v4 = 0;
        }
        v66 = 1;
LABEL_114:
        if (v90 != &v91[2])
          free(v90);
        if (!v66)
        {
LABEL_117:
          if (v4)
          {
            v92 = 0;
            v76 = sub_1C627E01C(a1 + 944, v4, &v92);
            v77 = 0;
            if (v76)
              v77 = v92[1];
            if (v77)
              v4 = v77;
            if (v4 == *(_QWORD *)(a1 + 928))
              *(_BYTE *)(a1 + 936) = 1;
          }
          return v4;
        }
LABEL_102:
        *(_QWORD *)(a1 + 920) = v4;
        return v4;
      }
    }
    return 0;
  }
  *(_QWORD *)a1 = v3 + 2;
  v25 = *(_QWORD *)(a1 + 784);
  *(_QWORD *)(a1 + 784) = (uint64_t)(*(_QWORD *)(a1 + 672) - *(_QWORD *)(a1 + 664)) >> 3;
  sub_1C54C7D98((uint64_t)v87, (_QWORD *)a1);
  v26 = *(_QWORD *)(a1 + 16);
  v27 = *(_QWORD *)(a1 + 24);
  v28 = *(char **)a1;
  v29 = *(_QWORD *)(a1 + 8);
  if (v29 == *(_QWORD *)a1)
  {
    v36 = *(_BYTE **)(a1 + 24);
    v35 = *(_QWORD *)(a1 + 16);
  }
  else
  {
    do
    {
      if (*v28 != 84)
        break;
      v30 = (unint64_t)(v29 - (_QWORD)v28) < 2 ? 0 : v28[1];
      v31 = memchr("yptn", v30, 4uLL);
      if (!v31 || v31 - "yptn" == -1)
        break;
      v32 = sub_1C5E0CFCC(a1);
      if (!v32)
        goto LABEL_79;
      v33 = v32;
      v34 = *(uint64_t **)(a1 + 24);
      if (v34 == *(uint64_t **)(a1 + 32))
      {
        sub_1C625449C(a1 + 16, ((uint64_t)v34 - *(_QWORD *)(a1 + 16)) >> 2);
        v34 = *(uint64_t **)(a1 + 24);
      }
      *(_QWORD *)(a1 + 24) = v34 + 1;
      *v34 = v33;
      v28 = *(char **)a1;
      v29 = *(_QWORD *)(a1 + 8);
    }
    while (v29 != *(_QWORD *)a1);
    v35 = *(_QWORD *)(a1 + 16);
    v36 = *(_BYTE **)(a1 + 24);
  }
  v37 = (v27 - v26) >> 3;
  v38 = (_BYTE *)(v35 + 8 * v37);
  v39 = v36 - v38;
  v40 = (uint64_t *)sub_1C484358C(a1 + 808, v36 - v38, 3);
  v41 = v40;
  if (v36 == v38)
  {
    v42 = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 672) -= 8;
  }
  else
  {
    memmove(v40, v38, v36 - v38);
    v42 = *(_QWORD *)(a1 + 16);
  }
  v43 = (_BYTE *)(v42 + 8 * v37);
  *(_QWORD *)(a1 + 24) = v43;
  v44 = *(char **)a1;
  if (*(_QWORD *)(a1 + 8) - *(_QWORD *)a1 > 1uLL && !strncmp("vE", *(const char **)a1, 2uLL))
  {
    v50 = v44 + 2;
  }
  else
  {
    v45 = sub_1C5DF9EB0(a1);
    if (!v45)
      goto LABEL_79;
    v46 = v45;
    while (1)
    {
      v47 = *(uint64_t **)(a1 + 24);
      if (v47 == *(uint64_t **)(a1 + 32))
      {
        sub_1C625449C(a1 + 16, ((uint64_t)v47 - *(_QWORD *)(a1 + 16)) >> 2);
        v47 = *(uint64_t **)(a1 + 24);
      }
      *(_QWORD *)(a1 + 24) = v47 + 1;
      *v47 = v46;
      v48 = *(char **)a1;
      if (*(_QWORD *)a1 != *(_QWORD *)(a1 + 8) && *v48 == 69)
        break;
      v46 = sub_1C5DF9EB0(a1);
      if (!v46)
        goto LABEL_79;
    }
    v50 = v48 + 1;
    v42 = *(_QWORD *)(a1 + 16);
    v43 = *(_BYTE **)(a1 + 24);
  }
  *(_QWORD *)a1 = v50;
  v51 = (_BYTE *)(v42 + 8 * v37);
  v52 = (uint64_t *)sub_1C484358C(a1 + 808, v43 - v51, 3);
  v53 = v52;
  v54 = v43 - v51;
  if (v43 != v51)
    memmove(v52, v51, v43 - v51);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 16) + 8 * v37;
  v55 = (unsigned __int8 *)sub_1C54C21F4((char **)a1, 0);
  v57 = *(char **)a1;
  if (*(_QWORD *)a1 != *(_QWORD *)(a1 + 8) && *v57 == 95)
  {
    v58 = v55;
    v59 = v56;
    *(_QWORD *)a1 = v57 + 1;
    v86 = *(unsigned __int8 *)(a1 + 937);
    v90 = &v91[2];
    *(_QWORD *)v91 = 0x2000000000;
    v85 = v39 >> 3;
    sub_1C5E01A94((unsigned int *)&v90, v41, v39 >> 3, v53, v54 >> 3, v55, v56);
    v60 = sub_1C4F5AB38(v90, (uint64_t)v90 + 4 * v91[0]);
    v62 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v60);
    v63 = *(unsigned int **)v62;
    v92 = v94;
    v93 = 0x2000000000;
    if (v63)
      v64 = (v63 & 1) == 0;
    else
      v64 = 0;
    if (!v64)
      goto LABEL_128;
    while (1)
    {
      LOBYTE(v60) = sub_1C5DFE6F4(v60, v63, (uint64_t)&v90, v61, (unsigned int *)&v92);
      if ((v60 & 1) != 0)
        break;
      LODWORD(v93) = 0;
      v63 = *(unsigned int **)v63;
      if (v63)
        v65 = (v63 & 1) == 0;
      else
        v65 = 0;
      if (!v65)
      {
        v63 = 0;
        goto LABEL_88;
      }
    }
    v62 = 0;
LABEL_88:
    if (v92 == v94)
    {
      if (v63)
      {
LABEL_90:
        v67 = 0;
        v4 = (uint64_t)(v63 + 2);
LABEL_135:
        if (v90 != &v91[2])
          free(v90);
        if (v67)
        {
          *(_QWORD *)(a1 + 920) = v4;
        }
        else if (v4)
        {
          v92 = 0;
          v82 = sub_1C627E01C(a1 + 944, v4, &v92);
          v83 = 0;
          if (v82)
            v83 = v92[1];
          if (v83)
            v4 = v83;
          if (v4 == *(_QWORD *)(a1 + 928))
            *(_BYTE *)(a1 + 936) = 1;
        }
        goto LABEL_80;
      }
    }
    else
    {
      free(v92);
      if (v63)
        goto LABEL_90;
    }
LABEL_128:
    if (v86)
    {
      v78 = sub_1C484358C(a1 + 808, 72, 3);
      *(_QWORD *)(v78 + 8) = &unk_1E816B5D8;
      v4 = v78 + 8;
      *(_QWORD *)v78 = 0;
      *(_BYTE *)(v78 + 16) = 48;
      *(_WORD *)(v78 + 17) = *(_WORD *)(v78 + 17) & 0xF000 | 0x540;
      *(_QWORD *)(v78 + 24) = v41;
      *(_QWORD *)(v78 + 32) = v85;
      *(_QWORD *)(v78 + 40) = v53;
      *(_QWORD *)(v78 + 48) = v54 >> 3;
      *(_QWORD *)(v78 + 56) = v58;
      *(_QWORD *)(v78 + 64) = v59;
      v79 = *(_DWORD *)(a1 + 916) + 1;
      v80 = *(_DWORD *)(a1 + 912);
      if (v79 > 2 * v80)
      {
        v84 = (unsigned int *)v78;
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v80, (uint64_t)off_1E81A1260);
        v92 = v94;
        v93 = 0x2000000000;
        sub_1C5DFE788(v84, (unsigned int *)&v92);
        v62 = *(_QWORD *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v92, (uint64_t)v92 + 4 * v93));
        if (v92 != v94)
          free(v92);
        v79 = *(_DWORD *)(a1 + 916) + 1;
        v78 = (unint64_t)v84;
      }
      *(_DWORD *)(a1 + 916) = v79;
      v81 = *(_QWORD *)v62;
      if (!*(_QWORD *)v62)
        v81 = v62 | 1;
      *(_QWORD *)v78 = v81;
      *(_QWORD *)v62 = v78;
    }
    else
    {
      v4 = 0;
    }
    v67 = 1;
    goto LABEL_135;
  }
LABEL_79:
  v4 = 0;
LABEL_80:
  *(_QWORD *)(v87[0] + 672) = *(_QWORD *)(v87[0] + 664) + 8 * v87[1];
  if (v88 != &v89)
    free(v88);
  *(_QWORD *)(a1 + 784) = v25;
  return v4;
}

uint64_t sub_1C5E0CFCC(uint64_t a1)
{
  const char *v1;
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  int v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int *v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int *v19;
  BOOL v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  BOOL v30;
  BOOL v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  int v39;
  unint64_t v40;
  unsigned int v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  const void *v45;
  uint64_t *v46;
  uint64_t *v47;
  int64_t v48;
  uint64_t v49;
  int v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unsigned int *v54;
  BOOL v55;
  BOOL v56;
  int v57;
  int v58;
  unint64_t v59;
  unsigned int v60;
  int v61;
  uint64_t v62;
  unsigned int *v63;
  unint64_t v64;
  unsigned int v65;
  int v66;
  uint64_t v67;
  int v68;
  uint64_t v69;
  unint64_t v70;
  unsigned int v71;
  int v72;
  uint64_t v73;
  int v74;
  uint64_t v75;
  unsigned int *v76;
  _QWORD v77[2];
  void *v78;
  uint64_t v79;
  void *v80;
  __int128 v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  void *v85;
  uint64_t v86;
  _QWORD v87[18];

  v87[16] = *MEMORY[0x1E0C80C00];
  v1 = *(const char **)a1;
  if (*(_QWORD *)(a1 + 8) - *(_QWORD *)a1 < 2uLL)
    return 0;
  if (!strncmp("Ty", v1, 2uLL))
  {
    *(_QWORD *)a1 = v1 + 2;
    v13 = sub_1C5E0DA60(a1, 0);
    if (!v13)
      return 0;
    v14 = v13;
    v15 = *(unsigned __int8 *)(a1 + 937);
    v80 = (char *)&v81 + 8;
    v82 = v13;
    v81 = xmmword_1C866FC10;
    v16 = sub_1C4F5AB38((_QWORD *)&v81 + 1, (uint64_t)&v83);
    v18 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v16);
    v19 = *(unsigned int **)v18;
    v85 = v87;
    v86 = 0x2000000000;
    if (v19)
      v20 = (v19 & 1) == 0;
    else
      v20 = 0;
    if (!v20)
      goto LABEL_85;
    while (1)
    {
      LOBYTE(v16) = sub_1C5DFE6F4(v16, v19, (uint64_t)&v80, v17, (unsigned int *)&v85);
      if ((v16 & 1) != 0)
        break;
      LODWORD(v86) = 0;
      v19 = *(unsigned int **)v19;
      if (v19)
        v21 = (v19 & 1) == 0;
      else
        v21 = 0;
      if (!v21)
      {
        v19 = 0;
        goto LABEL_51;
      }
    }
    v18 = 0;
LABEL_51:
    if (v85 == v87)
    {
      if (v19)
      {
LABEL_53:
        v39 = 0;
        v2 = (uint64_t)(v19 + 2);
        goto LABEL_92;
      }
    }
    else
    {
      free(v85);
      if (v19)
        goto LABEL_53;
    }
LABEL_85:
    if (v15)
    {
      v59 = sub_1C484358C(a1 + 808, 32, 3);
      *(_QWORD *)(v59 + 8) = &unk_1E816B478;
      v2 = v59 + 8;
      *(_QWORD *)v59 = 0;
      *(_BYTE *)(v59 + 16) = 32;
      *(_WORD *)(v59 + 17) = *(_WORD *)(v59 + 17) & 0xF000 | 0x500;
      *(_QWORD *)(v59 + 24) = v14;
      v60 = *(_DWORD *)(a1 + 916) + 1;
      v61 = *(_DWORD *)(a1 + 912);
      if (v60 > 2 * v61)
      {
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v61, (uint64_t)off_1E81A1260);
        v85 = v87;
        v86 = 0x2000000000;
        sub_1C5DFE788((unsigned int *)v59, (unsigned int *)&v85);
        v18 = *(_QWORD *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v85, (uint64_t)v85 + 4 * v86));
        if (v85 != v87)
          free(v85);
        v60 = *(_DWORD *)(a1 + 916) + 1;
      }
      *(_DWORD *)(a1 + 916) = v60;
      v62 = *(_QWORD *)v18;
      if (!*(_QWORD *)v18)
        v62 = v18 | 1;
      *(_QWORD *)v59 = v62;
      *(_QWORD *)v18 = v59;
    }
    else
    {
      v2 = 0;
    }
    v39 = 1;
LABEL_92:
    if (v80 != (char *)&v81 + 8)
      free(v80);
    if (!v39)
      goto LABEL_115;
    goto LABEL_95;
  }
  if (!strncmp("Tn", v1, 2uLL))
  {
    *(_QWORD *)a1 = v1 + 2;
    v22 = sub_1C5E0DA60(a1, 1u);
    if (v22)
    {
      v23 = v22;
      v24 = sub_1C5DF9EB0(a1);
      if (v24)
      {
        v25 = v24;
        v26 = *(unsigned __int8 *)(a1 + 937);
        v80 = (char *)&v81 + 8;
        v82 = v23;
        v83 = v24;
        v81 = xmmword_1C866FC00;
        v27 = sub_1C4F5AB38((_QWORD *)&v81 + 1, (uint64_t)&v84);
        v29 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v27);
        v11 = *(unsigned int **)v29;
        v85 = v87;
        v86 = 0x2000000000;
        if (v11)
          v30 = (v11 & 1) == 0;
        else
          v30 = 0;
        if (v30)
        {
          while (1)
          {
            LOBYTE(v27) = sub_1C5DFE6F4(v27, v11, (uint64_t)&v80, v28, (unsigned int *)&v85);
            if ((v27 & 1) != 0)
              break;
            LODWORD(v86) = 0;
            v11 = *(unsigned int **)v11;
            if (v11)
              v31 = (v11 & 1) == 0;
            else
              v31 = 0;
            if (!v31)
            {
              v11 = 0;
              goto LABEL_56;
            }
          }
          v29 = 0;
LABEL_56:
          if (v85 == v87)
          {
            if (v11)
            {
LABEL_79:
              v57 = 0;
              v2 = (uint64_t)(v11 + 2);
              goto LABEL_112;
            }
          }
          else
          {
            free(v85);
            if (v11)
              goto LABEL_79;
          }
        }
        if (v26)
        {
          v40 = sub_1C484358C(a1 + 808, 40, 3);
          *(_QWORD *)v40 = 0;
          *(_QWORD *)(v40 + 8) = &unk_1E816B4D0;
          v2 = v40 + 8;
          *(_BYTE *)(v40 + 16) = 33;
          *(_WORD *)(v40 + 17) = *(_WORD *)(v40 + 17) & 0xF000 | 0x500;
          *(_QWORD *)(v40 + 24) = v23;
          *(_QWORD *)(v40 + 32) = v25;
          v41 = *(_DWORD *)(a1 + 916) + 1;
          v42 = *(_DWORD *)(a1 + 912);
          if (v41 > 2 * v42)
          {
            v63 = (unsigned int *)v40;
            llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v42, (uint64_t)off_1E81A1260);
            v85 = v87;
            v86 = 0x2000000000;
            sub_1C5DFE788(v63, (unsigned int *)&v85);
            v29 = *(_QWORD *)(a1 + 904)
                + 8
                * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v85, (uint64_t)v85 + 4 * v86));
            if (v85 != v87)
              free(v85);
            v41 = *(_DWORD *)(a1 + 916) + 1;
            v40 = (unint64_t)v63;
          }
          *(_DWORD *)(a1 + 916) = v41;
          v43 = *(_QWORD *)v29;
          if (!*(_QWORD *)v29)
            v43 = v29 | 1;
          *(_QWORD *)v40 = v43;
          *(_QWORD *)v29 = v40;
          goto LABEL_111;
        }
        goto LABEL_110;
      }
    }
    return 0;
  }
  if (strncmp("Tt", v1, 2uLL))
  {
    if (!strncmp("Tp", v1, 2uLL))
    {
      *(_QWORD *)a1 = v1 + 2;
      v5 = sub_1C5E0CFCC(a1);
      if (v5)
      {
        v6 = v5;
        v7 = *(unsigned __int8 *)(a1 + 937);
        v80 = (char *)&v81 + 8;
        v82 = v5;
        v81 = xmmword_1C866FBF0;
        v8 = sub_1C4F5AB38((_QWORD *)&v81 + 1, (uint64_t)&v83);
        v10 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v8);
        v11 = *(unsigned int **)v10;
        v85 = v87;
        v86 = 0x2000000000;
        if (v11 && (v11 & 1) == 0)
        {
          while (1)
          {
            LOBYTE(v8) = sub_1C5DFE6F4(v8, v11, (uint64_t)&v80, v9, (unsigned int *)&v85);
            if ((v8 & 1) != 0)
              break;
            LODWORD(v86) = 0;
            v11 = *(unsigned int **)v11;
            if (v11)
              v12 = (v11 & 1) == 0;
            else
              v12 = 0;
            if (!v12)
            {
              v11 = 0;
              goto LABEL_77;
            }
          }
          v10 = 0;
LABEL_77:
          if (v85 == v87)
          {
            if (v11)
              goto LABEL_79;
          }
          else
          {
            free(v85);
            if (v11)
              goto LABEL_79;
          }
        }
        if (v7)
        {
          v64 = sub_1C484358C(a1 + 808, 32, 3);
          *(_QWORD *)v64 = 0;
          *(_QWORD *)(v64 + 8) = &unk_1E816B580;
          v2 = v64 + 8;
          *(_BYTE *)(v64 + 16) = 35;
          *(_WORD *)(v64 + 17) = *(_WORD *)(v64 + 17) & 0xF000 | 0x500;
          *(_QWORD *)(v64 + 24) = v6;
          v65 = *(_DWORD *)(a1 + 916) + 1;
          v66 = *(_DWORD *)(a1 + 912);
          if (v65 > 2 * v66)
          {
            llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v66, (uint64_t)off_1E81A1260);
            v85 = v87;
            v86 = 0x2000000000;
            sub_1C5DFE788((unsigned int *)v64, (unsigned int *)&v85);
            v10 = *(_QWORD *)(a1 + 904)
                + 8
                * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v85, (uint64_t)v85 + 4 * v86));
            if (v85 != v87)
              free(v85);
            v65 = *(_DWORD *)(a1 + 916) + 1;
          }
          *(_DWORD *)(a1 + 916) = v65;
          v67 = *(_QWORD *)v10;
          if (!*(_QWORD *)v10)
            v67 = v10 | 1;
          *(_QWORD *)v64 = v67;
          *(_QWORD *)v10 = v64;
          goto LABEL_111;
        }
LABEL_110:
        v2 = 0;
LABEL_111:
        v57 = 1;
LABEL_112:
        if (v80 != (char *)&v81 + 8)
          free(v80);
        if (!v57)
        {
LABEL_115:
          if (v2)
          {
            v85 = 0;
            v68 = sub_1C627E01C(a1 + 944, v2, &v85);
            v69 = 0;
            if (v68)
              v69 = *((_QWORD *)v85 + 1);
            if (v69)
              v2 = v69;
            if (v2 == *(_QWORD *)(a1 + 928))
              *(_BYTE *)(a1 + 936) = 1;
          }
          return v2;
        }
LABEL_95:
        *(_QWORD *)(a1 + 920) = v2;
        return v2;
      }
    }
    return 0;
  }
  *(_QWORD *)a1 = v1 + 2;
  v32 = sub_1C5E0DA60(a1, 2u);
  if (!v32)
    return 0;
  v33 = v32;
  v34 = (uint64_t)(*(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16)) >> 3;
  sub_1C54C7D98((uint64_t)v77, (_QWORD *)a1);
  while (1)
  {
    v35 = *(const char **)a1;
    if (*(_QWORD *)(a1 + 8) != *(_QWORD *)a1 && *v35 == 69)
      break;
    v36 = sub_1C5E0CFCC(a1);
    if (!v36)
    {
      v2 = 0;
      goto LABEL_138;
    }
    v37 = v36;
    v38 = *(uint64_t **)(a1 + 24);
    if (v38 == *(uint64_t **)(a1 + 32))
    {
      sub_1C625449C(a1 + 16, ((uint64_t)v38 - *(_QWORD *)(a1 + 16)) >> 2);
      v38 = *(uint64_t **)(a1 + 24);
    }
    *(_QWORD *)(a1 + 24) = v38 + 1;
    *v38 = v37;
  }
  *(_QWORD *)a1 = v35 + 1;
  v44 = *(_QWORD *)(a1 + 24);
  v45 = (const void *)(*(_QWORD *)(a1 + 16) + 8 * v34);
  v46 = (uint64_t *)sub_1C484358C(a1 + 808, v44 - (_QWORD)v45, 3);
  v47 = v46;
  v48 = v44 - (_QWORD)v45;
  if (v48)
    memmove(v46, v45, v48);
  v49 = v48 >> 3;
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 16) + 8 * v34;
  v50 = *(unsigned __int8 *)(a1 + 937);
  v80 = (char *)&v81 + 8;
  *(_QWORD *)&v81 = 0x2000000000;
  sub_1C5E01858(&v80, 34, v33, v47, v48 >> 3);
  v51 = sub_1C4F5AB38(v80, (uint64_t)v80 + 4 * v81);
  v53 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v51);
  v54 = *(unsigned int **)v53;
  v85 = v87;
  v86 = 0x2000000000;
  if (v54)
    v55 = (v54 & 1) == 0;
  else
    v55 = 0;
  if (!v55)
    goto LABEL_126;
  while (1)
  {
    LOBYTE(v51) = sub_1C5DFE6F4(v51, v54, (uint64_t)&v80, v52, (unsigned int *)&v85);
    if ((v51 & 1) != 0)
      break;
    LODWORD(v86) = 0;
    v54 = *(unsigned int **)v54;
    if (v54)
      v56 = (v54 & 1) == 0;
    else
      v56 = 0;
    if (!v56)
    {
      v54 = 0;
      goto LABEL_81;
    }
  }
  v53 = 0;
LABEL_81:
  if (v85 == v87)
  {
    if (v54)
    {
LABEL_83:
      v58 = 0;
      v2 = (uint64_t)(v54 + 2);
      goto LABEL_133;
    }
  }
  else
  {
    free(v85);
    if (v54)
      goto LABEL_83;
  }
LABEL_126:
  if (v50)
  {
    v70 = sub_1C484358C(a1 + 808, 48, 3);
    *(_QWORD *)v70 = 0;
    *(_QWORD *)(v70 + 8) = &unk_1E816B528;
    v2 = v70 + 8;
    *(_BYTE *)(v70 + 16) = 34;
    *(_WORD *)(v70 + 17) = *(_WORD *)(v70 + 17) & 0xF000 | 0x500;
    *(_QWORD *)(v70 + 24) = v33;
    *(_QWORD *)(v70 + 32) = v47;
    *(_QWORD *)(v70 + 40) = v49;
    v71 = *(_DWORD *)(a1 + 916) + 1;
    v72 = *(_DWORD *)(a1 + 912);
    if (v71 > 2 * v72)
    {
      v76 = (unsigned int *)v70;
      llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v72, (uint64_t)off_1E81A1260);
      v85 = v87;
      v86 = 0x2000000000;
      sub_1C5DFE788(v76, (unsigned int *)&v85);
      v53 = *(_QWORD *)(a1 + 904)
          + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v85, (uint64_t)v85 + 4 * v86));
      if (v85 != v87)
        free(v85);
      v71 = *(_DWORD *)(a1 + 916) + 1;
      v70 = (unint64_t)v76;
    }
    *(_DWORD *)(a1 + 916) = v71;
    v73 = *(_QWORD *)v53;
    if (!*(_QWORD *)v53)
      v73 = v53 | 1;
    *(_QWORD *)v70 = v73;
    *(_QWORD *)v53 = v70;
  }
  else
  {
    v2 = 0;
  }
  v58 = 1;
LABEL_133:
  if (v80 != (char *)&v81 + 8)
    free(v80);
  if (v58)
  {
    *(_QWORD *)(a1 + 920) = v2;
  }
  else if (v2)
  {
    v85 = 0;
    v74 = sub_1C627E01C(a1 + 944, v2, &v85);
    v75 = 0;
    if (v74)
      v75 = *((_QWORD *)v85 + 1);
    if (v75)
      v2 = v75;
    if (v2 == *(_QWORD *)(a1 + 928))
      *(_BYTE *)(a1 + 936) = 1;
  }
LABEL_138:
  *(_QWORD *)(v77[0] + 672) = *(_QWORD *)(v77[0] + 664) + 8 * v77[1];
  if (v78 != &v79)
    free(v78);
  return v2;
}

uint64_t sub_1C5E0DA60(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  int v5;
  int v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int *v10;
  BOOL v11;
  BOOL v12;
  int v13;
  uint64_t v14;
  unint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t *v20;
  int v22;
  uint64_t v23;
  void *v24;
  __int128 v25;
  unsigned int v26;
  int v27;
  int v28;
  int v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  _QWORD v33[17];

  v33[16] = *MEMORY[0x1E0C80C00];
  v4 = a1 + 4 * a2;
  v5 = *(_DWORD *)(v4 + 792);
  *(_DWORD *)(v4 + 792) = v5 + 1;
  v6 = *(unsigned __int8 *)(a1 + 937);
  v24 = (char *)&v25 + 8;
  v26 = a2;
  v27 = 0;
  v28 = v5;
  v29 = 0;
  v25 = xmmword_1C866FC20;
  v7 = sub_1C4F5AB38((_QWORD *)&v25 + 1, (uint64_t)&v30);
  v9 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v7);
  v10 = *(unsigned int **)v9;
  v31 = v33;
  v32 = 0x2000000000;
  if (v10)
    v11 = (v10 & 1) == 0;
  else
    v11 = 0;
  if (!v11)
    goto LABEL_17;
  while (1)
  {
    LOBYTE(v7) = sub_1C5DFE6F4(v7, v10, (uint64_t)&v24, v8, (unsigned int *)&v31);
    if ((v7 & 1) != 0)
      break;
    LODWORD(v32) = 0;
    v10 = *(unsigned int **)v10;
    if (v10)
      v12 = (v10 & 1) == 0;
    else
      v12 = 0;
    if (!v12)
    {
      v10 = 0;
      goto LABEL_13;
    }
  }
  v9 = 0;
LABEL_13:
  if (v31 == v33)
  {
    if (v10)
    {
LABEL_15:
      v13 = 0;
      v14 = (uint64_t)(v10 + 2);
      goto LABEL_24;
    }
  }
  else
  {
    free(v31);
    if (v10)
      goto LABEL_15;
  }
LABEL_17:
  if (v6)
  {
    v15 = sub_1C484358C(a1 + 808, 32, 3);
    *(_QWORD *)v15 = 0;
    *(_QWORD *)(v15 + 8) = &unk_1E816B420;
    v14 = v15 + 8;
    *(_BYTE *)(v15 + 16) = 31;
    *(_WORD *)(v15 + 17) = *(_WORD *)(v15 + 17) & 0xF000 | 0x540;
    *(_DWORD *)(v15 + 20) = a2;
    *(_DWORD *)(v15 + 24) = v5;
    v16 = *(_DWORD *)(a1 + 916) + 1;
    v17 = *(_DWORD *)(a1 + 912);
    if (v16 > 2 * v17)
    {
      llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v17, (uint64_t)off_1E81A1260);
      v31 = v33;
      v32 = 0x2000000000;
      sub_1C5DFE788((unsigned int *)v15, (unsigned int *)&v31);
      v9 = *(_QWORD *)(a1 + 904)
         + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v31, (uint64_t)v31 + 4 * v32));
      if (v31 != v33)
        free(v31);
      v16 = *(_DWORD *)(a1 + 916) + 1;
    }
    *(_DWORD *)(a1 + 916) = v16;
    v18 = *(_QWORD *)v9;
    if (!*(_QWORD *)v9)
      v18 = v9 | 1;
    *(_QWORD *)v15 = v18;
    *(_QWORD *)v9 = v15;
  }
  else
  {
    v14 = 0;
  }
  v13 = 1;
LABEL_24:
  if (v24 != (char *)&v25 + 8)
    free(v24);
  if (v13)
  {
    *(_QWORD *)(a1 + 920) = v14;
  }
  else
  {
    if (!v14)
      return v14;
    v31 = 0;
    v22 = sub_1C627E01C(a1 + 944, v14, &v31);
    v23 = 0;
    if (v22)
      v23 = *((_QWORD *)v31 + 1);
    if (v23)
      v14 = v23;
    if (v14 == *(_QWORD *)(a1 + 928))
      *(_BYTE *)(a1 + 936) = 1;
  }
  if (v14)
  {
    v19 = *(_QWORD **)(*(_QWORD *)(a1 + 672) - 8);
    v20 = (uint64_t *)v19[1];
    if (v20 == (uint64_t *)v19[2])
    {
      sub_1C625449C((uint64_t)v19, ((uint64_t)v20 - *v19) >> 2);
      v20 = (uint64_t *)v19[1];
    }
    v19[1] = v20 + 1;
    *v20 = v14;
  }
  return v14;
}

uint64_t sub_1C5E0DD60(uint64_t a1, __int128 *a2)
{
  int v4;
  unsigned __int8 *v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int *v10;
  BOOL v11;
  BOOL v12;
  int v13;
  uint64_t v14;
  unint64_t v15;
  __int128 v16;
  unsigned int v17;
  int v18;
  uint64_t v19;
  int v21;
  uint64_t v22;
  void *v23;
  unsigned int v24[34];
  void *v25;
  uint64_t v26;
  _QWORD v27[17];

  v27[16] = *MEMORY[0x1E0C80C00];
  v4 = *(unsigned __int8 *)(a1 + 937);
  v23 = &v24[2];
  v5 = *(unsigned __int8 **)a2;
  v6 = *((_QWORD *)a2 + 1);
  *(_OWORD *)v24 = xmmword_1C866FC30;
  llvm::FoldingSetNodeID::AddString((unsigned int *)&v23, v5, v6 - (_DWORD)v5);
  v7 = sub_1C4F5AB38(v23, (uint64_t)v23 + 4 * v24[0]);
  v9 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v7);
  v10 = *(unsigned int **)v9;
  v25 = v27;
  v26 = 0x2000000000;
  if (v10)
    v11 = (v10 & 1) == 0;
  else
    v11 = 0;
  if (!v11)
    goto LABEL_17;
  while (1)
  {
    LOBYTE(v7) = sub_1C5DFE6F4(v7, v10, (uint64_t)&v23, v8, (unsigned int *)&v25);
    if ((v7 & 1) != 0)
      break;
    LODWORD(v26) = 0;
    v10 = *(unsigned int **)v10;
    if (v10)
      v12 = (v10 & 1) == 0;
    else
      v12 = 0;
    if (!v12)
    {
      v10 = 0;
      goto LABEL_13;
    }
  }
  v9 = 0;
LABEL_13:
  if (v25 == v27)
  {
    if (v10)
    {
LABEL_15:
      v13 = 0;
      v14 = (uint64_t)(v10 + 2);
      goto LABEL_24;
    }
  }
  else
  {
    free(v25);
    if (v10)
      goto LABEL_15;
  }
LABEL_17:
  if (v4)
  {
    v15 = sub_1C484358C(a1 + 808, 40, 3);
    *(_QWORD *)v15 = 0;
    *(_QWORD *)(v15 + 8) = &unk_1E816B6E0;
    v14 = v15 + 8;
    *(_BYTE *)(v15 + 16) = 63;
    v16 = *a2;
    *(_WORD *)(v15 + 17) = *(_WORD *)(v15 + 17) & 0xF000 | 0x540;
    *(_OWORD *)(v15 + 24) = v16;
    v17 = *(_DWORD *)(a1 + 916) + 1;
    v18 = *(_DWORD *)(a1 + 912);
    if (v17 > 2 * v18)
    {
      llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v18, (uint64_t)off_1E81A1260);
      v25 = v27;
      v26 = 0x2000000000;
      sub_1C5DFE788((unsigned int *)v15, (unsigned int *)&v25);
      v9 = *(_QWORD *)(a1 + 904)
         + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v25, (uint64_t)v25 + 4 * v26));
      if (v25 != v27)
        free(v25);
      v17 = *(_DWORD *)(a1 + 916) + 1;
    }
    *(_DWORD *)(a1 + 916) = v17;
    v19 = *(_QWORD *)v9;
    if (!*(_QWORD *)v9)
      v19 = v9 | 1;
    *(_QWORD *)v15 = v19;
    *(_QWORD *)v9 = v15;
  }
  else
  {
    v14 = 0;
  }
  v13 = 1;
LABEL_24:
  if (v23 != &v24[2])
    free(v23);
  if (v13)
  {
    *(_QWORD *)(a1 + 920) = v14;
  }
  else if (v14)
  {
    v25 = 0;
    v21 = sub_1C627E01C(a1 + 944, v14, &v25);
    v22 = 0;
    if (v21)
      v22 = *((_QWORD *)v25 + 1);
    if (v22)
      v14 = v22;
    if (v14 == *(_QWORD *)(a1 + 928))
      *(_BYTE *)(a1 + 936) = 1;
  }
  return v14;
}

uint64_t sub_1C5E0E01C(uint64_t a1, uint64_t *a2, uint64_t *a3, char *a4)
{
  int v8;
  uint64_t v9;
  int v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  BOOL v16;
  BOOL v17;
  int v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char v23;
  unsigned int v24;
  int v25;
  uint64_t v26;
  int v28;
  uint64_t v29;
  void *v30;
  __int128 v31;
  int v32;
  int v33;
  uint64_t v34;
  int v35;
  int v36;
  uint64_t v37;
  void *v38;
  uint64_t v39;
  _QWORD v40[17];

  v40[16] = *MEMORY[0x1E0C80C00];
  v8 = *(unsigned __int8 *)(a1 + 937);
  v30 = (char *)&v31 + 8;
  v9 = *a3;
  v10 = *a4;
  v11 = HIDWORD(*a2);
  v32 = *a2;
  v33 = v11;
  v34 = v9;
  v35 = v10;
  v36 = 0;
  v31 = xmmword_1C866FC40;
  v12 = sub_1C4F5AB38((_QWORD *)&v31 + 1, (uint64_t)&v37);
  v14 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v12);
  v15 = *(unsigned int **)v14;
  v38 = v40;
  v39 = 0x2000000000;
  if (v15)
    v16 = (v15 & 1) == 0;
  else
    v16 = 0;
  if (!v16)
    goto LABEL_17;
  while (1)
  {
    LOBYTE(v12) = sub_1C5DFE6F4(v12, v15, (uint64_t)&v30, v13, (unsigned int *)&v38);
    if ((v12 & 1) != 0)
      break;
    LODWORD(v39) = 0;
    v15 = *(unsigned int **)v15;
    if (v15)
      v17 = (v15 & 1) == 0;
    else
      v17 = 0;
    if (!v17)
    {
      v15 = 0;
      goto LABEL_13;
    }
  }
  v14 = 0;
LABEL_13:
  if (v38 == v40)
  {
    if (v15)
    {
LABEL_15:
      v18 = 0;
      v19 = (uint64_t)(v15 + 2);
      goto LABEL_24;
    }
  }
  else
  {
    free(v38);
    if (v15)
      goto LABEL_15;
  }
LABEL_17:
  if (v8)
  {
    v20 = sub_1C484358C(a1 + 808, 48, 3);
    *(_QWORD *)(v20 + 8) = &unk_1E816B7E8;
    v19 = v20 + 8;
    *(_QWORD *)v20 = 0;
    v21 = *a2;
    v22 = *a3;
    v23 = *a4;
    *(_BYTE *)(v20 + 16) = 77;
    *(_WORD *)(v20 + 17) = *(_WORD *)(v20 + 17) & 0xF000 | 0x540;
    *(_QWORD *)(v20 + 24) = v21;
    *(_QWORD *)(v20 + 32) = v22;
    *(_BYTE *)(v20 + 40) = v23;
    v24 = *(_DWORD *)(a1 + 916) + 1;
    v25 = *(_DWORD *)(a1 + 912);
    if (v24 > 2 * v25)
    {
      llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v25, (uint64_t)off_1E81A1260);
      v38 = v40;
      v39 = 0x2000000000;
      sub_1C5DFE788((unsigned int *)v20, (unsigned int *)&v38);
      v14 = *(_QWORD *)(a1 + 904)
          + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v38, (uint64_t)v38 + 4 * v39));
      if (v38 != v40)
        free(v38);
      v24 = *(_DWORD *)(a1 + 916) + 1;
    }
    *(_DWORD *)(a1 + 916) = v24;
    v26 = *(_QWORD *)v14;
    if (!*(_QWORD *)v14)
      v26 = v14 | 1;
    *(_QWORD *)v20 = v26;
    *(_QWORD *)v14 = v20;
  }
  else
  {
    v19 = 0;
  }
  v18 = 1;
LABEL_24:
  if (v30 != (char *)&v31 + 8)
    free(v30);
  if (v18)
  {
    *(_QWORD *)(a1 + 920) = v19;
  }
  else if (v19)
  {
    v38 = 0;
    v28 = sub_1C627E01C(a1 + 944, v19, &v38);
    v29 = 0;
    if (v28)
      v29 = *((_QWORD *)v38 + 1);
    if (v29)
      v19 = v29;
    if (v19 == *(_QWORD *)(a1 + 928))
      *(_BYTE *)(a1 + 936) = 1;
  }
  return v19;
}

uint64_t sub_1C5E0E2FC(unsigned __int8 **a1)
{
  int v2;
  uint64_t v3;
  uint64_t v5;
  unsigned __int8 *v6;

  if (a1[1] == *a1)
    return sub_1C5E0ED94((uint64_t)a1);
  v2 = **a1;
  if (v2 == 68)
  {
    v3 = sub_1C5E07E04((uint64_t)a1);
    goto LABEL_7;
  }
  if (v2 != 84)
    return sub_1C5E0ED94((uint64_t)a1);
  v3 = sub_1C5E08860((uint64_t)a1);
LABEL_7:
  v5 = v3;
  if (v3)
  {
    v6 = a1[38];
    if (v6 == a1[39])
    {
      sub_1C625449C((uint64_t)(a1 + 37), (v6 - a1[37]) >> 2);
      v6 = a1[38];
    }
    a1[38] = v6 + 8;
    *(_QWORD *)v6 = v5;
  }
  return v5;
}

uint64_t sub_1C5E0E39C(_QWORD *a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;

  result = sub_1C5E0BC2C((uint64_t)a1);
  v4 = result;
  if (result && a1[1] != *a1 && *(_BYTE *)*a1 == 73)
  {
    result = sub_1C5E08AA8((uint64_t)a1, 0);
    v3 = result;
    if (result)
      return sub_1C5E09218((uint64_t)a1, &v4, &v3);
  }
  return result;
}

uint64_t sub_1C5E0E408(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  int v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;
  BOOL v13;
  BOOL v14;
  int v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  int v21;
  uint64_t v22;
  int v24;
  uint64_t v25;
  void *v26;
  __int128 v27;
  int v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  _QWORD v34[17];

  v34[16] = *MEMORY[0x1E0C80C00];
  v6 = *(unsigned __int8 *)(a1 + 937);
  v26 = (char *)&v27 + 8;
  v7 = *a3;
  v8 = HIDWORD(*a2);
  v28 = *a2;
  v29 = v8;
  v30 = v7;
  v27 = xmmword_1C866FC50;
  v9 = sub_1C4F5AB38((_QWORD *)&v27 + 1, (uint64_t)&v31);
  v11 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v9);
  v12 = *(unsigned int **)v11;
  v32 = v34;
  v33 = 0x2000000000;
  if (v12)
    v13 = (v12 & 1) == 0;
  else
    v13 = 0;
  if (!v13)
    goto LABEL_17;
  while (1)
  {
    LOBYTE(v9) = sub_1C5DFE6F4(v9, v12, (uint64_t)&v26, v10, (unsigned int *)&v32);
    if ((v9 & 1) != 0)
      break;
    LODWORD(v33) = 0;
    v12 = *(unsigned int **)v12;
    if (v12)
      v14 = (v12 & 1) == 0;
    else
      v14 = 0;
    if (!v14)
    {
      v12 = 0;
      goto LABEL_13;
    }
  }
  v11 = 0;
LABEL_13:
  if (v32 == v34)
  {
    if (v12)
    {
LABEL_15:
      v15 = 0;
      v16 = (uint64_t)(v12 + 2);
      goto LABEL_24;
    }
  }
  else
  {
    free(v32);
    if (v12)
      goto LABEL_15;
  }
LABEL_17:
  if (v6)
  {
    v17 = sub_1C484358C(a1 + 808, 40, 3);
    *(_QWORD *)v17 = 0;
    *(_QWORD *)(v17 + 8) = &unk_1E816BAA8;
    v16 = v17 + 8;
    v18 = *a2;
    v19 = *a3;
    *(_BYTE *)(v17 + 16) = 22;
    *(_WORD *)(v17 + 17) = *(_WORD *)(v17 + 17) & 0xF000 | 0x540;
    *(_QWORD *)(v17 + 24) = v18;
    *(_QWORD *)(v17 + 32) = v19;
    v20 = *(_DWORD *)(a1 + 916) + 1;
    v21 = *(_DWORD *)(a1 + 912);
    if (v20 > 2 * v21)
    {
      llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v21, (uint64_t)off_1E81A1260);
      v32 = v34;
      v33 = 0x2000000000;
      sub_1C5DFE788((unsigned int *)v17, (unsigned int *)&v32);
      v11 = *(_QWORD *)(a1 + 904)
          + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v32, (uint64_t)v32 + 4 * v33));
      if (v32 != v34)
        free(v32);
      v20 = *(_DWORD *)(a1 + 916) + 1;
    }
    *(_DWORD *)(a1 + 916) = v20;
    v22 = *(_QWORD *)v11;
    if (!*(_QWORD *)v11)
      v22 = v11 | 1;
    *(_QWORD *)v17 = v22;
    *(_QWORD *)v11 = v17;
  }
  else
  {
    v16 = 0;
  }
  v15 = 1;
LABEL_24:
  if (v26 != (char *)&v27 + 8)
    free(v26);
  if (v15)
  {
    *(_QWORD *)(a1 + 920) = v16;
  }
  else if (v16)
  {
    v32 = 0;
    v24 = sub_1C627E01C(a1 + 944, v16, &v32);
    v25 = 0;
    if (v24)
      v25 = *((_QWORD *)v32 + 1);
    if (v25)
      v16 = v25;
    if (v16 == *(_QWORD *)(a1 + 928))
      *(_BYTE *)(a1 + 936) = 1;
  }
  return v16;
}

uint64_t sub_1C5E0E6D4(uint64_t a1)
{
  const char *v2;
  char *v3;
  int v4;
  void *v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int *v14;
  BOOL v15;
  BOOL v16;
  int v17;
  unint64_t v18;
  unsigned int v19;
  int v20;
  uint64_t v21;
  int v22;
  void *v23;
  unsigned int *v24;
  void *v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  _QWORD v31[17];

  v31[16] = *MEMORY[0x1E0C80C00];
  v2 = *(const char **)a1;
  v3 = *(char **)(a1 + 8);
  if (v3 == *(char **)a1)
  {
    LOBYTE(v4) = 0;
  }
  else
  {
    v4 = *v2;
    if (v4 < 0)
      goto LABEL_6;
  }
  if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v4 + 60) & 0x400) != 0)
    return sub_1C5E0E39C((_QWORD *)a1);
LABEL_6:
  if ((unint64_t)&v3[-*(_QWORD *)a1] < 2)
    goto LABEL_10;
  if (!strncmp("dn", v2, 2uLL))
  {
    *(_QWORD *)a1 = v2 + 2;
    if (v3 == v2 + 2)
    {
      v7 = 0;
    }
    else
    {
      if (v2[2] < 0)
        goto LABEL_21;
      v7 = *((unsigned __int8 *)v2 + 2);
    }
    if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v7 + 60) & 0x400) != 0)
    {
      v8 = sub_1C5E0E39C((_QWORD *)a1);
LABEL_23:
      v9 = v8;
      if (!v8)
        return 0;
      v10 = *(unsigned __int8 *)(a1 + 937);
      v25 = (char *)&v26 + 8;
      v27 = v8;
      v26 = xmmword_1C866FC60;
      v11 = sub_1C4F5AB38((_QWORD *)&v26 + 1, (uint64_t)&v28);
      v13 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v11);
      v14 = *(unsigned int **)v13;
      v29 = v31;
      v30 = 0x2000000000;
      if (v14)
        v15 = (v14 & 1) == 0;
      else
        v15 = 0;
      if (!v15)
        goto LABEL_41;
      while (1)
      {
        LOBYTE(v11) = sub_1C5DFE6F4(v11, v14, (uint64_t)&v25, v12, (unsigned int *)&v29);
        if ((v11 & 1) != 0)
          break;
        LODWORD(v30) = 0;
        v14 = *(unsigned int **)v14;
        if (v14)
          v16 = (v14 & 1) == 0;
        else
          v16 = 0;
        if (!v16)
        {
          v14 = 0;
          goto LABEL_37;
        }
      }
      v13 = 0;
LABEL_37:
      if (v29 == v31)
      {
        if (v14)
        {
LABEL_39:
          v17 = 0;
          v5 = v14 + 2;
LABEL_48:
          if (v25 != (char *)&v26 + 8)
            free(v25);
          if (v17)
          {
            *(_QWORD *)(a1 + 920) = v5;
          }
          else if (v5)
          {
            v29 = 0;
            v22 = sub_1C627E01C(a1 + 944, (uint64_t)v5, &v29);
            v23 = 0;
            if (v22)
              v23 = (void *)*((_QWORD *)v29 + 1);
            if (v23)
              v5 = v23;
            if (v5 == *(void **)(a1 + 928))
              *(_BYTE *)(a1 + 936) = 1;
          }
          return (uint64_t)v5;
        }
      }
      else
      {
        free(v29);
        if (v14)
          goto LABEL_39;
      }
LABEL_41:
      if (v10)
      {
        v18 = sub_1C484358C(a1 + 808, 32, 3);
        *(_QWORD *)v18 = 0;
        *(_QWORD *)(v18 + 8) = &unk_1E816BB00;
        v5 = (void *)(v18 + 8);
        *(_BYTE *)(v18 + 16) = 46;
        *(_WORD *)(v18 + 17) = *(_WORD *)(v18 + 17) & 0xF000 | 0x540;
        *(_QWORD *)(v18 + 24) = v9;
        v19 = *(_DWORD *)(a1 + 916) + 1;
        v20 = *(_DWORD *)(a1 + 912);
        if (v19 > 2 * v20)
        {
          v24 = (unsigned int *)v18;
          llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v20, (uint64_t)off_1E81A1260);
          v29 = v31;
          v30 = 0x2000000000;
          sub_1C5DFE788(v24, (unsigned int *)&v29);
          v13 = *(_QWORD *)(a1 + 904)
              + 8
              * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v29, (uint64_t)v29 + 4 * v30));
          if (v29 != v31)
            free(v29);
          v19 = *(_DWORD *)(a1 + 916) + 1;
          v18 = (unint64_t)v24;
        }
        *(_DWORD *)(a1 + 916) = v19;
        v21 = *(_QWORD *)v13;
        if (!*(_QWORD *)v13)
          v21 = v13 | 1;
        *(_QWORD *)v18 = v21;
        *(_QWORD *)v13 = v18;
      }
      else
      {
        v5 = 0;
      }
      v17 = 1;
      goto LABEL_48;
    }
LABEL_21:
    v8 = sub_1C5E0E2FC((unsigned __int8 **)a1);
    goto LABEL_23;
  }
  if (!strncmp("on", v2, 2uLL))
    *(_QWORD *)a1 = v2 + 2;
LABEL_10:
  v5 = (void *)sub_1C5E0F528(a1, 0);
  v29 = v5;
  if (!v5 || *(_QWORD *)(a1 + 8) == *(_QWORD *)a1 || **(_BYTE **)a1 != 73)
    return (uint64_t)v5;
  v25 = (void *)sub_1C5E08AA8(a1, 0);
  if (!v25)
    return 0;
  return sub_1C5E09218(a1, (uint64_t *)&v29, (uint64_t *)&v25);
}

uint64_t sub_1C5E0EAE8(uint64_t a1, uint64_t *a2)
{
  int v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  BOOL v9;
  BOOL v10;
  int v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  int v19;
  uint64_t v20;
  void *v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  _QWORD v27[17];

  v27[16] = *MEMORY[0x1E0C80C00];
  v4 = *(unsigned __int8 *)(a1 + 937);
  v21 = (char *)&v22 + 8;
  v23 = *a2;
  v22 = xmmword_1C866FC70;
  v5 = sub_1C4F5AB38((_QWORD *)&v22 + 1, (uint64_t)&v24);
  v7 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v5);
  v8 = *(unsigned int **)v7;
  v25 = v27;
  v26 = 0x2000000000;
  if (v8)
    v9 = (v8 & 1) == 0;
  else
    v9 = 0;
  if (!v9)
    goto LABEL_17;
  while (1)
  {
    LOBYTE(v5) = sub_1C5DFE6F4(v5, v8, (uint64_t)&v21, v6, (unsigned int *)&v25);
    if ((v5 & 1) != 0)
      break;
    LODWORD(v26) = 0;
    v8 = *(unsigned int **)v8;
    if (v8)
      v10 = (v8 & 1) == 0;
    else
      v10 = 0;
    if (!v10)
    {
      v8 = 0;
      goto LABEL_13;
    }
  }
  v7 = 0;
LABEL_13:
  if (v25 == v27)
  {
    if (v8)
    {
LABEL_15:
      v11 = 0;
      v12 = (uint64_t)(v8 + 2);
      goto LABEL_24;
    }
  }
  else
  {
    free(v25);
    if (v8)
      goto LABEL_15;
  }
LABEL_17:
  if (v4)
  {
    v13 = sub_1C484358C(a1 + 808, 32, 3);
    *(_QWORD *)v13 = 0;
    *(_QWORD *)(v13 + 8) = &unk_1E816BC08;
    v12 = v13 + 8;
    v14 = *a2;
    *(_BYTE *)(v13 + 16) = 42;
    *(_WORD *)(v13 + 17) = *(_WORD *)(v13 + 17) & 0xF000 | 0x540;
    *(_QWORD *)(v13 + 24) = v14;
    v15 = *(_DWORD *)(a1 + 916) + 1;
    v16 = *(_DWORD *)(a1 + 912);
    if (v15 > 2 * v16)
    {
      llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v16, (uint64_t)off_1E81A1260);
      v25 = v27;
      v26 = 0x2000000000;
      sub_1C5DFE788((unsigned int *)v13, (unsigned int *)&v25);
      v7 = *(_QWORD *)(a1 + 904)
         + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v25, (uint64_t)v25 + 4 * v26));
      if (v25 != v27)
        free(v25);
      v15 = *(_DWORD *)(a1 + 916) + 1;
    }
    *(_DWORD *)(a1 + 916) = v15;
    v17 = *(_QWORD *)v7;
    if (!*(_QWORD *)v7)
      v17 = v7 | 1;
    *(_QWORD *)v13 = v17;
    *(_QWORD *)v7 = v13;
  }
  else
  {
    v12 = 0;
  }
  v11 = 1;
LABEL_24:
  if (v21 != (char *)&v22 + 8)
    free(v21);
  if (v11)
  {
    *(_QWORD *)(a1 + 920) = v12;
  }
  else if (v12)
  {
    v25 = 0;
    v19 = sub_1C627E01C(a1 + 944, v12, &v25);
    v20 = 0;
    if (v19)
      v20 = *((_QWORD *)v25 + 1);
    if (v20)
      v12 = v20;
    if (v12 == *(_QWORD *)(a1 + 928))
      *(_BYTE *)(a1 + 936) = 1;
  }
  return v12;
}

uint64_t sub_1C5E0ED94(uint64_t a1)
{
  unsigned __int8 *v1;
  unsigned __int8 *v2;
  unsigned int v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  unsigned __int8 *v8;
  unint64_t v9;
  uint64_t v10;
  int v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int *v16;
  BOOL v17;
  BOOL v18;
  int v19;
  unint64_t v20;
  unsigned int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  int v27;
  uint64_t v28;
  unsigned int *v29;
  void *v30;
  __int128 v31;
  int v32;
  int v33;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  _QWORD v37[17];

  v37[16] = *MEMORY[0x1E0C80C00];
  v1 = *(unsigned __int8 **)a1;
  v2 = *(unsigned __int8 **)(a1 + 8);
  if (*(unsigned __int8 **)a1 == v2 || *v1 != 83)
    return 0;
  *(_QWORD *)a1 = v1 + 1;
  if (v2 == v1 + 1)
    goto LABEL_11;
  v4 = v1[1];
  if ((char)v1[1] < 97)
  {
    if (v4 == 95)
    {
      *(_QWORD *)a1 = v1 + 2;
      v7 = *(_QWORD *)(a1 + 296);
      if (v7 != *(_QWORD *)(a1 + 304))
        return *(_QWORD *)v7;
      return 0;
    }
LABEL_11:
    v35 = 0;
    v5 = 0;
    if ((sub_1C54C3F6C((unsigned __int8 **)a1, (uint64_t *)&v35) & 1) != 0)
      return v5;
    v8 = *(unsigned __int8 **)a1;
    if (*(_QWORD *)a1 != *(_QWORD *)(a1 + 8) && *v8 == 95)
    {
      v9 = (unint64_t)v35 + 1;
      *(_QWORD *)a1 = v8 + 1;
      v10 = *(_QWORD *)(a1 + 296);
      if (v9 < (*(_QWORD *)(a1 + 304) - v10) >> 3)
        return *(_QWORD *)(v10 + 8 * v9);
    }
    return 0;
  }
  if (v4 > 0x7A)
    goto LABEL_11;
  v5 = 0;
  v6 = 0;
  switch(v1[1])
  {
    case 'a':
      goto LABEL_24;
    case 'b':
      v6 = 1;
      goto LABEL_24;
    case 'c':
    case 'e':
    case 'f':
    case 'g':
    case 'h':
      return v5;
    case 'd':
      v6 = 5;
      goto LABEL_24;
    case 'i':
      v6 = 3;
      goto LABEL_24;
    default:
      if (v4 == 111)
      {
        v6 = 4;
      }
      else
      {
        if (v4 != 115)
          return v5;
        v6 = 2;
      }
LABEL_24:
      *(_QWORD *)a1 = v1 + 2;
      v12 = *(unsigned __int8 *)(a1 + 937);
      v30 = (char *)&v31 + 8;
      v32 = v6;
      v33 = 0;
      v31 = xmmword_1C866FC80;
      v13 = sub_1C4F5AB38((_QWORD *)&v31 + 1, (uint64_t)&v34);
      v15 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v13);
      v16 = *(unsigned int **)v15;
      v35 = v37;
      v36 = 0x2000000000;
      if (v16)
        v17 = (v16 & 1) == 0;
      else
        v17 = 0;
      if (!v17)
        goto LABEL_40;
      break;
  }
  while (1)
  {
    LOBYTE(v13) = sub_1C5DFE6F4(v13, v16, (uint64_t)&v30, v14, (unsigned int *)&v35);
    if ((v13 & 1) != 0)
      break;
    LODWORD(v36) = 0;
    v16 = *(unsigned int **)v16;
    if (v16)
      v18 = (v16 & 1) == 0;
    else
      v18 = 0;
    if (!v18)
    {
      v16 = 0;
      goto LABEL_36;
    }
  }
  v15 = 0;
LABEL_36:
  if (v35 != v37)
  {
    free(v35);
    if (v16)
      goto LABEL_38;
LABEL_40:
    if (v12)
    {
      v20 = sub_1C484358C(a1 + 808, 24, 3);
      *(_QWORD *)v20 = 0;
      *(_QWORD *)(v20 + 8) = &unk_1E816BC60;
      v5 = v20 + 8;
      *(_BYTE *)(v20 + 16) = 44;
      *(_WORD *)(v20 + 17) = *(_WORD *)(v20 + 17) & 0xF000 | 0x540;
      *(_DWORD *)(v20 + 20) = v6;
      v21 = *(_DWORD *)(a1 + 916) + 1;
      v22 = *(_DWORD *)(a1 + 912);
      if (v21 > 2 * v22)
      {
        v29 = (unsigned int *)v20;
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v22, (uint64_t)off_1E81A1260);
        v35 = v37;
        v36 = 0x2000000000;
        sub_1C5DFE788(v29, (unsigned int *)&v35);
        v15 = *(_QWORD *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v35, (uint64_t)v35 + 4 * v36));
        if (v35 != v37)
          free(v35);
        v21 = *(_DWORD *)(a1 + 916) + 1;
        v20 = (unint64_t)v29;
      }
      *(_DWORD *)(a1 + 916) = v21;
      v23 = *(_QWORD *)v15;
      if (!*(_QWORD *)v15)
        v23 = v15 | 1;
      *(_QWORD *)v20 = v23;
      *(_QWORD *)v15 = v20;
    }
    else
    {
      v5 = 0;
    }
    v19 = 1;
    goto LABEL_47;
  }
  if (!v16)
    goto LABEL_40;
LABEL_38:
  v19 = 0;
  v5 = (uint64_t)(v16 + 2);
LABEL_47:
  if (v30 != (char *)&v31 + 8)
    free(v30);
  if (v19)
  {
    *(_QWORD *)(a1 + 920) = v5;
  }
  else
  {
    if (!v5)
      return v5;
    v35 = 0;
    v27 = sub_1C627E01C(a1 + 944, v5, &v35);
    v28 = 0;
    if (v27)
      v28 = *((_QWORD *)v35 + 1);
    if (v28)
      v5 = v28;
    if (v5 == *(_QWORD *)(a1 + 928))
      *(_BYTE *)(a1 + 936) = 1;
  }
  if (v5)
  {
    v24 = sub_1C5E0F1BC(a1, v5);
    if (v24 != v5)
    {
      v25 = v24;
      v26 = *(uint64_t **)(a1 + 304);
      if (v26 == *(uint64_t **)(a1 + 312))
      {
        sub_1C625449C(a1 + 296, ((uint64_t)v26 - *(_QWORD *)(a1 + 296)) >> 2);
        v26 = *(uint64_t **)(a1 + 304);
      }
      *(_QWORD *)(a1 + 304) = v26 + 1;
      *v26 = v25;
      return v25;
    }
  }
  return v5;
}

uint64_t sub_1C5E0F1BC(uint64_t a1, uint64_t a2)
{
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  int v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int *v11;
  BOOL v12;
  BOOL v13;
  int v14;
  unint64_t v15;
  __int16 v16;
  unsigned int v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  int v24;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  __int128 v30;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  _QWORD v34[18];

  v34[16] = *MEMORY[0x1E0C80C00];
  v26 = a1 + 904;
  v27 = a1 + 944;
  v28 = a1 + 808;
  while (1)
  {
    v4 = *(unsigned __int8 **)a1;
    if (*(_QWORD *)a1 == *(_QWORD *)(a1 + 8) || *v4 != 66)
      return a2;
    *(_QWORD *)a1 = v4 + 1;
    v32 = 0;
    v5 = 0;
    v6 = 0;
    if ((sub_1C54C42B4((unsigned __int8 **)a1, (uint64_t *)&v32) & 1) == 0)
    {
      v6 = *(unsigned __int8 **)a1;
      if (*(_QWORD *)(a1 + 8) - *(_QWORD *)a1 >= (unint64_t)v32)
      {
        v5 = (unsigned __int8 *)v32 + (_QWORD)v6;
        *(_QWORD *)a1 = (char *)v32 + (_QWORD)v6;
      }
      else
      {
        v5 = 0;
        v6 = 0;
      }
    }
    if (v6 == v5)
      return 0;
    v7 = *(unsigned __int8 *)(a1 + 937);
    v29 = (char *)&v30 + 8;
    v31 = a2;
    v30 = xmmword_1C866FC90;
    llvm::FoldingSetNodeID::AddString((unsigned int *)&v29, v6, (_DWORD)v5 - (_DWORD)v6);
    v8 = sub_1C4F5AB38(v29, (uint64_t)v29 + 4 * v30);
    v10 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v8);
    v11 = *(unsigned int **)v10;
    v32 = v34;
    v33 = 0x2000000000;
    if (v11)
      v12 = (v11 & 1) == 0;
    else
      v12 = 0;
    if (!v12)
    {
LABEL_25:
      if (v7)
      {
        v15 = sub_1C484358C(v28, 48, 3);
        *(_QWORD *)v15 = 0;
        v16 = *(_WORD *)(a2 + 9);
        *(_QWORD *)(v15 + 8) = &unk_1E816BCB8;
        *(_BYTE *)(v15 + 16) = 8;
        *(_WORD *)(v15 + 17) = *(_WORD *)(v15 + 17) & 0xF000 | v16 & 0xFC0;
        *(_QWORD *)(v15 + 24) = a2;
        *(_QWORD *)(v15 + 32) = v6;
        *(_QWORD *)(v15 + 40) = v5;
        v17 = *(_DWORD *)(a1 + 916) + 1;
        v18 = *(_DWORD *)(a1 + 912);
        if (v17 > 2 * v18)
        {
          llvm::FoldingSetBase::GrowBucketCount(v26, 2 * v18, (uint64_t)off_1E81A1260);
          v32 = v34;
          v33 = 0x2000000000;
          sub_1C5DFE788((unsigned int *)v15, (unsigned int *)&v32);
          v22 = sub_1C4F5AB38(v32, (uint64_t)v32 + 4 * v33);
          v23 = *(_QWORD *)(a1 + 904);
          v24 = *(_DWORD *)(a1 + 912);
          if (v32 != v34)
            free(v32);
          v10 = v23 + 8 * ((v24 - 1) & v22);
          v17 = *(_DWORD *)(a1 + 916) + 1;
        }
        *(_DWORD *)(a1 + 916) = v17;
        v19 = *(_QWORD *)v10;
        if (!*(_QWORD *)v10)
          v19 = v10 | 1;
        *(_QWORD *)v15 = v19;
        *(_QWORD *)v10 = v15;
        v14 = 1;
        a2 = v15 + 8;
      }
      else
      {
        a2 = 0;
        v14 = 1;
      }
      goto LABEL_31;
    }
    while (1)
    {
      LOBYTE(v8) = sub_1C5DFE6F4(v8, v11, (uint64_t)&v29, v9, (unsigned int *)&v32);
      if ((v8 & 1) != 0)
        break;
      LODWORD(v33) = 0;
      v11 = *(unsigned int **)v11;
      if (v11)
        v13 = (v11 & 1) == 0;
      else
        v13 = 0;
      if (!v13)
      {
        v11 = 0;
        goto LABEL_21;
      }
    }
    v10 = 0;
LABEL_21:
    if (v32 == v34)
    {
      if (!v11)
        goto LABEL_25;
    }
    else
    {
      free(v32);
      if (!v11)
        goto LABEL_25;
    }
    v14 = 0;
    a2 = (uint64_t)(v11 + 2);
LABEL_31:
    if (v29 != (char *)&v30 + 8)
      free(v29);
    if (v14)
    {
      *(_QWORD *)(a1 + 920) = a2;
      if (!a2)
        return a2;
    }
    else
    {
      if (!a2)
        return a2;
      v32 = 0;
      v20 = sub_1C627E01C(v27, a2, &v32);
      v21 = 0;
      if (v20)
        v21 = *((_QWORD *)v32 + 1);
      if (v21)
        a2 = v21;
      if (a2 == *(_QWORD *)(a1 + 928))
        *(_BYTE *)(a1 + 936) = 1;
    }
  }
}

uint64_t sub_1C5E0F528(uint64_t a1, _BYTE *a2)
{
  char *v4;
  unsigned int v5;
  char v6;
  int v7;
  BOOL v8;
  char v9;
  uint64_t v10;
  unsigned __int8 *v11;
  unsigned __int8 *v12;
  const char *v14;
  uint64_t v16;
  uint64_t v17;
  int v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int *v22;
  BOOL v23;
  BOOL v24;
  int v25;
  unint64_t v26;
  unsigned int v27;
  int v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  unsigned int *v32;
  void *v33;
  __int128 v34;
  uint64_t v35;
  uint64_t v36;
  __int128 v37;
  _QWORD v38[17];

  v38[16] = *MEMORY[0x1E0C80C00];
  v4 = sub_1C5E098BC((unsigned __int8 **)a1);
  if (v4)
  {
    v5 = v4[2];
    if (v5 == 8)
    {
      v6 = *(_BYTE *)(a1 + 776);
      *(_BYTE *)(a1 + 776) = 0;
      v7 = *(unsigned __int8 *)(a1 + 777);
      if (a2)
        v8 = 0;
      else
        v8 = v7 == 0;
      v9 = !v8;
      *(_BYTE *)(a1 + 777) = v9;
      *(_QWORD *)&v37 = sub_1C5DF9EB0(a1);
      if ((_QWORD)v37)
      {
        if (a2)
          *a2 = 1;
        v10 = sub_1C5E0F92C(a1, (uint64_t *)&v37);
      }
      else
      {
        v10 = 0;
      }
      *(_BYTE *)(a1 + 777) = v7;
      *(_BYTE *)(a1 + 776) = v6;
      return v10;
    }
    if (v5 <= 0xA && (v5 != 4 || (v4[3] & 1) != 0))
    {
      v14 = (const char *)*((_QWORD *)v4 + 1);
      *(_QWORD *)&v37 = v14;
      *((_QWORD *)&v37 + 1) = &v14[strlen(v14)];
      return sub_1C5E04030(a1, &v37);
    }
    return 0;
  }
  v11 = *(unsigned __int8 **)a1;
  v12 = *(unsigned __int8 **)(a1 + 8);
  if ((unint64_t)&v12[-*(_QWORD *)a1] < 2 || strncmp("li", *(const char **)a1, 2uLL))
  {
    if (v11 != v12 && *v11 == 118)
    {
      *(_QWORD *)a1 = v11 + 1;
      if (v12 != v11 + 1 && v11[1] - 48 <= 9)
      {
        *(_QWORD *)a1 = v11 + 2;
        *(_QWORD *)&v37 = sub_1C5E0BC2C(a1);
        if ((_QWORD)v37)
          return sub_1C5E0F92C(a1, (uint64_t *)&v37);
      }
    }
    return 0;
  }
  *(_QWORD *)a1 = v11 + 2;
  v16 = sub_1C5E0BC2C(a1);
  if (!v16)
    return 0;
  v17 = v16;
  v18 = *(unsigned __int8 *)(a1 + 937);
  v33 = (char *)&v34 + 8;
  v35 = v16;
  v34 = xmmword_1C866FCA0;
  v19 = sub_1C4F5AB38((_QWORD *)&v34 + 1, (uint64_t)&v36);
  v21 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v19);
  v22 = *(unsigned int **)v21;
  *(_QWORD *)&v37 = v38;
  *((_QWORD *)&v37 + 1) = 0x2000000000;
  if (v22)
    v23 = (v22 & 1) == 0;
  else
    v23 = 0;
  if (!v23)
    goto LABEL_47;
  while (1)
  {
    LOBYTE(v19) = sub_1C5DFE6F4(v19, v22, (uint64_t)&v33, v20, (unsigned int *)&v37);
    if ((v19 & 1) != 0)
      break;
    DWORD2(v37) = 0;
    v22 = *(unsigned int **)v22;
    if (v22)
      v24 = (v22 & 1) == 0;
    else
      v24 = 0;
    if (!v24)
    {
      v22 = 0;
      goto LABEL_43;
    }
  }
  v21 = 0;
LABEL_43:
  if ((_QWORD *)v37 != v38)
  {
    free((void *)v37);
    if (v22)
      goto LABEL_45;
LABEL_47:
    if (v18)
    {
      v26 = sub_1C484358C(a1 + 808, 32, 3);
      *(_QWORD *)v26 = 0;
      *(_QWORD *)(v26 + 8) = &unk_1E816BBB0;
      v10 = v26 + 8;
      *(_BYTE *)(v26 + 16) = 19;
      *(_WORD *)(v26 + 17) = *(_WORD *)(v26 + 17) & 0xF000 | 0x540;
      *(_QWORD *)(v26 + 24) = v17;
      v27 = *(_DWORD *)(a1 + 916) + 1;
      v28 = *(_DWORD *)(a1 + 912);
      if (v27 > 2 * v28)
      {
        v32 = (unsigned int *)v26;
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v28, (uint64_t)off_1E81A1260);
        *(_QWORD *)&v37 = v38;
        *((_QWORD *)&v37 + 1) = 0x2000000000;
        sub_1C5DFE788(v32, (unsigned int *)&v37);
        v21 = *(_QWORD *)(a1 + 904)
            + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38((_QWORD *)v37, v37 + 4 * DWORD2(v37)));
        if ((_QWORD *)v37 != v38)
          free((void *)v37);
        v27 = *(_DWORD *)(a1 + 916) + 1;
        v26 = (unint64_t)v32;
      }
      *(_DWORD *)(a1 + 916) = v27;
      v29 = *(_QWORD *)v21;
      if (!*(_QWORD *)v21)
        v29 = v21 | 1;
      *(_QWORD *)v26 = v29;
      *(_QWORD *)v21 = v26;
    }
    else
    {
      v10 = 0;
    }
    v25 = 1;
    goto LABEL_54;
  }
  if (!v22)
    goto LABEL_47;
LABEL_45:
  v25 = 0;
  v10 = (uint64_t)(v22 + 2);
LABEL_54:
  if (v33 != (char *)&v34 + 8)
    free(v33);
  if (v25)
  {
    *(_QWORD *)(a1 + 920) = v10;
  }
  else if (v10)
  {
    *(_QWORD *)&v37 = 0;
    v30 = sub_1C627E01C(a1 + 944, v10, &v37);
    v31 = 0;
    if (v30)
      v31 = *(_QWORD *)(v37 + 8);
    if (v31)
      v10 = v31;
    if (v10 == *(_QWORD *)(a1 + 928))
      *(_BYTE *)(a1 + 936) = 1;
  }
  return v10;
}

uint64_t sub_1C5E0F92C(uint64_t a1, uint64_t *a2)
{
  int v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  BOOL v9;
  BOOL v10;
  int v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  int v19;
  uint64_t v20;
  void *v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  _QWORD v27[17];

  v27[16] = *MEMORY[0x1E0C80C00];
  v4 = *(unsigned __int8 *)(a1 + 937);
  v21 = (char *)&v22 + 8;
  v23 = *a2;
  v22 = xmmword_1C866FCB0;
  v5 = sub_1C4F5AB38((_QWORD *)&v22 + 1, (uint64_t)&v24);
  v7 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v5);
  v8 = *(unsigned int **)v7;
  v25 = v27;
  v26 = 0x2000000000;
  if (v8)
    v9 = (v8 & 1) == 0;
  else
    v9 = 0;
  if (!v9)
    goto LABEL_17;
  while (1)
  {
    LOBYTE(v5) = sub_1C5DFE6F4(v5, v8, (uint64_t)&v21, v6, (unsigned int *)&v25);
    if ((v5 & 1) != 0)
      break;
    LODWORD(v26) = 0;
    v8 = *(unsigned int **)v8;
    if (v8)
      v10 = (v8 & 1) == 0;
    else
      v10 = 0;
    if (!v10)
    {
      v8 = 0;
      goto LABEL_13;
    }
  }
  v7 = 0;
LABEL_13:
  if (v25 == v27)
  {
    if (v8)
    {
LABEL_15:
      v11 = 0;
      v12 = (uint64_t)(v8 + 2);
      goto LABEL_24;
    }
  }
  else
  {
    free(v25);
    if (v8)
      goto LABEL_15;
  }
LABEL_17:
  if (v4)
  {
    v13 = sub_1C484358C(a1 + 808, 32, 3);
    *(_QWORD *)v13 = 0;
    *(_QWORD *)(v13 + 8) = &unk_1E816BB58;
    v12 = v13 + 8;
    v14 = *a2;
    *(_BYTE *)(v13 + 16) = 4;
    *(_WORD *)(v13 + 17) = *(_WORD *)(v13 + 17) & 0xF000 | 0x540;
    *(_QWORD *)(v13 + 24) = v14;
    v15 = *(_DWORD *)(a1 + 916) + 1;
    v16 = *(_DWORD *)(a1 + 912);
    if (v15 > 2 * v16)
    {
      llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v16, (uint64_t)off_1E81A1260);
      v25 = v27;
      v26 = 0x2000000000;
      sub_1C5DFE788((unsigned int *)v13, (unsigned int *)&v25);
      v7 = *(_QWORD *)(a1 + 904)
         + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v25, (uint64_t)v25 + 4 * v26));
      if (v25 != v27)
        free(v25);
      v15 = *(_DWORD *)(a1 + 916) + 1;
    }
    *(_DWORD *)(a1 + 916) = v15;
    v17 = *(_QWORD *)v7;
    if (!*(_QWORD *)v7)
      v17 = v7 | 1;
    *(_QWORD *)v13 = v17;
    *(_QWORD *)v7 = v13;
  }
  else
  {
    v12 = 0;
  }
  v11 = 1;
LABEL_24:
  if (v21 != (char *)&v22 + 8)
    free(v21);
  if (v11)
  {
    *(_QWORD *)(a1 + 920) = v12;
  }
  else if (v12)
  {
    v25 = 0;
    v19 = sub_1C627E01C(a1 + 944, v12, &v25);
    v20 = 0;
    if (v19)
      v20 = *((_QWORD *)v25 + 1);
    if (v20)
      v12 = v20;
    if (v12 == *(_QWORD *)(a1 + 928))
      *(_BYTE *)(a1 + 936) = 1;
  }
  return v12;
}

uint64_t sub_1C5E0FBD8(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  int v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;
  BOOL v13;
  BOOL v14;
  int v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  int v21;
  uint64_t v22;
  int v24;
  uint64_t v25;
  void *v26;
  __int128 v27;
  int v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  _QWORD v34[17];

  v34[16] = *MEMORY[0x1E0C80C00];
  v6 = *(unsigned __int8 *)(a1 + 937);
  v26 = (char *)&v27 + 8;
  v7 = *a3;
  v8 = HIDWORD(*a2);
  v28 = *a2;
  v29 = v8;
  v30 = v7;
  v27 = xmmword_1C866F9B0;
  v9 = sub_1C4F5AB38((_QWORD *)&v27 + 1, (uint64_t)&v31);
  v11 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v9);
  v12 = *(unsigned int **)v11;
  v32 = v34;
  v33 = 0x2000000000;
  if (v12)
    v13 = (v12 & 1) == 0;
  else
    v13 = 0;
  if (!v13)
    goto LABEL_17;
  while (1)
  {
    LOBYTE(v9) = sub_1C5DFE6F4(v9, v12, (uint64_t)&v26, v10, (unsigned int *)&v32);
    if ((v9 & 1) != 0)
      break;
    LODWORD(v33) = 0;
    v12 = *(unsigned int **)v12;
    if (v12)
      v14 = (v12 & 1) == 0;
    else
      v14 = 0;
    if (!v14)
    {
      v12 = 0;
      goto LABEL_13;
    }
  }
  v11 = 0;
LABEL_13:
  if (v32 == v34)
  {
    if (v12)
    {
LABEL_15:
      v15 = 0;
      v16 = (uint64_t)(v12 + 2);
      goto LABEL_24;
    }
  }
  else
  {
    free(v32);
    if (v12)
      goto LABEL_15;
  }
LABEL_17:
  if (v6)
  {
    v17 = sub_1C484358C(a1 + 808, 40, 3);
    *(_QWORD *)v17 = 0;
    *(_QWORD *)(v17 + 8) = &unk_1E816C4A0;
    v16 = v17 + 8;
    v18 = *a2;
    v19 = *a3;
    *(_BYTE *)(v17 + 16) = 27;
    *(_WORD *)(v17 + 17) = *(_WORD *)(v17 + 17) & 0xF000 | 0x540;
    *(_QWORD *)(v17 + 24) = v18;
    *(_QWORD *)(v17 + 32) = v19;
    v20 = *(_DWORD *)(a1 + 916) + 1;
    v21 = *(_DWORD *)(a1 + 912);
    if (v20 > 2 * v21)
    {
      llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v21, (uint64_t)off_1E81A1260);
      v32 = v34;
      v33 = 0x2000000000;
      sub_1C5DFE788((unsigned int *)v17, (unsigned int *)&v32);
      v11 = *(_QWORD *)(a1 + 904)
          + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v32, (uint64_t)v32 + 4 * v33));
      if (v32 != v34)
        free(v32);
      v20 = *(_DWORD *)(a1 + 916) + 1;
    }
    *(_DWORD *)(a1 + 916) = v20;
    v22 = *(_QWORD *)v11;
    if (!*(_QWORD *)v11)
      v22 = v11 | 1;
    *(_QWORD *)v17 = v22;
    *(_QWORD *)v11 = v17;
  }
  else
  {
    v16 = 0;
  }
  v15 = 1;
LABEL_24:
  if (v26 != (char *)&v27 + 8)
    free(v26);
  if (v15)
  {
    *(_QWORD *)(a1 + 920) = v16;
  }
  else if (v16)
  {
    v32 = 0;
    v24 = sub_1C627E01C(a1 + 944, v16, &v32);
    v25 = 0;
    if (v24)
      v25 = *((_QWORD *)v32 + 1);
    if (v25)
      v16 = v25;
    if (v16 == *(_QWORD *)(a1 + 928))
      *(_BYTE *)(a1 + 936) = 1;
  }
  return v16;
}

uint64_t sub_1C5E0FEA4(uint64_t a1, _BYTE *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int *v18;
  BOOL v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int *v26;
  BOOL v27;
  BOOL v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  unsigned __int8 *v36;
  uint64_t v37;
  const void *v38;
  uint64_t *v39;
  uint64_t *v40;
  int64_t v41;
  uint64_t v42;
  int v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int *v47;
  BOOL v48;
  BOOL v49;
  int v50;
  int v51;
  uint64_t v52;
  unint64_t v53;
  unsigned int v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unsigned int *v63;
  BOOL v64;
  int v65;
  uint64_t v66;
  int v67;
  unint64_t v68;
  unsigned int v69;
  int v70;
  uint64_t v71;
  int v72;
  uint64_t v73;
  unint64_t v74;
  unsigned int v75;
  int v76;
  uint64_t v77;
  int v78;
  uint64_t v79;
  unint64_t v80;
  unsigned int v81;
  int v82;
  uint64_t v83;
  int v84;
  unsigned __int8 *v85;
  int v86;
  unsigned int v87;
  int v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  void *v92;
  __int128 v93;
  uint64_t v94;
  uint64_t v95;
  _BYTE v96[104];
  void *v97;
  uint64_t v98;
  _QWORD v99[17];

  v99[16] = *MEMORY[0x1E0C80C00];
  v90 = a4;
  v91 = a3;
  if ((sub_1C5E10B28(a1, &v90) & 1) != 0)
    return 0;
  v9 = *(unsigned __int8 **)a1;
  v10 = *(unsigned __int8 **)(a1 + 8);
  if (*(unsigned __int8 **)a1 != v10 && *v9 == 76)
    *(_QWORD *)a1 = ++v9;
  if (v10 != v9 && (char)*v9 >= 49)
  {
    v11 = *v9;
    if (v11 <= 0x39)
    {
      v12 = sub_1C5E0BC2C(a1);
LABEL_30:
      v20 = v12;
      goto LABEL_31;
    }
    if (v11 == 85)
    {
      v12 = sub_1C5E0C534(a1, (uint64_t)a2);
      goto LABEL_30;
    }
  }
  if ((unint64_t)(v10 - v9) < 2 || strncmp("DC", (const char *)v9, 2uLL))
  {
    if (v10 == v9 || *v9 - 67 > 1)
    {
      v12 = sub_1C5E0F528(a1, a2);
      goto LABEL_30;
    }
    v7 = 0;
    if (!a3 || v90)
      return v7;
    if (*(_BYTE *)(a3 + 8) != 44 || (v13 = *(_DWORD *)(a3 + 12), v13 - 2 > 3))
    {
LABEL_170:
      if (v9 == v10)
        return 0;
      v84 = *v9;
      if (v84 == 67)
      {
        v85 = v9 + 1;
        *(_QWORD *)a1 = v9 + 1;
        if (v9 + 1 == v10)
        {
          v86 = 0;
          v85 = v10;
        }
        else if (*v85 == 73)
        {
          v85 = v9 + 2;
          *(_QWORD *)a1 = v9 + 2;
          v86 = 1;
        }
        else
        {
          v86 = 0;
        }
        if (v10 == v85 || *v85 - 49 > 4)
          return 0;
        LODWORD(v97) = 0;
        LODWORD(v97) = (char)*v85 - 48;
        *(_QWORD *)a1 = v85 + 1;
        if (a2)
          *a2 = 1;
        if (v86 && !sub_1C5DFC098(a1, a2))
        {
          v20 = 0;
          goto LABEL_31;
        }
        LOBYTE(v92) = 0;
      }
      else
      {
        v7 = 0;
        if ((unint64_t)(v10 - v9) < 2)
          return v7;
        if (v84 != 68)
          return v7;
        v7 = 0;
        v87 = v9[1];
        if (v87 > 0x35 || ((1 << v87) & 0x37000000000000) == 0)
          return v7;
        LODWORD(v97) = 0;
        LODWORD(v97) = (char)v9[1] - 48;
        *(_QWORD *)a1 = v9 + 2;
        if (a2)
          *a2 = 1;
        LOBYTE(v92) = 1;
      }
      v12 = sub_1C5E10EC8(a1, &v91, (char *)&v92, (int *)&v97);
      goto LABEL_30;
    }
    v14 = *(unsigned __int8 *)(a1 + 937);
    v92 = (char *)&v93 + 8;
    LODWORD(v94) = v13;
    HIDWORD(v94) = v13 >> 31;
    v93 = xmmword_1C866FCC0;
    v15 = sub_1C4F5AB38((_QWORD *)&v93 + 1, (uint64_t)&v95);
    v17 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v15);
    v18 = *(unsigned int **)v17;
    v97 = v99;
    v98 = 0x2000000000;
    if (v18 && (v18 & 1) == 0)
    {
      while (1)
      {
        LOBYTE(v15) = sub_1C5DFE6F4(v15, v18, (uint64_t)&v92, v16, (unsigned int *)&v97);
        if ((v15 & 1) != 0)
          break;
        LODWORD(v98) = 0;
        v18 = *(unsigned int **)v18;
        if (v18)
          v19 = (v18 & 1) == 0;
        else
          v19 = 0;
        if (!v19)
        {
          v18 = 0;
          goto LABEL_74;
        }
      }
      v17 = 0;
LABEL_74:
      if (v97 == v99)
      {
        if (v18)
        {
LABEL_76:
          v51 = 0;
          v52 = (uint64_t)(v18 + 2);
          goto LABEL_164;
        }
      }
      else
      {
        free(v97);
        if (v18)
          goto LABEL_76;
      }
    }
    if (v14)
    {
      v80 = sub_1C484358C(a1 + 808, 24, 3);
      *(_QWORD *)v80 = 0;
      *(_QWORD *)(v80 + 8) = &unk_1E816BD68;
      v52 = v80 + 8;
      *(_BYTE *)(v80 + 16) = 43;
      *(_WORD *)(v80 + 17) = *(_WORD *)(v80 + 17) & 0xF000 | 0x540;
      *(_DWORD *)(v80 + 20) = v13;
      v81 = *(_DWORD *)(a1 + 916) + 1;
      v82 = *(_DWORD *)(a1 + 912);
      if (v81 > 2 * v82)
      {
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v82, (uint64_t)off_1E81A1260);
        v97 = v99;
        v98 = 0x2000000000;
        sub_1C5DFE788((unsigned int *)v80, (unsigned int *)&v97);
        v17 = *(_QWORD *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v97, (uint64_t)v97 + 4 * v98));
        if (v97 != v99)
          free(v97);
        v81 = *(_DWORD *)(a1 + 916) + 1;
      }
      *(_DWORD *)(a1 + 916) = v81;
      v83 = *(_QWORD *)v17;
      if (!*(_QWORD *)v17)
        v83 = v17 | 1;
      *(_QWORD *)v80 = v83;
      *(_QWORD *)v17 = v80;
    }
    else
    {
      v52 = 0;
    }
    v51 = 1;
LABEL_164:
    if (v92 != (char *)&v93 + 8)
      free(v92);
    if (v51)
    {
      *(_QWORD *)(a1 + 920) = v52;
    }
    else
    {
      if (!v52)
        return 0;
      v97 = 0;
      v88 = sub_1C627E01C(a1 + 944, v52, &v97);
      v89 = 0;
      if (v88)
        v89 = *((_QWORD *)v97 + 1);
      if (v89)
        v52 = v89;
      if (v52 == *(_QWORD *)(a1 + 928))
        *(_BYTE *)(a1 + 936) = 1;
    }
    v91 = v52;
    if (v52)
    {
      v9 = *(unsigned __int8 **)a1;
      v10 = *(unsigned __int8 **)(a1 + 8);
      goto LABEL_170;
    }
    return 0;
  }
  *(_QWORD *)a1 = v9 + 2;
  v30 = *(_QWORD *)(a1 + 16);
  v31 = *(_QWORD *)(a1 + 24);
  v32 = sub_1C5E0BC2C(a1);
  if (!v32)
    return 0;
  v33 = v32;
  v34 = (v31 - v30) >> 3;
  while (1)
  {
    v35 = *(uint64_t **)(a1 + 24);
    if (v35 == *(uint64_t **)(a1 + 32))
    {
      sub_1C625449C(a1 + 16, ((uint64_t)v35 - *(_QWORD *)(a1 + 16)) >> 2);
      v35 = *(uint64_t **)(a1 + 24);
    }
    *(_QWORD *)(a1 + 24) = v35 + 1;
    *v35 = v33;
    v36 = *(unsigned __int8 **)a1;
    if (*(_QWORD *)a1 != *(_QWORD *)(a1 + 8) && *v36 == 69)
      break;
    v33 = sub_1C5E0BC2C(a1);
    v7 = 0;
    if (!v33)
      return v7;
  }
  *(_QWORD *)a1 = v36 + 1;
  v37 = *(_QWORD *)(a1 + 24);
  v38 = (const void *)(*(_QWORD *)(a1 + 16) + 8 * v34);
  v39 = (uint64_t *)sub_1C484358C(a1 + 808, v37 - (_QWORD)v38, 3);
  v40 = v39;
  v41 = v37 - (_QWORD)v38;
  if (v41)
    memmove(v39, v38, v41);
  v42 = v41 >> 3;
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 16) + 8 * v34;
  v43 = *(unsigned __int8 *)(a1 + 937);
  v92 = (char *)&v93 + 8;
  *(_QWORD *)&v93 = 0x2000000000;
  sub_1C5E0169C(&v92, 49, v40, v41 >> 3);
  v44 = sub_1C4F5AB38(v92, (uint64_t)v92 + 4 * v93);
  v46 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v44);
  v47 = *(unsigned int **)v46;
  v97 = v99;
  v98 = 0x2000000000;
  if (v47)
    v48 = (v47 & 1) == 0;
  else
    v48 = 0;
  if (!v48)
    goto LABEL_135;
  while (1)
  {
    LOBYTE(v44) = sub_1C5DFE6F4(v44, v47, (uint64_t)&v92, v45, (unsigned int *)&v97);
    if ((v44 & 1) != 0)
      break;
    LODWORD(v98) = 0;
    v47 = *(unsigned int **)v47;
    if (v47)
      v49 = (v47 & 1) == 0;
    else
      v49 = 0;
    if (!v49)
    {
      v47 = 0;
      goto LABEL_70;
    }
  }
  v46 = 0;
LABEL_70:
  if (v97 == v99)
  {
    if (v47)
    {
LABEL_72:
      v50 = 0;
      v20 = (uint64_t)(v47 + 2);
      goto LABEL_142;
    }
  }
  else
  {
    free(v97);
    if (v47)
      goto LABEL_72;
  }
LABEL_135:
  if (v43)
  {
    v74 = sub_1C484358C(a1 + 808, 40, 3);
    *(_QWORD *)v74 = 0;
    *(_QWORD *)(v74 + 8) = &unk_1E816BD10;
    v20 = v74 + 8;
    *(_BYTE *)(v74 + 16) = 49;
    *(_WORD *)(v74 + 17) = *(_WORD *)(v74 + 17) & 0xF000 | 0x540;
    *(_QWORD *)(v74 + 24) = v40;
    *(_QWORD *)(v74 + 32) = v42;
    v75 = *(_DWORD *)(a1 + 916) + 1;
    v76 = *(_DWORD *)(a1 + 912);
    if (v75 > 2 * v76)
    {
      llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v76, (uint64_t)off_1E81A1260);
      v97 = v99;
      v98 = 0x2000000000;
      sub_1C5DFE788((unsigned int *)v74, (unsigned int *)&v97);
      v46 = *(_QWORD *)(a1 + 904)
          + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v97, (uint64_t)v97 + 4 * v98));
      if (v97 != v99)
        free(v97);
      v75 = *(_DWORD *)(a1 + 916) + 1;
    }
    *(_DWORD *)(a1 + 916) = v75;
    v77 = *(_QWORD *)v46;
    if (!*(_QWORD *)v46)
      v77 = v46 | 1;
    *(_QWORD *)v74 = v77;
    *(_QWORD *)v46 = v74;
  }
  else
  {
    v20 = 0;
  }
  v50 = 1;
LABEL_142:
  if (v92 != (char *)&v93 + 8)
    free(v92);
  if (v50)
  {
    *(_QWORD *)(a1 + 920) = v20;
  }
  else
  {
    if (!v20)
      return 0;
    v97 = 0;
    v78 = sub_1C627E01C(a1 + 944, v20, &v97);
    v79 = 0;
    if (v78)
      v79 = *((_QWORD *)v97 + 1);
    if (v79)
      v20 = v79;
    if (v20 == *(_QWORD *)(a1 + 928))
      *(_BYTE *)(a1 + 936) = 1;
  }
LABEL_31:
  if (!v20)
    goto LABEL_88;
  v21 = v90;
  if (!v90)
    goto LABEL_88;
  v22 = *(unsigned __int8 *)(a1 + 937);
  v92 = (char *)&v93 + 8;
  v94 = v90;
  v95 = v20;
  v93 = xmmword_1C866FCD0;
  v23 = sub_1C4F5AB38((_QWORD *)&v93 + 1, (uint64_t)v96);
  v25 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v23);
  v26 = *(unsigned int **)v25;
  v97 = v99;
  v98 = 0x2000000000;
  if (v26)
    v27 = (v26 & 1) == 0;
  else
    v27 = 0;
  if (!v27)
    goto LABEL_78;
  while (1)
  {
    LOBYTE(v23) = sub_1C5DFE6F4(v23, v26, (uint64_t)&v92, v24, (unsigned int *)&v97);
    if ((v23 & 1) != 0)
      break;
    LODWORD(v98) = 0;
    v26 = *(unsigned int **)v26;
    if (v26)
      v28 = (v26 & 1) == 0;
    else
      v28 = 0;
    if (!v28)
    {
      v26 = 0;
      goto LABEL_45;
    }
  }
  v25 = 0;
LABEL_45:
  if (v97 == v99)
  {
    if (v26)
    {
LABEL_47:
      v29 = 0;
      v20 = (uint64_t)(v26 + 2);
      goto LABEL_84;
    }
  }
  else
  {
    free(v97);
    if (v26)
      goto LABEL_47;
  }
LABEL_78:
  if (v22)
  {
    v53 = sub_1C484358C(a1 + 808, 40, 3);
    *(_QWORD *)v53 = 0;
    *(_QWORD *)(v53 + 8) = &unk_1E816BE18;
    *(_BYTE *)(v53 + 16) = 26;
    *(_WORD *)(v53 + 17) = *(_WORD *)(v53 + 17) & 0xF000 | 0x540;
    *(_QWORD *)(v53 + 24) = v21;
    *(_QWORD *)(v53 + 32) = v20;
    v54 = *(_DWORD *)(a1 + 916) + 1;
    v55 = *(_DWORD *)(a1 + 912);
    if (v54 > 2 * v55)
    {
      llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v55, (uint64_t)off_1E81A1260);
      v97 = v99;
      v98 = 0x2000000000;
      sub_1C5DFE788((unsigned int *)v53, (unsigned int *)&v97);
      v25 = *(_QWORD *)(a1 + 904)
          + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v97, (uint64_t)v97 + 4 * v98));
      if (v97 != v99)
        free(v97);
      v54 = *(_DWORD *)(a1 + 916) + 1;
    }
    *(_DWORD *)(a1 + 916) = v54;
    v56 = *(_QWORD *)v25;
    if (!*(_QWORD *)v25)
      v56 = v25 | 1;
    *(_QWORD *)v53 = v56;
    *(_QWORD *)v25 = v53;
    v29 = 1;
    v20 = v53 + 8;
  }
  else
  {
    v20 = 0;
    v29 = 1;
  }
LABEL_84:
  if (v92 != (char *)&v93 + 8)
    free(v92);
  if (v29)
  {
    *(_QWORD *)(a1 + 920) = v20;
  }
  else
  {
    if (!v20)
      return 0;
    v97 = 0;
    v65 = sub_1C627E01C(a1 + 944, v20, &v97);
    v66 = 0;
    if (v65)
      v66 = *((_QWORD *)v97 + 1);
    if (v66)
      v20 = v66;
    if (v20 == *(_QWORD *)(a1 + 928))
      *(_BYTE *)(a1 + 936) = 1;
  }
LABEL_88:
  if (!v20)
    return 0;
  v57 = sub_1C5E0F1BC(a1, v20);
  v7 = v57;
  if (!v57)
    return v7;
  v58 = v91;
  if (!v91)
    return v7;
  v59 = *(unsigned __int8 *)(a1 + 937);
  v92 = (char *)&v93 + 8;
  v94 = v91;
  v95 = v57;
  v93 = xmmword_1C866FCE0;
  v60 = sub_1C4F5AB38((_QWORD *)&v93 + 1, (uint64_t)v96);
  v62 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v60);
  v63 = *(unsigned int **)v62;
  v97 = v99;
  v98 = 0x2000000000;
  if (!v63 || (v63 & 1) != 0)
    goto LABEL_114;
  while (1)
  {
    LOBYTE(v60) = sub_1C5DFE6F4(v60, v63, (uint64_t)&v92, v61, (unsigned int *)&v97);
    if ((v60 & 1) != 0)
      break;
    LODWORD(v98) = 0;
    v63 = *(unsigned int **)v63;
    if (v63)
      v64 = (v63 & 1) == 0;
    else
      v64 = 0;
    if (!v64)
    {
      v63 = 0;
      goto LABEL_107;
    }
  }
  v62 = 0;
LABEL_107:
  if (v97 != v99)
  {
    free(v97);
    if (v63)
      goto LABEL_109;
LABEL_114:
    if (v59)
    {
      v68 = sub_1C484358C(a1 + 808, 40, 3);
      *(_QWORD *)v68 = 0;
      *(_QWORD *)(v68 + 8) = &unk_1E816BE70;
      *(_BYTE *)(v68 + 16) = 23;
      *(_WORD *)(v68 + 17) = *(_WORD *)(v68 + 17) & 0xF000 | 0x540;
      *(_QWORD *)(v68 + 24) = v58;
      *(_QWORD *)(v68 + 32) = v7;
      v69 = *(_DWORD *)(a1 + 916) + 1;
      v70 = *(_DWORD *)(a1 + 912);
      if (v69 > 2 * v70)
      {
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v70, (uint64_t)off_1E81A1260);
        v97 = v99;
        v98 = 0x2000000000;
        sub_1C5DFE788((unsigned int *)v68, (unsigned int *)&v97);
        v62 = *(_QWORD *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v97, (uint64_t)v97 + 4 * v98));
        if (v97 != v99)
          free(v97);
        v69 = *(_DWORD *)(a1 + 916) + 1;
      }
      *(_DWORD *)(a1 + 916) = v69;
      v71 = *(_QWORD *)v62;
      if (!*(_QWORD *)v62)
        v71 = v62 | 1;
      *(_QWORD *)v68 = v71;
      *(_QWORD *)v62 = v68;
      v67 = 1;
      v7 = v68 + 8;
    }
    else
    {
      v7 = 0;
      v67 = 1;
    }
    goto LABEL_120;
  }
  if (!v63)
    goto LABEL_114;
LABEL_109:
  v67 = 0;
  v7 = (uint64_t)(v63 + 2);
LABEL_120:
  if (v92 != (char *)&v93 + 8)
    free(v92);
  if (v67)
  {
    *(_QWORD *)(a1 + 920) = v7;
  }
  else if (v7)
  {
    v97 = 0;
    v72 = sub_1C627E01C(a1 + 944, v7, &v97);
    v73 = 0;
    if (v72)
      v73 = *((_QWORD *)v97 + 1);
    if (v73)
      v7 = v73;
    if (v7 == *(_QWORD *)(a1 + 928))
      *(_BYTE *)(a1 + 936) = 1;
  }
  return v7;
}

uint64_t sub_1C5E10B28(uint64_t a1, uint64_t *a2)
{
  _BYTE *v2;
  _BYTE *v3;
  int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int *v14;
  BOOL v16;
  int v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unsigned int v21;
  int v22;
  uint64_t v23;
  uint64_t *v24;
  int v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  int v29;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  __int128 v36;
  int v37;
  int v38;
  uint64_t v39;
  int v40;
  int v41;
  uint64_t v42;
  void *v43;
  uint64_t v44;
  _QWORD v45[18];

  v45[16] = *MEMORY[0x1E0C80C00];
  v2 = *(_BYTE **)a1;
  v3 = *(_BYTE **)(a1 + 8);
  if (*(_BYTE **)a1 != v3)
  {
    v34 = a1 + 808;
    v31 = a1 + 904;
    v32 = a1 + 944;
    v33 = a1 + 296;
    while (1)
    {
      if (*v2 != 87)
        return 0;
      *(_QWORD *)a1 = v2 + 1;
      if (v2 + 1 == v3 || v2[1] != 80)
      {
        v6 = 0;
      }
      else
      {
        *(_QWORD *)a1 = v2 + 2;
        v6 = 1;
      }
      v7 = sub_1C5E0BC2C(a1);
      if (!v7)
        return 1;
      v8 = v7;
      v9 = *(unsigned __int8 *)(a1 + 937);
      v35 = (char *)&v36 + 8;
      v10 = HIDWORD(*a2);
      v37 = *a2;
      v38 = v10;
      v39 = v7;
      v40 = v6;
      v41 = 0;
      v36 = xmmword_1C866FCF0;
      v11 = sub_1C4F5AB38((_QWORD *)&v36 + 1, (uint64_t)&v42);
      v13 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v11);
      v14 = *(unsigned int **)v13;
      v43 = v45;
      v44 = 0x2000000000;
      if (!v14 || (v14 & 1) != 0)
        break;
      while (1)
      {
        LOBYTE(v11) = sub_1C5DFE6F4(v11, v14, (uint64_t)&v35, v12, (unsigned int *)&v43);
        if ((v11 & 1) != 0)
          break;
        LODWORD(v44) = 0;
        v14 = *(unsigned int **)v14;
        if (v14)
          v16 = (v14 & 1) == 0;
        else
          v16 = 0;
        if (!v16)
        {
          v14 = 0;
          goto LABEL_21;
        }
      }
      v13 = 0;
LABEL_21:
      if (v43 == v45)
      {
        if (!v14)
          break;
      }
      else
      {
        free(v43);
        if (!v14)
          break;
      }
      v17 = 0;
      v18 = (uint64_t)(v14 + 2);
LABEL_32:
      if (v35 != (char *)&v36 + 8)
        free(v35);
      if (v17)
      {
        *(_QWORD *)(a1 + 920) = v18;
      }
      else if (v18)
      {
        v43 = 0;
        v25 = sub_1C627E01C(v32, v18, &v43);
        v26 = 0;
        if (v25)
          v26 = *((_QWORD *)v43 + 1);
        if (v26)
          v18 = v26;
        if (v18 == *(_QWORD *)(a1 + 928))
          *(_BYTE *)(a1 + 936) = 1;
      }
      *a2 = v18;
      v24 = *(uint64_t **)(a1 + 304);
      if (v24 == *(uint64_t **)(a1 + 312))
      {
        sub_1C625449C(v33, ((uint64_t)v24 - *(_QWORD *)(a1 + 296)) >> 2);
        v24 = *(uint64_t **)(a1 + 304);
      }
      *(_QWORD *)(a1 + 304) = v24 + 1;
      *v24 = v18;
      v2 = *(_BYTE **)a1;
      v3 = *(_BYTE **)(a1 + 8);
      if (*(_BYTE **)a1 == v3)
        return 0;
    }
    if (v9)
    {
      v19 = sub_1C484358C(v34, 48, 3);
      *(_QWORD *)v19 = 0;
      *(_QWORD *)(v19 + 8) = &unk_1E816A908;
      v18 = v19 + 8;
      v20 = *a2;
      *(_BYTE *)(v19 + 16) = 25;
      *(_WORD *)(v19 + 17) = *(_WORD *)(v19 + 17) & 0xF000 | 0x540;
      *(_QWORD *)(v19 + 24) = v20;
      *(_QWORD *)(v19 + 32) = v8;
      *(_BYTE *)(v19 + 40) = v6;
      v21 = *(_DWORD *)(a1 + 916) + 1;
      v22 = *(_DWORD *)(a1 + 912);
      if (v21 > 2 * v22)
      {
        llvm::FoldingSetBase::GrowBucketCount(v31, 2 * v22, (uint64_t)off_1E81A1260);
        v43 = v45;
        v44 = 0x2000000000;
        sub_1C5DFE788((unsigned int *)v19, (unsigned int *)&v43);
        v27 = sub_1C4F5AB38(v43, (uint64_t)v43 + 4 * v44);
        v28 = *(_QWORD *)(a1 + 904);
        v29 = *(_DWORD *)(a1 + 912);
        if (v43 != v45)
          free(v43);
        v13 = v28 + 8 * ((v29 - 1) & v27);
        v21 = *(_DWORD *)(a1 + 916) + 1;
      }
      *(_DWORD *)(a1 + 916) = v21;
      v23 = *(_QWORD *)v13;
      if (!*(_QWORD *)v13)
        v23 = v13 | 1;
      *(_QWORD *)v19 = v23;
      *(_QWORD *)v13 = v19;
    }
    else
    {
      v18 = 0;
    }
    v17 = 1;
    goto LABEL_32;
  }
  return 0;
}

uint64_t sub_1C5E10EC8(uint64_t a1, uint64_t *a2, char *a3, int *a4)
{
  int v8;
  int v9;
  int v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  BOOL v16;
  BOOL v17;
  int v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  char v22;
  int v23;
  unsigned int v24;
  int v25;
  uint64_t v26;
  int v28;
  uint64_t v29;
  void *v30;
  __int128 v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  void *v39;
  uint64_t v40;
  _QWORD v41[17];

  v41[16] = *MEMORY[0x1E0C80C00];
  v8 = *(unsigned __int8 *)(a1 + 937);
  v30 = (char *)&v31 + 8;
  v9 = *a3;
  v10 = *a4;
  v11 = HIDWORD(*a2);
  v32 = *a2;
  v33 = v11;
  v34 = v9;
  v35 = 0;
  v36 = v10;
  v37 = v10 >> 31;
  v31 = xmmword_1C866FD00;
  v12 = sub_1C4F5AB38((_QWORD *)&v31 + 1, (uint64_t)&v38);
  v14 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v12);
  v15 = *(unsigned int **)v14;
  v39 = v41;
  v40 = 0x2000000000;
  if (v15)
    v16 = (v15 & 1) == 0;
  else
    v16 = 0;
  if (!v16)
    goto LABEL_17;
  while (1)
  {
    LOBYTE(v12) = sub_1C5DFE6F4(v12, v15, (uint64_t)&v30, v13, (unsigned int *)&v39);
    if ((v12 & 1) != 0)
      break;
    LODWORD(v40) = 0;
    v15 = *(unsigned int **)v15;
    if (v15)
      v17 = (v15 & 1) == 0;
    else
      v17 = 0;
    if (!v17)
    {
      v15 = 0;
      goto LABEL_13;
    }
  }
  v14 = 0;
LABEL_13:
  if (v39 == v41)
  {
    if (v15)
    {
LABEL_15:
      v18 = 0;
      v19 = (uint64_t)(v15 + 2);
      goto LABEL_24;
    }
  }
  else
  {
    free(v39);
    if (v15)
      goto LABEL_15;
  }
LABEL_17:
  if (v8)
  {
    v20 = sub_1C484358C(a1 + 808, 40, 3);
    *(_QWORD *)(v20 + 8) = &unk_1E816BDC0;
    v19 = v20 + 8;
    *(_QWORD *)v20 = 0;
    v21 = *a2;
    v22 = *a3;
    v23 = *a4;
    *(_BYTE *)(v20 + 16) = 45;
    *(_WORD *)(v20 + 17) = *(_WORD *)(v20 + 17) & 0xF000 | 0x540;
    *(_QWORD *)(v20 + 24) = v21;
    *(_BYTE *)(v20 + 32) = v22;
    *(_DWORD *)(v20 + 36) = v23;
    v24 = *(_DWORD *)(a1 + 916) + 1;
    v25 = *(_DWORD *)(a1 + 912);
    if (v24 > 2 * v25)
    {
      llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v25, (uint64_t)off_1E81A1260);
      v39 = v41;
      v40 = 0x2000000000;
      sub_1C5DFE788((unsigned int *)v20, (unsigned int *)&v39);
      v14 = *(_QWORD *)(a1 + 904)
          + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v39, (uint64_t)v39 + 4 * v40));
      if (v39 != v41)
        free(v39);
      v24 = *(_DWORD *)(a1 + 916) + 1;
    }
    *(_DWORD *)(a1 + 916) = v24;
    v26 = *(_QWORD *)v14;
    if (!*(_QWORD *)v14)
      v26 = v14 | 1;
    *(_QWORD *)v20 = v26;
    *(_QWORD *)v14 = v20;
  }
  else
  {
    v19 = 0;
  }
  v18 = 1;
LABEL_24:
  if (v30 != (char *)&v31 + 8)
    free(v30);
  if (v18)
  {
    *(_QWORD *)(a1 + 920) = v19;
  }
  else if (v19)
  {
    v39 = 0;
    v28 = sub_1C627E01C(a1 + 944, v19, &v39);
    v29 = 0;
    if (v28)
      v29 = *((_QWORD *)v39 + 1);
    if (v29)
      v19 = v29;
    if (v19 == *(_QWORD *)(a1 + 928))
      *(_BYTE *)(a1 + 936) = 1;
  }
  return v19;
}

uint64_t sub_1C5E111AC(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  int v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;
  BOOL v13;
  BOOL v14;
  int v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  int v21;
  uint64_t v22;
  int v24;
  uint64_t v25;
  void *v26;
  __int128 v27;
  int v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  _QWORD v34[17];

  v34[16] = *MEMORY[0x1E0C80C00];
  v6 = *(unsigned __int8 *)(a1 + 937);
  v26 = (char *)&v27 + 8;
  v7 = *a3;
  v8 = HIDWORD(*a2);
  v28 = *a2;
  v29 = v8;
  v30 = v7;
  v27 = xmmword_1C866FD10;
  v9 = sub_1C4F5AB38((_QWORD *)&v27 + 1, (uint64_t)&v31);
  v11 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v9);
  v12 = *(unsigned int **)v11;
  v32 = v34;
  v33 = 0x2000000000;
  if (v12)
    v13 = (v12 & 1) == 0;
  else
    v13 = 0;
  if (!v13)
    goto LABEL_17;
  while (1)
  {
    LOBYTE(v9) = sub_1C5DFE6F4(v9, v12, (uint64_t)&v26, v10, (unsigned int *)&v32);
    if ((v9 & 1) != 0)
      break;
    LODWORD(v33) = 0;
    v12 = *(unsigned int **)v12;
    if (v12)
      v14 = (v12 & 1) == 0;
    else
      v14 = 0;
    if (!v14)
    {
      v12 = 0;
      goto LABEL_13;
    }
  }
  v11 = 0;
LABEL_13:
  if (v32 == v34)
  {
    if (v12)
    {
LABEL_15:
      v15 = 0;
      v16 = (uint64_t)(v12 + 2);
      goto LABEL_24;
    }
  }
  else
  {
    free(v32);
    if (v12)
      goto LABEL_15;
  }
LABEL_17:
  if (v6)
  {
    v17 = sub_1C484358C(a1 + 808, 40, 3);
    *(_QWORD *)v17 = 0;
    *(_QWORD *)(v17 + 8) = &unk_1E816BEC8;
    v16 = v17 + 8;
    v18 = *a2;
    v19 = *a3;
    *(_BYTE *)(v17 + 16) = 24;
    *(_WORD *)(v17 + 17) = *(_WORD *)(v17 + 17) & 0xF000 | 0x540;
    *(_QWORD *)(v17 + 24) = v18;
    *(_QWORD *)(v17 + 32) = v19;
    v20 = *(_DWORD *)(a1 + 916) + 1;
    v21 = *(_DWORD *)(a1 + 912);
    if (v20 > 2 * v21)
    {
      llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v21, (uint64_t)off_1E81A1260);
      v32 = v34;
      v33 = 0x2000000000;
      sub_1C5DFE788((unsigned int *)v17, (unsigned int *)&v32);
      v11 = *(_QWORD *)(a1 + 904)
          + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v32, (uint64_t)v32 + 4 * v33));
      if (v32 != v34)
        free(v32);
      v20 = *(_DWORD *)(a1 + 916) + 1;
    }
    *(_DWORD *)(a1 + 916) = v20;
    v22 = *(_QWORD *)v11;
    if (!*(_QWORD *)v11)
      v22 = v11 | 1;
    *(_QWORD *)v17 = v22;
    *(_QWORD *)v11 = v17;
  }
  else
  {
    v16 = 0;
  }
  v15 = 1;
LABEL_24:
  if (v26 != (char *)&v27 + 8)
    free(v26);
  if (v15)
  {
    *(_QWORD *)(a1 + 920) = v16;
  }
  else if (v16)
  {
    v32 = 0;
    v24 = sub_1C627E01C(a1 + 944, v16, &v32);
    v25 = 0;
    if (v24)
      v25 = *((_QWORD *)v32 + 1);
    if (v25)
      v16 = v25;
    if (v16 == *(_QWORD *)(a1 + 928))
      *(_BYTE *)(a1 + 936) = 1;
  }
  return v16;
}

uint64_t sub_1C5E11478(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t *a5, int *a6, char *a7)
{
  char *v7;
  int *v8;
  uint64_t *v9;
  __int128 *v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  int v17;
  int v18;
  unint64_t v19;
  int v20;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int *v38;
  BOOL v39;
  int v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  char v47;
  __int128 v48;
  unsigned int v49;
  int v50;
  uint64_t v51;
  int v53;
  uint64_t v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  void *v68;
  __int128 v69;
  int v70;
  int v71;
  uint64_t v72;
  uint64_t v73;
  void *v74;
  uint64_t v75;
  _QWORD v76[18];

  v7 = a7;
  v8 = a6;
  v9 = a5;
  v10 = (__int128 *)a4;
  v11 = a1;
  v76[16] = *MEMORY[0x1E0C80C00];
  v12 = *(unsigned __int8 *)(a1 + 937);
  v68 = (char *)&v69 + 8;
  v13 = *a3;
  v15 = *(uint64_t **)a4;
  v14 = *(_QWORD *)(a4 + 8);
  v16 = *a5;
  v17 = *a6;
  v18 = *a7;
  v19 = HIDWORD(*a2);
  v70 = *a2;
  v71 = v19;
  v72 = v13;
  v73 = v14;
  v69 = xmmword_1C866FD20;
  if (v14)
  {
    v20 = v12;
    v25 = 8 * v14;
    LODWORD(v14) = 8;
    do
    {
      v26 = *v15;
      if (v14 >= DWORD1(v69))
      {
        v61 = v17;
        v63 = v18;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, (uint64_t)&v69 + 8, v14 + 1, 4);
        v17 = v61;
        v18 = v63;
        LODWORD(v14) = v69;
      }
      *((_DWORD *)v68 + v14) = v26;
      v27 = (v69 + 1);
      LODWORD(v69) = v27;
      if (v27 >= DWORD1(v69))
      {
        v62 = v17;
        v64 = v18;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, (uint64_t)&v69 + 8, v27 + 1, 4);
        v17 = v62;
        v18 = v64;
        LODWORD(v27) = v69;
      }
      *((_DWORD *)v68 + v27) = HIDWORD(v26);
      v14 = (v69 + 1);
      LODWORD(v69) = v69 + 1;
      ++v15;
      v25 -= 8;
    }
    while (v25);
    v7 = a7;
    v8 = a6;
    v9 = a5;
    v10 = (__int128 *)a4;
    v12 = v20;
    v11 = a1;
    if (v14 >= DWORD1(v69))
    {
      v28 = v18;
      v29 = v17;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, (uint64_t)&v69 + 8, v14 + 1, 4);
      v17 = v29;
      v18 = v28;
      LODWORD(v14) = v69;
    }
  }
  else
  {
    LODWORD(v14) = 8;
  }
  *((_DWORD *)v68 + v14) = v16;
  v30 = (v69 + 1);
  LODWORD(v69) = v30;
  if (v30 >= DWORD1(v69))
  {
    v58 = v18;
    v59 = v17;
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, (uint64_t)&v69 + 8, v30 + 1, 4);
    v17 = v59;
    v18 = v58;
    LODWORD(v30) = v69;
  }
  *((_DWORD *)v68 + v30) = HIDWORD(v16);
  v31 = (v69 + 1);
  LODWORD(v69) = v31;
  if (v31 >= DWORD1(v69))
  {
    v55 = v18;
    v56 = v17;
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, (uint64_t)&v69 + 8, v31 + 1, 4);
    v17 = v56;
    v18 = v55;
    LODWORD(v31) = v69;
  }
  *((_DWORD *)v68 + v31) = v17;
  v32 = (v69 + 1);
  LODWORD(v69) = v32;
  if (v32 >= DWORD1(v69))
  {
    v60 = v18;
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, (uint64_t)&v69 + 8, v32 + 1, 4);
    v18 = v60;
    LODWORD(v32) = v69;
  }
  *((_DWORD *)v68 + v32) = 0;
  v33 = (v69 + 1);
  LODWORD(v69) = v33;
  if (v33 >= DWORD1(v69))
  {
    v57 = v18;
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, (uint64_t)&v69 + 8, v33 + 1, 4);
    v18 = v57;
    LODWORD(v33) = v69;
  }
  *((_DWORD *)v68 + v33) = v18;
  v34 = (v69 + 1);
  LODWORD(v69) = v34;
  if (v34 >= DWORD1(v69))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, (uint64_t)&v69 + 8, v34 + 1, 4);
    LODWORD(v34) = v69;
  }
  *((_DWORD *)v68 + v34) = 0;
  LODWORD(v69) = v69 + 1;
  v35 = sub_1C4F5AB38(v68, (uint64_t)v68 + 4 * v69);
  v37 = *(_QWORD *)(v11 + 904) + 8 * ((*(_DWORD *)(v11 + 912) - 1) & v35);
  v38 = *(unsigned int **)v37;
  v74 = v76;
  v75 = 0x2000000000;
  if (v38 && (v38 & 1) == 0)
  {
    while (1)
    {
      LOBYTE(v35) = sub_1C5DFE6F4(v35, v38, (uint64_t)&v68, v36, (unsigned int *)&v74);
      if ((v35 & 1) != 0)
        break;
      LODWORD(v75) = 0;
      v38 = *(unsigned int **)v38;
      if (v38)
        v39 = (v38 & 1) == 0;
      else
        v39 = 0;
      if (!v39)
      {
        v38 = 0;
        goto LABEL_30;
      }
    }
    v37 = 0;
LABEL_30:
    if (v74 == v76)
    {
      if (v38)
      {
LABEL_32:
        v40 = 0;
        v41 = (uint64_t)(v38 + 2);
        goto LABEL_41;
      }
    }
    else
    {
      free(v74);
      if (v38)
        goto LABEL_32;
    }
  }
  if (v12)
  {
    v42 = sub_1C484358C(v11 + 808, 72, 3);
    *(_QWORD *)v42 = 0;
    *(_QWORD *)(v42 + 8) = &unk_1E816C0D8;
    v41 = v42 + 8;
    v43 = *a2;
    v44 = *a3;
    v45 = *v9;
    v46 = *v8;
    v47 = *v7;
    *(_BYTE *)(v42 + 16) = 18;
    v48 = *v10;
    *(_WORD *)(v42 + 17) = *(_WORD *)(v42 + 17) & 0xF000 | 0x100;
    *(_QWORD *)(v42 + 24) = v43;
    *(_QWORD *)(v42 + 32) = v44;
    *(_OWORD *)(v42 + 40) = v48;
    *(_QWORD *)(v42 + 56) = v45;
    *(_DWORD *)(v42 + 64) = v46;
    *(_BYTE *)(v42 + 68) = v47;
    v49 = *(_DWORD *)(v11 + 916) + 1;
    v50 = *(_DWORD *)(v11 + 912);
    if (v49 > 2 * v50)
    {
      llvm::FoldingSetBase::GrowBucketCount(v11 + 904, 2 * v50, (uint64_t)off_1E81A1260);
      v74 = v76;
      v75 = 0x2000000000;
      sub_1C5DFE788((unsigned int *)v42, (unsigned int *)&v74);
      v37 = *(_QWORD *)(v11 + 904)
          + 8
          * ((*(_DWORD *)(v11 + 912) - 1) & sub_1C4F5AB38(v74, (uint64_t)v74 + 4 * v75));
      if (v74 != v76)
        free(v74);
      v49 = *(_DWORD *)(v11 + 916) + 1;
    }
    *(_DWORD *)(v11 + 916) = v49;
    v51 = *(_QWORD *)v37;
    if (!*(_QWORD *)v37)
      v51 = v37 | 1;
    *(_QWORD *)v42 = v51;
    *(_QWORD *)v37 = v42;
  }
  else
  {
    v41 = 0;
  }
  v40 = 1;
LABEL_41:
  if (v68 != (char *)&v69 + 8)
    free(v68);
  if (v40)
  {
    *(_QWORD *)(v11 + 920) = v41;
  }
  else if (v41)
  {
    v74 = 0;
    v53 = sub_1C627E01C(v11 + 944, v41, &v74);
    v54 = 0;
    if (v53)
      v54 = *((_QWORD *)v74 + 1);
    if (v54)
      v41 = v54;
    if (v41 == *(_QWORD *)(v11 + 928))
      *(_BYTE *)(v11 + 936) = 1;
  }
  return v41;
}

uint64_t sub_1C5E119F8(uint64_t a1, char *__s, uint64_t *a3)
{
  int v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int *v14;
  BOOL v15;
  BOOL v16;
  int v17;
  uint64_t v18;
  unint64_t v19;
  size_t v20;
  uint64_t v21;
  unsigned int v22;
  int v23;
  uint64_t v24;
  int v26;
  uint64_t v27;
  void *v28;
  unsigned int v29[34];
  void *v30;
  uint64_t v31;
  _QWORD v32[17];

  v32[16] = *MEMORY[0x1E0C80C00];
  v6 = *(unsigned __int8 *)(a1 + 937);
  v28 = &v29[2];
  v7 = *a3;
  *(_OWORD *)v29 = xmmword_1C866F9F0;
  v8 = strlen(__s);
  llvm::FoldingSetNodeID::AddString((unsigned int *)&v28, (unsigned __int8 *)__s, v8);
  v9 = v29[0];
  if (v29[0] >= v29[1])
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v28, (uint64_t)&v29[2], v29[0] + 1, 4);
    v9 = v29[0];
  }
  *((_DWORD *)v28 + v9) = v7;
  v10 = v29[0] + 1;
  v29[0] = v10;
  if (v10 >= v29[1])
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v28, (uint64_t)&v29[2], v10 + 1, 4);
    LODWORD(v10) = v29[0];
  }
  *((_DWORD *)v28 + v10) = HIDWORD(v7);
  ++v29[0];
  v11 = sub_1C4F5AB38(v28, (uint64_t)v28 + 4 * v29[0]);
  v13 = *(_QWORD *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v11);
  v14 = *(unsigned int **)v13;
  v30 = v32;
  v31 = 0x2000000000;
  if (v14)
    v15 = (v14 & 1) == 0;
  else
    v15 = 0;
  if (!v15)
    goto LABEL_21;
  while (1)
  {
    LOBYTE(v11) = sub_1C5DFE6F4(v11, v14, (uint64_t)&v28, v12, (unsigned int *)&v30);
    if ((v11 & 1) != 0)
      break;
    LODWORD(v31) = 0;
    v14 = *(unsigned int **)v14;
    if (v14)
      v16 = (v14 & 1) == 0;
    else
      v16 = 0;
    if (!v16)
    {
      v14 = 0;
      goto LABEL_17;
    }
  }
  v13 = 0;
LABEL_17:
  if (v30 == v32)
  {
    if (v14)
    {
LABEL_19:
      v17 = 0;
      v18 = (uint64_t)(v14 + 2);
      goto LABEL_28;
    }
  }
  else
  {
    free(v30);
    if (v14)
      goto LABEL_19;
  }
LABEL_21:
  if (v6)
  {
    v19 = sub_1C484358C(a1 + 808, 48, 3);
    *(_QWORD *)v19 = 0;
    v20 = strlen(__s);
    *(_QWORD *)(v19 + 8) = &unk_1E816A800;
    v18 = v19 + 8;
    v21 = *a3;
    *(_BYTE *)(v19 + 16) = 20;
    *(_WORD *)(v19 + 17) = *(_WORD *)(v19 + 17) & 0xF000 | 0x540;
    *(_QWORD *)(v19 + 24) = __s;
    *(_QWORD *)(v19 + 32) = &__s[v20];
    *(_QWORD *)(v19 + 40) = v21;
    v22 = *(_DWORD *)(a1 + 916) + 1;
    v23 = *(_DWORD *)(a1 + 912);
    if (v22 > 2 * v23)
    {
      llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v23, (uint64_t)off_1E81A1260);
      v30 = v32;
      v31 = 0x2000000000;
      sub_1C5DFE788((unsigned int *)v19, (unsigned int *)&v30);
      v13 = *(_QWORD *)(a1 + 904)
          + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1C4F5AB38(v30, (uint64_t)v30 + 4 * v31));
      if (v30 != v32)
        free(v30);
      v22 = *(_DWORD *)(a1 + 916) + 1;
    }
    *(_DWORD *)(a1 + 916) = v22;
    v24 = *(_QWORD *)v13;
    if (!*(_QWORD *)v13)
      v24 = v13 | 1;
    *(_QWORD *)v19 = v24;
    *(_QWORD *)v13 = v19;
  }
  else
  {
    v18 = 0;
  }
  v17 = 1;
LABEL_28:
  if (v28 != &v29[2])
    free(v28);
  if (v17)
  {
    *(_QWORD *)(a1 + 920) = v18;
  }
  else if (v18)
  {
    v30 = 0;
    v26 = sub_1C627E01C(a1 + 944, v18, &v30);
    v27 = 0;
    if (v26)
      v27 = *((_QWORD *)v30 + 1);
    if (v27)
      v18 = v27;
    if (v18 == *(_QWORD *)(a1 + 928))
      *(_BYTE *)(a1 + 936) = 1;
  }
  return v18;
}

uint64_t sub_1C5E11D4C(uint64_t a1, unsigned int a2)
{
  unint64_t v3;
  unint64_t v4;
  int v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  uint64_t v14[65];

  v14[64] = *MEMORY[0x1E0C80C00];
  if (a2 >= 0x21)
  {
    v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40)
      a2 = v5 + 1;
    else
      a2 = 64;
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    v6 = *(uint64_t **)(a1 + 8);
    v7 = *(unsigned int *)(a1 + 16);
    if (a2 > 0x20)
    {
      v13 = a2;
      *(_QWORD *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
      *(_QWORD *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1C638BA1C(a1, v6, &v6[2 * v7]);
    JUMPOUT(0x1CAA32FB4);
  }
  v8 = 0;
  v9 = v14;
  do
  {
    v10 = *(_QWORD *)(a1 + v8 + 8);
    if ((v10 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      *v9 = v10;
      v9[1] = *(_QWORD *)(a1 + v8 + 16);
      v9 += 2;
    }
    v8 += 16;
  }
  while (v8 != 512);
  if (a2 > 0x20)
  {
    *(_DWORD *)a1 &= ~1u;
    v11 = a2;
    *(_QWORD *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
    *(_QWORD *)(a1 + 16) = v11;
  }
  return sub_1C638BA1C(a1, v14, v9);
}

uint64_t llvm::json::Object::operator[](uint64_t a1, __int128 **a2)
{
  _QWORD v3[3];

  sub_1C6174CF0(a1, a2, (uint64_t)v3);
  return v3[0] + 24;
}

uint64_t llvm::json::Object::get(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4;
  uint64_t v5;
  _QWORD v7[2];
  uint64_t v8;

  v7[0] = a2;
  v7[1] = a3;
  v8 = 0;
  v4 = sub_1C5E147B8((uint64_t *)a1, (uint64_t)v7, &v8);
  v5 = v8;
  if (!v4)
    v5 = *(_QWORD *)a1 + 56 * *(unsigned int *)(a1 + 16);
  if (*(_QWORD *)a1 + 56 * *(unsigned int *)(a1 + 16) == v5)
    return 0;
  else
    return v5 + 24;
}

{
  uint64_t v4;

  v4 = sub_1C5E11F9C(a1, a2, a3);
  if (*(_QWORD *)a1 + 56 * *(unsigned int *)(a1 + 16) == v4)
    return 0;
  else
    return v4 + 24;
}

uint64_t sub_1C5E11F9C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD v5[2];
  uint64_t v6;

  v5[0] = a2;
  v5[1] = a3;
  v6 = 0;
  if (sub_1C5E147B8((uint64_t *)a1, (uint64_t)v5, &v6))
    return v6;
  else
    return *(_QWORD *)a1 + 56 * *(unsigned int *)(a1 + 16);
}

uint64_t llvm::json::Object::getNull(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_1C5E11F9C(a1, a2, a3);
  return 0;
}

uint64_t llvm::json::Object::getBoolean(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  int v5;
  int v6;

  v4 = sub_1C5E11F9C(a1, a2, a3);
  if (*(_QWORD *)a1 + 56 * *(unsigned int *)(a1 + 16) == v4 || *(_WORD *)(v4 + 24) != 1)
  {
    v5 = 0;
    v6 = 0;
  }
  else
  {
    v5 = *(unsigned __int8 *)(v4 + 32);
    v6 = 1;
  }
  return v5 | (v6 << 8);
}

uint64_t llvm::json::Object::getNumber(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  int v5;
  double v6;

  v4 = sub_1C5E11F9C(a1, a2, a3);
  if (*(_QWORD *)a1 + 56 * *(unsigned int *)(a1 + 16) == v4)
    return 0;
  v5 = *(unsigned __int16 *)(v4 + 24);
  switch(v5)
  {
    case 2:
      v6 = *(double *)(v4 + 32);
      break;
    case 3:
      v6 = (double)*(uint64_t *)(v4 + 32);
      break;
    case 4:
      v6 = (double)*(unint64_t *)(v4 + 32);
      break;
    default:
      v6 = 0.0;
      break;
  }
  return *(_QWORD *)&v6;
}

unint64_t llvm::json::Object::getInteger(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = sub_1C5E11F9C(a1, a2, a3);
  if (*(_QWORD *)a1 + 56 * *(unsigned int *)(a1 + 16) == v4)
    return 0;
  else
    return sub_1C5DD5A44((unsigned __int16 *)(v4 + 24));
}

uint64_t llvm::json::Object::getString@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t result;
  int v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  int v11;
  uint64_t v12;
  char v13;

  result = sub_1C5E11F9C(a1, a2, a3);
  if (*(_QWORD *)a1 + 56 * *(unsigned int *)(a1 + 16) == result)
    goto LABEL_11;
  v7 = *(unsigned __int16 *)(result + 24);
  if (v7 == 6)
  {
    v9 = *(_QWORD *)(result + 32);
    result += 32;
    v8 = v9;
    v10 = *(_BYTE *)(result + 23);
    v11 = v10;
    if (v10 >= 0)
      v8 = result;
    v12 = v10 & 0x7F;
    if (v11 < 0)
      v12 = *(_QWORD *)(result + 8);
    *(_QWORD *)a4 = v8;
    *(_QWORD *)(a4 + 8) = v12;
    goto LABEL_10;
  }
  if (v7 != 5)
  {
LABEL_11:
    v13 = 0;
    *(_BYTE *)a4 = 0;
    goto LABEL_12;
  }
  *(_OWORD *)a4 = *(_OWORD *)(result + 32);
LABEL_10:
  v13 = 1;
LABEL_12:
  *(_BYTE *)(a4 + 16) = v13;
  return result;
}

uint64_t llvm::json::Object::getObject(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = sub_1C5E11F9C(a1, a2, a3);
  if (*(_QWORD *)a1 + 56 * *(unsigned int *)(a1 + 16) == v4)
    return 0;
  if (*(_WORD *)(v4 + 24) == 7)
    return v4 + 32;
  return 0;
}

{
  int v4;
  uint64_t result;
  _QWORD v6[2];
  uint64_t v7;

  v6[0] = a2;
  v6[1] = a3;
  v7 = 0;
  v4 = sub_1C5E147B8((uint64_t *)a1, (uint64_t)v6, &v7);
  result = 0;
  if (v4 && v7 != *(_QWORD *)a1 + 56 * *(unsigned int *)(a1 + 16))
  {
    if (*(_WORD *)(v7 + 24) == 7)
      return v7 + 32;
    else
      return 0;
  }
  return result;
}

uint64_t llvm::json::Object::getArray(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = sub_1C5E11F9C(a1, a2, a3);
  if (*(_QWORD *)a1 + 56 * *(unsigned int *)(a1 + 16) == v4)
    return 0;
  if (*(_WORD *)(v4 + 24) == 8)
    return v4 + 32;
  return 0;
}

{
  int v4;
  uint64_t result;
  _QWORD v6[2];
  uint64_t v7;

  v6[0] = a2;
  v6[1] = a3;
  v7 = 0;
  v4 = sub_1C5E147B8((uint64_t *)a1, (uint64_t)v6, &v7);
  result = 0;
  if (v4 && v7 != *(_QWORD *)a1 + 56 * *(unsigned int *)(a1 + 16))
  {
    if (*(_WORD *)(v7 + 24) == 8)
      return v7 + 32;
    else
      return 0;
  }
  return result;
}

uint64_t llvm::json::operator==(uint64_t *a1, uint64_t a2)
{
  int v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t result;

  v2 = *((_DWORD *)a1 + 2);
  if (v2 != *(_DWORD *)(a2 + 8))
    return 0;
  if (v2)
  {
    v4 = *((unsigned int *)a1 + 4);
    if ((_DWORD)v4)
    {
      v5 = 56 * v4;
      for (i = *a1; *(_QWORD *)(i + 8) >= 0xFFFFFFFFFFFFFFFELL; i += 56)
      {
        v5 -= 56;
        if (!v5)
          return 1;
      }
    }
    else
    {
      i = *a1;
    }
    v7 = *a1 + 56 * v4;
    if (i != v7)
    {
      v8 = *(_QWORD *)(i + 8);
LABEL_11:
      v9 = sub_1C5E11F9C(a2, v8, *(_QWORD *)(i + 16));
      if (*(_QWORD *)a2 + 56 * *(unsigned int *)(a2 + 16) != v9)
      {
        result = llvm::json::operator==((__int16 *)(i + 24), (__int16 *)(v9 + 24));
        if (!(_DWORD)result)
          return result;
        while (1)
        {
          i += 56;
          if (i == v7)
            return 1;
          v8 = *(_QWORD *)(i + 8);
          if (v8 < 0xFFFFFFFFFFFFFFFELL)
          {
            result = 1;
            if (i != v7)
              goto LABEL_11;
            return result;
          }
        }
      }
      return 0;
    }
  }
  return 1;
}

__n128 llvm::json::Value::moveFrom(uint64_t a1, unsigned __int16 *a2, __n128 result)
{
  int v3;
  int v4;
  int v5;

  v3 = *a2;
  *(_WORD *)a1 = v3;
  switch(v3)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      result = *(__n128 *)(a2 + 4);
      *(_QWORD *)(a1 + 24) = *((_QWORD *)a2 + 3);
      goto LABEL_3;
    case 5:
      result = *(__n128 *)(a2 + 4);
LABEL_3:
      *(__n128 *)(a1 + 8) = result;
      return result;
    case 6:
      result = *(__n128 *)(a2 + 4);
      *(_QWORD *)(a1 + 24) = *((_QWORD *)a2 + 3);
      *(__n128 *)(a1 + 8) = result;
      *((_QWORD *)a2 + 2) = 0;
      *((_QWORD *)a2 + 3) = 0;
      *((_QWORD *)a2 + 1) = 0;
      goto LABEL_7;
    case 7:
      *(_QWORD *)(a1 + 8) = 0;
      *(_QWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 24) = 0;
      *(_QWORD *)(a1 + 8) = *((_QWORD *)a2 + 1);
      *((_QWORD *)a2 + 1) = 0;
      *(_DWORD *)(a1 + 16) = *((_DWORD *)a2 + 4);
      *((_DWORD *)a2 + 4) = 0;
      v4 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(a1 + 20) = *((_DWORD *)a2 + 5);
      *((_DWORD *)a2 + 5) = v4;
      v5 = *(_DWORD *)(a1 + 24);
      *(_DWORD *)(a1 + 24) = *((_DWORD *)a2 + 6);
      *((_DWORD *)a2 + 6) = v5;
LABEL_7:
      *a2 = 0;
      break;
    case 8:
      *(_QWORD *)(a1 + 8) = 0;
      *(_QWORD *)(a1 + 16) = 0;
      *(_QWORD *)(a1 + 24) = 0;
      result = *(__n128 *)(a2 + 4);
      *(__n128 *)(a1 + 8) = result;
      *(_QWORD *)(a1 + 24) = *((_QWORD *)a2 + 3);
      *a2 = 0;
      *((_QWORD *)a2 + 2) = 0;
      *((_QWORD *)a2 + 3) = 0;
      *((_QWORD *)a2 + 1) = 0;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t llvm::json::Value::Value(uint64_t a1, unsigned __int16 *a2, unint64_t a3)
{
  __int128 v5;
  uint64_t v6;
  void **v7;

  llvm::json::Array::Array((uint64_t)&v5, a2, a3);
  *(_WORD *)a1 = 8;
  *(_OWORD *)(a1 + 8) = v5;
  *(_QWORD *)(a1 + 24) = v6;
  v5 = 0uLL;
  v6 = 0;
  v7 = (void **)&v5;
  sub_1C4D66218(&v7);
  return a1;
}

{
  __int128 v5;
  uint64_t v6;
  void **v7;

  llvm::json::Array::Array((uint64_t)&v5, a2, a3);
  *(_WORD *)a1 = 8;
  *(_OWORD *)(a1 + 8) = v5;
  *(_QWORD *)(a1 + 24) = v6;
  v5 = 0uLL;
  v6 = 0;
  v7 = (void **)&v5;
  sub_1C4D66218(&v7);
  return a1;
}

_QWORD *llvm::json::Value::copyFrom(_QWORD *result, unsigned __int16 *a2)
{
  int v2;
  __int128 v3;
  __int128 v4;
  char *v5;
  _QWORD *v6;

  v2 = *a2;
  *(_WORD *)result = v2;
  switch(v2)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      v3 = *(_OWORD *)(a2 + 4);
      result[3] = *((_QWORD *)a2 + 3);
      goto LABEL_3;
    case 5:
      v3 = *(_OWORD *)(a2 + 4);
LABEL_3:
      *(_OWORD *)(result + 1) = v3;
      break;
    case 6:
      ++result;
      if (*((char *)a2 + 31) < 0)
      {
        result = sub_1C47EBC30(result, *((void **)a2 + 1), *((_QWORD *)a2 + 2));
      }
      else
      {
        v4 = *(_OWORD *)(a2 + 4);
        result[2] = *((_QWORD *)a2 + 3);
        *(_OWORD *)result = v4;
      }
      break;
    case 7:
      result[1] = 0;
      result[2] = 0;
      v5 = (char *)(result + 1);
      *((_DWORD *)v5 + 4) = 0;
      result = sub_1C5E167B0((uint64_t *)v5, (uint64_t)(a2 + 4));
      break;
    case 8:
      result[1] = 0;
      result[2] = 0;
      v6 = result + 1;
      v6[2] = 0;
      result = sub_1C5E168B0(v6, *((const llvm::json::Value **)a2 + 1), *((const llvm::json::Value **)a2 + 2), (uint64_t)(*((_QWORD *)a2 + 2) - *((_QWORD *)a2 + 1)) >> 5);
      break;
    default:
      return result;
  }
  return result;
}

void llvm::json::Value::destroy(void **this)
{
  int v1;
  void **v2;

  v1 = *(unsigned __int16 *)this;
  if (v1 == 8)
  {
    v2 = this + 1;
    sub_1C4D66218(&v2);
  }
  else
  {
    if (v1 == 7)
    {
      sub_1C4D65F7C(this + 1);
      JUMPOUT(0x1CAA32FB4);
    }
    if (v1 == 6 && *((char *)this + 31) < 0)
      operator delete(this[1]);
  }
}

uint64_t llvm::json::operator==(__int16 *a1, __int16 *a2)
{
  if (dword_1C866FF90[*a1] == dword_1C866FF90[*a2])
    __asm { BR              X12 }
  return 0;
}

__n128 llvm::json::Path::report(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  __n128 *v8;
  __n128 *v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  __n128 *v16;
  char *v17;
  __n128 result;
  char *v19;

  v3 = a1;
  LODWORD(v4) = -1;
  v5 = a1;
  do
  {
    v6 = v5;
    v5 = (_QWORD *)*v5;
    v4 = (v4 + 1);
  }
  while (v5);
  v7 = v6[1];
  *(_QWORD *)(v7 + 16) = a2;
  *(_QWORD *)(v7 + 24) = a3;
  v9 = *(__n128 **)(v7 + 32);
  v8 = *(__n128 **)(v7 + 40);
  v10 = v8 - v9;
  if (v4 <= v10)
  {
    if (v4 < v10)
      *(_QWORD *)(v7 + 40) = &v9[v4];
  }
  else
  {
    v11 = v4 - v10;
    v12 = *(_QWORD *)(v7 + 48);
    if (v4 - v10 <= (v12 - (uint64_t)v8) >> 4)
    {
      bzero(*(void **)(v7 + 40), 16 * v11);
      *(_QWORD *)(v7 + 40) = &v8[v11];
    }
    else
    {
      v13 = v12 - (_QWORD)v9;
      if (v13 >> 3 > v4)
        v4 = v13 >> 3;
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF0)
        v14 = 0xFFFFFFFFFFFFFFFLL;
      else
        v14 = v4;
      if (v14 >> 60)
        sub_1C4764EE4();
      v15 = (char *)operator new(16 * v14);
      v16 = (__n128 *)&v15[16 * v10];
      v17 = &v15[16 * v14];
      bzero(v16, 16 * v11);
      v19 = &v15[16 * v11 + (char *)v8 - (char *)v9];
      if (v8 != v9)
      {
        do
        {
          result = v8[-1];
          v16[-1] = result;
          --v16;
          --v8;
        }
        while (v8 != v9);
        v8 = *(__n128 **)(v7 + 32);
      }
      *(_QWORD *)(v7 + 32) = v16;
      *(_QWORD *)(v7 + 40) = v19;
      *(_QWORD *)(v7 + 48) = v17;
      if (v8)
        operator delete(v8);
    }
    v9 = *(__n128 **)(v7 + 32);
  }
  while (*v3)
  {
    result = *(__n128 *)(v3 + 1);
    *v9++ = result;
    v3 = (_QWORD *)*v3;
  }
  return result;
}

void llvm::json::Path::Root::getError(llvm::json::Path::Root *this@<X0>, _QWORD *a2@<X8>)
{
  size_t v4;
  const char *v5;
  llvm::raw_ostream *v6;
  size_t v7;
  const char *v8;
  void *v9;
  _QWORD *v10;
  _DWORD *v11;
  llvm::raw_ostream *v12;
  char *v13;
  _QWORD *v14;
  const void *v15;
  size_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _BYTE *v21;
  const void *v22;
  unint64_t v23;
  _BYTE *v24;
  uint64_t v26;
  void **v27;
  void **v28;
  __int16 v29;
  void (**v30)(llvm::raw_ostream *__hidden);
  int v31;
  uint64_t v32;
  unint64_t v33;
  _DWORD *v34;
  char v35;
  uint64_t v36;
  int v37;
  void **v38;
  void *__p[2];
  uint64_t v40;
  void *v41[2];
  char v42;
  void **v43;
  uint64_t v44[2];

  __p[0] = 0;
  __p[1] = 0;
  v40 = 0;
  v31 = 0;
  v35 = 0;
  v36 = 0;
  v30 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
  v38 = __p;
  v37 = 0;
  v33 = 0;
  v34 = 0;
  v32 = 0;
  v4 = *((_QWORD *)this + 3);
  if (v4)
  {
    v5 = (const char *)*((_QWORD *)this + 2);
  }
  else
  {
    v5 = "invalid JSON contents";
    v4 = 21;
  }
  llvm::raw_ostream::write((llvm::raw_ostream *)&v30, v5, v4);
  if (*((_QWORD *)this + 4) != *((_QWORD *)this + 5))
  {
    if (v33 - (unint64_t)v34 > 3)
    {
      *v34++ = 544497952;
      v6 = (llvm::raw_ostream *)&v30;
    }
    else
    {
      v6 = llvm::raw_ostream::write((llvm::raw_ostream *)&v30, " at ", 4uLL);
    }
    v7 = *((_QWORD *)this + 1);
    if (v7)
    {
      v8 = *(const char **)this;
      v10 = (_QWORD *)((char *)v6 + 32);
      v9 = (void *)*((_QWORD *)v6 + 4);
      if (v7 > *((_QWORD *)v6 + 3) - (_QWORD)v9)
      {
LABEL_9:
        llvm::raw_ostream::write(v6, v8, v7);
        goto LABEL_17;
      }
    }
    else
    {
      v10 = (_QWORD *)((char *)v6 + 32);
      v9 = (void *)*((_QWORD *)v6 + 4);
      v8 = "(root)";
      v7 = 6;
      if (*((_QWORD *)v6 + 3) - (_QWORD)v9 <= 5uLL)
        goto LABEL_9;
    }
    memcpy(v9, v8, v7);
    *v10 += v7;
LABEL_17:
    v17 = *((_QWORD *)this + 4);
    v18 = *((_QWORD *)this + 5);
    if (v18 != v17)
    {
      v19 = *((_QWORD *)this + 5);
      do
      {
        v20 = *(_QWORD *)(v19 - 16);
        v19 -= 16;
        v21 = v34;
        if (v20)
        {
          if ((unint64_t)v34 >= v33)
          {
            llvm::raw_ostream::write((llvm::raw_ostream *)&v30, 46);
          }
          else
          {
            v34 = (_DWORD *)((char *)v34 + 1);
            *v21 = 46;
          }
          v22 = *(const void **)(v18 - 16);
          v23 = *(unsigned int *)(v18 - 8);
          if (v33 - (unint64_t)v34 >= v23)
          {
            if ((_DWORD)v23)
            {
              memcpy(v34, v22, *(unsigned int *)(v18 - 8));
              v34 = (_DWORD *)((char *)v34 + v23);
            }
          }
          else
          {
            llvm::raw_ostream::write((llvm::raw_ostream *)&v30, (const char *)v22, *(unsigned int *)(v18 - 8));
          }
        }
        else
        {
          if ((unint64_t)v34 >= v33)
          {
            llvm::raw_ostream::write((llvm::raw_ostream *)&v30, 91);
          }
          else
          {
            v34 = (_DWORD *)((char *)v34 + 1);
            *v21 = 91;
          }
          sub_1C5E21910((llvm::raw_ostream *)&v30, *(unsigned int *)(v18 - 8), 0, 0, 0);
          v24 = v34;
          if ((unint64_t)v34 >= v33)
          {
            llvm::raw_ostream::write((llvm::raw_ostream *)&v30, 93);
          }
          else
          {
            v34 = (_DWORD *)((char *)v34 + 1);
            *v24 = 93;
          }
        }
        v18 = v19;
      }
      while (v19 != v17);
    }
    goto LABEL_34;
  }
  if (*((_QWORD *)this + 1))
  {
    v11 = v34;
    if (v33 - (unint64_t)v34 > 0xD)
    {
      v14 = &v34;
      *(_QWORD *)v34 = *(_QWORD *)" when parsing ";
      *(_QWORD *)((char *)v11 + 6) = *(_QWORD *)"parsing ";
      v13 = (char *)v34 + 14;
      v34 = (_DWORD *)((char *)v34 + 14);
      v12 = (llvm::raw_ostream *)&v30;
    }
    else
    {
      v12 = llvm::raw_ostream::write((llvm::raw_ostream *)&v30, " when parsing ", 0xEuLL);
      v14 = (_QWORD *)((char *)v12 + 32);
      v13 = (char *)*((_QWORD *)v12 + 4);
    }
    v15 = *(const void **)this;
    v16 = *((_QWORD *)this + 1);
    if (v16 <= *((_QWORD *)v12 + 3) - (_QWORD)v13)
    {
      if (v16)
      {
        memcpy(v13, v15, v16);
        *v14 += v16;
      }
    }
    else
    {
      llvm::raw_ostream::write(v12, (const char *)v15, v16);
    }
  }
LABEL_34:
  if (!atomic_load(qword_1ED836B58))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED836B58, (void *(*)(void))sub_1C5DF15F0, (void (*)(void *))sub_1C5DF1624);
  v26 = qword_1ED836B58[0];
  v29 = 260;
  v28 = v38;
  llvm::Twine::str((llvm::Twine *)&v28, v41);
  if (v42 >= 0)
    v27 = v41;
  else
    v27 = (void **)v41[0];
  v44[0] = 3;
  v44[1] = v26;
  v43 = v27;
  sub_1C5DF1730((_BYTE **)&v43, v44, a2);
  if (v42 < 0)
    operator delete(v41[0]);
  v30 = off_1E81A6E70;
  if (v37 == 1 && v32)
    MEMORY[0x1CAA32F9C](v32, 0x1000C8077774924);
  if (SHIBYTE(v40) < 0)
    operator delete(__p[0]);
}

void llvm::json::Path::Root::printErrorContext(llvm::json::Path::Root *this, const llvm::json::Value *a2, llvm::raw_ostream *a3)
{
  uint64_t v3[2];
  void *v4[2];
  _QWORD v5[20];
  char v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v3[1] = (uint64_t)v4;
  v4[0] = v5;
  v5[17] = 0;
  v5[18] = a3;
  v5[19] = 2;
  v6 = 0;
  v5[16] = 0;
  v5[0] = 0;
  v4[1] = (void *)0x1000000001;
  v3[0] = (uint64_t)this;
  sub_1C5E12F60(v3, (uint64_t)a2, *((_QWORD *)this + 4), (uint64_t)(*((_QWORD *)this + 5) - *((_QWORD *)this + 4)) >> 4, (uint64_t)v3);
  if (v4[0] != v5)
    free(v4[0]);
}

void sub_1C5E12F60(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  llvm::json::OStream *v5;
  uint64_t v9;
  const void *v10;
  uint64_t *v11;
  size_t v13;
  llvm::json::OStream *v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  _DWORD *v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25[3];
  uint64_t *v26;
  uint64_t *v27;

  v5 = (llvm::json::OStream *)a1[1];
  v25[0] = *a1;
  v25[1] = (uint64_t)v5;
  v25[2] = a2;
  if (!a4)
    goto LABEL_18;
  v9 = a4 - 1;
  v10 = *(const void **)(a3 + 16 * (a4 - 1));
  if (v10)
  {
    v11 = (uint64_t *)(a2 + 8);
    if (*(_WORD *)a2 == 7)
    {
      v13 = *(unsigned int *)(a3 + 16 * v9 + 8);
      if (*(_QWORD *)(a2 + 8) + 56 * *(unsigned int *)(a2 + 24) != sub_1C5E11F9C(a2 + 8, (uint64_t)v10, v13))
      {
        v14 = (llvm::json::OStream *)a1[1];
        llvm::json::OStream::objectBegin(v14);
        sub_1C5E14C84(&v26, v11);
        v15 = v26;
        v16 = v27;
        if (v26 != v27)
        {
          v17 = v26;
          do
          {
            v18 = *v17;
            llvm::json::OStream::attributeBegin((uint64_t)v14, *(char **)(*v17 + 8), *(_QWORD *)(*v17 + 16));
            if (*(_QWORD *)(v18 + 16) == v13 && (!(_DWORD)v13 || !memcmp(v10, *(const void **)(v18 + 8), v13)))
              sub_1C5E12F60(a5, v18 + 24, a3, v9, a5);
            else
              sub_1C5E14A3C(v18 + 24);
            --*((_DWORD *)v14 + 2);
            ++v17;
          }
          while (v17 != v16);
        }
        if (v15)
          operator delete(v15);
        llvm::json::OStream::objectEnd(v14);
        return;
      }
    }
LABEL_18:
    sub_1C5E148CC(v25);
    return;
  }
  if (*(_WORD *)a2 != 8)
    goto LABEL_18;
  v19 = a3 + 16 * v9;
  v21 = *(_DWORD *)(v19 + 8);
  v20 = (_DWORD *)(v19 + 8);
  if (v21 >= (unint64_t)((uint64_t)(*(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8)) >> 5))
    goto LABEL_18;
  llvm::json::OStream::arrayBegin(v5);
  v22 = *(_QWORD *)(a2 + 8);
  v23 = *(_QWORD *)(a2 + 16);
  if (v22 != v23)
  {
    v24 = 0;
    do
    {
      if (v24 == *v20)
        sub_1C5E12F60(a5, v22, a3, v9, a5);
      else
        sub_1C5E14A3C(v22);
      v22 += 32;
      ++v24;
    }
    while (v22 != v23);
  }
  llvm::json::OStream::arrayEnd(v5);
}

void llvm::json::parse(unsigned __int8 *a1@<X0>, uint64_t a2@<X1>, const unsigned __int8 *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5;
  __n128 v6;
  unsigned __int8 *v7;
  unsigned int v8;
  BOOL v9;
  uint64_t v10;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  char v15;
  unsigned __int8 *v16;
  unsigned __int8 *v17;
  unsigned __int8 *v18;
  unsigned __int8 *v19;
  void *v20[5];

  v20[4] = *(void **)MEMORY[0x1E0C80C00];
  LOBYTE(v14) = 0;
  v15 = 0;
  v16 = a1;
  v17 = a1;
  v18 = &a1[a2];
  LOWORD(v20[0]) = 0;
  if (a2)
  {
    v5 = 0;
    while (((char)a1[v5] & 0x80000000) == 0)
    {
      if (a2 == ++v5)
        goto LABEL_7;
    }
    v19 = a1;
    if (!llvm::isLegalUTF8String(&v19, (const unsigned __int8 **)&a1[a2], a3))
    {
      v17 = v19;
      v12 = "Invalid UTF-8 sequence";
LABEL_16:
      sub_1C5E160FC((uint64_t)&v14, (uint64_t)v12);
      goto LABEL_17;
    }
  }
LABEL_7:
  if (sub_1C5E132F0((uint64_t)&v14, v20))
  {
    v7 = v17;
    if (v17 == v18)
    {
LABEL_14:
      *(_BYTE *)(a4 + 32) &= ~1u;
      llvm::json::Value::moveFrom(a4, (unsigned __int16 *)v20, v6);
      goto LABEL_18;
    }
    while (1)
    {
      v8 = *v7;
      v9 = v8 > 0x20;
      v10 = (1 << v8) & 0x100002600;
      if (v9 || v10 == 0)
        break;
      v17 = ++v7;
      if (v7 == v18)
        goto LABEL_14;
    }
    v12 = "Text after end of document";
    goto LABEL_16;
  }
LABEL_17:
  v13 = v14;
  v14 = 0;
  *(_BYTE *)(a4 + 32) |= 1u;
  *(_QWORD *)a4 = v13;
LABEL_18:
  llvm::json::Value::destroy(v20);
  if (v15)
  {
    if (v14)
      (*(void (**)(uint64_t))(*(_QWORD *)v14 + 8))(v14);
  }
}

uint64_t sub_1C5E132F0(uint64_t a1, void **a2)
{
  char v2;
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  unsigned int v7;
  BOOL v8;
  uint64_t v9;
  const char *v11;
  unsigned __int8 *v13;
  int v14;
  __n128 v15;
  _BYTE *v16;
  _BYTE *v17;
  __n128 v18;
  _BYTE *v19;
  _BYTE *v20;
  int v21;
  __n128 v22;
  __n128 v23;
  __n128 v24;
  void **v25;
  int v26;
  unsigned __int8 *v27;
  unsigned __int8 *v28;
  unsigned int v29;
  __n128 v31;
  uint64_t v32;
  int v33;
  unsigned __int8 *v34;
  unsigned int v35;
  __n128 v37;
  _BYTE *v38;
  _BYTE *v39;
  BOOL v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  unsigned int v44;
  uint64_t v45;
  char v47;
  unint64_t v48;
  std::string::size_type v49;
  char *v50;
  uint64_t v51;
  double v52;
  __n128 v53;
  __n128 v54;
  _WORD *v55;
  unsigned __int16 *v56;
  int v57;
  unsigned __int8 *v58;
  unsigned __int8 *v59;
  unsigned int v60;
  uint64_t v61;
  unsigned __int8 *v63;
  int v64;
  unsigned int v65;
  uint64_t v66;
  _BYTE *v68;
  unsigned __int8 *v69;
  unsigned __int8 *v70;
  unsigned int v71;
  uint64_t v72;
  const char *v74;
  int v75;
  unsigned __int8 *v76;
  unsigned int v77;
  uint64_t v78;
  char *v80;
  unsigned __int8 *v81;
  unsigned __int8 *v82;
  unsigned int v83;
  uint64_t v84;
  unsigned __int8 *v86;
  int v87;
  unsigned int v88;
  uint64_t v89;
  char *v91;
  std::string v92;
  char *__endptr[3];
  std::string __p;
  std::string v95;
  char *__str;
  __int128 v97;
  _QWORD v98[4];

  v98[3] = *MEMORY[0x1E0C80C00];
  v5 = *(unsigned __int8 **)(a1 + 24);
  v4 = *(unsigned __int8 **)(a1 + 32);
  if (v5 == v4)
  {
LABEL_7:
    v11 = "Unexpected EOF";
LABEL_8:
    sub_1C5E160FC(a1, (uint64_t)v11);
    v2 = 0;
    return v2 & 1;
  }
  while (1)
  {
    v7 = *v5;
    v8 = v7 > 0x20;
    v9 = (1 << v7) & 0x100002600;
    if (v8 || v9 == 0)
      break;
    *(_QWORD *)(a1 + 24) = ++v5;
    if (v5 == v4)
      goto LABEL_7;
  }
  v13 = v5 + 1;
  *(_QWORD *)(a1 + 24) = v5 + 1;
  v14 = (char)*v5;
  if (v14 <= 109)
  {
    if (v14 == 34)
    {
      memset(&v95, 0, sizeof(v95));
      v21 = sub_1C5E161C8(a1, &v95);
      v2 = v21;
      if (v21)
      {
        __p = v95;
        memset(&v95, 0, sizeof(v95));
        sub_1C4D673F4((uint64_t)&__str, (unint64_t)&__p);
        llvm::json::Value::destroy(a2);
        llvm::json::Value::moveFrom((uint64_t)a2, (unsigned __int16 *)&__str, v22);
        llvm::json::Value::destroy((void **)&__str);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v95.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v95.__r_.__value_.__l.__data_);
      return v2 & 1;
    }
    if (v14 != 91)
    {
      if (v14 == 102)
      {
        LOWORD(__str) = 1;
        LOBYTE(v97) = 0;
        llvm::json::Value::destroy(a2);
        llvm::json::Value::moveFrom((uint64_t)a2, (unsigned __int16 *)&__str, v15);
        llvm::json::Value::destroy((void **)&__str);
        v16 = *(_BYTE **)(a1 + 24);
        v17 = *(_BYTE **)(a1 + 32);
        if (v16 == v17
          || (*(_QWORD *)(a1 + 24) = v16 + 1, *v16 != 97)
          || v16 + 1 == v17
          || (*(_QWORD *)(a1 + 24) = v16 + 2, v16[1] != 108)
          || v16 + 2 == v17
          || (*(_QWORD *)(a1 + 24) = v16 + 3, v16[2] != 115)
          || v16 + 3 == v17
          || (*(_QWORD *)(a1 + 24) = v16 + 4, v16[3] != 101))
        {
          v11 = "Invalid JSON value (false?)";
          goto LABEL_8;
        }
LABEL_114:
        v2 = 1;
        return v2 & 1;
      }
      goto LABEL_63;
    }
    LOWORD(__str) = 8;
    v98[0] = 0;
    v97 = 0uLL;
    memset(&v95, 0, sizeof(v95));
    llvm::json::Value::destroy(a2);
    llvm::json::Value::moveFrom((uint64_t)a2, (unsigned __int16 *)&__str, v23);
    llvm::json::Value::destroy((void **)&__str);
    __endptr[0] = (char *)&v95;
    sub_1C4D66218((void ***)__endptr);
    v26 = *(unsigned __int16 *)a2;
    v25 = a2 + 1;
    if (v26 != 8)
      v25 = 0;
    v27 = *(unsigned __int8 **)(a1 + 24);
    v28 = *(unsigned __int8 **)(a1 + 32);
    if (v27 == v28)
    {
LABEL_93:
      while (1)
      {
        __str = 0;
        v55 = v25[1];
        if (v55 >= v25[2])
        {
          v56 = sub_1C5E166B4((unsigned __int16 **)v25, v24);
        }
        else
        {
          *v55 = 0;
          v56 = v55 + 16;
        }
        v25[1] = v56;
        v57 = sub_1C5E132F0(a1, v56 - 16);
        v2 = v57;
        if (!v57)
          return v2 & 1;
        v59 = *(unsigned __int8 **)(a1 + 24);
        v58 = *(unsigned __int8 **)(a1 + 32);
        if (v59 == v58)
          goto LABEL_169;
        while (1)
        {
          v60 = *v59;
          v8 = v60 > 0x20;
          v61 = (1 << v60) & 0x100002600;
          if (v8 || v61 == 0)
            break;
          *(_QWORD *)(a1 + 24) = ++v59;
          if (v59 == v58)
            goto LABEL_169;
        }
        v63 = v59 + 1;
        *(_QWORD *)(a1 + 24) = v59 + 1;
        v64 = (char)*v59;
        if (v64 != 44)
        {
          if (v64 == 93)
            return v2 & 1;
LABEL_169:
          v11 = "Expected , or ] after array element";
          goto LABEL_8;
        }
        for (; v63 != v58; *(_QWORD *)(a1 + 24) = v63)
        {
          v65 = *v63;
          v8 = v65 > 0x20;
          v66 = (1 << v65) & 0x100002600;
          if (v8 || v66 == 0)
            break;
          ++v63;
        }
      }
    }
    while (1)
    {
      v29 = *v27;
      if (v29 > 0x20 || ((1 << v29) & 0x100002600) == 0)
        break;
      *(_QWORD *)(a1 + 24) = ++v27;
      if (v27 == v28)
        goto LABEL_93;
    }
    if (v29 != 93)
      goto LABEL_93;
    goto LABEL_113;
  }
  if (v14 != 123)
  {
    if (v14 == 116)
    {
      LOWORD(__str) = 1;
      LOBYTE(v97) = 1;
      llvm::json::Value::destroy(a2);
      llvm::json::Value::moveFrom((uint64_t)a2, (unsigned __int16 *)&__str, v37);
      llvm::json::Value::destroy((void **)&__str);
      v38 = *(_BYTE **)(a1 + 24);
      v39 = *(_BYTE **)(a1 + 32);
      if (v38 == v39
        || ((*(_QWORD *)(a1 + 24) = v38 + 1, *v38 == 114) ? (v40 = v38 + 1 == v39) : (v40 = 1),
            v40
         || (*(_QWORD *)(a1 + 24) = v38 + 2, v38[1] != 117)
         || v38 + 2 == v39
         || (*(_QWORD *)(a1 + 24) = v38 + 3, v38[2] != 101)))
      {
        v11 = "Invalid JSON value (true?)";
        goto LABEL_8;
      }
      goto LABEL_114;
    }
    if (v14 == 110)
    {
      LOWORD(__str) = 0;
      llvm::json::Value::destroy(a2);
      llvm::json::Value::moveFrom((uint64_t)a2, (unsigned __int16 *)&__str, v18);
      llvm::json::Value::destroy((void **)&__str);
      v19 = *(_BYTE **)(a1 + 24);
      v20 = *(_BYTE **)(a1 + 32);
      if (v19 == v20
        || (*(_QWORD *)(a1 + 24) = v19 + 1, *v19 != 117)
        || v19 + 1 == v20
        || (*(_QWORD *)(a1 + 24) = v19 + 2, v19[1] != 108)
        || v19 + 2 == v20
        || (*(_QWORD *)(a1 + 24) = v19 + 3, v19[2] != 108))
      {
        v11 = "Invalid JSON value (null?)";
        goto LABEL_8;
      }
      goto LABEL_114;
    }
LABEL_63:
    if (v14 - 43 > 0x3A
      || ((1 << (v14 - 43)) & 0x400000004007FEDLL) == 0)
    {
      v11 = "Invalid JSON value";
      goto LABEL_8;
    }
    __str = (char *)v98;
    LOBYTE(v98[0]) = v14;
    v97 = xmmword_1C866FFC0;
    if (v13 == v4)
    {
      v41 = 0;
      v48 = 24;
      v42 = 1;
    }
    else
    {
      v41 = 0;
      v42 = 1;
      do
      {
        v43 = *v13;
        if ((v43 - 48) >= 0xA)
        {
          v44 = v43 - 43;
          v8 = v44 > 0x3A;
          v45 = (1 << v44) & 0x40000000400000DLL;
          if (v8 || v45 == 0)
            break;
        }
        *(_QWORD *)(a1 + 24) = v13 + 1;
        v47 = *v13;
        if ((unint64_t)(v41 + 2) > *((_QWORD *)&v97 + 1))
        {
          llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&__str, v98, v41 + 2, 1);
          v42 = v97;
        }
        __str[v42] = v47;
        v41 = v97;
        v42 = v97 + 1;
        *(_QWORD *)&v97 = v97 + 1;
        v13 = *(unsigned __int8 **)(a1 + 24);
      }
      while (v13 != *(unsigned __int8 **)(a1 + 32));
      v48 = *((_QWORD *)&v97 + 1);
    }
    __endptr[0] = 0;
    if (v41 + 2 > v48)
    {
      llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&__str, v98, v41 + 2, 1);
      v42 = v97;
    }
    __str[v42] = 0;
    v49 = strtoll(__str, __endptr, 10);
    v50 = __str;
    v51 = v97;
    if (__endptr[0] == &__str[(_QWORD)v97])
    {
      LOWORD(v95.__r_.__value_.__l.__data_) = 3;
      v95.__r_.__value_.__l.__size_ = v49;
      llvm::json::Value::destroy(a2);
      llvm::json::Value::moveFrom((uint64_t)a2, (unsigned __int16 *)&v95, v54);
      llvm::json::Value::destroy((void **)&v95.__r_.__value_.__l.__data_);
    }
    else
    {
      if ((unint64_t)(v97 + 1) > *((_QWORD *)&v97 + 1))
      {
        llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&__str, v98, v97 + 1, 1);
        v50 = __str;
        v51 = v97;
      }
      v50[v51] = 0;
      v52 = strtod(__str, __endptr);
      LOWORD(v95.__r_.__value_.__l.__data_) = 2;
      *(double *)&v95.__r_.__value_.__l.__size_ = v52;
      llvm::json::Value::destroy(a2);
      llvm::json::Value::moveFrom((uint64_t)a2, (unsigned __int16 *)&v95, v53);
      llvm::json::Value::destroy((void **)&v95.__r_.__value_.__l.__data_);
      if (__endptr[0] != &__str[(_QWORD)v97])
      {
        sub_1C5E160FC(a1, (uint64_t)"Invalid JSON value (number?)");
        v2 = 0;
        goto LABEL_86;
      }
    }
    v2 = 1;
LABEL_86:
    if (__str != (char *)v98)
      free(__str);
    return v2 & 1;
  }
  LOWORD(__str) = 7;
  v97 = 0uLL;
  memset(&v95, 0, sizeof(v95));
  LODWORD(v98[0]) = 0;
  llvm::json::Value::destroy(a2);
  llvm::json::Value::moveFrom((uint64_t)a2, (unsigned __int16 *)&__str, v31);
  llvm::json::Value::destroy((void **)&__str);
  sub_1C4D65F7C((uint64_t *)&v95);
  MEMORY[0x1CAA32FB4](v95.__r_.__value_.__r.__words[0], 8);
  v33 = *(unsigned __int16 *)a2;
  v32 = (uint64_t)(a2 + 1);
  if (v33 != 7)
    v32 = 0;
  v27 = *(unsigned __int8 **)(a1 + 24);
  v34 = *(unsigned __int8 **)(a1 + 32);
  if (v27 != v34)
  {
    while (1)
    {
      v35 = *v27;
      if (v35 > 0x20 || ((1 << v35) & 0x100002600) == 0)
        break;
      *(_QWORD *)(a1 + 24) = ++v27;
      if (v27 == v34)
        goto LABEL_115;
    }
    if (v35 == 125)
    {
LABEL_113:
      *(_QWORD *)(a1 + 24) = v27 + 1;
      goto LABEL_114;
    }
  }
  do
  {
LABEL_115:
    v68 = *(_BYTE **)(a1 + 24);
    if (v68 == *(_BYTE **)(a1 + 32) || (*(_QWORD *)(a1 + 24) = v68 + 1, *v68 != 34))
    {
      v11 = "Expected object key";
      goto LABEL_8;
    }
    memset(&v95, 0, sizeof(v95));
    if (!sub_1C5E161C8(a1, &v95))
    {
LABEL_127:
      LOBYTE(v75) = 0;
LABEL_128:
      v2 = 0;
      goto LABEL_129;
    }
    v70 = *(unsigned __int8 **)(a1 + 24);
    v69 = *(unsigned __int8 **)(a1 + 32);
    while (1)
    {
      if (v70 == v69)
      {
        v74 = "Expected : after object key";
LABEL_126:
        sub_1C5E160FC(a1, (uint64_t)v74);
        goto LABEL_127;
      }
      v71 = *v70;
      v8 = v71 > 0x20;
      v72 = (1 << v71) & 0x100002600;
      if (v8 || v72 == 0)
        break;
      *(_QWORD *)(a1 + 24) = ++v70;
    }
    v76 = v70 + 1;
    *(_QWORD *)(a1 + 24) = v70 + 1;
    v74 = "Expected : after object key";
    if (*v70 != 58)
      goto LABEL_126;
    while (v76 != v69)
    {
      v77 = *v76;
      v8 = v77 > 0x20;
      v78 = (1 << v77) & 0x100002600;
      if (v8 || v78 == 0)
        break;
      *(_QWORD *)(a1 + 24) = ++v76;
    }
    v92 = v95;
    memset(&v95, 0, sizeof(v95));
    sub_1C4D65688((unint64_t *)__endptr, (uint64_t)&v92);
    sub_1C638C378((uint64_t)&__str, v32, (uint64_t)__endptr);
    v75 = sub_1C5E132F0(a1, __str + 24);
    v80 = __endptr[0];
    __endptr[0] = 0;
    if (v80)
    {
      if (v80[23] < 0)
      {
        v91 = v80;
        operator delete(*(void **)v80);
        v80 = v91;
      }
      MEMORY[0x1CAA32FC0](v80, 0x1012C40EC159624);
    }
    if (SHIBYTE(v92.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v92.__r_.__value_.__l.__data_);
    if (!v75)
      goto LABEL_128;
    v82 = *(unsigned __int8 **)(a1 + 24);
    v81 = *(unsigned __int8 **)(a1 + 32);
    if (v82 == v81)
    {
      v74 = "Expected , or } after object property";
      goto LABEL_126;
    }
    while (1)
    {
      v83 = *v82;
      v8 = v83 > 0x20;
      v84 = (1 << v83) & 0x100002600;
      if (v8 || v84 == 0)
        break;
      *(_QWORD *)(a1 + 24) = ++v82;
      v74 = "Expected , or } after object property";
      if (v82 == v81)
        goto LABEL_126;
    }
    v86 = v82 + 1;
    *(_QWORD *)(a1 + 24) = v82 + 1;
    v87 = (char)*v82;
    if (v87 == 125)
    {
      LOBYTE(v75) = 0;
      v2 = 1;
      goto LABEL_129;
    }
    v74 = "Expected , or } after object property";
    if (v87 != 44)
      goto LABEL_126;
    if (v86 != v81)
    {
      while (1)
      {
        v88 = *v86;
        v8 = v88 > 0x20;
        v89 = (1 << v88) & 0x100002600;
        if (v8 || v89 == 0)
          break;
        *(_QWORD *)(a1 + 24) = ++v86;
        LOBYTE(v75) = 1;
        if (v86 == v81)
          goto LABEL_129;
      }
    }
    LOBYTE(v75) = 1;
LABEL_129:
    if (SHIBYTE(v95.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v95.__r_.__value_.__l.__data_);
  }
  while ((v75 & 1) != 0);
  return v2 & 1;
}

BOOL llvm::json::isUTF8(unsigned __int8 *a1, uint64_t a2, unsigned __int8 *a3)
{
  uint64_t v6;
  const unsigned __int8 **v7;
  _BOOL8 result;
  _BOOL4 isLegalUTF8String;
  unsigned __int8 *v10;

  if (!a2)
    return 1;
  v6 = 0;
  v7 = (const unsigned __int8 **)&a1[a2];
  while (((char)a1[v6] & 0x80000000) == 0)
  {
    if (a2 == ++v6)
      return 1;
  }
  v10 = a1;
  isLegalUTF8String = llvm::isLegalUTF8String(&v10, v7, a3);
  result = isLegalUTF8String;
  if (!isLegalUTF8String)
  {
    if (a3)
      *(_QWORD *)a3 = v10 - a1;
  }
  return result;
}

void llvm::json::OStream::value(uint64_t a1, uint64_t a2)
{
  __asm { BR              X10 }
}

llvm::raw_ostream *sub_1C5E13DA4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56)
{
  llvm::raw_ostream **v56;
  unsigned __int16 *v57;
  int v58;
  llvm::raw_ostream *v59;
  unint64_t v60;
  llvm::raw_ostream *v62;
  double v63;
  _QWORD v64[2];
  int v65;
  double v66;

  llvm::json::OStream::valueBegin((llvm::json::OStream *)v56);
  v58 = *v57;
  if (v58 == 4)
    return sub_1C5E21910(v56[20], *((_QWORD *)v57 + 1), 0, 0, 0);
  if (v58 == 3)
  {
    v59 = v56[20];
    v60 = sub_1C5DD5A44(v57);
    return llvm::raw_ostream::operator<<(v59, v60);
  }
  else
  {
    v62 = v56[20];
    v63 = *((double *)v57 + 1);
    if (v58 != 2)
      v63 = 0.0;
    v64[0] = &unk_1E81A16E8;
    v64[1] = "%.*g";
    v65 = 17;
    v66 = v63;
    return llvm::raw_ostream::operator<<(v62, (uint64_t)v64);
  }
}

llvm::raw_ostream *sub_1C5E14078(llvm::raw_ostream *this, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v3;
  llvm::raw_ostream *v5;
  _BYTE *v6;
  unint64_t v7;
  _BYTE *v8;
  _BYTE *v9;
  _BYTE *v10;
  llvm::raw_ostream *v11;
  char v12;
  _BYTE *v13;
  _BYTE *v14;
  _BYTE *v15;
  _BYTE *v16;
  _BYTE *v17;

  v3 = a3;
  v5 = this;
  v6 = (_BYTE *)*((_QWORD *)this + 4);
  if ((unint64_t)v6 < *((_QWORD *)this + 3))
  {
    *((_QWORD *)this + 4) = v6 + 1;
    *v6 = 34;
    if (!a3)
      goto LABEL_36;
    while (1)
    {
LABEL_5:
      v7 = *a2;
      if ((_DWORD)v7 == 92 || (_DWORD)v7 == 34)
      {
        v8 = (_BYTE *)*((_QWORD *)v5 + 4);
        if ((unint64_t)v8 >= *((_QWORD *)v5 + 3))
        {
          this = llvm::raw_ostream::write(v5, 92);
        }
        else
        {
          *((_QWORD *)v5 + 4) = v8 + 1;
          *v8 = 92;
        }
      }
      else if (v7 < 0x20)
      {
        v9 = (_BYTE *)*((_QWORD *)v5 + 4);
        if ((unint64_t)v9 >= *((_QWORD *)v5 + 3))
        {
          this = llvm::raw_ostream::write(v5, 92);
        }
        else
        {
          *((_QWORD *)v5 + 4) = v9 + 1;
          *v9 = 92;
        }
        switch((_DWORD)v7)
        {
          case 0xD:
            v14 = (_BYTE *)*((_QWORD *)v5 + 4);
            if ((unint64_t)v14 < *((_QWORD *)v5 + 3))
            {
              *((_QWORD *)v5 + 4) = v14 + 1;
              *v14 = 114;
              goto LABEL_17;
            }
            v11 = v5;
            v12 = 114;
            break;
          case 0xA:
            v15 = (_BYTE *)*((_QWORD *)v5 + 4);
            if ((unint64_t)v15 < *((_QWORD *)v5 + 3))
            {
              *((_QWORD *)v5 + 4) = v15 + 1;
              *v15 = 110;
              goto LABEL_17;
            }
            v11 = v5;
            v12 = 110;
            break;
          case 9:
            v13 = (_BYTE *)*((_QWORD *)v5 + 4);
            if ((unint64_t)v13 < *((_QWORD *)v5 + 3))
            {
              *((_QWORD *)v5 + 4) = v13 + 1;
              *v13 = 116;
              goto LABEL_17;
            }
            v11 = v5;
            v12 = 116;
            break;
          default:
            v16 = (_BYTE *)*((_QWORD *)v5 + 4);
            if ((unint64_t)v16 >= *((_QWORD *)v5 + 3))
            {
              llvm::raw_ostream::write(v5, 117);
            }
            else
            {
              *((_QWORD *)v5 + 4) = v16 + 1;
              *v16 = 117;
            }
            this = llvm::write_hex(v5, v7, 1, 4uLL, 1);
            goto LABEL_17;
        }
        goto LABEL_16;
      }
      v10 = (_BYTE *)*((_QWORD *)v5 + 4);
      if ((unint64_t)v10 >= *((_QWORD *)v5 + 3))
      {
        v11 = v5;
        v12 = v7;
LABEL_16:
        this = llvm::raw_ostream::write(v11, v12);
        goto LABEL_17;
      }
      *((_QWORD *)v5 + 4) = v10 + 1;
      *v10 = v7;
LABEL_17:
      ++a2;
      if (!--v3)
        goto LABEL_36;
    }
  }
  this = llvm::raw_ostream::write(this, 34);
  if (v3)
    goto LABEL_5;
LABEL_36:
  v17 = (_BYTE *)*((_QWORD *)v5 + 4);
  if ((unint64_t)v17 >= *((_QWORD *)v5 + 3))
    return llvm::raw_ostream::write(v5, 34);
  *((_QWORD *)v5 + 4) = v17 + 1;
  *v17 = 34;
  return this;
}

llvm::raw_ostream *llvm::json::OStream::flushComment(llvm::raw_ostream *this)
{
  uint64_t v1;
  llvm::raw_ostream *v2;
  int v3;
  const char *v4;
  size_t v5;
  void *v6;
  size_t v7;
  const void **v8;
  unint64_t v9;
  llvm::raw_ostream *v10;
  unint64_t v11;
  const void *v12;
  _BYTE *v13;
  unint64_t v14;
  unint64_t v15;
  const void *v16;
  void *v17;
  uint64_t v18;
  int v19;
  const char *v20;
  size_t v21;
  void *v22;
  uint64_t v23;
  _BYTE *v24;

  if (*((_QWORD *)this + 19))
  {
    v1 = (uint64_t)this;
    v2 = (llvm::raw_ostream *)*((_QWORD *)this + 20);
    v3 = *((_DWORD *)this + 42);
    if (v3)
      v4 = "/* ";
    else
      v4 = "/*";
    if (v3)
      v5 = 3;
    else
      v5 = 2;
    v6 = (void *)*((_QWORD *)v2 + 4);
    if (v5 <= *((_QWORD *)v2 + 3) - (_QWORD)v6)
    {
      memcpy(v6, v4, v5);
      *((_QWORD *)v2 + 4) += v5;
    }
    else
    {
      llvm::raw_ostream::write(v2, v4, v5);
    }
    v7 = *(_QWORD *)(v1 + 152);
    if (v7)
    {
      v8 = (const void **)(v1 + 144);
      while (1)
      {
        v9 = llvm::StringRef::find((uint64_t *)(v1 + 144), "*/", 2uLL, 0);
        v10 = *(llvm::raw_ostream **)(v1 + 160);
        if (v9 == -1)
          break;
        v11 = v9;
        v12 = *v8;
        if (v7 > v9)
          v7 = v9;
        v13 = (_BYTE *)*((_QWORD *)v10 + 4);
        if (v7 <= *((_QWORD *)v10 + 3) - (_QWORD)v13)
        {
          if (v7)
          {
            memcpy(v13, v12, v7);
            v13 = (_BYTE *)(*((_QWORD *)v10 + 4) + v7);
            *((_QWORD *)v10 + 4) = v13;
          }
        }
        else
        {
          v10 = llvm::raw_ostream::write(*(llvm::raw_ostream **)(v1 + 160), (const char *)v12, v7);
          v13 = (_BYTE *)*((_QWORD *)v10 + 4);
        }
        if (*((_QWORD *)v10 + 3) - (_QWORD)v13 > 2uLL)
        {
          v13[2] = 47;
          *(_WORD *)v13 = 8234;
          *((_QWORD *)v10 + 4) += 3;
        }
        else
        {
          llvm::raw_ostream::write(v10, "* /", 3uLL);
        }
        v14 = *(_QWORD *)(v1 + 152);
        if (v14 >= v11 + 2)
          v15 = v11 + 2;
        else
          v15 = *(_QWORD *)(v1 + 152);
        v7 = v14 - v15;
        *(_QWORD *)(v1 + 144) += v15;
        *(_QWORD *)(v1 + 152) = v14 - v15;
        if (v14 <= v11 + 2)
          goto LABEL_32;
      }
      v16 = *v8;
      v17 = (void *)*((_QWORD *)v10 + 4);
      if (v7 <= *((_QWORD *)v10 + 3) - (_QWORD)v17)
      {
        if (v7)
        {
          memcpy(v17, v16, v7);
          *((_QWORD *)v10 + 4) += v7;
        }
      }
      else
      {
        llvm::raw_ostream::write(*(llvm::raw_ostream **)(v1 + 160), (const char *)v16, v7);
      }
      *(_QWORD *)(v1 + 144) = "";
      *(_QWORD *)(v1 + 152) = 0;
    }
LABEL_32:
    v18 = *(_QWORD *)(v1 + 160);
    v19 = *(_DWORD *)(v1 + 168);
    if (v19)
      v20 = " */";
    else
      v20 = "*/";
    if (v19)
      v21 = 3;
    else
      v21 = 2;
    v22 = *(void **)(v18 + 32);
    if (v21 <= *(_QWORD *)(v18 + 24) - (_QWORD)v22)
    {
      this = (llvm::raw_ostream *)memcpy(v22, v20, v21);
      *(_QWORD *)(v18 + 32) += v21;
    }
    else
    {
      this = llvm::raw_ostream::write(*(llvm::raw_ostream **)(v1 + 160), v20, v21);
    }
    v23 = *(unsigned int *)(v1 + 8);
    if (v23 < 2 || *(_DWORD *)(*(_QWORD *)v1 + 8 * v23 - 8))
    {
      return llvm::json::OStream::newline((llvm::raw_ostream *)v1);
    }
    else if (*(_DWORD *)(v1 + 168))
    {
      this = *(llvm::raw_ostream **)(v1 + 160);
      v24 = (_BYTE *)*((_QWORD *)this + 4);
      if ((unint64_t)v24 >= *((_QWORD *)this + 3))
      {
        return llvm::raw_ostream::write(this, 32);
      }
      else
      {
        *((_QWORD *)this + 4) = v24 + 1;
        *v24 = 32;
      }
    }
  }
  return this;
}

uint64_t llvm::json::OStream::comment(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 144) = a2;
  *(_QWORD *)(result + 152) = a3;
  return result;
}

llvm::raw_ostream *llvm::json::OStream::attributeBegin(uint64_t a1, char *a2, unint64_t a3)
{
  llvm::raw_ostream *v6;
  _BYTE *v7;
  const unsigned __int8 *v8;
  uint64_t v9;
  _QWORD *v10;
  unsigned int v11;
  uint64_t v12;
  llvm::raw_ostream *result;
  llvm::raw_ostream *v14;
  unsigned __int8 *v15;
  uint64_t v16;
  void *__p[2];
  char v18;

  if (*(_BYTE *)(*(_QWORD *)a1 + 8 * *(unsigned int *)(a1 + 8) - 4))
  {
    v6 = *(llvm::raw_ostream **)(a1 + 160);
    v7 = (_BYTE *)*((_QWORD *)v6 + 4);
    if ((unint64_t)v7 >= *((_QWORD *)v6 + 3))
    {
      llvm::raw_ostream::write(v6, 44);
    }
    else
    {
      *((_QWORD *)v6 + 4) = v7 + 1;
      *v7 = 44;
    }
  }
  if (!*(_BYTE *)(a1 + 176)
    || *(_DWORD *)(a1 + 168) != 1
    || *(_BYTE *)(*(_QWORD *)a1 + 8 * *(unsigned int *)(a1 + 8) - 4))
  {
    llvm::json::OStream::newline((llvm::raw_ostream *)a1);
  }
  llvm::json::OStream::flushComment((llvm::raw_ostream *)a1);
  v9 = *(unsigned int *)(a1 + 8);
  v10 = (_QWORD *)(*(_QWORD *)a1 + 8 * v9);
  *((_BYTE *)v10 - 4) = 1;
  if (v9 >= *(_DWORD *)(a1 + 12))
  {
    sub_1C638C314(a1);
    v11 = *(_DWORD *)(a1 + 8);
  }
  else
  {
    *v10 = 0;
    v11 = *(_DWORD *)(a1 + 8) + 1;
    *(_DWORD *)(a1 + 8) = v11;
  }
  *(_DWORD *)(*(_QWORD *)a1 + 8 * v11 - 8) = 0;
  if (!a3)
    goto LABEL_16;
  v12 = 0;
  while ((a2[v12] & 0x80000000) == 0)
  {
    if (a3 == ++v12)
      goto LABEL_16;
  }
  __p[0] = a2;
  if (!llvm::isLegalUTF8String((unsigned __int8 **)__p, (const unsigned __int8 **)&a2[a3], v8))
  {
    v14 = *(llvm::raw_ostream **)(a1 + 160);
    llvm::json::fixUTF8((unint64_t)a2, a3, (uint64_t)__p);
    if (v18 >= 0)
      v15 = (unsigned __int8 *)__p;
    else
      v15 = (unsigned __int8 *)__p[0];
    if (v18 >= 0)
      v16 = v18 & 0x7F;
    else
      v16 = (uint64_t)__p[1];
    sub_1C5E14078(v14, v15, v16);
    if (v18 < 0)
      operator delete(__p[0]);
  }
  else
  {
LABEL_16:
    sub_1C5E14078(*(llvm::raw_ostream **)(a1 + 160), (unsigned __int8 *)a2, a3);
  }
  result = llvm::raw_ostream::write(*(llvm::raw_ostream **)(a1 + 160), 58);
  if (*(_DWORD *)(a1 + 168))
    return llvm::raw_ostream::write(*(llvm::raw_ostream **)(a1 + 160), 32);
  return result;
}

uint64_t llvm::json::OStream::rawValueBegin(llvm::json::OStream *this)
{
  uint64_t v2;
  unsigned int v3;

  llvm::json::OStream::valueBegin(this);
  v2 = *((unsigned int *)this + 2);
  if (v2 >= *((_DWORD *)this + 3))
  {
    sub_1C638C314((uint64_t)this);
    v3 = *((_DWORD *)this + 2);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)this + 8 * v2) = 0;
    v3 = *((_DWORD *)this + 2) + 1;
    *((_DWORD *)this + 2) = v3;
  }
  *(_DWORD *)(*(_QWORD *)this + 8 * v3 - 8) = 4;
  return *((_QWORD *)this + 20);
}

uint64_t llvm::json::OStream::rawValueEnd(uint64_t this)
{
  --*(_DWORD *)(this + 8);
  return this;
}

uint64_t sub_1C5E147B8(uint64_t *a1, uint64_t a2, _QWORD *a3)
{
  int v4;
  uint64_t v6;
  int v7;
  uint64_t v8;
  unsigned int v9;
  const void *v10;
  size_t v11;
  int i;
  int v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t result;

  v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    v6 = *a1;
    v7 = sub_1C5E3DF4C(*(_QWORD **)a2, *(_QWORD *)a2 + *(_QWORD *)(a2 + 8));
    v8 = 0;
    v9 = v4 - 1;
    v10 = *(const void **)a2;
    v11 = *(_QWORD *)(a2 + 8);
    for (i = 1; ; ++i)
    {
      v13 = v7 & v9;
      v14 = v6 + 56 * (v7 & v9);
      v15 = *(_QWORD *)(v14 + 8);
      if (v15 == -2)
      {
        if (v10 == (const void *)-2)
          goto LABEL_19;
      }
      else if (v15 == -1)
      {
        if (v10 == (const void *)-1)
          goto LABEL_19;
      }
      else if (v11 == *(_QWORD *)(v14 + 16) && (!v11 || !memcmp(v10, *(const void **)(v14 + 8), v11)))
      {
LABEL_19:
        result = 1;
        goto LABEL_23;
      }
      if (v15 == -1)
        break;
      if (v8)
        v16 = 0;
      else
        v16 = v15 == -2;
      if (v16)
        v8 = v14;
      v7 = i + v13;
    }
    result = 0;
    if (v8)
      v14 = v8;
  }
  else
  {
    v14 = 0;
    result = 0;
  }
LABEL_23:
  *a3 = v14;
  return result;
}

void sub_1C5E148CC(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  std::string *p_p;
  std::string::size_type size;
  llvm::json::OStream *v6;
  unsigned __int16 *v7;
  _QWORD *v8;
  unsigned int v9;
  uint64_t *v10;
  int v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t *v17;
  int v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  std::string __p;
  uint64_t *v23;
  uint64_t *v24;

  v2 = *a1;
  *((_BYTE *)&__p.__r_.__value_.__s + 23) = 7;
  strcpy((char *)&__p, "error: ");
  std::string::append(&__p, *(const std::string::value_type **)(v2 + 16), *(_QWORD *)(v2 + 24));
  v3 = a1[1];
  p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  size = *((_BYTE *)&__p.__r_.__value_.__s + 23) & 0x7F;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = __p.__r_.__value_.__l.__size_;
  *(_QWORD *)(v3 + 144) = p_p;
  *(_QWORD *)(v3 + 152) = size;
  v8 = a1 + 1;
  v6 = (llvm::json::OStream *)a1[1];
  v7 = (unsigned __int16 *)v8[1];
  v9 = *v7;
  if (v9 >= 7)
  {
    if (v9 == 7)
    {
      llvm::json::OStream::objectBegin(v6);
      v11 = *v7;
      v10 = (uint64_t *)(v7 + 4);
      if (v11 == 7)
        v12 = v10;
      else
        v12 = 0;
      sub_1C5E14C84(&v23, v12);
      v13 = v23;
      v14 = v24;
      if (v23 != v24)
      {
        v15 = v23;
        do
        {
          v16 = *v15++;
          llvm::json::OStream::attributeBegin((uint64_t)v6, *(char **)(v16 + 8), *(_QWORD *)(v16 + 16));
          sub_1C5E14A3C(v16 + 24);
          --*((_DWORD *)v6 + 2);
        }
        while (v15 != v14);
      }
      if (v13)
        operator delete(v13);
      llvm::json::OStream::objectEnd(v6);
    }
    else
    {
      llvm::json::OStream::arrayBegin(v6);
      v18 = *v7;
      v17 = (uint64_t *)(v7 + 4);
      if (v18 == 8)
        v19 = v17;
      else
        v19 = 0;
      v20 = *v19;
      v21 = v19[1];
      while (v20 != v21)
      {
        sub_1C5E14A3C(v20);
        v20 += 32;
      }
      llvm::json::OStream::arrayEnd(v6);
    }
  }
  else
  {
    llvm::json::OStream::value((uint64_t)v6, (uint64_t)v7);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_1C5E14A3C(uint64_t a1)
{
  __asm { BR              X10 }
}

void sub_1C5E14A84(void *__p, uint64_t a2, uint64_t a3, uint64_t a4, std::string *a5, char a6, uint64_t a7, uint64_t a8, void *__pa, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  uint64_t v16;
  std::string v17;
  std::string v18;
  void *v19[11];

  if (*(_QWORD *)(a2 + 16) > 0x27uLL)
  {
    llvm::json::fixUTF8(*(_QWORD *)(a2 + 8), 0x25uLL, (uint64_t)&v18);
    std::string::append(&v18, "...");
    if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
      sub_1C47EBC30(&v17, v18.__r_.__value_.__l.__data_, v18.__r_.__value_.__l.__size_);
    else
      v17 = v18;
    sub_1C4D673F4((uint64_t)v19, (unint64_t)&v17);
    llvm::json::OStream::value(v16, (uint64_t)v19);
    llvm::json::Value::destroy(v19);
    if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v17.__r_.__value_.__l.__data_);
    if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v18.__r_.__value_.__l.__data_);
  }
  else
  {
    llvm::json::OStream::value(v16, a2);
  }
}

uint64_t *sub_1C5E14C84(uint64_t **a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  unint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t *v18;
  unint64_t v19;
  uint64_t v20;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (!*((_DWORD *)a2 + 2))
    goto LABEL_33;
  v3 = *((unsigned int *)a2 + 4);
  if ((_DWORD)v3)
  {
    v4 = 56 * v3;
    v5 = *a2;
    while (*(_QWORD *)(v5 + 8) >= 0xFFFFFFFFFFFFFFFELL)
    {
      v5 += 56;
      v4 -= 56;
      if (!v4)
        goto LABEL_33;
    }
  }
  else
  {
    v5 = *a2;
  }
  v6 = *a2 + 56 * v3;
  if (v5 == v6)
  {
LABEL_33:
    v7 = 0;
    v18 = 0;
  }
  else
  {
    v7 = 0;
LABEL_10:
    v8 = (unint64_t)a1[2];
    if ((unint64_t)v7 >= v8)
    {
      v9 = *a1;
      v10 = v7 - *a1;
      v11 = v10 + 1;
      if ((unint64_t)(v10 + 1) >> 61)
        abort();
      v12 = v8 - (_QWORD)v9;
      if (v12 >> 2 > v11)
        v11 = v12 >> 2;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v13 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v13 = v11;
      if (v13)
      {
        if (v13 >> 61)
          sub_1C4764EE4();
        v14 = (char *)operator new(8 * v13);
      }
      else
      {
        v14 = 0;
      }
      v15 = (uint64_t *)&v14[8 * v10];
      *v15 = v5;
      v16 = v15 + 1;
      if (v7 != v9)
      {
        do
        {
          v17 = *--v7;
          *--v15 = v17;
        }
        while (v7 != v9);
        v7 = *a1;
      }
      *a1 = v15;
      a1[1] = v16;
      a1[2] = (uint64_t *)&v14[8 * v13];
      if (v7)
        operator delete(v7);
      v7 = v16;
    }
    else
    {
      *v7++ = v5;
    }
    a1[1] = v7;
    while (1)
    {
      v5 += 56;
      if (v5 == v6)
        break;
      if (*(_QWORD *)(v5 + 8) < 0xFFFFFFFFFFFFFFFELL)
      {
        if (v5 != v6)
          goto LABEL_10;
        break;
      }
    }
    v18 = *a1;
  }
  v19 = 126 - 2 * __clz(v7 - v18);
  if (v7 == v18)
    v20 = 0;
  else
    v20 = v19;
  return sub_1C5E14E28(v18, v7, v20, 1);
}

uint64_t *sub_1C5E14E28(uint64_t *result, uint64_t *a2, uint64_t a3, char a4)
{
  uint64_t *v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  size_t v14;
  uint64_t v15;
  size_t v16;
  size_t v17;
  size_t v18;
  size_t v19;
  uint64_t *v20;
  size_t v21;
  size_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  size_t v27;
  size_t v28;
  int v29;
  int v30;
  unint64_t v31;
  uint64_t *v32;
  uint64_t *v33;
  size_t v34;
  size_t v35;
  int v36;
  int v37;
  uint64_t *v38;
  size_t v39;
  size_t v40;
  int v41;
  int v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t *v45;
  size_t v46;
  size_t v47;
  int v48;
  int v49;
  uint64_t *v50;
  size_t v51;
  size_t v52;
  int v53;
  int v54;
  uint64_t *v55;
  BOOL v56;
  uint64_t *v57;
  size_t v58;
  size_t v59;
  int v60;
  uint64_t *v61;
  uint64_t *v62;
  size_t v63;
  size_t v64;
  int v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t *v68;
  size_t v69;
  size_t v70;
  int v71;
  uint64_t *v72;
  size_t v73;
  size_t v74;
  int v75;
  uint64_t *v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  unint64_t v80;
  size_t v81;
  uint64_t *v82;
  uint64_t *v83;
  uint64_t v84;
  uint64_t v85;
  unint64_t v86;
  unint64_t v87;
  size_t v88;
  uint64_t *v89;
  BOOL v90;
  char v91;
  uint64_t v92;
  uint64_t *v93;
  uint64_t *v94;
  uint64_t v95;
  uint64_t v96;
  size_t v97;
  size_t v98;
  size_t v99;
  uint64_t v100;
  uint64_t *v101;
  size_t v102;
  size_t v103;
  int v104;
  int64_t v105;
  int64_t v106;
  int64_t v107;
  uint64_t v108;
  uint64_t *v109;
  uint64_t v110;
  uint64_t v111;
  unint64_t v112;
  unint64_t v113;
  size_t v114;
  int v115;
  uint64_t *v116;
  uint64_t v117;
  uint64_t v118;
  unint64_t v119;
  unint64_t v120;
  size_t v121;
  uint64_t v122;
  uint64_t *v123;
  int64_t v124;
  uint64_t v125;
  unint64_t v126;
  unint64_t v127;
  size_t v128;
  int v129;
  unint64_t v130;
  size_t v131;
  int v132;
  uint64_t v133;
  _QWORD *v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  unint64_t v139;
  unint64_t v140;
  size_t v141;
  int v142;
  uint64_t *v143;
  uint64_t v144;
  unint64_t v145;
  uint64_t *v146;
  uint64_t v147;
  uint64_t v148;
  unint64_t v149;
  unint64_t v150;
  size_t v151;
  uint64_t *v152;
  unint64_t v153;
  size_t v154;
  int v155;
  uint64_t v157;
  uint64_t v158;
  size_t v159;
  size_t v160;
  size_t v161;
  uint64_t *v162;
  uint64_t v163;
  uint64_t v164;
  size_t v165;
  size_t v166;
  size_t v167;
  uint64_t *v168;
  uint64_t v169;
  size_t v170;
  size_t v171;
  int v172;
  uint64_t v173;
  size_t v174;
  size_t v175;
  uint64_t v176;
  size_t v177;
  size_t v178;
  uint64_t *v179;
  uint64_t v181;
  int64_t v182;
  uint64_t *v183;
  uint64_t v184;
  uint64_t v185;

  v5 = result;
LABEL_2:
  v6 = a2;
  v183 = a2 - 1;
  v7 = v5;
  while (2)
  {
    v5 = v7;
    v8 = (char *)v6 - (char *)v7;
    v9 = v6 - v7;
    switch(v9)
    {
      case 0:
      case 1:
        return result;
      case 2:
        v77 = *(a2 - 1);
        v78 = *v5;
        v79 = *(_QWORD *)(v77 + 16);
        v80 = *(_QWORD *)(*v5 + 16);
        if (v80 >= v79)
          v81 = *(_QWORD *)(v77 + 16);
        else
          v81 = *(_QWORD *)(*v5 + 16);
        if (v81
          && (result = (uint64_t *)memcmp(*(const void **)(v77 + 8), *(const void **)(v78 + 8), v81), (_DWORD)result))
        {
          if ((result & 0x80000000) == 0)
            return result;
        }
        else if (v79 >= v80)
        {
          return result;
        }
        *v5 = v77;
        *(a2 - 1) = v78;
        return result;
      case 3:
        return sub_1C5E15B64(v5, v5 + 1, v183);
      case 4:
        return sub_1C5E15FEC(v5, v5 + 1, v5 + 2, v183);
      case 5:
        v82 = v5 + 2;
        v83 = v5 + 3;
        result = sub_1C5E15FEC(v5, v5 + 1, v5 + 2, v5 + 3);
        v84 = *(a2 - 1);
        v85 = v5[3];
        v86 = *(_QWORD *)(v84 + 16);
        v87 = *(_QWORD *)(v85 + 16);
        if (v87 >= v86)
          v88 = *(_QWORD *)(v84 + 16);
        else
          v88 = *(_QWORD *)(v85 + 16);
        if (v88
          && (result = (uint64_t *)memcmp(*(const void **)(v84 + 8), *(const void **)(v85 + 8), v88), (_DWORD)result))
        {
          if ((result & 0x80000000) == 0)
            return result;
        }
        else if (v86 >= v87)
        {
          return result;
        }
        *v83 = v84;
        *(a2 - 1) = v85;
        v157 = *v83;
        v158 = *v82;
        v159 = *(_QWORD *)(*v83 + 16);
        v160 = *(_QWORD *)(*v82 + 16);
        if (v160 >= v159)
          v161 = *(_QWORD *)(*v83 + 16);
        else
          v161 = *(_QWORD *)(*v82 + 16);
        if (v161
          && (result = (uint64_t *)memcmp(*(const void **)(v157 + 8), *(const void **)(v158 + 8), v161), (_DWORD)result))
        {
          if ((result & 0x80000000) == 0)
            return result;
        }
        else if (v159 >= v160)
        {
          return result;
        }
        *v82 = v157;
        *v83 = v158;
        v173 = v5[1];
        v174 = *(_QWORD *)(v173 + 16);
        if (v174 >= v159)
          v175 = v159;
        else
          v175 = *(_QWORD *)(v173 + 16);
        if (v175
          && (result = (uint64_t *)memcmp(*(const void **)(v157 + 8), *(const void **)(v173 + 8), v175), (_DWORD)result))
        {
          if ((result & 0x80000000) == 0)
            return result;
        }
        else if (v159 >= v174)
        {
          return result;
        }
        v5[1] = v157;
        v5[2] = v173;
        v176 = *v5;
        v177 = *(_QWORD *)(*v5 + 16);
        if (v177 >= v159)
          v178 = v159;
        else
          v178 = *(_QWORD *)(*v5 + 16);
        if (v178
          && (result = (uint64_t *)memcmp(*(const void **)(v157 + 8), *(const void **)(v176 + 8), v178), (_DWORD)result))
        {
          if ((result & 0x80000000) == 0)
            return result;
        }
        else if (v159 >= v177)
        {
          return result;
        }
        *v5 = v157;
        v5[1] = v176;
        return result;
      default:
        if (v8 <= 191)
        {
          v89 = v5 + 1;
          v90 = v5 == v6 || v89 == v6;
          v91 = v90;
          if ((a4 & 1) == 0)
          {
            if ((v91 & 1) != 0)
              return result;
            while (1)
            {
              v162 = v5;
              v5 = v89;
              v164 = *v162;
              v163 = v162[1];
              v165 = *(_QWORD *)(v163 + 16);
              v166 = *(_QWORD *)(*v162 + 16);
              if (v166 >= v165)
                v167 = *(_QWORD *)(v163 + 16);
              else
                v167 = *(_QWORD *)(*v162 + 16);
              if (v167
                && (result = (uint64_t *)memcmp(*(const void **)(v163 + 8), *(const void **)(v164 + 8), v167),
                    (_DWORD)result))
              {
                if ((result & 0x80000000) != 0)
                {
                  do
                  {
LABEL_331:
                    v168 = v162;
                    v169 = *--v162;
                    v162[2] = v164;
                    v164 = v169;
                    v170 = *(_QWORD *)(v169 + 16);
                    if (v170 >= v165)
                      v171 = v165;
                    else
                      v171 = v170;
                    if (v171
                      && (result = (uint64_t *)memcmp(*(const void **)(v163 + 8), *(const void **)(v164 + 8), v171),
                          (_DWORD)result))
                    {
                      v172 = ((int)result >> 31) | 1;
                    }
                    else
                    {
                      if (v165 >= v170)
                        break;
                      v172 = -1;
                    }
                  }
                  while (v172 == -1);
                  *v168 = v163;
                }
              }
              else if (v165 < v166)
              {
                goto LABEL_331;
              }
              v89 = v5 + 1;
              if (v5 + 1 == a2)
                return result;
            }
          }
          if ((v91 & 1) != 0)
            return result;
          v92 = 0;
          v93 = v5;
LABEL_189:
          v94 = v93;
          v93 = v89;
          v96 = *v94;
          v95 = v94[1];
          v97 = *(_QWORD *)(v95 + 16);
          v98 = *(_QWORD *)(*v94 + 16);
          if (v98 >= v97)
            v99 = *(_QWORD *)(v95 + 16);
          else
            v99 = *(_QWORD *)(*v94 + 16);
          if (v99
            && (result = (uint64_t *)memcmp(*(const void **)(v95 + 8), *(const void **)(v96 + 8), v99), (_DWORD)result))
          {
            if ((result & 0x80000000) == 0)
              goto LABEL_212;
          }
          else if (v97 >= v98)
          {
            goto LABEL_212;
          }
          v100 = v92;
          while (1)
          {
            *(uint64_t *)((char *)v5 + v100 + 8) = v96;
            if (!v100)
            {
              v101 = v5;
              goto LABEL_211;
            }
            v101 = v94;
            v96 = *(uint64_t *)((char *)v5 + v100 - 8);
            v102 = *(_QWORD *)(v96 + 16);
            if (v102 >= v97)
              v103 = v97;
            else
              v103 = *(_QWORD *)(v96 + 16);
            if (v103
              && (result = (uint64_t *)memcmp(*(const void **)(v95 + 8), *(const void **)(v96 + 8), v103), (_DWORD)result))
            {
              v104 = ((int)result >> 31) | 1;
            }
            else
            {
              if (v97 >= v102)
              {
                v101 = (uint64_t *)((char *)v5 + v100);
LABEL_211:
                *v101 = v95;
LABEL_212:
                v89 = v93 + 1;
                v92 += 8;
                if (v93 + 1 == a2)
                  return result;
                goto LABEL_189;
              }
              v104 = -1;
            }
            v94 = v101 - 1;
            v100 -= 8;
            if (v104 != -1)
              goto LABEL_211;
          }
        }
        if (a3)
        {
          v10 = (unint64_t)v9 >> 1;
          v11 = &v5[(unint64_t)v9 >> 1];
          if ((unint64_t)v8 < 0x401)
          {
            result = sub_1C5E15B64(v11, v5, v183);
          }
          else
          {
            sub_1C5E15B64(v5, v11, v183);
            sub_1C5E15B64(v5 + 1, v11 - 1, a2 - 2);
            sub_1C5E15B64(v5 + 2, &v5[v10 + 1], a2 - 3);
            result = sub_1C5E15B64(v11 - 1, v11, &v5[v10 + 1]);
            v12 = *v5;
            *v5 = *v11;
            *v11 = v12;
          }
          --a3;
          v13 = *v5;
          if ((a4 & 1) == 0)
          {
            v15 = *(v5 - 1);
            v16 = *(_QWORD *)(v15 + 16);
            v14 = *(_QWORD *)(v13 + 16);
            if (v14 >= v16)
              v17 = *(_QWORD *)(v15 + 16);
            else
              v17 = *(_QWORD *)(v13 + 16);
            if (v17
              && (result = (uint64_t *)memcmp(*(const void **)(v15 + 8), *(const void **)(v13 + 8), v17), (_DWORD)result))
            {
              if ((result & 0x80000000) != 0)
                goto LABEL_38;
            }
            else if (v16 < v14)
            {
              goto LABEL_38;
            }
            v18 = *(_QWORD *)(*v183 + 16);
            if (v18 >= v14)
              v19 = v14;
            else
              v19 = *(_QWORD *)(*v183 + 16);
            if (v19
              && (result = (uint64_t *)memcmp(*(const void **)(v13 + 8), *(const void **)(*v183 + 8), v19), (_DWORD)result))
            {
              if ((result & 0x80000000) == 0)
                goto LABEL_23;
            }
            else if (v14 >= v18)
            {
LABEL_23:
              v20 = v5 + 1;
              do
              {
                v7 = v20;
                if (v20 >= v6)
                  break;
                v21 = *(_QWORD *)(*v20 + 16);
                v22 = v21 >= v14 ? v14 : *(_QWORD *)(*v20 + 16);
                if (v22
                  && (result = (uint64_t *)memcmp(*(const void **)(v13 + 8), *(const void **)(*v20 + 8), v22),
                      (_DWORD)result))
                {
                  v23 = ((int)result >> 31) | 1;
                }
                else if (v14 == v21)
                {
                  v23 = 0;
                }
                else
                {
                  if (v14 < v21)
                    goto LABEL_122;
                  v23 = 1;
                }
                v20 = v7 + 1;
              }
              while (v23 != -1);
              goto LABEL_122;
            }
            v57 = v5 + 1;
            do
            {
              v7 = v57;
              v58 = *(_QWORD *)(*v57 + 16);
              if (v58 >= v14)
                v59 = v14;
              else
                v59 = *(_QWORD *)(*v57 + 16);
              if (v59
                && (result = (uint64_t *)memcmp(*(const void **)(v13 + 8), *(const void **)(*v57 + 8), v59),
                    (_DWORD)result))
              {
                v60 = ((int)result >> 31) | 1;
              }
              else if (v14 == v58)
              {
                v60 = 0;
              }
              else
              {
                if (v14 < v58)
                  break;
                v60 = 1;
              }
              v57 = v7 + 1;
            }
            while (v60 != -1);
LABEL_122:
            v61 = v6;
            if (v7 < v6)
            {
              v62 = a2 - 1;
              do
              {
                v61 = v62;
                v63 = *(_QWORD *)(*v62 + 16);
                if (v63 >= v14)
                  v64 = v14;
                else
                  v64 = *(_QWORD *)(*v62 + 16);
                if (v64
                  && (result = (uint64_t *)memcmp(*(const void **)(v13 + 8), *(const void **)(*v62 + 8), v64),
                      (_DWORD)result))
                {
                  v65 = ((int)result >> 31) | 1;
                }
                else
                {
                  if (v14 >= v63)
                    break;
                  v65 = -1;
                }
                v62 = v61 - 1;
              }
              while (v65 == -1);
            }
            if (v7 < v61)
            {
              v66 = *v7;
              v67 = *v61;
              do
              {
                *v7 = v67;
                *v61 = v66;
                v68 = v7 + 1;
                do
                {
                  v7 = v68;
                  v66 = *v68;
                  v69 = *(_QWORD *)(*v68 + 16);
                  if (v69 >= v14)
                    v70 = v14;
                  else
                    v70 = *(_QWORD *)(*v68 + 16);
                  if (v70
                    && (result = (uint64_t *)memcmp(*(const void **)(v13 + 8), *(const void **)(v66 + 8), v70),
                        (_DWORD)result))
                  {
                    v71 = ((int)result >> 31) | 1;
                  }
                  else if (v14 == v69)
                  {
                    v71 = 0;
                  }
                  else
                  {
                    if (v14 < v69)
                      break;
                    v71 = 1;
                  }
                  v68 = v7 + 1;
                }
                while (v71 != -1);
                v72 = v61 - 1;
                do
                {
                  v61 = v72;
                  v67 = *v72;
                  v73 = *(_QWORD *)(*v72 + 16);
                  if (v73 >= v14)
                    v74 = v14;
                  else
                    v74 = *(_QWORD *)(*v72 + 16);
                  if (v74
                    && (result = (uint64_t *)memcmp(*(const void **)(v13 + 8), *(const void **)(v67 + 8), v74),
                        (_DWORD)result))
                  {
                    v75 = ((int)result >> 31) | 1;
                  }
                  else
                  {
                    if (v14 >= v73)
                      break;
                    v75 = -1;
                  }
                  v72 = v61 - 1;
                }
                while (v75 == -1);
              }
              while (v7 < v61);
            }
            v76 = v7 - 1;
            v6 = a2;
            if (v7 - 1 != v5)
              *v5 = *v76;
            a4 = 0;
            *v76 = v13;
            continue;
          }
          v14 = *(_QWORD *)(v13 + 16);
LABEL_38:
          v24 = 8;
          do
          {
            v25 = v24;
            v26 = *(uint64_t *)((char *)v5 + v24);
            v27 = *(_QWORD *)(v26 + 16);
            if (v14 >= v27)
              v28 = *(_QWORD *)(v26 + 16);
            else
              v28 = v14;
            if (v28 && (v29 = memcmp(*(const void **)(v26 + 8), *(const void **)(v13 + 8), v28)) != 0)
            {
              v30 = (v29 >> 31) | 1;
            }
            else
            {
              if (v27 >= v14)
                break;
              v30 = -1;
            }
            v24 = v25 + 8;
          }
          while (v30 == -1);
          v31 = (unint64_t)v5 + v25;
          v32 = a2 - 1;
          if (v25 == 8)
          {
            v38 = a2 - 1;
            while (v31 < (unint64_t)(v38 + 1))
            {
              v33 = v38;
              v39 = *(_QWORD *)(*v38 + 16);
              if (v14 >= v39)
                v40 = *(_QWORD *)(*v38 + 16);
              else
                v40 = v14;
              if (v40 && (v41 = memcmp(*(const void **)(*v38 + 8), *(const void **)(v13 + 8), v40)) != 0)
              {
                v42 = (v41 >> 31) | 1;
              }
              else if (v39 == v14)
              {
                v42 = 0;
              }
              else
              {
                if (v39 < v14)
                  goto LABEL_76;
                v42 = 1;
              }
              v38 = v33 - 1;
              if (v42 == -1)
                goto LABEL_76;
            }
            v33 = v38 + 1;
          }
          else
          {
            do
            {
              v33 = v32;
              v34 = *(_QWORD *)(*v32 + 16);
              if (v14 >= v34)
                v35 = *(_QWORD *)(*v32 + 16);
              else
                v35 = v14;
              if (v35 && (v36 = memcmp(*(const void **)(*v32 + 8), *(const void **)(v13 + 8), v35)) != 0)
              {
                v37 = (v36 >> 31) | 1;
              }
              else if (v34 == v14)
              {
                v37 = 0;
              }
              else
              {
                if (v34 < v14)
                  break;
                v37 = 1;
              }
              v32 = v33 - 1;
            }
            while (v37 != -1);
          }
LABEL_76:
          v181 = a3;
          if (v31 >= (unint64_t)v33)
          {
            v7 = (uint64_t *)v31;
          }
          else
          {
            v43 = *v33;
            v7 = (uint64_t *)v31;
            v44 = v33;
            do
            {
              *v7 = v43;
              *v44 = v26;
              v45 = v7 + 1;
              do
              {
                v7 = v45;
                v26 = *v45;
                v46 = *(_QWORD *)(*v45 + 16);
                if (v14 >= v46)
                  v47 = *(_QWORD *)(*v45 + 16);
                else
                  v47 = v14;
                if (v47 && (v48 = memcmp(*(const void **)(v26 + 8), *(const void **)(v13 + 8), v47)) != 0)
                {
                  v49 = (v48 >> 31) | 1;
                }
                else
                {
                  if (v46 >= v14)
                    break;
                  v49 = -1;
                }
                v45 = v7 + 1;
              }
              while (v49 == -1);
              v50 = v44 - 1;
              do
              {
                v44 = v50;
                v43 = *v50;
                v51 = *(_QWORD *)(*v50 + 16);
                if (v14 >= v51)
                  v52 = *(_QWORD *)(*v50 + 16);
                else
                  v52 = v14;
                if (v52 && (v53 = memcmp(*(const void **)(v43 + 8), *(const void **)(v13 + 8), v52)) != 0)
                {
                  v54 = (v53 >> 31) | 1;
                }
                else if (v51 == v14)
                {
                  v54 = 0;
                }
                else
                {
                  if (v51 < v14)
                    break;
                  v54 = 1;
                }
                v50 = v44 - 1;
              }
              while (v54 != -1);
            }
            while (v7 < v44);
          }
          v55 = v7 - 1;
          if (v7 - 1 != v5)
            *v5 = *v55;
          *v55 = v13;
          v6 = a2;
          a3 = v181;
          if (v31 < (unint64_t)v33)
            goto LABEL_108;
          v56 = sub_1C5E15CE0(v5, v7 - 1);
          result = (uint64_t *)sub_1C5E15CE0(v7, a2);
          if (!(_DWORD)result)
          {
            if (v56)
              continue;
LABEL_108:
            result = (uint64_t *)sub_1C5E14E28(v5, v7 - 1, v181, a4 & 1);
            a4 = 0;
            continue;
          }
          a2 = v7 - 1;
          if (v56)
            return result;
          goto LABEL_2;
        }
        if (v5 == v6)
          return result;
        v105 = (unint64_t)(v9 - 2) >> 1;
        v106 = v105;
        v179 = v5;
        while (2)
        {
          v107 = v106;
          if (v105 >= v106)
          {
            v108 = (2 * v106) | 1;
            v109 = &v5[v108];
            v110 = 2 * v106 + 2;
            v182 = v106;
            if (v110 < v9)
            {
              v111 = v109[1];
              v112 = *(_QWORD *)(*v109 + 16);
              v113 = *(_QWORD *)(v111 + 16);
              if (v113 >= v112)
                v114 = *(_QWORD *)(*v109 + 16);
              else
                v114 = *(_QWORD *)(v111 + 16);
              if (v114
                && (result = (uint64_t *)memcmp(*(const void **)(*v109 + 8), *(const void **)(v111 + 8), v114),
                    (_DWORD)result))
              {
                v115 = ((int)result >> 31) | 1;
              }
              else
              {
                if (v112 < v113)
                  v115 = -1;
                else
                  v115 = 1;
                if (v112 == v113)
                  v115 = 0;
              }
              if (v115 == -1)
              {
                ++v109;
                v108 = v110;
              }
              v107 = v182;
            }
            v116 = &v5[v107];
            v117 = *v109;
            v118 = *v116;
            v119 = *(_QWORD *)(*v109 + 16);
            v120 = *(_QWORD *)(*v116 + 16);
            if (v120 >= v119)
              v121 = *(_QWORD *)(*v109 + 16);
            else
              v121 = *(_QWORD *)(*v116 + 16);
            if (v121
              && (v122 = *v116,
                  result = (uint64_t *)memcmp(*(const void **)(v117 + 8), *(const void **)(v118 + 8), v121),
                  v118 = v122,
                  (_DWORD)result))
            {
              v107 = v182;
              if ((result & 0x80000000) != 0)
                goto LABEL_270;
            }
            else
            {
              v107 = v182;
              if (v119 < v120)
                goto LABEL_270;
            }
            v184 = v118;
            do
            {
              v123 = v109;
              *v116 = v117;
              if (v105 < v108)
                break;
              v109 = &v5[(2 * v108) | 1];
              if (2 * v108 + 2 >= v9)
              {
                v108 = (2 * v108) | 1;
              }
              else
              {
                v124 = v105;
                v125 = v109[1];
                v126 = *(_QWORD *)(*v109 + 16);
                v127 = *(_QWORD *)(v125 + 16);
                v128 = v127 >= v126 ? *(_QWORD *)(*v109 + 16) : *(_QWORD *)(v125 + 16);
                if (v128
                  && (result = (uint64_t *)memcmp(*(const void **)(*v109 + 8), *(const void **)(v125 + 8), v128),
                      (_DWORD)result))
                {
                  v129 = ((int)result >> 31) | 1;
                }
                else
                {
                  if (v126 < v127)
                    v129 = -1;
                  else
                    v129 = 1;
                  if (v126 == v127)
                    v129 = 0;
                }
                v105 = v124;
                v5 = v179;
                if (v129 == -1)
                {
                  ++v109;
                  v108 = 2 * v108 + 2;
                }
                else
                {
                  v108 = (2 * v108) | 1;
                }
              }
              v117 = *v109;
              v130 = *(_QWORD *)(*v109 + 16);
              v131 = v120 >= v130 ? *(_QWORD *)(*v109 + 16) : v120;
              if (v131
                && (result = (uint64_t *)memcmp(*(const void **)(v117 + 8), *(const void **)(v184 + 8), v131),
                    (_DWORD)result))
              {
                v132 = ((int)result >> 31) | 1;
              }
              else if (v130 == v120)
              {
                v132 = 0;
              }
              else
              {
                if (v130 < v120)
                  break;
                v132 = 1;
              }
              v116 = v123;
            }
            while (v132 != -1);
            v107 = v182;
            *v123 = v184;
          }
LABEL_270:
          v106 = v107 - 1;
          if (v107)
            continue;
          break;
        }
        do
        {
          v133 = 0;
          v185 = *v5;
          v134 = v5;
          do
          {
            v135 = (uint64_t)&v134[v133 + 1];
            v136 = (2 * v133) | 1;
            v137 = 2 * v133 + 2;
            if (v137 < v9)
            {
              v138 = v134[v133 + 2];
              v139 = *(_QWORD *)(*(_QWORD *)v135 + 16);
              v140 = *(_QWORD *)(v138 + 16);
              if (v140 >= v139)
                v141 = *(_QWORD *)(*(_QWORD *)v135 + 16);
              else
                v141 = *(_QWORD *)(v138 + 16);
              if (v141
                && (result = (uint64_t *)memcmp(*(const void **)(*(_QWORD *)v135 + 8), *(const void **)(v138 + 8), v141), (_DWORD)result))
              {
                v142 = ((int)result >> 31) | 1;
              }
              else
              {
                if (v139 < v140)
                  v142 = -1;
                else
                  v142 = 1;
                if (v139 == v140)
                  v142 = 0;
              }
              if (v142 == -1)
              {
                v135 += 8;
                v136 = v137;
              }
            }
            *v134 = *(_QWORD *)v135;
            v134 = (_QWORD *)v135;
            v133 = v136;
          }
          while (v136 <= (uint64_t)((unint64_t)(v9 - 2) >> 1));
          v143 = a2 - 1;
          v90 = v135 == (_QWORD)--a2;
          if (v90)
          {
            *(_QWORD *)v135 = v185;
          }
          else
          {
            *(_QWORD *)v135 = *v143;
            *v143 = v185;
            v144 = v135 - (_QWORD)v5 + 8;
            if (v144 >= 9)
            {
              v145 = (((unint64_t)v144 >> 3) - 2) >> 1;
              v146 = &v5[v145];
              v147 = *v146;
              v148 = *(_QWORD *)v135;
              v149 = *(_QWORD *)(*v146 + 16);
              v150 = *(_QWORD *)(*(_QWORD *)v135 + 16);
              if (v150 >= v149)
                v151 = *(_QWORD *)(*v146 + 16);
              else
                v151 = *(_QWORD *)(*(_QWORD *)v135 + 16);
              if (v151
                && (result = (uint64_t *)memcmp(*(const void **)(v147 + 8), *(const void **)(v148 + 8), v151),
                    (_DWORD)result))
              {
                if ((result & 0x80000000) != 0)
                {
                  do
                  {
LABEL_298:
                    v152 = v146;
                    *(_QWORD *)v135 = v147;
                    if (!v145)
                      break;
                    v145 = (v145 - 1) >> 1;
                    v146 = &v5[v145];
                    v147 = *v146;
                    v153 = *(_QWORD *)(*v146 + 16);
                    v154 = v150 >= v153 ? *(_QWORD *)(*v146 + 16) : v150;
                    if (v154
                      && (result = (uint64_t *)memcmp(*(const void **)(v147 + 8), *(const void **)(v148 + 8), v154),
                          (_DWORD)result))
                    {
                      v155 = ((int)result >> 31) | 1;
                    }
                    else
                    {
                      if (v153 >= v150)
                        break;
                      v155 = -1;
                    }
                    v135 = (uint64_t)v152;
                  }
                  while (v155 == -1);
                  *v152 = v148;
                }
              }
              else if (v149 < v150)
              {
                goto LABEL_298;
              }
            }
          }
        }
        while (v9-- > 2);
        return result;
    }
  }
}

uint64_t *sub_1C5E15B64(uint64_t *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  size_t v8;
  size_t v9;
  size_t v10;
  uint64_t v11;
  size_t v12;
  size_t v13;
  uint64_t v14;
  size_t v15;
  size_t v16;
  uint64_t v17;
  size_t v18;
  size_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  size_t v24;

  v5 = result;
  v6 = *a2;
  v7 = *result;
  v8 = *(_QWORD *)(*a2 + 16);
  v9 = *(_QWORD *)(*result + 16);
  if (v9 >= v8)
    v10 = *(_QWORD *)(*a2 + 16);
  else
    v10 = *(_QWORD *)(*result + 16);
  if (v10)
  {
    result = (uint64_t *)memcmp(*(const void **)(v6 + 8), *(const void **)(v7 + 8), v10);
    if ((_DWORD)result)
    {
      if ((result & 0x80000000) == 0)
        goto LABEL_7;
LABEL_15:
      v14 = *a3;
      v15 = *(_QWORD *)(*a3 + 16);
      if (v8 >= v15)
        v16 = *(_QWORD *)(*a3 + 16);
      else
        v16 = v8;
      if (v16 && (result = (uint64_t *)memcmp(*(const void **)(v14 + 8), *(const void **)(v6 + 8), v16), (_DWORD)result))
      {
        if ((result & 0x80000000) == 0)
        {
LABEL_21:
          *v5 = v6;
          *a2 = v7;
          v17 = *a3;
          v18 = *(_QWORD *)(*a3 + 16);
          if (v9 >= v18)
            v19 = *(_QWORD *)(*a3 + 16);
          else
            v19 = v9;
          if (v19
            && (result = (uint64_t *)memcmp(*(const void **)(v17 + 8), *(const void **)(v7 + 8), v19), (_DWORD)result))
          {
            if ((result & 0x80000000) == 0)
              return result;
          }
          else if (v18 >= v9)
          {
            return result;
          }
          *a2 = v17;
          goto LABEL_40;
        }
      }
      else if (v15 >= v8)
      {
        goto LABEL_21;
      }
      *v5 = v14;
LABEL_40:
      *a3 = v7;
      return result;
    }
  }
  if (v8 < v9)
    goto LABEL_15;
LABEL_7:
  v11 = *a3;
  v12 = *(_QWORD *)(*a3 + 16);
  if (v8 >= v12)
    v13 = *(_QWORD *)(*a3 + 16);
  else
    v13 = v8;
  if (v13 && (result = (uint64_t *)memcmp(*(const void **)(v11 + 8), *(const void **)(v6 + 8), v13), (_DWORD)result))
  {
    if ((result & 0x80000000) == 0)
      return result;
  }
  else if (v12 >= v8)
  {
    return result;
  }
  *a2 = v11;
  *a3 = v6;
  v20 = *a2;
  v21 = *v5;
  v22 = *(_QWORD *)(*a2 + 16);
  v23 = *(_QWORD *)(*v5 + 16);
  if (v23 >= v22)
    v24 = *(_QWORD *)(*a2 + 16);
  else
    v24 = *(_QWORD *)(*v5 + 16);
  if (v24 && (result = (uint64_t *)memcmp(*(const void **)(v20 + 8), *(const void **)(v21 + 8), v24), (_DWORD)result))
  {
    if ((result & 0x80000000) == 0)
      return result;
  }
  else if (v22 >= v23)
  {
    return result;
  }
  *v5 = v20;
  *a2 = v21;
  return result;
}

BOOL sub_1C5E15CE0(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;
  _BOOL8 result;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  size_t v10;
  int v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  size_t v18;
  size_t v19;
  size_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  size_t v25;
  size_t v26;
  int v27;
  int v28;
  uint64_t *v29;
  uint64_t *v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  size_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  size_t v40;
  size_t v41;
  size_t v42;
  int v43;
  uint64_t v44;
  size_t v45;
  size_t v46;
  int v47;
  uint64_t v48;
  size_t v49;
  size_t v50;
  int v51;

  v4 = a2 - a1;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = *(a2 - 1);
      v7 = *a1;
      v8 = *(_QWORD *)(v6 + 16);
      v9 = *(_QWORD *)(*a1 + 16);
      if (v9 >= v8)
        v10 = *(_QWORD *)(v6 + 16);
      else
        v10 = *(_QWORD *)(*a1 + 16);
      if (v10 && (v11 = memcmp(*(const void **)(v6 + 8), *(const void **)(v7 + 8), v10)) != 0)
      {
        if ((v11 & 0x80000000) == 0)
          return 1;
      }
      else if (v8 >= v9)
      {
        return 1;
      }
      *a1 = v6;
      *(a2 - 1) = v7;
      return 1;
    case 3:
      sub_1C5E15B64(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      sub_1C5E15FEC(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      v30 = a1 + 2;
      v31 = a1 + 3;
      sub_1C5E15FEC(a1, a1 + 1, a1 + 2, a1 + 3);
      v32 = *(a2 - 1);
      v33 = a1[3];
      v34 = *(_QWORD *)(v32 + 16);
      v35 = *(_QWORD *)(v33 + 16);
      if (v35 >= v34)
        v36 = *(_QWORD *)(v32 + 16);
      else
        v36 = *(_QWORD *)(v33 + 16);
      if (v36 && (v37 = memcmp(*(const void **)(v32 + 8), *(const void **)(v33 + 8), v36)) != 0)
      {
        if ((v37 & 0x80000000) == 0)
          return 1;
      }
      else if (v34 >= v35)
      {
        return 1;
      }
      *v31 = v32;
      *(a2 - 1) = v33;
      v38 = *v31;
      v39 = *v30;
      v40 = *(_QWORD *)(*v31 + 16);
      v41 = *(_QWORD *)(*v30 + 16);
      if (v41 >= v40)
        v42 = *(_QWORD *)(*v31 + 16);
      else
        v42 = *(_QWORD *)(*v30 + 16);
      if (v42 && (v43 = memcmp(*(const void **)(v38 + 8), *(const void **)(v39 + 8), v42)) != 0)
      {
        if ((v43 & 0x80000000) == 0)
          return 1;
      }
      else if (v40 >= v41)
      {
        return 1;
      }
      *v30 = v38;
      *v31 = v39;
      v44 = a1[1];
      v45 = *(_QWORD *)(v44 + 16);
      if (v45 >= v40)
        v46 = v40;
      else
        v46 = *(_QWORD *)(v44 + 16);
      if (v46 && (v47 = memcmp(*(const void **)(v38 + 8), *(const void **)(v44 + 8), v46)) != 0)
      {
        if ((v47 & 0x80000000) == 0)
          return 1;
      }
      else if (v40 >= v45)
      {
        return 1;
      }
      a1[1] = v38;
      a1[2] = v44;
      v48 = *a1;
      v49 = *(_QWORD *)(*a1 + 16);
      if (v49 >= v40)
        v50 = v40;
      else
        v50 = *(_QWORD *)(*a1 + 16);
      if (v50 && (v51 = memcmp(*(const void **)(v38 + 8), *(const void **)(v48 + 8), v50)) != 0)
      {
        if ((v51 & 0x80000000) == 0)
          return 1;
      }
      else if (v40 >= v49)
      {
        return 1;
      }
      *a1 = v38;
      a1[1] = v48;
      return 1;
    default:
      v12 = a1 + 2;
      sub_1C5E15B64(a1, a1 + 1, a1 + 2);
      v13 = a1 + 3;
      if (a1 + 3 == a2)
        return 1;
      v14 = 0;
      v15 = 0;
      break;
  }
  do
  {
    v16 = *v13;
    v17 = *v12;
    v18 = *(_QWORD *)(*v13 + 16);
    v19 = *(_QWORD *)(v17 + 16);
    if (v19 >= v18)
      v20 = *(_QWORD *)(*v13 + 16);
    else
      v20 = *(_QWORD *)(v17 + 16);
    if (v20 && (v21 = memcmp(*(const void **)(v16 + 8), *(const void **)(v17 + 8), v20)) != 0)
    {
      if ((v21 & 0x80000000) == 0)
        goto LABEL_33;
    }
    else if (v18 >= v19)
    {
      goto LABEL_33;
    }
    v22 = v14;
    while (1)
    {
      v23 = v22;
      v24 = (char *)a1 + v22;
      *((_QWORD *)v24 + 3) = v17;
      if (v23 == -16)
        break;
      v17 = *((_QWORD *)v24 + 1);
      v25 = *(_QWORD *)(v17 + 16);
      if (v25 >= v18)
        v26 = v18;
      else
        v26 = *(_QWORD *)(v17 + 16);
      if (v26 && (v27 = memcmp(*(const void **)(v16 + 8), *(const void **)(v17 + 8), v26)) != 0)
      {
        v28 = (v27 >> 31) | 1;
      }
      else
      {
        if (v18 >= v25)
          goto LABEL_30;
        v28 = -1;
      }
      v22 = v23 - 8;
      if (v28 != -1)
      {
LABEL_30:
        v29 = (uint64_t *)((char *)a1 + v23 + 16);
        goto LABEL_32;
      }
    }
    v29 = a1;
LABEL_32:
    *v29 = v16;
    if (++v15 == 8)
      return v13 + 1 == a2;
LABEL_33:
    v12 = v13;
    v14 += 8;
    ++v13;
  }
  while (v13 != a2);
  return 1;
}

uint64_t *sub_1C5E15FEC(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *result;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  size_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  size_t v23;

  result = sub_1C5E15B64(a1, a2, a3);
  v9 = *a4;
  v10 = *a3;
  v11 = *(_QWORD *)(*a4 + 16);
  v12 = *(_QWORD *)(*a3 + 16);
  if (v12 >= v11)
    v13 = *(_QWORD *)(*a4 + 16);
  else
    v13 = *(_QWORD *)(*a3 + 16);
  if (v13 && (result = (uint64_t *)memcmp(*(const void **)(v9 + 8), *(const void **)(v10 + 8), v13), (_DWORD)result))
  {
    if ((result & 0x80000000) == 0)
      return result;
  }
  else if (v11 >= v12)
  {
    return result;
  }
  *a3 = v9;
  *a4 = v10;
  v14 = *a3;
  v15 = *a2;
  v16 = *(_QWORD *)(*a3 + 16);
  v17 = *(_QWORD *)(*a2 + 16);
  if (v17 >= v16)
    v18 = *(_QWORD *)(*a3 + 16);
  else
    v18 = *(_QWORD *)(*a2 + 16);
  if (v18 && (result = (uint64_t *)memcmp(*(const void **)(v14 + 8), *(const void **)(v15 + 8), v18), (_DWORD)result))
  {
    if ((result & 0x80000000) == 0)
      return result;
  }
  else if (v16 >= v17)
  {
    return result;
  }
  *a2 = v14;
  *a3 = v15;
  v19 = *a2;
  v20 = *a1;
  v21 = *(_QWORD *)(*a2 + 16);
  v22 = *(_QWORD *)(*a1 + 16);
  if (v22 >= v21)
    v23 = *(_QWORD *)(*a2 + 16);
  else
    v23 = *(_QWORD *)(*a1 + 16);
  if (v23 && (result = (uint64_t *)memcmp(*(const void **)(v19 + 8), *(const void **)(v20 + 8), v23), (_DWORD)result))
  {
    if ((result & 0x80000000) == 0)
      return result;
  }
  else if (v21 >= v22)
  {
    return result;
  }
  *a1 = v19;
  *a2 = v20;
  return result;
}

uint64_t sub_1C5E160FC(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  int v6;
  unint64_t v7;
  int v8;
  unint64_t v9;
  int v10;
  uint64_t result;
  uint64_t v12;

  v4 = *(_QWORD *)(a1 + 16);
  v5 = *(_QWORD *)(a1 + 24);
  v6 = v5 - v4;
  if (v5 <= v4)
  {
    v8 = 1;
    v10 = v5 - v4;
  }
  else
  {
    v7 = v4 + 1;
    v8 = 1;
    v9 = v5 - v4;
    do
    {
      if (*(_BYTE *)(v7 - 1) == 10)
      {
        ++v8;
        LODWORD(v4) = v7;
      }
      ++v7;
      --v9;
    }
    while (v9);
    v10 = v5 - v4;
  }
  result = operator new();
  v12 = result;
  *(_QWORD *)result = &off_1E81A1668;
  *(_QWORD *)(result + 8) = a2;
  *(_DWORD *)(result + 16) = v8;
  *(_DWORD *)(result + 20) = v10;
  *(_DWORD *)(result + 24) = v6;
  if (*(_BYTE *)(a1 + 8))
  {
    result = *(_QWORD *)a1;
    if (*(_QWORD *)a1)
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  *(_QWORD *)a1 = v12;
  *(_BYTE *)(a1 + 8) = 1;
  return result;
}

uint64_t sub_1C5E161C8(uint64_t a1, std::string *this)
{
  unsigned __int8 *v4;
  std::string::value_type *v5;
  int v6;
  uint64_t v8;
  std::string::value_type v9;
  std::string *v10;
  int v11;
  unsigned __int8 v12;
  uint64_t v13;
  unsigned __int16 v14;
  uint64_t v15;
  __int16 v16;
  unsigned int v17;
  unint64_t v18;
  _BYTE *v19;
  std::string::value_type *v20;
  std::string::value_type v21;
  std::string::value_type v22;
  unsigned __int16 v23;
  uint64_t v24;
  uint64_t v25;
  __int16 v26;
  unsigned int v27;
  const char *v28;
  std::string::value_type __s[2];
  char v30;
  char v31;

  v5 = *(std::string::value_type **)(a1 + 24);
  v4 = *(unsigned __int8 **)(a1 + 32);
  if (v5 == (std::string::value_type *)v4)
  {
    LOBYTE(v6) = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 24) = v5 + 1;
    v6 = *v5;
    if (v6 == 34)
      return 1;
    ++v5;
  }
  v8 = MEMORY[0x1E0C80978];
  while (2)
  {
    if (v5 == (std::string::value_type *)v4)
    {
      v28 = "Unterminated string";
    }
    else
    {
      if (v6 > 0x1Fu)
      {
        if (v6 == 92)
        {
          *(_QWORD *)(a1 + 24) = v5 + 1;
          v11 = *v5;
          if (v11 > 97)
          {
            switch(*v5)
            {
              case 'n':
                v10 = this;
                v9 = 10;
                break;
              case 'o':
              case 'p':
              case 'q':
              case 's':
                goto LABEL_78;
              case 'r':
                v10 = this;
                v9 = 13;
                break;
              case 't':
                v10 = this;
                v9 = 9;
                break;
              case 'u':
                if (v5 + 1 == (std::string::value_type *)v4)
                {
                  __s[0] = 0;
LABEL_37:
                  __s[1] = 0;
LABEL_38:
                  v12 = 0;
                  v30 = 0;
                  goto LABEL_39;
                }
                *(_QWORD *)(a1 + 24) = v5 + 2;
                __s[0] = v5[1];
                if (v5 + 2 == (std::string::value_type *)v4)
                  goto LABEL_37;
                *(_QWORD *)(a1 + 24) = v5 + 3;
                __s[1] = v5[2];
                if (v5 + 3 == (std::string::value_type *)v4)
                  goto LABEL_38;
                *(_QWORD *)(a1 + 24) = v5 + 4;
                v30 = v5[3];
                if (v5 + 4 == (std::string::value_type *)v4)
                {
                  v12 = 0;
                }
                else
                {
                  *(_QWORD *)(a1 + 24) = v5 + 5;
                  v12 = v5[4];
                }
LABEL_39:
                v13 = 0;
                v14 = 0;
                v31 = v12;
                do
                {
                  v15 = __s[v13];
                  if ((*(_DWORD *)(v8 + 4 * v15 + 60) & 0x10000) == 0)
                  {
LABEL_77:
                    v28 = "Invalid \\u escape sequence";
                    goto LABEL_76;
                  }
                  if (v15 <= 0x39)
                    v16 = v15 - 48;
                  else
                    v16 = (v15 & 0xFFDF) - 55;
                  v14 = v16 | (16 * v14);
                  ++v13;
                }
                while (v13 != 4);
                v17 = (unsigned __int16)(v14 + 0x2000) >> 11;
                while (2)
                {
                  if (v17 < 0x1F)
                  {
                    v27 = v14;
LABEL_70:
                    sub_1C5E165D8(v27, this);
                    goto LABEL_13;
                  }
                  if ((unsigned __int16)(v14 >> 10) < 0x37u)
                  {
                    v19 = *(_BYTE **)(a1 + 24);
                    v18 = *(_QWORD *)(a1 + 32);
                    v20 = v19 + 2;
                    if ((unint64_t)(v19 + 2) <= v18 && *v19 == 92 && v19[1] == 117)
                    {
                      *(_QWORD *)(a1 + 24) = v20;
                      if (v20 == (std::string::value_type *)v18)
                      {
                        v21 = 0;
                      }
                      else
                      {
                        v20 = v19 + 3;
                        *(_QWORD *)(a1 + 24) = v19 + 3;
                        v21 = v19[2];
                      }
                      __s[0] = v21;
                      if (v20 == (std::string::value_type *)v18)
                      {
                        __s[1] = 0;
                      }
                      else
                      {
                        *(_QWORD *)(a1 + 24) = v20 + 1;
                        __s[1] = *v20;
                        if (v20 + 1 != (std::string::value_type *)v18)
                        {
                          *(_QWORD *)(a1 + 24) = v20 + 2;
                          v30 = v20[1];
                          if (v20 + 2 == (std::string::value_type *)v18)
                          {
                            v22 = 0;
                          }
                          else
                          {
                            *(_QWORD *)(a1 + 24) = v20 + 3;
                            v22 = v20[2];
                          }
LABEL_60:
                          v23 = 0;
                          v24 = 0;
                          v31 = v22;
                          do
                          {
                            v25 = __s[v24];
                            if ((*(_DWORD *)(v8 + 4 * v25 + 60) & 0x10000) == 0)
                              goto LABEL_77;
                            if (v25 <= 0x39)
                              v26 = v25 - 48;
                            else
                              v26 = (v25 & 0xFFDF) - 55;
                            v23 = v26 | (16 * v23);
                            ++v24;
                          }
                          while (v24 != 4);
                          if ((unsigned __int16)((unsigned __int16)(v23 + 0x2000) >> 10) >= 0x3Fu)
                          {
                            v27 = (v23 - 56320) | (((v14 << 10) | 0x10000) - 56623104);
                            goto LABEL_70;
                          }
                          *(_WORD *)__s = -16401;
                          v30 = -67;
                          std::string::append(this, __s, 3uLL);
                          v17 = (unsigned __int16)(v23 + 0x2000) >> 11;
                          v14 = v23;
                          continue;
                        }
                      }
                      v22 = 0;
                      v30 = 0;
                      goto LABEL_60;
                    }
                  }
                  break;
                }
                *(_WORD *)__s = -16401;
                v30 = -67;
                std::string::append(this, __s, 3uLL);
LABEL_13:
                v5 = *(std::string::value_type **)(a1 + 24);
                v4 = *(unsigned __int8 **)(a1 + 32);
                if (v5 == (std::string::value_type *)v4)
                {
                  v6 = 0;
                }
                else
                {
                  *(_QWORD *)(a1 + 24) = v5 + 1;
                  v6 = *v5++;
                }
                if (v6 == 34)
                  return 1;
                continue;
              default:
                if (v11 == 98)
                {
                  v10 = this;
                  v9 = 8;
                  break;
                }
                if (v11 != 102)
                  goto LABEL_78;
                v10 = this;
                v9 = 12;
                break;
            }
LABEL_12:
            std::string::push_back(v10, v9);
            goto LABEL_13;
          }
          if (v11 != 34 && v11 != 47 && v11 != 92)
          {
LABEL_78:
            v28 = "Invalid escape sequence";
            break;
          }
          v9 = *v5;
        }
        else
        {
          v9 = v6;
        }
        v10 = this;
        goto LABEL_12;
      }
      v28 = "Control character in string";
    }
    break;
  }
LABEL_76:
  sub_1C5E160FC(a1, (uint64_t)v28);
  return 0;
}

void sub_1C5E165D8(unsigned int a1, std::string *this)
{
  char v3;
  unsigned int v4;
  char v5;
  unsigned int v6;
  unsigned int v7;
  char v8;

  if (a1 > 0x7F)
  {
    if (a1 > 0x7FF)
    {
      if (HIWORD(a1))
      {
        v6 = (a1 >> 12) & 0x3F | 0xFFFFFF80;
        v7 = (a1 >> 6) & 0x3F | 0xFFFFFF80;
        v8 = a1 & 0x3F | 0x80;
        std::string::push_back(this, (a1 >> 18) | 0xF0);
        std::string::push_back(this, v6);
        std::string::push_back(this, v7);
        LOBYTE(a1) = v8;
      }
      else
      {
        v4 = (a1 >> 6) & 0x3F | 0xFFFFFF80;
        v5 = a1 & 0x3F | 0x80;
        std::string::push_back(this, (a1 >> 12) | 0xE0);
        std::string::push_back(this, v4);
        LOBYTE(a1) = v5;
      }
    }
    else
    {
      v3 = a1 & 0x3F | 0x80;
      std::string::push_back(this, (a1 >> 6) | 0xC0);
      LOBYTE(a1) = v3;
    }
  }
  std::string::push_back(this, a1);
}

unsigned __int16 *sub_1C5E166B4(unsigned __int16 **a1, __n128 a2)
{
  unsigned __int16 *v2;
  unsigned __int16 *v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  char *v9;
  unsigned __int16 *v10;
  unsigned __int16 *v11;
  unsigned __int16 *v12;
  void **v13;

  v3 = *a1;
  v2 = a1[1];
  v4 = ((char *)v2 - (char *)*a1) >> 5;
  v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 59)
    abort();
  v7 = (char *)a1[2] - (char *)v3;
  if (v7 >> 4 > v5)
    v5 = v7 >> 4;
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFE0)
    v8 = 0x7FFFFFFFFFFFFFFLL;
  else
    v8 = v5;
  if (v8)
  {
    if (v8 >> 59)
      sub_1C4764EE4();
    v9 = (char *)operator new(32 * v8);
  }
  else
  {
    v9 = 0;
  }
  v10 = (unsigned __int16 *)&v9[32 * v4];
  v11 = (unsigned __int16 *)&v9[32 * v8];
  *v10 = 0;
  v12 = v10 + 16;
  if (v2 == v3)
  {
    *a1 = v10;
    a1[1] = v12;
    a1[2] = v11;
  }
  else
  {
    do
    {
      v10 -= 16;
      v2 -= 16;
      a2 = llvm::json::Value::moveFrom((uint64_t)v10, v2, a2);
    }
    while (v2 != v3);
    v2 = *a1;
    v13 = (void **)a1[1];
    *a1 = v10;
    a1[1] = v12;
    a1[2] = v11;
    while (v13 != (void **)v2)
    {
      v13 -= 4;
      llvm::json::Value::destroy(v13);
    }
  }
  if (v2)
    operator delete(v2);
  return v12;
}

uint64_t *sub_1C5E167B0(uint64_t *a1, uint64_t a2)
{
  uint64_t *result;
  uint64_t v5;

  sub_1C4D65F7C(a1);
  result = (uint64_t *)MEMORY[0x1CAA32FB4](*a1, 8);
  v5 = *(unsigned int *)(a2 + 16);
  *((_DWORD *)a1 + 4) = v5;
  if ((_DWORD)v5)
  {
    *a1 = (uint64_t)operator new(56 * v5, (std::align_val_t)8uLL);
    return sub_1C5E16818(a1, (_QWORD *)a2);
  }
  else
  {
    *a1 = 0;
    a1[1] = 0;
  }
  return result;
}

uint64_t *sub_1C5E16818(uint64_t *result, _QWORD *a2)
{
  uint64_t *v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  __int128 **v7;
  uint64_t v8;

  result[1] = a2[1];
  if (*((_DWORD *)result + 4))
  {
    v3 = result;
    v4 = 0;
    v5 = 0;
    do
    {
      v6 = (uint64_t *)(*v3 + v4);
      v7 = (__int128 **)(*a2 + v4);
      *v6 = 0;
      v6[1] = 0;
      v6[2] = 0;
      result = sub_1C4D65828(v6, v7);
      v8 = *v3 + v4;
      if (*(_QWORD *)(v8 + 8) <= 0xFFFFFFFFFFFFFFFDLL)
        result = (uint64_t *)llvm::json::Value::copyFrom((llvm::json::Value *)(v8 + 24), (const llvm::json::Value *)(*a2 + v4 + 24));
      ++v5;
      v4 += 56;
    }
    while (v5 < *((unsigned int *)v3 + 4));
  }
  return result;
}

_QWORD *sub_1C5E168B0(_QWORD *result, const llvm::json::Value *a2, const llvm::json::Value *a3, unint64_t a4)
{
  _QWORD *v7;
  llvm::json::Value *v8;

  if (a4)
  {
    if (a4 >> 59)
      abort();
    v7 = result;
    result = operator new(32 * a4);
    v8 = (llvm::json::Value *)result;
    *v7 = result;
    v7[1] = result;
    v7[2] = &result[4 * a4];
    while (a2 != a3)
    {
      result = (_QWORD *)llvm::json::Value::copyFrom(v8, a2);
      a2 = (const llvm::json::Value *)((char *)a2 + 32);
      v8 = (llvm::json::Value *)((char *)v8 + 32);
    }
    v7[1] = v8;
  }
  return result;
}

uint64_t sub_1C5E16934@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, unsigned int a4@<W3>, uint64_t a5@<X8>)
{
  uint64_t v9;
  unint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  unint64_t v22;
  void *v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t *v26;
  uint64_t *v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  _BOOL4 v31;
  uint64_t result;
  uint64_t v33;
  unint64_t v34;
  void *v35;
  uint64_t *v36;
  unint64_t v37;
  _QWORD *v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t *v41;
  _QWORD *v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t *v48;
  _QWORD *v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t *v52;
  _QWORD *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t *v57;
  unint64_t v58;
  _QWORD *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t *v64;
  unint64_t v65;
  _QWORD *v66;
  uint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t *v70;
  _QWORD *v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t *v74;
  _QWORD *v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t *v78;
  _QWORD *v79;
  uint64_t v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  uint64_t *v84;
  _QWORD *v85;
  uint64_t v86;
  size_t v87;
  unint64_t v88;
  uint64_t *v89;
  _QWORD *v90;
  uint64_t v91;
  uint64_t v92;
  unint64_t v93;
  unint64_t *v94;
  uint64_t *v95;
  unint64_t v96;
  uint64_t v97;
  unint64_t v98;
  _BOOL4 v99;
  unint64_t v100;
  unint64_t v102;
  unsigned int v103;
  _QWORD *v104;
  unsigned int v105;
  unint64_t v106;
  unsigned int v107;
  unint64_t v108;
  unsigned int v109;
  _QWORD *v110;
  unsigned int v111;
  void *v112;
  unsigned int v113;

  v9 = *(unsigned int *)(a1 + 8);
  v113 = v9;
  if (v9 > 0x40)
  {
    v112 = (void *)operator new[]();
    memcpy(v112, *(const void **)a1, ((unint64_t)(v9 + 63) >> 3) & 0x3FFFFFF8);
    llvm::APInt::flipAllBitsSlowCase((uint64_t)&v112);
    LODWORD(v9) = v113;
    v11 = (uint64_t *)v112;
  }
  else
  {
    v10 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v9;
    if (!(_DWORD)v9)
      v10 = 0;
    v11 = (uint64_t *)(v10 & ~*(_QWORD *)a1);
  }
  v12 = *(unsigned int *)(a2 + 8);
  v113 = v12;
  if (v12 > 0x40)
  {
    v87 = ((unint64_t)(v12 + 63) >> 3) & 0x3FFFFFF8;
    v112 = (void *)operator new[]();
    memcpy(v112, *(const void **)a2, v87);
    llvm::APInt::flipAllBitsSlowCase((uint64_t)&v112);
    LODWORD(v12) = v113;
    v15 = v112;
    if (v113 > 0x40)
    {
      v92 = 0;
      v93 = ((unint64_t)v113 + 63) >> 6;
      v94 = (unint64_t *)v112;
      v95 = v11;
      v96 = v93;
      do
      {
        v97 = *v95++;
        v98 = v97 + *v94;
        v99 = v98 + 1 <= *v94;
        if (v92)
        {
          ++v98;
          v92 = v99;
        }
        else
        {
          v92 = v98 < *v94;
        }
        *v94++ = v98;
        --v96;
      }
      while (v96);
      v15[(v93 - 1)] &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v12;
      goto LABEL_13;
    }
    v13 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v113;
  }
  else
  {
    v13 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v12;
    if ((_DWORD)v12)
      v14 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v12;
    else
      v14 = 0;
    v15 = (_QWORD *)(v14 & ~*(_QWORD *)a2);
  }
  v16 = (unint64_t)v11 + (_QWORD)v15;
  if (!(_DWORD)v12)
    v13 = 0;
  v15 = (_QWORD *)(v13 & v16);
LABEL_13:
  v111 = v12;
  v110 = v15;
  llvm::APInt::operator+=((uint64_t)&v110, a3 ^ 1u);
  v17 = v111;
  v18 = (unint64_t)v110;
  v111 = 0;
  if (v9 >= 0x41 && v11)
    MEMORY[0x1CAA32F9C](v11, 0x1000C8000313F17);
  v19 = *(unsigned int *)(a1 + 24);
  if (v19 > 0x40)
  {
    v20 = (void *)operator new[]();
    memcpy(v20, *(const void **)(a1 + 16), ((unint64_t)(v19 + 63) >> 3) & 0x3FFFFFF8);
  }
  else
  {
    v20 = *(void **)(a1 + 16);
  }
  v21 = *(unsigned int *)(a2 + 24);
  if (v21 >= 0x41)
  {
    v23 = (void *)operator new[]();
    memcpy(v23, *(const void **)(a2 + 16), ((unint64_t)(v21 + 63) >> 3) & 0x3FFFFFF8);
    v24 = 0;
    v25 = (unint64_t)(v21 + 63) >> 6;
    v26 = (unint64_t *)v23;
    v27 = (uint64_t *)v20;
    v28 = v25;
    do
    {
      v29 = *v27++;
      v30 = v29 + *v26;
      v31 = v30 + 1 <= *v26;
      if (v24)
      {
        ++v30;
        v24 = v31;
      }
      else
      {
        v24 = v30 < *v26;
      }
      *v26++ = v30;
      --v28;
    }
    while (v28);
    *((_QWORD *)v23 + (v25 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v21;
  }
  else
  {
    v22 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v21;
    if (!(_DWORD)v21)
      v22 = 0;
    v23 = (void *)(v22 & ((unint64_t)v20 + *(_QWORD *)(a2 + 16)));
  }
  v109 = v21;
  v108 = (unint64_t)v23;
  result = llvm::APInt::operator+=((uint64_t)&v108, a4);
  v33 = v109;
  v102 = v108;
  v109 = 0;
  if (v19 >= 0x41 && v20)
    result = MEMORY[0x1CAA32F9C](v20, 0x1000C8000313F17);
  if (v17 >= 0x41)
  {
    v35 = (void *)operator new[]();
    memcpy(v35, (const void *)v18, ((unint64_t)(v17 + 63) >> 3) & 0x3FFFFFF8);
    v36 = *(uint64_t **)a1;
    v37 = (unint64_t)(v17 + 63) >> 6;
    v38 = v35;
    v39 = v37;
    do
    {
      v40 = *v36++;
      *v38++ ^= v40;
      --v39;
    }
    while (v39);
    v41 = *(uint64_t **)a2;
    v42 = v35;
    do
    {
      v43 = *v41++;
      *v42++ ^= v43;
      --v37;
    }
    while (v37);
    v107 = v17;
    v106 = (unint64_t)v35;
    result = llvm::APInt::flipAllBitsSlowCase((uint64_t)&v106);
    v103 = v107;
    v100 = v106;
  }
  else
  {
    v34 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v17;
    if (!(_DWORD)v17)
      v34 = 0;
    v100 = v34 & (*(_QWORD *)a1 ^ *(_QWORD *)a2 ^ ~v18);
    v103 = v17;
  }
  v44 = v102;
  if (v33 >= 0x41)
  {
    v46 = operator new[]();
    result = (uint64_t)memcpy((void *)v46, (const void *)v102, ((unint64_t)(v33 + 63) >> 3) & 0x3FFFFFF8);
    v45 = *(_QWORD *)(a1 + 16);
    v47 = (unint64_t)(v33 + 63) >> 6;
    v48 = (uint64_t *)v45;
    v49 = (_QWORD *)v46;
    v50 = v47;
    do
    {
      v51 = *v48++;
      *v49++ ^= v51;
      --v50;
    }
    while (v50);
    v52 = *(uint64_t **)(a2 + 16);
    v53 = (_QWORD *)v46;
    do
    {
      v54 = *v52++;
      *v53++ ^= v54;
      --v47;
    }
    while (v47);
  }
  else
  {
    v45 = *(_QWORD *)(a1 + 16);
    v46 = v45 ^ *(_QWORD *)(a2 + 16) ^ v102;
  }
  v55 = *(unsigned int *)(a1 + 8);
  if (v55 > 0x40)
  {
    v56 = operator new[]();
    result = (uint64_t)memcpy((void *)v56, *(const void **)a1, ((unint64_t)(v55 + 63) >> 3) & 0x3FFFFFF8);
    v57 = *(uint64_t **)(a1 + 16);
    v58 = (unint64_t)(v55 + 63) >> 6;
    v59 = (_QWORD *)v56;
    do
    {
      v60 = *v57++;
      *v59++ |= v60;
      --v58;
    }
    while (v58);
  }
  else
  {
    v56 = v45 | *(_QWORD *)a1;
  }
  v61 = *(unsigned int *)(a2 + 8);
  if (v61 > 0x40)
  {
    v62 = operator new[]();
    result = (uint64_t)memcpy((void *)v62, *(const void **)a2, ((unint64_t)(v61 + 63) >> 3) & 0x3FFFFFF8);
    v64 = *(uint64_t **)(a2 + 16);
    v65 = (unint64_t)(v61 + 63) >> 6;
    v66 = (_QWORD *)v62;
    do
    {
      v67 = *v64++;
      *v66++ |= v67;
      --v65;
    }
    while (v65);
    v63 = a5;
    v44 = v102;
  }
  else
  {
    v62 = *(_QWORD *)(a2 + 16) | *(_QWORD *)a2;
    v63 = a5;
  }
  v68 = v100;
  if (v103 > 0x40)
  {
    v69 = ((unint64_t)v103 + 63) >> 6;
    v70 = (uint64_t *)v46;
    v71 = (_QWORD *)v100;
    do
    {
      v72 = *v70++;
      *v71++ |= v72;
      --v69;
    }
    while (v69);
  }
  else
  {
    v68 = v46 | v100;
  }
  if (v55 >= 0x41)
  {
    v73 = (unint64_t)(v55 + 63) >> 6;
    v74 = (uint64_t *)v62;
    v75 = (_QWORD *)v56;
    v76 = v73;
    do
    {
      v77 = *v74++;
      *v75++ &= v77;
      --v76;
    }
    while (v76);
    v78 = (uint64_t *)v68;
    v79 = (_QWORD *)v56;
    do
    {
      v80 = *v78++;
      *v79++ &= v80;
      --v73;
    }
    while (v73);
  }
  else
  {
    v56 &= v62 & v68;
  }
  v105 = v17;
  v104 = (_QWORD *)v18;
  if (v17 > 0x40)
  {
    result = llvm::APInt::flipAllBitsSlowCase((uint64_t)&v104);
    LODWORD(v17) = v105;
    v82 = (unint64_t)v104;
    if (v105 > 0x40)
    {
      v88 = ((unint64_t)v105 + 63) >> 6;
      v89 = (uint64_t *)v56;
      v90 = v104;
      do
      {
        v91 = *v89++;
        *v90++ &= v91;
        --v88;
      }
      while (v88);
      v63 = a5;
      v44 = v102;
      goto LABEL_71;
    }
    v63 = a5;
    v44 = v102;
  }
  else
  {
    v81 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v17;
    if (!(_DWORD)v17)
      v81 = 0;
    v82 = v81 & ~v18;
  }
  v82 &= v56;
LABEL_71:
  *(_QWORD *)v63 = v82;
  *(_DWORD *)(v63 + 8) = v17;
  if (v33 > 0x40)
  {
    v83 = (unint64_t)(v33 + 63) >> 6;
    v84 = (uint64_t *)v56;
    v85 = (_QWORD *)v44;
    do
    {
      v86 = *v84++;
      *v85++ &= v86;
      --v83;
    }
    while (v83);
  }
  else
  {
    v44 &= v56;
  }
  *(_QWORD *)(v63 + 16) = v44;
  *(_DWORD *)(v63 + 24) = v33;
  if (v55 >= 0x41 && v56)
    result = MEMORY[0x1CAA32F9C](v56, 0x1000C8000313F17);
  if (v103 >= 0x41 && v68)
    result = MEMORY[0x1CAA32F9C](v68, 0x1000C8000313F17);
  if (v61 >= 0x41 && v62)
    result = MEMORY[0x1CAA32F9C](v62, 0x1000C8000313F17);
  if (v33 >= 0x41)
  {
    if (v46)
      return MEMORY[0x1CAA32F9C](v46, 0x1000C8000313F17);
  }
  return result;
}

uint64_t llvm::KnownBits::computeForAddSub@<X0>(int a1@<W0>, int a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  uint64_t result;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int v21;
  _QWORD *v22;
  uint64_t *v23;
  uint64_t v24;
  unsigned int v25;
  _QWORD *v26;
  _QWORD *v27;
  uint64_t v28;
  unsigned int v30;
  char v31;
  unsigned int v32;
  _QWORD *v33;
  unsigned int v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  _QWORD *v39;
  _QWORD *v40;
  unsigned int v41;
  unsigned int v42;
  uint64_t v43;
  unsigned int v44;
  uint64_t v45;
  unsigned int v46;

  v9 = (uint64_t *)(a5 + 16);
  if (a1)
  {
    v10 = a3;
    v11 = a4;
    v12 = 1;
    v13 = 0;
  }
  else
  {
    v14 = *(_DWORD *)(a4 + 8);
    v15 = *(_QWORD *)a4;
    *(_QWORD *)a4 = *(_QWORD *)(a4 + 16);
    *(_DWORD *)(a4 + 8) = *(_DWORD *)(a4 + 24);
    *(_QWORD *)(a4 + 16) = v15;
    *(_DWORD *)(a4 + 24) = v14;
    v10 = a3;
    v11 = a4;
    v12 = 0;
    v13 = 1;
  }
  result = sub_1C5E16934(v10, v11, v12, v13, (uint64_t)&v43);
  v17 = v43;
  v18 = v44;
  v19 = v45;
  v20 = v46;
  *(_QWORD *)a5 = v43;
  *(_DWORD *)(a5 + 8) = v18;
  *(_QWORD *)(a5 + 16) = v19;
  *(_DWORD *)(a5 + 24) = v20;
  v21 = v20 - 1;
  if (v20 >= 0x41)
    v23 = (uint64_t *)(v19 + 8 * (v21 >> 6));
  else
    v23 = v9;
  v24 = 1 << v21;
  if ((v24 & *v23) == 0)
  {
    v25 = v18 - 1;
    v27 = (_QWORD *)(v18 >= 0x41 ? v17 + 8 * (v25 >> 6) : a5);
    v28 = 1 << v25;
    if ((*v27 & v28) == 0 && a2 != 0)
    {
      v30 = *(_DWORD *)(a3 + 8);
      v31 = v30 - 1;
      v32 = (v30 - 1) >> 6;
      result = *(_QWORD *)a3 + 8 * v32;
      if (v30 >= 0x41)
        v33 = (_QWORD *)(*(_QWORD *)a3 + 8 * v32);
      else
        v33 = (_QWORD *)a3;
      if (((*v33 >> v31) & 1) == 0)
        goto LABEL_26;
      result = *(unsigned int *)(a4 + 8);
      v34 = result - 1;
      v35 = (_QWORD *)a4;
      if (result >= 0x41)
      {
        result = v34 >> 6;
        v35 = (_QWORD *)(*(_QWORD *)a4 + 8 * result);
      }
      if (((*v35 >> v34) & 1) != 0)
      {
        if (v18 > 0x40)
        {
          v26 = (_QWORD *)(v17 + 8 * ((v18 - 1) >> 6));
          *v26 |= v28;
        }
        else
        {
          *(_QWORD *)a5 = v28 | v17;
        }
      }
      else
      {
LABEL_26:
        v37 = *(_QWORD *)(a3 + 16);
        v36 = a3 + 16;
        v38 = *(_DWORD *)(v36 + 8);
        v39 = (_QWORD *)(v37 + 8 * ((v38 - 1) >> 6));
        if (v38 < 0x41)
          v39 = (_QWORD *)v36;
        if (((*v39 >> (v38 - 1)) & 1) != 0)
        {
          v40 = (_QWORD *)(a4 + 16);
          v41 = *(_DWORD *)(a4 + 24);
          v42 = v41 - 1;
          if (v41 >= 0x41)
            v40 = (_QWORD *)(*v40 + 8 * (v42 >> 6));
          if (((*v40 >> v42) & 1) != 0)
          {
            if (v20 > 0x40)
            {
              v22 = (_QWORD *)(v19 + 8 * ((v20 - 1) >> 6));
              *v22 |= v24;
            }
            else
            {
              *v9 = v24 | v19;
            }
          }
        }
      }
    }
  }
  return result;
}

unsigned int *llvm::KnownBits::sextInReg@<X0>(llvm::KnownBits *this@<X0>, int a2@<W1>, unsigned int *a3@<X8>)
{
  int v5;
  unsigned int v6;
  unint64_t *v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  unsigned int *result;
  unsigned int v12;
  unsigned int v13;
  char v14;
  uint64_t v15;
  unint64_t v16;
  char v17;
  uint64_t v18;
  unint64_t v19;
  size_t v20;
  size_t v21;
  void *v22;
  unsigned int v23;

  v5 = *((_DWORD *)this + 2);
  v6 = v5 - a2;
  if (v5 == a2)
    return (unsigned int *)sub_1C5CC921C((uint64_t)a3, (const void **)this);
  a3[2] = 1;
  *(_QWORD *)a3 = 0;
  *((_QWORD *)a3 + 2) = 0;
  v7 = (unint64_t *)(a3 + 4);
  a3[6] = 1;
  v8 = *((unsigned int *)this + 6);
  v23 = v8;
  if (v8 > 0x40)
  {
    v20 = ((unint64_t)(v8 + 63) >> 3) & 0x3FFFFFF8;
    v9 = (void *)operator new[]();
    memcpy(v9, *((const void **)this + 2), v20);
  }
  else
  {
    v9 = (void *)*((_QWORD *)this + 2);
  }
  v22 = v9;
  sub_1C4888094((uint64_t)&v22, v6);
  if (a3[6] >= 0x41 && *v7)
    MEMORY[0x1CAA32F9C](*v7, 0x1000C8000313F17);
  *((_QWORD *)a3 + 2) = v22;
  a3[6] = v23;
  v10 = *((unsigned int *)this + 2);
  v23 = v10;
  if (v10 > 0x40)
  {
    v21 = ((unint64_t)(v10 + 63) >> 3) & 0x3FFFFFF8;
    v22 = (void *)operator new[]();
    memcpy(v22, *(const void **)this, v21);
  }
  else
  {
    v22 = *(void **)this;
  }
  result = (unsigned int *)sub_1C4888094((uint64_t)&v22, v6);
  if (a3[2] >= 0x41)
  {
    result = *(unsigned int **)a3;
    if (*(_QWORD *)a3)
      result = (unsigned int *)MEMORY[0x1CAA32F9C](result, 0x1000C8000313F17);
  }
  *(_QWORD *)a3 = v22;
  v12 = v23;
  a3[2] = v23;
  v13 = a3[6];
  if (v13 > 0x40)
  {
    result = llvm::APInt::ashrSlowCase(a3 + 4, v6);
    v12 = a3[2];
  }
  else
  {
    if (v13 == v6)
      v14 = 63;
    else
      v14 = v6;
    v15 = (uint64_t)(*v7 << -(char)v13) >> -(char)v13 >> v14;
    if (v13)
      v16 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v13;
    else
      v16 = 0;
    *v7 = v16 & v15;
  }
  if (v12 > 0x40)
    return llvm::APInt::ashrSlowCase(a3, v6);
  if (v12 == v6)
    v17 = 63;
  else
    v17 = v6;
  v18 = (uint64_t)(*(_QWORD *)a3 << -(char)v12) >> -(char)v12 >> v17;
  if (v12)
    v19 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v12;
  else
    v19 = 0;
  *(_QWORD *)a3 = v19 & v18;
  return result;
}

char *llvm::KnownBits::makeGE@<X0>(const void **this@<X0>, const void **a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6;
  int v7;
  size_t v8;
  char *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  char *result;
  uint64_t v16;
  size_t v17;
  int v18;
  uint64_t v19;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  void *v24;
  unint64_t v25;
  uint64_t *v26;
  _QWORD *v27;
  uint64_t v28;
  unint64_t v29;
  unsigned int v30;

  v6 = *((unsigned int *)this + 2);
  if (v6 >= 0x41)
  {
    v8 = ((unint64_t)(v6 + 63) >> 3) & 0x3FFFFFF8;
    v9 = (char *)operator new[]();
    memcpy(v9, *this, v8);
    v10 = 0;
    v11 = (char *)*a2;
    do
    {
      *(_QWORD *)&v9[v10] |= *(_QWORD *)&v11[v10];
      v10 += 8;
    }
    while (v8 != v10);
    v30 = v6;
    v29 = (unint64_t)v9;
    v7 = llvm::APInt::countLeadingOnesSlowCase((llvm::APInt *)&v29);
    MEMORY[0x1CAA32F9C](v9, 0x1000C8000313F17);
  }
  else if ((_DWORD)v6)
  {
    v7 = __clz(~(((unint64_t)*a2 | (unint64_t)*this) << -(char)v6));
  }
  else
  {
    v7 = 0;
  }
  v12 = *((unsigned int *)a2 + 2);
  if (v12 > 0x40)
  {
    v17 = ((unint64_t)(v12 + 63) >> 3) & 0x3FFFFFF8;
    v16 = operator new[]();
    memcpy((void *)v16, *a2, v17);
    v18 = *((_DWORD *)this + 2) - (v12 + v7);
    v30 = v12;
    llvm::APInt::initSlowCase((llvm::APInt *)&v29, 0, 0);
    sub_1C4912E54(&v29, v18 + v30, v30);
    v19 = 0;
    result = (char *)v29;
    do
    {
      *(_QWORD *)(v16 + v19) &= *(_QWORD *)&result[v19];
      v19 += 8;
    }
    while (v17 != v19);
  }
  else
  {
    v13 = (unint64_t)*a2;
    v14 = *((_DWORD *)this + 2);
    v30 = *((_DWORD *)a2 + 2);
    v29 = 0;
    sub_1C4912E54(&v29, v14 - v7, v12);
    result = (char *)v29;
    v16 = v29 & v13;
  }
  if (v30 >= 0x41 && result != 0)
    result = (char *)MEMORY[0x1CAA32F9C]();
  v21 = *((unsigned int *)this + 2);
  if (v21 > 0x40)
  {
    v22 = (void *)operator new[]();
    result = (char *)memcpy(v22, *this, ((unint64_t)(v21 + 63) >> 3) & 0x3FFFFFF8);
  }
  else
  {
    v22 = (void *)*this;
  }
  v23 = *((unsigned int *)this + 6);
  if (v23 > 0x40)
  {
    v24 = (void *)operator new[]();
    result = (char *)memcpy(v24, this[2], ((unint64_t)(v23 + 63) >> 3) & 0x3FFFFFF8);
    v25 = (unint64_t)(v23 + 63) >> 6;
    v26 = (uint64_t *)v16;
    v27 = v24;
    do
    {
      v28 = *v26++;
      *v27++ |= v28;
      --v25;
    }
    while (v25);
  }
  else
  {
    v24 = (void *)((unint64_t)this[2] | v16);
  }
  *(_DWORD *)(a3 + 8) = v21;
  *(_QWORD *)a3 = v22;
  *(_DWORD *)(a3 + 24) = v23;
  *(_QWORD *)(a3 + 16) = v24;
  if (v12 >= 0x41)
  {
    if (v16)
      return (char *)MEMORY[0x1CAA32F9C](v16, 0x1000C8000313F17);
  }
  return result;
}

uint64_t llvm::KnownBits::umax@<X0>(const void **this@<X0>, const void **a2@<X1>, const llvm::KnownBits *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  int v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  void *v22;
  unint64_t v23;
  unint64_t v24;
  unsigned int v25;
  void *v26;
  uint64_t result;
  unint64_t v28;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  size_t v37;
  size_t v38;
  void *v39;
  void *v40;
  size_t v41;
  char *v42;
  size_t v43;
  char *v44;
  size_t v45;
  void *v46;
  size_t v47;
  void *v48;
  size_t v49;
  char *v50;
  uint64_t v51;
  size_t v52;
  uint64_t v53;
  void *v54;
  unsigned int v55;
  char *v56;
  char *v57;
  char *v58;
  uint64_t v59;
  char *v60;
  uint64_t v61;
  char *v62;
  char *v63;
  unint64_t v64;
  const void *v65;
  int v66;
  unint64_t v67;
  unsigned int v68;
  uint64_t v69;
  unsigned int v70;
  void *__src;
  unsigned int v72;
  void *v73;
  unsigned int v74;

  v7 = *((unsigned int *)this + 6);
  if (v7 > 0x40)
  {
    v41 = ((unint64_t)(v7 + 63) >> 3) & 0x3FFFFFF8;
    v59 = *((unsigned int *)this + 6);
    v42 = (char *)operator new[]();
    memcpy(v42, this[2], v41);
    v8 = v42;
    v7 = v59;
  }
  else
  {
    v8 = (char *)this[2];
  }
  v9 = *((unsigned int *)a2 + 2);
  v72 = v9;
  if (v9 > 0x40)
  {
    v37 = ((unint64_t)(v9 + 63) >> 3) & 0x3FFFFFF8;
    v57 = v8;
    __src = (void *)operator new[]();
    memcpy(__src, *a2, v37);
    llvm::APInt::flipAllBitsSlowCase((uint64_t)&__src);
    v8 = v57;
    LODWORD(v9) = v72;
    v11 = (char *)__src;
  }
  else
  {
    v10 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v9;
    if (!(_DWORD)v9)
      v10 = 0;
    v11 = (char *)(v10 & ~(unint64_t)*a2);
  }
  if (v7 > 0x40)
  {
    v31 = ((unint64_t)(v7 + 63) >> 3) & 0x3FFFFFF8;
    do
    {
      if (!v31)
      {
        v12 = 0;
        goto LABEL_11;
      }
      v32 = *(_QWORD *)&v8[v31 - 8];
      v33 = *(_QWORD *)&v11[v31 - 8];
      v31 -= 8;
    }
    while (v32 == v33);
    if (v32 > v33)
      v12 = 1;
    else
      v12 = -1;
  }
  else if (v8 < v11)
  {
    v12 = -1;
  }
  else
  {
    v12 = v8 > v11;
  }
LABEL_11:
  if (v9 >= 0x41 && v11)
  {
    v60 = v8;
    MEMORY[0x1CAA32F9C](v11, 0x1000C8000313F17, a3);
    v8 = v60;
  }
  if (v7 >= 0x41 && v8)
    MEMORY[0x1CAA32F9C](v8, 0x1000C8000313F17, a3);
  if ((v12 & 0x80000000) == 0)
    return sub_1C5CC921C(a4, this);
  v13 = *((unsigned int *)a2 + 6);
  if (v13 > 0x40)
  {
    v43 = ((unint64_t)(v13 + 63) >> 3) & 0x3FFFFFF8;
    v61 = *((unsigned int *)a2 + 6);
    v44 = (char *)operator new[]();
    memcpy(v44, a2[2], v43);
    v14 = v44;
    v13 = v61;
  }
  else
  {
    v14 = (char *)a2[2];
  }
  v15 = *((unsigned int *)this + 2);
  v72 = v15;
  if (v15 > 0x40)
  {
    v38 = ((unint64_t)(v15 + 63) >> 3) & 0x3FFFFFF8;
    v58 = v14;
    __src = (void *)operator new[]();
    memcpy(__src, *this, v38);
    llvm::APInt::flipAllBitsSlowCase((uint64_t)&__src);
    v14 = v58;
    LODWORD(v15) = v72;
    v17 = (char *)__src;
  }
  else
  {
    v16 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v15;
    if (!(_DWORD)v15)
      v16 = 0;
    v17 = (char *)(v16 & ~(unint64_t)*this);
  }
  if (v13 > 0x40)
  {
    v34 = ((unint64_t)(v13 + 63) >> 3) & 0x3FFFFFF8;
    do
    {
      if (!v34)
      {
        v18 = 0;
        goto LABEL_24;
      }
      v35 = *(_QWORD *)&v14[v34 - 8];
      v36 = *(_QWORD *)&v17[v34 - 8];
      v34 -= 8;
    }
    while (v35 == v36);
    if (v35 > v36)
      v18 = 1;
    else
      v18 = -1;
  }
  else if (v14 < v17)
  {
    v18 = -1;
  }
  else
  {
    v18 = v14 > v17;
  }
LABEL_24:
  if (v15 >= 0x41 && v17)
  {
    v62 = v14;
    MEMORY[0x1CAA32F9C](v17, 0x1000C8000313F17, a3);
    v14 = v62;
  }
  if (v13 >= 0x41 && v14)
    MEMORY[0x1CAA32F9C](v14, 0x1000C8000313F17, a3);
  if ((v18 & 0x80000000) == 0)
    return sub_1C5CC921C(a4, a2);
  v19 = *((unsigned int *)a2 + 6);
  v68 = v19;
  if (v19 > 0x40)
  {
    v45 = ((unint64_t)(v19 + 63) >> 3) & 0x3FFFFFF8;
    v46 = (void *)operator new[]();
    v67 = (unint64_t)v46;
    memcpy(v46, a2[2], v45);
    llvm::KnownBits::makeGE(this, (const void **)&v67, (uint64_t)&__src);
    MEMORY[0x1CAA32F9C](v46, 0x1000C8000313F17);
  }
  else
  {
    v67 = (unint64_t)a2[2];
    llvm::KnownBits::makeGE(this, (const void **)&v67, (uint64_t)&__src);
  }
  v20 = *((unsigned int *)this + 6);
  v66 = v20;
  if (v20 > 0x40)
  {
    v47 = ((unint64_t)(v20 + 63) >> 3) & 0x3FFFFFF8;
    v48 = (void *)operator new[]();
    v65 = v48;
    memcpy(v48, this[2], v47);
    llvm::KnownBits::makeGE(a2, &v65, (uint64_t)&v67);
    MEMORY[0x1CAA32F9C](v48, 0x1000C8000313F17);
  }
  else
  {
    v65 = this[2];
    llvm::KnownBits::makeGE(a2, &v65, (uint64_t)&v67);
  }
  v21 = v72;
  if (v72 > 0x40)
  {
    v49 = (((unint64_t)v72 + 63) >> 3) & 0x3FFFFFF8;
    v50 = (char *)operator new[]();
    v22 = __src;
    v63 = v50;
    memcpy(v50, __src, v49);
    v51 = 0;
    v23 = v67;
    do
    {
      *(_QWORD *)&v63[v51] &= *(_QWORD *)(v23 + v51);
      v51 += 8;
    }
    while (v49 != v51);
    v24 = (unint64_t)v63;
  }
  else
  {
    v22 = __src;
    v23 = v67;
    v24 = v67 & (unint64_t)__src;
  }
  v25 = v74;
  if (v74 > 0x40)
  {
    v64 = v24;
    v55 = v74;
    v52 = (((unint64_t)v74 + 63) >> 3) & 0x3FFFFFF8;
    v56 = (char *)operator new[]();
    v54 = v73;
    memcpy(v56, v73, v52);
    v53 = 0;
    result = v69;
    do
    {
      *(_QWORD *)&v56[v53] &= *(_QWORD *)(result + v53);
      v53 += 8;
    }
    while (v52 != v53);
    v28 = (unint64_t)v56;
    v24 = v64;
    v26 = v54;
    v25 = v55;
  }
  else
  {
    v26 = v73;
    result = v69;
    v28 = v69 & (unint64_t)v73;
  }
  *(_DWORD *)(a4 + 8) = v21;
  *(_QWORD *)a4 = v24;
  *(_DWORD *)(a4 + 24) = v25;
  *(_QWORD *)(a4 + 16) = v28;
  if (v70 >= 0x41 && result != 0)
  {
    v39 = v26;
    result = MEMORY[0x1CAA32F9C]();
    v26 = v39;
  }
  if (v68 >= 0x41 && v23 != 0)
  {
    v40 = v26;
    result = MEMORY[0x1CAA32F9C](v23, 0x1000C8000313F17);
    v26 = v40;
  }
  if (v25 >= 0x41 && v26)
    result = MEMORY[0x1CAA32F9C](v26, 0x1000C8000313F17);
  if (v21 >= 0x41)
  {
    if (v22)
      JUMPOUT(0x1CAA32F9CLL);
  }
  return result;
}

const void *llvm::KnownBits::umin@<X0>(const void **this@<X0>, const void **a2@<X1>, const llvm::KnownBits *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  void *v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  void *v14;
  const void *result;
  unsigned int v16;
  void *v17;
  size_t v18;
  unsigned int v19;
  void *v20;
  size_t v21;
  const void *v22;
  unsigned int v23;
  const void *v24;
  unsigned int v25;
  const void *v26;
  unsigned int v27;
  const void *v28;
  unsigned int v29;
  void *v30;
  unsigned int v31;
  void *__src;
  unsigned int v33;

  v7 = *((unsigned int *)this + 6);
  if (v7 > 0x40)
  {
    v8 = (void *)operator new[]();
    memcpy(v8, this[2], ((unint64_t)(v7 + 63) >> 3) & 0x3FFFFFF8);
  }
  else
  {
    v8 = (void *)this[2];
  }
  v9 = *((unsigned int *)this + 2);
  if (v9 >= 0x41)
  {
    v10 = (void *)operator new[]();
    memcpy(v10, *this, ((unint64_t)(v9 + 63) >> 3) & 0x3FFFFFF8);
  }
  else
  {
    v10 = (void *)*this;
  }
  v27 = v7;
  v26 = v8;
  v29 = v9;
  v28 = v10;
  v11 = *((unsigned int *)a2 + 6);
  if (v11 > 0x40)
  {
    v12 = (void *)operator new[]();
    memcpy(v12, a2[2], ((unint64_t)(v11 + 63) >> 3) & 0x3FFFFFF8);
  }
  else
  {
    v12 = (void *)a2[2];
  }
  v13 = *((unsigned int *)a2 + 2);
  if (v13 >= 0x41)
  {
    v14 = (void *)operator new[]();
    memcpy(v14, *a2, ((unint64_t)(v13 + 63) >> 3) & 0x3FFFFFF8);
  }
  else
  {
    v14 = (void *)*a2;
  }
  v23 = v11;
  v22 = v12;
  v25 = v13;
  v24 = v14;
  result = (const void *)llvm::KnownBits::umax(&v26, &v22, a3, (uint64_t)&v30);
  v16 = v33;
  if (v33 > 0x40)
  {
    v18 = (((unint64_t)v33 + 63) >> 3) & 0x3FFFFFF8;
    v17 = (void *)operator new[]();
    result = memcpy(v17, __src, v18);
  }
  else
  {
    v17 = __src;
  }
  v19 = v31;
  if (v31 >= 0x41)
  {
    v21 = (((unint64_t)v31 + 63) >> 3) & 0x3FFFFFF8;
    v20 = (void *)operator new[]();
    result = memcpy(v20, v30, v21);
  }
  else
  {
    v20 = v30;
  }
  *(_DWORD *)(a4 + 8) = v16;
  *(_QWORD *)a4 = v17;
  *(_DWORD *)(a4 + 24) = v19;
  *(_QWORD *)(a4 + 16) = v20;
  if (v33 >= 0x41)
  {
    result = __src;
    if (__src)
      result = (const void *)MEMORY[0x1CAA32F9C](__src, 0x1000C8000313F17);
  }
  if (v31 >= 0x41)
  {
    result = v30;
    if (v30)
      result = (const void *)MEMORY[0x1CAA32F9C](v30, 0x1000C8000313F17);
  }
  if (v25 >= 0x41)
  {
    result = v24;
    if (v24)
      result = (const void *)MEMORY[0x1CAA32F9C](v24, 0x1000C8000313F17);
  }
  if (v23 >= 0x41)
  {
    result = v22;
    if (v22)
      result = (const void *)MEMORY[0x1CAA32F9C](v22, 0x1000C8000313F17);
  }
  if (v29 >= 0x41)
  {
    result = v28;
    if (v28)
      result = (const void *)MEMORY[0x1CAA32F9C](v28, 0x1000C8000313F17);
  }
  if (v27 >= 0x41)
  {
    result = v26;
    if (v26)
      return (const void *)MEMORY[0x1CAA32F9C](v26, 0x1000C8000313F17);
  }
  return result;
}

uint64_t *llvm::KnownBits::smax@<X0>(llvm::KnownBits *this@<X0>, const llvm::KnownBits *a2@<X1>, uint64_t a3@<X8>)
{
  const llvm::KnownBits *v6;
  uint64_t *result;
  uint64_t *v8;
  unsigned int v9;
  uint64_t *v10;
  unsigned int v11;
  uint64_t *v12;
  unsigned int v13;
  uint64_t *v14;
  unsigned int v15;
  uint64_t *v16;
  unsigned int v17;
  uint64_t *v18;
  unsigned int v19;

  sub_1C5E18368((uint64_t *)this, (uint64_t)&v12);
  sub_1C5E18368((uint64_t *)a2, (uint64_t)&v8);
  llvm::KnownBits::umax((const void **)&v12, (const void **)&v8, v6, (uint64_t)&v16);
  result = sub_1C5E18368((uint64_t *)&v16, a3);
  if (v19 >= 0x41)
  {
    result = v18;
    if (v18)
      result = (uint64_t *)MEMORY[0x1CAA32F9C](v18, 0x1000C8000313F17);
  }
  if (v17 >= 0x41)
  {
    result = v16;
    if (v16)
      result = (uint64_t *)MEMORY[0x1CAA32F9C](v16, 0x1000C8000313F17);
  }
  if (v11 >= 0x41)
  {
    result = v10;
    if (v10)
      result = (uint64_t *)MEMORY[0x1CAA32F9C](v10, 0x1000C8000313F17);
  }
  if (v9 >= 0x41)
  {
    result = v8;
    if (v8)
      result = (uint64_t *)MEMORY[0x1CAA32F9C](v8, 0x1000C8000313F17);
  }
  if (v15 >= 0x41)
  {
    result = v14;
    if (v14)
      result = (uint64_t *)MEMORY[0x1CAA32F9C](v14, 0x1000C8000313F17);
  }
  if (v13 >= 0x41)
  {
    result = v12;
    if (v12)
      return (uint64_t *)MEMORY[0x1CAA32F9C](v12, 0x1000C8000313F17);
  }
  return result;
}

uint64_t *sub_1C5E18368@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t *v2;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  void *v19;

  v2 = result;
  v4 = *((unsigned int *)result + 2);
  v5 = v4 - 1;
  if (v4 > 0x40)
  {
    v6 = operator new[]();
    result = (uint64_t *)memcpy((void *)v6, (const void *)*v2, ((unint64_t)(v4 + 63) >> 3) & 0x3FFFFFF8);
  }
  else
  {
    v6 = *result;
  }
  v7 = v2 + 2;
  v8 = *((unsigned int *)v2 + 6);
  if (v8 > 0x40)
  {
    v9 = operator new[]();
    v11 = (char *)v2[2];
    result = (uint64_t *)memcpy((void *)v9, v11, ((unint64_t)(v8 + 63) >> 3) & 0x3FFFFFF8);
    v10 = v5 >> 6;
    if (*((_DWORD *)v2 + 6) > 0x40u)
      v7 = (uint64_t *)&v11[8 * v10];
  }
  else
  {
    v9 = *v7;
    v10 = v5 >> 6;
  }
  v12 = 1 << v5;
  if ((*v7 & (1 << v5)) != 0)
  {
    if (v4 <= 0x40)
    {
      v6 |= v12;
      goto LABEL_16;
    }
    v14 = *(_QWORD *)(v6 + 8 * v10) | v12;
  }
  else
  {
    v13 = ~v12;
    if (v4 <= 0x40)
    {
      v6 &= v13;
      goto LABEL_16;
    }
    v14 = *(_QWORD *)(v6 + 8 * v10) & v13;
  }
  *(_QWORD *)(v6 + 8 * v10) = v14;
LABEL_16:
  if (*((_DWORD *)v2 + 2) >= 0x41u)
    v15 = (uint64_t *)(*v2 + 8 * v10);
  else
    v15 = v2;
  if ((*v15 & v12) != 0)
  {
    if (v8 <= 0x40)
    {
      v9 |= v12;
      goto LABEL_27;
    }
    v17 = *(_QWORD *)(v9 + 8 * v10) | v12;
  }
  else
  {
    v16 = ~v12;
    if (v8 <= 0x40)
    {
      v9 &= v16;
      goto LABEL_27;
    }
    v17 = *(_QWORD *)(v9 + 8 * v10) & v16;
  }
  *(_QWORD *)(v9 + 8 * v10) = v17;
LABEL_27:
  v18 = (void *)v6;
  if (v4 >= 0x41)
  {
    v18 = (void *)operator new[]();
    result = (uint64_t *)memcpy(v18, (const void *)v6, ((unint64_t)(v4 + 63) >> 3) & 0x3FFFFFF8);
  }
  if (v8 > 0x40)
  {
    v19 = (void *)operator new[]();
    result = (uint64_t *)memcpy(v19, (const void *)v9, ((unint64_t)(v8 + 63) >> 3) & 0x3FFFFFF8);
    *(_DWORD *)(a2 + 8) = v4;
    *(_QWORD *)a2 = v18;
    *(_DWORD *)(a2 + 24) = v8;
    *(_QWORD *)(a2 + 16) = v19;
    if (v9)
      result = (uint64_t *)MEMORY[0x1CAA32F9C](v9, 0x1000C8000313F17);
  }
  else
  {
    *(_DWORD *)(a2 + 8) = v4;
    *(_QWORD *)a2 = v18;
    *(_DWORD *)(a2 + 24) = v8;
    *(_QWORD *)(a2 + 16) = v9;
  }
  if (v4 >= 0x41)
  {
    if (v6)
      JUMPOUT(0x1CAA32F9CLL);
  }
  return result;
}

char *llvm::KnownBits::smin@<X0>(llvm::KnownBits *this@<X0>, const llvm::KnownBits *a2@<X1>, uint64_t a3@<X8>)
{
  const llvm::KnownBits *v6;
  char *result;
  char *v8;
  unsigned int v9;
  char *v10;
  unsigned int v11;
  char *v12;
  unsigned int v13;
  char *v14;
  unsigned int v15;
  char *v16;
  unsigned int v17;
  char *v18;
  unsigned int v19;

  sub_1C5E18760((char *)this, (uint64_t)&v12);
  sub_1C5E18760((char *)a2, (uint64_t)&v8);
  llvm::KnownBits::umax((const void **)&v12, (const void **)&v8, v6, (uint64_t)&v16);
  result = sub_1C5E18760((char *)&v16, a3);
  if (v19 >= 0x41)
  {
    result = v18;
    if (v18)
      result = (char *)MEMORY[0x1CAA32F9C](v18, 0x1000C8000313F17);
  }
  if (v17 >= 0x41)
  {
    result = v16;
    if (v16)
      result = (char *)MEMORY[0x1CAA32F9C](v16, 0x1000C8000313F17);
  }
  if (v11 >= 0x41)
  {
    result = v10;
    if (v10)
      result = (char *)MEMORY[0x1CAA32F9C](v10, 0x1000C8000313F17);
  }
  if (v9 >= 0x41)
  {
    result = v8;
    if (v8)
      result = (char *)MEMORY[0x1CAA32F9C](v8, 0x1000C8000313F17);
  }
  if (v15 >= 0x41)
  {
    result = v14;
    if (v14)
      result = (char *)MEMORY[0x1CAA32F9C](v14, 0x1000C8000313F17);
  }
  if (v13 >= 0x41)
  {
    result = v12;
    if (v12)
      return (char *)MEMORY[0x1CAA32F9C](v12, 0x1000C8000313F17);
  }
  return result;
}

char *sub_1C5E18760@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  char *v2;
  unsigned int v4;
  unsigned int v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  void *v20;

  v2 = result;
  v4 = *((_DWORD *)result + 2);
  v5 = v4 - 1;
  v6 = (uint64_t *)(result + 16);
  v7 = *((unsigned int *)result + 6);
  if (v7 > 0x40)
  {
    v8 = operator new[]();
    result = (char *)memcpy((void *)v8, *((const void **)v2 + 2), ((unint64_t)(v7 + 63) >> 3) & 0x3FFFFFF8);
    v4 = *((_DWORD *)v2 + 2);
  }
  else
  {
    v8 = *v6;
  }
  if (v4 <= 0x40)
  {
    v9 = *(_QWORD *)v2;
    v10 = v5 >> 6;
LABEL_7:
    v12 = v2;
    goto LABEL_9;
  }
  v9 = operator new[]();
  v11 = *(_QWORD *)v2;
  result = (char *)memcpy((void *)v9, *(const void **)v2, (((unint64_t)v4 + 63) >> 3) & 0x3FFFFFF8);
  v10 = v5 >> 6;
  if (*((_DWORD *)v2 + 2) <= 0x40u)
    goto LABEL_7;
  v12 = (_QWORD *)(v11 + 8 * v10);
LABEL_9:
  v13 = 1 << v5;
  if ((*v12 & (1 << v5)) != 0)
  {
    if (v7 <= 0x40)
    {
      v8 |= v13;
      goto LABEL_17;
    }
    v15 = *(_QWORD *)(v8 + 8 * v10) | v13;
  }
  else
  {
    v14 = ~v13;
    if (v7 <= 0x40)
    {
      v8 &= v14;
      goto LABEL_17;
    }
    v15 = *(_QWORD *)(v8 + 8 * v10) & v14;
  }
  *(_QWORD *)(v8 + 8 * v10) = v15;
LABEL_17:
  if (*((_DWORD *)v2 + 6) >= 0x41u)
    v16 = (uint64_t *)(*((_QWORD *)v2 + 2) + 8 * v10);
  else
    v16 = v6;
  if ((*v16 & v13) != 0)
  {
    if (v4 <= 0x40)
    {
      v9 |= v13;
      goto LABEL_28;
    }
    v18 = *(_QWORD *)(v9 + 8 * v10) | v13;
  }
  else
  {
    v17 = ~v13;
    if (v4 <= 0x40)
    {
      v9 &= v17;
      goto LABEL_28;
    }
    v18 = *(_QWORD *)(v9 + 8 * v10) & v17;
  }
  *(_QWORD *)(v9 + 8 * v10) = v18;
LABEL_28:
  v19 = (void *)v8;
  if (v7 >= 0x41)
  {
    v19 = (void *)operator new[]();
    result = (char *)memcpy(v19, (const void *)v8, ((unint64_t)(v7 + 63) >> 3) & 0x3FFFFFF8);
  }
  if (v4 > 0x40)
  {
    v20 = (void *)operator new[]();
    result = (char *)memcpy(v20, (const void *)v9, (((unint64_t)v4 + 63) >> 3) & 0x3FFFFFF8);
    *(_DWORD *)(a2 + 8) = v7;
    *(_QWORD *)a2 = v19;
    *(_DWORD *)(a2 + 24) = v4;
    *(_QWORD *)(a2 + 16) = v20;
    if (v9)
      result = (char *)MEMORY[0x1CAA32F9C](v9, 0x1000C8000313F17);
  }
  else
  {
    *(_DWORD *)(a2 + 8) = v7;
    *(_QWORD *)a2 = v19;
    *(_DWORD *)(a2 + 24) = v4;
    *(_QWORD *)(a2 + 16) = v9;
  }
  if (v7 >= 0x41)
  {
    if (v8)
      JUMPOUT(0x1CAA32F9CLL);
  }
  return result;
}

int8x8_t *llvm::KnownBits::shl@<X0>(llvm::KnownBits *this@<X0>, int8x8_t *a2@<X1>, llvm::KnownBits *a3@<X8>)
{
  llvm::KnownBits *v5;
  unint64_t v7;
  uint64_t v8;
  uint8x8_t v9;
  __int32 v10;
  int8x8_t *v11;
  uint64_t v12;
  _QWORD *v13;
  uint8x8_t v14;
  unsigned int v15;
  unsigned int v16;
  int8x8_t *result;
  unint64_t v18;
  int8x8_t *v19;
  int8x8_t v20;
  uint8x8_t v21;
  int v22;
  unint64_t v23;
  int8x8_t *v24;
  int8x8_t v25;
  uint8x8_t v26;
  int8x8_t v27;
  int v28;
  unint64_t v29;
  int8x8_t *v30;
  int v31;
  uint64_t v32;
  BOOL v33;
  unint64_t v34;
  unsigned int v35;
  unsigned __int32 v36;
  unsigned int v37;
  uint64_t v38;
  unint64_t v39;
  _QWORD *v40;
  unsigned int v41;
  llvm::APInt *v42;
  unsigned int v43;
  uint64_t v44;
  unint64_t v45;
  unint64_t v46;
  size_t v47;
  int8x8_t *v48;
  uint64_t v49;
  unint64_t v50;
  llvm::KnownBits *v51;
  uint64_t v52;
  unint64_t v53;
  llvm::APInt *v54;
  unint64_t v55;
  _QWORD *v56;
  unint64_t v57;
  unsigned int v58;
  unint64_t v59;
  unsigned int v60;
  uint64_t v61;
  _QWORD *v62;
  uint64_t v63;
  void *v64;
  BOOL v65;
  char v66;
  char v67;
  _QWORD *v68;
  unint64_t v69;
  uint64_t *v70;
  uint64_t v71;
  unint64_t v72;
  uint64_t *v73;
  _QWORD *v74;
  uint64_t v75;
  size_t v76;
  int v77;
  int64_t v78;
  unint64_t v79;
  unsigned int v80;
  uint64_t v81;
  uint64_t v82;
  size_t __na;
  size_t __n;
  unsigned int v85;
  unsigned int v86;
  _QWORD *v87;
  int8x8_t *v88;
  _QWORD *v89;
  unsigned int v90;
  llvm::KnownBits *v91;
  int8x8_t v92;
  llvm::APInt *v93;
  _QWORD *v94;
  unsigned int v95;
  _QWORD *v96;
  unsigned int v97;

  v5 = this;
  v7 = *((unsigned int *)this + 2);
  *((_DWORD *)a3 + 2) = v7;
  v93 = (llvm::KnownBits *)((char *)a3 + 16);
  if (v7 > 0x40)
  {
    llvm::APInt::initSlowCase(a3, 0, 0);
    *((_DWORD *)a3 + 6) = v7;
    llvm::APInt::initSlowCase(v93, 0, 0);
  }
  else
  {
    *(_QWORD *)a3 = 0;
    *((_DWORD *)a3 + 6) = v7;
    *((_QWORD *)a3 + 2) = 0;
  }
  v8 = a2[1].u32[0];
  if (v8 > 0x40)
  {
    v10 = 0;
    v18 = (unint64_t)(v8 + 63) >> 6;
    v19 = (int8x8_t *)*a2;
    do
    {
      v20 = *v19++;
      v21 = (uint8x8_t)vcnt_s8(v20);
      v21.i16[0] = vaddlv_u8(v21);
      v10 += v21.i32[0];
      --v18;
    }
    while (v18);
  }
  else
  {
    v9 = (uint8x8_t)vcnt_s8(*a2);
    v9.i16[0] = vaddlv_u8(v9);
    v10 = v9.i32[0];
  }
  v11 = a2 + 2;
  v12 = a2[3].u32[0];
  v91 = v5;
  if (v12 > 0x40)
  {
    v22 = 0;
    v23 = (unint64_t)(v12 + 63) >> 6;
    v24 = (int8x8_t *)*v11;
    do
    {
      v25 = *v24++;
      v26 = (uint8x8_t)vcnt_s8(v25);
      v26.i16[0] = vaddlv_u8(v26);
      v22 += v26.i32[0];
      --v23;
    }
    while (v23);
    if (v22 + v10 != (_DWORD)v8
      || v12 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&a2[2]) > 0x40)
    {
      goto LABEL_23;
    }
    v13 = **(_QWORD ***)v11;
  }
  else
  {
    v13 = (_QWORD *)*v11;
    v14 = (uint8x8_t)vcnt_s8(*v11);
    v14.i16[0] = vaddlv_u8(v14);
    if (v10 + v14.i32[0] != (_DWORD)v8)
      goto LABEL_23;
  }
  if ((unint64_t)v13 < v7)
  {
    if (*((_DWORD *)a3 + 2) > 0x40u || (v15 = *((_DWORD *)v5 + 2), v15 > 0x40))
    {
      if (a3 != v5)
      {
        llvm::APInt::reallocate((uint64_t)a3, *((_DWORD *)v5 + 2));
        v81 = *((unsigned int *)a3 + 2);
        if (v81 <= 0x40)
          *(_QWORD *)a3 = *(_QWORD *)v5;
        else
          memcpy(*(void **)a3, *(const void **)v5, ((unint64_t)(v81 + 63) >> 3) & 0x3FFFFFF8);
      }
    }
    else
    {
      *(_QWORD *)a3 = *(_QWORD *)v5;
      *((_DWORD *)a3 + 2) = v15;
    }
    if (*((_DWORD *)a3 + 6) > 0x40u || (v16 = *((_DWORD *)v5 + 6), v16 > 0x40))
    {
      if (a3 != v5)
      {
        llvm::APInt::reallocate((uint64_t)v93, *((_DWORD *)v5 + 6));
        v82 = *((unsigned int *)a3 + 6);
        if (v82 <= 0x40)
          *(_QWORD *)v93 = *((_QWORD *)v5 + 2);
        else
          memcpy(*(void **)v93, *((const void **)v5 + 2), ((unint64_t)(v82 + 63) >> 3) & 0x3FFFFFF8);
      }
    }
    else
    {
      *((_QWORD *)a3 + 2) = *((_QWORD *)v5 + 2);
      *((_DWORD *)a3 + 6) = v16;
    }
    sub_1C4888094((uint64_t)a3, v13);
    sub_1C4888094((uint64_t)v93, v13);
    return (int8x8_t *)sub_1C4912E54(a3, 0, v13);
  }
LABEL_23:
  if (*((_DWORD *)v5 + 2) > 0x40u)
    v90 = llvm::APInt::countTrailingOnesSlowCase(v5);
  else
    v90 = __clz(__rbit64(~*(_QWORD *)v5));
  if (v12 <= 0x40)
  {
    v27 = *v11;
    v88 = (int8x8_t *)*v11;
LABEL_35:
    v36 = v90 + v27.i32[0];
    if (v7 < v90 + v27.i32[0])
      v36 = v7;
    if (*(_QWORD *)&v27 < v7)
      v37 = v36;
    else
      v37 = v90;
    v90 = v37;
    goto LABEL_41;
  }
  v28 = v12;
  v29 = v12 + 63;
  v30 = (int8x8_t *)operator new[]();
  memcpy(v30, *(const void **)v11, (v29 >> 3) & 0x3FFFFFF8);
  v31 = 0;
  v32 = v29 >> 6;
  do
  {
    v33 = v32-- < 1;
    if (v33)
      break;
    v34 = (unint64_t)v30[v32];
    v31 += __clz(v34);
  }
  while (!v34);
  v88 = v30;
  LODWORD(v12) = v28;
  v35 = v28 | 0xFFFFFFC0;
  if ((v28 & 0x3F) == 0)
    v35 = 0;
  if (v28 - v31 - v35 <= 0x40)
  {
    v27 = *v30;
    goto LABEL_35;
  }
LABEL_41:
  v38 = a2[1].u32[0];
  v97 = v38;
  if (v38 > 0x40)
  {
    v76 = ((unint64_t)(v38 + 63) >> 3) & 0x3FFFFFF8;
    v96 = (_QWORD *)operator new[]();
    memcpy(v96, *(const void **)a2, v76);
    llvm::APInt::flipAllBitsSlowCase((uint64_t)&v96);
    v86 = v97;
    v87 = v96;
    if (v97 >= 0x41)
    {
      v77 = 0;
      v78 = ((unint64_t)v97 + 63) >> 6;
      do
      {
        v33 = v78-- < 1;
        if (v33)
          break;
        v79 = v96[v78];
        v77 += __clz(v79);
      }
      while (!v79);
      v80 = v97 | 0xFFFFFFC0;
      if ((v97 & 0x3F) == 0)
        v80 = 0;
      if (v97 - v77 - v80 > 0x40)
        goto LABEL_75;
      v40 = (_QWORD *)*v96;
    }
    else
    {
      v40 = v96;
    }
  }
  else
  {
    v39 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v38;
    if (!(_DWORD)v38)
      v39 = 0;
    v86 = v38;
    v87 = (_QWORD *)(v39 & ~*(_QWORD *)a2);
    v40 = v87;
  }
  if ((unint64_t)v40 < v7)
  {
    v85 = v12;
    v41 = *((_DWORD *)v5 + 2);
    if (v41 > 0x40)
    {
      if (llvm::APInt::countLeadingZerosSlowCase(v5) != v41)
        goto LABEL_50;
    }
    else if (*(_QWORD *)v5)
    {
      goto LABEL_50;
    }
    v42 = (llvm::KnownBits *)((char *)v5 + 16);
    v43 = *((_DWORD *)v5 + 6);
    if (v43 <= 0x40)
    {
      if (*(_QWORD *)v42)
        goto LABEL_50;
LABEL_74:
      LODWORD(v12) = v85;
      goto LABEL_75;
    }
    if (llvm::APInt::countLeadingZerosSlowCase(v42) == v43)
      goto LABEL_74;
LABEL_50:
    v44 = a2[1].u32[0];
    v95 = v44;
    if (v44 > 0x40)
    {
      v47 = ((unint64_t)(v44 + 63) >> 3) & 0x3FFFFFF8;
      v94 = (_QWORD *)operator new[]();
      memcpy(v94, *(const void **)a2, v47);
      llvm::APInt::flipAllBitsSlowCase((uint64_t)&v94);
      if (v95 >= 0x41)
      {
        v46 = *v94;
        if (v94)
          MEMORY[0x1CAA32F9C](v94, 0x1000C8000313F17);
      }
      else
      {
        v46 = (unint64_t)v94;
      }
    }
    else
    {
      if ((_DWORD)v44)
        v45 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v44;
      else
        v45 = 0;
      v46 = v45 & ~*(_QWORD *)a2;
    }
    if (a2[3].i32[0] >= 0x41u)
      v48 = (int8x8_t *)a2[2];
    else
      v48 = a2 + 2;
    v92 = *v48;
    v49 = *((unsigned int *)a3 + 2);
    if (v49 > 0x40)
    {
      memset(*(void **)a3, 255, ((unint64_t)(v49 + 63) >> 3) & 0x3FFFFFF8);
      LODWORD(v49) = *((_DWORD *)a3 + 2);
      if ((_DWORD)v49)
      {
LABEL_63:
        v50 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v49;
        if (v49 >= 0x41)
        {
          v51 = (llvm::KnownBits *)(*(_QWORD *)a3
                                  + 8 * ((((unint64_t)v49 + 63) >> 6) - 1));
LABEL_65:
          *(_QWORD *)v51 &= v50;
          v52 = *((unsigned int *)a3 + 6);
          if (v52 > 0x40)
          {
            memset(*((void **)a3 + 2), 255, ((unint64_t)(v52 + 63) >> 3) & 0x3FFFFFF8);
            LODWORD(v52) = *((_DWORD *)a3 + 6);
            if ((_DWORD)v52)
            {
LABEL_67:
              v53 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v52;
              if (v52 >= 0x41)
              {
                v54 = (llvm::APInt *)(*(_QWORD *)v93
                                    + 8 * ((((unint64_t)v52 + 63) >> 6) - 1));
                goto LABEL_69;
              }
LABEL_68:
              v54 = v93;
LABEL_69:
              *(_QWORD *)v54 &= v53;
              v55 = (unint64_t)v88;
              if (v85 >= 0x41)
                v55 = (unint64_t)*v88;
              v56 = v87;
              if (v86 >= 0x41)
                v56 = (_QWORD *)*v87;
              if (v55 > (unint64_t)v56)
                goto LABEL_74;
              v89 = (_QWORD *)v46;
              while (1)
              {
                while ((v55 & ~v46) != 0 || (v55 | *(_QWORD *)&v92) != v55)
                {
                  if (++v55 > (unint64_t)v56)
                    goto LABEL_74;
                }
                v97 = *((_DWORD *)v5 + 2);
                if (v97 > 0x40)
                {
                  v96 = (_QWORD *)operator new[]();
                  memcpy(v96, *(const void **)v5, (((unint64_t)v97 + 63) >> 3) & 0x3FFFFFF8);
                }
                else
                {
                  v96 = *(_QWORD **)v5;
                }
                sub_1C4888094((uint64_t)&v96, v55);
                v57 = (unint64_t)v96;
                v58 = v97;
                v97 = *((_DWORD *)v5 + 6);
                if (v97 > 0x40)
                {
                  v96 = (_QWORD *)operator new[]();
                  memcpy(v96, *((const void **)v5 + 2), (((unint64_t)v97 + 63) >> 3) & 0x3FFFFFF8);
                }
                else
                {
                  v96 = (_QWORD *)*((_QWORD *)v5 + 2);
                }
                sub_1C4888094((uint64_t)&v96, v55);
                v59 = (unint64_t)v96;
                v60 = v97;
                v61 = *((unsigned int *)a3 + 2);
                if (v61 > 0x40)
                {
                  v68 = (_QWORD *)operator new[]();
                  memcpy(v68, *(const void **)a3, ((unint64_t)(v61 + 63) >> 3) & 0x3FFFFFF8);
                  v69 = (unint64_t)(v61 + 63) >> 6;
                  v70 = (uint64_t *)v57;
                  v62 = v68;
                  do
                  {
                    v71 = *v70++;
                    *v68++ &= v71;
                    --v69;
                  }
                  while (v69);
                }
                else
                {
                  v62 = (_QWORD *)(*(_QWORD *)a3 & v57);
                }
                v63 = *((unsigned int *)a3 + 6);
                if (v63 > 0x40)
                {
                  __n = (size_t)v62;
                  v64 = (void *)operator new[]();
                  memcpy(v64, *(const void **)v93, ((unint64_t)(v63 + 63) >> 3) & 0x3FFFFFF8);
                  v72 = (unint64_t)(v63 + 63) >> 6;
                  v73 = (uint64_t *)v59;
                  v74 = v64;
                  do
                  {
                    v75 = *v73++;
                    *v74++ &= v75;
                    --v72;
                  }
                  while (v72);
                  v62 = (_QWORD *)__n;
                }
                else
                {
                  v64 = (void *)(*(_QWORD *)v93 & v59);
                }
                if (*((_DWORD *)a3 + 2) >= 0x41u && *(_QWORD *)a3)
                {
                  __na = (size_t)v62;
                  MEMORY[0x1CAA32F9C](*(_QWORD *)a3, 0x1000C8000313F17);
                  v62 = (_QWORD *)__na;
                }
                *(_QWORD *)a3 = v62;
                *((_DWORD *)a3 + 2) = v61;
                if (*((_DWORD *)a3 + 6) >= 0x41u && *(_QWORD *)v93)
                {
                  MEMORY[0x1CAA32F9C](*(_QWORD *)v93, 0x1000C8000313F17);
                  LODWORD(v61) = *((_DWORD *)a3 + 2);
                }
                *((_QWORD *)a3 + 2) = v64;
                *((_DWORD *)a3 + 6) = v63;
                if (v61 > 0x40)
                {
                  v65 = llvm::APInt::countLeadingZerosSlowCase(a3) == (_DWORD)v61;
                  v46 = (unint64_t)v89;
                  if (v65)
                  {
LABEL_101:
                    if (v63 > 0x40)
                      v65 = llvm::APInt::countLeadingZerosSlowCase(v93) == (_DWORD)v63;
                    else
                      v65 = v64 == 0;
                    v66 = v65;
                    goto LABEL_112;
                  }
                }
                else
                {
                  v46 = (unint64_t)v89;
                  if (!*(_QWORD *)a3)
                    goto LABEL_101;
                }
                v66 = 0;
LABEL_112:
                if (v60 >= 0x41 && v59)
                  MEMORY[0x1CAA32F9C](v59, 0x1000C8000313F17);
                if (v58 >= 0x41 && v57)
                  MEMORY[0x1CAA32F9C](v57, 0x1000C8000313F17);
                if (++v55 > (unint64_t)v56)
                  v67 = 1;
                else
                  v67 = v66;
                v5 = v91;
                if ((v67 & 1) != 0)
                  goto LABEL_74;
              }
            }
          }
          else
          {
            *(_QWORD *)v93 = -1;
            if ((_DWORD)v52)
              goto LABEL_67;
          }
          v53 = 0;
          goto LABEL_68;
        }
LABEL_64:
        v51 = a3;
        goto LABEL_65;
      }
    }
    else
    {
      *(_QWORD *)a3 = -1;
      if ((_DWORD)v49)
        goto LABEL_63;
    }
    v50 = 0;
    goto LABEL_64;
  }
LABEL_75:
  sub_1C4912E54(a3, 0, v90);
  if (v86 >= 0x41 && v87)
    MEMORY[0x1CAA32F9C](v87, 0x1000C8000313F17);
  result = v88;
  if (v12 >= 0x41 && v88)
    return (int8x8_t *)MEMORY[0x1CAA32F9C](v88, 0x1000C8000313F17);
  return result;
}

_QWORD *llvm::KnownBits::lshr@<X0>(llvm::KnownBits *this@<X0>, int8x8_t *a2@<X1>, llvm::KnownBits *a3@<X8>)
{
  llvm::KnownBits *v5;
  unint64_t v7;
  uint64_t v8;
  uint8x8_t v9;
  __int32 v10;
  int8x8_t *v11;
  uint64_t v12;
  _QWORD *v13;
  uint8x8_t v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *result;
  unint64_t v20;
  int8x8_t *v21;
  int8x8_t v22;
  uint8x8_t v23;
  int v24;
  unint64_t v25;
  int8x8_t *v26;
  int8x8_t v27;
  uint8x8_t v28;
  unsigned int v29;
  int8x8_t *v30;
  int8x8_t v31;
  int v32;
  int64_t v33;
  BOOL v34;
  unint64_t v35;
  int v36;
  int v37;
  int v38;
  uint64_t v39;
  unint64_t v40;
  _QWORD *v41;
  unsigned int v42;
  llvm::APInt *v43;
  unsigned int v44;
  uint64_t v45;
  unint64_t v46;
  unint64_t v47;
  size_t v48;
  int8x8_t *v49;
  uint64_t v50;
  unint64_t v51;
  llvm::KnownBits *v52;
  uint64_t v53;
  unint64_t v54;
  llvm::APInt *v55;
  int8x8_t v56;
  _QWORD *v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  _QWORD *v63;
  uint64_t v64;
  void *v65;
  BOOL v66;
  char v67;
  char v68;
  _QWORD *v69;
  unint64_t v70;
  uint64_t *v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t *v74;
  _QWORD *v75;
  uint64_t v76;
  size_t v77;
  int v78;
  int64_t v79;
  unint64_t v80;
  unsigned int v81;
  uint64_t v82;
  uint64_t v83;
  size_t __na;
  size_t __n;
  int v86;
  unsigned int v87;
  _QWORD *v88;
  _QWORD *v89;
  int v90;
  int8x8_t *v91;
  const void **v92;
  int8x8_t v93;
  llvm::APInt *v94;
  _QWORD *v95;
  unsigned int v96;
  _QWORD *v97;
  unsigned int v98;

  v5 = this;
  v7 = *((unsigned int *)this + 2);
  *((_DWORD *)a3 + 2) = v7;
  v94 = (llvm::KnownBits *)((char *)a3 + 16);
  if (v7 > 0x40)
  {
    llvm::APInt::initSlowCase(a3, 0, 0);
    *((_DWORD *)a3 + 6) = v7;
    llvm::APInt::initSlowCase(v94, 0, 0);
  }
  else
  {
    *(_QWORD *)a3 = 0;
    *((_DWORD *)a3 + 6) = v7;
    *((_QWORD *)a3 + 2) = 0;
  }
  v8 = a2[1].u32[0];
  if (v8 > 0x40)
  {
    v10 = 0;
    v20 = (unint64_t)(v8 + 63) >> 6;
    v21 = (int8x8_t *)*a2;
    do
    {
      v22 = *v21++;
      v23 = (uint8x8_t)vcnt_s8(v22);
      v23.i16[0] = vaddlv_u8(v23);
      v10 += v23.i32[0];
      --v20;
    }
    while (v20);
  }
  else
  {
    v9 = (uint8x8_t)vcnt_s8(*a2);
    v9.i16[0] = vaddlv_u8(v9);
    v10 = v9.i32[0];
  }
  v11 = a2 + 2;
  v12 = a2[3].u32[0];
  v92 = (const void **)v5;
  if (v12 > 0x40)
  {
    v24 = 0;
    v25 = (unint64_t)(v12 + 63) >> 6;
    v26 = (int8x8_t *)*v11;
    do
    {
      v27 = *v26++;
      v28 = (uint8x8_t)vcnt_s8(v27);
      v28.i16[0] = vaddlv_u8(v28);
      v24 += v28.i32[0];
      --v25;
    }
    while (v25);
    if (v24 + v10 != (_DWORD)v8
      || v12 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&a2[2]) > 0x40)
    {
      goto LABEL_33;
    }
    v13 = **(_QWORD ***)v11;
  }
  else
  {
    v13 = (_QWORD *)*v11;
    v14 = (uint8x8_t)vcnt_s8(*v11);
    v14.i16[0] = vaddlv_u8(v14);
    if (v10 + v14.i32[0] != (_DWORD)v8)
      goto LABEL_33;
  }
  if ((unint64_t)v13 < v7)
  {
    if (*((_DWORD *)a3 + 2) > 0x40u || (v15 = *((_DWORD *)v5 + 2), v15 > 0x40))
    {
      if (a3 != v5)
      {
        llvm::APInt::reallocate((uint64_t)a3, *((_DWORD *)v5 + 2));
        v82 = *((unsigned int *)a3 + 2);
        if (v82 <= 0x40)
          *(_QWORD *)a3 = *(_QWORD *)v5;
        else
          memcpy(*(void **)a3, *(const void **)v5, ((unint64_t)(v82 + 63) >> 3) & 0x3FFFFFF8);
      }
    }
    else
    {
      *(_QWORD *)a3 = *(_QWORD *)v5;
      *((_DWORD *)a3 + 2) = v15;
    }
    if (*((_DWORD *)a3 + 6) > 0x40u || (v16 = *((_DWORD *)v5 + 6), v16 > 0x40))
    {
      if (a3 != v5)
      {
        llvm::APInt::reallocate((uint64_t)v94, *((_DWORD *)v5 + 6));
        v83 = *((unsigned int *)a3 + 6);
        if (v83 <= 0x40)
          *(_QWORD *)v94 = *((_QWORD *)v5 + 2);
        else
          memcpy(*(void **)v94, *((const void **)v5 + 2), ((unint64_t)(v83 + 63) >> 3) & 0x3FFFFFF8);
      }
    }
    else
    {
      *((_QWORD *)a3 + 2) = *((_QWORD *)v5 + 2);
      *((_DWORD *)a3 + 6) = v16;
    }
    v17 = *((unsigned int *)a3 + 2);
    if (v17 > 0x40)
    {
      llvm::APInt::tcShiftRight(*(llvm::APInt **)a3, (unint64_t *)((unint64_t)(v17 + 63) >> 6), v13);
    }
    else if ((_DWORD)v17 == (_DWORD)v13)
    {
      *(_QWORD *)a3 = 0;
    }
    else
    {
      *(_QWORD *)a3 >>= (char)v13;
    }
    v18 = *((unsigned int *)a3 + 6);
    if (v18 > 0x40)
    {
      llvm::APInt::tcShiftRight(*(llvm::APInt **)v94, (unint64_t *)((unint64_t)(v18 + 63) >> 6), v13);
    }
    else if ((_DWORD)v18 == (_DWORD)v13)
    {
      *(_QWORD *)v94 = 0;
    }
    else
    {
      *(_QWORD *)v94 >>= (char)v13;
    }
    return sub_1C4912E54(a3, *((_DWORD *)a3 + 2) - (int)v13, *((_DWORD *)a3 + 2));
  }
LABEL_33:
  v29 = *((_DWORD *)v5 + 2);
  if (v29 > 0x40)
  {
    v90 = llvm::APInt::countLeadingOnesSlowCase(v5);
  }
  else if (v29)
  {
    v90 = __clz(~(*(_QWORD *)v5 << -(char)v29));
  }
  else
  {
    v90 = 0;
  }
  if (v12 <= 0x40)
  {
    v30 = (int8x8_t *)*v11;
    v31 = *v11;
LABEL_46:
    v37 = v90 + v31.i32[0];
    if (v7 < v90 + v31.i32[0])
      v37 = v7;
    if (*(_QWORD *)&v31 < v7)
      v38 = v37;
    else
      v38 = v90;
    v90 = v38;
    goto LABEL_52;
  }
  v30 = (int8x8_t *)operator new[]();
  memcpy(v30, *(const void **)v11, ((unint64_t)(v12 + 63) >> 3) & 0x3FFFFFF8);
  v32 = 0;
  v33 = (unint64_t)(v12 + 63) >> 6;
  do
  {
    v34 = v33-- < 1;
    if (v34)
      break;
    v35 = (unint64_t)v30[v33];
    v32 += __clz(v35);
  }
  while (!v35);
  v36 = v12 | 0xFFFFFFC0;
  if ((v12 & 0x3F) == 0)
    v36 = 0;
  if ((v12 - v32 - v36) <= 0x40)
  {
    v31 = *v30;
    goto LABEL_46;
  }
LABEL_52:
  v39 = a2[1].u32[0];
  v98 = v39;
  v91 = v30;
  if (v39 > 0x40)
  {
    v77 = ((unint64_t)(v39 + 63) >> 3) & 0x3FFFFFF8;
    v97 = (_QWORD *)operator new[]();
    memcpy(v97, *(const void **)a2, v77);
    llvm::APInt::flipAllBitsSlowCase((uint64_t)&v97);
    v87 = v98;
    v88 = v97;
    if (v98 >= 0x41)
    {
      v78 = 0;
      v79 = ((unint64_t)v98 + 63) >> 6;
      do
      {
        v34 = v79-- < 1;
        if (v34)
          break;
        v80 = v97[v79];
        v78 += __clz(v80);
      }
      while (!v80);
      v81 = v98 | 0xFFFFFFC0;
      if ((v98 & 0x3F) == 0)
        v81 = 0;
      if (v98 - v78 - v81 > 0x40)
        goto LABEL_86;
      v41 = (_QWORD *)*v97;
    }
    else
    {
      v41 = v97;
    }
  }
  else
  {
    v40 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v39;
    if (!(_DWORD)v39)
      v40 = 0;
    v87 = v39;
    v88 = (_QWORD *)(v40 & ~*(_QWORD *)a2);
    v41 = v88;
  }
  if ((unint64_t)v41 < v7)
  {
    v42 = *((_DWORD *)v5 + 2);
    if (v42 > 0x40)
    {
      if (llvm::APInt::countLeadingZerosSlowCase(v5) != v42)
        goto LABEL_61;
    }
    else if (*(_QWORD *)v5)
    {
      goto LABEL_61;
    }
    v43 = (llvm::KnownBits *)((char *)v5 + 16);
    v44 = *((_DWORD *)v5 + 6);
    if (v44 <= 0x40)
    {
      if (!*(_QWORD *)v43)
        goto LABEL_86;
LABEL_61:
      v45 = a2[1].u32[0];
      v96 = v45;
      if (v45 > 0x40)
      {
        v48 = ((unint64_t)(v45 + 63) >> 3) & 0x3FFFFFF8;
        v95 = (_QWORD *)operator new[]();
        memcpy(v95, *(const void **)a2, v48);
        llvm::APInt::flipAllBitsSlowCase((uint64_t)&v95);
        if (v96 >= 0x41)
        {
          v47 = *v95;
          if (v95)
            MEMORY[0x1CAA32F9C](v95, 0x1000C8000313F17);
        }
        else
        {
          v47 = (unint64_t)v95;
        }
      }
      else
      {
        if ((_DWORD)v45)
          v46 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v45;
        else
          v46 = 0;
        v47 = v46 & ~*(_QWORD *)a2;
      }
      if (a2[3].i32[0] >= 0x41u)
        v49 = (int8x8_t *)a2[2];
      else
        v49 = a2 + 2;
      v93 = *v49;
      v50 = *((unsigned int *)a3 + 2);
      if (v50 > 0x40)
      {
        memset(*(void **)a3, 255, ((unint64_t)(v50 + 63) >> 3) & 0x3FFFFFF8);
        LODWORD(v50) = *((_DWORD *)a3 + 2);
        if ((_DWORD)v50)
        {
LABEL_74:
          v51 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v50;
          if (v50 >= 0x41)
          {
            v52 = (llvm::KnownBits *)(*(_QWORD *)a3
                                    + 8 * ((((unint64_t)v50 + 63) >> 6) - 1));
LABEL_76:
            *(_QWORD *)v52 &= v51;
            v53 = *((unsigned int *)a3 + 6);
            if (v53 > 0x40)
            {
              memset(*((void **)a3 + 2), 255, ((unint64_t)(v53 + 63) >> 3) & 0x3FFFFFF8);
              LODWORD(v53) = *((_DWORD *)a3 + 6);
              if ((_DWORD)v53)
              {
LABEL_78:
                v54 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v53;
                if (v53 >= 0x41)
                {
                  v55 = (llvm::APInt *)(*(_QWORD *)v94
                                      + 8 * ((((unint64_t)v53 + 63) >> 6) - 1));
                  goto LABEL_80;
                }
LABEL_79:
                v55 = v94;
LABEL_80:
                *(_QWORD *)v55 &= v54;
                v56 = (int8x8_t)v30;
                v86 = v12;
                if (v12 >= 0x41)
                  v56 = *v30;
                v57 = v88;
                if (v87 >= 0x41)
                  v57 = (_QWORD *)*v88;
                if (*(_QWORD *)&v56 > (unint64_t)v57)
                {
LABEL_85:
                  LODWORD(v12) = v86;
                  goto LABEL_86;
                }
                v89 = (_QWORD *)v47;
                while (1)
                {
                  while ((*(_QWORD *)&v56 & ~v47) != 0 || (*(_QWORD *)&v56 | *(_QWORD *)&v93) != *(_QWORD *)&v56)
                  {
                    if (++*(_QWORD *)&v56 > (unint64_t)v57)
                      goto LABEL_85;
                  }
                  v58 = *((unsigned int *)v5 + 2);
                  if (v58 > 0x40)
                  {
                    v59 = operator new[]();
                    memcpy((void *)v59, *(const void **)v5, ((unint64_t)(v58 + 63) >> 3) & 0x3FFFFFF8);
                  }
                  else
                  {
                    v59 = *(_QWORD *)v5;
                  }
                  v60 = *((unsigned int *)v5 + 6);
                  if (v60 > 0x40)
                  {
                    v61 = operator new[]();
                    memcpy((void *)v61, v92[2], ((unint64_t)(v60 + 63) >> 3) & 0x3FFFFFF8);
                  }
                  else
                  {
                    v61 = *((_QWORD *)v5 + 2);
                  }
                  if (v58 > 0x40)
                  {
                    llvm::APInt::tcShiftRight((llvm::APInt *)v59, (unint64_t *)((unint64_t)(v58 + 63) >> 6), v56.u32[0]);
                  }
                  else if ((_DWORD)v58 == v56.i32[0])
                  {
                    v59 = 0;
                  }
                  else
                  {
                    v59 >>= v56.i8[0];
                  }
                  if (v60 > 0x40)
                  {
                    llvm::APInt::tcShiftRight((llvm::APInt *)v61, (unint64_t *)((unint64_t)(v60 + 63) >> 6), v56.u32[0]);
                  }
                  else if ((_DWORD)v60 == v56.i32[0])
                  {
                    v61 = 0;
                  }
                  else
                  {
                    v61 >>= v56.i8[0];
                  }
                  v62 = *((unsigned int *)a3 + 2);
                  if (v62 > 0x40)
                  {
                    v69 = (_QWORD *)operator new[]();
                    memcpy(v69, *(const void **)a3, ((unint64_t)(v62 + 63) >> 3) & 0x3FFFFFF8);
                    v70 = (unint64_t)(v62 + 63) >> 6;
                    v71 = (uint64_t *)v59;
                    v63 = v69;
                    do
                    {
                      v72 = *v71++;
                      *v69++ &= v72;
                      --v70;
                    }
                    while (v70);
                  }
                  else
                  {
                    v63 = (_QWORD *)(*(_QWORD *)a3 & v59);
                  }
                  v64 = *((unsigned int *)a3 + 6);
                  if (v64 > 0x40)
                  {
                    __n = (size_t)v63;
                    v65 = (void *)operator new[]();
                    memcpy(v65, *(const void **)v94, ((unint64_t)(v64 + 63) >> 3) & 0x3FFFFFF8);
                    v73 = (unint64_t)(v64 + 63) >> 6;
                    v74 = (uint64_t *)v61;
                    v75 = v65;
                    do
                    {
                      v76 = *v74++;
                      *v75++ &= v76;
                      --v73;
                    }
                    while (v73);
                    v63 = (_QWORD *)__n;
                  }
                  else
                  {
                    v65 = (void *)(*(_QWORD *)v94 & v61);
                  }
                  if (*((_DWORD *)a3 + 2) >= 0x41u && *(_QWORD *)a3)
                  {
                    __na = (size_t)v63;
                    MEMORY[0x1CAA32F9C](*(_QWORD *)a3, 0x1000C8000313F17);
                    v63 = (_QWORD *)__na;
                  }
                  *(_QWORD *)a3 = v63;
                  *((_DWORD *)a3 + 2) = v62;
                  if (*((_DWORD *)a3 + 6) >= 0x41u && *(_QWORD *)v94)
                  {
                    MEMORY[0x1CAA32F9C](*(_QWORD *)v94, 0x1000C8000313F17);
                    LODWORD(v62) = *((_DWORD *)a3 + 2);
                  }
                  *((_QWORD *)a3 + 2) = v65;
                  *((_DWORD *)a3 + 6) = v64;
                  if (v62 > 0x40)
                  {
                    v66 = llvm::APInt::countLeadingZerosSlowCase(a3) == (_DWORD)v62;
                    v30 = v91;
                    if (v66)
                    {
LABEL_119:
                      if (v64 > 0x40)
                        v66 = llvm::APInt::countLeadingZerosSlowCase(v94) == (_DWORD)v64;
                      else
                        v66 = v65 == 0;
                      v67 = v66;
                      goto LABEL_132;
                    }
                  }
                  else
                  {
                    v30 = v91;
                    if (!*(_QWORD *)a3)
                      goto LABEL_119;
                  }
                  v67 = 0;
LABEL_132:
                  v5 = (llvm::KnownBits *)v92;
                  if (v60 >= 0x41 && v61)
                    MEMORY[0x1CAA32F9C](v61, 0x1000C8000313F17);
                  v47 = (unint64_t)v89;
                  if (v58 >= 0x41 && v59)
                    MEMORY[0x1CAA32F9C](v59, 0x1000C8000313F17);
                  if (++*(_QWORD *)&v56 > (unint64_t)v57)
                    v68 = 1;
                  else
                    v68 = v67;
                  if ((v68 & 1) != 0)
                    goto LABEL_85;
                }
              }
            }
            else
            {
              *(_QWORD *)v94 = -1;
              if ((_DWORD)v53)
                goto LABEL_78;
            }
            v54 = 0;
            goto LABEL_79;
          }
LABEL_75:
          v52 = a3;
          goto LABEL_76;
        }
      }
      else
      {
        *(_QWORD *)a3 = -1;
        if ((_DWORD)v50)
          goto LABEL_74;
      }
      v51 = 0;
      goto LABEL_75;
    }
    if (llvm::APInt::countLeadingZerosSlowCase(v43) != v44)
      goto LABEL_61;
  }
LABEL_86:
  sub_1C4912E54(a3, *((_DWORD *)a3 + 2) - v90, *((_DWORD *)a3 + 2));
  result = v88;
  if (v87 >= 0x41 && v88)
    result = (_QWORD *)MEMORY[0x1CAA32F9C](v88, 0x1000C8000313F17);
  if (v12 >= 0x41 && v30)
    JUMPOUT(0x1CAA32F9CLL);
  return result;
}

void llvm::KnownBits::ashr(llvm::KnownBits *this@<X0>, int8x8_t *a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t v7;
  unsigned int *v8;
  uint64_t v9;
  uint8x8_t v10;
  __int32 v11;
  int8x8_t *v12;
  uint64_t v13;
  _QWORD *v14;
  uint8x8_t v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  char v19;
  uint64_t v20;
  unint64_t v21;
  unsigned int v22;
  char v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  int8x8_t *v27;
  int8x8_t v28;
  uint8x8_t v29;
  int v30;
  unint64_t v31;
  int8x8_t *v32;
  int8x8_t v33;
  uint8x8_t v34;
  int v35;
  unsigned int v36;
  int v37;
  llvm::APInt *v38;
  unsigned int v39;
  int v40;
  int8x8_t *v41;
  int8x8_t v42;
  llvm::APInt *v43;
  int v44;
  int64_t v45;
  BOOL v46;
  unint64_t v47;
  int v48;
  int v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  _QWORD *v54;
  unint64_t v55;
  unsigned int v56;
  unsigned int v57;
  uint64_t v58;
  unint64_t v59;
  llvm::APInt *v60;
  unint64_t v61;
  llvm::APInt *v62;
  size_t v63;
  int8x8_t *v64;
  int8x8_t v65;
  uint64_t v66;
  unint64_t v67;
  unint64_t *v68;
  uint64_t v69;
  unint64_t v70;
  llvm::APInt *v71;
  int8x8_t v72;
  _QWORD *v73;
  unsigned int *v74;
  unsigned int v75;
  unsigned int v76;
  char v77;
  uint64_t v78;
  unint64_t v79;
  char v80;
  unint64_t v81;
  llvm::APInt *v82;
  void *v83;
  uint64_t v84;
  void *v85;
  BOOL v86;
  char v87;
  llvm::APInt *v88;
  int8x8_t v89;
  llvm::APInt *v90;
  int8x8_t v91;
  unsigned int *v92;
  unsigned int v93;
  const void **v94;
  int8x8_t v95;
  unsigned int *v96;
  unsigned int v97;
  llvm::APInt *v98;
  int8x8_t v99;
  unsigned int *v100;
  llvm::APInt *v101;
  int8x8_t v102;
  unsigned int *v103;
  llvm::APInt *v104;
  unsigned int *v105;
  int v106;
  char v107;
  int8x8_t *v108;
  llvm::APInt *v109;
  int8x8_t v110;
  unsigned int *v111;
  int8x8_t *v112;
  llvm::APInt *v113;
  int8x8_t v114;
  unsigned int *v115;
  uint64_t *v116;
  unint64_t v117;
  _QWORD *v118;
  uint64_t v119;
  uint64_t *v120;
  unint64_t v121;
  _QWORD *v122;
  uint64_t v123;
  llvm::APInt *v124;
  int8x8_t v125;
  unsigned int *v126;
  int v127;
  llvm::APInt *v128;
  int8x8_t v129;
  llvm::APInt *v130;
  int8x8_t v131;
  llvm::APInt *v132;
  size_t v133;
  int v134;
  int64_t v135;
  unint64_t v136;
  unsigned int v137;
  uint64_t v138;
  uint64_t v139;
  int8x8_t *v140;
  llvm::APInt *v141;
  int v142;
  int8x8_t *v143;
  llvm::APInt *v144;
  int v145;
  llvm::APInt *v146;
  llvm::APInt *v147;
  int8x8_t *v148;
  int8x8_t *v149;
  int8x8_t v150;
  int8x8_t v151;
  int8x8_t v152;
  int8x8_t v153;
  unsigned int *v154;
  unsigned int *v155;
  unsigned int *v156;
  unsigned int *v157;
  int v158;
  int v159;
  uint64_t v160;
  unsigned int v161;
  llvm::APInt *v162;
  int v163;
  int v164;
  uint64_t v165;
  unsigned int v166;
  uint64_t v167;
  unsigned int v168;
  _QWORD *v169;
  unsigned int v170;

  v7 = *((unsigned int *)this + 2);
  *((_DWORD *)a3 + 2) = v7;
  v8 = (unsigned int *)(a3 + 2);
  v162 = (llvm::APInt *)(a3 + 2);
  if (v7 > 0x40)
  {
    llvm::APInt::initSlowCase((llvm::APInt *)a3, 0, 0);
    *((_DWORD *)a3 + 6) = v7;
    llvm::APInt::initSlowCase(v162, 0, 0);
    v8 = (unsigned int *)v162;
  }
  else
  {
    *a3 = 0;
    *((_DWORD *)a3 + 6) = v7;
    a3[2] = 0;
  }
  v9 = a2[1].u32[0];
  if (v9 > 0x40)
  {
    v11 = 0;
    v26 = (unint64_t)(v9 + 63) >> 6;
    v27 = (int8x8_t *)*a2;
    do
    {
      v28 = *v27++;
      v29 = (uint8x8_t)vcnt_s8(v28);
      v29.i16[0] = vaddlv_u8(v29);
      v11 += v29.i32[0];
      --v26;
    }
    while (v26);
  }
  else
  {
    v10 = (uint8x8_t)vcnt_s8(*a2);
    v10.i16[0] = vaddlv_u8(v10);
    v11 = v10.i32[0];
  }
  v12 = a2 + 2;
  v13 = a2[3].u32[0];
  if (v13 > 0x40)
  {
    v30 = 0;
    v31 = (unint64_t)(v13 + 63) >> 6;
    v32 = (int8x8_t *)*v12;
    do
    {
      v33 = *v32++;
      v34 = (uint8x8_t)vcnt_s8(v33);
      v34.i16[0] = vaddlv_u8(v34);
      v30 += v34.i32[0];
      --v31;
    }
    while (v31);
    if (v30 + v11 != (_DWORD)v9)
      goto LABEL_36;
    v35 = llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&a2[2]);
    v8 = (unsigned int *)v162;
    if ((v13 - v35) > 0x40)
      goto LABEL_36;
    v14 = **(_QWORD ***)v12;
  }
  else
  {
    v14 = (_QWORD *)*v12;
    v15 = (uint8x8_t)vcnt_s8(*v12);
    v15.i16[0] = vaddlv_u8(v15);
    if (v11 + v15.i32[0] != (_DWORD)v9)
      goto LABEL_36;
  }
  if ((unint64_t)v14 < v7)
  {
    if (*((_DWORD *)a3 + 2) > 0x40u || (v16 = *((_DWORD *)this + 2), v16 > 0x40))
    {
      if (a3 != (unint64_t *)this)
      {
        llvm::APInt::reallocate((uint64_t)a3, *((_DWORD *)this + 2));
        v138 = *((unsigned int *)a3 + 2);
        if (v138 <= 0x40)
          *a3 = *(_QWORD *)this;
        else
          memcpy((void *)*a3, *(const void **)this, ((unint64_t)(v138 + 63) >> 3) & 0x3FFFFFF8);
        v8 = (unsigned int *)v162;
      }
    }
    else
    {
      *a3 = *(_QWORD *)this;
      *((_DWORD *)a3 + 2) = v16;
    }
    if (*((_DWORD *)a3 + 6) > 0x40u || (v17 = *((_DWORD *)this + 6), v17 > 0x40))
    {
      if (a3 != (unint64_t *)this)
      {
        llvm::APInt::reallocate((uint64_t)v8, *((_DWORD *)this + 6));
        v139 = *((unsigned int *)a3 + 6);
        if (v139 <= 0x40)
        {
          v8 = (unsigned int *)v162;
          *(_QWORD *)v162 = *((_QWORD *)this + 2);
        }
        else
        {
          memcpy(*(void **)v162, *((const void **)this + 2), ((unint64_t)(v139 + 63) >> 3) & 0x3FFFFFF8);
          v8 = (unsigned int *)v162;
        }
      }
    }
    else
    {
      a3[2] = *((_QWORD *)this + 2);
      *((_DWORD *)a3 + 6) = v17;
    }
    v18 = *((_DWORD *)a3 + 2);
    if (v18 > 0x40)
    {
      llvm::APInt::ashrSlowCase((unsigned int *)a3, v14);
      v8 = (unsigned int *)v162;
    }
    else
    {
      v19 = (char)v14;
      if (v18 == (_DWORD)v14)
        v19 = 63;
      v20 = (uint64_t)(*a3 << -(char)v18) >> -(char)v18 >> v19;
      if (v18)
        v21 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v18;
      else
        v21 = 0;
      *a3 = v21 & v20;
    }
    v22 = *((_DWORD *)a3 + 6);
    if (v22 > 0x40)
    {
      llvm::APInt::ashrSlowCase(v8, v14);
    }
    else
    {
      v23 = (char)v14;
      if (v22 == (_DWORD)v14)
        v23 = 63;
      v24 = (uint64_t)(*(_QWORD *)v8 << -(char)v22) >> -(char)v22 >> v23;
      if (v22)
        v25 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v22;
      else
        v25 = 0;
      *(_QWORD *)v8 = v25 & v24;
    }
    return;
  }
LABEL_36:
  v36 = *((_DWORD *)this + 2);
  if (v36 > 0x40)
  {
    v37 = llvm::APInt::countLeadingOnesSlowCase(this);
  }
  else if (v36)
  {
    v37 = __clz(~(*(_QWORD *)this << -(char)v36));
  }
  else
  {
    v37 = 0;
  }
  v38 = (llvm::KnownBits *)((char *)this + 16);
  v39 = *((_DWORD *)this + 6);
  if (v39 > 0x40)
  {
    v40 = llvm::APInt::countLeadingOnesSlowCase((llvm::KnownBits *)((char *)this + 16));
    v38 = (llvm::KnownBits *)((char *)this + 16);
  }
  else if (v39)
  {
    v40 = __clz(~(*(_QWORD *)v38 << -(char)v39));
  }
  else
  {
    v40 = 0;
  }
  if (v13 <= 0x40)
  {
    v41 = (int8x8_t *)*v12;
    v42 = *v12;
LABEL_53:
    v49 = v37 + v42.i32[0];
    if (v7 < v37 + v42.i32[0])
      v49 = v7;
    if (!v37)
      v49 = 0;
    v50 = v40 + v42.i32[0];
    if (v7 < v40 + v42.i32[0])
      v50 = v7;
    if (!v40)
      v50 = 0;
    if (*(_QWORD *)&v42 < v7)
    {
      v40 = v50;
      v37 = v49;
    }
    goto LABEL_63;
  }
  v163 = v40;
  v43 = v38;
  v41 = (int8x8_t *)operator new[]();
  memcpy(v41, *(const void **)&a2[2], ((unint64_t)(v13 + 63) >> 3) & 0x3FFFFFF8);
  v38 = v43;
  v44 = 0;
  v45 = (unint64_t)(v13 + 63) >> 6;
  do
  {
    v46 = v45-- < 1;
    if (v46)
      break;
    v47 = (unint64_t)v41[v45];
    v44 += __clz(v47);
  }
  while (!v47);
  v48 = v13 | 0xFFFFFFC0;
  if ((v13 & 0x3F) == 0)
    v48 = 0;
  v40 = v163;
  v12 = a2 + 2;
  if ((v13 - v44 - v48) <= 0x40)
  {
    v42 = *v41;
    goto LABEL_53;
  }
LABEL_63:
  v164 = v40;
  v51 = a2[1].u32[0];
  v166 = v51;
  if (v51 > 0x40)
  {
    v132 = v38;
    v133 = ((unint64_t)(v51 + 63) >> 3) & 0x3FFFFFF8;
    v165 = operator new[]();
    memcpy((void *)v165, *(const void **)a2, v133);
    llvm::APInt::flipAllBitsSlowCase((uint64_t)&v165);
    v160 = v165;
    v161 = v166;
    if (v166 >= 0x41)
    {
      v134 = 0;
      v135 = ((unint64_t)v166 + 63) >> 6;
      do
      {
        v46 = v135-- < 1;
        if (v46)
          break;
        v136 = *(_QWORD *)(v165 + 8 * v135);
        v134 += __clz(v136);
      }
      while (!v136);
      v137 = v166 | 0xFFFFFFC0;
      if ((v166 & 0x3F) == 0)
        v137 = 0;
      if (v166 - v134 - v137 > 0x40)
        goto LABEL_98;
      v54 = (_QWORD *)v165;
      v55 = *(_QWORD *)v165;
    }
    else
    {
      v54 = (_QWORD *)v165;
      v55 = v165;
    }
    v38 = v132;
  }
  else
  {
    v52 = ~*(_QWORD *)a2;
    v53 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v51;
    if (!(_DWORD)v51)
      v53 = 0;
    v54 = (_QWORD *)(v53 & v52);
    v161 = v51;
    v55 = v53 & v52;
  }
  v160 = (uint64_t)v54;
  if (v55 < v7)
  {
    v56 = *((_DWORD *)this + 2);
    if (v56 > 0x40)
    {
      v140 = v41;
      v141 = v38;
      v142 = llvm::APInt::countLeadingZerosSlowCase(this);
      v54 = (_QWORD *)v160;
      v38 = v141;
      v41 = v140;
      if (v142 != v56)
        goto LABEL_72;
    }
    else if (*(_QWORD *)this)
    {
      goto LABEL_72;
    }
    v57 = *((_DWORD *)this + 6);
    if (v57 <= 0x40)
    {
      if (!*(_QWORD *)v38)
        goto LABEL_98;
LABEL_72:
      v58 = a2[1].u32[0];
      v170 = v58;
      v158 = v37;
      if (v58 > 0x40)
      {
        v62 = v38;
        v63 = ((unint64_t)(v58 + 63) >> 3) & 0x3FFFFFF8;
        v169 = (_QWORD *)operator new[]();
        memcpy(v169, *(const void **)a2, v63);
        llvm::APInt::flipAllBitsSlowCase((uint64_t)&v169);
        if (v170 >= 0x41)
        {
          v61 = *v169;
          if (v169)
            MEMORY[0x1CAA32F9C](v169, 0x1000C8000313F17);
        }
        else
        {
          v61 = (unint64_t)v169;
        }
        v60 = v162;
        v38 = v62;
        v54 = (_QWORD *)v160;
      }
      else
      {
        if ((_DWORD)v58)
          v59 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v58;
        else
          v59 = 0;
        v60 = v162;
        v61 = v59 & ~*(_QWORD *)a2;
      }
      if (a2[3].i32[0] >= 0x41u)
        v64 = (int8x8_t *)a2[2];
      else
        v64 = v12;
      v65 = *v64;
      v66 = *((unsigned int *)a3 + 2);
      if (v66 > 0x40)
      {
        v128 = v38;
        v129 = v65;
        memset((void *)*a3, 255, ((unint64_t)(v66 + 63) >> 3) & 0x3FFFFFF8);
        v65 = v129;
        v54 = (_QWORD *)v160;
        v38 = v128;
        v60 = v162;
        LODWORD(v66) = *((_DWORD *)a3 + 2);
        if ((_DWORD)v66)
        {
LABEL_86:
          v67 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v66;
          if (v66 >= 0x41)
          {
            v68 = (unint64_t *)(*a3 + 8 * ((((unint64_t)v66 + 63) >> 6) - 1));
LABEL_88:
            *v68 &= v67;
            v69 = *((unsigned int *)a3 + 6);
            if (v69 > 0x40)
            {
              v130 = v38;
              v131 = v65;
              memset((void *)a3[2], 255, ((unint64_t)(v69 + 63) >> 3) & 0x3FFFFFF8);
              v65 = v131;
              v54 = (_QWORD *)v160;
              v38 = v130;
              v60 = v162;
              LODWORD(v69) = *((_DWORD *)a3 + 6);
              if ((_DWORD)v69)
              {
LABEL_90:
                v70 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v69;
                if (v69 >= 0x41)
                {
                  v71 = (llvm::APInt *)(*(_QWORD *)v60
                                      + 8 * ((((unint64_t)v69 + 63) >> 6) - 1));
                  goto LABEL_92;
                }
LABEL_91:
                v71 = v60;
LABEL_92:
                *(_QWORD *)v71 &= v70;
                v72 = (int8x8_t)v41;
                v159 = v13;
                if (v13 >= 0x41)
                  v72 = *v41;
                v73 = v54;
                if (v161 >= 0x41)
                  v73 = (_QWORD *)*v54;
                if (*(_QWORD *)&v72 > (unint64_t)v73)
                {
LABEL_97:
                  v37 = v158;
                  LODWORD(v13) = v159;
                  goto LABEL_98;
                }
                v74 = (unsigned int *)&v167;
                while (1)
                {
                  while ((*(_QWORD *)&v72 & ~v61) != 0 || (*(_QWORD *)&v72 | *(_QWORD *)&v65) != *(_QWORD *)&v72)
                  {
                    if (++*(_QWORD *)&v72 > (unint64_t)v73)
                      goto LABEL_97;
                  }
                  v75 = *((_DWORD *)this + 2);
                  v166 = v75;
                  if (v75 > 0x40)
                  {
                    v90 = v38;
                    v91 = v65;
                    v92 = v74;
                    v165 = operator new[]();
                    v93 = v166;
                    memcpy((void *)v165, *(const void **)this, (((unint64_t)v166 + 63) >> 3) & 0x3FFFFFF8);
                    v74 = v92;
                    v65 = v91;
                    v38 = v90;
                    v60 = v162;
                    v75 = v93;
                  }
                  else
                  {
                    v165 = *(_QWORD *)this;
                  }
                  v76 = *((_DWORD *)this + 6);
                  v168 = v76;
                  if (v76 > 0x40)
                  {
                    v94 = (const void **)v38;
                    v95 = v65;
                    v96 = v74;
                    v167 = operator new[]();
                    v97 = v168;
                    memcpy((void *)v167, *v94, (((unint64_t)v168 + 63) >> 3) & 0x3FFFFFF8);
                    v74 = v96;
                    v65 = v95;
                    v38 = (llvm::APInt *)v94;
                    v60 = v162;
                    v75 = v166;
                    v76 = v97;
                  }
                  else
                  {
                    v167 = *(_QWORD *)v38;
                  }
                  if (v75 > 0x40)
                  {
                    v98 = v38;
                    v99 = v65;
                    v100 = v74;
                    llvm::APInt::ashrSlowCase((unsigned int *)&v165, v72.u32[0]);
                    v74 = v100;
                    v65 = v99;
                    v38 = v98;
                    v60 = v162;
                    v76 = v168;
                  }
                  else
                  {
                    v77 = v72.i8[0];
                    if (v75 == v72.i32[0])
                      v77 = 63;
                    v78 = v165 << -(char)v75 >> -(char)v75 >> v77;
                    if (v75)
                      v79 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v75;
                    else
                      v79 = 0;
                    v165 = v79 & v78;
                  }
                  if (v76 > 0x40)
                  {
                    v101 = v38;
                    v102 = v65;
                    v103 = v74;
                    llvm::APInt::ashrSlowCase(v74, v72.u32[0]);
                    v74 = v103;
                    v65 = v102;
                    v38 = v101;
                    v60 = v162;
                  }
                  else
                  {
                    v80 = v72.i8[0];
                    if (v76 == v72.i32[0])
                      v80 = 63;
                    if (v76)
                      v81 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v76;
                    else
                      v81 = 0;
                    v167 = v81 & (v167 << -(char)v76 >> -(char)v76 >> v80);
                  }
                  v82 = (llvm::APInt *)*((unsigned int *)a3 + 2);
                  if (v82 > 0x40)
                  {
                    v152 = v65;
                    v156 = v74;
                    v146 = v38;
                    v83 = (void *)operator new[]();
                    memcpy(v83, (const void *)*a3, (((unint64_t)v82 + 63) >> 3) & 0x3FFFFFF8);
                    v116 = (uint64_t *)v165;
                    v117 = ((unint64_t)v82 + 63) >> 6;
                    v118 = v83;
                    do
                    {
                      v119 = *v116++;
                      *v118++ &= v119;
                      --v117;
                    }
                    while (v117);
                    v60 = v162;
                    v38 = v146;
                    v65 = v152;
                    v74 = v156;
                  }
                  else
                  {
                    v83 = (void *)(v165 & *a3);
                  }
                  v84 = *((unsigned int *)a3 + 6);
                  if (v84 > 0x40)
                  {
                    v153 = v65;
                    v157 = v74;
                    v147 = v38;
                    v85 = (void *)operator new[]();
                    memcpy(v85, *(const void **)v162, ((unint64_t)(v84 + 63) >> 3) & 0x3FFFFFF8);
                    v120 = (uint64_t *)v167;
                    v121 = (unint64_t)(v84 + 63) >> 6;
                    v122 = v85;
                    do
                    {
                      v123 = *v120++;
                      *v122++ &= v123;
                      --v121;
                    }
                    while (v121);
                    v60 = v162;
                    v38 = v147;
                    v65 = v153;
                    v74 = v157;
                  }
                  else
                  {
                    v85 = (void *)(v167 & *(_QWORD *)v60);
                  }
                  if (*((_DWORD *)a3 + 2) >= 0x41u && *a3)
                  {
                    v148 = v41;
                    v150 = v65;
                    v88 = v38;
                    v154 = v74;
                    MEMORY[0x1CAA32F9C](*a3, 0x1000C8000313F17);
                    v65 = v150;
                    v74 = v154;
                    v38 = v88;
                    v41 = v148;
                    v60 = v162;
                  }
                  *a3 = (unint64_t)v83;
                  *((_DWORD *)a3 + 2) = (_DWORD)v82;
                  if (*((_DWORD *)a3 + 6) >= 0x41u && *(_QWORD *)v60)
                  {
                    v82 = v38;
                    v89 = v65;
                    v155 = v74;
                    MEMORY[0x1CAA32F9C](*(_QWORD *)v60, 0x1000C8000313F17);
                    v74 = v155;
                    v65 = v89;
                    v38 = v82;
                    v60 = v162;
                    LODWORD(v82) = *((_DWORD *)a3 + 2);
                  }
                  a3[2] = (unint64_t)v85;
                  *((_DWORD *)a3 + 6) = v84;
                  if (v82 > 0x40)
                  {
                    v149 = v41;
                    v151 = v65;
                    v104 = v38;
                    v105 = v74;
                    v106 = llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)a3);
                    v74 = v105;
                    v38 = v104;
                    v41 = v149;
                    v65 = v151;
                    v60 = v162;
                    if (v106 == (_DWORD)v82)
                    {
LABEL_133:
                      if (v84 > 0x40)
                      {
                        v124 = v38;
                        v125 = v65;
                        v126 = v74;
                        v127 = llvm::APInt::countLeadingZerosSlowCase(v60);
                        v74 = v126;
                        v65 = v125;
                        v38 = v124;
                        v60 = v162;
                        v86 = v127 == (_DWORD)v84;
                      }
                      else
                      {
                        v86 = v85 == 0;
                      }
                      v87 = v86;
                      goto LABEL_150;
                    }
                  }
                  else if (!*a3)
                  {
                    goto LABEL_133;
                  }
                  v87 = 0;
LABEL_150:
                  if (v168 >= 0x41 && v167)
                  {
                    v108 = v41;
                    v109 = v38;
                    v110 = v65;
                    v111 = v74;
                    MEMORY[0x1CAA32F9C](v167, 0x1000C8000313F17);
                    v74 = v111;
                    v65 = v110;
                    v38 = v109;
                    v41 = v108;
                    v60 = v162;
                  }
                  if (v166 >= 0x41 && v165)
                  {
                    v112 = v41;
                    v113 = v38;
                    v114 = v65;
                    v115 = v74;
                    MEMORY[0x1CAA32F9C](v165, 0x1000C8000313F17);
                    v74 = v115;
                    v65 = v114;
                    v38 = v113;
                    v41 = v112;
                    v60 = v162;
                  }
                  if (++*(_QWORD *)&v72 > (unint64_t)v73)
                    v107 = 1;
                  else
                    v107 = v87;
                  if ((v107 & 1) != 0)
                    goto LABEL_97;
                }
              }
            }
            else
            {
              *(_QWORD *)v60 = -1;
              if ((_DWORD)v69)
                goto LABEL_90;
            }
            v70 = 0;
            goto LABEL_91;
          }
LABEL_87:
          v68 = a3;
          goto LABEL_88;
        }
      }
      else
      {
        *a3 = -1;
        if ((_DWORD)v66)
          goto LABEL_86;
      }
      v67 = 0;
      goto LABEL_87;
    }
    v143 = v41;
    v144 = v38;
    v145 = llvm::APInt::countLeadingZerosSlowCase(v38);
    v54 = (_QWORD *)v160;
    v38 = v144;
    v41 = v143;
    if (v145 != v57)
      goto LABEL_72;
  }
LABEL_98:
  sub_1C4912E54(a3, *((_DWORD *)a3 + 2) - v37, *((_DWORD *)a3 + 2));
  sub_1C4912E54(v162, *((_DWORD *)a3 + 6) - v164, *((_DWORD *)a3 + 6));
  if (v161 >= 0x41 && v160)
    MEMORY[0x1CAA32F9C](v160, 0x1000C8000313F17);
  if (v13 >= 0x41 && v41)
    MEMORY[0x1CAA32F9C](v41, 0x1000C8000313F17);
}

uint64_t llvm::KnownBits::eq(int8x8_t *a1, int8x8_t *a2)
{
  uint64_t v2;
  int8x8_t v3;
  uint8x8_t v4;
  __int32 v5;
  uint64_t v6;
  uint8x8_t v7;
  __int32 v8;
  uint64_t v9;
  uint8x8_t v10;
  __int32 v11;
  uint64_t v12;
  uint8x8_t v13;
  __int32 v14;
  BOOL v15;
  int v16;
  unint64_t v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t *v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  BOOL v31;
  uint64_t v33;
  uint8x8_t v34;
  unint64_t v35;
  int8x8_t *v36;
  int8x8_t v37;
  uint8x8_t v38;
  unint64_t v39;
  int8x8_t *v40;
  int8x8_t v41;
  uint8x8_t v42;
  unint64_t v43;
  int8x8_t *v44;
  int8x8_t v45;
  uint8x8_t v46;

  v2 = a1[1].u32[0];
  if (v2 > 0x40)
  {
    v33 = 0;
    v5 = 0;
    v3 = *a1;
    do
    {
      v34 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(*(_QWORD *)&v3 + v33));
      v34.i16[0] = vaddlv_u8(v34);
      v5 += v34.i32[0];
      v33 += 8;
    }
    while ((((unint64_t)(v2 + 63) >> 3) & 0x3FFFFFF8) != v33);
  }
  else
  {
    v3 = *a1;
    v4 = (uint8x8_t)vcnt_s8(*a1);
    v4.i16[0] = vaddlv_u8(v4);
    v5 = v4.i32[0];
  }
  v6 = a1[3].u32[0];
  if (v6 > 0x40)
  {
    v8 = 0;
    v35 = (unint64_t)(v6 + 63) >> 6;
    v36 = (int8x8_t *)a1[2];
    do
    {
      v37 = *v36++;
      v38 = (uint8x8_t)vcnt_s8(v37);
      v38.i16[0] = vaddlv_u8(v38);
      v8 += v38.i32[0];
      --v35;
    }
    while (v35);
  }
  else
  {
    v7 = (uint8x8_t)vcnt_s8(a1[2]);
    v7.i16[0] = vaddlv_u8(v7);
    v8 = v7.i32[0];
  }
  if (v8 + v5 == (_DWORD)v2)
  {
    v9 = a2[1].u32[0];
    if (v9 > 0x40)
    {
      v11 = 0;
      v39 = (unint64_t)(v9 + 63) >> 6;
      v40 = (int8x8_t *)*a2;
      do
      {
        v41 = *v40++;
        v42 = (uint8x8_t)vcnt_s8(v41);
        v42.i16[0] = vaddlv_u8(v42);
        v11 += v42.i32[0];
        --v39;
      }
      while (v39);
    }
    else
    {
      v10 = (uint8x8_t)vcnt_s8(*a2);
      v10.i16[0] = vaddlv_u8(v10);
      v11 = v10.i32[0];
    }
    v12 = a2[3].u32[0];
    if (v12 > 0x40)
    {
      v14 = 0;
      v43 = (unint64_t)(v12 + 63) >> 6;
      v44 = (int8x8_t *)a2[2];
      do
      {
        v45 = *v44++;
        v46 = (uint8x8_t)vcnt_s8(v45);
        v46.i16[0] = vaddlv_u8(v46);
        v14 += v46.i32[0];
        --v43;
      }
      while (v43);
    }
    else
    {
      v13 = (uint8x8_t)vcnt_s8(a2[2]);
      v13.i16[0] = vaddlv_u8(v13);
      v14 = v13.i32[0];
    }
    if (v14 + v11 == (_DWORD)v9)
    {
      if (v6 > 0x40)
        v15 = memcmp(*(const void **)&a1[2], *(const void **)&a2[2], ((unint64_t)(v6 + 63) >> 3) & 0x3FFFFFF8) == 0;
      else
        v15 = *(_QWORD *)&a1[2] == *(_QWORD *)&a2[2];
      v16 = v15;
      goto LABEL_32;
    }
  }
  if (v6 > 0x40)
  {
    v17 = (unint64_t)(v6 + 63) >> 6;
    v18 = (uint64_t *)a1[2];
    v19 = (uint64_t *)*a2;
    while (1)
    {
      v21 = *v18++;
      v20 = v21;
      v22 = *v19++;
      if ((v22 & v20) != 0)
        goto LABEL_15;
      if (!--v17)
        goto LABEL_19;
    }
  }
  if ((*(_QWORD *)a2 & *(_QWORD *)&a1[2]) != 0)
  {
LABEL_15:
    v16 = 0;
LABEL_32:
    v24 = 1;
    return v16 | (v24 << 8);
  }
LABEL_19:
  v23 = a2[3].u32[0];
  if (v23 > 0x40)
  {
    v25 = (uint64_t *)a2[2];
    v26 = ((unint64_t)(v23 + 63) >> 6) - 1;
    do
    {
      v28 = *v25++;
      v27 = v28;
      v29 = **(_QWORD **)&v3;
      *(_QWORD *)&v3 += 8;
      v30 = v29 & v27;
      v24 = (v29 & v27) != 0;
      if (v30)
        v31 = 1;
      else
        v31 = v26 == 0;
      --v26;
    }
    while (!v31);
  }
  else
  {
    v24 = (*(_QWORD *)&v3 & *(_QWORD *)&a2[2]) != 0;
  }
  v16 = 0;
  return v16 | (v24 << 8);
}

uint64_t llvm::KnownBits::ne(int8x8_t *a1, int8x8_t *a2)
{
  __int16 v2;

  v2 = llvm::KnownBits::eq(a1, a2);
  if ((v2 & 0xFF00) != 0)
    return v2 ^ 1 | 0x100u;
  else
    return 0;
}

uint64_t llvm::KnownBits::ugt(const void **this, const void **a2, const llvm::KnownBits *a3)
{
  uint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  char *v9;
  int v10;
  int v11;
  size_t v12;
  char *v13;
  int v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  BOOL v20;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  char *v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  size_t v32;
  char *v33;
  int v34;

  v5 = *((unsigned int *)this + 2);
  v34 = v5;
  if (v5 > 0x40)
  {
    v33 = (char *)operator new[]();
    memcpy(v33, *this, ((unint64_t)(v5 + 63) >> 3) & 0x3FFFFFF8);
    llvm::APInt::flipAllBitsSlowCase((uint64_t)&v33);
    LODWORD(v5) = v34;
    v7 = v33;
  }
  else
  {
    v6 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v5;
    if (!(_DWORD)v5)
      v6 = 0;
    v7 = (char *)(v6 & ~(unint64_t)*this);
  }
  v8 = *((unsigned int *)a2 + 6);
  if (v8 > 0x40)
  {
    v12 = ((unint64_t)(v8 + 63) >> 3) & 0x3FFFFFF8;
    v13 = (char *)operator new[]();
    memcpy(v13, a2[2], v12);
    if (v5 > 0x40)
    {
      v29 = (((unint64_t)v5 + 63) >> 3) & 0x3FFFFFF8;
      do
      {
        if (!v29)
        {
          v14 = 0;
          goto LABEL_13;
        }
        v30 = *(_QWORD *)&v7[v29 - 8];
        v31 = *(_QWORD *)&v13[v29 - 8];
        v29 -= 8;
      }
      while (v30 == v31);
      if (v30 > v31)
        v14 = 1;
      else
        v14 = -1;
    }
    else if (v7 < v13)
    {
      v14 = -1;
    }
    else
    {
      v14 = v7 > v13;
    }
LABEL_13:
    MEMORY[0x1CAA32F9C](v13, 0x1000C8000313F17);
LABEL_14:
    if (v5 >= 0x41 && v7)
      MEMORY[0x1CAA32F9C](v7, 0x1000C8000313F17);
    if (v14 < 1)
      goto LABEL_8;
    goto LABEL_18;
  }
  v9 = (char *)a2[2];
  if (v5 > 0x40)
  {
    v25 = v9 - 8;
    v26 = (((unint64_t)v5 + 63) >> 3) & 0x3FFFFFF8;
    do
    {
      if (!v26)
      {
        v14 = 0;
        goto LABEL_14;
      }
      v27 = *(_QWORD *)&v7[v26 - 8];
      v28 = *(_QWORD *)&v25[v26];
      v26 -= 8;
    }
    while (v27 == v28);
    if (v27 > v28)
      v14 = 1;
    else
      v14 = -1;
    goto LABEL_14;
  }
  if (v7 <= v9)
  {
LABEL_8:
    v10 = 0;
    v11 = 1;
    return v10 | (v11 << 8);
  }
LABEL_18:
  v15 = *((unsigned int *)this + 6);
  if (v15 > 0x40)
  {
    v16 = (char *)operator new[]();
    memcpy(v16, this[2], ((unint64_t)(v15 + 63) >> 3) & 0x3FFFFFF8);
  }
  else
  {
    v16 = (char *)this[2];
  }
  v17 = *((unsigned int *)a2 + 2);
  v34 = v17;
  if (v17 > 0x40)
  {
    v32 = ((unint64_t)(v17 + 63) >> 3) & 0x3FFFFFF8;
    v33 = (char *)operator new[]();
    memcpy(v33, *a2, v32);
    llvm::APInt::flipAllBitsSlowCase((uint64_t)&v33);
    LODWORD(v17) = v34;
    v19 = v33;
  }
  else
  {
    v18 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v17;
    if (!(_DWORD)v17)
      v18 = 0;
    v19 = (char *)(v18 & ~(unint64_t)*a2);
  }
  if (v15 > 0x40)
  {
    v22 = ((unint64_t)(v15 + 63) >> 3) & 0x3FFFFFF8;
    while (v22)
    {
      v23 = *(_QWORD *)&v16[v22 - 8];
      v24 = *(_QWORD *)&v19[v22 - 8];
      v22 -= 8;
      v20 = v23 > v24;
      if (v23 != v24)
        goto LABEL_27;
    }
    v10 = 0;
  }
  else
  {
    v20 = v16 > v19;
LABEL_27:
    v10 = v20;
  }
  if (v17 >= 0x41 && v19)
    MEMORY[0x1CAA32F9C](v19, 0x1000C8000313F17, a3);
  if (v15 >= 0x41 && v16)
    MEMORY[0x1CAA32F9C](v16, 0x1000C8000313F17, a3);
  v11 = v10;
  return v10 | (v11 << 8);
}

uint64_t llvm::KnownBits::sgt(llvm::KnownBits *this, const llvm::KnownBits *a2, const llvm::KnownBits *a3)
{
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  _BOOL4 v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _BOOL4 v17;
  int v18;
  unsigned int v19;
  _BOOL4 v20;
  int v21;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t *v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unsigned int v34;
  uint64_t v35;
  unsigned int v36;

  sub_1C580C14C((uint64_t)this, (char *)&v35);
  sub_1C580C07C(a2, (uint64_t)&v33);
  v5 = v36;
  if (v36 > 0x40)
  {
    v23 = *(_QWORD *)(v35 + 8 * ((v36 - 1) >> 6)) & (1 << (v36 - 1));
    v12 = v34;
    v7 = v33;
    v24 = (uint64_t *)(v33 + 8 * ((v34 - 1) >> 6));
    if (v34 < 0x41)
      v24 = &v33;
    if ((v23 != 0) == (((unint64_t)*v24 >> (v34 - 1)) & 1))
    {
      v27 = (((unint64_t)v36 + 63) >> 3) & 0x3FFFFFF8;
      do
      {
        if (!v27)
        {
          v11 = 0;
          goto LABEL_6;
        }
        v28 = *(_QWORD *)(v35 - 8 + v27);
        v29 = *(_QWORD *)(v33 + v27 - 8);
        v27 -= 8;
      }
      while (v28 == v29);
      if (v28 > v29)
        v11 = 1;
      else
        v11 = -1;
    }
    else if (v23)
    {
      v11 = -1;
    }
    else
    {
      v11 = 1;
    }
  }
  else
  {
    v6 = v35 << -(char)v36 >> -(char)v36;
    v7 = v33;
    v8 = v33 << -(char)v36 >> -(char)v36;
    v9 = v6 < v8;
    v10 = v6 > v8;
    if (v9)
      v11 = -1;
    else
      v11 = v10;
    v12 = v34;
  }
LABEL_6:
  if (v12 >= 0x41 && v7)
  {
    MEMORY[0x1CAA32F9C](v7, 0x1000C8000313F17);
    v5 = v36;
  }
  if (v5 >= 0x41 && v35)
    MEMORY[0x1CAA32F9C](v35, 0x1000C8000313F17);
  if (v11 < 1)
  {
    v20 = 0;
    v21 = 1;
  }
  else
  {
    sub_1C580C07C(this, (uint64_t)&v35);
    sub_1C580C14C((uint64_t)a2, (char *)&v33);
    v13 = v36;
    if (v36 > 0x40)
    {
      v25 = *(_QWORD *)(v35 + 8 * ((v36 - 1) >> 6)) & (1 << (v36 - 1));
      v19 = v34;
      v15 = v33;
      v26 = (uint64_t *)(v33 + 8 * ((v34 - 1) >> 6));
      if (v34 < 0x41)
        v26 = &v33;
      if ((v25 != 0) == (((unint64_t)*v26 >> (v34 - 1)) & 1))
      {
        v30 = (((unint64_t)v36 + 63) >> 3) & 0x3FFFFFF8;
        do
        {
          if (!v30)
          {
            v18 = 0;
            goto LABEL_18;
          }
          v31 = *(_QWORD *)(v35 - 8 + v30);
          v32 = *(_QWORD *)(v33 + v30 - 8);
          v30 -= 8;
        }
        while (v31 == v32);
        if (v31 > v32)
          v18 = 1;
        else
          v18 = -1;
      }
      else if (v25)
      {
        v18 = -1;
      }
      else
      {
        v18 = 1;
      }
    }
    else
    {
      v14 = v35 << -(char)v36 >> -(char)v36;
      v15 = v33;
      v16 = v33 << -(char)v36 >> -(char)v36;
      v9 = v14 < v16;
      v17 = v14 > v16;
      if (v9)
        v18 = -1;
      else
        v18 = v17;
      v19 = v34;
    }
LABEL_18:
    if (v19 >= 0x41 && v15)
    {
      MEMORY[0x1CAA32F9C](v15, 0x1000C8000313F17);
      v13 = v36;
    }
    if (v13 >= 0x41 && v35)
      MEMORY[0x1CAA32F9C](v35, 0x1000C8000313F17);
    v20 = v18 > 0;
    v21 = v20;
  }
  return v20 | (v21 << 8);
}

uint64_t llvm::KnownBits::sge(llvm::KnownBits *this, const llvm::KnownBits *a2, const llvm::KnownBits *a3)
{
  __int16 v3;

  v3 = llvm::KnownBits::sgt(a2, this, a3);
  if ((v3 & 0xFF00) != 0)
    return v3 ^ 1 | 0x100u;
  else
    return 0;
}

uint64_t llvm::KnownBits::slt(llvm::KnownBits *this, const llvm::KnownBits *a2, const llvm::KnownBits *a3)
{
  return llvm::KnownBits::sgt(a2, this, a3);
}

uint64_t llvm::KnownBits::sle(llvm::KnownBits *this, const llvm::KnownBits *a2, const llvm::KnownBits *a3)
{
  __int16 v3;

  v3 = llvm::KnownBits::sgt(this, a2, a3);
  if ((v3 & 0xFF00) != 0)
    return v3 ^ 1 | 0x100u;
  else
    return 0;
}

llvm::APInt *llvm::KnownBits::abs@<X0>(llvm::KnownBits *this@<X0>, char a2@<W1>, _DWORD *a3@<X8>)
{
  unsigned int v6;
  unsigned int v7;
  unint64_t v8;
  _DWORD *v9;
  unint64_t v10;
  llvm::APInt *result;
  const void **v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  llvm::APInt *v16;
  unsigned int v17;
  unsigned int v18;

  v6 = *((_DWORD *)this + 2);
  v7 = v6 - 1;
  if (v6 <= 0x40)
  {
    v8 = *(_QWORD *)this;
    a3[2] = v6;
    v9 = a3 + 2;
    if (((v8 >> v7) & 1) != 0)
    {
      *(_QWORD *)a3 = v8;
      goto LABEL_6;
    }
    *(_QWORD *)a3 = 0;
    a3[6] = v6;
    *((_QWORD *)a3 + 2) = 0;
    goto LABEL_12;
  }
  v10 = *(_QWORD *)(*(_QWORD *)this + 8 * (v7 >> 6));
  a3[2] = v6;
  v9 = a3 + 2;
  if (((v10 >> v7) & 1) != 0)
  {
    llvm::APInt::initSlowCase((llvm::APInt *)a3, (const void **)this);
LABEL_6:
    result = (llvm::APInt *)(a3 + 4);
    v12 = (const void **)((char *)this + 16);
    v13 = *((_DWORD *)this + 6);
    a3[6] = v13;
    if (v13 > 0x40)
      return (llvm::APInt *)llvm::APInt::initSlowCase(result, v12);
    *(_QWORD *)result = *v12;
    return result;
  }
  llvm::APInt::initSlowCase((llvm::APInt *)a3, 0, 0);
  a3[6] = v6;
  llvm::APInt::initSlowCase((llvm::APInt *)(a3 + 4), 0, 0);
  if (*((_DWORD *)this + 2) <= 0x40u)
  {
    v8 = *(_QWORD *)this;
LABEL_12:
    v14 = __clz(__rbit64(~v8));
    goto LABEL_14;
  }
  v14 = llvm::APInt::countTrailingOnesSlowCase(this);
LABEL_14:
  result = (llvm::APInt *)sub_1C4912E54(a3, 0, v14);
  if ((a2 & 1) != 0)
  {
LABEL_15:
    v15 = 1 << (*v9 - 1);
    if (*v9 > 0x40u)
      *(_QWORD *)(*(_QWORD *)a3 + 8 * ((*v9 - 1) >> 6)) |= v15;
    else
      *(_QWORD *)a3 |= v15;
    return result;
  }
  v16 = (llvm::KnownBits *)((char *)this + 16);
  v17 = *((_DWORD *)this + 6);
  if (v17 > 0x40)
  {
    result = (llvm::APInt *)llvm::APInt::countLeadingZerosSlowCase(v16);
    if ((_DWORD)result != v17)
    {
      v18 = v17 - 1;
      if (((*(_QWORD *)(*(_QWORD *)v16 + 8 * (v18 >> 6)) >> v18) & 1) == 0)
        goto LABEL_15;
      result = (llvm::APInt *)llvm::APInt::countTrailingZerosSlowCase((unint64_t **)v16);
      if ((_DWORD)result != v18)
        goto LABEL_15;
    }
  }
  else if (*(_QWORD *)v16 && *(_QWORD *)v16 != 1 << (v17 - 1))
  {
    goto LABEL_15;
  }
  return result;
}

uint64_t *llvm::KnownBits::mul@<X0>(const void **this@<X0>, const void **a2@<X1>, const llvm::KnownBits *a3@<X2>, uint64_t *a4@<X8>)
{
  int v4;
  uint64_t v8;
  unint64_t v9;
  uint64_t *v10;
  unsigned int v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t *v14;
  int v15;
  int v16;
  int64_t v17;
  unint64_t v19;
  unsigned int v20;
  uint64_t v21;
  unsigned int v22;
  size_t v23;
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  unsigned int v28;
  size_t v29;
  char *v30;
  uint64_t v31;
  char *v32;
  int v33;
  int v34;
  int v35;
  unsigned int v36;
  uint64_t *v37;
  unsigned int v38;
  unsigned int v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unsigned int v44;
  size_t v45;
  unsigned int v46;
  uint64_t v47;
  _QWORD *v48;
  uint64_t *v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t *result;
  unsigned int v53;
  _QWORD *v54;
  _QWORD *v55;
  uint64_t *v56;
  unint64_t v57;
  uint64_t v58;
  _QWORD *v59;
  uint64_t *v60;
  unint64_t v61;
  uint64_t v62;
  _QWORD *v63;
  unint64_t v64;
  uint64_t *v65;
  uint64_t v66;
  _QWORD *v67;
  unint64_t v68;
  uint64_t *v69;
  uint64_t v70;
  size_t v71;
  void *v72;
  unsigned int v73;
  unint64_t v74;
  unsigned int v75;
  unint64_t v76;
  unsigned int v77;
  void *__src;
  unsigned int v79;
  BOOL v80;
  uint64_t *v81;
  unsigned int v82;
  uint64_t *v83;
  unsigned int v84;
  void *v85;
  unsigned int v86;

  v4 = (int)a3;
  v8 = *((unsigned int *)this + 2);
  v86 = v8;
  if (v8 > 0x40)
  {
    v85 = (void *)operator new[]();
    memcpy(v85, *this, ((unint64_t)(v8 + 63) >> 3) & 0x3FFFFFF8);
    llvm::APInt::flipAllBitsSlowCase((uint64_t)&v85);
    v11 = v86;
    v10 = (uint64_t *)v85;
  }
  else
  {
    v9 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v8;
    if (!(_DWORD)v8)
      v9 = 0;
    v10 = (uint64_t *)(v9 & ~(unint64_t)*this);
    v11 = v8;
  }
  v84 = v11;
  v83 = v10;
  v12 = *((unsigned int *)a2 + 2);
  v86 = v12;
  if (v12 > 0x40)
  {
    v71 = ((unint64_t)(v12 + 63) >> 3) & 0x3FFFFFF8;
    v85 = (void *)operator new[]();
    memcpy(v85, *a2, v71);
    llvm::APInt::flipAllBitsSlowCase((uint64_t)&v85);
    LODWORD(v12) = v86;
    v14 = (uint64_t *)v85;
  }
  else
  {
    v13 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v12;
    if (!(_DWORD)v12)
      v13 = 0;
    v14 = (uint64_t *)(v13 & ~(unint64_t)*a2);
  }
  v82 = v12;
  v81 = v14;
  v80 = 0;
  llvm::APInt::umul_ov((llvm::APInt *)&v83, &v81, &v80, (uint64_t)&v85);
  v15 = 0;
  if (!v80)
  {
    if (v86 > 0x40)
    {
      v16 = 0;
      v17 = ((unint64_t)v86 + 63) >> 6;
      do
      {
        if (v17-- < 1)
          break;
        v19 = *((_QWORD *)v85 + v17);
        v16 += __clz(v19);
      }
      while (!v19);
      if ((v86 & 0x3F) != 0)
        v20 = v86 | 0xFFFFFFC0;
      else
        v20 = 0;
      v15 = v16 + v20;
    }
    else
    {
      v15 = v86 + __clz((unint64_t)v85) - 64;
    }
  }
  v21 = *((unsigned int *)this + 2);
  if (v21 >= 0x41)
  {
    v23 = ((unint64_t)(v21 + 63) >> 3) & 0x3FFFFFF8;
    v24 = (char *)operator new[]();
    memcpy(v24, *this, v23);
    v25 = 0;
    v26 = (char *)this[2];
    do
    {
      *(_QWORD *)&v24[v25] |= *(_QWORD *)&v26[v25];
      v25 += 8;
    }
    while (v23 != v25);
    v79 = v21;
    __src = v24;
    v22 = llvm::APInt::countTrailingOnesSlowCase((llvm::APInt *)&__src);
    MEMORY[0x1CAA32F9C](v24, 0x1000C8000313F17);
  }
  else
  {
    v22 = __clz(__rbit64(~((unint64_t)this[2] | (unint64_t)*this)));
  }
  v27 = *((unsigned int *)a2 + 2);
  if (v27 >= 0x41)
  {
    v29 = ((unint64_t)(v27 + 63) >> 3) & 0x3FFFFFF8;
    v30 = (char *)operator new[]();
    memcpy(v30, *a2, v29);
    v31 = 0;
    v32 = (char *)a2[2];
    do
    {
      *(_QWORD *)&v30[v31] |= *(_QWORD *)&v32[v31];
      v31 += 8;
    }
    while (v29 != v31);
    v79 = v27;
    __src = v30;
    v28 = llvm::APInt::countTrailingOnesSlowCase((llvm::APInt *)&__src);
    MEMORY[0x1CAA32F9C](v30, 0x1000C8000313F17);
  }
  else
  {
    v28 = __clz(__rbit64(~((unint64_t)a2[2] | (unint64_t)*a2)));
  }
  if (*((_DWORD *)this + 2) > 0x40u)
    v33 = llvm::APInt::countTrailingOnesSlowCase((llvm::APInt *)this);
  else
    v33 = __clz(__rbit64(~(unint64_t)*this));
  if (*((_DWORD *)a2 + 2) > 0x40u)
    v34 = llvm::APInt::countTrailingOnesSlowCase((llvm::APInt *)a2);
  else
    v34 = __clz(__rbit64(~(unint64_t)*a2));
  v35 = v22 - v33;
  if (v28 - v34 < v22 - v33)
    v35 = v28 - v34;
  if (v8 >= v34 + v33 + v35)
    v36 = v34 + v33 + v35;
  else
    v36 = v8;
  v77 = *((_DWORD *)this + 6);
  if (v77 > 0x40)
    llvm::APInt::initSlowCase((llvm::APInt *)&v76, 0, 0);
  else
    v76 = 0;
  sub_1C4912E54(&v76, 0, v22);
  if (v77 > 0x40)
  {
    v55 = (_QWORD *)v76;
    v56 = (uint64_t *)this[2];
    v57 = ((unint64_t)v77 + 63) >> 6;
    do
    {
      v58 = *v56++;
      *v55++ &= v58;
      --v57;
    }
    while (v57);
  }
  else
  {
    v76 &= (unint64_t)this[2];
  }
  v75 = *((_DWORD *)a2 + 6);
  if (v75 > 0x40)
    llvm::APInt::initSlowCase((llvm::APInt *)&v74, 0, 0);
  else
    v74 = 0;
  sub_1C4912E54(&v74, 0, v28);
  if (v75 > 0x40)
  {
    v59 = (_QWORD *)v74;
    v60 = (uint64_t *)a2[2];
    v61 = ((unint64_t)v75 + 63) >> 6;
    do
    {
      v62 = *v60++;
      *v59++ &= v62;
      --v61;
    }
    while (v61);
  }
  else
  {
    v74 &= (unint64_t)a2[2];
  }
  llvm::APInt::operator*((uint64_t)&v76, &v74, (uint64_t)&__src);
  if (v75 >= 0x41 && v74)
    MEMORY[0x1CAA32F9C](v74, 0x1000C8000313F17);
  if (v77 >= 0x41 && v76)
    MEMORY[0x1CAA32F9C](v76, 0x1000C8000313F17);
  *((_DWORD *)a4 + 2) = v8;
  v37 = a4 + 2;
  if (v8 > 0x40)
  {
    llvm::APInt::initSlowCase((llvm::APInt *)a4, 0, 0);
    *((_DWORD *)a4 + 6) = v8;
    llvm::APInt::initSlowCase((llvm::APInt *)(a4 + 2), 0, 0);
    v38 = *((_DWORD *)a4 + 2);
  }
  else
  {
    *a4 = 0;
    *((_DWORD *)a4 + 6) = v8;
    v38 = v8;
    a4[2] = 0;
  }
  sub_1C4912E54(a4, v38 - v15, v38);
  v39 = v79;
  v73 = v79;
  if (v79 <= 0x40)
  {
    v40 = (unint64_t)__src;
    v41 = ~(unint64_t)__src;
    v42 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v79;
    if (!v79)
      v42 = 0;
    v43 = v42 & v41;
    v72 = (void *)(v42 & v41);
    v73 = 0;
    v77 = v79;
    v44 = v79;
    goto LABEL_61;
  }
  v45 = (((unint64_t)v79 + 63) >> 3) & 0x3FFFFFF8;
  v72 = (void *)operator new[]();
  v40 = (unint64_t)__src;
  memcpy(v72, __src, v45);
  llvm::APInt::flipAllBitsSlowCase((uint64_t)&v72);
  v44 = v73;
  v43 = (unint64_t)v72;
  v73 = 0;
  v77 = v44;
  if (v44 <= 0x40)
  {
LABEL_61:
    v76 = 0;
    goto LABEL_62;
  }
  llvm::APInt::initSlowCase((llvm::APInt *)&v76, 0, 0);
LABEL_62:
  sub_1C4912E54(&v76, 0, v36);
  v46 = v77;
  if (v77 > 0x40)
  {
    v63 = (_QWORD *)v76;
    v64 = ((unint64_t)v77 + 63) >> 6;
    v65 = (uint64_t *)v43;
    do
    {
      v66 = *v65++;
      *v63++ &= v66;
      --v64;
    }
    while (v64);
  }
  else
  {
    v76 &= v43;
  }
  v47 = *((unsigned int *)a4 + 2);
  if (v47 > 0x40)
  {
    v48 = (_QWORD *)*a4;
    v49 = (uint64_t *)v76;
    v50 = (unint64_t)(v47 + 63) >> 6;
    do
    {
      v51 = *v49++;
      *v48++ |= v51;
      --v50;
    }
    while (v50);
  }
  else
  {
    *a4 |= v76;
  }
  if (v46 >= 0x41 && v76)
    MEMORY[0x1CAA32F9C](v76, 0x1000C8000313F17);
  if (v44 >= 0x41 && v43)
    MEMORY[0x1CAA32F9C](v43, 0x1000C8000313F17);
  v77 = v39;
  if (v39 > 0x40)
    llvm::APInt::initSlowCase((llvm::APInt *)&v76, 0, 0);
  else
    v76 = 0;
  result = sub_1C4912E54(&v76, 0, v36);
  v53 = v77;
  if (v77 > 0x40)
  {
    v67 = (_QWORD *)v76;
    v68 = ((unint64_t)v77 + 63) >> 6;
    v69 = (uint64_t *)v40;
    do
    {
      v70 = *v69++;
      *v67++ &= v70;
      --v68;
    }
    while (v68);
  }
  else
  {
    v76 &= v40;
  }
  if (*((_DWORD *)a4 + 6) >= 0x41u)
  {
    result = (uint64_t *)*v37;
    if (*v37)
    {
      result = (uint64_t *)MEMORY[0x1CAA32F9C](result, 0x1000C8000313F17);
      v53 = v77;
    }
  }
  a4[2] = v76;
  *((_DWORD *)a4 + 6) = v53;
  if (v8 >= 2 && v4)
  {
    if (*((_DWORD *)a4 + 2) >= 0x41u)
      v54 = (_QWORD *)*a4;
    else
      v54 = a4;
    *v54 |= 2uLL;
  }
  if (v39 >= 0x41 && v40)
    result = (uint64_t *)MEMORY[0x1CAA32F9C](v40, 0x1000C8000313F17);
  if (v86 >= 0x41)
  {
    result = (uint64_t *)v85;
    if (v85)
      result = (uint64_t *)MEMORY[0x1CAA32F9C](v85, 0x1000C8000313F17);
  }
  if (v82 >= 0x41)
  {
    result = v81;
    if (v81)
      result = (uint64_t *)MEMORY[0x1CAA32F9C](v81, 0x1000C8000313F17);
  }
  if (v84 >= 0x41)
  {
    result = v83;
    if (v83)
      return (uint64_t *)MEMORY[0x1CAA32F9C](v83, 0x1000C8000313F17);
  }
  return result;
}

llvm::APInt *sub_1C5E1C0A4@<X0>(uint64_t a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  llvm::APInt *result;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;

  llvm::APInt::sext((llvm::APInt *)a1, a2, (llvm::APInt *)&v9);
  result = llvm::APInt::sext((llvm::APInt *)(a1 + 16), a2, (llvm::APInt *)&v7);
  *(_DWORD *)(a3 + 8) = v10;
  *(_QWORD *)a3 = v9;
  *(_DWORD *)(a3 + 24) = v8;
  *(_QWORD *)(a3 + 16) = v7;
  return result;
}

void sub_1C5E1C110(uint64_t a1@<X0>, unsigned int a2@<W1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;

  llvm::APInt::extractBits((llvm::APInt *)a1, a2, a3, (unsigned int *)&v10);
  llvm::APInt::extractBits((llvm::APInt *)(a1 + 16), a2, a3, (unsigned int *)&v8);
  *(_DWORD *)(a4 + 8) = v11;
  *(_QWORD *)a4 = v10;
  *(_DWORD *)(a4 + 24) = v9;
  *(_QWORD *)(a4 + 16) = v8;
}

void sub_1C5E1C184(_DWORD *a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  unsigned int v6;
  unsigned int v7;
  void *v8;
  size_t v9;
  uint64_t v10;
  int v11;
  void *__src;
  unsigned int v13;

  v6 = a1[2];
  llvm::APInt::zext((llvm::APInt *)a1, a2, (uint64_t)&__src);
  sub_1C4912E54(&__src, v6, v13);
  v7 = v13;
  if (v13 > 0x40)
  {
    v9 = (((unint64_t)v13 + 63) >> 3) & 0x3FFFFFF8;
    v8 = (void *)operator new[]();
    memcpy(v8, __src, v9);
  }
  else
  {
    v8 = __src;
  }
  llvm::APInt::zext((llvm::APInt *)(a1 + 4), a2, (uint64_t)&v10);
  *(_DWORD *)(a3 + 8) = v7;
  *(_QWORD *)a3 = v8;
  *(_DWORD *)(a3 + 24) = v11;
  *(_QWORD *)(a3 + 16) = v10;
  v11 = 0;
  if (v13 >= 0x41)
  {
    if (__src)
      MEMORY[0x1CAA32F9C](__src, 0x1000C8000313F17);
  }
}

_QWORD *llvm::KnownBits::udiv@<X0>(llvm::KnownBits *this@<X0>, const llvm::KnownBits *a2@<X1>, unsigned int *a3@<X8>)
{
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  llvm::APInt *v10;
  unsigned int v11;
  int v12;
  unsigned int v13;

  v7 = *((_DWORD *)this + 2);
  a3[2] = v7;
  if (v7 <= 0x40)
  {
    *(_QWORD *)a3 = 0;
    a3[6] = v7;
    v8 = v7;
    *((_QWORD *)a3 + 2) = 0;
    goto LABEL_3;
  }
  llvm::APInt::initSlowCase((llvm::APInt *)a3, 0, 0);
  a3[6] = v7;
  llvm::APInt::initSlowCase((llvm::APInt *)(a3 + 4), 0, 0);
  v8 = *((_DWORD *)this + 2);
  if (v8 <= 0x40)
  {
LABEL_3:
    if (v8)
      v9 = __clz(~(*(_QWORD *)this << -(char)v8));
    else
      v9 = 0;
    goto LABEL_5;
  }
  v9 = llvm::APInt::countLeadingOnesSlowCase(this);
LABEL_5:
  v10 = (const llvm::KnownBits *)((char *)a2 + 16);
  v11 = *((_DWORD *)a2 + 6);
  if (v11 > 0x40)
    v12 = llvm::APInt::countLeadingZerosSlowCase(v10);
  else
    v12 = v11 + __clz(*(_QWORD *)v10) - 64;
  v13 = v9 + v7 + ~v12;
  if (v13 >= v7)
    v13 = v7;
  if (v12 == v7)
    v13 = v9;
  return sub_1C4912E54(a3, a3[2] - v13, a3[2]);
}

_QWORD *llvm::KnownBits::urem@<X0>(llvm::KnownBits *this@<X0>, int8x8_t *a2@<X1>, unsigned int *a3@<X8>)
{
  unsigned int v7;
  llvm::APInt *v8;
  uint64_t v9;
  int8x8_t v10;
  uint8x8_t v11;
  __int32 v12;
  uint64_t v13;
  uint64_t v14;
  uint8x8_t v15;
  __int32 v16;
  unsigned int v18;
  unsigned int v19;
  _QWORD *result;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  uint64_t *v29;
  unint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  void *v34;
  unint64_t v35;
  uint64_t *v36;
  _QWORD *v37;
  uint64_t v38;
  unint64_t v39;
  int8x8_t *v40;
  int8x8_t v41;
  uint8x8_t v42;
  int v43;
  unint64_t v44;
  int8x8_t *v45;
  int8x8_t v46;
  uint8x8_t v47;
  int v48;
  size_t v50;
  void *v51;
  unsigned int v52;
  uint64_t v53;
  unsigned __int32 v54;

  v7 = *((_DWORD *)this + 2);
  a3[2] = v7;
  v8 = (llvm::APInt *)(a3 + 4);
  if (v7 > 0x40)
  {
    llvm::APInt::initSlowCase((llvm::APInt *)a3, 0, 0);
    a3[6] = v7;
    llvm::APInt::initSlowCase(v8, 0, 0);
  }
  else
  {
    *(_QWORD *)a3 = 0;
    a3[6] = v7;
    *((_QWORD *)a3 + 2) = 0;
  }
  v9 = a2[1].u32[0];
  if (v9 > 0x40)
  {
    v12 = 0;
    v39 = (unint64_t)(v9 + 63) >> 6;
    v10 = *a2;
    v40 = (int8x8_t *)*a2;
    do
    {
      v41 = *v40++;
      v42 = (uint8x8_t)vcnt_s8(v41);
      v42.i16[0] = vaddlv_u8(v42);
      v12 += v42.i32[0];
      --v39;
    }
    while (v39);
  }
  else
  {
    v10 = *a2;
    v11 = (uint8x8_t)vcnt_s8(*a2);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.i32[0];
  }
  v13 = a2[3].u32[0];
  if (v13 > 0x40)
  {
    v43 = 0;
    v44 = (unint64_t)(v13 + 63) >> 6;
    v45 = (int8x8_t *)a2[2];
    do
    {
      v46 = *v45++;
      v47 = (uint8x8_t)vcnt_s8(v46);
      v47.i16[0] = vaddlv_u8(v47);
      v43 += v47.i32[0];
      --v44;
    }
    while (v44);
    v48 = v43 + v12;
    if (v43 != 1 || v48 != (_DWORD)v9)
    {
LABEL_10:
      v18 = *((_DWORD *)this + 2);
      if (v18 > 0x40)
      {
        v19 = llvm::APInt::countLeadingOnesSlowCase(this);
      }
      else if (v18)
      {
        v19 = __clz(~(*(_QWORD *)this << -(char)v18));
      }
      else
      {
        v19 = 0;
      }
      if (v9 > 0x40)
      {
        v27 = llvm::APInt::countLeadingOnesSlowCase((llvm::APInt *)a2);
      }
      else
      {
        v26 = __clz(~(*(_QWORD *)&v10 << -(char)v9));
        if ((_DWORD)v9)
          v27 = v26;
        else
          v27 = 0;
      }
      if (v19 <= v27)
        v28 = v27;
      else
        v28 = v19;
      return sub_1C4912E54(a3, a3[2] - v28, a3[2]);
    }
    v54 = a2[3].u32[0];
    v50 = ((unint64_t)(v13 + 63) >> 3) & 0x3FFFFFF8;
    v53 = operator new[]();
    memcpy((void *)v53, *(const void **)&a2[2], v50);
  }
  else
  {
    v14 = (uint64_t)a2[2];
    v15 = (uint8x8_t)vcnt_s8((int8x8_t)v14);
    v15.i16[0] = vaddlv_u8(v15);
    v16 = v12 + v15.i32[0];
    if (v15.u32[0] != 1 || v16 != (_DWORD)v9)
      goto LABEL_10;
    v54 = a2[3].u32[0];
    v53 = v14;
  }
  result = (_QWORD *)llvm::APInt::operator-=((uint64_t)&v53, 1uLL);
  v21 = v54;
  v22 = v53;
  v54 = 0;
  v52 = v21;
  if (v21 > 0x40)
  {
    v51 = (void *)operator new[]();
    memcpy(v51, (const void *)v22, ((unint64_t)(v21 + 63) >> 3) & 0x3FFFFFF8);
    result = (_QWORD *)llvm::APInt::flipAllBitsSlowCase((uint64_t)&v51);
    v25 = v52;
    v24 = (unint64_t)v51;
    if (v52 > 0x40)
    {
      v29 = *(uint64_t **)this;
      v30 = ((unint64_t)v52 + 63) >> 6;
      v31 = v51;
      do
      {
        v32 = *v29++;
        *v31++ |= v32;
        --v30;
      }
      while (v30);
      goto LABEL_32;
    }
  }
  else
  {
    v23 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v21;
    if (!(_DWORD)v21)
      v23 = 0;
    v24 = v23 & ~v53;
    v25 = v21;
  }
  v24 |= *(_QWORD *)this;
LABEL_32:
  if (a3[2] >= 0x41)
  {
    result = *(_QWORD **)a3;
    if (*(_QWORD *)a3)
      result = (_QWORD *)MEMORY[0x1CAA32F9C](result, 0x1000C8000313F17);
  }
  *(_QWORD *)a3 = v24;
  a3[2] = v25;
  v33 = *((unsigned int *)this + 6);
  if (v33 > 0x40)
  {
    v34 = (void *)operator new[]();
    result = memcpy(v34, *((const void **)this + 2), ((unint64_t)(v33 + 63) >> 3) & 0x3FFFFFF8);
    v35 = (unint64_t)(v33 + 63) >> 6;
    v36 = (uint64_t *)v22;
    v37 = v34;
    do
    {
      v38 = *v36++;
      *v37++ &= v38;
      --v35;
    }
    while (v35);
  }
  else
  {
    v34 = (void *)(*((_QWORD *)this + 2) & v22);
  }
  if (a3[6] >= 0x41)
  {
    result = *(_QWORD **)v8;
    if (*(_QWORD *)v8)
      result = (_QWORD *)MEMORY[0x1CAA32F9C](result, 0x1000C8000313F17);
  }
  *((_QWORD *)a3 + 2) = v34;
  a3[6] = v33;
  if (v21 >= 0x41 && v22)
    return (_QWORD *)MEMORY[0x1CAA32F9C](v22, 0x1000C8000313F17);
  return result;
}

uint64_t llvm::KnownBits::srem@<X0>(llvm::KnownBits *this@<X0>, int8x8_t *a2@<X1>, unsigned int *a3@<X8>)
{
  unsigned int v7;
  llvm::APInt *v8;
  uint64_t v9;
  uint8x8_t v10;
  __int32 v11;
  uint64_t v12;
  uint64_t v13;
  uint8x8_t v14;
  __int32 v15;
  unsigned int v17;
  int v18;
  uint64_t result;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  unint64_t v24;
  uint64_t *v25;
  _QWORD *v26;
  uint64_t v27;
  const void **v28;
  uint64_t v29;
  void *v30;
  unint64_t v31;
  uint64_t *v32;
  _QWORD *v33;
  uint64_t v34;
  unsigned int v35;
  unsigned int v36;
  uint64_t v37;
  llvm::KnownBits *v38;
  uint64_t v39;
  unsigned int v40;
  unint64_t v41;
  size_t v42;
  uint64_t v43;
  unint64_t v44;
  unsigned int v45;
  uint64_t v46;
  _QWORD *v47;
  unint64_t v48;
  uint64_t *v49;
  uint64_t v50;
  unsigned int v51;
  unsigned int v52;
  uint64_t v53;
  _QWORD *v54;
  unint64_t v55;
  unint64_t v56;
  unsigned int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  _QWORD *v61;
  unint64_t v62;
  uint64_t *v63;
  uint64_t v64;
  unint64_t v65;
  int8x8_t *v66;
  int8x8_t v67;
  uint8x8_t v68;
  int v69;
  unint64_t v70;
  int8x8_t *v71;
  int8x8_t v72;
  uint8x8_t v73;
  int v74;
  size_t v76;
  void *v77;
  unsigned int v78;
  uint64_t v79;
  unsigned int v80;
  uint64_t v81;
  unsigned __int32 v82;

  v7 = *((_DWORD *)this + 2);
  a3[2] = v7;
  v8 = (llvm::APInt *)(a3 + 4);
  if (v7 > 0x40)
  {
    llvm::APInt::initSlowCase((llvm::APInt *)a3, 0, 0);
    a3[6] = v7;
    llvm::APInt::initSlowCase(v8, 0, 0);
  }
  else
  {
    *(_QWORD *)a3 = 0;
    a3[6] = v7;
    *((_QWORD *)a3 + 2) = 0;
  }
  v9 = a2[1].u32[0];
  if (v9 > 0x40)
  {
    v11 = 0;
    v65 = (unint64_t)(v9 + 63) >> 6;
    v66 = (int8x8_t *)*a2;
    do
    {
      v67 = *v66++;
      v68 = (uint8x8_t)vcnt_s8(v67);
      v68.i16[0] = vaddlv_u8(v68);
      v11 += v68.i32[0];
      --v65;
    }
    while (v65);
  }
  else
  {
    v10 = (uint8x8_t)vcnt_s8(*a2);
    v10.i16[0] = vaddlv_u8(v10);
    v11 = v10.i32[0];
  }
  v12 = a2[3].u32[0];
  if (v12 > 0x40)
  {
    v69 = 0;
    v70 = (unint64_t)(v12 + 63) >> 6;
    v71 = (int8x8_t *)a2[2];
    do
    {
      v72 = *v71++;
      v73 = (uint8x8_t)vcnt_s8(v72);
      v73.i16[0] = vaddlv_u8(v73);
      v69 += v73.i32[0];
      --v70;
    }
    while (v70);
    v74 = v69 + v11;
    if (v69 != 1 || v74 != (_DWORD)v9)
    {
LABEL_10:
      v17 = *((_DWORD *)this + 2);
      if (v17 > 0x40)
      {
        v18 = llvm::APInt::countLeadingOnesSlowCase(this);
      }
      else if (v17)
      {
        v18 = __clz(~(*(_QWORD *)this << -(char)v17));
      }
      else
      {
        v18 = 0;
      }
      return (uint64_t)sub_1C4912E54(a3, a3[2] - v18, a3[2]);
    }
    v82 = a2[3].u32[0];
    v76 = ((unint64_t)(v12 + 63) >> 3) & 0x3FFFFFF8;
    v81 = operator new[]();
    memcpy((void *)v81, *(const void **)&a2[2], v76);
  }
  else
  {
    v13 = (uint64_t)a2[2];
    v14 = (uint8x8_t)vcnt_s8((int8x8_t)v13);
    v14.i16[0] = vaddlv_u8(v14);
    v15 = v11 + v14.i32[0];
    if (v14.u32[0] != 1 || v15 != (_DWORD)v9)
      goto LABEL_10;
    v82 = a2[3].u32[0];
    v81 = v13;
  }
  result = llvm::APInt::operator-=((uint64_t)&v81, 1uLL);
  v20 = v82;
  v21 = v81;
  v82 = 0;
  v22 = *((unsigned int *)this + 2);
  if (v22 > 0x40)
  {
    v23 = (void *)operator new[]();
    result = (uint64_t)memcpy(v23, *(const void **)this, ((unint64_t)(v22 + 63) >> 3) & 0x3FFFFFF8);
    v24 = (unint64_t)(v22 + 63) >> 6;
    v25 = (uint64_t *)v21;
    v26 = v23;
    do
    {
      v27 = *v25++;
      *v26++ &= v27;
      --v24;
    }
    while (v24);
  }
  else
  {
    v23 = (void *)(*(_QWORD *)this & v81);
  }
  if (a3[2] >= 0x41)
  {
    result = *(_QWORD *)a3;
    if (*(_QWORD *)a3)
      result = MEMORY[0x1CAA32F9C](result, 0x1000C8000313F17);
  }
  *(_QWORD *)a3 = v23;
  a3[2] = v22;
  v28 = (const void **)((char *)this + 16);
  v29 = *((unsigned int *)this + 6);
  if (v29 > 0x40)
  {
    v30 = (void *)operator new[]();
    result = (uint64_t)memcpy(v30, *v28, ((unint64_t)(v29 + 63) >> 3) & 0x3FFFFFF8);
    v31 = (unint64_t)(v29 + 63) >> 6;
    v32 = (uint64_t *)v21;
    v33 = v30;
    do
    {
      v34 = *v32++;
      *v33++ &= v34;
      --v31;
    }
    while (v31);
  }
  else
  {
    v30 = (void *)((unint64_t)*v28 & v21);
  }
  if (a3[6] >= 0x41)
  {
    result = *(_QWORD *)v8;
    if (*(_QWORD *)v8)
      result = MEMORY[0x1CAA32F9C](result, 0x1000C8000313F17);
  }
  *((_QWORD *)a3 + 2) = v30;
  a3[6] = v29;
  v35 = *((_DWORD *)this + 2);
  v36 = v35 - 1;
  v37 = *(_QWORD *)this;
  if (v35 >= 0x41)
    v38 = (llvm::KnownBits *)(*(_QWORD *)this + 8 * (v36 >> 6));
  else
    v38 = this;
  if (((*(_QWORD *)v38 >> v36) & 1) != 0)
  {
    v80 = v20;
    v39 = v21;
    v40 = v20;
    if (v20 >= 0x41)
    {
      v41 = v20 + 63;
LABEL_36:
      v42 = (v41 >> 3) & 0x3FFFFFF8;
      v39 = operator new[]();
      v79 = v39;
      memcpy((void *)v39, (const void *)v21, v42);
      v40 = v80;
      if (v80 > 0x40)
      {
        llvm::APInt::flipAllBitsSlowCase((uint64_t)&v79);
        result = v79;
LABEL_41:
        v45 = v80;
        v80 = 0;
        v46 = a3[2];
        if (v46 > 0x40)
        {
          v47 = *(_QWORD **)a3;
          v48 = (unint64_t)(v46 + 63) >> 6;
          v49 = (uint64_t *)result;
          do
          {
            v50 = *v49++;
            *v47++ |= v50;
            --v48;
          }
          while (v48);
        }
        else
        {
          *(_QWORD *)a3 |= result;
        }
        if (v45 >= 0x41 && result)
          result = MEMORY[0x1CAA32F9C](result, 0x1000C8000313F17);
        if (v80 >= 0x41)
        {
          result = v79;
          if (v79)
            result = MEMORY[0x1CAA32F9C](v79, 0x1000C8000313F17);
        }
        goto LABEL_54;
      }
    }
LABEL_37:
    v43 = ~v39;
    if (v40)
      v44 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v40;
    else
      v44 = 0;
    result = v44 & v43;
    v79 = v44 & v43;
    goto LABEL_41;
  }
  if (v20 > 0x40)
  {
    v59 = 0;
    v41 = v20 + 63;
    while ((*(_QWORD *)(v21 + v59) & ~*(_QWORD *)(v37 + v59)) == 0)
    {
      v59 += 8;
      if ((((unint64_t)(v20 + 63) >> 3) & 0x3FFFFFF8) == v59)
      {
        v80 = v20;
        goto LABEL_36;
      }
    }
    goto LABEL_54;
  }
  if ((v21 & ~v37) == 0)
  {
    v80 = v20;
    v39 = v21;
    v40 = v20;
    goto LABEL_37;
  }
LABEL_54:
  v51 = *((_DWORD *)this + 6);
  v52 = v51 - 1;
  v53 = *((_QWORD *)this + 2);
  if (v51 >= 0x41)
    v54 = (_QWORD *)(v53 + 8 * (v52 >> 6));
  else
    v54 = (_QWORD *)((char *)this + 16);
  if (((*v54 >> v52) & 1) != 0)
  {
    if (v20 > 0x40)
    {
      v58 = 0;
      while ((*(_QWORD *)(v53 + v58) & *(_QWORD *)(v21 + v58)) == 0)
      {
        v58 += 8;
        if ((((unint64_t)(v20 + 63) >> 3) & 0x3FFFFFF8) == v58)
          goto LABEL_81;
      }
      v78 = v20;
      v77 = (void *)operator new[]();
      memcpy(v77, (const void *)v21, ((unint64_t)(v20 + 63) >> 3) & 0x3FFFFFF8);
      result = llvm::APInt::flipAllBitsSlowCase((uint64_t)&v77);
      v57 = v78;
      v56 = (unint64_t)v77;
    }
    else
    {
      if ((v21 & v53) == 0)
        return result;
      v55 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v20;
      if (!(_DWORD)v20)
        v55 = 0;
      v56 = v55 & ~v21;
      v57 = v20;
    }
    v78 = 0;
    v60 = a3[6];
    if (v60 > 0x40)
    {
      v61 = *(_QWORD **)v8;
      v62 = (unint64_t)(v60 + 63) >> 6;
      v63 = (uint64_t *)v56;
      do
      {
        v64 = *v63++;
        *v61++ |= v64;
        --v62;
      }
      while (v62);
    }
    else
    {
      *(_QWORD *)v8 |= v56;
    }
    if (v57 >= 0x41)
    {
      if (v56)
      {
        result = MEMORY[0x1CAA32F9C](v56, 0x1000C8000313F17);
        if (v78 >= 0x41)
          result = MEMORY[0x1CAA32F9C](v56, 0x1000C8000313F17);
      }
    }
  }
  if (v20 >= 0x41)
  {
LABEL_81:
    if (v21)
      return MEMORY[0x1CAA32F9C](v21, 0x1000C8000313F17);
  }
  return result;
}

uint64_t llvm::KnownBits::operator&=(uint64_t result, uint64_t **a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t *v5;
  unint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t *v9;
  unint64_t v10;
  uint64_t v11;

  v2 = *(unsigned int *)(result + 8);
  if (v2 > 0x40)
  {
    v4 = *(_QWORD **)result;
    v5 = *a2;
    v6 = (unint64_t)(v2 + 63) >> 6;
    do
    {
      v7 = *v5++;
      *v4++ |= v7;
      --v6;
    }
    while (v6);
  }
  else
  {
    *(_QWORD *)result |= (unint64_t)*a2;
  }
  v3 = *(unsigned int *)(result + 24);
  if (v3 > 0x40)
  {
    v8 = *(_QWORD **)(result + 16);
    v9 = a2[2];
    v10 = (unint64_t)(v3 + 63) >> 6;
    do
    {
      v11 = *v9++;
      *v8++ &= v11;
      --v10;
    }
    while (v10);
  }
  else
  {
    *(_QWORD *)(result + 16) &= (unint64_t)a2[2];
  }
  return result;
}

uint64_t llvm::KnownBits::operator|=(uint64_t result, uint64_t **a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t *v5;
  unint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t *v9;
  unint64_t v10;
  uint64_t v11;

  v2 = *(unsigned int *)(result + 8);
  if (v2 > 0x40)
  {
    v4 = *(_QWORD **)result;
    v5 = *a2;
    v6 = (unint64_t)(v2 + 63) >> 6;
    do
    {
      v7 = *v5++;
      *v4++ &= v7;
      --v6;
    }
    while (v6);
  }
  else
  {
    *(_QWORD *)result &= (unint64_t)*a2;
  }
  v3 = *(unsigned int *)(result + 24);
  if (v3 > 0x40)
  {
    v8 = *(_QWORD **)(result + 16);
    v9 = a2[2];
    v10 = (unint64_t)(v3 + 63) >> 6;
    do
    {
      v11 = *v9++;
      *v8++ |= v11;
      --v10;
    }
    while (v10);
  }
  else
  {
    *(_QWORD *)(result + 16) |= (unint64_t)a2[2];
  }
  return result;
}

const void **llvm::KnownBits::operator^=(const void **result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  const void **v11;
  _QWORD **v12;
  _QWORD *v13;
  uint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  unint64_t v18;
  size_t v19;
  const void **v20;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t *v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  _QWORD *v28;
  uint64_t v29;
  const void **v30;
  _QWORD *v31;
  _QWORD *v32;
  _QWORD *v33;
  int v34;
  unint64_t v35;
  uint64_t **v36;
  size_t v37;
  const void **v38;
  _QWORD *v39;
  uint64_t *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t *v43;
  unint64_t v44;
  size_t v45;
  const void **v46;
  uint64_t **v47;
  _QWORD *v48;
  const void *v49;
  uint64_t *v50;
  unint64_t v51;
  _QWORD *v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t *v55;
  _QWORD *v56;
  uint64_t v57;
  const void **v58;
  _QWORD *v59;
  const void **v60;
  _QWORD *v61;
  const void **v62;
  _QWORD *v63;
  int v64;
  _QWORD *v65;
  int v66;
  int v67;
  int v68;
  int v69;

  v2 = *((unsigned int *)result + 2);
  if (v2 > 0x40)
  {
    v11 = result;
    v12 = (_QWORD **)a2;
    v13 = (_QWORD *)operator new[]();
    memcpy(v13, *v11, ((unint64_t)(v2 + 63) >> 3) & 0x3FFFFFF8);
    a2 = v12;
    v14 = *v12;
    v15 = (unint64_t)(v2 + 63) >> 6;
    v3 = (unint64_t)v13;
    do
    {
      v16 = *v14++;
      *v13++ &= v16;
      --v15;
    }
    while (v15);
    result = v11;
  }
  else
  {
    v3 = *a2 & (unint64_t)*result;
  }
  v4 = *((unsigned int *)result + 6);
  if (v4 >= 0x41)
  {
    v17 = (uint64_t *)v3;
    v67 = *((_DWORD *)result + 6);
    v18 = v4 + 63;
    v19 = ((unint64_t)(v4 + 63) >> 3) & 0x3FFFFFF8;
    v20 = result;
    v21 = a2;
    v22 = (_QWORD *)operator new[]();
    memcpy(v22, v20[2], v19);
    a2 = v21;
    v23 = (uint64_t *)v21[2];
    v5 = v21 + 2;
    v24 = v18 >> 6;
    v6 = v22;
    v25 = v18 >> 6;
    do
    {
      v26 = *v23++;
      *v22++ &= v26;
      --v25;
    }
    while (v25);
    v27 = v17;
    v28 = v6;
    do
    {
      v29 = *v27++;
      *v28++ |= v29;
      --v24;
    }
    while (v24);
    result = v20;
    v3 = (unint64_t)v17;
    LODWORD(v4) = v67;
  }
  else
  {
    v5 = a2 + 2;
    v6 = (_QWORD *)(a2[2] & (unint64_t)result[2] | v3);
  }
  if (v2 >= 0x41 && v3)
  {
    v30 = result;
    v31 = v6;
    v32 = a2;
    MEMORY[0x1CAA32F9C](v3, 0x1000C8000313F17);
    a2 = v32;
    v6 = v31;
    result = v30;
  }
  v7 = *((unsigned int *)result + 2);
  if (v7 > 0x40)
  {
    v65 = a2;
    v68 = v4;
    v33 = v6;
    v34 = *((_DWORD *)result + 2);
    v35 = v7 + 63;
    v36 = (uint64_t **)v5;
    v37 = ((unint64_t)(v7 + 63) >> 3) & 0x3FFFFFF8;
    v38 = result;
    v39 = (_QWORD *)operator new[]();
    memcpy(v39, *v38, v37);
    v40 = *v36;
    v41 = v35 >> 6;
    v8 = (unint64_t)v39;
    do
    {
      v42 = *v40++;
      *v39++ &= v42;
      --v41;
    }
    while (v41);
    result = v38;
    v6 = v33;
    a2 = v65;
    LODWORD(v4) = v68;
    LODWORD(v7) = v34;
  }
  else
  {
    v8 = *v5 & (unint64_t)*result;
  }
  v9 = *((unsigned int *)result + 6);
  if (v9 >= 0x41)
  {
    v66 = v7;
    v69 = v4;
    v43 = (uint64_t *)v8;
    v63 = v6;
    v64 = *((_DWORD *)result + 6);
    v44 = v9 + 63;
    v45 = ((unint64_t)(v9 + 63) >> 3) & 0x3FFFFFF8;
    v46 = result;
    v47 = (uint64_t **)a2;
    v48 = (_QWORD *)operator new[]();
    v62 = v46;
    v49 = v46[2];
    memcpy(v48, v49, v45);
    v50 = *v47;
    v51 = v44 >> 6;
    v52 = v48;
    v53 = v51;
    do
    {
      v54 = *v50++;
      *v48++ &= v54;
      --v53;
    }
    while (v53);
    v55 = v43;
    v56 = v52;
    do
    {
      v57 = *v55++;
      *v56++ |= v57;
      --v51;
    }
    while (v51);
    result = v62;
    v6 = v63;
    v8 = (unint64_t)v43;
    v10 = v52;
    LODWORD(v7) = v66;
    LODWORD(v4) = v69;
    LODWORD(v9) = v64;
    if (*((_DWORD *)v62 + 6) >= 0x41u)
    {
      if (v49)
        MEMORY[0x1CAA32F9C](v49, 0x1000C8000313F17);
      result = v62;
      v6 = v63;
      v8 = (unint64_t)v43;
      v10 = v52;
      LODWORD(v7) = v66;
      LODWORD(v4) = v69;
      LODWORD(v9) = v64;
    }
  }
  else
  {
    v10 = (_QWORD *)(*a2 & (unint64_t)result[2] | v8);
  }
  result[2] = v10;
  *((_DWORD *)result + 6) = v9;
  if (v7 >= 0x41 && v8)
  {
    v58 = result;
    v59 = v6;
    MEMORY[0x1CAA32F9C](v8, 0x1000C8000313F17);
    v6 = v59;
    result = v58;
  }
  if (*((_DWORD *)result + 2) >= 0x41u && *result)
  {
    v60 = result;
    v61 = v6;
    MEMORY[0x1CAA32F9C](*result, 0x1000C8000313F17);
    v6 = v61;
    result = v60;
  }
  *result = v6;
  *((_DWORD *)result + 2) = v4;
  return result;
}

void llvm::KnownBits::print(llvm::KnownBits *this, llvm::raw_ostream *a2)
{
  uint64_t v4;
  uint64_t v5;
  _BYTE *v6;
  void *v7;
  __int128 v8;
  _QWORD v9[6];

  v9[5] = *MEMORY[0x1E0C80C00];
  v4 = *((_QWORD *)a2 + 4);
  if ((unint64_t)(*((_QWORD *)a2 + 3) - v4) > 5)
  {
    *(_WORD *)(v4 + 4) = 15727;
    *(_DWORD *)v4 = 1919244923;
    *((_QWORD *)a2 + 4) += 6;
  }
  else
  {
    llvm::raw_ostream::write(a2, "{Zero=", 6uLL);
  }
  v7 = v9;
  v8 = xmmword_1C64638D0;
  llvm::APInt::toString((uint64_t)this, &v7, 0xAu, 1, 0);
  llvm::raw_ostream::write(a2, (const char *)v7, v8);
  if (v7 != v9)
    free(v7);
  v5 = *((_QWORD *)a2 + 4);
  if ((unint64_t)(*((_QWORD *)a2 + 3) - v5) > 5)
  {
    *(_WORD *)(v5 + 4) = 15717;
    *(_DWORD *)v5 = 1850679340;
    *((_QWORD *)a2 + 4) += 6;
  }
  else
  {
    llvm::raw_ostream::write(a2, ", One=", 6uLL);
  }
  v7 = v9;
  v8 = xmmword_1C64638D0;
  llvm::APInt::toString((uint64_t)this + 16, &v7, 0xAu, 1, 0);
  llvm::raw_ostream::write(a2, (const char *)v7, v8);
  if (v7 != v9)
    free(v7);
  v6 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v6)
  {
    llvm::raw_ostream::write(a2, "}", 1uLL);
  }
  else
  {
    *v6 = 125;
    ++*((_QWORD *)a2 + 4);
  }
}

llvm *llvm::KnownBits::dump(llvm::KnownBits *this)
{
  llvm *v2;
  llvm *v3;
  llvm *result;
  _BYTE *v5;

  v2 = llvm::dbgs(this);
  llvm::KnownBits::print(this, v2);
  result = llvm::dbgs(v3);
  v5 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v5)
    return llvm::raw_ostream::write(result, "\n", 1uLL);
  *v5 = 10;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t llvm::getULEB128Size(unint64_t this)
{
  uint64_t v1;
  BOOL v2;

  LODWORD(v1) = 0;
  do
  {
    v1 = (v1 + 1);
    v2 = this > 0x7F;
    this >>= 7;
  }
  while (v2);
  return v1;
}

uint64_t llvm::getSLEB128Size(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  int v3;

  v1 = this;
  LODWORD(this) = 0;
  v2 = v1 >> 63;
  do
  {
    do
    {
      v3 = v1;
      v1 >>= 7;
      this = (this + 1);
    }
    while (v1 != v2);
  }
  while (((v3 ^ v2) & 0x40) != 0);
  return this;
}

llvm::line_iterator *llvm::line_iterator::line_iterator(llvm::line_iterator *this, const llvm::MemoryBuffer *a2, char a3, char a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v12[4];

  v7 = *((_QWORD *)a2 + 1);
  v8 = *((_QWORD *)a2 + 2) - v7;
  v9 = (*(uint64_t (**)(const llvm::MemoryBuffer *))(*(_QWORD *)a2 + 16))(a2);
  v12[0] = v7;
  v12[1] = v8;
  v12[2] = v9;
  v12[3] = v10;
  return llvm::line_iterator::line_iterator(this, (const llvm::MemoryBufferRef *)v12, a3, a4);
}

{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v12[4];

  v7 = *((_QWORD *)a2 + 1);
  v8 = *((_QWORD *)a2 + 2) - v7;
  v9 = (*(uint64_t (**)(const llvm::MemoryBuffer *))(*(_QWORD *)a2 + 16))(a2);
  v12[0] = v7;
  v12[1] = v8;
  v12[2] = v9;
  v12[3] = v10;
  return llvm::line_iterator::line_iterator(this, (const llvm::MemoryBufferRef *)v12, a3, a4);
}

BOOL llvm::sys::locale::isPrint(llvm::sys::locale *this)
{
  char *v1;
  unint64_t v2;
  unint64_t v3;
  char *v4;
  unsigned int v5;
  char *v6;

  if (this >> 16 > 0x10)
    return 0;
  v1 = (char *)&unk_1C8670D0C;
  v2 = 548;
  do
  {
    v3 = v2 >> 1;
    v4 = &v1[8 * (v2 >> 1)];
    v5 = *((_DWORD *)v4 + 1);
    v6 = v4 + 8;
    v2 += ~(v2 >> 1);
    if (v5 < this)
      v1 = v6;
    else
      v2 = v3;
  }
  while (v2);
  return v1 == (char *)&unk_1C8671E2C || *(_DWORD *)v1 > this;
}

uint64_t llvm::LockFileManager::readLockFile@<X0>(void *a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  size_t v6;
  const void *v7;
  unint64_t first_not_of;
  uint64_t *v9;
  unint64_t v10;
  char v11;
  pid_t v12;
  uint64_t result;
  __int128 *p_dst;
  uint64_t v15;
  uint64_t v16;
  void **v17;
  uint64_t v18;
  __int128 __dst;
  int64_t v20;
  __int128 v21;
  void *__p[2];
  __int128 v23;
  __int16 v24;
  uint64_t *v25;
  char v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v24 = 261;
  __p[0] = a1;
  __p[1] = a2;
  sub_1C5E1F6CC((unsigned __int8 *)__p, 0xFFFFFFFFFFFFFFFFLL, 0, 0, 1, 0, (uint64_t)&v25);
  if ((v26 & 1) != 0)
  {
    v24 = 261;
    __p[0] = a1;
    __p[1] = a2;
    result = llvm::sys::fs::remove((llvm::sys::fs *)__p, (const llvm::Twine *)1);
    *(_BYTE *)a3 = 0;
    *(_BYTE *)(a3 + 32) = 0;
    return result;
  }
  llvm::getToken(v25[1], v25[2] - v25[1], " ", 1, __p);
  v7 = __p[0];
  v6 = (size_t)__p[1];
  v21 = v23;
  first_not_of = llvm::StringRef::find_first_not_of(&v21, " ", 1, 0);
  if (*((_QWORD *)&v21 + 1) >= first_not_of)
    v10 = first_not_of;
  else
    v10 = *((_QWORD *)&v21 + 1);
  *(_QWORD *)&__dst = 0;
  __p[0] = (void *)(v21 + v10);
  __p[1] = (void *)(*((_QWORD *)&v21 + 1) - v10);
  llvm::consumeSignedInteger((llvm *)__p, (llvm::StringRef *)0xA, (unint64_t *)&__dst, v9);
  if ((v11 & 1) != 0)
    goto LABEL_8;
  if (__p[1])
    goto LABEL_8;
  v12 = __dst;
  if ((_QWORD)__dst != (int)__dst)
    goto LABEL_8;
  if (v6 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  if (v6 >= 0x17)
  {
    v15 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17)
      v15 = v6 | 7;
    v16 = v15 + 1;
    p_dst = (__int128 *)operator new(v15 + 1);
    *((_QWORD *)&__dst + 1) = v6;
    v20 = v16 | 0x8000000000000000;
    *(_QWORD *)&__dst = p_dst;
    goto LABEL_22;
  }
  HIBYTE(v20) = v6;
  p_dst = &__dst;
  if (v6)
LABEL_22:
    memmove(p_dst, v7, v6);
  *((_BYTE *)p_dst + v6) = 0;
  *(_QWORD *)&v23 = v20;
  *(_OWORD *)__p = __dst;
  if (v20 >= 0)
    v17 = __p;
  else
    v17 = (void **)__dst;
  DWORD2(v23) = v12;
  if (v20 >= 0)
    v18 = HIBYTE(v20) & 0x7F;
  else
    v18 = *((_QWORD *)&__dst + 1);
  result = llvm::LockFileManager::processStillExecuting(v17, v18, v12);
  if (!(_DWORD)result)
  {
    if (SBYTE7(v23) < 0)
      operator delete(__p[0]);
LABEL_8:
    v24 = 261;
    __p[0] = a1;
    __p[1] = a2;
    result = llvm::sys::fs::remove((llvm::sys::fs *)__p, (const llvm::Twine *)1);
    *(_BYTE *)a3 = 0;
    *(_BYTE *)(a3 + 32) = 0;
    goto LABEL_9;
  }
  *(_OWORD *)a3 = *(_OWORD *)__p;
  *(_QWORD *)(a3 + 16) = v23;
  *(_DWORD *)(a3 + 24) = DWORD2(v23);
  *(_BYTE *)(a3 + 32) = 1;
LABEL_9:
  if ((v26 & 1) == 0)
  {
    result = (uint64_t)v25;
    if (v25)
      return (*(uint64_t (**)(uint64_t *))(*v25 + 8))(v25);
  }
  return result;
}

uint64_t sub_1C5E1D8E4(_QWORD *a1)
{
  size_t v2;
  size_t v3;
  uint64_t v4;
  char __s[256];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  a1[1] = 0;
  __s[255] = 0;
  __s[0] = 0;
  gethostname(__s, 0xFFuLL);
  v2 = strlen(__s);
  v3 = v2;
  v4 = a1[1];
  if (a1[2] < v4 + v2)
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a1, a1 + 3, v4 + v2, 1);
    v4 = a1[1];
    if (!v3)
      goto LABEL_4;
    goto LABEL_3;
  }
  if (v2)
  {
LABEL_3:
    memcpy((void *)(*a1 + v4), __s, v3);
    v4 = a1[1];
  }
LABEL_4:
  a1[1] = v4 + v3;
  std::system_category();
  return 0;
}

uint64_t llvm::LockFileManager::LockFileManager(uint64_t a1, const void *a2, unint64_t a3)
{
  void *v6;
  void *v7;
  const char **v8;
  std::string::size_type *v9;
  void *v10;
  size_t *v11;
  const std::error_category *v12;
  uint64_t v13;
  void *v14;
  size_t v15;
  const void *v16;
  _BYTE *v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  void *v21;
  int v22;
  size_t v23;
  size_t v24;
  std::string::size_type v25;
  void *v26;
  size_t v27;
  const void *v28;
  _BYTE *v29;
  uint64_t v30;
  uint64_t v31;
  const std::string::value_type *v32;
  std::string::size_type v33;
  std::string *p_p;
  size_t size;
  uint64_t v37;
  uint64_t v38;
  int v39;
  std::string::size_type v40;
  const llvm::Twine *v41;
  std::string::size_type v42;
  uint64_t v43;
  const std::error_category *v44;
  uint64_t v45;
  int v46;
  std::string::size_type v47;
  std::string::size_type v48;
  void *v49;
  size_t v50;
  const void *v51;
  _BYTE *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  const void *v57;
  const std::string::value_type *v58;
  std::string::size_type v59;
  std::string *v60;
  size_t v61;
  void *v62;
  llvm::raw_ostream *v63;
  llvm::raw_ostream *v64;
  _BYTE *v65;
  size_t v66;
  llvm::raw_ostream *v67;
  _DWORD *v68;
  uint64_t *v69;
  uint64_t v70;
  pid_t v71;
  unint64_t v72;
  llvm::raw_ostream *v73;
  int v74;
  size_t v75;
  const void *v76;
  void **v77;
  std::string::size_type v78;
  uint64_t v79;
  uint64_t v80;
  const void *v81;
  void **v82;
  void **v83;
  std::string::size_type v84;
  std::string *v85;
  size_t v86;
  void *v87;
  const void *v88;
  size_t v89;
  void *v90;
  char v91;
  void *v92;
  size_t v93;
  double v94;
  const void *v95;
  void *v96[2];
  int64_t v97;
  __int16 v98;
  std::string v99;
  _BYTE __dst[24];
  __int16 v101;
  __int128 v102;
  int v103;
  std::string __p;
  uint64_t v105;
  uint64_t v106;
  char v107;
  uint64_t v108;
  int v109;
  size_t *v110;
  uint64_t v111;

  v111 = *MEMORY[0x1E0C80C00];
  v6 = (void *)(a1 + 24);
  *(_QWORD *)a1 = a1 + 24;
  *(_OWORD *)(a1 + 8) = xmmword_1C85F20B0;
  v7 = (void *)(a1 + 176);
  *(_QWORD *)(a1 + 152) = a1 + 176;
  v8 = (const char **)(a1 + 152);
  *(_OWORD *)(a1 + 160) = xmmword_1C85F20B0;
  v9 = (std::string::size_type *)(a1 + 304);
  v10 = (void *)(a1 + 328);
  *(_QWORD *)(a1 + 304) = a1 + 328;
  *(_OWORD *)(a1 + 312) = xmmword_1C85F20B0;
  v11 = (size_t *)(a1 + 312);
  *(_BYTE *)(a1 + 456) = 0;
  *(_BYTE *)(a1 + 488) = 0;
  *(_DWORD *)(a1 + 496) = 0;
  v12 = std::system_category();
  v13 = 0;
  *(_QWORD *)(a1 + 504) = v12;
  *(_QWORD *)(a1 + 512) = 0;
  *(_QWORD *)(a1 + 528) = 0;
  *(_QWORD *)(a1 + 520) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  if (*(_QWORD *)(a1 + 16) >= a3)
  {
    if (!a3)
      goto LABEL_4;
    goto LABEL_3;
  }
  llvm::SmallVectorBase<unsigned long long>::grow_pod(a1, v6, a3, 1);
  v13 = *(_QWORD *)(a1 + 8);
  if (a3)
  {
LABEL_3:
    memcpy((void *)(*(_QWORD *)a1 + v13), a2, a3);
    v13 = *(_QWORD *)(a1 + 8);
  }
LABEL_4:
  *(_QWORD *)(a1 + 8) = v13 + a3;
  v96[0] = (void *)llvm::sys::fs::make_absolute(a1);
  v96[1] = v14;
  if (LODWORD(v96[0]))
  {
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x28uLL);
    *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = xmmword_1C85FC090;
    strcpy(__p.__r_.__value_.__l.__data_, "failed to obtain absolute path for ");
    v15 = *(_QWORD *)(a1 + 8);
    if (v15 > 0x7FFFFFFFFFFFFFF7)
      goto LABEL_147;
    v16 = *(const void **)a1;
    if (v15 >= 0x17)
    {
      v30 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v15 | 7) != 0x17)
        v30 = v15 | 7;
      v31 = v30 + 1;
      v17 = operator new(v30 + 1);
      *(_QWORD *)&__dst[8] = v15;
      *(_QWORD *)&__dst[16] = v31 | 0x8000000000000000;
      *(_QWORD *)__dst = v17;
    }
    else
    {
      __dst[23] = *(_QWORD *)(a1 + 8);
      v17 = __dst;
      if (!v15)
        goto LABEL_26;
    }
    memmove(v17, v16, v15);
LABEL_26:
    v17[v15] = 0;
LABEL_27:
    if (__dst[23] >= 0)
      v32 = __dst;
    else
      v32 = *(const std::string::value_type **)__dst;
    if (__dst[23] >= 0)
      v33 = __dst[23] & 0x7F;
    else
      v33 = *(_QWORD *)&__dst[8];
    std::string::append(&__p, v32, v33);
    if ((__dst[23] & 0x80000000) != 0)
      operator delete(*(void **)__dst);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_p = &__p;
    else
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = *((_BYTE *)&__p.__r_.__value_.__s + 23) & 0x7F;
    else
      size = __p.__r_.__value_.__l.__size_;
    sub_1C5E1E430(a1, v96, p_p, size);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    return a1;
  }
  sub_1C50502AC((uint64_t)v8, a1);
  v18 = *(_QWORD *)(a1 + 160);
  if (*(_QWORD *)(a1 + 168) < (unint64_t)(v18 + 5))
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)v8, v7, v18 + 5, 1);
    v18 = *(_QWORD *)(a1 + 160);
  }
  v19 = *(_QWORD *)(a1 + 152) + v18;
  *(_BYTE *)(v19 + 4) = 107;
  *(_DWORD *)v19 = 1668246574;
  v20 = *(void **)(a1 + 152);
  v21 = (void *)(*(_QWORD *)(a1 + 160) + 5);
  *(_QWORD *)(a1 + 160) = v21;
  llvm::LockFileManager::readLockFile(v20, v21, (uint64_t)&__p);
  sub_1C5E1E9EC(a1 + 456, (__int128 *)&__p);
  v22 = *(unsigned __int8 *)(a1 + 488);
  if ((_BYTE)v106 && SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (!v22)
  {
    sub_1C50502AC((uint64_t)v9, (uint64_t)v8);
    v23 = *(_QWORD *)(a1 + 312);
    if (*(_QWORD *)(a1 + 320) < v23 + 9)
    {
      llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)v9, v10, v23 + 9, 1);
      v23 = *v11;
    }
    v24 = *v9 + v23;
    *(_QWORD *)v24 = *(_QWORD *)"-%%%%%%%%";
    *(_BYTE *)(v24 + 8) = 37;
    v25 = *v11 + 9;
    *v11 = v25;
    v103 = 0;
    LOWORD(v106) = 261;
    __p.__r_.__value_.__r.__words[0] = *v9;
    __p.__r_.__value_.__l.__size_ = v25;
    v96[0] = (void *)sub_1C5E7D894((uint64_t)&__p, &v103, v9, 0, 1, 0, 438);
    v96[1] = v26;
    if (LODWORD(v96[0]))
    {
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x20uLL);
      *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = xmmword_1C640C6B0;
      strcpy(__p.__r_.__value_.__l.__data_, "failed to create unique file ");
      v27 = *v11;
      if (*v11 > 0x7FFFFFFFFFFFFFF7)
        goto LABEL_147;
      v28 = (const void *)*v9;
      if (v27 >= 0x17)
      {
        v53 = (v27 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v27 | 7) != 0x17)
          v53 = v27 | 7;
        v54 = v53 + 1;
        v29 = operator new(v53 + 1);
        *(_QWORD *)&__dst[8] = v27;
        *(_QWORD *)&__dst[16] = v54 | 0x8000000000000000;
        *(_QWORD *)__dst = v29;
      }
      else
      {
        __dst[23] = *v11;
        v29 = __dst;
        if (!v27)
          goto LABEL_69;
      }
      memmove(v29, v28, v27);
LABEL_69:
      v29[v27] = 0;
      goto LABEL_27;
    }
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v105;
    *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = xmmword_1C64638F0;
    v37 = sub_1C5E1D8E4(&__p);
    if ((_DWORD)v37)
    {
      *(_QWORD *)(a1 + 496) = v37;
      *(_QWORD *)(a1 + 504) = v38;
      if (*(char *)(a1 + 535) < 0)
        operator delete(*(void **)(a1 + 512));
      strcpy((char *)(a1 + 512), "failed to get host id");
      *(_BYTE *)(a1 + 535) = 21;
      v39 = 1;
LABEL_48:
      if ((uint64_t *)__p.__r_.__value_.__l.__data_ != &v105)
        free(__p.__r_.__value_.__l.__data_);
      if (!v39)
      {
        v40 = *v11;
        v95 = (const void *)*v9;
        llvm::sys::RemoveFileOnSignal((void *)*v9, *v11);
        while (1)
        {
          LOWORD(v106) = 261;
          v42 = *(_QWORD *)(a1 + 312);
          __p.__r_.__value_.__r.__words[0] = *(_QWORD *)(a1 + 304);
          __p.__r_.__value_.__l.__size_ = v42;
          v101 = 261;
          v43 = *(_QWORD *)(a1 + 160);
          *(_QWORD *)__dst = *(_QWORD *)(a1 + 152);
          *(_QWORD *)&__dst[8] = v43;
          v96[0] = (void *)llvm::sys::fs::create_link((llvm::sys::fs *)&__p, (const llvm::Twine *)__dst, v41);
          v96[1] = (void *)v44;
          v45 = LODWORD(v96[0]);
          if (!LODWORD(v96[0]))
            return a1;
          if (std::generic_category() != v44 || v45 != 17)
            break;
          llvm::LockFileManager::readLockFile(*(void **)(a1 + 152), *(void **)(a1 + 160), (uint64_t)&__p);
          sub_1C5E1E9EC(a1 + 456, (__int128 *)&__p);
          v46 = *(unsigned __int8 *)(a1 + 488);
          if ((_BYTE)v106 && SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
            operator delete(__p.__r_.__value_.__l.__data_);
          if (v46)
          {
            LOWORD(v106) = 261;
            v78 = *v11;
            __p.__r_.__value_.__r.__words[0] = *v9;
            __p.__r_.__value_.__l.__size_ = v78;
            llvm::sys::fs::remove((llvm::sys::fs *)&__p, (const llvm::Twine *)1);
            v57 = v95;
            goto LABEL_91;
          }
          LOWORD(v106) = 261;
          v47 = *(_QWORD *)(a1 + 160);
          __p.__r_.__value_.__r.__words[0] = *(_QWORD *)(a1 + 152);
          __p.__r_.__value_.__l.__size_ = v47;
          if (!llvm::sys::fs::access((unsigned __int8 *)&__p, 0))
          {
            LOWORD(v106) = 261;
            v48 = *(_QWORD *)(a1 + 160);
            __p.__r_.__value_.__r.__words[0] = *(_QWORD *)(a1 + 152);
            __p.__r_.__value_.__l.__size_ = v48;
            v96[0] = (void *)llvm::sys::fs::remove((llvm::sys::fs *)&__p, (const llvm::Twine *)1);
            v96[1] = v49;
            if (LODWORD(v96[0]))
            {
              __p.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x20uLL);
              *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = xmmword_1C64638E0;
              strcpy(__p.__r_.__value_.__l.__data_, "failed to remove lockfile ");
              v50 = *v11;
              if (*v11 <= 0x7FFFFFFFFFFFFFF7)
              {
                v51 = (const void *)*v9;
                if (v50 >= 0x17)
                {
                  v55 = (v50 & 0xFFFFFFFFFFFFFFF8) + 8;
                  if ((v50 | 7) != 0x17)
                    v55 = v50 | 7;
                  v56 = v55 + 1;
                  v52 = operator new(v55 + 1);
                  *(_QWORD *)&__dst[8] = v50;
                  *(_QWORD *)&__dst[16] = v56 | 0x8000000000000000;
                  *(_QWORD *)__dst = v52;
                }
                else
                {
                  __dst[23] = *v11;
                  v52 = __dst;
                  if (!v50)
                  {
LABEL_74:
                    v57 = v95;
                    v52[v50] = 0;
                    if (__dst[23] >= 0)
                      v58 = __dst;
                    else
                      v58 = *(const std::string::value_type **)__dst;
                    if (__dst[23] >= 0)
                      v59 = __dst[23] & 0x7F;
                    else
                      v59 = *(_QWORD *)&__dst[8];
                    std::string::append(&__p, v58, v59);
                    if ((__dst[23] & 0x80000000) != 0)
                      operator delete(*(void **)__dst);
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v60 = &__p;
                    else
                      v60 = (std::string *)__p.__r_.__value_.__r.__words[0];
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v61 = *((_BYTE *)&__p.__r_.__value_.__s + 23) & 0x7F;
                    else
                      v61 = __p.__r_.__value_.__l.__size_;
                    sub_1C5E1E430(a1, v96, v60, v61);
                    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                    {
                      v62 = (void *)__p.__r_.__value_.__r.__words[0];
LABEL_90:
                      operator delete(v62);
                      goto LABEL_91;
                    }
                    goto LABEL_91;
                  }
                }
                memmove(v52, v51, v50);
                goto LABEL_74;
              }
LABEL_147:
              abort();
            }
          }
        }
        strcpy(__dst, "failed to create link ");
        __dst[23] = 22;
        LODWORD(__p.__r_.__value_.__r.__words[1]) = 0;
        v107 = 0;
        v108 = 0;
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1E81A7208;
        v110 = (size_t *)__dst;
        v109 = 0;
        v105 = 0;
        v106 = 0;
        __p.__r_.__value_.__r.__words[2] = 0;
        v66 = *(_QWORD *)(a1 + 160);
        if (v66)
        {
          v67 = llvm::raw_ostream::write((llvm::raw_ostream *)&__p, *v8, v66);
          v69 = (uint64_t *)((char *)v67 + 32);
          v68 = (_DWORD *)*((_QWORD *)v67 + 4);
          v70 = *((_QWORD *)v67 + 3);
        }
        else
        {
          v70 = 0;
          v68 = 0;
          v67 = (llvm::raw_ostream *)&__p;
          v69 = &v106;
        }
        v57 = v95;
        if ((unint64_t)(v70 - (_QWORD)v68) > 3)
        {
          *v68 = 544175136;
          *v69 += 4;
        }
        else
        {
          v67 = llvm::raw_ostream::write(v67, " to ", 4uLL);
        }
        v88 = (const void *)*v9;
        v89 = *v11;
        v90 = (void *)*((_QWORD *)v67 + 4);
        if (*v11 <= *((_QWORD *)v67 + 3) - (_QWORD)v90)
        {
          if (v89)
          {
            memcpy(v90, v88, *v11);
            *((_QWORD *)v67 + 4) += v89;
          }
        }
        else
        {
          llvm::raw_ostream::write(v67, (const char *)v88, *v11);
        }
        v91 = *((_BYTE *)v110 + 23);
        if (v91 >= 0)
          v92 = v110;
        else
          v92 = (void *)*v110;
        if (v91 >= 0)
          v93 = v91 & 0x7F;
        else
          v93 = v110[1];
        v94 = sub_1C5E1E430(a1, v96, v92, v93);
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)off_1E81A6E70;
        if (v109 == 1 && __p.__r_.__value_.__r.__words[2])
          MEMORY[0x1CAA32F9C](__p.__r_.__value_.__r.__words[2], 0x1000C8077774924, v94);
        if ((__dst[23] & 0x80000000) != 0)
        {
          v62 = *(void **)__dst;
          goto LABEL_90;
        }
LABEL_91:
        LOWORD(v106) = 261;
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v57;
        __p.__r_.__value_.__l.__size_ = v40;
        llvm::sys::fs::remove((llvm::sys::fs *)&__p, (const llvm::Twine *)1);
        llvm::sys::DontRemoveFileOnSignal(v57, v40);
      }
      return a1;
    }
    llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)__dst, v103, 1, 0, 0);
    v63 = llvm::raw_ostream::write((llvm::raw_ostream *)__dst, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    v64 = v63;
    v65 = (_BYTE *)*((_QWORD *)v63 + 4);
    if ((unint64_t)v65 >= *((_QWORD *)v63 + 3))
    {
      llvm::raw_ostream::write(v63, 32);
    }
    else
    {
      *((_QWORD *)v63 + 4) = v65 + 1;
      *v65 = 32;
    }
    v71 = getpid();
    v72 = v71;
    if (v71 < 0)
    {
      v72 = -(uint64_t)v71;
      v73 = v64;
      v74 = 1;
    }
    else
    {
      v73 = v64;
      v74 = 0;
    }
    sub_1C5E21910(v73, v72, 0, 0, v74);
    llvm::raw_fd_ostream::close((llvm::raw_fd_ostream *)__dst);
    if (!(_DWORD)v102)
    {
      v39 = 0;
LABEL_129:
      llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)__dst);
      goto LABEL_48;
    }
    *((_BYTE *)&v99.__r_.__value_.__s + 23) = 19;
    strcpy((char *)&v99, "failed to write to ");
    v75 = *v11;
    if (*v11 > 0x7FFFFFFFFFFFFFF7)
      goto LABEL_147;
    v76 = (const void *)*v9;
    if (v75 >= 0x17)
    {
      v79 = (v75 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v75 | 7) != 0x17)
        v79 = v75 | 7;
      v80 = v79 + 1;
      v81 = (const void *)*v9;
      v82 = (void **)operator new(v79 + 1);
      v76 = v81;
      v77 = v82;
      v96[1] = (void *)v75;
      v97 = v80 | 0x8000000000000000;
      v96[0] = v82;
    }
    else
    {
      HIBYTE(v97) = *v11;
      v77 = v96;
      if (!v75)
        goto LABEL_112;
    }
    memmove(v77, v76, v75);
LABEL_112:
    *((_BYTE *)v77 + v75) = 0;
    if (v97 >= 0)
      v83 = v96;
    else
      v83 = (void **)v96[0];
    if (v97 >= 0)
      v84 = HIBYTE(v97) & 0x7F;
    else
      v84 = (std::string::size_type)v96[1];
    std::string::append(&v99, (const std::string::value_type *)v83, v84);
    if (SHIBYTE(v97) < 0)
      operator delete(v96[0]);
    *(_OWORD *)v96 = v102;
    if ((v99.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v85 = &v99;
    else
      v85 = (std::string *)v99.__r_.__value_.__r.__words[0];
    if ((v99.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v86 = *((_BYTE *)&v99.__r_.__value_.__s + 23) & 0x7F;
    else
      v86 = v99.__r_.__value_.__l.__size_;
    sub_1C5E1E430(a1, v96, v85, v86);
    v98 = 261;
    v87 = *(void **)(a1 + 312);
    v96[0] = *(void **)(a1 + 304);
    v96[1] = v87;
    llvm::sys::fs::remove((llvm::sys::fs *)v96, (const llvm::Twine *)1);
    if (SHIBYTE(v99.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v99.__r_.__value_.__l.__data_);
    v39 = 1;
    goto LABEL_129;
  }
  return a1;
}

double sub_1C5E1E430(uint64_t a1, _OWORD *a2, void *__src, size_t __len)
{
  __int128 *p_dst;
  size_t v8;
  size_t v9;
  void **v10;
  double result;
  __int128 __dst;
  unint64_t v13;

  *(_OWORD *)(a1 + 496) = *a2;
  if (!__src)
  {
    __dst = 0uLL;
    v13 = 0;
    goto LABEL_12;
  }
  if (__len >= 0x7FFFFFFFFFFFFFF8)
    abort();
  if (__len >= 0x17)
  {
    v8 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v8 = __len | 7;
    v9 = v8 + 1;
    p_dst = (__int128 *)operator new(v8 + 1);
    *((_QWORD *)&__dst + 1) = __len;
    v13 = v9 | 0x8000000000000000;
    *(_QWORD *)&__dst = p_dst;
  }
  else
  {
    HIBYTE(v13) = __len;
    p_dst = &__dst;
    if (!__len)
      goto LABEL_11;
  }
  memmove(p_dst, __src, __len);
LABEL_11:
  *((_BYTE *)p_dst + __len) = 0;
LABEL_12:
  v10 = (void **)(a1 + 512);
  if (*(char *)(a1 + 535) < 0)
    operator delete(*v10);
  result = *(double *)&__dst;
  *(_OWORD *)v10 = __dst;
  *(_QWORD *)(a1 + 528) = v13;
  return result;
}

void llvm::LockFileManager::getErrorMessage(llvm::LockFileManager *this@<X0>, uint64_t a2@<X8>)
{
  const std::error_code *v3;
  __int128 *p_dst;
  std::string::size_type size;
  llvm::raw_ostream *v6;
  std::string *v7;
  size_t v8;
  __int128 v9;
  void (**v10)(llvm::raw_ostream *__hidden);
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char v15;
  uint64_t v16;
  int v17;
  __int128 *v18;
  std::string v19;
  __int128 __dst;
  uint64_t v21;

  if (*((_DWORD *)this + 124))
  {
    v3 = (const std::error_code *)((char *)this + 496);
    if (*((char *)this + 535) < 0)
    {
      sub_1C47EBC30(&__dst, *((void **)this + 64), *((_QWORD *)this + 65));
    }
    else
    {
      __dst = *((_OWORD *)this + 32);
      v21 = *((_QWORD *)this + 66);
    }
    std::error_code::message(&v19, v3);
    v11 = 0;
    v15 = 0;
    v16 = 0;
    v10 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
    p_dst = &__dst;
    v18 = &__dst;
    v17 = 0;
    v13 = 0;
    v14 = 0;
    v12 = 0;
    size = *((_BYTE *)&v19.__r_.__value_.__s + 23) & 0x7F;
    if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      size = v19.__r_.__value_.__l.__size_;
    if (size)
    {
      v6 = llvm::raw_ostream::write((llvm::raw_ostream *)&v10, ": ", 2uLL);
      if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v7 = &v19;
      else
        v7 = (std::string *)v19.__r_.__value_.__r.__words[0];
      if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v8 = *((_BYTE *)&v19.__r_.__value_.__s + 23) & 0x7F;
      else
        v8 = v19.__r_.__value_.__l.__size_;
      llvm::raw_ostream::write(v6, (const char *)v7, v8);
      p_dst = v18;
    }
    if (*((char *)p_dst + 23) < 0)
    {
      sub_1C47EBC30((_BYTE *)a2, *(void **)p_dst, *((_QWORD *)p_dst + 1));
    }
    else
    {
      v9 = *p_dst;
      *(_QWORD *)(a2 + 16) = *((_QWORD *)p_dst + 2);
      *(_OWORD *)a2 = v9;
    }
    v10 = off_1E81A6E70;
    if (v17 == 1 && v12)
      MEMORY[0x1CAA32F9C](v12, 0x1000C8077774924);
    if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v19.__r_.__value_.__l.__data_);
    if (SHIBYTE(v21) < 0)
      operator delete((void *)__dst);
  }
  else
  {
    *(_BYTE *)(a2 + 23) = 0;
    *(_BYTE *)a2 = 0;
  }
}

void llvm::LockFileManager::~LockFileManager(llvm::LockFileManager *this)
{
  uint64_t v2;
  uint64_t v3;
  char *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  __int16 v8;

  if (!*((_BYTE *)this + 488) && !*((_DWORD *)this + 124))
  {
    v8 = 261;
    v2 = *((_QWORD *)this + 20);
    v6 = *((_QWORD *)this + 19);
    v7 = v2;
    llvm::sys::fs::remove((llvm::sys::fs *)&v6, (const llvm::Twine *)1);
    v8 = 261;
    v3 = *((_QWORD *)this + 39);
    v6 = *((_QWORD *)this + 38);
    v7 = v3;
    llvm::sys::fs::remove((llvm::sys::fs *)&v6, (const llvm::Twine *)1);
    llvm::sys::DontRemoveFileOnSignal(*((const void **)this + 38), *((_QWORD *)this + 39));
  }
  if (*((char *)this + 535) < 0)
    operator delete(*((void **)this + 64));
  if (*((_BYTE *)this + 488))
  {
    if (*((char *)this + 479) < 0)
      operator delete(*((void **)this + 57));
    *((_BYTE *)this + 488) = 0;
  }
  v4 = (char *)*((_QWORD *)this + 38);
  if (v4 != (char *)this + 328)
    free(v4);
  v5 = (char *)*((_QWORD *)this + 19);
  if (v5 != (char *)this + 176)
    free(v5);
  if (*(llvm::LockFileManager **)this != (llvm::LockFileManager *)((char *)this + 24))
    free(*(void **)this);
}

uint64_t llvm::LockFileManager::waitForUnlock(llvm::LockFileManager *this, unsigned int a2)
{
  uint32_t v4;
  unsigned int v5;
  std::chrono::steady_clock::time_point v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE *v13;
  char v14;
  int v15;
  const std::error_category *v16;
  char v17;
  BOOL v18;
  llvm::LockFileManager *v19;
  uint64_t v20;
  uint64_t v21;
  std::string::size_type v22;
  uint64_t v23;
  std::string __token;
  __int16 v26;
  _QWORD v27[2];
  unsigned int v28;
  std::random_device v29;

  if (!*((_BYTE *)this + 488))
    return 0;
  *((_BYTE *)&__token.__r_.__value_.__s + 23) = 12;
  strcpy((char *)&__token, "/dev/urandom");
  std::random_device::random_device(&v29, &__token);
  if (SHIBYTE(__token.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__token.__r_.__value_.__l.__data_);
  v4 = arc4random();
  v5 = v4 + ((v4 / 0x7FFFFFFF) | ((v4 / 0x7FFFFFFF) << 31));
  if (v5 <= 1)
    v5 = 1;
  v28 = v5;
  v6.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  v7 = (_QWORD *)((char *)this + 152);
  v8 = 1;
  v9 = a2;
  while (1)
  {
    v27[0] = 1;
    v27[1] = v8;
    v10 = sub_1C638CA90((uint64_t)&v28, v27);
    if (10 * v10 >= 1)
    {
      v11 = 0x7FFFFFFFFFFFFFFFLL;
      if ((unint64_t)(10 * v10) < 0x8637BD057A0)
        v11 = 10000000 * v10;
      __token.__r_.__value_.__r.__words[0] = v11;
      std::this_thread::sleep_for ((const std::chrono::nanoseconds *)&__token);
    }
    v12 = *((_QWORD *)this + 20);
    if ((unint64_t)(v12 + 1) > *((_QWORD *)this + 21))
    {
      llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)this + 152, (char *)this + 176, v12 + 1, 1);
      v12 = *((_QWORD *)this + 20);
    }
    *(_BYTE *)(*v7 + v12) = 0;
    v13 = (_BYTE *)*v7;
    v26 = 257;
    if (*v13)
    {
      __token.__r_.__value_.__r.__words[0] = (std::string::size_type)v13;
      v14 = 3;
    }
    else
    {
      v14 = 1;
    }
    LOBYTE(v26) = v14;
    v15 = llvm::sys::fs::access((unsigned __int8 *)&__token, 0);
    if (std::generic_category() == v16 && v15 == 2)
    {
      v26 = 261;
      v22 = *((_QWORD *)this + 1);
      __token.__r_.__value_.__r.__words[0] = *(_QWORD *)this;
      __token.__r_.__value_.__l.__size_ = v22;
      v23 = llvm::sys::fs::access((unsigned __int8 *)&__token, 0) != 0;
      goto LABEL_32;
    }
    v17 = *((_BYTE *)this + 479);
    v18 = v17 < 0;
    v19 = v17 >= 0 ? (llvm::LockFileManager *)((char *)this + 456) : (llvm::LockFileManager *)*((_QWORD *)this + 57);
    v20 = v17 & 0x7F;
    v21 = v18 ? *((_QWORD *)this + 58) : v20;
    if (!llvm::LockFileManager::processStillExecuting(v19, v21, *((_DWORD *)this + 120)))
      break;
    if ((unint64_t)(2 * v8) >= 0x32)
      v8 = 50;
    else
      v8 *= 2;
    if ((std::chrono::steady_clock::now().__d_.__rep_ - v6.__d_.__rep_) / 1000000000 >= v9)
    {
      v23 = 2;
      goto LABEL_32;
    }
  }
  v23 = 1;
LABEL_32:
  std::random_device::~random_device(&v29);
  return v23;
}

uint64_t sub_1C5E1E9EC(uint64_t a1, __int128 *a2)
{
  __int128 v4;
  __int128 v5;

  if (*((_BYTE *)a2 + 32))
  {
    if (*(_BYTE *)(a1 + 32))
    {
      if (*(char *)(a1 + 23) < 0)
        operator delete(*(void **)a1);
      v4 = *a2;
      *(_QWORD *)(a1 + 16) = *((_QWORD *)a2 + 2);
      *(_OWORD *)a1 = v4;
      *((_BYTE *)a2 + 23) = 0;
      *(_BYTE *)a2 = 0;
      *(_DWORD *)(a1 + 24) = *((_DWORD *)a2 + 6);
    }
    else
    {
      v5 = *a2;
      *(_QWORD *)(a1 + 16) = *((_QWORD *)a2 + 2);
      *(_OWORD *)a1 = v5;
      *((_QWORD *)a2 + 1) = 0;
      *((_QWORD *)a2 + 2) = 0;
      *(_QWORD *)a2 = 0;
      *(_DWORD *)(a1 + 24) = *((_DWORD *)a2 + 6);
      *(_BYTE *)(a1 + 32) = 1;
    }
  }
  else if (*(_BYTE *)(a1 + 32))
  {
    if (*(char *)(a1 + 23) < 0)
      operator delete(*(void **)a1);
    *(_BYTE *)(a1 + 32) = 0;
  }
  return a1;
}

uint64_t sub_1C5E1EA98(uint64_t result, uint64_t a2, unint64_t a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unsigned int v6;
  unsigned int v7;
  int v8;

  *(_QWORD *)result = a2;
  *(_QWORD *)(result + 8) = a3;
  if (a3 % 0x1E)
    v3 = a3 / 0x1E + 1;
  else
    v3 = a3 / 0x1E;
  v4 = a3 / v3;
  *(_QWORD *)(result + 16) = a3 / v3;
  *(_QWORD *)(result + 24) = v3;
  v5 = (-1 << (a3 / v3)) & 0x7FFFFFFE;
  if (a3 / v3 >= 0x40)
    v5 = 0;
  *(_QWORD *)(result + 40) = v5;
  if ((v5 ^ 0x7FFFFFFE) > v5 / v3)
  {
    ++v3;
    v4 = a3 / v3;
    *(_QWORD *)(result + 16) = a3 / v3;
    *(_QWORD *)(result + 24) = v3;
    if (a3 / v3 > 0x3F)
    {
      *(_QWORD *)(result + 32) = v3 + v4 * v3 - a3;
      *(_QWORD *)(result + 40) = 0;
      LODWORD(v4) = 64;
      goto LABEL_16;
    }
    *(_QWORD *)(result + 40) = (-1 << v4) & 0x7FFFFFFE;
  }
  *(_QWORD *)(result + 32) = v3 + a3 / v3 * v3 - a3;
  if (v4 >= 0x3F)
  {
LABEL_16:
    *(_QWORD *)(result + 48) = 0;
    v8 = -(int)v4;
    v7 = -1;
    *(_DWORD *)(result + 56) = 0xFFFFFFFF >> v8;
    goto LABEL_17;
  }
  *(_QWORD *)(result + 48) = 0x3FFFFFFFuLL >> v4 << (v4 + 1);
  v6 = 0xFFFFFFFF >> -(char)v4;
  if (!v4)
    v6 = 0;
  *(_DWORD *)(result + 56) = v6;
  if (v4 >= 0x1F)
    v7 = -1;
  else
    v7 = 0xFFFFFFFF >> ~(_BYTE)v4;
LABEL_17:
  *(_DWORD *)(result + 60) = v7;
  return result;
}

uint64_t sub_1C5E1EB9C(uint64_t a1)
{
  unint64_t v2;
  uint64_t result;
  uint64_t v4;
  unint64_t v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  BOOL v9;
  unsigned int v10;
  int v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unsigned int *v15;
  unint64_t v16;
  unint64_t v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  unint64_t v24;
  uint64_t v25;

  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
  {
    result = 0;
    v4 = 0;
    v5 = *(_QWORD *)(a1 + 16);
    v6 = **(_DWORD **)a1;
    do
    {
      do
      {
        v7 = v6 / 0xADC8;
        v8 = 48271 * (v6 % 0xADC8);
        v7 *= 3399;
        v9 = v8 >= v7;
        v10 = v8 - v7;
        if (v9)
          v11 = 0;
        else
          v11 = 0x7FFFFFFF;
        v6 = v11 + v10;
        v12 = v6 - 1;
      }
      while (*(_QWORD *)(a1 + 40) <= v12);
      v13 = result << v5;
      if (v5 >= 0x40)
        v13 = 0;
      result = v13 + (v12 & *(_DWORD *)(a1 + 56));
      ++v4;
    }
    while (v4 != v2);
    **(_DWORD **)a1 = v6;
  }
  else
  {
    result = 0;
  }
  v14 = *(_QWORD *)(a1 + 24);
  if (v2 < v14)
  {
    v15 = *(unsigned int **)a1;
    v16 = *(_QWORD *)(a1 + 48);
    v17 = *(_QWORD *)(a1 + 16);
    v18 = *(_DWORD *)(a1 + 60);
    v19 = *v15;
    while (1)
    {
      v20 = v19 / 0xADC8;
      v21 = 48271 * (v19 % 0xADC8);
      v20 *= 3399;
      v9 = v21 >= v20;
      v22 = v21 - v20;
      if (v9)
        v23 = 0;
      else
        v23 = 0x7FFFFFFF;
      v19 = v23 + v22;
      v24 = v19 - 1;
      if (v16 > v24)
      {
        v25 = result << (v17 + 1);
        if (v17 >= 0x3F)
          v25 = 0;
        result = v25 + (v24 & v18);
        if (++v2 == v14)
          break;
      }
    }
    *v15 = v19;
  }
  return result;
}

llvm::raw_ostream *llvm::LLT::print(llvm::raw_ostream *this, llvm::raw_ostream *a2)
{
  llvm::raw_ostream *v2;
  llvm::raw_ostream *v3;
  unint64_t v4;
  BOOL v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  _BYTE *v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char v20;
  unint64_t v21;
  char v22;
  char v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  _BYTE *v27;
  _BYTE *v28;
  char v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;

  v2 = a2;
  v3 = this;
  v4 = *(_QWORD *)this & 0xFFFFFFFFFFFFFFF9;
  if (v4)
    v5 = (*(_QWORD *)this & 4) == 0;
  else
    v5 = 1;
  if (!v5)
  {
    v13 = (_BYTE *)*((_QWORD *)a2 + 4);
    if (*((_BYTE **)a2 + 3) == v13)
    {
      llvm::raw_ostream::write(a2, "<", 1uLL);
    }
    else
    {
      *v13 = 60;
      ++*((_QWORD *)a2 + 4);
    }
    v14 = *(_QWORD *)v3;
    v15 = 0x800000000000000;
    if ((*(_QWORD *)v3 & 2) == 0)
      v15 = 0x8000000000000;
    v16 = (unsigned __int16)(v14 >> 3);
    if ((v15 & v14) != 0)
    {
      v17 = *((_QWORD *)v2 + 4);
      if ((unint64_t)(*((_QWORD *)v2 + 3) - v17) > 8)
      {
        *(_BYTE *)(v17 + 8) = 32;
        *(_QWORD *)v17 = *(_QWORD *)"vscale x ";
        *((_QWORD *)v2 + 4) += 9;
      }
      else
      {
        llvm::raw_ostream::write(v2, "vscale x ", 9uLL);
      }
    }
    sub_1C5E21910(v2, v16, 0, 0, 0);
    v18 = *((_QWORD *)v2 + 4);
    if ((unint64_t)(*((_QWORD *)v2 + 3) - v18) > 2)
    {
      *(_BYTE *)(v18 + 2) = 32;
      *(_WORD *)v18 = 30752;
      *((_QWORD *)v2 + 4) += 3;
    }
    else
    {
      v2 = llvm::raw_ostream::write(v2, " x ", 3uLL);
    }
    v19 = *(_QWORD *)v3;
    v20 = 3;
    if ((*(_QWORD *)v3 & 1) == 0)
      v20 = 19;
    v21 = v19 & 0x8000000000000000 | (8 * (v19 >> v20)) | 1;
    v22 = 35;
    v23 = 19;
    if ((v19 & 4) == 0)
      v22 = 19;
    v24 = v19 >> v22;
    if ((v19 & 4) == 0)
      v23 = 3;
    if ((v19 & 1) != 0)
      v23 = 3;
    v25 = (8 * (unsigned __int16)(v19 >> v23)) & 0xFFFFF8000007FFFFLL | ((v24 & 0xFFFFFF) << 19);
    if ((v19 & 2) != 0)
      v26 = v25 | 2;
    else
      v26 = v21;
    v32 = v26;
    this = (llvm::raw_ostream *)llvm::LLT::print((llvm::LLT *)&v32, v2);
    v27 = (_BYTE *)*((_QWORD *)v2 + 4);
    if (*((_BYTE **)v2 + 3) == v27)
      return llvm::raw_ostream::write(v2, ">", 1uLL);
    *v27 = 62;
    v31 = *((_QWORD *)v2 + 4) + 1;
LABEL_58:
    *((_QWORD *)v2 + 4) = v31;
    return this;
  }
  if (v4)
    v6 = (*(_QWORD *)this & 6) == 2;
  else
    v6 = 0;
  if (v6)
  {
    v28 = (_BYTE *)*((_QWORD *)a2 + 4);
    if (*((_BYTE **)a2 + 3) == v28)
    {
      v2 = llvm::raw_ostream::write(a2, "p", 1uLL);
    }
    else
    {
      *v28 = 112;
      ++*((_QWORD *)a2 + 4);
    }
    v29 = 35;
    if ((*(_QWORD *)v3 & 4) == 0)
      v29 = 19;
    v12 = (*(_QWORD *)v3 >> v29) & 0xFFFFFFLL;
    return sub_1C5E21910(v2, v12, 0, 0, 0);
  }
  if (!v4)
  {
    v30 = *((_QWORD *)a2 + 4);
    if ((unint64_t)(*((_QWORD *)a2 + 3) - v30) <= 0xA)
      return llvm::raw_ostream::write(a2, "LLT_invalid", 0xBuLL);
    *(_DWORD *)(v30 + 7) = 1684630625;
    *(_QWORD *)v30 = *(_QWORD *)"LLT_invalid";
    v31 = *((_QWORD *)a2 + 4) + 11;
    goto LABEL_58;
  }
  v8 = *((_QWORD *)a2 + 3);
  v7 = *((_QWORD *)a2 + 4);
  if ((*(_QWORD *)this & 0x8000000000000000) == 0)
  {
    if (v8 == v7)
    {
      v2 = llvm::raw_ostream::write(a2, "s", 1uLL);
    }
    else
    {
      *(_BYTE *)v7 = 115;
      ++*((_QWORD *)a2 + 4);
    }
    v9 = *(_QWORD *)v3;
    v10 = (unsigned __int16)(*(_QWORD *)v3 >> 3);
    v11 = (unsigned __int16)(*(_QWORD *)v3 >> 19);
    if ((*(_QWORD *)v3 & 2) == 0)
      v11 = (*(_QWORD *)v3 >> 19);
    if ((v9 & 4) != 0)
      v10 = v11;
    if ((v9 & 1) != 0)
      v12 = (v9 >> 3);
    else
      v12 = v10;
    return sub_1C5E21910(v2, v12, 0, 0, 0);
  }
  if ((unint64_t)(v8 - v7) > 5)
  {
    *(_WORD *)(v7 + 4) = 29793;
    *(_DWORD *)v7 = 1869375074;
    v31 = *((_QWORD *)a2 + 4) + 6;
    goto LABEL_58;
  }
  return llvm::raw_ostream::write(a2, "bfloat", 6uLL);
}

unint64_t *llvm::LLT::LLT(unint64_t *a1, unsigned __int8 a2)
{
  const char *v3;
  unsigned int v4;
  unint64_t v5;
  unsigned int v7;
  unsigned __int16 v8;
  int v9;
  const char *v10;
  unsigned int v11;
  unsigned int v12;
  unsigned __int8 v13;
  uint64_t v14;
  uint64_t v15;
  unsigned __int8 v16;
  unsigned __int8 v17;

  v17 = a2;
  if (a2 - 15 <= 0x9B)
  {
    v7 = sub_1C47F381C(&v17);
    v8 = sub_1C47F381C(&v17);
    v9 = v17;
    v16 = sub_1C47F37A0(&v17);
    v11 = sub_1C47A8C74(&v16);
    if ((_DWORD)v10 == 1)
    v12 = v9 - 120;
    v13 = v17;
    if ((v17 - 15) <= 0x9Bu)
      v13 = sub_1C47F37A0(&v17);
    v14 = 8 * (((unint64_t)v11 << 16) | ((unint64_t)(v12 < 0x33) << 48) | v8);
    v15 = 4;
    if (v7 <= 1)
    {
      v15 = 0;
      v14 = 8 * v11;
    }
    v5 = (v7 < 2) | ((unint64_t)(v13 == 8) << 63) | v15 | v14;
  }
  else
  {
    if (a2 - 1 > 0xB1)
    {
      *a1 = 0;
      return a1;
    }
    v4 = sub_1C47A8C74(&v17);
    if ((_DWORD)v3 == 1)
    v5 = ((unint64_t)(v17 == 8) << 63) | (8 * v4) | 1;
  }
  *a1 = v5;
  return a1;
}

{
  return llvm::LLT::LLT(a1, a2);
}

void llvm::ManagedStaticBase::RegisterManagedStatic(llvm::ManagedStaticBase *this, void *(*a2)(void), void (*a3)(void *))
{
  unsigned __int8 v6;
  uint64_t v7;

  v6 = atomic_load((unsigned __int8 *)&qword_1ED836BC8);
  if ((v6 & 1) == 0 && __cxa_guard_acquire(&qword_1ED836BC8))
  {
    MEMORY[0x1CAA32CE4](&stru_1ED836B88);
    __cxa_atexit((void (*)(void *))MEMORY[0x1E0DE4840], &stru_1ED836B88, &dword_1C475E000);
    __cxa_guard_release(&qword_1ED836BC8);
  }
  std::recursive_mutex::lock(&stru_1ED836B88);
  if (!*(_QWORD *)this)
  {
    atomic_store((uint64_t)a2(), (unint64_t *)this);
    v7 = qword_1ED836B80;
    *((_QWORD *)this + 1) = a3;
    *((_QWORD *)this + 2) = v7;
    qword_1ED836B80 = (uint64_t)this;
  }
  std::recursive_mutex::unlock(&stru_1ED836B88);
}

uint64_t llvm::ManagedStaticBase::destroy(llvm::ManagedStaticBase *this)
{
  uint64_t (*v2)(unint64_t);
  unint64_t v3;
  uint64_t result;

  v2 = (uint64_t (*)(unint64_t))*((_QWORD *)this + 1);
  qword_1ED836B80 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  v3 = atomic_load((unint64_t *)this);
  result = v2(v3);
  atomic_store(0, (unint64_t *)this);
  *((_QWORD *)this + 1) = 0;
  return result;
}

uint64_t llvm::llvm_shutdown(llvm *this)
{
  unint64_t *v1;
  uint64_t (*v2)(unint64_t);
  unint64_t v3;
  uint64_t result;

  while (1)
  {
    v1 = (unint64_t *)qword_1ED836B80;
    if (!qword_1ED836B80)
      break;
    v2 = *(uint64_t (**)(unint64_t))(qword_1ED836B80 + 8);
    qword_1ED836B80 = *(_QWORD *)(qword_1ED836B80 + 16);
    v1[2] = 0;
    v3 = atomic_load(v1);
    result = v2(v3);
    atomic_store(0, v1);
    v1[1] = 0;
  }
  return result;
}

void llvm::deallocate_buffer(llvm *this, void *a2)
{
  JUMPOUT(0x1CAA32FB4);
}

uint64_t llvm::MemoryBuffer::init(uint64_t this, const char *a2, const char *a3)
{
  *(_QWORD *)(this + 8) = a2;
  *(_QWORD *)(this + 16) = a3;
  return this;
}

char *llvm::MemoryBuffer::getMemBuffer@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, char **a5@<X8>)
{
  char *result;
  _QWORD v9[4];
  __int16 v10;
  const void ***v11;

  v10 = 261;
  v9[0] = a3;
  v9[1] = a4;
  v11 = (const void ***)v9;
  result = sub_1C5E1F380(24, &v11);
  *(_QWORD *)result = &off_1E81A17B0;
  *((_QWORD *)result + 1) = a1;
  *((_QWORD *)result + 2) = a1 + a2;
  *a5 = result;
  return result;
}

char *sub_1C5E1F380(uint64_t a1, const void ****a2)
{
  const void ***v3;
  size_t v4;
  const void **v5;
  char *v6;
  char *v7;
  char v9;
  void *v10;
  __int128 v11;
  _QWORD v12[33];

  v12[32] = *MEMORY[0x1E0C80C00];
  v10 = v12;
  v11 = xmmword_1C64638F0;
  v3 = *a2;
  if (*((_BYTE *)*a2 + 33) == 1)
  {
    v4 = 0;
    v5 = 0;
    switch(*((_BYTE *)v3 + 32))
    {
      case 1:
        break;
      case 3:
        v5 = *v3;
        if (*v3)
          v4 = strlen((const char *)*v3);
        else
          v4 = 0;
        break;
      case 4:
        v9 = *((_BYTE *)*v3 + 23);
        if (v9 >= 0)
          v5 = *v3;
        else
          v5 = (const void **)**v3;
        if (v9 >= 0)
          v4 = v9 & 0x7F;
        else
          v4 = (size_t)(*v3)[1];
        break;
      case 5:
        v5 = *v3;
        v4 = (size_t)v3[1];
        break;
      default:
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    llvm::Twine::toVector((uint64_t)v3, (uint64_t)&v10);
    v5 = (const void **)v10;
    v4 = v11;
  }
  v6 = (char *)operator new(a1 + v4 + 1);
  v7 = &v6[a1];
  if (v4)
    memcpy(v7, v5, v4);
  v7[v4] = 0;
  if (v10 != v12)
    free(v10);
  return v6;
}

void *sub_1C5E1F4D0@<X0>(const void *a1@<X0>, size_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  void *result;
  uint64_t v9;

  llvm::WritableMemoryBuffer::getNewUninitMemBuffer(a2, a3, &v9);
  v7 = v9;
  if (v9)
  {
    result = memcpy(*(void **)(v9 + 8), a1, a2);
    *(_BYTE *)(a4 + 16) &= ~1u;
  }
  else
  {
    result = (void *)std::generic_category();
    *(_BYTE *)(a4 + 16) |= 1u;
    *(_QWORD *)(a4 + 8) = result;
    v7 = 12;
  }
  *(_QWORD *)a4 = v7;
  return result;
}

void llvm::MemoryBuffer::getFileOrSTDIN(const char ***a1@<X0>, int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  const char *v8;
  size_t v9;
  char v10;
  void *v11;
  __int128 v12;
  _QWORD v13[33];

  v13[32] = *MEMORY[0x1E0C80C00];
  v11 = v13;
  v12 = xmmword_1C64638F0;
  if (*((_BYTE *)a1 + 33) == 1)
  {
    switch(*((_BYTE *)a1 + 32))
    {
      case 1:
        goto LABEL_7;
      case 3:
        v8 = (const char *)*a1;
        if (!*a1)
          goto LABEL_7;
        v9 = strlen((const char *)*a1);
        break;
      case 4:
        v10 = *((_BYTE *)*a1 + 23);
        if (v10 >= 0)
          v8 = (const char *)*a1;
        else
          v8 = **a1;
        if (v10 >= 0)
          v9 = v10 & 0x7F;
        else
          v9 = (size_t)(*a1)[1];
        break;
      case 5:
        v8 = (const char *)*a1;
        v9 = (size_t)a1[1];
        break;
      default:
        goto LABEL_11;
    }
  }
  else
  {
LABEL_11:
    llvm::Twine::toVector((uint64_t)a1, (uint64_t)&v11);
    v8 = (const char *)v11;
    v9 = v12;
  }
  if (v9 == 1 && *v8 == 45)
    llvm::MemoryBuffer::getSTDIN(a4);
  else
LABEL_7:
    sub_1C5E1F6CC((unsigned __int8 *)a1, 0xFFFFFFFFFFFFFFFFLL, 0, a2, a3, 0, a4);
  if (v11 != v13)
    free(v11);
}

_QWORD *llvm::MemoryBuffer::getFileSlice@<X0>(unsigned __int8 *a1@<X0>, size_t a2@<X1>, off_t a3@<X2>, char a4@<W3>, uint64_t a5@<X8>)
{
  return sub_1C5E1F6CC(a1, a2, a3, 0, 0, a4, a5);
}

_QWORD *sub_1C5E1F6CC@<X0>(unsigned __int8 *a1@<X0>, size_t a2@<X1>, off_t a3@<X2>, int a4@<W3>, int a5@<W4>, char a6@<W5>, uint64_t a7@<X8>)
{
  int v13;
  llvm::sys::Process *v14;
  _QWORD *result;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  int v19[2];
  char v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (a4)
    v13 = 3;
  else
    v13 = 0;
  llvm::sys::fs::openNativeFileForRead(a1, v13, 0, (uint64_t)v19);
  if ((v20 & 1) != 0)
  {
    v18 = *(_QWORD **)v19;
    v16 = llvm::errorToErrorCode(&v18);
    *(_BYTE *)(a7 + 16) |= 1u;
    *(_QWORD *)a7 = v16;
    *(_QWORD *)(a7 + 8) = v17;
    result = v18;
    if (v18)
      return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v18 + 8))(v18);
  }
  else
  {
    v14 = (llvm::sys::Process *)v19[0];
    sub_1C5E1FFD0(v19[0], (uint64_t)a1, 0xFFFFFFFFFFFFFFFFLL, a2, a3, a5, a6, a7);
    return (_QWORD *)llvm::sys::Process::SafelyCloseFileDescriptor(v14);
  }
  return result;
}

uint64_t llvm::WritableMemoryBuffer::getFile@<X0>(unsigned __int8 *a1@<X0>, uint64_t a2@<X8>)
{
  return sub_1C5E1F810(a2, a1, 0xFFFFFFFFFFFFFFFFLL, 0);
}

uint64_t sub_1C5E1F810(uint64_t a1, unsigned __int8 *a2, size_t a3, off_t a4)
{
  llvm::sys::Process *v8;
  unsigned __int8 v9;
  char *v10;
  llvm::sys::fs::mapped_file_region *v11;
  unint64_t v12;
  int v13;
  llvm::sys::fs::mapped_file_region *v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  llvm::sys::fs::mapped_file_region *v23;
  char *v24;
  unint64_t v25;
  int v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  const std::error_category *v30;
  uint64_t result;
  _QWORD *v32;
  _QWORD *v33;
  _OWORD v34[4];
  int v35[2];
  char v36;
  stat v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  llvm::sys::fs::openNativeFileForRead(a2, 0, 0, (uint64_t)v35);
  if ((v36 & 1) != 0)
  {
    v17 = *(_QWORD **)v35;
    *(_QWORD *)v35 = 0;
    v32 = v17;
    v18 = llvm::errorToErrorCode(&v32);
    *(_BYTE *)(a1 + 16) |= 1u;
    *(_QWORD *)a1 = v18;
    *(_QWORD *)(a1 + 8) = v19;
    if (v32)
      (*(void (**)(_QWORD *))(*v32 + 8))(v32);
    goto LABEL_39;
  }
  v8 = (llvm::sys::Process *)v35[0];
  v9 = atomic_load((unsigned __int8 *)&qword_1ED825C88);
  if ((v9 & 1) == 0)
  {
    v23 = (llvm::sys::fs::mapped_file_region *)__cxa_guard_acquire(&qword_1ED825C88);
    if ((_DWORD)v23)
    {
      dword_1ED825C80 = llvm::sys::fs::mapped_file_region::alignment(v23);
      __cxa_guard_release(&qword_1ED825C88);
    }
  }
  if (a3 == -1)
  {
    memset(v34, 0, 44);
    v20 = fstat((int)v8, &v37);
    v21 = sub_1C5E7F828(v20, &v37.st_dev, (uint64_t)v34);
    if ((_DWORD)v21)
    {
      *(_BYTE *)(a1 + 16) |= 1u;
      *(_QWORD *)a1 = v21;
      *(_QWORD *)(a1 + 8) = v22;
      goto LABEL_38;
    }
    if (DWORD2(v34[2]) != 2 && DWORD2(v34[2]) != 5)
    {
      sub_1C5E203C4();
      goto LABEL_38;
    }
    a3 = *(_QWORD *)&v34[2];
  }
  if (a3 >= 0x4000 && a3 >= dword_1ED825C80)
  {
    std::system_category();
    *(_QWORD *)&v37.st_dev = a2;
    v10 = sub_1C5E1F380(48, (const void ****)&v37);
    *(_QWORD *)v10 = &off_1E81A17E8;
    v11 = (llvm::sys::fs::mapped_file_region *)llvm::sys::fs::mapped_file_region::alignment((llvm::sys::fs::mapped_file_region *)v10);
    v12 = (((int)v11 - 1) & (unint64_t)a4) + a3;
    v13 = llvm::sys::fs::mapped_file_region::alignment(v11);
    *((_QWORD *)v10 + 3) = v12;
    *((_QWORD *)v10 + 4) = 0;
    *((_DWORD *)v10 + 10) = 2;
    v14 = (llvm::sys::fs::mapped_file_region *)llvm::sys::fs::mapped_file_region::init((size_t *)v10 + 3, (int)v8, -v13 & (unint64_t)a4, 2);
    if (!(_DWORD)v14)
    {
      v15 = *((_QWORD *)v10 + 4);
      v16 = v15 + ((int)(llvm::sys::fs::mapped_file_region::alignment(v14) - 1) & (unint64_t)a4);
      *((_QWORD *)v10 + 1) = v16;
      *((_QWORD *)v10 + 2) = v16 + a3;
      *(_BYTE *)(a1 + 16) &= ~1u;
      *(_QWORD *)a1 = v10;
      goto LABEL_38;
    }
    *((_QWORD *)v10 + 3) = 0;
    *((_QWORD *)v10 + 4) = 0;
    *((_DWORD *)v10 + 10) = 0;
    (*(void (**)(char *))(*(_QWORD *)v10 + 8))(v10);
  }
  llvm::WritableMemoryBuffer::getNewUninitMemBuffer(a3, (uint64_t)a2, v34);
  if (!*(_QWORD *)&v34[0])
  {
    v30 = std::generic_category();
    *(_BYTE *)(a1 + 16) |= 1u;
    *(_QWORD *)a1 = 12;
    *(_QWORD *)(a1 + 8) = v30;
    goto LABEL_38;
  }
  v24 = *(char **)(*(_QWORD *)&v34[0] + 8);
  v25 = *(_QWORD *)(*(_QWORD *)&v34[0] + 16) - (_QWORD)v24;
  do
  {
    if (!v25)
      goto LABEL_34;
    llvm::sys::fs::readNativeFileSlice((int)v8, v24, v25, a4, (uint64_t)&v37);
    if ((v37.st_ino & 1) != 0)
    {
      v27 = *(_QWORD **)&v37.st_dev;
      *(_QWORD *)&v37.st_dev = 0;
      v33 = v27;
      v28 = llvm::errorToErrorCode(&v33);
      *(_BYTE *)(a1 + 16) |= 1u;
      *(_QWORD *)a1 = v28;
      *(_QWORD *)(a1 + 8) = v29;
      if (v33)
        (*(void (**)(_QWORD *))(*v33 + 8))(v33);
      v26 = 1;
    }
    else
    {
      if (*(_QWORD *)&v37.st_dev)
      {
        v26 = 0;
        v25 -= *(_QWORD *)&v37.st_dev;
        v24 += *(_QWORD *)&v37.st_dev;
        a4 += *(_QWORD *)&v37.st_dev;
        continue;
      }
      bzero(v24, v25);
      if ((v37.st_ino & 1) == 0)
        goto LABEL_34;
      v26 = 3;
    }
    if (*(_QWORD *)&v37.st_dev)
      (*(void (**)(_QWORD))(**(_QWORD **)&v37.st_dev + 8))(*(_QWORD *)&v37.st_dev);
  }
  while (!v26);
  if (v26 == 3)
  {
LABEL_34:
    *(_BYTE *)(a1 + 16) &= ~1u;
    *(_QWORD *)a1 = *(_QWORD *)&v34[0];
    goto LABEL_38;
  }
  if (*(_QWORD *)&v34[0])
    (*(void (**)(_QWORD))(**(_QWORD **)&v34[0] + 8))(*(_QWORD *)&v34[0]);
LABEL_38:
  result = llvm::sys::Process::SafelyCloseFileDescriptor(v8);
  if ((v36 & 1) != 0)
  {
LABEL_39:
    result = *(_QWORD *)v35;
    if (*(_QWORD *)v35)
      return (*(uint64_t (**)(_QWORD))(**(_QWORD **)v35 + 8))(*(_QWORD *)v35);
  }
  return result;
}

uint64_t llvm::WritableMemoryBuffer::getFileSlice@<X0>(unsigned __int8 *a1@<X0>, size_t a2@<X1>, off_t a3@<X2>, uint64_t a4@<X8>)
{
  return sub_1C5E1F810(a4, a1, a2, a3);
}

void llvm::WritableMemoryBuffer::getNewUninitMemBuffer(size_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  size_t v5;
  const void *v6;
  unint64_t v7;
  size_t v8;
  _QWORD *v9;
  _QWORD *v10;
  char *v11;
  _BYTE *v12;
  const char *v13;
  char v14;
  void *v15;
  __int128 v16;
  _QWORD v17[33];

  v17[32] = *MEMORY[0x1E0C80C00];
  v15 = v17;
  v16 = xmmword_1C64638F0;
  if (*(_BYTE *)(a2 + 33) == 1)
  {
    v5 = 0;
    v6 = 0;
    switch(*(_BYTE *)(a2 + 32))
    {
      case 1:
        break;
      case 3:
        v6 = *(const void **)a2;
        if (*(_QWORD *)a2)
          v5 = strlen(*(const char **)a2);
        else
          v5 = 0;
        break;
      case 4:
        v13 = *(const char **)a2;
        v14 = *(_BYTE *)(*(_QWORD *)a2 + 23);
        if (v14 >= 0)
          v6 = *(const void **)a2;
        else
          v6 = *(const void **)v13;
        if (v14 >= 0)
          v5 = v14 & 0x7F;
        else
          v5 = *((_QWORD *)v13 + 1);
        break;
      case 5:
        v6 = *(const void **)a2;
        v5 = *(_QWORD *)(a2 + 8);
        break;
      default:
        goto LABEL_14;
    }
  }
  else
  {
LABEL_14:
    llvm::Twine::toVector(a2, (uint64_t)&v15);
    v6 = v15;
    v5 = v16;
  }
  v7 = (v5 + 40) & 0xFFFFFFFFFFFFFFF0;
  v8 = a1 + v7 + 1;
  if (v8 <= a1)
  {
    v10 = 0;
  }
  else
  {
    v9 = operator new(v8, MEMORY[0x1E0DE4E10]);
    v10 = v9;
    if (v9)
    {
      v11 = (char *)(v9 + 3);
      if (v5)
        memcpy(v9 + 3, v6, v5);
      v11[v5] = 0;
      v12 = (char *)v10 + v7 + a1;
      *v12 = 0;
      *v10 = &off_1E81A1820;
      v10[1] = (char *)v10 + v7;
      v10[2] = v12;
    }
  }
  *a3 = v10;
  if (v15 != v17)
    free(v15);
}

uint64_t llvm::WriteThroughMemoryBuffer::getFile@<X0>(unsigned __int8 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return sub_1C5E1FD88(a3, a1, a2, a2, 0);
}

uint64_t sub_1C5E1FD88(uint64_t a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  int v10;
  char *v11;
  llvm::sys::fs::mapped_file_region *v12;
  uint64_t v13;
  int v14;
  llvm::sys::fs::mapped_file_region *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t result;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  const std::error_category *v27;
  _OWORD v28[4];
  _QWORD *v29;
  stat v30;
  _QWORD *v31;
  char v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  llvm::sys::fs::openNativeFile(a2, 2, 3, 0, 438, (uint64_t)&v31);
  if ((v32 & 1) == 0)
  {
    v10 = (int)v31;
    if (a4 != -1)
      goto LABEL_4;
    a4 = a3;
    if (a3 != -1)
      goto LABEL_4;
    memset(v28, 0, 44);
    v26 = fstat((int)v31, &v30);
    result = sub_1C5E7F828(v26, &v30.st_dev, (uint64_t)v28);
    if (!(_DWORD)result)
    {
      if (DWORD2(v28[2]) == 2 || DWORD2(v28[2]) == 5)
      {
        a4 = *(_QWORD *)&v28[2];
LABEL_4:
        std::system_category();
        *(_QWORD *)&v30.st_dev = a2;
        v11 = sub_1C5E1F380(48, (const void ****)&v30);
        *(_QWORD *)v11 = &off_1E81A1778;
        v12 = (llvm::sys::fs::mapped_file_region *)llvm::sys::fs::mapped_file_region::alignment((llvm::sys::fs::mapped_file_region *)v11);
        v13 = (((int)v12 - 1) & a5) + a4;
        v14 = llvm::sys::fs::mapped_file_region::alignment(v12);
        *((_QWORD *)v11 + 3) = v13;
        *((_QWORD *)v11 + 4) = 0;
        *((_DWORD *)v11 + 10) = 1;
        v15 = (llvm::sys::fs::mapped_file_region *)llvm::sys::fs::mapped_file_region::init((size_t *)v11 + 3, v10, -v14 & a5, 1);
        if ((_DWORD)v15)
        {
          *((_QWORD *)v11 + 3) = 0;
          *((_QWORD *)v11 + 4) = 0;
          *((_DWORD *)v11 + 10) = 0;
          *(_BYTE *)(a1 + 16) |= 1u;
          *(_QWORD *)a1 = v15;
          *(_QWORD *)(a1 + 8) = v16;
          return (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v11 + 8))(v11, v16, v17, v18);
        }
        else
        {
          v19 = *((_QWORD *)v11 + 4);
          result = llvm::sys::fs::mapped_file_region::alignment(v15);
          v21 = v19 + (((int)result - 1) & a5);
          *((_QWORD *)v11 + 1) = v21;
          *((_QWORD *)v11 + 2) = v21 + a4;
          *(_BYTE *)(a1 + 16) &= ~1u;
          *(_QWORD *)a1 = v11;
        }
        return result;
      }
      v27 = std::generic_category();
      result = 22;
    }
    *(_BYTE *)(a1 + 16) |= 1u;
    *(_QWORD *)a1 = result;
    *(_QWORD *)(a1 + 8) = v27;
    return result;
  }
  v29 = v31;
  v22 = llvm::errorToErrorCode(&v29);
  *(_BYTE *)(a1 + 16) |= 1u;
  *(_QWORD *)a1 = v22;
  *(_QWORD *)(a1 + 8) = v23;
  result = (uint64_t)v29;
  if (v29)
    return (*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t))(*v29 + 8))(v29, v23, v24, v25);
  return result;
}

uint64_t llvm::WriteThroughMemoryBuffer::getFileSlice@<X0>(unsigned __int8 *a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return sub_1C5E1FD88(a4, a1, -1, a2, a3);
}

void llvm::MemoryBuffer::getOpenFile(int a1@<W0>, uint64_t a2@<X1>, size_t a3@<X2>, int a4@<W3>, char a5@<W4>, uint64_t a6@<X8>)
{
  sub_1C5E1FFD0(a1, a2, a3, a3, 0, a4, a5, a6);
}

void sub_1C5E1FFD0(int a1@<W0>, uint64_t a2@<X1>, size_t a3@<X2>, size_t a4@<X3>, off_t a5@<X4>, int a6@<W5>, char a7@<W6>, uint64_t a8@<X8>)
{
  unsigned __int8 v15;
  int v16;
  char *v17;
  unint64_t v18;
  int v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  BOOL v23;
  char v24;
  const std::error_category *v25;
  char *v26;
  llvm::sys::fs::mapped_file_region *v27;
  unint64_t v28;
  int v29;
  llvm::sys::fs::mapped_file_region *v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  char v37;
  char v38;
  uint64_t v39;
  size_t v40;
  llvm::sys::fs::mapped_file_region *v41;
  _QWORD *v42;
  __int128 v43;
  _QWORD v44[7];
  stat v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  v15 = atomic_load((unsigned __int8 *)&qword_1ED825C90);
  if ((v15 & 1) == 0)
  {
    v40 = a3;
    v41 = (llvm::sys::fs::mapped_file_region *)__cxa_guard_acquire(&qword_1ED825C90);
    a3 = v40;
    if ((_DWORD)v41)
    {
      dword_1ED825C84 = llvm::sys::fs::mapped_file_region::alignment(v41);
      __cxa_guard_release(&qword_1ED825C90);
      a3 = v40;
    }
  }
  if (a4 == -1)
  {
    a4 = a3;
    if (a3 == -1)
    {
      v43 = 0u;
      memset(v44, 0, 28);
      v33 = fstat(a1, &v45);
      v34 = sub_1C5E7F828(v33, &v45.st_dev, (uint64_t)&v43);
      if ((_DWORD)v34)
      {
        *(_BYTE *)(a8 + 16) |= 1u;
        *(_QWORD *)a8 = v34;
        *(_QWORD *)(a8 + 8) = v35;
        return;
      }
      if (LODWORD(v44[3]) != 2 && LODWORD(v44[3]) != 5)
      {
        sub_1C5E203C4();
        v37 = *(_BYTE *)(a8 + 16);
        if ((v45.st_uid & 1) != 0)
        {
          v38 = v37 | 1;
          v39 = *(_QWORD *)&v45.st_dev;
          *(_QWORD *)(a8 + 8) = v45.st_ino;
        }
        else
        {
          v38 = v37 & 0xFE;
          v39 = *(_QWORD *)&v45.st_dev;
        }
        *(_BYTE *)(a8 + 16) = v38;
        *(_QWORD *)a8 = v39;
        return;
      }
      a4 = v44[2];
      a3 = v44[2];
    }
  }
  v16 = dword_1ED825C84;
  if (a6 && (a7 & 1) != 0)
    goto LABEL_6;
  v23 = a4 >= 0x4000 && a4 >= dword_1ED825C84;
  v24 = !v23;
  if (v23 && a6)
  {
    if (a3 != -1)
    {
LABEL_32:
      if (a4 + a5 != a3 || (a3 & (v16 - 1)) == 0)
        goto LABEL_6;
LABEL_37:
      std::system_category();
      *(_QWORD *)&v45.st_dev = a2;
      v26 = sub_1C5E1F380(48, (const void ****)&v45);
      *(_QWORD *)v26 = &off_1E81A1858;
      v27 = (llvm::sys::fs::mapped_file_region *)llvm::sys::fs::mapped_file_region::alignment((llvm::sys::fs::mapped_file_region *)v26);
      v28 = (((int)v27 - 1) & (unint64_t)a5) + a4;
      v29 = llvm::sys::fs::mapped_file_region::alignment(v27);
      *((_QWORD *)v26 + 3) = v28;
      *((_QWORD *)v26 + 4) = 0;
      *((_DWORD *)v26 + 10) = 0;
      v30 = (llvm::sys::fs::mapped_file_region *)llvm::sys::fs::mapped_file_region::init((size_t *)v26 + 3, a1, -v29 & (unint64_t)a5, 0);
      if (!(_DWORD)v30)
      {
        v31 = *((_QWORD *)v26 + 4);
        v32 = v31 + ((int)(llvm::sys::fs::mapped_file_region::alignment(v30) - 1) & (unint64_t)a5);
        *((_QWORD *)v26 + 1) = v32;
        *((_QWORD *)v26 + 2) = v32 + a4;
        *(_BYTE *)(a8 + 16) &= ~1u;
        *(_QWORD *)a8 = v26;
        return;
      }
      *((_QWORD *)v26 + 3) = 0;
      *((_QWORD *)v26 + 4) = 0;
      *((_DWORD *)v26 + 10) = 0;
      (*(void (**)(char *))(*(_QWORD *)v26 + 8))(v26);
      goto LABEL_6;
    }
    v43 = 0u;
    memset(v44, 0, 28);
    v36 = fstat(a1, &v45);
    if (!sub_1C5E7F828(v36, &v45.st_dev, (uint64_t)&v43))
    {
      a3 = v44[2];
      goto LABEL_32;
    }
  }
  else if ((v24 & 1) == 0)
  {
    goto LABEL_37;
  }
LABEL_6:
  llvm::WritableMemoryBuffer::getNewUninitMemBuffer(a4, a2, &v43);
  if (!(_QWORD)v43)
  {
    v25 = std::generic_category();
    *(_BYTE *)(a8 + 16) |= 1u;
    *(_QWORD *)a8 = 12;
    *(_QWORD *)(a8 + 8) = v25;
    return;
  }
  v17 = *(char **)(v43 + 8);
  v18 = *(_QWORD *)(v43 + 16) - (_QWORD)v17;
  do
  {
    if (!v18)
      goto LABEL_21;
    llvm::sys::fs::readNativeFileSlice(a1, v17, v18, a5, (uint64_t)&v45);
    if ((v45.st_ino & 1) != 0)
    {
      v20 = *(_QWORD **)&v45.st_dev;
      *(_QWORD *)&v45.st_dev = 0;
      v42 = v20;
      v21 = llvm::errorToErrorCode(&v42);
      *(_BYTE *)(a8 + 16) |= 1u;
      *(_QWORD *)a8 = v21;
      *(_QWORD *)(a8 + 8) = v22;
      if (v42)
        (*(void (**)(_QWORD *))(*v42 + 8))(v42);
      v19 = 1;
    }
    else
    {
      if (*(_QWORD *)&v45.st_dev)
      {
        v19 = 0;
        v18 -= *(_QWORD *)&v45.st_dev;
        v17 += *(_QWORD *)&v45.st_dev;
        a5 += *(_QWORD *)&v45.st_dev;
        continue;
      }
      bzero(v17, v18);
      if ((v45.st_ino & 1) == 0)
        goto LABEL_21;
      v19 = 3;
    }
    if (*(_QWORD *)&v45.st_dev)
      (*(void (**)(_QWORD))(**(_QWORD **)&v45.st_dev + 8))(*(_QWORD *)&v45.st_dev);
  }
  while (!v19);
  if (v19 == 3)
  {
LABEL_21:
    *(_BYTE *)(a8 + 16) &= ~1u;
    *(_QWORD *)a8 = v43;
    return;
  }
  if ((_QWORD)v43)
    (*(void (**)(_QWORD))(*(_QWORD *)v43 + 8))(v43);
}

void llvm::MemoryBuffer::getOpenFileSlice(int a1@<W0>, uint64_t a2@<X1>, size_t a3@<X2>, off_t a4@<X3>, char a5@<W4>, uint64_t a6@<X8>)
{
  sub_1C5E1FFD0(a1, a2, 0xFFFFFFFFFFFFFFFFLL, a3, a4, 0, a5, a6);
}

void sub_1C5E203C4()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v9;
  __int128 v10;
  _QWORD v11[2049];

  v0 = MEMORY[0x1E0C80A78]();
  v2 = v1;
  v4 = v3;
  v11[2048] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = xmmword_1C8670030;
  llvm::sys::fs::readNativeFileToEOF(v0, &v9, 0x4000uLL, &v8);
  if (v8)
  {
    v7 = v8;
    v5 = llvm::errorToErrorCode(&v7);
    *(_BYTE *)(v4 + 16) |= 1u;
    *(_QWORD *)v4 = v5;
    *(_QWORD *)(v4 + 8) = v6;
    if (v7)
      (*(void (**)(_QWORD *))(*v7 + 8))(v7);
  }
  else
  {
    sub_1C5E1F4D0(v9, v10, v2, v4);
  }
  if (v9 != v11)
    free(v9);
}

_QWORD *llvm::MemoryBuffer::getFileAsStream@<X0>(unsigned __int8 *a1@<X0>, uint64_t a2@<X8>)
{
  llvm::sys::Process *v3;
  char v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *result;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  char v13;
  _QWORD *v14;
  char v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  llvm::sys::fs::openNativeFileForRead(a1, 0, 0, (uint64_t)&v14);
  if ((v15 & 1) != 0)
  {
    v10 = v14;
    v7 = llvm::errorToErrorCode(&v10);
    *(_BYTE *)(a2 + 16) |= 1u;
    *(_QWORD *)a2 = v7;
    *(_QWORD *)(a2 + 8) = v8;
    result = v10;
    if (v10)
      return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v10 + 8))(v10);
  }
  else
  {
    v3 = (llvm::sys::Process *)v14;
    sub_1C5E203C4();
    v4 = *(_BYTE *)(a2 + 16);
    if ((v13 & 1) != 0)
    {
      v5 = v4 | 1;
      v6 = v11;
      *(_QWORD *)(a2 + 8) = v12;
    }
    else
    {
      v5 = v4 & 0xFE;
      v6 = v11;
    }
    *(_BYTE *)(a2 + 16) = v5;
    *(_QWORD *)a2 = v6;
    return (_QWORD *)llvm::sys::Process::SafelyCloseFileDescriptor(v3);
  }
  return result;
}

uint64_t llvm::MemoryBuffer::getMemBufferRef@<X0>(llvm::MemoryBuffer *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  uint64_t v6;

  v3 = *((_QWORD *)this + 1);
  v4 = *((_QWORD *)this + 2) - v3;
  result = (*(uint64_t (**)(llvm::MemoryBuffer *))(*(_QWORD *)this + 16))(this);
  *a2 = v3;
  a2[1] = v4;
  a2[2] = result;
  a2[3] = v6;
  return result;
}

void llvm::SmallVectorMemoryBuffer::~SmallVectorMemoryBuffer(void **this)
{
  void **v2;

  *this = &off_1E81A1708;
  if (*((char *)this + 71) < 0)
    operator delete(this[6]);
  v2 = (void **)this[3];
  if (v2 != this + 6)
    free(v2);
}

{
  llvm::SmallVectorMemoryBuffer::~SmallVectorMemoryBuffer(this);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C5E2068C(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 48);
  v1 = a1 + 48;
  v2 = v3;
  if (*(char *)(v1 + 23) >= 0)
    return v1;
  return v2;
}

uint64_t sub_1C5E206B4()
{
  return 0;
}

const char *sub_1C5E206BC()
{
  return "Unknown buffer";
}

_QWORD *sub_1C5E206CC(_QWORD *a1)
{
  void *v2;

  *a1 = &off_1E81A1778;
  v2 = (void *)a1[4];
  if (v2)
    munmap(v2, a1[3]);
  return a1;
}

void sub_1C5E20708(_QWORD *__p)
{
  void *v2;

  *__p = &off_1E81A1778;
  v2 = (void *)__p[4];
  if (v2)
    munmap(v2, __p[3]);
  operator delete(__p);
}

uint64_t sub_1C5E20744(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 48;
  strlen((const char *)(a1 + 48));
  return v1;
}

void *sub_1C5E20770(uint64_t a1)
{
  void *result;

  result = *(void **)(a1 + 32);
  if (result)
    return (void *)posix_madvise(result, *(_QWORD *)(a1 + 24), 4);
  return result;
}

uint64_t sub_1C5E2078C()
{
  return 1;
}

uint64_t sub_1C5E2079C(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 24;
  strlen((const char *)(a1 + 24));
  return v1;
}

uint64_t sub_1C5E207C8()
{
  return 0;
}

_QWORD *sub_1C5E207D0(_QWORD *a1)
{
  void *v2;

  *a1 = &off_1E81A17E8;
  v2 = (void *)a1[4];
  if (v2)
    munmap(v2, a1[3]);
  return a1;
}

void sub_1C5E2080C(_QWORD *__p)
{
  void *v2;

  *__p = &off_1E81A17E8;
  v2 = (void *)__p[4];
  if (v2)
    munmap(v2, __p[3]);
  operator delete(__p);
}

uint64_t sub_1C5E20848(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 48;
  strlen((const char *)(a1 + 48));
  return v1;
}

void *sub_1C5E20874(uint64_t a1)
{
  void *result;

  result = *(void **)(a1 + 32);
  if (result)
    return (void *)posix_madvise(result, *(_QWORD *)(a1 + 24), 4);
  return result;
}

uint64_t sub_1C5E20890()
{
  return 1;
}

uint64_t sub_1C5E208A0(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 24;
  strlen((const char *)(a1 + 24));
  return v1;
}

uint64_t sub_1C5E208CC()
{
  return 0;
}

_QWORD *sub_1C5E208D4(_QWORD *a1)
{
  void *v2;

  *a1 = &off_1E81A1858;
  v2 = (void *)a1[4];
  if (v2)
    munmap(v2, a1[3]);
  return a1;
}

void sub_1C5E20910(_QWORD *__p)
{
  void *v2;

  *__p = &off_1E81A1858;
  v2 = (void *)__p[4];
  if (v2)
    munmap(v2, __p[3]);
  operator delete(__p);
}

uint64_t sub_1C5E2094C(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 48;
  strlen((const char *)(a1 + 48));
  return v1;
}

void *sub_1C5E20978(uint64_t a1)
{
  void *result;

  result = *(void **)(a1 + 32);
  if (result)
    return (void *)posix_madvise(result, *(_QWORD *)(a1 + 24), 4);
  return result;
}

uint64_t sub_1C5E20994()
{
  return 1;
}

llvm::MemoryBufferRef *llvm::MemoryBufferRef::MemoryBufferRef(llvm::MemoryBufferRef *this, const llvm::MemoryBuffer *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = *((_QWORD *)a2 + 1);
  v4 = *((_QWORD *)a2 + 2) - v3;
  *(_QWORD *)this = v3;
  *((_QWORD *)this + 1) = v4;
  *((_QWORD *)this + 2) = (*(uint64_t (**)(const llvm::MemoryBuffer *))(*(_QWORD *)a2 + 16))(a2);
  *((_QWORD *)this + 3) = v5;
  return this;
}

{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = *((_QWORD *)a2 + 1);
  v4 = *((_QWORD *)a2 + 2) - v3;
  *(_QWORD *)this = v3;
  *((_QWORD *)this + 1) = v4;
  *((_QWORD *)this + 2) = (*(uint64_t (**)(const llvm::MemoryBuffer *))(*(_QWORD *)a2 + 16))(a2);
  *((_QWORD *)this + 3) = v5;
  return this;
}

int *llvm::MD5::body(int *a1, int *a2, uint64_t a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  unint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  int v81;
  int v82;
  int v83;
  int v84;
  int v85;
  int v86;
  int v88;

  v3 = *a1;
  v4 = a1[1];
  v6 = a1[2];
  v5 = a1[3];
  do
  {
    v88 = v5;
    v7 = *a2;
    a1[22] = *a2;
    HIDWORD(v8) = v3 + (v6 & v4 | v5 & ~v4) - 680876936 + v7;
    LODWORD(v8) = HIDWORD(v8);
    v9 = (v8 >> 25) + v4;
    v10 = a2[1];
    a1[23] = v10;
    HIDWORD(v8) = v88 + v10 - 389564586 + (v4 & v9 | v6 & ~v9);
    LODWORD(v8) = HIDWORD(v8);
    v11 = (v8 >> 20) + v9;
    v12 = a2[2];
    a1[24] = v12;
    HIDWORD(v8) = v6 + v12 + 606105819 + (v9 & v11 | v4 & ~v11);
    LODWORD(v8) = HIDWORD(v8);
    v13 = (v8 >> 15) + v11;
    v14 = a2[3];
    a1[25] = v14;
    HIDWORD(v8) = v4 + v14 - 1044525330 + (v11 & v13 | v9 & ~v13);
    LODWORD(v8) = HIDWORD(v8);
    v15 = (v8 >> 10) + v13;
    v16 = a2[4];
    a1[26] = v16;
    HIDWORD(v8) = v9 + v16 - 176418897 + (v13 & v15 | v11 & ~v15);
    LODWORD(v8) = HIDWORD(v8);
    v17 = (v8 >> 25) + v15;
    v18 = a2[5];
    HIDWORD(v8) = v11 + v18 + 1200080426 + (v15 & v17 | v13 & ~v17);
    LODWORD(v8) = HIDWORD(v8);
    a1[27] = v18;
    v19 = (v8 >> 20) + v17;
    v20 = a2[6];
    a1[28] = v20;
    HIDWORD(v8) = v13 + v20 - 1473231341 + (v17 & v19 | v15 & ~v19);
    LODWORD(v8) = HIDWORD(v8);
    v21 = (v8 >> 15) + v19;
    v22 = a2[7];
    a1[29] = v22;
    HIDWORD(v8) = v15 + v22 - 45705983 + (v19 & v21 | v17 & ~v21);
    LODWORD(v8) = HIDWORD(v8);
    v23 = (v8 >> 10) + v21;
    v24 = a2[8];
    a1[30] = v24;
    HIDWORD(v8) = v17 + v24 + 1770035416 + (v21 & v23 | v19 & ~v23);
    LODWORD(v8) = HIDWORD(v8);
    v25 = (v8 >> 25) + v23;
    v26 = a2[9];
    a1[31] = v26;
    HIDWORD(v8) = v19 + v26 - 1958414417 + (v23 & v25 | v21 & ~v25);
    LODWORD(v8) = HIDWORD(v8);
    v27 = (v8 >> 20) + v25;
    v28 = a2[10];
    a1[32] = v28;
    HIDWORD(v8) = v21 + v28 - 42063 + (v25 & v27 | v23 & ~v27);
    LODWORD(v8) = HIDWORD(v8);
    v29 = (v8 >> 15) + v27;
    v30 = a2[11];
    HIDWORD(v8) = v23 + v30 - 1990404162 + (v27 & v29 | v25 & ~v29);
    LODWORD(v8) = HIDWORD(v8);
    a1[33] = v30;
    v31 = (v8 >> 10) + v29;
    v32 = a2[12];
    a1[34] = v32;
    HIDWORD(v8) = v25 + v32 + 1804603682 + (v29 & v31 | v27 & ~v31);
    LODWORD(v8) = HIDWORD(v8);
    v33 = (v8 >> 25) + v31;
    v34 = a2[13];
    a1[35] = v34;
    HIDWORD(v8) = v27 + v34 - 40341101 + (v31 & v33 | v29 & ~v33);
    LODWORD(v8) = HIDWORD(v8);
    v35 = (v8 >> 20) + v33;
    v36 = a2[14];
    a1[36] = v36;
    HIDWORD(v8) = v29 + v36 - 1502002290 + (v33 & v35 | v31 & ~v35);
    LODWORD(v8) = HIDWORD(v8);
    v37 = (v8 >> 15) + v35;
    v38 = a2[15];
    HIDWORD(v8) = v31 + v38 + 1236535329 + (v35 & v37 | v33 & ~v37);
    LODWORD(v8) = HIDWORD(v8);
    v39 = (v8 >> 10) + v37;
    HIDWORD(v8) = v10 + v33 - 165796510 + (v39 & v35 | v37 & ~v35);
    LODWORD(v8) = HIDWORD(v8);
    v40 = (v8 >> 27) + v39;
    HIDWORD(v8) = v20 + v35 - 1069501632 + (v40 & v37 | v39 & ~v37);
    LODWORD(v8) = HIDWORD(v8);
    v41 = (v8 >> 23) + v40;
    HIDWORD(v8) = v30 + v37 + 643717713 + (v41 & v39 | v40 & ~v39);
    LODWORD(v8) = HIDWORD(v8);
    v42 = (v8 >> 18) + v41;
    HIDWORD(v8) = v7 + v39 - 373897302 + (v42 & v40 | v41 & ~v40);
    LODWORD(v8) = HIDWORD(v8);
    v43 = (v8 >> 12) + v42;
    HIDWORD(v8) = v18 + v40 - 701558691 + (v43 & v41 | v42 & ~v41);
    LODWORD(v8) = HIDWORD(v8);
    v44 = (v8 >> 27) + v43;
    HIDWORD(v8) = v28 + v41 + 38016083 + (v44 & v42 | v43 & ~v42);
    LODWORD(v8) = HIDWORD(v8);
    v45 = (v8 >> 23) + v44;
    HIDWORD(v8) = v38 + v42 - 660478335 + (v45 & v43 | v44 & ~v43);
    LODWORD(v8) = HIDWORD(v8);
    v46 = (v8 >> 18) + v45;
    HIDWORD(v8) = v16 + v43 - 405537848 + (v46 & v44 | v45 & ~v44);
    LODWORD(v8) = HIDWORD(v8);
    v47 = (v8 >> 12) + v46;
    HIDWORD(v8) = v26 + v44 + 568446438 + (v47 & v45 | v46 & ~v45);
    LODWORD(v8) = HIDWORD(v8);
    v48 = (v8 >> 27) + v47;
    HIDWORD(v8) = v36 + v45 - 1019803690 + (v48 & v46 | v47 & ~v46);
    LODWORD(v8) = HIDWORD(v8);
    v49 = (v8 >> 23) + v48;
    HIDWORD(v8) = v14 + v46 - 187363961 + (v49 & v47 | v48 & ~v47);
    LODWORD(v8) = HIDWORD(v8);
    v50 = (v8 >> 18) + v49;
    HIDWORD(v8) = v24 + v47 + 1163531501 + (v50 & v48 | v49 & ~v48);
    LODWORD(v8) = HIDWORD(v8);
    v51 = (v8 >> 12) + v50;
    HIDWORD(v8) = v34 + v48 - 1444681467 + (v51 & v49 | v50 & ~v49);
    LODWORD(v8) = HIDWORD(v8);
    v52 = (v8 >> 27) + v51;
    HIDWORD(v8) = v12 + v49 - 51403784 + (v52 & v50 | v51 & ~v50);
    LODWORD(v8) = HIDWORD(v8);
    v53 = (v8 >> 23) + v52;
    HIDWORD(v8) = v22 + v50 + 1735328473 + (v53 & v51 | v52 & ~v51);
    LODWORD(v8) = HIDWORD(v8);
    v54 = (v8 >> 18) + v53;
    HIDWORD(v8) = v32 + v51 - 1926607734 + ((v54 ^ v53) & v52 ^ v53);
    LODWORD(v8) = HIDWORD(v8);
    v55 = (v8 >> 12) + v54;
    HIDWORD(v8) = v18 + v52 - 378558 + (v55 ^ v54 ^ v53);
    LODWORD(v8) = HIDWORD(v8);
    v56 = (v8 >> 28) + v55;
    HIDWORD(v8) = v24 + v53 - 2022574463 + (v56 ^ v55 ^ v54);
    LODWORD(v8) = HIDWORD(v8);
    v57 = (v8 >> 21) + v56;
    HIDWORD(v8) = v30 + v54 + 1839030562 + (v56 ^ v55 ^ v57);
    LODWORD(v8) = HIDWORD(v8);
    v58 = (v8 >> 16) + v57;
    HIDWORD(v8) = v36 + v55 - 35309556 + (v57 ^ v56 ^ v58);
    LODWORD(v8) = HIDWORD(v8);
    v59 = (v8 >> 9) + v58;
    HIDWORD(v8) = v10 + v56 - 1530992060 + (v58 ^ v57 ^ v59);
    LODWORD(v8) = HIDWORD(v8);
    v60 = (v8 >> 28) + v59;
    HIDWORD(v8) = v16 + v57 + 1272893353 + (v59 ^ v58 ^ v60);
    LODWORD(v8) = HIDWORD(v8);
    v61 = (v8 >> 21) + v60;
    HIDWORD(v8) = v22 + v58 - 155497632 + (v60 ^ v59 ^ v61);
    LODWORD(v8) = HIDWORD(v8);
    v62 = (v8 >> 16) + v61;
    HIDWORD(v8) = v28 + v59 - 1094730640 + (v61 ^ v60 ^ v62);
    LODWORD(v8) = HIDWORD(v8);
    v63 = (v8 >> 9) + v62;
    HIDWORD(v8) = v34 + v60 + 681279174 + (v62 ^ v61 ^ v63);
    LODWORD(v8) = HIDWORD(v8);
    v64 = (v8 >> 28) + v63;
    HIDWORD(v8) = v7 + v61 - 358537222 + (v63 ^ v62 ^ v64);
    LODWORD(v8) = HIDWORD(v8);
    v65 = (v8 >> 21) + v64;
    HIDWORD(v8) = v14 + v62 - 722521979 + (v64 ^ v63 ^ v65);
    LODWORD(v8) = HIDWORD(v8);
    v66 = (v8 >> 16) + v65;
    HIDWORD(v8) = v20 + v63 + 76029189 + (v65 ^ v64 ^ v66);
    LODWORD(v8) = HIDWORD(v8);
    v67 = (v8 >> 9) + v66;
    HIDWORD(v8) = v26 + v64 - 640364487 + (v66 ^ v65 ^ v67);
    LODWORD(v8) = HIDWORD(v8);
    v68 = (v8 >> 28) + v67;
    HIDWORD(v8) = v32 + v65 - 421815835 + (v67 ^ v66 ^ v68);
    LODWORD(v8) = HIDWORD(v8);
    v69 = (v8 >> 21) + v68;
    HIDWORD(v8) = v38 + v66 + 530742520 + (v68 ^ v67 ^ v69);
    LODWORD(v8) = HIDWORD(v8);
    v70 = (v8 >> 16) + v69;
    HIDWORD(v8) = v12 + v67 - 995338651 + (v69 ^ v68 ^ v70);
    LODWORD(v8) = HIDWORD(v8);
    v71 = (v8 >> 9) + v70;
    HIDWORD(v8) = v7 + v68 - 198630844 + ((v71 | ~v69) ^ v70);
    LODWORD(v8) = HIDWORD(v8);
    v72 = (v8 >> 26) + v71;
    HIDWORD(v8) = v22 + v69 + 1126891415 + ((v72 | ~v70) ^ v71);
    LODWORD(v8) = HIDWORD(v8);
    v73 = (v8 >> 22) + v72;
    HIDWORD(v8) = v36 + v70 - 1416354905 + ((v73 | ~v71) ^ v72);
    LODWORD(v8) = HIDWORD(v8);
    v74 = (v8 >> 17) + v73;
    HIDWORD(v8) = v18 + v71 - 57434055 + ((v74 | ~v72) ^ v73);
    LODWORD(v8) = HIDWORD(v8);
    v75 = (v8 >> 11) + v74;
    HIDWORD(v8) = v32 + v72 + 1700485571 + ((v75 | ~v73) ^ v74);
    LODWORD(v8) = HIDWORD(v8);
    v76 = (v8 >> 26) + v75;
    HIDWORD(v8) = v14 + v73 - 1894986606 + ((v76 | ~v74) ^ v75);
    LODWORD(v8) = HIDWORD(v8);
    v77 = (v8 >> 22) + v76;
    HIDWORD(v8) = v28 + v74 - 1051523 + ((v77 | ~v75) ^ v76);
    LODWORD(v8) = HIDWORD(v8);
    v78 = (v8 >> 17) + v77;
    HIDWORD(v8) = v10 + v75 - 2054922799 + ((v78 | ~v76) ^ v77);
    LODWORD(v8) = HIDWORD(v8);
    v79 = (v8 >> 11) + v78;
    HIDWORD(v8) = v24 + v76 + 1873313359 + ((v79 | ~v77) ^ v78);
    LODWORD(v8) = HIDWORD(v8);
    v80 = (v8 >> 26) + v79;
    HIDWORD(v8) = v38 + v77 - 30611744 + ((v80 | ~v78) ^ v79);
    LODWORD(v8) = HIDWORD(v8);
    v81 = (v8 >> 22) + v80;
    HIDWORD(v8) = v20 + v78 - 1560198380 + ((v81 | ~v79) ^ v80);
    LODWORD(v8) = HIDWORD(v8);
    v82 = (v8 >> 17) + v81;
    HIDWORD(v8) = v34 + v79 + 1309151649 + ((v82 | ~v80) ^ v81);
    LODWORD(v8) = HIDWORD(v8);
    v83 = (v8 >> 11) + v82;
    HIDWORD(v8) = v16 + v80 - 145523070 + ((v83 | ~v81) ^ v82);
    LODWORD(v8) = HIDWORD(v8);
    v84 = (v8 >> 26) + v83;
    HIDWORD(v8) = v30 + v81 - 1120210379 + ((v84 | ~v82) ^ v83);
    LODWORD(v8) = HIDWORD(v8);
    a1[37] = v38;
    v85 = (v8 >> 22) + v84;
    HIDWORD(v8) = v12 + v82 + 718787259 + ((v85 | ~v83) ^ v84);
    LODWORD(v8) = HIDWORD(v8);
    v86 = (v8 >> 17) + v85;
    v3 += v84;
    HIDWORD(v8) = v26 + v83 - 343485551 + ((v86 | ~v84) ^ v85);
    LODWORD(v8) = HIDWORD(v8);
    v4 += v86 + (v8 >> 11);
    v6 += v86;
    v5 = v85 + v88;
    a2 += 16;
    a3 -= 64;
  }
  while (a3);
  *a1 = v3;
  a1[1] = v4;
  a1[2] = v6;
  a1[3] = v5;
  return a2;
}

double llvm::MD5::MD5(llvm::MD5 *this)
{
  double result;

  result = -3.59869635e230;
  *(_OWORD *)this = xmmword_1C85F4BB0;
  *((_QWORD *)this + 2) = 0;
  return result;
}

{
  double result;

  result = -3.59869635e230;
  *(_OWORD *)this = xmmword_1C85F4BB0;
  *((_QWORD *)this + 2) = 0;
  return result;
}

void *llvm::MD5::update(int *a1, int *__src, size_t __n)
{
  size_t v3;
  int *v4;
  unsigned int v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  char *v10;
  uint64_t v12;
  size_t v13;

  v3 = __n;
  v4 = __src;
  v7 = a1[4];
  v6 = a1[5];
  v8 = (v6 + __n) & 0x1FFFFFFF;
  if (v8 < v6)
    ++v7;
  a1[4] = v7 + (__n >> 29);
  a1[5] = v8;
  v9 = v6 & 0x3F;
  if ((_DWORD)v9)
  {
    v12 = 64 - v9;
    v13 = __n - (64 - v9);
    if (__n < 64 - v9)
    {
      v10 = (char *)a1 + v9 + 24;
      return memcpy(v10, v4, v3);
    }
    memcpy((char *)a1 + v9 + 24, __src, 64 - v9);
    v4 = (int *)((char *)v4 + v12);
    llvm::MD5::body(a1, a1 + 6, 64);
    v3 = v13;
  }
  if (v3 >= 0x40)
  {
    v4 = llvm::MD5::body(a1, v4, v3 & 0xFFFFFFFFFFFFFFC0);
    v3 &= 0x3Fu;
  }
  v10 = (char *)(a1 + 6);
  return memcpy(v10, v4, v3);
}

int *llvm::MD5::final(int *a1, int *a2)
{
  uint64_t v4;
  int *v5;
  uint64_t v6;
  size_t v7;
  int v8;
  int v9;
  int *result;

  v4 = a1[5] & 0x3F;
  v5 = a1 + 6;
  v6 = v4 + 1;
  *((_BYTE *)a1 + v4 + 24) = 0x80;
  if ((v4 ^ 0x3FuLL) < 8)
  {
    bzero((char *)a1 + v6 + 24, v4 ^ 0x3F);
    llvm::MD5::body(a1, v5, 64);
    v6 = 0;
    v7 = 56;
  }
  else
  {
    v7 = 55 - v4;
  }
  bzero((char *)a1 + v6 + 24, v7);
  v8 = a1[4];
  v9 = 8 * a1[5];
  a1[5] = v9;
  a1[20] = v9;
  a1[21] = v8;
  result = llvm::MD5::body(a1, v5, 64);
  *a2 = *a1;
  a2[1] = a1[1];
  a2[2] = a1[2];
  a2[3] = a1[3];
  return result;
}

uint64_t llvm::MD5::final(llvm::MD5 *this)
{
  _QWORD v2[3];

  v2[2] = *MEMORY[0x1E0C80C00];
  llvm::MD5::final((int *)this, (int *)v2);
  return v2[0];
}

__n128 llvm::MD5::result(llvm::MD5 *this)
{
  __n128 result;
  __n128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  _QWORD v13[3];

  v13[2] = *MEMORY[0x1E0C80C00];
  v9 = *((_OWORD *)this + 6);
  v10 = *((_OWORD *)this + 7);
  v11 = *((_OWORD *)this + 8);
  v12 = *((_QWORD *)this + 18);
  v5 = *((_OWORD *)this + 2);
  v6 = *((_OWORD *)this + 3);
  v7 = *((_OWORD *)this + 4);
  v8 = *((_OWORD *)this + 5);
  v3 = *(__n128 *)this;
  v4 = *((_OWORD *)this + 1);
  llvm::MD5::final((int *)this, (int *)v13);
  *((_OWORD *)this + 6) = v9;
  *((_OWORD *)this + 7) = v10;
  *((_OWORD *)this + 8) = v11;
  *((_QWORD *)this + 18) = v12;
  *((_OWORD *)this + 2) = v5;
  *((_OWORD *)this + 3) = v6;
  *((_OWORD *)this + 4) = v7;
  *((_OWORD *)this + 5) = v8;
  result = v3;
  *(__n128 *)this = v3;
  *((_OWORD *)this + 1) = v4;
  return result;
}

_QWORD *llvm::MD5::stringifyResult(unsigned __int8 *a1, _QWORD *a2)
{
  _QWORD *result;
  uint64_t i;
  unsigned int v6;

  result = sub_1C5050254(a2, 0x20uLL);
  for (i = 0; i != 32; i += 2)
  {
    v6 = *a1++;
    *(_BYTE *)(*a2 + i) = a0123456789abcd_6[(unint64_t)v6 >> 4] | 0x20;
    *(_BYTE *)(*a2 + i + 1) = a0123456789abcd_6[v6 & 0xF] | 0x20;
  }
  return result;
}

_UNKNOWN **llvm::MSP430Attrs::getMSP430AttributeTags(llvm::MSP430Attrs *this)
{
  return &off_1E81A1880;
}

void llvm::MSP430AttributeParser::parseISA(_QWORD *a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  llvm::ELFAttributeParser::parseStringAttribute(a1, "ISA", a2, (uint64_t)off_1EF8EE8E0, 3uLL, a3);
}

void llvm::MSP430AttributeParser::parseCodeModel(_QWORD *a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  llvm::ELFAttributeParser::parseStringAttribute(a1, "Code Model", a2, (uint64_t)off_1EF8EE8F8, 3uLL, a3);
}

void llvm::MSP430AttributeParser::parseDataModel(_QWORD *a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  llvm::ELFAttributeParser::parseStringAttribute(a1, "Data Model", a2, (uint64_t)off_1EF8EE910, 4uLL, a3);
}

void llvm::MSP430AttributeParser::parseEnumSize(_QWORD *a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  llvm::ELFAttributeParser::parseStringAttribute(a1, "Enum Size", a2, (uint64_t)off_1EF8EE930, 4uLL, a3);
}

uint64_t llvm::MSP430AttributeParser::handler@<X0>(uint64_t this@<X0>, BOOL *a2@<X2>, uint64_t a3@<X1>, _QWORD *a4@<X8>)
{
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t (*v9)(_QWORD *);
  _QWORD *v10;

  v6 = 0;
  *a2 = 0;
  while (*(_DWORD *)((char *)&llvm::MSP430AttributeParser::DisplayRoutines + v6) != a3)
  {
    v6 += 24;
    if (v6 == 96)
      goto LABEL_9;
  }
  v7 = (char *)&llvm::MSP430AttributeParser::DisplayRoutines + v6;
  v9 = (uint64_t (*)(_QWORD *))*((_QWORD *)v7 + 1);
  v8 = *((_QWORD *)v7 + 2);
  v10 = (_QWORD *)(this + (v8 >> 1));
  if ((v8 & 1) != 0)
    v9 = *(uint64_t (**)(_QWORD *))(*v10 + v9);
  this = v9(v10);
  if (!*a4)
  {
    *a2 = 1;
LABEL_9:
    *a4 = 0;
  }
  return this;
}

void sub_1C5E218E4(_QWORD *a1)
{
  sub_1C62CD8A8(a1);
  JUMPOUT(0x1CAA32FC0);
}

llvm::raw_ostream *llvm::write_integer(llvm::raw_ostream *a1, unint64_t a2, size_t a3, int a4)
{
  return sub_1C5E21910(a1, a2, a3, a4, 0);
}

{
  int v4;

  if ((a2 & 0x8000000000000000) != 0)
  {
    a2 = -(uint64_t)a2;
    v4 = 1;
  }
  else
  {
    v4 = 0;
  }
  return sub_1C5E21910(a1, a2, a3, a4, v4);
}

{
  return sub_1C5E21910(a1, a2, a3, a4, 0);
}

{
  int v4;

  if ((a2 & 0x8000000000000000) != 0)
  {
    a2 = -(uint64_t)a2;
    v4 = 1;
  }
  else
  {
    v4 = 0;
  }
  return sub_1C5E21910(a1, a2, a3, a4, v4);
}

llvm::raw_ostream *sub_1C5E21910(llvm::raw_ostream *a1, unint64_t a2, size_t a3, int a4, int a5)
{
  uint64_t v8;
  __int128 v9;
  uint64_t v10;
  BOOL v11;
  size_t v12;
  _BYTE *v13;
  size_t v14;
  _BYTE *v15;
  const char *v16;
  _OWORD v17[8];
  _QWORD v18[2];

  v18[1] = *MEMORY[0x1E0C80C00];
  if (!HIDWORD(a2))
    return sub_1C5E21FD4(a1, a2, a3, a4, a5);
  v8 = 0;
  *(_QWORD *)&v9 = 0x3030303030303030;
  *((_QWORD *)&v9 + 1) = 0x3030303030303030;
  v17[6] = v9;
  v17[7] = v9;
  v17[4] = v9;
  v17[5] = v9;
  v17[2] = v9;
  v17[3] = v9;
  v10 = 127;
  v17[0] = v9;
  v17[1] = v9;
  do
  {
    *((_BYTE *)v17 + v10) = (a2 % 0xA) | 0x30;
    v8 += 0x100000000;
    --v10;
    v11 = a2 > 9;
    a2 /= 0xAuLL;
  }
  while (v11);
  v12 = v8 >> 32;
  if (a5)
  {
    v13 = (_BYTE *)*((_QWORD *)a1 + 4);
    if ((unint64_t)v13 >= *((_QWORD *)a1 + 3))
    {
      a1 = llvm::raw_ostream::write(a1, 45);
    }
    else
    {
      *((_QWORD *)a1 + 4) = v13 + 1;
      *v13 = 45;
    }
  }
  if (a4 != 1 && v12 < a3)
  {
    v14 = v12;
    do
    {
      v15 = (_BYTE *)*((_QWORD *)a1 + 4);
      if ((unint64_t)v15 >= *((_QWORD *)a1 + 3))
      {
        a1 = llvm::raw_ostream::write(a1, 48);
      }
      else
      {
        *((_QWORD *)a1 + 4) = v15 + 1;
        *v15 = 48;
      }
      ++v14;
    }
    while (v14 < a3);
  }
  v16 = (char *)v18 - v12;
  if (a4 == 1)
    return sub_1C5E22128(a1, v16, v12);
  else
    return llvm::raw_ostream::write(a1, v16, v12);
}

llvm::raw_ostream *llvm::write_hex(llvm::raw_ostream *a1, unint64_t a2, int a3, unint64_t a4, char a5)
{
  size_t v5;
  unsigned int v6;
  __int128 v7;
  unsigned int v8;
  char *v9;
  BOOL v10;
  _OWORD v12[8];
  uint64_t v13;

  LODWORD(v5) = 128;
  if (a4 < 0x80)
    LODWORD(v5) = a4;
  v6 = (67 - __clz(a2)) >> 2;
  if (!a5)
    LODWORD(v5) = 0;
  v13 = *MEMORY[0x1E0C80C00];
  if (v6 <= 1)
    v6 = 1;
  *(_QWORD *)&v7 = 0x3030303030303030;
  *((_QWORD *)&v7 + 1) = 0x3030303030303030;
  v12[6] = v7;
  v12[7] = v7;
  v12[4] = v7;
  v12[5] = v7;
  v8 = v6 + 2 * ((a3 & 0xFFFFFFFE) == 2);
  v12[2] = v7;
  v12[3] = v7;
  if (v5 <= v8)
    v5 = v8;
  else
    v5 = v5;
  v12[0] = v7;
  v12[1] = v7;
  if ((a3 & 0xFFFFFFFE) == 2)
    BYTE1(v12[0]) = 120;
  if (a2)
  {
    v9 = (char *)&v12[-1] + v5 + 15;
    do
    {
      *v9-- = a0123456789abcd_6[a2 & 0xF] | (32 * ((a3 & 0xFFFFFFFD) != 0));
      v10 = a2 > 0xF;
      a2 >>= 4;
    }
    while (v10);
  }
  return llvm::raw_ostream::write(a1, (const char *)v12, v5);
}

void llvm::write_double(llvm::raw_ostream *this, unsigned int a2, unint64_t a3, char a4, double a5)
{
  uint64_t v6;
  unint64_t v7;
  const char *v9;
  size_t v10;
  void *v11;
  char v13;
  char v14;
  llvm::raw_ostream *v15;
  char *v16;
  double v17;
  uint64_t v18;
  size_t v19;
  _BYTE *v20;
  uint64_t v21;
  size_t v22;
  void *v23;
  _QWORD v24[2];
  uint64_t v25;
  uint64_t v26;
  _WORD *v27;
  int v28;
  char __str[32];
  char *v30;
  __int128 v31;
  _QWORD v32[2];

  v32[1] = *MEMORY[0x1E0C80C00];
  v6 = 2;
  if (a2 < 2)
    v6 = 6;
  if (a4)
    v7 = a3;
  else
    v7 = v6;
  if (fabs(a5) == INFINITY)
  {
    if (a5 >= 0.0)
      v9 = "INF";
    else
      v9 = "-INF";
    if (a5 >= 0.0)
      v10 = 3;
    else
      v10 = 4;
    v11 = (void *)*((_QWORD *)this + 4);
    if (v10 <= *((_QWORD *)this + 3) - (_QWORD)v11)
    {
      memcpy(v11, v9, v10);
      *((_QWORD *)this + 4) += v10;
    }
    else
    {
      llvm::raw_ostream::write(this, v9, v10);
    }
  }
  else
  {
    if (a2 == 1)
      v13 = 69;
    else
      v13 = 102;
    if (a2)
      v14 = v13;
    else
      v14 = 101;
    v30 = (char *)v32;
    v31 = xmmword_1C6464ED0;
    sub_1C613932C((uint64_t)v24, (uint64_t)&v30);
    if ((unint64_t)(v26 - (_QWORD)v27) > 1)
    {
      *v27++ = 11813;
      v15 = (llvm::raw_ostream *)v24;
    }
    else
    {
      v15 = llvm::raw_ostream::write((llvm::raw_ostream *)v24, "%.", 2uLL);
    }
    sub_1C5E21910(v15, v7, 0, 0, 0);
    v16 = (char *)*((_QWORD *)v15 + 4);
    if ((unint64_t)v16 >= *((_QWORD *)v15 + 3))
    {
      llvm::raw_ostream::write(v15, v14);
    }
    else
    {
      *((_QWORD *)v15 + 4) = v16 + 1;
      *v16 = v14;
    }
    if (a2 == 3)
    {
      v17 = a5 * 100.0;
      v18 = v31;
      if ((unint64_t)(v31 + 1) > *((_QWORD *)&v31 + 1))
      {
        llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v30, v32, v31 + 1, 1);
        v18 = v31;
      }
      v30[v18] = 0;
      snprintf(__str, 0x20uLL, v30, *(_QWORD *)&v17);
      v19 = strlen(__str);
      v20 = (_BYTE *)*((_QWORD *)this + 4);
      if (v19 <= *((_QWORD *)this + 3) - (_QWORD)v20)
      {
        if (v19)
        {
          memcpy(v20, __str, v19);
          v20 = (_BYTE *)(*((_QWORD *)this + 4) + v19);
          *((_QWORD *)this + 4) = v20;
        }
      }
      else
      {
        llvm::raw_ostream::write(this, __str, v19);
        v20 = (_BYTE *)*((_QWORD *)this + 4);
      }
      if ((unint64_t)v20 >= *((_QWORD *)this + 3))
      {
        llvm::raw_ostream::write(this, 37);
      }
      else
      {
        *((_QWORD *)this + 4) = v20 + 1;
        *v20 = 37;
      }
    }
    else
    {
      v21 = v31;
      if ((unint64_t)(v31 + 1) > *((_QWORD *)&v31 + 1))
      {
        llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v30, v32, v31 + 1, 1);
        v21 = v31;
      }
      v30[v21] = 0;
      snprintf(__str, 0x20uLL, v30, *(_QWORD *)&a5);
      v22 = strlen(__str);
      v23 = (void *)*((_QWORD *)this + 4);
      if (v22 <= *((_QWORD *)this + 3) - (_QWORD)v23)
      {
        if (v22)
        {
          memcpy(v23, __str, v22);
          *((_QWORD *)this + 4) += v22;
        }
      }
      else
      {
        llvm::raw_ostream::write(this, __str, v22);
      }
    }
    v24[0] = off_1E81A6E70;
    if (v28 == 1 && v25)
      MEMORY[0x1CAA32F9C](v25, 0x1000C8077774924);
    if (v30 != (char *)v32)
      free(v30);
  }
}

llvm::raw_ostream *sub_1C5E21FD4(llvm::raw_ostream *a1, unsigned int a2, size_t a3, int a4, int a5)
{
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  BOOL v10;
  size_t v11;
  _BYTE *v12;
  size_t v13;
  _BYTE *v14;
  const char *v15;
  _OWORD v17[8];
  _QWORD v18[2];

  v7 = 0;
  v18[1] = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v8 = 0x3030303030303030;
  *((_QWORD *)&v8 + 1) = 0x3030303030303030;
  v17[6] = v8;
  v17[7] = v8;
  v17[4] = v8;
  v17[5] = v8;
  v17[2] = v8;
  v17[3] = v8;
  v17[0] = v8;
  v17[1] = v8;
  v9 = 127;
  do
  {
    *((_BYTE *)v17 + v9) = (a2 % 0xA) | 0x30;
    v7 += 0x100000000;
    --v9;
    v10 = a2 > 9;
    a2 /= 0xAu;
  }
  while (v10);
  v11 = v7 >> 32;
  if (a5)
  {
    v12 = (_BYTE *)*((_QWORD *)a1 + 4);
    if ((unint64_t)v12 >= *((_QWORD *)a1 + 3))
    {
      a1 = llvm::raw_ostream::write(a1, 45);
    }
    else
    {
      *((_QWORD *)a1 + 4) = v12 + 1;
      *v12 = 45;
    }
  }
  if (a4 != 1 && v11 < a3)
  {
    v13 = v11;
    do
    {
      v14 = (_BYTE *)*((_QWORD *)a1 + 4);
      if ((unint64_t)v14 >= *((_QWORD *)a1 + 3))
      {
        a1 = llvm::raw_ostream::write(a1, 48);
      }
      else
      {
        *((_QWORD *)a1 + 4) = v14 + 1;
        *v14 = 48;
      }
      ++v13;
    }
    while (v13 < a3);
  }
  v15 = (char *)v18 - v11;
  if (a4 == 1)
    return sub_1C5E22128(a1, v15, v11);
  else
    return llvm::raw_ostream::write(a1, v15, v11);
}

llvm::raw_ostream *sub_1C5E22128(llvm::raw_ostream *a1, const char *a2, size_t a3)
{
  size_t v3;
  unint64_t v6;
  unint64_t v7;
  size_t v8;
  llvm::raw_ostream *result;
  uint64_t v10;
  const char *v11;
  _BYTE *v12;

  v3 = a3;
  v6 = (a3 - 1) / 3;
  v7 = (a3 - 1) % 3;
  v8 = a3 - (v7 + 1);
  if (a3 >= v7 + 1)
    a3 = v7 + 1;
  result = llvm::raw_ostream::write(a1, a2, a3);
  if (v8)
  {
    v10 = -3 * v6;
    v11 = &a2[v3];
    do
    {
      v12 = (_BYTE *)*((_QWORD *)a1 + 4);
      if ((unint64_t)v12 >= *((_QWORD *)a1 + 3))
      {
        llvm::raw_ostream::write(a1, 44);
      }
      else
      {
        *((_QWORD *)a1 + 4) = v12 + 1;
        *v12 = 44;
      }
      result = llvm::raw_ostream::write(a1, &v11[v10], 3uLL);
      v10 += 3;
    }
    while (v10);
  }
  return result;
}

unsigned __int8 *llvm::Obfuscator::obfuscate(uint64_t a1, unsigned __int8 *a2, size_t a3, int a4, unsigned int a5)
{
  unsigned __int8 *v5;
  uint64_t v8;
  int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  unsigned int v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  int v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  int v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v44;

  v5 = a2;
  if (!a3)
    return v5;
  if (!a4)
  {
    v44 = *(unsigned int *)(a1 + 144);
    if ((_DWORD)v44)
    {
      v18 = 0;
      v19 = 0;
      do
        v19 = 33 * v19 + a2[v18++];
      while (a3 != v18);
      v20 = v44 - 1;
      v11 = *(_QWORD *)(a1 + 136);
      v21 = v11 + 8 * v44 + 8;
      v22 = 1;
      v23 = v19;
      while (1)
      {
        v24 = v23 & v20;
        v25 = *(_QWORD **)(v11 + 8 * v24);
        if (v25 != (_QWORD *)-8)
        {
          if (!v25)
            goto LABEL_46;
          if (*(_DWORD *)(v21 + 4 * v24) == v19 && a3 == *v25)
          {
            v26 = *(unsigned int *)(a1 + 156);
            if (!memcmp(v5, (char *)v25 + v26, a3))
              break;
          }
        }
        v23 = v22 + v24;
        ++v22;
      }
      if ((_DWORD)v24 != -1 && (int)v24 != v44)
      {
        v36 = 0;
        v37 = 0;
        do
          v37 = 33 * v37 + v5[v36++];
        while (a3 != v36);
        v38 = 1;
        v39 = v37;
        while (1)
        {
          v31 = v39 & v20;
          v32 = *(_QWORD **)(v11 + 8 * v31);
          if (v32 != (_QWORD *)-8)
          {
            if (!v32)
              return (unsigned __int8 *)v32;
            if (*(_DWORD *)(v21 + 4 * v31) == v37 && a3 == *v32 && !memcmp(v5, (char *)v32 + v26, a3))
              goto LABEL_49;
          }
          v39 = v38 + v31;
          ++v38;
        }
      }
    }
LABEL_46:
    v33 = a1 + 136;
    v34 = (**(uint64_t (***)(uint64_t, void *, size_t, _QWORD, _QWORD))a1)(a1, v5, a3, 0, a5);
    goto LABEL_47;
  }
  v44 = *(unsigned int *)(a1 + 112);
  if (!(_DWORD)v44)
    goto LABEL_34;
  v8 = 0;
  v9 = 0;
  do
    v9 = 33 * v9 + a2[v8++];
  while (a3 != v8);
  v10 = v44 - 1;
  v11 = *(_QWORD *)(a1 + 104);
  v12 = v11 + 8 * v44 + 8;
  v13 = 1;
  v14 = v9;
  while (1)
  {
    v15 = v14 & v10;
    v16 = *(_QWORD **)(v11 + 8 * v15);
    if (v16 != (_QWORD *)-8)
    {
      if (!v16)
        goto LABEL_34;
      if (*(_DWORD *)(v12 + 4 * v15) == v9 && a3 == *v16)
      {
        v17 = *(unsigned int *)(a1 + 124);
        if (!memcmp(v5, (char *)v16 + v17, a3))
          break;
      }
    }
    v14 = v13 + v15;
    ++v13;
  }
  if ((_DWORD)v15 == -1 || (int)v15 == v44)
  {
LABEL_34:
    v33 = a1 + 104;
    v34 = (**(uint64_t (***)(uint64_t, void *, size_t, uint64_t, _QWORD))a1)(a1, v5, a3, 1, a5);
LABEL_47:
    v40 = v34;
    v41 = v35;
    v42 = *sub_1C638D004(v33, v5, a3);
    *(_QWORD *)(v42 + 8) = v40;
    *(_QWORD *)(v42 + 16) = v41;
    return (unsigned __int8 *)v40;
  }
  v27 = 0;
  v28 = 0;
  do
    v28 = 33 * v28 + v5[v27++];
  while (a3 != v27);
  v29 = 1;
  v30 = v28;
  while (1)
  {
    v31 = v30 & v10;
    v32 = *(_QWORD **)(v11 + 8 * v31);
    if (v32 != (_QWORD *)-8)
    {
      if (!v32)
        return (unsigned __int8 *)v32;
      if (*(_DWORD *)(v12 + 4 * v31) == v28 && a3 == *v32 && !memcmp(v5, (char *)v32 + v17, a3))
        break;
    }
    v30 = v29 + v31;
    ++v29;
  }
LABEL_49:
  if ((_DWORD)v31 == -1 || (int)v31 == v44)
    return 0;
  else
    return *(unsigned __int8 **)(*(_QWORD *)(v11 + 8 * (int)v31) + 8);
}

const std::error_category *llvm::Obfuscator::lookupForwardMap@<X0>(unsigned __int8 *__s1@<X1>, std::error_category_vtbl *__n@<X2>, uint64_t a3@<X0>, uint64_t a4@<X8>)
{
  int v7;
  size_t v8;
  unsigned __int8 *v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  std::error_category_vtbl **v17;
  uint64_t v18;
  int v19;
  size_t v20;
  unsigned __int8 *v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  const std::error_category *result;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v31;

  v31 = *(unsigned int *)(a3 + 112);
  if (!(_DWORD)v31)
    goto LABEL_26;
  v7 = 0;
  if (__n)
  {
    v8 = (size_t)__n;
    v9 = __s1;
    do
    {
      v10 = *v9++;
      v7 = 33 * v7 + v10;
      --v8;
    }
    while (v8);
  }
  v11 = v31 - 1;
  v12 = *(_QWORD *)(a3 + 104);
  v13 = v12 + 8 * v31 + 8;
  v14 = 1;
  v15 = v7;
  while (1)
  {
    v16 = v15 & v11;
    v17 = *(std::error_category_vtbl ***)(v12 + 8 * v16);
    if (v17 != (std::error_category_vtbl **)-8)
    {
      if (!v17)
        goto LABEL_26;
      if (*(_DWORD *)(v13 + 4 * v16) == v7 && __n == *v17)
      {
        v18 = *(unsigned int *)(a3 + 124);
        if (!__n || !memcmp(__s1, (char *)v17 + v18, (size_t)__n))
          break;
      }
    }
    v15 = v14 + v16;
    ++v14;
  }
  if ((_DWORD)v16 == -1 || (int)v16 == v31)
  {
LABEL_26:
    result = std::generic_category();
    v27 = a4;
    *(_BYTE *)(a4 + 16) |= 1u;
    v28 = 1;
    goto LABEL_27;
  }
  v19 = 0;
  if (__n)
  {
    v20 = (size_t)__n;
    v21 = __s1;
    do
    {
      v22 = *v21++;
      v19 = 33 * v19 + v22;
      --v20;
    }
    while (v20);
  }
  v23 = 1;
  v24 = v19;
  while (1)
  {
    v25 = v24 & v11;
    result = *(const std::error_category **)(v12 + 8 * v25);
    if (result == (const std::error_category *)-8)
      goto LABEL_25;
    if (!result)
    {
      v28 = 0;
LABEL_29:
      v27 = a4;
      goto LABEL_30;
    }
    if (*(_DWORD *)(v13 + 4 * v25) == v19
      && __n == result->__vftable
      && (!__n || !memcmp(__s1, (char *)result + v18, (size_t)__n)))
    {
      break;
    }
LABEL_25:
    v24 = v23 + v25;
    ++v23;
  }
  if ((_DWORD)v25 == -1)
  {
    result = 0;
    v28 = 0;
    goto LABEL_29;
  }
  v27 = a4;
  if ((int)v25 == v31)
  {
    result = 0;
    v28 = 0;
  }
  else
  {
    v29 = *(_QWORD *)(v12 + 8 * (int)v25);
    v28 = *(_QWORD *)(v29 + 8);
    result = *(const std::error_category **)(v29 + 16);
  }
LABEL_30:
  *(_BYTE *)(v27 + 16) &= ~1u;
LABEL_27:
  *(_QWORD *)v27 = v28;
  *(_QWORD *)(v27 + 8) = result;
  return result;
}

const char *llvm::Rot13Obfuscator::obfuscateImpl(uint64_t a1, unsigned __int8 *a2, size_t a3, char a4)
{
  const char *v8;
  const char *v9;
  uint64_t v10;
  int v11;
  unsigned int v12;
  __int128 v14;

  v8 = (const char *)sub_1C484358C(a1 + 8, (a3 + 1), 0);
  v9 = v8;
  v8[a3] = 0;
  if (a3)
  {
    v10 = 0;
    do
    {
      v11 = (char)a2[v10];
      if ((v11 - 65) > 0x19)
      {
        LOBYTE(v12) = a2[v10];
        if (v12 - 97 <= 0x19)
          v12 = (v11 - 84) % 0x1Au + 97;
      }
      else
      {
        v12 = (v11 - 52) % 0x1Au + 65;
      }
      v8[v10++] = v12;
    }
    while (a3 > v10);
  }
  if ((a4 & 1) != 0)
  {
    *(_QWORD *)&v14 = v8;
    *((_QWORD *)&v14 + 1) = strlen(v8);
    sub_1C5E2353C(a1 + 168, a2, a3, &v14);
  }
  strlen(v9);
  return v9;
}

const std::error_category *llvm::Rot13Obfuscator::lookupImpl@<X0>(unsigned __int8 *__s1@<X1>, std::error_category_vtbl *__n@<X2>, uint64_t a3@<X0>, uint64_t a4@<X8>)
{
  int v7;
  size_t v8;
  unsigned __int8 *v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  std::error_category_vtbl **v17;
  uint64_t v18;
  int v19;
  size_t v20;
  unsigned __int8 *v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  const std::error_category *result;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v31;

  v31 = *(unsigned int *)(a3 + 176);
  if (!(_DWORD)v31)
    goto LABEL_26;
  v7 = 0;
  if (__n)
  {
    v8 = (size_t)__n;
    v9 = __s1;
    do
    {
      v10 = *v9++;
      v7 = 33 * v7 + v10;
      --v8;
    }
    while (v8);
  }
  v11 = v31 - 1;
  v12 = *(_QWORD *)(a3 + 168);
  v13 = v12 + 8 * v31 + 8;
  v14 = 1;
  v15 = v7;
  while (1)
  {
    v16 = v15 & v11;
    v17 = *(std::error_category_vtbl ***)(v12 + 8 * v16);
    if (v17 != (std::error_category_vtbl **)-8)
    {
      if (!v17)
        goto LABEL_26;
      if (*(_DWORD *)(v13 + 4 * v16) == v7 && __n == *v17)
      {
        v18 = *(unsigned int *)(a3 + 188);
        if (!__n || !memcmp(__s1, (char *)v17 + v18, (size_t)__n))
          break;
      }
    }
    v15 = v14 + v16;
    ++v14;
  }
  if ((_DWORD)v16 == -1 || (int)v16 == v31)
  {
LABEL_26:
    result = std::generic_category();
    v27 = a4;
    *(_BYTE *)(a4 + 16) |= 1u;
    v28 = 1;
    goto LABEL_27;
  }
  v19 = 0;
  if (__n)
  {
    v20 = (size_t)__n;
    v21 = __s1;
    do
    {
      v22 = *v21++;
      v19 = 33 * v19 + v22;
      --v20;
    }
    while (v20);
  }
  v23 = 1;
  v24 = v19;
  while (1)
  {
    v25 = v24 & v11;
    result = *(const std::error_category **)(v12 + 8 * v25);
    if (result == (const std::error_category *)-8)
      goto LABEL_25;
    if (!result)
    {
      v28 = 0;
LABEL_29:
      v27 = a4;
      goto LABEL_30;
    }
    if (*(_DWORD *)(v13 + 4 * v25) == v19
      && __n == result->__vftable
      && (!__n || !memcmp(__s1, (char *)result + v18, (size_t)__n)))
    {
      break;
    }
LABEL_25:
    v24 = v23 + v25;
    ++v23;
  }
  if ((_DWORD)v25 == -1)
  {
    result = 0;
    v28 = 0;
    goto LABEL_29;
  }
  v27 = a4;
  if ((int)v25 == v31)
  {
    result = 0;
    v28 = 0;
  }
  else
  {
    v29 = *(_QWORD *)(v12 + 8 * (int)v25);
    v28 = *(_QWORD *)(v29 + 8);
    result = *(const std::error_category **)(v29 + 16);
  }
LABEL_30:
  *(_BYTE *)(v27 + 16) &= ~1u;
LABEL_27:
  *(_QWORD *)v27 = v28;
  *(_QWORD *)(v27 + 8) = result;
  return result;
}

llvm::raw_ostream *llvm::Rot13Obfuscator::writeReverseMapImpl(llvm::raw_ostream *this, llvm::raw_ostream *a2)
{
  uint64_t v3;
  size_t **i;
  uint64_t v6;
  size_t *v7;
  const void *v8;
  size_t v9;
  _BYTE *v10;
  const void *v11;
  unint64_t v12;
  size_t *v13;
  BOOL v14;

  v3 = *((unsigned int *)this + 44);
  if ((_DWORD)v3)
  {
    for (i = (size_t **)*((_QWORD *)this + 21); !*i || *i + 1 == 0; ++i)
      ;
  }
  else
  {
    i = (size_t **)*((_QWORD *)this + 21);
  }
  v6 = *((_QWORD *)this + 21) + 8 * v3;
  if (i != (size_t **)v6)
  {
    v7 = *i;
    do
    {
      v8 = v7 + 3;
      v9 = *v7;
      v10 = (_BYTE *)*((_QWORD *)a2 + 4);
      if (*v7 <= *((_QWORD *)a2 + 3) - (_QWORD)v10)
      {
        if (v9)
        {
          memcpy(v10, v8, *v7);
          v10 = (_BYTE *)(*((_QWORD *)a2 + 4) + v9);
          *((_QWORD *)a2 + 4) = v10;
        }
      }
      else
      {
        llvm::raw_ostream::write(a2, (const char *)v8, *v7);
        v10 = (_BYTE *)*((_QWORD *)a2 + 4);
      }
      if (*((_BYTE **)a2 + 3) == v10)
      {
        llvm::raw_ostream::write(a2, ":", 1uLL);
        this = (llvm::raw_ostream *)*((_QWORD *)a2 + 4);
      }
      else
      {
        *v10 = 58;
        this = (llvm::raw_ostream *)(*((_QWORD *)a2 + 4) + 1);
        *((_QWORD *)a2 + 4) = this;
      }
      v11 = (const void *)v7[1];
      v12 = v7[2];
      if (v12 <= *((_QWORD *)a2 + 3) - (_QWORD)this)
      {
        if (v12)
        {
          memcpy(this, v11, v7[2]);
          this = (llvm::raw_ostream *)(*((_QWORD *)a2 + 4) + v12);
          *((_QWORD *)a2 + 4) = this;
        }
      }
      else
      {
        llvm::raw_ostream::write(a2, (const char *)v11, v7[2]);
        this = (llvm::raw_ostream *)*((_QWORD *)a2 + 4);
      }
      if (*((llvm::raw_ostream **)a2 + 3) == this)
      {
        this = llvm::raw_ostream::write(a2, "\n", 1uLL);
      }
      else
      {
        *(_BYTE *)this = 10;
        ++*((_QWORD *)a2 + 4);
      }
      do
      {
        v13 = i[1];
        ++i;
        v7 = v13;
        if (v13)
          v14 = v7 + 1 == 0;
        else
          v14 = 1;
      }
      while (v14);
    }
    while (i != (size_t **)v6);
  }
  return this;
}

uint64_t llvm::Rot13Obfuscator::readReverseMapImpl(uint64_t this, llvm::MemoryBuffer *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  unint64_t v13;
  unint64_t v14;
  size_t v15;
  unint64_t v16;
  char *v17;
  size_t v18;
  size_t v19;
  char *v20;
  size_t v21;
  char *v22;
  char *v23;
  char *v24;
  const char *v25;
  size_t v26;
  __int128 v27;
  uint64_t v28[2];
  uint64_t v29;
  unint64_t v30;
  char v31;

  v3 = *((_QWORD *)a2 + 1);
  v2 = *((_QWORD *)a2 + 2);
  v4 = v2 - v3;
  v29 = v3;
  v30 = v2 - v3;
  if (v2 != v3)
  {
    v5 = this + 168;
    v6 = this + 8;
    do
    {
      v31 = 10;
      v7 = llvm::StringRef::find(&v29, &v31, 1uLL, 0);
      if (v4 >= v7)
        v8 = v7;
      else
        v8 = v4;
      if (v4 >= v7 + 1)
        v9 = v7 + 1;
      else
        v9 = v4;
      v10 = v3 + v9;
      v11 = v4 - v9;
      v12 = (char *)v3;
      if (v7 == -1)
        v13 = v4;
      else
        v13 = v8;
      if (v7 == -1)
        v3 = 0;
      else
        v3 = v10;
      v28[0] = (uint64_t)v12;
      v28[1] = v13;
      if (v7 == -1)
        v4 = 0;
      else
        v4 = v11;
      v29 = v3;
      v30 = v4;
      v31 = 58;
      v14 = llvm::StringRef::find(v28, &v31, 1uLL, 0);
      if (v13 >= v14)
        v15 = v14;
      else
        v15 = v13;
      if (v13 >= v14 + 1)
        v16 = v14 + 1;
      else
        v16 = v13;
      v17 = &v12[v16];
      v18 = v13 - v16;
      if (v14 == -1)
        v19 = 0;
      else
        v19 = v18;
      if (v14 == -1)
        v20 = 0;
      else
        v20 = v17;
      if (v14 == -1)
        v21 = v13;
      else
        v21 = v15;
      v22 = (char *)sub_1C484358C(v6, (v19 + 1), 0);
      v23 = v22;
      v22[v19] = 0;
      if (v19)
        memmove(v22, v20, v19);
      v24 = (char *)sub_1C484358C(v6, (v21 + 1), 0);
      v25 = v24;
      v24[v21] = 0;
      if (v21)
        memmove(v24, v12, v21);
      v26 = strlen(v23);
      *(_QWORD *)&v27 = v25;
      *((_QWORD *)&v27 + 1) = strlen(v25);
      this = sub_1C5E2353C(v5, (unsigned __int8 *)v23, v26, &v27);
    }
    while (v4);
  }
  return this;
}

const char *llvm::IncrementObfuscator::obfuscateImpl(uint64_t a1, const char *a2, size_t a3, int a4, int a5)
{
  int v10;
  const void *v11;
  unint64_t v12;
  unint64_t v13;
  const void *v14;
  unint64_t v15;
  const void *v16;
  unint64_t v17;
  unint64_t v18;
  const void *v19;
  unint64_t v20;
  char *v21;
  const char *v22;
  size_t v23;
  size_t v24;
  unint64_t v25;
  const char **v26;
  _QWORD *v27;
  char *v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  char *v33;
  const char **v34;
  const void *v35;
  size_t v36;
  char *v37;
  const char *v38;
  _QWORD v40[2];
  uint64_t v41;
  char *v42;
  char *v43;
  int v44;
  uint64_t v45;
  void *v46;
  __int128 v47;
  _QWORD v48[17];

  v48[16] = *MEMORY[0x1E0C80C00];
  v46 = v48;
  v47 = xmmword_1C85F20B0;
  sub_1C613932C((uint64_t)v40, (uint64_t)&v46);
  if (a4)
  {
    if (a5)
    {
      if (a3)
      {
        v10 = *(unsigned __int8 *)a2;
        if ((v10 | 0x20) == 0x6C)
        {
          if (v42 == v43)
            llvm::raw_ostream::write((llvm::raw_ostream *)v40, a2, 1uLL);
          else
            *v43++ = v10;
        }
      }
    }
    v16 = *(const void **)(a1 + 168);
    v17 = *(_QWORD *)(a1 + 176);
    if (v17 <= v42 - v43)
    {
      if (v17)
      {
        memcpy(v43, v16, *(_QWORD *)(a1 + 176));
        v43 += v17;
      }
    }
    else
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)v40, (const char *)v16, *(_QWORD *)(a1 + 176));
    }
    v18 = *(unsigned int *)(a1 + 216);
    *(_DWORD *)(a1 + 216) = v18 + 1;
    sub_1C5E21910((llvm::raw_ostream *)v40, v18, 0, 0, 0);
    v19 = *(const void **)(a1 + 184);
    v20 = *(_QWORD *)(a1 + 192);
    if (v20 <= v42 - v43)
    {
      if (v20)
      {
        memcpy(v43, v19, *(_QWORD *)(a1 + 192));
        v43 += v20;
      }
    }
    else
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)v40, (const char *)v19, *(_QWORD *)(a1 + 192));
    }
    v21 = (char *)sub_1C484358C(a1 + 8, (a3 + 1), 0);
    v22 = v21;
    v21[a3] = 0;
    if (a3)
      memmove(v21, a2, a3);
    v23 = strlen(v22);
    v24 = v23;
    v26 = *(const char ***)(a1 + 232);
    v25 = *(_QWORD *)(a1 + 240);
    if ((unint64_t)v26 >= v25)
    {
      v28 = *(char **)(a1 + 224);
      v29 = ((char *)v26 - v28) >> 4;
      v30 = v29 + 1;
      if ((unint64_t)(v29 + 1) >> 60)
        abort();
      v31 = v25 - (_QWORD)v28;
      if (v31 >> 3 > v30)
        v30 = v31 >> 3;
      if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFF0)
        v32 = 0xFFFFFFFFFFFFFFFLL;
      else
        v32 = v30;
      if (v32)
      {
        if (v32 >> 60)
          sub_1C4764EE4();
        v33 = (char *)operator new(16 * v32);
      }
      else
      {
        v33 = 0;
      }
      v34 = (const char **)&v33[16 * v29];
      *v34 = v22;
      v34[1] = (const char *)v24;
      v27 = v34 + 2;
      if (v26 != (const char **)v28)
      {
        do
        {
          *((_OWORD *)v34 - 1) = *((_OWORD *)v26 - 1);
          v34 -= 2;
          v26 -= 2;
        }
        while (v26 != (const char **)v28);
        v26 = *(const char ***)(a1 + 224);
      }
      *(_QWORD *)(a1 + 224) = v34;
      *(_QWORD *)(a1 + 232) = v27;
      *(_QWORD *)(a1 + 240) = &v33[16 * v32];
      if (v26)
        operator delete(v26);
    }
    else
    {
      *v26 = v22;
      v26[1] = (const char *)v23;
      v27 = v26 + 2;
    }
    *(_QWORD *)(a1 + 232) = v27;
  }
  else
  {
    v11 = *(const void **)(a1 + 200);
    v12 = *(_QWORD *)(a1 + 208);
    if (v12 <= v42 - v43)
    {
      if (v12)
      {
        memcpy(v43, v11, *(_QWORD *)(a1 + 208));
        v43 += v12;
      }
    }
    else
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)v40, (const char *)v11, *(_QWORD *)(a1 + 208));
    }
    v13 = *(unsigned int *)(a1 + 220);
    *(_DWORD *)(a1 + 220) = v13 + 1;
    sub_1C5E21910((llvm::raw_ostream *)v40, v13, 0, 0, 0);
    v14 = *(const void **)(a1 + 184);
    v15 = *(_QWORD *)(a1 + 192);
    if (v15 <= v42 - v43)
    {
      if (v15)
      {
        memcpy(v43, v14, *(_QWORD *)(a1 + 192));
        v43 += v15;
      }
    }
    else
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)v40, (const char *)v14, *(_QWORD *)(a1 + 192));
    }
  }
  v35 = *(const void **)v45;
  v36 = *(_QWORD *)(v45 + 8);
  v37 = (char *)sub_1C484358C(a1 + 8, (v36 + 1), 0);
  v38 = v37;
  v37[v36] = 0;
  if (v36)
    memmove(v37, v35, v36);
  strlen(v38);
  v40[0] = off_1E81A6E70;
  if (v44 == 1 && v41)
    MEMORY[0x1CAA32F9C](v41, 0x1000C8077774924);
  if (v46 != v48)
    free(v46);
  return v38;
}

llvm *llvm::IncrementObfuscator::readReverseMapImpl(llvm::IncrementObfuscator *this, llvm::MemoryBuffer *a2)
{
  uint64_t v3;
  unint64_t v4;
  llvm *result;
  llvm *v6;
  char *v7;
  char *v8;
  unint64_t v9;
  size_t v10;
  char *v11;
  unint64_t v12;
  BOOL v13;
  BOOL v14;
  BOOL v15;
  llvm *v17;
  char *v18;
  char *v19;
  size_t v20;
  size_t v21;
  llvm::raw_ostream *v22;
  llvm::raw_ostream *v23;
  void *v24;
  llvm::raw_ostream *v25;
  void *v26;
  char *v27;
  char *v28;
  size_t v29;
  unint64_t v30;
  size_t v31;
  unint64_t v32;
  char *v33;
  unint64_t v34;
  uint64_t v35;
  char *v36;
  char *v37;
  uint64_t v38[2];
  _QWORD *v39;
  unint64_t v40;
  char v41;

  v3 = *((_QWORD *)a2 + 1);
  v4 = *((_QWORD *)a2 + 2) - v3;
  v39 = (_QWORD *)v3;
  v40 = v4;
  LOBYTE(v38[0]) = 10;
  result = (llvm *)llvm::StringRef::find((uint64_t *)&v39, (char *)v38, 1uLL, 0);
  if (v4 >= (unint64_t)result)
    v6 = result;
  else
    v6 = (llvm *)v4;
  if (v4 >= (unint64_t)result + 1)
    v7 = (char *)result + 1;
  else
    v7 = (char *)v4;
  v8 = &v7[v3];
  v9 = v4 - (_QWORD)v7;
  if (result == (llvm *)-1)
    v10 = v4;
  else
    v10 = (size_t)v6;
  if (result == (llvm *)-1)
    v11 = 0;
  else
    v11 = v8;
  v38[0] = v3;
  v38[1] = v10;
  if (result == (llvm *)-1)
    v12 = 0;
  else
    v12 = v9;
  v39 = v11;
  v40 = v12;
  if (v10 < 0x14
    || (*(_QWORD *)v3 == 0x6C6F626D79534342 ? (v13 = *(_QWORD *)(v3 + 8) == 0x737265562070614DLL) : (v13 = 0),
        v13 ? (v14 = *(_DWORD *)(v3 + 16) == 980316009) : (v14 = 0),
        !v14))
  {
    v25 = (llvm::raw_ostream *)llvm::errs(result);
    v26 = (void *)*((_QWORD *)v25 + 4);
    if (*((_QWORD *)v25 + 3) - (_QWORD)v26 > 0x2EuLL)
    {
      qmemcpy(v26, "warning: missing version string. Assuming 1.0.\n", 47);
      *((_QWORD *)v25 + 4) += 47;
    }
    else
    {
      llvm::raw_ostream::write(v25, "warning: missing version string. Assuming 1.0.\n", 0x2FuLL);
    }
    v27 = (char *)sub_1C484358C((uint64_t)this + 8, (v10 + 1), 0);
    v28 = v27;
    v27[v10] = 0;
    if (v10)
      memmove(v27, (const void *)v3, v10);
    result = (llvm *)sub_1C638CF84((uint64_t)this + 224, v28);
    ++*((_DWORD *)this + 54);
    goto LABEL_55;
  }
  if (v10 == 24)
  {
    v15 = *(_QWORD *)v3 == 0x6C6F626D79534342 && *(_QWORD *)(v3 + 8) == 0x737265562070614DLL;
    if (v15 && *(_QWORD *)(v3 + 16) == 0x302E31203A6E6F69)
    {
LABEL_55:
      while (v12)
      {
        v29 = v12;
        v41 = 10;
        v30 = llvm::StringRef::find((uint64_t *)&v39, &v41, 1uLL, 0);
        if (v12 >= v30)
          v31 = v30;
        else
          v31 = v12;
        if (v12 >= v30 + 1)
          v32 = v30 + 1;
        else
          v32 = v12;
        v33 = &v11[v32];
        v34 = v12 - v32;
        if (v30 == -1)
          v12 = 0;
        else
          v12 = v34;
        if (v30 == -1)
          v35 = 0;
        else
          v35 = (uint64_t)v33;
        if (v30 != -1)
          v29 = v31;
        v39 = (_QWORD *)v35;
        v40 = v12;
        v36 = (char *)sub_1C484358C((uint64_t)this + 8, (v29 + 1), 0);
        v37 = v36;
        v36[v29] = 0;
        if (v29)
          memmove(v36, v11, v29);
        result = (llvm *)sub_1C638CF84((uint64_t)this + 224, v37);
        ++*((_DWORD *)this + 54);
        v11 = (char *)v35;
      }
      return result;
    }
  }
  v41 = 58;
  v17 = (llvm *)llvm::StringRef::find(v38, &v41, 1uLL, 0);
  v18 = (char *)v17 + 1;
  if (v10 < (unint64_t)v17 + 1)
    v18 = (char *)v10;
  if (v17 == (llvm *)-1)
    v19 = 0;
  else
    v19 = &v18[v3];
  v20 = v10 - (_QWORD)v18;
  if (v17 == (llvm *)-1)
    v21 = 0;
  else
    v21 = v20;
  v22 = (llvm::raw_ostream *)llvm::errs(v17);
  v23 = v22;
  v24 = (void *)*((_QWORD *)v22 + 4);
  if (*((_QWORD *)v22 + 3) - (_QWORD)v24 > 0x1BuLL)
  {
    qmemcpy(v24, "warning: symbol map version ", 28);
    result = (llvm *)(*((_QWORD *)v22 + 4) + 28);
    *((_QWORD *)v23 + 4) = result;
  }
  else
  {
    llvm::raw_ostream::write(v22, "warning: symbol map version ", 0x1CuLL);
    result = (llvm *)*((_QWORD *)v23 + 4);
  }
  if (v21 <= *((_QWORD *)v23 + 3) - (_QWORD)result)
  {
    if (v21)
    {
      memcpy(result, v19, v21);
      result = (llvm *)(*((_QWORD *)v23 + 4) + v21);
      *((_QWORD *)v23 + 4) = result;
    }
  }
  else
  {
    llvm::raw_ostream::write(v23, v19, v21);
    result = (llvm *)*((_QWORD *)v23 + 4);
  }
  if (*((_QWORD *)v23 + 3) - (_QWORD)result <= 0x24uLL)
    return llvm::raw_ostream::write(v23, "is not supported. Not unobfuscating.\n", 0x25uLL);
  qmemcpy(result, "is not supported. Not unobfuscating.\n", 37);
  *((_QWORD *)v23 + 4) += 37;
  return result;
}

uint64_t sub_1C5E23474(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E81A1988;
  free(*(void **)(a1 + 168));
  *(_QWORD *)a1 = &unk_1E8148190;
  free(*(void **)(a1 + 136));
  free(*(void **)(a1 + 104));
  sub_1C4926AE8(a1 + 8);
  return a1;
}

void sub_1C5E234D0(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E81A1988;
  free(*(void **)(a1 + 168));
  *(_QWORD *)a1 = &unk_1E8148190;
  free(*(void **)(a1 + 136));
  free(*(void **)(a1 + 104));
  sub_1C4926AE8(a1 + 8);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C5E2353C(uint64_t result, unsigned __int8 *a2, size_t __n, _OWORD *a4)
{
  uint64_t v6;
  unsigned int v7;
  int v8;
  size_t v9;
  unsigned __int8 *v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  int v24;
  _QWORD *i;
  _OWORD *v27;

  v6 = result;
  v7 = *(_DWORD *)(result + 8);
  if (!v7)
  {
    *(_DWORD *)(result + 12) = 0;
    *(_DWORD *)(result + 16) = 0;
    result = (uint64_t)malloc_type_calloc(0x11uLL, 0xCuLL, 0x6D9A4F0CuLL);
    if (!result)
      llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    *(_QWORD *)(result + 128) = 2;
    *(_QWORD *)v6 = result;
    v7 = 16;
    *(_DWORD *)(v6 + 8) = 16;
  }
  v27 = a4;
  v8 = 0;
  if (__n)
  {
    v9 = __n;
    v10 = a2;
    do
    {
      v11 = *v10++;
      v8 = 33 * v8 + v11;
      --v9;
    }
    while (v9);
  }
  v12 = *(_QWORD *)v6;
  v13 = v7 - 1;
  v14 = *(_QWORD *)v6 + 8 * v7 + 8;
  v15 = -1;
  v16 = 1;
  v17 = v8;
  while (1)
  {
    v18 = v17 & v13;
    v19 = *(_QWORD **)(v12 + 8 * v18);
    if (!v19)
      break;
    if (v19 == (_QWORD *)-8)
    {
      if (v15 == -1)
        v15 = v17 & v13;
    }
    else if (*(_DWORD *)(v14 + 4 * v18) == v8 && __n == *v19)
    {
      if (!__n)
        goto LABEL_20;
      result = memcmp(a2, (char *)v19 + *(unsigned int *)(v6 + 20), __n);
      if (!(_DWORD)result)
        goto LABEL_20;
    }
    v17 = v16 + v18;
    ++v16;
  }
  v20 = v15;
  if (v15 == -1)
  {
    v20 = v18;
    v18 = v18;
  }
  else
  {
    v18 = v15;
  }
  *(_DWORD *)(v14 + 4 * v20) = v8;
  v19 = *(_QWORD **)(v12 + 8 * v18);
LABEL_20:
  if (v19 == (_QWORD *)-8)
  {
    --*(_DWORD *)(v6 + 16);
  }
  else if (v19)
  {
    return result;
  }
  v21 = sub_1C484358C(*(_QWORD *)(v6 + 24), __n + 25, 3);
  v22 = v21;
  v23 = v21 + 24;
  if (__n)
    memcpy((void *)(v21 + 24), a2, __n);
  *(_BYTE *)(v23 + __n) = 0;
  *(_QWORD *)v22 = __n;
  *(_OWORD *)(v22 + 8) = *v27;
  v24 = *(_DWORD *)(v6 + 12);
  *(_QWORD *)(v12 + 8 * v18) = v22;
  *(_DWORD *)(v6 + 12) = v24 + 1;
  result = llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)v6, v18);
  for (i = (_QWORD *)(*(_QWORD *)v6 + 8 * result); !*i || *i == -8; ++i)
    ;
  return result;
}

_QWORD *sub_1C5E23748(void **a1, const char *a2)
{
  char *v2;
  char *v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v8;
  unint64_t v9;
  char *v10;
  const char **v11;
  size_t v12;
  _QWORD *v13;

  v3 = (char *)*a1;
  v2 = (char *)a1[1];
  v4 = (v2 - (_BYTE *)*a1) >> 4;
  v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 60)
    abort();
  v8 = (_BYTE *)a1[2] - v3;
  if (v8 >> 3 > v5)
    v5 = v8 >> 3;
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0)
    v9 = 0xFFFFFFFFFFFFFFFLL;
  else
    v9 = v5;
  if (v9)
  {
    if (v9 >> 60)
      sub_1C4764EE4();
    v10 = (char *)operator new(16 * v9);
  }
  else
  {
    v10 = 0;
  }
  v11 = (const char **)&v10[16 * v4];
  *v11 = a2;
  if (a2)
    v12 = strlen(a2);
  else
    v12 = 0;
  v11[1] = (const char *)v12;
  v13 = v11 + 2;
  if (v2 != v3)
  {
    do
    {
      *((_OWORD *)v11 - 1) = *((_OWORD *)v2 - 1);
      v11 -= 2;
      v2 -= 16;
    }
    while (v2 != v3);
    v2 = (char *)*a1;
  }
  *a1 = v11;
  a1[1] = v13;
  a1[2] = &v10[16 * v9];
  if (v2)
    operator delete(v2);
  return v13;
}

unint64_t llvm::performOptimizedStructLayout(unint64_t *a1, unint64_t a2)
{
  unint64_t v4;
  unsigned __int8 v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  unsigned int v14;
  unint64_t *v15;
  char *i;
  unsigned int v17;
  char *v18;
  uint64_t v19;
  int v20;
  void *v21;
  char *v22;
  char *v23;
  char *v24;
  void **p_src;
  char *v26;
  __int128 v27;
  unint64_t v28;
  BOOL v29;
  unint64_t *v30;
  unint64_t v31;
  char *v32;
  uint64_t v33;
  __int128 v34;
  unint64_t v35;
  unint64_t v36;
  _BYTE *v37;
  int64_t v39;
  uint64_t *v40[3];
  _QWORD *v41;
  _QWORD v42[3];
  unint64_t v43;
  void **v44;
  void *__src;
  uint64_t v46;
  _BYTE v47[640];
  void *v48;
  uint64_t v49;
  _QWORD v50[26];

  v50[24] = *MEMORY[0x1E0C80C00];
  if (!a2)
    return 0;
  v4 = 0;
  v5 = 0;
  v6 = (char *)&a1[5 * a2];
  v7 = 40 * a2;
  v8 = 40 * a2;
  while (a1[v4 / 8] != -1)
  {
    if (v5 <= LOBYTE(a1[v4 / 8 + 4]))
      v5 = a1[v4 / 8 + 4];
    v8 -= 40;
    v4 += 40;
    if (v7 == v4)
      return a1[5 * a2 - 4] + a1[5 * a2 - 5];
  }
  v10 = &a1[v4 / 8];
  if (v7 != v4)
  {
    v11 = 0;
    v12 = 0;
    do
    {
      v13 = (char *)&a1[v11 / 8 + v4 / 8];
      *((_QWORD *)v13 + 3) = v12++;
      v14 = v13[32];
      if (v5 <= v14)
        v5 = v14;
      v11 += 40;
    }
    while (v8 != v11);
  }
  if (v8 >= 80)
    qsort(&a1[v4 / 8], v8 / 0x28uLL, 0x28uLL, (int (__cdecl *)(const void *, const void *))sub_1C5E23ED0);
  v9 = 0;
  if (v4)
  {
    v15 = a1;
    while (v9 == *v15)
    {
      v9 += v15[1];
      v15 += 5;
      if (v10 == v15)
        goto LABEL_20;
    }
  }
  else
  {
LABEL_20:
    if (v7 == v4)
      return v9;
    for (i = (char *)&a1[v4 / 8]; v9 == ((v9 + (1 << i[32]) - 1) & -(1 << i[32])); i += 40)
    {
      *(_QWORD *)i = v9;
      v9 += *((_QWORD *)i + 1);
      v8 -= 40;
      if (!v8)
        return v9;
    }
  }
  v48 = v50;
  v49 = 0x800000000;
  if (v7 != v4)
  {
    v17 = 0;
    v18 = (char *)&a1[v4 / 8];
    do
    {
      v19 = (uint64_t)v18;
      v20 = v18[32];
      v21 = (void *)*((_QWORD *)v18 + 1);
      v22 = v18 + 40;
      if (v18 + 40 == v6)
      {
        v23 = v18;
LABEL_34:
        v18 = v6;
      }
      else
      {
        while (1)
        {
          v18 = v22;
          if (v22[32] != v20)
            break;
          *((_QWORD *)v22 - 2) = v22;
          if (*((_QWORD *)v22 + 1) < (unint64_t)v21)
            v21 = (void *)*((_QWORD *)v22 + 1);
          v22 += 40;
          if (v18 + 40 == v6)
          {
            v23 = v18;
            goto LABEL_34;
          }
        }
        v23 = v22 - 40;
      }
      *((_QWORD *)v23 + 3) = 0;
      __src = v21;
      v46 = v19;
      v47[0] = v20;
      v24 = (char *)v48;
      if (v17 >= HIDWORD(v49))
      {
        v28 = v17 + 1;
        v29 = (char *)v48 + 24 * v17 > (char *)&__src;
        if (v48 <= &__src && v29)
        {
          v39 = (char *)&__src - (_BYTE *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, (uint64_t)v50, v28, 24);
          v24 = (char *)v48;
          p_src = (void **)((char *)v48 + v39);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, (uint64_t)v50, v28, 24);
          p_src = &__src;
          v24 = (char *)v48;
        }
      }
      else
      {
        p_src = &__src;
      }
      v26 = &v24[24 * v49];
      v27 = *(_OWORD *)p_src;
      *((_QWORD *)v26 + 2) = p_src[2];
      *(_OWORD *)v26 = v27;
      v17 = v49 + 1;
      LODWORD(v49) = v49 + 1;
    }
    while (v18 != v6);
  }
  v44 = &v48;
  __src = v47;
  v46 = 0x1000000000;
  if (a2 >= 0x11)
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, (uint64_t)v47, a2, 40);
  v42[0] = &v44;
  v42[1] = &__src;
  v42[2] = &v43;
  v43 = 0;
  v41 = v42;
  v40[0] = (uint64_t *)&v48;
  v40[1] = (uint64_t *)&v43;
  v40[2] = (uint64_t *)&v41;
  if (v4)
  {
    v30 = a1;
    do
    {
      while (v43 != *v30 && (sub_1C5E23CA4(v40, *v30, 1) & 1) != 0)
        ;
      v31 = sub_1C4A20B14((uint64_t)&__src, (unint64_t)v30, 1);
      v32 = (char *)__src + 40 * v46;
      v33 = *(_QWORD *)(v31 + 32);
      v34 = *(_OWORD *)(v31 + 16);
      *(_OWORD *)v32 = *(_OWORD *)v31;
      *((_OWORD *)v32 + 1) = v34;
      *((_QWORD *)v32 + 4) = v33;
      LODWORD(v46) = v46 + 1;
      v35 = *v30;
      v36 = v30[1];
      v30 += 5;
      v9 = v36 + v35;
      v43 = v36 + v35;
    }
    while (v10 != v30);
  }
  else
  {
    v9 = 0;
  }
  if ((_DWORD)v49)
  {
    do
      sub_1C5E23CA4(v40, 0, 0);
    while ((_DWORD)v49);
    v9 = v43;
  }
  v37 = __src;
  memcpy(a1, __src, 40 * a2);
  if (v37 != v47)
    free(v37);
  if (v48 != v50)
    free(v48);
  return v9;
}

uint64_t sub_1C5E23CA4(uint64_t **a1, unint64_t a2, char a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t **v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  uint64_t *v30;
  uint64_t v31;

  v3 = **a1;
  v4 = *((unsigned int *)*a1 + 2);
  v5 = v3 + 24 * v4;
  v6 = *a1[1];
  v7 = v3;
  if ((_DWORD)v4)
  {
    v8 = 24 * v4;
    v7 = **a1;
    while ((v6 & ~(-1 << *(_BYTE *)(v7 + 16))) != 0)
    {
      v7 += 24;
      v8 -= 24;
      if (!v8)
      {
        v7 = v5;
        break;
      }
    }
  }
  v9 = v6 - 1;
  while (1)
  {
    v10 = v7;
    if (v7 != v5)
      break;
LABEL_14:
    if (v10 == v3)
      return 0;
    v6 = ((1 << *(_BYTE *)(v10 - 8)) + v9) & -(1 << *(_BYTE *)(v10 - 8));
    if (a3)
    {
      if (v6 >= a2)
        return 0;
    }
    v13 = v10;
    while (1)
    {
      v7 = v13 - 24;
      if (v13 - 24 == v3)
        break;
      v14 = ((1 << *(_BYTE *)(v13 - 32)) + v9) & -(1 << *(_BYTE *)(v13 - 32));
      v13 -= 24;
      if (v6 != v14)
        goto LABEL_22;
    }
    v7 = **a1;
LABEL_22:
    v5 = v10;
  }
  if (a3)
    v11 = a2 - v6;
  else
    v11 = -1;
  v12 = v7 + 31;
  while (*(_QWORD *)v7 > v11)
  {
    v7 += 24;
    v12 += 24;
    if (v7 == v5)
      goto LABEL_14;
  }
  v15 = 0;
  v16 = v7 + 8;
  do
  {
    v17 = v15;
    v15 = *(_QWORD *)v16;
    v18 = *(_QWORD *)(*(_QWORD *)v16 + 8);
    v16 = *(_QWORD *)v16 + 24;
  }
  while (v18 > v11);
  v19 = (uint64_t **)*a1[2];
  v20 = *(_QWORD *)v16;
  if (v17)
  {
    *(_QWORD *)(v17 + 24) = v20;
    if (!*(_QWORD *)v16)
      *(_QWORD *)v7 = *(_QWORD *)(v17 + 8);
  }
  else if (v20)
  {
    *(_QWORD *)(v7 + 8) = v20;
  }
  else
  {
    v22 = **v19;
    v23 = *(_DWORD *)(v22 + 8);
    v24 = *(_QWORD *)v22 + 24 * v23;
    if (v7 + 24 != v24)
    {
      memmove((void *)v7, (const void *)(v7 + 24), v24 - v12);
      v23 = *(_DWORD *)(v22 + 8);
    }
    *(_DWORD *)(v22 + 8) = v23 - 1;
  }
  v25 = (uint64_t)v19[1];
  v21 = 1;
  v26 = sub_1C4A20B14(v25, v15, 1);
  v27 = *(_QWORD *)v25 + 40 * *(unsigned int *)(v25 + 8);
  v28 = *(_OWORD *)v26;
  v29 = *(_OWORD *)(v26 + 16);
  *(_QWORD *)(v27 + 32) = *(_QWORD *)(v26 + 32);
  *(_OWORD *)v27 = v28;
  *(_OWORD *)(v27 + 16) = v29;
  ++*(_DWORD *)(v25 + 8);
  v30 = v19[2];
  v31 = *v19[1] + 40 * *((unsigned int *)v19[1] + 2);
  *(_QWORD *)(v31 - 40) = v6;
  *v30 = *(_QWORD *)(v31 - 32) + v6;
  return v21;
}

uint64_t sub_1C5E23ED0(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  BOOL v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  BOOL v9;
  unsigned int v10;

  v2 = *(unsigned __int8 *)(a1 + 32);
  v3 = *(unsigned __int8 *)(a2 + 32);
  v4 = v2 >= v3;
  if (v2 == v3 && (v5 = *(_QWORD *)(a1 + 8), v6 = *(_QWORD *)(a2 + 8), v4 = v5 >= v6, v5 == v6))
  {
    v7 = *(_QWORD *)(a1 + 24);
    v8 = *(_QWORD *)(a2 + 24);
    v9 = v7 == v8;
    if (v7 < v8)
      v10 = -1;
    else
      v10 = 1;
    if (v9)
      return 0;
    else
      return v10;
  }
  else if (v4)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    return 1;
  }
}

uint64_t llvm::parallel::detail::TaskGroup::TaskGroup(uint64_t this)
{
  unsigned int v1;

  *(_DWORD *)this = 0;
  *(_QWORD *)(this + 8) = 850045863;
  *(_OWORD *)(this + 16) = 0u;
  *(_OWORD *)(this + 32) = 0u;
  *(_OWORD *)(this + 48) = 0u;
  *(_QWORD *)(this + 64) = 0;
  *(_QWORD *)(this + 72) = 1018212795;
  *(_OWORD *)(this + 80) = 0u;
  *(_OWORD *)(this + 96) = 0u;
  *(_QWORD *)(this + 112) = 0;
  do
    v1 = __ldaxr(&dword_1EF8F7304);
  while (__stlxr(v1 + 1, &dword_1EF8F7304));
  *(_BYTE *)(this + 120) = v1 == 0;
  return this;
}

{
  unsigned int v1;

  *(_DWORD *)this = 0;
  *(_QWORD *)(this + 8) = 850045863;
  *(_OWORD *)(this + 16) = 0u;
  *(_OWORD *)(this + 32) = 0u;
  *(_OWORD *)(this + 48) = 0u;
  *(_QWORD *)(this + 64) = 0;
  *(_QWORD *)(this + 72) = 1018212795;
  *(_OWORD *)(this + 80) = 0u;
  *(_OWORD *)(this + 96) = 0u;
  *(_QWORD *)(this + 112) = 0;
  do
    v1 = __ldaxr(&dword_1EF8F7304);
  while (__stlxr(v1 + 1, &dword_1EF8F7304));
  *(_BYTE *)(this + 120) = v1 == 0;
  return this;
}

void llvm::parallel::detail::TaskGroup::~TaskGroup(llvm::parallel::detail::TaskGroup *this)
{
  unsigned int v2;

  sub_1C5E24014((uint64_t)this);
  do
    v2 = __ldaxr(&dword_1EF8F7304);
  while (__stlxr(v2 - 1, &dword_1EF8F7304));
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 72));
  std::mutex::~mutex((std::mutex *)((char *)this + 8));
}

{
  unsigned int v2;

  sub_1C5E24014((uint64_t)this);
  do
    v2 = __ldaxr(&dword_1EF8F7304);
  while (__stlxr(v2 - 1, &dword_1EF8F7304));
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 72));
  std::mutex::~mutex((std::mutex *)((char *)this + 8));
}

void sub_1C5E24014(uint64_t a1)
{
  std::mutex *m;
  std::unique_lock<std::mutex> v3;

  m = (std::mutex *)(a1 + 8);
  v3.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 8);
  v3.__owns_ = 1;
  std::mutex::lock((std::mutex *)(a1 + 8));
  if (!*(_DWORD *)a1)
    goto LABEL_5;
  do
    std::condition_variable::wait((std::condition_variable *)(a1 + 72), &v3);
  while (*(_DWORD *)a1);
  if (v3.__owns_)
  {
    m = v3.__m_;
LABEL_5:
    std::mutex::unlock(m);
  }
}

uint64_t llvm::parallel::detail::TaskGroup::spawn(uint64_t a1, _QWORD *a2)
{
  _DWORD *v3;
  std::mutex *v4;
  unsigned __int8 v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t result;
  _QWORD *v11;
  _QWORD *v12;
  void (**v13)(void);
  uint64_t (*v14)(void);
  _QWORD v16[3];
  _QWORD *v17;
  _DWORD *v18;
  _QWORD v19[3];
  _QWORD *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 120))
  {
    v9 = a2[3];
    if (v9)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 48))(v9);
    sub_1C485C2F0();
    return llvm::parallelForEachN();
  }
  v3 = (_DWORD *)a1;
  v4 = (std::mutex *)(a1 + 8);
  std::mutex::lock((std::mutex *)(a1 + 8));
  ++*v3;
  std::mutex::unlock(v4);
  v5 = atomic_load((unsigned __int8 *)&qword_1ED825CA0);
  if ((v5 & 1) == 0 && __cxa_guard_acquire(&qword_1ED825CA0))
  {
    if (!atomic_load((unint64_t *)&qword_1ED825CA8))
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1ED825CA8, (void *(*)(void))sub_1C5E24580, (void (*)(void *))sub_1C5E247FC);
    qword_1ED825C98 = qword_1ED825CA8;
    __cxa_atexit((void (*)(void *))sub_1C5E24548, &qword_1ED825C98, &dword_1C475E000);
    __cxa_guard_release(&qword_1ED825CA0);
  }
  v6 = qword_1ED825C98;
  v7 = (_QWORD *)a2[3];
  if (v7)
  {
    if (v7 == a2)
    {
      v17 = v16;
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, v16);
      v8 = v17;
    }
    else
    {
      v8 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v7 + 16))(v7);
      v17 = v8;
    }
  }
  else
  {
    v8 = 0;
    v17 = 0;
  }
  v18 = v3;
  v11 = operator new(0x30uLL);
  v12 = v11;
  *v11 = &off_1E81A1A40;
  if (v8)
  {
    if (v8 == v16)
    {
      v11[4] = v11 + 1;
      (*(void (**)(_QWORD *))(v16[0] + 24))(v16);
      v3 = v18;
    }
    else
    {
      v11[4] = v8;
      v17 = 0;
    }
  }
  else
  {
    v11[4] = 0;
  }
  v12[5] = v3;
  v20 = v12;
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v6 + 16))(v6, v19);
  if (v20 == v19)
  {
    v13 = (void (**)(void))(v19[0] + 32);
    goto LABEL_19;
  }
  if (v20)
  {
    v13 = (void (**)(void))(*v20 + 40);
LABEL_19:
    (*v13)();
  }
  result = (uint64_t)v17;
  if (v17 == v16)
  {
    v14 = *(uint64_t (**)(void))(v16[0] + 32);
  }
  else
  {
    if (!v17)
      return result;
    v14 = *(uint64_t (**)(void))(*v17 + 40);
  }
  return v14();
}

void llvm::parallelForEachN(uint64_t a1, unint64_t a2, void (*a3)(uint64_t, uint64_t), uint64_t a4)
{
  uint64_t v5;
  unint64_t v6;
  uint64_t v10;
  unsigned int v11;
  _QWORD *v12;
  void (**v13)(void);
  unsigned int v14;
  void (*v15)(uint64_t, uint64_t);
  uint64_t v16;
  _QWORD v17[3];
  _QWORD *v18;
  int v19;
  std::mutex v20;
  std::condition_variable v21;
  BOOL v22;
  uint64_t v23;

  v5 = a1;
  v23 = *MEMORY[0x1E0C80C00];
  v15 = a3;
  v16 = a4;
  v6 = a2 - a1;
  if (a2 - a1 < 2 || (_DWORD)llvm::parallel::strategy == 1)
  {
    if (a2 != a1)
    {
      do
        a3(a4, v5++);
      while (a2 != v5);
    }
  }
  else
  {
    v19 = 0;
    v20.__m_.__sig = 850045863;
    if (v6 < 0x400)
      v10 = 1;
    else
      v10 = v6 >> 10;
    memset(v20.__m_.__opaque, 0, sizeof(v20.__m_.__opaque));
    v21.__cv_.__sig = 1018212795;
    memset(v21.__cv_.__opaque, 0, sizeof(v21.__cv_.__opaque));
    do
      v11 = __ldaxr(&dword_1EF8F7304);
    while (__stlxr(v11 + 1, &dword_1EF8F7304));
    v22 = v11 == 0;
    if (v10 + a1 < a2)
    {
      while (1)
      {
        v12 = operator new(0x20uLL);
        *v12 = &unk_1E81A1A88;
        v12[1] = &v15;
        v12[2] = v5;
        v12[3] = v10;
        v18 = v12;
        llvm::parallel::detail::TaskGroup::spawn((uint64_t)&v19, v17);
        if (v18 == v17)
          break;
        if (v18)
        {
          v13 = (void (**)(void))(*v18 + 40);
LABEL_19:
          (*v13)();
        }
        v5 += v10;
        if (v10 + v5 >= a2)
          goto LABEL_21;
      }
      v13 = (void (**)(void))(v17[0] + 32);
      goto LABEL_19;
    }
LABEL_21:
    while (a2 != v5)
      v15(v16, v5++);
    sub_1C5E24014((uint64_t)&v19);
    do
      v14 = __ldaxr(&dword_1EF8F7304);
    while (__stlxr(v14 - 1, &dword_1EF8F7304));
    std::condition_variable::~condition_variable(&v21);
    std::mutex::~mutex(&v20);
  }
}

uint64_t *sub_1C5E24548(uint64_t *a1)
{
  uint64_t v2;

  v2 = *a1;
  *a1 = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  return a1;
}

uint64_t sub_1C5E24580()
{
  uint64_t v0;
  std::mutex *v1;
  pthread_t **v2;
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  uint64_t v12;
  char *v13;
  std::thread *v14;
  std::thread *v15;
  std::thread *v16;
  _QWORD *v17;
  std::__thread_struct *v18;
  _QWORD *v19;
  int v20;
  int v21;
  pthread_t v23;
  uint64_t v24;
  uint64_t *v25;

  v0 = operator new();
  v24 = llvm::parallel::strategy;
  *(_QWORD *)v0 = &off_1E81A1A18;
  *(_BYTE *)(v0 + 8) = 0;
  *(_QWORD *)(v0 + 64) = 850045863;
  v1 = (std::mutex *)(v0 + 64);
  *(_OWORD *)(v0 + 16) = 0u;
  *(_OWORD *)(v0 + 32) = 0u;
  *(_OWORD *)(v0 + 48) = 0u;
  *(_OWORD *)(v0 + 72) = 0u;
  *(_OWORD *)(v0 + 88) = 0u;
  *(_OWORD *)(v0 + 104) = 0u;
  *(_QWORD *)(v0 + 120) = 0;
  *(_QWORD *)(v0 + 128) = 1018212795;
  *(_OWORD *)(v0 + 136) = 0u;
  *(_OWORD *)(v0 + 152) = 0u;
  *(_QWORD *)(v0 + 168) = 0;
  std::promise<void>::promise((std::promise<void> *)(v0 + 176));
  *(_QWORD *)(v0 + 184) = 0;
  v2 = (pthread_t **)(v0 + 184);
  *(_QWORD *)(v0 + 192) = 0;
  *(_QWORD *)(v0 + 200) = 0;
  v3 = llvm::ThreadPoolStrategy::compute_thread_count((llvm::ThreadPoolStrategy *)&v24);
  v4 = v3;
  v5 = v3;
  v6 = *(char **)(v0 + 184);
  if (v3 > (unint64_t)((uint64_t)(*(_QWORD *)(v0 + 200) - (_QWORD)v6) >> 3))
  {
    v7 = *(char **)(v0 + 192);
    v8 = (char *)operator new(8 * v3);
    v9 = &v8[8 * v5];
    v10 = &v8[(v7 - v6) & 0xFFFFFFFFFFFFFFF8];
    if (v7 == v6)
    {
      *(_QWORD *)(v0 + 184) = v10;
      *(_QWORD *)(v0 + 192) = v10;
      *(_QWORD *)(v0 + 200) = v9;
    }
    else
    {
      v11 = &v8[(v7 - v6) & 0xFFFFFFFFFFFFFFF8];
      do
      {
        v12 = *((_QWORD *)v7 - 1);
        v7 -= 8;
        *((_QWORD *)v11 - 1) = v12;
        v11 -= 8;
        *(_QWORD *)v7 = 0;
      }
      while (v7 != v6);
      v6 = *(char **)(v0 + 184);
      v13 = *(char **)(v0 + 192);
      *(_QWORD *)(v0 + 184) = v11;
      *(_QWORD *)(v0 + 192) = v10;
      *(_QWORD *)(v0 + 200) = v9;
      while (v13 != v6)
        std::thread::~thread((std::thread *)v13 - 1);
    }
    if (v6)
      operator delete(v6);
  }
  v14 = *(std::thread **)(v0 + 184);
  v15 = *(std::thread **)(v0 + 192);
  if (v15 == v14)
  {
    if (*(std::thread **)(v0 + 200) == v15)
    {
      v17 = operator new(8uLL);
      *(_QWORD *)(v0 + 184) = v17;
      *v17++ = 0;
      *(_QWORD *)(v0 + 192) = v17;
      *(_QWORD *)(v0 + 200) = v17;
      if (v15)
        operator delete(v15);
    }
    else
    {
      v15->__t_ = 0;
      *(_QWORD *)(v0 + 192) = v15 + 1;
    }
  }
  else if ((unint64_t)((char *)v15 - (char *)v14) >= 9)
  {
    v16 = v14 + 1;
    while (v15 != v16)
      std::thread::~thread(--v15);
    *(_QWORD *)(v0 + 192) = v16;
  }
  std::mutex::lock(v1);
  v18 = (std::__thread_struct *)operator new();
  std::__thread_struct::__thread_struct(v18);
  v19 = (_QWORD *)operator new();
  *v19 = v18;
  v19[1] = v0;
  v20 = v24;
  *((_DWORD *)v19 + 4) = v4;
  *((_DWORD *)v19 + 5) = v20;
  *((_WORD *)v19 + 12) = WORD2(v24);
  v21 = pthread_create(&v23, 0, (void *(__cdecl *)(void *))sub_1C5E24FBC, v19);
  if (v21)
  {
    std::__throw_system_error(v21, "thread constructor failed");
LABEL_25:
    std::terminate();
  }
  v25 = 0;
  sub_1C5E25174(&v25);
  if (**v2)
    goto LABEL_25;
  **v2 = v23;
  v23 = 0;
  std::thread::~thread((std::thread *)&v23);
  std::mutex::unlock(v1);
  return v0;
}

uint64_t sub_1C5E24800(uint64_t a1)
{
  pthread_t v2;
  std::thread *v3;
  std::thread *v4;
  _opaque_pthread_t *v5;
  std::thread *v6;
  std::thread *v7;
  void **v8;
  void **v9;
  _QWORD *v10;
  unint64_t v11;
  void **v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;

  *(_QWORD *)a1 = &off_1E81A1A18;
  sub_1C5E25580(a1);
  v2 = pthread_self();
  v3 = *(std::thread **)(a1 + 184);
  v4 = *(std::thread **)(a1 + 192);
  if (v3 != v4)
  {
    v5 = v2;
    while (1)
    {
      if (v3->__t_)
      {
        if (!v5 || v3->__t_ != v5)
        {
LABEL_8:
          std::thread::join(v3);
          goto LABEL_9;
        }
      }
      else if (v5)
      {
        goto LABEL_8;
      }
      std::thread::detach(v3);
LABEL_9:
      if (++v3 == v4)
      {
        v3 = *(std::thread **)(a1 + 184);
        break;
      }
    }
  }
  if (v3)
  {
    v6 = *(std::thread **)(a1 + 192);
    v7 = v3;
    if (v6 != v3)
    {
      do
        std::thread::~thread(v6 - 1);
      while (v6 != v3);
      v7 = *(std::thread **)(a1 + 184);
    }
    *(_QWORD *)(a1 + 192) = v3;
    operator delete(v7);
  }
  MEMORY[0x1CAA32EF4](a1 + 176);
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 128));
  std::mutex::~mutex((std::mutex *)(a1 + 64));
  v8 = *(void ***)(a1 + 24);
  v9 = *(void ***)(a1 + 32);
  if (v9 != v8)
  {
    v10 = (_QWORD *)(a1 + 56);
    v11 = *(_QWORD *)(a1 + 48);
    v12 = &v8[v11 >> 7];
    v13 = (uint64_t)*v12;
    v14 = (uint64_t)*v12 + 32 * (v11 & 0x7F);
    v15 = *(uint64_t *)((char *)v8 + (((*(_QWORD *)(a1 + 56) + v11) >> 4) & 0xFFFFFFFFFFFFFF8))
        + 32 * ((*(_QWORD *)(a1 + 56) + v11) & 0x7F);
    if (v14 == v15)
      goto LABEL_28;
    while (1)
    {
      v16 = *(_QWORD **)(v14 + 24);
      if (v16 == (_QWORD *)v14)
        break;
      if (v16)
      {
        v17 = 5;
LABEL_22:
        (*(void (**)(void))(*v16 + 8 * v17))();
        v13 = (uint64_t)*v12;
      }
      v14 += 32;
      if (v14 - v13 == 4096)
      {
        v18 = (uint64_t)v12[1];
        ++v12;
        v13 = v18;
        v14 = v18;
      }
      if (v14 == v15)
      {
        v8 = *(void ***)(a1 + 24);
        v9 = *(void ***)(a1 + 32);
        goto LABEL_28;
      }
    }
    v16 = (_QWORD *)v14;
    v17 = 4;
    goto LABEL_22;
  }
  v10 = (_QWORD *)(a1 + 56);
  v9 = *(void ***)(a1 + 24);
LABEL_28:
  *v10 = 0;
  v19 = (char *)v9 - (char *)v8;
  if ((unint64_t)((char *)v9 - (char *)v8) >= 0x11)
  {
    do
    {
      operator delete(*v8);
      v9 = *(void ***)(a1 + 32);
      v8 = (void **)(*(_QWORD *)(a1 + 24) + 8);
      *(_QWORD *)(a1 + 24) = v8;
      v19 = (char *)v9 - (char *)v8;
    }
    while ((unint64_t)((char *)v9 - (char *)v8) > 0x10);
  }
  v20 = v19 >> 3;
  if (v20 == 1)
  {
    v21 = 64;
    goto LABEL_34;
  }
  if (v20 == 2)
  {
    v21 = 128;
LABEL_34:
    *(_QWORD *)(a1 + 48) = v21;
  }
  if (v8 != v9)
  {
    do
    {
      v22 = *v8++;
      operator delete(v22);
    }
    while (v8 != v9);
    v24 = *(_QWORD *)(a1 + 24);
    v23 = *(_QWORD *)(a1 + 32);
    if (v23 != v24)
      *(_QWORD *)(a1 + 32) = v23 + ((v24 - v23 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  v25 = *(void **)(a1 + 16);
  if (v25)
    operator delete(v25);
  return a1;
}

void sub_1C5E24A28(uint64_t a1)
{
  sub_1C5E24800(a1);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5E24A4C(uint64_t a1, uint64_t a2)
{
  std::mutex *v4;
  char *v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  BOOL v10;
  unint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  int64_t v21;
  char *v22;
  char *v23;
  char *v24;
  void *v25;
  void *v26;
  unint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  void *v31;
  unint64_t v32;
  char *v33;
  char *v34;
  BOOL v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  unint64_t v44;
  void *v45;
  char *v46;
  char *v47;
  char *v48;
  char *v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  char *v57;
  uint64_t v58;
  uint64_t v59;
  char *v60;
  void *v61;
  unint64_t v62;
  char *v63;
  char *v64;
  uint64_t v65;
  char *v66;
  char *v67;
  uint64_t v68;
  char *v69;
  char *v70;
  uint64_t v71;
  char *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  char *v77;
  size_t v78;
  unint64_t v79;
  char *v80;
  char *v81;
  uint64_t v82;
  uint64_t v83;
  char *v84;
  uint64_t v85;

  v4 = (std::mutex *)(a1 + 64);
  std::mutex::lock((std::mutex *)(a1 + 64));
  v5 = *(char **)(a1 + 24);
  v6 = *(char **)(a1 + 32);
  v7 = v6 - v5;
  if (v6 == v5)
    v8 = 0;
  else
    v8 = 16 * (v6 - v5) - 1;
  v9 = *(_QWORD *)(a1 + 48);
  if (v8 != *(_QWORD *)(a1 + 56) + v9)
    goto LABEL_37;
  v10 = v9 >= 0x80;
  v11 = v9 - 128;
  if (v10)
  {
    *(_QWORD *)(a1 + 48) = v11;
    v14 = *(_QWORD *)v5;
    v12 = v5 + 8;
    v13 = v14;
    *(_QWORD *)(a1 + 24) = v12;
    if (v6 == *(char **)(a1 + 40))
    {
      v15 = *(char **)(a1 + 16);
      if (v12 <= v15)
      {
        if (v6 == v15)
          v32 = 1;
        else
          v32 = (v6 - v15) >> 2;
        if (v32 >> 61)
          goto LABEL_104;
        v33 = (char *)operator new(8 * v32);
        v34 = &v33[8 * (v32 >> 2)];
        v36 = v6 - v12;
        v35 = v6 == v12;
        v6 = v34;
        if (!v35)
        {
          v6 = &v34[v36 & 0xFFFFFFFFFFFFFFF8];
          v37 = 8 * (v36 >> 3);
          v38 = &v33[8 * (v32 >> 2)];
          do
          {
            v39 = *(_QWORD *)v12;
            v12 += 8;
            *(_QWORD *)v38 = v39;
            v38 += 8;
            v37 -= 8;
          }
          while (v37);
        }
        *(_QWORD *)(a1 + 16) = v33;
        *(_QWORD *)(a1 + 24) = v34;
        *(_QWORD *)(a1 + 32) = v6;
        *(_QWORD *)(a1 + 40) = &v33[8 * v32];
        if (v15)
        {
          operator delete(v15);
          v6 = *(char **)(a1 + 32);
        }
      }
      else
      {
        v16 = (v12 - v15) >> 3;
        if (v16 >= -1)
          v17 = v16 + 1;
        else
          v17 = v16 + 2;
        v18 = -(v17 >> 1);
        v19 = v17 >> 1;
        v20 = &v12[-8 * v19];
        v21 = v6 - v12;
        if (v6 != v12)
        {
          memmove(&v12[-8 * v19], v12, v6 - v12);
          v6 = *(char **)(a1 + 24);
        }
        v22 = &v6[8 * v18];
        v6 = &v20[v21];
        *(_QWORD *)(a1 + 24) = v22;
        *(_QWORD *)(a1 + 32) = &v20[v21];
      }
    }
    *(_QWORD *)v6 = v13;
    goto LABEL_35;
  }
  v23 = *(char **)(a1 + 40);
  v24 = *(char **)(a1 + 16);
  if (v7 >= (unint64_t)(v23 - v24))
  {
    if (v23 == v24)
      v27 = 1;
    else
      v27 = (v23 - v24) >> 2;
    if (v27 >> 61)
      goto LABEL_104;
    v28 = (char *)operator new(8 * v27);
    v29 = &v28[v7];
    v30 = &v28[8 * v27];
    v31 = operator new(0x1000uLL);
    if (v27 == v7 >> 3)
    {
      if (v7 < 1)
      {
        if (v6 == v5)
          v44 = 1;
        else
          v44 = v7 >> 2;
        if (v44 >> 61)
          goto LABEL_104;
        v45 = v31;
        v46 = (char *)operator new(8 * v44);
        v29 = &v46[8 * (v44 >> 2)];
        v30 = &v46[8 * v44];
        operator delete(v28);
        v5 = *(char **)(a1 + 24);
        v6 = *(char **)(a1 + 32);
        v28 = v46;
        v31 = v45;
      }
      else
      {
        v29 -= (4 * v27 + 4) & 0xFFFFFFFFFFFFFFF8;
      }
    }
    *(_QWORD *)v29 = v31;
    v47 = v29 + 8;
    if (v6 == v5)
    {
      v60 = v29;
      v48 = v29 + 8;
LABEL_75:
      v61 = *(void **)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v28;
      *(_QWORD *)(a1 + 24) = v60;
      v6 = v48;
      *(_QWORD *)(a1 + 32) = v48;
      *(_QWORD *)(a1 + 40) = v30;
      if (v61)
      {
        operator delete(v61);
        v6 = *(char **)(a1 + 32);
      }
      goto LABEL_36;
    }
    while (1)
    {
      if (v29 == v28)
      {
        if (v47 < v30)
        {
          v50 = (v30 - v47) >> 3;
          if (v50 >= -1)
            v51 = v50 + 1;
          else
            v51 = v50 + 2;
          v48 = &v47[8 * (v51 >> 1)];
          v49 = &v29[8 * (v51 >> 1)];
          if (v47 == v29)
            v29 = v47;
          else
            memmove(&v29[8 * (v51 >> 1)], v29, v47 - v29);
          goto LABEL_71;
        }
        if (v30 == v29)
          v52 = 1;
        else
          v52 = (v30 - v29) >> 2;
        if (v52 >> 61)
          goto LABEL_104;
        v53 = (char *)operator new(8 * v52);
        v28 = v53;
        v49 = &v53[(2 * v52 + 6) & 0xFFFFFFFFFFFFFFF8];
        v48 = v49;
        v54 = v47 - v29;
        if (v47 != v29)
        {
          v48 = &v49[v54 & 0xFFFFFFFFFFFFFFF8];
          v55 = 8 * (v54 >> 3);
          v56 = &v53[(2 * v52 + 6) & 0xFFFFFFFFFFFFFFF8];
          v57 = v29;
          do
          {
            v58 = *(_QWORD *)v57;
            v57 += 8;
            *(_QWORD *)v56 = v58;
            v56 += 8;
            v55 -= 8;
          }
          while (v55);
        }
        v30 = &v53[8 * v52];
        operator delete(v29);
      }
      else
      {
        v48 = v47;
        v49 = v29;
      }
      v29 = v28;
LABEL_71:
      v28 = v29;
      v59 = *((_QWORD *)v6 - 1);
      v6 -= 8;
      *((_QWORD *)v49 - 1) = v59;
      v60 = v49 - 8;
      v47 = v48;
      v29 = v60;
      if (v6 == *(char **)(a1 + 24))
        goto LABEL_75;
    }
  }
  v25 = operator new(0x1000uLL);
  v26 = v25;
  if (v23 == v6)
  {
    if (v5 == v24)
    {
      if (v6 == v5)
        v62 = 1;
      else
        v62 = (v23 - v5) >> 2;
      if (v62 >> 61)
        goto LABEL_104;
      v63 = (char *)operator new(8 * v62);
      v43 = &v63[(2 * v62 + 6) & 0xFFFFFFFFFFFFFFF8];
      v64 = v43;
      if (v6 != v5)
      {
        v64 = &v43[v7 & 0xFFFFFFFFFFFFFFF8];
        v65 = 8 * (v7 >> 3);
        v66 = &v63[(2 * v62 + 6) & 0xFFFFFFFFFFFFFFF8];
        v67 = v5;
        do
        {
          v68 = *(_QWORD *)v67;
          v67 += 8;
          *(_QWORD *)v66 = v68;
          v66 += 8;
          v65 -= 8;
        }
        while (v65);
      }
      *(_QWORD *)(a1 + 16) = v63;
      *(_QWORD *)(a1 + 24) = v43;
      *(_QWORD *)(a1 + 32) = v64;
      *(_QWORD *)(a1 + 40) = &v63[8 * v62];
      if (v5)
      {
        operator delete(v5);
        v43 = *(char **)(a1 + 24);
      }
    }
    else
    {
      v43 = v5;
    }
    *((_QWORD *)v43 - 1) = v26;
    v69 = *(char **)(a1 + 24);
    v70 = *(char **)(a1 + 32);
    *(_QWORD *)(a1 + 24) = v69 - 8;
    v71 = *((_QWORD *)v69 - 1);
    *(_QWORD *)(a1 + 24) = v69;
    if (v70 != *(char **)(a1 + 40))
    {
LABEL_103:
      *(_QWORD *)v70 = v71;
      goto LABEL_35;
    }
    v72 = *(char **)(a1 + 16);
    if (v69 > v72)
    {
      v73 = (v69 - v72) >> 3;
      if (v73 >= -1)
        v74 = v73 + 1;
      else
        v74 = v73 + 2;
      v75 = -(v74 >> 1);
      v76 = v74 >> 1;
      v77 = &v69[-8 * v76];
      v78 = v70 - v69;
      if (v78)
      {
        memmove(&v69[-8 * v76], v69, v78);
        v69 = *(char **)(a1 + 24);
      }
      v70 = &v77[v78];
      *(_QWORD *)(a1 + 24) = &v69[8 * v75];
      *(_QWORD *)(a1 + 32) = v70;
      goto LABEL_103;
    }
    if (v70 == v72)
      v79 = 1;
    else
      v79 = (v70 - v72) >> 2;
    if (!(v79 >> 61))
    {
      v80 = (char *)operator new(8 * v79);
      v81 = &v80[8 * (v79 >> 2)];
      v82 = v70 - v69;
      v35 = v70 == v69;
      v70 = v81;
      if (!v35)
      {
        v70 = &v81[v82 & 0xFFFFFFFFFFFFFFF8];
        v83 = 8 * (v82 >> 3);
        v84 = &v80[8 * (v79 >> 2)];
        do
        {
          v85 = *(_QWORD *)v69;
          v69 += 8;
          *(_QWORD *)v84 = v85;
          v84 += 8;
          v83 -= 8;
        }
        while (v83);
      }
      *(_QWORD *)(a1 + 16) = v80;
      *(_QWORD *)(a1 + 24) = v81;
      *(_QWORD *)(a1 + 32) = v70;
      *(_QWORD *)(a1 + 40) = &v80[8 * v79];
      if (v72)
      {
        operator delete(v72);
        v70 = *(char **)(a1 + 32);
      }
      goto LABEL_103;
    }
LABEL_104:
    sub_1C4764EE4();
  }
  *(_QWORD *)v6 = v25;
LABEL_35:
  v6 = (char *)(*(_QWORD *)(a1 + 32) + 8);
  *(_QWORD *)(a1 + 32) = v6;
LABEL_36:
  v5 = *(char **)(a1 + 24);
LABEL_37:
  if (v6 == v5)
  {
    v41 = 0;
  }
  else
  {
    v40 = *(_QWORD *)(a1 + 48) + *(_QWORD *)(a1 + 56);
    v41 = *(_QWORD *)&v5[(v40 >> 4) & 0xFFFFFFFFFFFFFF8] + 32 * (v40 & 0x7F);
  }
  v42 = *(_QWORD *)(a2 + 24);
  if (v42)
  {
    if (v42 == a2)
    {
      *(_QWORD *)(v41 + 24) = v41;
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a2 + 24) + 24))(*(_QWORD *)(a2 + 24), v41);
    }
    else
    {
      *(_QWORD *)(v41 + 24) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v42 + 16))(v42);
    }
  }
  else
  {
    *(_QWORD *)(v41 + 24) = 0;
  }
  ++*(_QWORD *)(a1 + 56);
  std::mutex::unlock(v4);
  std::condition_variable::notify_one((std::condition_variable *)(a1 + 128));
}

uint64_t sub_1C5E24FBC(uint64_t a1)
{
  std::__thread_specific_ptr<std::__thread_struct> *v2;
  const void *v3;
  uint64_t v4;
  unsigned int v5;
  unint64_t v6;
  unint64_t v7;
  pthread_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  pthread_t *v15;
  char *v16;
  std::thread *v17;
  std::thread *v18;
  _opaque_pthread_t *t;
  std::thread *v20;
  unsigned __int8 v21;
  uint64_t *v23;
  uint64_t v24;
  int v25;
  __int16 v26;
  unsigned int v27;

  v23 = (uint64_t *)a1;
  v2 = std::__thread_local_data();
  v3 = *(const void **)a1;
  *(_QWORD *)a1 = 0;
  pthread_setspecific(v2->__key_, v3);
  v4 = *(_QWORD *)(a1 + 8);
  if (*(_DWORD *)(a1 + 16) >= 2u)
  {
    v5 = 1;
    do
    {
      v24 = v4;
      v25 = *(_DWORD *)(a1 + 20);
      v26 = *(_WORD *)(a1 + 24);
      v27 = v5;
      v7 = *(_QWORD *)(v4 + 192);
      v6 = *(_QWORD *)(v4 + 200);
      if (v7 >= v6)
      {
        v9 = *(_QWORD *)(v4 + 184);
        v10 = (uint64_t)(v7 - v9) >> 3;
        if ((unint64_t)(v10 + 1) >> 61)
          abort();
        v11 = v6 - v9;
        v12 = v11 >> 2;
        if (v11 >> 2 <= (unint64_t)(v10 + 1))
          v12 = v10 + 1;
        if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
          v13 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v13 = v12;
        if (v13)
        {
          if (v13 >> 61)
            sub_1C4764EE4();
          v14 = (char *)operator new(8 * v13);
        }
        else
        {
          v14 = 0;
        }
        v15 = (pthread_t *)&v14[8 * v10];
        v16 = &v14[8 * v13];
        sub_1C5E25418(v15, (uint64_t)&v24);
        v8 = v15 + 1;
        v17 = *(std::thread **)(v4 + 184);
        v18 = *(std::thread **)(v4 + 192);
        if (v18 == v17)
        {
          *(_QWORD *)(v4 + 184) = v15;
          *(_QWORD *)(v4 + 192) = v8;
          *(_QWORD *)(v4 + 200) = v16;
        }
        else
        {
          do
          {
            t = v18[-1].__t_;
            --v18;
            *--v15 = t;
            v18->__t_ = 0;
          }
          while (v18 != v17);
          v18 = *(std::thread **)(v4 + 184);
          v20 = *(std::thread **)(v4 + 192);
          *(_QWORD *)(v4 + 184) = v15;
          *(_QWORD *)(v4 + 192) = v8;
          *(_QWORD *)(v4 + 200) = v16;
          while (v20 != v18)
            std::thread::~thread(v20 - 1);
        }
        if (v18)
          operator delete(v18);
      }
      else
      {
        sub_1C5E25418(*(pthread_t **)(v4 + 192), (uint64_t)&v24);
        v8 = (pthread_t *)(v7 + 8);
      }
      *(_QWORD *)(v4 + 192) = v8;
      v21 = atomic_load((unsigned __int8 *)(v4 + 8));
      if ((v21 & 1) != 0)
        break;
      ++v5;
    }
    while (v5 < *(_DWORD *)(a1 + 16));
  }
  std::promise<void>::set_value((std::promise<void> *)(v4 + 176));
  sub_1C5E251DC(v4);
  sub_1C5E25174(&v23);
  return 0;
}

uint64_t **sub_1C5E25174(uint64_t **a1)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    v3 = *v2;
    *v2 = 0;
    if (v3)
    {
      v4 = MEMORY[0x1CAA32CA8]();
      MEMORY[0x1CAA32FC0](v4, 0x20C4093837F09);
    }
    MEMORY[0x1CAA32FC0](v2, 0x1020C4059B2DB7BLL);
  }
  return a1;
}

void sub_1C5E251DC(uint64_t a1)
{
  std::mutex *v2;
  std::condition_variable *v3;
  unsigned __int8 v4;
  unsigned __int8 v5;
  unsigned __int8 v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void (**v19)(void);
  std::unique_lock<std::mutex> __lk;
  _QWORD v21[3];
  _QWORD *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v2 = (std::mutex *)(a1 + 64);
  v3 = (std::condition_variable *)(a1 + 128);
  do
  {
    __lk.__m_ = v2;
    __lk.__owns_ = 1;
    std::mutex::lock(v2);
    v4 = atomic_load((unsigned __int8 *)(a1 + 8));
    if ((v4 & 1) == 0)
    {
      do
      {
        if (*(_QWORD *)(a1 + 56))
          break;
        std::condition_variable::wait(v3, &__lk);
        v5 = atomic_load((unsigned __int8 *)(a1 + 8));
      }
      while ((v5 & 1) == 0);
    }
    v6 = atomic_load((unsigned __int8 *)(a1 + 8));
    if ((v6 & 1) != 0)
      goto LABEL_28;
    v7 = *(_QWORD *)(a1 + 56) + *(_QWORD *)(a1 + 48) - 1;
    v8 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + ((v7 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v7 & 0x7F);
    v9 = *(_QWORD *)(v8 + 24);
    if (v9)
    {
      if (v9 == v8)
      {
        v22 = v21;
        (*(void (**)(_QWORD, _QWORD *))(**(_QWORD **)(v8 + 24) + 24))(*(_QWORD *)(v8 + 24), v21);
      }
      else
      {
        v22 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 16))(v9);
      }
    }
    else
    {
      v22 = 0;
    }
    v11 = *(_QWORD *)(a1 + 48);
    v10 = *(_QWORD *)(a1 + 56);
    v12 = v10 - 1;
    v13 = *(_QWORD *)(a1 + 24);
    v14 = *(_QWORD *)(v13 + (((unint64_t)(v10 - 1 + v11) >> 4) & 0xFFFFFFFFFFFFFF8))
        + 32 * ((v10 - 1 + v11) & 0x7F);
    v15 = *(_QWORD **)(v14 + 24);
    if (v15 == (_QWORD *)v14)
    {
      v15 = (_QWORD *)(*(_QWORD *)(v13 + (((unint64_t)(v10 - 1 + v11) >> 4) & 0xFFFFFFFFFFFFFF8))
                     + 32 * ((v10 - 1 + v11) & 0x7F));
      v16 = 4;
      goto LABEL_15;
    }
    if (v15)
    {
      v16 = 5;
LABEL_15:
      (*(void (**)(void))(*v15 + 8 * v16))();
      v13 = *(_QWORD *)(a1 + 24);
      v11 = *(_QWORD *)(a1 + 48);
      v10 = *(_QWORD *)(a1 + 56);
      v12 = v10 - 1;
    }
    v17 = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a1 + 56) = v12;
    if (v17 == v13)
      v18 = 0;
    else
      v18 = 16 * (v17 - v13) - 1;
    if ((unint64_t)(v18 - (v11 + v10) - 255) <= 0xFFFFFFFFFFFFFEFFLL)
    {
      operator delete(*(void **)(v17 - 8));
      *(_QWORD *)(a1 + 32) -= 8;
    }
    if (!__lk.__owns_)
    {
      std::__throw_system_error(1, "unique_lock::unlock: not locked");
LABEL_33:
      sub_1C485C2F0();
    }
    std::mutex::unlock(__lk.__m_);
    __lk.__owns_ = 0;
    if (!v22)
      goto LABEL_33;
    (*(void (**)(_QWORD *))(*v22 + 48))(v22);
    if (v22 == v21)
    {
      v19 = (void (**)(void))(v21[0] + 32);
    }
    else
    {
      if (!v22)
        goto LABEL_28;
      v19 = (void (**)(void))(*v22 + 40);
    }
    (*v19)();
LABEL_28:
    if (__lk.__owns_)
      std::mutex::unlock(__lk.__m_);
  }
  while ((v6 & 1) == 0);
}

uint64_t **sub_1C5E25418(pthread_t *a1, uint64_t a2)
{
  std::__thread_struct *v4;
  char *v5;
  int v6;
  uint64_t *v8;
  uint64_t *v9;

  v4 = (std::__thread_struct *)operator new();
  std::__thread_struct::__thread_struct(v4);
  v5 = (char *)operator new();
  *(_QWORD *)v5 = v4;
  *(_OWORD *)(v5 + 8) = *(_OWORD *)a2;
  *((_QWORD *)v5 + 3) = *(_QWORD *)(a2 + 16);
  v6 = pthread_create(a1, 0, (void *(__cdecl *)(void *))sub_1C5E254C8, v5);
  if (v6)
  {
    std::__throw_system_error(v6, "thread constructor failed");
    return (uint64_t **)sub_1C5E254C8(v8);
  }
  else
  {
    v9 = 0;
    return sub_1C5E25518(&v9);
  }
}

uint64_t sub_1C5E254C8(uint64_t *a1)
{
  std::__thread_specific_ptr<std::__thread_struct> *v2;
  const void *v3;
  uint64_t *v5;

  v5 = a1;
  v2 = std::__thread_local_data();
  v3 = (const void *)*a1;
  *a1 = 0;
  pthread_setspecific(v2->__key_, v3);
  sub_1C5E251DC(a1[1]);
  sub_1C5E25518(&v5);
  return 0;
}

uint64_t **sub_1C5E25518(uint64_t **a1)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    v3 = *v2;
    *v2 = 0;
    if (v3)
    {
      v4 = MEMORY[0x1CAA32CA8]();
      MEMORY[0x1CAA32FC0](v4, 0x20C4093837F09);
    }
    MEMORY[0x1CAA32FC0](v2, 0x1020C40A82BEB12);
  }
  return a1;
}

void sub_1C5E25580(uint64_t a1)
{
  std::mutex *v2;
  unsigned __int8 v3;
  std::future<void> v4;

  v2 = (std::mutex *)(a1 + 64);
  std::mutex::lock((std::mutex *)(a1 + 64));
  v3 = atomic_load((unsigned __int8 *)(a1 + 8));
  if ((v3 & 1) != 0)
  {
    std::mutex::unlock(v2);
  }
  else
  {
    atomic_store(1u, (unsigned __int8 *)(a1 + 8));
    std::mutex::unlock(v2);
    std::condition_variable::notify_all((std::condition_variable *)(a1 + 128));
    std::promise<void>::get_future((std::promise<void> *)(a1 + 176));
    std::__assoc_sub_state::wait(v4.__state_);
    std::future<void>::~future(&v4);
  }
}

_QWORD *sub_1C5E25604(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = &off_1E81A1A40;
  v2 = a1 + 1;
  v3 = (_QWORD *)a1[4];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

void sub_1C5E25660(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;

  *a1 = &off_1E81A1A40;
  v1 = a1 + 1;
  v2 = (_QWORD *)a1[4];
  if (v2 == v1)
  {
    v3 = 4;
    v2 = v1;
  }
  else
  {
    if (!v2)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C5E256CC(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = operator new(0x30uLL);
  *v2 = &off_1E81A1A40;
  v3 = v2 + 1;
  v4 = *(_QWORD *)(a1 + 32);
  if (v4)
  {
    if (v4 == a1 + 8)
    {
      v2[4] = v3;
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
    }
    else
    {
      v2[4] = (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v4 + 16))(v4, v3);
    }
  }
  else
  {
    v2[4] = 0;
  }
  v2[5] = *(_QWORD *)(a1 + 40);
  return v2;
}

uint64_t sub_1C5E25750(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;
  uint64_t result;

  *a2 = &off_1E81A1A40;
  v4 = a2 + 1;
  result = *(_QWORD *)(a1 + 32);
  if (result)
  {
    if (result == a1 + 8)
    {
      a2[4] = v4;
      result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 24))(*(_QWORD *)(a1 + 32));
    }
    else
    {
      result = (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)result + 16))(result, v4);
      a2[4] = result;
    }
  }
  else
  {
    a2[4] = 0;
  }
  a2[5] = *(_QWORD *)(a1 + 40);
  return result;
}

_QWORD *sub_1C5E257C8(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 8);
  result = *(_QWORD **)(a1 + 32);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void sub_1C5E257FC(char *__p)
{
  char *v2;
  char *v3;
  uint64_t v4;

  v2 = __p + 8;
  v3 = (char *)*((_QWORD *)__p + 4);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  operator delete(__p);
}

void sub_1C5E2584C(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  if (!v2)
  {
    sub_1C485C2F0();
    JUMPOUT(0x1C5E258ACLL);
  }
  v3 = *(_QWORD *)(a1 + 40);
  (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
  std::mutex::lock((std::mutex *)(v3 + 8));
  if ((*(_DWORD *)v3)-- == 1)
    std::condition_variable::notify_all((std::condition_variable *)(v3 + 72));
  std::mutex::unlock((std::mutex *)(v3 + 8));
}

void sub_1C5E258B0()
{
  JUMPOUT(0x1CAA32FC0);
}

__n128 sub_1C5E258C4(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &unk_1E81A1A88;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 sub_1C5E25904(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &unk_1E81A1A88;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1C5E2592C(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(_QWORD *)(result + 24);
  if (v1)
  {
    v2 = result;
    v3 = *(_QWORD *)(result + 16);
    do
    {
      result = (**(uint64_t (***)(_QWORD, uint64_t))(v2 + 8))(*(_QWORD *)(*(_QWORD *)(v2 + 8) + 8), v3++);
      --v1;
    }
    while (v1);
  }
  return result;
}

void llvm::PluginLoader::operator=(uint64_t a1, uint64_t a2)
{
  std::recursive_mutex *v4;
  const char *v5;
  llvm *PermanentLibrary;
  uint64_t v8;
  unint64_t v9;
  __int128 v10;
  llvm::raw_ostream *v11;
  void *v12;
  char v13;
  BOOL v14;
  const char *v15;
  size_t v16;
  size_t v17;
  llvm::raw_ostream *v18;
  uint64_t v19;
  const char *p_p;
  size_t v21;
  llvm::raw_ostream *v22;
  void *v23;
  unint64_t v24;
  void *__p;
  size_t v26;
  uint64_t v27;

  if (!atomic_load(qword_1ED825CC0))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED825CC0, (void *(*)(void))sub_1C6246890, (void (*)(void *))sub_1C62468D0);
  v4 = (std::recursive_mutex *)qword_1ED825CC0[0];
  std::recursive_mutex::lock((std::recursive_mutex *)qword_1ED825CC0[0]);
  __p = 0;
  v26 = 0;
  v27 = 0;
  if (*(char *)(a2 + 23) >= 0)
    v5 = (const char *)a2;
  else
    v5 = *(const char **)a2;
  PermanentLibrary = (llvm *)llvm::sys::DynamicLibrary::getPermanentLibrary(v5, (uint64_t)&__p);
  if (PermanentLibrary == (llvm *)&llvm::sys::DynamicLibrary::Invalid)
  {
    v11 = (llvm::raw_ostream *)llvm::errs(PermanentLibrary);
    v12 = (void *)*((_QWORD *)v11 + 4);
    if (*((_QWORD *)v11 + 3) - (_QWORD)v12 > 0xEuLL)
    {
      qmemcpy(v12, "Error opening '", 15);
      *((_QWORD *)v11 + 4) += 15;
    }
    else
    {
      v11 = llvm::raw_ostream::write(v11, "Error opening '", 0xFuLL);
    }
    v13 = *(_BYTE *)(a2 + 23);
    v14 = v13 < 0;
    if (v13 >= 0)
      v15 = (const char *)a2;
    else
      v15 = *(const char **)a2;
    v16 = v13 & 0x7F;
    if (v14)
      v17 = *(_QWORD *)(a2 + 8);
    else
      v17 = v16;
    v18 = llvm::raw_ostream::write(v11, v15, v17);
    v19 = *((_QWORD *)v18 + 4);
    if ((unint64_t)(*((_QWORD *)v18 + 3) - v19) > 2)
    {
      *(_BYTE *)(v19 + 2) = 32;
      *(_WORD *)v19 = 14887;
      *((_QWORD *)v18 + 4) += 3;
    }
    else
    {
      v18 = llvm::raw_ostream::write(v18, "': ", 3uLL);
    }
    if (v27 >= 0)
      p_p = (const char *)&__p;
    else
      p_p = (const char *)__p;
    if (v27 >= 0)
      v21 = HIBYTE(v27) & 0x7F;
    else
      v21 = v26;
    v22 = llvm::raw_ostream::write(v18, p_p, v21);
    v23 = (void *)*((_QWORD *)v22 + 4);
    if (*((_QWORD *)v22 + 3) - (_QWORD)v23 > 0x19uLL)
    {
      qmemcpy(v23, "\n  -load request ignored.\n", 26);
      *((_QWORD *)v22 + 4) += 26;
    }
    else
    {
      llvm::raw_ostream::write(v22, "\n  -load request ignored.\n", 0x1AuLL);
    }
  }
  else
  {
    if (!atomic_load(qword_1ED825CD8))
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED825CD8, (void *(*)(void))sub_1C5DEBCE0, (void (*)(void *))sub_1C5DEBD10);
    v8 = qword_1ED825CD8[0];
    v9 = *(_QWORD *)(qword_1ED825CD8[0] + 8);
    if (v9 >= *(_QWORD *)(qword_1ED825CD8[0] + 16))
    {
      v24 = sub_1C4D9AEFC((unint64_t *)qword_1ED825CD8[0], a2);
    }
    else
    {
      if (*(char *)(a2 + 23) < 0)
      {
        sub_1C47EBC30(*(_BYTE **)(qword_1ED825CD8[0] + 8), *(void **)a2, *(_QWORD *)(a2 + 8));
      }
      else
      {
        v10 = *(_OWORD *)a2;
        *(_QWORD *)(v9 + 16) = *(_QWORD *)(a2 + 16);
        *(_OWORD *)v9 = v10;
      }
      v24 = v9 + 24;
    }
    *(_QWORD *)(v8 + 8) = v24;
  }
  if (SHIBYTE(v27) < 0)
    operator delete(__p);
  std::recursive_mutex::unlock(v4);
}

uint64_t llvm::PluginLoader::getNumPlugins(llvm::PluginLoader *this)
{
  std::recursive_mutex *v2;
  uint64_t v5;

  if (!atomic_load(qword_1ED825CC0))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED825CC0, (void *(*)(void))sub_1C6246890, (void (*)(void *))sub_1C62468D0);
  v2 = (std::recursive_mutex *)qword_1ED825CC0[0];
  std::recursive_mutex::lock((std::recursive_mutex *)qword_1ED825CC0[0]);
  if (atomic_load(qword_1ED825CD8))
  {
    if (!atomic_load(qword_1ED825CD8))
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED825CD8, (void *(*)(void))sub_1C5DEBCE0, (void (*)(void *))sub_1C5DEBD10);
    v5 = -1431655765 * ((*(_QWORD *)(qword_1ED825CD8[0] + 8) - *(_QWORD *)qword_1ED825CD8[0]) >> 3);
  }
  else
  {
    v5 = 0;
  }
  std::recursive_mutex::unlock(v2);
  return v5;
}

uint64_t llvm::PluginLoader::getPlugin(llvm::PluginLoader *this)
{
  unsigned int v1;
  std::recursive_mutex *v3;
  uint64_t v5;

  v1 = this;
  if (!atomic_load(qword_1ED825CC0))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED825CC0, (void *(*)(void))sub_1C6246890, (void (*)(void *))sub_1C62468D0);
  v3 = (std::recursive_mutex *)qword_1ED825CC0[0];
  std::recursive_mutex::lock((std::recursive_mutex *)qword_1ED825CC0[0]);
  if (!atomic_load(qword_1ED825CD8))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED825CD8, (void *(*)(void))sub_1C5DEBCE0, (void (*)(void *))sub_1C5DEBD10);
  v5 = *(_QWORD *)qword_1ED825CD8[0];
  std::recursive_mutex::unlock(v3);
  return v5 + 24 * v1;
}

_BYTE *llvm::MappedPrefix::getFromJoined@<X0>(_BYTE *result@<X0>, size_t a2@<X1>, uint64_t a3@<X8>)
{
  _BYTE *v5;
  size_t v6;
  size_t v7;
  size_t v8;
  __int128 v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;

  if (a2 && (v5 = result, (result = memchr(result, 61, a2)) != 0) && (v6 = result - v5, result - v5 != -1))
  {
    if (a2 >= v6)
      v7 = result - v5;
    else
      v7 = a2;
    if (a2 >= v6 + 1)
      v8 = v6 + 1;
    else
      v8 = a2;
    result = sub_1C5E26F9C(&v9, v5, v7, &v5[v8], a2 - v8);
    *(_OWORD *)a3 = v9;
    *(_QWORD *)(a3 + 16) = v10;
    *(_OWORD *)(a3 + 24) = v11;
    *(_QWORD *)(a3 + 40) = v12;
    *(_BYTE *)(a3 + 48) = 1;
  }
  else
  {
    *(_BYTE *)a3 = 0;
    *(_BYTE *)(a3 + 48) = 0;
  }
  return result;
}

void llvm::MappedPrefix::transformJoined(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t *v6;
  unint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  size_t v10;
  unint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  __int128 v15;
  _BYTE *v16;
  __int128 v17;
  char v18;
  uint64_t v19[2];
  char v20;
  void *v21[2];
  char v22;
  void *__p;
  char v24;
  char v25;

  if (a2)
  {
    v6 = a1;
    v7 = *(unsigned int *)(a3 + 8);
    v8 = &a1[2 * a2];
    while (1)
    {
      v9 = *v6;
      v10 = v6[1];
      llvm::MappedPrefix::getFromJoined((_BYTE *)*v6, v10, (uint64_t)v21);
      if (!v25)
        break;
      v11 = sub_1C5E270D8(a3, (unint64_t)v21);
      v12 = *(_QWORD *)a3;
      v13 = *(_DWORD *)(a3 + 8);
      v14 = *(_QWORD *)a3 + 48 * v13;
      if (*(char *)(v11 + 23) < 0)
      {
        sub_1C47EBC30((_BYTE *)v14, *(void **)v11, *(_QWORD *)(v11 + 8));
      }
      else
      {
        v15 = *(_OWORD *)v11;
        *(_QWORD *)(v14 + 16) = *(_QWORD *)(v11 + 16);
        *(_OWORD *)v14 = v15;
      }
      v16 = (_BYTE *)(v12 + 48 * v13 + 24);
      if (*(char *)(v11 + 47) < 0)
      {
        sub_1C47EBC30(v16, *(void **)(v11 + 24), *(_QWORD *)(v11 + 32));
      }
      else
      {
        v17 = *(_OWORD *)(v11 + 24);
        *(_QWORD *)(v12 + 48 * v13 + 40) = *(_QWORD *)(v11 + 40);
        *(_OWORD *)v16 = v17;
      }
      ++*(_DWORD *)(a3 + 8);
      if (v25)
      {
        if (v24 < 0)
          operator delete(__p);
        if (v22 < 0)
          operator delete(v21[0]);
      }
      v6 += 2;
      if (v6 == v8)
        goto LABEL_16;
    }
    sub_1C5E2726C(a3, v7);
    v19[0] = v9;
    v19[1] = v10;
    v18 = 1;
  }
  else
  {
LABEL_16:
    v18 = 0;
    LOBYTE(v19[0]) = 0;
  }
  v20 = v18;
  sub_1C5E25F28(a4, v19);
}

void sub_1C5E25F28(_QWORD *a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void **v7;
  uint64_t *v8;
  _QWORD v9[4];
  __int16 v10;
  _QWORD v11[4];
  __int16 v12;
  void *v13[2];
  char v14;
  void **v15;
  uint64_t v16[2];

  if (*((_BYTE *)a2 + 16))
  {
    if (!atomic_load(qword_1ED836B58))
    {
      v8 = a2;
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED836B58, (void *(*)(void))sub_1C5DF15F0, (void (*)(void *))sub_1C5DF1624);
      a2 = v8;
    }
    v4 = qword_1ED836B58[0];
    v10 = 1283;
    v5 = *a2;
    v6 = a2[1];
    v9[0] = "invalid prefix map: '";
    v9[2] = v5;
    v9[3] = v6;
    v11[0] = v9;
    v11[2] = "'";
    v12 = 770;
    llvm::Twine::str((llvm::Twine *)v11, v13);
    if (v14 >= 0)
      v7 = v13;
    else
      v7 = (void **)v13[0];
    v16[0] = 3;
    v16[1] = v4;
    v15 = v7;
    sub_1C5DF1730((_BYTE **)&v15, v16, a1);
    if (v14 < 0)
      operator delete(v13[0]);
  }
  else
  {
    *a1 = 0;
  }
}

void llvm::MappedPrefix::transformJoined(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  unint64_t v7;
  uint64_t v8;
  char v9;
  BOOL v10;
  _BYTE *v11;
  uint64_t v12;
  size_t v13;
  unint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  __int128 v18;
  _BYTE *v19;
  __int128 v20;
  char v21;
  uint64_t v22[2];
  char v23;
  void *v24[2];
  char v25;
  void *__p;
  char v27;
  char v28;

  if (a2)
  {
    v7 = *(unsigned int *)(a3 + 8);
    v8 = 24 * a2;
    while (1)
    {
      v9 = *(_BYTE *)(a1 + 23);
      v10 = v9 < 0;
      v11 = v9 >= 0 ? (_BYTE *)a1 : *(_BYTE **)a1;
      v12 = v9 & 0x7F;
      v13 = v10 ? *(_QWORD *)(a1 + 8) : v12;
      llvm::MappedPrefix::getFromJoined(v11, v13, (uint64_t)v24);
      if (!v28)
        break;
      v14 = sub_1C5E270D8(a3, (unint64_t)v24);
      v15 = *(_QWORD *)a3;
      v16 = *(_DWORD *)(a3 + 8);
      v17 = *(_QWORD *)a3 + 48 * v16;
      if (*(char *)(v14 + 23) < 0)
      {
        sub_1C47EBC30((_BYTE *)v17, *(void **)v14, *(_QWORD *)(v14 + 8));
      }
      else
      {
        v18 = *(_OWORD *)v14;
        *(_QWORD *)(v17 + 16) = *(_QWORD *)(v14 + 16);
        *(_OWORD *)v17 = v18;
      }
      v19 = (_BYTE *)(v15 + 48 * v16 + 24);
      if (*(char *)(v14 + 47) < 0)
      {
        sub_1C47EBC30(v19, *(void **)(v14 + 24), *(_QWORD *)(v14 + 32));
      }
      else
      {
        v20 = *(_OWORD *)(v14 + 24);
        *(_QWORD *)(v15 + 48 * v16 + 40) = *(_QWORD *)(v14 + 40);
        *(_OWORD *)v19 = v20;
      }
      ++*(_DWORD *)(a3 + 8);
      if (v28)
      {
        if (v27 < 0)
          operator delete(__p);
        if (v25 < 0)
          operator delete(v24[0]);
      }
      a1 += 24;
      v8 -= 24;
      if (!v8)
        goto LABEL_22;
    }
    sub_1C5E2726C(a3, v7);
    v22[0] = (uint64_t)v11;
    v22[1] = v13;
    v21 = 1;
  }
  else
  {
LABEL_22:
    v21 = 0;
    LOBYTE(v22[0]) = 0;
  }
  v23 = v21;
  sub_1C5E25F28(a4, v22);
}

void llvm::MappedPrefix::transformJoinedIfValid(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  __int128 v10;
  _BYTE *v11;
  __int128 v12;
  void *v13[2];
  char v14;
  void *__p;
  char v16;
  char v17;

  if (a2)
  {
    v4 = a1;
    v5 = a1 + 16 * a2;
    do
    {
      llvm::MappedPrefix::getFromJoined(*(_BYTE **)v4, *(_QWORD *)(v4 + 8), (uint64_t)v13);
      if (v17)
      {
        v6 = sub_1C5E270D8(a3, (unint64_t)v13);
        v7 = *(_QWORD *)a3;
        v8 = *(_DWORD *)(a3 + 8);
        v9 = *(_QWORD *)a3 + 48 * v8;
        if (*(char *)(v6 + 23) < 0)
        {
          sub_1C47EBC30((_BYTE *)v9, *(void **)v6, *(_QWORD *)(v6 + 8));
        }
        else
        {
          v10 = *(_OWORD *)v6;
          *(_QWORD *)(v9 + 16) = *(_QWORD *)(v6 + 16);
          *(_OWORD *)v9 = v10;
        }
        v11 = (_BYTE *)(v7 + 48 * v8 + 24);
        if (*(char *)(v6 + 47) < 0)
        {
          sub_1C47EBC30(v11, *(void **)(v6 + 24), *(_QWORD *)(v6 + 32));
        }
        else
        {
          v12 = *(_OWORD *)(v6 + 24);
          *(_QWORD *)(v7 + 48 * v8 + 40) = *(_QWORD *)(v6 + 40);
          *(_OWORD *)v11 = v12;
        }
        ++*(_DWORD *)(a3 + 8);
        if (v17)
        {
          if (v16 < 0)
            operator delete(__p);
          if (v14 < 0)
            operator delete(v13[0]);
        }
      }
      v4 += 16;
    }
    while (v4 != v5);
  }
}

{
  uint64_t v5;
  char v6;
  BOOL v7;
  _BYTE *v8;
  size_t v9;
  size_t v10;
  unint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  __int128 v15;
  _BYTE *v16;
  __int128 v17;
  void *v18[2];
  char v19;
  void *__p;
  char v21;
  char v22;

  if (a2)
  {
    v5 = 24 * a2;
    do
    {
      v6 = *(_BYTE *)(a1 + 23);
      v7 = v6 < 0;
      if (v6 >= 0)
        v8 = (_BYTE *)a1;
      else
        v8 = *(_BYTE **)a1;
      v9 = v6 & 0x7F;
      if (v7)
        v10 = *(_QWORD *)(a1 + 8);
      else
        v10 = v9;
      llvm::MappedPrefix::getFromJoined(v8, v10, (uint64_t)v18);
      if (v22)
      {
        v11 = sub_1C5E270D8(a3, (unint64_t)v18);
        v12 = *(_QWORD *)a3;
        v13 = *(_DWORD *)(a3 + 8);
        v14 = *(_QWORD *)a3 + 48 * v13;
        if (*(char *)(v11 + 23) < 0)
        {
          sub_1C47EBC30((_BYTE *)v14, *(void **)v11, *(_QWORD *)(v11 + 8));
        }
        else
        {
          v15 = *(_OWORD *)v11;
          *(_QWORD *)(v14 + 16) = *(_QWORD *)(v11 + 16);
          *(_OWORD *)v14 = v15;
        }
        v16 = (_BYTE *)(v12 + 48 * v13 + 24);
        if (*(char *)(v11 + 47) < 0)
        {
          sub_1C47EBC30(v16, *(void **)(v11 + 24), *(_QWORD *)(v11 + 32));
        }
        else
        {
          v17 = *(_OWORD *)(v11 + 24);
          *(_QWORD *)(v12 + 48 * v13 + 40) = *(_QWORD *)(v11 + 40);
          *(_OWORD *)v16 = v17;
        }
        ++*(_DWORD *)(a3 + 8);
        if (v22)
        {
          if (v21 < 0)
            operator delete(__p);
          if (v19 < 0)
            operator delete(v18[0]);
        }
      }
      a1 += 24;
      v5 -= 24;
    }
    while (v5);
  }
}

void llvm::PrefixMapper::mapImpl(unsigned __int8 *__s1@<X1>, uint64_t a2@<X0>, size_t a3@<X2>, uint64_t *a4@<X3>, uint64_t a5@<X8>)
{
  unsigned int v6;
  uint64_t v10;
  uint64_t v11;
  const llvm::Twine *v12;
  char v13;
  BOOL v14;
  _BYTE *v15;
  uint64_t v16;
  size_t v17;
  unsigned __int8 *v18;
  size_t i;
  int v20;
  int v21;
  char v22;
  int v23;
  _BOOL4 v25;
  int v26;
  char v27;
  _BOOL4 v28;
  int v29;
  _BOOL4 v31;
  char v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char v36;
  int v37;
  uint64_t v38;
  unsigned __int8 *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  void **v49;
  __int16 v50;
  _QWORD *v51;
  __int16 v52;
  _QWORD *v53;
  __int16 v54;
  _QWORD *v55[4];
  __int16 v56;

  v6 = *(_DWORD *)(a2 + 24);
  if (!v6)
  {
LABEL_52:
    v32 = 0;
    *(_BYTE *)(a5 + 24) &= ~1u;
    *(_BYTE *)a5 = 0;
    goto LABEL_66;
  }
  v10 = *(_QWORD *)(a2 + 16);
  v11 = v10 + 48 * v6;
  v12 = (const llvm::Twine *)*(unsigned int *)(a2 + 8);
  while (1)
  {
    v13 = *(_BYTE *)(v10 + 23);
    v14 = v13 < 0;
    v15 = v13 >= 0 ? (_BYTE *)v10 : *(_BYTE **)v10;
    v16 = v13 & 0x7F;
    v17 = v14 ? *(_QWORD *)(v10 + 8) : v16;
    if (v12 > 1)
    {
      if (a3 < v17)
        goto LABEL_51;
      if (v17)
      {
        v18 = __s1;
        for (i = v17; i; --i)
        {
          v21 = *v18++;
          v20 = v21;
          LOBYTE(v21) = *v15++;
          v22 = v21;
          v23 = v21;
          if (v21 == 47)
          {
            if (v20 != 47 && v20 != 92)
              goto LABEL_51;
          }
          else
          {
            v25 = v20 == 47 || v20 == 92;
            if (v25 != (v23 == 92))
              v26 = 1;
            else
              v26 = 4;
            if (v23 != 92)
            {
              if ((v20 - 65) >= 0x1A)
                v27 = v20;
              else
                v27 = v20 + 32;
              if ((v22 - 65) < 0x1Au)
                v22 += 32;
              v28 = v27 != v22;
              if (v20 == 92)
                v28 = v26;
              if (v20 != 47)
                v26 = v28;
            }
            if ((v26 | 4) != 4)
              goto LABEL_51;
          }
        }
      }
    }
    else if (a3 < v17 || v17 && memcmp(__s1, v15, v17))
    {
      goto LABEL_51;
    }
    if (a3 <= v17)
      break;
    v29 = __s1[v17];
    v31 = v12 > 1 && v29 == 92;
    if (v29 == 47 || v31)
    {
      v39 = &__s1[v17];
      v42 = *(_QWORD *)(v10 + 24);
      v41 = v10 + 24;
      v40 = v42;
      v43 = *(_BYTE *)(v41 + 23);
      v44 = *(_QWORD *)(v41 + 8);
      if (v43 >= 0)
      {
        v45 = v43 & 0x7F;
      }
      else
      {
        v41 = v40;
        v45 = v44;
      }
      a4[1] = 0;
      if (a4[2] < v45)
      {
        llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a4, a4 + 3, v45, 1);
        v46 = a4[1];
LABEL_63:
        memcpy((void *)(*a4 + v46), (const void *)v41, v45);
        v47 = a4[1];
        v12 = (const llvm::Twine *)*(unsigned int *)(a2 + 8);
      }
      else
      {
        v46 = 0;
        v47 = 0;
        if (v45)
          goto LABEL_63;
      }
      a4[1] = v47 + v45;
      v56 = 261;
      v55[0] = v39 + 1;
      v55[1] = (_QWORD *)(a3 + ~v17);
      v54 = 257;
      v52 = 257;
      v50 = 257;
      llvm::sys::path::append(a4, v12, v55, &v53, &v51, &v49);
      v33 = *a4;
      v38 = a4[1];
      goto LABEL_65;
    }
LABEL_51:
    v10 += 48;
    if (v10 == v11)
      goto LABEL_52;
  }
  v35 = *(_QWORD *)(v10 + 24);
  v34 = v10 + 24;
  v33 = v35;
  v36 = *(_BYTE *)(v34 + 23);
  v37 = v36;
  if (v36 >= 0)
    v33 = v34;
  v38 = v36 & 0x7F;
  if (v37 < 0)
    v38 = *(_QWORD *)(v34 + 8);
LABEL_65:
  *(_BYTE *)(a5 + 24) &= ~1u;
  *(_QWORD *)a5 = v33;
  *(_QWORD *)(a5 + 8) = v38;
  v32 = 1;
LABEL_66:
  *(_BYTE *)(a5 + 16) = v32;
}

_QWORD *llvm::PrefixMapper::map@<X0>(uint64_t a1@<X0>, const void *a2@<X1>, unint64_t a3@<X2>, _QWORD *a4@<X3>, _QWORD *a5@<X8>)
{
  _QWORD *result;
  unint64_t v10;
  const void *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD v15[2];
  unsigned __int8 v16;
  char v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  a4[1] = 0;
  result = (*(_QWORD *(**)(_QWORD *__return_ptr))(*(_QWORD *)a1 + 16))(v15);
  if ((v17 & 1) != 0)
  {
    v11 = (const void *)v15[0];
    *a5 = v15[0];
    if (v11)
      return result;
    v12 = 0;
  }
  else
  {
    v11 = (const void *)v15[0];
    v10 = v15[1];
    v12 = v16;
  }
  if (!a4[1])
  {
    if (v12)
    {
      a3 = v10;
      a2 = v11;
    }
    a4[1] = 0;
    if (a4[2] < a3)
    {
      llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a4, a4 + 3, a3, 1);
      v13 = a4[1];
    }
    else
    {
      v13 = 0;
      v14 = 0;
      if (!a3)
      {
LABEL_11:
        a4[1] = v14 + a3;
        goto LABEL_12;
      }
    }
    result = memcpy((void *)(*a4 + v13), a2, a3);
    v14 = a4[1];
    goto LABEL_11;
  }
LABEL_12:
  *a5 = 0;
  return result;
}

void llvm::PrefixMapper::map(uint64_t a1@<X0>, const void *a2@<X1>, size_t a3@<X2>, uint64_t a4@<X3>, _QWORD *a5@<X8>)
{
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  char v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  llvm::PrefixMapper::mapToString(a1, a2, a3, (uint64_t)&v8);
  if ((v10 & 1) != 0)
  {
    v7 = v8;
  }
  else
  {
    if (*(char *)(a4 + 23) < 0)
      operator delete(*(void **)a4);
    v7 = 0;
    *(_OWORD *)a4 = v8;
    *(_QWORD *)(a4 + 16) = v9;
  }
  *a5 = v7;
}

void llvm::PrefixMapper::mapToString(uint64_t a1@<X0>, const void *a2@<X1>, size_t a3@<X2>, uint64_t a4@<X8>)
{
  const void *v7;
  size_t v8;
  void *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  size_t v13;
  size_t v14;
  size_t __len[2];
  unint64_t v16;
  char v17;
  void *v18;
  __int128 v19;
  _QWORD v20[33];

  v20[32] = *MEMORY[0x1E0C80C00];
  v18 = v20;
  v19 = xmmword_1C64638F0;
  (*(void (**)(size_t *__return_ptr))(*(_QWORD *)a1 + 16))(__len);
  v7 = (const void *)__len[0];
  if ((v17 & 1) != 0)
  {
    if (__len[0])
    {
      *(_BYTE *)(a4 + 24) |= 1u;
      *(_QWORD *)a4 = v7;
      goto LABEL_27;
    }
  }
  else if ((_BYTE)v16)
  {
    if (__len[0])
    {
      v8 = __len[1];
      if (__len[1] <= 0x7FFFFFFFFFFFFFF7)
      {
        if (__len[1] >= 0x17)
        {
          v13 = (__len[1] & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((__len[1] | 7) != 0x17)
            v13 = __len[1] | 7;
          v14 = v13 + 1;
          v9 = operator new(v13 + 1);
          __len[1] = v8;
          v16 = v14 | 0x8000000000000000;
          __len[0] = (size_t)v9;
        }
        else
        {
          HIBYTE(v16) = __len[1];
          v9 = __len;
          if (!__len[1])
            goto LABEL_25;
        }
        memmove(v9, v7, v8);
LABEL_25:
        *((_BYTE *)v9 + v8) = 0;
        goto LABEL_26;
      }
LABEL_30:
      abort();
    }
    goto LABEL_15;
  }
  if (a2)
  {
    if (a3 > 0x7FFFFFFFFFFFFFF7)
      goto LABEL_30;
    if (a3 >= 0x17)
    {
      v11 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((a3 | 7) != 0x17)
        v11 = a3 | 7;
      v12 = v11 + 1;
      v10 = operator new(v11 + 1);
      __len[1] = a3;
      v16 = v12 | 0x8000000000000000;
      __len[0] = (size_t)v10;
    }
    else
    {
      HIBYTE(v16) = a3;
      v10 = __len;
      if (!a3)
        goto LABEL_20;
    }
    memmove(v10, a2, a3);
LABEL_20:
    *((_BYTE *)v10 + a3) = 0;
    goto LABEL_26;
  }
LABEL_15:
  __len[0] = 0;
  __len[1] = 0;
  v16 = 0;
LABEL_26:
  *(_BYTE *)(a4 + 24) &= ~1u;
  *(_OWORD *)a4 = *(_OWORD *)__len;
  *(_QWORD *)(a4 + 16) = v16;
LABEL_27:
  if (v18 != v20)
    free(v18);
}

void llvm::PrefixMapper::mapInPlace(uint64_t a1@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v5;
  unint64_t v6;
  const void *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v10[2];
  char v11;
  char v12;
  void *v13;
  __int128 v14;
  _QWORD v15[33];

  v15[32] = *MEMORY[0x1E0C80C00];
  v13 = v15;
  v14 = xmmword_1C64638F0;
  (*(void (**)(_QWORD *__return_ptr, uint64_t, _QWORD, _QWORD, void **))(*(_QWORD *)a1 + 16))(v10, a1, *a2, a2[1], &v13);
  if ((v12 & 1) != 0)
  {
    v5 = v10[0];
    *a3 = v10[0];
    if (v5)
      goto LABEL_12;
    goto LABEL_11;
  }
  if (v11)
  {
    if ((_QWORD)v14)
    {
      sub_1C5DF216C(&v13, a2);
      goto LABEL_11;
    }
    v7 = (const void *)v10[0];
    v6 = v10[1];
    a2[1] = 0;
    if (a2[2] < v6)
    {
      llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a2, a2 + 3, v6, 1);
      v8 = a2[1];
    }
    else
    {
      v8 = 0;
      v9 = 0;
      if (!v6)
      {
LABEL_10:
        a2[1] = v9 + v6;
        goto LABEL_11;
      }
    }
    memcpy((void *)(*a2 + v8), v7, v6);
    v9 = a2[1];
    goto LABEL_10;
  }
LABEL_11:
  *a3 = 0;
LABEL_12:
  if (v13 != v15)
    free(v13);
}

void llvm::PrefixMapper::mapInPlace(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v5;
  _QWORD v6[2];
  char v7;
  char v8;
  void *v9;
  __int128 v10;
  _QWORD v11[33];

  v11[32] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = xmmword_1C64638F0;
  (*(void (**)(_QWORD *__return_ptr))(*(_QWORD *)a1 + 16))(v6);
  if ((v8 & 1) != 0)
  {
    v5 = v6[0];
    *a3 = v6[0];
    if (v5)
      goto LABEL_6;
  }
  else if (v7)
  {
    MEMORY[0x1CAA32AC8](a2, v6[0], v6[1]);
  }
  *a3 = 0;
LABEL_6:
  if (v9 != v11)
    free(v9);
}

void llvm::PrefixMapper::sort(llvm::PrefixMapper *this, __n128 a2)
{
  const void **v2;
  unint64_t v3;
  const std::nothrow_t *v4;
  unint64_t v5;
  const void **v6;
  BOOL v7;
  const void **v8;

  v2 = (const void **)*((_QWORD *)this + 2);
  v3 = *((unsigned int *)this + 6);
  if ((_DWORD)v3)
  {
    v4 = (const std::nothrow_t *)MEMORY[0x1E0DE4E10];
    v5 = *((unsigned int *)this + 6);
    while (1)
    {
      v6 = (const void **)operator new(48 * v5, v4);
      if (v6)
        break;
      v7 = v5 > 1;
      v5 >>= 1;
      if (!v7)
        goto LABEL_5;
    }
    v8 = v6;
    sub_1C5E27354(v2, &v2[6 * v3], v3, v6, v5, a2);
    operator delete(v8);
  }
  else
  {
LABEL_5:
    sub_1C5E27354(v2, &v2[6 * v3], v3, 0, 0, a2);
  }
}

double llvm::TreePathPrefixMapper::TreePathPrefixMapper(uint64_t a1, _QWORD *a2, int a3)
{
  double result;

  *(_DWORD *)(a1 + 8) = a3;
  *(_QWORD *)(a1 + 16) = a1 + 32;
  *(_QWORD *)&result = 0x100000000;
  *(_QWORD *)(a1 + 24) = 0x100000000;
  *(_QWORD *)a1 = &off_1E81A1AD0;
  *(_QWORD *)(a1 + 80) = *a2;
  *a2 = 0;
  return result;
}

{
  double result;

  *(_DWORD *)(a1 + 8) = a3;
  *(_QWORD *)(a1 + 16) = a1 + 32;
  *(_QWORD *)&result = 0x100000000;
  *(_QWORD *)(a1 + 24) = 0x100000000;
  *(_QWORD *)a1 = &off_1E81A1AD0;
  *(_QWORD *)(a1 + 80) = *a2;
  *a2 = 0;
  return result;
}

void llvm::TreePathPrefixMapper::~TreePathPrefixMapper(llvm::TreePathPrefixMapper *this)
{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  *(_QWORD *)this = &off_1E81A1AD0;
  v2 = (unsigned int *)*((_QWORD *)this + 10);
  if (v2)
  {
    v3 = v2 + 2;
    do
    {
      v4 = __ldaxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 8))(v2);
  }
  *(_QWORD *)this = &off_1E81A1B00;
  sub_1C638D5A8((char **)this + 2);
}

{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  *(_QWORD *)this = &off_1E81A1AD0;
  v2 = (unsigned int *)*((_QWORD *)this + 10);
  if (v2)
  {
    v3 = v2 + 2;
    do
    {
      v4 = __ldaxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 8))(v2);
  }
  *(_QWORD *)this = &off_1E81A1B00;
  sub_1C638D5A8((char **)this + 2);
}

{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  *(_QWORD *)this = &off_1E81A1AD0;
  v2 = (unsigned int *)*((_QWORD *)this + 10);
  if (v2)
  {
    v3 = v2 + 2;
    do
    {
      v4 = __ldaxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 8))(v2);
  }
  *(_QWORD *)this = &off_1E81A1B00;
  sub_1C638D5A8((char **)this + 2);
  JUMPOUT(0x1CAA32FC0);
}

void llvm::TreePathPrefixMapper::canonicalizePrefix(llvm::TreePathPrefixMapper *this@<X0>, llvm::StringRef *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v5;
  const void *v6;
  size_t v7;
  _QWORD v8[2];
  char v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  llvm::TreePathPrefixMapper::getTreePath((uint64_t)this, *(_QWORD *)a2, *((_QWORD *)a2 + 1), (uint64_t)v8);
  v5 = v8[0];
  if ((v9 & 1) != 0)
    v6 = 0;
  else
    v6 = (const void *)v8[0];
  if ((v9 & 1) != 0)
    v7 = 0;
  else
    v7 = v8[1];
  if ((v9 & 1) == 0 || (*a3 = v8[0], !v5))
  {
    if (v7 != *((_QWORD *)a2 + 1) || v7 && memcmp(v6, *(const void **)a2, v7))
    {
      *(_QWORD *)a2 = v6;
      *((_QWORD *)a2 + 1) = v7;
    }
    *a3 = 0;
  }
}

void llvm::TreePathPrefixMapper::add(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  char v5;
  BOOL v6;
  void *v7;
  size_t v8;
  char v9;
  size_t v10;
  void *v11;
  void *v12;
  size_t v13;
  void *v14;
  unint64_t v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  __int128 v19;
  _BYTE *v20;
  __int128 v21;
  void *v22[2];
  char v23;
  void *__p;
  char v25;
  void *v26;
  size_t v27;

  v5 = *(_BYTE *)(a2 + 23);
  v6 = v5 < 0;
  v7 = *(void **)a2;
  if (v5 >= 0)
    v7 = (void *)a2;
  v8 = v5 & 0x7F;
  if (v6)
    v8 = *(_QWORD *)(a2 + 8);
  v26 = v7;
  v27 = v8;
  v9 = *(_BYTE *)(a2 + 47);
  v10 = *(_QWORD *)(a2 + 32);
  v11 = (void *)(a2 + 24);
  v12 = *(void **)(a2 + 24);
  llvm::TreePathPrefixMapper::canonicalizePrefix((llvm::TreePathPrefixMapper *)a1, (llvm::StringRef *)&v26, a3);
  if (!*a3)
  {
    if (v9 >= 0)
      v13 = v9 & 0x7F;
    else
      v13 = v10;
    if (v9 >= 0)
      v14 = v11;
    else
      v14 = v12;
    sub_1C5E26F9C(v22, v26, v27, v14, v13);
    v15 = sub_1C5E270D8(a1 + 16, (unint64_t)v22);
    v16 = *(_QWORD *)(a1 + 16);
    v17 = *(_DWORD *)(a1 + 24);
    v18 = v16 + 48 * v17;
    if (*(char *)(v15 + 23) < 0)
    {
      sub_1C47EBC30((_BYTE *)v18, *(void **)v15, *(_QWORD *)(v15 + 8));
    }
    else
    {
      v19 = *(_OWORD *)v15;
      *(_QWORD *)(v18 + 16) = *(_QWORD *)(v15 + 16);
      *(_OWORD *)v18 = v19;
    }
    v20 = (_BYTE *)(v16 + 48 * v17 + 24);
    if (*(char *)(v15 + 47) < 0)
    {
      sub_1C47EBC30(v20, *(void **)(v15 + 24), *(_QWORD *)(v15 + 32));
    }
    else
    {
      v21 = *(_OWORD *)(v15 + 24);
      *(_QWORD *)(v16 + 48 * v17 + 40) = *(_QWORD *)(v15 + 40);
      *(_OWORD *)v20 = v21;
    }
    ++*(_DWORD *)(a1 + 24);
    *a3 = 0;
    if (v25 < 0)
      operator delete(__p);
    if (v23 < 0)
      operator delete(v22[0]);
  }
}

_QWORD *sub_1C5E26F9C(_QWORD *__dst, void *__src, size_t __len, void *a4, size_t a5)
{
  void *v10;
  size_t v11;
  size_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;

  if (!__src)
  {
    *__dst = 0;
    __dst[1] = 0;
    __dst[2] = 0;
    goto LABEL_12;
  }
  if (__len > 0x7FFFFFFFFFFFFFF7)
    goto LABEL_24;
  if (__len >= 0x17)
  {
    v11 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v11 = __len | 7;
    v12 = v11 + 1;
    v10 = operator new(v11 + 1);
    __dst[1] = __len;
    __dst[2] = v12 | 0x8000000000000000;
    *__dst = v10;
  }
  else
  {
    *((_BYTE *)__dst + 23) = __len;
    v10 = __dst;
    if (!__len)
      goto LABEL_11;
  }
  memmove(v10, __src, __len);
LABEL_11:
  *((_BYTE *)v10 + __len) = 0;
LABEL_12:
  v13 = __dst + 3;
  if (a4)
  {
    if (a5 <= 0x7FFFFFFFFFFFFFF7)
    {
      if (a5 >= 0x17)
      {
        v14 = (a5 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((a5 | 7) != 0x17)
          v14 = a5 | 7;
        v15 = v14 + 1;
        v13 = operator new(v14 + 1);
        __dst[4] = a5;
        __dst[5] = v15 | 0x8000000000000000;
        __dst[3] = v13;
      }
      else
      {
        *((_BYTE *)__dst + 47) = a5;
        if (!a5)
          goto LABEL_22;
      }
      memmove(v13, a4, a5);
LABEL_22:
      *((_BYTE *)v13 + a5) = 0;
      return __dst;
    }
LABEL_24:
    abort();
  }
  *v13 = 0;
  __dst[4] = 0;
  __dst[5] = 0;
  return __dst;
}

unint64_t sub_1C5E270D8(uint64_t a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v5;
  unint64_t v6;
  unint64_t v8;

  v3 = *(unsigned int *)(a1 + 8);
  if (v3 >= *(_DWORD *)(a1 + 12))
  {
    v5 = v3 + 1;
    v6 = *(_QWORD *)a1 + 48 * v3;
    if (*(_QWORD *)a1 <= a2 && v6 > a2)
    {
      v8 = a2 - *(_QWORD *)a1;
      sub_1C638D60C(a1, v5);
      return *(_QWORD *)a1 + v8;
    }
    else
    {
      sub_1C638D60C(a1, v5);
    }
  }
  return a2;
}

void sub_1C5E27140(uint64_t *a1, uint64_t a2)
{
  unsigned int v2;
  __int128 *v3;
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;
  __int128 *v8;
  uint64_t v9;
  __int128 *v10;

  v2 = *((_DWORD *)a1 + 2);
  if (v2)
  {
    v3 = (__int128 *)*a1;
    v4 = *a1 + 48 * v2;
    do
    {
      v5 = *v3;
      *(_QWORD *)(a2 + 16) = *((_QWORD *)v3 + 2);
      *(_OWORD *)a2 = v5;
      *((_QWORD *)v3 + 1) = 0;
      *((_QWORD *)v3 + 2) = 0;
      *(_QWORD *)v3 = 0;
      v6 = *(__int128 *)((char *)v3 + 24);
      *(_QWORD *)(a2 + 40) = *((_QWORD *)v3 + 5);
      *(_OWORD *)(a2 + 24) = v6;
      *((_QWORD *)v3 + 4) = 0;
      *((_QWORD *)v3 + 5) = 0;
      *((_QWORD *)v3 + 3) = 0;
      v3 += 3;
      a2 += 48;
    }
    while (v3 != (__int128 *)v4);
    v7 = *((unsigned int *)a1 + 2);
    if ((_DWORD)v7)
    {
      v8 = (__int128 *)*a1;
      v9 = 3 * v7;
      do
      {
        v10 = &v8[v9];
        if (SHIBYTE(v8[v9 - 1]) < 0)
          operator delete(*((void **)v10 - 3));
        if (*((char *)v10 - 25) < 0)
          operator delete(*((void **)v10 - 6));
        v9 -= 3;
      }
      while (v9 * 16);
    }
  }
}

char *sub_1C5E271F4(char *__dst, __int128 *a2)
{
  __int128 v4;
  _BYTE *v5;
  __int128 v6;

  if (*((char *)a2 + 23) < 0)
  {
    sub_1C47EBC30(__dst, *(void **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v4 = *a2;
    *((_QWORD *)__dst + 2) = *((_QWORD *)a2 + 2);
    *(_OWORD *)__dst = v4;
  }
  v5 = __dst + 24;
  if (*((char *)a2 + 47) < 0)
  {
    sub_1C47EBC30(v5, *((void **)a2 + 3), *((_QWORD *)a2 + 4));
  }
  else
  {
    v6 = *(__int128 *)((char *)a2 + 24);
    *((_QWORD *)__dst + 5) = *((_QWORD *)a2 + 5);
    *(_OWORD *)v5 = v6;
  }
  return __dst;
}

void sub_1C5E2726C(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v2 = *(unsigned int *)(a1 + 8);
  if (v2 != a2)
  {
    if (v2 <= a2)
    {
      if (*(unsigned int *)(a1 + 12) < a2)
      {
        sub_1C638D60C(a1, a2);
        v2 = *(unsigned int *)(a1 + 8);
      }
      if (v2 != a2)
        bzero((void *)(*(_QWORD *)a1 + 48 * v2), 48 * ((-48 * v2 + 48 * a2 - 48) / 0x30) + 48);
    }
    else
    {
      v5 = 3 * v2;
      v6 = *(_QWORD *)a1 + 16 * v5 - 24;
      v7 = 48 * a2 - 16 * v5;
      do
      {
        if (*(char *)(v6 + 23) < 0)
          operator delete(*(void **)v6);
        if (*(char *)(v6 - 1) < 0)
          operator delete(*(void **)(v6 - 24));
        v6 -= 48;
        v7 += 48;
      }
      while (v7);
    }
    *(_DWORD *)(a1 + 8) = a2;
  }
}

void sub_1C5E27354(const void **a1, const void **a2, unint64_t a3, const void **a4, uint64_t a5, __n128 a6)
{
  uint64_t v7;
  const void **v8;
  char v9;
  int v10;
  const void **v11;
  const void **v12;
  size_t v13;
  size_t v14;
  int v15;
  size_t v16;
  unint64_t v20;
  const void **v21;
  unint64_t v22;
  size_t v23;
  int v24;
  _BOOL4 v25;
  const void *v26;
  const void *v27;
  void **v28;
  char v29;
  __int128 v30;
  __int128 v31;
  char *v32;
  uint64_t v33;
  const void **v34;
  char *v35;
  char v36;
  BOOL v37;
  char *v38;
  size_t v39;
  size_t v40;
  size_t v41;
  const void *v42;
  size_t v43;
  int v44;
  _BOOL4 v45;
  __int128 *v46;
  size_t v47;
  uint64_t v48;
  uint64_t v49;
  void **v50;
  void **v51;
  uint64_t v52;
  _QWORD *v53;
  size_t v54;
  size_t v55;
  int v56;
  BOOL v57;
  uint64_t v58;
  void **v59;
  __n128 v60;
  uint64_t v61;
  const void **v62;
  char *v63;
  const void **v64;
  const void **v65;
  char v66;
  BOOL v67;
  const void *v68;
  size_t v69;
  size_t v70;
  size_t v71;
  const void *v72;
  void **v73;
  size_t v74;
  int v75;
  _BOOL4 v76;
  int v77;
  __int128 v78;
  void **v79;
  __int128 v80;
  __int128 v81;
  void **v82;
  __int128 v83;
  uint64_t v84;
  char *v85;
  void **v86;
  const void **v87;
  __int128 v88;
  void **v89;
  __int128 v90;
  int v91;
  const void *v92;
  uint64_t v93;
  char *v94;
  void **v95;
  const void **v96;
  __int128 v97;
  void **v98;
  __int128 v99;
  unint64_t v100;
  char *v101;
  __int128 v102;
  uint64_t v103;
  __int128 v104;
  const void *v105;
  _QWORD v106[3];

  v106[2] = *MEMORY[0x1E0C80C00];
  if (a3 >= 2)
  {
    v7 = (uint64_t)a1;
    if (a3 == 2)
    {
      v8 = a2 - 6;
      v9 = *((_BYTE *)a2 - 25);
      v10 = v9;
      if (v9 >= 0)
        v11 = a2 - 6;
      else
        v11 = (const void **)*(a2 - 6);
      v12 = a2 - 5;
      v13 = v9 & 0x7F;
      if (v10 >= 0)
        v14 = v13;
      else
        v14 = (size_t)*(a2 - 5);
      v15 = *((char *)a1 + 23);
      if (v15 < 0)
      {
        a1 = (const void **)*a1;
        v16 = *(_QWORD *)(v7 + 8);
      }
      else
      {
        v16 = *((unsigned __int8 *)a1 + 23);
      }
      if (v14 >= v16)
        v23 = v16;
      else
        v23 = v14;
      v24 = memcmp(a1, v11, v23);
      v25 = v16 < v14;
      if (v24)
        v25 = v24 < 0;
      if (v25)
      {
        v26 = *(const void **)v7;
        *(_QWORD *)&v102 = *(_QWORD *)(v7 + 8);
        *(_QWORD *)((char *)&v102 + 7) = *(_QWORD *)(v7 + 15);
        *(_QWORD *)(v7 + 8) = 0;
        *(_QWORD *)(v7 + 16) = 0;
        *(_QWORD *)v7 = 0;
        v28 = (void **)(v7 + 24);
        v27 = *(const void **)(v7 + 24);
        v106[0] = *(_QWORD *)(v7 + 32);
        *(_QWORD *)((char *)v106 + 7) = *(_QWORD *)(v7 + 39);
        v29 = *(_BYTE *)(v7 + 47);
        *(_QWORD *)(v7 + 24) = 0;
        *(_QWORD *)(v7 + 32) = 0;
        *(_QWORD *)(v7 + 40) = 0;
        v30 = *(_OWORD *)v8;
        *(_QWORD *)(v7 + 16) = *(a2 - 4);
        *(_OWORD *)v7 = v30;
        *((_BYTE *)a2 - 25) = 0;
        *((_BYTE *)a2 - 48) = 0;
        if (*(char *)(v7 + 47) < 0)
          operator delete(*v28);
        v31 = *(_OWORD *)(a2 - 3);
        *(_QWORD *)(v7 + 40) = *(a2 - 1);
        *(_OWORD *)v28 = v31;
        *((_BYTE *)a2 - 1) = 0;
        *((_BYTE *)a2 - 24) = 0;
        if (*((char *)a2 - 25) < 0)
        {
          operator delete((void *)*(a2 - 6));
          v91 = *((char *)a2 - 1);
          *(a2 - 6) = v26;
          *v12 = (const void *)v102;
          *(const void **)((char *)a2 - 33) = *(const void **)((char *)&v102 + 7);
          *((_BYTE *)a2 - 25) = v15;
          if (v91 < 0)
            operator delete((void *)*(a2 - 3));
        }
        else
        {
          *(a2 - 6) = v26;
          *v12 = (const void *)v102;
          *(const void **)((char *)a2 - 33) = *(const void **)((char *)&v102 + 7);
          *((_BYTE *)a2 - 25) = v15;
        }
        v92 = (const void *)v106[0];
        *(a2 - 3) = v27;
        *(a2 - 2) = v92;
        *(const void **)((char *)a2 - 9) = *(const void **)((char *)v106 + 7);
        *((_BYTE *)a2 - 1) = v29;
      }
    }
    else if ((uint64_t)a3 <= 0)
    {
      if (a1 != a2)
      {
        v32 = (char *)(a1 + 6);
        if (a1 + 6 != a2)
        {
          v33 = 0;
          v34 = a1;
          do
          {
            v35 = v32;
            v36 = *((_BYTE *)v34 + 71);
            v37 = v36 < 0;
            if (v36 >= 0)
              v38 = v35;
            else
              v38 = (char *)v34[6];
            v39 = v36 & 0x7F;
            if (v37)
              v40 = (size_t)v34[7];
            else
              v40 = v39;
            if (*((char *)v34 + 23) < 0)
            {
              v42 = *v34;
              v41 = (size_t)v34[1];
            }
            else
            {
              v41 = *((unsigned __int8 *)v34 + 23);
              v42 = v34;
            }
            if (v40 >= v41)
              v43 = v41;
            else
              v43 = v40;
            v44 = memcmp(v42, v38, v43);
            v45 = v41 < v40;
            if (v44)
              v45 = v44 < 0;
            if (v45)
            {
              v103 = *((_QWORD *)v35 + 2);
              v102 = *(_OWORD *)v35;
              *((_QWORD *)v35 + 1) = 0;
              *((_QWORD *)v35 + 2) = 0;
              *(_QWORD *)v35 = 0;
              v104 = *(_OWORD *)(v34 + 9);
              v105 = v34[11];
              v34[9] = 0;
              v34[10] = 0;
              v34[11] = 0;
              if (v103 >= 0)
                v46 = &v102;
              else
                v46 = (__int128 *)v102;
              if (v103 >= 0)
                v47 = HIBYTE(v103) & 0x7F;
              else
                v47 = *((_QWORD *)&v102 + 1);
              v48 = v33;
              while (1)
              {
                v49 = v7 + v48;
                v50 = (void **)(v7 + v48 + 48);
                if (*(char *)(v7 + v48 + 71) < 0)
                  operator delete(*v50);
                *(_OWORD *)v50 = *(_OWORD *)v49;
                *(_QWORD *)(v7 + v48 + 64) = *(_QWORD *)(v49 + 16);
                *(_BYTE *)(v49 + 23) = 0;
                *(_BYTE *)v49 = 0;
                v51 = (void **)(v49 + 72);
                if (*(char *)(v49 + 95) < 0)
                  operator delete(*v51);
                v52 = v7 + v48;
                *(_OWORD *)v51 = *(_OWORD *)(v7 + v48 + 24);
                *(_QWORD *)(v49 + 88) = *(_QWORD *)(v7 + v48 + 40);
                *(_BYTE *)(v52 + 47) = 0;
                *(_BYTE *)(v52 + 24) = 0;
                if (!v48)
                  break;
                v53 = (_QWORD *)(v52 - 48);
                if (*(char *)(v52 - 25) < 0)
                {
                  v54 = *(_QWORD *)(v7 + v48 - 40);
                  v53 = (_QWORD *)*v53;
                }
                else
                {
                  v54 = *(unsigned __int8 *)(v52 - 25);
                }
                if (v47 >= v54)
                  v55 = v54;
                else
                  v55 = v47;
                v56 = memcmp(v53, v46, v55);
                v57 = v54 < v47;
                if (v56)
                  v57 = v56 < 0;
                v48 -= 48;
                if (!v57)
                {
                  v58 = v7 + v48 + 48;
                  goto LABEL_66;
                }
              }
              v58 = v7;
LABEL_66:
              if (*(char *)(v58 + 23) < 0)
                operator delete(*(void **)v58);
              v59 = (void **)(v52 + 24);
              *(_OWORD *)v58 = v102;
              *(_QWORD *)(v58 + 16) = v103;
              if (*(char *)(v58 + 47) < 0)
                operator delete(*v59);
              *(_OWORD *)v59 = v104;
              *(_QWORD *)(v52 + 40) = v105;
            }
            v32 = v35 + 48;
            v33 += 48;
            v34 = (const void **)v35;
          }
          while (v35 + 48 != (char *)a2);
        }
      }
    }
    else
    {
      v20 = a3 >> 1;
      v21 = &a1[6 * (a3 >> 1)];
      v22 = a3 >> 1;
      if ((uint64_t)a3 <= a5)
      {
        v60 = sub_1C5E27A5C(a1, v21, v22, (uint64_t)a4, a6);
        v61 = (uint64_t)&a4[6 * v20];
        sub_1C5E27A5C((const void **)(v7 + 48 * (a3 >> 1)), a2, a3 - (a3 >> 1), v61, v60);
        v62 = &a4[6 * a3];
        v63 = (char *)(v7 + 23);
        v64 = (const void **)v61;
        v65 = a4;
        while (v64 != v62)
        {
          v66 = *((_BYTE *)v64 + 23);
          v67 = v66 < 0;
          if (v66 >= 0)
            v68 = v64;
          else
            v68 = *v64;
          v69 = v66 & 0x7F;
          if (v67)
            v70 = (size_t)v64[1];
          else
            v70 = v69;
          if (*((char *)v65 + 23) < 0)
          {
            v72 = *v65;
            v71 = (size_t)v65[1];
          }
          else
          {
            v71 = *((unsigned __int8 *)v65 + 23);
            v72 = v65;
          }
          v73 = (void **)(v63 - 23);
          if (v70 >= v71)
            v74 = v71;
          else
            v74 = v70;
          v75 = memcmp(v72, v68, v74);
          v76 = v75 < 0;
          if (!v75)
            v76 = v71 < v70;
          v77 = *v63;
          if (v76)
          {
            if (v77 < 0)
              operator delete(*v73);
            v78 = *(_OWORD *)v64;
            *(_QWORD *)(v63 - 7) = v64[2];
            *(_OWORD *)v73 = v78;
            *((_BYTE *)v64 + 23) = 0;
            *(_BYTE *)v64 = 0;
            v79 = (void **)(v63 + 1);
            if (v63[24] < 0)
              operator delete(*v79);
            v80 = *(_OWORD *)(v64 + 3);
            *(_QWORD *)(v63 + 17) = v64[5];
            *(_OWORD *)v79 = v80;
            *((_BYTE *)v64 + 47) = 0;
            *((_BYTE *)v64 + 24) = 0;
            v64 += 6;
          }
          else
          {
            if (v77 < 0)
              operator delete(*v73);
            v81 = *(_OWORD *)v65;
            *(_QWORD *)(v63 - 7) = v65[2];
            *(_OWORD *)v73 = v81;
            *((_BYTE *)v65 + 23) = 0;
            *(_BYTE *)v65 = 0;
            v82 = (void **)(v63 + 1);
            if (v63[24] < 0)
              operator delete(*v82);
            v83 = *(_OWORD *)(v65 + 3);
            *(_QWORD *)(v63 + 17) = v65[5];
            *(_OWORD *)v82 = v83;
            *((_BYTE *)v65 + 47) = 0;
            *((_BYTE *)v65 + 24) = 0;
            v65 += 6;
          }
          v63 += 48;
          if (v65 == (const void **)v61)
          {
            if (v64 != v62)
            {
              v84 = 0;
              do
              {
                v85 = &v63[v84 * 8];
                v86 = (void **)&v63[v84 * 8 - 23];
                if (v63[v84 * 8] < 0)
                  operator delete(*v86);
                v87 = &v64[v84];
                v88 = *(_OWORD *)&v64[v84];
                *(_QWORD *)&v63[v84 * 8 - 7] = v64[v84 + 2];
                *(_OWORD *)v86 = v88;
                *((_BYTE *)v87 + 23) = 0;
                *(_BYTE *)v87 = 0;
                v89 = (void **)(v85 + 1);
                if (v85[24] < 0)
                  operator delete(*v89);
                v90 = *(_OWORD *)(v87 + 3);
                *(_QWORD *)(v85 + 17) = v87[5];
                *(_OWORD *)v89 = v90;
                *((_BYTE *)v87 + 47) = 0;
                *((_BYTE *)v87 + 24) = 0;
                v84 += 6;
              }
              while (v87 + 6 != v62);
            }
            goto LABEL_119;
          }
        }
        if (v65 != (const void **)v61)
        {
          v93 = 0;
          do
          {
            v94 = &v63[v93 * 8];
            v95 = (void **)&v63[v93 * 8 - 23];
            if (v63[v93 * 8] < 0)
              operator delete(*v95);
            v96 = &v65[v93];
            v97 = *(_OWORD *)&v65[v93];
            *(_QWORD *)&v63[v93 * 8 - 7] = v65[v93 + 2];
            *(_OWORD *)v95 = v97;
            *((_BYTE *)v96 + 23) = 0;
            *(_BYTE *)v96 = 0;
            v98 = (void **)(v94 + 1);
            if (v94[24] < 0)
              operator delete(*v98);
            v99 = *(_OWORD *)(v96 + 3);
            *(_QWORD *)(v94 + 17) = v96[5];
            *(_OWORD *)v98 = v99;
            *((_BYTE *)v96 + 47) = 0;
            *((_BYTE *)v96 + 24) = 0;
            v93 += 6;
          }
          while (v96 + 6 != (const void **)v61);
        }
LABEL_119:
        if (a4)
        {
          v100 = a3;
          v101 = (char *)a4 + 23;
          do
          {
            if (v101[24] < 0)
              operator delete(*(void **)(v101 + 1));
            if (*v101 < 0)
              operator delete(*(void **)(v101 - 23));
            v101 += 48;
            --v100;
          }
          while (v100);
        }
      }
      else
      {
        sub_1C5E27354(a1, v21, v22, a4, a5);
        sub_1C5E27354(v7 + 48 * (a3 >> 1), a2, a3 - (a3 >> 1), a4, a5);
        sub_1C5E2806C(v7, (const void **)(v7 + 48 * (a3 >> 1)), (char *)a2, a3 >> 1, a3 - (a3 >> 1), a4, a5);
      }
    }
  }
}

__n128 sub_1C5E27A5C(const void **a1, const void **a2, unint64_t a3, uint64_t a4, __n128 result)
{
  uint64_t v5;
  const void **v7;
  const void **v8;
  __int128 v9;
  const void **v10;
  __int128 *v11;
  char v12;
  int v13;
  const void **v14;
  size_t v15;
  size_t v16;
  size_t v17;
  __int128 v18;
  const void **v19;
  uint64_t v20;
  _OWORD *v21;
  const void **v22;
  char v23;
  BOOL v24;
  const void **v25;
  size_t v26;
  size_t v27;
  size_t v28;
  const void *v29;
  _OWORD *v30;
  size_t v31;
  int v32;
  _BOOL4 v33;
  _OWORD *v34;
  __int128 v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  const void **v39;
  char v40;
  int v41;
  const void *v42;
  size_t v43;
  size_t v44;
  size_t v45;
  const void *v46;
  size_t v47;
  int v48;
  _BOOL4 v49;
  uint64_t v50;
  void **v51;
  uint64_t v52;
  __int128 v53;
  __int128 v54;
  void **v55;
  const void **v56;
  const void **v57;
  char v58;
  BOOL v59;
  const void *v60;
  size_t v61;
  size_t v62;
  size_t v63;
  const void *v64;
  size_t v65;
  int v66;
  _BOOL4 v67;
  __n128 *v68;
  __int128 v69;
  __int128 v70;
  uint64_t v71;
  const void **v72;
  uint64_t v73;
  __int128 v74;
  size_t v75;
  int v76;
  _BOOL4 v77;
  _OWORD *v78;
  _OWORD *v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  const void *v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  uint64_t v87;
  uint64_t v88;
  const void **v89;
  __int128 v90;

  if (a3)
  {
    v5 = a4;
    v7 = a2;
    v8 = a1;
    if (a3 == 2)
    {
      v11 = (__int128 *)(a2 - 6);
      v12 = *((_BYTE *)a2 - 25);
      v13 = v12;
      if (v12 >= 0)
        v14 = a2 - 6;
      else
        v14 = (const void **)*(a2 - 6);
      v15 = v12 & 0x7F;
      if (v13 >= 0)
        v16 = v15;
      else
        v16 = (size_t)*(v7 - 5);
      if (*((char *)a1 + 23) < 0)
      {
        a1 = (const void **)*a1;
        v17 = (size_t)v8[1];
      }
      else
      {
        v17 = *((unsigned __int8 *)a1 + 23);
      }
      if (v16 >= v17)
        v75 = v17;
      else
        v75 = v16;
      v76 = memcmp(a1, v14, v75);
      if (v76)
        v77 = v76 < 0;
      else
        v77 = v17 < v16;
      v78 = (_OWORD *)(v5 + 24);
      v79 = (_OWORD *)(v5 + 48);
      if (v77)
      {
        v80 = *v11;
        *(_QWORD *)(v5 + 16) = *(v7 - 4);
        *(_OWORD *)v5 = v80;
        *(v7 - 5) = 0;
        *(v7 - 4) = 0;
        *(_QWORD *)v11 = 0;
        v81 = *(_OWORD *)(v7 - 3);
        *(_QWORD *)(v5 + 40) = *(v7 - 1);
        *v78 = v81;
        *(v7 - 2) = 0;
        *(v7 - 1) = 0;
        *(v7 - 3) = 0;
        v82 = *(_OWORD *)v8;
        *(_QWORD *)(v5 + 64) = v8[2];
        *v79 = v82;
        v8[1] = 0;
        v8[2] = 0;
        *v8 = 0;
        v10 = v8 + 3;
        result = *(__n128 *)(v8 + 3);
        v83 = v8[5];
      }
      else
      {
        v84 = *(_OWORD *)v8;
        *(_QWORD *)(v5 + 16) = v8[2];
        *(_OWORD *)v5 = v84;
        v8[1] = 0;
        v8[2] = 0;
        *v8 = 0;
        v85 = *(_OWORD *)(v8 + 3);
        *(_QWORD *)(v5 + 40) = v8[5];
        *v78 = v85;
        v8[4] = 0;
        v8[5] = 0;
        v8[3] = 0;
        v86 = *v11;
        *(_QWORD *)(v5 + 64) = *(v7 - 4);
        *v79 = v86;
        *(v7 - 5) = 0;
        *(v7 - 4) = 0;
        *(_QWORD *)v11 = 0;
        v10 = v7 - 3;
        result = *(__n128 *)(v7 - 3);
        v83 = *(v7 - 1);
      }
      *(_QWORD *)(v5 + 88) = v83;
      *(__n128 *)(v5 + 72) = result;
      goto LABEL_100;
    }
    if (a3 == 1)
    {
      v9 = *(_OWORD *)a1;
      *(_QWORD *)(a4 + 16) = a1[2];
      *(_OWORD *)a4 = v9;
      a1[1] = 0;
      a1[2] = 0;
      *a1 = 0;
      v10 = a1 + 3;
      result = *(__n128 *)(a1 + 3);
      *(_QWORD *)(a4 + 40) = a1[5];
      *(__n128 *)(a4 + 24) = result;
LABEL_100:
      *v10 = 0;
      v10[1] = 0;
      v10[2] = 0;
      return result;
    }
    if ((uint64_t)a3 > 8)
    {
      v56 = &a1[6 * (a3 >> 1)];
      sub_1C5E27354(a1, v56, a3 >> 1, a4, a3 >> 1);
      sub_1C5E27354(&v8[6 * (a3 >> 1)], v7, a3 - (a3 >> 1), v5 + 48 * (a3 >> 1), a3 - (a3 >> 1));
      v57 = &v8[6 * (a3 >> 1)];
      while (v57 != v7)
      {
        v58 = *((_BYTE *)v57 + 23);
        v59 = v58 < 0;
        if (v58 >= 0)
          v60 = v57;
        else
          v60 = *v57;
        v61 = v58 & 0x7F;
        if (v59)
          v62 = (size_t)v57[1];
        else
          v62 = v61;
        if (*((char *)v8 + 23) < 0)
        {
          v64 = *v8;
          v63 = (size_t)v8[1];
        }
        else
        {
          v63 = *((unsigned __int8 *)v8 + 23);
          v64 = v8;
        }
        if (v62 >= v63)
          v65 = v63;
        else
          v65 = v62;
        v66 = memcmp(v64, v60, v65);
        v67 = v66 < 0;
        if (!v66)
          v67 = v63 < v62;
        v68 = (__n128 *)(v5 + 24);
        if (v67)
        {
          v69 = *(_OWORD *)v57;
          *(_QWORD *)(v5 + 16) = v57[2];
          *(_OWORD *)v5 = v69;
          v57[1] = 0;
          v57[2] = 0;
          *v57 = 0;
          result = *(__n128 *)(v57 + 3);
          *(_QWORD *)(v5 + 40) = v57[5];
          *v68 = result;
          v57[4] = 0;
          v57[5] = 0;
          v57[3] = 0;
          v57 += 6;
        }
        else
        {
          v70 = *(_OWORD *)v8;
          *(_QWORD *)(v5 + 16) = v8[2];
          *(_OWORD *)v5 = v70;
          v8[1] = 0;
          v8[2] = 0;
          *v8 = 0;
          result = *(__n128 *)(v8 + 3);
          *(_QWORD *)(v5 + 40) = v8[5];
          *v68 = result;
          v8[4] = 0;
          v8[5] = 0;
          v8[3] = 0;
          v8 += 6;
        }
        v5 += 48;
        if (v8 == v56)
        {
          if (v57 != v7)
          {
            v71 = 0;
            do
            {
              v72 = &v57[v71];
              v73 = v5 + v71 * 8;
              v74 = *(_OWORD *)&v57[v71];
              *(_QWORD *)(v73 + 16) = v57[v71 + 2];
              *(_OWORD *)v73 = v74;
              v72[1] = 0;
              v72[2] = 0;
              *v72 = 0;
              result = *(__n128 *)&v57[v71 + 3];
              *(_QWORD *)(v73 + 40) = v57[v71 + 5];
              *(__n128 *)(v73 + 24) = result;
              v72[4] = 0;
              v72[5] = 0;
              v72[3] = 0;
              v71 += 6;
            }
            while (v72 + 6 != v7);
          }
          return result;
        }
      }
      if (v8 != v56)
      {
        v87 = 0;
        do
        {
          v88 = v5 + v87 * 8;
          v89 = &v8[v87];
          v90 = *(_OWORD *)&v8[v87];
          *(_QWORD *)(v88 + 16) = v8[v87 + 2];
          *(_OWORD *)v88 = v90;
          v89[1] = 0;
          v89[2] = 0;
          *v89 = 0;
          result = *(__n128 *)&v8[v87 + 3];
          *(_QWORD *)(v88 + 40) = v8[v87 + 5];
          *(__n128 *)(v88 + 24) = result;
          v89[4] = 0;
          v89[5] = 0;
          v89[3] = 0;
          v87 += 6;
        }
        while (v89 + 6 != v56);
      }
    }
    else if (a1 != a2)
    {
      v18 = *(_OWORD *)a1;
      *(_QWORD *)(a4 + 16) = a1[2];
      *(_OWORD *)a4 = v18;
      a1[1] = 0;
      a1[2] = 0;
      *a1 = 0;
      result = *(__n128 *)(a1 + 3);
      *(_QWORD *)(a4 + 40) = a1[5];
      *(__n128 *)(a4 + 24) = result;
      a1[4] = 0;
      a1[5] = 0;
      a1[3] = 0;
      v19 = a1 + 6;
      if (a1 + 6 != a2)
      {
        v20 = 0;
        v21 = (_OWORD *)a4;
        do
        {
          v22 = v19;
          v23 = *((_BYTE *)v8 + 71);
          v24 = v23 < 0;
          if (v23 >= 0)
            v25 = v22;
          else
            v25 = (const void **)v8[6];
          v26 = v23 & 0x7F;
          if (v24)
            v27 = (size_t)v8[7];
          else
            v27 = v26;
          if (*((char *)v21 + 23) < 0)
          {
            v29 = *(const void **)v21;
            v28 = *((_QWORD *)v21 + 1);
          }
          else
          {
            v28 = *((unsigned __int8 *)v21 + 23);
            v29 = v21;
          }
          v30 = v21 + 3;
          if (v27 >= v28)
            v31 = v28;
          else
            v31 = v27;
          v32 = memcmp(v29, v25, v31);
          v33 = v32 < 0;
          if (!v32)
            v33 = v28 < v27;
          v34 = (_OWORD *)((char *)v21 + 72);
          if (v33)
          {
            *v30 = *v21;
            *((_QWORD *)v21 + 8) = *((_QWORD *)v21 + 2);
            *(_QWORD *)v21 = 0;
            *((_QWORD *)v21 + 1) = 0;
            v35 = *(_OWORD *)((char *)v21 + 24);
            *((_QWORD *)v21 + 2) = 0;
            *((_QWORD *)v21 + 3) = 0;
            *v34 = v35;
            *((_QWORD *)v21 + 11) = *((_QWORD *)v21 + 5);
            v36 = v5;
            *((_QWORD *)v21 + 4) = 0;
            *((_QWORD *)v21 + 5) = 0;
            if (v21 != (_OWORD *)v5)
            {
              v37 = v20;
              while (1)
              {
                v38 = v5 + v37;
                v39 = (const void **)(v5 + v37 - 48);
                v40 = *((_BYTE *)v8 + 71);
                v41 = v40;
                if (v40 >= 0)
                  v42 = v22;
                else
                  v42 = *v22;
                v43 = v40 & 0x7F;
                if (v41 >= 0)
                  v44 = v43;
                else
                  v44 = (size_t)v8[7];
                if (*(char *)(v38 - 25) < 0)
                {
                  v45 = *(_QWORD *)(v38 - 40);
                  v46 = *v39;
                }
                else
                {
                  v45 = *(unsigned __int8 *)(v38 - 25);
                  v46 = (const void *)(v5 + v37 - 48);
                }
                if (v44 >= v45)
                  v47 = v45;
                else
                  v47 = v44;
                v48 = memcmp(v46, v42, v47);
                v49 = v45 < v44;
                if (v48)
                  v49 = v48 < 0;
                if (!v49)
                  break;
                v50 = v5 + v37;
                if (*(char *)(v5 + v37 + 23) < 0)
                  operator delete(*(void **)v38);
                *(_OWORD *)v38 = *(_OWORD *)v39;
                *(_QWORD *)(v38 + 16) = *(_QWORD *)(v5 + v37 - 32);
                *(_BYTE *)(v38 - 25) = 0;
                *(_BYTE *)v39 = 0;
                v51 = (void **)(v50 + 24);
                if (*(char *)(v50 + 47) < 0)
                  operator delete(*v51);
                v52 = v5 + v37;
                *(_OWORD *)v51 = *(_OWORD *)(v5 + v37 - 24);
                *(_QWORD *)(v50 + 40) = *(_QWORD *)(v5 + v37 - 8);
                *(_BYTE *)(v52 - 1) = 0;
                *(_BYTE *)(v52 - 24) = 0;
                v37 -= 48;
                if (!v37)
                {
                  v36 = v5;
                  goto LABEL_57;
                }
              }
              v36 = v5 + v37;
LABEL_57:
              v7 = a2;
            }
            if (*(char *)(v36 + 23) < 0)
              operator delete(*(void **)v36);
            v54 = *(_OWORD *)v22;
            *(_QWORD *)(v36 + 16) = v22[2];
            *(_OWORD *)v36 = v54;
            *((_BYTE *)v8 + 71) = 0;
            *(_BYTE *)v22 = 0;
            v55 = (void **)(v36 + 24);
            if (*(char *)(v36 + 47) < 0)
              operator delete(*v55);
            result = *(__n128 *)(v8 + 9);
            *(_QWORD *)(v36 + 40) = v8[11];
            *(__n128 *)v55 = result;
            *((_BYTE *)v8 + 95) = 0;
            *((_BYTE *)v8 + 72) = 0;
          }
          else
          {
            v53 = *(_OWORD *)v22;
            *((_QWORD *)v21 + 8) = v22[2];
            *v30 = v53;
            v22[1] = 0;
            v22[2] = 0;
            *v22 = 0;
            result = *(__n128 *)(v8 + 9);
            *((_QWORD *)v21 + 11) = v8[11];
            *v34 = result;
            v8[10] = 0;
            v8[11] = 0;
            v8[9] = 0;
          }
          v19 = v22 + 6;
          v20 += 48;
          v21 = v30;
          v8 = v22;
        }
        while (v22 + 6 != v7);
      }
    }
  }
  return result;
}

void sub_1C5E2806C(uint64_t a1, const void **a2, char *a3, uint64_t a4, uint64_t a5, const void **a6, uint64_t a7)
{
  uint64_t v12;
  char v13;
  BOOL v14;
  const void *v15;
  size_t v16;
  size_t v17;
  uint64_t v18;
  _QWORD *v19;
  int v20;
  size_t v21;
  size_t v22;
  int v23;
  BOOL v24;
  uint64_t v26;
  const void **v27;
  uint64_t v28;
  const void **v29;
  unint64_t v30;
  char v31;
  BOOL v32;
  const void *v33;
  size_t v34;
  size_t v35;
  const void **v36;
  const void **v37;
  size_t v38;
  const void **v39;
  size_t v40;
  int v41;
  _BOOL4 v42;
  unint64_t v43;
  const void **v44;
  uint64_t v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;
  size_t v49;
  unint64_t v50;
  char v51;
  BOOL v52;
  const void *v53;
  size_t v54;
  size_t v55;
  size_t v56;
  uint64_t v57;
  const void *v58;
  size_t v59;
  const void **v60;
  int v61;
  _BOOL4 v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  const void **v67;
  const void **v68;
  const void *v69;
  char v70;
  void *v71;
  uint64_t v72;
  char v73;
  __int128 v74;
  void **v75;
  __int128 v76;
  const void **v77;
  const void **v78;
  int v79;
  const void **v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  char v85;
  uint64_t v86;
  void **v87;
  char v88;
  __int128 v89;
  __int128 v90;
  int v91;
  unint64_t v92;
  const void **v93;
  unint64_t v94;
  const void **v95;
  unint64_t v96;
  uint64_t v97;
  const void **v98;
  __int128 *v99;
  const void **v100;
  __int128 v101;
  __int128 v102;
  __int128 *v103;
  const void **v104;
  char v105;
  int v106;
  const void **v107;
  size_t v108;
  size_t v109;
  const void **v110;
  size_t v111;
  const void **v112;
  size_t v113;
  int v114;
  _BOOL4 v115;
  void **v116;
  int v117;
  const void **v118;
  __int128 v119;
  void **v120;
  __int128 v121;
  const void **v122;
  __int128 v123;
  void **v124;
  __int128 v125;
  unint64_t v126;
  const void **v127;
  __int128 *v128;
  _QWORD *v129;
  __int128 v130;
  __int128 v131;
  __int128 *v132;
  uint64_t v133;
  __int128 *v134;
  char v135;
  BOOL v136;
  const void **v137;
  const void *v138;
  size_t v139;
  size_t v140;
  size_t v141;
  __int128 *v142;
  size_t v143;
  int v144;
  _BOOL4 v145;
  int v146;
  __int128 v147;
  void **v148;
  __int128 v149;
  __int128 v150;
  void **v151;
  __int128 v152;
  uint64_t v153;
  const void *v154;
  void *v155;
  uint64_t v156;
  char v157;
  __int128 v158;
  _QWORD *v159;
  __int128 v160;
  uint64_t v161;
  char *v162;
  void **v163;
  __int128 *v164;
  __int128 v165;
  void **v166;
  const void **v167;
  __int128 v168;
  uint64_t v169;
  uint64_t v170;
  __int128 *v171;
  __int128 v172;
  void **v173;
  __int128 v174;
  char *v175;
  int v176;
  uint64_t v177;
  unint64_t v178;
  uint64_t v179;
  uint64_t v180;
  unint64_t v181;
  char *v182;
  const void **v183;
  uint64_t v184;
  uint64_t v185;
  const void **v186;
  const void **v188;
  uint64_t v189;
  _BYTE v190[15];
  _BYTE v191[15];
  _BYTE v192[15];
  _BYTE v193[15];
  _BYTE v194[15];
  _BYTE v195[15];

  v185 = a5;
  if (a5)
  {
    while (a4 > a7 && v185 > a7)
    {
      if (!a4)
        return;
      v12 = 0;
      v13 = *((_BYTE *)a2 + 23);
      v14 = v13 < 0;
      if (v13 >= 0)
        v15 = a2;
      else
        v15 = *a2;
      v16 = v13 & 0x7F;
      if (v14)
        v17 = (size_t)a2[1];
      else
        v17 = v16;
      v18 = -a4;
      while (1)
      {
        v19 = (_QWORD *)(a1 + v12);
        v20 = *(char *)(a1 + v12 + 23);
        if (v20 < 0)
        {
          v19 = (_QWORD *)*v19;
          v21 = *(_QWORD *)(a1 + v12 + 8);
        }
        else
        {
          v21 = *(unsigned __int8 *)(a1 + v12 + 23);
        }
        if (v17 >= v21)
          v22 = v21;
        else
          v22 = v17;
        v23 = memcmp(v19, v15, v22);
        v24 = v21 < v17;
        if (v23)
          v24 = v23 < 0;
        if (v24)
          break;
        v12 += 48;
        if (__CFADD__(v18++, 1))
          return;
      }
      v26 = -v18;
      v27 = a2;
      v182 = a3;
      v183 = a6;
      v179 = a7;
      v184 = a1 + v12;
      if (-v18 >= v185)
      {
        if (v18 == -1)
        {
          v153 = a1 + v12;
          v154 = *(const void **)(a1 + v12);
          *(_QWORD *)&v195[7] = *(_QWORD *)(a1 + v12 + 15);
          *(_QWORD *)v195 = *(_QWORD *)(a1 + v12 + 8);
          *(_QWORD *)v153 = 0;
          *(_QWORD *)(v153 + 8) = 0;
          *(_QWORD *)(v153 + 16) = 0;
          v156 = a1 + v12 + 24;
          v155 = *(void **)v156;
          *(_QWORD *)v192 = *(_QWORD *)(a1 + v12 + 32);
          *(_QWORD *)&v192[7] = *(_QWORD *)(a1 + v12 + 39);
          v157 = *(_BYTE *)(a1 + v12 + 47);
          *(_QWORD *)v156 = 0;
          *(_QWORD *)(v153 + 32) = 0;
          *(_QWORD *)(v153 + 40) = 0;
          v158 = *(_OWORD *)a2;
          *(_QWORD *)(v153 + 16) = a2[2];
          *(_OWORD *)v153 = v158;
          *((_BYTE *)a2 + 23) = 0;
          *(_BYTE *)a2 = 0;
          if (*(char *)(v153 + 47) < 0)
          {
            operator delete(*(void **)v156);
            v27 = a2;
          }
          v159 = v27 + 1;
          v160 = *(_OWORD *)(v27 + 3);
          *(_QWORD *)(v156 + 16) = v27[5];
          *(_OWORD *)v156 = v160;
          *((_BYTE *)v27 + 47) = 0;
          *((_BYTE *)v27 + 24) = 0;
          if (*((char *)v27 + 23) < 0)
          {
            operator delete((void *)*a2);
            v27 = a2;
            v176 = *((char *)a2 + 47);
            *a2 = v154;
            *v159 = *(_QWORD *)v195;
            *(_QWORD *)((char *)v159 + 7) = *(_QWORD *)&v195[7];
            *((_BYTE *)a2 + 23) = v20;
            if (v176 < 0)
            {
              operator delete((void *)a2[3]);
              v27 = a2;
            }
          }
          else
          {
            *v27 = v154;
            *v159 = *(_QWORD *)v195;
            *(const void **)((char *)v27 + 15) = *(const void **)&v195[7];
            *((_BYTE *)v27 + 23) = v20;
          }
          v27[3] = v155;
          v27[4] = *(const void **)v192;
          *(const void **)((char *)v27 + 39) = *(const void **)&v192[7];
          *((_BYTE *)v27 + 47) = v157;
          return;
        }
        if (v18 > 0)
          v26 = 1 - v18;
        v180 = v26 >> 1;
        v29 = (const void **)(a1 + 48 * (v26 >> 1) + v12);
        v45 = (uint64_t)a3;
        if (a3 != (char *)a2)
        {
          v47 = 0xAAAAAAAAAAAAAAABLL * ((a3 - (char *)a2) >> 4);
          v48 = a1 + 48 * v180 + v12;
          v49 = *(unsigned __int8 *)(v48 + 23);
          v45 = (uint64_t)a2;
          do
          {
            v50 = v45 + 48 * (v47 >> 1);
            v51 = *(_BYTE *)(v50 + 23);
            v52 = v51 < 0;
            if (v51 >= 0)
              v53 = (const void *)(v45 + 48 * (v47 >> 1));
            else
              v53 = *(const void **)v50;
            v54 = v51 & 0x7F;
            if (v52)
              v55 = *(_QWORD *)(v50 + 8);
            else
              v55 = v54;
            v56 = v49;
            v57 = v45;
            v58 = v29;
            if ((v49 & 0x80) != 0)
            {
              v56 = *(_QWORD *)(v48 + 8);
              v58 = *v29;
            }
            if (v55 >= v56)
              v59 = v56;
            else
              v59 = v55;
            v60 = v29;
            v61 = memcmp(v58, v53, v59);
            v29 = v60;
            v62 = v56 < v55;
            if (v61)
              v62 = v61 < 0;
            if (v62)
              v47 += ~(v47 >> 1);
            else
              v47 >>= 1;
            if (v62)
              v45 = v50 + 48;
            else
              v45 = v57;
          }
          while (v47);
        }
        v44 = a2;
        v46 = 0xAAAAAAAAAAAAAAABLL * ((v45 - (uint64_t)a2) >> 4);
        a6 = v183;
        v43 = v180;
      }
      else
      {
        if (v185 >= 0)
          v28 = v185;
        else
          v28 = v185 + 1;
        v177 = v28 >> 1;
        v188 = &a2[6 * (v28 >> 1)];
        v29 = a2;
        if ((const void **)(a1 + v12) != a2)
        {
          v30 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)a2 - a1 - v12) >> 4);
          v31 = *((_BYTE *)v188 + 23);
          v32 = v31 < 0;
          if (v31 >= 0)
            v33 = v188;
          else
            v33 = *v188;
          v34 = v31 & 0x7F;
          if (v32)
            v35 = (size_t)v188[1];
          else
            v35 = v34;
          v29 = (const void **)(a1 + v12);
          do
          {
            v36 = &v29[6 * (v30 >> 1)];
            v37 = v29;
            if (*((char *)v36 + 23) < 0)
            {
              v39 = (const void **)*v36;
              v38 = (size_t)v36[1];
            }
            else
            {
              v38 = *((unsigned __int8 *)v36 + 23);
              v39 = &v29[6 * (v30 >> 1)];
            }
            if (v35 >= v38)
              v40 = v38;
            else
              v40 = v35;
            v41 = memcmp(v39, v33, v40);
            v42 = v38 < v35;
            if (v41)
              v42 = v41 < 0;
            if (v42)
              v29 = v37;
            else
              v29 = v36 + 6;
            if (v42)
              v30 >>= 1;
            else
              v30 += ~(v30 >> 1);
          }
          while (v30);
        }
        v43 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v29 - a1 - v12) >> 4);
        a6 = v183;
        v44 = a2;
        v45 = (uint64_t)v188;
        v46 = v177;
      }
      v63 = v45;
      a3 = v182;
      v65 = v184;
      v64 = v185;
      v189 = v45;
      if (v29 != v44)
      {
        v63 = (uint64_t)v29;
        if (v44 != (const void **)v45)
        {
          v181 = v43;
          v178 = v46;
          v66 = 0;
          v63 = (uint64_t)v44;
          v186 = v29;
          while (1)
          {
            v67 = &v29[v66];
            v68 = &v44[v66];
            v69 = v29[v66];
            *(_QWORD *)&v193[7] = *(const void **)((char *)&v29[v66 + 1] + 7);
            *(_QWORD *)v193 = v29[v66 + 1];
            v70 = HIBYTE(v29[v66 + 2]);
            *v67 = 0;
            v67[1] = 0;
            v67[2] = 0;
            v72 = (uint64_t)&v29[v66 + 3];
            v71 = *(void **)v72;
            *(_QWORD *)v190 = v29[v66 + 4];
            *(_QWORD *)&v190[7] = *(const void **)((char *)&v29[v66 + 4] + 7);
            v73 = HIBYTE(v29[v66 + 5]);
            *(_QWORD *)v72 = 0;
            v67[4] = 0;
            v67[5] = 0;
            v74 = *(_OWORD *)&v44[v66];
            v67[2] = v44[v66 + 2];
            *(_OWORD *)v67 = v74;
            *((_BYTE *)v68 + 23) = 0;
            *(_BYTE *)v68 = 0;
            if (SHIBYTE(v29[v66 + 5]) < 0)
            {
              operator delete(*(void **)v72);
              v29 = v186;
              v44 = a2;
              v45 = v189;
            }
            v75 = (void **)(v68 + 3);
            v76 = *(_OWORD *)(v68 + 3);
            *(_QWORD *)(v72 + 16) = v68[5];
            *(_OWORD *)v72 = v76;
            *((_BYTE *)v68 + 47) = 0;
            *((_BYTE *)v68 + 24) = 0;
            if (*((char *)v68 + 23) < 0)
            {
              v78 = &v44[v66];
              operator delete((void *)v44[v66]);
              v29 = v186;
              v44 = a2;
              v45 = v189;
              v79 = *((char *)v68 + 47);
              *v78 = v69;
              v78[1] = *(const void **)v193;
              *(const void **)((char *)v78 + 15) = *(const void **)&v193[7];
              *((_BYTE *)v68 + 23) = v70;
              if (v79 < 0)
              {
                operator delete(*v75);
                v29 = v186;
                v44 = a2;
                v45 = v189;
              }
            }
            else
            {
              v77 = &v44[v66];
              *v77 = v69;
              *(const void **)((char *)v77 + 15) = *(const void **)&v193[7];
              v77[1] = *(const void **)v193;
              *((_BYTE *)v68 + 23) = v70;
            }
            *v75 = v71;
            v80 = &v44[v66];
            *(const void **)((char *)v80 + 39) = *(const void **)&v190[7];
            v80[4] = *(const void **)v190;
            *((_BYTE *)v68 + 47) = v73;
            v81 = (uint64_t)&v29[v66 + 6];
            if (&v44[v66 + 6] == (const void **)v45)
              break;
            if (v81 == v63)
              v63 = (uint64_t)&v44[v66 + 6];
            v66 += 6;
          }
          if (v81 != v63)
          {
            v82 = (uint64_t)&v29[v66 + 6];
            v83 = v63;
            do
            {
              while (1)
              {
                v84 = *(_QWORD *)v82;
                *(_QWORD *)v194 = *(_QWORD *)(v82 + 8);
                *(_QWORD *)&v194[7] = *(_QWORD *)(v82 + 15);
                v85 = *(_BYTE *)(v82 + 23);
                *(_QWORD *)v82 = 0;
                *(_QWORD *)(v82 + 8) = 0;
                *(_QWORD *)(v82 + 16) = 0;
                v87 = (void **)(v82 + 24);
                v86 = *(_QWORD *)(v82 + 24);
                *(_QWORD *)v191 = *(_QWORD *)(v82 + 32);
                *(_QWORD *)&v191[7] = *(_QWORD *)(v82 + 39);
                v88 = *(_BYTE *)(v82 + 47);
                *(_QWORD *)(v82 + 24) = 0;
                *(_QWORD *)(v82 + 32) = 0;
                *(_QWORD *)(v82 + 40) = 0;
                v89 = *(_OWORD *)v63;
                *(_QWORD *)(v82 + 16) = *(_QWORD *)(v63 + 16);
                *(_OWORD *)v82 = v89;
                *(_BYTE *)(v63 + 23) = 0;
                *(_BYTE *)v63 = 0;
                if (*(char *)(v82 + 47) < 0)
                {
                  operator delete(*v87);
                  v29 = v186;
                  v45 = v189;
                }
                v90 = *(_OWORD *)(v63 + 24);
                *(_QWORD *)(v82 + 40) = *(_QWORD *)(v63 + 40);
                *(_OWORD *)v87 = v90;
                *(_BYTE *)(v63 + 47) = 0;
                *(_BYTE *)(v63 + 24) = 0;
                if (*(char *)(v63 + 23) < 0)
                {
                  operator delete(*(void **)v63);
                  v29 = v186;
                  v45 = v189;
                  v91 = *(char *)(v63 + 47);
                  *(_QWORD *)v63 = v84;
                  *(_QWORD *)(v63 + 8) = *(_QWORD *)v194;
                  *(_QWORD *)(v63 + 15) = *(_QWORD *)&v194[7];
                  *(_BYTE *)(v63 + 23) = v85;
                  if (v91 < 0)
                  {
                    operator delete(*(void **)(v63 + 24));
                    v29 = v186;
                    v45 = v189;
                  }
                }
                else
                {
                  *(_QWORD *)v63 = v84;
                  *(_QWORD *)(v63 + 8) = *(_QWORD *)v194;
                  *(_QWORD *)(v63 + 15) = *(_QWORD *)&v194[7];
                  *(_BYTE *)(v63 + 23) = v85;
                }
                *(_QWORD *)(v63 + 24) = v86;
                *(_QWORD *)(v63 + 32) = *(_QWORD *)v191;
                *(_QWORD *)(v63 + 39) = *(_QWORD *)&v191[7];
                *(_BYTE *)(v63 + 47) = v88;
                v82 += 48;
                v63 += 48;
                if (v63 == v45)
                  break;
                if (v82 == v83)
                  v83 = v63;
              }
              v63 = v83;
            }
            while (v82 != v83);
            v63 = v81;
          }
          a3 = v182;
          a6 = v183;
          v65 = v184;
          v64 = v185;
          v46 = v178;
          v43 = v181;
        }
      }
      a4 = -(uint64_t)v43 - v18;
      v92 = v64 - v46;
      if ((uint64_t)(v43 + v46) >= (uint64_t)(v64 - (v43 + v46) - v18))
      {
        v92 = v46;
        v94 = v43;
        a7 = v179;
        v95 = v29;
        sub_1C5E2806C(v63, v189, a3, -(uint64_t)v43 - v18, v64 - v46, a6, v179);
        v93 = v95;
        a4 = v94;
        a3 = (char *)v63;
      }
      else
      {
        a7 = v179;
        sub_1C5E2806C(v65, v29, v63, v43, v46, a6, v179);
        v65 = v63;
        v93 = (const void **)v189;
      }
      v185 = v92;
      a1 = v65;
      a2 = v93;
      if (!v92)
        return;
    }
    if (a4 <= v185)
    {
      if ((const void **)a1 == a2)
        return;
      v126 = 0;
      v97 = 0;
      v127 = a2;
      do
      {
        v128 = (__int128 *)&a6[v126 / 8];
        v129 = (_QWORD *)(a1 + v126);
        v130 = *(_OWORD *)(a1 + v126);
        *((_QWORD *)v128 + 2) = *(_QWORD *)(a1 + v126 + 16);
        *v128 = v130;
        v129[1] = 0;
        v129[2] = 0;
        *v129 = 0;
        v131 = *(_OWORD *)(a1 + v126 + 24);
        *((_QWORD *)v128 + 5) = *(_QWORD *)(a1 + v126 + 40);
        *(__int128 *)((char *)v128 + 24) = v131;
        v129[4] = 0;
        v129[5] = 0;
        v129[3] = 0;
        ++v97;
        v126 += 48;
      }
      while (v129 + 6 != a2);
      if (v126)
      {
        v132 = (__int128 *)&a6[v126 / 8];
        v133 = (uint64_t)&a6[v126 / 8 - 6];
        v134 = (__int128 *)a6;
        while (v127 != (const void **)a3)
        {
          v135 = *((_BYTE *)v127 + 23);
          v136 = v135 < 0;
          v137 = v127;
          if (v135 >= 0)
            v138 = v127;
          else
            v138 = *v127;
          v139 = v135 & 0x7F;
          if (v136)
            v140 = (size_t)v127[1];
          else
            v140 = v139;
          if (*((char *)v134 + 23) < 0)
          {
            v142 = *(__int128 **)v134;
            v141 = *((_QWORD *)v134 + 1);
          }
          else
          {
            v141 = *((unsigned __int8 *)v134 + 23);
            v142 = v134;
          }
          if (v140 >= v141)
            v143 = v141;
          else
            v143 = v140;
          v144 = memcmp(v142, v138, v143);
          v145 = v144 < 0;
          if (!v144)
            v145 = v141 < v140;
          v146 = *(char *)(a1 + 23);
          v127 = v137;
          if (v145)
          {
            if (v146 < 0)
            {
              operator delete(*(void **)a1);
              v127 = v137;
            }
            v147 = *(_OWORD *)v127;
            *(_QWORD *)(a1 + 16) = v127[2];
            *(_OWORD *)a1 = v147;
            *((_BYTE *)v127 + 23) = 0;
            *(_BYTE *)v127 = 0;
            v148 = (void **)(a1 + 24);
            if (*(char *)(a1 + 47) < 0)
            {
              operator delete(*v148);
              v127 = v137;
            }
            v149 = *(_OWORD *)(v127 + 3);
            *(_QWORD *)(a1 + 40) = v127[5];
            *(_OWORD *)v148 = v149;
            *((_BYTE *)v127 + 47) = 0;
            *((_BYTE *)v127 + 24) = 0;
            v127 += 6;
          }
          else
          {
            if (v146 < 0)
            {
              operator delete(*(void **)a1);
              v127 = v137;
            }
            v150 = *v134;
            *(_QWORD *)(a1 + 16) = *((_QWORD *)v134 + 2);
            *(_OWORD *)a1 = v150;
            *((_BYTE *)v134 + 23) = 0;
            *(_BYTE *)v134 = 0;
            v151 = (void **)(a1 + 24);
            if (*(char *)(a1 + 47) < 0)
            {
              operator delete(*v151);
              v127 = v137;
            }
            v152 = *(__int128 *)((char *)v134 + 24);
            *(_QWORD *)(a1 + 40) = *((_QWORD *)v134 + 5);
            *(_OWORD *)v151 = v152;
            *((_BYTE *)v134 + 47) = 0;
            *((_BYTE *)v134 + 24) = 0;
            v134 += 3;
          }
          a1 += 48;
          if (v132 == v134)
            goto LABEL_197;
        }
        if (v132 != v134)
        {
          v169 = 0;
          do
          {
            v170 = a1 + v169 * 16;
            if (*(char *)(a1 + v169 * 16 + 23) < 0)
              operator delete(*(void **)v170);
            v171 = &v134[v169];
            v172 = v134[v169];
            *(_QWORD *)(v170 + 16) = *(_QWORD *)&v134[v169 + 1];
            *(_OWORD *)v170 = v172;
            *((_BYTE *)v171 + 23) = 0;
            *(_BYTE *)v171 = 0;
            v173 = (void **)(v170 + 24);
            if (*(char *)(v170 + 47) < 0)
              operator delete(*v173);
            v174 = *(__int128 *)((char *)v171 + 24);
            *(_QWORD *)(v170 + 40) = *((_QWORD *)v171 + 5);
            *(_OWORD *)v173 = v174;
            *((_BYTE *)v171 + 47) = 0;
            *((_BYTE *)v171 + 24) = 0;
            v169 += 3;
          }
          while ((__int128 *)v133 != v171);
        }
      }
    }
    else
    {
      if (a2 == (const void **)a3)
        return;
      v96 = 0;
      v97 = 0;
      v98 = a2;
      do
      {
        v99 = (__int128 *)&a6[v96];
        v100 = &a2[v96];
        v101 = *(_OWORD *)&a2[v96];
        *((_QWORD *)v99 + 2) = a2[v96 + 2];
        *v99 = v101;
        v100[1] = 0;
        v100[2] = 0;
        *v100 = 0;
        v102 = *(_OWORD *)&a2[v96 + 3];
        *((_QWORD *)v99 + 5) = a2[v96 + 5];
        *(__int128 *)((char *)v99 + 24) = v102;
        v100[4] = 0;
        v100[5] = 0;
        v100[3] = 0;
        ++v97;
        v96 += 6;
      }
      while (v100 + 6 != (const void **)a3);
      if (v96 * 8)
      {
        v103 = (__int128 *)&a6[v96];
        while (v98 != (const void **)a1)
        {
          v104 = v98 - 6;
          v105 = *((_BYTE *)v103 - 25);
          v106 = v105;
          if (v105 >= 0)
            v107 = (const void **)(v103 - 3);
          else
            v107 = (const void **)*((_QWORD *)v103 - 6);
          v108 = v105 & 0x7F;
          if (v106 >= 0)
            v109 = v108;
          else
            v109 = *((_QWORD *)v103 - 5);
          v110 = v98;
          if (*((char *)v98 - 25) < 0)
          {
            v112 = (const void **)*(v98 - 6);
            v111 = (size_t)*(v98 - 5);
          }
          else
          {
            v111 = *((unsigned __int8 *)v98 - 25);
            v112 = v98 - 6;
          }
          if (v109 >= v111)
            v113 = v111;
          else
            v113 = v109;
          v114 = memcmp(v112, v107, v113);
          v115 = v114 < 0;
          if (!v114)
            v115 = v111 < v109;
          v116 = (void **)(a3 - 48);
          v117 = *(a3 - 25);
          if (v115)
          {
            v118 = v110;
            if (v117 < 0)
            {
              operator delete(*v116);
              v118 = v110;
            }
            v119 = *(_OWORD *)v104;
            *((_QWORD *)a3 - 4) = v104[2];
            *(_OWORD *)v116 = v119;
            *((_BYTE *)v118 - 25) = 0;
            *((_BYTE *)v118 - 48) = 0;
            v120 = (void **)(a3 - 24);
            if (*(a3 - 1) < 0)
            {
              operator delete(*v120);
              v118 = v110;
            }
            v121 = *(_OWORD *)(v118 - 3);
            *((_QWORD *)a3 - 1) = *(v118 - 1);
            *(_OWORD *)v120 = v121;
            v122 = v118;
            v98 = v104;
          }
          else
          {
            v98 = v110;
            if (v117 < 0)
            {
              operator delete(*v116);
              v98 = v110;
            }
            v123 = *(v103 - 3);
            *((_QWORD *)a3 - 4) = *((_QWORD *)v103 - 4);
            *(_OWORD *)v116 = v123;
            *((_BYTE *)v103 - 25) = 0;
            *((_BYTE *)v103 - 48) = 0;
            v124 = (void **)(a3 - 24);
            if (*(a3 - 1) < 0)
            {
              operator delete(*v124);
              v98 = v110;
            }
            v125 = *(__int128 *)((char *)v103 - 24);
            *((_QWORD *)a3 - 1) = *((_QWORD *)v103 - 1);
            *(_OWORD *)v124 = v125;
            v122 = (const void **)v103;
            v103 -= 3;
          }
          *((_BYTE *)v122 - 1) = 0;
          *((_BYTE *)v122 - 24) = 0;
          a3 -= 48;
          if (v103 == (__int128 *)a6)
            goto LABEL_197;
        }
        if (v103 != (__int128 *)a6)
        {
          v161 = 0;
          do
          {
            v162 = &a3[v161 * 16];
            v163 = (void **)&a3[v161 * 16 - 48];
            if (a3[v161 * 16 - 25] < 0)
              operator delete(*v163);
            v164 = &v103[v161 - 3];
            v165 = *v164;
            *(_QWORD *)&a3[v161 * 16 - 32] = *(_QWORD *)&v103[v161 - 2];
            *(_OWORD *)v163 = v165;
            *((_BYTE *)&v103[v161 - 1] - 9) = 0;
            *(_BYTE *)v164 = 0;
            v166 = (void **)(v162 - 24);
            if (*(v162 - 1) < 0)
              operator delete(*v166);
            v167 = (const void **)&v103[v161];
            v168 = *(__int128 *)((char *)&v103[v161 - 1] - 8);
            *((_QWORD *)v162 - 1) = *((_QWORD *)&v103[v161 - 1] + 1);
            *(_OWORD *)v166 = v168;
            *((_BYTE *)v167 - 1) = 0;
            *((_BYTE *)v167 - 24) = 0;
            v161 -= 3;
          }
          while (&v103[v161] != (__int128 *)a6);
        }
      }
    }
LABEL_197:
    if (a6)
    {
      v175 = (char *)a6 + 23;
      do
      {
        if (v175[24] < 0)
          operator delete(*(void **)(v175 + 1));
        if (*v175 < 0)
          operator delete(*(void **)(v175 - 23));
        v175 += 48;
        --v97;
      }
      while (v97);
    }
  }
}

uint64_t sub_1C5E28CB8(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  std::string *v6;
  std::string *v7;
  std::string *i;
  std::string *v9;
  uint64_t v10;
  std::string *v11;
  uint64_t v12;
  std::string *v13;
  std::string *v14;
  uint64_t v15;
  uint64_t v16;
  std::string *v17;
  std::string *v18;
  __int128 v19;
  std::string *v20;
  void **p_data;
  __int128 v22;

  if (a1 != a2)
  {
    v4 = *(unsigned int *)(a2 + 8);
    v5 = *(unsigned int *)(a1 + 8);
    if (v5 >= v4)
    {
      if ((_DWORD)v4)
      {
        v6 = sub_1C5E28E84(*(std::string **)a2, (std::string *)(*(_QWORD *)a2 + 48 * v4), *(std::string **)a1);
        v7 = *(std::string **)a1;
        LODWORD(v5) = *(_DWORD *)(a1 + 8);
      }
      else
      {
        v7 = *(std::string **)a1;
        v6 = *(std::string **)a1;
      }
      for (i = &v7[2 * v5]; i != v6; i -= 2)
      {
        if (SHIBYTE(i[-1].__r_.__value_.__r.__words[2]) < 0)
          operator delete(i[-1].__r_.__value_.__l.__data_);
        if (SHIBYTE(i[-2].__r_.__value_.__r.__words[2]) < 0)
          operator delete(i[-2].__r_.__value_.__l.__data_);
      }
      goto LABEL_34;
    }
    if (*(_DWORD *)(a1 + 12) < v4)
    {
      if ((_DWORD)v5)
      {
        v9 = *(std::string **)a1;
        v10 = 2 * v5;
        do
        {
          v11 = &v9[v10];
          if (SHIBYTE(v9[v10 - 1].__r_.__value_.__r.__words[2]) < 0)
            operator delete(v11[-1].__r_.__value_.__l.__data_);
          if (SHIBYTE(v11[-2].__r_.__value_.__r.__words[2]) < 0)
            operator delete(v11[-2].__r_.__value_.__l.__data_);
          v10 -= 2;
        }
        while (v10 * 24);
      }
      *(_DWORD *)(a1 + 8) = 0;
      sub_1C638D60C(a1, v4);
    }
    else if ((_DWORD)v5)
    {
      sub_1C5E28E84(*(std::string **)a2, (std::string *)(*(_QWORD *)a2 + 48 * v5), *(std::string **)a1);
      goto LABEL_25;
    }
    v5 = 0;
LABEL_25:
    v12 = *(unsigned int *)(a2 + 8);
    if (v5 != v12)
    {
      v13 = *(std::string **)a2;
      v14 = *(std::string **)a1;
      v15 = 48 * v5;
      v16 = 48 * v12;
      do
      {
        v17 = &v13[(unint64_t)v15 / 0x18];
        v18 = &v14[(unint64_t)v15 / 0x18];
        if (SHIBYTE(v13[(unint64_t)v15 / 0x18].__r_.__value_.__r.__words[2]) < 0)
        {
          sub_1C47EBC30(v18, v17->__r_.__value_.__l.__data_, v17->__r_.__value_.__l.__size_);
        }
        else
        {
          v19 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
          v18->__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v18->__r_.__value_.__l.__data_ = v19;
        }
        v20 = &v14[(unint64_t)v15 / 0x18 + 1];
        p_data = (void **)&v13[(unint64_t)v15 / 0x18 + 1].__r_.__value_.__l.__data_;
        if (SHIBYTE(v13[(unint64_t)v15 / 0x18 + 1].__r_.__value_.__r.__words[2]) < 0)
        {
          sub_1C47EBC30(v20, *p_data, v13[(unint64_t)v15 / 0x18 + 1].__r_.__value_.__l.__size_);
        }
        else
        {
          v22 = *(_OWORD *)p_data;
          v14[(unint64_t)v15 / 0x18 + 1].__r_.__value_.__r.__words[2] = v13[(unint64_t)v15 / 0x18 + 1].__r_.__value_.__r.__words[2];
          *(_OWORD *)&v20->__r_.__value_.__l.__data_ = v22;
        }
        v14 += 2;
        v13 += 2;
        v16 -= 48;
      }
      while (v15 != v16);
    }
LABEL_34:
    *(_DWORD *)(a1 + 8) = v4;
  }
  return a1;
}

std::string *sub_1C5E28E84(std::string *__str, std::string *a2, std::string *this)
{
  std::string *v5;

  if (__str != a2)
  {
    v5 = __str;
    do
    {
      std::string::operator=(this, v5);
      std::string::operator=(this + 1, v5 + 1);
      this += 2;
      v5 += 2;
    }
    while (v5 != a2);
  }
  return this;
}

uint64_t sub_1C5E28EE4(uint64_t a1)
{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  *(_QWORD *)(a1 + 24) = &off_1E81A1B00;
  sub_1C638D5A8((char **)(a1 + 40));
  *(_QWORD *)a1 = &off_1E81A4310;
  v2 = *(unsigned int **)(a1 + 16);
  if (v2)
  {
    v3 = v2 + 2;
    do
    {
      v4 = __ldaxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 8))(v2);
  }
  return a1;
}

void sub_1C5E28F58(uint64_t a1)
{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  *(_QWORD *)(a1 + 24) = &off_1E81A1B00;
  sub_1C638D5A8((char **)(a1 + 40));
  *(_QWORD *)a1 = &off_1E81A4310;
  v2 = *(unsigned int **)(a1 + 16);
  if (v2)
  {
    v3 = v2 + 2;
    do
    {
      v4 = __ldaxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 8))(v2);
  }
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5E28FDC(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD v7[4];
  __int16 v8;
  _QWORD *v9;
  void *v10;
  __int128 v11;
  _QWORD v12[33];

  v12[32] = *MEMORY[0x1E0C80C00];
  v10 = v12;
  v11 = xmmword_1C64638F0;
  llvm::Twine::toVector(a2, (uint64_t)&v10);
  llvm::PrefixMapper::mapInPlace(a1 + 24, &v10, v7);
  if (v7[0])
  {
    v9 = (_QWORD *)v7[0];
    v5 = llvm::errorToErrorCode(&v9);
    *(_BYTE *)(a3 + 80) |= 1u;
    *(_QWORD *)a3 = v5;
    *(_QWORD *)(a3 + 8) = v6;
    if (v9)
      (*(void (**)(_QWORD *))(*v9 + 8))(v9);
  }
  else
  {
    v8 = 261;
    v7[0] = v10;
    v7[1] = v11;
    (*(void (**)(_QWORD, _QWORD *))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16), v7);
  }
  if (v10 != v12)
    free(v10);
}

void sub_1C5E290E4(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD v7[4];
  __int16 v8;
  _QWORD *v9;
  void *v10;
  __int128 v11;
  _QWORD v12[33];

  v12[32] = *MEMORY[0x1E0C80C00];
  v10 = v12;
  v11 = xmmword_1C64638F0;
  llvm::Twine::toVector(a2, (uint64_t)&v10);
  llvm::PrefixMapper::mapInPlace(a1 + 24, &v10, v7);
  if (v7[0])
  {
    v9 = (_QWORD *)v7[0];
    v5 = llvm::errorToErrorCode(&v9);
    *(_BYTE *)(a3 + 16) |= 1u;
    *(_QWORD *)a3 = v5;
    *(_QWORD *)(a3 + 8) = v6;
    if (v9)
      (*(void (**)(_QWORD *))(*v9 + 8))(v9);
  }
  else
  {
    v8 = 261;
    v7[0] = v10;
    v7[1] = v11;
    (*(void (**)(_QWORD, _QWORD *))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16), v7);
  }
  if (v10 != v12)
    free(v10);
}

void sub_1C5E291EC(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t v7;
  _QWORD v8[4];
  __int16 v9;
  _QWORD *v10;
  void *v11;
  __int128 v12;
  _QWORD v13[33];

  v13[32] = *MEMORY[0x1E0C80C00];
  v11 = v13;
  v12 = xmmword_1C64638F0;
  llvm::Twine::toVector(a2, (uint64_t)&v11);
  llvm::PrefixMapper::mapInPlace(a1 + 24, &v11, v8);
  if (v8[0])
  {
    v10 = (_QWORD *)v8[0];
    *a3 = llvm::errorToErrorCode(&v10);
    a3[1] = v7;
    if (v10)
      (*(void (**)(_QWORD *))(*v10 + 8))(v10);
    *a4 = 0;
    a4[1] = 0;
  }
  else
  {
    v9 = 261;
    v8[0] = v11;
    v8[1] = v12;
    (*(void (**)(_QWORD, _QWORD *, uint64_t *))(**(_QWORD **)(a1 + 16) + 32))(*(_QWORD *)(a1 + 16), v8, a3);
  }
  if (v11 != v13)
    free(v11);
}

uint64_t sub_1C5E292FC(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD v5[4];
  __int16 v6;
  _QWORD *v7;
  void *v8;
  __int128 v9;
  _QWORD v10[33];

  v10[32] = *MEMORY[0x1E0C80C00];
  v8 = v10;
  v9 = xmmword_1C64638F0;
  llvm::Twine::toVector(a2, (uint64_t)&v8);
  llvm::PrefixMapper::mapInPlace(a1 + 24, &v8, v5);
  if (v5[0])
  {
    v7 = (_QWORD *)v5[0];
    v3 = llvm::errorToErrorCode(&v7);
    if (v7)
      (*(void (**)(_QWORD *))(*v7 + 8))(v7);
  }
  else
  {
    v6 = 261;
    v5[0] = v8;
    v5[1] = v9;
    v3 = (*(uint64_t (**)(_QWORD, _QWORD *))(**(_QWORD **)(a1 + 16) + 40))(*(_QWORD *)(a1 + 16), v5);
  }
  if (v8 != v10)
    free(v8);
  return v3;
}

uint64_t sub_1C5E29404(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  _QWORD v7[4];
  __int16 v8;
  _QWORD *v9;
  void *v10;
  __int128 v11;
  _QWORD v12[33];

  v12[32] = *MEMORY[0x1E0C80C00];
  v10 = v12;
  v11 = xmmword_1C64638F0;
  llvm::Twine::toVector(a2, (uint64_t)&v10);
  llvm::PrefixMapper::mapInPlace(a1 + 24, &v10, v7);
  if (v7[0])
  {
    v9 = (_QWORD *)v7[0];
    v5 = llvm::errorToErrorCode(&v9);
    if (v9)
      (*(void (**)(_QWORD *))(*v9 + 8))(v9);
  }
  else
  {
    v8 = 261;
    v7[0] = v10;
    v7[1] = v11;
    v5 = (*(uint64_t (**)(_QWORD, _QWORD *, uint64_t))(**(_QWORD **)(a1 + 16) + 56))(*(_QWORD *)(a1 + 16), v7, a3);
  }
  if (v10 != v12)
    free(v10);
  return v5;
}

uint64_t sub_1C5E29514(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  _QWORD v7[4];
  __int16 v8;
  _QWORD *v9;
  void *v10;
  __int128 v11;
  _QWORD v12[33];

  v12[32] = *MEMORY[0x1E0C80C00];
  v10 = v12;
  v11 = xmmword_1C64638F0;
  llvm::Twine::toVector(a2, (uint64_t)&v10);
  llvm::PrefixMapper::mapInPlace(a1 + 24, &v10, v7);
  if (v7[0])
  {
    v9 = (_QWORD *)v7[0];
    v5 = llvm::errorToErrorCode(&v9);
    if (v9)
      (*(void (**)(_QWORD *))(*v9 + 8))(v9);
  }
  else
  {
    v8 = 261;
    v7[0] = v10;
    v7[1] = v11;
    v5 = (*(uint64_t (**)(_QWORD, _QWORD *, uint64_t))(**(_QWORD **)(a1 + 16) + 80))(*(_QWORD *)(a1 + 16), v7, a3);
  }
  if (v10 != v12)
    free(v10);
  return v5;
}

uint64_t llvm::PrettyStackTraceEntry::PrettyStackTraceEntry(uint64_t result, int a2)
{
  *(_QWORD *)result = off_1E81A1BB8;
  *(_DWORD *)(result + 8) = a2;
  return result;
}

llvm::PrettyStackTraceFormat *llvm::PrettyStackTraceFormat::PrettyStackTraceFormat(llvm::PrettyStackTraceFormat *this, const char *__format, ...)
{
  char *v4;
  char **v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  va_list va;

  va_start(va, __format);
  *((_DWORD *)this + 2) = 0;
  v4 = (char *)this + 48;
  *((_QWORD *)this + 3) = (char *)this + 48;
  v5 = (char **)((char *)this + 24);
  *(_QWORD *)this = &off_1E81A1BE0;
  *((_OWORD *)this + 2) = xmmword_1C677F680;
  v6 = vsnprintf(0, 0, __format, va);
  if ((v6 & 0x80000000) == 0)
  {
    v7 = (v6 + 1);
    v8 = *((_QWORD *)this + 4);
    if (v8 != v7)
    {
      if (v8 <= v7)
      {
        if (*((_QWORD *)this + 5) < v7)
        {
          llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)v5, v4, v7, 1);
          v8 = *((_QWORD *)this + 4);
        }
        if (v7 != v8)
          bzero(&(*v5)[v8], v7 - v8);
      }
      *((_QWORD *)this + 4) = v7;
    }
    vsnprintf(*v5, v7, __format, va);
  }
  return this;
}

{
  char *v4;
  char **v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  va_list va;

  va_start(va, __format);
  *((_DWORD *)this + 2) = 0;
  v4 = (char *)this + 48;
  *((_QWORD *)this + 3) = (char *)this + 48;
  v5 = (char **)((char *)this + 24);
  *(_QWORD *)this = &off_1E81A1BE0;
  *((_OWORD *)this + 2) = xmmword_1C677F680;
  v6 = vsnprintf(0, 0, __format, va);
  if ((v6 & 0x80000000) == 0)
  {
    v7 = (v6 + 1);
    v8 = *((_QWORD *)this + 4);
    if (v8 != v7)
    {
      if (v8 <= v7)
      {
        if (*((_QWORD *)this + 5) < v7)
        {
          llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)v5, v4, v7, 1);
          v8 = *((_QWORD *)this + 4);
        }
        if (v7 != v8)
          bzero(&(*v5)[v8], v7 - v8);
      }
      *((_QWORD *)this + 4) = v7;
    }
    vsnprintf(*v5, v7, __format, va);
  }
  return this;
}

llvm::raw_ostream *llvm::PrettyStackTraceFormat::print(llvm::PrettyStackTraceFormat *this, llvm::raw_ostream *a2)
{
  llvm::raw_ostream *result;
  _BYTE *v4;

  result = llvm::raw_ostream::write(a2, *((const char **)this + 3), *((_QWORD *)this + 4));
  v4 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v4)
    return llvm::raw_ostream::write(a2, "\n", 1uLL);
  *v4 = 10;
  ++*((_QWORD *)a2 + 4);
  return result;
}

_QWORD *sub_1C5E29890(_QWORD *a1)
{
  _QWORD *v2;

  *a1 = &off_1E81A1BE0;
  v2 = (_QWORD *)a1[3];
  if (v2 != a1 + 6)
    free(v2);
  return a1;
}

void sub_1C5E298D0(_QWORD *a1)
{
  _QWORD *v2;

  *a1 = &off_1E81A1BE0;
  v2 = (_QWORD *)a1[3];
  if (v2 != a1 + 6)
    free(v2);
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *llvm::RandomNumberGenerator::RandomNumberGenerator(_QWORD *a1, char *a2, uint64_t a3)
{
  uint64_t v3;
  unint64_t v6;
  uint64_t i;
  int *v10;
  _DWORD *v11;
  int v12;
  int *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  int v18;
  char *v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  char *v23;
  int v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  unsigned int v35;
  unsigned int v36;
  int v37;
  int v38;
  unint64_t v39;
  int v40;
  unsigned int v41;
  int v42;
  int v43;
  uint64_t v44;
  int v45;
  unsigned int v46;
  int v47;
  int v48;
  unint64_t j;
  const float *v50;
  int8x16_t v51;
  int8x16_t v52;
  int8x16_t *v58;
  uint64_t v59;
  void *__p;
  int *v62;
  uint64_t v63;
  _DWORD v64[624];
  uint64_t v65;
  float32x4x2_t v66;

  v3 = a3;
  v65 = *MEMORY[0x1E0C80C00];
  v6 = 5489;
  *a1 = 5489;
  for (i = 1; i != 312; ++i)
  {
    v6 = i + 0x5851F42D4C957F2DLL * (v6 ^ (v6 >> 62));
    a1[i] = v6;
  }
  a1[312] = 0;
  __p = 0;
  v62 = 0;
  v63 = 0;
  if (a3 != -2)
    sub_1C4D63CD0((char **)&__p, a3 + 2);
  if (!atomic_load(qword_1ED836BD0))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED836BD0, (void *(*)(void))sub_1C5E29F68, (void (*)(void *))sub_1C638DA60);
  *(_DWORD *)__p = *(_QWORD *)(qword_1ED836BD0[0] + 128);
  if (!atomic_load(qword_1ED836BD0))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED836BD0, (void *(*)(void))sub_1C5E29F68, (void (*)(void *))sub_1C638DA60);
  v10 = (int *)__p;
  *((_DWORD *)__p + 1) = *(_DWORD *)(qword_1ED836BD0[0] + 132);
  if (v3)
  {
    v11 = v10 + 2;
    do
    {
      v12 = *a2++;
      *v11++ = v12;
      --v3;
    }
    while (v3);
  }
  v13 = v62;
  if (v10 == v62)
  {
    v14 = 0;
    v19 = 0;
  }
  else
  {
    v14 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    do
    {
      v18 = *v10;
      if (v17 >= v16)
      {
        v20 = (v17 - v15) >> 2;
        v21 = v20 + 1;
        if ((unint64_t)(v20 + 1) >> 62)
          abort();
        if ((v16 - v15) >> 1 > v21)
          v21 = (v16 - v15) >> 1;
        if ((unint64_t)(v16 - v15) >= 0x7FFFFFFFFFFFFFFCLL)
          v22 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v22 = v21;
        if (v22)
        {
          if (v22 >> 62)
            sub_1C4764EE4();
          v23 = (char *)operator new(4 * v22);
        }
        else
        {
          v23 = 0;
        }
        v14 = &v23[4 * v20];
        *(_DWORD *)v14 = v18;
        v19 = v14 + 4;
        while (v17 != v15)
        {
          v24 = *((_DWORD *)v17 - 1);
          v17 -= 4;
          *((_DWORD *)v14 - 1) = v24;
          v14 -= 4;
        }
        v16 = &v23[4 * v22];
        if (v15)
          operator delete(v15);
        v15 = v14;
      }
      else
      {
        *(_DWORD *)v17 = v18;
        v19 = v17 + 4;
      }
      ++v10;
      v17 = v19;
    }
    while (v10 != v13);
  }
  memset(&v64[1], 139, 0x9BCuLL);
  v25 = (v19 - v14) >> 2;
  v26 = v25 + 1;
  if ((unint64_t)(v25 + 1) > 0x270)
    v27 = v25 + 1;
  else
    v27 = 624;
  v64[317] = v25 - 582287779;
  v64[306] = -582287779;
  v64[0] = v25 + 1371501266;
  if (v19 == v14)
  {
    v28 = 0;
    v33 = 623;
    v32 = 306;
    v31 = 317;
  }
  else
  {
    v28 = 0;
    v29 = 2;
    if (v26 > 2)
      v29 = v25 + 1;
    v30 = v29 - 1;
    v31 = 317;
    v32 = 306;
    v33 = 623;
    v34 = v14;
    do
    {
      if (v28 == 623)
        v28 = 0;
      else
        ++v28;
      if (v33 == 623)
        v33 = 0;
      else
        ++v33;
      if (v32 == 623)
        v32 = 0;
      else
        ++v32;
      if (v31 == 623)
        v31 = 0;
      else
        ++v31;
      v35 = v64[v32];
      v36 = 1664525 * (v64[v28] ^ v64[v33] ^ v35 ^ ((v64[v28] ^ v64[v33] ^ v35) >> 27));
      v64[v32] = v36 + v35;
      v37 = *(_DWORD *)v34;
      v34 += 4;
      v38 = v37 + v28 + v36;
      v64[v31] += v38;
      v64[v28] = v38;
      --v30;
    }
    while (v30);
  }
  if (v26 <= 0x26F)
  {
    v39 = ~v25 + v27;
    do
    {
      if (v28 == 623)
        v28 = 0;
      else
        ++v28;
      if (v33 == 623)
        v33 = 0;
      else
        ++v33;
      if (v32 == 623)
        v32 = 0;
      else
        ++v32;
      if (v31 == 623)
        v31 = 0;
      else
        ++v31;
      v40 = v64[v32];
      v41 = v64[v28] ^ v64[v33] ^ v40;
      v42 = 1664525 * (v41 ^ (v41 >> 27));
      v64[v32] = v42 + v40;
      v43 = v42 + v28;
      v64[v31] += v43;
      v64[v28] = v43;
      --v39;
    }
    while (v39);
  }
  if (v27 <= 0xFFFFFFFFFFFFFD8FLL)
  {
    v44 = 624;
    do
    {
      if (v28 == 623)
        v28 = 0;
      else
        ++v28;
      if (v33 == 623)
        v33 = 0;
      else
        ++v33;
      if (v32 == 623)
        v32 = 0;
      else
        ++v32;
      if (v31 == 623)
        v31 = 0;
      else
        ++v31;
      v45 = v64[v32];
      v46 = v45 + v64[v28] + v64[v33];
      v47 = 1566083941 * (v46 ^ (v46 >> 27));
      v64[v32] = v47 ^ v45;
      v48 = v47 - v28;
      v64[v31] ^= v48;
      v64[v28] = v48;
      --v44;
    }
    while (v44);
  }
  for (j = 0; j != 2496; j += 32)
  {
    v50 = (const float *)&v64[j / 4];
    v66 = vld2q_f32(v50);
    v51.i64[0] = v66.val[0].u32[2];
    v51.i64[1] = v66.val[0].u32[3];
    v52 = v51;
    v51.i64[0] = v66.val[0].u32[0];
    v51.i64[1] = v66.val[0].u32[1];
    __asm { SHLL2           V4.2D, V1.4S, #0x20 ; ' ' }
    v58 = (int8x16_t *)&a1[j / 8];
    *v58 = vorrq_s8((int8x16_t)vshll_n_s32(*(int32x2_t *)v66.val[1].f32, 0x20uLL), v51);
    v58[1] = vorrq_s8(_Q4, v52);
  }
  a1[312] = 0;
  if (!(*a1 >> 31))
  {
    v59 = 1;
    while (!a1[v59])
    {
      if (++v59 == 312)
      {
        *a1 = 0x8000000000000000;
        break;
      }
    }
  }
  if (v14)
    operator delete(v14);
  if (__p)
  {
    v62 = (int *)__p;
    operator delete(__p);
  }
  return a1;
}

unint64_t llvm::RandomNumberGenerator::operator()(uint64_t a1)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;

  v1 = *(_QWORD *)(a1 + 2496);
  v2 = (v1 + 1) % 0x138uLL;
  v3 = *(_QWORD *)(a1 + 8 * ((v1 + 156) % 0x138uLL)) ^ ((*(_QWORD *)(a1 + 8 * v2) & 0x7FFFFFFELL | *(_QWORD *)(a1 + 8 * v1) & 0xFFFFFFFF80000000) >> 1) ^ ((uint64_t)(*(_QWORD *)(a1 + 8 * v2) << 63) >> 63) & 0xB5026F5AA96619E9;
  *(_QWORD *)(a1 + 8 * v1) = v3;
  *(_QWORD *)(a1 + 2496) = v2;
  v4 = (((v3 >> 29) & 0x5555555555555555 ^ v3) << 17) & 0x71D67FFFEDA60000 ^ (v3 >> 29) & 0x5555555555555555 ^ v3;
  return (v4 << 37) & 0xFFF7EEE000000000 ^ v4 ^ (((v4 << 37) & 0xFFF7EEE000000000 ^ v4) >> 43);
}

uint64_t llvm::getRandomBytes(llvm *this, void *a2)
{
  int v4;
  int v5;
  void *v6;
  unsigned int v7;

  v4 = open("/dev/urandom", 0);
  if (v4 == -1)
    goto LABEL_9;
  v5 = v4;
  std::system_category();
  v6 = (void *)read(v5, this, (size_t)a2);
  if (v6 == (void *)-1)
  {
    v7 = *__error();
  }
  else
  {
    if (v6 == a2)
    {
      v7 = 0;
      goto LABEL_8;
    }
    v7 = 5;
  }
  std::system_category();
LABEL_8:
  if (close(v5) == -1)
  {
LABEL_9:
    v7 = *__error();
    std::system_category();
  }
  return v7;
}

llvm::cl::Option *sub_1C5E29F68()
{
  llvm::cl::Option *v0;
  int v2;
  int *v3;
  __n128 v4;
  int v5;
  __int128 v6;

  v0 = (llvm::cl::Option *)operator new();
  *(_QWORD *)&v6 = "seed";
  *((_QWORD *)&v6 + 1) = 4;
  v5 = 1;
  v4.n128_u64[0] = (unint64_t)"Seed for the random number generator";
  v4.n128_u64[1] = 36;
  v2 = 0;
  v3 = &v2;
  return sub_1C638DA74(v0, &v6, &v5, &v4, &v3);
}

uint64_t llvm::Regex::Regex(uint64_t this)
{
  *(_QWORD *)this = 0;
  *(_DWORD *)(this + 8) = 2;
  return this;
}

{
  *(_QWORD *)this = 0;
  *(_DWORD *)(this + 8) = 2;
  return this;
}

uint64_t llvm::Regex::Regex(uint64_t a1, char *a2, uint64_t a3, unsigned int a4)
{
  _OWORD *v8;

  v8 = (_OWORD *)operator new();
  *v8 = 0u;
  v8[1] = 0u;
  *(_QWORD *)a1 = v8;
  *((_QWORD *)v8 + 2) = &a2[a3];
  *(_DWORD *)(a1 + 8) = llvm_regcomp((uint64_t)v8, a2, ((4 * a4) & 8 | (2 * (a4 & 1)) | (a4 >> 2) & 1) ^ 0x21);
  return a1;
}

{
  _OWORD *v8;

  v8 = (_OWORD *)operator new();
  *v8 = 0u;
  v8[1] = 0u;
  *(_QWORD *)a1 = v8;
  *((_QWORD *)v8 + 2) = &a2[a3];
  *(_DWORD *)(a1 + 8) = llvm_regcomp((uint64_t)v8, a2, ((4 * a4) & 8 | (2 * (a4 & 1)) | (a4 >> 2) & 1) ^ 0x21);
  return a1;
}

{
  _OWORD *v8;

  v8 = (_OWORD *)operator new();
  *v8 = 0u;
  v8[1] = 0u;
  *(_QWORD *)a1 = v8;
  *((_QWORD *)v8 + 2) = &a2[a3];
  *(_DWORD *)(a1 + 8) = llvm_regcomp((uint64_t)v8, a2, ((4 * a4) & 8 | (2 * (a4 & 1)) | (a4 >> 2) & 1) ^ 0x21);
  return a1;
}

{
  _OWORD *v8;

  v8 = (_OWORD *)operator new();
  *v8 = 0u;
  v8[1] = 0u;
  *(_QWORD *)a1 = v8;
  *((_QWORD *)v8 + 2) = &a2[a3];
  *(_DWORD *)(a1 + 8) = llvm_regcomp((uint64_t)v8, a2, ((4 * a4) & 8 | (2 * (a4 & 1)) | (a4 >> 2) & 1) ^ 0x21);
  return a1;
}

uint64_t llvm::Regex::Regex(uint64_t result, uint64_t a2)
{
  *(_QWORD *)result = *(_QWORD *)a2;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 8) = 2;
  return result;
}

{
  *(_QWORD *)result = *(_QWORD *)a2;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 8) = 2;
  return result;
}

void llvm::Regex::~Regex(llvm::Regex *this)
{
  uint64_t v2;

  v2 = *(_QWORD *)this;
  if (v2)
  {
    llvm_regfree(v2);
    if (*(_QWORD *)this)
      MEMORY[0x1CAA32FC0](*(_QWORD *)this, 0x1070C404B019E81);
  }
}

{
  uint64_t v2;

  v2 = *(_QWORD *)this;
  if (v2)
  {
    llvm_regfree(v2);
    if (*(_QWORD *)this)
      MEMORY[0x1CAA32FC0](*(_QWORD *)this, 0x1070C404B019E81);
  }
}

size_t sub_1C5E2A1F8(int a1, uint64_t a2, uint64_t a3)
{
  size_t v6;
  _BYTE *v7;

  v6 = llvm_regerror(a1, a2, 0, 0);
  std::string::resize((std::string *)a3, v6 - 1, 0);
  if (*(char *)(a3 + 23) >= 0)
    v7 = (_BYTE *)a3;
  else
    v7 = *(_BYTE **)a3;
  return llvm_regerror(a1, a2, v7, v6);
}

uint64_t llvm::Regex::getNumMatches(llvm::Regex *this)
{
  return *(unsigned int *)(*(_QWORD *)this + 8);
}

uint64_t llvm::Regex::match(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v10;
  uint64_t v11;
  unsigned int v12;
  unint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v26;
  uint64_t v27;
  _QWORD v28[17];

  v28[16] = *MEMORY[0x1E0C80C00];
  if (!a5)
  {
    if (*(_DWORD *)(a1 + 8))
      return 0;
    goto LABEL_9;
  }
  if ((*(char *)(a5 + 23) & 0x80000000) == 0)
  {
    if (!*(_BYTE *)(a5 + 23))
      goto LABEL_5;
    goto LABEL_4;
  }
  if (*(_QWORD *)(a5 + 8))
LABEL_4:
    MEMORY[0x1CAA32ABC](a5, "");
LABEL_5:
  v10 = *(_DWORD *)(a1 + 8);
  if (v10)
  {
    sub_1C5E2A1F8(v10, *(_QWORD *)a1, a5);
    return 0;
  }
LABEL_9:
  if (a4)
    v12 = *(_DWORD *)(*(_QWORD *)a1 + 8) + 1;
  else
    v12 = 0;
  v26 = v28;
  v27 = 0x800000000;
  if (v12 <= 1)
    v13 = 1;
  else
    v13 = v12;
  if (v13 >= 9)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, (uint64_t)v28, v13, 16);
    v14 = v27;
    if ((_DWORD)v27 == (_DWORD)v13)
      goto LABEL_20;
    v15 = v26;
  }
  else
  {
    v14 = 0;
    v15 = v28;
  }
  bzero(&v15[2 * v14], 16 * (v13 - v14));
LABEL_20:
  LODWORD(v27) = v13;
  v16 = v26;
  *(_QWORD *)v26 = 0;
  v16[1] = a3;
  v17 = llvm_regexec(*(_QWORD *)a1, a2, v12, v16, 4);
  if (v17)
  {
    if (v17 != 1 && a5)
      sub_1C5E2A1F8(*(_DWORD *)(a1 + 8), *(_QWORD *)a1, a5);
    v11 = 0;
  }
  else
  {
    if (a4)
    {
      *(_DWORD *)(a4 + 8) = 0;
      if (v12)
      {
        v18 = 0;
        v19 = 0;
        v20 = 16 * v12;
        do
        {
          v21 = *(_QWORD *)((char *)v26 + v18);
          if (v21 == -1)
          {
            if (v19 >= *(_DWORD *)(a4 + 12))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod(a4, a4 + 16, v19 + 1, 16);
              v19 = *(_DWORD *)(a4 + 8);
            }
            v24 = (_QWORD *)(*(_QWORD *)a4 + 16 * v19);
            *v24 = 0;
            v24[1] = 0;
          }
          else
          {
            v22 = *(_QWORD *)((char *)v26 + v18 + 8);
            if (v19 >= *(_DWORD *)(a4 + 12))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod(a4, a4 + 16, v19 + 1, 16);
              v19 = *(_DWORD *)(a4 + 8);
            }
            v23 = (_QWORD *)(*(_QWORD *)a4 + 16 * v19);
            *v23 = &a2[v21];
            v23[1] = v22 - v21;
          }
          v19 = *(_DWORD *)(a4 + 8) + 1;
          *(_DWORD *)(a4 + 8) = v19;
          v18 += 16;
        }
        while (v20 != v18);
      }
    }
    v11 = 1;
  }
  if (v26 != v28)
    free(v26);
  return v11;
}

void llvm::Regex::sub(uint64_t a1@<X0>, uint64_t a2@<X1>, std::string::size_type a3@<X2>, void *a4@<X3>, size_t a5@<X4>, uint64_t a6@<X5>, std::string *a7@<X8>)
{
  std::string::size_type v10;
  const std::string::value_type *v11;
  unint64_t v13;
  std::string::size_type v14;
  std::string::size_type v15;
  BOOL v16;
  unint64_t v17;
  const std::string::value_type *v18;
  int v19;
  unint64_t first_not_of;
  unint64_t v21;
  unint64_t v22;
  const std::string::value_type *v23;
  unint64_t v24;
  int v25;
  int v26;
  unsigned int v27;
  unint64_t v28;
  std::string *v29;
  std::string::value_type v30;
  _BOOL4 v31;
  _BOOL4 v32;
  BOOL v33;
  uint64_t v36;
  uint64_t v37;
  std::string *v38;
  _QWORD v40[4];
  __int16 v41;
  _QWORD v42[4];
  __int16 v43;
  __int128 v44;
  uint64_t v45;
  const std::string::value_type *v46;
  std::string::size_type v47;
  void *v48;
  uint64_t v49;
  _QWORD v50[18];

  v10 = a3;
  v11 = (const std::string::value_type *)a2;
  v50[16] = *MEMORY[0x1E0C80C00];
  v46 = (const std::string::value_type *)a2;
  v47 = a3;
  v48 = v50;
  v49 = 0x800000000;
  if ((llvm::Regex::match(a1, (char *)a4, a5, (uint64_t)&v48, a6) & 1) == 0)
  {
    if (a5 >= 0x7FFFFFFFFFFFFFF8)
      abort();
    if (a5 >= 0x17)
    {
      v36 = (a5 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((a5 | 7) != 0x17)
        v36 = a5 | 7;
      v37 = v36 + 1;
      v38 = (std::string *)operator new(v36 + 1);
      a7->__r_.__value_.__l.__size_ = a5;
      a7->__r_.__value_.__r.__words[2] = v37 | 0x8000000000000000;
      a7->__r_.__value_.__r.__words[0] = (std::string::size_type)v38;
      a7 = v38;
    }
    else
    {
      *((_BYTE *)&a7->__r_.__value_.__s + 23) = a5;
      if (!a5)
        goto LABEL_65;
    }
    memmove(a7, a4, a5);
LABEL_65:
    a7->__r_.__value_.__s.__data_[a5] = 0;
    goto LABEL_68;
  }
  sub_1C4E61270(a7, (char *)a4, *(char **)v48, *(_QWORD *)v48 - (_QWORD)a4);
  if (!v10)
    goto LABEL_67;
  LOBYTE(v42[0]) = 92;
  v13 = llvm::StringRef::find((uint64_t *)&v46, (char *)v42, 1uLL, 0);
  if (v13 == -1)
    goto LABEL_66;
  while (1)
  {
    v14 = v10 >= v13 ? v13 : v10;
    v15 = v13 + 1;
    std::string::append(a7, v11, v14);
    v16 = v10 > v15;
    v17 = v10 - v15;
    if (!v16)
      break;
    v18 = &v11[v15];
    v46 = &v11[v15];
    v47 = v17;
    v19 = v11[v15];
    if ((v19 - 48) >= 0xA)
    {
      if (v19 == 110)
      {
        v29 = a7;
        v30 = 10;
      }
      else if (v19 == 116)
      {
        v29 = a7;
        v30 = 9;
      }
      else
      {
        v30 = v11[v15];
        v29 = a7;
      }
      std::string::push_back(v29, v30);
      v11 = v18 + 1;
      v10 = v17 - 1;
      v46 = v18 + 1;
      v47 = v10;
      goto LABEL_50;
    }
    first_not_of = llvm::StringRef::find_first_not_of(&v46, "0123456789", 10, 0);
    if (v17 >= first_not_of)
      v21 = first_not_of;
    else
      v21 = v17;
    v11 = &v18[v21];
    v10 = v17 - v21;
    v46 = &v18[v21];
    v47 = v10;
    if (!v21)
    {
      v28 = 0;
      v31 = 0;
LABEL_32:
      v32 = 1;
      goto LABEL_36;
    }
    v22 = 0;
    v23 = v18;
    v24 = v21;
    while (1)
    {
      v25 = *(unsigned __int8 *)v23;
      if ((v25 - 48) < 0xA)
      {
        v26 = -48;
        goto LABEL_17;
      }
      if ((v25 - 97) < 0x1A)
      {
        v26 = -87;
        goto LABEL_17;
      }
      if ((v25 - 65) > 0x19)
        break;
      v26 = -55;
LABEL_17:
      v27 = v26 + v25;
      if (v27 > 9)
        break;
      v28 = 10 * v22 + v27;
      if (v22 > v28 / 0xA)
      {
        v31 = 1;
        goto LABEL_32;
      }
      ++v23;
      v22 = v28;
      if (!--v24)
        goto LABEL_35;
    }
    v28 = v22;
LABEL_35:
    v32 = v21 == v24;
    v31 = v24 != 0;
LABEL_36:
    if (HIDWORD(v28))
      v33 = 0;
    else
      v33 = !v31;
    if (v33 && !v32 && v28 < v49)
    {
      std::string::append(a7, *((const std::string::value_type **)v48 + 2 * v28), *((_QWORD *)v48 + 2 * v28 + 1));
      goto LABEL_50;
    }
    if (a6)
    {
      if (*(char *)(a6 + 23) < 0)
      {
        if (!*(_QWORD *)(a6 + 8))
          goto LABEL_54;
      }
      else
      {
        if (*(_BYTE *)(a6 + 23))
          goto LABEL_50;
LABEL_54:
        v40[0] = "invalid backreference string '";
        v40[2] = v18;
        v40[3] = v21;
        v41 = 1283;
        v42[0] = v40;
        v42[2] = "'";
        v43 = 770;
        llvm::Twine::str((llvm::Twine *)v42, &v44);
        if (*(char *)(a6 + 23) < 0)
          operator delete(*(void **)a6);
        *(_OWORD *)a6 = v44;
        *(_QWORD *)(a6 + 16) = v45;
      }
    }
LABEL_50:
    if (!v10)
      goto LABEL_67;
    LOBYTE(v42[0]) = 92;
    v13 = llvm::StringRef::find((uint64_t *)&v46, (char *)v42, 1uLL, 0);
    if (v13 == -1)
    {
LABEL_66:
      std::string::append(a7, v11, v10);
      goto LABEL_67;
    }
  }
  if (a6 && v47 != v14 && !(*(char *)(a6 + 23) < 0 ? *(_QWORD *)(a6 + 8) : *(unsigned __int8 *)(a6 + 23)))
    MEMORY[0x1CAA32ABC](a6, "replacement string contained trailing backslash");
LABEL_67:
  std::string::append(a7, (const std::string::value_type *)(*(_QWORD *)v48 + *((_QWORD *)v48 + 1)), (std::string::size_type)a4 + a5 - (*(_QWORD *)v48 + *((_QWORD *)v48 + 1)));
LABEL_68:
  if (v48 != v50)
    free(v48);
}

void llvm::Regex::escape(std::string::value_type *a1@<X0>, uint64_t a2@<X1>, std::string *a3@<X8>)
{
  uint64_t v3;
  std::string::value_type v6;

  a3->__r_.__value_.__r.__words[0] = 0;
  a3->__r_.__value_.__l.__size_ = 0;
  a3->__r_.__value_.__r.__words[2] = 0;
  if (a2)
  {
    v3 = a2;
    do
    {
      v6 = *a1;
      if (memchr("()^$|*+?.[]\\{}", *a1, 0xFuLL))
        std::string::push_back(a3, 92);
      std::string::push_back(a3, v6);
      ++a1;
      --v3;
    }
    while (v3);
  }
}

uint64_t llvm::RemoteBisectClient::setupConnection(llvm::RemoteBisectClient *this)
{
  std::string *p_p;
  llvm *v2;
  int v3;
  uint64_t v4;
  llvm::raw_ostream *v6;
  char *v7;
  int *v8;
  llvm::raw_ostream *v9;
  int *v10;
  char *v11;
  llvm::raw_ostream *v12;
  std::string __p;
  addrinfo *v14;
  addrinfo v15;

  v14 = 0;
  memset(&v15, 0, sizeof(v15));
  v15.ai_socktype = 1;
  v15.ai_flags = 1;
  std::to_string(&__p, *((_DWORD *)this + 6));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  v2 = (llvm *)getaddrinfo(0, (const char *)p_p, &v15, &v14);
  v3 = (int)v2;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (v3)
  {
    v6 = (llvm::raw_ostream *)llvm::errs(v2);
    v7 = "RemoteBisectClient: getaddrinfo() failed: ";
    goto LABEL_14;
  }
  v4 = socket(v14->ai_family, v14->ai_socktype, v14->ai_protocol);
  if (connect(v4, v14->ai_addr, v14->ai_addrlen) == -1)
  {
    v8 = __error();
    if (*v8 == 48 && (sleep(1u), v8 = (int *)connect(v4, v14->ai_addr, v14->ai_addrlen), (_DWORD)v8 == -1))
    {
      v6 = (llvm::raw_ostream *)llvm::errs((llvm *)v8);
      v7 = "RemoteBisectClient: could not bind() to the socket after waiting: ";
    }
    else
    {
      v6 = (llvm::raw_ostream *)llvm::errs((llvm *)v8);
      v7 = "RemoteBisectClient: could not bind() to the socket: ";
    }
LABEL_14:
    v9 = sub_1C4816AD8(v6, v7);
    v10 = __error();
    v11 = strerror(*v10);
    v12 = sub_1C4816AD8(v9, v11);
    sub_1C4816AD8(v12, "\n");
    llvm::report_fatal_error((llvm *)"Fatal error.", (const char *)1);
  }
  return v4;
}

