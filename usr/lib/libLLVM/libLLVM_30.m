unint64_t *llvm::ValueHandleBase::ValueIsDeleted(llvm::ValueHandleBase *this, llvm::Value *a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  int v5;
  unsigned int v6;
  llvm::ValueHandleBase **v7;
  llvm::ValueHandleBase *v8;
  llvm::ValueHandleBase **v9;
  int v10;
  BOOL v11;
  unsigned int v12;
  llvm::ValueHandleBase **v13;
  unint64_t *v14;
  unint64_t *result;
  int32x2_t ****v16;
  unint64_t **v18;
  char v19;
  unint64_t v20;
  int32x2_t ****v21;
  int32x2_t *v22;
  unint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  int32x2_t *****v27;
  int32x2_t ****v28;
  int v29;
  int v30;
  unint64_t **v31;
  unint64_t *v32;
  unint64_t v33;
  unsigned int v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  int32x2_t *v38;
  unint64_t v39;
  uint64_t v40;
  unsigned int v41;
  uint64_t v42;
  uint64_t *v43;
  uint64_t v44;
  int v45;
  int v46;
  unint64_t v47;
  int32x2_t ****v48;
  int32x2_t *v49;
  unint64_t v50;
  uint64_t v51;
  unsigned int v52;
  uint64_t v53;
  int32x2_t *****v54;
  int32x2_t ****v55;
  int v56;
  int v57;
  unint64_t v58;
  unint64_t *v59;
  int32x2_t ****v60;
  llvm::ValueHandleBase *v61;

  v61 = this;
  v2 = ***(_QWORD ***)this;
  v3 = *(_DWORD *)(v2 + 2440);
  if (v3)
  {
    v4 = *(_QWORD *)(v2 + 2424);
    v5 = v3 - 1;
    v6 = (v3 - 1) & ((this >> 4) ^ (this >> 9));
    v7 = (llvm::ValueHandleBase **)(v4 + 16 * v6);
    v8 = *v7;
    if (*v7 == this)
      goto LABEL_16;
    v9 = 0;
    v10 = 1;
    while (v8 != (llvm::ValueHandleBase *)-4096)
    {
      if (v9)
        v11 = 0;
      else
        v11 = v8 == (llvm::ValueHandleBase *)-8192;
      if (v11)
        v9 = v7;
      v12 = v6 + v10++;
      v6 = v12 & v5;
      v7 = (llvm::ValueHandleBase **)(v4 + 16 * (v12 & v5));
      v8 = *v7;
      if (*v7 == this)
        goto LABEL_16;
    }
    if (v9)
      v13 = v9;
    else
      v13 = v7;
  }
  else
  {
    v13 = 0;
  }
  v7 = (llvm::ValueHandleBase **)sub_1C5440874(v2 + 2424, (uint64_t)&v61, (uint64_t *)&v61, v13);
  *v7 = v61;
  v7[1] = 0;
LABEL_16:
  v14 = 0;
  result = (unint64_t *)v7[1];
  v58 = 0;
  v59 = 0;
  v16 = (int32x2_t ****)result[2];
  v60 = v16;
  if (v16 != (int32x2_t ****)-8192 && v16 != 0 && v16 != (int32x2_t ****)-4096)
  {
    v18 = (unint64_t **)(*result & 0xFFFFFFFFFFFFFFF8);
    v59 = *v18;
    *v18 = &v58;
    v58 = (unint64_t)v18;
    v14 = v59;
    if (v59)
      *v59 = *v59 & 7 | (unint64_t)&v59;
  }
  do
  {
    v19 = v58;
    v20 = v58 & 0xFFFFFFFFFFFFFFF8;
    *(_QWORD *)(v58 & 0xFFFFFFFFFFFFFFF8) = v14;
    if (v59)
    {
      *v59 = *v59 & 7 | v20;
      v19 = v58;
    }
    else
    {
      v21 = v60;
      v22 = ***v60;
      v23 = (unint64_t)v22[303];
      if (v23 <= v20)
      {
        v24 = v22[305].u32[0];
        if (v23 + 16 * v24 > v20)
        {
          v25 = v24 - 1;
          LODWORD(v26) = v25 & ((v60 >> 4) ^ (v60 >> 9));
          v27 = (int32x2_t *****)(v23 + 16 * v26);
          v28 = *v27;
          if (v60 == *v27)
          {
LABEL_31:
            *v27 = (int32x2_t ****)-8192;
            v22[304] = vadd_s32(v22[304], (int32x2_t)0x1FFFFFFFFLL);
            v21 = v60;
          }
          else
          {
            v29 = 1;
            while (v28 != (int32x2_t ****)-4096)
            {
              v30 = v26 + v29++;
              v26 = v30 & v25;
              v28 = *(int32x2_t *****)(v23 + 16 * v26);
              if (v60 == v28)
              {
                v27 = (int32x2_t *****)(v23 + 16 * v26);
                goto LABEL_31;
              }
            }
          }
          *((_BYTE *)v21 + 17) &= ~1u;
        }
      }
    }
    v31 = (unint64_t **)(result + 1);
    v32 = (unint64_t *)result[1];
    v58 = v19 & 7 | (unint64_t)(result + 1);
    v59 = v32;
    result[1] = (unint64_t)&v58;
    if (v59)
      *v59 = *v59 & 7 | (unint64_t)&v59;
    v33 = *result;
    v34 = (*result >> 1) & 3;
    if (v34 == 1)
    {
      (*(void (**)(unint64_t *, llvm::Value *))(*(result - 1) + 8))(result - 1, a2);
    }
    else if (v34 - 2 <= 1)
    {
      v35 = result[2];
      if (v35)
      {
        if ((v35 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          v36 = v33 & 0xFFFFFFFFFFFFFFF8;
          *(_QWORD *)(v33 & 0xFFFFFFFFFFFFFFF8) = &v58;
          if (*v31)
          {
            **v31 = **v31 & 7 | v36;
          }
          else
          {
            v37 = result[2];
            v38 = ***(int32x2_t ****)v37;
            v39 = (unint64_t)v38[303];
            if (v39 <= v36)
            {
              v40 = v38[305].u32[0];
              if (v39 + 16 * v40 > v36)
              {
                v41 = v40 - 1;
                LODWORD(v42) = v41 & ((v37 >> 4) ^ (v37 >> 9));
                v43 = (uint64_t *)(v39 + 16 * v42);
                v44 = *v43;
                if (v37 == *v43)
                {
LABEL_69:
                  *v43 = -8192;
                  v38[304] = vadd_s32(v38[304], (int32x2_t)0x1FFFFFFFFLL);
                  v37 = result[2];
                }
                else
                {
                  v45 = 1;
                  while (v44 != -4096)
                  {
                    v46 = v42 + v45++;
                    v42 = v46 & v41;
                    v44 = *(_QWORD *)(v39 + 16 * v42);
                    if (v37 == v44)
                    {
                      v43 = (uint64_t *)(v39 + 16 * v42);
                      goto LABEL_69;
                    }
                  }
                }
                *(_BYTE *)(v37 + 17) &= ~1u;
              }
            }
          }
        }
        result[2] = 0;
      }
    }
    v14 = v59;
    result = v59;
  }
  while (v59);
  if (v60 != (int32x2_t ****)-8192 && v60 != (int32x2_t ****)-4096 && v60)
  {
    v47 = v58 & 0xFFFFFFFFFFFFFFF8;
    *(_QWORD *)(v58 & 0xFFFFFFFFFFFFFFF8) = 0;
    if (v59)
    {
      *v59 = *v59 & 7 | v47;
    }
    else
    {
      v48 = v60;
      v49 = ***v60;
      v50 = (unint64_t)v49[303];
      if (v50 <= v47)
      {
        v51 = v49[305].u32[0];
        if (v50 + 16 * v51 > v47)
        {
          v52 = v51 - 1;
          LODWORD(v53) = v52 & ((v60 >> 4) ^ (v60 >> 9));
          v54 = (int32x2_t *****)(v50 + 16 * v53);
          v55 = *v54;
          if (v60 == *v54)
          {
LABEL_65:
            *v54 = (int32x2_t ****)-8192;
            v49[304] = vadd_s32(v49[304], (int32x2_t)0x1FFFFFFFFLL);
            v48 = v60;
          }
          else
          {
            v56 = 1;
            while (v55 != (int32x2_t ****)-4096)
            {
              v57 = v53 + v56++;
              v53 = v57 & v52;
              v55 = *(int32x2_t *****)(v50 + 16 * v53);
              if (v60 == v55)
              {
                v54 = (int32x2_t *****)(v50 + 16 * v53);
                goto LABEL_65;
              }
            }
          }
          *((_BYTE *)v48 + 17) &= ~1u;
        }
      }
    }
  }
  return result;
}

uint64_t llvm::Value::destroyValueName(uint64_t this)
{
  uint64_t v1;
  int v2;
  int32x2_t *v3;
  int32x2_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  int v10;
  int v11;
  unsigned int v12;
  uint64_t *v13;
  uint64_t v14;
  int v15;
  int v16;

  v1 = this;
  v2 = *(_DWORD *)(this + 20);
  if ((v2 & 0x10000000) == 0)
    goto LABEL_16;
  v3 = ***(int32x2_t ****)this;
  v4 = v3[19];
  v5 = v3[21].u32[0];
  v6 = this >> 4;
  if (!(_DWORD)v5)
    goto LABEL_19;
  LODWORD(v7) = (v5 - 1) & (v6 ^ (this >> 9));
  v8 = (uint64_t *)(*(_QWORD *)&v4 + 16 * v7);
  v9 = *v8;
  if (*v8 != this)
  {
    v10 = 1;
    while (v9 != -4096)
    {
      v11 = v7 + v10++;
      v7 = v11 & (v5 - 1);
      v9 = *(_QWORD *)(*(_QWORD *)&v4 + 16 * v7);
      if (v9 == this)
      {
        v8 = (uint64_t *)(*(_QWORD *)&v4 + 16 * v7);
        goto LABEL_8;
      }
    }
LABEL_19:
    v8 = (uint64_t *)(*(_QWORD *)&v4 + 16 * v5);
  }
LABEL_8:
  this = v8[1];
  if (this)
  {
    this = MEMORY[0x1CAA32FB4](this, 8);
    v2 = *(_DWORD *)(v1 + 20);
    if ((v2 & 0x10000000) == 0)
      goto LABEL_16;
    v3 = ***(int32x2_t ****)v1;
    v4 = v3[19];
    LODWORD(v5) = v3[21].i32[0];
  }
  if ((_DWORD)v5)
  {
    v12 = v5 - 1;
    LODWORD(v5) = (v5 - 1) & (v6 ^ (v1 >> 9));
    v13 = (uint64_t *)(*(_QWORD *)&v4 + 16 * v5);
    v14 = *v13;
    if (*v13 == v1)
    {
LABEL_15:
      *v13 = -8192;
      v3[20] = vadd_s32(v3[20], (int32x2_t)0x1FFFFFFFFLL);
      v2 = *(_DWORD *)(v1 + 20);
    }
    else
    {
      v15 = 1;
      while (v14 != -4096)
      {
        v16 = v5 + v15++;
        v5 = v16 & v12;
        v14 = *(_QWORD *)(*(_QWORD *)&v4 + 16 * v5);
        if (v14 == v1)
        {
          v13 = (uint64_t *)(*(_QWORD *)&v4 + 16 * v5);
          goto LABEL_15;
        }
      }
    }
  }
LABEL_16:
  *(_DWORD *)(v1 + 20) = v2 & 0xEFFFFFFF;
  return this;
}

void llvm::Value::deleteValue(llvm::Value *this)
{
  __asm { BR              X10 }
}

void sub_1C5438E40(int a1, llvm::Type *a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  uint64_t v24;
  unsigned __int8 *v25;
  int v26;
  uint64_t v27;
  char *v28;
  _QWORD **v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  char *v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  llvm::UndefValue *v39;
  llvm::Value *v40;

  if ((*(_BYTE *)(v24 + 23) & 8) != 0)
  {
    v39 = llvm::UndefValue::get(*(llvm::UndefValue **)v24, a2);
    llvm::ValueAsMetadata::handleRAUW((uint64_t *)v24, v39, v40);
  }
  v25 = *(unsigned __int8 **)(v24 + 48);
  if (v25)
    llvm::MetadataTracking::untrack(v24 + 48, v25);
  llvm::Value::~Value((llvm::Value *)v24, (llvm::Value *)v25);
  v26 = *(_DWORD *)(v24 + 20);
  if ((v26 & 0x40000000) != 0)
  {
    v34 = *(char **)(v24 - 8);
    v33 = (char *)(v24 - 8);
    v32 = v34;
    v35 = v26 & 0x7FFFFFF;
    if ((_DWORD)v35)
    {
      v36 = 32 * v35;
      do
      {
        v37 = &v32[v36];
        if (*(_QWORD *)&v32[v36 - 32])
        {
          **((_QWORD **)v37 - 2) = *((_QWORD *)v37 - 3);
          v38 = *((_QWORD *)v37 - 3);
          if (v38)
            *(_QWORD *)(v38 + 16) = *((_QWORD *)v37 - 2);
        }
        v36 -= 32;
      }
      while (v36);
    }
    operator delete(v32);
    v28 = v33;
  }
  else
  {
    v27 = v26 & 0x7FFFFFF;
    v28 = (char *)(v24 - 32 * v27);
    if ((_DWORD)v27)
    {
      v29 = (_QWORD **)(v24 - 16);
      v30 = -32 * v27;
      do
      {
        if (*(v29 - 2))
        {
          **v29 = *(v29 - 1);
          v31 = (uint64_t)*(v29 - 1);
          if (v31)
            *(_QWORD *)(v31 + 16) = *v29;
        }
        v29 -= 4;
        v30 += 32;
      }
      while (v30);
    }
    if (v26 < 0)
      v28 = &v28[-*((_QWORD *)v28 - 1) - 8];
  }
  operator delete(v28);
}

uint64_t llvm::Value::getValueName(llvm::Value *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  llvm::Value *v6;
  int v7;
  int v8;

  if ((*((_BYTE *)this + 23) & 0x10) != 0)
  {
    v1 = ***(_QWORD ***)this;
    v2 = *(_QWORD *)(v1 + 152);
    v3 = *(unsigned int *)(v1 + 168);
    if ((_DWORD)v3)
    {
      LODWORD(v4) = (v3 - 1) & ((this >> 4) ^ (this >> 9));
      v5 = v2 + 16 * v4;
      v6 = *(llvm::Value **)v5;
      if (*(llvm::Value **)v5 == this)
        return *(_QWORD *)(v5 + 8);
      v7 = 1;
      while (v6 != (llvm::Value *)-4096)
      {
        v8 = v4 + v7++;
        v4 = v8 & (v3 - 1);
        v6 = *(llvm::Value **)(v2 + 16 * v4);
        if (v6 == this)
        {
          v5 = v2 + 16 * v4;
          return *(_QWORD *)(v5 + 8);
        }
      }
    }
    v5 = v2 + 16 * v3;
    return *(_QWORD *)(v5 + 8);
  }
  return 0;
}

int32x2_t ****llvm::Value::setValueName(int32x2_t ****result, int32x2_t ***a2)
{
  int32x2_t **v2;
  int v3;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  unsigned int v9;
  int32x2_t ****v10;
  int32x2_t ****v11;
  int32x2_t ****v12;
  int v13;
  BOOL v14;
  unsigned int v15;
  int32x2_t *v16;
  __int32 v17;
  int32x2_t v18;
  __int32 v19;
  uint64_t v20;
  int32x2_t *****v21;
  int32x2_t ****v22;
  int v23;
  int v24;
  int32x2_t ****v25;
  int32x2_t ****v26;

  v2 = **result;
  v3 = *((_DWORD *)result + 5);
  if (a2)
  {
    *((_DWORD *)result + 5) = v3 | 0x10000000;
    v5 = (uint64_t)&(*v2)[19];
    v6 = *(_QWORD *)v5;
    v26 = result;
    v7 = *(_DWORD *)(v5 + 16);
    if (v7)
    {
      v8 = v7 - 1;
      v9 = (v7 - 1) & ((result >> 4) ^ (result >> 9));
      v10 = (int32x2_t ****)(v6 + 16 * v9);
      v11 = (int32x2_t ****)*v10;
      if (*v10 == (int32x2_t ***)result)
      {
LABEL_15:
        v10[1] = a2;
        return result;
      }
      v12 = 0;
      v13 = 1;
      while (v11 != (int32x2_t ****)-4096)
      {
        if (v12)
          v14 = 0;
        else
          v14 = v11 == (int32x2_t ****)-8192;
        if (v14)
          v12 = v10;
        v15 = v9 + v13++;
        v9 = v15 & v8;
        v10 = (int32x2_t ****)(v6 + 16 * (v15 & v8));
        v11 = (int32x2_t ****)*v10;
        if (*v10 == (int32x2_t ***)result)
          goto LABEL_15;
      }
      if (v12)
        v25 = v12;
      else
        v25 = v10;
    }
    else
    {
      v25 = 0;
    }
    result = (int32x2_t ****)sub_1C54406CC(v5, (uint64_t)&v26, (uint64_t *)&v26, v25);
    v10 = result;
    *result = (int32x2_t ***)v26;
    result[1] = 0;
    goto LABEL_15;
  }
  if ((v3 & 0x10000000) != 0)
  {
    v16 = *v2;
    v17 = v16[21].i32[0];
    if (v17)
    {
      v18 = v16[19];
      v19 = v17 - 1;
      LODWORD(v20) = (v17 - 1) & ((result >> 4) ^ (result >> 9));
      v21 = (int32x2_t *****)(*(_QWORD *)&v18 + 16 * v20);
      v22 = *v21;
      if (*v21 == result)
      {
LABEL_22:
        *v21 = (int32x2_t ****)-8192;
        v16[20] = vadd_s32(v16[20], (int32x2_t)0x1FFFFFFFFLL);
        v3 = *((_DWORD *)result + 5);
      }
      else
      {
        v23 = 1;
        while (v22 != (int32x2_t ****)-4096)
        {
          v24 = v20 + v23++;
          v20 = v24 & v19;
          v22 = *(int32x2_t *****)(*(_QWORD *)&v18 + 16 * v20);
          if (v22 == result)
          {
            v21 = (int32x2_t *****)(*(_QWORD *)&v18 + 16 * v20);
            goto LABEL_22;
          }
        }
      }
    }
  }
  *((_DWORD *)result + 5) = v3 & 0xEFFFFFFF;
  return result;
}

BOOL llvm::Value::hasNUses(llvm::Value *this, int a2)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 1);
  if (!a2)
    return v2 == 0;
  while (v2)
  {
    v2 = *(_QWORD *)(v2 + 8);
    if (!--a2)
      return v2 == 0;
  }
  return 0;
}

BOOL llvm::Value::hasNUsesOrMore(llvm::Value *this, int a2)
{
  _BOOL8 result;
  uint64_t v4;
  int v5;

  result = a2 == 0;
  if (a2)
  {
    v4 = *((_QWORD *)this + 1);
    if (v4)
    {
      v5 = a2 - 1;
      do
      {
        result = v5 == 0;
        if (!v5)
          break;
        v4 = *(_QWORD *)(v4 + 8);
        --v5;
      }
      while (v4);
    }
  }
  return result;
}

BOOL llvm::Value::hasOneUser(llvm::Value *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _BOOL8 result;

  v1 = *((_QWORD *)this + 1);
  if (!v1)
    return 0;
  v2 = *(_QWORD *)(v1 + 8);
  if (!v2)
    return 1;
  do
  {
    v3 = *(_QWORD *)(v2 + 24);
    v4 = *(_QWORD *)(v1 + 24);
    result = v3 == v4;
    if (v3 != v4)
      break;
    v1 = *(_QWORD *)(v1 + 8);
    v2 = *(_QWORD *)(v2 + 8);
  }
  while (v2);
  return result;
}

uint64_t llvm::Value::getUniqueUndroppableUser(llvm::Value *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *((_QWORD *)this + 1);
  if (v1)
  {
    v2 = 0;
    while (1)
    {
      v3 = *(_QWORD *)(v1 + 24);
      if (sub_1C4D9F8B4(v3) || sub_1C509DDB0(v3))
      {
        v3 = v2;
      }
      else if (v2 && v2 != v3)
      {
        return 0;
      }
      v1 = *(_QWORD *)(v1 + 8);
      v2 = v3;
      if (!v1)
        return v3;
    }
  }
  return 0;
}

BOOL llvm::Value::hasNUndroppableUses(llvm::Value *this, int a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  _BOOL4 v5;
  uint64_t v6;
  _BOOL8 result;

  v2 = *((_QWORD *)this + 1);
  if (a2)
  {
    v3 = a2;
    while (v2)
    {
      v4 = *(_QWORD *)(v2 + 24);
      v5 = sub_1C4D9F8B4(v4) || sub_1C509DDB0(v4);
      v2 = *(_QWORD *)(v2 + 8);
      v3 -= !v5;
      if (!v3)
        goto LABEL_8;
    }
    return 0;
  }
  else
  {
LABEL_8:
    if (v2)
    {
      while (1)
      {
        v6 = *(_QWORD *)(v2 + 24);
        if (!sub_1C4D9F8B4(v6))
        {
          result = sub_1C509DDB0(v6);
          if (!result)
            break;
        }
        v2 = *(_QWORD *)(v2 + 8);
        if (!v2)
          return 1;
      }
    }
    else
    {
      return 1;
    }
  }
  return result;
}

BOOL llvm::Value::hasNUndroppableUsesOrMore(llvm::Value *this, int a2)
{
  _BOOL8 result;
  uint64_t v4;
  int v5;
  uint64_t v6;
  _BOOL4 v7;

  result = a2 == 0;
  if (a2)
  {
    v4 = *((_QWORD *)this + 1);
    if (v4)
    {
      v5 = a2;
      do
      {
        v6 = *(_QWORD *)(v4 + 24);
        v7 = sub_1C4D9F8B4(v6) || sub_1C509DDB0(v6);
        v5 -= !v7;
        result = v5 == 0;
        if (!v5)
          break;
        v4 = *(_QWORD *)(v4 + 8);
      }
      while (v4);
    }
  }
  return result;
}

void llvm::Value::dropDroppableUses(uint64_t a1, unsigned int (*a2)(uint64_t, uint64_t), uint64_t a3)
{
  uint64_t v3;
  uint64_t v6;
  llvm::Use *v7;
  llvm::Value **v8;
  uint64_t v9;
  uint64_t v10;
  llvm::Value *v11;
  void *v12;
  uint64_t v13;
  _QWORD v14[9];

  v14[8] = *MEMORY[0x1E0C80C00];
  v12 = v14;
  v13 = 0x800000000;
  v3 = *(_QWORD *)(a1 + 8);
  if (v3)
  {
    do
    {
      v6 = *(_QWORD *)(v3 + 24);
      if ((sub_1C4D9F8B4(v6) || sub_1C509DDB0(v6)) && a2(a3, v3))
      {
        v9 = v13;
        if (v13 >= (unint64_t)HIDWORD(v13))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v12, (uint64_t)v14, v13 + 1, 8);
          v9 = v13;
        }
        *((_QWORD *)v12 + v9) = v3;
        LODWORD(v13) = v13 + 1;
      }
      v3 = *(_QWORD *)(v3 + 8);
    }
    while (v3);
    v8 = (llvm::Value **)v12;
    if ((_DWORD)v13)
    {
      v10 = 8 * v13;
      do
      {
        v11 = *v8++;
        llvm::Value::dropDroppableUse(v11, v7);
        v10 -= 8;
      }
      while (v10);
      v8 = (llvm::Value **)v12;
    }
    if (v8 != v14)
      free(v8);
  }
}

uint64_t llvm::Value::dropDroppableUse(llvm::Value *this, llvm::Use *a2)
{
  _QWORD *v3;
  uint64_t v4;
  char *v5;
  uint64_t result;
  llvm::Type *v7;
  const llvm::APInt *v8;
  BOOL v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  unint64_t v13;
  llvm::UndefValue *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  char *BundleOpInfoForOperand;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  llvm::ConstantInt *v27;
  unsigned int v28;
  char v29;
  uint64_t v30;
  unsigned int v31;

  v3 = (_QWORD *)((char *)this + 8);
  **((_QWORD **)this + 2) = *((_QWORD *)this + 1);
  v4 = *((_QWORD *)this + 1);
  if (v4)
    *(_QWORD *)(v4 + 16) = *((_QWORD *)this + 2);
  v5 = (char *)*((_QWORD *)this + 3);
  result = sub_1C4D9F8B4((uint64_t)v5);
  if (v5)
    v9 = (_DWORD)result == 0;
  else
    v9 = 1;
  if (!v9)
  {
    v10 = *((_QWORD *)this + 3);
    v11 = *(_DWORD *)(v10 + 20);
    if ((v11 & 0x40000000) != 0)
      v12 = *(_QWORD *)(v10 - 8);
    else
      v12 = v10 - 32 * (v11 & 0x7FFFFFF);
    v13 = ((unint64_t)this - v12) >> 5;
    if ((_DWORD)v13)
    {
      v14 = llvm::UndefValue::get(**(llvm::UndefValue ***)this, v7);
      if (*(_QWORD *)this)
      {
        **((_QWORD **)this + 2) = *((_QWORD *)this + 1);
        v15 = *((_QWORD *)this + 1);
        if (v15)
          *(_QWORD *)(v15 + 16) = *((_QWORD *)this + 2);
      }
      *(_QWORD *)this = v14;
      if (v14)
      {
        v18 = *((_QWORD *)v14 + 1);
        v16 = (_QWORD *)((char *)v14 + 8);
        v17 = v18;
        *v3 = v18;
        if (v18)
          *(_QWORD *)(v17 + 16) = v3;
        *((_QWORD *)this + 2) = v16;
        *v16 = this;
      }
      BundleOpInfoForOperand = llvm::CallBase::getBundleOpInfoForOperand(v5, v13);
      result = (uint64_t)llvm::LLVMContextImpl::getOrInsertBundleTag(***(_DWORD ****)v5, "ignore", 6uLL);
      *(_QWORD *)BundleOpInfoForOperand = result;
    }
    else
    {
      v20 = **(uint64_t ***)v5;
      v21 = *v20;
      v22 = *(_QWORD *)(*v20 + 1560);
      if (!v22)
      {
        v27 = *(llvm::ConstantInt **)(v21 + 1888);
        v28 = *(_DWORD *)(v21 + 1896);
        v31 = v28 >> 8;
        if (v28 >> 8 > 0x40)
        {
          llvm::APInt::initSlowCase((llvm::APInt *)&v30, 1, 0);
        }
        else
        {
          if (v28 <= 0xFF)
            v29 = 0;
          else
            v29 = 0xFFFFFFFFFFFFFFFFLL >> -BYTE1(v28);
          v30 = v29 & 1;
        }
        result = (uint64_t)llvm::ConstantInt::get(v27, (llvm::LLVMContext *)&v30, v8);
        v22 = result;
        if (v31 >= 0x41)
        {
          result = v30;
          if (v30)
            result = MEMORY[0x1CAA32F9C](v30, 0x1000C8000313F17);
        }
        *(_QWORD *)(v21 + 1560) = v22;
      }
      if (*(_QWORD *)this)
      {
        **((_QWORD **)this + 2) = *((_QWORD *)this + 1);
        v23 = *((_QWORD *)this + 1);
        if (v23)
          *(_QWORD *)(v23 + 16) = *((_QWORD *)this + 2);
      }
      *(_QWORD *)this = v22;
      if (v22)
      {
        v26 = *(_QWORD *)(v22 + 8);
        v25 = (_QWORD *)(v22 + 8);
        v24 = v26;
        *v3 = v26;
        if (v26)
          *(_QWORD *)(v24 + 16) = v3;
        *((_QWORD *)this + 2) = v25;
        *v25 = this;
      }
    }
  }
  return result;
}

uint64_t llvm::Value::getContext(llvm::Value *this)
{
  return **(_QWORD **)this;
}

uint64_t llvm::Value::isUsedInBasicBlock(llvm::Value *this, const llvm::BasicBlock *a2)
{
  _QWORD *v2;
  uint64_t i;
  uint64_t v5;
  int v6;
  uint64_t v7;
  llvm::Value **v8;
  uint64_t v9;
  llvm::Value **v10;
  uint64_t v11;
  BOOL v12;

  v2 = (_QWORD *)*((_QWORD *)a2 + 6);
  for (i = *((_QWORD *)this + 1); ; i = *(_QWORD *)(i + 8))
  {
    if (v2 == (_QWORD *)((char *)a2 + 40) || i == 0)
      return 0;
    v5 = v2 ? (uint64_t)(v2 - 3) : 0;
    v6 = *(_DWORD *)(v5 + 20);
    if ((v6 & 0x40000000) != 0)
    {
      v8 = *(llvm::Value ***)(v5 - 8);
      v7 = v6 & 0x7FFFFFF;
      if (!v7)
      {
LABEL_16:
        v10 = v8;
        goto LABEL_17;
      }
    }
    else
    {
      v7 = v6 & 0x7FFFFFF;
      v8 = (llvm::Value **)(v5 - 32 * v7);
      if (!v7)
        goto LABEL_16;
    }
    v9 = 32 * v7;
    v10 = v8;
    while (*v10 != this)
    {
      v10 += 4;
      v9 -= 32;
      if (!v9)
      {
        v10 = &v8[4 * v7];
        break;
      }
    }
LABEL_17:
    if (v7 != ((char *)v10 - (char *)v8) >> 5)
      break;
    v11 = *(_QWORD *)(i + 24);
    v12 = v11 && *(unsigned __int8 *)(v11 + 16) >= 0x1Cu;
    if (v12 && *(const llvm::BasicBlock **)(v11 + 40) == a2)
      break;
    v2 = (_QWORD *)v2[1];
  }
  return 1;
}

uint64_t llvm::Value::getNumUses(llvm::Value *this)
{
  uint64_t v1;
  uint64_t result;

  v1 = *((_QWORD *)this + 1);
  if (!v1)
    return 0;
  LODWORD(result) = 0;
  do
  {
    result = (result + 1);
    v1 = *(_QWORD *)(v1 + 8);
  }
  while (v1);
  return result;
}

char *llvm::Value::getName(llvm::Value *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  llvm::Value *v6;
  int v7;
  int v8;

  if ((*((_BYTE *)this + 23) & 0x10) != 0)
  {
    v1 = ***(_QWORD ***)this;
    v2 = *(_QWORD *)(v1 + 152);
    v3 = *(unsigned int *)(v1 + 168);
    if ((_DWORD)v3)
    {
      LODWORD(v4) = (v3 - 1) & ((this >> 4) ^ (this >> 9));
      v5 = v2 + 16 * v4;
      v6 = *(llvm::Value **)v5;
      if (*(llvm::Value **)v5 == this)
        return (char *)(*(_QWORD *)(v5 + 8) + 16);
      v7 = 1;
      while (v6 != (llvm::Value *)-4096)
      {
        v8 = v4 + v7++;
        v4 = v8 & (v3 - 1);
        v6 = *(llvm::Value **)(v2 + 16 * v4);
        if (v6 == this)
        {
          v5 = v2 + 16 * v4;
          return (char *)(*(_QWORD *)(v5 + 8) + 16);
        }
      }
    }
    v5 = v2 + 16 * v3;
    return (char *)(*(_QWORD *)(v5 + 8) + 16);
  }
  return &byte_1C871356D;
}

void llvm::Value::setNameImpl(uint64_t ***a1, uint64_t a2)
{
  int v3;
  BOOL v4;
  int v5;
  size_t v6;
  void *v7;
  _QWORD *v8;
  int v9;
  uint64_t **v10;
  char *v11;
  uint64_t *v12;
  int32x2_t ***ValueName;
  _QWORD *v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  unsigned int v20;
  uint64_t ****v21;
  uint64_t ***v22;
  uint64_t ****v23;
  int v24;
  BOOL v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t ****v31;
  uint64_t ***v32;
  int v33;
  int v34;
  uint64_t ****v35;
  const char *v36;
  char v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t ****v42;
  uint64_t ***v43;
  int v44;
  int v45;
  uint64_t ***v46;
  uint64_t **v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t ****v52;
  uint64_t ***v53;
  int v54;
  int v55;
  uint64_t v56;
  size_t *v57;
  unsigned __int8 *v58;
  size_t v59;
  int v60;
  size_t v61;
  unsigned __int8 *v62;
  int v63;
  unsigned int v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  int v68;
  uint64_t v69;
  _QWORD *v70;
  int v71;
  uint64_t v72;
  unsigned int v73;
  unsigned __int8 *v74;
  uint64_t v75;
  uint64_t *v76;
  uint64_t ***v77;
  void *v78;
  __int128 v79;
  _QWORD v80[34];

  v80[32] = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(***a1 + 2664) || *((unsigned __int8 *)a1 + 16) <= 3u)
  {
    v3 = *(unsigned __int8 *)(a2 + 32);
    v4 = v3 != 0;
    v5 = v3 - 1;
    if (v5 != 0 && v4 || (*((_BYTE *)a1 + 23) & 0x10) != 0)
    {
      v78 = v80;
      v79 = xmmword_1C64638F0;
      if (*(_BYTE *)(a2 + 33) == 1)
      {
        v6 = 0;
        v7 = 0;
        v8 = v80;
        switch(v5)
        {
          case 0:
            break;
          case 2:
            v7 = *(void **)a2;
            if (*(_QWORD *)a2)
              v6 = strlen(*(const char **)a2);
            else
              v6 = 0;
            goto LABEL_10;
          case 3:
            v36 = *(const char **)a2;
            v37 = *(_BYTE *)(*(_QWORD *)a2 + 23);
            if (v37 >= 0)
              v7 = *(void **)a2;
            else
              v7 = *(void **)v36;
            if (v37 >= 0)
              v6 = v37 & 0x7F;
            else
              v6 = *((_QWORD *)v36 + 1);
            goto LABEL_10;
          case 4:
            v7 = *(void **)a2;
            v6 = *(_QWORD *)(a2 + 8);
LABEL_10:
            v8 = v80;
            break;
          default:
            goto LABEL_39;
        }
      }
      else
      {
LABEL_39:
        llvm::Twine::toVector(a2, (uint64_t)&v78);
        v8 = v78;
        v6 = v79;
        v7 = v78;
      }
      v9 = *((_DWORD *)a1 + 5);
      if ((v9 & 0x10000000) == 0)
      {
        v10 = 0;
        v11 = &byte_1C871356D;
LABEL_13:
        if (v10 == (uint64_t **)v6 && (!v6 || !memcmp(v11, v7, v6)))
          goto LABEL_19;
        v76 = 0;
        if ((sub_1C543C99C((uint64_t)a1, &v76) & 1) != 0)
        {
LABEL_18:
          v8 = v78;
LABEL_19:
          if (v8 != v80)
            free(v8);
          return;
        }
        v12 = v76;
        if (v76)
        {
          if ((v9 & 0x10000000) == 0)
          {
LABEL_17:
            ValueName = (int32x2_t ***)llvm::ValueSymbolTable::createValueName((llvm::StringMapImpl *)v12, (unsigned __int8 *)v7, v6, (size_t)a1);
            llvm::Value::setValueName((int32x2_t ****)a1, ValueName);
            goto LABEL_18;
          }
          v48 = ***a1;
          v49 = *(_QWORD *)(v48 + 152);
          v50 = *(unsigned int *)(v48 + 168);
          if ((_DWORD)v50)
          {
            LODWORD(v51) = (v50 - 1) & ((a1 >> 4) ^ (a1 >> 9));
            v52 = (uint64_t ****)(v49 + 16 * v51);
            v53 = *v52;
            if (*v52 == a1)
              goto LABEL_69;
            v54 = 1;
            while (v53 != (uint64_t ***)-4096)
            {
              v55 = v51 + v54++;
              v51 = v55 & (v50 - 1);
              v53 = *(uint64_t ****)(v49 + 16 * v51);
              if (v53 == a1)
              {
                v52 = (uint64_t ****)(v49 + 16 * v51);
                goto LABEL_69;
              }
            }
          }
          v52 = (uint64_t ****)(v49 + 16 * v50);
LABEL_69:
          v56 = *((unsigned int *)v76 + 2);
          if ((_DWORD)v56)
          {
            v57 = (size_t *)v52[1];
            v75 = *((unsigned int *)v76 + 5);
            v58 = (unsigned __int8 *)v57 + v75;
            v59 = *v57;
            if (*v57)
            {
              v60 = 0;
              v61 = *v57;
              v62 = v58;
              do
              {
                v63 = *v62++;
                v60 = 33 * v60 + v63;
                --v61;
              }
              while (v61);
            }
            else
            {
              v60 = 0;
            }
            v64 = v56 - 1;
            v65 = *v76;
            v66 = *v76 + 8 * v56 + 8;
            v67 = 1;
            v68 = v60;
            v74 = v58;
            v73 = v64;
            v72 = *v76;
            while (1)
            {
              v69 = v68 & v64;
              v70 = *(_QWORD **)(v65 + 8 * v69);
              if (v70 != (_QWORD *)-8)
              {
                if (!v70)
                  goto LABEL_84;
                if (*(_DWORD *)(v66 + 4 * v69) == v60 && v59 == *v70)
                {
                  if (!v59)
                    break;
                  v71 = memcmp(v58, (char *)v70 + v75, v59);
                  v64 = v73;
                  v65 = v72;
                  v58 = v74;
                  if (!v71)
                    break;
                }
              }
              v68 = v67 + v69;
              ++v67;
            }
            *(_QWORD *)(v65 + 8 * (int)v69) = -8;
            *(uint64_t *)((char *)v12 + 12) = (uint64_t)vadd_s32(*(int32x2_t *)((char *)v12 + 12), (int32x2_t)0x1FFFFFFFFLL);
          }
LABEL_84:
          llvm::Value::destroyValueName((uint64_t)a1);
          if (!v6)
            goto LABEL_18;
          goto LABEL_17;
        }
        llvm::Value::destroyValueName((uint64_t)a1);
        if (!v6)
          goto LABEL_18;
        v14 = operator new(v6 + 17, (std::align_val_t)8uLL);
        memcpy(v14 + 2, v7, v6);
        *((_BYTE *)v14 + v6 + 16) = 0;
        *v14 = v6;
        v14[1] = 0;
        v15 = **a1;
        *((_DWORD *)a1 + 5) |= 0x10000000u;
        v16 = *v15 + 152;
        v17 = *(_QWORD *)v16;
        v77 = a1;
        v18 = *(_DWORD *)(v16 + 16);
        if (v18)
        {
          v19 = v18 - 1;
          v20 = (v18 - 1) & ((a1 >> 4) ^ (a1 >> 9));
          v21 = (uint64_t ****)(v17 + 16 * v20);
          v22 = *v21;
          if (*v21 == a1)
            goto LABEL_32;
          v23 = 0;
          v24 = 1;
          while (v22 != (uint64_t ***)-4096)
          {
            if (v23)
              v25 = 0;
            else
              v25 = v22 == (uint64_t ***)-8192;
            if (v25)
              v23 = v21;
            v26 = v20 + v24++;
            v20 = v26 & v19;
            v21 = (uint64_t ****)(v17 + 16 * (v26 & v19));
            v22 = *v21;
            if (*v21 == a1)
              goto LABEL_32;
          }
          if (v23)
            v35 = v23;
          else
            v35 = v21;
        }
        else
        {
          v35 = 0;
        }
        v21 = (uint64_t ****)sub_1C54406CC(v16, (uint64_t)&v77, (uint64_t *)&v77, v35);
        *v21 = v77;
        v21[1] = 0;
LABEL_32:
        v21[1] = (uint64_t ***)v14;
        v27 = ***a1;
        v28 = *(_QWORD *)(v27 + 152);
        v29 = *(unsigned int *)(v27 + 168);
        if ((_DWORD)v29)
        {
          LODWORD(v30) = (v29 - 1) & ((a1 >> 4) ^ (a1 >> 9));
          v31 = (uint64_t ****)(v28 + 16 * v30);
          v32 = *v31;
          if (*v31 == a1)
          {
LABEL_38:
            v31[1][1] = (uint64_t **)a1;
            goto LABEL_18;
          }
          v33 = 1;
          while (v32 != (uint64_t ***)-4096)
          {
            v34 = v30 + v33++;
            v30 = v34 & (v29 - 1);
            v32 = *(uint64_t ****)(v28 + 16 * v30);
            if (v32 == a1)
            {
              v31 = (uint64_t ****)(v28 + 16 * v30);
              goto LABEL_38;
            }
          }
        }
        v31 = (uint64_t ****)(v28 + 16 * v29);
        goto LABEL_38;
      }
      v38 = ***a1;
      v39 = *(_QWORD *)(v38 + 152);
      v40 = *(unsigned int *)(v38 + 168);
      if ((_DWORD)v40)
      {
        LODWORD(v41) = (v40 - 1) & ((a1 >> 4) ^ (a1 >> 9));
        v42 = (uint64_t ****)(v39 + 16 * v41);
        v43 = *v42;
        if (*v42 == a1)
        {
LABEL_62:
          v46 = v42[1];
          v47 = *v46;
          v11 = (char *)(v46 + 2);
          v10 = v47;
          goto LABEL_13;
        }
        v44 = 1;
        while (v43 != (uint64_t ***)-4096)
        {
          v45 = v41 + v44++;
          v41 = v45 & (v40 - 1);
          v43 = *(uint64_t ****)(v39 + 16 * v41);
          if (v43 == a1)
          {
            v42 = (uint64_t ****)(v39 + 16 * v41);
            goto LABEL_62;
          }
        }
      }
      v42 = (uint64_t ****)(v39 + 16 * v40);
      goto LABEL_62;
    }
  }
}

uint64_t sub_1C543C99C(uint64_t a1, _QWORD *a2)
{
  unsigned int v2;
  uint64_t v3;
  _QWORD *v4;

  *a2 = 0;
  v2 = *(unsigned __int8 *)(a1 + 16);
  if (a1 && v2 >= 0x1C)
  {
    v3 = *(_QWORD *)(a1 + 40);
    if (!v3)
      return v3;
    v3 = *(_QWORD *)(v3 + 56);
    if (!v3)
      return v3;
    goto LABEL_17;
  }
  if (a1 && v2 == 22)
  {
    v3 = *(_QWORD *)(a1 + 56);
    if (!v3)
      return v3;
    goto LABEL_17;
  }
  if (a1 && v2 <= 3)
  {
    v3 = *(_QWORD *)(a1 + 40);
    if (!v3)
      return v3;
    v4 = (_QWORD *)(v3 + 112);
LABEL_18:
    v3 = 0;
    *a2 = *v4;
    return v3;
  }
  v3 = 1;
  if (a1)
  {
    if (v2 == 21)
    {
      v3 = *(_QWORD *)(a1 + 24);
      if (v3)
      {
LABEL_17:
        v4 = (_QWORD *)(v3 + 104);
        goto LABEL_18;
      }
    }
  }
  return v3;
}

void llvm::Value::setName(uint64_t ***a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t ****v7;
  uint64_t ***v8;
  int v9;
  int v10;
  uint64_t ***v11;
  _BYTE *v12;
  unint64_t v13;
  unint64_t v14;
  int v16;

  llvm::Value::setNameImpl(a1, a2);
  if (a1 && !*((_BYTE *)a1 + 16))
  {
    if ((*((_BYTE *)a1 + 23) & 0x10) == 0)
      goto LABEL_18;
    v3 = ***a1;
    v4 = *(_QWORD *)(v3 + 152);
    v5 = *(unsigned int *)(v3 + 168);
    if ((_DWORD)v5)
    {
      LODWORD(v6) = (v5 - 1) & ((a1 >> 4) ^ (a1 >> 9));
      v7 = (uint64_t ****)(v4 + 16 * v6);
      v8 = *v7;
      if (*v7 == a1)
      {
LABEL_11:
        v11 = v7[1];
        v14 = (unint64_t)*v11;
        v12 = v11 + 2;
        v13 = v14;
        if (v14 >= 5 && *(_DWORD *)v12 == *(_DWORD *)"llvm." && v12[4] == aLlvm_1[4])
        {
          *((_DWORD *)a1 + 8) |= 0x2000u;
          v16 = llvm::Function::lookupIntrinsicID(v12, v13);
LABEL_19:
          *((_DWORD *)a1 + 9) = v16;
          return;
        }
LABEL_18:
        v16 = 0;
        *((_DWORD *)a1 + 8) &= ~0x2000u;
        goto LABEL_19;
      }
      v9 = 1;
      while (v8 != (uint64_t ***)-4096)
      {
        v10 = v6 + v9++;
        v6 = v10 & (v5 - 1);
        v8 = *(uint64_t ****)(v4 + 16 * v6);
        if (v8 == a1)
        {
          v7 = (uint64_t ****)(v4 + 16 * v6);
          goto LABEL_11;
        }
      }
    }
    v7 = (uint64_t ****)(v4 + 16 * v5);
    goto LABEL_11;
  }
}

void llvm::Value::takeName(llvm::Value *this, llvm::Value *a2)
{
  llvm::Value *v2;
  unsigned int *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  llvm::Value **v9;
  llvm::Value *v10;
  int v11;
  int v12;
  uint64_t v13;
  llvm::Value *v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  llvm::Value *v22;
  int v23;
  int v24;
  llvm::ValueSymbolTable *v25;
  uint64_t v26;
  size_t *v27;
  uint64_t v28;
  unsigned __int8 *v29;
  size_t v30;
  int v31;
  size_t v32;
  unsigned __int8 *v33;
  int v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  int v39;
  uint64_t v40;
  _QWORD *v41;
  llvm::Value *v42;
  _BYTE *v43;
  unint64_t v44;
  unint64_t v45;
  int v47;
  uint64_t v48;
  uint64_t **v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  llvm::Value **v54;
  llvm::Value *v55;
  int v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  llvm::Value *v63;
  int v64;
  int v65;
  uint64_t v66;
  size_t *v67;
  unsigned __int8 *v68;
  size_t v69;
  int v70;
  size_t v71;
  unsigned __int8 *v72;
  int v73;
  unsigned int v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  int v78;
  uint64_t v79;
  _QWORD *v80;
  unsigned int v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  llvm::Value *v87;
  int v88;
  int v89;
  int32x2_t *v90;
  __int32 v91;
  int32x2_t v92;
  __int32 v93;
  uint64_t v94;
  llvm::Value **v95;
  llvm::Value *v96;
  int v97;
  int v98;
  int32x2_t ***v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  llvm::Value **v104;
  llvm::Value *v105;
  int v106;
  int v107;
  unsigned int v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  llvm::Value *v114;
  int v115;
  int v116;
  int32x2_t *v117;
  __int32 v118;
  int32x2_t v119;
  __int32 v120;
  uint64_t v121;
  llvm::Value **v122;
  llvm::Value *v123;
  int v124;
  int v125;
  unsigned int *v126;
  uint64_t v127;
  llvm::Value *v128;
  uint64_t ***v129;
  unsigned int *v130;
  llvm::ValueSymbolTable *v131;
  _QWORD v132[4];
  __int16 v133;
  unsigned int *v134;

  v2 = a2;
  v134 = 0;
  if ((*((_BYTE *)this + 23) & 0x10) == 0)
  {
    if ((*((_BYTE *)a2 + 23) & 0x10) == 0)
      return;
    v4 = (unsigned int *)((char *)a2 + 20);
LABEL_4:
    if (sub_1C543C99C((uint64_t)this, &v134))
    {
      v133 = 257;
      llvm::Value::setNameImpl((uint64_t ***)v2, (uint64_t)v132);
      if (!*((_BYTE *)v2 + 16))
      {
        if ((*((_BYTE *)v2 + 23) & 0x10) == 0)
          goto LABEL_52;
        v5 = ***(_QWORD ***)v2;
        v6 = *(_QWORD *)(v5 + 152);
        v7 = *(unsigned int *)(v5 + 168);
        if (!(_DWORD)v7)
          goto LABEL_44;
        LODWORD(v8) = (v7 - 1) & ((v2 >> 4) ^ (v2 >> 9));
        v9 = (llvm::Value **)(v6 + 16 * v8);
        v10 = *v9;
        if (*v9 != v2)
        {
          v11 = 1;
          while (v10 != (llvm::Value *)-4096)
          {
            v12 = v8 + v11++;
            v8 = v12 & (v7 - 1);
            v10 = *(llvm::Value **)(v6 + 16 * v8);
            if (v10 == v2)
              goto LABEL_22;
          }
LABEL_44:
          v9 = (llvm::Value **)(v6 + 16 * v7);
          goto LABEL_45;
        }
        goto LABEL_45;
      }
      return;
    }
    v25 = (llvm::ValueSymbolTable *)v134;
LABEL_57:
    v132[0] = 0;
    sub_1C543C99C((uint64_t)v2, v132);
    v48 = v132[0];
    if (v25 != (llvm::ValueSymbolTable *)v132[0])
    {
      v49 = *(uint64_t ***)v2;
      if (!v132[0])
        goto LABEL_105;
      v126 = v4;
      v50 = **v49;
      v51 = *(_QWORD *)(v50 + 152);
      v52 = *(unsigned int *)(v50 + 168);
      if ((_DWORD)v52)
      {
        LODWORD(v53) = (v52 - 1) & ((v2 >> 4) ^ (v2 >> 9));
        v54 = (llvm::Value **)(v51 + 16 * v53);
        v55 = *v54;
        if (*v54 == v2)
        {
LABEL_72:
          v129 = (uint64_t ***)v2;
          v131 = v25;
          v66 = *(unsigned int *)(v132[0] + 8);
          if ((_DWORD)v66)
          {
            v67 = (size_t *)v54[1];
            v127 = *(unsigned int *)(v132[0] + 20);
            v68 = (unsigned __int8 *)v67 + v127;
            v69 = *v67;
            if (*v67)
            {
              v70 = 0;
              v71 = *v67;
              v72 = v68;
              do
              {
                v73 = *v72++;
                v70 = 33 * v70 + v73;
                --v71;
              }
              while (v71);
            }
            else
            {
              v70 = 0;
            }
            v74 = v66 - 1;
            v75 = *(_QWORD *)v132[0];
            v76 = *(_QWORD *)v132[0] + 8 * v66 + 8;
            v77 = 1;
            v78 = v70;
            while (1)
            {
              v79 = v78 & v74;
              v80 = *(_QWORD **)(v75 + 8 * v79);
              if (v80 != (_QWORD *)-8)
              {
                if (!v80)
                  goto LABEL_102;
                if (*(_DWORD *)(v76 + 4 * v79) == v70 && v69 == *v80 && (!v69 || !memcmp(v68, (char *)v80 + v127, v69)))
                  break;
              }
              v78 = v77 + v79;
              ++v77;
            }
            *(_QWORD *)(v75 + 8 * (int)v79) = -8;
            *(int32x2_t *)(v48 + 12) = vadd_s32(*(int32x2_t *)(v48 + 12), (int32x2_t)0x1FFFFFFFFLL);
          }
LABEL_102:
          v4 = v126;
          if ((*((_BYTE *)v126 + 3) & 0x10) == 0)
          {
            v99 = 0;
            v2 = (llvm::Value *)v129;
            v25 = v131;
LABEL_113:
            llvm::Value::setValueName((int32x2_t ****)this, v99);
            v108 = *v4;
            if ((*v4 & 0x10000000) != 0)
            {
              v117 = ***(int32x2_t ****)v2;
              v118 = v117[21].i32[0];
              if (v118)
              {
                v119 = v117[19];
                v120 = v118 - 1;
                LODWORD(v121) = (v118 - 1) & ((v2 >> 4) ^ (v2 >> 9));
                v122 = (llvm::Value **)(*(_QWORD *)&v119 + 16 * v121);
                v123 = *v122;
                if (*v122 == v2)
                {
LABEL_130:
                  *v122 = (llvm::Value *)-8192;
                  v117[20] = vadd_s32(v117[20], (int32x2_t)0x1FFFFFFFFLL);
                  v108 = *v4;
                }
                else
                {
                  v124 = 1;
                  while (v123 != (llvm::Value *)-4096)
                  {
                    v125 = v121 + v124++;
                    v121 = v125 & v120;
                    v123 = *(llvm::Value **)(*(_QWORD *)&v119 + 16 * v121);
                    if (v123 == v2)
                    {
                      v122 = (llvm::Value **)(*(_QWORD *)&v119 + 16 * v121);
                      goto LABEL_130;
                    }
                  }
                }
              }
            }
            *v4 = v108 & 0xEFFFFFFF;
            v109 = ***(_QWORD ***)this;
            v110 = *(_QWORD *)(v109 + 152);
            v111 = *(unsigned int *)(v109 + 168);
            if ((_DWORD)v111)
            {
              LODWORD(v112) = (v111 - 1) & ((this >> 4) ^ (this >> 9));
              v113 = v110 + 16 * v112;
              v114 = *(llvm::Value **)v113;
              if (*(llvm::Value **)v113 == this)
                goto LABEL_121;
              v115 = 1;
              while (v114 != (llvm::Value *)-4096)
              {
                v116 = v112 + v115++;
                v112 = v116 & (v111 - 1);
                v114 = *(llvm::Value **)(v110 + 16 * v112);
                if (v114 == this)
                {
                  v113 = v110 + 16 * v112;
                  goto LABEL_121;
                }
              }
            }
            v113 = v110 + 16 * v111;
LABEL_121:
            *(_QWORD *)(*(_QWORD *)(v113 + 8) + 8) = this;
            if (v25)
              llvm::ValueSymbolTable::reinsertValue(v25, this);
            return;
          }
          v2 = (llvm::Value *)v129;
          v25 = v131;
          v49 = *v129;
LABEL_105:
          v100 = **v49;
          v101 = *(_QWORD *)(v100 + 152);
          v102 = *(unsigned int *)(v100 + 168);
          if ((_DWORD)v102)
          {
            LODWORD(v103) = (v102 - 1) & ((v2 >> 4) ^ (v2 >> 9));
            v104 = (llvm::Value **)(v101 + 16 * v103);
            v105 = *v104;
            if (*v104 == v2)
            {
LABEL_112:
              v99 = (int32x2_t ***)v104[1];
              goto LABEL_113;
            }
            v106 = 1;
            while (v105 != (llvm::Value *)-4096)
            {
              v107 = v103 + v106++;
              v103 = v107 & (v102 - 1);
              v105 = *(llvm::Value **)(v101 + 16 * v103);
              if (v105 == v2)
              {
                v104 = (llvm::Value **)(v101 + 16 * v103);
                goto LABEL_112;
              }
            }
          }
          v104 = (llvm::Value **)(v101 + 16 * v102);
          goto LABEL_112;
        }
        v56 = 1;
        while (v55 != (llvm::Value *)-4096)
        {
          v57 = v53 + v56++;
          v53 = v57 & (v52 - 1);
          v55 = *(llvm::Value **)(v51 + 16 * v53);
          if (v55 == v2)
          {
            v54 = (llvm::Value **)(v51 + 16 * v53);
            goto LABEL_72;
          }
        }
      }
      v54 = (llvm::Value **)(v51 + 16 * v52);
      goto LABEL_72;
    }
    v58 = ***(_QWORD ***)v2;
    v59 = *(_QWORD *)(v58 + 152);
    v60 = *(unsigned int *)(v58 + 168);
    if ((_DWORD)v60)
    {
      LODWORD(v61) = (v60 - 1) & ((v2 >> 4) ^ (v2 >> 9));
      v62 = v59 + 16 * v61;
      v63 = *(llvm::Value **)v62;
      if (*(llvm::Value **)v62 == v2)
      {
LABEL_85:
        llvm::Value::setValueName((int32x2_t ****)this, *(int32x2_t ****)(v62 + 8));
        v81 = *v4;
        if ((*v4 & 0x10000000) != 0)
        {
          v90 = ***(int32x2_t ****)v2;
          v91 = v90[21].i32[0];
          if (v91)
          {
            v92 = v90[19];
            v93 = v91 - 1;
            LODWORD(v94) = (v91 - 1) & ((v2 >> 4) ^ (v2 >> 9));
            v95 = (llvm::Value **)(*(_QWORD *)&v92 + 16 * v94);
            v96 = *v95;
            if (*v95 == v2)
            {
LABEL_100:
              *v95 = (llvm::Value *)-8192;
              v90[20] = vadd_s32(v90[20], (int32x2_t)0x1FFFFFFFFLL);
              v81 = *v4;
            }
            else
            {
              v97 = 1;
              while (v96 != (llvm::Value *)-4096)
              {
                v98 = v94 + v97++;
                v94 = v98 & v93;
                v96 = *(llvm::Value **)(*(_QWORD *)&v92 + 16 * v94);
                if (v96 == v2)
                {
                  v95 = (llvm::Value **)(*(_QWORD *)&v92 + 16 * v94);
                  goto LABEL_100;
                }
              }
            }
          }
        }
        *v4 = v81 & 0xEFFFFFFF;
        v82 = ***(_QWORD ***)this;
        v83 = *(_QWORD *)(v82 + 152);
        v84 = *(unsigned int *)(v82 + 168);
        if ((_DWORD)v84)
        {
          LODWORD(v85) = (v84 - 1) & ((this >> 4) ^ (this >> 9));
          v86 = v83 + 16 * v85;
          v87 = *(llvm::Value **)v86;
          if (*(llvm::Value **)v86 == this)
          {
LABEL_93:
            *(_QWORD *)(*(_QWORD *)(v86 + 8) + 8) = this;
            return;
          }
          v88 = 1;
          while (v87 != (llvm::Value *)-4096)
          {
            v89 = v85 + v88++;
            v85 = v89 & (v84 - 1);
            v87 = *(llvm::Value **)(v83 + 16 * v85);
            if (v87 == this)
            {
              v86 = v83 + 16 * v85;
              goto LABEL_93;
            }
          }
        }
        v86 = v83 + 16 * v84;
        goto LABEL_93;
      }
      v64 = 1;
      while (v63 != (llvm::Value *)-4096)
      {
        v65 = v61 + v64++;
        v61 = v65 & (v60 - 1);
        v63 = *(llvm::Value **)(v59 + 16 * v61);
        if (v63 == v2)
        {
          v62 = v59 + 16 * v61;
          goto LABEL_85;
        }
      }
    }
    v62 = v59 + 16 * v60;
    goto LABEL_85;
  }
  if (!sub_1C543C99C((uint64_t)this, &v134))
  {
    v128 = v2;
    v130 = v134;
    if (!v134)
      goto LABEL_55;
    v17 = ***(_QWORD ***)this;
    v18 = *(_QWORD *)(v17 + 152);
    v19 = *(unsigned int *)(v17 + 168);
    if ((_DWORD)v19)
    {
      LODWORD(v20) = (v19 - 1) & ((this >> 4) ^ (this >> 9));
      v21 = v18 + 16 * v20;
      v22 = *(llvm::Value **)v21;
      if (*(llvm::Value **)v21 == this)
        goto LABEL_32;
      v23 = 1;
      while (v22 != (llvm::Value *)-4096)
      {
        v24 = v20 + v23++;
        v20 = v24 & (v19 - 1);
        v22 = *(llvm::Value **)(v18 + 16 * v20);
        if (v22 == this)
        {
          v21 = v18 + 16 * v20;
          goto LABEL_32;
        }
      }
    }
    v21 = v18 + 16 * v19;
LABEL_32:
    v26 = v134[2];
    if ((_DWORD)v26)
    {
      v27 = *(size_t **)(v21 + 8);
      v28 = v134[5];
      v29 = (unsigned __int8 *)v27 + v28;
      v30 = *v27;
      if (*v27)
      {
        v31 = 0;
        v32 = *v27;
        v33 = v29;
        do
        {
          v34 = *v33++;
          v31 = 33 * v31 + v34;
          --v32;
        }
        while (v32);
      }
      else
      {
        v31 = 0;
      }
      v35 = v26 - 1;
      v36 = *(_QWORD *)v134;
      v37 = *(_QWORD *)v134 + 8 * v26 + 8;
      v38 = 1;
      v39 = v31;
      while (1)
      {
        v40 = v39 & v35;
        v41 = *(_QWORD **)(v36 + 8 * v40);
        if (v41 != (_QWORD *)-8)
        {
          if (!v41)
            goto LABEL_55;
          if (*(_DWORD *)(v37 + 4 * v40) == v31 && v30 == *v41 && (!v30 || !memcmp(v29, (char *)v41 + v28, v30)))
            break;
        }
        v39 = v38 + v40;
        ++v38;
      }
      *(_QWORD *)(v36 + 8 * (int)v40) = -8;
      *(int32x2_t *)(v130 + 3) = vadd_s32(*(int32x2_t *)(v130 + 3), (int32x2_t)0x1FFFFFFFFLL);
    }
LABEL_55:
    llvm::Value::destroyValueName((uint64_t)this);
    v2 = v128;
    if ((*((_BYTE *)v128 + 23) & 0x10) == 0)
      return;
    v4 = (unsigned int *)((char *)v128 + 20);
    v25 = (llvm::ValueSymbolTable *)v130;
    if (v130)
      goto LABEL_57;
    goto LABEL_4;
  }
  if ((*((_BYTE *)v2 + 23) & 0x10) != 0)
  {
    v133 = 257;
    llvm::Value::setNameImpl((uint64_t ***)v2, (uint64_t)v132);
    if (!*((_BYTE *)v2 + 16))
    {
      if ((*((_BYTE *)v2 + 23) & 0x10) == 0)
        goto LABEL_52;
      v13 = ***(_QWORD ***)v2;
      v6 = *(_QWORD *)(v13 + 152);
      v7 = *(unsigned int *)(v13 + 168);
      if (!(_DWORD)v7)
        goto LABEL_44;
      LODWORD(v8) = (v7 - 1) & ((v2 >> 4) ^ (v2 >> 9));
      v9 = (llvm::Value **)(v6 + 16 * v8);
      v14 = *v9;
      if (*v9 != v2)
      {
        v15 = 1;
        while (v14 != (llvm::Value *)-4096)
        {
          v16 = v8 + v15++;
          v8 = v16 & (v7 - 1);
          v14 = *(llvm::Value **)(v6 + 16 * v8);
          if (v14 == v2)
          {
LABEL_22:
            v9 = (llvm::Value **)(v6 + 16 * v8);
            goto LABEL_45;
          }
        }
        goto LABEL_44;
      }
LABEL_45:
      v42 = v9[1];
      v45 = *(_QWORD *)v42;
      v43 = (char *)v42 + 16;
      v44 = v45;
      if (v45 >= 5 && *(_DWORD *)v43 == *(_DWORD *)"llvm." && v43[4] == aLlvm_1[4])
      {
        *((_DWORD *)v2 + 8) |= 0x2000u;
        v47 = llvm::Function::lookupIntrinsicID(v43, v44);
LABEL_53:
        *((_DWORD *)v2 + 9) = v47;
        return;
      }
LABEL_52:
      v47 = 0;
      *((_DWORD *)v2 + 8) &= ~0x2000u;
      goto LABEL_53;
    }
  }
}

void llvm::Value::doRAUW(llvm::ValueAsMetadata *this, llvm::Value *a2, llvm::Value *a3)
{
  int v3;
  uint64_t v6;
  uint64_t *v7;
  unsigned __int8 *v8;
  BOOL v9;
  uint64_t v10;
  uint64_t v11;

  v3 = (int)a3;
  if ((*((_BYTE *)this + 17) & 1) != 0)
    llvm::ValueHandleBase::ValueIsRAUWd(this, a2, a3);
  if (v3 == 1 && (*((_BYTE *)this + 23) & 8) != 0)
    llvm::ValueAsMetadata::handleRAUW((uint64_t *)this, a2, a3);
  v6 = *((_QWORD *)this + 1);
  if (v6)
  {
    v7 = (uint64_t *)((char *)a2 + 8);
    do
    {
      v8 = *(unsigned __int8 **)(v6 + 24);
      if (v8)
        v9 = v8[16] - 21 >= 0xFFFFFFEF;
      else
        v9 = 0;
      if (v9)
      {
        llvm::Constant::handleOperandChange((llvm::Constant *)v8, this, a2);
      }
      else
      {
        if (*(_QWORD *)v6)
        {
          **(_QWORD **)(v6 + 16) = *(_QWORD *)(v6 + 8);
          v10 = *(_QWORD *)(v6 + 8);
          if (v10)
            *(_QWORD *)(v10 + 16) = *(_QWORD *)(v6 + 16);
        }
        *(_QWORD *)v6 = a2;
        if (a2)
        {
          v11 = *v7;
          *(_QWORD *)(v6 + 8) = *v7;
          if (v11)
            *(_QWORD *)(v11 + 16) = v6 + 8;
          *(_QWORD *)(v6 + 16) = v7;
          *v7 = v6;
        }
      }
      v6 = *((_QWORD *)this + 1);
    }
    while (v6);
  }
  if (*((_BYTE *)this + 16) == 22)
    llvm::BasicBlock::replaceSuccessorsPhiUsesWith(this, this, a2);
}

llvm::ValueHandleBase *llvm::ValueHandleBase::ValueIsRAUWd(llvm::ValueHandleBase *this, llvm::Value *a2, llvm::Value *a3)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;
  unsigned int v8;
  llvm::ValueHandleBase **v9;
  llvm::ValueHandleBase *v10;
  llvm::ValueHandleBase **v11;
  int v12;
  BOOL v13;
  unsigned int v14;
  llvm::ValueHandleBase **v15;
  unint64_t *v16;
  llvm::ValueHandleBase *result;
  int32x2_t ****v18;
  unint64_t **v20;
  char v21;
  unint64_t v22;
  int32x2_t ****v23;
  int32x2_t *v24;
  unint64_t v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  int32x2_t *****v29;
  int32x2_t ****v30;
  int v31;
  int v32;
  unint64_t *v33;
  int v34;
  unint64_t v35;
  int32x2_t ****v36;
  int32x2_t *v37;
  unint64_t v38;
  uint64_t v39;
  unsigned int v40;
  uint64_t v41;
  int32x2_t *****v42;
  int32x2_t ****v43;
  int v44;
  int v45;
  unint64_t v46;
  unint64_t *v47;
  int32x2_t ****v48;
  llvm::ValueHandleBase *v49;

  v49 = this;
  v4 = ***(_QWORD ***)this;
  v5 = *(_DWORD *)(v4 + 2440);
  if (v5)
  {
    v6 = *(_QWORD *)(v4 + 2424);
    v7 = v5 - 1;
    v8 = (v5 - 1) & ((this >> 4) ^ (this >> 9));
    v9 = (llvm::ValueHandleBase **)(v6 + 16 * v8);
    v10 = *v9;
    if (*v9 == this)
      goto LABEL_16;
    v11 = 0;
    v12 = 1;
    while (v10 != (llvm::ValueHandleBase *)-4096)
    {
      if (v11)
        v13 = 0;
      else
        v13 = v10 == (llvm::ValueHandleBase *)-8192;
      if (v13)
        v11 = v9;
      v14 = v8 + v12++;
      v8 = v14 & v7;
      v9 = (llvm::ValueHandleBase **)(v6 + 16 * (v14 & v7));
      v10 = *v9;
      if (*v9 == this)
        goto LABEL_16;
    }
    if (v11)
      v15 = v11;
    else
      v15 = v9;
  }
  else
  {
    v15 = 0;
  }
  v9 = (llvm::ValueHandleBase **)sub_1C5440874(v4 + 2424, (uint64_t)&v49, (uint64_t *)&v49, v15);
  *v9 = v49;
  v9[1] = 0;
LABEL_16:
  v16 = 0;
  result = v9[1];
  v46 = 0;
  v47 = 0;
  v18 = (int32x2_t ****)*((_QWORD *)result + 2);
  v48 = v18;
  if (v18 != (int32x2_t ****)-8192 && v18 != 0 && v18 != (int32x2_t ****)-4096)
  {
    v20 = (unint64_t **)(*(_QWORD *)result & 0xFFFFFFFFFFFFFFF8);
    v47 = *v20;
    *v20 = &v46;
    v46 = (unint64_t)v20;
    v16 = v47;
    if (v47)
      *v47 = *v47 & 7 | (unint64_t)&v47;
  }
  do
  {
    v21 = v46;
    v22 = v46 & 0xFFFFFFFFFFFFFFF8;
    *(_QWORD *)(v46 & 0xFFFFFFFFFFFFFFF8) = v16;
    if (v47)
    {
      *v47 = *v47 & 7 | v22;
      v21 = v46;
    }
    else
    {
      v23 = v48;
      v24 = ***v48;
      v25 = (unint64_t)v24[303];
      if (v25 <= v22)
      {
        v26 = v24[305].u32[0];
        if (v25 + 16 * v26 > v22)
        {
          v27 = v26 - 1;
          LODWORD(v28) = v27 & ((v48 >> 4) ^ (v48 >> 9));
          v29 = (int32x2_t *****)(v25 + 16 * v28);
          v30 = *v29;
          if (v48 == *v29)
          {
LABEL_40:
            *v29 = (int32x2_t ****)-8192;
            v24[304] = vadd_s32(v24[304], (int32x2_t)0x1FFFFFFFFLL);
            v23 = v48;
          }
          else
          {
            v31 = 1;
            while (v30 != (int32x2_t ****)-4096)
            {
              v32 = v28 + v31++;
              v28 = v32 & v27;
              v30 = *(int32x2_t *****)(v25 + 16 * v28);
              if (v48 == v30)
              {
                v29 = (int32x2_t *****)(v25 + 16 * v28);
                goto LABEL_40;
              }
            }
          }
          *((_BYTE *)v23 + 17) &= ~1u;
        }
      }
    }
    v33 = (unint64_t *)*((_QWORD *)result + 1);
    v46 = v21 & 7 | ((unint64_t)result + 8);
    v47 = v33;
    *((_QWORD *)result + 1) = &v46;
    if (v47)
      *v47 = *v47 & 7 | (unint64_t)&v47;
    v34 = (*(_DWORD *)result >> 1) & 3;
    if (v34 == 1)
    {
      (*(void (**)(_QWORD *, llvm::Value *, llvm::Value *))(*((_QWORD *)result - 1) + 16))((_QWORD *)result - 1, a2, a3);
    }
    else if (v34 == 3)
    {
      sub_1C4E3D39C(result, (uint64_t)a2);
    }
    v16 = v47;
    result = (llvm::ValueHandleBase *)v47;
  }
  while (v47);
  if (v48 != (int32x2_t ****)-8192 && v48 != (int32x2_t ****)-4096 && v48)
  {
    v35 = v46 & 0xFFFFFFFFFFFFFFF8;
    *(_QWORD *)(v46 & 0xFFFFFFFFFFFFFFF8) = 0;
    if (v47)
    {
      *v47 = *v47 & 7 | v35;
    }
    else
    {
      v36 = v48;
      v37 = ***v48;
      v38 = (unint64_t)v37[303];
      if (v38 <= v35)
      {
        v39 = v37[305].u32[0];
        if (v38 + 16 * v39 > v35)
        {
          v40 = v39 - 1;
          LODWORD(v41) = v40 & ((v48 >> 4) ^ (v48 >> 9));
          v42 = (int32x2_t *****)(v38 + 16 * v41);
          v43 = *v42;
          if (v48 == *v42)
          {
LABEL_53:
            *v42 = (int32x2_t ****)-8192;
            v37[304] = vadd_s32(v37[304], (int32x2_t)0x1FFFFFFFFLL);
            v36 = v48;
          }
          else
          {
            v44 = 1;
            while (v43 != (int32x2_t ****)-4096)
            {
              v45 = v41 + v44++;
              v41 = v45 & v40;
              v43 = *(int32x2_t *****)(v38 + 16 * v41);
              if (v48 == v43)
              {
                v42 = (int32x2_t *****)(v38 + 16 * v41);
                goto LABEL_53;
              }
            }
          }
          *((_BYTE *)v36 + 17) &= ~1u;
        }
      }
    }
  }
  return result;
}

void llvm::Value::replaceAllUsesWith(llvm::Value *this, llvm::Value *a2)
{
  llvm::Value::doRAUW(this, a2, (llvm::Value *)1);
}

void llvm::Value::replaceUsesWithIf(llvm::Value *a1, llvm::Value *a2, unsigned int (*a3)(uint64_t, uint64_t), uint64_t a4)
{
  uint64_t v4;
  uint64_t *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  unint64_t *v17;
  unint64_t *v18;
  unint64_t v19;
  llvm::Constant *v20;
  int32x2_t *v21;
  unint64_t v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  llvm::Constant **v26;
  llvm::Constant *v27;
  int v28;
  int v29;
  unint64_t v30;
  int64_t v31;
  unint64_t v33;
  llvm::Constant *v34;
  int32x2_t *v35;
  unint64_t v36;
  uint64_t v37;
  unsigned int v38;
  uint64_t v39;
  llvm::Constant **v40;
  llvm::Constant *v41;
  int v42;
  int v43;
  char *v44;
  char *v45;
  uint64_t v46;
  unint64_t v48;
  unint64_t *v49;
  uint64_t v50;
  int32x2_t *v51;
  unint64_t v52;
  uint64_t v53;
  unsigned int v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  int v58;
  int v59;
  unint64_t v60;
  unint64_t *v61;
  llvm::Constant *v62;
  _BYTE *v63;
  _BYTE *v64;
  uint64_t v65;
  int v66;
  _BYTE v67[64];
  void *v68;
  uint64_t v69;
  _QWORD v70[26];

  v70[24] = *MEMORY[0x1E0C80C00];
  v68 = v70;
  v69 = 0x800000000;
  v63 = v67;
  v64 = v67;
  v65 = 8;
  v66 = 0;
  v4 = *((_QWORD *)a1 + 1);
  if (v4)
  {
    v9 = (uint64_t *)((char *)a2 + 8);
    do
    {
      v10 = v4;
      v11 = (uint64_t *)(v4 + 8);
      v4 = *(_QWORD *)(v4 + 8);
      if (a3(a4, v10))
      {
        v12 = *(_QWORD *)(v10 + 24);
        if (v12)
          v13 = *(unsigned __int8 *)(v12 + 16) - 21 >= 0xFFFFFFEF;
        else
          v13 = 0;
        if (v13)
        {
          sub_1C4774094((llvm::SmallPtrSetImplBase *)&v63, *(_QWORD *)(v10 + 24));
          if (v16)
          {
            v60 = 6;
            v61 = 0;
            v62 = 0;
            v17 = &v60;
            sub_1C4E3D39C((llvm::ValueHandleBase *)&v60, v12);
            v18 = (unint64_t *)v68;
            if (v69 >= HIDWORD(v69))
            {
              v30 = v69 + 1;
              if (v68 <= &v60 && (char *)v68 + 24 * v69 > (char *)&v60)
              {
                v31 = (char *)&v60 - (_BYTE *)v68;
                sub_1C6249108((uint64_t)&v68, v30);
                v18 = (unint64_t *)v68;
                v17 = (unint64_t *)((char *)v68 + v31);
              }
              else
              {
                sub_1C6249108((uint64_t)&v68, v30);
                v17 = &v60;
                v18 = (unint64_t *)v68;
              }
            }
            sub_1C5440668(&v18[3 * v69], v17);
            LODWORD(v69) = v69 + 1;
            if (v62 != (llvm::Constant *)-8192 && v62 != (llvm::Constant *)-4096 && v62)
            {
              v19 = v60 & 0xFFFFFFFFFFFFFFF8;
              *(_QWORD *)(v60 & 0xFFFFFFFFFFFFFFF8) = v61;
              if (v61)
              {
                *v61 = *v61 & 7 | v19;
              }
              else
              {
                v20 = v62;
                v21 = ***(int32x2_t ****)v62;
                v22 = (unint64_t)v21[303];
                if (v22 <= v19)
                {
                  v23 = v21[305].u32[0];
                  if (v22 + 16 * v23 > v19)
                  {
                    v24 = v23 - 1;
                    LODWORD(v25) = v24 & ((v62 >> 4) ^ (v62 >> 9));
                    v26 = (llvm::Constant **)(v22 + 16 * v25);
                    v27 = *v26;
                    if (v62 == *v26)
                    {
LABEL_28:
                      *v26 = (llvm::Constant *)-8192;
                      v21[304] = vadd_s32(v21[304], (int32x2_t)0x1FFFFFFFFLL);
                      v20 = v62;
                    }
                    else
                    {
                      v28 = 1;
                      while (v27 != (llvm::Constant *)-4096)
                      {
                        v29 = v25 + v28++;
                        v25 = v29 & v24;
                        v27 = *(llvm::Constant **)(v22 + 16 * v25);
                        if (v62 == v27)
                        {
                          v26 = (llvm::Constant **)(v22 + 16 * v25);
                          goto LABEL_28;
                        }
                      }
                    }
                    *((_BYTE *)v20 + 17) &= ~1u;
                  }
                }
              }
            }
          }
        }
        else
        {
          if (*(_QWORD *)v10)
          {
            **(_QWORD **)(v10 + 16) = *(_QWORD *)(v10 + 8);
            v14 = *(_QWORD *)(v10 + 8);
            if (v14)
              *(_QWORD *)(v14 + 16) = *(_QWORD *)(v10 + 16);
          }
          *(_QWORD *)v10 = a2;
          if (a2)
          {
            v15 = *v9;
            *v11 = *v9;
            if (v15)
              *(_QWORD *)(v15 + 16) = v11;
            *(_QWORD *)(v10 + 16) = v9;
            *v9 = v10;
          }
        }
      }
    }
    while (v4);
    while ((_DWORD)v69)
    {
      sub_1C6248D4C(&v60, (uint64_t)&v68);
      llvm::Constant::handleOperandChange(v62, a1, a2);
      if (v62 != (llvm::Constant *)-8192 && v62 != (llvm::Constant *)-4096 && v62 != 0)
      {
        v33 = v60 & 0xFFFFFFFFFFFFFFF8;
        *(_QWORD *)(v60 & 0xFFFFFFFFFFFFFFF8) = v61;
        if (v61)
        {
          *v61 = *v61 & 7 | v33;
        }
        else
        {
          v34 = v62;
          v35 = ***(int32x2_t ****)v62;
          v36 = (unint64_t)v35[303];
          if (v36 <= v33)
          {
            v37 = v35[305].u32[0];
            if (v36 + 16 * v37 > v33)
            {
              v38 = v37 - 1;
              LODWORD(v39) = v38 & ((v62 >> 4) ^ (v62 >> 9));
              v40 = (llvm::Constant **)(v36 + 16 * v39);
              v41 = *v40;
              if (v62 == *v40)
              {
LABEL_54:
                *v40 = (llvm::Constant *)-8192;
                v35[304] = vadd_s32(v35[304], (int32x2_t)0x1FFFFFFFFLL);
                v34 = v62;
              }
              else
              {
                v42 = 1;
                while (v41 != (llvm::Constant *)-4096)
                {
                  v43 = v39 + v42++;
                  v39 = v43 & v38;
                  v41 = *(llvm::Constant **)(v36 + 16 * v39);
                  if (v62 == v41)
                  {
                    v40 = (llvm::Constant **)(v36 + 16 * v39);
                    goto LABEL_54;
                  }
                }
              }
              *((_BYTE *)v34 + 17) &= ~1u;
            }
          }
        }
      }
    }
  }
  if (v64 != v63)
  {
    free(v64);
    v44 = (char *)v68;
    if (!(_DWORD)v69)
      goto LABEL_80;
    v45 = (char *)v68 + 24 * v69;
    do
    {
      v46 = *((_QWORD *)v45 - 1);
      if (v46 != -8192 && v46 != -4096 && v46 != 0)
      {
        v48 = *((_QWORD *)v45 - 3) & 0xFFFFFFFFFFFFFFF8;
        *(_QWORD *)v48 = *((_QWORD *)v45 - 2);
        v49 = (unint64_t *)*((_QWORD *)v45 - 2);
        if (v49)
        {
          *v49 = *v49 & 7 | v48;
        }
        else
        {
          v50 = *((_QWORD *)v45 - 1);
          v51 = ***(int32x2_t ****)v50;
          v52 = (unint64_t)v51[303];
          if (v52 <= v48)
          {
            v53 = v51[305].u32[0];
            if (v52 + 16 * v53 > v48)
            {
              v54 = v53 - 1;
              LODWORD(v55) = v54 & ((v50 >> 4) ^ (v50 >> 9));
              v56 = (uint64_t *)(v52 + 16 * v55);
              v57 = *v56;
              if (v50 == *v56)
              {
LABEL_76:
                *v56 = -8192;
                v51[304] = vadd_s32(v51[304], (int32x2_t)0x1FFFFFFFFLL);
                v50 = *((_QWORD *)v45 - 1);
              }
              else
              {
                v58 = 1;
                while (v57 != -4096)
                {
                  v59 = v55 + v58++;
                  v55 = v59 & v54;
                  v57 = *(_QWORD *)(v52 + 16 * v55);
                  if (v50 == v57)
                  {
                    v56 = (uint64_t *)(v52 + 16 * v55);
                    goto LABEL_76;
                  }
                }
              }
              *(_BYTE *)(v50 + 17) &= ~1u;
            }
          }
        }
      }
      v45 -= 24;
    }
    while (v45 != v44);
  }
  v44 = (char *)v68;
LABEL_80:
  if (v44 != (char *)v70)
    free(v44);
}

llvm::Value *llvm::Value::stripPointerCasts(llvm::Value *this)
{
  llvm::Value *v1;
  llvm::Value *v2;
  unsigned int v3;
  int v4;
  int v5;
  llvm::Value **v6;
  int v7;
  llvm::Value **v8;
  uint64_t v9;
  unsigned int v10;
  llvm::Value *v11;
  char v12;
  _BYTE *v14;
  _BYTE *v15;
  uint64_t v16;
  int v17;
  _BYTE v18[32];
  uint64_t v19;
  int v20;

  v2 = this;
  if (*(_BYTE *)(*(_QWORD *)this + 8) != 15)
    return this;
  v14 = v18;
  v15 = v18;
  v16 = 4;
  v17 = 0;
  sub_1C4774094((llvm::SmallPtrSetImplBase *)&v14, (uint64_t)this);
  while (1)
  {
    v3 = *((unsigned __int8 *)v2 + 16);
    if (v3 == 62)
      break;
    if (v3 == 5)
    {
      v4 = *((unsigned __int16 *)v2 + 9);
      switch(v4)
      {
        case '2':
          goto LABEL_9;
        case '1':
          goto LABEL_16;
        case '"':
          goto LABEL_8;
      }
LABEL_27:
      v10 = 0;
      v1 = v2;
      goto LABEL_28;
    }
    if (v3 < 0x1C)
      goto LABEL_27;
    if (*((unsigned __int8 *)v2 + 16) <= 0x4Cu)
    {
      if (v3 != 33 && v3 != 39)
        goto LABEL_27;
    }
    else if (v3 != 84)
    {
      if (v3 == 78)
        goto LABEL_9;
      if (v3 == 77)
      {
LABEL_16:
        v7 = *((_DWORD *)v2 + 5);
        if ((v7 & 0x40000000) != 0)
          v8 = (llvm::Value **)*((_QWORD *)v2 - 1);
        else
          v8 = (llvm::Value **)((char *)v2 - 32 * (v7 & 0x7FFFFFF));
        v2 = *v8;
        v11 = *v8;
        if (*(_BYTE *)(*(_QWORD *)*v8 + 8) != 15)
          goto LABEL_40;
        goto LABEL_34;
      }
      goto LABEL_27;
    }
    v20 = 0;
    if (!llvm::AttributeList::hasAttrSomewhere((uint64_t *)v2 + 8, 46, &v20))
    {
      v9 = *((_QWORD *)v2 - 4);
      if (!v9)
        goto LABEL_27;
      if (*(_BYTE *)(v9 + 16))
        goto LABEL_27;
      if (*(_QWORD *)(v9 + 24) != *((_QWORD *)v2 + 9))
        goto LABEL_27;
      v19 = *(_QWORD *)(v9 + 112);
      if (!llvm::AttributeList::hasAttrSomewhere(&v19, 46, &v20))
        goto LABEL_27;
    }
    if (!*((_QWORD *)v2 + 4 * (v20 - 1) + -4 * (*((_DWORD *)v2 + 5) & 0x7FFFFFF)))
      goto LABEL_27;
    v10 = 3;
    v2 = (llvm::Value *)*((_QWORD *)v2 + 4 * (v20 - 1) + -4 * (*((_DWORD *)v2 + 5) & 0x7FFFFFF));
LABEL_28:
    if (v10 <= 1)
      v10 = 1;
    v11 = v1;
    if (v10 != 3)
      goto LABEL_40;
LABEL_34:
    sub_1C4774094((llvm::SmallPtrSetImplBase *)&v14, (uint64_t)v2);
    v11 = v2;
    if (!v12)
      goto LABEL_40;
  }
LABEL_8:
  if (sub_1C535A110((uint64_t)v2))
  {
LABEL_9:
    v5 = *((_DWORD *)v2 + 5);
    if ((v5 & 0x40000000) != 0)
      v6 = (llvm::Value **)*((_QWORD *)v2 - 1);
    else
      v6 = (llvm::Value **)((char *)v2 - 32 * (v5 & 0x7FFFFFF));
    v2 = *v6;
    goto LABEL_34;
  }
  v11 = v2;
LABEL_40:
  if (v15 != v14)
    free(v15);
  return v11;
}

llvm::Value *llvm::Value::stripPointerCastsAndAliases(llvm::Value *this)
{
  llvm::Value *v1;
  llvm::Value *v2;
  unsigned int v3;
  unsigned int v4;
  int v5;
  llvm::Value **v6;
  int v7;
  llvm::Value **v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  BOOL v13;
  llvm::Value *v14;
  char v15;
  _BYTE *v17;
  _BYTE *v18;
  uint64_t v19;
  int v20;
  _BYTE v21[32];
  uint64_t v22;
  int v23;

  v2 = this;
  if (*(_BYTE *)(*(_QWORD *)this + 8) != 15)
    return this;
  v17 = v21;
  v18 = v21;
  v19 = 4;
  v20 = 0;
  sub_1C4774094((llvm::SmallPtrSetImplBase *)&v17, (uint64_t)this);
  while (1)
  {
    v3 = *((unsigned __int8 *)v2 + 16);
    if (v3 == 62)
      break;
    if (v3 == 5)
    {
      v4 = *((unsigned __int16 *)v2 + 9);
      if (v4 == 49)
        goto LABEL_12;
      if (v4 == 34)
        break;
LABEL_15:
      if (v4 == 50)
        goto LABEL_8;
      goto LABEL_16;
    }
    v4 = v3 - 28;
    if (v3 >= 0x1C)
    {
      if (v3 == 77)
      {
LABEL_12:
        v7 = *((_DWORD *)v2 + 5);
        if ((v7 & 0x40000000) != 0)
          v8 = (llvm::Value **)*((_QWORD *)v2 - 1);
        else
          v8 = (llvm::Value **)((char *)v2 - 32 * (v7 & 0x7FFFFFF));
        v2 = *v8;
        v12 = *(unsigned __int8 *)(*(_QWORD *)*v8 + 8);
        v13 = v12 == 15;
        v11 = v12 != 15;
        if (!v13)
          v1 = v2;
        goto LABEL_33;
      }
      goto LABEL_15;
    }
LABEL_16:
    if (v3 == 1)
    {
      v6 = (llvm::Value **)((char *)v2 - 32);
LABEL_18:
      v2 = *v6;
      goto LABEL_38;
    }
    if (v3 >= 0x1C
      && (v9 = v3 - 33, v9 <= 0x33)
      && ((1 << v9) & 0x8000000000041) != 0
      && ((v23 = 0, llvm::AttributeList::hasAttrSomewhere((uint64_t *)v2 + 8, 46, &v23))
       || (v10 = *((_QWORD *)v2 - 4)) != 0
       && !*(_BYTE *)(v10 + 16)
       && *(_QWORD *)(v10 + 24) == *((_QWORD *)v2 + 9)
       && (v22 = *(_QWORD *)(v10 + 112), llvm::AttributeList::hasAttrSomewhere(&v22, 46, &v23)))
      && *((_QWORD *)v2 + 4 * (v23 - 1) + -4 * (*((_DWORD *)v2 + 5) & 0x7FFFFFF)))
    {
      v11 = 3;
      v2 = (llvm::Value *)*((_QWORD *)v2 + 4 * (v23 - 1) + -4 * (*((_DWORD *)v2 + 5) & 0x7FFFFFF));
    }
    else
    {
      v11 = 0;
      v1 = v2;
    }
    if (v11 <= 1)
      v11 = 1;
LABEL_33:
    if (v11)
      v13 = v11 == 3;
    else
      v13 = 1;
    v14 = v1;
    if (!v13)
      goto LABEL_44;
LABEL_38:
    sub_1C4774094((llvm::SmallPtrSetImplBase *)&v17, (uint64_t)v2);
    v14 = v2;
    if (!v15)
      goto LABEL_44;
  }
  if (sub_1C535A110((uint64_t)v2))
  {
LABEL_8:
    v5 = *((_DWORD *)v2 + 5);
    if ((v5 & 0x40000000) != 0)
      v6 = (llvm::Value **)*((_QWORD *)v2 - 1);
    else
      v6 = (llvm::Value **)((char *)v2 - 32 * (v5 & 0x7FFFFFF));
    goto LABEL_18;
  }
  v14 = v2;
LABEL_44:
  if (v18 != v17)
    free(v18);
  return v14;
}

llvm::Value *llvm::Value::stripPointerCastsSameRepresentation(llvm::Value *this)
{
  llvm::Value *v1;
  llvm::Value *v2;
  unsigned int v3;
  int v4;
  int v5;
  llvm::Value **v6;
  int v7;
  llvm::Value **v8;
  uint64_t v9;
  unsigned int v10;
  llvm::Value *v11;
  char v12;
  _BYTE *v14;
  _BYTE *v15;
  uint64_t v16;
  int v17;
  _BYTE v18[32];
  uint64_t v19;
  int v20;

  v2 = this;
  if (*(_BYTE *)(*(_QWORD *)this + 8) != 15)
    return this;
  v14 = v18;
  v15 = v18;
  v16 = 4;
  v17 = 0;
  sub_1C4774094((llvm::SmallPtrSetImplBase *)&v14, (uint64_t)this);
  while (1)
  {
    v3 = *((unsigned __int8 *)v2 + 16);
    if (v3 == 62)
      break;
    if (v3 == 5)
    {
      v4 = *((unsigned __int16 *)v2 + 9);
      if (v4 == 49)
        goto LABEL_19;
      if (v4 == 34)
        break;
LABEL_26:
      v10 = 0;
      v1 = v2;
      goto LABEL_27;
    }
    if (v3 < 0x1C)
      goto LABEL_26;
    if (*((unsigned __int8 *)v2 + 16) > 0x4Cu)
    {
      if (v3 != 84)
      {
        if (v3 == 77)
        {
LABEL_19:
          v7 = *((_DWORD *)v2 + 5);
          if ((v7 & 0x40000000) != 0)
            v8 = (llvm::Value **)*((_QWORD *)v2 - 1);
          else
            v8 = (llvm::Value **)((char *)v2 - 32 * (v7 & 0x7FFFFFF));
          v2 = *v8;
          v11 = *v8;
          if (*(_BYTE *)(*(_QWORD *)*v8 + 8) != 15)
            goto LABEL_39;
          goto LABEL_33;
        }
        goto LABEL_26;
      }
    }
    else if (v3 != 33 && v3 != 39)
    {
      goto LABEL_26;
    }
    v20 = 0;
    if (!llvm::AttributeList::hasAttrSomewhere((uint64_t *)v2 + 8, 46, &v20))
    {
      v9 = *((_QWORD *)v2 - 4);
      if (!v9)
        goto LABEL_26;
      if (*(_BYTE *)(v9 + 16))
        goto LABEL_26;
      if (*(_QWORD *)(v9 + 24) != *((_QWORD *)v2 + 9))
        goto LABEL_26;
      v19 = *(_QWORD *)(v9 + 112);
      if (!llvm::AttributeList::hasAttrSomewhere(&v19, 46, &v20))
        goto LABEL_26;
    }
    if (!*((_QWORD *)v2 + 4 * (v20 - 1) + -4 * (*((_DWORD *)v2 + 5) & 0x7FFFFFF)))
      goto LABEL_26;
    v10 = 3;
    v2 = (llvm::Value *)*((_QWORD *)v2 + 4 * (v20 - 1) + -4 * (*((_DWORD *)v2 + 5) & 0x7FFFFFF));
LABEL_27:
    if (v10 <= 1)
      v10 = 1;
    v11 = v1;
    if (v10 != 3)
      goto LABEL_39;
LABEL_33:
    sub_1C4774094((llvm::SmallPtrSetImplBase *)&v14, (uint64_t)v2);
    v11 = v2;
    if (!v12)
      goto LABEL_39;
  }
  if (sub_1C535A110((uint64_t)v2))
  {
    v5 = *((_DWORD *)v2 + 5);
    if ((v5 & 0x40000000) != 0)
      v6 = (llvm::Value **)*((_QWORD *)v2 - 1);
    else
      v6 = (llvm::Value **)((char *)v2 - 32 * (v5 & 0x7FFFFFF));
    v2 = *v6;
    goto LABEL_33;
  }
  v11 = v2;
LABEL_39:
  if (v15 != v14)
    free(v15);
  return v11;
}

llvm::Value *llvm::Value::stripInBoundsConstantOffsets(llvm::Value *this)
{
  llvm::Value *v1;
  llvm::Value *v2;
  _BYTE *v3;
  _BYTE *v4;
  unsigned int v5;
  int v6;
  int v7;
  uint64_t v8;
  char *v9;
  int v10;
  llvm::Value **v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  llvm::Value **v15;
  int v16;
  uint64_t v17;
  unsigned int v18;
  llvm::Value *v19;
  char v20;
  _BYTE *v22;
  _BYTE *v23;
  uint64_t v24;
  int v25;
  _BYTE v26[32];
  uint64_t v27;
  int v28;

  v2 = this;
  if (*(_BYTE *)(*(_QWORD *)this + 8) != 15)
    return this;
  v22 = v26;
  v23 = v26;
  v24 = 4;
  v25 = 0;
  sub_1C4774094((llvm::SmallPtrSetImplBase *)&v22, (uint64_t)this);
  v4 = v22;
  v3 = v23;
  while (1)
  {
    v5 = *((unsigned __int8 *)v2 + 16);
    if (v5 == 62)
      goto LABEL_8;
    if (v5 == 5)
    {
      v6 = *((unsigned __int16 *)v2 + 9);
      if (v6 == 50)
        goto LABEL_25;
      if (v6 != 49)
      {
        if (v6 != 34)
          goto LABEL_36;
LABEL_8:
        v7 = *((_DWORD *)v2 + 5);
        if ((v7 & 0x40000000) != 0)
        {
          v9 = (char *)*((_QWORD *)v2 - 1);
          v8 = v7 & 0x7FFFFFF;
        }
        else
        {
          v8 = v7 & 0x7FFFFFF;
          v9 = (char *)v2 - 32 * v8;
        }
        v12 = (uint64_t *)(v9 + 32);
        v13 = 32 * v8 - 32;
        while (v13)
        {
          v14 = *v12;
          v12 += 4;
          v13 -= 32;
          if (*(_BYTE *)(v14 + 16) != 16)
            goto LABEL_48;
        }
        if ((*((_BYTE *)v2 + 17) & 2) == 0)
        {
LABEL_48:
          v19 = v2;
          goto LABEL_49;
        }
        if ((v7 & 0x40000000) != 0)
          goto LABEL_27;
        v15 = (llvm::Value **)((char *)v2 - 32 * v8);
LABEL_28:
        v2 = *v15;
        goto LABEL_43;
      }
      goto LABEL_15;
    }
    if (v5 < 0x1C)
      goto LABEL_36;
    if (*((unsigned __int8 *)v2 + 16) <= 0x4Cu)
      break;
    if (v5 == 84)
      goto LABEL_31;
    if (v5 == 78)
    {
LABEL_25:
      v16 = *((_DWORD *)v2 + 5);
      if ((v16 & 0x40000000) != 0)
LABEL_27:
        v15 = (llvm::Value **)*((_QWORD *)v2 - 1);
      else
        v15 = (llvm::Value **)((char *)v2 - 32 * (v16 & 0x7FFFFFF));
      goto LABEL_28;
    }
    if (v5 != 77)
      goto LABEL_36;
LABEL_15:
    v10 = *((_DWORD *)v2 + 5);
    if ((v10 & 0x40000000) != 0)
      v11 = (llvm::Value **)*((_QWORD *)v2 - 1);
    else
      v11 = (llvm::Value **)((char *)v2 - 32 * (v10 & 0x7FFFFFF));
    v2 = *v11;
    v19 = *v11;
    if (*(_BYTE *)(*(_QWORD *)*v11 + 8) != 15)
      goto LABEL_49;
LABEL_43:
    sub_1C4774094((llvm::SmallPtrSetImplBase *)&v22, (uint64_t)v2);
    v4 = v22;
    v3 = v23;
    v19 = v2;
    if (!v20)
      goto LABEL_49;
  }
  if (v5 != 33 && v5 != 39)
  {
LABEL_36:
    v18 = 0;
    v1 = v2;
    goto LABEL_37;
  }
LABEL_31:
  v28 = 0;
  if (!llvm::AttributeList::hasAttrSomewhere((uint64_t *)v2 + 8, 46, &v28))
  {
    v17 = *((_QWORD *)v2 - 4);
    if (!v17)
      goto LABEL_36;
    if (*(_BYTE *)(v17 + 16))
      goto LABEL_36;
    if (*(_QWORD *)(v17 + 24) != *((_QWORD *)v2 + 9))
      goto LABEL_36;
    v27 = *(_QWORD *)(v17 + 112);
    if (!llvm::AttributeList::hasAttrSomewhere(&v27, 46, &v28))
      goto LABEL_36;
  }
  if (!*((_QWORD *)v2 + 4 * (v28 - 1) + -4 * (*((_DWORD *)v2 + 5) & 0x7FFFFFF)))
    goto LABEL_36;
  v18 = 3;
  v2 = (llvm::Value *)*((_QWORD *)v2 + 4 * (v28 - 1) + -4 * (*((_DWORD *)v2 + 5) & 0x7FFFFFF));
LABEL_37:
  if (v18 <= 1)
    v18 = 1;
  v19 = v1;
  if (v18 == 3)
    goto LABEL_43;
LABEL_49:
  if (v3 != v4)
    free(v3);
  return v19;
}

llvm::Value *llvm::Value::stripPointerCastsForAliasAnalysis(llvm::Value *this)
{
  llvm::Value *v1;
  llvm::Value *v2;
  unsigned int v3;
  int v4;
  int v5;
  llvm::Value **v6;
  char *v7;
  llvm::Value *v8;
  int v9;
  uint64_t v10;
  int v11;
  BOOL v12;
  llvm::Value *v13;
  int v14;
  char v15;
  _BYTE *v17;
  _BYTE *v18;
  uint64_t v19;
  int v20;
  _BYTE v21[32];
  uint64_t v22;
  int v23;

  v2 = this;
  if (*(_BYTE *)(*(_QWORD *)this + 8) != 15)
    return this;
  v17 = v21;
  v18 = v21;
  v19 = 4;
  v20 = 0;
  sub_1C4774094((llvm::SmallPtrSetImplBase *)&v17, (uint64_t)this);
  while (1)
  {
    v3 = *((unsigned __int8 *)v2 + 16);
    if (v3 == 62)
      break;
    if (v3 != 5)
    {
      if (v3 >= 0x1C)
      {
        LODWORD(v7) = 0;
        v8 = v2;
        switch(*((_BYTE *)v2 + 16))
        {
          case 'M':
            goto LABEL_18;
          case 'N':
            goto LABEL_9;
          case 'O':
          case 'P':
          case 'Q':
          case 'R':
            goto LABEL_14;
          case 'S':
            v14 = *((_DWORD *)v2 + 5);
            if ((v14 & 0x7FFFFFF) != 1)
              break;
            if ((v14 & 0x40000000) != 0)
              goto LABEL_44;
            v6 = (llvm::Value **)((char *)v2 - 32);
            goto LABEL_45;
          case 'T':
            goto LABEL_22;
          default:
            if (v3 != 33 && v3 != 39)
              goto LABEL_13;
LABEL_22:
            v23 = 0;
            if (llvm::AttributeList::hasAttrSomewhere((uint64_t *)v2 + 8, 46, &v23)
              || (v10 = *((_QWORD *)v2 - 4)) != 0
              && !*(_BYTE *)(v10 + 16)
              && *(_QWORD *)(v10 + 24) == *((_QWORD *)v2 + 9)
              && (v22 = *(_QWORD *)(v10 + 112), llvm::AttributeList::hasAttrSomewhere(&v22, 46, &v23)))
            {
              if (*((_QWORD *)v2 + 4 * (v23 - 1) + -4 * (*((_DWORD *)v2 + 5) & 0x7FFFFFF)))
              {
                LODWORD(v7) = 3;
                v2 = (llvm::Value *)*((_QWORD *)v2 + 4 * (v23 - 1)
                                                   + -4 * (*((_DWORD *)v2 + 5) & 0x7FFFFFF));
                goto LABEL_34;
              }
            }
            v7 = (char *)*((_QWORD *)v2 - 4);
            if (!v7)
              goto LABEL_13;
            if (!v7[16]
              && (*((_QWORD *)v7 + 3) == *((_QWORD *)v2 + 9) && *((_DWORD *)v7 + 9) == 166
               || *((_QWORD *)v7 + 3) == *((_QWORD *)v2 + 9) && *((_DWORD *)v7 + 9) == 290))
            {
              v2 = (llvm::Value *)*((_QWORD *)v2 - 4 * (*((_DWORD *)v2 + 5) & 0x7FFFFFF));
              LODWORD(v7) = 3;
LABEL_34:
              v8 = v1;
              goto LABEL_14;
            }
            break;
        }
      }
LABEL_12:
      LODWORD(v7) = 0;
LABEL_13:
      v8 = v2;
LABEL_14:
      if (v7 <= 1)
        LODWORD(v7) = 1;
      v1 = v8;
LABEL_39:
      v13 = v1;
      if ((_DWORD)v7 != 3)
        goto LABEL_52;
      goto LABEL_46;
    }
    v4 = *((unsigned __int16 *)v2 + 9);
    if (v4 == 50)
      goto LABEL_9;
    if (v4 != 49)
    {
      if (v4 != 34)
        goto LABEL_12;
      break;
    }
LABEL_18:
    v9 = *((_DWORD *)v2 + 5);
    if ((v9 & 0x40000000) != 0)
      v7 = (char *)*((_QWORD *)v2 - 1);
    else
      v7 = (char *)v2 - 32 * (v9 & 0x7FFFFFF);
    v2 = *(llvm::Value **)v7;
    v11 = *(unsigned __int8 *)(**(_QWORD **)v7 + 8);
    v12 = v11 == 15;
    LODWORD(v7) = v11 != 15;
    if (!v12)
      v1 = v2;
    if ((_DWORD)v7)
      goto LABEL_39;
LABEL_46:
    sub_1C4774094((llvm::SmallPtrSetImplBase *)&v17, (uint64_t)v2);
    v13 = v2;
    if (!v15)
      goto LABEL_52;
  }
  if (sub_1C535A110((uint64_t)v2))
  {
LABEL_9:
    v5 = *((_DWORD *)v2 + 5);
    if ((v5 & 0x40000000) != 0)
LABEL_44:
      v6 = (llvm::Value **)*((_QWORD *)v2 - 1);
    else
      v6 = (llvm::Value **)((char *)v2 - 32 * (v5 & 0x7FFFFFF));
LABEL_45:
    v2 = *v6;
    goto LABEL_46;
  }
  v13 = v2;
LABEL_52:
  if (v18 != v17)
    free(v18);
  return v13;
}

uint64_t llvm::Value::stripAndAccumulateConstantOffsets(uint64_t a1, llvm::DataLayout *a2, const void **a3, char a4, uint64_t a5, unsigned int (*a6)(uint64_t), uint64_t a7)
{
  uint64_t v13;
  int v14;
  uint64_t v15;
  _BYTE *v16;
  _BYTE *v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  int v24;
  uint64_t *v25;
  llvm::Module *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  unint64_t v35;
  unsigned int v36;
  _BOOL4 v37;
  uint64_t v38;
  int v39;
  uint64_t *v40;
  char v41;
  uint64_t v42;
  unint64_t *v43;
  uint64_t *v44;
  unint64_t v45;
  unint64_t v46;
  uint64_t v47;
  unint64_t v48;
  _BOOL4 v49;
  char v51;
  uint64_t v52;
  const void *v53;
  unsigned int v54;
  BOOL v55;
  void *v56;
  unsigned int v57;
  void *__src;
  unsigned int IndexTypeSizeInBits;
  _BYTE *v60;
  _BYTE *v61;
  uint64_t v62;
  int v63;
  _BYTE v64[32];

  v13 = a1;
  if ((*(_DWORD *)(*(_QWORD *)a1 + 8) & 0xFE) == 0x12)
    v14 = *(unsigned __int8 *)(**(_QWORD **)(*(_QWORD *)a1 + 16) + 8);
  else
    v14 = *(_DWORD *)(*(_QWORD *)a1 + 8);
  if (v14 != 15)
    return v13;
  v15 = *((unsigned int *)a3 + 2);
  v60 = v64;
  v61 = v64;
  v62 = 4;
  v63 = 0;
  sub_1C4774094((llvm::SmallPtrSetImplBase *)&v60, a1);
  v17 = v60;
  v16 = v61;
  v51 = a4;
  while (1)
  {
    v18 = *(unsigned __int8 *)(v13 + 16);
    if (v18 == 62)
      break;
    if (v18 == 5)
    {
      v19 = *(unsigned __int16 *)(v13 + 18);
      if (v19 == 49)
        goto LABEL_20;
      if (v19 == 34)
        break;
    }
    else
    {
      v19 = v18 - 28;
      if (v18 < 0x1C)
        goto LABEL_22;
      if (v18 == 77)
        goto LABEL_20;
    }
    if (v19 != 50)
    {
LABEL_22:
      if (v18 == 1)
      {
        if ((*(_DWORD *)(v13 + 32) & 0xFu) - 5 >= 4 && ((1 << (*(_DWORD *)(v13 + 32) & 0xF)) & 0x614) != 0)
          goto LABEL_88;
        v26 = *(llvm::Module **)(v13 + 40);
        if (v26)
        {
          if (llvm::Module::getSemanticInterposition(v26) && (*(_BYTE *)(v13 + 33) & 0x40) == 0)
            goto LABEL_88;
        }
        v25 = (uint64_t *)(v13 - 32);
        goto LABEL_28;
      }
      if (v18 < 0x1C || v18 - 33 > 0x33 || ((1 << (v18 - 33)) & 0x8000000000041) == 0)
        goto LABEL_88;
      LODWORD(v56) = 0;
      if (!llvm::AttributeList::hasAttrSomewhere((uint64_t *)(v13 + 64), 46, (int *)&v56))
      {
        v27 = *(_QWORD *)(v13 - 32);
        if (!v27)
        {
LABEL_38:
          if (v27)
            v28 = v27;
          else
            v28 = v13;
          if (!(_DWORD)a5 || !llvm::Instruction::isLaunderOrStripInvariantGroup((llvm::Instruction *)v13))
          {
            v13 = v28;
            goto LABEL_88;
          }
          v24 = *(_DWORD *)(v13 + 20);
          goto LABEL_21;
        }
        if (*(_BYTE *)(v27 + 16)
          || *(_QWORD *)(v27 + 24) != *(_QWORD *)(v13 + 72)
          || (__src = *(void **)(v27 + 112), !llvm::AttributeList::hasAttrSomewhere((uint64_t *)&__src, 46, (int *)&v56)))
        {
          v27 = 0;
          goto LABEL_38;
        }
      }
      v27 = *(_QWORD *)(v13 - 32 * (*(_DWORD *)(v13 + 20) & 0x7FFFFFF) + 32 * ((_DWORD)v56 - 1));
      goto LABEL_38;
    }
LABEL_20:
    v24 = *(_DWORD *)(v13 + 20);
    if ((v24 & 0x40000000) != 0)
    {
      v25 = *(uint64_t **)(v13 - 8);
      goto LABEL_28;
    }
LABEL_21:
    v25 = (uint64_t *)(v13 - 32 * (v24 & 0x7FFFFFF));
LABEL_28:
    v13 = *v25;
LABEL_88:
    sub_1C4774094((llvm::SmallPtrSetImplBase *)&v60, v13);
    v17 = v60;
    v16 = v61;
    if (!v41)
      goto LABEL_106;
  }
  if ((a4 & 1) == 0 && (*(_BYTE *)(v13 + 17) & 2) == 0)
    goto LABEL_106;
  IndexTypeSizeInBits = llvm::DataLayout::getIndexTypeSizeInBits((uint64_t)a2, *(_QWORD *)v13);
  if (IndexTypeSizeInBits > 0x40)
    llvm::APInt::initSlowCase((llvm::APInt *)&__src, 0, 0);
  else
    __src = 0;
  v20 = llvm::GEPOperator::accumulateConstantOffset(v13, a2, (uint64_t)&__src, a6, a7);
  v21 = IndexTypeSizeInBits;
  if (!v20
    || (v22 = v21 - sub_1C4959174((llvm::APInt *)&__src) + 1, v21 = IndexTypeSizeInBits, v22 > v15))
  {
    v23 = 1;
    v52 = v13;
    goto LABEL_84;
  }
  if (IndexTypeSizeInBits < v15)
  {
    llvm::APInt::sext((llvm::APInt *)&__src, v15, (llvm::APInt *)&v56);
  }
  else if (IndexTypeSizeInBits > v15)
  {
    llvm::APInt::trunc((llvm::APInt *)&__src, v15, (llvm::APInt *)&v56);
  }
  else
  {
    v57 = IndexTypeSizeInBits;
    if (IndexTypeSizeInBits > 0x40)
    {
      v56 = (void *)operator new[]();
      memcpy(v56, __src, (((unint64_t)v57 + 63) >> 3) & 0x3FFFFFF8);
    }
    else
    {
      v56 = __src;
    }
  }
  if (!a6)
  {
    v34 = *((unsigned int *)a3 + 2);
    if (v34 >= 0x41)
    {
      v42 = 0;
      v43 = (unint64_t *)*a3;
      v44 = (uint64_t *)v56;
      v45 = (unint64_t)(v34 + 63) >> 6;
      v46 = v45;
      do
      {
        v47 = *v44++;
        v48 = v47 + *v43;
        v49 = v48 + 1 <= *v43;
        if (v42)
        {
          ++v48;
          v42 = v49;
        }
        else
        {
          v42 = v48 < *v43;
        }
        *v43++ = v48;
        --v46;
      }
      while (v46);
      *((_QWORD *)*a3 + (v45 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v34;
    }
    else
    {
      if ((_DWORD)v34)
        v35 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v34;
      else
        v35 = 0;
      *a3 = (const void *)(v35 & ((unint64_t)v56 + (_QWORD)*a3));
    }
    goto LABEL_76;
  }
  v29 = a7;
  v30 = v15;
  v31 = a5;
  v55 = 0;
  v32 = *((unsigned int *)a3 + 2);
  if (v32 > 0x40)
  {
    v33 = (_QWORD *)operator new[]();
    memcpy(v33, *a3, ((unint64_t)(v32 + 63) >> 3) & 0x3FFFFFF8);
  }
  else
  {
    v33 = *a3;
  }
  llvm::APInt::sadd_ov(a3, (const llvm::APInt *)&v56, &v55, (uint64_t)&v53);
  if (*((_DWORD *)a3 + 2) >= 0x41u && *a3)
    MEMORY[0x1CAA32F9C](*a3, 0x1000C8000313F17);
  *a3 = v53;
  v36 = v54;
  *((_DWORD *)a3 + 2) = v54;
  v37 = v55;
  if (v55)
  {
    if (v36 <= 0x40 && v32 <= 0x40)
    {
      *a3 = v33;
      *((_DWORD *)a3 + 2) = v32;
      v23 = 1;
      v52 = v13;
      goto LABEL_74;
    }
    llvm::APInt::reallocate((uint64_t)a3, v32);
    v38 = *((unsigned int *)a3 + 2);
    if (v38 <= 0x40)
      *a3 = v33;
    else
      memcpy((void *)*a3, v33, ((unint64_t)(v38 + 63) >> 3) & 0x3FFFFFF8);
    v52 = v13;
  }
  if (v32 >= 0x41 && v33)
    MEMORY[0x1CAA32F9C](v33, 0x1000C8000313F17);
  if (!v37)
  {
    a5 = v31;
    v15 = v30;
    a7 = v29;
    a4 = v51;
LABEL_76:
    v39 = *(_DWORD *)(v13 + 20);
    if ((v39 & 0x40000000) != 0)
      v40 = *(uint64_t **)(v13 - 8);
    else
      v40 = (uint64_t *)(v13 - 32 * (v39 & 0x7FFFFFF));
    v23 = 0;
    v13 = *v40;
    goto LABEL_80;
  }
  v23 = 1;
LABEL_74:
  a5 = v31;
  v15 = v30;
  a7 = v29;
  a4 = v51;
LABEL_80:
  if (v57 >= 0x41 && v56)
    MEMORY[0x1CAA32F9C](v56, 0x1000C8000313F17);
  v21 = IndexTypeSizeInBits;
LABEL_84:
  if (v21 >= 0x41 && __src)
    MEMORY[0x1CAA32F9C](__src, 0x1000C8000313F17);
  if (!v23)
    goto LABEL_88;
  v17 = v60;
  v16 = v61;
  v13 = v52;
LABEL_106:
  if (v16 != v17)
    free(v16);
  return v13;
}

uint64_t llvm::Value::stripInBoundsOffsets(uint64_t a1, void (*a2)(uint64_t, uint64_t), uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  unsigned int v7;
  int v8;
  int v9;
  uint64_t *v10;
  int v11;
  uint64_t *v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  char v16;
  _BYTE *v18;
  _BYTE *v19;
  uint64_t v20;
  int v21;
  _BYTE v22[32];
  uint64_t v23;
  int v24;

  v4 = a1;
  if (*(_BYTE *)(*(_QWORD *)a1 + 8) != 15)
    return a1;
  v18 = v22;
  v19 = v22;
  v20 = 4;
  v21 = 0;
  sub_1C4774094((llvm::SmallPtrSetImplBase *)&v18, a1);
  while (1)
  {
    a2(a3, v4);
    v7 = *(unsigned __int8 *)(v4 + 16);
    if (v7 == 62)
      break;
    if (v7 == 5)
    {
      v8 = *(unsigned __int16 *)(v4 + 18);
      switch(v8)
      {
        case '2':
          goto LABEL_9;
        case '1':
          goto LABEL_16;
        case '"':
          goto LABEL_8;
      }
LABEL_27:
      v14 = 0;
      v3 = v4;
      goto LABEL_28;
    }
    if (v7 < 0x1C)
      goto LABEL_27;
    if (*(unsigned __int8 *)(v4 + 16) <= 0x4Cu)
    {
      if (v7 != 33 && v7 != 39)
        goto LABEL_27;
    }
    else if (v7 != 84)
    {
      if (v7 == 78)
        goto LABEL_9;
      if (v7 == 77)
      {
LABEL_16:
        v11 = *(_DWORD *)(v4 + 20);
        if ((v11 & 0x40000000) != 0)
          v12 = *(uint64_t **)(v4 - 8);
        else
          v12 = (uint64_t *)(v4 - 32 * (v11 & 0x7FFFFFF));
        v4 = *v12;
        v15 = *v12;
        if (*(_BYTE *)(*(_QWORD *)*v12 + 8) != 15)
          goto LABEL_40;
        goto LABEL_34;
      }
      goto LABEL_27;
    }
    v24 = 0;
    if (!llvm::AttributeList::hasAttrSomewhere((uint64_t *)(v4 + 64), 46, &v24))
    {
      v13 = *(_QWORD *)(v4 - 32);
      if (!v13)
        goto LABEL_27;
      if (*(_BYTE *)(v13 + 16))
        goto LABEL_27;
      if (*(_QWORD *)(v13 + 24) != *(_QWORD *)(v4 + 72))
        goto LABEL_27;
      v23 = *(_QWORD *)(v13 + 112);
      if (!llvm::AttributeList::hasAttrSomewhere(&v23, 46, &v24))
        goto LABEL_27;
    }
    if (!*(_QWORD *)(v4 - 32 * (*(_DWORD *)(v4 + 20) & 0x7FFFFFF) + 32 * (v24 - 1)))
      goto LABEL_27;
    v14 = 3;
    v4 = *(_QWORD *)(v4 - 32 * (*(_DWORD *)(v4 + 20) & 0x7FFFFFF) + 32 * (v24 - 1));
LABEL_28:
    if (v14 <= 1)
      v14 = 1;
    v15 = v3;
    if (v14 != 3)
      goto LABEL_40;
LABEL_34:
    sub_1C4774094((llvm::SmallPtrSetImplBase *)&v18, v4);
    v15 = v4;
    if (!v16)
      goto LABEL_40;
  }
LABEL_8:
  if ((*(_BYTE *)(v4 + 17) & 2) != 0)
  {
LABEL_9:
    v9 = *(_DWORD *)(v4 + 20);
    if ((v9 & 0x40000000) != 0)
      v10 = *(uint64_t **)(v4 - 8);
    else
      v10 = (uint64_t *)(v4 - 32 * (v9 & 0x7FFFFFF));
    v4 = *v10;
    goto LABEL_34;
  }
  v15 = v4;
LABEL_40:
  if (v19 != v18)
    free(v19);
  return v15;
}

BOOL llvm::Value::canBeFreed(llvm::Value *this)
{
  unsigned int v1;
  _BOOL8 result;
  uint64_t *v4;
  uint64_t v5;
  _QWORD *GC;
  char v7;
  uint64_t v8;
  unint64_t v9;
  size_t v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  _BYTE *v17;

  v1 = *((unsigned __int8 *)this + 16);
  if (v1 < 0x15)
    return 0;
  if (v1 == 21)
  {
    if ((llvm::Argument::hasPointeeInMemoryValueAttr(this) & 1) != 0)
      return 0;
    v17 = *(_BYTE **)(*((_QWORD *)this + 3) + 112);
    if (v17 && ((v17[17] & 0x30) != 0 || (v17[15] & 2) != 0) && (v17[16] & 8) != 0)
      return 0;
    v1 = *((unsigned __int8 *)this + 16);
  }
  if (v1 >= 0x1C)
  {
    v4 = (uint64_t *)(*((_QWORD *)this + 5) + 56);
  }
  else
  {
    if (v1 != 21)
      return 1;
    v4 = (uint64_t *)((char *)this + 24);
  }
  v5 = *v4;
  if (!*v4 || (*(_WORD *)(v5 + 18) & 0x4000) == 0)
    return 1;
  GC = llvm::LLVMContext::getGC(**(llvm::LLVMContext ***)v5, (const llvm::Function *)v5);
  v7 = *((_BYTE *)GC + 23);
  v8 = v7 >= 0 ? v7 & 0x7F : GC[1];
  if (v8 != 18)
    return 1;
  if (v7 >= 0)
    v9 = *((unsigned __int8 *)GC + 23);
  else
    v9 = GC[1];
  if (v7 < 0)
    GC = (_QWORD *)*GC;
  v10 = v9 >= 0x12 ? 18 : v9;
  v11 = !memcmp(GC, "statepoint-example", v10) && v9 == 18;
  if (!v11 || (*(_DWORD *)(*(_QWORD *)this + 8) & 0xFFFFFF00) != 0x100)
    return 1;
  v12 = *(_QWORD *)(v5 + 40);
  v13 = v12 + 24;
  v14 = *(_QWORD *)(v12 + 32);
  if (v14 == v13)
    return 0;
  do
  {
    v15 = v14 - 56;
    if (!v14)
      v15 = 0;
    v16 = *(_DWORD *)(v15 + 36);
    result = v16 == 124;
    if (v16 == 124)
      break;
    v14 = *(_QWORD *)(v14 + 8);
  }
  while (v14 != v13);
  return result;
}

uint64_t llvm::Value::getPointerDereferenceableBytes(uint64_t ***this, const llvm::DataLayout *a2, BOOL *a3, BOOL *a4)
{
  BOOL canBeFreed;
  unsigned int v9;
  uint64_t result;
  uint64_t PointeeInMemoryValueType;
  uint64_t v12;
  unsigned int v13;
  unint64_t v14;
  llvm::AttributeList *v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  unsigned int v23;
  llvm::Value **v24;
  llvm::Value *v25;
  llvm::Value **v26;
  int v27;
  BOOL v28;
  unsigned int v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  int v36;
  unsigned int v37;
  llvm::Value **v38;
  llvm::Value *v39;
  llvm::Value **v40;
  int v41;
  BOOL v42;
  unsigned int v43;
  uint64_t v44;
  _QWORD *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  int v52;
  unsigned int v53;
  llvm::Value **v54;
  llvm::Value *v55;
  llvm::Value **v56;
  int v57;
  BOOL v58;
  unsigned int v59;
  uint64_t v60;
  _QWORD *v61;
  uint64_t v62;
  uint64_t v63;
  int v64;
  uint64_t v65;
  int v66;
  unsigned int v67;
  llvm::Value **v68;
  llvm::Value *v69;
  llvm::Value **v70;
  int v71;
  BOOL v72;
  unsigned int v73;
  uint64_t v74;
  uint64_t v75;
  int isSizedDerivedType;
  uint64_t v78;
  uint64_t v79;
  _QWORD *v80;
  unsigned int v81;
  uint64_t v82;
  uint64_t v83;
  _QWORD *v84;
  unsigned int v85;
  uint64_t v86;
  uint64_t v87;
  _QWORD *v88;
  unsigned int v89;
  llvm::Value **v90;
  llvm::Value *v91;
  llvm::Value **v92;
  llvm::Value *v93;
  llvm::Value **v94;
  llvm::Value *v95;
  llvm::Value **v96;
  llvm::Value *v97;
  llvm::Value *v98;

  *a3 = 0;
  if (dword_1ED804D10)
    canBeFreed = llvm::Value::canBeFreed((llvm::Value *)this);
  else
    canBeFreed = 0;
  *a4 = canBeFreed;
  v9 = *((unsigned __int8 *)this + 16);
  if (this && v9 == 21)
  {
    result = llvm::Argument::getDereferenceableBytes((llvm::Argument *)this);
    if (result)
      return result;
    PointeeInMemoryValueType = llvm::Argument::getPointeeInMemoryValueType((llvm::Argument *)this);
    if (!PointeeInMemoryValueType)
      goto LABEL_11;
    v12 = PointeeInMemoryValueType;
    v13 = *(unsigned __int8 *)(PointeeInMemoryValueType + 8);
    if (v13 <= 0x11)
    {
      if (((1 << v13) & 0xAC7F) != 0)
        goto LABEL_10;
      if (((1 << v13) & 0x30000) != 0)
        goto LABEL_156;
    }
    if ((v13 & 0xFE) == 0x12 || v13 == 21)
    {
LABEL_156:
      if (llvm::Type::isSizedDerivedType(PointeeInMemoryValueType, 0))
      {
LABEL_10:
        sub_1C4768AD0((uint64_t)a2, v12);
        if (v14 != 0 && v14 < 0xFFFFFFFFFFFFFFF9)
          return (v14 + 7) >> 3;
      }
    }
LABEL_11:
    result = llvm::AttributeList::getParamDereferenceableOrNullBytes((llvm::AttributeList *)(this[3] + 14), *((_DWORD *)this + 8));
LABEL_117:
    *a3 = 1;
    return result;
  }
  if (v9 < 0x1C)
  {
    result = 0;
    if (!this || v9 != 3)
      return result;
    v17 = (uint64_t)this[3];
    v18 = *(unsigned __int8 *)(v17 + 8);
    if (v18 > 0x11)
      goto LABEL_95;
    if (((1 << v18) & 0xAC7F) != 0)
      goto LABEL_23;
    if (((1 << v18) & 0x30000) == 0)
    {
LABEL_95:
      if ((v18 & 0xFE) != 0x12 && v18 != 21)
        return 0;
    }
    isSizedDerivedType = llvm::Type::isSizedDerivedType(v17, 0);
    result = 0;
    if (!isSizedDerivedType)
      return result;
LABEL_23:
    if ((llvm::GlobalValue::hasExternalWeakLinkage((llvm::GlobalValue *)this) & 1) == 0)
    {
      v47 = (uint64_t)this[3];
LABEL_59:
      sub_1C4768AD0((uint64_t)a2, v47);
      result = (unint64_t)(v48 + 7) >> 3;
      *a3 = 0;
      *a4 = 0;
      return result;
    }
    return 0;
  }
  if (v9 - 33 <= 0x33 && ((1 << (v9 - 33)) & 0x8000000000041) != 0)
  {
    v16 = (llvm::AttributeList *)(this + 8);
    result = llvm::AttributeList::getRetDereferenceableBytes(v16);
    if (result)
      return result;
    result = llvm::AttributeList::getRetDereferenceableOrNullBytes(v16);
    goto LABEL_117;
  }
  if (!this || v9 != 60)
  {
    if (this && v9 == 76)
    {
      if ((*((_BYTE *)this + 23) & 0x20) == 0)
        goto LABEL_78;
      v49 = ***this;
      v98 = (llvm::Value *)this;
      v50 = *(_DWORD *)(v49 + 2496);
      if (v50)
      {
        v51 = *(_QWORD *)(v49 + 2480);
        v52 = v50 - 1;
        v53 = v52 & ((this >> 4) ^ (this >> 9));
        v54 = (llvm::Value **)(v51 + 40 * v53);
        v55 = *v54;
        if (*v54 == (llvm::Value *)this)
        {
LABEL_74:
          v60 = *((unsigned int *)v54 + 4);
          if ((_DWORD)v60)
          {
            v61 = (_QWORD *)((char *)v54[1] + 8);
            v62 = 16 * v60;
            while (*((_DWORD *)v61 - 2) != 12)
            {
              v61 += 2;
              v62 -= 16;
              if (!v62)
                goto LABEL_78;
            }
            v86 = *v61;
            if (v86)
            {
              v87 = *(_QWORD *)(*(_QWORD *)(v86 - 8 * *(unsigned int *)(v86 + 8)) + 128);
              v88 = (_QWORD *)(v87 + 24);
              v89 = *(_DWORD *)(v87 + 32);
              if (v89 >= 0x41)
              {
                if (v89 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)(v87 + 24)) > 0x40)
                  return -1;
                v88 = (_QWORD *)*v88;
              }
              result = *v88;
              if (*v88)
                return result;
            }
          }
LABEL_78:
          if ((*((_BYTE *)this + 23) & 0x20) == 0)
            goto LABEL_116;
          v63 = ***this;
          v98 = (llvm::Value *)this;
          v64 = *(_DWORD *)(v63 + 2496);
          if (v64)
          {
            v65 = *(_QWORD *)(v63 + 2480);
            v66 = v64 - 1;
            v67 = v66 & ((this >> 4) ^ (this >> 9));
            v68 = (llvm::Value **)(v65 + 40 * v67);
            v69 = *v68;
            if (*v68 == (llvm::Value *)this)
            {
LABEL_89:
              v74 = *((unsigned int *)v68 + 4);
              if (!(_DWORD)v74)
                goto LABEL_116;
              v45 = (_QWORD *)((char *)v68[1] + 8);
              v75 = 16 * v74;
              while (*((_DWORD *)v45 - 2) != 13)
              {
                result = 0;
                v45 += 2;
                v75 -= 16;
                if (!v75)
                  goto LABEL_117;
              }
LABEL_112:
              v78 = *v45;
              if (v78)
              {
                v79 = *(_QWORD *)(*(_QWORD *)(v78 - 8 * *(unsigned int *)(v78 + 8)) + 128);
                v80 = (_QWORD *)(v79 + 24);
                v81 = *(_DWORD *)(v79 + 32);
                if (v81 >= 0x41)
                {
                  if (v81 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)(v79 + 24)) > 0x40)
                  {
                    result = -1;
                    goto LABEL_117;
                  }
                  v80 = (_QWORD *)*v80;
                }
                result = *v80;
                goto LABEL_117;
              }
LABEL_116:
              result = 0;
              goto LABEL_117;
            }
            v70 = 0;
            v71 = 1;
            while (v69 != (llvm::Value *)-4096)
            {
              if (v70)
                v72 = 0;
              else
                v72 = v69 == (llvm::Value *)-8192;
              if (v72)
                v70 = v68;
              v73 = v67 + v71++;
              v67 = v73 & v66;
              v68 = (llvm::Value **)(v65 + 40 * v67);
              v69 = *v68;
              if (*v68 == (llvm::Value *)this)
                goto LABEL_89;
            }
            if (v70)
              v96 = v70;
            else
              v96 = v68;
          }
          else
          {
            v96 = 0;
          }
          v68 = (llvm::Value **)sub_1C541AB24(v63 + 2480, (uint64_t)&v98, (uint64_t *)&v98, v96);
          v97 = v98;
          v68[3] = 0;
          v68[4] = 0;
          *v68 = v97;
          v68[1] = (llvm::Value *)(v68 + 3);
          v68[2] = (llvm::Value *)0x100000000;
          goto LABEL_89;
        }
        v56 = 0;
        v57 = 1;
        while (v55 != (llvm::Value *)-4096)
        {
          if (v56)
            v58 = 0;
          else
            v58 = v55 == (llvm::Value *)-8192;
          if (v58)
            v56 = v54;
          v59 = v53 + v57++;
          v53 = v59 & v52;
          v54 = (llvm::Value **)(v51 + 40 * v53);
          v55 = *v54;
          if (*v54 == (llvm::Value *)this)
            goto LABEL_74;
        }
        if (v56)
          v94 = v56;
        else
          v94 = v54;
      }
      else
      {
        v94 = 0;
      }
      v54 = (llvm::Value **)sub_1C541AB24(v49 + 2480, (uint64_t)&v98, (uint64_t *)&v98, v94);
      v95 = v98;
      v54[3] = 0;
      v54[4] = 0;
      *v54 = v95;
      v54[1] = (llvm::Value *)(v54 + 3);
      v54[2] = (llvm::Value *)0x100000000;
      goto LABEL_74;
    }
    result = 0;
    if (!this || v9 != 59)
      return result;
    if ((llvm::AllocaInst::isArrayAllocation((llvm::AllocaInst *)this) & 1) == 0)
    {
      v47 = (uint64_t)this[8];
      goto LABEL_59;
    }
    return 0;
  }
  if ((*((_BYTE *)this + 23) & 0x20) == 0)
    goto LABEL_42;
  v19 = ***this;
  v98 = (llvm::Value *)this;
  v20 = *(_DWORD *)(v19 + 2496);
  if (!v20)
  {
    v90 = 0;
LABEL_132:
    v24 = (llvm::Value **)sub_1C541AB24(v19 + 2480, (uint64_t)&v98, (uint64_t *)&v98, v90);
    v91 = v98;
    v24[3] = 0;
    v24[4] = 0;
    *v24 = v91;
    v24[1] = (llvm::Value *)(v24 + 3);
    v24[2] = (llvm::Value *)0x100000000;
    goto LABEL_38;
  }
  v21 = *(_QWORD *)(v19 + 2480);
  v22 = v20 - 1;
  v23 = v22 & ((this >> 4) ^ (this >> 9));
  v24 = (llvm::Value **)(v21 + 40 * v23);
  v25 = *v24;
  if (*v24 != (llvm::Value *)this)
  {
    v26 = 0;
    v27 = 1;
    while (v25 != (llvm::Value *)-4096)
    {
      if (v26)
        v28 = 0;
      else
        v28 = v25 == (llvm::Value *)-8192;
      if (v28)
        v26 = v24;
      v29 = v23 + v27++;
      v23 = v29 & v22;
      v24 = (llvm::Value **)(v21 + 40 * v23);
      v25 = *v24;
      if (*v24 == (llvm::Value *)this)
        goto LABEL_38;
    }
    if (v26)
      v90 = v26;
    else
      v90 = v24;
    goto LABEL_132;
  }
LABEL_38:
  v30 = *((unsigned int *)v24 + 4);
  if (!(_DWORD)v30)
    goto LABEL_42;
  v31 = (_QWORD *)((char *)v24[1] + 8);
  v32 = 16 * v30;
  while (*((_DWORD *)v31 - 2) != 12)
  {
    v31 += 2;
    v32 -= 16;
    if (!v32)
      goto LABEL_42;
  }
  v82 = *v31;
  if (!v82)
  {
LABEL_42:
    if ((*((_BYTE *)this + 23) & 0x20) == 0)
      goto LABEL_116;
    v33 = ***this;
    v98 = (llvm::Value *)this;
    v34 = *(_DWORD *)(v33 + 2496);
    if (v34)
    {
      v35 = *(_QWORD *)(v33 + 2480);
      v36 = v34 - 1;
      v37 = v36 & ((this >> 4) ^ (this >> 9));
      v38 = (llvm::Value **)(v35 + 40 * v37);
      v39 = *v38;
      if (*v38 == (llvm::Value *)this)
      {
LABEL_53:
        v44 = *((unsigned int *)v38 + 4);
        if (!(_DWORD)v44)
          goto LABEL_116;
        v45 = (_QWORD *)((char *)v38[1] + 8);
        v46 = 16 * v44;
        while (*((_DWORD *)v45 - 2) != 13)
        {
          result = 0;
          v45 += 2;
          v46 -= 16;
          if (!v46)
            goto LABEL_117;
        }
        goto LABEL_112;
      }
      v40 = 0;
      v41 = 1;
      while (v39 != (llvm::Value *)-4096)
      {
        if (v40)
          v42 = 0;
        else
          v42 = v39 == (llvm::Value *)-8192;
        if (v42)
          v40 = v38;
        v43 = v37 + v41++;
        v37 = v43 & v36;
        v38 = (llvm::Value **)(v35 + 40 * v37);
        v39 = *v38;
        if (*v38 == (llvm::Value *)this)
          goto LABEL_53;
      }
      if (v40)
        v92 = v40;
      else
        v92 = v38;
    }
    else
    {
      v92 = 0;
    }
    v38 = (llvm::Value **)sub_1C541AB24(v33 + 2480, (uint64_t)&v98, (uint64_t *)&v98, v92);
    v93 = v98;
    v38[3] = 0;
    v38[4] = 0;
    *v38 = v93;
    v38[1] = (llvm::Value *)(v38 + 3);
    v38[2] = (llvm::Value *)0x100000000;
    goto LABEL_53;
  }
  v83 = *(_QWORD *)(*(_QWORD *)(v82 - 8 * *(unsigned int *)(v82 + 8)) + 128);
  v84 = (_QWORD *)(v83 + 24);
  v85 = *(_DWORD *)(v83 + 32);
  if (v85 < 0x41)
    goto LABEL_123;
  if (v85 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)(v83 + 24)) > 0x40)
    return -1;
  v84 = (_QWORD *)*v84;
LABEL_123:
  result = *v84;
  if (!*v84)
    goto LABEL_42;
  return result;
}

void llvm::Value::getPointerAlignment(llvm::Value *this, const llvm::DataLayout *a2)
{
  unsigned int v4;
  int v5;
  int v6;
  llvm::AttributeList *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t ParamStructRetType;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  llvm::Constant *v17;
  llvm::Type *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  int v24;
  unsigned int v25;
  llvm::Value **v26;
  llvm::Value *v27;
  llvm::Value **v28;
  int v29;
  BOOL v30;
  unsigned int v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v36;
  uint64_t v37;
  llvm::Value **v38;
  llvm::Value *v39;
  llvm::Value *v41;

  v4 = *((unsigned __int8 *)this + 16);
  if (v4 > 0x14)
  {
    if (v4 != 21)
    {
      if (v4 == 59)
        return;
      goto LABEL_19;
    }
    v6 = *((_DWORD *)this + 8);
    v7 = (llvm::AttributeList *)(*((_QWORD *)this + 3) + 112);
    if ((unsigned __int16)llvm::AttributeList::getParamAlignment(v7, v6) > 0xFFu)
      return;
    if (*(_BYTE *)(*(_QWORD *)this + 8) != 15)
      return;
    v8 = *(_QWORD *)v7;
    if (!*(_QWORD *)v7)
      return;
    if ((v6 + 2) >= *(_DWORD *)(v8 + 8))
      return;
    v9 = *(_QWORD *)(v8 + 8 * (v6 + 2) + 40);
    if (!v9 || (*(_BYTE *)(v9 + 21) & 2) == 0)
      return;
    ParamStructRetType = llvm::AttributeList::getParamStructRetType(v7, v6);
    v11 = ParamStructRetType;
    v12 = *(unsigned __int8 *)(ParamStructRetType + 8);
    if (v12 > 0x11)
      goto LABEL_84;
    if (((1 << v12) & 0xAC7F) != 0)
      goto LABEL_18;
    if (((1 << v12) & 0x30000) == 0)
    {
LABEL_84:
      if ((v12 & 0xFE) != 0x12 && v12 != 21)
        return;
    }
    if (!llvm::Type::isSizedDerivedType(ParamStructRetType, 0))
      return;
LABEL_18:
    llvm::DataLayout::getAlignment((uint64_t)a2, v11);
    return;
  }
  if (v4 - 2 >= 2)
  {
    if (!*((_BYTE *)this + 16))
      return;
LABEL_19:
    if (v4 < 0x1C)
    {
      if (v4 <= 0x14)
      {
        v16 = llvm::Value::stripPointerCasts(this);
        llvm::DataLayout::getIntPtrType(a2, *(llvm::Type **)this);
        v19 = llvm::ConstantFoldCastInstruction((llvm *)0x2F, v16, v17, v18);
        if (v19)
        {
          if (*(_BYTE *)(v19 + 16) == 16 && *(_DWORD *)(v19 + 32) > 0x40u)
            llvm::APInt::countTrailingZerosSlowCase((unint64_t **)(v19 + 24));
        }
      }
      return;
    }
    if (*((unsigned __int8 *)this + 16) <= 0x3Bu)
    {
      if (v4 != 33 && v4 != 39)
        return;
      goto LABEL_39;
    }
    if (v4 != 60)
    {
      if (v4 != 84)
        return;
LABEL_39:
      if ((unsigned __int16)sub_1C543FD8C((uint64_t)this) <= 0xFFu)
      {
        v20 = *((_QWORD *)this - 4);
        if (v20)
        {
          if (!*(_BYTE *)(v20 + 16) && *(_QWORD *)(v20 + 24) == *((_QWORD *)this + 9))
          {
            v41 = *(llvm::Value **)(v20 + 112);
            llvm::AttributeList::getRetAlignment((llvm::AttributeList *)&v41);
          }
        }
      }
      return;
    }
    if ((*((_BYTE *)this + 23) & 0x20) == 0)
      return;
    v21 = ***(_QWORD ***)this;
    v41 = this;
    v22 = *(_DWORD *)(v21 + 2496);
    if (v22)
    {
      v23 = *(_QWORD *)(v21 + 2480);
      v24 = v22 - 1;
      v25 = v24 & ((this >> 4) ^ (this >> 9));
      v26 = (llvm::Value **)(v23 + 40 * v25);
      v27 = *v26;
      if (*v26 == this)
        goto LABEL_55;
      v28 = 0;
      v29 = 1;
      while (v27 != (llvm::Value *)-4096)
      {
        if (v28)
          v30 = 0;
        else
          v30 = v27 == (llvm::Value *)-8192;
        if (v30)
          v28 = v26;
        v31 = v25 + v29++;
        v25 = v31 & v24;
        v26 = (llvm::Value **)(v23 + 40 * v25);
        v27 = *v26;
        if (*v26 == this)
          goto LABEL_55;
      }
      if (v28)
        v38 = v28;
      else
        v38 = v26;
    }
    else
    {
      v38 = 0;
    }
    v26 = (llvm::Value **)sub_1C541AB24(v21 + 2480, (uint64_t)&v41, (uint64_t *)&v41, v38);
    v39 = v41;
    v26[3] = 0;
    v26[4] = 0;
    *v26 = v39;
    v26[1] = (llvm::Value *)(v26 + 3);
    v26[2] = (llvm::Value *)0x100000000;
LABEL_55:
    v32 = *((unsigned int *)v26 + 4);
    if ((_DWORD)v32)
    {
      v33 = (_QWORD *)((char *)v26[1] + 8);
      v34 = 16 * v32;
      while (*((_DWORD *)v33 - 2) != 17)
      {
        v33 += 2;
        v34 -= 16;
        if (!v34)
          return;
      }
      v36 = *v33;
      if (v36)
      {
        v37 = *(_QWORD *)(*(_QWORD *)(v36 - 8 * *(unsigned int *)(v36 + 8)) + 128);
        if (*(_DWORD *)(v37 + 32) >= 0x41u)
          llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)(v37 + 24));
      }
    }
    return;
  }
  v5 = *((_DWORD *)this + 8);
  if ((v5 & 0x3F0000) != 0 || v4 != 3)
    return;
  v13 = *((_QWORD *)this + 3);
  v14 = *(unsigned __int8 *)(v13 + 8);
  if (v14 > 0x11)
    goto LABEL_69;
  if (((1 << v14) & 0xAC7F) == 0)
  {
    if (((1 << v14) & 0x30000) != 0)
    {
LABEL_61:
      if (!llvm::Type::isSizedDerivedType(*((_QWORD *)this + 3), 0))
        return;
      v5 = *((_DWORD *)this + 8);
      goto LABEL_27;
    }
LABEL_69:
    if ((v14 & 0xFE) != 0x12 && v14 != 21)
      return;
    goto LABEL_61;
  }
LABEL_27:
  v15 = v5 & 0xF;
  if (v15 == 1)
    goto LABEL_67;
  if (*((_BYTE *)this + 16))
  {
    if (*((_BYTE *)this + 16) == 3 && (*((_DWORD *)this + 5) & 0x7FFFFFF) == 0)
      goto LABEL_67;
  }
  else if (*((llvm::Value **)this + 9) == (llvm::Value *)((char *)this + 72) && (v5 & 0x800000) == 0)
  {
    goto LABEL_67;
  }
  if (v15 <= 0xA && ((1 << v15) & 0x63C) != 0)
  {
LABEL_67:
    llvm::DataLayout::getAlignment((uint64_t)a2, v13);
    return;
  }
  llvm::DataLayout::getPreferredAlign(a2, this);
}

uint64_t sub_1C543FD8C(uint64_t a1)
{
  __int16 RetAlignment;
  uint64_t v3;
  uint64_t v5;

  RetAlignment = llvm::AttributeList::getRetAlignment((llvm::AttributeList *)(a1 + 64));
  LODWORD(v3) = HIBYTE(RetAlignment);
  if (!HIBYTE(RetAlignment))
  {
    v3 = *(_QWORD *)(a1 - 32);
    if (v3)
    {
      if (!*(_BYTE *)(v3 + 16) && *(_QWORD *)(v3 + 24) == *(_QWORD *)(a1 + 72))
      {
        v5 = *(_QWORD *)(v3 + 112);
        RetAlignment = llvm::AttributeList::getRetAlignment((llvm::AttributeList *)&v5);
        LODWORD(v3) = HIBYTE(RetAlignment);
        return RetAlignment | ((_DWORD)v3 << 8);
      }
      LODWORD(v3) = 0;
    }
    LOBYTE(RetAlignment) = 0;
  }
  return RetAlignment | ((_DWORD)v3 << 8);
}

uint64_t llvm::Value::DoPHITranslation(uint64_t this, const llvm::BasicBlock *a2, const llvm::BasicBlock *a3)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (this && *(_BYTE *)(this + 16) == 83 && *(const llvm::BasicBlock **)(this + 40) == a2)
  {
    v3 = *(_DWORD *)(this + 20);
    v4 = v3 & 0x7FFFFFF;
    if ((v3 & 0x7FFFFFF) != 0)
    {
      v5 = 0;
      while (1)
      {
        v6 = this - 32 * v4;
        if ((v3 & 0x40000000) != 0)
          v6 = *(_QWORD *)(this - 8);
        if (*(const llvm::BasicBlock **)(v6 + 32 * *(unsigned int *)(this + 60) + 8 * v5) == a3)
          break;
        if (v4 == ++v5)
          goto LABEL_11;
      }
    }
    else
    {
LABEL_11:
      LODWORD(v5) = -1;
    }
    if ((v3 & 0x40000000) != 0)
      v7 = *(_QWORD *)(this - 8);
    else
      v7 = this - 32 * v4;
    return *(_QWORD *)(v7 + 32 * v5);
  }
  return this;
}

_QWORD *llvm::Value::reverseUseList(llvm::Value *this)
{
  _QWORD *result;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;

  v3 = *((_QWORD *)this + 1);
  result = (_QWORD *)((char *)this + 8);
  v2 = v3;
  if (v3)
  {
    v4 = *(_QWORD *)(v2 + 8);
    if (v4)
    {
      *(_QWORD *)(v2 + 8) = 0;
      do
      {
        v5 = v4;
        v6 = (_QWORD *)(v4 + 8);
        v4 = *(_QWORD *)(v4 + 8);
        *v6 = v2;
        *(_QWORD *)(v2 + 16) = v6;
        v2 = v5;
      }
      while (v4);
      *result = v5;
      *(_QWORD *)(v5 + 16) = result;
    }
  }
  return result;
}

BOOL llvm::Value::isSwiftError(llvm::Value *this)
{
  int v2;
  uint64_t v3;
  unsigned int v4;
  _BOOL8 result;
  uint64_t v6;

  v2 = *((unsigned __int8 *)this + 16);
  if (this && v2 == 21)
  {
    v3 = *(_QWORD *)(*((_QWORD *)this + 3) + 112);
    if (v3 && (v4 = *((_DWORD *)this + 8) + 2, v4 < *(_DWORD *)(v3 + 8)) && (v6 = *(_QWORD *)(v3 + 8 * v4 + 40)) != 0)
      return *(char *)(v6 + 19) < 0;
    else
      return 0;
  }
  else
  {
    result = 0;
    if (this && v2 == 59)
      return (*((unsigned __int16 *)this + 9) >> 7) & 1;
  }
  return result;
}

unint64_t *llvm::ValueHandleBase::AddToExistingUseList(unint64_t *result, unint64_t a2)
{
  unint64_t *v2;

  result[1] = *(_QWORD *)a2;
  *(_QWORD *)a2 = result;
  *result = *result & 7 | a2;
  v2 = (unint64_t *)result[1];
  if (v2)
    *v2 = *v2 & 7 | (unint64_t)(result + 1);
  return result;
}

unint64_t *llvm::ValueHandleBase::AddToExistingUseListAfter(unint64_t *result, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t *v4;

  v3 = *(_QWORD *)(a2 + 8);
  v2 = a2 + 8;
  result[1] = v3;
  *result = *result & 7 | v2;
  *(_QWORD *)v2 = result;
  v4 = (unint64_t *)result[1];
  if (v4)
    *v4 = *v4 & 7 | (unint64_t)(result + 1);
  return result;
}

uint64_t ****llvm::ValueHandleBase::AddToUseList(llvm::ValueHandleBase *this)
{
  uint64_t ***v2;
  uint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  int v6;
  int v7;
  unsigned int v8;
  uint64_t ****v9;
  uint64_t ***v10;
  uint64_t ****v11;
  int v12;
  BOOL v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  int v17;
  unsigned int v18;
  uint64_t ****v19;
  uint64_t ***v20;
  uint64_t ****v21;
  int v22;
  BOOL v23;
  unsigned int v24;
  uint64_t ****v25;
  uint64_t ****result;
  uint64_t ***v27;
  unint64_t *v28;
  _QWORD *v29;
  int v30;
  uint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  uint64_t ****v34;
  uint64_t ***v35;
  unint64_t *v36;
  uint64_t v37;
  _QWORD *v38;
  unint64_t v39;
  uint64_t *v40;
  _QWORD *v41;
  uint64_t ***v42;

  v2 = (uint64_t ***)*((_QWORD *)this + 2);
  v3 = ***v2;
  v4 = (_QWORD *)(v3 + 2424);
  if ((*((_BYTE *)v2 + 17) & 1) != 0)
  {
    v42 = (uint64_t ***)*((_QWORD *)this + 2);
    v15 = *(_DWORD *)(v3 + 2440);
    if (v15)
    {
      v16 = *(_QWORD *)(v3 + 2424);
      v17 = v15 - 1;
      v18 = v17 & ((v2 >> 4) ^ (v2 >> 9));
      v19 = (uint64_t ****)(v16 + 16 * v18);
      v20 = *v19;
      if (v2 == *v19)
        goto LABEL_39;
      v21 = 0;
      v22 = 1;
      while (v20 != (uint64_t ***)-4096)
      {
        if (v21)
          v23 = 0;
        else
          v23 = v20 == (uint64_t ***)-8192;
        if (v23)
          v21 = v19;
        v24 = v18 + v22++;
        v18 = v24 & v17;
        v19 = (uint64_t ****)(v16 + 16 * v18);
        v20 = *v19;
        if (v2 == *v19)
          goto LABEL_39;
      }
      if (v21)
        v34 = v21;
      else
        v34 = v19;
    }
    else
    {
      v34 = 0;
    }
    v19 = (uint64_t ****)sub_1C5440874(v3 + 2424, (uint64_t)&v42, (uint64_t *)&v42, v34);
    *v19 = v42;
    v19[1] = 0;
LABEL_39:
    v35 = v19[1];
    result = v19 + 1;
    *((_QWORD *)this + 1) = v35;
    *result = (uint64_t ***)this;
    *(_QWORD *)this = *(_QWORD *)this & 7 | (unint64_t)result;
    v36 = (unint64_t *)*((_QWORD *)this + 1);
    if (v36)
      *v36 = *v36 & 7 | ((unint64_t)this + 8);
    return result;
  }
  v5 = *(_QWORD *)(v3 + 2424);
  v42 = (uint64_t ***)*((_QWORD *)this + 2);
  v6 = *(_DWORD *)(v3 + 2440);
  if (v6)
  {
    v7 = v6 - 1;
    v8 = v7 & ((v2 >> 4) ^ (v2 >> 9));
    v9 = (uint64_t ****)(v5 + 16 * v8);
    v10 = *v9;
    if (v2 == *v9)
      goto LABEL_28;
    v11 = 0;
    v12 = 1;
    while (v10 != (uint64_t ***)-4096)
    {
      if (v11)
        v13 = 0;
      else
        v13 = v10 == (uint64_t ***)-8192;
      if (v13)
        v11 = v9;
      v14 = v8 + v12++;
      v8 = v14 & v7;
      v9 = (uint64_t ****)(v5 + 16 * v8);
      v10 = *v9;
      if (v2 == *v9)
        goto LABEL_28;
    }
    if (v11)
      v25 = v11;
    else
      v25 = v9;
  }
  else
  {
    v25 = 0;
  }
  v9 = (uint64_t ****)sub_1C5440874(v3 + 2424, (uint64_t)&v42, (uint64_t *)&v42, v25);
  *v9 = v42;
  v9[1] = 0;
LABEL_28:
  v27 = v9[1];
  result = v9 + 1;
  *((_QWORD *)this + 1) = v27;
  *result = (uint64_t ***)this;
  *(_QWORD *)this = *(_QWORD *)this & 7 | (unint64_t)result;
  v28 = (unint64_t *)*((_QWORD *)this + 1);
  if (v28)
    *v28 = *v28 & 7 | ((unint64_t)this + 8);
  *(_BYTE *)(*((_QWORD *)this + 2) + 17) |= 1u;
  v29 = (_QWORD *)*v4;
  if (*v4 > v5 || (unint64_t)&v29[2 * *(unsigned int *)(v3 + 2440)] <= v5)
  {
    v30 = *(_DWORD *)(v3 + 2432);
    if (v30 != 1)
    {
      if (v30)
      {
        v31 = *(unsigned int *)(v3 + 2440);
        v33 = &v29[2 * v31];
        if ((_DWORD)v31)
        {
          v37 = 16 * v31;
          v32 = (_QWORD *)*v4;
          while ((*v32 | 0x1000) == 0xFFFFFFFFFFFFF000)
          {
            v32 += 2;
            v37 -= 16;
            if (!v37)
            {
              v32 = &v29[2 * v31];
              break;
            }
          }
        }
        else
        {
          v32 = (_QWORD *)*v4;
        }
      }
      else
      {
        v31 = *(unsigned int *)(v3 + 2440);
        v32 = &v29[2 * v31];
        v33 = v32;
      }
      v38 = &v29[2 * v31];
LABEL_49:
      while (v32 != v38)
      {
        v40 = (uint64_t *)v32[1];
        v39 = (unint64_t)(v32 + 1);
        *v40 = *v40 & 7 | v39;
        v41 = (_QWORD *)(v39 + 8);
        v32 = v33;
        if (v41 != v33)
        {
          v32 = v41;
          while ((*v32 | 0x1000) == 0xFFFFFFFFFFFFF000)
          {
            v32 += 2;
            if (v32 == v33)
            {
              v32 = v33;
              goto LABEL_49;
            }
          }
        }
      }
    }
  }
  return result;
}

_QWORD *llvm::ValueHandleBase::RemoveFromUseList(_QWORD *this)
{
  unint64_t v1;
  unint64_t *v2;
  uint64_t v3;
  int32x2_t *v4;
  unint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;
  int v12;

  v1 = *this & 0xFFFFFFFFFFFFFFF8;
  *(_QWORD *)v1 = this[1];
  v2 = (unint64_t *)this[1];
  if (v2)
  {
    *v2 = *v2 & 7 | v1;
  }
  else
  {
    v3 = this[2];
    v4 = ***(int32x2_t ****)v3;
    v5 = (unint64_t)v4[303];
    if (v5 <= v1)
    {
      v6 = v4[305].u32[0];
      if (v5 + 16 * v6 > v1)
      {
        v7 = v6 - 1;
        LODWORD(v8) = v7 & ((v3 >> 4) ^ (v3 >> 9));
        v9 = (uint64_t *)(v5 + 16 * v8);
        v10 = *v9;
        if (v3 == *v9)
        {
LABEL_9:
          *v9 = -8192;
          v4[304] = vadd_s32(v4[304], (int32x2_t)0x1FFFFFFFFLL);
          v3 = this[2];
        }
        else
        {
          v11 = 1;
          while (v10 != -4096)
          {
            v12 = v8 + v11++;
            v8 = v12 & v7;
            v10 = *(_QWORD *)(v5 + 16 * v8);
            if (v3 == v10)
            {
              v9 = (uint64_t *)(v5 + 16 * v8);
              goto LABEL_9;
            }
          }
        }
        *(_BYTE *)(v3 + 17) &= ~1u;
      }
    }
  }
  return this;
}

_QWORD *sub_1C5440354(_QWORD *result)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t *v3;
  uint64_t v4;
  int32x2_t *v5;
  unint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  int v12;
  int v13;

  v1 = result[3];
  if (v1)
  {
    if ((v1 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v2 = result[1] & 0xFFFFFFFFFFFFFFF8;
      *(_QWORD *)v2 = result[2];
      v3 = (unint64_t *)result[2];
      if (v3)
      {
        *v3 = *v3 & 7 | v2;
      }
      else
      {
        v4 = result[3];
        v5 = ***(int32x2_t ****)v4;
        v6 = (unint64_t)v5[303];
        if (v6 <= v2)
        {
          v7 = v5[305].u32[0];
          if (v6 + 16 * v7 > v2)
          {
            v8 = v7 - 1;
            LODWORD(v9) = v8 & ((v4 >> 4) ^ (v4 >> 9));
            v10 = (uint64_t *)(v6 + 16 * v9);
            v11 = *v10;
            if (v4 == *v10)
            {
LABEL_13:
              *v10 = -8192;
              v5[304] = vadd_s32(v5[304], (int32x2_t)0x1FFFFFFFFLL);
              v4 = result[3];
            }
            else
            {
              v12 = 1;
              while (v11 != -4096)
              {
                v13 = v9 + v12++;
                v9 = v13 & v8;
                v11 = *(_QWORD *)(v6 + 16 * v9);
                if (v4 == v11)
                {
                  v10 = (uint64_t *)(v6 + 16 * v9);
                  goto LABEL_13;
                }
              }
            }
            *(_BYTE *)(v4 + 17) &= ~1u;
          }
        }
      }
    }
    result[3] = 0;
  }
  return result;
}

llvm::ValueHandleBase *sub_1C5440440(llvm::ValueHandleBase *this, llvm::Value *a2)
{
  int v3;
  int32x2_t *v5;
  int32x2_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  llvm::ValueHandleBase *v10;
  int v11;
  int v12;
  uint64_t v13;
  int32x2_t **v14;
  int32x2_t *v15;
  __int32 v16;
  int32x2_t v17;
  __int32 v18;
  unsigned int v19;
  uint64_t v20;
  llvm::ValueHandleBase *v21;
  int v22;
  unsigned int v23;
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  unsigned __int8 *v28;

  if (*((char *)this + 71) < 0)
    operator delete(*((void **)this + 6));
  if (*((char *)this + 47) < 0)
    operator delete(*((void **)this + 3));
  if ((*((_BYTE *)this + 17) & 1) != 0)
    llvm::ValueHandleBase::ValueIsDeleted(this, a2);
  v3 = *((_DWORD *)this + 5);
  if ((v3 & 0x8000000) != 0)
  {
    v5 = ***(int32x2_t ****)this;
    v6 = v5[49];
    v7 = v5[51].u32[0];
    if ((_DWORD)v7)
    {
      LODWORD(v8) = (v7 - 1) & ((this >> 4) ^ (this >> 9));
      v9 = *(_QWORD *)&v6 + 16 * v8;
      v10 = *(llvm::ValueHandleBase **)v9;
      if (*(llvm::ValueHandleBase **)v9 == this)
      {
LABEL_16:
        if (v9 != *(_QWORD *)&v6 + 16 * v7)
        {
          v13 = *(_QWORD *)(v9 + 8);
          *(_QWORD *)v9 = -8192;
          v5[50] = vadd_s32(v5[50], (int32x2_t)0x1FFFFFFFFLL);
          llvm::ReplaceableMetadataImpl::replaceAllUsesWith((llvm::ReplaceableMetadataImpl *)(v13 + 8), 0);
          if (v13)
          {
            if ((*(_BYTE *)(v13 + 24) & 1) == 0)
              MEMORY[0x1CAA32FB4](*(_QWORD *)(v13 + 32), 8);
            MEMORY[0x1CAA32FC0](v13, 0x1020C4072C728BCLL);
          }
        }
        v3 = *((_DWORD *)this + 5);
        if ((v3 & 0x20000000) == 0)
          goto LABEL_9;
        goto LABEL_22;
      }
      v11 = 1;
      while (v10 != (llvm::ValueHandleBase *)-4096)
      {
        v12 = v8 + v11++;
        v8 = v12 & (v7 - 1);
        v10 = *(llvm::ValueHandleBase **)(*(_QWORD *)&v6 + 16 * v8);
        if (v10 == this)
        {
          v9 = *(_QWORD *)&v6 + 16 * v8;
          goto LABEL_16;
        }
      }
    }
    v9 = *(_QWORD *)&v6 + 16 * v7;
    goto LABEL_16;
  }
  if ((v3 & 0x20000000) == 0)
    goto LABEL_9;
LABEL_22:
  v14 = **(int32x2_t ****)this;
  v15 = *v14;
  v16 = (*v14)[312].i32[0];
  if (v16)
  {
    v17 = v15[310];
    v18 = v16 - 1;
    v19 = v18 & ((this >> 4) ^ (this >> 9));
    v20 = *(_QWORD *)&v17 + 40 * v19;
    v21 = *(llvm::ValueHandleBase **)v20;
    if (*(llvm::ValueHandleBase **)v20 == this)
    {
LABEL_27:
      v24 = *(char **)(v20 + 8);
      v25 = *(unsigned int *)(v20 + 16);
      if ((_DWORD)v25)
      {
        v26 = v24 - 8;
        v27 = 16 * v25;
        do
        {
          v28 = *(unsigned __int8 **)&v26[v27];
          if (v28)
            llvm::MetadataTracking::untrack((uint64_t)&v26[v27], v28);
          v27 -= 16;
        }
        while (v27);
        v24 = *(char **)(v20 + 8);
      }
      if (v24 != (char *)(v20 + 24))
        free(v24);
      *(_QWORD *)v20 = -8192;
      v15[311] = vadd_s32(v15[311], (int32x2_t)0x1FFFFFFFFLL);
      v3 = *((_DWORD *)this + 5);
    }
    else
    {
      v22 = 1;
      while (v21 != (llvm::ValueHandleBase *)-4096)
      {
        v23 = v19 + v22++;
        v19 = v23 & v18;
        v20 = *(_QWORD *)&v17 + 40 * v19;
        v21 = *(llvm::ValueHandleBase **)v20;
        if (*(llvm::ValueHandleBase **)v20 == this)
          goto LABEL_27;
      }
    }
  }
  *((_DWORD *)this + 5) = v3 & 0xDFFFFFFF;
LABEL_9:
  llvm::Value::destroyValueName((uint64_t)this);
  return this;
}

unint64_t *sub_1C5440668(unint64_t *result, _QWORD *a2)
{
  unint64_t v2;
  unint64_t v4;
  unint64_t *v5;

  *result = 6;
  result[1] = 0;
  v2 = a2[2];
  result[2] = v2;
  if (v2 != -8192 && v2 != -4096 && v2 != 0)
  {
    v4 = *a2 & 0xFFFFFFFFFFFFFFF8;
    result[1] = *(_QWORD *)v4;
    *(_QWORD *)v4 = result;
    *result = v4 | 6;
    v5 = (unint64_t *)result[1];
    if (v5)
      *v5 = *v5 & 7 | (unint64_t)(result + 1);
  }
  return result;
}

_QWORD *sub_1C54406CC(uint64_t a1, uint64_t a2, uint64_t *a3, _QWORD *a4)
{
  int v6;
  unsigned int v7;
  uint64_t v8;
  int v10;
  unsigned int v11;
  uint64_t v12;
  _QWORD *v13;
  int v14;
  BOOL v15;
  unsigned int v16;
  int v17;
  unsigned int v18;
  uint64_t v19;
  int v20;
  BOOL v21;
  unsigned int v22;

  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    sub_1C47AD304(a1, 2 * v7);
    v8 = *a3;
    v10 = *(_DWORD *)(a1 + 16) - 1;
    v11 = ((*a3 >> 4) ^ (*a3 >> 9)) & v10;
    a4 = (_QWORD *)(*(_QWORD *)a1 + 16 * v11);
    v12 = *a4;
    if (*a3 != *a4)
    {
      v13 = 0;
      v14 = 1;
      while (v12 != -4096)
      {
        if (v13)
          v15 = 0;
        else
          v15 = v12 == -8192;
        if (v15)
          v13 = a4;
        v16 = v11 + v14++;
        v11 = v16 & v10;
        a4 = (_QWORD *)(*(_QWORD *)a1 + 16 * v11);
        v12 = *a4;
        if (v8 == *a4)
          goto LABEL_4;
      }
      goto LABEL_27;
    }
  }
  else
  {
    if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
    {
LABEL_3:
      v8 = *a4;
      goto LABEL_4;
    }
    sub_1C47AD304(a1, v7);
    v8 = *a3;
    v17 = *(_DWORD *)(a1 + 16) - 1;
    v18 = ((*a3 >> 4) ^ (*a3 >> 9)) & v17;
    a4 = (_QWORD *)(*(_QWORD *)a1 + 16 * v18);
    v19 = *a4;
    if (*a3 != *a4)
    {
      v13 = 0;
      v20 = 1;
      while (v19 != -4096)
      {
        if (v13)
          v21 = 0;
        else
          v21 = v19 == -8192;
        if (v21)
          v13 = a4;
        v22 = v18 + v20++;
        v18 = v22 & v17;
        a4 = (_QWORD *)(*(_QWORD *)a1 + 16 * v18);
        v19 = *a4;
        if (v8 == *a4)
          goto LABEL_4;
      }
LABEL_27:
      if (v13)
        a4 = v13;
      goto LABEL_3;
    }
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v8 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a4;
}

BOOL sub_1C5440844(_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  BOOL v3;

  v2 = *(_QWORD *)(a2 + 24);
  if (v2)
    v3 = *(unsigned __int8 *)(v2 + 16) >= 0x1Cu;
  else
    v3 = 0;
  return !v3 || *(_QWORD *)(v2 + 40) != *a1;
}

_QWORD *sub_1C5440874(uint64_t a1, uint64_t a2, uint64_t *a3, _QWORD *a4)
{
  int v6;
  unsigned int v7;
  uint64_t v8;
  int v10;
  unsigned int v11;
  uint64_t v12;
  _QWORD *v13;
  int v14;
  BOOL v15;
  unsigned int v16;
  int v17;
  unsigned int v18;
  uint64_t v19;
  int v20;
  BOOL v21;
  unsigned int v22;

  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    sub_1C4775244(a1, 2 * v7);
    v8 = *a3;
    v10 = *(_DWORD *)(a1 + 16) - 1;
    v11 = ((*a3 >> 4) ^ (*a3 >> 9)) & v10;
    a4 = (_QWORD *)(*(_QWORD *)a1 + 16 * v11);
    v12 = *a4;
    if (*a3 != *a4)
    {
      v13 = 0;
      v14 = 1;
      while (v12 != -4096)
      {
        if (v13)
          v15 = 0;
        else
          v15 = v12 == -8192;
        if (v15)
          v13 = a4;
        v16 = v11 + v14++;
        v11 = v16 & v10;
        a4 = (_QWORD *)(*(_QWORD *)a1 + 16 * v11);
        v12 = *a4;
        if (v8 == *a4)
          goto LABEL_4;
      }
      goto LABEL_27;
    }
  }
  else
  {
    if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
    {
LABEL_3:
      v8 = *a4;
      goto LABEL_4;
    }
    sub_1C4775244(a1, v7);
    v8 = *a3;
    v17 = *(_DWORD *)(a1 + 16) - 1;
    v18 = ((*a3 >> 4) ^ (*a3 >> 9)) & v17;
    a4 = (_QWORD *)(*(_QWORD *)a1 + 16 * v18);
    v19 = *a4;
    if (*a3 != *a4)
    {
      v13 = 0;
      v20 = 1;
      while (v19 != -4096)
      {
        if (v13)
          v21 = 0;
        else
          v21 = v19 == -8192;
        if (v21)
          v13 = a4;
        v22 = v18 + v20++;
        v18 = v22 & v17;
        a4 = (_QWORD *)(*(_QWORD *)a1 + 16 * v18);
        v19 = *a4;
        if (v8 == *a4)
          goto LABEL_4;
      }
LABEL_27:
      if (v13)
        a4 = v13;
      goto LABEL_3;
    }
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v8 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a4;
}

uint64_t sub_1C54409E8()
{
  __int128 v1;
  char v2;
  char *v3;
  int v4;

  v4 = 1;
  v2 = 0;
  v3 = &v2;
  *(_QWORD *)&v1 = "Deref attributes and metadata infer facts at definition only";
  *((_QWORD *)&v1 + 1) = 60;
  sub_1C624902C(&v4, (unsigned __int8 **)&v3, &v1);
  return __cxa_atexit((void (*)(void *))sub_1C4785FB8, &qword_1ED804C90, &dword_1C475E000);
}

void llvm::ValueSymbolTable::~ValueSymbolTable(llvm::ValueSymbolTable *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (*((_DWORD *)this + 3))
  {
    v2 = *((unsigned int *)this + 2);
    if ((_DWORD)v2)
    {
      v3 = 0;
      v4 = 8 * v2;
      do
      {
        v5 = *(_QWORD *)(*(_QWORD *)this + v3);
        if (v5 != -8 && v5 != 0)
          MEMORY[0x1CAA32FB4]();
        v3 += 8;
      }
      while (v4 != v3);
    }
  }
  free(*(void **)this);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (*((_DWORD *)this + 3))
  {
    v2 = *((unsigned int *)this + 2);
    if ((_DWORD)v2)
    {
      v3 = 0;
      v4 = 8 * v2;
      do
      {
        v5 = *(_QWORD *)(*(_QWORD *)this + v3);
        if (v5 != -8 && v5 != 0)
          MEMORY[0x1CAA32FB4]();
        v3 += 8;
      }
      while (v4 != v3);
    }
  }
  free(*(void **)this);
}

uint64_t llvm::ValueSymbolTable::makeUniqueName(llvm::StringMapImpl *a1, size_t a2, unsigned __int8 **a3)
{
  unsigned __int8 **v3;
  size_t v4;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  int v9;
  unint64_t v10;
  size_t v11;
  unsigned int v12;
  int v13;
  size_t v14;
  unsigned __int8 *v15;
  int v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  size_t *v28;
  char *v29;
  uint64_t *j;
  uint64_t v31;
  void *v34;
  unint64_t i;
  unsigned __int8 *__s1;
  uint64_t v39[4];
  __int16 v40;
  void *__p;
  char v42;
  int v43;
  _QWORD v44[2];
  uint64_t v45;
  _BYTE *v46;
  _BYTE *v47;
  int v48;

  v3 = a3;
  v4 = a2;
  v6 = (unint64_t)a3[1];
  v7 = v6;
  v34 = a3 + 3;
  for (i = v6; ; v7 = i)
  {
    if (v6 != v7)
    {
      if (v6 <= v7)
      {
        if ((unint64_t)v3[2] < v7)
        {
          llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)v3, v34, v7, 1);
          v6 = (unint64_t)v3[1];
        }
        if (v7 != v6)
          bzero(&(*v3)[v6], v7 - v6);
      }
      v3[1] = (unsigned __int8 *)v7;
    }
    sub_1C613932C((uint64_t)v44, (uint64_t)v3);
    if (v4 && *(unsigned __int8 *)(v4 + 16) <= 3u)
    {
      v8 = *(_QWORD *)(v4 + 40);
      if (!v8)
        goto LABEL_9;
      v40 = 260;
      v39[0] = v8 + 216;
      llvm::Triple::Triple((uint64_t)&__p, (llvm::Twine *)v39);
      v9 = v43;
      if (v42 < 0)
        operator delete(__p);
      if ((v9 & 0xFFFFFFFE) != 0x2C)
      {
LABEL_9:
        if (v46 == v47)
          llvm::raw_ostream::write((llvm::raw_ostream *)v44, ".", 1uLL);
        else
          *v47++ = 46;
      }
    }
    v10 = (*((_DWORD *)a1 + 9) + 1);
    *((_DWORD *)a1 + 9) = v10;
    sub_1C5E21910((llvm::raw_ostream *)v44, v10, 0, 0, 0);
    v11 = (size_t)v3[1];
    __s1 = *v3;
    v12 = *((_DWORD *)a1 + 2);
    if (!v12)
    {
      *((_DWORD *)a1 + 3) = 0;
      *((_DWORD *)a1 + 4) = 0;
      v26 = malloc_type_calloc(0x11uLL, 0xCuLL, 0x6D9A4F0CuLL);
      if (!v26)
        llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
      v26[16] = 2;
      *(_QWORD *)a1 = v26;
      v12 = 16;
      *((_DWORD *)a1 + 2) = 16;
    }
    v13 = 0;
    if (v11)
    {
      v14 = v11;
      v15 = __s1;
      do
      {
        v16 = *v15++;
        v13 = 33 * v13 + v16;
        --v14;
      }
      while (v14);
    }
    v17 = *(_QWORD *)a1;
    v18 = v12 - 1;
    v19 = *(_QWORD *)a1 + 8 * v12 + 8;
    v20 = -1;
    v21 = 1;
    v22 = v13;
    while (1)
    {
      v23 = v22 & v18;
      v24 = *(_QWORD **)(v17 + 8 * v23);
      if (!v24)
        break;
      if (v24 == (_QWORD *)-8)
      {
        if (v20 == -1)
          v20 = v22 & v18;
      }
      else if (*(_DWORD *)(v19 + 4 * v23) == v13
             && v11 == *v24
             && (!v11 || !memcmp(__s1, (char *)v24 + *((unsigned int *)a1 + 5), v11)))
      {
        goto LABEL_30;
      }
      v22 = v21 + v23;
      ++v21;
    }
    v25 = v20;
    if (v20 == -1)
    {
      v25 = v23;
      v23 = v23;
    }
    else
    {
      v23 = v20;
    }
    *(_DWORD *)(v19 + 4 * v25) = v13;
    v24 = *(_QWORD **)(v17 + 8 * v23);
LABEL_30:
    if (!v24)
      break;
    if (v24 == (_QWORD *)-8)
    {
      --*((_DWORD *)a1 + 4);
      break;
    }
    v44[0] = off_1E81A6E70;
    if (v48 == 1)
    {
      if (v45)
        MEMORY[0x1CAA32F9C](v45, 0x1000C8077774924);
    }
    v3 = a3;
    v4 = a2;
    v6 = (unint64_t)a3[1];
  }
  v27 = operator new(v11 + 17, (std::align_val_t)8uLL);
  v28 = v27;
  v29 = (char *)(v27 + 2);
  if (v11)
    memcpy(v27 + 2, __s1, v11);
  v29[v11] = 0;
  *v28 = v11;
  v28[1] = a2;
  *(_QWORD *)(v17 + 8 * v23) = v28;
  ++*((_DWORD *)a1 + 3);
  for (j = (uint64_t *)(*(_QWORD *)a1 + 8 * llvm::StringMapImpl::RehashTable(a1, v23)); ; ++j)
  {
    v31 = *j;
    if (*j && v31 != -8)
      break;
  }
  v44[0] = off_1E81A6E70;
  if (v48 == 1 && v45)
    MEMORY[0x1CAA32F9C](v45, 0x1000C8077774924);
  return v31;
}

void llvm::ValueSymbolTable::reinsertValue(llvm::ValueSymbolTable *this, llvm::Value *a2)
{
  llvm::ValueSymbolTable *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  llvm::Value *v9;
  int v10;
  int v11;
  size_t *v12;
  size_t v13;
  unsigned int v14;
  int v15;
  size_t v16;
  unsigned __int8 *v17;
  int v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  _QWORD *v26;
  llvm::ValueSymbolTable *v27;
  int v28;
  uint64_t v29;
  int32x2_t ****v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  llvm::Value **v35;
  llvm::Value *v36;
  int v37;
  int v38;
  llvm::StringMapImpl *v39;
  char *v40;
  uint64_t v41;
  llvm::Value **v42;
  llvm::Value *v43;
  int v44;
  int v45;
  llvm::Value *v46;
  uint64_t v47;
  char *v48;
  uint64_t v49;
  char *v50;
  BOOL v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  llvm::Value **v57;
  llvm::Value *v58;
  int v59;
  int v60;
  llvm::Value *v61;
  int32x2_t ***UniqueName;
  _QWORD *v64;
  uint64_t v65;
  uint64_t v66;
  llvm::Value *v67;
  int v68;
  int v69;
  llvm::Value *v70;
  size_t *v71;
  void *__s1;
  char *__s1a;
  void *__dst;
  __int128 v75;
  _QWORD v76[34];

  v3 = this;
  v76[32] = *MEMORY[0x1E0C80C00];
  if ((*((_BYTE *)a2 + 23) & 0x10) == 0)
  {
    v12 = 0;
    goto LABEL_9;
  }
  v4 = ***(_QWORD ***)a2;
  v5 = *(_QWORD *)(v4 + 152);
  v6 = *(unsigned int *)(v4 + 168);
  if (!(_DWORD)v6)
    goto LABEL_33;
  LODWORD(v7) = (v6 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  v8 = v5 + 16 * v7;
  v9 = *(llvm::Value **)v8;
  if (*(llvm::Value **)v8 != a2)
  {
    v10 = 1;
    while (v9 != (llvm::Value *)-4096)
    {
      v11 = v7 + v10++;
      v7 = v11 & (v6 - 1);
      v9 = *(llvm::Value **)(v5 + 16 * v7);
      if (v9 == a2)
      {
        v8 = v5 + 16 * v7;
        goto LABEL_8;
      }
    }
LABEL_33:
    v8 = v5 + 16 * v6;
  }
LABEL_8:
  v12 = *(size_t **)(v8 + 8);
LABEL_9:
  v13 = *v12;
  __s1 = v12 + 2;
  v14 = *((_DWORD *)this + 2);
  if (!v14)
  {
    *((_DWORD *)this + 3) = 0;
    *((_DWORD *)this + 4) = 0;
    v64 = malloc_type_calloc(0x11uLL, 0xCuLL, 0x6D9A4F0CuLL);
    if (!v64)
      llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    v64[16] = 2;
    *(_QWORD *)this = v64;
    v14 = 16;
    *((_DWORD *)this + 2) = 16;
    v3 = this;
  }
  v15 = 0;
  if (v13)
  {
    v16 = v13;
    v17 = (unsigned __int8 *)(v12 + 2);
    do
    {
      v18 = *v17++;
      v15 = 33 * v15 + v18;
      --v16;
    }
    while (v16);
  }
  v70 = a2;
  v71 = v12;
  v19 = *(_QWORD *)v3;
  v20 = v14 - 1;
  v21 = *(_QWORD *)v3 + 8 * v14 + 8;
  v22 = -1;
  v23 = 1;
  v24 = v15;
  while (1)
  {
    v25 = v24 & v20;
    v26 = *(_QWORD **)(v19 + 8 * v25);
    if (!v26)
      break;
    if (v26 == (_QWORD *)-8)
    {
      if (v22 == -1)
        v22 = v24 & v20;
    }
    else if (*(_DWORD *)(v21 + 4 * v25) == v15 && v13 == *v26)
    {
      if (!v13)
        goto LABEL_25;
      v27 = v3;
      v28 = memcmp(__s1, (char *)v26 + *((unsigned int *)v3 + 5), v13);
      v3 = v27;
      if (!v28)
        goto LABEL_25;
    }
    v24 = v23 + v25;
    ++v23;
  }
  v29 = v22;
  if (v22 == -1)
  {
    v29 = v25;
    v25 = v25;
  }
  else
  {
    v25 = v22;
  }
  *(_DWORD *)(v21 + 4 * v29) = v15;
  v26 = *(_QWORD **)(v19 + 8 * v25);
LABEL_25:
  if (!v26)
    goto LABEL_26;
  if (v26 == (_QWORD *)-8)
  {
    --*((_DWORD *)v3 + 4);
LABEL_26:
    *(_QWORD *)(v19 + 8 * v25) = v71;
    ++*((_DWORD *)v3 + 3);
    llvm::StringMapImpl::RehashTable(v3, 0);
    return;
  }
  v30 = (int32x2_t ****)v70;
  if ((*((_BYTE *)v70 + 23) & 0x10) == 0)
  {
    v39 = v3;
    v47 = 0;
    v40 = &byte_1C871356D;
    v48 = &byte_1C871356D;
    goto LABEL_48;
  }
  v31 = ***(_QWORD ***)v70;
  v32 = *(_QWORD *)(v31 + 152);
  v33 = *(unsigned int *)(v31 + 168);
  if ((_DWORD)v33)
  {
    LODWORD(v34) = (v33 - 1) & ((v70 >> 4) ^ (v70 >> 9));
    v35 = (llvm::Value **)(v32 + 16 * v34);
    v36 = *v35;
    if (*v35 == v70)
    {
      v39 = v3;
      v40 = (char *)v35[1] + 16;
      goto LABEL_42;
    }
    v37 = 1;
    while (v36 != (llvm::Value *)-4096)
    {
      v38 = v34 + v37++;
      v34 = v38 & (v33 - 1);
      v36 = *(llvm::Value **)(v32 + 16 * v34);
      if (v36 == v70)
      {
        v39 = v3;
        goto LABEL_41;
      }
    }
  }
  v39 = v3;
  v34 = v33;
LABEL_41:
  v40 = (char *)(*(_QWORD *)(v32 + 16 * v34 + 8) + 16);
  if (!(_DWORD)v33)
    goto LABEL_63;
LABEL_42:
  LODWORD(v41) = (v33 - 1) & ((v70 >> 4) ^ (v70 >> 9));
  v42 = (llvm::Value **)(v32 + 16 * v41);
  v43 = *v42;
  if (*v42 != v70)
  {
    v44 = 1;
    while (v43 != (llvm::Value *)-4096)
    {
      v45 = v41 + v44++;
      v41 = v45 & (v33 - 1);
      v43 = *(llvm::Value **)(v32 + 16 * v41);
      if (v43 == v70)
      {
        v42 = (llvm::Value **)(v32 + 16 * v41);
        goto LABEL_47;
      }
    }
LABEL_63:
    v42 = (llvm::Value **)(v32 + 16 * v33);
  }
LABEL_47:
  v46 = v42[1];
  v49 = *(_QWORD *)v46;
  v48 = (char *)v46 + 16;
  v47 = v49;
LABEL_48:
  v50 = &v48[v47];
  __dst = v76;
  v75 = xmmword_1C64638F0;
  v51 = v50 != v40;
  v52 = v50 - v40;
  if ((unint64_t)(v50 - v40) > 0x100 || v50 == v40)
  {
    __s1a = v40;
    if (v52 >= 0x101)
    {
      llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&__dst, v76, v52, 1);
      v65 = v75;
    }
    else
    {
      v65 = 0;
    }
    if (v51)
    {
      memcpy((char *)__dst + v65, __s1a, v52);
      v65 = v75;
    }
    *(_QWORD *)&v75 = v65 + v52;
    v30 = (int32x2_t ****)v70;
    if ((*((_BYTE *)v70 + 23) & 0x10) != 0)
    {
      v66 = ***(_QWORD ***)v70;
      v54 = *(_QWORD *)(v66 + 152);
      v55 = *(unsigned int *)(v66 + 168);
      if ((_DWORD)v55)
      {
        LODWORD(v56) = (v55 - 1) & ((v70 >> 4) ^ (v70 >> 9));
        v57 = (llvm::Value **)(v54 + 16 * v56);
        v67 = *v57;
        if (*v57 != v70)
        {
          v68 = 1;
          while (v67 != (llvm::Value *)-4096)
          {
            v69 = v56 + v68++;
            v56 = v69 & (v55 - 1);
            v67 = *(llvm::Value **)(v54 + 16 * v56);
            if (v67 == v70)
            {
LABEL_56:
              v57 = (llvm::Value **)(v54 + 16 * v56);
              goto LABEL_57;
            }
          }
          goto LABEL_79;
        }
        goto LABEL_57;
      }
LABEL_79:
      v57 = (llvm::Value **)(v54 + 16 * v55);
      goto LABEL_57;
    }
  }
  else
  {
    memcpy(__dst, v40, v50 - v40);
    *(_QWORD *)&v75 = v75 + v52;
    if ((*((_BYTE *)v70 + 23) & 0x10) != 0)
    {
      v53 = ***(_QWORD ***)v70;
      v54 = *(_QWORD *)(v53 + 152);
      v55 = *(unsigned int *)(v53 + 168);
      if ((_DWORD)v55)
      {
        LODWORD(v56) = (v55 - 1) & ((v70 >> 4) ^ (v70 >> 9));
        v57 = (llvm::Value **)(v54 + 16 * v56);
        v58 = *v57;
        if (*v57 != v70)
        {
          v59 = 1;
          while (v58 != (llvm::Value *)-4096)
          {
            v60 = v56 + v59++;
            v56 = v60 & (v55 - 1);
            v58 = *(llvm::Value **)(v54 + 16 * v56);
            if (v58 == v70)
              goto LABEL_56;
          }
          goto LABEL_79;
        }
LABEL_57:
        v61 = v57[1];
        goto LABEL_58;
      }
      goto LABEL_79;
    }
  }
  v61 = 0;
LABEL_58:
  MEMORY[0x1CAA32FB4](v61, 8);
  UniqueName = (int32x2_t ***)llvm::ValueSymbolTable::makeUniqueName(v39, (size_t)v30, (unsigned __int8 **)&__dst);
  llvm::Value::setValueName(v30, UniqueName);
  if (__dst != v76)
    free(__dst);
}

int32x2_t llvm::ValueSymbolTable::removeValueName(uint64_t *a1, size_t *a2)
{
  uint64_t v2;
  uint64_t v4;
  char *v5;
  size_t v6;
  int v7;
  size_t v8;
  unsigned __int8 *v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  _QWORD *v17;
  int32x2_t result;

  v2 = *((unsigned int *)a1 + 2);
  if ((_DWORD)v2)
  {
    v4 = *((unsigned int *)a1 + 5);
    v5 = (char *)a2 + v4;
    v6 = *a2;
    if (*a2)
    {
      v7 = 0;
      v8 = *a2;
      v9 = (unsigned __int8 *)a2 + v4;
      do
      {
        v10 = *v9++;
        v7 = 33 * v7 + v10;
        --v8;
      }
      while (v8);
    }
    else
    {
      v7 = 0;
    }
    v11 = v2 - 1;
    v12 = *a1;
    v13 = *a1 + 8 * v2 + 8;
    v14 = 1;
    v15 = v7;
    while (1)
    {
      v16 = v15 & v11;
      v17 = *(_QWORD **)(v12 + 8 * v16);
      if (v17 != (_QWORD *)-8)
      {
        if (!v17)
          return result;
        if (*(_DWORD *)(v13 + 4 * v16) == v7 && v6 == *v17 && (!v6 || !memcmp(v5, (char *)v17 + v4, v6)))
          break;
      }
      v15 = v14 + v16;
      ++v14;
    }
    *(_QWORD *)(v12 + 8 * (int)v16) = -8;
    result = vadd_s32(*(int32x2_t *)((char *)a1 + 12), (int32x2_t)0x1FFFFFFFFLL);
    *(uint64_t *)((char *)a1 + 12) = (uint64_t)result;
  }
  return result;
}

uint64_t llvm::ValueSymbolTable::createValueName(llvm::StringMapImpl *a1, unsigned __int8 *a2, size_t a3, size_t a4)
{
  size_t v5;
  size_t v8;
  unint64_t v9;
  unsigned int v10;
  int v11;
  size_t v12;
  unsigned __int8 *v13;
  int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  _QWORD *v24;
  size_t *v25;
  char *v26;
  uint64_t *i;
  size_t v28;
  uint64_t v29;
  uint64_t UniqueName;
  _QWORD *v31;
  unsigned __int8 *v34;
  size_t v35;
  void *__s1;
  void *v37;
  __int128 v38;
  _QWORD v39[34];

  v5 = a3;
  v39[32] = *MEMORY[0x1E0C80C00];
  v8 = *((unsigned int *)a1 + 8);
  if ((v8 & 0x80000000) == 0)
  {
    if (v8 <= 1)
      v9 = 1;
    else
      v9 = v8;
    if (a3 < v9)
      v9 = a3;
    if (a3 > v8)
      v5 = v9;
  }
  v10 = *((_DWORD *)a1 + 2);
  if (!v10)
  {
    *((_DWORD *)a1 + 3) = 0;
    *((_DWORD *)a1 + 4) = 0;
    v31 = malloc_type_calloc(0x11uLL, 0xCuLL, 0x6D9A4F0CuLL);
    if (!v31)
      llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    v31[16] = 2;
    *(_QWORD *)a1 = v31;
    v10 = 16;
    *((_DWORD *)a1 + 2) = 16;
  }
  v35 = a4;
  v11 = 0;
  if (v5)
  {
    v12 = v5;
    v13 = a2;
    do
    {
      v14 = *v13++;
      v11 = 33 * v11 + v14;
      --v12;
    }
    while (v12);
  }
  __s1 = a2;
  v34 = &a2[v5];
  v15 = v10 - 1;
  v16 = *(_QWORD *)a1;
  v17 = *(_QWORD *)a1 + 8 * v10 + 8;
  v18 = -1;
  v19 = 1;
  v20 = v11;
  while (1)
  {
    v21 = v20 & v15;
    v22 = *(_QWORD **)(v16 + 8 * v21);
    if (!v22)
      break;
    if (v22 == (_QWORD *)-8)
    {
      if (v18 == -1)
        v18 = v20 & v15;
    }
    else if (*(_DWORD *)(v17 + 4 * v21) == v11
           && v5 == *v22
           && (!v5 || !memcmp(__s1, (char *)v22 + *((unsigned int *)a1 + 5), v5)))
    {
      goto LABEL_28;
    }
    v20 = v19 + v21;
    ++v19;
  }
  v23 = v18;
  if (v18 == -1)
  {
    v23 = v21;
    v21 = v21;
  }
  else
  {
    v21 = v18;
  }
  *(_DWORD *)(v17 + 4 * v23) = v11;
  v22 = *(_QWORD **)(v16 + 8 * v21);
LABEL_28:
  if (!v22)
    goto LABEL_29;
  if (v22 == (_QWORD *)-8)
  {
    --*((_DWORD *)a1 + 4);
LABEL_29:
    v24 = operator new(v5 + 17, (std::align_val_t)8uLL);
    v25 = v24;
    v26 = (char *)(v24 + 2);
    if (v5)
      memcpy(v24 + 2, __s1, v5);
    v26[v5] = 0;
    *v25 = v5;
    v25[1] = v35;
    *(_QWORD *)(v16 + 8 * v21) = v25;
    ++*((_DWORD *)a1 + 3);
    for (i = (uint64_t *)(*(_QWORD *)a1 + 8 * llvm::StringMapImpl::RehashTable(a1, v21)); ; ++i)
    {
      UniqueName = *i;
      if (*i && UniqueName != -8)
        break;
    }
    return UniqueName;
  }
  v37 = v39;
  v38 = xmmword_1C64638F0;
  v28 = v34 - (_BYTE *)__s1;
  if ((unint64_t)(v34 - (_BYTE *)__s1) > 0x100)
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v37, v39, v34 - (_BYTE *)__s1, 1);
    v29 = v38;
  }
  else
  {
    v29 = 0;
  }
  if (v5)
  {
    memcpy((char *)v37 + v29, __s1, v28);
    v29 = v38;
  }
  *(_QWORD *)&v38 = v29 + v28;
  UniqueName = llvm::ValueSymbolTable::makeUniqueName(a1, v35, (unsigned __int8 **)&v37);
  if (v37 != v39)
    free(v37);
  return UniqueName;
}

uint64_t llvm::VectorBuilder::handleError(uint64_t this, llvm *a2)
{
  if (*(_DWORD *)(this + 8) != 1)
    llvm::report_fatal_error(a2, (const char *)1);
  return this;
}

uint64_t llvm::VectorBuilder::getModule(llvm::VectorBuilder *this)
{
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 48) + 56) + 40);
}

llvm::ValueHandleBase *llvm::VectorBuilder::getAllTrueMask(llvm::VectorBuilder *this)
{
  uint64_t **v2;
  llvm::Type *v3;
  llvm::Constant *v4;
  llvm::Type *v5;

  v2 = (uint64_t **)(**(_QWORD **)(*(_QWORD *)this + 64) + 1888);
  v3 = (llvm::Type *)*((_QWORD *)this + 4);
  if ((unint64_t)v3 >> 32 == 1)
    llvm::ScalableVectorType::get(v2, v3);
  else
    llvm::FixedVectorType::get((llvm::FixedVectorType *)v2, v3);
  return llvm::Constant::getAllOnesValue(v4, v5);
}

llvm::ValueHandleBase *llvm::VectorBuilder::requestMask(llvm::VectorBuilder *this)
{
  llvm::ValueHandleBase *result;
  uint64_t **v3;
  llvm::Type *v4;
  llvm::Constant *v5;
  llvm::Type *v6;

  result = (llvm::ValueHandleBase *)*((_QWORD *)this + 2);
  if (!result)
  {
    v3 = (uint64_t **)(**(_QWORD **)(*(_QWORD *)this + 64) + 1888);
    v4 = (llvm::Type *)*((_QWORD *)this + 4);
    if ((unint64_t)v4 >> 32 == 1)
      llvm::ScalableVectorType::get(v3, v4);
    else
      llvm::FixedVectorType::get((llvm::FixedVectorType *)v3, v4);
    return llvm::Constant::getAllOnesValue(v5, v6);
  }
  return result;
}

llvm::ValueHandleBase *llvm::VectorBuilder::requestEVL(llvm::VectorBuilder *this, uint64_t a2, const llvm::APInt *a3)
{
  llvm::ValueHandleBase *result;
  uint64_t v5;
  uint64_t v6;
  llvm::ConstantInt *v7;
  unsigned int v8;
  unint64_t v9;
  llvm::ConstantInt *v10;
  llvm::ValueHandleBase *v11;
  unint64_t v12;
  unsigned int v13;

  result = (llvm::ValueHandleBase *)*((_QWORD *)this + 3);
  if (!result)
  {
    v5 = **(_QWORD **)(*(_QWORD *)this + 64);
    v6 = *((unsigned int *)this + 8);
    v7 = *(llvm::ConstantInt **)(v5 + 1960);
    v8 = *(_DWORD *)(v5 + 1968);
    v13 = v8 >> 8;
    if (v8 >> 8 > 0x40)
    {
      v10 = v7;
      llvm::APInt::initSlowCase((llvm::APInt *)&v12, v6, 0);
      v7 = v10;
    }
    else
    {
      if (v8 <= 0xFF)
        v9 = 0;
      else
        v9 = 0xFFFFFFFFFFFFFFFFLL >> -BYTE1(v8);
      v12 = v9 & v6;
    }
    result = llvm::ConstantInt::get(v7, (llvm::LLVMContext *)&v12, a3);
    if (v13 >= 0x41)
    {
      if (v12)
      {
        v11 = result;
        MEMORY[0x1CAA32F9C](v12, 0x1000C8000313F17);
        return v11;
      }
    }
  }
  return result;
}

uint64_t llvm::VectorBuilder::createVectorInstruction(llvm::VectorBuilder *a1, llvm::VPIntrinsic *this, uint64_t a3, _BYTE *a4, unint64_t a5, uint64_t a6)
{
  llvm::VPIntrinsic *v11;
  uint64_t v12;
  llvm::VPIntrinsic *v14;
  uint64_t MaskParamPos;
  uint64_t VectorLengthParamPos;
  unint64_t v17;
  unsigned int v18;
  int v19;
  unint64_t v20;
  unint64_t v21;
  unsigned int v22;
  uint64_t v23;
  const llvm::APInt *v24;
  uint64_t v25;
  uint64_t v26;
  BOOL v27;
  char v28;
  BOOL v29;
  uint64_t *v30;
  llvm::ValueHandleBase *v31;
  llvm::ValueHandleBase *v32;
  uint64_t DeclarationForParams;
  uint64_t **v34;
  _BOOL8 v35;
  int v36;
  uint64_t **v37;
  uint64_t v38;
  _QWORD v39[7];

  v39[6] = *MEMORY[0x1E0C80C00];
  v11 = (llvm::VPIntrinsic *)llvm::VPIntrinsic::getForOpcode(this);
  if ((_DWORD)v11)
  {
    v14 = v11;
    MaskParamPos = llvm::VPIntrinsic::getMaskParamPos(v11);
    VectorLengthParamPos = llvm::VPIntrinsic::getVectorLengthParamPos(v14);
    if (BYTE4(MaskParamPos))
      v17 = a5 + 1;
    else
      v17 = a5;
    if (BYTE4(MaskParamPos))
      v18 = MaskParamPos;
    else
      v18 = a5;
    v19 = BYTE4(VectorLengthParamPos);
    if (BYTE4(VectorLengthParamPos))
      v20 = v17 + 1;
    else
      v20 = v17;
    v37 = (uint64_t **)v39;
    v38 = 0x600000000;
    v21 = v18;
    v36 = VectorLengthParamPos;
    if (BYTE4(VectorLengthParamPos))
      v22 = VectorLengthParamPos;
    else
      v22 = a5;
    if (v22 < (unint64_t)v18)
      v21 = v22;
    if (v21 >= a5)
    {
      sub_1C4FA6FB8((unsigned int *)&v37, a4, &a4[8 * a5]);
      sub_1C6154790((uint64_t)&v37, v20);
    }
    else
    {
      v35 = BYTE4(VectorLengthParamPos) != 0;
      sub_1C6154790((uint64_t)&v37, v20);
      if (v20)
      {
        v25 = 0;
        v26 = 0;
        do
        {
          if (v19)
            v27 = v36 == v26;
          else
            v27 = 0;
          v28 = v27;
          v29 = MaskParamPos != v26 || BYTE4(MaskParamPos) == 0;
          if (v29 && (v28 & 1) == 0)
          {
            v30 = *(uint64_t **)&a4[8 * v25++];
            v37[v26] = v30;
          }
          ++v26;
        }
        while (a5 + v35 + (BYTE4(MaskParamPos) != 0) != v26);
      }
    }
    if (BYTE4(MaskParamPos))
    {
      v31 = llvm::VectorBuilder::requestMask(a1);
      v37[MaskParamPos] = (uint64_t *)v31;
    }
    if (v19)
    {
      v32 = llvm::VectorBuilder::requestEVL(a1, v23, v24);
      v37[v36] = (uint64_t *)v32;
    }
    DeclarationForParams = llvm::VPIntrinsic::getDeclarationForParams(*(uint64_t **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 48) + 56) + 40), (int)v14, a3, v37);
    if (DeclarationForParams)
      v34 = *(uint64_t ***)(DeclarationForParams + 24);
    else
      v34 = 0;
    v12 = sub_1C4774778(*(uint64_t **)a1, v34, DeclarationForParams, (uint64_t *)v37, v38, a6, 0);
    if (v37 != v39)
      free(v37);
  }
  else
  {
    if (*((_DWORD *)a1 + 2) != 1)
      llvm::report_fatal_error((llvm *)"No VPIntrinsic for this opcode", (const char *)1);
    return 0;
  }
  return v12;
}

uint64_t sub_1C5441BDC(uint64_t a1, uint64_t a2, char a3, _QWORD *a4)
{
  _QWORD *v8;
  __int16 v9;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a4;
  *(_QWORD *)(a1 + 16) = &off_1E814DC18;
  *(_QWORD *)(a1 + 24) = 0;
  *(_WORD *)(a1 + 32) = 257;
  *(_QWORD *)(a1 + 40) = a4;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  *(_OWORD *)(a1 + 48) = 0u;
  v9 = 260;
  v8 = a4 + 27;
  llvm::Triple::Triple(a1 + 128, (llvm::Twine *)&v8);
  *(_QWORD *)(a1 + 176) = a4 + 34;
  *(_QWORD *)(a1 + 184) = *a4;
  *(_WORD *)(a1 + 192) = 0;
  *(_QWORD *)(a1 + 200) = a1 + 216;
  *(_QWORD *)(a1 + 208) = 0x100000000;
  *(_DWORD *)(a1 + 268) = 0;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_DWORD *)(a1 + 240) = 0;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_BYTE *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 272) = a1 + 304;
  *(_QWORD *)(a1 + 280) = a1 + 304;
  *(_QWORD *)(a1 + 288) = 16;
  *(_DWORD *)(a1 + 296) = 0;
  *(_QWORD *)(a1 + 432) = a1 + 464;
  *(_QWORD *)(a1 + 440) = a1 + 464;
  *(_QWORD *)(a1 + 448) = 32;
  *(_DWORD *)(a1 + 456) = 0;
  *(_DWORD *)(a1 + 736) = 0;
  *(_OWORD *)(a1 + 720) = 0u;
  *(_QWORD *)(a1 + 744) = a1 + 776;
  *(_QWORD *)(a1 + 752) = a1 + 776;
  *(_QWORD *)(a1 + 760) = 2;
  *(_DWORD *)(a1 + 768) = 0;
  *(_QWORD *)(a1 + 792) = 0;
  *(_WORD *)(a1 + 800) = 0;
  *(_DWORD *)(a1 + 804) = 0x8000;
  *(_DWORD *)(a1 + 824) = 0;
  *(_OWORD *)(a1 + 808) = 0u;
  *(_DWORD *)(a1 + 848) = 0;
  *(_OWORD *)(a1 + 832) = 0u;
  *(_DWORD *)(a1 + 872) = 0;
  *(_OWORD *)(a1 + 856) = 0u;
  *(_QWORD *)(a1 + 896) = 0;
  *(_QWORD *)(a1 + 880) = 0;
  *(_QWORD *)(a1 + 888) = 0;
  *(_QWORD *)(a1 + 904) = a1 + 936;
  *(_QWORD *)(a1 + 912) = a1 + 936;
  *(_QWORD *)(a1 + 920) = 32;
  *(_DWORD *)(a1 + 928) = 0;
  *(_QWORD *)(a1 + 1192) = a1 + 1208;
  *(_QWORD *)(a1 + 1200) = 0x400000000;
  *(_QWORD *)(a1 + 1240) = a1 + 1272;
  *(_QWORD *)(a1 + 1248) = a1 + 1272;
  *(_QWORD *)(a1 + 1256) = 32;
  *(_DWORD *)(a1 + 1264) = 0;
  *(_QWORD *)(a1 + 1528) = a1 + 1560;
  *(_QWORD *)(a1 + 1536) = a1 + 1560;
  *(_QWORD *)(a1 + 1544) = 32;
  *(_DWORD *)(a1 + 1552) = 0;
  *(_QWORD *)(a1 + 1816) = a1 + 1832;
  *(_QWORD *)(a1 + 1824) = 0x1000000000;
  *(_QWORD *)(a1 + 1960) = a1;
  *(_QWORD *)(a1 + 1976) = 0;
  *(_QWORD *)(a1 + 1968) = 0;
  *(_DWORD *)(a1 + 1984) = 0;
  *(_QWORD *)(a1 + 2000) = 0;
  *(_QWORD *)(a1 + 1992) = 0;
  *(_DWORD *)(a1 + 2008) = 0;
  *(_QWORD *)(a1 + 2016) = a1 + 2032;
  *(_QWORD *)(a1 + 2024) = 0x400000000;
  *(_BYTE *)(a1 + 194) = a3;
  return a1;
}

BOOL sub_1C5441DC4(uint64_t a1, uint64_t ***a2)
{
  uint64_t **v4;
  uint64_t **i;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t **v10;
  int v11;
  int v12;
  uint64_t **v13;
  unsigned int v14;
  int v15;
  char *v16;
  llvm::raw_ostream *v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t ****v23;
  uint64_t ***v24;
  int v25;
  int v26;
  unsigned int v27;
  int v28;
  uint64_t **v29;
  unsigned int v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD **v34;
  unsigned int v35;
  _QWORD *v36;
  _QWORD *v37;
  _QWORD *v38;
  _QWORD *v39;
  unsigned int v40;
  uint64_t v41;
  char *v42;
  char *v43;
  char *v44;
  unsigned int v45;
  uint64_t *v46;
  uint64_t v47;
  int v48;
  BOOL v49;
  uint64_t *v50;
  int v51;
  const llvm::BasicBlock *v52;
  uint64_t v53;
  char *v54;
  uint64_t **v55;
  uint64_t v56;
  uint64_t **v57;
  uint64_t *v58;
  _QWORD *v59;
  uint64_t v60;
  int v61;
  BOOL v62;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t *v70;
  int v71;
  llvm::Value **v72;
  llvm::Value *v73;
  llvm::User *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t **v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  unsigned int v81;
  BOOL v82;
  llvm::Constant *v84;
  int v85;
  int v86;
  char *v87;
  uint64_t ***v88;
  int v89;
  uint64_t ***v90;
  uint64_t **v91;
  char v92;
  _QWORD *v93;
  int v94;
  unsigned int v95;
  uint64_t **v96;
  uint64_t ***v97;
  int v98;
  uint64_t **v99;
  uint64_t *v100;
  char *v101;
  uint64_t **v102;
  uint64_t *v103;
  uint64_t v104;
  int v105;
  uint64_t v106;
  int v107;
  unsigned int v108;
  uint64_t ****v109;
  uint64_t ***v110;
  uint64_t ****v111;
  int v112;
  BOOL v113;
  unsigned int v114;
  uint64_t v115;
  _QWORD *v116;
  uint64_t v117;
  uint64_t v118;
  char *v119;
  int v120;
  uint64_t v121;
  llvm::raw_ostream **v122;
  llvm::User *v123;
  uint64_t ***v124;
  const char *v125;
  size_t v126;
  size_t v127;
  void *v128;
  llvm::raw_ostream *v129;
  _BYTE *v130;
  _BOOL8 result;
  uint64_t v132;
  uint64_t **v133;
  uint64_t **v134;
  uint64_t *v135;
  uint64_t *j;
  uint64_t v137;
  uint64_t v138;
  int v139;
  uint64_t v140;
  int v141;
  unsigned int v142;
  _QWORD *v143;
  uint64_t v144;
  _QWORD *v145;
  int v146;
  BOOL v147;
  unsigned int v148;
  uint64_t v149;
  _QWORD *v150;
  uint64_t v151;
  uint64_t v152;
  unint64_t v153;
  unint64_t k;
  _BYTE *v155;
  _QWORD *v156;
  uint64_t v157;
  char *v158;
  llvm::raw_ostream **v159;
  uint64_t v160;
  uint64_t *v161;
  uint64_t *v162;
  int v163;
  llvm::Type *v165;
  uint64_t ***v166;
  llvm::raw_ostream **v167;
  uint64_t ****v168;
  uint64_t ***v169;
  char *v170;
  uint64_t *v171;
  uint64_t *v172;
  char *v173;
  llvm::raw_ostream **v174;
  uint64_t v175;
  char *v176;
  uint64_t **v177;
  uint64_t **v178;
  uint64_t **v179;
  void *v180;
  uint64_t **v181;
  uint64_t *v182;
  uint64_t **v183;
  uint64_t *v184;
  uint64_t *v185;
  uint64_t m;
  uint64_t v187;
  unsigned int v188;
  BOOL v189;
  uint64_t *n;
  uint64_t v192;
  uint64_t *v193;
  int v194;
  int v195;
  unint64_t v196;
  unsigned int v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  int v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  _QWORD *v206;
  unsigned int v207;
  unint64_t v208;
  uint64_t v209;
  uint64_t v210;
  char *v211;
  uint64_t *v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t *v216;
  uint64_t *v217;
  uint64_t *v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  llvm::raw_ostream **v224;
  unsigned int v225;
  int v226;
  unsigned int v227;
  void *v228;
  uint64_t *v229;
  uint64_t *ii;
  _QWORD *v231;
  uint64_t *v232;
  uint64_t jj;
  uint64_t v234;
  _QWORD *v235;
  _BYTE *v236;
  char v237;
  uint64_t v238;
  uint64_t v239;
  unsigned int v241;
  int v242;
  unsigned int v243;
  void *v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t *v247;
  uint64_t v248;
  uint64_t v249;
  void *v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t *v253;
  uint64_t v254;
  uint64_t v255;
  BOOL v256;
  unsigned __int8 *v257;
  uint64_t **v258;
  uint64_t v259;
  unsigned __int8 *v260;
  uint64_t v261;
  unsigned __int8 **v262;
  char *v263;
  llvm::raw_ostream *v264;
  uint64_t **v265;
  uint64_t v266;
  unint64_t v267;
  unint64_t v268;
  uint64_t v269;
  uint64_t v270;
  const llvm::Value **v271;
  const llvm::Value **v272;
  const llvm::Value **v273;
  const llvm::Value **v274;
  const llvm::Value **v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  const llvm::Value **v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  const llvm::Value **v283;
  const llvm::Value **v284;
  const llvm::Value *v285;
  uint64_t v286;
  const llvm::Instruction **v287;
  llvm::raw_ostream **v288;
  uint64_t v289;
  unsigned int v290;
  int v291;
  unsigned int v292;
  void *v293;
  char *v294;
  char *v295;
  uint64_t *v296;
  uint64_t **v297;
  _QWORD *v298;
  uint64_t v299[2];
  uint64_t v300[4];
  __int16 v301;
  uint64_t v302;
  uint64_t v303;
  void *v304;
  void *v305;
  uint64_t v306;
  int v307;
  int v308[64];
  llvm::User *v309;
  uint64_t v310;
  _QWORD v311[2];
  uint64_t v312;
  char *v313;
  uint64_t v314;
  _BYTE v315[12];
  _QWORD v316[10];

  v316[8] = *MEMORY[0x1E0C80C00];
  v4 = (uint64_t **)(a2 + 9);
  if (a2[9] != (uint64_t **)(a2 + 9))
  {
    *(_QWORD *)(a1 + 256) = a2;
    sub_1C53BA620(a1 + 200, 0);
  }
  for (i = a2[10]; i != v4; i = (uint64_t **)i[1])
  {
    if (i)
      v6 = (uint64_t *)(i - 3);
    else
      v6 = 0;
    v7 = (uint64_t *)v6[5];
    if (v7 != v6 + 5)
    {
      v8 = v7 ? (uint64_t)(v7 - 3) : 0;
      if (*(unsigned __int8 *)(v8 + 16) - 29 < 0xB)
        continue;
    }
    v17 = *(llvm::raw_ostream **)a1;
    if (*(_QWORD *)a1)
    {
      v18 = (void *)*((_QWORD *)v17 + 4);
      if (*((_QWORD *)v17 + 3) - (_QWORD)v18 > 0x18uLL)
      {
        qmemcpy(v18, "Basic Block in function '", 25);
        *((_QWORD *)v17 + 4) += 25;
      }
      else
      {
        llvm::raw_ostream::write(*(llvm::raw_ostream **)a1, "Basic Block in function '", 0x19uLL);
      }
      if ((*((_BYTE *)a2 + 23) & 0x10) != 0)
      {
        v19 = ***a2;
        v20 = *(_QWORD *)(v19 + 152);
        v21 = *(unsigned int *)(v19 + 168);
        if (!(_DWORD)v21)
          goto LABEL_207;
        LODWORD(v22) = (v21 - 1) & ((a2 >> 4) ^ (a2 >> 9));
        v23 = (uint64_t ****)(v20 + 16 * v22);
        v24 = *v23;
        if (*v23 != a2)
        {
          v25 = 1;
          while (v24 != (uint64_t ***)-4096)
          {
            v26 = v22 + v25++;
            v22 = v26 & (v21 - 1);
            v24 = *(uint64_t ****)(v20 + 16 * v22);
            if (v24 == a2)
            {
              v23 = (uint64_t ****)(v20 + 16 * v22);
              goto LABEL_208;
            }
          }
LABEL_207:
          v23 = (uint64_t ****)(v20 + 16 * v21);
        }
LABEL_208:
        v124 = v23[1];
        v127 = (size_t)*v124;
        v125 = (const char *)(v124 + 2);
        v126 = v127;
        v128 = (void *)*((_QWORD *)v17 + 4);
        if (v127 > *((_QWORD *)v17 + 3) - (_QWORD)v128)
        {
          llvm::raw_ostream::write(v17, v125, v126);
          goto LABEL_210;
        }
        if (v126)
        {
          memcpy(v128, v125, v126);
          v128 = (void *)(*((_QWORD *)v17 + 4) + v126);
          *((_QWORD *)v17 + 4) = v128;
        }
      }
      else
      {
LABEL_210:
        v128 = (void *)*((_QWORD *)v17 + 4);
      }
      if (*((_QWORD *)v17 + 3) - (_QWORD)v128 > 0x1BuLL)
      {
        qmemcpy(v128, "' does not have terminator!\n", 28);
        *((_QWORD *)v17 + 4) += 28;
      }
      else
      {
        llvm::raw_ostream::write(v17, "' does not have terminator!\n", 0x1CuLL);
      }
      sub_1C5314910(v6, *(llvm::raw_ostream **)a1, 1, (llvm::ModuleSlotTracker *)(a1 + 16));
      v129 = *(llvm::raw_ostream **)a1;
      v130 = *(_BYTE **)(*(_QWORD *)a1 + 32);
      if (*(_BYTE **)(*(_QWORD *)a1 + 24) != v130)
      {
        result = 0;
        *v130 = 10;
        ++*((_QWORD *)v129 + 4);
        return result;
      }
      llvm::raw_ostream::write(*(llvm::raw_ostream **)a1, "\n", 1uLL);
    }
    return 0;
  }
  *(_BYTE *)(a1 + 192) = 0;
  sub_1C5447AD0(a1, (llvm::GlobalValue *)a2);
  v297 = v4;
  if (*(uint64_t **)(a1 + 184) != **a2)
  {
    v158 = "Function context does not match Module context!";
LABEL_288:
    v304 = v158;
    LOWORD(v308[0]) = 259;
    sub_1C6249A24(a1, (llvm::Twine *)&v304);
    if (!*(_QWORD *)a1)
      goto LABEL_338;
    v159 = (llvm::raw_ostream **)a1;
    v160 = (uint64_t)a2;
    goto LABEL_290;
  }
  v9 = *((_DWORD *)a2 + 8);
  if ((v9 & 0xF) == 0xA)
  {
    v158 = "Functions may not have common linkage";
    goto LABEL_288;
  }
  v10 = a2[3];
  v11 = *((_DWORD *)v10 + 3);
  if (v11 - 1 != *((_DWORD *)a2 + 24))
  {
    v304 = "# formal arguments must match # of arguments for function type!";
    LOWORD(v308[0]) = 259;
    sub_1C6249A24(a1, (llvm::Twine *)&v304);
    if (*(_QWORD *)a1)
    {
      sub_1C6249A88((llvm::raw_ostream **)a1, (uint64_t)a2);
      sub_1C6249BA8((llvm::raw_ostream **)a1, (llvm::Type *)v10);
    }
    goto LABEL_338;
  }
  v12 = *(unsigned __int8 *)(*v10[2] + 8);
  if (v12 == 14)
  {
    v158 = "Functions cannot return aggregate values!";
    goto LABEL_288;
  }
  v13 = a2[14];
  if (v13)
  {
    v14 = *((_DWORD *)v13 + 2);
    if (v14 < 3)
    {
LABEL_20:
      if (v14 > v11 + 1)
      {
        v16 = "Attribute after last parameter!";
        goto LABEL_335;
      }
      v15 = (v9 >> 13) & 1;
      sub_1C5447FA8((llvm::raw_ostream **)a1, (uint64_t)a2[3], (uint64_t)a2[14], (uint64_t)a2, ((_DWORD)a2[4] & 0x2000) != 0, 0);
      if ((*((_BYTE *)v13 + 12) & 0x10) != 0)
      {
        v16 = "Attribute 'builtin' can only be applied to a callsite.";
        goto LABEL_335;
      }
      if (((_BYTE)v13[4] & 0x40) != 0)
      {
        v16 = "Attribute 'elementtype' can only be applied to a callsite.";
        goto LABEL_335;
      }
      goto LABEL_35;
    }
    v161 = v13[7];
    if (v161 && (*((_BYTE *)v161 + 21) & 2) != 0)
    {
      if (v12 == 7)
        goto LABEL_20;
    }
    else
    {
      if (v14 < 4)
        goto LABEL_20;
      v162 = v13[8];
      if (!v162)
        goto LABEL_20;
      v163 = *((_BYTE *)v162 + 21) & 2;
      if (v12 == 7 || v163 == 0)
        goto LABEL_20;
    }
    v16 = "Invalid struct return type!";
    goto LABEL_335;
  }
  v15 = (v9 >> 13) & 1;
  sub_1C5447FA8((llvm::raw_ostream **)a1, (uint64_t)a2[3], 0, (uint64_t)a2, ((_DWORD)a2[4] & 0x2000) != 0, 0);
LABEL_35:
  v27 = *((unsigned __int16 *)a2 + 9);
  v28 = (v27 >> 4) & 0x3FF;
  switch(v28)
  {
    case 'G':
    case 'H':
    case 'M':
      goto LABEL_60;
    case 'I':
    case 'J':
    case 'K':
    case 'N':
    case 'O':
    case 'P':
    case 'Q':
    case 'R':
    case 'T':
    case 'U':
    case 'V':
    case '\\':
      goto LABEL_61;
    case 'L':
    case '[':
      if (*(_BYTE *)(*a2[3][2] + 8) == 7)
        goto LABEL_37;
      v16 = "Calling convention requires void return type";
      goto LABEL_335;
    case 'S':
      if (!a2[12])
        goto LABEL_61;
      if (v13)
      {
        if (*((_DWORD *)v13 + 2) >= 3u)
        {
          v296 = v13[7];
          if (v296)
          {
            if ((*((_BYTE *)v296 + 20) & 0x20) != 0)
              goto LABEL_61;
          }
        }
      }
      v16 = "Calling convention parameter requires byval";
      goto LABEL_335;
    case 'W':
    case 'X':
    case 'Y':
    case 'Z':
    case ']':
LABEL_37:
      v29 = a2[14];
      if (v29)
      {
        v30 = *((_DWORD *)v29 + 2);
        if (v30 >= 3
          && ((v171 = v29[7]) != 0 && (*((_BYTE *)v171 + 21) & 2) != 0
           || v30 >= 4 && (v172 = v29[8]) != 0 && (*((_BYTE *)v172 + 21) & 2) != 0))
        {
          v16 = "Calling convention does not allow sret";
          goto LABEL_335;
        }
      }
      if ((v27 & 0x3FF0) == 0x4C0)
        goto LABEL_60;
      v31 = *(_DWORD *)(*(_QWORD *)(a1 + 176) + 4);
      v32 = sub_1C485F330((uint64_t)a2);
      if (v32 == v33)
        goto LABEL_60;
      v34 = v13 + 5;
      v35 = 2;
      break;
    default:
      if ((v28 - 8) < 2 || v28 == 255)
        goto LABEL_60;
      goto LABEL_61;
  }
  do
  {
    if (v13 && v35 < *((_DWORD *)v13 + 2))
    {
      v36 = v34[v35];
      if (v36 && (*((_BYTE *)v36 + 20) & 0x20) != 0)
      {
        v16 = "Calling convention disallows byval";
        goto LABEL_335;
      }
      v37 = v34[v35];
      if (v37 && (*((_BYTE *)v37 + 21) & 1) != 0)
      {
        v16 = "Calling convention disallows preallocated";
        goto LABEL_335;
      }
      v38 = v34[v35];
      if (v38 && *((char *)v38 + 20) < 0)
      {
        v16 = "Calling convention disallows inalloca";
LABEL_335:
        v304 = v16;
        LOWORD(v308[0]) = 259;
        sub_1C6249A24(a1, (llvm::Twine *)&v304);
        if (*(_QWORD *)a1)
          sub_1C6249A88((llvm::raw_ostream **)a1, (uint64_t)a2);
        goto LABEL_337;
      }
      v39 = v34[v35];
      if (v39 && (*((_BYTE *)v39 + 20) & 0x10) != 0)
      {
        v40 = *(_DWORD *)(*(_QWORD *)v32 + 8);
        if ((v40 & 0xFE) == 0x12)
          v40 = *(_DWORD *)(**(_QWORD **)(*(_QWORD *)v32 + 16) + 8);
        if (v31 == v40 >> 8)
        {
          v16 = "Calling convention disallows stack byref";
          goto LABEL_335;
        }
      }
    }
    v32 += 40;
    ++v35;
  }
  while (v32 != v33);
LABEL_60:
  if (*((_DWORD *)a2[3] + 2) >= 0x100u)
  {
    v16 = "Calling convention does not support varargs or perfect forwarding!";
    goto LABEL_335;
  }
LABEL_61:
  v41 = sub_1C485F330((uint64_t)a2);
  if ((char *)v41 != v42)
  {
    v43 = (char *)v41;
    v44 = v42;
    v45 = 2;
    do
    {
      v46 = v10[2];
      v47 = v45 - 1;
      if (*(_QWORD *)v43 != v46[v47])
      {
        v304 = "Argument value does not match function argument type!";
        LOWORD(v308[0]) = 259;
        v165 = (llvm::Type *)v46[v47];
        sub_1C6249A24(a1, (llvm::Twine *)&v304);
        if (*(_QWORD *)a1)
        {
          sub_1C6249A88((llvm::raw_ostream **)a1, (uint64_t)v43);
          sub_1C6249BA8((llvm::raw_ostream **)a1, v165);
        }
        goto LABEL_337;
      }
      v48 = *(_DWORD *)(*(_QWORD *)v43 + 8);
      v49 = v48 == 14 || v48 == 7;
      if (v49)
      {
        v304 = "Function arguments must have first-class types!";
        LOWORD(v308[0]) = 259;
        sub_1C6249A24(a1, (llvm::Twine *)&v304);
        v4 = v297;
        if (!*(_QWORD *)a1)
          goto LABEL_338;
        v159 = (llvm::raw_ostream **)a1;
        v160 = (uint64_t)v43;
LABEL_290:
        sub_1C6249A88(v159, v160);
        goto LABEL_338;
      }
      if ((v15 & 1) == 0)
      {
        switch(v48)
        {
          case 0xCu:
            v173 = "Function takes token but isn't an intrinsic";
            goto LABEL_309;
          case 0xBu:
            v173 = "Function takes x86_amx but isn't an intrinsic";
LABEL_309:
            v304 = v173;
            LOWORD(v308[0]) = 259;
            v313 = v43;
            v309 = (llvm::User *)a2;
            sub_1C6249880((llvm::raw_ostream **)a1, (llvm::Twine *)&v304, (uint64_t *)&v313, (uint64_t *)&v309);
LABEL_337:
            v4 = v297;
            goto LABEL_338;
          case 9u:
            v173 = "Function takes metadata but isn't an intrinsic";
            goto LABEL_309;
        }
      }
      if (v13)
      {
        if (v45 < *((_DWORD *)v13 + 2))
        {
          v50 = v13[v45 + 5];
          if (v50)
          {
            if (*((char *)v50 + 19) < 0)
              sub_1C5448CA4((llvm::raw_ostream **)a1, (uint64_t)v43);
          }
        }
      }
      v43 += 40;
      ++v45;
    }
    while (v43 != v44);
  }
  v4 = v297;
  if ((v15 & 1) == 0)
  {
    v51 = *(unsigned __int8 *)(*a2[3][2] + 8);
    if (v51 == 11)
    {
      v158 = "Function returns a x86_amx but isn't an intrinsic";
      goto LABEL_288;
    }
    if (v51 == 12)
    {
      v158 = "Function returns a token but isn't an intrinsic";
      goto LABEL_288;
    }
  }
  v313 = v315;
  v314 = 0x400000000;
  llvm::Value::getAllMetadata(a2, (uint64_t)&v313);
  if ((_DWORD)v314)
  {
    v53 = 16 * v314;
    v54 = v313 + 8;
    while (1)
    {
      if (*((_DWORD *)v54 - 2) == 2)
      {
        v55 = *(uint64_t ***)v54;
        v56 = *(unsigned int *)(*(_QWORD *)v54 + 8);
        if (v56 <= 1)
        {
          v170 = "!prof annotations should have no less than 2 operands";
          goto LABEL_321;
        }
        v57 = &v55[-v56];
        v58 = *v57;
        if (!*v57)
        {
          v170 = "first operand should not be null";
          goto LABEL_321;
        }
        if (*(_BYTE *)v58)
        {
          v170 = "expected string with name of the !prof annotation";
          goto LABEL_321;
        }
        v59 = (_QWORD *)v58[1];
        if (*v59 == 30)
        {
          v52 = (const llvm::BasicBlock *)v59[3];
          v64 = v59[4];
          v65 = v59[5];
          v66 = *(_QWORD *)((char *)v59 + 46);
          if (v52 != (const llvm::BasicBlock *)0x69746568746E7973
            || v64 != 0x6974636E75665F63
            || v65 != 0x7972746E655F6E6FLL
            || v66 != 0x746E756F635F7972)
          {
LABEL_298:
            v170 = "first operand should be 'function_entry_count' or 'synthetic_function_entry_count'";
            goto LABEL_321;
          }
        }
        else
        {
          if (*v59 != 20)
            goto LABEL_298;
          v52 = (const llvm::BasicBlock *)v59[3];
          v60 = v59[4];
          v61 = *((_DWORD *)v59 + 10);
          v62 = v52 == (const llvm::BasicBlock *)0x6E6F6974636E7566 && v60 == 0x635F7972746E655FLL;
          if (!v62 || v61 != 1953396079)
            goto LABEL_298;
        }
        v70 = v57[1];
        if (!v70)
        {
          v170 = "second operand should not be null";
          goto LABEL_321;
        }
        if (*(_BYTE *)v70 != 1)
          break;
      }
      v54 += 16;
      v53 -= 16;
      if (!v53)
        goto LABEL_112;
    }
    v170 = "expected integer argument to function_entry_count";
LABEL_321:
    v304 = v170;
    LOWORD(v308[0]) = 259;
    sub_1C6249A24(a1, (llvm::Twine *)&v304);
    if (*(_QWORD *)a1)
      sub_1C6249C6C((llvm::raw_ostream *)a1, v55);
  }
LABEL_112:
  if ((*((_WORD *)a2 + 9) & 8) != 0)
  {
    v71 = *((_DWORD *)a2 + 5);
    v72 = (v71 & 0x40000000) != 0 ? (llvm::Value **)*(a2 - 1) : (llvm::Value **)&a2[-4 * (v71 & 0x7FFFFFF)];
    v73 = llvm::Value::stripPointerCasts(*v72);
    v74 = *((_BYTE *)v73 + 16) ? 0 : v73;
    v309 = v74;
    if (v74)
    {
      v75 = *((_QWORD *)v74 + 5);
      v76 = (uint64_t)a2[5];
      if (v75 != v76)
      {
        v303 = v75;
        v304 = "Referencing personality function in another module!";
        LOWORD(v308[0]) = 259;
        v300[0] = (uint64_t)a2;
        v299[0] = v76;
        sub_1C62498E8((llvm::raw_ostream **)a1, (llvm::Twine *)&v304, v300, v299, (uint64_t *)&v309, &v303);
        goto LABEL_194;
      }
    }
  }
  if ((*((_BYTE *)a2 + 34) & 0x80) != 0)
  {
    if ((_DWORD)v314)
    {
      v304 = "unmaterialized function cannot have metadata";
      LOWORD(v308[0]) = 259;
      v309 = (llvm::User *)a2;
      v300[0] = *((_QWORD *)v313 + 1);
      v166 = (uint64_t ***)v300;
      v167 = (llvm::raw_ostream **)a1;
LABEL_292:
      sub_1C6249964(v167, (llvm::Twine *)&v304, (uint64_t *)&v309, v166);
      goto LABEL_293;
    }
    goto LABEL_166;
  }
  if (*((_BYTE *)a2 + 16) == 3)
  {
    if ((*((_DWORD *)a2 + 5) & 0x7FFFFFF) != 0)
      goto LABEL_125;
LABEL_197:
    if ((_DWORD)v314)
    {
      v118 = 16 * v314;
      v119 = v313 + 8;
      do
      {
        v120 = *((_DWORD *)v119 - 2);
        if (v120)
        {
          if (v120 == 2)
          {
            v101 = "function declaration may not have a !prof attachment";
            goto LABEL_326;
          }
          v121 = *(_QWORD *)v119;
        }
        else
        {
          v121 = *(_QWORD *)v119;
          if ((*(_BYTE *)(*(_QWORD *)v119 + 1) & 0x7F) == 1)
          {
            v304 = "function declaration may only have a unique !dbg attachment";
            LOWORD(v308[0]) = 259;
            sub_1C6249CD4(a1, (llvm::Twine *)&v304);
LABEL_327:
            if (*(_QWORD *)a1)
              goto LABEL_328;
            goto LABEL_194;
          }
        }
        sub_1C5448E64((_QWORD *)a1, v121);
        v119 += 16;
        v118 -= 16;
      }
      while (v118);
    }
    if ((*((_WORD *)a2 + 9) & 8) != 0)
    {
      v304 = "Function declaration shouldn't have a personality routine";
      LOWORD(v308[0]) = 259;
      sub_1C6249A24(a1, (llvm::Twine *)&v304);
      if (*(_QWORD *)a1)
        goto LABEL_206;
      goto LABEL_293;
    }
    goto LABEL_166;
  }
  if (!*((_BYTE *)a2 + 16) && *v297 == (uint64_t *)v297)
    goto LABEL_197;
LABEL_125:
  if (v15)
  {
    v101 = "llvm intrinsics cannot be defined!";
    goto LABEL_326;
  }
  v77 = a2[10];
  if (v77)
    v78 = (uint64_t)(v77 - 3);
  else
    v78 = 0;
  v79 = *(_QWORD *)(v78 + 8);
  if (v79)
  {
    while (1)
    {
      v80 = *(_QWORD *)(v79 + 24);
      v81 = *(unsigned __int8 *)(v80 + 16);
      v82 = v80 && v81 >= 0x1C;
      if (v82 && v81 - 29 <= 0xA)
        break;
      v79 = *(_QWORD *)(v79 + 8);
      if (!v79)
        goto LABEL_139;
    }
    v176 = "Entry block to function must not have predecessors!";
LABEL_331:
    v304 = v176;
    LOWORD(v308[0]) = 259;
    sub_1C6249A24(a1, (llvm::Twine *)&v304);
    if (v77 && *(_QWORD *)a1)
    {
      v174 = (llvm::raw_ostream **)a1;
      v175 = v78;
LABEL_329:
      sub_1C6249A88(v174, v175);
    }
    goto LABEL_194;
  }
LABEL_139:
  if ((*(_WORD *)(v78 + 18) & 0x7FFF) != 0)
  {
    v84 = (llvm::Constant *)llvm::BlockAddress::lookup((llvm::BlockAddress *)v78, v52);
    if (llvm::Constant::isConstantUsed(v84))
    {
      v176 = "blockaddress may not be used with the entry block!";
      goto LABEL_331;
    }
  }
  if (!(_DWORD)v314)
  {
LABEL_166:
    if ((*((_BYTE *)a2 + 33) & 0x20) != 0 && !a2[5][20])
    {
      v309 = 0;
      if (llvm::Function::hasAddressTaken((llvm::Function *)a2, &v309, 0, 1, 0, 1))
      {
        v304 = "Invalid user of intrinsic instruction!";
        LOWORD(v308[0]) = 259;
        sub_1C6249A24(a1, (llvm::Twine *)&v304);
        if (*(_QWORD *)a1)
        {
          v123 = v309;
          if (v309)
          {
            v122 = (llvm::raw_ostream **)a1;
            goto LABEL_570;
          }
        }
LABEL_293:
        v4 = v297;
        goto LABEL_194;
      }
    }
    v98 = *((_DWORD *)a2 + 9);
    if (v98 == 121)
    {
      v102 = a2[3];
      v4 = v297;
      if (*((_DWORD *)v102 + 3) == 2)
      {
        v103 = v102[2];
        if (*(_BYTE *)(v103[1] + 8) != 15)
        {
          v101 = "gc.get.pointer.offset operand must be a pointer";
          goto LABEL_326;
        }
        if (*(_BYTE *)(*v103 + 8) != 13)
        {
          v101 = "gc.get.pointer.offset must return integer";
          goto LABEL_326;
        }
        goto LABEL_178;
      }
    }
    else
    {
      v4 = v297;
      if (v98 != 120)
        goto LABEL_178;
      v99 = a2[3];
      if (*((_DWORD *)v99 + 3) == 2)
      {
        v100 = v99[2];
        if (*(_BYTE *)(*v100 + 8) != 15)
        {
          v101 = "gc.get.pointer.base must return a pointer";
          goto LABEL_326;
        }
        if (v100[1] != *v100)
        {
          v101 = "gc.get.pointer.base operand and result must be of the same type";
LABEL_326:
          v304 = v101;
          LOWORD(v308[0]) = 259;
          sub_1C6249A24(a1, (llvm::Twine *)&v304);
          goto LABEL_327;
        }
LABEL_178:
        v299[0] = 0;
        if ((*((_BYTE *)a2 + 23) & 0x20) == 0)
          goto LABEL_193;
        v104 = ***a2;
        v304 = a2;
        v105 = *(_DWORD *)(v104 + 2496);
        if (v105)
        {
          v106 = *(_QWORD *)(v104 + 2480);
          v107 = v105 - 1;
          v108 = v107 & ((a2 >> 4) ^ (a2 >> 9));
          v109 = (uint64_t ****)(v106 + 40 * v108);
          v110 = *v109;
          if (*v109 == a2)
            goto LABEL_189;
          v111 = 0;
          v112 = 1;
          while (v110 != (uint64_t ***)-4096)
          {
            if (v111)
              v113 = 0;
            else
              v113 = v110 == (uint64_t ***)-8192;
            if (v113)
              v111 = v109;
            v114 = v108 + v112++;
            v108 = v114 & v107;
            v109 = (uint64_t ****)(v106 + 40 * v108);
            v110 = *v109;
            if (*v109 == a2)
              goto LABEL_189;
          }
          if (v111)
            v168 = v111;
          else
            v168 = v109;
        }
        else
        {
          v168 = 0;
        }
        v109 = (uint64_t ****)sub_1C541AB24(v104 + 2480, (uint64_t)&v304, (uint64_t *)&v304, v168);
        v169 = (uint64_t ***)v304;
        v109[3] = 0;
        v109[4] = 0;
        *v109 = v169;
        v109[1] = (uint64_t ***)(v109 + 3);
        v109[2] = (uint64_t ***)0x100000000;
LABEL_189:
        v115 = *((unsigned int *)v109 + 4);
        if ((_DWORD)v115)
        {
          v116 = v109[1] + 1;
          v117 = 16 * v115;
          while (*((_DWORD *)v116 - 2))
          {
            v116 += 2;
            v117 -= 16;
            if (!v117)
              goto LABEL_193;
          }
          v132 = *v116;
          v299[0] = v132;
          *(_BYTE *)(a1 + 801) = v132 != 0;
          if (!v132)
            goto LABEL_194;
          v304 = v308;
          v305 = v308;
          v306 = 32;
          v307 = 0;
          v309 = (llvm::User *)&v304;
          v310 = a1;
          v311[0] = v299;
          v311[1] = a2;
          v133 = a2[10];
          if (v133 == v4)
          {
LABEL_258:
            if (v305 != v304)
              free(v305);
            goto LABEL_194;
          }
LABEL_220:
          v134 = v133 - 3;
          if (!v133)
            v134 = 0;
          v135 = (uint64_t *)(v134 + 5);
          for (j = v134[6]; ; j = (uint64_t *)j[1])
          {
            if (j == v135)
            {
              v133 = (uint64_t **)v133[1];
              if (v133 == v4)
                goto LABEL_258;
              goto LABEL_220;
            }
            v137 = j ? (uint64_t)(j - 3) : 0;
            sub_1C544A79C((uint64_t)&v309, v137, *(_QWORD *)(v137 + 48));
            if ((*(_BYTE *)(v137 + 23) & 0x20) != 0)
              break;
LABEL_242:
            v4 = v297;
            if (*(_BYTE *)(a1 + 193))
              goto LABEL_258;
          }
          v138 = ***(_QWORD ***)v137;
          v300[0] = v137;
          v139 = *(_DWORD *)(v138 + 2496);
          if (v139)
          {
            v140 = *(_QWORD *)(v138 + 2480);
            v141 = v139 - 1;
            v142 = v141 & ((v137 >> 4) ^ (v137 >> 9));
            v143 = (_QWORD *)(v140 + 40 * v142);
            v144 = *v143;
            if (*v143 == v137)
              goto LABEL_238;
            v145 = 0;
            v146 = 1;
            while (v144 != -4096)
            {
              if (v145)
                v147 = 0;
              else
                v147 = v144 == -8192;
              if (v147)
                v145 = v143;
              v148 = v142 + v146++;
              v142 = v148 & v141;
              v143 = (_QWORD *)(v140 + 40 * v142);
              v144 = *v143;
              if (*v143 == v137)
                goto LABEL_238;
            }
            if (v145)
              v156 = v145;
            else
              v156 = v143;
          }
          else
          {
            v156 = 0;
          }
          v143 = sub_1C541AB24(v138 + 2480, (uint64_t)v300, v300, v156);
          v157 = v300[0];
          v143[4] = 0;
          v143[3] = 0;
          *v143 = v157;
          v143[1] = v143 + 3;
          v143[2] = 0x100000000;
LABEL_238:
          v149 = *((unsigned int *)v143 + 4);
          if ((_DWORD)v149)
          {
            v150 = (_QWORD *)(v143[1] + 8);
            v151 = 16 * v149;
            while (*((_DWORD *)v150 - 2) != 18)
            {
              v150 += 2;
              v151 -= 16;
              if (!v151)
                goto LABEL_242;
            }
            v152 = *v150;
            if (*v150)
            {
              v153 = *(unsigned int *)(v152 + 8);
              if (v153 >= 2)
              {
                for (k = 1; k < v153; ++k)
                {
                  v155 = *(_BYTE **)(v152 - 8 * v153 + 8 * k);
                  if (v155)
                  {
                    switch(*v155)
                    {
                      case 4:
                      case 5:
                      case 6:
                      case 7:
                      case 8:
                      case 9:
                      case 0xA:
                      case 0xB:
                      case 0xC:
                      case 0xD:
                      case 0xE:
                      case 0xF:
                      case 0x10:
                      case 0x11:
                      case 0x12:
                      case 0x13:
                      case 0x14:
                      case 0x15:
                      case 0x16:
                      case 0x17:
                      case 0x18:
                      case 0x19:
                      case 0x1A:
                      case 0x1B:
                      case 0x1C:
                      case 0x1D:
                      case 0x1E:
                      case 0x1F:
                      case 0x20:
                      case 0x21:
                      case 0x22:
                        break;
                      default:
                        v155 = 0;
                        break;
                    }
                  }
                  sub_1C544A79C((uint64_t)&v309, v137, (uint64_t)v155);
                  v153 = *(unsigned int *)(v152 + 8);
                }
              }
            }
          }
          goto LABEL_242;
        }
LABEL_193:
        *(_BYTE *)(a1 + 801) = 0;
        goto LABEL_194;
      }
    }
    v101 = "wrong number of parameters";
    goto LABEL_326;
  }
  v85 = 0;
  v86 = 0;
  v87 = &v313[16 * v314];
  v88 = (uint64_t ***)(v313 + 8);
  while (1)
  {
    v90 = v88 - 1;
    v89 = *((_DWORD *)v88 - 2);
    if (v89 != 2)
      break;
    if (v85)
    {
      v304 = "function must have a single !prof attachment";
      LOWORD(v308[0]) = 259;
      v309 = (llvm::User *)a2;
      v167 = (llvm::raw_ostream **)a1;
      v166 = v88;
      goto LABEL_292;
    }
    v85 = 1;
LABEL_160:
    v96 = *v88;
    v88 += 2;
    sub_1C5448E64((_QWORD *)a1, (uint64_t)v96);
    if (v90 + 2 == (uint64_t ***)v87)
      goto LABEL_166;
  }
  if (v89)
    goto LABEL_160;
  if (v86)
  {
    v295 = "function must have a single !dbg attachment";
LABEL_575:
    v304 = v295;
    LOWORD(v308[0]) = 259;
    v309 = (llvm::User *)a2;
    sub_1C62499C4((llvm::raw_ostream **)a1, (llvm::Twine *)&v304, (uint64_t *)&v309, v88);
    goto LABEL_293;
  }
  v91 = *v88;
  if (*(_BYTE *)*v88 != 17)
  {
    v295 = "function !dbg attachment must be a subprogram";
    goto LABEL_575;
  }
  if ((*((_BYTE *)v91 + 1) & 0x7F) == 1)
  {
    v304 = 0;
    v92 = sub_1C4F575EC(*(_QWORD *)(a1 + 720), *(_DWORD *)(a1 + 736), (uint64_t)v91, &v304);
    v93 = v304;
    if ((v92 & 1) != 0)
    {
      v97 = (uint64_t ***)*((_QWORD *)v304 + 1);
      if (v97 && v97 != a2)
      {
        v304 = "DISubprogram attached to more than one function";
        LOWORD(v308[0]) = 259;
        sub_1C6249CD4(a1, (llvm::Twine *)&v304);
        if (*(_QWORD *)a1)
        {
          sub_1C6249C6C((llvm::raw_ostream *)a1, v91);
LABEL_206:
          v122 = (llvm::raw_ostream **)a1;
          v123 = (llvm::User *)a2;
LABEL_570:
          sub_1C6249A88(v122, (uint64_t)v123);
        }
        goto LABEL_293;
      }
      goto LABEL_159;
    }
    v94 = *(_DWORD *)(a1 + 728);
    v95 = *(_DWORD *)(a1 + 736);
    if (4 * v94 + 4 < 3 * v95)
    {
      if (v95 + ~v94 - *(_DWORD *)(a1 + 732) > v95 >> 3)
        goto LABEL_156;
    }
    else
    {
      v95 *= 2;
    }
    sub_1C544D1C4(a1 + 720, v95);
    v304 = 0;
    sub_1C4F575EC(*(_QWORD *)(a1 + 720), *(_DWORD *)(a1 + 736), (uint64_t)v91, &v304);
    v93 = v304;
LABEL_156:
    ++*(_DWORD *)(a1 + 728);
    if (*v93 != -4096)
      --*(_DWORD *)(a1 + 732);
    *v93 = v91;
    v93[1] = 0;
LABEL_159:
    v93[1] = a2;
    v86 = 1;
    goto LABEL_160;
  }
  v304 = "function definition may only have a distinct !dbg attachment";
  LOWORD(v308[0]) = 259;
  sub_1C6249CD4(a1, (llvm::Twine *)&v304);
  v4 = v297;
  if (*(_QWORD *)a1)
  {
LABEL_328:
    v174 = (llvm::raw_ostream **)a1;
    v175 = (uint64_t)a2;
    goto LABEL_329;
  }
LABEL_194:
  if (v313 != v315)
    free(v313);
LABEL_338:
  v177 = a2[10];
  if (v177 != v4)
  {
    v298 = (_QWORD *)(a1 + 292);
    do
    {
      v178 = v177 - 3;
      v49 = v177 == 0;
      v177 = (uint64_t **)v177[1];
      if (v49)
        v179 = 0;
      else
        v179 = v178;
      v180 = *(void **)(a1 + 280);
      if (v180 != *(void **)(a1 + 272))
      {
        v214 = *(unsigned int *)(a1 + 288);
        if (v214 >= 0x21 && 4 * (*(_DWORD *)(a1 + 292) - *(_DWORD *)(a1 + 296)) < v214)
        {
          free(v180);
          v225 = *(_DWORD *)(a1 + 292) - *(_DWORD *)(a1 + 296);
          v226 = 1 << (33 - __clz(v225 - 1));
          if (v225 <= 0x10)
            v227 = 32;
          else
            v227 = v226;
          *(_DWORD *)(a1 + 288) = v227;
          *v298 = 0;
          v228 = malloc_type_malloc(8 * v227, 0x4065EBACuLL);
          if (!v228)
            goto LABEL_587;
          *(_QWORD *)(a1 + 280) = v228;
          memset(v228, 255, 8 * *(unsigned int *)(a1 + 288));
          goto LABEL_345;
        }
        memset(v180, 255, 8 * v214);
      }
      *v298 = 0;
LABEL_345:
      v182 = v179 + 5;
      v181 = (uint64_t **)v179[5];
      if (v181 == v179 + 5
        || (v181 ? (v183 = v181 - 3) : (v183 = 0), *((unsigned __int8 *)v183 + 16) - 29 >= 0xB))
      {
        v304 = "Basic Block does not have terminator!";
        LOWORD(v308[0]) = 259;
        sub_1C6249A24(a1, (llvm::Twine *)&v304);
        if (*(_QWORD *)a1)
          sub_1C6249A88((llvm::raw_ostream **)a1, (uint64_t)v179);
        goto LABEL_420;
      }
      v184 = v179[6];
      v185 = v184 - 3;
      if (!v184)
        v185 = 0;
      if (*((_BYTE *)v185 + 16) == 83)
      {
        for (m = (uint64_t)v179[1]; m; m = *(_QWORD *)(m + 8))
        {
          v187 = *(_QWORD *)(m + 24);
          v188 = *(unsigned __int8 *)(v187 + 16);
          if (v187)
            v189 = v188 >= 0x1C;
          else
            v189 = 0;
          if (v189 && v188 - 29 < 0xB)
            break;
        }
        v313 = v315;
        v314 = 0x800000000;
        sub_1C4DBBCC0((unsigned int *)&v313, m, 0);
        v304 = &v306;
        v305 = (void *)0x800000000;
        if (v314 >= 2)
          qsort(v313, v314, 8uLL, (int (__cdecl *)(const void *, const void *))sub_1C4776710);
        if ((_QWORD *)*v182 == v182)
        {
          v194 = 1;
          goto LABEL_408;
        }
        for (n = v179[6]; ; n = *(uint64_t **)(v192 + 32))
        {
          v192 = (uint64_t)(n - 3);
          if (n)
            v193 = (uint64_t)(n - 3);
          else
            v193 = 0;
          v194 = 1;
          if (!n || *(_BYTE *)(v193 + 16) != 83)
            goto LABEL_408;
          v195 = *((_DWORD *)n - 1);
          v196 = v195 & 0x7FFFFFF;
          if ((_DWORD)v314 != (v195 & 0x7FFFFFF))
          {
            v309 = (llvm::User *)"PHINode should have one entry for each predecessor of its parent basic block!";
            LOWORD(v312) = 259;
            sub_1C6249A24(a1, (llvm::Twine *)&v309);
            if (*(_QWORD *)a1)
            {
              v224 = (llvm::raw_ostream **)a1;
              v222 = v192;
LABEL_440:
              sub_1C6249A88(v224, v222);
            }
            goto LABEL_407;
          }
          LODWORD(v305) = 0;
          if (HIDWORD(v305) < v196)
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v304, (uint64_t)&v306, v196, 16);
            v195 = *(_DWORD *)(v192 + 20);
          }
          v197 = v195 & 0x7FFFFFF;
          if (v197)
          {
            v198 = 0;
            v199 = 0;
            v200 = 8 * v197;
            do
            {
              v201 = *(_DWORD *)(v192 + 20);
              if ((v201 & 0x40000000) != 0)
                v202 = *(_QWORD *)(v192 - 8);
              else
                v202 = v192 - 32 * (v201 & 0x7FFFFFF);
              v203 = *(_QWORD *)(v202 + 32 * *(unsigned int *)(v192 + 60) + v199);
              v204 = *(_QWORD *)(v202 + v198);
              v205 = v305;
              if (v305 >= (unint64_t)HIDWORD(v305))
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v304, (uint64_t)&v306, v305 + 1, 16);
                v205 = v305;
              }
              v206 = (char *)v304 + 16 * v205;
              *v206 = v203;
              v206[1] = v204;
              v207 = (_DWORD)v305 + 1;
              LODWORD(v305) = (_DWORD)v305 + 1;
              v199 += 8;
              v198 += 32;
            }
            while (v200 != v199);
          }
          else
          {
            v207 = v305;
          }
          v208 = 126 - 2 * __clz(v207);
          v209 = v207 ? v208 : 0;
          sub_1C544D27C((uint64_t)v304, (unint64_t *)v304 + 2 * v207, (uint64_t)&v309, v209, 1);
          if ((_DWORD)v305)
            break;
LABEL_397:
          ;
        }
        v210 = 0;
        v211 = (char *)v304;
        v212 = (uint64_t *)v313;
        while (1)
        {
          if (v210)
          {
            v213 = *(_QWORD *)((char *)v304 + v210);
            if (v213 == *(_QWORD *)((char *)v304 + v210 - 16)
              && *(_QWORD *)((char *)v304 + v210 + 8) != *(_QWORD *)((char *)v304 + v210 - 8))
            {
              v309 = (llvm::User *)"PHI node has multiple entries for the same basic block with different incoming values!";
              LOWORD(v312) = 259;
              sub_1C6249A24(a1, (llvm::Twine *)&v309);
              if (*(_QWORD *)a1)
              {
                sub_1C6249A88((llvm::raw_ostream **)a1, v192);
                v220 = *(_QWORD *)&v211[v210];
                if (v220)
                  sub_1C6249A88((llvm::raw_ostream **)a1, v220);
                v221 = *(_QWORD *)&v211[v210 + 8];
                if (v221)
                  sub_1C6249A88((llvm::raw_ostream **)a1, v221);
                v222 = *(_QWORD *)&v211[v210 - 8];
                if (v222)
                {
LABEL_437:
                  v224 = (llvm::raw_ostream **)a1;
                  goto LABEL_440;
                }
              }
LABEL_407:
              v194 = 0;
LABEL_408:
              if (v304 != &v306)
                free(v304);
              v4 = v297;
              if (v313 != v315)
                free(v313);
              if (v194)
              {
                v184 = v179[6];
                goto LABEL_414;
              }
              goto LABEL_420;
            }
          }
          else
          {
            v213 = *(_QWORD *)v304;
          }
          if (v213 != *v212)
          {
            v309 = (llvm::User *)"PHI node entries do not match predecessors!";
            LOWORD(v312) = 259;
            sub_1C6249A24(a1, (llvm::Twine *)&v309);
            if (*(_QWORD *)a1)
            {
              sub_1C6249A88((llvm::raw_ostream **)a1, v192);
              v223 = *(_QWORD *)&v211[v210];
              if (v223)
                sub_1C6249A88((llvm::raw_ostream **)a1, v223);
              v222 = *v212;
              if (*v212)
                goto LABEL_437;
            }
            goto LABEL_407;
          }
          ++v212;
          v210 += 16;
          if (16 * v305 == v210)
            goto LABEL_397;
        }
      }
      while (1)
      {
LABEL_414:
        if (v184 == v182)
          goto LABEL_420;
        v216 = v184 - 3;
        if (!v184)
          v216 = 0;
        if ((uint64_t **)v216[5] != v179)
          break;
        v184 = (uint64_t *)v184[1];
      }
      v304 = "Instruction has bogus parent pointer!";
      LOWORD(v308[0]) = 259;
      sub_1C6249A24(a1, (llvm::Twine *)&v304);
LABEL_420:
      v217 = v179[6];
      if (v217 != v182)
      {
        do
        {
          v218 = (_QWORD *)v217[1];
          if (v217)
            v219 = (uint64_t)(v217 - 3);
          else
            v219 = 0;
          sub_1C544E3AC((llvm::raw_ostream **)a1, v219);
          v217 = v218;
        }
        while (v218 != v182);
      }
    }
    while (v177 != v4);
  }
  v304 = v308;
  v305 = v308;
  v306 = 8;
  v307 = 0;
  v313 = (char *)v316;
  v314 = (uint64_t)v316;
  *(_QWORD *)v315 = 8;
  *(_DWORD *)&v315[8] = 0;
  v229 = *(uint64_t **)(a1 + 880);
  for (ii = *(uint64_t **)(a1 + 888); v229 != ii; v229 += 2)
  {
    v303 = 0;
    v303 = *v229;
    v231 = sub_1C477672C((uint64_t)&v304, v303);
    if (v305 == v304)
      v232 = (uint64_t *)((char *)&v306 + 4);
    else
      v232 = &v306;
    if (v231 == (_QWORD *)((char *)v305 + 8 * *(unsigned int *)v232))
    {
      sub_1C4774094((llvm::SmallPtrSetImplBase *)&v313, v303);
      for (jj = v229[1]; ; jj = v239)
      {
        v234 = sub_1C545A178(jj);
        v235 = sub_1C477672C((uint64_t)&v313, v234);
        if ((char *)v314 == v313)
          v236 = &v315[4];
        else
          v236 = v315;
        if (v235 != (_QWORD *)(v314 + 8 * *(unsigned int *)v236))
        {
          v302 = v234;
          v309 = (llvm::User *)v311;
          v310 = 0x800000000;
          v245 = v234;
          do
          {
            v246 = v310;
            if (v310 >= (unint64_t)HIDWORD(v310))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v309, (uint64_t)v311, v310 + 1, 8);
              v246 = v310;
            }
            *((_QWORD *)v309 + v246) = v245;
            LODWORD(v310) = v310 + 1;
            v247 = (uint64_t *)sub_1C6194570(a1 + 856, &v302);
            v248 = *v247;
            if (*v247 != v302)
            {
              v249 = v310;
              if (v310 >= (unint64_t)HIDWORD(v310))
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v309, (uint64_t)v311, v310 + 1, 8);
                v249 = v310;
              }
              *((_QWORD *)v309 + v249) = v248;
              LODWORD(v310) = v310 + 1;
            }
            v245 = sub_1C545A178(v248);
            v302 = v245;
          }
          while (v245 != v234);
          v301 = 259;
          v299[0] = (uint64_t)v309;
          v299[1] = v310;
          v300[0] = (uint64_t)"EH pads can't handle each other's exceptions";
          sub_1C624A1E8((llvm::raw_ostream **)a1, (llvm::Twine *)v300, (uint64_t)v299);
          if (v309 != (llvm::User *)v311)
            free(v309);
          goto LABEL_485;
        }
        sub_1C4774094((llvm::SmallPtrSetImplBase *)&v304, v234);
        if (!v237)
          break;
        v303 = v234;
        v238 = sub_1C619495C(a1 + 856, &v303);
        if (*(_QWORD *)(a1 + 888) == v238)
          break;
        v239 = *(_QWORD *)(v238 + 8);
        sub_1C4774094((llvm::SmallPtrSetImplBase *)&v313, v303);
      }
      if ((char *)v314 == v313)
        goto LABEL_461;
      if (*(_DWORD *)v315 >= 0x21u && (4 * (*(_DWORD *)&v315[4] - *(_DWORD *)&v315[8])) < *(_DWORD *)v315)
      {
        free((void *)v314);
        v241 = *(_DWORD *)&v315[4] - *(_DWORD *)&v315[8];
        v242 = 1 << (33 - __clz(*(_DWORD *)&v315[4] - *(_DWORD *)&v315[8] - 1));
        *(_QWORD *)&v315[4] = 0;
        if (v241 <= 0x10)
          v243 = 32;
        else
          v243 = v242;
        *(_DWORD *)v315 = v243;
        v244 = malloc_type_malloc(8 * v243, 0x4065EBACuLL);
        if (v244)
        {
          v314 = (uint64_t)v244;
          memset(v244, 255, 8 * *(unsigned int *)v315);
          continue;
        }
LABEL_587:
        llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
      }
      memset((void *)v314, 255, 8 * *(unsigned int *)v315);
LABEL_461:
      *(_QWORD *)&v315[4] = 0;
    }
  }
LABEL_485:
  if ((char *)v314 != v313)
    free((void *)v314);
  if (v305 != v304)
    free(v305);
  v250 = *(void **)(a1 + 280);
  if (v250 != *(void **)(a1 + 272))
  {
    v266 = *(unsigned int *)(a1 + 288);
    if (v266 >= 0x21 && 4 * (*(_DWORD *)(a1 + 292) - *(_DWORD *)(a1 + 296)) < v266)
    {
      free(v250);
      v290 = *(_DWORD *)(a1 + 292) - *(_DWORD *)(a1 + 296);
      v291 = 1 << (33 - __clz(v290 - 1));
      if (v290 <= 0x10)
        v292 = 32;
      else
        v292 = v291;
      *(_DWORD *)(a1 + 288) = v292;
      *(_QWORD *)(a1 + 292) = 0;
      v293 = malloc_type_malloc(8 * v292, 0x4065EBACuLL);
      if (!v293)
        goto LABEL_587;
      *(_QWORD *)(a1 + 280) = v293;
      memset(v293, 255, 8 * *(unsigned int *)(a1 + 288));
      goto LABEL_491;
    }
    memset(v250, 255, 8 * v266);
  }
  *(_QWORD *)(a1 + 292) = 0;
LABEL_491:
  *(_DWORD *)(a1 + 1824) = 0;
  *(_QWORD *)(a1 + 792) = 0;
  *(_BYTE *)(a1 + 800) = 0;
  sub_1C4D8D8A8((_DWORD *)(a1 + 856));
  *(_QWORD *)(a1 + 888) = *(_QWORD *)(a1 + 880);
  v251 = *(unsigned int *)(a1 + 2024);
  if (!(_DWORD)v251)
    goto LABEL_530;
  v252 = 8 * v251;
  v253 = *(uint64_t **)(a1 + 2016);
  do
  {
    v254 = *v253;
    v255 = *(_QWORD *)(*v253 - 32 * (*(_DWORD *)(*v253 + 20) & 0x7FFFFFF));
    if (v255)
      v256 = *(_BYTE *)(v255 + 16) == 23;
    else
      v256 = 0;
    if (!v256)
    {
      v294 = "llvm.experimental.noalias.scope.decl must have a MetadataAsValue argument";
      goto LABEL_529;
    }
    v257 = *(unsigned __int8 **)(v255 + 24);
    if (*v257 - 4 >= 0x1F)
    {
      v294 = "!id.scope.list must point to an MDNode";
      goto LABEL_529;
    }
    if (*((_DWORD *)v257 + 2) != 1)
    {
      v294 = "!id.scope.list must point to a list with a single scope";
LABEL_529:
      v304 = v294;
      LOWORD(v308[0]) = 259;
      sub_1C6249A24(a1, (llvm::Twine *)&v304);
      if (*(_QWORD *)a1)
      {
        v288 = (llvm::raw_ostream **)a1;
        v289 = v254;
LABEL_558:
        sub_1C6249A88(v288, v289);
      }
      goto LABEL_530;
    }
    v258 = (uint64_t **)*((_QWORD *)v257 - 1);
    if (*(unsigned __int8 *)v258 - 4 >= 0x1F)
    {
      v304 = "scope list must consist of MDNodes";
LABEL_514:
      LOWORD(v308[0]) = 259;
      sub_1C6249A24(a1, (llvm::Twine *)&v304);
      if (!*(_QWORD *)a1)
        goto LABEL_518;
      v264 = (llvm::raw_ostream *)a1;
      v265 = (uint64_t **)v257;
LABEL_527:
      sub_1C6249C6C(v264, v265);
      goto LABEL_518;
    }
    v259 = *((unsigned int *)v258 + 2);
    if ((v259 & 0xFFFFFFFE) != 2)
    {
      v304 = "scope must have two or three operands";
LABEL_517:
      LOWORD(v308[0]) = 259;
      sub_1C6249A24(a1, (llvm::Twine *)&v304);
      if (!*(_QWORD *)a1)
        goto LABEL_518;
      v264 = (llvm::raw_ostream *)a1;
      v265 = v258;
      goto LABEL_527;
    }
    v260 = (unsigned __int8 *)&v258[-v259];
    if (*(uint64_t ***)v260 != v258 && **(_BYTE **)v260)
    {
      v304 = "first scope operand must be self-referential or string";
      goto LABEL_517;
    }
    if ((_DWORD)v259 == 3 && **((_BYTE **)v260 + 2))
    {
      v304 = "third scope operand must be string (if used)";
      goto LABEL_517;
    }
    v257 = (unsigned __int8 *)*((_QWORD *)v260 + 1);
    if (*v257 - 4 >= 0x1F)
    {
      v304 = "second scope operand must be MDNode";
      goto LABEL_517;
    }
    v261 = *((unsigned int *)v257 + 2);
    if ((v261 - 1) >= 2)
    {
      v263 = "domain must have one or two operands";
LABEL_525:
      v304 = v263;
      goto LABEL_514;
    }
    v262 = (unsigned __int8 **)&v257[-8 * v261];
    if (*v262 != v257 && **v262)
    {
      v263 = "first domain operand must be self-referential or string";
      goto LABEL_525;
    }
    if ((_DWORD)v261 == 2 && *v262[1])
    {
      v263 = "second domain operand must be string (if used)";
      goto LABEL_525;
    }
LABEL_518:
    ++v253;
    v252 -= 8;
  }
  while (v252);
  if (byte_1ED804DD0)
  {
    v267 = *(unsigned int *)(a1 + 2024);
    v268 = 126 - 2 * __clz(v267);
    v269 = (_DWORD)v267 ? v268 : 0;
    sub_1C545A210(*(uint64_t **)(a1 + 2016), (uint64_t *)(*(_QWORD *)(a1 + 2016) + 8 * v267), v269, 1);
    v270 = *(unsigned int *)(a1 + 2024);
    if ((_DWORD)v270)
    {
      v271 = *(const llvm::Value ***)(a1 + 2016);
      v272 = &v271[v270];
      v273 = v271;
      while (1)
      {
        v274 = v273;
        v275 = v273 + 1;
        v276 = *(_QWORD *)(*((_QWORD *)*v273 - 4 * (*((_DWORD *)*v273 + 5) & 0x7FFFFFF)) + 24);
        v277 = v276 - 8 * *(unsigned int *)(v276 + 8);
        v278 = 8;
        while (1)
        {
          v279 = v275;
          v280 = v278;
          if (v275 == v272)
            break;
          ++v275;
          v281 = *(_QWORD *)(*((_QWORD *)*v279 - 4 * (*((_DWORD *)*v279 + 5) & 0x7FFFFFF)) + 24);
          v282 = v281 - 8 * *(unsigned int *)(v281 + 8);
          v278 = v280 + 8;
          if (v282 != v277)
          {
            v273 = v279;
            goto LABEL_545;
          }
        }
        v273 = v272;
LABEL_545:
        if (v273 != v274 && (char *)v273 - (char *)v274 <= 255)
          break;
LABEL_555:
        v272 = &v271[v270];
        if (v273 == v272)
          goto LABEL_530;
      }
      v283 = v279 - 1;
      v284 = v274;
LABEL_548:
      v285 = *v284;
      v286 = v280;
      v287 = v274;
      while (v285 == *v287 || !llvm::DominatorTree::dominates((llvm::DominatorTree *)(a1 + 200), v285, *v287))
      {
        ++v287;
        v286 -= 8;
        if (!v286)
        {
          v49 = v283 == v284++;
          if (!v49)
            goto LABEL_548;
          v271 = *(const llvm::Value ***)(a1 + 2016);
          v270 = *(unsigned int *)(a1 + 2024);
          goto LABEL_555;
        }
      }
      v304 = "llvm.experimental.noalias.scope.decl dominates another one with the same scope";
      LOWORD(v308[0]) = 259;
      sub_1C6249A24(a1, (llvm::Twine *)&v304);
      if (v285 && *(_QWORD *)a1)
      {
        v288 = (llvm::raw_ostream **)a1;
        v289 = (uint64_t)v285;
        goto LABEL_558;
      }
    }
  }
LABEL_530:
  *(_DWORD *)(a1 + 2024) = 0;
  return *(_BYTE *)(a1 + 192) == 0;
}

uint64_t sub_1C5443D80(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;

  v2 = *(void **)(a1 + 2016);
  if (v2 != (void *)(a1 + 2032))
    free(v2);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 1992), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 1968), 8);
  v3 = *(void **)(a1 + 1816);
  if (v3 != (void *)(a1 + 1832))
    free(v3);
  v4 = *(void **)(a1 + 1536);
  if (v4 != *(void **)(a1 + 1528))
    free(v4);
  v5 = *(void **)(a1 + 1248);
  if (v5 != *(void **)(a1 + 1240))
    free(v5);
  v6 = *(void **)(a1 + 1192);
  if (v6 != (void *)(a1 + 1208))
    free(v6);
  v7 = *(void **)(a1 + 912);
  if (v7 != *(void **)(a1 + 904))
    free(v7);
  v8 = *(void **)(a1 + 880);
  if (v8)
  {
    *(_QWORD *)(a1 + 888) = v8;
    operator delete(v8);
  }
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 856), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 832), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 808), 8);
  v9 = *(void **)(a1 + 752);
  if (v9 != *(void **)(a1 + 744))
    free(v9);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 720), 8);
  v10 = *(void **)(a1 + 440);
  if (v10 != *(void **)(a1 + 432))
    free(v10);
  v11 = *(void **)(a1 + 280);
  if (v11 != *(void **)(a1 + 272))
    free(v11);
  sub_1C4DC4E38((uint64_t *)(a1 + 224));
  v12 = *(void **)(a1 + 200);
  if (v12 != (void *)(a1 + 216))
    free(v12);
  if (*(char *)(a1 + 151) < 0)
    operator delete(*(void **)(a1 + 128));
  llvm::ModuleSlotTracker::~ModuleSlotTracker((llvm::ModuleSlotTracker *)(a1 + 16));
  return a1;
}

uint64_t llvm::verifyModule(llvm *this, const llvm::Module *a2, llvm::raw_ostream *a3, BOOL *a4)
{
  char *v6;
  uint64_t v7;
  int v8;
  uint64_t ***v9;
  BOOL v10;
  _BYTE v12[2064];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  sub_1C5441BDC((uint64_t)v12, (uint64_t)a2, a3 == 0, this);
  v6 = (char *)this + 24;
  v7 = *((_QWORD *)this + 4);
  if ((char *)v7 == v6)
  {
    LOBYTE(v8) = 0;
  }
  else
  {
    v8 = 0;
    do
    {
      if (v7)
        v9 = (uint64_t ***)(v7 - 56);
      else
        v9 = 0;
      v8 |= !sub_1C5441DC4((uint64_t)v12, v9);
      v7 = *(_QWORD *)(v7 + 8);
    }
    while ((char *)v7 != v6);
  }
  v10 = sub_1C5443FC0((uint64_t)v12);
  if (a3)
    *(_BYTE *)a3 = v12[193];
  sub_1C5443D80((uint64_t)v12);
  return v8 & 1 | !v10;
}

BOOL sub_1C5443FC0(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t ***v18;
  llvm::Constant *v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t ****v26;
  uint64_t ***v27;
  int v28;
  int v29;
  uint64_t ***v30;
  uint64_t **v31;
  uint64_t **v32;
  int v33;
  BOOL v34;
  uint64_t v36;
  uint64_t ****v37;
  uint64_t ***v38;
  int v39;
  int v40;
  uint64_t ***v41;
  uint64_t **v42;
  uint64_t **v43;
  int v44;
  BOOL v45;
  uint64_t **v47;
  uint64_t *v48;
  int v49;
  llvm::PointerType *v50;
  uint64_t v51;
  int v52;
  _QWORD *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t ****v62;
  uint64_t ***v63;
  int v64;
  int v65;
  uint64_t ***v66;
  uint64_t **v67;
  int v68;
  BOOL v69;
  uint64_t v70;
  uint64_t ****v71;
  uint64_t ***v72;
  int v73;
  int v74;
  uint64_t ***v75;
  uint64_t **v76;
  uint64_t **v77;
  int v78;
  BOOL v79;
  BOOL v80;
  BOOL v81;
  char v82;
  uint64_t **v83;
  uint64_t *v84;
  char *v85;
  llvm::Value *v86;
  int v87;
  uint64_t v88;
  llvm::Value **v89;
  uint64_t v90;
  llvm::Value *v91;
  unsigned int v92;
  uint64_t v94;
  int v95;
  uint64_t v96;
  int v97;
  unsigned int v98;
  uint64_t ****v99;
  uint64_t ***v100;
  uint64_t ***v101;
  uint64_t **v102;
  int v103;
  uint64_t *v105;
  uint64_t v106;
  std::string::size_type v107;
  std::string::size_type v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  _QWORD *v114;
  _QWORD *v115;
  int v116;
  int64_t v117;
  BOOL v118;
  unint64_t v119;
  int v120;
  int v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  _QWORD *v125;
  _QWORD *v126;
  int v127;
  int64_t v128;
  unint64_t v129;
  int v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  _QWORD *v134;
  _QWORD *v135;
  int v136;
  int64_t v137;
  unint64_t v138;
  int v139;
  int v140;
  char v141;
  unint64_t v142;
  unint64_t v143;
  unint64_t v144;
  unsigned __int8 *v145;
  int v146;
  char v147;
  uint64_t ****v148;
  int v149;
  BOOL v150;
  unsigned int v151;
  uint64_t ****v152;
  uint64_t ***v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  llvm::GlobalValue **v158;
  llvm::GlobalValue *v159;
  int v160;
  int v161;
  llvm::raw_ostream **v162;
  uint64_t v163;
  llvm::GlobalValue *v164;
  uint64_t v165;
  char *v166;
  uint64_t v167;
  std::string *v168;
  char *v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t ****v174;
  uint64_t ***v175;
  int v176;
  int v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t ****v182;
  uint64_t ***v183;
  int v184;
  int v185;
  uint64_t ***v186;
  uint64_t v187;
  char *v188;
  uint64_t v189;
  const char *v190;
  uint64_t ***v191;
  uint64_t v192;
  char *v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  _DWORD *v197;
  unsigned int v198;
  int v199;
  uint64_t v201;
  unsigned int v202;
  char *v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  unsigned int v208;
  int v209;
  uint64_t ResolverFunction;
  int v212;
  uint64_t v213;
  uint64_t **v214;
  llvm::PointerType *v215;
  uint64_t v216;
  std::string::size_type v217;
  uint64_t **v218;
  char v219;
  int v220;
  std::string::size_type v221;
  unint64_t v222;
  unint64_t v223;
  unint64_t v224;
  uint64_t v226;
  uint64_t v227;
  BOOL v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  _BYTE *v232;
  char v233;
  int v234;
  uint64_t v235;
  uint64_t *v236;
  uint64_t v237;
  uint64_t v238;
  BOOL v239;
  uint64_t *v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  BOOL v244;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  unsigned int v251;
  unint64_t v252;
  unsigned __int8 *v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  llvm::Value *v257;
  llvm::Value *v258;
  unsigned int v259;
  BOOL v260;
  BOOL v261;
  BOOL v262;
  uint64_t v263;
  _QWORD *i;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  BOOL v271;
  uint64_t NamedMetadata;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  const char *v280;
  unsigned __int8 *v281;
  uint64_t v282;
  uint64_t v283;
  uint64_t v284;
  unsigned int v285;
  _QWORD *v286;
  uint64_t *v287;
  uint64_t *v288;
  uint64_t v289;
  BOOL v290;
  uint64_t v291;
  const char *v292;
  uint64_t **v294;
  uint64_t v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  BOOL v299;
  uint64_t v301;
  uint64_t v302;
  BOOL v303;
  uint64_t v304;
  int v305;
  uint64_t v307;
  uint64_t v308;
  uint64_t v309;
  unsigned __int8 *v310;
  llvm::Value **v311;
  unsigned __int8 *v312;
  llvm::Value **v313;
  unsigned __int8 *v314;
  uint64_t v315;
  int v316;
  llvm::raw_ostream *v317;
  uint64_t v318;
  BOOL v319;
  const char *v320;
  uint64_t **v321;
  uint64_t *v322;
  uint64_t *v323;
  std::string::size_type v324;
  int v325;
  int v326;
  uint64_t v327;
  uint64_t **v328;
  uint64_t v329;
  uint64_t v330;
  uint64_t **v331;
  uint64_t v332;
  int v333;
  int v334;
  uint64_t v335;
  uint64_t v336;
  uint64_t v337;
  uint64_t v338;
  uint64_t ***v339;
  uint64_t **v340;
  _BYTE *v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  uint64_t v345;
  uint64_t ***v346;
  uint64_t **v347;
  _BYTE *v348;
  uint64_t v349;
  uint64_t v350;
  uint64_t v351;
  uint64_t v352;
  uint64_t v353;
  uint64_t v354;
  char *v355;
  char *v356;
  uint64_t v357;
  uint64_t v358;
  uint64_t ***v359;
  uint64_t v360;
  uint64_t ***v361;
  uint64_t **v362;
  _QWORD *v363;
  uint64_t *v364;
  uint64_t v365;
  uint64_t *v366;
  uint64_t *v367;
  uint64_t v368;
  uint64_t v369;
  unsigned __int16 v370;
  uint64_t v371;
  uint64_t v372;
  _QWORD *v373;
  int v374;
  unsigned int v375;
  _QWORD *v376;
  uint64_t v377;
  uint64_t v379;
  uint64_t **v381;
  llvm::raw_ostream *v382;
  uint64_t **v383;
  llvm::raw_ostream *v384;
  unsigned int v385;
  int v386;
  unsigned int v387;
  void *v388;
  int v389;
  int v390;
  _QWORD *v391;
  uint64_t v392;
  unint64_t v393;
  unint64_t v394;
  _QWORD *v395;
  uint64_t v396;
  uint64_t v397;
  uint64_t v398;
  llvm::GlobalValue *v399;
  uint64_t v400;
  std::string::size_type v401;
  llvm::ModuleSlotTracker *v402;
  char *v403;
  void *__p[2];
  char *v405;
  uint64_t v406;
  __int16 v407;
  void *v408;
  uint64_t v409;
  uint64_t v410;
  int v411;
  _WORD v412[56];
  std::string v413;
  uint64_t v414;

  v1 = a1;
  v414 = *MEMORY[0x1E0C80C00];
  *(_BYTE *)(a1 + 192) = 0;
  v2 = *(_QWORD *)(a1 + 8);
  v3 = v2 + 24;
  v4 = *(_QWORD *)(v2 + 32);
  if (v4 != v2 + 24)
  {
    do
    {
      if (v4)
        v5 = v4 - 56;
      else
        v5 = 0;
      if (*(_DWORD *)(v5 + 36) == 119)
      {
        v6 = *(unsigned int *)(v1 + 1200);
        if (v6 >= *(unsigned int *)(v1 + 1204))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(v1 + 1192, v1 + 1208, v6 + 1, 8);
          v6 = *(unsigned int *)(v1 + 1200);
        }
        *(_QWORD *)(*(_QWORD *)(v1 + 1192) + 8 * v6) = v5;
        ++*(_DWORD *)(v1 + 1200);
      }
      v4 = *(_QWORD *)(v4 + 8);
    }
    while (v4 != v3);
  }
  v7 = *(_QWORD *)(v1 + 832);
  v8 = *(unsigned int *)(v1 + 848);
  v9 = (uint64_t *)(v7 + 16 * v8);
  if (*(_DWORD *)(v1 + 840))
  {
    if ((_DWORD)v8)
    {
      v10 = 16 * v8;
      v11 = *(uint64_t **)(v1 + 832);
      while ((*v11 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v11 += 2;
        v10 -= 16;
        if (!v10)
          goto LABEL_15;
      }
    }
    else
    {
      v11 = *(uint64_t **)(v1 + 832);
    }
  }
  else
  {
LABEL_15:
    v11 = (uint64_t *)(v7 + 16 * v8);
  }
  v12 = (uint64_t *)(v7 + 16 * v8);
LABEL_18:
  while (v11 != v12)
  {
    if (*((_DWORD *)v11 + 3) > *((_DWORD *)v11 + 2))
    {
      v14 = *v11;
      v408 = "all indices passed to llvm.localrecover must be less than the number of arguments passed to llvm.localescap"
             "e in the parent function";
      v412[0] = 259;
      sub_1C6249A24(v1, (llvm::Twine *)&v408);
      if (*(_QWORD *)v1)
        v15 = v14 == 0;
      else
        v15 = 1;
      if (!v15)
        sub_1C6249A88((llvm::raw_ostream **)v1, v14);
      break;
    }
    v13 = v11 + 2;
    v11 = v9;
    if (v13 != v9)
    {
      while ((*v13 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v13 += 2;
        if (v13 == v9)
        {
          v11 = v9;
          goto LABEL_18;
        }
      }
      v11 = v13;
    }
  }
  v16 = *(_QWORD *)(v1 + 8);
  v17 = *(_QWORD *)(v16 + 16);
  v398 = v16 + 8;
  v402 = (llvm::ModuleSlotTracker *)v1;
  if (v17 != v16 + 8)
  {
    while (1)
    {
      if (v17)
        v18 = (uint64_t ***)(v17 - 56);
      else
        v18 = 0;
      if (v17 && *((_BYTE *)v18 + 16) == 3)
      {
        if ((*((_DWORD *)v18 + 5) & 0x7FFFFFF) == 0)
          goto LABEL_46;
      }
      else if (!*((_BYTE *)v18 + 16) && v18[9] == (uint64_t **)(v18 + 9) && (*((_BYTE *)v18 + 34) & 0x80) == 0)
      {
        goto LABEL_46;
      }
      v19 = (llvm::Constant *)*(v18 - 4);
      if (*(uint64_t ***)v19 != v18[3])
      {
        v85 = "Global variable initializer type does not match global variable type!";
        goto LABEL_296;
      }
      if (((_DWORD)v18[4] & 0xF) == 0xA)
      {
        if ((llvm::Constant::isNullValue(v19) & 1) == 0)
        {
          v85 = "'common' global must have a zero initializer!";
          goto LABEL_296;
        }
        if (((_BYTE)v18[10] & 1) != 0)
        {
          v85 = "'common' global may not be marked constant!";
          goto LABEL_296;
        }
        if (v18[6])
        {
          v85 = "'common' global may not be in a Comdat!";
          goto LABEL_296;
        }
      }
LABEL_46:
      v20 = *((_DWORD *)v18 + 5);
      if ((v20 & 0x10000000) == 0)
        goto LABEL_168;
      v21 = ***v18;
      v22 = *(_QWORD *)(v21 + 152);
      v23 = *(unsigned int *)(v21 + 168);
      v24 = v18 >> 4;
      if (!(_DWORD)v23)
        goto LABEL_53;
      LODWORD(v25) = (v23 - 1) & (v24 ^ (v18 >> 9));
      v26 = (uint64_t ****)(v22 + 16 * v25);
      v27 = *v26;
      if (*v26 != v18)
      {
        v28 = 1;
        while (v27 != (uint64_t ***)-4096)
        {
          v29 = v25 + v28++;
          v25 = v29 & (v23 - 1);
          v27 = *(uint64_t ****)(v22 + 16 * v25);
          if (v27 == v18)
          {
            v26 = (uint64_t ****)(v22 + 16 * v25);
            goto LABEL_54;
          }
        }
LABEL_53:
        v26 = (uint64_t ****)(v22 + 16 * v23);
      }
LABEL_54:
      v30 = v26[1];
      if (*v30 == (uint64_t **)17)
      {
        v31 = v30[2];
        v32 = v30[3];
        v33 = *((unsigned __int8 *)v30 + 32);
        v34 = v31 == (uint64_t **)0x6F6C672E6D766C6CLL && v32 == (uint64_t **)0x726F74635F6C6162;
        if (v34 && v33 == 115)
          goto LABEL_78;
      }
      if (!(_DWORD)v23)
        goto LABEL_68;
      LODWORD(v36) = (v23 - 1) & (v24 ^ (v18 >> 9));
      v37 = (uint64_t ****)(v22 + 16 * v36);
      v38 = *v37;
      if (*v37 != v18)
      {
        v39 = 1;
        while (v38 != (uint64_t ***)-4096)
        {
          v40 = v36 + v39++;
          v36 = v40 & (v23 - 1);
          v38 = *(uint64_t ****)(v22 + 16 * v36);
          if (v38 == v18)
          {
            v37 = (uint64_t ****)(v22 + 16 * v36);
            goto LABEL_69;
          }
        }
LABEL_68:
        v37 = (uint64_t ****)(v22 + 16 * v23);
      }
LABEL_69:
      v41 = v37[1];
      if (*v41 != (uint64_t **)17)
        goto LABEL_101;
      v42 = v41[2];
      v43 = v41[3];
      v44 = *((unsigned __int8 *)v41 + 32);
      v45 = v42 == (uint64_t **)0x6F6C672E6D766C6CLL && v43 == (uint64_t **)0x726F74645F6C6162;
      if (!v45 || v44 != 115)
        goto LABEL_101;
LABEL_78:
      if (v17 && *((_BYTE *)v18 + 16) == 3)
      {
        if ((v20 & 0x7FFFFFF) == 0)
          goto LABEL_86;
      }
      else if (!*((_BYTE *)v18 + 16) && v18[9] == (uint64_t **)(v18 + 9) && (*((_BYTE *)v18 + 34) & 0x80) == 0)
      {
LABEL_86:
        v47 = v18[3];
        if (v47 && *((_BYTE *)v47 + 8) == 17)
        {
          v48 = v47[3];
          v49 = *((unsigned __int8 *)v48 + 8);
          v50 = (llvm::PointerType *)llvm::FunctionType::get((uint64_t **)(**(_QWORD **)(v1 + 184) + 1576), 0, 0, 0);
          v51 = llvm::PointerType::get(v50, (llvm::Type *)*(unsigned int *)(*(_QWORD *)(v1 + 176) + 12));
          if (!v48)
            goto LABEL_158;
          if (v49 != 16)
            goto LABEL_158;
          v52 = *((_DWORD *)v48 + 3);
          if ((v52 & 0xFFFFFFFE) != 2)
            goto LABEL_158;
          v53 = (_QWORD *)v48[2];
          if (*(_DWORD *)(*v53 + 8) != 8205 || v53[1] != v51)
            goto LABEL_158;
          if (v52 != 3)
          {
            v408 = "the third field of the element type is mandatory, specify i8* null to migrate from the obsoleted 2-field form";
            v412[0] = 259;
            sub_1C6249A24(v1, (llvm::Twine *)&v408);
            goto LABEL_297;
          }
          v54 = v53[2];
          if (*(_BYTE *)(v54 + 8) != 15)
            goto LABEL_158;
          v55 = **(_QWORD **)v54 + 1912;
          v56 = *(_QWORD *)(v54 + 24);
          if (v56 && v56 != v55)
            goto LABEL_158;
          v20 = *((_DWORD *)v18 + 5);
          if ((v20 & 0x10000000) == 0)
            goto LABEL_168;
        }
LABEL_101:
        v58 = ***v18;
        v59 = *(_QWORD *)(v58 + 152);
        v60 = *(unsigned int *)(v58 + 168);
        if ((_DWORD)v60)
        {
          LODWORD(v61) = (v60 - 1) & (v24 ^ (v18 >> 9));
          v62 = (uint64_t ****)(v59 + 16 * v61);
          v63 = *v62;
          if (*v62 != v18)
          {
            v64 = 1;
            while (v63 != (uint64_t ***)-4096)
            {
              v65 = v61 + v64++;
              v61 = v65 & (v60 - 1);
              v63 = *(uint64_t ****)(v59 + 16 * v61);
              if (v63 == v18)
              {
                v62 = (uint64_t ****)(v59 + 16 * v61);
                goto LABEL_108;
              }
            }
            goto LABEL_107;
          }
        }
        else
        {
LABEL_107:
          v62 = (uint64_t ****)(v59 + 16 * v60);
        }
LABEL_108:
        v66 = v62[1];
        if (*v66 != (uint64_t **)9
          || ((v67 = v66[2], v68 = *((unsigned __int8 *)v66 + 24), v67 == (uint64_t **)0x6573752E6D766C6CLL)
            ? (v69 = v68 == 100)
            : (v69 = 0),
              !v69))
        {
          if (!(_DWORD)v60)
            goto LABEL_119;
          LODWORD(v70) = (v60 - 1) & (v24 ^ (v18 >> 9));
          v71 = (uint64_t ****)(v59 + 16 * v70);
          v72 = *v71;
          if (*v71 != v18)
          {
            v73 = 1;
            while (v72 != (uint64_t ***)-4096)
            {
              v74 = v70 + v73++;
              v70 = v74 & (v60 - 1);
              v72 = *(uint64_t ****)(v59 + 16 * v70);
              if (v72 == v18)
              {
                v71 = (uint64_t ****)(v59 + 16 * v70);
                goto LABEL_120;
              }
            }
LABEL_119:
            v71 = (uint64_t ****)(v59 + 16 * v60);
          }
LABEL_120:
          v75 = v71[1];
          if (*v75 != (uint64_t **)18
            || ((v76 = v75[2],
                 v77 = v75[3],
                 v78 = *((unsigned __int16 *)v75 + 16),
                 v76 == (uint64_t **)0x6D6F632E6D766C6CLL)
              ? (v79 = v77 == (uint64_t **)0x73752E72656C6970)
              : (v79 = 0),
                v79 ? (v80 = v78 == 25701) : (v80 = 0),
                !v80))
          {
LABEL_168:
            if ((*((_BYTE *)v18 + 34) & 0x40) != 0)
            {
              v94 = ***v18;
              v408 = v18;
              v95 = *(_DWORD *)(v94 + 2520);
              if (v95)
              {
                v96 = *(_QWORD *)(v94 + 2504);
                v97 = v95 - 1;
                v98 = v97 & ((v18 >> 4) ^ (v18 >> 9));
                v99 = (uint64_t ****)(v96 + 24 * v98);
                v100 = *v99;
                if (*v99 == v18)
                  goto LABEL_171;
                v148 = 0;
                v149 = 1;
                while (v100 != (uint64_t ***)-4096)
                {
                  if (v148)
                    v150 = 0;
                  else
                    v150 = v100 == (uint64_t ***)-8192;
                  if (v150)
                    v148 = v99;
                  v151 = v98 + v149++;
                  v98 = v151 & v97;
                  v99 = (uint64_t ****)(v96 + 24 * v98);
                  v100 = *v99;
                  if (*v99 == v18)
                    goto LABEL_171;
                }
                if (v148)
                  v152 = v148;
                else
                  v152 = v99;
              }
              else
              {
                v152 = 0;
              }
              v99 = (uint64_t ****)sub_1C53D65B8(v94 + 2504, (uint64_t)&v408, (uint64_t *)&v408, v152);
              v153 = (uint64_t ***)v408;
              v99[1] = 0;
              v99[2] = 0;
              *v99 = v153;
LABEL_171:
              if (v99[2] == (uint64_t ***)12)
              {
                v101 = v99[1];
                v102 = *v101;
                v103 = *((_DWORD *)v101 + 2);
                if (v102 == (uint64_t **)0x7274702E6D766C6CLL && v103 == 1752462689)
                {
                  llvm::GlobalPtrAuthInfo::tryAnalyze(v18, (uint64_t)&v408);
                  if ((v409 & 1) != 0)
                  {
                    if (v408)
                    {
                      v403 = (char *)v408;
                      sub_1C61D2548(&v403, &v413);
                      v168 = std::string::insert(&v413, 0, "invalid llvm.ptrauth global: ");
                      v169 = (char *)v168->__r_.__value_.__r.__words[2];
                      *(_OWORD *)__p = *(_OWORD *)&v168->__r_.__value_.__l.__data_;
                      v405 = v169;
                      v168->__r_.__value_.__l.__size_ = 0;
                      v168->__r_.__value_.__r.__words[2] = 0;
                      v168->__r_.__value_.__r.__words[0] = 0;
                      v412[0] = 260;
                      v408 = __p;
                      sub_1C6249A24(v1, (llvm::Twine *)&v408);
                      if (*(_QWORD *)v1)
                        sub_1C6249A88((llvm::raw_ostream **)v1, (uint64_t)v18);
                      if (SHIBYTE(v405) < 0)
                        operator delete(__p[0]);
                      if (SHIBYTE(v413.__r_.__value_.__r.__words[2]) < 0)
                        operator delete(v413.__r_.__value_.__l.__data_);
                      if (v403)
                        (*(void (**)(char *))(*(_QWORD *)v403 + 8))(v403);
                      goto LABEL_297;
                    }
                  }
                }
              }
            }
            v413.__r_.__value_.__r.__words[0] = (std::string::size_type)&v413.__r_.__value_.__r.__words[2];
            v413.__r_.__value_.__l.__size_ = 0x100000000;
            llvm::Value::getMetadata((unsigned int *)v18, 0, (uint64_t)&v413);
            if (LODWORD(v413.__r_.__value_.__r.__words[1]))
            {
              v105 = (uint64_t *)v413.__r_.__value_.__r.__words[0];
              v106 = 8 * LODWORD(v413.__r_.__value_.__r.__words[1]);
              do
              {
                if (*(_BYTE *)*v105 != 7)
                {
                  v408 = "!dbg attachment of global variable must be a DIGlobalVariableExpression";
                  v412[0] = 259;
                  sub_1C6249CD4(v1, (llvm::Twine *)&v408);
                  goto LABEL_268;
                }
                sub_1C544C834((llvm::raw_ostream *)v1, *v105++);
                v106 -= 8;
              }
              while (v106);
            }
            LODWORD(v413.__r_.__value_.__r.__words[1]) = 0;
            v399 = (llvm::GlobalValue *)v18;
            llvm::Value::getMetadata((unsigned int *)v18, 28, (uint64_t)&v413);
            if (LODWORD(v413.__r_.__value_.__r.__words[1]))
            {
              v107 = v413.__r_.__value_.__r.__words[0];
              v108 = v413.__r_.__value_.__r.__words[0] + 8 * LODWORD(v413.__r_.__value_.__r.__words[1]);
              v400 = v17;
              v401 = v108;
              do
              {
                v109 = *(_QWORD *)v107;
                v110 = *(unsigned int *)(*(_QWORD *)v107 + 8);
                if (!(_DWORD)v110
                  || (v111 = *(_QWORD *)(v109 - 8 * v110), *(_BYTE *)v111 != 1)
                  || (v112 = *(_QWORD *)(v111 + 128), *(_BYTE *)(v112 + 16) != 16))
                {
                  v408 = "bad !vcall_visibility attachment";
                  v412[0] = 259;
                  sub_1C6249A24(v1, (llvm::Twine *)&v408);
                  goto LABEL_268;
                }
                v113 = *(unsigned int *)(v112 + 32);
                if (v113 > 0x40)
                {
                  v114 = (_QWORD *)operator new[]();
                  memcpy(v114, *(const void **)(v112 + 24), ((unint64_t)(v113 + 63) >> 3) & 0x3FFFFFF8);
                  v116 = 0;
                  v117 = (unint64_t)(v113 + 63) >> 6;
                  do
                  {
                    v118 = v117-- < 1;
                    if (v118)
                      break;
                    v119 = v114[v117];
                    v116 += __clz(v119);
                  }
                  while (!v119);
                  v120 = v113 | 0xFFFFFFC0;
                  if ((v113 & 0x3F) == 0)
                    v120 = 0;
                  if ((v113 - v116 - v120) > 0x40)
                    goto LABEL_216;
                  v115 = (_QWORD *)*v114;
                }
                else
                {
                  v114 = *(_QWORD **)(v112 + 24);
                  v115 = v114;
                }
                if (v115 == (_QWORD *)-1)
                  goto LABEL_216;
                v121 = *(_DWORD *)(v109 + 8);
                if (v121 == 1)
                  goto LABEL_240;
                if (v121 != 3
                  || (v122 = *(_QWORD *)(v109 - 16), *(_BYTE *)v122 != 1)
                  || (v123 = *(_QWORD *)(v122 + 128), *(_BYTE *)(v123 + 16) != 16))
                {
LABEL_216:
                  v408 = "bad !vcall_visibility attachment";
                  v412[0] = 259;
                  sub_1C6249A24(v1, (llvm::Twine *)&v408);
                  goto LABEL_239;
                }
                v124 = *(unsigned int *)(v123 + 32);
                if (v124 > 0x40)
                {
                  v125 = (_QWORD *)operator new[]();
                  memcpy(v125, *(const void **)(v123 + 24), ((unint64_t)(v124 + 63) >> 3) & 0x3FFFFFF8);
                  v127 = 0;
                  v128 = (unint64_t)(v124 + 63) >> 6;
                  do
                  {
                    v118 = v128-- < 1;
                    if (v118)
                      break;
                    v129 = v125[v128];
                    v127 += __clz(v129);
                  }
                  while (!v129);
                  v130 = v124 | 0xFFFFFFC0;
                  if ((v124 & 0x3F) == 0)
                    v130 = 0;
                  v1 = (uint64_t)v402;
                  if ((v124 - v127 - v130) > 0x40)
                  {
LABEL_228:
                    v408 = "bad !vcall_visibility attachment";
                    v412[0] = 259;
                    sub_1C6249A24(v1, (llvm::Twine *)&v408);
                    v140 = 1;
                    goto LABEL_235;
                  }
                  v126 = (_QWORD *)*v125;
                }
                else
                {
                  v125 = *(_QWORD **)(v123 + 24);
                  v126 = v125;
                }
                if (v126 == (_QWORD *)-1)
                  goto LABEL_228;
                v131 = *(_QWORD *)(v109 - 8 * *(unsigned int *)(v109 + 8) + 16);
                if (*(_BYTE *)v131 != 1)
                  goto LABEL_228;
                v132 = *(_QWORD *)(v131 + 128);
                if (*(_BYTE *)(v132 + 16) != 16)
                  goto LABEL_228;
                v133 = *(unsigned int *)(v132 + 32);
                if (v133 > 0x40)
                {
                  v134 = (_QWORD *)operator new[]();
                  memcpy(v134, *(const void **)(v132 + 24), ((unint64_t)(v133 + 63) >> 3) & 0x3FFFFFF8);
                  v136 = 0;
                  v137 = (unint64_t)(v133 + 63) >> 6;
                  do
                  {
                    v118 = v137-- < 1;
                    if (v118)
                      break;
                    v138 = v134[v137];
                    v136 += __clz(v138);
                  }
                  while (!v138);
                  v139 = v133 | 0xFFFFFFC0;
                  if ((v133 & 0x3F) == 0)
                    v139 = 0;
                  if ((v133 - v136 - v139) > 0x40)
                  {
                    v17 = v400;
                    goto LABEL_230;
                  }
                  v135 = (_QWORD *)*v134;
                  v17 = v400;
                }
                else
                {
                  v134 = *(_QWORD **)(v132 + 24);
                  v135 = v134;
                }
                if (v135 != (_QWORD *)-1)
                {
                  if (v124 > 0x40)
                  {
                    v142 = ((unint64_t)(v124 + 63) >> 3) & 0x3FFFFFF8;
                    while (v142)
                    {
                      v143 = *(_QWORD *)((char *)v125 + v142 - 8);
                      v144 = *(_QWORD *)((char *)v134 + v142 - 8);
                      v142 -= 8;
                      if (v143 != v144)
                      {
                        if (v143 <= v144)
                          break;
                        goto LABEL_230;
                      }
                    }
LABEL_227:
                    v140 = 0;
                    goto LABEL_231;
                  }
                  if (v125 <= v134)
                    goto LABEL_227;
                }
LABEL_230:
                v408 = "bad !vcall_visibility attachment";
                v412[0] = 259;
                sub_1C6249A24((uint64_t)v402, (llvm::Twine *)&v408);
                v140 = 1;
LABEL_231:
                if (v133 >= 0x41 && v134)
                  MEMORY[0x1CAA32F9C](v134, 0x1000C8000313F17);
                v1 = (uint64_t)v402;
LABEL_235:
                if (v124 >= 0x41 && v125)
                  MEMORY[0x1CAA32F9C](v125, 0x1000C8000313F17);
                v108 = v401;
                if (!v140)
                {
LABEL_240:
                  v141 = 1;
                  goto LABEL_241;
                }
LABEL_239:
                v141 = 0;
LABEL_241:
                if (v113 >= 0x41 && v114)
                  MEMORY[0x1CAA32F9C](v114, 0x1000C8000313F17);
                if ((v141 & 1) == 0)
                  goto LABEL_268;
                v107 += 8;
              }
              while (v107 != v108);
            }
            v145 = (unsigned __int8 *)*((_QWORD *)v399 + 3);
            v146 = v145[8];
            if (v146 == 16)
            {
              if (!llvm::StructType::containsScalableVectorType(*((llvm::StructType **)v399 + 3)))
                goto LABEL_254;
            }
            else if (v146 != 19)
            {
LABEL_254:
              if (v146 != 21 || (llvm::TargetExtType::getLayoutType((llvm::TargetExtType *)v145), (v147 & 2) != 0))
              {
                if (v17 && *((_BYTE *)v399 + 16) == 3)
                {
                  if ((*((_DWORD *)v399 + 5) & 0x7FFFFFF) == 0)
                    goto LABEL_267;
LABEL_266:
                  sub_1C5453144(v1, *((_QWORD *)v399 - 4));
                  goto LABEL_267;
                }
                if (*((_BYTE *)v399 + 16)
                  || *((llvm::GlobalValue **)v399 + 9) != (llvm::GlobalValue *)((char *)v399 + 72)
                  || (*((_BYTE *)v399 + 34) & 0x80) != 0)
                {
                  goto LABEL_266;
                }
LABEL_267:
                sub_1C5447AD0(v1, v399);
LABEL_268:
                if ((std::string::size_type *)v413.__r_.__value_.__l.__data_ != &v413.__r_.__value_.__r.__words[2])
                  free(v413.__r_.__value_.__l.__data_);
                goto LABEL_297;
              }
              if ((*((_BYTE *)v399 + 23) & 0x10) != 0)
              {
                v154 = ***(_QWORD ***)v399;
                v155 = *(_QWORD *)(v154 + 152);
                v156 = *(unsigned int *)(v154 + 168);
                if (!(_DWORD)v156)
                  goto LABEL_304;
                LODWORD(v157) = (v156 - 1) & ((v399 >> 4) ^ (v399 >> 9));
                v158 = (llvm::GlobalValue **)(v155 + 16 * v157);
                v159 = *v158;
                if (*v158 != v399)
                {
                  v160 = 1;
                  while (v159 != (llvm::GlobalValue *)-4096)
                  {
                    v161 = v157 + v160++;
                    v157 = v161 & (v156 - 1);
                    v159 = *(llvm::GlobalValue **)(v155 + 16 * v157);
                    if (v159 == v399)
                    {
                      v158 = (llvm::GlobalValue **)(v155 + 16 * v157);
                      goto LABEL_305;
                    }
                  }
LABEL_304:
                  v158 = (llvm::GlobalValue **)(v155 + 16 * v156);
                }
LABEL_305:
                v164 = v158[1];
                v167 = *(_QWORD *)v164;
                v166 = (char *)v164 + 16;
                v165 = v167;
              }
              else
              {
                v165 = 0;
                v166 = &byte_1C871356D;
              }
              v407 = 1283;
              __p[0] = "Global @";
              v405 = v166;
              v406 = v165;
              v408 = __p;
              v410 = (uint64_t)" has illegal target extension type";
              v412[0] = 770;
              sub_1C6249A24(v1, (llvm::Twine *)&v408);
              if (*(_QWORD *)v1)
                sub_1C6249BA8((llvm::raw_ostream **)v1, (llvm::Type *)v145);
              goto LABEL_268;
            }
            v408 = "Globals cannot contain scalable vectors";
            v412[0] = 259;
            sub_1C6249A24(v1, (llvm::Twine *)&v408);
            if (*(_QWORD *)v1)
              sub_1C6249A88((llvm::raw_ostream **)v1, (uint64_t)v399);
            goto LABEL_268;
          }
        }
        if (v17)
          v81 = *((_BYTE *)v18 + 16) == 3;
        else
          v81 = 0;
        v82 = !v81;
        if (v81)
        {
          if ((v20 & 0x7FFFFFF) == 0)
            goto LABEL_142;
        }
        else if (!*((_BYTE *)v18 + 16) && v18[9] == (uint64_t **)(v18 + 9) && (*((_BYTE *)v18 + 34) & 0x80) == 0)
        {
LABEL_142:
          v83 = v18[3];
          if (!v83 || *((_BYTE *)v83 + 8) != 17)
            goto LABEL_168;
          v84 = v83[3];
          if (v84 && *((_BYTE *)v84 + 8) == 15)
          {
            if ((v82 & 1) != 0)
            {
              if (!*((_BYTE *)v18 + 16) && v18[9] == (uint64_t **)(v18 + 9) && (*((_BYTE *)v18 + 34) & 0x80) == 0)
                goto LABEL_168;
            }
            else if ((v20 & 0x7FFFFFF) == 0)
            {
              goto LABEL_168;
            }
            v86 = (llvm::Value *)*(v18 - 4);
            if (v86 && *((_BYTE *)v86 + 16) == 8)
            {
              v87 = *((_DWORD *)v86 + 5);
              if ((v87 & 0x40000000) != 0)
              {
                v89 = (llvm::Value **)*((_QWORD *)v86 - 1);
                v88 = v87 & 0x7FFFFFF;
                if (!v88)
                  goto LABEL_168;
              }
              else
              {
                v88 = v87 & 0x7FFFFFF;
                v89 = (llvm::Value **)((char *)v86 - 32 * v88);
                if (!v88)
                  goto LABEL_168;
              }
              v90 = 32 * v88;
              while (1)
              {
                v91 = llvm::Value::stripPointerCasts(*v89);
                v86 = v91;
                v92 = *((unsigned __int8 *)v91 + 16);
                if (v92 >= 2 && v92 != 3)
                  break;
                if ((*((_BYTE *)v91 + 23) & 0x10) == 0)
                {
                  if ((*((_BYTE *)v18 + 23) & 0x10) != 0)
                  {
                    v170 = ***v18;
                    v171 = *(_QWORD *)(v170 + 152);
                    v172 = *(unsigned int *)(v170 + 168);
                    if (!(_DWORD)v172)
                      goto LABEL_332;
                    LODWORD(v173) = (v172 - 1) & (v24 ^ (v18 >> 9));
                    v174 = (uint64_t ****)(v171 + 16 * v173);
                    v175 = *v174;
                    if (*v174 != v18)
                    {
                      v176 = 1;
                      while (v175 != (uint64_t ***)-4096)
                      {
                        v177 = v173 + v176++;
                        v173 = v177 & (v172 - 1);
                        v175 = *(uint64_t ****)(v171 + 16 * v173);
                        if (v175 == v18)
                        {
                          v174 = (uint64_t ****)(v171 + 16 * v173);
                          goto LABEL_333;
                        }
                      }
LABEL_332:
                      v174 = (uint64_t ****)(v171 + 16 * v172);
                    }
LABEL_333:
                    v186 = v174[1];
                    v189 = (uint64_t)*v186;
                    v188 = (char *)(v186 + 2);
                    v187 = v189;
                  }
                  else
                  {
                    v187 = 0;
                    v188 = &byte_1C871356D;
                  }
                  __p[0] = "members of ";
                  v405 = v188;
                  v406 = v187;
                  v407 = 1283;
                  v408 = __p;
                  v409 = v187;
                  v190 = " must be named";
                  goto LABEL_338;
                }
                v89 += 4;
                v90 -= 32;
                if (!v90)
                  goto LABEL_168;
              }
              if ((*((_BYTE *)v18 + 23) & 0x10) != 0)
              {
                v178 = ***v18;
                v179 = *(_QWORD *)(v178 + 152);
                v180 = *(unsigned int *)(v178 + 168);
                if (!(_DWORD)v180)
                  goto LABEL_335;
                LODWORD(v181) = (v180 - 1) & (v24 ^ (v18 >> 9));
                v182 = (uint64_t ****)(v179 + 16 * v181);
                v183 = *v182;
                if (*v182 != v18)
                {
                  v184 = 1;
                  while (v183 != (uint64_t ***)-4096)
                  {
                    v185 = v181 + v184++;
                    v181 = v185 & (v180 - 1);
                    v183 = *(uint64_t ****)(v179 + 16 * v181);
                    if (v183 == v18)
                    {
                      v182 = (uint64_t ****)(v179 + 16 * v181);
                      goto LABEL_336;
                    }
                  }
LABEL_335:
                  v182 = (uint64_t ****)(v179 + 16 * v180);
                }
LABEL_336:
                v191 = v182[1];
                v194 = (uint64_t)*v191;
                v193 = (char *)(v191 + 2);
                v192 = v194;
              }
              else
              {
                v192 = 0;
                v193 = &byte_1C871356D;
              }
              __p[0] = "invalid ";
              v405 = v193;
              v406 = v192;
              v407 = 1283;
              v408 = __p;
              v409 = v192;
              v190 = " member";
LABEL_338:
              v410 = (uint64_t)v190;
              v412[0] = 770;
              sub_1C6249A24(v1, (llvm::Twine *)&v408);
            }
            else
            {
              v408 = "wrong initalizer for intrinsic global variable";
              v412[0] = 259;
              sub_1C6249A24(v1, (llvm::Twine *)&v408);
              if (!v86)
                goto LABEL_297;
            }
            if (!*(_QWORD *)v1)
              goto LABEL_297;
            v162 = (llvm::raw_ostream **)v1;
            v163 = (uint64_t)v86;
LABEL_300:
            sub_1C6249A88(v162, v163);
            goto LABEL_297;
          }
LABEL_158:
          v85 = "wrong type for intrinsic global variable";
          goto LABEL_296;
        }
        if (((_DWORD)v18[4] & 0xF) == 6)
          goto LABEL_142;
        goto LABEL_295;
      }
      if (((_DWORD)v18[4] & 0xF) == 6)
        goto LABEL_86;
LABEL_295:
      v85 = "invalid linkage for intrinsic global variable";
LABEL_296:
      v408 = v85;
      v412[0] = 259;
      sub_1C6249A24(v1, (llvm::Twine *)&v408);
      if (*(_QWORD *)v1)
      {
        v162 = (llvm::raw_ostream **)v1;
        v163 = (uint64_t)v18;
        goto LABEL_300;
      }
LABEL_297:
      v17 = *(_QWORD *)(v17 + 8);
      if (v17 == v398)
      {
        v16 = *(_QWORD *)(v1 + 8);
        break;
      }
    }
  }
  v195 = v16 + 40;
  v196 = *(_QWORD *)(v16 + 48);
  if (v196 == v16 + 40)
    goto LABEL_369;
  do
  {
    if (v196)
      v197 = (_DWORD *)(v196 - 48);
    else
      v197 = 0;
    v198 = v197[8] & 0xF;
    v118 = v198 > 8;
    v199 = (1 << v198) & 0x1BD;
    if (v118 || v199 == 0)
    {
      v204 = "Alias should have private, internal, linkonce, weak, linkonce_odr, weak_odr, or external linkage!";
      goto LABEL_366;
    }
    v201 = *((_QWORD *)v197 - 4);
    if (!v201)
    {
      v408 = "Aliasee cannot be NULL!";
      goto LABEL_367;
    }
    if (*(_QWORD *)v197 != *(_QWORD *)v201)
    {
      v408 = "Alias and aliasee types should match!";
      goto LABEL_367;
    }
    v202 = *(unsigned __int8 *)(v201 + 16);
    if (v202 >= 4 && v202 != 5)
    {
      v204 = "Aliasee should be either GlobalValue or ConstantExpr";
LABEL_366:
      v408 = v204;
LABEL_367:
      v412[0] = 259;
      sub_1C6249A24((uint64_t)v402, (llvm::Twine *)&v408);
      if (*(_QWORD *)v402)
        sub_1C6249A88((llvm::raw_ostream **)v402, (uint64_t)v197);
      goto LABEL_361;
    }
    v408 = v412;
    v409 = (uint64_t)v412;
    v410 = 4;
    v411 = 0;
    sub_1C4774094((llvm::SmallPtrSetImplBase *)&v408, (uint64_t)v197);
    sub_1C545B25C((llvm::raw_ostream **)v402, (llvm::SmallPtrSetImplBase *)&v408, (uint64_t)v197, v201);
    if ((void *)v409 != v408)
      free((void *)v409);
    sub_1C5447AD0((uint64_t)v402, (llvm::GlobalValue *)v197);
LABEL_361:
    v196 = *(_QWORD *)(v196 + 8);
  }
  while (v196 != v195);
  v1 = (uint64_t)v402;
  v16 = *((_QWORD *)v402 + 1);
LABEL_369:
  v205 = v16 + 56;
  v206 = *(_QWORD *)(v16 + 64);
  if (v206 != v16 + 56)
  {
    while (2)
    {
      if (v206)
        v207 = v206 - 56;
      else
        v207 = 0;
      v208 = *(_DWORD *)(v207 + 32) & 0xF;
      v118 = v208 > 8;
      v209 = (1 << v208) & 0x1BD;
      if (v118 || v209 == 0)
      {
        v408 = "IFunc should have private, internal, linkonce, weak, linkonce_odr, weak_odr, or external linkage!";
        goto LABEL_390;
      }
      ResolverFunction = llvm::GlobalIFunc::getResolverFunction((llvm::GlobalIFunc *)v207);
      if (!ResolverFunction)
      {
        v408 = "IFunc must have a Function resolver";
        goto LABEL_390;
      }
      v212 = *(_DWORD *)(ResolverFunction + 32);
      if ((v212 & 0xF) == 1)
        goto LABEL_388;
      if (*(_BYTE *)(ResolverFunction + 16))
      {
        if (*(_BYTE *)(ResolverFunction + 16) == 3 && (*(_DWORD *)(ResolverFunction + 20) & 0x7FFFFFF) == 0)
          goto LABEL_388;
LABEL_385:
        v213 = **(_QWORD **)(v207 - 32);
        v214 = (uint64_t **)llvm::PointerType::get(*(llvm::PointerType **)(v207 + 24), 0);
        v215 = (llvm::PointerType *)llvm::FunctionType::get(v214, 0, 0, 0);
        if (v213 != llvm::PointerType::get(v215, 0))
        {
          v408 = "IFunc resolver has incorrect type";
          goto LABEL_390;
        }
      }
      else
      {
        if ((v212 & 0x800000) != 0 || *(_QWORD *)(ResolverFunction + 72) != ResolverFunction + 72)
          goto LABEL_385;
LABEL_388:
        v408 = "IFunc resolver must be a definition";
LABEL_390:
        v412[0] = 259;
        sub_1C6249A24((uint64_t)v402, (llvm::Twine *)&v408);
        if (*(_QWORD *)v402)
          sub_1C6249A88((llvm::raw_ostream **)v402, v207);
      }
      v206 = *(_QWORD *)(v206 + 8);
      if (v206 == v205)
      {
        v1 = (uint64_t)v402;
        v16 = *((_QWORD *)v402 + 1);
        break;
      }
      continue;
    }
  }
  v216 = v16 + 72;
  v217 = *(_QWORD *)(v16 + 80);
  if (v217 == v16 + 72)
    goto LABEL_485;
  while (2)
  {
    v218 = (uint64_t **)(v217 + 16);
    v219 = *(_BYTE *)(v217 + 39);
    v220 = v219;
    if (v219 >= 0)
      v221 = v217 + 16;
    else
      v221 = *(_QWORD *)(v217 + 16);
    v222 = *(_QWORD *)(v217 + 24);
    v223 = v219 & 0x7F;
    if (v220 >= 0)
      v224 = v223;
    else
      v224 = *(_QWORD *)(v217 + 24);
    if (v224 >= 9 && *(_QWORD *)v221 == 0x6762642E6D766C6CLL && *(_BYTE *)(v221 + 8) == 46)
    {
      if (v224 != 11
        || ((v226 = *(_QWORD *)v221, v227 = *(_QWORD *)(v221 + 3), v226 == 0x6762642E6D766C6CLL)
          ? (v228 = v227 == 0x75632E6762642E6DLL)
          : (v228 = 0),
            !v228))
      {
        v408 = "unrecognized named metadata node in the llvm.dbg namespace";
        v412[0] = 259;
        sub_1C6249CD4(v1, (llvm::Twine *)&v408);
        if (*(_QWORD *)v1)
          sub_1C624A2AC((llvm::raw_ostream *)v1, (llvm::NamedMDNode *)v217);
        goto LABEL_479;
      }
    }
    v229 = *(unsigned int *)(*(_QWORD *)(v217 + 48) + 8);
    if ((_DWORD)v229)
    {
      v230 = 0;
      v231 = 8 * v229;
      while (1)
      {
        v232 = *(_BYTE **)(**(_QWORD **)(v217 + 48) + v230);
        __p[0] = v232;
        v233 = *(_BYTE *)(v217 + 39);
        v234 = v233;
        v235 = v233 & 0x7F;
        if (v234 < 0)
          v235 = *(_QWORD *)(v217 + 24);
        if (v235 == 11
          && (v234 >= 0 ? (v236 = (uint64_t *)(v217 + 16)) : (v236 = *v218),
              (v237 = *v236, v238 = *(uint64_t *)((char *)v236 + 3), v237 == 0x6762642E6D766C6CLL)
            ? (v239 = v238 == 0x75632E6762642E6DLL)
            : (v239 = 0),
              v239))
        {
          if (!v232 || *v232 != 16)
          {
            v408 = "invalid compile unit";
            v412[0] = 259;
            v413.__r_.__value_.__r.__words[0] = v217;
            sub_1C624A250((llvm::raw_ostream *)v1, (llvm::Twine *)&v408, (llvm::NamedMDNode **)&v413, (uint64_t ***)__p);
            goto LABEL_479;
          }
        }
        else if (!v232)
        {
          goto LABEL_430;
        }
        sub_1C5448E64((_QWORD *)v1, (uint64_t)v232);
LABEL_430:
        v230 += 8;
        if (v231 == v230)
        {
          LOBYTE(v220) = *(_BYTE *)(v217 + 39);
          v222 = *(_QWORD *)(v217 + 24);
          v223 = v220 & 0x7F;
          break;
        }
      }
    }
    v220 = (char)v220;
    if ((v220 & 0x80u) == 0)
      v222 = v223;
    if (v222 == 21)
    {
      v240 = v220 >= 0 ? (uint64_t *)(v217 + 16) : *v218;
      v241 = *v240;
      v242 = v240[1];
      v243 = *(uint64_t *)((char *)v240 + 13);
      v244 = v241 == 0x6573752E6D766C6CLL && v242 == 0x7469646E6F632E64;
      if (v244 && v243 == 0x6C616E6F69746964)
      {
        v246 = *(unsigned int *)(*(_QWORD *)(v217 + 48) + 8);
        if ((_DWORD)v246)
        {
          v247 = 0;
          while (2)
          {
            v248 = *(_QWORD *)(**(_QWORD **)(v217 + 48) + 8 * v247);
            if (*(_DWORD *)(v248 + 8) == 3
              && ((v249 = *(_QWORD *)(v248 - 24)) == 0
               || *(_BYTE *)v249 == 1 && *(unsigned __int8 *)(*(_QWORD *)(v249 + 128) + 16) < 4u)
              && ((v250 = *(_QWORD *)(*(_QWORD *)(v248 - 16) + 128), v251 = *(_DWORD *)(v250 + 32), v251 > 0x40)
                ? (v252 = **(_QWORD **)(v250 + 24))
                : (v252 = (uint64_t)(*(_QWORD *)(v250 + 24) << -(char)v251) >> -(char)v251),
                  v252 < 2
               && (v253 = *(unsigned __int8 **)(v248 - 8), *v253 - 4 < 0x1F)
               && (v254 = *((unsigned int *)v253 + 2), (_DWORD)v254)))
            {
              v255 = -8 * v254;
              do
              {
                v256 = *(_QWORD *)&v253[v255];
                if (v256)
                {
                  v257 = *(_BYTE *)v256 == 1 ? *(llvm::Value **)(v256 + 128) : 0;
                  v258 = llvm::Value::stripPointerCasts(v257);
                  v259 = *((unsigned __int8 *)v258 + 16);
                  v260 = v259 == 19 || v259 - 13 >= 0xFFFFFFFE;
                  v261 = !v260 || v258 == 0;
                  v262 = v261;
                  if (v259 >= 4 && v262)
                  {
                    v408 = "invalid llvm.used.conditional member";
                    v412[0] = 259;
                    v1 = (uint64_t)v402;
                    goto LABEL_478;
                  }
                }
                v255 += 8;
              }
              while (v255);
              ++v247;
              v1 = (uint64_t)v402;
              if (v247 != v246)
                continue;
            }
            else
            {
              v408 = "invalid llvm.used.conditional member";
              v412[0] = 259;
LABEL_478:
              sub_1C6249A24(v1, (llvm::Twine *)&v408);
            }
            break;
          }
        }
      }
    }
LABEL_479:
    v217 = *(_QWORD *)(v217 + 8);
    if (v217 != v216)
      continue;
    break;
  }
  v16 = *(_QWORD *)(v1 + 8);
LABEL_485:
  v263 = *(unsigned int *)(v16 + 128);
  if ((_DWORD)v263)
  {
    for (i = *(_QWORD **)(v16 + 120); !*i || *i == -8; ++i)
      ;
  }
  else
  {
    i = *(_QWORD **)(v16 + 120);
  }
  v266 = *(_QWORD *)(v16 + 120) + 8 * v263;
  if (i != (_QWORD *)v266)
  {
    do
    {
      if (*(_DWORD *)(v1 + 172) == 1)
      {
        v267 = sub_1C4FB7E80(*(uint64_t **)(*(_QWORD *)(v1 + 8) + 112), (unsigned __int8 *)(*(_QWORD *)(*i + 8) + 72), **(_QWORD **)(*i + 8));
        if (v267)
        {
          v268 = v267;
          if ((*(_DWORD *)(v267 + 32) & 0xF) == 8)
          {
            v408 = "comdat global value has private linkage";
            v412[0] = 259;
            sub_1C6249A24(v1, (llvm::Twine *)&v408);
            if (*(_QWORD *)v1)
              sub_1C6249A88((llvm::raw_ostream **)v1, v268);
          }
        }
      }
      do
      {
        v270 = i[1];
        ++i;
        v269 = v270;
        if (v270)
          v271 = v269 == -8;
        else
          v271 = 1;
      }
      while (v271);
    }
    while (i != (_QWORD *)v266);
    v16 = *(_QWORD *)(v1 + 8);
  }
  v408 = "llvm.module.flags";
  v412[0] = 259;
  NamedMetadata = llvm::Module::getNamedMetadata(v16, (uint64_t)&v408);
  if (!NamedMetadata)
    goto LABEL_656;
  v273 = NamedMetadata;
  memset(&v413, 0, 20);
  v408 = &v410;
  v409 = 0x1000000000;
  v274 = *(unsigned int *)(*(_QWORD *)(NamedMetadata + 48) + 8);
  if (!(_DWORD)v274)
    goto LABEL_655;
  v275 = 0;
  v276 = 0;
  while (2)
  {
    v277 = *(_QWORD *)(**(_QWORD **)(v273 + 48) + 8 * v276);
    if (*(_DWORD *)(v277 + 8) != 3)
    {
      __p[0] = "incorrect number of operands in module flag";
      v407 = 259;
      sub_1C6249A24(v1, (llvm::Twine *)__p);
      if (!*(_QWORD *)v1)
        goto LABEL_622;
      v317 = (llvm::raw_ostream *)v1;
      v294 = (uint64_t **)v277;
      goto LABEL_627;
    }
    LODWORD(v403) = 0;
    v278 = *(_QWORD *)(v277 - 24);
    if ((llvm::Module::isValidModFlagBehavior(v278, &v403) & 1) == 0)
    {
      if (v278
        && *(_BYTE *)v278 == 1
        && ((v318 = *(_QWORD *)(v278 + 128)) != 0 ? (v319 = *(_BYTE *)(v318 + 16) == 16) : (v319 = 0), v319))
      {
        v320 = "invalid behavior operand in module flag (unexpected constant)";
      }
      else
      {
        v320 = "invalid behavior operand in module flag (expected constant integer)";
      }
      __p[0] = (void *)v320;
      v407 = 259;
      v1 = (uint64_t)v402;
      sub_1C6249A24((uint64_t)v402, (llvm::Twine *)__p);
      if (!*(_QWORD *)v402)
        goto LABEL_622;
      v294 = *(uint64_t ***)(v277 - 24);
      goto LABEL_626;
    }
    v279 = *(_QWORD *)(v277 - 16);
    if (!v279 || *(_BYTE *)v279)
    {
      __p[0] = "invalid ID operand in module flag (expected metadata string)";
      v407 = 259;
      v1 = (uint64_t)v402;
      sub_1C6249A24((uint64_t)v402, (llvm::Twine *)__p);
      if (!*(_QWORD *)v402)
        goto LABEL_622;
      v294 = *(uint64_t ***)(v277 - 16);
LABEL_626:
      v317 = (llvm::raw_ostream *)v1;
LABEL_627:
      sub_1C6249C6C(v317, v294);
      goto LABEL_622;
    }
    switch((int)v403)
    {
      case 3:
        v281 = *(unsigned __int8 **)(v277 - 8);
        if (*v281 - 4 > 0x1E || *((_DWORD *)v281 + 2) != 2)
        {
          __p[0] = "invalid value for 'require' module flag (expected metadata pair)";
          v407 = 259;
          v1 = (uint64_t)v402;
          sub_1C6249A24((uint64_t)v402, (llvm::Twine *)__p);
          if (!*(_QWORD *)v402)
            break;
          v321 = *(uint64_t ***)(v277 - 8);
          goto LABEL_632;
        }
        if (!**((_BYTE **)v281 - 2))
        {
          v282 = v409;
          if (v409 >= (unint64_t)HIDWORD(v409))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v408, (uint64_t)&v410, v409 + 1, 8);
            v282 = v409;
          }
          *((_QWORD *)v408 + v282) = v281;
          LODWORD(v409) = v409 + 1;
          goto LABEL_535;
        }
        __p[0] = "invalid value for 'require' module flag (first value operand should be a string)";
        v407 = 259;
        v1 = (uint64_t)v402;
        sub_1C6249A24((uint64_t)v402, (llvm::Twine *)__p);
        if (*(_QWORD *)v402)
        {
          v321 = (uint64_t **)*((_QWORD *)v281 - 2);
LABEL_632:
          sub_1C6249C6C((llvm::raw_ostream *)v1, v321);
          break;
        }
        break;
      case 5:
      case 6:
        if (**(unsigned __int8 **)(v277 - 8) - 4 < 0x1F)
          goto LABEL_529;
        v280 = "invalid value for 'append'-type module flag (expected a metadata node)";
        goto LABEL_621;
      case 7:
        v283 = *(_QWORD *)(v277 - 8);
        if (v283 && *(_BYTE *)v283 == 1 && *(_BYTE *)(*(_QWORD *)(v283 + 128) + 16) == 16)
          goto LABEL_529;
        v280 = "invalid value for 'max' module flag (expected constant integer)";
        goto LABEL_621;
      case 8:
        v284 = *(_QWORD *)(v277 - 8);
        if (v284 && *(_BYTE *)v284 == 1 && *(_BYTE *)(*(_QWORD *)(v284 + 128) + 16) == 16)
          goto LABEL_529;
        v280 = "invalid value for 'min' module flag (expected constant integer)";
LABEL_621:
        __p[0] = (void *)v280;
        v407 = 259;
        v1 = (uint64_t)v402;
        sub_1C6249A24((uint64_t)v402, (llvm::Twine *)__p);
        if (!*(_QWORD *)v402)
          break;
        v294 = *(uint64_t ***)(v277 - 8);
        goto LABEL_626;
      default:
LABEL_529:
        __p[0] = 0;
        v285 = v413.__r_.__value_.__r.__words[2];
        if ((sub_1C545B460(v275, v413.__r_.__value_.__r.__words[2], v279, __p) & 1) != 0)
        {
          __p[0] = "module flag identifiers must be unique (or of 'require' type)";
          v407 = 259;
          sub_1C6249A24((uint64_t)v402, (llvm::Twine *)__p);
          if (*(_QWORD *)v402)
            sub_1C6249C6C(v402, (uint64_t **)v279);
          v1 = (uint64_t)v402;
          break;
        }
        if (4 * LODWORD(v413.__r_.__value_.__r.__words[1]) + 4 >= 3 * v285)
        {
          v316 = 2 * v285;
        }
        else
        {
          if (v285 + ~LODWORD(v413.__r_.__value_.__r.__words[1]) - HIDWORD(v413.__r_.__value_.__r.__words[1]) > v285 >> 3)
            goto LABEL_532;
          v316 = v285;
        }
        sub_1C545B4F4((uint64_t)&v413, v316);
        __p[0] = 0;
        v275 = v413.__r_.__value_.__r.__words[0];
        sub_1C545B460((uint64_t)v413.__r_.__value_.__l.__data_, v413.__r_.__value_.__r.__words[2], v279, __p);
LABEL_532:
        v286 = __p[0];
        ++LODWORD(v413.__r_.__value_.__r.__words[1]);
        if (*(_QWORD *)__p[0] != -4096)
          --HIDWORD(v413.__r_.__value_.__r.__words[1]);
        *(_QWORD *)__p[0] = v279;
        v286[1] = v277;
LABEL_535:
        v287 = *(uint64_t **)(v279 + 8);
        v288 = v287 + 3;
        v289 = *v287;
        if (*v287 == 14)
        {
          if (*v288 != 0x4F2072656B6E694CLL || *(uint64_t *)((char *)v287 + 30) != 0x736E6F6974704F20)
          {
            v1 = (uint64_t)v402;
            break;
          }
          v295 = *((_QWORD *)v402 + 1);
          __p[0] = "llvm.linker.options";
          v407 = 259;
          if (!llvm::Module::getNamedMetadata(v295, (uint64_t)__p))
          {
            __p[0] = "'Linker Options' named metadata no longer supported";
            v407 = 259;
            v1 = (uint64_t)v402;
            goto LABEL_573;
          }
          v287 = *(uint64_t **)(v279 + 8);
          v289 = *v287;
        }
        else if (v289 == 10)
        {
          v290 = *v288 == 0x69735F7261686377 && *((_WORD *)v287 + 16) == 25978;
          v1 = (uint64_t)v402;
          if (v290)
          {
            v291 = *(_QWORD *)(v277 - 8 * *(unsigned int *)(v277 + 8) + 16);
            if (!v291 || *(_BYTE *)v291 != 1 || *(_BYTE *)(*(_QWORD *)(v291 + 128) + 16) != 16)
            {
              v292 = "wchar_size metadata requires constant integer argument";
LABEL_572:
              __p[0] = (void *)v292;
              v407 = 259;
LABEL_573:
              sub_1C6249A24(v1, (llvm::Twine *)__p);
              break;
            }
          }
LABEL_574:
          v304 = *v288;
          v305 = *((unsigned __int16 *)v288 + 4);
          if (v304 == 0x69666F7250204743 && v305 == 25964)
          {
            v307 = *(_QWORD *)(v277 - 8 * *(unsigned int *)(v277 + 8) + 16);
            v308 = *(unsigned int *)(v307 + 8);
            if ((_DWORD)v308)
            {
              v309 = -8 * v308;
              do
              {
                v310 = *(unsigned __int8 **)(v307 + v309);
                if (v310 && *v310 - 4 <= 0x1E && *((_DWORD *)v310 + 2) == 3)
                {
                  v311 = (llvm::Value **)*((_QWORD *)v310 - 3);
                  if (v311
                    && (*(unsigned __int8 *)v311 - 3 < 0xFFFFFFFE
                     || *((_BYTE *)llvm::Value::stripPointerCasts(v311[16]) + 16)))
                  {
                    __p[0] = "expected a Function or null";
                    v407 = 259;
                    sub_1C6249A24((uint64_t)v402, (llvm::Twine *)__p);
                    if (*(_QWORD *)v402)
                      sub_1C6249C6C(v402, *((uint64_t ***)v310 - 3));
                  }
                  v312 = &v310[-8 * *((unsigned int *)v310 + 2)];
                  v313 = (llvm::Value **)*((_QWORD *)v312 + 1);
                  if (v313
                    && (*(unsigned __int8 *)v313 - 3 < 0xFFFFFFFE
                     || *((_BYTE *)llvm::Value::stripPointerCasts(v313[16]) + 16)))
                  {
                    __p[0] = "expected a Function or null";
                    v407 = 259;
                    sub_1C6249A24((uint64_t)v402, (llvm::Twine *)__p);
                    if (*(_QWORD *)v402)
                      sub_1C6249C6C(v402, *((uint64_t ***)v312 + 1));
                  }
                  v314 = &v310[-8 * *((unsigned int *)v310 + 2)];
                  v315 = *((_QWORD *)v314 + 2);
                  if (!v315 || *(_BYTE *)v315 != 1 || *(_BYTE *)(**(_QWORD **)(v315 + 128) + 8) != 13)
                  {
                    __p[0] = "expected an integer constant";
                    v407 = 259;
                    sub_1C6249A24((uint64_t)v402, (llvm::Twine *)__p);
                    if (*(_QWORD *)v402)
                      sub_1C6249C6C(v402, *((uint64_t ***)v314 + 2));
                  }
                }
                else
                {
                  __p[0] = "expected a MDNode triple";
                  v407 = 259;
                  sub_1C6249A24((uint64_t)v402, (llvm::Twine *)__p);
                  if (*(_QWORD *)v402)
                    sub_1C6249C6C(v402, *(uint64_t ***)(v307 + v309));
                }
                v309 += 8;
              }
              while (v309);
              v1 = (uint64_t)v402;
            }
          }
          break;
        }
        v1 = (uint64_t)v402;
        v288 = v287 + 3;
        if (v289 == 10)
          goto LABEL_574;
        if (v289 == 21)
        {
          v296 = *v288;
          v297 = v287[4];
          v298 = *(uint64_t *)((char *)v288 + 13);
          v299 = v296 == 0x6369746E616D6553 && v297 == 0x736F707265746E49;
          if (v299 && v298 == 0x6E6F697469736F70)
          {
            if ((v301 = *(_QWORD *)(v277 - 8 * *(unsigned int *)(v277 + 8) + 16)) == 0
              || *(_BYTE *)v301 != 1
              || ((v302 = *(_QWORD *)(v301 + 128)) != 0 ? (v303 = *(_BYTE *)(v302 + 16) == 16) : (v303 = 0), !v303))
            {
              v292 = "SemanticInterposition metadata requires constant integer argument";
              goto LABEL_572;
            }
          }
        }
        break;
    }
LABEL_622:
    if (++v276 != v274)
      continue;
    break;
  }
  v322 = (uint64_t *)v408;
  if ((_DWORD)v409)
  {
    v323 = (uint64_t *)((char *)v408 + 8 * v409);
    v324 = v413.__r_.__value_.__r.__words[0];
    v325 = v413.__r_.__value_.__r.__words[2];
    v326 = LODWORD(v413.__r_.__value_.__r.__words[2]) - 1;
    while (1)
    {
      v327 = *v322 - 8 * *(unsigned int *)(*v322 + 8);
      v328 = *(uint64_t ***)v327;
      if (!v325)
        goto LABEL_650;
      v329 = *(_QWORD *)(v327 + 8);
      v330 = ((v328 >> 4) ^ (v328 >> 9)) & v326;
      v331 = *(uint64_t ***)(v324 + 16 * v330);
      if (v328 != v331)
        break;
LABEL_641:
      v332 = *(_QWORD *)(v324 + 16 * v330 + 8);
      if (!v332)
        goto LABEL_650;
      if (*(_QWORD *)(v332 - 8 * *(unsigned int *)(v332 + 8) + 16) != v329)
      {
        __p[0] = "invalid requirement on flag, flag does not have the required value";
        goto LABEL_651;
      }
LABEL_643:
      if (++v322 == v323)
      {
        v322 = (uint64_t *)v408;
        v1 = (uint64_t)v402;
        goto LABEL_653;
      }
    }
    v333 = 1;
    while (v331 != (uint64_t **)-4096)
    {
      v334 = v330 + v333++;
      v330 = v334 & v326;
      v331 = *(uint64_t ***)(v324 + 16 * v330);
      if (v328 == v331)
        goto LABEL_641;
    }
LABEL_650:
    __p[0] = "invalid requirement on flag, flag is not present in module";
LABEL_651:
    v407 = 259;
    sub_1C6249A24((uint64_t)v402, (llvm::Twine *)__p);
    if (*(_QWORD *)v402)
      sub_1C6249C6C(v402, v328);
    goto LABEL_643;
  }
LABEL_653:
  if (v322 != &v410)
    free(v322);
LABEL_655:
  MEMORY[0x1CAA32FB4](v413.__r_.__value_.__r.__words[0], 8);
LABEL_656:
  v335 = *(_QWORD *)(v1 + 8);
  v408 = "llvm.ident";
  v412[0] = 259;
  v336 = llvm::Module::getNamedMetadata(v335, (uint64_t)&v408);
  if (v336)
  {
    v337 = *(_QWORD *)(v336 + 48);
    v338 = *(unsigned int *)(v337 + 8);
    if ((_DWORD)v338)
    {
      v339 = *(uint64_t ****)v337;
      while (1)
      {
        v340 = *v339;
        if (*((_DWORD *)*v339 + 2) != 1)
          break;
        v341 = *(v340 - 1);
        if (!v341 || *v341)
        {
          v408 = "invalid value for llvm.ident metadata entry operand(the operand should be a string)";
          v412[0] = 259;
          sub_1C6249A24(v1, (llvm::Twine *)&v408);
          if (!*(_QWORD *)v1)
            goto LABEL_663;
          v381 = (uint64_t **)*(v340 - 1);
          v382 = (llvm::raw_ostream *)v1;
          goto LABEL_722;
        }
        ++v339;
        if (!--v338)
          goto LABEL_663;
      }
      v408 = "incorrect number of operands in llvm.ident metadata";
      v412[0] = 259;
      sub_1C6249A24(v1, (llvm::Twine *)&v408);
      if (!*(_QWORD *)v1)
        goto LABEL_663;
      v382 = (llvm::raw_ostream *)v1;
      v381 = v340;
LABEL_722:
      sub_1C6249C6C(v382, v381);
    }
  }
LABEL_663:
  v342 = *(_QWORD *)(v1 + 8);
  v408 = "llvm.commandline";
  v412[0] = 259;
  v343 = llvm::Module::getNamedMetadata(v342, (uint64_t)&v408);
  if (v343)
  {
    v344 = *(_QWORD *)(v343 + 48);
    v345 = *(unsigned int *)(v344 + 8);
    if ((_DWORD)v345)
    {
      v346 = *(uint64_t ****)v344;
      while (1)
      {
        v347 = *v346;
        if (*((_DWORD *)*v346 + 2) != 1)
          break;
        v348 = *(v347 - 1);
        if (!v348 || *v348)
        {
          v408 = "invalid value for llvm.commandline metadata entry operand(the operand should be a string)";
          v412[0] = 259;
          sub_1C6249A24(v1, (llvm::Twine *)&v408);
          if (!*(_QWORD *)v1)
            goto LABEL_670;
          v383 = (uint64_t **)*(v347 - 1);
          v384 = (llvm::raw_ostream *)v1;
          goto LABEL_725;
        }
        ++v346;
        if (!--v345)
          goto LABEL_670;
      }
      v408 = "incorrect number of operands in llvm.commandline metadata";
      v412[0] = 259;
      sub_1C6249A24(v1, (llvm::Twine *)&v408);
      if (!*(_QWORD *)v1)
        goto LABEL_670;
      v384 = (llvm::raw_ostream *)v1;
      v383 = v347;
LABEL_725:
      sub_1C6249C6C(v384, v383);
    }
  }
LABEL_670:
  v349 = *(_QWORD *)(v1 + 8);
  if (!*(_BYTE *)(**(_QWORD **)v349 + 1184))
  {
    v408 = "llvm.dbg.cu";
    v412[0] = 259;
    v350 = llvm::Module::getNamedMetadata(v349, (uint64_t)&v408);
    v408 = v412;
    v409 = (uint64_t)v412;
    v410 = 2;
    v411 = 0;
    if (v350)
    {
      v351 = v350;
      v352 = *(unsigned int *)(*(_QWORD *)(v350 + 48) + 8);
      if ((_DWORD)v352)
      {
        v353 = 0;
        v354 = 8 * v352;
        do
        {
          sub_1C4774094((llvm::SmallPtrSetImplBase *)&v408, *(_QWORD *)(**(_QWORD **)(v351 + 48) + v353));
          v353 += 8;
        }
        while (v354 != v353);
      }
    }
    v355 = *(char **)(v1 + 752);
    v356 = *(char **)(v1 + 744);
    v357 = 760;
    if (v355 == v356)
      v357 = 764;
    v358 = *(unsigned int *)(v1 + v357);
    v359 = *(uint64_t ****)(v1 + 752);
    if ((_DWORD)v358)
    {
      v360 = 0;
      while (*(_QWORD *)&v355[v360] >= 0xFFFFFFFFFFFFFFFELL)
      {
        v360 += 8;
        if (8 * v358 == v360)
          goto LABEL_693;
      }
      v359 = (uint64_t ***)&v355[v360];
    }
    v361 = (uint64_t ***)&v355[8 * v358];
    if (v359 == v361)
    {
LABEL_693:
      if (v355 != v356)
      {
        v379 = *(unsigned int *)(v1 + 760);
        if (v379 >= 0x21 && 4 * (*(_DWORD *)(v1 + 764) - *(_DWORD *)(v1 + 768)) < v379)
        {
          free(v355);
          v385 = *(_DWORD *)(v1 + 764) - *(_DWORD *)(v1 + 768);
          v386 = 1 << (33 - __clz(v385 - 1));
          if (v385 <= 0x10)
            v387 = 32;
          else
            v387 = v386;
          *(_DWORD *)(v1 + 760) = v387;
          *(_QWORD *)(v1 + 764) = 0;
          v388 = malloc_type_malloc(8 * v387, 0x4065EBACuLL);
          if (!v388)
            llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
          *(_QWORD *)(v1 + 752) = v388;
          memset(v388, 255, 8 * *(unsigned int *)(v1 + 760));
          goto LABEL_695;
        }
        memset(v355, 255, 8 * v379);
      }
      *(_QWORD *)(v1 + 764) = 0;
      goto LABEL_695;
    }
    v362 = *v359;
LABEL_685:
    v363 = sub_1C477672C((uint64_t)&v408, (uint64_t)v362);
    if ((void *)v409 == v408)
      v364 = (uint64_t *)((char *)&v410 + 4);
    else
      v364 = &v410;
    if (v363 != (_QWORD *)(v409 + 8 * *(unsigned int *)v364))
    {
      while (++v359 != v361)
      {
        v362 = *v359;
        if ((unint64_t)*v359 < 0xFFFFFFFFFFFFFFFELL)
          goto LABEL_685;
      }
      v355 = *(char **)(v1 + 752);
      v356 = *(char **)(v1 + 744);
      goto LABEL_693;
    }
    __p[0] = "DICompileUnit not listed in llvm.dbg.cu";
    v407 = 259;
    sub_1C6249CD4(v1, (llvm::Twine *)__p);
    if (*(_QWORD *)v1)
      sub_1C6249C6C((llvm::raw_ostream *)v1, v362);
LABEL_695:
    if ((void *)v409 != v408)
      free((void *)v409);
  }
  v365 = *(unsigned int *)(v1 + 1200);
  if (v365 >= 2)
  {
    v366 = *(uint64_t **)(v1 + 1192);
    v369 = *v366;
    v367 = v366 + 1;
    v368 = v369;
    v370 = *(_WORD *)(v369 + 18);
    v371 = 8 * v365 - 8;
    while (1)
    {
      v372 = *v367;
      if (((*(_WORD *)(*v367 + 18) ^ v370) & 0x3FF0) != 0)
        break;
      ++v367;
      v371 -= 8;
      if (!v371)
        goto LABEL_701;
    }
    v408 = "All llvm.experimental.deoptimize declarations must have the same calling convention";
    v412[0] = 259;
    sub_1C6249A24(v1, (llvm::Twine *)&v408);
    if (*(_QWORD *)v1)
    {
      if (v368)
        sub_1C6249A88((llvm::raw_ostream **)v1, v368);
      sub_1C6249A88((llvm::raw_ostream **)v1, v372);
    }
  }
LABEL_701:
  v373 = (_QWORD *)(v1 + 720);
  v374 = *(_DWORD *)(v1 + 728);
  if (!v374)
  {
    if (!*(_DWORD *)(v1 + 732))
      return *(_BYTE *)(v1 + 192) == 0;
    v375 = *(_DWORD *)(v1 + 736);
    if (v375 <= 0x40)
    {
      v1 = (uint64_t)v402;
      if (v375)
        goto LABEL_705;
      goto LABEL_707;
    }
    v390 = 0;
    goto LABEL_743;
  }
  v375 = *(_DWORD *)(v1 + 736);
  if (v375 > 4 * v374 && v375 >= 0x41)
  {
    v389 = 1 << (33 - __clz(v374 - 1));
    if (v389 <= 64)
      v390 = 64;
    else
      v390 = v389;
LABEL_743:
    if (v390 == v375)
    {
      v1 = (uint64_t)v402;
      *((_QWORD *)v402 + 91) = 0;
      v391 = (_QWORD *)*((_QWORD *)v402 + 90);
      v392 = 16 * v375;
      do
      {
        *v391 = -4096;
        v391 += 2;
        v392 -= 16;
      }
      while (v392);
    }
    else
    {
      MEMORY[0x1CAA32FB4](*v373, 8);
      if (v390)
      {
        v393 = (4 * v390 / 3u + 1) | ((unint64_t)(4 * v390 / 3u + 1) >> 1);
        v394 = v393 | (v393 >> 2) | ((v393 | (v393 >> 2)) >> 4);
        LODWORD(v394) = (((v394 | (v394 >> 8)) >> 16) | v394 | (v394 >> 8)) + 1;
        v1 = (uint64_t)v402;
        *((_DWORD *)v402 + 184) = v394;
        v395 = operator new(16 * v394, (std::align_val_t)8uLL);
        *((_QWORD *)v402 + 90) = v395;
        *((_QWORD *)v402 + 91) = 0;
        v396 = *((unsigned int *)v402 + 184);
        if ((_DWORD)v396)
        {
          v397 = 16 * v396;
          do
          {
            *v395 = -4096;
            v395 += 2;
            v397 -= 16;
          }
          while (v397);
        }
      }
      else
      {
        *v373 = 0;
        *(_QWORD *)(v1 + 728) = 0;
        *(_DWORD *)(v1 + 736) = 0;
        v1 = (uint64_t)v402;
      }
    }
    return *(_BYTE *)(v1 + 192) == 0;
  }
  if (v375)
  {
LABEL_705:
    v376 = (_QWORD *)*v373;
    v377 = 16 * v375;
    do
    {
      *v376 = -4096;
      v376 += 2;
      v377 -= 16;
    }
    while (v377);
  }
LABEL_707:
  *(_QWORD *)(v1 + 728) = 0;
  return *(_BYTE *)(v1 + 192) == 0;
}

unint64_t llvm::TBAAVerifier::verifyTBAABaseNode(llvm::TBAAVerifier *this, llvm::Instruction *a2, const llvm::MDNode *a3, int a4)
{
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  const llvm::MDNode *v11;
  unint64_t v12;
  int v13;
  unint64_t v14;
  int v16;
  int v17;
  unsigned int v18;
  uint64_t v19;
  unsigned int v20;
  const llvm::MDNode **v21;
  const llvm::MDNode *v22;
  const llvm::MDNode **v23;
  int v24;
  BOOL v25;
  unsigned int v26;
  const llvm::MDNode **v27;
  int v28;
  const llvm::MDNode *v29;
  uint64_t v30;
  int v31;
  unsigned int v32;
  const llvm::MDNode *v33;
  const llvm::MDNode **v34;
  int v35;
  BOOL v36;
  unsigned int v37;
  llvm::raw_ostream **v38;
  llvm::Instruction *v39;
  uint64_t **v40;
  _QWORD v41[4];
  __int16 v42;

  v40 = (uint64_t **)a3;
  if (*((_DWORD *)a3 + 2) > 1u)
  {
    v6 = *((_QWORD *)this + 1);
    v7 = *((unsigned int *)this + 6);
    v8 = a3 >> 4;
    if ((_DWORD)v7)
    {
      LODWORD(v9) = (v7 - 1) & (v8 ^ (a3 >> 9));
      v10 = v6 + 16 * v9;
      v11 = *(const llvm::MDNode **)v10;
      if (*(const llvm::MDNode **)v10 == a3)
        goto LABEL_4;
      v16 = 1;
      while (v11 != (const llvm::MDNode *)-4096)
      {
        v17 = v9 + v16++;
        v9 = v17 & (v7 - 1);
        v11 = *(const llvm::MDNode **)(v6 + 16 * v9);
        if (v11 == a3)
        {
          v10 = v6 + 16 * v9;
          goto LABEL_4;
        }
      }
    }
    v10 = v6 + 16 * v7;
LABEL_4:
    if (v10 != v6 + 16 * v7)
    {
      v12 = *(_QWORD *)(v10 + 8);
      v13 = v12 & 0xFFFFFF00;
      v14 = v12 & 0xFFFFFFFF00000000;
      return v12 | v14 | v13 & 0xFFFFFF00;
    }
    v12 = llvm::TBAAVerifier::verifyTBAABaseNodeImpl(this, a2, (uint64_t **)a3, a4);
    v13 = v12 & 0xFFFFFF00;
    v14 = v12 & 0xFFFFFFFF00000000;
    v18 = *((_DWORD *)this + 6);
    if (v18)
    {
      v19 = *((_QWORD *)this + 1);
      v20 = (v18 - 1) & (v8 ^ (a3 >> 9));
      v21 = (const llvm::MDNode **)(v19 + 16 * v20);
      v22 = *v21;
      if (*v21 == a3)
        return v12 | v14 | v13 & 0xFFFFFF00;
      v23 = 0;
      v24 = 1;
      while (v22 != (const llvm::MDNode *)-4096)
      {
        if (v23)
          v25 = 0;
        else
          v25 = v22 == (const llvm::MDNode *)-8192;
        if (v25)
          v23 = v21;
        v26 = v20 + v24++;
        v20 = v26 & (v18 - 1);
        v21 = (const llvm::MDNode **)(v19 + 16 * v20);
        v22 = *v21;
        if (*v21 == a3)
          return v12 | v14 | v13 & 0xFFFFFF00;
      }
      if (v23)
        v27 = v23;
      else
        v27 = v21;
    }
    else
    {
      v27 = 0;
    }
    v28 = *((_DWORD *)this + 4);
    if (4 * v28 + 4 >= 3 * v18)
    {
      sub_1C545B93C((uint64_t)this + 8, 2 * v18);
      v30 = *((_QWORD *)this + 1);
      v31 = *((_DWORD *)this + 6) - 1;
      v32 = v31 & (v8 ^ (a3 >> 9));
      v27 = (const llvm::MDNode **)(v30 + 16 * v32);
      v33 = *v27;
      if (*v27 == a3)
      {
LABEL_34:
        v29 = a3;
        goto LABEL_30;
      }
      v34 = 0;
      v35 = 1;
      while (v33 != (const llvm::MDNode *)-4096)
      {
        if (v34)
          v36 = 0;
        else
          v36 = v33 == (const llvm::MDNode *)-8192;
        if (v36)
          v34 = v27;
        v37 = v32 + v35++;
        v32 = v37 & v31;
        v27 = (const llvm::MDNode **)(v30 + 16 * (v37 & v31));
        v33 = *v27;
        if (*v27 == a3)
          goto LABEL_34;
      }
      if (v34)
        v27 = v34;
    }
    else if (v18 + ~v28 - *((_DWORD *)this + 5) <= v18 >> 3)
    {
      sub_1C545B93C((uint64_t)this + 8, v18);
      v41[0] = 0;
      sub_1C504C9E8(*((_QWORD *)this + 1), *((_DWORD *)this + 6), (uint64_t)a3, v41);
      v27 = (const llvm::MDNode **)v41[0];
    }
    v29 = *v27;
LABEL_30:
    ++*((_DWORD *)this + 4);
    if (v29 != (const llvm::MDNode *)-4096)
      --*((_DWORD *)this + 5);
    *v27 = a3;
    v27[1] = (const llvm::MDNode *)v12;
    return v12 | v14 | v13 & 0xFFFFFF00;
  }
  v39 = a2;
  v38 = *(llvm::raw_ostream ***)this;
  if (*(_QWORD *)this)
  {
    v41[0] = "Base nodes must have at least two operands";
    v42 = 259;
    sub_1C6249964(v38, (llvm::Twine *)v41, (uint64_t *)&v39, &v40);
  }
  v13 = 0;
  v14 = 0xFFFFFFFF00000000;
  LOBYTE(v12) = 1;
  return v12 | v14 | v13 & 0xFFFFFF00;
}

unint64_t llvm::TBAAVerifier::verifyTBAABaseNodeImpl(llvm::TBAAVerifier *this, llvm::Instruction *a2, uint64_t **a3, int a4)
{
  uint64_t v4;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t *v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t **v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  llvm::raw_ostream **v20;
  const char *v21;
  uint64_t v22;
  llvm::raw_ostream **v23;
  void *v24;
  uint64_t *v25;
  llvm::raw_ostream **v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  void *v34;
  const void *v35;
  void *v36;
  llvm::raw_ostream **v37;
  llvm::raw_ostream *v39;
  char *v40;
  llvm::Instruction *v41;
  void *__dst;
  unsigned int v43;
  char v44;
  uint64_t **v45;
  _QWORD v46[4];
  __int16 v47;

  v45 = a3;
  v7 = *((unsigned int *)a3 + 2);
  if ((_DWORD)v7 == 2)
  {
    v8 = !llvm::TBAAVerifier::isValidScalarTBAANode(this, (const llvm::MDNode *)a3);
    v9 = (v8 << 31 >> 31);
    return v8 & 1 | (unint64_t)(v9 << 32);
  }
  if (!a4)
  {
    if ((v7 & 1) != 0)
    {
      if (!*(_BYTE *)a3[-v7])
      {
        v14 = 1;
        v13 = 2;
        goto LABEL_12;
      }
      v39 = *(llvm::raw_ostream **)this;
      v40 = "Struct tag nodes have a string as their first operand";
    }
    else
    {
      v39 = *(llvm::raw_ostream **)this;
      v40 = "Struct tag nodes must have an odd number of operands!";
    }
    sub_1C62493C8(v39, v40, &v45);
LABEL_62:
    v9 = 0xFFFFFFFFLL;
    LOBYTE(v8) = 1;
    return v8 & 1 | (unint64_t)(v9 << 32);
  }
  if ((-1431655765 * v7) >= 0x55555556)
  {
    sub_1C6249364(*(llvm::raw_ostream **)this, &v45);
    goto LABEL_62;
  }
  v12 = a3[-v7 + 1];
  if (!v12 || *(_BYTE *)v12 != 1 || *(_BYTE *)(v12[16] + 16) != 16)
  {
    __dst = a2;
    v37 = *(llvm::raw_ostream ***)this;
    if (*(_QWORD *)this)
    {
      v46[0] = "Type size nodes must be constants!";
      v47 = 259;
      sub_1C6249964(v37, (llvm::Twine *)v46, (uint64_t *)&__dst, &v45);
    }
    goto LABEL_62;
  }
  v13 = 3;
  v14 = 3;
LABEL_12:
  LOBYTE(__dst) = 0;
  v44 = 0;
  if (v14 >= v7)
  {
    LOBYTE(v8) = 0;
    v9 = 0xFFFFFFFFLL;
    return v8 & 1 | (unint64_t)(v9 << 32);
  }
  LOBYTE(v8) = 0;
  v15 = -1;
  do
  {
    v16 = &a3[-v7];
    if (*(unsigned __int8 *)v16[v14] - 4 >= 0x1F)
    {
      v41 = a2;
      v20 = *(llvm::raw_ostream ***)this;
      if (*(_QWORD *)this)
      {
        v21 = "Incorrect field entry in struct type node!";
        goto LABEL_49;
      }
      goto LABEL_25;
    }
    v17 = v16[v14 + 1];
    if (!v17 || *(_BYTE *)v17 != 1 || (v18 = v17[16], *(_BYTE *)(v18 + 16) != 16))
    {
      v41 = a2;
      v20 = *(llvm::raw_ostream ***)this;
      if (*(_QWORD *)this)
      {
        v21 = "Offset entries must be constants!";
        goto LABEL_49;
      }
LABEL_25:
      LOBYTE(v8) = 1;
      goto LABEL_26;
    }
    v19 = *(unsigned int *)(v18 + 32);
    if (v15 != -1 && (_DWORD)v19 != v15)
    {
      v41 = a2;
      v20 = *(llvm::raw_ostream ***)this;
      if (*(_QWORD *)this)
      {
        v21 = "Bitwidth between the offsets and struct type entries must match";
LABEL_49:
        v46[0] = v21;
        v47 = 259;
        v27 = v4;
        sub_1C6249964(v20, (llvm::Twine *)v46, (uint64_t *)&v41, &v45);
        v4 = v27;
        goto LABEL_25;
      }
      goto LABEL_25;
    }
    if (!v44)
    {
      v43 = *(_DWORD *)(v18 + 32);
      if (v19 > 0x40)
      {
        v34 = (void *)operator new[]();
        v35 = *(const void **)(v18 + 24);
        v36 = v34;
        memcpy(v34, v35, ((unint64_t)(v19 + 63) >> 3) & 0x3FFFFFF8);
        v24 = v36;
      }
      else
      {
        v24 = *(void **)(v18 + 24);
      }
      __dst = v24;
      v44 = 1;
      v4 = v19;
      goto LABEL_40;
    }
    if (v4 > 0x40)
    {
      v30 = (((unint64_t)v4 + 63) >> 3) & 0x3FFFFFF8;
      while (v30)
      {
        v31 = *(_QWORD *)((char *)__dst + v30 - 8);
        v32 = *(_QWORD *)(*(_QWORD *)(v18 + 24) - 8 + v30);
        v30 -= 8;
        if (v31 != v32)
        {
          v22 = *(unsigned int *)(v18 + 32);
          if (v31 <= v32)
            goto LABEL_34;
          goto LABEL_31;
        }
      }
      goto LABEL_33;
    }
    v22 = *(unsigned int *)(v18 + 32);
    if ((unint64_t)__dst <= *(_QWORD *)(v18 + 24))
      goto LABEL_35;
LABEL_31:
    v41 = a2;
    v23 = *(llvm::raw_ostream ***)this;
    if (!*(_QWORD *)this)
    {
      LOBYTE(v8) = 1;
LABEL_33:
      v22 = v19;
      goto LABEL_34;
    }
    v46[0] = "Offsets must be increasing!";
    v47 = 259;
    v29 = v4;
    sub_1C6249964(v23, (llvm::Twine *)v46, (uint64_t *)&v41, &v45);
    LODWORD(v4) = v29;
    v22 = *(unsigned int *)(v18 + 32);
    LOBYTE(v8) = 1;
LABEL_34:
    if (v4 > 0x40)
      goto LABEL_56;
LABEL_35:
    if (v22 > 0x40)
    {
LABEL_56:
      llvm::APInt::reallocate((uint64_t)&__dst, v22);
      v4 = v43;
      if (v43 <= 0x40)
      {
        __dst = *(void **)(v18 + 24);
      }
      else
      {
        v33 = v43;
        memcpy(__dst, *(const void **)(v18 + 24), (((unint64_t)v43 + 63) >> 3) & 0x3FFFFFF8);
        v4 = v33;
      }
      goto LABEL_40;
    }
    __dst = *(void **)(v18 + 24);
    v43 = v22;
    v4 = v22;
LABEL_40:
    if (a4)
    {
      v25 = (&a3[v14 + 2])[-*((unsigned int *)a3 + 2)];
      if (!v25 || *(_BYTE *)v25 != 1 || *(_BYTE *)(v25[16] + 16) != 16)
      {
        v41 = a2;
        v26 = *(llvm::raw_ostream ***)this;
        if (*(_QWORD *)this)
        {
          v46[0] = "Member size entries must be constants!";
          v47 = 259;
          v28 = v4;
          sub_1C6249964(v26, (llvm::Twine *)v46, (uint64_t *)&v41, &v45);
          v4 = v28;
        }
        LOBYTE(v8) = 1;
      }
    }
    v15 = v19;
LABEL_26:
    v14 += v13;
    LODWORD(v7) = *((_DWORD *)a3 + 2);
  }
  while (v14 < v7);
  if ((v8 & 1) != 0)
    v9 = 0xFFFFFFFFLL;
  else
    v9 = v15;
  if (v44 && v4 > 0x40 && __dst)
    MEMORY[0x1CAA32F9C](__dst, 0x1000C8000313F17);
  return v8 & 1 | (unint64_t)(v9 << 32);
}

BOOL llvm::TBAAVerifier::isValidScalarTBAANode(llvm::TBAAVerifier *this, const llvm::MDNode *a2)
{
  uint64_t v4;
  char *v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  const llvm::MDNode *v10;
  uint64_t v11;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  llvm::APInt *v19;
  unsigned int v20;
  char v21;
  unsigned int v22;
  uint64_t v23;
  unsigned int v24;
  const llvm::MDNode **v25;
  const llvm::MDNode *v26;
  const llvm::MDNode **v27;
  int v28;
  BOOL v29;
  unsigned int v30;
  const llvm::MDNode **v31;
  int v32;
  const llvm::MDNode *v33;
  uint64_t v34;
  int v35;
  unsigned int v36;
  const llvm::MDNode *v37;
  const llvm::MDNode **v38;
  int v39;
  BOOL v40;
  unsigned int v41;
  _BYTE *v42;
  _BYTE *v43;
  uint64_t v44;
  int v45;
  _BYTE v46[32];
  const llvm::MDNode **v47;

  v5 = (char *)this + 32;
  v4 = *((_QWORD *)this + 4);
  v6 = *((unsigned int *)this + 12);
  v7 = a2 >> 4;
  if ((_DWORD)v6)
  {
    LODWORD(v8) = (v6 - 1) & (v7 ^ (a2 >> 9));
    v9 = v4 + 16 * v8;
    v10 = *(const llvm::MDNode **)v9;
    if (*(const llvm::MDNode **)v9 == a2)
      goto LABEL_3;
    v13 = 1;
    while (v10 != (const llvm::MDNode *)-4096)
    {
      v14 = v8 + v13++;
      v8 = v14 & (v6 - 1);
      v10 = *(const llvm::MDNode **)(v4 + 16 * v8);
      if (v10 == a2)
      {
        v9 = v4 + 16 * v8;
        goto LABEL_3;
      }
    }
  }
  v9 = v4 + 16 * v6;
LABEL_3:
  if (v9 != v4 + 16 * v6)
    return *(_BYTE *)(v9 + 8) != 0;
  v42 = v46;
  v43 = v46;
  v44 = 4;
  v45 = 0;
  v15 = *((unsigned int *)a2 + 2);
  v11 = (uint64_t)a2;
  while ((v15 & 0xFFFFFFFE) == 2)
  {
    v16 = v11 - 8 * v15;
    if (**(_BYTE **)v16)
      break;
    if (v15 == 3)
    {
      v17 = *(_QWORD *)(v16 + 16);
      if (*(_BYTE *)v17 != 1)
        break;
      v18 = *(_QWORD *)(v17 + 128);
      if (*(_BYTE *)(v18 + 16) != 16)
        break;
      v19 = (llvm::APInt *)(v18 + 24);
      v20 = *(_DWORD *)(v18 + 32);
      if (v20 > 0x40)
      {
        if (llvm::APInt::countLeadingZerosSlowCase(v19) != v20)
          break;
      }
      else if (*(_QWORD *)v19)
      {
        break;
      }
    }
    v11 = *(_QWORD *)(v16 + 8);
    if (!v11)
      goto LABEL_27;
    if (*(unsigned __int8 *)v11 - 4 > 0x1E)
      break;
    sub_1C4774094((llvm::SmallPtrSetImplBase *)&v42, v11);
    if (!v21)
      break;
    v15 = *(unsigned int *)(v11 + 8);
    if (v15 <= 1)
    {
      v11 = 1;
      goto LABEL_27;
    }
  }
  v11 = 0;
LABEL_27:
  v22 = *((_DWORD *)this + 12);
  if (!v22)
  {
    v31 = 0;
    goto LABEL_43;
  }
  v23 = *((_QWORD *)this + 4);
  v24 = (v22 - 1) & (v7 ^ (a2 >> 9));
  v25 = (const llvm::MDNode **)(v23 + 16 * v24);
  v26 = *v25;
  if (*v25 != a2)
  {
    v27 = 0;
    v28 = 1;
    while (v26 != (const llvm::MDNode *)-4096)
    {
      if (v27)
        v29 = 0;
      else
        v29 = v26 == (const llvm::MDNode *)-8192;
      if (v29)
        v27 = v25;
      v30 = v24 + v28++;
      v24 = v30 & (v22 - 1);
      v25 = (const llvm::MDNode **)(v23 + 16 * v24);
      v26 = *v25;
      if (*v25 == a2)
        goto LABEL_29;
    }
    if (v27)
      v31 = v27;
    else
      v31 = v25;
LABEL_43:
    v32 = *((_DWORD *)this + 10);
    if (4 * v32 + 4 >= 3 * v22)
    {
      sub_1C545BAA0((uint64_t)v5, 2 * v22);
      v34 = *((_QWORD *)this + 4);
      v35 = *((_DWORD *)this + 12) - 1;
      v36 = v35 & (v7 ^ (a2 >> 9));
      v31 = (const llvm::MDNode **)(v34 + 16 * v36);
      v37 = *v31;
      if (*v31 == a2)
      {
LABEL_51:
        v33 = a2;
        goto LABEL_47;
      }
      v38 = 0;
      v39 = 1;
      while (v37 != (const llvm::MDNode *)-4096)
      {
        if (v38)
          v40 = 0;
        else
          v40 = v37 == (const llvm::MDNode *)-8192;
        if (v40)
          v38 = v31;
        v41 = v36 + v39++;
        v36 = v41 & v35;
        v31 = (const llvm::MDNode **)(v34 + 16 * (v41 & v35));
        v37 = *v31;
        if (*v31 == a2)
          goto LABEL_51;
      }
      if (v38)
        v31 = v38;
    }
    else if (v22 + ~v32 - *((_DWORD *)this + 11) <= v22 >> 3)
    {
      sub_1C545BAA0((uint64_t)v5, v22);
      v47 = 0;
      sub_1C504C9E8(*((_QWORD *)this + 4), *((_DWORD *)this + 12), (uint64_t)a2, &v47);
      v31 = v47;
    }
    v33 = *v31;
LABEL_47:
    ++*((_DWORD *)this + 10);
    if (v33 != (const llvm::MDNode *)-4096)
      --*((_DWORD *)this + 11);
    *v31 = a2;
    *((_BYTE *)v31 + 8) = v11;
  }
LABEL_29:
  if (v43 != v42)
    free(v43);
  return v11;
}

uint64_t *llvm::TBAAVerifier::getFieldNodeFromTBAABaseNode(llvm::raw_ostream ***this, llvm::Instruction *a2, uint64_t **a3, unint64_t **a4, int a5)
{
  uint64_t v5;
  unsigned int v7;
  int v8;
  uint64_t **v9;
  unint64_t *v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t *v31;
  unint64_t *v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  _BOOL4 v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t *v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  _BOOL4 v45;
  unint64_t v46;
  unint64_t **v47;
  llvm::Instruction *v48;
  uint64_t **v49;

  v49 = a3;
  v5 = *((unsigned int *)a3 + 2);
  if ((_DWORD)v5 == 2)
    return *(a3 - 1);
  if (a5)
    v7 = 3;
  else
    v7 = 1;
  if (a5)
    v8 = 3;
  else
    v8 = 2;
  if (v7 >= v5)
  {
LABEL_20:
    v20 = v5 - v8;
    v21 = (&a3[(v5 - v8 + 1)])[-v5][16];
    v22 = *((unsigned int *)a4 + 2);
    if (v22 >= 0x41)
    {
      v30 = 0;
      v31 = *a4;
      v32 = *(unint64_t **)(v21 + 24);
      v33 = (unint64_t)(v22 + 63) >> 6;
      v34 = v33;
      do
      {
        v35 = *v32++;
        v36 = *v31 - v35;
        v37 = *v31 < v35;
        v38 = *v31 + ~v35;
        if (v30)
        {
          v30 = v38 >= *v31;
        }
        else
        {
          v38 = v36;
          v30 = v37;
        }
        *v31++ = v38;
        --v34;
      }
      while (v34);
      (*a4)[(v33 - 1)] &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v22;
    }
    else
    {
      v23 = (uint64_t)*a4 - *(_QWORD *)(v21 + 24);
      if ((_DWORD)v22)
        v24 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v22;
      else
        v24 = 0;
      *a4 = (unint64_t *)(v24 & v23);
    }
    return (&a3[v20])[-*((unsigned int *)a3 + 2)];
  }
  v9 = &a3[-v5];
  v10 = *a4;
  v11 = v7;
  while (1)
  {
    v12 = v9[v11 + 1][16];
    v13 = *(unsigned int *)(v12 + 32);
    if (v13 > 0x40)
    {
      v15 = *(_QWORD *)(v12 + 24);
      v16 = ((unint64_t)(v13 + 63) >> 3) & 0x3FFFFFF8;
      v17 = v15 - 8;
      while (v16)
      {
        v18 = *(_QWORD *)(v17 + v16);
        v19 = *(unint64_t *)((char *)*a4 + v16 - 8);
        v16 -= 8;
        v14 = v18 > v19;
        if (v18 != v19)
          goto LABEL_13;
      }
      goto LABEL_14;
    }
    v14 = *(_QWORD *)(v12 + 24) > (unint64_t)v10;
LABEL_13:
    if (v14)
      break;
LABEL_14:
    v11 += v8;
    if (v11 >= v5)
      goto LABEL_20;
  }
  if (v11 == v7)
  {
    v47 = a4;
    v48 = a2;
    sub_1C6249438(*this, (uint64_t *)&v48, &v49, (llvm::APInt **)&v47);
    return 0;
  }
  else
  {
    v25 = v11 - v8;
    v26 = v9[v11 - v8 + 1][16];
    v27 = *((unsigned int *)a4 + 2);
    if (v27 >= 0x41)
    {
      v39 = 0;
      v40 = *(unint64_t **)(v26 + 24);
      v41 = (unint64_t)(v27 + 63) >> 6;
      v42 = v41;
      do
      {
        v43 = *v40++;
        v44 = *v10 - v43;
        v45 = *v10 < v43;
        v46 = *v10 + ~v43;
        if (v39)
        {
          v39 = v46 >= *v10;
        }
        else
        {
          v46 = v44;
          v39 = v45;
        }
        *v10++ = v46;
        --v42;
      }
      while (v42);
      (*a4)[(v41 - 1)] &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v27;
    }
    else
    {
      v28 = (unint64_t)v10 - *(_QWORD *)(v26 + 24);
      if ((_DWORD)v27)
        v29 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v27;
      else
        v29 = 0;
      *a4 = (unint64_t *)(v29 & v28);
    }
    return (&a3[v25])[-*((unsigned int *)a3 + 2)];
  }
}

BOOL llvm::TBAAVerifier::visitTBAAMetadata(llvm::raw_ostream ***this, llvm::Instruction *a2, const llvm::MDNode *a3)
{
  unsigned int v5;
  BOOL v6;
  int v7;
  uint64_t v10;
  uint64_t **v11;
  uint64_t *FieldNodeFromTBAABaseNode;
  llvm::raw_ostream **v14;
  const char *v15;
  uint64_t **v16;
  uint64_t v17;
  uint64_t *v18;
  unsigned __int8 *v19;
  unsigned int v20;
  int v21;
  unsigned __int8 *v22;
  uint64_t v23;
  llvm::APInt *v24;
  unsigned int v25;
  llvm::raw_ostream **v26;
  const char *v27;
  int v28;
  uint64_t v30;
  llvm::raw_ostream **v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  _BOOL8 v36;
  size_t v38;
  int v39;
  char v40;
  unint64_t v41;
  unint64_t v42;
  _BOOL4 v43;
  unint64_t *v44;
  int v45;
  int64_t v46;
  unint64_t v47;
  unsigned int v48;
  unint64_t v49;
  char v50;
  unint64_t *v51;
  int v52;
  int64_t v53;
  unint64_t v54;
  unsigned int v55;
  llvm::raw_ostream **v56;
  const char *v57;
  llvm::raw_ostream **v58;
  unsigned int v59;
  unint64_t **v60;
  const char *v61;
  char *v62;
  uint64_t v63;
  int v64;
  _WORD v65[16];
  unint64_t *v66;
  unsigned int v67;
  uint64_t **v68;
  llvm::Metadata *v69;
  uint64_t v70[4];
  __int16 v71;

  v69 = a3;
  v5 = *((unsigned __int8 *)a2 + 16) - 60;
  v6 = v5 > 0x1C;
  v7 = (1 << v5) & 0x11000033;
  if (v6 || v7 == 0)
  {
    v14 = *this;
    if (!*this)
      return 0;
    v15 = "This instruction shall not have a TBAA access tag!";
    goto LABEL_15;
  }
  v10 = *((unsigned int *)a3 + 2);
  v11 = (uint64_t **)((char *)a3 - 8 * v10);
  FieldNodeFromTBAABaseNode = *v11;
  if (v10 < 3 || *(unsigned __int8 *)*v11 - 4 >= 0x1F)
  {
    v14 = *this;
    if (!*this)
      return 0;
    v15 = "Old-style TBAA is no longer allowed, use struct-path TBAA instead";
LABEL_15:
    v61 = v15;
    v65[0] = 259;
    sub_1C6249A24((uint64_t)v14, (llvm::Twine *)&v61);
    if (*v14)
      sub_1C6249A88(v14, (uint64_t)a2);
    return 0;
  }
  switch(*(_BYTE *)*v11)
  {
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 0xA:
    case 0xB:
    case 0xC:
    case 0xD:
    case 0xE:
    case 0xF:
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x13:
    case 0x14:
    case 0x15:
    case 0x16:
    case 0x17:
    case 0x18:
    case 0x19:
    case 0x1A:
    case 0x1B:
    case 0x1C:
    case 0x1D:
    case 0x1E:
    case 0x1F:
    case 0x20:
    case 0x21:
    case 0x22:
      break;
    default:
      FieldNodeFromTBAABaseNode = 0;
      break;
  }
  v68 = 0;
  v16 = (uint64_t **)v11[1];
  if (!v16)
    goto LABEL_29;
  if (*(unsigned __int8 *)v16 - 4 > 0x1E)
  {
    v16 = 0;
LABEL_29:
    if (v10 >= 5)
    {
      v70[0] = (uint64_t)a2;
      v26 = *this;
      if (*this)
      {
        v27 = "Struct tag metadata must have either 3 or 4 operands";
        goto LABEL_68;
      }
      return 0;
    }
    v21 = 0;
    v20 = 3;
    goto LABEL_31;
  }
  v68 = (uint64_t **)v11[1];
  v17 = *((unsigned int *)v16 + 2);
  if (v17 < 3)
    goto LABEL_29;
  v18 = v16[-v17];
  if (!v18 || *(unsigned __int8 *)v18 - 4 > 0x1E)
    goto LABEL_29;
  if ((v10 & 0xFFFFFFFE) != 4)
  {
    v70[0] = (uint64_t)a2;
    v26 = *this;
    if (*this)
    {
      v27 = "Access tag metadata must have either 4 or 5 operands";
      goto LABEL_68;
    }
    return 0;
  }
  v19 = (unsigned __int8 *)v11[3];
  if (!v19 || *v19 != 1 || *(_BYTE *)(*((_QWORD *)v19 + 16) + 16) != 16)
  {
    v70[0] = (uint64_t)a2;
    v26 = *this;
    if (*this)
    {
      v27 = "Access size field must be a constant";
      goto LABEL_68;
    }
    return 0;
  }
  v20 = 4;
  v21 = 1;
LABEL_31:
  if ((_DWORD)v10 == v20 + 1)
  {
    v22 = (unsigned __int8 *)v11[v20];
    if (!v22 || *v22 != 1 || (v23 = *((_QWORD *)v22 + 16), *(_BYTE *)(v23 + 16) != 16))
    {
      v70[0] = (uint64_t)a2;
      v26 = *this;
      if (*this)
      {
        v27 = "Immutability tag on struct tag metadata must be a constant";
        goto LABEL_68;
      }
      return 0;
    }
    v24 = (llvm::APInt *)(v23 + 24);
    v25 = *(_DWORD *)(v23 + 32);
    if (v25 > 0x40)
    {
      v28 = llvm::APInt::countLeadingZerosSlowCase(v24);
      if (v28 != v25 && v28 != v25 - 1)
      {
LABEL_37:
        v70[0] = (uint64_t)a2;
        v26 = *this;
        if (*this)
        {
          v27 = "Immutability part of the struct tag metadata must be either 0 or 1";
LABEL_68:
          v61 = v27;
          v65[0] = 259;
          sub_1C6249964(v26, (llvm::Twine *)&v61, v70, (uint64_t ***)&v69);
          return 0;
        }
        return 0;
      }
    }
    else if (*(_QWORD *)v24 >= 2uLL)
    {
      goto LABEL_37;
    }
  }
  if (!FieldNodeFromTBAABaseNode || !v16)
  {
    v31 = *this;
    if (v31)
    {
      v61 = "Malformed struct tag metadata: base and access-type should be non-null and point to Metadata nodes";
      v65[0] = 259;
      sub_1C6249A24((uint64_t)v31, (llvm::Twine *)&v61);
      if (*v31)
      {
        sub_1C6249A88(v31, (uint64_t)a2);
        sub_1C6249C6C((llvm::raw_ostream *)v31, (uint64_t **)a3);
        sub_1C6249C6C((llvm::raw_ostream *)v31, (uint64_t **)FieldNodeFromTBAABaseNode);
        sub_1C6249C6C((llvm::raw_ostream *)v31, v16);
      }
    }
    return 0;
  }
  if ((v21 & 1) != 0)
  {
    v30 = -v10;
  }
  else
  {
    if (!llvm::TBAAVerifier::isValidScalarTBAANode((llvm::TBAAVerifier *)this, (const llvm::MDNode *)v16))
    {
      v61 = (const char *)a2;
      sub_1C62494B4(*this, (uint64_t *)&v61, (uint64_t ***)&v69, &v68);
      return 0;
    }
    v30 = -(uint64_t)*((unsigned int *)a3 + 2);
  }
  v32 = *((_QWORD *)a3 + v30 + 2);
  if (!v32 || *(_BYTE *)v32 != 1 || (v33 = *(_QWORD *)(v32 + 128), *(_BYTE *)(v33 + 16) != 16))
  {
    v70[0] = (uint64_t)a2;
    v26 = *this;
    if (*this)
    {
      v27 = "Offset must be constant integer";
      goto LABEL_68;
    }
    return 0;
  }
  v34 = *(unsigned int *)(v33 + 32);
  v67 = v34;
  if (v34 > 0x40)
  {
    v38 = ((unint64_t)(v34 + 63) >> 3) & 0x3FFFFFF8;
    v35 = (void *)operator new[]();
    memcpy(v35, *(const void **)(v33 + 24), v38);
  }
  else
  {
    v35 = *(void **)(v33 + 24);
  }
  v39 = 0;
  v66 = (unint64_t *)v35;
  v61 = (const char *)v65;
  v62 = (char *)v65;
  v63 = 4;
  v64 = 0;
  while (1)
  {
    if (*((_DWORD *)FieldNodeFromTBAABaseNode + 2) < 2u)
    {
LABEL_105:
      if ((v39 & 1) != 0)
      {
        v36 = 1;
        goto LABEL_116;
      }
      v60 = (unint64_t **)a2;
      v56 = *this;
      if (!*this)
        goto LABEL_115;
      v57 = "Did not see access type in access path!";
LABEL_112:
      v70[0] = (uint64_t)v57;
      v71 = 259;
      sub_1C6249964(v56, (llvm::Twine *)v70, (uint64_t *)&v60, (uint64_t ***)&v69);
      goto LABEL_115;
    }
    sub_1C4774094((llvm::SmallPtrSetImplBase *)&v61, (uint64_t)FieldNodeFromTBAABaseNode);
    if (!v40)
    {
      v60 = (unint64_t **)a2;
      v56 = *this;
      if (!*this)
        goto LABEL_115;
      v57 = "Cycle detected in struct path";
      goto LABEL_112;
    }
    v41 = llvm::TBAAVerifier::verifyTBAABaseNode((llvm::TBAAVerifier *)this, a2, (const llvm::MDNode *)FieldNodeFromTBAABaseNode, v21);
    v36 = v41 == 0;
    if ((_BYTE)v41)
      goto LABEL_116;
    v42 = v41;
    v43 = FieldNodeFromTBAABaseNode == (uint64_t *)v68;
    if (llvm::TBAAVerifier::isValidScalarTBAANode((llvm::TBAAVerifier *)this, (const llvm::MDNode *)FieldNodeFromTBAABaseNode)|| FieldNodeFromTBAABaseNode == (uint64_t *)v68)
    {
      v44 = v66;
      if (v67 >= 0x41)
      {
        v45 = 0;
        v46 = ((unint64_t)v67 + 63) >> 6;
        do
        {
          v6 = v46-- < 1;
          if (v6)
            break;
          v47 = v66[v46];
          v45 += __clz(v47);
        }
        while (!v47);
        v48 = v67 | 0xFFFFFFC0;
        if ((v67 & 0x3F) == 0)
          v48 = 0;
        if (v67 - v45 - v48 > 0x40)
        {
LABEL_121:
          v70[0] = (uint64_t)a2;
          v60 = &v66;
          sub_1C6249530(*this, v70, (uint64_t ***)&v69, (llvm::APInt **)&v60);
          goto LABEL_115;
        }
        v44 = (unint64_t *)*v66;
      }
      if (v44)
        goto LABEL_121;
    }
    v49 = HIDWORD(v42);
    if (v67 != (_DWORD)v49)
      break;
LABEL_103:
    v39 |= v43;
    if ((v21 & v39 & 1) != 0)
      goto LABEL_116;
    FieldNodeFromTBAABaseNode = llvm::TBAAVerifier::getFieldNodeFromTBAABaseNode(this, a2, (uint64_t **)FieldNodeFromTBAABaseNode, &v66, v21);
    if (!FieldNodeFromTBAABaseNode)
      goto LABEL_105;
  }
  if ((_DWORD)v49)
  {
    if ((_DWORD)v49 == -1)
      v50 = v21;
    else
      v50 = 0;
    if ((v50 & 1) == 0)
      goto LABEL_114;
    goto LABEL_103;
  }
  v51 = v66;
  if (v67 < 0x41)
    goto LABEL_102;
  v52 = 0;
  v53 = ((unint64_t)v67 + 63) >> 6;
  do
  {
    v6 = v53-- < 1;
    if (v6)
      break;
    v54 = v66[v53];
    v52 += __clz(v54);
  }
  while (!v54);
  v55 = v67 | 0xFFFFFFC0;
  if ((v67 & 0x3F) == 0)
    v55 = 0;
  if (v67 - v52 - v55 <= 0x40)
  {
    v51 = (unint64_t *)*v66;
LABEL_102:
    if (v51)
      goto LABEL_113;
    goto LABEL_103;
  }
LABEL_113:
  LODWORD(v49) = 0;
LABEL_114:
  v58 = *this;
  if (*this)
  {
    v59 = v67;
    v70[0] = (uint64_t)"Access bit-width not the same as description bit-width";
    v71 = 259;
    sub_1C6249A24((uint64_t)v58, (llvm::Twine *)v70);
    if (*v58)
    {
      sub_1C6249A88(v58, (uint64_t)a2);
      sub_1C6249C6C((llvm::raw_ostream *)v58, (uint64_t **)v69);
      sub_1C6249EC8(*v58, v49);
      sub_1C6249EC8(*v58, v59);
    }
  }
LABEL_115:
  v36 = 0;
LABEL_116:
  if (v62 != v61)
    free(v62);
  if (v67 >= 0x41 && v66)
    MEMORY[0x1CAA32F9C](v66, 0x1000C8000313F17);
  return v36;
}

uint64_t sub_1C5447A40(uint64_t a1)
{
  uint64_t v2;

  v2 = operator new();
  *(_QWORD *)v2 = "Module Verifier";
  *(_QWORD *)(v2 + 8) = 15;
  *(_QWORD *)(v2 + 16) = "verify";
  *(_QWORD *)(v2 + 24) = 6;
  *(_QWORD *)(v2 + 32) = &unk_1EF8F7100;
  *(_WORD *)(v2 + 40) = 0;
  *(_BYTE *)(v2 + 42) = 0;
  *(_QWORD *)(v2 + 48) = 0;
  *(_QWORD *)(v2 + 56) = 0;
  *(_QWORD *)(v2 + 64) = 0;
  *(_QWORD *)(v2 + 72) = sub_1C545B5AC;
  llvm::PassRegistry::registerPass(a1, (_QWORD *)v2, 1);
  return v2;
}

void sub_1C5447AD0(uint64_t a1, llvm::GlobalValue *this)
{
  int v4;
  int v5;
  int v6;
  int v8;
  llvm::GlobalValue *v10;
  llvm::raw_ostream **v11;
  llvm::GlobalValue *v12;
  llvm::GlobalValue *AliaseeObject;
  int v14;
  char hasExternalWeakLinkage;
  char v16;
  unsigned int i;
  uint64_t v18;
  char v19;
  BOOL v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  llvm::GlobalValue *v32;
  uint64_t v33;
  _QWORD v34[4];
  __int16 v35;
  void *v36;
  uint64_t v37;
  _BYTE v38[16];
  __int16 v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v4 = *((unsigned __int8 *)this + 16);
  if (v4 == 3)
  {
    if ((*((_DWORD *)this + 5) & 0x7FFFFFF) != 0)
      goto LABEL_15;
    v6 = *((_DWORD *)this + 8);
LABEL_7:
    if ((v6 & 0xF) != 0 && (v6 & 0xF) != 9)
    {
      v29 = "Global is external, but doesn't have external or weak linkage!";
      goto LABEL_88;
    }
    goto LABEL_15;
  }
  if (!*((_BYTE *)this + 16))
  {
    if (*((llvm::GlobalValue **)this + 9) != (llvm::GlobalValue *)((char *)this + 72))
      goto LABEL_15;
    v6 = *((_DWORD *)this + 8);
    if ((v6 & 0x800000) != 0)
      goto LABEL_15;
    goto LABEL_7;
  }
  if (v4 != 2)
  {
    v5 = *((_DWORD *)this + 8);
    goto LABEL_17;
  }
LABEL_15:
  v5 = *((_DWORD *)this + 8);
  if ((v5 & 0x3F0000) != 0 && ((BYTE2(v5) & 0x3F) - 1) >= 0x21u)
  {
    v29 = "huge alignment values are unsupported";
    goto LABEL_88;
  }
LABEL_17:
  v8 = v5 & 0xF;
  if (v4 != 3 && v8 == 6)
  {
    v29 = "Only global variables can have appending linkage!";
    goto LABEL_88;
  }
  if (v8 == 1)
  {
    if (v4 == 2)
      goto LABEL_42;
    AliaseeObject = this;
    if (v4 == 1)
    {
      AliaseeObject = (llvm::GlobalValue *)llvm::GlobalAlias::getAliaseeObject(this);
      if (!AliaseeObject)
        goto LABEL_42;
    }
    goto LABEL_41;
  }
  if (v8 == 6)
  {
    if (v4 == 3)
      v10 = this;
    else
      v10 = 0;
    if (v4 != 3 || *(_BYTE *)(*((_QWORD *)this + 3) + 8) != 17)
    {
      v36 = "Only global arrays can have appending linkage!";
      v39 = 259;
      sub_1C6249A24(a1, (llvm::Twine *)&v36);
      if (v4 == 3 && *(_QWORD *)a1)
      {
        v11 = (llvm::raw_ostream **)a1;
        v12 = v10;
LABEL_91:
        sub_1C6249A88(v11, (uint64_t)v12);
        return;
      }
      return;
    }
  }
  else if (v4 != 3)
  {
    if (*((_BYTE *)this + 16))
      goto LABEL_42;
    if (*((llvm::GlobalValue **)this + 9) != (llvm::GlobalValue *)((char *)this + 72))
      goto LABEL_42;
    AliaseeObject = this;
    if ((v5 & 0x800000) != 0)
      goto LABEL_42;
    goto LABEL_41;
  }
  AliaseeObject = this;
  if ((*((_DWORD *)this + 5) & 0x7FFFFFF) != 0)
    goto LABEL_42;
LABEL_41:
  if (*((_QWORD *)AliaseeObject + 6))
  {
    v29 = "Declaration may not be in a Comdat!";
    goto LABEL_88;
  }
LABEL_42:
  v14 = *((_DWORD *)this + 8);
  if ((v14 & 0x300) != 0x100)
    goto LABEL_53;
  if ((v14 & 0x4000) != 0)
  {
    v29 = "GlobalValue with DLLImport Storage is dso_local!";
    goto LABEL_88;
  }
  if (*((_BYTE *)this + 16))
  {
    if (*((_BYTE *)this + 16) == 3 && (*((_DWORD *)this + 5) & 0x7FFFFFF) == 0)
      goto LABEL_50;
  }
  else if ((v14 & 0x800000) == 0 && *((llvm::GlobalValue **)this + 9) == (llvm::GlobalValue *)((char *)this + 72))
  {
LABEL_50:
    if ((v14 & 0xF) == 0)
      goto LABEL_53;
    hasExternalWeakLinkage = llvm::GlobalValue::hasExternalWeakLinkage(this);
    v14 = *((_DWORD *)this + 8);
    if ((hasExternalWeakLinkage & 1) != 0)
      goto LABEL_53;
  }
  if ((v14 & 0xF) != 1)
  {
    v29 = "Global is marked as dllimport, but not external";
    goto LABEL_88;
  }
LABEL_53:
  if ((v14 & 0xFu) - 7 >= 2)
  {
    if ((v14 & 0x30) == 0 || (llvm::GlobalValue::hasExternalWeakLinkage(this) & 1) != 0)
    {
LABEL_58:
      sub_1C4774094((llvm::SmallPtrSetImplBase *)(a1 + 1528), (uint64_t)this);
      if (v16)
      {
        v36 = v38;
        v37 = 0x600000000;
        sub_1C544A9D0((unsigned int *)&v36, (uint64_t)v38, *((_QWORD *)this + 1));
        for (i = v37; (_DWORD)v37; i = v37)
        {
          v18 = *((_QWORD *)v36 + i - 1);
          LODWORD(v37) = i - 1;
          sub_1C4774094((llvm::SmallPtrSetImplBase *)(a1 + 1528), v18);
          if (v19)
          {
            if (v18)
              v20 = *(unsigned __int8 *)(v18 + 16) >= 0x1Cu;
            else
              v20 = 0;
            if (v20)
            {
              v24 = *(_QWORD *)(v18 + 40);
              if (v24 && (v25 = *(_QWORD *)(v24 + 56)) != 0)
              {
                v26 = *(_QWORD *)(v25 + 40);
                v27 = *(_QWORD *)(a1 + 8);
                if (v26 != v27)
                {
                  v34[0] = "Global is referenced in a different module!";
                  v35 = 259;
                  sub_1C6249A24(a1, (llvm::Twine *)v34);
                  if (*(_QWORD *)a1)
                  {
                    sub_1C6249A88((llvm::raw_ostream **)a1, (uint64_t)this);
                    sub_1C6249B08(*(llvm::raw_ostream **)a1, v27);
                    sub_1C6249A88((llvm::raw_ostream **)a1, v18);
                    sub_1C6249A88((llvm::raw_ostream **)a1, v25);
                    sub_1C6249B08(*(llvm::raw_ostream **)a1, v26);
                  }
                }
              }
              else
              {
                v34[0] = "Global is referenced by parentless instruction!";
                v35 = 259;
                v28 = *(_QWORD *)(a1 + 8);
                sub_1C6249A24(a1, (llvm::Twine *)v34);
                if (*(_QWORD *)a1)
                {
                  sub_1C6249A88((llvm::raw_ostream **)a1, (uint64_t)this);
                  sub_1C6249B08(*(llvm::raw_ostream **)a1, v28);
                  sub_1C6249A88((llvm::raw_ostream **)a1, v18);
                }
              }
            }
            else
            {
              if (*(_BYTE *)(v18 + 16))
                v21 = 0;
              else
                v21 = v18;
              v33 = v21;
              if (v21)
              {
                v22 = *(_QWORD *)(v21 + 40);
                v23 = *(_QWORD *)(a1 + 8);
                if (v22 != v23)
                {
                  v34[0] = "Global is used by function in a different module";
                  v35 = 259;
                  v31 = v23;
                  v32 = this;
                  v30 = v22;
                  sub_1C62498E8((llvm::raw_ostream **)a1, (llvm::Twine *)v34, (uint64_t *)&v32, &v31, &v33, &v30);
                }
              }
              else
              {
                sub_1C544A9D0((unsigned int *)&v36, (uint64_t)v36 + 8 * v37, *(_QWORD *)(v18 + 8));
              }
            }
          }
        }
        if (v36 != v38)
          free(v36);
      }
      return;
    }
    v14 = *((_DWORD *)this + 8);
  }
  if ((v14 & 0x4000) != 0)
    goto LABEL_58;
  v29 = "GlobalValue with local linkage or non-default visibility must be dso_local!";
LABEL_88:
  v36 = v29;
  v39 = 259;
  sub_1C6249A24(a1, (llvm::Twine *)&v36);
  if (*(_QWORD *)a1)
  {
    v11 = (llvm::raw_ostream **)a1;
    v12 = this;
    goto LABEL_91;
  }
}

void sub_1C5447FA8(llvm::raw_ostream **a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, char a6)
{
  uint64_t v6;
  llvm::raw_ostream **v7;
  char v8;
  uint64_t v9;
  llvm::AttributeSetNode **v10;
  uint64_t v11;
  llvm::AttributeSetNode *v12;
  uint64_t v13;
  unsigned int **v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  unint64_t v20;
  int v21;
  int v22;
  int v23;
  llvm::Type *v24;
  _BYTE *v25;
  llvm::raw_ostream **v26;
  uint64_t v27;
  unsigned int v28;
  int v29;
  char v30;
  unsigned int v31;
  _BOOL4 v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t i;
  uint64_t v39;
  const char *v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  uint64_t v44;
  llvm::raw_ostream *v45;
  std::string *v46;
  size_t v47;
  _BYTE *v48;
  int v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  unsigned __int8 v53;
  unint64_t v54;
  unsigned int v55;
  int j;
  unsigned int v57;
  uint64_t v58;
  _QWORD *v59;
  uint64_t v61;
  int v62;
  uint64_t v63;
  unsigned __int8 v64;
  unint64_t v65;
  unsigned int v66;
  int k;
  unsigned int v68;
  uint64_t v69;
  _QWORD *v70;
  uint64_t v72;
  llvm::AttributeSetNode *v74;
  uint64_t AllocSizeArgs;
  char v76;
  char v77;
  llvm::AttributeSetNode *v78;
  unsigned int VScaleRangeMin;
  llvm::AttributeSetNode *v80;
  uint64_t VScaleRangeMax;
  std::string *v82;
  std::string::size_type v83;
  const std::string::value_type *v84;
  const char *v85;
  std::string::size_type size;
  char v87;
  BOOL v88;
  size_t v89;
  std::string *v90;
  std::string::size_type v91;
  std::string *v92;
  std::string::size_type v93;
  uint64_t v94;
  llvm::raw_ostream **v95;
  uint64_t v96;
  unint64_t v97;
  uint64_t v98;
  int v99;
  unint64_t v100;
  uint64_t v102;
  uint64_t v103;
  int v106;
  std::string v107;
  std::string v108;
  uint64_t v109;
  uint64_t *v110[2];
  uint64_t *v111;
  uint64_t v112;
  __int16 v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  std::string v117;

  v115 = a2;
  v116 = a3;
  v114 = a4;
  if (!a3)
    return;
  v6 = a3;
  v7 = a1;
  sub_1C4774094((llvm::SmallPtrSetImplBase *)(a1 + 155), a3);
  if (v8)
  {
    if (!llvm::AttributeList::hasParentContext((llvm::AttributeList *)&v116, v7[23]))
    {
      v110[0] = (uint64_t *)"Attribute list does not match Module context!";
      v113 = 259;
      sub_1C6249A24((uint64_t)v7, (llvm::Twine *)v110);
      if (!*v7)
        return;
      llvm::AttributeList::print((llvm::AttributeList *)&v116, *v7);
      goto LABEL_216;
    }
    v9 = *(unsigned int *)(v6 + 8);
    if ((_DWORD)v9)
    {
      v10 = (llvm::AttributeSetNode **)(v6 + 40);
      v11 = v6 + 40 + 8 * v9;
      while (1)
      {
        if (*v10)
        {
          if (!llvm::AttributeSet::hasParentContext((llvm::AttributeSet *)v10, v7[23]))
          {
            v110[0] = (uint64_t *)"Attribute set does not match Module context!";
            v113 = 259;
            sub_1C6249A24((uint64_t)v7, (llvm::Twine *)v110);
            v45 = *v7;
            if (!*v7)
              return;
            if (*v10)
            {
              llvm::AttributeSetNode::getAsString(*v10, 0, &v117);
              v87 = HIBYTE(v117.__r_.__value_.__r.__words[2]);
              size = v117.__r_.__value_.__l.__size_;
            }
            else
            {
              v87 = 0;
              *((_BYTE *)&v117.__r_.__value_.__s + 23) = 0;
              v117.__r_.__value_.__s.__data_[0] = 0;
            }
            v88 = v87 < 0;
            if (v87 >= 0)
              v46 = &v117;
            else
              v46 = (std::string *)v117.__r_.__value_.__r.__words[0];
            v89 = v87 & 0x7F;
            if (v88)
              v47 = size;
            else
              v47 = v89;
            goto LABEL_82;
          }
          v12 = *v10;
          if (*v10)
          {
            v13 = *((unsigned int *)v12 + 2);
            if ((_DWORD)v13)
              break;
          }
        }
LABEL_13:
        if (++v10 == (llvm::AttributeSetNode **)v11)
          goto LABEL_14;
      }
      v14 = (unsigned int **)((char *)v12 + 48);
      v15 = 8 * v13;
      while (llvm::Attribute::hasParentContext(v14, v7[23]))
      {
        ++v14;
        v15 -= 8;
        if (!v15)
          goto LABEL_13;
      }
      v110[0] = (uint64_t *)"Attribute does not match Module context!";
      v113 = 259;
      sub_1C6249A24((uint64_t)v7, (llvm::Twine *)v110);
      v45 = *v7;
      if (!*v7)
        return;
      llvm::Attribute::getAsString((llvm::Attribute *)v14, 0, &v117);
      if ((v117.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v46 = &v117;
      else
        v46 = (std::string *)v117.__r_.__value_.__r.__words[0];
      if ((v117.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v47 = *((_BYTE *)&v117.__r_.__value_.__s + 23) & 0x7F;
      else
        v47 = v117.__r_.__value_.__l.__size_;
LABEL_82:
      llvm::raw_ostream::write(v45, (const char *)v46, v47);
      v48 = (_BYTE *)*((_QWORD *)v45 + 4);
      if ((unint64_t)v48 >= *((_QWORD *)v45 + 3))
      {
        llvm::raw_ostream::write(v45, 10);
      }
      else
      {
        *((_QWORD *)v45 + 4) = v48 + 1;
        *v48 = 10;
      }
      if (SHIBYTE(v117.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v117.__r_.__value_.__l.__data_);
LABEL_216:
      v94 = v114;
      if (!v114)
        return;
      v95 = v7;
      goto LABEL_219;
    }
  }
LABEL_14:
  if (*(_DWORD *)(v6 + 8) < 2u)
  {
    v16 = 0;
    v17 = a2;
    goto LABEL_16;
  }
  v16 = *(_QWORD *)(v6 + 48);
  v17 = a2;
  if (v16)
  {
    v41 = *(unsigned int *)(v16 + 8);
    if ((_DWORD)v41)
    {
      v42 = (uint64_t *)(v16 + 48);
      v43 = 8 * v41;
      while (1)
      {
        v44 = *v42;
        v109 = v44;
        if (!v44)
          goto LABEL_72;
        if (*(_BYTE *)(v44 + 8) != 2)
          break;
LABEL_73:
        ++v42;
        v43 -= 8;
        if (!v43)
          goto LABEL_16;
      }
      LODWORD(v44) = *(_DWORD *)(v44 + 12);
LABEL_72:
      if ((byte_1C85FC5EE[(v44 - 1)] & 4) == 0)
      {
        llvm::Attribute::getAsString((llvm::Attribute *)&v109, 0, &v107);
        v90 = std::string::insert(&v107, 0, "Attribute '");
        v91 = v90->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v108.__r_.__value_.__l.__data_ = *(_OWORD *)&v90->__r_.__value_.__l.__data_;
        v108.__r_.__value_.__r.__words[2] = v91;
        v90->__r_.__value_.__l.__size_ = 0;
        v90->__r_.__value_.__r.__words[2] = 0;
        v90->__r_.__value_.__r.__words[0] = 0;
        v84 = "' does not apply to function return values";
LABEL_185:
        v92 = std::string::append(&v108, v84);
        v93 = v92->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v117.__r_.__value_.__l.__data_ = *(_OWORD *)&v92->__r_.__value_.__l.__data_;
        v117.__r_.__value_.__r.__words[2] = v93;
        v92->__r_.__value_.__l.__size_ = 0;
        v92->__r_.__value_.__r.__words[2] = 0;
        v92->__r_.__value_.__r.__words[0] = 0;
        v113 = 260;
        v110[0] = (uint64_t *)&v117;
        sub_1C6249A24((uint64_t)v7, (llvm::Twine *)v110);
        if (*v7 && v114)
          sub_1C6249A88(v7, v114);
        if (SHIBYTE(v117.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v117.__r_.__value_.__l.__data_);
        if (SHIBYTE(v108.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v108.__r_.__value_.__l.__data_);
        if (SHIBYTE(v107.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v107.__r_.__value_.__l.__data_);
        return;
      }
      goto LABEL_73;
    }
  }
LABEL_16:
  sub_1C544ABD0(v7, v16, **(_QWORD **)(v17 + 16), v114);
  v18 = *(_DWORD *)(v17 + 12);
  v19 = (v18 - 1);
  if (v18 != 1)
  {
    v20 = 0;
    v106 = 0;
    v21 = 0;
    v22 = 0;
    v23 = 0;
    v102 = 0;
    v103 = v6 + 40;
    while (1)
    {
      v24 = *(llvm::Type **)(*(_QWORD *)(v17 + 16) + 8 * v20 + 8);
      if ((v20 + 2) >= *(_DWORD *)(v6 + 8))
        break;
      v25 = *(_BYTE **)(v103 + 8 * (v20 + 2));
      if ((a5 & 1) != 0)
      {
        sub_1C544ABD0(v7, (uint64_t)v25, *(_QWORD *)(*(_QWORD *)(v17 + 16) + 8 * v20 + 8), v114);
        if (!v25)
          goto LABEL_43;
      }
      else
      {
        if (!v25)
          break;
        if ((v25[13] & 2) != 0)
        {
          v40 = "immarg attribute only applies to intrinsics";
          goto LABEL_215;
        }
        if ((a6 & 1) == 0 && (v25[20] & 0x40) != 0)
        {
          v40 = "Attribute 'elementtype' can only be applied to intrinsics and inline asm.";
          goto LABEL_215;
        }
        sub_1C544ABD0(v7, (uint64_t)v25, *(_QWORD *)(*(_QWORD *)(v17 + 16) + 8 * v20 + 8), v114);
      }
      v26 = v7;
      v27 = v6;
      v28 = v25[14] & 4;
      if ((v106 & (v28 >> 2)) == 1)
      {
        v85 = "More than one parameter has attribute nest!";
LABEL_199:
        v110[0] = (uint64_t *)v85;
        v113 = 259;
        sub_1C6249A24((uint64_t)v26, (llvm::Twine *)v110);
        if (!*v26)
          return;
        v94 = v114;
        if (!v114)
          return;
        v95 = v26;
LABEL_219:
        sub_1C6249A88(v95, v94);
        return;
      }
      if ((v25[17] & 0x40) != 0)
      {
        if ((v102 & 0x100000000) != 0)
        {
          v85 = "More than one parameter has attribute returned!";
          goto LABEL_199;
        }
        if (!llvm::Type::canLosslesslyBitCastTo(v24, **(llvm::Type ***)(a2 + 16)))
        {
          v85 = "Incompatible argument and return types for 'returned' attribute";
          goto LABEL_199;
        }
        BYTE4(v102) = 1;
      }
      if ((v25[21] & 2) != 0)
      {
        if ((v102 & 1) != 0)
        {
          v85 = "Cannot have multiple 'sret' parameters!";
          goto LABEL_199;
        }
        if (v20 >= 2)
        {
          v85 = "Attribute 'sret' is not on first or second parameter!";
          goto LABEL_199;
        }
        LOBYTE(v102) = 1;
      }
      v29 = v25[20];
      if ((v29 & v21 & 1) != 0)
      {
        v85 = "Cannot have multiple 'swiftself' parameters!";
        goto LABEL_199;
      }
      v30 = v25[19];
      v31 = v30 & 0x40;
      if ((v22 & (v31 >> 6)) == 1)
      {
        v85 = "Cannot have multiple 'swiftasync' parameters!";
        goto LABEL_199;
      }
      v32 = v30 < 0;
      if ((v32 & v23) == 1)
      {
        v85 = "Cannot have multiple 'swifterror' parameters!";
        goto LABEL_199;
      }
      v106 |= v28 >> 2;
      v21 |= v29;
      v23 |= v32;
      v22 |= v31 >> 6;
      if ((v29 & 0x80) != 0)
      {
        v6 = v27;
        v7 = v26;
        v17 = a2;
        if (v20 != *(_DWORD *)(a2 + 12) - 2)
        {
          v40 = "inalloca isn't on the last parameter!";
          goto LABEL_215;
        }
      }
      else
      {
        v6 = v27;
        v7 = v26;
        v17 = a2;
      }
LABEL_43:
      if (v19 == ++v20)
        goto LABEL_44;
    }
    sub_1C544ABD0(v7, 0, *(_QWORD *)(*(_QWORD *)(v17 + 16) + 8 * v20 + 8), v114);
    goto LABEL_43;
  }
LABEL_44:
  if (!*(_DWORD *)(v6 + 8))
    return;
  v33 = *(_QWORD *)(v6 + 40);
  if (!v33)
    return;
  sub_1C544B3B0(v7, v33, v114);
  v34 = *(_DWORD *)(v6 + 8);
  if (v34)
  {
    v35 = *(_QWORD *)(v6 + 40);
    if (v35)
    {
      v36 = *(unsigned int *)(v35 + 8);
      if ((_DWORD)v36)
      {
        v37 = (uint64_t *)(v35 + 48);
        for (i = 8 * v36; i; i -= 8)
        {
          v39 = *v37;
          v109 = v39;
          if (v39)
          {
            if (*(_BYTE *)(v39 + 8) == 2)
              goto LABEL_54;
            LODWORD(v39) = *(_DWORD *)(v39 + 12);
          }
          if ((byte_1C85FC5EE[(v39 - 1)] & 1) == 0)
          {
            llvm::Attribute::getAsString((llvm::Attribute *)&v109, 0, &v107);
            v82 = std::string::insert(&v107, 0, "Attribute '");
            v83 = v82->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v108.__r_.__value_.__l.__data_ = *(_OWORD *)&v82->__r_.__value_.__l.__data_;
            v108.__r_.__value_.__r.__words[2] = v83;
            v82->__r_.__value_.__l.__size_ = 0;
            v82->__r_.__value_.__r.__words[2] = 0;
            v82->__r_.__value_.__r.__words[0] = 0;
            v84 = "' does not apply to functions!";
            goto LABEL_185;
          }
LABEL_54:
          ++v37;
        }
      }
    }
  }
  if ((*(_BYTE *)(v6 + 17) & 0x10) != 0)
  {
    if ((*(_BYTE *)(v6 + 17) & 0x20) != 0)
    {
      v40 = "Attributes 'readnone and readonly' are incompatible!";
      goto LABEL_215;
    }
    if ((*(_BYTE *)(v6 + 20) & 4) != 0)
    {
      v40 = "Attributes 'readnone and writeonly' are incompatible!";
      goto LABEL_215;
    }
  }
  if ((*(_BYTE *)(v6 + 17) & 0x20) != 0 && (*(_BYTE *)(v6 + 20) & 4) != 0)
  {
    v40 = "Attributes 'readonly and writeonly' are incompatible!";
    goto LABEL_215;
  }
  if ((*(_BYTE *)(v6 + 17) & 0x10) != 0)
  {
    if ((*(_BYTE *)(v6 + 13) & 0x10) != 0)
    {
      v40 = "Attributes 'readnone and inaccessiblemem_or_argmemonly' are incompatible!";
      goto LABEL_215;
    }
    if ((*(_BYTE *)(v6 + 13) & 8) != 0)
    {
      v40 = "Attributes 'readnone and inaccessiblememonly' are incompatible!";
      goto LABEL_215;
    }
  }
  if ((*(_BYTE *)(v6 + 15) & 8) == 0)
  {
    if ((*(_BYTE *)(v6 + 17) & 8) != 0)
    {
      v40 = "Attribute 'optnone' requires 'noinline'!";
      goto LABEL_215;
    }
LABEL_86:
    if ((*(_BYTE *)(v6 + 13) & 0x40) == 0)
      goto LABEL_92;
    goto LABEL_91;
  }
  if ((*(_BYTE *)(v6 + 12) & 4) != 0)
  {
    v40 = "Attributes 'noinline and alwaysinline' are incompatible!";
    goto LABEL_215;
  }
  if ((*(_BYTE *)(v6 + 17) & 8) == 0)
    goto LABEL_86;
  if ((*(_BYTE *)(v6 + 17) & 4) != 0)
  {
    v40 = "Attributes 'optsize and optnone' are incompatible!";
    goto LABEL_215;
  }
  v49 = *(char *)(v6 + 13);
  if (v49 < 0)
  {
    v40 = "Attributes 'minsize and optnone' are incompatible!";
    goto LABEL_215;
  }
  if ((v49 & 0x40) != 0)
  {
LABEL_91:
    if ((*(_DWORD *)(v114 + 32) & 0xC0) == 0x80)
      goto LABEL_92;
    v40 = "Attribute 'jumptable' requires 'unnamed_addr'";
LABEL_215:
    v110[0] = (uint64_t *)v40;
    v113 = 259;
    sub_1C6249A24((uint64_t)v7, (llvm::Twine *)v110);
    if (!*v7)
      return;
    goto LABEL_216;
  }
LABEL_92:
  if ((*(_BYTE *)(v6 + 21) & 8) != 0)
  {
    if (v34 && (v74 = *(llvm::AttributeSetNode **)(v6 + 40)) != 0)
    {
      AllocSizeArgs = llvm::AttributeSetNode::getAllocSizeArgs(v74);
      v77 = v76;
    }
    else
    {
      AllocSizeArgs = 0;
      v77 = 1;
    }
    v110[0] = &v115;
    v110[1] = (uint64_t *)v7;
    v111 = &v114;
    if (!sub_1C544C430(v110, (uint64_t)"element size", 12, AllocSizeArgs)
      || v77 && !sub_1C544C430(v110, (uint64_t)"number of elements", 18, HIDWORD(AllocSizeArgs)))
    {
      return;
    }
  }
  if ((*(_BYTE *)(v6 + 22) & 1) != 0)
  {
    if (!*(_DWORD *)(v6 + 8))
      goto LABEL_213;
    v78 = *(llvm::AttributeSetNode **)(v6 + 40);
    if (!v78)
      goto LABEL_213;
    VScaleRangeMin = llvm::AttributeSetNode::getVScaleRangeMin(v78);
    if (!VScaleRangeMin)
    {
      v110[0] = (uint64_t *)"'vscale_range' minimum must be greater than 0";
      v113 = 259;
      sub_1C6249A24((uint64_t)v7, (llvm::Twine *)v110);
      if (*v7)
      {
        if (v114)
          sub_1C6249A88(v7, v114);
      }
    }
    if (!*(_DWORD *)(v6 + 8))
      goto LABEL_213;
    v80 = *(llvm::AttributeSetNode **)(v6 + 40);
    if (!v80)
      goto LABEL_213;
    VScaleRangeMax = llvm::AttributeSetNode::getVScaleRangeMax(v80);
    if ((VScaleRangeMax & 0xFF00000000) != 0 && VScaleRangeMin > VScaleRangeMax)
    {
      v110[0] = (uint64_t *)"'vscale_range' minimum cannot be greater than maximum";
      v113 = 259;
      sub_1C6249A24((uint64_t)v7, (llvm::Twine *)v110);
      if (*v7)
      {
        if (v114)
          sub_1C6249A88(v7, v114);
      }
    }
  }
  if (!*(_DWORD *)(v6 + 8))
    goto LABEL_213;
  v50 = *(_QWORD *)(v6 + 40);
  if (!v50)
    goto LABEL_213;
  v51 = *(_DWORD *)(v50 + 40);
  if (!v51)
    goto LABEL_213;
  v52 = *(_QWORD *)(v50 + 24);
  v53 = atomic_load((unsigned __int8 *)&qword_1ED7EAC88);
  if ((v53 & 1) == 0 && __cxa_guard_acquire(&qword_1ED7EAC88))
  {
    v97 = llvm::hashing::detail::fixed_seed_override;
    if (!llvm::hashing::detail::fixed_seed_override)
      v97 = 0xFF51AFD7ED558CCDLL;
    qword_1ED7EAC80 = v97;
    __cxa_guard_release(&qword_1ED7EAC88);
  }
  v54 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (qword_1ED7EAC80 ^ 0xEEA3BE4ECE12391DLL)) ^ ((0x9DDFEA08EB382D69
                                                                             * (qword_1ED7EAC80 ^ 0xEEA3BE4ECE12391DLL)) >> 47) ^ 0x81D3932BA3734B7BLL);
  v55 = (-348639895 * ((v54 >> 47) ^ v54)) ^ 0x696F702D;
  for (j = 1; ; ++j)
  {
    v57 = v55 & (v51 - 1);
    v58 = v52 + 24 * v57;
    v59 = *(_QWORD **)v58;
    if (*(_QWORD *)v58 == -1)
    {
      if ("frame-pointer" == (char *)-1)
        goto LABEL_112;
      goto LABEL_101;
    }
    if (v59 != (_QWORD *)-2)
      break;
    if ("frame-pointer" == (char *)-2)
      goto LABEL_112;
LABEL_101:
    if (v59 == (_QWORD *)-1)
      goto LABEL_213;
    v55 = j + v57;
  }
  if (*(_QWORD *)(v58 + 8) != 13)
    goto LABEL_101;
  if (*v59 != 0x6F702D656D617266 || *(_QWORD *)((char *)v59 + 5) != 0x7265746E696F702DLL)
    goto LABEL_101;
LABEL_112:
  v61 = v116;
  if (!v116)
    goto LABEL_209;
  if (!*(_DWORD *)(v116 + 8))
    goto LABEL_208;
  v61 = *(_QWORD *)(v116 + 40);
  if (!v61)
    goto LABEL_209;
  v62 = *(_DWORD *)(v61 + 40);
  if (!v62)
  {
LABEL_208:
    v61 = 0;
    goto LABEL_209;
  }
  v63 = *(_QWORD *)(v61 + 24);
  v64 = atomic_load((unsigned __int8 *)&qword_1ED7EAC88);
  if ((v64 & 1) == 0)
  {
    v98 = v63;
    v99 = __cxa_guard_acquire(&qword_1ED7EAC88);
    v63 = v98;
    if (v99)
    {
      v100 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v100 = 0xFF51AFD7ED558CCDLL;
      qword_1ED7EAC80 = v100;
      __cxa_guard_release(&qword_1ED7EAC88);
      v63 = v98;
    }
  }
  v65 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (qword_1ED7EAC80 ^ 0xEEA3BE4ECE12391DLL)) ^ ((0x9DDFEA08EB382D69
                                                                             * (qword_1ED7EAC80 ^ 0xEEA3BE4ECE12391DLL)) >> 47) ^ 0x81D3932BA3734B7BLL);
  v66 = (-348639895 * ((v65 >> 47) ^ v65)) ^ 0x696F702D;
  for (k = 1; ; ++k)
  {
    v68 = v66 & (v62 - 1);
    v69 = v63 + 24 * v68;
    v70 = *(_QWORD **)v69;
    if (*(_QWORD *)v69 == -1)
    {
      if ("frame-pointer" == (char *)-1)
        goto LABEL_131;
      goto LABEL_120;
    }
    if (v70 != (_QWORD *)-2)
      break;
    if ("frame-pointer" == (char *)-2)
      goto LABEL_131;
LABEL_120:
    if (v70 == (_QWORD *)-1)
      goto LABEL_208;
    v66 = k + v68;
  }
  if (*(_QWORD *)(v69 + 8) != 13)
    goto LABEL_120;
  if (*v70 != 0x6F702D656D617266 || *(_QWORD *)((char *)v70 + 5) != 0x7265746E696F702DLL)
    goto LABEL_120;
LABEL_131:
  v61 = *(_QWORD *)(v69 + 16);
  if (!v61)
  {
LABEL_209:
    v72 = 0;
    goto LABEL_210;
  }
  v72 = *(unsigned int *)(v61 + 16);
  v61 += *(unsigned int *)(v61 + 12) + 25;
  switch((_DWORD)v72)
  {
    case 8:
      if (*(_QWORD *)v61 != 0x6661656C2D6E6F6ELL)
      {
        v72 = 8;
        goto LABEL_210;
      }
      break;
    case 4:
      if (*(_DWORD *)v61 != 1701736302)
      {
        v72 = 4;
        goto LABEL_210;
      }
      break;
    case 3:
      if (*(_WORD *)v61 != 27745 || *(_BYTE *)(v61 + 2) != 108)
      {
        v72 = 3;
        goto LABEL_210;
      }
      break;
    default:
LABEL_210:
      v113 = 1283;
      v110[0] = (uint64_t *)"invalid value for 'frame-pointer' attribute: ";
      v111 = (uint64_t *)v61;
      v112 = v72;
      sub_1C6249A24((uint64_t)v7, (llvm::Twine *)v110);
      if (*v7)
      {
        if (v114)
          sub_1C6249A88(v7, v114);
      }
      break;
  }
LABEL_213:
  v96 = v116;
  sub_1C544C510(v7, v116, "patchable-function-prefix", 0x19uLL, v114);
  sub_1C544C510(v7, v96, "patchable-function-entry", 0x18uLL, v114);
  sub_1C544C510(v7, v96, "warn-stack-size", 0xFuLL, v114);
}

void sub_1C5448CA4(llvm::raw_ostream **a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD v19[4];
  __int16 v20;
  uint64_t v21;

  v18 = a2;
  v2 = *(_QWORD *)(a2 + 8);
  if (!v2)
    return;
  while (1)
  {
    v5 = *(_QWORD *)(v2 + 24);
    v17 = v5;
    v6 = *(unsigned __int8 *)(v5 + 16);
    if (v6 <= 0x3C)
    {
      if (v6 == 33)
        goto LABEL_8;
      if (v6 != 60)
        goto LABEL_25;
      goto LABEL_19;
    }
    if (v6 != 61)
    {
      if (v6 != 84)
      {
LABEL_25:
        v16 = "swifterror value can only be loaded and stored from, or as a swifterror argument!";
        goto LABEL_27;
      }
LABEL_8:
      v21 = a2;
      if (v6 == 84)
        v7 = 0;
      else
        v7 = 2;
      v8 = *(_DWORD *)(v5 + 20);
      v9 = v8 & 0x7FFFFFF;
      v10 = v5 - 32 * v9;
      if (v8 < 0 && (v15 = *(_QWORD *)(v10 - 8), (v15 & 0xFFFFFFFF0) != 0))
        v11 = (*(_DWORD *)(v10 - 12) - *(_DWORD *)(v10 - v15));
      else
        v11 = 0;
      if (v10 != v5 - 32 * v7 - 32 * v11 - 32)
      {
        v12 = 0;
        v13 = (32 * v7 + 32 * v11) ^ 0xFFFFFFFFFFFFFFE0;
        v14 = -32 * v9;
        while (*(_QWORD *)(v5 + v14) != a2 || (llvm::CallBase::paramHasAttr(v5, v12, 63) & 1) != 0)
        {
          ++v12;
          v14 += 32;
          if (v13 == v14)
            goto LABEL_19;
        }
        v19[0] = "swifterror value when used in a callsite should be marked with swifterror attribute";
        v20 = 259;
        sub_1C6249C0C(a1, (llvm::Twine *)v19, &v21, v5);
      }
      goto LABEL_19;
    }
    if (*(_QWORD *)(v5 - 32) != a2)
      break;
LABEL_19:
    v2 = *(_QWORD *)(v2 + 8);
    if (!v2)
      return;
  }
  v16 = "swifterror value should be the second operand when used by stores";
LABEL_27:
  v19[0] = v16;
  v20 = 259;
  sub_1C6249880(a1, (llvm::Twine *)v19, &v18, &v17);
}

void sub_1C5448E64(_QWORD *a1, uint64_t a2)
{
  char v4;
  uint64_t v5;
  _QWORD *v6;
  const char *v7;
  __int16 v8;

  sub_1C4774094((llvm::SmallPtrSetImplBase *)(a1 + 54), a2);
  if (v4)
  {
    v5 = *(_QWORD *)(a2 + 16);
    v6 = (_QWORD *)(v5 & 0xFFFFFFFFFFFFFFF8);
    if ((v5 & 4) != 0)
      v6 = (_QWORD *)*v6;
    if (v6 == (_QWORD *)a1[23])
      __asm { BR              X10 }
    v7 = "MDNode context does not match Module context!";
    v8 = 259;
    sub_1C6249A24((uint64_t)a1, (llvm::Twine *)&v7);
    if (*a1)
      sub_1C6249C6C((llvm::raw_ostream *)a1, (uint64_t **)a2);
  }
}

void sub_1C544A79C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  llvm::raw_ostream *v6;
  char v7;
  uint64_t **v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t **v13;
  char v14;
  llvm::DISubprogram *v15;
  uint64_t v16;
  char v17;
  uint64_t ***v18;
  llvm::raw_ostream *v19;
  uint64_t **v20;
  uint64_t v21;
  uint64_t ***v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD v25[4];
  __int16 v26;
  uint64_t **v27;
  uint64_t **v28;

  if (a3)
  {
    if (*(_BYTE *)a3 == 5)
    {
      v28 = (uint64_t **)a3;
      v6 = *(llvm::raw_ostream **)(a1 + 8);
      sub_1C4774094(*(llvm::SmallPtrSetImplBase **)a1, a3);
      if (v7)
      {
        v8 = *(uint64_t ***)(a3 - 8 * *(unsigned int *)(a3 + 8));
        v27 = v8;
        if (v8 && *(unsigned __int8 *)v8 - 17 <= 2)
        {
          v9 = a3;
          do
          {
            v10 = v9;
            v11 = *(unsigned int *)(v9 + 8);
            if ((_DWORD)v11 != 2)
              break;
            v9 = *(_QWORD *)(v9 - 8);
          }
          while (v9);
          v12 = (uint64_t *)(v10 - 8 * v11);
          v13 = (uint64_t **)*v12;
          if (*v12)
          {
            sub_1C4774094(*(llvm::SmallPtrSetImplBase **)a1, *v12);
            if (v14)
            {
              v15 = (llvm::DISubprogram *)v13;
              if ((*(_BYTE *)v13 & 0xFE) != 0x12)
                goto LABEL_16;
              v16 = (uint64_t)v13;
              do
                v16 = *(_QWORD *)(v16 - 8 * *(unsigned int *)(v16 + 8) + 8);
              while ((*(_BYTE *)v16 & 0xFE) == 0x12);
              v15 = (llvm::DISubprogram *)v13;
              if (v13 == (uint64_t **)v16
                || (sub_1C4774094(*(llvm::SmallPtrSetImplBase **)a1, v16), v15 = (llvm::DISubprogram *)v16, v17))
              {
LABEL_16:
                if (!llvm::DISubprogram::describes(v15, *(const llvm::Function **)(a1 + 24)))
                {
                  v25[0] = "!dbg attachment points at wrong subprogram for function";
                  v26 = 259;
                  v22 = *(uint64_t ****)(a1 + 16);
                  v21 = *(_QWORD *)(a1 + 24);
                  sub_1C6249CD4((uint64_t)v6, (llvm::Twine *)v25);
                  if (*(_QWORD *)v6)
                  {
                    sub_1C6249C6C(v6, *v22);
                    if (v21)
                      sub_1C6249A88((llvm::raw_ostream **)v6, v21);
                    sub_1C6249A88((llvm::raw_ostream **)v6, a2);
                    sub_1C6249C6C(v6, (uint64_t **)a3);
                    sub_1C6249C6C(v6, v13);
                    v19 = v6;
                    v20 = (uint64_t **)v15;
                    goto LABEL_26;
                  }
                }
              }
            }
          }
          else
          {
            v25[0] = "Failed to find DILocalScope";
            v26 = 259;
            sub_1C6249A24((uint64_t)v6, (llvm::Twine *)v25);
            if (*(_QWORD *)v6)
            {
              v19 = v6;
              v20 = (uint64_t **)a3;
LABEL_26:
              sub_1C6249C6C(v19, v20);
            }
          }
        }
        else
        {
          v26 = 259;
          v18 = *(uint64_t ****)(a1 + 16);
          v24 = *(_QWORD *)(a1 + 24);
          v25[0] = "DILocation's scope must be a DILocalScope";
          v23 = a2;
          sub_1C6249CD4((uint64_t)v6, (llvm::Twine *)v25);
          if (*(_QWORD *)v6)
            sub_1C6249F08(v6, *v18, &v24, &v23, &v28, &v27);
        }
      }
    }
  }
}

unsigned int *sub_1C544A9D0(unsigned int *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  unsigned int *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  char *v11;
  unint64_t v12;
  char *v13;

  v3 = a3;
  v4 = result;
  v5 = *(_QWORD *)result;
  v6 = result[2];
  if (*(_QWORD *)result + 8 * v6 == a2)
    return sub_1C544AB28(result, a3, 0);
  v7 = 0;
  if (a3)
  {
    v8 = a3;
    do
    {
      ++v7;
      v8 = *(_QWORD *)(v8 + 8);
    }
    while (v8);
  }
  v9 = (a2 - v5) >> 3;
  if (v7 + v6 > result[3])
  {
    result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)result, (uint64_t)(result + 4), v7 + v6, 8);
    v5 = *(_QWORD *)v4;
    v6 = v4[2];
  }
  v10 = (char *)(v5 + 8 * v9);
  v11 = (char *)(v5 + 8 * v6);
  v12 = (v11 - v10) >> 3;
  if (v12 >= v7)
  {
    v13 = &v11[-8 * v7];
    result = sub_1C6177054(v4, v13, (char *)(v5 + 8 * v6));
    if (v13 != v10)
      result = (unsigned int *)memmove(&v11[-(v13 - v10)], v10, v13 - v10);
    while (v3)
    {
      *(_QWORD *)v10 = *(_QWORD *)(v3 + 24);
      v10 += 8;
      v3 = *(_QWORD *)(v3 + 8);
    }
  }
  else
  {
    v4[2] = v6 + v7;
    if (v9 != v6)
    {
      result = (unsigned int *)memcpy((void *)(v5 + 8 * (v6 + v7) - 8 * v12), v10, v11 - v10);
      do
      {
        *(_QWORD *)v10 = *(_QWORD *)(v3 + 24);
        v10 += 8;
        v3 = *(_QWORD *)(v3 + 8);
        --v12;
      }
      while (v12);
    }
    for (; v3; v3 = *(_QWORD *)(v3 + 8))
    {
      *(_QWORD *)v11 = *(_QWORD *)(v3 + 24);
      v11 += 8;
    }
  }
  return result;
}

unsigned int *sub_1C544AB28(unsigned int *result, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  unsigned int *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;

  v4 = a2;
  v5 = result;
  if (a2 == a3)
  {
    v6 = 0;
  }
  else
  {
    v6 = 0;
    v7 = a2;
    do
    {
      ++v6;
      v7 = *(_QWORD *)(v7 + 8);
    }
    while (v7 != a3);
  }
  v8 = result[2];
  if (v6 + v8 > (unint64_t)result[3])
  {
    result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)result, (uint64_t)(result + 4), v6 + v8, 8);
    v8 = v5[2];
  }
  if (v4 != a3)
  {
    v9 = (_QWORD *)(*(_QWORD *)v5 + 8 * v8);
    do
    {
      *v9++ = *(_QWORD *)(v4 + 24);
      v4 = *(_QWORD *)(v4 + 8);
    }
    while (v4 != a3);
  }
  v5[2] = v8 + v6;
  return result;
}

void sub_1C544ABD0(llvm::raw_ostream **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  std::string::size_type *v12;
  std::string::size_type v13;
  char v14;
  const char *v15;
  unsigned int v16;
  char v17;
  int v18;
  unint64_t v19;
  unsigned int Alignment;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t PreallocatedType;
  unsigned int v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  std::string *v32;
  std::string::size_type v33;
  std::string *v34;
  std::string::size_type v35;
  std::string *v36;
  std::string::size_type v37;
  std::string *v38;
  std::string::size_type v39;
  const char *v40;
  const char *v41;
  std::string v42;
  __int16 v43;
  std::string *v44;
  std::string *v45;
  uint64_t v46;
  int v47;
  _WORD v48[16];
  std::string v49;
  unint64_t v50;
  void *__p[2];
  _QWORD v52[4];
  std::string v53;
  _QWORD v54[2];

  v54[0] = a2;
  if (!a2)
    return;
  sub_1C544B3B0(a1, a2, a4);
  v8 = (unint64_t *)(a2 + 48);
  v9 = *(unsigned int *)(a2 + 8);
  v10 = 8 * v9;
  if (!(_DWORD)v9)
  {
    v14 = *(_BYTE *)(a2 + 13);
    if ((v14 & 2) != 0)
      goto LABEL_11;
    goto LABEL_13;
  }
  v11 = 8 * v9;
  v12 = (std::string::size_type *)(a2 + 48);
  do
  {
    v13 = *v12;
    v49.__r_.__value_.__r.__words[0] = v13;
    if (v13)
    {
      if (*(_BYTE *)(v13 + 8) == 2)
        goto LABEL_8;
      LODWORD(v13) = *(_DWORD *)(v13 + 12);
    }
    if ((byte_1C85FC5EE[(v13 - 1)] & 2) == 0)
    {
      llvm::Attribute::getAsString((llvm::Attribute *)&v49, 0, &v53);
      v32 = std::string::insert(&v53, 0, "Attribute '");
      v33 = v32->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v42.__r_.__value_.__l.__data_ = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
      v42.__r_.__value_.__r.__words[2] = v33;
      v32->__r_.__value_.__l.__size_ = 0;
      v32->__r_.__value_.__r.__words[2] = 0;
      v32->__r_.__value_.__r.__words[0] = 0;
      v34 = std::string::append(&v42, "' does not apply to parameters");
      v35 = v34->__r_.__value_.__r.__words[2];
      *(_OWORD *)__p = *(_OWORD *)&v34->__r_.__value_.__l.__data_;
      v52[0] = v35;
      v34->__r_.__value_.__l.__size_ = 0;
      v34->__r_.__value_.__r.__words[2] = 0;
      v34->__r_.__value_.__r.__words[0] = 0;
      v48[0] = 260;
      v44 = (std::string *)__p;
      sub_1C6249A24((uint64_t)a1, (llvm::Twine *)&v44);
      if (a4 && *a1)
        sub_1C6249A88(a1, a4);
      if (SHIBYTE(v52[0]) < 0)
        operator delete(__p[0]);
      if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v42.__r_.__value_.__l.__data_);
      if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v53.__r_.__value_.__l.__data_);
      return;
    }
LABEL_8:
    ++v12;
    v11 -= 8;
  }
  while (v11);
  v14 = *(_BYTE *)(a2 + 13);
  if ((v14 & 2) != 0 && (_DWORD)v9 != 1)
  {
LABEL_11:
    v15 = "Attribute 'immarg' is incompatible with other attributes";
    goto LABEL_104;
  }
LABEL_13:
  v16 = *(unsigned __int8 *)(a2 + 20);
  v17 = *(_BYTE *)(a2 + 21);
  if (v17 & 2 | v14 & 4)
    v18 = ((v16 >> 5) & 1) + (v16 >> 7) + (v17 & 1) + 1;
  else
    v18 = ((v16 >> 5) & 1) + (v16 >> 7) + (v17 & 1);
  if (v18 + ((*(unsigned __int8 *)(a2 + 14) >> 2) & 1) + ((v16 >> 4) & 1) >= 2)
  {
    v15 = "Attributes 'byval', 'inalloca', 'preallocated', 'inreg', 'nest', 'byref', and 'sret' are incompatible!";
    goto LABEL_104;
  }
  if ((v16 & 0x80) != 0 && (*(_BYTE *)(a2 + 17) & 0x20) != 0)
  {
    v15 = "Attributes 'inalloca and readonly' are incompatible!";
    goto LABEL_104;
  }
  if ((*(_BYTE *)(a2 + 21) & 2) != 0 && (*(_BYTE *)(a2 + 17) & 0x40) != 0)
  {
    v15 = "Attributes 'sret and returned' are incompatible!";
    goto LABEL_104;
  }
  if ((v16 & 8) != 0 && (*(_BYTE *)(a2 + 18) & 1) != 0)
  {
    v15 = "Attributes 'zeroext and signext' are incompatible!";
    goto LABEL_104;
  }
  if ((*(_BYTE *)(a2 + 17) & 0x10) != 0)
  {
    if ((*(_BYTE *)(a2 + 17) & 0x20) != 0)
    {
      v15 = "Attributes 'readnone and readonly' are incompatible!";
    }
    else
    {
      if ((v16 & 4) == 0)
        goto LABEL_26;
      v15 = "Attributes 'readnone and writeonly' are incompatible!";
    }
LABEL_104:
    v44 = (std::string *)v15;
    v48[0] = 259;
    sub_1C6249A24((uint64_t)a1, (llvm::Twine *)&v44);
    if (a4)
    {
      if (*a1)
        sub_1C6249A88(a1, a4);
    }
    return;
  }
LABEL_26:
  if ((*(_BYTE *)(a2 + 17) & 0x20) != 0 && (v16 & 4) != 0)
  {
    v15 = "Attributes 'readonly and writeonly' are incompatible!";
    goto LABEL_104;
  }
  if ((*(_BYTE *)(a2 + 15) & 8) != 0 && (*(_BYTE *)(a2 + 12) & 4) != 0)
  {
    v15 = "Attributes 'noinline and alwaysinline' are incompatible!";
    goto LABEL_104;
  }
  llvm::AttributeFuncs::typeIncompatible(a3, 3, (uint64_t *)__p);
  if (!(_DWORD)v9)
  {
LABEL_36:
    if (!a3 || *(_BYTE *)(a3 + 8) != 15)
      goto LABEL_69;
    if ((v16 & 0x20) == 0)
    {
LABEL_46:
      if ((v16 & 0x10) == 0)
        goto LABEL_50;
      v44 = (std::string *)v48;
      v45 = (std::string *)v48;
      v46 = 4;
      v47 = 0;
      v23 = llvm::AttributeSet::getByRefType((llvm::AttributeSet *)v54);
      v24 = *(unsigned __int8 *)(v23 + 8);
      if (v24 <= 0x11)
      {
        if (((1 << v24) & 0xAC7F) != 0)
        {
LABEL_49:
          LOBYTE(v16) = *(_BYTE *)(a2 + 20);
LABEL_50:
          if ((v16 & 0x80) != 0)
          {
            v44 = (std::string *)v48;
            v45 = (std::string *)v48;
            v46 = 4;
            v47 = 0;
            v25 = llvm::AttributeSet::getInAllocaType((llvm::AttributeSet *)v54);
            v26 = *(unsigned __int8 *)(v25 + 8);
            if (v26 <= 0x11)
            {
              if (((1 << v26) & 0xAC7F) != 0)
                goto LABEL_53;
              if (((1 << v26) & 0x30000) != 0)
                goto LABEL_99;
            }
            if ((v26 & 0xFE) == 0x12 || v26 == 21)
            {
LABEL_99:
              if ((llvm::Type::isSizedDerivedType(v25, (llvm::SmallPtrSetImplBase *)&v44) & 1) != 0)
              {
                if (v45 != v44)
                  free(v45);
                goto LABEL_53;
              }
            }
            v40 = "Attribute 'inalloca' does not support unsized types!";
            goto LABEL_130;
          }
LABEL_53:
          if ((*(_BYTE *)(a2 + 21) & 1) == 0)
            goto LABEL_56;
          v44 = (std::string *)v48;
          v45 = (std::string *)v48;
          v46 = 4;
          v47 = 0;
          PreallocatedType = llvm::AttributeSet::getPreallocatedType((llvm::AttributeSet *)v54);
          v28 = *(unsigned __int8 *)(PreallocatedType + 8);
          if (v28 <= 0x11)
          {
            if (((1 << v28) & 0xAC7F) != 0)
              goto LABEL_56;
            if (((1 << v28) & 0x30000) != 0)
              goto LABEL_82;
          }
          if ((v28 & 0xFE) == 0x12 || v28 == 21)
          {
LABEL_82:
            if ((llvm::Type::isSizedDerivedType(PreallocatedType, (llvm::SmallPtrSetImplBase *)&v44) & 1) != 0)
            {
              if (v45 != v44)
                free(v45);
LABEL_56:
              if (!*(_QWORD *)(a3 + 24))
                goto LABEL_69;
              v29 = **(_QWORD **)(a3 + 16);
              if (*(_BYTE *)(v29 + 8) != 15 && *(char *)(a2 + 19) < 0)
              {
                v41 = "Attribute 'swifterror' only applies to parameters with pointer to pointer type!";
              }
              else
              {
                v30 = *(_BYTE *)(a2 + 20);
                if ((v30 & 0x10) != 0 && llvm::AttributeSet::getByRefType((llvm::AttributeSet *)v54) != v29)
                {
                  v41 = "Attribute 'byref' type does not match parameter!";
                }
                else if ((v30 & 0x20) != 0
                       && (v31 = llvm::AttributeSet::getByValType((llvm::AttributeSet *)v54)) != 0
                       && v31 != v29)
                {
                  v41 = "Attribute 'byval' type does not match parameter!";
                }
                else if ((*(_BYTE *)(a2 + 21) & 1) != 0
                       && llvm::AttributeSet::getPreallocatedType((llvm::AttributeSet *)v54) != v29)
                {
                  v41 = "Attribute 'preallocated' type does not match parameter!";
                }
                else if (v30 < 0 && llvm::AttributeSet::getInAllocaType((llvm::AttributeSet *)v54) != v29)
                {
                  v41 = "Attribute 'inalloca' type does not match parameter!";
                }
                else
                {
                  if ((v30 & 0x40) == 0 || llvm::AttributeSet::getElementType((llvm::AttributeSet *)v54) == v29)
                    goto LABEL_69;
                  v41 = "Attribute 'elementtype' type does not match parameter!";
                }
              }
              goto LABEL_141;
            }
          }
          v40 = "Attribute 'preallocated' does not support unsized types!";
LABEL_130:
          v42.__r_.__value_.__r.__words[0] = (std::string::size_type)v40;
          v43 = 259;
          sub_1C6249A24((uint64_t)a1, (llvm::Twine *)&v42);
          if (a4 && *a1)
            sub_1C6249A88(a1, a4);
          if (v45 != v44)
            free(v45);
          goto LABEL_69;
        }
        if (((1 << v24) & 0x30000) != 0)
          goto LABEL_74;
      }
      if ((v24 & 0xFE) == 0x12 || v24 == 21)
      {
LABEL_74:
        if ((llvm::Type::isSizedDerivedType(v23, (llvm::SmallPtrSetImplBase *)&v44) & 1) != 0)
        {
          if (v45 != v44)
            free(v45);
          goto LABEL_49;
        }
      }
      v40 = "Attribute 'byref' does not support unsized types!";
      goto LABEL_130;
    }
    if ((v17 & 4) != 0)
    {
      Alignment = (unsigned __int16)llvm::AttributeSetNode::getAlignment((llvm::AttributeSetNode *)a2);
      if (Alignment <= 0x100)
        LOBYTE(Alignment) = 0;
      if (Alignment >= 0xFu)
      {
        v41 = "Attribute 'align' exceed the max size 2^14";
LABEL_141:
        v44 = (std::string *)v41;
        v48[0] = 259;
        sub_1C6249A24((uint64_t)a1, (llvm::Twine *)&v44);
        if (a4 && *a1)
          sub_1C6249A88(a1, a4);
        goto LABEL_69;
      }
    }
    v44 = (std::string *)v48;
    v45 = (std::string *)v48;
    v46 = 4;
    v47 = 0;
    v21 = llvm::AttributeSet::getByValType((llvm::AttributeSet *)v54);
    v22 = *(unsigned __int8 *)(v21 + 8);
    if (v22 <= 0x11)
    {
      if (((1 << v22) & 0xAC7F) != 0)
      {
LABEL_45:
        LOBYTE(v16) = *(_BYTE *)(a2 + 20);
        goto LABEL_46;
      }
      if (((1 << v22) & 0x30000) != 0)
        goto LABEL_78;
    }
    if ((v22 & 0xFE) == 0x12 || v22 == 21)
    {
LABEL_78:
      if ((llvm::Type::isSizedDerivedType(v21, (llvm::SmallPtrSetImplBase *)&v44) & 1) != 0)
      {
        if (v45 != v44)
          free(v45);
        goto LABEL_45;
      }
    }
    v40 = "Attribute 'byval' does not support unsized types!";
    goto LABEL_130;
  }
  while (2)
  {
    v19 = *v8;
    v50 = v19;
    if (!v19)
      goto LABEL_34;
    if (*(_BYTE *)(v19 + 8) == 2)
      goto LABEL_35;
    v19 = *(unsigned int *)(v19 + 12);
LABEL_34:
    if (((*(unint64_t *)((char *)__p + ((v19 >> 3) & 0x1FFFFFF8)) >> v19) & 1) == 0)
    {
LABEL_35:
      ++v8;
      v10 -= 8;
      if (!v10)
        goto LABEL_36;
      continue;
    }
    break;
  }
  llvm::Attribute::getAsString((llvm::Attribute *)&v50, 0, &v49);
  v36 = std::string::insert(&v49, 0, "Attribute '");
  v37 = v36->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v53.__r_.__value_.__l.__data_ = *(_OWORD *)&v36->__r_.__value_.__l.__data_;
  v53.__r_.__value_.__r.__words[2] = v37;
  v36->__r_.__value_.__l.__size_ = 0;
  v36->__r_.__value_.__r.__words[2] = 0;
  v36->__r_.__value_.__r.__words[0] = 0;
  v38 = std::string::append(&v53, "' applied to incompatible type!");
  v39 = v38->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v42.__r_.__value_.__l.__data_ = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
  v42.__r_.__value_.__r.__words[2] = v39;
  v38->__r_.__value_.__l.__size_ = 0;
  v38->__r_.__value_.__r.__words[2] = 0;
  v38->__r_.__value_.__r.__words[0] = 0;
  v48[0] = 260;
  v44 = &v42;
  sub_1C6249A24((uint64_t)a1, (llvm::Twine *)&v44);
  if (a4 && *a1)
    sub_1C6249A88(a1, a4);
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v42.__r_.__value_.__l.__data_);
  if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v53.__r_.__value_.__l.__data_);
  if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v49.__r_.__value_.__l.__data_);
LABEL_69:
  sub_1C5010E9C((uint64_t)v52, (_QWORD *)v52[1]);
}

void sub_1C544B3B0(llvm::raw_ostream **a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  BOOL v10;
  int v12;
  BOOL v14;
  int v16;
  int v19;
  BOOL v25;
  uint64_t v27;
  _DWORD *v28;
  uint64_t v29;
  _DWORD *v30;
  uint64_t v31;
  _DWORD *v32;
  uint64_t v33;
  _DWORD *v34;
  uint64_t v35;
  _DWORD *v36;
  uint64_t v37;
  _DWORD *v38;
  uint64_t v39;
  _DWORD *v40;
  uint64_t v41;
  _DWORD *v42;
  uint64_t v43;
  _DWORD *v44;
  uint64_t v45;
  _DWORD *v46;
  std::string *v57;
  std::string::size_type v58;
  std::string *v59;
  std::string::size_type v60;
  std::string v63;
  std::string v64;
  void *__p[2];
  std::string::size_type v66;
  _QWORD v67[2];
  uint64_t v68;
  uint64_t v69;
  __int16 v70;
  uint64_t v71;

  if (a2)
    v3 = (uint64_t *)(a2 + 48);
  else
    v3 = 0;
  if (a2)
    v4 = a2 + 48 + 8 * *(unsigned int *)(a2 + 8);
  else
    v4 = 0;
  if (v3 == (uint64_t *)v4)
    return;
  while (1)
  {
    v71 = *v3;
    v5 = v71;
    if (!v71)
      goto LABEL_89;
    v6 = *(unsigned __int8 *)(v71 + 8);
    if (v6 != 2)
      break;
    v7 = *(_DWORD *)(v71 + 12);
    if (v7 == 19)
    {
      if (*(_QWORD *)(v71 + 24) == 0x662D786F72707061
        && *(_QWORD *)(v71 + 32) == 0x6D2D70662D636E75
        && *(_QWORD *)(v71 + 35) == 0x6874616D2D70662DLL)
      {
        v29 = *(unsigned int *)(v71 + 16);
        if ((_DWORD)v29)
        {
          v30 = (_DWORD *)(v71 + 44);
          if ((_DWORD)v29 == 5)
          {
            if (*v30 != 1936482662 || *(_BYTE *)(v71 + 48) != 101)
            {
LABEL_145:
              v67[0] = "invalid value for 'approx-func-fp-math' attribute: ";
              v68 = v71 + 44;
              v69 = v29;
              v70 = 1283;
              sub_1C6249A24((uint64_t)a1, (llvm::Twine *)v67);
            }
          }
          else if ((_DWORD)v29 != 4 || *v30 != 1702195828)
          {
            goto LABEL_145;
          }
        }
      }
      v7 = *(_DWORD *)(v5 + 12);
    }
    if (v7 == 18)
    {
      v10 = *(_QWORD *)(v5 + 24) == 0x6572702D7373656CLL && *(_QWORD *)(v5 + 32) == 0x6D70662D65736963;
      if (v10 && *(_WORD *)(v5 + 40) == 25697)
      {
        v31 = *(unsigned int *)(v5 + 16);
        if ((_DWORD)v31)
        {
          v32 = (_DWORD *)(v5 + 43);
          if ((_DWORD)v31 == 5)
          {
            if (*v32 != 1936482662 || *(_BYTE *)(v5 + 47) != 101)
            {
LABEL_150:
              v67[0] = "invalid value for 'less-precise-fpmad' attribute: ";
              v68 = v5 + 43;
              v69 = v31;
              v70 = 1283;
              sub_1C6249A24((uint64_t)a1, (llvm::Twine *)v67);
            }
          }
          else if ((_DWORD)v31 != 4 || *v32 != 1702195828)
          {
            goto LABEL_150;
          }
        }
      }
    }
    v12 = *(_DWORD *)(v5 + 12);
    if (v12 == 15)
    {
      if (*(_QWORD *)(v5 + 24) == 0x2D73666E692D6F6ELL && *(_QWORD *)(v5 + 31) == 0x6874616D2D70662DLL)
      {
        v33 = *(unsigned int *)(v5 + 16);
        if ((_DWORD)v33)
        {
          v34 = (_DWORD *)(v5 + 40);
          if ((_DWORD)v33 == 5)
          {
            if (*v34 != 1936482662 || *(_BYTE *)(v5 + 44) != 101)
            {
LABEL_155:
              v67[0] = "invalid value for 'no-infs-fp-math' attribute: ";
              v68 = v5 + 40;
              v69 = v33;
              v70 = 1283;
              sub_1C6249A24((uint64_t)a1, (llvm::Twine *)v67);
            }
          }
          else if ((_DWORD)v33 != 4 || *v34 != 1702195828)
          {
            goto LABEL_155;
          }
        }
      }
      v12 = *(_DWORD *)(v5 + 12);
    }
    if (v12 == 21)
    {
      v14 = *(_QWORD *)(v5 + 24) == 0x6E696C6E692D6F6ELL && *(_QWORD *)(v5 + 32) == 0x742D656E696C2D65;
      if (v14 && *(_QWORD *)(v5 + 37) == 0x73656C6261742D65)
      {
        v35 = *(unsigned int *)(v5 + 16);
        if ((_DWORD)v35)
        {
          v36 = (_DWORD *)(v5 + 46);
          if ((_DWORD)v35 == 5)
          {
            if (*v36 != 1936482662 || *(_BYTE *)(v5 + 50) != 101)
            {
LABEL_160:
              v67[0] = "invalid value for 'no-inline-line-tables' attribute: ";
              v68 = v5 + 46;
              v69 = v35;
              v70 = 1283;
              sub_1C6249A24((uint64_t)a1, (llvm::Twine *)v67);
            }
          }
          else if ((_DWORD)v35 != 4 || *v36 != 1702195828)
          {
            goto LABEL_160;
          }
        }
      }
    }
    v16 = *(_DWORD *)(v5 + 12);
    if (v16 == 14)
    {
      if (*(_QWORD *)(v5 + 24) == 0x2D706D756A2D6F6ELL && *(_QWORD *)(v5 + 30) == 0x73656C6261742D70)
      {
        v37 = *(unsigned int *)(v5 + 16);
        if ((_DWORD)v37)
        {
          v38 = (_DWORD *)(v5 + 39);
          if ((_DWORD)v37 == 5)
          {
            if (*v38 != 1936482662 || *(_BYTE *)(v5 + 43) != 101)
            {
LABEL_165:
              v67[0] = "invalid value for 'no-jump-tables' attribute: ";
              v68 = v5 + 39;
              v69 = v37;
              v70 = 1283;
              sub_1C6249A24((uint64_t)a1, (llvm::Twine *)v67);
            }
          }
          else if ((_DWORD)v37 != 4 || *v38 != 1702195828)
          {
            goto LABEL_165;
          }
        }
      }
      v16 = *(_DWORD *)(v5 + 12);
    }
    if (v16 == 15 && *(_QWORD *)(v5 + 24) == 0x2D736E616E2D6F6ELL && *(_QWORD *)(v5 + 31) == 0x6874616D2D70662DLL)
    {
      v39 = *(unsigned int *)(v5 + 16);
      if ((_DWORD)v39)
      {
        v40 = (_DWORD *)(v5 + 40);
        if ((_DWORD)v39 == 5)
        {
          if (*v40 != 1936482662 || *(_BYTE *)(v5 + 44) != 101)
          {
LABEL_170:
            v67[0] = "invalid value for 'no-nans-fp-math' attribute: ";
            v68 = v5 + 40;
            v69 = v39;
            v70 = 1283;
            sub_1C6249A24((uint64_t)a1, (llvm::Twine *)v67);
          }
        }
        else if ((_DWORD)v39 != 4 || *v40 != 1702195828)
        {
          goto LABEL_170;
        }
      }
    }
    v19 = *(_DWORD *)(v5 + 12);
    if (v19 != 23)
      goto LABEL_69;
    if (*(_QWORD *)(v5 + 24) == 0x656E6769732D6F6ELL
      && *(_QWORD *)(v5 + 32) == 0x2D736F72657A2D64
      && *(_QWORD *)(v5 + 39) == 0x6874616D2D70662DLL)
    {
      v41 = *(unsigned int *)(v5 + 16);
      if ((_DWORD)v41)
      {
        v42 = (_DWORD *)(v5 + 48);
        if ((_DWORD)v41 == 5)
        {
          if (*v42 != 1936482662 || *(_BYTE *)(v5 + 52) != 101)
          {
LABEL_175:
            v67[0] = "invalid value for 'no-signed-zeros-fp-math' attribute: ";
            v68 = v5 + 48;
            v69 = v41;
            v70 = 1283;
            sub_1C6249A24((uint64_t)a1, (llvm::Twine *)v67);
          }
        }
        else if ((_DWORD)v41 != 4 || *v42 != 1702195828)
        {
          goto LABEL_175;
        }
      }
    }
    v19 = *(_DWORD *)(v5 + 12);
    if (v19 == 23)
    {
      if (*(_QWORD *)(v5 + 24) == 0x2D656C69666F7270
        && *(_QWORD *)(v5 + 32) == 0x612D656C706D6173
        && *(_QWORD *)(v5 + 39) == 0x6574617275636361)
      {
        v45 = *(unsigned int *)(v5 + 16);
        if ((_DWORD)v45)
        {
          v46 = (_DWORD *)(v5 + 48);
          if ((_DWORD)v45 == 5)
          {
            if (*v46 != 1936482662 || *(_BYTE *)(v5 + 52) != 101)
            {
LABEL_185:
              v67[0] = "invalid value for 'profile-sample-accurate' attribute: ";
              v68 = v5 + 48;
              v69 = v45;
              v70 = 1283;
              sub_1C6249A24((uint64_t)a1, (llvm::Twine *)v67);
            }
          }
          else if ((_DWORD)v45 != 4 || *v46 != 1702195828)
          {
            goto LABEL_185;
          }
        }
      }
      v19 = *(_DWORD *)(v5 + 12);
    }
LABEL_69:
    if (v19 != 14)
      goto LABEL_74;
    if (*(_QWORD *)(v5 + 24) != 0x662D656661736E75 || *(_QWORD *)(v5 + 30) != 0x6874616D2D70662DLL)
      goto LABEL_74;
    v43 = *(unsigned int *)(v5 + 16);
    if (!(_DWORD)v43)
      goto LABEL_74;
    v44 = (_DWORD *)(v5 + 39);
    if ((_DWORD)v43 == 5)
    {
      if (*v44 == 1936482662 && *(_BYTE *)(v5 + 43) == 101)
        goto LABEL_74;
LABEL_180:
      v67[0] = "invalid value for 'unsafe-fp-math' attribute: ";
      v68 = v5 + 39;
      v69 = v43;
      v70 = 1283;
      sub_1C6249A24((uint64_t)a1, (llvm::Twine *)v67);
      goto LABEL_74;
    }
    if ((_DWORD)v43 != 4 || *v44 != 1702195828)
      goto LABEL_180;
LABEL_74:
    if (*(_DWORD *)(v5 + 12) != 18)
      goto LABEL_89;
    v25 = *(_QWORD *)(v5 + 24) == 0x706D61732D657375 && *(_QWORD *)(v5 + 32) == 0x69666F72702D656CLL;
    if (!v25 || *(_WORD *)(v5 + 40) != 25964)
      goto LABEL_89;
    v27 = *(unsigned int *)(v5 + 16);
    if (!(_DWORD)v27)
      goto LABEL_89;
    v28 = (_DWORD *)(v5 + 43);
    if ((_DWORD)v27 == 5)
    {
      if (*v28 == 1936482662 && *(_BYTE *)(v5 + 47) == 101)
        goto LABEL_89;
    }
    else if ((_DWORD)v27 == 4 && *v28 == 1702195828)
    {
      goto LABEL_89;
    }
    v67[0] = "invalid value for 'use-sample-profile' attribute: ";
    v68 = v5 + 43;
    v69 = v27;
    v70 = 1283;
    sub_1C6249A24((uint64_t)a1, (llvm::Twine *)v67);
LABEL_89:
    if (++v3 == (uint64_t *)v4)
      return;
  }
  if ((v6 == 1) == (*(_DWORD *)(v71 + 12) - 74) < 7)
    goto LABEL_89;
  llvm::Attribute::getAsString((llvm::Attribute *)&v71, 0, &v63);
  v57 = std::string::insert(&v63, 0, "Attribute '");
  v58 = v57->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v64.__r_.__value_.__l.__data_ = *(_OWORD *)&v57->__r_.__value_.__l.__data_;
  v64.__r_.__value_.__r.__words[2] = v58;
  v57->__r_.__value_.__l.__size_ = 0;
  v57->__r_.__value_.__r.__words[2] = 0;
  v57->__r_.__value_.__r.__words[0] = 0;
  v59 = std::string::append(&v64, "' should have an Argument");
  v60 = v59->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = *(_OWORD *)&v59->__r_.__value_.__l.__data_;
  v66 = v60;
  v59->__r_.__value_.__l.__size_ = 0;
  v59->__r_.__value_.__r.__words[2] = 0;
  v59->__r_.__value_.__r.__words[0] = 0;
  v70 = 260;
  v67[0] = __p;
  sub_1C6249A24((uint64_t)a1, (llvm::Twine *)v67);
  if (a3 && *a1)
    sub_1C6249A88(a1, a3);
  if (SHIBYTE(v66) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v64.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v64.__r_.__value_.__l.__data_);
  if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v63.__r_.__value_.__l.__data_);
}

uint64_t sub_1C544C430(uint64_t **a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  llvm::raw_ostream **v4;
  uint64_t v5;
  const char *v7;
  uint64_t *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  __int16 v12;
  _QWORD v13[4];
  __int16 v14;

  v4 = (llvm::raw_ostream **)a1[1];
  v5 = **a1;
  if (*(_DWORD *)(v5 + 12) - 1 <= a4)
  {
    v12 = 1283;
    v9 = "'allocsize' ";
    v10 = a2;
    v11 = a3;
    v7 = " argument is out of bounds";
  }
  else
  {
    if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v5 + 16) + 8 * (a4 + 1)) + 8) == 13)
      return 1;
    v12 = 1283;
    v9 = "'allocsize' ";
    v10 = a2;
    v11 = a3;
    v7 = " argument must refer to an integer parameter";
  }
  v13[0] = &v9;
  v13[2] = v7;
  v14 = 770;
  v8 = a1[2];
  sub_1C6249A24((uint64_t)v4, (llvm::Twine *)v13);
  if (*v4)
  {
    if (*v8)
      sub_1C6249A88(v4, *v8);
  }
  return 0;
}

void sub_1C544C510(llvm::raw_ostream **a1, uint64_t a2, _QWORD *a3, size_t a4, uint64_t a5)
{
  uint64_t v6;
  int v7;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  int i;
  int v15;
  uint64_t v16;
  const void *v17;
  unsigned __int8 *v18;
  int v19;
  uint64_t v20;
  int v21;
  unsigned int v22;
  int j;
  int v24;
  uint64_t v25;
  const void *v26;
  uint64_t v27;
  unint64_t v28;
  unsigned __int8 *v29;
  uint64_t v30;
  int v31;
  int v32;
  unsigned int v33;
  unint64_t v34;
  _QWORD v37[4];
  __int16 v38;
  _QWORD v39[4];
  __int16 v40;
  _QWORD v41[4];
  __int16 v42;

  if (!a2)
    return;
  if (!*(_DWORD *)(a2 + 8))
    return;
  v6 = *(_QWORD *)(a2 + 40);
  if (!v6)
    return;
  v7 = *(_DWORD *)(v6 + 40);
  if (!v7)
    return;
  v10 = *(_QWORD *)(v6 + 24);
  v11 = (uint64_t)a3 + a4;
  v12 = sub_1C5E3DF4C(a3, (uint64_t)a3 + a4);
  v13 = v7 - 1;
  for (i = 1; ; ++i)
  {
    v15 = v12 & v13;
    v16 = v10 + 24 * (v12 & v13);
    v17 = *(const void **)v16;
    if (*(_QWORD *)v16 == -1)
    {
      if (a3 == (_QWORD *)-1)
        goto LABEL_16;
      goto LABEL_8;
    }
    if (v17 != (const void *)-2)
      break;
    if (a3 == (_QWORD *)-2)
      goto LABEL_16;
LABEL_8:
    if (v17 == (const void *)-1)
      return;
    v12 = i + v15;
  }
  if (a4 != *(_QWORD *)(v16 + 8) || a4 && memcmp(a3, v17, a4))
    goto LABEL_8;
LABEL_16:
  if (!*(_DWORD *)(a2 + 8))
    goto LABEL_43;
  v18 = *(unsigned __int8 **)(a2 + 40);
  if (!v18)
    goto LABEL_44;
  v19 = *((_DWORD *)v18 + 10);
  if (!v19)
  {
LABEL_43:
    v18 = 0;
    goto LABEL_44;
  }
  v20 = *((_QWORD *)v18 + 3);
  v21 = sub_1C5E3DF4C(a3, v11);
  v22 = v19 - 1;
  for (j = 1; ; ++j)
  {
    v24 = v21 & v22;
    v25 = v20 + 24 * (v21 & v22);
    v26 = *(const void **)v25;
    if (*(_QWORD *)v25 == -1)
    {
      if (a3 == (_QWORD *)-1)
        goto LABEL_30;
      goto LABEL_22;
    }
    if (v26 != (const void *)-2)
      break;
    if (a3 == (_QWORD *)-2)
      goto LABEL_30;
LABEL_22:
    if (v26 == (const void *)-1)
      goto LABEL_43;
    v21 = j + v24;
  }
  if (a4 != *(_QWORD *)(v25 + 8) || a4 && memcmp(a3, *(const void **)v25, a4))
    goto LABEL_22;
LABEL_30:
  v18 = *(unsigned __int8 **)(v25 + 16);
  if (!v18 || (v27 = *((unsigned int *)v18 + 4), v18 += *((unsigned int *)v18 + 3) + 25, !(_DWORD)v27))
  {
LABEL_44:
    v27 = 0;
    goto LABEL_45;
  }
  v28 = 0;
  v29 = v18;
  v30 = v27;
  while (1)
  {
    v31 = *v29;
    if ((v31 - 48) >= 0xA)
    {
      if ((v31 - 97) >= 0x1A)
      {
        if ((v31 - 65) > 0x19)
          break;
        v32 = -55;
      }
      else
      {
        v32 = -87;
      }
    }
    else
    {
      v32 = -48;
    }
    v33 = v32 + v31;
    if (v33 > 9)
      break;
    v34 = 10 * v28 + v33;
    if (v28 > v34 / 0xA)
      break;
    ++v29;
    v28 = v34;
    if (!--v30)
    {
      if (!HIDWORD(v34))
        return;
      break;
    }
  }
LABEL_45:
  v38 = 1283;
  v37[0] = "\"";
  v37[2] = a3;
  v37[3] = a4;
  v39[0] = v37;
  v39[2] = "\" takes an unsigned integer: ";
  v40 = 770;
  v41[0] = v39;
  v41[2] = v18;
  v41[3] = v27;
  v42 = 1282;
  sub_1C6249A24((uint64_t)a1, (llvm::Twine *)v41);
  if (a5)
  {
    if (*a1)
      sub_1C6249A88(a1, a5);
  }
}

void sub_1C544C7C8(llvm::raw_ostream *a1, uint64_t **this)
{
  const char *v4;
  __int16 v5;

  if (!llvm::DIExpression::isValid((llvm::DIExpression *)this))
  {
    v4 = "invalid expression";
    v5 = 259;
    sub_1C6249CD4((uint64_t)a1, (llvm::Twine *)&v4);
    if (*(_QWORD *)a1)
      sub_1C6249C6C(a1, this);
  }
}

void sub_1C544C834(llvm::raw_ostream *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  llvm::DIVariable *v7;
  __int32 v8;
  __int32 v9;
  unint64_t SizeInBits;
  char v11;
  const char *v12;
  int8x16_t v13;
  char v14;
  uint64_t **v15;
  _QWORD v16[4];
  __int16 v17;
  uint64_t **v18;

  v4 = *(_QWORD *)(a2 - 8 * *(unsigned int *)(a2 + 8));
  if (v4)
  {
    sub_1C544C944(a1, v4);
    v5 = a2 - 8 * *(unsigned int *)(a2 + 8);
    v6 = *(_QWORD *)(v5 + 8);
    if (v6)
    {
      sub_1C544C7C8(a1, *(uint64_t ***)(v5 + 8));
      llvm::DIExpression::getFragmentInfo(*(uint64_t **)(v6 + 24), *(uint64_t **)(v6 + 32), &v13);
      if (v14)
      {
        v7 = *(llvm::DIVariable **)(a2 - 8 * *(unsigned int *)(a2 + 8));
        v8 = v13.i32[0];
        v9 = v13.i32[2];
        v18 = (uint64_t **)a2;
        SizeInBits = llvm::DIVariable::getSizeInBits(v7);
        if (v11)
        {
          if ((v9 + v8) > SizeInBits)
          {
            v12 = "fragment is larger than or outside of variable";
          }
          else
          {
            if (SizeInBits != v8)
              return;
            v12 = "fragment covers entire variable";
          }
          v15 = (uint64_t **)v7;
          v16[0] = v12;
          v17 = 259;
          sub_1C6249DA4(a1, (llvm::Twine *)v16, &v18, &v15);
        }
      }
    }
  }
  else
  {
    v16[0] = "missing variable";
    v17 = 259;
    sub_1C6249CD4((uint64_t)a1, (llvm::Twine *)v16);
  }
}

void sub_1C544C944(llvm::raw_ostream *a1, uint64_t a2)
{
  uint64_t v4;
  unsigned __int8 *v5;
  int v6;
  uint64_t ***v7;
  uint64_t ***v8;
  _BYTE *v9;
  const char *v10;
  unsigned __int8 *v11;
  _BYTE *v12;
  _QWORD v13[4];
  __int16 v14;

  sub_1C544D130(a1, a2);
  if (*(_WORD *)(a2 + 2) != 52)
  {
    v10 = "invalid tag";
    goto LABEL_14;
  }
  v4 = a2 - 8 * *(unsigned int *)(a2 + 8);
  v5 = *(unsigned __int8 **)(v4 + 24);
  if (v5)
  {
    v6 = *v5;
    if ((v6 - 11) >= 4 && v6 != 33)
    {
      v12 = (_BYTE *)a2;
      v13[0] = "invalid type ref";
      v14 = 259;
      v11 = v5;
      v7 = (uint64_t ***)&v12;
      v8 = (uint64_t ***)&v11;
LABEL_12:
      sub_1C6249DA4(a1, (llvm::Twine *)v13, v7, v8);
      return;
    }
    goto LABEL_7;
  }
  if (*(_BYTE *)(a2 + 33))
  {
    v10 = "missing global variable type";
LABEL_14:
    v13[0] = v10;
    v14 = 259;
    sub_1C6249CD4((uint64_t)a1, (llvm::Twine *)v13);
    if (*(_QWORD *)a1)
      sub_1C6249C6C(a1, (uint64_t **)a2);
    return;
  }
LABEL_7:
  v9 = *(_BYTE **)(v4 + 48);
  v12 = v9;
  if (v9 && *v9 != 12)
  {
    v13[0] = "invalid static data member declaration";
    v14 = 259;
    v11 = (unsigned __int8 *)a2;
    v7 = (uint64_t ***)&v11;
    v8 = (uint64_t ***)&v12;
    goto LABEL_12;
  }
}

void sub_1C544CA60(llvm::raw_ostream *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  const char *v11;
  _QWORD v12[4];
  __int16 v13;

  v5 = *(_QWORD *)(a2 + 128);
  if (!v5)
  {
    v10 = "Expected valid value";
    goto LABEL_21;
  }
  if (*(_BYTE *)(*(_QWORD *)v5 + 8) == 9)
  {
    v11 = "Unexpected metadata round-trip through values";
    goto LABEL_18;
  }
  if (*(_BYTE *)a2 != 2)
    return;
  if (!a3)
  {
    v10 = "function-local metadata used outside a function";
LABEL_21:
    v12[0] = v10;
    v13 = 259;
    sub_1C6249A24((uint64_t)a1, (llvm::Twine *)v12);
    if (*(_QWORD *)a1)
      sub_1C6249C6C(a1, (uint64_t **)a2);
    return;
  }
  v6 = *(unsigned __int8 *)(v5 + 16);
  if (v6 < 0x1C)
  {
    if (v6 == 21)
    {
      v7 = (uint64_t *)(v5 + 24);
    }
    else
    {
      if (v6 != 22)
      {
        v9 = 0;
        goto LABEL_13;
      }
      v7 = (uint64_t *)(v5 + 56);
    }
LABEL_12:
    v9 = *v7;
LABEL_13:
    if (v9 == a3)
      return;
    v10 = "function-local metadata used in wrong function";
    goto LABEL_21;
  }
  v8 = *(_QWORD *)(v5 + 40);
  if (v8)
  {
    v7 = (uint64_t *)(v8 + 56);
    goto LABEL_12;
  }
  v11 = "function-local metadata not in basic block";
LABEL_18:
  v12[0] = v11;
  v13 = 259;
  sub_1C6249A24((uint64_t)a1, (llvm::Twine *)v12);
  if (*(_QWORD *)a1)
  {
    sub_1C6249C6C(a1, (uint64_t **)a2);
    sub_1C6249A88((llvm::raw_ostream **)a1, v5);
  }
}

void sub_1C544CBA4(llvm::raw_ostream *a1, uint64_t a2)
{
  uint64_t **v2;
  uint64_t **v3;
  const char *v4;
  __int16 v5;
  uint64_t **v6;

  if (*(_BYTE *)a2 != 15)
  {
    v2 = *(uint64_t ***)(a2 - 8 * *(unsigned int *)(a2 + 8));
    v6 = v2;
    if (v2)
    {
      if (*(_BYTE *)v2 != 15)
      {
        v3 = (uint64_t **)a2;
        v4 = "invalid file";
        v5 = 259;
        sub_1C6249DA4(a1, (llvm::Twine *)&v4, &v3, &v6);
      }
    }
  }
}

void sub_1C544CC10(llvm::raw_ostream *a1, uint64_t **a2, uint64_t **a3)
{
  int v5;
  uint64_t **v6;
  uint64_t v7;
  uint64_t ***v8;
  uint64_t **v9;
  uint64_t **v10;
  uint64_t **v11;
  _QWORD v12[4];
  __int16 v13;

  v5 = *(unsigned __int8 *)a3;
  if (v5 == 4)
    v6 = a3;
  else
    v6 = 0;
  if (v5 == 4)
  {
    v7 = *((unsigned int *)a3 + 2);
    if ((_DWORD)v7)
    {
      v8 = (uint64_t ***)&a3[-v7];
      while (1)
      {
        v9 = *v8;
        if (!*v8 || (*(_BYTE *)v9 & 0xFE) != 0x16)
          break;
        if (++v8 == (uint64_t ***)v6)
          return;
      }
      v12[0] = "invalid template parameter";
      v13 = 259;
      sub_1C6249CD4((uint64_t)a1, (llvm::Twine *)v12);
      if (*(_QWORD *)a1)
      {
        sub_1C6249C6C(a1, a2);
        sub_1C6249C6C(a1, v6);
        sub_1C6249C6C(a1, v9);
      }
    }
  }
  else
  {
    v11 = a2;
    v12[0] = "invalid template params";
    v13 = 259;
    v10 = a3;
    sub_1C6249DA4(a1, (llvm::Twine *)v12, &v11, &v10);
  }
}

void sub_1C544CD00(uint64_t a1, uint64_t a2, unsigned __int8 a3)
{
  uint64_t v6;
  uint64_t v7[4];
  __int16 v8;

  v6 = a1 + 808;
  if ((sub_1C4F763D4(*(_QWORD *)(a1 + 808), *(_DWORD *)(a1 + 824), a2, v7) & 1) == 0)
  {
    v7[0] = a2;
    *(_BYTE *)(sub_1C544CDA4(v6, v7) + 8) = a3;
  }
  v7[0] = a2;
  if (*(unsigned __int8 *)(sub_1C544CDA4(v6, v7) + 8) != a3)
  {
    v7[0] = (uint64_t)"inconsistent use of embedded source";
    v8 = 259;
    sub_1C6249CD4(a1, (llvm::Twine *)v7);
  }
}

uint64_t sub_1C544CDA4(uint64_t a1, uint64_t *a2)
{
  char v4;
  uint64_t result;
  int v6;
  unsigned int v7;
  uint64_t v8;

  v8 = 0;
  v4 = sub_1C4F763D4(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  result = v8;
  if ((v4 & 1) != 0)
    return result;
  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 < 3 * v7)
  {
    if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
      goto LABEL_5;
  }
  else
  {
    v7 *= 2;
  }
  sub_1C544CE88(a1, v7);
  v8 = 0;
  sub_1C4F763D4(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  result = v8;
LABEL_5:
  ++*(_DWORD *)(a1 + 8);
  if (*(_QWORD *)result != -4096)
    --*(_DWORD *)(a1 + 12);
  *(_QWORD *)result = *a2;
  *(_BYTE *)(result + 8) = 0;
  return result;
}

_QWORD *sub_1C544CE88(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unsigned int v8;
  _QWORD *result;
  uint64_t v10;
  uint64_t v11;

  v3 = *(unsigned int *)(a1 + 16);
  v4 = *(_QWORD *)a1;
  v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
    v8 = v7 + 1;
  else
    v8 = 64;
  *(_DWORD *)(a1 + 16) = v8;
  result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(_QWORD *)a1 = result;
  if (v4)
  {
    sub_1C544CF40(a1, v4, v4 + 16 * v3);
    JUMPOUT(0x1CAA32FB4);
  }
  *(_QWORD *)(a1 + 8) = 0;
  v10 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v10)
  {
    v11 = 16 * v10;
    do
    {
      *result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1C544CF40(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;

  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(unsigned int *)(result + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)result;
    v8 = 16 * v6;
    do
    {
      *v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    v9 = *(_QWORD *)a2;
    if ((*(_QWORD *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v11 = 0;
      result = sub_1C4F763D4(*(_QWORD *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
      v10 = v11;
      *v11 = *(_QWORD *)a2;
      *((_BYTE *)v10 + 8) = *(_BYTE *)(a2 + 8);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 16;
  }
  return result;
}

void sub_1C544CFEC(llvm::raw_ostream *a1, uint64_t a2)
{
  uint64_t **v4;
  int v5;
  const char *v6;
  uint64_t **v7;
  uint64_t **v8;
  _QWORD v9[4];
  __int16 v10;

  if (*(_WORD *)(a2 + 2) != 11)
  {
    v6 = "invalid tag";
LABEL_9:
    v9[0] = v6;
    v10 = 259;
    sub_1C6249CD4((uint64_t)a1, (llvm::Twine *)v9);
    if (*(_QWORD *)a1)
      sub_1C6249C6C(a1, (uint64_t **)a2);
    return;
  }
  v4 = *(uint64_t ***)(a2 - 8 * *(unsigned int *)(a2 + 8) + 8);
  if (!v4 || (v5 = *(unsigned __int8 *)v4, (v5 - 20) <= 0xFFFFFFFC))
  {
    v8 = (uint64_t **)a2;
    v9[0] = "invalid local scope";
    v10 = 259;
    v7 = v4;
    sub_1C6249DA4(a1, (llvm::Twine *)v9, &v8, &v7);
    return;
  }
  if (v5 == 17 && (*((_BYTE *)v4 + 44) & 8) == 0)
  {
    v6 = "scope points into the type hierarchy";
    goto LABEL_9;
  }
}

void sub_1C544D0C4(llvm::raw_ostream *a1, uint64_t a2)
{
  uint64_t **v2;
  int v3;
  uint64_t **v4;
  uint64_t **v5;
  const char *v6;
  __int16 v7;

  v2 = *(uint64_t ***)(a2 - 8 * *(unsigned int *)(a2 + 8) + 8);
  if (v2)
  {
    v3 = *(unsigned __int8 *)v2;
    if ((v3 - 11) >= 4 && v3 != 33)
    {
      v5 = (uint64_t **)a2;
      v6 = "invalid type ref";
      v7 = 259;
      v4 = v2;
      sub_1C6249DA4(a1, (llvm::Twine *)&v6, &v5, &v4);
    }
  }
}

void sub_1C544D130(llvm::raw_ostream *a1, uint64_t a2)
{
  uint64_t ***v2;
  int v3;
  BOOL v4;
  uint64_t **v5;
  const char *v6;
  uint64_t **v7;
  const char *v8;
  __int16 v9;
  uint64_t **v10;

  v2 = (uint64_t ***)(a2 - 8 * *(unsigned int *)(a2 + 8));
  v10 = *v2;
  if (v10)
  {
    v3 = *(unsigned __int8 *)v10;
    v4 = (v3 - 11) < 0xB || v3 == 31;
    if (!v4 && v3 != 33)
    {
      v6 = "invalid scope";
LABEL_13:
      v7 = (uint64_t **)a2;
      v8 = v6;
      v9 = 259;
      sub_1C6249DA4(a1, (llvm::Twine *)&v8, &v7, &v10);
      return;
    }
  }
  v5 = v2[2];
  v10 = v5;
  if (v5 && *(_BYTE *)v5 != 15)
  {
    v6 = "invalid file";
    goto LABEL_13;
  }
}

_QWORD *sub_1C544D1C4(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unsigned int v8;
  _QWORD *result;
  uint64_t v10;
  uint64_t v11;

  v3 = *(unsigned int *)(a1 + 16);
  v4 = *(uint64_t **)a1;
  v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
    v8 = v7 + 1;
  else
    v8 = 64;
  *(_DWORD *)(a1 + 16) = v8;
  result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(_QWORD *)a1 = result;
  if (v4)
  {
    sub_1C4F57738(a1, v4, &v4[2 * v3]);
    JUMPOUT(0x1CAA32FB4);
  }
  *(_QWORD *)(a1 + 8) = 0;
  v10 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v10)
  {
    v11 = 16 * v10;
    do
    {
      *result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1C544D27C(uint64_t result, unint64_t *a2, uint64_t a3, uint64_t a4, char a5)
{
  unint64_t *v8;
  unint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t *v15;
  __int128 v16;
  unint64_t v17;
  unint64_t *v18;
  char v19;
  BOOL v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;

  v8 = (unint64_t *)result;
LABEL_2:
  v9 = v8;
LABEL_3:
  v10 = 1 - a4;
  while (2)
  {
    v8 = v9;
    v11 = v10;
    v12 = (char *)a2 - (char *)v9;
    v13 = ((char *)a2 - (char *)v9) >> 4;
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        v21 = *(a2 - 2);
        v22 = *v9;
        if (v21 < *v9 || v22 >= v21 && *(a2 - 1) < v9[1])
        {
          *v9 = v21;
          *(a2 - 2) = v22;
          v23 = v9[1];
          v9[1] = *(a2 - 1);
          *(a2 - 1) = v23;
        }
        return result;
      case 3uLL:
        return sub_1C544D76C(v9, v9 + 2, a2 - 2);
      case 4uLL:
        return sub_1C544DD50(v9, v9 + 2, v9 + 4, a2 - 2);
      case 5uLL:
        return sub_1C544DE50(v9, v9 + 2, v9 + 4, v9 + 6, a2 - 2);
      default:
        if (v12 <= 383)
        {
          if ((a5 & 1) != 0)
            return (uint64_t)sub_1C544D5F0(v9, a2);
          else
            return (uint64_t)sub_1C544D6D0(v9, a2);
        }
        if (v11 != 1)
        {
          v14 = v13 >> 1;
          v15 = &v9[2 * (v13 >> 1)];
          if ((unint64_t)v12 < 0x801)
          {
            sub_1C544D76C(&v9[2 * (v13 >> 1)], v9, a2 - 2);
            if ((a5 & 1) != 0)
              goto LABEL_14;
          }
          else
          {
            sub_1C544D76C(v9, &v9[2 * (v13 >> 1)], a2 - 2);
            sub_1C544D76C(v9 + 2, v15 - 2, a2 - 4);
            sub_1C544D76C(v9 + 4, &v9[2 * v14 + 2], a2 - 6);
            sub_1C544D76C(v15 - 2, v15, &v9[2 * v14 + 2]);
            v16 = *(_OWORD *)v9;
            *(_OWORD *)v9 = *(_OWORD *)v15;
            *(_OWORD *)v15 = v16;
            if ((a5 & 1) != 0)
              goto LABEL_14;
          }
          v17 = *(v9 - 2);
          if (v17 >= *v9 && (*v9 < v17 || *(v9 - 1) >= v9[1]))
          {
            result = (uint64_t)sub_1C544D8C0(v9, a2);
            v9 = (unint64_t *)result;
            goto LABEL_19;
          }
LABEL_14:
          v18 = sub_1C544DA04(v9, a2);
          if ((v19 & 1) == 0)
            goto LABEL_17;
          v20 = sub_1C544DB4C(v9, v18);
          v9 = v18 + 2;
          result = sub_1C544DB4C(v18 + 2, a2);
          if (!(_DWORD)result)
          {
            v10 = v11 + 1;
            if (v20)
              continue;
LABEL_17:
            result = sub_1C544D27C(v8, v18, a3, -v11, a5 & 1);
            v9 = v18 + 2;
LABEL_19:
            a5 = 0;
            a4 = -v11;
            goto LABEL_3;
          }
          a4 = -v11;
          a2 = v18;
          if (v20)
            return result;
          goto LABEL_2;
        }
        if (v9 != a2)
          return (uint64_t)sub_1C544DFA4(v9, a2, a2, a3);
        return result;
    }
  }
}

unint64_t *sub_1C544D5F0(unint64_t *result, unint64_t *a2)
{
  unint64_t *v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t *v13;

  if (result == a2)
    return result;
  v2 = result + 2;
  if (result + 2 == a2)
    return result;
  v3 = 0;
  v4 = result;
  do
  {
    v5 = v4;
    v4 = v2;
    v6 = v5[2];
    v7 = *v5;
    if (v6 >= *v5)
    {
      if (v7 < v6)
        goto LABEL_20;
      v8 = v5[3];
      if (v8 >= v5[1])
        goto LABEL_20;
    }
    else
    {
      v8 = v5[3];
    }
    v5[2] = v7;
    v4[1] = v5[1];
    v9 = result;
    if (v5 == result)
      goto LABEL_19;
    v10 = v3;
    while (1)
    {
      v11 = *(unint64_t *)((char *)result + v10 - 16);
      if (v6 < v11)
      {
        v12 = *(unint64_t *)((char *)result + v10 - 8);
        goto LABEL_12;
      }
      if (v11 < v6)
      {
        v9 = (unint64_t *)((char *)result + v10);
        goto LABEL_19;
      }
      v12 = *(unint64_t *)((char *)result + v10 - 8);
      if (v8 >= v12)
        break;
LABEL_12:
      v5 -= 2;
      v13 = (unint64_t *)((char *)result + v10);
      *v13 = v11;
      v13[1] = v12;
      v10 -= 16;
      if (!v10)
      {
        v9 = result;
        goto LABEL_19;
      }
    }
    v9 = v5;
LABEL_19:
    *v9 = v6;
    v9[1] = v8;
LABEL_20:
    v2 = v4 + 2;
    v3 += 16;
  }
  while (v4 + 2 != a2);
  return result;
}

unint64_t *sub_1C544D6D0(unint64_t *result, unint64_t *a2)
{
  unint64_t *v2;
  unint64_t *i;
  unint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t *j;
  unint64_t v9;

  if (result != a2)
  {
    v2 = result + 2;
    if (result + 2 != a2)
    {
      for (i = result + 1; ; i += 2)
      {
        v4 = result;
        result = v2;
        v5 = v4[2];
        v6 = *v4;
        if (v5 < *v4)
          break;
        if (v6 >= v5)
        {
          v7 = v4[3];
          if (v7 < v4[1])
            goto LABEL_6;
        }
LABEL_14:
        v2 = result + 2;
        if (result + 2 == a2)
          return result;
      }
      v7 = v4[3];
LABEL_6:
      for (j = i; ; j -= 2)
      {
        v9 = *j;
        j[1] = v6;
        j[2] = v9;
        v6 = *(j - 3);
        if (v5 >= v6 && (v6 < v5 || v7 >= *(j - 2)))
          break;
      }
      *(j - 1) = v5;
      *j = v7;
      goto LABEL_14;
    }
  }
  return result;
}

uint64_t sub_1C544D76C(unint64_t *a1, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;

  v3 = *a2;
  v4 = *a1;
  if (*a2 >= *a1 && (v4 < v3 || a2[1] >= a1[1]))
  {
    v9 = *a3;
    if (*a3 >= v3 && (v3 < v9 || a3[1] >= a2[1]))
      return 0;
    *a2 = v9;
    *a3 = v3;
    v11 = (uint64_t *)(a2 + 1);
    v10 = a2[1];
    a2[1] = a3[1];
    a3[1] = v10;
    v12 = *a2;
    v13 = *a1;
    if (*a2 >= *a1 && (v13 < v12 || *v11 >= a1[1]))
      return 1;
    *a1 = v12;
    v6 = (uint64_t *)(a1 + 1);
    *a2 = v13;
    v8 = 2;
  }
  else
  {
    v5 = *a3;
    if (*a3 < v3 || v3 >= v5 && a3[1] < a2[1])
    {
      *a1 = v5;
      v6 = (uint64_t *)(a1 + 1);
      *a3 = v4;
      v7 = (uint64_t *)(a3 + 1);
      v8 = 1;
    }
    else
    {
      *a1 = v3;
      *a2 = v4;
      v14 = a1[1];
      a1[1] = a2[1];
      a2[1] = v14;
      v15 = *a3;
      v16 = *a2;
      if (*a3 >= *a2 && (v16 < v15 || a3[1] >= v14))
        return 1;
      *a2 = v15;
      *a3 = v16;
      v7 = (uint64_t *)(a3 + 1);
      v8 = 2;
      v6 = (uint64_t *)(a2 + 1);
    }
    v11 = v7;
  }
  v17 = *v6;
  *v6 = *v11;
  *v11 = v17;
  return v8;
}

unint64_t *sub_1C544D8C0(unint64_t *a1, unint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t *i;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;

  v2 = *a1;
  v3 = a1[1];
  v4 = *(a2 - 2);
  if (*a1 >= v4 && (v4 < v2 || v3 >= *(a2 - 1)))
  {
    for (i = a1 + 2; i < a2 && v2 >= *i && (*i < v2 || v3 >= i[1]); i += 2)
      ;
  }
  else
  {
    i = a1;
    do
    {
      v7 = i[2];
      i += 2;
      v6 = v7;
    }
    while (v2 >= v7 && (v6 < v2 || v3 >= i[1]));
  }
  if (i < a2)
  {
    for (a2 -= 2; v2 < v4 || v4 >= v2 && v3 < a2[1]; a2 -= 2)
    {
      v8 = *(a2 - 2);
      v4 = v8;
    }
  }
  if (i < a2)
  {
    v9 = *i;
    v10 = *a2;
    do
    {
      *i = v10;
      *a2 = v9;
      v11 = i[1];
      i[1] = a2[1];
      a2[1] = v11;
      do
      {
        v12 = i[2];
        i += 2;
        v9 = v12;
      }
      while (v2 >= v12 && (v9 < v2 || v3 >= i[1]));
      do
      {
        do
        {
          v13 = *(a2 - 2);
          a2 -= 2;
          v10 = v13;
        }
        while (v2 < v13);
      }
      while (v10 >= v2 && v3 < a2[1]);
    }
    while (i < a2);
  }
  if (i - 2 != a1)
  {
    *a1 = *(i - 2);
    a1[1] = *(i - 1);
  }
  *(i - 2) = v2;
  *(i - 1) = v3;
  return i;
}

unint64_t *sub_1C544DA04(unint64_t *a1, unint64_t *a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;

  v2 = 0;
  v3 = *a1;
  v4 = a1[1];
  while (1)
  {
    v5 = a1[v2 + 2];
    if (v5 >= v3 && (v3 < v5 || a1[v2 + 3] >= v4))
      break;
    v2 += 2;
  }
  v6 = (unint64_t)&a1[v2 + 2];
  if (v2 * 8)
  {
    do
    {
      v8 = *(a2 - 2);
      a2 -= 2;
      v7 = v8;
    }
    while (v8 >= v3 && (v3 < v7 || a2[1] >= v4));
  }
  else
  {
LABEL_16:
    if (v6 < (unint64_t)a2)
    {
      do
      {
        v10 = *(a2 - 2);
        a2 -= 2;
        v9 = v10;
        if (v10 < v3)
          break;
        if (v3 < v9)
          goto LABEL_16;
      }
      while (v6 < (unint64_t)a2 && a2[1] >= v4);
    }
  }
  if (v6 >= (unint64_t)a2)
  {
    v12 = (unint64_t *)v6;
  }
  else
  {
    v11 = *a2;
    v12 = (unint64_t *)v6;
    v13 = a2;
    do
    {
      *v12 = v11;
      *v13 = v5;
      v14 = v12[1];
      v12[1] = v13[1];
      v13[1] = v14;
      do
      {
        do
        {
          v15 = v12[2];
          v12 += 2;
          v5 = v15;
        }
        while (v15 < v3);
      }
      while (v3 >= v5 && v12[1] < v4);
      do
      {
        v16 = *(v13 - 2);
        v13 -= 2;
        v11 = v16;
      }
      while (v16 >= v3 && (v3 < v11 || v13[1] >= v4));
    }
    while (v12 < v13);
  }
  if (v12 - 2 != a1)
  {
    *a1 = *(v12 - 2);
    a1[1] = *(v12 - 1);
  }
  *(v12 - 2) = v3;
  *(v12 - 1) = v4;
  return v12 - 2;
}

BOOL sub_1C544DB4C(unint64_t *a1, unint64_t *a2)
{
  uint64_t v4;
  _BOOL8 result;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t *v9;
  unint64_t *v10;
  uint64_t v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t *v16;
  uint64_t v17;
  char *v18;
  unint64_t v19;
  unint64_t v20;

  v4 = ((char *)a2 - (char *)a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = *(a2 - 2);
      v7 = *a1;
      if (v6 < *a1 || v7 >= v6 && *(a2 - 1) < a1[1])
      {
        *a1 = v6;
        *(a2 - 2) = v7;
        v8 = a1[1];
        a1[1] = *(a2 - 1);
        *(a2 - 1) = v8;
      }
      return result;
    case 3:
      sub_1C544D76C(a1, a1 + 2, a2 - 2);
      return 1;
    case 4:
      sub_1C544DD50(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1;
    case 5:
      sub_1C544DE50(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2);
      return 1;
    default:
      v9 = a1 + 4;
      sub_1C544D76C(a1, a1 + 2, a1 + 4);
      v10 = a1 + 6;
      if (a1 + 6 == a2)
        return 1;
      v11 = 0;
      v12 = 0;
      break;
  }
  do
  {
    v13 = *v10;
    v14 = *v9;
    if (*v10 >= *v9)
    {
      if (v14 < v13)
        goto LABEL_23;
      v15 = v10[1];
      if (v15 >= v9[1])
        goto LABEL_23;
    }
    else
    {
      v15 = v10[1];
    }
    *v10 = v14;
    v10[1] = v9[1];
    v16 = a1;
    if (v9 == a1)
      goto LABEL_22;
    v17 = v11;
    while (1)
    {
      v18 = (char *)a1 + v17;
      v19 = *(unint64_t *)((char *)a1 + v17 + 16);
      if (v13 < v19)
      {
        v20 = *((_QWORD *)v18 + 3);
        goto LABEL_18;
      }
      if (v19 < v13)
      {
        v16 = (unint64_t *)((char *)a1 + v17 + 32);
        goto LABEL_22;
      }
      v20 = *(unint64_t *)((char *)a1 + v17 + 24);
      if (v15 >= v20)
        break;
LABEL_18:
      v9 -= 2;
      *((_QWORD *)v18 + 4) = v19;
      *(unint64_t *)((char *)a1 + v17 + 40) = v20;
      v17 -= 16;
      if (v17 == -32)
      {
        v16 = a1;
        goto LABEL_22;
      }
    }
    v16 = v9;
LABEL_22:
    *v16 = v13;
    v16[1] = v15;
    if (++v12 == 8)
      return v10 + 2 == a2;
LABEL_23:
    v9 = v10;
    v11 += 16;
    v10 += 2;
  }
  while (v10 != a2);
  return 1;
}

uint64_t sub_1C544DD50(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  uint64_t result;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;

  result = sub_1C544D76C(a1, a2, a3);
  v9 = *a4;
  v10 = *a3;
  if (*a4 < *a3 || v10 >= v9 && a4[1] < a3[1])
  {
    *a3 = v9;
    *a4 = v10;
    v11 = a3[1];
    a3[1] = a4[1];
    a4[1] = v11;
    v12 = *a3;
    v13 = *a2;
    if (*a3 < *a2 || v13 >= v12 && a3[1] < a2[1])
    {
      *a2 = v12;
      *a3 = v13;
      v14 = a2[1];
      a2[1] = a3[1];
      a3[1] = v14;
      v15 = *a2;
      v16 = *a1;
      if (*a2 < *a1 || v16 >= v15 && a2[1] < a1[1])
      {
        *a1 = v15;
        *a2 = v16;
        v17 = a1[1];
        a1[1] = a2[1];
        a2[1] = v17;
      }
    }
  }
  return result;
}

uint64_t sub_1C544DE50(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  uint64_t result;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;

  result = sub_1C544DD50(a1, a2, a3, a4);
  v11 = *a5;
  v12 = *a4;
  if (*a5 < *a4 || v12 >= v11 && a5[1] < a4[1])
  {
    *a4 = v11;
    *a5 = v12;
    v13 = a4[1];
    a4[1] = a5[1];
    a5[1] = v13;
    v14 = *a4;
    v15 = *a3;
    if (*a4 < *a3 || v15 >= v14 && a4[1] < a3[1])
    {
      *a3 = v14;
      *a4 = v15;
      v16 = a3[1];
      a3[1] = a4[1];
      a4[1] = v16;
      v17 = *a3;
      v18 = *a2;
      if (*a3 < *a2 || v18 >= v17 && a3[1] < a2[1])
      {
        *a2 = v17;
        *a3 = v18;
        v19 = a2[1];
        a2[1] = a3[1];
        a3[1] = v19;
        v20 = *a2;
        v21 = *a1;
        if (*a2 < *a1 || v21 >= v20 && a2[1] < a1[1])
        {
          *a1 = v20;
          *a2 = v21;
          v22 = a1[1];
          a1[1] = a2[1];
          a2[1] = v22;
        }
      }
    }
  }
  return result;
}

unint64_t *sub_1C544DFA4(unint64_t *a1, unint64_t *a2, unint64_t *a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t *v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t *v21;

  if (a1 != a2)
  {
    v8 = (char *)a2 - (char *)a1;
    v9 = ((char *)a2 - (char *)a1) >> 4;
    if ((char *)a2 - (char *)a1 >= 17)
    {
      v10 = (unint64_t)(v9 - 2) >> 1;
      v11 = v10 + 1;
      v12 = &a1[2 * v10];
      do
      {
        sub_1C544E118((uint64_t)a1, a4, v9, v12);
        v12 -= 2;
        --v11;
      }
      while (v11);
    }
    v13 = a2;
    if (a2 != a3)
    {
      v14 = a2;
      do
      {
        v15 = *v14;
        v16 = *a1;
        if (*v14 < *a1 || v16 >= v15 && v14[1] < a1[1])
        {
          *v14 = v16;
          *a1 = v15;
          v17 = v14[1];
          v14[1] = a1[1];
          a1[1] = v17;
          sub_1C544E118((uint64_t)a1, a4, v9, a1);
        }
        v14 += 2;
      }
      while (v14 != a3);
      v13 = a3;
    }
    if (v8 >= 17)
    {
      v18 = a2 - 2;
      do
      {
        v20 = *a1;
        v19 = a1[1];
        v21 = sub_1C544E264(a1, a4, v9);
        if (v18 == v21)
        {
          *v21 = v20;
          v21[1] = v19;
        }
        else
        {
          *v21 = *v18;
          v21[1] = v18[1];
          *v18 = v20;
          v18[1] = v19;
          sub_1C544E2F8((uint64_t)a1, (uint64_t)(v21 + 2), a4, ((char *)(v21 + 2) - (char *)a1) >> 4);
        }
        v18 -= 2;
      }
      while (v9-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t sub_1C544E118(uint64_t result, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  uint64_t v4;
  int64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;

  if (a3 >= 2)
  {
    v4 = (uint64_t)a4 - result;
    v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 4)
    {
      v6 = v4 >> 3;
      v7 = (v4 >> 3) + 1;
      v8 = (unint64_t *)(result + 16 * v7);
      v9 = v6 + 2;
      if (v9 < a3)
      {
        v10 = v8[2];
        if (*v8 < v10 || v10 >= *v8 && *(_QWORD *)(result + 16 * v7 + 8) < v8[3])
        {
          v8 += 2;
          v7 = v9;
        }
      }
      v11 = *v8;
      v12 = *a4;
      if (*v8 >= *a4)
      {
        if (v12 >= v11)
        {
          v13 = a4[1];
          if (v8[1] < v13)
            return result;
        }
        else
        {
          v13 = a4[1];
        }
        *a4 = v11;
        a4[1] = v8[1];
        if (v5 >= v7)
        {
          while (1)
          {
            v15 = 2 * v7;
            v7 = (2 * v7) | 1;
            v14 = (unint64_t *)(result + 16 * v7);
            v16 = v15 + 2;
            if (v16 < a3)
            {
              v17 = v14[2];
              if (*v14 < v17 || v17 >= *v14 && *(_QWORD *)(result + 16 * v7 + 8) < v14[3])
              {
                v14 += 2;
                v7 = v16;
              }
            }
            v18 = *v14;
            if (*v14 < v12 || v12 >= v18 && v14[1] < v13)
              break;
            *v8 = v18;
            v8[1] = v14[1];
            v8 = v14;
            if (v5 < v7)
              goto LABEL_23;
          }
        }
        v14 = v8;
LABEL_23:
        *v14 = v12;
        v14[1] = v13;
      }
    }
  }
  return result;
}

unint64_t *sub_1C544E264(unint64_t *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;

  v3 = 0;
  v4 = a3 - 2;
  if (a3 < 2)
    v4 = a3 - 1;
  v5 = v4 >> 1;
  do
  {
    v6 = result;
    v7 = v3 + 1;
    result += 2 * v3 + 2;
    v8 = 2 * v3;
    v3 = (2 * v3) | 1;
    v9 = v8 + 2;
    if (v9 < a3)
    {
      v10 = result[2];
      if (*result < v10 || v10 >= *result && v6[2 * v7 + 1] < result[3])
      {
        result += 2;
        v3 = v9;
      }
    }
    *v6 = *result;
    v6[1] = result[1];
  }
  while (v3 <= v5);
  return result;
}

uint64_t sub_1C544E2F8(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;

  v4 = a4 - 2;
  if (a4 >= 2)
  {
    v5 = v4 >> 1;
    v6 = (unint64_t *)(result + 16 * (v4 >> 1));
    v7 = *v6;
    v8 = *(_QWORD *)(a2 - 16);
    if (*v6 >= v8)
    {
      if (v8 < v7)
        return result;
      v9 = *(_QWORD *)(a2 - 8);
      if (*(_QWORD *)(result + 16 * v5 + 8) >= v9)
        return result;
    }
    else
    {
      v9 = *(_QWORD *)(a2 - 8);
    }
    *(_QWORD *)(a2 - 16) = v7;
    *(_QWORD *)(a2 - 8) = *(_QWORD *)(result + 16 * v5 + 8);
    if (v4 >= 2)
    {
      while (1)
      {
        v11 = v5 - 1;
        v5 = (v5 - 1) >> 1;
        v10 = (unint64_t *)(result + 16 * v5);
        v12 = *v10;
        if (*v10 >= v8)
        {
          if (v8 < v12)
            break;
          v13 = *(_QWORD *)(result + 16 * v5 + 8);
          if (v13 >= v9)
            break;
        }
        else
        {
          v13 = v10[1];
        }
        *v6 = v12;
        v6[1] = v13;
        v6 = (unint64_t *)(result + 16 * v5);
        if (v11 <= 1)
          goto LABEL_13;
      }
    }
    v10 = v6;
LABEL_13:
    *v10 = v8;
    v10[1] = v9;
  }
  return result;
}

void sub_1C544E3AC(llvm::raw_ostream **a1, uint64_t a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  __int16 v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v4 = *(_DWORD *)(a2 + 20);
  v5 = v4 & 0x7FFFFFF;
  if ((v4 & 0x7FFFFFF) == 0)
LABEL_7:
    __asm { BR              X12 }
  v6 = 0;
  while (1)
  {
    v7 = a2 - 32 * v5;
    if ((v4 & 0x40000000) != 0)
      v7 = *(_QWORD *)(a2 - 8);
    if (!*(_QWORD *)(v7 + v6))
      break;
    v6 += 32;
    if (32 * v5 == v6)
      goto LABEL_7;
  }
  v8 = "Operand is null";
  v9 = 259;
  sub_1C6249A24((uint64_t)a1, (llvm::Twine *)&v8);
  if (*a1)
    sub_1C6249A88(a1, a2);
}

void sub_1C5450B74(llvm::raw_ostream **a1, uint64_t a2)
{
  const char *v4;
  __int16 v5;

  v4 = "User-defined operators should not live outside of a pass!";
  v5 = 259;
  sub_1C6249A24((uint64_t)a1, (llvm::Twine *)&v4);
  if (*a1)
    sub_1C6249A88(a1, a2);
}

void sub_1C5450BD0(llvm::raw_ostream **a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  const char *v7;
  __int16 v8;

  v3 = *(_QWORD *)(a2 + 40);
  v4 = *(_QWORD *)(v3 + 40);
  if (v4 == v3 + 40
    || (v4 ? (v5 = v4 - 24) : (v5 = 0),
        v5 == a2 ? (v6 = *(unsigned __int8 *)(v5 + 16) - 29 >= 0xB) : (v6 = 1),
        v6))
  {
    v7 = "Terminator found in the middle of a basic block!";
    v8 = 259;
    sub_1C6249A24((uint64_t)a1, (llvm::Twine *)&v7);
    if (*a1)
      sub_1C6249A88(a1, v3);
  }
  else
  {
    sub_1C5450C74((uint64_t)a1, (uint64_t ***)a2);
  }
}

void sub_1C5450C74(uint64_t a1, uint64_t ***a2)
{
  uint64_t v4;
  uint64_t **i;
  int v6;
  char *v7;
  int v8;
  uint64_t **v9;
  uint64_t v10;
  unsigned int v11;
  BOOL v12;
  uint64_t v13;
  BOOL v14;
  llvm::Instruction *v15;
  int v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  llvm::Instruction *v20;
  uint64_t v21;
  llvm::DominatorTree *v22;
  int v23;
  uint64_t ***v24;
  uint64_t **v25;
  int v26;
  uint64_t ***v28;
  uint64_t **v29;
  uint64_t **v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t ***v33;
  uint64_t *v34;
  unsigned int v35;
  BOOL v36;
  uint64_t v37;
  unsigned __int8 *v38;
  unsigned int v39;
  llvm::Instruction *v40;
  unsigned int v41;
  int v42;
  char *v43;
  uint64_t v44;
  char *BundleOpInfoForOperand;
  int v46;
  int v47;
  unsigned int v49;
  int v50;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  int v56;
  char *v57;
  uint64_t v58;
  char *v59;
  uint64_t v60;
  _QWORD *v61;
  uint64_t v62;
  uint64_t v63;
  llvm::Instruction *v64;
  int v65;
  BOOL v66;
  llvm::DominatorTree *v67;
  uint64_t v68;
  uint64_t v69;
  llvm::raw_ostream **v70;
  llvm::Instruction *v71;
  unsigned int v72;
  uint64_t v73;
  int v74;
  uint64_t v75;
  int v76;
  unsigned int v77;
  llvm::Instruction **v78;
  llvm::Instruction *v79;
  llvm::Instruction **v80;
  int v81;
  BOOL v82;
  unsigned int v83;
  uint64_t v84;
  _QWORD *v85;
  uint64_t v86;
  uint64_t v87;
  int v88;
  uint64_t v89;
  int v90;
  unsigned int v91;
  llvm::Instruction **v92;
  llvm::Instruction *v93;
  llvm::Instruction **v94;
  int v95;
  BOOL v96;
  unsigned int v97;
  uint64_t v98;
  _QWORD *v99;
  uint64_t v100;
  uint64_t v101;
  unsigned int v102;
  llvm::Metadata *v103;
  unsigned int v104;
  uint64_t v105;
  unint64_t v107;
  uint64_t v108;
  char *v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v115;
  void *v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  size_t v120;
  uint64_t v121;
  unsigned int v122;
  void *v123;
  BOOL v124;
  char v125;
  char *v127;
  char v128;
  uint64_t v130;
  unsigned __int32 v131;
  int8x16_t *v132;
  void *v133;
  void *v134;
  unint64_t v135;
  unint64_t v136;
  unint64_t v137;
  _QWORD *v138;
  int v139;
  int64_t v140;
  unint64_t v141;
  int v142;
  int v143;
  uint64_t v144;
  unint64_t v145;
  unsigned int v146;
  uint64_t v147;
  uint64_t v148;
  char v149;
  BOOL v150;
  llvm::Instruction **v151;
  llvm::Instruction *v152;
  llvm::Instruction **v153;
  llvm::Instruction *v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  void *v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  void *v163;
  void *v164;
  void *v165;
  uint64_t v166;
  void *v167;
  BOOL v168;
  char v169;
  char *v171;
  char *v172;
  uint64_t v173;
  int v174;
  uint64_t v175;
  int v176;
  unsigned int v177;
  llvm::Instruction **v178;
  llvm::Instruction *v179;
  llvm::Instruction **v180;
  int v181;
  BOOL v182;
  unsigned int v183;
  uint64_t v184;
  _QWORD *v185;
  uint64_t v186;
  uint64_t v187;
  int v188;
  uint64_t v189;
  int v190;
  unsigned int v191;
  llvm::Instruction **v192;
  llvm::Instruction *v193;
  llvm::Instruction **v194;
  int v195;
  BOOL v196;
  unsigned int v197;
  uint64_t v198;
  _QWORD *v199;
  uint64_t v200;
  uint64_t v201;
  int v202;
  uint64_t v203;
  int v204;
  unsigned int v205;
  llvm::Instruction **v206;
  llvm::Instruction *v207;
  llvm::Instruction **v208;
  int v209;
  BOOL v210;
  unsigned int v211;
  uint64_t v212;
  uint64_t *v213;
  uint64_t v214;
  uint64_t v215;
  int v216;
  uint64_t v217;
  int v218;
  unsigned int v219;
  llvm::Instruction **v220;
  llvm::Instruction *v221;
  llvm::Instruction **v222;
  int v223;
  BOOL v224;
  unsigned int v225;
  uint64_t v226;
  uint64_t *v227;
  uint64_t v228;
  uint64_t v229;
  int v230;
  uint64_t v231;
  int v232;
  unsigned int v233;
  llvm::Instruction **v234;
  llvm::Instruction *v235;
  llvm::Instruction **v236;
  int v237;
  BOOL v238;
  unsigned int v239;
  uint64_t v240;
  const llvm::MDNode **v241;
  uint64_t v242;
  uint64_t v243;
  int v244;
  uint64_t v245;
  int v246;
  unsigned int v247;
  llvm::Instruction **v248;
  llvm::Instruction *v249;
  llvm::Instruction **v250;
  int v251;
  BOOL v252;
  unsigned int v253;
  uint64_t v254;
  _QWORD *v255;
  uint64_t v256;
  uint64_t v257;
  int v258;
  uint64_t v259;
  int v260;
  unsigned int v261;
  llvm::Instruction **v262;
  llvm::Instruction *v263;
  llvm::Instruction **v264;
  int v265;
  BOOL v266;
  unsigned int v267;
  uint64_t v268;
  _QWORD *v269;
  uint64_t v270;
  uint64_t v271;
  int v272;
  uint64_t v273;
  int v274;
  unsigned int v275;
  llvm::Instruction **v276;
  llvm::Instruction *v277;
  llvm::Instruction **v278;
  int v279;
  BOOL v280;
  unsigned int v281;
  uint64_t v282;
  _QWORD *v283;
  uint64_t v284;
  uint64_t v285;
  int v286;
  uint64_t v287;
  int v288;
  unsigned int v289;
  llvm::Instruction **v290;
  llvm::Instruction *v291;
  llvm::Instruction **v292;
  int v293;
  BOOL v294;
  unsigned int v295;
  uint64_t v296;
  _QWORD *v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  unsigned __int8 *v302;
  uint64_t v303;
  uint64_t v304;
  int8x8_t *v305;
  int8x8_t *v306;
  uint8x8_t v307;
  uint64_t v308;
  uint64_t v309;
  uint64_t v310;
  _QWORD *v311;
  uint64_t v312;
  uint64_t v313;
  int v315;
  int v316;
  uint64_t v317;
  uint64_t v318;
  uint64_t v319;
  uint64_t **v320;
  uint64_t v321;
  uint64_t v322;
  uint64_t ***v323;
  uint64_t *v324;
  llvm::DIVariable *v325;
  unsigned __int8 *v326;
  int v327;
  uint64_t **v328;
  __int32 v329;
  __int32 v330;
  unint64_t SizeInBits;
  char v332;
  llvm::DIExpression *v333;
  _QWORD *v334;
  char *v335;
  char *v336;
  char *v337;
  llvm::Instruction **v338;
  llvm::Instruction *v339;
  llvm::Instruction **v340;
  llvm::Instruction *v341;
  llvm::Instruction **v342;
  llvm::Instruction *v343;
  llvm::Instruction **v344;
  llvm::Instruction *v345;
  llvm::Instruction **v346;
  llvm::Instruction *v347;
  llvm::Instruction **v348;
  llvm::Instruction *v349;
  llvm::Instruction **v350;
  llvm::Instruction *v351;
  llvm::Instruction **v352;
  llvm::Instruction *v353;
  llvm::Instruction **v354;
  llvm::Instruction *v355;
  char *v356;
  char *v357;
  uint64_t v358;
  uint64_t v359;
  uint64_t v360;
  uint64_t v361;
  char *v362;
  char *v363;
  _QWORD *v364;
  int v365;
  int64_t v366;
  unint64_t v367;
  int v368;
  unint64_t v369;
  unsigned int v370;
  unint64_t v371;
  llvm::DominatorTree *v372;
  uint64_t **v373;
  llvm::Metadata *v374;
  llvm::Metadata *v375;
  llvm::Metadata *v376;
  llvm::Metadata *v377;
  uint64_t v378;
  uint64_t v379;
  llvm::Instruction *v380;
  unsigned int v381;
  uint64_t v382;
  unsigned int v383;
  int8x16_t v384;
  uint64_t v385;
  unsigned int v386;
  uint64_t **v387;
  void *__s1;
  uint64_t v389;
  void *__s2;
  unsigned int v391;
  __int16 v392;
  uint64_t v393;

  v393 = *MEMORY[0x1E0C80C00];
  v4 = (uint64_t)a2[5];
  if (!v4)
  {
    v7 = "Instruction not embedded in basic block!";
    goto LABEL_134;
  }
  if (*((_BYTE *)a2 + 16) != 83)
  {
    for (i = a2[1]; i; i = (uint64_t **)i[1])
    {
      if (i[3] == (uint64_t *)a2 && llvm::DominatorTreeBase<llvm::BasicBlock,false>::isReachableFromEntry(a1 + 200, v4))
      {
        v7 = "Only PHI nodes may reference their own value!";
        goto LABEL_134;
      }
    }
  }
  v6 = *((unsigned __int8 *)*a2 + 8);
  switch(v6)
  {
    case 7:
      if ((*((_BYTE *)a2 + 23) & 0x10) != 0)
      {
        v7 = "Instruction has a name, but provides a void value!";
        goto LABEL_134;
      }
      break;
    case 9:
      v8 = *((unsigned __int8 *)a2 + 16);
      if (v8 != 33 && v8 != 84)
      {
        v7 = "Invalid use of metadata!";
        goto LABEL_134;
      }
      break;
    case 14:
      v7 = "Instruction returns a non-scalar type!";
      goto LABEL_134;
  }
  v9 = a2[1];
  if (!v9)
  {
LABEL_21:
    v11 = *((unsigned __int8 *)a2 + 16) - 33;
    v12 = v11 > 0x33;
    v13 = (1 << v11) & 0x8000000000041;
    v14 = v12 || v13 == 0;
    v15 = (llvm::Instruction *)a2;
    if (v14)
      v15 = 0;
    v16 = *((_DWORD *)a2 + 5);
    v17 = v16 & 0x7FFFFFF;
    if ((v16 & 0x7FFFFFF) != 0)
    {
      v18 = 0;
      v19 = 0;
      v20 = (llvm::Instruction *)((char *)v15 - 32);
      v21 = a1 + 272;
      v22 = (llvm::DominatorTree *)(a1 + 200);
      while (1)
      {
        v23 = *((_DWORD *)a2 + 5);
        if ((v23 & 0x40000000) != 0)
          v24 = (uint64_t ***)*(a2 - 1);
        else
          v24 = &a2[-4 * (v23 & 0x7FFFFFF)];
        v25 = v24[v18];
        if (!v25)
        {
          v7 = "Instruction has null operand!";
          goto LABEL_134;
        }
        v26 = *((unsigned __int8 *)*v25 + 8);
        if (v26 == 14 || v26 == 7)
        {
          v7 = "Instruction operands must be first-class values!";
          goto LABEL_134;
        }
        if ((v23 & 0x40000000) != 0)
          v28 = (uint64_t ***)*(a2 - 1);
        else
          v28 = &a2[-4 * (v23 & 0x7FFFFFF)];
        v29 = v28[v18];
        if (*((_BYTE *)v29 + 16))
          v30 = 0;
        else
          v30 = v29;
        v387 = v30;
        if (v30)
        {
          if ((*((_BYTE *)v30 + 33) & 0x20) == 0)
            goto LABEL_45;
          if (!v15)
            goto LABEL_133;
          v40 = (v23 & 0x40000000) != 0
              ? (llvm::Instruction *)*(a2 - 1)
              : (llvm::Instruction *)&a2[-4 * (v23 & 0x7FFFFFF)];
          if ((llvm::Instruction *)((char *)v40 + v18 * 8) == v20)
          {
            v46 = 1;
          }
          else
          {
            v42 = *((_DWORD *)v15 + 5);
            if ((v42 & 0x80000000) == 0
              || (v43 = (char *)v15 - 32 * (v42 & 0x7FFFFFF), v44 = *((_QWORD *)v43 - 1), (v44 & 0xFFFFFFFF0) == 0)
              || *(_DWORD *)&v43[-v44] > v19
              || *((_DWORD *)v43 - 3) <= v19
              || (v374 = (llvm::Metadata *)v21,
                  BundleOpInfoForOperand = llvm::CallBase::getBundleOpInfoForOperand((char *)v15, v19),
                  v21 = (uint64_t)v374,
                  *(_DWORD *)(*(_QWORD *)BundleOpInfoForOperand + 8) != 6))
            {
LABEL_133:
              v7 = "Cannot take the address of an intrinsic!";
              goto LABEL_134;
            }
            v46 = (_DWORD)v30[4] & 0x2000;
          }
          if (!v46 || *((_BYTE *)a2 + 16) == 84)
            goto LABEL_45;
          v47 = *((_DWORD *)v30 + 9);
          if (v47 > 265)
          {
            if ((v47 - 266) >= 4 && v47 != 11082)
              goto LABEL_106;
          }
          else
          {
            if (v47 <= 0x3C && ((1 << v47) & 0x1000100040000000) != 0)
              goto LABEL_45;
            v49 = v47 - 124;
            v12 = v49 > 4;
            v50 = (1 << v49) & 0x19;
            if (!v12 && v50 != 0)
              goto LABEL_45;
LABEL_106:
            v56 = *((_DWORD *)v15 + 5);
            if ((v56 & 0x80000000) == 0
              || (v57 = (char *)v15 - 32 * (v56 & 0x7FFFFFF), v58 = *((_QWORD *)v57 - 1), (v58 & 0xFFFFFFFF0) == 0)
              || *(_DWORD *)&v57[-v58] > v19
              || *((_DWORD *)v57 - 3) <= v19
              || (v375 = (llvm::Metadata *)v21,
                  v59 = llvm::CallBase::getBundleOpInfoForOperand((char *)v15, v19),
                  v21 = (uint64_t)v375,
                  *(_DWORD *)(*(_QWORD *)v59 + 8) != 6))
            {
              v7 = "Cannot invoke an intrinsic other than donothing, patchpoint, statepoint, coro_resume, coro_destroy or"
                   " clang.arc.attachedcall";
              goto LABEL_134;
            }
          }
LABEL_45:
          v31 = (uint64_t)v30[5];
          v32 = *(_QWORD *)(a1 + 8);
          if (v31 != v32)
          {
            __s1 = "Referencing function in another module!";
            v392 = 259;
            v384.i64[0] = (uint64_t)a2;
            v379 = v31;
            v380 = (llvm::Instruction *)v32;
            sub_1C62498E8((llvm::raw_ostream **)a1, (llvm::Twine *)&__s1, v384.i64, (uint64_t *)&v380, (uint64_t *)&v387, &v379);
            return;
          }
          goto LABEL_100;
        }
        if ((v23 & 0x40000000) != 0)
        {
          v34 = (*(a2 - 1))[v18];
          v41 = *((unsigned __int8 *)v34 + 16);
          if (v34 && v41 == 22)
            goto LABEL_67;
          if (v41 == 21)
          {
LABEL_93:
            if (v34[3] != *(_QWORD *)(v4 + 56))
            {
              v7 = "Referring to an argument in another function!";
              goto LABEL_134;
            }
            goto LABEL_100;
          }
          if (v41 >= 4)
            v52 = 0;
          else
            v52 = (uint64_t)(*(a2 - 1))[v18];
          v379 = v52;
          if (v52)
          {
LABEL_99:
            v53 = v34[5];
            v54 = *(_QWORD *)(a1 + 8);
            if (v53 != v54)
            {
              __s1 = "Referencing global in another module!";
              v392 = 259;
              v384.i64[0] = (uint64_t)a2;
              v380 = (llvm::Instruction *)v54;
              v378 = v53;
              sub_1C62498E8((llvm::raw_ostream **)a1, (llvm::Twine *)&__s1, v384.i64, (uint64_t *)&v380, &v379, &v378);
              return;
            }
            goto LABEL_100;
          }
          v33 = (uint64_t ***)*(a2 - 1);
          v38 = (unsigned __int8 *)v33[v18];
          v39 = v38[16];
          if (v39 < 0x1C)
            goto LABEL_58;
        }
        else
        {
          v33 = &a2[-4 * (v23 & 0x7FFFFFF)];
          v34 = (uint64_t *)v33[v18];
          v35 = *((unsigned __int8 *)v34 + 16);
          if (v34)
            v36 = v35 == 22;
          else
            v36 = 0;
          if (v36)
          {
LABEL_67:
            if (v34[7] != *(_QWORD *)(v4 + 56))
            {
              v7 = "Referring to a basic block in another function!";
              goto LABEL_134;
            }
            goto LABEL_100;
          }
          if (v35 == 21)
            goto LABEL_93;
          if (v35 >= 4)
            v37 = 0;
          else
            v37 = (uint64_t)v33[v18];
          v379 = v37;
          if (v37)
            goto LABEL_99;
          v38 = (unsigned __int8 *)v33[v18];
          v39 = v38[16];
          if (v39 <= 0x1B)
          {
LABEL_58:
            if (v39 == 24)
            {
              if (!v15 || &v33[v18] != (uint64_t ***)v20)
              {
                v7 = "Cannot take the address of an inline asm!";
                goto LABEL_134;
              }
              goto LABEL_100;
            }
            if (v39 == 5)
            {
              v65 = (*(_DWORD *)(*(_QWORD *)v38 + 8) & 0xFE) == 0x12
                  ? *(unsigned __int8 *)(**(_QWORD **)(*(_QWORD *)v38 + 16) + 8)
                  : *(_DWORD *)(*(_QWORD *)v38 + 8);
              if (v65 == 15)
              {
                v69 = (uint64_t)v38;
                v67 = v22;
                v68 = v21;
                sub_1C5453144(a1, v69);
                goto LABEL_132;
              }
            }
            goto LABEL_100;
          }
        }
        v384.i64[0] = (uint64_t)v38;
        if (v39 != 33 || *((_QWORD *)v38 - 12) != *((_QWORD *)v38 - 8))
        {
          if (*((_BYTE *)a2 + 16) != 83)
          {
            v372 = v22;
            v60 = v21;
            v61 = sub_1C477672C(v21, (uint64_t)v38);
            v21 = v60;
            v22 = v372;
            v62 = *(_QWORD *)(a1 + 280);
            if (v62 == *(_QWORD *)(a1 + 272))
              v63 = 292;
            else
              v63 = 288;
            if (v61 != (_QWORD *)(v62 + 8 * *(unsigned int *)(a1 + v63)))
              goto LABEL_100;
            v23 = *((_DWORD *)a2 + 5);
          }
          v376 = (llvm::Metadata *)v21;
          v64 = (v23 & 0x40000000) != 0
              ? (llvm::Instruction *)*(a2 - 1)
              : (llvm::Instruction *)&a2[-4 * (v23 & 0x7FFFFFF)];
          v66 = llvm::DominatorTree::dominates(v22, (const llvm::Value *)v38, (llvm::Instruction *)((char *)v64 + v18 * 8));
          v21 = (uint64_t)v376;
          if (!v66)
          {
            __s1 = "Instruction does not dominate all uses!";
            v392 = 259;
            v380 = (llvm::Instruction *)a2;
            v67 = v22;
            v68 = (uint64_t)v376;
            sub_1C6249880((llvm::raw_ostream **)a1, (llvm::Twine *)&__s1, v384.i64, (uint64_t *)&v380);
LABEL_132:
            v21 = v68;
            v22 = v67;
          }
        }
LABEL_100:
        ++v19;
        v18 += 4;
        if (v17 == v19)
        {
          v16 = *((_DWORD *)a2 + 5);
          break;
        }
      }
    }
    v72 = a2 >> 4;
    if ((v16 & 0x20000000) == 0)
    {
LABEL_153:
      if ((*((_DWORD *)a2 + 5) & 0x20000000) == 0)
        goto LABEL_365;
      v87 = ***a2;
      __s1 = a2;
      v88 = *(_DWORD *)(v87 + 2496);
      if (v88)
      {
        v89 = *(_QWORD *)(v87 + 2480);
        v90 = v88 - 1;
        v91 = v90 & (v72 ^ (a2 >> 9));
        v92 = (llvm::Instruction **)(v89 + 40 * v91);
        v93 = *v92;
        if (*v92 == (llvm::Instruction *)a2)
        {
LABEL_164:
          v98 = *((unsigned int *)v92 + 4);
          if (!(_DWORD)v98)
            goto LABEL_365;
          v99 = (_QWORD *)((char *)v92[1] + 8);
          v100 = 16 * v98;
          while (*((_DWORD *)v99 - 2) != 4)
          {
            v99 += 2;
            v100 -= 16;
            if (!v100)
              goto LABEL_365;
          }
          v103 = (llvm::Metadata *)*v99;
          if (!*v99)
            goto LABEL_365;
          v104 = *((unsigned __int8 *)a2 + 16) - 33;
          v12 = v104 > 0x33;
          v105 = (1 << v104) & 0x8000008000001;
          if (v12 || v105 == 0)
          {
            v7 = "Ranges are only for loads, calls and invokes!";
            goto LABEL_134;
          }
          v107 = *((unsigned int *)v103 + 2);
          if ((v107 & 1) != 0)
          {
            v171 = "Unfinished range!";
          }
          else
          {
            if (v107 > 1)
            {
              v370 = *((_DWORD *)v103 + 2);
              v108 = 0;
              v371 = v107 >> 1;
              v373 = *a2;
              v384.i32[2] = 1;
              v384.i64[0] = 1;
              v386 = 1;
              v385 = 1;
              v377 = v103;
              while (1)
              {
                v109 = (char *)v103 - 8 * *((unsigned int *)v103 + 2);
                v110 = *(_QWORD *)&v109[16 * v108];
                if (*(_BYTE *)v110 != 1 || (v111 = *(_QWORD *)(v110 + 128), *(_BYTE *)(v111 + 16) != 16))
                {
                  v172 = "The lower limit must be an integer!";
LABEL_362:
                  __s1 = v172;
                  v392 = 259;
                  sub_1C6249A24(a1, (llvm::Twine *)&__s1);
                  goto LABEL_363;
                }
                v112 = *(_QWORD *)&v109[(16 * v108) | 8];
                if (*(_BYTE *)v112 != 1 || (v113 = *(_QWORD *)(v112 + 128), *(_BYTE *)(v113 + 16) != 16))
                {
                  v172 = "The upper limit must be an integer!";
                  goto LABEL_362;
                }
                if (*(uint64_t ***)v113 != v373 || *(_QWORD *)v113 != *(_QWORD *)v111)
                {
                  __s1 = "Range types must match instruction type!";
                  v392 = 259;
                  sub_1C6249A24(a1, (llvm::Twine *)&__s1);
                  if (*(_QWORD *)a1)
                    sub_1C6249A88((llvm::raw_ostream **)a1, (uint64_t)a2);
                  goto LABEL_363;
                }
                v115 = *(unsigned int *)(v113 + 32);
                if (v115 > 0x40)
                {
                  v116 = (void *)operator new[]();
                  memcpy(v116, *(const void **)(v113 + 24), ((unint64_t)(v115 + 63) >> 3) & 0x3FFFFFF8);
                }
                else
                {
                  v116 = *(void **)(v113 + 24);
                }
                v117 = *(unsigned int *)(v111 + 32);
                if (v117 > 0x40)
                {
                  v120 = ((unint64_t)(v117 + 63) >> 3) & 0x3FFFFFF8;
                  v119 = operator new[]();
                  memcpy((void *)v119, *(const void **)(v111 + 24), v120);
                  v118 = operator new[]();
                  memcpy((void *)v118, (const void *)v119, v120);
                }
                else
                {
                  v118 = *(_QWORD *)(v111 + 24);
                  v119 = v118;
                }
                v121 = (uint64_t)v116;
                if (v115 >= 0x41)
                {
                  v121 = operator new[]();
                  memcpy((void *)v121, v116, ((unint64_t)(v115 + 63) >> 3) & 0x3FFFFFF8);
                }
                v381 = v117;
                v380 = (llvm::Instruction *)v118;
                v383 = v115;
                v382 = v121;
                if (v117 >= 0x41)
                {
                  if (!memcmp((const void *)v118, (const void *)v121, ((unint64_t)(v117 + 63) >> 3) & 0x3FFFFFF8))
                  {
                    v139 = 0;
                    v140 = (unint64_t)(v117 + 63) >> 6;
                    do
                    {
                      v12 = v140-- < 1;
                      if (v12)
                        break;
                      v141 = *(_QWORD *)(v118 + 8 * v140);
                      v139 += __clz(v141);
                    }
                    while (!v141);
                    v142 = v117 | 0xFFFFFFC0;
                    if ((v117 & 0x3F) == 0)
                      v142 = 0;
                    if (v139 + v142 == (_DWORD)v117)
                      goto LABEL_224;
                  }
                  if (!memcmp((const void *)v118, (const void *)v121, ((unint64_t)(v117 + 63) >> 3) & 0x3FFFFFF8)&& llvm::APInt::countTrailingOnesSlowCase((llvm::APInt *)&v380) == (_DWORD)v117)
                  {
LABEL_224:
                    v127 = "Range must not be empty!";
                    goto LABEL_216;
                  }
                }
                else
                {
                  if (!(v121 | v118))
                    goto LABEL_224;
                  if (v118 == v121 && (!(_DWORD)v117 || v118 == 0xFFFFFFFFFFFFFFFFLL >> -(char)v117))
                    goto LABEL_224;
                }
                if (!v108)
                  goto LABEL_231;
                llvm::ConstantRange::intersectWith((uint64_t)&v380, (llvm::ConstantRange *)&v384, 0, (uint64_t)&__s1);
                v122 = v389;
                if (v389 <= 0x40)
                  break;
                v138 = __s1;
                v123 = __s2;
                v369 = v389 + 63;
                if (!memcmp(__s1, __s2, (v369 >> 3) & 0x3FFFFFF8))
                {
                  v143 = 0;
                  v144 = v369 >> 6;
                  do
                  {
                    v12 = v144-- < 1;
                    if (v12)
                      break;
                    v145 = v138[v144];
                    v143 += __clz(v145);
                  }
                  while (!v145);
                  v146 = v122 | 0xFFFFFFC0;
                  if ((v122 & 0x3F) == 0)
                    v146 = 0;
                  v124 = v143 + v146 == v122;
                  goto LABEL_203;
                }
                v125 = 0;
LABEL_206:
                if (v391 >= 0x41 && v123 != 0)
                {
                  MEMORY[0x1CAA32F9C](v123, 0x1000C8000313F17);
                  v122 = v389;
                }
                if (v122 >= 0x41 && __s1)
                  MEMORY[0x1CAA32F9C](__s1, 0x1000C8000313F17);
                if ((v125 & 1) == 0)
                {
                  v127 = "Intervals are overlapping";
                  goto LABEL_216;
                }
                if (v117 > 0x40)
                {
                  v130 = *(_QWORD *)(v119 + 8 * ((v117 - 1) >> 6)) & (1 << (v117 - 1));
                  v131 = v384.i32[2] - 1;
                  v132 = &v384;
                  if (v384.i32[2] >= 0x41u)
                    v132 = (int8x16_t *)(v384.i64[0] + 8 * (v131 >> 6));
                  if ((v130 != 0) == (((unint64_t)v132->i64[0] >> v131) & 1))
                  {
                    v135 = ((unint64_t)(v117 + 63) >> 3) & 0x3FFFFFF8;
                    while (v135)
                    {
                      v136 = *(_QWORD *)(v119 - 8 + v135);
                      v137 = *(_QWORD *)(v384.i64[0] - 8 + v135);
                      v135 -= 8;
                      if (v136 != v137)
                      {
                        if (v136 <= v137)
                          break;
                        goto LABEL_230;
                      }
                    }
LABEL_215:
                    v127 = "Intervals are not in order";
                    goto LABEL_216;
                  }
                  if (v130)
                    goto LABEL_215;
                }
                else if (v119 << -(char)v117 >> -(char)v117 <= v384.i64[0] << -(char)v117 >> -(char)v117)
                {
                  goto LABEL_215;
                }
LABEL_230:
                if (!sub_1C5453470((uint64_t)&v380, (const void **)&v384))
                {
LABEL_231:
                  v133 = (void *)v119;
                  if (v117 >= 0x41)
                  {
                    v133 = (void *)operator new[]();
                    memcpy(v133, (const void *)v119, ((unint64_t)(v117 + 63) >> 3) & 0x3FFFFFF8);
                  }
                  v134 = v116;
                  if (v115 >= 0x41)
                  {
                    v134 = (void *)operator new[]();
                    memcpy(v134, v116, ((unint64_t)(v115 + 63) >> 3) & 0x3FFFFFF8);
                  }
                  if (v384.i32[2] >= 0x41u && v384.i64[0])
                    MEMORY[0x1CAA32F9C](v384.i64[0], 0x1000C8000313F17);
                  v384.i64[0] = (uint64_t)v133;
                  v384.i32[2] = v117;
                  if (v386 >= 0x41 && v385)
                    MEMORY[0x1CAA32F9C](v385, 0x1000C8000313F17);
                  v385 = (uint64_t)v134;
                  v386 = v115;
                  v128 = 1;
                  goto LABEL_238;
                }
                v127 = "Intervals are contiguous";
LABEL_216:
                __s1 = v127;
                v392 = 259;
                sub_1C6249A24(a1, (llvm::Twine *)&__s1);
                if (*(_QWORD *)a1)
                  sub_1C6249C6C((llvm::raw_ostream *)a1, (uint64_t **)v377);
                v128 = 0;
LABEL_238:
                if (v383 >= 0x41 && v382)
                  MEMORY[0x1CAA32F9C](v382, 0x1000C8000313F17);
                if (v381 >= 0x41 && v380)
                  MEMORY[0x1CAA32F9C](v380, 0x1000C8000313F17);
                if (v117 >= 0x41 && v119)
                  MEMORY[0x1CAA32F9C](v119, 0x1000C8000313F17);
                if (v115 >= 0x41 && v116)
                  MEMORY[0x1CAA32F9C](v116, 0x1000C8000313F17);
                v103 = v377;
                if ((v128 & 1) == 0)
                  goto LABEL_363;
                if (++v108 == v371)
                {
                  if (v370 < 6)
                    goto LABEL_363;
                  v155 = *((unsigned int *)v377 + 2);
                  if (*(_BYTE *)(*(_QWORD *)(*((_QWORD *)v377 - v155) + 128) + 16) == 16)
                    v156 = *(_QWORD *)(*((_QWORD *)v377 - v155) + 128);
                  else
                    v156 = 0;
                  v157 = *(unsigned int *)(v156 + 32);
                  if (v157 > 0x40)
                  {
                    v159 = (void *)operator new[]();
                    memcpy(v159, *(const void **)(v156 + 24), ((unint64_t)(v157 + 63) >> 3) & 0x3FFFFFF8);
                    v158 = -(uint64_t)*((unsigned int *)v377 + 2);
                  }
                  else
                  {
                    v158 = -v155;
                    v159 = *(void **)(v156 + 24);
                  }
                  v160 = *(_QWORD *)(*((_QWORD *)v377 + v158 + 1) + 128);
                  if (*(_BYTE *)(v160 + 16) == 16)
                    v161 = v160;
                  else
                    v161 = 0;
                  v162 = *(unsigned int *)(v161 + 32);
                  if (v162 > 0x40)
                  {
                    v163 = (void *)operator new[]();
                    memcpy(v163, *(const void **)(v161 + 24), ((unint64_t)(v162 + 63) >> 3) & 0x3FFFFFF8);
                  }
                  else
                  {
                    v163 = *(void **)(v161 + 24);
                  }
                  v164 = v159;
                  if (v157 >= 0x41)
                  {
                    v164 = (void *)operator new[]();
                    memcpy(v164, v159, ((unint64_t)(v157 + 63) >> 3) & 0x3FFFFFF8);
                  }
                  v165 = v163;
                  if (v162 >= 0x41)
                  {
                    v165 = (void *)operator new[]();
                    memcpy(v165, v163, ((unint64_t)(v162 + 63) >> 3) & 0x3FFFFFF8);
                  }
                  v381 = v157;
                  v380 = (llvm::Instruction *)v164;
                  v383 = v162;
                  v382 = (uint64_t)v165;
                  llvm::ConstantRange::intersectWith((uint64_t)&v380, (llvm::ConstantRange *)&v384, 0, (uint64_t)&__s1);
                  v166 = v389;
                  if (v389 <= 0x40)
                  {
                    v167 = __s2;
                    v168 = ((unint64_t)__s2 | (unint64_t)__s1) == 0;
                    goto LABEL_335;
                  }
                  v364 = __s1;
                  v167 = __s2;
                  if (!memcmp(__s1, __s2, (((unint64_t)v389 + 63) >> 3) & 0x3FFFFFF8))
                  {
                    v365 = 0;
                    v366 = (unint64_t)(v166 + 63) >> 6;
                    do
                    {
                      v12 = v366-- < 1;
                      if (v12)
                        break;
                      v367 = v364[v366];
                      v365 += __clz(v367);
                    }
                    while (!v367);
                    v368 = v166 | 0xFFFFFFC0;
                    if ((v166 & 0x3F) == 0)
                      v368 = 0;
                    v168 = v365 + v368 == (_DWORD)v166;
LABEL_335:
                    v169 = v168;
                  }
                  else
                  {
                    v169 = 0;
                  }
                  if (v391 >= 0x41 && v167 != 0)
                  {
                    MEMORY[0x1CAA32F9C](v167, 0x1000C8000313F17);
                    LODWORD(v166) = v389;
                  }
                  if (v166 >= 0x41 && __s1)
                    MEMORY[0x1CAA32F9C](__s1, 0x1000C8000313F17);
                  if ((v169 & 1) != 0)
                  {
                    if (!sub_1C5453470((uint64_t)&v380, (const void **)&v384))
                      goto LABEL_346;
                    v363 = "Intervals are contiguous";
                  }
                  else
                  {
                    v363 = "Intervals are overlapping";
                  }
                  __s1 = v363;
                  v392 = 259;
                  sub_1C6249A24(a1, (llvm::Twine *)&__s1);
                  if (*(_QWORD *)a1)
                    sub_1C6249C6C((llvm::raw_ostream *)a1, (uint64_t **)v377);
LABEL_346:
                  if (v383 >= 0x41 && v382)
                    MEMORY[0x1CAA32F9C](v382, 0x1000C8000313F17);
                  if (v381 >= 0x41 && v380)
                    MEMORY[0x1CAA32F9C](v380, 0x1000C8000313F17);
                  if (v162 >= 0x41 && v163)
                    MEMORY[0x1CAA32F9C](v163, 0x1000C8000313F17);
                  if (v157 >= 0x41 && v159)
                    MEMORY[0x1CAA32F9C](v159, 0x1000C8000313F17);
LABEL_363:
                  if (v386 >= 0x41 && v385)
                    MEMORY[0x1CAA32F9C](v385, 0x1000C8000313F17);
                  v72 = a2 >> 4;
                  if (v384.i32[2] >= 0x41u && v384.i64[0])
                    MEMORY[0x1CAA32F9C](v384.i64[0], 0x1000C8000313F17);
LABEL_365:
                  if ((*((_BYTE *)a2 + 23) & 0x20) != 0)
                  {
                    v173 = ***a2;
                    __s1 = a2;
                    v174 = *(_DWORD *)(v173 + 2496);
                    if (!v174)
                    {
                      v338 = 0;
                      goto LABEL_600;
                    }
                    v175 = *(_QWORD *)(v173 + 2480);
                    v176 = v174 - 1;
                    v177 = v176 & (v72 ^ (a2 >> 9));
                    v178 = (llvm::Instruction **)(v175 + 40 * v177);
                    v179 = *v178;
                    if (*v178 != (llvm::Instruction *)a2)
                    {
                      v180 = 0;
                      v181 = 1;
                      while (v179 != (llvm::Instruction *)-4096)
                      {
                        if (v180)
                          v182 = 0;
                        else
                          v182 = v179 == (llvm::Instruction *)-8192;
                        if (v182)
                          v180 = v178;
                        v183 = v177 + v181++;
                        v177 = v183 & v176;
                        v178 = (llvm::Instruction **)(v175 + 40 * v177);
                        v179 = *v178;
                        if (*v178 == (llvm::Instruction *)a2)
                          goto LABEL_376;
                      }
                      if (v180)
                        v338 = v180;
                      else
                        v338 = v178;
LABEL_600:
                      v178 = (llvm::Instruction **)sub_1C541AB24(v173 + 2480, (uint64_t)&__s1, (uint64_t *)&__s1, v338);
                      v339 = (llvm::Instruction *)__s1;
                      v178[3] = 0;
                      v178[4] = 0;
                      *v178 = v339;
                      v178[1] = (llvm::Instruction *)(v178 + 3);
                      v178[2] = (llvm::Instruction *)0x100000000;
                    }
LABEL_376:
                    v184 = *((unsigned int *)v178 + 4);
                    if ((_DWORD)v184)
                    {
                      v185 = (_QWORD *)((char *)v178[1] + 8);
                      v186 = 16 * v184;
                      while (*((_DWORD *)v185 - 2) != 16)
                      {
                        v185 += 2;
                        v186 -= 16;
                        if (!v186)
                          goto LABEL_383;
                      }
                      if (*v185 && ((_BYTE)a2[2] & 0xFE) != 0x3C)
                      {
                        v7 = "invariant.group metadata is only for loads and stores";
                        goto LABEL_134;
                      }
                    }
                  }
LABEL_383:
                  if ((*((_BYTE *)a2 + 23) & 0x20) != 0)
                  {
                    v187 = ***a2;
                    __s1 = a2;
                    v188 = *(_DWORD *)(v187 + 2496);
                    if (!v188)
                    {
                      v340 = 0;
                      goto LABEL_604;
                    }
                    v189 = *(_QWORD *)(v187 + 2480);
                    v190 = v188 - 1;
                    v191 = v190 & (v72 ^ (a2 >> 9));
                    v192 = (llvm::Instruction **)(v189 + 40 * v191);
                    v193 = *v192;
                    if (*v192 != (llvm::Instruction *)a2)
                    {
                      v194 = 0;
                      v195 = 1;
                      while (v193 != (llvm::Instruction *)-4096)
                      {
                        if (v194)
                          v196 = 0;
                        else
                          v196 = v193 == (llvm::Instruction *)-8192;
                        if (v196)
                          v194 = v192;
                        v197 = v191 + v195++;
                        v191 = v197 & v190;
                        v192 = (llvm::Instruction **)(v189 + 40 * v191);
                        v193 = *v192;
                        if (*v192 == (llvm::Instruction *)a2)
                          goto LABEL_394;
                      }
                      if (v194)
                        v340 = v194;
                      else
                        v340 = v192;
LABEL_604:
                      v192 = (llvm::Instruction **)sub_1C541AB24(v187 + 2480, (uint64_t)&__s1, (uint64_t *)&__s1, v340);
                      v341 = (llvm::Instruction *)__s1;
                      v192[3] = 0;
                      v192[4] = 0;
                      *v192 = v341;
                      v192[1] = (llvm::Instruction *)(v192 + 3);
                      v192[2] = (llvm::Instruction *)0x100000000;
                    }
LABEL_394:
                    v198 = *((unsigned int *)v192 + 4);
                    if ((_DWORD)v198)
                    {
                      v199 = (_QWORD *)((char *)v192[1] + 8);
                      v200 = 16 * v198;
                      while (*((_DWORD *)v199 - 2) != 11)
                      {
                        v199 += 2;
                        v200 -= 16;
                        if (!v200)
                          goto LABEL_402;
                      }
                      if (*v199)
                      {
                        if (*((_BYTE *)*a2 + 8) == 15)
                        {
                          if (*((_BYTE *)a2 + 16) == 60)
                            goto LABEL_402;
                          v7 = "nonnull applies only to load instructions, use attributes for calls or invokes";
                        }
                        else
                        {
                          v7 = "nonnull applies only to pointer types";
                        }
LABEL_134:
                        __s1 = v7;
                        v392 = 259;
                        sub_1C6249A24(a1, (llvm::Twine *)&__s1);
                        if (*(_QWORD *)a1)
                        {
                          v70 = (llvm::raw_ostream **)a1;
                          v71 = (llvm::Instruction *)a2;
                          goto LABEL_136;
                        }
                        return;
                      }
                    }
                  }
LABEL_402:
                  if ((*((_BYTE *)a2 + 23) & 0x20) != 0)
                  {
                    v201 = ***a2;
                    __s1 = a2;
                    v202 = *(_DWORD *)(v201 + 2496);
                    if (!v202)
                    {
                      v342 = 0;
                      goto LABEL_608;
                    }
                    v203 = *(_QWORD *)(v201 + 2480);
                    v204 = v202 - 1;
                    v205 = v204 & (v72 ^ (a2 >> 9));
                    v206 = (llvm::Instruction **)(v203 + 40 * v205);
                    v207 = *v206;
                    if (*v206 != (llvm::Instruction *)a2)
                    {
                      v208 = 0;
                      v209 = 1;
                      while (v207 != (llvm::Instruction *)-4096)
                      {
                        if (v208)
                          v210 = 0;
                        else
                          v210 = v207 == (llvm::Instruction *)-8192;
                        if (v210)
                          v208 = v206;
                        v211 = v205 + v209++;
                        v205 = v211 & v204;
                        v206 = (llvm::Instruction **)(v203 + 40 * v205);
                        v207 = *v206;
                        if (*v206 == (llvm::Instruction *)a2)
                          goto LABEL_413;
                      }
                      if (v208)
                        v342 = v208;
                      else
                        v342 = v206;
LABEL_608:
                      v206 = (llvm::Instruction **)sub_1C541AB24(v201 + 2480, (uint64_t)&__s1, (uint64_t *)&__s1, v342);
                      v343 = (llvm::Instruction *)__s1;
                      v206[3] = 0;
                      v206[4] = 0;
                      *v206 = v343;
                      v206[1] = (llvm::Instruction *)(v206 + 3);
                      v206[2] = (llvm::Instruction *)0x100000000;
                    }
LABEL_413:
                    v212 = *((unsigned int *)v206 + 4);
                    if ((_DWORD)v212)
                    {
                      v213 = (uint64_t *)((char *)v206[1] + 8);
                      v214 = 16 * v212;
                      while (*((_DWORD *)v213 - 2) != 12)
                      {
                        v213 += 2;
                        v214 -= 16;
                        if (!v214)
                          goto LABEL_420;
                      }
                      if (*v213)
                        sub_1C5453388((llvm::raw_ostream **)a1, (unsigned __int8 *)a2, *v213);
                    }
                  }
LABEL_420:
                  if ((*((_BYTE *)a2 + 23) & 0x20) != 0)
                  {
                    v215 = ***a2;
                    __s1 = a2;
                    v216 = *(_DWORD *)(v215 + 2496);
                    if (!v216)
                    {
                      v344 = 0;
                      goto LABEL_612;
                    }
                    v217 = *(_QWORD *)(v215 + 2480);
                    v218 = v216 - 1;
                    v219 = v218 & (v72 ^ (a2 >> 9));
                    v220 = (llvm::Instruction **)(v217 + 40 * v219);
                    v221 = *v220;
                    if (*v220 != (llvm::Instruction *)a2)
                    {
                      v222 = 0;
                      v223 = 1;
                      while (v221 != (llvm::Instruction *)-4096)
                      {
                        if (v222)
                          v224 = 0;
                        else
                          v224 = v221 == (llvm::Instruction *)-8192;
                        if (v224)
                          v222 = v220;
                        v225 = v219 + v223++;
                        v219 = v225 & v218;
                        v220 = (llvm::Instruction **)(v217 + 40 * v219);
                        v221 = *v220;
                        if (*v220 == (llvm::Instruction *)a2)
                          goto LABEL_431;
                      }
                      if (v222)
                        v344 = v222;
                      else
                        v344 = v220;
LABEL_612:
                      v220 = (llvm::Instruction **)sub_1C541AB24(v215 + 2480, (uint64_t)&__s1, (uint64_t *)&__s1, v344);
                      v345 = (llvm::Instruction *)__s1;
                      v220[3] = 0;
                      v220[4] = 0;
                      *v220 = v345;
                      v220[1] = (llvm::Instruction *)(v220 + 3);
                      v220[2] = (llvm::Instruction *)0x100000000;
                    }
LABEL_431:
                    v226 = *((unsigned int *)v220 + 4);
                    if ((_DWORD)v226)
                    {
                      v227 = (uint64_t *)((char *)v220[1] + 8);
                      v228 = 16 * v226;
                      while (*((_DWORD *)v227 - 2) != 13)
                      {
                        v227 += 2;
                        v228 -= 16;
                        if (!v228)
                          goto LABEL_438;
                      }
                      if (*v227)
                        sub_1C5453388((llvm::raw_ostream **)a1, (unsigned __int8 *)a2, *v227);
                    }
                  }
LABEL_438:
                  if ((*((_BYTE *)a2 + 23) & 0x20) != 0)
                  {
                    v229 = ***a2;
                    __s1 = a2;
                    v230 = *(_DWORD *)(v229 + 2496);
                    if (!v230)
                    {
                      v346 = 0;
                      goto LABEL_616;
                    }
                    v231 = *(_QWORD *)(v229 + 2480);
                    v232 = v230 - 1;
                    v233 = v232 & (v72 ^ (a2 >> 9));
                    v234 = (llvm::Instruction **)(v231 + 40 * v233);
                    v235 = *v234;
                    if (*v234 != (llvm::Instruction *)a2)
                    {
                      v236 = 0;
                      v237 = 1;
                      while (v235 != (llvm::Instruction *)-4096)
                      {
                        if (v236)
                          v238 = 0;
                        else
                          v238 = v235 == (llvm::Instruction *)-8192;
                        if (v238)
                          v236 = v234;
                        v239 = v233 + v237++;
                        v233 = v239 & v232;
                        v234 = (llvm::Instruction **)(v231 + 40 * v233);
                        v235 = *v234;
                        if (*v234 == (llvm::Instruction *)a2)
                          goto LABEL_449;
                      }
                      if (v236)
                        v346 = v236;
                      else
                        v346 = v234;
LABEL_616:
                      v234 = (llvm::Instruction **)sub_1C541AB24(v229 + 2480, (uint64_t)&__s1, (uint64_t *)&__s1, v346);
                      v347 = (llvm::Instruction *)__s1;
                      v234[3] = 0;
                      v234[4] = 0;
                      *v234 = v347;
                      v234[1] = (llvm::Instruction *)(v234 + 3);
                      v234[2] = (llvm::Instruction *)0x100000000;
                    }
LABEL_449:
                    v240 = *((unsigned int *)v234 + 4);
                    if ((_DWORD)v240)
                    {
                      v241 = (const llvm::MDNode **)((char *)v234[1] + 8);
                      v242 = 16 * v240;
                      while (*((_DWORD *)v241 - 2) != 1)
                      {
                        v241 += 2;
                        v242 -= 16;
                        if (!v242)
                          goto LABEL_456;
                      }
                      if (*v241)
                        llvm::TBAAVerifier::visitTBAAMetadata((llvm::raw_ostream ***)(a1 + 1960), (llvm::Instruction *)a2, *v241);
                    }
                  }
LABEL_456:
                  if ((*((_BYTE *)a2 + 23) & 0x20) != 0)
                  {
                    v243 = ***a2;
                    __s1 = a2;
                    v244 = *(_DWORD *)(v243 + 2496);
                    if (!v244)
                    {
                      v348 = 0;
                      goto LABEL_620;
                    }
                    v245 = *(_QWORD *)(v243 + 2480);
                    v246 = v244 - 1;
                    v247 = v246 & (v72 ^ (a2 >> 9));
                    v248 = (llvm::Instruction **)(v245 + 40 * v247);
                    v249 = *v248;
                    if (*v248 != (llvm::Instruction *)a2)
                    {
                      v250 = 0;
                      v251 = 1;
                      while (v249 != (llvm::Instruction *)-4096)
                      {
                        if (v250)
                          v252 = 0;
                        else
                          v252 = v249 == (llvm::Instruction *)-8192;
                        if (v252)
                          v250 = v248;
                        v253 = v247 + v251++;
                        v247 = v253 & v246;
                        v248 = (llvm::Instruction **)(v245 + 40 * v247);
                        v249 = *v248;
                        if (*v248 == (llvm::Instruction *)a2)
                          goto LABEL_467;
                      }
                      if (v250)
                        v348 = v250;
                      else
                        v348 = v248;
LABEL_620:
                      v248 = (llvm::Instruction **)sub_1C541AB24(v243 + 2480, (uint64_t)&__s1, (uint64_t *)&__s1, v348);
                      v349 = (llvm::Instruction *)__s1;
                      v248[3] = 0;
                      v248[4] = 0;
                      *v248 = v349;
                      v248[1] = (llvm::Instruction *)(v248 + 3);
                      v248[2] = (llvm::Instruction *)0x100000000;
                    }
LABEL_467:
                    v254 = *((unsigned int *)v248 + 4);
                    if ((_DWORD)v254)
                    {
                      v255 = (_QWORD *)((char *)v248[1] + 8);
                      v256 = 16 * v254;
                      while (*((_DWORD *)v255 - 2) != 25)
                      {
                        v255 += 2;
                        v256 -= 16;
                        if (!v256)
                          goto LABEL_471;
                      }
                      v299 = *v255;
                      if (*v255)
                      {
                        v300 = *(unsigned int *)(v299 + 8);
                        if ((_DWORD)v300)
                        {
                          v301 = -8 * v300;
                          while (1)
                          {
                            v302 = *(unsigned __int8 **)(v299 + v301);
                            if (*v302 - 4 >= 0x1F)
                            {
                              v337 = "Access scope list must consist of MDNodes";
                              goto LABEL_593;
                            }
                            if (*((_DWORD *)v302 + 2) || (v302[1] & 0x7F) != 1)
                              break;
                            v301 += 8;
                            if (!v301)
                              goto LABEL_471;
                          }
                          v337 = "Access scope list contains invalid access scope";
LABEL_593:
                          __s1 = v337;
                          v392 = 259;
                          sub_1C6249A24(a1, (llvm::Twine *)&__s1);
                          if (*(_QWORD *)a1)
                            sub_1C6249C6C((llvm::raw_ostream *)a1, (uint64_t **)v299);
                        }
                      }
                    }
                  }
LABEL_471:
                  if ((*((_BYTE *)a2 + 23) & 0x20) != 0)
                  {
                    v257 = ***a2;
                    __s1 = a2;
                    v258 = *(_DWORD *)(v257 + 2496);
                    if (!v258)
                    {
                      v350 = 0;
                      goto LABEL_624;
                    }
                    v259 = *(_QWORD *)(v257 + 2480);
                    v260 = v258 - 1;
                    v261 = v260 & (v72 ^ (a2 >> 9));
                    v262 = (llvm::Instruction **)(v259 + 40 * v261);
                    v263 = *v262;
                    if (*v262 != (llvm::Instruction *)a2)
                    {
                      v264 = 0;
                      v265 = 1;
                      while (v263 != (llvm::Instruction *)-4096)
                      {
                        if (v264)
                          v266 = 0;
                        else
                          v266 = v263 == (llvm::Instruction *)-8192;
                        if (v266)
                          v264 = v262;
                        v267 = v261 + v265++;
                        v261 = v267 & v260;
                        v262 = (llvm::Instruction **)(v259 + 40 * v261);
                        v263 = *v262;
                        if (*v262 == (llvm::Instruction *)a2)
                          goto LABEL_482;
                      }
                      if (v264)
                        v350 = v264;
                      else
                        v350 = v262;
LABEL_624:
                      v262 = (llvm::Instruction **)sub_1C541AB24(v257 + 2480, (uint64_t)&__s1, (uint64_t *)&__s1, v350);
                      v351 = (llvm::Instruction *)__s1;
                      v262[3] = 0;
                      v262[4] = 0;
                      *v262 = v351;
                      v262[1] = (llvm::Instruction *)(v262 + 3);
                      v262[2] = (llvm::Instruction *)0x100000000;
                    }
LABEL_482:
                    v268 = *((unsigned int *)v262 + 4);
                    if ((_DWORD)v268)
                    {
                      v269 = (_QWORD *)((char *)v262[1] + 8);
                      v270 = 16 * v268;
                      while (*((_DWORD *)v269 - 2) != 17)
                      {
                        v269 += 2;
                        v270 -= 16;
                        if (!v270)
                          goto LABEL_486;
                      }
                      v303 = *v269;
                      if (v303)
                      {
                        if (*((_BYTE *)*a2 + 8) != 15)
                        {
                          v7 = "align applies only to pointer types";
                          goto LABEL_134;
                        }
                        if (*((_BYTE *)a2 + 16) != 60)
                        {
                          v7 = "align applies only to load instructions, use attributes for calls or invokes";
                          goto LABEL_134;
                        }
                        if (*(_DWORD *)(v303 + 8) != 1)
                        {
                          v7 = "align takes one operand!";
                          goto LABEL_134;
                        }
                        v304 = *(_QWORD *)(v303 - 8);
                        if (*(_BYTE *)v304 != 1
                          || (v305 = *(int8x8_t **)(v304 + 128), v305[2].i8[0] != 16)
                          || *(_DWORD *)(*(_QWORD *)v305 + 8) != 16397)
                        {
                          v7 = "align metadata value must be an i64!";
                          goto LABEL_134;
                        }
                        v306 = v305 + 3;
                        if (v305[4].i32[0] >= 0x41u)
                          v306 = (int8x8_t *)*v306;
                        v307 = (uint8x8_t)vcnt_s8(*v306);
                        v307.i16[0] = vaddlv_u8(v307);
                        if (v307.u32[0] != 1)
                        {
                          v7 = "align metadata value must be a power of 2!";
                          goto LABEL_134;
                        }
                        if (*(_QWORD *)v306 >= 0x100000001uLL)
                        {
                          v7 = "alignment is larger that implementation defined limit";
                          goto LABEL_134;
                        }
                      }
                    }
                  }
LABEL_486:
                  if ((*((_BYTE *)a2 + 23) & 0x20) != 0)
                  {
                    v271 = ***a2;
                    __s1 = a2;
                    v272 = *(_DWORD *)(v271 + 2496);
                    if (!v272)
                    {
                      v352 = 0;
                      goto LABEL_628;
                    }
                    v273 = *(_QWORD *)(v271 + 2480);
                    v274 = v272 - 1;
                    v275 = v274 & (v72 ^ (a2 >> 9));
                    v276 = (llvm::Instruction **)(v273 + 40 * v275);
                    v277 = *v276;
                    if (*v276 != (llvm::Instruction *)a2)
                    {
                      v278 = 0;
                      v279 = 1;
                      while (v277 != (llvm::Instruction *)-4096)
                      {
                        if (v278)
                          v280 = 0;
                        else
                          v280 = v277 == (llvm::Instruction *)-8192;
                        if (v280)
                          v278 = v276;
                        v281 = v275 + v279++;
                        v275 = v281 & v274;
                        v276 = (llvm::Instruction **)(v273 + 40 * v275);
                        v277 = *v276;
                        if (*v276 == (llvm::Instruction *)a2)
                          goto LABEL_497;
                      }
                      if (v278)
                        v352 = v278;
                      else
                        v352 = v276;
LABEL_628:
                      v276 = (llvm::Instruction **)sub_1C541AB24(v271 + 2480, (uint64_t)&__s1, (uint64_t *)&__s1, v352);
                      v353 = (llvm::Instruction *)__s1;
                      v276[3] = 0;
                      v276[4] = 0;
                      *v276 = v353;
                      v276[1] = (llvm::Instruction *)(v276 + 3);
                      v276[2] = (llvm::Instruction *)0x100000000;
                    }
LABEL_497:
                    v282 = *((unsigned int *)v276 + 4);
                    if ((_DWORD)v282)
                    {
                      v283 = (_QWORD *)((char *)v276[1] + 8);
                      v284 = 16 * v282;
                      while (*((_DWORD *)v283 - 2) != 2)
                      {
                        v283 += 2;
                        v284 -= 16;
                        if (!v284)
                          goto LABEL_501;
                      }
                      v308 = *v283;
                      if (*v283)
                      {
                        v309 = *(unsigned int *)(v308 + 8);
                        if (v309 <= 1)
                        {
                          v356 = "!prof annotations should have no less than 2 operands";
                        }
                        else
                        {
                          v310 = *(_QWORD *)(v308 - 8 * v309);
                          if (v310)
                          {
                            if (*(_BYTE *)v310)
                            {
                              v356 = "expected string with name of the !prof annotation";
                            }
                            else
                            {
                              v311 = *(_QWORD **)(v310 + 8);
                              if (*v311 != 14)
                                goto LABEL_501;
                              v312 = v311[3];
                              v313 = *(_QWORD *)((char *)v311 + 30);
                              if (v312 != 0x775F68636E617262 || v313 != 0x737468676965775FLL)
                                goto LABEL_501;
                              v315 = *((unsigned __int8 *)a2 + 16);
                              switch(*((_BYTE *)a2 + 16))
                              {
                                case 0x1E:
                                  if ((*((_DWORD *)a2 + 5) & 0x7FFFFFF) == 3)
                                    v316 = 2;
                                  else
                                    v316 = 1;
                                  goto LABEL_663;
                                case 0x1F:
                                  v316 = (*((_DWORD *)a2 + 5) >> 1) & 0x3FFFFFF;
                                  goto LABEL_663;
                                case 0x20:
                                  v316 = (*((_DWORD *)a2 + 5) & 0x7FFFFFF) - 1;
                                  goto LABEL_663;
                                case 0x21:
                                  if ((v309 & 0xFFFFFFFE) == 2)
                                  {
                                    v358 = -v309;
                                    goto LABEL_666;
                                  }
                                  v356 = "Wrong number of InvokeInst branch_weights operands";
                                  break;
                                default:
                                  if (v315 == 84)
                                  {
                                    v316 = 1;
                                  }
                                  else if (v315 == 85)
                                  {
                                    v316 = 2;
                                  }
                                  else
                                  {
                                    __s1 = "!prof branch_weights are not allowed for this instruction";
                                    v392 = 259;
                                    sub_1C6249A24(a1, (llvm::Twine *)&__s1);
                                    if (*(_QWORD *)a1)
                                      sub_1C6249C6C((llvm::raw_ostream *)a1, (uint64_t **)v308);
                                    v316 = 0;
                                    LODWORD(v309) = *(_DWORD *)(v308 + 8);
                                  }
LABEL_663:
                                  if ((_DWORD)v309 == v316 + 1)
                                  {
                                    if (v309 < 2)
                                      goto LABEL_501;
                                    v358 = -(uint64_t)v309;
                                    v309 = v309;
LABEL_666:
                                    v359 = 8 * v358 + 8;
                                    v360 = v309 - 1;
                                    while (1)
                                    {
                                      v361 = *(_QWORD *)(v308 + v359);
                                      if (!v361)
                                        break;
                                      if (*(_BYTE *)v361 != 1 || *(_BYTE *)(*(_QWORD *)(v361 + 128) + 16) != 16)
                                      {
                                        __s1 = "!prof brunch_weights operand is not a const int";
                                        v392 = 259;
                                        sub_1C6249A24(a1, (llvm::Twine *)&__s1);
                                        goto LABEL_501;
                                      }
                                      v359 += 8;
                                      if (!--v360)
                                        goto LABEL_501;
                                    }
                                    v356 = "second operand should not be null";
                                  }
                                  else
                                  {
                                    v356 = "Wrong number of operands";
                                  }
                                  break;
                              }
                            }
                          }
                          else
                          {
                            v356 = "first operand should not be null";
                          }
                        }
                        __s1 = v356;
                        v392 = 259;
                        sub_1C6249A24(a1, (llvm::Twine *)&__s1);
                        if (*(_QWORD *)a1)
                          sub_1C6249C6C((llvm::raw_ostream *)a1, (uint64_t **)v308);
                      }
                    }
                  }
LABEL_501:
                  if ((*((_BYTE *)a2 + 23) & 0x20) != 0)
                  {
                    v285 = ***a2;
                    __s1 = a2;
                    v286 = *(_DWORD *)(v285 + 2496);
                    if (!v286)
                    {
                      v354 = 0;
                      goto LABEL_632;
                    }
                    v287 = *(_QWORD *)(v285 + 2480);
                    v288 = v286 - 1;
                    v289 = v288 & (v72 ^ (a2 >> 9));
                    v290 = (llvm::Instruction **)(v287 + 40 * v289);
                    v291 = *v290;
                    if (*v290 != (llvm::Instruction *)a2)
                    {
                      v292 = 0;
                      v293 = 1;
                      while (v291 != (llvm::Instruction *)-4096)
                      {
                        if (v292)
                          v294 = 0;
                        else
                          v294 = v291 == (llvm::Instruction *)-8192;
                        if (v294)
                          v292 = v290;
                        v295 = v289 + v293++;
                        v289 = v295 & v288;
                        v290 = (llvm::Instruction **)(v287 + 40 * v289);
                        v291 = *v290;
                        if (*v290 == (llvm::Instruction *)a2)
                          goto LABEL_512;
                      }
                      if (v292)
                        v354 = v292;
                      else
                        v354 = v290;
LABEL_632:
                      v290 = (llvm::Instruction **)sub_1C541AB24(v285 + 2480, (uint64_t)&__s1, (uint64_t *)&__s1, v354);
                      v355 = (llvm::Instruction *)__s1;
                      v290[3] = 0;
                      v290[4] = 0;
                      *v290 = v355;
                      v290[1] = (llvm::Instruction *)(v290 + 3);
                      v290[2] = (llvm::Instruction *)0x100000000;
                    }
LABEL_512:
                    v296 = *((unsigned int *)v290 + 4);
                    if ((_DWORD)v296)
                    {
                      v297 = (_QWORD *)((char *)v290[1] + 8);
                      v298 = 16 * v296;
                      while (*((_DWORD *)v297 - 2) != 30)
                      {
                        v297 += 2;
                        v298 -= 16;
                        if (!v298)
                          goto LABEL_557;
                      }
                      v317 = *v297;
                      if (v317)
                      {
                        if (*(_BYTE *)v317 == 4)
                        {
                          v318 = *(unsigned int *)(v317 + 8);
                          if ((_DWORD)v318)
                          {
                            v319 = -8 * v318;
                            while (!**(_BYTE **)(v317 + v319))
                            {
                              v319 += 8;
                              if (!v319)
                                goto LABEL_557;
                            }
                            v357 = "operands must be strings";
                          }
                          else
                          {
                            v357 = "annotation must have at least one operand";
                          }
                        }
                        else
                        {
                          v357 = "annotation must be a tuple";
                        }
                        __s1 = v357;
                        v392 = 259;
                        sub_1C6249A24(a1, (llvm::Twine *)&__s1);
                      }
                    }
                  }
LABEL_557:
                  v320 = a2[6];
                  if (v320)
                  {
                    if (*(_BYTE *)v320 != 5)
                    {
                      __s1 = "invalid !dbg metadata attachment";
                      v392 = 259;
                      sub_1C6249CD4(a1, (llvm::Twine *)&__s1);
                      if (*(_QWORD *)a1)
                      {
                        sub_1C6249A88((llvm::raw_ostream **)a1, (uint64_t)a2);
                        sub_1C6249C6C((llvm::raw_ostream *)a1, v320);
                      }
                      return;
                    }
                    sub_1C5448E64((_QWORD *)a1, (uint64_t)a2[6]);
                  }
                  if (sub_1C53923FC((uint64_t)a2))
                  {
                    v321 = *((_DWORD *)a2 + 5) & 0x7FFFFFF;
                    v322 = -v321;
                    v323 = &a2[-4 * v321];
                    v324 = v323[4][3];
                    if (v324)
                    {
                      if (*(_BYTE *)v324 == 25)
                        v325 = (llvm::DIVariable *)v323[4][3];
                      else
                        v325 = 0;
                    }
                    else
                    {
                      v325 = 0;
                    }
                    v326 = (unsigned __int8 *)v323[8][3];
                    if (v326)
                    {
                      v327 = *v326;
                      v328 = v327 == 6 ? (uint64_t **)v326 : 0;
                      if (v325)
                      {
                        if (v327 == 6 && llvm::DIExpression::isValid((llvm::DIExpression *)v328))
                        {
                          llvm::DIExpression::getFragmentInfo(v328[3], v328[4], &v384);
                          if ((_BYTE)v385)
                          {
                            if ((*((_BYTE *)v325 + 36) & 0x40) == 0)
                            {
                              v329 = v384.i32[0];
                              v330 = v384.i32[2];
                              v380 = (llvm::Instruction *)a2;
                              SizeInBits = llvm::DIVariable::getSizeInBits(v325);
                              if (!v332)
                                goto LABEL_578;
                              if ((v330 + v329) > SizeInBits)
                              {
                                v362 = "fragment is larger than or outside of variable";
                              }
                              else
                              {
                                if (SizeInBits != v329)
                                  goto LABEL_578;
                                v362 = "fragment covers entire variable";
                              }
                              v387 = (uint64_t **)v325;
                              __s1 = v362;
                              v392 = 259;
                              sub_1C62499C4((llvm::raw_ostream **)a1, (llvm::Twine *)&__s1, (uint64_t *)&v380, &v387);
LABEL_578:
                              v322 = -(uint64_t)(*((_DWORD *)a2 + 5) & 0x7FFFFFF);
                            }
                          }
                        }
                      }
                    }
                    v333 = (llvm::DIExpression *)a2[4 * v322 + 8][3];
                    if (v333)
                    {
                      if (*(_BYTE *)v333 == 6 && llvm::DIExpression::isValid(v333))
                      {
                        v334 = (_QWORD *)*((_QWORD *)v333 + 3);
                        if (((*((_QWORD *)v333 + 4) - (_QWORD)v334) & 0x7FFFFFFF8) != 0 && *v334 == 4099)
                        {
                          __s1 = "Entry values are only allowed in MIR";
                          v392 = 259;
                          sub_1C6249CD4(a1, (llvm::Twine *)&__s1);
                          if (*(_QWORD *)a1)
                            sub_1C6249A88((llvm::raw_ostream **)a1, (uint64_t)a2);
                        }
                      }
                    }
                  }
                  __s1 = &__s2;
                  v389 = 0x400000000;
                  if (a2[6] || (*((_BYTE *)a2 + 23) & 0x20) != 0)
                  {
                    llvm::Instruction::getAllMetadataImpl((uint64_t)a2, (uint64_t)&__s1);
                    if ((_DWORD)v389)
                    {
                      v335 = (char *)__s1;
                      v336 = (char *)__s1 + 16 * v389;
                      do
                      {
                        sub_1C5448E64((_QWORD *)a1, *((_QWORD *)v335 + 1));
                        v335 += 16;
                      }
                      while (v335 != v336);
                    }
                  }
                  sub_1C4774094((llvm::SmallPtrSetImplBase *)(a1 + 272), (uint64_t)a2);
                  if (__s1 != &__s2)
                    free(__s1);
                  return;
                }
              }
              v123 = __s2;
              v124 = ((unint64_t)__s2 | (unint64_t)__s1) == 0;
LABEL_203:
              v125 = v124;
              goto LABEL_206;
            }
            v171 = "It should have at least one range!";
          }
          __s1 = v171;
          v392 = 259;
          sub_1C6249A24(a1, (llvm::Twine *)&__s1);
          if (*(_QWORD *)a1)
            sub_1C6249C6C((llvm::raw_ostream *)a1, (uint64_t **)v103);
          goto LABEL_365;
        }
        v94 = 0;
        v95 = 1;
        while (v93 != (llvm::Instruction *)-4096)
        {
          if (v94)
            v96 = 0;
          else
            v96 = v93 == (llvm::Instruction *)-8192;
          if (v96)
            v94 = v92;
          v97 = v91 + v95++;
          v91 = v97 & v90;
          v92 = (llvm::Instruction **)(v89 + 40 * v91);
          v93 = *v92;
          if (*v92 == (llvm::Instruction *)a2)
            goto LABEL_164;
        }
        if (v94)
          v153 = v94;
        else
          v153 = v92;
      }
      else
      {
        v153 = 0;
      }
      v92 = (llvm::Instruction **)sub_1C541AB24(v87 + 2480, (uint64_t)&__s1, (uint64_t *)&__s1, v153);
      v154 = (llvm::Instruction *)__s1;
      v92[3] = 0;
      v92[4] = 0;
      *v92 = v154;
      v92[1] = (llvm::Instruction *)(v92 + 3);
      v92[2] = (llvm::Instruction *)0x100000000;
      goto LABEL_164;
    }
    v73 = ***a2;
    __s1 = a2;
    v74 = *(_DWORD *)(v73 + 2496);
    if (v74)
    {
      v75 = *(_QWORD *)(v73 + 2480);
      v76 = v74 - 1;
      v77 = v76 & (v72 ^ (a2 >> 9));
      v78 = (llvm::Instruction **)(v75 + 40 * v77);
      v79 = *v78;
      if (*v78 == (llvm::Instruction *)a2)
        goto LABEL_149;
      v80 = 0;
      v81 = 1;
      while (v79 != (llvm::Instruction *)-4096)
      {
        if (v80)
          v82 = 0;
        else
          v82 = v79 == (llvm::Instruction *)-8192;
        if (v82)
          v80 = v78;
        v83 = v77 + v81++;
        v77 = v83 & v76;
        v78 = (llvm::Instruction **)(v75 + 40 * v77);
        v79 = *v78;
        if (*v78 == (llvm::Instruction *)a2)
          goto LABEL_149;
      }
      if (v80)
        v151 = v80;
      else
        v151 = v78;
    }
    else
    {
      v151 = 0;
    }
    v78 = (llvm::Instruction **)sub_1C541AB24(v73 + 2480, (uint64_t)&__s1, (uint64_t *)&__s1, v151);
    v152 = (llvm::Instruction *)__s1;
    v78[3] = 0;
    v78[4] = 0;
    *v78 = v152;
    v78[1] = (llvm::Instruction *)(v78 + 3);
    v78[2] = (llvm::Instruction *)0x100000000;
LABEL_149:
    v84 = *((unsigned int *)v78 + 4);
    if ((_DWORD)v84)
    {
      v85 = (_QWORD *)((char *)v78[1] + 8);
      v86 = 16 * v84;
      while (*((_DWORD *)v85 - 2) != 3)
      {
        v85 += 2;
        v86 -= 16;
        if (!v86)
          goto LABEL_153;
      }
      v101 = *v85;
      if (v101)
      {
        if (((_DWORD)(*a2)[1] & 0xFE) == 0x12)
          v102 = *(unsigned __int8 *)(*(*a2)[2] + 8);
        else
          v102 = *((_DWORD *)*a2 + 2);
        if (v102 >= 7)
        {
          v7 = "fpmath requires a floating point result!";
          goto LABEL_134;
        }
        if (*(_DWORD *)(v101 + 8) != 1)
        {
          v7 = "fpmath takes one operand!";
          goto LABEL_134;
        }
        v147 = *(_QWORD *)(v101 - 8);
        if (!v147 || *(_BYTE *)v147 != 1 || (v148 = *(_QWORD *)(v147 + 128), *(_BYTE *)(v148 + 16) != 17))
        {
          v7 = "invalid fpmath accuracy!";
          goto LABEL_134;
        }
        if (*(_UNKNOWN **)(v148 + 32) != &unk_1C866F184)
        {
          v7 = "fpmath accuracy must have float type";
          goto LABEL_134;
        }
        v149 = *(_BYTE *)(v148 + 52);
        v150 = (v149 & 7u) > 3 || (v149 & 7) == 2;
        if (!v150 || (v149 & 8) != 0)
        {
          v7 = "fpmath accuracy not a positive number!";
          goto LABEL_134;
        }
      }
    }
    goto LABEL_153;
  }
  while (1)
  {
    v10 = (uint64_t)v9[3];
    if (*(unsigned __int8 *)(v10 + 16) <= 0x1Bu)
      v10 = 0;
    v384.i64[0] = v10;
    if (!v10)
      break;
    if (!*(_QWORD *)(v10 + 40))
    {
      __s1 = "Instruction referencing instruction not embedded in a basic block!";
      v392 = 259;
      v380 = (llvm::Instruction *)a2;
      sub_1C6249880((llvm::raw_ostream **)a1, (llvm::Twine *)&__s1, (uint64_t *)&v380, v384.i64);
      return;
    }
    v9 = (uint64_t **)v9[1];
    if (!v9)
      goto LABEL_21;
  }
  __s1 = "Use of instruction is not an instruction!";
  v392 = 259;
  sub_1C6249A24(a1, (llvm::Twine *)&__s1);
  if (*(_QWORD *)a1)
  {
    v71 = (llvm::Instruction *)*v9;
    if (*v9)
    {
      v70 = (llvm::raw_ostream **)a1;
LABEL_136:
      sub_1C6249A88(v70, (uint64_t)v71);
    }
  }
}

void sub_1C5453144(uint64_t a1, uint64_t a2)
{
  llvm::SmallPtrSetImplBase *v4;
  char v5;
  unsigned int v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  char v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD v24[4];
  __int16 v25;
  void *v26;
  unsigned int v27;
  unsigned int v28;
  _QWORD v29[17];

  v29[16] = *MEMORY[0x1E0C80C00];
  v23 = a2;
  v4 = (llvm::SmallPtrSetImplBase *)(a1 + 904);
  sub_1C4774094((llvm::SmallPtrSetImplBase *)(a1 + 904), a2);
  if (!v5)
    return;
  v26 = v29;
  v28 = 16;
  v29[0] = a2;
  v6 = 1;
  while (1)
  {
    v7 = *((_QWORD *)v26 + v6 - 1);
    v27 = v6 - 1;
    if (v7)
      v8 = *(_BYTE *)(v7 + 16) == 5;
    else
      v8 = 0;
    if (v8
      && *(_WORD *)(v7 + 18) == 49
      && !llvm::CastInst::castIsValid(49, **(llvm::Type ***)(v7 - 32 * (*(_DWORD *)(v7 + 20) & 0x7FFFFFF)), *(_QWORD *)v7))
    {
      v24[0] = "Invalid bitcast";
      v25 = 259;
      sub_1C6249A24(a1, (llvm::Twine *)v24);
      if (*(_QWORD *)a1)
        sub_1C6249A88((llvm::raw_ostream **)a1, v7);
    }
    v9 = *(unsigned __int8 *)(v7 + 16) >= 4u ? 0 : v7;
    v22 = v9;
    if (v9)
      break;
    v12 = *(_DWORD *)(v7 + 20);
    if ((v12 & 0x40000000) != 0)
    {
      v14 = *(uint64_t **)(v7 - 8);
      v13 = v12 & 0x7FFFFFF;
      if (v13)
      {
LABEL_21:
        v15 = 32 * v13;
        do
        {
          v16 = *v14;
          if (*v14)
            v17 = *(unsigned __int8 *)(*v14 + 16) > 0x14u;
          else
            v17 = 1;
          if (!v17)
          {
            sub_1C4774094(v4, *v14);
            if (v18)
            {
              v19 = v27;
              if (v27 >= (unint64_t)v28)
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, (uint64_t)v29, v27 + 1, 8);
                v19 = v27;
              }
              *((_QWORD *)v26 + v19) = v16;
              ++v27;
            }
          }
          v14 += 4;
          v15 -= 32;
        }
        while (v15);
      }
    }
    else
    {
      v13 = v12 & 0x7FFFFFF;
      v14 = (uint64_t *)(v7 - 32 * v13);
      if (v13)
        goto LABEL_21;
    }
LABEL_15:
    v6 = v27;
    if (!v27)
      goto LABEL_35;
  }
  v10 = *(_QWORD *)(v9 + 40);
  v11 = *(_QWORD *)(a1 + 8);
  if (v10 == v11)
    goto LABEL_15;
  v24[0] = "Referencing global in another module!";
  v25 = 259;
  v20 = v10;
  v21 = v11;
  sub_1C62498E8((llvm::raw_ostream **)a1, (llvm::Twine *)v24, &v23, &v21, &v22, &v20);
LABEL_35:
  if (v26 != v29)
    free(v26);
}

void sub_1C5453388(llvm::raw_ostream **a1, unsigned __int8 *a2, uint64_t a3)
{
  int v5;
  uint64_t v6;
  _BYTE *v7;
  const char *v8;
  const char *v9;
  __int16 v10;

  if (*(_BYTE *)(*(_QWORD *)a2 + 8) != 15)
  {
    v8 = "dereferenceable, dereferenceable_or_null apply only to pointer types";
    goto LABEL_12;
  }
  v5 = a2[16];
  if (v5 != 60 && v5 != 76)
  {
    v8 = "dereferenceable, dereferenceable_or_null apply only to load and inttoptr instructions, use attributes for calls or invokes";
LABEL_12:
    v9 = v8;
    v10 = 259;
    sub_1C6249A24((uint64_t)a1, (llvm::Twine *)&v9);
    if (*a1)
      sub_1C6249A88(a1, (uint64_t)a2);
    return;
  }
  if (*(_DWORD *)(a3 + 8) != 1)
  {
    v8 = "dereferenceable, dereferenceable_or_null take one operand!";
    goto LABEL_12;
  }
  v6 = *(_QWORD *)(a3 - 8);
  if (*(_BYTE *)v6 != 1 || (v7 = *(_BYTE **)(v6 + 128), v7[16] != 16) || *(_DWORD *)(*(_QWORD *)v7 + 8) != 16397)
  {
    v8 = "dereferenceable, dereferenceable_or_null metadata value must be an i64!";
    goto LABEL_12;
  }
}

BOOL sub_1C5453470(uint64_t a1, const void **a2)
{
  uint64_t v4;
  uint64_t v6;

  v4 = *(unsigned int *)(a1 + 24);
  if (v4 > 0x40)
  {
    if (!memcmp(*(const void **)(a1 + 16), *a2, ((unint64_t)(v4 + 63) >> 3) & 0x3FFFFFF8))
      return 1;
  }
  else if (*(const void **)(a1 + 16) == *a2)
  {
    return 1;
  }
  v6 = *(unsigned int *)(a1 + 8);
  if (v6 > 0x40)
    return memcmp(*(const void **)a1, a2[2], ((unint64_t)(v6 + 63) >> 3) & 0x3FFFFFF8) == 0;
  else
    return *(_QWORD *)a1 == (_QWORD)a2[2];
}

void sub_1C545350C(llvm::Type *a1, uint64_t a2)
{
  llvm::raw_ostream **v3;
  llvm::Value **v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  int v9;
  unint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  llvm::Type **v19;
  llvm::Type *v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  llvm::Value *v28;
  llvm::Value *v29;
  unsigned int v30;
  int v31;
  uint64_t v32;
  llvm::Value *v33;
  int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  unsigned int v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t *v61;
  unint64_t v62;
  int v63;
  uint64_t v64;
  uint64_t *v65;
  uint64_t v66;
  const char *v67;
  uint64_t v68;
  int v69;
  char v70;
  unint64_t v71;
  uint64_t i;
  int v73;
  uint64_t v74;
  int v75;
  int v76;
  uint64_t v77;
  llvm::Type *v78;
  _BYTE *v79;
  char v80;
  llvm::Value *v81;
  int v82;
  uint64_t v83;
  int v84;
  int v85;
  uint64_t v86;
  unsigned int v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  int v92;
  llvm::Value *v93;
  int v94;
  int v95;
  int v96;
  char v97;
  llvm::Value *v98;
  uint64_t ***v99;
  uint64_t v100;
  int v101;
  uint64_t v102;
  int v103;
  unsigned int v104;
  uint64_t ****v105;
  uint64_t ***v106;
  uint64_t ****v107;
  int v108;
  BOOL v109;
  unsigned int v110;
  uint64_t v111;
  _QWORD *v112;
  uint64_t v113;
  llvm::Value *v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  int v121;
  uint64_t v122;
  int v123;
  unsigned int v124;
  llvm::Value **v125;
  llvm::Value *v126;
  llvm::Value **v127;
  int v128;
  BOOL v129;
  unsigned int v130;
  uint64_t v131;
  _QWORD *v132;
  uint64_t v133;
  const char *v134;
  const char *v135;
  uint64_t ****v136;
  uint64_t v137;
  llvm::raw_ostream **v138;
  const char *v139;
  llvm::Value **v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  unint64_t v153;
  uint64_t v154;
  char v155;
  uint64_t v156;
  uint64_t v157;
  unsigned int *v158;
  uint64_t v159;
  _QWORD **v160;
  uint64_t v161;
  unsigned int v162;
  _BYTE *v164;
  uint64_t v165;
  uint64_t v166;
  int v167;
  uint64_t v168;
  _BYTE *v169;
  int v170;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  _QWORD *v176;
  _BYTE *v177;
  int v178;
  int v179;
  const char *v180;
  uint64_t *v181;
  const void *v182;
  uint64_t v183;
  uint64_t v184;
  const char *v185;
  size_t v186;
  uint64_t v187;
  const char *v188;
  char v189;
  uint64_t v190;
  uint64_t v191;
  char v192;
  char v193;
  char v194;
  char v195;
  uint64_t v197;
  uint64_t v198;
  llvm::Type *v199[2];
  uint64_t v200[4];
  __int16 v201;

  v3 = (llvm::raw_ostream **)a1;
  v4 = (llvm::Value **)(a2 - 32);
  v5 = **(_QWORD **)(a2 - 32);
  if (*(_BYTE *)(v5 + 8) != 15)
  {
    v134 = "Called function must be a pointer!";
    goto LABEL_252;
  }
  v6 = *(_QWORD *)(a2 + 72);
  v7 = *(_QWORD *)(v5 + 24);
  if (v7)
    v8 = v7 == v6;
  else
    v8 = 1;
  if (!v8)
  {
    v134 = "Called function is not the same type as the call!";
    goto LABEL_252;
  }
  v9 = *(unsigned __int8 *)(a2 + 16);
  if (*(_DWORD *)(v6 + 8) < 0x100u)
  {
    if (v9 == 84)
    {
      v15 = 0;
    }
    else if (v9 == 39)
    {
      v15 = (*(_DWORD *)(a2 + 80) + 1);
    }
    else
    {
      v15 = 2;
    }
    v11 = *(_DWORD *)(a2 + 20);
    if (v11 < 0 && (v151 = a2 - 32 * (v11 & 0x7FFFFFF), v152 = *(_QWORD *)(v151 - 8), (v152 & 0xFFFFFFFF0) != 0))
    {
      v13 = -(uint64_t)(v11 & 0x7FFFFFF);
      v16 = *(_DWORD *)(v151 - 12) - *(_DWORD *)(v151 - v152);
    }
    else
    {
      v16 = 0;
      v13 = -(uint64_t)(v11 & 0x7FFFFFF);
    }
    v10 = (-32 * v15 + 32 * (unint64_t)-v16 - 32 * v13 - 32) >> 5;
    if (*(_DWORD *)(v6 + 12) - 1 != (_DWORD)v10)
    {
      v134 = "Incorrect number of arguments passed to called function!";
      goto LABEL_252;
    }
  }
  else
  {
    if (v9 == 84)
    {
      v10 = 0;
    }
    else if (v9 == 39)
    {
      v10 = (*(_DWORD *)(a2 + 80) + 1);
    }
    else
    {
      v10 = 2;
    }
    v11 = *(_DWORD *)(a2 + 20);
    if (v11 < 0 && (v149 = a2 - 32 * (v11 & 0x7FFFFFF), v150 = *(_QWORD *)(v149 - 8), (v150 & 0xFFFFFFFF0) != 0))
    {
      v13 = -(uint64_t)(v11 & 0x7FFFFFF);
      v12 = *(_DWORD *)(v149 - 12) - *(_DWORD *)(v149 - v150);
    }
    else
    {
      v12 = 0;
      v13 = -(uint64_t)(v11 & 0x7FFFFFF);
    }
    v14 = (-32 * v10 + 32 * -v12 - 32 * v13 - 32) >> 5;
    LODWORD(v10) = *(_DWORD *)(v6 + 12) - 1;
    if (v10 > v14)
    {
      v134 = "Called function requires more parameters than were provided!";
      goto LABEL_252;
    }
  }
  v17 = 0;
  v18 = a2 + 32 * v13;
  while ((_DWORD)v10 != v17)
  {
    v19 = *(llvm::Type ***)(v18 + 32 * v17++);
    v20 = *(llvm::Type **)(*(_QWORD *)(v6 + 16) + 8 * v17);
    if (*v19 != v20)
    {
      v200[0] = (uint64_t)"Call parameter type does not match function signature!";
      v201 = 259;
      v199[0] = v20;
      sub_1C6249A24((uint64_t)a1, (llvm::Twine *)v200);
      if (*v3)
        sub_1C624A014(v3, (uint64_t)v19, v199, a2);
      return;
    }
  }
  v21 = *(_QWORD *)(a2 + 64);
  if (v9 == 84)
  {
    v22 = 0;
  }
  else if (v9 == 39)
  {
    v22 = (*(_DWORD *)(a2 + 80) + 1);
  }
  else
  {
    v22 = 2;
  }
  if (v11 < 0
    && (v143 = a2 - 32 * (v11 & 0x7FFFFFF),
        v146 = *(_QWORD *)(v143 - 8),
        v144 = v143 - 8,
        v145 = v146,
        (v146 & 0xFFFFFFFF0) != 0))
  {
    v23 = *(_DWORD *)(a2 - 32 * (v11 & 0x7FFFFFF) - 12) - *(_DWORD *)(v144 - v145 + 8);
    if (!v21)
      goto LABEL_29;
  }
  else
  {
    v23 = 0;
    if (!v21)
      goto LABEL_29;
  }
  if (*(_DWORD *)(v21 + 8) > ((-32 * v22
                                            + 32 * -v23
                                            - 32 * (unint64_t)-(v11 & 0x7FFFFFF)
                                            - 32) >> 5)
                            + 2)
  {
    v134 = "Attribute after last parameter!";
    goto LABEL_252;
  }
LABEL_29:
  v199[0] = a1;
  v199[1] = (llvm::Type *)a2;
  v24 = **(_QWORD **)(v6 + 16);
  v200[0] = (uint64_t)"return type";
  v201 = 259;
  sub_1C54549A8((uint64_t *)v199, v24, v200);
  if (*(_DWORD *)(v6 + 12) != 1)
  {
    v25 = 0;
    v26 = 8 * (*(_DWORD *)(v6 + 12) - 1);
    do
    {
      v27 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + v25 + 8);
      v200[0] = (uint64_t)"argument passed";
      v201 = 259;
      sub_1C54549A8((uint64_t *)v199, v27, v200);
      v25 += 8;
    }
    while (v26 != v25);
  }
  v28 = llvm::Value::stripPointerCasts(*v4);
  if (*((_BYTE *)v28 + 16))
    v29 = 0;
  else
    v29 = v28;
  if (v29)
  {
    v30 = *((_DWORD *)v29 + 8);
    v3 = (llvm::raw_ostream **)a1;
    if ((v30 & 0x2000) != 0 && *((_QWORD *)v29 + 3) != v6)
    {
      v134 = "Intrinsic called with incompatible signature";
      goto LABEL_252;
    }
    v31 = (v30 >> 13) & 1;
    if (v21)
    {
      if ((*(_BYTE *)(v21 + 19) & 1) != 0)
      {
        v32 = *((_QWORD *)v29 + 14);
        if (!v32 || (*(_BYTE *)(v32 + 19) & 1) == 0)
          goto LABEL_211;
      }
      goto LABEL_46;
    }
LABEL_50:
    v33 = *v4;
    goto LABEL_51;
  }
  v3 = (llvm::raw_ostream **)a1;
  if (!v21)
  {
    LOBYTE(v31) = 0;
    goto LABEL_50;
  }
  if ((*(_BYTE *)(v21 + 19) & 1) != 0)
  {
LABEL_211:
    v134 = "speculatable attribute may not apply to call sites";
    goto LABEL_252;
  }
  LOBYTE(v31) = 0;
LABEL_46:
  v33 = *v4;
  if ((*(_BYTE *)(v21 + 21) & 1) == 0)
  {
LABEL_51:
    v34 = *((unsigned __int8 *)v33 + 16);
    goto LABEL_52;
  }
  if (*((_DWORD *)v33 + 9) != 10)
  {
    v135 = "preallocated as a call site attribute can only be on llvm.call.preallocated.arg";
    goto LABEL_245;
  }
  v34 = 0;
LABEL_52:
  sub_1C5447FA8(v3, v6, v21, a2, v31, v34 == 24);
  v35 = *(unsigned __int8 *)(a2 + 16);
  if (v35 == 84)
  {
    v36 = 0;
  }
  else
  {
    if (v35 == 39)
      v36 = (*(_DWORD *)(a2 + 80) + 1);
    else
      v36 = 2;
    v3 = (llvm::raw_ostream **)a1;
  }
  v37 = 0;
  v38 = *(_DWORD *)(a2 + 20);
  if (v38 < 0)
  {
    v147 = a2 - 32 * (v38 & 0x7FFFFFF);
    v148 = *(_QWORD *)(v147 - 8);
    if ((v148 & 0xFFFFFFFF0) != 0)
      v37 = (*(_DWORD *)(v147 - 12) - *(_DWORD *)(v147 - v148));
    else
      v37 = 0;
    v3 = (llvm::raw_ostream **)a1;
  }
  v39 = a2 - 32 * v36 - 32 * v37 - 32;
  v40 = a2 - 32 * (v38 & 0x7FFFFFF);
  if (v39 == v40)
    goto LABEL_65;
  if (v35 == 84)
  {
    v41 = 0;
    if ((v38 & 0x80000000) == 0)
    {
LABEL_58:
      v42 = 0;
      goto LABEL_59;
    }
  }
  else
  {
    if (v35 == 39)
      v41 = (*(_DWORD *)(a2 + 80) + 1);
    else
      v41 = 2;
    v3 = (llvm::raw_ostream **)a1;
    if ((v38 & 0x80000000) == 0)
      goto LABEL_58;
  }
  v187 = *(_QWORD *)(v40 - 8);
  if ((v187 & 0xFFFFFFFF0) != 0)
    v42 = *(_DWORD *)(v40 - 12) - *(_DWORD *)(v40 - v187);
  else
    v42 = 0;
  v3 = (llvm::raw_ostream **)a1;
LABEL_59:
  if (llvm::CallBase::paramHasAttr(a2, ((a2 - 32 * v41 + 32 * (unint64_t)-v42 - v40 - 32) >> 5) - 1, 71))
  {
    v43 = llvm::Value::stripInBoundsOffsets(*(_QWORD *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF) + 32 * (*(_DWORD *)(v6 + 12) - 2)), (void (*)(uint64_t, uint64_t))nullsub_615, (uint64_t)v200);
    v44 = *(_BYTE *)(v43 + 16) == 59 ? v43 : 0;
    v198 = v44;
    if (v44)
    {
      if ((*(_WORD *)(v44 + 18) & 0x40) == 0)
      {
        v200[0] = (uint64_t)"inalloca argument for call has mismatched alloca";
        v201 = 259;
        sub_1C6249C0C(v3, (llvm::Twine *)v200, &v198, a2);
        return;
      }
    }
  }
LABEL_65:
  v193 = v31;
  v45 = *(_DWORD *)(v6 + 12);
  v46 = (v45 - 1);
  if (v45 != 1)
  {
    v47 = 0;
    do
    {
      if (llvm::CallBase::paramHasAttr(a2, v47, 63))
      {
        v48 = *(_QWORD *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF) + 32 * v47);
        v198 = v48;
        v49 = llvm::Value::stripInBoundsOffsets(v48, (void (*)(uint64_t, uint64_t))nullsub_615, (uint64_t)v200);
        if (*(_BYTE *)(v49 + 16) == 59)
          v50 = v49;
        else
          v50 = 0;
        v197 = v50;
        if (v50)
        {
          if ((*(_WORD *)(v50 + 18) & 0x80) != 0)
          {
            v51 = 30;
LABEL_82:
            if (v51 != 30)
              return;
            v55 = v47 + 1;
            goto LABEL_96;
          }
          v200[0] = (uint64_t)"swifterror argument for call has mismatched alloca";
          v201 = 259;
          sub_1C6249C0C((llvm::raw_ostream **)a1, (llvm::Twine *)v200, &v197, a2);
LABEL_81:
          v51 = 1;
          goto LABEL_82;
        }
        if (*(_BYTE *)(v48 + 16) == 21)
          v52 = v48;
        else
          v52 = 0;
        v197 = v52;
        if (!v52)
        {
          v200[0] = (uint64_t)"swifterror argument should come from an alloca or parameter";
          v201 = 259;
          sub_1C6249C0C((llvm::raw_ostream **)a1, (llvm::Twine *)v200, &v198, a2);
          goto LABEL_81;
        }
        v53 = *(_QWORD *)(*(_QWORD *)(v52 + 24) + 112);
        if (!v53
          || (v54 = *(_DWORD *)(v52 + 32) + 2, v54 >= *(_DWORD *)(v53 + 8))
          || (v56 = *(_QWORD *)(v53 + 8 * v54 + 40)) == 0
          || (*(char *)(v56 + 19) & 0x80000000) == 0)
        {
          v200[0] = (uint64_t)"swifterror argument for call has mismatched parameter";
          v201 = 259;
          sub_1C6249C0C((llvm::raw_ostream **)a1, (llvm::Twine *)v200, &v197, a2);
          goto LABEL_81;
        }
      }
      v55 = v47 + 1;
      if (v21)
      {
        if ((v47 + 2) < *(_DWORD *)(v21 + 8))
        {
          v58 = *(_QWORD *)(v21 + 40 + 8 * (v47 + 2));
          if (v58)
          {
            if ((*(_BYTE *)(v58 + 13) & 2) != 0
              && (!v29
               || (v59 = *((_QWORD *)v29 + 14)) == 0
               || (v47 + 2) >= *(_DWORD *)(v59 + 8)
               || (v60 = *(_QWORD *)(v59 + 8 * (v47 + 2) + 40)) == 0
               || (*(_BYTE *)(v60 + 13) & 2) == 0))
            {
              v200[0] = (uint64_t)"immarg may not apply only to call sites";
              v201 = 259;
              v198 = *(_QWORD *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF) + 32 * v47);
LABEL_250:
              sub_1C6249C0C((llvm::raw_ostream **)a1, (llvm::Twine *)v200, &v198, a2);
              return;
            }
          }
        }
      }
      if (llvm::CallBase::paramHasAttr(a2, v47, 9))
      {
        v198 = *(_QWORD *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF) + 32 * v47);
        if ((*(_BYTE *)(v198 + 16) & 0xFE) != 0x10)
        {
          v67 = "immarg operand has non-immediate parameter";
          goto LABEL_249;
        }
      }
      if (llvm::CallBase::paramHasAttr(a2, v47, 72))
      {
        v57 = *(_DWORD *)(a2 + 20);
        v198 = *(_QWORD *)(a2 - 32 * (v57 & 0x7FFFFFF) + 32 * v47);
        if (v57 < 0
          && (v61 = (unint64_t *)(a2 - 8 - 32 * (v57 & 0x7FFFFFF)), v62 = *v61, (*v61 & 0xFFFFFFFF0) != 0))
        {
          v63 = 0;
          v64 = (v62 >> 4);
          v65 = (uint64_t *)((char *)v61 - v62);
          do
          {
            v66 = *v65;
            v65 += 2;
            if (*(_DWORD *)(v66 + 8) == 4)
              ++v63;
            --v64;
          }
          while (v64);
          if (*(_BYTE *)(a2 + 16) == 84)
          {
            if ((v63 == 0) != ((*(_WORD *)(a2 + 18) & 3) == 2))
              goto LABEL_115;
          }
          else if (!v63)
          {
            goto LABEL_115;
          }
        }
        else if (*(_BYTE *)(a2 + 16) != 84 || (*(_WORD *)(a2 + 18) & 3) != 2)
        {
LABEL_115:
          v67 = "preallocated operand either requires a preallocated bundle or the call to be musttail (but not both)";
LABEL_249:
          v200[0] = (uint64_t)v67;
          v201 = 259;
          goto LABEL_250;
        }
      }
LABEL_96:
      v47 = v55;
    }
    while (v55 != v46);
  }
  if (*(_DWORD *)(v6 + 8) >= 0x100u)
  {
    v68 = (*(_DWORD *)(v6 + 12) - 1);
    if (*(_DWORD *)(v6 + 12) == 1)
    {
      v69 = 0;
      v70 = 0;
    }
    else
    {
      v115 = 0;
      v70 = 0;
      v69 = 0;
      v116 = v21 + 40;
      do
      {
        if (v21 && (v115 + 2) < *(_DWORD *)(v21 + 8))
        {
          v118 = *(_QWORD *)(v116 + 8 * (v115 + 2));
          if (v118)
            LODWORD(v118) = (*(unsigned __int8 *)(v118 + 14) >> 2) & 1;
          v69 |= v118;
          v117 = *(_QWORD *)(v116 + 8 * (v115 + 2));
          if (v117)
            LODWORD(v117) = (*(unsigned __int8 *)(v117 + 17) >> 6) & 1;
        }
        else
        {
          LOBYTE(v117) = 0;
        }
        ++v115;
        v70 |= v117;
      }
      while (v68 != v115);
    }
    v71 = v68;
    v191 = a2 - 8;
    for (i = a2 + 32 * v68; ; i += 32)
    {
      v73 = *(unsigned __int8 *)(a2 + 16);
      if (v73 == 84)
      {
        v74 = 0;
      }
      else if (v73 == 39)
      {
        v74 = (*(_DWORD *)(a2 + 80) + 1);
      }
      else
      {
        v74 = 2;
      }
      v75 = *(_DWORD *)(a2 + 20);
      if (v75 < 0 && (v88 = v75 & 0x7FFFFFF, (*(_QWORD *)(v191 - 32 * v88) & 0xFFFFFFFF0) != 0))
      {
        v77 = -v88;
        v76 = *(_DWORD *)(a2 - 32 * v88 - 12) - *(_DWORD *)(a2 - 32 * v88 - *(_QWORD *)(a2 - 32 * v88 - 8));
      }
      else
      {
        v76 = 0;
        v77 = -(uint64_t)(v75 & 0x7FFFFFF);
      }
      if (v71 >= (((unint64_t)&v4[4 * -v76] + -a2 + -32 * v74 + -32 * v77) >> 5))
        goto LABEL_161;
      v78 = **(llvm::Type ***)(i + 32 * v77);
      if (!v21 || (v71 + 2) >= *(_DWORD *)(v21 + 8))
        break;
      v79 = *(_BYTE **)(v21 + 40 + 8 * (v71 + 2));
      sub_1C544ABD0((llvm::raw_ostream **)a1, (uint64_t)v79, (uint64_t)v78, a2);
      if (!v79)
        goto LABEL_128;
      v87 = v79[14] & 4;
      if ((v69 & (v87 >> 2)) == 1)
      {
        v139 = "More than one parameter has attribute nest!";
        goto LABEL_262;
      }
      v69 |= v87 >> 2;
      if ((v79[17] & 0x40) != 0)
      {
        if ((v70 & 1) != 0)
        {
          v139 = "More than one parameter has attribute returned!";
          goto LABEL_262;
        }
        if (!llvm::Type::canLosslesslyBitCastTo(v78, **(llvm::Type ***)(v6 + 16)))
        {
          v139 = "Incompatible argument and return types for 'returned' attribute";
LABEL_262:
          v200[0] = (uint64_t)v139;
          v201 = 259;
          v3 = (llvm::raw_ostream **)a1;
LABEL_253:
          sub_1C6249A24((uint64_t)v3, (llvm::Twine *)v200);
          if (*v3)
          {
            v138 = v3;
            goto LABEL_256;
          }
          return;
        }
        v80 = 0;
        v70 = 1;
      }
      else
      {
        v80 = 0;
      }
LABEL_129:
      v81 = *v4;
      if (*v4 && !*((_BYTE *)v81 + 16) && *((_QWORD *)v81 + 3) == *(_QWORD *)(a2 + 72) && *((_DWORD *)v81 + 9) == 124)
      {
        if ((v80 & 1) != 0)
          goto LABEL_143;
      }
      else
      {
        if ((v80 & 1) != 0)
          goto LABEL_143;
        if ((v79[21] & 2) != 0)
        {
          v139 = "Attribute 'sret' cannot be used for vararg call arguments!";
          goto LABEL_262;
        }
      }
      if ((char)v79[20] < 0)
      {
        v82 = *(unsigned __int8 *)(a2 + 16);
        if (v82 == 84)
          v83 = 0;
        else
          v83 = v82 == 39 ? (*(_DWORD *)(a2 + 80) + 1) : 2;
        v84 = *(_DWORD *)(a2 + 20);
        if (v84 < 0 && (v89 = v84 & 0x7FFFFFF, (*(_QWORD *)(v191 - 32 * v89) & 0xFFFFFFFF0) != 0))
        {
          v86 = -v89;
          v85 = *(_DWORD *)(a2 - 32 * v89 - 12) - *(_DWORD *)(a2 - 32 * v89 - *(_QWORD *)(a2 - 32 * v89 - 8));
        }
        else
        {
          v85 = 0;
          v86 = -(uint64_t)(v84 & 0x7FFFFFF);
        }
        if (v71 != (((unint64_t)&v4[4 * -v85] + -a2 + -32 * v83 + -32 * v86) >> 5)
                  - 1)
        {
          v139 = "inalloca isn't on the last argument!";
          goto LABEL_262;
        }
      }
LABEL_143:
      ++v71;
    }
    sub_1C544ABD0((llvm::raw_ostream **)a1, 0, (uint64_t)v78, a2);
    v79 = 0;
LABEL_128:
    v80 = 1;
    goto LABEL_129;
  }
LABEL_161:
  v3 = (llvm::raw_ostream **)a1;
  if ((v193 & 1) == 0 && 8 * *(unsigned int *)(v6 + 12) != 8)
  {
    v90 = *(_QWORD *)(v6 + 16) + 8;
    v91 = 8 * ((8 * *(unsigned int *)(v6 + 12) - 8) >> 3);
    while (1)
    {
      v92 = *(unsigned __int8 *)(*(_QWORD *)v90 + 8);
      if (v92 == 12)
      {
        v134 = "Function has token parameter but isn't an intrinsic";
        goto LABEL_252;
      }
      if (v92 == 9)
        break;
      v90 += 8;
      v91 -= 8;
      if (!v91)
        goto LABEL_167;
    }
    v134 = "Function has metadata parameter but isn't an intrinsic";
    goto LABEL_252;
  }
LABEL_167:
  v93 = *v4;
  if (*v4 && !*((_BYTE *)v93 + 16) && *((_QWORD *)v93 + 3) == *(_QWORD *)(a2 + 72))
    goto LABEL_175;
  v94 = *(unsigned __int8 *)(**(_QWORD **)(v6 + 16) + 8);
  if (v94 == 11)
  {
    v135 = "Return type cannot be x86_amx for indirect call!";
    goto LABEL_245;
  }
  if (v94 == 12)
  {
    v135 = "Return type cannot be token for indirect call!";
LABEL_245:
    v200[0] = (uint64_t)v135;
    v201 = 259;
    sub_1C6249A24((uint64_t)v3, (llvm::Twine *)v200);
    return;
  }
  if (v93 && !*((_BYTE *)v93 + 16) && *((_QWORD *)v93 + 3) == *(_QWORD *)(a2 + 72))
  {
LABEL_175:
    v95 = *((_DWORD *)v93 + 9);
    if (v95)
      sub_1C5454B04((uint64_t)a1, v95, a2);
  }
  v96 = *(_DWORD *)(a2 + 20);
  if ((v96 & 0x80000000) == 0)
  {
    v97 = 0;
LABEL_179:
    v98 = *v4;
    if (*v4 && !*((_BYTE *)v98 + 16) && ((*((_QWORD *)v98 + 3) == *(_QWORD *)(a2 + 72)) & v97) == 1)
    {
      v134 = "Direct call cannot have a ptrauth bundle";
LABEL_252:
      v200[0] = (uint64_t)v134;
      v201 = 259;
      goto LABEL_253;
    }
    v99 = *(uint64_t ****)(*(_QWORD *)(a2 + 40) + 56);
    if ((*((_BYTE *)v99 + 23) & 0x20) == 0)
      goto LABEL_197;
    v100 = ***v99;
    v200[0] = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 56);
    v101 = *(_DWORD *)(v100 + 2496);
    if (v101)
    {
      v102 = *(_QWORD *)(v100 + 2480);
      v103 = v101 - 1;
      v104 = v103 & ((v99 >> 4) ^ (v99 >> 9));
      v105 = (uint64_t ****)(v102 + 40 * v104);
      v106 = *v105;
      if (*v105 == v99)
      {
LABEL_193:
        v111 = *((unsigned int *)v105 + 4);
        if (!(_DWORD)v111)
          goto LABEL_197;
        v112 = v105[1] + 1;
        v113 = 16 * v111;
        while (*((_DWORD *)v112 - 2))
        {
          v112 += 2;
          v113 -= 16;
          if (!v113)
            goto LABEL_197;
        }
        v119 = *v112;
        v114 = *v4;
        if (!v119 || *((_BYTE *)v114 + 16) || *((_QWORD *)v114 + 3) != *(_QWORD *)(a2 + 72))
          goto LABEL_198;
        if ((*((_BYTE *)v114 + 23) & 0x20) == 0)
        {
LABEL_197:
          v114 = *v4;
LABEL_198:
          if (*((_BYTE *)v114 + 16) == 24)
            sub_1C5458310(v3, a2);
          sub_1C5450C74((uint64_t)v3, (uint64_t ***)a2);
          return;
        }
        v120 = ***(_QWORD ***)v114;
        v200[0] = (uint64_t)*v4;
        v121 = *(_DWORD *)(v120 + 2496);
        if (v121)
        {
          v122 = *(_QWORD *)(v120 + 2480);
          v123 = v121 - 1;
          v124 = v123 & ((v114 >> 4) ^ (v114 >> 9));
          v125 = (llvm::Value **)(v122 + 40 * v124);
          v126 = *v125;
          if (*v125 == v114)
          {
LABEL_227:
            v131 = *((unsigned int *)v125 + 4);
            if ((_DWORD)v131)
            {
              v132 = (_QWORD *)((char *)v125[1] + 8);
              v133 = 16 * v131;
              while (*((_DWORD *)v132 - 2))
              {
                v132 += 2;
                v133 -= 16;
                if (!v133)
                  goto LABEL_197;
              }
              if (*v132 && *(_QWORD *)(a2 + 48) == 0)
              {
                v200[0] = (uint64_t)"inlinable function call in a function with debug info must have a !dbg location";
                v201 = 259;
                sub_1C6249CD4((uint64_t)v3, (llvm::Twine *)v200);
                goto LABEL_269;
              }
            }
            goto LABEL_197;
          }
          v127 = 0;
          v128 = 1;
          while (v126 != (llvm::Value *)-4096)
          {
            if (v127)
              v129 = 0;
            else
              v129 = v126 == (llvm::Value *)-8192;
            if (v129)
              v127 = v125;
            v130 = v124 + v128++;
            v124 = v130 & v123;
            v125 = (llvm::Value **)(v122 + 40 * v124);
            v126 = *v125;
            if (*v125 == v114)
              goto LABEL_227;
          }
          if (v127)
            v141 = v127;
          else
            v141 = v125;
        }
        else
        {
          v141 = 0;
        }
        v125 = (llvm::Value **)sub_1C541AB24(v120 + 2480, (uint64_t)v200, v200, v141);
        v142 = v200[0];
        v125[3] = 0;
        v125[4] = 0;
        *v125 = (llvm::Value *)v142;
        v125[1] = (llvm::Value *)(v125 + 3);
        v125[2] = (llvm::Value *)0x100000000;
        goto LABEL_227;
      }
      v107 = 0;
      v108 = 1;
      while (v106 != (uint64_t ***)-4096)
      {
        if (v107)
          v109 = 0;
        else
          v109 = v106 == (uint64_t ***)-8192;
        if (v109)
          v107 = v105;
        v110 = v104 + v108++;
        v104 = v110 & v103;
        v105 = (uint64_t ****)(v102 + 40 * v104);
        v106 = *v105;
        if (*v105 == v99)
          goto LABEL_193;
      }
      if (v107)
        v136 = v107;
      else
        v136 = v105;
    }
    else
    {
      v136 = 0;
    }
    v105 = (uint64_t ****)sub_1C541AB24(v100 + 2480, (uint64_t)v200, v200, v136);
    v137 = v200[0];
    v105[3] = 0;
    v105[4] = 0;
    *v105 = (uint64_t ***)v137;
    v105[1] = (uint64_t ***)(v105 + 3);
    v105[2] = (uint64_t ***)0x100000000;
    goto LABEL_193;
  }
  v153 = *(_QWORD *)(a2 - 32 * (v96 & 0x7FFFFFF) - 8);
  if ((v153 & 0xFFFFFFFF0) == 0)
  {
    v97 = 0;
    v3 = (llvm::raw_ostream **)a1;
    goto LABEL_179;
  }
  v154 = 0;
  v155 = 0;
  v97 = 0;
  v194 = 0;
  v195 = 0;
  v189 = 0;
  v190 = 0;
  v192 = 0;
  v156 = (v153 >> 4);
  while (2)
  {
    v157 = *(_DWORD *)(a2 + 20) & 0x7FFFFFF;
    v158 = (unsigned int *)(a2 - 8 - 32 * v157 - *(_QWORD *)(a2 - 8 - 32 * v157) + 16 * v154);
    v159 = *(unsigned int *)(a2 - 32 * v157 - *(_QWORD *)(a2 - 8 - 32 * v157) + 16 * v154);
    v160 = (_QWORD **)(a2 - 32 * v157 + 32 * v159);
    v161 = v158[3] - v159;
    switch(*(_DWORD *)(*(_QWORD *)v158 + 8))
    {
      case 0:
        if ((v192 & 1) == 0)
        {
          v192 = 1;
          goto LABEL_367;
        }
        v188 = "Multiple deopt operand bundles";
        goto LABEL_396;
      case 1:
        if ((v190 & 1) != 0)
        {
          v188 = "Multiple funclet operand bundles";
          goto LABEL_396;
        }
        if (v161 != 1)
        {
          v188 = "Expected exactly one funclet bundle operand";
          goto LABEL_396;
        }
        v162 = *((unsigned __int8 *)*v160 + 16);
        if (v162 < 0x1C || v162 - 79 >= 2)
        {
          v188 = "Funclet bundle operands should correspond to a FuncletPadInst";
          goto LABEL_396;
        }
        LOBYTE(v190) = 1;
        goto LABEL_367;
      case 2:
        if ((v194 & 1) != 0)
        {
          v188 = "Multiple gc-transition operand bundles";
          goto LABEL_396;
        }
        v194 = 1;
        goto LABEL_367;
      case 3:
        if ((v190 & 0x100000000) != 0)
        {
          v188 = "Multiple CFGuardTarget operand bundles";
          goto LABEL_396;
        }
        if (v161 != 1)
        {
          v188 = "Expected exactly one cfguardtarget bundle operand";
          goto LABEL_396;
        }
        BYTE4(v190) = 1;
        goto LABEL_367;
      case 4:
        if ((v189 & 1) != 0)
        {
          v188 = "Multiple preallocated operand bundles";
          goto LABEL_396;
        }
        if (v161 != 1)
        {
          v188 = "Expected exactly one preallocated bundle operand";
          goto LABEL_396;
        }
        v164 = *v160;
        if (*((_BYTE *)*v160 + 16) != 84
          || (v165 = *((_QWORD *)v164 - 4)) == 0
          || *(_BYTE *)(v165 + 16)
          || *(_QWORD *)(v165 + 24) != *((_QWORD *)v164 + 9)
          || (*(_DWORD *)(v165 + 32) & 0x2000) == 0
          || *(_DWORD *)(v165 + 36) != 11)
        {
          v188 = "\"preallocated\" argument must be a token from llvm.call.preallocated.setup";
          goto LABEL_396;
        }
        v189 = 1;
        goto LABEL_367;
      case 5:
        if ((v195 & 1) != 0)
        {
          v188 = "Multiple gc-live operand bundles";
          goto LABEL_396;
        }
        v195 = 1;
        goto LABEL_367;
      case 6:
        if ((v155 & 1) != 0)
        {
          v188 = "Multiple \"clang.arc.attachedcall\" operand bundles";
          goto LABEL_396;
        }
        v166 = *(_QWORD *)(a2 + 72);
        v167 = *(unsigned __int8 *)(**(_QWORD **)(v166 + 16) + 8);
        if (v167 == 15)
          goto LABEL_332;
        v168 = *(_QWORD *)(a2 + 64);
        if (v168 && (*(_BYTE *)(v168 + 16) & 1) != 0)
          goto LABEL_331;
        if (!llvm::CallBase::hasFnAttrOnCalledFunction(a2, 32))
          goto LABEL_354;
        v167 = *(unsigned __int8 *)(**(_QWORD **)(v166 + 16) + 8);
LABEL_331:
        if (v167 != 7)
        {
LABEL_354:
          v180 = "a call with operand bundle \"clang.arc.attachedcall\" must call a function returning a pointer or a non"
                 "-returning function that has a void return type";
          goto LABEL_364;
        }
LABEL_332:
        if (v161 != 1 || (v169 = *v160, *((_BYTE *)*v160 + 16)))
        {
          v180 = "operand bundle \"clang.arc.attachedcall\" requires one function as an argument";
          goto LABEL_364;
        }
        v170 = *((_DWORD *)v169 + 9);
        if ((v170 - 212) <= 0x17 && ((1 << (v170 + 44)) & 0x804001) != 0)
          goto LABEL_366;
        if (v170 || (v169[23] & 0x10) == 0)
          goto LABEL_363;
        v172 = ***(_QWORD ***)v169;
        v173 = *(_QWORD *)(v172 + 152);
        v174 = *(unsigned int *)(v172 + 168);
        if (!(_DWORD)v174)
          goto LABEL_355;
        LODWORD(v175) = (v174 - 1) & ((v169 >> 4) ^ (v169 >> 9));
        v176 = (_QWORD *)(v173 + 16 * v175);
        v177 = (_BYTE *)*v176;
        if ((_BYTE *)*v176 != v169)
        {
          v178 = 1;
          while (v177 != (_BYTE *)-4096)
          {
            v179 = v175 + v178++;
            v175 = v179 & (v174 - 1);
            v177 = *(_BYTE **)(v173 + 16 * v175);
            if (v177 == v169)
            {
              v176 = (_QWORD *)(v173 + 16 * v175);
              goto LABEL_356;
            }
          }
LABEL_355:
          v176 = (_QWORD *)(v173 + 16 * v174);
        }
LABEL_356:
        v181 = (uint64_t *)v176[1];
        v184 = *v181;
        v182 = v181 + 2;
        v183 = v184;
        if (v184 == 33)
        {
          v185 = "objc_claimAutoreleasedReturnValue";
          v186 = 33;
        }
        else if (v183 == 39)
        {
          v185 = "objc_unsafeClaimAutoreleasedReturnValue";
          v186 = 39;
        }
        else
        {
          if (v183 != 34)
            goto LABEL_363;
          v185 = "objc_retainAutoreleasedReturnValue";
          v186 = 34;
        }
        if (!memcmp(v182, v185, v186))
          goto LABEL_366;
LABEL_363:
        v180 = "invalid function argument";
LABEL_364:
        v200[0] = (uint64_t)v180;
        v201 = 259;
        sub_1C6249A24((uint64_t)a1, (llvm::Twine *)v200);
        if (*(_QWORD *)a1)
          sub_1C6249A88((llvm::raw_ostream **)a1, a2);
LABEL_366:
        v155 = 1;
        goto LABEL_367;
      case 7:
        if ((v97 & 1) != 0)
        {
          v188 = "Multiple ptrauth operand bundles";
          goto LABEL_396;
        }
        if (v161 != 2)
        {
          v188 = "Expected exactly two ptrauth bundle operands";
          goto LABEL_396;
        }
        if (*((_BYTE *)*v160 + 16) != 16 || *(_DWORD *)(**v160 + 8) != 8205)
        {
          v188 = "Ptrauth bundle key operand must be an i32 constant";
          goto LABEL_396;
        }
        if (*(_DWORD *)(*v160[4] + 8) == 16397)
        {
          v97 = 1;
LABEL_367:
          ++v154;
          v3 = (llvm::raw_ostream **)a1;
          if (v154 == v156)
            goto LABEL_179;
          continue;
        }
        v188 = "Ptrauth bundle discriminator operand must be an i64";
LABEL_396:
        v200[0] = (uint64_t)v188;
        v201 = 259;
        v3 = (llvm::raw_ostream **)a1;
        sub_1C6249A24((uint64_t)a1, (llvm::Twine *)v200);
LABEL_269:
        if (*v3)
        {
          v138 = (llvm::raw_ostream **)a1;
LABEL_256:
          sub_1C6249A88(v138, a2);
        }
        return;
      default:
        goto LABEL_367;
    }
  }
}

void sub_1C54549A8(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6;
  unsigned int v7;
  unsigned __int8 v8;
  int v10;
  const char *v11;
  char v12;
  char v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD v17[4];
  __int16 v18;
  _QWORD v19[4];
  char v20;
  char v21;

  v6 = *a1;
  v7 = *(unsigned __int8 *)(a2 + 8);
  if (v7 > 0x11)
    goto LABEL_6;
  if (((1 << v7) & 0xAC7F) == 0)
  {
    if (((1 << v7) & 0x30000) != 0)
    {
LABEL_11:
      if (!llvm::Type::isSizedDerivedType(a2, 0))
        return;
      goto LABEL_3;
    }
LABEL_6:
    if ((v7 & 0xFE) != 0x12 && v7 != 21)
      return;
    goto LABEL_11;
  }
LABEL_3:
  llvm::DataLayout::getAlignment(*(_QWORD *)(v6 + 176), a2);
  if (v8 >= 0xFu)
  {
    v10 = *((unsigned __int8 *)a3 + 32);
    if (*((_BYTE *)a3 + 32))
    {
      if (v10 == 1)
      {
        v11 = "Incorrect alignment of ";
        v17[0] = "Incorrect alignment of ";
        v18 = 259;
        v12 = 3;
      }
      else
      {
        v14 = (uint64_t *)*a3;
        v15 = a3[1];
        v12 = 2;
        if (*((_BYTE *)a3 + 33) != 1)
        {
          LOBYTE(v10) = 2;
          v14 = a3;
        }
        v17[0] = "Incorrect alignment of ";
        v17[2] = v14;
        v17[3] = v15;
        LOBYTE(v18) = 3;
        HIBYTE(v18) = v10;
        v11 = (const char *)v17;
      }
      v19[0] = v11;
      v19[2] = " to called function!";
      v13 = 3;
    }
    else
    {
      v12 = 0;
      v18 = 256;
      v13 = 1;
    }
    v20 = v12;
    v21 = v13;
    v16 = a1[1];
    sub_1C6249A24(v6, (llvm::Twine *)v19);
    if (*(_QWORD *)v6)
      sub_1C6249A88((llvm::raw_ostream **)v6, v16);
  }
}

void sub_1C5454B04(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6;
  char v7;
  uint64_t v8;
  unsigned int v9;
  int matched;
  uint64_t v11;
  std::string *v12;
  uint64_t v13;
  int v14;
  const char *v15;
  std::string *v16;
  size_t size;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  int v24;
  int v25;
  _QWORD *v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  BOOL v38;
  unsigned __int8 *v39;
  BOOL v40;
  uint64_t v41;
  char v42;
  int v43;
  llvm::Type *v45;
  uint64_t v46;
  unsigned int v47;
  unsigned int v48;
  const char *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  int v55;
  int v56;
  unsigned int PrimitiveSizeInBits;
  int v58;
  int v59;
  unsigned int v60;
  __int16 ParamAlignment;
  int8x8_t v62;
  uint64_t v63;
  uint8x8_t v64;
  unsigned int v65;
  __int16 v67;
  int8x8_t v68;
  uint64_t v69;
  uint8x8_t v70;
  uint64_t v71;
  int v72;
  unint64_t *v73;
  unint64_t *v74;
  unint64_t v75;
  const char *v76;
  uint64_t v77;
  llvm::APInt *v78;
  uint64_t v79;
  unint64_t *v80;
  uint8x8_t v81;
  unsigned __int16 v82;
  char v83;
  unint64_t v84;
  int v85;
  unsigned __int16 v86;
  char v87;
  llvm::Value *v88;
  unsigned int v89;
  uint64_t *v91;
  uint64_t v92;
  unint64_t v93;
  int v94;
  uint8x8_t v95;
  unint64_t *v96;
  unint64_t v97;
  uint64_t v98;
  BOOL v99;
  uint64_t **v100;
  unsigned __int16 v101;
  uint64_t v103;
  _QWORD **v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t *v107;
  uint64_t *v108;
  uint64_t v109;
  _QWORD *v110;
  uint64_t v111;
  uint64_t v112;
  unsigned int v113;
  unsigned int v114;
  unsigned int v115;
  unsigned int v116;
  int v118;
  llvm::Type *v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  llvm::Type **v123;
  int8x8_t *v124;
  uint64_t v125;
  uint8x8_t v126;
  int v127;
  uint64_t v128;
  BOOL v129;
  llvm::APInt *v130;
  unsigned int v131;
  unsigned int v132;
  llvm::APInt *v133;
  uint64_t v134;
  BOOL v135;
  uint64_t v136;
  uint64_t v137;
  llvm::BasicBlock *v138;
  uint64_t v139;
  unsigned int v140;
  unsigned int v141;
  uint64_t v142;
  BOOL v143;
  const char *v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  BOOL v148;
  uint64_t v149;
  char v150;
  uint64_t v151;
  unsigned int v152;
  BOOL v153;
  uint64_t v154;
  unsigned int v155;
  uint64_t v156;
  uint64_t v157;
  int v158;
  int v159;
  uint64_t v160;
  uint64_t v161;
  unsigned int v162;
  _QWORD *v163;
  int v164;
  uint64_t v165;
  BOOL v166;
  unsigned int v167;
  char v168;
  uint64_t v169;
  unsigned int v170;
  unsigned int v171;
  uint64_t v172;
  BOOL v173;
  _QWORD *v174;
  uint64_t v175;
  unint64_t v176;
  unint64_t v177;
  unint64_t v178;
  unint64_t v179;
  uint64_t v180;
  unint64_t v181;
  unsigned int v182;
  uint64_t v183;
  uint64_t *v184;
  uint64_t v185;
  llvm::Type *v186;
  int v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  unsigned __int16 *v192;
  BOOL v193;
  uint64_t v194;
  int AttrKindFromName;
  uint64_t v196;
  int v197;
  unsigned int v198;
  llvm::Value *v199;
  int v200;
  llvm::Value *v201;
  llvm::GlobalValue *Section;
  uint64_t v203;
  llvm::Module *v204;
  uint64_t v205;
  unsigned int v206;
  unsigned int v207;
  uint64_t v208;
  BOOL v209;
  uint64_t v210;
  uint64_t v211;
  unsigned int v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t *v215;
  uint64_t v216;
  _QWORD *v217;
  llvm::Type *v218;
  uint64_t v219;
  unsigned int v220;
  unsigned int v221;
  unsigned int v222;
  unsigned int v223;
  int v225;
  uint64_t v226;
  int v227;
  int v228;
  uint64_t v229;
  uint64_t v230;
  void **v231;
  int v232;
  llvm::Type *v233;
  llvm::Type *v234;
  const char *v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  _QWORD *v239;
  uint64_t v240;
  _QWORD *v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t *v244;
  uint64_t v245;
  int8x8_t *v246;
  uint64_t v247;
  uint8x8_t v248;
  uint64_t v249;
  _QWORD **v250;
  uint64_t v251;
  int v252;
  unint64_t v253;
  int8x8_t *v254;
  int8x8_t v255;
  uint8x8_t v256;
  int64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  llvm::AttributeSetNode *v261;
  unsigned int VScaleRangeMin;
  int v263;
  unint64_t v264;
  int8x8_t *v265;
  int8x8_t v266;
  uint8x8_t v267;
  void *v268;
  uint64_t UniquePredecessor;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  const char *v273;
  int v274;
  unint64_t v275;
  int8x8_t *v276;
  int8x8_t v277;
  uint8x8_t v278;
  uint64_t v279;
  uint64_t v280;
  BOOL v281;
  int v282;
  unint64_t v283;
  int8x8_t *v284;
  int8x8_t v285;
  uint8x8_t v286;
  llvm::Type *v287;
  BOOL v288;
  uint64_t Statepoint;
  uint64_t v290;
  uint64_t v291;
  uint64_t v292;
  _QWORD *v293;
  _QWORD *v294;
  _QWORD *v295;
  _QWORD *v296;
  uint64_t DerivedPtr;
  int v298;
  llvm::Type *v299;
  uint64_t v300;
  unsigned int v301;
  int v302;
  uint64_t **v303;
  uint64_t *v304;
  uint64_t *v305;
  int v306;
  unsigned __int8 **v307;
  unsigned __int8 *v308;
  unsigned __int8 *v309;
  int v310;
  llvm::raw_ostream *v311;
  uint64_t **v312;
  llvm::Value *v313;
  llvm::Value *v314;
  uint64_t v315;
  unsigned int v316;
  unsigned int v317;
  uint64_t v318;
  BOOL v319;
  uint64_t v320;
  uint64_t v321;
  uint64_t v322;
  uint64_t v323;
  int v324;
  uint64_t v325;
  int v326;
  uint64_t v327;
  uint64_t v328;
  uint64_t v329;
  unint64_t v330;
  uint64_t v331;
  llvm::Value *v332;
  llvm::Value *v333;
  uint64_t v334;
  uint64_t v335;
  uint64_t v336;
  uint64_t v337;
  int v338;
  int v339;
  uint64_t v340;
  llvm::raw_ostream **v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t *v344;
  uint64_t v345;
  int v346;
  int64_t v347;
  BOOL v348;
  BOOL v349;
  uint64_t v350;
  _QWORD *v351;
  unint64_t v352;
  llvm::APInt *v353;
  unsigned int v354;
  unint64_t v355;
  unint64_t v356;
  uint64_t v357;
  uint64_t v358;
  uint64_t v359;
  uint64_t v360;
  unint64_t v361;
  int v362;
  uint64_t v363;
  uint64_t v364;
  uint64_t v365;
  uint64_t v366;
  uint64_t v367;
  _BOOL4 v369;
  uint64_t v370;
  int v371;
  uint64_t v372;
  uint64_t v373;
  uint64_t v374;
  unint64_t v375;
  unint64_t v376;
  int v377;
  uint64_t v378;
  uint64_t *v379;
  uint64_t v380;
  BOOL v381;
  uint64_t v382;
  uint64_t v383;
  uint64_t v384;
  uint64_t v385;
  uint64_t v386;
  uint64_t v387;
  uint64_t v388;
  uint64_t v389;
  uint64_t v390;
  uint64_t v391;
  unsigned int v392;
  uint64_t v394;
  int v395;
  _QWORD *v396;
  uint64_t v397;
  unsigned int v398;
  uint64_t v399;
  uint64_t ParamElementType;
  unsigned int v401;
  uint64_t v402;
  _QWORD *v403;
  _QWORD *v404;
  uint64_t v405;
  uint64_t v406;
  _QWORD *v407;
  uint64_t v408;
  uint64_t v409;
  uint64_t v410;
  uint64_t v411;
  uint64_t v412;
  _QWORD *v413;
  uint64_t v414;
  _QWORD *v415;
  int v416;
  uint64_t v417;
  int v418;
  int v419;
  uint64_t v420;
  _BYTE *v421;
  uint64_t v422;
  const char *v423;
  const char *v424;
  uint64_t v425;
  uint64_t v426;
  llvm::APInt *v427;
  std::string v428;
  unsigned int *v429;
  uint64_t v430;
  void *__p;
  unint64_t v432;
  const char *v433;
  uint64_t v434;
  __int16 v435;
  uint64_t v436;
  uint64_t v437[2];
  const char *v438;
  __int16 v439;
  void *v440;
  uint64_t v441;
  _BYTE v442[32];
  void *v443[2];
  _WORD v444[48];
  uint64_t v445;

  v445 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a3 - 32);
  if (v6 && !*(_BYTE *)(v6 + 16) && *(_QWORD *)(v6 + 24) == *(_QWORD *)(a3 + 72))
  {
    v7 = 0;
  }
  else
  {
    v6 = 0;
    v7 = 1;
    if (MEMORY[0x10])
      goto LABEL_27;
  }
  if (*(_QWORD *)(v6 + 72) != v6 + 72 || (*(_BYTE *)(v6 + 34) & 0x80) != 0)
  {
LABEL_27:
    v443[0] = "Intrinsic functions should never be defined!";
    v444[8] = 259;
    sub_1C6249A24(a1, (llvm::Twine *)v443);
    if ((v7 & 1) == 0 && *(_QWORD *)a1)
      sub_1C6249A88((llvm::raw_ostream **)a1, v6);
    return;
  }
  v8 = *(_QWORD *)(v6 + 24);
  v9 = *(_DWORD *)(v8 + 8);
  v443[0] = v444;
  v443[1] = (void *)0x800000000;
  llvm::Intrinsic::getIntrinsicInfoTableEntries(a2);
  v429 = (unsigned int *)v444;
  v430 = 0;
  v440 = v442;
  v441 = 0x400000000;
  matched = llvm::Intrinsic::matchIntrinsicSignature(v8, &v429);
  if (matched == 2)
  {
    v15 = "Intrinsic has incorrect argument type!";
LABEL_86:
    v437[0] = (uint64_t)v15;
    v439 = 259;
    sub_1C6249A24(a1, (llvm::Twine *)v437);
    if (*(_QWORD *)a1)
      sub_1C6249A88((llvm::raw_ostream **)a1, v6);
    goto LABEL_849;
  }
  if (matched == 1)
  {
    v15 = "Intrinsic has incorrect return type!";
    goto LABEL_86;
  }
  if (v9 < 0x100)
  {
    if (v430)
    {
      if (v430 == 1)
      {
        v429 += 3;
        v430 = 0;
      }
      v15 = "Callsite was not defined with variable arguments!";
      goto LABEL_86;
    }
  }
  else if (v430 != 1 || (v14 = *v429, v429 += 3, v430 = 0, v14 != 1))
  {
    v15 = "Intrinsic was not defined with variable arguments!";
    goto LABEL_86;
  }
  sub_1C53CF274(a2, (uint64_t *)v440, v441, *(uint64_t **)(v6 + 40), v8, v11, v12, v13, &v428);
  if ((v428.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v16 = &v428;
  else
    v16 = (std::string *)v428.__r_.__value_.__r.__words[0];
  if ((v428.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = *((_BYTE *)&v428.__r_.__value_.__s + 23) & 0x7F;
  else
    size = v428.__r_.__value_.__l.__size_;
  if ((*(_BYTE *)(v6 + 23) & 0x10) == 0)
  {
    v28 = 0;
    v27 = &byte_1C871356D;
    goto LABEL_32;
  }
  v18 = ***(_QWORD ***)v6;
  v19 = *(_QWORD *)(v18 + 152);
  v20 = *(unsigned int *)(v18 + 168);
  if (!(_DWORD)v20)
    goto LABEL_30;
  LODWORD(v21) = (v20 - 1) & ((v6 >> 4) ^ (v6 >> 9));
  v22 = (uint64_t *)(v19 + 16 * v21);
  v23 = *v22;
  if (*v22 != v6)
  {
    v24 = 1;
    while (v23 != -4096)
    {
      v25 = v21 + v24++;
      v21 = v25 & (v20 - 1);
      v23 = *(_QWORD *)(v19 + 16 * v21);
      if (v23 == v6)
      {
        v22 = (uint64_t *)(v19 + 16 * v21);
        goto LABEL_31;
      }
    }
LABEL_30:
    v22 = (uint64_t *)(v19 + 16 * v20);
  }
LABEL_31:
  v26 = (_QWORD *)v22[1];
  v29 = *v26;
  v27 = (char *)(v26 + 2);
  v28 = v29;
LABEL_32:
  if (size != v28 || size && memcmp(v16, v27, size))
  {
    std::operator+<char>();
    v439 = 260;
    v437[0] = (uint64_t)&__p;
    sub_1C6249A24(a1, (llvm::Twine *)v437);
    if (*(_QWORD *)a1)
      sub_1C6249A88((llvm::raw_ostream **)a1, v6);
    if (SHIBYTE(v433) < 0)
      operator delete(__p);
    goto LABEL_847;
  }
  v30 = *(_DWORD *)(a3 + 20);
  v31 = v30 & 0x7FFFFFF;
  v32 = a3 - 32 * v31;
  v33 = *(unsigned __int8 *)(a3 + 16);
  if (v33 == 84)
  {
    v34 = 0;
  }
  else if (v33 == 39)
  {
    v34 = (*(_DWORD *)(a3 + 80) + 1);
  }
  else
  {
    v34 = 2;
  }
  if (v30 < 0 && (v357 = *(_QWORD *)(v32 - 8), (v357 & 0xFFFFFFFF0) != 0))
    v35 = (*(_DWORD *)(v32 - 12) - *(_DWORD *)(v32 - v357));
  else
    v35 = 0;
  if (v32 != a3 - 32 * v34 - 32 * v35 - 32)
  {
    v36 = 32 * v31 - 32 * v34 - 32 * v35 - 32;
    while (1)
    {
      v37 = *(_QWORD *)v32;
      if (*(_QWORD *)v32)
        v38 = *(_BYTE *)(*(_QWORD *)v32 + 16) == 23;
      else
        v38 = 0;
      if (v38)
      {
        v39 = *(unsigned __int8 **)(v37 + 24);
        if (*v39 - 4 > 0x1E)
        {
          v41 = *(_QWORD *)(*(_QWORD *)(a3 + 40) + 56);
          sub_1C4774094((llvm::SmallPtrSetImplBase *)(a1 + 432), *(_QWORD *)(v37 + 24));
          if (v42 && *v39 - 3 >= 0xFFFFFFFE)
            sub_1C544CA60((llvm::raw_ostream *)a1, (uint64_t)v39, v41);
        }
        else
        {
          sub_1C5448E64((_QWORD *)a1, *(_QWORD *)(v37 + 24));
        }
      }
      v40 = !v37 || *(unsigned __int8 *)(v37 + 16) > 0x14u;
      if (!v40 && *(_BYTE *)(*(_QWORD *)v37 + 8) == 11)
        break;
      v32 += 32;
      v36 -= 32;
      if (!v36)
        goto LABEL_58;
    }
    v76 = "const x86_amx is not allowed in argument!";
LABEL_721:
    v437[0] = (uint64_t)v76;
    v439 = 259;
    sub_1C6249A24(a1, (llvm::Twine *)v437);
    goto LABEL_847;
  }
LABEL_58:
  if (a2 > 446)
  {
    if (a2 > 3646)
    {
      if (a2 <= 4052)
      {
        if (a2 != 3647 && a2 != 3653)
          goto LABEL_847;
LABEL_488:
        if (llvm::AttributeList::getParamElementType((llvm::AttributeList *)(a3 + 64), 0))
          goto LABEL_847;
        v235 = "Intrinsic requires elementtype attribute on first argument.";
        goto LABEL_691;
      }
      if (a2 != 4053 && a2 != 4055)
        goto LABEL_847;
    }
    else
    {
      if (a2 <= 648)
      {
        if (a2 != 447 && a2 != 450)
          goto LABEL_847;
        goto LABEL_488;
      }
      if (a2 != 649 && a2 != 651)
        goto LABEL_847;
    }
    v437[0] = *(_QWORD *)(a3 + 64);
    if (llvm::AttributeList::getParamElementType((llvm::AttributeList *)v437, 1))
      goto LABEL_847;
    v235 = "Intrinsic requires elementtype attribute on second argument.";
LABEL_691:
    v437[0] = (uint64_t)v235;
    v439 = 259;
    sub_1C6249A24(a1, (llvm::Twine *)v437);
    if (!*(_QWORD *)a1)
      goto LABEL_847;
    v341 = (llvm::raw_ostream **)a1;
    v342 = a3;
LABEL_855:
    sub_1C6249A88(v341, v342);
    goto LABEL_847;
  }
  switch(a2)
  {
    case 7:
      v187 = *(_DWORD *)(a3 + 20);
      if ((v187 & 0x80000000) == 0)
        goto LABEL_847;
      v188 = a3 - 32 * (v187 & 0x7FFFFFF);
      v189 = *(_QWORD *)(v188 - 8);
      if (!v189)
        goto LABEL_847;
      v190 = -v189;
      while (2)
      {
        v191 = *(_QWORD *)(v188 + v190 - 8);
        v192 = (unsigned __int16 *)(v191 + 16);
        if (*(_QWORD *)v191 == 6
          && (*(_DWORD *)v192 == 1869506409 ? (v193 = *(unsigned __int16 *)(v191 + 20) == 25970) : (v193 = 0), v193))
        {
          v194 = 6;
        }
        else
        {
          if (!llvm::Attribute::isExistingAttribute(v192, *(_QWORD *)v191))
          {
            v49 = "tags must be valid attribute names";
            goto LABEL_846;
          }
          v191 = *(_QWORD *)(v188 + v190 - 8);
          v194 = *(_QWORD *)v191;
        }
        AttrKindFromName = llvm::Attribute::getAttrKindFromName(v191 + 16, v194);
        v196 = *(unsigned int *)(v188 + v190);
        v197 = *(_DWORD *)(v188 + v190 + 4);
        v198 = v197 - v196;
        if (AttrKindFromName == 74)
        {
          if ((v198 & 0xFFFFFFFE) == 2)
          {
            v382 = a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF);
            if (*(_BYTE *)(**(_QWORD **)(v382 + 32 * v196) + 8) == 15)
            {
              if (*(_BYTE *)(**(_QWORD **)(v382 + 32 * (v196 + 1)) + 8) == 13)
              {
                if (v198 != 3 || *(_BYTE *)(**(_QWORD **)(v382 + 32 * (v196 + 2)) + 8) == 13)
                  goto LABEL_847;
                v49 = "third argument should be an integer if present";
              }
              else
              {
                v49 = "second argument should be an integer";
              }
            }
            else
            {
              v49 = "first argument should be a pointer";
            }
          }
          else
          {
            v49 = "alignment assumptions should have 2 or 3 arguments";
          }
        }
        else
        {
          if (v198 >= 3)
          {
            v49 = "too many arguments";
            goto LABEL_846;
          }
          if (!AttrKindFromName)
            goto LABEL_847;
          if ((AttrKindFromName - 74) <= 6)
          {
            if (v198 != 2)
            {
              v49 = "this attribute should have 2 arguments";
              goto LABEL_846;
            }
            if (*(_BYTE *)(*(_QWORD *)(a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF) + 32 * (v196 + 1))
                          + 16) != 16)
            {
              v49 = "the second argument should be a constant integral value";
              goto LABEL_846;
            }
LABEL_388:
            v190 += 16;
            if (!v190)
              goto LABEL_847;
            continue;
          }
          if ((byte_1C85FC5EE[AttrKindFromName - 1] & 2) == 0)
          {
            if ((byte_1C85FC5EE[AttrKindFromName - 1] & 1) != 0 && v197 != (_DWORD)v196)
            {
              v49 = "this attribute has no argument";
              goto LABEL_846;
            }
            goto LABEL_388;
          }
          if (v198 == 1)
            goto LABEL_388;
          v49 = "this attribute should have one argument";
        }
        goto LABEL_846;
      }
    case 9:
      v186 = *(llvm::Type **)a3;
      if ((*(_DWORD *)(*(_QWORD *)a3 + 8) & 0xFE) == 0x12)
        v186 = (llvm::Type *)**((_QWORD **)v186 + 2);
      if ((llvm::Type::getPrimitiveSizeInBits(v186) & 0xF) == 0)
        goto LABEL_847;
      v49 = "bswap must be an even number of bytes";
      goto LABEL_846;
    case 10:
      v205 = *(_QWORD *)(a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF));
      v206 = *(unsigned __int8 *)(v205 + 16);
      if (v206 < 0x1C
        || ((v207 = v206 - 33, v40 = v207 > 0x33, v208 = (1 << v207) & 0x8000000000041, !v40)
          ? (v209 = v208 == 0)
          : (v209 = 1),
            v209 || *(_DWORD *)(*(_QWORD *)(v205 - 32) + 36) != 11))
      {
        v76 = "llvm.call.preallocated.arg token argument must be a llvm.call.preallocated.setup";
        goto LABEL_721;
      }
      v210 = *(_QWORD *)(a3 + 64);
      if ((!v210 || (*(_BYTE *)(v210 + 21) & 1) == 0) && (llvm::CallBase::hasFnAttrOnCalledFunction(a3, 72) & 1) == 0)
      {
        v76 = "llvm.call.preallocated.arg must be called with a \"preallocated\" call site attribute";
        goto LABEL_721;
      }
      goto LABEL_847;
    case 11:
      v147 = *(_QWORD *)(a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF));
      v426 = v147;
      if (v147)
        v148 = *(_BYTE *)(v147 + 16) == 16;
      else
        v148 = 0;
      if (!v148)
      {
        v76 = "llvm.call.preallocated.setup argument must be a constant";
        goto LABEL_721;
      }
      v149 = *(_QWORD *)(a3 + 8);
      if (!v149)
        goto LABEL_847;
      v150 = 0;
      v427 = (llvm::APInt *)(v147 + 24);
      while (2)
      {
        v151 = *(_QWORD *)(v149 + 24);
        v152 = *(unsigned __int8 *)(v151 + 16);
        if (v152 < 0x1C
          || (v152 - 33 <= 0x33 ? (v153 = ((1 << (v152 - 33)) & 0x8000000000041) == 0) : (v153 = 1),
              v153))
        {
          v76 = "Uses of llvm.call.preallocated.setup must be calls";
          goto LABEL_721;
        }
        v154 = *(_QWORD *)(v151 - 32);
        if (!v154 || *(_BYTE *)(v154 + 16) || *(_QWORD *)(v154 + 24) != *(_QWORD *)(v151 + 72))
          break;
        v164 = *(_DWORD *)(v154 + 36);
        if (v164 == 12)
          goto LABEL_322;
        if (v164 == 10)
        {
          v165 = *(_QWORD *)(v151 - 32 * (*(_DWORD *)(v151 + 20) & 0x7FFFFFF) + 32);
          if (v165)
            v166 = *(_BYTE *)(v165 + 16) == 16;
          else
            v166 = 0;
          if (!v166)
          {
            v76 = "llvm.call.preallocated.alloc arg index must be a constant";
            goto LABEL_721;
          }
          LODWORD(v432) = *(_DWORD *)(v165 + 32);
          if (v432 > 0x40)
          {
            __p = (void *)operator new[]();
            memcpy(__p, *(const void **)(v165 + 24), (((unint64_t)v432 + 63) >> 3) & 0x3FFFFFF8);
          }
          else
          {
            __p = *(void **)(v165 + 24);
          }
          if ((sub_1C4DA9220((llvm::APInt *)&__p, 0) & 1) == 0)
          {
            v167 = v432;
            if (v432 > 0x40)
            {
              v169 = *((_QWORD *)__p + ((v432 - 1) >> 6)) & (1 << (v432 - 1));
              v170 = *(_DWORD *)(v426 + 32);
              v171 = v170 - 1;
              v172 = *(_QWORD *)(v426 + 24);
              v173 = v170 >= 0x41;
              v174 = (_QWORD *)(v426 + 24);
              if (v173)
                v174 = (_QWORD *)(v172 + 8 * (v171 >> 6));
              if ((v169 != 0) == ((*v174 >> v171) & 1))
              {
                v175 = v172 - 8;
                v176 = (((unint64_t)v432 + 63) >> 3) & 0x3FFFFFF8;
                while (v176)
                {
                  v177 = *(_QWORD *)((char *)__p + v176 - 8);
                  v178 = *(_QWORD *)(v175 + v176);
                  v176 -= 8;
                  if (v177 != v178)
                  {
                    if (v177 > v178)
                      break;
                    v168 = 1;
                    goto LABEL_338;
                  }
                }
              }
              else if (v169)
              {
                if (__p)
                  MEMORY[0x1CAA32F9C]();
                goto LABEL_322;
              }
            }
            else if ((uint64_t)((_QWORD)__p << -(uint64_t)v432) >> -(uint64_t)v432 < (uint64_t)(*(_QWORD *)v427 << -(uint64_t)v432) >> -(uint64_t)v432)
            {
              goto LABEL_322;
            }
          }
          v437[0] = (uint64_t)"llvm.call.preallocated.alloc arg index must be between 0 and corresponding llvm.call.preall"
                             "ocated.setup's argument count";
          v439 = 259;
          sub_1C6249A24(a1, (llvm::Twine *)v437);
          v168 = 0;
          v167 = v432;
LABEL_338:
          if (v167 >= 0x41 && __p)
            MEMORY[0x1CAA32F9C](__p, 0x1000C8000313F17);
          if ((v168 & 1) == 0)
            goto LABEL_847;
LABEL_322:
          v149 = *(_QWORD *)(v149 + 8);
          if (!v149)
            goto LABEL_847;
          continue;
        }
        break;
      }
      if ((v150 & 1) != 0)
      {
        v76 = "Can have at most one call corresponding to a llvm.call.preallocated.setup";
        goto LABEL_721;
      }
      v155 = 0;
      v156 = 0;
      while (1)
      {
        if (v152 == 84)
          v157 = 0;
        else
          v157 = v152 == 39 ? (*(_DWORD *)(v151 + 80) + 1) : 2;
        v158 = *(_DWORD *)(v151 + 20);
        if (v158 < 0 && (*(_QWORD *)(v151 - 8 - 32 * (v158 & 0x7FFFFFF)) & 0xFFFFFFFF0) != 0)
        {
          v160 = -(uint64_t)(v158 & 0x7FFFFFF);
          v159 = *(_DWORD *)(v151 - 32 * (v158 & 0x7FFFFFF) - 12)
               - *(_DWORD *)(v151 - 32 * (v158 & 0x7FFFFFF) - *(_QWORD *)(v151 - 32 * (v158 & 0x7FFFFFF) - 8));
        }
        else
        {
          v159 = 0;
          v160 = -(uint64_t)(v158 & 0x7FFFFFF);
        }
        v161 = v151 + 32 * v160;
        if (v155 >= ((-32 - 32 * v157 + 32 * (unint64_t)-v159 - 32 * v160) >> 5))
          break;
        v156 += llvm::CallBase::paramHasAttr(v151, v155++, 72);
        v152 = *(unsigned __int8 *)(v151 + 16);
      }
      if (!v156)
      {
        v76 = "cannot use preallocated intrinsics on a call without preallocated arguments";
        goto LABEL_721;
      }
      v162 = *(_DWORD *)(v426 + 32);
      v163 = (_QWORD *)(v426 + 24);
      if (v162 < 0x41)
        goto LABEL_317;
      if (v162 - llvm::APInt::countLeadingZerosSlowCase(v427) <= 0x40)
      {
        v163 = *(_QWORD **)v427;
LABEL_317:
        if (*v163 == v156)
        {
          if (v158 < 0)
          {
            v181 = *(_QWORD *)(v161 - 8);
            v180 = v161 - 8;
            v179 = v181;
            if ((v181 & 0xFFFFFFFF0) != 0)
            {
              v182 = 0;
              v183 = (v179 >> 4);
              v184 = (uint64_t *)(v180 - v179);
              do
              {
                v185 = *v184;
                v184 += 2;
                if (*(_DWORD *)(v185 + 8) == 4)
                  ++v182;
                --v183;
              }
              while (v183);
              if (v182 > 1)
                goto LABEL_847;
            }
          }
          sub_1C5062CEC(v151, 4, (uint64_t)&__p);
          if (!(_BYTE)v434)
          {
            v76 = "Use of llvm.call.preallocated.setup outside intrinsics must be in \"preallocated\" operand bundle";
            goto LABEL_721;
          }
          if (*(_QWORD *)__p != a3)
          {
            v76 = "preallocated bundle must have token from corresponding llvm.call.preallocated.setup";
            goto LABEL_721;
          }
          v150 = 1;
          goto LABEL_322;
        }
      }
      v437[0] = (uint64_t)"llvm.call.preallocated.setup arg size must be equal to number of preallocated arguments at call site";
      v439 = 259;
      sub_1C624A060((llvm::raw_ostream **)a1, (llvm::Twine *)v437, a3, v151);
      goto LABEL_847;
    case 12:
      v139 = *(_QWORD *)(a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF));
      v140 = *(unsigned __int8 *)(v139 + 16);
      if (v140 >= 0x1C)
      {
        v141 = v140 - 33;
        v40 = v141 > 0x33;
        v142 = (1 << v141) & 0x8000000000041;
        v143 = v40 || v142 == 0;
        if (!v143 && *(_DWORD *)(*(_QWORD *)(v139 - 32) + 36) == 11)
          goto LABEL_847;
      }
      v76 = "llvm.call.preallocated.teardown token argument must be a llvm.call.preallocated.setup";
      goto LABEL_721;
    case 36:
      v199 = llvm::Value::stripPointerCasts(*(llvm::Value **)(a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF) + 96));
      v200 = *((unsigned __int8 *)v199 + 16);
      if (v200 == 19)
        goto LABEL_847;
      if (v200 != 3
        || (v201 = v199, (*((_BYTE *)v199 + 80) & 1) == 0)
        || (*((_DWORD *)v199 + 5) & 0x7FFFFFF) == 0
        || (Section = llvm::GlobalValue::getSection(v199), v203 == 12)
        && (*(_QWORD *)Section == *(_QWORD *)"llvm.ptrauth"
          ? (v381 = *((unsigned int *)Section + 2) == (unint64_t)*(unsigned int *)"auth")
          : (v381 = 0),
            v381)
        || (*((_DWORD *)v201 + 8) & 0xFu) - 5 >= 4 && ((1 << (*((_DWORD *)v201 + 8) & 0xF)) & 0x614) != 0
        || (v204 = (llvm::Module *)*((_QWORD *)v201 + 5)) != 0
        && llvm::Module::getSemanticInterposition(v204)
        && (*((_BYTE *)v201 + 33) & 0x40) == 0
        || (*((_BYTE *)v201 + 80) & 2) != 0)
      {
        v76 = "info argument of llvm.coro.id must refer to an initialized constant";
      }
      else
      {
        if ((*(_BYTE *)(*((_QWORD *)v201 - 4) + 16) & 0xFE) == 8)
          goto LABEL_847;
        v76 = "info argument of llvm.coro.id must refer to either a struct or an array";
      }
      goto LABEL_721;
    case 55:
      v144 = "addr";
      v145 = a1;
      v146 = 4;
      goto LABEL_414;
    case 56:
      if (*(_BYTE *)(*(_QWORD *)(a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF)) + 16) != 23)
      {
        v49 = "invalid llvm.dbg.declare intrinsic call 1";
        goto LABEL_846;
      }
      v144 = "declare";
      v145 = a1;
      v146 = 7;
LABEL_414:
      sub_1C54584AC(v145, (uint64_t)v144, v146, a3);
      goto LABEL_847;
    case 57:
      v100 = *(uint64_t ***)(*(_QWORD *)(a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF)) + 24);
      if (*(_BYTE *)v100 != 26)
      {
        v435 = 1283;
        __p = "invalid llvm.dbg.";
        v433 = "label";
        v434 = 5;
        v437[0] = (uint64_t)&__p;
        v438 = " intrinsic variable";
        v439 = 770;
        sub_1C6249CD4(a1, (llvm::Twine *)v437);
        if (!*(_QWORD *)a1)
          goto LABEL_847;
        sub_1C6249A88((llvm::raw_ostream **)a1, a3);
        goto LABEL_659;
      }
      v136 = *(_QWORD *)(a3 + 48);
      if (v136 && *(_BYTE *)v136 != 5)
        goto LABEL_847;
      v137 = *(_QWORD *)(a3 + 40);
      if (v137)
        v138 = *(llvm::BasicBlock **)(v137 + 56);
      else
        v138 = 0;
      if (!v136)
      {
        v435 = 1283;
        __p = "llvm.dbg.";
        v433 = "label";
        v434 = 5;
        v437[0] = (uint64_t)&__p;
        v438 = " intrinsic requires a !dbg attachment";
        v439 = 770;
        sub_1C6249A24(a1, (llvm::Twine *)v437);
        if (!*(_QWORD *)a1)
          goto LABEL_847;
        sub_1C6249A88((llvm::raw_ostream **)a1, a3);
        if (v137)
        {
          sub_1C6249A88((llvm::raw_ostream **)a1, v137);
          if (!v138)
            goto LABEL_847;
        }
        else if (!v138)
        {
          goto LABEL_847;
        }
        goto LABEL_716;
      }
      v303 = &v100[-*((unsigned int *)v100 + 2)];
      v304 = *v303;
      if (!*v303)
        goto LABEL_567;
      v305 = *v303;
      while (2)
      {
        v306 = *(unsigned __int8 *)v305;
        if (v306 != 17)
        {
          if ((v306 & 0xFE) == 0x12)
          {
            v305 = (uint64_t *)v305[-*((unsigned int *)v305 + 2) + 1];
            if (!v305)
              break;
            continue;
          }
LABEL_567:
          v305 = 0;
        }
        break;
      }
      v307 = (unsigned __int8 **)(v136 - 8 * *(unsigned int *)(v136 + 8));
      v308 = *v307;
      if (!*v307)
        goto LABEL_847;
      v309 = *v307;
      while (1)
      {
        v310 = *v309;
        if (v310 == 17)
          break;
        if ((v310 & 0xFE) == 0x12)
        {
          v309 = *(unsigned __int8 **)&v309[-8 * *((unsigned int *)v309 + 2) + 8];
          if (v309)
            continue;
        }
        goto LABEL_847;
      }
      if (v305)
      {
        if (v305 != (uint64_t *)v309)
        {
          v435 = 1283;
          __p = "mismatched subprogram between llvm.dbg.";
          v433 = "label";
          v434 = 5;
          v437[0] = (uint64_t)&__p;
          v438 = " label and !dbg attachment";
          v439 = 770;
          while ((*(_BYTE *)v304 & 0xFE) == 0x12)
            v304 = (uint64_t *)v304[-*((unsigned int *)v304 + 2) + 1];
          while ((*v308 & 0xFE) == 0x12)
            v308 = *(unsigned __int8 **)&v308[-8 * *((unsigned int *)v308 + 2) + 8];
          sub_1C6249CD4(a1, (llvm::Twine *)v437);
          if (*(_QWORD *)a1)
          {
            sub_1C6249A88((llvm::raw_ostream **)a1, a3);
            if (v137)
              sub_1C6249A88((llvm::raw_ostream **)a1, v137);
            if (v138)
              sub_1C6249A88((llvm::raw_ostream **)a1, (uint64_t)v138);
            sub_1C6249C6C((llvm::raw_ostream *)a1, v100);
            sub_1C6249C6C((llvm::raw_ostream *)a1, (uint64_t **)v304);
            sub_1C6249C6C((llvm::raw_ostream *)a1, (uint64_t **)v136);
            v311 = (llvm::raw_ostream *)a1;
            v312 = (uint64_t **)v308;
            goto LABEL_660;
          }
        }
      }
      goto LABEL_847;
    case 58:
      v144 = "value";
      v145 = a1;
      v146 = 5;
      goto LABEL_414;
    case 62:
    case 63:
      if (*(_BYTE *)(*(_QWORD *)(a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF)) + 16) == 80)
        goto LABEL_847;
      v49 = "eh.exceptionpointer argument must be a catchpad";
      goto LABEL_846;
    case 79:
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 90:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 97:
    case 98:
    case 99:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 108:
    case 109:
    case 110:
    case 111:
    case 112:
    case 113:
    case 114:
    case 115:
    case 116:
    case 117:
    case 118:
      __asm { BR              X11 }
      return;
    case 119:
      if (*(_BYTE *)(a3 + 16) != 84)
      {
        v49 = "experimental_deoptimize cannot be invoked";
        goto LABEL_846;
      }
      v118 = *(_DWORD *)(a3 + 20);
      if ((v118 & 0x80000000) == 0)
        goto LABEL_248;
      v360 = v118 & 0x7FFFFFF;
      v361 = *(_QWORD *)(a3 - 32 * v360 - 8);
      if ((v361 & 0xFFFFFFFF0) == 0)
        goto LABEL_248;
      v362 = 0;
      v363 = (v361 >> 4);
      v364 = -8 - (v361 + 32 * v360);
      do
      {
        if (!*(_DWORD *)(*(_QWORD *)(a3 + v364) + 8))
          ++v362;
        v364 += 16;
        --v363;
      }
      while (v363);
      if (v362 != 1)
      {
LABEL_248:
        v76 = "experimental_deoptimize must have exactly one \"deopt\" operand bundle";
        goto LABEL_721;
      }
      v365 = *(_QWORD *)(a3 + 40);
      if (*(_QWORD *)a3 != **(_QWORD **)(*(_QWORD *)(*(_QWORD *)(v365 + 56) + 24) + 16))
      {
        v76 = "experimental_deoptimize return type must match caller return type";
        goto LABEL_721;
      }
      v366 = *(_QWORD *)(a3 + 32);
      v367 = v366 - 24;
      v369 = v366 == v365 + 40 || v366 == 0;
      if (v369)
        v370 = 0;
      else
        v370 = v367;
      v371 = *(unsigned __int8 *)(v370 + 16);
      if (v371 != 29)
        v370 = 0;
      if (v369 || v371 != 29)
      {
        v76 = "calls to experimental_deoptimize must be followed by a return";
        goto LABEL_721;
      }
      if (*(_BYTE *)(*(_QWORD *)a3 + 8) != 7)
      {
        v372 = *(_DWORD *)(v370 + 20) & 0x7FFFFFF;
        if (!(_DWORD)v372 || *(_QWORD *)(v370 - 32 * v372) != a3)
        {
          v76 = "calls to experimental_deoptimize must be followed by a return of the value computed by experimental_deoptimize";
          goto LABEL_721;
        }
      }
      goto LABEL_847;
    case 122:
      v225 = *(unsigned __int8 *)(a3 + 16);
      if (v225 == 84)
      {
        v226 = 0;
      }
      else if (v225 == 39)
      {
        v226 = (*(_DWORD *)(a3 + 80) + 1);
      }
      else
      {
        v226 = 2;
      }
      v227 = *(_DWORD *)(a3 + 20);
      if (v227 < 0
        && (v358 = a3 - 32 * (v227 & 0x7FFFFFF), v359 = *(_QWORD *)(v358 - 8), (v359 & 0xFFFFFFFF0) != 0))
      {
        v229 = -(uint64_t)(v227 & 0x7FFFFFF);
        v228 = *(_DWORD *)(v358 - 12) - *(_DWORD *)(v358 - v359);
      }
      else
      {
        v228 = 0;
        v229 = -(uint64_t)(v227 & 0x7FFFFFF);
      }
      v230 = a3 - 32 * v226 + 32 * -v228;
      v231 = (void **)(a3 + 32 * v229);
      if (((v230 - (_QWORD)v231 - 32) & 0x1FFFFFFFE0) != 0x60)
      {
        v49 = "wrong number of arguments";
        goto LABEL_846;
      }
      if ((*(_DWORD *)(*(_QWORD *)a3 + 8) & 0xFE) == 0x12)
        v232 = *(unsigned __int8 *)(**(_QWORD **)(*(_QWORD *)a3 + 16) + 8);
      else
        v232 = *(_DWORD *)(*(_QWORD *)a3 + 8);
      if (v232 != 15)
      {
        v49 = "gc.relocate must return a pointer or a vector of pointers";
        goto LABEL_846;
      }
      v268 = *v231;
      if (*v231 && *((_BYTE *)v268 + 16) == 94)
      {
        v138 = (llvm::BasicBlock *)*((_QWORD *)v268 + 5);
        UniquePredecessor = llvm::BasicBlock::getUniquePredecessor(v138);
        if (!UniquePredecessor)
        {
          v437[0] = (uint64_t)"safepoints should have unique landingpads";
          v439 = 259;
          sub_1C6249A24(a1, (llvm::Twine *)v437);
          if (v138)
            v349 = *(_QWORD *)a1 == 0;
          else
            v349 = 1;
          if (!v349)
          {
LABEL_716:
            v341 = (llvm::raw_ostream **)a1;
            v342 = (uint64_t)v138;
            goto LABEL_855;
          }
          goto LABEL_847;
        }
        v270 = UniquePredecessor;
        v271 = *(_QWORD *)(UniquePredecessor + 40);
        if (v271 == UniquePredecessor + 40
          || (v271 ? (v272 = v271 - 24) : (v272 = 0), *(unsigned __int8 *)(v272 + 16) - 29 >= 0xB))
        {
          v273 = "safepoint block should be well formed";
          goto LABEL_662;
        }
        if (!sub_1C50A011C(v272))
        {
          v273 = "gc relocate should be linked to a statepoint";
LABEL_662:
          v437[0] = (uint64_t)v273;
          v439 = 259;
          sub_1C6249A24(a1, (llvm::Twine *)v437);
          if (!*(_QWORD *)a1)
            goto LABEL_847;
          v341 = (llvm::raw_ostream **)a1;
          v342 = v270;
          goto LABEL_855;
        }
      }
      else
      {
        __p = *v231;
        if (!sub_1C50A011C((uint64_t)v268))
        {
          v437[0] = (uint64_t)"gc relocate is incorrectly tied to the statepoint";
          v439 = 259;
          goto LABEL_711;
        }
      }
      Statepoint = llvm::GCProjectionInst::getStatepoint((llvm::GCProjectionInst *)a3);
      v290 = a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF);
      v291 = *(_QWORD *)(v290 + 32);
      if (*(_BYTE *)(v291 + 16) != 16)
      {
        v49 = "gc.relocate operand #2 must be integer offset";
        goto LABEL_846;
      }
      v292 = *(_QWORD *)(v290 + 64);
      if (*(_BYTE *)(v292 + 16) != 16)
      {
        v49 = "gc.relocate operand #3 must be integer offset";
        goto LABEL_846;
      }
      v293 = (_QWORD *)(v291 + 24);
      if (*(_DWORD *)(v291 + 32) >= 0x41u)
        v293 = (_QWORD *)*v293;
      v294 = (_QWORD *)(v292 + 24);
      if (*(_DWORD *)(v292 + 32) >= 0x41u)
        v294 = (_QWORD *)*v294;
      v295 = (_QWORD *)*v293;
      v296 = (_QWORD *)*v294;
      sub_1C5062CEC(Statepoint, 5, (uint64_t)&__p);
      if ((_BYTE)v434)
      {
        if ((unint64_t)v295 >= v432)
        {
          v49 = "gc.relocate: statepoint base index out of bounds";
          goto LABEL_846;
        }
        if ((unint64_t)v296 >= v432)
        {
          v49 = "gc.relocate: statepoint derived index out of bounds";
          goto LABEL_846;
        }
      }
      DerivedPtr = llvm::GCRelocateInst::getDerivedPtr((llvm::GCRelocateInst *)a3);
      if ((*(_DWORD *)(*(_QWORD *)DerivedPtr + 8) & 0xFE) == 0x12)
        v298 = *(unsigned __int8 *)(**(_QWORD **)(*(_QWORD *)DerivedPtr + 16) + 8);
      else
        v298 = *(_DWORD *)(*(_QWORD *)DerivedPtr + 8);
      if (v298 != 15)
      {
        v49 = "gc.relocate: relocated value must be a gc pointer";
        goto LABEL_846;
      }
      v299 = *(llvm::Type **)a3;
      v300 = *(_QWORD *)llvm::GCRelocateInst::getDerivedPtr((llvm::GCRelocateInst *)a3);
      v301 = *((_DWORD *)v299 + 2);
      v302 = *(_DWORD *)(v300 + 8);
      if (((v301 & 0xFE) == 18) != ((v302 & 0xFE) == 18))
      {
        v49 = "gc.relocate: vector relocates to vector and pointer to pointer";
        goto LABEL_846;
      }
      if ((v301 & 0xFE) == 0x12)
        v301 = *(_DWORD *)(**((_QWORD **)v299 + 2) + 8);
      if ((v302 & 0xFE) == 0x12)
        v302 = *(_DWORD *)(**(_QWORD **)(v300 + 16) + 8);
      if ((v302 ^ v301) >= 0x100)
      {
        v49 = "gc.relocate: relocating a pointer shouldn't change its address space";
        goto LABEL_846;
      }
      goto LABEL_847;
    case 123:
      if ((*(_WORD *)(*(_QWORD *)(*(_QWORD *)(a3 + 40) + 56) + 18) & 0x4000) == 0)
        goto LABEL_198;
      v315 = *(_QWORD *)(a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF));
      v316 = *(unsigned __int8 *)(v315 + 16);
      if (v316 < 0x1C
        || ((v317 = v316 - 33, v40 = v317 > 0x33, v318 = (1 << v317) & 0x8000000000041, !v40)
          ? (v319 = v318 == 0)
          : (v319 = 1),
            v319
         || (v320 = *(_QWORD *)(v315 - 32)) == 0
         || *(_BYTE *)(v320 + 16)
         || *(_QWORD *)(v320 + 24) != *(_QWORD *)(v315 + 72)
         || *(_QWORD *)(v320 + 72) != v320 + 72
         || (*(_BYTE *)(v320 + 34) & 0x80) != 0
         || *(_DWORD *)(v320 + 36) != 124))
      {
        v437[0] = (uint64_t)"gc.result operand #1 must be from a statepoint";
        v439 = 259;
        __p = (void *)v315;
LABEL_711:
        sub_1C624A0BC((llvm::raw_ostream **)a1, (llvm::Twine *)v437, a3, (uint64_t *)&__p);
        goto LABEL_847;
      }
      if (*(_QWORD *)a3 == **(_QWORD **)(llvm::AttributeList::getParamElementType((llvm::AttributeList *)(v315 + 64), 2)+ 16))goto LABEL_847;
      v49 = "gc.result result type does not match wrapped callee";
      goto LABEL_846;
    case 124:
      if (*(_BYTE *)(a3 + 16) == 84 && *(_BYTE *)(*(_QWORD *)(a3 - 32) + 16) == 24)
      {
        v49 = "gc.statepoint support for inline assembly unimplemented";
        goto LABEL_846;
      }
      if ((*(_WORD *)(*(_QWORD *)(*(_QWORD *)(a3 + 40) + 56) + 18) & 0x4000) == 0)
        goto LABEL_198;
      v344 = (uint64_t *)(a3 + 64);
      v343 = *(_QWORD *)(a3 + 64);
      if (v343 && (*(_BYTE *)(v343 + 17) & 0x10) != 0)
        goto LABEL_679;
      LODWORD(v437[0]) = 7;
      if ((!sub_1C53E4BBC(a3, (__int32 *)v437, 1uLL)
         || (v383 = *(_QWORD *)(a3 - 32)) != 0
         && !*(_BYTE *)(v383 + 16)
         && *(_QWORD *)(v383 + 24) == *(_QWORD *)(a3 + 72)
         && *(_DWORD *)(v383 + 36) == 7)
        && (llvm::CallBase::hasFnAttrOnCalledFunction(a3, 44) & 1) != 0)
      {
        goto LABEL_679;
      }
      v345 = *v344;
      if (*v344)
      {
        if ((*(_BYTE *)(v345 + 17) & 0x30) != 0)
          goto LABEL_679;
      }
      v346 = *(_DWORD *)(a3 + 20);
      if ((v346 & 0x80000000) == 0)
        goto LABEL_672;
      v387 = a3 - 32 * (v346 & 0x7FFFFFF);
      v390 = *(_QWORD *)(v387 - 8);
      v388 = v387 - 8;
      v389 = v390;
      if (!v390)
        goto LABEL_672;
      v391 = -v389;
      do
      {
        v392 = *(_DWORD *)(*(_QWORD *)(v388 + v391) + 8);
        if (v392 >= 2 && v392 != 7)
          goto LABEL_675;
        v391 += 16;
      }
      while (v391);
LABEL_672:
      if ((llvm::CallBase::hasFnAttrOnCalledFunction(a3, 45) & 1) != 0
        || (llvm::CallBase::hasFnAttrOnCalledFunction(a3, 44) & 1) != 0)
      {
        goto LABEL_679;
      }
      v345 = *v344;
LABEL_675:
      if (v345 && (*(_BYTE *)(v345 + 12) & 8) != 0
        || ((LODWORD(v437[0]) = 7, !sub_1C53E4BBC(a3, (__int32 *)v437, 1uLL))
         || (v394 = *(_QWORD *)(a3 - 32)) != 0
         && !*(_BYTE *)(v394 + 16)
         && *(_QWORD *)(v394 + 24) == *(_QWORD *)(a3 + 72)
         && *(_DWORD *)(v394 + 36) == 7)
        && llvm::CallBase::hasFnAttrOnCalledFunction(a3, 3))
      {
LABEL_679:
        v49 = "gc.statepoint must read and write all memory to preserve reordering restrictions required by safepoint semantics";
        goto LABEL_846;
      }
      v395 = *(_DWORD *)(a3 + 20);
      v396 = (_QWORD *)(a3 - 32 * (v395 & 0x7FFFFFF));
      v397 = v396[4];
      v398 = *(_DWORD *)(v397 + 32);
      if (v398 > 0x40)
        v399 = **(_QWORD **)(v397 + 24);
      else
        v399 = (uint64_t)(*(_QWORD *)(v397 + 24) << -(char)v398) >> -(char)v398;
      if (v399 < 0)
      {
        v49 = "gc.statepoint number of patchable bytes must be positive";
        goto LABEL_846;
      }
      ParamElementType = llvm::AttributeList::getParamElementType((llvm::AttributeList *)(a3 + 64), 2);
      if (!ParamElementType)
      {
        v49 = "gc.statepoint callee argument must have elementtype attribute";
        goto LABEL_846;
      }
      v401 = *(_DWORD *)(ParamElementType + 8);
      if (v401 != 14)
      {
        v49 = "gc.statepoint callee elementtype must be function type";
        goto LABEL_846;
      }
      v402 = v396[12];
      v403 = (_QWORD *)(v402 + 24);
      if (*(_DWORD *)(v402 + 32) >= 0x41u)
        v403 = (_QWORD *)*v403;
      v404 = (_QWORD *)*v403;
      if ((v404 & 0x80000000) != 0)
      {
        v49 = "gc.statepoint number of arguments to underlying call must be positive";
        goto LABEL_846;
      }
      v405 = (*(_DWORD *)(ParamElementType + 12) - 1);
      if (v401 >= 0x100)
      {
        if ((int)v405 <= (int)v404)
        {
          if (*(_BYTE *)(**(_QWORD **)(ParamElementType + 16) + 8) != 7)
          {
            v49 = "gc.statepoint doesn't support wrapping non-void vararg functions yet";
            goto LABEL_846;
          }
          goto LABEL_857;
        }
        v49 = "gc.statepoint mismatch in number of vararg call args";
LABEL_846:
        v437[0] = (uint64_t)v49;
        v439 = 259;
        sub_1C6249A24(a1, (llvm::Twine *)v437);
        if (!*(_QWORD *)a1)
          goto LABEL_847;
        v341 = (llvm::raw_ostream **)a1;
        v342 = a3;
        goto LABEL_855;
      }
      if ((_DWORD)v405 != (_DWORD)v404)
      {
        v49 = "gc.statepoint mismatch in number of call args";
        goto LABEL_846;
      }
LABEL_857:
      v406 = v396[16];
      v407 = (_QWORD *)(v406 + 24);
      if (*(_DWORD *)(v406 + 32) >= 0x41u)
        v407 = (_QWORD *)*v407;
      if (*v407 >= 4uLL)
      {
        v49 = "unknown flag used in gc.statepoint flags argument";
        goto LABEL_846;
      }
      if ((int)v405 >= 1)
      {
        v408 = 0;
        v409 = *v344;
        v410 = 160 - 32 * (v395 & 0x7FFFFFF);
        while (1)
        {
          if (**(_QWORD **)(a3 + v410) != *(_QWORD *)(*(_QWORD *)(ParamElementType + 16) + 8 + 8 * v408))
          {
            v49 = "gc.statepoint call argument does not match wrapped function type";
            goto LABEL_846;
          }
          if (v401 >= 0x100)
          {
            if (v409)
            {
              if ((v408 + 7) < *(_DWORD *)(v409 + 8))
              {
                v411 = *(_QWORD *)(*v344 + 96 + 8 * v408);
                if (v411)
                {
                  if ((*(_BYTE *)(v411 + 21) & 2) != 0)
                    break;
                }
              }
            }
          }
          ++v408;
          v410 += 32;
          if (v405 == v408)
            goto LABEL_869;
        }
        v49 = "Attribute 'sret' cannot be used for vararg call arguments!";
        goto LABEL_846;
      }
LABEL_869:
      v412 = v396[4 * ((_DWORD)v404 + 5)];
      if (*(_BYTE *)(v412 + 16) != 16)
      {
        v49 = "gc.statepoint number of transition arguments must be constant integer";
        goto LABEL_846;
      }
      v413 = (_QWORD *)(v412 + 24);
      if (*(_DWORD *)(v412 + 32) >= 0x41u)
        v413 = (_QWORD *)*v413;
      if (*(_DWORD *)v413)
      {
        v49 = "gc.statepoint w/inline transition bundle is deprecated";
        goto LABEL_846;
      }
      v414 = v396[4 * ((_DWORD)v404 + 6)];
      if (*(_BYTE *)(v414 + 16) != 16)
      {
        v49 = "gc.statepoint number of deoptimization arguments must be constant integer";
        goto LABEL_846;
      }
      v415 = (_QWORD *)(v414 + 24);
      if (*(_DWORD *)(v414 + 32) >= 0x41u)
        v415 = (_QWORD *)*v415;
      if (*(_DWORD *)v415)
      {
        v49 = "gc.statepoint w/inline deopt operands is deprecated";
        goto LABEL_846;
      }
      v416 = *(unsigned __int8 *)(a3 + 16);
      if (v416 == 84)
      {
        v417 = 0;
      }
      else if (v416 == 39)
      {
        v417 = (*(_DWORD *)(a3 + 80) + 1);
      }
      else
      {
        v417 = 2;
      }
      v418 = (_DWORD)v404 + 7;
      if (v395 < 0 && (v425 = *(v396 - 1), (v425 & 0xFFFFFFFF0) != 0))
        v419 = *((_DWORD *)v396 - 3) - *(_DWORD *)((char *)v396 - v425);
      else
        v419 = 0;
      if (v418 != ((-32 * v417
                                 + 32 * -v419
                                 - -32 * (unint64_t)(v395 & 0x7FFFFFF)
                                 - 32) >> 5))
      {
        v49 = "gc.statepoint too many arguments";
        goto LABEL_846;
      }
      v420 = *(_QWORD *)(a3 + 8);
      if (!v420)
        goto LABEL_847;
      while (1)
      {
        v421 = *(_BYTE **)(v420 + 24);
        __p = v421;
        if (v421[16] == 84)
          v422 = (uint64_t)v421;
        else
          v422 = 0;
        v436 = v422;
        if (!v422)
        {
          v423 = "illegal use of statepoint token";
LABEL_910:
          v437[0] = (uint64_t)v423;
          v439 = 259;
          sub_1C624A0BC((llvm::raw_ostream **)a1, (llvm::Twine *)v437, a3, (uint64_t *)&__p);
          goto LABEL_847;
        }
        if (!sub_1C4E9AE24(v422) && !sub_1C5458950(v422))
        {
          v423 = "gc.result or gc.relocate are the only value uses of a gc.statepoint";
          goto LABEL_910;
        }
        if (!sub_1C5458950(v422))
          break;
        if (*(_QWORD *)(v422 - 32 * (*(_DWORD *)(v422 + 20) & 0x7FFFFFF)) != a3)
        {
          v424 = "gc.result connected to wrong gc.statepoint";
          goto LABEL_912;
        }
LABEL_894:
        v420 = *(_QWORD *)(v420 + 8);
        if (!v420)
          goto LABEL_847;
      }
      if (!sub_1C4E9AE24(a3) || *(_QWORD *)(v422 - 32 * (*(_DWORD *)(v422 + 20) & 0x7FFFFFF)) == a3)
        goto LABEL_894;
      v424 = "gc.relocate connected to wrong gc.statepoint";
LABEL_912:
      v437[0] = (uint64_t)v424;
      v439 = 259;
      sub_1C624A0BC((llvm::raw_ostream **)a1, (llvm::Twine *)v437, a3, &v436);
LABEL_847:
      if (SHIBYTE(v428.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v428.__r_.__value_.__l.__data_);
LABEL_849:
      if (v440 != v442)
        free(v440);
      if (v443[0] != v444)
        free(v443[0]);
      return;
    case 125:
      if (*(_BYTE *)(a3 + 16) != 84)
      {
        v49 = "experimental_guard cannot be invoked";
        goto LABEL_846;
      }
      v127 = *(_DWORD *)(a3 + 20);
      if ((v127 & 0x80000000) == 0)
        goto LABEL_256;
      v373 = a3 - 32 * (v127 & 0x7FFFFFF);
      v376 = *(_QWORD *)(v373 - 8);
      v374 = v373 - 8;
      v375 = v376;
      if ((v376 & 0xFFFFFFFF0) == 0)
        goto LABEL_256;
      v377 = 0;
      v378 = (v375 >> 4);
      v379 = (uint64_t *)(v374 - v375);
      do
      {
        v380 = *v379;
        v379 += 2;
        if (!*(_DWORD *)(v380 + 8))
          ++v377;
        --v378;
      }
      while (v378);
      if (v377 != 1)
      {
LABEL_256:
        v76 = "experimental_guard must have exactly one \"deopt\" operand bundle";
        goto LABEL_721;
      }
      goto LABEL_847;
    case 126:
      v236 = *(unsigned int *)(a1 + 2024);
      if (v236 >= *(_DWORD *)(a1 + 2028))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 2016, a1 + 2032, v236 + 1, 8);
        LODWORD(v236) = *(_DWORD *)(a1 + 2024);
      }
      *(_QWORD *)(*(_QWORD *)(a1 + 2016) + 8 * v236) = a3;
      ++*(_DWORD *)(a1 + 2024);
      goto LABEL_847;
    case 130:
      v233 = *(llvm::Type **)a3;
      if (*(_QWORD *)a3)
      {
        if ((*((_DWORD *)v233 + 2) & 0xFE) == 0x12)
        {
          v234 = (llvm::Type *)**((_QWORD **)v233 + 2);
          if (*((_BYTE *)v234 + 8) == 13 && (llvm::Type::getPrimitiveSizeInBits(v234) & 0xFFFFFFF8) != 0)
            goto LABEL_847;
        }
      }
      v235 = "experimental_stepvector only supported for vectors of integers with a bitwidth of at least 8.";
      goto LABEL_691;
    case 131:
      v214 = a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF);
      v215 = *(uint64_t **)v214;
      v216 = *(_QWORD *)(v214 + 32);
      v217 = (_QWORD *)(v216 + 24);
      if (*(_DWORD *)(v216 + 32) >= 0x41u)
        v217 = (_QWORD *)*v217;
      v218 = *(llvm::Type **)a3;
      v219 = *v215;
      if (*(_QWORD *)(*(_QWORD *)a3 + 24) != *(_QWORD *)(v219 + 24))
      {
        v235 = "experimental_vector_extract result must have the same element type as the input vector.";
        goto LABEL_691;
      }
      v220 = *(_DWORD *)v217;
      v221 = *((_DWORD *)v218 + 8);
      if (v220 % v221)
      {
        v76 = "experimental_vector_extract index must be a constant multiple of the result type's known minimum vector length.";
        goto LABEL_721;
      }
      if ((*(_BYTE *)(v219 + 8) == 19) == (*((_BYTE *)v218 + 8) == 19))
      {
        v222 = *(_DWORD *)(v219 + 32);
        v223 = v221 + v220;
        if (v222 <= v220 || v223 > v222)
        {
          v76 = "experimental_vector_extract would overrun.";
          goto LABEL_721;
        }
      }
      goto LABEL_847;
    case 132:
      v106 = a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF);
      v107 = *(uint64_t **)v106;
      v108 = *(uint64_t **)(v106 + 32);
      v109 = *(_QWORD *)(v106 + 64);
      v110 = (_QWORD *)(v109 + 24);
      if (*(_DWORD *)(v109 + 32) >= 0x41u)
        v110 = (_QWORD *)*v110;
      v111 = *v107;
      v112 = *v108;
      if (*(_QWORD *)(v111 + 24) != *(_QWORD *)(*v108 + 24))
      {
        v235 = "experimental_vector_insert parameters must have the same element type.";
        goto LABEL_691;
      }
      v113 = *(_DWORD *)v110;
      v114 = *(_DWORD *)(v112 + 32);
      if (v113 % v114)
      {
        v76 = "experimental_vector_insert index must be a constant multiple of the subvector's known minimum vector length.";
        goto LABEL_721;
      }
      if ((*(_BYTE *)(v111 + 8) == 19) == (*(_BYTE *)(v112 + 8) == 19))
      {
        v115 = *(_DWORD *)(v111 + 32);
        v116 = v114 + v113;
        if (v115 <= v113 || v116 > v115)
        {
          v76 = "subvector operand of experimental_vector_insert would overrun the vector being inserted into.";
          goto LABEL_721;
        }
      }
      goto LABEL_847;
    case 134:
      v211 = *(_QWORD *)(a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF) + 64);
      v212 = *(_DWORD *)(v211 + 32);
      if (v212 > 0x40)
        v213 = **(_QWORD **)(v211 + 24);
      else
        v213 = (uint64_t)(*(_QWORD *)(v211 + 24) << -(char)v212) >> -(char)v212;
      v257 = *(unsigned int *)(*(_QWORD *)a3 + 32);
      v258 = *(_QWORD *)(a3 + 40);
      if (v258)
      {
        v259 = *(_QWORD *)(v258 + 56);
        if (v259)
        {
          v260 = *(_QWORD *)(v259 + 112);
          if (v260)
          {
            if ((*(_BYTE *)(v260 + 22) & 1) != 0)
            {
              if (*(_DWORD *)(v260 + 8) && (v261 = *(llvm::AttributeSetNode **)(v260 + 40)) != 0)
                VScaleRangeMin = llvm::AttributeSetNode::getVScaleRangeMin(v261);
              else
                VScaleRangeMin = 1;
              v257 = VScaleRangeMin * (unint64_t)v257;
            }
          }
        }
      }
      if (v213 >= 0)
        v347 = v213;
      else
        v347 = -v213;
      v348 = v347 <= v257;
      if (v213 >= 0)
        v348 = v213 < v257;
      if (v348)
        goto LABEL_847;
      v235 = "The splice index exceeds the range [-VL, VL-1] where VL is the known minimum number of elements in the vect"
             "or. For scalable vectors the minimum number of elements is determined from vscale_range.";
      goto LABEL_691;
    case 135:
    case 136:
    case 137:
    case 330:
    case 331:
    case 332:
    case 333:
    case 334:
    case 335:
    case 336:
    case 337:
    case 338:
    case 339:
    case 340:
    case 341:
    case 342:
    case 343:
    case 344:
    case 345:
    case 346:
    case 347:
    case 348:
    case 349:
    case 350:
    case 351:
    case 352:
    case 353:
    case 354:
    case 355:
    case 356:
    case 357:
    case 358:
    case 359:
    case 360:
    case 361:
    case 362:
    case 363:
    case 364:
    case 365:
    case 366:
    case 367:
    case 368:
    case 369:
    case 370:
    case 371:
    case 372:
    case 373:
    case 374:
    case 375:
    case 376:
    case 377:
    case 378:
    case 379:
    case 380:
    case 381:
      v43 = *(_DWORD *)(*(_QWORD *)(a3 - 32) + 36);
      if ((v43 - 339) > 0x2A || ((1 << (v43 - 83)) & 0x4A28000410FLL) == 0)
      {
        if (v43 == 334)
        {
          if (llvm::VPCmpIntrinsic::getPredicate((llvm::VPCmpIntrinsic *)a3) > 0xF)
          {
            v49 = "invalid predicate for VP FP comparison intrinsic";
            goto LABEL_846;
          }
          v43 = *(_DWORD *)(*(_QWORD *)(a3 - 32) + 36);
        }
        if (v43 == 346 && llvm::VPCmpIntrinsic::getPredicate((llvm::VPCmpIntrinsic *)a3) - 32 >= 0xA)
        {
          v49 = "invalid predicate for VP integer comparison intrinsic";
          goto LABEL_846;
        }
      }
      else
      {
        v45 = *(llvm::Type **)a3;
        v46 = **(_QWORD **)(a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF));
        v47 = *(unsigned __int8 *)(*(_QWORD *)a3 + 8);
        v48 = *(unsigned __int8 *)(v46 + 8);
        if (*(_DWORD *)(*(_QWORD *)a3 + 32) != *(_DWORD *)(v46 + 32) || (v47 != 19) == (v48 == 19))
        {
          v49 = "VP cast intrinsic first argument and result vector lengths must be equal";
          goto LABEL_846;
        }
        switch(v43)
        {
          case 339:
            v55 = v47 & 0xFE;
            if (v55 == 18)
              v47 = *(unsigned __int8 *)(**((_QWORD **)v45 + 2) + 8);
            if (v47 > 6)
              goto LABEL_490;
            v56 = v48 & 0xFE;
            if (v56 == 18)
              v48 = *(unsigned __int8 *)(**(_QWORD **)(v46 + 16) + 8);
            if (v48 >= 7)
            {
LABEL_490:
              v49 = "llvm.vp.fpext intrinsic first argument and result element type must be floating-point";
              goto LABEL_846;
            }
            if (v55 == 18)
              v45 = (llvm::Type *)**((_QWORD **)v45 + 2);
            PrimitiveSizeInBits = llvm::Type::getPrimitiveSizeInBits(v45);
            if (v56 == 18)
              v46 = **(_QWORD **)(v46 + 16);
            if (PrimitiveSizeInBits <= llvm::Type::getPrimitiveSizeInBits((llvm::Type *)v46))
            {
              v49 = "llvm.vp.fpext intrinsic the bit size of first argument must be smaller than the bit size of the return type";
              goto LABEL_846;
            }
            goto LABEL_847;
          case 340:
          case 341:
            if ((v47 & 0xFE) == 0x12)
              v47 = *(unsigned __int8 *)(**((_QWORD **)v45 + 2) + 8);
            if (v47 == 13)
            {
              if ((v48 & 0xFE) == 0x12)
                v48 = *(unsigned __int8 *)(**(_QWORD **)(v46 + 16) + 8);
              if (v48 < 7)
                goto LABEL_847;
            }
            v49 = "llvm.vp.fptoui or llvm.vp.fptosi intrinsic first argument element type must be floating-point and resu"
                  "lt element type must be integer";
            goto LABEL_846;
          case 342:
            v58 = v47 & 0xFE;
            if (v58 == 18)
              v47 = *(unsigned __int8 *)(**((_QWORD **)v45 + 2) + 8);
            if (v47 > 6)
              goto LABEL_491;
            v59 = v48 & 0xFE;
            if (v59 == 18)
              v48 = *(unsigned __int8 *)(**(_QWORD **)(v46 + 16) + 8);
            if (v48 >= 7)
            {
LABEL_491:
              v49 = "llvm.vp.fptrunc intrinsic first argument and result element type must be floating-point";
              goto LABEL_846;
            }
            if (v58 == 18)
              v45 = (llvm::Type *)**((_QWORD **)v45 + 2);
            v60 = llvm::Type::getPrimitiveSizeInBits(v45);
            if (v59 == 18)
              v46 = **(_QWORD **)(v46 + 16);
            if (v60 >= llvm::Type::getPrimitiveSizeInBits((llvm::Type *)v46))
            {
              v49 = "llvm.vp.fptrunc intrinsic the bit size of first argument must be larger than the bit size of the return type";
              goto LABEL_846;
            }
            break;
          case 343:
          case 344:
          case 345:
          case 346:
          case 348:
          case 349:
          case 350:
          case 351:
          case 352:
            __break(1u);
            JUMPOUT(0x1C5457AA4);
          case 347:
            if ((v47 & 0xFE) == 0x12)
              v47 = *(unsigned __int8 *)(**((_QWORD **)v45 + 2) + 8);
            if (v47 == 15)
            {
              if ((v48 & 0xFE) == 0x12)
                v48 = *(unsigned __int8 *)(**(_QWORD **)(v46 + 16) + 8);
              if (v48 == 13)
                goto LABEL_847;
            }
            v49 = "llvm.vp.inttoptr intrinsic first argument element type must be integer and result element type must be pointer";
            goto LABEL_846;
          case 353:
            if ((v47 & 0xFE) == 0x12)
              v47 = *(unsigned __int8 *)(**((_QWORD **)v45 + 2) + 8);
            if (v47 == 13)
            {
              if ((v48 & 0xFE) == 0x12)
                v48 = *(unsigned __int8 *)(**(_QWORD **)(v46 + 16) + 8);
              if (v48 == 15)
                goto LABEL_847;
            }
            v49 = "llvm.vp.ptrtoint intrinsic first argument element type must be pointer and result element type must be integer";
            goto LABEL_846;
          default:
            __asm { BR              X12 }
            return;
        }
      }
      goto LABEL_847;
    case 146:
      v98 = *(_QWORD *)(a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF) + 32);
      if (v98)
        v99 = *(_BYTE *)(v98 + 16) == 23;
      else
        v99 = 0;
      if (!v99 || (v100 = *(uint64_t ***)(v98 + 24)) == 0)
      {
        v49 = "missing rounding mode argument";
        goto LABEL_846;
      }
      if (*(_BYTE *)v100)
      {
        v437[0] = (uint64_t)"invalid value for llvm.fptrunc.round metadata operand (the operand should be a string)";
        v439 = 259;
        sub_1C6249A24(a1, (llvm::Twine *)v437);
        if (*(_QWORD *)a1)
        {
LABEL_659:
          v311 = (llvm::raw_ostream *)a1;
          v312 = v100;
LABEL_660:
          sub_1C6249C6C(v311, v312);
        }
      }
      else
      {
        v101 = llvm::convertStrToRoundingMode(v100[1] + 3, *v100[1]);
        if (v101 < 0x100u || v101 == 7)
        {
          v49 = "unsupported rounding mode argument";
          goto LABEL_846;
        }
      }
      goto LABEL_847;
    case 150:
    case 151:
    case 152:
      if (a2 != 151)
        goto LABEL_197;
      v88 = llvm::Value::stripPointerCasts(*(llvm::Value **)(a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF)));
      if (!v88 || *((_BYTE *)v88 + 16) != 59)
      {
        v49 = "llvm.gcroot parameter #1 must be an alloca.";
        goto LABEL_846;
      }
      v89 = *(unsigned __int8 *)(*(_QWORD *)(a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF) + 32) + 16);
      if (v89 >= 0x15)
      {
        v49 = "llvm.gcroot parameter #2 must be a constant.";
        goto LABEL_846;
      }
      if (v89 == 19 && *(_BYTE *)(*((_QWORD *)v88 + 8) + 8) != 15)
      {
        v49 = "llvm.gcroot parameter #1 must either be a pointer alloca, or argument #2 must be a non-null constant.";
        goto LABEL_846;
      }
LABEL_197:
      if ((*(_WORD *)(*(_QWORD *)(*(_QWORD *)(a3 + 40) + 56) + 18) & 0x4000) == 0)
      {
LABEL_198:
        v49 = "Enclosing function does not use GC.";
        goto LABEL_846;
      }
      goto LABEL_847;
    case 153:
      if ((*(_DWORD *)(*(_QWORD *)a3 + 8) & 0xFE) == 0x12)
      {
        if (*(_DWORD *)(**(_QWORD **)(*(_QWORD *)a3 + 16) + 8) == 269)
          goto LABEL_847;
        v49 = "get_active_lane_mask: element type is not i1";
      }
      else
      {
        v49 = "get_active_lane_mask: must return a vector";
      }
      goto LABEL_846;
    case 158:
      if (!*((_BYTE *)llvm::Value::stripPointerCasts(*(llvm::Value **)(a3
                                                                      - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF)
                                                                      + 32))
            + 16))
        goto LABEL_847;
      v49 = "llvm.init_trampoline parameter #2 must resolve to a function.";
      goto LABEL_846;
    case 164:
      v128 = *(_QWORD *)(a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF));
      if (v128)
        v129 = *(_BYTE *)(v128 + 16) == 16;
      else
        v129 = 0;
      if (!v129)
        goto LABEL_575;
      v130 = (llvm::APInt *)(v128 + 24);
      v131 = *(_DWORD *)(v128 + 32);
      v132 = v131 - 1;
      v133 = v130;
      if (v131 >= 0x41)
        v133 = (llvm::APInt *)(*(_QWORD *)v130 + 8 * (v132 >> 6));
      v134 = *(_QWORD *)v133 & (1 << v132);
      if (v131)
        v135 = v134 == 0;
      else
        v135 = 1;
      if (v135)
        goto LABEL_847;
      if (v131 > 0x40)
      {
        if (llvm::APInt::countTrailingOnesSlowCase(v130) == v131)
          goto LABEL_847;
      }
      else if (*(_QWORD *)v130 == 0xFFFFFFFFFFFFFFFFLL >> -(char)v131)
      {
        goto LABEL_847;
      }
LABEL_575:
      v49 = "invariant_start parameter must be -1, 0 or a positive number";
      goto LABEL_846;
    case 169:
    case 170:
    case 180:
    case 181:
      if ((*(_DWORD *)(**(_QWORD **)(a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF)) + 8) & 0xFE) != 0x12
        && (*(_DWORD *)(*(_QWORD *)a3 + 8) & 0xFE) != 0x12)
      {
        goto LABEL_847;
      }
      v49 = "Intrinsic does not support vectors";
      goto LABEL_846;
    case 173:
      v321 = *(_QWORD *)(a3 + 40);
      v322 = *(_QWORD *)(*(_QWORD *)(v321 + 56) + 80);
      if (v322)
        v323 = v322 - 24;
      else
        v323 = 0;
      if (v321 != v323)
      {
        v49 = "llvm.localescape used outside of entry block";
        goto LABEL_846;
      }
      if (*(_BYTE *)(a1 + 800))
      {
        v49 = "multiple calls to llvm.localescape in one function";
        goto LABEL_846;
      }
      v324 = *(_DWORD *)(a3 + 20);
      v325 = v324 & 0x7FFFFFF;
      v326 = *(unsigned __int8 *)(a3 + 16);
      if (v326 == 84)
      {
        v327 = 0;
      }
      else if (v326 == 39)
      {
        v327 = (*(_DWORD *)(a3 + 80) + 1);
      }
      else
      {
        v327 = 2;
      }
      v328 = a3 - 32 * v325;
      if (v324 < 0 && (v384 = *(_QWORD *)(v328 - 8), (v384 & 0xFFFFFFFF0) != 0))
        v329 = (*(_DWORD *)(v328 - 12) - *(_DWORD *)(v328 - v384));
      else
        v329 = 0;
      if (v328 == a3 - 32 * v327 - 32 * v329 - 32)
        goto LABEL_639;
      v330 = (32 * v327 + 32 * v329) ^ 0xFFFFFFFFFFFFFFE0;
      v331 = -32 * v325;
      while (1)
      {
        v332 = *(llvm::Value **)(a3 + v331);
        if (*((_BYTE *)v332 + 16) != 19)
        {
          v333 = llvm::Value::stripPointerCasts(v332);
          if (!v333 || *((_BYTE *)v333 + 16) != 59 || *(_BYTE *)(*((_QWORD *)v333 - 4) + 16) != 16)
            break;
          v334 = *((_QWORD *)v333 + 5);
          v335 = *(_QWORD *)(*(_QWORD *)(v334 + 56) + 80);
          v336 = v335 ? v335 - 24 : 0;
          if (v334 != v336 || (*((_WORD *)v333 + 9) & 0x40) != 0)
            break;
        }
        v331 += 32;
        if (v330 == v331)
        {
          v326 = *(unsigned __int8 *)(a3 + 16);
LABEL_639:
          if (v326 == 84)
          {
            v337 = 0;
          }
          else if (v326 == 39)
          {
            v337 = (*(_DWORD *)(a3 + 80) + 1);
          }
          else
          {
            v337 = 2;
          }
          v338 = 0;
          v339 = *(_DWORD *)(a3 + 20);
          v340 = -(uint64_t)(v339 & 0x7FFFFFF);
          if (v339 < 0)
          {
            v385 = a3 - 32 * (v339 & 0x7FFFFFF);
            v386 = *(_QWORD *)(v385 - 8);
            if ((v386 & 0xFFFFFFFF0) != 0)
              v338 = *(_DWORD *)(v385 - 12) - *(_DWORD *)(v385 - v386);
            else
              v338 = 0;
          }
          v437[0] = *(_QWORD *)(v321 + 56);
          *((_DWORD *)sub_1C6180A54(a1 + 832, v437) + 2) = (-32 * v337
                                                          + 32 * (unint64_t)-v338
                                                          - 32 * v340
                                                          - 32) >> 5;
          *(_BYTE *)(a1 + 800) = 1;
          goto LABEL_847;
        }
      }
      v49 = "llvm.localescape only accepts static allocas";
      goto LABEL_846;
    case 174:
      v313 = llvm::Value::stripPointerCasts(*(llvm::Value **)(a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF)));
      if (*((_BYTE *)v313 + 16))
        v314 = 0;
      else
        v314 = v313;
      __p = v314;
      if (!v314)
        goto LABEL_602;
      if (*((_BYTE *)v314 + 16))
      {
        if (*((_BYTE *)v314 + 16) != 3 || (*((_DWORD *)v314 + 5) & 0x7FFFFFF) != 0)
          goto LABEL_727;
      }
      else if (*((llvm::Value **)v314 + 9) != (llvm::Value *)((char *)v314 + 72) || (*((_BYTE *)v314 + 34) & 0x80) != 0)
      {
LABEL_727:
        v350 = *(_QWORD *)(a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF) + 64);
        v351 = sub_1C6180A54(a1 + 832, (uint64_t *)&__p);
        v352 = *((unsigned int *)v351 + 3);
        v353 = (llvm::APInt *)(v350 + 24);
        v354 = *(_DWORD *)(v350 + 32);
        if (v354 >= 0x41)
        {
          if (v354 - llvm::APInt::countLeadingZerosSlowCase(v353) > 0x40)
            goto LABEL_732;
          v355 = **(_QWORD **)v353;
        }
        else
        {
          v355 = *(_QWORD *)v353;
        }
        if (!HIDWORD(v355))
        {
          v356 = v355 + 1;
          goto LABEL_734;
        }
LABEL_732:
        v356 = 0x100000000;
LABEL_734:
        if (v356 <= v352)
          LODWORD(v356) = v352;
        *((_DWORD *)v351 + 3) = v356;
        goto LABEL_847;
      }
LABEL_602:
      v49 = "llvm.localrecover first argument must be function defined in this module";
      goto LABEL_846;
    case 184:
      v249 = *(_QWORD *)(a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF) + 32);
      v250 = (_QWORD **)(v249 + 24);
      v251 = *(unsigned int *)(v249 + 32);
      if (v251 > 0x40)
      {
        if (llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)(v249 + 24)) == (_DWORD)v251)
          goto LABEL_847;
        v263 = 0;
        v264 = (unint64_t)(v251 + 63) >> 6;
        v265 = (int8x8_t *)*v250;
        do
        {
          v266 = *v265++;
          v267 = (uint8x8_t)vcnt_s8(v266);
          v267.i16[0] = vaddlv_u8(v267);
          v263 += v267.i32[0];
          --v264;
        }
        while (v264);
        if (v263 == 1)
          goto LABEL_847;
      }
      else if (((unint64_t)*v250 & ((unint64_t)*v250 - 1)) == 0)
      {
        goto LABEL_847;
      }
      v49 = "masked_gather: alignment must be 0 or a power of 2";
      goto LABEL_846;
    case 185:
      v119 = *(llvm::Type **)a3;
      if ((*(_DWORD *)(*(_QWORD *)a3 + 8) & 0xFE) != 0x12)
      {
        v49 = "masked_load: must return a vector";
        goto LABEL_846;
      }
      v120 = a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF);
      v121 = **(_QWORD **)(v120 + 64);
      if ((*(_DWORD *)(v121 + 8) & 0xFE) != 0x12)
      {
        v49 = "masked_load: mask must be vector";
        goto LABEL_846;
      }
      v122 = *(_QWORD *)v120;
      v123 = *(llvm::Type ***)(v120 + 96);
      v124 = *(int8x8_t **)(v120 + 32);
      v125 = v124[4].u32[0];
      if (v125 > 0x40)
      {
        v282 = 0;
        v283 = (unint64_t)(v125 + 63) >> 6;
        v284 = (int8x8_t *)v124[3];
        do
        {
          v285 = *v284++;
          v286 = (uint8x8_t)vcnt_s8(v285);
          v286.i16[0] = vaddlv_u8(v286);
          v282 += v286.i32[0];
          --v283;
        }
        while (v283);
        if (v282 != 1)
          goto LABEL_253;
      }
      else
      {
        v126 = (uint8x8_t)vcnt_s8(v124[3]);
        v126.i16[0] = vaddlv_u8(v126);
        if (v126.u32[0] != 1)
        {
LABEL_253:
          v49 = "masked_load: alignment must be a power of 2";
          goto LABEL_846;
        }
      }
      v287 = *(llvm::Type **)(*(_QWORD *)v122 + 24);
      if (v287)
        v288 = v287 == v119;
      else
        v288 = 1;
      if (v288)
      {
        if (*v123 == v119)
        {
          if ((*(_DWORD *)(*(_QWORD *)a3 + 8) == 19) != (*(_DWORD *)(v121 + 8) != 19)
            && *(_DWORD *)(v121 + 32) == *((_DWORD *)v119 + 8))
          {
            goto LABEL_847;
          }
          v49 = "masked_load: vector mask must be same length as return";
        }
        else
        {
          v49 = "masked_load: pass through and return type must match";
        }
      }
      else
      {
        v49 = "masked_load: return must match pointer type";
      }
      goto LABEL_846;
    case 186:
      v103 = *(_QWORD *)(a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF) + 64);
      v104 = (_QWORD **)(v103 + 24);
      v105 = *(unsigned int *)(v103 + 32);
      if (v105 > 0x40)
      {
        if (llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)(v103 + 24)) == (_DWORD)v105)
          goto LABEL_847;
        v252 = 0;
        v253 = (unint64_t)(v105 + 63) >> 6;
        v254 = (int8x8_t *)*v104;
        do
        {
          v255 = *v254++;
          v256 = (uint8x8_t)vcnt_s8(v255);
          v256.i16[0] = vaddlv_u8(v256);
          v252 += v256.i32[0];
          --v253;
        }
        while (v253);
        if (v252 == 1)
          goto LABEL_847;
      }
      else if (((unint64_t)*v104 & ((unint64_t)*v104 - 1)) == 0)
      {
        goto LABEL_847;
      }
      v49 = "masked_scatter: alignment must be 0 or a power of 2";
      goto LABEL_846;
    case 187:
      v242 = a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF);
      v243 = **(_QWORD **)(v242 + 96);
      if ((*(_DWORD *)(v243 + 8) & 0xFE) != 0x12)
      {
        v49 = "masked_store: mask must be vector";
        goto LABEL_846;
      }
      v244 = *(uint64_t **)v242;
      v245 = *(_QWORD *)(v242 + 32);
      v246 = *(int8x8_t **)(v242 + 64);
      v247 = v246[4].u32[0];
      if (v247 > 0x40)
      {
        v274 = 0;
        v275 = (unint64_t)(v247 + 63) >> 6;
        v276 = (int8x8_t *)v246[3];
        do
        {
          v277 = *v276++;
          v278 = (uint8x8_t)vcnt_s8(v277);
          v278.i16[0] = vaddlv_u8(v278);
          v274 += v278.i32[0];
          --v275;
        }
        while (v275);
        if (v274 != 1)
          goto LABEL_455;
      }
      else
      {
        v248 = (uint8x8_t)vcnt_s8(v246[3]);
        v248.i16[0] = vaddlv_u8(v248);
        if (v248.u32[0] != 1)
        {
LABEL_455:
          v49 = "masked_store: alignment must be a power of 2";
          goto LABEL_846;
        }
      }
      v279 = *v244;
      v280 = *(_QWORD *)(*(_QWORD *)v245 + 24);
      if (v280)
        v281 = v280 == v279;
      else
        v281 = 1;
      if (v281)
      {
        if (*(_DWORD *)(v243 + 32) == *(_DWORD *)(v279 + 32)
          && (*(_DWORD *)(v243 + 8) != 19) != (*(_BYTE *)(v279 + 8) == 19))
        {
          goto LABEL_847;
        }
        v49 = "masked_store: vector mask must be same length as value";
      }
      else
      {
        v49 = "masked_store: storee must match pointer type";
      }
      goto LABEL_846;
    case 188:
    case 189:
    case 190:
    case 191:
      __asm { BR              X10 }
      return;
    case 194:
    case 196:
    case 197:
    case 199:
      ParamAlignment = llvm::AttributeList::getParamAlignment((llvm::AttributeList *)(a3 + 64), 0);
      v63 = 1 << ParamAlignment;
      if ((ParamAlignment & 0xFF00) == 0)
        LODWORD(v63) = 0;
      if ((_DWORD)v63)
      {
        v62.i32[0] = v63;
        v64 = (uint8x8_t)vcnt_s8(v62);
        v64.i16[0] = vaddlv_u8(v64);
        if (v64.i32[0] >= 2u)
        {
          v49 = "alignment of arg 0 of memory intrinsic must be 0 or a power of 2";
          goto LABEL_846;
        }
      }
      v65 = *(_DWORD *)(*(_QWORD *)(a3 - 32) + 36) - 194;
      if (v65 <= 3 && v65 != 1)
      {
        v67 = llvm::AttributeList::getParamAlignment((llvm::AttributeList *)(a3 + 64), 1);
        v69 = 1 << v67;
        if ((v67 & 0xFF00) == 0)
          LODWORD(v69) = 0;
        if ((_DWORD)v69)
        {
          v68.i32[0] = v69;
          v70 = (uint8x8_t)vcnt_s8(v68);
          v70.i16[0] = vaddlv_u8(v70);
          if (v70.i32[0] >= 2u)
          {
            v49 = "alignment of arg 1 of memory intrinsic must be 0 or a power of 2";
            goto LABEL_846;
          }
        }
      }
      goto LABEL_847;
    case 195:
    case 198:
    case 200:
      v77 = *(_QWORD *)(a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF) + 96);
      v78 = (llvm::APInt *)(v77 + 24);
      v79 = *(unsigned int *)(v77 + 32);
      if (v79 > 0x40)
      {
        v93 = 0;
        v94 = 0;
        v80 = *(unint64_t **)v78;
        do
        {
          v95 = (uint8x8_t)vcnt_s8((int8x8_t)v80[v93 / 8]);
          v95.i16[0] = vaddlv_u8(v95);
          v94 += v95.i32[0];
          v93 += 8;
        }
        while ((((unint64_t)(v79 + 63) >> 3) & 0x3FFFFFF8) != v93);
        if (v94 == 1)
        {
LABEL_173:
          v82 = llvm::AttributeList::getParamAlignment((llvm::AttributeList *)(a3 + 64), 0);
          if (v82 < 0x100u)
            goto LABEL_542;
          v83 = v82;
          if (v82 > 0x1Fu)
            goto LABEL_542;
          v84 = (unint64_t)v80;
          if (v79 >= 0x41)
          {
            if (v79 - llvm::APInt::countLeadingZerosSlowCase(v78) > 0x40)
              goto LABEL_542;
            v84 = *v80;
          }
          if (v84 <= (1 << v83))
          {
            v85 = *(_DWORD *)(*(_QWORD *)(a3 - 32) + 36);
            if (v85 != 198 && v85 != 195)
              goto LABEL_847;
            v86 = llvm::AttributeList::getParamAlignment((llvm::AttributeList *)(a3 + 64), 1);
            if (v86 >= 0x100u)
            {
              v87 = v86;
              if (v86 <= 0x1Fu)
              {
                if (v79 < 0x41)
                  goto LABEL_186;
                if (v79 - llvm::APInt::countLeadingZerosSlowCase(v78) <= 0x40)
                {
                  v80 = (unint64_t *)*v80;
LABEL_186:
                  if ((unint64_t)v80 <= (1 << v87))
                    goto LABEL_847;
                }
              }
            }
            v49 = "incorrect alignment of the source argument";
            goto LABEL_846;
          }
LABEL_542:
          v49 = "incorrect alignment of the destination argument";
          goto LABEL_846;
        }
      }
      else
      {
        v80 = *(unint64_t **)v78;
        v81 = (uint8x8_t)vcnt_s8(*(int8x8_t *)v78);
        v81.i16[0] = vaddlv_u8(v81);
        if (v81.u32[0] == 1)
          goto LABEL_173;
      }
      v49 = "element size of the element-wise atomic memory intrinsic must be a power of 2";
      goto LABEL_846;
    case 240:
      v237 = a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF);
      v238 = *(_QWORD *)(v237 + 32);
      v239 = (_QWORD *)(v238 + 24);
      if (*(_DWORD *)(v238 + 32) >= 0x41u)
        v239 = (_QWORD *)*v239;
      if (*v239 <= 1uLL)
      {
        v240 = *(_QWORD *)(v237 + 64);
        v241 = (_QWORD *)(v240 + 24);
        if (*(_DWORD *)(v240 + 32) >= 0x41u)
          v241 = (_QWORD *)*v241;
        if (*v241 < 4uLL)
          goto LABEL_847;
      }
      v49 = "invalid arguments to llvm.prefetch";
      goto LABEL_846;
    case 241:
    case 242:
      goto LABEL_488;
    case 264:
    case 265:
    case 276:
    case 277:
    case 303:
    case 304:
    case 307:
    case 308:
      v51 = a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF);
      v52 = **(_QWORD **)v51;
      v53 = *(_DWORD *)(v52 + 8) & 0xFE;
      if (v53 == 18)
        v54 = *(unsigned __int8 *)(**(_QWORD **)(v52 + 16) + 8);
      else
        v54 = *(_DWORD *)(v52 + 8);
      if (v54 != 13)
      {
        v76 = "first operand of [us][mul|div]_fix[_sat] must be an int type or vector of ints";
        goto LABEL_721;
      }
      v71 = **(_QWORD **)(v51 + 32);
      if ((*(_DWORD *)(v71 + 8) & 0xFE) == 0x12)
        v72 = *(unsigned __int8 *)(**(_QWORD **)(v71 + 16) + 8);
      else
        v72 = *(_DWORD *)(v71 + 8);
      if (v72 != 13)
      {
        v76 = "second operand of [us][mul|div]_fix[_sat] must be an int type or vector of ints";
        goto LABEL_721;
      }
      v73 = *(unint64_t **)(v51 + 64);
      if (*(_DWORD *)(*v73 + 8) >> 8 >= 0x21u)
      {
        v76 = "third argument of [us][mul|div]_fix[_sat] must fit within 32 bits";
        goto LABEL_721;
      }
      if ((a2 - 264) <= 0xD && ((1 << (a2 - 8)) & 0x3003) != 0)
      {
        v74 = v73 + 3;
        if (*((_DWORD *)v73 + 8) >= 0x41u)
          v74 = (unint64_t *)*v74;
        if (v53 == 18)
          v52 = **(_QWORD **)(v52 + 16);
        v75 = *v74;
        if (v75 >= llvm::Type::getPrimitiveSizeInBits((llvm::Type *)v52))
        {
          v76 = "the scale of s[mul|div]_fix[_sat] must be less than the width of the operands";
          goto LABEL_721;
        }
      }
      else
      {
        v96 = v73 + 3;
        if (*((_DWORD *)v73 + 8) >= 0x41u)
          v96 = (unint64_t *)*v96;
        if (v53 == 18)
          v52 = **(_QWORD **)(v52 + 16);
        v97 = *v96;
        if (v97 > llvm::Type::getPrimitiveSizeInBits((llvm::Type *)v52))
        {
          v76 = "the scale of u[mul|div]_fix[_sat] must be less than or equal to the width of the operands";
          goto LABEL_721;
        }
      }
      goto LABEL_847;
    case 286:
      if (*((_BYTE *)llvm::Value::stripPointerCasts(*(llvm::Value **)(a3
                                                                     - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF)
                                                                     + 32))
           + 16) == 59)
        goto LABEL_847;
      v49 = "llvm.stackprotector parameter #2 must resolve to an alloca.";
      goto LABEL_846;
    case 317:
    case 318:
    case 323:
    case 324:
    case 325:
    case 326:
    case 327:
    case 328:
    case 329:
      v50 = **(_QWORD **)(a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF));
      if ((*(_DWORD *)(v50 + 8) & 0xFE) != 0x12 || *(_BYTE *)(**(_QWORD **)(v50 + 16) + 8) != 13)
        goto LABEL_206;
      goto LABEL_847;
    case 319:
    case 322:
      v91 = *(uint64_t **)(a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF) + 32);
      goto LABEL_204;
    case 320:
    case 321:
      v91 = *(uint64_t **)(a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF));
LABEL_204:
      v92 = *v91;
      if ((*(_DWORD *)(v92 + 8) & 0xFE) == 0x12 && *(unsigned __int8 *)(**(_QWORD **)(v92 + 16) + 8) < 7u)
        goto LABEL_847;
LABEL_206:
      v76 = "Intrinsic has incorrect argument type!";
      goto LABEL_721;
    default:
      goto LABEL_847;
  }
}

void sub_1C5458310(llvm::raw_ostream **a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  char *v6;
  char *v7;
  char v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  char *v13;
  unsigned int v14;
  const char *v15;
  char *v16;
  void *v17;
  void **v18[4];
  __int16 v19;
  void *__p;
  char *v21;

  v4 = *(_QWORD *)(a2 - 32);
  v7 = *(char **)(v4 + 48);
  v5 = v4 + 48;
  v6 = v7;
  v8 = *(_BYTE *)(v5 + 23);
  if (v8 >= 0)
    v9 = (char *)v5;
  else
    v9 = v6;
  v10 = *(_QWORD *)(v5 + 8);
  if (v8 >= 0)
    v11 = v8 & 0x7F;
  else
    v11 = v10;
  llvm::InlineAsm::ParseConstraints(v9, v11, (uint64_t *)&__p);
  v12 = (char *)__p;
  v13 = v21;
  if (__p == v21)
    goto LABEL_26;
  v14 = 0;
  while (1)
  {
    if (*(_DWORD *)v12)
    {
      if (*(_DWORD *)v12 != 1 || !v12[13])
        goto LABEL_16;
LABEL_18:
      if (*(_BYTE *)(**(_QWORD **)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF) + 32 * v14) + 8) != 15)
      {
        v15 = "Operand for indirect constraint must have pointer type";
        goto LABEL_23;
      }
      if (!llvm::AttributeList::getParamElementType((llvm::AttributeList *)(a2 + 64), v14))
      {
        v15 = "Operand for indirect constraint must have elementtype attribute";
        goto LABEL_23;
      }
      goto LABEL_15;
    }
    if (v12[13])
      goto LABEL_18;
    if (llvm::CallBase::paramHasAttr(a2, v14, 70))
      break;
LABEL_15:
    ++v14;
LABEL_16:
    v12 += 80;
    if (v12 == v13)
      goto LABEL_25;
  }
  v15 = "Elementtype attribute can only be applied for indirect constraints";
LABEL_23:
  v18[0] = (void **)v15;
  v19 = 259;
  sub_1C6249A24((uint64_t)a1, (llvm::Twine *)v18);
  if (*a1)
    sub_1C6249A88(a1, a2);
LABEL_25:
  v12 = (char *)__p;
LABEL_26:
  if (v12)
  {
    v16 = v21;
    v17 = v12;
    if (v21 != v12)
    {
      do
      {
        v18[0] = (void **)(v16 - 32);
        sub_1C50107D8(v18);
        v18[0] = (void **)(v16 - 64);
        sub_1C4765410(v18);
        v16 -= 80;
      }
      while (v16 != v12);
      v17 = __p;
    }
    v21 = v12;
    operator delete(v17);
  }
}

void sub_1C54584AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v6;
  unsigned __int8 *v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t **v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t ***v14;
  unsigned __int8 **v15;
  unsigned __int8 *v16;
  unsigned __int8 *v17;
  int v18;
  uint64_t v19;
  unsigned __int8 **v20;
  unsigned __int8 *v21;
  unsigned __int8 *v22;
  int v23;
  uint64_t **v24;
  int v25;
  unint64_t v26;
  uint64_t *v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t **v30;
  BOOL v31;
  uint64_t **v32;
  uint64_t **v33[2];
  uint64_t v34;
  uint64_t v35;
  __int16 v36;
  unsigned __int8 *v37;
  _QWORD v38[2];
  const char *v39;
  __int16 v40;
  uint64_t **v41;

  v6 = (_QWORD *)(a4 - 32 * (*(_DWORD *)(a4 + 20) & 0x7FFFFFF));
  v7 = *(unsigned __int8 **)(*v6 + 24);
  v37 = v7;
  v8 = *v7;
  if (v8 > 0x22 || ((1 << v8) & 0x100000006) == 0 && (((1 << v8) & 0x6FFFFFFF0) == 0 || *((_DWORD *)v7 + 2)))
  {
    v36 = 1283;
    v33[0] = (uint64_t **)"invalid llvm.dbg.";
    v34 = a2;
    v35 = a3;
    v38[0] = v33;
    v39 = " intrinsic address/value";
    v40 = 770;
    v41 = (uint64_t **)a4;
    v14 = (uint64_t ***)&v37;
LABEL_47:
    sub_1C62499C4((llvm::raw_ostream **)a1, (llvm::Twine *)v38, (uint64_t *)&v41, v14);
    return;
  }
  v9 = *(_QWORD *)(v6[4] + 24);
  if (*(_BYTE *)v9 != 25)
  {
    v36 = 1283;
    v32 = (uint64_t **)v9;
    v33[0] = (uint64_t **)"invalid llvm.dbg.";
    v34 = a2;
    v35 = a3;
    v38[0] = v33;
    v39 = " intrinsic variable";
    v40 = 770;
LABEL_46:
    v41 = (uint64_t **)a4;
    v14 = &v32;
    goto LABEL_47;
  }
  v10 = *(uint64_t ***)(v6[8] + 24);
  if (*(_BYTE *)v10 != 6)
  {
    v36 = 1283;
    v32 = v10;
    v33[0] = (uint64_t **)"invalid llvm.dbg.";
    v34 = a2;
    v35 = a3;
    v38[0] = v33;
    v39 = " intrinsic expression";
    v40 = 770;
    goto LABEL_46;
  }
  v11 = *(_QWORD *)(a4 + 48);
  if (!v11 || *(_BYTE *)v11 == 5)
  {
    v12 = *(_QWORD *)(a4 + 40);
    if (v12)
      v13 = *(_QWORD *)(v12 + 56);
    else
      v13 = 0;
    v32 = (uint64_t **)v9;
    if (!v11)
    {
      v36 = 1283;
      v33[0] = (uint64_t **)"llvm.dbg.";
      v34 = a2;
      v35 = a3;
      v38[0] = v33;
      v39 = " intrinsic requires a !dbg attachment";
      v40 = 770;
      sub_1C6249CD4(a1, (llvm::Twine *)v38);
      if (!*(_QWORD *)a1)
        return;
      sub_1C6249A88((llvm::raw_ostream **)a1, a4);
      if (v12)
      {
        sub_1C6249A88((llvm::raw_ostream **)a1, v12);
        if (!v13)
          return;
      }
      else if (!v13)
      {
        return;
      }
      sub_1C6249A88((llvm::raw_ostream **)a1, v13);
      return;
    }
    v15 = (unsigned __int8 **)(v9 - 8 * *(unsigned int *)(v9 + 8));
    v16 = *v15;
    if (*v15)
    {
      v17 = *v15;
      do
      {
        v18 = *v17;
        if (v18 == 17)
          break;
        if ((v18 & 0xFE) != 0x12)
          goto LABEL_20;
        v17 = *(unsigned __int8 **)&v17[-8 * *((unsigned int *)v17 + 2) + 8];
      }
      while (v17);
    }
    else
    {
LABEL_20:
      v17 = 0;
    }
    v19 = *(unsigned int *)(v11 + 8);
    v20 = (unsigned __int8 **)(v11 - 8 * v19);
    v21 = *v20;
    if (*v20)
    {
      v22 = *v20;
      while (1)
      {
        v23 = *v22;
        if (v23 == 17)
          break;
        if ((v23 & 0xFE) == 0x12)
        {
          v22 = *(unsigned __int8 **)&v22[-8 * *((unsigned int *)v22 + 2) + 8];
          if (v22)
            continue;
        }
        return;
      }
      if (v17)
      {
        if (v17 == v22)
        {
          v24 = (uint64_t **)v15[3];
          if (v24 && (v25 = *(unsigned __int8 *)v24, (v25 - 11) >= 4) && v25 != 33)
          {
            v38[0] = "invalid type ref";
            v40 = 259;
            v33[0] = v24;
            sub_1C6249DA4((llvm::raw_ostream *)a1, (llvm::Twine *)v38, &v32, v33);
          }
          else if (*(_BYTE *)(a1 + 801) && ((_DWORD)v19 != 2 || !*(_QWORD *)(v11 - 8)))
          {
            v33[0] = (uint64_t **)v9;
            v26 = *(unsigned __int16 *)(v9 + 32);
            if (*(_WORD *)(v9 + 32))
            {
              v27 = (uint64_t *)(a1 + 1816);
              v28 = *(unsigned int *)(a1 + 1824);
              if (v26 > v28)
                sub_1C624A11C(a1 + 1816, v26 - v28);
              v29 = *v27;
              v41 = *(uint64_t ***)(*v27 + 8 * (v26 - 1));
              v30 = v41;
              *(_QWORD *)(v29 + 8 * (v26 - 1)) = v9;
              if (v30)
                v31 = v30 == (uint64_t **)v9;
              else
                v31 = 1;
              if (!v31)
              {
                v38[0] = "conflicting debug info for argument";
                v40 = 259;
                sub_1C6249CD4(a1, (llvm::Twine *)v38);
                if (*(_QWORD *)a1)
                  sub_1C6249F68((llvm::raw_ostream **)a1, a4, &v41, v33);
              }
            }
          }
        }
        else
        {
          v36 = 1283;
          v33[0] = (uint64_t **)"mismatched subprogram between llvm.dbg.";
          v34 = a2;
          v35 = a3;
          v38[0] = v33;
          v39 = " variable and !dbg attachment";
          v40 = 770;
          while ((*v16 & 0xFE) == 0x12)
            v16 = *(unsigned __int8 **)&v16[-8 * *((unsigned int *)v16 + 2) + 8];
          while ((*v21 & 0xFE) == 0x12)
            v21 = *(unsigned __int8 **)&v21[-8 * *((unsigned int *)v21 + 2) + 8];
          sub_1C6249CD4(a1, (llvm::Twine *)v38);
          if (*(_QWORD *)a1)
          {
            sub_1C6249A88((llvm::raw_ostream **)a1, a4);
            if (v12)
              sub_1C6249A88((llvm::raw_ostream **)a1, v12);
            if (v13)
              sub_1C6249A88((llvm::raw_ostream **)a1, v13);
            sub_1C6249C6C((llvm::raw_ostream *)a1, (uint64_t **)v9);
            sub_1C6249C6C((llvm::raw_ostream *)a1, (uint64_t **)v16);
            sub_1C6249C6C((llvm::raw_ostream *)a1, (uint64_t **)v11);
            sub_1C6249C6C((llvm::raw_ostream *)a1, (uint64_t **)v21);
          }
        }
      }
    }
  }
}

BOOL sub_1C5458950(uint64_t a1)
{
  uint64_t v1;

  return *(_BYTE *)(a1 + 16) == 84
      && (v1 = *(_QWORD *)(a1 - 32)) != 0
      && !*(_BYTE *)(v1 + 16)
      && *(_QWORD *)(v1 + 24) == *(_QWORD *)(a1 + 72)
      && (*(_BYTE *)(v1 + 33) & 0x20) != 0
      && *(_DWORD *)(v1 + 36) == 123;
}

void sub_1C545899C(llvm::raw_ostream **a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  BOOL v12;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  BOOL v17;
  uint64_t v19;
  unsigned int v20;
  BOOL v21;
  unsigned int v22;
  BOOL v23;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  uint64_t v35;
  unsigned int v36;
  BOOL v37;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unsigned int v42;
  int v43;
  llvm::LLVMContext *v45;
  _QWORD *v46;
  char v47;
  unsigned int v48;
  BOOL v49;
  BOOL v50;
  int v51;
  _QWORD **v52;
  int v53;
  const char *v54;
  llvm::raw_ostream **v55;
  uint64_t v56;
  unsigned int v57;
  BOOL v58;
  llvm::raw_ostream **v60;
  uint64_t v61;
  const char *v62;
  _QWORD v63[4];
  __int16 v64;
  const char *v65;
  char *v66;
  uint64_t v67;
  int v68;
  _WORD v69[32];
  uint64_t v70;
  _QWORD *v71;

  v2 = a2;
  v4 = *(_QWORD *)(a2 + 40);
  v5 = *(_QWORD *)(*(_QWORD *)(v4 + 56) + 80);
  if (v5)
    v6 = v5 - 24;
  else
    v6 = 0;
  if (v4 == v6)
  {
    v62 = "EH pad cannot be in entry block.";
LABEL_149:
    v65 = v62;
    v69[0] = 259;
    sub_1C6249A24((uint64_t)a1, (llvm::Twine *)&v65);
    if (!*a1)
      return;
LABEL_150:
    v60 = a1;
    v61 = v2;
LABEL_158:
    sub_1C6249A88(v60, v61);
    return;
  }
  v7 = *(unsigned __int8 *)(a2 + 16);
  if (v7 == 94)
    v8 = a2;
  else
    v8 = 0;
  if (v7 == 94)
  {
    v9 = *(_QWORD *)(v4 + 8);
    if (!v9)
      return;
    while (1)
    {
      v10 = *(_QWORD *)(v9 + 24);
      v11 = *(unsigned __int8 *)(v10 + 16);
      v12 = v10 && v11 >= 0x1C;
      if (v12 && v11 - 29 <= 0xA)
        break;
      v9 = *(_QWORD *)(v9 + 8);
      if (!v9)
        return;
    }
LABEL_55:
    v25 = *(_QWORD *)(v10 + 40);
    v26 = *(_QWORD *)(v25 + 40);
    if (v26 != v25 + 40)
    {
      v19 = v26 - 24;
      if (!v26)
        v19 = 0;
      v20 = *(unsigned __int8 *)(v19 + 16) - 40;
      if (v20 < 0xFFFFFFF5)
        v19 = 0;
      if (v26)
      {
        v21 = *(_BYTE *)(v19 + 16) == 33 && v20 >= 0xFFFFFFF5;
        if (v21 && *(_QWORD *)(v19 - 64) == v4 && *(_QWORD *)(v19 - 96) != v4)
        {
          while (1)
          {
            v9 = *(_QWORD *)(v9 + 8);
            if (!v9)
              return;
            v10 = *(_QWORD *)(v9 + 24);
            v22 = *(unsigned __int8 *)(v10 + 16);
            if (v10)
              v23 = v22 >= 0x1C;
            else
              v23 = 0;
            if (v23 && v22 - 29 <= 0xA)
              goto LABEL_55;
          }
        }
      }
    }
    v65 = "Block containing LandingPadInst must be jumped to only by the unwind edge of an invoke.";
    v69[0] = 259;
    sub_1C6249A24((uint64_t)a1, (llvm::Twine *)&v65);
    if (!*a1)
      return;
    goto LABEL_157;
  }
  if (v7 == 80)
    v8 = a2;
  else
    v8 = 0;
  if (v7 == 80)
  {
    v14 = *(_QWORD *)(v4 + 8);
    if (!v14)
      goto LABEL_64;
    while (1)
    {
      v15 = *(_QWORD *)(v14 + 24);
      v16 = *(unsigned __int8 *)(v15 + 16);
      v17 = v15 && v16 >= 0x1C;
      if (v17 && v16 - 29 <= 0xA)
        break;
      v14 = *(_QWORD *)(v14 + 8);
      if (!v14)
        goto LABEL_64;
    }
    if (llvm::BasicBlock::getUniquePredecessor(*(llvm::BasicBlock **)(a2 + 40)) == *(_QWORD *)(*(_QWORD *)(v8 - 32)
                                                                                              + 40))
    {
LABEL_64:
      v29 = *(_QWORD *)(v8 - 32);
      if ((*(_WORD *)(v29 + 18) & 1) != 0)
      {
        v31 = *(_DWORD *)(v29 + 20);
        if ((v31 & 0x40000000) != 0)
          v32 = *(_QWORD *)(v29 - 8);
        else
          v32 = v29 - 32 * (v31 & 0x7FFFFFF);
        v30 = *(_QWORD *)(v32 + 32);
      }
      else
      {
        v30 = 0;
      }
      if (v4 != v30)
        return;
      v65 = "Catchswitch cannot unwind to one of its catchpads";
      v69[0] = 259;
      sub_1C6249A24((uint64_t)a1, (llvm::Twine *)&v65);
      if (!*a1)
        return;
      sub_1C6249A88(a1, v29);
LABEL_157:
      v60 = a1;
      v61 = v8;
      goto LABEL_158;
    }
    v62 = "Block containg CatchPadInst must be jumped to only by its catchswitch.";
    goto LABEL_149;
  }
  v71 = (_QWORD *)a2;
  if (v7 < 0x1C || v7 - 81 < 0xFFFFFFFE)
  {
    v28 = *(_DWORD *)(a2 + 20);
    if ((v28 & 0x40000000) != 0)
      v27 = *(_QWORD **)(a2 - 8);
    else
      v27 = (_QWORD *)(a2 - 32 * (v28 & 0x7FFFFFF));
  }
  else
  {
    v27 = (_QWORD *)(a2 - 32);
  }
  v33 = *(_QWORD *)(v4 + 8);
  if (!v33)
    return;
  v34 = (_QWORD *)*v27;
  while (1)
  {
    v35 = *(_QWORD *)(v33 + 24);
    v36 = *(unsigned __int8 *)(v35 + 16);
    v37 = v35 && v36 >= 0x1C;
    if (v37 && v36 - 29 < 0xB)
      break;
    v33 = *(_QWORD *)(v33 + 8);
    if (!v33)
      return;
  }
LABEL_81:
  v39 = *(_QWORD *)(v35 + 40);
  v40 = *(_QWORD *)(v39 + 40);
  if (v40 == v39 + 40)
  {
    v2 = 0;
    v70 = 0;
    v43 = MEMORY[0x10];
  }
  else
  {
    v41 = v40 - 24;
    if (!v40)
      v41 = 0;
    v42 = *(unsigned __int8 *)(v41 + 16) - 40;
    if (v42 >= 0xFFFFFFF5)
      v2 = v41;
    else
      v2 = 0;
    v70 = v2;
    v43 = *(unsigned __int8 *)(v2 + 16);
    if (v40)
    {
      if (v43 == 33 && v42 >= 0xFFFFFFF5)
      {
        if (*(_QWORD *)(v2 - 64) != v4 || *(_QWORD *)(v2 - 96) == v4)
        {
          v65 = "EH pad must be jumped to via an unwind edge";
          v69[0] = 259;
          sub_1C6249A24((uint64_t)a1, (llvm::Twine *)&v65);
          if (!*a1)
            return;
          if (v71)
            sub_1C6249A88(a1, (uint64_t)v71);
          goto LABEL_150;
        }
        sub_1C5062CEC(v2, 1, (uint64_t)&v65);
        if ((_BYTE)v68)
          v46 = *(_QWORD **)v65;
        else
          v46 = llvm::ConstantTokenNone::get(**(llvm::ConstantTokenNone ***)v2, v45);
        goto LABEL_103;
      }
    }
  }
  if (v43 == 38)
  {
    v46 = (_QWORD *)v2;
  }
  else
  {
    if (v43 != 36)
    {
      v65 = "EH pad must be jumped to via an unwind edge";
      v69[0] = 259;
      sub_1C6249880(a1, (llvm::Twine *)&v65, (uint64_t *)&v71, &v70);
      return;
    }
    v46 = *(_QWORD **)(v2 - 32 * (*(_DWORD *)(v2 + 20) & 0x7FFFFFF));
    if (v46 == v34)
    {
      v62 = "A cleanupret must exit its cleanup";
      goto LABEL_149;
    }
  }
LABEL_103:
  v65 = (const char *)v69;
  v66 = (char *)v69;
  v67 = 8;
  v68 = 0;
  while (1)
  {
    if (v46 == v71)
    {
      v63[0] = "EH pad cannot handle exceptions raised within it";
      v64 = 259;
      sub_1C6249A24((uint64_t)a1, (llvm::Twine *)v63);
      if (!*a1)
        goto LABEL_132;
      if (v46)
        sub_1C6249A88(a1, (uint64_t)v46);
      goto LABEL_131;
    }
    if (v46 == v34)
    {
      v53 = 1;
      goto LABEL_133;
    }
    if (*((_BYTE *)v46 + 16) == 20)
    {
      v54 = "A single unwind edge may only enter one EH pad";
      goto LABEL_130;
    }
    sub_1C4774094((llvm::SmallPtrSetImplBase *)&v65, (uint64_t)v46);
    if (!v47)
    {
      v63[0] = "EH pad jumps through a cycle of pads";
      v64 = 259;
      sub_1C6249A24((uint64_t)a1, (llvm::Twine *)v63);
      if (!*a1)
        goto LABEL_132;
      v55 = a1;
      v56 = (uint64_t)v46;
      goto LABEL_147;
    }
    v48 = *((unsigned __int8 *)v46 + 16);
    v49 = v48 <= 0x1B || v48 - 79 >= 2;
    v50 = !v49;
    if (v48 != 38 && !v50)
      break;
    if (v48 - 81 >= 0xFFFFFFFE)
    {
      v52 = (_QWORD **)(v46 - 4);
    }
    else
    {
      v51 = *((_DWORD *)v46 + 5);
      if ((v51 & 0x40000000) != 0)
        v52 = (_QWORD **)*(v46 - 1);
      else
        v52 = (_QWORD **)&v46[-4 * (v51 & 0x7FFFFFF)];
    }
    v46 = *v52;
  }
  v54 = "Parent pad must be catchpad/cleanuppad/catchswitch";
LABEL_130:
  v63[0] = v54;
  v64 = 259;
  sub_1C6249A24((uint64_t)a1, (llvm::Twine *)v63);
  if (!*a1)
    goto LABEL_132;
LABEL_131:
  v56 = v70;
  if (!v70)
    goto LABEL_132;
  v55 = a1;
LABEL_147:
  sub_1C6249A88(v55, v56);
LABEL_132:
  v53 = 0;
LABEL_133:
  if (v66 != v65)
    free(v66);
  if (v53)
  {
    while (1)
    {
      v33 = *(_QWORD *)(v33 + 8);
      if (!v33)
        break;
      v35 = *(_QWORD *)(v33 + 24);
      v57 = *(unsigned __int8 *)(v35 + 16);
      if (v35)
        v58 = v57 >= 0x1C;
      else
        v58 = 0;
      if (v58 && v57 - 29 < 0xB)
        goto LABEL_81;
    }
  }
}

void sub_1C5458F54(llvm::raw_ostream **a1, uint64_t a2)
{
  const char *v4;
  __int16 v5;

  if (**(_QWORD **)(a2 - 64) == **(_QWORD **)(a2 - 32))
    __asm { BR              X11 }
  v4 = "Both operands to a binary operator are not of the same type!";
  v5 = 259;
  sub_1C6249A24((uint64_t)a1, (llvm::Twine *)&v4);
  if (*a1)
    sub_1C6249A88(a1, a2);
}

void sub_1C5459144(uint64_t a1, llvm::Type *a2, uint64_t a3)
{
  unsigned int v4;
  const char *v5;
  const char *v6;
  unsigned int v7;
  const char *v8;
  __int16 v9;
  uint64_t v10;
  llvm::Type *v11;

  v10 = a3;
  v11 = a2;
  sub_1C4768AD0(*(_QWORD *)(a1 + 176), (uint64_t)a2);
  if ((_DWORD)v5 == 1)
  {
    v7 = v4;
    v4 = v7;
  }
  if (v4 <= 7)
  {
    v6 = "atomic memory access' size must be byte-sized";
LABEL_8:
    v8 = v6;
    v9 = 259;
    sub_1C624A188((llvm::raw_ostream **)a1, (llvm::Twine *)&v8, &v11, &v10);
    return;
  }
  if ((v4 & (v4 - 1)) != 0)
  {
    v6 = "atomic memory access' operand must have a power-of-two size";
    goto LABEL_8;
  }
}

void sub_1C54591E4(llvm::raw_ostream **a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  llvm::LLVMContext *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t i;
  _QWORD *v17;
  uint64_t v18;
  int v19;
  int v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  BOOL v27;
  uint64_t *v28;
  int v29;
  unsigned int v30;
  _QWORD *v31;
  int v32;
  uint64_t v33;
  unsigned int v34;
  BOOL v35;
  int v37;
  uint64_t *v38;
  uint64_t v39;
  unsigned int v40;
  BOOL v41;
  uint64_t *v42;
  int v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t j;
  _QWORD *v50;
  uint64_t v51;
  llvm::raw_ostream **v52;
  uint64_t v53;
  BOOL v54;
  uint64_t v55;
  uint64_t v57[4];
  __int16 v58;
  _BYTE *v59;
  _BYTE *v60;
  uint64_t v61;
  int v62;
  _BYTE v63[64];
  void *v64;
  unsigned int v65;
  unsigned int v66;
  _QWORD v67[10];

  v3 = 0;
  v4 = 0;
  v67[8] = *MEMORY[0x1E0C80C00];
  v64 = v67;
  v66 = 8;
  v67[0] = a2;
  v59 = v63;
  v60 = v63;
  v61 = 8;
  v62 = 0;
  v55 = (uint64_t)(a1 + 107);
  LODWORD(v5) = 1;
LABEL_2:
  while (1)
  {
    v6 = *((_QWORD *)v64 + v5 - 1);
    v65 = v5 - 1;
    sub_1C4774094((llvm::SmallPtrSetImplBase *)&v59, v6);
    if (!(_BYTE)v7)
      break;
    v8 = *(_QWORD *)(v6 + 8);
    if (v8)
    {
      v9 = 0;
      while (1)
      {
        v10 = *(_QWORD *)(v8 + 24);
        v11 = *(unsigned __int8 *)(v10 + 16);
        if (v10)
        {
          if (v11 == 36)
            break;
        }
        if (v10 && v11 == 38)
        {
          if ((*(_WORD *)(v10 + 18) & 1) == 0)
            goto LABEL_63;
          v12 = *(_DWORD *)(v10 + 20);
          if ((v12 & 0x40000000) != 0)
          {
            v13 = *(_QWORD *)(v10 - 8);
            goto LABEL_10;
          }
LABEL_9:
          v13 = v10 - 32 * (v12 & 0x7FFFFFF);
LABEL_10:
          v14 = (uint64_t *)(v13 + 32);
          goto LABEL_11;
        }
        if (v11 != 33)
        {
          if (v11 != 84)
          {
            if (v10 && v11 == 79)
            {
              v23 = v65;
              if (v65 >= (unint64_t)v66)
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, (uint64_t)v67, v65 + 1, 8);
                v23 = v65;
              }
              *((_QWORD *)v64 + v23) = v10;
              ++v65;
            }
            else if (v11 != 37)
            {
              v57[0] = (uint64_t)"Bogus funclet pad use";
              v58 = 259;
              sub_1C6249A24((uint64_t)a1, (llvm::Twine *)v57);
              if (*a1)
              {
                v52 = a1;
                v53 = v10;
                goto LABEL_151;
              }
              goto LABEL_140;
            }
          }
          goto LABEL_63;
        }
        v14 = (uint64_t *)(v10 - 64);
LABEL_11:
        v15 = *v14;
        if (v15)
        {
          for (i = *(_QWORD *)(v15 + 48); ; i = *(_QWORD *)(i + 8))
          {
            v17 = (_QWORD *)(i - 24);
            v18 = i ? i - 24 : 0;
            if (*(_BYTE *)(v18 + 16) != 83)
              break;
          }
          v19 = *(unsigned __int8 *)(i - 8);
          if ((v19 - 38) > 0x38 || ((1 << (v19 - 38)) & 0x100060000000001) == 0)
            goto LABEL_63;
          if ((v19 - 81) >= 0xFFFFFFFE)
          {
            v22 = (uint64_t *)(i - 56);
          }
          else
          {
            v21 = *(_DWORD *)(i - 4);
            v22 = (v21 & 0x40000000) != 0 ? *(uint64_t **)(i - 32) : &v17[-4 * (v21 & 0x7FFFFFF)];
          }
          v24 = *v22;
          if (v24 == v6)
            goto LABEL_63;
          v25 = v6;
          while (v25 != a2)
          {
            if (v25
              && ((v26 = *(unsigned __int8 *)(v25 + 16), v26 >= 0x1C) ? (v27 = v26 - 81 >= 0xFFFFFFFE) : (v27 = 0), v27))
            {
              v28 = (uint64_t *)(v25 - 32);
            }
            else
            {
              v29 = *(_DWORD *)(v25 + 20);
              if ((v29 & 0x40000000) != 0)
                v28 = *(uint64_t **)(v25 - 8);
              else
                v28 = (uint64_t *)(v25 - 32 * (v29 & 0x7FFFFFF));
            }
            v25 = *v28;
            if (v25 == v24)
            {
              v10 = v3;
              goto LABEL_61;
            }
            if (*(_BYTE *)(v25 + 16) == 20)
            {
              v10 = v3;
              v24 = v9;
              goto LABEL_61;
            }
          }
          goto LABEL_58;
        }
LABEL_57:
        v17 = llvm::ConstantTokenNone::get(**(llvm::ConstantTokenNone ***)a2, v7);
LABEL_58:
        if (v3)
        {
          if (v17 != v4)
          {
            v57[0] = (uint64_t)"Unwind edges out of a funclet pad must have the same unwind dest";
            v58 = 259;
            sub_1C6249A24((uint64_t)a1, (llvm::Twine *)v57);
            if (!*a1)
              goto LABEL_140;
            sub_1C6249A88(a1, a2);
            if (v10)
              sub_1C6249A88(a1, v10);
            v52 = a1;
            v53 = v3;
            goto LABEL_151;
          }
          v10 = v3;
          v24 = a2;
LABEL_61:
          v17 = v4;
        }
        else
        {
          if (*(_BYTE *)(a2 + 16) == 79)
          {
            v30 = *((unsigned __int8 *)v17 + 16);
            if (v30 != 20)
            {
              if (v30 < 0x1C || v30 - 81 < 0xFFFFFFFE)
              {
                v32 = *((_DWORD *)v17 + 5);
                v31 = (v32 & 0x40000000) != 0 ? (_QWORD *)*(v17 - 1) : &v17[-4 * (v32 & 0x7FFFFFF)];
              }
              else
              {
                v31 = v17 - 4;
              }
              if (*v31 == *(_QWORD *)(a2 - 32))
              {
                v57[0] = a2;
                *(_QWORD *)sub_1C6194570(v55, v57) = v10;
              }
            }
          }
          v24 = a2;
        }
        v3 = v10;
        v4 = v17;
        v9 = v24;
        if (v6 != a2)
        {
LABEL_78:
          v5 = v65;
          if (!v24 || v6 == v24)
          {
LABEL_108:
            v3 = v10;
            v4 = v17;
            if ((_DWORD)v5)
              goto LABEL_2;
            goto LABEL_111;
          }
          if (v65)
          {
            do
            {
              v33 = *((_QWORD *)v64 + v5 - 1);
              v34 = *(unsigned __int8 *)(v33 + 16);
              if (v33)
                v35 = v34 >= 0x1C;
              else
                v35 = 0;
              if (v35 && v34 - 81 >= 0xFFFFFFFE)
              {
                v38 = (uint64_t *)(v33 - 32);
              }
              else
              {
                v37 = *(_DWORD *)(v33 + 20);
                if ((v37 & 0x40000000) != 0)
                  v38 = *(uint64_t **)(v33 - 8);
                else
                  v38 = (uint64_t *)(v33 - 32 * (v37 & 0x7FFFFFF));
              }
              v39 = *v38;
              while (v6 != v39)
              {
                if (v6
                  && ((v40 = *(unsigned __int8 *)(v6 + 16), v40 >= 0x1C) ? (v41 = v40 - 81 >= 0xFFFFFFFE) : (v41 = 0),
                      v41))
                {
                  v42 = (uint64_t *)(v6 - 32);
                }
                else
                {
                  v43 = *(_DWORD *)(v6 + 20);
                  if ((v43 & 0x40000000) != 0)
                    v42 = *(uint64_t **)(v6 - 8);
                  else
                    v42 = (uint64_t *)(v6 - 32 * (v43 & 0x7FFFFFF));
                }
                v6 = *v42;
                if (*v42 == v24)
                  goto LABEL_108;
              }
              v6 = v39;
              v65 = --v5;
            }
            while ((_DWORD)v5);
          }
          v3 = v10;
          v4 = v17;
          if (!v17)
            goto LABEL_139;
LABEL_114:
          v44 = *(_QWORD *)(a2 - 32);
          if (!v44 || *(_BYTE *)(v44 + 16) != 38)
            goto LABEL_139;
          if ((*(_WORD *)(v44 + 18) & 1) != 0
            && ((v45 = *(_DWORD *)(v44 + 20), (v45 & 0x40000000) != 0)
              ? (v46 = *(_QWORD *)(v44 - 8))
              : (v46 = v44 - 32 * (v45 & 0x7FFFFFF)),
                (v47 = *(_QWORD *)(v46 + 32)) != 0))
          {
            v48 = v47 + 40;
            for (j = *(_QWORD *)(v47 + 48); j != v48; j = *(_QWORD *)(j + 8))
            {
              v50 = (_QWORD *)(j - 24);
              if (j)
                v51 = j - 24;
              else
                v51 = 0;
              if (*(_BYTE *)(v51 + 16) != 83)
                goto LABEL_138;
            }
            v50 = 0;
          }
          else
          {
            v50 = llvm::ConstantTokenNone::get(**(llvm::ConstantTokenNone ***)a2, v7);
          }
LABEL_138:
          if (v50 == v4)
          {
LABEL_139:
            sub_1C5450C74((uint64_t)a1, (uint64_t ***)a2);
            goto LABEL_140;
          }
          v57[0] = (uint64_t)"Unwind edges out of a catch must have the same unwind dest as the parent catchswitch";
          v58 = 259;
          sub_1C6249A24((uint64_t)a1, (llvm::Twine *)v57);
          if (*a1)
          {
            sub_1C6249A88(a1, a2);
            if (v3)
              sub_1C6249A88(a1, v3);
            v52 = a1;
            v53 = v44;
LABEL_151:
            sub_1C6249A88(v52, v53);
          }
          goto LABEL_140;
        }
LABEL_63:
        v8 = *(_QWORD *)(v8 + 8);
        v10 = v3;
        v17 = v4;
        v24 = v9;
        if (!v8)
          goto LABEL_78;
      }
      if ((*(_WORD *)(v10 + 18) & 1) == 0)
        goto LABEL_57;
      v12 = *(_DWORD *)(v10 + 20);
      goto LABEL_9;
    }
    LODWORD(v5) = v65;
    if (!v65)
    {
LABEL_111:
      if (v4)
        goto LABEL_114;
      goto LABEL_139;
    }
  }
  v57[0] = (uint64_t)"FuncletPadInst must not be nested within itself";
  v58 = 259;
  sub_1C6249A24((uint64_t)a1, (llvm::Twine *)v57);
  if (v6)
    v54 = *a1 == 0;
  else
    v54 = 1;
  if (!v54)
  {
    v52 = a1;
    v53 = v6;
    goto LABEL_151;
  }
LABEL_140:
  if (v60 != v59)
    free(v60);
  if (v64 != v67)
    free(v64);
}

void sub_1C545982C(llvm::Type *a1, uint64_t a2)
{
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  int v23;
  const char *v24;
  uint64_t v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  BOOL v39;
  unsigned int v40;
  uint64_t *v41;
  uint64_t v42;
  _QWORD *v43;
  _QWORD *v44;
  const char *v45;
  uint64_t v46;
  const char *v47;
  llvm::raw_ostream **v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  const char *v55;
  uint64_t v56;
  const char *v57;
  uint64_t v58;
  __int16 v59;
  void *v60;
  void *v61[2];
  uint64_t v62;
  __int16 v63;
  void **v64;
  void *v65;
  const char *v66;
  uint64_t v67;
  __int16 v68;
  uint64_t v69;

  v69 = *MEMORY[0x1E0C80C00];
  sub_1C545350C(a1, a2);
  v4 = *(unsigned __int16 *)(a2 + 18);
  if ((v4 & 3) != 2)
    return;
  v5 = *(_QWORD *)(a2 - 32);
  if (*(_BYTE *)(v5 + 16) == 24)
  {
    v45 = "cannot use musttail call with inline asm";
    goto LABEL_89;
  }
  v6 = *(_QWORD *)(a2 + 40);
  v7 = *(_QWORD *)(v6 + 56);
  v8 = *(_QWORD *)(v7 + 24);
  v9 = *(_QWORD *)(a2 + 72);
  if (*(_DWORD *)(v8 + 8) > 0xFFu != *(_DWORD *)(v9 + 8) > 0xFFu)
  {
    v45 = "cannot guarantee tail call due to mismatched varargs";
    goto LABEL_89;
  }
  v10 = *(uint64_t **)(v8 + 16);
  v11 = *v10;
  v12 = *(uint64_t **)(v9 + 16);
  v13 = *v12;
  if (*v10 != *v12)
  {
    if (*(_BYTE *)(v11 + 8) != 15)
      v11 = 0;
    if (*(_BYTE *)(v13 + 8) != 15)
      v13 = 0;
    v14 = !v11 || v13 == 0;
    if (v14 || (*(_DWORD *)(v13 + 8) ^ *(_DWORD *)(v11 + 8)) >= 0x100)
    {
      v45 = "cannot guarantee tail call due to mismatched return types";
      goto LABEL_89;
    }
  }
  if ((((*(unsigned __int16 *)(v7 + 18) >> 4) ^ (v4 >> 2)) & 0x3FF) != 0)
  {
    v45 = "cannot guarantee tail call due to mismatched calling conv";
    goto LABEL_89;
  }
  v15 = *(_QWORD *)(a2 + 32);
  if (v15 == v6 + 40 || !v15)
    goto LABEL_84;
  v16 = v15 - 24;
  if (*(_BYTE *)(v15 - 8) == 77)
  {
    if (*(_QWORD *)(v15 - 56) != a2)
    {
      v47 = "bitcast following musttail call must use the call";
LABEL_102:
      v64 = (void **)v47;
      v68 = 259;
      sub_1C6249A24((uint64_t)a1, (llvm::Twine *)&v64);
      if (!*(_QWORD *)a1)
        return;
      v48 = (llvm::raw_ostream **)a1;
      v49 = v16;
LABEL_98:
      sub_1C6249A88(v48, v49);
      return;
    }
    v18 = v15 + 8;
    v17 = *(_QWORD *)(v15 + 8);
    if (v17 == *(_QWORD *)(v18 + 8) + 40 || !v17)
      goto LABEL_84;
    v19 = v16;
    v16 = v17 - 24;
  }
  else
  {
    v19 = a2;
  }
  if (*(_BYTE *)(v16 + 16) != 29)
  {
LABEL_84:
    v45 = "musttail call must precede a ret with an optional bitcast";
LABEL_89:
    v64 = (void **)v45;
    v68 = 259;
    sub_1C6249A24((uint64_t)a1, (llvm::Twine *)&v64);
    if (!*(_QWORD *)a1)
      return;
    v48 = (llvm::raw_ostream **)a1;
    v49 = a2;
    goto LABEL_98;
  }
  v20 = *(_DWORD *)(v16 + 20) & 0x7FFFFFF;
  if ((_DWORD)v20)
  {
    v21 = *(_QWORD *)(v16 - 32 * v20);
    v22 = !v21 || v21 == v19;
    if (!v22 && *(unsigned __int8 *)(v21 + 16) - 11 >= 2)
    {
      v47 = "musttail call result must be returned";
      goto LABEL_102;
    }
  }
  v53 = *(_QWORD *)(v7 + 112);
  v54 = *(_QWORD *)(a2 + 64);
  v23 = (v4 >> 2) & 0x3FF;
  if (v23 == 20 || v23 == 18)
  {
    v51 = *(_QWORD *)(a2 + 72);
    v52 = *(_QWORD *)(v7 + 24);
    if ((v4 & 0xFFC) == 0x48)
      v24 = "tailcc";
    else
      v24 = "swifttailcc";
    if ((v4 & 0xFFC) == 0x48)
      v25 = 6;
    else
      v25 = 11;
    v26 = *(_DWORD *)(v8 + 12);
    v27 = v26 - 1;
    if (v26 != 1)
    {
      v28 = 0;
      do
      {
        sub_1C5459E98((uint64_t)&v64, **(_QWORD **)v7, v28, v53);
        v55 = v24;
        v56 = v25;
        v57 = " musttail caller";
        v58 = 16;
        v60 = &v62;
        *(_OWORD *)v61 = xmmword_1C677F680;
        sub_1C545A0D0(&v60, (uint64_t)&v55, 2);
        sub_1C5459FF4((uint64_t)a1, (uint64_t)&v64, (uint64_t)v60, (uint64_t)v61[0]);
        if (v60 != &v62)
          free(v60);
        if (v65 != &v67)
          free(v65);
        ++v28;
      }
      while (v27 != v28);
    }
    v29 = *(_DWORD *)(v51 + 12);
    v30 = v29 - 1;
    if (v29 != 1)
    {
      v31 = 0;
      do
      {
        sub_1C5459E98((uint64_t)&v64, **(_QWORD **)v7, v31, v54);
        v55 = v24;
        v56 = v25;
        v57 = " musttail callee";
        v58 = 16;
        v60 = &v62;
        *(_OWORD *)v61 = xmmword_1C677F680;
        sub_1C545A0D0(&v60, (uint64_t)&v55, 2);
        sub_1C5459FF4((uint64_t)a1, (uint64_t)&v64, (uint64_t)v60, (uint64_t)v61[0]);
        if (v60 != &v62)
          free(v60);
        if (v65 != &v67)
          free(v65);
        ++v31;
      }
      while (v30 != v31);
    }
    if (*(_DWORD *)(v52 + 8) > 0xFFu)
    {
      v60 = "cannot guarantee ";
      v61[1] = (void *)v24;
      v62 = v25;
      v63 = 1283;
      v64 = &v60;
      v66 = " tail call for varargs function";
      v68 = 770;
      sub_1C6249A24((uint64_t)a1, (llvm::Twine *)&v64);
    }
    return;
  }
  if (!*(_BYTE *)(v5 + 16) && *(_QWORD *)(v5 + 24) == v9 && (*(_BYTE *)(v5 + 33) & 0x20) != 0)
  {
    v50 = *(_DWORD *)(v8 + 12);
    LODWORD(v33) = v50 - 1;
    if (v50 == 1)
      return;
    goto LABEL_72;
  }
  v32 = *(_DWORD *)(v8 + 12);
  if (v32 != *(_DWORD *)(v9 + 12))
  {
    v45 = "cannot guarantee tail call due to mismatched parameter counts";
    goto LABEL_89;
  }
  v33 = (v32 - 1);
  if (v32 == 1)
    return;
  v34 = v12 + 1;
  v35 = v10 + 1;
  v36 = v33;
  do
  {
    v37 = *v35;
    v38 = *v34;
    if (*v35 != *v34)
    {
      if (*(_BYTE *)(v37 + 8) != 15)
        v37 = 0;
      if (*(_BYTE *)(v38 + 8) != 15)
        v38 = 0;
      v39 = !v37 || v38 == 0;
      if (v39 || (*(_DWORD *)(v38 + 8) ^ *(_DWORD *)(v37 + 8)) >= 0x100)
      {
        v45 = "cannot guarantee tail call due to mismatched parameter types";
        goto LABEL_89;
      }
    }
    ++v34;
    ++v35;
    --v36;
  }
  while (v36);
  if (!(_DWORD)v33)
    return;
LABEL_72:
  v40 = 0;
  while (1)
  {
    sub_1C5459E98((uint64_t)&v64, **(_QWORD **)v7, v40, v53);
    sub_1C5459E98((uint64_t)&v60, **(_QWORD **)v7, v40, v54);
    if ((_DWORD)v66 != LODWORD(v61[1]))
      break;
    v41 = (uint64_t *)v65;
    if ((_DWORD)v66)
    {
      v42 = 8 * v66;
      v43 = v61[0];
      v44 = v65;
      while (*v44 == *v43)
      {
        ++v44;
        ++v43;
        v42 -= 8;
        if (!v42)
          goto LABEL_78;
      }
      break;
    }
LABEL_78:
    if (v61[0] != &v62)
    {
      free(v61[0]);
      v41 = (uint64_t *)v65;
    }
    if (v41 != &v67)
      free(v41);
    if (++v40 == (_DWORD)v33)
      return;
  }
  v55 = "cannot guarantee tail call due to mismatched ABI impacting function attributes";
  v59 = 259;
  v46 = *(_QWORD *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF) + 32 * v40);
  sub_1C6249A24((uint64_t)a1, (llvm::Twine *)&v55);
  if (*(_QWORD *)a1)
  {
    sub_1C6249A88((llvm::raw_ostream **)a1, a2);
    if (v46)
      sub_1C6249A88((llvm::raw_ostream **)a1, v46);
  }
  if (v61[0] != &v62)
    free(v61[0]);
  if (v65 != &v67)
    free(v65);
}

uint64_t sub_1C5459E98(uint64_t result, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v6;
  unsigned int *v7;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  char v11;
  uint64_t v13;
  __int16 ParamAlignment;
  uint64_t v15;

  v6 = result;
  v15 = a4;
  *(_QWORD *)result = a2;
  *(_QWORD *)(result + 8) = result + 24;
  v7 = (unsigned int *)(result + 8);
  *(_QWORD *)(result + 16) = 0x800000000;
  v8 = (a3 + 2);
  v9 = a4 + 40;
  v10 = &dword_1C8651674;
  do
  {
    while (!a4)
    {
      if (++v10 == (int *)&unk_1C865169C)
        return result;
    }
    if (v8 < *(_DWORD *)(a4 + 8))
    {
      result = *(_QWORD *)(v9 + 8 * v8);
      if (result)
      {
        result = llvm::AttributeSetNode::findEnumAttribute(result, *v10);
        if (v11 && result != 0)
        {
          if (*(_BYTE *)(result + 8) == 2)
            result = sub_1C532EADC((uint64_t)v7, (void *)(result + 24), *(unsigned int *)(result + 12), result);
          else
            result = (uint64_t)sub_1C532EC68(v7, *(_DWORD *)(result + 12), result);
        }
      }
    }
    ++v10;
  }
  while (v10 != (int *)&unk_1C865169C);
  if (v8 < *(_DWORD *)(a4 + 8))
  {
    v13 = *(_QWORD *)(v9 + 8 * v8);
    if (v13)
    {
      if ((*(_BYTE *)(v13 + 21) & 4) != 0 && (*(_BYTE *)(v13 + 20) & 0x30) != 0)
      {
        ParamAlignment = llvm::AttributeList::getParamAlignment((llvm::AttributeList *)&v15, a3);
        return llvm::AttrBuilder::addAlignmentAttr(v6, ParamAlignment);
      }
    }
  }
  return result;
}

void sub_1C5459FF4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  const char *v8;
  _QWORD v9[4];
  __int16 v10;

  if (llvm::AttrBuilder::getAttribute(a2, 71))
  {
    v8 = "inalloca attribute not allowed in ";
  }
  else if (llvm::AttrBuilder::getAttribute(a2, 10))
  {
    v8 = "inreg attribute not allowed in ";
  }
  else if (llvm::AttrBuilder::getAttribute(a2, 63))
  {
    v8 = "swifterror attribute not allowed in ";
  }
  else if (llvm::AttrBuilder::getAttribute(a2, 72))
  {
    v8 = "preallocated attribute not allowed in ";
  }
  else
  {
    if (!llvm::AttrBuilder::getAttribute(a2, 68))
      return;
    v8 = "byref attribute not allowed in ";
  }
  v9[0] = v8;
  v9[2] = a3;
  v9[3] = a4;
  v10 = 1283;
  sub_1C6249A24(a1, (llvm::Twine *)v9);
}

_QWORD *sub_1C545A0D0(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  _QWORD *result;
  size_t *v12;
  size_t v13;

  v4 = a1[1];
  if (!a3)
    return sub_1C5050254(a1, a1[1]);
  v6 = 16 * a3;
  v7 = (uint64_t *)(a2 + 8);
  v8 = 16 * a3;
  v9 = a1[1];
  do
  {
    v10 = *v7;
    v7 += 2;
    v9 += v10;
    v8 -= 16;
  }
  while (v8);
  result = sub_1C5050254(a1, v9);
  v12 = (size_t *)(a2 + 8);
  do
  {
    if (*v12)
    {
      result = memmove((void *)(*a1 + v4), (const void *)*(v12 - 1), *v12);
      v13 = *v12;
    }
    else
    {
      v13 = 0;
    }
    v4 += v13;
    v12 += 2;
    v6 -= 16;
  }
  while (v6);
  return result;
}

uint64_t sub_1C545A178(uint64_t a1)
{
  int v1;
  uint64_t *v2;
  __int16 v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  uint64_t result;
  uint64_t v10;

  v1 = *(unsigned __int8 *)(a1 + 16);
  if (a1 && v1 == 33)
  {
    v2 = (uint64_t *)(a1 - 64);
LABEL_14:
    v6 = *v2;
    goto LABEL_15;
  }
  v3 = *(_WORD *)(a1 + 18);
  if (a1 && v1 == 38)
  {
    if ((v3 & 1) != 0)
    {
      v4 = *(_DWORD *)(a1 + 20);
      if ((v4 & 0x40000000) != 0)
      {
        v5 = *(_QWORD *)(a1 - 8);
LABEL_13:
        v2 = (uint64_t *)(v5 + 32);
        goto LABEL_14;
      }
LABEL_12:
      v5 = a1 - 32 * (v4 & 0x7FFFFFF);
      goto LABEL_13;
    }
  }
  else if ((v3 & 1) != 0)
  {
    v4 = *(_DWORD *)(a1 + 20);
    goto LABEL_12;
  }
  v6 = 0;
LABEL_15:
  v7 = v6 + 40;
  for (i = *(_QWORD *)(v6 + 48); i != v7; i = *(_QWORD *)(i + 8))
  {
    result = i - 24;
    if (i)
      v10 = i - 24;
    else
      v10 = 0;
    if (*(_BYTE *)(v10 + 16) != 83)
      return result;
  }
  return 0;
}

uint64_t *sub_1C545A210(uint64_t *result, uint64_t *a2, uint64_t a3, char a4)
{
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t *v39;
  BOOL v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t *v62;
  BOOL v64;
  uint64_t v65;
  uint64_t *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t *v77;
  int64_t v78;
  int64_t v79;
  int64_t v80;
  uint64_t v81;
  uint64_t *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  unint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t *v100;
  uint64_t *v101;
  uint64_t *v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t *v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t *v116;
  uint64_t v117;
  unint64_t v118;
  uint64_t v119;
  unint64_t v120;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t *v126;
  uint64_t v127;
  uint64_t v128;

  v7 = result;
LABEL_2:
  v8 = v7;
  while (2)
  {
    v7 = v8;
    v9 = (char *)a2 - (char *)v8;
    v10 = a2 - v8;
    switch(v10)
    {
      case 0:
      case 1:
        return result;
      case 2:
        v58 = *(a2 - 1);
        v59 = *v8;
        v60 = *(_QWORD *)(*(_QWORD *)(v58 - 32 * (*(_DWORD *)(v58 + 20) & 0x7FFFFFF)) + 24);
        v61 = *(_QWORD *)(*(_QWORD *)(*v8 - 32 * (*(_DWORD *)(*v8 + 20) & 0x7FFFFFF)) + 24);
        if (v60 - 8 * (unint64_t)*(unsigned int *)(v60 + 8) < v61
                                                                    - 8 * (unint64_t)*(unsigned int *)(v61 + 8))
        {
          *v8 = v58;
          *(a2 - 1) = v59;
        }
        return result;
      case 3:
        return sub_1C545AE00(v8, v8 + 1, a2 - 1);
      case 4:
        return sub_1C545B138(v8, v8 + 1, v8 + 2, a2 - 1);
      case 5:
        return sub_1C545AC80(v8, v8 + 1, v8 + 2, v8 + 3, a2 - 1);
      default:
        if (v9 <= 191)
        {
          v62 = v8 + 1;
          v64 = v8 == a2 || v62 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v64)
            {
              v65 = 8;
              v66 = v8;
              do
              {
                v68 = *v66;
                v67 = v66[1];
                v66 = v62;
                v69 = *(_QWORD *)(*(_QWORD *)(v67 - 32 * (*(_DWORD *)(v67 + 20) & 0x7FFFFFF)) + 24);
                v70 = *(_QWORD *)(*(_QWORD *)(v68 - 32 * (*(_DWORD *)(v68 + 20) & 0x7FFFFFF)) + 24);
                if (v69 - 8 * (unint64_t)*(unsigned int *)(v69 + 8) < v70
                                                                            - 8
                                                                            * (unint64_t)*(unsigned int *)(v70 + 8))
                {
                  v71 = v65;
                  while (1)
                  {
                    *(uint64_t *)((char *)v8 + v71) = v68;
                    v72 = v71 - 8;
                    if (v71 == 8)
                      break;
                    v68 = *(uint64_t *)((char *)v8 + v71 - 16);
                    v73 = *(_QWORD *)(*(_QWORD *)(v67 - 32 * (*(_DWORD *)(v67 + 20) & 0x7FFFFFF)) + 24);
                    v74 = v73 - 8 * *(unsigned int *)(v73 + 8);
                    v75 = *(_QWORD *)(*(_QWORD *)(v68 - 32 * (*(_DWORD *)(v68 + 20) & 0x7FFFFFF)) + 24);
                    v76 = v75 - 8 * *(unsigned int *)(v75 + 8);
                    v71 = v72;
                    if (v74 >= v76)
                    {
                      v77 = (uint64_t *)((char *)v8 + v72);
                      goto LABEL_77;
                    }
                  }
                  v77 = v8;
LABEL_77:
                  *v77 = v67;
                }
                v62 = v66 + 1;
                v65 += 8;
              }
              while (v66 + 1 != a2);
            }
          }
          else if (!v64)
          {
            do
            {
              v123 = *v7;
              v122 = v7[1];
              v7 = v62;
              v124 = *(_QWORD *)(*(_QWORD *)(v122 - 32 * (*(_DWORD *)(v122 + 20) & 0x7FFFFFF)) + 24);
              v125 = *(_QWORD *)(*(_QWORD *)(v123 - 32 * (*(_DWORD *)(v123 + 20) & 0x7FFFFFF)) + 24);
              if (v124 - 8 * (unint64_t)*(unsigned int *)(v124 + 8) < v125
                                                                            - 8
                                                                            * (unint64_t)*(unsigned int *)(v125 + 8))
              {
                v126 = v62;
                do
                {
                  *v126 = v123;
                  v123 = *(v126 - 2);
                  v127 = *(_QWORD *)(*(_QWORD *)(v122 - 32 * (*(_DWORD *)(v122 + 20) & 0x7FFFFFF)) + 24);
                  v128 = *(_QWORD *)(*(_QWORD *)(v123 - 32 * (*(_DWORD *)(v123 + 20) & 0x7FFFFFF)) + 24);
                  --v126;
                }
                while (v127 - 8 * (unint64_t)*(unsigned int *)(v127 + 8) < v128
                                                                                 - 8
                                                                                 * (unint64_t)*(unsigned int *)(v128 + 8));
                *v126 = v122;
              }
              v62 = v7 + 1;
            }
            while (v7 + 1 != a2);
          }
          return result;
        }
        if (!a3)
        {
          if (v8 != a2)
          {
            v78 = (unint64_t)(v10 - 2) >> 1;
            v79 = v78;
            do
            {
              v80 = v79;
              if (v78 >= v79)
              {
                v81 = (2 * v79) | 1;
                v82 = &v8[v81];
                v83 = *v82;
                if (2 * v80 + 2 < v10)
                {
                  v84 = *(_QWORD *)(*(_QWORD *)(v83 - 32 * (*(_DWORD *)(v83 + 20) & 0x7FFFFFF)) + 24);
                  v85 = *(_QWORD *)(*(_QWORD *)(v82[1] - 32 * (*(_DWORD *)(v82[1] + 20) & 0x7FFFFFF)) + 24);
                  if (v84 - 8 * (unint64_t)*(unsigned int *)(v84 + 8) < v85
                                                                              - 8
                                                                              * (unint64_t)*(unsigned int *)(v85 + 8))
                  {
                    v83 = v82[1];
                    ++v82;
                    v81 = 2 * v80 + 2;
                  }
                }
                v86 = &v8[v80];
                v87 = *v86;
                v88 = *(_QWORD *)(*(_QWORD *)(v83 - 32 * (*(_DWORD *)(v83 + 20) & 0x7FFFFFF)) + 24);
                v89 = *(_QWORD *)(*(_QWORD *)(*v86 - 32 * (*(_DWORD *)(*v86 + 20) & 0x7FFFFFF)) + 24);
                result = (uint64_t *)*(unsigned int *)(v89 + 8);
                if (v88 - 8 * (unint64_t)*(unsigned int *)(v88 + 8) >= v89 - 8 * (uint64_t)result)
                {
                  do
                  {
                    v90 = v82;
                    *v86 = v83;
                    if (v78 < v81)
                      break;
                    v91 = (2 * v81) | 1;
                    v82 = &v8[v91];
                    v92 = 2 * v81 + 2;
                    v83 = *v82;
                    if (v92 < v10)
                    {
                      v93 = *(_QWORD *)(*(_QWORD *)(v83 - 32 * (*(_DWORD *)(v83 + 20) & 0x7FFFFFF)) + 24);
                      v94 = *(_QWORD *)(*(_QWORD *)(v82[1] - 32 * (*(_DWORD *)(v82[1] + 20) & 0x7FFFFFF)) + 24);
                      if (v93 - 8 * (unint64_t)*(unsigned int *)(v93 + 8) < v94
                                                                                  - 8
                                                                                  * (unint64_t)*(unsigned int *)(v94 + 8))
                      {
                        v83 = v82[1];
                        ++v82;
                        v91 = v92;
                      }
                    }
                    v95 = *(_QWORD *)(*(_QWORD *)(v83 - 32 * (*(_DWORD *)(v83 + 20) & 0x7FFFFFF)) + 24);
                    result = (uint64_t *)(v95 - 8 * *(unsigned int *)(v95 + 8));
                    v96 = *(_QWORD *)(*(_QWORD *)(v87 - 32 * (*(_DWORD *)(v87 + 20) & 0x7FFFFFF)) + 24);
                    v97 = v96 - 8 * *(unsigned int *)(v96 + 8);
                    v86 = v90;
                    v81 = v91;
                  }
                  while ((unint64_t)result >= v97);
                  *v90 = v87;
                }
              }
              v79 = v80 - 1;
            }
            while (v80);
            do
            {
              v98 = 0;
              v99 = *v8;
              v100 = v8;
              do
              {
                v101 = &v100[v98];
                v104 = v101[1];
                v102 = v101 + 1;
                v103 = v104;
                v105 = (2 * v98) | 1;
                v106 = 2 * v98 + 2;
                if (v106 < v10)
                {
                  v107 = *(_QWORD *)(*(_QWORD *)(v103 - 32 * (*(_DWORD *)(v103 + 20) & 0x7FFFFFF)) + 24);
                  result = (uint64_t *)(v107 - 8 * *(unsigned int *)(v107 + 8));
                  v108 = *(_QWORD *)(*(_QWORD *)(v102[1] - 32 * (*(_DWORD *)(v102[1] + 20) & 0x7FFFFFF)) + 24);
                  if ((unint64_t)result < v108 - 8 * (unint64_t)*(unsigned int *)(v108 + 8))
                  {
                    v103 = v102[1];
                    ++v102;
                    v105 = v106;
                  }
                }
                *v100 = v103;
                v100 = v102;
                v98 = v105;
              }
              while (v105 <= (uint64_t)((unint64_t)(v10 - 2) >> 1));
              if (v102 == --a2)
              {
                *v102 = v99;
              }
              else
              {
                *v102 = *a2;
                *a2 = v99;
                v109 = (char *)v102 - (char *)v8 + 8;
                if (v109 >= 9)
                {
                  v110 = (((unint64_t)v109 >> 3) - 2) >> 1;
                  v111 = &v8[v110];
                  v112 = *v111;
                  v113 = *v102;
                  v114 = *(_QWORD *)(*(_QWORD *)(*v111 - 32 * (*(_DWORD *)(*v111 + 20) & 0x7FFFFFF)) + 24);
                  v115 = *(_QWORD *)(*(_QWORD *)(*v102 - 32 * (*(_DWORD *)(*v102 + 20) & 0x7FFFFFF)) + 24);
                  if (v114 - 8 * (unint64_t)*(unsigned int *)(v114 + 8) < v115
                                                                                - 8
                                                                                * (unint64_t)*(unsigned int *)(v115 + 8))
                  {
                    do
                    {
                      v116 = v111;
                      *v102 = v112;
                      if (!v110)
                        break;
                      v110 = (v110 - 1) >> 1;
                      v111 = &v8[v110];
                      v112 = *v111;
                      v117 = *(_QWORD *)(*(_QWORD *)(*v111 - 32 * (*(_DWORD *)(*v111 + 20) & 0x7FFFFFF)) + 24);
                      v118 = v117 - 8 * *(unsigned int *)(v117 + 8);
                      v119 = *(_QWORD *)(*(_QWORD *)(v113 - 32 * (*(_DWORD *)(v113 + 20) & 0x7FFFFFF)) + 24);
                      v120 = v119 - 8 * *(unsigned int *)(v119 + 8);
                      v102 = v116;
                    }
                    while (v118 < v120);
                    *v116 = v113;
                  }
                }
              }
            }
            while (v10-- > 2);
          }
          return result;
        }
        v11 = (unint64_t)v10 >> 1;
        v12 = &v8[(unint64_t)v10 >> 1];
        if ((unint64_t)v9 < 0x401)
        {
          result = sub_1C545AE00(&v7[(unint64_t)v10 >> 1], v7, a2 - 1);
        }
        else
        {
          sub_1C545AE00(v7, &v7[(unint64_t)v10 >> 1], a2 - 1);
          sub_1C545AE00(v7 + 1, v12 - 1, a2 - 2);
          sub_1C545AE00(v7 + 2, &v7[v11 + 1], a2 - 3);
          result = sub_1C545AE00(v12 - 1, v12, &v7[v11 + 1]);
          v13 = *v7;
          *v7 = *v12;
          *v12 = v13;
        }
        --a3;
        v14 = *v7;
        if ((a4 & 1) == 0)
        {
          v17 = *(_QWORD *)(*(_QWORD *)(*(v7 - 1) - 32 * (*(_DWORD *)(*(v7 - 1) + 20) & 0x7FFFFFF)) + 24);
          v18 = v17 - 8 * *(unsigned int *)(v17 + 8);
          v15 = *(_QWORD *)(*(_QWORD *)(v14 - 32 * (*(_DWORD *)(v14 + 20) & 0x7FFFFFF)) + 24);
          v19 = *(unsigned int *)(v15 + 8);
          v20 = v15 - 8 * v19;
          if (v18 < v20)
          {
            v16 = -v19;
            goto LABEL_13;
          }
          v41 = *(_QWORD *)(*(_QWORD *)(*(a2 - 1) - 32 * (*(_DWORD *)(*(a2 - 1) + 20) & 0x7FFFFFF)) + 24);
          if (v20 >= v41 - 8 * (unint64_t)*(unsigned int *)(v41 + 8))
          {
            v44 = v7 + 1;
            do
            {
              v8 = v44;
              if (v44 >= a2)
                break;
              ++v44;
              v45 = *(_QWORD *)(*(_QWORD *)(*v8 - 32 * (*(_DWORD *)(*v8 + 20) & 0x7FFFFFF)) + 24);
            }
            while (v20 >= v45 - 8 * (unint64_t)*(unsigned int *)(v45 + 8));
          }
          else
          {
            v8 = v7;
            do
            {
              v42 = v8[1];
              ++v8;
              v43 = *(_QWORD *)(*(_QWORD *)(v42 - 32 * (*(_DWORD *)(v42 + 20) & 0x7FFFFFF)) + 24);
            }
            while (v20 >= v43 - 8 * (unint64_t)*(unsigned int *)(v43 + 8));
          }
          v46 = a2;
          if (v8 < a2)
          {
            v46 = a2;
            do
            {
              v47 = *--v46;
              v48 = *(_QWORD *)(*(_QWORD *)(v47 - 32 * (*(_DWORD *)(v47 + 20) & 0x7FFFFFF)) + 24);
            }
            while (v20 < v48 - 8 * (unint64_t)*(unsigned int *)(v48 + 8));
          }
          if (v8 < v46)
          {
            v49 = *v8;
            v50 = *v46;
            do
            {
              *v8 = v50;
              *v46 = v49;
              v51 = *(_QWORD *)(*(_QWORD *)(v14 - 32 * (*(_DWORD *)(v14 + 20) & 0x7FFFFFF)) + 24);
              v52 = v51 - 8 * *(unsigned int *)(v51 + 8);
              do
              {
                v53 = v8[1];
                ++v8;
                v49 = v53;
                v54 = *(_QWORD *)(*(_QWORD *)(v53 - 32 * (*(_DWORD *)(v53 + 20) & 0x7FFFFFF)) + 24);
              }
              while (v52 >= v54 - 8 * (unint64_t)*(unsigned int *)(v54 + 8));
              do
              {
                v55 = *--v46;
                v50 = v55;
                v56 = *(_QWORD *)(*(_QWORD *)(v55 - 32 * (*(_DWORD *)(v55 + 20) & 0x7FFFFFF)) + 24);
              }
              while (v52 < v56 - 8 * (unint64_t)*(unsigned int *)(v56 + 8));
            }
            while (v8 < v46);
          }
          v57 = v8 - 1;
          if (v8 - 1 != v7)
            *v7 = *v57;
          a4 = 0;
          *v57 = v14;
          continue;
        }
        v15 = *(_QWORD *)(*(_QWORD *)(v14 - 32 * (*(_DWORD *)(v14 + 20) & 0x7FFFFFF)) + 24);
        v16 = -(uint64_t)*(unsigned int *)(v15 + 8);
LABEL_13:
        v21 = 0;
        v22 = v15 + 8 * v16;
        do
        {
          v23 = v7[v21 + 1];
          v24 = *(_QWORD *)(*(_QWORD *)(v23 - 32 * (*(_DWORD *)(v23 + 20) & 0x7FFFFFF)) + 24);
          ++v21;
        }
        while (v24 - 8 * (unint64_t)*(unsigned int *)(v24 + 8) < v22);
        v25 = &v7[v21];
        v26 = a2;
        if (v21 == 1)
        {
          v26 = a2;
          do
          {
            if (v25 >= v26)
              break;
            v29 = *--v26;
            v30 = *(_QWORD *)(*(_QWORD *)(v29 - 32 * (*(_DWORD *)(v29 + 20) & 0x7FFFFFF)) + 24);
          }
          while (v30 - 8 * (unint64_t)*(unsigned int *)(v30 + 8) >= v22);
        }
        else
        {
          do
          {
            v27 = *--v26;
            v28 = *(_QWORD *)(*(_QWORD *)(v27 - 32 * (*(_DWORD *)(v27 + 20) & 0x7FFFFFF)) + 24);
          }
          while (v28 - 8 * (unint64_t)*(unsigned int *)(v28 + 8) >= v22);
        }
        if (v25 >= v26)
        {
          v8 = v25;
        }
        else
        {
          v31 = *v26;
          v8 = v25;
          v32 = v26;
          do
          {
            *v8 = v31;
            *v32 = v23;
            v33 = *(_QWORD *)(*(_QWORD *)(v14 - 32 * (*(_DWORD *)(v14 + 20) & 0x7FFFFFF)) + 24);
            v34 = v33 - 8 * *(unsigned int *)(v33 + 8);
            do
            {
              v35 = v8[1];
              ++v8;
              v23 = v35;
              v36 = *(_QWORD *)(*(_QWORD *)(v35 - 32 * (*(_DWORD *)(v35 + 20) & 0x7FFFFFF)) + 24);
            }
            while (v36 - 8 * (unint64_t)*(unsigned int *)(v36 + 8) < v34);
            do
            {
              v37 = *--v32;
              v31 = v37;
              v38 = *(_QWORD *)(*(_QWORD *)(v37 - 32 * (*(_DWORD *)(v37 + 20) & 0x7FFFFFF)) + 24);
            }
            while (v38 - 8 * (unint64_t)*(unsigned int *)(v38 + 8) >= v34);
          }
          while (v8 < v32);
        }
        v39 = v8 - 1;
        if (v8 - 1 != v7)
          *v7 = *v39;
        *v39 = v14;
        if (v25 < v26)
        {
LABEL_34:
          result = (uint64_t *)sub_1C545A210(v7, v8 - 1, a3, a4 & 1);
          a4 = 0;
          continue;
        }
        v40 = sub_1C545AF34(v7, v8 - 1);
        result = (uint64_t *)sub_1C545AF34(v8, a2);
        if (!(_DWORD)result)
        {
          if (v40)
            continue;
          goto LABEL_34;
        }
        a2 = v8 - 1;
        if (!v40)
          goto LABEL_2;
        return result;
    }
  }
}

uint64_t *sub_1C545AC80(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t *result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  result = sub_1C545B138(a1, a2, a3, a4);
  v11 = *a4;
  v12 = *(_QWORD *)(*(_QWORD *)(*a5 - 32 * (*(_DWORD *)(*a5 + 20) & 0x7FFFFFF)) + 24);
  v13 = *(_QWORD *)(*(_QWORD *)(*a4 - 32 * (*(_DWORD *)(*a4 + 20) & 0x7FFFFFF)) + 24);
  if (v12 - 8 * (unint64_t)*(unsigned int *)(v12 + 8) < v13 - 8 * (unint64_t)*(unsigned int *)(v13 + 8))
  {
    *a4 = *a5;
    *a5 = v11;
    v14 = *a3;
    v15 = *(_QWORD *)(*(_QWORD *)(*a4 - 32 * (*(_DWORD *)(*a4 + 20) & 0x7FFFFFF)) + 24);
    v16 = *(_QWORD *)(*(_QWORD *)(*a3 - 32 * (*(_DWORD *)(*a3 + 20) & 0x7FFFFFF)) + 24);
    if (v15 - 8 * (unint64_t)*(unsigned int *)(v15 + 8) < v16 - 8 * (unint64_t)*(unsigned int *)(v16 + 8))
    {
      *a3 = *a4;
      *a4 = v14;
      v17 = *a2;
      v18 = *(_QWORD *)(*(_QWORD *)(*a3 - 32 * (*(_DWORD *)(*a3 + 20) & 0x7FFFFFF)) + 24);
      v19 = *(_QWORD *)(*(_QWORD *)(*a2 - 32 * (*(_DWORD *)(*a2 + 20) & 0x7FFFFFF)) + 24);
      if (v18 - 8 * (unint64_t)*(unsigned int *)(v18 + 8) < v19
                                                                  - 8 * (unint64_t)*(unsigned int *)(v19 + 8))
      {
        *a2 = *a3;
        *a3 = v17;
        v20 = *a1;
        v21 = *(_QWORD *)(*(_QWORD *)(*a2 - 32 * (*(_DWORD *)(*a2 + 20) & 0x7FFFFFF)) + 24);
        v22 = *(_QWORD *)(*(_QWORD *)(*a1 - 32 * (*(_DWORD *)(*a1 + 20) & 0x7FFFFFF)) + 24);
        if (v21 - 8 * (unint64_t)*(unsigned int *)(v21 + 8) < v22
                                                                    - 8 * (unint64_t)*(unsigned int *)(v22 + 8))
        {
          *a1 = *a2;
          *a2 = v20;
        }
      }
    }
  }
  return result;
}

uint64_t *sub_1C545AE00(uint64_t *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v3 = *a2;
  v4 = *result;
  v5 = *(_QWORD *)(*(_QWORD *)(*a2 - 32 * (*(_DWORD *)(*a2 + 20) & 0x7FFFFFF)) + 24);
  v6 = v5 - 8 * *(unsigned int *)(v5 + 8);
  v7 = *(_QWORD *)(*(_QWORD *)(*result - 32 * (*(_DWORD *)(*result + 20) & 0x7FFFFFF)) + 24);
  v8 = v7 - 8 * *(unsigned int *)(v7 + 8);
  v9 = *a3;
  v10 = *(_QWORD *)(*(_QWORD *)(*a3 - 32 * (*(_DWORD *)(*a3 + 20) & 0x7FFFFFF)) + 24);
  v11 = v10 - 8 * *(unsigned int *)(v10 + 8);
  if (v6 >= v8)
  {
    if (v11 < v6)
    {
      *a2 = v9;
      *a3 = v3;
      v12 = *result;
      v13 = *(_QWORD *)(*(_QWORD *)(*a2 - 32 * (*(_DWORD *)(*a2 + 20) & 0x7FFFFFF)) + 24);
      v14 = *(_QWORD *)(*(_QWORD *)(*result - 32 * (*(_DWORD *)(*result + 20) & 0x7FFFFFF)) + 24);
      if (v13 - 8 * (unint64_t)*(unsigned int *)(v13 + 8) < v14
                                                                  - 8 * (unint64_t)*(unsigned int *)(v14 + 8))
      {
        *result = *a2;
        *a2 = v12;
      }
    }
  }
  else
  {
    if (v11 >= v6)
    {
      *result = v3;
      *a2 = v4;
      v15 = *(_QWORD *)(*(_QWORD *)(*a3 - 32 * (*(_DWORD *)(*a3 + 20) & 0x7FFFFFF)) + 24);
      v16 = *(_QWORD *)(*(_QWORD *)(v4 - 32 * (*(_DWORD *)(v4 + 20) & 0x7FFFFFF)) + 24);
      if (v15 - 8 * (unint64_t)*(unsigned int *)(v15 + 8) >= v16
                                                                   - 8 * (unint64_t)*(unsigned int *)(v16 + 8))
        return result;
      *a2 = *a3;
    }
    else
    {
      *result = v9;
    }
    *a3 = v4;
  }
  return result;
}

BOOL sub_1C545AF34(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;
  _BOOL8 result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t *v24;

  v4 = a2 - a1;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = *(a2 - 1);
      v7 = *a1;
      v8 = *(_QWORD *)(*(_QWORD *)(v6 - 32 * (*(_DWORD *)(v6 + 20) & 0x7FFFFFF)) + 24);
      v9 = *(_QWORD *)(*(_QWORD *)(*a1 - 32 * (*(_DWORD *)(*a1 + 20) & 0x7FFFFFF)) + 24);
      if (v8 - 8 * (unint64_t)*(unsigned int *)(v8 + 8) < v9 - 8 * (unint64_t)*(unsigned int *)(v9 + 8))
      {
        *a1 = v6;
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      sub_1C545AE00(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      sub_1C545B138(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      sub_1C545AC80(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      v10 = a1 + 2;
      sub_1C545AE00(a1, a1 + 1, a1 + 2);
      v11 = a1 + 3;
      if (a1 + 3 == a2)
        return 1;
      v12 = 0;
      v13 = 24;
      break;
  }
  while (1)
  {
    v14 = *v11;
    v15 = *v10;
    v16 = *(_QWORD *)(*(_QWORD *)(*v11 - 32 * (*(_DWORD *)(*v11 + 20) & 0x7FFFFFF)) + 24);
    v17 = *(_QWORD *)(*(_QWORD *)(*v10 - 32 * (*(_DWORD *)(*v10 + 20) & 0x7FFFFFF)) + 24);
    if (v16 - 8 * (unint64_t)*(unsigned int *)(v16 + 8) < v17 - 8 * (unint64_t)*(unsigned int *)(v17 + 8))
    {
      v18 = v13;
      while (1)
      {
        *(uint64_t *)((char *)a1 + v18) = v15;
        v19 = v18 - 8;
        if (v18 == 8)
          break;
        v15 = *(uint64_t *)((char *)a1 + v18 - 16);
        v20 = *(_QWORD *)(*(_QWORD *)(v14 - 32 * (*(_DWORD *)(v14 + 20) & 0x7FFFFFF)) + 24);
        v21 = v20 - 8 * *(unsigned int *)(v20 + 8);
        v22 = *(_QWORD *)(*(_QWORD *)(v15 - 32 * (*(_DWORD *)(v15 + 20) & 0x7FFFFFF)) + 24);
        v23 = v22 - 8 * *(unsigned int *)(v22 + 8);
        v18 = v19;
        if (v21 >= v23)
        {
          v24 = (uint64_t *)((char *)a1 + v19);
          goto LABEL_12;
        }
      }
      v24 = a1;
LABEL_12:
      *v24 = v14;
      if (++v12 == 8)
        return v11 + 1 == a2;
    }
    v10 = v11;
    v13 += 8;
    if (++v11 == a2)
      return 1;
  }
}

uint64_t *sub_1C545B138(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  result = sub_1C545AE00(a1, a2, a3);
  v9 = *a3;
  v10 = *(_QWORD *)(*(_QWORD *)(*a4 - 32 * (*(_DWORD *)(*a4 + 20) & 0x7FFFFFF)) + 24);
  v11 = *(_QWORD *)(*(_QWORD *)(*a3 - 32 * (*(_DWORD *)(*a3 + 20) & 0x7FFFFFF)) + 24);
  if (v10 - 8 * (unint64_t)*(unsigned int *)(v10 + 8) < v11 - 8 * (unint64_t)*(unsigned int *)(v11 + 8))
  {
    *a3 = *a4;
    *a4 = v9;
    v12 = *a2;
    v13 = *(_QWORD *)(*(_QWORD *)(*a3 - 32 * (*(_DWORD *)(*a3 + 20) & 0x7FFFFFF)) + 24);
    v14 = *(_QWORD *)(*(_QWORD *)(*a2 - 32 * (*(_DWORD *)(*a2 + 20) & 0x7FFFFFF)) + 24);
    if (v13 - 8 * (unint64_t)*(unsigned int *)(v13 + 8) < v14 - 8 * (unint64_t)*(unsigned int *)(v14 + 8))
    {
      *a2 = *a3;
      *a3 = v12;
      v15 = *a1;
      v16 = *(_QWORD *)(*(_QWORD *)(*a2 - 32 * (*(_DWORD *)(*a2 + 20) & 0x7FFFFFF)) + 24);
      v17 = *(_QWORD *)(*(_QWORD *)(*a1 - 32 * (*(_DWORD *)(*a1 + 20) & 0x7FFFFFF)) + 24);
      if (v16 - 8 * (unint64_t)*(unsigned int *)(v16 + 8) < v17
                                                                  - 8 * (unint64_t)*(unsigned int *)(v17 + 8))
      {
        *a1 = *a2;
        *a2 = v15;
      }
    }
  }
  return result;
}

void sub_1C545B25C(llvm::raw_ostream **a1, llvm::SmallPtrSetImplBase *a2, uint64_t a3, uint64_t a4)
{
  unsigned int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t i;
  uint64_t v14;
  unsigned int v15;
  BOOL v16;
  BOOL v17;
  char v18;
  llvm::GlobalValue *Section;
  uint64_t v20;
  llvm::Module *v21;
  const char *v22;
  BOOL v23;
  const char *v24;
  __int16 v25;

  v8 = *(unsigned __int8 *)(a4 + 16);
  if (v8 > 3)
    goto LABEL_2;
  v12 = *(_DWORD *)(a4 + 32);
  if ((v12 & 0xF) == 1)
    goto LABEL_38;
  if (!*(_BYTE *)(a4 + 16))
  {
    if ((v12 & 0x800000) != 0 || *(_QWORD *)(a4 + 72) != a4 + 72)
      return;
    goto LABEL_38;
  }
  if (v8 != 1)
  {
    if (v8 != 3 || (*(_DWORD *)(a4 + 20) & 0x7FFFFFF) != 0)
      return;
LABEL_38:
    v22 = "Alias must point to a definition";
    goto LABEL_39;
  }
  sub_1C4774094(a2, a4);
  if (!v18)
  {
    v22 = "Aliases cannot form a cycle";
LABEL_39:
    v24 = v22;
    v25 = 259;
    sub_1C6249A24((uint64_t)a1, (llvm::Twine *)&v24);
    if (*a1)
      sub_1C6249A88(a1, a3);
    return;
  }
  if (*(_BYTE *)(a4 + 16) == 3
    && (Section = llvm::GlobalValue::getSection((llvm::GlobalValue *)a4), v20 == 12)
    && (*(_QWORD *)Section == *(_QWORD *)"llvm.ptrauth"
      ? (v23 = *((unsigned int *)Section + 2) == (unint64_t)*(unsigned int *)"auth")
      : (v23 = 0),
        v23)
    || (*(_DWORD *)(a4 + 32) & 0xFu) - 5 >= 4 && ((1 << (*(_DWORD *)(a4 + 32) & 0xF)) & 0x614) != 0
    || (v21 = *(llvm::Module **)(a4 + 40)) != 0
    && llvm::Module::getSemanticInterposition(v21)
    && (*(_BYTE *)(a4 + 33) & 0x40) == 0)
  {
    v22 = "Alias cannot point to an interposable alias";
    goto LABEL_39;
  }
  v8 = *(unsigned __int8 *)(a4 + 16);
LABEL_2:
  if (v8 == 5)
    sub_1C5453144((uint64_t)a1, a4);
  v9 = *(_DWORD *)(a4 + 20);
  if ((v9 & 0x40000000) == 0)
  {
    v10 = v9 & 0x7FFFFFF;
    v11 = a4 - 32 * v10;
    if (!v10)
      return;
    goto LABEL_14;
  }
  v11 = *(_QWORD *)(a4 - 8);
  v10 = v9 & 0x7FFFFFF;
  if (v10)
  {
LABEL_14:
    for (i = 32 * v10; i; i -= 32)
    {
      v14 = *(_QWORD *)v11;
      v15 = *(unsigned __int8 *)(*(_QWORD *)v11 + 16);
      if (*(_QWORD *)v11)
        v16 = v15 == 1;
      else
        v16 = 0;
      if (v16)
      {
        v14 = *(_QWORD *)(v14 - 32);
      }
      else
      {
        if (v14)
          v17 = v15 > 0x14;
        else
          v17 = 1;
        if (v17)
          goto LABEL_27;
      }
      sub_1C545B25C(a1, a2, a3, v14);
LABEL_27:
      v11 += 32;
    }
  }
}

uint64_t sub_1C545B460(uint64_t a1, int a2, uint64_t a3, _QWORD *a4)
{
  int v4;
  unsigned int v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  int v9;
  uint64_t v10;
  BOOL v12;
  unsigned int v13;

  if (a2)
  {
    v4 = a2 - 1;
    v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    v6 = (_QWORD *)(a1 + 16 * v5);
    v7 = *v6;
    if (*v6 == a3)
    {
      v10 = 1;
    }
    else
    {
      v8 = 0;
      v9 = 1;
      while (v7 != -4096)
      {
        if (v8)
          v12 = 0;
        else
          v12 = v7 == -8192;
        if (v12)
          v8 = v6;
        v13 = v5 + v9++;
        v5 = v13 & v4;
        v6 = (_QWORD *)(a1 + 16 * (v13 & v4));
        v7 = *v6;
        v10 = 1;
        if (*v6 == a3)
          goto LABEL_7;
      }
      v10 = 0;
      if (v8)
        v6 = v8;
    }
  }
  else
  {
    v6 = 0;
    v10 = 0;
  }
LABEL_7:
  *a4 = v6;
  return v10;
}

_QWORD *sub_1C545B4F4(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unsigned int v8;
  _QWORD *result;
  uint64_t v10;
  uint64_t v11;

  v3 = *(unsigned int *)(a1 + 16);
  v4 = *(uint64_t **)a1;
  v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
    v8 = v7 + 1;
  else
    v8 = 64;
  *(_DWORD *)(a1 + 16) = v8;
  result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(_QWORD *)a1 = result;
  if (v4)
  {
    sub_1C624A314(a1, v4, &v4[2 * v3]);
    JUMPOUT(0x1CAA32FB4);
  }
  *(_QWORD *)(a1 + 8) = 0;
  v10 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v10)
  {
    v11 = 16 * v10;
    do
    {
      *result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1C545B5AC()
{
  uint64_t v0;
  unint64_t v2;
  unint64_t v4;
  _QWORD *v5;
  _QWORD v6[2];

  v0 = operator new();
  *(_QWORD *)(v0 + 8) = 0;
  *(_QWORD *)(v0 + 16) = &unk_1EF8F7100;
  *(_DWORD *)(v0 + 24) = 2;
  *(_QWORD *)v0 = &off_1E8168F88;
  *(_QWORD *)(v0 + 32) = 0;
  *(_BYTE *)(v0 + 40) = 1;
  if (!atomic_load(qword_1ED830BC0))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED830BC0, (void *(*)(void))sub_1C624602C, (void (*)(void *))sub_1C62460B0);
  v4 = qword_1ED830BC0[0];
  v2 = atomic_load(&qword_1ED8310E0);
  if (v2 != -1)
  {
    v6[0] = sub_1C5447A40;
    v6[1] = &v4;
    v5 = v6;
    std::__call_once(&qword_1ED8310E0, &v5, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return v0;
}

void sub_1C545B698(llvm::Pass *this)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E8168F88;
  v2 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v2)
  {
    v3 = sub_1C5443D80(v2);
    MEMORY[0x1CAA32FC0](v3, 0x10F2C406720EBC5);
  }
  llvm::Pass::~Pass(this);
}

void sub_1C545B6E8(llvm::Pass *this)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E8168F88;
  v2 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v2)
  {
    v3 = sub_1C5443D80(v2);
    MEMORY[0x1CAA32FC0](v3, 0x10F2C406720EBC5);
  }
  llvm::Pass::~Pass(this);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C545B74C(llvm *a1, _QWORD *a2)
{
  llvm *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v4 = llvm::dbgs(a1);
  v5 = operator new();
  sub_1C5441BDC(v5, (uint64_t)v4, 0, a2);
  v6 = *((_QWORD *)a1 + 4);
  *((_QWORD *)a1 + 4) = v5;
  if (v6)
  {
    v7 = sub_1C5443D80(v6);
    MEMORY[0x1CAA32FC0](v7, 0x10F2C406720EBC5);
  }
  return 0;
}

uint64_t sub_1C545B7D0(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  BOOL v7;

  v3 = a2 + 24;
  v4 = *(_QWORD *)(a2 + 32);
  if (v4 != a2 + 24)
  {
    v5 = 0;
    while (1)
    {
      v6 = v4 ? v4 - 56 : 0;
      if (!v4 || *(_BYTE *)(v6 + 16) != 3)
        break;
      if ((*(_DWORD *)(v6 + 20) & 0x7FFFFFF) == 0)
        goto LABEL_9;
LABEL_13:
      v4 = *(_QWORD *)(v4 + 8);
      if (v4 == v3)
        goto LABEL_16;
    }
    if (*(_BYTE *)(v6 + 16) || *(_QWORD *)(v6 + 72) != v6 + 72 || (*(_BYTE *)(v6 + 34) & 0x80) != 0)
      goto LABEL_13;
LABEL_9:
    v5 |= !sub_1C5441DC4(*(_QWORD *)(a1 + 32), (uint64_t ***)v6);
    goto LABEL_13;
  }
  LOBYTE(v5) = 0;
LABEL_16:
  v7 = sub_1C5443FC0(*(_QWORD *)(a1 + 32));
  if (*(_BYTE *)(a1 + 40) && (v5 & 1 | !v7 || *(_BYTE *)(*(_QWORD *)(a1 + 32) + 193)))
    llvm::report_fatal_error((llvm *)"Broken module found, compilation aborted!", (const char *)1);
  return 0;
}

void sub_1C545B8AC(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 160) = 1;
}

uint64_t sub_1C545B8B8(uint64_t a1, uint64_t ***a2)
{
  _BOOL8 v4;
  llvm::raw_ostream *v6;
  llvm::raw_ostream *v7;
  char *Name;
  size_t v9;
  llvm::raw_ostream *v10;

  v4 = sub_1C5441DC4(*(_QWORD *)(a1 + 32), a2);
  if (!v4 && *(_BYTE *)(a1 + 40))
  {
    v6 = (llvm::raw_ostream *)llvm::errs((llvm *)v4);
    v7 = sub_1C4816AD8(v6, "in function ");
    Name = llvm::Value::getName((llvm::Value *)a2);
    v10 = sub_1C6245B98(v7, Name, v9);
    sub_1C61ABDB8(v10, 10);
    llvm::report_fatal_error((llvm *)"Broken function found, compilation aborted!", (const char *)1);
  }
  return 0;
}

_QWORD *sub_1C545B93C(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unsigned int v8;
  _QWORD *result;
  uint64_t v10;
  uint64_t v11;

  v3 = *(unsigned int *)(a1 + 16);
  v4 = *(uint64_t **)a1;
  v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
    v8 = v7 + 1;
  else
    v8 = 64;
  *(_DWORD *)(a1 + 16) = v8;
  result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(_QWORD *)a1 = result;
  if (v4)
  {
    sub_1C545B9F4(a1, v4, &v4[2 * v3]);
    JUMPOUT(0x1CAA32FB4);
  }
  *(_QWORD *)(a1 + 8) = 0;
  v10 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v10)
  {
    v11 = 16 * v10;
    do
    {
      *result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1C545B9F4(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;

  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(unsigned int *)(result + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)result;
    v8 = 16 * v6;
    do
    {
      *v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v11 = 0;
      result = sub_1C504C9E8(*(_QWORD *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
      v10 = v11;
      *v11 = *a2;
      v10[1] = a2[1];
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 2;
  }
  return result;
}

_QWORD *sub_1C545BAA0(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unsigned int v8;
  _QWORD *result;
  uint64_t v10;
  uint64_t v11;

  v3 = *(unsigned int *)(a1 + 16);
  v4 = *(_QWORD *)a1;
  v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
    v8 = v7 + 1;
  else
    v8 = 64;
  *(_DWORD *)(a1 + 16) = v8;
  result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(_QWORD *)a1 = result;
  if (v4)
  {
    sub_1C545BB58(a1, v4, v4 + 16 * v3);
    JUMPOUT(0x1CAA32FB4);
  }
  *(_QWORD *)(a1 + 8) = 0;
  v10 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v10)
  {
    v11 = 16 * v10;
    do
    {
      *result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1C545BB58(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;

  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(unsigned int *)(result + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)result;
    v8 = 16 * v6;
    do
    {
      *v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    v9 = *(_QWORD *)a2;
    if ((*(_QWORD *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v11 = 0;
      result = sub_1C504C9E8(*(_QWORD *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
      v10 = v11;
      *v11 = *(_QWORD *)a2;
      *((_BYTE *)v10 + 8) = *(_BYTE *)(a2 + 8);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 16;
  }
  return result;
}

uint64_t sub_1C545BC04()
{
  char v1;
  int v2;
  __n128 v3;
  int *v4;

  v2 = 1;
  v1 = 0;
  v4 = (int *)&v1;
  v3.n128_u64[0] = (unint64_t)"Ensure that llvm.experimental.noalias.scope.decl for identical scopes are not dominating";
  v3.n128_u64[1] = 88;
  sub_1C4E5DE0C((llvm::cl::Option *)&unk_1ED804D50, "verify-noalias-scope-decl-dom", &v2, (_BYTE **)&v4, &v3);
  __cxa_atexit((void (*)(void *))sub_1C484246C, &unk_1ED804D50, &dword_1C475E000);
  LOBYTE(v2) = 0;
  v3.n128_u64[0] = (unint64_t)"Check that tail calls from swifttailcc functions to swifttailcc functions are marked musttail.";
  v3.n128_u64[1] = 94;
  v4 = &v2;
  sub_1C624A3C0((char **)&v4, (__int128 *)&v3);
  return __cxa_atexit((void (*)(void *))sub_1C484246C, qword_1ED804E10, &dword_1C475E000);
}

unint64_t llvm::coverage::CounterExpressionBuilder::simplify(uint64_t a1, uint64_t a2)
{
  unsigned int *v3;
  _DWORD *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unsigned int *v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unsigned int *v16;
  unsigned int v17;
  unint64_t v18;
  int v19;
  unint64_t v20;
  int v22;
  unint64_t v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  _QWORD v27[34];

  v27[32] = *MEMORY[0x1E0C80C00];
  v25 = v27;
  v26 = 0x2000000000;
  llvm::coverage::CounterExpressionBuilder::extractTerms(a1, a2, 1, (uint64_t)&v25);
  v3 = (unsigned int *)v25;
  if ((_DWORD)v26)
  {
    sub_1C546505C((uint64_t *)v25, (uint64_t *)v25 + v26, 126 - 2 * __clz(v26), 1);
    v3 = (unsigned int *)v25;
    v4 = v25;
    if ((_DWORD)v26 != 1)
    {
      v5 = (char *)v25 + 8;
      LODWORD(v6) = *(_DWORD *)v25;
      v7 = 8 * v26 - 8;
      v4 = v25;
      do
      {
        if (*(_DWORD *)v5 == (_DWORD)v6)
        {
          v4[1] += *((_DWORD *)v5 + 1);
        }
        else
        {
          v6 = *(_QWORD *)v5;
          *((_QWORD *)v4 + 1) = *(_QWORD *)v5;
          v4 += 2;
        }
        v5 += 8;
        v7 -= 8;
      }
      while (v7);
    }
    v8 = (unint64_t)((char *)v4 - (char *)v3 + 8) >> 3;
    LODWORD(v26) = v8;
    if ((_DWORD)v8)
    {
      v9 = 0;
      v10 = 0;
      v11 = &v3[2 * v8];
      do
      {
        v12 = v3[1];
        if (v12 >= 1)
        {
          v13 = *v3;
          v14 = v10;
          do
          {
            v10 = v13;
            LODWORD(v15) = 1;
            if (v9)
            {
              v22 = 1;
              v23 = v9 | (v14 << 32);
              v24 = (v13 << 32) | 1;
              v15 = llvm::coverage::CounterExpressionBuilder::get(a1, &v22);
              v10 = HIDWORD(v15);
            }
            v9 = v15;
            v14 = v10;
            --v12;
          }
          while (v12);
        }
        v3 += 2;
      }
      while (v3 != v11);
      v3 = (unsigned int *)v25;
      if ((_DWORD)v26)
      {
        v16 = (unsigned int *)((char *)v25 + 8 * v26);
        do
        {
          v17 = v3[1];
          if ((v17 & 0x80000000) != 0)
          {
            v18 = ((unint64_t)*v3 << 32) | 1;
            if ((signed int)-v17 > 1)
              v19 = -v17;
            else
              v19 = 1;
            do
            {
              v22 = 0;
              v23 = v9 | (v10 << 32);
              v24 = v18;
              v20 = llvm::coverage::CounterExpressionBuilder::get(a1, &v22);
              v9 = v20;
              v10 = HIDWORD(v20);
              --v19;
            }
            while (v19);
          }
          v3 += 2;
        }
        while (v3 != v16);
        v3 = (unsigned int *)v25;
      }
    }
    else
    {
      v10 = 0;
      v9 = 0;
    }
  }
  else
  {
    v10 = 0;
    v9 = 0;
  }
  if (v3 != (unsigned int *)v27)
    free(v3);
  return v9 | (v10 << 32);
}

uint64_t llvm::coverage::CounterMappingContext::getMaxCounterID(_QWORD *a1, unsigned int *a2)
{
  uint64_t result;
  unint64_t v4;
  uint64_t v5;
  unsigned int MaxCounterID;

  result = *a2;
  if ((_DWORD)result)
  {
    if ((_DWORD)result == 2)
    {
      v4 = a2[1];
      if (a1[1] <= v4)
      {
        return 0;
      }
      else
      {
        v5 = *a1 + 20 * v4;
        MaxCounterID = llvm::coverage::CounterMappingContext::getMaxCounterID(a1, v5 + 4);
        LODWORD(result) = llvm::coverage::CounterMappingContext::getMaxCounterID(a1, v5 + 12);
        if (MaxCounterID <= result)
          return result;
        else
          return MaxCounterID;
      }
    }
    else
    {
      return a2[1];
    }
  }
  return result;
}

double llvm::coverage::FunctionRecordIterator::skipOtherFiles(llvm::coverage::FunctionRecordIterator *this)
{
  uint64_t v2;
  uint64_t v3;
  size_t v4;
  const void *v5;
  uint64_t v6;
  char v7;
  int v8;
  uint64_t v9;
  const void *v10;
  double result;

  v2 = *(_QWORD *)this + 104 * *((_QWORD *)this + 1);
  v3 = *((_QWORD *)this + 2);
  if (v3 == v2)
  {
LABEL_12:
    *((_QWORD *)this + 4) = 0;
    result = 0.0;
    *(_OWORD *)this = 0u;
    *((_OWORD *)this + 1) = 0u;
  }
  else
  {
    v4 = *((_QWORD *)this + 4);
    if (v4)
    {
      v5 = (const void *)*((_QWORD *)this + 3);
      while (1)
      {
        v6 = *(_QWORD *)(v3 + 24);
        v7 = *(_BYTE *)(v6 + 23);
        v8 = v7;
        v9 = v7 & 0x7F;
        if (v8 < 0)
          v9 = *(_QWORD *)(v6 + 8);
        if (v4 == v9)
        {
          v10 = v8 >= 0 ? *(const void **)(v3 + 24) : *(const void **)v6;
          if (!memcmp(v5, v10, v4))
            break;
        }
        v3 += 104;
        *((_QWORD *)this + 2) = v3;
        if (v3 == v2)
          goto LABEL_12;
      }
    }
  }
  return result;
}

uint64_t llvm::coverage::CoverageMapping::getImpreciseRecordIndicesForFilename(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  unint64_t v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t *v8;
  uint64_t v9;
  int v10;
  unsigned int v11;

  v4 = sub_1C5E3DF4C(a2, (uint64_t)a2 + a3);
  v5 = *(_QWORD *)(a1 + 48);
  v6 = *(_DWORD *)(a1 + 64);
  if (v6)
  {
    v7 = (v6 - 1) & (37 * v4);
    v8 = (uint64_t *)(v5 + 24 * v7);
    v9 = *v8;
    if (v4 == *v8)
      goto LABEL_8;
    v10 = 1;
    while (v9 != -1)
    {
      v11 = v7 + v10++;
      v7 = v11 & (v6 - 1);
      v8 = (uint64_t *)(v5 + 24 * v7);
      v9 = *v8;
      if (v4 == *v8)
        goto LABEL_8;
    }
  }
  v8 = (uint64_t *)(v5 + 24 * v6);
LABEL_8:
  if (v8 == (uint64_t *)(v5 + 24 * v6))
    return 0;
  else
    return v8[1];
}

void llvm::coverage::CoverageMapping::loadFunctionRecord(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  char *v8;
  size_t v9;
  uint64_t v10;
  size_t v11;
  size_t v12;
  uint64_t v13;
  uint64_t v14;
  _BYTE *v15;
  uint64_t v16;
  uint64_t v17;
  size_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  size_t v23;
  const void *v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  __int128 *v28;
  uint64_t v29;
  char *v30;
  char *v31;
  int *v32;
  int *v33;
  char v34;
  char *v35;
  char v36;
  char *v37;
  char v38;
  int v39;
  int v40;
  int v41;
  int v42;
  uint64_t v43;
  char *v44;
  char *v45;
  __int128 v46;
  char *v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  char *v51;
  char *v52;
  char *v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  char *v57;
  unint64_t v58;
  unint64_t v59;
  int v60;
  int v61;
  char *v62;
  char *v63;
  char *v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  char *v68;
  uint64_t v69;
  _QWORD **v70;
  unsigned __int8 v71;
  unint64_t v72;
  unint64_t v73;
  _QWORD **v74;
  uint64_t v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  size_t v79;
  unint64_t v80;
  uint64_t v81;
  unint64_t v82;
  unint64_t v83;
  unint64_t v84;
  unint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  unint64_t v90;
  unint64_t v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  unint64_t v100;
  unint64_t v101;
  unint64_t v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  uint64_t v107;
  unint64_t v108;
  unint64_t v109;
  unint64_t v110;
  uint64_t v111;
  unint64_t v112;
  uint64_t v113;
  uint64_t v114;
  unsigned int v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  int v121;
  BOOL v122;
  int v123;
  int v124;
  unint64_t v125;
  unint64_t v126;
  uint64_t v127;
  uint64_t v128;
  unsigned int v129;
  unsigned int v130;
  unint64_t *v131;
  unint64_t v132;
  unint64_t *v133;
  int v134;
  unint64_t v135;
  unint64_t v136;
  unint64_t v137;
  __int128 v138;
  char *v139;
  uint64_t v140;
  unint64_t v141;
  unint64_t v142;
  unint64_t v143;
  uint64_t v144;
  char *v145;
  char *v146;
  char *v147;
  uint64_t v148;
  uint64_t v149;
  void *v150;
  void *v151;
  int v152;
  uint64_t *v153;
  size_t v154;
  const void *v155;
  __int128 *v156;
  _QWORD *v157;
  uint64_t v158;
  int v159;
  uint64_t v160;
  uint64_t v161;
  unint64_t v162;
  char v163;
  uint64_t v164;
  unint64_t v165;
  _DWORD *v166;
  _QWORD *v167;
  int v168;
  unsigned int v169;
  uint64_t v170;
  unsigned int v171;
  unsigned int *v172;
  uint64_t v173;
  unsigned int MaxCounterID;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  unint64_t v178;
  unint64_t v179;
  unint64_t v180;
  uint64_t v181;
  uint64_t v182;
  unint64_t v183;
  unint64_t v184;
  char *v185;
  char *v186;
  uint64_t v187;
  char *v188;
  __int128 v189;
  int64x2_t v190;
  unint64_t v191;
  uint64_t v192;
  char *v193;
  uint64_t v194;
  unint64_t v195;
  char *v196;
  char *v197;
  size_t v198;
  char *v199;
  int64_t v200;
  unint64_t v201;
  int64_t v202;
  BOOL v203;
  unint64_t v204;
  unint64_t *v205;
  int v206;
  BOOL v207;
  unsigned int v208;
  int v209;
  uint64_t v210;
  unint64_t v211;
  uint64_t v212;
  int v213;
  BOOL v214;
  int v215;
  uint64_t v216;
  int v217;
  unsigned int v218;
  unint64_t v219;
  unint64_t *v220;
  int v221;
  BOOL v222;
  unsigned int v223;
  int v224;
  uint64_t v225;
  unint64_t v226;
  uint64_t v227;
  int v228;
  unsigned int v229;
  unint64_t v230;
  int v231;
  BOOL v232;
  int v233;
  int v234;
  BOOL v235;
  unsigned int v236;
  unint64_t v237;
  uint64_t v238;
  __int128 *v239;
  uint64_t v240;
  __int128 *v241;
  int v242;
  char v243;
  size_t v244;
  uint64_t *v245;
  uint64_t v246;
  char *__src;
  char v249;
  char v250;
  unint64_t v251;
  char *v252;
  char *v253;
  uint64_t v254;
  int *v255;
  uint64_t v256;
  _BYTE __dst[24];
  __int128 v258;
  char *v259;
  void *v260[2];
  void *__p[4];
  uint64_t v262;
  _QWORD *v263;
  void *v264;
  void *v265;
  char *v266;
  __int128 v267;
  void *v268;
  int64_t v269;
  char *v270;
  char *v271;
  _OWORD v272[2];
  char *v273;
  char v274;
  __int128 v275;
  unint64_t v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282[3];

  v282[0] = *MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)(a2 + 8))
  {
    v10 = operator new();
    *(_QWORD *)v10 = &off_1E8169028;
    *(_DWORD *)(v10 + 8) = 5;
    *a4 = v10;
    return;
  }
  v6 = a2;
  if (*(_QWORD *)(a2 + 32))
  {
    v7 = *(_QWORD *)(a2 + 24);
    v8 = *(char **)v7;
    v9 = *(_QWORD *)(v7 + 8);
  }
  else
  {
    v8 = "<unknown>";
    v9 = 9;
  }
  __src = llvm::getFuncNameWithoutPrefix(*(char **)a2, *(_QWORD *)(a2 + 8), v8, v9);
  v12 = v11;
  v267 = *(_OWORD *)(v6 + 40);
  v268 = 0;
  v269 = 0;
  v264 = 0;
  v265 = 0;
  v266 = 0;
  llvm::IndexedInstrProfReader::getFunctionCounts(a3, *(_QWORD *)(v6 + 16), (char **)&v264, (uint64_t *)&v273);
  v246 = v6;
  if (!v273)
    goto LABEL_7;
  v263 = v273;
  v273 = 0;
  v152 = sub_1C624ABD8(&v263);
  if (v263)
    (*(void (**)(_QWORD *))(*v263 + 8))(v263);
  if (v152 != 13)
  {
    if (v152 != 15)
    {
      v175 = operator new();
      WORD4(v258) = 257;
      *(_QWORD *)v175 = off_1E8192D50;
      *(_DWORD *)(v175 + 8) = v152;
      llvm::Twine::str((llvm::Twine *)__dst, (_QWORD *)(v175 + 16));
      goto LABEL_254;
    }
    v153 = a4;
    v154 = *(_QWORD *)(v6 + 8);
    if (v154 > 0x7FFFFFFFFFFFFFF7)
      goto LABEL_295;
    v155 = *(const void **)v6;
    if (v154 >= 0x17)
    {
      v176 = (v154 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v154 | 7) != 0x17)
        v176 = v154 | 7;
      v177 = v176 + 1;
      v156 = (__int128 *)operator new(v176 + 1);
      *((_QWORD *)&v275 + 1) = v154;
      v276 = v177 | 0x8000000000000000;
      *(_QWORD *)&v275 = v156;
      v157 = (_QWORD *)a1;
    }
    else
    {
      HIBYTE(v276) = v154;
      v156 = &v275;
      v157 = (_QWORD *)a1;
      if (!v154)
        goto LABEL_216;
    }
    memmove(v156, v155, v154);
LABEL_216:
    *((_BYTE *)v156 + v154) = 0;
    v178 = v157[11];
    v179 = v157[10];
    if (v179 >= v178)
    {
      v181 = v157[9];
      v182 = (uint64_t)(v179 - v181) >> 5;
      v183 = v182 + 1;
      if ((unint64_t)(v182 + 1) >> 59)
        goto LABEL_295;
      if ((uint64_t)(v178 - v181) >> 4 > v183)
        v183 = (uint64_t)(v178 - v181) >> 4;
      if (v178 - v181 >= 0x7FFFFFFFFFFFFFE0)
        v184 = 0x7FFFFFFFFFFFFFFLL;
      else
        v184 = v183;
      *((_QWORD *)&v258 + 1) = v157 + 11;
      if (v184 >> 59)
        goto LABEL_296;
      v185 = (char *)operator new(32 * v184);
      v186 = &v185[32 * v182];
      *(_OWORD *)v186 = v275;
      v187 = *(_QWORD *)(v246 + 16);
      *((_QWORD *)v186 + 2) = v276;
      *((_QWORD *)v186 + 3) = v187;
      if (v179 == v181)
      {
        v190 = vdupq_n_s64(v179);
        v188 = &v185[32 * v182];
      }
      else
      {
        v188 = &v185[32 * v182];
        do
        {
          v189 = *(_OWORD *)(v179 - 32);
          *((_QWORD *)v188 - 2) = *(_QWORD *)(v179 - 16);
          *((_OWORD *)v188 - 2) = v189;
          *(_QWORD *)(v179 - 24) = 0;
          *(_QWORD *)(v179 - 16) = 0;
          *(_QWORD *)(v179 - 32) = 0;
          *((_QWORD *)v188 - 1) = *(_QWORD *)(v179 - 8);
          v188 -= 32;
          v179 -= 32;
        }
        while (v179 != v181);
        v190 = *(int64x2_t *)(v157 + 9);
        v178 = v157[11];
      }
      v180 = (unint64_t)(v186 + 32);
      v157[9] = v188;
      v157[10] = v186 + 32;
      *(int64x2_t *)&__dst[8] = v190;
      v157[11] = &v185[32 * v184];
      *(_QWORD *)&v258 = v178;
      *(_QWORD *)__dst = v190.i64[0];
      sub_1C5465AA0((uint64_t)__dst);
    }
    else
    {
      *(_OWORD *)v179 = v275;
      *(_QWORD *)(v179 + 16) = v276;
      *(_QWORD *)(v179 + 24) = *(_QWORD *)(v246 + 16);
      v180 = v179 + 32;
    }
    a4 = v153;
    v175 = 0;
    v157[10] = v180;
LABEL_254:
    *a4 = v175;
    if (v273)
      (*(void (**)(char *))(*(_QWORD *)v273 + 8))(v273);
    goto LABEL_143;
  }
  v170 = *(_QWORD *)(v6 + 64);
  if (v170)
  {
    v171 = 0;
    v172 = *(unsigned int **)(v6 + 56);
    v173 = 44 * v170;
    do
    {
      MaxCounterID = llvm::coverage::CounterMappingContext::getMaxCounterID(&v267, v172);
      if (v171 <= MaxCounterID)
        v171 = MaxCounterID;
      v172 += 11;
      v173 -= 44;
    }
    while (v173);
  }
  else
  {
    v171 = 0;
  }
  v191 = v171 + 1;
  v192 = (uint64_t)v266;
  v193 = (char *)v264;
  if (v191 <= (v266 - (_BYTE *)v264) >> 3)
  {
    v198 = v12;
    v199 = (char *)v265;
    v200 = (_BYTE *)v265 - (_BYTE *)v264;
    v201 = ((_BYTE *)v265 - (_BYTE *)v264) >> 3;
    if (v201 >= v191)
      v202 = v191;
    else
      v202 = ((_BYTE *)v265 - (_BYTE *)v264) >> 3;
    if (v202)
      bzero(v264, 8 * v202);
    v203 = v191 >= v201;
    v204 = v191 - v201;
    if (v204 != 0 && v203)
    {
      bzero(v199, 8 * v191 - (v200 & 0xFFFFFFFFFFFFFFF8));
      v197 = &v199[8 * v204];
    }
    else
    {
      v197 = &v193[8 * v191];
    }
    v12 = v198;
  }
  else
  {
    if (v264)
    {
      v265 = v264;
      operator delete(v264);
      v192 = 0;
      v264 = 0;
      v265 = 0;
      v266 = 0;
    }
    v194 = v192 >> 2;
    if (v192 >> 2 <= v191)
      v194 = v191;
    if ((unint64_t)v192 >= 0x7FFFFFFFFFFFFFF8)
      v195 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v195 = v194;
    if (v195 >> 61)
      goto LABEL_295;
    v196 = (char *)operator new(8 * v195);
    v264 = v196;
    v266 = &v196[8 * v195];
    bzero(v196, 8 * v191);
    v197 = &v196[8 * v191];
  }
  v265 = v197;
  if (v273)
    (*(void (**)(char *))(*(_QWORD *)v273 + 8))(v273);
LABEL_7:
  v268 = v264;
  v269 = ((_BYTE *)v265 - (_BYTE *)v264) >> 3;
  if (*(_QWORD *)(v6 + 64) != 1 || **(_DWORD **)(v6 + 56) || !*(_QWORD *)v264)
  {
    if (v12 > 0x7FFFFFFFFFFFFFF7)
      goto LABEL_295;
    v13 = *(_QWORD *)(v6 + 24);
    v14 = *(_QWORD *)(v6 + 32);
    if (v12 >= 0x17)
    {
      v16 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v12 | 7) != 0x17)
        v16 = v12 | 7;
      v17 = v16 + 1;
      v15 = operator new(v16 + 1);
      *(_QWORD *)&__dst[8] = v12;
      *(_QWORD *)&__dst[16] = v17 | 0x8000000000000000;
      *(_QWORD *)__dst = v15;
    }
    else
    {
      __dst[23] = v12;
      v15 = __dst;
      if (!v12)
      {
LABEL_17:
        v15[v12] = 0;
        v258 = 0uLL;
        v259 = 0;
        if (16 * v14)
        {
          if (16 * v14 < 0)
            goto LABEL_295;
          v18 = v12;
          v19 = (16 * v14) >> 4;
          v20 = 3 * v19;
          v21 = operator new(24 * v19);
          *(_QWORD *)&v258 = v21;
          v259 = (char *)&v21[v20];
          if (v14)
          {
            v22 = v13 + 16 * v14;
            v12 = v18;
            while (1)
            {
              v23 = *(_QWORD *)(v13 + 8);
              if (v23 > 0x7FFFFFFFFFFFFFF7)
                goto LABEL_295;
              v24 = *(const void **)v13;
              if (v23 >= 0x17)
              {
                v26 = (v23 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v23 | 7) != 0x17)
                  v26 = v23 | 7;
                v27 = v26 + 1;
                v25 = operator new(v26 + 1);
                v21[1] = v23;
                v21[2] = v27 | 0x8000000000000000;
                *v21 = v25;
              }
              else
              {
                *((_BYTE *)v21 + 23) = v23;
                v25 = v21;
                if (!v23)
                  goto LABEL_29;
              }
              memmove(v25, v24, v23);
LABEL_29:
              *((_BYTE *)v25 + v23) = 0;
              v21 += 3;
              v13 += 16;
              if (v13 == v22)
                goto LABEL_34;
            }
          }
          v12 = v18;
LABEL_34:
          *((_QWORD *)&v258 + 1) = v21;
        }
        v244 = v12;
        v245 = a4;
        v28 = &v258;
        v262 = 0;
        memset(__p, 0, sizeof(__p));
        *(_OWORD *)v260 = 0u;
        v29 = *(_QWORD *)(v6 + 64);
        if (v29)
        {
          v30 = 0;
          v31 = 0;
          v32 = *(int **)(v6 + 56);
          v33 = &v32[11 * v29];
          do
          {
            llvm::coverage::CounterMappingContext::evaluate(&v267, v32, (uint64_t)&v275);
            v34 = BYTE8(v275);
            if ((BYTE8(v275) & 1) != 0)
            {
              v35 = (char *)v275;
              *(_QWORD *)&v275 = 0;
              if (v35)
              {
                v271 = v35;
                sub_1C4D62BD4(&v271, &v273);
                if (v271)
                  (*(void (**)(char *))(*(_QWORD *)v271 + 8))(v271);
                goto LABEL_136;
              }
            }
            llvm::coverage::CounterMappingContext::evaluate(&v267, v32 + 2, (uint64_t)&v273);
            v36 = v274;
            if ((v274 & 1) != 0)
            {
              if (v273)
              {
                v270 = v273;
                sub_1C4D62BD4(&v270, &v271);
                if (v270)
                  (*(void (**)(char *))(*(_QWORD *)v270 + 8))(v270);
                v38 = 0;
                *v245 = 0;
                goto LABEL_90;
              }
              v255 = v33;
              v37 = 0;
            }
            else
            {
              v255 = v33;
              v37 = v273;
            }
            v40 = *v32;
            v39 = v32[1];
            v41 = v32[2];
            v272[0] = *(_OWORD *)(v32 + 3);
            *(_OWORD *)((char *)v272 + 12) = *(_OWORD *)(v32 + 6);
            v42 = v32[10];
            v43 = v275;
            if (v42 == 4)
            {
              v44 = (char *)__p[2];
              if (__p[2] >= __p[3])
              {
                v239 = v28;
                v47 = (char *)__p[1];
                v48 = 0x8E38E38E38E38E39 * (((char *)__p[2] - (char *)__p[1]) >> 3);
                v49 = v48 + 1;
                if (v48 + 1 > 0x38E38E38E38E38ELL)
                  goto LABEL_295;
                v242 = v41;
                v252 = v37;
                v249 = v274;
                if (0x1C71C71C71C71C72 * (((char *)__p[3] - (char *)__p[1]) >> 3) > v49)
                  v49 = 0x1C71C71C71C71C72 * (((char *)__p[3] - (char *)__p[1]) >> 3);
                if (0x8E38E38E38E38E39 * (((char *)__p[3] - (char *)__p[1]) >> 3) >= 0x1C71C71C71C71C7)
                  v50 = 0x38E38E38E38E38ELL;
                else
                  v50 = v49;
                if (v50 > 0x38E38E38E38E38ELL)
                  goto LABEL_296;
                v238 = 9 * v50;
                v51 = (char *)operator new(72 * v50);
                v52 = &v51[72 * v48];
                *(_DWORD *)v52 = v40;
                *((_DWORD *)v52 + 1) = v39;
                v41 = v242;
                *((_DWORD *)v52 + 2) = v242;
                *(_OWORD *)(v52 + 12) = v272[0];
                *(_OWORD *)(v52 + 24) = *(_OWORD *)((char *)v272 + 12);
                *((_DWORD *)v52 + 10) = 4;
                v37 = v252;
                *((_QWORD *)v52 + 6) = v43;
                *((_QWORD *)v52 + 7) = v252;
                v52[64] = 0;
                if (v44 == v47)
                {
                  v57 = &v51[72 * v48];
                  v33 = v255;
                }
                else
                {
                  v53 = &v51[72 * v48];
                  v33 = v255;
                  do
                  {
                    *(_OWORD *)(v53 - 72) = *(_OWORD *)(v44 - 72);
                    v54 = *(_OWORD *)(v44 - 56);
                    v55 = *(_OWORD *)(v44 - 40);
                    v56 = *(_OWORD *)(v44 - 24);
                    v57 = v53 - 72;
                    *(v53 - 8) = *(v44 - 8);
                    *(_OWORD *)(v53 - 24) = v56;
                    *(_OWORD *)(v53 - 40) = v55;
                    *(_OWORD *)(v53 - 56) = v54;
                    v44 -= 72;
                    v53 -= 72;
                  }
                  while (v44 != v47);
                }
                v45 = v52 + 72;
                __p[1] = v57;
                __p[3] = &v51[8 * v238];
                if (v47)
                {
                  operator delete(v47);
                  v41 = v242;
                  v37 = v252;
                }
                v28 = v239;
                v36 = v249;
              }
              else
              {
                *(_DWORD *)__p[2] = v40;
                *((_DWORD *)v44 + 1) = v39;
                *((_DWORD *)v44 + 2) = v41;
                *(_OWORD *)(v44 + 12) = v272[0];
                *(_OWORD *)(v44 + 24) = *(_OWORD *)((char *)v272 + 12);
                *((_DWORD *)v44 + 10) = 4;
                *((_QWORD *)v44 + 6) = v43;
                *((_QWORD *)v44 + 7) = v37;
                v45 = v44 + 72;
                v44[64] = 0;
                v33 = v255;
              }
              __p[2] = v45;
              if (!(v40 | v41))
                *(v45 - 8) = 1;
              v6 = v246;
            }
            else
            {
              if (v31 == v30)
                v262 = v275;
              if (v30 >= __p[0])
              {
                v243 = v34;
                v58 = 0x8E38E38E38E38E39 * ((v30 - v31) >> 3) + 1;
                if (v58 > 0x38E38E38E38E38ELL)
                  goto LABEL_295;
                v253 = v37;
                v250 = v274;
                if (0x1C71C71C71C71C72 * (((char *)__p[0] - (char *)v31) >> 3) > v58)
                  v58 = 0x1C71C71C71C71C72 * (((char *)__p[0] - (char *)v31) >> 3);
                if (0x8E38E38E38E38E39 * (((char *)__p[0] - (char *)v31) >> 3) >= 0x1C71C71C71C71C7)
                  v59 = 0x38E38E38E38E38ELL;
                else
                  v59 = v58;
                if (v59 > 0x38E38E38E38E38ELL)
                  goto LABEL_296;
                v60 = v40;
                v61 = v41;
                v240 = 9 * v59;
                v62 = (char *)operator new(72 * v59);
                v63 = &v62[8 * ((v30 - v31) >> 3)];
                *(_DWORD *)v63 = v60;
                *((_DWORD *)v63 + 1) = v39;
                *((_DWORD *)v63 + 2) = v61;
                *(_OWORD *)(v63 + 12) = v272[0];
                *(_OWORD *)(v63 + 24) = *(_OWORD *)((char *)v272 + 12);
                *((_DWORD *)v63 + 10) = v42;
                v37 = v253;
                *((_QWORD *)v63 + 6) = v43;
                *((_QWORD *)v63 + 7) = v253;
                v63[64] = 0;
                if (v31 == v30)
                {
                  v68 = &v62[8 * ((v30 - v31) >> 3)];
                  v6 = v246;
                  v33 = v255;
                  v34 = v243;
                }
                else
                {
                  v64 = &v62[8 * ((v30 - v31) >> 3)];
                  v6 = v246;
                  v33 = v255;
                  v34 = v243;
                  do
                  {
                    *(_OWORD *)(v64 - 72) = *(_OWORD *)(v30 - 72);
                    v65 = *(_OWORD *)(v30 - 56);
                    v66 = *(_OWORD *)(v30 - 40);
                    v67 = *(_OWORD *)(v30 - 24);
                    v68 = v64 - 72;
                    *(v64 - 8) = *(v30 - 8);
                    *(_OWORD *)(v64 - 24) = v67;
                    *(_OWORD *)(v64 - 40) = v66;
                    *(_OWORD *)(v64 - 56) = v65;
                    v30 -= 72;
                    v64 -= 72;
                  }
                  while (v30 != v31);
                }
                v30 = v63 + 72;
                v260[0] = v68;
                v260[1] = v63 + 72;
                __p[0] = &v62[8 * v240];
                if (v31)
                {
                  operator delete(v31);
                  v37 = v253;
                }
                v31 = v68;
                v36 = v250;
              }
              else
              {
                *(_DWORD *)v30 = v40;
                *((_DWORD *)v30 + 1) = v39;
                *((_DWORD *)v30 + 2) = v41;
                v46 = v272[0];
                *(_OWORD *)(v30 + 24) = *(_OWORD *)((char *)v272 + 12);
                *(_OWORD *)(v30 + 12) = v46;
                *((_DWORD *)v30 + 10) = v42;
                *((_QWORD *)v30 + 6) = v43;
                *((_QWORD *)v30 + 7) = v37;
                v30[64] = 0;
                v30 += 72;
                v6 = v246;
                v33 = v255;
              }
              v260[1] = v30;
            }
            v38 = 1;
            if ((v36 & 1) != 0 && v37)
              (*(void (**)(char *))(*(_QWORD *)v37 + 8))(v37);
LABEL_90:
            if ((v34 & 1) != 0 && (_QWORD)v275)
              (*(void (**)(_QWORD))(*(_QWORD *)v275 + 8))(v275);
            if ((v38 & 1) == 0)
              goto LABEL_137;
            v32 += 11;
          }
          while (v32 != v33);
        }
        v70 = *(_QWORD ***)(v6 + 24);
        v69 = *(_QWORD *)(v6 + 32);
        v71 = atomic_load((unsigned __int8 *)&qword_1ED7EAC88);
        if ((v71 & 1) == 0 && __cxa_guard_acquire(&qword_1ED7EAC88))
        {
          v237 = llvm::hashing::detail::fixed_seed_override;
          if (!llvm::hashing::detail::fixed_seed_override)
            v237 = 0xFF51AFD7ED558CCDLL;
          qword_1ED7EAC80 = v237;
          __cxa_guard_release(&qword_1ED7EAC88);
        }
        v72 = qword_1ED7EAC80;
        if (v69)
        {
          v73 = 0;
          v74 = &v70[2 * v69];
          v75 = 16 * v69;
          while (1)
          {
            v76 = sub_1C5E3DF4C(*v70, (uint64_t)v70[1] + (_QWORD)*v70);
            if (v73 > 0x38)
              break;
            v77 = v73 + 8;
            *(_QWORD *)((char *)&v275 + v73) = v76;
            v70 += 2;
            v73 += 8;
            v75 -= 16;
            if (!v75)
              goto LABEL_104;
          }
          v241 = v28;
          v80 = 0x9DDFEA08EB382D69
              * ((0x9DDFEA08EB382D69 * (v72 ^ 0xB492B66FBE98F273)) ^ ((0x9DDFEA08EB382D69
                                                                         * (v72 ^ 0xB492B66FBE98F273)) >> 47) ^ 0xB492B66FBE98F273);
          v81 = __ROR8__(v72 ^ 0xB492B66FBE98F273, 49);
          v82 = v72 ^ (v72 >> 47);
          v83 = v72 ^ (((0x9DDFEA08EB382D69 * (v82 ^ (0xB492B66FBE98F273 * v72))) ^ v72) >> 47) ^ (0x9DDFEA08EB382D69 * (v82 ^ (0xB492B66FBE98F273 * v72)));
          v84 = v81 + v72 + *((_QWORD *)&v275 + 1);
          v85 = v279 + v81 - 0x4B6D499041670D8DLL * __ROR8__(v280 + v72 - 0x4B6D499041670D8DLL * v72, 42);
          v86 = v275 - 0x6D8ED9027DD26057 * v72;
          v87 = v82 + v86;
          v88 = v86 + *((_QWORD *)&v275 + 1) + v276;
          v89 = __ROR8__(v88, 44) + v86;
          v90 = 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * v83) ^ ((0x9DDFEA08EB382D69 * v83) >> 47));
          v91 = (0xB492B66FBE98F273 * __ROR8__(v84, 37)) ^ v90;
          v92 = v89 + __ROR8__(v91 + v87 + v277, 21);
          v93 = __ROR8__(v82 - 0x622015F714C7D297 * (v80 ^ (v80 >> 47)), 33);
          v94 = 0xB492B66FBE98F273 * v93;
          v95 = v88 + v277;
          v96 = v90 + v278 - 0x4B6D499041670D8DLL * v93;
          v97 = v279 + v280 + v96;
          v98 = __ROR8__(v97, 44) + v96 + __ROR8__(v85 + v276 + v281 + v96, 21);
          v99 = v97 + v281;
          v100 = 64;
          if (v75)
          {
            v101 = v91;
            do
            {
              v251 = v101;
              v254 = v98;
              v256 = v92;
              v102 = 0;
              do
              {
                v103 = sub_1C5E3DF4C(*v70, (uint64_t)v70[1] + (_QWORD)*v70);
                if (v102 > 0x38)
                {
                  v104 = 64;
                  goto LABEL_114;
                }
                v104 = v102 + 8;
                *(_QWORD *)((char *)&v275 + v102) = v103;
                v70 += 2;
                v102 += 8;
              }
              while (v70 != v74);
              if ((v104 & 0x7FFFFFFFFFFFFFB8) != 0)
                sub_1C4E37E60(&v275, (_BYTE *)&v275 + v104, v282);
              v70 = v74;
LABEL_114:
              v105 = v85 + v94 + v95 + *((_QWORD *)&v275 + 1);
              v85 = v279 + v95 - 0x4B6D499041670D8DLL * __ROR8__(v256 + v85 + v280, 42);
              v106 = v275 - 0x4B6D499041670D8DLL * v256;
              v107 = v106 + *((_QWORD *)&v275 + 1) + v276;
              v91 = (0xB492B66FBE98F273 * __ROR8__(v105, 37)) ^ v254;
              v92 = __ROR8__(v107, 44) + v106 + __ROR8__(v91 + v99 + v106 + v277, 21);
              v94 = 0xB492B66FBE98F273 * __ROR8__(v99 + v251, 33);
              v95 = v107 + v277;
              v108 = v94 + v254 + v278;
              v109 = v279 + v280 + v108;
              v98 = __ROR8__(v109, 44) + v108 + __ROR8__(v85 + v276 + v108 + v281, 21);
              v99 = v109 + v281;
              v100 += v104;
              v101 = v91;
            }
            while (v70 != v74);
          }
          v110 = 0x9DDFEA08EB382D69
               * (v99 ^ ((0x9DDFEA08EB382D69 * (v95 ^ v99)) >> 47) ^ (0x9DDFEA08EB382D69 * (v95 ^ v99)));
          v111 = v91 - 0x4B6D499041670D8DLL * (v85 ^ (v85 >> 47)) - 0x622015F714C7D297 * (v110 ^ (v110 >> 47));
          v112 = 0x9DDFEA08EB382D69
               * (v98 ^ ((0x9DDFEA08EB382D69 * (v92 ^ v98)) >> 47) ^ (0x9DDFEA08EB382D69 * (v92 ^ v98)));
          v113 = v94 - 0x4B6D499041670D8DLL * (v100 ^ (v100 >> 47)) - 0x622015F714C7D297 * (v112 ^ (v112 >> 47));
          v78 = 0x9DDFEA08EB382D69
              * ((0x9DDFEA08EB382D69
                * (v113 ^ ((0x9DDFEA08EB382D69 * (v111 ^ v113)) >> 47) ^ (0x9DDFEA08EB382D69 * (v111 ^ v113)))) ^ ((0x9DDFEA08EB382D69 * (v113 ^ ((0x9DDFEA08EB382D69 * (v111 ^ v113)) >> 47) ^ (0x9DDFEA08EB382D69 * (v111 ^ v113)))) >> 47));
          v28 = v241;
          v79 = v244;
        }
        else
        {
          v77 = 0;
LABEL_104:
          v78 = sub_1C49CE808(&v275, v77, v72);
          v79 = v244;
        }
        v114 = a1;
        v115 = *(_DWORD *)(a1 + 16);
        v116 = v246;
        if (v115)
        {
          v117 = (v115 - 1) & (37 * (_DWORD)v78);
          v118 = *(_QWORD *)a1 + 32 * v117;
          v119 = *(_QWORD *)v118;
          if (v78 == *(_QWORD *)v118)
            goto LABEL_134;
          v120 = 0;
          v121 = 1;
          while (v119 != -1)
          {
            if (v120)
              v122 = 0;
            else
              v122 = v119 == -2;
            if (v122)
              v120 = v118;
            v123 = v117 + v121++;
            v117 = v123 & (v115 - 1);
            v118 = *(_QWORD *)a1 + 32 * v117;
            v119 = *(_QWORD *)v118;
            if (v78 == *(_QWORD *)v118)
              goto LABEL_134;
          }
          if (v120)
            v118 = v120;
        }
        else
        {
          v118 = 0;
        }
        v124 = *(_DWORD *)(a1 + 8);
        if (4 * v124 + 4 >= 3 * v115)
        {
          sub_1C5465B00((uint64_t *)a1, 2 * v115);
          v209 = *(_DWORD *)(a1 + 16) - 1;
          v210 = v209 & (37 * v78);
          v118 = *(_QWORD *)a1 + 32 * v210;
          v211 = *(_QWORD *)v118;
          if (v78 == *(_QWORD *)v118)
            goto LABEL_292;
          v212 = 0;
          v213 = 1;
          while (v211 != -1)
          {
            if (v212)
              v214 = 0;
            else
              v214 = v211 == -2;
            if (v214)
              v212 = v118;
            v215 = v210 + v213++;
            v210 = v215 & v209;
            v118 = *(_QWORD *)a1 + 32 * v210;
            v211 = *(_QWORD *)v118;
            if (v78 == *(_QWORD *)v118)
            {
LABEL_305:
              v125 = v78;
              v114 = a1;
              v116 = v246;
              goto LABEL_131;
            }
          }
        }
        else
        {
          if (v115 + ~v124 - *(_DWORD *)(a1 + 12) > v115 >> 3)
          {
LABEL_130:
            v125 = *(_QWORD *)v118;
LABEL_131:
            ++*(_DWORD *)(v114 + 8);
            if (v125 != -1)
              --*(_DWORD *)(v114 + 12);
            *(_QWORD *)v118 = v78;
            *(_QWORD *)(v118 + 8) = 0;
            *(_QWORD *)(v118 + 16) = 0;
            *(_QWORD *)(v118 + 24) = 0;
LABEL_134:
            v126 = sub_1C5E3DF4C(__src, (uint64_t)&__src[v79]);
            v127 = v118 + 8;
            v128 = *(_QWORD *)(v118 + 8);
            v129 = *(_DWORD *)(v118 + 24);
            if (v129)
            {
              v130 = (v129 - 1) & (37 * v126);
              v131 = (unint64_t *)(v128 + 8 * v130);
              v132 = *v131;
              if (v126 == *v131)
                goto LABEL_136;
              v205 = 0;
              v206 = 1;
              while (v132 != -1)
              {
                if (v205)
                  v207 = 0;
                else
                  v207 = v132 == -2;
                if (v207)
                  v205 = v131;
                v208 = v130 + v206++;
                v130 = v208 & (v129 - 1);
                v131 = (unint64_t *)(v128 + 8 * v130);
                v132 = *v131;
                if (v126 == *v131)
                  goto LABEL_136;
              }
              if (v205)
                v133 = v205;
              else
                v133 = v131;
            }
            else
            {
              v133 = 0;
            }
            v134 = *(_DWORD *)(v118 + 16);
            if (4 * v134 + 4 >= 3 * v129)
            {
              sub_1C5465CCC(v127, 2 * v129);
              v216 = *(_QWORD *)(v118 + 8);
              v217 = *(_DWORD *)(v118 + 24) - 1;
              v218 = v217 & (37 * v126);
              v133 = (unint64_t *)(v216 + 8 * v218);
              v219 = *v133;
              if (v126 == *v133)
                goto LABEL_294;
              v220 = 0;
              v221 = 1;
              while (v219 != -1)
              {
                if (v220)
                  v222 = 0;
                else
                  v222 = v219 == -2;
                if (v222)
                  v220 = v133;
                v223 = v218 + v221++;
                v218 = v223 & v217;
                v133 = (unint64_t *)(v216 + 8 * (v223 & v217));
                v219 = *v133;
                if (v126 == *v133)
                {
LABEL_317:
                  v135 = v126;
                  v114 = a1;
                  v116 = v246;
                  goto LABEL_150;
                }
              }
            }
            else
            {
              if (v129 + ~v134 - *(_DWORD *)(v118 + 20) > v129 >> 3)
              {
LABEL_149:
                v135 = *v133;
                goto LABEL_150;
              }
              sub_1C5465CCC(v127, v129);
              v227 = *(_QWORD *)(v118 + 8);
              v228 = *(_DWORD *)(v118 + 24) - 1;
              v229 = v228 & (37 * v126);
              v133 = (unint64_t *)(v227 + 8 * v229);
              v230 = *v133;
              if (v126 == *v133)
              {
LABEL_294:
                v135 = v126;
LABEL_150:
                ++*(_DWORD *)(v118 + 16);
                if (v135 != -1)
                  --*(_DWORD *)(v118 + 20);
                *v133 = v126;
                v137 = *(_QWORD *)(v114 + 32);
                v136 = *(_QWORD *)(v114 + 40);
                if (v137 < v136)
                {
                  v138 = *(_OWORD *)__dst;
                  *(_QWORD *)(v137 + 16) = *(_QWORD *)&__dst[16];
                  *(_OWORD *)v137 = v138;
                  memset(__dst, 0, sizeof(__dst));
                  *(_OWORD *)(v137 + 24) = v258;
                  *(_QWORD *)(v137 + 40) = v259;
                  *(_QWORD *)v28 = 0;
                  *((_QWORD *)v28 + 1) = 0;
                  *((_QWORD *)v28 + 2) = 0;
                  *(_OWORD *)(v137 + 48) = *(_OWORD *)v260;
                  *(void **)(v137 + 64) = __p[0];
                  v260[0] = 0;
                  v260[1] = 0;
                  __p[0] = 0;
                  *(_OWORD *)(v137 + 72) = *(_OWORD *)&__p[1];
                  *(void **)(v137 + 88) = __p[3];
                  memset(&__p[1], 0, 24);
                  *(_QWORD *)(v137 + 96) = v262;
                  v139 = (char *)(v137 + 104);
LABEL_186:
                  *(_QWORD *)(v114 + 32) = v139;
                  v158 = *(_QWORD *)(v116 + 32);
                  if (!v158)
                  {
LABEL_136:
                    *v245 = 0;
LABEL_137:
                    if (__p[1])
                    {
                      __p[2] = __p[1];
                      operator delete(__p[1]);
                    }
                    if (v260[0])
                    {
                      v260[1] = v260[0];
                      operator delete(v260[0]);
                    }
                    *(_QWORD *)&v275 = v28;
                    sub_1C4765410((void ***)&v275);
                    if ((__dst[23] & 0x80000000) != 0)
                      operator delete(*(void **)__dst);
                    goto LABEL_143;
                  }
                  v159 = -991146299 * ((unint64_t)&v139[-*(_QWORD *)(v114 + 24)] >> 3) - 1;
                  v160 = *(_QWORD *)(v116 + 24);
                  v161 = v160 + 16 * v158;
                  while (1)
                  {
                    v162 = sub_1C5E3DF4C(*(_QWORD **)v160, *(_QWORD *)v160 + *(_QWORD *)(v160 + 8));
                    *(_QWORD *)&v275 = 0;
                    v163 = sub_1C5465A08(*(_QWORD *)(v114 + 48), *(_DWORD *)(v114 + 64), v162, &v275);
                    v164 = v275;
                    if ((v163 & 1) == 0)
                      break;
                    v166 = (_DWORD *)(v275 + 16);
                    v165 = *(unsigned int *)(v275 + 16);
                    v167 = (_QWORD *)(v275 + 8);
                    if (!(_DWORD)v165)
                    {
                      v165 = 0;
LABEL_198:
                      if (v165 >= *(unsigned int *)(v164 + 20))
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v167, v164 + 24, v165 + 1, 4);
                        v165 = *v166;
                      }
                      *(_DWORD *)(*v167 + 4 * v165) = v159;
                      ++*v166;
                      goto LABEL_201;
                    }
                    if (*(_DWORD *)(*v167 + 4 * v165 - 4) != v159)
                      goto LABEL_198;
LABEL_201:
                    v160 += 16;
                    if (v160 == v161)
                      goto LABEL_136;
                  }
                  v168 = *(_DWORD *)(v114 + 56);
                  v169 = *(_DWORD *)(v114 + 64);
                  if (4 * v168 + 4 >= 3 * v169)
                  {
                    v169 *= 2;
                  }
                  else if (v169 + ~v168 - *(_DWORD *)(v114 + 60) > v169 >> 3)
                  {
LABEL_194:
                    ++*(_DWORD *)(v114 + 56);
                    if (*(_QWORD *)v164 != -1)
                      --*(_DWORD *)(v114 + 60);
                    v165 = 0;
                    *(_QWORD *)v164 = v162;
                    *(_QWORD *)(v164 + 8) = v164 + 24;
                    v167 = (_QWORD *)(v164 + 8);
                    *(_DWORD *)(v164 + 16) = 0;
                    v166 = (_DWORD *)(v164 + 16);
                    *(_DWORD *)(v164 + 20) = 0;
                    goto LABEL_198;
                  }
                  sub_1C5465ED0(v114 + 48, v169);
                  *(_QWORD *)&v275 = 0;
                  sub_1C5465A08(*(_QWORD *)(v114 + 48), *(_DWORD *)(v114 + 64), v162, &v275);
                  v164 = v275;
                  goto LABEL_194;
                }
                v140 = *(_QWORD *)(v114 + 24);
                v141 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v137 - v140) >> 3) + 1;
                if (v141 <= 0x276276276276276)
                {
                  v142 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v136 - v140) >> 3);
                  if (2 * v142 > v141)
                    v141 = 2 * v142;
                  if (v142 >= 0x13B13B13B13B13BLL)
                    v143 = 0x276276276276276;
                  else
                    v143 = v141;
                  if (v143 <= 0x276276276276276)
                  {
                    v144 = 104 * v143;
                    v145 = (char *)operator new(104 * v143);
                    v146 = &v145[8 * ((uint64_t)(v137 - v140) >> 3)];
                    *(_OWORD *)v146 = *(_OWORD *)__dst;
                    v147 = &v145[v144];
                    *((_QWORD *)v146 + 2) = *(_QWORD *)&__dst[16];
                    memset(__dst, 0, sizeof(__dst));
                    *(_OWORD *)(v146 + 24) = v258;
                    *((_QWORD *)v146 + 5) = v259;
                    *((_QWORD *)v28 + 1) = 0;
                    *((_QWORD *)v28 + 2) = 0;
                    *(_QWORD *)v28 = 0;
                    *((_QWORD *)v146 + 8) = 0;
                    *((_OWORD *)v146 + 3) = *(_OWORD *)v260;
                    *((void **)v146 + 8) = __p[0];
                    v260[0] = 0;
                    v260[1] = 0;
                    __p[0] = 0;
                    *((_QWORD *)v146 + 10) = 0;
                    *((_QWORD *)v146 + 11) = 0;
                    *(_OWORD *)(v146 + 72) = *(_OWORD *)&__p[1];
                    memset(&__p[1], 0, 24);
                    v148 = v262;
                    v139 = v146 + 104;
                    *((void **)v146 + 11) = __p[3];
                    *((_QWORD *)v146 + 12) = v148;
                    if (v137 == v140)
                    {
                      v114 = a1;
                      *(_QWORD *)(a1 + 24) = v146;
                      *(_QWORD *)(a1 + 32) = v139;
                      *(_QWORD *)(a1 + 40) = v147;
                    }
                    else
                    {
                      v114 = a1;
                      do
                      {
                        v137 -= 104;
                        sub_1C5465E50((uint64_t)(v146 - 104), (__int128 *)v137);
                      }
                      while (v137 != v140);
                      v137 = *(_QWORD *)(a1 + 24);
                      v149 = *(_QWORD *)(a1 + 32);
                      *(_QWORD *)(a1 + 24) = v146;
                      *(_QWORD *)(a1 + 32) = v139;
                      *(_QWORD *)(a1 + 40) = v147;
                      if (v149 != v137)
                      {
                        v116 = v246;
                        do
                        {
                          v150 = *(void **)(v149 - 32);
                          if (v150)
                          {
                            *(_QWORD *)(v149 - 24) = v150;
                            operator delete(v150);
                          }
                          v151 = *(void **)(v149 - 56);
                          if (v151)
                          {
                            *(_QWORD *)(v149 - 48) = v151;
                            operator delete(v151);
                          }
                          *(_QWORD *)&v275 = v149 - 80;
                          sub_1C4765410((void ***)&v275);
                          if (*(char *)(v149 - 81) < 0)
                            operator delete(*(void **)(v149 - 104));
                          v149 -= 104;
                        }
                        while (v149 != v137);
                        goto LABEL_184;
                      }
                    }
                    v116 = v246;
LABEL_184:
                    if (v137)
                      operator delete((void *)v137);
                    goto LABEL_186;
                  }
LABEL_296:
                  sub_1C4764EE4();
                }
LABEL_295:
                abort();
              }
              v220 = 0;
              v234 = 1;
              while (v230 != -1)
              {
                if (v220)
                  v235 = 0;
                else
                  v235 = v230 == -2;
                if (v235)
                  v220 = v133;
                v236 = v229 + v234++;
                v229 = v236 & v228;
                v133 = (unint64_t *)(v227 + 8 * (v236 & v228));
                v230 = *v133;
                if (v126 == *v133)
                  goto LABEL_317;
              }
            }
            if (v220)
              v133 = v220;
            v114 = a1;
            v116 = v246;
            goto LABEL_149;
          }
          sub_1C5465B00((uint64_t *)a1, v115);
          v224 = *(_DWORD *)(a1 + 16) - 1;
          v225 = v224 & (37 * v78);
          v118 = *(_QWORD *)a1 + 32 * v225;
          v226 = *(_QWORD *)v118;
          if (v78 == *(_QWORD *)v118)
          {
LABEL_292:
            v125 = v78;
            goto LABEL_131;
          }
          v212 = 0;
          v231 = 1;
          while (v226 != -1)
          {
            if (v212)
              v232 = 0;
            else
              v232 = v226 == -2;
            if (v232)
              v212 = v118;
            v233 = v225 + v231++;
            v225 = v233 & v224;
            v118 = *(_QWORD *)a1 + 32 * v225;
            v226 = *(_QWORD *)v118;
            if (v78 == *(_QWORD *)v118)
              goto LABEL_305;
          }
        }
        if (v212)
          v118 = v212;
        v114 = a1;
        v116 = v246;
        goto LABEL_130;
      }
    }
    memmove(v15, __src, v12);
    goto LABEL_17;
  }
  *a4 = 0;
LABEL_143:
  if (v264)
  {
    v265 = v264;
    operator delete(v264);
  }
}

void llvm::coverage::CoverageMapping::loadFromReaders(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t *v8;
  uint64_t *v9;
  __int128 v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  _QWORD v14[3];
  __int128 v15;
  __int128 v16;
  __int128 v17;
  int v18;

  if (a2)
  {
    v8 = a1;
    v9 = &a1[a2];
    v10 = 0uLL;
    while (2)
    {
      v13 = *v8;
      v14[0] = 0;
      v14[1] = 0;
      v15 = v10;
      v16 = v10;
      v17 = v10;
      v18 = 0;
      while (1)
      {
        llvm::coverage::CoverageMappingIterator::increment(&v13);
        if (!v13)
          break;
        if (v18)
        {
          v11 = operator new();
          v12 = v18;
          *(_QWORD *)v11 = &off_1E8169028;
          *(_DWORD *)(v11 + 8) = v12;
          *a5 = v11;
          return;
        }
        *a5 = 0;
        llvm::coverage::CoverageMapping::loadFunctionRecord(a4, (uint64_t)v14, a3, a5);
        if (*a5)
          return;
      }
      ++v8;
      v10 = 0uLL;
      if (v8 != v9)
        continue;
      break;
    }
  }
  *a5 = 0;
}

void llvm::coverage::CoverageMapping::load(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8;
  void **v9;
  void **v10;

  v8 = operator new();
  *(_OWORD *)v8 = 0u;
  *(_OWORD *)(v8 + 16) = 0u;
  *(_OWORD *)(v8 + 32) = 0u;
  *(_OWORD *)(v8 + 48) = 0u;
  *(_OWORD *)(v8 + 64) = 0u;
  *(_OWORD *)(v8 + 80) = 0u;
  llvm::coverage::CoverageMapping::loadFromReaders(a1, a2, a3, v8, (uint64_t *)&v10);
  v9 = v10;
  if (v10)
  {
    *(_BYTE *)(a4 + 8) |= 1u;
    v10 = (void **)(v8 + 72);
    sub_1C5464DAC(&v10);
    sub_1C5464E24((uint64_t *)(v8 + 48));
    v10 = (void **)(v8 + 24);
    sub_1C5464E98(&v10);
    sub_1C5464F3C(v8);
    MEMORY[0x1CAA32FB4](*(_QWORD *)v8, 8);
    MEMORY[0x1CAA32FC0](v8, 0x1020C40EA482D60);
    v8 = (uint64_t)v9;
  }
  else
  {
    *(_BYTE *)(a4 + 8) &= ~1u;
  }
  *(_QWORD *)a4 = v8;
}

uint64_t llvm::coverage::CoverageMapping::load@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void **a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X8>, uint64_t a9, uint64_t a10)
{
  uint64_t v13;
  _OWORD *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  char v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t *v29;
  uint64_t *v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  char *v35;
  _QWORD *v36;
  char **v37;
  uint64_t v38;
  char *v39;
  char *v40;
  unint64_t v41;
  int64_t v42;
  uint64_t v43;
  uint64_t *v44;
  BOOL v45;
  char *v46;
  int v47;
  _WORD *v48;
  uint64_t v49;
  char *v50;
  uint64_t v51;
  void *v52;
  _QWORD *v53;
  void **v54;
  uint64_t v55;
  void **v56;
  void *v57;
  uint64_t result;
  uint64_t v59;
  _QWORD *v60;
  void **v61;
  void **v62;
  uint64_t *v63;
  uint64_t v64;
  _QWORD *v66;
  uint64_t v67;
  uint64_t v68;
  char v70;
  _QWORD v71[4];
  uint64_t v72;
  char *v73;
  char *v74;
  void *v75;
  uint64_t v76;
  _WORD v77[16];
  _QWORD *v78;
  _QWORD *v79;
  char v80;
  void **v81;
  uint64_t v82;
  _BYTE v83[16];
  __int16 v84;
  _QWORD v85[2];
  char v86;
  uint64_t v87;
  char v88;
  uint64_t v89;

  v89 = *MEMORY[0x1E0C80C00];
  v84 = 261;
  v81 = a3;
  v82 = a4;
  v77[8] = 257;
  llvm::IndexedInstrProfReader::create((llvm::Twine *)&v81, a5, (llvm::Twine *)&v75, (uint64_t)&v87);
  v13 = v87;
  if ((v88 & 1) != 0)
  {
    v87 = 0;
    if (v13)
    {
      *(_BYTE *)(a8 + 8) |= 1u;
      *(_QWORD *)a8 = v13;
      goto LABEL_78;
    }
  }
  v87 = 0;
  v14 = (_OWORD *)operator new();
  v14[3] = 0u;
  *v14 = 0u;
  v14[1] = 0u;
  v14[2] = 0u;
  v14[4] = 0u;
  v14[5] = 0u;
  if (!a2)
  {
    LOBYTE(v16) = *(_BYTE *)(a8 + 8);
LABEL_76:
    *(_BYTE *)(a8 + 8) = v16 & 0xFE;
    *(_QWORD *)a8 = v14;
    if (!v13)
      goto LABEL_78;
LABEL_77:
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
    goto LABEL_78;
  }
  v63 = (uint64_t *)(v14 + 3);
  v67 = v13;
  v70 = 0;
  v15 = 0;
  v66 = v14;
  v61 = (void **)v14 + 9;
  v62 = (void **)v14 + 3;
  v64 = a8;
  v16 = *(unsigned __int8 *)(a8 + 8);
  v68 = a1 + 16 * a2;
  do
  {
    v84 = 261;
    v17 = *(_QWORD *)(a1 + 8);
    v81 = *(void ***)a1;
    v82 = v17;
    llvm::MemoryBuffer::getFileOrSTDIN((const char ***)&v81, 0, 0, (uint64_t)v85);
    v18 = v86;
    if ((v86 & 1) != 0)
    {
      v19 = v85[0];
      if (LODWORD(v85[0]))
      {
        v59 = v85[1];
        v60 = (_QWORD *)operator new();
        *v60 = &off_1E81A0D28;
        v60[1] = v19;
        v60[2] = v59;
        goto LABEL_83;
      }
    }
    else
    {
      std::system_category();
    }
    if (a7)
    {
      v20 = a6 + 16 * v15;
      v22 = *(void **)v20;
      v21 = *(void **)(v20 + 8);
    }
    else
    {
      v21 = 0;
      v22 = 0;
    }
    v23 = v85[0];
    v24 = *(_QWORD *)(v85[0] + 8);
    v25 = *(_QWORD *)(v85[0] + 16) - v24;
    v26 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v85[0] + 16))(v85[0]);
    v81 = (void **)v83;
    v82 = 0x400000000;
    v71[0] = v24;
    v71[1] = v25;
    v71[2] = v26;
    v71[3] = v27;
    llvm::coverage::BinaryCoverageReader::create((uint64_t)v71, v22, v21, &v81, a9, a10, (uint64_t)&v78);
    v28 = v78;
    if ((v80 & 1) != 0 && (v78 = 0, v28))
    {
      if ((*(unsigned int (**)(_QWORD *, void *))(*v28 + 48))(v28, &llvm::ErrorList::ID))
      {
        v30 = (uint64_t *)v28[1];
        v29 = (uint64_t *)v28[2];
        if (v30 == v29)
        {
          v31 = 0;
        }
        else
        {
          v31 = 0;
          do
          {
            v74 = v31;
            v32 = *v30;
            *v30 = 0;
            v72 = v32;
            sub_1C54617C8((uint64_t *)&v73, &v72);
            sub_1C6174794(&v74, &v73, &v75);
            v31 = (char *)v75;
            v75 = 0;
            if (v73)
              (*(void (**)(char *))(*(_QWORD *)v73 + 8))(v73);
            v33 = v72;
            v72 = 0;
            if (v33)
              (*(void (**)(uint64_t))(*(_QWORD *)v33 + 8))(v33);
            if (v74)
              (*(void (**)(char *))(*(_QWORD *)v74 + 8))(v74);
            ++v30;
          }
          while (v30 != v29);
        }
        (*(void (**)(_QWORD *))(*v28 + 8))(v28);
        if (v31)
          goto LABEL_52;
      }
      else
      {
        v75 = v28;
        sub_1C54617C8((uint64_t *)&v74, &v75);
        v52 = v75;
        v75 = 0;
        if (v52)
          (*(void (**)(void *))(*(_QWORD *)v52 + 8))(v52);
        v31 = v74;
        if (v74)
        {
LABEL_52:
          v16 |= 1u;
          *(_BYTE *)(v64 + 8) = v16;
          *(_QWORD *)v64 = v31;
          v47 = 1;
          goto LABEL_56;
        }
      }
      v47 = 3;
    }
    else
    {
      v75 = v77;
      v76 = 0x400000000;
      v34 = v79;
      if (v28 == v79)
      {
        v43 = 0;
        v44 = (uint64_t *)v77;
      }
      else
      {
        do
        {
          v35 = (char *)*v28;
          *v28 = 0;
          v74 = v35;
          v36 = v75;
          if (v76 >= HIDWORD(v76))
          {
            v41 = v76 + 1;
            if (v75 <= &v74 && (char *)v75 + 8 * v76 > (char *)&v74)
            {
              v42 = (char *)&v74 - (_BYTE *)v75;
              sub_1C6189DFC((uint64_t)&v75, v41);
              v36 = v75;
              v37 = (char **)((char *)v75 + v42);
            }
            else
            {
              sub_1C6189DFC((uint64_t)&v75, v41);
              v37 = &v74;
              v36 = v75;
            }
          }
          else
          {
            v37 = &v74;
          }
          v38 = v76;
          v39 = *v37;
          *v37 = 0;
          v36[v38] = v39;
          LODWORD(v76) = v38 + 1;
          v40 = v74;
          v74 = 0;
          if (v40)
            (*(void (**)(char *))(*(_QWORD *)v40 + 8))(v40);
          ++v28;
        }
        while (v28 != v34);
        v43 = v76;
        v44 = (uint64_t *)v75;
      }
      v45 = v43 != 0;
      llvm::coverage::CoverageMapping::loadFromReaders(v44, v43, v67, (uint64_t)v66, (uint64_t *)&v74);
      v46 = v74;
      if (v74)
      {
        v16 |= 1u;
        *(_BYTE *)(v64 + 8) = v16;
        *(_QWORD *)v64 = v46;
        v47 = 1;
      }
      else
      {
        v47 = 0;
      }
      v48 = v75;
      if ((_DWORD)v76)
      {
        v49 = 8 * v76;
        v50 = (char *)v75 - 8;
        do
        {
          v51 = *(_QWORD *)&v50[v49];
          *(_QWORD *)&v50[v49] = 0;
          if (v51)
            (*(void (**)(uint64_t))(*(_QWORD *)v51 + 8))(v51);
          v49 -= 8;
        }
        while (v49);
        v48 = v75;
      }
      if (v48 != v77)
        free(v48);
      v70 |= v45;
    }
LABEL_56:
    if ((v80 & 1) != 0)
    {
      v53 = v78;
      v78 = 0;
      if (v53)
        (*(void (**)(_QWORD *))(*v53 + 8))(v53);
    }
    else
    {
      v75 = &v78;
      sub_1C4764BBC((void ***)&v75);
    }
    v54 = v81;
    if ((_DWORD)v82)
    {
      v55 = v82;
      v56 = v81 - 1;
      do
      {
        v57 = v56[v55];
        v56[v55] = 0;
        if (v57)
          (*(void (**)(void *))(*(_QWORD *)v57 + 8))(v57);
        --v55;
      }
      while (v55 * 8);
      v54 = v81;
    }
    if (v54 != (void **)v83)
      free(v54);
    if ((v18 & 1) == 0)
      (*(void (**)(uint64_t))(*(_QWORD *)v23 + 8))(v23);
    if (v47 != 3 && v47)
      goto LABEL_84;
    a1 += 16;
    ++v15;
  }
  while (a1 != v68);
  if ((v70 & 1) != 0)
  {
    v14 = v66;
    v13 = v67;
    a8 = v64;
    goto LABEL_76;
  }
  v60 = (_QWORD *)operator new();
  *v60 = &off_1E8169028;
  *((_DWORD *)v60 + 2) = 2;
LABEL_83:
  *(_BYTE *)(v64 + 8) = v16 | 1;
  *(_QWORD *)v64 = v60;
LABEL_84:
  v81 = v61;
  sub_1C5464DAC(&v81);
  sub_1C5464E24(v63);
  v81 = v62;
  sub_1C5464E98(&v81);
  sub_1C5464F3C((uint64_t)v66);
  MEMORY[0x1CAA32FB4](*v66, 8);
  MEMORY[0x1CAA32FC0](v66, 0x1020C40EA482D60);
  v13 = v67;
  if (v67)
    goto LABEL_77;
LABEL_78:
  result = v87;
  v87 = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

const void **llvm::coverage::CoverageMapping::getUniqueSourceFiles@<X0>(llvm::coverage::CoverageMapping *this@<X0>, __int128 **a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  __int128 *v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  __int128 *v12;
  uint64_t v13;
  char *v14;
  __int128 *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t *v21;
  __int128 *v22;
  uint64_t *v23;
  char *v24;
  uint64_t *v25;
  char v26;
  int v27;
  uint64_t v28;
  char *v29;
  __int128 *v30;
  __int128 v31;
  char *v32;
  char v33;
  BOOL v34;
  uint64_t *v35;
  uint64_t v36;
  char *v37;
  char *v38;
  char *v39;
  char v40;
  BOOL v41;
  uint64_t *v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  int64_t v46;
  __int128 *v47;
  unint64_t v48;
  uint64_t v49;
  const void **result;
  unint64_t v51;
  __int128 v52;
  __int128 v53;
  uint64_t v54;
  __int128 v55;
  __int128 v56;
  uint64_t v57;

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v3 = *((_QWORD *)this + 3);
  v4 = 0x4EC4EC4EC4EC4EC5 * ((*((_QWORD *)this + 4) - v3) >> 3);
  *(_QWORD *)&v55 = v3;
  *((_QWORD *)&v55 + 1) = v4;
  *(_QWORD *)&v56 = v3;
  *((_QWORD *)&v56 + 1) = "";
  v57 = 0;
  llvm::coverage::FunctionRecordIterator::skipOtherFiles((llvm::coverage::FunctionRecordIterator *)&v55);
  v54 = v57;
  v52 = v55;
  v53 = v56;
  v5 = v56;
  if (!(_QWORD)v56)
  {
    v6 = 0;
    v7 = 0;
    if (!v57)
      goto LABEL_57;
  }
  v8 = 0;
  do
  {
    v10 = *(uint64_t **)(v5 + 24);
    v9 = *(uint64_t **)(v5 + 32);
    if ((char *)v9 - (char *)v10 >= 1)
    {
      v11 = 0xAAAAAAAAAAAAAAABLL * (v9 - v10);
      v12 = *a2;
      v13 = v8 - (char *)*a2;
      v14 = (char *)*a2 + (v13 & 0xFFFFFFFFFFFFFFF0);
      v15 = a2[2];
      if (v11 <= ((char *)v15 - v8) >> 4)
      {
        v20 = (v8 - v14) >> 4;
        if (v20 >= v11)
        {
          v21 = &v10[v9 - v10];
          v22 = (__int128 *)v8;
        }
        else
        {
          v21 = &v10[3 * v20];
          v22 = (__int128 *)v8;
          if (v21 != v9)
          {
            v23 = v21;
            v24 = v8;
            do
            {
              if (*((char *)v23 + 23) >= 0)
                v25 = v23;
              else
                v25 = (uint64_t *)*v23;
              *(_QWORD *)v24 = v25;
              v26 = *((_BYTE *)v23 + 23);
              v27 = v26;
              v28 = v26 & 0x7F;
              if (v27 < 0)
                v28 = v23[1];
              *((_QWORD *)v24 + 1) = v28;
              v23 += 3;
              ++v22;
              v24 += 16;
            }
            while (v23 != v9);
          }
          a2[1] = v22;
          if (v8 - v14 < 1)
          {
            v8 = (char *)v22;
            goto LABEL_54;
          }
        }
        v29 = (char *)&v22[0x555555555555555 * (v9 - v10)];
        v30 = v22;
        while (v29 < v8)
        {
          v31 = *(_OWORD *)v29;
          v29 += 16;
          *v30++ = v31;
        }
        v32 = &v14[16 * v11];
        a2[1] = v30;
        if (v22 != (__int128 *)v32)
          memmove(&v22[-(((char *)v22 - v32) >> 4)], v14, (char *)v22 - v32);
        for (; v10 != v21; v10 += 3)
        {
          v33 = *((_BYTE *)v10 + 23);
          v34 = v33 < 0;
          v35 = (uint64_t *)*v10;
          if (v33 >= 0)
            v35 = v10;
          v36 = v33 & 0x7F;
          if (v34)
            v36 = v10[1];
          *(_QWORD *)v14 = v35;
          *((_QWORD *)v14 + 1) = v36;
          v14 += 16;
        }
        v8 = (char *)v30;
      }
      else
      {
        v16 = v13 >> 4;
        v17 = (v13 >> 4) - 0x5555555555555555 * (v9 - v10);
        if (v17 >> 60)
          abort();
        v18 = (char *)v15 - (char *)v12;
        if (v18 >> 3 > v17)
          v17 = v18 >> 3;
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF0)
          v17 = 0xFFFFFFFFFFFFFFFLL;
        v51 = v17;
        if (v17)
        {
          if (v17 >> 60)
            sub_1C4764EE4();
          v19 = (char *)operator new(16 * v17);
        }
        else
        {
          v19 = 0;
        }
        v37 = &v19[16 * v16];
        v38 = &v37[16 * v11];
        v39 = v37;
        do
        {
          v40 = *((_BYTE *)v10 + 23);
          v41 = v40 < 0;
          if (v40 >= 0)
            v42 = v10;
          else
            v42 = (uint64_t *)*v10;
          *(_QWORD *)v39 = v42;
          v43 = v40 & 0x7F;
          if (v41)
            v43 = v10[1];
          *((_QWORD *)v39 + 1) = v43;
          v10 += 3;
          v39 += 16;
        }
        while (v39 != v38);
        if (v12 != (__int128 *)v8)
        {
          v44 = v16;
          do
          {
            *(_OWORD *)&v19[v44 * 16 - 16] = v12[v44 - 1];
            --v44;
          }
          while (v44 * 16);
          v37 = v19;
        }
        v45 = (char *)a2[1];
        v46 = v45 - v14;
        if (v45 != v14)
          memmove(v38, v14, v45 - v14);
        v47 = *a2;
        v8 = &v38[v46];
        *a2 = (__int128 *)v37;
        a2[1] = (__int128 *)v8;
        a2[2] = (__int128 *)&v19[16 * v51];
        if (v47)
          operator delete(v47);
      }
    }
LABEL_54:
    *(_QWORD *)&v53 = v5 + 104;
    llvm::coverage::FunctionRecordIterator::skipOtherFiles((llvm::coverage::FunctionRecordIterator *)&v52);
    v5 = v53;
  }
  while ((_QWORD)v53 || v54);
  v7 = *a2;
  v6 = a2[1];
LABEL_57:
  v48 = 126 - 2 * __clz(v6 - v7);
  if (v6 == v7)
    v49 = 0;
  else
    v49 = v48;
  sub_1C4E4F728(v7, v6, (uint64_t)&v55, v49, 1);
  result = sub_1C4E509FC((const void **)v7, (const void **)v6);
  if (v6 != (__int128 *)result)
    a2[1] = (__int128 *)result;
  return result;
}

double LLVMCreateCoverageSourceFileRange(llvm::coverage::CoverageMapping *a1)
{
  uint64_t v1;
  uint64_t v2;
  double result;
  __int128 v4;
  uint64_t v5;

  llvm::coverage::CoverageMapping::getUniqueSourceFiles(a1, (__int128 **)&v4);
  v1 = operator new();
  v2 = v5;
  *(_DWORD *)v1 = 0;
  result = *(double *)&v4;
  *(_OWORD *)(v1 + 8) = v4;
  *(_QWORD *)(v1 + 24) = v2;
  return result;
}

uint64_t LLVMDisposeCoverageSourceFileRange(uint64_t result)
{
  uint64_t v1;
  void *v2;

  if (result)
  {
    v1 = result;
    v2 = *(void **)(result + 8);
    if (v2)
    {
      *(_QWORD *)(v1 + 16) = v2;
      operator delete(v2);
    }
    JUMPOUT(0x1CAA32FC0);
  }
  return result;
}

uint64_t LLVMGetNextCoverageSourceFile(unsigned int *a1)
{
  unint64_t v1;
  uint64_t v2;

  v1 = *a1;
  v2 = *((_QWORD *)a1 + 1);
  if (v1 < (*((_QWORD *)a1 + 2) - v2) >> 4 && (*a1 = v1 + 1, v2))
    return *(_QWORD *)(v2 + 16 * v1);
  else
    return 0;
}

void llvm::coverage::CoverageMapping::getCoverageForFile(uint64_t a1@<X0>, _QWORD *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  size_t v5;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int *ImpreciseRecordIndicesForFilename;
  uint64_t v11;
  __n128 v12;
  char *v13;
  char *v14;
  _QWORD *v15;
  const void ***v16;
  const void **v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t i;
  char v25;
  BOOL v26;
  const void *v27;
  const void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  unint64_t v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  unint64_t v37;
  unint64_t v38;
  char *v39;
  char *v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  char *v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  char *v48;
  char *v49;
  unint64_t v50;
  char *v51;
  char *v52;
  char *v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  uint64_t v57;
  char *v58;
  char *v59;
  char *v60;
  char *v61;
  __int128 v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67;
  char *v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  char *v72;
  char *v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  char *v77;
  char *v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  char *v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  char *v86;
  void *v87;
  unsigned int *v88;
  unsigned int *v90;
  char *v91;
  uint64_t v92;
  unsigned int v93;
  _QWORD *v94;
  _QWORD *__s1;
  uint64_t v96;
  size_t v97;
  __int128 v98;
  uint64_t v99;

  if (a3 >= 0x7FFFFFFFFFFFFFF8)
LABEL_112:
    abort();
  v5 = a3;
  if (a3 >= 0x17)
  {
    v8 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a3 | 7) != 0x17)
      v8 = a3 | 7;
    v9 = v8 + 1;
    v7 = operator new(v8 + 1);
    *(_QWORD *)(a4 + 8) = v5;
    *(_QWORD *)(a4 + 16) = v9 | 0x8000000000000000;
    *(_QWORD *)a4 = v7;
    goto LABEL_8;
  }
  *(_BYTE *)(a4 + 23) = a3;
  v7 = (void *)a4;
  if (a3)
LABEL_8:
    memmove(v7, a2, v5);
  *((_BYTE *)v7 + v5) = 0;
  *(_OWORD *)(a4 + 24) = 0u;
  *(_QWORD *)(a4 + 88) = 0;
  *(_OWORD *)(a4 + 56) = 0u;
  *(_OWORD *)(a4 + 72) = 0u;
  *(_OWORD *)(a4 + 40) = 0u;
  ImpreciseRecordIndicesForFilename = (unsigned int *)llvm::coverage::CoverageMapping::getImpreciseRecordIndicesForFilename(a1, a2, v5);
  if (v11)
  {
    v13 = 0;
    v14 = 0;
    v91 = 0;
    v88 = &ImpreciseRecordIndicesForFilename[v11];
    v97 = v5;
    __s1 = a2;
    while (1)
    {
      v90 = ImpreciseRecordIndicesForFilename;
      v92 = *(_QWORD *)(a1 + 24);
      v93 = *ImpreciseRecordIndicesForFilename;
      v15 = (_QWORD *)(v92 + 104 * *ImpreciseRecordIndicesForFilename);
      v96 = sub_1C545ECCC(a2, v5, v15);
      v16 = (const void ***)(v15 + 3);
      v17 = (const void **)v15[3];
      v94 = v15;
      v19 = v15[4];
      v18 = v15 + 4;
      v20 = (v19 - (uint64_t)v17) >> 3;
      v21 = -1431655765 * v20;
      v22 = (-1431655765 * v20);
      *(_QWORD *)&v98 = 1;
      if ((-1431655765 * v20) > 0x39)
      {
        v23 = operator new();
        *(_QWORD *)v23 = v23 + 16;
        *(_QWORD *)(v23 + 8) = 0x600000000;
        sub_1C4765AA4((char *)v23, (v21 + 63) >> 6, 0);
        *(_DWORD *)(v23 + 64) = v22;
        v17 = *v16;
        v22 = -1431655765 * ((*v18 - (_QWORD)*v16) >> 3);
      }
      else
      {
        v23 = (0xAC00000000000000 * v20) | 1;
      }
      *(_QWORD *)&v98 = v23;
      a2 = __s1;
      if (v22)
      {
        for (i = 0; i != v22; ++i)
        {
          v25 = *((_BYTE *)v17 + 23);
          v26 = v25 < 0;
          if (v25 >= 0)
            v27 = v17;
          else
            v27 = *v17;
          v28 = (const void *)(v25 & 0x7F);
          if (v26)
            v28 = v17[1];
          if ((const void *)v5 == v28 && (!v5 || !memcmp(__s1, v27, v5)))
          {
            if ((v98 & 1) != 0)
              *(_QWORD *)&v98 = v98 & 0xFC00000000000000 | (2
                                                            * ((((unint64_t)v98 >> 1) & ~(-1 << ((unint64_t)v98 >> 58)) | (1 << i)) & ~(-1 << ((unint64_t)v98 >> 58)))) | 1;
            else
              *(_QWORD *)(*(_QWORD *)v98 + 8 * (i >> 6)) |= 1 << i;
          }
          v17 += 3;
        }
      }
      v29 = v92 + 104 * v93;
      v30 = *(_QWORD *)(v29 + 48);
      v31 = *(_QWORD *)(v29 + 56);
      if (v30 != v31)
      {
        v32 = v91;
        while (1)
        {
          v33 = *(unsigned int *)(v30 + 16);
          if ((v98 & 1) != 0)
          {
            if (((1 << v33) & ((unint64_t)v98 >> 1) & ~(-1 << ((unint64_t)v98 >> 58))) != 0)
            {
LABEL_33:
              if (v14 >= v32)
              {
                v37 = 0x8E38E38E38E38E39 * ((v14 - v13) >> 3) + 1;
                if (v37 > 0x38E38E38E38E38ELL)
                  goto LABEL_112;
                if (0x1C71C71C71C71C72 * ((v32 - v13) >> 3) > v37)
                  v37 = 0x1C71C71C71C71C72 * ((v32 - v13) >> 3);
                if (0x8E38E38E38E38E39 * ((v32 - v13) >> 3) >= 0x1C71C71C71C71C7)
                  v38 = 0x38E38E38E38E38ELL;
                else
                  v38 = v37;
                if (v38)
                {
                  if (v38 > 0x38E38E38E38E38ELL)
                    goto LABEL_113;
                  v39 = (char *)operator new(72 * v38);
                }
                else
                {
                  v39 = 0;
                }
                v40 = &v39[8 * ((v14 - v13) >> 3)];
                *(_OWORD *)v40 = *(_OWORD *)v30;
                v41 = *(_OWORD *)(v30 + 16);
                v42 = *(_OWORD *)(v30 + 32);
                v43 = *(_OWORD *)(v30 + 48);
                *((_QWORD *)v40 + 8) = *(_QWORD *)(v30 + 64);
                *((_OWORD *)v40 + 2) = v42;
                *((_OWORD *)v40 + 3) = v43;
                *((_OWORD *)v40 + 1) = v41;
                if (v14 == v13)
                {
                  v48 = &v39[8 * ((v14 - v13) >> 3)];
                }
                else
                {
                  v44 = &v39[8 * ((v14 - v13) >> 3)];
                  do
                  {
                    *(_OWORD *)(v44 - 72) = *(_OWORD *)(v14 - 72);
                    v45 = *(_OWORD *)(v14 - 56);
                    v46 = *(_OWORD *)(v14 - 40);
                    v47 = *(_OWORD *)(v14 - 24);
                    v48 = v44 - 72;
                    *(v44 - 8) = *(v14 - 8);
                    *(_OWORD *)(v44 - 24) = v47;
                    *(_OWORD *)(v44 - 40) = v46;
                    *(_OWORD *)(v44 - 56) = v45;
                    v14 -= 72;
                    v44 -= 72;
                  }
                  while (v14 != v13);
                }
                v49 = &v39[72 * v38];
                v14 = v40 + 72;
                if (v13)
                  operator delete(v13);
                v13 = v48;
                v32 = v49;
                v5 = v97;
              }
              else
              {
                *(_OWORD *)v14 = *(_OWORD *)v30;
                v34 = *(_OWORD *)(v30 + 16);
                v35 = *(_OWORD *)(v30 + 32);
                v36 = *(_OWORD *)(v30 + 48);
                *((_QWORD *)v14 + 8) = *(_QWORD *)(v30 + 64);
                *((_OWORD *)v14 + 2) = v35;
                *((_OWORD *)v14 + 3) = v36;
                *((_OWORD *)v14 + 1) = v34;
                v14 += 72;
              }
              if ((v96 & 0xFF00000000) != 0 && *(_DWORD *)(v30 + 40) == 1 && *(_DWORD *)(v30 + 16) == (_DWORD)v96)
              {
                v51 = *(char **)(a4 + 56);
                v50 = *(_QWORD *)(a4 + 64);
                if ((unint64_t)v51 >= v50)
                {
                  v53 = *(char **)(a4 + 48);
                  v54 = 0xAAAAAAAAAAAAAAABLL * ((v51 - v53) >> 3) + 1;
                  if (v54 > 0xAAAAAAAAAAAAAAALL)
                    goto LABEL_112;
                  v55 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v50 - (_QWORD)v53) >> 3);
                  if (2 * v55 > v54)
                    v54 = 2 * v55;
                  if (v55 >= 0x555555555555555)
                    v56 = 0xAAAAAAAAAAAAAAALL;
                  else
                    v56 = v54;
                  if (v56 > 0xAAAAAAAAAAAAAAALL)
LABEL_113:
                    sub_1C4764EE4();
                  v57 = 3 * v56;
                  v58 = (char *)operator new(24 * v56);
                  v59 = &v58[8 * ((v51 - v53) >> 3)];
                  *(_DWORD *)v59 = *(_DWORD *)(v30 + 20);
                  *((_QWORD *)v59 + 1) = v30;
                  *((_QWORD *)v59 + 2) = v94;
                  if (v51 == v53)
                  {
                    v61 = &v58[8 * ((v51 - v53) >> 3)];
                  }
                  else
                  {
                    v60 = &v58[8 * ((v51 - v53) >> 3)];
                    do
                    {
                      v61 = v60 - 24;
                      v62 = *(_OWORD *)(v51 - 24);
                      *((_QWORD *)v60 - 1) = *((_QWORD *)v51 - 1);
                      *(_OWORD *)(v60 - 24) = v62;
                      v51 -= 24;
                      v60 -= 24;
                    }
                    while (v51 != v53);
                  }
                  v52 = v59 + 24;
                  *(_QWORD *)(a4 + 48) = v61;
                  *(_QWORD *)(a4 + 64) = &v58[8 * v57];
                  v5 = v97;
                  if (v53)
                    operator delete(v53);
                  a2 = __s1;
                }
                else
                {
                  *(_DWORD *)v51 = *(_DWORD *)(v30 + 20);
                  *((_QWORD *)v51 + 1) = v30;
                  *((_QWORD *)v51 + 2) = v94;
                  v52 = v51 + 24;
                }
                *(_QWORD *)(a4 + 56) = v52;
              }
            }
          }
          else if ((*(_QWORD *)(*(_QWORD *)v98 + ((v33 >> 3) & 0x1FFFFFF8)) & (1 << *(_DWORD *)(v30 + 16))) != 0)
          {
            goto LABEL_33;
          }
          v30 += 72;
          if (v30 == v31)
            goto LABEL_77;
        }
      }
      v32 = v91;
LABEL_77:
      v91 = v32;
      v63 = v92 + 104 * v93;
      v64 = *(_QWORD *)(v63 + 72);
      v65 = *(_QWORD *)(v63 + 80);
      while (v64 != v65)
      {
        v66 = *(unsigned int *)(v64 + 16);
        if ((v98 & 1) != 0)
        {
          if (((1 << v66) & ((unint64_t)v98 >> 1) & ~(-1 << ((unint64_t)v98 >> 58))) == 0)
            goto LABEL_102;
        }
        else if ((*(_QWORD *)(*(_QWORD *)v98 + ((v66 >> 3) & 0x1FFFFFF8)) & (1 << v66)) == 0)
        {
          goto LABEL_102;
        }
        if ((_DWORD)v66 == *(_DWORD *)(v64 + 20))
        {
          v68 = *(char **)(a4 + 80);
          v67 = *(_QWORD *)(a4 + 88);
          if ((unint64_t)v68 >= v67)
          {
            v73 = *(char **)(a4 + 72);
            v74 = 0x8E38E38E38E38E39 * ((v68 - v73) >> 3) + 1;
            if (v74 > 0x38E38E38E38E38ELL)
              goto LABEL_112;
            v75 = 0x8E38E38E38E38E39 * ((uint64_t)(v67 - (_QWORD)v73) >> 3);
            if (2 * v75 > v74)
              v74 = 2 * v75;
            if (v75 >= 0x1C71C71C71C71C7)
              v76 = 0x38E38E38E38E38ELL;
            else
              v76 = v74;
            if (v76)
            {
              if (v76 > 0x38E38E38E38E38ELL)
                goto LABEL_113;
              v77 = (char *)operator new(72 * v76);
            }
            else
            {
              v77 = 0;
            }
            v78 = &v77[8 * ((v68 - v73) >> 3)];
            *(_OWORD *)v78 = *(_OWORD *)v64;
            v79 = *(_OWORD *)(v64 + 16);
            v80 = *(_OWORD *)(v64 + 32);
            v81 = *(_OWORD *)(v64 + 48);
            *((_QWORD *)v78 + 8) = *(_QWORD *)(v64 + 64);
            *((_OWORD *)v78 + 2) = v80;
            *((_OWORD *)v78 + 3) = v81;
            *((_OWORD *)v78 + 1) = v79;
            v82 = v78;
            if (v68 != v73)
            {
              do
              {
                *(_OWORD *)(v82 - 72) = *(_OWORD *)(v68 - 72);
                v83 = *(_OWORD *)(v68 - 56);
                v84 = *(_OWORD *)(v68 - 40);
                v85 = *(_OWORD *)(v68 - 24);
                *(v82 - 8) = *(v68 - 8);
                *(_OWORD *)(v82 - 24) = v85;
                *(_OWORD *)(v82 - 40) = v84;
                *(_OWORD *)(v82 - 56) = v83;
                v82 -= 72;
                v68 -= 72;
              }
              while (v68 != v73);
              v68 = *(char **)(a4 + 72);
            }
            v86 = &v77[72 * v76];
            v72 = v78 + 72;
            *(_QWORD *)(a4 + 72) = v82;
            *(_QWORD *)(a4 + 88) = v86;
            a2 = __s1;
            if (v68)
              operator delete(v68);
          }
          else
          {
            *(_OWORD *)v68 = *(_OWORD *)v64;
            v69 = *(_OWORD *)(v64 + 16);
            v70 = *(_OWORD *)(v64 + 32);
            v71 = *(_OWORD *)(v64 + 48);
            *((_QWORD *)v68 + 8) = *(_QWORD *)(v64 + 64);
            *((_OWORD *)v68 + 2) = v70;
            *((_OWORD *)v68 + 3) = v71;
            *((_OWORD *)v68 + 1) = v69;
            v72 = v68 + 72;
          }
          *(_QWORD *)(a4 + 80) = v72;
        }
LABEL_102:
        v64 += 72;
      }
      sub_1C4914448((void ***)&v98);
      ImpreciseRecordIndicesForFilename = v90 + 1;
      if (v90 + 1 == v88)
      {
        v87 = *(void **)(a4 + 24);
        goto LABEL_107;
      }
    }
  }
  v87 = 0;
  v14 = 0;
  v13 = 0;
LABEL_107:
  sub_1C545ED70((uint64_t)&v98, (uint64_t)v13, 0x8E38E38E38E38E39 * ((v14 - v13) >> 3), v12);
  if (v87)
    operator delete(v87);
  *(_OWORD *)(a4 + 24) = v98;
  *(_QWORD *)(a4 + 40) = v99;
  if (v13)
    operator delete(v13);
}

uint64_t sub_1C545ECCC(const void *a1, uint64_t a2, _QWORD *a3)
{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  char v9;
  const void *v10;
  size_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v6 = sub_1C545FBC8(a3);
  if ((v6 & 0x100000000) != 0
    && ((v7 = v6, v8 = a3[3] + 24 * v6, v9 = *(_BYTE *)(v8 + 23), v9 >= 0)
      ? (v10 = (const void *)(a3[3] + 24 * v6))
      : (v10 = *(const void **)v8),
        v9 >= 0 ? (v11 = v9 & 0x7F) : (v11 = *(_QWORD *)(v8 + 8)),
        a2 == v11 && (!v11 || !memcmp(a1, v10, v11))))
  {
    v13 = v7 & 0x100000000;
    v14 = v7 & 0xFFFFFF00;
    v12 = v7;
  }
  else
  {
    v12 = 0;
    v13 = 0;
    v14 = 0;
  }
  return v13 | v12 | v14;
}

void sub_1C545ED70(uint64_t a1, uint64_t a2, unint64_t a3, __n128 a4)
{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  _OWORD *v9;
  uint64_t v10;
  _OWORD *v11;
  uint64_t v12;
  BOOL v13;
  BOOL v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char *v22;
  uint64_t v23;
  int8x16_t *v24;
  unsigned int v25;
  BOOL v26;
  unint64_t *v27;
  uint64_t v28;
  unint64_t *v29;
  unsigned int v30;
  unsigned int v31;
  uint64_t v33;
  unint64_t v34;
  uint64_t *v35;
  uint64_t *v36;
  int v37;
  _BOOL4 v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  int v44;
  BOOL v45;
  uint64_t v46;
  _BYTE v47[12];
  unint64_t v48;
  char v49;
  unint64_t v50;
  unsigned int *v51;
  void **v52;
  void *v53;
  uint64_t v54;
  _QWORD v55[10];

  v55[8] = *MEMORY[0x1E0C80C00];
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  v52 = (void **)a1;
  v53 = v55;
  a4.n128_u64[0] = 0x800000000;
  v54 = 0x800000000;
  v6 = a2 + 72 * a3;
  v7 = 126 - 2 * __clz(a3);
  if (a3)
    v8 = v7;
  else
    v8 = 0;
  sub_1C5461874(a2, v6, v8, 1, a4);
  if (a3)
  {
    v9 = (_OWORD *)a2;
    if (a3 != 1)
    {
      v10 = 0;
      v11 = (_OWORD *)a2;
      do
      {
        v12 = a2 + v10;
        v13 = *((_DWORD *)v11 + 6) == *(_DWORD *)(a2 + v10 + 96) && *((_DWORD *)v11 + 7) == *(_DWORD *)(a2 + v10 + 100);
        if (v13
          && (*((_DWORD *)v11 + 8) == *(_DWORD *)(v12 + 104)
            ? (v14 = *((_DWORD *)v11 + 9) == *(_DWORD *)(v12 + 108))
            : (v14 = 0),
              v14))
        {
          if (*(_DWORD *)(a2 + v10 + 112) == *((_DWORD *)v11 + 10))
            *((_QWORD *)v11 + 6) += *(_QWORD *)(a2 + v10 + 120);
          v9 = v11;
        }
        else
        {
          v9 = (_OWORD *)((char *)v11 + 72);
          if ((_OWORD *)v12 != v11)
          {
            *v9 = *(_OWORD *)(v12 + 72);
            v15 = *(_OWORD *)(v12 + 88);
            v16 = *(_OWORD *)(v12 + 104);
            v17 = *(_OWORD *)(v12 + 120);
            *((_BYTE *)v11 + 136) = *(_BYTE *)(v12 + 136);
            *(_OWORD *)((char *)v11 + 104) = v16;
            *(_OWORD *)((char *)v11 + 120) = v17;
            *(_OWORD *)((char *)v11 + 88) = v15;
          }
        }
        v10 += 72;
        v11 = v9;
      }
      while (72 * a3 - 72 != v10);
    }
    v18 = a3 + 0x71C71C71C71C71C7 * ((uint64_t)(v6 - (_QWORD)v9 - 72) >> 3);
    if (v18)
    {
      v19 = 0;
      v20 = a2;
      do
      {
        v21 = *(_QWORD *)(v20 + 24);
        v50 = v21;
        v51 = (unsigned int *)&v50;
        v22 = (char *)v53;
        if ((_DWORD)v54)
        {
          v23 = 8 * v54 - 8;
          v24 = (int8x16_t *)v53;
          while (1)
          {
            v25 = *(_DWORD *)(v24->i64[0] + 32);
            if (v25 <= v21)
            {
              v26 = v25 >= v21 && *(_DWORD *)(v24->i64[0] + 36) > HIDWORD(v21);
              if (!v26)
                break;
            }
            v24 = (int8x16_t *)((char *)v24 + 8);
            v23 -= 8;
            if (v24 == (int8x16_t *)((char *)v53 + 8 * v54))
            {
              v22 = (char *)v53 + 8 * v54;
              goto LABEL_52;
            }
          }
          v27 = (unint64_t *)((char *)v53 + 8 * v54 - 8);
          do
          {
            if (!v23)
            {
              v22 = (char *)v24;
              goto LABEL_52;
            }
            v28 = v23;
            v29 = v27;
            v30 = *(_DWORD *)(*v27 + 32);
            if (v30 > v21)
              break;
            v31 = *(_DWORD *)(*v27 + 36);
            v23 -= 8;
            --v27;
          }
          while (v30 < v21 || v31 <= HIDWORD(v21));
          v33 = (v28 >> 3) + 1;
          if (v28 < 17)
          {
LABEL_47:
            v36 = 0;
            v34 = 0;
          }
          else
          {
            if (v33 >= 0xFFFFFFFFFFFFFFFLL)
              v34 = 0xFFFFFFFFFFFFFFFLL;
            else
              v34 = (v28 >> 3) + 1;
            while (1)
            {
              v35 = (uint64_t *)operator new(8 * v34, MEMORY[0x1E0DE4E10]);
              if (v35)
                break;
              v26 = v34 > 1;
              v34 >>= 1;
              if (!v26)
                goto LABEL_47;
            }
            v36 = v35;
          }
          v22 = (char *)sub_1C546402C(v24, v29, &v51, v33, v36, v34);
          if (v36)
            operator delete(v36);
        }
LABEL_52:
        if (v22 != (char *)v53 + 8 * v54)
        {
          v48 = v50;
          v49 = 1;
          sub_1C5463C40((uint64_t)&v52, (uint64_t)&v48, (unint64_t)(v22 - (_BYTE *)v53) >> 3);
          v49 = 0;
        }
        v37 = *(_DWORD *)(v20 + 40);
        ++v19;
        if (v50 == *(_QWORD *)(v20 + 32))
        {
          v39 = v19 == v18 || v37 == 2;
          v40 = v20;
          if ((_DWORD)v54)
            v40 = *((_QWORD *)v53 + v54 - 1);
          sub_1C5463E58(v52, *(_DWORD *)(v40 + 40), *(_QWORD *)(v40 + 48), v50, v37 != 3, v39);
          if (v39 && (_DWORD)v54)
          {
            v41 = *((_QWORD *)v53 + v54 - 1);
            sub_1C5463E58(v52, *(_DWORD *)(v41 + 40), *(_QWORD *)(v41 + 48), v50, 0, 0);
          }
        }
        else
        {
          if (v19 == v18
            || ((v42 = a2 + 72 * v19, v44 = *(_DWORD *)(v42 + 24), v43 = *(_DWORD *)(v42 + 28), (_DWORD)v50 == v44)
              ? (v45 = HIDWORD(v50) == v43)
              : (v45 = 0),
                !v45))
          {
            sub_1C5463E58(v52, v37, *(_QWORD *)(v20 + 48), v50, v37 != 3, 0);
          }
          v46 = v54;
          if (v54 >= (unint64_t)HIDWORD(v54))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v53, (uint64_t)v55, v54 + 1, 8);
            v46 = v54;
          }
          *((_QWORD *)v53 + v46) = v20;
          LODWORD(v54) = v54 + 1;
        }
        v20 += 72;
      }
      while (v20 != a2 + 72 * v18);
    }
  }
  if ((_DWORD)v54)
  {
    v47[0] = 0;
    v47[8] = 0;
    sub_1C5463C40((uint64_t)&v52, (uint64_t)v47, 0);
  }
  if (v53 != v55)
    free(v53);
}

void llvm::coverage::CoverageMapping::getInstantiationGroups(uint64_t a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X2>, char **a4@<X8>)
{
  uint64_t **v5;
  uint64_t ImpreciseRecordIndicesForFilename;
  uint64_t v7;
  unsigned int *v8;
  unsigned int *v9;
  unsigned int v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t **v19;
  uint64_t **v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t *v23;
  uint64_t *v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t *v27;
  uint64_t *v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  char *v33;
  uint64_t *v34;
  uint64_t v35;
  char **v36;
  uint64_t **v37;
  uint64_t *v38;
  uint64_t *v39;
  uint64_t *v40;
  uint64_t *v41;
  unint64_t v42;
  uint64_t **v43;
  char *v44;
  uint64_t **v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t **v48;
  uint64_t v49;
  unint64_t v50;
  char *v51;
  char *v52;
  char *v53;
  uint64_t v54;
  char *v55;
  uint64_t **v56;
  uint64_t *v57;
  uint64_t *v58;
  uint64_t **v59;
  BOOL v60;
  uint64_t **v64;
  uint64_t *v65;
  uint64_t v66;

  v65 = 0;
  v66 = 0;
  v5 = &v65;
  v64 = &v65;
  ImpreciseRecordIndicesForFilename = llvm::coverage::CoverageMapping::getImpreciseRecordIndicesForFilename(a1, a2, a3);
  if (v7)
  {
    v8 = (unsigned int *)ImpreciseRecordIndicesForFilename;
    v9 = (unsigned int *)(ImpreciseRecordIndicesForFilename + 4 * v7);
    do
    {
      v10 = *v8;
      v11 = *(_QWORD *)(a1 + 24);
      v12 = (_QWORD *)(v11 + 104 * *v8);
      v13 = sub_1C545ECCC(a2, a3, v12);
      if ((v13 & 0xFF00000000) != 0)
      {
        v14 = v11 + 104 * v10;
        v15 = *(_QWORD *)(v14 + 48);
        v16 = *(_QWORD *)(v14 + 56);
        if (v15 != v16)
        {
          while (*(_DWORD *)(v15 + 16) != (_DWORD)v13)
          {
            v15 += 72;
            if (v15 == v16)
            {
              v15 = v16;
              break;
            }
          }
        }
        v17 = *(uint64_t **)(v15 + 24);
        v18 = v65;
        v19 = &v65;
        v20 = &v65;
        if (v65)
        {
          while (1)
          {
            while (1)
            {
              v20 = (uint64_t **)v18;
              v21 = *((_DWORD *)v18 + 8);
              if (v21 <= v17)
                break;
LABEL_12:
              v18 = *v20;
              v19 = v20;
              if (!*v20)
                goto LABEL_17;
            }
            if (v21 >= v17)
            {
              v22 = *((_DWORD *)v20 + 9);
              if (v22 > HIDWORD(v17))
                goto LABEL_12;
              if (v22 >= HIDWORD(v17))
                goto LABEL_20;
            }
            v18 = v20[1];
            if (!v18)
            {
              v19 = v20 + 1;
              break;
            }
          }
        }
LABEL_17:
        v23 = (uint64_t *)v20;
        v20 = (uint64_t **)operator new(0x40uLL);
        v20[4] = v17;
        v20[5] = 0;
        v20[6] = 0;
        v20[7] = 0;
        *v20 = 0;
        v20[1] = 0;
        v20[2] = v23;
        *v19 = (uint64_t *)v20;
        v24 = (uint64_t *)v20;
        if (*v64)
        {
          v64 = (uint64_t **)*v64;
          v24 = *v19;
        }
        sub_1C4768E74(v65, v24);
        ++v66;
LABEL_20:
        v26 = v20[6];
        v25 = v20[7];
        if (v26 >= v25)
        {
          v28 = v20[5];
          v29 = v26 - v28;
          v30 = v29 + 1;
          if ((unint64_t)(v29 + 1) >> 61)
LABEL_69:
            abort();
          v31 = (char *)v25 - (char *)v28;
          if (v31 >> 2 > v30)
            v30 = v31 >> 2;
          if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFF8)
            v32 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v32 = v30;
          if (v32)
          {
            if (v32 >> 61)
LABEL_70:
              sub_1C4764EE4();
            v33 = (char *)operator new(8 * v32);
          }
          else
          {
            v33 = 0;
          }
          v34 = (uint64_t *)&v33[8 * v29];
          *v34 = (uint64_t)v12;
          v27 = v34 + 1;
          if (v26 != v28)
          {
            do
            {
              v35 = *--v26;
              *--v34 = v35;
            }
            while (v26 != v28);
            v26 = v20[5];
          }
          v20[5] = v34;
          v20[6] = v27;
          v20[7] = (uint64_t *)&v33[8 * v32];
          if (v26)
            operator delete(v26);
        }
        else
        {
          *v26 = (uint64_t)v12;
          v27 = v26 + 1;
        }
        v20[6] = v27;
      }
      ++v8;
    }
    while (v8 != v9);
  }
  v36 = a4;
  v37 = v64;
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  if (v64 != &v65)
  {
    while (1)
    {
      v39 = v37[6];
      v38 = v37[7];
      v40 = v37[4];
      v41 = v37[5];
      v37[6] = 0;
      v37[7] = 0;
      v37[5] = 0;
      v43 = (uint64_t **)v36[1];
      v42 = (unint64_t)v36[2];
      if ((unint64_t)v43 >= v42)
        break;
      *v43 = v40;
      v43[1] = v41;
      v44 = (char *)(v43 + 4);
      v43[2] = v39;
      v43[3] = v38;
LABEL_59:
      v36[1] = v44;
      v58 = v37[1];
      if (v58)
      {
        do
        {
          v59 = (uint64_t **)v58;
          v58 = (uint64_t *)*v58;
        }
        while (v58);
      }
      else
      {
        do
        {
          v59 = (uint64_t **)v37[2];
          v60 = *v59 == (uint64_t *)v37;
          v37 = v59;
        }
        while (!v60);
      }
      v37 = v59;
      if (v59 == v5)
        goto LABEL_68;
    }
    v45 = (uint64_t **)*v36;
    v46 = ((char *)v43 - *v36) >> 5;
    v47 = v46 + 1;
    if ((unint64_t)(v46 + 1) >> 59)
      goto LABEL_69;
    v48 = v5;
    v49 = v42 - (_QWORD)v45;
    if (v49 >> 4 > v47)
      v47 = v49 >> 4;
    if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFE0)
      v50 = 0x7FFFFFFFFFFFFFFLL;
    else
      v50 = v47;
    if (v50 >> 59)
      goto LABEL_70;
    v51 = (char *)operator new(32 * v50);
    v52 = &v51[32 * v46];
    *(_QWORD *)v52 = v40;
    *((_QWORD *)v52 + 1) = v41;
    v53 = &v51[32 * v50];
    *((_QWORD *)v52 + 2) = v39;
    *((_QWORD *)v52 + 3) = v38;
    v44 = v52 + 32;
    if (v43 == v45)
    {
      *a4 = v52;
      a4[2] = v53;
      v5 = v48;
      if (!v45)
        goto LABEL_58;
    }
    else
    {
      v54 = 0;
      v5 = v48;
      do
      {
        v55 = &v52[v54 * 8];
        v56 = &v43[v54];
        *((_QWORD *)v55 - 4) = v43[v54 - 4];
        *((_QWORD *)v55 - 3) = 0;
        *((_QWORD *)v55 - 2) = 0;
        *((_QWORD *)v55 - 1) = 0;
        *(_OWORD *)(v55 - 24) = *(_OWORD *)&v43[v54 - 3];
        *((_QWORD *)v55 - 1) = v43[v54 - 1];
        *(v56 - 3) = 0;
        *(v56 - 2) = 0;
        *(v56 - 1) = 0;
        v54 -= 4;
      }
      while (&v43[v54] != v45);
      *a4 = &v52[v54 * 8];
      a4[1] = v44;
      a4[2] = v53;
      do
      {
        v57 = *(v43 - 3);
        if (v57)
        {
          *(v43 - 2) = v57;
          operator delete(v57);
        }
        v43 -= 4;
      }
      while (v43 != v45);
      if (!v45)
        goto LABEL_58;
    }
    operator delete(v45);
LABEL_58:
    v36 = a4;
    goto LABEL_59;
  }
LABEL_68:
  sub_1C5245168(v65);
}

void llvm::coverage::CoverageMapping::getCoverageForFunction(_QWORD *a1@<X1>, uint64_t a2@<X8>)
{
  unint64_t v4;
  int v5;
  uint64_t v6;
  char v7;
  const void *v8;
  size_t v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  __n128 v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  __int128 v19;
  __int128 v20;
  unint64_t v21;
  unint64_t v22;
  char *v23;
  char *v24;
  __int128 v25;
  __int128 v26;
  char *v27;
  __int128 v28;
  __int128 v29;
  char *v30;
  unint64_t v31;
  char *v32;
  char *v33;
  char *v34;
  char *v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  uint64_t v39;
  char *v40;
  char *v41;
  char *v42;
  char *v43;
  char *v44;
  __n128 *v45;
  __n128 *i;
  unint64_t v47;
  char *v48;
  __n128 v49;
  __n128 v50;
  char *v51;
  char *v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  char *v56;
  __n128 *v57;
  __n128 v58;
  __n128 v59;
  __n128 *v60;
  __n128 v61;
  __n128 v62;
  void **v63;
  uint64_t v64;
  _QWORD *v65;
  __int128 v66;
  uint64_t v67;

  v4 = sub_1C545FBC8(a1);
  if (!HIDWORD(v4))
  {
    *(_OWORD *)(a2 + 64) = 0u;
    *(_OWORD *)(a2 + 80) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    return;
  }
  v5 = v4;
  v6 = a1[3] + 24 * v4;
  v7 = *(_BYTE *)(v6 + 23);
  if (v7 >= 0)
    v8 = (const void *)(a1[3] + 24 * v4);
  else
    v8 = *(const void **)v6;
  if (v7 >= 0)
    v9 = v7 & 0x7F;
  else
    v9 = *(_QWORD *)(v6 + 8);
  if (v9 >= 0x7FFFFFFFFFFFFFF8)
LABEL_89:
    abort();
  if (v9 >= 0x17)
  {
    v11 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v9 | 7) != 0x17)
      v11 = v9 | 7;
    v12 = v11 + 1;
    v10 = operator new(v11 + 1);
    *(_QWORD *)(a2 + 8) = v9;
    *(_QWORD *)(a2 + 16) = v12 | 0x8000000000000000;
    *(_QWORD *)a2 = v10;
  }
  else
  {
    *(_BYTE *)(a2 + 23) = v9;
    v10 = (void *)a2;
    if (!v9)
      goto LABEL_17;
  }
  memmove(v10, v8, v9);
LABEL_17:
  *((_BYTE *)v10 + v9) = 0;
  v13 = 0uLL;
  *(_OWORD *)(a2 + 24) = 0u;
  *(_QWORD *)(a2 + 88) = 0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 72) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  v15 = a1[6];
  v14 = a1[7];
  v65 = a1;
  v63 = (void **)(a2 + 24);
  if (v15 == v14)
  {
    v17 = 0;
    v16 = 0;
  }
  else
  {
    v16 = 0;
    v17 = 0;
    v18 = 0;
    v64 = a1[7];
    do
    {
      if (*(_DWORD *)(v15 + 16) == v5)
      {
        if (v17 >= v18)
        {
          v21 = 0x8E38E38E38E38E39 * ((v17 - v16) >> 3) + 1;
          if (v21 > 0x38E38E38E38E38ELL)
            goto LABEL_89;
          if (0x1C71C71C71C71C72 * ((v18 - v16) >> 3) > v21)
            v21 = 0x1C71C71C71C71C72 * ((v18 - v16) >> 3);
          v22 = 0x8E38E38E38E38E39 * ((v18 - v16) >> 3) >= 0x1C71C71C71C71C7 ? 0x38E38E38E38E38ELL : v21;
          if (v22)
          {
            if (v22 > 0x38E38E38E38E38ELL)
              goto LABEL_90;
            v23 = (char *)operator new(72 * v22);
          }
          else
          {
            v23 = 0;
          }
          v24 = &v23[8 * ((v17 - v16) >> 3)];
          *(_OWORD *)v24 = *(_OWORD *)v15;
          v13 = *(__n128 *)(v15 + 16);
          v25 = *(_OWORD *)(v15 + 32);
          v26 = *(_OWORD *)(v15 + 48);
          *((_QWORD *)v24 + 8) = *(_QWORD *)(v15 + 64);
          *((_OWORD *)v24 + 2) = v25;
          *((_OWORD *)v24 + 3) = v26;
          *((__n128 *)v24 + 1) = v13;
          if (v17 == v16)
          {
            v30 = &v23[8 * ((v17 - v16) >> 3)];
          }
          else
          {
            v27 = &v23[8 * ((v17 - v16) >> 3)];
            do
            {
              *(_OWORD *)(v27 - 72) = *(_OWORD *)(v17 - 72);
              v13 = *(__n128 *)(v17 - 56);
              v28 = *(_OWORD *)(v17 - 40);
              v29 = *(_OWORD *)(v17 - 24);
              v30 = v27 - 72;
              *(v27 - 8) = *(v17 - 8);
              *(_OWORD *)(v27 - 24) = v29;
              *(_OWORD *)(v27 - 40) = v28;
              *(__n128 *)(v27 - 56) = v13;
              v17 -= 72;
              v27 -= 72;
            }
            while (v17 != v16);
          }
          v18 = &v23[72 * v22];
          v17 = v24 + 72;
          if (v16)
            operator delete(v16);
          v16 = v30;
        }
        else
        {
          *(_OWORD *)v17 = *(_OWORD *)v15;
          v13 = *(__n128 *)(v15 + 16);
          v19 = *(_OWORD *)(v15 + 32);
          v20 = *(_OWORD *)(v15 + 48);
          *((_QWORD *)v17 + 8) = *(_QWORD *)(v15 + 64);
          *((_OWORD *)v17 + 2) = v19;
          *((_OWORD *)v17 + 3) = v20;
          *((__n128 *)v17 + 1) = v13;
          v17 += 72;
        }
        if (*(_DWORD *)(v15 + 40) == 1 && *(_DWORD *)(v15 + 16) == v5)
        {
          v32 = *(char **)(a2 + 56);
          v31 = *(_QWORD *)(a2 + 64);
          if ((unint64_t)v32 >= v31)
          {
            v34 = v18;
            v35 = *(char **)(a2 + 48);
            v36 = 0xAAAAAAAAAAAAAAABLL * ((v32 - v35) >> 3) + 1;
            if (v36 > 0xAAAAAAAAAAAAAAALL)
              goto LABEL_89;
            v37 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v31 - (_QWORD)v35) >> 3);
            if (2 * v37 > v36)
              v36 = 2 * v37;
            if (v37 >= 0x555555555555555)
              v38 = 0xAAAAAAAAAAAAAAALL;
            else
              v38 = v36;
            if (v38 > 0xAAAAAAAAAAAAAAALL)
LABEL_90:
              sub_1C4764EE4();
            v39 = 3 * v38;
            v40 = (char *)operator new(24 * v38);
            v41 = &v40[8 * ((v32 - v35) >> 3)];
            *(_DWORD *)v41 = *(_DWORD *)(v15 + 20);
            *((_QWORD *)v41 + 1) = v15;
            *((_QWORD *)v41 + 2) = v65;
            if (v32 == v35)
            {
              v43 = &v40[8 * ((v32 - v35) >> 3)];
            }
            else
            {
              v42 = &v40[8 * ((v32 - v35) >> 3)];
              do
              {
                v43 = v42 - 24;
                v13 = *(__n128 *)(v32 - 24);
                *((_QWORD *)v42 - 1) = *((_QWORD *)v32 - 1);
                *(__n128 *)(v42 - 24) = v13;
                v32 -= 24;
                v42 -= 24;
              }
              while (v32 != v35);
            }
            v44 = &v40[8 * v39];
            v33 = v41 + 24;
            *(_QWORD *)(a2 + 48) = v43;
            *(_QWORD *)(a2 + 64) = v44;
            if (v35)
              operator delete(v35);
            v14 = v64;
            v18 = v34;
          }
          else
          {
            *(_DWORD *)v32 = *(_DWORD *)(v15 + 20);
            *((_QWORD *)v32 + 1) = v15;
            *((_QWORD *)v32 + 2) = v65;
            v33 = v32 + 24;
            v14 = v64;
          }
          *(_QWORD *)(a2 + 56) = v33;
        }
      }
      v15 += 72;
    }
    while (v15 != v14);
  }
  v45 = (__n128 *)v65[9];
  for (i = (__n128 *)v65[10]; v45 != i; v45 = (__n128 *)((char *)v45 + 72))
  {
    if (v45[1].n128_u32[0] == v5)
    {
      v48 = *(char **)(a2 + 80);
      v47 = *(_QWORD *)(a2 + 88);
      if ((unint64_t)v48 >= v47)
      {
        v52 = *(char **)(a2 + 72);
        v53 = 0x8E38E38E38E38E39 * ((v48 - v52) >> 3) + 1;
        if (v53 > 0x38E38E38E38E38ELL)
          goto LABEL_89;
        v54 = 0x8E38E38E38E38E39 * ((uint64_t)(v47 - (_QWORD)v52) >> 3);
        if (2 * v54 > v53)
          v53 = 2 * v54;
        if (v54 >= 0x1C71C71C71C71C7)
          v55 = 0x38E38E38E38E38ELL;
        else
          v55 = v53;
        if (v55)
        {
          if (v55 > 0x38E38E38E38E38ELL)
            goto LABEL_90;
          v56 = (char *)operator new(72 * v55);
        }
        else
        {
          v56 = 0;
        }
        v57 = (__n128 *)&v56[8 * ((v48 - v52) >> 3)];
        *v57 = *v45;
        v13 = v45[1];
        v58 = v45[2];
        v59 = v45[3];
        v57[4].n128_u64[0] = v45[4].n128_u64[0];
        v57[2] = v58;
        v57[3] = v59;
        v57[1] = v13;
        v60 = v57;
        if (v48 != v52)
        {
          do
          {
            *(__n128 *)((char *)v60 - 72) = *(__n128 *)(v48 - 72);
            v13 = *(__n128 *)(v48 - 56);
            v61 = *(__n128 *)(v48 - 40);
            v62 = *(__n128 *)(v48 - 24);
            v60[-1].n128_u8[8] = *(v48 - 8);
            *(__n128 *)((char *)v60 - 24) = v62;
            *(__n128 *)((char *)v60 - 40) = v61;
            *(__n128 *)((char *)v60 - 56) = v13;
            v60 = (__n128 *)((char *)v60 - 72);
            v48 -= 72;
          }
          while (v48 != v52);
          v48 = *(char **)(a2 + 72);
        }
        v51 = &v57[4].n128_i8[8];
        *(_QWORD *)(a2 + 72) = v60;
        *(_QWORD *)(a2 + 88) = &v56[72 * v55];
        if (v48)
          operator delete(v48);
      }
      else
      {
        *(__n128 *)v48 = *v45;
        v13 = v45[1];
        v49 = v45[2];
        v50 = v45[3];
        *((_QWORD *)v48 + 8) = v45[4].n128_u64[0];
        *((__n128 *)v48 + 2) = v49;
        *((__n128 *)v48 + 3) = v50;
        *((__n128 *)v48 + 1) = v13;
        v51 = v48 + 72;
      }
      *(_QWORD *)(a2 + 80) = v51;
    }
  }
  sub_1C545ED70((uint64_t)&v66, (uint64_t)v16, 0x8E38E38E38E38E39 * ((v17 - v16) >> 3), v13);
  if (*v63)
    operator delete(*v63);
  *(_OWORD *)(a2 + 24) = v66;
  *(_QWORD *)(a2 + 40) = v67;
  if (v16)
    operator delete(v16);
}

unint64_t sub_1C545FBC8(_QWORD *a1)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t i;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v12;
  void **v13;

  v2 = (uint64_t)(a1[4] - a1[3]) >> 3;
  v3 = -1431655765 * v2;
  if ((-1431655765 * v2) > 0x39)
  {
    v12 = operator new();
    v4 = sub_1C496F858(v12, v3, 1);
  }
  else
  {
    v4 = (0xAC00000000000000 * v2) | (2 * ~(-1 << v3)) | 1;
  }
  v13 = (void **)v4;
  v5 = a1[6];
  for (i = a1[7]; v5 != i; v5 += 72)
  {
    if (*(_DWORD *)(v5 + 40) == 1)
    {
      v7 = *(_DWORD *)(v5 + 20);
      if ((v4 & 1) != 0)
      {
        v4 = ((2 * ~((1 << v7) | (-1 << (v4 >> 58)))) | 0xFC00000000000000) & v4 | 1;
        v13 = (void **)v4;
      }
      else
      {
        *(_QWORD *)(*(_QWORD *)v4 + 8 * (v7 >> 6)) &= ~(1 << v7);
      }
    }
  }
  if ((v4 & 1) != 0)
  {
    v9 = __clz(__rbit64((v4 >> 1) & ~(-1 << (v4 >> 58))));
    if (((v4 >> 1) & ~(-1 << (v4 >> 58))) != 0)
      v8 = v9;
    else
      v8 = -1;
  }
  else
  {
    v8 = sub_1C476B7EC(v4);
  }
  sub_1C4914448(&v13);
  if (v8 == -1)
    v10 = 0;
  else
    v10 = v8;
  return v10 | ((unint64_t)(v8 != -1) << 32);
}

void llvm::coverage::CoverageMapping::getCoverageForExpansion(unsigned int *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v3;
  char v4;
  const void *v5;
  size_t v6;
  unsigned int *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  __n128 v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  char *v16;
  char *v17;
  __int128 v18;
  __int128 v19;
  unint64_t v20;
  unint64_t v21;
  char *v22;
  char *v23;
  __int128 v24;
  __int128 v25;
  char *v26;
  __int128 v27;
  __int128 v28;
  char *v29;
  uint64_t v30;
  unint64_t v31;
  char *v32;
  char *v33;
  char *v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  char *v41;
  char *v42;
  char *v43;
  __n128 *v44;
  __n128 *i;
  unint64_t v46;
  char *v47;
  __n128 v48;
  __n128 v49;
  char *v50;
  char *v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  char *v55;
  __n128 *v56;
  __n128 v57;
  __n128 v58;
  __n128 *v59;
  __n128 v60;
  __n128 v61;
  void **v62;
  unsigned int *v63;
  char *v64;
  __int128 v65;
  uint64_t v66;

  v3 = *(_QWORD *)(*((_QWORD *)a1 + 2) + 24) + 24 * *a1;
  v4 = *(_BYTE *)(v3 + 23);
  if (v4 >= 0)
    v5 = (const void *)(*(_QWORD *)(*((_QWORD *)a1 + 2) + 24) + 24 * *a1);
  else
    v5 = *(const void **)v3;
  if (v4 >= 0)
    v6 = v4 & 0x7F;
  else
    v6 = *(_QWORD *)(v3 + 8);
  if (v6 >= 0x7FFFFFFFFFFFFFF8)
LABEL_87:
    abort();
  v7 = a1;
  if (v6 >= 0x17)
  {
    v9 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17)
      v9 = v6 | 7;
    v10 = v9 + 1;
    v8 = operator new(v9 + 1);
    *(_QWORD *)(a2 + 8) = v6;
    *(_QWORD *)(a2 + 16) = v10 | 0x8000000000000000;
    *(_QWORD *)a2 = v8;
    goto LABEL_14;
  }
  *(_BYTE *)(a2 + 23) = v6;
  v8 = (void *)a2;
  if (v6)
LABEL_14:
    memmove(v8, v5, v6);
  *((_BYTE *)v8 + v6) = 0;
  v11 = 0uLL;
  *(_OWORD *)(a2 + 24) = 0u;
  *(_QWORD *)(a2 + 88) = 0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 72) = 0u;
  v62 = (void **)(a2 + 24);
  *(_OWORD *)(a2 + 40) = 0u;
  v12 = (_QWORD *)*((_QWORD *)v7 + 2);
  v13 = v12[6];
  v14 = v12[7];
  if (v13 == v14)
  {
    v16 = 0;
    v15 = 0;
  }
  else
  {
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v63 = v7;
    do
    {
      if (*(_DWORD *)(v13 + 16) == *v7)
      {
        if (v16 >= v17)
        {
          v20 = 0x8E38E38E38E38E39 * ((v16 - v15) >> 3) + 1;
          if (v20 > 0x38E38E38E38E38ELL)
            goto LABEL_87;
          if (0x1C71C71C71C71C72 * ((v17 - v15) >> 3) > v20)
            v20 = 0x1C71C71C71C71C72 * ((v17 - v15) >> 3);
          v21 = 0x8E38E38E38E38E39 * ((v17 - v15) >> 3) >= 0x1C71C71C71C71C7 ? 0x38E38E38E38E38ELL : v20;
          if (v21)
          {
            if (v21 > 0x38E38E38E38E38ELL)
              goto LABEL_88;
            v22 = (char *)operator new(72 * v21);
          }
          else
          {
            v22 = 0;
          }
          v23 = &v22[8 * ((v16 - v15) >> 3)];
          *(_OWORD *)v23 = *(_OWORD *)v13;
          v11 = *(__n128 *)(v13 + 16);
          v24 = *(_OWORD *)(v13 + 32);
          v25 = *(_OWORD *)(v13 + 48);
          *((_QWORD *)v23 + 8) = *(_QWORD *)(v13 + 64);
          *((_OWORD *)v23 + 2) = v24;
          *((_OWORD *)v23 + 3) = v25;
          *((__n128 *)v23 + 1) = v11;
          if (v16 == v15)
          {
            v29 = &v22[8 * ((v16 - v15) >> 3)];
          }
          else
          {
            v26 = &v22[8 * ((v16 - v15) >> 3)];
            do
            {
              *(_OWORD *)(v26 - 72) = *(_OWORD *)(v16 - 72);
              v11 = *(__n128 *)(v16 - 56);
              v27 = *(_OWORD *)(v16 - 40);
              v28 = *(_OWORD *)(v16 - 24);
              v29 = v26 - 72;
              *(v26 - 8) = *(v16 - 8);
              *(_OWORD *)(v26 - 24) = v28;
              *(_OWORD *)(v26 - 40) = v27;
              *(__n128 *)(v26 - 56) = v11;
              v16 -= 72;
              v26 -= 72;
            }
            while (v16 != v15);
          }
          v17 = &v22[72 * v21];
          v16 = v23 + 72;
          if (v15)
            operator delete(v15);
          v15 = v29;
        }
        else
        {
          *(_OWORD *)v16 = *(_OWORD *)v13;
          v11 = *(__n128 *)(v13 + 16);
          v18 = *(_OWORD *)(v13 + 32);
          v19 = *(_OWORD *)(v13 + 48);
          *((_QWORD *)v16 + 8) = *(_QWORD *)(v13 + 64);
          *((_OWORD *)v16 + 2) = v18;
          *((_OWORD *)v16 + 3) = v19;
          *((__n128 *)v16 + 1) = v11;
          v16 += 72;
        }
        if (*(_DWORD *)(v13 + 40) == 1 && *(_DWORD *)(v13 + 16) == *v7)
        {
          v30 = *((_QWORD *)v7 + 2);
          v32 = *(char **)(a2 + 56);
          v31 = *(_QWORD *)(a2 + 64);
          if ((unint64_t)v32 >= v31)
          {
            v64 = v17;
            v34 = *(char **)(a2 + 48);
            v35 = 0xAAAAAAAAAAAAAAABLL * ((v32 - v34) >> 3) + 1;
            if (v35 > 0xAAAAAAAAAAAAAAALL)
              goto LABEL_87;
            v36 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v31 - (_QWORD)v34) >> 3);
            if (2 * v36 > v35)
              v35 = 2 * v36;
            if (v36 >= 0x555555555555555)
              v37 = 0xAAAAAAAAAAAAAAALL;
            else
              v37 = v35;
            if (v37 > 0xAAAAAAAAAAAAAAALL)
LABEL_88:
              sub_1C4764EE4();
            v38 = v14;
            v39 = 3 * v37;
            v40 = (char *)operator new(24 * v37);
            v41 = &v40[8 * ((v32 - v34) >> 3)];
            *(_DWORD *)v41 = *(_DWORD *)(v13 + 20);
            *((_QWORD *)v41 + 1) = v13;
            *((_QWORD *)v41 + 2) = v30;
            if (v32 == v34)
            {
              v43 = &v40[8 * ((v32 - v34) >> 3)];
            }
            else
            {
              v42 = &v40[8 * ((v32 - v34) >> 3)];
              do
              {
                v43 = v42 - 24;
                v11 = *(__n128 *)(v32 - 24);
                *((_QWORD *)v42 - 1) = *((_QWORD *)v32 - 1);
                *(__n128 *)(v42 - 24) = v11;
                v32 -= 24;
                v42 -= 24;
              }
              while (v32 != v34);
            }
            v33 = v41 + 24;
            *(_QWORD *)(a2 + 48) = v43;
            *(_QWORD *)(a2 + 64) = &v40[8 * v39];
            if (v34)
              operator delete(v34);
            v14 = v38;
            v7 = v63;
            v17 = v64;
          }
          else
          {
            *(_DWORD *)v32 = *(_DWORD *)(v13 + 20);
            *((_QWORD *)v32 + 1) = v13;
            *((_QWORD *)v32 + 2) = v30;
            v33 = v32 + 24;
          }
          *(_QWORD *)(a2 + 56) = v33;
        }
      }
      v13 += 72;
    }
    while (v13 != v14);
    v12 = (_QWORD *)*((_QWORD *)v7 + 2);
  }
  v44 = (__n128 *)v12[9];
  for (i = (__n128 *)v12[10]; v44 != i; v44 = (__n128 *)((char *)v44 + 72))
  {
    if (v44[1].n128_u32[0] == *v7)
    {
      v47 = *(char **)(a2 + 80);
      v46 = *(_QWORD *)(a2 + 88);
      if ((unint64_t)v47 >= v46)
      {
        v51 = *(char **)(a2 + 72);
        v52 = 0x8E38E38E38E38E39 * ((v47 - v51) >> 3) + 1;
        if (v52 > 0x38E38E38E38E38ELL)
          goto LABEL_87;
        v53 = 0x8E38E38E38E38E39 * ((uint64_t)(v46 - (_QWORD)v51) >> 3);
        if (2 * v53 > v52)
          v52 = 2 * v53;
        if (v53 >= 0x1C71C71C71C71C7)
          v54 = 0x38E38E38E38E38ELL;
        else
          v54 = v52;
        if (v54)
        {
          if (v54 > 0x38E38E38E38E38ELL)
            goto LABEL_88;
          v55 = (char *)operator new(72 * v54);
        }
        else
        {
          v55 = 0;
        }
        v56 = (__n128 *)&v55[8 * ((v47 - v51) >> 3)];
        *v56 = *v44;
        v11 = v44[1];
        v57 = v44[2];
        v58 = v44[3];
        v56[4].n128_u64[0] = v44[4].n128_u64[0];
        v56[2] = v57;
        v56[3] = v58;
        v56[1] = v11;
        v59 = v56;
        if (v47 != v51)
        {
          do
          {
            *(__n128 *)((char *)v59 - 72) = *(__n128 *)(v47 - 72);
            v11 = *(__n128 *)(v47 - 56);
            v60 = *(__n128 *)(v47 - 40);
            v61 = *(__n128 *)(v47 - 24);
            v59[-1].n128_u8[8] = *(v47 - 8);
            *(__n128 *)((char *)v59 - 24) = v61;
            *(__n128 *)((char *)v59 - 40) = v60;
            *(__n128 *)((char *)v59 - 56) = v11;
            v59 = (__n128 *)((char *)v59 - 72);
            v47 -= 72;
          }
          while (v47 != v51);
          v47 = *(char **)(a2 + 72);
        }
        v50 = &v56[4].n128_i8[8];
        *(_QWORD *)(a2 + 72) = v59;
        *(_QWORD *)(a2 + 88) = &v55[72 * v54];
        if (v47)
          operator delete(v47);
      }
      else
      {
        *(__n128 *)v47 = *v44;
        v11 = v44[1];
        v48 = v44[2];
        v49 = v44[3];
        *((_QWORD *)v47 + 8) = v44[4].n128_u64[0];
        *((__n128 *)v47 + 2) = v48;
        *((__n128 *)v47 + 3) = v49;
        *((__n128 *)v47 + 1) = v11;
        v50 = v47 + 72;
      }
      *(_QWORD *)(a2 + 80) = v50;
    }
  }
  sub_1C545ED70((uint64_t)&v65, (uint64_t)v15, 0x8E38E38E38E38E39 * ((v16 - v15) >> 3), v11);
  if (*v62)
    operator delete(*v62);
  *(_OWORD *)(a2 + 24) = v65;
  *(_QWORD *)(a2 + 40) = v66;
  if (v15)
    operator delete(v15);
}

char *LLVMCreateCoverageMappingForArch(char *a1, char *a2, char *a3)
{
  char *v4;
  char *v5[2];

  v5[1] = *(char **)MEMORY[0x1E0C80C00];
  v4 = a3;
  v5[0] = a1;
  return LLVMCreateCoverageMappingAggregate(v5, 1, a2, &v4, 0, 0);
}

char *LLVMCreateCoverageMappingAggregateForArch(char **a1, uint64_t a2, char *a3, char **a4)
{
  return LLVMCreateCoverageMappingAggregate(a1, a2, a3, a4, 0, 0);
}

char *LLVMCreateCoverageMappingAggregate(char **a1, uint64_t a2, char *a3, char **a4, char **a5, int *a6)
{
  uint64_t v9;
  void *v10;
  uint64_t v12;
  char **v14;
  size_t v15;
  uint64_t v16;
  char *v17;
  char *v18;
  unsigned int *v19;
  unsigned int v20;
  unsigned int v21;
  char **v23;
  char **v24;
  BOOL v25;
  char *v26;
  char *v27;
  std::string *v28;
  int v29;
  char *v30;
  std::string v31;
  uint64_t v32;
  void *__p;
  uint64_t v34;
  uint64_t v35;
  void *v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  char *v40;
  char *v41;
  char v42;
  uint64_t v43;

  v9 = 0;
  v10 = 0;
  v43 = *MEMORY[0x1E0C80C00];
  v36 = 0;
  v37 = 0;
  v38 = 0;
  __p = 0;
  v34 = 0;
  v35 = 0;
  if (a2)
  {
    v12 = a2;
    v14 = a4;
    do
    {
      sub_1C546068C((char **)&v36, *a1);
      if (a4)
        sub_1C546068C((char **)&__p, *v14);
      ++v14;
      ++a1;
      --v12;
    }
    while (v12);
    v10 = v36;
    v9 = v37;
  }
  llvm::vfs::getRealFileSystem(&v32);
  if (a3)
    v15 = strlen(a3);
  else
    v15 = 0;
  v16 = v32;
  llvm::coverage::CoverageMapping::load((uint64_t)v10, (v9 - (uint64_t)v10) >> 4, (void **)a3, v15, v32, (uint64_t)__p, (v34 - (uint64_t)__p) >> 4, (uint64_t)&v41, (uint64_t)"", 0);
  if ((v42 & 1) != 0 && (v17 = v41, v41 = 0, v17))
  {
    if ((*(unsigned int (**)(char *, void *))(*(_QWORD *)v17 + 48))(v17, &llvm::ErrorList::ID))
    {
      v23 = (char **)*((_QWORD *)v17 + 1);
      v24 = (char **)*((_QWORD *)v17 + 2);
      if (v23 == v24)
      {
        v25 = 0;
        v26 = 0;
      }
      else
      {
        v26 = 0;
        v25 = 0;
        do
        {
          v40 = v26;
          v27 = *v23;
          *v23 = 0;
          if ((*(unsigned int (**)(char *, void *))(*(_QWORD *)v27 + 48))(v27, &llvm::coverage::CoverageMapError::ID))
          {
            v25 = *((_DWORD *)v27 + 2) == 2;
          }
          v39 = v27;
          sub_1C6174794(&v40, &v39, &v31);
          v26 = (char *)v31.__r_.__value_.__r.__words[0];
          v31.__r_.__value_.__r.__words[0] = 0;
          if (v39)
            (*(void (**)(char *))(*(_QWORD *)v39 + 8))(v39);
          if (v40)
            (*(void (**)(char *))(*(_QWORD *)v40 + 8))(v40);
          ++v23;
        }
        while (v23 != v24);
      }
      (*(void (**)(char *))(*(_QWORD *)v17 + 8))(v17);
      v17 = v26;
    }
    else if ((*(unsigned int (**)(char *, void *))(*(_QWORD *)v17 + 48))(v17, &llvm::coverage::CoverageMapError::ID))
    {
      v25 = *((_DWORD *)v17 + 2) == 2;
    }
    else
    {
      v25 = 0;
    }
    v30 = v17;
    sub_1C61D2548(&v30, &v31);
    if (v30)
      (*(void (**)(char *))(*(_QWORD *)v30 + 8))(v30);
    if (a5)
    {
      if ((v31.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v28 = &v31;
      else
        v28 = (std::string *)v31.__r_.__value_.__r.__words[0];
      *a5 = strdup((const char *)v28);
    }
    if (a6)
    {
      if (v25)
        v29 = 2;
      else
        v29 = 1;
      *a6 = v29;
    }
    if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v31.__r_.__value_.__l.__data_);
    v18 = 0;
  }
  else
  {
    if (a5)
      *a5 = 0;
    if (a6)
      *a6 = 0;
    v18 = v41;
  }
  v19 = (unsigned int *)(v16 + 8);
  do
  {
    v20 = __ldaxr(v19);
    v21 = v20 - 1;
  }
  while (__stlxr(v21, v19));
  if (!v21)
    (*(void (**)(uint64_t))(*(_QWORD *)v16 + 8))(v16);
  if (__p)
    operator delete(__p);
  if (v36)
    operator delete(v36);
  return v18;
}

void sub_1C546068C(char **a1, char *__s)
{
  unint64_t v4;
  char *v5;
  size_t v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  size_t v15;

  v5 = a1[1];
  v4 = (unint64_t)a1[2];
  if ((unint64_t)v5 >= v4)
  {
    v7 = *a1;
    v8 = (v5 - *a1) >> 4;
    v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 60)
      abort();
    v10 = v4 - (_QWORD)v7;
    if (v10 >> 3 > v9)
      v9 = v10 >> 3;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF0)
      v11 = 0xFFFFFFFFFFFFFFFLL;
    else
      v11 = v9;
    if (v11)
    {
      if (v11 >> 60)
        sub_1C4764EE4();
      v12 = (char *)operator new(16 * v11);
    }
    else
    {
      v12 = 0;
    }
    v14 = &v12[16 * v8];
    *(_QWORD *)v14 = __s;
    if (__s)
      v15 = strlen(__s);
    else
      v15 = 0;
    *((_QWORD *)v14 + 1) = v15;
    v13 = v14 + 16;
    if (v5 != v7)
    {
      do
      {
        *((_OWORD *)v14 - 1) = *((_OWORD *)v5 - 1);
        v14 -= 16;
        v5 -= 16;
      }
      while (v5 != v7);
      v5 = *a1;
    }
    *a1 = v14;
    a1[1] = v13;
    a1[2] = &v12[16 * v11];
    if (v5)
      operator delete(v5);
  }
  else
  {
    *(_QWORD *)v5 = __s;
    if (__s)
      v6 = strlen(__s);
    else
      v6 = 0;
    *((_QWORD *)v5 + 1) = v6;
    v13 = v5 + 16;
  }
  a1[1] = v13;
}

uint64_t LLVMDisposeCoverageMapping(uint64_t result)
{
  uint64_t v1;
  void **v2;

  if (result)
  {
    v1 = result;
    v2 = (void **)(result + 72);
    sub_1C5464DAC(&v2);
    sub_1C5464E24((uint64_t *)(v1 + 48));
    v2 = (void **)(v1 + 24);
    sub_1C5464E98(&v2);
    sub_1C5464F3C(v1);
    MEMORY[0x1CAA32FB4](*(_QWORD *)v1, 8);
    return MEMORY[0x1CAA32FC0](v1, 0x1020C40EA482D60);
  }
  return result;
}

uint64_t LLVMCreateCoverageFunctionRange(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  __int128 v5;
  __int128 v7;
  __int128 v8;
  uint64_t v9;

  v2 = operator new();
  v3 = *(_QWORD *)(a1 + 24);
  v4 = 0x4EC4EC4EC4EC4EC5 * ((*(_QWORD *)(a1 + 32) - v3) >> 3);
  *(_QWORD *)&v7 = v3;
  *((_QWORD *)&v7 + 1) = v4;
  *(_QWORD *)&v8 = v3;
  *((_QWORD *)&v8 + 1) = "";
  v9 = 0;
  llvm::coverage::FunctionRecordIterator::skipOtherFiles((llvm::coverage::FunctionRecordIterator *)&v7);
  v5 = v8;
  *(_OWORD *)v2 = v7;
  *(_OWORD *)(v2 + 16) = v5;
  *(_QWORD *)(v2 + 32) = v9;
  return v2 | 4;
}

uint64_t LLVMCreateCoverageFunctionRangeForFile(uint64_t a1, const char *a2)
{
  uint64_t v4;
  size_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v10;
  __int128 v11;
  size_t v12;

  v4 = operator new();
  if (a2)
    v5 = strlen(a2);
  else
    v5 = 0;
  v6 = *(_QWORD *)(a1 + 24);
  v7 = 0x4EC4EC4EC4EC4EC5 * ((*(_QWORD *)(a1 + 32) - v6) >> 3);
  *(_QWORD *)&v10 = v6;
  *((_QWORD *)&v10 + 1) = v7;
  *(_QWORD *)&v11 = v6;
  *((_QWORD *)&v11 + 1) = a2;
  v12 = v5;
  llvm::coverage::FunctionRecordIterator::skipOtherFiles((llvm::coverage::FunctionRecordIterator *)&v10);
  v8 = v11;
  *(_OWORD *)v4 = v10;
  *(_OWORD *)(v4 + 16) = v8;
  *(_QWORD *)(v4 + 32) = v12;
  return v4 | 4;
}

unint64_t LLVMDisposeCoverageFunctionRange(unint64_t result)
{
  if (result >= 8 && (result & 0xFFFFFFFFFFFFFFF8) != 0)
    JUMPOUT(0x1CAA32FC0);
  return result;
}

uint64_t LLVMGetNextCoverageFunction(uint64_t a1, uint64_t a2)
{
  llvm::coverage::FunctionRecordIterator *v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v8[5];

  v2 = (llvm::coverage::FunctionRecordIterator *)(a2 & 0xFFFFFFFFFFFFFFF8);
  if ((a2 & 4) != 0)
  {
    v5 = *(_QWORD *)(a1 + 24);
    v6 = 0x4EC4EC4EC4EC4EC5 * ((*(_QWORD *)(a1 + 32) - v5) >> 3);
    v8[0] = v5;
    v8[1] = v6;
    v8[2] = v5;
    v8[3] = "";
    v8[4] = 0;
    llvm::coverage::FunctionRecordIterator::skipOtherFiles((llvm::coverage::FunctionRecordIterator *)v8);
    v4 = *((_QWORD *)v2 + 2);
    if (v4 || *((_QWORD *)v2 + 4))
    {
      *((_QWORD *)v2 + 2) = v4 + 104;
      llvm::coverage::FunctionRecordIterator::skipOtherFiles(v2);
      return v4;
    }
    return 0;
  }
  v3 = *(unsigned int *)v2;
  if (*((_QWORD *)v2 + 2) <= v3)
    return 0;
  *(_DWORD *)v2 = v3 + 1;
  return *(_QWORD *)(*((_QWORD *)v2 + 1) + 8 * v3);
}

char *LLVMGetCoverageFunctionName(char *result)
{
  if (result[23] < 0)
    return *(char **)result;
  return result;
}

uint64_t LLVMGetCoverageFunctionExecutionCount(uint64_t a1)
{
  return *(_QWORD *)(a1 + 96);
}

uint64_t LLVMCreateCoverageDataForFile(uint64_t a1, char *a2)
{
  uint64_t v4;
  size_t v5;

  v4 = operator new();
  if (a2)
    v5 = strlen(a2);
  else
    v5 = 0;
  llvm::coverage::CoverageMapping::getCoverageForFile(a1, a2, v5, v4);
  return v4;
}

uint64_t LLVMCreateCoverageDataForFunction(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;

  v3 = operator new();
  llvm::coverage::CoverageMapping::getCoverageForFunction(a2, v3);
  return v3;
}

uint64_t LLVMDisposeCoverageData(uint64_t result)
{
  uint64_t v1;
  void *v2;
  void *v3;
  void *v4;

  if (result)
  {
    v1 = result;
    v2 = *(void **)(result + 72);
    if (v2)
    {
      *(_QWORD *)(v1 + 80) = v2;
      operator delete(v2);
    }
    v3 = *(void **)(v1 + 48);
    if (v3)
    {
      *(_QWORD *)(v1 + 56) = v3;
      operator delete(v3);
    }
    v4 = *(void **)(v1 + 24);
    if (v4)
    {
      *(_QWORD *)(v1 + 32) = v4;
      operator delete(v4);
    }
    if (*(char *)(v1 + 23) < 0)
      operator delete(*(void **)v1);
    JUMPOUT(0x1CAA32FC0);
  }
  return result;
}

uint64_t LLVMCreateCoverageIterator(uint64_t a1, int a2)
{
  uint64_t v4;
  int *v5;

  v4 = operator new();
  v5 = *(int **)(a1 + 24);
  if (!a2)
    a2 = *v5;
  *(_QWORD *)v4 = a1;
  *(_QWORD *)(v4 + 8) = 0;
  *(_QWORD *)(v4 + 16) = v5;
  *(_BYTE *)(v4 + 24) = 0;
  *(_DWORD *)(v4 + 28) = a2;
  *(_QWORD *)(v4 + 32) = v4 + 48;
  *(_QWORD *)(v4 + 40) = 0x400000000;
  *(_QWORD *)(v4 + 96) = 0;
  *(_QWORD *)(v4 + 104) = 0;
  return llvm::coverage::LineCoverageIterator::operator++(v4);
}

uint64_t LLVMDisposeCoverageIterator(uint64_t result)
{
  uint64_t v1;
  void *v2;

  if (result)
  {
    v1 = result;
    v2 = *(void **)(result + 32);
    if (v2 != (void *)(v1 + 48))
      free(v2);
    JUMPOUT(0x1CAA32FC0);
  }
  return result;
}

uint64_t LLVMGetCoverageIteratorIsMapped(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 89);
}

uint64_t LLVMGetCoverageIteratorLine(uint64_t a1)
{
  return *(unsigned int *)(a1 + 92);
}

uint64_t LLVMGetCoverageIteratorExecutionCount(uint64_t a1)
{
  return *(_QWORD *)(a1 + 80);
}

uint64_t LLVMGetCoverageIteratorWrappedSegment(uint64_t a1)
{
  return *(_QWORD *)(a1 + 112);
}

uint64_t LLVMGetCoverageIteratorLineSegments(uint64_t a1, _DWORD *a2)
{
  uint64_t result;

  if (!a2)
    return 0;
  result = *(_QWORD *)(a1 + 96);
  *a2 = *(_QWORD *)(a1 + 104);
  return result;
}

BOOL LLVMAdvanceCoverageIterator(uint64_t a1)
{
  __int128 v2;
  __int128 v3;
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  _BOOL8 v7;
  __int128 v9;
  void *v10[2];
  _OWORD v11[4];
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  void *v15[2];
  _OWORD v16[4];
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v2 = *(_OWORD *)(a1 + 16);
  v13 = *(_OWORD *)a1;
  v14 = v2;
  v15[0] = v16;
  v15[1] = (void *)0x400000000;
  if (*(_DWORD *)(a1 + 40))
    sub_1C49F5C14((uint64_t)v15, a1 + 32);
  v3 = *(_OWORD *)(a1 + 96);
  v16[2] = *(_OWORD *)(a1 + 80);
  v16[3] = v3;
  v17 = *(_QWORD *)(a1 + 112);
  v4 = *(_QWORD *)a1;
  v5 = *(_QWORD *)(*(_QWORD *)a1 + 32);
  *(_QWORD *)&v14 = v5;
  BYTE8(v14) = 1;
  if (v4 == (_QWORD)v13 && *(_QWORD *)(a1 + 16) == v5 && *(_BYTE *)(a1 + 24))
  {
    v7 = 0;
  }
  else
  {
    llvm::coverage::LineCoverageIterator::operator++(a1);
    v9 = *(_OWORD *)a1;
    v10[0] = v11;
    v10[1] = (void *)0x400000000;
    if (*(_DWORD *)(a1 + 40))
      sub_1C49F5C14((uint64_t)v10, a1 + 32);
    v6 = *(_OWORD *)(a1 + 96);
    v11[2] = *(_OWORD *)(a1 + 80);
    v11[3] = v6;
    v12 = *(_QWORD *)(a1 + 112);
    v7 = 1;
    if (*(_QWORD *)a1 == (_QWORD)v9 && *(_QWORD *)(a1 + 16) == *(_QWORD *)(*(_QWORD *)a1 + 32))
      v7 = *(_BYTE *)(a1 + 24) == 0;
    if (v10[0] != v11)
      free(v10[0]);
  }
  if (v15[0] != v16)
    free(v15[0]);
  return v7;
}

uint64_t llvm::coverage::LineCoverageIterator::operator++(uint64_t a1)
{
  _DWORD *v2;
  uint64_t v3;
  unsigned int v4;
  int v5;
  __int128 v6;
  _OWORD v8[2];
  uint64_t v9;

  v2 = *(_DWORD **)(a1 + 16);
  if (v2 == *(_DWORD **)(*(_QWORD *)a1 + 32))
  {
    *(_QWORD *)(a1 + 112) = 0;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(_BYTE *)(a1 + 24) = 1;
  }
  else
  {
    v3 = *(unsigned int *)(a1 + 40);
    if ((_DWORD)v3)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v3 - 8);
    v4 = 0;
    *(_DWORD *)(a1 + 40) = 0;
    while (1)
    {
      v5 = *(_DWORD *)(a1 + 28);
      if (*v2 != v5)
        break;
      *(_QWORD *)(a1 + 16) = v2 + 6;
      if (v4 >= *(_DWORD *)(a1 + 44))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 32, a1 + 48, v4 + 1, 8);
        v4 = *(_DWORD *)(a1 + 40);
      }
      *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v4) = v2;
      v4 = *(_DWORD *)(a1 + 40) + 1;
      *(_DWORD *)(a1 + 40) = v4;
      v2 = *(_DWORD **)(a1 + 16);
      if (v2 == *(_DWORD **)(*(_QWORD *)a1 + 32))
      {
        v5 = *(_DWORD *)(a1 + 28);
        break;
      }
    }
    llvm::coverage::LineCoverageStats::LineCoverageStats((uint64_t)v8, *(uint64_t **)(a1 + 32), v4, *(_QWORD *)(a1 + 8), v5);
    v6 = v8[1];
    *(_OWORD *)(a1 + 80) = v8[0];
    *(_OWORD *)(a1 + 96) = v6;
    *(_QWORD *)(a1 + 112) = v9;
    ++*(_DWORD *)(a1 + 28);
  }
  return a1;
}

uint64_t LLVMGetFirstCoverageSegment(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 24) == *(_QWORD *)(a1 + 32))
    return 0;
  else
    return *(_QWORD *)(a1 + 24);
}

uint64_t LLVMGetNextCoverageSegment(uint64_t a1, uint64_t a2)
{
  if (0xAAAAAAAAAAAAAAABLL * ((a2 + 24 - *(_QWORD *)(a1 + 24)) >> 3) >= 0xAAAAAAAAAAAAAAABLL
                                                                       * ((uint64_t)(*(_QWORD *)(a1 + 32)
                                                                                  - *(_QWORD *)(a1 + 24)) >> 3))
    return 0;
  else
    return a2 + 24;
}

uint64_t LLVMGetCoverageSegmentLine(unsigned int *a1)
{
  return *a1;
}

uint64_t LLVMGetCoverageSegmentColumn(uint64_t a1)
{
  return *(unsigned int *)(a1 + 4);
}

uint64_t LLVMGetCoverageSegmentCount(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t LLVMGetCoverageSegmentHasCount(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 16);
}

uint64_t LLVMGetCoverageSegmentIsRegionEntry(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 17);
}

uint64_t LLVMGetCoverageSegmentIsGapRegion(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 18);
}

uint64_t LLVMCreateCoverageInstantiationGroupRangeForFile(uint64_t a1, char *a2)
{
  uint64_t v4;
  size_t v5;
  __int128 v7;
  uint64_t v8;
  void **v9;

  v4 = operator new();
  if (a2)
    v5 = strlen(a2);
  else
    v5 = 0;
  llvm::coverage::CoverageMapping::getInstantiationGroups(a1, a2, v5, (char **)&v7);
  *(_DWORD *)v4 = 0;
  *(_OWORD *)(v4 + 8) = v7;
  *(_QWORD *)(v4 + 24) = v8;
  v7 = 0uLL;
  v8 = 0;
  v9 = (void **)&v7;
  sub_1C52E1318(&v9);
  return v4;
}

uint64_t LLVMDisposeCoverageInstantiationGroupRange(uint64_t result)
{
  void **v1;

  if (result)
  {
    v1 = (void **)(result + 8);
    sub_1C52E1318(&v1);
    JUMPOUT(0x1CAA32FC0);
  }
  return result;
}

uint64_t LLVMGetNextCoverageInstantiationGroup(unsigned int *a1)
{
  unint64_t v1;
  uint64_t v2;

  v1 = *a1;
  v2 = *((_QWORD *)a1 + 1);
  if (v1 >= (*((_QWORD *)a1 + 2) - v2) >> 5)
    return 0;
  *a1 = v1 + 1;
  return v2 + 32 * v1;
}

uint64_t LLVMGetCoverageInstantiationGroupSize(uint64_t a1)
{
  return (uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8)) >> 3;
}

unsigned __int8 *LLVMGetCoverageInstantiationGroupName(uint64_t a1)
{
  unsigned __int8 **v1;
  unint64_t v2;
  unsigned __int8 *v3;
  unsigned __int8 v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned __int8 *v8;
  signed __int8 v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;

  v1 = *(unsigned __int8 ***)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16) - (_QWORD)v1;
  v3 = *v1;
  v4 = (*v1)[23];
  if ((v2 & 0x7FFFFFFF0) != 0)
  {
    if ((v4 & 0x80u) == 0)
      v5 = v4 & 0x7F;
    else
      v5 = *((_QWORD *)v3 + 1);
    v6 = (v2 >> 3);
    v7 = 1;
    while (1)
    {
      v8 = v1[v7];
      v9 = v8[23];
      v10 = v9 & 0x7F;
      v11 = v9 >= 0 ? v9 & 0x7F : *((_QWORD *)v8 + 1);
      if (v11 != v5)
        return 0;
      v12 = *(unsigned __int8 **)v3;
      if ((v4 & 0x80u) == 0)
        v13 = v3;
      else
        v13 = *(unsigned __int8 **)v3;
      if ((v8[23] & 0x80) != 0)
      {
        if (memcmp(*(const void **)v8, v13, *((_QWORD *)v8 + 1)))
          return 0;
      }
      else if ((v9 & 0x7F) != 0)
      {
        while (*v8 == *v13)
        {
          ++v8;
          ++v13;
          if (!--v10)
            goto LABEL_19;
        }
        return 0;
      }
LABEL_19:
      if (++v7 == v6)
        goto LABEL_23;
    }
  }
  else
  {
    v12 = *(unsigned __int8 **)v3;
LABEL_23:
    if ((v4 & 0x80u) == 0)
      return v3;
    else
      return v12;
  }
}

uint64_t LLVMGetCoverageInstantiationGroupLine(unsigned int *a1)
{
  return *a1;
}

uint64_t LLVMGetCoverageInstantiationGroupColumn(uint64_t a1)
{
  return *(unsigned int *)(a1 + 4);
}

uint64_t LLVMGetCoverageInstantiationGroupTotalExecutionCount(uint64_t a1)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t result;
  uint64_t v4;

  v1 = *(uint64_t **)(a1 + 8);
  v2 = *(uint64_t **)(a1 + 16);
  if (v1 == v2)
    return 0;
  result = 0;
  do
  {
    v4 = *v1++;
    result += *(_QWORD *)(v4 + 96);
  }
  while (v1 != v2);
  return result;
}

unint64_t LLVMCreateCoverageFunctionRangeForInstantiationGroup(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = operator new();
  v3 = *(_QWORD *)(a1 + 8);
  v4 = (*(_QWORD *)(a1 + 16) - v3) >> 3;
  *(_DWORD *)v2 = 0;
  *(_QWORD *)(v2 + 8) = v3;
  *(_QWORD *)(v2 + 16) = v4;
  return v2 & 0xFFFFFFFFFFFFFFFBLL;
}

uint64_t llvm::coverage::LineCoverageStats::LineCoverageStats(uint64_t result, uint64_t *a2, unint64_t a3, uint64_t a4, int a5)
{
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  _BYTE *v8;
  int v9;
  int v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;

  *(_QWORD *)result = 0;
  *(_DWORD *)(result + 12) = a5;
  *(_QWORD *)(result + 16) = a2;
  *(_QWORD *)(result + 24) = a3;
  *(_QWORD *)(result + 32) = a4;
  if (!a3)
  {
    v6 = 0;
LABEL_13:
    *(_BYTE *)(result + 8) = v6 > 1;
    goto LABEL_14;
  }
  v5 = 0;
  v6 = 0;
  v7 = 1;
  do
  {
    v8 = (_BYTE *)a2[v5];
    v9 = !v8[18] && v8[16] && v8[17] != 0;
    v6 += v9;
    if (a3 <= v7)
      break;
    v5 = v7++;
  }
  while (v6 < 2);
  if (*(_BYTE *)(*a2 + 16))
    goto LABEL_13;
  v10 = *(unsigned __int8 *)(*a2 + 17);
  *(_BYTE *)(result + 8) = v6 > 1;
  if (v10)
  {
    *(_BYTE *)(result + 9) = 0;
    return result;
  }
LABEL_14:
  if (a4)
  {
    if (!*(_BYTE *)(a4 + 16))
    {
      *(_BYTE *)(result + 9) = v6 != 0;
      if (!v6)
        return result;
      v11 = *(_QWORD *)(a4 + 8);
      *(_QWORD *)result = v11;
      if (!a3)
        return result;
      goto LABEL_21;
    }
    *(_BYTE *)(result + 9) = 1;
    v11 = *(_QWORD *)(a4 + 8);
    *(_QWORD *)result = v11;
    if (!v6)
      return result;
  }
  else
  {
    *(_BYTE *)(result + 9) = v6 != 0;
    if (!v6)
      return result;
    v11 = 0;
  }
  if (!a3)
    return result;
LABEL_21:
  v12 = 8 * a3;
  do
  {
    v13 = *a2;
    if (!*(_BYTE *)(*a2 + 18) && *(_BYTE *)(v13 + 16) && *(_BYTE *)(v13 + 17))
    {
      v14 = *(_QWORD *)(v13 + 8);
      if (v11 <= v14)
        v11 = v14;
      *(_QWORD *)result = v11;
    }
    ++a2;
    v12 -= 8;
  }
  while (v12);
  return result;
}

void sub_1C54613D0(uint64_t a1, int a2)
{
  __asm { BR              X10 }
}

void sub_1C54613FC()
{
  char *v0;

  v0[23] = 7;
  strcpy(v0, "Success");
}

unint64_t llvm::coverage::coveragemap_category(llvm::coverage *this)
{
  if (!atomic_load(qword_1EF8F2FB0))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EF8F2FB0, (void *(*)(void))sub_1C54660B0, (void (*)(void *))sub_1C54660E4);
  return qword_1EF8F2FB0[0];
}

void sub_1C54615CC(uint64_t a1, llvm::raw_ostream *a2)
{
  void **v3;
  size_t v4;
  void *__p[2];
  char v6;

  (*(void (**)(void **__return_ptr))(*(_QWORD *)a1 + 24))(__p);
  if (v6 >= 0)
    v3 = __p;
  else
    v3 = (void **)__p[0];
  if (v6 >= 0)
    v4 = v6 & 0x7F;
  else
    v4 = (size_t)__p[1];
  llvm::raw_ostream::write(a2, (const char *)v3, v4);
  if (v6 < 0)
    operator delete(__p[0]);
}

_QWORD **sub_1C5461638@<X0>(_QWORD **result@<X0>, _DWORD **a2@<X1>, char **a3@<X8>)
{
  _QWORD *v4;
  char **v6;
  char **v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;

  v4 = *result;
  if (*result)
  {
    *result = 0;
    if ((*(unsigned int (**)(_QWORD *, void *))(*v4 + 48))(v4, &llvm::ErrorList::ID))
    {
      *a3 = 0;
      v6 = (char **)v4[1];
      v7 = (char **)v4[2];
      if (v6 != v7)
      {
        v8 = 0;
        do
        {
          v11 = v8;
          v9 = *v6;
          *v6 = 0;
          if ((*(unsigned int (**)(char *, void *))(*(_QWORD *)v9 + 48))(v9, &llvm::InstrProfError::ID))
          {
            **a2 = *((_DWORD *)v9 + 2);
            (*(void (**)(char *))(*(_QWORD *)v9 + 8))(v9);
            v9 = 0;
          }
          v10 = v9;
          sub_1C6174794(&v11, &v10, &v12);
          v8 = v12;
          *a3 = v12;
          v12 = 0;
          if (v10)
            (*(void (**)(char *))(*(_QWORD *)v10 + 8))(v10);
          if (v11)
            (*(void (**)(char *))(*(_QWORD *)v11 + 8))(v11);
          ++v6;
        }
        while (v6 != v7);
      }
      return (_QWORD **)(*(uint64_t (**)(_QWORD *))(*v4 + 8))(v4);
    }
    else
    {
      result = (_QWORD **)(*(uint64_t (**)(_QWORD *, void *))(*v4 + 48))(v4, &llvm::InstrProfError::ID);
      if ((_DWORD)result)
      {
        **a2 = *((_DWORD *)v4 + 2);
        *a3 = 0;
        return (_QWORD **)(*(uint64_t (**)(_QWORD *))(*v4 + 8))(v4);
      }
      else
      {
        *a3 = (char *)v4;
      }
    }
  }
  else
  {
    *a3 = 0;
  }
  return result;
}

uint64_t sub_1C54617C8(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  _DWORD *v5;
  int v6;
  uint64_t v7;

  result = (*(uint64_t (**)(_QWORD, void *))(*(_QWORD *)*a2 + 48))(*a2, &llvm::coverage::CoverageMapError::ID);
  v5 = (_DWORD *)*a2;
  *a2 = 0;
  if ((_DWORD)result)
  {
    v6 = v5[2];
    if (v6 == 2)
    {
      v7 = 0;
    }
    else
    {
      v7 = operator new();
      *(_QWORD *)v7 = &off_1E8169028;
      *(_DWORD *)(v7 + 8) = v6;
    }
    *a1 = v7;
    return (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v5 + 8))(v5);
  }
  else
  {
    *a1 = (uint64_t)v5;
  }
  return result;
}

__n128 sub_1C5461874(uint64_t a1, unint64_t a2, uint64_t a3, char a4, __n128 result)
{
  __n128 *v9;
  unint64_t i;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  uint64_t v29;
  unsigned int v30;
  unsigned int v31;
  int v32;
  uint64_t v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v38;
  unsigned int v39;
  BOOL v41;
  unint64_t v42;
  _DWORD *j;
  unsigned int v44;
  unsigned int v45;
  unsigned int v48;
  unsigned int v49;
  unsigned int v52;
  unsigned int v53;
  BOOL v55;
  unsigned int v56;
  unsigned int v57;
  _DWORD *v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  unsigned int v65;
  unsigned int v66;
  unsigned int v69;
  unsigned int v70;
  unsigned int v73;
  unsigned int v74;
  unsigned int v77;
  unsigned int v78;
  _OWORD *v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  BOOL v85;
  int v86;
  unsigned int v87;
  unsigned int v88;
  unsigned int v89;
  unsigned int v90;
  unsigned int v91;
  unsigned int v92;
  unsigned int v95;
  unsigned int v96;
  unsigned int v99;
  unsigned int v100;
  unsigned int v103;
  unsigned int v104;
  unsigned int *v107;
  unsigned int *v108;
  unsigned int v109;
  unsigned int v110;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  unsigned int v115;
  unsigned int v116;
  unsigned int v119;
  unsigned int v120;
  unsigned int v123;
  unsigned int v124;
  unsigned int v127;
  unsigned int v128;
  _OWORD *v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  unsigned int v135;
  unsigned int v136;
  unsigned int v137;
  unsigned int v138;
  __n128 *v140;
  __n128 *v141;
  __n128 *v142;
  unsigned int v143;
  unsigned int v144;
  unsigned int v145;
  unsigned int v146;
  uint64_t v148;
  BOOL v150;
  uint64_t v151;
  unint64_t v152;
  unint64_t v153;
  unsigned __int32 v154;
  unsigned __int32 v155;
  unsigned int v158;
  unsigned int v159;
  unsigned int v160;
  unsigned int v161;
  unint64_t v164;
  int v165;
  __int128 v166;
  __int128 v167;
  unint64_t v168;
  uint64_t v169;
  uint64_t v170;
  unsigned __int32 v171;
  unsigned __int32 v172;
  unsigned int v175;
  unsigned int v176;
  __int128 v179;
  __int128 v180;
  int64_t v181;
  int64_t v182;
  int64_t v183;
  uint64_t v184;
  unint64_t v185;
  unsigned int v186;
  unsigned int v187;
  unsigned int v188;
  unsigned int v189;
  unsigned int v192;
  unsigned int v193;
  unsigned int v194;
  unsigned int v195;
  unint64_t v198;
  unsigned int v199;
  unsigned int v200;
  unsigned int v201;
  unsigned int v202;
  unsigned int v205;
  unsigned int v206;
  unsigned int v207;
  unsigned int v208;
  int v211;
  __int128 v212;
  __int128 v213;
  __int128 v214;
  unint64_t v215;
  uint64_t v216;
  uint64_t v217;
  unsigned int v218;
  unsigned int v219;
  unsigned int v220;
  unsigned int v221;
  unsigned int v224;
  unsigned int v225;
  unsigned int v226;
  unsigned int v227;
  unsigned int v230;
  unsigned int v231;
  unsigned int v234;
  unsigned int v235;
  __int128 v238;
  __int128 v239;
  __int128 v240;
  uint64_t v241;
  unint64_t v242;
  unint64_t v243;
  uint64_t v244;
  uint64_t v245;
  unsigned int v246;
  unsigned int v247;
  unsigned int v248;
  unsigned int v249;
  unsigned int v252;
  unsigned int v253;
  unsigned int v254;
  unsigned int v255;
  __int128 v258;
  __int128 v259;
  __int128 v260;
  __int128 v261;
  __int128 v262;
  __int128 v263;
  uint64_t v264;
  unint64_t v265;
  unint64_t v266;
  unint64_t v267;
  unsigned __int32 v268;
  unsigned __int32 v269;
  unsigned int v272;
  unsigned int v273;
  unsigned int v274;
  unsigned int v275;
  unint64_t v278;
  int v279;
  __int128 v280;
  __int128 v281;
  __int128 v282;
  unint64_t v283;
  unint64_t v284;
  unsigned __int32 v285;
  unsigned __int32 v286;
  unsigned int v289;
  unsigned int v290;
  BOOL v292;
  __int128 v293;
  __int128 v294;
  __int128 v295;
  unsigned int v297;
  unsigned int v298;
  unsigned int v299;
  unsigned int v300;
  unsigned int v302;
  unsigned int v303;
  unsigned int v304;
  unsigned int v305;
  uint64_t v306;
  unsigned __int32 v307;
  unsigned __int32 v308;
  unsigned int v311;
  unsigned int v312;
  unsigned int v313;
  unsigned int v314;
  unint64_t v317;
  int v318;
  uint64_t v319;
  __int128 v320;
  __int128 v321;
  unsigned __int32 v322;
  unsigned __int32 v323;
  unsigned int v324;
  unsigned int v325;
  __int128 v326;
  __int128 v327;
  __int128 v328;
  __int128 v329;
  __int128 v330;
  __int128 v331;
  unsigned int v332;
  unsigned int v333;
  unsigned int v334;
  unsigned int v335;
  unsigned int v336;
  unsigned int v337;
  unsigned int v338;
  unsigned int v339;
  __int128 v340;
  __int128 v341;
  unsigned int v342;
  unsigned int v343;
  unsigned int v344;
  unsigned int v345;
  unsigned int v346;
  unsigned int v347;
  unsigned int v348;
  unsigned int v349;
  __int128 v350;
  __int128 v351;
  unsigned int v352;
  unsigned int v353;
  unsigned int v354;
  unsigned int v355;
  unsigned int v356;
  unsigned int v357;
  unsigned int v358;
  unsigned int v359;
  __int128 v360;
  __int128 v361;
  _BYTE v362[28];
  _BYTE v363[28];
  __int128 v364;
  __int128 v365;
  _BYTE v366[28];
  __int128 v367;
  uint64_t v368;
  uint64_t v369;
  uint64_t v370;
  __int128 v371;
  __int128 v372;
  __int128 v373;
  uint64_t v374;
  uint64_t v375;
  uint64_t v376;
  __int128 v377;
  __n128 v378;
  __n128 v379;
  _BYTE v380[28];
  _BYTE v381[28];
  __n128 v382;
  _BYTE v383[28];
  __n128 v384;
  __n128 v385;
  __n128 v386;
  __n128 v387;
  __n128 v388;
  __int128 v389;
  __int128 v390;
  __int128 v391;
  __n128 v392;
  __int128 v393;
  __n128 v394;
  __int128 v395;
  __int128 v396;
  __int128 v397;
  __int128 v398;
  __int128 v399;
  __int128 v400;
  __int128 v401;
  __int128 v402;
  __int128 v403;
  __int128 v404;
  __int128 v405;
  __int128 v406;
  __int128 v407;
  __int128 v408;
  __int128 v409;
  __int128 v410;
  __int128 v411;
  __int128 v412;
  __int128 v413;
  __int128 v414;
  __int128 v415;
  uint64_t v416;
  uint64_t v417;
  uint64_t v418;
  uint64_t v419;
  uint64_t v420;
  uint64_t v421;
  uint64_t v422;
  uint64_t v423;
  uint64_t v424;

__n128 sub_1C5462F3C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v15;
  unsigned int v16;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  unsigned int v26;
  unsigned int v27;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __n128 result;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;
  unsigned int v43;
  unsigned int v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  unsigned int v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  unsigned int v52;
  unsigned int v53;
  unsigned int v54;
  unsigned int v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __n128 v62;
  __n128 v63;
  __n128 v64;
  __n128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;

  v4 = *(_DWORD *)(a2 + 24);
  v3 = *(_DWORD *)(a2 + 28);
  v5 = *(_DWORD *)(a1 + 24);
  v6 = *(_DWORD *)(a1 + 28);
  if (v4 != v5 || v3 != v6)
  {
    if (v4 < v5)
      goto LABEL_21;
    if (v5 >= v4 && v3 < v6)
      goto LABEL_21;
LABEL_38:
    v27 = *(_DWORD *)(a3 + 24);
    v26 = *(_DWORD *)(a3 + 28);
    if (v27 == v4 && v26 == v3)
    {
      v42 = *(_DWORD *)(a3 + 32);
      v41 = *(_DWORD *)(a3 + 36);
      v44 = *(_DWORD *)(a2 + 32);
      v43 = *(_DWORD *)(a2 + 36);
      if (v42 == v44 && v41 == v43)
      {
        if (*(_DWORD *)(a3 + 40) >= *(_DWORD *)(a2 + 40))
          return result;
      }
      else if (v44 >= v42 && (v42 < v44 || v43 >= v41))
      {
        return result;
      }
    }
    else if (v27 >= v4 && (v4 < v27 || v26 >= v3))
    {
      return result;
    }
    v72 = *(_OWORD *)(a2 + 32);
    v76 = *(_OWORD *)(a2 + 48);
    v80 = *(_QWORD *)(a2 + 64);
    v64 = *(__n128 *)a2;
    v68 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)a2 = *(_OWORD *)a3;
    v46 = *(_OWORD *)(a3 + 32);
    v45 = *(_OWORD *)(a3 + 48);
    v47 = *(_OWORD *)(a3 + 16);
    *(_BYTE *)(a2 + 64) = *(_BYTE *)(a3 + 64);
    *(_OWORD *)(a2 + 32) = v46;
    *(_OWORD *)(a2 + 48) = v45;
    *(_OWORD *)(a2 + 16) = v47;
    *(_BYTE *)(a3 + 64) = v80;
    *(_OWORD *)(a3 + 32) = v72;
    *(_OWORD *)(a3 + 48) = v76;
    result = v64;
    *(__n128 *)a3 = v64;
    *(_OWORD *)(a3 + 16) = v68;
    v49 = *(_DWORD *)(a2 + 24);
    v48 = *(_DWORD *)(a2 + 28);
    v51 = *(_DWORD *)(a1 + 24);
    v50 = *(_DWORD *)(a1 + 28);
    if (v49 == v51 && v48 == v50)
    {
      v53 = *(_DWORD *)(a2 + 32);
      v52 = *(_DWORD *)(a2 + 36);
      v55 = *(_DWORD *)(a1 + 32);
      v54 = *(_DWORD *)(a1 + 36);
      if (v53 == v55 && v52 == v54)
      {
        if (*(_DWORD *)(a2 + 40) >= *(_DWORD *)(a1 + 40))
          return result;
      }
      else if (v55 >= v53 && (v53 < v55 || v54 >= v52))
      {
        return result;
      }
    }
    else if (v49 >= v51 && (v51 < v49 || v48 >= v50))
    {
      return result;
    }
    v73 = *(_OWORD *)(a1 + 32);
    v77 = *(_OWORD *)(a1 + 48);
    v81 = *(_QWORD *)(a1 + 64);
    v65 = *(__n128 *)a1;
    v69 = *(_OWORD *)(a1 + 16);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    v60 = *(_OWORD *)(a2 + 32);
    v59 = *(_OWORD *)(a2 + 48);
    v61 = *(_OWORD *)(a2 + 16);
    *(_BYTE *)(a1 + 64) = *(_BYTE *)(a2 + 64);
    *(_OWORD *)(a1 + 32) = v60;
    *(_OWORD *)(a1 + 48) = v59;
    *(_OWORD *)(a1 + 16) = v61;
    *(_BYTE *)(a2 + 64) = v81;
    *(_OWORD *)(a2 + 32) = v73;
    *(_OWORD *)(a2 + 48) = v77;
    result = v65;
    *(__n128 *)a2 = v65;
    *(_OWORD *)(a2 + 16) = v69;
    return result;
  }
  v9 = *(_DWORD *)(a2 + 32);
  v10 = *(_DWORD *)(a2 + 36);
  v11 = *(_DWORD *)(a1 + 32);
  v12 = *(_DWORD *)(a1 + 36);
  if (v9 == v11 && v10 == v12)
  {
    if (*(_DWORD *)(a2 + 40) < *(_DWORD *)(a1 + 40))
      goto LABEL_21;
    goto LABEL_38;
  }
  if (v11 >= v9 && (v9 < v11 || v12 >= v10))
    goto LABEL_38;
LABEL_21:
  v16 = *(_DWORD *)(a3 + 24);
  v15 = *(_DWORD *)(a3 + 28);
  if (v16 != v4 || v15 != v3)
  {
    if (v16 >= v4 && (v4 < v16 || v15 >= v3))
      goto LABEL_47;
LABEL_36:
    v70 = *(_OWORD *)(a1 + 32);
    v74 = *(_OWORD *)(a1 + 48);
    v78 = *(_QWORD *)(a1 + 64);
    v62 = *(__n128 *)a1;
    v66 = *(_OWORD *)(a1 + 16);
    *(_OWORD *)a1 = *(_OWORD *)a3;
    v24 = *(_OWORD *)(a3 + 32);
    v23 = *(_OWORD *)(a3 + 48);
    v25 = *(_OWORD *)(a3 + 16);
    *(_BYTE *)(a1 + 64) = *(_BYTE *)(a3 + 64);
    *(_OWORD *)(a1 + 32) = v24;
    *(_OWORD *)(a1 + 48) = v23;
    *(_OWORD *)(a1 + 16) = v25;
LABEL_78:
    *(_BYTE *)(a3 + 64) = v78;
    *(_OWORD *)(a3 + 32) = v70;
    *(_OWORD *)(a3 + 48) = v74;
    result = v62;
    *(__n128 *)a3 = v62;
    *(_OWORD *)(a3 + 16) = v66;
    return result;
  }
  v19 = *(_DWORD *)(a3 + 32);
  v18 = *(_DWORD *)(a3 + 36);
  v21 = *(_DWORD *)(a2 + 32);
  v20 = *(_DWORD *)(a2 + 36);
  if (v19 == v21 && v18 == v20)
  {
    if (*(_DWORD *)(a3 + 40) >= *(_DWORD *)(a2 + 40))
      goto LABEL_47;
    goto LABEL_36;
  }
  if (v21 < v19 || v19 >= v21 && v20 < v18)
    goto LABEL_36;
LABEL_47:
  v71 = *(_OWORD *)(a1 + 32);
  v75 = *(_OWORD *)(a1 + 48);
  v79 = *(_QWORD *)(a1 + 64);
  v63 = *(__n128 *)a1;
  v67 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  v30 = *(_OWORD *)(a2 + 32);
  v29 = *(_OWORD *)(a2 + 48);
  v31 = *(_OWORD *)(a2 + 16);
  *(_BYTE *)(a1 + 64) = *(_BYTE *)(a2 + 64);
  *(_OWORD *)(a1 + 32) = v30;
  *(_OWORD *)(a1 + 48) = v29;
  *(_OWORD *)(a1 + 16) = v31;
  *(_BYTE *)(a2 + 64) = v79;
  *(_OWORD *)(a2 + 32) = v71;
  *(_OWORD *)(a2 + 48) = v75;
  result = v63;
  *(__n128 *)a2 = v63;
  *(_OWORD *)(a2 + 16) = v67;
  v34 = *(_DWORD *)(a3 + 24);
  v33 = *(_DWORD *)(a3 + 28);
  v36 = *(_DWORD *)(a2 + 24);
  v35 = *(_DWORD *)(a2 + 28);
  if (v34 == v36 && v33 == v35)
  {
    v38 = *(_DWORD *)(a3 + 32);
    v37 = *(_DWORD *)(a3 + 36);
    v40 = *(_DWORD *)(a2 + 32);
    v39 = *(_DWORD *)(a2 + 36);
    if (v38 == v40 && v37 == v39)
    {
      if (*(_DWORD *)(a3 + 40) >= *(_DWORD *)(a2 + 40))
        return result;
      goto LABEL_77;
    }
    if (v40 < v38 || v38 >= v40 && v39 < v37)
    {
LABEL_77:
      v70 = *(_OWORD *)(a2 + 32);
      v74 = *(_OWORD *)(a2 + 48);
      v78 = *(_QWORD *)(a2 + 64);
      v62 = *(__n128 *)a2;
      v66 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      v57 = *(_OWORD *)(a3 + 32);
      v56 = *(_OWORD *)(a3 + 48);
      v58 = *(_OWORD *)(a3 + 16);
      *(_BYTE *)(a2 + 64) = *(_BYTE *)(a3 + 64);
      *(_OWORD *)(a2 + 32) = v57;
      *(_OWORD *)(a2 + 48) = v56;
      *(_OWORD *)(a2 + 16) = v58;
      goto LABEL_78;
    }
  }
  else if (v34 < v36 || v36 >= v34 && v33 < v35)
  {
    goto LABEL_77;
  }
  return result;
}

BOOL sub_1C54632F4(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  _BOOL8 result;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  __int128 v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  uint64_t v26;
  int v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v37;
  unsigned int v38;
  uint64_t v41;
  uint64_t v42;
  __int128 v43;
  __int128 v44;
  __int128 *v45;
  __int128 *v46;
  __int128 *v47;
  unsigned int v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  unsigned int v52;
  unsigned int v53;
  unsigned int v54;
  unsigned int v55;
  unsigned int v56;
  unsigned int v57;
  unsigned int v58;
  unsigned int v59;
  uint64_t v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  unsigned int v64;
  unsigned int v65;
  unsigned int v66;
  unsigned int v67;
  unsigned int v68;
  unsigned int v69;
  unsigned int v70;
  unsigned int v71;
  uint64_t v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  unsigned int v78;
  unsigned int v79;
  unsigned int v80;
  unsigned int v81;
  unsigned int v82;
  unsigned int v83;
  unsigned int v84;
  unsigned int v85;
  __int128 v86;
  __int128 v87;
  unsigned int v88;
  unsigned int v89;
  unsigned int v90;
  unsigned int v91;
  unsigned int v92;
  unsigned int v93;
  unsigned int v94;
  unsigned int v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  uint64_t v99;
  _BYTE v100[28];
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;

  v4 = 0x8E38E38E38E38E39 * ((a2 - a1) >> 3);
  result = 1;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      v7 = *(_DWORD *)(a2 - 48);
      v6 = *(_DWORD *)(a2 - 44);
      v9 = *(_DWORD *)(a1 + 24);
      v8 = *(_DWORD *)(a1 + 28);
      if (v7 != v9 || v6 != v8)
      {
        if (v7 >= v9 && (v9 < v7 || v6 >= v8))
          return result;
        goto LABEL_101;
      }
      v57 = *(_DWORD *)(a2 - 40);
      v56 = *(_DWORD *)(a2 - 36);
      v59 = *(_DWORD *)(a1 + 32);
      v58 = *(_DWORD *)(a1 + 36);
      if (v57 == v59 && v56 == v58)
      {
        if (*(_DWORD *)(a2 - 32) >= *(_DWORD *)(a1 + 40))
          return result;
        goto LABEL_101;
      }
      if (v59 < v57 || v57 >= v59 && v58 < v56)
      {
LABEL_101:
        v72 = a2 - 72;
        v112 = *(_OWORD *)(a1 + 32);
        v117 = *(_OWORD *)(a1 + 48);
        v122 = *(_QWORD *)(a1 + 64);
        v102 = *(_OWORD *)a1;
        v107 = *(_OWORD *)(a1 + 16);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 72);
        v74 = *(_OWORD *)(a2 - 40);
        v73 = *(_OWORD *)(a2 - 24);
        v75 = *(_OWORD *)(a2 - 56);
        *(_BYTE *)(a1 + 64) = *(_BYTE *)(a2 - 8);
        *(_OWORD *)(a1 + 32) = v74;
        *(_OWORD *)(a1 + 48) = v73;
        *(_OWORD *)(a1 + 16) = v75;
        *(_BYTE *)(v72 + 64) = v122;
        *(_OWORD *)(v72 + 32) = v112;
        *(_OWORD *)(v72 + 48) = v117;
        *(_OWORD *)v72 = v102;
        *(_OWORD *)(v72 + 16) = v107;
        return result;
      }
      return result;
    case 3uLL:
      sub_1C5462F3C(a1, a1 + 72, a2 - 72);
      return 1;
    case 4uLL:
      sub_1C54639B8(a1, a1 + 72, a1 + 144, a2 - 72);
      return 1;
    case 5uLL:
      v45 = (__int128 *)(a1 + 72);
      v46 = (__int128 *)(a1 + 144);
      v47 = (__int128 *)(a1 + 216);
      sub_1C54639B8(a1, a1 + 72, a1 + 144, a1 + 216);
      v49 = *(_DWORD *)(a2 - 48);
      v48 = *(_DWORD *)(a2 - 44);
      v51 = *(_DWORD *)(a1 + 240);
      v50 = *(_DWORD *)(a1 + 244);
      if (v49 == v51 && v48 == v50)
      {
        v53 = *(_DWORD *)(a2 - 40);
        v52 = *(_DWORD *)(a2 - 36);
        v55 = *(_DWORD *)(a1 + 248);
        v54 = *(_DWORD *)(a1 + 252);
        if (v53 == v55 && v52 == v54)
        {
          if (*(_DWORD *)(a2 - 32) >= *(_DWORD *)(a1 + 256))
            return 1;
        }
        else if (v55 >= v53)
        {
          result = 1;
          if (v53 < v55 || v54 >= v52)
            return result;
        }
      }
      else if (v49 >= v51)
      {
        result = 1;
        if (v51 < v49 || v48 >= v50)
          return result;
      }
      v60 = a2 - 72;
      v111 = *(_OWORD *)(a1 + 248);
      v116 = *(_OWORD *)(a1 + 264);
      v121 = *(_QWORD *)(a1 + 280);
      v101 = *v47;
      v106 = *(_OWORD *)(a1 + 232);
      *v47 = *(_OWORD *)(a2 - 72);
      v62 = *(_OWORD *)(a2 - 40);
      v61 = *(_OWORD *)(a2 - 24);
      v63 = *(_OWORD *)(a2 - 56);
      *(_BYTE *)(a1 + 280) = *(_BYTE *)(a2 - 8);
      *(_OWORD *)(a1 + 248) = v62;
      *(_OWORD *)(a1 + 264) = v61;
      *(_OWORD *)(a1 + 232) = v63;
      *(_BYTE *)(v60 + 64) = v121;
      *(_OWORD *)(v60 + 32) = v111;
      *(_OWORD *)(v60 + 48) = v116;
      *(_OWORD *)v60 = v101;
      *(_OWORD *)(v60 + 16) = v106;
      v65 = *(_DWORD *)(a1 + 240);
      v64 = *(_DWORD *)(a1 + 244);
      v67 = *(_DWORD *)(a1 + 168);
      v66 = *(_DWORD *)(a1 + 172);
      if (v65 == v67 && v64 == v66)
      {
        v69 = *(_DWORD *)(a1 + 248);
        v68 = *(_DWORD *)(a1 + 252);
        v71 = *(_DWORD *)(a1 + 176);
        v70 = *(_DWORD *)(a1 + 180);
        if (v69 == v71 && v68 == v70)
        {
          if (*(_DWORD *)(a1 + 256) >= *(_DWORD *)(a1 + 184))
            return 1;
        }
        else if (v71 >= v69)
        {
          result = 1;
          if (v69 < v71 || v70 >= v68)
            return result;
        }
      }
      else if (v65 >= v67)
      {
        result = 1;
        if (v67 < v65 || v64 >= v66)
          return result;
      }
      v113 = *(_OWORD *)(a1 + 176);
      v118 = *(_OWORD *)(a1 + 192);
      v123 = *(_QWORD *)(a1 + 208);
      v103 = *v46;
      v108 = *(_OWORD *)(a1 + 160);
      v76 = *(_OWORD *)(a1 + 264);
      *(_OWORD *)(a1 + 176) = *(_OWORD *)(a1 + 248);
      *(_OWORD *)(a1 + 192) = v76;
      *(_BYTE *)(a1 + 208) = *(_BYTE *)(a1 + 280);
      v77 = *(_OWORD *)(a1 + 232);
      *v46 = *v47;
      *(_OWORD *)(a1 + 160) = v77;
      *(_BYTE *)(a1 + 280) = v123;
      *(_OWORD *)(a1 + 248) = v113;
      *(_OWORD *)(a1 + 264) = v118;
      *v47 = v103;
      *(_OWORD *)(a1 + 232) = v108;
      v79 = *(_DWORD *)(a1 + 168);
      v78 = *(_DWORD *)(a1 + 172);
      v81 = *(_DWORD *)(a1 + 96);
      v80 = *(_DWORD *)(a1 + 100);
      if (v79 == v81 && v78 == v80)
      {
        v83 = *(_DWORD *)(a1 + 176);
        v82 = *(_DWORD *)(a1 + 180);
        v85 = *(_DWORD *)(a1 + 104);
        v84 = *(_DWORD *)(a1 + 108);
        if (v83 == v85 && v82 == v84)
        {
          if (*(_DWORD *)(a1 + 184) >= *(_DWORD *)(a1 + 112))
            return 1;
        }
        else if (v85 >= v83)
        {
          result = 1;
          if (v83 < v85 || v84 >= v82)
            return result;
        }
      }
      else if (v79 >= v81)
      {
        result = 1;
        if (v81 < v79 || v78 >= v80)
          return result;
      }
      v114 = *(_OWORD *)(a1 + 104);
      v119 = *(_OWORD *)(a1 + 120);
      v124 = *(_QWORD *)(a1 + 136);
      v104 = *v45;
      v109 = *(_OWORD *)(a1 + 88);
      v86 = *(_OWORD *)(a1 + 192);
      *(_OWORD *)(a1 + 104) = *(_OWORD *)(a1 + 176);
      *(_OWORD *)(a1 + 120) = v86;
      *(_BYTE *)(a1 + 136) = *(_BYTE *)(a1 + 208);
      v87 = *(_OWORD *)(a1 + 160);
      *v45 = *v46;
      *(_OWORD *)(a1 + 88) = v87;
      *(_BYTE *)(a1 + 208) = v124;
      *(_OWORD *)(a1 + 176) = v114;
      *(_OWORD *)(a1 + 192) = v119;
      *v46 = v104;
      *(_OWORD *)(a1 + 160) = v109;
      v89 = *(_DWORD *)(a1 + 96);
      v88 = *(_DWORD *)(a1 + 100);
      v91 = *(_DWORD *)(a1 + 24);
      v90 = *(_DWORD *)(a1 + 28);
      if (v89 == v91 && v88 == v90)
      {
        v93 = *(_DWORD *)(a1 + 104);
        v92 = *(_DWORD *)(a1 + 108);
        v95 = *(_DWORD *)(a1 + 32);
        v94 = *(_DWORD *)(a1 + 36);
        if (v93 == v95 && v92 == v94)
        {
          if (*(_DWORD *)(a1 + 112) >= *(_DWORD *)(a1 + 40))
            return 1;
          goto LABEL_131;
        }
        if (v95 < v93 || (result = 1, v93 >= v95) && v94 < v92)
        {
LABEL_131:
          v115 = *(_OWORD *)(a1 + 32);
          v120 = *(_OWORD *)(a1 + 48);
          v125 = *(_QWORD *)(a1 + 64);
          v105 = *(_OWORD *)a1;
          v110 = *(_OWORD *)(a1 + 16);
          v96 = *(_OWORD *)(a1 + 120);
          *(_OWORD *)(a1 + 32) = *(_OWORD *)(a1 + 104);
          *(_OWORD *)(a1 + 48) = v96;
          *(_BYTE *)(a1 + 64) = *(_BYTE *)(a1 + 136);
          v97 = *(_OWORD *)(a1 + 88);
          *(_OWORD *)a1 = *v45;
          *(_OWORD *)(a1 + 16) = v97;
          *(_BYTE *)(a1 + 136) = v125;
          *(_OWORD *)(a1 + 104) = v115;
          *(_OWORD *)(a1 + 120) = v120;
          result = 1;
          *v45 = v105;
          *(_OWORD *)(a1 + 88) = v110;
        }
      }
      else
      {
        if (v89 < v91)
          goto LABEL_131;
        result = 1;
        if (v91 >= v89 && v88 < v90)
          goto LABEL_131;
      }
      return result;
    default:
      v11 = a1 + 144;
      sub_1C5462F3C(a1, a1 + 72, a1 + 144);
      v12 = a1 + 216;
      if (a1 + 216 == a2)
        return 1;
      v13 = 0;
      v14 = 0;
      break;
  }
LABEL_12:
  *(_QWORD *)&v15 = *(_QWORD *)(v12 + 24);
  v16 = *(_DWORD *)(v11 + 24);
  v17 = *(_DWORD *)(v11 + 28);
  if ((_DWORD)v15 == v16 && DWORD1(v15) == v17)
  {
    v20 = *(_DWORD *)(v12 + 32);
    v21 = *(_DWORD *)(v12 + 36);
    v22 = *(_DWORD *)(v11 + 32);
    v23 = *(_DWORD *)(v11 + 36);
    if (v20 == v22 && v21 == v23)
    {
      if (*(_DWORD *)(v12 + 40) >= *(_DWORD *)(v11 + 40))
        goto LABEL_64;
    }
    else if (v22 >= v20 && (v20 < v22 || v23 >= v21))
    {
      goto LABEL_64;
    }
  }
  else if (v15 >= v16 && (v16 < v15 || DWORD1(v15) >= v17))
  {
    goto LABEL_64;
  }
  v99 = *(_QWORD *)(v12 + 16);
  v98 = *(_OWORD *)v12;
  v26 = *(_QWORD *)(v12 + 32);
  v27 = *(_DWORD *)(v12 + 40);
  *(_OWORD *)&v100[12] = *(_OWORD *)(v12 + 56);
  *(_OWORD *)v100 = *(_OWORD *)(v12 + 44);
  v28 = *(_OWORD *)(v11 + 48);
  *(_OWORD *)(v12 + 32) = *(_OWORD *)(v11 + 32);
  *(_OWORD *)(v12 + 48) = v28;
  *(_BYTE *)(v12 + 64) = *(_BYTE *)(v11 + 64);
  v29 = *(_OWORD *)(v11 + 16);
  *(_OWORD *)v12 = *(_OWORD *)v11;
  *(_OWORD *)(v12 + 16) = v29;
  v30 = a1;
  if (v11 == a1)
    goto LABEL_63;
  v31 = v13;
  while (1)
  {
    v32 = a1 + v31;
    v33 = *(_DWORD *)(a1 + v31 + 96);
    v34 = *(_DWORD *)(a1 + v31 + 100);
    if ((_DWORD)v15 == v33 && DWORD1(v15) == v34)
    {
      v37 = *(_DWORD *)(v32 + 104);
      v38 = *(_DWORD *)(v32 + 108);
      if ((_DWORD)v26 == v37 && HIDWORD(v26) == v38)
      {
        if (v27 >= *(_DWORD *)(a1 + v31 + 112))
          goto LABEL_62;
      }
      else if (v37 >= v26 && (v26 < v37 || v38 >= HIDWORD(v26)))
      {
        v30 = a1 + v31 + 144;
        goto LABEL_63;
      }
    }
    else if (v15 >= v33 && (v33 < v15 || DWORD1(v15) >= v34))
    {
LABEL_62:
      v30 = v11;
LABEL_63:
      *(_QWORD *)(v30 + 16) = v99;
      *(_OWORD *)v30 = v98;
      *((_QWORD *)&v15 + 1) = v26;
      *(_OWORD *)(v30 + 24) = v15;
      *(_DWORD *)(v30 + 40) = v27;
      *(_OWORD *)(v30 + 44) = *(_OWORD *)v100;
      *(_QWORD *)(v30 + 57) = *(_QWORD *)&v100[13];
      if (++v14 == 8)
        return v12 + 72 == a2;
LABEL_64:
      v11 = v12;
      v13 += 72;
      v12 += 72;
      if (v12 == a2)
        return 1;
      goto LABEL_12;
    }
    v41 = v32 + 144;
    v11 -= 72;
    v42 = v32 + 72;
    v43 = *(_OWORD *)(v42 + 48);
    *(_OWORD *)(v41 + 32) = *(_OWORD *)(v42 + 32);
    *(_OWORD *)(v41 + 48) = v43;
    *(_BYTE *)(v41 + 64) = *(_BYTE *)(v42 + 64);
    v44 = *(_OWORD *)(v42 + 16);
    *(_OWORD *)v41 = *(_OWORD *)v42;
    *(_OWORD *)(v41 + 16) = v44;
    v31 -= 72;
    if (v31 == -144)
    {
      v30 = a1;
      goto LABEL_63;
    }
  }
}

__n128 sub_1C54639B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __n128 result;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int v39;
  unsigned int v40;
  unsigned int v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __n128 v45;
  __n128 v46;
  __n128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;

  result.n128_u64[0] = sub_1C5462F3C(a1, a2, a3).n128_u64[0];
  v9 = *(_DWORD *)(a4 + 24);
  v10 = *(_DWORD *)(a4 + 28);
  v11 = *(_DWORD *)(a3 + 24);
  v12 = *(_DWORD *)(a3 + 28);
  if (v9 == v11 && v10 == v12)
  {
    v16 = *(_DWORD *)(a4 + 32);
    v15 = *(_DWORD *)(a4 + 36);
    v18 = *(_DWORD *)(a3 + 32);
    v17 = *(_DWORD *)(a3 + 36);
    if (v16 == v18 && v15 == v17)
    {
      if (*(_DWORD *)(a4 + 40) >= *(_DWORD *)(a3 + 40))
        return result;
    }
    else if (v18 >= v16 && (v16 < v18 || v17 >= v15))
    {
      return result;
    }
  }
  else if (v9 >= v11 && (v11 < v9 || v10 >= v12))
  {
    return result;
  }
  v51 = *(_OWORD *)(a3 + 32);
  v54 = *(_OWORD *)(a3 + 48);
  v57 = *(_QWORD *)(a3 + 64);
  v45 = *(__n128 *)a3;
  v48 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)a3 = *(_OWORD *)a4;
  v21 = *(_OWORD *)(a4 + 32);
  v20 = *(_OWORD *)(a4 + 48);
  v22 = *(_OWORD *)(a4 + 16);
  *(_BYTE *)(a3 + 64) = *(_BYTE *)(a4 + 64);
  *(_OWORD *)(a3 + 32) = v21;
  *(_OWORD *)(a3 + 48) = v20;
  *(_OWORD *)(a3 + 16) = v22;
  *(_BYTE *)(a4 + 64) = v57;
  *(_OWORD *)(a4 + 32) = v51;
  *(_OWORD *)(a4 + 48) = v54;
  result = v45;
  *(__n128 *)a4 = v45;
  *(_OWORD *)(a4 + 16) = v48;
  v24 = *(_DWORD *)(a3 + 24);
  v23 = *(_DWORD *)(a3 + 28);
  v26 = *(_DWORD *)(a2 + 24);
  v25 = *(_DWORD *)(a2 + 28);
  if (v24 == v26 && v23 == v25)
  {
    v28 = *(_DWORD *)(a3 + 32);
    v27 = *(_DWORD *)(a3 + 36);
    v30 = *(_DWORD *)(a2 + 32);
    v29 = *(_DWORD *)(a2 + 36);
    if (v28 == v30 && v27 == v29)
    {
      if (*(_DWORD *)(a3 + 40) >= *(_DWORD *)(a2 + 40))
        return result;
    }
    else if (v30 >= v28 && (v28 < v30 || v29 >= v27))
    {
      return result;
    }
  }
  else if (v24 >= v26 && (v26 < v24 || v23 >= v25))
  {
    return result;
  }
  v52 = *(_OWORD *)(a2 + 32);
  v55 = *(_OWORD *)(a2 + 48);
  v58 = *(_QWORD *)(a2 + 64);
  v46 = *(__n128 *)a2;
  v49 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  v32 = *(_OWORD *)(a3 + 32);
  v31 = *(_OWORD *)(a3 + 48);
  v33 = *(_OWORD *)(a3 + 16);
  *(_BYTE *)(a2 + 64) = *(_BYTE *)(a3 + 64);
  *(_OWORD *)(a2 + 32) = v32;
  *(_OWORD *)(a2 + 48) = v31;
  *(_OWORD *)(a2 + 16) = v33;
  *(_BYTE *)(a3 + 64) = v58;
  *(_OWORD *)(a3 + 32) = v52;
  *(_OWORD *)(a3 + 48) = v55;
  result = v46;
  *(__n128 *)a3 = v46;
  *(_OWORD *)(a3 + 16) = v49;
  v35 = *(_DWORD *)(a2 + 24);
  v34 = *(_DWORD *)(a2 + 28);
  v37 = *(_DWORD *)(a1 + 24);
  v36 = *(_DWORD *)(a1 + 28);
  if (v35 == v37 && v34 == v36)
  {
    v39 = *(_DWORD *)(a2 + 32);
    v38 = *(_DWORD *)(a2 + 36);
    v41 = *(_DWORD *)(a1 + 32);
    v40 = *(_DWORD *)(a1 + 36);
    if (v39 == v41 && v38 == v40)
    {
      if (*(_DWORD *)(a2 + 40) >= *(_DWORD *)(a1 + 40))
        return result;
LABEL_47:
      v53 = *(_OWORD *)(a1 + 32);
      v56 = *(_OWORD *)(a1 + 48);
      v59 = *(_QWORD *)(a1 + 64);
      v47 = *(__n128 *)a1;
      v50 = *(_OWORD *)(a1 + 16);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      v43 = *(_OWORD *)(a2 + 32);
      v42 = *(_OWORD *)(a2 + 48);
      v44 = *(_OWORD *)(a2 + 16);
      *(_BYTE *)(a1 + 64) = *(_BYTE *)(a2 + 64);
      *(_OWORD *)(a1 + 32) = v43;
      *(_OWORD *)(a1 + 48) = v42;
      *(_OWORD *)(a1 + 16) = v44;
      *(_BYTE *)(a2 + 64) = v59;
      *(_OWORD *)(a2 + 32) = v53;
      *(_OWORD *)(a2 + 48) = v56;
      result = v47;
      *(__n128 *)a2 = v47;
      *(_OWORD *)(a2 + 16) = v50;
      return result;
    }
    if (v41 < v39 || v39 >= v41 && v40 < v38)
      goto LABEL_47;
  }
  else if (v35 < v37 || v37 >= v35 && v34 < v36)
  {
    goto LABEL_47;
  }
  return result;
}

void sub_1C5463C40(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v6;
  char *v7;
  char *v8;
  const std::nothrow_t *v9;
  unint64_t v10;
  uint64_t *v11;
  BOOL v12;
  uint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v34;
  uint64_t v35;
  BOOL v36;

  v6 = *(_QWORD *)(a1 + 8);
  v7 = (char *)(v6 + 8 * a3);
  v8 = (char *)(v6 + 8 * *(unsigned int *)(a1 + 16));
  if (v8 - v7 < 1025)
  {
LABEL_5:
    sub_1C546435C(v7, v8, (v8 - v7) >> 3, 0, 0);
  }
  else
  {
    v9 = (const std::nothrow_t *)MEMORY[0x1E0DE4E10];
    v10 = (v8 - v7) >> 3;
    while (1)
    {
      v11 = (uint64_t *)operator new(8 * v10, v9);
      if (v11)
        break;
      v12 = v10 > 1;
      v10 >>= 1;
      if (!v12)
        goto LABEL_5;
    }
    v13 = v11;
    sub_1C546435C(v7, v8, (v8 - v7) >> 3, v11, v10);
    operator delete(v13);
  }
  v14 = *(unsigned int *)(a1 + 16);
  v15 = a3 + 1;
  if (v15 < v14)
  {
    v16 = a3 + 2;
    v17 = a3;
    do
    {
      v18 = *(_QWORD *)(a1 + 8);
      v19 = *(_QWORD *)(v18 + 8 * v15);
      v20 = *(_QWORD *)(v18 + 8 * v17);
      v21 = *(unsigned int *)(v20 + 32);
      v22 = *(unsigned int *)(v20 + 36);
      if (*(_BYTE *)(a2 + 8))
      {
        if ((_DWORD)v21 == *(_DWORD *)a2 && (_DWORD)v22 == *(_DWORD *)(a2 + 4))
          break;
      }
      if ((_DWORD)v21 != *(_DWORD *)(v19 + 32) || (_DWORD)v22 != *(_DWORD *)(v19 + 36))
      {
        v25 = v17 + 2;
        v26 = v16;
        if (v25 < v14)
        {
          do
          {
            v27 = *(_QWORD *)(v18 + 8 * v26);
            if (*(_DWORD *)(v19 + 36) == *(_DWORD *)(v27 + 36) && *(_DWORD *)(v19 + 32) == *(_DWORD *)(v27 + 32))
              v19 = *(_QWORD *)(v18 + 8 * v26);
            ++v26;
          }
          while (v26 < v14);
        }
        sub_1C5463E58(*(void ***)a1, *(_DWORD *)(v19 + 40), *(_QWORD *)(v19 + 48), (v22 << 32) | v21, 0, 0);
      }
      v17 = v15;
      ++v16;
      ++v15;
    }
    while ((_DWORD)v14 != (_DWORD)v15);
    LODWORD(v14) = *(_DWORD *)(a1 + 16);
  }
  v29 = *(_QWORD *)(a1 + 8);
  v30 = *(_QWORD *)(v29 + 8 * v14 - 8);
  if (a3)
  {
    v32 = *(unsigned int *)(v30 + 32);
    v31 = *(unsigned int *)(v30 + 36);
    if ((_DWORD)v32 != *(_DWORD *)a2 || (_DWORD)v31 != *(_DWORD *)(a2 + 4))
    {
      v34 = v32 | (v31 << 32);
      v35 = *(_QWORD *)(v29 + 8 * (a3 - 1));
      sub_1C5463E58(*(void ***)a1, *(_DWORD *)(v35 + 40), *(_QWORD *)(v35 + 48), v34, 0, 0);
    }
  }
  else if (!*(_BYTE *)(a2 + 8)
         || (*(_DWORD *)a2 == *(_DWORD *)(v30 + 32) ? (v36 = *(_DWORD *)(a2 + 4) == *(_DWORD *)(v30 + 36)) : (v36 = 0),
             !v36))
  {
    sub_1C5464C60(*(_QWORD *)a1, *(_DWORD *)(v30 + 32), *(_DWORD *)(v30 + 36), 0);
  }
  *(_DWORD *)(a1 + 16) = (unint64_t)&v7[-*(_QWORD *)(a1 + 8)] >> 3;
}

void sub_1C5463E58(void **a1, int a2, uint64_t a3, unint64_t a4, char a5, int a6)
{
  int v7;
  int v10;
  char *v11;
  char *v12;
  BOOL v13;
  unint64_t v14;
  BOOL v15;
  char *v16;
  char *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  char *v22;
  char *v23;
  __int128 v24;
  char *v25;

  v7 = a4;
  v10 = (a2 != 2) & ~a6;
  v11 = (char *)*a1;
  v12 = (char *)a1[1];
  if (*a1 == v12
    || (a5 & 1) != 0
    || (a6 & 1) != 0
    || *(v12 - 8) != v10
    || (*((_QWORD *)v12 - 2) == a3 ? (v13 = *(v12 - 7) == 0) : (v13 = 0), !v13))
  {
    v14 = HIDWORD(a4);
    if (v10)
    {
      v15 = a2 == 3;
      v16 = (char *)a1[2];
      if (v12 >= v16)
      {
        v18 = 0xAAAAAAAAAAAAAAABLL * ((v12 - v11) >> 3) + 1;
        if (v18 > 0xAAAAAAAAAAAAAAALL)
          abort();
        v19 = 0xAAAAAAAAAAAAAAABLL * ((v16 - v11) >> 3);
        if (2 * v19 > v18)
          v18 = 2 * v19;
        if (v19 >= 0x555555555555555)
          v20 = 0xAAAAAAAAAAAAAAALL;
        else
          v20 = v18;
        if (v20 > 0xAAAAAAAAAAAAAAALL)
          sub_1C4764EE4();
        v21 = 3 * v20;
        v22 = (char *)operator new(24 * v20);
        v23 = &v22[8 * ((v12 - v11) >> 3)];
        *(_DWORD *)v23 = v7;
        *((_DWORD *)v23 + 1) = v14;
        *((_QWORD *)v23 + 1) = a3;
        v23[16] = 1;
        v23[17] = a5;
        v23[18] = v15;
        v17 = v23 + 24;
        if (v11 == v12)
        {
          v25 = &v22[8 * ((v12 - v11) >> 3)];
        }
        else
        {
          do
          {
            v24 = *(_OWORD *)(v12 - 24);
            v25 = v23 - 24;
            *(_DWORD *)(v23 - 9) = *(_DWORD *)(v12 - 9);
            *(_OWORD *)(v23 - 24) = v24;
            v12 -= 24;
            v23 -= 24;
          }
          while (v12 != v11);
        }
        *a1 = v25;
        a1[1] = v17;
        a1[2] = &v22[8 * v21];
        if (v11)
          operator delete(v11);
      }
      else
      {
        *(_QWORD *)v12 = a4;
        *((_QWORD *)v12 + 1) = a3;
        v12[16] = 1;
        v12[17] = a5;
        v17 = v12 + 24;
        v12[18] = v15;
      }
      a1[1] = v17;
    }
    else
    {
      sub_1C5464C60((uint64_t)a1, a4, SHIDWORD(a4), a5);
    }
  }
}

uint64_t *sub_1C546402C(int8x16_t *a1, unint64_t *a2, unsigned int **a3, uint64_t a4, uint64_t *a5, uint64_t a6)
{
  unint64_t *v7;
  uint64_t *v8;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  unsigned int *v20;
  unsigned int v21;
  char *v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t *v27;
  uint64_t v28;
  unsigned int v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  uint64_t v35;
  char *v36;
  unsigned int v37;
  uint64_t v38;
  int64_t v39;
  uint64_t v40;
  size_t v41;

  v7 = a2;
  v8 = (uint64_t *)a1;
  if (a4 == 3)
  {
    v11 = a1->i64[1];
    v12 = *(_DWORD *)(v11 + 32);
    v13 = **a3;
    if (v13 >= v12 && (v12 < v13 || (*a3)[1] >= *(_DWORD *)(v11 + 36)))
    {
      a1->i64[1] = *a2;
      *a2 = v11;
      *a1 = vextq_s8(*a1, *a1, 8uLL);
      return &a1->i64[1];
    }
    v10 = a1->i64[0];
    a1->i64[0] = v11;
    a1->i64[1] = v10;
    a1->i64[1] = *a2;
    goto LABEL_8;
  }
  if (a4 == 2)
  {
    v10 = a1->i64[0];
    a1->i64[0] = *a2;
LABEL_8:
    *a2 = v10;
    return (uint64_t *)v7;
  }
  if (a6 >= a4)
  {
    v26 = &a1->i64[1];
    *a5 = a1->i64[0];
    v27 = a5 + 1;
    if (&a1->u64[1] == a2)
    {
      a1->i64[0] = *a2;
    }
    else
    {
      do
      {
        v28 = *v26;
        v29 = *(_DWORD *)(*v26 + 32);
        v30 = **a3;
        if (v30 >= v29 && (v29 < v30 || (*a3)[1] >= *(_DWORD *)(v28 + 36)))
          *v27++ = v28;
        else
          *v8++ = v28;
        ++v26;
      }
      while (v26 != (uint64_t *)a2);
      *v8 = *a2;
      v7 = (unint64_t *)(v8 + 1);
      if (v27 <= a5)
        return (uint64_t *)v7;
    }
    v33 = 0;
    do
    {
      v7[v33] = a5[v33];
      ++v33;
    }
    while (&a5[v33] < v27);
    return (uint64_t *)v7;
  }
  if (a4 >= 0)
    v17 = a4;
  else
    v17 = a4 + 1;
  v18 = v17 >> 1;
  v19 = &a1->i8[8 * (v17 >> 1)];
  v20 = *a3;
  v21 = **a3;
  v22 = v19 - 8;
  v23 = *((_QWORD *)v19 - 1);
  v24 = *(_DWORD *)(v23 + 32);
  if (v21 >= v24)
  {
    v31 = 8 * v18 - 8;
    v32 = v18;
    while (v24 < v21 || v20[1] >= *(_DWORD *)(v23 + 36))
    {
      if (!v31)
        goto LABEL_38;
      v25 = v32 - 1;
      v23 = a1[-1].i64[v32];
      v24 = *(_DWORD *)(v23 + 32);
      v31 -= 8;
      --v32;
      if (v21 < v24)
      {
        v22 = &a1->i8[v31];
        goto LABEL_37;
      }
    }
    v22 = &a1->i8[v31];
    v25 = v32;
  }
  else
  {
    v25 = v18;
  }
LABEL_37:
  v8 = (uint64_t *)sub_1C546402C(a1, v22, a3, v25, a5, a6);
  v20 = *a3;
  v21 = **a3;
LABEL_38:
  v34 = (char *)(v7 + 1);
  v35 = a4 - v18;
  v36 = v19;
  while (1)
  {
    v37 = *(_DWORD *)(*(_QWORD *)v36 + 32);
    if (v21 >= v37 && (v37 < v21 || v20[1] >= *(_DWORD *)(*(_QWORD *)v36 + 36)))
      break;
    v36 += 8;
    if (v36 == (char *)v7)
      goto LABEL_45;
    --v35;
  }
  v34 = (char *)sub_1C546402C(v36, v7, a3, v35, a5, a6);
LABEL_45:
  if (v8 == (uint64_t *)v19)
    return (uint64_t *)v34;
  if (v19 == v34)
    return v8;
  if (v8 + 1 == (uint64_t *)v19)
  {
    v38 = *v8;
    v39 = v34 - v19;
    memmove(v8, v19, v34 - v19);
    v7 = (unint64_t *)((char *)v8 + v39);
    *v7 = v38;
    return (uint64_t *)v7;
  }
  if (v19 + 8 == v34)
  {
    v40 = *((_QWORD *)v34 - 1);
    v7 = (unint64_t *)(v8 + 1);
    v41 = v34 - 8 - (char *)v8;
    if (v41)
      memmove(v8 + 1, v8, v41);
    *v8 = v40;
    return (uint64_t *)v7;
  }
  return sub_1C4E85DF0(v8, v19, v34);
}

char *sub_1C546435C(char *result, char *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  char *v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  BOOL v11;
  char *v13;
  uint64_t v14;
  char *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  BOOL v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  char *v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t *v32;
  char *v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  unsigned int v38;
  BOOL v39;
  uint64_t v40;
  uint64_t v41;

  if (a3 >= 2)
  {
    v6 = result;
    if (a3 == 2)
    {
      v7 = *((_QWORD *)a2 - 1);
      v8 = *(_QWORD *)result;
      v9 = *(_DWORD *)(v7 + 32);
      v10 = *(_DWORD *)(*(_QWORD *)result + 32);
      if (v9 < v10 || (v10 >= v9 ? (v11 = *(_DWORD *)(v7 + 36) >= *(_DWORD *)(v8 + 36)) : (v11 = 1), !v11))
      {
        *(_QWORD *)result = v7;
        *((_QWORD *)a2 - 1) = v8;
      }
    }
    else if ((uint64_t)a3 > 128)
    {
      v28 = (char *)a4;
      v29 = a3 >> 1;
      v30 = (uint64_t)&result[8 * (a3 >> 1)];
      v31 = a3 >> 1;
      if ((uint64_t)a3 <= a5)
      {
        sub_1C54645DC((uint64_t)result, v30, v31, a4);
        v32 = (uint64_t *)&v28[8 * v29];
        result = (char *)sub_1C54645DC((uint64_t)&v6[8 * (a3 >> 1)], (uint64_t)a2, a3 - (a3 >> 1), v32);
        v33 = &v28[8 * a3];
        v34 = v32;
        while (v34 != (uint64_t *)v33)
        {
          v35 = *v34;
          v36 = *(_QWORD *)v28;
          v37 = *(_DWORD *)(*v34 + 32);
          v38 = *(_DWORD *)(*(_QWORD *)v28 + 32);
          if (v37 >= v38 && (v38 >= v37 ? (v39 = *(_DWORD *)(v35 + 36) >= *(_DWORD *)(v36 + 36)) : (v39 = 1), v39))
          {
            *(_QWORD *)v6 = v36;
            v28 += 8;
          }
          else
          {
            *(_QWORD *)v6 = v35;
            ++v34;
          }
          v6 += 8;
          if (v28 == (char *)v32)
          {
            if (v34 != (uint64_t *)v33)
            {
              v40 = 0;
              do
              {
                *(_QWORD *)&v6[v40 * 8] = v34[v40];
                ++v40;
              }
              while (&v34[v40] != (uint64_t *)v33);
            }
            return result;
          }
        }
        if (v28 != (char *)v32)
        {
          v41 = 0;
          do
          {
            *(_QWORD *)&v6[v41] = *(_QWORD *)&v28[v41];
            v41 += 8;
          }
          while (&v28[v41] != (char *)v32);
        }
      }
      else
      {
        sub_1C546435C(result, v30, v31, a4, a5);
        sub_1C546435C(&v6[8 * (a3 >> 1)], a2, a3 - (a3 >> 1), v28, a5);
        return sub_1C546482C(v6, &v6[8 * (a3 >> 1)], a2, a3 >> 1, a3 - (a3 >> 1), v28, a5);
      }
    }
    else if (result != a2)
    {
      v13 = result + 8;
      if (result + 8 != a2)
      {
        v14 = 0;
        v15 = result;
        do
        {
          v16 = v13;
          v18 = *(_QWORD *)v15;
          v17 = *((_QWORD *)v15 + 1);
          v19 = *(_DWORD *)(v17 + 32);
          v20 = *(_DWORD *)(*(_QWORD *)v15 + 32);
          if (v19 < v20 || (v20 >= v19 ? (v21 = *(_DWORD *)(v17 + 36) >= *(_DWORD *)(v18 + 36)) : (v21 = 1), !v21))
          {
            *((_QWORD *)v15 + 1) = v18;
            v22 = result;
            if (v15 != result)
            {
              v23 = v14;
              while (1)
              {
                v24 = *(_QWORD *)&result[v23 - 8];
                v25 = *(_DWORD *)(v24 + 32);
                if (v19 >= v25 && (v25 < v19 || *(_DWORD *)(v17 + 36) >= *(_DWORD *)(v24 + 36)))
                  break;
                *(_QWORD *)&result[v23] = v24;
                v23 -= 8;
                if (!v23)
                {
                  v22 = result;
                  goto LABEL_28;
                }
              }
              v22 = &result[v23];
            }
LABEL_28:
            *(_QWORD *)v22 = v17;
          }
          v13 = v16 + 8;
          v14 += 8;
          v15 = v16;
        }
        while (v16 + 8 != a2);
      }
    }
  }
  return result;
}

uint64_t sub_1C54645DC(uint64_t result, uint64_t a2, unint64_t a3, uint64_t *a4)
{
  uint64_t *v4;
  uint64_t v6;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  BOOL v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  unsigned int v25;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  unsigned int v32;
  BOOL v33;
  uint64_t v34;
  uint64_t v35;

  if (a3)
  {
    v4 = a4;
    v6 = result;
    if (a3 == 1)
    {
LABEL_8:
      *v4 = *(_QWORD *)v6;
      return result;
    }
    if (a3 == 2)
    {
      v8 = *(_QWORD *)(a2 - 8);
      v9 = *(_DWORD *)(v8 + 32);
      v10 = *(_DWORD *)(*(_QWORD *)result + 32);
      if (v9 >= v10 && (v10 < v9 || *(_DWORD *)(v8 + 36) >= *(_DWORD *)(*(_QWORD *)result + 36)))
      {
        v8 = *(_QWORD *)result;
        v6 = a2 - 8;
      }
      *a4 = v8;
      v4 = a4 + 1;
      goto LABEL_8;
    }
    if ((uint64_t)a3 > 8)
    {
      v27 = result + 8 * (a3 >> 1);
      sub_1C546435C(result, v27, a3 >> 1, a4, a3 >> 1);
      result = sub_1C546435C(v6 + 8 * (a3 >> 1), a2, a3 - (a3 >> 1), &v4[a3 >> 1], a3 - (a3 >> 1));
      v28 = v6 + 8 * (a3 >> 1);
      while (v28 != a2)
      {
        v29 = *(_QWORD *)v28;
        v30 = *(_QWORD *)v6;
        v31 = *(_DWORD *)(*(_QWORD *)v28 + 32);
        v32 = *(_DWORD *)(*(_QWORD *)v6 + 32);
        if (v31 >= v32 && (v32 >= v31 ? (v33 = *(_DWORD *)(v29 + 36) >= *(_DWORD *)(v30 + 36)) : (v33 = 1), v33))
        {
          *v4 = v30;
          v6 += 8;
        }
        else
        {
          *v4 = v29;
          v28 += 8;
        }
        ++v4;
        if (v6 == v27)
        {
          if (v28 != a2)
          {
            v34 = 0;
            do
            {
              v4[v34] = *(_QWORD *)(v28 + v34 * 8);
              ++v34;
            }
            while (v28 + v34 * 8 != a2);
          }
          return result;
        }
      }
      if (v6 != v27)
      {
        v35 = 0;
        do
        {
          v4[v35] = *(_QWORD *)(v6 + v35 * 8);
          ++v35;
        }
        while (v6 + v35 * 8 != v27);
      }
    }
    else if (result != a2)
    {
      v11 = result + 8;
      *a4 = *(_QWORD *)result;
      if (result + 8 != a2)
      {
        v12 = 0;
        v13 = a4;
        v14 = a4;
        do
        {
          v16 = *v14++;
          v15 = v16;
          v17 = *(_QWORD *)v11;
          v18 = *(_DWORD *)(*(_QWORD *)v11 + 32);
          v19 = *(_DWORD *)(v16 + 32);
          if (v18 >= v19 && (v19 >= v18 ? (v20 = *(_DWORD *)(v17 + 36) >= *(_DWORD *)(v15 + 36)) : (v20 = 1), v20))
          {
            *v14 = v17;
          }
          else
          {
            v13[1] = v15;
            v21 = a4;
            if (v13 != a4)
            {
              v22 = v12;
              while (1)
              {
                v23 = *(uint64_t *)((char *)a4 + v22 - 8);
                v24 = *(_DWORD *)(*(_QWORD *)v11 + 32);
                v25 = *(_DWORD *)(v23 + 32);
                if (v24 >= v25 && (v25 < v24 || *(_DWORD *)(*(_QWORD *)v11 + 36) >= *(_DWORD *)(v23 + 36)))
                  break;
                *(uint64_t *)((char *)a4 + v22) = v23;
                v22 -= 8;
                if (!v22)
                {
                  v21 = a4;
                  goto LABEL_31;
                }
              }
              v21 = (uint64_t *)((char *)a4 + v22);
            }
LABEL_31:
            *v21 = *(_QWORD *)v11;
          }
          v11 += 8;
          v12 += 8;
          v13 = v14;
        }
        while (v11 != a2);
      }
    }
  }
  return result;
}

char *sub_1C546482C(char *result, char *a2, char *a3, uint64_t a4, uint64_t a5, char *a6, uint64_t a7)
{
  uint64_t v8;
  char *v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  unint64_t v20;
  uint64_t v21;
  unsigned int v22;
  unint64_t v23;
  char *v24;
  unsigned int v25;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  unsigned int v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unsigned int v34;
  unsigned int v35;
  BOOL v36;
  char *v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  char *v41;
  char *v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v46;
  unsigned int v47;
  BOOL v48;
  uint64_t v49;
  char *v50;
  uint64_t v51;
  uint64_t v52;
  unsigned int v53;
  unsigned int v54;
  BOOL v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;

  if (!a5)
    return result;
  v8 = a5;
  v11 = result;
  v58 = a6;
  while (a4 > a7 && v8 > a7)
  {
    if (!a4)
      return result;
    v12 = *(_QWORD *)a2;
    v13 = *(_DWORD *)(*(_QWORD *)a2 + 32);
    while (1)
    {
      v14 = *(_QWORD *)v11;
      v15 = *(_DWORD *)(*(_QWORD *)v11 + 32);
      if (v13 < v15)
        break;
      if (v15 >= v13 && *(_DWORD *)(v12 + 36) < *(_DWORD *)(v14 + 36))
        break;
      v11 += 8;
      if (!--a4)
        return result;
    }
    if (a4 >= v8)
    {
      if (a4 == 1)
      {
        *(_QWORD *)v11 = v12;
        *(_QWORD *)a2 = v14;
        return result;
      }
      if (a4 >= 0)
        v28 = a4;
      else
        v28 = a4 + 1;
      v27 = v28 >> 1;
      v19 = &v11[8 * (v28 >> 1)];
      v18 = 0;
      if (a3 == a2)
      {
        v37 = a3;
LABEL_52:
        v39 = v19;
        goto LABEL_56;
      }
      v29 = (a3 - a2) >> 3;
      v30 = *(_DWORD *)(*(_QWORD *)v19 + 32);
      do
      {
        v31 = v29 >> 1;
        v32 = v18 + (v29 >> 1);
        v33 = *(_QWORD *)&a2[8 * v32];
        v34 = *(_DWORD *)(v33 + 32);
        if (v34 < v30
          || ((v35 = *(_DWORD *)(v33 + 36), v30 >= v34) ? (v36 = v35 >= *(_DWORD *)(*(_QWORD *)v19 + 36)) : (v36 = 1),
              !v36))
        {
          v18 = v32 + 1;
          v31 = v29 + ~v31;
        }
        v29 = v31;
      }
      while (v31);
    }
    else
    {
      if (v8 >= 0)
        v17 = v8;
      else
        v17 = v8 + 1;
      v18 = v17 >> 1;
      v19 = a2;
      if (v11 != a2)
      {
        v20 = (a2 - v11) >> 3;
        v21 = *(_QWORD *)&a2[8 * v18];
        v22 = *(_DWORD *)(v21 + 32);
        v19 = v11;
        do
        {
          v23 = v20 >> 1;
          v24 = &v19[8 * (v20 >> 1)];
          v25 = *(_DWORD *)(*(_QWORD *)v24 + 32);
          if (v22 >= v25 && (v25 < v22 || *(_DWORD *)(v21 + 36) >= *(_DWORD *)(*(_QWORD *)v24 + 36)))
          {
            v19 = v24 + 8;
            v23 = v20 + ~v23;
          }
          v20 = v23;
        }
        while (v23);
      }
      v27 = (v19 - v11) >> 3;
    }
    v37 = &a2[8 * v18];
    v8 -= v18;
    if (v19 != a2)
    {
      if (v18)
      {
        if (v19 + 8 == a2)
        {
          v57 = *(_QWORD *)v19;
          memmove(v19, a2, 8 * v18);
          a6 = v58;
          v39 = &v19[8 * v18];
          *(_QWORD *)v39 = v57;
        }
        else
        {
          if (v18 == 1)
          {
            v38 = *((_QWORD *)v37 - 1);
            v39 = v19 + 8;
            if (v37 - 8 != v19)
              memmove(v19 + 8, v19, v37 - 8 - v19);
            *(_QWORD *)v19 = v38;
            v18 = 1;
          }
          else
          {
            v39 = (char *)sub_1C4E85DF0(v19, a2, &a2[8 * v18]);
          }
          a6 = v58;
        }
        goto LABEL_56;
      }
      goto LABEL_52;
    }
    v19 = a2;
    v39 = &a2[8 * v18];
LABEL_56:
    a4 -= v27;
    if (v18 + v27 >= a4 + v8)
    {
      result = (char *)sub_1C546482C(v39, v37, a3, a4, v8, a6, a7);
      v37 = v19;
      v8 = v18;
      a4 = v27;
      a3 = v39;
    }
    else
    {
      result = (char *)sub_1C546482C(v11, v19, v39, v27, v18, a6, a7);
      v11 = v39;
    }
    a2 = v37;
    a6 = v58;
    if (!v8)
      return result;
  }
  if (a4 <= v8)
  {
    if (v11 != a2)
    {
      v49 = 0;
      do
      {
        *(_QWORD *)&a6[v49] = *(_QWORD *)&v11[v49];
        v49 += 8;
      }
      while (&v11[v49] != a2);
      if (v49)
      {
        v50 = a6;
        while (a2 != a3)
        {
          v51 = *(_QWORD *)a2;
          v52 = *(_QWORD *)v50;
          v53 = *(_DWORD *)(*(_QWORD *)a2 + 32);
          v54 = *(_DWORD *)(*(_QWORD *)v50 + 32);
          if (v53 >= v54 && (v54 >= v53 ? (v55 = *(_DWORD *)(v51 + 36) >= *(_DWORD *)(v52 + 36)) : (v55 = 1), v55))
          {
            *(_QWORD *)v11 = v52;
            v50 += 8;
          }
          else
          {
            *(_QWORD *)v11 = v51;
            a2 += 8;
          }
          v11 += 8;
          if (&a6[v49] == v50)
            return result;
        }
        return (char *)memmove(v11, v50, a6 - v50 + v49);
      }
    }
  }
  else if (a2 != a3)
  {
    v40 = 0;
    do
    {
      *(_QWORD *)&a6[v40] = *(_QWORD *)&a2[v40];
      v40 += 8;
    }
    while (&a2[v40] != a3);
    if (v40)
    {
      v41 = &a6[v40];
      v42 = a3 - 8;
      while (a2 != v11)
      {
        v43 = a2 - 8;
        v44 = *((_QWORD *)a2 - 1);
        v45 = *((_QWORD *)v41 - 1);
        v46 = *(_DWORD *)(v45 + 32);
        v47 = *(_DWORD *)(v44 + 32);
        if (v46 >= v47)
        {
          v48 = v47 < v46 || *(_DWORD *)(v45 + 36) >= *(_DWORD *)(v44 + 36);
          if (v48)
            v44 = *((_QWORD *)v41 - 1);
          if (v48)
            v43 = a2;
          if (v48)
            v41 -= 8;
        }
        *(_QWORD *)v42 = v44;
        v42 -= 8;
        a2 = v43;
        if (v41 == a6)
          return result;
      }
      if (v41 != a6)
      {
        v56 = 0;
        do
        {
          *(_QWORD *)&v42[v56] = *(_QWORD *)&v41[v56 - 8];
          v56 -= 8;
        }
        while (&v41[v56] != a6);
      }
    }
  }
  return result;
}

void sub_1C5464C60(uint64_t a1, int a2, int a3, char a4)
{
  unint64_t v8;
  _DWORD *v9;
  char *v10;
  _DWORD *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  char *v17;
  char *v18;
  __int128 v19;
  char *v20;

  v9 = *(_DWORD **)(a1 + 8);
  v8 = *(_QWORD *)(a1 + 16);
  if ((unint64_t)v9 >= v8)
  {
    v11 = *(_DWORD **)a1;
    v12 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v9 - *(_QWORD *)a1) >> 3);
    v13 = v12 + 1;
    if (v12 + 1 > 0xAAAAAAAAAAAAAAALL)
      abort();
    v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v8 - (_QWORD)v11) >> 3);
    if (2 * v14 > v13)
      v13 = 2 * v14;
    if (v14 >= 0x555555555555555)
      v15 = 0xAAAAAAAAAAAAAAALL;
    else
      v15 = v13;
    if (v15 > 0xAAAAAAAAAAAAAAALL)
      sub_1C4764EE4();
    v16 = 3 * v15;
    v17 = (char *)operator new(24 * v15);
    v18 = &v17[24 * v12];
    *(_DWORD *)v18 = a2;
    *((_DWORD *)v18 + 1) = a3;
    *((_QWORD *)v18 + 1) = 0;
    v18[16] = 0;
    v18[17] = a4;
    v18[18] = 0;
    v10 = v18 + 24;
    if (v9 == v11)
    {
      v20 = &v17[24 * v12];
    }
    else
    {
      do
      {
        v19 = *(_OWORD *)(v9 - 6);
        v20 = v18 - 24;
        *(_DWORD *)(v18 - 9) = *(_DWORD *)((char *)v9 - 9);
        *(_OWORD *)(v18 - 24) = v19;
        v9 -= 6;
        v18 -= 24;
      }
      while (v9 != v11);
    }
    *(_QWORD *)a1 = v20;
    *(_QWORD *)(a1 + 8) = v10;
    *(_QWORD *)(a1 + 16) = &v17[8 * v16];
    if (v11)
      operator delete(v11);
  }
  else
  {
    *v9 = a2;
    v9[1] = a3;
    *((_QWORD *)v9 + 1) = 0;
    *((_BYTE *)v9 + 16) = 0;
    *((_BYTE *)v9 + 17) = a4;
    v10 = (char *)(v9 + 6);
    *((_BYTE *)v9 + 18) = 0;
  }
  *(_QWORD *)(a1 + 8) = v10;
}

void sub_1C5464DAC(void ***a1)
{
  void **v1;
  void **v2;
  void **v4;
  void *v5;

  v1 = *a1;
  v2 = (void **)**a1;
  if (v2)
  {
    v4 = (void **)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        if (*((char *)v4 - 9) < 0)
          operator delete(*(v4 - 4));
        v4 -= 4;
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t *sub_1C5464E24(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;

  v2 = *((unsigned int *)a1 + 4);
  v3 = *a1;
  if ((_DWORD)v2)
  {
    v4 = 24 * v2;
    v5 = (_QWORD *)(v3 + 24);
    do
    {
      if (*(v5 - 3) <= 0xFFFFFFFFFFFFFFFDLL)
      {
        v6 = (_QWORD *)*(v5 - 2);
        if (v5 != v6)
          free(v6);
      }
      v5 += 3;
      v4 -= 24;
    }
    while (v4);
    v3 = *a1;
  }
  MEMORY[0x1CAA32FB4](v3, 8);
  return a1;
}

void sub_1C5464E98(void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  void *v6;
  void *v7;
  void **v8;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = (void *)*((_QWORD *)v4 - 4);
        if (v6)
        {
          *((_QWORD *)v4 - 3) = v6;
          operator delete(v6);
        }
        v7 = (void *)*((_QWORD *)v4 - 7);
        if (v7)
        {
          *((_QWORD *)v4 - 6) = v7;
          operator delete(v7);
        }
        v8 = (void **)(v4 - 80);
        sub_1C4765410(&v8);
        if (*(v4 - 81) < 0)
          operator delete(*((void **)v4 - 13));
        v4 -= 104;
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1C5464F3C(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v3;

  v1 = *(unsigned int *)(result + 16);
  if ((_DWORD)v1)
  {
    v2 = 32 * v1;
    v3 = (_QWORD *)(*(_QWORD *)result + 8);
    do
    {
      if (*(v3 - 1) <= 0xFFFFFFFFFFFFFFFDLL)
        result = MEMORY[0x1CAA32FB4](*v3, 8);
      v3 += 4;
      v2 -= 32;
    }
    while (v2);
  }
  return result;
}

char *sub_1C5464F8C(uint64_t a1, int a2)
{
  int v3;
  _DWORD *v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unsigned int v8;
  char *result;
  int v10;
  char *v11;
  int64x2_t v12;

  v3 = *(_DWORD *)(a1 + 16);
  v4 = *(_DWORD **)a1;
  v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
    v8 = v7 + 1;
  else
    v8 = 64;
  *(_DWORD *)(a1 + 16) = v8;
  result = (char *)operator new(24 * v8, (std::align_val_t)4uLL);
  *(_QWORD *)a1 = result;
  if (v4)
  {
    sub_1C624B13C(a1, v4, &v4[6 * v3]);
    JUMPOUT(0x1CAA32FB4);
  }
  *(_QWORD *)(a1 + 8) = 0;
  v10 = *(_DWORD *)(a1 + 16);
  if (v10)
  {
    v11 = &result[24 * v10];
    v12 = vdupq_n_s64(0xFFFFFFFF00000001);
    do
    {
      *(_DWORD *)result = 0;
      *(int64x2_t *)(result + 4) = v12;
      result += 24;
    }
    while (result != v11);
  }
  return result;
}

uint64_t *sub_1C546505C(uint64_t *result, uint64_t *a2, uint64_t a3, char a4)
{
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unsigned int *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  unint64_t v17;
  uint64_t *v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t *v21;
  uint64_t v22;
  unsigned int v23;
  unsigned int v24;
  _QWORD *v25;
  BOOL v26;
  uint64_t v27;
  unsigned int v28;
  unint64_t v29;
  uint64_t *v30;
  unsigned int v31;
  uint64_t v32;
  unsigned int v33;
  unsigned int v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t *v44;
  BOOL v46;
  uint64_t v47;
  _DWORD *v48;
  unsigned int v49;
  unsigned int v50;
  uint64_t v51;
  uint64_t v52;
  unsigned int v53;
  _QWORD *v54;
  int64_t v55;
  int64_t v56;
  int64_t v57;
  uint64_t v58;
  unsigned int *v59;
  unsigned int v60;
  unsigned int v61;
  unsigned int *v62;
  uint64_t v63;
  unsigned int *v64;
  uint64_t v65;
  unsigned int v66;
  uint64_t v67;
  uint64_t v68;
  _QWORD *v69;
  uint64_t *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t *v75;
  uint64_t v76;
  uint64_t *v77;
  unsigned int v79;
  unsigned int v80;
  uint64_t v81;
  uint64_t *v82;
  uint64_t v83;

  v7 = (uint64_t)result;
LABEL_2:
  v8 = v7;
  while (2)
  {
    v7 = v8;
    v9 = (uint64_t)a2 - v8;
    v10 = (uint64_t)((uint64_t)a2 - v8) >> 3;
    switch(v10)
    {
      case 0:
      case 1:
        return result;
      case 2:
        if (*((_DWORD *)a2 - 2) < *(_DWORD *)v8)
        {
          v36 = *(_QWORD *)v8;
          *(_QWORD *)v8 = *(a2 - 1);
          *(a2 - 1) = v36;
        }
        return result;
      case 3:
        return sub_1C54656FC((uint64_t *)v8, (unsigned int *)(v8 + 8), (unsigned int *)a2 - 2);
      case 4:
        return sub_1C5465974((uint64_t *)v8, (unsigned int *)(v8 + 8), (unsigned int *)(v8 + 16), a2 - 1);
      case 5:
        v37 = (uint64_t *)(v8 + 16);
        v38 = (uint64_t *)(v8 + 24);
        result = sub_1C5465974((uint64_t *)v8, (unsigned int *)(v8 + 8), (unsigned int *)(v8 + 16), (_QWORD *)(v8 + 24));
        if (*((_DWORD *)a2 - 2) < *(_DWORD *)(v8 + 24))
        {
          v39 = *v38;
          *v38 = *(a2 - 1);
          *(a2 - 1) = v39;
          if (*(_DWORD *)v38 < *(_DWORD *)v37)
          {
            v40 = *v37;
            v41 = *v38;
            *v37 = *v38;
            *v38 = v40;
            if (*(_DWORD *)(v8 + 8) > v41)
            {
              v42 = *(_QWORD *)(v8 + 8);
              *(_QWORD *)(v8 + 8) = v41;
              *(_QWORD *)(v8 + 16) = v42;
              if (*(_DWORD *)v8 > v41)
              {
                v43 = *(_QWORD *)v8;
                *(_QWORD *)v8 = v41;
                *(_QWORD *)(v8 + 8) = v43;
              }
            }
          }
        }
        return result;
      default:
        if (v9 <= 191)
        {
          v44 = (uint64_t *)(v8 + 8);
          v46 = (uint64_t *)v8 == a2 || v44 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v46)
            {
              v47 = 0;
              v48 = (_DWORD *)v8;
              do
              {
                v49 = v48[2];
                v50 = *v48;
                v48 = v44;
                if (v49 < v50)
                {
                  v51 = *v44;
                  v52 = v47;
                  while (1)
                  {
                    *(_QWORD *)(v8 + v52 + 8) = *(_QWORD *)(v8 + v52);
                    if (!v52)
                      break;
                    v53 = *(_DWORD *)(v8 + v52 - 8);
                    v52 -= 8;
                    if (v53 <= v51)
                    {
                      v54 = (_QWORD *)(v8 + v52 + 8);
                      goto LABEL_76;
                    }
                  }
                  v54 = (_QWORD *)v8;
LABEL_76:
                  *v54 = v51;
                }
                v44 = (uint64_t *)(v48 + 2);
                v47 += 8;
              }
              while (v48 + 2 != (_DWORD *)a2);
            }
          }
          else if (!v46)
          {
            do
            {
              v79 = *(_DWORD *)(v7 + 8);
              v80 = *(_DWORD *)v7;
              v7 = (uint64_t)v44;
              if (v79 < v80)
              {
                v81 = *v44;
                do
                {
                  v82 = v44;
                  v83 = *--v44;
                  *v82 = v83;
                }
                while (*((_DWORD *)v82 - 4) > v81);
                *v44 = v81;
              }
              v44 = (uint64_t *)(v7 + 8);
            }
            while ((uint64_t *)(v7 + 8) != a2);
          }
          return result;
        }
        if (!a3)
        {
          if ((uint64_t *)v8 != a2)
          {
            v55 = (unint64_t)(v10 - 2) >> 1;
            v56 = v55;
            do
            {
              v57 = v56;
              if (v55 >= v56)
              {
                v58 = (2 * v56) | 1;
                v59 = (unsigned int *)(v8 + 8 * v58);
                if (2 * v57 + 2 >= v10)
                {
                  v60 = *v59;
                }
                else
                {
                  v60 = *v59;
                  v61 = v59[2];
                  if (*v59 <= v61)
                    v60 = v59[2];
                  if (*v59 < v61)
                  {
                    v59 += 2;
                    v58 = 2 * v57 + 2;
                  }
                }
                v62 = (unsigned int *)(v8 + 8 * v57);
                if (v60 >= *v62)
                {
                  v63 = *(_QWORD *)v62;
                  do
                  {
                    v64 = v62;
                    v62 = v59;
                    *(_QWORD *)v64 = *(_QWORD *)v59;
                    if (v55 < v58)
                      break;
                    v65 = (2 * v58) | 1;
                    v59 = (unsigned int *)(v8 + 8 * v65);
                    v58 = 2 * v58 + 2;
                    if (v58 >= v10)
                    {
                      v66 = *v59;
                      v58 = v65;
                    }
                    else
                    {
                      v66 = *v59;
                      result = (uint64_t *)v59[2];
                      if (*v59 <= result)
                        v66 = v59[2];
                      if (*v59 >= result)
                        v58 = v65;
                      else
                        v59 += 2;
                    }
                  }
                  while (v66 >= v63);
                  *(_QWORD *)v62 = v63;
                }
              }
              v56 = v57 - 1;
            }
            while (v57);
            do
            {
              v67 = 0;
              v68 = *(_QWORD *)v8;
              v69 = (_QWORD *)v8;
              do
              {
                v70 = &v69[v67 + 1];
                v71 = (2 * v67) | 1;
                v72 = 2 * v67 + 2;
                if (v72 < v10 && *(_DWORD *)v70 < *((_DWORD *)v70 + 2))
                {
                  ++v70;
                  v71 = v72;
                }
                *v69 = *v70;
                v69 = v70;
                v67 = v71;
              }
              while (v71 <= (uint64_t)((unint64_t)(v10 - 2) >> 1));
              if (v70 == --a2)
              {
                *v70 = v68;
              }
              else
              {
                *v70 = *a2;
                *a2 = v68;
                v73 = (uint64_t)v70 - v8 + 8;
                if (v73 >= 9)
                {
                  v74 = (((unint64_t)v73 >> 3) - 2) >> 1;
                  v75 = (uint64_t *)(v8 + 8 * v74);
                  if (*(_DWORD *)v75 < *(_DWORD *)v70)
                  {
                    v76 = *v70;
                    do
                    {
                      v77 = v70;
                      v70 = v75;
                      *v77 = *v75;
                      if (!v74)
                        break;
                      v74 = (v74 - 1) >> 1;
                      v75 = (uint64_t *)(v8 + 8 * v74);
                    }
                    while (*(_DWORD *)v75 < v76);
                    *v70 = v76;
                  }
                }
              }
            }
            while (v10-- > 2);
          }
          return result;
        }
        v11 = (unint64_t)v10 >> 1;
        v12 = (unsigned int *)(v8 + 8 * ((unint64_t)v10 >> 1));
        if ((unint64_t)v9 < 0x401)
        {
          result = sub_1C54656FC((uint64_t *)(v7 + 8 * ((unint64_t)v10 >> 1)), (unsigned int *)v7, (unsigned int *)a2 - 2);
        }
        else
        {
          sub_1C54656FC((uint64_t *)v7, (unsigned int *)(v7 + 8 * ((unint64_t)v10 >> 1)), (unsigned int *)a2 - 2);
          sub_1C54656FC((uint64_t *)(v7 + 8), v12 - 2, (unsigned int *)a2 - 4);
          sub_1C54656FC((uint64_t *)(v7 + 16), (unsigned int *)(v7 + 8 + 8 * v11), (unsigned int *)a2 - 6);
          result = sub_1C54656FC((uint64_t *)v12 - 1, v12, (unsigned int *)(v7 + 8 + 8 * v11));
          v13 = *(_QWORD *)v7;
          *(_QWORD *)v7 = *(_QWORD *)v12;
          *(_QWORD *)v12 = v13;
        }
        --a3;
        if ((a4 & 1) == 0 && *(_DWORD *)(v7 - 8) >= *(_DWORD *)v7)
        {
          v27 = *(_QWORD *)v7;
          if (*((_DWORD *)a2 - 2) <= *(_QWORD *)v7)
          {
            v29 = v7 + 8;
            do
            {
              v8 = v29;
              if (v29 >= (unint64_t)a2)
                break;
              v29 += 8;
            }
            while (*(_DWORD *)v8 <= v27);
          }
          else
          {
            v8 = v7;
            do
            {
              v28 = *(_DWORD *)(v8 + 8);
              v8 += 8;
            }
            while (v28 <= v27);
          }
          v30 = a2;
          if (v8 < (unint64_t)a2)
          {
            v30 = a2;
            do
              v31 = *((_DWORD *)v30-- - 2);
            while (v31 > v27);
          }
          while (v8 < (unint64_t)v30)
          {
            v32 = *(_QWORD *)v8;
            *(_QWORD *)v8 = *v30;
            *v30 = v32;
            do
            {
              v33 = *(_DWORD *)(v8 + 8);
              v8 += 8;
            }
            while (v33 <= v27);
            do
              v34 = *((_DWORD *)v30-- - 2);
            while (v34 > v27);
          }
          v35 = (_QWORD *)(v8 - 8);
          if (v8 - 8 != v7)
            *(_QWORD *)v7 = *v35;
          a4 = 0;
          *v35 = v27;
          continue;
        }
        v14 = 0;
        v15 = *(_QWORD *)v7;
        do
        {
          v16 = *(_DWORD *)(v7 + v14 + 8);
          v14 += 8;
        }
        while (v16 < v15);
        v17 = v7 + v14;
        v18 = a2;
        if (v14 == 8)
        {
          v18 = a2;
          do
          {
            if (v17 >= (unint64_t)v18)
              break;
            v20 = *((_DWORD *)v18-- - 2);
          }
          while (v20 >= v15);
        }
        else
        {
          do
            v19 = *((_DWORD *)v18-- - 2);
          while (v19 >= v15);
        }
        v8 = v7 + v14;
        if (v17 < (unint64_t)v18)
        {
          v21 = v18;
          do
          {
            v22 = *(_QWORD *)v8;
            *(_QWORD *)v8 = *v21;
            *v21 = v22;
            do
            {
              v23 = *(_DWORD *)(v8 + 8);
              v8 += 8;
            }
            while (v23 < v15);
            do
              v24 = *((_DWORD *)v21-- - 2);
            while (v24 >= v15);
          }
          while (v8 < (unint64_t)v21);
        }
        v25 = (_QWORD *)(v8 - 8);
        if (v8 - 8 != v7)
          *(_QWORD *)v7 = *v25;
        *v25 = v15;
        if (v17 < (unint64_t)v18)
        {
LABEL_30:
          result = (uint64_t *)sub_1C546505C(v7, v8 - 8, a3, a4 & 1);
          a4 = 0;
          continue;
        }
        v26 = sub_1C546578C(v7, (_QWORD *)(v8 - 8));
        result = (uint64_t *)sub_1C546578C(v8, a2);
        if (!(_DWORD)result)
        {
          if (v26)
            continue;
          goto LABEL_30;
        }
        a2 = (uint64_t *)(v8 - 8);
        if (!v26)
          goto LABEL_2;
        return result;
    }
  }
}

uint64_t *sub_1C54656FC(uint64_t *result, unsigned int *a2, unsigned int *a3)
{
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v3 = *a2;
  v4 = *a3;
  if (*a2 >= *(_DWORD *)result)
  {
    if (v4 < v3)
    {
      v6 = *(_QWORD *)a2;
      *(_QWORD *)a2 = *(_QWORD *)a3;
      *(_QWORD *)a3 = v6;
      if (*a2 < *(_DWORD *)result)
      {
        v7 = *result;
        *result = *(_QWORD *)a2;
        *(_QWORD *)a2 = v7;
      }
    }
  }
  else
  {
    v5 = *result;
    if (v4 >= v3)
    {
      *result = *(_QWORD *)a2;
      *(_QWORD *)a2 = v5;
      if (*a3 >= v5)
        return result;
      *(_QWORD *)a2 = *(_QWORD *)a3;
    }
    else
    {
      *result = *(_QWORD *)a3;
    }
    *(_QWORD *)a3 = v5;
  }
  return result;
}

BOOL sub_1C546578C(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  _BOOL8 result;
  uint64_t v6;
  _DWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  _QWORD *v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v4 = ((uint64_t)a2 - a1) >> 3;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (*((_DWORD *)a2 - 2) < *(_DWORD *)a1)
      {
        v6 = *(_QWORD *)a1;
        *(_QWORD *)a1 = *(a2 - 1);
        *(a2 - 1) = v6;
      }
      return result;
    case 3:
      sub_1C54656FC((uint64_t *)a1, (unsigned int *)(a1 + 8), (unsigned int *)a2 - 2);
      return 1;
    case 4:
      sub_1C5465974((uint64_t *)a1, (unsigned int *)(a1 + 8), (unsigned int *)(a1 + 16), a2 - 1);
      return 1;
    case 5:
      v15 = (uint64_t *)(a1 + 16);
      v16 = (uint64_t *)(a1 + 24);
      sub_1C5465974((uint64_t *)a1, (unsigned int *)(a1 + 8), (unsigned int *)(a1 + 16), (_QWORD *)(a1 + 24));
      if (*((_DWORD *)a2 - 2) < *(_DWORD *)(a1 + 24))
      {
        v17 = *v16;
        *v16 = *(a2 - 1);
        *(a2 - 1) = v17;
        if (*(_DWORD *)v16 < *(_DWORD *)v15)
        {
          v18 = *v15;
          v19 = *v16;
          *v15 = *v16;
          *v16 = v18;
          if (*(_DWORD *)(a1 + 8) > v19)
          {
            v20 = *(_QWORD *)(a1 + 8);
            *(_QWORD *)(a1 + 8) = v19;
            *(_QWORD *)(a1 + 16) = v20;
            if (*(_DWORD *)a1 > v19)
            {
              v21 = *(_QWORD *)a1;
              *(_QWORD *)a1 = v19;
              *(_QWORD *)(a1 + 8) = v21;
            }
          }
        }
      }
      return 1;
    default:
      v7 = (_DWORD *)(a1 + 16);
      sub_1C54656FC((uint64_t *)a1, (unsigned int *)(a1 + 8), (unsigned int *)(a1 + 16));
      v8 = (_QWORD *)(a1 + 24);
      if ((_QWORD *)(a1 + 24) == a2)
        return 1;
      v9 = 0;
      v10 = 0;
      break;
  }
  while (1)
  {
    if (*(_DWORD *)v8 < *v7)
    {
      v11 = *v8;
      v12 = v9;
      while (1)
      {
        *(_QWORD *)(a1 + v12 + 24) = *(_QWORD *)(a1 + v12 + 16);
        if (v12 == -16)
          break;
        v13 = *(_DWORD *)(a1 + v12 + 8);
        v12 -= 8;
        if (v13 <= v11)
        {
          v14 = (_QWORD *)(a1 + v12 + 24);
          goto LABEL_13;
        }
      }
      v14 = (_QWORD *)a1;
LABEL_13:
      *v14 = v11;
      if (++v10 == 8)
        return v8 + 1 == a2;
    }
    v7 = v8;
    v9 += 8;
    if (++v8 == a2)
      return 1;
  }
}

uint64_t *sub_1C5465974(uint64_t *a1, unsigned int *a2, unsigned int *a3, _QWORD *a4)
{
  uint64_t *result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  result = sub_1C54656FC(a1, a2, a3);
  if (*(_DWORD *)a4 < *a3)
  {
    v9 = *(_QWORD *)a3;
    *(_QWORD *)a3 = *a4;
    *a4 = v9;
    if (*a3 < *a2)
    {
      v10 = *(_QWORD *)a2;
      *(_QWORD *)a2 = *(_QWORD *)a3;
      *(_QWORD *)a3 = v10;
      if (*a2 < *(_DWORD *)a1)
      {
        v11 = *a1;
        *a1 = *(_QWORD *)a2;
        *(_QWORD *)a2 = v11;
      }
    }
  }
  return result;
}

uint64_t sub_1C5465A08(uint64_t a1, int a2, uint64_t a3, _QWORD *a4)
{
  int v4;
  unsigned int v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v10;
  int v11;
  BOOL v12;
  unsigned int v13;

  if (a2)
  {
    v4 = a2 - 1;
    v5 = (37 * a3) & (a2 - 1);
    v6 = (_QWORD *)(a1 + 24 * v5);
    v7 = *v6;
    if (*v6 == a3)
    {
      v8 = 1;
    }
    else
    {
      v10 = 0;
      v11 = 1;
      while (v7 != -1)
      {
        if (v10)
          v12 = 0;
        else
          v12 = v7 == -2;
        if (v12)
          v10 = v6;
        v13 = v5 + v11++;
        v5 = v13 & v4;
        v6 = (_QWORD *)(a1 + 24 * (v13 & v4));
        v7 = *v6;
        v8 = 1;
        if (*v6 == a3)
          goto LABEL_5;
      }
      v8 = 0;
      if (v10)
        v6 = v10;
    }
  }
  else
  {
    v6 = 0;
    v8 = 0;
  }
LABEL_5:
  *a4 = v6;
  return v8;
}

uint64_t sub_1C5465AA0(uint64_t a1)
{
  void **v2;
  void **v3;
  void **v4;

  v3 = *(void ***)(a1 + 8);
  v2 = *(void ***)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      v4 = v2 - 4;
      *(_QWORD *)(a1 + 16) = v2 - 4;
      if (*((char *)v2 - 9) < 0)
      {
        operator delete(*v4);
        v4 = *(void ***)(a1 + 16);
      }
      v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

_QWORD *sub_1C5465B00(uint64_t *a1, int a2)
{
  uint64_t v3;
  uint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unsigned int v8;
  _QWORD *result;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  BOOL v23;
  int v24;
  uint64_t v25;
  uint64_t v26;

  v3 = *((unsigned int *)a1 + 4);
  v4 = (uint64_t *)*a1;
  v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
    v8 = v7 + 1;
  else
    v8 = 64;
  *((_DWORD *)a1 + 4) = v8;
  result = operator new(32 * v8, (std::align_val_t)8uLL);
  *a1 = (uint64_t)result;
  if (v4)
  {
    a1[1] = 0;
    v10 = *((unsigned int *)a1 + 4);
    if ((_DWORD)v10)
    {
      v11 = 32 * v10;
      do
      {
        *result = -1;
        result += 4;
        v11 -= 32;
      }
      while (v11);
    }
    if ((_DWORD)v3)
    {
      v12 = v4;
      v13 = &v4[4 * v3];
      do
      {
        v14 = *v12;
        if ((unint64_t)*v12 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          v15 = *((_DWORD *)a1 + 4) - 1;
          v16 = v15 & (37 * v14);
          v17 = *a1 + 32 * v16;
          v18 = *(_QWORD *)v17;
          if (v14 != *(_QWORD *)v17)
          {
            v21 = 0;
            v22 = 1;
            while (v18 != -1)
            {
              if (v21)
                v23 = 0;
              else
                v23 = v18 == -2;
              if (v23)
                v21 = v17;
              v24 = v16 + v22++;
              v16 = v24 & v15;
              v17 = *a1 + 32 * v16;
              v18 = *(_QWORD *)v17;
              if (v14 == *(_QWORD *)v17)
                goto LABEL_12;
            }
            if (v21)
              v17 = v21;
          }
LABEL_12:
          *(_QWORD *)(v17 + 8) = 0;
          *(_QWORD *)(v17 + 16) = 0;
          *(_QWORD *)v17 = v14;
          *(_DWORD *)(v17 + 24) = 0;
          *(_QWORD *)(v17 + 8) = v12[1];
          v12[1] = 0;
          *(_DWORD *)(v17 + 16) = *((_DWORD *)v12 + 4);
          *((_DWORD *)v12 + 4) = 0;
          v19 = *(_DWORD *)(v17 + 20);
          *(_DWORD *)(v17 + 20) = *((_DWORD *)v12 + 5);
          *((_DWORD *)v12 + 5) = v19;
          v20 = *(_DWORD *)(v17 + 24);
          *(_DWORD *)(v17 + 24) = *((_DWORD *)v12 + 6);
          *((_DWORD *)v12 + 6) = v20;
          ++*((_DWORD *)a1 + 2);
          MEMORY[0x1CAA32FB4](0, 8);
        }
        v12 += 4;
      }
      while (v12 != v13);
    }
    JUMPOUT(0x1CAA32FB4);
  }
  a1[1] = 0;
  v25 = *((unsigned int *)a1 + 4);
  if ((_DWORD)v25)
  {
    v26 = 32 * v25;
    do
    {
      *result = -1;
      result += 4;
      v26 -= 32;
    }
    while (v26);
  }
  return result;
}

char *sub_1C5465CCC(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unsigned int v8;
  char *result;
  char *v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned int v16;
  char *v17;
  uint64_t v18;
  char *v19;
  int v20;
  BOOL v21;
  unsigned int v22;
  uint64_t v23;

  v3 = *(unsigned int *)(a1 + 16);
  v4 = *(uint64_t **)a1;
  v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
    v8 = v7 + 1;
  else
    v8 = 64;
  *(_DWORD *)(a1 + 16) = v8;
  result = (char *)operator new(8 * v8, (std::align_val_t)8uLL);
  v10 = result;
  *(_QWORD *)a1 = result;
  if (v4)
  {
    *(_QWORD *)(a1 + 8) = 0;
    v11 = *(unsigned int *)(a1 + 16);
    if ((_DWORD)v11)
      memset(result, 255, 8 * v11);
    if ((_DWORD)v3)
    {
      v12 = 0;
      v13 = v11 - 1;
      v14 = v4;
      do
      {
        v15 = *v14;
        if ((unint64_t)*v14 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          v16 = (37 * v15) & v13;
          v17 = &v10[8 * v16];
          v18 = *(_QWORD *)v17;
          if (v15 != *(_QWORD *)v17)
          {
            v19 = 0;
            v20 = 1;
            while (v18 != -1)
            {
              if (v19)
                v21 = 0;
              else
                v21 = v18 == -2;
              if (v21)
                v19 = v17;
              v22 = v16 + v20++;
              v16 = v22 & v13;
              v17 = &v10[8 * (v22 & v13)];
              v18 = *(_QWORD *)v17;
              if (v15 == *(_QWORD *)v17)
                goto LABEL_11;
            }
            if (v19)
              v17 = v19;
          }
LABEL_11:
          *(_QWORD *)v17 = v15;
          *(_DWORD *)(a1 + 8) = ++v12;
        }
        ++v14;
      }
      while (v14 != &v4[v3]);
    }
    JUMPOUT(0x1CAA32FB4);
  }
  *(_QWORD *)(a1 + 8) = 0;
  v23 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v23)
    return (char *)memset(result, 255, 8 * v23);
  return result;
}

__n128 sub_1C5465E50(uint64_t a1, __int128 *a2)
{
  __int128 v2;
  __n128 result;
  uint64_t v4;

  v2 = *a2;
  *(_QWORD *)(a1 + 16) = *((_QWORD *)a2 + 2);
  *(_OWORD *)a1 = v2;
  *((_QWORD *)a2 + 1) = 0;
  *((_QWORD *)a2 + 2) = 0;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + 24) = *(__int128 *)((char *)a2 + 24);
  *(_QWORD *)(a1 + 40) = *((_QWORD *)a2 + 5);
  *((_QWORD *)a2 + 3) = 0;
  *((_QWORD *)a2 + 4) = 0;
  *((_QWORD *)a2 + 5) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 48) = a2[3];
  *(_QWORD *)(a1 + 64) = *((_QWORD *)a2 + 8);
  *((_QWORD *)a2 + 6) = 0;
  *((_QWORD *)a2 + 7) = 0;
  *((_QWORD *)a2 + 8) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  result = *(__n128 *)((char *)a2 + 72);
  *(__n128 *)(a1 + 72) = result;
  v4 = *((_QWORD *)a2 + 12);
  *(_QWORD *)(a1 + 88) = *((_QWORD *)a2 + 11);
  *((_QWORD *)a2 + 9) = 0;
  *((_QWORD *)a2 + 10) = 0;
  *((_QWORD *)a2 + 11) = 0;
  *(_QWORD *)(a1 + 96) = v4;
  return result;
}

_QWORD *sub_1C5465ED0(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unsigned int v8;
  _QWORD *result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  void *v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;

  v3 = *(unsigned int *)(a1 + 16);
  v4 = *(_QWORD *)a1;
  v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
    v8 = v7 + 1;
  else
    v8 = 64;
  *(_DWORD *)(a1 + 16) = v8;
  result = operator new(24 * v8, (std::align_val_t)8uLL);
  *(_QWORD *)a1 = result;
  if (v4)
  {
    *(_QWORD *)(a1 + 8) = 0;
    v10 = *(unsigned int *)(a1 + 16);
    if ((_DWORD)v10)
    {
      v11 = 24 * v10;
      do
      {
        *result = -1;
        result += 3;
        v11 -= 24;
      }
      while (v11);
    }
    if ((_DWORD)v3)
    {
      v12 = 24 * v3;
      v13 = v4;
      do
      {
        v14 = *(_QWORD *)v13;
        if (*(_QWORD *)v13 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          v22 = 0;
          sub_1C5465A08(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), v14, &v22);
          v15 = v22;
          *v22 = *(_QWORD *)v13;
          v15[1] = v15 + 3;
          v15[2] = 0;
          v16 = *(void **)(v13 + 8);
          if ((_QWORD *)v13 != v15)
          {
            v17 = *(_DWORD *)(v13 + 16);
            if (v17)
            {
              if ((void *)(v13 + 24) == v16)
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v15 + 1), (uint64_t)(v15 + 3), *(unsigned int *)(v13 + 16), 4);
                v18 = *(unsigned int *)(v13 + 16);
                if ((_DWORD)v18)
                  memcpy((void *)v15[1], *(const void **)(v13 + 8), 4 * v18);
                *((_DWORD *)v15 + 4) = v17;
                v16 = *(void **)(v13 + 8);
              }
              else
              {
                v15[1] = v16;
                v19 = *(_DWORD *)(v13 + 20);
                *((_DWORD *)v15 + 4) = v17;
                *((_DWORD *)v15 + 5) = v19;
                *(_QWORD *)(v13 + 8) = v13 + 24;
                *(_DWORD *)(v13 + 20) = 0;
                v16 = (void *)(v13 + 24);
              }
              *(_DWORD *)(v13 + 16) = 0;
            }
          }
          ++*(_DWORD *)(a1 + 8);
          if ((void *)(v13 + 24) != v16)
            free(v16);
        }
        v13 += 24;
        v12 -= 24;
      }
      while (v12);
    }
    JUMPOUT(0x1CAA32FB4);
  }
  *(_QWORD *)(a1 + 8) = 0;
  v20 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v20)
  {
    v21 = 24 * v20;
    do
    {
      *result = -1;
      result += 3;
      v21 -= 24;
    }
    while (v21);
  }
  return result;
}

_QWORD *sub_1C54660B0()
{
  _QWORD *result;

  result = (_QWORD *)operator new();
  *result = &off_1E8169078;
  return result;
}

uint64_t sub_1C54660E4(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1C54660FC(std::error_category *a1)
{
  std::error_category::~error_category(a1);
  JUMPOUT(0x1CAA32FC0);
}

const char *sub_1C5466120()
{
  return "llvm.coveragemap";
}

void sub_1C546612C(int a1@<W1>, uint64_t a2@<X8>)
{
  sub_1C54613D0(a2, a1);
}

_QWORD *llvm::coverage::CoverageFilenamesSectionWriter::CoverageFilenamesSectionWriter(_QWORD *result, uint64_t a2, uint64_t a3)
{
  *result = a2;
  result[1] = a3;
  return result;
}

{
  *result = a2;
  result[1] = a3;
  return result;
}

void llvm::coverage::CoverageFilenamesSectionWriter::write(llvm::coverage::CoverageFilenamesSectionWriter *this, llvm::raw_ostream *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  char v8;
  char *v9;
  BOOL v10;
  char v11;
  BOOL v12;
  const char *v13;
  size_t v14;
  size_t v15;
  unint64_t v16;
  char v17;
  char *v18;
  unint64_t v19;
  char v20;
  char *v21;
  _BYTE *v22;
  const void *v23;
  size_t v24;
  void *v25;
  void *__p;
  unint64_t v27;
  uint64_t v28;
  void *v29;
  __int128 v30;
  unint64_t v31;
  char *v32;
  char v33;
  uint64_t v34;
  int v35;
  void **p_p;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  __p = 0;
  v27 = 0;
  v28 = 0;
  LODWORD(v30) = 0;
  v33 = 0;
  v34 = 0;
  v29 = &unk_1E81A7208;
  p_p = &__p;
  v35 = 0;
  v31 = 0;
  v32 = 0;
  *((_QWORD *)&v30 + 1) = 0;
  v4 = *((_QWORD *)this + 1);
  if (v4)
  {
    v5 = *(_QWORD *)this;
    v6 = *(_QWORD *)this + 24 * v4;
    do
    {
      if (*(char *)(v5 + 23) < 0)
        v7 = *(_QWORD *)(v5 + 8);
      else
        v7 = *(unsigned __int8 *)(v5 + 23);
      do
      {
        v8 = v7 & 0x7F | ((v7 > 0x7F) << 7);
        v9 = v32;
        if ((unint64_t)v32 >= v31)
        {
          llvm::raw_ostream::write((llvm::raw_ostream *)&v29, v8);
        }
        else
        {
          ++v32;
          *v9 = v8;
        }
        v10 = v7 > 0x7F;
        v7 >>= 7;
      }
      while (v10);
      v11 = *(_BYTE *)(v5 + 23);
      v12 = v11 < 0;
      if (v11 >= 0)
        v13 = (const char *)v5;
      else
        v13 = *(const char **)v5;
      v14 = v11 & 0x7F;
      if (v12)
        v15 = *(_QWORD *)(v5 + 8);
      else
        v15 = v14;
      llvm::raw_ostream::write((llvm::raw_ostream *)&v29, v13, v15);
      v5 += 24;
    }
    while (v5 != v6);
    v29 = off_1E81A6E70;
    if (v35 == 1)
    {
      if (*((_QWORD *)&v30 + 1))
        MEMORY[0x1CAA32F9C](*((_QWORD *)&v30 + 1), 0x1000C8077774924);
    }
  }
  v29 = &v31;
  v30 = xmmword_1C85F20B0;
  v16 = *((_QWORD *)this + 1);
  do
  {
    v17 = v16 & 0x7F | ((v16 > 0x7F) << 7);
    v18 = (char *)*((_QWORD *)a2 + 4);
    if ((unint64_t)v18 >= *((_QWORD *)a2 + 3))
    {
      llvm::raw_ostream::write(a2, v17);
    }
    else
    {
      *((_QWORD *)a2 + 4) = v18 + 1;
      *v18 = v17;
    }
    v10 = v16 > 0x7F;
    v16 >>= 7;
  }
  while (v10);
  if (v28 >= 0)
    v19 = HIBYTE(v28) & 0x7F;
  else
    v19 = v27;
  do
  {
    v20 = v19 & 0x7F | ((v19 > 0x7F) << 7);
    v21 = (char *)*((_QWORD *)a2 + 4);
    if ((unint64_t)v21 >= *((_QWORD *)a2 + 3))
    {
      llvm::raw_ostream::write(a2, v20);
    }
    else
    {
      *((_QWORD *)a2 + 4) = v21 + 1;
      *v21 = v20;
    }
    v10 = v19 > 0x7F;
    v19 >>= 7;
  }
  while (v10);
  v22 = (_BYTE *)*((_QWORD *)a2 + 4);
  if ((unint64_t)v22 >= *((_QWORD *)a2 + 3))
  {
    llvm::raw_ostream::write(a2, 0);
  }
  else
  {
    *((_QWORD *)a2 + 4) = v22 + 1;
    *v22 = 0;
  }
  if (v28 >= 0)
    v23 = &__p;
  else
    v23 = __p;
  if (v28 >= 0)
    v24 = HIBYTE(v28) & 0x7F;
  else
    v24 = v27;
  v25 = (void *)*((_QWORD *)a2 + 4);
  if (v24 <= *((_QWORD *)a2 + 3) - (_QWORD)v25)
  {
    if (v24)
    {
      memcpy(v25, v23, v24);
      *((_QWORD *)a2 + 4) += v24;
    }
  }
  else
  {
    llvm::raw_ostream::write(a2, (const char *)v23, v24);
  }
  if (v29 != &v31)
    free(v29);
  if (SHIBYTE(v28) < 0)
    operator delete(__p);
}

void llvm::coverage::CoverageMappingWriter::write(llvm::coverage::CoverageMappingWriter *this, llvm::raw_ostream *a2, __n128 a3)
{
  int64_t v5;
  __n128 *v6;
  const std::nothrow_t *v7;
  unint64_t v8;
  void *v9;
  BOOL v10;
  void *v11;
  unint64_t v12;
  char v13;
  char *v14;
  uint64_t v15;
  unsigned int *v16;
  uint64_t v17;
  unint64_t v18;
  char v19;
  char *v20;
  unint64_t v21;
  unint64_t *v22;
  uint64_t v23;
  unint64_t *v24;
  unint64_t *v25;
  char *v26;
  int v27;
  unint64_t v28;
  char v29;
  char *v30;
  char *v31;
  char *v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  char v36;
  char *v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  char v41;
  char *v42;
  uint64_t v43;
  int v44;
  uint64_t *v45;
  uint64_t *v46;
  uint64_t v47;
  int v48;
  int v49;
  uint64_t v50;
  unsigned int v51;
  unint64_t v52;
  char v53;
  char *v54;
  uint64_t v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  char v60;
  char *v61;
  unint64_t v62;
  char v63;
  char *v64;
  _BYTE *v65;
  _BYTE *v66;
  unint64_t v67;
  char v68;
  char *v69;
  unint64_t v70;
  char v71;
  char *v72;
  unint64_t v73;
  char v74;
  char *v75;
  unint64_t v76;
  char v77;
  char *v78;
  unint64_t v79;
  char v80;
  char *v81;
  unint64_t v82;
  char v83;
  char *v84;
  char *v85;
  int v86;
  uint64_t v87[2];
  void *v88;
  uint64_t v89;
  _BYTE v90[320];
  _DWORD *v91;
  _DWORD *v92;
  uint64_t v93;
  uint64_t v94;

  v94 = *MEMORY[0x1E0C80C00];
  v6 = (__n128 *)*((_QWORD *)this + 4);
  v5 = *((_QWORD *)this + 5);
  if (v5 < 129)
  {
LABEL_5:
    sub_1C5466D98(v6, (__n128 *)((char *)v6 + 44 * v5), v5, 0, 0, a3);
  }
  else
  {
    v7 = (const std::nothrow_t *)MEMORY[0x1E0DE4E10];
    v8 = *((_QWORD *)this + 5);
    while (1)
    {
      v9 = operator new(44 * v8, v7);
      if (v9)
        break;
      v10 = v8 > 1;
      v8 >>= 1;
      if (!v10)
        goto LABEL_5;
    }
    v11 = v9;
    sub_1C5466D98(v6, (__n128 *)((char *)v6 + 44 * v5), v5, (uint64_t)v9, v8, a3);
    operator delete(v11);
  }
  v12 = *((_QWORD *)this + 1);
  do
  {
    v13 = v12 & 0x7F | ((v12 > 0x7F) << 7);
    v14 = (char *)*((_QWORD *)a2 + 4);
    if ((unint64_t)v14 >= *((_QWORD *)a2 + 3))
    {
      llvm::raw_ostream::write(a2, v13);
    }
    else
    {
      *((_QWORD *)a2 + 4) = v14 + 1;
      *v14 = v13;
    }
    v10 = v12 > 0x7F;
    v12 >>= 7;
  }
  while (v10);
  v15 = *((_QWORD *)this + 1);
  if (v15)
  {
    v16 = *(unsigned int **)this;
    v17 = *(_QWORD *)this + 4 * v15;
    do
    {
      v18 = *v16;
      do
      {
        v19 = v18 & 0x7F | ((v18 > 0x7F) << 7);
        v20 = (char *)*((_QWORD *)a2 + 4);
        if ((unint64_t)v20 >= *((_QWORD *)a2 + 3))
        {
          llvm::raw_ostream::write(a2, v19);
        }
        else
        {
          *((_QWORD *)a2 + 4) = v20 + 1;
          *v20 = v19;
        }
        v10 = v18 > 0x7F;
        v18 >>= 7;
      }
      while (v10);
      ++v16;
    }
    while (v16 != (unsigned int *)v17);
  }
  v21 = *((_QWORD *)this + 3);
  v22 = (unint64_t *)*((_QWORD *)this + 4);
  v23 = *((_QWORD *)this + 5);
  v87[0] = *((_QWORD *)this + 2);
  v87[1] = v21;
  v88 = v90;
  v89 = 0x1000000000;
  v92 = 0;
  v93 = 0;
  v91 = 0;
  v86 = 0;
  if (v21)
    sub_1C50F0728((uint64_t)&v91, v21, &v86);
  if (v23)
  {
    v24 = (unint64_t *)((char *)v22 + 44 * v23);
    v25 = v22;
    do
    {
      sub_1C5466C24(v87, *v25);
      sub_1C5466C24(v87, v25[1]);
      v25 = (unint64_t *)((char *)v25 + 44);
    }
    while (v25 != v24);
    do
    {
      sub_1C5466C90((uint64_t)v87, *v22);
      sub_1C5466C90((uint64_t)v87, v22[1]);
      v22 = (unint64_t *)((char *)v22 + 44);
    }
    while (v22 != v24);
  }
  v26 = (char *)v88;
  v27 = v89;
  v28 = v89;
  do
  {
    v29 = v28 & 0x7F | ((v28 > 0x7F) << 7);
    v30 = (char *)*((_QWORD *)a2 + 4);
    if ((unint64_t)v30 >= *((_QWORD *)a2 + 3))
    {
      llvm::raw_ostream::write(a2, v29);
    }
    else
    {
      *((_QWORD *)a2 + 4) = v30 + 1;
      *v30 = v29;
    }
    v10 = v28 > 0x7F;
    v28 >>= 7;
  }
  while (v10);
  if (v27)
  {
    v31 = &v26[20 * v27];
    v32 = v26;
    do
    {
      v33 = *(_QWORD *)(v32 + 4);
      v34 = HIDWORD(v33);
      if ((_DWORD)v33 == 2)
      {
        LODWORD(v34) = v91[v34];
        LODWORD(v33) = *(_DWORD *)&v26[20 * v34] + 2;
      }
      v35 = v33 | (4 * (_DWORD)v34);
      do
      {
        v36 = v35 & 0x7F | ((v35 > 0x7F) << 7);
        v37 = (char *)*((_QWORD *)a2 + 4);
        if ((unint64_t)v37 >= *((_QWORD *)a2 + 3))
        {
          llvm::raw_ostream::write(a2, v36);
        }
        else
        {
          *((_QWORD *)a2 + 4) = v37 + 1;
          *v37 = v36;
        }
        v10 = v35 > 0x7F;
        v35 >>= 7;
      }
      while (v10);
      v38 = *(_QWORD *)(v32 + 12);
      v39 = HIDWORD(v38);
      if ((_DWORD)v38 == 2)
      {
        LODWORD(v39) = v91[v39];
        LODWORD(v38) = *(_DWORD *)&v26[20 * v39] + 2;
      }
      v40 = v38 | (4 * (_DWORD)v39);
      do
      {
        v41 = v40 & 0x7F | ((v40 > 0x7F) << 7);
        v42 = (char *)*((_QWORD *)a2 + 4);
        if ((unint64_t)v42 >= *((_QWORD *)a2 + 3))
        {
          llvm::raw_ostream::write(a2, v41);
        }
        else
        {
          *((_QWORD *)a2 + 4) = v42 + 1;
          *v42 = v41;
        }
        v10 = v40 > 0x7F;
        v40 >>= 7;
      }
      while (v10);
      v32 += 20;
    }
    while (v32 != v31);
  }
  v85 = v26;
  v43 = *((_QWORD *)this + 5);
  if (v43)
  {
    v44 = 0;
    v45 = (uint64_t *)*((_QWORD *)this + 4);
    v46 = (uint64_t *)((char *)v45 + 44 * v43);
    v47 = 44 * v43 - 44;
    v48 = -1;
    do
    {
      v49 = *((_DWORD *)v45 + 4);
      if (v49 != v48)
      {
        if ((uint64_t *)((char *)v45 + 44) == v46)
        {
          v51 = 1;
        }
        else
        {
          v50 = 0;
          v51 = 1;
          do
          {
            if (v49 != *(_DWORD *)((char *)v45 + v50 + 60))
              break;
            ++v51;
            v50 += 44;
          }
          while (v47 != v50);
        }
        v52 = v51;
        do
        {
          v53 = v52 & 0x7F | ((v52 > 0x7F) << 7);
          v54 = (char *)*((_QWORD *)a2 + 4);
          if ((unint64_t)v54 >= *((_QWORD *)a2 + 3))
          {
            llvm::raw_ostream::write(a2, v53);
          }
          else
          {
            *((_QWORD *)a2 + 4) = v54 + 1;
            *v54 = v53;
          }
          v10 = v52 > 0x7F;
          v52 >>= 7;
        }
        while (v10);
        v44 = 0;
        v48 = *((_DWORD *)v45 + 4);
      }
      v55 = *v45;
      v56 = HIDWORD(*v45);
      if (*v45 == 2)
      {
        LODWORD(v56) = v91[v56];
        LODWORD(v55) = 2;
      }
      v57 = v45[1];
      v58 = HIDWORD(v57);
      if ((_DWORD)v57 == 2)
      {
        LODWORD(v58) = v91[v58];
        LODWORD(v57) = 2;
      }
      switch(*((_DWORD *)v45 + 10))
      {
        case 0:
        case 3:
          if ((_DWORD)v55 == 2)
            LODWORD(v55) = *(_DWORD *)&v85[20 * v56] + 2;
          v59 = v55 | (4 * (_DWORD)v56);
          do
          {
            v60 = v59 & 0x7F | ((v59 > 0x7F) << 7);
            v61 = (char *)*((_QWORD *)a2 + 4);
            if ((unint64_t)v61 >= *((_QWORD *)a2 + 3))
            {
              llvm::raw_ostream::write(a2, v60);
            }
            else
            {
              *((_QWORD *)a2 + 4) = v61 + 1;
              *v61 = v60;
            }
            v10 = v59 > 0x7F;
            v59 >>= 7;
          }
          while (v10);
          break;
        case 1:
          v62 = (8 * *((_DWORD *)v45 + 5)) | 4u;
          do
          {
            v63 = v62 & 0x7F | ((v62 > 0x7F) << 7);
            v64 = (char *)*((_QWORD *)a2 + 4);
            if ((unint64_t)v64 >= *((_QWORD *)a2 + 3))
            {
              llvm::raw_ostream::write(a2, v63);
            }
            else
            {
              *((_QWORD *)a2 + 4) = v64 + 1;
              *v64 = v63;
            }
            v10 = v62 > 0x7F;
            v62 >>= 7;
          }
          while (v10);
          break;
        case 2:
          v65 = (_BYTE *)*((_QWORD *)a2 + 4);
          if ((unint64_t)v65 >= *((_QWORD *)a2 + 3))
          {
            llvm::raw_ostream::write(a2, 16);
          }
          else
          {
            *((_QWORD *)a2 + 4) = v65 + 1;
            *v65 = 16;
          }
          break;
        case 4:
          v66 = (_BYTE *)*((_QWORD *)a2 + 4);
          if ((unint64_t)v66 >= *((_QWORD *)a2 + 3))
          {
            llvm::raw_ostream::write(a2, 32);
          }
          else
          {
            *((_QWORD *)a2 + 4) = v66 + 1;
            *v66 = 32;
          }
          if ((_DWORD)v55 == 2)
            LODWORD(v55) = *(_DWORD *)&v85[20 * v56] + 2;
          v67 = v55 | (4 * (_DWORD)v56);
          do
          {
            v68 = v67 & 0x7F | ((v67 > 0x7F) << 7);
            v69 = (char *)*((_QWORD *)a2 + 4);
            if ((unint64_t)v69 >= *((_QWORD *)a2 + 3))
            {
              llvm::raw_ostream::write(a2, v68);
            }
            else
            {
              *((_QWORD *)a2 + 4) = v69 + 1;
              *v69 = v68;
            }
            v10 = v67 > 0x7F;
            v67 >>= 7;
          }
          while (v10);
          if ((_DWORD)v57 == 2)
            LODWORD(v57) = *(_DWORD *)&v85[20 * v58] + 2;
          v70 = v57 | (4 * (_DWORD)v58);
          do
          {
            v71 = v70 & 0x7F | ((v70 > 0x7F) << 7);
            v72 = (char *)*((_QWORD *)a2 + 4);
            if ((unint64_t)v72 >= *((_QWORD *)a2 + 3))
            {
              llvm::raw_ostream::write(a2, v71);
            }
            else
            {
              *((_QWORD *)a2 + 4) = v72 + 1;
              *v72 = v71;
            }
            v10 = v70 > 0x7F;
            v70 >>= 7;
          }
          while (v10);
          break;
        default:
          break;
      }
      v73 = (*((_DWORD *)v45 + 6) - v44);
      do
      {
        v74 = v73 & 0x7F | ((v73 > 0x7F) << 7);
        v75 = (char *)*((_QWORD *)a2 + 4);
        if ((unint64_t)v75 >= *((_QWORD *)a2 + 3))
        {
          llvm::raw_ostream::write(a2, v74);
        }
        else
        {
          *((_QWORD *)a2 + 4) = v75 + 1;
          *v75 = v74;
        }
        v10 = v73 > 0x7F;
        v73 >>= 7;
      }
      while (v10);
      v76 = *((unsigned int *)v45 + 7);
      do
      {
        v77 = v76 & 0x7F | ((v76 > 0x7F) << 7);
        v78 = (char *)*((_QWORD *)a2 + 4);
        if ((unint64_t)v78 >= *((_QWORD *)a2 + 3))
        {
          llvm::raw_ostream::write(a2, v77);
        }
        else
        {
          *((_QWORD *)a2 + 4) = v78 + 1;
          *v78 = v77;
        }
        v10 = v76 > 0x7F;
        v76 >>= 7;
      }
      while (v10);
      v79 = (*((_DWORD *)v45 + 8) - *((_DWORD *)v45 + 6));
      do
      {
        v80 = v79 & 0x7F | ((v79 > 0x7F) << 7);
        v81 = (char *)*((_QWORD *)a2 + 4);
        if ((unint64_t)v81 >= *((_QWORD *)a2 + 3))
        {
          llvm::raw_ostream::write(a2, v80);
        }
        else
        {
          *((_QWORD *)a2 + 4) = v81 + 1;
          *v81 = v80;
        }
        v10 = v79 > 0x7F;
        v79 >>= 7;
      }
      while (v10);
      v82 = *((unsigned int *)v45 + 9);
      do
      {
        v83 = v82 & 0x7F | ((v82 > 0x7F) << 7);
        v84 = (char *)*((_QWORD *)a2 + 4);
        if ((unint64_t)v84 >= *((_QWORD *)a2 + 3))
        {
          llvm::raw_ostream::write(a2, v83);
        }
        else
        {
          *((_QWORD *)a2 + 4) = v84 + 1;
          *v84 = v83;
        }
        v10 = v82 > 0x7F;
        v82 >>= 7;
      }
      while (v10);
      v44 = *((_DWORD *)v45 + 6);
      v45 = (uint64_t *)((char *)v45 + 44);
      v47 -= 44;
    }
    while (v45 != v46);
  }
  if (v91)
  {
    v92 = v91;
    operator delete(v91);
  }
  if (v88 != v90)
    free(v88);
}

uint64_t *sub_1C5466C24(uint64_t *result, unint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;

  if ((_DWORD)a2 == 2)
  {
    v2 = result;
    v3 = *result;
    do
    {
      *(_DWORD *)(v2[44] + 4 * HIDWORD(a2)) = 1;
      v4 = 5 * HIDWORD(a2);
      result = (uint64_t *)sub_1C5466C24(v2, *(_QWORD *)(v3 + 20 * HIDWORD(a2) + 4));
      v3 = *v2;
      a2 = *(_QWORD *)(*v2 + 4 * v4 + 12);
    }
    while ((_DWORD)a2 == 2);
  }
  return result;
}

uint64_t sub_1C5466C90(uint64_t result, unint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  __int128 v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v17;

  if ((_DWORD)a2 == 2)
  {
    v2 = result;
    v3 = (unint64_t *)(result + 16);
    v4 = result + 32;
    do
    {
      v5 = HIDWORD(a2);
      v6 = *(_QWORD *)(v2 + 352);
      if (!*(_DWORD *)(v6 + 4 * HIDWORD(a2)))
        break;
      *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v2 + 24);
      v7 = *(_QWORD *)v2;
      v8 = *(_QWORD *)v2 + 20 * HIDWORD(a2);
      v9 = *(unsigned int *)(v2 + 24);
      v10 = *(_QWORD *)(v2 + 16);
      if (v9 >= *(_DWORD *)(v2 + 28))
      {
        v14 = v9 + 1;
        v15 = v10 + 20 * v9;
        if (v10 <= v8 && v15 > v8)
        {
          v17 = v8 - v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v3, v4, v14, 20);
          v10 = *v3;
          v8 = *v3 + v17;
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v3, v4, v14, 20);
          v10 = *v3;
        }
      }
      v11 = v10 + 20 * *(unsigned int *)(v2 + 24);
      v12 = *(_OWORD *)v8;
      *(_DWORD *)(v11 + 16) = *(_DWORD *)(v8 + 16);
      *(_OWORD *)v11 = v12;
      ++*(_DWORD *)(v2 + 24);
      v13 = v7 + 20 * v5;
      result = sub_1C5466C90(v2, *(_QWORD *)(v13 + 4));
      a2 = *(_QWORD *)(v13 + 12);
    }
    while ((_DWORD)a2 == 2);
  }
  return result;
}

__n128 sub_1C5466D98(__n128 *a1, __n128 *a2, unint64_t a3, uint64_t a4, uint64_t a5, __n128 result)
{
  __n128 *v7;
  unsigned __int32 v8;
  unsigned __int32 v9;
  BOOL v10;
  unsigned __int32 v11;
  unsigned __int32 v12;
  unsigned __int32 v13;
  unsigned __int32 v14;
  __n128 *v17;
  uint64_t v18;
  __n128 *v19;
  __n128 *v20;
  unsigned __int32 v21;
  unsigned __int32 v22;
  unsigned __int32 v23;
  unsigned __int32 v24;
  unsigned __int32 v25;
  unsigned __int32 v26;
  unsigned __int32 v29;
  unint64_t v30;
  signed __int32 v31;
  __n128 v32;
  __n128 *v33;
  uint64_t v34;
  _OWORD *v35;
  unsigned __int32 v36;
  BOOL v37;
  unsigned __int32 v38;
  unsigned __int32 v39;
  __int128 v41;
  _DWORD *v43;
  unint64_t v44;
  __n128 *v45;
  unint64_t v46;
  __n128 *v47;
  __n128 v48;
  __n128 v49;
  __n128 v50;
  __n128 v51;
  uint64_t v52;
  __n128 *v53;
  __n128 *v54;
  unsigned __int32 v55;
  unsigned __int32 v56;
  BOOL v57;
  unsigned __int32 v58;
  unsigned __int32 v59;
  unsigned __int32 v60;
  unsigned __int32 v61;
  __n128 v63;
  __n128 v64;
  uint64_t v65;
  char *v66;
  __int128 v67;
  uint64_t v68;
  char *v69;
  __int128 v70;
  __n128 v71;
  _BYTE v72[28];

  if (a3 < 2)
    return result;
  v7 = a1;
  if (a3 == 2)
  {
    v8 = a2[-2].n128_u32[1];
    v9 = a1[1].n128_u32[0];
    v10 = v8 >= v9;
    if (v8 == v9)
    {
      v12 = a2[-2].n128_u32[3];
      v11 = a2[-1].n128_u32[0];
      v14 = a1[1].n128_u32[2];
      v13 = a1[1].n128_u32[3];
      if (v12 == v14 && v11 == v13)
      {
        if ((signed __int32)a2[-1].n128_u32[3] >= (signed __int32)a1[2].n128_u32[2])
          return result;
        goto LABEL_56;
      }
      if (v12 < v14)
      {
LABEL_56:
        v47 = (__n128 *)((char *)a2 - 44);
        v48 = *a1;
        *(__n128 *)v72 = a1[1];
        *(__n128 *)&v72[12] = *(__n128 *)((char *)a1 + 28);
        v49 = a2[-1];
        v50 = *(__n128 *)((char *)a2 - 28);
        *a1 = *(__n128 *)((char *)a2 - 44);
        a1[1] = v50;
        *(__n128 *)((char *)a1 + 28) = v49;
        *(__n128 *)((char *)v47 + 28) = *(__n128 *)&v72[12];
        result = *(__n128 *)v72;
        *v47 = v48;
        v47[1] = *(__n128 *)v72;
        return result;
      }
      if (v14 < v12)
        return result;
      v10 = v11 >= v13;
    }
    if (v10)
      return result;
    goto LABEL_56;
  }
  if ((uint64_t)a3 > 128)
  {
    v43 = (_DWORD *)a4;
    v44 = a3 >> 1;
    v45 = (__n128 *)((char *)a1 + 44 * (a3 >> 1));
    v46 = a3 >> 1;
    if ((uint64_t)a3 > a5)
    {
      sub_1C5466D98(a1, v45, v46, a4, a5);
      sub_1C5466D98((char *)v7 + 44 * (a3 >> 1), a2, a3 - (a3 >> 1), v43, a5);
      sub_1C5467500((char *)v7, (char *)v7 + 44 * (a3 >> 1), (char *)a2, a3 >> 1, a3 - (a3 >> 1), v43, a5);
      return result;
    }
    v51 = sub_1C5467178(a1, v45, v46, a4, result);
    v52 = (uint64_t)&v43[11 * v44];
    result.n128_u64[0] = sub_1C5467178((__n128 *)((char *)v7 + 44 * (a3 >> 1)), a2, a3 - (a3 >> 1), v52, v51).n128_u64[0];
    v53 = (__n128 *)&v43[11 * a3];
    v54 = (__n128 *)v52;
    while (1)
    {
      if (v54 == v53)
      {
        if (v43 != (_DWORD *)v52)
        {
          v68 = 0;
          do
          {
            v69 = (char *)v7 + v68 * 4;
            result = *(__n128 *)&v43[v68];
            v70 = *(_OWORD *)&v43[v68 + 4];
            *(_OWORD *)(v69 + 28) = *(_OWORD *)&v43[v68 + 7];
            *(__n128 *)v69 = result;
            *((_OWORD *)v69 + 1) = v70;
            v68 += 11;
          }
          while (&v43[v68] != (_DWORD *)v52);
        }
        return result;
      }
      v55 = v54[1].n128_u32[0];
      v56 = v43[4];
      v57 = v55 >= v56;
      if (v55 != v56)
        goto LABEL_68;
      v59 = v54[1].n128_u32[2];
      v58 = v54[1].n128_u32[3];
      v61 = v43[6];
      v60 = v43[7];
      if (v59 != v61 || v58 != v60)
        break;
      if ((signed __int32)v54[2].n128_u32[2] >= v43[10])
      {
LABEL_71:
        result = *(__n128 *)v43;
        v64 = *((__n128 *)v43 + 1);
        *(__n128 *)((char *)v7 + 28) = *(__n128 *)(v43 + 7);
        *v7 = result;
        v7[1] = v64;
        v43 += 11;
        goto LABEL_72;
      }
LABEL_69:
      result = *v54;
      v63 = v54[1];
      *(__n128 *)((char *)v7 + 28) = *(__n128 *)((char *)v54 + 28);
      *v7 = result;
      v7[1] = v63;
      v54 = (__n128 *)((char *)v54 + 44);
LABEL_72:
      v7 = (__n128 *)((char *)v7 + 44);
      if (v43 == (_DWORD *)v52)
      {
        if (v54 != v53)
        {
          v65 = 0;
          do
          {
            v66 = (char *)v7 + v65;
            result = *(__n128 *)((char *)v54 + v65);
            v67 = *(__int128 *)((char *)&v54[1] + v65);
            *(__n128 *)(v66 + 28) = *(__n128 *)((char *)v54 + v65 + 28);
            *(__n128 *)v66 = result;
            *((_OWORD *)v66 + 1) = v67;
            v65 += 44;
          }
          while ((__n128 *)((char *)v54 + v65) != v53);
        }
        return result;
      }
    }
    if (v59 < v61)
      goto LABEL_69;
    if (v61 < v59)
      goto LABEL_71;
    v57 = v58 >= v60;
LABEL_68:
    if (v57)
      goto LABEL_71;
    goto LABEL_69;
  }
  if (a1 == a2)
    return result;
  v17 = (__n128 *)((char *)a1 + 44);
  if ((__n128 *)((char *)&a1[2].n128_f64[1] + 4) == a2)
    return result;
  v18 = 0;
  v19 = a1;
  do
  {
    v20 = v19;
    v19 = v17;
    v21 = v20[3].n128_u32[3];
    v22 = v20[1].n128_u32[0];
    if (v21 == v22)
    {
      v23 = v20[4].n128_u32[1];
      v24 = v20[4].n128_u32[2];
      v25 = v20[1].n128_u32[2];
      v26 = v20[1].n128_u32[3];
      if (v23 == v25 && v24 == v26)
      {
        if ((signed __int32)v20[5].n128_u32[1] >= (signed __int32)v20[2].n128_u32[2])
          goto LABEL_51;
      }
      else if (v23 >= v25 && (v25 < v23 || v24 >= v26))
      {
        goto LABEL_51;
      }
    }
    else
    {
      if (v21 >= v22)
        goto LABEL_51;
      v23 = v20[4].n128_u32[1];
      v24 = v20[4].n128_u32[2];
    }
    v71 = *v19;
    v29 = v20[4].n128_u32[0];
    v30 = *(unint64_t *)((char *)&v20[4].n128_u64[1] + 4);
    v31 = v20[5].n128_i32[1];
    *(__n128 *)((char *)v19 + 28) = *(__n128 *)((char *)v20 + 28);
    v32 = v20[1];
    *v19 = *v20;
    v19[1] = v32;
    v33 = v7;
    if (v20 == v7)
      goto LABEL_50;
    v34 = v18;
    do
    {
      v35 = (_OWORD *)((char *)v7->n128_u64 + v34);
      v36 = *(_DWORD *)((char *)&v7[-1] + v34 - 12);
      v37 = v21 >= v36;
      if (v21 == v36)
      {
        v38 = *((_DWORD *)v35 - 5);
        v39 = *((_DWORD *)v35 - 4);
        if (v23 == v38 && v24 == v39)
        {
          v33 = (__n128 *)((char *)v7 + v34);
          if (v31 >= *(signed __int32 *)((char *)&v7->n128_u32[-1] + v34))
            goto LABEL_50;
          goto LABEL_48;
        }
        if (v23 < v38)
          goto LABEL_48;
        v37 = v38 < v23 || v24 >= v39;
      }
      if (v37)
      {
        v33 = v20;
        goto LABEL_50;
      }
LABEL_48:
      v20 = (__n128 *)((char *)v20 - 44);
      v41 = *(_OWORD *)((char *)v35 - 28);
      *v35 = *(_OWORD *)((char *)v35 - 44);
      v35[1] = v41;
      *(_OWORD *)((char *)v35 + 28) = *(v35 - 1);
      v34 -= 44;
    }
    while (v34);
    v33 = v7;
LABEL_50:
    result = v71;
    *v33 = v71;
    v33[1].n128_u32[0] = v21;
    v33[1].n128_u32[1] = v29;
    v33[1].n128_u32[2] = v23;
    v33[1].n128_u32[3] = v24;
    v33[2].n128_u64[0] = v30;
    v33[2].n128_u32[2] = v31;
LABEL_51:
    v17 = (__n128 *)((char *)v19 + 44);
    v18 += 44;
  }
  while ((__n128 *)((char *)&v19[2].n128_f64[1] + 4) != a2);
  return result;
}

__n128 sub_1C5467178(__n128 *a1, __n128 *a2, unint64_t a3, uint64_t a4, __n128 result)
{
  uint64_t v5;
  __n128 *v8;
  __n128 v9;
  __n128 *v10;
  unsigned __int32 v11;
  unsigned __int32 v12;
  BOOL v13;
  unsigned __int32 v14;
  unsigned __int32 v15;
  unsigned __int32 v16;
  unsigned __int32 v17;
  __n128 v19;
  __int128 v20;
  __n128 v21;
  __n128 v22;
  __n128 v23;
  __n128 *v24;
  uint64_t v25;
  _OWORD *v26;
  __n128 *v27;
  _OWORD *v28;
  unsigned __int32 v29;
  unsigned __int32 v30;
  BOOL v31;
  unsigned __int32 v32;
  unsigned __int32 v33;
  unsigned __int32 v34;
  unsigned __int32 v35;
  _OWORD *v37;
  __int128 v38;
  uint64_t v39;
  _OWORD *v40;
  unsigned __int32 v41;
  unsigned __int32 v42;
  BOOL v43;
  unsigned __int32 v44;
  unsigned __int32 v45;
  unsigned __int32 v46;
  unsigned __int32 v47;
  __int128 v49;
  __n128 v50;
  uint64_t v51;
  __n128 *v52;
  __n128 *v53;
  unsigned __int32 v54;
  unsigned __int32 v55;
  BOOL v56;
  unsigned __int32 v57;
  unsigned __int32 v58;
  unsigned __int32 v59;
  unsigned __int32 v60;
  __n128 v62;
  __n128 v63;
  uint64_t v64;
  uint64_t v65;
  __int128 v66;
  __n128 v67;
  __n128 v68;
  uint64_t v69;
  uint64_t v70;
  __int128 v71;

  if (!a3)
    return result;
  v5 = a4;
  v8 = a1;
  if (a3 == 2)
  {
    v10 = (__n128 *)((char *)a2 - 44);
    v11 = a2[-2].n128_u32[1];
    v12 = a1[1].n128_u32[0];
    v13 = v11 >= v12;
    if (v11 == v12)
    {
      v15 = a2[-2].n128_u32[3];
      v14 = a2[-1].n128_u32[0];
      v17 = a1[1].n128_u32[2];
      v16 = a1[1].n128_u32[3];
      if (v15 == v17 && v14 == v16)
      {
        if ((signed __int32)a2[-1].n128_u32[3] < (signed __int32)a1[2].n128_u32[2])
          goto LABEL_14;
        goto LABEL_71;
      }
      if (v15 < v17)
      {
LABEL_14:
        v19 = *v10;
        v20 = *(__int128 *)((char *)&a2[-2] + 4);
        *(__n128 *)(a4 + 28) = a2[-1];
        *(__n128 *)a4 = v19;
        *(_OWORD *)(a4 + 16) = v20;
        result = *a1;
        v21 = a1[1];
        v22 = *(__n128 *)((char *)a1 + 28);
LABEL_72:
        *(__n128 *)(a4 + 72) = v22;
        *(__n128 *)(a4 + 60) = v21;
        *(__n128 *)(a4 + 44) = result;
        return result;
      }
      if (v17 < v15)
      {
LABEL_71:
        v67 = *a1;
        v68 = a1[1];
        *(__n128 *)(a4 + 28) = *(__n128 *)((char *)a1 + 28);
        *(__n128 *)a4 = v67;
        *(__n128 *)(a4 + 16) = v68;
        result = *v10;
        v21 = *(__n128 *)((char *)a2 - 28);
        v22 = a2[-1];
        goto LABEL_72;
      }
      v13 = v14 >= v16;
    }
    if (!v13)
      goto LABEL_14;
    goto LABEL_71;
  }
  if (a3 == 1)
  {
    result = *a1;
    v9 = a1[1];
    *(__n128 *)(a4 + 28) = *(__n128 *)((char *)a1 + 28);
    *(__n128 *)a4 = result;
    *(__n128 *)(a4 + 16) = v9;
    return result;
  }
  if ((uint64_t)a3 > 8)
  {
    v51 = 44 * (a3 >> 1);
    v52 = (__n128 *)((char *)a1 + v51);
    sub_1C5466D98(a1, (char *)a1 + v51, a3 >> 1, a4, a3 >> 1);
    sub_1C5466D98((char *)v8 + v51, a2, a3 - (a3 >> 1), v5 + v51, a3 - (a3 >> 1));
    v53 = (__n128 *)((char *)v8 + v51);
    while (1)
    {
      if (v53 == a2)
      {
        if (v8 != v52)
        {
          v69 = 0;
          do
          {
            v70 = v5 + v69;
            result = *(__n128 *)((char *)v8 + v69);
            v71 = *(__int128 *)((char *)&v8[1] + v69);
            *(__n128 *)(v70 + 28) = *(__n128 *)((char *)v8 + v69 + 28);
            *(__n128 *)v70 = result;
            *(_OWORD *)(v70 + 16) = v71;
            v69 += 44;
          }
          while ((__n128 *)((char *)v8 + v69) != v52);
        }
        return result;
      }
      v54 = v53[1].n128_u32[0];
      v55 = v8[1].n128_u32[0];
      v56 = v54 >= v55;
      if (v54 != v55)
        goto LABEL_61;
      v58 = v53[1].n128_u32[2];
      v57 = v53[1].n128_u32[3];
      v60 = v8[1].n128_u32[2];
      v59 = v8[1].n128_u32[3];
      if (v58 != v60 || v57 != v59)
        break;
      if ((signed __int32)v53[2].n128_u32[2] >= (signed __int32)v8[2].n128_u32[2])
      {
LABEL_64:
        result = *v8;
        v63 = v8[1];
        *(__n128 *)(v5 + 28) = *(__n128 *)((char *)v8 + 28);
        *(__n128 *)v5 = result;
        *(__n128 *)(v5 + 16) = v63;
        v8 = (__n128 *)((char *)v8 + 44);
        goto LABEL_65;
      }
LABEL_62:
      result = *v53;
      v62 = v53[1];
      *(__n128 *)(v5 + 28) = *(__n128 *)((char *)v53 + 28);
      *(__n128 *)v5 = result;
      *(__n128 *)(v5 + 16) = v62;
      v53 = (__n128 *)((char *)v53 + 44);
LABEL_65:
      v5 += 44;
      if (v8 == v52)
      {
        if (v53 != a2)
        {
          v64 = 0;
          do
          {
            v65 = v5 + v64;
            result = *(__n128 *)((char *)v53 + v64);
            v66 = *(__int128 *)((char *)&v53[1] + v64);
            *(__n128 *)(v65 + 28) = *(__n128 *)((char *)v53 + v64 + 28);
            *(__n128 *)v65 = result;
            *(_OWORD *)(v65 + 16) = v66;
            v64 += 44;
          }
          while ((__n128 *)((char *)v53 + v64) != a2);
        }
        return result;
      }
    }
    if (v58 < v60)
      goto LABEL_62;
    if (v60 < v58)
      goto LABEL_64;
    v56 = v57 >= v59;
LABEL_61:
    if (v56)
      goto LABEL_64;
    goto LABEL_62;
  }
  if (a1 != a2)
  {
    result = *a1;
    v23 = a1[1];
    *(__n128 *)(a4 + 28) = *(__n128 *)((char *)a1 + 28);
    *(__n128 *)a4 = result;
    *(__n128 *)(a4 + 16) = v23;
    v24 = (__n128 *)((char *)a1 + 44);
    if ((__n128 *)((char *)&a1[2].n128_f64[1] + 4) != a2)
    {
      v25 = 0;
      v26 = (_OWORD *)a4;
      do
      {
        v27 = v8;
        v28 = v26;
        v8 = v24;
        v26 = (_OWORD *)((char *)v26 + 44);
        v29 = v27[3].n128_u32[3];
        v30 = *((_DWORD *)v28 + 4);
        v31 = v29 >= v30;
        if (v29 == v30)
        {
          v32 = v27[4].n128_u32[1];
          v33 = v27[4].n128_u32[2];
          v34 = *((_DWORD *)v28 + 6);
          v35 = *((_DWORD *)v28 + 7);
          if (v32 == v34 && v33 == v35)
          {
            v37 = v26;
            if ((signed __int32)v27[5].n128_u32[1] >= *((_DWORD *)v28 + 10))
              goto LABEL_49;
LABEL_32:
            v38 = v28[1];
            *v26 = *v28;
            v26[1] = v38;
            *(_OWORD *)((char *)v26 + 28) = *(_OWORD *)((char *)v28 + 28);
            v37 = (_OWORD *)a4;
            if (v28 == (_OWORD *)a4)
              goto LABEL_49;
            v39 = v25;
            while (2)
            {
              v40 = (_OWORD *)(a4 + v39);
              v41 = v27[3].n128_u32[3];
              v42 = *(_DWORD *)(a4 + v39 - 28);
              v43 = v41 >= v42;
              if (v41 == v42)
              {
                v44 = v27[4].n128_u32[1];
                v45 = v27[4].n128_u32[2];
                v46 = *((_DWORD *)v40 - 5);
                v47 = *((_DWORD *)v40 - 4);
                if (v44 == v46 && v45 == v47)
                {
                  v37 = (_OWORD *)(a4 + v39);
                  if ((signed __int32)v27[5].n128_u32[1] >= *(_DWORD *)(a4 + v39 - 4))
                    goto LABEL_49;
                }
                else if (v44 >= v46)
                {
                  v43 = v46 < v44 || v45 >= v47;
                  goto LABEL_43;
                }
              }
              else
              {
LABEL_43:
                if (v43)
                {
                  v37 = v28;
                  goto LABEL_49;
                }
              }
              v28 = (_OWORD *)((char *)v28 - 44);
              v49 = *(_OWORD *)((char *)v40 - 28);
              *v40 = *(_OWORD *)((char *)v40 - 44);
              v40[1] = v49;
              *(_OWORD *)((char *)v40 + 28) = *(v40 - 1);
              v39 -= 44;
              if (!v39)
              {
                v37 = (_OWORD *)a4;
                goto LABEL_49;
              }
              continue;
            }
          }
          if (v32 < v34)
            goto LABEL_32;
          v31 = v34 < v32 || v33 >= v35;
        }
        v37 = v26;
        if (!v31)
          goto LABEL_32;
LABEL_49:
        result = *v8;
        v50 = v8[1];
        *(__n128 *)((char *)v37 + 28) = *(__n128 *)((char *)&v8[1] + 12);
        *v37 = result;
        v37[1] = v50;
        v24 = (__n128 *)((char *)v8 + 44);
        v25 += 44;
      }
      while ((__n128 *)((char *)&v8[2].n128_f64[1] + 4) != a2);
    }
  }
  return result;
}

char *sub_1C5467500(char *result, char *a2, char *a3, uint64_t a4, uint64_t a5, _DWORD *a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  char *v14;
  unsigned int v15;
  BOOL v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  BOOL v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  unint64_t v27;
  char *v28;
  unsigned int v29;
  unsigned int *v30;
  unsigned int *v31;
  _DWORD *v32;
  unint64_t v33;
  char *v34;
  unsigned int v35;
  BOOL v36;
  unsigned int v37;
  unsigned int v38;
  char *v39;
  unsigned int v40;
  unsigned int v41;
  uint64_t v43;
  unint64_t v44;
  char *v45;
  unsigned int v46;
  char *v47;
  unint64_t v48;
  unsigned int v49;
  BOOL v50;
  char *v51;
  unsigned int v52;
  unsigned int v53;
  unsigned int v54;
  unsigned int v55;
  char *v57;
  _DWORD *v58;
  char *v59;
  uint64_t v60;
  char *v61;
  char *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  char *v68;
  char *v69;
  __int128 v70;
  __int128 v71;
  uint64_t v72;
  char *v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  char *v77;
  _OWORD *v78;
  _OWORD *v79;
  __int128 v80;
  __int128 v81;
  uint64_t v82;
  BOOL v83;
  char v84;
  uint64_t v85;
  char *v86;
  char *v87;
  char *v88;
  uint64_t v89;
  _DWORD *v90;
  uint64_t v91;
  uint64_t v92;
  char *v93;
  uint64_t v94;
  char *v95;
  unint64_t v96;
  _OWORD *v97;
  __int128 v98;
  __int128 v99;
  _DWORD *v100;
  char *v101;
  char *v102;
  unsigned int v103;
  unsigned int v104;
  BOOL v105;
  unsigned int v106;
  unsigned int v107;
  unsigned int v108;
  unsigned int v109;
  __int128 v111;
  __int128 v112;
  unint64_t v113;
  _OWORD *v114;
  __int128 v115;
  __int128 v116;
  _DWORD *v117;
  unsigned int v118;
  unsigned int v119;
  BOOL v120;
  unsigned int v121;
  unsigned int v122;
  unsigned int v123;
  unsigned int v124;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 *v130;
  __int128 v131;
  __int128 v132;
  uint64_t v133;
  char *v134;
  __int128 v135;
  __int128 v136;
  _DWORD *v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  __int128 v142;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  __int128 v146;
  _BYTE v147[28];
  _BYTE v148[28];
  _BYTE v149[28];
  _BYTE v150[28];
  _BYTE v151[28];

  if (!a5)
    return result;
  v7 = a5;
  while (a4 > a7 && v7 > a7)
  {
    if (!a4)
      return result;
    v11 = 0;
    v12 = *((_DWORD *)a2 + 4);
    v13 = -a4;
    while (1)
    {
      v14 = &result[v11];
      v15 = *(_DWORD *)&result[v11 + 16];
      v16 = v12 >= v15;
      if (v12 != v15)
        goto LABEL_16;
      v17 = *((_DWORD *)a2 + 6);
      v18 = *((_DWORD *)a2 + 7);
      v19 = *((_DWORD *)v14 + 6);
      v20 = *((_DWORD *)v14 + 7);
      v21 = v17 == v19 && v18 == v20;
      if (!v21)
      {
        if (v17 < v19)
          break;
        v16 = v19 < v17 || v18 >= v20;
LABEL_16:
        if (!v16)
          break;
        goto LABEL_19;
      }
      if (*((_DWORD *)a2 + 10) < *(_DWORD *)&result[v11 + 40])
        break;
LABEL_19:
      v11 += 44;
      v16 = __CFADD__(v13++, 1);
      if (v16)
        return result;
    }
    v22 = -v13;
    v23 = &result[v11];
    if (-v13 >= v7)
    {
      if (v13 == -1)
      {
        v130 = (__int128 *)&result[v11];
        *(_OWORD *)&v151[12] = *(__int128 *)((char *)v130 + 28);
        v146 = *v130;
        *(_OWORD *)v151 = v130[1];
        v131 = *(_OWORD *)a2;
        v132 = *((_OWORD *)a2 + 1);
        *(__int128 *)((char *)v130 + 28) = *(_OWORD *)(a2 + 28);
        *v130 = v131;
        v130[1] = v132;
        *(_OWORD *)(a2 + 28) = *(_OWORD *)&v151[12];
        *(_OWORD *)a2 = v146;
        *((_OWORD *)a2 + 1) = *(_OWORD *)v151;
        return result;
      }
      if (v13 > 0)
        v22 = 1 - v13;
      v43 = v22 >> 1;
      v26 = &result[44 * (v22 >> 1) + v11];
      v25 = 0;
      if (a3 == a2)
      {
        v57 = a3;
LABEL_74:
        a2 = v26;
        goto LABEL_90;
      }
      v44 = 0x2E8BA2E8BA2E8BA3 * ((a3 - a2) >> 2);
      v45 = &result[44 * v43 + v11];
      v46 = *((_DWORD *)v45 + 4);
      v47 = a2;
      while (2)
      {
        v48 = v44 >> 1;
        v49 = *(_DWORD *)&v47[44 * (v44 >> 1) + 16];
        v50 = v49 >= v46;
        if (v49 == v46)
        {
          v51 = &v47[44 * v48];
          v52 = *((_DWORD *)v51 + 6);
          v53 = *((_DWORD *)v51 + 7);
          v54 = *((_DWORD *)v45 + 6);
          v55 = *((_DWORD *)v45 + 7);
          if (v52 == v54 && v53 == v55)
          {
            if (*(_DWORD *)&v47[44 * v48 + 40] < *((_DWORD *)v45 + 10))
              goto LABEL_59;
          }
          else
          {
            if (v52 >= v54)
            {
              v50 = v54 < v52 || v53 >= v55;
              goto LABEL_58;
            }
LABEL_59:
            v25 += v48 + 1;
            v48 = v44 + ~v48;
          }
        }
        else
        {
LABEL_58:
          if (!v50)
            goto LABEL_59;
        }
        v47 = &a2[44 * v25];
        v44 = v48;
        if (!v48)
          goto LABEL_65;
        continue;
      }
    }
    if (v7 >= 0)
      v24 = v7;
    else
      v24 = v7 + 1;
    v25 = v24 >> 1;
    v26 = a2;
    if (v23 != a2)
    {
      v27 = 0x2E8BA2E8BA2E8BA3 * ((a2 - result - v11) >> 2);
      v28 = &a2[44 * v25];
      v29 = *((_DWORD *)v28 + 4);
      v30 = (unsigned int *)(v28 + 24);
      v31 = (unsigned int *)(v28 + 28);
      v32 = v28 + 40;
      v26 = &result[v11];
      while (1)
      {
        v33 = v27 >> 1;
        v34 = &v26[44 * (v27 >> 1)];
        v35 = *((_DWORD *)v34 + 4);
        v36 = v29 >= v35;
        if (v29 != v35)
          goto LABEL_37;
        v37 = *v30;
        v38 = *v31;
        v39 = &v26[44 * v33];
        v40 = *((_DWORD *)v39 + 6);
        v41 = *((_DWORD *)v39 + 7);
        if (*v30 == v40 && v38 == v41)
          break;
        if (v37 >= v40)
        {
          v36 = v40 < v37 || v38 >= v41;
LABEL_37:
          if (!v36)
            goto LABEL_40;
LABEL_39:
          v26 = v34 + 44;
          v33 = v27 + ~v33;
        }
LABEL_40:
        v27 = v33;
        if (!v33)
          goto LABEL_64;
      }
      if (*v32 < *(_DWORD *)&v26[44 * v33 + 40])
        goto LABEL_40;
      goto LABEL_39;
    }
LABEL_64:
    v43 = 0x2E8BA2E8BA2E8BA3 * ((v26 - result - v11) >> 2);
LABEL_65:
    v57 = &a2[44 * v25];
    v7 -= v25;
    if (v26 != a2)
    {
      if (v25)
      {
        if (v26 + 44 == a2)
        {
          *(_OWORD *)&v148[12] = *(_OWORD *)(v26 + 28);
          v143 = *(_OWORD *)v26;
          *(_OWORD *)v148 = *((_OWORD *)v26 + 1);
          v61 = a2;
          v137 = a6;
          v139 = v43;
          v62 = a3;
          v141 = a7;
          v63 = v7;
          memmove(v26, v61, 44 * v25);
          v7 = v63;
          v43 = v139;
          a7 = v141;
          a3 = v62;
          a6 = v137;
          a2 = &v26[44 * v25];
          *(_OWORD *)a2 = v143;
          *((_OWORD *)a2 + 1) = *(_OWORD *)v148;
          *(_OWORD *)(a2 + 28) = *(_OWORD *)&v148[12];
        }
        else if (v25 == 1)
        {
          a2 = v26 + 44;
          *(_OWORD *)&v147[12] = *((_OWORD *)v57 - 1);
          v142 = *(_OWORD *)(v57 - 44);
          *(_OWORD *)v147 = *(_OWORD *)(v57 - 28);
          if (v57 - 44 != v26)
          {
            v58 = a6;
            v59 = a3;
            v138 = v43;
            v140 = a7;
            v60 = v7;
            memmove(v26 + 44, v26, v57 - 44 - v26);
            v7 = v60;
            v43 = v138;
            a7 = v140;
            a3 = v59;
            a6 = v58;
          }
          *(_OWORD *)(v26 + 28) = *(_OWORD *)&v147[12];
          *(_OWORD *)v26 = v142;
          *((_OWORD *)v26 + 1) = *(_OWORD *)v147;
          v25 = 1;
        }
        else
        {
          v64 = 0x2E8BA2E8BA2E8BA3 * ((a2 - v26) >> 2);
          v65 = v25;
          v66 = v64;
          if (v64 == v25)
          {
            v67 = 0;
            do
            {
              v68 = &a2[v67];
              v69 = &v26[v67];
              *(_OWORD *)&v149[12] = *(_OWORD *)&v26[v67 + 28];
              v144 = *(_OWORD *)&v26[v67];
              *(_OWORD *)v149 = *(_OWORD *)&v26[v67 + 16];
              v70 = *(_OWORD *)&a2[v67];
              v71 = *(_OWORD *)&a2[v67 + 16];
              *(_OWORD *)(v69 + 28) = *(_OWORD *)&a2[v67 + 28];
              *(_OWORD *)v69 = v70;
              *((_OWORD *)v69 + 1) = v71;
              *(_OWORD *)(v68 + 28) = *(_OWORD *)&v149[12];
              *(_OWORD *)v68 = v144;
              *((_OWORD *)v68 + 1) = *(_OWORD *)v149;
              if (&v26[v67 + 44] == a2)
                break;
              v21 = 44 * v25 - 44 == v67;
              v67 += 44;
            }
            while (!v21);
          }
          else
          {
            do
            {
              v72 = v66;
              v66 = v65;
              v65 = v72 % v65;
            }
            while (v65);
            v73 = &v26[44 * v66];
            do
            {
              v74 = *(_OWORD *)(v73 - 44);
              v75 = *(_OWORD *)(v73 - 28);
              v76 = *((_OWORD *)v73 - 1);
              v73 -= 44;
              *(_OWORD *)&v150[12] = v76;
              v145 = v74;
              *(_OWORD *)v150 = v75;
              v77 = &v73[4 * ((a2 - v26) >> 2)];
              v78 = v73;
              do
              {
                v79 = v78;
                v78 = v77;
                v80 = *(_OWORD *)v77;
                v81 = *((_OWORD *)v77 + 1);
                *(_OWORD *)((char *)v79 + 28) = *(_OWORD *)(v77 + 28);
                *v79 = v80;
                v79[1] = v81;
                v82 = 0x2E8BA2E8BA2E8BA3 * ((v57 - v77) >> 2);
                v83 = __OFSUB__(v64, v82);
                v85 = v64 - v82;
                v84 = (v85 < 0) ^ v83;
                v77 = &v26[44 * v85];
                if (v84)
                  v77 = (char *)v78 + 4 * ((a2 - v26) >> 2);
              }
              while (v77 != v73);
              *(_OWORD *)((char *)v78 + 28) = *(_OWORD *)&v150[12];
              *v78 = v145;
              v78[1] = *(_OWORD *)v150;
            }
            while (v73 != v26);
            a2 = &v26[44 * v25];
          }
        }
        goto LABEL_90;
      }
      goto LABEL_74;
    }
    v26 = a2;
    a2 += 44 * v25;
LABEL_90:
    a4 = -(v43 + v13);
    if (v25 + v43 >= v7 - v43 - v13)
    {
      v93 = a3;
      v94 = -(v43 + v13);
      v95 = v23;
      v90 = a6;
      v91 = a7;
      sub_1C5467500(a2, v57, v93, v94, v7);
      result = v95;
      v57 = v26;
      v7 = v25;
      a4 = v43;
      a3 = a2;
    }
    else
    {
      v86 = v23;
      v87 = v26;
      v88 = a3;
      v89 = v43;
      v90 = a6;
      v91 = a7;
      v92 = v7;
      sub_1C5467500(v86, v87, a2, v89, v25);
      v7 = v92;
      a3 = v88;
      result = a2;
    }
    a2 = v57;
    a6 = v90;
    a7 = v91;
    if (!v7)
      return result;
  }
  if (a4 <= v7)
  {
    if (result == a2)
      return result;
    v113 = 0;
    do
    {
      v114 = &a6[v113 / 4];
      v115 = *(_OWORD *)&result[v113];
      v116 = *(_OWORD *)&result[v113 + 16];
      *(_OWORD *)((char *)v114 + 28) = *(_OWORD *)&result[v113 + 28];
      *v114 = v115;
      v114[1] = v116;
      v113 += 44;
    }
    while (&result[v113] != a2);
    if (!v113)
      return result;
    v117 = a6;
    while (1)
    {
      if (a2 == a3)
        return (char *)memmove(result, v117, (char *)a6 - (char *)v117 + v113);
      v118 = *((_DWORD *)a2 + 4);
      v119 = v117[4];
      v120 = v118 >= v119;
      if (v118 != v119)
        goto LABEL_130;
      v122 = *((_DWORD *)a2 + 6);
      v121 = *((_DWORD *)a2 + 7);
      v124 = v117[6];
      v123 = v117[7];
      if (v122 != v124 || v121 != v123)
        break;
      if (*((_DWORD *)a2 + 10) >= v117[10])
      {
LABEL_133:
        v128 = *(_OWORD *)v117;
        v129 = *((_OWORD *)v117 + 1);
        *(_OWORD *)(result + 28) = *(_OWORD *)(v117 + 7);
        *(_OWORD *)result = v128;
        *((_OWORD *)result + 1) = v129;
        v117 += 11;
        goto LABEL_134;
      }
LABEL_131:
      v126 = *(_OWORD *)a2;
      v127 = *((_OWORD *)a2 + 1);
      *(_OWORD *)(result + 28) = *(_OWORD *)(a2 + 28);
      *(_OWORD *)result = v126;
      *((_OWORD *)result + 1) = v127;
      a2 += 44;
LABEL_134:
      result += 44;
      if (&a6[v113 / 4] == v117)
        return result;
    }
    if (v122 < v124)
      goto LABEL_131;
    if (v124 < v122)
      goto LABEL_133;
    v120 = v121 >= v123;
LABEL_130:
    if (v120)
      goto LABEL_133;
    goto LABEL_131;
  }
  if (a2 == a3)
    return result;
  v96 = 0;
  do
  {
    v97 = &a6[v96 / 4];
    v98 = *(_OWORD *)&a2[v96];
    v99 = *(_OWORD *)&a2[v96 + 16];
    *(_OWORD *)((char *)v97 + 28) = *(_OWORD *)&a2[v96 + 28];
    *v97 = v98;
    v97[1] = v99;
    v96 += 44;
  }
  while (&a2[v96] != a3);
  if (!v96)
    return result;
  v100 = &a6[v96 / 4];
  v101 = a3 - 44;
  while (a2 != result)
  {
    v102 = a2 - 44;
    v103 = *(v100 - 7);
    v104 = *((_DWORD *)a2 - 7);
    v105 = v103 >= v104;
    if (v103 != v104)
      goto LABEL_110;
    v107 = *(v100 - 5);
    v106 = *(v100 - 4);
    v109 = *((_DWORD *)a2 - 5);
    v108 = *((_DWORD *)a2 - 4);
    if (v107 != v109 || v106 != v108)
    {
      if (v107 < v109)
        goto LABEL_111;
      if (v109 < v107)
        goto LABEL_113;
      v105 = v106 >= v108;
LABEL_110:
      if (v105)
        goto LABEL_113;
      goto LABEL_111;
    }
    if (*(v100 - 1) >= *((_DWORD *)a2 - 1))
    {
LABEL_113:
      v102 = (char *)(v100 - 11);
      v100 -= 11;
      goto LABEL_114;
    }
LABEL_111:
    a2 -= 44;
LABEL_114:
    v111 = *(_OWORD *)v102;
    v112 = *((_OWORD *)v102 + 1);
    *(_OWORD *)(v101 + 28) = *(_OWORD *)(v102 + 28);
    *(_OWORD *)v101 = v111;
    *((_OWORD *)v101 + 1) = v112;
    v101 -= 44;
    if (v100 == a6)
      return result;
  }
  if (v100 != a6)
  {
    v133 = 0;
    do
    {
      v134 = &v101[v133 * 4];
      v135 = *(_OWORD *)&v100[v133 - 11];
      v136 = *(_OWORD *)&v100[v133 - 7];
      *(_OWORD *)(v134 + 28) = *(_OWORD *)&v100[v133 - 4];
      *(_OWORD *)v134 = v135;
      *((_OWORD *)v134 + 1) = v136;
      v133 -= 11;
    }
    while (&v100[v133] != a6);
  }
  return result;
}

_QWORD *llvm::coverage::CoverageMappingIterator::increment(_QWORD *this)
{
  _QWORD *v1;
  _QWORD *v2;
  char **v3;
  char **v4;
  char *v5;
  char *v6;
  int v7;
  int v8;
  _QWORD *v9;
  char *v10;
  char *v11;
  char *v12;

  if (!*((_DWORD *)this + 20))
  {
    v1 = this;
    this = (*(_QWORD *(**)(_QWORD **__return_ptr, _QWORD, _QWORD *))(*(_QWORD *)*this + 16))(&v9, *this, this + 1);
    v2 = v9;
    if (v9)
    {
      v9 = 0;
      if ((*(unsigned int (**)(_QWORD *, void *))(*v2 + 48))(v2, &llvm::ErrorList::ID))
      {
        v3 = (char **)v2[1];
        v4 = (char **)v2[2];
        if (v3 != v4)
        {
          v5 = 0;
          do
          {
            v11 = v5;
            v6 = *v3;
            *v3 = 0;
            if ((*(unsigned int (**)(char *, void *))(*(_QWORD *)v6 + 48))(v6, &llvm::coverage::CoverageMapError::ID))
            {
              v7 = *((_DWORD *)v6 + 2);
              if (v7 == 1)
              {
                *v1 = 0;
                v1[1] = 0;
                v1[2] = 0;
                *((_OWORD *)v1 + 2) = 0u;
                *((_OWORD *)v1 + 3) = 0u;
                *((_OWORD *)v1 + 4) = 0u;
                *((_DWORD *)v1 + 20) = 0;
              }
              else
              {
                *((_DWORD *)v1 + 20) = v7;
              }
              v10 = 0;
              (*(void (**)(char *))(*(_QWORD *)v6 + 8))(v6);
            }
            else
            {
              v10 = v6;
            }
            sub_1C6174794(&v11, &v10, &v12);
            v5 = v12;
            v12 = 0;
            if (v10)
              (*(void (**)(char *))(*(_QWORD *)v10 + 8))(v10);
            if (v11)
              (*(void (**)(char *))(*(_QWORD *)v11 + 8))(v11);
            ++v3;
          }
          while (v3 != v4);
        }
      }
      else
      {
        if (!(*(unsigned int (**)(_QWORD *, void *))(*v2 + 48))(v2, &llvm::coverage::CoverageMapError::ID))
          goto LABEL_24;
        v8 = *((_DWORD *)v2 + 2);
        if (v8 == 1)
        {
          *v1 = 0;
          v1[1] = 0;
          v1[2] = 0;
          *((_OWORD *)v1 + 2) = 0u;
          *((_OWORD *)v1 + 3) = 0u;
          *((_OWORD *)v1 + 4) = 0u;
          *((_DWORD *)v1 + 20) = 0;
        }
        else
        {
          *((_DWORD *)v1 + 20) = v8;
        }
      }
      (*(void (**)(_QWORD *))(*v2 + 8))(v2);
LABEL_24:
      this = v9;
      if (v9)
        return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v9 + 8))(v9);
    }
  }
  return this;
}

uint64_t llvm::coverage::RawCoverageReader::readString@<X0>(char **this@<X0>, llvm::StringRef *a2@<X1>, char ***a3@<X8>)
{
  uint64_t result;
  unint64_t v7;
  unint64_t v8;
  char *v9;
  unint64_t v10;

  v10 = 0;
  result = llvm::coverage::RawCoverageReader::readSize(this, &v10, a3);
  if (!*a3)
  {
    v7 = v10;
    v8 = (unint64_t)this[1];
    if (v8 >= v10)
      v8 = v10;
    *(_QWORD *)a2 = *this;
    *((_QWORD *)a2 + 1) = v8;
    v9 = this[1];
    if ((unint64_t)v9 < v7)
      v7 = (unint64_t)this[1];
    *this += v7;
    this[1] = &v9[-v7];
    *a3 = 0;
  }
  return result;
}

void llvm::coverage::RawCoverageFilenamesReader::read(char **a1@<X0>, int a2@<W1>, char ***a3@<X8>)
{
  unint64_t v6;
  uint64_t v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;

  v11 = 0;
  llvm::coverage::RawCoverageReader::readSize(a1, &v11, a3);
  if (*a3)
    return;
  v6 = v11;
  if (!v11)
  {
    v7 = operator new();
    *(_QWORD *)v7 = &off_1E8169028;
    v8 = 5;
    goto LABEL_7;
  }
  if (a2 <= 2)
  {
    llvm::coverage::RawCoverageFilenamesReader::readUncompressed(a1, a2, v11, a3);
    return;
  }
  llvm::coverage::RawCoverageReader::readULEB128(a1, &v10, a3);
  if (!*a3)
  {
    v9 = 0;
    llvm::coverage::RawCoverageReader::readSize(a1, &v9, a3);
    if (!*a3)
    {
      if (!v9)
      {
        llvm::coverage::RawCoverageFilenamesReader::readUncompressed(a1, a2, v6, a3);
        return;
      }
      v7 = operator new();
      *(_QWORD *)v7 = &off_1E8169028;
      v8 = 6;
LABEL_7:
      *(_DWORD *)(v7 + 8) = v8;
      *a3 = (char **)v7;
    }
  }
}

void llvm::coverage::RawCoverageFilenamesReader::readUncompressed(char **this@<X0>, int a2@<W1>, unint64_t a3@<X2>, char ***a4@<X8>)
{
  unint64_t v4;
  uint64_t v7;
  char *v8;
  const void *v9;
  size_t v10;
  __int128 *p_dst;
  size_t v12;
  size_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  char *v21;
  char *v22;
  uint64_t v23;
  void *v24;
  char *v25;
  __int128 v26;
  void *v27;
  char v28;
  char *v29;
  uint64_t v30;
  char *v31;
  void *v32;
  size_t v33;
  __int128 *v34;
  size_t v35;
  size_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  char *v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  char *v45;
  char *v46;
  uint64_t v47;
  void *v48;
  char *v49;
  __int128 v50;
  void *v51;
  uint64_t v52;
  uint64_t v53;
  size_t v54;
  const void *v55;
  char *v56;
  __int128 *v57;
  size_t v58;
  size_t v59;
  char *v60;
  uint64_t *v61;
  size_t v62;
  char *v63;
  void *v64;
  void *v65;
  size_t v66;
  size_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  char *v74;
  uint64_t v75;
  uint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  unint64_t v82;
  char *v83;
  char *v84;
  uint64_t v85;
  void *v86;
  char *v87;
  __int128 v88;
  void *v89;
  char v90;
  char *v91;
  unint64_t v92;
  uint64_t v93;
  char *v94;
  __int128 v95;
  uint64_t v96;
  char v97;
  char *v98;
  uint64_t v99;
  char *v100;
  uint64_t v101;
  void **v103;
  __int16 v104;
  _QWORD *v105;
  __int16 v106;
  size_t __len[2];
  unint64_t v108;
  __int16 v109;
  void *v110;
  size_t v111;
  void *__src;
  size_t v113;
  __int128 __dst;
  unint64_t v115;
  uint64_t v116;
  _QWORD *v117;
  void *v118;
  size_t v119;
  uint64_t v120;
  uint64_t v121;
  _QWORD *v122;
  uint64_t v123;

  v4 = a3;
  v123 = *MEMORY[0x1E0C80C00];
  if (a2 <= 4)
  {
    if (a3)
    {
      v7 = 0;
      while (1)
      {
        __len[0] = 0;
        __len[1] = 0;
        llvm::coverage::RawCoverageReader::readString(this, (llvm::StringRef *)__len, a4);
        if (*a4)
          return;
        v8 = this[2];
        v9 = (const void *)__len[0];
        if (__len[0])
          break;
        __dst = 0uLL;
        v115 = 0;
LABEL_16:
        v15 = *((_QWORD *)v8 + 2);
        v16 = *((_QWORD *)v8 + 1);
        if (v16 >= v15)
        {
          v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v16 - *(_QWORD *)v8) >> 3);
          v18 = v17 + 1;
          if (v17 + 1 > 0xAAAAAAAAAAAAAAALL)
            goto LABEL_143;
          v19 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v15 - *(_QWORD *)v8) >> 3);
          if (2 * v19 > v18)
            v18 = 2 * v19;
          if (v19 >= 0x555555555555555)
            v20 = 0xAAAAAAAAAAAAAAALL;
          else
            v20 = v18;
          v122 = v8 + 16;
          if (v20)
          {
            if (v20 > 0xAAAAAAAAAAAAAAALL)
              goto LABEL_144;
            v21 = (char *)operator new(24 * v20);
          }
          else
          {
            v21 = 0;
          }
          v22 = &v21[24 * v17];
          *((_QWORD *)v22 + 2) = v115;
          *(_OWORD *)v22 = __dst;
          v115 = 0;
          __dst = 0uLL;
          v24 = *(void **)v8;
          v23 = *((_QWORD *)v8 + 1);
          if (v23 == *(_QWORD *)v8)
          {
            v28 = 0;
            v27 = (void *)*((_QWORD *)v8 + 1);
            v25 = v22;
          }
          else
          {
            v25 = &v21[24 * v17];
            do
            {
              v26 = *(_OWORD *)(v23 - 24);
              *((_QWORD *)v25 - 1) = *(_QWORD *)(v23 - 8);
              *(_OWORD *)(v25 - 24) = v26;
              v25 -= 24;
              *(_QWORD *)(v23 - 16) = 0;
              *(_QWORD *)(v23 - 8) = 0;
              *(_QWORD *)(v23 - 24) = 0;
              v23 -= 24;
            }
            while ((void *)v23 != v24);
            v27 = *(void **)v8;
            v23 = *((_QWORD *)v8 + 1);
            v28 = HIBYTE(v115);
          }
          v29 = v22 + 24;
          *(_QWORD *)v8 = v25;
          v118 = v27;
          v119 = (size_t)v27;
          *((_QWORD *)v8 + 1) = v22 + 24;
          v120 = v23;
          v30 = *((_QWORD *)v8 + 2);
          *((_QWORD *)v8 + 2) = &v21[24 * v20];
          v121 = v30;
          sub_1C4D868F0((uint64_t)&v118);
          *((_QWORD *)v8 + 1) = v29;
          if (v28 < 0)
            operator delete((void *)__dst);
        }
        else
        {
          *(_OWORD *)v16 = __dst;
          *(_QWORD *)(v16 + 16) = v115;
          *((_QWORD *)v8 + 1) = v16 + 24;
        }
        if (++v7 == v4)
          goto LABEL_141;
      }
      v10 = __len[1];
      if (__len[1] > 0x7FFFFFFFFFFFFFF7)
        goto LABEL_143;
      if (__len[1] >= 0x17)
      {
        v12 = (__len[1] & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((__len[1] | 7) != 0x17)
          v12 = __len[1] | 7;
        v13 = v12 + 1;
        p_dst = (__int128 *)operator new(v12 + 1);
        v14 = v13 | 0x8000000000000000;
        v4 = a3;
        *((_QWORD *)&__dst + 1) = v10;
        v115 = v14;
        *(_QWORD *)&__dst = p_dst;
      }
      else
      {
        HIBYTE(v115) = __len[1];
        p_dst = &__dst;
        if (!__len[1])
          goto LABEL_15;
      }
      memmove(p_dst, v9, v10);
LABEL_15:
      *((_BYTE *)p_dst + v10) = 0;
      goto LABEL_16;
    }
    goto LABEL_141;
  }
  __src = 0;
  v113 = 0;
  llvm::coverage::RawCoverageReader::readString(this, (llvm::StringRef *)&__src, a4);
  if (*a4)
    return;
  v31 = this[2];
  v32 = __src;
  if (!__src)
  {
    __dst = 0uLL;
    v115 = 0;
    goto LABEL_49;
  }
  v33 = v113;
  if (v113 > 0x7FFFFFFFFFFFFFF7)
    goto LABEL_143;
  if (v113 >= 0x17)
  {
    v35 = (v113 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v113 | 7) != 0x17)
      v35 = v113 | 7;
    v36 = v35 + 1;
    v34 = (__int128 *)operator new(v35 + 1);
    v37 = v36 | 0x8000000000000000;
    v4 = a3;
    *((_QWORD *)&__dst + 1) = v33;
    v115 = v37;
    *(_QWORD *)&__dst = v34;
  }
  else
  {
    HIBYTE(v115) = v113;
    v34 = &__dst;
    if (!v113)
      goto LABEL_48;
  }
  memmove(v34, v32, v33);
LABEL_48:
  *((_BYTE *)v34 + v33) = 0;
LABEL_49:
  v38 = *((_QWORD *)v31 + 2);
  v39 = *((_QWORD *)v31 + 1);
  if (v39 < v38)
  {
    *(_OWORD *)v39 = __dst;
    *(_QWORD *)(v39 + 16) = v115;
    v40 = (char *)(v39 + 24);
    goto LABEL_67;
  }
  v41 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v39 - *(_QWORD *)v31) >> 3);
  v42 = v41 + 1;
  if (v41 + 1 > 0xAAAAAAAAAAAAAAALL)
LABEL_143:
    abort();
  v43 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v38 - *(_QWORD *)v31) >> 3);
  if (2 * v43 > v42)
    v42 = 2 * v43;
  if (v43 >= 0x555555555555555)
    v44 = 0xAAAAAAAAAAAAAAALL;
  else
    v44 = v42;
  v122 = v31 + 16;
  if (v44)
  {
    if (v44 > 0xAAAAAAAAAAAAAAALL)
LABEL_144:
      sub_1C4764EE4();
    v45 = (char *)operator new(24 * v44);
  }
  else
  {
    v45 = 0;
  }
  v46 = &v45[24 * v41];
  *(_OWORD *)v46 = __dst;
  *((_QWORD *)v46 + 2) = v115;
  v48 = *(void **)v31;
  v47 = *((_QWORD *)v31 + 1);
  if (v47 == *(_QWORD *)v31)
  {
    v51 = (void *)*((_QWORD *)v31 + 1);
    v49 = &v45[24 * v41];
  }
  else
  {
    v49 = &v45[24 * v41];
    do
    {
      v50 = *(_OWORD *)(v47 - 24);
      *((_QWORD *)v49 - 1) = *(_QWORD *)(v47 - 8);
      *(_OWORD *)(v49 - 24) = v50;
      v49 -= 24;
      *(_QWORD *)(v47 - 16) = 0;
      *(_QWORD *)(v47 - 8) = 0;
      *(_QWORD *)(v47 - 24) = 0;
      v47 -= 24;
    }
    while ((void *)v47 != v48);
    v51 = *(void **)v31;
    v47 = *((_QWORD *)v31 + 1);
  }
  v40 = v46 + 24;
  *(_QWORD *)v31 = v49;
  v118 = v51;
  v119 = (size_t)v51;
  *((_QWORD *)v31 + 1) = v46 + 24;
  v120 = v47;
  v52 = *((_QWORD *)v31 + 2);
  *((_QWORD *)v31 + 2) = &v45[24 * v44];
  v121 = v52;
  sub_1C4D868F0((uint64_t)&v118);
LABEL_67:
  *((_QWORD *)v31 + 1) = v40;
  if (v4 >= 2)
  {
    v53 = 1;
    while (1)
    {
      v110 = 0;
      v111 = 0;
      llvm::coverage::RawCoverageReader::readString(this, (llvm::StringRef *)&v110, a4);
      if (*a4)
        return;
      LOWORD(v122) = 261;
      v55 = v110;
      v54 = v111;
      v118 = v110;
      v119 = v111;
      if (llvm::sys::path::is_absolute((const char **)&v118, 0))
      {
        v56 = this[2];
        if (v55)
        {
          if (v54 > 0x7FFFFFFFFFFFFFF7)
            goto LABEL_143;
          if (v54 >= 0x17)
          {
            v75 = (v54 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v54 | 7) != 0x17)
              v75 = v54 | 7;
            v76 = v75 + 1;
            v57 = (__int128 *)operator new(v75 + 1);
            *((_QWORD *)&__dst + 1) = v54;
            v115 = v76 | 0x8000000000000000;
            *(_QWORD *)&__dst = v57;
          }
          else
          {
            HIBYTE(v115) = v54;
            v57 = &__dst;
            if (!v54)
            {
LABEL_107:
              *((_BYTE *)v57 + v54) = 0;
              v4 = a3;
LABEL_108:
              v77 = *((_QWORD *)v56 + 2);
              v78 = *((_QWORD *)v56 + 1);
              if (v78 >= v77)
              {
                v79 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v78 - *(_QWORD *)v56) >> 3);
                v80 = v79 + 1;
                if (v79 + 1 > 0xAAAAAAAAAAAAAAALL)
                  goto LABEL_143;
                v81 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v77 - *(_QWORD *)v56) >> 3);
                if (2 * v81 > v80)
                  v80 = 2 * v81;
                if (v81 >= 0x555555555555555)
                  v82 = 0xAAAAAAAAAAAAAAALL;
                else
                  v82 = v80;
                v122 = v56 + 16;
                if (v82)
                {
                  if (v82 > 0xAAAAAAAAAAAAAAALL)
                    goto LABEL_144;
                  v83 = (char *)operator new(24 * v82);
                }
                else
                {
                  v83 = 0;
                }
                v84 = &v83[24 * v79];
                *((_QWORD *)v84 + 2) = v115;
                *(_OWORD *)v84 = __dst;
                v115 = 0;
                __dst = 0uLL;
                v86 = *(void **)v56;
                v85 = *((_QWORD *)v56 + 1);
                if (v85 == *(_QWORD *)v56)
                {
                  v90 = 0;
                  v89 = (void *)*((_QWORD *)v56 + 1);
                  v87 = v84;
                }
                else
                {
                  v87 = &v83[24 * v79];
                  do
                  {
                    v88 = *(_OWORD *)(v85 - 24);
                    *((_QWORD *)v87 - 1) = *(_QWORD *)(v85 - 8);
                    *(_OWORD *)(v87 - 24) = v88;
                    v87 -= 24;
                    *(_QWORD *)(v85 - 16) = 0;
                    *(_QWORD *)(v85 - 8) = 0;
                    *(_QWORD *)(v85 - 24) = 0;
                    v85 -= 24;
                  }
                  while ((void *)v85 != v86);
                  v89 = *(void **)v56;
                  v85 = *((_QWORD *)v56 + 1);
                  v90 = HIBYTE(v115);
                }
                v98 = v84 + 24;
                *(_QWORD *)v56 = v87;
                v118 = v89;
                v119 = (size_t)v89;
                *((_QWORD *)v56 + 1) = v84 + 24;
                v120 = v85;
                v99 = *((_QWORD *)v56 + 2);
                *((_QWORD *)v56 + 2) = &v83[24 * v82];
                v121 = v99;
                sub_1C4D868F0((uint64_t)&v118);
                *((_QWORD *)v56 + 1) = v98;
                v4 = a3;
                if (v90 < 0)
                  operator delete((void *)__dst);
              }
              else
              {
                *(_OWORD *)v78 = __dst;
                *(_QWORD *)(v78 + 16) = v115;
                *((_QWORD *)v56 + 1) = v78 + 24;
              }
              goto LABEL_137;
            }
          }
          memmove(v57, v55, v54);
          goto LABEL_107;
        }
        __dst = 0uLL;
        v115 = 0;
        goto LABEL_108;
      }
      v118 = &v121;
      v120 = 256;
      v58 = (size_t)this[4];
      if (v58)
        break;
      v59 = 0;
      v60 = (char *)__src;
      v58 = v113;
      v119 = 0;
      if (v113 < 0x101)
      {
        if (!v113)
          goto LABEL_84;
LABEL_82:
        v61 = (uint64_t *)v118;
LABEL_83:
        memcpy((char *)v61 + v59, v60, v58);
        v59 = v119;
        goto LABEL_84;
      }
      llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v118, &v121, v113, 1);
      v59 = v119;
      if (v58)
        goto LABEL_82;
LABEL_84:
      v119 = v59 + v58;
      LOWORD(v117) = 261;
      *(_QWORD *)&__dst = v55;
      *((_QWORD *)&__dst + 1) = v54;
      v109 = 257;
      v106 = 257;
      v104 = 257;
      llvm::sys::path::append(&v118, 0, (_QWORD **)&__dst, (_QWORD **)__len, &v105, &v103);
      v62 = v119;
      if (v119 > 0x7FFFFFFFFFFFFFF7)
        goto LABEL_143;
      v63 = this[2];
      v64 = v118;
      if (v119 >= 0x17)
      {
        v66 = (v119 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v119 | 7) != 0x17)
          v66 = v119 | 7;
        v67 = v66 + 1;
        v65 = operator new(v66 + 1);
        __len[1] = v62;
        v108 = v67 | 0x8000000000000000;
        __len[0] = (size_t)v65;
      }
      else
      {
        HIBYTE(v108) = v119;
        v65 = __len;
        if (!v119)
          goto LABEL_92;
      }
      memmove(v65, v64, v62);
LABEL_92:
      *((_BYTE *)v65 + v62) = 0;
      v68 = *((_QWORD *)v63 + 2);
      v69 = *((_QWORD *)v63 + 1);
      if (v69 >= v68)
      {
        v70 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v69 - *(_QWORD *)v63) >> 3);
        v71 = v70 + 1;
        if (v70 + 1 > 0xAAAAAAAAAAAAAAALL)
          goto LABEL_143;
        v72 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v68 - *(_QWORD *)v63) >> 3);
        if (2 * v72 > v71)
          v71 = 2 * v72;
        if (v72 >= 0x555555555555555)
          v73 = 0xAAAAAAAAAAAAAAALL;
        else
          v73 = v71;
        v117 = v63 + 16;
        if (v73)
        {
          if (v73 > 0xAAAAAAAAAAAAAAALL)
            goto LABEL_144;
          v74 = (char *)operator new(24 * v73);
        }
        else
        {
          v74 = 0;
        }
        v91 = &v74[24 * v70];
        *((_QWORD *)v91 + 2) = v108;
        *(_OWORD *)v91 = *(_OWORD *)__len;
        __len[1] = 0;
        v108 = 0;
        __len[0] = 0;
        v93 = *(_QWORD *)v63;
        v92 = *((_QWORD *)v63 + 1);
        if (v92 == *(_QWORD *)v63)
        {
          v97 = 0;
          v96 = *((_QWORD *)v63 + 1);
          v94 = v91;
        }
        else
        {
          v94 = &v74[24 * v70];
          do
          {
            v95 = *(_OWORD *)(v92 - 24);
            *((_QWORD *)v94 - 1) = *(_QWORD *)(v92 - 8);
            *(_OWORD *)(v94 - 24) = v95;
            v94 -= 24;
            *(_QWORD *)(v92 - 16) = 0;
            *(_QWORD *)(v92 - 8) = 0;
            *(_QWORD *)(v92 - 24) = 0;
            v92 -= 24;
          }
          while (v92 != v93);
          v96 = *(_QWORD *)v63;
          v92 = *((_QWORD *)v63 + 1);
          v97 = HIBYTE(v108);
        }
        v100 = v91 + 24;
        *(_QWORD *)v63 = v94;
        *(_QWORD *)&__dst = v96;
        *((_QWORD *)&__dst + 1) = v96;
        *((_QWORD *)v63 + 1) = v91 + 24;
        v115 = v92;
        v101 = *((_QWORD *)v63 + 2);
        *((_QWORD *)v63 + 2) = &v74[24 * v73];
        v116 = v101;
        sub_1C4D868F0((uint64_t)&__dst);
        *((_QWORD *)v63 + 1) = v100;
        v4 = a3;
        if (v97 < 0)
          operator delete((void *)__len[0]);
      }
      else
      {
        *(_OWORD *)v69 = *(_OWORD *)__len;
        *(_QWORD *)(v69 + 16) = v108;
        *((_QWORD *)v63 + 1) = v69 + 24;
        v4 = a3;
      }
      if (v118 != &v121)
        free(v118);
LABEL_137:
      if (++v53 == v4)
        goto LABEL_141;
    }
    v59 = 0;
    v60 = this[3];
    v119 = 0;
    v61 = &v121;
    if (v58 >= 0x101)
    {
      llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v118, &v121, v58, 1);
      v59 = v119;
      goto LABEL_82;
    }
    goto LABEL_83;
  }
LABEL_141:
  *a4 = 0;
}

void llvm::coverage::RawCoverageMappingReader::readMappingRegionsSubArray(char **a1@<X0>, char **a2@<X1>, int a3@<W2>, unint64_t a4@<X3>, char ***a5@<X8>)
{
  unint64_t v10;
  unsigned int v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  unint64_t v15;
  unint64_t v16;
  int v17;
  unsigned int v18;
  unsigned int v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  char *v23;
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  char *v31;
  char *v32;
  char *v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unsigned int v40;
  int v41;
  int v42;
  unint64_t v43;
  unsigned int v44;
  uint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;

  v53 = 0;
  llvm::coverage::RawCoverageReader::readSize(a1, &v53, a5);
  if (!*a5)
  {
    v10 = v53;
    if (v53)
    {
      v11 = 0;
      v12 = 0;
      while (1)
      {
        v51 = 0;
        v52 = 0;
        v50 = 0;
        llvm::coverage::RawCoverageReader::readIntMax(a1, &v50, 0xFFFFFFFFuLL, a5);
        if (*a5)
          break;
        if ((v50 & 3) != 0)
        {
          llvm::coverage::RawCoverageMappingReader::decodeCounter((uint64_t)a1, v50, &v52, (uint64_t *)a5);
          if (*a5)
            return;
          v45 = v12;
          v14 = 0;
          LODWORD(v13) = 0;
        }
        else
        {
          v13 = v50 >> 3;
          if ((v50 & 4) != 0)
          {
            if (v13 >= a4)
              goto LABEL_57;
            v45 = v12;
            v14 = 1;
          }
          else if (v13)
          {
            if (v13 == 4)
            {
              llvm::coverage::RawCoverageMappingReader::readCounter(a1, &v52, a5);
              if (*a5)
                return;
              llvm::coverage::RawCoverageMappingReader::readCounter(a1, &v51, a5);
              if (*a5)
                return;
              v45 = v12;
              LODWORD(v13) = 0;
              v14 = 4;
            }
            else
            {
              if (v13 != 2)
                goto LABEL_57;
              v45 = v12;
              LODWORD(v13) = 0;
              v14 = 2;
            }
          }
          else
          {
            v45 = v12;
            v14 = 0;
          }
        }
        v48 = 0;
        v49 = 0;
        v46 = 0;
        v47 = 0;
        llvm::coverage::RawCoverageReader::readIntMax(a1, &v49, 0xFFFFFFFFuLL, a5);
        if (*a5)
          return;
        llvm::coverage::RawCoverageReader::readULEB128(a1, &v48, a5);
        if (*a5)
          return;
        v15 = v48;
        if (HIDWORD(v48))
          goto LABEL_57;
        llvm::coverage::RawCoverageReader::readIntMax(a1, &v47, 0xFFFFFFFFuLL, a5);
        if (*a5)
          return;
        llvm::coverage::RawCoverageReader::readIntMax(a1, &v46, 0xFFFFFFFFuLL, a5);
        if (*a5)
          return;
        if ((v46 & 0x80000000) != 0)
          v16 = v46 & 0x7FFFFFFF;
        else
          v16 = v46;
        if ((v46 & 0x80000000) != 0)
          v17 = 3;
        else
          v17 = v14;
        if (!(v16 | v15))
        {
          v48 = 1;
          LODWORD(v16) = -1;
          LODWORD(v15) = 1;
        }
        v18 = v11 + v49;
        v19 = v18 + v47;
        if (__CFADD__(v18, (_DWORD)v47) || (v20 = v51, v21 = v52, v15 > v16) && v18 >= v19)
        {
LABEL_57:
          v36 = operator new();
          *(_QWORD *)v36 = &off_1E8169028;
          *(_DWORD *)(v36 + 8) = 5;
          *a5 = (char **)v36;
          return;
        }
        v23 = a2[1];
        v22 = (unint64_t)a2[2];
        v44 = v18;
        if ((unint64_t)v23 >= v22)
        {
          v26 = *a2;
          v27 = 0x2E8BA2E8BA2E8BA3 * ((v23 - *a2) >> 2);
          v28 = v27 + 1;
          if ((unint64_t)(v27 + 1) > 0x5D1745D1745D174)
            abort();
          v29 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v22 - (_QWORD)v26) >> 2);
          if (2 * v29 > v28)
            v28 = 2 * v29;
          if (v29 >= 0x2E8BA2E8BA2E8BALL)
            v30 = 0x5D1745D1745D174;
          else
            v30 = v28;
          v43 = v30;
          if (v30)
          {
            v37 = 0x2E8BA2E8BA2E8BA3 * ((v23 - *a2) >> 2);
            v38 = v52;
            v39 = v51;
            v40 = v19;
            v41 = v16;
            v42 = v17;
            if (v30 > 0x5D1745D1745D174)
              sub_1C4764EE4();
            v31 = (char *)operator new(44 * v30);
            v17 = v42;
            LODWORD(v16) = v41;
            v19 = v40;
            v21 = v38;
            v20 = v39;
            v27 = v37;
          }
          else
          {
            v31 = 0;
          }
          v32 = &v31[44 * v27];
          *(_QWORD *)v32 = v21;
          *((_QWORD *)v32 + 1) = v20;
          *((_DWORD *)v32 + 4) = a3;
          *((_DWORD *)v32 + 5) = v13;
          *((_DWORD *)v32 + 6) = v44;
          *((_DWORD *)v32 + 7) = v15;
          *((_DWORD *)v32 + 8) = v19;
          *((_DWORD *)v32 + 9) = v16;
          *((_DWORD *)v32 + 10) = v17;
          v33 = v32;
          if (v23 == v26)
          {
            v25 = v45;
          }
          else
          {
            v25 = v45;
            do
            {
              v34 = *(_OWORD *)(v23 - 44);
              v35 = *(_OWORD *)(v23 - 28);
              *((_OWORD *)v33 - 1) = *((_OWORD *)v23 - 1);
              *(_OWORD *)(v33 - 28) = v35;
              *(_OWORD *)(v33 - 44) = v34;
              v33 -= 44;
              v23 -= 44;
            }
            while (v23 != v26);
            v23 = *a2;
          }
          v24 = v32 + 44;
          *a2 = v33;
          a2[1] = v32 + 44;
          a2[2] = &v31[44 * v43];
          if (v23)
            operator delete(v23);
        }
        else
        {
          *(_QWORD *)v23 = v52;
          *((_QWORD *)v23 + 1) = v20;
          *((_DWORD *)v23 + 4) = a3;
          *((_DWORD *)v23 + 5) = v13;
          *((_DWORD *)v23 + 6) = v18;
          *((_DWORD *)v23 + 7) = v15;
          *((_DWORD *)v23 + 8) = v19;
          *((_DWORD *)v23 + 9) = v16;
          v24 = v23 + 44;
          *((_DWORD *)v23 + 10) = v17;
          v25 = v45;
        }
        a2[1] = v24;
        v12 = v25 + 1;
        v11 = v44;
        if (v12 == v10)
          goto LABEL_56;
      }
    }
    else
    {
LABEL_56:
      *a5 = 0;
    }
  }
}

uint64_t llvm::coverage::RawCoverageMappingDummyChecker::isDummy@<X0>(char **this@<X0>, uint64_t a2@<X8>)
{
  uint64_t result;
  char **v5;
  _BOOL8 v6;
  char **v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;

  v12 = 0;
  result = llvm::coverage::RawCoverageReader::readSize(this, &v12, (char ***)&v11);
  v5 = (char **)v11;
  if (v11)
    goto LABEL_2;
  if (v12 != 1)
    goto LABEL_4;
  v11 = 0;
  result = llvm::coverage::RawCoverageReader::readIntMax(this, &v11, 0xFFFFFFFFuLL, (char ***)&v10);
  v5 = (char **)v10;
  if (v10
    || (v10 = 0,
        result = llvm::coverage::RawCoverageReader::readSize(this, &v10, (char ***)&v9),
        (v5 = (char **)v9) != 0))
  {
LABEL_2:
    *(_BYTE *)(a2 + 8) |= 1u;
    *(_QWORD *)a2 = v5;
    return result;
  }
  if (!v10)
  {
    v9 = 0;
    result = llvm::coverage::RawCoverageReader::readSize(this, &v9, (char ***)&v8);
    v5 = (char **)v8;
    if (v8)
      goto LABEL_2;
    if (v9 == 1)
    {
      v8 = 0;
      result = llvm::coverage::RawCoverageReader::readIntMax(this, &v8, 0xFFFFFFFFuLL, &v7);
      v5 = v7;
      if (!v7)
      {
        v6 = (v8 & 3) == 0;
        *(_BYTE *)(a2 + 8) &= ~1u;
        *(_BYTE *)a2 = v6;
        return result;
      }
      goto LABEL_2;
    }
  }
LABEL_4:
  *(_BYTE *)(a2 + 8) &= ~1u;
  *(_BYTE *)a2 = 0;
  return result;
}

uint64_t llvm::InstrProfSymtab::create@<X0>(uint64_t *a1@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v11[2];
  char v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  result = (uint64_t)(*(_QWORD *(**)(_QWORD *__return_ptr, _QWORD, _QWORD))(*(_QWORD *)a2[1] + 168))(v11, a2[1], *a2);
  v7 = v11[0];
  if ((v12 & 1) == 0)
  {
    v8 = v11[1];
    *a1 = v11[0];
    a1[1] = v8;
    a1[2] = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)a2[1] + 144))(a2[1], *a2);
    result = a2[1];
    if (*(_DWORD *)(result + 8) == 9
      && (result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 424))(result), (result & 1) == 0))
    {
      v7 = 0;
      v10 = *a1;
      v9 = a1[1];
      if (v9)
        ++v10;
      *a1 = v10;
      a1[1] = v9 - (v9 != 0);
    }
    else
    {
      v7 = 0;
    }
  }
  *a3 = v7;
  return result;
}

unint64_t llvm::InstrProfSymtab::getFuncName(llvm::InstrProfSymtab *this, unint64_t a2, uint64_t a3)
{
  unint64_t v3;
  BOOL v4;
  unint64_t v5;
  unint64_t v6;

  v3 = *((_QWORD *)this + 2);
  v4 = a2 >= v3;
  v5 = a2 - v3;
  if (!v4)
    return 0;
  v6 = *((_QWORD *)this + 1);
  if (v5 + a3 > v6)
    return 0;
  if (v6 < v5)
    v5 = *((_QWORD *)this + 1);
  return *(_QWORD *)this + v5;
}

uint64_t llvm::coverage::BinaryCoverageReader::createCoverageReaderFromBuffer@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, int a5@<W4>, int a6@<W5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>)
{
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  void *v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t result;
  uint64_t v29;
  uint64_t v30;
  uint64_t (**v31)();
  unsigned int v32;
  uint64_t v33;
  uint64_t (**v34)();
  uint64_t v35;
  uint64_t (**v36)();
  unsigned int v37;
  int v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t (**v42)();
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v48;
  unint64_t v49;
  char v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  v16 = operator new();
  *(_QWORD *)v16 = off_1E81690C0;
  *(_OWORD *)(v16 + 8) = 0u;
  v17 = v16 + 8;
  *(_OWORD *)(v16 + 24) = 0u;
  *(_OWORD *)(v16 + 40) = 0u;
  *(_OWORD *)(v16 + 72) = 0u;
  *(_OWORD *)(v16 + 84) = 0u;
  *(_OWORD *)(v16 + 56) = 0u;
  v18 = v16 + 56;
  *(_DWORD *)(v16 + 100) = 8;
  *(_OWORD *)(v16 + 112) = 0u;
  *(_OWORD *)(v16 + 128) = 0u;
  *(_OWORD *)(v16 + 144) = 0u;
  *(_OWORD *)(v16 + 160) = 0u;
  *(_OWORD *)(v16 + 169) = 0u;
  *(_OWORD *)(v16 + 192) = 0u;
  *(_OWORD *)(v16 + 208) = 0u;
  *(_OWORD *)(v16 + 224) = 0u;
  *(_OWORD *)(v16 + 240) = 0u;
  *(_OWORD *)(v16 + 256) = 0u;
  v19 = *a3;
  *a3 = 0;
  *(_QWORD *)(v16 + 272) = v19;
  *(_OWORD *)(v16 + 56) = *(_OWORD *)a4;
  *(_QWORD *)(v16 + 72) = *(_QWORD *)(a4 + 16);
  sub_1C624B9FC((uint64_t *)(v16 + 80), (uint64_t *)(a4 + 24));
  v20 = *(void **)(v16 + 112);
  if (v20)
  {
    *(_QWORD *)(v16 + 120) = v20;
    operator delete(v20);
  }
  *(_OWORD *)(v16 + 112) = *(_OWORD *)(a4 + 56);
  *(_QWORD *)(v16 + 128) = *(_QWORD *)(a4 + 72);
  *(_QWORD *)(a4 + 64) = 0;
  *(_QWORD *)(a4 + 72) = 0;
  *(_QWORD *)(a4 + 56) = 0;
  v21 = *(void **)(v16 + 136);
  if (v21)
  {
    *(_QWORD *)(v16 + 144) = v21;
    operator delete(v21);
  }
  *(_OWORD *)(v16 + 136) = *(_OWORD *)(a4 + 80);
  *(_QWORD *)(v16 + 152) = *(_QWORD *)(a4 + 96);
  *(_QWORD *)(a4 + 88) = 0;
  *(_QWORD *)(a4 + 96) = 0;
  *(_QWORD *)(a4 + 80) = 0;
  v22 = *(void **)(v16 + 160);
  if (v22)
  {
    *(_QWORD *)(v16 + 168) = v22;
    operator delete(v22);
  }
  *(_OWORD *)(v16 + 160) = *(_OWORD *)(a4 + 104);
  *(_QWORD *)(v16 + 176) = *(_QWORD *)(a4 + 120);
  *(_QWORD *)(a4 + 112) = 0;
  *(_QWORD *)(a4 + 120) = 0;
  *(_QWORD *)(a4 + 104) = 0;
  *(_BYTE *)(v16 + 184) = *(_BYTE *)(a4 + 128);
  v23 = *(_QWORD *)(v16 + 272);
  v25 = *(_QWORD *)(v23 + 8);
  v24 = *(_QWORD *)(v23 + 16);
  v26 = v24 - v25;
  if (a5 == 4 && a6 == 1)
  {
    v27 = *(_DWORD *)(a1 + 12);
    if (v27 < 6)
    {
      v45 = v24 - v25;
      if (v27)
      {
        llvm::readPGOFuncNameStrings(*(char **)(v16 + 56), *(_QWORD *)(v16 + 64), v16 + 56, (uint64_t *)&v49);
        result = v49;
        if (v49)
          goto LABEL_72;
        switch(v27)
        {
          case 1:
            v29 = operator new();
            v30 = v29;
            *(_QWORD *)(v29 + 16) = 0;
            v31 = &off_1E8169118;
            break;
          case 2:
            v29 = operator new();
            v30 = v29;
            *(_QWORD *)(v29 + 16) = 0;
            v31 = &off_1E8169148;
            break;
          case 3:
            v29 = operator new();
            v30 = v29;
            *(_QWORD *)(v29 + 16) = 0;
            v31 = &off_1E8169178;
            break;
          case 4:
            v29 = operator new();
            v30 = v29;
            *(_QWORD *)(v29 + 16) = 0;
            v31 = &off_1E81691A8;
            break;
          default:
            v29 = operator new();
            v30 = v29;
            *(_QWORD *)(v29 + 16) = 0;
            v31 = &off_1E81691D8;
            break;
        }
      }
      else
      {
        v29 = operator new();
        v30 = v29;
        *(_QWORD *)(v29 + 16) = 0;
        v31 = &off_1E81690E8;
      }
      *(_QWORD *)v29 = v31;
      *(_QWORD *)(v29 + 8) = 0;
      *(_DWORD *)(v29 + 24) = 0;
      *(_QWORD *)(v29 + 32) = v18;
      *(_QWORD *)(v29 + 40) = a7;
      *(_QWORD *)(v29 + 48) = a8;
      *(_QWORD *)(v29 + 56) = v17;
      *(_QWORD *)(v29 + 64) = v16 + 32;
      *(_QWORD *)(v29 + 72) = 0;
      *(_QWORD *)(v29 + 80) = 0;
      *(_DWORD *)(v29 + 88) = 0;
      if (a2 >= 1)
      {
        v39 = a1 + a2;
        while (1)
        {
          (*(void (**)(unint64_t *__return_ptr, uint64_t, uint64_t, unint64_t))(*(_QWORD *)v30 + 16))(&v49, v30, a1, v39);
          a1 = v49;
          if ((v50 & 1) != 0)
          {
            if (v49)
              break;
          }
          if (v49 >= v39)
            goto LABEL_68;
        }
LABEL_70:
        v48 = a1;
        goto LABEL_71;
      }
      goto LABEL_68;
    }
    goto LABEL_31;
  }
  if (a5 != 4 || a6)
  {
    if (a5 == 8 && a6 == 1)
    {
      v27 = *(_DWORD *)(a1 + 12);
      if (v27 < 6)
      {
        v45 = v24 - v25;
        if (v27)
        {
          llvm::readPGOFuncNameStrings(*(char **)(v16 + 56), *(_QWORD *)(v16 + 64), v16 + 56, (uint64_t *)&v49);
          result = v49;
          if (v49)
            goto LABEL_72;
          switch(v27)
          {
            case 1:
              v35 = operator new();
              v30 = v35;
              *(_QWORD *)(v35 + 16) = 0;
              v36 = &off_1E8169358;
              break;
            case 2:
              v35 = operator new();
              v30 = v35;
              *(_QWORD *)(v35 + 16) = 0;
              v36 = &off_1E8169388;
              break;
            case 3:
              v35 = operator new();
              v30 = v35;
              *(_QWORD *)(v35 + 16) = 0;
              v36 = &off_1E81693B8;
              break;
            case 4:
              v35 = operator new();
              v30 = v35;
              *(_QWORD *)(v35 + 16) = 0;
              v36 = &off_1E81693E8;
              break;
            default:
              v35 = operator new();
              v30 = v35;
              *(_QWORD *)(v35 + 16) = 0;
              v36 = &off_1E8169418;
              break;
          }
        }
        else
        {
          v35 = operator new();
          v30 = v35;
          *(_QWORD *)(v35 + 16) = 0;
          v36 = &off_1E8169328;
        }
        *(_QWORD *)v35 = v36;
        *(_QWORD *)(v35 + 8) = 0;
        *(_DWORD *)(v35 + 24) = 0;
        *(_QWORD *)(v35 + 32) = v18;
        *(_QWORD *)(v35 + 40) = a7;
        *(_QWORD *)(v35 + 48) = a8;
        *(_QWORD *)(v35 + 56) = v17;
        *(_QWORD *)(v35 + 64) = v16 + 32;
        *(_QWORD *)(v35 + 72) = 0;
        *(_QWORD *)(v35 + 80) = 0;
        *(_DWORD *)(v35 + 88) = 0;
        if (a2 >= 1)
        {
          v43 = a1 + a2;
          while (1)
          {
            (*(void (**)(unint64_t *__return_ptr, uint64_t, uint64_t, unint64_t))(*(_QWORD *)v30 + 16))(&v49, v30, a1, v43);
            a1 = v49;
            if ((v50 & 1) != 0)
            {
              if (v49)
                goto LABEL_70;
            }
            if (v49 >= v43)
              goto LABEL_68;
          }
        }
        goto LABEL_68;
      }
    }
    else
    {
      if (a5 != 8 || a6)
      {
        result = operator new();
        *(_QWORD *)result = &off_1E8169028;
        v38 = 5;
        goto LABEL_32;
      }
      v37 = *(_DWORD *)(a1 + 12);
      v27 = bswap32(v37);
      if (v27 < 6)
      {
        v45 = v26;
        if (v37)
        {
          llvm::readPGOFuncNameStrings(*(char **)(v16 + 56), *(_QWORD *)(v16 + 64), v16 + 56, (uint64_t *)&v49);
          result = v49;
          if (v49)
            goto LABEL_72;
          switch(v27)
          {
            case 1:
              v41 = operator new();
              v30 = v41;
              *(_QWORD *)(v41 + 16) = 0;
              v42 = &off_1E8169478;
              break;
            case 2:
              v41 = operator new();
              v30 = v41;
              *(_QWORD *)(v41 + 16) = 0;
              v42 = &off_1E81694A8;
              break;
            case 3:
              v41 = operator new();
              v30 = v41;
              *(_QWORD *)(v41 + 16) = 0;
              v42 = &off_1E81694D8;
              break;
            case 4:
              v41 = operator new();
              v30 = v41;
              *(_QWORD *)(v41 + 16) = 0;
              v42 = &off_1E8169508;
              break;
            default:
              v41 = operator new();
              v30 = v41;
              *(_QWORD *)(v41 + 16) = 0;
              v42 = &off_1E8169538;
              break;
          }
        }
        else
        {
          v41 = operator new();
          v30 = v41;
          *(_QWORD *)(v41 + 16) = 0;
          v42 = &off_1E8169448;
        }
        *(_QWORD *)v41 = v42;
        *(_QWORD *)(v41 + 8) = 0;
        *(_DWORD *)(v41 + 24) = 0;
        *(_QWORD *)(v41 + 32) = v18;
        *(_QWORD *)(v41 + 40) = a7;
        *(_QWORD *)(v41 + 48) = a8;
        *(_QWORD *)(v41 + 56) = v17;
        *(_QWORD *)(v41 + 64) = v16 + 32;
        *(_QWORD *)(v41 + 72) = 0;
        *(_QWORD *)(v41 + 80) = 0;
        *(_DWORD *)(v41 + 88) = 0;
        if (a2 >= 1)
        {
          v44 = a1 + a2;
          while (1)
          {
            (*(void (**)(unint64_t *__return_ptr, uint64_t, uint64_t, unint64_t))(*(_QWORD *)v30 + 16))(&v49, v30, a1, v44);
            a1 = v49;
            if ((v50 & 1) != 0)
            {
              if (v49)
                goto LABEL_70;
            }
            if (v49 >= v44)
              goto LABEL_68;
          }
        }
        goto LABEL_68;
      }
    }
LABEL_31:
    result = operator new();
    *(_QWORD *)result = &off_1E8169028;
    v38 = 3;
LABEL_32:
    *(_DWORD *)(result + 8) = v38;
    goto LABEL_72;
  }
  v32 = *(_DWORD *)(a1 + 12);
  v27 = bswap32(v32);
  if (v27 >= 6)
    goto LABEL_31;
  v45 = v26;
  if (v32)
  {
    llvm::readPGOFuncNameStrings(*(char **)(v16 + 56), *(_QWORD *)(v16 + 64), v16 + 56, (uint64_t *)&v49);
    result = v49;
    if (v49)
      goto LABEL_72;
    switch(v27)
    {
      case 1:
        v33 = operator new();
        v30 = v33;
        *(_QWORD *)(v33 + 16) = 0;
        v34 = &off_1E8169238;
        break;
      case 2:
        v33 = operator new();
        v30 = v33;
        *(_QWORD *)(v33 + 16) = 0;
        v34 = &off_1E8169268;
        break;
      case 3:
        v33 = operator new();
        v30 = v33;
        *(_QWORD *)(v33 + 16) = 0;
        v34 = &off_1E8169298;
        break;
      case 4:
        v33 = operator new();
        v30 = v33;
        *(_QWORD *)(v33 + 16) = 0;
        v34 = &off_1E81692C8;
        break;
      default:
        v33 = operator new();
        v30 = v33;
        *(_QWORD *)(v33 + 16) = 0;
        v34 = &off_1E81692F8;
        break;
    }
  }
  else
  {
    v33 = operator new();
    v30 = v33;
    *(_QWORD *)(v33 + 16) = 0;
    v34 = &off_1E8169208;
  }
  *(_QWORD *)v33 = v34;
  *(_QWORD *)(v33 + 8) = 0;
  *(_DWORD *)(v33 + 24) = 0;
  *(_QWORD *)(v33 + 32) = v18;
  *(_QWORD *)(v33 + 40) = a7;
  *(_QWORD *)(v33 + 48) = a8;
  *(_QWORD *)(v33 + 56) = v17;
  *(_QWORD *)(v33 + 64) = v16 + 32;
  *(_QWORD *)(v33 + 72) = 0;
  *(_QWORD *)(v33 + 80) = 0;
  *(_DWORD *)(v33 + 88) = 0;
  if (a2 >= 1)
  {
    v40 = a1 + a2;
    do
    {
      (*(void (**)(unint64_t *__return_ptr, uint64_t, uint64_t, unint64_t))(*(_QWORD *)v30 + 16))(&v49, v30, a1, v40);
      a1 = v49;
      if ((v50 & 1) != 0)
      {
        if (v49)
          goto LABEL_70;
      }
    }
    while (v49 < v40);
  }
LABEL_68:
  v48 = 0;
  if (v27 >= 3)
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v30 + 24))(&v48, v30, v25, v25 + v45, 0, 0, 0, 0);
LABEL_71:
  (*(void (**)(uint64_t))(*(_QWORD *)v30 + 8))(v30);
  result = v48;
  if (!v48)
  {
    *(_BYTE *)(a9 + 8) &= ~1u;
    *(_QWORD *)a9 = v16;
    return result;
  }
LABEL_72:
  *(_BYTE *)(a9 + 8) |= 1u;
  *(_QWORD *)a9 = result;
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v16 + 8))(v16);
}

void llvm::coverage::BinaryCoverageReader::create(uint64_t a1@<X0>, void *a2@<X1>, void *a3@<X2>, _QWORD *a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v7;
  uint64_t v8;
  unint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  BOOL v16;
  __int128 v17;
  _DWORD *v18;
  int v19;
  int v20;
  _DWORD *v21;
  uint64_t v22;
  _DWORD *v23;
  int v24;
  uint64_t v25;
  int v26;
  int v27;
  unint64_t v28;
  unsigned int v29;
  _QWORD *v30;
  char *v31;
  char v32;
  uint64_t v33;
  _DWORD *v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unsigned int v38;
  char *v39;
  char *v40;
  char v41;
  uint64_t v42;
  int v43;
  unsigned int v44;
  int v45;
  unsigned int v46;
  int v47;
  _BYTE *v48;
  size_t v49;
  void *v50;
  void *v51;
  _BYTE *v52;
  size_t v53;
  void *v54;
  void *v55;
  void **v56;
  uint64_t v57;
  char *v58;
  void **v59;
  size_t v60;
  char *v61;
  _QWORD *v62;
  _DWORD *v63;
  unint64_t v65;
  _QWORD *v66;
  char *v67;
  char *v68;
  void *v69;
  char *v70;
  _QWORD *v71;
  void *v72;
  char *v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  char *v77;
  void *v78;
  uint64_t v79;
  char *v80;
  uint64_t v81;
  uint64_t v82;
  void (*v83)(void);
  void *v84;
  int v85;
  __int128 v86;
  __int128 i;
  int v88;
  void *v89;
  void *v90;
  _BOOL4 v91;
  _BYTE *v92;
  uint64_t v93;
  uint64_t v94;
  char v95;
  _BYTE *v96;
  void *v97;
  void *v98;
  int v99;
  void *v100;
  __int128 v101;
  void *v102;
  char *v103;
  void *v104;
  void *v105;
  uint64_t v106;
  uint64_t v107;
  char *v108;
  _DWORD *v109;
  unint64_t v110;
  BOOL v111;
  unint64_t v112;
  unint64_t v113;
  char *v114;
  unint64_t v115;
  unint64_t v116;
  uint64_t v117;
  char v118;
  uint64_t *v119;
  uint64_t *v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  char *v124;
  uint64_t v125;
  unint64_t v126;
  uint64_t v127;
  unint64_t v128;
  char *v129;
  char *v130;
  uint64_t v131;
  char *v132;
  uint64_t v133;
  char *v134;
  uint64_t v135;
  uint64_t v136;
  char v137;
  char v138;
  void *v139;
  uint64_t *v140;
  __int128 v141;
  uint64_t *v142;
  unsigned int v143;
  uint64_t *v144;
  unint64_t v145;
  uint64_t *v146;
  uint64_t v147;
  uint64_t v148;
  unint64_t v149;
  unint64_t v150;
  uint64_t v152;
  _QWORD *v153;
  char *v154;
  size_t v155;
  _QWORD *v156;
  char *v157;
  char *v158;
  unint64_t v159;
  size_t v160;
  void **v161;
  char *v162;
  uint64_t v163;
  void *v164;
  void *v165;
  uint64_t v166;
  uint64_t v167;
  _DWORD *v168;
  unint64_t v171;
  char *v172;
  uint64_t v173;
  char *v174;
  _DWORD *v175;
  int v176;
  char v177;
  _QWORD *v178;
  void *v179;
  unint64_t v180;
  char *v181;
  _DWORD *v182;
  char v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t *v186;
  uint64_t v187;
  uint64_t v188;
  _QWORD *v189;
  int __s1;
  void *__s1a;
  int __s1b;
  void *__s1c;
  _OWORD v194[2];
  _OWORD v195[2];
  _OWORD v196[2];
  char *v197;
  char *v198;
  char *v199;
  void **v200;
  char *v201;
  uint64_t v202;
  uint64_t v203;
  void **v204;
  uint64_t v205;
  uint64_t v206;
  void **v207;
  __int128 v208;
  __int128 v209;
  char v210;
  _DWORD *v211;
  char v212;
  void *v213[2];
  __int128 v214;
  __int128 v215;
  __int128 v216;
  void *__p[2];
  __int128 v218;
  __int128 v219;
  __int128 v220;
  void *v221;
  _QWORD *v222;
  char v223;
  _BYTE v224[48];
  _BYTE v225[24];
  __int128 v226;
  __int128 v227;
  _BYTE v228[25];
  uint64_t v229;

  v7 = a6;
  v8 = a5;
  v229 = *MEMORY[0x1E0C80C00];
  v197 = 0;
  v198 = 0;
  v199 = 0;
  v13 = *(_QWORD *)(a1 + 8);
  v14 = v13 - 16;
  if (v13 >= 0x10)
  {
    v15 = *(_QWORD **)a1;
    v16 = **(_QWORD **)a1 == 0x6D766F636D766C6CLL && *(_QWORD *)(*(_QWORD *)a1 + 8) == 0x6174616474736574;
    if (v16)
    {
      if (v13 < 0x11)
      {
LABEL_16:
        v22 = operator new();
        v23 = (_DWORD *)v22;
        *(_QWORD *)v22 = &off_1E8169028;
        v24 = 4;
LABEL_34:
        *(_DWORD *)(v22 + 8) = v24;
LABEL_35:
        *(_BYTE *)(a7 + 24) |= 1u;
        *(_QWORD *)a7 = v23;
        goto LABEL_300;
      }
      v28 = 0;
      v29 = 0;
      v30 = v15 + 2;
      v31 = (char *)(v15 + 2);
      while (1)
      {
        v32 = *v31;
        v33 = *v31 & 0x7F;
        if (v29 >= 0x40 && (*v31 & 0x7F) != 0)
          break;
        if ((unint64_t)(v33 << v29) >> v29 != v33)
          break;
        v28 += v33 << v29;
        v29 += 7;
        ++v31;
        if ((v32 & 0x80) == 0)
          goto LABEL_32;
      }
      v28 = 0;
LABEL_32:
      v35 = ((_DWORD)v31 - (_DWORD)v30);
      v36 = v14 - v35;
      if (v14 < v35)
        goto LABEL_33;
      if (v14 == v35)
        goto LABEL_16;
      v37 = 0;
      v38 = 0;
      v39 = (char *)v30 + v35;
      v40 = v39;
      while (1)
      {
        v41 = *v40;
        v42 = *v40 & 0x7F;
        if (v38 >= 0x40 && (*v40 & 0x7F) != 0)
          break;
        if ((unint64_t)(v42 << v38) >> v38 != v42)
          break;
        v37 += v42 << v38;
        v38 += 7;
        ++v40;
        if ((v41 & 0x80) == 0)
          goto LABEL_184;
      }
      v37 = 0;
LABEL_184:
      v110 = ((_DWORD)v40 - (_DWORD)v39);
      v111 = v36 >= v110;
      v112 = v36 - v110;
      if (!v111 || (v111 = v112 >= v28, v113 = v112 - v28, !v111))
      {
LABEL_33:
        v22 = operator new();
        v23 = (_DWORD *)v22;
        *(_QWORD *)v22 = &off_1E8169028;
        v24 = 5;
        goto LABEL_34;
      }
      *(_QWORD *)&v224[32] = 0;
      *(_QWORD *)&v224[40] = 0x800000000;
      *(_OWORD *)&v225[8] = 0u;
      v226 = 0u;
      v227 = 0u;
      memset(v228, 0, sizeof(v228));
      *(_QWORD *)v224 = &v39[v110];
      *(_QWORD *)&v224[8] = v28;
      *(_OWORD *)&v224[16] = v37;
      v114 = &v39[v110 + v28];
      v115 = ((unint64_t)(v114 + 7) & 0xFFFFFFFFFFFFFFF8) - (_QWORD)v114;
      v116 = v113 - v115;
      if (v113 < v115 || v116 < 0x10)
      {
        v23 = (_DWORD *)operator new();
        *(_QWORD *)v23 = &off_1E8169028;
        v23[2] = 5;
        sub_1C624BA64(v224);
        goto LABEL_35;
      }
      v171 = (unint64_t)(v114 + 7) & 0xFFFFFFFFFFFFFFF8;
      if (*(int *)(v171 + 12) <= 2)
      {
        LOWORD(v219) = 261;
        __p[0] = "";
        __p[1] = 0;
        *(_QWORD *)&v208 = __p;
        v172 = sub_1C5E1F380(24, (const void ****)&v208);
        *(_QWORD *)v172 = &off_1E81A17B0;
        *((_QWORD *)v172 + 1) = "";
        *((_QWORD *)v172 + 2) = "";
        __p[0] = v172;
        v173 = v116;
        goto LABEL_303;
      }
      if (v116 >= (*(_DWORD *)(v171 + 4) + 16))
        v173 = (*(_DWORD *)(v171 + 4) + 16);
      else
        v173 = v113 - v115;
      if (v173)
      {
        if (v116 - v173 >= ((v171 + v173 + 7) & 0xFFFFFFFFFFFFFFF8) - (v171 + v173))
        {
          v180 = (v171 + v173 + 7) & 0xFFFFFFFFFFFFFFF8;
          LOWORD(v219) = 261;
          __p[0] = "";
          __p[1] = 0;
          *(_QWORD *)&v208 = __p;
          v181 = sub_1C5E1F380(24, (const void ****)&v208);
          *(_QWORD *)v181 = &off_1E81A17B0;
          *((_QWORD *)v181 + 1) = v180;
          *((_QWORD *)v181 + 2) = (char *)v15 + v13;
          __p[0] = v181;
          if ((_QWORD *)((char *)v15 + v13) == (_QWORD *)v180)
          {
            v174 = v181;
            v182 = (_DWORD *)operator new();
            *(_QWORD *)v182 = &off_1E8169028;
            v182[2] = 4;
            LOBYTE(v213[1]) = -1;
            v213[0] = v182;
            goto LABEL_304;
          }
LABEL_303:
          llvm::coverage::BinaryCoverageReader::createCoverageReaderFromBuffer(v171, v173, (uint64_t *)__p, (uint64_t)v224, 8, 1, a5, a6, (uint64_t)v213);
          v174 = (char *)__p[0];
          if (!__p[0])
          {
LABEL_313:
            v177 = (char)v213[1];
            sub_1C624BA64(v224);
            if ((v177 & 1) == 0)
            {
              v178 = operator new(8uLL);
              v179 = v213[0];
              *(_QWORD *)a7 = v178;
              *v178++ = v179;
              *(_BYTE *)(a7 + 24) &= ~1u;
              *(_QWORD *)(a7 + 8) = v178;
              *(_QWORD *)(a7 + 16) = v178;
              v198 = 0;
              v199 = 0;
              v197 = 0;
              goto LABEL_300;
            }
            v23 = v213[0];
            goto LABEL_35;
          }
LABEL_304:
          (*(void (**)(char *))(*(_QWORD *)v174 + 8))(v174);
          goto LABEL_313;
        }
        v175 = (_DWORD *)operator new();
        *(_QWORD *)v175 = &off_1E8169028;
        v176 = 5;
      }
      else
      {
        v175 = (_DWORD *)operator new();
        *(_QWORD *)v175 = &off_1E8169028;
        v176 = 4;
      }
      v175[2] = v176;
      LOBYTE(v213[1]) = -1;
      v213[0] = v175;
      goto LABEL_313;
    }
  }
  v17 = *(_OWORD *)(a1 + 16);
  v196[0] = *(_OWORD *)a1;
  v196[1] = v17;
  llvm::object::createBinary((uint64_t)v196);
  v18 = v211;
  v211 = 0;
  if ((v212 & 1) != 0)
  {
    *(_BYTE *)(a7 + 24) |= 1u;
    *(_QWORD *)a7 = v18;
    goto LABEL_298;
  }
  v19 = v18[2];
  if (v18 && v19 == 1)
  {
    v188 = v7;
    __s1a = a2;
    llvm::object::MachOUniversalBinary::ObjectForArch::ObjectForArch((uint64_t)__p, (uint64_t)v18, 0);
    llvm::object::MachOUniversalBinary::ObjectForArch::ObjectForArch((uint64_t)v224, 0, 0);
    v84 = *(void **)v224;
    v85 = *(_DWORD *)&v224[8];
    *(_OWORD *)v213 = *(_OWORD *)__p;
    v214 = v218;
    v86 = v219;
    for (i = v220; ; i = *(_OWORD *)v225)
    {
      v215 = v86;
      v216 = i;
      if (v213[0] == v84 && LODWORD(v213[1]) == v85)
      {
        v117 = operator new();
        *(_QWORD *)v117 = &off_1E8169028;
        *(_DWORD *)(v117 + 8) = 7;
        *(_BYTE *)(a7 + 24) |= 1u;
        *(_QWORD *)a7 = v117;
        goto LABEL_296;
      }
      sub_1C546AF68((unsigned int *)v213, v224);
      v88 = v224[23];
      v89 = *(void **)v224;
      v90 = (void *)(v224[23] & 0x7F);
      if (v224[23] < 0)
        v90 = *(void **)&v224[8];
      v91 = a3 == v90;
      if (a3 && a3 == v90)
      {
        if (v224[23] >= 0)
          v92 = v224;
        else
          v92 = *(_BYTE **)v224;
        v91 = memcmp(__s1a, v92, (size_t)a3) == 0;
      }
      if (v88 < 0)
        operator delete(v89);
      if (v91)
        break;
      llvm::object::MachOUniversalBinary::ObjectForArch::ObjectForArch((uint64_t)v224, (uint64_t)v213[0], LODWORD(v213[1]) + 1);
      *(_OWORD *)v213 = *(_OWORD *)v224;
      v214 = *(_OWORD *)&v224[16];
      v86 = *(_OWORD *)&v224[32];
    }
    v19 = v18[2];
    v7 = v188;
    a2 = __s1a;
  }
  if (v19 != 1)
    goto LABEL_10;
  llvm::object::MachOUniversalBinary::ObjectForArch::ObjectForArch((uint64_t)__p, (uint64_t)v18, 0);
  llvm::object::MachOUniversalBinary::ObjectForArch::ObjectForArch((uint64_t)v224, 0, 0);
  v93 = *(_QWORD *)v224;
  __s1b = *(_DWORD *)&v224[8];
  *(_OWORD *)v213 = *(_OWORD *)__p;
  v214 = v218;
  v215 = v219;
  v216 = v220;
  if (__p[0] != *(void **)v224)
    goto LABEL_147;
LABEL_146:
  if (LODWORD(v213[1]) == __s1b)
    goto LABEL_10;
  while (1)
  {
LABEL_147:
    v94 = v7;
    sub_1C546AF68((unsigned int *)v213, v224);
    v95 = v224[23];
    if (v224[23] >= 0)
      v96 = v224;
    else
      v96 = *(_BYTE **)v224;
    v97 = (void *)(v224[23] & 0x7F);
    if (v224[23] < 0)
      v97 = *(void **)&v224[8];
    if (a3 != v97 || a3 && memcmp(a2, v96, (size_t)a3))
    {
      v98 = a2;
      v99 = 3;
      if ((v95 & 0x80) == 0)
        goto LABEL_157;
LABEL_156:
      operator delete(*(void **)v224);
      goto LABEL_157;
    }
    llvm::object::MachOUniversalBinary::ObjectForArch::getAsArchive((llvm::object::MachOUniversalBinary::ObjectForArch *)v213, (uint64_t)__p);
    v100 = __p[0];
    if (((uint64_t)__p[1] & 1) != 0)
    {
      v98 = a2;
      __p[0] = 0;
      v221 = v100;
      sub_1C4D62BD4((char **)&v221, (char **)&v208);
      if (v221)
        (*(void (**)(void *))(*(_QWORD *)v221 + 8))(v221);
      v99 = 2;
    }
    else
    {
      v101 = *((_OWORD *)__p[0] + 2);
      v195[0] = *((_OWORD *)__p[0] + 1);
      v195[1] = v101;
      v98 = a2;
      llvm::coverage::BinaryCoverageReader::create(v195, a2, a3, a4, v8, v94);
      v99 = 1;
    }
    v102 = __p[0];
    __p[0] = 0;
    if (v102)
      (*(void (**)(void *))(*(_QWORD *)v102 + 8))(v102);
    if ((v224[23] & 0x80) != 0)
      goto LABEL_156;
LABEL_157:
    if (v99 != 3)
      break;
    llvm::object::MachOUniversalBinary::ObjectForArch::ObjectForArch((uint64_t)v224, (uint64_t)v213[0], LODWORD(v213[1]) + 1);
    *(_OWORD *)v213 = *(_OWORD *)v224;
    v214 = *(_OWORD *)&v224[16];
    v215 = *(_OWORD *)&v224[32];
    v216 = *(_OWORD *)v225;
    v7 = v94;
    a2 = v98;
    if (*(_QWORD *)v224 == v93)
      goto LABEL_146;
  }
  v16 = v99 == 2;
  v7 = v94;
  a2 = v98;
  if (!v16)
    goto LABEL_296;
LABEL_10:
  v20 = v18[2];
  if (v20)
  {
    if (v20 == 1)
    {
      llvm::object::MachOUniversalBinary::getMachOObjectForArch((uint64_t)v18, a2, (size_t)a3, (uint64_t)v224);
      if ((v224[8] & 1) == 0)
      {
        v21 = v18;
        v18 = *(_DWORD **)v224;
        goto LABEL_44;
      }
      LOBYTE(__p[1]) = -1;
      __p[0] = *(void **)v224;
LABEL_105:
      (*(void (**)(_DWORD *))(*(_QWORD *)v18 + 8))(v18);
LABEL_106:
      if (((uint64_t)__p[1] & 1) != 0)
      {
        v72 = __p[0];
        *(_BYTE *)(a7 + 24) |= 1u;
        *(_QWORD *)a7 = v72;
      }
      else
      {
        v67 = v198;
        v68 = v199;
        if (v198 >= v199)
        {
          v73 = v197;
          v74 = (v198 - v197) >> 3;
          v75 = v74 + 1;
          if ((unint64_t)(v74 + 1) >> 61)
LABEL_318:
            abort();
          if ((v199 - v197) >> 2 > v75)
            v75 = (v199 - v197) >> 2;
          if ((unint64_t)(v199 - v197) >= 0x7FFFFFFFFFFFFFF8)
            v76 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v76 = v75;
          if (v76)
          {
            if (v76 >> 61)
LABEL_319:
              sub_1C4764EE4();
            v77 = (char *)operator new(8 * v76);
          }
          else
          {
            v77 = 0;
          }
          v70 = &v77[8 * v74];
          v68 = &v77[8 * v76];
          v78 = __p[0];
          __p[0] = 0;
          *(_QWORD *)v70 = v78;
          v71 = v70 + 8;
          if (v67 != v73)
          {
            do
            {
              v79 = *((_QWORD *)v67 - 1);
              v67 -= 8;
              *(_QWORD *)v67 = 0;
              *((_QWORD *)v70 - 1) = v79;
              v70 -= 8;
            }
            while (v67 != v73);
            v67 = v197;
            v80 = v198;
            while (v80 != v67)
            {
              v82 = *((_QWORD *)v80 - 1);
              v80 -= 8;
              v81 = v82;
              *(_QWORD *)v80 = 0;
              if (v82)
                (*(void (**)(uint64_t))(*(_QWORD *)v81 + 8))(v81);
            }
          }
          if (v67)
            operator delete(v67);
        }
        else
        {
          v69 = __p[0];
          __p[0] = 0;
          *(_QWORD *)v198 = v69;
          v70 = v197;
          v71 = v67 + 8;
        }
        *(_BYTE *)(a7 + 24) &= ~1u;
        *(_QWORD *)a7 = v70;
        *(_QWORD *)(a7 + 8) = v71;
        *(_QWORD *)(a7 + 16) = v68;
        v198 = 0;
        v199 = 0;
        v197 = 0;
        if (__p[0])
        {
          v83 = *(void (**)(void))(*(_QWORD *)__p[0] + 8);
          goto LABEL_297;
        }
      }
      goto LABEL_298;
    }
    if ((v20 - 9) > 0xE)
    {
      v34 = (_DWORD *)operator new();
      *(_QWORD *)v34 = &off_1E8169028;
      v34[2] = 5;
      LOBYTE(__p[1]) = -1;
      __p[0] = v34;
      goto LABEL_105;
    }
    if (a3)
    {
      v25 = v8;
      v26 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v18 + 376))(v18);
      LOWORD(v219) = 261;
      __p[0] = a2;
      __p[1] = a3;
      llvm::Triple::Triple((uint64_t)v224, (llvm::Twine *)__p);
      v27 = *(_DWORD *)&v224[24];
      if ((v224[23] & 0x80000000) != 0)
        operator delete(*(void **)v224);
      if (v26 == v27)
      {
        v21 = 0;
        v8 = v25;
        goto LABEL_44;
      }
      if (!atomic_load(qword_1EF8F7238))
        llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EF8F7238, (void *(*)(void))sub_1C59D0934, (void (*)(void *))sub_1C59D0968);
      v65 = qword_1EF8F7238[0];
      v66 = (_QWORD *)operator new();
      v21 = 0;
      *v66 = &off_1E81A0D28;
      v66[1] = 1;
      v66[2] = v65;
      LOBYTE(__p[1]) = -1;
      __p[0] = v66;
LABEL_104:
      (*(void (**)(_DWORD *))(*(_QWORD *)v18 + 8))(v18);
      v18 = v21;
      if (v21)
        goto LABEL_105;
      goto LABEL_106;
    }
    v21 = 0;
LABEL_44:
    v43 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v18 + 360))(v18);
    v44 = v18[2];
    if (v44 <= 0x13)
    {
      v45 = 1;
      if (((1 << v44) & 0xAAC00) != 0)
      {
        v45 = 0;
LABEL_47:
        v46 = v44 & 0xFFFFFFFC;
        if (v46 == 16)
        {
          v47 = 5;
        }
        else if (v46 == 12)
        {
          v47 = 3;
        }
        else
        {
          v47 = 0;
        }
LABEL_53:
        llvm::getInstrProfSectionName(2u, v47, 0, (std::string *)v224);
        if (v224[23] >= 0)
          v48 = v224;
        else
          v48 = *(_BYTE **)v224;
        if (v224[23] >= 0)
          v49 = v224[23] & 0x7F;
        else
          v49 = *(_QWORD *)&v224[8];
        sub_1C546B334((uint64_t)v213, v18, v48, v49);
        if ((v224[23] & 0x80000000) != 0)
          operator delete(*(void **)v224);
        if ((BYTE8(v214) & 1) != 0)
        {
          v50 = v213[0];
          v213[0] = 0;
          if (v50)
          {
            v51 = 0;
            LOBYTE(__p[1]) = -1;
            __p[0] = v50;
            if ((BYTE8(v214) & 1) != 0)
              goto LABEL_64;
            goto LABEL_99;
          }
        }
        llvm::getInstrProfSectionName(5u, v47, 0, (std::string *)v224);
        if (v224[23] >= 0)
          v52 = v224;
        else
          v52 = *(_BYTE **)v224;
        if (v224[23] >= 0)
          v53 = v224[23] & 0x7F;
        else
          v53 = *(_QWORD *)&v224[8];
        sub_1C546B334((uint64_t)&v208, v18, v52, v53);
        if ((v224[23] & 0x80000000) != 0)
          operator delete(*(void **)v224);
        v54 = (void *)v208;
        if ((BYTE8(v209) & 1) != 0)
        {
          *(_QWORD *)&v208 = 0;
          if (v54)
          {
            v55 = 0;
            LOBYTE(__p[1]) = -1;
            __p[0] = v54;
            if ((BYTE8(v209) & 1) != 0)
            {
LABEL_77:
              if (v55)
                (*(void (**)(void *))(*(_QWORD *)v55 + 8))(v55);
              goto LABEL_98;
            }
LABEL_96:
            if (v55)
              operator delete(v55);
LABEL_98:
            v51 = v213[0];
            if ((BYTE8(v214) & 1) != 0)
            {
LABEL_64:
              if (v51)
                (*(void (**)(void *))(*(_QWORD *)v51 + 8))(v51);
              goto LABEL_104;
            }
LABEL_99:
            if (v51)
              operator delete(v51);
            goto LABEL_104;
          }
        }
        __s1 = v43;
        v204 = 0;
        v205 = 0;
        v206 = 0;
        sub_1C4EEC644(&v204, v54, *((uint64_t *)&v208 + 1), (uint64_t)(*((_QWORD *)&v208 + 1) - (_QWORD)v54) >> 4);
        v56 = v204;
        if (v205 - (_QWORD)v204 == 16)
        {
          (*(void (**)(_BYTE *__return_ptr, _QWORD, _QWORD))(**(_QWORD **)(v205 - 8) + 168))(v224, *(_QWORD *)(v205 - 8), *(_QWORD *)(v205 - 16));
          v187 = *(_QWORD *)v224;
          if ((v224[16] & 1) != 0)
          {
            LOBYTE(__p[1]) = -1;
            __p[0] = *(void **)v224;
            if (!v56)
              goto LABEL_95;
          }
          else
          {
            v57 = *(_QWORD *)&v224[8];
            memset(v224, 0, 44);
            *(_DWORD *)&v224[44] = 8;
            *(_OWORD *)&v225[8] = 0u;
            v226 = 0u;
            v227 = 0u;
            memset(v228, 0, sizeof(v228));
            v201 = 0;
            v202 = 0;
            v203 = 0;
            sub_1C4EEC644(&v201, v213[0], (uint64_t)v213[1], ((char *)v213[1] - (char *)v213[0]) >> 4);
            v58 = v201;
            if (v202 - (_QWORD)v201 == 16)
            {
              llvm::InstrProfSymtab::create((uint64_t *)v224, (_QWORD *)(v202 - 16), &v221);
              if (v221)
              {
                LOBYTE(__p[1]) = -1;
                __p[0] = v221;
              }
              else
              {
                llvm::getInstrProfSectionName(6u, v47, 0, (std::string *)__p);
                if ((SBYTE7(v218) & 0x80u) == 0)
                  v59 = __p;
                else
                  v59 = (void **)__p[0];
                if ((SBYTE7(v218) & 0x80u) == 0)
                  v60 = BYTE7(v218) & 0x7F;
                else
                  v60 = (size_t)__p[1];
                sub_1C546B334((uint64_t)&v221, v18, v59, v60);
                if (SBYTE7(v218) < 0)
                  operator delete(__p[0]);
                v184 = v8;
                v185 = v57;
                v200 = 0;
                v61 = (char *)v221;
                if ((v223 & 1) == 0)
                {
                  v62 = v221;
                  goto LABEL_253;
                }
                v62 = 0;
                v221 = 0;
                if (v61)
                {
                  v207 = (void **)v61;
                  sub_1C4D62BD4((char **)&v207, (char **)__p);
                  if (v207)
                    (*((void (**)(void **))*v207 + 1))(v207);
                  LOWORD(v219) = 261;
                  __p[0] = "";
                  __p[1] = 0;
                  v207 = __p;
                  v162 = sub_1C5E1F380(24, (const void ****)&v207);
                  *(_QWORD *)v162 = &off_1E81A17B0;
                  *((_QWORD *)v162 + 1) = "";
                  *((_QWORD *)v162 + 2) = "";
                  v200 = (void **)v162;
LABEL_272:
                  llvm::coverage::BinaryCoverageReader::createCoverageReaderFromBuffer(v187, v185, (uint64_t *)&v200, (uint64_t)v224, __s1, v45, v184, v7, (uint64_t)__p);
                }
                else
                {
LABEL_253:
                  v153 = v222;
                  if (v62 == v222)
                  {
                    LOWORD(v219) = 257;
                    llvm::WritableMemoryBuffer::getNewUninitMemBuffer(0, (uint64_t)__p, &v207);
                    v200 = v207;
                    goto LABEL_272;
                  }
                  v155 = 0;
                  v156 = v62;
                  do
                  {
                    (*(void (**)(void **__return_ptr, _QWORD, _QWORD))(*(_QWORD *)v156[1] + 168))(__p, v156[1], *v156);
                    if ((v218 & 1) != 0)
                    {
                      LOBYTE(__p[1]) = -1;
                      goto LABEL_273;
                    }
                    v155 += ((unint64_t)__p[1] + 7) & 0xFFFFFFFFFFFFFFF8;
                    v156 += 2;
                  }
                  while (v156 != v153);
                  LOWORD(v219) = 257;
                  llvm::WritableMemoryBuffer::getNewUninitMemBuffer(v155, (uint64_t)__p, &v207);
                  v157 = (char *)v207[1];
                  while (1)
                  {
                    (*(void (**)(void **__return_ptr, _QWORD, _QWORD))(*(_QWORD *)v62[1] + 168))(__p, v62[1], *v62);
                    if ((v218 & 1) != 0)
                      break;
                    v158 = (char *)__p[1];
                    if (__p[1])
                      memmove(v157, __p[0], (size_t)__p[1]);
                    v157 = &v158[(_QWORD)v157];
                    v159 = (unint64_t)(v157 + 7) & 0xFFFFFFFFFFFFFFF8;
                    v160 = v159 - (_QWORD)v157;
                    if ((char *)v159 != v157)
                    {
                      bzero(v157, v160);
                      v157 = (char *)((unint64_t)(v157 + 7) & 0xFFFFFFFFFFFFFFF8);
                    }
                    v62 += 2;
                    if (v62 == v153)
                    {
                      v161 = v200;
                      v200 = v207;
                      if (v161)
                        (*((void (**)(void **, size_t))*v161 + 1))(v161, v160);
                      goto LABEL_272;
                    }
                  }
                  LOBYTE(__p[1]) |= 1u;
                  if (v207)
                    (*((void (**)(void **, void *))*v207 + 1))(v207, __p[0]);
                }
LABEL_273:
                if (v200)
                  (*((void (**)(void **))*v200 + 1))(v200);
                if ((v223 & 1) != 0)
                {
                  if (v221)
                    (*(void (**)(void))(*(_QWORD *)v221 + 8))();
                }
                else if (v221)
                {
                  operator delete(v221);
                }
                v58 = v201;
              }
            }
            else
            {
              v109 = (_DWORD *)operator new();
              *(_QWORD *)v109 = &off_1E8169028;
              v109[2] = 5;
              LOBYTE(__p[1]) = -1;
              __p[0] = v109;
            }
            if (v58)
              operator delete(v58);
            sub_1C624BA64(v224);
            v56 = v204;
            if (!v204)
            {
LABEL_95:
              v55 = (void *)v208;
              if ((BYTE8(v209) & 1) != 0)
                goto LABEL_77;
              goto LABEL_96;
            }
          }
        }
        else
        {
          v63 = (_DWORD *)operator new();
          *(_QWORD *)v63 = &off_1E8169028;
          v63[2] = 5;
          LOBYTE(__p[1]) = -1;
          __p[0] = v63;
          if (!v56)
            goto LABEL_95;
        }
        operator delete(v56);
        goto LABEL_95;
      }
      v47 = 1;
      if (v44 == 9)
        goto LABEL_53;
    }
    v45 = 1;
    goto LABEL_47;
  }
  v201 = 0;
  __s1c = a2;
  sub_1C624B904((uint64_t)v18, &v201, 1, (uint64_t)v224);
  sub_1C624BC78((uint64_t)__p, (uint64_t)v224);
  *((_QWORD *)&v219 + 1) = *(_QWORD *)&v224[40];
  sub_1C624BC78((uint64_t)v213, (uint64_t)v225);
  *((_QWORD *)&v215 + 1) = v227;
  v189 = a4;
  if (*((_QWORD *)&v219 + 1) > 7uLL || (v103 = 0, (unint64_t)v227 >= 8))
  {
    v103 = 0;
    while ((_QWORD)v218 != (_QWORD)v214)
    {
      llvm::object::Archive::Child::getMemoryBufferRef((llvm::object::Archive::Child *)__p, (uint64_t)&v208);
      if ((v210 & 1) != 0)
      {
        v163 = v208;
        *(_BYTE *)(a7 + 24) |= 1u;
        *(_QWORD *)a7 = v163;
LABEL_286:
        v164 = v213[1];
        v213[1] = 0;
        if (v164)
          (*(void (**)(void *))(*(_QWORD *)v164 + 16))(v164);
        v165 = __p[1];
        __p[1] = 0;
        if (v165)
          (*(void (**)(void *))(*(_QWORD *)v165 + 16))(v165);
        v166 = *(_QWORD *)&v225[8];
        *(_QWORD *)&v225[8] = 0;
        if (v166)
          (*(void (**)(uint64_t))(*(_QWORD *)v166 + 16))(v166);
        v167 = *(_QWORD *)&v224[8];
        *(_QWORD *)&v224[8] = 0;
        if (v167)
          (*(void (**)(uint64_t))(*(_QWORD *)v167 + 16))(v167);
        goto LABEL_294;
      }
      v194[0] = v208;
      v194[1] = v209;
      llvm::coverage::BinaryCoverageReader::create(v194, a2, a3, a4, v8, v7);
      v118 = v223;
      v119 = (uint64_t *)v221;
      if ((v223 & 1) != 0)
      {
        v221 = 0;
        *(_BYTE *)(a7 + 24) |= 1u;
        *(_QWORD *)a7 = v119;
        v137 = v118;
        v138 = v118;
      }
      else
      {
        v183 = v223;
        v120 = v222;
        if (v221 == v222)
        {
          v138 = v223;
          v137 = v223;
        }
        else
        {
          v186 = v222;
          do
          {
            if (v103 >= v199)
            {
              v122 = v8;
              v123 = v7;
              v124 = v197;
              v125 = (v103 - v197) >> 3;
              v126 = v125 + 1;
              if ((unint64_t)(v125 + 1) >> 61)
                goto LABEL_318;
              v127 = v199 - v197;
              if ((v199 - v197) >> 2 > v126)
                v126 = v127 >> 2;
              if ((unint64_t)v127 >= 0x7FFFFFFFFFFFFFF8)
                v128 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v128 = v126;
              if (v128)
              {
                if (v128 >> 61)
                  goto LABEL_319;
                v129 = (char *)operator new(8 * v128);
              }
              else
              {
                v129 = 0;
              }
              v130 = &v129[8 * v125];
              v131 = *v119;
              *v119 = 0;
              *(_QWORD *)v130 = v131;
              v132 = v130 + 8;
              if (v103 == v124)
              {
                v197 = v130;
                v198 = v130 + 8;
                v199 = &v129[8 * v128];
              }
              else
              {
                do
                {
                  v133 = *((_QWORD *)v103 - 1);
                  v103 -= 8;
                  *(_QWORD *)v103 = 0;
                  *((_QWORD *)v130 - 1) = v133;
                  v130 -= 8;
                }
                while (v103 != v124);
                v103 = v197;
                v134 = v198;
                v197 = v130;
                v198 = v132;
                v199 = &v129[8 * v128];
                while (v134 != v103)
                {
                  v136 = *((_QWORD *)v134 - 1);
                  v134 -= 8;
                  v135 = v136;
                  *(_QWORD *)v134 = 0;
                  if (v136)
                    (*(void (**)(uint64_t))(*(_QWORD *)v135 + 8))(v135);
                }
              }
              v7 = v123;
              if (v103)
                operator delete(v103);
              v103 = v132;
              v8 = v122;
              a4 = v189;
              a2 = __s1c;
              v120 = v186;
            }
            else
            {
              v121 = *v119;
              *v119 = 0;
              *(_QWORD *)v103 = v121;
              v103 += 8;
            }
            v198 = v103;
            ++v119;
          }
          while (v119 != v120);
          v137 = v223;
          v138 = v183;
        }
      }
      if ((v137 & 1) != 0)
      {
        v139 = v221;
        v221 = 0;
        if (v139)
          (*(void (**)(void *))(*(_QWORD *)v139 + 8))(v139);
      }
      else
      {
        v204 = &v221;
        sub_1C4764BBC(&v204);
      }
      if ((v210 & 1) != 0 && (_QWORD)v208)
        (*(void (**)(_QWORD))(*(_QWORD *)v208 + 8))(v208);
      if ((v138 & 1) != 0)
        goto LABEL_286;
      sub_1C624B980((uint64_t)__p);
      if (*((_QWORD *)&v219 + 1) <= 7uLL && *((_QWORD *)&v215 + 1) < 8uLL)
        break;
    }
  }
  v104 = v213[1];
  v213[1] = 0;
  if (v104)
    (*(void (**)(void *))(*(_QWORD *)v104 + 16))(v104);
  v105 = __p[1];
  __p[1] = 0;
  if (v105)
    (*(void (**)(void *))(*(_QWORD *)v105 + 16))(v105);
  v106 = *(_QWORD *)&v225[8];
  *(_QWORD *)&v225[8] = 0;
  if (v106)
    (*(void (**)(uint64_t))(*(_QWORD *)v106 + 16))(v106);
  v107 = *(_QWORD *)&v224[8];
  *(_QWORD *)&v224[8] = 0;
  if (v107)
    (*(void (**)(uint64_t))(*(_QWORD *)v107 + 16))(v107);
  v108 = v201;
  if (v201)
  {
    v201 = 0;
    *(_BYTE *)(a7 + 24) |= 1u;
    *(_QWORD *)a7 = v108;
  }
  else
  {
    if ((*((_BYTE *)v18 + 98) & 8) != 0)
    {
      *(_QWORD *)v224 = *((_QWORD *)v18 + 13);
      v140 = *(uint64_t **)v224;
      v141 = *((_OWORD *)v18 + 7);
      *(_OWORD *)&v224[8] = v141;
      v142 = (uint64_t *)v141;
      *((_QWORD *)v18 + 14) = 0;
      *((_QWORD *)v18 + 15) = 0;
      *((_QWORD *)v18 + 13) = 0;
      if (v140 != (uint64_t *)v141)
      {
        v143 = *((_DWORD *)a4 + 2);
        v144 = v140;
        do
        {
          v145 = *a4;
          v146 = v144;
          if (v143 >= *((_DWORD *)a4 + 3))
          {
            v149 = v143 + 1;
            v150 = v145 + 8 * v143;
            if (v145 <= (unint64_t)v144 && v150 > (unint64_t)v144)
            {
              v152 = (uint64_t)v140 - v145;
              sub_1C6189DFC((uint64_t)v189, v149);
              v145 = *v189;
              v146 = (uint64_t *)(*v189 + v152);
              a4 = v189;
            }
            else
            {
              a4 = v189;
              sub_1C6189DFC((uint64_t)v189, v149);
              v145 = *v189;
              v146 = v144;
            }
          }
          v147 = *((unsigned int *)a4 + 2);
          v148 = *v146;
          *v146 = 0;
          *(_QWORD *)(v145 + 8 * v147) = v148;
          v143 = v147 + 1;
          *((_DWORD *)a4 + 2) = v143;
          ++v144;
          ++v140;
        }
        while (v144 != v142);
      }
      __p[0] = v224;
      sub_1C4764BBC((void ***)__p);
    }
    *(_BYTE *)(a7 + 24) &= ~1u;
    v154 = v199;
    *(_QWORD *)a7 = v197;
    *(_QWORD *)(a7 + 8) = v103;
    *(_QWORD *)(a7 + 16) = v154;
    v198 = 0;
    v199 = 0;
    v197 = 0;
  }
LABEL_294:
  if (v201)
    (*(void (**)(char *))(*(_QWORD *)v201 + 8))(v201);
LABEL_296:
  v83 = *(void (**)(void))(*(_QWORD *)v18 + 8);
LABEL_297:
  v83();
LABEL_298:
  v168 = v211;
  v211 = 0;
  if (v168)
    (*(void (**)(_DWORD *))(*(_QWORD *)v168 + 8))(v168);
LABEL_300:
  *(_QWORD *)v224 = &v197;
  sub_1C4764BBC((void ***)v224);
}

void sub_1C546AF68(unsigned int *a1@<X0>, _QWORD *a2@<X8>)
{
  int v3;
  unsigned int *v4;
  uint64_t v5;
  BOOL v6;
  unsigned int *v7;
  char *v8;
  size_t v9;
  size_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  __int128 __p;
  char v15;
  char *__s;
  uint64_t v17;

  v3 = *(_DWORD *)(*(_QWORD *)a1 + 48) | 0x1000000;
  v4 = a1 + 3;
  if (v3 != -872498498)
    v4 = a1 + 8;
  v5 = *v4;
  v6 = v3 == -872498498;
  v7 = a1 + 4;
  if (!v6)
    v7 = a1 + 9;
  v17 = 0;
  __s = 0;
  llvm::object::MachOObjectFile::getArchTriple(v5, (const char **)&__s, *v7, &v17, &__p);
  if (v15 < 0)
    operator delete((void *)__p);
  v8 = __s;
  if (!__s)
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    return;
  }
  v9 = strlen(__s);
  if (v9 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v10 = v9;
  if (v9 >= 0x17)
  {
    v11 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v9 | 7) != 0x17)
      v11 = v9 | 7;
    v12 = v11 + 1;
    v13 = operator new(v11 + 1);
    a2[1] = v10;
    a2[2] = v12 | 0x8000000000000000;
    *a2 = v13;
    a2 = v13;
  }
  else
  {
    *((_BYTE *)a2 + 23) = v9;
    if (!v9)
      goto LABEL_17;
  }
  memmove(a2, v8, v10);
LABEL_17:
  *((_BYTE *)a2 + v10) = 0;
}

__n128 llvm::coverage::BinaryCoverageReader::readNextRecord@<Q0>(_QWORD *a1@<X0>, __n128 *a2@<X1>, char ***a3@<X8>)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __n128 result;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  __int128 v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD v23[2];

  v4 = a1[24];
  v5 = a1[4];
  if (v4 < (a1[5] - v5) >> 6)
  {
    a1[26] = a1[25];
    a1[29] = a1[28];
    a1[32] = a1[31];
    v10 = v5 + (v4 << 6);
    v11 = *(_QWORD *)(v10 + 56);
    v23[0] = a1[1] + 24 * *(_QWORD *)(v10 + 48);
    v23[1] = v11;
    v18 = *(_OWORD *)(v10 + 32);
    v19 = v23;
    v20 = a1 + 25;
    v21 = a1 + 28;
    v22 = a1 + 31;
    llvm::coverage::RawCoverageMappingReader::read((llvm::coverage::RawCoverageMappingReader *)&v18, a3);
    if (!*a3)
    {
      result = *(__n128 *)(v10 + 8);
      *a2 = result;
      a2[1].n128_u64[0] = *(_QWORD *)(v10 + 24);
      v12 = a1[25];
      v13 = (uint64_t)(a1[26] - v12) >> 4;
      a2[1].n128_u64[1] = v12;
      a2[2].n128_u64[0] = v13;
      v14 = a1[28];
      v15 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(a1[29] - v14) >> 2);
      a2[2].n128_u64[1] = v14;
      a2[3].n128_u64[0] = v15;
      v16 = a1[31];
      v17 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(a1[32] - v16) >> 2);
      a2[3].n128_u64[1] = v16;
      a2[4].n128_u64[0] = v17;
      ++a1[24];
      *a3 = 0;
    }
  }
  else
  {
    v6 = operator new();
    *(_QWORD *)v6 = &off_1E8169028;
    *(_DWORD *)(v6 + 8) = 1;
    *a3 = (char **)v6;
  }
  return result;
}

uint64_t sub_1C546B1D8(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void **v8;

  *(_QWORD *)a1 = off_1E81690C0;
  v2 = *(_QWORD *)(a1 + 272);
  *(_QWORD *)(a1 + 272) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *(void **)(a1 + 248);
  if (v3)
  {
    *(_QWORD *)(a1 + 256) = v3;
    operator delete(v3);
  }
  v4 = *(void **)(a1 + 224);
  if (v4)
  {
    *(_QWORD *)(a1 + 232) = v4;
    operator delete(v4);
  }
  v5 = *(void **)(a1 + 200);
  if (v5)
  {
    *(_QWORD *)(a1 + 208) = v5;
    operator delete(v5);
  }
  sub_1C624BA64((_QWORD *)(a1 + 56));
  v6 = *(void **)(a1 + 32);
  if (v6)
  {
    *(_QWORD *)(a1 + 40) = v6;
    operator delete(v6);
  }
  v8 = (void **)(a1 + 8);
  sub_1C4765410(&v8);
  return a1;
}

uint64_t sub_1C546B27C(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void **v8;

  *(_QWORD *)a1 = off_1E81690C0;
  v2 = *(_QWORD *)(a1 + 272);
  *(_QWORD *)(a1 + 272) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *(void **)(a1 + 248);
  if (v3)
  {
    *(_QWORD *)(a1 + 256) = v3;
    operator delete(v3);
  }
  v4 = *(void **)(a1 + 224);
  if (v4)
  {
    *(_QWORD *)(a1 + 232) = v4;
    operator delete(v4);
  }
  v5 = *(void **)(a1 + 200);
  if (v5)
  {
    *(_QWORD *)(a1 + 208) = v5;
    operator delete(v5);
  }
  sub_1C624BA64((_QWORD *)(a1 + 56));
  v6 = *(void **)(a1 + 32);
  if (v6)
  {
    *(_QWORD *)(a1 + 40) = v6;
    operator delete(v6);
  }
  v8 = (void **)(a1 + 8);
  sub_1C4765410(&v8);
  return MEMORY[0x1CAA32FC0](a1, 0x10F1C40330DA253);
}

void sub_1C546B334(uint64_t a1, _DWORD *a2, const void *a3, size_t a4)
{
  size_t v4;
  int v7;
  unint64_t v8;
  size_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  char *v19;
  char v20;
  unint64_t v21;
  const void *v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  char *v30;
  char *v31;
  char *v32;
  char *v33;
  uint64_t v34;
  char *v36;
  __int128 v37;
  uint64_t v38[2];
  char v39;
  const void *v40;
  uint64_t v41;
  char v42;
  uint64_t v43;

  v4 = a4;
  v43 = *MEMORY[0x1E0C80C00];
  v7 = a2[2];
  v40 = a3;
  v41 = a4;
  if (v7 == 9)
  {
    LOBYTE(v38[0]) = 36;
    v8 = llvm::StringRef::find((uint64_t *)&v40, (char *)v38, 1uLL, 0);
    v9 = v4 >= v8 ? v8 : v4;
    if (v8 != -1)
      v4 = v9;
  }
  v10 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)a2 + 344))(a2);
  v12 = v11;
  v13 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)a2 + 352))(a2);
  *(_QWORD *)&v37 = v10;
  *((_QWORD *)&v37 + 1) = v12;
  if (v12 == v14 && v10 == v13)
  {
    v19 = 0;
LABEL_50:
    v34 = operator new();
    *(_QWORD *)v34 = &off_1E8169028;
    *(_DWORD *)(v34 + 8) = 2;
    *(_BYTE *)(a1 + 24) |= 1u;
    *(_QWORD *)a1 = v34;
    v18 = v19;
  }
  else
  {
    v16 = v13;
    v17 = v14;
    v18 = 0;
    v19 = 0;
    v36 = 0;
    while (1)
    {
      (*(void (**)(const void **__return_ptr, uint64_t, uint64_t))(*(_QWORD *)v12 + 136))(&v40, v12, v10);
      v20 = v42;
      if ((v42 & 1) != 0)
      {
        v25 = (uint64_t)v40;
        v40 = 0;
        *(_BYTE *)(a1 + 24) |= 1u;
        *(_QWORD *)a1 = v25;
      }
      else
      {
        v22 = v40;
        v21 = v41;
        v38[0] = (uint64_t)v40;
        v38[1] = v41;
        if (v7 == 9)
        {
          v39 = 36;
          v23 = llvm::StringRef::find(v38, &v39, 1uLL, 0);
          v24 = v21 >= v23 ? v23 : v21;
          if (v23 != -1)
            v21 = v24;
        }
        if (v21 == v4 && (!v4 || !memcmp(v22, a3, v4)))
        {
          if (v19 >= v36)
          {
            v27 = (v19 - v18) >> 4;
            v28 = v27 + 1;
            if ((unint64_t)(v27 + 1) >> 60)
              abort();
            if ((v36 - v18) >> 3 > v28)
              v28 = (v36 - v18) >> 3;
            if ((unint64_t)(v36 - v18) >= 0x7FFFFFFFFFFFFFF0)
              v29 = 0xFFFFFFFFFFFFFFFLL;
            else
              v29 = v28;
            if (v29)
            {
              if (v29 >> 60)
                sub_1C4764EE4();
              v30 = (char *)operator new(16 * v29);
            }
            else
            {
              v30 = 0;
            }
            v31 = &v30[16 * v27];
            *(_OWORD *)v31 = v37;
            if (v19 == v18)
            {
              v33 = &v30[16 * v27];
            }
            else
            {
              v32 = &v30[16 * v27];
              do
              {
                v33 = v32 - 16;
                *((_OWORD *)v32 - 1) = *((_OWORD *)v19 - 1);
                v19 -= 16;
                v32 -= 16;
              }
              while (v19 != v18);
            }
            v36 = &v30[16 * v29];
            v19 = v31 + 16;
            if (v18)
              operator delete(v18);
            v18 = v33;
          }
          else
          {
            *(_OWORD *)v19 = v37;
            v19 += 16;
          }
        }
      }
      if ((v42 & 1) != 0)
      {
        v26 = (uint64_t)v40;
        v40 = 0;
        if (v26)
          (*(void (**)(uint64_t))(*(_QWORD *)v26 + 8))(v26);
      }
      if ((v20 & 1) != 0)
        break;
      (*(void (**)(_QWORD, __int128 *))(**((_QWORD **)&v37 + 1) + 128))(*((_QWORD *)&v37 + 1), &v37);
      v12 = *((_QWORD *)&v37 + 1);
      v10 = v37;
      if (v37 == __PAIR128__(v17, v16))
      {
        if (v18 == v19)
          goto LABEL_50;
        *(_BYTE *)(a1 + 24) &= ~1u;
        *(_QWORD *)a1 = v18;
        *(_QWORD *)(a1 + 8) = v19;
        *(_QWORD *)(a1 + 16) = v36;
        return;
      }
    }
  }
  if (v18)
    operator delete(v18);
}

void sub_1C546B668(void **a1, unint64_t a2, __int128 *a3)
{
  _BYTE *v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  uint64_t v14;
  __int128 v15;
  char *v16;
  char *v17;
  uint64_t v18;
  char *v19;
  __int128 v20;
  char *v21;
  __int128 v22;

  v7 = (char *)a1[1];
  v6 = a1[2];
  if (0xCCCCCCCCCCCCCCCDLL * ((v6 - v7) >> 2) >= a2)
  {
    if (a2)
    {
      v13 = &v7[20 * a2];
      v14 = 20 * a2;
      do
      {
        v15 = *a3;
        *((_DWORD *)v7 + 4) = *((_DWORD *)a3 + 4);
        *(_OWORD *)v7 = v15;
        v7 += 20;
        v14 -= 20;
      }
      while (v14);
      v7 = v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xCCCCCCCCCCCCCCCDLL * ((v7 - (_BYTE *)*a1) >> 2);
    v9 = v8 + a2;
    if (v8 + a2 > 0xCCCCCCCCCCCCCCCLL)
      abort();
    v10 = 0xCCCCCCCCCCCCCCCDLL * ((v6 - (_BYTE *)*a1) >> 2);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x666666666666666)
      v11 = 0xCCCCCCCCCCCCCCCLL;
    else
      v11 = v9;
    if (v11)
    {
      if (v11 > 0xCCCCCCCCCCCCCCCLL)
        sub_1C4764EE4();
      v12 = (char *)operator new(20 * v11);
    }
    else
    {
      v12 = 0;
    }
    v16 = &v12[20 * v8];
    v17 = &v16[20 * a2];
    v18 = 20 * a2;
    v19 = v16;
    do
    {
      v20 = *a3;
      *((_DWORD *)v19 + 4) = *((_DWORD *)a3 + 4);
      *(_OWORD *)v19 = v20;
      v19 += 20;
      v18 -= 20;
    }
    while (v18);
    v21 = (char *)*a1;
    if (v7 != *a1)
    {
      do
      {
        v22 = *(_OWORD *)(v7 - 20);
        *((_DWORD *)v16 - 1) = *((_DWORD *)v7 - 1);
        *(_OWORD *)(v16 - 20) = v22;
        v16 -= 20;
        v7 -= 20;
      }
      while (v7 != v21);
      v7 = (char *)*a1;
    }
    *a1 = v16;
    a1[1] = v17;
    a1[2] = &v12[20 * v11];
    if (v7)
      operator delete(v7);
  }
}

_QWORD *sub_1C546B800(_QWORD *a1)
{
  *a1 = &off_1E81690E8;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  return a1;
}

void sub_1C546B844(_QWORD *a1)
{
  *a1 = &off_1E81690E8;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C546B898(uint64_t a1@<X0>, unsigned int *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unsigned int *v5;
  char *v7;
  unsigned int *v8;
  char *v9;
  uint64_t v10;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char **v16;
  char v17;
  unint64_t v18;
  char **v19;
  char *v20[3];
  __int128 v21;

  v5 = a2 + 4;
  if ((unint64_t)(a2 + 4) > a3)
    goto LABEL_3;
  v7 = (char *)a2[1];
  v8 = &v5[5 * *a2];
  v9 = &v7[(_QWORD)v8];
  if (&v7[(_QWORD)v8] > (char *)a3)
    goto LABEL_3;
  v12 = a2[2];
  v13 = *(char **)(a1 + 56);
  v15 = *(_QWORD *)v13;
  v14 = *((_QWORD *)v13 + 1);
  v20[0] = (char *)&v5[5 * *a2];
  v20[1] = v7;
  v20[2] = v13;
  v21 = *(_OWORD *)(a1 + 40);
  llvm::coverage::RawCoverageFilenamesReader::read(v20, 0, &v19);
  v16 = v19;
  if (v19)
    goto LABEL_5;
  v18 = (unint64_t)&v9[v12];
  if (v18 > a3)
  {
LABEL_3:
    v10 = operator new();
    *(_QWORD *)v10 = &off_1E8169028;
    *(_DWORD *)(v10 + 8) = 5;
    *(_BYTE *)(a4 + 8) |= 1u;
    *(_QWORD *)a4 = v10;
    return;
  }
  (*(void (**)(char ***__return_ptr, uint64_t, unsigned int *, unsigned int *, unint64_t, uint64_t, char *, unint64_t))(*(_QWORD *)a1 + 24))(&v19, a1, v5, v8, (-1431655765 * ((v14 - v15) >> 3)) | ((unint64_t)(-1431655765* ((*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8)- **(_QWORD **)(a1 + 56)) >> 3)- -1431655765* ((v14 - v15) >> 3)) << 32), 1, v9, v18);
  v16 = v19;
  if (v19)
  {
LABEL_5:
    v17 = *(_BYTE *)(a4 + 8) | 1;
  }
  else
  {
    v16 = (char **)((v18 + 7) & 0xFFFFFFFFFFFFFFF8);
    v17 = *(_BYTE *)(a4 + 8) & 0xFE;
  }
  *(_BYTE *)(a4 + 8) = v17;
  *(_QWORD *)a4 = v16;
}

void sub_1C546BA18(uint64_t a1@<X0>, unsigned int *a2@<X1>, unint64_t a3@<X2>, unint64_t a4@<X3>, char a5@<W4>, uint64_t a6@<X5>, unint64_t a7@<X6>, uint64_t *a8@<X8>)
{
  uint64_t *v8;
  unint64_t v9;
  unint64_t v11;
  unsigned int *v12;
  uint64_t v13;
  BOOL v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  BOOL v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  __n128 v34;
  char v35;
  uint64_t v36;
  unint64_t v37;
  _QWORD *v38;
  char *v39;
  uint64_t v40;
  _QWORD *v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  unint64_t v45;
  char *v46;
  char *v47;
  char *v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  char *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v60;
  unint64_t v61;
  char v65;
  uint64_t v66;
  uint64_t v67;
  char v68;
  _OWORD v69[2];
  __int16 v70;
  uint64_t v71;
  char v72;
  uint64_t v73;
  char v74;
  uint64_t v75;

  v8 = a8;
  v75 = *MEMORY[0x1E0C80C00];
  if ((unint64_t)a2 < a3)
  {
    v9 = a7;
    v11 = a3;
    v12 = a2;
    v13 = a1;
    v61 = HIDWORD(a4);
    if (a5)
      v14 = HIDWORD(a4) == 0;
    else
      v14 = 1;
    v15 = v14;
    v66 = a1 + 8;
    v60 = a4;
    v65 = v15;
    while (1)
    {
      v16 = v12[2];
      if (a6 + v16 > v9)
      {
LABEL_64:
        v56 = operator new();
        *(_QWORD *)v56 = &off_1E8169028;
        *(_DWORD *)(v56 + 8) = 5;
        goto LABEL_65;
      }
      if ((v15 & 1) == 0)
        break;
LABEL_62:
      v12 += 5;
      a6 += v16;
      if ((unint64_t)v12 >= v11)
        goto LABEL_63;
    }
    v17 = *(_QWORD *)(v12 + 3);
    v18 = (uint64_t)(*(_QWORD *)(*(_QWORD *)(v13 + 64) + 8) - **(_QWORD **)(v13 + 64)) >> 6;
    *(_QWORD *)&v69[0] = *v12;
    *((_QWORD *)&v69[0] + 1) = v18;
    sub_1C546BE80(&v67, v66, v69, (_QWORD *)v69 + 1);
    if (!v68)
    {
      v28 = v13;
      v29 = *(_QWORD *)(v67 + 8);
      v30 = **(_QWORD **)(v28 + 64);
      v31 = v30 + (v29 << 6);
      v33 = *(_QWORD *)(v31 + 24);
      v32 = v31 + 24;
      v34 = *(__n128 *)(v32 + 8);
      if (v33)
      {
        v74 &= ~1u;
        LOBYTE(v73) = 0;
        if ((v74 & 1) == 0)
          goto LABEL_19;
LABEL_44:
        v53 = v73;
        *v8 = v73;
LABEL_61:
        v9 = a7;
        v13 = a1;
        v11 = a3;
        v15 = v65;
        if (v53)
          return;
        goto LABEL_62;
      }
      v69[0] = *(_OWORD *)(v32 + 8);
      llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v69, (uint64_t)&v73);
      if ((v74 & 1) != 0)
        goto LABEL_44;
LABEL_19:
      if ((_BYTE)v73)
      {
        if (v17)
        {
          v35 = v72 & 0xFE;
          v72 &= ~1u;
          LOBYTE(v71) = 0;
        }
        else
        {
          *(_QWORD *)&v69[0] = a6;
          *((_QWORD *)&v69[0] + 1) = v16;
          llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v69, (uint64_t)&v71);
          v35 = v72;
        }
        v54 = v17;
        if ((v35 & 1) != 0)
        {
          v53 = v71;
          v71 = 0;
          *v8 = v53;
          if (v53)
            goto LABEL_61;
        }
        else if ((_BYTE)v71)
        {
          goto LABEL_55;
        }
        v53 = 0;
        *(_QWORD *)v32 = v54;
        *(_QWORD *)(v32 + 8) = a6;
        *(_QWORD *)(v32 + 16) = v16;
        v55 = v30 + (v29 << 6);
        *(_QWORD *)(v55 + 48) = v60;
        *(_QWORD *)(v55 + 56) = v61;
        *v8 = 0;
        if ((v35 & 1) != 0)
        {
          if (v71)
            (*(void (**)(uint64_t, __n128))(*(_QWORD *)v71 + 8))(v71, v34);
          v53 = 0;
        }
        goto LABEL_61;
      }
LABEL_55:
      v53 = 0;
      *v8 = 0;
      goto LABEL_61;
    }
    v19 = *(_QWORD **)(v13 + 32);
    v21 = *v12;
    v20 = v12[1];
    v22 = v19[2];
    v23 = v21 >= v22;
    v24 = v21 - v22;
    if (v23 && (v25 = v19[1], v24 + v20 <= v25))
    {
      if (v25 < v24)
        v24 = v19[1];
      v26 = *v19 + v24;
      if (v25 - v24 >= v20)
        v27 = v12[1];
      else
        v27 = v25 - v24;
      if (!(_DWORD)v20)
      {
LABEL_29:
        if (v27)
        {
          v36 = *(_QWORD *)(v13 + 64);
          v38 = *(_QWORD **)(v36 + 8);
          v37 = *(_QWORD *)(v36 + 16);
          if ((unint64_t)v38 >= v37)
          {
            v58 = v17;
            v41 = *(_QWORD **)v36;
            v42 = ((uint64_t)v38 - *(_QWORD *)v36) >> 6;
            v43 = v42 + 1;
            if ((unint64_t)(v42 + 1) >> 58)
              abort();
            v44 = v37 - (_QWORD)v41;
            if (v44 >> 5 > v43)
              v43 = v44 >> 5;
            if ((unint64_t)v44 >= 0x7FFFFFFFFFFFFFC0)
              v43 = 0x3FFFFFFFFFFFFFFLL;
            if (v43 >> 58)
              sub_1C4764EE4();
            v45 = v26;
            v57 = v43;
            v46 = (char *)operator new(v43 << 6);
            v47 = &v46[64 * v42];
            *(_DWORD *)v47 = 0;
            *((_QWORD *)v47 + 1) = v45;
            *((_QWORD *)v47 + 2) = v27;
            *((_QWORD *)v47 + 3) = v58;
            *((_QWORD *)v47 + 4) = a6;
            *((_QWORD *)v47 + 5) = v16;
            *((_QWORD *)v47 + 6) = v60;
            *((_QWORD *)v47 + 7) = v61;
            if (v38 == v41)
            {
              v52 = &v46[64 * v42];
              v9 = a7;
              v15 = v65;
            }
            else
            {
              v48 = &v46[64 * v42];
              v9 = a7;
              v15 = v65;
              do
              {
                v49 = *((_OWORD *)v38 - 4);
                v50 = *((_OWORD *)v38 - 3);
                v51 = *((_OWORD *)v38 - 1);
                v52 = v48 - 64;
                *((_OWORD *)v48 - 2) = *((_OWORD *)v38 - 2);
                *((_OWORD *)v48 - 1) = v51;
                *((_OWORD *)v48 - 4) = v49;
                *((_OWORD *)v48 - 3) = v50;
                v38 -= 8;
                v48 -= 64;
              }
              while (v38 != v41);
            }
            v39 = v47 + 64;
            *(_QWORD *)v36 = v52;
            *(_QWORD *)(v36 + 8) = v47 + 64;
            *(_QWORD *)(v36 + 16) = &v46[64 * v57];
            if (v41)
              operator delete(v41);
            v11 = a3;
          }
          else
          {
            *(_DWORD *)v38 = 0;
            v38[1] = v26;
            v38[2] = v27;
            v38[3] = v17;
            v38[4] = a6;
            v38[5] = v16;
            v38[6] = v60;
            v39 = (char *)(v38 + 8);
            v38[7] = v61;
            v11 = a3;
            v15 = v65;
          }
          v40 = 0;
          *(_QWORD *)(v36 + 8) = v39;
          v8 = a8;
          v13 = a1;
        }
        else
        {
          v40 = operator new();
          *(_QWORD *)&v69[0] = "function name is empty";
          v70 = 259;
          *(_QWORD *)v40 = off_1E8192D50;
          *(_DWORD *)(v40 + 8) = 9;
          llvm::Twine::str((llvm::Twine *)v69, (_QWORD *)(v40 + 16));
          v15 = v65;
        }
        *v8 = v40;
        if (v40)
          return;
        goto LABEL_62;
      }
    }
    else
    {
      v26 = 0;
      v27 = 0;
      if (!(_DWORD)v20)
        goto LABEL_29;
    }
    if (!v27)
      goto LABEL_64;
    goto LABEL_29;
  }
LABEL_63:
  v56 = 0;
LABEL_65:
  *v8 = v56;
}

_DWORD *sub_1C546BE80(_DWORD *result, uint64_t a2, _DWORD *a3, _QWORD *a4)
{
  _DWORD *v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  char v14;
  int v15;
  uint64_t v16;
  int v17;
  BOOL v18;
  unsigned int v19;
  int v20;
  int v21;
  unsigned int v22;
  int v23;
  uint64_t v24;
  int v25;
  BOOL v26;
  unsigned int v27;
  int v28;
  int v29;
  unsigned int v30;
  int v31;
  int v32;
  BOOL v33;
  unsigned int v34;

  v7 = result;
  v8 = *(_QWORD *)a2;
  v9 = *(_DWORD *)(a2 + 16);
  if (v9)
  {
    v10 = v9 - 1;
    v11 = (37 * *a3) & (v9 - 1);
    v12 = v8 + 16 * v11;
    v13 = *(_DWORD *)v12;
    if (*a3 == *(_DWORD *)v12)
    {
LABEL_3:
      v14 = 0;
      goto LABEL_10;
    }
    v16 = 0;
    v17 = 1;
    while (v13 != -1)
    {
      if (v16)
        v18 = 0;
      else
        v18 = v13 == -2;
      if (v18)
        v16 = v12;
      v19 = v11 + v17++;
      v11 = v19 & v10;
      v12 = v8 + 16 * (v19 & v10);
      v13 = *(_DWORD *)v12;
      if (*a3 == *(_DWORD *)v12)
        goto LABEL_3;
    }
    if (v16)
      v12 = v16;
  }
  else
  {
    v12 = 0;
  }
  v15 = *(_DWORD *)(a2 + 8);
  if (4 * v15 + 4 >= 3 * v9)
  {
    result = sub_1C5255878((uint64_t *)a2, 2 * v9);
    v8 = *(_QWORD *)a2;
    v20 = *(_DWORD *)(a2 + 16);
    if (v20)
    {
      v21 = v20 - 1;
      v22 = (37 * *a3) & (v20 - 1);
      v12 = v8 + 16 * v22;
      v23 = *(_DWORD *)v12;
      if (*a3 == *(_DWORD *)v12)
        goto LABEL_7;
      v24 = 0;
      v25 = 1;
      while (v23 != -1)
      {
        if (v24)
          v26 = 0;
        else
          v26 = v23 == -2;
        if (v26)
          v24 = v12;
        v27 = v22 + v25++;
        v22 = v27 & v21;
        v12 = v8 + 16 * (v27 & v21);
        v23 = *(_DWORD *)v12;
        if (*a3 == *(_DWORD *)v12)
          goto LABEL_7;
      }
LABEL_46:
      if (v24)
        v12 = v24;
      goto LABEL_7;
    }
LABEL_45:
    v12 = 0;
    goto LABEL_7;
  }
  if (v9 + ~v15 - *(_DWORD *)(a2 + 12) <= v9 >> 3)
  {
    result = sub_1C5255878((uint64_t *)a2, v9);
    v8 = *(_QWORD *)a2;
    v28 = *(_DWORD *)(a2 + 16);
    if (v28)
    {
      v29 = v28 - 1;
      v30 = (37 * *a3) & (v28 - 1);
      v12 = v8 + 16 * v30;
      v31 = *(_DWORD *)v12;
      if (*a3 == *(_DWORD *)v12)
        goto LABEL_7;
      v24 = 0;
      v32 = 1;
      while (v31 != -1)
      {
        if (v24)
          v33 = 0;
        else
          v33 = v31 == -2;
        if (v33)
          v24 = v12;
        v34 = v30 + v32++;
        v30 = v34 & v29;
        v12 = v8 + 16 * (v34 & v29);
        v31 = *(_DWORD *)v12;
        if (*a3 == *(_DWORD *)v12)
          goto LABEL_7;
      }
      goto LABEL_46;
    }
    goto LABEL_45;
  }
LABEL_7:
  ++*(_DWORD *)(a2 + 8);
  if (*(_DWORD *)v12 != -1)
    --*(_DWORD *)(a2 + 12);
  *(_DWORD *)v12 = *a3;
  *(_QWORD *)(v12 + 8) = *a4;
  v9 = *(_DWORD *)(a2 + 16);
  v14 = 1;
LABEL_10:
  *(_QWORD *)v7 = v12;
  *((_QWORD *)v7 + 1) = v8 + 16 * v9;
  *((_BYTE *)v7 + 16) = v14;
  return result;
}

_QWORD *sub_1C546C0B8(_QWORD *a1)
{
  *a1 = &off_1E8169118;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  return a1;
}

void sub_1C546C0FC(_QWORD *a1)
{
  *a1 = &off_1E8169118;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C546C150(uint64_t a1@<X0>, unsigned int *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unsigned int *v5;
  char *v7;
  unsigned int *v8;
  char *v9;
  uint64_t v10;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char **v16;
  char v17;
  unint64_t v18;
  char **v19;
  char *v20[3];
  __int128 v21;

  v5 = a2 + 4;
  if ((unint64_t)(a2 + 4) > a3)
    goto LABEL_3;
  v7 = (char *)a2[1];
  v8 = &v5[5 * *a2];
  v9 = &v7[(_QWORD)v8];
  if (&v7[(_QWORD)v8] > (char *)a3)
    goto LABEL_3;
  v12 = a2[2];
  v13 = *(char **)(a1 + 56);
  v15 = *(_QWORD *)v13;
  v14 = *((_QWORD *)v13 + 1);
  v20[0] = (char *)&v5[5 * *a2];
  v20[1] = v7;
  v20[2] = v13;
  v21 = *(_OWORD *)(a1 + 40);
  llvm::coverage::RawCoverageFilenamesReader::read(v20, 1, &v19);
  v16 = v19;
  if (v19)
    goto LABEL_5;
  v18 = (unint64_t)&v9[v12];
  if (v18 > a3)
  {
LABEL_3:
    v10 = operator new();
    *(_QWORD *)v10 = &off_1E8169028;
    *(_DWORD *)(v10 + 8) = 5;
    *(_BYTE *)(a4 + 8) |= 1u;
    *(_QWORD *)a4 = v10;
    return;
  }
  (*(void (**)(char ***__return_ptr, uint64_t, unsigned int *, unsigned int *, unint64_t, uint64_t, char *, unint64_t))(*(_QWORD *)a1 + 24))(&v19, a1, v5, v8, (-1431655765 * ((v14 - v15) >> 3)) | ((unint64_t)(-1431655765* ((*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8)- **(_QWORD **)(a1 + 56)) >> 3)- -1431655765* ((v14 - v15) >> 3)) << 32), 1, v9, v18);
  v16 = v19;
  if (v19)
  {
LABEL_5:
    v17 = *(_BYTE *)(a4 + 8) | 1;
  }
  else
  {
    v16 = (char **)((v18 + 7) & 0xFFFFFFFFFFFFFFF8);
    v17 = *(_BYTE *)(a4 + 8) & 0xFE;
  }
  *(_BYTE *)(a4 + 8) = v17;
  *(_QWORD *)a4 = v16;
}

void sub_1C546C2D0(uint64_t a1@<X0>, uint64_t *a2@<X1>, unint64_t a3@<X2>, unint64_t a4@<X3>, char a5@<W4>, uint64_t a6@<X5>, unint64_t a7@<X6>, uint64_t *a8@<X8>)
{
  uint64_t *v8;
  unint64_t v9;
  uint64_t *v11;
  uint64_t v12;
  BOOL v13;
  char v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  unint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  _QWORD *v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  __n128 v38;
  char v39;
  char v40;
  uint64_t v41;
  _QWORD *v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  char *v46;
  char *v47;
  char *v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  char *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v62;
  unint64_t v63;
  char v65;
  uint64_t v67;
  uint64_t *v68;
  char v69;
  _OWORD v70[2];
  __int16 v71;
  uint64_t v72;
  char v73;
  uint64_t v74;
  char v75;
  uint64_t v76;

  v8 = a8;
  v76 = *MEMORY[0x1E0C80C00];
  if ((unint64_t)a2 < a3)
  {
    v9 = a7;
    v11 = a2;
    v12 = a1;
    v60 = HIDWORD(a4);
    if (a5)
      v13 = HIDWORD(a4) == 0;
    else
      v13 = 1;
    v14 = v13;
    v62 = a1 + 8;
    v59 = a4;
    v63 = a3;
    v65 = v14;
    do
    {
      v15 = *((unsigned int *)v11 + 2);
      if (a6 + v15 > v9)
      {
        v55 = operator new();
        *(_QWORD *)v55 = &off_1E8169028;
        *(_DWORD *)(v55 + 8) = 5;
        goto LABEL_64;
      }
      if ((v14 & 1) == 0)
      {
        v67 = *(uint64_t *)((char *)v11 + 12);
        v16 = (uint64_t)(*(_QWORD *)(*(_QWORD *)(v12 + 64) + 8) - **(_QWORD **)(v12 + 64)) >> 6;
        *(_QWORD *)&v70[0] = *v11;
        *((_QWORD *)&v70[0] + 1) = v16;
        sub_1C546C7AC(&v68, v62, (uint64_t *)v70, (uint64_t *)v70 + 1);
        if (!v69)
        {
          v33 = v68[1];
          v34 = **(_QWORD **)(v12 + 64);
          v35 = v34 + (v33 << 6);
          v37 = *(_QWORD *)(v35 + 24);
          v36 = v35 + 24;
          v38 = *(__n128 *)(v36 + 8);
          if (v37)
          {
            v39 = v75 & 0xFE;
            v75 &= ~1u;
            LOBYTE(v74) = 0;
          }
          else
          {
            v70[0] = *(_OWORD *)(v36 + 8);
            llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v70, (uint64_t)&v74);
            v39 = v75;
          }
          v14 = v65;
          if ((v39 & 1) != 0)
          {
            v41 = v74;
            v8 = a8;
            *a8 = v74;
          }
          else if ((_BYTE)v74)
          {
            if (v67)
            {
              v40 = v73 & 0xFE;
              v73 &= ~1u;
              LOBYTE(v72) = 0;
            }
            else
            {
              *(_QWORD *)&v70[0] = a6;
              *((_QWORD *)&v70[0] + 1) = v15;
              llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v70, (uint64_t)&v72);
              v14 = v65;
              v40 = v73;
            }
            v53 = v33;
            if ((v40 & 1) != 0)
            {
              v41 = v72;
              v72 = 0;
              *a8 = v41;
              if (!v41)
                goto LABEL_50;
            }
            else
            {
              if ((_BYTE)v72)
              {
                v41 = 0;
                *a8 = 0;
                goto LABEL_54;
              }
LABEL_50:
              v41 = 0;
              *(_QWORD *)v36 = v67;
              *(_QWORD *)(v36 + 8) = a6;
              *(_QWORD *)(v36 + 16) = v15;
              v54 = v34 + (v53 << 6);
              *(_QWORD *)(v54 + 48) = v59;
              *(_QWORD *)(v54 + 56) = v60;
              *a8 = 0;
              if ((v40 & 1) != 0)
              {
                if (v72)
                {
                  (*(void (**)(uint64_t, __n128))(*(_QWORD *)v72 + 8))(v72, v38);
                  v14 = v65;
                }
                v41 = 0;
              }
            }
LABEL_54:
            v8 = a8;
          }
          else
          {
            v41 = 0;
            v8 = a8;
            *a8 = 0;
          }
          a3 = v63;
          v9 = a7;
          v12 = a1;
          if (v41)
            return;
          goto LABEL_56;
        }
        v17 = *(uint64_t **)(v12 + 32);
        v18 = *v11;
        sub_1C546CB40(v17);
        v19 = (_QWORD *)v17[7];
        v20 = (_QWORD *)v17[8];
        if (v20 != v19)
        {
          v21 = 0xAAAAAAAAAAAAAAABLL * (v20 - v19);
          do
          {
            v22 = v21 >> 1;
            v23 = &v19[3 * (v21 >> 1)];
            v25 = *v23;
            v24 = v23 + 3;
            v21 += ~(v21 >> 1);
            if (v25 < v18)
              v19 = v24;
            else
              v21 = v22;
          }
          while (v21);
        }
        if (v19 != v20 && *v19 == v18 && (v26 = v19[2]) != 0)
        {
          v27 = v19[1];
          v28 = *(_QWORD *)(a1 + 64);
          v30 = *(_QWORD **)(v28 + 8);
          v29 = *(_QWORD *)(v28 + 16);
          if ((unint64_t)v30 >= v29)
          {
            v42 = *(_QWORD **)v28;
            v43 = ((uint64_t)v30 - *(_QWORD *)v28) >> 6;
            v44 = v43 + 1;
            if ((unint64_t)(v43 + 1) >> 58)
              abort();
            v57 = v27;
            v58 = *(_QWORD *)(a1 + 64);
            v45 = v29 - (_QWORD)v42;
            if (v45 >> 5 > v44)
              v44 = v45 >> 5;
            if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFC0)
              v44 = 0x3FFFFFFFFFFFFFFLL;
            if (v44 >> 58)
              sub_1C4764EE4();
            v56 = v44;
            v46 = (char *)operator new(v44 << 6);
            v47 = &v46[64 * v43];
            *(_DWORD *)v47 = 1;
            *((_QWORD *)v47 + 1) = v57;
            *((_QWORD *)v47 + 2) = v26;
            *((_QWORD *)v47 + 3) = v67;
            *((_QWORD *)v47 + 4) = a6;
            *((_QWORD *)v47 + 5) = v15;
            *((_QWORD *)v47 + 6) = v59;
            *((_QWORD *)v47 + 7) = v60;
            if (v30 == v42)
            {
              v52 = &v46[64 * v43];
              v9 = a7;
              v28 = v58;
            }
            else
            {
              v48 = &v46[64 * v43];
              v9 = a7;
              v28 = v58;
              do
              {
                v49 = *((_OWORD *)v30 - 4);
                v50 = *((_OWORD *)v30 - 3);
                v51 = *((_OWORD *)v30 - 1);
                v52 = v48 - 64;
                *((_OWORD *)v48 - 2) = *((_OWORD *)v30 - 2);
                *((_OWORD *)v48 - 1) = v51;
                *((_OWORD *)v48 - 4) = v49;
                *((_OWORD *)v48 - 3) = v50;
                v30 -= 8;
                v48 -= 64;
              }
              while (v30 != v42);
            }
            v31 = v47 + 64;
            *(_QWORD *)v28 = v52;
            *(_QWORD *)(v28 + 8) = v47 + 64;
            *(_QWORD *)(v28 + 16) = &v46[64 * v56];
            if (v42)
            {
              operator delete(v42);
              v28 = v58;
            }
          }
          else
          {
            *(_DWORD *)v30 = 1;
            v30[1] = v27;
            v30[2] = v26;
            v30[3] = v67;
            v30[4] = a6;
            v30[5] = v15;
            v30[6] = v59;
            v31 = (char *)(v30 + 8);
            v30[7] = v60;
            v9 = a7;
          }
          a3 = v63;
          v12 = a1;
          v14 = v65;
          v32 = 0;
          *(_QWORD *)(v28 + 8) = v31;
          v8 = a8;
        }
        else
        {
          v32 = operator new();
          *(_QWORD *)&v70[0] = "function name is empty";
          v71 = 259;
          *(_QWORD *)v32 = off_1E8192D50;
          *(_DWORD *)(v32 + 8) = 9;
          llvm::Twine::str((llvm::Twine *)v70, (_QWORD *)(v32 + 16));
          a3 = v63;
          v9 = a7;
          v12 = a1;
          v14 = v65;
        }
        *v8 = v32;
        if (v32)
          return;
      }
LABEL_56:
      v11 = (uint64_t *)((char *)v11 + 20);
      a6 += v15;
    }
    while ((unint64_t)v11 < a3);
  }
  v55 = 0;
LABEL_64:
  *v8 = v55;
}

uint64_t **sub_1C546C7AC(uint64_t **result, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t **v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t *v12;
  uint64_t v13;
  char v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  int v19;
  BOOL v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t *v25;
  int v26;
  BOOL v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  uint64_t v31;
  int v32;
  BOOL v33;
  unsigned int v34;

  v7 = result;
  v8 = *(_QWORD *)a2;
  v9 = *(_DWORD *)(a2 + 16);
  if (v9)
  {
    v10 = v9 - 1;
    v11 = (37 * *a3) & (v9 - 1);
    v12 = (uint64_t *)(v8 + 16 * v11);
    v13 = *v12;
    if (*a3 == *v12)
    {
LABEL_3:
      v14 = 0;
      goto LABEL_11;
    }
    v18 = 0;
    v19 = 1;
    while (v13 != -1)
    {
      if (v18)
        v20 = 0;
      else
        v20 = v13 == -2;
      if (v20)
        v18 = v12;
      v21 = v11 + v19++;
      v11 = v21 & v10;
      v12 = (uint64_t *)(v8 + 16 * (v21 & v10));
      v13 = *v12;
      if (*a3 == *v12)
        goto LABEL_3;
    }
    if (v18)
      v12 = v18;
  }
  else
  {
    v12 = 0;
  }
  v15 = *(_DWORD *)(a2 + 8);
  if (4 * v15 + 4 >= 3 * v9)
  {
    result = (uint64_t **)sub_1C546C9CC(a2, 2 * v9);
    v8 = *(_QWORD *)a2;
    v9 = *(_DWORD *)(a2 + 16);
    v16 = *a3;
    v22 = v9 - 1;
    v23 = (37 * *a3) & (v9 - 1);
    v12 = (uint64_t *)(*(_QWORD *)a2 + 16 * v23);
    v24 = *v12;
    if (*a3 == *v12)
      goto LABEL_8;
    v25 = 0;
    v26 = 1;
    while (v24 != -1)
    {
      if (v25)
        v27 = 0;
      else
        v27 = v24 == -2;
      if (v27)
        v25 = v12;
      v28 = v23 + v26++;
      v23 = v28 & v22;
      v12 = (uint64_t *)(v8 + 16 * (v28 & v22));
      v24 = *v12;
      if (v16 == *v12)
        goto LABEL_8;
    }
    goto LABEL_44;
  }
  if (v9 + ~v15 - *(_DWORD *)(a2 + 12) <= v9 >> 3)
  {
    result = (uint64_t **)sub_1C546C9CC(a2, v9);
    v8 = *(_QWORD *)a2;
    v9 = *(_DWORD *)(a2 + 16);
    v16 = *a3;
    v29 = v9 - 1;
    v30 = (37 * *a3) & (v9 - 1);
    v12 = (uint64_t *)(*(_QWORD *)a2 + 16 * v30);
    v31 = *v12;
    if (*a3 == *v12)
      goto LABEL_8;
    v25 = 0;
    v32 = 1;
    while (v31 != -1)
    {
      if (v25)
        v33 = 0;
      else
        v33 = v31 == -2;
      if (v33)
        v25 = v12;
      v34 = v30 + v32++;
      v30 = v34 & v29;
      v12 = (uint64_t *)(v8 + 16 * (v34 & v29));
      v31 = *v12;
      if (v16 == *v12)
        goto LABEL_8;
    }
LABEL_44:
    if (v25)
      v12 = v25;
  }
  v16 = *v12;
LABEL_8:
  ++*(_DWORD *)(a2 + 8);
  if (v16 != -1)
    --*(_DWORD *)(a2 + 12);
  v17 = *a4;
  *v12 = *a3;
  v12[1] = v17;
  v14 = 1;
LABEL_11:
  *v7 = v12;
  v7[1] = (uint64_t *)(v8 + 16 * v9);
  *((_BYTE *)v7 + 16) = v14;
  return result;
}

_QWORD *sub_1C546C9CC(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unsigned int v8;
  _QWORD *result;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  int v13;
  int v14;
  uint64_t *v15;
  uint64_t v16;
  unsigned int v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  int v22;
  BOOL v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;

  v3 = *(unsigned int *)(a1 + 16);
  v4 = *(uint64_t **)a1;
  v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
    v8 = v7 + 1;
  else
    v8 = 64;
  *(_DWORD *)(a1 + 16) = v8;
  result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(_QWORD *)a1 = result;
  if (v4)
  {
    *(_QWORD *)(a1 + 8) = 0;
    v10 = *(unsigned int *)(a1 + 16);
    if ((_DWORD)v10)
    {
      v11 = 16 * v10;
      v12 = result;
      do
      {
        *v12 = -1;
        v12 += 2;
        v11 -= 16;
      }
      while (v11);
    }
    if ((_DWORD)v3)
    {
      v13 = 0;
      v14 = v10 - 1;
      v15 = v4;
      do
      {
        v16 = *v15;
        if ((unint64_t)*v15 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          v17 = (37 * v16) & v14;
          v18 = &result[2 * v17];
          v19 = *v18;
          if (v16 != *v18)
          {
            v21 = 0;
            v22 = 1;
            while (v19 != -1)
            {
              if (v21)
                v23 = 0;
              else
                v23 = v19 == -2;
              if (v23)
                v21 = v18;
              v24 = v17 + v22++;
              v17 = v24 & v14;
              v18 = &result[2 * (v24 & v14)];
              v19 = *v18;
              if (v16 == *v18)
                goto LABEL_12;
            }
            if (v21)
              v18 = v21;
          }
LABEL_12:
          v20 = v15[1];
          *v18 = v16;
          v18[1] = v20;
          *(_DWORD *)(a1 + 8) = ++v13;
        }
        v15 += 2;
      }
      while (v15 != &v4[2 * v3]);
    }
    JUMPOUT(0x1CAA32FB4);
  }
  *(_QWORD *)(a1 + 8) = 0;
  v25 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v25)
  {
    v26 = 16 * v25;
    do
    {
      *result = -1;
      result += 2;
      v26 -= 16;
    }
    while (v26);
  }
  return result;
}

uint64_t *sub_1C546CB40(uint64_t *result)
{
  uint64_t *v1;
  unint64_t *v2;
  uint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  char v14;
  char v15;
  char v16;

  if (!*((_BYTE *)result + 128))
  {
    v1 = result;
    v2 = (unint64_t *)result[7];
    v3 = (uint64_t *)v1[8];
    v4 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * (((char *)v3 - (char *)v2) >> 3));
    if (v3 == (uint64_t *)v2)
      v5 = 0;
    else
      v5 = v4;
    sub_1C546CC50(v2, v3, (uint64_t)&v14, v5, 1);
    v6 = v1[10];
    v7 = (unint64_t *)v1[11];
    v8 = 126 - 2 * __clz(((uint64_t)v7 - v6) >> 4);
    if (v7 == (unint64_t *)v6)
      v9 = 0;
    else
      v9 = v8;
    sub_1C546DA6C(v6, v7, (uint64_t)&v15, v9, 1);
    v10 = v1[13];
    v11 = (unint64_t *)v1[14];
    v12 = 126 - 2 * __clz(((uint64_t)v11 - v10) >> 4);
    if (v11 == (unint64_t *)v10)
      v13 = 0;
    else
      v13 = v12;
    sub_1C546E61C(v10, v11, (uint64_t)&v16, v13, 1);
    result = sub_1C546F268((uint64_t *)v1[13], (uint64_t *)v1[14]);
    if ((uint64_t *)v1[14] != result)
      v1[14] = (uint64_t)result;
    *((_BYTE *)v1 + 128) = 1;
  }
  return result;
}

void sub_1C546CC50(unint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4, char a5)
{
  unint64_t *v8;
  unint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t *v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  char v20;
  BOOL v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t *v24;
  BOOL v26;
  uint64_t v27;
  unint64_t *v28;
  uint64_t *v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  char *v33;
  unint64_t *v34;
  unint64_t *v35;
  uint64_t *v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t *v39;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;

uint64_t sub_1C546D0A0(unint64_t *a1, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  __int128 *v6;
  __int128 v7;
  __int128 v8;
  unint64_t v9;
  __int128 v10;
  __int128 v11;
  unint64_t v12;
  __int128 v13;

  v3 = *a2;
  v4 = *a1;
  v5 = *a3;
  if (*a2 < *a1)
  {
    v6 = (__int128 *)(a1 + 1);
    if (v5 < v3)
    {
      *a1 = v5;
      *a3 = v4;
      v7 = *v6;
      *v6 = *(_OWORD *)(a3 + 1);
      *(_OWORD *)(a3 + 1) = v7;
      return 1;
    }
    *a1 = v3;
    *a2 = v4;
    v11 = *v6;
    *v6 = *(_OWORD *)(a2 + 1);
    *(_OWORD *)(a2 + 1) = v11;
    v12 = *a2;
    if (*a3 >= *a2)
      return 1;
    *a2 = *a3;
    *a3 = v12;
    v13 = *(_OWORD *)(a2 + 1);
    *(_OWORD *)(a2 + 1) = *(_OWORD *)(a3 + 1);
    *(_OWORD *)(a3 + 1) = v13;
    return 2;
  }
  if (v5 < v3)
  {
    *a2 = v5;
    *a3 = v3;
    v8 = *(_OWORD *)(a2 + 1);
    *(_OWORD *)(a2 + 1) = *(_OWORD *)(a3 + 1);
    *(_OWORD *)(a3 + 1) = v8;
    v9 = *a1;
    if (*a2 >= *a1)
      return 1;
    *a1 = *a2;
    *a2 = v9;
    v10 = *(_OWORD *)(a1 + 1);
    *(_OWORD *)(a1 + 1) = *(_OWORD *)(a2 + 1);
    *(_OWORD *)(a2 + 1) = v10;
    return 2;
  }
  return 0;
}

unint64_t *sub_1C546D190(uint64_t *a1, unint64_t *a2)
{
  unint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  __int128 v12;
  __int128 v13;

  v2 = *a1;
  if (*a1 >= *(a2 - 3))
  {
    v5 = (unint64_t *)(a1 + 3);
    do
    {
      v3 = v5;
      if (v5 >= a2)
        break;
      v5 += 3;
    }
    while (v2 >= *v3);
  }
  else
  {
    v3 = (unint64_t *)a1;
    do
    {
      v4 = v3[3];
      v3 += 3;
    }
    while (v2 >= v4);
  }
  if (v3 < a2)
  {
    do
    {
      v6 = *(a2 - 3);
      a2 -= 3;
    }
    while (v2 < v6);
  }
  if (v3 < a2)
  {
    v7 = *v3;
    v8 = *a2;
    do
    {
      *v3 = v8;
      *a2 = v7;
      v13 = *(_OWORD *)(v3 + 1);
      *(_OWORD *)(v3 + 1) = *(_OWORD *)(a2 + 1);
      *(_OWORD *)(a2 + 1) = v13;
      do
      {
        v9 = v3[3];
        v3 += 3;
        v7 = v9;
      }
      while (v2 >= v9);
      do
      {
        v10 = *(a2 - 3);
        a2 -= 3;
        v8 = v10;
      }
      while (v2 < v10);
    }
    while (v3 < a2);
  }
  if (v3 - 3 != (unint64_t *)a1)
  {
    *a1 = *(v3 - 3);
    *(_OWORD *)(a1 + 1) = *((_OWORD *)v3 - 1);
  }
  *(v3 - 3) = v2;
  *((_OWORD *)v3 - 1) = v12;
  return v3;
}

unint64_t sub_1C546D278(uint64_t *a1, unint64_t *a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  __int128 v14;
  __int128 v15;

  v2 = 0;
  v3 = *a1;
  do
  {
    v4 = a1[v2 + 3];
    v2 += 3;
  }
  while (v4 < v3);
  v5 = (unint64_t)&a1[v2];
  if (v2 == 3)
  {
    do
    {
      if (v5 >= (unint64_t)a2)
        break;
      v7 = *(a2 - 3);
      a2 -= 3;
    }
    while (v7 >= v3);
  }
  else
  {
    do
    {
      v6 = *(a2 - 3);
      a2 -= 3;
    }
    while (v6 >= v3);
  }
  if (v5 >= (unint64_t)a2)
  {
    v9 = (unint64_t)&a1[v2];
  }
  else
  {
    v8 = *a2;
    v9 = (unint64_t)&a1[v2];
    v10 = a2;
    do
    {
      *(_QWORD *)v9 = v8;
      *v10 = v4;
      v15 = *(_OWORD *)(v9 + 8);
      *(_OWORD *)(v9 + 8) = *(_OWORD *)(v10 + 1);
      *(_OWORD *)(v10 + 1) = v15;
      do
      {
        v11 = *(_QWORD *)(v9 + 24);
        v9 += 24;
        v4 = v11;
      }
      while (v11 < v3);
      do
      {
        v12 = *(v10 - 3);
        v10 -= 3;
        v8 = v12;
      }
      while (v12 >= v3);
    }
    while (v9 < (unint64_t)v10);
  }
  if ((uint64_t *)(v9 - 24) != a1)
  {
    *a1 = *(_QWORD *)(v9 - 24);
    *(_OWORD *)(a1 + 1) = *(_OWORD *)(v9 - 16);
  }
  *(_QWORD *)(v9 - 24) = v3;
  *(_OWORD *)(v9 - 16) = v14;
  return v9 - 24;
}

BOOL sub_1C546D368(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  _BOOL8 result;
  unint64_t v6;
  unint64_t v7;
  __int128 v8;
  unint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  __int128 v18;

  v4 = 0xAAAAAAAAAAAAAAABLL * ((a2 - a1) >> 3);
  result = 1;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      v6 = *(_QWORD *)(a2 - 24);
      v7 = *(_QWORD *)a1;
      if (v6 < *(_QWORD *)a1)
      {
        *(_QWORD *)a1 = v6;
        *(_QWORD *)(a2 - 24) = v7;
        v8 = *(_OWORD *)(a1 + 8);
        *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 - 16);
        *(_OWORD *)(a2 - 16) = v8;
      }
      return result;
    case 3uLL:
      sub_1C546D0A0((unint64_t *)a1, (unint64_t *)(a1 + 24), (unint64_t *)(a2 - 24));
      return 1;
    case 4uLL:
      sub_1C546D518(a1, a1 + 24, a1 + 48, a2 - 24);
      return 1;
    case 5uLL:
      sub_1C546D5D8(a1, a1 + 24, a1 + 48, a1 + 72, a2 - 24);
      return 1;
    default:
      v9 = (unint64_t *)(a1 + 48);
      sub_1C546D0A0((unint64_t *)a1, (unint64_t *)(a1 + 24), (unint64_t *)(a1 + 48));
      v10 = a1 + 72;
      if (a1 + 72 == a2)
        return 1;
      v11 = 0;
      v12 = 0;
      break;
  }
  while (1)
  {
    v13 = *(_QWORD *)v10;
    if (*(_QWORD *)v10 < *v9)
    {
      v18 = *(_OWORD *)(v10 + 8);
      v14 = *v9;
      v15 = v11;
      while (1)
      {
        v16 = a1 + v15;
        *(_QWORD *)(v16 + 72) = v14;
        *(_OWORD *)(v16 + 80) = *(_OWORD *)(a1 + v15 + 56);
        if (v15 == -48)
          break;
        v14 = *(_QWORD *)(v16 + 24);
        v15 -= 24;
        if (v13 >= v14)
        {
          v17 = (_QWORD *)(a1 + v15 + 72);
          goto LABEL_12;
        }
      }
      v17 = (_QWORD *)a1;
LABEL_12:
      *v17 = v13;
      *(_OWORD *)(v16 + 56) = v18;
      if (++v12 == 8)
        return v10 + 24 == a2;
    }
    v9 = (unint64_t *)v10;
    v11 += 24;
    v10 += 24;
    if (v10 == a2)
      return 1;
  }
}

__n128 sub_1C546D518(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __n128 result;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;

  sub_1C546D0A0((unint64_t *)a1, (unint64_t *)a2, (unint64_t *)a3);
  v9 = *(_QWORD *)a3;
  if (*(_QWORD *)a4 < *(_QWORD *)a3)
  {
    *(_QWORD *)a3 = *(_QWORD *)a4;
    *(_QWORD *)a4 = v9;
    result = *(__n128 *)(a3 + 8);
    *(_OWORD *)(a3 + 8) = *(_OWORD *)(a4 + 8);
    *(__n128 *)(a4 + 8) = result;
    v10 = *(_QWORD *)a2;
    if (*(_QWORD *)a3 < *(_QWORD *)a2)
    {
      *(_QWORD *)a2 = *(_QWORD *)a3;
      *(_QWORD *)a3 = v10;
      result = *(__n128 *)(a2 + 8);
      *(_OWORD *)(a2 + 8) = *(_OWORD *)(a3 + 8);
      *(__n128 *)(a3 + 8) = result;
      v11 = *(_QWORD *)a1;
      if (*(_QWORD *)a2 < *(_QWORD *)a1)
      {
        *(_QWORD *)a1 = *(_QWORD *)a2;
        *(_QWORD *)a2 = v11;
        result = *(__n128 *)(a1 + 8);
        *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
        *(__n128 *)(a2 + 8) = result;
      }
    }
  }
  return result;
}

__n128 sub_1C546D5D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  __n128 result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  result.n128_u64[0] = sub_1C546D518(a1, a2, a3, a4).n128_u64[0];
  v11 = *(_QWORD *)a4;
  if (*(_QWORD *)a5 < *(_QWORD *)a4)
  {
    *(_QWORD *)a4 = *(_QWORD *)a5;
    *(_QWORD *)a5 = v11;
    result = *(__n128 *)(a4 + 8);
    *(_OWORD *)(a4 + 8) = *(_OWORD *)(a5 + 8);
    *(__n128 *)(a5 + 8) = result;
    v12 = *(_QWORD *)a3;
    if (*(_QWORD *)a4 < *(_QWORD *)a3)
    {
      *(_QWORD *)a3 = *(_QWORD *)a4;
      *(_QWORD *)a4 = v12;
      result = *(__n128 *)(a3 + 8);
      *(_OWORD *)(a3 + 8) = *(_OWORD *)(a4 + 8);
      *(__n128 *)(a4 + 8) = result;
      v13 = *(_QWORD *)a2;
      if (*(_QWORD *)a3 < *(_QWORD *)a2)
      {
        *(_QWORD *)a2 = *(_QWORD *)a3;
        *(_QWORD *)a3 = v13;
        result = *(__n128 *)(a2 + 8);
        *(_OWORD *)(a2 + 8) = *(_OWORD *)(a3 + 8);
        *(__n128 *)(a3 + 8) = result;
        v14 = *(_QWORD *)a1;
        if (*(_QWORD *)a2 < *(_QWORD *)a1)
        {
          *(_QWORD *)a1 = *(_QWORD *)a2;
          *(_QWORD *)a2 = v14;
          result = *(__n128 *)(a1 + 8);
          *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
          *(__n128 *)(a2 + 8) = result;
        }
      }
    }
  }
  return result;
}

uint64_t *sub_1C546D6D0(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *v6;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t *v12;
  uint64_t *v13;
  _OWORD *v14;
  uint64_t *v15;
  unint64_t v16;
  __int128 v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  _OWORD *v25;
  __int128 v28;

  if ((uint64_t *)a1 != a2)
  {
    v6 = a2;
    v8 = (uint64_t)a2 - a1;
    v9 = ((uint64_t)a2 - a1) / 24;
    if ((uint64_t)a2 - a1 >= 25)
    {
      v10 = (unint64_t)(v9 - 2) >> 1;
      v11 = v10 + 1;
      v12 = (unint64_t *)(a1 + 24 * v10);
      do
      {
        sub_1C546D8E4(a1, a4, v9, v12);
        v12 -= 3;
        --v11;
      }
      while (v11);
    }
    v13 = v6;
    if (v6 != a3)
    {
      v14 = (_OWORD *)(a1 + 8);
      v15 = v6;
      do
      {
        v16 = *v15;
        if ((unint64_t)*v15 < *(_QWORD *)a1)
        {
          *v15 = *(_QWORD *)a1;
          *(_QWORD *)a1 = v16;
          v17 = *(_OWORD *)(v15 + 1);
          *(_OWORD *)(v15 + 1) = *v14;
          *v14 = v17;
          sub_1C546D8E4(a1, a4, v9, (unint64_t *)a1);
        }
        v15 += 3;
      }
      while (v15 != a3);
      v13 = a3;
    }
    if (v8 >= 25)
    {
      do
      {
        v18 = 0;
        v19 = *(_QWORD *)a1;
        v28 = *(_OWORD *)(a1 + 8);
        v20 = a1;
        do
        {
          v21 = v20 + 24 * v18 + 24;
          v22 = (2 * v18) | 1;
          v18 = 2 * v18 + 2;
          if (v18 >= v9)
          {
            v23 = *(_QWORD *)v21;
            v18 = v22;
          }
          else
          {
            v23 = *(_QWORD *)v21;
            v24 = *(_QWORD *)(v21 + 24);
            if (*(_QWORD *)v21 <= v24)
              v23 = *(_QWORD *)(v21 + 24);
            if (*(_QWORD *)v21 >= v24)
              v18 = v22;
            else
              v21 += 24;
          }
          *(_QWORD *)v20 = v23;
          *(_OWORD *)(v20 + 8) = *(_OWORD *)(v21 + 8);
          v20 = v21;
        }
        while (v18 <= (uint64_t)((unint64_t)(v9 - 2) >> 1));
        v25 = (_OWORD *)(v21 + 8);
        if ((uint64_t *)v21 == v6 - 3)
        {
          *(_QWORD *)v21 = v19;
          *v25 = v28;
        }
        else
        {
          *(_QWORD *)v21 = *(v6 - 3);
          *v25 = *((_OWORD *)v6 - 1);
          *(v6 - 3) = v19;
          *((_OWORD *)v6 - 1) = v28;
          sub_1C546D9EC(a1, v21 + 24, a4, 0xAAAAAAAAAAAAAAABLL * ((v21 + 24 - a1) >> 3));
        }
        v6 -= 3;
      }
      while (v9-- > 2);
    }
    return v13;
  }
  return a3;
}

__n128 sub_1C546D8E4(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  int64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  __n128 result;
  __n128 v14;

  if (a3 >= 2)
  {
    v4 = (unint64_t)(a3 - 2) >> 1;
    if (v4 >= (uint64_t)(0xAAAAAAAAAAAAAAABLL * (((uint64_t)a4 - a1) >> 3)))
    {
      v5 = (0x5555555555555556 * (((uint64_t)a4 - a1) >> 3)) | 1;
      v6 = (unint64_t *)(a1 + 24 * v5);
      if (0x5555555555555556 * (((uint64_t)a4 - a1) >> 3) + 2 >= a3)
      {
        v7 = *v6;
      }
      else
      {
        v7 = *v6;
        v8 = v6[3];
        if (*v6 <= v8)
          v7 = v6[3];
        if (*v6 < v8)
        {
          v6 += 3;
          v5 = 0x5555555555555556 * (((uint64_t)a4 - a1) >> 3) + 2;
        }
      }
      v9 = *a4;
      if (v7 >= *a4)
      {
        v14 = *(__n128 *)(a4 + 1);
        do
        {
          v10 = a4;
          a4 = v6;
          *v10 = v7;
          *(_OWORD *)(v10 + 1) = *(_OWORD *)(v6 + 1);
          if (v4 < v5)
            break;
          v11 = (2 * v5) | 1;
          v6 = (unint64_t *)(a1 + 24 * v11);
          v5 = 2 * v5 + 2;
          if (v5 >= a3)
          {
            v7 = *v6;
            v5 = v11;
          }
          else
          {
            v7 = *v6;
            v12 = v6[3];
            if (*v6 <= v12)
              v7 = v6[3];
            if (*v6 >= v12)
              v5 = v11;
            else
              v6 += 3;
          }
        }
        while (v7 >= v9);
        *a4 = v9;
        result = v14;
        *(__n128 *)(a4 + 1) = v14;
      }
    }
  }
  return result;
}

__n128 sub_1C546D9EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t *v9;
  __n128 result;
  __n128 v11;

  if (a4 >= 2)
  {
    v4 = (unint64_t)(a4 - 2) >> 1;
    v5 = (unint64_t *)(a1 + 24 * v4);
    v7 = (unint64_t *)(a2 - 24);
    v6 = *(_QWORD *)(a2 - 24);
    v8 = *v5;
    if (*v5 < v6)
    {
      v11 = *(__n128 *)(a2 - 16);
      do
      {
        v9 = v7;
        v7 = v5;
        *v9 = v8;
        *(_OWORD *)(v9 + 1) = *(_OWORD *)(v5 + 1);
        if (!v4)
          break;
        v4 = (v4 - 1) >> 1;
        v5 = (unint64_t *)(a1 + 24 * v4);
        v8 = *v5;
      }
      while (*v5 < v6);
      *v7 = v6;
      result = v11;
      *(__n128 *)(v7 + 1) = v11;
    }
  }
  return result;
}

uint64_t sub_1C546DA6C(uint64_t result, unint64_t *a2, uint64_t a3, uint64_t a4, char a5)
{
  unint64_t *v8;
  unint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t *v19;
  char v20;
  BOOL v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t *v26;
  BOOL v28;
  uint64_t v29;
  unint64_t *v30;
  unint64_t *v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  unint64_t *v38;
  unint64_t *v39;
  unint64_t *v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t *v44;
  unint64_t *v45;
  unint64_t v46;

  v8 = (unint64_t *)result;
LABEL_2:
  v9 = v8;
LABEL_3:
  v10 = 1 - a4;
  while (2)
  {
    v8 = v9;
    v11 = v10;
    v12 = (char *)a2 - (char *)v9;
    v13 = ((char *)a2 - (char *)v9) >> 4;
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        v22 = *(a2 - 2);
        v23 = *v9;
        if (v22 < *v9)
        {
          v24 = v9[1];
          v25 = *(a2 - 1);
          *v9 = v22;
          v9[1] = v25;
          *(a2 - 2) = v23;
          *(a2 - 1) = v24;
        }
        return result;
      case 3uLL:
        return sub_1C546DE3C(v9, v9 + 2, a2 - 2);
      case 4uLL:
        return sub_1C546E1E8(v9, v9 + 2, v9 + 4, a2 - 2);
      case 5uLL:
        return sub_1C546E288(v9, v9 + 2, v9 + 4, v9 + 6, a2 - 2);
      default:
        if (v12 > 383)
        {
          if (v11 == 1)
          {
            if (v9 != a2)
              return (uint64_t)sub_1C546E358(v9, a2, a2, a3);
            return result;
          }
          v14 = v13 >> 1;
          v15 = &v9[2 * (v13 >> 1)];
          if ((unint64_t)v12 < 0x801)
          {
            sub_1C546DE3C(&v9[2 * (v13 >> 1)], v9, a2 - 2);
            if ((a5 & 1) != 0)
              goto LABEL_12;
          }
          else
          {
            sub_1C546DE3C(v9, &v9[2 * (v13 >> 1)], a2 - 2);
            sub_1C546DE3C(v9 + 2, v15 - 2, a2 - 4);
            sub_1C546DE3C(v9 + 4, &v9[2 * v14 + 2], a2 - 6);
            sub_1C546DE3C(v15 - 2, v15, &v9[2 * v14 + 2]);
            v16 = *v9;
            v17 = v9[1];
            v18 = v15[1];
            *v9 = *v15;
            v9[1] = v18;
            *v15 = v16;
            v15[1] = v17;
            if ((a5 & 1) != 0)
              goto LABEL_12;
          }
          if (*(v9 - 2) >= *v9)
          {
            result = (uint64_t)sub_1C546DEEC(v9, (uint64_t *)a2);
            v9 = (unint64_t *)result;
            goto LABEL_17;
          }
LABEL_12:
          v19 = sub_1C546DFA8(v9, a2);
          if ((v20 & 1) == 0)
            goto LABEL_15;
          v21 = sub_1C546E068(v9, v19);
          v9 = v19 + 2;
          result = sub_1C546E068(v19 + 2, a2);
          if (!(_DWORD)result)
          {
            v10 = v11 + 1;
            if (v21)
              continue;
LABEL_15:
            result = sub_1C546DA6C(v8, v19, a3, -v11, a5 & 1);
            v9 = v19 + 2;
LABEL_17:
            a5 = 0;
            a4 = -v11;
            goto LABEL_3;
          }
          a4 = -v11;
          a2 = v19;
          if (v21)
            return result;
          goto LABEL_2;
        }
        v26 = v9 + 2;
        v28 = v9 == a2 || v26 == a2;
        if ((a5 & 1) != 0)
        {
          if (!v28)
          {
            v29 = 0;
            v30 = v9;
            do
            {
              v31 = v26;
              v32 = v30[2];
              v33 = *v30;
              if (v32 < *v30)
              {
                v34 = v30[3];
                v35 = v29;
                while (1)
                {
                  v36 = (char *)v9 + v35;
                  v37 = *(unint64_t *)((char *)v9 + v35 + 8);
                  *((_QWORD *)v36 + 2) = v33;
                  *((_QWORD *)v36 + 3) = v37;
                  if (!v35)
                    break;
                  v33 = *((_QWORD *)v36 - 2);
                  v35 -= 16;
                  if (v32 >= v33)
                  {
                    v38 = (unint64_t *)((char *)v9 + v35 + 16);
                    goto LABEL_42;
                  }
                }
                v38 = v9;
LABEL_42:
                *v38 = v32;
                v38[1] = v34;
              }
              v26 = v31 + 2;
              v29 += 16;
              v30 = v31;
            }
            while (v31 + 2 != a2);
          }
        }
        else if (!v28)
        {
          v39 = v9 + 3;
          do
          {
            v40 = v26;
            v41 = v8[2];
            v42 = *v8;
            if (v41 < *v8)
            {
              v43 = v8[3];
              v44 = v39;
              do
              {
                v45 = v44;
                *(v44 - 1) = v42;
                v46 = *(v44 - 2);
                v44 -= 2;
                *v45 = v46;
                v42 = *(v45 - 5);
              }
              while (v41 < v42);
              *(v44 - 1) = v41;
              *v44 = v43;
            }
            v26 = v40 + 2;
            v39 += 2;
            v8 = v40;
          }
          while (v40 + 2 != a2);
        }
        return result;
    }
  }
}

uint64_t sub_1C546DE3C(unint64_t *a1, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;

  v3 = *a2;
  v4 = *a1;
  v5 = *a3;
  if (*a2 < *a1)
  {
    if (v5 < v3)
    {
      v6 = a1[1];
      v7 = a3[1];
      *a1 = v5;
      a1[1] = v7;
      *a3 = v4;
      a3[1] = v6;
      return 1;
    }
    v13 = a1[1];
    v14 = a2[1];
    *a1 = v3;
    a1[1] = v14;
    *a2 = v4;
    a2[1] = v13;
    if (*a3 >= v4)
      return 1;
    v15 = a3[1];
    *a2 = *a3;
    a2[1] = v15;
    *a3 = v4;
    a3[1] = v13;
    return 2;
  }
  if (v5 < v3)
  {
    *a2 = v5;
    *a3 = v3;
    v8 = *a2;
    v9 = a2[1];
    a2[1] = a3[1];
    a3[1] = v9;
    v10 = *a1;
    if (v8 >= *a1)
      return 1;
    v11 = a1[1];
    v12 = a2[1];
    *a1 = v8;
    a1[1] = v12;
    *a2 = v10;
    a2[1] = v11;
    return 2;
  }
  return 0;
}

unint64_t *sub_1C546DEEC(unint64_t *a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;

  v2 = *a1;
  if (*a1 >= *(a2 - 2))
  {
    v5 = (uint64_t *)(a1 + 2);
    do
    {
      v3 = (unint64_t *)v5;
      if (v5 >= a2)
        break;
      v5 += 2;
    }
    while (v2 >= *v3);
  }
  else
  {
    v3 = a1;
    do
    {
      v4 = v3[2];
      v3 += 2;
    }
    while (v2 >= v4);
  }
  if (v3 < (unint64_t *)a2)
  {
    do
    {
      v6 = *(a2 - 2);
      a2 -= 2;
    }
    while (v2 < v6);
  }
  v7 = a1[1];
  if (v3 < (unint64_t *)a2)
  {
    v8 = *v3;
    v9 = *a2;
    do
    {
      v10 = v3[1];
      v11 = a2[1];
      *v3 = v9;
      v3[1] = v11;
      *a2 = v8;
      a2[1] = v10;
      do
      {
        v12 = v3[2];
        v3 += 2;
        v8 = v12;
      }
      while (v2 >= v12);
      do
      {
        v13 = *(a2 - 2);
        a2 -= 2;
        v9 = v13;
      }
      while (v2 < v13);
    }
    while (v3 < (unint64_t *)a2);
  }
  if (v3 - 2 != a1)
  {
    v14 = *(v3 - 1);
    *a1 = *(v3 - 2);
    a1[1] = v14;
  }
  *(v3 - 2) = v2;
  *(v3 - 1) = v7;
  return v3;
}

unint64_t *sub_1C546DFA8(unint64_t *a1, unint64_t *a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;

  v2 = 0;
  v3 = *a1;
  v4 = a1[1];
  do
  {
    v5 = a1[v2 + 2];
    v2 += 2;
  }
  while (v5 < v3);
  v6 = &a1[v2];
  if (v2 == 2)
  {
    do
    {
      if (v6 >= a2)
        break;
      v8 = *(a2 - 2);
      a2 -= 2;
    }
    while (v8 >= v3);
  }
  else
  {
    do
    {
      v7 = *(a2 - 2);
      a2 -= 2;
    }
    while (v7 >= v3);
  }
  if (v6 >= a2)
  {
    v10 = &a1[v2];
  }
  else
  {
    v9 = *a2;
    v10 = &a1[v2];
    v11 = a2;
    do
    {
      v12 = v10[1];
      v13 = v11[1];
      *v10 = v9;
      v10[1] = v13;
      *v11 = v5;
      v11[1] = v12;
      do
      {
        v14 = v10[2];
        v10 += 2;
        v5 = v14;
      }
      while (v14 < v3);
      do
      {
        v15 = *(v11 - 2);
        v11 -= 2;
        v9 = v15;
      }
      while (v15 >= v3);
    }
    while (v10 < v11);
  }
  if (v10 - 2 != a1)
  {
    v16 = *(v10 - 1);
    *a1 = *(v10 - 2);
    a1[1] = v16;
  }
  *(v10 - 2) = v3;
  *(v10 - 1) = v4;
  return v10 - 2;
}

BOOL sub_1C546E068(unint64_t *a1, unint64_t *a2)
{
  uint64_t v4;
  _BOOL8 result;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t *v11;
  uint64_t v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t *v20;

  v4 = ((char *)a2 - (char *)a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = *(a2 - 2);
      v7 = *a1;
      if (v6 < *a1)
      {
        v8 = a1[1];
        v9 = *(a2 - 1);
        *a1 = v6;
        a1[1] = v9;
        *(a2 - 2) = v7;
        *(a2 - 1) = v8;
      }
      return result;
    case 3:
      sub_1C546DE3C(a1, a1 + 2, a2 - 2);
      return 1;
    case 4:
      sub_1C546E1E8(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1;
    case 5:
      sub_1C546E288(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2);
      return 1;
    default:
      v10 = a1 + 4;
      sub_1C546DE3C(a1, a1 + 2, a1 + 4);
      v11 = a1 + 6;
      if (a1 + 6 == a2)
        return 1;
      v12 = 0;
      v13 = 0;
      break;
  }
  while (1)
  {
    v14 = *v11;
    v15 = *v10;
    if (*v11 < *v10)
    {
      v16 = v11[1];
      v17 = v12;
      while (1)
      {
        v18 = (unint64_t *)((char *)a1 + v17);
        v19 = *(unint64_t *)((char *)a1 + v17 + 40);
        v18[6] = v15;
        v18[7] = v19;
        if (v17 == -32)
          break;
        v15 = v18[2];
        v17 -= 16;
        if (v14 >= v15)
        {
          v20 = (unint64_t *)((char *)a1 + v17 + 48);
          goto LABEL_12;
        }
      }
      v20 = a1;
LABEL_12:
      *v20 = v14;
      v20[1] = v16;
      if (++v13 == 8)
        return v11 + 2 == a2;
    }
    v10 = v11;
    v12 += 16;
    v11 += 2;
    if (v11 == a2)
      return 1;
  }
}

uint64_t sub_1C546E1E8(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  uint64_t result;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;

  result = sub_1C546DE3C(a1, a2, a3);
  v9 = *a3;
  if (*a4 < *a3)
  {
    *a3 = *a4;
    *a4 = v9;
    v10 = *a3;
    v11 = a3[1];
    a3[1] = a4[1];
    a4[1] = v11;
    v12 = *a2;
    if (v10 < *a2)
    {
      *a2 = v10;
      *a3 = v12;
      v13 = *a2;
      v14 = a2[1];
      a2[1] = a3[1];
      a3[1] = v14;
      v15 = *a1;
      if (v13 < *a1)
      {
        v16 = a1[1];
        v17 = a2[1];
        *a1 = v13;
        a1[1] = v17;
        *a2 = v15;
        a2[1] = v16;
      }
    }
  }
  return result;
}

uint64_t sub_1C546E288(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  uint64_t result;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;

  result = sub_1C546E1E8(a1, a2, a3, a4);
  v11 = *a4;
  if (*a5 < *a4)
  {
    *a4 = *a5;
    *a5 = v11;
    v12 = *a4;
    v13 = a4[1];
    a4[1] = a5[1];
    a5[1] = v13;
    v14 = *a3;
    if (v12 < *a3)
    {
      *a3 = v12;
      *a4 = v14;
      v15 = *a3;
      v16 = a3[1];
      a3[1] = a4[1];
      a4[1] = v16;
      v17 = *a2;
      if (v15 < *a2)
      {
        *a2 = v15;
        *a3 = v17;
        v18 = *a2;
        v19 = a2[1];
        a2[1] = a3[1];
        a3[1] = v19;
        v20 = *a1;
        if (v18 < *a1)
        {
          v21 = a1[1];
          v22 = a2[1];
          *a1 = v18;
          a1[1] = v22;
          *a2 = v20;
          a2[1] = v21;
        }
      }
    }
  }
  return result;
}

unint64_t *sub_1C546E358(unint64_t *a1, unint64_t *a2, unint64_t *a3, uint64_t a4)
{
  unint64_t *v6;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t *v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t *v21;
  unint64_t *v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t *v34;
  unint64_t v35;

  if (a1 != a2)
  {
    v6 = a2;
    v8 = (char *)a2 - (char *)a1;
    v9 = ((char *)a2 - (char *)a1) >> 4;
    if ((char *)a2 - (char *)a1 >= 17)
    {
      v10 = (unint64_t)(v9 - 2) >> 1;
      v11 = v10 + 1;
      v12 = &a1[2 * v10];
      do
      {
        sub_1C546E54C((uint64_t)a1, a4, v9, v12);
        v12 -= 2;
        --v11;
      }
      while (v11);
    }
    v13 = v6;
    if (v6 != a3)
    {
      v14 = v6;
      do
      {
        v15 = *v14;
        if (*v14 < *a1)
        {
          v16 = v14[1];
          v17 = a1[1];
          *v14 = *a1;
          v14[1] = v17;
          *a1 = v15;
          a1[1] = v16;
          sub_1C546E54C((uint64_t)a1, a4, v9, a1);
        }
        v14 += 2;
      }
      while (v14 != a3);
      v13 = a3;
    }
    if (v8 >= 17)
    {
      do
      {
        v18 = 0;
        v19 = *a1;
        v20 = a1[1];
        v21 = a1;
        do
        {
          v22 = &v21[2 * v18 + 2];
          v23 = (2 * v18) | 1;
          v18 = 2 * v18 + 2;
          if (v18 >= v9)
          {
            v24 = *v22;
            v18 = v23;
          }
          else
          {
            v24 = *v22;
            v25 = v22[2];
            if (*v22 <= v25)
              v24 = v22[2];
            if (*v22 >= v25)
              v18 = v23;
            else
              v22 += 2;
          }
          v26 = v22[1];
          *v21 = v24;
          v21[1] = v26;
          v21 = v22;
        }
        while (v18 <= (uint64_t)((unint64_t)(v9 - 2) >> 1));
        if (v22 == v6 - 2)
        {
          *v22 = v19;
          v22[1] = v20;
        }
        else
        {
          v27 = *(v6 - 1);
          *v22 = *(v6 - 2);
          v22[1] = v27;
          *(v6 - 2) = v19;
          *(v6 - 1) = v20;
          v28 = (char *)v22 - (char *)a1 + 16;
          if (v28 >= 17)
          {
            v29 = (((unint64_t)v28 >> 4) - 2) >> 1;
            v30 = &a1[2 * v29];
            v31 = *v30;
            v32 = *v22;
            if (*v30 < *v22)
            {
              v33 = v22[1];
              do
              {
                v34 = v22;
                v22 = v30;
                v35 = v30[1];
                *v34 = v31;
                v34[1] = v35;
                if (!v29)
                  break;
                v29 = (v29 - 1) >> 1;
                v30 = &a1[2 * v29];
                v31 = *v30;
              }
              while (*v30 < v32);
              *v22 = v32;
              v22[1] = v33;
            }
          }
        }
        v6 -= 2;
      }
      while (v9-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t sub_1C546E54C(uint64_t result, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  uint64_t v4;
  int64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  uint64_t v9;
  unint64_t v10;
  BOOL v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;

  if (a3 >= 2)
  {
    v4 = (uint64_t)a4 - result;
    v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 4)
    {
      v6 = v4 >> 3;
      v7 = (v4 >> 3) + 1;
      v8 = (unint64_t *)(result + 16 * v7);
      v9 = v6 + 2;
      if (v9 >= a3)
      {
        v10 = *v8;
      }
      else
      {
        v10 = v8[2];
        v11 = *v8 >= v10;
        if (*v8 > v10)
          v10 = *v8;
        if (!v11)
        {
          v8 += 2;
          v7 = v9;
        }
      }
      v12 = *a4;
      if (v10 >= *a4)
      {
        v13 = a4[1];
        do
        {
          v14 = a4;
          a4 = v8;
          v15 = v8[1];
          *v14 = v10;
          v14[1] = v15;
          if (v5 < v7)
            break;
          v16 = (2 * v7) | 1;
          v8 = (unint64_t *)(result + 16 * v16);
          v7 = 2 * v7 + 2;
          if (v7 >= a3)
          {
            v10 = *v8;
            v7 = v16;
          }
          else
          {
            v10 = *v8;
            v17 = v8[2];
            if (*v8 <= v17)
              v10 = v8[2];
            if (*v8 >= v17)
              v7 = v16;
            else
              v8 += 2;
          }
        }
        while (v10 >= v12);
        *a4 = v12;
        a4[1] = v13;
      }
    }
  }
  return result;
}

uint64_t sub_1C546E61C(uint64_t result, unint64_t *a2, uint64_t a3, uint64_t a4, char a5)
{
  unint64_t *v8;
  unint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t *v15;
  __int128 v16;
  unint64_t *v17;
  char v18;
  BOOL v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t *v23;
  BOOL v25;
  uint64_t v26;
  unint64_t *v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  unint64_t *v35;
  unint64_t *v36;
  unint64_t *v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t *v41;
  unint64_t *v42;
  unint64_t v43;

  v8 = (unint64_t *)result;
LABEL_2:
  v9 = v8;
LABEL_3:
  v10 = 1 - a4;
  while (2)
  {
    v8 = v9;
    v11 = v10;
    v12 = (char *)a2 - (char *)v9;
    v13 = ((char *)a2 - (char *)v9) >> 4;
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        v20 = *(a2 - 2);
        v21 = *v9;
        if (v20 < *v9)
        {
          *v9 = v20;
          *(a2 - 2) = v21;
          v22 = v9[1];
          v9[1] = *(a2 - 1);
          *(a2 - 1) = v22;
        }
        return result;
      case 3uLL:
        return sub_1C546E9F4((uint64_t *)v9, v9 + 2, a2 - 2);
      case 4uLL:
        return sub_1C546EDF4((uint64_t *)v9, v9 + 2, v9 + 4, a2 - 2);
      case 5uLL:
        return sub_1C546EEA4((uint64_t *)v9, v9 + 2, v9 + 4, v9 + 6, a2 - 2);
      default:
        if (v12 > 383)
        {
          if (v11 == 1)
          {
            if (v9 != a2)
              return (uint64_t)sub_1C546EF88(v9, a2, a2, a3);
            return result;
          }
          v14 = v13 >> 1;
          v15 = &v9[2 * (v13 >> 1)];
          if ((unint64_t)v12 < 0x801)
          {
            sub_1C546E9F4((uint64_t *)&v9[2 * (v13 >> 1)], v9, a2 - 2);
            if ((a5 & 1) != 0)
              goto LABEL_12;
          }
          else
          {
            sub_1C546E9F4((uint64_t *)v9, &v9[2 * (v13 >> 1)], a2 - 2);
            sub_1C546E9F4((uint64_t *)v9 + 2, v15 - 2, a2 - 4);
            sub_1C546E9F4((uint64_t *)v9 + 4, &v9[2 * v14 + 2], a2 - 6);
            sub_1C546E9F4((uint64_t *)v15 - 2, v15, &v9[2 * v14 + 2]);
            v16 = *(_OWORD *)v9;
            *(_OWORD *)v9 = *(_OWORD *)v15;
            *(_OWORD *)v15 = v16;
            if ((a5 & 1) != 0)
              goto LABEL_12;
          }
          if (*(v9 - 2) >= *v9)
          {
            result = (uint64_t)sub_1C546EACC(v9, (uint64_t *)a2);
            v9 = (unint64_t *)result;
            goto LABEL_17;
          }
LABEL_12:
          v17 = sub_1C546EB98(v9, a2);
          if ((v18 & 1) == 0)
            goto LABEL_15;
          v19 = sub_1C546EC6C(v9, (char *)v17);
          v9 = v17 + 2;
          result = sub_1C546EC6C(v17 + 2, (char *)a2);
          if (!(_DWORD)result)
          {
            v10 = v11 + 1;
            if (v19)
              continue;
LABEL_15:
            result = sub_1C546E61C(v8, v17, a3, -v11, a5 & 1);
            v9 = v17 + 2;
LABEL_17:
            a5 = 0;
            a4 = -v11;
            goto LABEL_3;
          }
          a4 = -v11;
          a2 = v17;
          if (v19)
            return result;
          goto LABEL_2;
        }
        v23 = v9 + 2;
        v25 = v9 == a2 || v23 == a2;
        if ((a5 & 1) != 0)
        {
          if (!v25)
          {
            v26 = 0;
            v27 = v9;
            do
            {
              v28 = v23;
              v29 = v27[2];
              v30 = *v27;
              if (v29 < *v27)
              {
                v31 = v27[3];
                v32 = v26;
                while (1)
                {
                  v33 = (char *)v9 + v32;
                  v34 = *(unint64_t *)((char *)v9 + v32 + 8);
                  *((_QWORD *)v33 + 2) = v30;
                  *((_QWORD *)v33 + 3) = v34;
                  if (!v32)
                    break;
                  v30 = *((_QWORD *)v33 - 2);
                  v32 -= 16;
                  if (v29 >= v30)
                  {
                    v35 = (unint64_t *)((char *)v9 + v32 + 16);
                    goto LABEL_42;
                  }
                }
                v35 = v9;
LABEL_42:
                *v35 = v29;
                v35[1] = v31;
              }
              v23 = v28 + 2;
              v26 += 16;
              v27 = v28;
            }
            while (v28 + 2 != a2);
          }
        }
        else if (!v25)
        {
          v36 = v9 + 3;
          do
          {
            v37 = v23;
            v38 = v8[2];
            v39 = *v8;
            if (v38 < *v8)
            {
              v40 = v8[3];
              v41 = v36;
              do
              {
                v42 = v41;
                *(v41 - 1) = v39;
                v43 = *(v41 - 2);
                v41 -= 2;
                *v42 = v43;
                v39 = *(v42 - 5);
              }
              while (v38 < v39);
              *(v41 - 1) = v38;
              *v41 = v40;
            }
            v23 = v37 + 2;
            v36 += 2;
            v8 = v37;
          }
          while (v37 + 2 != a2);
        }
        return result;
    }
  }
}

uint64_t sub_1C546E9F4(uint64_t *a1, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;

  v3 = *a2;
  v4 = *a1;
  v5 = *a3;
  if (*a2 < *a1)
  {
    if (v5 < v3)
    {
      *a1 = v5;
      v6 = a1 + 1;
      *a3 = v4;
      v7 = (uint64_t *)(a3 + 1);
      v8 = 1;
LABEL_9:
      v10 = v7;
      goto LABEL_10;
    }
    *a1 = v3;
    *a2 = v4;
    v12 = a1[1];
    a1[1] = a2[1];
    a2[1] = v12;
    v13 = *a2;
    if (*a3 < *a2)
    {
      *a2 = *a3;
      *a3 = v13;
      v7 = (uint64_t *)(a3 + 1);
      v8 = 2;
      v6 = (uint64_t *)(a2 + 1);
      goto LABEL_9;
    }
    return 1;
  }
  if (v5 >= v3)
    return 0;
  *a2 = v5;
  *a3 = v3;
  v10 = (uint64_t *)(a2 + 1);
  v9 = a2[1];
  a2[1] = a3[1];
  a3[1] = v9;
  v11 = *a1;
  if (*a2 >= *a1)
    return 1;
  *a1 = *a2;
  v6 = a1 + 1;
  *a2 = v11;
  v8 = 2;
LABEL_10:
  v14 = *v6;
  *v6 = *v10;
  *v10 = v14;
  return v8;
}

unint64_t *sub_1C546EACC(unint64_t *a1, uint64_t *a2)
{
  __int128 v2;
  unint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  uint64_t *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;

  v2 = *(_OWORD *)a1;
  v3 = *a1;
  if (*a1 >= *(a2 - 2))
  {
    v6 = (uint64_t *)(a1 + 2);
    do
    {
      v4 = (unint64_t *)v6;
      if (v6 >= a2)
        break;
      v6 += 2;
    }
    while (v3 >= *v4);
  }
  else
  {
    v4 = a1;
    do
    {
      v5 = v4[2];
      v4 += 2;
    }
    while (v3 >= v5);
  }
  if (v4 < (unint64_t *)a2)
  {
    do
    {
      v7 = *(a2 - 2);
      a2 -= 2;
    }
    while (v3 < v7);
  }
  if (v4 < (unint64_t *)a2)
  {
    v8 = *v4;
    v9 = *a2;
    do
    {
      *v4 = v9;
      *a2 = v8;
      v10 = v4[1];
      v4[1] = a2[1];
      a2[1] = v10;
      do
      {
        v11 = v4[2];
        v4 += 2;
        v8 = v11;
      }
      while (v3 >= v11);
      do
      {
        v12 = *(a2 - 2);
        a2 -= 2;
        v9 = v12;
      }
      while (v3 < v12);
    }
    while (v4 < (unint64_t *)a2);
  }
  if (v4 - 2 != a1)
  {
    *a1 = *(v4 - 2);
    a1[1] = *(v4 - 1);
  }
  *((_OWORD *)v4 - 1) = v2;
  return v4;
}

unint64_t *sub_1C546EB98(unint64_t *a1, unint64_t *a2)
{
  uint64_t v2;
  __int128 v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;

  v2 = 0;
  v3 = *(_OWORD *)a1;
  v4 = *a1;
  do
  {
    v5 = a1[v2 + 2];
    v2 += 2;
  }
  while (v5 < v4);
  v6 = (unint64_t)&a1[v2];
  if (v2 == 2)
  {
    do
    {
      if (v6 >= (unint64_t)a2)
        break;
      v8 = *(a2 - 2);
      a2 -= 2;
    }
    while (v8 >= v4);
  }
  else
  {
    do
    {
      v7 = *(a2 - 2);
      a2 -= 2;
    }
    while (v7 >= v4);
  }
  if (v6 >= (unint64_t)a2)
  {
    v10 = &a1[v2];
  }
  else
  {
    v9 = *a2;
    v10 = &a1[v2];
    v11 = a2;
    do
    {
      *v10 = v9;
      *v11 = v5;
      v12 = v10[1];
      v10[1] = v11[1];
      v11[1] = v12;
      do
      {
        v13 = v10[2];
        v10 += 2;
        v5 = v13;
      }
      while (v13 < v4);
      do
      {
        v14 = *(v11 - 2);
        v11 -= 2;
        v9 = v14;
      }
      while (v14 >= v4);
    }
    while (v10 < v11);
  }
  if (v10 - 2 != a1)
  {
    *a1 = *(v10 - 2);
    a1[1] = *(v10 - 1);
  }
  *((_OWORD *)v10 - 1) = v3;
  return v10 - 2;
}

BOOL sub_1C546EC6C(unint64_t *a1, char *a2)
{
  uint64_t v4;
  _BOOL8 result;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  char *v9;
  char *v10;
  uint64_t v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  unint64_t *v19;

  v4 = (a2 - (char *)a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = *((_QWORD *)a2 - 2);
      v7 = *a1;
      if (v6 < *a1)
      {
        *a1 = v6;
        *((_QWORD *)a2 - 2) = v7;
        v8 = a1[1];
        a1[1] = *((_QWORD *)a2 - 1);
        *((_QWORD *)a2 - 1) = v8;
      }
      return result;
    case 3:
      sub_1C546E9F4((uint64_t *)a1, a1 + 2, (unint64_t *)a2 - 2);
      return 1;
    case 4:
      sub_1C546EDF4((uint64_t *)a1, a1 + 2, a1 + 4, (unint64_t *)a2 - 2);
      return 1;
    case 5:
      sub_1C546EEA4((uint64_t *)a1, a1 + 2, a1 + 4, a1 + 6, (unint64_t *)a2 - 2);
      return 1;
    default:
      v9 = (char *)(a1 + 4);
      sub_1C546E9F4((uint64_t *)a1, a1 + 2, a1 + 4);
      v10 = (char *)(a1 + 6);
      if (a1 + 6 == (unint64_t *)a2)
        return 1;
      v11 = 0;
      v12 = 0;
      break;
  }
  while (1)
  {
    v13 = *(_QWORD *)v10;
    v14 = *(_QWORD *)v9;
    if (*(_QWORD *)v10 < *(_QWORD *)v9)
    {
      v15 = *((_QWORD *)v10 + 1);
      v16 = v11;
      while (1)
      {
        v17 = (unint64_t *)((char *)a1 + v16);
        v18 = *(unint64_t *)((char *)a1 + v16 + 40);
        v17[6] = v14;
        v17[7] = v18;
        if (v16 == -32)
          break;
        v14 = v17[2];
        v16 -= 16;
        if (v13 >= v14)
        {
          v19 = (unint64_t *)((char *)a1 + v16 + 48);
          goto LABEL_12;
        }
      }
      v19 = a1;
LABEL_12:
      *v19 = v13;
      v19[1] = v15;
      if (++v12 == 8)
        return v10 + 16 == a2;
    }
    v9 = v10;
    v11 += 16;
    v10 += 16;
    if (v10 == a2)
      return 1;
  }
}

uint64_t sub_1C546EDF4(uint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  uint64_t result;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;

  result = sub_1C546E9F4(a1, a2, a3);
  v9 = *a3;
  if (*a4 < *a3)
  {
    *a3 = *a4;
    *a4 = v9;
    v10 = a3[1];
    a3[1] = a4[1];
    a4[1] = v10;
    v11 = *a2;
    if (*a3 < *a2)
    {
      *a2 = *a3;
      *a3 = v11;
      v12 = a2[1];
      a2[1] = a3[1];
      a3[1] = v12;
      v13 = *a1;
      if (*a2 < *a1)
      {
        *a1 = *a2;
        *a2 = v13;
        v14 = a1[1];
        a1[1] = a2[1];
        a2[1] = v14;
      }
    }
  }
  return result;
}

uint64_t sub_1C546EEA4(uint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  uint64_t result;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;

  result = sub_1C546EDF4(a1, a2, a3, a4);
  v11 = *a4;
  if (*a5 < *a4)
  {
    *a4 = *a5;
    *a5 = v11;
    v12 = a4[1];
    a4[1] = a5[1];
    a5[1] = v12;
    v13 = *a3;
    if (*a4 < *a3)
    {
      *a3 = *a4;
      *a4 = v13;
      v14 = a3[1];
      a3[1] = a4[1];
      a4[1] = v14;
      v15 = *a2;
      if (*a3 < *a2)
      {
        *a2 = *a3;
        *a3 = v15;
        v16 = a2[1];
        a2[1] = a3[1];
        a3[1] = v16;
        v17 = *a1;
        if (*a2 < *a1)
        {
          *a1 = *a2;
          *a2 = v17;
          v18 = a1[1];
          a1[1] = a2[1];
          a2[1] = v18;
        }
      }
    }
  }
  return result;
}

unint64_t *sub_1C546EF88(unint64_t *a1, unint64_t *a2, unint64_t *a3, uint64_t a4)
{
  unint64_t *v6;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t *v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t *v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t *v31;

  if (a1 != a2)
  {
    v6 = a2;
    v8 = (char *)a2 - (char *)a1;
    v9 = ((char *)a2 - (char *)a1) >> 4;
    if ((char *)a2 - (char *)a1 >= 17)
    {
      v10 = (unint64_t)(v9 - 2) >> 1;
      v11 = v10 + 1;
      v12 = &a1[2 * v10];
      do
      {
        sub_1C546F194((uint64_t)a1, a4, v9, v12);
        v12 -= 2;
        --v11;
      }
      while (v11);
    }
    v13 = v6;
    if (v6 != a3)
    {
      v14 = v6;
      do
      {
        v15 = *v14;
        if (*v14 < *a1)
        {
          *v14 = *a1;
          *a1 = v15;
          v16 = v14[1];
          v14[1] = a1[1];
          a1[1] = v16;
          sub_1C546F194((uint64_t)a1, a4, v9, a1);
        }
        v14 += 2;
      }
      while (v14 != a3);
      v13 = a3;
    }
    if (v8 >= 17)
    {
      do
      {
        v17 = 0;
        v18 = *a1;
        v19 = a1[1];
        v20 = a1;
        do
        {
          v21 = &v20[2 * v17 + 2];
          v22 = (2 * v17) | 1;
          v17 = 2 * v17 + 2;
          if (v17 >= v9)
          {
            v23 = *v21;
            v17 = v22;
          }
          else
          {
            v23 = *v21;
            v24 = v21[2];
            if (*v21 <= v24)
              v23 = v21[2];
            if (*v21 >= v24)
              v17 = v22;
            else
              v21 += 2;
          }
          *v20 = v23;
          v20[1] = v21[1];
          v20 = v21;
        }
        while (v17 <= (uint64_t)((unint64_t)(v9 - 2) >> 1));
        if (v21 == v6 - 2)
        {
          *v21 = v18;
          v21[1] = v19;
        }
        else
        {
          *v21 = *(v6 - 2);
          v21[1] = *(v6 - 1);
          *(v6 - 2) = v18;
          *(v6 - 1) = v19;
          v25 = (char *)v21 - (char *)a1 + 16;
          if (v25 >= 17)
          {
            v26 = (((unint64_t)v25 >> 4) - 2) >> 1;
            v27 = &a1[2 * v26];
            v28 = *v27;
            v29 = *v21;
            if (*v27 < *v21)
            {
              v30 = v21[1];
              do
              {
                v31 = v21;
                v21 = v27;
                *v31 = v28;
                v31[1] = v27[1];
                if (!v26)
                  break;
                v26 = (v26 - 1) >> 1;
                v27 = &a1[2 * v26];
                v28 = *v27;
              }
              while (*v27 < v29);
              *v21 = v29;
              v21[1] = v30;
            }
          }
        }
        v6 -= 2;
      }
      while (v9-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t sub_1C546F194(uint64_t result, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  uint64_t v4;
  int64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  uint64_t v9;
  unint64_t v10;
  BOOL v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t *v14;
  uint64_t v15;
  unint64_t v16;

  if (a3 >= 2)
  {
    v4 = (uint64_t)a4 - result;
    v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 4)
    {
      v6 = v4 >> 3;
      v7 = (v4 >> 3) + 1;
      v8 = (unint64_t *)(result + 16 * v7);
      v9 = v6 + 2;
      if (v9 >= a3)
      {
        v10 = *v8;
      }
      else
      {
        v10 = v8[2];
        v11 = *v8 >= v10;
        if (*v8 > v10)
          v10 = *v8;
        if (!v11)
        {
          v8 += 2;
          v7 = v9;
        }
      }
      v12 = *a4;
      if (v10 >= *a4)
      {
        v13 = a4[1];
        do
        {
          v14 = a4;
          a4 = v8;
          *v14 = v10;
          v14[1] = v8[1];
          if (v5 < v7)
            break;
          v15 = (2 * v7) | 1;
          v8 = (unint64_t *)(result + 16 * v15);
          v7 = 2 * v7 + 2;
          if (v7 >= a3)
          {
            v10 = *v8;
            v7 = v15;
          }
          else
          {
            v10 = *v8;
            v16 = v8[2];
            if (*v8 <= v16)
              v10 = v8[2];
            if (*v8 >= v16)
              v7 = v15;
            else
              v8 += 2;
          }
        }
        while (v10 >= v12);
        *a4 = v12;
        a4[1] = v13;
      }
    }
  }
  return result;
}

uint64_t *sub_1C546F268(uint64_t *a1, uint64_t *a2)
{
  uint64_t *result;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *i;
  uint64_t v9;

  result = a2;
  if (a1 != a2)
  {
    v4 = a1 - 2;
    do
    {
      if (v4 + 4 == a2)
        return a2;
      v6 = v4[2];
      v4 += 2;
      v5 = v6;
    }
    while (v6 != v4[2] || v4[1] != v4[3]);
    for (i = v4 + 4; i != a2; i += 2)
    {
      v9 = v5;
      v5 = *i;
      if (v9 != *i || v4[1] != i[1])
      {
        v4[2] = v5;
        v4 += 2;
        v4[1] = i[1];
      }
    }
    return v4 + 2;
  }
  return result;
}

_QWORD *sub_1C546F2E8(_QWORD *a1)
{
  *a1 = &off_1E8169148;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  return a1;
}

void sub_1C546F32C(_QWORD *a1)
{
  *a1 = &off_1E8169148;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C546F380(uint64_t a1@<X0>, unsigned int *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unsigned int *v5;
  char *v7;
  unsigned int *v8;
  char *v9;
  uint64_t v10;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char **v16;
  char v17;
  unint64_t v18;
  char **v19;
  char *v20[3];
  __int128 v21;

  v5 = a2 + 4;
  if ((unint64_t)(a2 + 4) > a3)
    goto LABEL_3;
  v7 = (char *)a2[1];
  v8 = &v5[5 * *a2];
  v9 = &v7[(_QWORD)v8];
  if (&v7[(_QWORD)v8] > (char *)a3)
    goto LABEL_3;
  v12 = a2[2];
  v13 = *(char **)(a1 + 56);
  v15 = *(_QWORD *)v13;
  v14 = *((_QWORD *)v13 + 1);
  v20[0] = (char *)&v5[5 * *a2];
  v20[1] = v7;
  v20[2] = v13;
  v21 = *(_OWORD *)(a1 + 40);
  llvm::coverage::RawCoverageFilenamesReader::read(v20, 2, &v19);
  v16 = v19;
  if (v19)
    goto LABEL_5;
  v18 = (unint64_t)&v9[v12];
  if (v18 > a3)
  {
LABEL_3:
    v10 = operator new();
    *(_QWORD *)v10 = &off_1E8169028;
    *(_DWORD *)(v10 + 8) = 5;
    *(_BYTE *)(a4 + 8) |= 1u;
    *(_QWORD *)a4 = v10;
    return;
  }
  (*(void (**)(char ***__return_ptr, uint64_t, unsigned int *, unsigned int *, unint64_t, uint64_t, char *, unint64_t))(*(_QWORD *)a1 + 24))(&v19, a1, v5, v8, (-1431655765 * ((v14 - v15) >> 3)) | ((unint64_t)(-1431655765* ((*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8)- **(_QWORD **)(a1 + 56)) >> 3)- -1431655765* ((v14 - v15) >> 3)) << 32), 1, v9, v18);
  v16 = v19;
  if (v19)
  {
LABEL_5:
    v17 = *(_BYTE *)(a4 + 8) | 1;
  }
  else
  {
    v16 = (char **)((v18 + 7) & 0xFFFFFFFFFFFFFFF8);
    v17 = *(_BYTE *)(a4 + 8) & 0xFE;
  }
  *(_BYTE *)(a4 + 8) = v17;
  *(_QWORD *)a4 = v16;
}

void sub_1C546F500(uint64_t a1@<X0>, uint64_t *a2@<X1>, unint64_t a3@<X2>, unint64_t a4@<X3>, char a5@<W4>, uint64_t a6@<X5>, unint64_t a7@<X6>, uint64_t *a8@<X8>)
{
  uint64_t *v8;
  unint64_t v9;
  uint64_t *v11;
  uint64_t v12;
  BOOL v13;
  char v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  unint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  _QWORD *v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  __n128 v38;
  char v39;
  char v40;
  uint64_t v41;
  _QWORD *v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  char *v46;
  char *v47;
  char *v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  char *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v62;
  unint64_t v63;
  char v65;
  uint64_t v67;
  uint64_t *v68;
  char v69;
  _OWORD v70[2];
  __int16 v71;
  uint64_t v72;
  char v73;
  uint64_t v74;
  char v75;
  uint64_t v76;

  v8 = a8;
  v76 = *MEMORY[0x1E0C80C00];
  if ((unint64_t)a2 < a3)
  {
    v9 = a7;
    v11 = a2;
    v12 = a1;
    v60 = HIDWORD(a4);
    if (a5)
      v13 = HIDWORD(a4) == 0;
    else
      v13 = 1;
    v14 = v13;
    v62 = a1 + 8;
    v59 = a4;
    v63 = a3;
    v65 = v14;
    do
    {
      v15 = *((unsigned int *)v11 + 2);
      if (a6 + v15 > v9)
      {
        v55 = operator new();
        *(_QWORD *)v55 = &off_1E8169028;
        *(_DWORD *)(v55 + 8) = 5;
        goto LABEL_64;
      }
      if ((v14 & 1) == 0)
      {
        v67 = *(uint64_t *)((char *)v11 + 12);
        v16 = (uint64_t)(*(_QWORD *)(*(_QWORD *)(v12 + 64) + 8) - **(_QWORD **)(v12 + 64)) >> 6;
        *(_QWORD *)&v70[0] = *v11;
        *((_QWORD *)&v70[0] + 1) = v16;
        sub_1C546C7AC(&v68, v62, (uint64_t *)v70, (uint64_t *)v70 + 1);
        if (!v69)
        {
          v33 = v68[1];
          v34 = **(_QWORD **)(v12 + 64);
          v35 = v34 + (v33 << 6);
          v37 = *(_QWORD *)(v35 + 24);
          v36 = v35 + 24;
          v38 = *(__n128 *)(v36 + 8);
          if (v37)
          {
            v39 = v75 & 0xFE;
            v75 &= ~1u;
            LOBYTE(v74) = 0;
          }
          else
          {
            v70[0] = *(_OWORD *)(v36 + 8);
            llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v70, (uint64_t)&v74);
            v39 = v75;
          }
          v14 = v65;
          if ((v39 & 1) != 0)
          {
            v41 = v74;
            v8 = a8;
            *a8 = v74;
          }
          else if ((_BYTE)v74)
          {
            if (v67)
            {
              v40 = v73 & 0xFE;
              v73 &= ~1u;
              LOBYTE(v72) = 0;
            }
            else
            {
              *(_QWORD *)&v70[0] = a6;
              *((_QWORD *)&v70[0] + 1) = v15;
              llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v70, (uint64_t)&v72);
              v14 = v65;
              v40 = v73;
            }
            v53 = v33;
            if ((v40 & 1) != 0)
            {
              v41 = v72;
              v72 = 0;
              *a8 = v41;
              if (!v41)
                goto LABEL_50;
            }
            else
            {
              if ((_BYTE)v72)
              {
                v41 = 0;
                *a8 = 0;
                goto LABEL_54;
              }
LABEL_50:
              v41 = 0;
              *(_QWORD *)v36 = v67;
              *(_QWORD *)(v36 + 8) = a6;
              *(_QWORD *)(v36 + 16) = v15;
              v54 = v34 + (v53 << 6);
              *(_QWORD *)(v54 + 48) = v59;
              *(_QWORD *)(v54 + 56) = v60;
              *a8 = 0;
              if ((v40 & 1) != 0)
              {
                if (v72)
                {
                  (*(void (**)(uint64_t, __n128))(*(_QWORD *)v72 + 8))(v72, v38);
                  v14 = v65;
                }
                v41 = 0;
              }
            }
LABEL_54:
            v8 = a8;
          }
          else
          {
            v41 = 0;
            v8 = a8;
            *a8 = 0;
          }
          a3 = v63;
          v9 = a7;
          v12 = a1;
          if (v41)
            return;
          goto LABEL_56;
        }
        v17 = *(uint64_t **)(v12 + 32);
        v18 = *v11;
        sub_1C546CB40(v17);
        v19 = (_QWORD *)v17[7];
        v20 = (_QWORD *)v17[8];
        if (v20 != v19)
        {
          v21 = 0xAAAAAAAAAAAAAAABLL * (v20 - v19);
          do
          {
            v22 = v21 >> 1;
            v23 = &v19[3 * (v21 >> 1)];
            v25 = *v23;
            v24 = v23 + 3;
            v21 += ~(v21 >> 1);
            if (v25 < v18)
              v19 = v24;
            else
              v21 = v22;
          }
          while (v21);
        }
        if (v19 != v20 && *v19 == v18 && (v26 = v19[2]) != 0)
        {
          v27 = v19[1];
          v28 = *(_QWORD *)(a1 + 64);
          v30 = *(_QWORD **)(v28 + 8);
          v29 = *(_QWORD *)(v28 + 16);
          if ((unint64_t)v30 >= v29)
          {
            v42 = *(_QWORD **)v28;
            v43 = ((uint64_t)v30 - *(_QWORD *)v28) >> 6;
            v44 = v43 + 1;
            if ((unint64_t)(v43 + 1) >> 58)
              abort();
            v57 = v27;
            v58 = *(_QWORD *)(a1 + 64);
            v45 = v29 - (_QWORD)v42;
            if (v45 >> 5 > v44)
              v44 = v45 >> 5;
            if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFC0)
              v44 = 0x3FFFFFFFFFFFFFFLL;
            if (v44 >> 58)
              sub_1C4764EE4();
            v56 = v44;
            v46 = (char *)operator new(v44 << 6);
            v47 = &v46[64 * v43];
            *(_DWORD *)v47 = 2;
            *((_QWORD *)v47 + 1) = v57;
            *((_QWORD *)v47 + 2) = v26;
            *((_QWORD *)v47 + 3) = v67;
            *((_QWORD *)v47 + 4) = a6;
            *((_QWORD *)v47 + 5) = v15;
            *((_QWORD *)v47 + 6) = v59;
            *((_QWORD *)v47 + 7) = v60;
            if (v30 == v42)
            {
              v52 = &v46[64 * v43];
              v9 = a7;
              v28 = v58;
            }
            else
            {
              v48 = &v46[64 * v43];
              v9 = a7;
              v28 = v58;
              do
              {
                v49 = *((_OWORD *)v30 - 4);
                v50 = *((_OWORD *)v30 - 3);
                v51 = *((_OWORD *)v30 - 1);
                v52 = v48 - 64;
                *((_OWORD *)v48 - 2) = *((_OWORD *)v30 - 2);
                *((_OWORD *)v48 - 1) = v51;
                *((_OWORD *)v48 - 4) = v49;
                *((_OWORD *)v48 - 3) = v50;
                v30 -= 8;
                v48 -= 64;
              }
              while (v30 != v42);
            }
            v31 = v47 + 64;
            *(_QWORD *)v28 = v52;
            *(_QWORD *)(v28 + 8) = v47 + 64;
            *(_QWORD *)(v28 + 16) = &v46[64 * v56];
            if (v42)
            {
              operator delete(v42);
              v28 = v58;
            }
          }
          else
          {
            *(_DWORD *)v30 = 2;
            v30[1] = v27;
            v30[2] = v26;
            v30[3] = v67;
            v30[4] = a6;
            v30[5] = v15;
            v30[6] = v59;
            v31 = (char *)(v30 + 8);
            v30[7] = v60;
            v9 = a7;
          }
          a3 = v63;
          v12 = a1;
          v14 = v65;
          v32 = 0;
          *(_QWORD *)(v28 + 8) = v31;
          v8 = a8;
        }
        else
        {
          v32 = operator new();
          *(_QWORD *)&v70[0] = "function name is empty";
          v71 = 259;
          *(_QWORD *)v32 = off_1E8192D50;
          *(_DWORD *)(v32 + 8) = 9;
          llvm::Twine::str((llvm::Twine *)v70, (_QWORD *)(v32 + 16));
          a3 = v63;
          v9 = a7;
          v12 = a1;
          v14 = v65;
        }
        *v8 = v32;
        if (v32)
          return;
      }
LABEL_56:
      v11 = (uint64_t *)((char *)v11 + 20);
      a6 += v15;
    }
    while ((unint64_t)v11 < a3);
  }
  v55 = 0;
LABEL_64:
  *v8 = v55;
}

_QWORD *sub_1C546F9DC(_QWORD *a1)
{
  *a1 = &off_1E8169178;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  return a1;
}

void sub_1C546FA20(_QWORD *a1)
{
  *a1 = &off_1E8169178;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C546FA74(uint64_t a1@<X0>, unsigned int *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  size_t v5;
  int *v6;
  char *v7;
  uint64_t v8;
  unsigned int v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned __int8 **v24;
  unsigned __int8 **v25;
  char v26;
  uint64_t v27;
  unsigned __int8 *v28;
  char v29;
  int v30;
  unsigned __int8 *v31;
  unsigned __int8 *v32;
  uint64_t v33;
  char *v34[3];
  __int128 v35;
  uint64_t v36;
  unint64_t v37;
  __int128 v38;
  uint64_t v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  if ((unint64_t)(a2 + 4) > a3)
    goto LABEL_3;
  v5 = a2[1];
  v6 = (int *)((char *)a2 + 29 * *a2 + 16);
  v7 = (char *)v6 + v5;
  if ((unint64_t)v6 + v5 > a3)
    goto LABEL_3;
  v10 = a2[2];
  v11 = *(char **)(a1 + 56);
  v13 = *(_QWORD *)v11;
  v12 = *((_QWORD *)v11 + 1);
  v34[0] = (char *)a2 + 29 * *a2 + 16;
  v34[1] = (char *)v5;
  v34[2] = v11;
  v35 = *(_OWORD *)(a1 + 40);
  llvm::coverage::RawCoverageFilenamesReader::read(v34, 3, (char ***)&v38);
  v14 = v38;
  if ((_QWORD)v38)
  {
    v15 = *(_BYTE *)(a4 + 8) | 1;
LABEL_7:
    *(_BYTE *)(a4 + 8) = v15;
    *(_QWORD *)a4 = v14;
    return;
  }
  v16 = 0xAAAAAAAAAAAAAAABLL * ((v12 - v13) >> 3);
  v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) - **(_QWORD **)(a1 + 56)) >> 3) - v16;
  v38 = xmmword_1C85F4BB0;
  v39 = 0;
  llvm::MD5::update((int *)&v38, v6, v5);
  llvm::MD5::final((int *)&v38, (int *)&v36);
  v37 = v16 | ((unint64_t)v17 << 32);
  sub_1C54701B8((uint64_t **)&v38, a1 + 72, &v36, (uint64_t *)&v37);
  if (!(_BYTE)v39)
  {
    v18 = v38;
    v19 = *(unsigned int *)(v38 + 12);
    if (v17 != v19)
      goto LABEL_31;
    v20 = v16;
    v21 = **(_QWORD **)(a1 + 56);
    v22 = v21 + 24 * *(unsigned int *)(v38 + 8);
    v23 = v22 + 24 * v19;
    v24 = (unsigned __int8 **)(v21 + 24 * v20);
    v25 = &v24[3 * v17];
    if ((_DWORD)v19)
    {
      do
      {
        v26 = *(_BYTE *)(v22 + 23);
        v27 = v26 & 0x7F;
        if (v26 >= 0)
          v28 = (unsigned __int8 *)(v26 & 0x7F);
        else
          v28 = *(unsigned __int8 **)(v22 + 8);
        v29 = *((_BYTE *)v24 + 23);
        v30 = v29;
        v31 = (unsigned __int8 *)(v29 & 0x7F);
        if (v30 < 0)
          v31 = v24[1];
        if (v28 != v31)
          goto LABEL_31;
        if (v30 >= 0)
          v32 = (unsigned __int8 *)v24;
        else
          v32 = *v24;
        if ((*(_BYTE *)(v22 + 23) & 0x80) != 0)
        {
          if (memcmp(*(const void **)v22, v32, *(_QWORD *)(v22 + 8)))
            goto LABEL_31;
        }
        else if ((v26 & 0x7F) != 0)
        {
          v33 = 0;
          while (*(unsigned __int8 *)(v22 + v33) == v32[v33])
          {
            if (v27 == ++v33)
              goto LABEL_27;
          }
          goto LABEL_31;
        }
LABEL_27:
        v22 += 24;
        v24 += 3;
      }
      while (v22 != v23 && v24 != v25);
    }
    if (v22 != v23 || v24 != v25)
LABEL_31:
      *(_DWORD *)(v18 + 12) = 0;
  }
  if (!v10)
  {
    v14 = (unint64_t)(v7 + 7) & 0xFFFFFFFFFFFFFFF8;
    v15 = *(_BYTE *)(a4 + 8) & 0xFE;
    goto LABEL_7;
  }
LABEL_3:
  v8 = operator new();
  *(_QWORD *)v8 = &off_1E8169028;
  *(_DWORD *)(v8 + 8) = 5;
  *(_BYTE *)(a4 + 8) |= 1u;
  *(_QWORD *)a4 = v8;
}

void sub_1C546FD18(uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  unint64_t v4;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  unint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t *v21;
  _QWORD *v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  _QWORD *v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t *v36;
  __n128 v37;
  char v38;
  _QWORD *v39;
  unint64_t v40;
  uint64_t v41;
  char *v42;
  char *v43;
  char *v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  char *v48;
  unint64_t *v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t *v65;
  char v66;
  _OWORD v67[2];
  __int16 v68;
  uint64_t v69;
  char v70;
  uint64_t v71;
  char v72;
  uint64_t v73;

  v73 = *MEMORY[0x1E0C80C00];
  if (a2 < a3)
  {
    v4 = a2;
    v61 = a1 + 8;
    while (1)
    {
      v6 = *(unsigned int *)(v4 + 8);
      v7 = *(_QWORD *)(a1 + 72);
      v8 = *(unsigned int *)(a1 + 88);
      v9 = sub_1C5470560(v7, *(_DWORD *)(a1 + 88), *(_QWORD *)(v4 + 20));
      if ((uint64_t *)(v7 + 16 * v8) == v9)
      {
LABEL_52:
        v51 = operator new();
        *(_QWORD *)v51 = &off_1E8169028;
        *(_DWORD *)(v51 + 8) = 5;
        goto LABEL_53;
      }
      v10 = v4 + 28;
      v11 = v4 + 28 + v6;
      v12 = v9[1];
      v13 = HIDWORD(v12);
      if (HIDWORD(v12))
        break;
LABEL_50:
      v4 = (v11 + 7) & 0xFFFFFFFFFFFFFFF8;
      if (v4 >= a3)
        goto LABEL_51;
    }
    if (v11 > a3)
      goto LABEL_52;
    v62 = *(_QWORD *)(v4 + 12);
    v14 = (uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) - **(_QWORD **)(a1 + 64)) >> 6;
    *(_QWORD *)&v67[0] = *(_QWORD *)v4;
    *((_QWORD *)&v67[0] + 1) = v14;
    sub_1C546C7AC(&v65, v61, (uint64_t *)v67, (uint64_t *)v67 + 1);
    if (v66)
    {
      v15 = *(uint64_t **)(a1 + 32);
      v16 = *(_QWORD *)v4;
      sub_1C546CB40(v15);
      v17 = (_QWORD *)v15[7];
      v18 = (_QWORD *)v15[8];
      if (v18 != v17)
      {
        v19 = 0xAAAAAAAAAAAAAAABLL * (v18 - v17);
        do
        {
          v20 = v19 >> 1;
          v21 = &v17[3 * (v19 >> 1)];
          v23 = *v21;
          v22 = v21 + 3;
          v19 += ~(v19 >> 1);
          if (v23 < v16)
            v17 = v22;
          else
            v19 = v20;
        }
        while (v19);
      }
      if (v17 != v18 && *v17 == v16 && (v24 = v17[2]) != 0)
      {
        v25 = v17[1];
        v26 = *(_QWORD *)(a1 + 64);
        v28 = *(_QWORD **)(v26 + 8);
        v27 = *(_QWORD *)(v26 + 16);
        if ((unint64_t)v28 >= v27)
        {
          v39 = *(_QWORD **)v26;
          v40 = (((uint64_t)v28 - *(_QWORD *)v26) >> 6) + 1;
          if (v40 >> 58)
            abort();
          v53 = ((uint64_t)v28 - *(_QWORD *)v26) >> 6;
          v54 = v25;
          v56 = v24;
          v59 = *(_QWORD *)(a1 + 64);
          v41 = v27 - (_QWORD)v39;
          if (v41 >> 5 > v40)
            v40 = v41 >> 5;
          if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFC0)
            v40 = 0x3FFFFFFFFFFFFFFLL;
          if (v40 >> 58)
            sub_1C4764EE4();
          v52 = v40;
          v42 = (char *)operator new(v40 << 6);
          v43 = &v42[64 * v53];
          *(_DWORD *)v43 = 3;
          *((_QWORD *)v43 + 1) = v54;
          *((_QWORD *)v43 + 2) = v56;
          *((_QWORD *)v43 + 3) = v62;
          *((_QWORD *)v43 + 4) = v10;
          *((_QWORD *)v43 + 5) = v6;
          *((_QWORD *)v43 + 6) = v12;
          *((_QWORD *)v43 + 7) = v13;
          if (v28 == v39)
          {
            v48 = &v42[64 * v53];
            v26 = v59;
          }
          else
          {
            v44 = &v42[64 * v53];
            v26 = v59;
            do
            {
              v45 = *((_OWORD *)v28 - 4);
              v46 = *((_OWORD *)v28 - 3);
              v47 = *((_OWORD *)v28 - 1);
              v48 = v44 - 64;
              *((_OWORD *)v44 - 2) = *((_OWORD *)v28 - 2);
              *((_OWORD *)v44 - 1) = v47;
              *((_OWORD *)v44 - 4) = v45;
              *((_OWORD *)v44 - 3) = v46;
              v28 -= 8;
              v44 -= 64;
            }
            while (v28 != v39);
          }
          v29 = v43 + 64;
          *(_QWORD *)v26 = v48;
          *(_QWORD *)(v26 + 8) = v43 + 64;
          *(_QWORD *)(v26 + 16) = &v42[64 * v52];
          if (v39)
          {
            operator delete(v39);
            v26 = v59;
          }
        }
        else
        {
          *(_DWORD *)v28 = 3;
          v28[1] = v25;
          v28[2] = v24;
          v28[3] = v62;
          v28[4] = v10;
          v28[5] = v6;
          v28[6] = v12;
          v29 = (char *)(v28 + 8);
          v28[7] = v13;
        }
        v30 = 0;
        *(_QWORD *)(v26 + 8) = v29;
      }
      else
      {
        v30 = operator new();
        *(_QWORD *)&v67[0] = "function name is empty";
        v68 = 259;
        *(_QWORD *)v30 = off_1E8192D50;
        *(_DWORD *)(v30 + 8) = 9;
        llvm::Twine::str((llvm::Twine *)v67, (_QWORD *)(v30 + 16));
      }
      goto LABEL_48;
    }
    v31 = v65[1];
    v32 = **(_QWORD **)(a1 + 64);
    v33 = v32 + (v31 << 6);
    v35 = *(_QWORD *)(v33 + 24);
    v34 = v33 + 24;
    v36 = (unint64_t *)(v34 + 8);
    v37 = *(__n128 *)(v34 + 8);
    if (v35)
    {
      v72 &= ~1u;
      LOBYTE(v71) = 0;
      if ((v72 & 1) == 0)
        goto LABEL_21;
    }
    else
    {
      v67[0] = *(_OWORD *)(v34 + 8);
      v55 = v31;
      v58 = v32;
      llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v67, (uint64_t)&v71);
      v31 = v55;
      v32 = v58;
      v36 = (unint64_t *)(v34 + 8);
      if ((v72 & 1) == 0)
      {
LABEL_21:
        if (!(_BYTE)v71)
        {
LABEL_25:
          v30 = 0;
          *a4 = 0;
          goto LABEL_49;
        }
        if (v62)
        {
          v70 &= ~1u;
          v38 = v70;
          LOBYTE(v69) = 0;
          if ((v70 & 1) == 0)
            goto LABEL_24;
        }
        else
        {
          *(_QWORD *)&v67[0] = v4 + 28;
          *((_QWORD *)&v67[0] + 1) = v6;
          v57 = v31;
          v60 = v32;
          v49 = v36;
          llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v67, (uint64_t)&v69);
          v31 = v57;
          v32 = v60;
          v36 = v49;
          v38 = v70;
          if ((v70 & 1) == 0)
          {
LABEL_24:
            if ((_BYTE)v69)
              goto LABEL_25;
LABEL_40:
            v30 = 0;
            *(_QWORD *)v34 = v62;
            *v36 = v10;
            v36[1] = v6;
            v50 = v32 + (v31 << 6);
            *(_QWORD *)(v50 + 48) = v12;
            *(_QWORD *)(v50 + 56) = v13;
            *a4 = 0;
            if ((v38 & 1) != 0)
            {
              if (v69)
                (*(void (**)(uint64_t, __n128))(*(_QWORD *)v69 + 8))(v69, v37);
              v30 = 0;
            }
LABEL_49:
            if (v30)
              return;
            goto LABEL_50;
          }
        }
        v30 = v69;
        v69 = 0;
        *a4 = v30;
        if (v30)
          goto LABEL_49;
        goto LABEL_40;
      }
    }
    v30 = v71;
LABEL_48:
    *a4 = v30;
    goto LABEL_49;
  }
LABEL_51:
  v51 = 0;
LABEL_53:
  *a4 = v51;
}

uint64_t **sub_1C54701B8(uint64_t **result, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t **v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t *v12;
  uint64_t v13;
  char v14;
  int v15;
  uint64_t v16;
  uint64_t *v17;
  int v18;
  BOOL v19;
  unsigned int v20;
  int v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t *v24;
  int v25;
  BOOL v26;
  unsigned int v27;
  int v28;
  unsigned int v29;
  uint64_t v30;
  int v31;
  BOOL v32;
  unsigned int v33;

  v7 = result;
  v8 = *(_DWORD *)(a2 + 16);
  if (v8)
  {
    v9 = *(_QWORD *)a2;
    v10 = v8 - 1;
    v11 = (37 * *a3) & (v8 - 1);
    v12 = (uint64_t *)(*(_QWORD *)a2 + 16 * v11);
    v13 = *v12;
    if (*a3 == *v12)
    {
LABEL_3:
      v14 = 0;
      goto LABEL_11;
    }
    v17 = 0;
    v18 = 1;
    while (v13 != -1)
    {
      if (v17)
        v19 = 0;
      else
        v19 = v13 == -2;
      if (v19)
        v17 = v12;
      v20 = v11 + v18++;
      v11 = v20 & v10;
      v12 = (uint64_t *)(v9 + 16 * (v20 & v10));
      v13 = *v12;
      if (*a3 == *v12)
        goto LABEL_3;
    }
    if (v17)
      v12 = v17;
  }
  else
  {
    v12 = 0;
  }
  v15 = *(_DWORD *)(a2 + 8);
  if (4 * v15 + 4 >= 3 * v8)
  {
    result = (uint64_t **)sub_1C54703E4(a2, 2 * v8);
    v16 = *a3;
    v21 = *(_DWORD *)(a2 + 16) - 1;
    v22 = (37 * *a3) & v21;
    v12 = (uint64_t *)(*(_QWORD *)a2 + 16 * v22);
    v23 = *v12;
    if (*a3 == *v12)
      goto LABEL_8;
    v24 = 0;
    v25 = 1;
    while (v23 != -1)
    {
      if (v24)
        v26 = 0;
      else
        v26 = v23 == -2;
      if (v26)
        v24 = v12;
      v27 = v22 + v25++;
      v22 = v27 & v21;
      v12 = (uint64_t *)(*(_QWORD *)a2 + 16 * (v27 & v21));
      v23 = *v12;
      if (v16 == *v12)
        goto LABEL_8;
    }
    goto LABEL_44;
  }
  if (v8 + ~v15 - *(_DWORD *)(a2 + 12) <= v8 >> 3)
  {
    result = (uint64_t **)sub_1C54703E4(a2, v8);
    v16 = *a3;
    v28 = *(_DWORD *)(a2 + 16) - 1;
    v29 = (37 * *a3) & v28;
    v12 = (uint64_t *)(*(_QWORD *)a2 + 16 * v29);
    v30 = *v12;
    if (*a3 == *v12)
      goto LABEL_8;
    v24 = 0;
    v31 = 1;
    while (v30 != -1)
    {
      if (v24)
        v32 = 0;
      else
        v32 = v30 == -2;
      if (v32)
        v24 = v12;
      v33 = v29 + v31++;
      v29 = v33 & v28;
      v12 = (uint64_t *)(*(_QWORD *)a2 + 16 * (v33 & v28));
      v30 = *v12;
      if (v16 == *v12)
        goto LABEL_8;
    }
LABEL_44:
    if (v24)
      v12 = v24;
  }
  v16 = *v12;
LABEL_8:
  ++*(_DWORD *)(a2 + 8);
  if (v16 != -1)
    --*(_DWORD *)(a2 + 12);
  *v12 = *a3;
  v12[1] = *a4;
  v9 = *(_QWORD *)a2;
  v8 = *(_DWORD *)(a2 + 16);
  v14 = 1;
LABEL_11:
  *v7 = v12;
  v7[1] = (uint64_t *)(v9 + 16 * v8);
  *((_BYTE *)v7 + 16) = v14;
  return result;
}

_QWORD *sub_1C54703E4(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unsigned int v8;
  _QWORD *result;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  int v14;
  unsigned int v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18;
  int v19;
  BOOL v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;

  v3 = *(unsigned int *)(a1 + 16);
  v4 = *(uint64_t **)a1;
  v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
    v8 = v7 + 1;
  else
    v8 = 64;
  *(_DWORD *)(a1 + 16) = v8;
  result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(_QWORD *)a1 = result;
  if (v4)
  {
    *(_QWORD *)(a1 + 8) = 0;
    v10 = *(unsigned int *)(a1 + 16);
    if ((_DWORD)v10)
    {
      v11 = 16 * v10;
      do
      {
        *result = -1;
        result += 2;
        v11 -= 16;
      }
      while (v11);
    }
    if ((_DWORD)v3)
    {
      v12 = v4;
      do
      {
        v13 = *v12;
        if ((unint64_t)*v12 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          v14 = *(_DWORD *)(a1 + 16) - 1;
          v15 = v14 & (37 * v13);
          v16 = (_QWORD *)(*(_QWORD *)a1 + 16 * v15);
          v17 = *v16;
          if (v13 != *v16)
          {
            v18 = 0;
            v19 = 1;
            while (v17 != -1)
            {
              if (v18)
                v20 = 0;
              else
                v20 = v17 == -2;
              if (v20)
                v18 = v16;
              v21 = v15 + v19++;
              v15 = v21 & v14;
              v16 = (_QWORD *)(*(_QWORD *)a1 + 16 * (v21 & v14));
              v17 = *v16;
              if (v13 == *v16)
                goto LABEL_12;
            }
            if (v18)
              v16 = v18;
          }
LABEL_12:
          *v16 = v13;
          v16[1] = v12[1];
          ++*(_DWORD *)(a1 + 8);
        }
        v12 += 2;
      }
      while (v12 != &v4[2 * v3]);
    }
    JUMPOUT(0x1CAA32FB4);
  }
  *(_QWORD *)(a1 + 8) = 0;
  v22 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v22)
  {
    v23 = 16 * v22;
    do
    {
      *result = -1;
      result += 2;
      v23 -= 16;
    }
    while (v23);
  }
  return result;
}

uint64_t *sub_1C5470560(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  int v6;
  int v7;

  if (!a2)
    return (uint64_t *)(a1 + 16 * a2);
  LODWORD(v3) = (37 * a3) & (a2 - 1);
  v4 = (uint64_t *)(a1 + 16 * v3);
  v5 = *v4;
  if (*v4 != a3)
  {
    v6 = 1;
    while (v5 != -1)
    {
      v7 = v3 + v6++;
      v3 = v7 & (a2 - 1);
      v5 = *(_QWORD *)(a1 + 16 * v3);
      if (v5 == a3)
        return (uint64_t *)(a1 + 16 * v3);
    }
    return (uint64_t *)(a1 + 16 * a2);
  }
  return v4;
}

_QWORD *sub_1C54705C0(_QWORD *a1)
{
  *a1 = &off_1E81691A8;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  return a1;
}

void sub_1C5470604(_QWORD *a1)
{
  *a1 = &off_1E81691A8;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5470658(uint64_t a1@<X0>, unsigned int *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  size_t v5;
  int *v6;
  char *v7;
  uint64_t v8;
  unsigned int v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned __int8 **v24;
  unsigned __int8 **v25;
  char v26;
  uint64_t v27;
  unsigned __int8 *v28;
  char v29;
  int v30;
  unsigned __int8 *v31;
  unsigned __int8 *v32;
  uint64_t v33;
  char *v34[3];
  __int128 v35;
  uint64_t v36;
  unint64_t v37;
  __int128 v38;
  uint64_t v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  if ((unint64_t)(a2 + 4) > a3)
    goto LABEL_3;
  v5 = a2[1];
  v6 = (int *)((char *)a2 + 29 * *a2 + 16);
  v7 = (char *)v6 + v5;
  if ((unint64_t)v6 + v5 > a3)
    goto LABEL_3;
  v10 = a2[2];
  v11 = *(char **)(a1 + 56);
  v13 = *(_QWORD *)v11;
  v12 = *((_QWORD *)v11 + 1);
  v34[0] = (char *)a2 + 29 * *a2 + 16;
  v34[1] = (char *)v5;
  v34[2] = v11;
  v35 = *(_OWORD *)(a1 + 40);
  llvm::coverage::RawCoverageFilenamesReader::read(v34, 4, (char ***)&v38);
  v14 = v38;
  if ((_QWORD)v38)
  {
    v15 = *(_BYTE *)(a4 + 8) | 1;
LABEL_7:
    *(_BYTE *)(a4 + 8) = v15;
    *(_QWORD *)a4 = v14;
    return;
  }
  v16 = 0xAAAAAAAAAAAAAAABLL * ((v12 - v13) >> 3);
  v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) - **(_QWORD **)(a1 + 56)) >> 3) - v16;
  v38 = xmmword_1C85F4BB0;
  v39 = 0;
  llvm::MD5::update((int *)&v38, v6, v5);
  llvm::MD5::final((int *)&v38, (int *)&v36);
  v37 = v16 | ((unint64_t)v17 << 32);
  sub_1C54701B8((uint64_t **)&v38, a1 + 72, &v36, (uint64_t *)&v37);
  if (!(_BYTE)v39)
  {
    v18 = v38;
    v19 = *(unsigned int *)(v38 + 12);
    if (v17 != v19)
      goto LABEL_31;
    v20 = v16;
    v21 = **(_QWORD **)(a1 + 56);
    v22 = v21 + 24 * *(unsigned int *)(v38 + 8);
    v23 = v22 + 24 * v19;
    v24 = (unsigned __int8 **)(v21 + 24 * v20);
    v25 = &v24[3 * v17];
    if ((_DWORD)v19)
    {
      do
      {
        v26 = *(_BYTE *)(v22 + 23);
        v27 = v26 & 0x7F;
        if (v26 >= 0)
          v28 = (unsigned __int8 *)(v26 & 0x7F);
        else
          v28 = *(unsigned __int8 **)(v22 + 8);
        v29 = *((_BYTE *)v24 + 23);
        v30 = v29;
        v31 = (unsigned __int8 *)(v29 & 0x7F);
        if (v30 < 0)
          v31 = v24[1];
        if (v28 != v31)
          goto LABEL_31;
        if (v30 >= 0)
          v32 = (unsigned __int8 *)v24;
        else
          v32 = *v24;
        if ((*(_BYTE *)(v22 + 23) & 0x80) != 0)
        {
          if (memcmp(*(const void **)v22, v32, *(_QWORD *)(v22 + 8)))
            goto LABEL_31;
        }
        else if ((v26 & 0x7F) != 0)
        {
          v33 = 0;
          while (*(unsigned __int8 *)(v22 + v33) == v32[v33])
          {
            if (v27 == ++v33)
              goto LABEL_27;
          }
          goto LABEL_31;
        }
LABEL_27:
        v22 += 24;
        v24 += 3;
      }
      while (v22 != v23 && v24 != v25);
    }
    if (v22 != v23 || v24 != v25)
LABEL_31:
      *(_DWORD *)(v18 + 12) = 0;
  }
  if (!v10)
  {
    v14 = (unint64_t)(v7 + 7) & 0xFFFFFFFFFFFFFFF8;
    v15 = *(_BYTE *)(a4 + 8) & 0xFE;
    goto LABEL_7;
  }
LABEL_3:
  v8 = operator new();
  *(_QWORD *)v8 = &off_1E8169028;
  *(_DWORD *)(v8 + 8) = 5;
  *(_BYTE *)(a4 + 8) |= 1u;
  *(_QWORD *)a4 = v8;
}

void sub_1C54708FC(uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  unint64_t v4;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  unint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t *v21;
  _QWORD *v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  _QWORD *v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t *v36;
  __n128 v37;
  char v38;
  _QWORD *v39;
  unint64_t v40;
  uint64_t v41;
  char *v42;
  char *v43;
  char *v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  char *v48;
  unint64_t *v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t *v65;
  char v66;
  _OWORD v67[2];
  __int16 v68;
  uint64_t v69;
  char v70;
  uint64_t v71;
  char v72;
  uint64_t v73;

  v73 = *MEMORY[0x1E0C80C00];
  if (a2 < a3)
  {
    v4 = a2;
    v61 = a1 + 8;
    while (1)
    {
      v6 = *(unsigned int *)(v4 + 8);
      v7 = *(_QWORD *)(a1 + 72);
      v8 = *(unsigned int *)(a1 + 88);
      v9 = sub_1C5470560(v7, *(_DWORD *)(a1 + 88), *(_QWORD *)(v4 + 20));
      if ((uint64_t *)(v7 + 16 * v8) == v9)
      {
LABEL_52:
        v51 = operator new();
        *(_QWORD *)v51 = &off_1E8169028;
        *(_DWORD *)(v51 + 8) = 5;
        goto LABEL_53;
      }
      v10 = v4 + 28;
      v11 = v4 + 28 + v6;
      v12 = v9[1];
      v13 = HIDWORD(v12);
      if (HIDWORD(v12))
        break;
LABEL_50:
      v4 = (v11 + 7) & 0xFFFFFFFFFFFFFFF8;
      if (v4 >= a3)
        goto LABEL_51;
    }
    if (v11 > a3)
      goto LABEL_52;
    v62 = *(_QWORD *)(v4 + 12);
    v14 = (uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) - **(_QWORD **)(a1 + 64)) >> 6;
    *(_QWORD *)&v67[0] = *(_QWORD *)v4;
    *((_QWORD *)&v67[0] + 1) = v14;
    sub_1C546C7AC(&v65, v61, (uint64_t *)v67, (uint64_t *)v67 + 1);
    if (v66)
    {
      v15 = *(uint64_t **)(a1 + 32);
      v16 = *(_QWORD *)v4;
      sub_1C546CB40(v15);
      v17 = (_QWORD *)v15[7];
      v18 = (_QWORD *)v15[8];
      if (v18 != v17)
      {
        v19 = 0xAAAAAAAAAAAAAAABLL * (v18 - v17);
        do
        {
          v20 = v19 >> 1;
          v21 = &v17[3 * (v19 >> 1)];
          v23 = *v21;
          v22 = v21 + 3;
          v19 += ~(v19 >> 1);
          if (v23 < v16)
            v17 = v22;
          else
            v19 = v20;
        }
        while (v19);
      }
      if (v17 != v18 && *v17 == v16 && (v24 = v17[2]) != 0)
      {
        v25 = v17[1];
        v26 = *(_QWORD *)(a1 + 64);
        v28 = *(_QWORD **)(v26 + 8);
        v27 = *(_QWORD *)(v26 + 16);
        if ((unint64_t)v28 >= v27)
        {
          v39 = *(_QWORD **)v26;
          v40 = (((uint64_t)v28 - *(_QWORD *)v26) >> 6) + 1;
          if (v40 >> 58)
            abort();
          v53 = ((uint64_t)v28 - *(_QWORD *)v26) >> 6;
          v54 = v25;
          v56 = v24;
          v59 = *(_QWORD *)(a1 + 64);
          v41 = v27 - (_QWORD)v39;
          if (v41 >> 5 > v40)
            v40 = v41 >> 5;
          if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFC0)
            v40 = 0x3FFFFFFFFFFFFFFLL;
          if (v40 >> 58)
            sub_1C4764EE4();
          v52 = v40;
          v42 = (char *)operator new(v40 << 6);
          v43 = &v42[64 * v53];
          *(_DWORD *)v43 = 4;
          *((_QWORD *)v43 + 1) = v54;
          *((_QWORD *)v43 + 2) = v56;
          *((_QWORD *)v43 + 3) = v62;
          *((_QWORD *)v43 + 4) = v10;
          *((_QWORD *)v43 + 5) = v6;
          *((_QWORD *)v43 + 6) = v12;
          *((_QWORD *)v43 + 7) = v13;
          if (v28 == v39)
          {
            v48 = &v42[64 * v53];
            v26 = v59;
          }
          else
          {
            v44 = &v42[64 * v53];
            v26 = v59;
            do
            {
              v45 = *((_OWORD *)v28 - 4);
              v46 = *((_OWORD *)v28 - 3);
              v47 = *((_OWORD *)v28 - 1);
              v48 = v44 - 64;
              *((_OWORD *)v44 - 2) = *((_OWORD *)v28 - 2);
              *((_OWORD *)v44 - 1) = v47;
              *((_OWORD *)v44 - 4) = v45;
              *((_OWORD *)v44 - 3) = v46;
              v28 -= 8;
              v44 -= 64;
            }
            while (v28 != v39);
          }
          v29 = v43 + 64;
          *(_QWORD *)v26 = v48;
          *(_QWORD *)(v26 + 8) = v43 + 64;
          *(_QWORD *)(v26 + 16) = &v42[64 * v52];
          if (v39)
          {
            operator delete(v39);
            v26 = v59;
          }
        }
        else
        {
          *(_DWORD *)v28 = 4;
          v28[1] = v25;
          v28[2] = v24;
          v28[3] = v62;
          v28[4] = v10;
          v28[5] = v6;
          v28[6] = v12;
          v29 = (char *)(v28 + 8);
          v28[7] = v13;
        }
        v30 = 0;
        *(_QWORD *)(v26 + 8) = v29;
      }
      else
      {
        v30 = operator new();
        *(_QWORD *)&v67[0] = "function name is empty";
        v68 = 259;
        *(_QWORD *)v30 = off_1E8192D50;
        *(_DWORD *)(v30 + 8) = 9;
        llvm::Twine::str((llvm::Twine *)v67, (_QWORD *)(v30 + 16));
      }
      goto LABEL_48;
    }
    v31 = v65[1];
    v32 = **(_QWORD **)(a1 + 64);
    v33 = v32 + (v31 << 6);
    v35 = *(_QWORD *)(v33 + 24);
    v34 = v33 + 24;
    v36 = (unint64_t *)(v34 + 8);
    v37 = *(__n128 *)(v34 + 8);
    if (v35)
    {
      v72 &= ~1u;
      LOBYTE(v71) = 0;
      if ((v72 & 1) == 0)
        goto LABEL_21;
    }
    else
    {
      v67[0] = *(_OWORD *)(v34 + 8);
      v55 = v31;
      v58 = v32;
      llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v67, (uint64_t)&v71);
      v31 = v55;
      v32 = v58;
      v36 = (unint64_t *)(v34 + 8);
      if ((v72 & 1) == 0)
      {
LABEL_21:
        if (!(_BYTE)v71)
        {
LABEL_25:
          v30 = 0;
          *a4 = 0;
          goto LABEL_49;
        }
        if (v62)
        {
          v70 &= ~1u;
          v38 = v70;
          LOBYTE(v69) = 0;
          if ((v70 & 1) == 0)
            goto LABEL_24;
        }
        else
        {
          *(_QWORD *)&v67[0] = v4 + 28;
          *((_QWORD *)&v67[0] + 1) = v6;
          v57 = v31;
          v60 = v32;
          v49 = v36;
          llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v67, (uint64_t)&v69);
          v31 = v57;
          v32 = v60;
          v36 = v49;
          v38 = v70;
          if ((v70 & 1) == 0)
          {
LABEL_24:
            if ((_BYTE)v69)
              goto LABEL_25;
LABEL_40:
            v30 = 0;
            *(_QWORD *)v34 = v62;
            *v36 = v10;
            v36[1] = v6;
            v50 = v32 + (v31 << 6);
            *(_QWORD *)(v50 + 48) = v12;
            *(_QWORD *)(v50 + 56) = v13;
            *a4 = 0;
            if ((v38 & 1) != 0)
            {
              if (v69)
                (*(void (**)(uint64_t, __n128))(*(_QWORD *)v69 + 8))(v69, v37);
              v30 = 0;
            }
LABEL_49:
            if (v30)
              return;
            goto LABEL_50;
          }
        }
        v30 = v69;
        v69 = 0;
        *a4 = v30;
        if (v30)
          goto LABEL_49;
        goto LABEL_40;
      }
    }
    v30 = v71;
LABEL_48:
    *a4 = v30;
    goto LABEL_49;
  }
LABEL_51:
  v51 = 0;
LABEL_53:
  *a4 = v51;
}

_QWORD *sub_1C5470D9C(_QWORD *a1)
{
  *a1 = &off_1E81691D8;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  return a1;
}

void sub_1C5470DE0(_QWORD *a1)
{
  *a1 = &off_1E81691D8;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5470E34(uint64_t a1@<X0>, unsigned int *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  size_t v5;
  int *v6;
  char *v7;
  uint64_t v8;
  unsigned int v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned __int8 **v24;
  unsigned __int8 **v25;
  char v26;
  uint64_t v27;
  unsigned __int8 *v28;
  char v29;
  int v30;
  unsigned __int8 *v31;
  unsigned __int8 *v32;
  uint64_t v33;
  char *v34[3];
  __int128 v35;
  uint64_t v36;
  unint64_t v37;
  __int128 v38;
  uint64_t v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  if ((unint64_t)(a2 + 4) > a3)
    goto LABEL_3;
  v5 = a2[1];
  v6 = (int *)((char *)a2 + 29 * *a2 + 16);
  v7 = (char *)v6 + v5;
  if ((unint64_t)v6 + v5 > a3)
    goto LABEL_3;
  v10 = a2[2];
  v11 = *(char **)(a1 + 56);
  v13 = *(_QWORD *)v11;
  v12 = *((_QWORD *)v11 + 1);
  v34[0] = (char *)a2 + 29 * *a2 + 16;
  v34[1] = (char *)v5;
  v34[2] = v11;
  v35 = *(_OWORD *)(a1 + 40);
  llvm::coverage::RawCoverageFilenamesReader::read(v34, 5, (char ***)&v38);
  v14 = v38;
  if ((_QWORD)v38)
  {
    v15 = *(_BYTE *)(a4 + 8) | 1;
LABEL_7:
    *(_BYTE *)(a4 + 8) = v15;
    *(_QWORD *)a4 = v14;
    return;
  }
  v16 = 0xAAAAAAAAAAAAAAABLL * ((v12 - v13) >> 3);
  v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) - **(_QWORD **)(a1 + 56)) >> 3) - v16;
  v38 = xmmword_1C85F4BB0;
  v39 = 0;
  llvm::MD5::update((int *)&v38, v6, v5);
  llvm::MD5::final((int *)&v38, (int *)&v36);
  v37 = v16 | ((unint64_t)v17 << 32);
  sub_1C54701B8((uint64_t **)&v38, a1 + 72, &v36, (uint64_t *)&v37);
  if (!(_BYTE)v39)
  {
    v18 = v38;
    v19 = *(unsigned int *)(v38 + 12);
    if (v17 != v19)
      goto LABEL_31;
    v20 = v16;
    v21 = **(_QWORD **)(a1 + 56);
    v22 = v21 + 24 * *(unsigned int *)(v38 + 8);
    v23 = v22 + 24 * v19;
    v24 = (unsigned __int8 **)(v21 + 24 * v20);
    v25 = &v24[3 * v17];
    if ((_DWORD)v19)
    {
      do
      {
        v26 = *(_BYTE *)(v22 + 23);
        v27 = v26 & 0x7F;
        if (v26 >= 0)
          v28 = (unsigned __int8 *)(v26 & 0x7F);
        else
          v28 = *(unsigned __int8 **)(v22 + 8);
        v29 = *((_BYTE *)v24 + 23);
        v30 = v29;
        v31 = (unsigned __int8 *)(v29 & 0x7F);
        if (v30 < 0)
          v31 = v24[1];
        if (v28 != v31)
          goto LABEL_31;
        if (v30 >= 0)
          v32 = (unsigned __int8 *)v24;
        else
          v32 = *v24;
        if ((*(_BYTE *)(v22 + 23) & 0x80) != 0)
        {
          if (memcmp(*(const void **)v22, v32, *(_QWORD *)(v22 + 8)))
            goto LABEL_31;
        }
        else if ((v26 & 0x7F) != 0)
        {
          v33 = 0;
          while (*(unsigned __int8 *)(v22 + v33) == v32[v33])
          {
            if (v27 == ++v33)
              goto LABEL_27;
          }
          goto LABEL_31;
        }
LABEL_27:
        v22 += 24;
        v24 += 3;
      }
      while (v22 != v23 && v24 != v25);
    }
    if (v22 != v23 || v24 != v25)
LABEL_31:
      *(_DWORD *)(v18 + 12) = 0;
  }
  if (!v10)
  {
    v14 = (unint64_t)(v7 + 7) & 0xFFFFFFFFFFFFFFF8;
    v15 = *(_BYTE *)(a4 + 8) & 0xFE;
    goto LABEL_7;
  }
LABEL_3:
  v8 = operator new();
  *(_QWORD *)v8 = &off_1E8169028;
  *(_DWORD *)(v8 + 8) = 5;
  *(_BYTE *)(a4 + 8) |= 1u;
  *(_QWORD *)a4 = v8;
}

void sub_1C54710D8(uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  unint64_t v4;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  unint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t *v21;
  _QWORD *v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  _QWORD *v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t *v36;
  __n128 v37;
  char v38;
  _QWORD *v39;
  unint64_t v40;
  uint64_t v41;
  char *v42;
  char *v43;
  char *v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  char *v48;
  unint64_t *v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t *v65;
  char v66;
  _OWORD v67[2];
  __int16 v68;
  uint64_t v69;
  char v70;
  uint64_t v71;
  char v72;
  uint64_t v73;

  v73 = *MEMORY[0x1E0C80C00];
  if (a2 < a3)
  {
    v4 = a2;
    v61 = a1 + 8;
    while (1)
    {
      v6 = *(unsigned int *)(v4 + 8);
      v7 = *(_QWORD *)(a1 + 72);
      v8 = *(unsigned int *)(a1 + 88);
      v9 = sub_1C5470560(v7, *(_DWORD *)(a1 + 88), *(_QWORD *)(v4 + 20));
      if ((uint64_t *)(v7 + 16 * v8) == v9)
      {
LABEL_52:
        v51 = operator new();
        *(_QWORD *)v51 = &off_1E8169028;
        *(_DWORD *)(v51 + 8) = 5;
        goto LABEL_53;
      }
      v10 = v4 + 28;
      v11 = v4 + 28 + v6;
      v12 = v9[1];
      v13 = HIDWORD(v12);
      if (HIDWORD(v12))
        break;
LABEL_50:
      v4 = (v11 + 7) & 0xFFFFFFFFFFFFFFF8;
      if (v4 >= a3)
        goto LABEL_51;
    }
    if (v11 > a3)
      goto LABEL_52;
    v62 = *(_QWORD *)(v4 + 12);
    v14 = (uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) - **(_QWORD **)(a1 + 64)) >> 6;
    *(_QWORD *)&v67[0] = *(_QWORD *)v4;
    *((_QWORD *)&v67[0] + 1) = v14;
    sub_1C546C7AC(&v65, v61, (uint64_t *)v67, (uint64_t *)v67 + 1);
    if (v66)
    {
      v15 = *(uint64_t **)(a1 + 32);
      v16 = *(_QWORD *)v4;
      sub_1C546CB40(v15);
      v17 = (_QWORD *)v15[7];
      v18 = (_QWORD *)v15[8];
      if (v18 != v17)
      {
        v19 = 0xAAAAAAAAAAAAAAABLL * (v18 - v17);
        do
        {
          v20 = v19 >> 1;
          v21 = &v17[3 * (v19 >> 1)];
          v23 = *v21;
          v22 = v21 + 3;
          v19 += ~(v19 >> 1);
          if (v23 < v16)
            v17 = v22;
          else
            v19 = v20;
        }
        while (v19);
      }
      if (v17 != v18 && *v17 == v16 && (v24 = v17[2]) != 0)
      {
        v25 = v17[1];
        v26 = *(_QWORD *)(a1 + 64);
        v28 = *(_QWORD **)(v26 + 8);
        v27 = *(_QWORD *)(v26 + 16);
        if ((unint64_t)v28 >= v27)
        {
          v39 = *(_QWORD **)v26;
          v40 = (((uint64_t)v28 - *(_QWORD *)v26) >> 6) + 1;
          if (v40 >> 58)
            abort();
          v53 = ((uint64_t)v28 - *(_QWORD *)v26) >> 6;
          v54 = v25;
          v56 = v24;
          v59 = *(_QWORD *)(a1 + 64);
          v41 = v27 - (_QWORD)v39;
          if (v41 >> 5 > v40)
            v40 = v41 >> 5;
          if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFC0)
            v40 = 0x3FFFFFFFFFFFFFFLL;
          if (v40 >> 58)
            sub_1C4764EE4();
          v52 = v40;
          v42 = (char *)operator new(v40 << 6);
          v43 = &v42[64 * v53];
          *(_DWORD *)v43 = 5;
          *((_QWORD *)v43 + 1) = v54;
          *((_QWORD *)v43 + 2) = v56;
          *((_QWORD *)v43 + 3) = v62;
          *((_QWORD *)v43 + 4) = v10;
          *((_QWORD *)v43 + 5) = v6;
          *((_QWORD *)v43 + 6) = v12;
          *((_QWORD *)v43 + 7) = v13;
          if (v28 == v39)
          {
            v48 = &v42[64 * v53];
            v26 = v59;
          }
          else
          {
            v44 = &v42[64 * v53];
            v26 = v59;
            do
            {
              v45 = *((_OWORD *)v28 - 4);
              v46 = *((_OWORD *)v28 - 3);
              v47 = *((_OWORD *)v28 - 1);
              v48 = v44 - 64;
              *((_OWORD *)v44 - 2) = *((_OWORD *)v28 - 2);
              *((_OWORD *)v44 - 1) = v47;
              *((_OWORD *)v44 - 4) = v45;
              *((_OWORD *)v44 - 3) = v46;
              v28 -= 8;
              v44 -= 64;
            }
            while (v28 != v39);
          }
          v29 = v43 + 64;
          *(_QWORD *)v26 = v48;
          *(_QWORD *)(v26 + 8) = v43 + 64;
          *(_QWORD *)(v26 + 16) = &v42[64 * v52];
          if (v39)
          {
            operator delete(v39);
            v26 = v59;
          }
        }
        else
        {
          *(_DWORD *)v28 = 5;
          v28[1] = v25;
          v28[2] = v24;
          v28[3] = v62;
          v28[4] = v10;
          v28[5] = v6;
          v28[6] = v12;
          v29 = (char *)(v28 + 8);
          v28[7] = v13;
        }
        v30 = 0;
        *(_QWORD *)(v26 + 8) = v29;
      }
      else
      {
        v30 = operator new();
        *(_QWORD *)&v67[0] = "function name is empty";
        v68 = 259;
        *(_QWORD *)v30 = off_1E8192D50;
        *(_DWORD *)(v30 + 8) = 9;
        llvm::Twine::str((llvm::Twine *)v67, (_QWORD *)(v30 + 16));
      }
      goto LABEL_48;
    }
    v31 = v65[1];
    v32 = **(_QWORD **)(a1 + 64);
    v33 = v32 + (v31 << 6);
    v35 = *(_QWORD *)(v33 + 24);
    v34 = v33 + 24;
    v36 = (unint64_t *)(v34 + 8);
    v37 = *(__n128 *)(v34 + 8);
    if (v35)
    {
      v72 &= ~1u;
      LOBYTE(v71) = 0;
      if ((v72 & 1) == 0)
        goto LABEL_21;
    }
    else
    {
      v67[0] = *(_OWORD *)(v34 + 8);
      v55 = v31;
      v58 = v32;
      llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v67, (uint64_t)&v71);
      v31 = v55;
      v32 = v58;
      v36 = (unint64_t *)(v34 + 8);
      if ((v72 & 1) == 0)
      {
LABEL_21:
        if (!(_BYTE)v71)
        {
LABEL_25:
          v30 = 0;
          *a4 = 0;
          goto LABEL_49;
        }
        if (v62)
        {
          v70 &= ~1u;
          v38 = v70;
          LOBYTE(v69) = 0;
          if ((v70 & 1) == 0)
            goto LABEL_24;
        }
        else
        {
          *(_QWORD *)&v67[0] = v4 + 28;
          *((_QWORD *)&v67[0] + 1) = v6;
          v57 = v31;
          v60 = v32;
          v49 = v36;
          llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v67, (uint64_t)&v69);
          v31 = v57;
          v32 = v60;
          v36 = v49;
          v38 = v70;
          if ((v70 & 1) == 0)
          {
LABEL_24:
            if ((_BYTE)v69)
              goto LABEL_25;
LABEL_40:
            v30 = 0;
            *(_QWORD *)v34 = v62;
            *v36 = v10;
            v36[1] = v6;
            v50 = v32 + (v31 << 6);
            *(_QWORD *)(v50 + 48) = v12;
            *(_QWORD *)(v50 + 56) = v13;
            *a4 = 0;
            if ((v38 & 1) != 0)
            {
              if (v69)
                (*(void (**)(uint64_t, __n128))(*(_QWORD *)v69 + 8))(v69, v37);
              v30 = 0;
            }
LABEL_49:
            if (v30)
              return;
            goto LABEL_50;
          }
        }
        v30 = v69;
        v69 = 0;
        *a4 = v30;
        if (v30)
          goto LABEL_49;
        goto LABEL_40;
      }
    }
    v30 = v71;
LABEL_48:
    *a4 = v30;
    goto LABEL_49;
  }
LABEL_51:
  v51 = 0;
LABEL_53:
  *a4 = v51;
}

_QWORD *sub_1C5471578(_QWORD *a1)
{
  *a1 = &off_1E8169208;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  return a1;
}

void sub_1C54715BC(_QWORD *a1)
{
  *a1 = &off_1E8169208;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5471610(uint64_t a1@<X0>, unsigned int *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unsigned int *v5;
  unsigned int v7;
  char *v8;
  unsigned int *v9;
  char *v10;
  uint64_t v11;
  unsigned int v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char **v17;
  char v18;
  unint64_t v19;
  char **v20;
  char *v21[3];
  __int128 v22;

  v5 = a2 + 4;
  if ((unint64_t)(a2 + 4) > a3)
    goto LABEL_3;
  v7 = bswap32(*a2);
  v8 = (char *)bswap32(a2[1]);
  v9 = &v5[5 * v7];
  v10 = &v8[(_QWORD)v9];
  if (&v8[(_QWORD)v9] > (char *)a3)
    goto LABEL_3;
  v13 = a2[2];
  v14 = *(char **)(a1 + 56);
  v16 = *(_QWORD *)v14;
  v15 = *((_QWORD *)v14 + 1);
  v21[0] = (char *)&v5[5 * v7];
  v21[1] = v8;
  v21[2] = v14;
  v22 = *(_OWORD *)(a1 + 40);
  llvm::coverage::RawCoverageFilenamesReader::read(v21, 0, &v20);
  v17 = v20;
  if (v20)
    goto LABEL_5;
  v19 = (unint64_t)&v10[bswap32(v13)];
  if (v19 > a3)
  {
LABEL_3:
    v11 = operator new();
    *(_QWORD *)v11 = &off_1E8169028;
    *(_DWORD *)(v11 + 8) = 5;
    *(_BYTE *)(a4 + 8) |= 1u;
    *(_QWORD *)a4 = v11;
    return;
  }
  (*(void (**)(char ***__return_ptr, uint64_t, unsigned int *, unsigned int *, unint64_t, uint64_t, char *, unint64_t))(*(_QWORD *)a1 + 24))(&v20, a1, v5, v9, (-1431655765 * ((v15 - v16) >> 3)) | ((unint64_t)(-1431655765* ((*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8)- **(_QWORD **)(a1 + 56)) >> 3)- -1431655765* ((v15 - v16) >> 3)) << 32), 1, v10, v19);
  v17 = v20;
  if (v20)
  {
LABEL_5:
    v18 = *(_BYTE *)(a4 + 8) | 1;
  }
  else
  {
    v17 = (char **)((v19 + 7) & 0xFFFFFFFFFFFFFFF8);
    v18 = *(_BYTE *)(a4 + 8) & 0xFE;
  }
  *(_BYTE *)(a4 + 8) = v18;
  *(_QWORD *)a4 = v17;
}

void sub_1C547179C(uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, unint64_t a4@<X3>, char a5@<W4>, uint64_t a6@<X5>, unint64_t a7@<X6>, uint64_t *a8@<X8>)
{
  uint64_t *v8;
  unint64_t v9;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  BOOL v14;
  char v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  unsigned int v20;
  unint64_t v21;
  unint64_t v22;
  BOOL v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  __n128 v35;
  char v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  _QWORD *v40;
  char *v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  char *v48;
  char *v49;
  char *v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  char *v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  char v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v67;
  char v68;
  _OWORD v69[2];
  __int16 v70;
  uint64_t v71;
  char v72;
  uint64_t v73;
  char v74;
  uint64_t v75;

  v8 = a8;
  v75 = *MEMORY[0x1E0C80C00];
  if (a2 < a3)
  {
    v9 = a7;
    v11 = a3;
    v12 = a2;
    v13 = a1;
    v60 = HIDWORD(a4);
    if (a5)
      v14 = HIDWORD(a4) == 0;
    else
      v14 = 1;
    v15 = v14;
    v65 = a1 + 8;
    v59 = a4;
    v64 = v15;
    while (1)
    {
      v16 = bswap32(*(_DWORD *)(v12 + 8));
      if (a6 + v16 > v9)
      {
LABEL_64:
        v56 = operator new();
        *(_QWORD *)v56 = &off_1E8169028;
        *(_DWORD *)(v56 + 8) = 5;
        goto LABEL_65;
      }
      if ((v15 & 1) == 0)
        break;
LABEL_55:
      v12 += 20;
      a6 += v16;
      if (v12 >= v11)
        goto LABEL_63;
    }
    v17 = *(_QWORD *)(v12 + 12);
    v66 = bswap64(v17);
    v18 = (uint64_t)(*(_QWORD *)(*(_QWORD *)(v13 + 64) + 8) - **(_QWORD **)(v13 + 64)) >> 6;
    *(_QWORD *)&v69[0] = bswap32(*(_DWORD *)v12);
    *((_QWORD *)&v69[0] + 1) = v18;
    sub_1C546BE80(&v67, v65, v69, (_QWORD *)v69 + 1);
    if (!v68)
    {
      v29 = v13;
      v30 = *(_QWORD *)(v67 + 8);
      v31 = **(_QWORD **)(v29 + 64);
      v32 = v31 + (v30 << 6);
      v34 = *(_QWORD *)(v32 + 24);
      v33 = v32 + 24;
      v35 = *(__n128 *)(v33 + 8);
      if (v34)
      {
        v74 &= ~1u;
        LOBYTE(v73) = 0;
        if ((v74 & 1) == 0)
          goto LABEL_19;
LABEL_46:
        v37 = v73;
        *v8 = v73;
LABEL_47:
        v11 = a3;
        v9 = a7;
        v13 = a1;
        v15 = v64;
        if (v37)
          return;
        goto LABEL_55;
      }
      v69[0] = *(_OWORD *)(v33 + 8);
      llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v69, (uint64_t)&v73);
      if ((v74 & 1) != 0)
        goto LABEL_46;
LABEL_19:
      if ((_BYTE)v73)
      {
        if (v17)
        {
          v72 &= ~1u;
          v36 = v72;
          LOBYTE(v71) = 0;
          if ((v72 & 1) == 0)
            goto LABEL_22;
LABEL_58:
          v37 = v71;
          v71 = 0;
          *v8 = v37;
          if (v37)
            goto LABEL_47;
          goto LABEL_59;
        }
        *(_QWORD *)&v69[0] = a6;
        *((_QWORD *)&v69[0] + 1) = v16;
        llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v69, (uint64_t)&v71);
        v36 = v72;
        if ((v72 & 1) != 0)
          goto LABEL_58;
LABEL_22:
        if (!(_BYTE)v71)
        {
LABEL_59:
          v37 = 0;
          *(_QWORD *)v33 = v66;
          *(_QWORD *)(v33 + 8) = a6;
          *(_QWORD *)(v33 + 16) = v16;
          v55 = v31 + (v30 << 6);
          *(_QWORD *)(v55 + 48) = v59;
          *(_QWORD *)(v55 + 56) = v60;
          *v8 = 0;
          if ((v36 & 1) != 0)
          {
            if (v71)
              (*(void (**)(uint64_t, __n128))(*(_QWORD *)v71 + 8))(v71, v35);
            v37 = 0;
          }
          goto LABEL_47;
        }
      }
      v37 = 0;
      *v8 = 0;
      goto LABEL_47;
    }
    v19 = *(_QWORD **)(v13 + 32);
    v20 = *(_DWORD *)(v12 + 4);
    v21 = bswap32(*(_DWORD *)v12);
    v22 = v19[2];
    v23 = v21 >= v22;
    v24 = v21 - v22;
    if (v23 && (v25 = bswap32(v20), v26 = v19[1], v24 + v25 <= v26))
    {
      if (v26 < v24)
        v24 = v19[1];
      v27 = *v19 + v24;
      if (v26 - v24 >= v25)
        v28 = v25;
      else
        v28 = v26 - v24;
      if (!v20)
      {
LABEL_31:
        if (v28)
        {
          v38 = *(_QWORD *)(v13 + 64);
          v40 = *(_QWORD **)(v38 + 8);
          v39 = *(_QWORD *)(v38 + 16);
          if ((unint64_t)v40 >= v39)
          {
            v43 = *(_QWORD **)v38;
            v44 = ((uint64_t)v40 - *(_QWORD *)v38) >> 6;
            v45 = v44 + 1;
            if ((unint64_t)(v44 + 1) >> 58)
              abort();
            v46 = v39 - (_QWORD)v43;
            if (v46 >> 5 > v45)
              v45 = v46 >> 5;
            if ((unint64_t)v46 >= 0x7FFFFFFFFFFFFFC0)
              v45 = 0x3FFFFFFFFFFFFFFLL;
            if (v45 >> 58)
              sub_1C4764EE4();
            v47 = v27;
            v58 = v45;
            v48 = (char *)operator new(v45 << 6);
            v49 = &v48[64 * v44];
            *(_DWORD *)v49 = 0;
            *((_QWORD *)v49 + 1) = v47;
            *((_QWORD *)v49 + 2) = v28;
            *((_QWORD *)v49 + 3) = v66;
            *((_QWORD *)v49 + 4) = a6;
            *((_QWORD *)v49 + 5) = v16;
            *((_QWORD *)v49 + 6) = v59;
            *((_QWORD *)v49 + 7) = v60;
            if (v40 == v43)
            {
              v54 = &v48[64 * v44];
              v15 = v64;
            }
            else
            {
              v50 = &v48[64 * v44];
              v15 = v64;
              do
              {
                v51 = *((_OWORD *)v40 - 4);
                v52 = *((_OWORD *)v40 - 3);
                v53 = *((_OWORD *)v40 - 1);
                v54 = v50 - 64;
                *((_OWORD *)v50 - 2) = *((_OWORD *)v40 - 2);
                *((_OWORD *)v50 - 1) = v53;
                *((_OWORD *)v50 - 4) = v51;
                *((_OWORD *)v50 - 3) = v52;
                v40 -= 8;
                v50 -= 64;
              }
              while (v40 != v43);
            }
            v41 = v49 + 64;
            *(_QWORD *)v38 = v54;
            *(_QWORD *)(v38 + 8) = v49 + 64;
            *(_QWORD *)(v38 + 16) = &v48[64 * v58];
            if (v43)
              operator delete(v43);
            v8 = a8;
            v9 = a7;
          }
          else
          {
            *(_DWORD *)v40 = 0;
            v40[1] = v27;
            v40[2] = v28;
            v40[3] = v66;
            v40[4] = a6;
            v40[5] = v16;
            v40[6] = v59;
            v41 = (char *)(v40 + 8);
            v40[7] = v60;
            v9 = a7;
            v15 = v64;
          }
          v42 = 0;
          *(_QWORD *)(v38 + 8) = v41;
          v13 = a1;
          v11 = a3;
        }
        else
        {
          v42 = operator new();
          *(_QWORD *)&v69[0] = "function name is empty";
          v70 = 259;
          *(_QWORD *)v42 = off_1E8192D50;
          *(_DWORD *)(v42 + 8) = 9;
          llvm::Twine::str((llvm::Twine *)v69, (_QWORD *)(v42 + 16));
          v15 = v64;
        }
        *v8 = v42;
        if (v42)
          return;
        goto LABEL_55;
      }
    }
    else
    {
      v27 = 0;
      v28 = 0;
      if (!v20)
        goto LABEL_31;
    }
    if (!v28)
      goto LABEL_64;
    goto LABEL_31;
  }
LABEL_63:
  v56 = 0;
LABEL_65:
  *v8 = v56;
}

_QWORD *sub_1C5471C1C(_QWORD *a1)
{
  *a1 = &off_1E8169238;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  return a1;
}

void sub_1C5471C60(_QWORD *a1)
{
  *a1 = &off_1E8169238;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5471CB4(uint64_t a1@<X0>, unsigned int *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unsigned int *v5;
  unsigned int v7;
  char *v8;
  unsigned int *v9;
  char *v10;
  uint64_t v11;
  unsigned int v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char **v17;
  char v18;
  unint64_t v19;
  char **v20;
  char *v21[3];
  __int128 v22;

  v5 = a2 + 4;
  if ((unint64_t)(a2 + 4) > a3)
    goto LABEL_3;
  v7 = bswap32(*a2);
  v8 = (char *)bswap32(a2[1]);
  v9 = &v5[5 * v7];
  v10 = &v8[(_QWORD)v9];
  if (&v8[(_QWORD)v9] > (char *)a3)
    goto LABEL_3;
  v13 = a2[2];
  v14 = *(char **)(a1 + 56);
  v16 = *(_QWORD *)v14;
  v15 = *((_QWORD *)v14 + 1);
  v21[0] = (char *)&v5[5 * v7];
  v21[1] = v8;
  v21[2] = v14;
  v22 = *(_OWORD *)(a1 + 40);
  llvm::coverage::RawCoverageFilenamesReader::read(v21, 1, &v20);
  v17 = v20;
  if (v20)
    goto LABEL_5;
  v19 = (unint64_t)&v10[bswap32(v13)];
  if (v19 > a3)
  {
LABEL_3:
    v11 = operator new();
    *(_QWORD *)v11 = &off_1E8169028;
    *(_DWORD *)(v11 + 8) = 5;
    *(_BYTE *)(a4 + 8) |= 1u;
    *(_QWORD *)a4 = v11;
    return;
  }
  (*(void (**)(char ***__return_ptr, uint64_t, unsigned int *, unsigned int *, unint64_t, uint64_t, char *, unint64_t))(*(_QWORD *)a1 + 24))(&v20, a1, v5, v9, (-1431655765 * ((v15 - v16) >> 3)) | ((unint64_t)(-1431655765* ((*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8)- **(_QWORD **)(a1 + 56)) >> 3)- -1431655765* ((v15 - v16) >> 3)) << 32), 1, v10, v19);
  v17 = v20;
  if (v20)
  {
LABEL_5:
    v18 = *(_BYTE *)(a4 + 8) | 1;
  }
  else
  {
    v17 = (char **)((v19 + 7) & 0xFFFFFFFFFFFFFFF8);
    v18 = *(_BYTE *)(a4 + 8) & 0xFE;
  }
  *(_BYTE *)(a4 + 8) = v18;
  *(_QWORD *)a4 = v17;
}

void sub_1C5471E40(uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, unint64_t a4@<X3>, char a5@<W4>, uint64_t a6@<X5>, unint64_t a7@<X6>, uint64_t *a8@<X8>)
{
  uint64_t *v8;
  unint64_t v9;
  unint64_t v11;
  uint64_t v12;
  BOOL v13;
  char v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t *v24;
  _QWORD *v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  _QWORD *v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  __n128 v39;
  char v40;
  uint64_t v41;
  char v42;
  _QWORD *v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  char *v47;
  char *v48;
  char *v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  unint64_t v65;
  uint64_t v66;
  unint64_t v68;
  char v69;
  uint64_t *v71;
  char v72;
  _OWORD v73[2];
  __int16 v74;
  uint64_t v75;
  char v76;
  uint64_t v77;
  char v78;
  uint64_t v79;

  v8 = a8;
  v79 = *MEMORY[0x1E0C80C00];
  if (a2 < a3)
  {
    v9 = a7;
    v11 = a2;
    v12 = a1;
    v63 = HIDWORD(a4);
    if (a5)
      v13 = HIDWORD(a4) == 0;
    else
      v13 = 1;
    v14 = v13;
    v66 = a1 + 8;
    v62 = a4;
    v65 = a3;
    v69 = v14;
    while (1)
    {
      v15 = bswap32(*(_DWORD *)(v11 + 8));
      if (a6 + v15 > v9)
      {
        v57 = operator new();
        *(_QWORD *)v57 = &off_1E8169028;
        *(_DWORD *)(v57 + 8) = 5;
        goto LABEL_63;
      }
      if ((v14 & 1) == 0)
        break;
LABEL_55:
      v11 += 20;
      a6 += v15;
      if (v11 >= a3)
        goto LABEL_61;
    }
    v16 = *(_QWORD *)(v11 + 12);
    v17 = (uint64_t)(*(_QWORD *)(*(_QWORD *)(v12 + 64) + 8) - **(_QWORD **)(v12 + 64)) >> 6;
    *(_QWORD *)&v73[0] = bswap64(*(_QWORD *)v11);
    *((_QWORD *)&v73[0] + 1) = v17;
    sub_1C546C7AC(&v71, v66, (uint64_t *)v73, (uint64_t *)v73 + 1);
    v68 = bswap64(v16);
    if (v72)
    {
      v18 = *(uint64_t **)(v12 + 32);
      v19 = bswap64(*(_QWORD *)v11);
      sub_1C546CB40(v18);
      v20 = (_QWORD *)v18[7];
      v21 = (_QWORD *)v18[8];
      if (v21 != v20)
      {
        v22 = 0xAAAAAAAAAAAAAAABLL * (v21 - v20);
        do
        {
          v23 = v22 >> 1;
          v24 = &v20[3 * (v22 >> 1)];
          v26 = *v24;
          v25 = v24 + 3;
          v22 += ~(v22 >> 1);
          if (v26 < v19)
            v20 = v25;
          else
            v22 = v23;
        }
        while (v22);
      }
      if (v20 != v21 && *v20 == v19 && (v27 = v20[2]) != 0)
      {
        v28 = v20[1];
        v29 = *(_QWORD *)(a1 + 64);
        v31 = *(_QWORD **)(v29 + 8);
        v30 = *(_QWORD *)(v29 + 16);
        if ((unint64_t)v31 >= v30)
        {
          v43 = *(_QWORD **)v29;
          v44 = ((uint64_t)v31 - *(_QWORD *)v29) >> 6;
          v45 = v44 + 1;
          if ((unint64_t)(v44 + 1) >> 58)
            abort();
          v59 = v28;
          v61 = *(_QWORD *)(a1 + 64);
          v46 = v30 - (_QWORD)v43;
          if (v46 >> 5 > v45)
            v45 = v46 >> 5;
          if ((unint64_t)v46 >= 0x7FFFFFFFFFFFFFC0)
            v45 = 0x3FFFFFFFFFFFFFFLL;
          if (v45 >> 58)
            sub_1C4764EE4();
          v58 = v45;
          v47 = (char *)operator new(v45 << 6);
          v48 = &v47[64 * v44];
          *(_DWORD *)v48 = 1;
          *((_QWORD *)v48 + 1) = v59;
          *((_QWORD *)v48 + 2) = v27;
          *((_QWORD *)v48 + 3) = v68;
          *((_QWORD *)v48 + 4) = a6;
          *((_QWORD *)v48 + 5) = v15;
          *((_QWORD *)v48 + 6) = v62;
          *((_QWORD *)v48 + 7) = v63;
          if (v31 == v43)
          {
            v53 = &v47[64 * v44];
            v9 = a7;
            v29 = v61;
          }
          else
          {
            v49 = &v47[64 * v44];
            v9 = a7;
            v29 = v61;
            do
            {
              v50 = *((_OWORD *)v31 - 4);
              v51 = *((_OWORD *)v31 - 3);
              v52 = *((_OWORD *)v31 - 1);
              v53 = v49 - 64;
              *((_OWORD *)v49 - 2) = *((_OWORD *)v31 - 2);
              *((_OWORD *)v49 - 1) = v52;
              *((_OWORD *)v49 - 4) = v50;
              *((_OWORD *)v49 - 3) = v51;
              v31 -= 8;
              v49 -= 64;
            }
            while (v31 != v43);
          }
          v32 = v48 + 64;
          *(_QWORD *)v29 = v53;
          *(_QWORD *)(v29 + 8) = v48 + 64;
          *(_QWORD *)(v29 + 16) = &v47[64 * v58];
          if (v43)
          {
            operator delete(v43);
            v29 = v61;
          }
        }
        else
        {
          *(_DWORD *)v31 = 1;
          v31[1] = v28;
          v31[2] = v27;
          v9 = a7;
          v31[3] = v68;
          v31[4] = a6;
          v31[5] = v15;
          v31[6] = v62;
          v32 = (char *)(v31 + 8);
          v31[7] = v63;
        }
        v8 = a8;
        v14 = v69;
        v33 = 0;
        *(_QWORD *)(v29 + 8) = v32;
      }
      else
      {
        v33 = operator new();
        *(_QWORD *)&v73[0] = "function name is empty";
        v74 = 259;
        *(_QWORD *)v33 = off_1E8192D50;
        *(_DWORD *)(v33 + 8) = 9;
        llvm::Twine::str((llvm::Twine *)v73, (_QWORD *)(v33 + 16));
        v9 = a7;
        v14 = v69;
      }
      *v8 = v33;
LABEL_54:
      a3 = v65;
      v12 = a1;
      if (v33)
        return;
      goto LABEL_55;
    }
    v34 = v71[1];
    v35 = **(_QWORD **)(v12 + 64);
    v36 = v35 + (v34 << 6);
    v38 = *(_QWORD *)(v36 + 24);
    v37 = v36 + 24;
    v39 = *(__n128 *)(v37 + 8);
    if (v38)
    {
      v40 = v78 & 0xFE;
      v78 &= ~1u;
      LOBYTE(v77) = 0;
    }
    else
    {
      v73[0] = *(_OWORD *)(v37 + 8);
      v60 = v34;
      v41 = v35;
      llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v73, (uint64_t)&v77);
      v35 = v41;
      v34 = v60;
      v40 = v78;
    }
    v14 = v69;
    if ((v40 & 1) != 0)
    {
      v33 = v77;
      v8 = a8;
      *a8 = v77;
    }
    else
    {
      if ((_BYTE)v77)
      {
        if (v16)
        {
          v76 &= ~1u;
          v42 = v76;
          LOBYTE(v75) = 0;
          if ((v76 & 1) == 0)
            goto LABEL_32;
        }
        else
        {
          *(_QWORD *)&v73[0] = a6;
          *((_QWORD *)&v73[0] + 1) = v15;
          v54 = v34;
          v55 = v35;
          llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v73, (uint64_t)&v75);
          v35 = v55;
          v34 = v54;
          v14 = v69;
          v42 = v76;
          if ((v76 & 1) == 0)
          {
LABEL_32:
            if ((_BYTE)v75)
            {
              v33 = 0;
              *a8 = 0;
LABEL_52:
              v8 = a8;
              goto LABEL_53;
            }
LABEL_48:
            v33 = 0;
            *(_QWORD *)v37 = v68;
            *(_QWORD *)(v37 + 8) = a6;
            *(_QWORD *)(v37 + 16) = v15;
            v56 = v35 + (v34 << 6);
            *(_QWORD *)(v56 + 48) = v62;
            *(_QWORD *)(v56 + 56) = v63;
            *a8 = 0;
            if ((v42 & 1) != 0)
            {
              if (v75)
              {
                (*(void (**)(uint64_t, __n128))(*(_QWORD *)v75 + 8))(v75, v39);
                v14 = v69;
              }
              v33 = 0;
            }
            goto LABEL_52;
          }
        }
        v33 = v75;
        v75 = 0;
        *a8 = v33;
        if (v33)
          goto LABEL_52;
        goto LABEL_48;
      }
      v33 = 0;
      v8 = a8;
      *a8 = 0;
    }
LABEL_53:
    v9 = a7;
    goto LABEL_54;
  }
LABEL_61:
  v57 = 0;
LABEL_63:
  *v8 = v57;
}

_QWORD *sub_1C5472338(_QWORD *a1)
{
  *a1 = &off_1E8169268;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  return a1;
}

void sub_1C547237C(_QWORD *a1)
{
  *a1 = &off_1E8169268;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C54723D0(uint64_t a1@<X0>, unsigned int *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unsigned int *v5;
  unsigned int v7;
  char *v8;
  unsigned int *v9;
  char *v10;
  uint64_t v11;
  unsigned int v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char **v17;
  char v18;
  unint64_t v19;
  char **v20;
  char *v21[3];
  __int128 v22;

  v5 = a2 + 4;
  if ((unint64_t)(a2 + 4) > a3)
    goto LABEL_3;
  v7 = bswap32(*a2);
  v8 = (char *)bswap32(a2[1]);
  v9 = &v5[5 * v7];
  v10 = &v8[(_QWORD)v9];
  if (&v8[(_QWORD)v9] > (char *)a3)
    goto LABEL_3;
  v13 = a2[2];
  v14 = *(char **)(a1 + 56);
  v16 = *(_QWORD *)v14;
  v15 = *((_QWORD *)v14 + 1);
  v21[0] = (char *)&v5[5 * v7];
  v21[1] = v8;
  v21[2] = v14;
  v22 = *(_OWORD *)(a1 + 40);
  llvm::coverage::RawCoverageFilenamesReader::read(v21, 2, &v20);
  v17 = v20;
  if (v20)
    goto LABEL_5;
  v19 = (unint64_t)&v10[bswap32(v13)];
  if (v19 > a3)
  {
LABEL_3:
    v11 = operator new();
    *(_QWORD *)v11 = &off_1E8169028;
    *(_DWORD *)(v11 + 8) = 5;
    *(_BYTE *)(a4 + 8) |= 1u;
    *(_QWORD *)a4 = v11;
    return;
  }
  (*(void (**)(char ***__return_ptr, uint64_t, unsigned int *, unsigned int *, unint64_t, uint64_t, char *, unint64_t))(*(_QWORD *)a1 + 24))(&v20, a1, v5, v9, (-1431655765 * ((v15 - v16) >> 3)) | ((unint64_t)(-1431655765* ((*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8)- **(_QWORD **)(a1 + 56)) >> 3)- -1431655765* ((v15 - v16) >> 3)) << 32), 1, v10, v19);
  v17 = v20;
  if (v20)
  {
LABEL_5:
    v18 = *(_BYTE *)(a4 + 8) | 1;
  }
  else
  {
    v17 = (char **)((v19 + 7) & 0xFFFFFFFFFFFFFFF8);
    v18 = *(_BYTE *)(a4 + 8) & 0xFE;
  }
  *(_BYTE *)(a4 + 8) = v18;
  *(_QWORD *)a4 = v17;
}

void sub_1C547255C(uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, unint64_t a4@<X3>, char a5@<W4>, uint64_t a6@<X5>, unint64_t a7@<X6>, uint64_t *a8@<X8>)
{
  uint64_t *v8;
  unint64_t v9;
  unint64_t v11;
  uint64_t v12;
  BOOL v13;
  char v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t *v24;
  _QWORD *v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  _QWORD *v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  __n128 v39;
  char v40;
  uint64_t v41;
  char v42;
  _QWORD *v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  char *v47;
  char *v48;
  char *v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  unint64_t v65;
  uint64_t v66;
  unint64_t v68;
  char v69;
  uint64_t *v71;
  char v72;
  _OWORD v73[2];
  __int16 v74;
  uint64_t v75;
  char v76;
  uint64_t v77;
  char v78;
  uint64_t v79;

  v8 = a8;
  v79 = *MEMORY[0x1E0C80C00];
  if (a2 < a3)
  {
    v9 = a7;
    v11 = a2;
    v12 = a1;
    v63 = HIDWORD(a4);
    if (a5)
      v13 = HIDWORD(a4) == 0;
    else
      v13 = 1;
    v14 = v13;
    v66 = a1 + 8;
    v62 = a4;
    v65 = a3;
    v69 = v14;
    while (1)
    {
      v15 = bswap32(*(_DWORD *)(v11 + 8));
      if (a6 + v15 > v9)
      {
        v57 = operator new();
        *(_QWORD *)v57 = &off_1E8169028;
        *(_DWORD *)(v57 + 8) = 5;
        goto LABEL_63;
      }
      if ((v14 & 1) == 0)
        break;
LABEL_55:
      v11 += 20;
      a6 += v15;
      if (v11 >= a3)
        goto LABEL_61;
    }
    v16 = *(_QWORD *)(v11 + 12);
    v17 = (uint64_t)(*(_QWORD *)(*(_QWORD *)(v12 + 64) + 8) - **(_QWORD **)(v12 + 64)) >> 6;
    *(_QWORD *)&v73[0] = bswap64(*(_QWORD *)v11);
    *((_QWORD *)&v73[0] + 1) = v17;
    sub_1C546C7AC(&v71, v66, (uint64_t *)v73, (uint64_t *)v73 + 1);
    v68 = bswap64(v16);
    if (v72)
    {
      v18 = *(uint64_t **)(v12 + 32);
      v19 = bswap64(*(_QWORD *)v11);
      sub_1C546CB40(v18);
      v20 = (_QWORD *)v18[7];
      v21 = (_QWORD *)v18[8];
      if (v21 != v20)
      {
        v22 = 0xAAAAAAAAAAAAAAABLL * (v21 - v20);
        do
        {
          v23 = v22 >> 1;
          v24 = &v20[3 * (v22 >> 1)];
          v26 = *v24;
          v25 = v24 + 3;
          v22 += ~(v22 >> 1);
          if (v26 < v19)
            v20 = v25;
          else
            v22 = v23;
        }
        while (v22);
      }
      if (v20 != v21 && *v20 == v19 && (v27 = v20[2]) != 0)
      {
        v28 = v20[1];
        v29 = *(_QWORD *)(a1 + 64);
        v31 = *(_QWORD **)(v29 + 8);
        v30 = *(_QWORD *)(v29 + 16);
        if ((unint64_t)v31 >= v30)
        {
          v43 = *(_QWORD **)v29;
          v44 = ((uint64_t)v31 - *(_QWORD *)v29) >> 6;
          v45 = v44 + 1;
          if ((unint64_t)(v44 + 1) >> 58)
            abort();
          v59 = v28;
          v61 = *(_QWORD *)(a1 + 64);
          v46 = v30 - (_QWORD)v43;
          if (v46 >> 5 > v45)
            v45 = v46 >> 5;
          if ((unint64_t)v46 >= 0x7FFFFFFFFFFFFFC0)
            v45 = 0x3FFFFFFFFFFFFFFLL;
          if (v45 >> 58)
            sub_1C4764EE4();
          v58 = v45;
          v47 = (char *)operator new(v45 << 6);
          v48 = &v47[64 * v44];
          *(_DWORD *)v48 = 2;
          *((_QWORD *)v48 + 1) = v59;
          *((_QWORD *)v48 + 2) = v27;
          *((_QWORD *)v48 + 3) = v68;
          *((_QWORD *)v48 + 4) = a6;
          *((_QWORD *)v48 + 5) = v15;
          *((_QWORD *)v48 + 6) = v62;
          *((_QWORD *)v48 + 7) = v63;
          if (v31 == v43)
          {
            v53 = &v47[64 * v44];
            v9 = a7;
            v29 = v61;
          }
          else
          {
            v49 = &v47[64 * v44];
            v9 = a7;
            v29 = v61;
            do
            {
              v50 = *((_OWORD *)v31 - 4);
              v51 = *((_OWORD *)v31 - 3);
              v52 = *((_OWORD *)v31 - 1);
              v53 = v49 - 64;
              *((_OWORD *)v49 - 2) = *((_OWORD *)v31 - 2);
              *((_OWORD *)v49 - 1) = v52;
              *((_OWORD *)v49 - 4) = v50;
              *((_OWORD *)v49 - 3) = v51;
              v31 -= 8;
              v49 -= 64;
            }
            while (v31 != v43);
          }
          v32 = v48 + 64;
          *(_QWORD *)v29 = v53;
          *(_QWORD *)(v29 + 8) = v48 + 64;
          *(_QWORD *)(v29 + 16) = &v47[64 * v58];
          if (v43)
          {
            operator delete(v43);
            v29 = v61;
          }
        }
        else
        {
          *(_DWORD *)v31 = 2;
          v31[1] = v28;
          v31[2] = v27;
          v9 = a7;
          v31[3] = v68;
          v31[4] = a6;
          v31[5] = v15;
          v31[6] = v62;
          v32 = (char *)(v31 + 8);
          v31[7] = v63;
        }
        v8 = a8;
        v14 = v69;
        v33 = 0;
        *(_QWORD *)(v29 + 8) = v32;
      }
      else
      {
        v33 = operator new();
        *(_QWORD *)&v73[0] = "function name is empty";
        v74 = 259;
        *(_QWORD *)v33 = off_1E8192D50;
        *(_DWORD *)(v33 + 8) = 9;
        llvm::Twine::str((llvm::Twine *)v73, (_QWORD *)(v33 + 16));
        v9 = a7;
        v14 = v69;
      }
      *v8 = v33;
LABEL_54:
      a3 = v65;
      v12 = a1;
      if (v33)
        return;
      goto LABEL_55;
    }
    v34 = v71[1];
    v35 = **(_QWORD **)(v12 + 64);
    v36 = v35 + (v34 << 6);
    v38 = *(_QWORD *)(v36 + 24);
    v37 = v36 + 24;
    v39 = *(__n128 *)(v37 + 8);
    if (v38)
    {
      v40 = v78 & 0xFE;
      v78 &= ~1u;
      LOBYTE(v77) = 0;
    }
    else
    {
      v73[0] = *(_OWORD *)(v37 + 8);
      v60 = v34;
      v41 = v35;
      llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v73, (uint64_t)&v77);
      v35 = v41;
      v34 = v60;
      v40 = v78;
    }
    v14 = v69;
    if ((v40 & 1) != 0)
    {
      v33 = v77;
      v8 = a8;
      *a8 = v77;
    }
    else
    {
      if ((_BYTE)v77)
      {
        if (v16)
        {
          v76 &= ~1u;
          v42 = v76;
          LOBYTE(v75) = 0;
          if ((v76 & 1) == 0)
            goto LABEL_32;
        }
        else
        {
          *(_QWORD *)&v73[0] = a6;
          *((_QWORD *)&v73[0] + 1) = v15;
          v54 = v34;
          v55 = v35;
          llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v73, (uint64_t)&v75);
          v35 = v55;
          v34 = v54;
          v14 = v69;
          v42 = v76;
          if ((v76 & 1) == 0)
          {
LABEL_32:
            if ((_BYTE)v75)
            {
              v33 = 0;
              *a8 = 0;
LABEL_52:
              v8 = a8;
              goto LABEL_53;
            }
LABEL_48:
            v33 = 0;
            *(_QWORD *)v37 = v68;
            *(_QWORD *)(v37 + 8) = a6;
            *(_QWORD *)(v37 + 16) = v15;
            v56 = v35 + (v34 << 6);
            *(_QWORD *)(v56 + 48) = v62;
            *(_QWORD *)(v56 + 56) = v63;
            *a8 = 0;
            if ((v42 & 1) != 0)
            {
              if (v75)
              {
                (*(void (**)(uint64_t, __n128))(*(_QWORD *)v75 + 8))(v75, v39);
                v14 = v69;
              }
              v33 = 0;
            }
            goto LABEL_52;
          }
        }
        v33 = v75;
        v75 = 0;
        *a8 = v33;
        if (v33)
          goto LABEL_52;
        goto LABEL_48;
      }
      v33 = 0;
      v8 = a8;
      *a8 = 0;
    }
LABEL_53:
    v9 = a7;
    goto LABEL_54;
  }
LABEL_61:
  v57 = 0;
LABEL_63:
  *v8 = v57;
}

_QWORD *sub_1C5472A54(_QWORD *a1)
{
  *a1 = &off_1E8169298;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  return a1;
}

void sub_1C5472A98(_QWORD *a1)
{
  *a1 = &off_1E8169298;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5472AEC(uint64_t a1@<X0>, unsigned int *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  size_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  unsigned int v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned __int8 **v24;
  unsigned __int8 **v25;
  char v26;
  uint64_t v27;
  unsigned __int8 *v28;
  char v29;
  int v30;
  unsigned __int8 *v31;
  unsigned __int8 *v32;
  uint64_t v33;
  char *v34[3];
  __int128 v35;
  uint64_t v36;
  unint64_t v37;
  __int128 v38;
  uint64_t v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  if ((unint64_t)(a2 + 4) > a3)
    goto LABEL_3;
  v5 = bswap32(a2[1]);
  v6 = (char *)a2 + 29 * bswap32(*a2) + 16;
  v7 = &v6[v5];
  if ((unint64_t)&v6[v5] > a3)
    goto LABEL_3;
  v10 = a2[2];
  v11 = *(char **)(a1 + 56);
  v13 = *(_QWORD *)v11;
  v12 = *((_QWORD *)v11 + 1);
  v34[0] = v6;
  v34[1] = (char *)v5;
  v34[2] = v11;
  v35 = *(_OWORD *)(a1 + 40);
  llvm::coverage::RawCoverageFilenamesReader::read(v34, 3, (char ***)&v38);
  v14 = v38;
  if ((_QWORD)v38)
  {
    v15 = *(_BYTE *)(a4 + 8) | 1;
LABEL_7:
    *(_BYTE *)(a4 + 8) = v15;
    *(_QWORD *)a4 = v14;
    return;
  }
  v16 = 0xAAAAAAAAAAAAAAABLL * ((v12 - v13) >> 3);
  v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) - **(_QWORD **)(a1 + 56)) >> 3) - v16;
  v38 = xmmword_1C85F4BB0;
  v39 = 0;
  llvm::MD5::update((int *)&v38, (int *)v6, v5);
  llvm::MD5::final((int *)&v38, (int *)&v36);
  v37 = v16 | ((unint64_t)v17 << 32);
  sub_1C54701B8((uint64_t **)&v38, a1 + 72, &v36, (uint64_t *)&v37);
  if (!(_BYTE)v39)
  {
    v18 = v38;
    v19 = *(unsigned int *)(v38 + 12);
    if (v17 != v19)
      goto LABEL_31;
    v20 = v16;
    v21 = **(_QWORD **)(a1 + 56);
    v22 = v21 + 24 * *(unsigned int *)(v38 + 8);
    v23 = v22 + 24 * v19;
    v24 = (unsigned __int8 **)(v21 + 24 * v20);
    v25 = &v24[3 * v17];
    if ((_DWORD)v19)
    {
      do
      {
        v26 = *(_BYTE *)(v22 + 23);
        v27 = v26 & 0x7F;
        if (v26 >= 0)
          v28 = (unsigned __int8 *)(v26 & 0x7F);
        else
          v28 = *(unsigned __int8 **)(v22 + 8);
        v29 = *((_BYTE *)v24 + 23);
        v30 = v29;
        v31 = (unsigned __int8 *)(v29 & 0x7F);
        if (v30 < 0)
          v31 = v24[1];
        if (v28 != v31)
          goto LABEL_31;
        if (v30 >= 0)
          v32 = (unsigned __int8 *)v24;
        else
          v32 = *v24;
        if ((*(_BYTE *)(v22 + 23) & 0x80) != 0)
        {
          if (memcmp(*(const void **)v22, v32, *(_QWORD *)(v22 + 8)))
            goto LABEL_31;
        }
        else if ((v26 & 0x7F) != 0)
        {
          v33 = 0;
          while (*(unsigned __int8 *)(v22 + v33) == v32[v33])
          {
            if (v27 == ++v33)
              goto LABEL_27;
          }
          goto LABEL_31;
        }
LABEL_27:
        v22 += 24;
        v24 += 3;
      }
      while (v22 != v23 && v24 != v25);
    }
    if (v22 != v23 || v24 != v25)
LABEL_31:
      *(_DWORD *)(v18 + 12) = 0;
  }
  if (!v10)
  {
    v14 = (unint64_t)(v7 + 7) & 0xFFFFFFFFFFFFFFF8;
    v15 = *(_BYTE *)(a4 + 8) & 0xFE;
    goto LABEL_7;
  }
LABEL_3:
  v8 = operator new();
  *(_QWORD *)v8 = &off_1E8169028;
  *(_DWORD *)(v8 + 8) = 5;
  *(_BYTE *)(a4 + 8) |= 1u;
  *(_QWORD *)a4 = v8;
}

void sub_1C5472D98(uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  unint64_t v4;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  unint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  _QWORD *v30;
  char *v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t *v39;
  __n128 v40;
  char v41;
  uint64_t *v42;
  _QWORD *v43;
  unint64_t v44;
  uint64_t v45;
  char *v46;
  char *v47;
  char *v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  char *v52;
  uint64_t v53;
  unint64_t *v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  unint64_t v67;
  uint64_t *v69;
  char v70;
  _OWORD v71[2];
  __int16 v72;
  uint64_t v73;
  char v74;
  uint64_t v75;
  char v76;
  uint64_t v77;

  v77 = *MEMORY[0x1E0C80C00];
  if (a2 < a3)
  {
    v4 = a2;
    v65 = a1 + 8;
    while (1)
    {
      v6 = *(_DWORD *)(v4 + 8);
      v7 = *(_QWORD *)(a1 + 72);
      v8 = *(unsigned int *)(a1 + 88);
      v9 = sub_1C5470560(v7, *(_DWORD *)(a1 + 88), bswap64(*(_QWORD *)(v4 + 20)));
      if ((uint64_t *)(v7 + 16 * v8) == v9)
      {
LABEL_57:
        v56 = operator new();
        *(_QWORD *)v56 = &off_1E8169028;
        *(_DWORD *)(v56 + 8) = 5;
        goto LABEL_58;
      }
      v10 = v4 + 28;
      v11 = bswap32(v6);
      v12 = v4 + 28 + v11;
      v13 = v9[1];
      v14 = HIDWORD(v13);
      if (HIDWORD(v13))
        break;
LABEL_29:
      v4 = (v12 + 7) & 0xFFFFFFFFFFFFFFF8;
      if (v4 >= a3)
        goto LABEL_56;
    }
    if (v12 > a3)
      goto LABEL_57;
    v67 = v4 + 28 + v11;
    v15 = *(_QWORD *)(v4 + 12);
    v64 = bswap64(v15);
    v16 = (uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) - **(_QWORD **)(a1 + 64)) >> 6;
    *(_QWORD *)&v71[0] = bswap64(*(_QWORD *)v4);
    *((_QWORD *)&v71[0] + 1) = v16;
    sub_1C546C7AC(&v69, v65, (uint64_t *)v71, (uint64_t *)v71 + 1);
    if (v70)
    {
      v17 = *(uint64_t **)(a1 + 32);
      v18 = bswap64(*(_QWORD *)v4);
      sub_1C546CB40(v17);
      v19 = (_QWORD *)v17[7];
      v20 = (_QWORD *)v17[8];
      if (v20 != v19)
      {
        v21 = 0xAAAAAAAAAAAAAAABLL * (v20 - v19);
        do
        {
          v22 = v21 >> 1;
          v23 = &v19[3 * (v21 >> 1)];
          v25 = *v23;
          v24 = v23 + 3;
          v21 += ~(v21 >> 1);
          if (v25 < v18)
            v19 = v24;
          else
            v21 = v22;
        }
        while (v21);
      }
      if (v19 != v20 && *v19 == v18 && (v26 = v19[2]) != 0)
      {
        v27 = v19[1];
        v28 = *(_QWORD *)(a1 + 64);
        v30 = *(_QWORD **)(v28 + 8);
        v29 = *(_QWORD *)(v28 + 16);
        if ((unint64_t)v30 >= v29)
        {
          v43 = *(_QWORD **)v28;
          v44 = (((uint64_t)v30 - *(_QWORD *)v28) >> 6) + 1;
          if (v44 >> 58)
            abort();
          v58 = ((uint64_t)v30 - *(_QWORD *)v28) >> 6;
          v60 = v27;
          v62 = *(_QWORD *)(a1 + 64);
          v45 = v29 - (_QWORD)v43;
          if (v45 >> 5 > v44)
            v44 = v45 >> 5;
          if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFC0)
            v44 = 0x3FFFFFFFFFFFFFFLL;
          if (v44 >> 58)
            sub_1C4764EE4();
          v57 = v44;
          v46 = (char *)operator new(v44 << 6);
          v47 = &v46[64 * v58];
          *(_DWORD *)v47 = 3;
          *((_QWORD *)v47 + 1) = v60;
          *((_QWORD *)v47 + 2) = v26;
          *((_QWORD *)v47 + 3) = v64;
          *((_QWORD *)v47 + 4) = v10;
          *((_QWORD *)v47 + 5) = v11;
          *((_QWORD *)v47 + 6) = v13;
          *((_QWORD *)v47 + 7) = v14;
          if (v30 == v43)
          {
            v52 = &v46[64 * v58];
            v12 = v67;
            v28 = v62;
          }
          else
          {
            v48 = &v46[64 * v58];
            v12 = v67;
            v28 = v62;
            do
            {
              v49 = *((_OWORD *)v30 - 4);
              v50 = *((_OWORD *)v30 - 3);
              v51 = *((_OWORD *)v30 - 1);
              v52 = v48 - 64;
              *((_OWORD *)v48 - 2) = *((_OWORD *)v30 - 2);
              *((_OWORD *)v48 - 1) = v51;
              *((_OWORD *)v48 - 4) = v49;
              *((_OWORD *)v48 - 3) = v50;
              v30 -= 8;
              v48 -= 64;
            }
            while (v30 != v43);
          }
          v31 = v47 + 64;
          *(_QWORD *)v28 = v52;
          *(_QWORD *)(v28 + 8) = v47 + 64;
          *(_QWORD *)(v28 + 16) = &v46[64 * v57];
          if (v43)
          {
            operator delete(v43);
            v28 = v62;
          }
        }
        else
        {
          *(_DWORD *)v30 = 3;
          v30[1] = v27;
          v30[2] = v26;
          v30[3] = v64;
          v30[4] = v10;
          v30[5] = v11;
          v30[6] = v13;
          v31 = (char *)(v30 + 8);
          v30[7] = v14;
          v12 = v67;
        }
        v32 = 0;
        *(_QWORD *)(v28 + 8) = v31;
      }
      else
      {
        v32 = operator new();
        *(_QWORD *)&v71[0] = "function name is empty";
        v72 = 259;
        *(_QWORD *)v32 = off_1E8192D50;
        *(_DWORD *)(v32 + 8) = 9;
        llvm::Twine::str((llvm::Twine *)v71, (_QWORD *)(v32 + 16));
        v12 = v67;
      }
      v33 = a4;
      goto LABEL_27;
    }
    v34 = v69[1];
    v35 = **(_QWORD **)(a1 + 64);
    v36 = v35 + (v34 << 6);
    v38 = *(_QWORD *)(v36 + 24);
    v37 = v36 + 24;
    v39 = (unint64_t *)(v37 + 8);
    v40 = *(__n128 *)(v37 + 8);
    if (v38)
    {
      v76 &= ~1u;
      LOBYTE(v75) = 0;
      if ((v76 & 1) == 0)
        goto LABEL_22;
    }
    else
    {
      v71[0] = *(_OWORD *)(v37 + 8);
      v59 = v35;
      v61 = v34;
      llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v71, (uint64_t)&v75);
      v35 = v59;
      v34 = v61;
      v39 = (unint64_t *)(v37 + 8);
      if ((v76 & 1) == 0)
      {
LABEL_22:
        if (!(_BYTE)v75)
        {
          v32 = 0;
          v42 = a4;
          v12 = v67;
LABEL_46:
          *v42 = 0;
          goto LABEL_28;
        }
        if (v15)
        {
          v41 = v74 & 0xFE;
          v74 &= ~1u;
          LOBYTE(v73) = 0;
        }
        else
        {
          *(_QWORD *)&v71[0] = v4 + 28;
          *((_QWORD *)&v71[0] + 1) = v11;
          v53 = v35;
          v54 = v39;
          v63 = v34;
          llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v71, (uint64_t)&v73);
          v34 = v63;
          v39 = v54;
          v35 = v53;
          v41 = v74;
        }
        v12 = v67;
        if ((v41 & 1) != 0)
        {
          v32 = v73;
          v73 = 0;
          *a4 = v32;
          if (v32)
            goto LABEL_28;
        }
        else if ((_BYTE)v73)
        {
          v32 = 0;
          v42 = a4;
          goto LABEL_46;
        }
        v32 = 0;
        *(_QWORD *)v37 = v64;
        *v39 = v10;
        v39[1] = v11;
        v55 = v35 + (v34 << 6);
        *(_QWORD *)(v55 + 48) = v13;
        *(_QWORD *)(v55 + 56) = v14;
        *a4 = 0;
        if ((v41 & 1) != 0)
        {
          if (v73)
            (*(void (**)(uint64_t, __n128))(*(_QWORD *)v73 + 8))(v73, v40);
          v32 = 0;
        }
LABEL_28:
        if (v32)
          return;
        goto LABEL_29;
      }
    }
    v32 = v75;
    v33 = a4;
    v12 = v67;
LABEL_27:
    *v33 = v32;
    goto LABEL_28;
  }
LABEL_56:
  v56 = 0;
LABEL_58:
  *a4 = v56;
}

_QWORD *sub_1C5473278(_QWORD *a1)
{
  *a1 = &off_1E81692C8;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  return a1;
}

void sub_1C54732BC(_QWORD *a1)
{
  *a1 = &off_1E81692C8;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5473310(uint64_t a1@<X0>, unsigned int *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  size_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  unsigned int v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned __int8 **v24;
  unsigned __int8 **v25;
  char v26;
  uint64_t v27;
  unsigned __int8 *v28;
  char v29;
  int v30;
  unsigned __int8 *v31;
  unsigned __int8 *v32;
  uint64_t v33;
  char *v34[3];
  __int128 v35;
  uint64_t v36;
  unint64_t v37;
  __int128 v38;
  uint64_t v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  if ((unint64_t)(a2 + 4) > a3)
    goto LABEL_3;
  v5 = bswap32(a2[1]);
  v6 = (char *)a2 + 29 * bswap32(*a2) + 16;
  v7 = &v6[v5];
  if ((unint64_t)&v6[v5] > a3)
    goto LABEL_3;
  v10 = a2[2];
  v11 = *(char **)(a1 + 56);
  v13 = *(_QWORD *)v11;
  v12 = *((_QWORD *)v11 + 1);
  v34[0] = v6;
  v34[1] = (char *)v5;
  v34[2] = v11;
  v35 = *(_OWORD *)(a1 + 40);
  llvm::coverage::RawCoverageFilenamesReader::read(v34, 4, (char ***)&v38);
  v14 = v38;
  if ((_QWORD)v38)
  {
    v15 = *(_BYTE *)(a4 + 8) | 1;
LABEL_7:
    *(_BYTE *)(a4 + 8) = v15;
    *(_QWORD *)a4 = v14;
    return;
  }
  v16 = 0xAAAAAAAAAAAAAAABLL * ((v12 - v13) >> 3);
  v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) - **(_QWORD **)(a1 + 56)) >> 3) - v16;
  v38 = xmmword_1C85F4BB0;
  v39 = 0;
  llvm::MD5::update((int *)&v38, (int *)v6, v5);
  llvm::MD5::final((int *)&v38, (int *)&v36);
  v37 = v16 | ((unint64_t)v17 << 32);
  sub_1C54701B8((uint64_t **)&v38, a1 + 72, &v36, (uint64_t *)&v37);
  if (!(_BYTE)v39)
  {
    v18 = v38;
    v19 = *(unsigned int *)(v38 + 12);
    if (v17 != v19)
      goto LABEL_31;
    v20 = v16;
    v21 = **(_QWORD **)(a1 + 56);
    v22 = v21 + 24 * *(unsigned int *)(v38 + 8);
    v23 = v22 + 24 * v19;
    v24 = (unsigned __int8 **)(v21 + 24 * v20);
    v25 = &v24[3 * v17];
    if ((_DWORD)v19)
    {
      do
      {
        v26 = *(_BYTE *)(v22 + 23);
        v27 = v26 & 0x7F;
        if (v26 >= 0)
          v28 = (unsigned __int8 *)(v26 & 0x7F);
        else
          v28 = *(unsigned __int8 **)(v22 + 8);
        v29 = *((_BYTE *)v24 + 23);
        v30 = v29;
        v31 = (unsigned __int8 *)(v29 & 0x7F);
        if (v30 < 0)
          v31 = v24[1];
        if (v28 != v31)
          goto LABEL_31;
        if (v30 >= 0)
          v32 = (unsigned __int8 *)v24;
        else
          v32 = *v24;
        if ((*(_BYTE *)(v22 + 23) & 0x80) != 0)
        {
          if (memcmp(*(const void **)v22, v32, *(_QWORD *)(v22 + 8)))
            goto LABEL_31;
        }
        else if ((v26 & 0x7F) != 0)
        {
          v33 = 0;
          while (*(unsigned __int8 *)(v22 + v33) == v32[v33])
          {
            if (v27 == ++v33)
              goto LABEL_27;
          }
          goto LABEL_31;
        }
LABEL_27:
        v22 += 24;
        v24 += 3;
      }
      while (v22 != v23 && v24 != v25);
    }
    if (v22 != v23 || v24 != v25)
LABEL_31:
      *(_DWORD *)(v18 + 12) = 0;
  }
  if (!v10)
  {
    v14 = (unint64_t)(v7 + 7) & 0xFFFFFFFFFFFFFFF8;
    v15 = *(_BYTE *)(a4 + 8) & 0xFE;
    goto LABEL_7;
  }
LABEL_3:
  v8 = operator new();
  *(_QWORD *)v8 = &off_1E8169028;
  *(_DWORD *)(v8 + 8) = 5;
  *(_BYTE *)(a4 + 8) |= 1u;
  *(_QWORD *)a4 = v8;
}

void sub_1C54735BC(uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  unint64_t v4;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  unint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  _QWORD *v30;
  char *v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t *v39;
  __n128 v40;
  char v41;
  uint64_t *v42;
  _QWORD *v43;
  unint64_t v44;
  uint64_t v45;
  char *v46;
  char *v47;
  char *v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  char *v52;
  uint64_t v53;
  unint64_t *v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  unint64_t v67;
  uint64_t *v69;
  char v70;
  _OWORD v71[2];
  __int16 v72;
  uint64_t v73;
  char v74;
  uint64_t v75;
  char v76;
  uint64_t v77;

  v77 = *MEMORY[0x1E0C80C00];
  if (a2 < a3)
  {
    v4 = a2;
    v65 = a1 + 8;
    while (1)
    {
      v6 = *(_DWORD *)(v4 + 8);
      v7 = *(_QWORD *)(a1 + 72);
      v8 = *(unsigned int *)(a1 + 88);
      v9 = sub_1C5470560(v7, *(_DWORD *)(a1 + 88), bswap64(*(_QWORD *)(v4 + 20)));
      if ((uint64_t *)(v7 + 16 * v8) == v9)
      {
LABEL_57:
        v56 = operator new();
        *(_QWORD *)v56 = &off_1E8169028;
        *(_DWORD *)(v56 + 8) = 5;
        goto LABEL_58;
      }
      v10 = v4 + 28;
      v11 = bswap32(v6);
      v12 = v4 + 28 + v11;
      v13 = v9[1];
      v14 = HIDWORD(v13);
      if (HIDWORD(v13))
        break;
LABEL_29:
      v4 = (v12 + 7) & 0xFFFFFFFFFFFFFFF8;
      if (v4 >= a3)
        goto LABEL_56;
    }
    if (v12 > a3)
      goto LABEL_57;
    v67 = v4 + 28 + v11;
    v15 = *(_QWORD *)(v4 + 12);
    v64 = bswap64(v15);
    v16 = (uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) - **(_QWORD **)(a1 + 64)) >> 6;
    *(_QWORD *)&v71[0] = bswap64(*(_QWORD *)v4);
    *((_QWORD *)&v71[0] + 1) = v16;
    sub_1C546C7AC(&v69, v65, (uint64_t *)v71, (uint64_t *)v71 + 1);
    if (v70)
    {
      v17 = *(uint64_t **)(a1 + 32);
      v18 = bswap64(*(_QWORD *)v4);
      sub_1C546CB40(v17);
      v19 = (_QWORD *)v17[7];
      v20 = (_QWORD *)v17[8];
      if (v20 != v19)
      {
        v21 = 0xAAAAAAAAAAAAAAABLL * (v20 - v19);
        do
        {
          v22 = v21 >> 1;
          v23 = &v19[3 * (v21 >> 1)];
          v25 = *v23;
          v24 = v23 + 3;
          v21 += ~(v21 >> 1);
          if (v25 < v18)
            v19 = v24;
          else
            v21 = v22;
        }
        while (v21);
      }
      if (v19 != v20 && *v19 == v18 && (v26 = v19[2]) != 0)
      {
        v27 = v19[1];
        v28 = *(_QWORD *)(a1 + 64);
        v30 = *(_QWORD **)(v28 + 8);
        v29 = *(_QWORD *)(v28 + 16);
        if ((unint64_t)v30 >= v29)
        {
          v43 = *(_QWORD **)v28;
          v44 = (((uint64_t)v30 - *(_QWORD *)v28) >> 6) + 1;
          if (v44 >> 58)
            abort();
          v58 = ((uint64_t)v30 - *(_QWORD *)v28) >> 6;
          v60 = v27;
          v62 = *(_QWORD *)(a1 + 64);
          v45 = v29 - (_QWORD)v43;
          if (v45 >> 5 > v44)
            v44 = v45 >> 5;
          if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFC0)
            v44 = 0x3FFFFFFFFFFFFFFLL;
          if (v44 >> 58)
            sub_1C4764EE4();
          v57 = v44;
          v46 = (char *)operator new(v44 << 6);
          v47 = &v46[64 * v58];
          *(_DWORD *)v47 = 4;
          *((_QWORD *)v47 + 1) = v60;
          *((_QWORD *)v47 + 2) = v26;
          *((_QWORD *)v47 + 3) = v64;
          *((_QWORD *)v47 + 4) = v10;
          *((_QWORD *)v47 + 5) = v11;
          *((_QWORD *)v47 + 6) = v13;
          *((_QWORD *)v47 + 7) = v14;
          if (v30 == v43)
          {
            v52 = &v46[64 * v58];
            v12 = v67;
            v28 = v62;
          }
          else
          {
            v48 = &v46[64 * v58];
            v12 = v67;
            v28 = v62;
            do
            {
              v49 = *((_OWORD *)v30 - 4);
              v50 = *((_OWORD *)v30 - 3);
              v51 = *((_OWORD *)v30 - 1);
              v52 = v48 - 64;
              *((_OWORD *)v48 - 2) = *((_OWORD *)v30 - 2);
              *((_OWORD *)v48 - 1) = v51;
              *((_OWORD *)v48 - 4) = v49;
              *((_OWORD *)v48 - 3) = v50;
              v30 -= 8;
              v48 -= 64;
            }
            while (v30 != v43);
          }
          v31 = v47 + 64;
          *(_QWORD *)v28 = v52;
          *(_QWORD *)(v28 + 8) = v47 + 64;
          *(_QWORD *)(v28 + 16) = &v46[64 * v57];
          if (v43)
          {
            operator delete(v43);
            v28 = v62;
          }
        }
        else
        {
          *(_DWORD *)v30 = 4;
          v30[1] = v27;
          v30[2] = v26;
          v30[3] = v64;
          v30[4] = v10;
          v30[5] = v11;
          v30[6] = v13;
          v31 = (char *)(v30 + 8);
          v30[7] = v14;
          v12 = v67;
        }
        v32 = 0;
        *(_QWORD *)(v28 + 8) = v31;
      }
      else
      {
        v32 = operator new();
        *(_QWORD *)&v71[0] = "function name is empty";
        v72 = 259;
        *(_QWORD *)v32 = off_1E8192D50;
        *(_DWORD *)(v32 + 8) = 9;
        llvm::Twine::str((llvm::Twine *)v71, (_QWORD *)(v32 + 16));
        v12 = v67;
      }
      v33 = a4;
      goto LABEL_27;
    }
    v34 = v69[1];
    v35 = **(_QWORD **)(a1 + 64);
    v36 = v35 + (v34 << 6);
    v38 = *(_QWORD *)(v36 + 24);
    v37 = v36 + 24;
    v39 = (unint64_t *)(v37 + 8);
    v40 = *(__n128 *)(v37 + 8);
    if (v38)
    {
      v76 &= ~1u;
      LOBYTE(v75) = 0;
      if ((v76 & 1) == 0)
        goto LABEL_22;
    }
    else
    {
      v71[0] = *(_OWORD *)(v37 + 8);
      v59 = v35;
      v61 = v34;
      llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v71, (uint64_t)&v75);
      v35 = v59;
      v34 = v61;
      v39 = (unint64_t *)(v37 + 8);
      if ((v76 & 1) == 0)
      {
LABEL_22:
        if (!(_BYTE)v75)
        {
          v32 = 0;
          v42 = a4;
          v12 = v67;
LABEL_46:
          *v42 = 0;
          goto LABEL_28;
        }
        if (v15)
        {
          v41 = v74 & 0xFE;
          v74 &= ~1u;
          LOBYTE(v73) = 0;
        }
        else
        {
          *(_QWORD *)&v71[0] = v4 + 28;
          *((_QWORD *)&v71[0] + 1) = v11;
          v53 = v35;
          v54 = v39;
          v63 = v34;
          llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v71, (uint64_t)&v73);
          v34 = v63;
          v39 = v54;
          v35 = v53;
          v41 = v74;
        }
        v12 = v67;
        if ((v41 & 1) != 0)
        {
          v32 = v73;
          v73 = 0;
          *a4 = v32;
          if (v32)
            goto LABEL_28;
        }
        else if ((_BYTE)v73)
        {
          v32 = 0;
          v42 = a4;
          goto LABEL_46;
        }
        v32 = 0;
        *(_QWORD *)v37 = v64;
        *v39 = v10;
        v39[1] = v11;
        v55 = v35 + (v34 << 6);
        *(_QWORD *)(v55 + 48) = v13;
        *(_QWORD *)(v55 + 56) = v14;
        *a4 = 0;
        if ((v41 & 1) != 0)
        {
          if (v73)
            (*(void (**)(uint64_t, __n128))(*(_QWORD *)v73 + 8))(v73, v40);
          v32 = 0;
        }
LABEL_28:
        if (v32)
          return;
        goto LABEL_29;
      }
    }
    v32 = v75;
    v33 = a4;
    v12 = v67;
LABEL_27:
    *v33 = v32;
    goto LABEL_28;
  }
LABEL_56:
  v56 = 0;
LABEL_58:
  *a4 = v56;
}

_QWORD *sub_1C5473A9C(_QWORD *a1)
{
  *a1 = &off_1E81692F8;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  return a1;
}

void sub_1C5473AE0(_QWORD *a1)
{
  *a1 = &off_1E81692F8;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5473B34(uint64_t a1@<X0>, unsigned int *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  size_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  unsigned int v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned __int8 **v24;
  unsigned __int8 **v25;
  char v26;
  uint64_t v27;
  unsigned __int8 *v28;
  char v29;
  int v30;
  unsigned __int8 *v31;
  unsigned __int8 *v32;
  uint64_t v33;
  char *v34[3];
  __int128 v35;
  uint64_t v36;
  unint64_t v37;
  __int128 v38;
  uint64_t v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  if ((unint64_t)(a2 + 4) > a3)
    goto LABEL_3;
  v5 = bswap32(a2[1]);
  v6 = (char *)a2 + 29 * bswap32(*a2) + 16;
  v7 = &v6[v5];
  if ((unint64_t)&v6[v5] > a3)
    goto LABEL_3;
  v10 = a2[2];
  v11 = *(char **)(a1 + 56);
  v13 = *(_QWORD *)v11;
  v12 = *((_QWORD *)v11 + 1);
  v34[0] = v6;
  v34[1] = (char *)v5;
  v34[2] = v11;
  v35 = *(_OWORD *)(a1 + 40);
  llvm::coverage::RawCoverageFilenamesReader::read(v34, 5, (char ***)&v38);
  v14 = v38;
  if ((_QWORD)v38)
  {
    v15 = *(_BYTE *)(a4 + 8) | 1;
LABEL_7:
    *(_BYTE *)(a4 + 8) = v15;
    *(_QWORD *)a4 = v14;
    return;
  }
  v16 = 0xAAAAAAAAAAAAAAABLL * ((v12 - v13) >> 3);
  v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) - **(_QWORD **)(a1 + 56)) >> 3) - v16;
  v38 = xmmword_1C85F4BB0;
  v39 = 0;
  llvm::MD5::update((int *)&v38, (int *)v6, v5);
  llvm::MD5::final((int *)&v38, (int *)&v36);
  v37 = v16 | ((unint64_t)v17 << 32);
  sub_1C54701B8((uint64_t **)&v38, a1 + 72, &v36, (uint64_t *)&v37);
  if (!(_BYTE)v39)
  {
    v18 = v38;
    v19 = *(unsigned int *)(v38 + 12);
    if (v17 != v19)
      goto LABEL_31;
    v20 = v16;
    v21 = **(_QWORD **)(a1 + 56);
    v22 = v21 + 24 * *(unsigned int *)(v38 + 8);
    v23 = v22 + 24 * v19;
    v24 = (unsigned __int8 **)(v21 + 24 * v20);
    v25 = &v24[3 * v17];
    if ((_DWORD)v19)
    {
      do
      {
        v26 = *(_BYTE *)(v22 + 23);
        v27 = v26 & 0x7F;
        if (v26 >= 0)
          v28 = (unsigned __int8 *)(v26 & 0x7F);
        else
          v28 = *(unsigned __int8 **)(v22 + 8);
        v29 = *((_BYTE *)v24 + 23);
        v30 = v29;
        v31 = (unsigned __int8 *)(v29 & 0x7F);
        if (v30 < 0)
          v31 = v24[1];
        if (v28 != v31)
          goto LABEL_31;
        if (v30 >= 0)
          v32 = (unsigned __int8 *)v24;
        else
          v32 = *v24;
        if ((*(_BYTE *)(v22 + 23) & 0x80) != 0)
        {
          if (memcmp(*(const void **)v22, v32, *(_QWORD *)(v22 + 8)))
            goto LABEL_31;
        }
        else if ((v26 & 0x7F) != 0)
        {
          v33 = 0;
          while (*(unsigned __int8 *)(v22 + v33) == v32[v33])
          {
            if (v27 == ++v33)
              goto LABEL_27;
          }
          goto LABEL_31;
        }
LABEL_27:
        v22 += 24;
        v24 += 3;
      }
      while (v22 != v23 && v24 != v25);
    }
    if (v22 != v23 || v24 != v25)
LABEL_31:
      *(_DWORD *)(v18 + 12) = 0;
  }
  if (!v10)
  {
    v14 = (unint64_t)(v7 + 7) & 0xFFFFFFFFFFFFFFF8;
    v15 = *(_BYTE *)(a4 + 8) & 0xFE;
    goto LABEL_7;
  }
LABEL_3:
  v8 = operator new();
  *(_QWORD *)v8 = &off_1E8169028;
  *(_DWORD *)(v8 + 8) = 5;
  *(_BYTE *)(a4 + 8) |= 1u;
  *(_QWORD *)a4 = v8;
}

void sub_1C5473DE0(uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  unint64_t v4;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  unint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  _QWORD *v30;
  char *v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t *v39;
  __n128 v40;
  char v41;
  uint64_t *v42;
  _QWORD *v43;
  unint64_t v44;
  uint64_t v45;
  char *v46;
  char *v47;
  char *v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  char *v52;
  uint64_t v53;
  unint64_t *v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  unint64_t v67;
  uint64_t *v69;
  char v70;
  _OWORD v71[2];
  __int16 v72;
  uint64_t v73;
  char v74;
  uint64_t v75;
  char v76;
  uint64_t v77;

  v77 = *MEMORY[0x1E0C80C00];
  if (a2 < a3)
  {
    v4 = a2;
    v65 = a1 + 8;
    while (1)
    {
      v6 = *(_DWORD *)(v4 + 8);
      v7 = *(_QWORD *)(a1 + 72);
      v8 = *(unsigned int *)(a1 + 88);
      v9 = sub_1C5470560(v7, *(_DWORD *)(a1 + 88), bswap64(*(_QWORD *)(v4 + 20)));
      if ((uint64_t *)(v7 + 16 * v8) == v9)
      {
LABEL_57:
        v56 = operator new();
        *(_QWORD *)v56 = &off_1E8169028;
        *(_DWORD *)(v56 + 8) = 5;
        goto LABEL_58;
      }
      v10 = v4 + 28;
      v11 = bswap32(v6);
      v12 = v4 + 28 + v11;
      v13 = v9[1];
      v14 = HIDWORD(v13);
      if (HIDWORD(v13))
        break;
LABEL_29:
      v4 = (v12 + 7) & 0xFFFFFFFFFFFFFFF8;
      if (v4 >= a3)
        goto LABEL_56;
    }
    if (v12 > a3)
      goto LABEL_57;
    v67 = v4 + 28 + v11;
    v15 = *(_QWORD *)(v4 + 12);
    v64 = bswap64(v15);
    v16 = (uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) - **(_QWORD **)(a1 + 64)) >> 6;
    *(_QWORD *)&v71[0] = bswap64(*(_QWORD *)v4);
    *((_QWORD *)&v71[0] + 1) = v16;
    sub_1C546C7AC(&v69, v65, (uint64_t *)v71, (uint64_t *)v71 + 1);
    if (v70)
    {
      v17 = *(uint64_t **)(a1 + 32);
      v18 = bswap64(*(_QWORD *)v4);
      sub_1C546CB40(v17);
      v19 = (_QWORD *)v17[7];
      v20 = (_QWORD *)v17[8];
      if (v20 != v19)
      {
        v21 = 0xAAAAAAAAAAAAAAABLL * (v20 - v19);
        do
        {
          v22 = v21 >> 1;
          v23 = &v19[3 * (v21 >> 1)];
          v25 = *v23;
          v24 = v23 + 3;
          v21 += ~(v21 >> 1);
          if (v25 < v18)
            v19 = v24;
          else
            v21 = v22;
        }
        while (v21);
      }
      if (v19 != v20 && *v19 == v18 && (v26 = v19[2]) != 0)
      {
        v27 = v19[1];
        v28 = *(_QWORD *)(a1 + 64);
        v30 = *(_QWORD **)(v28 + 8);
        v29 = *(_QWORD *)(v28 + 16);
        if ((unint64_t)v30 >= v29)
        {
          v43 = *(_QWORD **)v28;
          v44 = (((uint64_t)v30 - *(_QWORD *)v28) >> 6) + 1;
          if (v44 >> 58)
            abort();
          v58 = ((uint64_t)v30 - *(_QWORD *)v28) >> 6;
          v60 = v27;
          v62 = *(_QWORD *)(a1 + 64);
          v45 = v29 - (_QWORD)v43;
          if (v45 >> 5 > v44)
            v44 = v45 >> 5;
          if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFC0)
            v44 = 0x3FFFFFFFFFFFFFFLL;
          if (v44 >> 58)
            sub_1C4764EE4();
          v57 = v44;
          v46 = (char *)operator new(v44 << 6);
          v47 = &v46[64 * v58];
          *(_DWORD *)v47 = 5;
          *((_QWORD *)v47 + 1) = v60;
          *((_QWORD *)v47 + 2) = v26;
          *((_QWORD *)v47 + 3) = v64;
          *((_QWORD *)v47 + 4) = v10;
          *((_QWORD *)v47 + 5) = v11;
          *((_QWORD *)v47 + 6) = v13;
          *((_QWORD *)v47 + 7) = v14;
          if (v30 == v43)
          {
            v52 = &v46[64 * v58];
            v12 = v67;
            v28 = v62;
          }
          else
          {
            v48 = &v46[64 * v58];
            v12 = v67;
            v28 = v62;
            do
            {
              v49 = *((_OWORD *)v30 - 4);
              v50 = *((_OWORD *)v30 - 3);
              v51 = *((_OWORD *)v30 - 1);
              v52 = v48 - 64;
              *((_OWORD *)v48 - 2) = *((_OWORD *)v30 - 2);
              *((_OWORD *)v48 - 1) = v51;
              *((_OWORD *)v48 - 4) = v49;
              *((_OWORD *)v48 - 3) = v50;
              v30 -= 8;
              v48 -= 64;
            }
            while (v30 != v43);
          }
          v31 = v47 + 64;
          *(_QWORD *)v28 = v52;
          *(_QWORD *)(v28 + 8) = v47 + 64;
          *(_QWORD *)(v28 + 16) = &v46[64 * v57];
          if (v43)
          {
            operator delete(v43);
            v28 = v62;
          }
        }
        else
        {
          *(_DWORD *)v30 = 5;
          v30[1] = v27;
          v30[2] = v26;
          v30[3] = v64;
          v30[4] = v10;
          v30[5] = v11;
          v30[6] = v13;
          v31 = (char *)(v30 + 8);
          v30[7] = v14;
          v12 = v67;
        }
        v32 = 0;
        *(_QWORD *)(v28 + 8) = v31;
      }
      else
      {
        v32 = operator new();
        *(_QWORD *)&v71[0] = "function name is empty";
        v72 = 259;
        *(_QWORD *)v32 = off_1E8192D50;
        *(_DWORD *)(v32 + 8) = 9;
        llvm::Twine::str((llvm::Twine *)v71, (_QWORD *)(v32 + 16));
        v12 = v67;
      }
      v33 = a4;
      goto LABEL_27;
    }
    v34 = v69[1];
    v35 = **(_QWORD **)(a1 + 64);
    v36 = v35 + (v34 << 6);
    v38 = *(_QWORD *)(v36 + 24);
    v37 = v36 + 24;
    v39 = (unint64_t *)(v37 + 8);
    v40 = *(__n128 *)(v37 + 8);
    if (v38)
    {
      v76 &= ~1u;
      LOBYTE(v75) = 0;
      if ((v76 & 1) == 0)
        goto LABEL_22;
    }
    else
    {
      v71[0] = *(_OWORD *)(v37 + 8);
      v59 = v35;
      v61 = v34;
      llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v71, (uint64_t)&v75);
      v35 = v59;
      v34 = v61;
      v39 = (unint64_t *)(v37 + 8);
      if ((v76 & 1) == 0)
      {
LABEL_22:
        if (!(_BYTE)v75)
        {
          v32 = 0;
          v42 = a4;
          v12 = v67;
LABEL_46:
          *v42 = 0;
          goto LABEL_28;
        }
        if (v15)
        {
          v41 = v74 & 0xFE;
          v74 &= ~1u;
          LOBYTE(v73) = 0;
        }
        else
        {
          *(_QWORD *)&v71[0] = v4 + 28;
          *((_QWORD *)&v71[0] + 1) = v11;
          v53 = v35;
          v54 = v39;
          v63 = v34;
          llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v71, (uint64_t)&v73);
          v34 = v63;
          v39 = v54;
          v35 = v53;
          v41 = v74;
        }
        v12 = v67;
        if ((v41 & 1) != 0)
        {
          v32 = v73;
          v73 = 0;
          *a4 = v32;
          if (v32)
            goto LABEL_28;
        }
        else if ((_BYTE)v73)
        {
          v32 = 0;
          v42 = a4;
          goto LABEL_46;
        }
        v32 = 0;
        *(_QWORD *)v37 = v64;
        *v39 = v10;
        v39[1] = v11;
        v55 = v35 + (v34 << 6);
        *(_QWORD *)(v55 + 48) = v13;
        *(_QWORD *)(v55 + 56) = v14;
        *a4 = 0;
        if ((v41 & 1) != 0)
        {
          if (v73)
            (*(void (**)(uint64_t, __n128))(*(_QWORD *)v73 + 8))(v73, v40);
          v32 = 0;
        }
LABEL_28:
        if (v32)
          return;
        goto LABEL_29;
      }
    }
    v32 = v75;
    v33 = a4;
    v12 = v67;
LABEL_27:
    *v33 = v32;
    goto LABEL_28;
  }
LABEL_56:
  v56 = 0;
LABEL_58:
  *a4 = v56;
}

_QWORD *sub_1C54742C0(_QWORD *a1)
{
  *a1 = &off_1E8169328;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  return a1;
}

void sub_1C5474304(_QWORD *a1)
{
  *a1 = &off_1E8169328;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5474358(uint64_t a1@<X0>, unsigned int *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unsigned int *v5;
  char *v7;
  unsigned int *v8;
  char *v9;
  uint64_t v10;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char **v16;
  char v17;
  unint64_t v18;
  char **v19;
  char *v20[3];
  __int128 v21;

  v5 = a2 + 4;
  if ((unint64_t)(a2 + 4) > a3)
    goto LABEL_3;
  v7 = (char *)a2[1];
  v8 = &v5[6 * *a2];
  v9 = &v7[(_QWORD)v8];
  if (&v7[(_QWORD)v8] > (char *)a3)
    goto LABEL_3;
  v12 = a2[2];
  v13 = *(char **)(a1 + 56);
  v15 = *(_QWORD *)v13;
  v14 = *((_QWORD *)v13 + 1);
  v20[0] = (char *)&v5[6 * *a2];
  v20[1] = v7;
  v20[2] = v13;
  v21 = *(_OWORD *)(a1 + 40);
  llvm::coverage::RawCoverageFilenamesReader::read(v20, 0, &v19);
  v16 = v19;
  if (v19)
    goto LABEL_5;
  v18 = (unint64_t)&v9[v12];
  if (v18 > a3)
  {
LABEL_3:
    v10 = operator new();
    *(_QWORD *)v10 = &off_1E8169028;
    *(_DWORD *)(v10 + 8) = 5;
    *(_BYTE *)(a4 + 8) |= 1u;
    *(_QWORD *)a4 = v10;
    return;
  }
  (*(void (**)(char ***__return_ptr, uint64_t, unsigned int *, unsigned int *, unint64_t, uint64_t, char *, unint64_t))(*(_QWORD *)a1 + 24))(&v19, a1, v5, v8, (-1431655765 * ((v14 - v15) >> 3)) | ((unint64_t)(-1431655765* ((*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8)- **(_QWORD **)(a1 + 56)) >> 3)- -1431655765* ((v14 - v15) >> 3)) << 32), 1, v9, v18);
  v16 = v19;
  if (v19)
  {
LABEL_5:
    v17 = *(_BYTE *)(a4 + 8) | 1;
  }
  else
  {
    v16 = (char **)((v18 + 7) & 0xFFFFFFFFFFFFFFF8);
    v17 = *(_BYTE *)(a4 + 8) & 0xFE;
  }
  *(_BYTE *)(a4 + 8) = v17;
  *(_QWORD *)a4 = v16;
}

void sub_1C54744D8(uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, unint64_t a4@<X3>, char a5@<W4>, uint64_t a6@<X5>, unint64_t a7@<X6>, uint64_t *a8@<X8>)
{
  uint64_t *v8;
  unint64_t v9;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  BOOL v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  __n128 v32;
  char v33;
  uint64_t v34;
  unint64_t v35;
  _QWORD *v36;
  char *v37;
  uint64_t v38;
  _QWORD *v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  char *v44;
  char *v45;
  char *v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  char *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  uint64_t v58;
  unint64_t v59;
  char v63;
  uint64_t v64;
  uint64_t *v65;
  char v66;
  _OWORD v67[2];
  __int16 v68;
  uint64_t v69;
  char v70;
  uint64_t v71;
  char v72;
  uint64_t v73;

  v8 = a8;
  v73 = *MEMORY[0x1E0C80C00];
  if (a2 < a3)
  {
    v9 = a7;
    v11 = a3;
    v12 = a2;
    v13 = a1;
    v59 = HIDWORD(a4);
    if (a5)
      v14 = HIDWORD(a4) == 0;
    else
      v14 = 1;
    v15 = v14;
    v64 = a1 + 8;
    v58 = a4;
    v63 = v15;
    while (1)
    {
      v16 = *(unsigned int *)(v12 + 12);
      if (a6 + v16 > v9)
      {
LABEL_63:
        v54 = operator new();
        *(_QWORD *)v54 = &off_1E8169028;
        *(_DWORD *)(v54 + 8) = 5;
        goto LABEL_64;
      }
      if ((v15 & 1) == 0)
        break;
LABEL_61:
      v12 += 24;
      a6 += v16;
      if (v12 >= v11)
        goto LABEL_62;
    }
    v17 = *(_QWORD *)(v12 + 16);
    v18 = (uint64_t)(*(_QWORD *)(*(_QWORD *)(v13 + 64) + 8) - **(_QWORD **)(v13 + 64)) >> 6;
    *(_QWORD *)&v67[0] = *(_QWORD *)v12;
    *((_QWORD *)&v67[0] + 1) = v18;
    sub_1C546C7AC(&v65, v64, (uint64_t *)v67, (uint64_t *)v67 + 1);
    if (!v66)
    {
      v26 = v13;
      v27 = v65[1];
      v28 = **(_QWORD **)(v26 + 64);
      v29 = v28 + (v27 << 6);
      v31 = *(_QWORD *)(v29 + 24);
      v30 = v29 + 24;
      v32 = *(__n128 *)(v30 + 8);
      if (v31)
      {
        v72 &= ~1u;
        LOBYTE(v71) = 0;
        if ((v72 & 1) == 0)
          goto LABEL_18;
LABEL_43:
        v51 = v71;
        *v8 = v71;
LABEL_60:
        v9 = a7;
        v13 = a1;
        v11 = a3;
        v15 = v63;
        if (v51)
          return;
        goto LABEL_61;
      }
      v67[0] = *(_OWORD *)(v30 + 8);
      llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v67, (uint64_t)&v71);
      if ((v72 & 1) != 0)
        goto LABEL_43;
LABEL_18:
      if ((_BYTE)v71)
      {
        if (v17)
        {
          v33 = v70 & 0xFE;
          v70 &= ~1u;
          LOBYTE(v69) = 0;
        }
        else
        {
          *(_QWORD *)&v67[0] = a6;
          *((_QWORD *)&v67[0] + 1) = v16;
          llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v67, (uint64_t)&v69);
          v33 = v70;
        }
        v52 = v17;
        if ((v33 & 1) != 0)
        {
          v51 = v69;
          v69 = 0;
          *v8 = v51;
          if (v51)
            goto LABEL_60;
        }
        else if ((_BYTE)v69)
        {
          goto LABEL_54;
        }
        v51 = 0;
        *(_QWORD *)v30 = v52;
        *(_QWORD *)(v30 + 8) = a6;
        *(_QWORD *)(v30 + 16) = v16;
        v53 = v28 + (v27 << 6);
        *(_QWORD *)(v53 + 48) = v58;
        *(_QWORD *)(v53 + 56) = v59;
        *v8 = 0;
        if ((v33 & 1) != 0)
        {
          if (v69)
            (*(void (**)(uint64_t, __n128))(*(_QWORD *)v69 + 8))(v69, v32);
          v51 = 0;
        }
        goto LABEL_60;
      }
LABEL_54:
      v51 = 0;
      *v8 = 0;
      goto LABEL_60;
    }
    v19 = *(_QWORD **)(v13 + 32);
    v20 = *(unsigned int *)(v12 + 8);
    v21 = v19[2];
    v22 = *(_QWORD *)v12 - v21;
    if (*(_QWORD *)v12 >= v21 && (v23 = v19[1], v22 + v20 <= v23))
    {
      if (v23 < v22)
        v22 = v19[1];
      v24 = *v19 + v22;
      if (v23 - v22 >= v20)
        v25 = *(unsigned int *)(v12 + 8);
      else
        v25 = v23 - v22;
      if (!(_DWORD)v20)
      {
LABEL_28:
        if (v25)
        {
          v34 = *(_QWORD *)(v13 + 64);
          v36 = *(_QWORD **)(v34 + 8);
          v35 = *(_QWORD *)(v34 + 16);
          if ((unint64_t)v36 >= v35)
          {
            v56 = v17;
            v39 = *(_QWORD **)v34;
            v40 = ((uint64_t)v36 - *(_QWORD *)v34) >> 6;
            v41 = v40 + 1;
            if ((unint64_t)(v40 + 1) >> 58)
              abort();
            v42 = v35 - (_QWORD)v39;
            if (v42 >> 5 > v41)
              v41 = v42 >> 5;
            if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFC0)
              v41 = 0x3FFFFFFFFFFFFFFLL;
            if (v41 >> 58)
              sub_1C4764EE4();
            v43 = v24;
            v55 = v41;
            v44 = (char *)operator new(v41 << 6);
            v45 = &v44[64 * v40];
            *(_DWORD *)v45 = 0;
            *((_QWORD *)v45 + 1) = v43;
            *((_QWORD *)v45 + 2) = v25;
            *((_QWORD *)v45 + 3) = v56;
            *((_QWORD *)v45 + 4) = a6;
            *((_QWORD *)v45 + 5) = v16;
            *((_QWORD *)v45 + 6) = v58;
            *((_QWORD *)v45 + 7) = v59;
            if (v36 == v39)
            {
              v50 = &v44[64 * v40];
              v9 = a7;
              v15 = v63;
            }
            else
            {
              v46 = &v44[64 * v40];
              v9 = a7;
              v15 = v63;
              do
              {
                v47 = *((_OWORD *)v36 - 4);
                v48 = *((_OWORD *)v36 - 3);
                v49 = *((_OWORD *)v36 - 1);
                v50 = v46 - 64;
                *((_OWORD *)v46 - 2) = *((_OWORD *)v36 - 2);
                *((_OWORD *)v46 - 1) = v49;
                *((_OWORD *)v46 - 4) = v47;
                *((_OWORD *)v46 - 3) = v48;
                v36 -= 8;
                v46 -= 64;
              }
              while (v36 != v39);
            }
            v37 = v45 + 64;
            *(_QWORD *)v34 = v50;
            *(_QWORD *)(v34 + 8) = v45 + 64;
            *(_QWORD *)(v34 + 16) = &v44[64 * v55];
            if (v39)
              operator delete(v39);
            v11 = a3;
          }
          else
          {
            *(_DWORD *)v36 = 0;
            v36[1] = v24;
            v36[2] = v25;
            v36[3] = v17;
            v36[4] = a6;
            v36[5] = v16;
            v36[6] = v58;
            v37 = (char *)(v36 + 8);
            v36[7] = v59;
            v11 = a3;
            v15 = v63;
          }
          v38 = 0;
          *(_QWORD *)(v34 + 8) = v37;
          v8 = a8;
          v13 = a1;
        }
        else
        {
          v38 = operator new();
          *(_QWORD *)&v67[0] = "function name is empty";
          v68 = 259;
          *(_QWORD *)v38 = off_1E8192D50;
          *(_DWORD *)(v38 + 8) = 9;
          llvm::Twine::str((llvm::Twine *)v67, (_QWORD *)(v38 + 16));
          v15 = v63;
        }
        *v8 = v38;
        if (v38)
          return;
        goto LABEL_61;
      }
    }
    else
    {
      v24 = 0;
      v25 = 0;
      if (!(_DWORD)v20)
        goto LABEL_28;
    }
    if (!v25)
      goto LABEL_63;
    goto LABEL_28;
  }
LABEL_62:
  v54 = 0;
LABEL_64:
  *v8 = v54;
}

_QWORD *sub_1C5474944(_QWORD *a1)
{
  *a1 = &off_1E8169358;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  return a1;
}

void sub_1C5474988(_QWORD *a1)
{
  *a1 = &off_1E8169358;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C54749DC(uint64_t a1@<X0>, unsigned int *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unsigned int *v5;
  char *v7;
  unsigned int *v8;
  char *v9;
  uint64_t v10;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char **v16;
  char v17;
  unint64_t v18;
  char **v19;
  char *v20[3];
  __int128 v21;

  v5 = a2 + 4;
  if ((unint64_t)(a2 + 4) > a3)
    goto LABEL_3;
  v7 = (char *)a2[1];
  v8 = &v5[5 * *a2];
  v9 = &v7[(_QWORD)v8];
  if (&v7[(_QWORD)v8] > (char *)a3)
    goto LABEL_3;
  v12 = a2[2];
  v13 = *(char **)(a1 + 56);
  v15 = *(_QWORD *)v13;
  v14 = *((_QWORD *)v13 + 1);
  v20[0] = (char *)&v5[5 * *a2];
  v20[1] = v7;
  v20[2] = v13;
  v21 = *(_OWORD *)(a1 + 40);
  llvm::coverage::RawCoverageFilenamesReader::read(v20, 1, &v19);
  v16 = v19;
  if (v19)
    goto LABEL_5;
  v18 = (unint64_t)&v9[v12];
  if (v18 > a3)
  {
LABEL_3:
    v10 = operator new();
    *(_QWORD *)v10 = &off_1E8169028;
    *(_DWORD *)(v10 + 8) = 5;
    *(_BYTE *)(a4 + 8) |= 1u;
    *(_QWORD *)a4 = v10;
    return;
  }
  (*(void (**)(char ***__return_ptr, uint64_t, unsigned int *, unsigned int *, unint64_t, uint64_t, char *, unint64_t))(*(_QWORD *)a1 + 24))(&v19, a1, v5, v8, (-1431655765 * ((v14 - v15) >> 3)) | ((unint64_t)(-1431655765* ((*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8)- **(_QWORD **)(a1 + 56)) >> 3)- -1431655765* ((v14 - v15) >> 3)) << 32), 1, v9, v18);
  v16 = v19;
  if (v19)
  {
LABEL_5:
    v17 = *(_BYTE *)(a4 + 8) | 1;
  }
  else
  {
    v16 = (char **)((v18 + 7) & 0xFFFFFFFFFFFFFFF8);
    v17 = *(_BYTE *)(a4 + 8) & 0xFE;
  }
  *(_BYTE *)(a4 + 8) = v17;
  *(_QWORD *)a4 = v16;
}

void sub_1C5474B5C(uint64_t a1@<X0>, uint64_t *a2@<X1>, unint64_t a3@<X2>, unint64_t a4@<X3>, char a5@<W4>, uint64_t a6@<X5>, unint64_t a7@<X6>, uint64_t *a8@<X8>)
{
  uint64_t *v8;
  unint64_t v9;
  uint64_t *v11;
  uint64_t v12;
  BOOL v13;
  char v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  unint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  _QWORD *v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  __n128 v38;
  char v39;
  char v40;
  uint64_t v41;
  _QWORD *v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  char *v46;
  char *v47;
  char *v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  char *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v62;
  unint64_t v63;
  char v65;
  uint64_t v67;
  uint64_t *v68;
  char v69;
  _OWORD v70[2];
  __int16 v71;
  uint64_t v72;
  char v73;
  uint64_t v74;
  char v75;
  uint64_t v76;

  v8 = a8;
  v76 = *MEMORY[0x1E0C80C00];
  if ((unint64_t)a2 < a3)
  {
    v9 = a7;
    v11 = a2;
    v12 = a1;
    v60 = HIDWORD(a4);
    if (a5)
      v13 = HIDWORD(a4) == 0;
    else
      v13 = 1;
    v14 = v13;
    v62 = a1 + 8;
    v59 = a4;
    v63 = a3;
    v65 = v14;
    do
    {
      v15 = *((unsigned int *)v11 + 2);
      if (a6 + v15 > v9)
      {
        v55 = operator new();
        *(_QWORD *)v55 = &off_1E8169028;
        *(_DWORD *)(v55 + 8) = 5;
        goto LABEL_64;
      }
      if ((v14 & 1) == 0)
      {
        v67 = *(uint64_t *)((char *)v11 + 12);
        v16 = (uint64_t)(*(_QWORD *)(*(_QWORD *)(v12 + 64) + 8) - **(_QWORD **)(v12 + 64)) >> 6;
        *(_QWORD *)&v70[0] = *v11;
        *((_QWORD *)&v70[0] + 1) = v16;
        sub_1C546C7AC(&v68, v62, (uint64_t *)v70, (uint64_t *)v70 + 1);
        if (!v69)
        {
          v33 = v68[1];
          v34 = **(_QWORD **)(v12 + 64);
          v35 = v34 + (v33 << 6);
          v37 = *(_QWORD *)(v35 + 24);
          v36 = v35 + 24;
          v38 = *(__n128 *)(v36 + 8);
          if (v37)
          {
            v39 = v75 & 0xFE;
            v75 &= ~1u;
            LOBYTE(v74) = 0;
          }
          else
          {
            v70[0] = *(_OWORD *)(v36 + 8);
            llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v70, (uint64_t)&v74);
            v39 = v75;
          }
          v14 = v65;
          if ((v39 & 1) != 0)
          {
            v41 = v74;
            v8 = a8;
            *a8 = v74;
          }
          else if ((_BYTE)v74)
          {
            if (v67)
            {
              v40 = v73 & 0xFE;
              v73 &= ~1u;
              LOBYTE(v72) = 0;
            }
            else
            {
              *(_QWORD *)&v70[0] = a6;
              *((_QWORD *)&v70[0] + 1) = v15;
              llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v70, (uint64_t)&v72);
              v14 = v65;
              v40 = v73;
            }
            v53 = v33;
            if ((v40 & 1) != 0)
            {
              v41 = v72;
              v72 = 0;
              *a8 = v41;
              if (!v41)
                goto LABEL_50;
            }
            else
            {
              if ((_BYTE)v72)
              {
                v41 = 0;
                *a8 = 0;
                goto LABEL_54;
              }
LABEL_50:
              v41 = 0;
              *(_QWORD *)v36 = v67;
              *(_QWORD *)(v36 + 8) = a6;
              *(_QWORD *)(v36 + 16) = v15;
              v54 = v34 + (v53 << 6);
              *(_QWORD *)(v54 + 48) = v59;
              *(_QWORD *)(v54 + 56) = v60;
              *a8 = 0;
              if ((v40 & 1) != 0)
              {
                if (v72)
                {
                  (*(void (**)(uint64_t, __n128))(*(_QWORD *)v72 + 8))(v72, v38);
                  v14 = v65;
                }
                v41 = 0;
              }
            }
LABEL_54:
            v8 = a8;
          }
          else
          {
            v41 = 0;
            v8 = a8;
            *a8 = 0;
          }
          a3 = v63;
          v9 = a7;
          v12 = a1;
          if (v41)
            return;
          goto LABEL_56;
        }
        v17 = *(uint64_t **)(v12 + 32);
        v18 = *v11;
        sub_1C546CB40(v17);
        v19 = (_QWORD *)v17[7];
        v20 = (_QWORD *)v17[8];
        if (v20 != v19)
        {
          v21 = 0xAAAAAAAAAAAAAAABLL * (v20 - v19);
          do
          {
            v22 = v21 >> 1;
            v23 = &v19[3 * (v21 >> 1)];
            v25 = *v23;
            v24 = v23 + 3;
            v21 += ~(v21 >> 1);
            if (v25 < v18)
              v19 = v24;
            else
              v21 = v22;
          }
          while (v21);
        }
        if (v19 != v20 && *v19 == v18 && (v26 = v19[2]) != 0)
        {
          v27 = v19[1];
          v28 = *(_QWORD *)(a1 + 64);
          v30 = *(_QWORD **)(v28 + 8);
          v29 = *(_QWORD *)(v28 + 16);
          if ((unint64_t)v30 >= v29)
          {
            v42 = *(_QWORD **)v28;
            v43 = ((uint64_t)v30 - *(_QWORD *)v28) >> 6;
            v44 = v43 + 1;
            if ((unint64_t)(v43 + 1) >> 58)
              abort();
            v57 = v27;
            v58 = *(_QWORD *)(a1 + 64);
            v45 = v29 - (_QWORD)v42;
            if (v45 >> 5 > v44)
              v44 = v45 >> 5;
            if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFC0)
              v44 = 0x3FFFFFFFFFFFFFFLL;
            if (v44 >> 58)
              sub_1C4764EE4();
            v56 = v44;
            v46 = (char *)operator new(v44 << 6);
            v47 = &v46[64 * v43];
            *(_DWORD *)v47 = 1;
            *((_QWORD *)v47 + 1) = v57;
            *((_QWORD *)v47 + 2) = v26;
            *((_QWORD *)v47 + 3) = v67;
            *((_QWORD *)v47 + 4) = a6;
            *((_QWORD *)v47 + 5) = v15;
            *((_QWORD *)v47 + 6) = v59;
            *((_QWORD *)v47 + 7) = v60;
            if (v30 == v42)
            {
              v52 = &v46[64 * v43];
              v9 = a7;
              v28 = v58;
            }
            else
            {
              v48 = &v46[64 * v43];
              v9 = a7;
              v28 = v58;
              do
              {
                v49 = *((_OWORD *)v30 - 4);
                v50 = *((_OWORD *)v30 - 3);
                v51 = *((_OWORD *)v30 - 1);
                v52 = v48 - 64;
                *((_OWORD *)v48 - 2) = *((_OWORD *)v30 - 2);
                *((_OWORD *)v48 - 1) = v51;
                *((_OWORD *)v48 - 4) = v49;
                *((_OWORD *)v48 - 3) = v50;
                v30 -= 8;
                v48 -= 64;
              }
              while (v30 != v42);
            }
            v31 = v47 + 64;
            *(_QWORD *)v28 = v52;
            *(_QWORD *)(v28 + 8) = v47 + 64;
            *(_QWORD *)(v28 + 16) = &v46[64 * v56];
            if (v42)
            {
              operator delete(v42);
              v28 = v58;
            }
          }
          else
          {
            *(_DWORD *)v30 = 1;
            v30[1] = v27;
            v30[2] = v26;
            v30[3] = v67;
            v30[4] = a6;
            v30[5] = v15;
            v30[6] = v59;
            v31 = (char *)(v30 + 8);
            v30[7] = v60;
            v9 = a7;
          }
          a3 = v63;
          v12 = a1;
          v14 = v65;
          v32 = 0;
          *(_QWORD *)(v28 + 8) = v31;
          v8 = a8;
        }
        else
        {
          v32 = operator new();
          *(_QWORD *)&v70[0] = "function name is empty";
          v71 = 259;
          *(_QWORD *)v32 = off_1E8192D50;
          *(_DWORD *)(v32 + 8) = 9;
          llvm::Twine::str((llvm::Twine *)v70, (_QWORD *)(v32 + 16));
          a3 = v63;
          v9 = a7;
          v12 = a1;
          v14 = v65;
        }
        *v8 = v32;
        if (v32)
          return;
      }
LABEL_56:
      v11 = (uint64_t *)((char *)v11 + 20);
      a6 += v15;
    }
    while ((unint64_t)v11 < a3);
  }
  v55 = 0;
LABEL_64:
  *v8 = v55;
}

_QWORD *sub_1C5475038(_QWORD *a1)
{
  *a1 = &off_1E8169388;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  return a1;
}

void sub_1C547507C(_QWORD *a1)
{
  *a1 = &off_1E8169388;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C54750D0(uint64_t a1@<X0>, unsigned int *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unsigned int *v5;
  char *v7;
  unsigned int *v8;
  char *v9;
  uint64_t v10;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char **v16;
  char v17;
  unint64_t v18;
  char **v19;
  char *v20[3];
  __int128 v21;

  v5 = a2 + 4;
  if ((unint64_t)(a2 + 4) > a3)
    goto LABEL_3;
  v7 = (char *)a2[1];
  v8 = &v5[5 * *a2];
  v9 = &v7[(_QWORD)v8];
  if (&v7[(_QWORD)v8] > (char *)a3)
    goto LABEL_3;
  v12 = a2[2];
  v13 = *(char **)(a1 + 56);
  v15 = *(_QWORD *)v13;
  v14 = *((_QWORD *)v13 + 1);
  v20[0] = (char *)&v5[5 * *a2];
  v20[1] = v7;
  v20[2] = v13;
  v21 = *(_OWORD *)(a1 + 40);
  llvm::coverage::RawCoverageFilenamesReader::read(v20, 2, &v19);
  v16 = v19;
  if (v19)
    goto LABEL_5;
  v18 = (unint64_t)&v9[v12];
  if (v18 > a3)
  {
LABEL_3:
    v10 = operator new();
    *(_QWORD *)v10 = &off_1E8169028;
    *(_DWORD *)(v10 + 8) = 5;
    *(_BYTE *)(a4 + 8) |= 1u;
    *(_QWORD *)a4 = v10;
    return;
  }
  (*(void (**)(char ***__return_ptr, uint64_t, unsigned int *, unsigned int *, unint64_t, uint64_t, char *, unint64_t))(*(_QWORD *)a1 + 24))(&v19, a1, v5, v8, (-1431655765 * ((v14 - v15) >> 3)) | ((unint64_t)(-1431655765* ((*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8)- **(_QWORD **)(a1 + 56)) >> 3)- -1431655765* ((v14 - v15) >> 3)) << 32), 1, v9, v18);
  v16 = v19;
  if (v19)
  {
LABEL_5:
    v17 = *(_BYTE *)(a4 + 8) | 1;
  }
  else
  {
    v16 = (char **)((v18 + 7) & 0xFFFFFFFFFFFFFFF8);
    v17 = *(_BYTE *)(a4 + 8) & 0xFE;
  }
  *(_BYTE *)(a4 + 8) = v17;
  *(_QWORD *)a4 = v16;
}

void sub_1C5475250(uint64_t a1@<X0>, uint64_t *a2@<X1>, unint64_t a3@<X2>, unint64_t a4@<X3>, char a5@<W4>, uint64_t a6@<X5>, unint64_t a7@<X6>, uint64_t *a8@<X8>)
{
  uint64_t *v8;
  unint64_t v9;
  uint64_t *v11;
  uint64_t v12;
  BOOL v13;
  char v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  unint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  _QWORD *v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  __n128 v38;
  char v39;
  char v40;
  uint64_t v41;
  _QWORD *v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  char *v46;
  char *v47;
  char *v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  char *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v62;
  unint64_t v63;
  char v65;
  uint64_t v67;
  uint64_t *v68;
  char v69;
  _OWORD v70[2];
  __int16 v71;
  uint64_t v72;
  char v73;
  uint64_t v74;
  char v75;
  uint64_t v76;

  v8 = a8;
  v76 = *MEMORY[0x1E0C80C00];
  if ((unint64_t)a2 < a3)
  {
    v9 = a7;
    v11 = a2;
    v12 = a1;
    v60 = HIDWORD(a4);
    if (a5)
      v13 = HIDWORD(a4) == 0;
    else
      v13 = 1;
    v14 = v13;
    v62 = a1 + 8;
    v59 = a4;
    v63 = a3;
    v65 = v14;
    do
    {
      v15 = *((unsigned int *)v11 + 2);
      if (a6 + v15 > v9)
      {
        v55 = operator new();
        *(_QWORD *)v55 = &off_1E8169028;
        *(_DWORD *)(v55 + 8) = 5;
        goto LABEL_64;
      }
      if ((v14 & 1) == 0)
      {
        v67 = *(uint64_t *)((char *)v11 + 12);
        v16 = (uint64_t)(*(_QWORD *)(*(_QWORD *)(v12 + 64) + 8) - **(_QWORD **)(v12 + 64)) >> 6;
        *(_QWORD *)&v70[0] = *v11;
        *((_QWORD *)&v70[0] + 1) = v16;
        sub_1C546C7AC(&v68, v62, (uint64_t *)v70, (uint64_t *)v70 + 1);
        if (!v69)
        {
          v33 = v68[1];
          v34 = **(_QWORD **)(v12 + 64);
          v35 = v34 + (v33 << 6);
          v37 = *(_QWORD *)(v35 + 24);
          v36 = v35 + 24;
          v38 = *(__n128 *)(v36 + 8);
          if (v37)
          {
            v39 = v75 & 0xFE;
            v75 &= ~1u;
            LOBYTE(v74) = 0;
          }
          else
          {
            v70[0] = *(_OWORD *)(v36 + 8);
            llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v70, (uint64_t)&v74);
            v39 = v75;
          }
          v14 = v65;
          if ((v39 & 1) != 0)
          {
            v41 = v74;
            v8 = a8;
            *a8 = v74;
          }
          else if ((_BYTE)v74)
          {
            if (v67)
            {
              v40 = v73 & 0xFE;
              v73 &= ~1u;
              LOBYTE(v72) = 0;
            }
            else
            {
              *(_QWORD *)&v70[0] = a6;
              *((_QWORD *)&v70[0] + 1) = v15;
              llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v70, (uint64_t)&v72);
              v14 = v65;
              v40 = v73;
            }
            v53 = v33;
            if ((v40 & 1) != 0)
            {
              v41 = v72;
              v72 = 0;
              *a8 = v41;
              if (!v41)
                goto LABEL_50;
            }
            else
            {
              if ((_BYTE)v72)
              {
                v41 = 0;
                *a8 = 0;
                goto LABEL_54;
              }
LABEL_50:
              v41 = 0;
              *(_QWORD *)v36 = v67;
              *(_QWORD *)(v36 + 8) = a6;
              *(_QWORD *)(v36 + 16) = v15;
              v54 = v34 + (v53 << 6);
              *(_QWORD *)(v54 + 48) = v59;
              *(_QWORD *)(v54 + 56) = v60;
              *a8 = 0;
              if ((v40 & 1) != 0)
              {
                if (v72)
                {
                  (*(void (**)(uint64_t, __n128))(*(_QWORD *)v72 + 8))(v72, v38);
                  v14 = v65;
                }
                v41 = 0;
              }
            }
LABEL_54:
            v8 = a8;
          }
          else
          {
            v41 = 0;
            v8 = a8;
            *a8 = 0;
          }
          a3 = v63;
          v9 = a7;
          v12 = a1;
          if (v41)
            return;
          goto LABEL_56;
        }
        v17 = *(uint64_t **)(v12 + 32);
        v18 = *v11;
        sub_1C546CB40(v17);
        v19 = (_QWORD *)v17[7];
        v20 = (_QWORD *)v17[8];
        if (v20 != v19)
        {
          v21 = 0xAAAAAAAAAAAAAAABLL * (v20 - v19);
          do
          {
            v22 = v21 >> 1;
            v23 = &v19[3 * (v21 >> 1)];
            v25 = *v23;
            v24 = v23 + 3;
            v21 += ~(v21 >> 1);
            if (v25 < v18)
              v19 = v24;
            else
              v21 = v22;
          }
          while (v21);
        }
        if (v19 != v20 && *v19 == v18 && (v26 = v19[2]) != 0)
        {
          v27 = v19[1];
          v28 = *(_QWORD *)(a1 + 64);
          v30 = *(_QWORD **)(v28 + 8);
          v29 = *(_QWORD *)(v28 + 16);
          if ((unint64_t)v30 >= v29)
          {
            v42 = *(_QWORD **)v28;
            v43 = ((uint64_t)v30 - *(_QWORD *)v28) >> 6;
            v44 = v43 + 1;
            if ((unint64_t)(v43 + 1) >> 58)
              abort();
            v57 = v27;
            v58 = *(_QWORD *)(a1 + 64);
            v45 = v29 - (_QWORD)v42;
            if (v45 >> 5 > v44)
              v44 = v45 >> 5;
            if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFC0)
              v44 = 0x3FFFFFFFFFFFFFFLL;
            if (v44 >> 58)
              sub_1C4764EE4();
            v56 = v44;
            v46 = (char *)operator new(v44 << 6);
            v47 = &v46[64 * v43];
            *(_DWORD *)v47 = 2;
            *((_QWORD *)v47 + 1) = v57;
            *((_QWORD *)v47 + 2) = v26;
            *((_QWORD *)v47 + 3) = v67;
            *((_QWORD *)v47 + 4) = a6;
            *((_QWORD *)v47 + 5) = v15;
            *((_QWORD *)v47 + 6) = v59;
            *((_QWORD *)v47 + 7) = v60;
            if (v30 == v42)
            {
              v52 = &v46[64 * v43];
              v9 = a7;
              v28 = v58;
            }
            else
            {
              v48 = &v46[64 * v43];
              v9 = a7;
              v28 = v58;
              do
              {
                v49 = *((_OWORD *)v30 - 4);
                v50 = *((_OWORD *)v30 - 3);
                v51 = *((_OWORD *)v30 - 1);
                v52 = v48 - 64;
                *((_OWORD *)v48 - 2) = *((_OWORD *)v30 - 2);
                *((_OWORD *)v48 - 1) = v51;
                *((_OWORD *)v48 - 4) = v49;
                *((_OWORD *)v48 - 3) = v50;
                v30 -= 8;
                v48 -= 64;
              }
              while (v30 != v42);
            }
            v31 = v47 + 64;
            *(_QWORD *)v28 = v52;
            *(_QWORD *)(v28 + 8) = v47 + 64;
            *(_QWORD *)(v28 + 16) = &v46[64 * v56];
            if (v42)
            {
              operator delete(v42);
              v28 = v58;
            }
          }
          else
          {
            *(_DWORD *)v30 = 2;
            v30[1] = v27;
            v30[2] = v26;
            v30[3] = v67;
            v30[4] = a6;
            v30[5] = v15;
            v30[6] = v59;
            v31 = (char *)(v30 + 8);
            v30[7] = v60;
            v9 = a7;
          }
          a3 = v63;
          v12 = a1;
          v14 = v65;
          v32 = 0;
          *(_QWORD *)(v28 + 8) = v31;
          v8 = a8;
        }
        else
        {
          v32 = operator new();
          *(_QWORD *)&v70[0] = "function name is empty";
          v71 = 259;
          *(_QWORD *)v32 = off_1E8192D50;
          *(_DWORD *)(v32 + 8) = 9;
          llvm::Twine::str((llvm::Twine *)v70, (_QWORD *)(v32 + 16));
          a3 = v63;
          v9 = a7;
          v12 = a1;
          v14 = v65;
        }
        *v8 = v32;
        if (v32)
          return;
      }
LABEL_56:
      v11 = (uint64_t *)((char *)v11 + 20);
      a6 += v15;
    }
    while ((unint64_t)v11 < a3);
  }
  v55 = 0;
LABEL_64:
  *v8 = v55;
}

_QWORD *sub_1C547572C(_QWORD *a1)
{
  *a1 = &off_1E81693B8;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  return a1;
}

void sub_1C5475770(_QWORD *a1)
{
  *a1 = &off_1E81693B8;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C54757C4(uint64_t a1@<X0>, unsigned int *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  size_t v5;
  int *v6;
  char *v7;
  uint64_t v8;
  unsigned int v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned __int8 **v24;
  unsigned __int8 **v25;
  char v26;
  uint64_t v27;
  unsigned __int8 *v28;
  char v29;
  int v30;
  unsigned __int8 *v31;
  unsigned __int8 *v32;
  uint64_t v33;
  char *v34[3];
  __int128 v35;
  uint64_t v36;
  unint64_t v37;
  __int128 v38;
  uint64_t v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  if ((unint64_t)(a2 + 4) > a3)
    goto LABEL_3;
  v5 = a2[1];
  v6 = (int *)((char *)a2 + 29 * *a2 + 16);
  v7 = (char *)v6 + v5;
  if ((unint64_t)v6 + v5 > a3)
    goto LABEL_3;
  v10 = a2[2];
  v11 = *(char **)(a1 + 56);
  v13 = *(_QWORD *)v11;
  v12 = *((_QWORD *)v11 + 1);
  v34[0] = (char *)a2 + 29 * *a2 + 16;
  v34[1] = (char *)v5;
  v34[2] = v11;
  v35 = *(_OWORD *)(a1 + 40);
  llvm::coverage::RawCoverageFilenamesReader::read(v34, 3, (char ***)&v38);
  v14 = v38;
  if ((_QWORD)v38)
  {
    v15 = *(_BYTE *)(a4 + 8) | 1;
LABEL_7:
    *(_BYTE *)(a4 + 8) = v15;
    *(_QWORD *)a4 = v14;
    return;
  }
  v16 = 0xAAAAAAAAAAAAAAABLL * ((v12 - v13) >> 3);
  v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) - **(_QWORD **)(a1 + 56)) >> 3) - v16;
  v38 = xmmword_1C85F4BB0;
  v39 = 0;
  llvm::MD5::update((int *)&v38, v6, v5);
  llvm::MD5::final((int *)&v38, (int *)&v36);
  v37 = v16 | ((unint64_t)v17 << 32);
  sub_1C54701B8((uint64_t **)&v38, a1 + 72, &v36, (uint64_t *)&v37);
  if (!(_BYTE)v39)
  {
    v18 = v38;
    v19 = *(unsigned int *)(v38 + 12);
    if (v17 != v19)
      goto LABEL_31;
    v20 = v16;
    v21 = **(_QWORD **)(a1 + 56);
    v22 = v21 + 24 * *(unsigned int *)(v38 + 8);
    v23 = v22 + 24 * v19;
    v24 = (unsigned __int8 **)(v21 + 24 * v20);
    v25 = &v24[3 * v17];
    if ((_DWORD)v19)
    {
      do
      {
        v26 = *(_BYTE *)(v22 + 23);
        v27 = v26 & 0x7F;
        if (v26 >= 0)
          v28 = (unsigned __int8 *)(v26 & 0x7F);
        else
          v28 = *(unsigned __int8 **)(v22 + 8);
        v29 = *((_BYTE *)v24 + 23);
        v30 = v29;
        v31 = (unsigned __int8 *)(v29 & 0x7F);
        if (v30 < 0)
          v31 = v24[1];
        if (v28 != v31)
          goto LABEL_31;
        if (v30 >= 0)
          v32 = (unsigned __int8 *)v24;
        else
          v32 = *v24;
        if ((*(_BYTE *)(v22 + 23) & 0x80) != 0)
        {
          if (memcmp(*(const void **)v22, v32, *(_QWORD *)(v22 + 8)))
            goto LABEL_31;
        }
        else if ((v26 & 0x7F) != 0)
        {
          v33 = 0;
          while (*(unsigned __int8 *)(v22 + v33) == v32[v33])
          {
            if (v27 == ++v33)
              goto LABEL_27;
          }
          goto LABEL_31;
        }
LABEL_27:
        v22 += 24;
        v24 += 3;
      }
      while (v22 != v23 && v24 != v25);
    }
    if (v22 != v23 || v24 != v25)
LABEL_31:
      *(_DWORD *)(v18 + 12) = 0;
  }
  if (!v10)
  {
    v14 = (unint64_t)(v7 + 7) & 0xFFFFFFFFFFFFFFF8;
    v15 = *(_BYTE *)(a4 + 8) & 0xFE;
    goto LABEL_7;
  }
LABEL_3:
  v8 = operator new();
  *(_QWORD *)v8 = &off_1E8169028;
  *(_DWORD *)(v8 + 8) = 5;
  *(_BYTE *)(a4 + 8) |= 1u;
  *(_QWORD *)a4 = v8;
}

void sub_1C5475A68(uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  unint64_t v4;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  unint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t *v21;
  _QWORD *v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  _QWORD *v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t *v36;
  __n128 v37;
  char v38;
  _QWORD *v39;
  unint64_t v40;
  uint64_t v41;
  char *v42;
  char *v43;
  char *v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  char *v48;
  unint64_t *v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t *v65;
  char v66;
  _OWORD v67[2];
  __int16 v68;
  uint64_t v69;
  char v70;
  uint64_t v71;
  char v72;
  uint64_t v73;

  v73 = *MEMORY[0x1E0C80C00];
  if (a2 < a3)
  {
    v4 = a2;
    v61 = a1 + 8;
    while (1)
    {
      v6 = *(unsigned int *)(v4 + 8);
      v7 = *(_QWORD *)(a1 + 72);
      v8 = *(unsigned int *)(a1 + 88);
      v9 = sub_1C5470560(v7, *(_DWORD *)(a1 + 88), *(_QWORD *)(v4 + 20));
      if ((uint64_t *)(v7 + 16 * v8) == v9)
      {
LABEL_52:
        v51 = operator new();
        *(_QWORD *)v51 = &off_1E8169028;
        *(_DWORD *)(v51 + 8) = 5;
        goto LABEL_53;
      }
      v10 = v4 + 28;
      v11 = v4 + 28 + v6;
      v12 = v9[1];
      v13 = HIDWORD(v12);
      if (HIDWORD(v12))
        break;
LABEL_50:
      v4 = (v11 + 7) & 0xFFFFFFFFFFFFFFF8;
      if (v4 >= a3)
        goto LABEL_51;
    }
    if (v11 > a3)
      goto LABEL_52;
    v62 = *(_QWORD *)(v4 + 12);
    v14 = (uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) - **(_QWORD **)(a1 + 64)) >> 6;
    *(_QWORD *)&v67[0] = *(_QWORD *)v4;
    *((_QWORD *)&v67[0] + 1) = v14;
    sub_1C546C7AC(&v65, v61, (uint64_t *)v67, (uint64_t *)v67 + 1);
    if (v66)
    {
      v15 = *(uint64_t **)(a1 + 32);
      v16 = *(_QWORD *)v4;
      sub_1C546CB40(v15);
      v17 = (_QWORD *)v15[7];
      v18 = (_QWORD *)v15[8];
      if (v18 != v17)
      {
        v19 = 0xAAAAAAAAAAAAAAABLL * (v18 - v17);
        do
        {
          v20 = v19 >> 1;
          v21 = &v17[3 * (v19 >> 1)];
          v23 = *v21;
          v22 = v21 + 3;
          v19 += ~(v19 >> 1);
          if (v23 < v16)
            v17 = v22;
          else
            v19 = v20;
        }
        while (v19);
      }
      if (v17 != v18 && *v17 == v16 && (v24 = v17[2]) != 0)
      {
        v25 = v17[1];
        v26 = *(_QWORD *)(a1 + 64);
        v28 = *(_QWORD **)(v26 + 8);
        v27 = *(_QWORD *)(v26 + 16);
        if ((unint64_t)v28 >= v27)
        {
          v39 = *(_QWORD **)v26;
          v40 = (((uint64_t)v28 - *(_QWORD *)v26) >> 6) + 1;
          if (v40 >> 58)
            abort();
          v53 = ((uint64_t)v28 - *(_QWORD *)v26) >> 6;
          v54 = v25;
          v56 = v24;
          v59 = *(_QWORD *)(a1 + 64);
          v41 = v27 - (_QWORD)v39;
          if (v41 >> 5 > v40)
            v40 = v41 >> 5;
          if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFC0)
            v40 = 0x3FFFFFFFFFFFFFFLL;
          if (v40 >> 58)
            sub_1C4764EE4();
          v52 = v40;
          v42 = (char *)operator new(v40 << 6);
          v43 = &v42[64 * v53];
          *(_DWORD *)v43 = 3;
          *((_QWORD *)v43 + 1) = v54;
          *((_QWORD *)v43 + 2) = v56;
          *((_QWORD *)v43 + 3) = v62;
          *((_QWORD *)v43 + 4) = v10;
          *((_QWORD *)v43 + 5) = v6;
          *((_QWORD *)v43 + 6) = v12;
          *((_QWORD *)v43 + 7) = v13;
          if (v28 == v39)
          {
            v48 = &v42[64 * v53];
            v26 = v59;
          }
          else
          {
            v44 = &v42[64 * v53];
            v26 = v59;
            do
            {
              v45 = *((_OWORD *)v28 - 4);
              v46 = *((_OWORD *)v28 - 3);
              v47 = *((_OWORD *)v28 - 1);
              v48 = v44 - 64;
              *((_OWORD *)v44 - 2) = *((_OWORD *)v28 - 2);
              *((_OWORD *)v44 - 1) = v47;
              *((_OWORD *)v44 - 4) = v45;
              *((_OWORD *)v44 - 3) = v46;
              v28 -= 8;
              v44 -= 64;
            }
            while (v28 != v39);
          }
          v29 = v43 + 64;
          *(_QWORD *)v26 = v48;
          *(_QWORD *)(v26 + 8) = v43 + 64;
          *(_QWORD *)(v26 + 16) = &v42[64 * v52];
          if (v39)
          {
            operator delete(v39);
            v26 = v59;
          }
        }
        else
        {
          *(_DWORD *)v28 = 3;
          v28[1] = v25;
          v28[2] = v24;
          v28[3] = v62;
          v28[4] = v10;
          v28[5] = v6;
          v28[6] = v12;
          v29 = (char *)(v28 + 8);
          v28[7] = v13;
        }
        v30 = 0;
        *(_QWORD *)(v26 + 8) = v29;
      }
      else
      {
        v30 = operator new();
        *(_QWORD *)&v67[0] = "function name is empty";
        v68 = 259;
        *(_QWORD *)v30 = off_1E8192D50;
        *(_DWORD *)(v30 + 8) = 9;
        llvm::Twine::str((llvm::Twine *)v67, (_QWORD *)(v30 + 16));
      }
      goto LABEL_48;
    }
    v31 = v65[1];
    v32 = **(_QWORD **)(a1 + 64);
    v33 = v32 + (v31 << 6);
    v35 = *(_QWORD *)(v33 + 24);
    v34 = v33 + 24;
    v36 = (unint64_t *)(v34 + 8);
    v37 = *(__n128 *)(v34 + 8);
    if (v35)
    {
      v72 &= ~1u;
      LOBYTE(v71) = 0;
      if ((v72 & 1) == 0)
        goto LABEL_21;
    }
    else
    {
      v67[0] = *(_OWORD *)(v34 + 8);
      v55 = v31;
      v58 = v32;
      llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v67, (uint64_t)&v71);
      v31 = v55;
      v32 = v58;
      v36 = (unint64_t *)(v34 + 8);
      if ((v72 & 1) == 0)
      {
LABEL_21:
        if (!(_BYTE)v71)
        {
LABEL_25:
          v30 = 0;
          *a4 = 0;
          goto LABEL_49;
        }
        if (v62)
        {
          v70 &= ~1u;
          v38 = v70;
          LOBYTE(v69) = 0;
          if ((v70 & 1) == 0)
            goto LABEL_24;
        }
        else
        {
          *(_QWORD *)&v67[0] = v4 + 28;
          *((_QWORD *)&v67[0] + 1) = v6;
          v57 = v31;
          v60 = v32;
          v49 = v36;
          llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v67, (uint64_t)&v69);
          v31 = v57;
          v32 = v60;
          v36 = v49;
          v38 = v70;
          if ((v70 & 1) == 0)
          {
LABEL_24:
            if ((_BYTE)v69)
              goto LABEL_25;
LABEL_40:
            v30 = 0;
            *(_QWORD *)v34 = v62;
            *v36 = v10;
            v36[1] = v6;
            v50 = v32 + (v31 << 6);
            *(_QWORD *)(v50 + 48) = v12;
            *(_QWORD *)(v50 + 56) = v13;
            *a4 = 0;
            if ((v38 & 1) != 0)
            {
              if (v69)
                (*(void (**)(uint64_t, __n128))(*(_QWORD *)v69 + 8))(v69, v37);
              v30 = 0;
            }
LABEL_49:
            if (v30)
              return;
            goto LABEL_50;
          }
        }
        v30 = v69;
        v69 = 0;
        *a4 = v30;
        if (v30)
          goto LABEL_49;
        goto LABEL_40;
      }
    }
    v30 = v71;
LABEL_48:
    *a4 = v30;
    goto LABEL_49;
  }
LABEL_51:
  v51 = 0;
LABEL_53:
  *a4 = v51;
}

_QWORD *sub_1C5475F08(_QWORD *a1)
{
  *a1 = &off_1E81693E8;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  return a1;
}

void sub_1C5475F4C(_QWORD *a1)
{
  *a1 = &off_1E81693E8;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5475FA0(uint64_t a1@<X0>, unsigned int *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  size_t v5;
  int *v6;
  char *v7;
  uint64_t v8;
  unsigned int v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned __int8 **v24;
  unsigned __int8 **v25;
  char v26;
  uint64_t v27;
  unsigned __int8 *v28;
  char v29;
  int v30;
  unsigned __int8 *v31;
  unsigned __int8 *v32;
  uint64_t v33;
  char *v34[3];
  __int128 v35;
  uint64_t v36;
  unint64_t v37;
  __int128 v38;
  uint64_t v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  if ((unint64_t)(a2 + 4) > a3)
    goto LABEL_3;
  v5 = a2[1];
  v6 = (int *)((char *)a2 + 29 * *a2 + 16);
  v7 = (char *)v6 + v5;
  if ((unint64_t)v6 + v5 > a3)
    goto LABEL_3;
  v10 = a2[2];
  v11 = *(char **)(a1 + 56);
  v13 = *(_QWORD *)v11;
  v12 = *((_QWORD *)v11 + 1);
  v34[0] = (char *)a2 + 29 * *a2 + 16;
  v34[1] = (char *)v5;
  v34[2] = v11;
  v35 = *(_OWORD *)(a1 + 40);
  llvm::coverage::RawCoverageFilenamesReader::read(v34, 4, (char ***)&v38);
  v14 = v38;
  if ((_QWORD)v38)
  {
    v15 = *(_BYTE *)(a4 + 8) | 1;
LABEL_7:
    *(_BYTE *)(a4 + 8) = v15;
    *(_QWORD *)a4 = v14;
    return;
  }
  v16 = 0xAAAAAAAAAAAAAAABLL * ((v12 - v13) >> 3);
  v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) - **(_QWORD **)(a1 + 56)) >> 3) - v16;
  v38 = xmmword_1C85F4BB0;
  v39 = 0;
  llvm::MD5::update((int *)&v38, v6, v5);
  llvm::MD5::final((int *)&v38, (int *)&v36);
  v37 = v16 | ((unint64_t)v17 << 32);
  sub_1C54701B8((uint64_t **)&v38, a1 + 72, &v36, (uint64_t *)&v37);
  if (!(_BYTE)v39)
  {
    v18 = v38;
    v19 = *(unsigned int *)(v38 + 12);
    if (v17 != v19)
      goto LABEL_31;
    v20 = v16;
    v21 = **(_QWORD **)(a1 + 56);
    v22 = v21 + 24 * *(unsigned int *)(v38 + 8);
    v23 = v22 + 24 * v19;
    v24 = (unsigned __int8 **)(v21 + 24 * v20);
    v25 = &v24[3 * v17];
    if ((_DWORD)v19)
    {
      do
      {
        v26 = *(_BYTE *)(v22 + 23);
        v27 = v26 & 0x7F;
        if (v26 >= 0)
          v28 = (unsigned __int8 *)(v26 & 0x7F);
        else
          v28 = *(unsigned __int8 **)(v22 + 8);
        v29 = *((_BYTE *)v24 + 23);
        v30 = v29;
        v31 = (unsigned __int8 *)(v29 & 0x7F);
        if (v30 < 0)
          v31 = v24[1];
        if (v28 != v31)
          goto LABEL_31;
        if (v30 >= 0)
          v32 = (unsigned __int8 *)v24;
        else
          v32 = *v24;
        if ((*(_BYTE *)(v22 + 23) & 0x80) != 0)
        {
          if (memcmp(*(const void **)v22, v32, *(_QWORD *)(v22 + 8)))
            goto LABEL_31;
        }
        else if ((v26 & 0x7F) != 0)
        {
          v33 = 0;
          while (*(unsigned __int8 *)(v22 + v33) == v32[v33])
          {
            if (v27 == ++v33)
              goto LABEL_27;
          }
          goto LABEL_31;
        }
LABEL_27:
        v22 += 24;
        v24 += 3;
      }
      while (v22 != v23 && v24 != v25);
    }
    if (v22 != v23 || v24 != v25)
LABEL_31:
      *(_DWORD *)(v18 + 12) = 0;
  }
  if (!v10)
  {
    v14 = (unint64_t)(v7 + 7) & 0xFFFFFFFFFFFFFFF8;
    v15 = *(_BYTE *)(a4 + 8) & 0xFE;
    goto LABEL_7;
  }
LABEL_3:
  v8 = operator new();
  *(_QWORD *)v8 = &off_1E8169028;
  *(_DWORD *)(v8 + 8) = 5;
  *(_BYTE *)(a4 + 8) |= 1u;
  *(_QWORD *)a4 = v8;
}

void sub_1C5476244(uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  unint64_t v4;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  unint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t *v21;
  _QWORD *v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  _QWORD *v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t *v36;
  __n128 v37;
  char v38;
  _QWORD *v39;
  unint64_t v40;
  uint64_t v41;
  char *v42;
  char *v43;
  char *v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  char *v48;
  unint64_t *v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t *v65;
  char v66;
  _OWORD v67[2];
  __int16 v68;
  uint64_t v69;
  char v70;
  uint64_t v71;
  char v72;
  uint64_t v73;

  v73 = *MEMORY[0x1E0C80C00];
  if (a2 < a3)
  {
    v4 = a2;
    v61 = a1 + 8;
    while (1)
    {
      v6 = *(unsigned int *)(v4 + 8);
      v7 = *(_QWORD *)(a1 + 72);
      v8 = *(unsigned int *)(a1 + 88);
      v9 = sub_1C5470560(v7, *(_DWORD *)(a1 + 88), *(_QWORD *)(v4 + 20));
      if ((uint64_t *)(v7 + 16 * v8) == v9)
      {
LABEL_52:
        v51 = operator new();
        *(_QWORD *)v51 = &off_1E8169028;
        *(_DWORD *)(v51 + 8) = 5;
        goto LABEL_53;
      }
      v10 = v4 + 28;
      v11 = v4 + 28 + v6;
      v12 = v9[1];
      v13 = HIDWORD(v12);
      if (HIDWORD(v12))
        break;
LABEL_50:
      v4 = (v11 + 7) & 0xFFFFFFFFFFFFFFF8;
      if (v4 >= a3)
        goto LABEL_51;
    }
    if (v11 > a3)
      goto LABEL_52;
    v62 = *(_QWORD *)(v4 + 12);
    v14 = (uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) - **(_QWORD **)(a1 + 64)) >> 6;
    *(_QWORD *)&v67[0] = *(_QWORD *)v4;
    *((_QWORD *)&v67[0] + 1) = v14;
    sub_1C546C7AC(&v65, v61, (uint64_t *)v67, (uint64_t *)v67 + 1);
    if (v66)
    {
      v15 = *(uint64_t **)(a1 + 32);
      v16 = *(_QWORD *)v4;
      sub_1C546CB40(v15);
      v17 = (_QWORD *)v15[7];
      v18 = (_QWORD *)v15[8];
      if (v18 != v17)
      {
        v19 = 0xAAAAAAAAAAAAAAABLL * (v18 - v17);
        do
        {
          v20 = v19 >> 1;
          v21 = &v17[3 * (v19 >> 1)];
          v23 = *v21;
          v22 = v21 + 3;
          v19 += ~(v19 >> 1);
          if (v23 < v16)
            v17 = v22;
          else
            v19 = v20;
        }
        while (v19);
      }
      if (v17 != v18 && *v17 == v16 && (v24 = v17[2]) != 0)
      {
        v25 = v17[1];
        v26 = *(_QWORD *)(a1 + 64);
        v28 = *(_QWORD **)(v26 + 8);
        v27 = *(_QWORD *)(v26 + 16);
        if ((unint64_t)v28 >= v27)
        {
          v39 = *(_QWORD **)v26;
          v40 = (((uint64_t)v28 - *(_QWORD *)v26) >> 6) + 1;
          if (v40 >> 58)
            abort();
          v53 = ((uint64_t)v28 - *(_QWORD *)v26) >> 6;
          v54 = v25;
          v56 = v24;
          v59 = *(_QWORD *)(a1 + 64);
          v41 = v27 - (_QWORD)v39;
          if (v41 >> 5 > v40)
            v40 = v41 >> 5;
          if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFC0)
            v40 = 0x3FFFFFFFFFFFFFFLL;
          if (v40 >> 58)
            sub_1C4764EE4();
          v52 = v40;
          v42 = (char *)operator new(v40 << 6);
          v43 = &v42[64 * v53];
          *(_DWORD *)v43 = 4;
          *((_QWORD *)v43 + 1) = v54;
          *((_QWORD *)v43 + 2) = v56;
          *((_QWORD *)v43 + 3) = v62;
          *((_QWORD *)v43 + 4) = v10;
          *((_QWORD *)v43 + 5) = v6;
          *((_QWORD *)v43 + 6) = v12;
          *((_QWORD *)v43 + 7) = v13;
          if (v28 == v39)
          {
            v48 = &v42[64 * v53];
            v26 = v59;
          }
          else
          {
            v44 = &v42[64 * v53];
            v26 = v59;
            do
            {
              v45 = *((_OWORD *)v28 - 4);
              v46 = *((_OWORD *)v28 - 3);
              v47 = *((_OWORD *)v28 - 1);
              v48 = v44 - 64;
              *((_OWORD *)v44 - 2) = *((_OWORD *)v28 - 2);
              *((_OWORD *)v44 - 1) = v47;
              *((_OWORD *)v44 - 4) = v45;
              *((_OWORD *)v44 - 3) = v46;
              v28 -= 8;
              v44 -= 64;
            }
            while (v28 != v39);
          }
          v29 = v43 + 64;
          *(_QWORD *)v26 = v48;
          *(_QWORD *)(v26 + 8) = v43 + 64;
          *(_QWORD *)(v26 + 16) = &v42[64 * v52];
          if (v39)
          {
            operator delete(v39);
            v26 = v59;
          }
        }
        else
        {
          *(_DWORD *)v28 = 4;
          v28[1] = v25;
          v28[2] = v24;
          v28[3] = v62;
          v28[4] = v10;
          v28[5] = v6;
          v28[6] = v12;
          v29 = (char *)(v28 + 8);
          v28[7] = v13;
        }
        v30 = 0;
        *(_QWORD *)(v26 + 8) = v29;
      }
      else
      {
        v30 = operator new();
        *(_QWORD *)&v67[0] = "function name is empty";
        v68 = 259;
        *(_QWORD *)v30 = off_1E8192D50;
        *(_DWORD *)(v30 + 8) = 9;
        llvm::Twine::str((llvm::Twine *)v67, (_QWORD *)(v30 + 16));
      }
      goto LABEL_48;
    }
    v31 = v65[1];
    v32 = **(_QWORD **)(a1 + 64);
    v33 = v32 + (v31 << 6);
    v35 = *(_QWORD *)(v33 + 24);
    v34 = v33 + 24;
    v36 = (unint64_t *)(v34 + 8);
    v37 = *(__n128 *)(v34 + 8);
    if (v35)
    {
      v72 &= ~1u;
      LOBYTE(v71) = 0;
      if ((v72 & 1) == 0)
        goto LABEL_21;
    }
    else
    {
      v67[0] = *(_OWORD *)(v34 + 8);
      v55 = v31;
      v58 = v32;
      llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v67, (uint64_t)&v71);
      v31 = v55;
      v32 = v58;
      v36 = (unint64_t *)(v34 + 8);
      if ((v72 & 1) == 0)
      {
LABEL_21:
        if (!(_BYTE)v71)
        {
LABEL_25:
          v30 = 0;
          *a4 = 0;
          goto LABEL_49;
        }
        if (v62)
        {
          v70 &= ~1u;
          v38 = v70;
          LOBYTE(v69) = 0;
          if ((v70 & 1) == 0)
            goto LABEL_24;
        }
        else
        {
          *(_QWORD *)&v67[0] = v4 + 28;
          *((_QWORD *)&v67[0] + 1) = v6;
          v57 = v31;
          v60 = v32;
          v49 = v36;
          llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v67, (uint64_t)&v69);
          v31 = v57;
          v32 = v60;
          v36 = v49;
          v38 = v70;
          if ((v70 & 1) == 0)
          {
LABEL_24:
            if ((_BYTE)v69)
              goto LABEL_25;
LABEL_40:
            v30 = 0;
            *(_QWORD *)v34 = v62;
            *v36 = v10;
            v36[1] = v6;
            v50 = v32 + (v31 << 6);
            *(_QWORD *)(v50 + 48) = v12;
            *(_QWORD *)(v50 + 56) = v13;
            *a4 = 0;
            if ((v38 & 1) != 0)
            {
              if (v69)
                (*(void (**)(uint64_t, __n128))(*(_QWORD *)v69 + 8))(v69, v37);
              v30 = 0;
            }
LABEL_49:
            if (v30)
              return;
            goto LABEL_50;
          }
        }
        v30 = v69;
        v69 = 0;
        *a4 = v30;
        if (v30)
          goto LABEL_49;
        goto LABEL_40;
      }
    }
    v30 = v71;
LABEL_48:
    *a4 = v30;
    goto LABEL_49;
  }
LABEL_51:
  v51 = 0;
LABEL_53:
  *a4 = v51;
}

_QWORD *sub_1C54766E4(_QWORD *a1)
{
  *a1 = &off_1E8169418;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  return a1;
}

void sub_1C5476728(_QWORD *a1)
{
  *a1 = &off_1E8169418;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C547677C(uint64_t a1@<X0>, unsigned int *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  size_t v5;
  int *v6;
  char *v7;
  uint64_t v8;
  unsigned int v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned __int8 **v24;
  unsigned __int8 **v25;
  char v26;
  uint64_t v27;
  unsigned __int8 *v28;
  char v29;
  int v30;
  unsigned __int8 *v31;
  unsigned __int8 *v32;
  uint64_t v33;
  char *v34[3];
  __int128 v35;
  uint64_t v36;
  unint64_t v37;
  __int128 v38;
  uint64_t v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  if ((unint64_t)(a2 + 4) > a3)
    goto LABEL_3;
  v5 = a2[1];
  v6 = (int *)((char *)a2 + 29 * *a2 + 16);
  v7 = (char *)v6 + v5;
  if ((unint64_t)v6 + v5 > a3)
    goto LABEL_3;
  v10 = a2[2];
  v11 = *(char **)(a1 + 56);
  v13 = *(_QWORD *)v11;
  v12 = *((_QWORD *)v11 + 1);
  v34[0] = (char *)a2 + 29 * *a2 + 16;
  v34[1] = (char *)v5;
  v34[2] = v11;
  v35 = *(_OWORD *)(a1 + 40);
  llvm::coverage::RawCoverageFilenamesReader::read(v34, 5, (char ***)&v38);
  v14 = v38;
  if ((_QWORD)v38)
  {
    v15 = *(_BYTE *)(a4 + 8) | 1;
LABEL_7:
    *(_BYTE *)(a4 + 8) = v15;
    *(_QWORD *)a4 = v14;
    return;
  }
  v16 = 0xAAAAAAAAAAAAAAABLL * ((v12 - v13) >> 3);
  v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) - **(_QWORD **)(a1 + 56)) >> 3) - v16;
  v38 = xmmword_1C85F4BB0;
  v39 = 0;
  llvm::MD5::update((int *)&v38, v6, v5);
  llvm::MD5::final((int *)&v38, (int *)&v36);
  v37 = v16 | ((unint64_t)v17 << 32);
  sub_1C54701B8((uint64_t **)&v38, a1 + 72, &v36, (uint64_t *)&v37);
  if (!(_BYTE)v39)
  {
    v18 = v38;
    v19 = *(unsigned int *)(v38 + 12);
    if (v17 != v19)
      goto LABEL_31;
    v20 = v16;
    v21 = **(_QWORD **)(a1 + 56);
    v22 = v21 + 24 * *(unsigned int *)(v38 + 8);
    v23 = v22 + 24 * v19;
    v24 = (unsigned __int8 **)(v21 + 24 * v20);
    v25 = &v24[3 * v17];
    if ((_DWORD)v19)
    {
      do
      {
        v26 = *(_BYTE *)(v22 + 23);
        v27 = v26 & 0x7F;
        if (v26 >= 0)
          v28 = (unsigned __int8 *)(v26 & 0x7F);
        else
          v28 = *(unsigned __int8 **)(v22 + 8);
        v29 = *((_BYTE *)v24 + 23);
        v30 = v29;
        v31 = (unsigned __int8 *)(v29 & 0x7F);
        if (v30 < 0)
          v31 = v24[1];
        if (v28 != v31)
          goto LABEL_31;
        if (v30 >= 0)
          v32 = (unsigned __int8 *)v24;
        else
          v32 = *v24;
        if ((*(_BYTE *)(v22 + 23) & 0x80) != 0)
        {
          if (memcmp(*(const void **)v22, v32, *(_QWORD *)(v22 + 8)))
            goto LABEL_31;
        }
        else if ((v26 & 0x7F) != 0)
        {
          v33 = 0;
          while (*(unsigned __int8 *)(v22 + v33) == v32[v33])
          {
            if (v27 == ++v33)
              goto LABEL_27;
          }
          goto LABEL_31;
        }
LABEL_27:
        v22 += 24;
        v24 += 3;
      }
      while (v22 != v23 && v24 != v25);
    }
    if (v22 != v23 || v24 != v25)
LABEL_31:
      *(_DWORD *)(v18 + 12) = 0;
  }
  if (!v10)
  {
    v14 = (unint64_t)(v7 + 7) & 0xFFFFFFFFFFFFFFF8;
    v15 = *(_BYTE *)(a4 + 8) & 0xFE;
    goto LABEL_7;
  }
LABEL_3:
  v8 = operator new();
  *(_QWORD *)v8 = &off_1E8169028;
  *(_DWORD *)(v8 + 8) = 5;
  *(_BYTE *)(a4 + 8) |= 1u;
  *(_QWORD *)a4 = v8;
}

void sub_1C5476A20(uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  unint64_t v4;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  unint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t *v21;
  _QWORD *v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  _QWORD *v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t *v36;
  __n128 v37;
  char v38;
  _QWORD *v39;
  unint64_t v40;
  uint64_t v41;
  char *v42;
  char *v43;
  char *v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  char *v48;
  unint64_t *v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t *v65;
  char v66;
  _OWORD v67[2];
  __int16 v68;
  uint64_t v69;
  char v70;
  uint64_t v71;
  char v72;
  uint64_t v73;

  v73 = *MEMORY[0x1E0C80C00];
  if (a2 < a3)
  {
    v4 = a2;
    v61 = a1 + 8;
    while (1)
    {
      v6 = *(unsigned int *)(v4 + 8);
      v7 = *(_QWORD *)(a1 + 72);
      v8 = *(unsigned int *)(a1 + 88);
      v9 = sub_1C5470560(v7, *(_DWORD *)(a1 + 88), *(_QWORD *)(v4 + 20));
      if ((uint64_t *)(v7 + 16 * v8) == v9)
      {
LABEL_52:
        v51 = operator new();
        *(_QWORD *)v51 = &off_1E8169028;
        *(_DWORD *)(v51 + 8) = 5;
        goto LABEL_53;
      }
      v10 = v4 + 28;
      v11 = v4 + 28 + v6;
      v12 = v9[1];
      v13 = HIDWORD(v12);
      if (HIDWORD(v12))
        break;
LABEL_50:
      v4 = (v11 + 7) & 0xFFFFFFFFFFFFFFF8;
      if (v4 >= a3)
        goto LABEL_51;
    }
    if (v11 > a3)
      goto LABEL_52;
    v62 = *(_QWORD *)(v4 + 12);
    v14 = (uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) - **(_QWORD **)(a1 + 64)) >> 6;
    *(_QWORD *)&v67[0] = *(_QWORD *)v4;
    *((_QWORD *)&v67[0] + 1) = v14;
    sub_1C546C7AC(&v65, v61, (uint64_t *)v67, (uint64_t *)v67 + 1);
    if (v66)
    {
      v15 = *(uint64_t **)(a1 + 32);
      v16 = *(_QWORD *)v4;
      sub_1C546CB40(v15);
      v17 = (_QWORD *)v15[7];
      v18 = (_QWORD *)v15[8];
      if (v18 != v17)
      {
        v19 = 0xAAAAAAAAAAAAAAABLL * (v18 - v17);
        do
        {
          v20 = v19 >> 1;
          v21 = &v17[3 * (v19 >> 1)];
          v23 = *v21;
          v22 = v21 + 3;
          v19 += ~(v19 >> 1);
          if (v23 < v16)
            v17 = v22;
          else
            v19 = v20;
        }
        while (v19);
      }
      if (v17 != v18 && *v17 == v16 && (v24 = v17[2]) != 0)
      {
        v25 = v17[1];
        v26 = *(_QWORD *)(a1 + 64);
        v28 = *(_QWORD **)(v26 + 8);
        v27 = *(_QWORD *)(v26 + 16);
        if ((unint64_t)v28 >= v27)
        {
          v39 = *(_QWORD **)v26;
          v40 = (((uint64_t)v28 - *(_QWORD *)v26) >> 6) + 1;
          if (v40 >> 58)
            abort();
          v53 = ((uint64_t)v28 - *(_QWORD *)v26) >> 6;
          v54 = v25;
          v56 = v24;
          v59 = *(_QWORD *)(a1 + 64);
          v41 = v27 - (_QWORD)v39;
          if (v41 >> 5 > v40)
            v40 = v41 >> 5;
          if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFC0)
            v40 = 0x3FFFFFFFFFFFFFFLL;
          if (v40 >> 58)
            sub_1C4764EE4();
          v52 = v40;
          v42 = (char *)operator new(v40 << 6);
          v43 = &v42[64 * v53];
          *(_DWORD *)v43 = 5;
          *((_QWORD *)v43 + 1) = v54;
          *((_QWORD *)v43 + 2) = v56;
          *((_QWORD *)v43 + 3) = v62;
          *((_QWORD *)v43 + 4) = v10;
          *((_QWORD *)v43 + 5) = v6;
          *((_QWORD *)v43 + 6) = v12;
          *((_QWORD *)v43 + 7) = v13;
          if (v28 == v39)
          {
            v48 = &v42[64 * v53];
            v26 = v59;
          }
          else
          {
            v44 = &v42[64 * v53];
            v26 = v59;
            do
            {
              v45 = *((_OWORD *)v28 - 4);
              v46 = *((_OWORD *)v28 - 3);
              v47 = *((_OWORD *)v28 - 1);
              v48 = v44 - 64;
              *((_OWORD *)v44 - 2) = *((_OWORD *)v28 - 2);
              *((_OWORD *)v44 - 1) = v47;
              *((_OWORD *)v44 - 4) = v45;
              *((_OWORD *)v44 - 3) = v46;
              v28 -= 8;
              v44 -= 64;
            }
            while (v28 != v39);
          }
          v29 = v43 + 64;
          *(_QWORD *)v26 = v48;
          *(_QWORD *)(v26 + 8) = v43 + 64;
          *(_QWORD *)(v26 + 16) = &v42[64 * v52];
          if (v39)
          {
            operator delete(v39);
            v26 = v59;
          }
        }
        else
        {
          *(_DWORD *)v28 = 5;
          v28[1] = v25;
          v28[2] = v24;
          v28[3] = v62;
          v28[4] = v10;
          v28[5] = v6;
          v28[6] = v12;
          v29 = (char *)(v28 + 8);
          v28[7] = v13;
        }
        v30 = 0;
        *(_QWORD *)(v26 + 8) = v29;
      }
      else
      {
        v30 = operator new();
        *(_QWORD *)&v67[0] = "function name is empty";
        v68 = 259;
        *(_QWORD *)v30 = off_1E8192D50;
        *(_DWORD *)(v30 + 8) = 9;
        llvm::Twine::str((llvm::Twine *)v67, (_QWORD *)(v30 + 16));
      }
      goto LABEL_48;
    }
    v31 = v65[1];
    v32 = **(_QWORD **)(a1 + 64);
    v33 = v32 + (v31 << 6);
    v35 = *(_QWORD *)(v33 + 24);
    v34 = v33 + 24;
    v36 = (unint64_t *)(v34 + 8);
    v37 = *(__n128 *)(v34 + 8);
    if (v35)
    {
      v72 &= ~1u;
      LOBYTE(v71) = 0;
      if ((v72 & 1) == 0)
        goto LABEL_21;
    }
    else
    {
      v67[0] = *(_OWORD *)(v34 + 8);
      v55 = v31;
      v58 = v32;
      llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v67, (uint64_t)&v71);
      v31 = v55;
      v32 = v58;
      v36 = (unint64_t *)(v34 + 8);
      if ((v72 & 1) == 0)
      {
LABEL_21:
        if (!(_BYTE)v71)
        {
LABEL_25:
          v30 = 0;
          *a4 = 0;
          goto LABEL_49;
        }
        if (v62)
        {
          v70 &= ~1u;
          v38 = v70;
          LOBYTE(v69) = 0;
          if ((v70 & 1) == 0)
            goto LABEL_24;
        }
        else
        {
          *(_QWORD *)&v67[0] = v4 + 28;
          *((_QWORD *)&v67[0] + 1) = v6;
          v57 = v31;
          v60 = v32;
          v49 = v36;
          llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v67, (uint64_t)&v69);
          v31 = v57;
          v32 = v60;
          v36 = v49;
          v38 = v70;
          if ((v70 & 1) == 0)
          {
LABEL_24:
            if ((_BYTE)v69)
              goto LABEL_25;
LABEL_40:
            v30 = 0;
            *(_QWORD *)v34 = v62;
            *v36 = v10;
            v36[1] = v6;
            v50 = v32 + (v31 << 6);
            *(_QWORD *)(v50 + 48) = v12;
            *(_QWORD *)(v50 + 56) = v13;
            *a4 = 0;
            if ((v38 & 1) != 0)
            {
              if (v69)
                (*(void (**)(uint64_t, __n128))(*(_QWORD *)v69 + 8))(v69, v37);
              v30 = 0;
            }
LABEL_49:
            if (v30)
              return;
            goto LABEL_50;
          }
        }
        v30 = v69;
        v69 = 0;
        *a4 = v30;
        if (v30)
          goto LABEL_49;
        goto LABEL_40;
      }
    }
    v30 = v71;
LABEL_48:
    *a4 = v30;
    goto LABEL_49;
  }
LABEL_51:
  v51 = 0;
LABEL_53:
  *a4 = v51;
}

_QWORD *sub_1C5476EC0(_QWORD *a1)
{
  *a1 = &off_1E8169448;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  return a1;
}

void sub_1C5476F04(_QWORD *a1)
{
  *a1 = &off_1E8169448;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5476F58(uint64_t a1@<X0>, unsigned int *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unsigned int *v5;
  unsigned int v7;
  char *v8;
  unsigned int *v9;
  char *v10;
  uint64_t v11;
  unsigned int v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char **v17;
  char v18;
  unint64_t v19;
  char **v20;
  char *v21[3];
  __int128 v22;

  v5 = a2 + 4;
  if ((unint64_t)(a2 + 4) > a3)
    goto LABEL_3;
  v7 = bswap32(*a2);
  v8 = (char *)bswap32(a2[1]);
  v9 = &v5[6 * v7];
  v10 = &v8[(_QWORD)v9];
  if (&v8[(_QWORD)v9] > (char *)a3)
    goto LABEL_3;
  v13 = a2[2];
  v14 = *(char **)(a1 + 56);
  v16 = *(_QWORD *)v14;
  v15 = *((_QWORD *)v14 + 1);
  v21[0] = (char *)&v5[6 * v7];
  v21[1] = v8;
  v21[2] = v14;
  v22 = *(_OWORD *)(a1 + 40);
  llvm::coverage::RawCoverageFilenamesReader::read(v21, 0, &v20);
  v17 = v20;
  if (v20)
    goto LABEL_5;
  v19 = (unint64_t)&v10[bswap32(v13)];
  if (v19 > a3)
  {
LABEL_3:
    v11 = operator new();
    *(_QWORD *)v11 = &off_1E8169028;
    *(_DWORD *)(v11 + 8) = 5;
    *(_BYTE *)(a4 + 8) |= 1u;
    *(_QWORD *)a4 = v11;
    return;
  }
  (*(void (**)(char ***__return_ptr, uint64_t, unsigned int *, unsigned int *, unint64_t, uint64_t, char *, unint64_t))(*(_QWORD *)a1 + 24))(&v20, a1, v5, v9, (-1431655765 * ((v15 - v16) >> 3)) | ((unint64_t)(-1431655765* ((*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8)- **(_QWORD **)(a1 + 56)) >> 3)- -1431655765* ((v15 - v16) >> 3)) << 32), 1, v10, v19);
  v17 = v20;
  if (v20)
  {
LABEL_5:
    v18 = *(_BYTE *)(a4 + 8) | 1;
  }
  else
  {
    v17 = (char **)((v19 + 7) & 0xFFFFFFFFFFFFFFF8);
    v18 = *(_BYTE *)(a4 + 8) & 0xFE;
  }
  *(_BYTE *)(a4 + 8) = v18;
  *(_QWORD *)a4 = v17;
}

void sub_1C54770E4(uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, unint64_t a4@<X3>, char a5@<W4>, uint64_t a6@<X5>, unint64_t a7@<X6>, uint64_t *a8@<X8>)
{
  uint64_t *v8;
  unint64_t v9;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  BOOL v14;
  char v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  unsigned int v20;
  unint64_t v21;
  unint64_t v22;
  BOOL v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  __n128 v35;
  char v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  _QWORD *v40;
  char *v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  char *v48;
  char *v49;
  char *v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  char *v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  char v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t *v67;
  char v68;
  _OWORD v69[2];
  __int16 v70;
  uint64_t v71;
  char v72;
  uint64_t v73;
  char v74;
  uint64_t v75;

  v8 = a8;
  v75 = *MEMORY[0x1E0C80C00];
  if (a2 < a3)
  {
    v9 = a7;
    v11 = a3;
    v12 = a2;
    v13 = a1;
    v60 = HIDWORD(a4);
    if (a5)
      v14 = HIDWORD(a4) == 0;
    else
      v14 = 1;
    v15 = v14;
    v65 = a1 + 8;
    v59 = a4;
    v64 = v15;
    while (1)
    {
      v16 = bswap32(*(_DWORD *)(v12 + 12));
      if (a6 + v16 > v9)
      {
LABEL_64:
        v56 = operator new();
        *(_QWORD *)v56 = &off_1E8169028;
        *(_DWORD *)(v56 + 8) = 5;
        goto LABEL_65;
      }
      if ((v15 & 1) == 0)
        break;
LABEL_55:
      v12 += 24;
      a6 += v16;
      if (v12 >= v11)
        goto LABEL_63;
    }
    v17 = *(_QWORD *)(v12 + 16);
    v66 = bswap64(v17);
    v18 = (uint64_t)(*(_QWORD *)(*(_QWORD *)(v13 + 64) + 8) - **(_QWORD **)(v13 + 64)) >> 6;
    *(_QWORD *)&v69[0] = bswap64(*(_QWORD *)v12);
    *((_QWORD *)&v69[0] + 1) = v18;
    sub_1C546C7AC(&v67, v65, (uint64_t *)v69, (uint64_t *)v69 + 1);
    if (!v68)
    {
      v29 = v13;
      v30 = v67[1];
      v31 = **(_QWORD **)(v29 + 64);
      v32 = v31 + (v30 << 6);
      v34 = *(_QWORD *)(v32 + 24);
      v33 = v32 + 24;
      v35 = *(__n128 *)(v33 + 8);
      if (v34)
      {
        v74 &= ~1u;
        LOBYTE(v73) = 0;
        if ((v74 & 1) == 0)
          goto LABEL_19;
LABEL_46:
        v37 = v73;
        *v8 = v73;
LABEL_47:
        v11 = a3;
        v9 = a7;
        v13 = a1;
        v15 = v64;
        if (v37)
          return;
        goto LABEL_55;
      }
      v69[0] = *(_OWORD *)(v33 + 8);
      llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v69, (uint64_t)&v73);
      if ((v74 & 1) != 0)
        goto LABEL_46;
LABEL_19:
      if ((_BYTE)v73)
      {
        if (v17)
        {
          v72 &= ~1u;
          v36 = v72;
          LOBYTE(v71) = 0;
          if ((v72 & 1) == 0)
            goto LABEL_22;
LABEL_58:
          v37 = v71;
          v71 = 0;
          *v8 = v37;
          if (v37)
            goto LABEL_47;
          goto LABEL_59;
        }
        *(_QWORD *)&v69[0] = a6;
        *((_QWORD *)&v69[0] + 1) = v16;
        llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v69, (uint64_t)&v71);
        v36 = v72;
        if ((v72 & 1) != 0)
          goto LABEL_58;
LABEL_22:
        if (!(_BYTE)v71)
        {
LABEL_59:
          v37 = 0;
          *(_QWORD *)v33 = v66;
          *(_QWORD *)(v33 + 8) = a6;
          *(_QWORD *)(v33 + 16) = v16;
          v55 = v31 + (v30 << 6);
          *(_QWORD *)(v55 + 48) = v59;
          *(_QWORD *)(v55 + 56) = v60;
          *v8 = 0;
          if ((v36 & 1) != 0)
          {
            if (v71)
              (*(void (**)(uint64_t, __n128))(*(_QWORD *)v71 + 8))(v71, v35);
            v37 = 0;
          }
          goto LABEL_47;
        }
      }
      v37 = 0;
      *v8 = 0;
      goto LABEL_47;
    }
    v19 = *(_QWORD **)(v13 + 32);
    v20 = *(_DWORD *)(v12 + 8);
    v21 = bswap64(*(_QWORD *)v12);
    v22 = v19[2];
    v23 = v21 >= v22;
    v24 = v21 - v22;
    if (v23 && (v25 = bswap32(v20), v26 = v19[1], v24 + v25 <= v26))
    {
      if (v26 < v24)
        v24 = v19[1];
      v27 = *v19 + v24;
      if (v26 - v24 >= v25)
        v28 = v25;
      else
        v28 = v26 - v24;
      if (!v20)
      {
LABEL_31:
        if (v28)
        {
          v38 = *(_QWORD *)(v13 + 64);
          v40 = *(_QWORD **)(v38 + 8);
          v39 = *(_QWORD *)(v38 + 16);
          if ((unint64_t)v40 >= v39)
          {
            v43 = *(_QWORD **)v38;
            v44 = ((uint64_t)v40 - *(_QWORD *)v38) >> 6;
            v45 = v44 + 1;
            if ((unint64_t)(v44 + 1) >> 58)
              abort();
            v46 = v39 - (_QWORD)v43;
            if (v46 >> 5 > v45)
              v45 = v46 >> 5;
            if ((unint64_t)v46 >= 0x7FFFFFFFFFFFFFC0)
              v45 = 0x3FFFFFFFFFFFFFFLL;
            if (v45 >> 58)
              sub_1C4764EE4();
            v47 = v27;
            v58 = v45;
            v48 = (char *)operator new(v45 << 6);
            v49 = &v48[64 * v44];
            *(_DWORD *)v49 = 0;
            *((_QWORD *)v49 + 1) = v47;
            *((_QWORD *)v49 + 2) = v28;
            *((_QWORD *)v49 + 3) = v66;
            *((_QWORD *)v49 + 4) = a6;
            *((_QWORD *)v49 + 5) = v16;
            *((_QWORD *)v49 + 6) = v59;
            *((_QWORD *)v49 + 7) = v60;
            if (v40 == v43)
            {
              v54 = &v48[64 * v44];
              v15 = v64;
            }
            else
            {
              v50 = &v48[64 * v44];
              v15 = v64;
              do
              {
                v51 = *((_OWORD *)v40 - 4);
                v52 = *((_OWORD *)v40 - 3);
                v53 = *((_OWORD *)v40 - 1);
                v54 = v50 - 64;
                *((_OWORD *)v50 - 2) = *((_OWORD *)v40 - 2);
                *((_OWORD *)v50 - 1) = v53;
                *((_OWORD *)v50 - 4) = v51;
                *((_OWORD *)v50 - 3) = v52;
                v40 -= 8;
                v50 -= 64;
              }
              while (v40 != v43);
            }
            v41 = v49 + 64;
            *(_QWORD *)v38 = v54;
            *(_QWORD *)(v38 + 8) = v49 + 64;
            *(_QWORD *)(v38 + 16) = &v48[64 * v58];
            if (v43)
              operator delete(v43);
            v8 = a8;
            v9 = a7;
          }
          else
          {
            *(_DWORD *)v40 = 0;
            v40[1] = v27;
            v40[2] = v28;
            v40[3] = v66;
            v40[4] = a6;
            v40[5] = v16;
            v40[6] = v59;
            v41 = (char *)(v40 + 8);
            v40[7] = v60;
            v9 = a7;
            v15 = v64;
          }
          v42 = 0;
          *(_QWORD *)(v38 + 8) = v41;
          v13 = a1;
          v11 = a3;
        }
        else
        {
          v42 = operator new();
          *(_QWORD *)&v69[0] = "function name is empty";
          v70 = 259;
          *(_QWORD *)v42 = off_1E8192D50;
          *(_DWORD *)(v42 + 8) = 9;
          llvm::Twine::str((llvm::Twine *)v69, (_QWORD *)(v42 + 16));
          v15 = v64;
        }
        *v8 = v42;
        if (v42)
          return;
        goto LABEL_55;
      }
    }
    else
    {
      v27 = 0;
      v28 = 0;
      if (!v20)
        goto LABEL_31;
    }
    if (!v28)
      goto LABEL_64;
    goto LABEL_31;
  }
LABEL_63:
  v56 = 0;
LABEL_65:
  *v8 = v56;
}

_QWORD *sub_1C5477568(_QWORD *a1)
{
  *a1 = &off_1E8169478;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  return a1;
}

void sub_1C54775AC(_QWORD *a1)
{
  *a1 = &off_1E8169478;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5477600(uint64_t a1@<X0>, unsigned int *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unsigned int *v5;
  unsigned int v7;
  char *v8;
  unsigned int *v9;
  char *v10;
  uint64_t v11;
  unsigned int v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char **v17;
  char v18;
  unint64_t v19;
  char **v20;
  char *v21[3];
  __int128 v22;

  v5 = a2 + 4;
  if ((unint64_t)(a2 + 4) > a3)
    goto LABEL_3;
  v7 = bswap32(*a2);
  v8 = (char *)bswap32(a2[1]);
  v9 = &v5[5 * v7];
  v10 = &v8[(_QWORD)v9];
  if (&v8[(_QWORD)v9] > (char *)a3)
    goto LABEL_3;
  v13 = a2[2];
  v14 = *(char **)(a1 + 56);
  v16 = *(_QWORD *)v14;
  v15 = *((_QWORD *)v14 + 1);
  v21[0] = (char *)&v5[5 * v7];
  v21[1] = v8;
  v21[2] = v14;
  v22 = *(_OWORD *)(a1 + 40);
  llvm::coverage::RawCoverageFilenamesReader::read(v21, 1, &v20);
  v17 = v20;
  if (v20)
    goto LABEL_5;
  v19 = (unint64_t)&v10[bswap32(v13)];
  if (v19 > a3)
  {
LABEL_3:
    v11 = operator new();
    *(_QWORD *)v11 = &off_1E8169028;
    *(_DWORD *)(v11 + 8) = 5;
    *(_BYTE *)(a4 + 8) |= 1u;
    *(_QWORD *)a4 = v11;
    return;
  }
  (*(void (**)(char ***__return_ptr, uint64_t, unsigned int *, unsigned int *, unint64_t, uint64_t, char *, unint64_t))(*(_QWORD *)a1 + 24))(&v20, a1, v5, v9, (-1431655765 * ((v15 - v16) >> 3)) | ((unint64_t)(-1431655765* ((*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8)- **(_QWORD **)(a1 + 56)) >> 3)- -1431655765* ((v15 - v16) >> 3)) << 32), 1, v10, v19);
  v17 = v20;
  if (v20)
  {
LABEL_5:
    v18 = *(_BYTE *)(a4 + 8) | 1;
  }
  else
  {
    v17 = (char **)((v19 + 7) & 0xFFFFFFFFFFFFFFF8);
    v18 = *(_BYTE *)(a4 + 8) & 0xFE;
  }
  *(_BYTE *)(a4 + 8) = v18;
  *(_QWORD *)a4 = v17;
}

void sub_1C547778C(uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, unint64_t a4@<X3>, char a5@<W4>, uint64_t a6@<X5>, unint64_t a7@<X6>, uint64_t *a8@<X8>)
{
  uint64_t *v8;
  unint64_t v9;
  unint64_t v11;
  uint64_t v12;
  BOOL v13;
  char v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t *v24;
  _QWORD *v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  _QWORD *v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  __n128 v39;
  char v40;
  uint64_t v41;
  char v42;
  _QWORD *v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  char *v47;
  char *v48;
  char *v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  unint64_t v65;
  uint64_t v66;
  unint64_t v68;
  char v69;
  uint64_t *v71;
  char v72;
  _OWORD v73[2];
  __int16 v74;
  uint64_t v75;
  char v76;
  uint64_t v77;
  char v78;
  uint64_t v79;

  v8 = a8;
  v79 = *MEMORY[0x1E0C80C00];
  if (a2 < a3)
  {
    v9 = a7;
    v11 = a2;
    v12 = a1;
    v63 = HIDWORD(a4);
    if (a5)
      v13 = HIDWORD(a4) == 0;
    else
      v13 = 1;
    v14 = v13;
    v66 = a1 + 8;
    v62 = a4;
    v65 = a3;
    v69 = v14;
    while (1)
    {
      v15 = bswap32(*(_DWORD *)(v11 + 8));
      if (a6 + v15 > v9)
      {
        v57 = operator new();
        *(_QWORD *)v57 = &off_1E8169028;
        *(_DWORD *)(v57 + 8) = 5;
        goto LABEL_63;
      }
      if ((v14 & 1) == 0)
        break;
LABEL_55:
      v11 += 20;
      a6 += v15;
      if (v11 >= a3)
        goto LABEL_61;
    }
    v16 = *(_QWORD *)(v11 + 12);
    v17 = (uint64_t)(*(_QWORD *)(*(_QWORD *)(v12 + 64) + 8) - **(_QWORD **)(v12 + 64)) >> 6;
    *(_QWORD *)&v73[0] = bswap64(*(_QWORD *)v11);
    *((_QWORD *)&v73[0] + 1) = v17;
    sub_1C546C7AC(&v71, v66, (uint64_t *)v73, (uint64_t *)v73 + 1);
    v68 = bswap64(v16);
    if (v72)
    {
      v18 = *(uint64_t **)(v12 + 32);
      v19 = bswap64(*(_QWORD *)v11);
      sub_1C546CB40(v18);
      v20 = (_QWORD *)v18[7];
      v21 = (_QWORD *)v18[8];
      if (v21 != v20)
      {
        v22 = 0xAAAAAAAAAAAAAAABLL * (v21 - v20);
        do
        {
          v23 = v22 >> 1;
          v24 = &v20[3 * (v22 >> 1)];
          v26 = *v24;
          v25 = v24 + 3;
          v22 += ~(v22 >> 1);
          if (v26 < v19)
            v20 = v25;
          else
            v22 = v23;
        }
        while (v22);
      }
      if (v20 != v21 && *v20 == v19 && (v27 = v20[2]) != 0)
      {
        v28 = v20[1];
        v29 = *(_QWORD *)(a1 + 64);
        v31 = *(_QWORD **)(v29 + 8);
        v30 = *(_QWORD *)(v29 + 16);
        if ((unint64_t)v31 >= v30)
        {
          v43 = *(_QWORD **)v29;
          v44 = ((uint64_t)v31 - *(_QWORD *)v29) >> 6;
          v45 = v44 + 1;
          if ((unint64_t)(v44 + 1) >> 58)
            abort();
          v59 = v28;
          v61 = *(_QWORD *)(a1 + 64);
          v46 = v30 - (_QWORD)v43;
          if (v46 >> 5 > v45)
            v45 = v46 >> 5;
          if ((unint64_t)v46 >= 0x7FFFFFFFFFFFFFC0)
            v45 = 0x3FFFFFFFFFFFFFFLL;
          if (v45 >> 58)
            sub_1C4764EE4();
          v58 = v45;
          v47 = (char *)operator new(v45 << 6);
          v48 = &v47[64 * v44];
          *(_DWORD *)v48 = 1;
          *((_QWORD *)v48 + 1) = v59;
          *((_QWORD *)v48 + 2) = v27;
          *((_QWORD *)v48 + 3) = v68;
          *((_QWORD *)v48 + 4) = a6;
          *((_QWORD *)v48 + 5) = v15;
          *((_QWORD *)v48 + 6) = v62;
          *((_QWORD *)v48 + 7) = v63;
          if (v31 == v43)
          {
            v53 = &v47[64 * v44];
            v9 = a7;
            v29 = v61;
          }
          else
          {
            v49 = &v47[64 * v44];
            v9 = a7;
            v29 = v61;
            do
            {
              v50 = *((_OWORD *)v31 - 4);
              v51 = *((_OWORD *)v31 - 3);
              v52 = *((_OWORD *)v31 - 1);
              v53 = v49 - 64;
              *((_OWORD *)v49 - 2) = *((_OWORD *)v31 - 2);
              *((_OWORD *)v49 - 1) = v52;
              *((_OWORD *)v49 - 4) = v50;
              *((_OWORD *)v49 - 3) = v51;
              v31 -= 8;
              v49 -= 64;
            }
            while (v31 != v43);
          }
          v32 = v48 + 64;
          *(_QWORD *)v29 = v53;
          *(_QWORD *)(v29 + 8) = v48 + 64;
          *(_QWORD *)(v29 + 16) = &v47[64 * v58];
          if (v43)
          {
            operator delete(v43);
            v29 = v61;
          }
        }
        else
        {
          *(_DWORD *)v31 = 1;
          v31[1] = v28;
          v31[2] = v27;
          v9 = a7;
          v31[3] = v68;
          v31[4] = a6;
          v31[5] = v15;
          v31[6] = v62;
          v32 = (char *)(v31 + 8);
          v31[7] = v63;
        }
        v8 = a8;
        v14 = v69;
        v33 = 0;
        *(_QWORD *)(v29 + 8) = v32;
      }
      else
      {
        v33 = operator new();
        *(_QWORD *)&v73[0] = "function name is empty";
        v74 = 259;
        *(_QWORD *)v33 = off_1E8192D50;
        *(_DWORD *)(v33 + 8) = 9;
        llvm::Twine::str((llvm::Twine *)v73, (_QWORD *)(v33 + 16));
        v9 = a7;
        v14 = v69;
      }
      *v8 = v33;
LABEL_54:
      a3 = v65;
      v12 = a1;
      if (v33)
        return;
      goto LABEL_55;
    }
    v34 = v71[1];
    v35 = **(_QWORD **)(v12 + 64);
    v36 = v35 + (v34 << 6);
    v38 = *(_QWORD *)(v36 + 24);
    v37 = v36 + 24;
    v39 = *(__n128 *)(v37 + 8);
    if (v38)
    {
      v40 = v78 & 0xFE;
      v78 &= ~1u;
      LOBYTE(v77) = 0;
    }
    else
    {
      v73[0] = *(_OWORD *)(v37 + 8);
      v60 = v34;
      v41 = v35;
      llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v73, (uint64_t)&v77);
      v35 = v41;
      v34 = v60;
      v40 = v78;
    }
    v14 = v69;
    if ((v40 & 1) != 0)
    {
      v33 = v77;
      v8 = a8;
      *a8 = v77;
    }
    else
    {
      if ((_BYTE)v77)
      {
        if (v16)
        {
          v76 &= ~1u;
          v42 = v76;
          LOBYTE(v75) = 0;
          if ((v76 & 1) == 0)
            goto LABEL_32;
        }
        else
        {
          *(_QWORD *)&v73[0] = a6;
          *((_QWORD *)&v73[0] + 1) = v15;
          v54 = v34;
          v55 = v35;
          llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v73, (uint64_t)&v75);
          v35 = v55;
          v34 = v54;
          v14 = v69;
          v42 = v76;
          if ((v76 & 1) == 0)
          {
LABEL_32:
            if ((_BYTE)v75)
            {
              v33 = 0;
              *a8 = 0;
LABEL_52:
              v8 = a8;
              goto LABEL_53;
            }
LABEL_48:
            v33 = 0;
            *(_QWORD *)v37 = v68;
            *(_QWORD *)(v37 + 8) = a6;
            *(_QWORD *)(v37 + 16) = v15;
            v56 = v35 + (v34 << 6);
            *(_QWORD *)(v56 + 48) = v62;
            *(_QWORD *)(v56 + 56) = v63;
            *a8 = 0;
            if ((v42 & 1) != 0)
            {
              if (v75)
              {
                (*(void (**)(uint64_t, __n128))(*(_QWORD *)v75 + 8))(v75, v39);
                v14 = v69;
              }
              v33 = 0;
            }
            goto LABEL_52;
          }
        }
        v33 = v75;
        v75 = 0;
        *a8 = v33;
        if (v33)
          goto LABEL_52;
        goto LABEL_48;
      }
      v33 = 0;
      v8 = a8;
      *a8 = 0;
    }
LABEL_53:
    v9 = a7;
    goto LABEL_54;
  }
LABEL_61:
  v57 = 0;
LABEL_63:
  *v8 = v57;
}

_QWORD *sub_1C5477C84(_QWORD *a1)
{
  *a1 = &off_1E81694A8;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  return a1;
}

void sub_1C5477CC8(_QWORD *a1)
{
  *a1 = &off_1E81694A8;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5477D1C(uint64_t a1@<X0>, unsigned int *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unsigned int *v5;
  unsigned int v7;
  char *v8;
  unsigned int *v9;
  char *v10;
  uint64_t v11;
  unsigned int v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char **v17;
  char v18;
  unint64_t v19;
  char **v20;
  char *v21[3];
  __int128 v22;

  v5 = a2 + 4;
  if ((unint64_t)(a2 + 4) > a3)
    goto LABEL_3;
  v7 = bswap32(*a2);
  v8 = (char *)bswap32(a2[1]);
  v9 = &v5[5 * v7];
  v10 = &v8[(_QWORD)v9];
  if (&v8[(_QWORD)v9] > (char *)a3)
    goto LABEL_3;
  v13 = a2[2];
  v14 = *(char **)(a1 + 56);
  v16 = *(_QWORD *)v14;
  v15 = *((_QWORD *)v14 + 1);
  v21[0] = (char *)&v5[5 * v7];
  v21[1] = v8;
  v21[2] = v14;
  v22 = *(_OWORD *)(a1 + 40);
  llvm::coverage::RawCoverageFilenamesReader::read(v21, 2, &v20);
  v17 = v20;
  if (v20)
    goto LABEL_5;
  v19 = (unint64_t)&v10[bswap32(v13)];
  if (v19 > a3)
  {
LABEL_3:
    v11 = operator new();
    *(_QWORD *)v11 = &off_1E8169028;
    *(_DWORD *)(v11 + 8) = 5;
    *(_BYTE *)(a4 + 8) |= 1u;
    *(_QWORD *)a4 = v11;
    return;
  }
  (*(void (**)(char ***__return_ptr, uint64_t, unsigned int *, unsigned int *, unint64_t, uint64_t, char *, unint64_t))(*(_QWORD *)a1 + 24))(&v20, a1, v5, v9, (-1431655765 * ((v15 - v16) >> 3)) | ((unint64_t)(-1431655765* ((*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8)- **(_QWORD **)(a1 + 56)) >> 3)- -1431655765* ((v15 - v16) >> 3)) << 32), 1, v10, v19);
  v17 = v20;
  if (v20)
  {
LABEL_5:
    v18 = *(_BYTE *)(a4 + 8) | 1;
  }
  else
  {
    v17 = (char **)((v19 + 7) & 0xFFFFFFFFFFFFFFF8);
    v18 = *(_BYTE *)(a4 + 8) & 0xFE;
  }
  *(_BYTE *)(a4 + 8) = v18;
  *(_QWORD *)a4 = v17;
}

void sub_1C5477EA8(uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, unint64_t a4@<X3>, char a5@<W4>, uint64_t a6@<X5>, unint64_t a7@<X6>, uint64_t *a8@<X8>)
{
  uint64_t *v8;
  unint64_t v9;
  unint64_t v11;
  uint64_t v12;
  BOOL v13;
  char v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t *v24;
  _QWORD *v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  _QWORD *v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  __n128 v39;
  char v40;
  uint64_t v41;
  char v42;
  _QWORD *v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  char *v47;
  char *v48;
  char *v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  unint64_t v65;
  uint64_t v66;
  unint64_t v68;
  char v69;
  uint64_t *v71;
  char v72;
  _OWORD v73[2];
  __int16 v74;
  uint64_t v75;
  char v76;
  uint64_t v77;
  char v78;
  uint64_t v79;

  v8 = a8;
  v79 = *MEMORY[0x1E0C80C00];
  if (a2 < a3)
  {
    v9 = a7;
    v11 = a2;
    v12 = a1;
    v63 = HIDWORD(a4);
    if (a5)
      v13 = HIDWORD(a4) == 0;
    else
      v13 = 1;
    v14 = v13;
    v66 = a1 + 8;
    v62 = a4;
    v65 = a3;
    v69 = v14;
    while (1)
    {
      v15 = bswap32(*(_DWORD *)(v11 + 8));
      if (a6 + v15 > v9)
      {
        v57 = operator new();
        *(_QWORD *)v57 = &off_1E8169028;
        *(_DWORD *)(v57 + 8) = 5;
        goto LABEL_63;
      }
      if ((v14 & 1) == 0)
        break;
LABEL_55:
      v11 += 20;
      a6 += v15;
      if (v11 >= a3)
        goto LABEL_61;
    }
    v16 = *(_QWORD *)(v11 + 12);
    v17 = (uint64_t)(*(_QWORD *)(*(_QWORD *)(v12 + 64) + 8) - **(_QWORD **)(v12 + 64)) >> 6;
    *(_QWORD *)&v73[0] = bswap64(*(_QWORD *)v11);
    *((_QWORD *)&v73[0] + 1) = v17;
    sub_1C546C7AC(&v71, v66, (uint64_t *)v73, (uint64_t *)v73 + 1);
    v68 = bswap64(v16);
    if (v72)
    {
      v18 = *(uint64_t **)(v12 + 32);
      v19 = bswap64(*(_QWORD *)v11);
      sub_1C546CB40(v18);
      v20 = (_QWORD *)v18[7];
      v21 = (_QWORD *)v18[8];
      if (v21 != v20)
      {
        v22 = 0xAAAAAAAAAAAAAAABLL * (v21 - v20);
        do
        {
          v23 = v22 >> 1;
          v24 = &v20[3 * (v22 >> 1)];
          v26 = *v24;
          v25 = v24 + 3;
          v22 += ~(v22 >> 1);
          if (v26 < v19)
            v20 = v25;
          else
            v22 = v23;
        }
        while (v22);
      }
      if (v20 != v21 && *v20 == v19 && (v27 = v20[2]) != 0)
      {
        v28 = v20[1];
        v29 = *(_QWORD *)(a1 + 64);
        v31 = *(_QWORD **)(v29 + 8);
        v30 = *(_QWORD *)(v29 + 16);
        if ((unint64_t)v31 >= v30)
        {
          v43 = *(_QWORD **)v29;
          v44 = ((uint64_t)v31 - *(_QWORD *)v29) >> 6;
          v45 = v44 + 1;
          if ((unint64_t)(v44 + 1) >> 58)
            abort();
          v59 = v28;
          v61 = *(_QWORD *)(a1 + 64);
          v46 = v30 - (_QWORD)v43;
          if (v46 >> 5 > v45)
            v45 = v46 >> 5;
          if ((unint64_t)v46 >= 0x7FFFFFFFFFFFFFC0)
            v45 = 0x3FFFFFFFFFFFFFFLL;
          if (v45 >> 58)
            sub_1C4764EE4();
          v58 = v45;
          v47 = (char *)operator new(v45 << 6);
          v48 = &v47[64 * v44];
          *(_DWORD *)v48 = 2;
          *((_QWORD *)v48 + 1) = v59;
          *((_QWORD *)v48 + 2) = v27;
          *((_QWORD *)v48 + 3) = v68;
          *((_QWORD *)v48 + 4) = a6;
          *((_QWORD *)v48 + 5) = v15;
          *((_QWORD *)v48 + 6) = v62;
          *((_QWORD *)v48 + 7) = v63;
          if (v31 == v43)
          {
            v53 = &v47[64 * v44];
            v9 = a7;
            v29 = v61;
          }
          else
          {
            v49 = &v47[64 * v44];
            v9 = a7;
            v29 = v61;
            do
            {
              v50 = *((_OWORD *)v31 - 4);
              v51 = *((_OWORD *)v31 - 3);
              v52 = *((_OWORD *)v31 - 1);
              v53 = v49 - 64;
              *((_OWORD *)v49 - 2) = *((_OWORD *)v31 - 2);
              *((_OWORD *)v49 - 1) = v52;
              *((_OWORD *)v49 - 4) = v50;
              *((_OWORD *)v49 - 3) = v51;
              v31 -= 8;
              v49 -= 64;
            }
            while (v31 != v43);
          }
          v32 = v48 + 64;
          *(_QWORD *)v29 = v53;
          *(_QWORD *)(v29 + 8) = v48 + 64;
          *(_QWORD *)(v29 + 16) = &v47[64 * v58];
          if (v43)
          {
            operator delete(v43);
            v29 = v61;
          }
        }
        else
        {
          *(_DWORD *)v31 = 2;
          v31[1] = v28;
          v31[2] = v27;
          v9 = a7;
          v31[3] = v68;
          v31[4] = a6;
          v31[5] = v15;
          v31[6] = v62;
          v32 = (char *)(v31 + 8);
          v31[7] = v63;
        }
        v8 = a8;
        v14 = v69;
        v33 = 0;
        *(_QWORD *)(v29 + 8) = v32;
      }
      else
      {
        v33 = operator new();
        *(_QWORD *)&v73[0] = "function name is empty";
        v74 = 259;
        *(_QWORD *)v33 = off_1E8192D50;
        *(_DWORD *)(v33 + 8) = 9;
        llvm::Twine::str((llvm::Twine *)v73, (_QWORD *)(v33 + 16));
        v9 = a7;
        v14 = v69;
      }
      *v8 = v33;
LABEL_54:
      a3 = v65;
      v12 = a1;
      if (v33)
        return;
      goto LABEL_55;
    }
    v34 = v71[1];
    v35 = **(_QWORD **)(v12 + 64);
    v36 = v35 + (v34 << 6);
    v38 = *(_QWORD *)(v36 + 24);
    v37 = v36 + 24;
    v39 = *(__n128 *)(v37 + 8);
    if (v38)
    {
      v40 = v78 & 0xFE;
      v78 &= ~1u;
      LOBYTE(v77) = 0;
    }
    else
    {
      v73[0] = *(_OWORD *)(v37 + 8);
      v60 = v34;
      v41 = v35;
      llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v73, (uint64_t)&v77);
      v35 = v41;
      v34 = v60;
      v40 = v78;
    }
    v14 = v69;
    if ((v40 & 1) != 0)
    {
      v33 = v77;
      v8 = a8;
      *a8 = v77;
    }
    else
    {
      if ((_BYTE)v77)
      {
        if (v16)
        {
          v76 &= ~1u;
          v42 = v76;
          LOBYTE(v75) = 0;
          if ((v76 & 1) == 0)
            goto LABEL_32;
        }
        else
        {
          *(_QWORD *)&v73[0] = a6;
          *((_QWORD *)&v73[0] + 1) = v15;
          v54 = v34;
          v55 = v35;
          llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v73, (uint64_t)&v75);
          v35 = v55;
          v34 = v54;
          v14 = v69;
          v42 = v76;
          if ((v76 & 1) == 0)
          {
LABEL_32:
            if ((_BYTE)v75)
            {
              v33 = 0;
              *a8 = 0;
LABEL_52:
              v8 = a8;
              goto LABEL_53;
            }
LABEL_48:
            v33 = 0;
            *(_QWORD *)v37 = v68;
            *(_QWORD *)(v37 + 8) = a6;
            *(_QWORD *)(v37 + 16) = v15;
            v56 = v35 + (v34 << 6);
            *(_QWORD *)(v56 + 48) = v62;
            *(_QWORD *)(v56 + 56) = v63;
            *a8 = 0;
            if ((v42 & 1) != 0)
            {
              if (v75)
              {
                (*(void (**)(uint64_t, __n128))(*(_QWORD *)v75 + 8))(v75, v39);
                v14 = v69;
              }
              v33 = 0;
            }
            goto LABEL_52;
          }
        }
        v33 = v75;
        v75 = 0;
        *a8 = v33;
        if (v33)
          goto LABEL_52;
        goto LABEL_48;
      }
      v33 = 0;
      v8 = a8;
      *a8 = 0;
    }
LABEL_53:
    v9 = a7;
    goto LABEL_54;
  }
LABEL_61:
  v57 = 0;
LABEL_63:
  *v8 = v57;
}

_QWORD *sub_1C54783A0(_QWORD *a1)
{
  *a1 = &off_1E81694D8;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  return a1;
}

void sub_1C54783E4(_QWORD *a1)
{
  *a1 = &off_1E81694D8;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5478438(uint64_t a1@<X0>, unsigned int *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  size_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  unsigned int v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned __int8 **v24;
  unsigned __int8 **v25;
  char v26;
  uint64_t v27;
  unsigned __int8 *v28;
  char v29;
  int v30;
  unsigned __int8 *v31;
  unsigned __int8 *v32;
  uint64_t v33;
  char *v34[3];
  __int128 v35;
  uint64_t v36;
  unint64_t v37;
  __int128 v38;
  uint64_t v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  if ((unint64_t)(a2 + 4) > a3)
    goto LABEL_3;
  v5 = bswap32(a2[1]);
  v6 = (char *)a2 + 29 * bswap32(*a2) + 16;
  v7 = &v6[v5];
  if ((unint64_t)&v6[v5] > a3)
    goto LABEL_3;
  v10 = a2[2];
  v11 = *(char **)(a1 + 56);
  v13 = *(_QWORD *)v11;
  v12 = *((_QWORD *)v11 + 1);
  v34[0] = v6;
  v34[1] = (char *)v5;
  v34[2] = v11;
  v35 = *(_OWORD *)(a1 + 40);
  llvm::coverage::RawCoverageFilenamesReader::read(v34, 3, (char ***)&v38);
  v14 = v38;
  if ((_QWORD)v38)
  {
    v15 = *(_BYTE *)(a4 + 8) | 1;
LABEL_7:
    *(_BYTE *)(a4 + 8) = v15;
    *(_QWORD *)a4 = v14;
    return;
  }
  v16 = 0xAAAAAAAAAAAAAAABLL * ((v12 - v13) >> 3);
  v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) - **(_QWORD **)(a1 + 56)) >> 3) - v16;
  v38 = xmmword_1C85F4BB0;
  v39 = 0;
  llvm::MD5::update((int *)&v38, (int *)v6, v5);
  llvm::MD5::final((int *)&v38, (int *)&v36);
  v37 = v16 | ((unint64_t)v17 << 32);
  sub_1C54701B8((uint64_t **)&v38, a1 + 72, &v36, (uint64_t *)&v37);
  if (!(_BYTE)v39)
  {
    v18 = v38;
    v19 = *(unsigned int *)(v38 + 12);
    if (v17 != v19)
      goto LABEL_31;
    v20 = v16;
    v21 = **(_QWORD **)(a1 + 56);
    v22 = v21 + 24 * *(unsigned int *)(v38 + 8);
    v23 = v22 + 24 * v19;
    v24 = (unsigned __int8 **)(v21 + 24 * v20);
    v25 = &v24[3 * v17];
    if ((_DWORD)v19)
    {
      do
      {
        v26 = *(_BYTE *)(v22 + 23);
        v27 = v26 & 0x7F;
        if (v26 >= 0)
          v28 = (unsigned __int8 *)(v26 & 0x7F);
        else
          v28 = *(unsigned __int8 **)(v22 + 8);
        v29 = *((_BYTE *)v24 + 23);
        v30 = v29;
        v31 = (unsigned __int8 *)(v29 & 0x7F);
        if (v30 < 0)
          v31 = v24[1];
        if (v28 != v31)
          goto LABEL_31;
        if (v30 >= 0)
          v32 = (unsigned __int8 *)v24;
        else
          v32 = *v24;
        if ((*(_BYTE *)(v22 + 23) & 0x80) != 0)
        {
          if (memcmp(*(const void **)v22, v32, *(_QWORD *)(v22 + 8)))
            goto LABEL_31;
        }
        else if ((v26 & 0x7F) != 0)
        {
          v33 = 0;
          while (*(unsigned __int8 *)(v22 + v33) == v32[v33])
          {
            if (v27 == ++v33)
              goto LABEL_27;
          }
          goto LABEL_31;
        }
LABEL_27:
        v22 += 24;
        v24 += 3;
      }
      while (v22 != v23 && v24 != v25);
    }
    if (v22 != v23 || v24 != v25)
LABEL_31:
      *(_DWORD *)(v18 + 12) = 0;
  }
  if (!v10)
  {
    v14 = (unint64_t)(v7 + 7) & 0xFFFFFFFFFFFFFFF8;
    v15 = *(_BYTE *)(a4 + 8) & 0xFE;
    goto LABEL_7;
  }
LABEL_3:
  v8 = operator new();
  *(_QWORD *)v8 = &off_1E8169028;
  *(_DWORD *)(v8 + 8) = 5;
  *(_BYTE *)(a4 + 8) |= 1u;
  *(_QWORD *)a4 = v8;
}

void sub_1C54786E4(uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  unint64_t v4;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  unint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  _QWORD *v30;
  char *v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t *v39;
  __n128 v40;
  char v41;
  uint64_t *v42;
  _QWORD *v43;
  unint64_t v44;
  uint64_t v45;
  char *v46;
  char *v47;
  char *v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  char *v52;
  uint64_t v53;
  unint64_t *v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  unint64_t v67;
  uint64_t *v69;
  char v70;
  _OWORD v71[2];
  __int16 v72;
  uint64_t v73;
  char v74;
  uint64_t v75;
  char v76;
  uint64_t v77;

  v77 = *MEMORY[0x1E0C80C00];
  if (a2 < a3)
  {
    v4 = a2;
    v65 = a1 + 8;
    while (1)
    {
      v6 = *(_DWORD *)(v4 + 8);
      v7 = *(_QWORD *)(a1 + 72);
      v8 = *(unsigned int *)(a1 + 88);
      v9 = sub_1C5470560(v7, *(_DWORD *)(a1 + 88), bswap64(*(_QWORD *)(v4 + 20)));
      if ((uint64_t *)(v7 + 16 * v8) == v9)
      {
LABEL_57:
        v56 = operator new();
        *(_QWORD *)v56 = &off_1E8169028;
        *(_DWORD *)(v56 + 8) = 5;
        goto LABEL_58;
      }
      v10 = v4 + 28;
      v11 = bswap32(v6);
      v12 = v4 + 28 + v11;
      v13 = v9[1];
      v14 = HIDWORD(v13);
      if (HIDWORD(v13))
        break;
LABEL_29:
      v4 = (v12 + 7) & 0xFFFFFFFFFFFFFFF8;
      if (v4 >= a3)
        goto LABEL_56;
    }
    if (v12 > a3)
      goto LABEL_57;
    v67 = v4 + 28 + v11;
    v15 = *(_QWORD *)(v4 + 12);
    v64 = bswap64(v15);
    v16 = (uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) - **(_QWORD **)(a1 + 64)) >> 6;
    *(_QWORD *)&v71[0] = bswap64(*(_QWORD *)v4);
    *((_QWORD *)&v71[0] + 1) = v16;
    sub_1C546C7AC(&v69, v65, (uint64_t *)v71, (uint64_t *)v71 + 1);
    if (v70)
    {
      v17 = *(uint64_t **)(a1 + 32);
      v18 = bswap64(*(_QWORD *)v4);
      sub_1C546CB40(v17);
      v19 = (_QWORD *)v17[7];
      v20 = (_QWORD *)v17[8];
      if (v20 != v19)
      {
        v21 = 0xAAAAAAAAAAAAAAABLL * (v20 - v19);
        do
        {
          v22 = v21 >> 1;
          v23 = &v19[3 * (v21 >> 1)];
          v25 = *v23;
          v24 = v23 + 3;
          v21 += ~(v21 >> 1);
          if (v25 < v18)
            v19 = v24;
          else
            v21 = v22;
        }
        while (v21);
      }
      if (v19 != v20 && *v19 == v18 && (v26 = v19[2]) != 0)
      {
        v27 = v19[1];
        v28 = *(_QWORD *)(a1 + 64);
        v30 = *(_QWORD **)(v28 + 8);
        v29 = *(_QWORD *)(v28 + 16);
        if ((unint64_t)v30 >= v29)
        {
          v43 = *(_QWORD **)v28;
          v44 = (((uint64_t)v30 - *(_QWORD *)v28) >> 6) + 1;
          if (v44 >> 58)
            abort();
          v58 = ((uint64_t)v30 - *(_QWORD *)v28) >> 6;
          v60 = v27;
          v62 = *(_QWORD *)(a1 + 64);
          v45 = v29 - (_QWORD)v43;
          if (v45 >> 5 > v44)
            v44 = v45 >> 5;
          if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFC0)
            v44 = 0x3FFFFFFFFFFFFFFLL;
          if (v44 >> 58)
            sub_1C4764EE4();
          v57 = v44;
          v46 = (char *)operator new(v44 << 6);
          v47 = &v46[64 * v58];
          *(_DWORD *)v47 = 3;
          *((_QWORD *)v47 + 1) = v60;
          *((_QWORD *)v47 + 2) = v26;
          *((_QWORD *)v47 + 3) = v64;
          *((_QWORD *)v47 + 4) = v10;
          *((_QWORD *)v47 + 5) = v11;
          *((_QWORD *)v47 + 6) = v13;
          *((_QWORD *)v47 + 7) = v14;
          if (v30 == v43)
          {
            v52 = &v46[64 * v58];
            v12 = v67;
            v28 = v62;
          }
          else
          {
            v48 = &v46[64 * v58];
            v12 = v67;
            v28 = v62;
            do
            {
              v49 = *((_OWORD *)v30 - 4);
              v50 = *((_OWORD *)v30 - 3);
              v51 = *((_OWORD *)v30 - 1);
              v52 = v48 - 64;
              *((_OWORD *)v48 - 2) = *((_OWORD *)v30 - 2);
              *((_OWORD *)v48 - 1) = v51;
              *((_OWORD *)v48 - 4) = v49;
              *((_OWORD *)v48 - 3) = v50;
              v30 -= 8;
              v48 -= 64;
            }
            while (v30 != v43);
          }
          v31 = v47 + 64;
          *(_QWORD *)v28 = v52;
          *(_QWORD *)(v28 + 8) = v47 + 64;
          *(_QWORD *)(v28 + 16) = &v46[64 * v57];
          if (v43)
          {
            operator delete(v43);
            v28 = v62;
          }
        }
        else
        {
          *(_DWORD *)v30 = 3;
          v30[1] = v27;
          v30[2] = v26;
          v30[3] = v64;
          v30[4] = v10;
          v30[5] = v11;
          v30[6] = v13;
          v31 = (char *)(v30 + 8);
          v30[7] = v14;
          v12 = v67;
        }
        v32 = 0;
        *(_QWORD *)(v28 + 8) = v31;
      }
      else
      {
        v32 = operator new();
        *(_QWORD *)&v71[0] = "function name is empty";
        v72 = 259;
        *(_QWORD *)v32 = off_1E8192D50;
        *(_DWORD *)(v32 + 8) = 9;
        llvm::Twine::str((llvm::Twine *)v71, (_QWORD *)(v32 + 16));
        v12 = v67;
      }
      v33 = a4;
      goto LABEL_27;
    }
    v34 = v69[1];
    v35 = **(_QWORD **)(a1 + 64);
    v36 = v35 + (v34 << 6);
    v38 = *(_QWORD *)(v36 + 24);
    v37 = v36 + 24;
    v39 = (unint64_t *)(v37 + 8);
    v40 = *(__n128 *)(v37 + 8);
    if (v38)
    {
      v76 &= ~1u;
      LOBYTE(v75) = 0;
      if ((v76 & 1) == 0)
        goto LABEL_22;
    }
    else
    {
      v71[0] = *(_OWORD *)(v37 + 8);
      v59 = v35;
      v61 = v34;
      llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v71, (uint64_t)&v75);
      v35 = v59;
      v34 = v61;
      v39 = (unint64_t *)(v37 + 8);
      if ((v76 & 1) == 0)
      {
LABEL_22:
        if (!(_BYTE)v75)
        {
          v32 = 0;
          v42 = a4;
          v12 = v67;
LABEL_46:
          *v42 = 0;
          goto LABEL_28;
        }
        if (v15)
        {
          v41 = v74 & 0xFE;
          v74 &= ~1u;
          LOBYTE(v73) = 0;
        }
        else
        {
          *(_QWORD *)&v71[0] = v4 + 28;
          *((_QWORD *)&v71[0] + 1) = v11;
          v53 = v35;
          v54 = v39;
          v63 = v34;
          llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v71, (uint64_t)&v73);
          v34 = v63;
          v39 = v54;
          v35 = v53;
          v41 = v74;
        }
        v12 = v67;
        if ((v41 & 1) != 0)
        {
          v32 = v73;
          v73 = 0;
          *a4 = v32;
          if (v32)
            goto LABEL_28;
        }
        else if ((_BYTE)v73)
        {
          v32 = 0;
          v42 = a4;
          goto LABEL_46;
        }
        v32 = 0;
        *(_QWORD *)v37 = v64;
        *v39 = v10;
        v39[1] = v11;
        v55 = v35 + (v34 << 6);
        *(_QWORD *)(v55 + 48) = v13;
        *(_QWORD *)(v55 + 56) = v14;
        *a4 = 0;
        if ((v41 & 1) != 0)
        {
          if (v73)
            (*(void (**)(uint64_t, __n128))(*(_QWORD *)v73 + 8))(v73, v40);
          v32 = 0;
        }
LABEL_28:
        if (v32)
          return;
        goto LABEL_29;
      }
    }
    v32 = v75;
    v33 = a4;
    v12 = v67;
LABEL_27:
    *v33 = v32;
    goto LABEL_28;
  }
LABEL_56:
  v56 = 0;
LABEL_58:
  *a4 = v56;
}

_QWORD *sub_1C5478BC4(_QWORD *a1)
{
  *a1 = &off_1E8169508;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  return a1;
}

void sub_1C5478C08(_QWORD *a1)
{
  *a1 = &off_1E8169508;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5478C5C(uint64_t a1@<X0>, unsigned int *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  size_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  unsigned int v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned __int8 **v24;
  unsigned __int8 **v25;
  char v26;
  uint64_t v27;
  unsigned __int8 *v28;
  char v29;
  int v30;
  unsigned __int8 *v31;
  unsigned __int8 *v32;
  uint64_t v33;
  char *v34[3];
  __int128 v35;
  uint64_t v36;
  unint64_t v37;
  __int128 v38;
  uint64_t v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  if ((unint64_t)(a2 + 4) > a3)
    goto LABEL_3;
  v5 = bswap32(a2[1]);
  v6 = (char *)a2 + 29 * bswap32(*a2) + 16;
  v7 = &v6[v5];
  if ((unint64_t)&v6[v5] > a3)
    goto LABEL_3;
  v10 = a2[2];
  v11 = *(char **)(a1 + 56);
  v13 = *(_QWORD *)v11;
  v12 = *((_QWORD *)v11 + 1);
  v34[0] = v6;
  v34[1] = (char *)v5;
  v34[2] = v11;
  v35 = *(_OWORD *)(a1 + 40);
  llvm::coverage::RawCoverageFilenamesReader::read(v34, 4, (char ***)&v38);
  v14 = v38;
  if ((_QWORD)v38)
  {
    v15 = *(_BYTE *)(a4 + 8) | 1;
LABEL_7:
    *(_BYTE *)(a4 + 8) = v15;
    *(_QWORD *)a4 = v14;
    return;
  }
  v16 = 0xAAAAAAAAAAAAAAABLL * ((v12 - v13) >> 3);
  v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) - **(_QWORD **)(a1 + 56)) >> 3) - v16;
  v38 = xmmword_1C85F4BB0;
  v39 = 0;
  llvm::MD5::update((int *)&v38, (int *)v6, v5);
  llvm::MD5::final((int *)&v38, (int *)&v36);
  v37 = v16 | ((unint64_t)v17 << 32);
  sub_1C54701B8((uint64_t **)&v38, a1 + 72, &v36, (uint64_t *)&v37);
  if (!(_BYTE)v39)
  {
    v18 = v38;
    v19 = *(unsigned int *)(v38 + 12);
    if (v17 != v19)
      goto LABEL_31;
    v20 = v16;
    v21 = **(_QWORD **)(a1 + 56);
    v22 = v21 + 24 * *(unsigned int *)(v38 + 8);
    v23 = v22 + 24 * v19;
    v24 = (unsigned __int8 **)(v21 + 24 * v20);
    v25 = &v24[3 * v17];
    if ((_DWORD)v19)
    {
      do
      {
        v26 = *(_BYTE *)(v22 + 23);
        v27 = v26 & 0x7F;
        if (v26 >= 0)
          v28 = (unsigned __int8 *)(v26 & 0x7F);
        else
          v28 = *(unsigned __int8 **)(v22 + 8);
        v29 = *((_BYTE *)v24 + 23);
        v30 = v29;
        v31 = (unsigned __int8 *)(v29 & 0x7F);
        if (v30 < 0)
          v31 = v24[1];
        if (v28 != v31)
          goto LABEL_31;
        if (v30 >= 0)
          v32 = (unsigned __int8 *)v24;
        else
          v32 = *v24;
        if ((*(_BYTE *)(v22 + 23) & 0x80) != 0)
        {
          if (memcmp(*(const void **)v22, v32, *(_QWORD *)(v22 + 8)))
            goto LABEL_31;
        }
        else if ((v26 & 0x7F) != 0)
        {
          v33 = 0;
          while (*(unsigned __int8 *)(v22 + v33) == v32[v33])
          {
            if (v27 == ++v33)
              goto LABEL_27;
          }
          goto LABEL_31;
        }
LABEL_27:
        v22 += 24;
        v24 += 3;
      }
      while (v22 != v23 && v24 != v25);
    }
    if (v22 != v23 || v24 != v25)
LABEL_31:
      *(_DWORD *)(v18 + 12) = 0;
  }
  if (!v10)
  {
    v14 = (unint64_t)(v7 + 7) & 0xFFFFFFFFFFFFFFF8;
    v15 = *(_BYTE *)(a4 + 8) & 0xFE;
    goto LABEL_7;
  }
LABEL_3:
  v8 = operator new();
  *(_QWORD *)v8 = &off_1E8169028;
  *(_DWORD *)(v8 + 8) = 5;
  *(_BYTE *)(a4 + 8) |= 1u;
  *(_QWORD *)a4 = v8;
}

void sub_1C5478F08(uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  unint64_t v4;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  unint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  _QWORD *v30;
  char *v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t *v39;
  __n128 v40;
  char v41;
  uint64_t *v42;
  _QWORD *v43;
  unint64_t v44;
  uint64_t v45;
  char *v46;
  char *v47;
  char *v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  char *v52;
  uint64_t v53;
  unint64_t *v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  unint64_t v67;
  uint64_t *v69;
  char v70;
  _OWORD v71[2];
  __int16 v72;
  uint64_t v73;
  char v74;
  uint64_t v75;
  char v76;
  uint64_t v77;

  v77 = *MEMORY[0x1E0C80C00];
  if (a2 < a3)
  {
    v4 = a2;
    v65 = a1 + 8;
    while (1)
    {
      v6 = *(_DWORD *)(v4 + 8);
      v7 = *(_QWORD *)(a1 + 72);
      v8 = *(unsigned int *)(a1 + 88);
      v9 = sub_1C5470560(v7, *(_DWORD *)(a1 + 88), bswap64(*(_QWORD *)(v4 + 20)));
      if ((uint64_t *)(v7 + 16 * v8) == v9)
      {
LABEL_57:
        v56 = operator new();
        *(_QWORD *)v56 = &off_1E8169028;
        *(_DWORD *)(v56 + 8) = 5;
        goto LABEL_58;
      }
      v10 = v4 + 28;
      v11 = bswap32(v6);
      v12 = v4 + 28 + v11;
      v13 = v9[1];
      v14 = HIDWORD(v13);
      if (HIDWORD(v13))
        break;
LABEL_29:
      v4 = (v12 + 7) & 0xFFFFFFFFFFFFFFF8;
      if (v4 >= a3)
        goto LABEL_56;
    }
    if (v12 > a3)
      goto LABEL_57;
    v67 = v4 + 28 + v11;
    v15 = *(_QWORD *)(v4 + 12);
    v64 = bswap64(v15);
    v16 = (uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) - **(_QWORD **)(a1 + 64)) >> 6;
    *(_QWORD *)&v71[0] = bswap64(*(_QWORD *)v4);
    *((_QWORD *)&v71[0] + 1) = v16;
    sub_1C546C7AC(&v69, v65, (uint64_t *)v71, (uint64_t *)v71 + 1);
    if (v70)
    {
      v17 = *(uint64_t **)(a1 + 32);
      v18 = bswap64(*(_QWORD *)v4);
      sub_1C546CB40(v17);
      v19 = (_QWORD *)v17[7];
      v20 = (_QWORD *)v17[8];
      if (v20 != v19)
      {
        v21 = 0xAAAAAAAAAAAAAAABLL * (v20 - v19);
        do
        {
          v22 = v21 >> 1;
          v23 = &v19[3 * (v21 >> 1)];
          v25 = *v23;
          v24 = v23 + 3;
          v21 += ~(v21 >> 1);
          if (v25 < v18)
            v19 = v24;
          else
            v21 = v22;
        }
        while (v21);
      }
      if (v19 != v20 && *v19 == v18 && (v26 = v19[2]) != 0)
      {
        v27 = v19[1];
        v28 = *(_QWORD *)(a1 + 64);
        v30 = *(_QWORD **)(v28 + 8);
        v29 = *(_QWORD *)(v28 + 16);
        if ((unint64_t)v30 >= v29)
        {
          v43 = *(_QWORD **)v28;
          v44 = (((uint64_t)v30 - *(_QWORD *)v28) >> 6) + 1;
          if (v44 >> 58)
            abort();
          v58 = ((uint64_t)v30 - *(_QWORD *)v28) >> 6;
          v60 = v27;
          v62 = *(_QWORD *)(a1 + 64);
          v45 = v29 - (_QWORD)v43;
          if (v45 >> 5 > v44)
            v44 = v45 >> 5;
          if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFC0)
            v44 = 0x3FFFFFFFFFFFFFFLL;
          if (v44 >> 58)
            sub_1C4764EE4();
          v57 = v44;
          v46 = (char *)operator new(v44 << 6);
          v47 = &v46[64 * v58];
          *(_DWORD *)v47 = 4;
          *((_QWORD *)v47 + 1) = v60;
          *((_QWORD *)v47 + 2) = v26;
          *((_QWORD *)v47 + 3) = v64;
          *((_QWORD *)v47 + 4) = v10;
          *((_QWORD *)v47 + 5) = v11;
          *((_QWORD *)v47 + 6) = v13;
          *((_QWORD *)v47 + 7) = v14;
          if (v30 == v43)
          {
            v52 = &v46[64 * v58];
            v12 = v67;
            v28 = v62;
          }
          else
          {
            v48 = &v46[64 * v58];
            v12 = v67;
            v28 = v62;
            do
            {
              v49 = *((_OWORD *)v30 - 4);
              v50 = *((_OWORD *)v30 - 3);
              v51 = *((_OWORD *)v30 - 1);
              v52 = v48 - 64;
              *((_OWORD *)v48 - 2) = *((_OWORD *)v30 - 2);
              *((_OWORD *)v48 - 1) = v51;
              *((_OWORD *)v48 - 4) = v49;
              *((_OWORD *)v48 - 3) = v50;
              v30 -= 8;
              v48 -= 64;
            }
            while (v30 != v43);
          }
          v31 = v47 + 64;
          *(_QWORD *)v28 = v52;
          *(_QWORD *)(v28 + 8) = v47 + 64;
          *(_QWORD *)(v28 + 16) = &v46[64 * v57];
          if (v43)
          {
            operator delete(v43);
            v28 = v62;
          }
        }
        else
        {
          *(_DWORD *)v30 = 4;
          v30[1] = v27;
          v30[2] = v26;
          v30[3] = v64;
          v30[4] = v10;
          v30[5] = v11;
          v30[6] = v13;
          v31 = (char *)(v30 + 8);
          v30[7] = v14;
          v12 = v67;
        }
        v32 = 0;
        *(_QWORD *)(v28 + 8) = v31;
      }
      else
      {
        v32 = operator new();
        *(_QWORD *)&v71[0] = "function name is empty";
        v72 = 259;
        *(_QWORD *)v32 = off_1E8192D50;
        *(_DWORD *)(v32 + 8) = 9;
        llvm::Twine::str((llvm::Twine *)v71, (_QWORD *)(v32 + 16));
        v12 = v67;
      }
      v33 = a4;
      goto LABEL_27;
    }
    v34 = v69[1];
    v35 = **(_QWORD **)(a1 + 64);
    v36 = v35 + (v34 << 6);
    v38 = *(_QWORD *)(v36 + 24);
    v37 = v36 + 24;
    v39 = (unint64_t *)(v37 + 8);
    v40 = *(__n128 *)(v37 + 8);
    if (v38)
    {
      v76 &= ~1u;
      LOBYTE(v75) = 0;
      if ((v76 & 1) == 0)
        goto LABEL_22;
    }
    else
    {
      v71[0] = *(_OWORD *)(v37 + 8);
      v59 = v35;
      v61 = v34;
      llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v71, (uint64_t)&v75);
      v35 = v59;
      v34 = v61;
      v39 = (unint64_t *)(v37 + 8);
      if ((v76 & 1) == 0)
      {
LABEL_22:
        if (!(_BYTE)v75)
        {
          v32 = 0;
          v42 = a4;
          v12 = v67;
LABEL_46:
          *v42 = 0;
          goto LABEL_28;
        }
        if (v15)
        {
          v41 = v74 & 0xFE;
          v74 &= ~1u;
          LOBYTE(v73) = 0;
        }
        else
        {
          *(_QWORD *)&v71[0] = v4 + 28;
          *((_QWORD *)&v71[0] + 1) = v11;
          v53 = v35;
          v54 = v39;
          v63 = v34;
          llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v71, (uint64_t)&v73);
          v34 = v63;
          v39 = v54;
          v35 = v53;
          v41 = v74;
        }
        v12 = v67;
        if ((v41 & 1) != 0)
        {
          v32 = v73;
          v73 = 0;
          *a4 = v32;
          if (v32)
            goto LABEL_28;
        }
        else if ((_BYTE)v73)
        {
          v32 = 0;
          v42 = a4;
          goto LABEL_46;
        }
        v32 = 0;
        *(_QWORD *)v37 = v64;
        *v39 = v10;
        v39[1] = v11;
        v55 = v35 + (v34 << 6);
        *(_QWORD *)(v55 + 48) = v13;
        *(_QWORD *)(v55 + 56) = v14;
        *a4 = 0;
        if ((v41 & 1) != 0)
        {
          if (v73)
            (*(void (**)(uint64_t, __n128))(*(_QWORD *)v73 + 8))(v73, v40);
          v32 = 0;
        }
LABEL_28:
        if (v32)
          return;
        goto LABEL_29;
      }
    }
    v32 = v75;
    v33 = a4;
    v12 = v67;
LABEL_27:
    *v33 = v32;
    goto LABEL_28;
  }
LABEL_56:
  v56 = 0;
LABEL_58:
  *a4 = v56;
}

_QWORD *sub_1C54793E8(_QWORD *a1)
{
  *a1 = &off_1E8169538;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  return a1;
}

void sub_1C547942C(_QWORD *a1)
{
  *a1 = &off_1E8169538;
  MEMORY[0x1CAA32FB4](a1[9], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5479480(uint64_t a1@<X0>, unsigned int *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  size_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  unsigned int v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned __int8 **v24;
  unsigned __int8 **v25;
  char v26;
  uint64_t v27;
  unsigned __int8 *v28;
  char v29;
  int v30;
  unsigned __int8 *v31;
  unsigned __int8 *v32;
  uint64_t v33;
  char *v34[3];
  __int128 v35;
  uint64_t v36;
  unint64_t v37;
  __int128 v38;
  uint64_t v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  if ((unint64_t)(a2 + 4) > a3)
    goto LABEL_3;
  v5 = bswap32(a2[1]);
  v6 = (char *)a2 + 29 * bswap32(*a2) + 16;
  v7 = &v6[v5];
  if ((unint64_t)&v6[v5] > a3)
    goto LABEL_3;
  v10 = a2[2];
  v11 = *(char **)(a1 + 56);
  v13 = *(_QWORD *)v11;
  v12 = *((_QWORD *)v11 + 1);
  v34[0] = v6;
  v34[1] = (char *)v5;
  v34[2] = v11;
  v35 = *(_OWORD *)(a1 + 40);
  llvm::coverage::RawCoverageFilenamesReader::read(v34, 5, (char ***)&v38);
  v14 = v38;
  if ((_QWORD)v38)
  {
    v15 = *(_BYTE *)(a4 + 8) | 1;
LABEL_7:
    *(_BYTE *)(a4 + 8) = v15;
    *(_QWORD *)a4 = v14;
    return;
  }
  v16 = 0xAAAAAAAAAAAAAAABLL * ((v12 - v13) >> 3);
  v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) - **(_QWORD **)(a1 + 56)) >> 3) - v16;
  v38 = xmmword_1C85F4BB0;
  v39 = 0;
  llvm::MD5::update((int *)&v38, (int *)v6, v5);
  llvm::MD5::final((int *)&v38, (int *)&v36);
  v37 = v16 | ((unint64_t)v17 << 32);
  sub_1C54701B8((uint64_t **)&v38, a1 + 72, &v36, (uint64_t *)&v37);
  if (!(_BYTE)v39)
  {
    v18 = v38;
    v19 = *(unsigned int *)(v38 + 12);
    if (v17 != v19)
      goto LABEL_31;
    v20 = v16;
    v21 = **(_QWORD **)(a1 + 56);
    v22 = v21 + 24 * *(unsigned int *)(v38 + 8);
    v23 = v22 + 24 * v19;
    v24 = (unsigned __int8 **)(v21 + 24 * v20);
    v25 = &v24[3 * v17];
    if ((_DWORD)v19)
    {
      do
      {
        v26 = *(_BYTE *)(v22 + 23);
        v27 = v26 & 0x7F;
        if (v26 >= 0)
          v28 = (unsigned __int8 *)(v26 & 0x7F);
        else
          v28 = *(unsigned __int8 **)(v22 + 8);
        v29 = *((_BYTE *)v24 + 23);
        v30 = v29;
        v31 = (unsigned __int8 *)(v29 & 0x7F);
        if (v30 < 0)
          v31 = v24[1];
        if (v28 != v31)
          goto LABEL_31;
        if (v30 >= 0)
          v32 = (unsigned __int8 *)v24;
        else
          v32 = *v24;
        if ((*(_BYTE *)(v22 + 23) & 0x80) != 0)
        {
          if (memcmp(*(const void **)v22, v32, *(_QWORD *)(v22 + 8)))
            goto LABEL_31;
        }
        else if ((v26 & 0x7F) != 0)
        {
          v33 = 0;
          while (*(unsigned __int8 *)(v22 + v33) == v32[v33])
          {
            if (v27 == ++v33)
              goto LABEL_27;
          }
          goto LABEL_31;
        }
LABEL_27:
        v22 += 24;
        v24 += 3;
      }
      while (v22 != v23 && v24 != v25);
    }
    if (v22 != v23 || v24 != v25)
LABEL_31:
      *(_DWORD *)(v18 + 12) = 0;
  }
  if (!v10)
  {
    v14 = (unint64_t)(v7 + 7) & 0xFFFFFFFFFFFFFFF8;
    v15 = *(_BYTE *)(a4 + 8) & 0xFE;
    goto LABEL_7;
  }
LABEL_3:
  v8 = operator new();
  *(_QWORD *)v8 = &off_1E8169028;
  *(_DWORD *)(v8 + 8) = 5;
  *(_BYTE *)(a4 + 8) |= 1u;
  *(_QWORD *)a4 = v8;
}

void sub_1C547972C(uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  unint64_t v4;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  unint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  _QWORD *v30;
  char *v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t *v39;
  __n128 v40;
  char v41;
  uint64_t *v42;
  _QWORD *v43;
  unint64_t v44;
  uint64_t v45;
  char *v46;
  char *v47;
  char *v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  char *v52;
  uint64_t v53;
  unint64_t *v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  unint64_t v67;
  uint64_t *v69;
  char v70;
  _OWORD v71[2];
  __int16 v72;
  uint64_t v73;
  char v74;
  uint64_t v75;
  char v76;
  uint64_t v77;

  v77 = *MEMORY[0x1E0C80C00];
  if (a2 < a3)
  {
    v4 = a2;
    v65 = a1 + 8;
    while (1)
    {
      v6 = *(_DWORD *)(v4 + 8);
      v7 = *(_QWORD *)(a1 + 72);
      v8 = *(unsigned int *)(a1 + 88);
      v9 = sub_1C5470560(v7, *(_DWORD *)(a1 + 88), bswap64(*(_QWORD *)(v4 + 20)));
      if ((uint64_t *)(v7 + 16 * v8) == v9)
      {
LABEL_57:
        v56 = operator new();
        *(_QWORD *)v56 = &off_1E8169028;
        *(_DWORD *)(v56 + 8) = 5;
        goto LABEL_58;
      }
      v10 = v4 + 28;
      v11 = bswap32(v6);
      v12 = v4 + 28 + v11;
      v13 = v9[1];
      v14 = HIDWORD(v13);
      if (HIDWORD(v13))
        break;
LABEL_29:
      v4 = (v12 + 7) & 0xFFFFFFFFFFFFFFF8;
      if (v4 >= a3)
        goto LABEL_56;
    }
    if (v12 > a3)
      goto LABEL_57;
    v67 = v4 + 28 + v11;
    v15 = *(_QWORD *)(v4 + 12);
    v64 = bswap64(v15);
    v16 = (uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) - **(_QWORD **)(a1 + 64)) >> 6;
    *(_QWORD *)&v71[0] = bswap64(*(_QWORD *)v4);
    *((_QWORD *)&v71[0] + 1) = v16;
    sub_1C546C7AC(&v69, v65, (uint64_t *)v71, (uint64_t *)v71 + 1);
    if (v70)
    {
      v17 = *(uint64_t **)(a1 + 32);
      v18 = bswap64(*(_QWORD *)v4);
      sub_1C546CB40(v17);
      v19 = (_QWORD *)v17[7];
      v20 = (_QWORD *)v17[8];
      if (v20 != v19)
      {
        v21 = 0xAAAAAAAAAAAAAAABLL * (v20 - v19);
        do
        {
          v22 = v21 >> 1;
          v23 = &v19[3 * (v21 >> 1)];
          v25 = *v23;
          v24 = v23 + 3;
          v21 += ~(v21 >> 1);
          if (v25 < v18)
            v19 = v24;
          else
            v21 = v22;
        }
        while (v21);
      }
      if (v19 != v20 && *v19 == v18 && (v26 = v19[2]) != 0)
      {
        v27 = v19[1];
        v28 = *(_QWORD *)(a1 + 64);
        v30 = *(_QWORD **)(v28 + 8);
        v29 = *(_QWORD *)(v28 + 16);
        if ((unint64_t)v30 >= v29)
        {
          v43 = *(_QWORD **)v28;
          v44 = (((uint64_t)v30 - *(_QWORD *)v28) >> 6) + 1;
          if (v44 >> 58)
            abort();
          v58 = ((uint64_t)v30 - *(_QWORD *)v28) >> 6;
          v60 = v27;
          v62 = *(_QWORD *)(a1 + 64);
          v45 = v29 - (_QWORD)v43;
          if (v45 >> 5 > v44)
            v44 = v45 >> 5;
          if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFC0)
            v44 = 0x3FFFFFFFFFFFFFFLL;
          if (v44 >> 58)
            sub_1C4764EE4();
          v57 = v44;
          v46 = (char *)operator new(v44 << 6);
          v47 = &v46[64 * v58];
          *(_DWORD *)v47 = 5;
          *((_QWORD *)v47 + 1) = v60;
          *((_QWORD *)v47 + 2) = v26;
          *((_QWORD *)v47 + 3) = v64;
          *((_QWORD *)v47 + 4) = v10;
          *((_QWORD *)v47 + 5) = v11;
          *((_QWORD *)v47 + 6) = v13;
          *((_QWORD *)v47 + 7) = v14;
          if (v30 == v43)
          {
            v52 = &v46[64 * v58];
            v12 = v67;
            v28 = v62;
          }
          else
          {
            v48 = &v46[64 * v58];
            v12 = v67;
            v28 = v62;
            do
            {
              v49 = *((_OWORD *)v30 - 4);
              v50 = *((_OWORD *)v30 - 3);
              v51 = *((_OWORD *)v30 - 1);
              v52 = v48 - 64;
              *((_OWORD *)v48 - 2) = *((_OWORD *)v30 - 2);
              *((_OWORD *)v48 - 1) = v51;
              *((_OWORD *)v48 - 4) = v49;
              *((_OWORD *)v48 - 3) = v50;
              v30 -= 8;
              v48 -= 64;
            }
            while (v30 != v43);
          }
          v31 = v47 + 64;
          *(_QWORD *)v28 = v52;
          *(_QWORD *)(v28 + 8) = v47 + 64;
          *(_QWORD *)(v28 + 16) = &v46[64 * v57];
          if (v43)
          {
            operator delete(v43);
            v28 = v62;
          }
        }
        else
        {
          *(_DWORD *)v30 = 5;
          v30[1] = v27;
          v30[2] = v26;
          v30[3] = v64;
          v30[4] = v10;
          v30[5] = v11;
          v30[6] = v13;
          v31 = (char *)(v30 + 8);
          v30[7] = v14;
          v12 = v67;
        }
        v32 = 0;
        *(_QWORD *)(v28 + 8) = v31;
      }
      else
      {
        v32 = operator new();
        *(_QWORD *)&v71[0] = "function name is empty";
        v72 = 259;
        *(_QWORD *)v32 = off_1E8192D50;
        *(_DWORD *)(v32 + 8) = 9;
        llvm::Twine::str((llvm::Twine *)v71, (_QWORD *)(v32 + 16));
        v12 = v67;
      }
      v33 = a4;
      goto LABEL_27;
    }
    v34 = v69[1];
    v35 = **(_QWORD **)(a1 + 64);
    v36 = v35 + (v34 << 6);
    v38 = *(_QWORD *)(v36 + 24);
    v37 = v36 + 24;
    v39 = (unint64_t *)(v37 + 8);
    v40 = *(__n128 *)(v37 + 8);
    if (v38)
    {
      v76 &= ~1u;
      LOBYTE(v75) = 0;
      if ((v76 & 1) == 0)
        goto LABEL_22;
    }
    else
    {
      v71[0] = *(_OWORD *)(v37 + 8);
      v59 = v35;
      v61 = v34;
      llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v71, (uint64_t)&v75);
      v35 = v59;
      v34 = v61;
      v39 = (unint64_t *)(v37 + 8);
      if ((v76 & 1) == 0)
      {
LABEL_22:
        if (!(_BYTE)v75)
        {
          v32 = 0;
          v42 = a4;
          v12 = v67;
LABEL_46:
          *v42 = 0;
          goto LABEL_28;
        }
        if (v15)
        {
          v41 = v74 & 0xFE;
          v74 &= ~1u;
          LOBYTE(v73) = 0;
        }
        else
        {
          *(_QWORD *)&v71[0] = v4 + 28;
          *((_QWORD *)&v71[0] + 1) = v11;
          v53 = v35;
          v54 = v39;
          v63 = v34;
          llvm::coverage::RawCoverageMappingDummyChecker::isDummy((char **)v71, (uint64_t)&v73);
          v34 = v63;
          v39 = v54;
          v35 = v53;
          v41 = v74;
        }
        v12 = v67;
        if ((v41 & 1) != 0)
        {
          v32 = v73;
          v73 = 0;
          *a4 = v32;
          if (v32)
            goto LABEL_28;
        }
        else if ((_BYTE)v73)
        {
          v32 = 0;
          v42 = a4;
          goto LABEL_46;
        }
        v32 = 0;
        *(_QWORD *)v37 = v64;
        *v39 = v10;
        v39[1] = v11;
        v55 = v35 + (v34 << 6);
        *(_QWORD *)(v55 + 48) = v13;
        *(_QWORD *)(v55 + 56) = v14;
        *a4 = 0;
        if ((v41 & 1) != 0)
        {
          if (v73)
            (*(void (**)(uint64_t, __n128))(*(_QWORD *)v73 + 8))(v73, v40);
          v32 = 0;
        }
LABEL_28:
        if (v32)
          return;
        goto LABEL_29;
      }
    }
    v32 = v75;
    v33 = a4;
    v12 = v67;
LABEL_27:
    *v33 = v32;
    goto LABEL_28;
  }
LABEL_56:
  v56 = 0;
LABEL_58:
  *a4 = v56;
}

uint64_t llvm::DWARFAbbreviationDeclaration::clear(uint64_t this)
{
  *(_DWORD *)(this + 16) = 0;
  *(_QWORD *)this = 0;
  if (*(_BYTE *)(this + 158))
    *(_BYTE *)(this + 158) = 0;
  return this;
}

double llvm::DWARFAbbreviationDeclaration::DWARFAbbreviationDeclaration(llvm::DWARFAbbreviationDeclaration *this)
{
  double result;

  *((_BYTE *)this + 152) = 0;
  *((_BYTE *)this + 158) = 0;
  *(_QWORD *)&result = 0x800000000;
  *((_QWORD *)this + 2) = 0x800000000;
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = (char *)this + 24;
  return result;
}

{
  double result;

  *((_BYTE *)this + 152) = 0;
  *((_BYTE *)this + 158) = 0;
  *(_QWORD *)&result = 0x800000000;
  *((_QWORD *)this + 2) = 0x800000000;
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = (char *)this + 24;
  return result;
}

uint64_t llvm::DWARFAbbreviationDeclaration::extract(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t result;
  __int16 ULEB128;
  uint64_t v9;
  int v10;
  BOOL v11;
  unsigned __int16 v12;
  int v13;
  int v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t SLEB128;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unsigned __int16 FixedFormByteSize;
  unint64_t *v22;
  unsigned __int16 v23;
  int v24;
  uint64_t v25;
  unint64_t v26;

  *(_DWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  if (*(_BYTE *)(a1 + 158))
    *(_BYTE *)(a1 + 158) = 0;
  v6 = *a3;
  result = llvm::DataExtractor::getULEB128(a2, a3, 0);
  *(_DWORD *)a1 = result;
  if ((_DWORD)result)
  {
    *(_BYTE *)(a1 + 6) = *(_BYTE *)a3 - v6;
    ULEB128 = llvm::DataExtractor::getULEB128(a2, a3, 0);
    *(_WORD *)(a1 + 4) = ULEB128;
    if (!ULEB128)
      goto LABEL_42;
    v9 = *a3;
    if (llvm::DataExtractor::prepareRead((uint64_t)a2, *a3, 1, 0))
    {
      v10 = *(unsigned __int8 *)(*a2 + v9);
      ++*a3;
      v11 = v10 == 1;
    }
    else
    {
      v11 = 0;
    }
    *(_BYTE *)(a1 + 7) = v11;
    if (!*(_BYTE *)(a1 + 158))
      *(_WORD *)(a1 + 157) = 256;
    *(_BYTE *)(a1 + 156) = 0;
    *(_DWORD *)(a1 + 152) = 0;
    v12 = llvm::DataExtractor::getULEB128(a2, a3, 0);
    v13 = llvm::DataExtractor::getULEB128(a2, a3, 0);
    v14 = v13;
    v15 = v12;
    if (v12 && (_WORD)v13)
    {
      v16 = 0;
      v25 = a1 + 24;
      while ((unsigned __int16)v14 == 33)
      {
        SLEB128 = llvm::DataExtractor::getSLEB128(a2, a3, 0);
        v18 = *(unsigned int *)(a1 + 16);
        if (v18 >= *(unsigned int *)(a1 + 20))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 8, v25, v18 + 1, 16);
          v18 = *(unsigned int *)(a1 + 16);
        }
        v19 = (v14 << 16) | v15;
LABEL_34:
        v22 = (unint64_t *)(*(_QWORD *)(a1 + 8) + 16 * v18);
        *v22 = v19;
        v22[1] = SLEB128;
        ++*(_DWORD *)(a1 + 16);
        v23 = llvm::DataExtractor::getULEB128(a2, a3, 0);
        v24 = llvm::DataExtractor::getULEB128(a2, a3, 0);
        v14 = v24;
        v15 = v23;
        if (!v23 || !(_WORD)v24)
          goto LABEL_40;
      }
      if ((unsigned __int16)v14 <= 0x1Fu)
      {
        if (((1 << v14) & 0xA0804000) != 0)
        {
LABEL_23:
          if (*(_BYTE *)(a1 + 158))
          {
            v20 = 0;
            ++*(_BYTE *)(a1 + 156);
            goto LABEL_31;
          }
LABEL_30:
          v20 = 0;
          goto LABEL_31;
        }
        if ((unsigned __int16)v14 == 1)
        {
          if (*(_BYTE *)(a1 + 158))
          {
            v20 = 0;
            ++*(_BYTE *)(a1 + 154);
            goto LABEL_31;
          }
          goto LABEL_30;
        }
        if ((unsigned __int16)v14 == 16)
        {
          if (*(_BYTE *)(a1 + 158))
          {
            v20 = 0;
            ++*(_BYTE *)(a1 + 155);
LABEL_31:
            v18 = *(unsigned int *)(a1 + 16);
            if (v18 >= *(unsigned int *)(a1 + 20))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 8, v25, v18 + 1, 16);
              v18 = *(unsigned int *)(a1 + 16);
            }
            v19 = (v14 << 16) | v15;
            SLEB128 = v20 | (v16 << 8);
            goto LABEL_34;
          }
          goto LABEL_30;
        }
      }
      if ((unsigned __int16)v14 - 7968 >= 2)
      {
        v26 &= 0xFFFF000000000000;
        FixedFormByteSize = llvm::dwarf::getFixedFormByteSize((unsigned __int16)v14, v26);
        if (FixedFormByteSize >= 0x100u)
        {
          v16 = FixedFormByteSize;
          if (*(_BYTE *)(a1 + 158))
            *(_WORD *)(a1 + 152) += FixedFormByteSize;
          v20 = 1;
          goto LABEL_31;
        }
        if (*(_BYTE *)(a1 + 158))
        {
          v20 = 0;
          *(_BYTE *)(a1 + 158) = 0;
          goto LABEL_31;
        }
        goto LABEL_30;
      }
      goto LABEL_23;
    }
LABEL_40:
    if (v15 | (unsigned __int16)v14)
    {
LABEL_42:
      *(_DWORD *)(a1 + 16) = 0;
      *(_QWORD *)a1 = 0;
      result = 0;
      if (*(_BYTE *)(a1 + 158))
        *(_BYTE *)(a1 + 158) = 0;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

void llvm::DWARFAbbreviationDeclaration::dump(llvm::DWARFAbbreviationDeclaration *this, llvm::raw_ostream *a2)
{
  _BYTE *v4;
  _WORD *v5;
  __int16 v6;
  void *v7;
  void *v8;
  const char *v9;
  size_t v10;
  _BYTE *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _BYTE *v16;
  _BYTE *v17;
  _BYTE *v18;
  const char *v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t (**v23)(llvm::detail::format_adapter *__hidden);
  uint64_t v24;
  _QWORD v25[2];
  _QWORD v26[2];

  v4 = (_BYTE *)*((_QWORD *)a2 + 4);
  if ((unint64_t)v4 >= *((_QWORD *)a2 + 3))
  {
    llvm::raw_ostream::write(a2, 91);
  }
  else
  {
    *((_QWORD *)a2 + 4) = v4 + 1;
    *v4 = 91;
  }
  sub_1C5E21910(a2, *(unsigned int *)this, 0, 0, 0);
  v5 = (_WORD *)*((_QWORD *)a2 + 4);
  if (*((_QWORD *)a2 + 3) - (_QWORD)v5 > 1uLL)
  {
    *v5 = 8285;
    *((_QWORD *)a2 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(a2, "] ", 2uLL);
  }
  v6 = *((_WORD *)this + 2);
  v19 = "{0}";
  v20 = 3;
  v21 = v25;
  v22 = 1;
  v23 = (uint64_t (**)(llvm::detail::format_adapter *__hidden))&unk_1E8169568;
  LOWORD(v24) = v6;
  v25[0] = &v23;
  sub_1C639D338((uint64_t)&v19, a2);
  v7 = (void *)*((_QWORD *)a2 + 4);
  if (*((_QWORD *)a2 + 3) - (_QWORD)v7 > 0xCuLL)
  {
    qmemcpy(v7, "\tDW_CHILDREN_", 13);
    v8 = (void *)(*((_QWORD *)a2 + 4) + 13);
    *((_QWORD *)a2 + 4) = v8;
  }
  else
  {
    llvm::raw_ostream::write(a2, "\tDW_CHILDREN_", 0xDuLL);
    v8 = (void *)*((_QWORD *)a2 + 4);
  }
  if (*((_BYTE *)this + 7))
    v9 = "yes";
  else
    v9 = "no";
  if (*((_BYTE *)this + 7))
    v10 = 3;
  else
    v10 = 2;
  if (v10 <= *((_QWORD *)a2 + 3) - (_QWORD)v8)
  {
    memcpy(v8, v9, v10);
    v11 = (_BYTE *)(*((_QWORD *)a2 + 4) + v10);
    *((_QWORD *)a2 + 4) = v11;
  }
  else
  {
    llvm::raw_ostream::write(a2, v9, v10);
    v11 = (_BYTE *)*((_QWORD *)a2 + 4);
  }
  if ((unint64_t)v11 >= *((_QWORD *)a2 + 3))
  {
    llvm::raw_ostream::write(a2, 10);
  }
  else
  {
    *((_QWORD *)a2 + 4) = v11 + 1;
    *v11 = 10;
  }
  v12 = *((unsigned int *)this + 4);
  if ((_DWORD)v12)
  {
    v13 = *((_QWORD *)this + 1);
    v14 = v13 + 16 * v12;
    do
    {
      v19 = "\t{0}\t{1}";
      v20 = 8;
      v21 = v26;
      v22 = 2;
      v23 = &off_1E81695B8;
      v24 = v13;
      v15 = v13 + 2;
      v25[0] = &unk_1E8169608;
      v25[1] = v13 + 2;
      v26[0] = &v23;
      v26[1] = v25;
      sub_1C639D338((uint64_t)&v19, a2);
      if (*(_WORD *)(v13 + 2) == 33)
      {
        v16 = (_BYTE *)*((_QWORD *)a2 + 4);
        if ((unint64_t)v16 >= *((_QWORD *)a2 + 3))
        {
          llvm::raw_ostream::write(a2, 9);
        }
        else
        {
          *((_QWORD *)a2 + 4) = v16 + 1;
          *v16 = 9;
        }
        llvm::raw_ostream::operator<<(a2, *(_QWORD *)(v13 + 8));
      }
      v17 = (_BYTE *)*((_QWORD *)a2 + 4);
      if ((unint64_t)v17 >= *((_QWORD *)a2 + 3))
      {
        llvm::raw_ostream::write(a2, 10);
      }
      else
      {
        *((_QWORD *)a2 + 4) = v17 + 1;
        *v17 = 10;
      }
      v13 += 16;
    }
    while (v15 + 14 != v14);
  }
  v18 = (_BYTE *)*((_QWORD *)a2 + 4);
  if ((unint64_t)v18 >= *((_QWORD *)a2 + 3))
  {
    llvm::raw_ostream::write(a2, 10);
  }
  else
  {
    *((_QWORD *)a2 + 4) = v18 + 1;
    *v18 = 10;
  }
}

uint64_t llvm::DWARFAbbreviationDeclaration::findAttributeIndex(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  unsigned __int16 *v4;
  int v5;
  uint64_t v6;

  v2 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v2)
  {
    v3 = 0;
    v4 = *(unsigned __int16 **)(a1 + 8);
    while (1)
    {
      v5 = *v4;
      v4 += 8;
      if (v5 == a2)
        break;
      if (v2 == ++v3)
        goto LABEL_5;
    }
    v6 = 0x100000000;
  }
  else
  {
LABEL_5:
    v6 = 0;
    LODWORD(v3) = 0;
  }
  return v6 | v3;
}

uint64_t llvm::DWARFAbbreviationDeclaration::getAttributeOffsetFromIndex(llvm::DWARFAbbreviationDeclaration *this, unsigned int a2, uint64_t a3, const llvm::DWARFUnit *a4)
{
  unint64_t v4;
  char v6;
  char v7;
  __int128 v8;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  unint64_t v16;
  BOOL v17;
  __int128 v18;
  __int128 v19;
  char v20;
  char v21;
  uint64_t v22;

  v6 = *((_BYTE *)a4 + 208);
  v7 = *((_BYTE *)a4 + 34);
  v8 = *(_OWORD *)*((_QWORD *)a4 + 2);
  result = *((unsigned __int8 *)this + 6) + a3;
  v22 = result;
  if (a2)
  {
    v18 = v8;
    v11 = 0;
    v12 = 16 * a2;
    while (1)
    {
      v13 = *((_QWORD *)this + 1);
      v14 = *(unsigned __int16 *)(v13 + v11 + 2);
      if (v14 == 33)
        break;
      if (*(_BYTE *)(v13 + v11 + 8))
      {
        v15 = *(unsigned __int8 *)(v13 + v11 + 9);
        goto LABEL_12;
      }
      v16 = *((unsigned int *)a4 + 8) | ((unint64_t)*((unsigned __int16 *)a4 + 18) << 32);
      LODWORD(v15) = (unsigned __int16)llvm::dwarf::getFixedFormByteSize(v14, v16);
      v17 = v15 >= 0x100;
      if (v15 <= 0x100)
        LOBYTE(v15) = 0;
      if (v17)
      {
        v15 = v15;
        goto LABEL_12;
      }
      v19 = v18;
      v20 = v6;
      v21 = v7;
      v4 = v4 & 0xFFFF000000000000 | v16;
      llvm::DWARFFormValue::skipValue(v14, (uint64_t *)&v19, (unint64_t *)&v22, v4);
LABEL_13:
      v11 += 16;
      if (v12 == v11)
        return v22;
    }
    v15 = 0;
LABEL_12:
    v22 += v15;
    goto LABEL_13;
  }
  return result;
}

uint64_t llvm::DWARFAbbreviationDeclaration::getAttributeValue@<X0>(uint64_t this@<X0>, llvm::DWARFUnit *a2@<X3>, uint64_t a3@<X1>, int a4@<W2>, _BYTE *a5@<X8>)
{
  uint64_t v6;
  llvm::DWARFAbbreviationDeclaration *v8;
  uint64_t v9;
  unsigned __int16 *v10;
  int v11;
  uint64_t AttributeOffsetFromIndex;

  v6 = *(unsigned int *)(this + 16);
  if ((_DWORD)v6)
  {
    v8 = (llvm::DWARFAbbreviationDeclaration *)this;
    v9 = 0;
    v10 = *(unsigned __int16 **)(this + 8);
    while (1)
    {
      v11 = *v10;
      v10 += 8;
      if (v11 == a4)
        break;
      if (v6 == ++v9)
        goto LABEL_5;
    }
    AttributeOffsetFromIndex = llvm::DWARFAbbreviationDeclaration::getAttributeOffsetFromIndex((llvm::DWARFAbbreviationDeclaration *)this, v9, a3, a2);
    return llvm::DWARFAbbreviationDeclaration::getAttributeValueFromOffset(v8, a2, v9, AttributeOffsetFromIndex, (uint64_t)a5);
  }
  else
  {
LABEL_5:
    *a5 = 0;
    a5[48] = 0;
  }
  return this;
}

void sub_1C547A490()
{
  JUMPOUT(0x1CAA32FC0);
}

llvm::raw_ostream *sub_1C547A4A4(uint64_t a1, llvm::raw_ostream *a2)
{
  return sub_1C624C144(*(unsigned __int16 **)(a1 + 8), a2);
}

llvm::raw_ostream *llvm::operator<<(llvm::raw_ostream *a1, uint64_t *a2)
{
  _QWORD v4[2];
  int v5;
  __int16 v6;
  _QWORD v7[4];
  _QWORD v8[5];

  v8[4] = *MEMORY[0x1E0C80C00];
  v4[0] = -1;
  v4[1] = 0x1040000FFFFFFFFLL;
  v5 = 0;
  v6 = 0;
  v7[0] = &unk_1E8169658;
  v7[1] = llvm::WithColor::defaultErrorHandler;
  v7[3] = v7;
  v8[0] = &unk_1E8169658;
  v8[1] = llvm::WithColor::defaultWarningHandler;
  v8[3] = v8;
  llvm::DWARFAddressRange::dump(a2, a1, 8u, (uint64_t)v4, 0);
  sub_1C624C568(v4);
  return a1;
}

{
  llvm::raw_ostream *v3;
  _BYTE *v4;
  _BYTE *v5;
  _BYTE *v6;
  llvm::raw_ostream *result;
  _BYTE *v8;
  uint64_t v9;

  v3 = a1;
  v4 = (_BYTE *)*((_QWORD *)a1 + 4);
  if ((unint64_t)v4 >= *((_QWORD *)a1 + 3))
  {
    v3 = llvm::raw_ostream::write(a1, 91);
  }
  else
  {
    *((_QWORD *)a1 + 4) = v4 + 1;
    *v4 = 91;
  }
  v9 = *a2;
  llvm::SlotIndex::print((llvm::SlotIndex *)&v9, v3);
  v5 = (_BYTE *)*((_QWORD *)v3 + 4);
  if ((unint64_t)v5 >= *((_QWORD *)v3 + 3))
  {
    v3 = llvm::raw_ostream::write(v3, 44);
  }
  else
  {
    *((_QWORD *)v3 + 4) = v5 + 1;
    *v5 = 44;
  }
  v9 = a2[1];
  llvm::SlotIndex::print((llvm::SlotIndex *)&v9, v3);
  v6 = (_BYTE *)*((_QWORD *)v3 + 4);
  if ((unint64_t)v6 >= *((_QWORD *)v3 + 3))
  {
    v3 = llvm::raw_ostream::write(v3, 58);
  }
  else
  {
    *((_QWORD *)v3 + 4) = v6 + 1;
    *v6 = 58;
  }
  result = llvm::raw_ostream::operator<<(v3, *(unsigned int *)a2[2]);
  v8 = (_BYTE *)*((_QWORD *)result + 4);
  if ((unint64_t)v8 >= *((_QWORD *)result + 3))
    return llvm::raw_ostream::write(result, 41);
  *((_QWORD *)result + 4) = v8 + 1;
  *v8 = 41;
  return result;
}

void llvm::AppleAcceleratorTable::extract(llvm::AppleAcceleratorTable *this@<X0>, _QWORD *a2@<X8>)
{
  const char *v3;
  char *v5;
  unsigned int v6;
  const std::error_category *v7;
  int v8;
  int v9;
  int v10;
  int v11;
  unint64_t v12;
  int v13;
  unint64_t v14;
  const char *v15;
  uint64_t v16;
  const std::error_category *v17;

  v14 = 0;
  if (*((_QWORD *)this + 2) <= 0x14uLL)
  {
    v16 = 92;
    v17 = std::generic_category();
    v3 = "Section too small: cannot read header.";
LABEL_3:
    v15 = v3;
    sub_1C5DF1730((_BYTE **)&v15, &v16, a2);
    return;
  }
  v5 = (char *)this + 8;
  *((_DWORD *)this + 18) = sub_1C6387364((uint64_t)this + 8, &v14, 0);
  *((_WORD *)this + 38) = sub_1C63871E8((uint64_t)v5, &v14, 0);
  *((_WORD *)this + 39) = sub_1C63871E8((uint64_t)v5, &v14, 0);
  *((_DWORD *)this + 20) = sub_1C6387364((uint64_t)v5, &v14, 0);
  *((_DWORD *)this + 21) = sub_1C6387364((uint64_t)v5, &v14, 0);
  v6 = sub_1C6387364((uint64_t)v5, &v14, 0);
  *((_DWORD *)this + 22) = v6;
  if (*((_QWORD *)this + 2) <= (4 * *((_DWORD *)this + 20))
                              + (unint64_t)v6
                              + (8 * *((_DWORD *)this + 21))
                              + 19)
  {
    v7 = std::generic_category();
    v16 = 92;
    v17 = v7;
    v3 = "Section too small: cannot read buckets and hashes.";
    goto LABEL_3;
  }
  *((_QWORD *)this + 12) = sub_1C6387364((uint64_t)v5, &v14, 0);
  v8 = sub_1C6387364((uint64_t)v5, &v14, 0);
  if (v8)
  {
    v9 = v8;
    do
    {
      v10 = sub_1C63871E8((uint64_t)v5, &v14, 0);
      v11 = sub_1C63871E8((uint64_t)v5, &v14, 0);
      v12 = *((unsigned int *)this + 28);
      if (v12 >= *((unsigned int *)this + 29))
      {
        v13 = v11;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)this + 104, (uint64_t)this + 120, v12 + 1, 4);
        v11 = v13;
        v12 = *((unsigned int *)this + 28);
      }
      *(_DWORD *)(*((_QWORD *)this + 13) + 4 * v12) = v10 | (v11 << 16);
      ++*((_DWORD *)this + 28);
      --v9;
    }
    while (v9);
  }
  *((_BYTE *)this + 136) = 1;
  *a2 = 0;
}

uint64_t llvm::AppleAcceleratorTable::getNumBuckets(llvm::AppleAcceleratorTable *this)
{
  return *((unsigned int *)this + 20);
}

uint64_t llvm::AppleAcceleratorTable::getNumHashes(llvm::AppleAcceleratorTable *this)
{
  return *((unsigned int *)this + 21);
}

uint64_t llvm::AppleAcceleratorTable::getSizeHdr(llvm::AppleAcceleratorTable *this)
{
  return 20;
}

uint64_t llvm::AppleAcceleratorTable::getHeaderDataLength(llvm::AppleAcceleratorTable *this)
{
  return *((unsigned int *)this + 22);
}

uint64_t llvm::AppleAcceleratorTable::getAtomsDesc(llvm::AppleAcceleratorTable *this)
{
  return *((_QWORD *)this + 13);
}

uint64_t llvm::AppleAcceleratorTable::validateForms(llvm::AppleAcceleratorTable *this)
{
  uint64_t v1;
  uint64_t v2;
  unsigned __int16 *v3;
  unsigned __int16 *v4;
  unsigned int v5;
  int v6;
  BOOL v7;
  int v8;
  char isFormClass;
  unsigned __int16 v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v1 = *((unsigned int *)this + 28);
  v2 = 1;
  if ((_DWORD)v1)
  {
    v3 = (unsigned __int16 *)*((_QWORD *)this + 13);
    v4 = &v3[2 * v1];
    while (1)
    {
      v5 = *v3;
      v6 = v3[1];
      v12 = v3[1];
      v13 = 0;
      v14 = 0;
      v15 = 0;
      v16 = 0;
      v17 = 0;
      v7 = v5 > 4;
      v8 = (1 << v5) & 0x1A;
      if (!v7 && v8 != 0)
      {
        isFormClass = llvm::DWARFFormValue::isFormClass(&v12, 3);
        if ((isFormClass & 1) == 0 && !llvm::DWARFFormValue::isFormClass(&v12, 5) || v6 == 13)
          break;
      }
      v3 += 2;
      if (v3 == v4)
        return 1;
    }
    return 0;
  }
  return v2;
}

unint64_t llvm::AppleAcceleratorTable::readAtoms(llvm::AppleAcceleratorTable *this, unint64_t *a2)
{
  unint64_t v2;
  uint64_t v3;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  uint64_t v7;
  uint64_t *v8;
  unint64_t AsUnsignedConstant;
  int v10;
  unsigned __int16 v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v3 = *((unsigned int *)this + 28);
  if (!(_DWORD)v3)
    return 0xFFFFFFFFLL;
  v5 = (unsigned __int16 *)*((_QWORD *)this + 13);
  v6 = &v5[2 * v3];
  v7 = *((unsigned __int16 *)this + 38);
  v8 = (uint64_t *)((char *)this + 8);
  AsUnsignedConstant = 0xFFFFFFFFLL;
  do
  {
    v10 = *v5;
    v12 = v5[1];
    v13 = 0;
    v2 = v2 & 0xFFFF000000000000 | v7;
    v14 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    llvm::DWARFFormValue::extractValue(&v12, v8, (uint64_t *)a2, v2, 0, 0);
    if (v10 == 3)
    {
      llvm::DWARFFormValue::getAsUnsignedConstant((llvm::DWARFFormValue *)&v12);
    }
    else if (v10 == 1)
    {
      AsUnsignedConstant = llvm::DWARFFormValue::getAsUnsignedConstant((llvm::DWARFFormValue *)&v12);
    }
    v5 += 2;
  }
  while (v5 != v6);
  return AsUnsignedConstant;
}

unint64_t llvm::AppleAcceleratorTable::HeaderData::extractOffset(_QWORD *a1, unsigned __int16 *a2)
{
  uint64_t v3;
  unint64_t v4;

  if (*((_BYTE *)a2 + 48))
  {
    if (*a2 - 17 > 4)
    {
      if (llvm::DWARFFormValue::isFormClass(a2, 8))
        v3 = *((_QWORD *)a2 + 1);
      else
        v3 = 0;
      v4 = v3 & 0xFFFFFFFFFFFFFF00;
    }
    else
    {
      v3 = *a1 + *((_QWORD *)a2 + 1);
      v4 = v3 & 0xFFFFFFFFFFFFFF00;
    }
  }
  else
  {
    LOBYTE(v3) = 0;
    v4 = 0;
  }
  return v4 | v3;
}

BOOL llvm::AppleAcceleratorTable::dumpName(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  uint64_t v5;
  unint64_t v6;
  _BOOL8 v8;
  unint64_t RelocatedValue;
  _QWORD *v13;
  void *p_p;
  uint64_t v15;
  llvm::raw_ostream *v16;
  llvm::raw_ostream *v17;
  unint64_t v18;
  _WORD *v19;
  const char *CStrRef;
  _WORD *v21;
  const char *v22;
  size_t v23;
  size_t v24;
  uint64_t *v25;
  unsigned int v26;
  uint64_t v27;
  unint64_t v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  unsigned __int16 *v34;
  uint64_t v35;
  llvm::raw_ostream *v36;
  int Value;
  llvm::raw_ostream *v38;
  void *v39;
  const char *v40;
  size_t v41;
  llvm::raw_ostream *v42;
  _BYTE *v43;
  llvm::dwarf *AsUnsignedConstant;
  char v45;
  const char *v46;
  size_t v47;
  llvm::raw_ostream *v48;
  llvm::raw_ostream *v49;
  _WORD *v50;
  void *v51;
  _BYTE *v52;
  const char *__src;
  uint64_t v54;
  uint64_t v55;
  size_t __n;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  const char *v60;
  const char *v61;
  _QWORD *v62;
  __int16 v63;
  void *__p;
  uint64_t v65;
  char v66;
  unint64_t v67;
  unint64_t v68;
  _QWORD v69[3];
  void *v70;
  __int128 v71;
  void **v72;
  void *v73;
  __int128 v74;
  void **v75;
  uint64_t v76;

  v76 = *MEMORY[0x1E0C80C00];
  v5 = *(unsigned __int16 *)(a1 + 76);
  v6 = *a4;
  v68 = v6;
  if (v6 <= 0xFFFFFFFFFFFFFFFBLL && *(_QWORD *)(a1 + 16) > v6 + 3)
  {
    RelocatedValue = llvm::DWARFDataExtractor::getRelocatedValue(a1 + 8, 4, a4, 0, 0);
    v67 = RelocatedValue;
    v8 = RelocatedValue != 0;
    if (!RelocatedValue)
      return v8;
    v13 = (_QWORD *)RelocatedValue;
    v59 = v5;
    v60 = "Name@0x";
    v62 = &v68;
    v63 = 3587;
    llvm::Twine::str((llvm::Twine *)&v60, &__p);
    if (v66 >= 0)
      p_p = &__p;
    else
      p_p = __p;
    if (v66 >= 0)
      v15 = v66 & 0x7F;
    else
      v15 = v65;
    (*(void (**)(uint64_t, void *, uint64_t))(*(_QWORD *)a2 + 208))(a2, p_p, v15);
    if (v66 < 0)
      operator delete(__p);
    v16 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 248))(a2);
    v60 = (const char *)&unk_1E8133270;
    v61 = "String: 0x%08llx";
    v62 = v13;
    llvm::raw_ostream::operator<<(v16, (uint64_t)&v60);
    v17 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 256))(a2);
    v18 = (unint64_t)v17;
    v19 = (_WORD *)*((_QWORD *)v17 + 4);
    if (*((_QWORD *)v17 + 3) - (_QWORD)v19 > 1uLL)
    {
      *v19 = 8736;
      *((_QWORD *)v17 + 4) += 2;
    }
    else
    {
      llvm::raw_ostream::write(v17, " \"", 2uLL);
    }
    CStrRef = (const char *)llvm::DataExtractor::getCStrRef((uint64_t *)(a1 + 48), &v67, 0);
    v21 = *(_WORD **)(v18 + 32);
    v55 = a3;
    if (CStrRef)
    {
      v22 = CStrRef;
      v23 = strlen(CStrRef);
      v24 = v23;
      if (v23 <= *(_QWORD *)(v18 + 24) - (_QWORD)v21)
      {
        if (v23)
        {
          memcpy(v21, v22, v23);
          v21 = (_WORD *)(*(_QWORD *)(v18 + 32) + v24);
          *(_QWORD *)(v18 + 32) = v21;
        }
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)v18, v22, v23);
        v21 = *(_WORD **)(v18 + 32);
      }
    }
    v25 = (uint64_t *)(a1 + 8);
    if (*(_QWORD *)(v18 + 24) - (_QWORD)v21 > 1uLL)
    {
      *v21 = 2594;
      *(_QWORD *)(v18 + 32) += 2;
    }
    else
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)v18, "\"\n", 2uLL);
    }
    v26 = sub_1C6387364(a1 + 8, a4, 0);
    if (!v26)
    {
LABEL_60:
      (*(void (**)(uint64_t))(*(_QWORD *)a2 + 216))(a2);
      return v8;
    }
    v27 = 0;
    v54 = v26;
    while (1)
    {
      v58 = v27;
      v28 = v57 & 0xFFFFFFFF00000000 | v27;
      v60 = "Data ";
      v62 = (_QWORD *)v28;
      v63 = 2051;
      llvm::Twine::str((llvm::Twine *)&v60, &__p);
      if (v66 >= 0)
        v29 = &__p;
      else
        v29 = __p;
      if (v66 >= 0)
        v30 = v66 & 0x7F;
      else
        v30 = v65;
      (*(void (**)(uint64_t, void *, uint64_t))(*(_QWORD *)a2 + 232))(a2, v29, v30);
      if (v66 < 0)
        operator delete(__p);
      v57 = v28;
      v31 = *(unsigned int *)(a3 + 8);
      if ((_DWORD)v31)
        break;
LABEL_59:
      (*(void (**)(uint64_t))(*(_QWORD *)a2 + 240))(a2);
      v27 = v58 + 1;
      a3 = v55;
      if (v58 + 1 == v54)
        goto LABEL_60;
    }
    v32 = 0;
    v33 = 0;
    v34 = *(unsigned __int16 **)a3;
    v35 = 48 * v31;
    while (1)
    {
      v36 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 248))(a2);
      v60 = (const char *)&off_1E8132728;
      v61 = "Atom[%d]: ";
      v62 = v33;
      llvm::raw_ostream::operator<<(v36, (uint64_t)&v60);
      v18 = v18 & 0xFFFF000000000000 | v59;
      Value = llvm::DWARFFormValue::extractValue(v34, v25, (uint64_t *)a4, v18, 0, 0);
      v38 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 256))(a2);
      if (!Value)
        break;
      v74 = 0u;
      v69[2] = 0;
      v71 = 0u;
      v69[0] = -1;
      v69[1] = 0x1040000FFFFFFFFLL;
      v70 = &unk_1E8169658;
      *(_QWORD *)&v71 = llvm::WithColor::defaultErrorHandler;
      v72 = &v70;
      v73 = &unk_1E8169658;
      *(_QWORD *)&v74 = llvm::WithColor::defaultWarningHandler;
      v75 = &v73;
      llvm::DWARFFormValue::dump(v34, v38, (uint64_t)v69);
      sub_1C624C568(v69);
      AsUnsignedConstant = (llvm::dwarf *)llvm::DWARFFormValue::getAsUnsignedConstant((llvm::DWARFFormValue *)v34);
      v25 = (uint64_t *)(a1 + 8);
      if (!v45)
        goto LABEL_38;
      if (!*(_WORD *)(*(_QWORD *)(a1 + 104) + v32))
      {
        __n = 4;
        __src = "NULL";
LABEL_50:
        v48 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 256))(a2);
        v49 = v48;
        v50 = (_WORD *)*((_QWORD *)v48 + 4);
        if (*((_QWORD *)v48 + 3) - (_QWORD)v50 > 1uLL)
        {
          *v50 = 10272;
          v51 = (void *)(*((_QWORD *)v48 + 4) + 2);
          *((_QWORD *)v49 + 4) = v51;
        }
        else
        {
          llvm::raw_ostream::write(v48, " (", 2uLL);
          v51 = (void *)*((_QWORD *)v49 + 4);
        }
        if (__n <= *((_QWORD *)v49 + 3) - (_QWORD)v51)
        {
          memcpy(v51, __src, __n);
          v52 = (_BYTE *)(*((_QWORD *)v49 + 4) + __n);
          *((_QWORD *)v49 + 4) = v52;
        }
        else
        {
          llvm::raw_ostream::write(v49, __src, __n);
          v52 = (_BYTE *)*((_QWORD *)v49 + 4);
        }
        if (*((_BYTE **)v49 + 3) == v52)
        {
          v38 = v49;
          v40 = ")";
          v41 = 1;
LABEL_36:
          llvm::raw_ostream::write(v38, v40, v41);
        }
        else
        {
          *v52 = 41;
          ++*((_QWORD *)v49 + 4);
        }
        goto LABEL_37;
      }
      if (*(_WORD *)(*(_QWORD *)(a1 + 104) + v32) == 3)
      {
        v46 = llvm::dwarf::TagString(AsUnsignedConstant);
        if (v47)
        {
          __src = v46;
          __n = v47;
          goto LABEL_50;
        }
      }
LABEL_38:
      v42 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 256))(a2);
      v43 = (_BYTE *)*((_QWORD *)v42 + 4);
      if (*((_BYTE **)v42 + 3) == v43)
      {
        llvm::raw_ostream::write(v42, "\n", 1uLL);
      }
      else
      {
        *v43 = 10;
        ++*((_QWORD *)v42 + 4);
      }
      v33 = (_QWORD *)((char *)v33 + 1);
      v34 += 24;
      v32 += 4;
      v35 -= 48;
      if (!v35)
        goto LABEL_59;
    }
    v39 = (void *)*((_QWORD *)v38 + 4);
    if (*((_QWORD *)v38 + 3) - (_QWORD)v39 <= 0x19uLL)
    {
      v40 = "Error extracting the value";
      v41 = 26;
      goto LABEL_36;
    }
    qmemcpy(v39, "Error extracting the value", 26);
    *((_QWORD *)v38 + 4) += 26;
LABEL_37:
    v25 = (uint64_t *)(a1 + 8);
    goto LABEL_38;
  }
  (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a2 + 184))(a2, "Incorrectly terminated list.", 28);
  return 0;
}

void llvm::AppleAcceleratorTable::dump(llvm::AppleAcceleratorTable *this, llvm::raw_ostream *a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v5;
  uint64_t v6;
  __int16 *v7;
  const char *p_p;
  uint64_t v9;
  llvm::raw_ostream *v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  size_t v14;
  void *v15;
  _OWORD *v16;
  _BYTE *v17;
  llvm::raw_ostream *v18;
  uint64_t v19;
  _WORD *v20;
  _BYTE *v21;
  __int16 v22;
  _OWORD *v23;
  _OWORD *v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;
  int v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  const char *v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int v39;
  const char *v40;
  uint64_t v41;
  __int16 *v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  uint64_t v47;
  const char *v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  void *v52;
  _WORD *v53;
  void **v54;
  void *__p;
  uint64_t v56;
  char v57;
  void (**v58)(void **, const char *, uint64_t);
  llvm::raw_ostream *v59;
  int v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  void *v64;
  uint64_t v65;
  _QWORD v66[20];

  v66[18] = *MEMORY[0x1E0C80C00];
  if (*((_BYTE *)this + 136))
  {
    v58 = (void (**)(void **, const char *, uint64_t))&unk_1E81A26B0;
    v59 = a2;
    v60 = 0;
    v61 = 0;
    v62 = 0;
    v63 = 0;
    llvm::AppleAcceleratorTable::Header::dump((unsigned int *)this + 18, (uint64_t)&v58);
    sub_1C624C7A4((uint64_t)&v58, "DIE offset base", 0xFuLL, *((_QWORD *)this + 12));
    sub_1C624C7A4((uint64_t)&v58, "Number of atoms", 0xFuLL, *((unsigned int *)this + 28));
    v64 = v66;
    v65 = 0x300000000;
    v58[29]((void **)&v58, "Atoms", 5);
    v5 = *((unsigned int *)this + 28);
    if ((_DWORD)v5)
    {
      v6 = 0;
      v7 = (__int16 *)*((_QWORD *)this + 13);
      v42 = &v7[2 * v5];
      v2 = (unint64_t)&v49;
      do
      {
        v3 = v3 & 0xFFFFFFFF00000000 | v6;
        v48 = "Atom ";
        v50 = v3;
        LOWORD(v52) = 2051;
        llvm::Twine::str((llvm::Twine *)&v48, &__p);
        if (v57 >= 0)
          p_p = (const char *)&__p;
        else
          p_p = (const char *)__p;
        if (v57 >= 0)
          v9 = v57 & 0x7F;
        else
          v9 = v56;
        v58[26]((void **)&v58, p_p, v9);
        if (v57 < 0)
          operator delete(__p);
        sub_1C624CF60((uint64_t)&v58);
        v10 = v59;
        v11 = *((_QWORD *)v59 + 4);
        if ((unint64_t)(*((_QWORD *)v59 + 3) - v11) > 5)
        {
          *(_WORD *)(v11 + 4) = 8250;
          *(_DWORD *)v11 = 1701869908;
          *((_QWORD *)v10 + 4) += 6;
        }
        else
        {
          llvm::raw_ostream::write(v59, "Type: ", 6uLL);
        }
        v12 = *v7;
        if (v12 > 7)
        {
          v16 = (_OWORD *)*((_QWORD *)v10 + 4);
          if (*((_QWORD *)v10 + 3) - (_QWORD)v16 > 0xFuLL)
          {
            *v16 = *(_OWORD *)"DW_ATOM_unknown_";
            *((_QWORD *)v10 + 4) += 16;
          }
          else
          {
            llvm::raw_ostream::write(v10, "DW_ATOM_unknown_", 0x10uLL);
          }
          v48 = (const char *)&off_1E8132728;
          v49 = (uint64_t)"%x";
          v50 = (unsigned __int16)v12;
          llvm::raw_ostream::operator<<(v10, (uint64_t)&v48);
        }
        else
        {
          v13 = off_1E8169890[v12];
          v14 = qword_1C8651750[v12];
          v15 = (void *)*((_QWORD *)v10 + 4);
          if (v14 <= *((_QWORD *)v10 + 3) - (_QWORD)v15)
          {
            memcpy(v15, v13, v14);
            *((_QWORD *)v10 + 4) += v14;
          }
          else
          {
            llvm::raw_ostream::write(v10, v13, v14);
          }
        }
        v17 = (_BYTE *)*((_QWORD *)v10 + 4);
        if ((unint64_t)v17 >= *((_QWORD *)v10 + 3))
        {
          llvm::raw_ostream::write(v10, 10);
        }
        else
        {
          *((_QWORD *)v10 + 4) = v17 + 1;
          *v17 = 10;
        }
        sub_1C624CF60((uint64_t)&v58);
        v18 = v59;
        v19 = *((_QWORD *)v59 + 4);
        if ((unint64_t)(*((_QWORD *)v59 + 3) - v19) > 5)
        {
          *(_WORD *)(v19 + 4) = 8250;
          *(_DWORD *)v19 = 1836216134;
          *((_QWORD *)v18 + 4) += 6;
        }
        else
        {
          llvm::raw_ostream::write(v59, "Form: ", 6uLL);
        }
        v48 = "{0}";
        v49 = 3;
        v50 = (unint64_t)&v54;
        v51 = 1;
        v20 = v7 + 1;
        v52 = &unk_1E8169608;
        v53 = v20;
        v54 = &v52;
        sub_1C639D338((uint64_t)&v48, v18);
        v21 = (_BYTE *)*((_QWORD *)v18 + 4);
        if ((unint64_t)v21 >= *((_QWORD *)v18 + 3))
        {
          llvm::raw_ostream::write(v18, 10);
        }
        else
        {
          *((_QWORD *)v18 + 4) = v21 + 1;
          *v21 = 10;
        }
        v22 = *v20;
        v7 = v20 + 1;
        LOWORD(v48) = v22;
        BYTE2(v48) = 0;
        v49 = 0;
        v50 = 0;
        v52 = 0;
        v53 = 0;
        v23 = (_OWORD *)sub_1C4FE36B8((uint64_t)&v64, (unint64_t)&v48);
        v24 = (char *)v64 + 48 * v65;
        v26 = v23[1];
        v25 = v23[2];
        *v24 = *v23;
        v24[1] = v26;
        v24[2] = v25;
        LODWORD(v65) = v65 + 1;
        ((void (*)(void (***)(void **, const char *, uint64_t)))v58[27])(&v58);
        ++v6;
      }
      while (v7 != v42);
    }
    ((void (*)(void (***)(void **, const char *, uint64_t)))v58[30])(&v58);
    v27 = *((unsigned int *)this + 22) + 20;
    v47 = v27;
    v28 = *((_DWORD *)this + 20);
    if (v28)
    {
      v29 = 0;
      v30 = v27 + (4 * v28);
      v31 = v30 + (4 * *((_DWORD *)this + 21));
      do
      {
        v32 = sub_1C6387364((uint64_t)this + 8, (unint64_t *)&v47, 0);
        v2 = v2 & 0xFFFFFFFF00000000 | v29;
        v48 = "Bucket ";
        v50 = v2;
        LOWORD(v52) = 2051;
        llvm::Twine::str((llvm::Twine *)&v48, &__p);
        if (v57 >= 0)
          v33 = (const char *)&__p;
        else
          v33 = (const char *)__p;
        if (v57 >= 0)
          v34 = v57 & 0x7F;
        else
          v34 = v56;
        v58[29]((void **)&v58, v33, v34);
        if (v57 < 0)
          operator delete(__p);
        if (v32 == -1)
        {
          sub_1C624C840((uint64_t)&v58, "EMPTY", 5uLL);
        }
        else if (v32 < *((_DWORD *)this + 21))
        {
          v35 = v32;
          do
          {
            v36 = (4 * v35);
            v45 = v31 + v36;
            v46 = v36 + v30;
            v37 = sub_1C6387364((uint64_t)this + 8, &v46, 0);
            if (v29 != v37 % *((_DWORD *)this + 20))
              break;
            v38 = v37;
            v44 = 0;
            v39 = sub_1C6387364((uint64_t)this + 8, &v45, 0);
            v43 = v38;
            v44 = v39;
            v48 = "Hash 0x";
            v50 = (unint64_t)&v43;
            LOWORD(v52) = 3587;
            llvm::Twine::str((llvm::Twine *)&v48, &__p);
            if (v57 >= 0)
              v40 = (const char *)&__p;
            else
              v40 = (const char *)__p;
            if (v57 >= 0)
              v41 = v57 & 0x7F;
            else
              v41 = v56;
            v58[29]((void **)&v58, v40, v41);
            if (v57 < 0)
              operator delete(__p);
            if (*((_QWORD *)this + 2) <= v44)
            {
              sub_1C624C840((uint64_t)&v58, "Invalid section offset", 0x16uLL);
            }
            else
            {
              while (llvm::AppleAcceleratorTable::dumpName((uint64_t)this, (uint64_t)&v58, (uint64_t)&v64, &v44))
                ;
            }
            ((void (*)(void (***)(void **, const char *, uint64_t)))v58[30])(&v58);
            ++v35;
          }
          while (v35 < *((unsigned int *)this + 21));
        }
        ((void (*)(void (***)(void **, const char *, uint64_t)))v58[30])(&v58);
        ++v29;
      }
      while (v29 < *((unsigned int *)this + 20));
    }
    if (v64 != v66)
      free(v64);
  }
}

_QWORD *llvm::AppleAcceleratorTable::Entry::Entry(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  __int16 *v7;
  __int16 v8;
  _OWORD *v9;
  _OWORD *v10;
  __int128 v11;
  __int128 v12;
  __int16 v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  a1[1] = a1 + 3;
  v4 = (uint64_t)(a1 + 1);
  a1[2] = 0x300000000;
  *a1 = off_1E81696A0;
  a1[21] = a2;
  v5 = *(unsigned int *)(a2 + 16);
  if (v5 >= 4)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(a1 + 1), (uint64_t)(a1 + 3), v5, 48);
    LODWORD(v5) = *(_DWORD *)(a2 + 16);
  }
  if ((_DWORD)v5)
  {
    v6 = 4 * v5;
    v7 = (__int16 *)(*(_QWORD *)(a2 + 8) + 2);
    do
    {
      v8 = *v7;
      v7 += 2;
      v14 = v8;
      v15 = 0;
      v16 = 0;
      v17 = 0;
      v18 = 0;
      v19 = 0;
      v9 = (_OWORD *)sub_1C4FE36B8(v4, (unint64_t)&v14);
      v10 = (_OWORD *)(a1[1] + 48 * *((unsigned int *)a1 + 4));
      v12 = v9[1];
      v11 = v9[2];
      *v10 = *v9;
      v10[1] = v12;
      v10[2] = v11;
      ++*((_DWORD *)a1 + 4);
      v6 -= 4;
    }
    while (v6);
  }
  return a1;
}

uint64_t llvm::AppleAcceleratorTable::Entry::extract(uint64_t this, const llvm::AppleAcceleratorTable *a2, unint64_t *a3)
{
  unint64_t v3;
  uint64_t v4;
  unsigned __int16 *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;

  v4 = *(unsigned int *)(this + 16);
  if ((_DWORD)v4)
  {
    v6 = *(unsigned __int16 **)(this + 8);
    v7 = *((unsigned __int16 *)a2 + 38);
    v8 = (uint64_t *)((char *)a2 + 8);
    v9 = 48 * v4;
    do
    {
      v3 = v3 & 0xFFFF000000000000 | v7;
      this = llvm::DWARFFormValue::extractValue(v6, v8, (uint64_t *)a3, v3, 0, 0);
      v6 += 24;
      v9 -= 48;
    }
    while (v9);
  }
  return this;
}

uint64_t llvm::AppleAcceleratorTable::Entry::lookup@<X0>(uint64_t this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  unsigned __int16 *v5;
  _OWORD *v6;
  uint64_t v7;
  char v8;
  __int128 v9;

  v3 = *(_QWORD *)(this + 168);
  v4 = *(unsigned int *)(v3 + 16);
  if ((_DWORD)v4)
  {
    v5 = *(unsigned __int16 **)(v3 + 8);
    v6 = *(_OWORD **)(this + 8);
    v7 = 4 * v4;
    while (*v5 != a2)
    {
      v5 += 2;
      v6 += 3;
      v7 -= 4;
      if (!v7)
        goto LABEL_5;
    }
    v9 = v6[1];
    *(_OWORD *)a3 = *v6;
    *(_OWORD *)(a3 + 16) = v9;
    *(_OWORD *)(a3 + 32) = v6[2];
    v8 = 1;
  }
  else
  {
LABEL_5:
    v8 = 0;
    *(_BYTE *)a3 = 0;
  }
  *(_BYTE *)(a3 + 48) = v8;
  return this;
}

unint64_t llvm::AppleAcceleratorTable::Entry::getDIESectionOffset(llvm::AppleAcceleratorTable::Entry *this)
{
  uint64_t v2;
  uint64_t v3;
  _WORD *v4;
  _OWORD *v5;
  uint64_t v6;
  char v7;
  __int128 v8;
  _OWORD v10[3];
  char v11;

  v2 = *((_QWORD *)this + 21);
  v3 = *(unsigned int *)(v2 + 16);
  if ((_DWORD)v3)
  {
    v4 = *(_WORD **)(v2 + 8);
    v5 = (_OWORD *)*((_QWORD *)this + 1);
    v6 = 4 * v3;
    while (*v4 != 1)
    {
      v4 += 2;
      v5 += 3;
      v6 -= 4;
      if (!v6)
        goto LABEL_5;
    }
    v8 = v5[1];
    v10[0] = *v5;
    v10[1] = v8;
    v10[2] = v5[2];
    v7 = 1;
  }
  else
  {
LABEL_5:
    v7 = 0;
    LOBYTE(v10[0]) = 0;
  }
  v11 = v7;
  return llvm::AppleAcceleratorTable::HeaderData::extractOffset((_QWORD *)v2, (unsigned __int16 *)v10);
}

unint64_t llvm::AppleAcceleratorTable::Entry::getCUOffset(llvm::AppleAcceleratorTable::Entry *this)
{
  uint64_t v2;
  uint64_t v3;
  _WORD *v4;
  _OWORD *v5;
  uint64_t v6;
  char v7;
  __int128 v8;
  _OWORD v10[3];
  char v11;

  v2 = *((_QWORD *)this + 21);
  v3 = *(unsigned int *)(v2 + 16);
  if ((_DWORD)v3)
  {
    v4 = *(_WORD **)(v2 + 8);
    v5 = (_OWORD *)*((_QWORD *)this + 1);
    v6 = 4 * v3;
    while (*v4 != 2)
    {
      v4 += 2;
      v5 += 3;
      v6 -= 4;
      if (!v6)
        goto LABEL_5;
    }
    v8 = v5[1];
    v10[0] = *v5;
    v10[1] = v8;
    v10[2] = v5[2];
    v7 = 1;
  }
  else
  {
LABEL_5:
    v7 = 0;
    LOBYTE(v10[0]) = 0;
  }
  v11 = v7;
  return llvm::AppleAcceleratorTable::HeaderData::extractOffset((_QWORD *)v2, (unsigned __int16 *)v10);
}

uint64_t llvm::AppleAcceleratorTable::Entry::getTag(llvm::AppleAcceleratorTable::Entry *this)
{
  uint64_t v1;
  uint64_t v2;
  _WORD *v3;
  _OWORD *v4;
  int v5;
  int v6;
  __int128 v8;
  __int16 AsUnsignedConstant;
  char v10;
  _OWORD v11[3];
  char v12;

  v1 = *((_QWORD *)this + 21);
  v2 = *(unsigned int *)(v1 + 16);
  if ((_DWORD)v2)
  {
    v3 = *(_WORD **)(v1 + 8);
    v4 = (_OWORD *)*((_QWORD *)this + 1);
    v2 *= 4;
    while (*v3 != 3)
    {
      v3 += 2;
      v4 += 3;
      v2 -= 4;
      if (!v2)
        goto LABEL_5;
    }
    v8 = v4[1];
    v11[0] = *v4;
    v11[1] = v8;
    v11[2] = v4[2];
    v12 = 1;
    AsUnsignedConstant = llvm::DWARFFormValue::getAsUnsignedConstant((llvm::DWARFFormValue *)v11);
    LODWORD(v2) = AsUnsignedConstant & 0xFF00;
    v6 = AsUnsignedConstant;
    if (v10)
      v5 = 0x10000;
    else
      v5 = 0;
    if (!v10)
    {
      v6 = 0;
      LODWORD(v2) = 0;
    }
  }
  else
  {
LABEL_5:
    v5 = 0;
    v6 = 0;
  }
  return v6 | v5 | v2;
}

llvm::AppleAcceleratorTable::ValueIterator *llvm::AppleAcceleratorTable::ValueIterator::ValueIterator(llvm::AppleAcceleratorTable::ValueIterator *this, const llvm::AppleAcceleratorTable *a2, unint64_t a3)
{
  *(_QWORD *)this = a2;
  llvm::AppleAcceleratorTable::Entry::Entry((_QWORD *)this + 1, (uint64_t)a2 + 96);
  *((_QWORD *)this + 23) = a3;
  *((_QWORD *)this + 24) = 0;
  if (a3 <= 0xFFFFFFFFFFFFFFFBLL && *((_QWORD *)a2 + 2) > a3 + 3)
  {
    *((_DWORD *)this + 49) = sub_1C6387364((uint64_t)a2 + 8, (unint64_t *)this + 23, 0);
    llvm::AppleAcceleratorTable::ValueIterator::Next((uint64_t *)this);
  }
  return this;
}

uint64_t *llvm::AppleAcceleratorTable::ValueIterator::Next(uint64_t *this)
{
  unint64_t v1;
  uint64_t v2;
  unsigned int v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned __int16 *v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;

  v2 = (uint64_t)this;
  v3 = *((_DWORD *)this + 48);
  if (v3 >= *((_DWORD *)this + 49)
    || (v4 = this[23], v4 > 0xFFFFFFFFFFFFFFFBLL)
    || (v5 = *this, *(_QWORD *)(*this + 16) <= v4 + 3))
  {
    *((_DWORD *)this + 49) = 0;
    this[23] = 0;
  }
  else
  {
    v6 = *((unsigned int *)this + 6);
    if ((_DWORD)v6)
    {
      v7 = (unsigned __int16 *)this[2];
      v8 = *(unsigned __int16 *)(v5 + 76);
      v9 = (uint64_t *)(v5 + 8);
      v10 = 48 * v6;
      do
      {
        v1 = v1 & 0xFFFF000000000000 | v8;
        this = (uint64_t *)llvm::DWARFFormValue::extractValue(v7, v9, (uint64_t *)(v2 + 184), v1, 0, 0);
        v7 += 24;
        v10 -= 48;
      }
      while (v10);
      v3 = *(_DWORD *)(v2 + 192);
    }
    *(_DWORD *)(v2 + 192) = v3 + 1;
  }
  return this;
}

void llvm::AppleAcceleratorTable::equal_range(uint64_t a1@<X0>, unsigned __int8 *a2@<X1>, size_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t *v5;
  uint64_t *v6;
  unsigned int v10;
  size_t v11;
  unsigned __int8 *v12;
  int v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  int v21;
  uint64_t v22;
  const char *CStrRef;
  const char *v24;
  uint64_t v25;
  int v26;
  unint64_t RelocatedValue;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t (**v33)(llvm::AppleAcceleratorTable::Entry *__hidden);
  void *v34[2];
  _OWORD v35[9];
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t (**v40)(llvm::AppleAcceleratorTable::Entry *__hidden);
  __int128 v41;
  _BYTE v42[144];
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t (**v47)(llvm::AppleAcceleratorTable::Entry *__hidden);
  __int128 v48;
  _BYTE v49[144];
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53[2];
  uint64_t *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t (**v57)(llvm::AppleAcceleratorTable::Entry *__hidden);
  __int128 v58;
  _BYTE v59[144];
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t (**v64)(llvm::AppleAcceleratorTable::Entry *__hidden);
  __int128 v65;
  _BYTE v66[144];
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 136))
  {
    v10 = 5381;
    if (a3)
    {
      v11 = a3;
      v12 = a2;
      do
      {
        v13 = *v12++;
        v10 = 33 * v10 + v13;
        --v11;
      }
      while (v11);
    }
    v14 = *(_DWORD *)(a1 + 80);
    v15 = *(_DWORD *)(a1 + 84);
    v16 = *(unsigned int *)(a1 + 88) + 20;
    v26 = v10 % v14;
    v31 = v16 + 4 * (v10 % v14);
    v17 = sub_1C6387364(a1 + 8, (unint64_t *)&v31, 0);
    if (v17 < *(_DWORD *)(a1 + 84))
    {
      v18 = v16 + 4 * v14;
      v19 = v18 + (4 * v15);
      v25 = v19;
      v20 = v17;
      v21 = 4 * v17;
      do
      {
        v22 = v18;
        v29 = v19 + (v21 & 0xFFFFFFFC);
        v30 = (v21 & 0xFFFFFFFC) + v18;
        if (sub_1C6387364(a1 + 8, (unint64_t *)&v30, 0) % *(_DWORD *)(a1 + 80) != v26)
          break;
        v28 = 0;
        v28 = sub_1C6387364(a1 + 8, (unint64_t *)&v29, 0);
        RelocatedValue = llvm::DWARFDataExtractor::getRelocatedValue(a1 + 8, 4, &v28, 0, 0);
        if (!RelocatedValue)
          break;
        CStrRef = (const char *)llvm::DataExtractor::getCStrRef((uint64_t *)(a1 + 48), &RelocatedValue, 0);
        if (CStrRef)
        {
          v24 = CStrRef;
          if (a3 == strlen(CStrRef) && (!a3 || !memcmp(a2, v24, a3)))
          {
LABEL_25:
            llvm::AppleAcceleratorTable::ValueIterator::ValueIterator((llvm::AppleAcceleratorTable::ValueIterator *)v53, (const llvm::AppleAcceleratorTable *)a1, v28);
            v46 = 0;
            v48 = 0u;
            memset(v49, 0, sizeof(v49));
            HIDWORD(v48) = 3;
            v47 = off_1E81696A0;
            *(_QWORD *)&v48 = v49;
            v52 = 0;
            v50 = 0;
            v51 = 0;
            sub_1C547BF84(a4, v53, &v46);
            v47 = (uint64_t (**)(llvm::AppleAcceleratorTable::Entry *__hidden))&unk_1E81697C0;
            if ((_BYTE *)v48 != v49)
              free((void *)v48);
            v53[1] = (uint64_t)&unk_1E81697C0;
            v6 = v54;
            if (v54 != &v55)
              goto LABEL_6;
            return;
          }
        }
        else if (!a3)
        {
          goto LABEL_25;
        }
        ++v20;
        v21 += 4;
        v18 = v22;
        v19 = v25;
      }
      while (v20 < *(unsigned int *)(a1 + 84));
    }
    v39 = 0;
    v41 = 0u;
    memset(v42, 0, sizeof(v42));
    v5 = (uint64_t *)v42;
    HIDWORD(v41) = 3;
    v40 = off_1E81696A0;
    *(_QWORD *)&v41 = v42;
    v44 = 0;
    v45 = 0;
    v43 = 0;
    memset(v35, 0, sizeof(v35));
    v32 = 0;
    v34[1] = (void *)0x300000000;
    v33 = off_1E81696A0;
    v34[0] = v35;
    v36 = 0;
    v37 = 0;
    v38 = 0;
    sub_1C547BF84(a4, &v39, &v32);
    v33 = (uint64_t (**)(llvm::AppleAcceleratorTable::Entry *__hidden))&unk_1E81697C0;
    if (v34[0] != v35)
      free(v34[0]);
    v40 = (uint64_t (**)(llvm::AppleAcceleratorTable::Entry *__hidden))&unk_1E81697C0;
    v6 = (uint64_t *)v41;
  }
  else
  {
    v65 = 0u;
    v63 = 0;
    memset(v66, 0, sizeof(v66));
    v5 = (uint64_t *)v66;
    HIDWORD(v65) = 3;
    *(_QWORD *)&v65 = v66;
    v64 = off_1E81696A0;
    v69 = 0;
    v67 = 0;
    v68 = 0;
    v58 = 0u;
    memset(v59, 0, sizeof(v59));
    v56 = 0;
    HIDWORD(v58) = 3;
    *(_QWORD *)&v58 = v59;
    v57 = off_1E81696A0;
    v61 = 0;
    v60 = 0;
    v62 = 0;
    sub_1C547BF84(a4, &v63, &v56);
    v57 = (uint64_t (**)(llvm::AppleAcceleratorTable::Entry *__hidden))&unk_1E81697C0;
    if ((_BYTE *)v58 != v59)
      free((void *)v58);
    v64 = (uint64_t (**)(llvm::AppleAcceleratorTable::Entry *__hidden))&unk_1E81697C0;
    v6 = (uint64_t *)v65;
  }
  if (v6 != v5)
LABEL_6:
    free(v6);
}

void sub_1C547BF84(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6;
  _BYTE *v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  _BYTE v11[97];
  uint64_t v12;
  __int128 v13;
  uint64_t v14;
  uint64_t (**v15)(llvm::AppleAcceleratorTable::Entry *__hidden);
  void *v16;
  uint64_t v17;
  _BYTE v18[144];
  uint64_t v19;
  __int128 v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v14 = *a2;
  v15 = (uint64_t (**)(llvm::AppleAcceleratorTable::Entry *__hidden))&unk_1E81697C0;
  v16 = v18;
  v17 = 0x300000000;
  if (*((_DWORD *)a2 + 6))
    sub_1C624D034((uint64_t)&v16, (uint64_t)(a2 + 2));
  v6 = a2[22];
  v15 = off_1E81696A0;
  v19 = v6;
  v20 = *(_OWORD *)(a2 + 23);
  v8 = *a3;
  v9 = v11;
  v10 = 0x300000000;
  if (*((_DWORD *)a3 + 6))
    sub_1C624D034((uint64_t)&v9, (uint64_t)(a3 + 2));
  v12 = a3[22];
  v13 = *(_OWORD *)(a3 + 23);
  *(_QWORD *)a1 = v14;
  *(_QWORD *)(a1 + 8) = &unk_1E81697C0;
  *(_QWORD *)(a1 + 16) = a1 + 32;
  *(_QWORD *)(a1 + 24) = 0x300000000;
  if ((_DWORD)v17)
    sub_1C624D034(a1 + 16, (uint64_t)&v16);
  *(_QWORD *)(a1 + 216) = a1 + 232;
  *(_QWORD *)(a1 + 8) = off_1E81696A0;
  *(_QWORD *)(a1 + 176) = v19;
  *(_OWORD *)(a1 + 184) = v20;
  *(_QWORD *)(a1 + 200) = v8;
  *(_QWORD *)(a1 + 208) = &unk_1E81697C0;
  *(_QWORD *)(a1 + 224) = 0x300000000;
  if ((_DWORD)v10)
    sub_1C624D034(a1 + 216, (uint64_t)&v9);
  *(_QWORD *)(a1 + 208) = off_1E81696A0;
  v7 = v9;
  *(_QWORD *)(a1 + 376) = v12;
  *(_OWORD *)(a1 + 384) = v13;
  if (v7 != v11)
    free(v7);
  v15 = (uint64_t (**)(llvm::AppleAcceleratorTable::Entry *__hidden))&unk_1E81697C0;
  if (v16 != v18)
    free(v16);
}

char *llvm::DWARFDebugNames::Header::extract@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, unint64_t *a3@<X2>, _QWORD *a4@<X8>)
{
  unint64_t v8;
  char v9;
  unint64_t v10;
  char *v11;
  unint64_t v12;
  _BYTE **v13;
  unint64_t v14;
  char *result;
  char *v16;
  const std::error_category *v17;
  std::string *v18;
  void **v19;
  uint64_t v20;
  char *v21;
  const std::error_category *v22;
  const std::error_category *v23;
  std::string *v24;
  void **v25;
  uint64_t v26;
  char *v27;
  unint64_t v28;
  char *v29;
  char *v30;
  std::string v31;
  uint64_t v32;
  const std::error_category *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char v37;
  uint64_t v38;
  int v39;
  void **p_p;
  void *__p;
  uint64_t v42;
  uint64_t v43;
  const char *v44;
  const char *v45;
  unint64_t v46;
  std::string *v47;
  __int16 v48;

  v8 = *a3;
  v28 = *a3;
  v29 = 0;
  *(_QWORD *)a1 = llvm::DWARFDataExtractor::getInitialLength((uint64_t)a2, &v28, &v29);
  *(_BYTE *)(a1 + 8) = v9;
  *(_WORD *)(a1 + 10) = sub_1C63871E8((uint64_t)a2, &v28, (uint64_t *)&v29);
  llvm::DataExtractor::skip((_BOOL8)a2, &v28, 2);
  *(_DWORD *)(a1 + 12) = sub_1C6387364((uint64_t)a2, &v28, (uint64_t *)&v29);
  *(_DWORD *)(a1 + 16) = sub_1C6387364((uint64_t)a2, &v28, (uint64_t *)&v29);
  *(_DWORD *)(a1 + 20) = sub_1C6387364((uint64_t)a2, &v28, (uint64_t *)&v29);
  *(_DWORD *)(a1 + 24) = sub_1C6387364((uint64_t)a2, &v28, (uint64_t *)&v29);
  *(_DWORD *)(a1 + 28) = sub_1C6387364((uint64_t)a2, &v28, (uint64_t *)&v29);
  *(_DWORD *)(a1 + 32) = sub_1C6387364((uint64_t)a2, &v28, (uint64_t *)&v29);
  v10 = (sub_1C6387364((uint64_t)a2, &v28, (uint64_t *)&v29) + 3) & 0xFFFFFFFC;
  *(_DWORD *)(a1 + 36) = v10;
  v11 = v29;
  if (v29)
  {
    v29 = 0;
    v17 = std::generic_category();
    v30 = v11;
    sub_1C61D2548(&v30, &v31);
    if ((v31.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v18 = &v31;
    else
      v18 = (std::string *)v31.__r_.__value_.__r.__words[0];
    __p = 0;
    v42 = 0;
    v43 = 0;
    LODWORD(v33) = 0;
    v37 = 0;
    v38 = 0;
    v32 = (uint64_t)&unk_1E81A7208;
    p_p = &__p;
    v39 = 0;
    v35 = 0;
    v36 = 0;
    v34 = 0;
    v44 = (const char *)&unk_1E8169880;
    v45 = "parsing .debug_names header at 0x%llx: %s";
    v46 = v8;
    v47 = v18;
    llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v32, (uint64_t)&v44);
    v19 = p_p;
    v20 = operator new();
    v48 = 260;
    v44 = (const char *)v19;
    *(_QWORD *)v20 = off_1E81A0C88;
    llvm::Twine::str((llvm::Twine *)&v44, (_QWORD *)(v20 + 8));
    *(_QWORD *)(v20 + 32) = 92;
    *(_QWORD *)(v20 + 40) = v17;
    *(_BYTE *)(v20 + 48) = 1;
    *a4 = v20;
    v32 = (uint64_t)off_1E81A6E70;
    if (v39 == 1 && v34)
      MEMORY[0x1CAA32F9C](v34, 0x1000C8077774924);
    if (SHIBYTE(v43) < 0)
      operator delete(__p);
    if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v31.__r_.__value_.__l.__data_);
    v21 = v30;
    if (!v30)
      goto LABEL_16;
    goto LABEL_15;
  }
  v12 = v28 + v10;
  if (v12 >= v28 && a2[1] > v12 - 1)
  {
    v13 = (_BYTE **)(a1 + 40);
    v14 = *(_QWORD *)(a1 + 48);
    if (v14 != v10)
    {
      if (v14 <= v10)
      {
        if (*(_QWORD *)(a1 + 56) < v10)
        {
          llvm::SmallVectorBase<unsigned long long>::grow_pod(a1 + 40, (void *)(a1 + 64), v10, 1);
          v14 = *(_QWORD *)(a1 + 48);
        }
        if (v10 != v14)
          bzero(&(*v13)[v14], v10 - v14);
      }
      *(_QWORD *)(a1 + 48) = v10;
      LODWORD(v10) = *(_DWORD *)(a1 + 36);
    }
    result = sub_1C6387118(a2, &v28, *v13, v10, (uint64_t *)&v29);
    v16 = v29;
    *a3 = v28;
    *a4 = v16;
    return result;
  }
  v22 = std::generic_category();
  v32 = 92;
  v33 = v22;
  v44 = "cannot read header augmentation";
  sub_1C5DF1730((_BYTE **)&v44, &v32, &v27);
  v23 = std::generic_category();
  v30 = v27;
  v27 = 0;
  sub_1C61D2548(&v30, &v31);
  if ((v31.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v24 = &v31;
  else
    v24 = (std::string *)v31.__r_.__value_.__r.__words[0];
  __p = 0;
  v42 = 0;
  v43 = 0;
  LODWORD(v33) = 0;
  v37 = 0;
  v38 = 0;
  v32 = (uint64_t)&unk_1E81A7208;
  p_p = &__p;
  v39 = 0;
  v35 = 0;
  v36 = 0;
  v34 = 0;
  v44 = (const char *)&unk_1E8169880;
  v45 = "parsing .debug_names header at 0x%llx: %s";
  v46 = v8;
  v47 = v24;
  llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v32, (uint64_t)&v44);
  v25 = p_p;
  v26 = operator new();
  v48 = 260;
  v44 = (const char *)v25;
  *(_QWORD *)v26 = off_1E81A0C88;
  llvm::Twine::str((llvm::Twine *)&v44, (_QWORD *)(v26 + 8));
  *(_QWORD *)(v26 + 32) = 92;
  *(_QWORD *)(v26 + 40) = v23;
  *(_BYTE *)(v26 + 48) = 1;
  *a4 = v26;
  v32 = (uint64_t)off_1E81A6E70;
  if (v39 == 1 && v34)
    MEMORY[0x1CAA32F9C](v34, 0x1000C8077774924);
  if (SHIBYTE(v43) < 0)
    operator delete(__p);
  if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v31.__r_.__value_.__l.__data_);
  if (v30)
    (*(void (**)(char *))(*(_QWORD *)v30 + 8))(v30);
  v21 = v27;
  if (v27)
LABEL_15:
    (*(void (**)(char *))(*(_QWORD *)v21 + 8))(v21);
LABEL_16:
  result = v29;
  if (v29)
    return (char *)(*(uint64_t (**)(char *))(*(_QWORD *)v29 + 8))(v29);
  return result;
}

uint64_t llvm::DWARFDebugNames::Abbrev::dump(unsigned int *a1, uint64_t a2)
{
  void **v4;
  void *v5;
  llvm::raw_ostream *v6;
  unsigned int *i;
  unsigned int *v8;
  llvm::raw_ostream *v9;
  const char *v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  void *v15;
  unsigned int *v16;
  _QWORD v17[2];
  _QWORD v18[2];
  uint64_t v19;
  void *__p[2];
  char v21;

  v19 = *a1;
  v11 = "Abbreviation 0x";
  v13 = &v19;
  LOWORD(v15) = 3587;
  llvm::Twine::str((llvm::Twine *)&v11, __p);
  if (v21 >= 0)
    v4 = __p;
  else
    v4 = (void **)__p[0];
  if (v21 >= 0)
    v5 = (void *)(v21 & 0x7F);
  else
    v5 = __p[1];
  (*(void (**)(uint64_t, void **, void *))(*(_QWORD *)a2 + 208))(a2, v4, v5);
  if (v21 < 0)
    operator delete(__p[0]);
  v6 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 248))(a2);
  v11 = "Tag: {0}\n";
  v12 = 9;
  v13 = v17;
  v14 = 1;
  v15 = &unk_1E81697E0;
  v16 = a1 + 1;
  v17[0] = &v15;
  sub_1C639D338((uint64_t)&v11, v6);
  v8 = (unsigned int *)*((_QWORD *)a1 + 1);
  for (i = (unsigned int *)*((_QWORD *)a1 + 2); v8 != i; v8 += 2)
  {
    v9 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 248))(a2);
    v11 = "{0}: {1}\n";
    v12 = 9;
    v13 = v18;
    v14 = 2;
    v15 = &unk_1E8169810;
    v16 = v8;
    v17[0] = &unk_1E8169608;
    v17[1] = v8 + 1;
    v18[0] = &v15;
    v18[1] = v17;
    sub_1C639D338((uint64_t)&v11, v9);
  }
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 216))(a2);
}

void llvm::DWARFDebugNames::AbbrevMapInfo::getEmptyKey(uint64_t a1@<X8>)
{
  *(_DWORD *)a1 = 0;
  *(_WORD *)(a1 + 4) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 8) = 0;
}

void llvm::DWARFDebugNames::AbbrevMapInfo::getTombstoneKey(uint64_t a1@<X8>)
{
  *(_DWORD *)a1 = -1;
  *(_WORD *)(a1 + 4) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 8) = 0;
}

void llvm::DWARFDebugNames::NameIndex::extractAttributeEncoding(llvm::DWARFDebugNames::NameIndex *this@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int ULEB128;
  unsigned __int16 v7;
  unint64_t v8;
  unint64_t v9;
  const char *v10;
  uint64_t v11[2];

  if (*a2 >= *((_QWORD *)this + 19))
  {
    v11[0] = 92;
    v11[1] = (uint64_t)std::generic_category();
    v10 = "Incorrectly terminated abbreviation table.";
    sub_1C5DF1730((_BYTE **)&v10, v11, &v9);
    *(_BYTE *)(a3 + 8) |= 1u;
    v8 = v9;
  }
  else
  {
    ULEB128 = llvm::DataExtractor::getULEB128((uint64_t *)(*((_QWORD *)this + 12) + 8), (uint64_t *)a2, 0);
    v7 = llvm::DataExtractor::getULEB128((uint64_t *)(*((_QWORD *)this + 12) + 8), (uint64_t *)a2, 0);
    *(_BYTE *)(a3 + 8) &= ~1u;
    v8 = ULEB128 | ((unint64_t)v7 << 32);
  }
  *(_QWORD *)a3 = v8;
}

void llvm::DWARFDebugNames::NameIndex::extractAttributeEncodings(llvm::DWARFDebugNames::NameIndex *this@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  char *v6;
  char *v7;
  char *v8;
  BOOL v9;
  char *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  int v16;
  __int16 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  llvm::DWARFDebugNames::NameIndex::extractAttributeEncoding(this, a2, (uint64_t)&v20);
  if ((v21 & 1) != 0)
  {
    v19 = v20;
    *(_BYTE *)(a3 + 24) |= 1u;
    *(_QWORD *)a3 = v19;
  }
  else
  {
    v6 = 0;
    v7 = 0;
    v8 = 0;
    do
    {
      if ((_DWORD)v20)
        v9 = 0;
      else
        v9 = WORD2(v20) == 0;
      if (v9)
      {
        *(_BYTE *)(a3 + 24) &= ~1u;
        *(_QWORD *)a3 = v6;
        *(_QWORD *)(a3 + 8) = v7;
        *(_QWORD *)(a3 + 16) = v8;
        return;
      }
      if (v7 >= v8)
      {
        v11 = (v7 - v6) >> 3;
        v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 61)
          abort();
        if ((v8 - v6) >> 2 > v12)
          v12 = (v8 - v6) >> 2;
        if ((unint64_t)(v8 - v6) >= 0x7FFFFFFFFFFFFFF8)
          v13 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v13 = v12;
        if (v13)
        {
          if (v13 >> 61)
            sub_1C4764EE4();
          v14 = (char *)operator new(8 * v13);
        }
        else
        {
          v14 = 0;
        }
        v15 = &v14[8 * v11];
        *(_QWORD *)v15 = v20;
        v10 = v15 + 8;
        while (v7 != v6)
        {
          v16 = *((_DWORD *)v7 - 2);
          v7 -= 8;
          v17 = *((_WORD *)v7 + 2);
          *((_DWORD *)v15 - 2) = v16;
          v15 -= 8;
          *((_WORD *)v15 + 2) = v17;
        }
        v8 = &v14[8 * v13];
        if (v6)
          operator delete(v6);
        v6 = v15;
      }
      else
      {
        *(_QWORD *)v7 = v20;
        v10 = v7 + 8;
        if ((v21 & 1) != 0 && v20)
          (*(void (**)(uint64_t))(*(_QWORD *)v20 + 8))(v20);
      }
      llvm::DWARFDebugNames::NameIndex::extractAttributeEncoding(this, a2, (uint64_t)&v20);
      v7 = v10;
    }
    while ((v21 & 1) == 0);
    v18 = v20;
    *(_BYTE *)(a3 + 24) |= 1u;
    *(_QWORD *)a3 = v18;
    if (v6)
      operator delete(v6);
  }
}

void llvm::DWARFDebugNames::NameIndex::extractAbbrev(llvm::DWARFDebugNames::NameIndex *this@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  int ULEB128;
  __int16 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  __int128 v12;
  uint64_t v13;
  char v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (*a2 >= *((_QWORD *)this + 19))
  {
    *(_QWORD *)&v12 = 92;
    *((_QWORD *)&v12 + 1) = std::generic_category();
    v11 = "Incorrectly terminated abbreviation table.";
    sub_1C5DF1730((_BYTE **)&v11, (uint64_t *)&v12, &v10);
    *(_BYTE *)(a3 + 32) |= 1u;
    v9 = v10;
  }
  else
  {
    ULEB128 = llvm::DataExtractor::getULEB128((uint64_t *)(*((_QWORD *)this + 12) + 8), (uint64_t *)a2, 0);
    if (!ULEB128)
    {
      *(_BYTE *)(a3 + 32) &= ~1u;
      *(_DWORD *)a3 = 0;
      *(_WORD *)(a3 + 4) = 0;
      *(_QWORD *)(a3 + 16) = 0;
      *(_QWORD *)(a3 + 24) = 0;
      *(_QWORD *)(a3 + 8) = 0;
      return;
    }
    v7 = llvm::DataExtractor::getULEB128((uint64_t *)(*((_QWORD *)this + 12) + 8), (uint64_t *)a2, 0);
    llvm::DWARFDebugNames::NameIndex::extractAttributeEncodings(this, a2, (uint64_t)&v12);
    if ((v14 & 1) == 0)
    {
      v8 = v13;
      *(_BYTE *)(a3 + 32) &= ~1u;
      *(_DWORD *)a3 = ULEB128;
      *(_WORD *)(a3 + 4) = v7;
      *(_OWORD *)(a3 + 8) = v12;
      *(_QWORD *)(a3 + 24) = v8;
      return;
    }
    v9 = v12;
    *(_BYTE *)(a3 + 32) |= 1u;
  }
  *(_QWORD *)a3 = v9;
}

void llvm::DWARFDebugNames::NameIndex::extract(llvm::DWARFDebugNames::NameIndex *this@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4;
  char v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char v13;
  unsigned int v14;
  uint64_t v15;
  _DWORD *v16;
  int v17;
  _DWORD *v18;
  int v19;
  BOOL v20;
  int v21;
  uint64_t v22;
  int v23;
  int v24;
  int v25;
  void *v26;
  int v27;
  int v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  int v32;
  BOOL v33;
  int v34;
  int v35;
  int v36;
  uint64_t v37;
  int v38;
  int v39;
  BOOL v40;
  int v41;
  const std::error_category *v42;
  uint64_t v43;
  const std::error_category *v44;
  unint64_t v45;
  const char *v46;
  _BYTE *v47[2];
  uint64_t v48;
  void *__p[2];
  uint64_t v50;
  char v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  v4 = *((_QWORD *)this + 12);
  v45 = *((_QWORD *)this + 13);
  llvm::DWARFDebugNames::Header::extract((uint64_t)this + 24, (_QWORD *)(v4 + 8), &v45, a2);
  if (*a2)
    return;
  if (*((_BYTE *)this + 32))
    v5 = 3;
  else
    v5 = 2;
  v6 = *((_DWORD *)this + 12);
  v7 = v45
     + (*((_DWORD *)this + 9) << v5)
     + (*((_DWORD *)this + 10) << v5)
     + (unint64_t)(8 * *((_DWORD *)this + 11));
  *((_QWORD *)this + 14) = v45;
  *((_QWORD *)this + 15) = v7;
  v8 = v7 + (4 * v6);
  v9 = *((_DWORD *)this + 13);
  v10 = *((unsigned int *)this + 14);
  if (v6)
    v7 = v8 + (4 * v9);
  *((_QWORD *)this + 16) = v8;
  *((_QWORD *)this + 17) = v7;
  v11 = (v9 << v5);
  *((_QWORD *)this + 18) = v7 + v11;
  v45 = v7 + v11 + v11;
  v12 = v45 + v10;
  if (__CFADD__(v45, v10) || *(_QWORD *)(v4 + 16) <= (unint64_t)(v12 - 1))
  {
    v42 = std::generic_category();
    v48 = 92;
    __p[0] = (void *)v42;
    v47[0] = "Section too small: cannot read abbreviations.";
    sub_1C5DF1730(v47, &v48, a2);
    return;
  }
  *((_QWORD *)this + 19) = v12;
  llvm::DWARFDebugNames::NameIndex::extractAbbrev(this, &v45, (uint64_t)&v48);
  v13 = v51;
  while ((v51 & 1) == 0)
  {
    if (!(_DWORD)v48)
    {
      *a2 = 0;
      if ((v13 & 1) == 0)
        goto LABEL_66;
LABEL_69:
      if (v48)
        (*(void (**)(uint64_t))(*(_QWORD *)v48 + 8))(v48);
      return;
    }
    v14 = *((_DWORD *)this + 4);
    if (v14)
    {
      v15 = (v14 - 1) & (37 * (_DWORD)v48);
      v16 = (_DWORD *)(*(_QWORD *)this + 32 * v15);
      v17 = *v16;
      if ((_DWORD)v48 == *v16)
      {
LABEL_65:
        v44 = std::generic_category();
        v47[0] = (_BYTE *)22;
        v47[1] = v44;
        v46 = "Duplicate abbreviation code.";
        sub_1C5DF1730((_BYTE **)&v46, (uint64_t *)v47, a2);
        if ((v13 & 1) != 0)
          goto LABEL_69;
        goto LABEL_66;
      }
      v18 = 0;
      v19 = 1;
      while (v17)
      {
        if (v18)
          v20 = 0;
        else
          v20 = v17 == -1;
        if (v20)
          v18 = v16;
        v21 = v15 + v19++;
        v15 = v21 & (v14 - 1);
        v16 = (_DWORD *)(*(_QWORD *)this + 32 * v15);
        v17 = *v16;
        if ((_DWORD)v48 == *v16)
          goto LABEL_65;
      }
      if (v18)
        v22 = (uint64_t)v18;
      else
        v22 = (uint64_t)v16;
    }
    else
    {
      v22 = 0;
    }
    v23 = *((_DWORD *)this + 2);
    if (4 * v23 + 4 >= 3 * v14)
    {
      v27 = v48;
      sub_1C547F7E8((char **)this, 2 * v14);
      v28 = *((_DWORD *)this + 4) - 1;
      v29 = v28 & (37 * v27);
      v22 = *(_QWORD *)this + 32 * v29;
      v30 = *(_DWORD *)v22;
      if (v27 == *(_DWORD *)v22)
        goto LABEL_48;
      v31 = 0;
      v32 = 1;
      while (v30)
      {
        if (v31)
          v33 = 0;
        else
          v33 = v30 == -1;
        if (v33)
          v31 = v22;
        v34 = v29 + v32++;
        v29 = v34 & v28;
        v22 = *(_QWORD *)this + 32 * v29;
        v30 = *(_DWORD *)v22;
        if (v27 == *(_DWORD *)v22)
          goto LABEL_48;
      }
    }
    else
    {
      if (v14 + ~v23 - *((_DWORD *)this + 3) > v14 >> 3)
        goto LABEL_25;
      v35 = v48;
      sub_1C547F7E8((char **)this, v14);
      v36 = *((_DWORD *)this + 4) - 1;
      v37 = v36 & (37 * v35);
      v22 = *(_QWORD *)this + 32 * v37;
      v38 = *(_DWORD *)v22;
      if (v35 == *(_DWORD *)v22)
      {
LABEL_48:
        ++*((_DWORD *)this + 2);
LABEL_26:
        --*((_DWORD *)this + 3);
        goto LABEL_27;
      }
      v31 = 0;
      v39 = 1;
      while (v38)
      {
        if (v31)
          v40 = 0;
        else
          v40 = v38 == -1;
        if (v40)
          v31 = v22;
        v41 = v37 + v39++;
        v37 = v41 & v36;
        v22 = *(_QWORD *)this + 32 * v37;
        v38 = *(_DWORD *)v22;
        if (v35 == *(_DWORD *)v22)
          goto LABEL_48;
      }
    }
    if (v31)
      v22 = v31;
LABEL_25:
    v24 = *(_DWORD *)v22;
    ++*((_DWORD *)this + 2);
    if (v24)
      goto LABEL_26;
LABEL_27:
    v25 = v48;
    *(_WORD *)(v22 + 4) = WORD2(v48);
    *(_DWORD *)v22 = v25;
    v26 = *(void **)(v22 + 8);
    if (v26)
    {
      *(_QWORD *)(v22 + 16) = v26;
      operator delete(v26);
      *(_QWORD *)(v22 + 8) = 0;
      *(_QWORD *)(v22 + 16) = 0;
      *(_QWORD *)(v22 + 24) = 0;
    }
    *(_OWORD *)(v22 + 8) = *(_OWORD *)__p;
    *(_QWORD *)(v22 + 24) = v50;
    if ((v51 & 1) != 0 && v48)
      (*(void (**)(uint64_t))(*(_QWORD *)v48 + 8))(v48);
    llvm::DWARFDebugNames::NameIndex::extractAbbrev(this, &v45, (uint64_t)&v48);
    v13 = v51;
  }
  v43 = v48;
  v48 = 0;
  *a2 = v43;
  if ((v13 & 1) != 0)
    goto LABEL_69;
LABEL_66:
  if (__p[0])
    operator delete(__p[0]);
}

uint64_t llvm::DWARFDebugNames::Entry::lookup@<X0>(uint64_t result@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v3;
  _DWORD *v4;
  _DWORD *v5;
  _OWORD *v6;
  char v7;
  __int128 v8;

  v3 = *(_QWORD *)(result + 176);
  v4 = *(_DWORD **)(v3 + 8);
  v5 = *(_DWORD **)(v3 + 16);
  if (v4 == v5)
  {
LABEL_5:
    v7 = 0;
    *(_BYTE *)a3 = 0;
  }
  else
  {
    v6 = *(_OWORD **)(result + 8);
    while (*v4 != a2)
    {
      v4 += 2;
      v6 += 3;
      if (v4 == v5)
        goto LABEL_5;
    }
    v8 = v6[1];
    *(_OWORD *)a3 = *v6;
    *(_OWORD *)(a3 + 16) = v8;
    *(_OWORD *)(a3 + 32) = v6[2];
    v7 = 1;
  }
  *(_BYTE *)(a3 + 48) = v7;
  return result;
}

uint64_t llvm::DWARFDebugNames::Entry::getDIEUnitOffset(llvm::DWARFDebugNames::Entry *this)
{
  uint64_t v1;
  _DWORD *v2;
  _DWORD *v3;
  uint64_t *v4;
  unsigned int v5;
  uint64_t result;

  v1 = *((_QWORD *)this + 22);
  v2 = *(_DWORD **)(v1 + 8);
  v3 = *(_DWORD **)(v1 + 16);
  if (v2 == v3)
    return 0;
  v4 = (uint64_t *)(*((_QWORD *)this + 1) + 8);
  while (*v2 != 3)
  {
    v2 += 2;
    v4 += 6;
    if (v2 == v3)
      return 0;
  }
  v5 = *((unsigned __int16 *)v4 - 4);
  result = *v4;
  if (v5 <= 0x2D)
  {
    if (((0x11103F0000uLL >> v5) & 1) != 0)
      return result;
    return 0;
  }
  if (v5 != 7968)
    return 0;
  return result;
}

unint64_t llvm::DWARFDebugNames::Entry::getCUIndex(llvm::DWARFDebugNames::Entry *this)
{
  uint64_t v1;
  _DWORD *v2;
  _DWORD *v3;
  _OWORD *v4;
  __int128 v7;
  _OWORD v8[3];
  char v9;

  v1 = *((_QWORD *)this + 22);
  v2 = *(_DWORD **)(v1 + 8);
  v3 = *(_DWORD **)(v1 + 16);
  if (v2 == v3)
    return 0;
  v4 = (_OWORD *)*((_QWORD *)this + 1);
  while (*v2 != 1)
  {
    v2 += 2;
    v4 += 3;
    if (v2 == v3)
      return 0;
  }
  v7 = v4[1];
  v8[0] = *v4;
  v8[1] = v7;
  v8[2] = v4[2];
  v9 = 1;
  return llvm::DWARFFormValue::getAsUnsignedConstant((llvm::DWARFFormValue *)v8);
}

unint64_t llvm::DWARFDebugNames::Entry::getCUOffset(llvm::DWARFDebugNames::Entry *this)
{
  unint64_t CUIndex;
  char v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v8;
  char v9;
  unint64_t RelocatedValue;
  unint64_t v11;

  CUIndex = llvm::DWARFDebugNames::Entry::getCUIndex(this);
  if (v3 && (v4 = *((_QWORD *)this + 21), CUIndex < *(unsigned int *)(v4 + 36)))
  {
    if (*(_BYTE *)(v4 + 32))
      v8 = 8;
    else
      v8 = 4;
    if (*(_BYTE *)(v4 + 32))
      v9 = 3;
    else
      v9 = 2;
    v11 = *(_QWORD *)(v4 + 112) + ((_DWORD)CUIndex << v9);
    RelocatedValue = llvm::DWARFDataExtractor::getRelocatedValue(*(_QWORD *)(v4 + 96) + 8, v8, &v11, 0, 0);
    v6 = RelocatedValue & 0xFFFFFFFFFFFFFF00;
    v5 = RelocatedValue;
  }
  else
  {
    v5 = 0;
    v6 = 0;
  }
  return v6 | v5;
}

unint64_t llvm::DWARFDebugNames::NameIndex::getCUOffset(llvm::DWARFDebugNames::NameIndex *this, int a2)
{
  int v2;
  char v3;
  unint64_t v5;

  if (*((_BYTE *)this + 32))
    v2 = 8;
  else
    v2 = 4;
  if (*((_BYTE *)this + 32))
    v3 = 3;
  else
    v3 = 2;
  v5 = *((_QWORD *)this + 14) + (a2 << v3);
  return llvm::DWARFDataExtractor::getRelocatedValue(*((_QWORD *)this + 12) + 8, v2, &v5, 0, 0);
}

unint64_t llvm::DWARFDebugNames::NameIndex::getLocalTUOffset(llvm::DWARFDebugNames::NameIndex *this, int a2)
{
  int v2;
  char v3;
  unint64_t v5;

  if (*((_BYTE *)this + 32))
    v2 = 8;
  else
    v2 = 4;
  if (*((_BYTE *)this + 32))
    v3 = 3;
  else
    v3 = 2;
  v5 = *((_QWORD *)this + 14) + ((*((_DWORD *)this + 9) + a2) << v3);
  return llvm::DWARFDataExtractor::getRelocatedValue(*((_QWORD *)this + 12) + 8, v2, &v5, 0, 0);
}

unint64_t llvm::DWARFDebugNames::NameIndex::getForeignTUSignature(llvm::DWARFDebugNames::NameIndex *this, int a2)
{
  char v2;
  unint64_t v4;

  if (*((_BYTE *)this + 32))
    v2 = 3;
  else
    v2 = 2;
  v4 = *((_QWORD *)this + 14)
     + (8 * a2)
     + ((*((_DWORD *)this + 10) + *((_DWORD *)this + 9)) << v2);
  return sub_1C63873F8(*((_QWORD *)this + 12) + 8, &v4, 0);
}

void llvm::DWARFDebugNames::NameIndex::getEntry(llvm::DWARFDebugNames::NameIndex *this@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4;
  unint64_t v6;
  uint64_t *v7;
  int ULEB128;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int *v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  _QWORD *v17;
  unsigned __int16 *v18;
  unint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  _BYTE *v26[2];
  uint64_t v27;
  void *v28;
  unsigned int v29;
  _OWORD v30[10];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v4 = *((_QWORD *)this + 12);
  if (*(_QWORD *)(v4 + 16) <= *a2)
  {
    v27 = 92;
    v28 = (void *)std::generic_category();
    v26[0] = "Incorrectly terminated entry list.";
    sub_1C5DF1730(v26, &v27, &v24);
    *(_BYTE *)(a3 + 184) |= 1u;
    v16 = v24;
LABEL_14:
    *(_QWORD *)a3 = v16;
    return;
  }
  v6 = (unint64_t)this;
  v7 = (uint64_t *)(v4 + 8);
  ULEB128 = llvm::DataExtractor::getULEB128((uint64_t *)(v4 + 8), (uint64_t *)a2, 0);
  if (!ULEB128)
  {
    v17 = (_QWORD *)operator new();
    *v17 = &off_1E8169770;
    *(_BYTE *)(a3 + 184) |= 1u;
    *(_QWORD *)a3 = v17;
    return;
  }
  v9 = *(_QWORD *)v6;
  v10 = *(unsigned int *)(v6 + 16);
  if ((_DWORD)v10)
  {
    v11 = ((_DWORD)v10 - 1) & (37 * ULEB128);
    v12 = (int *)(v9 + 32 * v11);
    v13 = *v12;
    if (*v12 == ULEB128)
      goto LABEL_12;
    v14 = 1;
    while (v13)
    {
      v15 = v11 + v14++;
      v11 = v15 & (v10 - 1);
      v13 = *(_DWORD *)(v9 + 32 * v11);
      if (v13 == ULEB128)
      {
        v12 = (int *)(v9 + 32 * v11);
        goto LABEL_12;
      }
    }
  }
  v12 = (int *)(v9 + 32 * v10);
LABEL_12:
  if ((int *)(v9 + 32 * v10) == v12)
  {
    v27 = 22;
    v28 = (void *)std::generic_category();
    v26[0] = "Invalid abbreviation.";
    sub_1C5DF1730(v26, &v27, &v23);
    *(_BYTE *)(a3 + 184) |= 1u;
    v16 = v23;
    goto LABEL_14;
  }
  llvm::DWARFDebugNames::Entry::Entry(&v27, v6, (uint64_t)v12);
  if (v29)
  {
    v18 = (unsigned __int16 *)v28;
    v19 = *(unsigned __int16 *)(v6 + 34) | ((unint64_t)*(unsigned __int8 *)(v6 + 32) << 24);
    v20 = 48 * v29;
    while (1)
    {
      v6 = v19 | v6 & 0xFFFF000000000000;
      if ((llvm::DWARFFormValue::extractValue(v18, v7, (uint64_t *)a2, v6, 0, 0) & 1) == 0)
        break;
      v18 += 24;
      v20 -= 48;
      if (!v20)
      {
        v21 = v29 == 0;
        goto LABEL_22;
      }
    }
    v26[0] = (_BYTE *)5;
    v26[1] = std::generic_category();
    v25 = "Error extracting index attribute values.";
    sub_1C5DF1730((_BYTE **)&v25, (uint64_t *)v26, &v22);
    *(_BYTE *)(a3 + 184) |= 1u;
    *(_QWORD *)a3 = v22;
    v22 = 0;
  }
  else
  {
    v21 = 1;
LABEL_22:
    *(_BYTE *)(a3 + 184) &= ~1u;
    *(_QWORD *)a3 = &unk_1E81697C0;
    *(_QWORD *)(a3 + 8) = a3 + 24;
    *(_QWORD *)(a3 + 16) = 0x300000000;
    if (!v21)
      sub_1C624D034(a3 + 8, (uint64_t)&v28);
    *(_QWORD *)a3 = &off_1E81696C0;
    *(_OWORD *)(a3 + 168) = v30[9];
  }
  v27 = (uint64_t)&unk_1E81697C0;
  if (v28 != v30)
    free(v28);
}

__n128 llvm::DWARFDebugNames::NameIndex::getNameTableEntry@<Q0>(llvm::DWARFDebugNames::NameIndex *this@<X0>, unsigned __int32 a2@<W1>, __n128 *a3@<X8>)
{
  int v6;
  char v7;
  uint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t RelocatedValue;
  unint64_t v12;
  __n128 *v13;
  __n128 result;
  unint64_t v15;
  unint64_t v16;

  if (*((_BYTE *)this + 32))
    v6 = 8;
  else
    v6 = 4;
  if (*((_BYTE *)this + 32))
    v7 = 3;
  else
    v7 = 2;
  v8 = (a2 - 1) << v7;
  v9 = *((_QWORD *)this + 17) + v8;
  v15 = *((_QWORD *)this + 18) + v8;
  v16 = v9;
  v10 = (_QWORD *)(*((_QWORD *)this + 12) + 8);
  RelocatedValue = llvm::DWARFDataExtractor::getRelocatedValue((uint64_t)v10, v6, &v16, 0, 0);
  v12 = *((_QWORD *)this + 19) + llvm::DataExtractor::getUnsigned(v10, &v15, v6, 0);
  v13 = (__n128 *)*((_QWORD *)this + 12);
  result = v13[3];
  *a3 = result;
  a3[1].n128_u64[0] = v13[4].n128_u64[0];
  a3[1].n128_u32[2] = a2;
  a3[2].n128_u64[0] = RelocatedValue;
  a3[2].n128_u64[1] = v12;
  return result;
}

uint64_t llvm::DWARFDebugNames::NameIndex::getBucketArrayEntry(llvm::DWARFDebugNames::NameIndex *this, int a2)
{
  unint64_t v3;

  v3 = *((_QWORD *)this + 15) + (4 * a2);
  return sub_1C6387364(*((_QWORD *)this + 12) + 8, &v3, 0);
}

uint64_t llvm::DWARFDebugNames::NameIndex::getHashArrayEntry(llvm::DWARFDebugNames::NameIndex *this, int a2)
{
  unint64_t v3;

  v3 = *((_QWORD *)this + 16) + (4 * a2 - 4);
  return sub_1C6387364(*((_QWORD *)this + 12) + 8, &v3, 0);
}

BOOL llvm::DWARFDebugNames::NameIndex::dumpEntry(llvm::DWARFDebugNames::NameIndex *a1, uint64_t a2, unint64_t *a3)
{
  char v4;
  _QWORD *v5;
  uint64_t *v6;
  uint64_t *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  void (*v11)(void);
  _QWORD *v12;
  void **v14;
  void *v15;
  _QWORD v16[4];
  __int16 v17;
  void *__p[2];
  char v19;
  uint64_t v20;
  unint64_t v21;
  void *v22;
  uint64_t v23;
  char *v24;
  _QWORD *v25;
  void *v26;
  uint64_t v27;
  char v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v21 = *a3;
  llvm::DWARFDebugNames::NameIndex::getEntry(a1, a3, (uint64_t)&v25);
  v4 = v28;
  if ((v28 & 1) != 0)
  {
    v5 = v25;
    v25 = 0;
    v20 = a2;
    if (!v5)
    {
      v22 = 0;
      goto LABEL_20;
    }
    if ((*(unsigned int (**)(_QWORD *, void *))(*v5 + 48))(v5, &llvm::ErrorList::ID))
    {
      v6 = (uint64_t *)v5[1];
      v7 = (uint64_t *)v5[2];
      if (v6 == v7)
      {
        v8 = 0;
      }
      else
      {
        v8 = 0;
        do
        {
          __p[0] = v8;
          v9 = *v6;
          *v6 = 0;
          v23 = v9;
          sub_1C547FA20(&v24, &v23, &v20);
          sub_1C6174794((char **)__p, &v24, v16);
          v8 = (void *)v16[0];
          v16[0] = 0;
          if (v24)
            (*(void (**)(char *))(*(_QWORD *)v24 + 8))(v24);
          v10 = v23;
          v23 = 0;
          if (v10)
            (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
          if (__p[0])
            (*(void (**)(void *))(*(_QWORD *)__p[0] + 8))(__p[0]);
          ++v6;
        }
        while (v6 != v7);
      }
      v22 = v8;
      v11 = *(void (**)(void))(*v5 + 8);
    }
    else
    {
      v16[0] = v5;
      sub_1C547FA20(&v22, v16, &v20);
      if (!v16[0])
        goto LABEL_20;
      v11 = *(void (**)(void))(*(_QWORD *)v16[0] + 8);
    }
  }
  else
  {
    v16[0] = "Entry @ 0x";
    v16[2] = &v21;
    v17 = 3587;
    llvm::Twine::str((llvm::Twine *)v16, __p);
    if (v19 >= 0)
      v14 = __p;
    else
      v14 = (void **)__p[0];
    if (v19 >= 0)
      v15 = (void *)(v19 & 0x7F);
    else
      v15 = __p[1];
    (*(void (**)(uint64_t, void **, void *))(*(_QWORD *)a2 + 208))(a2, v14, v15);
    if (v19 < 0)
      operator delete(__p[0]);
    llvm::DWARFDebugNames::Entry::dump((uint64_t)&v25, a2);
    v11 = *(void (**)(void))(*(_QWORD *)a2 + 216);
  }
  v11();
LABEL_20:
  if ((v28 & 1) != 0)
  {
    v12 = v25;
    v25 = 0;
    if (v12)
      (*(void (**)(_QWORD *))(*v12 + 8))(v12);
  }
  else
  {
    v25 = &unk_1E81697C0;
    if (v26 != &v27)
      free(v26);
  }
  return (v4 & 1) == 0;
}

uint64_t llvm::DWARFDebugNames::NameIndex::dumpName(llvm::DWARFDebugNames::NameIndex *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  void **v9;
  void *v10;
  llvm::raw_ostream *v11;
  uint64_t v12;
  llvm::raw_ostream *v13;
  llvm::raw_ostream *v14;
  _WORD *v15;
  const char *CStrRef;
  _WORD *v17;
  const char *v18;
  size_t v19;
  size_t v20;
  unint64_t v22[2];
  uint64_t v23;
  __int16 v24;
  void *__p[2];
  char v26;

  v8 = *(unsigned int *)(a3 + 24);
  v22[0] = (unint64_t)"Name ";
  v23 = v8;
  v24 = 2051;
  llvm::Twine::str((llvm::Twine *)v22, __p);
  if (v26 >= 0)
    v9 = __p;
  else
    v9 = (void **)__p[0];
  if (v26 >= 0)
    v10 = (void *)(v26 & 0x7F);
  else
    v10 = __p[1];
  (*(void (**)(uint64_t, void **, void *))(*(_QWORD *)a2 + 208))(a2, v9, v10);
  if (v26 < 0)
    operator delete(__p[0]);
  if ((a4 & 0xFF00000000) != 0)
    (*(void (**)(uint64_t, const char *, uint64_t, _QWORD))(*(_QWORD *)a2 + 296))(a2, "Hash", 4, a4);
  v11 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 248))(a2);
  v12 = *(_QWORD *)(a3 + 32);
  v22[0] = (unint64_t)&unk_1E8133270;
  v22[1] = (unint64_t)"String: 0x%08llx";
  v23 = v12;
  llvm::raw_ostream::operator<<(v11, (uint64_t)v22);
  v13 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 256))(a2);
  v14 = v13;
  v15 = (_WORD *)*((_QWORD *)v13 + 4);
  if (*((_QWORD *)v13 + 3) - (_QWORD)v15 > 1uLL)
  {
    *v15 = 8736;
    *((_QWORD *)v13 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(v13, " \"", 2uLL);
  }
  v22[0] = *(_QWORD *)(a3 + 32);
  CStrRef = (const char *)llvm::DataExtractor::getCStrRef((uint64_t *)a3, v22, 0);
  v17 = (_WORD *)*((_QWORD *)v14 + 4);
  if (CStrRef)
  {
    v18 = CStrRef;
    v19 = strlen(CStrRef);
    v20 = v19;
    if (v19 <= *((_QWORD *)v14 + 3) - (_QWORD)v17)
    {
      if (v19)
      {
        memcpy(v17, v18, v19);
        v17 = (_WORD *)(*((_QWORD *)v14 + 4) + v20);
        *((_QWORD *)v14 + 4) = v17;
      }
    }
    else
    {
      llvm::raw_ostream::write(v14, v18, v19);
      v17 = (_WORD *)*((_QWORD *)v14 + 4);
    }
  }
  if (*((_QWORD *)v14 + 3) - (_QWORD)v17 > 1uLL)
  {
    *v17 = 2594;
    *((_QWORD *)v14 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(v14, "\"\n", 2uLL);
  }
  v22[0] = *(_QWORD *)(a3 + 40);
  while (llvm::DWARFDebugNames::NameIndex::dumpEntry(a1, a2, v22))
    ;
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 216))(a2);
}

uint64_t llvm::DWARFDebugNames::NameIndex::dumpCUs(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  llvm::raw_ostream *v5;
  int v6;
  char v7;
  unint64_t RelocatedValue;
  unint64_t v10[2];
  unsigned int v11;
  unint64_t v12;

  (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a2 + 232))(a2, "Compilation Unit offsets", 24);
  if (*(_DWORD *)(a1 + 36))
  {
    v4 = 0;
    do
    {
      v5 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 248))(a2);
      if (*(_BYTE *)(a1 + 32))
        v6 = 8;
      else
        v6 = 4;
      if (*(_BYTE *)(a1 + 32))
        v7 = 3;
      else
        v7 = 2;
      v10[0] = *(_QWORD *)(a1 + 112) + (v4 << v7);
      RelocatedValue = llvm::DWARFDataExtractor::getRelocatedValue(*(_QWORD *)(a1 + 96) + 8, v6, v10, 0, 0);
      v10[0] = (unint64_t)&unk_1E8169860;
      v10[1] = (unint64_t)"CU[%u]: 0x%08llx\n";
      v11 = v4;
      v12 = RelocatedValue;
      llvm::raw_ostream::operator<<(v5, (uint64_t)v10);
      ++v4;
    }
    while (v4 < *(_DWORD *)(a1 + 36));
  }
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 240))(a2);
}

uint64_t llvm::DWARFDebugNames::NameIndex::dumpLocalTUs(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  unsigned int v4;
  llvm::raw_ostream *v5;
  int v6;
  char v7;
  unint64_t RelocatedValue;
  unint64_t v9[2];
  unsigned int v10;
  unint64_t v11;

  if (*(_DWORD *)(result + 40))
  {
    v3 = result;
    (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a2 + 232))(a2, "Local Type Unit offsets", 23);
    if (*(_DWORD *)(v3 + 40))
    {
      v4 = 0;
      do
      {
        v5 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 248))(a2);
        if (*(_BYTE *)(v3 + 32))
          v6 = 8;
        else
          v6 = 4;
        if (*(_BYTE *)(v3 + 32))
          v7 = 3;
        else
          v7 = 2;
        v9[0] = *(_QWORD *)(v3 + 112) + ((v4 + *(_DWORD *)(v3 + 36)) << v7);
        RelocatedValue = llvm::DWARFDataExtractor::getRelocatedValue(*(_QWORD *)(v3 + 96) + 8, v6, v9, 0, 0);
        v9[0] = (unint64_t)&unk_1E8169860;
        v9[1] = (unint64_t)"LocalTU[%u]: 0x%08llx\n";
        v10 = v4;
        v11 = RelocatedValue;
        llvm::raw_ostream::operator<<(v5, (uint64_t)v9);
        ++v4;
      }
      while (v4 < *(_DWORD *)(v3 + 40));
    }
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 240))(a2);
  }
  return result;
}

uint64_t llvm::DWARFDebugNames::NameIndex::dumpAbbreviations(uint64_t a1, uint64_t a2)
{
  unsigned int *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  unsigned int *v9;
  unsigned int *v10;

  (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a2 + 232))(a2, "Abbreviations", 13);
  v4 = *(unsigned int **)a1;
  v5 = *(unsigned int *)(a1 + 16);
  v6 = *(_QWORD *)a1 + 32 * v5;
  if (*(_DWORD *)(a1 + 8))
  {
    if ((_DWORD)v5)
    {
      v7 = 32 * v5;
      v8 = *(unsigned int **)a1;
      while (*v8 + 1 <= 1)
      {
        v8 += 8;
        v7 -= 32;
        if (!v7)
          goto LABEL_6;
      }
    }
    else
    {
      v8 = *(unsigned int **)a1;
    }
  }
  else
  {
LABEL_6:
    v8 = (unsigned int *)v6;
  }
  v9 = &v4[8 * v5];
LABEL_9:
  while (v8 != v9)
  {
    llvm::DWARFDebugNames::Abbrev::dump(v8, a2);
    v10 = v8 + 8;
    v8 = (unsigned int *)v6;
    if (v10 != (unsigned int *)v6)
    {
      v8 = v10;
      while (*v8 + 1 <= 1)
      {
        v8 += 8;
        if (v8 == (unsigned int *)v6)
        {
          v8 = (unsigned int *)v6;
          goto LABEL_9;
        }
      }
    }
  }
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 240))(a2);
}

uint64_t llvm::DWARFDebugNames::NameIndex::dumpBucket(uint64_t a1, uint64_t a2, unsigned int a3)
{
  void **v6;
  void *v7;
  unsigned __int32 v8;
  unsigned __int32 v9;
  const char *v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  __n128 v16;
  uint64_t v17;
  __int16 v18;
  void *__p[2];
  char v20;

  v16.n128_u64[0] = (unint64_t)"Bucket ";
  v17 = a3;
  v18 = 2051;
  llvm::Twine::str((llvm::Twine *)&v16, __p);
  if (v20 >= 0)
    v6 = __p;
  else
    v6 = (void **)__p[0];
  if (v20 >= 0)
    v7 = (void *)(v20 & 0x7F);
  else
    v7 = __p[1];
  (*(void (**)(uint64_t, void **, void *))(*(_QWORD *)a2 + 232))(a2, v6, v7);
  if (v20 < 0)
    operator delete(__p[0]);
  v16.n128_u64[0] = *(_QWORD *)(a1 + 120) + 4 * a3;
  v8 = sub_1C6387364(*(_QWORD *)(a1 + 96) + 8, v16.n128_u64, 0);
  if (!v8)
  {
    v10 = "EMPTY";
    v11 = 5;
    goto LABEL_13;
  }
  v9 = v8;
  if (v8 > *(_DWORD *)(a1 + 52))
  {
    v10 = "Name index is invalid";
    v11 = 21;
LABEL_13:
    (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a2 + 184))(a2, v10, v11);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 240))(a2);
  }
  v12 = 4 * v8 - 4;
  do
  {
    v16.n128_u64[0] = *(_QWORD *)(a1 + 128) + v12;
    v13 = sub_1C6387364(*(_QWORD *)(a1 + 96) + 8, v16.n128_u64, 0);
    if (v13 % *(_DWORD *)(a1 + 48) != a3)
      break;
    v14 = v13;
    llvm::DWARFDebugNames::NameIndex::getNameTableEntry((llvm::DWARFDebugNames::NameIndex *)a1, v9, &v16);
    llvm::DWARFDebugNames::NameIndex::dumpName((llvm::DWARFDebugNames::NameIndex *)a1, a2, (uint64_t)&v16, v14 | 0x100000000);
    ++v9;
    v12 += 4;
  }
  while (v9 <= *(_DWORD *)(a1 + 52));
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 240))(a2);
}

uint64_t llvm::DWARFDebugNames::NameIndex::dump(llvm::DWARFDebugNames::NameIndex *a1, uint64_t a2)
{
  void **v4;
  void *v5;
  unsigned int v6;
  llvm::raw_ostream *v7;
  void *v8;
  int v9;
  int v10;
  __n128 v12;
  _DWORD *v13;
  __int16 v14;
  void *__p[2];
  char v16;

  v12.n128_u64[0] = (unint64_t)"Name Index @ 0x";
  v13 = (_DWORD *)((char *)a1 + 104);
  v14 = 3587;
  llvm::Twine::str((llvm::Twine *)&v12, __p);
  if (v16 >= 0)
    v4 = __p;
  else
    v4 = (void **)__p[0];
  if (v16 >= 0)
    v5 = (void *)(v16 & 0x7F);
  else
    v5 = __p[1];
  (*(void (**)(uint64_t, void **, void *))(*(_QWORD *)a2 + 208))(a2, v4, v5);
  if (v16 < 0)
    operator delete(__p[0]);
  llvm::DWARFDebugNames::Header::dump((uint64_t)a1 + 24, a2);
  llvm::DWARFDebugNames::NameIndex::dumpCUs((uint64_t)a1, a2);
  llvm::DWARFDebugNames::NameIndex::dumpLocalTUs((uint64_t)a1, a2);
  llvm::DWARFDebugNames::NameIndex::dumpForeignTUs((uint64_t)a1, a2);
  llvm::DWARFDebugNames::NameIndex::dumpAbbreviations((uint64_t)a1, a2);
  if (*((_DWORD *)a1 + 12))
  {
    v6 = 0;
    do
      llvm::DWARFDebugNames::NameIndex::dumpBucket((uint64_t)a1, a2, v6++);
    while (v6 < *((_DWORD *)a1 + 12));
  }
  else
  {
    v7 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 248))(a2);
    v8 = (void *)*((_QWORD *)v7 + 4);
    if (*((_QWORD *)v7 + 3) - (_QWORD)v8 > 0x16uLL)
    {
      qmemcpy(v8, "Hash table not present\n", 23);
      *((_QWORD *)v7 + 4) += 23;
    }
    else
    {
      llvm::raw_ostream::write(v7, "Hash table not present\n", 0x17uLL);
    }
    v9 = *((_DWORD *)a1 + 13);
    if (v9)
    {
      v10 = 0;
      do
      {
        llvm::DWARFDebugNames::NameIndex::getNameTableEntry(a1, ++v10, &v12);
        llvm::DWARFDebugNames::NameIndex::dumpName(a1, a2, (uint64_t)&v12, 0);
      }
      while (v9 != v10);
    }
  }
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 216))(a2);
}

uint64_t *llvm::DWARFDebugNames::extract@<X0>(uint64_t *this@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v2;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  _OWORD *v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24[2];
  int v25;
  uint64_t v26;
  char v27;
  void *v28;
  __int128 v29;
  _QWORD v30[2];
  unint64_t v31;
  uint64_t v32;

  v2 = (uint64_t)this;
  v4 = 0;
  v32 = *MEMORY[0x1E0C80C00];
  v23 = (uint64_t)(this + 9);
  while (*(_QWORD *)(v2 + 16) > v4)
  {
    v24[0] = 0;
    v24[1] = 0;
    v25 = 0;
    v28 = v30;
    v29 = xmmword_1C6464ED0;
    v30[1] = v2;
    v31 = v4;
    llvm::DWARFDebugNames::NameIndex::extract((llvm::DWARFDebugNames::NameIndex *)v24, a2);
    v5 = *a2;
    if (!*a2)
    {
      v6 = v31;
      if (v27)
        v7 = 12;
      else
        v7 = 4;
      v8 = v26;
      v9 = sub_1C547FAE0(v23, (unint64_t)v24, 1);
      v10 = *(_QWORD *)(v2 + 72);
      v11 = *(_DWORD *)(v2 + 80);
      v12 = v10 + 160 * v11;
      *(_DWORD *)(v12 + 16) = 0;
      *(_QWORD *)v12 = 0;
      *(_QWORD *)(v12 + 8) = 0;
      *(_QWORD *)v12 = *(_QWORD *)v9;
      *(_QWORD *)v9 = 0;
      *(_DWORD *)(v12 + 8) = *(_DWORD *)(v9 + 8);
      *(_DWORD *)(v9 + 8) = 0;
      v13 = *(_DWORD *)(v12 + 12);
      *(_DWORD *)(v12 + 12) = *(_DWORD *)(v9 + 12);
      *(_DWORD *)(v9 + 12) = v13;
      v14 = *(_DWORD *)(v12 + 16);
      *(_DWORD *)(v12 + 16) = *(_DWORD *)(v9 + 16);
      *(_DWORD *)(v9 + 16) = v14;
      v15 = *(_QWORD *)(v9 + 56);
      v16 = *(_OWORD *)(v9 + 40);
      v17 = *(_OWORD *)(v9 + 24);
      *(_QWORD *)(v12 + 64) = v12 + 88;
      v18 = v12 + 64;
      *(_OWORD *)(v18 - 40) = v17;
      *(_OWORD *)(v18 - 24) = v16;
      *(_QWORD *)(v18 - 8) = v15;
      *(_OWORD *)(v18 + 8) = xmmword_1C6464ED0;
      if (*(_QWORD *)(v9 + 72))
        sub_1C4FE6ED8(v18, v9 + 64);
      v4 = v8 + v6 + v7;
      v19 = (_OWORD *)(v10 + 160 * v11);
      v20 = *(_OWORD *)(v9 + 96);
      v21 = *(_OWORD *)(v9 + 112);
      v22 = *(_OWORD *)(v9 + 144);
      v19[8] = *(_OWORD *)(v9 + 128);
      v19[9] = v22;
      v19[6] = v20;
      v19[7] = v21;
      ++*(_DWORD *)(v2 + 80);
    }
    if (v28 != v30)
      free(v28);
    this = sub_1C547F634(v24);
    if (v5)
      return this;
  }
  *a2 = 0;
  return this;
}

void llvm::DWARFDebugNames::NameIndex::equal_range(uint64_t a1@<X0>, const void *a2@<X1>, size_t a3@<X2>, uint64_t a4@<X8>)
{
  __int128 v5;
  void *v6[2];
  _OWORD v7[10];
  __int128 v8;
  void *__p[2];
  __int128 v10;
  uint64_t v11;
  uint64_t v12[3];
  void *v13;
  _BYTE v14[176];
  void *v15;
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  llvm::DWARFDebugNames::ValueIterator::ValueIterator((uint64_t)v12, a1, a2, a3);
  v11 = 0;
  *(_OWORD *)__p = 0u;
  v10 = 0u;
  v8 = 0u;
  *(_OWORD *)v6 = 0u;
  memset(v7, 0, sizeof(v7));
  v5 = 0u;
  sub_1C547E58C(v12, (uint64_t *)&v5, a4);
  if (SHIBYTE(v10) < 0)
    operator delete(__p[1]);
  if (BYTE8(v8))
  {
    v6[0] = &unk_1E81697C0;
    if (v6[1] != (char *)v7 + 8)
      free(v6[1]);
    BYTE8(v8) = 0;
  }
  if (v16 < 0)
    operator delete(v15);
  if (v14[160])
  {
    v12[2] = (uint64_t)&unk_1E81697C0;
    if (v13 != v14)
      free(v13);
  }
}

void sub_1C547E58C(uint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  void *v18;
  void *v19;
  uint64_t v20;
  char v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char v27;
  void *v28;
  void *v29;
  uint64_t v30;
  char v31;
  uint64_t v32;
  __int128 __p;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v26 = *a1;
  v27 = *((_BYTE *)a1 + 8);
  LOBYTE(v28) = 0;
  v31 = 0;
  if (*((_BYTE *)a1 + 200))
    sub_1C547FCF8((uint64_t)&v28, (uint64_t)(a1 + 2));
  v32 = a1[26];
  __p = *(_OWORD *)(a1 + 27);
  a1[27] = 0;
  a1[28] = 0;
  v6 = a1[29];
  v7 = a1[30];
  a1[29] = 0;
  v34 = v6;
  v35 = v7;
  v16 = *a2;
  v17 = *((_BYTE *)a2 + 8);
  LOBYTE(v18) = 0;
  v21 = 0;
  if (*((_BYTE *)a2 + 200))
    sub_1C547FCF8((uint64_t)&v18, (uint64_t)(a2 + 2));
  v22 = a2[26];
  v8 = *(_OWORD *)(a2 + 27);
  a2[27] = 0;
  a2[28] = 0;
  v9 = a2[29];
  v10 = a2[30];
  a2[29] = 0;
  v23 = v8;
  v24 = v9;
  v25 = v10;
  *(_QWORD *)a3 = v26;
  *(_BYTE *)(a3 + 8) = v27;
  *(_BYTE *)(a3 + 16) = 0;
  *(_BYTE *)(a3 + 200) = 0;
  if (v31)
    sub_1C547FCF8(a3 + 16, (uint64_t)&v28);
  v11 = v35;
  *(_QWORD *)(a3 + 208) = v32;
  v12 = __p;
  v13 = v34;
  __p = 0uLL;
  v34 = 0;
  *(_OWORD *)(a3 + 216) = v12;
  *(_QWORD *)(a3 + 232) = v13;
  *(_QWORD *)(a3 + 240) = v11;
  *(_QWORD *)(a3 + 248) = v16;
  *(_BYTE *)(a3 + 256) = v17;
  *(_BYTE *)(a3 + 264) = 0;
  *(_BYTE *)(a3 + 448) = 0;
  if (v21)
    sub_1C547FCF8(a3 + 264, (uint64_t)&v18);
  v14 = v25;
  *(_QWORD *)(a3 + 456) = v22;
  *(_OWORD *)(a3 + 464) = v23;
  v15 = v24;
  v23 = 0uLL;
  v24 = 0;
  *(_QWORD *)(a3 + 480) = v15;
  *(_QWORD *)(a3 + 488) = v14;
  if (v21)
  {
    v18 = &unk_1E81697C0;
    if (v19 != &v20)
      free(v19);
    v21 = 0;
  }
  if (SHIBYTE(v34) < 0)
    operator delete((void *)__p);
  if (v31)
  {
    v28 = &unk_1E81697C0;
    if (v29 != &v30)
      free(v29);
  }
}

unint64_t llvm::DWARFDebugNames::ValueIterator::findEntryOffsetInCurrentIndex(llvm::DWARFDebugNames::ValueIterator *this)
{
  llvm::DWARFDebugNames::NameIndex *v2;
  int v3;
  int v4;
  const char *v5;
  size_t v6;
  size_t v7;
  size_t v8;
  size_t v9;
  char *v10;
  size_t v11;
  unsigned __int8 v13;
  unint64_t v14;
  char v15;
  int v16;
  unsigned int *v17;
  char *v18;
  char *v19;
  unsigned int v20;
  int v21;
  int v22;
  llvm::DWARFDebugNames::NameIndex *v23;
  unsigned __int32 v24;
  unsigned __int32 v25;
  unsigned int i;
  llvm::DWARFDebugNames::NameIndex *v27;
  const char *CStrRef;
  size_t v29;
  size_t v30;
  size_t v31;
  size_t v32;
  char *v33;
  size_t v34;
  __n128 v36[2];
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;

  v2 = *(llvm::DWARFDebugNames::NameIndex **)this;
  if (*(_DWORD *)(*(_QWORD *)this + 48))
  {
    if (*((_BYTE *)this + 244))
    {
      v20 = *((_DWORD *)this + 60);
    }
    else
    {
      v15 = *((_BYTE *)this + 239);
      v16 = v15;
      if (v15 >= 0)
        v17 = (unsigned int *)((char *)this + 216);
      else
        v17 = (unsigned int *)*((_QWORD *)this + 27);
      v18 = (char *)(v15 & 0x7F);
      if (v16 >= 0)
        v19 = v18;
      else
        v19 = (char *)*((_QWORD *)this + 28);
      v20 = llvm::caseFoldingDjbHash(v17, v19, 5381);
      v21 = *((unsigned __int8 *)this + 244);
      *((_DWORD *)this + 60) = v20;
      if (!v21)
        *((_BYTE *)this + 244) = 1;
    }
    v22 = v20 % *((_DWORD *)v2 + 12);
    v23 = *(llvm::DWARFDebugNames::NameIndex **)this;
    v36[0].n128_u64[0] = *(_QWORD *)(*(_QWORD *)this + 120) + (4 * v22);
    v24 = sub_1C6387364(*((_QWORD *)v23 + 12) + 8, v36[0].n128_u64, 0);
    if (v24)
    {
      v25 = v24;
      if (v24 <= *((_DWORD *)v2 + 13))
      {
        for (i = 4 * v24 - 4; ; i += 4)
        {
          v27 = *(llvm::DWARFDebugNames::NameIndex **)this;
          v36[0].n128_u64[0] = *(_QWORD *)(*(_QWORD *)this + 128) + i;
          if (sub_1C6387364(*((_QWORD *)v27 + 12) + 8, v36[0].n128_u64, 0) % *((_DWORD *)v2 + 12) != v22)
            break;
          llvm::DWARFDebugNames::NameIndex::getNameTableEntry(*(llvm::DWARFDebugNames::NameIndex **)this, v25, v36);
          v39 = v37;
          CStrRef = (const char *)llvm::DataExtractor::getCStrRef((uint64_t *)v36, &v39, 0);
          v29 = strlen(CStrRef);
          v30 = *((unsigned __int8 *)this + 239);
          if ((v30 & 0x80u) == 0)
            v31 = v30 & 0x7F;
          else
            v31 = *((_QWORD *)this + 28);
          if (v29 == v31)
          {
            v32 = v29;
            if ((v30 & 0x80) != 0)
            {
              if (v29 == -1)
LABEL_54:
                abort();
              v33 = (char *)*((_QWORD *)this + 27);
              v30 = *((_QWORD *)this + 28);
            }
            else
            {
              v33 = (char *)this + 216;
              if (v32 == -1)
                goto LABEL_54;
            }
            v34 = v30 >= v32 ? v32 : v30;
            if (!memcmp(v33, CStrRef, v34) && v30 == v32)
              goto LABEL_52;
          }
          v13 = 0;
          v14 = 0;
          if (++v25 > *((_DWORD *)v2 + 13))
            return v14 | v13;
        }
      }
    }
    goto LABEL_21;
  }
  v3 = *((_DWORD *)v2 + 13);
  if (!v3)
  {
LABEL_21:
    v13 = 0;
    v14 = 0;
    return v14 | v13;
  }
  v4 = 0;
  while (1)
  {
    llvm::DWARFDebugNames::NameIndex::getNameTableEntry(v2, ++v4, v36);
    v39 = v37;
    v5 = (const char *)llvm::DataExtractor::getCStrRef((uint64_t *)v36, &v39, 0);
    v6 = strlen(v5);
    v7 = *((unsigned __int8 *)this + 239);
    v8 = (v7 & 0x80u) == 0 ? v7 & 0x7F : *((_QWORD *)this + 28);
    if (v6 == v8)
    {
      v9 = v6;
      if ((v7 & 0x80) != 0)
      {
        if (v6 == -1)
          goto LABEL_54;
        v10 = (char *)*((_QWORD *)this + 27);
        v7 = *((_QWORD *)this + 28);
      }
      else
      {
        v10 = (char *)this + 216;
        if (v9 == -1)
          goto LABEL_54;
      }
      v11 = v7 >= v9 ? v9 : v7;
      if (!memcmp(v10, v5, v11) && v7 == v9)
        break;
    }
    if (v3 == v4)
      goto LABEL_21;
  }
LABEL_52:
  v13 = v38;
  v14 = v38 & 0xFFFFFFFFFFFFFF00;
  return v14 | v13;
}

BOOL llvm::DWARFDebugNames::ValueIterator::getEntryAtCurrentOffset(llvm::DWARFDebugNames::ValueIterator *this)
{
  char v2;
  char *v3;
  char *v4;
  char *v6;
  char *v7;
  char *v8;
  void *v9;
  uint64_t v10;
  char v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  llvm::DWARFDebugNames::NameIndex::getEntry(*(llvm::DWARFDebugNames::NameIndex **)this, (unint64_t *)this + 26, (uint64_t)&v8);
  v2 = v11;
  if ((v11 & 1) != 0)
  {
    v3 = v8;
    v8 = 0;
    v6 = v3;
    sub_1C4D62BD4(&v6, &v7);
    if (v6)
      (*(void (**)(char *))(*(_QWORD *)v6 + 8))(v6);
  }
  else
  {
    sub_1C547FDA0((uint64_t)this + 16, (uint64_t)&v8);
  }
  if ((v11 & 1) != 0)
  {
    v4 = v8;
    v8 = 0;
    if (v4)
      (*(void (**)(char *))(*(_QWORD *)v4 + 8))(v4);
  }
  else
  {
    v8 = (char *)&unk_1E81697C0;
    if (v9 != &v10)
      free(v9);
  }
  return (v2 & 1) == 0;
}

BOOL llvm::DWARFDebugNames::ValueIterator::findInCurrentIndex(llvm::DWARFDebugNames::ValueIterator *this)
{
  unint64_t EntryOffsetInCurrentIndex;
  char v3;

  EntryOffsetInCurrentIndex = llvm::DWARFDebugNames::ValueIterator::findEntryOffsetInCurrentIndex(this);
  if (!v3)
    return 0;
  *((_QWORD *)this + 26) = EntryOffsetInCurrentIndex;
  return llvm::DWARFDebugNames::ValueIterator::getEntryAtCurrentOffset(this);
}

void llvm::DWARFDebugNames::ValueIterator::searchFromStartOfCurrentIndex(llvm::DWARFDebugNames::ValueIterator *this)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t EntryOffsetInCurrentIndex;
  char v5;

  v2 = *(_QWORD *)this;
  v3 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 96) + 72)
     + 160 * *(unsigned int *)(*(_QWORD *)(*(_QWORD *)this + 96) + 80);
  while (v2 != v3)
  {
    EntryOffsetInCurrentIndex = llvm::DWARFDebugNames::ValueIterator::findEntryOffsetInCurrentIndex(this);
    if (v5)
    {
      *((_QWORD *)this + 26) = EntryOffsetInCurrentIndex;
      if (llvm::DWARFDebugNames::ValueIterator::getEntryAtCurrentOffset(this))
        return;
    }
    v2 = *(_QWORD *)this + 160;
    *(_QWORD *)this = v2;
  }
  sub_1C547EC3C((uint64_t)this);
}

void sub_1C547EC3C(uint64_t a1)
{
  void **v2;
  void *v3[2];
  _OWORD v4[10];
  __int128 v5;
  _OWORD v6[2];
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v7 = 0;
  memset(v6, 0, sizeof(v6));
  v5 = 0u;
  *(_OWORD *)v3 = 0u;
  memset(v4, 0, sizeof(v4));
  *(_QWORD *)a1 = 0;
  *(_BYTE *)(a1 + 8) = 0;
  sub_1C547F698(a1 + 16, (uint64_t)v3);
  *(_QWORD *)(a1 + 208) = *(_QWORD *)&v6[0];
  v2 = (void **)(a1 + 216);
  if (*(char *)(a1 + 239) < 0)
    operator delete(*v2);
  *(_OWORD *)v2 = *(_OWORD *)((char *)v6 + 8);
  *(_QWORD *)(a1 + 232) = *((_QWORD *)&v6[1] + 1);
  HIBYTE(v6[1]) = 0;
  BYTE8(v6[0]) = 0;
  *(_QWORD *)(a1 + 240) = v7;
  if (BYTE8(v5))
  {
    v3[0] = &unk_1E81697C0;
    if (v3[1] != (char *)v4 + 8)
      free(v3[1]);
  }
}

void llvm::DWARFDebugNames::ValueIterator::next(llvm::DWARFDebugNames::ValueIterator *this)
{
  if (!llvm::DWARFDebugNames::ValueIterator::getEntryAtCurrentOffset(this))
  {
    if (*((_BYTE *)this + 8)
      || *(_QWORD *)this == *(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 96) + 72)
                          + 160 * *(unsigned int *)(*(_QWORD *)(*(_QWORD *)this + 96) + 80)
                          - 160)
    {
      sub_1C547EC3C((uint64_t)this);
    }
    else
    {
      *(_QWORD *)this += 160;
      llvm::DWARFDebugNames::ValueIterator::searchFromStartOfCurrentIndex(this);
    }
  }
}

uint64_t llvm::DWARFDebugNames::ValueIterator::ValueIterator(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  void *v7;
  uint64_t v8;
  uint64_t v9;

  *(_QWORD *)a1 = *(_QWORD *)(a2 + 72);
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 200) = 0;
  *(_QWORD *)(a1 + 208) = 0;
  if (a4 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  if (a4 >= 0x17)
  {
    v8 = (a4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a4 | 7) != 0x17)
      v8 = a4 | 7;
    v9 = v8 + 1;
    v7 = operator new(v8 + 1);
    *(_QWORD *)(a1 + 224) = a4;
    *(_QWORD *)(a1 + 232) = v9 | 0x8000000000000000;
    *(_QWORD *)(a1 + 216) = v7;
  }
  else
  {
    v7 = (void *)(a1 + 216);
    *(_BYTE *)(a1 + 239) = a4;
    if (!a4)
      goto LABEL_9;
  }
  memmove(v7, a3, a4);
LABEL_9:
  *((_BYTE *)v7 + a4) = 0;
  *(_BYTE *)(a1 + 240) = 0;
  *(_BYTE *)(a1 + 244) = 0;
  llvm::DWARFDebugNames::ValueIterator::searchFromStartOfCurrentIndex((llvm::DWARFDebugNames::ValueIterator *)a1);
  return a1;
}

{
  void *v7;
  uint64_t v8;
  uint64_t v9;

  *(_QWORD *)a1 = *(_QWORD *)(a2 + 72);
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 200) = 0;
  *(_QWORD *)(a1 + 208) = 0;
  if (a4 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  if (a4 >= 0x17)
  {
    v8 = (a4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a4 | 7) != 0x17)
      v8 = a4 | 7;
    v9 = v8 + 1;
    v7 = operator new(v8 + 1);
    *(_QWORD *)(a1 + 224) = a4;
    *(_QWORD *)(a1 + 232) = v9 | 0x8000000000000000;
    *(_QWORD *)(a1 + 216) = v7;
  }
  else
  {
    v7 = (void *)(a1 + 216);
    *(_BYTE *)(a1 + 239) = a4;
    if (!a4)
      goto LABEL_9;
  }
  memmove(v7, a3, a4);
LABEL_9:
  *((_BYTE *)v7 + a4) = 0;
  *(_BYTE *)(a1 + 240) = 0;
  *(_BYTE *)(a1 + 244) = 0;
  llvm::DWARFDebugNames::ValueIterator::searchFromStartOfCurrentIndex((llvm::DWARFDebugNames::ValueIterator *)a1);
  return a1;
}

{
  void *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t EntryOffsetInCurrentIndex;
  char v11;

  *(_QWORD *)a1 = a2;
  *(_BYTE *)(a1 + 8) = 1;
  *(_BYTE *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 200) = 0;
  *(_QWORD *)(a1 + 208) = 0;
  if (a4 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  if (a4 >= 0x17)
  {
    v8 = (a4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a4 | 7) != 0x17)
      v8 = a4 | 7;
    v9 = v8 + 1;
    v7 = operator new(v8 + 1);
    *(_QWORD *)(a1 + 224) = a4;
    *(_QWORD *)(a1 + 232) = v9 | 0x8000000000000000;
    *(_QWORD *)(a1 + 216) = v7;
  }
  else
  {
    v7 = (void *)(a1 + 216);
    *(_BYTE *)(a1 + 239) = a4;
    if (!a4)
      goto LABEL_9;
  }
  memmove(v7, a3, a4);
LABEL_9:
  *((_BYTE *)v7 + a4) = 0;
  *(_BYTE *)(a1 + 240) = 0;
  *(_BYTE *)(a1 + 244) = 0;
  EntryOffsetInCurrentIndex = llvm::DWARFDebugNames::ValueIterator::findEntryOffsetInCurrentIndex((llvm::DWARFDebugNames::ValueIterator *)a1);
  if (!v11
    || (*(_QWORD *)(a1 + 208) = EntryOffsetInCurrentIndex,
        !llvm::DWARFDebugNames::ValueIterator::getEntryAtCurrentOffset((llvm::DWARFDebugNames::ValueIterator *)a1)))
  {
    sub_1C547EC3C(a1);
  }
  return a1;
}

void llvm::DWARFDebugNames::equal_range(uint64_t a1@<X0>, const void *a2@<X1>, size_t a3@<X2>, uint64_t a4@<X8>)
{
  void *v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  void *v13[2];
  _OWORD v14[10];
  __int128 v15;
  void *v16[2];
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  void *v21;
  void *v22;
  char v23;
  uint64_t v24;
  void *v25[2];
  unint64_t v26;
  char v27;
  char v28;
  __int128 v29;
  void *v30[2];
  _OWORD v31[10];
  __int128 v32;
  void *__p[2];
  __int128 v34;
  uint64_t v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  void *v49[2];
  __int128 v50;
  uint64_t v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 80))
  {
    v19 = *(_QWORD *)(a1 + 72);
    v20 = 0;
    LOBYTE(v21) = 0;
    v23 = 0;
    v24 = 0;
    if (a3 >= 0x7FFFFFFFFFFFFFF8)
      abort();
    if (a3 >= 0x17)
    {
      v10 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((a3 | 7) != 0x17)
        v10 = a3 | 7;
      v11 = v10 + 1;
      v7 = operator new(v10 + 1);
      v25[1] = (void *)a3;
      v26 = v11 | 0x8000000000000000;
      v25[0] = v7;
    }
    else
    {
      v7 = v25;
      HIBYTE(v26) = a3;
      if (!a3)
      {
LABEL_20:
        *((_BYTE *)v7 + a3) = 0;
        v27 = 0;
        v28 = 0;
        llvm::DWARFDebugNames::ValueIterator::searchFromStartOfCurrentIndex((llvm::DWARFDebugNames::ValueIterator *)&v19);
        v18 = 0;
        *(_OWORD *)v16 = 0u;
        v17 = 0u;
        v15 = 0u;
        *(_OWORD *)v13 = 0u;
        memset(v14, 0, sizeof(v14));
        v12 = 0u;
        sub_1C547E58C(&v19, (uint64_t *)&v12, a4);
        if (SHIBYTE(v17) < 0)
          operator delete(v16[1]);
        if (BYTE8(v15))
        {
          v13[0] = &unk_1E81697C0;
          if (v13[1] != (char *)v14 + 8)
            free(v13[1]);
          BYTE8(v15) = 0;
        }
        if (SHIBYTE(v26) < 0)
          operator delete(v25[0]);
        if (v23)
        {
          v21 = &unk_1E81697C0;
          v8 = (uint64_t *)v22;
          v9 = &v19;
LABEL_30:
          if (v8 != v9 + 5)
            free(v8);
          return;
        }
        return;
      }
    }
    memmove(v7, a2, a3);
    goto LABEL_20;
  }
  v51 = 0;
  *(_OWORD *)v49 = 0u;
  v50 = 0u;
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v36 = 0u;
  v29 = 0u;
  *(_OWORD *)v30 = 0u;
  memset(v31, 0, sizeof(v31));
  v32 = 0u;
  *(_OWORD *)__p = 0u;
  v34 = 0u;
  v35 = 0;
  sub_1C547E58C((uint64_t *)&v36, (uint64_t *)&v29, a4);
  if (SHIBYTE(v34) < 0)
    operator delete(__p[1]);
  if (BYTE8(v32))
  {
    v30[0] = &unk_1E81697C0;
    if (v30[1] != (char *)v31 + 8)
      free(v30[1]);
    BYTE8(v32) = 0;
  }
  if (SHIBYTE(v50) < 0)
    operator delete(v49[1]);
  if (BYTE8(v48))
  {
    *(_QWORD *)&v37 = &unk_1E81697C0;
    v8 = (uint64_t *)*((_QWORD *)&v37 + 1);
    v9 = (uint64_t *)&v36;
    goto LABEL_30;
  }
}

uint64_t llvm::DWARFDebugNames::getCUNameIndex(llvm::DWARFDebugNames *this, uint64_t a2)
{
  uint64_t *v2;
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  int v7;
  char v8;
  unint64_t RelocatedValue;
  unint64_t v11[3];
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;

  v14 = a2;
  v2 = (uint64_t *)((char *)this + 88);
  if (!*((_DWORD *)this + 24))
  {
    v3 = *((_DWORD *)this + 20);
    if (v3)
    {
      v4 = *((_QWORD *)this + 9);
      v5 = v4 + 160 * v3;
      do
      {
        if (*(_DWORD *)(v4 + 36))
        {
          v6 = 0;
          do
          {
            if (*(_BYTE *)(v4 + 32))
              v7 = 8;
            else
              v7 = 4;
            if (*(_BYTE *)(v4 + 32))
              v8 = 3;
            else
              v8 = 2;
            v11[0] = *(_QWORD *)(v4 + 112) + (v6 << v8);
            RelocatedValue = llvm::DWARFDataExtractor::getRelocatedValue(*(_QWORD *)(v4 + 96) + 8, v7, v11, 0, 0);
            v12 = v4;
            v13 = RelocatedValue;
            sub_1C547F3B8((uint64_t)v2, (uint64_t *)&v13, &v12, (uint64_t)v11);
            ++v6;
          }
          while (v6 < *(_DWORD *)(v4 + 36));
        }
        v4 += 160;
      }
      while (v4 != v5);
    }
  }
  return sub_1C547F4A4(v2, &v14);
}

_QWORD *sub_1C547F3B8@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  _QWORD *result;
  uint64_t v12;
  char v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  int v17;
  BOOL v18;
  unsigned int v19;

  v8 = *(_DWORD *)(a1 + 16);
  if (!v8)
  {
    v14 = 0;
LABEL_5:
    result = sub_1C547FE3C(a1, (uint64_t)a2, a2, v14);
    v15 = *a3;
    *result = *a2;
    result[1] = v15;
    v9 = *(_QWORD *)a1;
    v8 = *(_DWORD *)(a1 + 16);
    v13 = 1;
    goto LABEL_6;
  }
  v9 = *(_QWORD *)a1;
  v10 = (37 * *a2) & (v8 - 1);
  result = (_QWORD *)(*(_QWORD *)a1 + 16 * v10);
  v12 = *result;
  if (*a2 != *result)
  {
    v16 = 0;
    v17 = 1;
    while (v12 != -1)
    {
      if (v16)
        v18 = 0;
      else
        v18 = v12 == -2;
      if (v18)
        v16 = result;
      v19 = v10 + v17++;
      v10 = v19 & (v8 - 1);
      result = (_QWORD *)(v9 + 16 * v10);
      v12 = *result;
      if (*a2 == *result)
        goto LABEL_3;
    }
    if (v16)
      v14 = v16;
    else
      v14 = result;
    goto LABEL_5;
  }
LABEL_3:
  v13 = 0;
LABEL_6:
  *(_QWORD *)a4 = result;
  *(_QWORD *)(a4 + 8) = v9 + 16 * v8;
  *(_BYTE *)(a4 + 16) = v13;
  return result;
}

uint64_t sub_1C547F4A4(uint64_t *a1, _QWORD *a2)
{
  int v2;
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  int v8;
  int v9;

  v2 = *((_DWORD *)a1 + 4);
  if (v2)
  {
    v3 = *a1;
    v4 = v2 - 1;
    v5 = (37 * *a2) & (v2 - 1);
    v6 = *(_QWORD *)(*a1 + 16 * ((37 * *a2) & v4));
    if (*a2 == v6)
      return *(_QWORD *)(v3 + 16 * v5 + 8);
    v8 = 1;
    while (v6 != -1)
    {
      v9 = v5 + v8++;
      v5 = v9 & v4;
      v6 = *(_QWORD *)(v3 + 16 * v5);
      if (*a2 == v6)
        return *(_QWORD *)(v3 + 16 * v5 + 8);
    }
  }
  return 0;
}

_QWORD *sub_1C547F514(_QWORD *a1)
{
  _QWORD *v2;

  *a1 = &off_1E8169710;
  v2 = (_QWORD *)a1[13];
  if (v2 != a1 + 15)
    free(v2);
  return a1;
}

void sub_1C547F554(_QWORD *a1)
{
  _QWORD *v2;

  *a1 = &off_1E8169710;
  v2 = (_QWORD *)a1[13];
  if (v2 != a1 + 15)
    free(v2);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C547F5A4(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E8169740;
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 88), 8);
  sub_1C547F76C((char **)(a1 + 72));
  return a1;
}

void sub_1C547F5E4(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E8169740;
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 88), 8);
  sub_1C547F76C((char **)(a1 + 72));
  JUMPOUT(0x1CAA32FC0);
}

uint64_t *sub_1C547F634(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  void *v6;

  v2 = *((unsigned int *)a1 + 4);
  v3 = *a1;
  if ((_DWORD)v2)
  {
    v4 = 32 * v2;
    v5 = (_QWORD *)(v3 + 16);
    do
    {
      v6 = (void *)*(v5 - 1);
      if (v6)
      {
        *v5 = v6;
        operator delete(v6);
      }
      v5 += 4;
      v4 -= 32;
    }
    while (v4);
    v3 = *a1;
  }
  MEMORY[0x1CAA32FB4](v3, 8);
  return a1;
}

uint64_t sub_1C547F698(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  void *v5;

  if (*(_BYTE *)(a2 + 184))
  {
    if (*(_BYTE *)(a1 + 184))
    {
      sub_1C624D034(a1 + 8, a2 + 8);
      *(_OWORD *)(a1 + 168) = *(_OWORD *)(a2 + 168);
    }
    else
    {
      *(_QWORD *)a1 = &unk_1E81697C0;
      *(_QWORD *)(a1 + 8) = a1 + 24;
      v4 = a1 + 8;
      *(_QWORD *)(a1 + 16) = 0x300000000;
      if (*(_DWORD *)(a2 + 16))
        sub_1C624D034(v4, a2 + 8);
      *(_QWORD *)a1 = &off_1E81696C0;
      *(_OWORD *)(a1 + 168) = *(_OWORD *)(a2 + 168);
      *(_BYTE *)(a1 + 184) = 1;
    }
  }
  else if (*(_BYTE *)(a1 + 184))
  {
    *(_QWORD *)a1 = &unk_1E81697C0;
    v5 = *(void **)(a1 + 8);
    if (v5 != (void *)(a1 + 24))
      free(v5);
    *(_BYTE *)(a1 + 184) = 0;
  }
  return a1;
}

char **sub_1C547F76C(char **a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;

  v2 = *a1;
  v3 = *((unsigned int *)a1 + 2);
  if ((_DWORD)v3)
  {
    v4 = 160 * v3;
    do
    {
      v5 = *(char **)&v2[v4 - 96];
      if (&v2[v4 - 72] != v5)
        free(v5);
      sub_1C547F634((uint64_t *)&v2[v4 - 160]);
      v4 -= 160;
    }
    while (v4);
    v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2))
    free(v2);
  return a1;
}

char *sub_1C547F7E8(char **a1, int a2)
{
  uint64_t v3;
  int *v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unsigned int v8;
  char *result;
  uint64_t v10;
  char *v11;
  int *v12;
  int *v13;
  int v14;
  int v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  BOOL v22;
  int v23;
  int v24;
  void *v25;
  uint64_t v26;
  char *v27;

  v3 = *((unsigned int *)a1 + 4);
  v4 = (int *)*a1;
  v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
    v8 = v7 + 1;
  else
    v8 = 64;
  *((_DWORD *)a1 + 4) = v8;
  result = (char *)operator new(32 * v8, (std::align_val_t)8uLL);
  *a1 = result;
  if (v4)
  {
    a1[1] = 0;
    v10 = *((unsigned int *)a1 + 4);
    if ((_DWORD)v10)
    {
      v11 = &result[32 * v10];
      do
      {
        *(_DWORD *)result = 0;
        *((_WORD *)result + 2) = 0;
        *((_QWORD *)result + 2) = 0;
        *((_QWORD *)result + 3) = 0;
        *((_QWORD *)result + 1) = 0;
        result += 32;
      }
      while (result != v11);
    }
    if ((_DWORD)v3)
    {
      v12 = v4;
      v13 = &v4[8 * v3];
      do
      {
        v14 = *v12;
        if ((*v12 + 1) >= 2)
        {
          v15 = *((_DWORD *)a1 + 4);
          if (v15)
          {
            v16 = v15 - 1;
            v17 = (v15 - 1) & (37 * v14);
            v18 = (uint64_t)&(*a1)[32 * v17];
            v19 = *(_DWORD *)v18;
            if (v14 != *(_DWORD *)v18)
            {
              v20 = 0;
              v21 = 1;
              while (v19)
              {
                if (v20)
                  v22 = 0;
                else
                  v22 = v19 == -1;
                if (v22)
                  v20 = v18;
                v23 = v17 + v21++;
                v17 = v23 & v16;
                v18 = (uint64_t)&(*a1)[32 * v17];
                v19 = *(_DWORD *)v18;
                if (v14 == *(_DWORD *)v18)
                  goto LABEL_23;
              }
              if (v20)
                v18 = v20;
            }
          }
          else
          {
            v18 = 0;
          }
LABEL_23:
          v24 = *v12;
          *(_WORD *)(v18 + 4) = *((_WORD *)v12 + 2);
          *(_DWORD *)v18 = v24;
          sub_1C6184574(v18 + 8, (__n128 *)(v12 + 2));
          ++*((_DWORD *)a1 + 2);
        }
        v25 = (void *)*((_QWORD *)v12 + 1);
        if (v25)
        {
          *((_QWORD *)v12 + 2) = v25;
          operator delete(v25);
        }
        v12 += 8;
      }
      while (v12 != v13);
    }
    JUMPOUT(0x1CAA32FB4);
  }
  a1[1] = 0;
  v26 = *((unsigned int *)a1 + 4);
  if ((_DWORD)v26)
  {
    v27 = &result[32 * v26];
    do
    {
      *(_DWORD *)result = 0;
      *((_WORD *)result + 2) = 0;
      *((_QWORD *)result + 2) = 0;
      *((_QWORD *)result + 3) = 0;
      *((_QWORD *)result + 1) = 0;
      result += 32;
    }
    while (result != v27);
  }
  return result;
}

uint64_t sub_1C547F9AC(uint64_t a1, __int16 a2)
{
  _OWORD *v3;
  _OWORD *v4;
  __int128 v5;
  __int128 v6;
  __int16 v8;
  char v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v8 = a2;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v3 = (_OWORD *)sub_1C4FE36B8(a1, (unint64_t)&v8);
  v4 = (_OWORD *)(*(_QWORD *)a1 + 48 * *(unsigned int *)(a1 + 8));
  v6 = v3[1];
  v5 = v3[2];
  *v4 = *v3;
  v4[1] = v6;
  v4[2] = v5;
  LODWORD(v4) = *(_DWORD *)(a1 + 8) + 1;
  *(_DWORD *)(a1 + 8) = (_DWORD)v4;
  return *(_QWORD *)a1 + 48 * v4 - 48;
}

uint64_t sub_1C547FA20(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;

  result = (*(uint64_t (**)(_QWORD, void *))(*(_QWORD *)*a2 + 48))(*a2, &llvm::DWARFDebugNames::SentinelError::ID);
  v7 = *a2;
  *a2 = 0;
  if (!(_DWORD)result)
  {
    result = (*(uint64_t (**)(uint64_t, void *))(*(_QWORD *)v7 + 48))(v7, &llvm::ErrorInfoBase::ID);
    if (!(_DWORD)result)
    {
      *a1 = v7;
      return result;
    }
    v8 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a3 + 248))(*a3);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v7 + 16))(v7, v8);
    *a1 = 0;
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  }
  *a1 = 0;
  if (v7)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return result;
}

unint64_t sub_1C547FAE0(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v7;
  unint64_t v9;

  v4 = *(unsigned int *)(a1 + 8);
  v5 = v4 + a3;
  if (v4 + a3 > (unint64_t)*(unsigned int *)(a1 + 12))
  {
    v7 = *(_QWORD *)a1 + 160 * v4;
    if (*(_QWORD *)a1 <= a2 && v7 > a2)
    {
      v9 = a2 - *(_QWORD *)a1;
      sub_1C547FB48(a1, v5);
      return *(_QWORD *)a1 + v9;
    }
    else
    {
      sub_1C547FB48(a1, v5);
    }
  }
  return a2;
}

void sub_1C547FB48(uint64_t a1, unint64_t a2)
{
  void *v3;
  int v4;
  unint64_t v5;

  v5 = 0;
  v3 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, a2, 160, &v5);
  sub_1C547FBB4(a1, (uint64_t)v3);
  v4 = v5;
  if (*(_QWORD *)a1 != a1 + 16)
    free(*(void **)a1);
  *(_QWORD *)a1 = v3;
  *(_DWORD *)(a1 + 12) = v4;
}

uint64_t sub_1C547FBB4(uint64_t result, uint64_t a2)
{
  unsigned int v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;

  v2 = *(_DWORD *)(result + 8);
  if (v2)
  {
    v4 = result;
    v5 = 0;
    v6 = *(_QWORD *)result;
    v7 = *(_QWORD *)result + 160 * v2;
    do
    {
      v8 = v6 + v5;
      v9 = a2 + v5;
      *(_QWORD *)v9 = 0;
      *(_QWORD *)(v9 + 8) = 0;
      *(_DWORD *)(v9 + 16) = 0;
      *(_QWORD *)v9 = *(_QWORD *)(v6 + v5);
      *(_QWORD *)v8 = 0;
      *(_DWORD *)(v9 + 8) = *(_DWORD *)(v6 + v5 + 8);
      *(_DWORD *)(v8 + 8) = 0;
      v10 = *(_DWORD *)(a2 + v5 + 12);
      *(_DWORD *)(v9 + 12) = *(_DWORD *)(v6 + v5 + 12);
      *(_DWORD *)(v8 + 12) = v10;
      v11 = *(_DWORD *)(a2 + v5 + 16);
      *(_DWORD *)(v9 + 16) = *(_DWORD *)(v6 + v5 + 16);
      v12 = *(_OWORD *)(v6 + v5 + 24);
      v13 = *(_OWORD *)(v6 + v5 + 40);
      v14 = *(_QWORD *)(v6 + v5 + 56);
      *(_QWORD *)(a2 + v5 + 64) = a2 + v5 + 88;
      result = a2 + v5 + 64;
      *(_DWORD *)(v8 + 16) = v11;
      *(_QWORD *)(result - 8) = v14;
      *(_OWORD *)(result - 24) = v13;
      *(_OWORD *)(result - 40) = v12;
      *(_OWORD *)(result + 8) = xmmword_1C6464ED0;
      if (*(_QWORD *)(v6 + v5 + 72))
        result = sub_1C4FE6ED8(result, v8 + 64);
      v15 = *(_OWORD *)(v8 + 96);
      v16 = *(_OWORD *)(v8 + 112);
      v17 = *(_OWORD *)(v8 + 144);
      *(_OWORD *)(v9 + 128) = *(_OWORD *)(v8 + 128);
      *(_OWORD *)(v9 + 144) = v17;
      *(_OWORD *)(v9 + 96) = v15;
      *(_OWORD *)(v9 + 112) = v16;
      v5 += 160;
    }
    while (v8 + 160 != v7);
    v18 = *(unsigned int *)(v4 + 8);
    if ((_DWORD)v18)
    {
      v19 = *(_QWORD *)v4;
      v20 = 160 * v18;
      do
      {
        v21 = *(void **)(v19 + v20 - 96);
        if ((void *)(v19 + v20 - 72) != v21)
          free(v21);
        result = (uint64_t)sub_1C547F634((uint64_t *)(v19 + v20 - 160));
        v20 -= 160;
      }
      while (v20);
    }
  }
  return result;
}

__n128 sub_1C547FCF8(uint64_t a1, uint64_t a2)
{
  void *v4;
  __n128 result;

  if (*(_BYTE *)(a1 + 184))
  {
    *(_QWORD *)a1 = &unk_1E81697C0;
    v4 = *(void **)(a1 + 8);
    if (v4 != (void *)(a1 + 24))
      free(v4);
    *(_BYTE *)(a1 + 184) = 0;
  }
  *(_QWORD *)a1 = &unk_1E81697C0;
  *(_QWORD *)(a1 + 8) = a1 + 24;
  *(_QWORD *)(a1 + 16) = 0x300000000;
  if (*(_DWORD *)(a2 + 16))
    sub_1C624D034(a1 + 8, a2 + 8);
  *(_QWORD *)a1 = &off_1E81696C0;
  result = *(__n128 *)(a2 + 168);
  *(__n128 *)(a1 + 168) = result;
  *(_BYTE *)(a1 + 184) = 1;
  return result;
}

uint64_t sub_1C547FDA0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  if (*(_BYTE *)(a1 + 184))
  {
    sub_1C624D034(a1 + 8, a2 + 8);
    *(_OWORD *)(a1 + 168) = *(_OWORD *)(a2 + 168);
  }
  else
  {
    *(_QWORD *)a1 = &unk_1E81697C0;
    *(_QWORD *)(a1 + 8) = a1 + 24;
    v4 = a1 + 8;
    *(_QWORD *)(a1 + 16) = 0x300000000;
    if (*(_DWORD *)(a2 + 16))
      sub_1C624D034(v4, a2 + 8);
    *(_QWORD *)a1 = &off_1E81696C0;
    *(_OWORD *)(a1 + 168) = *(_OWORD *)(a2 + 168);
    *(_BYTE *)(a1 + 184) = 1;
  }
  return a1;
}

_QWORD *sub_1C547FE3C(uint64_t a1, uint64_t a2, uint64_t *a3, _QWORD *a4)
{
  int v6;
  unsigned int v7;
  uint64_t v8;
  int v10;
  unsigned int v11;
  uint64_t v12;
  _QWORD *v13;
  int v14;
  BOOL v15;
  unsigned int v16;
  int v17;
  unsigned int v18;
  uint64_t v19;
  int v20;
  BOOL v21;
  unsigned int v22;

  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    sub_1C53061CC(a1, 2 * v7);
    v8 = *a3;
    v10 = *(_DWORD *)(a1 + 16) - 1;
    v11 = (37 * *a3) & v10;
    a4 = (_QWORD *)(*(_QWORD *)a1 + 16 * v11);
    v12 = *a4;
    if (*a3 != *a4)
    {
      v13 = 0;
      v14 = 1;
      while (v12 != -1)
      {
        if (v13)
          v15 = 0;
        else
          v15 = v12 == -2;
        if (v15)
          v13 = a4;
        v16 = v11 + v14++;
        v11 = v16 & v10;
        a4 = (_QWORD *)(*(_QWORD *)a1 + 16 * v11);
        v12 = *a4;
        if (v8 == *a4)
          goto LABEL_4;
      }
      goto LABEL_27;
    }
  }
  else
  {
    if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
    {
LABEL_3:
      v8 = *a4;
      goto LABEL_4;
    }
    sub_1C53061CC(a1, v7);
    v8 = *a3;
    v17 = *(_DWORD *)(a1 + 16) - 1;
    v18 = (37 * *a3) & v17;
    a4 = (_QWORD *)(*(_QWORD *)a1 + 16 * v18);
    v19 = *a4;
    if (*a3 != *a4)
    {
      v13 = 0;
      v20 = 1;
      while (v19 != -1)
      {
        if (v13)
          v21 = 0;
        else
          v21 = v19 == -2;
        if (v21)
          v13 = a4;
        v22 = v18 + v20++;
        v18 = v22 & v17;
        a4 = (_QWORD *)(*(_QWORD *)a1 + 16 * v18);
        v19 = *a4;
        if (v8 == *a4)
          goto LABEL_4;
      }
LABEL_27:
      if (v13)
        a4 = v13;
      goto LABEL_3;
    }
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v8 != -1)
    --*(_DWORD *)(a1 + 12);
  return a4;
}

uint64_t llvm::DWARFContext::DWARFContext(uint64_t a1, uint64_t *a2, __int128 *a3, uint64_t a4, uint64_t a5)
{
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = &off_1E8169948;
  *(_QWORD *)(a1 + 16) = a1 + 32;
  *(_QWORD *)(a1 + 24) = 0x100000000;
  *(_QWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 72) = -1;
  *(_BYTE *)(a1 + 80) = 0;
  *(_BYTE *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_QWORD *)(a1 + 240) = a1 + 256;
  *(_QWORD *)(a1 + 248) = 0x100000000;
  *(_QWORD *)(a1 + 288) = 0;
  *(_DWORD *)(a1 + 296) = -1;
  *(_BYTE *)(a1 + 304) = 0;
  *(_BYTE *)(a1 + 328) = 0;
  *(_QWORD *)(a1 + 336) = 0;
  *(_QWORD *)(a1 + 344) = 0;
  *(_DWORD *)(a1 + 360) = 0;
  *(_QWORD *)(a1 + 352) = 0;
  *(_QWORD *)(a1 + 368) = 0;
  *(_QWORD *)(a1 + 376) = 0;
  *(_QWORD *)(a1 + 384) = 0x1800000000;
  *(_QWORD *)(a1 + 400) = 0;
  *(_QWORD *)(a1 + 408) = 0;
  *(_BYTE *)(a1 + 416) = 0;
  v8 = *a3;
  *(_QWORD *)(a1 + 440) = *((_QWORD *)a3 + 2);
  *(_OWORD *)(a1 + 424) = v8;
  *((_QWORD *)a3 + 1) = 0;
  *((_QWORD *)a3 + 2) = 0;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a1 + 448) = 0;
  v9 = *(_QWORD *)(a4 + 24);
  if (v9)
  {
    if (v9 == a4)
    {
      *(_QWORD *)(a1 + 480) = a1 + 456;
      (*(void (**)(_QWORD))(**(_QWORD **)(a4 + 24) + 24))(*(_QWORD *)(a4 + 24));
    }
    else
    {
      *(_QWORD *)(a1 + 480) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 16))(v9);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 480) = 0;
  }
  v10 = *(_QWORD *)(a5 + 24);
  if (v10)
  {
    if (v10 == a5)
    {
      *(_QWORD *)(a1 + 512) = a1 + 488;
      (*(void (**)(_QWORD))(**(_QWORD **)(a5 + 24) + 24))(*(_QWORD *)(a5 + 24));
    }
    else
    {
      *(_QWORD *)(a1 + 512) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 16))(v10);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 512) = 0;
  }
  v11 = *a2;
  *a2 = 0;
  *(_QWORD *)(a1 + 520) = v11;
  return a1;
}

void llvm::DWARFContext::~DWARFContext(llvm::DWARFContext *this)
{
  uint64_t v2;
  llvm::DWARFContext *v3;
  uint64_t v4;
  llvm::DWARFContext *v5;
  uint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v14;
  void **v15;
  void **v16;
  uint64_t v17;
  llvm::DWARFContext *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void **v25;
  void **v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  uint64_t v36;
  void *v37;
  void *v38;
  void *v39;
  void *v40;
  _QWORD *v41;
  llvm::DWARFContext *v42;
  uint64_t v43;
  uint64_t v44;
  _QWORD *v45;
  _QWORD *v46;
  void **v47;

  *(_QWORD *)this = &off_1E8169948;
  v2 = *((_QWORD *)this + 65);
  *((_QWORD *)this + 65) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (llvm::DWARFContext *)*((_QWORD *)this + 64);
  if (v3 == (llvm::DWARFContext *)((char *)this + 488))
  {
    v4 = 4;
    v3 = (llvm::DWARFContext *)((char *)this + 488);
  }
  else
  {
    if (!v3)
      goto LABEL_8;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_8:
  v5 = (llvm::DWARFContext *)*((_QWORD *)this + 60);
  if (v5 == (llvm::DWARFContext *)((char *)this + 456))
  {
    v6 = 4;
    v5 = (llvm::DWARFContext *)((char *)this + 456);
  }
  else
  {
    if (!v5)
      goto LABEL_13;
    v6 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v5 + 8 * v6))();
LABEL_13:
  v7 = *((_QWORD *)this + 56);
  *((_QWORD *)this + 56) = 0;
  if (v7)
  {
    v44 = sub_1C61E6B14(v7);
    MEMORY[0x1CAA32FC0](v44, 0x10F0C4031312594);
  }
  if (*((char *)this + 447) < 0)
    operator delete(*((void **)this + 53));
  v8 = (std::__shared_weak_count *)*((_QWORD *)this + 51);
  if (v8)
    std::__shared_weak_count::__release_weak(v8);
  if (*((_DWORD *)this + 95))
  {
    v9 = *((unsigned int *)this + 94);
    if ((_DWORD)v9)
    {
      v10 = 0;
      v11 = 8 * v9;
      do
      {
        v12 = *(_QWORD *)(*((_QWORD *)this + 46) + v10);
        if (v12 != -8 && v12 != 0)
        {
          v14 = *(std::__shared_weak_count **)(v12 + 16);
          if (v14)
            std::__shared_weak_count::__release_weak(v14);
          MEMORY[0x1CAA32FB4](v12, 8);
        }
        v10 += 8;
      }
      while (v11 != v10);
    }
  }
  free(*((void **)this + 46));
  v15 = (void **)*((_QWORD *)this + 44);
  *((_QWORD *)this + 44) = 0;
  if (v15)
  {
    v47 = v15;
    sub_1C548BD34(&v47);
    MEMORY[0x1CAA32FC0](v15, 0x20C40960023A9);
  }
  v16 = (void **)*((_QWORD *)this + 43);
  *((_QWORD *)this + 43) = 0;
  if (v16)
  {
    v47 = v16;
    sub_1C548BD34(&v47);
    MEMORY[0x1CAA32FC0](v16, 0x20C40960023A9);
  }
  v17 = *((_QWORD *)this + 42);
  *((_QWORD *)this + 42) = 0;
  if (v17)
  {
    sub_1C624E174(v17, *(char **)(v17 + 8));
    MEMORY[0x1CAA32FC0](v17, 0x1072C402B7D7BD7);
  }
  if (*((_BYTE *)this + 328))
  {
    MEMORY[0x1CAA32FB4](*((_QWORD *)this + 38), 8);
    *((_BYTE *)this + 328) = 0;
  }
  v18 = (llvm::DWARFContext *)*((_QWORD *)this + 36);
  if (v18 == (llvm::DWARFContext *)((char *)this + 264))
  {
    v19 = 4;
    v18 = (llvm::DWARFContext *)((char *)this + 264);
  }
  else
  {
    if (!v18)
      goto LABEL_43;
    v19 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v18 + 8 * v19))();
LABEL_43:
  sub_1C51E463C((char **)this + 30);
  v20 = *((_QWORD *)this + 29);
  *((_QWORD *)this + 29) = 0;
  if (v20)
    (*(void (**)(uint64_t))(*(_QWORD *)v20 + 8))(v20);
  v21 = *((_QWORD *)this + 28);
  *((_QWORD *)this + 28) = 0;
  if (v21)
    (*(void (**)(uint64_t))(*(_QWORD *)v21 + 8))(v21);
  v22 = *((_QWORD *)this + 27);
  *((_QWORD *)this + 27) = 0;
  if (v22)
    (*(void (**)(uint64_t))(*(_QWORD *)v22 + 8))(v22);
  v23 = *((_QWORD *)this + 26);
  *((_QWORD *)this + 26) = 0;
  if (v23)
    (*(void (**)(uint64_t))(*(_QWORD *)v23 + 8))(v23);
  v24 = *((_QWORD *)this + 25);
  *((_QWORD *)this + 25) = 0;
  if (v24)
    (*(void (**)(uint64_t))(*(_QWORD *)v24 + 8))(v24);
  v25 = (void **)*((_QWORD *)this + 24);
  *((_QWORD *)this + 24) = 0;
  if (v25)
  {
    v47 = v25;
    sub_1C548BD34(&v47);
    MEMORY[0x1CAA32FC0](v25, 0x20C40960023A9);
  }
  v26 = (void **)*((_QWORD *)this + 23);
  *((_QWORD *)this + 23) = 0;
  if (v26)
  {
    v47 = v26;
    sub_1C548BD34(&v47);
    MEMORY[0x1CAA32FC0](v26, 0x20C40960023A9);
  }
  v27 = *((_QWORD *)this + 22);
  *((_QWORD *)this + 22) = 0;
  if (v27)
  {
    v47 = (void **)(v27 + 16);
    sub_1C4764BBC(&v47);
    MEMORY[0x1CAA32FC0](v27, 0x1020C40CCA6D962);
  }
  v28 = *((_QWORD *)this + 21);
  *((_QWORD *)this + 21) = 0;
  if (v28)
  {
    v47 = (void **)(v28 + 16);
    sub_1C4764BBC(&v47);
    MEMORY[0x1CAA32FC0](v28, 0x1020C40CCA6D962);
  }
  v29 = *((_QWORD *)this + 20);
  *((_QWORD *)this + 20) = 0;
  if (v29)
  {
    sub_1C548D8E8(*(_QWORD **)(v29 + 8));
    MEMORY[0x1CAA32FC0](v29, 0x1020C4062D53EE8);
  }
  v30 = *((_QWORD *)this + 19);
  *((_QWORD *)this + 19) = 0;
  if (v30)
  {
    MEMORY[0x1CAA32FB4](*(_QWORD *)(v30 + 48), 8);
    v31 = *(void **)(v30 + 24);
    if (v31)
    {
      *(_QWORD *)(v30 + 32) = v31;
      operator delete(v31);
    }
    v32 = *(void **)v30;
    if (*(_QWORD *)v30)
    {
      *(_QWORD *)(v30 + 8) = v32;
      operator delete(v32);
    }
    MEMORY[0x1CAA32FC0](v30, 0x1020C4088D124F6);
  }
  v33 = *((_QWORD *)this + 18);
  *((_QWORD *)this + 18) = 0;
  if (v33)
  {
    sub_1C624E1D0((char **)(v33 + 48));
    MEMORY[0x1CAA32FC0](v33, 0x10F1C40D646D640);
  }
  v34 = *((_QWORD *)this + 17);
  *((_QWORD *)this + 17) = 0;
  if (v34)
  {
    sub_1C624E174(v34, *(char **)(v34 + 8));
    MEMORY[0x1CAA32FC0](v34, 0x1072C402B7D7BD7);
  }
  v35 = (_QWORD *)*((_QWORD *)this + 16);
  *((_QWORD *)this + 16) = 0;
  if (v35)
  {
    v45 = sub_1C624E0F0(v35);
    MEMORY[0x1CAA32FC0](v45, 0x10B0C40B5600ACDLL);
  }
  v36 = *((_QWORD *)this + 15);
  *((_QWORD *)this + 15) = 0;
  if (v36)
  {
    sub_1C548D628((char **)(v36 + 88));
    v37 = *(void **)(v36 + 72);
    if (v37 != (void *)(v36 + 88))
      free(v37);
    v38 = *(void **)(v36 + 56);
    if (v38 != (void *)(v36 + 72))
      free(v38);
    v39 = *(void **)(v36 + 40);
    if (v39 != (void *)(v36 + 56))
      free(v39);
    v40 = *(void **)(v36 + 24);
    if (v40 != (void *)(v36 + 40))
      free(v40);
    MEMORY[0x1CAA32FC0](v36, 0x10D0C40CB60C578);
  }
  v41 = (_QWORD *)*((_QWORD *)this + 14);
  *((_QWORD *)this + 14) = 0;
  if (v41)
  {
    v46 = sub_1C624E0F0(v41);
    MEMORY[0x1CAA32FC0](v46, 0x10B0C40B5600ACDLL);
  }
  if (*((_BYTE *)this + 104))
  {
    MEMORY[0x1CAA32FB4](*((_QWORD *)this + 10), 8);
    *((_BYTE *)this + 104) = 0;
  }
  v42 = (llvm::DWARFContext *)*((_QWORD *)this + 8);
  if (v42 == (llvm::DWARFContext *)((char *)this + 40))
  {
    v43 = 4;
    v42 = (llvm::DWARFContext *)((char *)this + 40);
    goto LABEL_93;
  }
  if (v42)
  {
    v43 = 5;
LABEL_93:
    (*(void (**)(void))(*(_QWORD *)v42 + 8 * v43))();
  }
  sub_1C51E463C((char **)this + 2);
}

{
  llvm::DWARFContext::~DWARFContext(this);
  JUMPOUT(0x1CAA32FC0);
}

char **llvm::DWARFContext::parseMacroOrMacinfo@<X0>(uint64_t a1@<X0>, int a2@<W1>, char ***a3@<X8>)
{
  char **result;
  uint64_t (*v7)(void);
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  int v12;
  uint64_t v13;
  __int128 *v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  __int128 v20;
  char v21;
  char v22;
  uint64_t v23;
  __int128 *v24;
  char ***v25[3];
  int v26;

  v26 = a2;
  result = (char **)operator new();
  result[1] = 0;
  result[2] = 0;
  *result = 0;
  *a3 = result;
  v25[0] = a3;
  v25[1] = (char ***)&v26;
  v25[2] = (char ***)a1;
  switch(a2)
  {
    case 0:
      v7 = *(uint64_t (**)(void))(**(_QWORD **)(a1 + 520) + 176);
      goto LABEL_4;
    case 1:
      v7 = *(uint64_t (**)(void))(**(_QWORD **)(a1 + 520) + 184);
LABEL_4:
      v8 = v7();
      v10 = v9;
      v11 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 520) + 40))(*(_QWORD *)(a1 + 520));
      *(_QWORD *)&v20 = v8;
      *((_QWORD *)&v20 + 1) = v10;
      v21 = v11;
      v22 = 0;
      v23 = 0;
      v24 = 0;
      v12 = 0;
      goto LABEL_8;
    case 2:
      v13 = *(_QWORD *)(a1 + 520);
      v14 = (__int128 *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v13 + 160))(v13);
      v15 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 520) + 40))(*(_QWORD *)(a1 + 520));
      v20 = *v14;
      v21 = v15;
      v22 = 0;
      v23 = v13;
      v24 = v14;
      goto LABEL_7;
    case 3:
      v16 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 520) + 168))(*(_QWORD *)(a1 + 520));
      v18 = v17;
      v19 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 520) + 40))(*(_QWORD *)(a1 + 520));
      *(_QWORD *)&v20 = v16;
      *((_QWORD *)&v20 + 1) = v18;
      v21 = v19;
      v22 = 0;
      v23 = 0;
      v24 = 0;
LABEL_7:
      v12 = 1;
LABEL_8:
      result = (char **)sub_1C548082C(v25, &v20, v12);
      break;
    default:
      return result;
  }
  return result;
}

const char *sub_1C548082C(char ****a1, __int128 *a2, int a3)
{
  llvm::DWARFContext *v5;
  char **v6;
  __int128 v7;
  char **v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  const char *result;
  uint64_t v15;
  char ***v16;
  char **v17;
  const char *v18;
  _OWORD v19[3];
  const char *v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24[2];
  __int16 v25;
  char v26;
  _OWORD v27[3];
  char v28;

  v5 = (llvm::DWARFContext *)a1[2];
  v6 = **a1;
  if (a3)
  {
    if (*(_DWORD *)a1[1] == 2)
      sub_1C548BC00((uint64_t)a1[2], v19);
    else
      sub_1C5487034(v19, v5);
    v10 = 280;
    if (*(_DWORD *)a1[1] == 2)
      v10 = 136;
    v11 = (*(uint64_t (**)(void))(**((_QWORD **)v5 + 65) + v10))();
    v12 = a2[1];
    v21 = *a2;
    v22 = v12;
    v23 = *((_QWORD *)a2 + 4);
    v27[0] = v19[0];
    v27[1] = v19[1];
    v27[2] = v19[2];
    v28 = 1;
    v24[0] = v11;
    v24[1] = v13;
    v25 = 0;
    v26 = 1;
    v8 = v6;
    v9 = 1;
  }
  else
  {
    v7 = a2[1];
    v21 = *a2;
    v22 = v7;
    v23 = *((_QWORD *)a2 + 4);
    LOBYTE(v27[0]) = 0;
    v28 = 0;
    LOBYTE(v24[0]) = 0;
    v26 = 0;
    v8 = v6;
    v9 = 0;
  }
  result = (const char *)llvm::DWARFDebugMacro::parseImpl(v8, (uint64_t)v27, v24, (uint64_t)&v21, v9, &v20);
  if (v20)
  {
    v18 = v20;
    v20 = 0;
    v15 = *((_QWORD *)v5 + 60);
    if (v15)
    {
      (*(void (**)(uint64_t, const char **))(*(_QWORD *)v15 + 48))(v15, &v18);
      if (v18)
        (*(void (**)(const char *))(*(_QWORD *)v18 + 8))(v18);
      v16 = *a1;
      v17 = **a1;
      *v16 = 0;
      if (v17)
      {
        *(_QWORD *)&v27[0] = v17;
        sub_1C548BD34((void ***)v27);
        MEMORY[0x1CAA32FC0](v17, 0x20C40960023A9);
      }
      result = v20;
      if (v20)
        return (const char *)(*(uint64_t (**)(const char *))(*(_QWORD *)v20 + 8))(v20);
    }
    else
    {
      sub_1C485C2F0();
      return (const char *)llvm::DWARFContext::dump();
    }
  }
  return result;
}

_QWORD *llvm::DWARFContext::dump(uint64_t a1, llvm::raw_ostream *a2, llvm::raw_ostream *a3, uint64_t a4)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t *v17;
  _WORD *v18;
  unint64_t v19;
  uint64_t v20;
  _WORD *v21;
  llvm::raw_ostream *v22;
  size_t v23;
  llvm::Triple *ArchName;
  size_t v25;
  _BYTE *v26;
  _BYTE *v27;
  const void *v28;
  unint64_t v29;
  _BYTE *v30;
  llvm::raw_ostream *v31;
  uint64_t v32;
  uint64_t v33;
  char v34;
  char v35;
  uint64_t v36;
  _BYTE *v37;
  llvm::raw_ostream *v38;
  void *v39;
  uint64_t v40;
  uint64_t **DebugAbbrev;
  uint64_t v42;
  char v43;
  _BYTE *v44;
  llvm::raw_ostream *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t **DebugAbbrevDWO;
  int v49;
  unsigned int v50;
  int v51;
  unsigned int v52;
  unsigned int v53;
  unsigned int v54;
  uint64_t v55;
  char v56;
  _BYTE *v57;
  llvm::raw_ostream *v58;
  uint64_t v59;
  uint64_t v60;
  _QWORD *DebugLoc;
  uint64_t v62;
  uint64_t v63;
  char v64;
  _BYTE *v65;
  llvm::raw_ostream *v66;
  void *v67;
  uint64_t v68;
  uint64_t v69;
  _QWORD *v70;
  char v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  char v75;
  _BYTE *v76;
  llvm::raw_ostream *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  _QWORD *v81;
  char v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  char v86;
  _BYTE *v87;
  llvm::raw_ostream *v88;
  void *v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t *v92;
  char v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  _BYTE *v100;
  uint64_t v101;
  char v102;
  _BYTE *v103;
  llvm::raw_ostream *v104;
  uint64_t v105;
  uint64_t v106;
  _QWORD *v107;
  uint64_t v108;
  uint64_t v109;
  _BYTE *v110;
  llvm::raw_ostream *v111;
  uint64_t v112;
  uint64_t v113;
  _QWORD *v114;
  uint64_t v115;
  uint64_t v116;
  char v117;
  _BYTE *v118;
  llvm::raw_ostream *v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t DebugMacro;
  uint64_t v123;
  _BYTE *v124;
  llvm::raw_ostream *v125;
  _OWORD *v126;
  uint64_t v127;
  uint64_t DebugMacroDWO;
  uint64_t v129;
  _BYTE *v130;
  llvm::raw_ostream *v131;
  void *v132;
  uint64_t v133;
  uint64_t DebugMacinfo;
  uint64_t v135;
  _BYTE *v136;
  llvm::raw_ostream *v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t DebugMacinfoDWO;
  uint64_t v141;
  char v142;
  _BYTE *v143;
  llvm::raw_ostream *v144;
  void *v145;
  uint64_t v146;
  uint64_t v147;
  unint64_t v148;
  unint64_t v149;
  char v150;
  char v151;
  uint64_t v152;
  uint64_t v153;
  char v154;
  _BYTE *v155;
  llvm::raw_ostream *v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  _OWORD *v160;
  char v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  llvm::raw_ostream *v165;
  llvm::raw_ostream *v166;
  _WORD *v167;
  uint64_t v168;
  char v169;
  _BYTE *v170;
  llvm::raw_ostream *v171;
  void *v172;
  uint64_t v173;
  uint64_t v174;
  _OWORD *v175;
  char v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  llvm::raw_ostream *v180;
  llvm::raw_ostream *v181;
  _WORD *v182;
  uint64_t v183;
  char v184;
  _BYTE *v185;
  llvm::raw_ostream *v186;
  void *v187;
  uint64_t v188;
  llvm::raw_ostream *CUIndex;
  uint64_t v190;
  char v191;
  _BYTE *v192;
  llvm::raw_ostream *v193;
  void *v194;
  uint64_t v195;
  llvm::raw_ostream *TUIndex;
  uint64_t v197;
  char v198;
  _BYTE *v199;
  llvm::raw_ostream *v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  unint64_t v204;
  uint64_t v205;
  char v206;
  _BYTE *v207;
  llvm::raw_ostream *v208;
  void *v209;
  uint64_t v210;
  uint64_t v211;
  unint64_t v212;
  uint64_t v213;
  char v214;
  _BYTE *v215;
  llvm::raw_ostream *v216;
  void *v217;
  uint64_t v218;
  uint64_t v219;
  unint64_t v220;
  uint64_t v221;
  char v222;
  _BYTE *v223;
  llvm::raw_ostream *v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  _OWORD *v228;
  char v229;
  int v230;
  int v231;
  unint64_t v232;
  void (**v233)(void);
  uint64_t v234;
  int v235;
  uint64_t v236;
  char v237;
  _BYTE *v238;
  llvm::raw_ostream *v239;
  void *v240;
  uint64_t v241;
  char v242;
  uint64_t v243;
  _QWORD *v244;
  char v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  char v249;
  _BYTE *v250;
  llvm::raw_ostream *v251;
  void *v252;
  uint64_t v253;
  uint64_t v254;
  _OWORD *v255;
  unsigned __int8 v256;
  uint64_t v257;
  char v258;
  _BYTE *v259;
  llvm::raw_ostream *v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  _OWORD *v264;
  unsigned __int8 v265;
  uint64_t v266;
  char v267;
  _BYTE *v268;
  llvm::raw_ostream *v269;
  void *v270;
  uint64_t v271;
  uint64_t v272;
  _QWORD *v273;
  char v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  char v278;
  _BYTE *v279;
  llvm::raw_ostream *v280;
  void *v281;
  uint64_t v282;
  uint64_t v283;
  _QWORD *v284;
  char v285;
  uint64_t v286;
  uint64_t v287;
  uint64_t v288;
  char v289;
  _BYTE *v290;
  llvm::raw_ostream *v291;
  uint64_t v292;
  uint64_t v293;
  uint64_t v294;
  _QWORD *v295;
  char v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  char v300;
  _BYTE *v301;
  llvm::raw_ostream *v302;
  uint64_t v303;
  uint64_t v304;
  uint64_t v305;
  _QWORD *v306;
  char v307;
  uint64_t v308;
  uint64_t v309;
  uint64_t v310;
  char v311;
  _BYTE *v312;
  llvm::raw_ostream *v313;
  uint64_t v314;
  uint64_t v315;
  uint64_t v316;
  _QWORD *v317;
  uint64_t v318;
  uint64_t v319;
  __n128 **v320;
  __n128 **v321;
  __n128 v322;
  char v323;
  uint64_t v324;
  char v325;
  _BYTE *v326;
  llvm::raw_ostream *v327;
  void *v328;
  uint64_t v329;
  uint64_t v330;
  _QWORD *v331;
  uint64_t v332;
  uint64_t v333;
  uint64_t v334;
  __n128 **v335;
  __n128 v336;
  char v337;
  uint64_t v338;
  __n128 v339;
  char v340;
  _BYTE *v341;
  llvm::raw_ostream *v342;
  uint64_t v343;
  uint64_t v344;
  llvm::DWARFGdbIndex *GdbIndex;
  uint64_t v346;
  char v347;
  _BYTE *v348;
  llvm::raw_ostream *v349;
  uint64_t v350;
  uint64_t v351;
  uint64_t v352;
  uint64_t *v353;
  uint64_t v354;
  uint64_t v355;
  char v356;
  uint64_t (***v357)();
  uint64_t v358;
  char v359;
  _BYTE *v360;
  llvm::raw_ostream *v361;
  uint64_t v362;
  uint64_t v363;
  uint64_t v364;
  uint64_t *v365;
  uint64_t v366;
  uint64_t v367;
  char v368;
  uint64_t (***v369)();
  uint64_t v370;
  char v371;
  _BYTE *v372;
  llvm::raw_ostream *v373;
  uint64_t v374;
  uint64_t v375;
  uint64_t v376;
  uint64_t *v377;
  uint64_t v378;
  uint64_t v379;
  char v380;
  uint64_t (***v381)();
  uint64_t v382;
  char v383;
  _BYTE *v384;
  llvm::raw_ostream *v385;
  uint64_t v386;
  uint64_t v387;
  uint64_t v388;
  uint64_t *v389;
  uint64_t v390;
  uint64_t v391;
  char v392;
  uint64_t (***v393)();
  uint64_t v394;
  char v395;
  _BYTE *v396;
  llvm::raw_ostream *v397;
  uint64_t v398;
  uint64_t v399;
  uint64_t DebugNames;
  uint64_t v402;
  BOOL v403;
  uint64_t v404;
  int v405;
  _QWORD v407[2];
  char v408;
  char v409;
  uint64_t v410;
  _QWORD *v411;
  _QWORD v412[2];
  char v413;
  char v414;
  uint64_t v415;
  _QWORD *v416;
  _QWORD v417[2];
  char v418;
  char v419;
  uint64_t v420;
  _QWORD *v421;
  _QWORD v422[2];
  char v423;
  char v424;
  uint64_t v425;
  _QWORD *v426;
  void (**v427)(void);
  uint64_t *v428[3];
  _BYTE v429[25];
  uint64_t *v430[3];
  _BYTE v431[25];
  __int128 v432;
  char v433;
  char v434;
  uint64_t v435;
  _OWORD *v436;
  _QWORD v437[3];
  uint64_t v438;
  _QWORD v439[2];
  char v440;
  char v441;
  uint64_t v442;
  uint64_t v443;
  uint64_t v444;
  uint64_t v445;
  __int128 v446;
  char v447;
  __int128 v448;
  char v449;
  char v450;
  uint64_t v451;
  _QWORD *v452;
  __int128 v453;
  char v454;
  char v455;
  uint64_t v456;
  _QWORD *v457;
  llvm::raw_ostream *v458[3];
  llvm::raw_ostream *v459[3];
  uint64_t v460;
  uint64_t v461;
  unint64_t v462;
  _QWORD *v463;
  void *v464;
  _BYTE v465[32];
  unint64_t v466;
  _QWORD v467[11];
  _QWORD v468[11];
  _QWORD v469[11];
  _QWORD v470[11];
  _QWORD v471[11];
  _QWORD v472[11];
  _QWORD v473[11];
  _QWORD v474[11];
  __int128 v475[3];
  uint64_t v476;
  _QWORD v477[3];
  _QWORD *v478;
  _QWORD v479[2];
  unsigned __int8 v480;
  _BYTE v481[32];
  _QWORD v482[2];
  unsigned __int8 v483;
  _BYTE v484[32];
  __int128 v485[5];
  __int128 v486[5];
  __int128 v487[5];
  _QWORD v488[11];
  _QWORD v489[11];
  _QWORD v490[11];
  __int128 v491[5];
  unsigned __int8 v492[96];
  void (**v493)(void);
  const char *v494;
  uint64_t v495;
  uint64_t *v496;
  _BYTE __p[24];
  __int128 v498;
  void *v499;
  void *v500;
  uint64_t v501;
  uint64_t v502;

  v502 = *MEMORY[0x1E0C80C00];
  v7 = *(_DWORD *)a3;
  v8 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 520) + 16))(*(_QWORD *)(a1 + 520));
  v10 = llvm::sys::path::extension(v8, v9, 0);
  v11 = 0;
  if (v12 == 4)
    v11 = *(_DWORD *)v10 == 1870095406 || *(_DWORD *)v10 == 1886872622;
  v403 = v11;
  v404 = a1;
  v13 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 520) + 24))(*(_QWORD *)(a1 + 520));
  v405 = v7;
  if ((v7 & 0x8000000) != 0)
  {
    v14 = v13;
    if ((*(_DWORD *)(v13 + 8) & 0xFFFFFFFC) == 0x10)
    {
      v15 = *(unsigned int *)(v13 + 136);
      if ((_DWORD)v15)
      {
        v16 = *(uint64_t **)(v13 + 128);
        v17 = &v16[2 * v15];
        do
        {
          if (*((_DWORD *)v16 + 2) == 27)
          {
            v18 = (_WORD *)*((_QWORD *)a2 + 4);
            v19 = *((_QWORD *)a2 + 3) - (_QWORD)v18;
            if (*((_DWORD *)v16 + 3) <= 0x17u)
            {
              if (v19 > 0x26)
              {
                qmemcpy(v18, "error: UUID load command is too short.\n", 39);
                *((_QWORD *)a2 + 4) += 39;
              }
              else
              {
                llvm::raw_ostream::write(a2, "error: UUID load command is too short.\n", 0x27uLL);
              }
              break;
            }
            v20 = *v16;
            if (v19 > 5)
            {
              v18[2] = 8250;
              *(_DWORD *)v18 = 1145656661;
              *((_QWORD *)a2 + 4) += 6;
            }
            else
            {
              llvm::raw_ostream::write(a2, "UUID: ", 6uLL);
            }
            *(_OWORD *)v492 = *(_OWORD *)(v20 + 8);
            llvm::raw_ostream::write_uuid(a2, v492);
            llvm::object::MachOObjectFile::getArchTriple(*(unsigned int *)(v14 + 52), 0, *(_DWORD *)(v14 + 56), 0, __p);
            v21 = (_WORD *)*((_QWORD *)a2 + 4);
            if (*((_QWORD *)a2 + 3) - (_QWORD)v21 > 1uLL)
            {
              *v21 = 10272;
              *((_QWORD *)a2 + 4) += 2;
              v22 = a2;
            }
            else
            {
              v22 = llvm::raw_ostream::write(a2, " (", 2uLL);
            }
            ArchName = llvm::Triple::getArchName((llvm::Triple *)__p);
            v25 = v23;
            v26 = (_BYTE *)*((_QWORD *)v22 + 4);
            if (v23 <= *((_QWORD *)v22 + 3) - (_QWORD)v26)
            {
              if (v23)
              {
                memcpy(v26, ArchName, v23);
                v26 = (_BYTE *)(*((_QWORD *)v22 + 4) + v25);
                *((_QWORD *)v22 + 4) = v26;
              }
            }
            else
            {
              v22 = llvm::raw_ostream::write(v22, (const char *)ArchName, v23);
              v26 = (_BYTE *)*((_QWORD *)v22 + 4);
            }
            if ((unint64_t)v26 >= *((_QWORD *)v22 + 3))
            {
              llvm::raw_ostream::write(v22, 41);
            }
            else
            {
              *((_QWORD *)v22 + 4) = v26 + 1;
              *v26 = 41;
            }
            v27 = (_BYTE *)*((_QWORD *)a2 + 4);
            if ((unint64_t)v27 >= *((_QWORD *)a2 + 3))
            {
              llvm::raw_ostream::write(a2, 32);
            }
            else
            {
              *((_QWORD *)a2 + 4) = v27 + 1;
              *v27 = 32;
            }
            v28 = *(const void **)(v14 + 32);
            v29 = *(_QWORD *)(v14 + 40);
            v30 = (_BYTE *)*((_QWORD *)a2 + 4);
            if (v29 <= *((_QWORD *)a2 + 3) - (_QWORD)v30)
            {
              if (v29)
              {
                memcpy(v30, v28, *(_QWORD *)(v14 + 40));
                v30 = (_BYTE *)(*((_QWORD *)a2 + 4) + v29);
                *((_QWORD *)a2 + 4) = v30;
              }
              v31 = a2;
            }
            else
            {
              v31 = llvm::raw_ostream::write(a2, (const char *)v28, *(_QWORD *)(v14 + 40));
              v30 = (_BYTE *)*((_QWORD *)v31 + 4);
            }
            if ((unint64_t)v30 >= *((_QWORD *)v31 + 3))
            {
              llvm::raw_ostream::write(v31, 10);
            }
            else
            {
              *((_QWORD *)v31 + 4) = v30 + 1;
              *v30 = 10;
            }
            if ((__p[23] & 0x80000000) != 0)
              operator delete(*(void **)__p);
          }
          v16 += 2;
        }
        while (v16 != v17);
      }
    }
  }
  v33 = a1;
  LODWORD(v32) = v405;
  v34 = v405 != -1 && !v403;
  v35 = v34 & v403;
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 520) + 72))(*(_QWORD *)(a1 + 520));
  if ((v405 & 1) == 0 || (v34 & 1) != 0)
  {
    if ((v405 & 1) == 0)
      goto LABEL_56;
  }
  else if (!v36)
  {
    goto LABEL_56;
  }
  v37 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v37)
  {
    v38 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v39 = (void *)*((_QWORD *)v38 + 4);
  }
  else
  {
    *v37 = 10;
    v39 = (void *)(*((_QWORD *)a2 + 4) + 1);
    *((_QWORD *)a2 + 4) = v39;
    v38 = a2;
  }
  if (*((_QWORD *)v38 + 3) - (_QWORD)v39 > 0xCuLL)
  {
    qmemcpy(v39, ".debug_abbrev", 13);
    v40 = *((_QWORD *)v38 + 4) + 13;
    *((_QWORD *)v38 + 4) = v40;
  }
  else
  {
    v38 = llvm::raw_ostream::write(v38, ".debug_abbrev", 0xDuLL);
    v40 = *((_QWORD *)v38 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v38 + 3) - v40) <= 0xA)
  {
    llvm::raw_ostream::write(v38, " contents:\n", 0xBuLL);
    if (!a4)
      goto LABEL_56;
    goto LABEL_55;
  }
  *(_DWORD *)(v40 + 7) = 171602804;
  *(_QWORD *)v40 = *(_QWORD *)" contents:\n";
  *((_QWORD *)v38 + 4) += 11;
  if (a4)
  {
LABEL_55:
    DebugAbbrev = (uint64_t **)llvm::DWARFContext::getDebugAbbrev((llvm::DWARFContext *)a1);
    llvm::DWARFDebugAbbrev::dump(DebugAbbrev, a2);
  }
LABEL_56:
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 520) + 248))(*(_QWORD *)(a1 + 520));
  if ((v405 & 1) != 0)
    v43 = v34 & v403;
  else
    v43 = 1;
  if ((v43 & 1) != 0)
  {
    if ((v405 & 1) == 0)
      goto LABEL_70;
  }
  else if (!v42)
  {
    goto LABEL_70;
  }
  v44 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v44)
  {
    v45 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v46 = *((_QWORD *)v45 + 4);
  }
  else
  {
    *v44 = 10;
    v46 = *((_QWORD *)a2 + 4) + 1;
    *((_QWORD *)a2 + 4) = v46;
    v45 = a2;
  }
  if ((unint64_t)(*((_QWORD *)v45 + 3) - v46) > 0x10)
  {
    *(_BYTE *)(v46 + 16) = 111;
    *(_OWORD *)v46 = *(_OWORD *)".debug_abbrev.dwo";
    v47 = *((_QWORD *)v45 + 4) + 17;
    *((_QWORD *)v45 + 4) = v47;
  }
  else
  {
    v45 = llvm::raw_ostream::write(v45, ".debug_abbrev.dwo", 0x11uLL);
    v47 = *((_QWORD *)v45 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v45 + 3) - v47) <= 0xA)
  {
    llvm::raw_ostream::write(v45, " contents:\n", 0xBuLL);
    if (!a4)
      goto LABEL_70;
    goto LABEL_69;
  }
  *(_DWORD *)(v47 + 7) = 171602804;
  *(_QWORD *)v47 = *(_QWORD *)" contents:\n";
  *((_QWORD *)v45 + 4) += 11;
  if (a4)
  {
LABEL_69:
    DebugAbbrevDWO = (uint64_t **)llvm::DWARFContext::getDebugAbbrevDWO((llvm::DWARFContext *)a1);
    llvm::DWARFDebugAbbrev::dump(DebugAbbrevDWO, a2);
  }
LABEL_70:
  v459[0] = a2;
  v459[1] = (llvm::raw_ostream *)a4;
  v459[2] = a3;
  if ((v405 & 8) == 0)
    goto LABEL_86;
  if ((v34 & 1) != 0)
    goto LABEL_77;
  llvm::DWARFContext::parseNormalUnits(a1);
  v49 = *(_DWORD *)(a1 + 72);
  if (v49 != -1)
  {
    if (!v49)
      goto LABEL_74;
LABEL_77:
    llvm::DWARFContext::parseNormalUnits(a1);
    v50 = *(_DWORD *)(a1 + 72);
    if (v50 == -1)
      v50 = *(_DWORD *)(a1 + 24);
    sub_1C5484650(v459, ".debug_info", *(llvm::DWARFUnit ***)(a1 + 16), (llvm::DWARFUnit **)(*(_QWORD *)(a1 + 16) + 8 * v50));
    if ((v34 & v403 & 1) != 0)
      goto LABEL_83;
    goto LABEL_80;
  }
  if (*(_DWORD *)(a1 + 24))
    goto LABEL_77;
LABEL_74:
  if ((v34 & v403 & 1) != 0)
  {
LABEL_83:
    llvm::DWARFContext::parseDWOUnits(a1, 0);
    v52 = *(_DWORD *)(a1 + 296);
    if (v52 == -1)
      v52 = *(_DWORD *)(a1 + 248);
    sub_1C5484650(v459, ".debug_info.dwo", *(llvm::DWARFUnit ***)(a1 + 240), (llvm::DWARFUnit **)(*(_QWORD *)(a1 + 240) + 8 * v52));
    goto LABEL_86;
  }
LABEL_80:
  llvm::DWARFContext::parseDWOUnits(a1, 0);
  v51 = *(_DWORD *)(a1 + 296);
  if (v51 == -1)
    v51 = *(_DWORD *)(a1 + 248);
  if (v51)
    goto LABEL_83;
LABEL_86:
  v458[0] = a2;
  v458[1] = (llvm::raw_ostream *)a4;
  v458[2] = a3;
  if ((v405 & 0x10) != 0)
  {
    if ((v34 & 1) != 0 || (llvm::DWARFContext::parseNormalUnits(a1), *(_DWORD *)(a1 + 24) != *(_DWORD *)(a1 + 72)))
    {
      llvm::DWARFContext::parseNormalUnits(a1);
      v53 = *(_DWORD *)(a1 + 72);
      if (v53 == -1)
        v53 = *(_DWORD *)(a1 + 24);
      sub_1C548486C(v458, ".debug_types", (llvm::DWARFUnit **)(*(_QWORD *)(a1 + 16) + 8 * v53), (llvm::DWARFUnit **)(*(_QWORD *)(a1 + 16) + 8 * *(unsigned int *)(a1 + 24)));
    }
    if ((v34 & v403 & 1) != 0
      || (llvm::DWARFContext::parseDWOUnits(a1, 0), *(_DWORD *)(a1 + 248) != *(_DWORD *)(a1 + 296)))
    {
      llvm::DWARFContext::parseDWOUnits(a1, 0);
      v54 = *(_DWORD *)(a1 + 296);
      if (v54 == -1)
        v54 = *(_DWORD *)(a1 + 248);
      sub_1C548486C(v458, ".debug_types.dwo", (llvm::DWARFUnit **)(*(_QWORD *)(a1 + 240) + 8 * v54), (llvm::DWARFUnit **)(*(_QWORD *)(a1 + 240) + 8 * *(unsigned int *)(a1 + 248)));
    }
  }
  sub_1C624C4A4((uint64_t)v492, (__int128 *)a3);
  if (v492[20])
    v492[21] = 1;
  v55 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 520) + 80))(*(_QWORD *)(a1 + 520));
  if ((v405 & 0x80) != 0)
    v56 = v34;
  else
    v56 = 1;
  if ((v56 & 1) != 0)
  {
    if ((v405 & 0x80) == 0)
      goto LABEL_113;
  }
  else if (!*(_QWORD *)(v55 + 8))
  {
    goto LABEL_113;
  }
  v57 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v57)
  {
    v58 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v59 = *((_QWORD *)v58 + 4);
  }
  else
  {
    *v57 = 10;
    v59 = *((_QWORD *)a2 + 4) + 1;
    *((_QWORD *)a2 + 4) = v59;
    v58 = a2;
  }
  if ((unint64_t)(*((_QWORD *)v58 + 3) - v59) > 9)
  {
    *(_WORD *)(v59 + 8) = 25455;
    *(_QWORD *)v59 = *(_QWORD *)".debug_loc";
    v60 = *((_QWORD *)v58 + 4) + 10;
    *((_QWORD *)v58 + 4) = v60;
  }
  else
  {
    v58 = llvm::raw_ostream::write(v58, ".debug_loc", 0xAuLL);
    v60 = *((_QWORD *)v58 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v58 + 3) - v60) > 0xA)
  {
    *(_DWORD *)(v60 + 7) = 171602804;
    *(_QWORD *)v60 = *(_QWORD *)" contents:\n";
    *((_QWORD *)v58 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v58, " contents:\n", 0xBuLL);
  }
  DebugLoc = (_QWORD *)llvm::DWARFContext::getDebugLoc((llvm::DWARFContext *)a1);
  v62 = *(_QWORD *)(a1 + 448);
  v32 = *(_QWORD *)(a1 + 520);
  sub_1C624C4A4((uint64_t)v491, (__int128 *)v492);
  llvm::DWARFDebugLoc::dump(DebugLoc, a2, v62, v32, v491, *(_QWORD *)(a4 + 112), *(_QWORD *)(a4 + 120));
  sub_1C624C568(v491);
  LODWORD(v32) = v405;
LABEL_113:
  v63 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 520) + 88))(*(_QWORD *)(a1 + 520));
  if ((v32 & 0x100) != 0)
    v64 = v34;
  else
    v64 = 1;
  if ((v64 & 1) != 0)
  {
    if ((v32 & 0x100) == 0)
      goto LABEL_127;
  }
  else if (!*(_QWORD *)(v63 + 8))
  {
    goto LABEL_127;
  }
  v65 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v65)
  {
    v66 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v67 = (void *)*((_QWORD *)v66 + 4);
  }
  else
  {
    *v65 = 10;
    v67 = (void *)(*((_QWORD *)a2 + 4) + 1);
    *((_QWORD *)a2 + 4) = v67;
    v66 = a2;
  }
  if (*((_QWORD *)v66 + 3) - (_QWORD)v67 > 0xEuLL)
  {
    qmemcpy(v67, ".debug_loclists", 15);
    v68 = *((_QWORD *)v66 + 4) + 15;
    *((_QWORD *)v66 + 4) = v68;
  }
  else
  {
    v66 = llvm::raw_ostream::write(v66, ".debug_loclists", 0xFuLL);
    v68 = *((_QWORD *)v66 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v66 + 3) - v68) > 0xA)
  {
    *(_DWORD *)(v68 + 7) = 171602804;
    *(_QWORD *)v68 = *(_QWORD *)" contents:\n";
    *((_QWORD *)v66 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v66, " contents:\n", 0xBuLL);
  }
  v69 = *(_QWORD *)(a1 + 520);
  v70 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v69 + 88))(v69);
  v71 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 520) + 40))(*(_QWORD *)(a1 + 520));
  v72 = *v70;
  v73 = v70[1];
  sub_1C624C4A4((uint64_t)v490, (__int128 *)v492);
  *(_QWORD *)&v453 = v72;
  *((_QWORD *)&v453 + 1) = v73;
  v454 = v71;
  v455 = 0;
  v456 = v69;
  v457 = v70;
  sub_1C5484BBC(a2, (uint64_t)v490, &v453, *(_QWORD *)(v404 + 448), *(_QWORD *)(v404 + 520), *(_QWORD *)(a4 + 128), *(_QWORD *)(a4 + 136));
  sub_1C624C568(v490);
  LODWORD(v32) = v405;
LABEL_127:
  v74 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v404 + 520) + 272))(*(_QWORD *)(v404 + 520));
  if ((v32 & 0x100) != 0)
    v75 = v34 & v403;
  else
    v75 = 1;
  if ((v75 & 1) != 0)
  {
    if ((v32 & 0x100) == 0)
      goto LABEL_141;
  }
  else if (!*(_QWORD *)(v74 + 8))
  {
    goto LABEL_141;
  }
  v76 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v76)
  {
    v77 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v78 = *((_QWORD *)v77 + 4);
  }
  else
  {
    *v76 = 10;
    v78 = *((_QWORD *)a2 + 4) + 1;
    *((_QWORD *)a2 + 4) = v78;
    v77 = a2;
  }
  if ((unint64_t)(*((_QWORD *)v77 + 3) - v78) > 0x12)
  {
    *(_DWORD *)(v78 + 15) = 1870095406;
    *(_OWORD *)v78 = *(_OWORD *)".debug_loclists.dwo";
    v79 = *((_QWORD *)v77 + 4) + 19;
    *((_QWORD *)v77 + 4) = v79;
  }
  else
  {
    v77 = llvm::raw_ostream::write(v77, ".debug_loclists.dwo", 0x13uLL);
    v79 = *((_QWORD *)v77 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v77 + 3) - v79) > 0xA)
  {
    *(_DWORD *)(v79 + 7) = 171602804;
    *(_QWORD *)v79 = *(_QWORD *)" contents:\n";
    *((_QWORD *)v77 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v77, " contents:\n", 0xBuLL);
  }
  v80 = *(_QWORD *)(v404 + 520);
  v81 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v80 + 272))(v80);
  v82 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v404 + 520) + 40))(*(_QWORD *)(v404 + 520));
  v83 = *v81;
  v84 = v81[1];
  sub_1C624C4A4((uint64_t)v489, (__int128 *)v492);
  *(_QWORD *)&v448 = v83;
  *((_QWORD *)&v448 + 1) = v84;
  v449 = v82;
  v450 = 0;
  v451 = v80;
  v452 = v81;
  sub_1C5484BBC(a2, (uint64_t)v489, &v448, *(_QWORD *)(v404 + 448), *(_QWORD *)(v404 + 520), *(_QWORD *)(a4 + 128), *(_QWORD *)(a4 + 136));
  sub_1C624C568(v489);
  LODWORD(v32) = v405;
LABEL_141:
  v85 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v404 + 520) + 264))(*(_QWORD *)(v404 + 520));
  if ((v32 & 0x80) != 0)
    v86 = v34 & v403;
  else
    v86 = 1;
  if ((v86 & 1) != 0)
  {
    if ((v32 & 0x80) == 0)
      goto LABEL_159;
  }
  else if (!*(_QWORD *)(v85 + 8))
  {
    goto LABEL_159;
  }
  v87 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v87)
  {
    v88 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v89 = (void *)*((_QWORD *)v88 + 4);
  }
  else
  {
    *v87 = 10;
    v89 = (void *)(*((_QWORD *)a2 + 4) + 1);
    *((_QWORD *)a2 + 4) = v89;
    v88 = a2;
  }
  if (*((_QWORD *)v88 + 3) - (_QWORD)v89 > 0xDuLL)
  {
    qmemcpy(v89, ".debug_loc.dwo", 14);
    v90 = *((_QWORD *)v88 + 4) + 14;
    *((_QWORD *)v88 + 4) = v90;
  }
  else
  {
    v88 = llvm::raw_ostream::write(v88, ".debug_loc.dwo", 0xEuLL);
    v90 = *((_QWORD *)v88 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v88 + 3) - v90) > 0xA)
  {
    *(_DWORD *)(v90 + 7) = 171602804;
    *(_QWORD *)v90 = *(_QWORD *)" contents:\n";
    *((_QWORD *)v88 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v88, " contents:\n", 0xBuLL);
  }
  v91 = *(_QWORD *)(v404 + 520);
  v92 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v91 + 264))(v91);
  v93 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v404 + 520) + 40))(*(_QWORD *)(v404 + 520));
  v94 = *v92;
  v95 = v92[1];
  *(_QWORD *)&__p[16] = v95;
  LOBYTE(v498) = v93;
  BYTE1(v498) = 4;
  *((_QWORD *)&v498 + 1) = v91;
  v499 = v92;
  *(_QWORD *)&__p[8] = v94;
  *(_QWORD *)__p = &unk_1E816A040;
  LOWORD(v500) = 4;
  if (*(_BYTE *)(a4 + 120))
  {
    v462 = *(_QWORD *)(a4 + 112);
    LOBYTE(v446) = 0;
    v447 = 0;
    v98 = *(_QWORD *)(v404 + 448);
    v99 = *(_QWORD *)(v404 + 520);
    sub_1C624C4A4((uint64_t)v488, (__int128 *)v492);
    LODWORD(v402) = 0;
    llvm::DWARFLocationTable::dumpLocationList((uint64_t)__p, (uint64_t *)&v462, a2, &v446, v98, v99, 0, (uint64_t)v488, v402);
    sub_1C624C568(v488);
    v100 = (_BYTE *)*((_QWORD *)a2 + 4);
    if (*((_BYTE **)a2 + 3) == v100)
    {
      llvm::raw_ostream::write(a2, "\n", 1uLL);
    }
    else
    {
      *v100 = 10;
      ++*((_QWORD *)a2 + 4);
    }
  }
  else
  {
    v96 = *(_QWORD *)(v404 + 448);
    v97 = *(_QWORD *)(v404 + 520);
    sub_1C624C4A4((uint64_t)v487, (__int128 *)v492);
    llvm::DWARFDebugLoclists::dumpRange((uint64_t)__p, 0, v95, a2, v96, v97, v487);
    sub_1C624C568(v487);
  }
  LODWORD(v32) = v405;
LABEL_159:
  v101 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v404 + 520) + 104))(*(_QWORD *)(v404 + 520));
  if ((v32 & 0x200) != 0)
    v102 = v34;
  else
    v102 = 1;
  if ((v102 & 1) != 0)
  {
    if ((v32 & 0x200) == 0)
      goto LABEL_177;
  }
  else if (!*(_QWORD *)(v101 + 8))
  {
    goto LABEL_177;
  }
  v103 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v103)
  {
    v104 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v105 = *((_QWORD *)v104 + 4);
  }
  else
  {
    *v103 = 10;
    v105 = *((_QWORD *)a2 + 4) + 1;
    *((_QWORD *)a2 + 4) = v105;
    v104 = a2;
  }
  if ((unint64_t)(*((_QWORD *)v104 + 3) - v105) > 0xB)
  {
    *(_DWORD *)(v105 + 8) = 1701667186;
    *(_QWORD *)v105 = *(_QWORD *)".debug_frame";
    v106 = *((_QWORD *)v104 + 4) + 12;
    *((_QWORD *)v104 + 4) = v106;
  }
  else
  {
    v104 = llvm::raw_ostream::write(v104, ".debug_frame", 0xCuLL);
    v106 = *((_QWORD *)v104 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v104 + 3) - v106) > 0xA)
  {
    *(_DWORD *)(v106 + 7) = 171602804;
    *(_QWORD *)v106 = *(_QWORD *)" contents:\n";
    *((_QWORD *)v104 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v104, " contents:\n", 0xBuLL);
  }
  llvm::DWARFContext::getDebugFrame(v404, (uint64_t)__p);
  if ((__p[8] & 1) != 0)
  {
    v445 = *(_QWORD *)__p;
    v108 = *(_QWORD *)(v404 + 480);
    if (!v108)
      goto LABEL_776;
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v108 + 48))(v108, &v445);
    if (v445)
      (*(void (**)(uint64_t))(*(_QWORD *)v445 + 8))(v445);
  }
  else
  {
    v107 = *(_QWORD **)__p;
    sub_1C624C4A4((uint64_t)v486, (__int128 *)a3);
    llvm::DWARFDebugFrame::dump(v107, a2, v486, *(_QWORD *)(v404 + 448), *(_QWORD *)(a4 + 144), *(_QWORD *)(a4 + 152));
    sub_1C624C568(v486);
  }
LABEL_177:
  v109 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v404 + 520) + 112))(*(_QWORD *)(v404 + 520));
  if ((v102 & 1) != 0)
  {
    if ((v32 & 0x200) == 0)
      goto LABEL_192;
  }
  else if (!*(_QWORD *)(v109 + 8))
  {
    goto LABEL_192;
  }
  v110 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v110)
  {
    v111 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v112 = *((_QWORD *)v111 + 4);
  }
  else
  {
    *v110 = 10;
    v112 = *((_QWORD *)a2 + 4) + 1;
    *((_QWORD *)a2 + 4) = v112;
    v111 = a2;
  }
  if ((unint64_t)(*((_QWORD *)v111 + 3) - v112) > 8)
  {
    *(_BYTE *)(v112 + 8) = 101;
    *(_QWORD *)v112 = *(_QWORD *)".eh_frame";
    v113 = *((_QWORD *)v111 + 4) + 9;
    *((_QWORD *)v111 + 4) = v113;
  }
  else
  {
    v111 = llvm::raw_ostream::write(v111, ".eh_frame", 9uLL);
    v113 = *((_QWORD *)v111 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v111 + 3) - v113) > 0xA)
  {
    *(_DWORD *)(v113 + 7) = 171602804;
    *(_QWORD *)v113 = *(_QWORD *)" contents:\n";
    *((_QWORD *)v111 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v111, " contents:\n", 0xBuLL);
  }
  llvm::DWARFContext::getEHFrame(v404, (uint64_t)__p);
  if ((__p[8] & 1) != 0)
  {
    v444 = *(_QWORD *)__p;
    v115 = *(_QWORD *)(v404 + 480);
    if (!v115)
      goto LABEL_776;
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v115 + 48))(v115, &v444);
    if (v444)
      (*(void (**)(uint64_t))(*(_QWORD *)v444 + 8))(v444);
  }
  else
  {
    v114 = *(_QWORD **)__p;
    sub_1C624C4A4((uint64_t)v485, (__int128 *)a3);
    llvm::DWARFDebugFrame::dump(v114, a2, v485, *(_QWORD *)(v404 + 448), *(_QWORD *)(a4 + 144), *(_QWORD *)(a4 + 152));
    sub_1C624C568(v485);
  }
LABEL_192:
  v116 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v404 + 520) + 160))(*(_QWORD *)(v404 + 520));
  if ((v32 & 0x400) != 0)
    v117 = v34;
  else
    v117 = 1;
  if ((v117 & 1) != 0)
  {
    if ((v32 & 0x400) == 0)
      goto LABEL_207;
  }
  else if (!*(_QWORD *)(v116 + 8))
  {
    goto LABEL_207;
  }
  v118 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v118)
  {
    v119 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v120 = *((_QWORD *)v119 + 4);
  }
  else
  {
    *v118 = 10;
    v120 = *((_QWORD *)a2 + 4) + 1;
    *((_QWORD *)a2 + 4) = v120;
    v119 = a2;
  }
  if ((unint64_t)(*((_QWORD *)v119 + 3) - v120) > 0xB)
  {
    *(_DWORD *)(v120 + 8) = 1869767521;
    *(_QWORD *)v120 = *(_QWORD *)".debug_macro";
    v121 = *((_QWORD *)v119 + 4) + 12;
    *((_QWORD *)v119 + 4) = v121;
  }
  else
  {
    v119 = llvm::raw_ostream::write(v119, ".debug_macro", 0xCuLL);
    v121 = *((_QWORD *)v119 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v119 + 3) - v121) > 0xA)
  {
    *(_DWORD *)(v121 + 7) = 171602804;
    *(_QWORD *)v121 = *(_QWORD *)" contents:\n";
    *((_QWORD *)v119 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v119, " contents:\n", 0xBuLL);
  }
  DebugMacro = llvm::DWARFContext::getDebugMacro((llvm::DWARFContext *)v404);
  if (DebugMacro)
    llvm::DWARFDebugMacro::dump(DebugMacro, a2);
LABEL_207:
  (*(void (**)(_QWORD))(**(_QWORD **)(v404 + 520) + 168))(*(_QWORD *)(v404 + 520));
  if ((v117 & 1) != 0)
  {
    if ((v32 & 0x400) == 0)
      goto LABEL_219;
  }
  else if (!v123)
  {
    goto LABEL_219;
  }
  v124 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v124)
  {
    v125 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v126 = (_OWORD *)*((_QWORD *)v125 + 4);
  }
  else
  {
    *v124 = 10;
    v126 = (_OWORD *)(*((_QWORD *)a2 + 4) + 1);
    *((_QWORD *)a2 + 4) = v126;
    v125 = a2;
  }
  if (*((_QWORD *)v125 + 3) - (_QWORD)v126 > 0xFuLL)
  {
    *v126 = *(_OWORD *)".debug_macro.dwo";
    v127 = *((_QWORD *)v125 + 4) + 16;
    *((_QWORD *)v125 + 4) = v127;
  }
  else
  {
    v125 = llvm::raw_ostream::write(v125, ".debug_macro.dwo", 0x10uLL);
    v127 = *((_QWORD *)v125 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v125 + 3) - v127) > 0xA)
  {
    *(_DWORD *)(v127 + 7) = 171602804;
    *(_QWORD *)v127 = *(_QWORD *)" contents:\n";
    *((_QWORD *)v125 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v125, " contents:\n", 0xBuLL);
  }
  DebugMacroDWO = llvm::DWARFContext::getDebugMacroDWO((llvm::DWARFContext *)v404);
  if (DebugMacroDWO)
    llvm::DWARFDebugMacro::dump(DebugMacroDWO, a2);
LABEL_219:
  (*(void (**)(_QWORD))(**(_QWORD **)(v404 + 520) + 176))(*(_QWORD *)(v404 + 520));
  if ((v117 & 1) != 0)
  {
    if ((v32 & 0x400) == 0)
      goto LABEL_231;
  }
  else if (!v129)
  {
    goto LABEL_231;
  }
  v130 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v130)
  {
    v131 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v132 = (void *)*((_QWORD *)v131 + 4);
  }
  else
  {
    *v130 = 10;
    v132 = (void *)(*((_QWORD *)a2 + 4) + 1);
    *((_QWORD *)a2 + 4) = v132;
    v131 = a2;
  }
  if (*((_QWORD *)v131 + 3) - (_QWORD)v132 > 0xDuLL)
  {
    qmemcpy(v132, ".debug_macinfo", 14);
    v133 = *((_QWORD *)v131 + 4) + 14;
    *((_QWORD *)v131 + 4) = v133;
  }
  else
  {
    v131 = llvm::raw_ostream::write(v131, ".debug_macinfo", 0xEuLL);
    v133 = *((_QWORD *)v131 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v131 + 3) - v133) > 0xA)
  {
    *(_DWORD *)(v133 + 7) = 171602804;
    *(_QWORD *)v133 = *(_QWORD *)" contents:\n";
    *((_QWORD *)v131 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v131, " contents:\n", 0xBuLL);
  }
  DebugMacinfo = llvm::DWARFContext::getDebugMacinfo((llvm::DWARFContext *)v404);
  if (DebugMacinfo)
    llvm::DWARFDebugMacro::dump(DebugMacinfo, a2);
LABEL_231:
  (*(void (**)(_QWORD))(**(_QWORD **)(v404 + 520) + 184))(*(_QWORD *)(v404 + 520));
  if ((v117 & 1) != 0)
  {
    if ((v32 & 0x400) == 0)
      goto LABEL_243;
  }
  else if (!v135)
  {
    goto LABEL_243;
  }
  v136 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v136)
  {
    v137 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v138 = *((_QWORD *)v137 + 4);
  }
  else
  {
    *v136 = 10;
    v138 = *((_QWORD *)a2 + 4) + 1;
    *((_QWORD *)a2 + 4) = v138;
    v137 = a2;
  }
  if ((unint64_t)(*((_QWORD *)v137 + 3) - v138) > 0x11)
  {
    *(_WORD *)(v138 + 16) = 28535;
    *(_OWORD *)v138 = *(_OWORD *)".debug_macinfo.dwo";
    v139 = *((_QWORD *)v137 + 4) + 18;
    *((_QWORD *)v137 + 4) = v139;
  }
  else
  {
    v137 = llvm::raw_ostream::write(v137, ".debug_macinfo.dwo", 0x12uLL);
    v139 = *((_QWORD *)v137 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v137 + 3) - v139) > 0xA)
  {
    *(_DWORD *)(v139 + 7) = 171602804;
    *(_QWORD *)v139 = *(_QWORD *)" contents:\n";
    *((_QWORD *)v137 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v137, " contents:\n", 0xBuLL);
  }
  DebugMacinfoDWO = llvm::DWARFContext::getDebugMacinfoDWO((llvm::DWARFContext *)v404);
  if (DebugMacinfoDWO)
    llvm::DWARFDebugMacro::dump(DebugMacinfoDWO, a2);
LABEL_243:
  (*(void (**)(_QWORD))(**(_QWORD **)(v404 + 520) + 96))(*(_QWORD *)(v404 + 520));
  if ((v32 & 4) != 0)
    v142 = v34;
  else
    v142 = 1;
  if ((v142 & 1) != 0)
  {
    if ((v32 & 4) == 0)
      goto LABEL_269;
  }
  else if (!v141)
  {
    goto LABEL_269;
  }
  v143 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v143)
  {
    v144 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v145 = (void *)*((_QWORD *)v144 + 4);
  }
  else
  {
    *v143 = 10;
    v145 = (void *)(*((_QWORD *)a2 + 4) + 1);
    *((_QWORD *)a2 + 4) = v145;
    v144 = a2;
  }
  if (*((_QWORD *)v144 + 3) - (_QWORD)v145 > 0xDuLL)
  {
    qmemcpy(v145, ".debug_aranges", 14);
    v146 = *((_QWORD *)v144 + 4) + 14;
    *((_QWORD *)v144 + 4) = v146;
  }
  else
  {
    v144 = llvm::raw_ostream::write(v144, ".debug_aranges", 0xEuLL);
    v146 = *((_QWORD *)v144 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v144 + 3) - v146) > 0xA)
  {
    *(_DWORD *)(v146 + 7) = 171602804;
    *(_QWORD *)v146 = *(_QWORD *)" contents:\n";
    *((_QWORD *)v144 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v144, " contents:\n", 0xBuLL);
  }
  v462 = 0;
  v147 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v404 + 520) + 96))(*(_QWORD *)(v404 + 520));
  v149 = v148;
  v150 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v404 + 520) + 40))(*(_QWORD *)(v404 + 520));
  v500 = 0;
  v501 = 0;
  v499 = 0;
  *(_QWORD *)__p = -1;
  *(_OWORD *)&__p[8] = 0u;
  v498 = 0u;
  if (v149 > v462)
  {
    v151 = v150;
    while (1)
    {
      v439[0] = v147;
      v439[1] = v149;
      v440 = v151;
      v441 = 0;
      v442 = 0;
      v443 = 0;
      llvm::DWARFDebugArangeSet::extract((unint64_t *)__p, v439, &v462, (void (*)(uint64_t, void (***)(llvm::raw_ostream *__hidden)))sub_1C624E09C, (uint64_t)a3 + 56, (uint64_t *)&v432);
      if ((_QWORD)v432)
        break;
      llvm::DWARFDebugArangeSet::dump((llvm::DWARFDebugArangeSet *)__p, a2);
      if (v149 <= v462)
        goto LABEL_266;
    }
    v438 = v432;
    *(_QWORD *)&v432 = 0;
    v152 = *(_QWORD *)(v404 + 480);
    if (!v152)
      goto LABEL_776;
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v152 + 48))(v152, &v438);
    if (v438)
      (*(void (**)(uint64_t))(*(_QWORD *)v438 + 8))(v438);
    if ((_QWORD)v432)
      (*(void (**)(_QWORD))(*(_QWORD *)v432 + 8))(v432);
  }
LABEL_266:
  if (v499)
  {
    v500 = v499;
    operator delete(v499);
  }
  LODWORD(v32) = v405;
LABEL_269:
  v437[0] = v404;
  v437[1] = a3;
  v437[2] = a2;
  v153 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v404 + 520) + 120))(*(_QWORD *)(v404 + 520));
  if ((v32 & 0x20) != 0)
    v154 = v34;
  else
    v154 = 1;
  if ((v154 & 1) != 0)
  {
    if ((v32 & 0x20) == 0)
      goto LABEL_297;
  }
  else if (!*(_QWORD *)(v153 + 8))
  {
    goto LABEL_297;
  }
  v155 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v155)
  {
    v156 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v157 = *((_QWORD *)v156 + 4);
  }
  else
  {
    *v155 = 10;
    v157 = *((_QWORD *)a2 + 4) + 1;
    *((_QWORD *)a2 + 4) = v157;
    v156 = a2;
  }
  if ((unint64_t)(*((_QWORD *)v156 + 3) - v157) > 0xA)
  {
    *(_DWORD *)(v157 + 7) = 1701734764;
    *(_QWORD *)v157 = *(_QWORD *)".debug_line";
    v158 = *((_QWORD *)v156 + 4) + 11;
    *((_QWORD *)v156 + 4) = v158;
  }
  else
  {
    v156 = llvm::raw_ostream::write(v156, ".debug_line", 0xBuLL);
    v158 = *((_QWORD *)v156 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v156 + 3) - v158) > 0xA)
  {
    *(_DWORD *)(v158 + 7) = 171602804;
    *(_QWORD *)v158 = *(_QWORD *)" contents:\n";
    *((_QWORD *)v156 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v156, " contents:\n", 0xBuLL);
  }
  v159 = *(_QWORD *)(v404 + 520);
  v160 = (_OWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v159 + 120))(v159);
  v161 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v404 + 520) + 40))(*(_QWORD *)(v404 + 520));
  v432 = *v160;
  v433 = v161;
  v434 = 0;
  v435 = v159;
  v436 = v160;
  llvm::DWARFContext::parseNormalUnits(v404);
  llvm::DWARFDebugLine::SectionParser::SectionParser((uint64_t)&v462, (uint64_t)&v432, v404, *(llvm::DWARFUnit ***)(v404 + 16), (llvm::DWARFUnit **)(*(_QWORD *)(v404 + 16) + 8 * *(unsigned int *)(v404 + 24)));
  sub_1C548BDB0(v430, &v462);
  *(_OWORD *)v431 = *(_OWORD *)v465;
  *(_OWORD *)&v431[9] = *(_OWORD *)&v465[9];
  sub_1C624C4A4((uint64_t)v482, (__int128 *)a3);
  if (!v431[24])
  {
    v162 = *(_QWORD *)(a4 + 80);
    v163 = *(unsigned __int8 *)(a4 + 88);
    do
    {
      if (!v163 || *(_QWORD *)&v431[16] == v162)
      {
        v164 = *((_QWORD *)a2 + 4);
        if ((unint64_t)(*((_QWORD *)a2 + 3) - v164) > 0xA)
        {
          *(_DWORD *)(v164 + 7) = 1533374057;
          *(_QWORD *)v164 = *(_QWORD *)"debug_line[";
          *((_QWORD *)a2 + 4) += 11;
          v165 = a2;
        }
        else
        {
          v165 = llvm::raw_ostream::write(a2, "debug_line[", 0xBuLL);
        }
        v493 = (void (**)(void))&unk_1E8133270;
        v494 = "0x%8.8llx";
        v495 = *(_QWORD *)&v431[16];
        v166 = llvm::raw_ostream::operator<<(v165, (uint64_t)&v493);
        v167 = (_WORD *)*((_QWORD *)v166 + 4);
        if (*((_QWORD *)v166 + 3) - (_QWORD)v167 > 1uLL)
        {
          *v167 = 2653;
          *((_QWORD *)v166 + 4) += 2;
        }
        else
        {
          llvm::raw_ostream::write(v166, "]\n", 2uLL);
        }
        llvm::DWARFDebugLine::SectionParser::parseNext((uint64_t)v430, (void (*)(uint64_t, __int128 *))sub_1C624E09C, (uint64_t)v484, (void (*)(uint64_t, uint64_t *))sub_1C624E09C, (uint64_t)v484, a2, v483, (uint64_t)__p);
        sub_1C624DF80(__p);
      }
      else
      {
        llvm::DWARFDebugLine::SectionParser::skip((uint64_t)v430, (void (*)(uint64_t, __int128 *))sub_1C624E09C, (uint64_t)v484, (void (*)(uint64_t, uint64_t *))sub_1C624E09C, (uint64_t)v484);
      }
    }
    while (!v431[24]);
  }
  sub_1C624C568(v482);
  sub_1C4FE319C((uint64_t)v430, v430[1]);
  sub_1C4FE319C((uint64_t)&v462, v463);
  v33 = v404;
  LODWORD(v32) = v405;
LABEL_297:
  v168 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 256))(*(_QWORD *)(v33 + 520));
  if ((v32 & 0x20) != 0)
    v169 = v34 & v403;
  else
    v169 = 1;
  if ((v169 & 1) != 0)
  {
    if ((v32 & 0x20) == 0)
      goto LABEL_325;
  }
  else if (!*(_QWORD *)(v168 + 8))
  {
    goto LABEL_325;
  }
  v170 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v170)
  {
    v171 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v172 = (void *)*((_QWORD *)v171 + 4);
  }
  else
  {
    *v170 = 10;
    v172 = (void *)(*((_QWORD *)a2 + 4) + 1);
    *((_QWORD *)a2 + 4) = v172;
    v171 = a2;
  }
  if (*((_QWORD *)v171 + 3) - (_QWORD)v172 > 0xEuLL)
  {
    qmemcpy(v172, ".debug_line.dwo", 15);
    v173 = *((_QWORD *)v171 + 4) + 15;
    *((_QWORD *)v171 + 4) = v173;
  }
  else
  {
    v171 = llvm::raw_ostream::write(v171, ".debug_line.dwo", 0xFuLL);
    v173 = *((_QWORD *)v171 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v171 + 3) - v173) > 0xA)
  {
    *(_DWORD *)(v173 + 7) = 171602804;
    *(_QWORD *)v173 = *(_QWORD *)" contents:\n";
    *((_QWORD *)v171 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v171, " contents:\n", 0xBuLL);
  }
  v174 = *(_QWORD *)(v33 + 520);
  v175 = (_OWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v174 + 256))(v174);
  v176 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 40))(*(_QWORD *)(v33 + 520));
  v432 = *v175;
  v433 = v176;
  v434 = 0;
  v435 = v174;
  v436 = v175;
  llvm::DWARFContext::parseDWOUnits(v33, 0);
  llvm::DWARFDebugLine::SectionParser::SectionParser((uint64_t)&v462, (uint64_t)&v432, v33, *(llvm::DWARFUnit ***)(v33 + 240), (llvm::DWARFUnit **)(*(_QWORD *)(v33 + 240) + 8 * *(unsigned int *)(v33 + 248)));
  sub_1C548BDB0(v428, &v462);
  *(_OWORD *)v429 = *(_OWORD *)v465;
  *(_OWORD *)&v429[9] = *(_OWORD *)&v465[9];
  sub_1C624C4A4((uint64_t)v479, (__int128 *)a3);
  if (!v429[24])
  {
    v177 = *(_QWORD *)(a4 + 80);
    v178 = *(unsigned __int8 *)(a4 + 88);
    do
    {
      if (!v178 || *(_QWORD *)&v429[16] == v177)
      {
        v179 = *((_QWORD *)a2 + 4);
        if ((unint64_t)(*((_QWORD *)a2 + 3) - v179) > 0xA)
        {
          *(_DWORD *)(v179 + 7) = 1533374057;
          *(_QWORD *)v179 = *(_QWORD *)"debug_line[";
          *((_QWORD *)a2 + 4) += 11;
          v180 = a2;
        }
        else
        {
          v180 = llvm::raw_ostream::write(a2, "debug_line[", 0xBuLL);
        }
        v493 = (void (**)(void))&unk_1E8133270;
        v494 = "0x%8.8llx";
        v495 = *(_QWORD *)&v429[16];
        v181 = llvm::raw_ostream::operator<<(v180, (uint64_t)&v493);
        v182 = (_WORD *)*((_QWORD *)v181 + 4);
        if (*((_QWORD *)v181 + 3) - (_QWORD)v182 > 1uLL)
        {
          *v182 = 2653;
          *((_QWORD *)v181 + 4) += 2;
        }
        else
        {
          llvm::raw_ostream::write(v181, "]\n", 2uLL);
        }
        llvm::DWARFDebugLine::SectionParser::parseNext((uint64_t)v428, (void (*)(uint64_t, __int128 *))sub_1C624E09C, (uint64_t)v481, (void (*)(uint64_t, uint64_t *))sub_1C624E09C, (uint64_t)v481, a2, v480, (uint64_t)__p);
        sub_1C624DF80(__p);
      }
      else
      {
        llvm::DWARFDebugLine::SectionParser::skip((uint64_t)v428, (void (*)(uint64_t, __int128 *))sub_1C624E09C, (uint64_t)v481, (void (*)(uint64_t, uint64_t *))sub_1C624E09C, (uint64_t)v481);
      }
    }
    while (!v429[24]);
  }
  sub_1C624C568(v479);
  sub_1C4FE319C((uint64_t)v428, v428[1]);
  sub_1C4FE319C((uint64_t)&v462, v463);
  v33 = v404;
  LODWORD(v32) = v405;
LABEL_325:
  (*(void (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 360))(*(_QWORD *)(v33 + 520));
  if ((v32 & 0x100000) != 0)
    v184 = v34;
  else
    v184 = 1;
  if ((v184 & 1) != 0)
  {
    if ((v32 & 0x100000) == 0)
      goto LABEL_339;
  }
  else if (!v183)
  {
    goto LABEL_339;
  }
  v185 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v185)
  {
    v186 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v187 = (void *)*((_QWORD *)v186 + 4);
  }
  else
  {
    *v185 = 10;
    v187 = (void *)(*((_QWORD *)a2 + 4) + 1);
    *((_QWORD *)a2 + 4) = v187;
    v186 = a2;
  }
  if (*((_QWORD *)v186 + 3) - (_QWORD)v187 > 0xEuLL)
  {
    qmemcpy(v187, ".debug_cu_index", 15);
    v188 = *((_QWORD *)v186 + 4) + 15;
    *((_QWORD *)v186 + 4) = v188;
  }
  else
  {
    v186 = llvm::raw_ostream::write(v186, ".debug_cu_index", 0xFuLL);
    v188 = *((_QWORD *)v186 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v186 + 3) - v188) > 0xA)
  {
    *(_DWORD *)(v188 + 7) = 171602804;
    *(_QWORD *)v188 = *(_QWORD *)" contents:\n";
    *((_QWORD *)v186 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v186, " contents:\n", 0xBuLL);
  }
  CUIndex = (llvm::raw_ostream *)llvm::DWARFContext::getCUIndex((llvm::DWARFContext *)v33);
  llvm::DWARFUnitIndex::dump(CUIndex, a2);
LABEL_339:
  (*(void (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 376))(*(_QWORD *)(v33 + 520));
  if ((v32 & 0x200000) != 0)
    v191 = v34;
  else
    v191 = 1;
  if ((v191 & 1) != 0)
  {
    if ((v32 & 0x200000) == 0)
      goto LABEL_353;
  }
  else if (!v190)
  {
    goto LABEL_353;
  }
  v192 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v192)
  {
    v193 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v194 = (void *)*((_QWORD *)v193 + 4);
  }
  else
  {
    *v192 = 10;
    v194 = (void *)(*((_QWORD *)a2 + 4) + 1);
    *((_QWORD *)a2 + 4) = v194;
    v193 = a2;
  }
  if (*((_QWORD *)v193 + 3) - (_QWORD)v194 > 0xEuLL)
  {
    qmemcpy(v194, ".debug_tu_index", 15);
    v195 = *((_QWORD *)v193 + 4) + 15;
    *((_QWORD *)v193 + 4) = v195;
  }
  else
  {
    v193 = llvm::raw_ostream::write(v193, ".debug_tu_index", 0xFuLL);
    v195 = *((_QWORD *)v193 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v193 + 3) - v195) > 0xA)
  {
    *(_DWORD *)(v195 + 7) = 171602804;
    *(_QWORD *)v195 = *(_QWORD *)" contents:\n";
    *((_QWORD *)v193 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v193, " contents:\n", 0xBuLL);
  }
  TUIndex = (llvm::raw_ostream *)llvm::DWARFContext::getTUIndex((llvm::DWARFContext *)v33);
  llvm::DWARFUnitIndex::dump(TUIndex, a2);
LABEL_353:
  (*(void (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 136))(*(_QWORD *)(v33 + 520));
  if ((v32 & 0x40000) != 0)
    v198 = v34;
  else
    v198 = 1;
  if ((v198 & 1) != 0)
  {
    if ((v32 & 0x40000) == 0)
      goto LABEL_367;
  }
  else if (!v197)
  {
    goto LABEL_367;
  }
  v199 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v199)
  {
    v200 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v201 = *((_QWORD *)v200 + 4);
  }
  else
  {
    *v199 = 10;
    v201 = *((_QWORD *)a2 + 4) + 1;
    *((_QWORD *)a2 + 4) = v201;
    v200 = a2;
  }
  if ((unint64_t)(*((_QWORD *)v200 + 3) - v201) > 9)
  {
    *(_WORD *)(v201 + 8) = 29300;
    *(_QWORD *)v201 = *(_QWORD *)".debug_str";
    v202 = *((_QWORD *)v200 + 4) + 10;
    *((_QWORD *)v200 + 4) = v202;
  }
  else
  {
    v200 = llvm::raw_ostream::write(v200, ".debug_str", 0xAuLL);
    v202 = *((_QWORD *)v200 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v200 + 3) - v202) > 0xA)
  {
    *(_DWORD *)(v202 + 7) = 171602804;
    *(_QWORD *)v202 = *(_QWORD *)" contents:\n";
    *((_QWORD *)v200 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v200, " contents:\n", 0xBuLL);
  }
  v203 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 136))(*(_QWORD *)(v33 + 520));
  sub_1C548541C((uint64_t)v437, v203, v204);
LABEL_367:
  (*(void (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 280))(*(_QWORD *)(v33 + 520));
  if ((v32 & 0x40000) != 0)
    v206 = v34 & v403;
  else
    v206 = 1;
  if ((v206 & 1) != 0)
  {
    if ((v32 & 0x40000) == 0)
      goto LABEL_381;
  }
  else if (!v205)
  {
    goto LABEL_381;
  }
  v207 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v207)
  {
    v208 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v209 = (void *)*((_QWORD *)v208 + 4);
  }
  else
  {
    *v207 = 10;
    v209 = (void *)(*((_QWORD *)a2 + 4) + 1);
    *((_QWORD *)a2 + 4) = v209;
    v208 = a2;
  }
  if (*((_QWORD *)v208 + 3) - (_QWORD)v209 > 0xDuLL)
  {
    qmemcpy(v209, ".debug_str.dwo", 14);
    v210 = *((_QWORD *)v208 + 4) + 14;
    *((_QWORD *)v208 + 4) = v210;
  }
  else
  {
    v208 = llvm::raw_ostream::write(v208, ".debug_str.dwo", 0xEuLL);
    v210 = *((_QWORD *)v208 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v208 + 3) - v210) > 0xA)
  {
    *(_DWORD *)(v210 + 7) = 171602804;
    *(_QWORD *)v210 = *(_QWORD *)" contents:\n";
    *((_QWORD *)v208 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v208, " contents:\n", 0xBuLL);
  }
  v211 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 280))(*(_QWORD *)(v33 + 520));
  sub_1C548541C((uint64_t)v437, v211, v212);
LABEL_381:
  (*(void (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 128))(*(_QWORD *)(v33 + 520));
  if ((v32 & 0x40) != 0)
    v214 = v34;
  else
    v214 = 1;
  if ((v214 & 1) != 0)
  {
    if ((v32 & 0x40) == 0)
      goto LABEL_395;
  }
  else if (!v213)
  {
    goto LABEL_395;
  }
  v215 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v215)
  {
    v216 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v217 = (void *)*((_QWORD *)v216 + 4);
  }
  else
  {
    *v215 = 10;
    v217 = (void *)(*((_QWORD *)a2 + 4) + 1);
    *((_QWORD *)a2 + 4) = v217;
    v216 = a2;
  }
  if (*((_QWORD *)v216 + 3) - (_QWORD)v217 > 0xEuLL)
  {
    qmemcpy(v217, ".debug_line_str", 15);
    v218 = *((_QWORD *)v216 + 4) + 15;
    *((_QWORD *)v216 + 4) = v218;
  }
  else
  {
    v216 = llvm::raw_ostream::write(v216, ".debug_line_str", 0xFuLL);
    v218 = *((_QWORD *)v216 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v216 + 3) - v218) > 0xA)
  {
    *(_DWORD *)(v218 + 7) = 171602804;
    *(_QWORD *)v218 = *(_QWORD *)" contents:\n";
    *((_QWORD *)v216 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v216, " contents:\n", 0xBuLL);
  }
  v219 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 128))(*(_QWORD *)(v33 + 520));
  sub_1C548541C((uint64_t)v437, v219, v220);
LABEL_395:
  v221 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 312))(*(_QWORD *)(v33 + 520));
  if ((v32 & 2) != 0)
    v222 = v34;
  else
    v222 = 1;
  if ((v222 & 1) == 0)
  {
    if (!*(_QWORD *)(v221 + 8))
      goto LABEL_440;
    goto LABEL_402;
  }
  if ((v32 & 2) != 0)
  {
LABEL_402:
    v223 = (_BYTE *)*((_QWORD *)a2 + 4);
    if (*((_BYTE **)a2 + 3) == v223)
    {
      v224 = llvm::raw_ostream::write(a2, "\n", 1uLL);
      v225 = *((_QWORD *)v224 + 4);
    }
    else
    {
      *v223 = 10;
      v225 = *((_QWORD *)a2 + 4) + 1;
      *((_QWORD *)a2 + 4) = v225;
      v224 = a2;
    }
    if ((unint64_t)(*((_QWORD *)v224 + 3) - v225) > 0xA)
    {
      *(_DWORD *)(v225 + 7) = 1919181921;
      *(_QWORD *)v225 = *(_QWORD *)".debug_addr";
      v226 = *((_QWORD *)v224 + 4) + 11;
      *((_QWORD *)v224 + 4) = v226;
    }
    else
    {
      v224 = llvm::raw_ostream::write(v224, ".debug_addr", 0xBuLL);
      v226 = *((_QWORD *)v224 + 4);
    }
    if ((unint64_t)(*((_QWORD *)v224 + 3) - v226) > 0xA)
    {
      *(_DWORD *)(v226 + 7) = 171602804;
      *(_QWORD *)v226 = *(_QWORD *)" contents:\n";
      *((_QWORD *)v224 + 4) += 11;
    }
    else
    {
      llvm::raw_ostream::write(v224, " contents:\n", 0xBuLL);
    }
    v227 = *(_QWORD *)(v33 + 520);
    v228 = (_OWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v227 + 312))(v227);
    v229 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 40))(*(_QWORD *)(v33 + 520));
    v432 = *v228;
    v433 = v229;
    v434 = 0;
    v435 = v227;
    v436 = v228;
    sub_1C624C4A4((uint64_t)v475, (__int128 *)a3);
    llvm::DWARFContext::parseNormalUnits(v33);
    v230 = *(_DWORD *)(v33 + 360);
    sub_1C548BC00(v33, __p);
    v231 = 0;
    if (*(_QWORD *)__p != (_QWORD)v498)
      v231 = *(unsigned __int8 *)(**(_QWORD **)__p + 34);
    v466 = 0;
    while (1)
    {
      v232 = v466;
      if (*((_QWORD *)&v432 + 1) <= v466)
      {
LABEL_439:
        sub_1C624C568(v475);
        LODWORD(v32) = v405;
        v35 = v34 & v403;
        goto LABEL_440;
      }
      v464 = 0;
      memset(&v465[8], 0, 24);
      if (v478)
      {
        if (v478 == v477)
        {
          v496 = (uint64_t *)&v493;
          (*(void (**)(_QWORD *, void (***)(void)))(v477[0] + 24))(v477, &v493);
        }
        else
        {
          v496 = (uint64_t *)(*(uint64_t (**)(void))(*v478 + 16))();
        }
      }
      else
      {
        v496 = 0;
      }
      llvm::DWARFDebugAddrTable::extract((llvm::DWARFDebugAddrTable *)&v462, (llvm::DWARFDataExtractor *)&v432, &v466, (unsigned __int16)v230, v231, &v493, &v461);
      if (v496 == (uint64_t *)&v493)
        break;
      if (v496)
      {
        v233 = (void (**)(void))(*v496 + 40);
LABEL_421:
        (*v233)();
      }
      if (v461)
      {
        v460 = v461;
        v461 = 0;
        if (!v476)
          goto LABEL_776;
        (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v476 + 48))(v476, &v460);
        if (v460)
          (*(void (**)(uint64_t))(*(_QWORD *)v460 + 8))(v460);
        if (v464)
        {
          if ((_BYTE)v462)
            v234 = 12;
          else
            v234 = 4;
          v466 = (unint64_t)v464 + v232 + v234;
          v235 = 2;
        }
        else
        {
          v235 = 3;
        }
        if (v461)
          (*(void (**)(uint64_t))(*(_QWORD *)v461 + 8))(v461);
      }
      else
      {
        sub_1C624C4A4((uint64_t)__p, v475);
        llvm::DWARFDebugAddrTable::dump((llvm::raw_ostream *)&v462, a2, (uint64_t)__p);
        sub_1C624C568(__p);
        v235 = 0;
      }
      if (*(_QWORD *)&v465[8])
      {
        *(_QWORD *)&v465[16] = *(_QWORD *)&v465[8];
        operator delete(*(void **)&v465[8]);
      }
      if (v235 == 3)
        goto LABEL_439;
    }
    v233 = v493 + 4;
    goto LABEL_421;
  }
LABEL_440:
  v236 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 144))(*(_QWORD *)(v33 + 520));
  if ((v32 & 0x10000) != 0)
    v237 = v34;
  else
    v237 = 1;
  if ((v237 & 1) != 0)
  {
    if ((v32 & 0x10000) == 0)
      goto LABEL_467;
  }
  else if (!*(_QWORD *)(v236 + 8))
  {
    goto LABEL_467;
  }
  v238 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v238)
  {
    v239 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v240 = (void *)*((_QWORD *)v239 + 4);
  }
  else
  {
    *v238 = 10;
    v240 = (void *)(*((_QWORD *)a2 + 4) + 1);
    *((_QWORD *)a2 + 4) = v240;
    v239 = a2;
  }
  if (*((_QWORD *)v239 + 3) - (_QWORD)v240 > 0xCuLL)
  {
    qmemcpy(v240, ".debug_ranges", 13);
    v241 = *((_QWORD *)v239 + 4) + 13;
    *((_QWORD *)v239 + 4) = v241;
  }
  else
  {
    v239 = llvm::raw_ostream::write(v239, ".debug_ranges", 0xDuLL);
    v241 = *((_QWORD *)v239 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v239 + 3) - v241) > 0xA)
  {
    *(_DWORD *)(v241 + 7) = 171602804;
    *(_QWORD *)v241 = *(_QWORD *)" contents:\n";
    *((_QWORD *)v239 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v239, " contents:\n", 0xBuLL);
  }
  sub_1C548BC00(v33, __p);
  if (*(_QWORD *)__p == (_QWORD)v498)
    v242 = 0;
  else
    v242 = *(_BYTE *)(**(_QWORD **)__p + 34);
  v243 = *(_QWORD *)(v33 + 520);
  v244 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v243 + 144))(v243);
  v245 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 40))(*(_QWORD *)(v33 + 520));
  v246 = v244[1];
  *(_QWORD *)__p = *v244;
  *(_QWORD *)&__p[8] = v246;
  __p[16] = v245;
  __p[17] = v242;
  *(_QWORD *)&v498 = v243;
  *((_QWORD *)&v498 + 1) = v244;
  *(_QWORD *)&v432 = 0;
  *(_QWORD *)v465 = 0;
  v464 = 0;
  *(_QWORD *)&v465[8] = 0;
  v462 = -1;
  LOBYTE(v463) = 0;
  if (v246)
  {
    while (1)
    {
      llvm::DWARFDebugRangeList::extract((llvm::DWARFDebugRangeList *)&v462, (const llvm::DWARFDataExtractor *)__p, (unint64_t *)&v432, (uint64_t *)&v493);
      if (v493)
        break;
      llvm::DWARFDebugRangeList::dump((llvm::DWARFDebugRangeList *)&v462, a2);
      if (*(_QWORD *)&__p[8] <= (unint64_t)v432)
        goto LABEL_465;
    }
    v427 = v493;
    v493 = 0;
    v247 = *((_QWORD *)a3 + 6);
    if (v247)
    {
      (*(void (**)(uint64_t, void (***)(void)))(*(_QWORD *)v247 + 48))(v247, &v427);
      if (v427)
        (*((void (**)(void (**)(void)))*v427 + 1))(v427);
      if (v493)
        (*((void (**)(void (**)(void)))*v493 + 1))(v493);
      goto LABEL_465;
    }
LABEL_776:
    sub_1C485C2F0();
  }
LABEL_465:
  if (v464)
  {
    *(_QWORD *)v465 = v464;
    operator delete(v464);
  }
LABEL_467:
  v462 = v33;
  v248 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 152))(*(_QWORD *)(v33 + 520));
  if ((v32 & 0x20000) != 0)
    v249 = v34;
  else
    v249 = 1;
  if ((v249 & 1) != 0)
  {
    if ((v32 & 0x20000) == 0)
      goto LABEL_481;
  }
  else if (!*(_QWORD *)(v248 + 8))
  {
    goto LABEL_481;
  }
  v250 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v250)
  {
    v251 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v252 = (void *)*((_QWORD *)v251 + 4);
  }
  else
  {
    *v250 = 10;
    v252 = (void *)(*((_QWORD *)a2 + 4) + 1);
    *((_QWORD *)a2 + 4) = v252;
    v251 = a2;
  }
  if (*((_QWORD *)v251 + 3) - (_QWORD)v252 > 0xEuLL)
  {
    qmemcpy(v252, ".debug_rnglists", 15);
    v253 = *((_QWORD *)v251 + 4) + 15;
    *((_QWORD *)v251 + 4) = v253;
  }
  else
  {
    v251 = llvm::raw_ostream::write(v251, ".debug_rnglists", 0xFuLL);
    v253 = *((_QWORD *)v251 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v251 + 3) - v253) > 0xA)
  {
    *(_DWORD *)(v253 + 7) = 171602804;
    *(_QWORD *)v253 = *(_QWORD *)" contents:\n";
    *((_QWORD *)v251 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v251, " contents:\n", 0xBuLL);
  }
  v254 = *(_QWORD *)(v33 + 520);
  v255 = (_OWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v254 + 152))(v254);
  v256 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 40))(*(_QWORD *)(v33 + 520));
  *(_OWORD *)__p = *v255;
  *(_WORD *)&__p[16] = v256;
  *(_QWORD *)&v498 = v254;
  *((_QWORD *)&v498 + 1) = v255;
  sub_1C624C4A4((uint64_t)v474, (__int128 *)a3);
  sub_1C54855EC(a2, (__int128 *)__p, (uint64_t)sub_1C548D698, (uint64_t)&v462, (uint64_t)v474);
  sub_1C624C568(v474);
LABEL_481:
  v257 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 304))(*(_QWORD *)(v33 + 520));
  if ((v32 & 0x20000) != 0)
    v258 = v35;
  else
    v258 = 1;
  if ((v258 & 1) != 0)
  {
    if ((v32 & 0x20000) == 0)
      goto LABEL_495;
  }
  else if (!*(_QWORD *)(v257 + 8))
  {
    goto LABEL_495;
  }
  v259 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v259)
  {
    v260 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v261 = *((_QWORD *)v260 + 4);
  }
  else
  {
    *v259 = 10;
    v261 = *((_QWORD *)a2 + 4) + 1;
    *((_QWORD *)a2 + 4) = v261;
    v260 = a2;
  }
  if ((unint64_t)(*((_QWORD *)v260 + 3) - v261) > 0x12)
  {
    *(_DWORD *)(v261 + 15) = 1870095406;
    *(_OWORD *)v261 = *(_OWORD *)".debug_rnglists.dwo";
    v262 = *((_QWORD *)v260 + 4) + 19;
    *((_QWORD *)v260 + 4) = v262;
  }
  else
  {
    v260 = llvm::raw_ostream::write(v260, ".debug_rnglists.dwo", 0x13uLL);
    v262 = *((_QWORD *)v260 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v260 + 3) - v262) > 0xA)
  {
    *(_DWORD *)(v262 + 7) = 171602804;
    *(_QWORD *)v262 = *(_QWORD *)" contents:\n";
    *((_QWORD *)v260 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v260, " contents:\n", 0xBuLL);
  }
  v263 = *(_QWORD *)(v33 + 520);
  v264 = (_OWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v263 + 304))(v263);
  v265 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 40))(*(_QWORD *)(v33 + 520));
  *(_OWORD *)__p = *v264;
  *(_WORD *)&__p[16] = v265;
  *(_QWORD *)&v498 = v263;
  *((_QWORD *)&v498 + 1) = v264;
  sub_1C624C4A4((uint64_t)v473, (__int128 *)a3);
  sub_1C54855EC(a2, (__int128 *)__p, (uint64_t)sub_1C548D698, (uint64_t)&v462, (uint64_t)v473);
  sub_1C624C568(v473);
LABEL_495:
  v266 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 192))(*(_QWORD *)(v33 + 520));
  if ((v32 & 0x1000) != 0)
    v267 = v34;
  else
    v267 = 1;
  if ((v267 & 1) != 0)
  {
    if ((v32 & 0x1000) == 0)
      goto LABEL_509;
  }
  else if (!*(_QWORD *)(v266 + 8))
  {
    goto LABEL_509;
  }
  v268 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v268)
  {
    v269 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v270 = (void *)*((_QWORD *)v269 + 4);
  }
  else
  {
    *v268 = 10;
    v270 = (void *)(*((_QWORD *)a2 + 4) + 1);
    *((_QWORD *)a2 + 4) = v270;
    v269 = a2;
  }
  if (*((_QWORD *)v269 + 3) - (_QWORD)v270 > 0xEuLL)
  {
    qmemcpy(v270, ".debug_pubnames", 15);
    v271 = *((_QWORD *)v269 + 4) + 15;
    *((_QWORD *)v269 + 4) = v271;
  }
  else
  {
    v269 = llvm::raw_ostream::write(v269, ".debug_pubnames", 0xFuLL);
    v271 = *((_QWORD *)v269 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v269 + 3) - v271) > 0xA)
  {
    *(_DWORD *)(v271 + 7) = 171602804;
    *(_QWORD *)v271 = *(_QWORD *)" contents:\n";
    *((_QWORD *)v269 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v269, " contents:\n", 0xBuLL);
  }
  v272 = *(_QWORD *)(v33 + 520);
  v273 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v272 + 192))(v272);
  v274 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 40))(*(_QWORD *)(v33 + 520));
  v275 = *v273;
  v276 = v273[1];
  sub_1C624C4A4((uint64_t)v472, (__int128 *)a3);
  v422[0] = v275;
  v422[1] = v276;
  v423 = v274;
  v424 = 0;
  v425 = v272;
  v426 = v273;
  sub_1C5485CF8(a2, (uint64_t)v472, (uint64_t)v422, 0);
  sub_1C624C568(v472);
LABEL_509:
  v277 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 200))(*(_QWORD *)(v33 + 520));
  if ((v32 & 0x2000) != 0)
    v278 = v34;
  else
    v278 = 1;
  if ((v278 & 1) != 0)
  {
    if ((v32 & 0x2000) == 0)
      goto LABEL_523;
  }
  else if (!*(_QWORD *)(v277 + 8))
  {
    goto LABEL_523;
  }
  v279 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v279)
  {
    v280 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v281 = (void *)*((_QWORD *)v280 + 4);
  }
  else
  {
    *v279 = 10;
    v281 = (void *)(*((_QWORD *)a2 + 4) + 1);
    *((_QWORD *)a2 + 4) = v281;
    v280 = a2;
  }
  if (*((_QWORD *)v280 + 3) - (_QWORD)v281 > 0xEuLL)
  {
    qmemcpy(v281, ".debug_pubtypes", 15);
    v282 = *((_QWORD *)v280 + 4) + 15;
    *((_QWORD *)v280 + 4) = v282;
  }
  else
  {
    v280 = llvm::raw_ostream::write(v280, ".debug_pubtypes", 0xFuLL);
    v282 = *((_QWORD *)v280 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v280 + 3) - v282) > 0xA)
  {
    *(_DWORD *)(v282 + 7) = 171602804;
    *(_QWORD *)v282 = *(_QWORD *)" contents:\n";
    *((_QWORD *)v280 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v280, " contents:\n", 0xBuLL);
  }
  v283 = *(_QWORD *)(v33 + 520);
  v284 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v283 + 200))(v283);
  v285 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 40))(*(_QWORD *)(v33 + 520));
  v286 = *v284;
  v287 = v284[1];
  sub_1C624C4A4((uint64_t)v471, (__int128 *)a3);
  v417[0] = v286;
  v417[1] = v287;
  v418 = v285;
  v419 = 0;
  v420 = v283;
  v421 = v284;
  sub_1C5485CF8(a2, (uint64_t)v471, (uint64_t)v417, 0);
  sub_1C624C568(v471);
LABEL_523:
  v288 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 208))(*(_QWORD *)(v33 + 520));
  if ((v32 & 0x4000) != 0)
    v289 = v34;
  else
    v289 = 1;
  if ((v289 & 1) != 0)
  {
    if ((v32 & 0x4000) == 0)
      goto LABEL_537;
  }
  else if (!*(_QWORD *)(v288 + 8))
  {
    goto LABEL_537;
  }
  v290 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v290)
  {
    v291 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v292 = *((_QWORD *)v291 + 4);
  }
  else
  {
    *v290 = 10;
    v292 = *((_QWORD *)a2 + 4) + 1;
    *((_QWORD *)a2 + 4) = v292;
    v291 = a2;
  }
  if ((unint64_t)(*((_QWORD *)v291 + 3) - v292) > 0x12)
  {
    *(_DWORD *)(v292 + 15) = 1936026977;
    *(_OWORD *)v292 = *(_OWORD *)".debug_gnu_pubnames";
    v293 = *((_QWORD *)v291 + 4) + 19;
    *((_QWORD *)v291 + 4) = v293;
  }
  else
  {
    v291 = llvm::raw_ostream::write(v291, ".debug_gnu_pubnames", 0x13uLL);
    v293 = *((_QWORD *)v291 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v291 + 3) - v293) > 0xA)
  {
    *(_DWORD *)(v293 + 7) = 171602804;
    *(_QWORD *)v293 = *(_QWORD *)" contents:\n";
    *((_QWORD *)v291 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v291, " contents:\n", 0xBuLL);
  }
  v294 = *(_QWORD *)(v33 + 520);
  v295 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v294 + 208))(v294);
  v296 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 40))(*(_QWORD *)(v33 + 520));
  v297 = *v295;
  v298 = v295[1];
  sub_1C624C4A4((uint64_t)v470, (__int128 *)a3);
  v412[0] = v297;
  v412[1] = v298;
  v413 = v296;
  v414 = 0;
  v415 = v294;
  v416 = v295;
  sub_1C5485CF8(a2, (uint64_t)v470, (uint64_t)v412, 1);
  sub_1C624C568(v470);
LABEL_537:
  v299 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 216))(*(_QWORD *)(v33 + 520));
  if ((v32 & 0x8000) != 0)
    v300 = v34;
  else
    v300 = 1;
  if ((v300 & 1) != 0)
  {
    if ((v32 & 0x8000) == 0)
      goto LABEL_551;
  }
  else if (!*(_QWORD *)(v299 + 8))
  {
    goto LABEL_551;
  }
  v301 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v301)
  {
    v302 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v303 = *((_QWORD *)v302 + 4);
  }
  else
  {
    *v301 = 10;
    v303 = *((_QWORD *)a2 + 4) + 1;
    *((_QWORD *)a2 + 4) = v303;
    v302 = a2;
  }
  if ((unint64_t)(*((_QWORD *)v302 + 3) - v303) > 0x12)
  {
    *(_DWORD *)(v303 + 15) = 1936027769;
    *(_OWORD *)v303 = *(_OWORD *)".debug_gnu_pubtypes";
    v304 = *((_QWORD *)v302 + 4) + 19;
    *((_QWORD *)v302 + 4) = v304;
  }
  else
  {
    v302 = llvm::raw_ostream::write(v302, ".debug_gnu_pubtypes", 0x13uLL);
    v304 = *((_QWORD *)v302 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v302 + 3) - v304) > 0xA)
  {
    *(_DWORD *)(v304 + 7) = 171602804;
    *(_QWORD *)v304 = *(_QWORD *)" contents:\n";
    *((_QWORD *)v302 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v302, " contents:\n", 0xBuLL);
  }
  v305 = *(_QWORD *)(v33 + 520);
  v306 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v305 + 216))(v305);
  v307 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 40))(*(_QWORD *)(v33 + 520));
  v308 = *v306;
  v309 = v306[1];
  sub_1C624C4A4((uint64_t)v469, (__int128 *)a3);
  v407[0] = v308;
  v407[1] = v309;
  v408 = v307;
  v409 = 0;
  v410 = v305;
  v411 = v306;
  sub_1C5485CF8(a2, (uint64_t)v469, (uint64_t)v407, 1);
  sub_1C624C568(v469);
LABEL_551:
  v310 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 224))(*(_QWORD *)(v33 + 520));
  if ((v32 & 0x80000) != 0)
    v311 = v34;
  else
    v311 = 1;
  if ((v311 & 1) != 0)
  {
    if ((v32 & 0x80000) == 0)
      goto LABEL_565;
  }
  else if (!*(_QWORD *)(v310 + 8))
  {
    goto LABEL_565;
  }
  v312 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v312)
  {
    v313 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v314 = *((_QWORD *)v313 + 4);
  }
  else
  {
    *v312 = 10;
    v314 = *((_QWORD *)a2 + 4) + 1;
    *((_QWORD *)a2 + 4) = v314;
    v313 = a2;
  }
  if ((unint64_t)(*((_QWORD *)v313 + 3) - v314) > 0x11)
  {
    *(_WORD *)(v314 + 16) = 29556;
    *(_OWORD *)v314 = *(_OWORD *)".debug_str_offsets";
    v315 = *((_QWORD *)v313 + 4) + 18;
    *((_QWORD *)v313 + 4) = v315;
  }
  else
  {
    v313 = llvm::raw_ostream::write(v313, ".debug_str_offsets", 0x12uLL);
    v315 = *((_QWORD *)v313 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v313 + 3) - v315) > 0xA)
  {
    *(_DWORD *)(v315 + 7) = 171602804;
    *(_QWORD *)v315 = *(_QWORD *)" contents:\n";
    *((_QWORD *)v313 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v313, " contents:\n", 0xBuLL);
  }
  sub_1C624C4A4((uint64_t)v468, (__int128 *)a3);
  v316 = *(_QWORD *)(v33 + 520);
  v317 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v316 + 224))(v316);
  v318 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 136))(*(_QWORD *)(v33 + 520));
  v32 = v319;
  llvm::DWARFContext::parseNormalUnits(v33);
  v320 = *(__n128 ***)(v33 + 16);
  v321 = &v320[*(unsigned int *)(v33 + 24)];
  v322.n128_f64[0] = (*(double (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 40))(*(_QWORD *)(v33 + 520));
  sub_1C5485DA4(a2, (uint64_t)v468, "debug_str_offsets", 0x11uLL, v316, v317, v318, v32, v322, v320, v321, v323);
  sub_1C624C568(v468);
  LODWORD(v32) = v405;
LABEL_565:
  v324 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 288))(*(_QWORD *)(v33 + 520));
  if ((v32 & 0x80000) != 0)
    v325 = v35;
  else
    v325 = 1;
  if ((v325 & 1) != 0)
  {
    if ((v32 & 0x80000) == 0)
      goto LABEL_579;
  }
  else if (!*(_QWORD *)(v324 + 8))
  {
    goto LABEL_579;
  }
  v326 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v326)
  {
    v327 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v328 = (void *)*((_QWORD *)v327 + 4);
  }
  else
  {
    *v326 = 10;
    v328 = (void *)(*((_QWORD *)a2 + 4) + 1);
    *((_QWORD *)a2 + 4) = v328;
    v327 = a2;
  }
  if (*((_QWORD *)v327 + 3) - (_QWORD)v328 > 0x15uLL)
  {
    qmemcpy(v328, ".debug_str_offsets.dwo", 22);
    v329 = *((_QWORD *)v327 + 4) + 22;
    *((_QWORD *)v327 + 4) = v329;
  }
  else
  {
    v327 = llvm::raw_ostream::write(v327, ".debug_str_offsets.dwo", 0x16uLL);
    v329 = *((_QWORD *)v327 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v327 + 3) - v329) > 0xA)
  {
    *(_DWORD *)(v329 + 7) = 171602804;
    *(_QWORD *)v329 = *(_QWORD *)" contents:\n";
    *((_QWORD *)v327 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v327, " contents:\n", 0xBuLL);
  }
  sub_1C624C4A4((uint64_t)v467, (__int128 *)a3);
  v330 = *(_QWORD *)(v33 + 520);
  v331 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v330 + 288))(v330);
  v332 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 280))(*(_QWORD *)(v33 + 520));
  v334 = v333;
  llvm::DWARFContext::parseDWOUnits(v33, 0);
  v335 = *(__n128 ***)(v33 + 240);
  v32 = (uint64_t)&v335[*(unsigned int *)(v33 + 248)];
  v336.n128_f64[0] = (*(double (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 40))(*(_QWORD *)(v33 + 520));
  sub_1C5485DA4(a2, (uint64_t)v467, "debug_str_offsets.dwo", 0x15uLL, v330, v331, v332, v334, v336, v335, (__n128 **)v32, v337);
  sub_1C624C568(v467);
  LODWORD(v32) = v405;
LABEL_579:
  (*(void (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 368))(*(_QWORD *)(v33 + 520));
  if ((v32 & 0x4000000) != 0)
    v340 = v34;
  else
    v340 = 1;
  if ((v340 & 1) != 0)
  {
    if ((v32 & 0x4000000) == 0)
      goto LABEL_593;
  }
  else if (!v338)
  {
    goto LABEL_593;
  }
  v341 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v341)
  {
    v342 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v343 = *((_QWORD *)v342 + 4);
  }
  else
  {
    *v341 = 10;
    v343 = *((_QWORD *)a2 + 4) + 1;
    *((_QWORD *)a2 + 4) = v343;
    v342 = a2;
  }
  if ((unint64_t)(*((_QWORD *)v342 + 3) - v343) > 9)
  {
    *(_WORD *)(v343 + 8) = 30821;
    *(_QWORD *)v343 = *(_QWORD *)".gdb_index";
    v344 = *((_QWORD *)v342 + 4) + 10;
    *((_QWORD *)v342 + 4) = v344;
  }
  else
  {
    v342 = llvm::raw_ostream::write(v342, ".gdb_index", 0xAuLL);
    v344 = *((_QWORD *)v342 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v342 + 3) - v344) > 0xA)
  {
    *(_DWORD *)(v344 + 7) = 171602804;
    *(_QWORD *)v344 = *(_QWORD *)" contents:\n";
    *((_QWORD *)v342 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v342, " contents:\n", 0xBuLL);
  }
  GdbIndex = (llvm::DWARFGdbIndex *)llvm::DWARFContext::getGdbIndex((llvm::DWARFContext *)v33);
  v339.n128_f64[0] = llvm::DWARFGdbIndex::dump(GdbIndex, a2);
LABEL_593:
  v346 = (*(uint64_t (**)(_QWORD, __n128))(**(_QWORD **)(v33 + 520) + 320))(*(_QWORD *)(v33 + 520), v339);
  if ((v32 & 0x400000) != 0)
    v347 = v34;
  else
    v347 = 1;
  if ((v347 & 1) != 0)
  {
    if ((v32 & 0x400000) == 0)
      goto LABEL_607;
  }
  else if (!*(_QWORD *)(v346 + 8))
  {
    goto LABEL_607;
  }
  v348 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v348)
  {
    v349 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v350 = *((_QWORD *)v349 + 4);
  }
  else
  {
    *v348 = 10;
    v350 = *((_QWORD *)a2 + 4) + 1;
    *((_QWORD *)a2 + 4) = v350;
    v349 = a2;
  }
  if ((unint64_t)(*((_QWORD *)v349 + 3) - v350) > 0xB)
  {
    *(_DWORD *)(v350 + 8) = 1936026977;
    *(_QWORD *)v350 = *(_QWORD *)".apple_names";
    v351 = *((_QWORD *)v349 + 4) + 12;
    *((_QWORD *)v349 + 4) = v351;
  }
  else
  {
    v349 = llvm::raw_ostream::write(v349, ".apple_names", 0xCuLL);
    v351 = *((_QWORD *)v349 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v349 + 3) - v351) > 0xA)
  {
    *(_DWORD *)(v351 + 7) = 171602804;
    *(_QWORD *)v351 = *(_QWORD *)" contents:\n";
    *((_QWORD *)v349 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v349, " contents:\n", 0xBuLL);
  }
  v352 = *(_QWORD *)(v33 + 520);
  v353 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v352 + 320))(v352);
  v354 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 136))(*(_QWORD *)(v33 + 520));
  v32 = v355;
  v356 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 40))(*(_QWORD *)(v33 + 520));
  v357 = sub_1C5487284((uint64_t *)(v33 + 208), v352, v353, v354, v32, v356);
  ((void (*)(uint64_t (***)(), llvm::raw_ostream *))(*v357)[3])(v357, a2);
  LODWORD(v32) = v405;
LABEL_607:
  v358 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 328))(*(_QWORD *)(v33 + 520));
  if ((v32 & 0x800000) != 0)
    v359 = v34;
  else
    v359 = 1;
  if ((v359 & 1) != 0)
  {
    if ((v32 & 0x800000) == 0)
      goto LABEL_621;
  }
  else if (!*(_QWORD *)(v358 + 8))
  {
    goto LABEL_621;
  }
  v360 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v360)
  {
    v361 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v362 = *((_QWORD *)v361 + 4);
  }
  else
  {
    *v360 = 10;
    v362 = *((_QWORD *)a2 + 4) + 1;
    *((_QWORD *)a2 + 4) = v362;
    v361 = a2;
  }
  if ((unint64_t)(*((_QWORD *)v361 + 3) - v362) > 0xB)
  {
    *(_DWORD *)(v362 + 8) = 1936027769;
    *(_QWORD *)v362 = *(_QWORD *)".apple_types";
    v363 = *((_QWORD *)v361 + 4) + 12;
    *((_QWORD *)v361 + 4) = v363;
  }
  else
  {
    v361 = llvm::raw_ostream::write(v361, ".apple_types", 0xCuLL);
    v363 = *((_QWORD *)v361 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v361 + 3) - v363) > 0xA)
  {
    *(_DWORD *)(v363 + 7) = 171602804;
    *(_QWORD *)v363 = *(_QWORD *)" contents:\n";
    *((_QWORD *)v361 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v361, " contents:\n", 0xBuLL);
  }
  v364 = *(_QWORD *)(v33 + 520);
  v365 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v364 + 328))(v364);
  v366 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 136))(*(_QWORD *)(v33 + 520));
  v32 = v367;
  v368 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 40))(*(_QWORD *)(v33 + 520));
  v369 = sub_1C5487284((uint64_t *)(v33 + 216), v364, v365, v366, v32, v368);
  ((void (*)(uint64_t (***)(), llvm::raw_ostream *))(*v369)[3])(v369, a2);
  LODWORD(v32) = v405;
LABEL_621:
  v370 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 336))(*(_QWORD *)(v33 + 520));
  if ((v32 & 0x1000000) != 0)
    v371 = v34;
  else
    v371 = 1;
  if ((v371 & 1) != 0)
  {
    if ((v32 & 0x1000000) == 0)
      goto LABEL_635;
  }
  else if (!*(_QWORD *)(v370 + 8))
  {
    goto LABEL_635;
  }
  v372 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v372)
  {
    v373 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v374 = *((_QWORD *)v373 + 4);
  }
  else
  {
    *v372 = 10;
    v374 = *((_QWORD *)a2 + 4) + 1;
    *((_QWORD *)a2 + 4) = v374;
    v373 = a2;
  }
  if ((unint64_t)(*((_QWORD *)v373 + 3) - v374) > 0x10)
  {
    *(_BYTE *)(v374 + 16) = 115;
    *(_OWORD *)v374 = *(_OWORD *)".apple_namespaces";
    v375 = *((_QWORD *)v373 + 4) + 17;
    *((_QWORD *)v373 + 4) = v375;
  }
  else
  {
    v373 = llvm::raw_ostream::write(v373, ".apple_namespaces", 0x11uLL);
    v375 = *((_QWORD *)v373 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v373 + 3) - v375) > 0xA)
  {
    *(_DWORD *)(v375 + 7) = 171602804;
    *(_QWORD *)v375 = *(_QWORD *)" contents:\n";
    *((_QWORD *)v373 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v373, " contents:\n", 0xBuLL);
  }
  v376 = *(_QWORD *)(v33 + 520);
  v377 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v376 + 336))(v376);
  v378 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 136))(*(_QWORD *)(v33 + 520));
  v32 = v379;
  v380 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 40))(*(_QWORD *)(v33 + 520));
  v381 = sub_1C5487284((uint64_t *)(v33 + 224), v376, v377, v378, v32, v380);
  ((void (*)(uint64_t (***)(), llvm::raw_ostream *))(*v381)[3])(v381, a2);
  LODWORD(v32) = v405;
LABEL_635:
  v382 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 352))(*(_QWORD *)(v33 + 520));
  if ((v32 & 0x2000000) != 0)
    v383 = v34;
  else
    v383 = 1;
  if ((v383 & 1) != 0)
  {
    if ((v32 & 0x2000000) == 0)
      goto LABEL_649;
  }
  else if (!*(_QWORD *)(v382 + 8))
  {
    goto LABEL_649;
  }
  v384 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v384)
  {
    v385 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v386 = *((_QWORD *)v385 + 4);
  }
  else
  {
    *v384 = 10;
    v386 = *((_QWORD *)a2 + 4) + 1;
    *((_QWORD *)a2 + 4) = v386;
    v385 = a2;
  }
  if ((unint64_t)(*((_QWORD *)v385 + 3) - v386) > 0xA)
  {
    *(_DWORD *)(v386 + 7) = 1667916399;
    *(_QWORD *)v386 = *(_QWORD *)".apple_objc";
    v387 = *((_QWORD *)v385 + 4) + 11;
    *((_QWORD *)v385 + 4) = v387;
  }
  else
  {
    v385 = llvm::raw_ostream::write(v385, ".apple_objc", 0xBuLL);
    v387 = *((_QWORD *)v385 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v385 + 3) - v387) > 0xA)
  {
    *(_DWORD *)(v387 + 7) = 171602804;
    *(_QWORD *)v387 = *(_QWORD *)" contents:\n";
    *((_QWORD *)v385 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v385, " contents:\n", 0xBuLL);
  }
  v388 = *(_QWORD *)(v33 + 520);
  v389 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v388 + 352))(v388);
  v390 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 136))(*(_QWORD *)(v33 + 520));
  v32 = v391;
  v392 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 40))(*(_QWORD *)(v33 + 520));
  v393 = sub_1C5487284((uint64_t *)(v33 + 232), v388, v389, v390, v32, v392);
  ((void (*)(uint64_t (***)(), llvm::raw_ostream *))(*v393)[3])(v393, a2);
  LOWORD(v32) = v405;
LABEL_649:
  v394 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v33 + 520) + 344))(*(_QWORD *)(v33 + 520));
  if ((v32 & 0x800) != 0)
    v395 = v34;
  else
    v395 = 1;
  if ((v395 & 1) != 0)
  {
    if ((v32 & 0x800) == 0)
      return sub_1C624C568(v492);
  }
  else if (!*(_QWORD *)(v394 + 8))
  {
    return sub_1C624C568(v492);
  }
  v396 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v396)
  {
    v397 = llvm::raw_ostream::write(a2, "\n", 1uLL);
    v398 = *((_QWORD *)v397 + 4);
  }
  else
  {
    *v396 = 10;
    v398 = *((_QWORD *)a2 + 4) + 1;
    *((_QWORD *)a2 + 4) = v398;
    v397 = a2;
  }
  if ((unint64_t)(*((_QWORD *)v397 + 3) - v398) > 0xB)
  {
    *(_DWORD *)(v398 + 8) = 1936026977;
    *(_QWORD *)v398 = *(_QWORD *)".debug_names";
    v399 = *((_QWORD *)v397 + 4) + 12;
    *((_QWORD *)v397 + 4) = v399;
  }
  else
  {
    v397 = llvm::raw_ostream::write(v397, ".debug_names", 0xCuLL);
    v399 = *((_QWORD *)v397 + 4);
  }
  if ((unint64_t)(*((_QWORD *)v397 + 3) - v399) > 0xA)
  {
    *(_DWORD *)(v399 + 7) = 171602804;
    *(_QWORD *)v399 = *(_QWORD *)" contents:\n";
    *((_QWORD *)v397 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v397, " contents:\n", 0xBuLL);
  }
  DebugNames = llvm::DWARFContext::getDebugNames((llvm::DWARFContext *)v33);
  (*(void (**)(uint64_t, llvm::raw_ostream *))(*(_QWORD *)DebugNames + 24))(DebugNames, a2);
  return sub_1C624C568(v492);
}

llvm::raw_ostream **sub_1C5484650(llvm::raw_ostream **result, char *__s, llvm::DWARFUnit **a3, llvm::DWARFUnit **a4)
{
  llvm::raw_ostream **v7;
  llvm::raw_ostream **v8;
  _BYTE *v9;
  unint64_t v10;
  llvm::raw_ostream *v11;
  llvm::raw_ostream *v12;
  unint64_t v13;
  uint64_t v14;
  llvm::raw_ostream *v15;
  llvm::raw_ostream *v16;
  llvm::DWARFUnit *v17;
  llvm::raw_ostream *v18;
  uint64_t v19[2];
  _QWORD v20[11];
  uint64_t v21;
  int v22;
  uint64_t v23;

  v7 = result;
  v23 = *MEMORY[0x1E0C80C00];
  v8 = (llvm::raw_ostream **)*result;
  v9 = (_BYTE *)*((_QWORD *)*result + 4);
  if ((unint64_t)v9 >= *((_QWORD *)*result + 3))
  {
    result = (llvm::raw_ostream **)llvm::raw_ostream::write(*result, 10);
  }
  else
  {
    v8[4] = (llvm::raw_ostream *)(v9 + 1);
    *v9 = 10;
  }
  if (__s)
  {
    v10 = strlen(__s);
    result = (llvm::raw_ostream **)v8[4];
    if (v10 <= v8[3] - (llvm::raw_ostream *)result)
    {
      if (v10)
      {
        result = (llvm::raw_ostream **)memcpy(result, __s, v10);
        v8[4] = (llvm::raw_ostream *)((char *)v8[4] + v10);
      }
    }
    else
    {
      result = (llvm::raw_ostream **)llvm::raw_ostream::write((llvm::raw_ostream *)v8, __s, v10);
      v8 = result;
    }
  }
  v11 = v8[4];
  if ((unint64_t)(v8[3] - v11) > 0xA)
  {
    *(_DWORD *)((char *)v11 + 7) = 171602804;
    *(_QWORD *)v11 = *(_QWORD *)" contents:\n";
    v8[4] = (llvm::raw_ostream *)((char *)v8[4] + 11);
  }
  else
  {
    result = (llvm::raw_ostream **)llvm::raw_ostream::write((llvm::raw_ostream *)v8, " contents:\n", 0xBuLL);
  }
  v12 = v7[1];
  if (*((_BYTE *)v12 + 56))
  {
    if (a3 != a4)
    {
      v13 = *((_QWORD *)v12 + 6);
      do
      {
        v19[0] = (uint64_t)sub_1C624DB94(*a3, v13);
        v19[1] = v14;
        v15 = *v7;
        v16 = v7[2];
        sub_1C624C4A4((uint64_t)&v21, (__int128 *)v16);
        if (*((_DWORD *)v16 + 1) == -1 && !*((_BYTE *)v16 + 16))
          HIDWORD(v21) = 0;
        if (*((_DWORD *)v16 + 2) == -1 && !*((_BYTE *)v16 + 17))
          v22 = 0;
        llvm::DWARFDie::dump(v19, v15, 0, (uint64_t)&v21);
        result = (llvm::raw_ostream **)sub_1C624C568(&v21);
        ++a3;
      }
      while (a3 != a4);
    }
  }
  else
  {
    while (a3 != a4)
    {
      v17 = *a3++;
      v18 = *v7;
      sub_1C624C4A4((uint64_t)v20, (__int128 *)v7[2]);
      (*(void (**)(llvm::DWARFUnit *, llvm::raw_ostream *, _QWORD *))(*(_QWORD *)v17 + 16))(v17, v18, v20);
      result = (llvm::raw_ostream **)sub_1C624C568(v20);
    }
  }
  return result;
}

llvm::raw_ostream **sub_1C548486C(llvm::raw_ostream **result, char *__s, llvm::DWARFUnit **a3, llvm::DWARFUnit **a4)
{
  llvm::raw_ostream **v7;
  llvm::raw_ostream **v8;
  _BYTE *v9;
  unint64_t v10;
  llvm::raw_ostream *v11;
  llvm::raw_ostream *v12;
  llvm::DWARFUnit *v13;
  llvm::raw_ostream *v14;
  _BYTE *v15;
  uint64_t v16;
  llvm::raw_ostream *v17;
  llvm::raw_ostream *v18;
  uint64_t v19[2];
  _BYTE v20[88];
  _BYTE v21[4];
  int v22;
  int v23;
  uint64_t v24;

  v7 = result;
  v24 = *MEMORY[0x1E0C80C00];
  v8 = (llvm::raw_ostream **)*result;
  v9 = (_BYTE *)*((_QWORD *)*result + 4);
  if ((unint64_t)v9 >= *((_QWORD *)*result + 3))
  {
    result = (llvm::raw_ostream **)llvm::raw_ostream::write(*result, 10);
  }
  else
  {
    v8[4] = (llvm::raw_ostream *)(v9 + 1);
    *v9 = 10;
  }
  if (__s)
  {
    v10 = strlen(__s);
    result = (llvm::raw_ostream **)v8[4];
    if (v10 <= v8[3] - (llvm::raw_ostream *)result)
    {
      if (v10)
      {
        result = (llvm::raw_ostream **)memcpy(result, __s, v10);
        v8[4] = (llvm::raw_ostream *)((char *)v8[4] + v10);
      }
    }
    else
    {
      result = (llvm::raw_ostream **)llvm::raw_ostream::write((llvm::raw_ostream *)v8, __s, v10);
      v8 = result;
    }
  }
  v11 = v8[4];
  if ((unint64_t)(v8[3] - v11) > 0xA)
  {
    *(_DWORD *)((char *)v11 + 7) = 171602804;
    *(_QWORD *)v11 = *(_QWORD *)" contents:\n";
    v8[4] = (llvm::raw_ostream *)((char *)v8[4] + 11);
  }
  else
  {
    result = (llvm::raw_ostream **)llvm::raw_ostream::write((llvm::raw_ostream *)v8, " contents:\n", 0xBuLL);
  }
  while (a3 != a4)
  {
    v12 = v7[1];
    if (*((_BYTE *)v12 + 72))
    {
      v19[0] = (uint64_t)sub_1C624DB94(*a3, *((_QWORD *)v12 + 8));
      v19[1] = v16;
      v17 = *v7;
      v18 = v7[2];
      sub_1C624C4A4((uint64_t)v21, (__int128 *)v18);
      if (*((_DWORD *)v18 + 1) == -1 && !*((_BYTE *)v18 + 16))
        v22 = 0;
      if (*((_DWORD *)v18 + 2) == -1 && !*((_BYTE *)v18 + 17))
        v23 = 0;
      llvm::DWARFDie::dump(v19, v17, 0, (uint64_t)v21);
      v15 = v21;
    }
    else
    {
      v13 = *a3;
      v14 = *v7;
      sub_1C624C4A4((uint64_t)v20, (__int128 *)v7[2]);
      (*(void (**)(llvm::DWARFUnit *, llvm::raw_ostream *, _BYTE *))(*(_QWORD *)v13 + 16))(v13, v14, v20);
      v15 = v20;
    }
    result = (llvm::raw_ostream **)sub_1C624C568(v15);
    ++a3;
  }
  return result;
}

uint64_t llvm::DWARFContext::getDebugLoc(llvm::DWARFContext *this)
{
  uint64_t result;
  int v3;
  uint64_t *v4;
  uint64_t v5;
  char v6;
  char v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;

  result = *((_QWORD *)this + 18);
  if (!result)
  {
    llvm::DWARFContext::parseNormalUnits((uint64_t)this);
    v3 = *((_DWORD *)this + 18);
    if (v3 == -1)
      v3 = *((_DWORD *)this + 6);
    v4 = (uint64_t *)*((_QWORD *)this + 65);
    v5 = *v4;
    if (v3)
    {
      v9 = (*(uint64_t (**)(_QWORD))(v5 + 80))(*((_QWORD *)this + 65));
      v6 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 65) + 40))(*((_QWORD *)this + 65));
      llvm::DWARFContext::parseNormalUnits((uint64_t)this);
      v7 = *(_BYTE *)(**((_QWORD **)this + 2) + 34);
      v10 = *(const char **)v9;
      v8 = *(_QWORD *)(v9 + 8);
    }
    else
    {
      v6 = (*(uint64_t (**)(_QWORD))(v5 + 40))(*((_QWORD *)this + 65));
      v7 = 0;
      v8 = 0;
      v4 = 0;
      v9 = 0;
      v10 = "";
    }
    result = operator new();
    *(_QWORD *)(result + 16) = v8;
    *(_BYTE *)(result + 24) = v6;
    *(_BYTE *)(result + 25) = v7;
    *(_QWORD *)(result + 32) = v4;
    *(_QWORD *)(result + 40) = v9;
    *(_QWORD *)result = &unk_1E816A070;
    *(_QWORD *)(result + 8) = v10;
    *(_QWORD *)(result + 48) = result + 64;
    *(_QWORD *)(result + 56) = 0x400000000;
    v11 = *((_QWORD *)this + 18);
    *((_QWORD *)this + 18) = result;
    if (v11)
    {
      sub_1C624E1D0((char **)(v11 + 48));
      MEMORY[0x1CAA32FC0](v11, 0x10F1C40D646D640);
      return *((_QWORD *)this + 18);
    }
  }
  return result;
}

llvm::raw_ostream *sub_1C5484BBC(llvm::raw_ostream *result, uint64_t a2, __int128 *a3, uint64_t a4, uint64_t a5, unint64_t a6, unsigned __int8 a7)
{
  llvm::raw_ostream *v10;
  __int128 v11;
  llvm::raw_ostream *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  __int128 v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  _BYTE *v21;
  llvm::DWARFContext *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v27;
  __int128 v28;
  char v29;
  llvm::raw_ostream *v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;
  __int16 v34;
  __int128 v35;
  uint64_t v36;
  uint64_t v37;
  _OWORD v38[2];
  uint64_t v39;
  uint64_t v40;
  __int16 v41;
  char v42;
  char v43;
  uint64_t v44;
  const char *v45;
  uint64_t v46;
  const char *v47;
  uint64_t v48;
  unint64_t v49;
  __int128 v50[5];
  _QWORD v51[11];
  _QWORD v52[13];

  v52[11] = *MEMORY[0x1E0C80C00];
  v49 = 0;
  if (*((_QWORD *)a3 + 1))
  {
    v10 = result;
    v27 = a7;
    while (1)
    {
      v40 = 0;
      v45 = ".debug_loclists";
      v46 = 15;
      v47 = "locations";
      v48 = 9;
      v11 = a3[1];
      v38[0] = *a3;
      v38[1] = v11;
      v39 = *((_QWORD *)a3 + 4);
      llvm::DWARFListTableHeader::extract((uint64_t)&v40, (uint64_t)v38, &v49, (uint64_t *)&v30);
      if (v30)
        break;
      v35 = *a3;
      v36 = *((_QWORD *)a3 + 2);
      sub_1C624C4A4((uint64_t)v52, (__int128 *)a2);
      v12 = v10;
      llvm::DWARFListTableHeader::dump(&v40, &v35, v10, (uint64_t)v52);
      result = (llvm::raw_ostream *)sub_1C624C568(v52);
      v13 = 12;
      if (!v43)
        v13 = 4;
      v14 = v13 + v40;
      if (v40)
        v15 = v14;
      else
        v15 = 0;
      v16 = v15 + v44;
      *((_BYTE *)a3 + 17) = v42;
      v17 = a3[1];
      v31 = *a3;
      v32 = v17;
      v33 = *((_QWORD *)a3 + 4);
      v30 = (llvm::raw_ostream *)&unk_1E816A040;
      v34 = v41;
      v18 = v49;
      if (v27)
      {
        v10 = v12;
        if (a6 >= v49 && a6 < v16)
        {
          v49 = a6;
          LOBYTE(v28) = 0;
          v29 = 0;
          sub_1C624C4A4((uint64_t)v51, (__int128 *)a2);
          LODWORD(v23) = 0;
          llvm::DWARFLocationTable::dumpLocationList((uint64_t)&v30, (uint64_t *)&v49, v12, &v28, a4, a5, 0, (uint64_t)v51, v23);
          result = (llvm::raw_ostream *)sub_1C624C568(v51);
          v21 = (_BYTE *)*((_QWORD *)v12 + 4);
          if (*((_BYTE **)v12 + 3) == v21)
            return llvm::raw_ostream::write(v12, "\n", 1uLL);
          *v21 = 10;
          ++*((_QWORD *)v12 + 4);
          return result;
        }
      }
      else
      {
        v24 = v16 - v49;
        sub_1C624C4A4((uint64_t)v50, (__int128 *)a2);
        v19 = v18;
        v10 = v12;
        llvm::DWARFDebugLoclists::dumpRange((uint64_t)&v30, v19, v24, v12, a4, a5, v50);
        result = (llvm::raw_ostream *)sub_1C624C568(v50);
      }
      v49 = v16;
      if (*((_QWORD *)a3 + 1) <= v16)
        return result;
    }
    v37 = (uint64_t)v30;
    v30 = 0;
    v20 = *(_QWORD *)(a2 + 48);
    if (v20)
    {
      (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v20 + 48))(v20, &v37);
      if (v37)
        (*(void (**)(uint64_t))(*(_QWORD *)v37 + 8))(v37);
      result = v30;
      if (v30)
        return (llvm::raw_ostream *)(*(uint64_t (**)(llvm::raw_ostream *))(*(_QWORD *)v30 + 8))(v30);
    }
    else
    {
      sub_1C485C2F0();
      return (llvm::raw_ostream *)llvm::DWARFContext::getDebugFrame(v22);
    }
  }
  return result;
}

uint64_t llvm::DWARFContext::getDebugFrame@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  char v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  void **v15;
  uint64_t v16;
  _QWORD v17[2];
  char v18;
  char v19;
  uint64_t v20;
  _QWORD *v21;
  void **v22;

  v3 = *(_QWORD *)(this + 168);
  if (v3)
  {
    *(_BYTE *)(a2 + 8) &= ~1u;
    *(_QWORD *)a2 = v3;
    return this;
  }
  v4 = this;
  v5 = (_QWORD *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(this + 520) + 104))(*(_QWORD *)(this + 520));
  v6 = *(_QWORD *)(v4 + 520);
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6);
  v8 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v4 + 520) + 48))(*(_QWORD *)(v4 + 520));
  v9 = *v5;
  v10 = v5[1];
  v11 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v4 + 520) + 24))(*(_QWORD *)(v4 + 520));
  v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v11 + 376))(v11);
  v13 = operator new();
  v14 = v5[2];
  *(_DWORD *)v13 = v12;
  *(_BYTE *)(v13 + 4) = 0;
  *(_QWORD *)(v13 + 24) = 0;
  *(_QWORD *)(v13 + 32) = 0;
  *(_QWORD *)(v13 + 8) = v14;
  *(_QWORD *)(v13 + 16) = 0;
  v17[0] = v9;
  v17[1] = v10;
  v18 = v7;
  v19 = v8;
  v20 = v6;
  v21 = v5;
  this = llvm::DWARFDebugFrame::parse(v13, (uint64_t)v17, (uint64_t *)&v22);
  v15 = v22;
  if (v22)
  {
    *(_BYTE *)(a2 + 8) |= 1u;
    *(_QWORD *)a2 = v15;
  }
  else
  {
    v16 = *(_QWORD *)(v4 + 168);
    *(_QWORD *)(v4 + 168) = v13;
    *(_BYTE *)(a2 + 8) &= ~1u;
    *(_QWORD *)a2 = v13;
    v13 = v16;
    if (!v16)
      return this;
  }
  v22 = (void **)(v13 + 16);
  sub_1C4764BBC(&v22);
  return MEMORY[0x1CAA32FC0](v13, 0x1020C40CCA6D962);
}

uint64_t llvm::DWARFContext::getEHFrame@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  char v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  void **v15;
  uint64_t v16;
  _QWORD v17[2];
  char v18;
  char v19;
  uint64_t v20;
  _QWORD *v21;
  void **v22;

  v3 = *(_QWORD *)(this + 176);
  if (v3)
  {
    *(_BYTE *)(a2 + 8) &= ~1u;
    *(_QWORD *)a2 = v3;
    return this;
  }
  v4 = this;
  v5 = (_QWORD *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(this + 520) + 112))(*(_QWORD *)(this + 520));
  v6 = *(_QWORD *)(v4 + 520);
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6);
  v8 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v4 + 520) + 48))(*(_QWORD *)(v4 + 520));
  v9 = *v5;
  v10 = v5[1];
  v11 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v4 + 520) + 24))(*(_QWORD *)(v4 + 520));
  v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v11 + 376))(v11);
  v13 = operator new();
  v14 = v5[2];
  *(_DWORD *)v13 = v12;
  *(_BYTE *)(v13 + 4) = 1;
  *(_QWORD *)(v13 + 24) = 0;
  *(_QWORD *)(v13 + 32) = 0;
  *(_QWORD *)(v13 + 8) = v14;
  *(_QWORD *)(v13 + 16) = 0;
  v17[0] = v9;
  v17[1] = v10;
  v18 = v7;
  v19 = v8;
  v20 = v6;
  v21 = v5;
  this = llvm::DWARFDebugFrame::parse(v13, (uint64_t)v17, (uint64_t *)&v22);
  v15 = v22;
  if (v22)
  {
    *(_BYTE *)(a2 + 8) |= 1u;
    *(_QWORD *)a2 = v15;
  }
  else
  {
    v16 = *(_QWORD *)(v4 + 168);
    *(_QWORD *)(v4 + 168) = v13;
    *(_BYTE *)(a2 + 8) &= ~1u;
    *(_QWORD *)a2 = v13;
    v13 = v16;
    if (!v16)
      return this;
  }
  v22 = (void **)(v13 + 16);
  sub_1C4764BBC(&v22);
  return MEMORY[0x1CAA32FC0](v13, 0x1020C40CCA6D962);
}

uint64_t llvm::DWARFContext::getDebugMacro(llvm::DWARFContext *this)
{
  uint64_t result;
  char **v3;
  void **v4;
  void **v5;
  char **v6;
  void **v7;

  result = *((_QWORD *)this + 23);
  if (!result)
  {
    llvm::DWARFContext::parseMacroOrMacinfo((uint64_t)this, 2, &v6);
    v3 = v6;
    v6 = 0;
    v4 = (void **)*((_QWORD *)this + 23);
    *((_QWORD *)this + 23) = v3;
    if (v4)
    {
      v7 = v4;
      sub_1C548BD34(&v7);
      MEMORY[0x1CAA32FC0](v4, 0x20C40960023A9);
      v5 = (void **)v6;
      v6 = 0;
      if (v5)
      {
        v7 = v5;
        sub_1C548BD34(&v7);
        MEMORY[0x1CAA32FC0](v5, 0x20C40960023A9);
      }
    }
    return *((_QWORD *)this + 23);
  }
  return result;
}

uint64_t llvm::DWARFContext::getDebugMacroDWO(llvm::DWARFContext *this)
{
  uint64_t result;
  char **v3;
  void **v4;
  void **v5;
  char **v6;
  void **v7;

  result = *((_QWORD *)this + 44);
  if (!result)
  {
    llvm::DWARFContext::parseMacroOrMacinfo((uint64_t)this, 3, &v6);
    v3 = v6;
    v6 = 0;
    v4 = (void **)*((_QWORD *)this + 44);
    *((_QWORD *)this + 44) = v3;
    if (v4)
    {
      v7 = v4;
      sub_1C548BD34(&v7);
      MEMORY[0x1CAA32FC0](v4, 0x20C40960023A9);
      v5 = (void **)v6;
      v6 = 0;
      if (v5)
      {
        v7 = v5;
        sub_1C548BD34(&v7);
        MEMORY[0x1CAA32FC0](v5, 0x20C40960023A9);
      }
    }
    return *((_QWORD *)this + 44);
  }
  return result;
}

uint64_t llvm::DWARFContext::getDebugMacinfo(llvm::DWARFContext *this)
{
  uint64_t result;
  char **v3;
  void **v4;
  void **v5;
  char **v6;
  void **v7;

  result = *((_QWORD *)this + 24);
  if (!result)
  {
    llvm::DWARFContext::parseMacroOrMacinfo((uint64_t)this, 0, &v6);
    v3 = v6;
    v6 = 0;
    v4 = (void **)*((_QWORD *)this + 24);
    *((_QWORD *)this + 24) = v3;
    if (v4)
    {
      v7 = v4;
      sub_1C548BD34(&v7);
      MEMORY[0x1CAA32FC0](v4, 0x20C40960023A9);
      v5 = (void **)v6;
      v6 = 0;
      if (v5)
      {
        v7 = v5;
        sub_1C548BD34(&v7);
        MEMORY[0x1CAA32FC0](v5, 0x20C40960023A9);
      }
    }
    return *((_QWORD *)this + 24);
  }
  return result;
}

uint64_t llvm::DWARFContext::getDebugMacinfoDWO(llvm::DWARFContext *this)
{
  uint64_t result;
  char **v3;
  void **v4;
  void **v5;
  char **v6;
  void **v7;

  result = *((_QWORD *)this + 43);
  if (!result)
  {
    llvm::DWARFContext::parseMacroOrMacinfo((uint64_t)this, 1, &v6);
    v3 = v6;
    v6 = 0;
    v4 = (void **)*((_QWORD *)this + 43);
    *((_QWORD *)this + 43) = v3;
    if (v4)
    {
      v7 = v4;
      sub_1C548BD34(&v7);
      MEMORY[0x1CAA32FC0](v4, 0x20C40960023A9);
      v5 = (void **)v6;
      v6 = 0;
      if (v5)
      {
        v7 = v5;
        sub_1C548BD34(&v7);
        MEMORY[0x1CAA32FC0](v5, 0x20C40960023A9);
      }
    }
    return *((_QWORD *)this + 43);
  }
  return result;
}

uint64_t sub_1C548541C(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t result;
  unint64_t v7;
  char *CStrRef;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  llvm::raw_ostream *v13;
  size_t v14;
  llvm::raw_ostream *v15;
  _WORD *v16;
  llvm::DWARFContext *v17;
  _QWORD v18[3];
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22[2];
  char v23;
  char v24;

  result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)a1 + 520) + 40))(*(_QWORD *)(*(_QWORD *)a1 + 520));
  v7 = 0;
  v22[0] = a2;
  v22[1] = a3;
  v23 = result;
  v24 = 0;
  v21 = 0;
  while (a3 > v21)
  {
    v20 = 0;
    CStrRef = (char *)llvm::DataExtractor::getCStrRef(v22, &v21, &v20);
    v9 = v20;
    if (v20)
    {
      v10 = *(_QWORD *)(a1 + 8);
      v19 = v20;
      v20 = 0;
      v11 = *(_QWORD *)(v10 + 80);
      if (!v11)
      {
        sub_1C485C2F0();
        return llvm::DWARFContext::getCUAddrSize(v17);
      }
      (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v11 + 48))(v11, &v19);
      if (v19)
        (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
    }
    else
    {
      v12 = CStrRef;
      v13 = *(llvm::raw_ostream **)(a1 + 16);
      v18[0] = &unk_1E8133270;
      v18[1] = "0x%8.8llx: \"";
      v18[2] = v7;
      llvm::raw_ostream::operator<<(v13, (uint64_t)v18);
      if (v12)
        v14 = strlen(v12);
      else
        v14 = 0;
      llvm::raw_ostream::write_escaped(*(llvm::raw_ostream **)(a1 + 16), v12, v14, 0);
      v15 = *(llvm::raw_ostream **)(a1 + 16);
      v16 = (_WORD *)*((_QWORD *)v15 + 4);
      if (*((_QWORD *)v15 + 3) - (_QWORD)v16 > 1uLL)
      {
        *v16 = 2594;
        *((_QWORD *)v15 + 4) += 2;
      }
      else
      {
        llvm::raw_ostream::write(v15, "\"\n", 2uLL);
      }
      v7 = v21;
    }
    result = v20;
    if (v20)
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v20 + 8))(v20);
    if (v9)
      return result;
  }
  return result;
}

uint64_t llvm::DWARFContext::getCUAddrSize(llvm::DWARFContext *this)
{
  _QWORD v2[6];

  sub_1C548BC00((uint64_t)this, v2);
  if (v2[0] == v2[3])
    return 0;
  else
    return *(unsigned __int8 *)(*(_QWORD *)v2[0] + 34);
}

void sub_1C54855EC(llvm::raw_ostream *a1, __int128 *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v8;
  char *v9;
  int v10;
  char v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t **i;
  uint64_t **v21;
  unint64_t v22;
  uint64_t *v23;
  uint64_t *v24;
  char *v25;
  char *v26;
  size_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t *v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  uint64_t **v36;
  uint64_t *v37;
  uint64_t *v38;
  size_t v39;
  unint64_t v40;
  char *v41;
  uint64_t *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char v46;
  size_t v47;
  _BYTE *v48;
  llvm::raw_ostream *v49;
  unint64_t v50;
  uint64_t *v51;
  uint64_t *v52;
  uint64_t j;
  unint64_t v54;
  unint64_t v55;
  uint64_t *v56;
  uint64_t **v57;
  BOOL v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t *v62;
  uint64_t **v63;
  uint64_t v64;
  unint64_t v65;
  char *v67;
  __int128 *v68;
  llvm::raw_ostream *v69;
  uint64_t v70;
  BOOL v71;
  char v72;
  char *v73;
  __int128 v74;
  __int128 v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  char v80;
  unint64_t v81;
  const char *v82;
  uint64_t v83;
  const char *v84;
  uint64_t v85;
  uint64_t **v86;
  uint64_t *v87;
  uint64_t v88;
  const char *v89;
  size_t v90;
  unint64_t v91;
  uint64_t v92;
  __int128 v93;
  uint64_t v94;
  __int128 v95;
  char v96;
  _BYTE v97[22];
  _QWORD v98[2];
  BOOL v99;
  char v100;
  _OWORD v101[4];
  char *v102;
  char *v103;
  _QWORD v104[12];

  v104[9] = *MEMORY[0x1E0C80C00];
  v91 = 0;
  v68 = a2;
  v67 = (char *)a2 + 18;
  do
  {
    v8 = *((_QWORD *)a2 + 1);
    if (v8 <= v91)
      return;
    v65 = v91;
    v82 = ".debug_rnglists";
    v83 = 15;
    v84 = "range";
    v85 = 5;
    v87 = 0;
    v88 = 0;
    v86 = &v87;
    v89 = "ranges:";
    v90 = 7;
    v9 = *(char **)a2;
    v10 = *((unsigned __int8 *)a2 + 16);
    v11 = *((_BYTE *)a2 + 17);
    *(_OWORD *)v97 = *(_OWORD *)v67;
    *(_QWORD *)&v97[14] = *(_QWORD *)(v67 + 14);
    v78 = 0;
    v79 = 0;
    sub_1C624E018((uint64_t)&v86, 0);
    v87 = 0;
    v88 = 0;
    v86 = &v87;
    v73 = v9;
    v102 = v9;
    v103 = (char *)v8;
    LOBYTE(v104[0]) = v10;
    BYTE1(v104[0]) = v11;
    *(_OWORD *)((char *)v104 + 2) = *(_OWORD *)v97;
    v104[2] = *(_QWORD *)&v97[14];
    llvm::DWARFListTableHeader::extract((uint64_t)&v78, (uint64_t)&v102, &v91, &v77);
    v12 = v77;
    if (v77)
    {
      v43 = a5;
LABEL_53:
      v76 = v12;
      v77 = 0;
      v44 = *(_QWORD *)(v43 + 48);
      if (!v44)
        sub_1C485C2F0();
      (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v44 + 48))(v44, &v76);
      if (v76)
        (*(void (**)(uint64_t))(*(_QWORD *)v76 + 8))(v76);
      if (!v78)
        goto LABEL_60;
      v45 = 12;
      if (!v80)
        v45 = 4;
      if (v45 + v78)
      {
        v91 = v45 + v78 + v65;
        v46 = 1;
      }
      else
      {
LABEL_60:
        v46 = 0;
      }
      goto LABEL_98;
    }
    v64 = a4;
    v72 = BYTE2(v79);
    v13 = 12;
    if (!v80)
      v13 = 4;
    v14 = v13 + v78;
    if (v78)
      v15 = v14;
    else
      v15 = 0;
    if (v8 >= v15 + v81)
      v16 = v15 + v81;
    else
      v16 = v8;
    v71 = v10 != 0;
    v69 = a1;
    v70 = a3;
    do
    {
      v17 = v91;
      if (v16 <= v91)
      {
        v77 = 0;
        v43 = a5;
        a4 = v64;
        goto LABEL_62;
      }
      v102 = 0;
      v103 = 0;
      v104[0] = 0;
      v98[0] = v73;
      v98[1] = v16;
      v99 = v71;
      v100 = v72;
      v101[0] = *(_OWORD *)v97;
      *(_QWORD *)((char *)v101 + 14) = *(_QWORD *)&v97[14];
      sub_1C548BF38(&v102, (uint64_t)v98, v81, (uint64_t *)&v91, (uint64_t)v82, (uint64_t)v84, &v77);
      v18 = v77;
      if (!v77)
      {
        v19 = v87;
        for (i = &v87; ; v19 = *i)
        {
          v21 = i;
          if (!v19)
            break;
          while (1)
          {
            i = (uint64_t **)v19;
            v22 = v19[4];
            if (v22 > v17)
              break;
            if (v22 >= v17)
              goto LABEL_25;
            v19 = i[1];
            if (!v19)
            {
              v21 = i + 1;
              goto LABEL_22;
            }
          }
        }
LABEL_22:
        v23 = (uint64_t *)i;
        i = (uint64_t **)operator new(0x40uLL);
        *i = 0;
        i[1] = 0;
        i[4] = (uint64_t *)v17;
        i[5] = 0;
        i[6] = 0;
        i[7] = 0;
        i[2] = v23;
        *v21 = (uint64_t *)i;
        v24 = (uint64_t *)i;
        if (*v86)
        {
          v86 = (uint64_t **)*v86;
          v24 = *v21;
        }
        sub_1C4768E74(v87, v24);
        ++v88;
LABEL_25:
        if (i + 5 != (uint64_t **)&v102)
        {
          v26 = v102;
          v25 = v103;
          v27 = v103 - v102;
          v28 = 0xCCCCCCCCCCCCCCCDLL * ((v103 - v102) >> 3);
          v29 = (uint64_t)i[7];
          v30 = i[5];
          if (0xCCCCCCCCCCCCCCCDLL * ((v29 - (uint64_t)v30) >> 3) < v28)
          {
            if (v30)
            {
              i[6] = v30;
              operator delete(v30);
              v29 = 0;
              i[5] = 0;
              i[6] = 0;
              i[7] = 0;
            }
            if (v28 > 0x666666666666666)
              goto LABEL_104;
            v31 = 0xCCCCCCCCCCCCCCCDLL * (v29 >> 3);
            v32 = 2 * v31;
            if (2 * v31 <= v28)
              v32 = 0xCCCCCCCCCCCCCCCDLL * ((v25 - v26) >> 3);
            v33 = v31 >= 0x333333333333333 ? 0x666666666666666 : v32;
            if (v33 > 0x666666666666666)
LABEL_104:
              abort();
            v34 = 5 * v33;
            v35 = (uint64_t *)operator new(40 * v33);
            v30 = v35;
            i[6] = v35;
            v36 = i + 6;
            *(v36 - 1) = v35;
            v36[1] = &v35[v34];
            if (v25 != v26)
              memcpy(v35, v26, v25 - v26);
            goto LABEL_46;
          }
          v38 = i[6];
          v36 = i + 6;
          v37 = v38;
          v39 = (char *)v38 - (char *)v30;
          v40 = 0xCCCCCCCCCCCCCCCDLL * (v38 - v30);
          if (v40 >= v28)
          {
            if (v103 == v102)
            {
LABEL_46:
              *v36 = (uint64_t *)((char *)v30 + v27);
              a1 = v69;
              a3 = v70;
              goto LABEL_47;
            }
            v42 = v30;
            v41 = v102;
          }
          else
          {
            if (v37 != v30)
            {
              memmove(v30, v102, v39);
              v30 = *v36;
            }
            v41 = &v26[40 * v40];
            v27 = v25 - v41;
            if (v25 == v41)
              goto LABEL_46;
            v42 = v30;
          }
          memmove(v42, v41, v27);
          goto LABEL_46;
        }
      }
LABEL_47:
      if (v102)
      {
        v103 = v102;
        operator delete(v102);
      }
    }
    while (!v18);
    v12 = v77;
    v43 = a5;
    a4 = v64;
    if (v77)
      goto LABEL_53;
LABEL_62:
    v74 = *v68;
    v75 = v68[1];
    sub_1C624C4A4((uint64_t)&v95, (__int128 *)v43);
    v93 = v74;
    v94 = v75;
    sub_1C624C4A4((uint64_t)&v102, &v95);
    llvm::DWARFListTableHeader::dump(&v78, &v93, a1, (uint64_t)&v102);
    sub_1C624C568(&v102);
    v47 = v90;
    v48 = (_BYTE *)*((_QWORD *)a1 + 4);
    if (v90 <= *((_QWORD *)a1 + 3) - (_QWORD)v48)
    {
      if (v90)
      {
        memcpy(v48, v89, v90);
        v48 = (_BYTE *)(*((_QWORD *)a1 + 4) + v47);
        *((_QWORD *)a1 + 4) = v48;
      }
      v49 = a1;
    }
    else
    {
      v49 = llvm::raw_ostream::write(a1, v89, v90);
      v48 = (_BYTE *)*((_QWORD *)v49 + 4);
    }
    if (*((_BYTE **)v49 + 3) == v48)
    {
      llvm::raw_ostream::write(v49, "\n", 1uLL);
    }
    else
    {
      *v48 = 10;
      ++*((_QWORD *)v49 + 4);
    }
    LOBYTE(v50) = 0;
    v51 = (uint64_t *)v86;
    if (v96 && v86 != &v87)
    {
      v50 = 0;
      v52 = (uint64_t *)v86;
      do
      {
        for (j = v52[5]; j != v52[6]; j += 40)
        {
          v54 = *(char *)(j + 8);
          if (v54 > 7)
            v55 = 0;
          else
            v55 = qword_1C86517D8[v54];
          if (v50 <= v55)
            v50 = v55;
        }
        v56 = (uint64_t *)v52[1];
        if (v56)
        {
          do
          {
            v57 = (uint64_t **)v56;
            v56 = (uint64_t *)*v56;
          }
          while (v56);
        }
        else
        {
          do
          {
            v57 = (uint64_t **)v52[2];
            v58 = *v57 == v52;
            v52 = (uint64_t *)v57;
          }
          while (!v58);
        }
        v52 = (uint64_t *)v57;
      }
      while (v57 != &v87);
    }
    v92 = 0;
    if (v86 != &v87)
    {
      do
      {
        v60 = v51[5];
        v59 = v51[6];
        while (v60 != v59)
        {
          v61 = BYTE2(v79);
          sub_1C624C4A4((uint64_t)v98, &v95);
          llvm::RangeListEntry::dump(v60, a1, v61, v50, (uint64_t)&v92, (uint64_t)v98);
          sub_1C624C568(v98);
          v60 += 40;
        }
        v62 = (uint64_t *)v51[1];
        if (v62)
        {
          do
          {
            v63 = (uint64_t **)v62;
            v62 = (uint64_t *)*v62;
          }
          while (v62);
        }
        else
        {
          do
          {
            v63 = (uint64_t **)v51[2];
            v58 = *v63 == v51;
            v51 = (uint64_t *)v63;
          }
          while (!v58);
        }
        v51 = (uint64_t *)v63;
      }
      while (v63 != &v87);
    }
    sub_1C624C568(&v95);
    v46 = 1;
LABEL_98:
    if (v77)
      (*(void (**)(uint64_t))(*(_QWORD *)v77 + 8))(v77);
    sub_1C624E018((uint64_t)&v86, v87);
    a2 = v68;
  }
  while ((v46 & 1) != 0);
}

void sub_1C5485CF8(llvm::raw_ostream *a1, uint64_t a2, uint64_t a3, int a4)
{
  __int128 v5;
  char *v6;
  char *v7;
  void *v8;
  void *v9;
  _OWORD v10[2];
  uint64_t v11;
  void *__p;
  char *v13;
  uint64_t v14;
  char v15;

  __p = 0;
  v13 = 0;
  v15 = 0;
  v14 = 0;
  v5 = *(_OWORD *)(a3 + 16);
  v10[0] = *(_OWORD *)a3;
  v10[1] = v5;
  v11 = *(_QWORD *)(a3 + 32);
  llvm::DWARFDebugPubTable::extract(&__p, (uint64_t)v10, a4, (void (*)(_QWORD, _QWORD))sub_1C624E09C, a2 + 24);
  llvm::DWARFDebugPubTable::dump((uint64_t **)&__p, a1);
  v6 = (char *)__p;
  if (__p)
  {
    v7 = v13;
    v8 = __p;
    if (v13 != __p)
    {
      do
      {
        v9 = (void *)*((_QWORD *)v7 - 3);
        if (v9)
        {
          *((_QWORD *)v7 - 2) = v9;
          operator delete(v9);
        }
        v7 -= 56;
      }
      while (v7 != v6);
      v8 = __p;
    }
    v13 = v6;
    operator delete(v8);
  }
}

void sub_1C5485DA4(llvm::raw_ostream *a1, uint64_t a2, const void *a3, size_t a4, uint64_t a5, _QWORD *a6, uint64_t a7, uint64_t a8, __n128 a9, __n128 **a10, __n128 **a11, char a12)
{
  __n128 **v13;
  char *v14;
  char *v15;
  __n128 *v16;
  uint64_t v17;
  __n128 v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  char *v22;
  __int128 v23;
  char *v24;
  __n128 *v25;
  __n128 v26;
  char *v27;
  unint64_t v28;
  uint64_t v29;
  __n128 *i;
  BOOL v31;
  char *v32;
  BOOL v33;
  __n128 v34;
  unint64_t v35;
  unint64_t v36;
  __n128 *v37;
  int v38;
  int v39;
  __int16 v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  const std::error_category *v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  llvm::raw_ostream *v49;
  _BYTE *v50;
  uint64_t v51;
  llvm::raw_ostream *v52;
  uint64_t v53;
  const char *v54;
  int v55;
  _DWORD *v56;
  uint64_t v57;
  _BYTE *v58;
  unint64_t v59;
  int v60;
  void *CStrRef;
  _BYTE *v62;
  llvm::raw_ostream *v63;
  _BYTE *v64;
  void *v65;
  _WORD *v66;
  uint64_t v67;
  unint64_t v69;
  int v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79[2];
  char v80;
  char v81;
  _QWORD v82[2];
  char v83;
  char v84;
  uint64_t v85;
  _QWORD *v86;
  void (**v87)(llvm::raw_ostream *__hidden);
  const char *v88;
  unint64_t v89;
  unint64_t v90;
  uint64_t v91;
  char v92;
  uint64_t v93;
  int v94;
  void **v95;
  void *v96[2];
  uint64_t v97;
  unint64_t v98[4];
  __int16 v99;

  v13 = a10;
  if (a10 == a11)
  {
    v16 = 0;
    v15 = 0;
  }
  else
  {
    v14 = 0;
    v15 = 0;
    v16 = 0;
    do
    {
      if ((*v13)[15].n128_u8[8])
      {
        v17 = (uint64_t)&(*v13)[14];
        if (v16 >= (__n128 *)v14)
        {
          v19 = ((char *)v16 - v15) >> 5;
          v20 = v19 + 1;
          if ((unint64_t)(v19 + 1) >> 59)
            abort();
          if ((v14 - v15) >> 4 > v20)
            v20 = (v14 - v15) >> 4;
          if ((unint64_t)(v14 - v15) >= 0x7FFFFFFFFFFFFFE0)
            v21 = 0x7FFFFFFFFFFFFFFLL;
          else
            v21 = v20;
          if (v21)
          {
            if (v21 >> 59)
              goto LABEL_132;
            v22 = (char *)operator new(32 * v21);
          }
          else
          {
            v22 = 0;
          }
          a9 = *(__n128 *)v17;
          v23 = *(_OWORD *)(v17 + 16);
          v24 = &v22[32 * v19];
          *(_OWORD *)v24 = *(_OWORD *)v17;
          *((_OWORD *)v24 + 1) = v23;
          if (v16 == (__n128 *)v15)
          {
            v27 = &v22[32 * v19];
          }
          else
          {
            v25 = (__n128 *)&v22[32 * v19];
            do
            {
              a9 = v16[-2];
              v26 = v16[-1];
              v27 = (char *)&v25[-2];
              v25[-2] = a9;
              v25[-1] = v26;
              v16 -= 2;
              v25 -= 2;
            }
            while (v16 != (__n128 *)v15);
          }
          v14 = &v22[32 * v21];
          v16 = (__n128 *)(v24 + 32);
          if (v15)
            operator delete(v15);
          v15 = v27;
        }
        else
        {
          a9 = *(__n128 *)v17;
          v18 = (*v13)[15];
          *v16 = *(__n128 *)v17;
          v16[1] = v18;
          v16 += 2;
        }
      }
      ++v13;
    }
    while (v13 != a11);
  }
  v28 = 126 - 2 * __clz(((char *)v16 - v15) >> 5);
  if (v16 == (__n128 *)v15)
    v29 = 0;
  else
    v29 = v28;
  sub_1C548C300((uint64_t)v15, v16, v29, 1, a9);
  if (v16 != (__n128 *)v15)
  {
    for (i = (__n128 *)(v15 + 32); i != v16; i += 2)
    {
      if (i[-1].n128_u8[8])
        v31 = i[1].n128_u8[8] == 0;
      else
        v31 = 1;
      if (!v31 && i[-2].n128_u64[0] == i->n128_u64[0] && i[-2].n128_u64[1] == i->n128_u64[1])
      {
        v32 = (char *)&i[-2];
        if (&i[-2] != v16)
        {
          while (1)
          {
            i += 2;
            if (i == v16)
              break;
            if (v32[24])
              v33 = i[1].n128_u8[8] == 0;
            else
              v33 = 1;
            if (v33 || *(_QWORD *)v32 != i->n128_u64[0] || *((_QWORD *)v32 + 1) != i->n128_u64[1])
            {
              v34 = i[1];
              *((__n128 *)v32 + 2) = *i;
              *((__n128 *)v32 + 3) = v34;
              v32 += 32;
            }
          }
          if (v32 + 32 != (char *)v16)
            v16 = (__n128 *)(v32 + 32);
        }
        break;
      }
    }
  }
  v35 = a6[1];
  v82[0] = *a6;
  v82[1] = v35;
  v69 = v35;
  v83 = a12;
  v84 = 0;
  v85 = a5;
  v86 = a6;
  v79[0] = a7;
  v79[1] = a8;
  v80 = a12;
  v81 = 0;
  v78 = 0;
  if (v15 != (char *)v16)
  {
    v36 = 0;
    v37 = (__n128 *)v15;
    while (1)
    {
      if (!v37[1].n128_u8[8])
      {
        v65 = (void *)*((_QWORD *)a1 + 4);
        if (*((_QWORD *)a1 + 3) - (_QWORD)v65 > 0x3FuLL)
        {
          qmemcpy(v65, "error: invalid contribution to string offsets table in section .", 64);
          v66 = (_WORD *)(*((_QWORD *)a1 + 4) + 64);
          *((_QWORD *)a1 + 4) = v66;
        }
        else
        {
          a1 = llvm::raw_ostream::write(a1, "error: invalid contribution to string offsets table in section .", 0x40uLL);
          v66 = (_WORD *)*((_QWORD *)a1 + 4);
        }
        if (a4 <= *((_QWORD *)a1 + 3) - (_QWORD)v66)
        {
          if (a4)
          {
            memcpy(v66, a3, a4);
            v66 = (_WORD *)(*((_QWORD *)a1 + 4) + a4);
            *((_QWORD *)a1 + 4) = v66;
          }
        }
        else
        {
          a1 = llvm::raw_ostream::write(a1, (const char *)a3, a4);
          v66 = (_WORD *)*((_QWORD *)a1 + 4);
        }
        if (*((_QWORD *)a1 + 3) - (_QWORD)v66 <= 1uLL)
        {
          llvm::raw_ostream::write(a1, ".\n", 2uLL);
          goto LABEL_122;
        }
        *v66 = 2606;
        v67 = *((_QWORD *)a1 + 4) + 2;
LABEL_128:
        *((_QWORD *)a1 + 4) = v67;
        if (!v15)
          return;
        goto LABEL_123;
      }
      v38 = v37[1].n128_u8[3];
      if (v37[1].n128_u8[3])
        v39 = 16;
      else
        v39 = 8;
      v76 = v39;
      v40 = v37[1].n128_i16[0];
      v41 = v37->n128_u64[0];
      v42 = -16;
      if (!v37[1].n128_u8[3])
        v42 = -8;
      if (v37[1].n128_u16[0] <= 4u)
        v43 = 0;
      else
        v43 = v42;
      v44 = v43 + v41;
      if (v36 > v43 + v41)
      {
        v45 = std::generic_category();
        v96[0] = 0;
        v96[1] = 0;
        LODWORD(v88) = 0;
        v92 = 0;
        v93 = 0;
        v87 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
        v95 = v96;
        v94 = 0;
        v90 = 0;
        v91 = 0;
        v89 = 0;
        v97 = 0;
        v98[0] = (unint64_t)&off_1E8132A78;
        v98[1] = (unint64_t)"overlapping contributions to string offsets table in section .%s.";
        v98[2] = (unint64_t)a3;
        llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v87, (uint64_t)v98);
        v46 = (unint64_t)v95;
        v47 = operator new();
        v99 = 260;
        v98[0] = v46;
        *(_QWORD *)v47 = off_1E81A0C88;
        llvm::Twine::str((llvm::Twine *)v98, (_QWORD *)(v47 + 8));
        *(_QWORD *)(v47 + 32) = 22;
        *(_QWORD *)(v47 + 40) = v45;
        *(_BYTE *)(v47 + 48) = 1;
        v77 = v47;
        v87 = off_1E81A6E70;
        if (v94 == 1 && v89)
          MEMORY[0x1CAA32F9C](v89, 0x1000C8077774924);
        if (SHIBYTE(v97) < 0)
          operator delete(v96[0]);
        v48 = *(_QWORD *)(a2 + 48);
        if (!v48)
        {
          sub_1C485C2F0();
LABEL_132:
          sub_1C4764EE4();
        }
        (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v48 + 48))(v48, &v77);
        if (v77)
          (*(void (**)(uint64_t))(*(_QWORD *)v77 + 8))(v77);
      }
      if (v78 < v44)
      {
        v87 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E8133270;
        v88 = "0x%8.8llx: Gap, length = ";
        v89 = v78;
        v49 = llvm::raw_ostream::operator<<(a1, (uint64_t)&v87);
        sub_1C5E21910(v49, v44 - v78, 0, 0, 0);
        v50 = (_BYTE *)*((_QWORD *)a1 + 4);
        if (*((_BYTE **)a1 + 3) == v50)
        {
          llvm::raw_ostream::write(a1, "\n", 1uLL);
        }
        else
        {
          *v50 = 10;
          ++*((_QWORD *)a1 + 4);
        }
      }
      v87 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E8133270;
      v88 = "0x%8.8llx: ";
      v89 = v44;
      llvm::raw_ostream::operator<<(a1, (uint64_t)&v87);
      v51 = *((_QWORD *)a1 + 4);
      if ((unint64_t)(*((_QWORD *)a1 + 3) - v51) > 0x13)
      {
        *(_DWORD *)(v51 + 16) = 540876901;
        *(_OWORD *)v51 = *(_OWORD *)"Contribution size = ";
        *((_QWORD *)a1 + 4) += 20;
        v52 = a1;
      }
      else
      {
        v52 = llvm::raw_ostream::write(a1, "Contribution size = ", 0x14uLL);
      }
      sub_1C5E21910(v52, v37->n128_u64[1] + 4 * (v40 > 4u), 0, 0, 0);
      v53 = *((_QWORD *)v52 + 4);
      if ((unint64_t)(*((_QWORD *)v52 + 3) - v53) > 0xA)
      {
        *(_DWORD *)(v53 + 7) = 540876916;
        *(_QWORD *)v53 = *(_QWORD *)", Format = ";
        *((_QWORD *)v52 + 4) += 11;
      }
      else
      {
        v52 = llvm::raw_ostream::write(v52, ", Format = ", 0xBuLL);
      }
      if (v38)
      {
        if (v38 != 1)
        {
          v57 = *((_QWORD *)v52 + 4);
          v55 = v76;
          goto LABEL_85;
        }
        v54 = "DWARF64";
      }
      else
      {
        v54 = "DWARF32";
      }
      v55 = v76;
      v56 = (_DWORD *)*((_QWORD *)v52 + 4);
      if (*((_QWORD *)v52 + 3) - (_QWORD)v56 > 6uLL)
      {
        *v56 = *(_DWORD *)v54;
        *(_DWORD *)((char *)v56 + 3) = *(_DWORD *)(v54 + 3);
        v57 = *((_QWORD *)v52 + 4) + 7;
        *((_QWORD *)v52 + 4) = v57;
      }
      else
      {
        v52 = llvm::raw_ostream::write(v52, v54, 7uLL);
        v57 = *((_QWORD *)v52 + 4);
      }
LABEL_85:
      if ((unint64_t)(*((_QWORD *)v52 + 3) - v57) > 0xB)
      {
        *(_DWORD *)(v57 + 8) = 540876910;
        *(_QWORD *)v57 = *(_QWORD *)", Version = ";
        *((_QWORD *)v52 + 4) += 12;
      }
      else
      {
        v52 = llvm::raw_ostream::write(v52, ", Version = ", 0xCuLL);
      }
      sub_1C5E21910(v52, v40, 0, 0, 0);
      v58 = (_BYTE *)*((_QWORD *)v52 + 4);
      if (*((_BYTE **)v52 + 3) == v58)
      {
        llvm::raw_ostream::write(v52, "\n", 1uLL);
      }
      else
      {
        *v58 = 10;
        ++*((_QWORD *)v52 + 4);
      }
      v36 = v37->n128_u64[0];
      v59 = v37->n128_u64[1];
      v78 = v37->n128_u64[0];
      if (v37[1].n128_u8[3])
        v60 = 8;
      else
        v60 = 4;
      if (v36 - v37->n128_u64[0] < v59)
      {
        do
        {
          v87 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E8133270;
          v88 = "0x%8.8llx: ";
          v89 = v36;
          llvm::raw_ostream::operator<<(a1, (uint64_t)&v87);
          v98[0] = llvm::DWARFDataExtractor::getRelocatedValue((uint64_t)v82, v60, &v78, 0, 0);
          v87 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81698E0;
          v88 = "%0*llx ";
          LODWORD(v89) = v55;
          v90 = v98[0];
          llvm::raw_ostream::operator<<(a1, (uint64_t)&v87);
          CStrRef = llvm::DataExtractor::getCStrRef(v79, v98, 0);
          if (CStrRef)
          {
            v87 = (void (**)(llvm::raw_ostream *__hidden))&off_1E8132A78;
            v88 = "\"%s\"";
            v89 = (unint64_t)CStrRef;
            llvm::raw_ostream::operator<<(a1, (uint64_t)&v87);
          }
          v62 = (_BYTE *)*((_QWORD *)a1 + 4);
          if (*((_BYTE **)a1 + 3) == v62)
          {
            llvm::raw_ostream::write(a1, "\n", 1uLL);
          }
          else
          {
            *v62 = 10;
            ++*((_QWORD *)a1 + 4);
          }
          v36 = v78;
        }
        while (v78 - v37->n128_u64[0] < v37->n128_u64[1]);
      }
      v37 += 2;
      if (v37 == v16)
        goto LABEL_110;
    }
  }
  v36 = 0;
LABEL_110:
  if (v36 >= v69)
  {
LABEL_122:
    if (!v15)
      return;
    goto LABEL_123;
  }
  v87 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E8133270;
  v88 = "0x%8.8llx: Gap, length = ";
  v89 = v36;
  v63 = llvm::raw_ostream::operator<<(a1, (uint64_t)&v87);
  sub_1C5E21910(v63, v69 - v78, 0, 0, 0);
  v64 = (_BYTE *)*((_QWORD *)a1 + 4);
  if (*((_BYTE **)a1 + 3) != v64)
  {
    *v64 = 10;
    v67 = *((_QWORD *)a1 + 4) + 1;
    goto LABEL_128;
  }
  llvm::raw_ostream::write(a1, "\n", 1uLL);
  if (v15)
LABEL_123:
    operator delete(v15);
}

uint64_t llvm::DWARFContext::getGdbIndex(llvm::DWARFContext *this)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  uint64_t v12;
  char v13;
  _QWORD v14[2];
  __int16 v15;

  result = *((_QWORD *)this + 15);
  if (!result)
  {
    v3 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 65) + 368))(*((_QWORD *)this + 65));
    v5 = v4;
    v6 = operator new();
    *(_OWORD *)(v6 + 64) = 0u;
    *(_OWORD *)(v6 + 80) = 0u;
    *(_OWORD *)(v6 + 32) = 0u;
    *(_OWORD *)(v6 + 48) = 0u;
    *(_OWORD *)(v6 + 96) = 0u;
    *(_OWORD *)(v6 + 112) = 0u;
    *(_QWORD *)(v6 + 104) = 0;
    *(_QWORD *)(v6 + 88) = v6 + 104;
    *(_QWORD *)(v6 + 72) = v6 + 88;
    *(_QWORD *)(v6 + 56) = v6 + 72;
    *(_QWORD *)(v6 + 40) = v6 + 56;
    *(_OWORD *)v6 = 0u;
    *(_OWORD *)(v6 + 16) = 0u;
    *(_QWORD *)(v6 + 24) = v6 + 40;
    *(_QWORD *)(v6 + 96) = 0;
    *(_QWORD *)(v6 + 112) = 0;
    v7 = *((_QWORD *)this + 15);
    *((_QWORD *)this + 15) = v6;
    if (v7)
    {
      sub_1C548D628((char **)(v7 + 88));
      v8 = *(void **)(v7 + 72);
      if (v8 != (void *)(v7 + 88))
        free(v8);
      v9 = *(void **)(v7 + 56);
      if (v9 != (void *)(v7 + 72))
        free(v9);
      v10 = *(void **)(v7 + 40);
      if (v10 != (void *)(v7 + 56))
        free(v10);
      v11 = *(void **)(v7 + 24);
      if (v11 != (void *)(v7 + 40))
        free(v11);
      MEMORY[0x1CAA32FC0](v7, 0x10D0C40CB60C578);
      v12 = *((_QWORD *)this + 15);
    }
    else
    {
      v12 = v6;
    }
    *(_BYTE *)(v12 + 124) = v5 != 0;
    if (v5)
    {
      v14[0] = v3;
      v14[1] = v5;
      v15 = 1;
      v13 = llvm::DWARFGdbIndex::parseImpl(v12, v14) ^ 1;
      result = *((_QWORD *)this + 15);
    }
    else
    {
      v13 = 0;
      result = v12;
    }
    *(_BYTE *)(v12 + 125) = v13;
  }
  return result;
}

uint64_t (***llvm::DWARFContext::getAppleNames(llvm::DWARFContext *this))()
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;

  v2 = (uint64_t *)((char *)this + 208);
  v3 = *((_QWORD *)this + 65);
  v4 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 320))(v3);
  v5 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 65) + 136))(*((_QWORD *)this + 65));
  v7 = v6;
  v8 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 65) + 40))(*((_QWORD *)this + 65));
  return sub_1C5487284(v2, v3, v4, v5, v7, v8);
}

uint64_t (***llvm::DWARFContext::getAppleTypes(llvm::DWARFContext *this))()
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;

  v2 = (uint64_t *)((char *)this + 216);
  v3 = *((_QWORD *)this + 65);
  v4 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 328))(v3);
  v5 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 65) + 136))(*((_QWORD *)this + 65));
  v7 = v6;
  v8 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 65) + 40))(*((_QWORD *)this + 65));
  return sub_1C5487284(v2, v3, v4, v5, v7, v8);
}

uint64_t (***llvm::DWARFContext::getAppleNamespaces(llvm::DWARFContext *this))()
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;

  v2 = (uint64_t *)((char *)this + 224);
  v3 = *((_QWORD *)this + 65);
  v4 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 336))(v3);
  v5 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 65) + 136))(*((_QWORD *)this + 65));
  v7 = v6;
  v8 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 65) + 40))(*((_QWORD *)this + 65));
  return sub_1C5487284(v2, v3, v4, v5, v7, v8);
}

uint64_t (***llvm::DWARFContext::getAppleObjC(llvm::DWARFContext *this))()
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;

  v2 = (uint64_t *)((char *)this + 232);
  v3 = *((_QWORD *)this + 65);
  v4 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 352))(v3);
  v5 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 65) + 136))(*((_QWORD *)this + 65));
  v7 = v6;
  v8 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 65) + 40))(*((_QWORD *)this + 65));
  return sub_1C5487284(v2, v3, v4, v5, v7, v8);
}

uint64_t llvm::DWARFContext::getDebugNames(llvm::DWARFContext *this)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t (**v12)();
  uint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;

  v2 = *((_QWORD *)this + 65);
  v3 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 344))(v2);
  v4 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 65) + 136))(*((_QWORD *)this + 65));
  v6 = v5;
  v7 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 65) + 40))(*((_QWORD *)this + 65));
  result = *((_QWORD *)this + 25);
  if (!result)
  {
    v9 = *v3;
    v10 = v3[1];
    v11 = operator new();
    *(_QWORD *)(v11 + 16) = v10;
    *(_BYTE *)(v11 + 24) = v7;
    *(_BYTE *)(v11 + 25) = 0;
    *(_QWORD *)(v11 + 32) = v2;
    *(_QWORD *)(v11 + 40) = v3;
    *(_QWORD *)(v11 + 48) = v4;
    *(_QWORD *)(v11 + 56) = v6;
    *(_BYTE *)(v11 + 64) = v7;
    *(_BYTE *)(v11 + 65) = 0;
    v12 = &off_1E8169740;
    *(_QWORD *)v11 = &off_1E8169740;
    *(_QWORD *)(v11 + 8) = v9;
    *(_QWORD *)(v11 + 88) = 0;
    *(_QWORD *)(v11 + 72) = v11 + 88;
    *(_QWORD *)(v11 + 80) = 0;
    *(_QWORD *)(v11 + 96) = 0;
    *(_DWORD *)(v11 + 104) = 0;
    v13 = *((_QWORD *)this + 25);
    *((_QWORD *)this + 25) = v11;
    if (v13)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
      v12 = (uint64_t (**)())**((_QWORD **)this + 25);
    }
    ((void (*)(char **__return_ptr))v12[2])(&v15);
    v14 = v15;
    if (v15)
    {
      v15 = 0;
      v16 = v14;
      sub_1C4D62BD4(&v16, &v17);
      if (v16)
        (*(void (**)(char *))(*(_QWORD *)v16 + 8))(v16);
      if (v15)
        (*(void (**)(char *))(*(_QWORD *)v15 + 8))(v15);
    }
    return *((_QWORD *)this + 25);
  }
  return result;
}

const llvm::DWARFUnitIndex::Entry *llvm::DWARFContext::getTypeUnitForHash(llvm::DWARFContext *this, unsigned __int16 a2, uint64_t a3, int a4)
{
  llvm::DWARFUnitIndex *TUIndex;
  uint64_t v8;
  char *v9;
  int v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  int v17;
  BOOL v18;
  unsigned int v19;
  _QWORD *v20;
  const llvm::DWARFUnitIndex::Entry *result;
  char *v22;
  char *v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  BOOL v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  int v32;
  unsigned int v33;
  _QWORD *v34;
  uint64_t v35;
  _QWORD *v36;
  int v37;
  BOOL v38;
  unsigned int v39;
  _QWORD *v40;
  uint64_t v41;
  uint64_t v42;

  v42 = a3;
  llvm::DWARFContext::parseDWOUnits((uint64_t)this, 1);
  TUIndex = (llvm::DWARFUnitIndex *)llvm::DWARFContext::getTUIndex(this);
  if (!*((_DWORD *)TUIndex + 3))
  {
    if (a4)
      v8 = 304;
    else
      v8 = 80;
    if (a4)
      v9 = (char *)this + 304;
    else
      v9 = (char *)this + 80;
    if (!v9[24])
    {
      *(_QWORD *)v9 = 0;
      *((_QWORD *)v9 + 1) = 0;
      *((_DWORD *)v9 + 4) = 0;
      v9[24] = 1;
      if (a4)
      {
        llvm::DWARFContext::parseDWOUnits((uint64_t)this, 0);
        v22 = (char *)this + 240;
        v23 = (char *)this + 248;
      }
      else
      {
        llvm::DWARFContext::parseNormalUnits((uint64_t)this);
        v22 = (char *)this + 16;
        v23 = (char *)this + 24;
      }
      v24 = *(unsigned int *)v23;
      if ((_DWORD)v24)
      {
        v25 = *(uint64_t **)v22;
        v26 = *(_QWORD *)v22 + 8 * v24;
        while (1)
        {
          v27 = *v25;
          if (*v25)
            v28 = (*(_BYTE *)(*v25 + 96) & 0xFB) == 2;
          else
            v28 = 0;
          if (!v28)
            goto LABEL_53;
          v29 = *(_QWORD *)(v27 + 64);
          v41 = v29;
          v30 = *((_DWORD *)v9 + 4);
          if (!v30)
            break;
          v31 = *(_QWORD *)((char *)this + v8);
          v32 = v30 - 1;
          v33 = v32 & (37 * v29);
          v34 = (_QWORD *)(v31 + 16 * v33);
          v35 = *v34;
          if (v29 != *v34)
          {
            v36 = 0;
            v37 = 1;
            while (v35 != -1)
            {
              if (v36)
                v38 = 0;
              else
                v38 = v35 == -2;
              if (v38)
                v36 = v34;
              v39 = v33 + v37++;
              v33 = v39 & v32;
              v34 = (_QWORD *)(v31 + 16 * v33);
              v35 = *v34;
              if (v29 == *v34)
                goto LABEL_52;
            }
            if (v36)
              v40 = v36;
            else
              v40 = v34;
            goto LABEL_51;
          }
LABEL_52:
          v34[1] = v27;
LABEL_53:
          if (++v25 == (uint64_t *)v26)
            goto LABEL_9;
        }
        v40 = 0;
LABEL_51:
        v34 = sub_1C548D6F8((uint64_t)v9, &v41, v40);
        *v34 = v29;
        v34[1] = 0;
        goto LABEL_52;
      }
    }
LABEL_9:
    v10 = *((_DWORD *)v9 + 4);
    if (v10)
    {
      v11 = *(_QWORD *)((char *)this + v8);
      v12 = v10 - 1;
      v13 = v12 & (37 * a3);
      v14 = (_QWORD *)(v11 + 16 * v13);
      v15 = *v14;
      if (*v14 == a3)
        return (const llvm::DWARFUnitIndex::Entry *)v14[1];
      v16 = 0;
      v17 = 1;
      while (v15 != -1)
      {
        if (v16)
          v18 = 0;
        else
          v18 = v15 == -2;
        if (v18)
          v16 = v14;
        v19 = v13 + v17++;
        v13 = v19 & v12;
        v14 = (_QWORD *)(v11 + 16 * v13);
        v15 = *v14;
        if (*v14 == a3)
          return (const llvm::DWARFUnitIndex::Entry *)v14[1];
      }
      if (v16)
        v20 = v16;
      else
        v20 = v14;
    }
    else
    {
      v20 = 0;
    }
    v14 = sub_1C548D6F8((uint64_t)v9, &v42, v20);
    *v14 = a3;
    v14[1] = 0;
    return (const llvm::DWARFUnitIndex::Entry *)v14[1];
  }
  result = (const llvm::DWARFUnitIndex::Entry *)llvm::DWARFUnitIndex::getFromHash(TUIndex, a3);
  if (result)
  {
    result = (const llvm::DWARFUnitIndex::Entry *)llvm::DWARFUnitVector::getUnitForIndexEntry((llvm::DWARFContext *)((char *)this + 240), result);
    if (result)
    {
      if ((*((_BYTE *)result + 96) & 0xFB) != 2)
        return 0;
    }
  }
  return result;
}

llvm::DWARFUnit *llvm::DWARFContext::getDWOCompileUnitForHash(llvm::DWARFContext *this, uint64_t a2)
{
  llvm::DWARFUnitIndex *CUIndex;
  llvm::DWARFUnit **v5;
  llvm::DWARFUnit **v6;
  llvm::DWARFUnit **v7;
  unsigned int (*v8)(llvm::DWARFUnit **);
  llvm::DWARFUnit *v9;
  llvm::DWARFUnit *v10;
  llvm::DWARFUnit *v11;
  llvm::DWARFUnit *v12;
  BOOL v13;
  llvm::DWARFUnit *v14;
  unint64_t AsUnsignedConstant;
  char v16;
  int v17;
  BOOL v18;
  llvm::DWARFUnit *result;
  llvm::DWARFUnit *v20[2];
  _BYTE v21[56];
  _QWORD v22[3];
  llvm::DWARFUnit **v23;

  llvm::DWARFContext::parseDWOUnits((uint64_t)this, 1);
  CUIndex = (llvm::DWARFUnitIndex *)llvm::DWARFContext::getCUIndex(this);
  if (*((_DWORD *)CUIndex + 3))
  {
    result = (llvm::DWARFUnit *)llvm::DWARFUnitIndex::getFromHash(CUIndex, a2);
    if (result)
    {
      result = (llvm::DWARFUnit *)llvm::DWARFUnitVector::getUnitForIndexEntry((llvm::DWARFContext *)((char *)this + 240), result);
      if (result)
      {
        if ((*((_BYTE *)result + 96) & 0xFB) == 2)
          return 0;
      }
    }
  }
  else
  {
    sub_1C5487034(v22, this);
    v5 = (llvm::DWARFUnit **)v22[0];
    v6 = v23;
    if ((llvm::DWARFUnit **)v22[0] == v23)
    {
      return 0;
    }
    else
    {
      v7 = (llvm::DWARFUnit **)v22[1];
      v8 = (unsigned int (*)(llvm::DWARFUnit **))v22[2];
      while (1)
      {
        v9 = *v5;
        llvm::DWARFUnit::extractDIEsIfNeeded(*v5, 1);
        v10 = *v5;
        if (*((_BYTE *)v9 + 88))
          break;
        llvm::DWARFUnit::extractDIEsIfNeeded(*v5, 1);
        v11 = (llvm::DWARFUnit *)*((_QWORD *)v10 + 36);
        v12 = (llvm::DWARFUnit *)*((_QWORD *)v10 + 37);
        v13 = v11 == v12;
        if (v11 == v12)
          v14 = 0;
        else
          v14 = v10;
        if (v13)
          v11 = 0;
        v20[0] = v14;
        v20[1] = v11;
        llvm::DWARFDie::find(v20, 8497, v21);
        if (v21[48])
        {
          AsUnsignedConstant = llvm::DWARFFormValue::getAsUnsignedConstant((llvm::DWARFFormValue *)v21);
          if (v16)
          {
            v10 = *v5;
            v17 = *((unsigned __int8 *)*v5 + 88);
            *((_QWORD *)*v5 + 10) = AsUnsignedConstant;
            if (v17)
              v10 = *v5;
            else
              *((_BYTE *)v10 + 88) = 1;
            break;
          }
        }
LABEL_19:
        while (++v5 != v7)
        {
          if (v8(v5))
            goto LABEL_23;
        }
        v5 = v7;
LABEL_23:
        if (v5 == v6)
          return 0;
      }
      llvm::DWARFUnit::extractDIEsIfNeeded(v10, 1);
      if (*((_BYTE *)v10 + 88))
        v18 = *((_QWORD *)v10 + 10) == a2;
      else
        v18 = 0;
      if (!v18)
        goto LABEL_19;
      if ((*((_BYTE *)*v5 + 96) & 0xFB) == 2)
        return 0;
      else
        return *v5;
    }
  }
  return result;
}

uint64_t sub_1C5487034(_QWORD *a1, llvm::DWARFContext *this)
{
  uint64_t result;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;

  result = llvm::DWARFContext::parseDWOUnits((uint64_t)this, 0);
  v5 = *((_QWORD *)this + 30);
  v6 = *((_DWORD *)this + 74);
  if (v6 == -1)
    v6 = *((_DWORD *)this + 62);
  v7 = v5 + 8 * v6;
  if (v6)
  {
    v8 = 8 * v6;
    while ((*(_BYTE *)(*(_QWORD *)v5 + 96) & 0xFB) == 2)
    {
      v5 += 8;
      v8 -= 8;
      if (!v8)
      {
        v5 = v7;
        break;
      }
    }
  }
  *a1 = v5;
  a1[1] = v7;
  a1[2] = sub_1C548D3BC;
  a1[3] = v7;
  a1[4] = v7;
  a1[5] = sub_1C548D3BC;
  return result;
}

llvm::DWARFUnit *llvm::DWARFContext::getDIEForOffset(uint64_t **this, unint64_t a2)
{
  llvm::DWARFUnit *result;

  llvm::DWARFContext::parseNormalUnits((uint64_t)this);
  result = (llvm::DWARFUnit *)llvm::DWARFUnitVector::getUnitForOffset(this + 2, a2);
  if (result)
    return sub_1C624DB94(result, a2);
  return result;
}

uint64_t llvm::DWARFContext::verify(uint64_t a1, uint64_t a2, __int128 *a3)
{
  int v6;
  int v7;
  _BOOL4 v8;
  __int128 v10[5];
  llvm::raw_ostream *v11[2];
  _QWORD v12[13];

  v12[12] = *MEMORY[0x1E0C80C00];
  sub_1C624C4A4((uint64_t)v10, a3);
  llvm::DWARFVerifier::DWARFVerifier((uint64_t)v11, a2, a1, v10);
  sub_1C624C568(v10);
  v6 = llvm::DWARFVerifier::handleDebugAbbrev(v11);
  v7 = *(_DWORD *)a3;
  if ((*(_DWORD *)a3 & 8) != 0)
  {
    v6 &= llvm::DWARFVerifier::handleDebugInfo((llvm::DWARFVerifier *)v11);
    v7 = *(_DWORD *)a3;
  }
  if ((v7 & 0x20) != 0)
    v6 &= llvm::DWARFVerifier::handleDebugLine((llvm::DWARFVerifier *)v11);
  v8 = llvm::DWARFVerifier::handleAccelTables((llvm::DWARFVerifier *)v11);
  sub_1C624C568(v12);
  return v6 & v8;
}

uint64_t llvm::DWARFContext::getDebugAranges(llvm::DWARFContext *this)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;

  result = *((_QWORD *)this + 19);
  if (!result)
  {
    v3 = operator new();
    *(_OWORD *)v3 = 0u;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_OWORD *)(v3 + 48) = 0u;
    *(_QWORD *)(v3 + 64) = 0;
    v4 = *((_QWORD *)this + 19);
    *((_QWORD *)this + 19) = v3;
    if (v4)
    {
      MEMORY[0x1CAA32FB4](*(_QWORD *)(v4 + 48), 8);
      v5 = *(void **)(v4 + 24);
      if (v5)
      {
        *(_QWORD *)(v4 + 32) = v5;
        operator delete(v5);
      }
      v6 = *(void **)v4;
      if (*(_QWORD *)v4)
      {
        *(_QWORD *)(v4 + 8) = v6;
        operator delete(v6);
      }
      MEMORY[0x1CAA32FC0](v4, 0x1020C4088D124F6);
      v3 = *((_QWORD *)this + 19);
    }
    llvm::DWARFDebugAranges::generate((llvm::DWARFDebugAranges *)v3, this);
    return *((_QWORD *)this + 19);
  }
  return result;
}

uint64_t (***sub_1C5487284(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, char a6))()
{
  uint64_t (***result)();
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t (**v16)();
  uint64_t (***v17)();
  char *v18;
  char *v19;
  char *v20;
  char *v21;

  result = (uint64_t (***)())*a1;
  if (!result)
  {
    v13 = *a3;
    v14 = a3[1];
    v15 = operator new();
    *(_QWORD *)(v15 + 16) = v14;
    *(_BYTE *)(v15 + 24) = a6;
    *(_BYTE *)(v15 + 25) = 0;
    *(_QWORD *)(v15 + 32) = a2;
    *(_QWORD *)(v15 + 40) = a3;
    *(_QWORD *)(v15 + 48) = a4;
    *(_QWORD *)(v15 + 56) = a5;
    *(_BYTE *)(v15 + 64) = a6;
    *(_BYTE *)(v15 + 65) = 0;
    v16 = &off_1E8169710;
    *(_QWORD *)v15 = &off_1E8169710;
    *(_QWORD *)(v15 + 8) = v13;
    *(_QWORD *)(v15 + 104) = v15 + 120;
    *(_QWORD *)(v15 + 112) = 0x300000000;
    *(_BYTE *)(v15 + 136) = 0;
    v17 = (uint64_t (***)())*a1;
    *a1 = v15;
    if (v17)
    {
      ((void (*)(uint64_t (***)()))(*v17)[1])(v17);
      v16 = *(uint64_t (***)())*a1;
    }
    ((void (*)(char **__return_ptr))v16[2])(&v19);
    v18 = v19;
    if (v19)
    {
      v19 = 0;
      v20 = v18;
      sub_1C4D62BD4(&v20, &v21);
      if (v20)
        (*(void (**)(char *))(*(_QWORD *)v20 + 8))(v20);
      if (v19)
        (*(void (**)(char *))(*(_QWORD *)v19 + 8))(v19);
    }
    return (uint64_t (***)())*a1;
  }
  return result;
}

uint64_t llvm::DWARFContext::getCompileUnitForOffset(uint64_t **this, unint64_t a2)
{
  uint64_t result;

  llvm::DWARFContext::parseNormalUnits((uint64_t)this);
  result = llvm::DWARFUnitVector::getUnitForOffset(this + 2, a2);
  if (result)
  {
    if ((*(_BYTE *)(result + 96) & 0xFB) == 2)
      return 0;
  }
  return result;
}

uint64_t llvm::DWARFContext::getCompileUnitForAddress(uint64_t **this, unint64_t a2)
{
  llvm::DWARFDebugAranges *DebugAranges;
  unint64_t Address;
  uint64_t result;

  DebugAranges = (llvm::DWARFDebugAranges *)llvm::DWARFContext::getDebugAranges((llvm::DWARFContext *)this);
  Address = llvm::DWARFDebugAranges::findAddress(DebugAranges, a2);
  llvm::DWARFContext::parseNormalUnits((uint64_t)this);
  result = llvm::DWARFUnitVector::getUnitForOffset(this + 2, Address);
  if (result)
  {
    if ((*(_BYTE *)(result + 96) & 0xFB) == 2)
      return 0;
  }
  return result;
}

void llvm::DWARFContext::getDIEsForAddress(uint64_t **this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t i;
  llvm::DWARFUnit *CompileUnitForAddress;
  uint64_t v6;
  _OWORD *v7;
  uint64_t *v8;
  char *v9;
  __int128 v10;
  __int128 v11;
  BOOL v12;
  uint64_t v13;
  uint64_t FirstChild;
  uint64_t v15;
  uint64_t v16;
  uint64_t LastChild;
  uint64_t v18;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  unint64_t v38;
  unint64_t v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v46;
  int64_t v47;
  char *v48;
  char *v49;
  __int128 v50;
  uint64_t v51;
  uint64_t v52;
  unsigned int v53;
  uint64_t v54;
  uint64_t *v55;
  uint64_t *v56;
  uint64_t v57;
  uint64_t v58;
  unsigned int v59;
  size_t v60;
  uint64_t v61;
  uint64_t v62;
  _OWORD *v63;
  unint64_t v64;
  char *v65;
  char *__p;
  __int128 v67;
  uint64_t v68;
  uint64_t v69;

  i = a2;
  *(_QWORD *)(a3 + 32) = 0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  CompileUnitForAddress = (llvm::DWARFUnit *)llvm::DWARFContext::getCompileUnitForAddress(this, a2);
  if (!CompileUnitForAddress)
    return;
  v63 = (_OWORD *)(a3 + 24);
  *(_QWORD *)a3 = CompileUnitForAddress;
  *(_QWORD *)(a3 + 8) = llvm::DWARFUnit::getSubroutineForAddress(CompileUnitForAddress, i);
  *(_QWORD *)(a3 + 16) = v6;
  v7 = operator new(0x10uLL);
  *v7 = *(_OWORD *)(a3 + 8);
  v8 = (uint64_t *)v7;
  v65 = (char *)(v7 + 1);
  v9 = (char *)(v7 + 1);
  while (1)
  {
    v10 = *((_OWORD *)v9 - 1);
    v9 -= 16;
    v67 = v10;
    v11 = v10;
    if ((_QWORD)v10)
      v12 = *((_QWORD *)&v10 + 1) == 0;
    else
      v12 = 1;
    if (v12)
      goto LABEL_81;
    v13 = *(_QWORD *)(*((_QWORD *)&v10 + 1) + 16);
    if (v13)
    {
      if (*(_WORD *)(v13 + 4) == 11
        && llvm::DWARFDie::addressRangeContainsAddress((llvm::DWARFDie *)&v67, i))
      {
        break;
      }
    }
    FirstChild = llvm::DWARFUnit::getFirstChild(v11, *((uint64_t *)&v11 + 1));
    v16 = v15;
    LastChild = llvm::DWARFUnit::getLastChild(v11, *((uint64_t *)&v11 + 1));
    if (v16 == v18 && FirstChild == LastChild)
      goto LABEL_64;
    v20 = LastChild;
    v21 = v18;
    v64 = i;
    v22 = 0;
    v23 = 0;
    v24 = v16;
    v25 = FirstChild;
    do
    {
      v26 = v25;
      v25 = 0;
      if (v24)
      {
        v27 = v24;
        v24 = 0;
        if (v26)
        {
          v28 = *(_DWORD *)(v27 + 12);
          if (v28)
          {
            v24 = *(_QWORD *)(v26 + 288) + 24 * v28;
            v25 = v26;
          }
          else
          {
            v25 = 0;
            v24 = 0;
          }
        }
      }
      else
      {
        v24 = 0;
      }
      --v23;
      v22 += 16;
    }
    while (v24 != v18 || v25 != LastChild);
    v29 = (char *)v7;
    v30 = v9 - (char *)v7;
    v31 = v30 >> 4;
    __p = v29;
    v32 = (uint64_t *)&v29[v30 & 0xFFFFFFFFFFFFFFF0];
    v33 = ~v23;
    if (~v23 >= (v65 - v9) >> 4)
    {
      v38 = v31 - v23;
      if (v38 >> 60)
        abort();
      if ((v65 - v29) >> 3 > v38)
        v38 = (v65 - v29) >> 3;
      if ((unint64_t)(v65 - v29) >= 0x7FFFFFFFFFFFFFF0)
        v39 = 0xFFFFFFFFFFFFFFFLL;
      else
        v39 = v38;
      if (v39)
      {
        if (v39 >> 60)
          sub_1C4764EE4();
        v40 = (char *)operator new(16 * v39);
        v31 = v30 >> 4;
      }
      else
      {
        v40 = 0;
      }
      v8 = (uint64_t *)&v40[16 * v31];
      v54 = 16 * v31;
      v55 = &v8[v22 / 8];
      v56 = v8;
      do
      {
        v57 = 0;
        *v56 = FirstChild;
        v56[1] = v16;
        v58 = 0;
        if (FirstChild && v16)
        {
          v59 = *(_DWORD *)(v16 + 12);
          if (v59)
          {
            v58 = *(_QWORD *)(FirstChild + 288) + 24 * v59;
            v57 = FirstChild;
          }
          else
          {
            v57 = 0;
            v58 = 0;
          }
        }
        v56 += 2;
        v16 = v58;
        FirstChild = v57;
      }
      while (v55 != v56);
      if ((unint64_t)v30 >= 0x10)
      {
        do
        {
          *(_OWORD *)&v40[v54 - 16] = *(_OWORD *)&__p[v54 - 16];
          v54 -= 16;
        }
        while (v54);
        v8 = (uint64_t *)v40;
      }
      v60 = v9 - (char *)v32;
      if (v60)
      {
        v61 = v31;
        memmove(v55, v32, v60);
        v31 = v61;
      }
      v65 = &v40[16 * v39];
      v9 = &v40[16 * v31 + (v60 & 0xFFFFFFFFFFFFFFF0) + v22];
      if (__p)
        operator delete(__p);
      v7 = v8;
      i = v64;
      goto LABEL_81;
    }
    v62 = v30 >> 4;
    v68 = FirstChild;
    v69 = v16;
    sub_1C548D980(&v68, -v23);
    v34 = v68;
    v35 = v69;
    v36 = (v9 - (char *)v32) >> 4;
    if (v36 > v33)
    {
      v37 = v9;
LABEL_47:
      v47 = &v37[-16 * v62] - __p - v22;
      v48 = (char *)v32 + v47;
      v49 = v37;
      while (v48 < v9)
      {
        v50 = *(_OWORD *)v48;
        v48 += 16;
        *(_OWORD *)v49 = v50;
        v49 += 16;
      }
      if (&__p[16 * v62 + v22] != v37)
        memmove(&v37[-16 * (v47 >> 4)], v32, v47);
      for (i = v64; v16 != v35 || FirstChild != v34; v32 += 2)
      {
        v51 = FirstChild;
        *v32 = FirstChild;
        v32[1] = v16;
        FirstChild = 0;
        if (v16)
        {
          v52 = v16;
          v16 = 0;
          if (v51)
          {
            v53 = *(_DWORD *)(v52 + 12);
            if (v53)
            {
              v16 = *(_QWORD *)(v51 + 288) + 24 * v53;
              FirstChild = v51;
            }
            else
            {
              FirstChild = 0;
              v16 = 0;
            }
          }
        }
        else
        {
          v16 = 0;
        }
      }
      v37 = v49;
      goto LABEL_63;
    }
    v68 = FirstChild;
    v69 = v16;
    sub_1C548D980(&v68, v36);
    v34 = v68;
    v35 = v69;
    if (v69 != v21 || (v37 = v9, v68 != v20))
    {
      v37 = v9;
      v41 = v69;
      v42 = v68;
      v43 = v9;
      do
      {
        v44 = v42;
        *v43 = v42;
        v43[1] = v41;
        v42 = 0;
        if (v41)
        {
          v45 = v41;
          v41 = 0;
          if (v44)
          {
            v46 = *(_DWORD *)(v45 + 12);
            if (v46)
            {
              v41 = *(_QWORD *)(v44 + 288) + 24 * v46;
              v42 = v44;
            }
            else
            {
              v42 = 0;
              v41 = 0;
            }
          }
        }
        else
        {
          v41 = 0;
        }
        v37 += 16;
        v43 += 2;
      }
      while (v41 != v21 || v42 != v20);
    }
    if (v9 - (char *)v32 >= 1)
      goto LABEL_47;
    i = v64;
LABEL_63:
    v9 = v37;
    v7 = __p;
LABEL_64:
    v8 = (uint64_t *)v7;
LABEL_81:
    if (v8 == (uint64_t *)v9)
      goto LABEL_85;
  }
  *v63 = v67;
  v9 = (char *)v7;
LABEL_85:
  if (v9)
    operator delete(v9);
}

void llvm::DWARFContext::addLocalsForDie(uint64_t a1, llvm::DWARFContext **a2, llvm::DWARFUnit *a3, uint64_t a4, llvm::DWARFUnit *a5, uint64_t a6, void **a7)
{
  uint64_t v9;
  int v10;
  char *SubroutineName;
  _BOOL4 v13;
  int v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  unsigned __int8 *v18;
  int v19;
  _BOOL4 v20;
  uint64_t v22;
  unsigned int v23;
  int v24;
  uint64_t v25;
  int v26;
  unsigned __int8 v27;
  uint64_t v28;
  BOOL v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  llvm::DWARFUnit *AttributeValueAsReferencedDie;
  uint64_t v36;
  llvm::DWARFUnit *LastChild;
  uint64_t v38;
  void **v39;
  uint64_t v40;
  uint64_t FirstChild;
  llvm::DWARFUnit *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  llvm::DWARFUnit *v51;
  uint64_t v52;
  char *v53;
  char v54;
  llvm::DWARFUnit *v55;
  llvm::DWARFUnit *v56;
  llvm::DWARFUnit *v57;
  llvm::DWARFUnit *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t AsUnsignedConstant;
  char *CompilationDir;
  uint64_t v65;
  size_t v66;
  char *v67;
  char *v68;
  __int128 v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unint64_t v73;
  _BYTE *v74;
  _BYTE *v75;
  __int128 v76;
  _BYTE *v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  char *v82;
  void **v83;
  _BYTE *v84;
  _BYTE *v85;
  char *v86;
  char *v87;
  __int128 v88;
  void **v89;
  void **v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  void **v97;
  unsigned int v98;
  _OWORD v100[3];
  char v101;
  void *v102[2];
  void *v103[4];
  void *__p[2];
  _BYTE v105[24];
  __int128 v106;
  __int128 v107;
  uint64_t v108;
  llvm::DWARFUnit *v109;
  uint64_t v110;
  llvm::DWARFUnit *v111;
  uint64_t v112;
  char *v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  char v117;
  uint64_t v118;

  v118 = *MEMORY[0x1E0C80C00];
  v111 = a3;
  v112 = a4;
  v109 = a5;
  v110 = a6;
  v9 = *(_QWORD *)(a6 + 16);
  if (!v9)
    goto LABEL_56;
  v10 = *(unsigned __int16 *)(v9 + 4);
  if (v10 == 29)
  {
    AttributeValueAsReferencedDie = llvm::DWARFDie::getAttributeValueAsReferencedDie(&v109, 49);
    if (AttributeValueAsReferencedDie && v36)
    {
      v111 = AttributeValueAsReferencedDie;
      v112 = v36;
    }
    goto LABEL_56;
  }
  if (v10 != 52 && v10 != 5)
  {
LABEL_56:
    LastChild = v109;
    if (v109)
    {
      v38 = v110;
      v39 = a7;
      if (v110)
      {
        FirstChild = llvm::DWARFUnit::getFirstChild((uint64_t)v109, v110);
        v40 = v47;
        LastChild = (llvm::DWARFUnit *)llvm::DWARFUnit::getLastChild((uint64_t)LastChild, v38);
        v38 = v48;
      }
      else
      {
        v40 = 0;
        FirstChild = 0;
        LastChild = 0;
      }
    }
    else
    {
      v39 = a7;
      v40 = 0;
      FirstChild = 0;
      v38 = 0;
    }
    if (v40 != v38 || (llvm::DWARFUnit *)FirstChild != LastChild)
    {
      v42 = v111;
      v43 = v112;
      do
      {
        v44 = FirstChild;
        llvm::DWARFContext::addLocalsForDie(a1, a2, v42, v43, FirstChild, v40, v39);
        FirstChild = 0;
        v45 = 0;
        if (v40 && v44)
        {
          v46 = *(_DWORD *)(v40 + 12);
          if (v46)
          {
            v45 = *(_QWORD *)(v44 + 288) + 24 * v46;
            FirstChild = v44;
          }
          else
          {
            FirstChild = 0;
            v45 = 0;
          }
        }
        v40 = v45;
      }
      while (v38 != v45 || LastChild != (llvm::DWARFUnit *)FirstChild);
    }
    return;
  }
  LOBYTE(v106) = 0;
  BYTE8(v106) = 0;
  LOBYTE(v107) = 0;
  BYTE8(v107) = 0;
  LOBYTE(v108) = 0;
  *(_OWORD *)v102 = 0u;
  memset(v103, 0, sizeof(v103));
  *(_OWORD *)__p = 0u;
  memset(v105, 0, 17);
  SubroutineName = llvm::DWARFDie::getSubroutineName((llvm::DWARFDie *)&v111, 1);
  if (SubroutineName)
    MEMORY[0x1CAA32ABC](v102, SubroutineName);
  llvm::DWARFDie::find(&v111, 64, &v114);
  if (v117
    && (unsigned __int16)v114 <= 0x2Du
    && (((0x618uLL >> v114) & 1) != 0 || (unsigned __int16)v114 == 30 || (unsigned __int16)v114 == 24)
    && *((_QWORD *)&v114 + 1))
  {
    v98 = *(unsigned __int8 *)v115 - 80;
    v13 = v98 <= 0x1F;
    if (v98 <= 0x1F)
      v14 = *(unsigned __int8 *)v115 - 80;
    else
      v14 = 0;
  }
  else
  {
    v13 = 0;
    v14 = 0;
  }
  llvm::DWARFDie::getLocations(&v109, (llvm::dwarf *)2, (uint64_t)&v114);
  v15 = BYTE8(v115);
  v16 = v114;
  if ((BYTE8(v115) & 1) != 0)
  {
    v113 = (char *)v114;
    *(_QWORD *)&v114 = 0;
    sub_1C4D62BD4(&v113, (char **)v100);
    if (v113)
      (*(void (**)(char *))(*(_QWORD *)v113 + 8))(v113);
    v15 = BYTE8(v115);
  }
  else if ((_QWORD)v114 != *((_QWORD *)&v114 + 1))
  {
    while (1)
    {
      v17 = *(_QWORD *)(v16 + 40);
      if (v17)
      {
        v18 = *(unsigned __int8 **)(v16 + 32);
        v19 = *v18;
        v20 = v14 + 112 == v19 && v13;
        if (v19 == 145 || v20)
        {
          v22 = 0;
          v23 = 0;
          v24 = (_DWORD)v18 + v17;
          v25 = 1;
          v26 = (_DWORD)v18 + 1;
          while (v17 != v25)
          {
            v27 = v18[v25];
            v28 = v27 & 0x7F;
            if (v23 >= 0x40)
            {
              if (((v22 >> 63) & 0x7F) != v28)
              {
                v34 = 0;
LABEL_46:
                v24 = (_DWORD)v18 + v25;
                goto LABEL_47;
              }
            }
            else if (v23 == 63 && (_DWORD)v28 != 127 && (_DWORD)v28 != 0)
            {
              v34 = 0;
              v24 = v26;
              goto LABEL_47;
            }
            v22 |= v28 << v23;
            v23 += 7;
            ++v26;
            ++v25;
            if ((v27 & 0x80) == 0)
            {
              v30 = (v27 & 0x40) == 0 || v23 > 0x3F;
              v31 = -1 << v23;
              if (v30)
                v31 = 0;
              v34 = v22 | v31;
              goto LABEL_46;
            }
          }
          v34 = 0;
LABEL_47:
          v32 = v24 - ((_DWORD)v18 + 1);
          v33 = (v32 + 1);
          if (v17 == v33 || v17 == v32 + 2 && v18[v33] == 6)
            break;
        }
      }
      v16 += 64;
      if (v16 == *((_QWORD *)&v114 + 1))
        goto LABEL_75;
    }
    *(_QWORD *)&v105[16] = v34;
    if (!(_BYTE)v106)
      LOBYTE(v106) = 1;
  }
LABEL_75:
  if ((v15 & 1) != 0)
  {
    v49 = v114;
    *(_QWORD *)&v114 = 0;
    if (v49)
      (*(void (**)(uint64_t))(*(_QWORD *)v49 + 8))(v49);
  }
  else
  {
    *(_QWORD *)&v100[0] = &v114;
    sub_1C548DA28((void ***)v100);
  }
  llvm::DWARFDie::find(&v109, 15875, &v114);
  if (v117)
  {
    *((_QWORD *)&v107 + 1) = llvm::DWARFFormValue::getAsUnsignedConstant((llvm::DWARFFormValue *)&v114);
    v108 = v50;
  }
  v51 = llvm::DWARFDie::getAttributeValueAsReferencedDie(&v109, 49);
  if (v51 && v52)
  {
    v109 = v51;
    v110 = v52;
  }
  llvm::DWARFDie::find(&v109, 3, &v114);
  if (v117)
  {
    v100[0] = v114;
    v100[1] = v115;
    v100[2] = v116;
    v101 = 1;
    v53 = sub_1C624DEB4((llvm::DWARFFormValue *)v100);
    if (v54)
      MEMORY[0x1CAA32ABC](&v103[1], v53);
  }
  v55 = llvm::DWARFDie::getAttributeValueAsReferencedDie(&v109, 73);
  if (v55)
  {
    v57 = v56;
    if (v56)
    {
      v58 = v55;
      sub_1C548BC00(a1, &v114);
      if ((_QWORD)v114 == *((_QWORD *)&v115 + 1))
        v59 = 0;
      else
        v59 = *(unsigned __int8 *)(*(_QWORD *)v114 + 34);
      *((_QWORD *)&v106 + 1) = sub_1C5488188(v58, v57, v59);
      *(_QWORD *)&v107 = v60;
    }
  }
  llvm::DWARFDie::find(&v109, 58, &v114);
  if (v117)
  {
    llvm::DWARFContext::getLineTableForUnit(a2[1], (llvm::DWARFUnit *)a2);
    if (v61)
    {
      v62 = v61;
      AsUnsignedConstant = llvm::DWARFFormValue::getAsUnsignedConstant((llvm::DWARFFormValue *)&v114);
      CompilationDir = llvm::DWARFUnit::getCompilationDir(a2);
      v65 = (uint64_t)CompilationDir;
      if (CompilationDir)
        v66 = strlen(CompilationDir);
      else
        v66 = 0;
      llvm::DWARFDebugLine::Prologue::getFileNameByIndex(v62 + 8, AsUnsignedConstant, v65, v66, 4, (uint64_t)__p, 0);
    }
  }
  llvm::DWARFDie::find(&v109, 59, &v114);
  if (v117)
    *(_QWORD *)&v105[8] = llvm::DWARFFormValue::getAsUnsignedConstant((llvm::DWARFFormValue *)&v114);
  v68 = (char *)a7[1];
  v67 = (char *)a7[2];
  if (v68 >= v67)
  {
    v70 = (v68 - (_BYTE *)*a7) >> 7;
    if ((unint64_t)(v70 + 1) >> 57)
      abort();
    v71 = v67 - (_BYTE *)*a7;
    v72 = v71 >> 6;
    if (v71 >> 6 <= (unint64_t)(v70 + 1))
      v72 = v70 + 1;
    if ((unint64_t)v71 >= 0x7FFFFFFFFFFFFF80)
      v73 = 0x1FFFFFFFFFFFFFFLL;
    else
      v73 = v72;
    if (v73)
    {
      if (v73 >> 57)
        sub_1C4764EE4();
      v74 = operator new(v73 << 7);
    }
    else
    {
      v74 = 0;
    }
    v83 = (void **)&v74[128 * v70];
    if (SHIBYTE(v103[0]) < 0)
    {
      sub_1C47EBC30(&v74[128 * v70], v102[0], (unint64_t)v102[1]);
    }
    else
    {
      *(_OWORD *)v83 = *(_OWORD *)v102;
      v83[2] = v103[0];
    }
    v84 = &v74[128 * v70 + 24];
    if (SHIBYTE(v103[3]) < 0)
    {
      sub_1C47EBC30(v84, v103[1], (unint64_t)v103[2]);
    }
    else
    {
      *(_OWORD *)v84 = *(_OWORD *)&v103[1];
      *(void **)&v74[128 * v70 + 40] = v103[3];
    }
    v85 = &v74[128 * v70 + 48];
    if ((v105[7] & 0x80000000) != 0)
    {
      sub_1C47EBC30(v85, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      *(_OWORD *)v85 = *(_OWORD *)__p;
      *(_QWORD *)&v74[128 * v70 + 64] = *(_QWORD *)v105;
    }
    v86 = &v74[128 * v73];
    v87 = &v74[128 * v70];
    v88 = v106;
    *(_OWORD *)(v87 + 72) = *(_OWORD *)&v105[8];
    *(_OWORD *)(v87 + 88) = v88;
    *(_OWORD *)(v87 + 104) = v107;
    *((_QWORD *)v87 + 15) = v108;
    v82 = (char *)(v83 + 16);
    v89 = (void **)*a7;
    v90 = (void **)a7[1];
    if (v90 == *a7)
    {
      *a7 = v83;
      a7[1] = v82;
      a7[2] = v86;
    }
    else
    {
      do
      {
        v91 = *((_OWORD *)v90 - 8);
        *(v83 - 14) = *(v90 - 14);
        *((_OWORD *)v83 - 8) = v91;
        *(v90 - 15) = 0;
        *(v90 - 14) = 0;
        *(v90 - 16) = 0;
        v92 = *(_OWORD *)(v90 - 13);
        *(v83 - 11) = *(v90 - 11);
        *(_OWORD *)(v83 - 13) = v92;
        *(v90 - 12) = 0;
        *(v90 - 11) = 0;
        *(v90 - 13) = 0;
        v93 = *((_OWORD *)v90 - 5);
        *(v83 - 8) = *(v90 - 8);
        *((_OWORD *)v83 - 5) = v93;
        *(v90 - 9) = 0;
        *(v90 - 8) = 0;
        *(v90 - 10) = 0;
        v94 = *(_OWORD *)(v90 - 7);
        v95 = *(_OWORD *)(v90 - 5);
        v96 = *(_OWORD *)(v90 - 3);
        *(v83 - 1) = *(v90 - 1);
        *(_OWORD *)(v83 - 3) = v96;
        *(_OWORD *)(v83 - 5) = v95;
        *(_OWORD *)(v83 - 7) = v94;
        v83 -= 16;
        v90 -= 16;
      }
      while (v90 != v89);
      v90 = (void **)*a7;
      v97 = (void **)a7[1];
      *a7 = v83;
      a7[1] = v82;
      a7[2] = v86;
      while (v97 != v90)
      {
        if (*((char *)v97 - 57) < 0)
          operator delete(*(v97 - 10));
        if (*((char *)v97 - 81) < 0)
          operator delete(*(v97 - 13));
        if (*((char *)v97 - 105) < 0)
          operator delete(*(v97 - 16));
        v97 -= 16;
      }
    }
    if (v90)
      operator delete(v90);
  }
  else
  {
    if (SHIBYTE(v103[0]) < 0)
    {
      sub_1C47EBC30(a7[1], v102[0], (unint64_t)v102[1]);
    }
    else
    {
      v69 = *(_OWORD *)v102;
      *((void **)v68 + 2) = v103[0];
      *(_OWORD *)v68 = v69;
    }
    v75 = v68 + 24;
    if (SHIBYTE(v103[3]) < 0)
    {
      sub_1C47EBC30(v75, v103[1], (unint64_t)v103[2]);
    }
    else
    {
      v76 = *(_OWORD *)&v103[1];
      *((void **)v68 + 5) = v103[3];
      *(_OWORD *)v75 = v76;
    }
    v77 = v68 + 48;
    if ((v105[7] & 0x80000000) != 0)
    {
      sub_1C47EBC30(v77, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      v78 = *(_OWORD *)__p;
      *((_QWORD *)v68 + 8) = *(_QWORD *)v105;
      *(_OWORD *)v77 = v78;
    }
    v79 = *(_OWORD *)&v105[8];
    v80 = v106;
    v81 = v107;
    *((_QWORD *)v68 + 15) = v108;
    *(_OWORD *)(v68 + 104) = v81;
    *(_OWORD *)(v68 + 88) = v80;
    *(_OWORD *)(v68 + 72) = v79;
    v82 = v68 + 128;
  }
  a7[1] = v82;
  if ((v105[7] & 0x80000000) != 0)
    operator delete(__p[0]);
  if (SHIBYTE(v103[3]) < 0)
    operator delete(v103[1]);
  if (SHIBYTE(v103[0]) < 0)
    operator delete(v102[0]);
}

unint64_t sub_1C5488188(llvm::DWARFUnit *a1, llvm::DWARFUnit *a2, uint64_t a3)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t AsUnsignedConstant;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  llvm::DWARFUnit *FirstChild;
  uint64_t LastChild;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  unint64_t v24;
  char v25;
  uint64_t v26;
  unint64_t AsSignedConstant;
  char v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  char v32;
  char v33;
  uint64_t v35;
  uint64_t v36;
  _BYTE v37[56];
  llvm::DWARFUnit *v38[2];
  _BYTE v39[48];
  char v40;
  llvm::DWARFUnit *v41[2];

  v41[0] = a1;
  v41[1] = a2;
  llvm::DWARFDie::find(v41, 11, v39);
  if (v40)
  {
    AsUnsignedConstant = llvm::DWARFFormValue::getAsUnsignedConstant((llvm::DWARFFormValue *)v39);
    if (v33)
      goto LABEL_48;
  }
  v6 = *((_QWORD *)a2 + 2);
  if (!v6)
    goto LABEL_45;
  v7 = *(unsigned __int16 *)(v6 + 4);
  v8 = (v7 - 15);
  if (v8 > 0x3C)
  {
LABEL_16:
    if (v7 == 1)
    {
      if (!llvm::DWARFDie::getAttributeValueAsReferencedDie(v41, 73))
        goto LABEL_46;
      v10 = 0;
      LOBYTE(v11) = 0;
      if (!v15)
        return v11 | v10;
      v16 = sub_1C5488188();
      if (v17)
      {
        v11 = v16;
        v18 = 0;
        FirstChild = 0;
        LastChild = 0;
        v21 = 0;
        if (a1 && a2)
        {
          FirstChild = (llvm::DWARFUnit *)llvm::DWARFUnit::getFirstChild((uint64_t)a1, (uint64_t)a2);
          v18 = v35;
          LastChild = llvm::DWARFUnit::getLastChild((uint64_t)a1, (uint64_t)a2);
          v21 = v36;
        }
        while (1)
        {
          while (1)
          {
            if (v18 == v21 && FirstChild == (llvm::DWARFUnit *)LastChild)
            {
              v10 = v11 & 0xFFFFFFFFFFFFFF00;
              return v11 | v10;
            }
            v38[0] = FirstChild;
            v38[1] = (llvm::DWARFUnit *)v18;
            v22 = *(_QWORD *)(v18 + 16);
            if (v22 && *(_WORD *)(v22 + 4) == 33)
            {
              llvm::DWARFDie::find(v38, 55, v39);
              if (v40)
              {
                v24 = llvm::DWARFFormValue::getAsUnsignedConstant((llvm::DWARFFormValue *)v39);
                if (v25)
                  v26 = v24;
                else
                  v26 = 1;
                v11 *= v26;
              }
              llvm::DWARFDie::find(v38, 47, v39);
              if (v40)
              {
                AsSignedConstant = llvm::DWARFFormValue::getAsSignedConstant((llvm::DWARFFormValue *)v39);
                if (v28)
                {
                  v29 = AsSignedConstant;
                  llvm::DWARFDie::find(v38, 34, v37);
                  if (v37[48])
                  {
                    v31 = llvm::DWARFFormValue::getAsSignedConstant((llvm::DWARFFormValue *)v37);
                    if (v32)
                      v30 = v31;
                    else
                      v30 = 0;
                  }
                  else
                  {
                    v30 = 0;
                  }
                  v11 += v11 * (v29 - v30);
                }
              }
            }
            if (FirstChild)
              break;
LABEL_28:
            v18 = 0;
          }
          v23 = *(_DWORD *)(v18 + 12);
          if (!v23)
          {
            FirstChild = 0;
            goto LABEL_28;
          }
          v18 = *((_QWORD *)FirstChild + 36) + 24 * v23;
        }
      }
    }
LABEL_45:
    v10 = 0;
    LOBYTE(v11) = 0;
    return v11 | v10;
  }
  if (((1 << (v7 - 15)) & 0x1000014000800080) == 0)
  {
    if (((1 << (v7 - 15)) & 0x8000000000003) != 0)
    {
LABEL_9:
      v10 = 0;
      LOBYTE(v11) = a3;
      return v11 | v10;
    }
    if (v8 == 16)
    {
      if (llvm::DWARFDie::getAttributeValueAsReferencedDie(v41, 73))
      {
        if (v13)
        {
          v14 = *(_QWORD *)(v13 + 16);
          if (v14)
          {
            if (*(_WORD *)(v14 + 4) == 21)
            {
              LOBYTE(v11) = 2 * a3;
              v10 = (2 * a3) & 0x7FFFFFFFFFFFFF00;
              return v11 | v10;
            }
          }
        }
      }
      goto LABEL_9;
    }
    goto LABEL_16;
  }
  if (!llvm::DWARFDie::getAttributeValueAsReferencedDie(v41, 73))
  {
LABEL_46:
    v10 = 0;
    LOBYTE(v11) = 0;
    return v11 | v10;
  }
  v10 = 0;
  LOBYTE(v11) = 0;
  if (v9)
  {
    AsUnsignedConstant = sub_1C5488188();
LABEL_48:
    LOBYTE(v11) = AsUnsignedConstant;
    v10 = AsUnsignedConstant & 0xFFFFFFFFFFFFFF00;
  }
  return v11 | v10;
}

void llvm::DWARFContext::getLocalsForAddress(uint64_t **a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  llvm::DWARFUnit *CompileUnitForAddress;
  llvm::DWARFContext **v7;
  llvm::DWARFUnit *SubroutineForAddress;
  uint64_t v9;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  CompileUnitForAddress = (llvm::DWARFUnit *)llvm::DWARFContext::getCompileUnitForAddress(a1, a2);
  if (CompileUnitForAddress)
  {
    v7 = (llvm::DWARFContext **)CompileUnitForAddress;
    SubroutineForAddress = (llvm::DWARFUnit *)llvm::DWARFUnit::getSubroutineForAddress(CompileUnitForAddress, a2);
    if (SubroutineForAddress)
    {
      if (v9)
        llvm::DWARFContext::addLocalsForDie((uint64_t)a1, v7, SubroutineForAddress, v9, SubroutineForAddress, v9, (void **)a3);
    }
  }
}

void llvm::DWARFContext::getLineInfoForAddress(uint64_t **a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  llvm::DWARFUnit *CompileUnitForAddress;
  llvm::DWARFUnit *v11;
  _QWORD *v12;
  _QWORD *v13;
  char *CompilationDir;

  strcpy((char *)(a5 + 23), "\t<invalid>");
  strcpy((char *)a5, "<invalid>");
  strcpy((char *)(a5 + 47), "\t<invalid>");
  *(_WORD *)(a5 + 71) = 9;
  *(_BYTE *)(a5 + 88) = 0;
  *(_DWORD *)(a5 + 104) = 0;
  *(_QWORD *)(a5 + 96) = 0;
  *(_BYTE *)(a5 + 112) = 0;
  *(_BYTE *)(a5 + 120) = 0;
  *(_DWORD *)(a5 + 128) = 0;
  CompileUnitForAddress = (llvm::DWARFUnit *)llvm::DWARFContext::getCompileUnitForAddress(a1, a2);
  if (CompileUnitForAddress)
  {
    v11 = CompileUnitForAddress;
    sub_1C5488624(CompileUnitForAddress, a2, SHIDWORD(a4), a4, a5 + 24, (std::string *)(a5 + 48), (_DWORD *)(a5 + 104), a5 + 112);
    if ((_DWORD)a4)
    {
      llvm::DWARFContext::getLineTableForUnit((llvm::DWARFContext *)a1, v11);
      if (v12)
      {
        v13 = v12;
        CompilationDir = llvm::DWARFUnit::getCompilationDir((llvm::DWARFUnit **)v11);
        llvm::DWARFDebugLine::LineTable::getFileLineInfoForAddress(v13, a2, a3, CompilationDir, a4, a5);
      }
    }
  }
}

void sub_1C5488624(llvm::DWARFUnit *a1, unint64_t a2, int a3, int a4, uint64_t a5, std::string *a6, _DWORD *a7, uint64_t a8)
{
  llvm::DWARFDie *v14;
  char *SubroutineName;
  std::string::size_type size;
  unint64_t DeclLine;
  int v18;
  _QWORD v19[6];
  char v20;
  uint64_t v21;
  char v22;
  std::string __str;
  void *v24;
  uint64_t v25;
  _QWORD v26[9];

  v26[8] = *MEMORY[0x1E0C80C00];
  v24 = v26;
  v25 = 0x400000000;
  llvm::DWARFUnit::getInlinedChainForAddress(a1, a2, (uint64_t)&v24);
  if ((_DWORD)v25)
  {
    v14 = (llvm::DWARFDie *)v24;
    if (a3)
    {
      SubroutineName = llvm::DWARFDie::getSubroutineName((llvm::DWARFDie *)v24, a3);
      if (SubroutineName)
        MEMORY[0x1CAA32ABC](a5, SubroutineName);
    }
    llvm::DWARFDie::getDeclFile(v14, a4, (uint64_t)&__str);
    size = *((_BYTE *)&__str.__r_.__value_.__s + 23) & 0x7F;
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      size = __str.__r_.__value_.__l.__size_;
    if (size)
      std::string::operator=(a6, &__str);
    DeclLine = llvm::DWARFDie::getDeclLine(v14);
    if (DeclLine)
      *a7 = DeclLine;
    llvm::DWARFDie::find((llvm::DWARFUnit **)v14, 17, v19);
    if (v20)
    {
      llvm::DWARFFormValue::getAsSectionedAddress(v19, (uint64_t)&v21);
      if (v22)
      {
        v18 = *(unsigned __int8 *)(a8 + 8);
        *(_QWORD *)a8 = v21;
        if (!v18)
          *(_BYTE *)(a8 + 8) = 1;
      }
    }
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__str.__r_.__value_.__l.__data_);
  }
  if (v24 != v26)
    free(v24);
}

void llvm::DWARFContext::getLineInfoForAddressRange(uint64_t **a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, _QWORD *a6@<X8>)
{
  llvm::DWARFUnit *CompileUnitForAddress;
  llvm::DWARFUnit *v13;
  unsigned int *v14;
  _QWORD *v15;
  _QWORD *v16;
  int v17;
  unsigned int *v18;
  unsigned int *v19;
  _QWORD *v20;
  uint64_t v21;
  unint64_t v22;
  char *CompilationDir;
  uint64_t v24;
  size_t v25;
  unsigned int *v26;
  int v27;
  uint64_t v28;
  unsigned int *v29;
  unsigned int *v30;
  unsigned int *v31;
  uint64_t v32;
  unint64_t v33;
  __int128 v34;
  uint64_t v35;
  __int128 v36;
  uint64_t v37;
  __int128 __p;
  uint64_t v39;
  __int128 v40;
  __int128 v41;
  _OWORD v42[2];
  __int128 v43;
  _BYTE v44[24];
  _BYTE v45[24];
  _BYTE v46[24];
  __int128 v47;
  _BYTE v48[28];
  __int128 v49;
  std::string __str;
  std::string v51;
  int v52[3];

  *a6 = a6 + 2;
  a6[1] = 0x1000000000;
  CompileUnitForAddress = (llvm::DWARFUnit *)llvm::DWARFContext::getCompileUnitForAddress(a1, a2);
  if (!CompileUnitForAddress)
    return;
  v13 = CompileUnitForAddress;
  v52[0] = 0;
  memset(&v51, 0, sizeof(v51));
  *((_BYTE *)&__str.__r_.__value_.__s + 23) = 9;
  strcpy((char *)&__str, "<invalid>");
  LOBYTE(v49) = 0;
  BYTE8(v49) = 0;
  sub_1C5488624(CompileUnitForAddress, a2, SHIDWORD(a5), a5, (uint64_t)&__str, &v51, v52, (uint64_t)&v49);
  if ((_DWORD)a5)
  {
    llvm::DWARFContext::getLineTableForUnit((llvm::DWARFContext *)a1, v13);
    v16 = v15;
    v30 = 0;
    v31 = 0;
    v32 = 0;
    v17 = llvm::DWARFDebugLine::LineTable::lookupAddressRange(v15, a2, a3, a4, (uint64_t)&v30);
    v18 = v30;
    if (v17)
    {
      v29 = v31;
      if (v30 != v31)
      {
        v28 = (uint64_t)(v16 + 1);
        v27 = v52[0];
        v19 = v30;
        v26 = v30;
        do
        {
          v20 = v16;
          v21 = v16[15] + 32 * *v19;
          strcpy(&v44[7], "\t<invalid>");
          strcpy((char *)&v43, "<invalid>");
          strcpy(&v45[7], "\t<invalid>");
          strcpy(&v46[7], "\t");
          LOBYTE(v47) = 0;
          *((_QWORD *)&v47 + 1) = 0;
          *(_DWORD *)v48 = 0;
          v48[8] = 0;
          v48[16] = 0;
          *(_DWORD *)&v48[24] = 0;
          v22 = *(unsigned __int16 *)(v21 + 22);
          CompilationDir = llvm::DWARFUnit::getCompilationDir((llvm::DWARFUnit **)v13);
          v24 = (uint64_t)CompilationDir;
          if (CompilationDir)
            v25 = strlen(CompilationDir);
          else
            v25 = 0;
          llvm::DWARFDebugLine::Prologue::getFileNameByIndex(v28, v22, v24, v25, a5, (uint64_t)&v43, 0);
          std::string::operator=((std::string *)&v44[8], &__str);
          DWORD2(v47) = *(_DWORD *)(v21 + 16);
          HIDWORD(v47) = *(unsigned __int16 *)(v21 + 20);
          std::string::operator=((std::string *)&v45[8], &v51);
          *(_DWORD *)v48 = v27;
          *(_OWORD *)&v48[8] = v49;
          v33 = *(_QWORD *)v21;
          if ((v44[7] & 0x80000000) != 0)
          {
            sub_1C47EBC30(&v34, (void *)v43, *((unint64_t *)&v43 + 1));
          }
          else
          {
            v34 = v43;
            v35 = *(_QWORD *)v44;
          }
          v18 = v26;
          v16 = v20;
          if ((v45[7] & 0x80000000) != 0)
          {
            sub_1C47EBC30(&v36, *(void **)&v44[8], *(unint64_t *)&v44[16]);
          }
          else
          {
            v36 = *(_OWORD *)&v44[8];
            v37 = *(_QWORD *)v45;
          }
          if ((v46[7] & 0x80000000) != 0)
          {
            sub_1C47EBC30(&__p, *(void **)&v45[8], *(unint64_t *)&v45[16]);
          }
          else
          {
            __p = *(_OWORD *)&v45[8];
            v39 = *(_QWORD *)v46;
          }
          v40 = *(_OWORD *)&v46[8];
          v41 = v47;
          v42[0] = *(_OWORD *)v48;
          *(_OWORD *)((char *)v42 + 12) = *(_OWORD *)&v48[12];
          sub_1C5488CE8((uint64_t)a6, (unint64_t)&v33);
          if (SHIBYTE(v39) < 0)
            operator delete((void *)__p);
          if (SHIBYTE(v37) < 0)
            operator delete((void *)v36);
          if (SHIBYTE(v35) < 0)
            operator delete((void *)v34);
          if ((v46[7] & 0x80000000) != 0)
            operator delete(*(void **)&v45[8]);
          if ((v45[7] & 0x80000000) != 0)
            operator delete(*(void **)&v44[8]);
          if ((v44[7] & 0x80000000) != 0)
            operator delete((void *)v43);
          ++v19;
        }
        while (v19 != v29);
      }
    }
    if (!v18)
      goto LABEL_25;
    v14 = v18;
  }
  else
  {
    strcpy(&v44[7], "\t<invalid>");
    strcpy((char *)&v43, "<invalid>");
    strcpy(&v45[7], "\t<invalid>");
    strcpy(&v46[7], "\t");
    LOBYTE(v47) = 0;
    *((_QWORD *)&v47 + 1) = 0;
    *(_DWORD *)v48 = 0;
    v48[8] = 0;
    v48[16] = 0;
    *(_DWORD *)&v48[24] = 0;
    std::string::operator=((std::string *)&v44[8], &__str);
    std::string::operator=((std::string *)&v45[8], &v51);
    *(_DWORD *)v48 = v52[0];
    *(_OWORD *)&v48[8] = v49;
    v33 = a2;
    if ((v44[7] & 0x80000000) != 0)
    {
      sub_1C47EBC30(&v34, (void *)v43, *((unint64_t *)&v43 + 1));
    }
    else
    {
      v34 = v43;
      v35 = *(_QWORD *)v44;
    }
    if ((v45[7] & 0x80000000) != 0)
    {
      sub_1C47EBC30(&v36, *(void **)&v44[8], *(unint64_t *)&v44[16]);
    }
    else
    {
      v36 = *(_OWORD *)&v44[8];
      v37 = *(_QWORD *)v45;
    }
    if ((v46[7] & 0x80000000) != 0)
    {
      sub_1C47EBC30(&__p, *(void **)&v45[8], *(unint64_t *)&v45[16]);
    }
    else
    {
      __p = *(_OWORD *)&v45[8];
      v39 = *(_QWORD *)v46;
    }
    v40 = *(_OWORD *)&v46[8];
    v41 = v47;
    v42[0] = *(_OWORD *)v48;
    *(_OWORD *)((char *)v42 + 12) = *(_OWORD *)&v48[12];
    sub_1C5488CE8((uint64_t)a6, (unint64_t)&v33);
    if (SHIBYTE(v39) < 0)
      operator delete((void *)__p);
    if (SHIBYTE(v37) < 0)
      operator delete((void *)v36);
    if (SHIBYTE(v35) < 0)
      operator delete((void *)v34);
    if ((v46[7] & 0x80000000) != 0)
      operator delete(*(void **)&v45[8]);
    if ((v45[7] & 0x80000000) != 0)
      operator delete(*(void **)&v44[8]);
    if ((v44[7] & 0x80000000) == 0)
      goto LABEL_25;
    v14 = (unsigned int *)v43;
  }
  operator delete(v14);
LABEL_25:
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v51.__r_.__value_.__l.__data_);
}

__n128 sub_1C5488CE8(uint64_t a1, unint64_t a2)
{
  unint64_t v3;
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  __n128 result;
  __int128 v9;
  __int128 v10;

  v3 = sub_1C548DAA4(a1, a2, 1);
  v4 = *(_QWORD *)a1 + 144 * *(unsigned int *)(a1 + 8);
  *(_QWORD *)v4 = *(_QWORD *)v3;
  v5 = *(_OWORD *)(v3 + 8);
  *(_QWORD *)(v4 + 24) = *(_QWORD *)(v3 + 24);
  *(_OWORD *)(v4 + 8) = v5;
  *(_QWORD *)(v3 + 16) = 0;
  *(_QWORD *)(v3 + 24) = 0;
  *(_QWORD *)(v3 + 8) = 0;
  v6 = *(_QWORD *)(v3 + 48);
  *(_OWORD *)(v4 + 32) = *(_OWORD *)(v3 + 32);
  *(_QWORD *)(v4 + 48) = v6;
  *(_QWORD *)(v3 + 40) = 0;
  *(_QWORD *)(v3 + 48) = 0;
  *(_QWORD *)(v3 + 32) = 0;
  v7 = *(_QWORD *)(v3 + 72);
  *(_OWORD *)(v4 + 56) = *(_OWORD *)(v3 + 56);
  *(_QWORD *)(v4 + 72) = v7;
  *(_QWORD *)(v3 + 64) = 0;
  *(_QWORD *)(v3 + 72) = 0;
  *(_QWORD *)(v3 + 56) = 0;
  result = *(__n128 *)(v3 + 80);
  v9 = *(_OWORD *)(v3 + 96);
  v10 = *(_OWORD *)(v3 + 112);
  *(_OWORD *)(v4 + 124) = *(_OWORD *)(v3 + 124);
  *(_OWORD *)(v4 + 96) = v9;
  *(_OWORD *)(v4 + 112) = v10;
  *(__n128 *)(v4 + 80) = result;
  ++*(_DWORD *)(a1 + 8);
  return result;
}

void llvm::DWARFContext::getInliningInfoForAddress(uint64_t **a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, _QWORD *a5@<X8>)
{
  llvm::DWARFUnit *CompileUnitForAddress;
  llvm::DWARFUnit **v11;
  uint64_t v12;
  unint64_t v13;
  llvm::DWARFDie *v14;
  char *SubroutineName;
  unint64_t DeclLine;
  unint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  __int128 v21;
  _BYTE *v22;
  __int128 v23;
  _BYTE *v24;
  __int128 v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  _QWORD *v30;
  unint64_t v31;
  char *CompilationDir;
  uint64_t v33;
  size_t v34;
  _QWORD *v35;
  char *v36;
  _QWORD *v37;
  _QWORD *v38;
  char *v39;
  unint64_t v40;
  uint64_t v41;
  unsigned int v42;
  uint64_t v43;
  __int128 v44;
  _BYTE *v45;
  __int128 v46;
  _BYTE *v47;
  __int128 v48;
  uint64_t v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  _QWORD *v56;
  uint64_t v57;
  __int128 v58;
  uint64_t v59;
  char v60;
  uint64_t v61;
  char v62;
  unsigned int v63[2];
  unsigned int v64[2];
  void *v65[2];
  char v66[24];
  char v67[17];
  _QWORD v68[3];
  char v69;
  unint64_t v70;
  int v71;
  uint64_t v72;
  char v73;
  unsigned int v74;
  char *v75;
  uint64_t v76;
  _QWORD v77[10];

  v77[8] = *MEMORY[0x1E0C80C00];
  *a5 = a5 + 2;
  a5[1] = 0x400000000;
  CompileUnitForAddress = (llvm::DWARFUnit *)llvm::DWARFContext::getCompileUnitForAddress(a1, a2);
  if (CompileUnitForAddress)
  {
    v11 = (llvm::DWARFUnit **)CompileUnitForAddress;
    v75 = (char *)v77;
    v76 = 0x400000000;
    llvm::DWARFUnit::getInlinedChainForAddress(CompileUnitForAddress, a2, (uint64_t)&v75);
    if ((_DWORD)v76)
    {
      v53 = a2;
      v54 = a3;
      v12 = 0;
      *(_QWORD *)v63 = 0;
      *(_QWORD *)v64 = 0;
      v55 = v76;
      v56 = 0;
      v57 = 16 * v76;
      v13 = 1;
      do
      {
        v14 = (llvm::DWARFDie *)&v75[v12];
        strcpy(v66, "\t<invalid>");
        strcpy((char *)v65, "<invalid>");
        strcpy(v67, "\t<invalid>");
        strcpy((char *)v68 + 7, "\t");
        v69 = 0;
        v70 = 0;
        v71 = 0;
        LOBYTE(v72) = 0;
        v73 = 0;
        v74 = 0;
        SubroutineName = llvm::DWARFDie::getSubroutineName((llvm::DWARFDie *)&v75[v12], SHIDWORD(a4));
        if (SubroutineName)
          MEMORY[0x1CAA32ABC](&v66[1], SubroutineName);
        DeclLine = llvm::DWARFDie::getDeclLine(v14);
        if (DeclLine)
          v71 = DeclLine;
        llvm::DWARFDie::getDeclFile(v14, a4, (uint64_t)&v58);
        if (SHIBYTE(v68[0]) < 0)
          operator delete(*(void **)&v67[1]);
        *(_OWORD *)&v67[1] = v58;
        v68[0] = v59;
        llvm::DWARFDie::find((llvm::DWARFUnit **)v14, 17, &v58);
        if (v60)
        {
          llvm::DWARFFormValue::getAsSectionedAddress(&v58, (uint64_t)&v61);
          if (v62)
          {
            v72 = v61;
            if (!v73)
              v73 = 1;
          }
        }
        if ((_DWORD)a4)
        {
          if (v12)
          {
            if (v56)
            {
              v31 = v64[1];
              CompilationDir = llvm::DWARFUnit::getCompilationDir(v11);
              v33 = (uint64_t)CompilationDir;
              if (CompilationDir)
                v34 = strlen(CompilationDir);
              else
                v34 = 0;
              llvm::DWARFDebugLine::Prologue::getFileNameByIndex((uint64_t)(v56 + 1), v31, v33, v34, a4, (uint64_t)v65, 0);
            }
            v70 = __PAIR64__(v63[1], v64[0]);
            v74 = v63[0];
          }
          else
          {
            llvm::DWARFContext::getLineTableForUnit((llvm::DWARFContext *)a1, (llvm::DWARFUnit *)v11);
            if (v30)
            {
              v35 = v30;
              v36 = llvm::DWARFUnit::getCompilationDir(v11);
              v56 = v35;
              llvm::DWARFDebugLine::LineTable::getFileLineInfoForAddress(v35, v53, v54, v36, a4, (uint64_t)v65);
            }
            else
            {
              v56 = 0;
            }
          }
          if (v13 < v55)
            llvm::DWARFDie::getCallerFrame((llvm::DWARFUnit **)v14, &v64[1], v64, &v63[1], v63);
        }
        v17 = sub_1C548D3D4((uint64_t)a5, (unint64_t)v65, 1);
        v18 = *a5;
        v19 = *((_DWORD *)a5 + 2);
        v20 = *a5 + 136 * v19;
        if (*(char *)(v17 + 23) < 0)
        {
          sub_1C47EBC30((_BYTE *)v20, *(void **)v17, *(_QWORD *)(v17 + 8));
        }
        else
        {
          v21 = *(_OWORD *)v17;
          *(_QWORD *)(v20 + 16) = *(_QWORD *)(v17 + 16);
          *(_OWORD *)v20 = v21;
        }
        v22 = (_BYTE *)(v18 + 136 * v19 + 24);
        if (*(char *)(v17 + 47) < 0)
        {
          sub_1C47EBC30(v22, *(void **)(v17 + 24), *(_QWORD *)(v17 + 32));
        }
        else
        {
          v23 = *(_OWORD *)(v17 + 24);
          *(_QWORD *)(v18 + 136 * v19 + 40) = *(_QWORD *)(v17 + 40);
          *(_OWORD *)v22 = v23;
        }
        v24 = (_BYTE *)(v18 + 136 * v19 + 48);
        if (*(char *)(v17 + 71) < 0)
        {
          sub_1C47EBC30(v24, *(void **)(v17 + 48), *(_QWORD *)(v17 + 56));
        }
        else
        {
          v25 = *(_OWORD *)(v17 + 48);
          *(_QWORD *)(v18 + 136 * v19 + 64) = *(_QWORD *)(v17 + 64);
          *(_OWORD *)v24 = v25;
        }
        v26 = v18 + 136 * v19;
        v27 = *(_OWORD *)(v17 + 72);
        v28 = *(_OWORD *)(v17 + 88);
        v29 = *(_OWORD *)(v17 + 104);
        *(_OWORD *)(v26 + 116) = *(_OWORD *)(v17 + 116);
        *(_OWORD *)(v26 + 104) = v29;
        *(_OWORD *)(v26 + 88) = v28;
        *(_OWORD *)(v26 + 72) = v27;
        ++*((_DWORD *)a5 + 2);
        if (SHIBYTE(v68[0]) < 0)
          operator delete(*(void **)&v67[1]);
        if (v67[0] < 0)
          operator delete(*(void **)&v66[1]);
        if (v66[0] < 0)
          operator delete(v65[0]);
        v12 += 16;
        ++v13;
      }
      while (v57 != v12);
    }
    else if ((_DWORD)a4)
    {
      strcpy(v66, "\t<invalid>");
      strcpy((char *)v65, "<invalid>");
      strcpy(v67, "\t<invalid>");
      strcpy((char *)v68 + 7, "\t");
      v69 = 0;
      v70 = 0;
      v71 = 0;
      LOBYTE(v72) = 0;
      v73 = 0;
      v74 = 0;
      llvm::DWARFContext::getLineTableForUnit((llvm::DWARFContext *)a1, (llvm::DWARFUnit *)v11);
      if (v37)
      {
        v38 = v37;
        v39 = llvm::DWARFUnit::getCompilationDir(v11);
        if (llvm::DWARFDebugLine::LineTable::getFileLineInfoForAddress(v38, a2, a3, v39, a4, (uint64_t)v65))
        {
          v40 = sub_1C548D3D4((uint64_t)a5, (unint64_t)v65, 1);
          v41 = *a5;
          v42 = *((_DWORD *)a5 + 2);
          v43 = *a5 + 136 * v42;
          if (*(char *)(v40 + 23) < 0)
          {
            sub_1C47EBC30((_BYTE *)v43, *(void **)v40, *(_QWORD *)(v40 + 8));
          }
          else
          {
            v44 = *(_OWORD *)v40;
            *(_QWORD *)(v43 + 16) = *(_QWORD *)(v40 + 16);
            *(_OWORD *)v43 = v44;
          }
          v45 = (_BYTE *)(v41 + 136 * v42 + 24);
          if (*(char *)(v40 + 47) < 0)
          {
            sub_1C47EBC30(v45, *(void **)(v40 + 24), *(_QWORD *)(v40 + 32));
          }
          else
          {
            v46 = *(_OWORD *)(v40 + 24);
            *(_QWORD *)(v41 + 136 * v42 + 40) = *(_QWORD *)(v40 + 40);
            *(_OWORD *)v45 = v46;
          }
          v47 = (_BYTE *)(v41 + 136 * v42 + 48);
          if (*(char *)(v40 + 71) < 0)
          {
            sub_1C47EBC30(v47, *(void **)(v40 + 48), *(_QWORD *)(v40 + 56));
          }
          else
          {
            v48 = *(_OWORD *)(v40 + 48);
            *(_QWORD *)(v41 + 136 * v42 + 64) = *(_QWORD *)(v40 + 64);
            *(_OWORD *)v47 = v48;
          }
          v49 = v41 + 136 * v42;
          v50 = *(_OWORD *)(v40 + 72);
          v51 = *(_OWORD *)(v40 + 88);
          v52 = *(_OWORD *)(v40 + 104);
          *(_OWORD *)(v49 + 116) = *(_OWORD *)(v40 + 116);
          *(_OWORD *)(v49 + 104) = v52;
          *(_OWORD *)(v49 + 88) = v51;
          *(_OWORD *)(v49 + 72) = v50;
          ++*((_DWORD *)a5 + 2);
        }
      }
      if (SHIBYTE(v68[0]) < 0)
        operator delete(*(void **)&v67[1]);
      if (v67[0] < 0)
        operator delete(*(void **)&v66[1]);
      if (v66[0] < 0)
        operator delete(v65[0]);
    }
    if (v75 != (char *)v77)
      free(v75);
  }
}

void llvm::DWARFContext::getDWOContext(uint64_t a1@<X0>, unsigned __int8 *a2@<X1>, size_t a3@<X2>, uint64_t *a4@<X8>)
{
  _QWORD *v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unsigned int v17;
  int v18;
  size_t v19;
  unsigned __int8 *v20;
  int v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  int v25;
  int v26;
  int v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  _QWORD *v31;
  size_t *v32;
  char *v33;
  _QWORD **i;
  _QWORD *v36;
  std::__shared_weak_count *v37;
  std::__shared_weak_count *v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  uint64_t *v45;
  char v46;
  void *v47;
  uint64_t v48;
  char *v49;
  char *v50;
  char v51;
  char *v52;
  uint64_t shared_owners;
  std::__shared_count_vtbl *v54;
  std::__shared_weak_count *v55;
  unint64_t *v56;
  unint64_t *p_shared_weak_owners;
  std::__shared_count_vtbl *v58;
  _QWORD *v59;
  void (**v60)(void);
  char *v61;
  void (**v62)(void);
  unint64_t v63;
  std::__shared_weak_count *v64;
  unint64_t v65;
  unint64_t v66;
  uint64_t v67;
  std::__shared_count_vtbl *v68;
  _QWORD *v69;
  _QWORD *v70;
  uint64_t *v71;
  void *__p;
  char v74;
  char *v75[4];
  __int16 v76;
  char *v77;
  _QWORD v78[3];
  _QWORD *v79;
  _QWORD v80[3];
  _QWORD *v81;
  std::__shared_count v82;
  char v83;
  void *v84;
  __int128 v85;
  _QWORD v86[18];

  v86[16] = *MEMORY[0x1E0C80C00];
  v7 = (_QWORD *)(a1 + 400);
  v8 = *(std::__shared_weak_count **)(a1 + 408);
  if (!v8)
    goto LABEL_13;
  v9 = std::__shared_weak_count::lock(v8);
  if (!v9)
    goto LABEL_13;
  v10 = v9;
  v11 = *v7;
  if (*v7)
  {
    *a4 = *(_QWORD *)(v11 + 16);
    a4[1] = (uint64_t)v9;
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
    do
      v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (v14)
      return;
  }
  else
  {
    v15 = (unint64_t *)&v9->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (v16)
      goto LABEL_13;
  }
  ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
  std::__shared_weak_count::__release_weak(v10);
  if (v11)
    return;
LABEL_13:
  v17 = *(_DWORD *)(a1 + 376);
  if (!v17)
  {
    *(_QWORD *)(a1 + 380) = 0;
    v69 = malloc_type_calloc(0x11uLL, 0xCuLL, 0x6D9A4F0CuLL);
    if (!v69)
      llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    v69[16] = 2;
    *(_QWORD *)(a1 + 368) = v69;
    v17 = 16;
    *(_DWORD *)(a1 + 376) = 16;
  }
  v70 = v7;
  v71 = a4;
  v18 = 0;
  if (a3)
  {
    v19 = a3;
    v20 = a2;
    do
    {
      v21 = *v20++;
      v18 = 33 * v18 + v21;
      --v19;
    }
    while (v19);
  }
  v22 = *(_QWORD *)(a1 + 368);
  v23 = v17 - 1;
  v24 = v22 + 8 * v17 + 8;
  v25 = -1;
  v26 = 1;
  v27 = v18;
  while (1)
  {
    v28 = v27 & v23;
    v29 = *(_QWORD **)(v22 + 8 * v28);
    if (!v29)
      break;
    if (v29 == (_QWORD *)-8)
    {
      if (v25 == -1)
        v25 = v27 & v23;
    }
    else if (*(_DWORD *)(v24 + 4 * v28) == v18
           && a3 == *v29
           && (!a3 || !memcmp(a2, (char *)v29 + *(unsigned int *)(a1 + 388), a3)))
    {
      goto LABEL_32;
    }
    v27 = v26 + v28;
    ++v26;
  }
  v30 = v25;
  if (v25 == -1)
  {
    v30 = v28;
    v28 = v28;
  }
  else
  {
    v28 = v25;
  }
  *(_DWORD *)(v24 + 4 * v30) = v18;
  v29 = *(_QWORD **)(v22 + 8 * v28);
LABEL_32:
  if (v29 == (_QWORD *)-8)
  {
    --*(_DWORD *)(a1 + 384);
  }
  else if (v29)
  {
    goto LABEL_45;
  }
  v31 = operator new(a3 + 25, (std::align_val_t)8uLL);
  v32 = v31;
  v33 = (char *)(v31 + 3);
  if (a3)
    memcpy(v31 + 3, a2, a3);
  v33[a3] = 0;
  v32[1] = 0;
  v32[2] = 0;
  *v32 = a3;
  *(_QWORD *)(v22 + 8 * v28) = v32;
  ++*(_DWORD *)(a1 + 380);
  for (i = (_QWORD **)(*(_QWORD *)(a1 + 368)
                      + 8 * llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)(a1 + 368), v28)); ; ++i)
  {
    v29 = *i;
    if (*i && v29 + 1 != 0)
      break;
  }
LABEL_45:
  v36 = v29 + 1;
  v37 = (std::__shared_weak_count *)v29[2];
  if (v37)
  {
    v38 = std::__shared_weak_count::lock(v37);
    if (v38)
    {
      v39 = v38;
      if (*v36)
      {
        *v71 = *(_QWORD *)(*v36 + 16);
        v71[1] = (uint64_t)v38;
        v40 = (unint64_t *)&v38->__shared_owners_;
        do
          v41 = __ldxr(v40);
        while (__stxr(v41 + 1, v40));
        do
          v42 = __ldaxr(v40);
        while (__stlxr(v42 - 1, v40));
        if (!v42)
        {
          ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
          std::__shared_weak_count::__release_weak(v39);
        }
        return;
      }
      v43 = (unint64_t *)&v38->__shared_owners_;
      do
        v44 = __ldaxr(v43);
      while (__stlxr(v44 - 1, v43));
      if (!v44)
      {
        ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
        std::__shared_weak_count::__release_weak(v39);
      }
    }
  }
  if (*(_BYTE *)(a1 + 416))
  {
    v70 = v29 + 1;
    v45 = v71;
LABEL_81:
    llvm::object::ObjectFile::createObjectFile((uint64_t)a2, a3, (uint64_t)&v82);
    goto LABEL_82;
  }
  v84 = v86;
  v85 = xmmword_1C85F20B0;
  v46 = *(_BYTE *)(a1 + 447);
  if (v46 < 0)
  {
    if (*(_QWORD *)(a1 + 432))
      goto LABEL_61;
LABEL_68:
    v49 = (char *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 520) + 16))(*(_QWORD *)(a1 + 520));
    v76 = 773;
    v75[0] = v49;
    v75[1] = v50;
    v75[2] = ".dwp";
    llvm::Twine::toVector((uint64_t)v75, (uint64_t)&v84);
    v47 = v84;
    v48 = v85;
    goto LABEL_69;
  }
  if (!*(_BYTE *)(a1 + 447))
    goto LABEL_68;
LABEL_61:
  if (v46 >= 0)
    v47 = (void *)(a1 + 424);
  else
    v47 = *(void **)(a1 + 424);
  if (v46 >= 0)
    v48 = *(unsigned __int8 *)(a1 + 447);
  else
    v48 = *(_QWORD *)(a1 + 432);
LABEL_69:
  llvm::object::ObjectFile::createObjectFile((uint64_t)v47, v48, (uint64_t)&v82);
  v51 = v83;
  if ((v83 & 1) != 0)
  {
    *(_BYTE *)(a1 + 416) = 1;
    v52 = (char *)v82.__vftable;
    v82.__vftable = 0;
    v77 = v52;
    sub_1C4D62BD4(&v77, v75);
    if (v77)
      (*(void (**)(char *))(*(_QWORD *)v77 + 8))(v77);
    if ((v83 & 1) == 0)
    {
      shared_owners = v82.__shared_owners_;
      v82.__shared_owners_ = 0;
      if (shared_owners)
        (*(void (**)(uint64_t))(*(_QWORD *)shared_owners + 8))(shared_owners);
    }
    v54 = v82.__vftable;
    v82.__vftable = 0;
    if (v54)
      (*((void (**)(std::__shared_count_vtbl *))v54->~__shared_count + 1))(v54);
    v70 = v29 + 1;
  }
  if (v84 != v86)
    free(v84);
  v45 = v71;
  if ((v51 & 1) != 0)
    goto LABEL_81;
LABEL_82:
  if ((v83 & 1) != 0)
  {
    v61 = (char *)v82.__vftable;
    v82.__vftable = 0;
    v75[0] = v61;
    sub_1C4D62BD4(v75, (char **)&v84);
    if (v75[0])
      (*(void (**)(char *))(*(_QWORD *)v75[0] + 8))(v75[0]);
    *v45 = 0;
    v45[1] = 0;
    goto LABEL_106;
  }
  v55 = (std::__shared_weak_count *)operator new(0x30uLL);
  v55->__shared_owners_ = 0;
  v56 = (unint64_t *)&v55->__shared_owners_;
  v55->__shared_weak_owners_ = 0;
  p_shared_weak_owners = (unint64_t *)&v55->__shared_weak_owners_;
  v55->__vftable = (std::__shared_weak_count_vtbl *)&off_1E8169998;
  v58 = v82.__vftable;
  v55[1].std::__shared_count = v82;
  v82 = (std::__shared_count)0;
  v74 = 0;
  v80[0] = &unk_1E8169658;
  v80[1] = llvm::WithColor::defaultErrorHandler;
  v81 = v80;
  LOBYTE(__p) = 0;
  v78[0] = &unk_1E8169658;
  v78[1] = llvm::WithColor::defaultWarningHandler;
  v79 = v78;
  llvm::DWARFContext::create(v58, 1, 0, (uint64_t)&__p, v80, v78, &v55[1].__shared_weak_owners_);
  if (v79 == v78)
  {
    v60 = (void (**)(void))(v78[0] + 32);
    v59 = v70;
  }
  else
  {
    v59 = v70;
    if (!v79)
      goto LABEL_91;
    v60 = (void (**)(void))(*v79 + 40);
  }
  (*v60)();
LABEL_91:
  if (v81 == v80)
  {
    v62 = (void (**)(void))(v80[0] + 32);
    goto LABEL_95;
  }
  if (v81)
  {
    v62 = (void (**)(void))(*v81 + 40);
LABEL_95:
    (*v62)();
  }
  if (v74 < 0)
    operator delete(__p);
  do
    v63 = __ldxr(p_shared_weak_owners);
  while (__stxr(v63 + 1, p_shared_weak_owners));
  v64 = (std::__shared_weak_count *)v59[1];
  *v59 = v55 + 1;
  v59[1] = v55;
  if (v64)
    std::__shared_weak_count::__release_weak(v64);
  *v45 = v55[1].__shared_weak_owners_;
  v45[1] = (uint64_t)v55;
  do
    v65 = __ldxr(v56);
  while (__stxr(v65 + 1, v56));
  do
    v66 = __ldaxr(v56);
  while (__stlxr(v66 - 1, v56));
  if (!v66)
  {
    ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
    std::__shared_weak_count::__release_weak(v55);
  }
LABEL_106:
  if ((v83 & 1) == 0)
  {
    v67 = v82.__shared_owners_;
    v82.__shared_owners_ = 0;
    if (v67)
      (*(void (**)(uint64_t))(*(_QWORD *)v67 + 8))(v67);
  }
  v68 = v82.__vftable;
  v82.__vftable = 0;
  if (v68)
    (*((void (**)(std::__shared_count_vtbl *))v68->~__shared_count + 1))(v68);
}

void *llvm::DWARFContext::create@<X0>(_DWORD *a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _QWORD *a5@<X4>, _QWORD *a6@<X5>, uint64_t *a7@<X8>)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unsigned __int8 **v13;
  unsigned __int8 **v14;
  size_t v15;
  unsigned int v16;
  int v17;
  size_t v18;
  unsigned __int8 *v19;
  int v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  char *v32;
  char *v33;
  unsigned __int8 **v34;
  int v35;
  uint64_t *j;
  _QWORD *v37;
  uint64_t v39;
  _QWORD *v40;
  size_t v41;
  void *v42;
  uint64_t v43;
  unsigned int v44;
  int v45;
  size_t v46;
  unsigned __int8 *v47;
  int v48;
  unsigned int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  char *v60;
  char *v61;
  int v62;
  uint64_t *i;
  _QWORD *v64;
  unint64_t v66;
  _BYTE *v67;
  _BYTE *v68;
  _BYTE *v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  char *v74;
  char *v75;
  char *v76;
  __int128 v77;
  _DWORD *v78;
  uint64_t v79;
  char *v80;
  unint64_t first_not_of;
  unint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  _OWORD *v86;
  BOOL v88;
  _BOOL4 v89;
  uint64_t **v90;
  uint64_t v92;
  uint64_t **v93;
  _OWORD *v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  uint64_t v98;
  BOOL v100;
  void *v101;
  uint64_t v102;
  unint64_t v103;
  __int128 v104;
  unint64_t v105;
  uint64_t v106;
  unint64_t v107;
  unint64_t v108;
  uint64_t v109;
  BOOL (*RelocationResolver)(uint64_t);
  uint64_t v111;
  uint64_t v112;
  unint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  BOOL v117;
  uint64_t **v118;
  char *v119;
  char *v120;
  uint64_t v121;
  _DWORD *v122;
  void *v123;
  uint64_t v124;
  _DWORD *v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t **v129;
  uint64_t **v130;
  uint64_t **v131;
  uint64_t *v132;
  unint64_t v133;
  unint64_t v134;
  BOOL v135;
  _BOOL4 v136;
  _BOOL4 v137;
  unint64_t v138;
  unint64_t v139;
  _BOOL4 v140;
  _BOOL4 v141;
  __int128 v142;
  uint64_t *v143;
  int v144;
  char *v145;
  char *v146;
  uint64_t v147;
  uint64_t v148;
  void *v149;
  void *v150;
  void *v152;
  void *v153;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  char v158;
  char *v159;
  _OWORD *v160;
  int v161;
  unsigned int v162;
  __int128 v163;
  unint64_t v165;
  uint64_t v166;
  int Relocation;
  void *v169;
  uint64_t v170;
  unint64_t v172;
  BOOL v173;
  uint64_t v174;
  uint64_t v175;
  unint64_t v177;
  _QWORD *v178;
  void (**v179)(void);
  void (**v180)(void);
  void *result;
  _OWORD *v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t **v185;
  uint64_t **v186;
  char v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v196;
  _DWORD *v197;
  _QWORD *v198;
  unsigned __int8 **v199;
  unint64_t v200;
  unsigned __int8 **v201;
  _QWORD *v202;
  unsigned __int8 *__s1;
  unsigned __int8 *__s1a;
  char *v205;
  void *__p[2];
  __int128 v207;
  __int16 v208;
  uint64_t v209;
  __int128 v210;
  uint64_t **v211;
  uint64_t *v212;
  uint64_t v213;
  _QWORD v214[2];
  __int128 v215;
  char *v216;
  void *v217;
  __int128 v218;
  char *v219;
  uint64_t v220;
  __int128 v221;
  __int128 v222;
  __int128 v223;
  _QWORD *v224;
  uint64_t v225;
  uint64_t v226;
  char *v227;
  uint64_t v228;
  char *v229;
  uint64_t v230;
  _OWORD v231[2];
  __int16 v232;
  __int128 v233;
  const char *v234;
  __int128 *v235;
  __int16 v236;
  __int128 v237;
  char v238;
  uint64_t v239;
  char v240;
  uint64_t v241;

  v241 = *MEMORY[0x1E0C80C00];
  v8 = operator new();
  *(_QWORD *)(v8 + 16) = 0;
  *(_QWORD *)(v8 + 24) = 0;
  *(_QWORD *)v8 = &off_1E81699D0;
  *(_QWORD *)(v8 + 8) = 0;
  *(_BYTE *)(v8 + 32) = (a1[2] > 0x13u) | (0x553FFu >> a1[2]) & 1;
  *(_BYTE *)(v8 + 33) = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)a1 + 360))(a1);
  *(_OWORD *)(v8 + 40) = *((_OWORD *)a1 + 2);
  *(_QWORD *)(v8 + 56) = a1;
  *(_QWORD *)(v8 + 64) = 0;
  v198 = (_QWORD *)(v8 + 64);
  *(_QWORD *)(v8 + 96) = 0;
  *(_QWORD *)(v8 + 88) = v8 + 96;
  v186 = (uint64_t **)(v8 + 88);
  *(_QWORD *)(v8 + 72) = 0;
  *(_QWORD *)(v8 + 80) = 0;
  *(_QWORD *)(v8 + 104) = 0;
  *(_QWORD *)(v8 + 112) = 0;
  *(_QWORD *)(v8 + 144) = 0;
  *(_QWORD *)(v8 + 136) = v8 + 144;
  v185 = (uint64_t **)(v8 + 136);
  *(_QWORD *)(v8 + 120) = 0;
  *(_QWORD *)(v8 + 128) = 0;
  *(_QWORD *)(v8 + 152) = 0;
  *(_QWORD *)(v8 + 160) = 0;
  *(_QWORD *)(v8 + 168) = 0;
  *(_QWORD *)(v8 + 176) = 0;
  *(_QWORD *)(v8 + 192) = 0;
  *(_QWORD *)(v8 + 184) = v8 + 192;
  v184 = v8 + 184;
  *(_QWORD *)(v8 + 240) = 0;
  *(_QWORD *)(v8 + 232) = v8 + 240;
  v183 = v8 + 232;
  *(_QWORD *)(v8 + 200) = 0;
  *(_QWORD *)(v8 + 208) = 0;
  *(_QWORD *)(v8 + 216) = 0;
  *(_QWORD *)(v8 + 224) = 0;
  *(_QWORD *)(v8 + 248) = 0;
  *(_OWORD *)(v8 + 328) = 0u;
  *(_OWORD *)(v8 + 344) = 0u;
  *(_OWORD *)(v8 + 356) = 0u;
  *(_OWORD *)(v8 + 404) = 0u;
  *(_OWORD *)(v8 + 376) = 0u;
  *(_OWORD *)(v8 + 392) = 0u;
  *(_OWORD *)(v8 + 452) = 0u;
  *(_OWORD *)(v8 + 424) = 0u;
  *(_OWORD *)(v8 + 440) = 0u;
  *(_OWORD *)(v8 + 500) = 0u;
  *(_OWORD *)(v8 + 472) = 0u;
  *(_OWORD *)(v8 + 488) = 0u;
  *(_OWORD *)(v8 + 548) = 0u;
  *(_OWORD *)(v8 + 520) = 0u;
  *(_OWORD *)(v8 + 536) = 0u;
  *(_OWORD *)(v8 + 596) = 0u;
  *(_OWORD *)(v8 + 568) = 0u;
  *(_OWORD *)(v8 + 584) = 0u;
  *(_OWORD *)(v8 + 644) = 0u;
  *(_OWORD *)(v8 + 616) = 0u;
  *(_OWORD *)(v8 + 632) = 0u;
  *(_OWORD *)(v8 + 664) = 0u;
  *(_OWORD *)(v8 + 680) = 0u;
  *(_OWORD *)(v8 + 692) = 0u;
  *(_OWORD *)(v8 + 740) = 0u;
  *(_OWORD *)(v8 + 712) = 0u;
  *(_OWORD *)(v8 + 728) = 0u;
  *(_OWORD *)(v8 + 788) = 0u;
  *(_OWORD *)(v8 + 760) = 0u;
  *(_OWORD *)(v8 + 776) = 0u;
  *(_OWORD *)(v8 + 836) = 0u;
  *(_OWORD *)(v8 + 808) = 0u;
  *(_OWORD *)(v8 + 824) = 0u;
  *(_OWORD *)(v8 + 932) = 0u;
  *(_OWORD *)(v8 + 904) = 0u;
  *(_OWORD *)(v8 + 920) = 0u;
  *(_OWORD *)(v8 + 980) = 0u;
  *(_OWORD *)(v8 + 952) = 0u;
  *(_OWORD *)(v8 + 968) = 0u;
  *(_OWORD *)(v8 + 1028) = 0u;
  *(_OWORD *)(v8 + 1000) = 0u;
  *(_OWORD *)(v8 + 1016) = 0u;
  *(_OWORD *)(v8 + 1076) = 0u;
  *(_OWORD *)(v8 + 1048) = 0u;
  *(_OWORD *)(v8 + 1064) = 0u;
  *(_OWORD *)(v8 + 1124) = 0u;
  *(_OWORD *)(v8 + 1096) = 0u;
  *(_OWORD *)(v8 + 1112) = 0u;
  *(_OWORD *)(v8 + 1172) = 0u;
  *(_OWORD *)(v8 + 1144) = 0u;
  *(_OWORD *)(v8 + 1160) = 0u;
  *(_OWORD *)(v8 + 1220) = 0u;
  *(_OWORD *)(v8 + 1192) = 0u;
  *(_OWORD *)(v8 + 1208) = 0u;
  *(_OWORD *)(v8 + 1268) = 0u;
  *(_OWORD *)(v8 + 1240) = 0u;
  *(_OWORD *)(v8 + 1256) = 0u;
  *(_OWORD *)(v8 + 1316) = 0u;
  *(_OWORD *)(v8 + 1288) = 0u;
  *(_OWORD *)(v8 + 1304) = 0u;
  *(_OWORD *)(v8 + 1364) = 0u;
  *(_OWORD *)(v8 + 1336) = 0u;
  *(_OWORD *)(v8 + 1352) = 0u;
  *(_OWORD *)(v8 + 1412) = 0u;
  *(_OWORD *)(v8 + 1384) = 0u;
  *(_OWORD *)(v8 + 1400) = 0u;
  *(_OWORD *)(v8 + 1460) = 0u;
  *(_OWORD *)(v8 + 1432) = 0u;
  *(_OWORD *)(v8 + 1448) = 0u;
  *(_OWORD *)(v8 + 256) = 0u;
  *(_OWORD *)(v8 + 272) = 0u;
  *(_OWORD *)(v8 + 288) = 0u;
  *(_OWORD *)(v8 + 304) = 0u;
  v202 = (_QWORD *)v8;
  *(_DWORD *)(v8 + 320) = 0;
  *(_OWORD *)(v8 + 884) = 0u;
  *(_OWORD *)(v8 + 856) = 0u;
  *(_OWORD *)(v8 + 872) = 0u;
  v182 = (_OWORD *)(v8 + 856);
  *(_OWORD *)(v8 + 1688) = 0u;
  *(_OWORD *)(v8 + 1704) = 0u;
  *(_OWORD *)(v8 + 1656) = 0u;
  *(_OWORD *)(v8 + 1672) = 0u;
  *(_OWORD *)(v8 + 1624) = 0u;
  *(_OWORD *)(v8 + 1640) = 0u;
  *(_OWORD *)(v8 + 1592) = 0u;
  *(_OWORD *)(v8 + 1608) = 0u;
  *(_OWORD *)(v8 + 1560) = 0u;
  *(_OWORD *)(v8 + 1576) = 0u;
  *(_OWORD *)(v8 + 1528) = 0u;
  *(_OWORD *)(v8 + 1544) = 0u;
  *(_OWORD *)(v8 + 1496) = 0u;
  *(_OWORD *)(v8 + 1512) = 0u;
  *(_OWORD *)(v8 + 1480) = 0u;
  v224 = 0;
  v225 = 0;
  v226 = 0x1000000000;
  v9 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)a1 + 344))(a1);
  v11 = v10;
  v197 = a1;
  v196 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)a1 + 352))(a1);
  *(_QWORD *)&v223 = v9;
  *((_QWORD *)&v223 + 1) = v11;
  v200 = v12;
  if (v11 != v12 || v9 != v196)
  {
    v192 = 0;
    do
    {
      v222 = 0uLL;
      (*(void (**)(_OWORD *__return_ptr, uint64_t, uint64_t))(*(_QWORD *)v11 + 136))(v231, v11, v9);
      if ((v231[1] & 1) != 0)
      {
        v42 = *(void **)&v231[0];
        *(_QWORD *)&v231[0] = 0;
        __p[0] = v42;
        sub_1C4D62BD4((char **)__p, (char **)&v233);
        if (__p[0])
          (*(void (**)(void *))(*(_QWORD *)__p[0] + 8))(__p[0]);
        if ((v231[1] & 1) != 0)
        {
          v43 = *(_QWORD *)&v231[0];
          *(_QWORD *)&v231[0] = 0;
          if (v43)
            (*(void (**)(uint64_t))(*(_QWORD *)v43 + 8))(v43);
        }
        __s1a = 0;
        v41 = 0;
      }
      else
      {
        v222 = v231[0];
        v41 = *((_QWORD *)&v231[0] + 1);
        __s1a = *(unsigned __int8 **)&v231[0];
      }
      v44 = v225;
      if (!(_DWORD)v225)
      {
        v225 = 0;
        LODWORD(v226) = 0;
        v64 = malloc_type_calloc(0x11uLL, 0xCuLL, 0x6D9A4F0CuLL);
        if (!v64)
LABEL_332:
          llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
        v64[16] = 2;
        v224 = v64;
        v44 = 16;
        LODWORD(v225) = 16;
      }
      v45 = 0;
      if (v41)
      {
        v46 = v41;
        v47 = __s1a;
        do
        {
          v48 = *v47++;
          v45 = 33 * v45 + v48;
          --v46;
        }
        while (v46);
      }
      v49 = v44 - 1;
      v50 = (uint64_t)v224;
      v51 = (uint64_t)&v224[v44 + 1];
      v52 = HIDWORD(v226);
      v53 = -1;
      v54 = 1;
      v55 = v45;
      while (1)
      {
        v56 = v55 & v49;
        v57 = *(_QWORD *)(v50 + 8 * v56);
        if (!v57)
          break;
        if (v57 == -8)
        {
          if (v53 == -1)
            v53 = v55 & v49;
        }
        else if (*(_DWORD *)(v51 + 4 * v56) == v45
               && v41 == *(_QWORD *)v57
               && (!v41 || !memcmp(__s1a, (const void *)(v57 + v52), v41)))
        {
          goto LABEL_72;
        }
        v55 = v54 + v56;
        ++v54;
      }
      v58 = v53;
      if (v53 == -1)
      {
        v58 = v56;
        v56 = v56;
      }
      else
      {
        v56 = v53;
      }
      *(_DWORD *)(v51 + 4 * v58) = v45;
      v57 = *(_QWORD *)(v50 + 8 * v56);
LABEL_72:
      if (v57)
      {
        if (v57 != -8)
          goto LABEL_85;
        LODWORD(v226) = v226 - 1;
      }
      v59 = (char *)operator new(v41 + 17, (std::align_val_t)8uLL);
      v60 = v59;
      v61 = v59 + 16;
      if (v41)
        memcpy(v59 + 16, __s1a, v41);
      v61[v41] = 0;
      *(_QWORD *)v60 = v41;
      *((_DWORD *)v60 + 2) = 0;
      *(_QWORD *)(v50 + 8 * v56) = v60;
      ++HIDWORD(v225);
      v62 = llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)&v224, v56);
      for (i = &v224[v62]; ; ++i)
      {
        v57 = *i;
        if (*i && v57 != -8)
          break;
      }
LABEL_85:
      ++*(_DWORD *)(v57 + 8);
      v67 = (_BYTE *)v202[9];
      v66 = v202[10];
      if ((unint64_t)v67 >= v66)
      {
        v69 = (_BYTE *)*v198;
        v70 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v67[-*v198] >> 3);
        v71 = v70 + 1;
        if (v70 + 1 > 0xAAAAAAAAAAAAAAALL)
          abort();
        v72 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v66 - (_QWORD)v69) >> 3);
        if (2 * v72 > v71)
          v71 = 2 * v72;
        if (v72 >= 0x555555555555555)
          v73 = 0xAAAAAAAAAAAAAAALL;
        else
          v73 = v71;
        if (v73)
        {
          if (v73 > 0xAAAAAAAAAAAAAAALL)
            sub_1C4764EE4();
          v74 = (char *)operator new(24 * v73);
        }
        else
        {
          v74 = 0;
        }
        v75 = &v74[24 * v70];
        *(_OWORD *)v75 = v222;
        v75[16] = 1;
        v76 = v75;
        if (v67 != v69)
        {
          do
          {
            v77 = *(_OWORD *)(v67 - 24);
            *(v76 - 8) = *(v67 - 8);
            *(_OWORD *)(v76 - 24) = v77;
            v76 -= 24;
            v67 -= 24;
          }
          while (v67 != v69);
          v67 = (_BYTE *)*v198;
        }
        v68 = v75 + 24;
        v202[8] = v76;
        v202[9] = v75 + 24;
        v202[10] = &v74[24 * v73];
        if (v67)
          operator delete(v67);
      }
      else
      {
        *(_OWORD *)v67 = v222;
        v67[16] = 1;
        v68 = v67 + 24;
      }
      v202[9] = v68;
      if (((*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)&v223 + 1) + 208))(*((_QWORD *)&v223 + 1), v223) & 1) != 0
        || ((*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)&v223 + 1) + 216))(*((_QWORD *)&v223 + 1), v223) & 1) != 0
        || ((*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)&v223 + 1) + 232))(*((_QWORD *)&v223 + 1), v223) & 1) != 0)
      {
        goto LABEL_298;
      }
      v221 = 0uLL;
      (*(void (**)(__int128 *__return_ptr, _QWORD, _QWORD))(**((_QWORD **)&v223 + 1) + 280))(&v237, *((_QWORD *)&v223 + 1), v223);
      v78 = v197;
      if ((v238 & 1) != 0)
      {
        *(_QWORD *)&v231[0] = "failed to get relocated section: ";
        v232 = 259;
        v119 = (char *)v237;
        *(_QWORD *)&v237 = 0;
        v219 = v119;
        sub_1C548DD2C(&v220, (uint64_t *)v231, &v219);
        *(_QWORD *)&v233 = v220;
        v220 = 0;
        sub_1C624E09C((uint64_t)a5, &v233);
        if ((_QWORD)v233)
          (*(void (**)(_QWORD))(*(_QWORD *)v233 + 8))(v233);
        v120 = v219;
        if (!v219)
          goto LABEL_295;
LABEL_294:
        (*(void (**)(char *))(*(_QWORD *)v120 + 8))(v120);
        goto LABEL_295;
      }
      if ((*(unsigned int (**)(_DWORD *))(*(_QWORD *)v197 + 424))(v197))
      {
        v218 = v237;
      }
      else
      {
        *(_QWORD *)&v218 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v197 + 352))(v197);
        *((_QWORD *)&v218 + 1) = v79;
      }
      if (!a3
        || ((*(uint64_t (**)(uint64_t, __int128 *, __int128 *))(*(_QWORD *)a3 + 24))(a3, &v218, &v221) & 1) == 0)
      {
        (*(void (**)(_OWORD *__return_ptr, _QWORD, _QWORD))(**((_QWORD **)&v223 + 1) + 168))(v231, *((_QWORD *)&v223 + 1), v223);
        if ((v231[1] & 1) != 0)
        {
          *(_QWORD *)&v233 = *(_QWORD *)&v231[0];
          sub_1C4D62BD4((char **)&v233, (char **)v231);
          if ((_QWORD)v233)
            (*(void (**)(_QWORD))(*(_QWORD *)v233 + 8))(v233);
          v78 = v197;
        }
        else
        {
          v221 = v231[0];
        }
      }
      if (llvm::object::Decompressor::isCompressed(&v223))
      {
        llvm::object::Decompressor::create((uint64_t)v231);
        if ((BYTE8(v231[1]) & 1) == 0)
        {
          *((_QWORD *)&v233 + 1) = 0;
          v234 = 0;
          *(_QWORD *)&v233 = &v235;
          result = llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v233, &v235, *(unint64_t *)&v231[1], 1);
          __break(1u);
          return result;
        }
        v80 = *(char **)&v231[0];
        if (*(_QWORD *)&v231[0])
        {
          v236 = 1283;
          *(_QWORD *)&v233 = "failed to decompress '";
          v234 = (const char *)__s1a;
          v235 = (__int128 *)v41;
          *(_QWORD *)&v231[0] = &v233;
          *(_QWORD *)&v231[1] = "', ";
          v232 = 770;
          v216 = v80;
          sub_1C548DD2C((uint64_t *)&v217, (uint64_t *)v231, &v216);
          __p[0] = v217;
          v217 = 0;
          sub_1C624E09C((uint64_t)a5, __p);
          if (__p[0])
            (*(void (**)(void *))(*(_QWORD *)__p[0] + 8))(__p[0]);
          v120 = v216;
          if (!v216)
            goto LABEL_295;
          goto LABEL_294;
        }
      }
      first_not_of = llvm::StringRef::find_first_not_of(&v222, "._z", 3, 0);
      if (v41 >= first_not_of)
        v82 = first_not_of;
      else
        v82 = v41;
      v83 = (*(uint64_t (**)(_DWORD *, unsigned __int8 *, size_t))(*(_QWORD *)v78 + 416))(v78, &__s1a[v82], v41 - v82);
      v85 = v84;
      *(_QWORD *)&v222 = v83;
      *((_QWORD *)&v222 + 1) = v84;
      v86 = (_OWORD *)sub_1C548DE78((uint64_t)v202, v83, v84);
      if (v86)
      {
        *v86 = v221;
        if (v85 == 8)
        {
          if (*(_QWORD *)v83 != 0x656D6172665F6865)
            goto LABEL_149;
        }
        else
        {
          if (v85 != 11)
          {
            if (v85 == 12 && *(_QWORD *)v83 == 0x61725F6775626564 && *(_DWORD *)(v83 + 8) == 1936025454)
              *v182 = v221;
            goto LABEL_149;
          }
          if (*(_QWORD *)v83 != 0x72665F6775626564 || *(_QWORD *)(v83 + 3) != 0x656D6172665F6775)
            goto LABEL_149;
        }
        v92 = sub_1C548E188((uint64_t)v202, v83, v85);
        if (v92)
          *(_QWORD *)(v92 + 16) = (*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)&v223 + 1) + 144))(*((_QWORD *)&v223 + 1), v223);
      }
      else
      {
        switch(v85)
        {
          case 10:
            v88 = (*(_QWORD *)v83 ^ 0x6E695F6775626564 | *(unsigned __int16 *)(v83 + 8) ^ 0x6F66) == 0;
            v89 = v88;
            v90 = v186;
            goto LABEL_143;
          case 11:
            v88 = (*(_QWORD *)v83 ^ 0x79745F6775626564 | *(_QWORD *)(v83 + 3) ^ 0x73657079745F6775) == 0;
            v89 = v88;
            v90 = v185;
            goto LABEL_143;
          case 14:
            v88 = (*(_QWORD *)v83 ^ 0x6E695F6775626564 | *(_QWORD *)(v83 + 6) ^ 0x6F77642E6F666E69) == 0;
            v89 = v88;
            v90 = (uint64_t **)v184;
            goto LABEL_143;
          case 15:
            v88 = (*(_QWORD *)v83 ^ 0x79745F6775626564 | *(_QWORD *)(v83 + 7) ^ 0x6F77642E73657079) == 0;
            v89 = v88;
            v90 = (uint64_t **)v183;
LABEL_143:
            if (v88)
              v93 = v90;
            else
              v93 = 0;
            if (v89 && v93)
            {
              v94 = (_OWORD *)sub_1C548E760(v93, &v223);
              *v94 = v221;
            }
            break;
          default:
            break;
        }
      }
LABEL_149:
      v95 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v197 + 352))(v197);
      if (v218 != __PAIR128__(v96, v95) && llvm::StringRef::find((uint64_t *)&v222, ".dwo", 4uLL, 0) != -1)
      {
        v232 = 1283;
        *(_QWORD *)&v231[0] = "Unexpected relocations for dwo section ";
        *(_QWORD *)&v231[1] = v83;
        *((_QWORD *)&v231[1] + 1) = v85;
        v175 = operator new();
        if (!atomic_load(qword_1EF8F7238))
          llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EF8F7238, (void *(*)(void))sub_1C59D0934, (void (*)(void *))sub_1C59D0968);
        v177 = qword_1EF8F7238[0];
        *(_QWORD *)v175 = off_1E81A0C88;
        llvm::Twine::str((llvm::Twine *)v231, (_QWORD *)(v175 + 8));
        *(_QWORD *)(v175 + 32) = 3;
        *(_QWORD *)(v175 + 40) = v177;
        *(_BYTE *)(v175 + 48) = 1;
        *(_QWORD *)&v233 = v175;
        sub_1C624E09C((uint64_t)a6, &v233);
        if ((_QWORD)v233)
          (*(void (**)(_QWORD))(*(_QWORD *)v233 + 8))(v233);
      }
      v97 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v197 + 352))(v197);
      v100 = *((_QWORD *)&v218 + 1) == v98 && (_QWORD)v218 == v97;
      if (a2 == 1 || v100)
        goto LABEL_295;
      v215 = 0uLL;
      (*(void (**)(_OWORD *__return_ptr))(**((_QWORD **)&v218 + 1) + 136))(v231);
      if ((v231[1] & 1) != 0)
      {
        v101 = *(void **)&v231[0];
        *(_QWORD *)&v231[0] = 0;
        __p[0] = v101;
        sub_1C4D62BD4((char **)__p, (char **)&v233);
        if (__p[0])
          (*(void (**)(void *))(*(_QWORD *)__p[0] + 8))(__p[0]);
        if ((v231[1] & 1) != 0)
        {
          v102 = *(_QWORD *)&v231[0];
          *(_QWORD *)&v231[0] = 0;
          if (v102)
            (*(void (**)(uint64_t))(*(_QWORD *)v102 + 8))(v102);
        }
      }
      else
      {
        v215 = v231[0];
      }
      v214[0] = 0;
      v214[1] = 0;
      if (a3)
      {
        if (((*(uint64_t (**)(uint64_t, __int128 *, _QWORD *))(*(_QWORD *)a3 + 24))(a3, &v218, v214) & 1) != 0)
          goto LABEL_295;
      }
      else if ((v197[2] & 0xFFFFFFFC) == 0x10)
      {
        goto LABEL_295;
      }
      v103 = llvm::StringRef::find_first_not_of(&v215, "._z", 3, 0);
      v104 = v215;
      if (*((_QWORD *)&v215 + 1) >= v103)
        v105 = v103;
      else
        v105 = *((_QWORD *)&v215 + 1);
      v106 = v215 + v105;
      v107 = *((_QWORD *)&v215 + 1) - v105;
      *(_QWORD *)&v215 = v215 + v105;
      *((_QWORD *)&v215 + 1) = *((_QWORD *)&v104 + 1) - v105;
      v108 = sub_1C548E188((uint64_t)v202, v104 + v105, *((_QWORD *)&v104 + 1) - v105);
      if (!v108)
      {
        if (v107 == 11)
        {
          v173 = *(_QWORD *)v106 == 0x79745F6775626564 && *(_QWORD *)(v106 + 3) == 0x73657079745F6775;
          v118 = v185;
          if (!v173)
            goto LABEL_295;
        }
        else
        {
          if (v107 != 10)
            goto LABEL_295;
          v117 = *(_QWORD *)v106 == 0x6E695F6775626564 && *(_WORD *)(v106 + 8) == 28518;
          v118 = v186;
          if (!v117)
            goto LABEL_295;
        }
        v108 = sub_1C548E760(v118, &v218);
      }
      v109 = (*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)&v223 + 1) + 264))(*((_QWORD *)&v223 + 1), v223);
      if (v109 != (*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)&v223 + 1) + 272))(*((_QWORD *)&v223 + 1), v223))
      {
        v212 = 0;
        v213 = 0;
        v211 = &v212;
        RelocationResolver = llvm::object::getRelocationResolver(v197);
        v112 = v111;
        v113 = (*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)&v223 + 1) + 264))(*((_QWORD *)&v223 + 1), v223);
        v115 = v114;
        v116 = (*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)&v223 + 1) + 272))(*((_QWORD *)&v223 + 1), v223);
        *(_QWORD *)&v210 = v113;
        *((_QWORD *)&v210 + 1) = v115;
        if (v113 == v116)
        {
LABEL_176:
          sub_1C49F3440(v212);
          goto LABEL_295;
        }
        v121 = v116;
        v122 = v197;
        while (2)
        {
          if ((v122[2] & 0xFFFFFFFC) == 0x10)
          {
            Relocation = llvm::object::MachOObjectFile::getRelocation((uint64_t)v122, v113);
            if (v122[13] != 16777223 && Relocation < 0)
            {
LABEL_258:
              (*(void (**)(_QWORD, __int128 *))(**((_QWORD **)&v210 + 1) + 288))(*((_QWORD *)&v210 + 1), &v210);
              v113 = v210;
              if ((_QWORD)v210 == v121)
                goto LABEL_176;
              continue;
            }
          }
          break;
        }
        __p[0] = (void *)(*(uint64_t (**)(_DWORD *))(*(_QWORD *)v122 + 352))(v122);
        __p[1] = v123;
        v124 = (*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)&v210 + 1) + 304))(*((_QWORD *)&v210 + 1), v210);
        v125 = v122;
        v127 = v126;
        if (v124 == (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v125 + 56))(v125))
        {
          if ((v125[2] & 0xFFFFFFFC) == 0x10)
          {
            *(_QWORD *)&v231[0] = llvm::object::MachOObjectFile::getRelocation((uint64_t)v125, v210);
            __p[0] = (void *)llvm::object::MachOObjectFile::getAnyRelocationSection(v125, v231);
            __p[1] = v169;
            v128 = (*(uint64_t (**)(void *, void *))(*(_QWORD *)v169 + 144))(v169, __p[0]);
          }
          else
          {
            v128 = 0;
          }
          v129 = &v212;
          goto LABEL_230;
        }
        *(_QWORD *)&v231[0] = v124;
        *((_QWORD *)&v231[0] + 1) = v127;
        v231[1] = 0uLL;
        v130 = &v212;
        v131 = &v212;
        v132 = v212;
        if (v212)
        {
          while (1)
          {
            while (1)
            {
              v130 = (uint64_t **)v132;
              v133 = bswap64(*(unint64_t *)&v231[0]);
              v134 = bswap64((unint64_t)v130[4]);
              v135 = v133 >= v134;
              v136 = v133 > v134;
              v137 = !v135;
              if (v136 - v137 >= 0)
                break;
              v132 = *v130;
              v131 = v130;
              if (!*v130)
                goto LABEL_209;
            }
            v138 = bswap64((unint64_t)v130[4]);
            v139 = bswap64(*(unint64_t *)&v231[0]);
            v135 = v138 >= v139;
            v140 = v138 > v139;
            v141 = !v135;
            if (v140 - v141 >= 0)
              break;
            v132 = v130[1];
            if (!v132)
            {
              v131 = v130 + 1;
              goto LABEL_209;
            }
          }
          v128 = (uint64_t)v130[6];
          v193 = (uint64_t)v130[7];
          v122 = v197;
LABEL_246:
          v192 = 0;
          v194 = v128;
          if (RelocationResolver)
          {
LABEL_247:
            v156 = (*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)&v210 + 1) + 312))(*((_QWORD *)&v210 + 1), v210);
            if (((unsigned int (*)(uint64_t))RelocationResolver)(v156))
            {
              v157 = (*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)&v210 + 1) + 296))(*((_QWORD *)&v210 + 1), v210);
              v233 = v210;
              memset(v231, 0, sizeof(v231));
              __p[0] = 0;
              v158 = sub_1C548F1BC(*(_QWORD *)(v108 + 24), *(_DWORD *)(v108 + 40), v157, __p);
              v159 = (char *)__p[0];
              if ((v158 & 1) != 0)
              {
                v160 = (char *)__p[0] + 40;
                if (!*((_BYTE *)__p[0] + 56))
                  goto LABEL_250;
                *(_QWORD *)&v231[0] = "At most two relocations per offset are supported";
                v232 = 259;
                v170 = operator new();
                if (!atomic_load(qword_1EF8F7238))
                  llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EF8F7238, (void *(*)(void))sub_1C59D0934, (void (*)(void *))sub_1C59D0968);
                v172 = qword_1EF8F7238[0];
                *(_QWORD *)v170 = off_1E81A0C88;
                llvm::Twine::str((llvm::Twine *)v231, (_QWORD *)(v170 + 8));
                *(_QWORD *)(v170 + 32) = 3;
                *(_QWORD *)(v170 + 40) = v172;
                *(_BYTE *)(v170 + 48) = 1;
                *(_QWORD *)&v233 = v170;
                sub_1C624E09C((uint64_t)a5, &v233);
                if ((_QWORD)v233)
                  (*(void (**)(_QWORD))(*(_QWORD *)v233 + 8))(v233);
                if (v159[56])
                {
                  *v160 = v210;
                }
                else
                {
LABEL_250:
                  *v160 = v210;
                  v159[56] = 1;
                }
                *((_QWORD *)v159 + 8) = v194;
LABEL_257:
                v122 = v197;
                goto LABEL_258;
              }
              v161 = *(_DWORD *)(v108 + 32);
              v162 = *(_DWORD *)(v108 + 40);
              if (4 * v161 + 4 >= 3 * v162)
              {
                v162 *= 2;
              }
              else if (v162 + ~v161 - *(_DWORD *)(v108 + 36) > v162 >> 3)
              {
LABEL_254:
                ++*(_DWORD *)(v108 + 32);
                if (*(_QWORD *)v159 != -1)
                  --*(_DWORD *)(v108 + 36);
                *(_QWORD *)v159 = v157;
                *((_QWORD *)v159 + 1) = v193;
                *((_OWORD *)v159 + 1) = v233;
                *((_QWORD *)v159 + 4) = v194;
                v163 = v231[1];
                *(_OWORD *)(v159 + 40) = v231[0];
                *(_OWORD *)(v159 + 56) = v163;
                *((_QWORD *)v159 + 9) = v112;
                goto LABEL_257;
              }
              sub_1C548F254(v108 + 24, v162);
              __p[0] = 0;
              sub_1C548F1BC(*(_QWORD *)(v108 + 24), *(_DWORD *)(v108 + 40), v157, __p);
              v159 = (char *)__p[0];
              goto LABEL_254;
            }
          }
        }
        else
        {
LABEL_209:
          v129 = (uint64_t **)operator new(0x40uLL);
          v142 = v231[1];
          *((_OWORD *)v129 + 2) = v231[0];
          *((_OWORD *)v129 + 3) = v142;
          *v129 = 0;
          v129[1] = 0;
          v129[2] = (uint64_t *)v130;
          *v131 = (uint64_t *)v129;
          v143 = (uint64_t *)v129;
          if (*v211)
          {
            v211 = (uint64_t **)*v211;
            v143 = *v131;
          }
          sub_1C4768E74(v212, v143);
          ++v213;
          (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(_QWORD *)v127 + 80))(&v239, v127, v124);
          if ((v240 & 1) != 0)
          {
            *(_QWORD *)&v231[0] = "failed to compute symbol address: ";
            v232 = 259;
            v145 = (char *)v239;
            v239 = 0;
            v229 = v145;
            sub_1C548DD2C(&v230, (uint64_t *)v231, &v229);
            v194 = v230;
            v230 = 0;
            if (v229)
              (*(void (**)(char *))(*(_QWORD *)v229 + 8))(v229);
            v128 = 0;
            v192 = 1;
            v144 = 1;
          }
          else
          {
            (*(void (**)(__int128 *__return_ptr, uint64_t, uint64_t))(*(_QWORD *)v127 + 120))(&v233, v127, v124);
            if ((v234 & 1) != 0)
            {
              *(_QWORD *)&v231[0] = "failed to get symbol section: ";
              v232 = 259;
              v146 = (char *)v233;
              *(_QWORD *)&v233 = 0;
              v227 = v146;
              sub_1C548DD2C(&v228, (uint64_t *)v231, &v227);
              v194 = v228;
              v228 = 0;
              if (v227)
                (*(void (**)(char *))(*(_QWORD *)v227 + 8))(v227);
              if ((v234 & 1) != 0)
              {
                v147 = v233;
                *(_QWORD *)&v233 = 0;
                if (v147)
                  (*(void (**)(uint64_t))(*(_QWORD *)v147 + 8))(v147);
              }
              v128 = 0;
              v144 = 1;
              v192 = 1;
            }
            else
            {
              v144 = 0;
              *(_OWORD *)__p = v233;
              v128 = v239;
            }
          }
          if ((v240 & 1) != 0)
          {
            v148 = v239;
            v239 = 0;
            if (v148)
              (*(void (**)(uint64_t))(*(_QWORD *)v148 + 8))(v148);
          }
          if (!v144)
          {
LABEL_230:
            v122 = v197;
            v149 = (void *)(*(uint64_t (**)(_DWORD *))(*(_QWORD *)v197 + 352))(v197);
            if (__p[1] == v150 && __p[0] == v149)
              v193 = -1;
            else
              v193 = (*(uint64_t (**)(void))(*(_QWORD *)__p[1] + 152))();
            if (a3)
            {
              v152 = (void *)(*(uint64_t (**)(_DWORD *))(*(_QWORD *)v197 + 352))(v197);
              if (__p[1] != v153 || __p[0] != v152)
              {
                v155 = (*(uint64_t (**)(uint64_t, void **))(*(_QWORD *)a3 + 16))(a3, __p);
                if (v155)
                  v128 = v155
                       + v128
                       - (*(uint64_t (**)(void *, void *))(*(_QWORD *)__p[1] + 144))(__p[1], __p[0]);
                v122 = v197;
              }
            }
            if (v129 != &v212)
            {
              v129[6] = (uint64_t *)v128;
              v129[7] = (uint64_t *)v193;
            }
            goto LABEL_246;
          }
          if ((v192 & 1) != 0)
          {
            *(_QWORD *)&v231[0] = v194;
            sub_1C624E09C((uint64_t)a5, v231);
            if (*(_QWORD *)&v231[0])
              (*(void (**)(_QWORD))(**(_QWORD **)&v231[0] + 8))(*(_QWORD *)&v231[0]);
            v194 = 0;
            goto LABEL_257;
          }
          v122 = v197;
          if (RelocationResolver)
            goto LABEL_247;
        }
        *(_QWORD *)&v231[0] = (char *)&v231[1] + 8;
        *(_OWORD *)((char *)v231 + 8) = xmmword_1C677F680;
        (*(void (**)(_QWORD, _QWORD, _OWORD *))(**((_QWORD **)&v210 + 1) + 320))(*((_QWORD *)&v210 + 1), v210, v231);
        v208 = 1283;
        __p[0] = "failed to compute relocation: ";
        v207 = v231[0];
        *(_QWORD *)&v233 = __p;
        v234 = ", ";
        v236 = 770;
        if (!atomic_load(qword_1EF8F7238))
          llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EF8F7238, (void *(*)(void))sub_1C59D0934, (void (*)(void *))sub_1C59D0968);
        v165 = qword_1EF8F7238[0];
        v166 = operator new();
        *(_QWORD *)v166 = &off_1E81A0D28;
        *(_QWORD *)(v166 + 8) = 3;
        *(_QWORD *)(v166 + 16) = v165;
        v205 = (char *)v166;
        sub_1C548DD2C(&v209, (uint64_t *)&v233, &v205);
        v239 = v209;
        v209 = 0;
        sub_1C624E09C((uint64_t)a6, &v239);
        if (v239)
          (*(void (**)(uint64_t))(*(_QWORD *)v239 + 8))(v239);
        if (v205)
          (*(void (**)(char *))(*(_QWORD *)v205 + 8))(v205);
        if (*(_OWORD **)&v231[0] != (_OWORD *)((char *)&v231[1] + 8))
          free(*(void **)&v231[0]);
        goto LABEL_258;
      }
LABEL_295:
      if ((v238 & 1) != 0)
      {
        v174 = v237;
        *(_QWORD *)&v237 = 0;
        if (v174)
          (*(void (**)(uint64_t))(*(_QWORD *)v174 + 8))(v174);
      }
LABEL_298:
      (*(void (**)(_QWORD, __int128 *))(**((_QWORD **)&v223 + 1) + 128))(*((_QWORD *)&v223 + 1), &v223);
      v11 = *((_QWORD *)&v223 + 1);
      v9 = v223;
    }
    while (v223 != __PAIR128__(v200, v196));
  }
  v14 = (unsigned __int8 **)v202[8];
  v13 = (unsigned __int8 **)v202[9];
  v199 = v13;
  while (v14 != v13)
  {
    v15 = (size_t)v14[1];
    __s1 = *v14;
    v16 = v225;
    if (!(_DWORD)v225)
    {
      v225 = 0;
      LODWORD(v226) = 0;
      v37 = malloc_type_calloc(0x11uLL, 0xCuLL, 0x6D9A4F0CuLL);
      if (!v37)
        goto LABEL_332;
      v37[16] = 2;
      v224 = v37;
      v16 = 16;
      LODWORD(v225) = 16;
    }
    v201 = v14;
    v17 = 0;
    if (v15)
    {
      v18 = v15;
      v19 = __s1;
      do
      {
        v20 = *v19++;
        v17 = 33 * v17 + v20;
        --v18;
      }
      while (v18);
    }
    v21 = v16 - 1;
    v22 = (uint64_t)v224;
    v23 = (uint64_t)&v224[v16 + 1];
    v24 = HIDWORD(v226);
    v25 = -1;
    v26 = 1;
    v27 = v17;
    while (1)
    {
      v28 = v27 & v21;
      v29 = *(_QWORD *)(v22 + 8 * v28);
      if (!v29)
        break;
      if (v29 == -8)
      {
        if (v25 == -1)
          v25 = v27 & v21;
      }
      else if (*(_DWORD *)(v23 + 4 * v28) == v17
             && v15 == *(_QWORD *)v29
             && (!v15 || !memcmp(__s1, (const void *)(v29 + v24), v15)))
      {
        goto LABEL_24;
      }
      v27 = v26 + v28;
      ++v26;
    }
    v30 = v25;
    if (v25 == -1)
    {
      v30 = v28;
      v28 = v28;
    }
    else
    {
      v28 = v25;
    }
    *(_DWORD *)(v23 + 4 * v30) = v17;
    v29 = *(_QWORD *)(v22 + 8 * v28);
LABEL_24:
    if (v29)
    {
      if (v29 != -8)
      {
        v34 = v201;
        goto LABEL_37;
      }
      LODWORD(v226) = v226 - 1;
    }
    v31 = (char *)operator new(v15 + 17, (std::align_val_t)8uLL);
    v32 = v31;
    v33 = v31 + 16;
    v34 = v201;
    if (v15)
      memcpy(v31 + 16, __s1, v15);
    v33[v15] = 0;
    *(_QWORD *)v32 = v15;
    *((_DWORD *)v32 + 2) = 0;
    *(_QWORD *)(v22 + 8 * v28) = v32;
    ++HIDWORD(v225);
    v35 = llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)&v224, v28);
    for (j = &v224[v35]; ; ++j)
    {
      v29 = *j;
      if (*j && v29 != -8)
        break;
    }
LABEL_37:
    if (*(_DWORD *)(v29 + 8) >= 2u)
      *((_BYTE *)v34 + 16) = 0;
    v14 = v34 + 3;
    v13 = v199;
  }
  sub_1C51838C8((uint64_t)&v224);
  v39 = operator new();
  v224 = v202;
  *(_OWORD *)__p = *(_OWORD *)a4;
  *(_QWORD *)&v207 = *(_QWORD *)(a4 + 16);
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  *(_QWORD *)(a4 + 16) = 0;
  v40 = (_QWORD *)a5[3];
  if (v40)
  {
    if (v40 == a5)
    {
      *((_QWORD *)&v231[1] + 1) = v231;
      (*(void (**)(_QWORD *, _OWORD *))(*a5 + 24))(a5, v231);
    }
    else
    {
      *((_QWORD *)&v231[1] + 1) = (*(uint64_t (**)(_QWORD *))(*v40 + 16))(v40);
    }
  }
  else
  {
    *((_QWORD *)&v231[1] + 1) = 0;
  }
  v178 = (_QWORD *)a6[3];
  if (v178)
  {
    if (v178 == a6)
    {
      v235 = &v233;
      (*(void (**)(_QWORD *, __int128 *))(*a6 + 24))(a6, &v233);
    }
    else
    {
      v235 = (__int128 *)(*(uint64_t (**)(_QWORD *))(*v178 + 16))(v178);
    }
  }
  else
  {
    v235 = 0;
  }
  llvm::DWARFContext::DWARFContext(v39, (uint64_t *)&v224, (__int128 *)__p, (uint64_t)v231, (uint64_t)&v233);
  *a7 = v39;
  if (v235 == &v233)
  {
    v179 = (void (**)(void))(v233 + 32);
LABEL_319:
    (*v179)();
  }
  else if (v235)
  {
    v179 = (void (**)(void))(*(_QWORD *)v235 + 40);
    goto LABEL_319;
  }
  if (*((_OWORD **)&v231[1] + 1) == v231)
  {
    v180 = (void (**)(void))(*(_QWORD *)&v231[0] + 32);
LABEL_324:
    (*v180)();
  }
  else if (*((_QWORD *)&v231[1] + 1))
  {
    v180 = (void (**)(void))(**((_QWORD **)&v231[1] + 1) + 40);
    goto LABEL_324;
  }
  if (SBYTE7(v207) < 0)
    operator delete(__p[0]);
  result = v224;
  if (v224)
    return (void *)(*(uint64_t (**)(_QWORD *))(*v224 + 8))(v224);
  return result;
}

uint64_t llvm::DWARFContext::create@<X0>(uint64_t a1@<X0>, char a2@<W2>, _QWORD *a3@<X3>, _QWORD *a4@<X4>, uint64_t *a5@<X8>)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t *i;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  BOOL v20;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t **v25;
  uint64_t v27;
  uint64_t v29;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  void (**v36)(void);
  void (**v37)(void);
  uint64_t result;
  __int128 __p;
  char v43;
  uint64_t v44;
  _QWORD v45[3];
  _QWORD *v46;
  __int128 v47;
  __int128 *v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  v7 = operator new();
  *(_QWORD *)(v7 + 16) = 0;
  *(_QWORD *)(v7 + 24) = 0;
  *(_QWORD *)v7 = &off_1E81699D0;
  *(_QWORD *)(v7 + 8) = 0;
  *(_BYTE *)(v7 + 32) = a2;
  *(_QWORD *)(v7 + 96) = 0;
  *(_QWORD *)(v7 + 88) = v7 + 96;
  *(_OWORD *)(v7 + 40) = 0u;
  *(_OWORD *)(v7 + 56) = 0u;
  *(_OWORD *)(v7 + 72) = 0u;
  *(_QWORD *)(v7 + 104) = 0;
  *(_QWORD *)(v7 + 112) = 0;
  *(_QWORD *)(v7 + 144) = 0;
  *(_QWORD *)(v7 + 136) = v7 + 144;
  *(_QWORD *)(v7 + 192) = 0;
  *(_QWORD *)(v7 + 120) = 0;
  *(_QWORD *)(v7 + 128) = 0;
  *(_QWORD *)(v7 + 184) = v7 + 192;
  *(_QWORD *)(v7 + 152) = 0;
  *(_QWORD *)(v7 + 160) = 0;
  *(_QWORD *)(v7 + 168) = 0;
  *(_QWORD *)(v7 + 176) = 0;
  *(_QWORD *)(v7 + 240) = 0;
  *(_QWORD *)(v7 + 232) = v7 + 240;
  *(_QWORD *)(v7 + 200) = 0;
  *(_QWORD *)(v7 + 208) = 0;
  *(_QWORD *)(v7 + 216) = 0;
  *(_QWORD *)(v7 + 224) = 0;
  *(_QWORD *)(v7 + 248) = 0;
  *(_DWORD *)(v7 + 320) = 0;
  *(_OWORD *)(v7 + 288) = 0u;
  *(_OWORD *)(v7 + 304) = 0u;
  *(_OWORD *)(v7 + 256) = 0u;
  *(_OWORD *)(v7 + 272) = 0u;
  *(_OWORD *)(v7 + 356) = 0u;
  *(_OWORD *)(v7 + 328) = 0u;
  *(_OWORD *)(v7 + 344) = 0u;
  *(_OWORD *)(v7 + 404) = 0u;
  *(_OWORD *)(v7 + 376) = 0u;
  *(_OWORD *)(v7 + 392) = 0u;
  *(_OWORD *)(v7 + 452) = 0u;
  *(_OWORD *)(v7 + 424) = 0u;
  *(_OWORD *)(v7 + 440) = 0u;
  *(_OWORD *)(v7 + 500) = 0u;
  *(_OWORD *)(v7 + 472) = 0u;
  *(_OWORD *)(v7 + 488) = 0u;
  *(_OWORD *)(v7 + 548) = 0u;
  *(_OWORD *)(v7 + 520) = 0u;
  *(_OWORD *)(v7 + 536) = 0u;
  *(_OWORD *)(v7 + 596) = 0u;
  *(_OWORD *)(v7 + 568) = 0u;
  *(_OWORD *)(v7 + 584) = 0u;
  *(_OWORD *)(v7 + 644) = 0u;
  *(_OWORD *)(v7 + 616) = 0u;
  *(_OWORD *)(v7 + 632) = 0u;
  *(_OWORD *)(v7 + 692) = 0u;
  *(_OWORD *)(v7 + 664) = 0u;
  *(_OWORD *)(v7 + 680) = 0u;
  *(_OWORD *)(v7 + 740) = 0u;
  *(_OWORD *)(v7 + 712) = 0u;
  *(_OWORD *)(v7 + 728) = 0u;
  *(_OWORD *)(v7 + 788) = 0u;
  *(_OWORD *)(v7 + 760) = 0u;
  *(_OWORD *)(v7 + 776) = 0u;
  *(_OWORD *)(v7 + 836) = 0u;
  *(_OWORD *)(v7 + 808) = 0u;
  *(_OWORD *)(v7 + 824) = 0u;
  *(_OWORD *)(v7 + 884) = 0u;
  *(_OWORD *)(v7 + 856) = 0u;
  *(_OWORD *)(v7 + 872) = 0u;
  *(_OWORD *)(v7 + 932) = 0u;
  *(_OWORD *)(v7 + 904) = 0u;
  *(_OWORD *)(v7 + 920) = 0u;
  *(_OWORD *)(v7 + 980) = 0u;
  *(_OWORD *)(v7 + 952) = 0u;
  *(_OWORD *)(v7 + 968) = 0u;
  *(_OWORD *)(v7 + 1028) = 0u;
  *(_OWORD *)(v7 + 1000) = 0u;
  *(_OWORD *)(v7 + 1016) = 0u;
  *(_OWORD *)(v7 + 1076) = 0u;
  *(_OWORD *)(v7 + 1048) = 0u;
  *(_OWORD *)(v7 + 1064) = 0u;
  *(_OWORD *)(v7 + 1124) = 0u;
  *(_OWORD *)(v7 + 1096) = 0u;
  *(_OWORD *)(v7 + 1112) = 0u;
  *(_OWORD *)(v7 + 1172) = 0u;
  *(_OWORD *)(v7 + 1144) = 0u;
  *(_OWORD *)(v7 + 1160) = 0u;
  *(_OWORD *)(v7 + 1220) = 0u;
  *(_OWORD *)(v7 + 1192) = 0u;
  *(_OWORD *)(v7 + 1208) = 0u;
  *(_OWORD *)(v7 + 1268) = 0u;
  *(_OWORD *)(v7 + 1240) = 0u;
  *(_OWORD *)(v7 + 1256) = 0u;
  *(_OWORD *)(v7 + 1316) = 0u;
  *(_OWORD *)(v7 + 1288) = 0u;
  *(_OWORD *)(v7 + 1304) = 0u;
  *(_OWORD *)(v7 + 1364) = 0u;
  *(_OWORD *)(v7 + 1336) = 0u;
  *(_OWORD *)(v7 + 1352) = 0u;
  *(_OWORD *)(v7 + 1412) = 0u;
  *(_OWORD *)(v7 + 1384) = 0u;
  *(_OWORD *)(v7 + 1400) = 0u;
  *(_OWORD *)(v7 + 1460) = 0u;
  *(_OWORD *)(v7 + 1432) = 0u;
  *(_OWORD *)(v7 + 1448) = 0u;
  *(_OWORD *)(v7 + 1688) = 0u;
  *(_OWORD *)(v7 + 1704) = 0u;
  *(_OWORD *)(v7 + 1656) = 0u;
  *(_OWORD *)(v7 + 1672) = 0u;
  *(_OWORD *)(v7 + 1624) = 0u;
  *(_OWORD *)(v7 + 1640) = 0u;
  *(_OWORD *)(v7 + 1592) = 0u;
  *(_OWORD *)(v7 + 1608) = 0u;
  *(_OWORD *)(v7 + 1560) = 0u;
  *(_OWORD *)(v7 + 1576) = 0u;
  *(_OWORD *)(v7 + 1528) = 0u;
  *(_OWORD *)(v7 + 1544) = 0u;
  *(_OWORD *)(v7 + 1496) = 0u;
  *(_OWORD *)(v7 + 1512) = 0u;
  *(_OWORD *)(v7 + 1480) = 0u;
  v8 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v8)
  {
    for (i = *(uint64_t **)a1; !*i || *i == -8; ++i)
      ;
  }
  else
  {
    i = *(uint64_t **)a1;
  }
  v11 = *(_QWORD *)a1 + 8 * v8;
  if (i != (uint64_t *)v11)
  {
    v12 = *i;
    do
    {
      v13 = (_QWORD *)(v12 + 16);
      v14 = *(_QWORD *)v12;
      v15 = (_QWORD *)sub_1C548DE78(v7, v12 + 16, *(_QWORD *)v12);
      if (v15)
      {
        v16 = *(_QWORD *)(v12 + 8);
        v17 = *(_QWORD *)(v16 + 8);
        v18 = *(_QWORD *)(v16 + 16) - v17;
        *v15 = v17;
        v15[1] = v18;
      }
      else
      {
        switch(v14)
        {
          case 10:
            if (*v13 == 0x6E695F6775626564 && *(_WORD *)(v12 + 24) == 28518)
            {
              v22 = *(_QWORD *)(v12 + 8);
              v23 = *(_QWORD *)(v22 + 8);
              v24 = *(_QWORD *)(v22 + 16) - v23;
              v47 = 0uLL;
              v25 = (uint64_t **)(v7 + 88);
              goto LABEL_45;
            }
            break;
          case 11:
            if (*v13 == 0x79745F6775626564 && *(_QWORD *)(v12 + 19) == 0x73657079745F6775)
            {
              v27 = *(_QWORD *)(v12 + 8);
              v23 = *(_QWORD *)(v27 + 8);
              v24 = *(_QWORD *)(v27 + 16) - v23;
              v47 = 0uLL;
              v25 = (uint64_t **)(v7 + 136);
              goto LABEL_45;
            }
            break;
          case 14:
            if (*v13 == 0x6E695F6775626564 && *(_QWORD *)(v12 + 22) == 0x6F77642E6F666E69)
            {
              v29 = *(_QWORD *)(v12 + 8);
              v23 = *(_QWORD *)(v29 + 8);
              v24 = *(_QWORD *)(v29 + 16) - v23;
              v47 = 0uLL;
              v25 = (uint64_t **)(v7 + 184);
              goto LABEL_45;
            }
            break;
          case 15:
            if (*v13 == 0x79745F6775626564 && *(_QWORD *)(v12 + 23) == 0x6F77642E73657079)
            {
              v31 = *(_QWORD *)(v12 + 8);
              v23 = *(_QWORD *)(v31 + 8);
              v24 = *(_QWORD *)(v31 + 16) - v23;
              v47 = 0uLL;
              v25 = (uint64_t **)(v7 + 232);
LABEL_45:
              v32 = (_QWORD *)sub_1C548E760(v25, &v47);
              *v32 = v23;
              v32[1] = v24;
            }
            break;
          default:
            goto LABEL_14;
        }
      }
      do
      {
LABEL_14:
        v19 = i[1];
        ++i;
        v12 = v19;
        if (v19)
          v20 = v12 == -8;
        else
          v20 = 1;
      }
      while (v20);
    }
    while (i != (uint64_t *)v11);
  }
  v33 = operator new();
  v44 = v7;
  v43 = 0;
  LOBYTE(__p) = 0;
  v34 = (_QWORD *)a3[3];
  if (v34)
  {
    if (v34 == a3)
    {
      v48 = &v47;
      (*(void (**)(_QWORD *, __int128 *))(*a3 + 24))(a3, &v47);
    }
    else
    {
      v48 = (__int128 *)(*(uint64_t (**)(_QWORD *))(*v34 + 16))(v34);
    }
  }
  else
  {
    v48 = 0;
  }
  v35 = (_QWORD *)a4[3];
  if (v35)
  {
    if (v35 == a4)
    {
      v46 = v45;
      (*(void (**)(_QWORD *, _QWORD *))(*a4 + 24))(a4, v45);
    }
    else
    {
      v46 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v35 + 16))(v35);
    }
  }
  else
  {
    v46 = 0;
  }
  llvm::DWARFContext::DWARFContext(v33, &v44, &__p, (uint64_t)&v47, (uint64_t)v45);
  *a5 = v33;
  if (v46 == v45)
  {
    v36 = (void (**)(void))(v45[0] + 32);
  }
  else
  {
    if (!v46)
      goto LABEL_61;
    v36 = (void (**)(void))(*v46 + 40);
  }
  (*v36)();
LABEL_61:
  if (v48 == &v47)
  {
    v37 = (void (**)(void))(v47 + 32);
  }
  else
  {
    if (!v48)
      goto LABEL_66;
    v37 = (void (**)(void))(*(_QWORD *)v48 + 40);
  }
  (*v37)();
LABEL_66:
  if (v43 < 0)
    operator delete((void *)__p);
  result = v44;
  if (v44)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v44 + 8))(v44);
  return result;
}

void llvm::DWARFContext::loadRegisterInfo(llvm::DWARFContext *this@<X0>, const llvm::object::ObjectFile *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v5;
  char *ArchName;
  uint64_t v7;
  char *VendorTypeName;
  uint64_t v9;
  char *OSTypeName;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  const std::error_category *v14;
  _BYTE *p_p;
  void **v16;
  uint64_t v17;
  uint64_t (*v18)(void **);
  uint64_t v19;
  uint64_t v20;
  void *__p;
  uint64_t v22;
  uint64_t v23;
  void *v24[2];
  __int128 v25;
  __int128 v26;
  _BYTE *v27;
  uint64_t v28[2];

  v25 = 0u;
  v26 = 0u;
  *(_OWORD *)v24 = 0u;
  v5 = (*(uint64_t (**)(const llvm::object::ObjectFile *))(*(_QWORD *)a2 + 376))(a2);
  ArchName = llvm::Triple::getArchName(v5, v5, 0);
  llvm::Triple::setArchName((llvm::Triple *)v24, ArchName, v7);
  VendorTypeName = llvm::Triple::getVendorTypeName(0);
  llvm::Triple::setVendorName((llvm::Triple *)v24, (uint64_t)VendorTypeName, v9);
  OSTypeName = llvm::Triple::getOSTypeName(0);
  llvm::Triple::setOSName((llvm::Triple *)v24, (uint64_t)OSTypeName, v11);
  __p = 0;
  v22 = 0;
  v23 = 0;
  v12 = llvm::TargetRegistry::lookupTarget((std::string::size_type)v24, (uint64_t)&__p);
  v13 = HIBYTE(v23) & 0x7F;
  if (v23 < 0)
    v13 = v22;
  if (v13)
  {
    v14 = std::generic_category();
    if (v23 >= 0)
      p_p = &__p;
    else
      p_p = __p;
    v28[0] = 22;
    v28[1] = (uint64_t)v14;
    v27 = p_p;
    sub_1C5DF1730(&v27, v28, a3);
  }
  else
  {
    if ((SBYTE7(v25) & 0x80u) == 0)
      v16 = v24;
    else
      v16 = (void **)v24[0];
    if ((SBYTE7(v25) & 0x80u) == 0)
      v17 = BYTE7(v25) & 0x7F;
    else
      v17 = (uint64_t)v24[1];
    v18 = sub_1C511F97C((uint64_t)v12, (uint64_t)v16, v17);
    v19 = *((_QWORD *)this + 56);
    *((_QWORD *)this + 56) = v18;
    if (v19)
    {
      v20 = sub_1C61E6B14(v19);
      MEMORY[0x1CAA32FC0](v20, 0x10F0C4031312594);
    }
    *a3 = 0;
  }
  if (SHIBYTE(v23) < 0)
    operator delete(__p);
  if (SBYTE7(v25) < 0)
    operator delete(v24[0]);
}

uint64_t sub_1C548BC00@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;

  result = llvm::DWARFContext::parseNormalUnits(a1);
  v5 = *(_QWORD *)(a1 + 16);
  v6 = *(_DWORD *)(a1 + 72);
  if (v6 == -1)
    v6 = *(_DWORD *)(a1 + 24);
  v7 = v5 + 8 * v6;
  if (v6)
  {
    v8 = 8 * v6;
    while ((*(_BYTE *)(*(_QWORD *)v5 + 96) & 0xFB) == 2)
    {
      v5 += 8;
      v8 -= 8;
      if (!v8)
      {
        v5 = v7;
        break;
      }
    }
  }
  *a2 = v5;
  a2[1] = v7;
  a2[2] = sub_1C548D3BC;
  a2[3] = v7;
  a2[4] = v7;
  a2[5] = sub_1C548D3BC;
  return result;
}

_QWORD *sub_1C548BC80(uint64_t a1, llvm::raw_ostream *a2, __int128 *a3)
{
  uint64_t v5;
  _BYTE *v6;
  _BYTE v8[448];
  _BYTE __src[448];
  _QWORD v10[12];

  v5 = 0;
  v10[11] = *MEMORY[0x1E0C80C00];
  do
  {
    v6 = &__src[v5];
    *v6 = 0;
    v6[8] = 0;
    v5 += 16;
  }
  while (v5 != 448);
  sub_1C624C4A4((uint64_t)v10, a3);
  memcpy(v8, __src, sizeof(v8));
  llvm::DWARFContext::dump(a1, a2, (llvm::raw_ostream *)v10, (uint64_t)v8);
  return sub_1C624C568(v10);
}

void sub_1C548BD34(void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = (char *)*((_QWORD *)v4 - 16);
        if (v4 - 112 != v6)
          free(v6);
        v4 -= 144;
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t **sub_1C548BDB0(uint64_t **a1, _QWORD *a2)
{
  uint64_t *v3;
  _QWORD *v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t *v10;
  BOOL v11;
  uint64_t **v12;
  uint64_t **v13;
  unint64_t v14;
  _OWORD *v15;
  uint64_t *v16;
  uint64_t *v17;
  _QWORD *v18;
  _QWORD *v19;

  a1[1] = 0;
  v3 = (uint64_t *)(a1 + 1);
  a1[2] = 0;
  *a1 = (uint64_t *)(a1 + 1);
  v4 = a2 + 1;
  v5 = (_QWORD *)*a2;
  if ((_QWORD *)*a2 != a2 + 1)
  {
    do
    {
      v6 = v5[4];
      v7 = a1[1];
      v8 = v3;
      if (*a1 == v3)
        goto LABEL_8;
      v9 = a1[1];
      v10 = v3;
      if (v7)
      {
        do
        {
          v8 = v9;
          v9 = (uint64_t *)v9[1];
        }
        while (v9);
      }
      else
      {
        do
        {
          v8 = (uint64_t *)v10[2];
          v11 = *v8 == (_QWORD)v10;
          v10 = v8;
        }
        while (v11);
      }
      if (v8[4] < v6)
      {
LABEL_8:
        if (v7)
          v12 = (uint64_t **)v8;
        else
          v12 = (uint64_t **)v3;
        if (v7)
          v13 = (uint64_t **)(v8 + 1);
        else
          v13 = (uint64_t **)v3;
        if (*v13)
          goto LABEL_27;
      }
      else
      {
        v13 = (uint64_t **)v3;
        v12 = (uint64_t **)v3;
        if (v7)
        {
          while (1)
          {
            while (1)
            {
              v12 = (uint64_t **)v7;
              v14 = v7[4];
              if (v14 <= v6)
                break;
              v7 = *v12;
              v13 = v12;
              if (!*v12)
                goto LABEL_23;
            }
            if (v14 >= v6)
              goto LABEL_27;
            v7 = v12[1];
            if (!v7)
            {
              v13 = v12 + 1;
              break;
            }
          }
        }
      }
LABEL_23:
      v15 = operator new(0x30uLL);
      v15[2] = *((_OWORD *)v5 + 2);
      *(_QWORD *)v15 = 0;
      *((_QWORD *)v15 + 1) = 0;
      *((_QWORD *)v15 + 2) = v12;
      *v13 = (uint64_t *)v15;
      v16 = (uint64_t *)**a1;
      if (v16)
      {
        *a1 = v16;
        v17 = *v13;
      }
      else
      {
        v17 = (uint64_t *)v15;
      }
      sub_1C4768E74(a1[1], v17);
      a1[2] = (uint64_t *)((char *)a1[2] + 1);
LABEL_27:
      v18 = (_QWORD *)v5[1];
      if (v18)
      {
        do
        {
          v19 = v18;
          v18 = (_QWORD *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          v19 = (_QWORD *)v5[2];
          v11 = *v19 == (_QWORD)v5;
          v5 = v19;
        }
        while (!v11);
      }
      v5 = v19;
    }
    while (v19 != v4);
  }
  return a1;
}

void sub_1C548BF38(char **a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t *a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X6>, uint64_t *a7@<X8>)
{
  __int128 v13;
  unint64_t v14;
  char *v15;
  __int128 v16;
  __int128 v17;
  char *v18;
  char *v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  char *v24;
  char *v25;
  __int128 v26;
  char *v27;
  __int128 v28;
  __int128 v29;
  const std::error_category *v30;
  void **v31;
  uint64_t v32;
  const std::error_category *v33;
  uint64_t v34;
  void **v35;
  uint64_t v36;
  _OWORD v38[2];
  uint64_t v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;
  char v43;
  uint64_t v44;
  int v45;
  void **p_p;
  void *__p;
  uint64_t v48;
  uint64_t v49;
  void **v50;
  const char *v51;
  uint64_t v52;
  uint64_t v53;
  __int16 v54;

  if (*a4 < a3 || (unint64_t)*a4 >= *(_QWORD *)(a2 + 8))
  {
    v33 = std::generic_category();
    __p = 0;
    v48 = 0;
    v49 = 0;
    DWORD2(v40) = 0;
    v43 = 0;
    v44 = 0;
    *(_QWORD *)&v40 = &unk_1E81A7208;
    p_p = &__p;
    v45 = 0;
    v42 = 0;
    v41 = 0uLL;
    v34 = *a4;
    v50 = (void **)&unk_1E8169B68;
    v51 = "invalid %s list offset 0x%llx";
    v52 = a6;
    v53 = v34;
    llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v40, (uint64_t)&v50);
    v35 = p_p;
    v36 = operator new();
    v54 = 260;
    v50 = v35;
    *(_QWORD *)v36 = off_1E81A0C88;
    llvm::Twine::str((llvm::Twine *)&v50, (_QWORD *)(v36 + 8));
    *(_QWORD *)(v36 + 32) = 22;
    *(_QWORD *)(v36 + 40) = v33;
    *(_BYTE *)(v36 + 48) = 1;
    *a7 = v36;
LABEL_26:
    *(_QWORD *)&v40 = off_1E81A6E70;
    if (v45 == 1 && (_QWORD)v41)
      MEMORY[0x1CAA32F9C](v41, 0x1000C8077774924);
    if (SHIBYTE(v49) < 0)
      operator delete(__p);
  }
  else
  {
    a1[1] = *a1;
    while (1)
    {
      v13 = *(_OWORD *)(a2 + 16);
      v38[0] = *(_OWORD *)a2;
      v38[1] = v13;
      v39 = *(_QWORD *)(a2 + 32);
      llvm::RangeListEntry::extract((uint64_t)&v40, (uint64_t)v38, a4, a7);
      if (*a7)
        break;
      v15 = a1[1];
      v14 = (unint64_t)a1[2];
      if ((unint64_t)v15 >= v14)
      {
        v19 = *a1;
        v20 = 0xCCCCCCCCCCCCCCCDLL * ((v15 - *a1) >> 3);
        v21 = v20 + 1;
        if (v20 + 1 > 0x666666666666666)
          abort();
        v22 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v14 - (_QWORD)v19) >> 3);
        if (2 * v22 > v21)
          v21 = 2 * v22;
        if (v22 >= 0x333333333333333)
          v23 = 0x666666666666666;
        else
          v23 = v21;
        if (v23)
        {
          if (v23 > 0x666666666666666)
            sub_1C4764EE4();
          v24 = (char *)operator new(40 * v23);
        }
        else
        {
          v24 = 0;
        }
        v25 = &v24[40 * v20];
        v26 = v41;
        *(_OWORD *)v25 = v40;
        *((_OWORD *)v25 + 1) = v26;
        *((_QWORD *)v25 + 4) = v42;
        v27 = v25;
        if (v15 != v19)
        {
          do
          {
            v28 = *(_OWORD *)(v15 - 40);
            v29 = *(_OWORD *)(v15 - 24);
            *((_QWORD *)v27 - 1) = *((_QWORD *)v15 - 1);
            *(_OWORD *)(v27 - 24) = v29;
            *(_OWORD *)(v27 - 40) = v28;
            v27 -= 40;
            v15 -= 40;
          }
          while (v15 != v19);
          v15 = *a1;
        }
        v18 = v25 + 40;
        *a1 = v27;
        a1[1] = v25 + 40;
        a1[2] = &v24[40 * v23];
        if (v15)
          operator delete(v15);
      }
      else
      {
        v16 = v40;
        v17 = v41;
        *((_QWORD *)v15 + 4) = v42;
        *(_OWORD *)v15 = v16;
        *((_OWORD *)v15 + 1) = v17;
        v18 = v15 + 40;
      }
      a1[1] = v18;
      if (!BYTE8(v40))
      {
        *a7 = 0;
        return;
      }
      if (*(_QWORD *)(a2 + 8) <= (unint64_t)*a4)
      {
        v30 = std::generic_category();
        __p = 0;
        v48 = 0;
        v49 = 0;
        DWORD2(v40) = 0;
        v43 = 0;
        v44 = 0;
        *(_QWORD *)&v40 = &unk_1E81A7208;
        p_p = &__p;
        v45 = 0;
        v42 = 0;
        v41 = 0uLL;
        v50 = (void **)&unk_1E8169B68;
        v51 = "no end of list marker detected at end of %s table starting at offset 0x%llx";
        v52 = a5;
        v53 = a3;
        llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v40, (uint64_t)&v50);
        v31 = p_p;
        v32 = operator new();
        v54 = 260;
        v50 = v31;
        *(_QWORD *)v32 = off_1E81A0C88;
        llvm::Twine::str((llvm::Twine *)&v50, (_QWORD *)(v32 + 8));
        *(_QWORD *)(v32 + 32) = 92;
        *(_QWORD *)(v32 + 40) = v30;
        *(_BYTE *)(v32 + 48) = 1;
        *a7 = v32;
        goto LABEL_26;
      }
    }
  }
}

__n128 sub_1C548C300(uint64_t a1, __n128 *a2, uint64_t a3, char a4, __n128 result)
{
  __n128 *v9;
  unint64_t i;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  __int128 *v14;
  __n128 v15;
  __n128 v16;
  __n128 v17;
  __int128 v18;
  unint64_t v19;
  int v20;
  uint64_t v21;
  BOOL v22;
  unint64_t v23;
  __n128 *v24;
  __n128 *v25;
  int v26;
  __n128 *v28;
  int v29;
  __int128 *v32;
  __int128 v33;
  unint64_t v34;
  int v35;
  __int128 *v37;
  int v38;
  __int128 v40;
  BOOL v41;
  __n128 v42;
  int v43;
  unint64_t v44;
  int v45;
  __int128 *v46;
  unsigned __int8 *v47;
  int v48;
  __int128 v49;
  unint64_t v50;
  int v51;
  __int128 *v52;
  int v53;
  __int128 v54;
  BOOL v55;
  __n128 *v56;
  __n128 *v57;
  __n128 *v58;
  BOOL v59;
  __n128 *v60;
  BOOL v62;
  uint64_t v63;
  __n128 *v64;
  __n128 *v65;
  int v66;
  BOOL v67;
  unint64_t v68;
  __n128 v69;
  unint64_t v70;
  uint64_t v71;
  _OWORD *v72;
  unint64_t *v73;
  __int128 v74;
  int64_t v75;
  int64_t v76;
  int64_t v77;
  uint64_t v78;
  unint64_t v79;
  _BOOL4 v80;
  BOOL v81;
  unint64_t v82;
  int v83;
  BOOL v84;
  unint64_t v85;
  __int128 v86;
  unint64_t v87;
  uint64_t v88;
  uint64_t v89;
  _BOOL4 v90;
  BOOL v91;
  BOOL v92;
  __int128 v93;
  uint64_t v94;
  _OWORD *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  _BOOL4 v99;
  BOOL v100;
  __int128 v101;
  __n128 v102;
  uint64_t v103;
  unint64_t v104;
  unint64_t v105;
  unint64_t v106;
  BOOL v107;
  unint64_t v108;
  int v109;
  __int128 v110;
  unint64_t v111;
  unint64_t v112;
  BOOL v113;
  __int128 v114;
  __n128 v116;
  __n128 v117;
  uint64_t v118;
  int v119;
  BOOL v120;
  unint64_t v121;
  uint64_t v122;
  __int128 v123;
  __n128 v124;
  __int128 v125;
  __n128 v126;
  __int128 v127;
  __int128 v128;
  _BYTE v129[7];
  _BYTE v130[7];
  _BYTE v131[7];
  __n128 v132;
  __n128 v133;
  _BYTE v134[7];
  _BYTE v135[7];
  __n128 v136;
  _BYTE v137[7];
  __int128 v138;
  __int128 v139;
  __int128 v140;
  __n128 v141;
  __int128 v142;
  __n128 v143;
  __n128 v144;
  __n128 v145;
  __n128 v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  __n128 v150;
  __n128 v151;
  __n128 v152;
  __int128 v153;

__n128 sub_1C548CE94(__int128 *a1, __int128 *a2, __int128 *a3, __n128 result)
{
  BOOL v4;
  BOOL v5;
  __int128 v6;
  __int128 v7;
  BOOL v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;

  if (*((_BYTE *)a2 + 24))
    v4 = *((_BYTE *)a1 + 24) == 0;
  else
    v4 = 1;
  if (v4)
  {
    if (!*((_BYTE *)a1 + 24))
      goto LABEL_15;
LABEL_7:
    if (*((_BYTE *)a2 + 24))
      v5 = *((_BYTE *)a3 + 24) == 0;
    else
      v5 = 1;
    if (v5)
    {
      if (!*((_BYTE *)a2 + 24))
        goto LABEL_23;
    }
    else if (*(_QWORD *)a3 >= *(_QWORD *)a2)
    {
LABEL_23:
      v9 = *a1;
      result = (__n128)a1[1];
      v10 = a2[1];
      *a1 = *a2;
      a1[1] = v10;
      *a2 = v9;
      a2[1] = (__int128)result;
      if (*((_BYTE *)a3 + 24) && *((_BYTE *)a2 + 24))
      {
        if (*(_QWORD *)a3 >= *(_QWORD *)a2)
          return result;
      }
      else if (!*((_BYTE *)a2 + 24))
      {
        return result;
      }
      v6 = *a2;
      result = (__n128)a2[1];
      v13 = a3[1];
      *a2 = *a3;
      a2[1] = v13;
LABEL_34:
      *a3 = v6;
      a3[1] = (__int128)result;
      return result;
    }
    v6 = *a1;
    result = (__n128)a1[1];
    v7 = a3[1];
    *a1 = *a3;
    a1[1] = v7;
    goto LABEL_34;
  }
  if (*(_QWORD *)a2 < *(_QWORD *)a1)
    goto LABEL_7;
LABEL_15:
  if (*((_BYTE *)a2 + 24))
    v8 = *((_BYTE *)a3 + 24) == 0;
  else
    v8 = 1;
  if (v8)
  {
    if (!*((_BYTE *)a2 + 24))
      return result;
  }
  else if (*(_QWORD *)a3 >= *(_QWORD *)a2)
  {
    return result;
  }
  v11 = *a2;
  result = (__n128)a2[1];
  v12 = a3[1];
  *a2 = *a3;
  a2[1] = v12;
  *a3 = v11;
  a3[1] = (__int128)result;
  if (!*((_BYTE *)a2 + 24) || !*((_BYTE *)a1 + 24))
  {
    if (!*((_BYTE *)a1 + 24))
      return result;
    goto LABEL_36;
  }
  if (*(_QWORD *)a2 < *(_QWORD *)a1)
  {
LABEL_36:
    v14 = *a1;
    result = (__n128)a1[1];
    v15 = a2[1];
    *a1 = *a2;
    a1[1] = v15;
    *a2 = v14;
    a2[1] = (__int128)result;
  }
  return result;
}

BOOL sub_1C548CFB8(uint64_t a1, uint64_t a2, __n128 a3)
{
  uint64_t v5;
  _BOOL8 result;
  _QWORD *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  BOOL v14;
  unint64_t v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t *v20;
  __int128 v21;
  _QWORD *v22;
  _QWORD *v23;
  _QWORD *v24;
  _QWORD *v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  _BYTE v41[7];
  __int128 v42;

  v5 = (a2 - a1) >> 5;
  result = 1;
  switch(v5)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v7 = (_QWORD *)(a2 - 32);
      if (*(_BYTE *)(a2 - 8))
        v8 = *(_BYTE *)(a1 + 24) == 0;
      else
        v8 = 1;
      if (v8)
      {
        if (!*(_BYTE *)(a1 + 24))
          return result;
      }
      else if (*v7 >= *(_QWORD *)a1)
      {
        return result;
      }
      v27 = *(_OWORD *)a1;
      v26 = *(_OWORD *)(a1 + 16);
      v28 = *(_OWORD *)(a2 - 16);
      *(_OWORD *)a1 = *(_OWORD *)v7;
      *(_OWORD *)(a1 + 16) = v28;
      *(_OWORD *)v7 = v27;
      *(_OWORD *)(a2 - 16) = v26;
      return result;
    case 3:
      sub_1C548CE94((__int128 *)a1, (__int128 *)(a1 + 32), (__int128 *)(a2 - 32), a3);
      return 1;
    case 4:
      sub_1C548D2D4(a1, a1 + 32, a1 + 64, a2 - 32, a3);
      return 1;
    case 5:
      v22 = (_QWORD *)(a1 + 32);
      v23 = (_QWORD *)(a1 + 64);
      v24 = (_QWORD *)(a1 + 96);
      v25 = (_QWORD *)(a2 - 32);
      sub_1C548D2D4(a1, a1 + 32, a1 + 64, a1 + 96, a3);
      if (*(_BYTE *)(a2 - 8) && *(_BYTE *)(a1 + 120))
      {
        if (*v25 >= *v24)
          return 1;
      }
      else if (!*(_BYTE *)(a1 + 120))
      {
        return 1;
      }
      v30 = *(_OWORD *)v24;
      v29 = *(_OWORD *)(a1 + 112);
      v31 = *(_OWORD *)(a2 - 16);
      *(_OWORD *)v24 = *(_OWORD *)v25;
      *(_OWORD *)(a1 + 112) = v31;
      *(_OWORD *)v25 = v30;
      *(_OWORD *)(a2 - 16) = v29;
      if (*(_BYTE *)(a1 + 120) && *(_BYTE *)(a1 + 88))
      {
        if (*v24 >= *v23)
          return 1;
      }
      else if (!*(_BYTE *)(a1 + 88))
      {
        return 1;
      }
      v33 = *(_OWORD *)v23;
      v32 = *(_OWORD *)(a1 + 80);
      v34 = *(_OWORD *)(a1 + 112);
      *(_OWORD *)v23 = *(_OWORD *)v24;
      *(_OWORD *)(a1 + 80) = v34;
      *(_OWORD *)v24 = v33;
      *(_OWORD *)(a1 + 112) = v32;
      if (*(_BYTE *)(a1 + 88) && *(_BYTE *)(a1 + 56))
      {
        if (*v23 >= *v22)
          return 1;
      }
      else if (!*(_BYTE *)(a1 + 56))
      {
        return 1;
      }
      v36 = *(_OWORD *)v22;
      v35 = *(_OWORD *)(a1 + 48);
      v37 = *(_OWORD *)(a1 + 80);
      *(_OWORD *)v22 = *(_OWORD *)v23;
      *(_OWORD *)(a1 + 48) = v37;
      *(_OWORD *)v23 = v36;
      *(_OWORD *)(a1 + 80) = v35;
      if (*(_BYTE *)(a1 + 56) && *(_BYTE *)(a1 + 24))
      {
        if (*(_QWORD *)(a1 + 32) >= *(_QWORD *)a1)
          return 1;
      }
      else if (!*(_BYTE *)(a1 + 24))
      {
        return 1;
      }
      v39 = *(_OWORD *)a1;
      v38 = *(_OWORD *)(a1 + 16);
      v40 = *(_OWORD *)(a1 + 48);
      *(_OWORD *)a1 = *(_OWORD *)v22;
      *(_OWORD *)(a1 + 16) = v40;
      *(_OWORD *)v22 = v39;
      *(_OWORD *)(a1 + 48) = v38;
      return 1;
    default:
      v9 = a1 + 64;
      sub_1C548CE94((__int128 *)a1, (__int128 *)(a1 + 32), (__int128 *)(a1 + 64), a3);
      v10 = a1 + 96;
      if (a1 + 96 == a2)
        return 1;
      v11 = 0;
      v12 = 0;
      break;
  }
  do
  {
    v13 = *(unsigned __int8 *)(v10 + 24);
    if (*(_BYTE *)(v10 + 24))
      v14 = *(_BYTE *)(v9 + 24) == 0;
    else
      v14 = 1;
    if (v14)
    {
      if (!*(_BYTE *)(v9 + 24))
        goto LABEL_30;
      v15 = *(_QWORD *)v10;
    }
    else
    {
      v15 = *(_QWORD *)v10;
      if (*(_QWORD *)v10 >= *(_QWORD *)v9)
        goto LABEL_30;
    }
    v42 = *(_OWORD *)(v10 + 8);
    *(_DWORD *)v41 = *(_DWORD *)(v10 + 25);
    *(_DWORD *)&v41[3] = *(_DWORD *)(v10 + 28);
    v16 = *(_OWORD *)(v9 + 16);
    *(_OWORD *)v10 = *(_OWORD *)v9;
    *(_OWORD *)(v10 + 16) = v16;
    v17 = a1;
    if (v9 == a1)
      goto LABEL_29;
    v18 = v11;
    while (1)
    {
      v19 = a1 + v18;
      v20 = (unint64_t *)(a1 + v18 + 32);
      if (v13 && *(_BYTE *)(a1 + v18 + 56))
      {
        if (v15 >= *v20)
        {
          v17 = a1 + v18 + 64;
          goto LABEL_29;
        }
        goto LABEL_26;
      }
      if (!*(_BYTE *)(a1 + v18 + 56))
        break;
LABEL_26:
      v9 -= 32;
      v21 = *(_OWORD *)(a1 + v18 + 48);
      *(_OWORD *)(v19 + 64) = *(_OWORD *)v20;
      *(_OWORD *)(v19 + 80) = v21;
      v18 -= 32;
      if (v18 == -64)
      {
        v17 = a1;
        goto LABEL_29;
      }
    }
    v17 = v9;
LABEL_29:
    *(_QWORD *)v17 = v15;
    *(_OWORD *)(v17 + 8) = v42;
    *(_BYTE *)(v17 + 24) = v13;
    *(_DWORD *)(v17 + 25) = *(_DWORD *)v41;
    *(_DWORD *)(v17 + 28) = *(_DWORD *)&v41[3];
    if (++v12 == 8)
      return v10 + 32 == a2;
LABEL_30:
    v9 = v10;
    v11 += 32;
    v10 += 32;
  }
  while (v10 != a2);
  return 1;
}

__n128 sub_1C548D2D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __n128 a5)
{
  __n128 result;
  BOOL v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;

  result.n128_u64[0] = sub_1C548CE94((__int128 *)a1, (__int128 *)a2, (__int128 *)a3, a5).n128_u64[0];
  if (*(_BYTE *)(a4 + 24))
    v10 = *(_BYTE *)(a3 + 24) == 0;
  else
    v10 = 1;
  if (v10)
  {
    if (!*(_BYTE *)(a3 + 24))
      return result;
  }
  else if (*(_QWORD *)a4 >= *(_QWORD *)a3)
  {
    return result;
  }
  v11 = *(_OWORD *)a3;
  result = *(__n128 *)(a3 + 16);
  v12 = *(_OWORD *)(a4 + 16);
  *(_OWORD *)a3 = *(_OWORD *)a4;
  *(_OWORD *)(a3 + 16) = v12;
  *(_OWORD *)a4 = v11;
  *(__n128 *)(a4 + 16) = result;
  if (*(_BYTE *)(a3 + 24) && *(_BYTE *)(a2 + 24))
  {
    if (*(_QWORD *)a3 >= *(_QWORD *)a2)
      return result;
  }
  else if (!*(_BYTE *)(a2 + 24))
  {
    return result;
  }
  v13 = *(_OWORD *)a2;
  result = *(__n128 *)(a2 + 16);
  v14 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v14;
  *(_OWORD *)a3 = v13;
  *(__n128 *)(a3 + 16) = result;
  if (!*(_BYTE *)(a2 + 24) || !*(_BYTE *)(a1 + 24))
  {
    if (!*(_BYTE *)(a1 + 24))
      return result;
    goto LABEL_19;
  }
  if (*(_QWORD *)a2 < *(_QWORD *)a1)
  {
LABEL_19:
    v15 = *(_OWORD *)a1;
    result = *(__n128 *)(a1 + 16);
    v16 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_OWORD *)(a1 + 16) = v16;
    *(_OWORD *)a2 = v15;
    *(__n128 *)(a2 + 16) = result;
  }
  return result;
}

BOOL sub_1C548D3BC(uint64_t a1)
{
  return (*(_BYTE *)(*(_QWORD *)a1 + 96) & 0xFB) != 2;
}

unint64_t sub_1C548D3D4(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v7;
  unint64_t v9;

  v4 = *(unsigned int *)(a1 + 8);
  v5 = v4 + a3;
  if (v4 + a3 > (unint64_t)*(unsigned int *)(a1 + 12))
  {
    v7 = *(_QWORD *)a1 + 136 * v4;
    if (*(_QWORD *)a1 <= a2 && v7 > a2)
    {
      v9 = a2 - *(_QWORD *)a1;
      sub_1C548D43C(a1, v5);
      return *(_QWORD *)a1 + v9;
    }
    else
    {
      sub_1C548D43C(a1, v5);
    }
  }
  return a2;
}

void sub_1C548D43C(uint64_t a1, unint64_t a2)
{
  void *v3;
  int v4;
  unint64_t v5;

  v5 = 0;
  v3 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, a2, 136, &v5);
  sub_1C548D4A8((uint64_t *)a1, (uint64_t)v3);
  v4 = v5;
  if (*(_QWORD *)a1 != a1 + 16)
    free(*(void **)a1);
  *(_QWORD *)a1 = v3;
  *(_DWORD *)(a1 + 12) = v4;
}

void sub_1C548D4A8(uint64_t *a1, uint64_t a2)
{
  unsigned int v2;
  __int128 *v3;
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  __int128 *v12;
  uint64_t v13;
  uint64_t v14;

  v2 = *((_DWORD *)a1 + 2);
  if (v2)
  {
    v3 = (__int128 *)*a1;
    v4 = *a1 + 136 * v2;
    do
    {
      v5 = *v3;
      *(_QWORD *)(a2 + 16) = *((_QWORD *)v3 + 2);
      *(_OWORD *)a2 = v5;
      *((_QWORD *)v3 + 1) = 0;
      *((_QWORD *)v3 + 2) = 0;
      *(_QWORD *)v3 = 0;
      v6 = *(__int128 *)((char *)v3 + 24);
      *(_QWORD *)(a2 + 40) = *((_QWORD *)v3 + 5);
      *(_OWORD *)(a2 + 24) = v6;
      *((_QWORD *)v3 + 4) = 0;
      *((_QWORD *)v3 + 5) = 0;
      *((_QWORD *)v3 + 3) = 0;
      v7 = v3[3];
      *(_QWORD *)(a2 + 64) = *((_QWORD *)v3 + 8);
      *(_OWORD *)(a2 + 48) = v7;
      *((_QWORD *)v3 + 7) = 0;
      *((_QWORD *)v3 + 8) = 0;
      *((_QWORD *)v3 + 6) = 0;
      v8 = *(__int128 *)((char *)v3 + 72);
      v9 = *(__int128 *)((char *)v3 + 88);
      v10 = *(__int128 *)((char *)v3 + 104);
      *(_OWORD *)(a2 + 116) = *(__int128 *)((char *)v3 + 116);
      *(_OWORD *)(a2 + 104) = v10;
      *(_OWORD *)(a2 + 88) = v9;
      *(_OWORD *)(a2 + 72) = v8;
      v3 = (__int128 *)((char *)v3 + 136);
      a2 += 136;
    }
    while (v3 != (__int128 *)v4);
    v11 = *((unsigned int *)a1 + 2);
    if ((_DWORD)v11)
    {
      v12 = (__int128 *)*a1;
      v13 = 136 * v11;
      do
      {
        v14 = (uint64_t)v12 + v13;
        if (*((char *)v12 + v13 - 65) < 0)
          operator delete(*(void **)(v14 - 88));
        if (*(char *)(v14 - 89) < 0)
          operator delete(*(void **)((char *)v12 + v13 - 112));
        if (*((char *)v12 + v13 - 113) < 0)
          operator delete(*(void **)(v14 - 136));
        v13 -= 136;
      }
      while (v13);
    }
  }
}

void sub_1C548D5AC(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (a2)
  {
    v3 = a2 - 8;
    v2 = *(_QWORD *)(a2 - 8);
    if (v2)
    {
      v4 = 24 * v2;
      do
      {
        v5 = *(_QWORD *)(v3 + v4);
        *(_QWORD *)(v3 + v4) = 0;
        if (v5)
          MEMORY[0x1CAA32F9C](v5, 0x1000C8000313F17);
        v4 -= 24;
      }
      while (v4);
    }
    JUMPOUT(0x1CAA32F9CLL);
  }
}

char **sub_1C548D628(char **a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;

  v2 = *a1;
  v3 = *((unsigned int *)a1 + 2);
  if ((_DWORD)v3)
  {
    v4 = 24 * v3;
    do
    {
      v5 = *(char **)&v2[v4 - 16];
      if (&v2[v4] != v5)
        free(v5);
      v4 -= 24;
    }
    while (v4);
    v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2))
    free(v2);
  return a1;
}

uint64_t sub_1C548D698@<X0>(uint64_t *a1@<X0>, int a2@<W1>, _BYTE *a3@<X8>)
{
  uint64_t result;
  _QWORD v6[6];

  result = sub_1C548BC00(*a1, v6);
  if (v6[0] != v6[3])
    return llvm::DWARFUnit::getAddrOffsetSectionItem(*(_QWORD *)v6[0], a2, (uint64_t)a3);
  *a3 = 0;
  a3[16] = 0;
  return result;
}

_QWORD *sub_1C548D6F8(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  uint64_t v7;
  int v9;
  unsigned int v10;
  uint64_t v11;
  _QWORD *v12;
  int v13;
  BOOL v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  int v19;
  BOOL v20;
  unsigned int v21;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    sub_1C53061CC(a1, 2 * v6);
    v7 = *a2;
    v9 = *(_DWORD *)(a1 + 16) - 1;
    v10 = (37 * *a2) & v9;
    a3 = (_QWORD *)(*(_QWORD *)a1 + 16 * v10);
    v11 = *a3;
    if (*a2 != *a3)
    {
      v12 = 0;
      v13 = 1;
      while (v11 != -1)
      {
        if (v12)
          v14 = 0;
        else
          v14 = v11 == -2;
        if (v14)
          v12 = a3;
        v15 = v10 + v13++;
        v10 = v15 & v9;
        a3 = (_QWORD *)(*(_QWORD *)a1 + 16 * v10);
        v11 = *a3;
        if (v7 == *a3)
          goto LABEL_4;
      }
      goto LABEL_27;
    }
  }
  else
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
    {
LABEL_3:
      v7 = *a3;
      goto LABEL_4;
    }
    sub_1C53061CC(a1, v6);
    v7 = *a2;
    v16 = *(_DWORD *)(a1 + 16) - 1;
    v17 = (37 * *a2) & v16;
    a3 = (_QWORD *)(*(_QWORD *)a1 + 16 * v17);
    v18 = *a3;
    if (*a2 != *a3)
    {
      v12 = 0;
      v19 = 1;
      while (v18 != -1)
      {
        if (v12)
          v20 = 0;
        else
          v20 = v18 == -2;
        if (v20)
          v12 = a3;
        v21 = v17 + v19++;
        v17 = v21 & v16;
        a3 = (_QWORD *)(*(_QWORD *)a1 + 16 * v17);
        v18 = *a3;
        if (v7 == *a3)
          goto LABEL_4;
      }
LABEL_27:
      if (v12)
        a3 = v12;
      goto LABEL_3;
    }
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v7 != -1)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

void sub_1C548D86C(void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = (char *)*((_QWORD *)v4 - 19);
        if (v4 - 136 != v6)
          free(v6);
        v4 -= 160;
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1C548D8E8(_QWORD *a1)
{
  if (a1)
  {
    sub_1C548D8E8(*a1);
    sub_1C548D8E8(a1[1]);
    sub_1C624DF80(a1 + 5);
    operator delete(a1);
  }
}

_QWORD *sub_1C548D928(llvm::DWARFContext **a1, uint64_t a2)
{
  return llvm::DWARFUnitVector::addUnitsForSection((_QWORD *)*a1 + 2, *a1, a2, 1);
}

_QWORD *sub_1C548D93C(llvm::DWARFContext **a1, uint64_t a2)
{
  return llvm::DWARFUnitVector::addUnitsForSection((_QWORD *)*a1 + 2, *a1, a2, 2);
}

_QWORD *sub_1C548D950(uint64_t a1, uint64_t a2)
{
  return llvm::DWARFUnitVector::addUnitsForDWOSection((_QWORD *)(*(_QWORD *)a1 + 240), *(llvm::DWARFContext **)a1, a2, 1, **(_BYTE **)(a1 + 8));
}

_QWORD *sub_1C548D968(uint64_t a1, uint64_t a2)
{
  return llvm::DWARFUnitVector::addUnitsForDWOSection((_QWORD *)(*(_QWORD *)a1 + 240), *(llvm::DWARFContext **)a1, a2, 2, **(_BYTE **)(a1 + 8));
}

_QWORD *sub_1C548D980(_QWORD *result, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  unint64_t i;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;

  v2 = a2;
  v3 = result;
  if (a2 < 0)
  {
    result = (_QWORD *)*result;
    do
    {
      if (result)
      {
        v8 = v3[1];
        if (v8)
          result = (_QWORD *)llvm::DWARFUnit::getPreviousSibling((uint64_t)result, v8);
        else
          result = 0;
      }
      else
      {
        v8 = 0;
      }
      *v3 = result;
      v3[1] = v8;
    }
    while (!__CFADD__(v2++, 1));
  }
  else if (a2)
  {
    v4 = *result;
    for (i = a2 + 1; i > 1; --i)
    {
      if (!v4)
        goto LABEL_10;
      v6 = result[1];
      if (v6)
      {
        v7 = *(_DWORD *)(v6 + 12);
        if (!v7)
        {
          v4 = 0;
LABEL_10:
          v6 = 0;
          goto LABEL_11;
        }
        v6 = *(_QWORD *)(v4 + 288) + 24 * v7;
      }
      else
      {
        v4 = 0;
      }
LABEL_11:
      *result = v4;
      result[1] = v6;
    }
  }
  return result;
}

void sub_1C548DA28(void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = (char *)*((_QWORD *)v4 - 4);
        if (v4 - 8 != v6)
          free(v6);
        v4 -= 64;
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

unint64_t sub_1C548DAA4(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v7;
  unint64_t v9;

  v4 = *(unsigned int *)(a1 + 8);
  v5 = v4 + a3;
  if (v4 + a3 > (unint64_t)*(unsigned int *)(a1 + 12))
  {
    v7 = *(_QWORD *)a1 + 144 * v4;
    if (*(_QWORD *)a1 <= a2 && v7 > a2)
    {
      v9 = a2 - *(_QWORD *)a1;
      sub_1C548DB0C(a1, v5);
      return *(_QWORD *)a1 + v9;
    }
    else
    {
      sub_1C548DB0C(a1, v5);
    }
  }
  return a2;
}

void sub_1C548DB0C(uint64_t a1, unint64_t a2)
{
  void *v3;
  int v4;
  unint64_t v5;

  v5 = 0;
  v3 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, a2, 144, &v5);
  sub_1C548DB78((uint64_t *)a1, (uint64_t)v3);
  v4 = v5;
  if (*(_QWORD *)a1 != a1 + 16)
    free(*(void **)a1);
  *(_QWORD *)a1 = v3;
  *(_DWORD *)(a1 + 12) = v4;
}

void sub_1C548DB78(uint64_t *a1, uint64_t a2)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v2 = *((_DWORD *)a1 + 2);
  if (v2)
  {
    v3 = *a1;
    v4 = *a1 + 144 * v2;
    do
    {
      *(_QWORD *)a2 = *(_QWORD *)v3;
      v5 = *(_OWORD *)(v3 + 8);
      *(_QWORD *)(a2 + 24) = *(_QWORD *)(v3 + 24);
      *(_OWORD *)(a2 + 8) = v5;
      *(_QWORD *)(v3 + 16) = 0;
      *(_QWORD *)(v3 + 24) = 0;
      *(_QWORD *)(v3 + 8) = 0;
      v6 = *(_OWORD *)(v3 + 32);
      *(_QWORD *)(a2 + 48) = *(_QWORD *)(v3 + 48);
      *(_OWORD *)(a2 + 32) = v6;
      *(_QWORD *)(v3 + 40) = 0;
      *(_QWORD *)(v3 + 48) = 0;
      *(_QWORD *)(v3 + 32) = 0;
      v7 = *(_OWORD *)(v3 + 56);
      *(_QWORD *)(a2 + 72) = *(_QWORD *)(v3 + 72);
      *(_OWORD *)(a2 + 56) = v7;
      *(_QWORD *)(v3 + 64) = 0;
      *(_QWORD *)(v3 + 72) = 0;
      *(_QWORD *)(v3 + 56) = 0;
      v8 = *(_OWORD *)(v3 + 80);
      v9 = *(_OWORD *)(v3 + 96);
      v10 = *(_OWORD *)(v3 + 112);
      *(_OWORD *)(a2 + 124) = *(_OWORD *)(v3 + 124);
      *(_OWORD *)(a2 + 96) = v9;
      *(_OWORD *)(a2 + 112) = v10;
      *(_OWORD *)(a2 + 80) = v8;
      v3 += 144;
      a2 += 144;
    }
    while (v3 != v4);
    v11 = *((unsigned int *)a1 + 2);
    if ((_DWORD)v11)
    {
      v12 = *a1;
      v13 = 144 * v11;
      do
      {
        v14 = v12 + v13;
        if (*(char *)(v12 + v13 - 65) < 0)
          operator delete(*(void **)(v14 - 88));
        if (*(char *)(v14 - 89) < 0)
          operator delete(*(void **)(v12 + v13 - 112));
        if (*(char *)(v12 + v13 - 113) < 0)
          operator delete(*(void **)(v14 - 136));
        v13 -= 144;
      }
      while (v13);
    }
  }
}

void sub_1C548DC7C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E8169998;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1C548DC8C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E8169998;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C548DCBC(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;

  v2 = a1[5];
  a1[5] = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = a1[4];
  a1[4] = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  result = a1[3];
  a1[3] = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

char *sub_1C548DD2C(uint64_t *a1, uint64_t *a2, char **a3)
{
  int v5;
  __int16 v6;
  uint64_t v7;
  uint64_t *v8;
  unint64_t v10;
  uint64_t v11;
  char *result;
  char *v13;
  std::string __p;
  _QWORD v15[4];
  __int16 v16;

  v13 = *a3;
  *a3 = 0;
  sub_1C61D2548(&v13, &__p);
  v5 = *((unsigned __int8 *)a2 + 32);
  if (v5 == 1)
  {
    v15[0] = &__p;
    v6 = 260;
    goto LABEL_5;
  }
  if (!*((_BYTE *)a2 + 32))
  {
    v6 = 256;
LABEL_5:
    v16 = v6;
    goto LABEL_10;
  }
  v7 = a2[1];
  if (*((_BYTE *)a2 + 33) == 1)
  {
    v8 = (uint64_t *)*a2;
  }
  else
  {
    LOBYTE(v5) = 2;
    v8 = a2;
  }
  v15[0] = v8;
  v15[1] = v7;
  v15[2] = &__p;
  LOBYTE(v16) = v5;
  HIBYTE(v16) = 4;
LABEL_10:
  if (!atomic_load(qword_1ED836B58))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED836B58, (void *(*)(void))sub_1C5DF15F0, (void (*)(void *))sub_1C5DF1624);
  v10 = qword_1ED836B58[0];
  v11 = operator new();
  *(_QWORD *)v11 = off_1E81A0C88;
  llvm::Twine::str((llvm::Twine *)v15, (_QWORD *)(v11 + 8));
  *(_QWORD *)(v11 + 32) = 3;
  *(_QWORD *)(v11 + 40) = v10;
  *(_BYTE *)(v11 + 48) = 1;
  *a1 = v11;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  result = v13;
  if (v13)
    return (char *)(*(uint64_t (**)(char *))(*(_QWORD *)v13 + 8))(v13);
  return result;
}

uint64_t sub_1C548DE78(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = sub_1C548E188(a1, a2, a3);
  if (!result)
  {
    switch(a3)
    {
      case 9:
        if (*(_QWORD *)a2 == 0x74735F6775626564 && *(_BYTE *)(a2 + 8) == 114)
        {
          result = a1 + 1512;
        }
        else
        {
          if (*(_QWORD *)a2 != 0x65646E695F626467 || *(_BYTE *)(a2 + 8) != 120)
            goto LABEL_63;
          result = a1 + 1624;
        }
        break;
      case 12:
        if (*(_QWORD *)a2 != 0x62615F6775626564 || *(_DWORD *)(a2 + 8) != 1986359906)
          goto LABEL_63;
        result = a1 + 1480;
        break;
      case 13:
        if (*(_QWORD *)a2 == 0x72615F6775626564 && *(_QWORD *)(a2 + 5) == 0x7365676E6172615FLL)
        {
          result = a1 + 1496;
        }
        else if (*(_QWORD *)a2 == 0x616D5F6775626564 && *(_QWORD *)(a2 + 5) == 0x6F666E6963616D5FLL)
        {
          result = a1 + 1528;
        }
        else
        {
          if (*(_QWORD *)a2 != 0x74735F6775626564 || *(_QWORD *)(a2 + 5) != 0x6F77642E7274735FLL)
            goto LABEL_63;
          result = a1 + 1592;
        }
        break;
      case 14:
        if (*(_QWORD *)a2 == 0x75635F6775626564 && *(_QWORD *)(a2 + 6) == 0x7865646E695F7563)
        {
          result = a1 + 1608;
        }
        else if (*(_QWORD *)a2 == 0x75745F6775626564 && *(_QWORD *)(a2 + 6) == 0x7865646E695F7574)
        {
          result = a1 + 1640;
        }
        else if (*(_QWORD *)a2 ^ 0x696C5F6775626564 | *(_QWORD *)(a2 + 6) ^ 0x7274735F656E696CLL)
        {
          result = 0;
        }
        else
        {
          result = a1 + 1656;
        }
        break;
      case 15:
        if (*(_QWORD *)a2 != 0x616D5F6775626564 || *(_QWORD *)(a2 + 7) != 0x6F77642E6F726361)
          goto LABEL_63;
        result = a1 + 1560;
        break;
      case 16:
        if (*(_QWORD *)a2 != 0x62615F6775626564 || *(_QWORD *)(a2 + 8) != 0x6F77642E76657262)
          goto LABEL_63;
        result = a1 + 1576;
        break;
      case 17:
        if (*(_QWORD *)a2 == 0x616D5F6775626564
          && *(_QWORD *)(a2 + 8) == 0x77642E6F666E6963
          && *(_BYTE *)(a2 + 16) == 111)
        {
          result = a1 + 1544;
        }
        else
        {
LABEL_63:
          result = 0;
        }
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t sub_1C548E188(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v18;
  BOOL v19;
  uint64_t v20;

  switch(a3)
  {
    case 8:
      if (*(_QWORD *)a2 != 0x656D6172665F6865)
        goto LABEL_120;
      return a1 + 712;
    case 9:
      if (*(_QWORD *)a2 != 0x6F6C5F6775626564 || *(_BYTE *)(a2 + 8) != 99)
        return 0;
      return a1 + 280;
    case 10:
      if (*(_QWORD *)a2 == 0x696C5F6775626564 && *(_WORD *)(a2 + 8) == 25966)
        return a1 + 424;
      if (*(_QWORD *)a2 != 0x64615F6775626564 || *(_WORD *)(a2 + 8) != 29284)
        goto LABEL_120;
      return a1 + 952;
    case 11:
      if (*(_QWORD *)a2 == 0x72665F6775626564 && *(_QWORD *)(a2 + 3) == 0x656D6172665F6775)
        return a1 + 664;
      if (*(_QWORD *)a2 == 0x616E5F6775626564 && *(_QWORD *)(a2 + 3) == 0x73656D616E5F6775)
        return a1 + 1192;
      if (*(_QWORD *)a2 == 0x616E5F656C707061 && *(_QWORD *)(a2 + 3) == 0x73656D616E5F656CLL)
        return a1 + 1000;
      if (*(_QWORD *)a2 != 0x79745F656C707061 || *(_QWORD *)(a2 + 3) != 0x73657079745F656CLL)
        goto LABEL_120;
      return a1 + 1048;
    case 12:
      if (*(_QWORD *)a2 != 0x61725F6775626564 || *(_DWORD *)(a2 + 8) != 1936025454)
        goto LABEL_120;
      return a1 + 472;
    case 13:
      if (*(_QWORD *)a2 != 0x6F6C5F6775626564 || *(_QWORD *)(a2 + 5) != 0x6F77642E636F6C5FLL)
        goto LABEL_120;
      return a1 + 760;
    case 14:
      if (*(_QWORD *)a2 == 0x6F6C5F6775626564 && *(_QWORD *)(a2 + 6) == 0x737473696C636F6CLL)
        return a1 + 328;
      if (*(_QWORD *)a2 == 0x6E725F6775626564 && *(_QWORD *)(a2 + 6) == 0x737473696C676E72)
        return a1 + 520;
      if (*(_QWORD *)a2 == 0x696C5F6775626564 && *(_QWORD *)(a2 + 6) == 0x6F77642E656E696CLL)
        return a1 + 616;
      if (*(_QWORD *)a2 == 0x75705F6775626564 && *(_QWORD *)(a2 + 6) == 0x73656D616E627570)
        return a1 + 1240;
      if (*(_QWORD *)a2 != 0x75705F6775626564 || *(_QWORD *)(a2 + 6) != 0x7365707974627570)
        goto LABEL_120;
      return a1 + 1288;
    case 17:
      if (*(_QWORD *)a2 != 0x74735F6775626564
        || *(_QWORD *)(a2 + 8) != 0x74657366666F5F72
        || *(_BYTE *)(a2 + 16) != 115)
      {
        goto LABEL_120;
      }
      return a1 + 568;
    case 18:
      if (*(_QWORD *)a2 == 0x6F6C5F6775626564
        && *(_QWORD *)(a2 + 8) == 0x642E737473696C63
        && *(_WORD *)(a2 + 16) == 28535)
      {
        return a1 + 376;
      }
      if (*(_QWORD *)a2 == 0x6E725F6775626564
        && *(_QWORD *)(a2 + 8) == 0x642E737473696C67
        && *(_WORD *)(a2 + 16) == 28535)
      {
        return a1 + 904;
      }
      if (*(_QWORD *)a2 == 0x6E675F6775626564
        && *(_QWORD *)(a2 + 8) == 0x6D616E6275705F75
        && *(_WORD *)(a2 + 16) == 29541)
      {
        return a1 + 1336;
      }
      if (*(_QWORD *)a2 != 0x6E675F6775626564
        || *(_QWORD *)(a2 + 8) != 0x7079746275705F75
        || *(_WORD *)(a2 + 16) != 29541)
      {
        return 0;
      }
      return a1 + 1384;
    case 21:
      if (*(_QWORD *)a2 != 0x74735F6775626564
        || *(_QWORD *)(a2 + 8) != 0x74657366666F5F72
        || *(_QWORD *)(a2 + 13) != 0x6F77642E73746573)
      {
LABEL_120:
        v3 = a1 + 1096;
        goto LABEL_121;
      }
      return a1 + 808;
    default:
      v3 = a1 + 1096;
      if (a3 == 16)
      {
        v18 = *(_QWORD *)(a2 + 8);
        v19 = *(_QWORD *)a2 == 0x616E5F656C707061;
        v20 = 0x736563617073656DLL;
      }
      else
      {
LABEL_121:
        if (a3 == 10)
        {
          if (*(_QWORD *)a2 == 0x626F5F656C707061 && *(_WORD *)(a2 + 8) == 25450)
            return a1 + 1144;
          return 0;
        }
        if (a3 == 11)
        {
          v3 = a1 + 1432;
          if (*(_QWORD *)a2 ^ 0x616D5F6775626564 | *(_QWORD *)(a2 + 3) ^ 0x6F7263616D5F6775)
            return 0;
          return v3;
        }
        if (a3 != 14)
          return 0;
        v18 = *(_QWORD *)(a2 + 6);
        v19 = *(_QWORD *)a2 == 0x616E5F656C707061;
        v20 = 0x63617073656D616ELL;
      }
      if (!v19 || v18 != v20)
        return 0;
      return v3;
  }
}

unint64_t sub_1C548E760(uint64_t **a1, __int128 *a2)
{
  uint64_t *v4;
  uint64_t **v5;
  uint64_t *v6;
  unint64_t v7;
  unint64_t v8;
  BOOL v9;
  _BOOL4 v10;
  _BOOL4 v11;
  unint64_t v12;
  unint64_t v13;
  _BOOL4 v14;
  _BOOL4 v15;
  unsigned int v16;
  uint64_t *v17;
  _OWORD *v18;
  uint64_t *v19;
  uint64_t *v20;
  unint64_t v21;
  char *v22;
  __int128 v23;
  uint64_t *v24;
  char *v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char *v30;
  char *v31;
  char *v32;
  uint64_t v33;
  char *v34;
  char *v35;
  __int128 v36;
  char *v37;
  char *v38;
  __int128 v40;

  v40 = *a2;
  v5 = a1 + 1;
  v4 = a1[1];
  if (!v4)
  {
    v6 = (uint64_t *)(a1 + 1);
LABEL_16:
    v18 = operator new(0x38uLL);
    v18[2] = *a2;
    *((_DWORD *)v18 + 12) = 0;
    *(_QWORD *)v18 = 0;
    *((_QWORD *)v18 + 1) = 0;
    *((_QWORD *)v18 + 2) = v6;
    *v5 = (uint64_t *)v18;
    v19 = (uint64_t *)**a1;
    v20 = (uint64_t *)v18;
    if (v19)
    {
      *a1 = v19;
      v20 = *v5;
    }
    sub_1C4768E74(a1[1], v20);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    v22 = (char *)a1[4];
    v21 = (unint64_t)a1[5];
    if ((unint64_t)v22 >= v21)
    {
      v25 = (char *)a1[3];
      v26 = (v22 - v25) >> 6;
      v27 = v26 + 1;
      if ((unint64_t)(v26 + 1) >> 58)
        abort();
      v28 = v21 - (_QWORD)v25;
      if (v28 >> 5 > v27)
        v27 = v28 >> 5;
      if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFC0)
        v29 = 0x3FFFFFFFFFFFFFFLL;
      else
        v29 = v27;
      if (v29 >> 58)
        sub_1C4764EE4();
      v30 = (char *)operator new(v29 << 6);
      v31 = &v30[64 * v26];
      *(_OWORD *)v31 = *a2;
      *((_OWORD *)v31 + 1) = 0u;
      v32 = &v30[64 * v29];
      v24 = (uint64_t *)(v31 + 64);
      *((_OWORD *)v31 + 2) = 0u;
      *(_OWORD *)(v31 + 44) = 0u;
      if (v22 == v25)
      {
        a1[3] = (uint64_t *)v31;
        a1[4] = v24;
        a1[5] = (uint64_t *)v32;
        if (!v22)
          goto LABEL_34;
      }
      else
      {
        v33 = 0;
        do
        {
          v34 = &v31[v33];
          v35 = &v22[v33];
          *((_OWORD *)v34 - 4) = *(_OWORD *)&v22[v33 - 64];
          v36 = *(_OWORD *)&v22[v33 - 48];
          *((_QWORD *)v34 - 4) = *(_QWORD *)&v22[v33 - 32];
          *((_OWORD *)v34 - 3) = v36;
          *((_QWORD *)v34 - 3) = *(_QWORD *)&v22[v33 - 24];
          *((_QWORD *)v35 - 3) = 0;
          *((_DWORD *)v34 - 4) = *(_DWORD *)&v22[v33 - 16];
          *((_DWORD *)v35 - 4) = 0;
          *((_DWORD *)v34 - 3) = *(_DWORD *)&v22[v33 - 12];
          *((_DWORD *)v35 - 3) = 0;
          *((_DWORD *)v34 - 2) = *(_DWORD *)&v22[v33 - 8];
          *((_DWORD *)v35 - 2) = 0;
          v33 -= 64;
        }
        while (&v22[v33] != v25);
        v22 = (char *)a1[3];
        v37 = (char *)a1[4];
        a1[3] = (uint64_t *)&v31[v33];
        a1[4] = v24;
        a1[5] = (uint64_t *)v32;
        if (v37 != v22)
        {
          do
          {
            v38 = v37 - 64;
            MEMORY[0x1CAA32FB4](*((_QWORD *)v37 - 3), 8);
            v37 = v38;
          }
          while (v38 != v22);
        }
        if (!v22)
          goto LABEL_34;
      }
      operator delete(v22);
    }
    else
    {
      v23 = *a2;
      v24 = (uint64_t *)(v22 + 64);
      *(_OWORD *)v22 = v23;
      *((_OWORD *)v22 + 1) = 0u;
      *((_OWORD *)v22 + 2) = 0u;
      *(_OWORD *)(v22 + 44) = 0u;
    }
LABEL_34:
    a1[4] = v24;
    MEMORY[0x1CAA32FB4](0, 8);
    MEMORY[0x1CAA32FB4](0, 8);
    v17 = a1[3];
    v16 = ((unint64_t)((char *)a1[4] - (char *)v17) >> 6) - 1;
    *((_DWORD *)v18 + 12) = v16;
    return (unint64_t)&v17[8 * (unint64_t)v16 + 2];
  }
  while (1)
  {
    while (1)
    {
      v6 = v4;
      v7 = bswap64(v40);
      v8 = bswap64(v6[4]);
      v9 = v7 >= v8;
      v10 = v7 > v8;
      v11 = !v9;
      if (v10 - v11 >= 0)
        break;
      v4 = (uint64_t *)*v6;
      v5 = (uint64_t **)v6;
      if (!*v6)
        goto LABEL_16;
    }
    v12 = bswap64(v6[4]);
    v13 = bswap64(v40);
    v9 = v12 >= v13;
    v14 = v12 > v13;
    v15 = !v9;
    if (v14 - v15 >= 0)
      break;
    v4 = (uint64_t *)v6[1];
    if (!v4)
    {
      v5 = (uint64_t **)(v6 + 1);
      goto LABEL_16;
    }
  }
  v16 = *((_DWORD *)v6 + 12);
  v17 = a1[3];
  return (unint64_t)&v17[8 * (unint64_t)v16 + 2];
}

uint64_t sub_1C548EA14(uint64_t a1)
{
  void **v2;
  void **v3;
  unint64_t v4;
  void **v5;
  void **v6;
  void **v7;
  _QWORD *v8;
  unint64_t v9;
  void **v10;
  void **v11;
  void **v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  void *v34;
  uint64_t v35;
  void *v36;

  v2 = *(void ***)(a1 + 1680);
  v3 = *(void ***)(a1 + 1688);
  if (v3 == v2)
  {
    v8 = (_QWORD *)(a1 + 1712);
    v3 = *(void ***)(a1 + 1680);
  }
  else
  {
    v4 = *(_QWORD *)(a1 + 1704);
    v5 = &v2[v4 / 0xAA];
    v6 = (void **)*v5;
    v7 = (void **)((char *)*v5 + 24 * (v4 % 0xAA));
    v8 = (_QWORD *)(a1 + 1712);
    v9 = (unint64_t)v2[(*(_QWORD *)(a1 + 1712) + v4) / 0xAA] + 24 * ((*(_QWORD *)(a1 + 1712) + v4) % 0xAA);
    if (v7 != (void **)v9)
    {
      do
      {
        v11 = (void **)*v7;
        v7 += 3;
        v10 = v11;
        if (v11 != v7)
        {
          free(v10);
          v6 = (void **)*v5;
        }
        if ((char *)v7 - (char *)v6 == 4080)
        {
          v12 = (void **)v5[1];
          ++v5;
          v6 = v12;
          v7 = v12;
        }
      }
      while (v7 != (void **)v9);
      v3 = *(void ***)(a1 + 1688);
      v2 = *(void ***)(a1 + 1680);
    }
  }
  *v8 = 0;
  v13 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v2 = (void **)(*(_QWORD *)(a1 + 1680) + 8);
      *(_QWORD *)(a1 + 1680) = v2;
      v3 = *(void ***)(a1 + 1688);
      v13 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  v14 = v13 >> 3;
  if (v14 == 1)
  {
    v15 = 85;
    goto LABEL_16;
  }
  if (v14 == 2)
  {
    v15 = 170;
LABEL_16:
    *(_QWORD *)(a1 + 1704) = v15;
  }
  if (v2 != v3)
  {
    do
    {
      v16 = *v2++;
      operator delete(v16);
    }
    while (v2 != v3);
    v17 = *(_QWORD *)(a1 + 1680);
    v18 = *(_QWORD *)(a1 + 1688);
    if (v18 != v17)
      *(_QWORD *)(a1 + 1688) = v18 + ((v17 - v18 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  v19 = *(void **)(a1 + 1672);
  if (v19)
    operator delete(v19);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 1456), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 1408), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 1360), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 1312), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 1264), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 1216), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 1168), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 1120), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 1072), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 1024), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 976), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 928), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 880), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 832), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 784), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 736), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 688), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 640), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 592), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 544), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 496), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 448), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 400), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 352), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 304), 8);
  v20 = *(_QWORD *)(a1 + 256);
  if (v20)
  {
    v21 = *(_QWORD *)(a1 + 264);
    v22 = *(void **)(a1 + 256);
    if (v21 != v20)
    {
      do
      {
        v23 = v21 - 64;
        MEMORY[0x1CAA32FB4](*(_QWORD *)(v21 - 24), 8);
        v21 = v23;
      }
      while (v23 != v20);
      v22 = *(void **)(a1 + 256);
    }
    *(_QWORD *)(a1 + 264) = v20;
    operator delete(v22);
  }
  sub_1C49F3440(*(_QWORD **)(a1 + 240));
  v24 = *(_QWORD *)(a1 + 208);
  if (v24)
  {
    v25 = *(_QWORD *)(a1 + 216);
    v26 = *(void **)(a1 + 208);
    if (v25 != v24)
    {
      do
      {
        v27 = v25 - 64;
        MEMORY[0x1CAA32FB4](*(_QWORD *)(v25 - 24), 8);
        v25 = v27;
      }
      while (v27 != v24);
      v26 = *(void **)(a1 + 208);
    }
    *(_QWORD *)(a1 + 216) = v24;
    operator delete(v26);
  }
  sub_1C49F3440(*(_QWORD **)(a1 + 192));
  v28 = *(_QWORD *)(a1 + 160);
  if (v28)
  {
    v29 = *(_QWORD *)(a1 + 168);
    v30 = *(void **)(a1 + 160);
    if (v29 != v28)
    {
      do
      {
        v31 = v29 - 64;
        MEMORY[0x1CAA32FB4](*(_QWORD *)(v29 - 24), 8);
        v29 = v31;
      }
      while (v31 != v28);
      v30 = *(void **)(a1 + 160);
    }
    *(_QWORD *)(a1 + 168) = v28;
    operator delete(v30);
  }
  sub_1C49F3440(*(_QWORD **)(a1 + 144));
  v32 = *(_QWORD *)(a1 + 112);
  if (v32)
  {
    v33 = *(_QWORD *)(a1 + 120);
    v34 = *(void **)(a1 + 112);
    if (v33 != v32)
    {
      do
      {
        v35 = v33 - 64;
        MEMORY[0x1CAA32FB4](*(_QWORD *)(v33 - 24), 8);
        v33 = v35;
      }
      while (v35 != v32);
      v34 = *(void **)(a1 + 112);
    }
    *(_QWORD *)(a1 + 120) = v32;
    operator delete(v34);
  }
  sub_1C49F3440(*(_QWORD **)(a1 + 96));
  v36 = *(void **)(a1 + 64);
  if (v36)
  {
    *(_QWORD *)(a1 + 72) = v36;
    operator delete(v36);
  }
  return a1;
}

void sub_1C548EDF0(uint64_t a1)
{
  sub_1C548EA14(a1);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C548EE14(uint64_t a1)
{
  return *(_QWORD *)(a1 + 40);
}

uint64_t sub_1C548EE20(uint64_t a1)
{
  return *(_QWORD *)(a1 + 56);
}

uint64_t sub_1C548EE28(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

uint64_t sub_1C548EE48(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 32);
}

uint64_t sub_1C548EE50(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 33);
}

uint64_t sub_1C548EE58(uint64_t result, uint64_t (*a2)(uint64_t, uint64_t), uint64_t a3)
{
  uint64_t v3;
  uint64_t i;

  v3 = *(_QWORD *)(result + 112);
  for (i = *(_QWORD *)(result + 120); v3 != i; v3 += 64)
    result = a2(a3, v3 + 16);
  return result;
}

uint64_t sub_1C548EEA4(uint64_t result, uint64_t (*a2)(uint64_t, uint64_t), uint64_t a3)
{
  uint64_t v3;
  uint64_t i;

  v3 = *(_QWORD *)(result + 160);
  for (i = *(_QWORD *)(result + 168); v3 != i; v3 += 64)
    result = a2(a3, v3 + 16);
  return result;
}

uint64_t sub_1C548EEF0(uint64_t a1)
{
  return *(_QWORD *)(a1 + 1480);
}

uint64_t sub_1C548EF00(uint64_t a1)
{
  return a1 + 280;
}

uint64_t sub_1C548EF08(uint64_t a1)
{
  return a1 + 328;
}

uint64_t sub_1C548EF10(uint64_t a1)
{
  return *(_QWORD *)(a1 + 1496);
}

uint64_t sub_1C548EF20(uint64_t a1)
{
  return a1 + 664;
}

uint64_t sub_1C548EF28(uint64_t a1)
{
  return a1 + 712;
}

uint64_t sub_1C548EF30(uint64_t a1)
{
  return a1 + 424;
}

uint64_t sub_1C548EF38(uint64_t a1)
{
  return *(_QWORD *)(a1 + 1656);
}

uint64_t sub_1C548EF48(uint64_t a1)
{
  return *(_QWORD *)(a1 + 1512);
}

uint64_t sub_1C548EF58(uint64_t a1)
{
  return a1 + 472;
}

uint64_t sub_1C548EF60(uint64_t a1)
{
  return a1 + 520;
}

uint64_t sub_1C548EF68(uint64_t a1)
{
  return a1 + 1432;
}

uint64_t sub_1C548EF70(uint64_t a1)
{
  return *(_QWORD *)(a1 + 1560);
}

uint64_t sub_1C548EF80(uint64_t a1)
{
  return *(_QWORD *)(a1 + 1528);
}

uint64_t sub_1C548EF90(uint64_t a1)
{
  return *(_QWORD *)(a1 + 1544);
}

uint64_t sub_1C548EFA0(uint64_t a1)
{
  return a1 + 1240;
}

uint64_t sub_1C548EFA8(uint64_t a1)
{
  return a1 + 1288;
}

uint64_t sub_1C548EFB0(uint64_t a1)
{
  return a1 + 1336;
}

uint64_t sub_1C548EFB8(uint64_t a1)
{
  return a1 + 1384;
}

uint64_t sub_1C548EFC0(uint64_t a1)
{
  return a1 + 568;
}

uint64_t sub_1C548EFC8(uint64_t result, uint64_t (*a2)(uint64_t, uint64_t), uint64_t a3)
{
  uint64_t v3;
  uint64_t i;

  v3 = *(_QWORD *)(result + 208);
  for (i = *(_QWORD *)(result + 216); v3 != i; v3 += 64)
    result = a2(a3, v3 + 16);
  return result;
}

uint64_t sub_1C548F014(uint64_t result, uint64_t (*a2)(uint64_t, uint64_t), uint64_t a3)
{
  uint64_t v3;
  uint64_t i;

  v3 = *(_QWORD *)(result + 256);
  for (i = *(_QWORD *)(result + 264); v3 != i; v3 += 64)
    result = a2(a3, v3 + 16);
  return result;
}

uint64_t sub_1C548F060(uint64_t a1)
{
  return *(_QWORD *)(a1 + 1576);
}

uint64_t sub_1C548F070(uint64_t a1)
{
  return a1 + 616;
}

uint64_t sub_1C548F078(uint64_t a1)
{
  return a1 + 760;
}

uint64_t sub_1C548F080(uint64_t a1)
{
  return a1 + 376;
}

uint64_t sub_1C548F088(uint64_t a1)
{
  return *(_QWORD *)(a1 + 1592);
}

uint64_t sub_1C548F098(uint64_t a1)
{
  return a1 + 808;
}

uint64_t sub_1C548F0A0(uint64_t a1)
{
  return a1 + 856;
}

uint64_t sub_1C548F0A8(uint64_t a1)
{
  return a1 + 904;
}

uint64_t sub_1C548F0B0(uint64_t a1)
{
  return a1 + 952;
}

uint64_t sub_1C548F0B8(uint64_t a1)
{
  return a1 + 1000;
}

uint64_t sub_1C548F0C0(uint64_t a1)
{
  return a1 + 1048;
}

uint64_t sub_1C548F0C8(uint64_t a1)
{
  return a1 + 1096;
}

uint64_t sub_1C548F0D0(uint64_t a1)
{
  return a1 + 1192;
}

uint64_t sub_1C548F0D8(uint64_t a1)
{
  return a1 + 1144;
}

uint64_t sub_1C548F0E0(uint64_t a1)
{
  return *(_QWORD *)(a1 + 1608);
}

uint64_t sub_1C548F0F0(uint64_t a1)
{
  return *(_QWORD *)(a1 + 1624);
}

uint64_t sub_1C548F100(uint64_t a1)
{
  return *(_QWORD *)(a1 + 1640);
}

void sub_1C548F110(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t *v6;
  uint64_t v7;
  int v8;
  unsigned int v9;
  __int128 v10;
  __int128 v11;
  char v12;

  v3 = *(_QWORD *)(a1 + 24);
  v4 = *(_DWORD *)(a1 + 40);
  if (v4)
  {
    v5 = (v4 - 1) & (37 * a2);
    v6 = (uint64_t *)(v3 + 80 * v5);
    v7 = *v6;
    if (*v6 == a2)
      goto LABEL_8;
    v8 = 1;
    while (v7 != -1)
    {
      v9 = v5 + v8++;
      v5 = v9 & (v4 - 1);
      v6 = (uint64_t *)(v3 + 80 * v5);
      v7 = *v6;
      if (*v6 == a2)
        goto LABEL_8;
    }
  }
  v6 = (uint64_t *)(v3 + 80 * v4);
LABEL_8:
  if (v6 == (uint64_t *)(v3 + 80 * v4))
  {
    v12 = 0;
    *(_BYTE *)a3 = 0;
  }
  else
  {
    v10 = *(_OWORD *)(v6 + 3);
    v11 = *(_OWORD *)(v6 + 7);
    *(_OWORD *)(a3 + 32) = *(_OWORD *)(v6 + 5);
    *(_OWORD *)(a3 + 48) = v11;
    *(_QWORD *)(a3 + 64) = v6[9];
    *(_OWORD *)a3 = *(_OWORD *)(v6 + 1);
    *(_OWORD *)(a3 + 16) = v10;
    v12 = 1;
  }
  *(_BYTE *)(a3 + 72) = v12;
}

uint64_t sub_1C548F1BC(uint64_t a1, int a2, uint64_t a3, _QWORD *a4)
{
  int v4;
  unsigned int v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v10;
  int v11;
  BOOL v12;
  unsigned int v13;

  if (a2)
  {
    v4 = a2 - 1;
    v5 = (37 * a3) & (a2 - 1);
    v6 = (_QWORD *)(a1 + 80 * v5);
    v7 = *v6;
    if (*v6 == a3)
    {
      v8 = 1;
    }
    else
    {
      v10 = 0;
      v11 = 1;
      while (v7 != -1)
      {
        if (v10)
          v12 = 0;
        else
          v12 = v7 == -2;
        if (v12)
          v10 = v6;
        v13 = v5 + v11++;
        v5 = v13 & v4;
        v6 = (_QWORD *)(a1 + 80 * (v13 & v4));
        v7 = *v6;
        v8 = 1;
        if (*v6 == a3)
          goto LABEL_5;
      }
      v8 = 0;
      if (v10)
        v6 = v10;
    }
  }
  else
  {
    v6 = 0;
    v8 = 0;
  }
LABEL_5:
  *a4 = v6;
  return v8;
}

_QWORD *sub_1C548F254(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unsigned int v8;
  _QWORD *result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;

  v3 = *(unsigned int *)(a1 + 16);
  v4 = *(_QWORD *)a1;
  v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
    v8 = v7 + 1;
  else
    v8 = 64;
  *(_DWORD *)(a1 + 16) = v8;
  result = operator new(80 * v8, (std::align_val_t)8uLL);
  *(_QWORD *)a1 = result;
  if (v4)
  {
    *(_QWORD *)(a1 + 8) = 0;
    v10 = *(unsigned int *)(a1 + 16);
    if ((_DWORD)v10)
    {
      v11 = 80 * v10;
      do
      {
        *result = -1;
        result += 10;
        v11 -= 80;
      }
      while (v11);
    }
    if ((_DWORD)v3)
    {
      v12 = 80 * v3;
      v13 = v4;
      do
      {
        v14 = *(_QWORD *)v13;
        if (*(_QWORD *)v13 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          v21 = 0;
          sub_1C548F1BC(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), v14, &v21);
          v15 = v21;
          *v21 = *(_QWORD *)v13;
          *(_OWORD *)(v15 + 1) = *(_OWORD *)(v13 + 8);
          v16 = *(_OWORD *)(v13 + 24);
          v17 = *(_OWORD *)(v13 + 40);
          v18 = *(_OWORD *)(v13 + 56);
          v15[9] = *(_QWORD *)(v13 + 72);
          *(_OWORD *)(v15 + 7) = v18;
          *(_OWORD *)(v15 + 5) = v17;
          *(_OWORD *)(v15 + 3) = v16;
          ++*(_DWORD *)(a1 + 8);
        }
        v13 += 80;
        v12 -= 80;
      }
      while (v12);
    }
    JUMPOUT(0x1CAA32FB4);
  }
  *(_QWORD *)(a1 + 8) = 0;
  v19 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v19)
  {
    v20 = 80 * v19;
    do
    {
      *result = -1;
      result += 10;
      v20 -= 80;
    }
    while (v20);
  }
  return result;
}

void sub_1C548F3B0(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v8;
  void **v9;
  uint64_t v10;
  void (**v11)(llvm::raw_ostream *__hidden);
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  int v18;
  void **v19;
  void *__p[2];
  uint64_t v21;
  _QWORD v22[4];
  __int16 v23;

  __p[0] = 0;
  __p[1] = 0;
  v21 = 0;
  v12 = 0;
  v16 = 0;
  v17 = 0;
  v11 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
  v19 = __p;
  v18 = 0;
  v15 = 0;
  v13 = 0;
  v14 = 0;
  v8 = *a4;
  v22[0] = &unk_1E8133270;
  v22[1] = a3;
  v22[2] = v8;
  llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v11, (uint64_t)v22);
  v9 = v19;
  v10 = operator new();
  v23 = 260;
  v22[0] = v9;
  *(_QWORD *)v10 = off_1E81A0C88;
  llvm::Twine::str((llvm::Twine *)v22, (_QWORD *)(v10 + 8));
  *(_QWORD *)(v10 + 32) = a1;
  *(_QWORD *)(v10 + 40) = a2;
  *(_BYTE *)(v10 + 48) = 1;
  *a5 = v10;
  v11 = off_1E81A6E70;
  if (v18 == 1 && v13)
    MEMORY[0x1CAA32F9C](v13, 0x1000C8077774924);
  if (SHIBYTE(v21) < 0)
    operator delete(__p[0]);
}

unint64_t llvm::DWARFDataExtractor::getEncodedPointer(llvm::DWARFDataExtractor *this, unint64_t *a2, unsigned int a3, uint64_t a4)
{
  unint64_t v5;
  unint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v12;
  unsigned int v13;
  int v14;
  unint64_t Unsigned;

  if (a3 == 255)
  {
LABEL_8:
    v5 = 0;
    v9 = 0;
  }
  else
  {
    v5 = 0;
    v8 = *a2;
    v9 = 0;
    switch(a3 & 0xF)
    {
      case 0u:
        v10 = *((unsigned __int8 *)this + 17);
        if (v10 > 8 || ((1 << v10) & 0x114) == 0)
          goto LABEL_8;
        Unsigned = llvm::DataExtractor::getUnsigned(this, a2, v10, 0);
        goto LABEL_17;
      case 1u:
        Unsigned = llvm::DataExtractor::getULEB128((uint64_t *)this, (uint64_t *)a2, 0);
        goto LABEL_17;
      case 2u:
        LODWORD(Unsigned) = sub_1C63871E8((uint64_t)this, a2, 0);
        goto LABEL_26;
      case 3u:
        LODWORD(Unsigned) = sub_1C6387364((uint64_t)this, a2, 0);
LABEL_26:
        Unsigned = Unsigned;
        goto LABEL_17;
      case 4u:
        Unsigned = sub_1C63873F8((uint64_t)this, a2, 0);
        goto LABEL_17;
      case 5u:
      case 6u:
      case 7u:
      case 8u:
        return v9 | v5;
      case 9u:
        Unsigned = llvm::DataExtractor::getSLEB128(this, (uint64_t *)a2, 0);
        goto LABEL_17;
      case 0xAu:
        if (v8 > 0xFFFFFFFFFFFFFFFDLL || *((_QWORD *)this + 1) <= v8 + 1)
        {
          Unsigned = 0;
        }
        else
        {
          v12 = *(unsigned __int16 *)(*(_QWORD *)this + v8);
          v13 = bswap32(v12) >> 16;
          if (*((_BYTE *)this + 16) != 1)
            LOWORD(v12) = v13;
          *a2 = v8 + 2;
          Unsigned = (__int16)v12;
        }
        goto LABEL_17;
      case 0xBu:
        Unsigned = (int)llvm::DWARFDataExtractor::getRelocatedValue((uint64_t)this, 4, a2, 0, 0);
        goto LABEL_17;
      case 0xCu:
        Unsigned = llvm::DWARFDataExtractor::getRelocatedValue((uint64_t)this, 8, a2, 0, 0);
LABEL_17:
        v14 = (a3 >> 4) & 7;
        if (!v14)
          goto LABEL_20;
        if (v14 == 1)
        {
          Unsigned += a4;
LABEL_20:
          v5 = Unsigned & 0xFFFFFFFFFFFFFF00;
          v9 = Unsigned;
        }
        else
        {
          v5 = 0;
          v9 = 0;
          *a2 = v8;
        }
        break;
      default:
        v9 = 0;
        return v9 | v5;
    }
  }
  return v9 | v5;
}

uint64_t llvm::DWARFAbbreviationDeclarationSet::DWARFAbbreviationDeclarationSet(uint64_t this)
{
  *(_QWORD *)this = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 24) = 0;
  *(_QWORD *)(this + 32) = 0;
  *(_QWORD *)(this + 16) = 0;
  return this;
}

{
  *(_QWORD *)this = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 24) = 0;
  *(_QWORD *)(this + 32) = 0;
  *(_QWORD *)(this + 16) = 0;
  return this;
}

void llvm::DWARFAbbreviationDeclarationSet::clear(llvm::DWARFAbbreviationDeclarationSet *this)
{
  uint64_t v2;
  uint64_t i;
  void *v4;

  *(_QWORD *)this = 0;
  *((_DWORD *)this + 2) = 0;
  v2 = *((_QWORD *)this + 2);
  for (i = *((_QWORD *)this + 3); i != v2; i -= 160)
  {
    v4 = *(void **)(i - 152);
    if ((void *)(i - 136) != v4)
      free(v4);
  }
  *((_QWORD *)this + 3) = v2;
}

void sub_1C548F728(uint64_t *a1, uint64_t a2)
{
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  char *v12;
  char *v13;
  char *i;
  char *v15;
  void *__p;
  char *v17;
  char *v18;
  char *v19;
  uint64_t *v20;

  v4 = a1[2];
  v5 = (_QWORD *)a1[1];
  if ((unint64_t)v5 >= v4)
  {
    v7 = 0xCCCCCCCCCCCCCCCDLL * (((uint64_t)v5 - *a1) >> 5);
    if (v7 + 1 > 0x199999999999999)
      abort();
    v8 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v4 - *a1) >> 5);
    v9 = 2 * v8;
    if (2 * v8 <= v7 + 1)
      v9 = v7 + 1;
    if (v8 >= 0xCCCCCCCCCCCCCCLL)
      v10 = 0x199999999999999;
    else
      v10 = v9;
    v20 = a1 + 2;
    if (v10)
    {
      if (v10 > 0x199999999999999)
        sub_1C4764EE4();
      v11 = (char *)operator new(160 * v10);
    }
    else
    {
      v11 = 0;
    }
    v12 = &v11[160 * v7];
    __p = v11;
    v17 = v12;
    v19 = &v11[160 * v10];
    *(_QWORD *)v12 = *(_QWORD *)a2;
    *((_QWORD *)v12 + 1) = v12 + 24;
    *((_QWORD *)v12 + 2) = 0x800000000;
    if (*(_DWORD *)(a2 + 16))
      sub_1C6180FA8((uint64_t)(v12 + 8), a2 + 8);
    *(_QWORD *)&v11[160 * v7 + 152] = *(_QWORD *)(a2 + 152);
    v18 = v12 + 160;
    sub_1C624E78C(a1, &__p);
    v6 = (_QWORD *)a1[1];
    v13 = v17;
    for (i = v18; i != v13; i -= 160)
    {
      v15 = (char *)*((_QWORD *)i - 19);
      if (i - 136 != v15)
        free(v15);
    }
    if (__p)
      operator delete(__p);
  }
  else
  {
    *v5 = *(_QWORD *)a2;
    v5[1] = v5 + 3;
    v5[2] = 0x800000000;
    if (*(_DWORD *)(a2 + 16))
      sub_1C6180FA8((uint64_t)(v5 + 1), a2 + 8);
    v5[19] = *(_QWORD *)(a2 + 152);
    v6 = v5 + 20;
  }
  a1[1] = (uint64_t)v6;
}

void llvm::DWARFAbbreviationDeclarationSet::dump(llvm::DWARFAbbreviationDeclarationSet *this, llvm::raw_ostream *a2)
{
  llvm::DWARFAbbreviationDeclaration *v2;
  llvm::DWARFAbbreviationDeclaration *i;

  v2 = (llvm::DWARFAbbreviationDeclaration *)*((_QWORD *)this + 2);
  for (i = (llvm::DWARFAbbreviationDeclaration *)*((_QWORD *)this + 3);
        v2 != i;
        v2 = (llvm::DWARFAbbreviationDeclaration *)((char *)v2 + 160))
  {
    llvm::DWARFAbbreviationDeclaration::dump(v2, a2);
  }
}

void llvm::DWARFAbbreviationDeclarationSet::getCodeRange(llvm::DWARFAbbreviationDeclarationSet *this@<X0>, _QWORD *a2@<X8>)
{
  int *v4;
  int *v5;
  char *v6;
  int v7;
  char *v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  int v16;
  char *v17;
  unsigned int v18;
  char *v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  char *v23;
  llvm::raw_ostream *v24;
  void (**v25)(llvm::raw_ostream *__hidden);
  int v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char v30;
  uint64_t v31;
  int v32;
  _QWORD *v33;
  char *v34;
  char *v35;
  char *v36;

  v34 = 0;
  v35 = 0;
  v36 = 0;
  sub_1C515E708((uint64_t)&v34, 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((_QWORD *)this + 3) - *((_QWORD *)this + 2)) >> 5));
  v4 = (int *)*((_QWORD *)this + 2);
  v5 = (int *)*((_QWORD *)this + 3);
  v6 = v35;
  if (v4 == v5)
  {
    v8 = v35;
  }
  else
  {
    do
    {
      v7 = *v4;
      if (v6 >= v36)
      {
        v9 = v34;
        v10 = (v6 - v34) >> 2;
        v11 = v10 + 1;
        if ((unint64_t)(v10 + 1) >> 62)
          abort();
        v12 = v36 - v34;
        if ((v36 - v34) >> 1 > v11)
          v11 = v12 >> 1;
        if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL)
          v13 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v13 = v11;
        if (v13)
        {
          if (v13 >> 62)
            sub_1C4764EE4();
          v14 = (char *)operator new(4 * v13);
        }
        else
        {
          v14 = 0;
        }
        v15 = &v14[4 * v10];
        *(_DWORD *)v15 = v7;
        v8 = v15 + 4;
        while (v6 != v9)
        {
          v16 = *((_DWORD *)v6 - 1);
          v6 -= 4;
          *((_DWORD *)v15 - 1) = v16;
          v15 -= 4;
        }
        v34 = v15;
        v35 = v8;
        v36 = &v14[4 * v13];
        if (v9)
          operator delete(v9);
      }
      else
      {
        *(_DWORD *)v6 = v7;
        v8 = v6 + 4;
      }
      v35 = v8;
      v4 += 40;
      v6 = v8;
    }
    while (v4 != v5);
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v26 = 0;
  v30 = 0;
  v31 = 0;
  v25 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
  v33 = a2;
  v32 = 0;
  v28 = 0;
  v29 = 0;
  v27 = 0;
  v17 = v34;
  if (v34 != v8)
  {
    do
    {
      v20 = *(_DWORD *)v17;
      v19 = v17 + 4;
      v18 = v20;
      sub_1C5E21910((llvm::raw_ostream *)&v25, v20, 0, 0, 0);
      v21 = v20;
      while (1)
      {
        v22 = v21;
        v23 = v19;
        if (v19 == v8)
          break;
        v19 += 4;
        v21 = *(_DWORD *)v23;
        if (*(_DWORD *)v23 != v22 + 1)
        {
          v17 = v23;
          goto LABEL_28;
        }
      }
      v17 = v8;
LABEL_28:
      if (v18 != v22)
      {
        if (v28 == v29)
        {
          v24 = llvm::raw_ostream::write((llvm::raw_ostream *)&v25, "-", 1uLL);
        }
        else
        {
          *v29++ = 45;
          v24 = (llvm::raw_ostream *)&v25;
        }
        sub_1C5E21910(v24, v22, 0, 0, 0);
      }
      if (v23 != v8)
      {
        if ((unint64_t)(v28 - v29) > 1)
        {
          *(_WORD *)v29 = 8236;
          v29 += 2;
        }
        else
        {
          llvm::raw_ostream::write((llvm::raw_ostream *)&v25, ", ", 2uLL);
        }
      }
    }
    while (v17 != v8);
    v25 = off_1E81A6E70;
    if (v32 == 1 && v27)
      MEMORY[0x1CAA32F9C](v27, 0x1000C8077774924);
    v8 = v34;
  }
  if (v8)
  {
    v35 = v8;
    operator delete(v8);
  }
}

uint64_t llvm::DWARFDebugAbbrev::DWARFDebugAbbrev(uint64_t this)
{
  *(_BYTE *)(this + 56) = 0;
  *(_BYTE *)(this + 32) = 0;
  *(_QWORD *)(this + 8) = 0;
  *(_QWORD *)this = this + 8;
  *(_QWORD *)(this + 16) = 0;
  *(_QWORD *)(this + 24) = this + 8;
  return this;
}

{
  *(_BYTE *)(this + 56) = 0;
  *(_BYTE *)(this + 32) = 0;
  *(_QWORD *)(this + 8) = 0;
  *(_QWORD *)this = this + 8;
  *(_QWORD *)(this + 16) = 0;
  *(_QWORD *)(this + 24) = this + 8;
  return this;
}

void llvm::DWARFDebugAbbrev::clear(char **this)
{
  char *v2;

  v2 = (char *)(this + 1);
  sub_1C624E174((uint64_t)this, this[1]);
  *this = v2;
  *(_QWORD *)v2 = 0;
  this[2] = 0;
  this[3] = v2;
}

void llvm::DWARFDebugAbbrev::parse(uint64_t **this)
{
  void **v2;
  uint64_t *v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t *v21;
  unint64_t v22;
  uint64_t *v23;
  uint64_t *v24;
  unint64_t v25;
  _QWORD *v26;
  void **v27;
  uint64_t *v28;
  uint64_t *v29;
  char *v30;
  void **v31[2];
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  __int128 v36;
  uint64_t v37;
  void **v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  void **v44;

  if (!*((_BYTE *)this + 56))
    return;
  v43 = 0;
  if (!this[5])
    goto LABEL_59;
  v2 = 0;
  v3 = (uint64_t *)(this + 1);
  v4 = *this;
  v30 = (char *)(this + 4);
  while (1)
  {
    v5 = v4;
    v4 = (uint64_t *)(this + 1);
    if (v5 != v3)
    {
      while (v5[4] < (unint64_t)v2)
      {
        v6 = (uint64_t *)v5[1];
        if (v6)
        {
          do
          {
            v7 = v6;
            v6 = (uint64_t *)*v6;
          }
          while (v6);
        }
        else
        {
          do
          {
            v7 = (uint64_t *)v5[2];
            v8 = *v7 == (_QWORD)v5;
            v5 = v7;
          }
          while (!v8);
        }
        v5 = v7;
        if (v7 == v3)
        {
          v4 = (uint64_t *)(this + 1);
          goto LABEL_14;
        }
      }
      v4 = v5;
    }
LABEL_14:
    v38 = 0;
    v39 = 0;
    v41 = 0;
    v42 = 0;
    v40 = 0;
    v36 = *(_OWORD *)v30;
    v37 = *((_QWORD *)v30 + 2);
    if (!llvm::DWARFAbbreviationDeclarationSet::extract((uint64_t)&v38, &v36, (uint64_t *)&v43))
      break;
    v31[1] = v38;
    v32 = v39;
    v9 = v40;
    v10 = v41;
    v31[0] = v2;
    v33 = v40;
    v34 = v41;
    v11 = v42;
    v35 = v42;
    v41 = 0;
    v42 = 0;
    v40 = 0;
    if (v3 == v4 || (v12 = v4[4], v12 > (unint64_t)v2))
    {
      v13 = *v4;
      v14 = v4;
      if (*this == v4)
        goto LABEL_23;
      v15 = (uint64_t *)*v4;
      v16 = v4;
      if (v13)
      {
        do
        {
          v14 = v15;
          v15 = (uint64_t *)v15[1];
        }
        while (v15);
      }
      else
      {
        do
        {
          v14 = (uint64_t *)v16[2];
          v8 = *v14 == (_QWORD)v16;
          v16 = v14;
        }
        while (v8);
      }
      if (v14[4] < (unint64_t)v2)
      {
LABEL_23:
        if (v13)
          v17 = v14;
        else
          v17 = v4;
        if (v13)
          v18 = v14 + 1;
        else
          v18 = v4;
        if (*v18)
          goto LABEL_58;
      }
      else
      {
        v21 = (uint64_t *)*v3;
        v18 = (uint64_t *)(this + 1);
        v17 = (uint64_t *)(this + 1);
        if (*v3)
        {
          while (1)
          {
            while (1)
            {
              v17 = v21;
              v22 = v21[4];
              if (v22 <= (unint64_t)v2)
                break;
              v21 = (uint64_t *)*v17;
              v18 = v17;
              if (!*v17)
                goto LABEL_54;
            }
            if (v22 >= (unint64_t)v2)
              goto LABEL_58;
            v21 = (uint64_t *)v17[1];
            if (!v21)
              goto LABEL_41;
          }
        }
      }
      goto LABEL_54;
    }
    if (v12 < (unint64_t)v2)
    {
      v18 = v4 + 1;
      v19 = (uint64_t *)v4[1];
      if (v19)
      {
        do
        {
          v18 = v19;
          v19 = (uint64_t *)*v19;
          v17 = v18;
          v20 = v18;
        }
        while (v19);
      }
      else
      {
        v20 = v4;
        do
        {
          v23 = v20;
          v20 = (uint64_t *)v20[2];
        }
        while ((uint64_t *)*v20 != v23);
        v17 = v4;
      }
      if (v20 != v3 && v20[4] <= (unint64_t)v2)
      {
        v24 = (uint64_t *)*v3;
        v18 = (uint64_t *)(this + 1);
        v17 = (uint64_t *)(this + 1);
        if (*v3)
        {
          while (1)
          {
            while (1)
            {
              v17 = v24;
              v25 = v24[4];
              if (v25 <= (unint64_t)v2)
                break;
              v24 = (uint64_t *)*v17;
              v18 = v17;
              if (!*v17)
                goto LABEL_54;
            }
            if (v25 >= (unint64_t)v2)
              goto LABEL_58;
            v24 = (uint64_t *)v17[1];
            if (!v24)
            {
LABEL_41:
              v18 = v17 + 1;
              break;
            }
          }
        }
      }
LABEL_54:
      v26 = operator new(0x50uLL);
      v27 = v38;
      v26[4] = v2;
      v26[5] = v27;
      *((_DWORD *)v26 + 12) = v39;
      v26[7] = v9;
      v26[8] = v10;
      v26[9] = v11;
      v34 = 0;
      v35 = 0;
      v33 = 0;
      *v26 = 0;
      v26[1] = 0;
      v26[2] = v17;
      *v18 = (uint64_t)v26;
      v28 = (uint64_t *)**this;
      if (v28)
      {
        *this = v28;
        v29 = (uint64_t *)*v18;
      }
      else
      {
        v29 = v26;
      }
      sub_1C4768E74(this[1], v29);
      this[2] = (uint64_t *)((char *)this[2] + 1);
    }
LABEL_58:
    v44 = (void **)&v33;
    sub_1C548D86C(&v44);
    v31[0] = (void **)&v40;
    sub_1C548D86C(v31);
    v2 = (void **)v43;
    if ((unint64_t)this[5] <= v43)
      goto LABEL_59;
  }
  v31[0] = (void **)&v40;
  sub_1C548D86C(v31);
LABEL_59:
  *((_BYTE *)this + 32) = 0;
  *((_BYTE *)this + 56) = 0;
}

void llvm::DWARFDebugAbbrev::dump(uint64_t **this, llvm::raw_ostream *a2)
{
  uint64_t *v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  llvm::DWARFAbbreviationDeclaration *v8;
  llvm::DWARFAbbreviationDeclaration *v9;
  uint64_t *v10;
  uint64_t *v11;
  BOOL v12;
  uint64_t v13;
  _QWORD v14[3];

  llvm::DWARFDebugAbbrev::parse(this);
  if (this[2])
  {
    v6 = *this;
    v4 = (uint64_t *)(this + 1);
    v5 = v6;
    if (v6 != v4)
    {
      do
      {
        v7 = v5[4];
        v14[0] = &unk_1E8133270;
        v14[1] = "Abbrev table for offset: 0x%8.8llx\n";
        v14[2] = v7;
        llvm::raw_ostream::operator<<(a2, (uint64_t)v14);
        v8 = (llvm::DWARFAbbreviationDeclaration *)v5[7];
        v9 = (llvm::DWARFAbbreviationDeclaration *)v5[8];
        while (v8 != v9)
        {
          llvm::DWARFAbbreviationDeclaration::dump(v8, a2);
          v8 = (llvm::DWARFAbbreviationDeclaration *)((char *)v8 + 160);
        }
        v10 = (uint64_t *)v5[1];
        if (v10)
        {
          do
          {
            v11 = v10;
            v10 = (uint64_t *)*v10;
          }
          while (v10);
        }
        else
        {
          do
          {
            v11 = (uint64_t *)v5[2];
            v12 = *v11 == (_QWORD)v5;
            v5 = v11;
          }
          while (!v12);
        }
        v5 = v11;
      }
      while (v11 != v4);
    }
  }
  else
  {
    v13 = *((_QWORD *)a2 + 4);
    if ((unint64_t)(*((_QWORD *)a2 + 3) - v13) > 9)
    {
      *(_WORD *)(v13 + 8) = 2622;
      *(_QWORD *)v13 = *(_QWORD *)"< EMPTY >\n";
      *((_QWORD *)a2 + 4) += 10;
    }
    else
    {
      llvm::raw_ostream::write(a2, "< EMPTY >\n", 0xAuLL);
    }
  }
}

_QWORD *llvm::DWARFDebugAbbrev::getAbbreviationDeclarationSet(llvm::DWARFDebugAbbrev *this, void **a2)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  unint64_t v7;
  BOOL v8;
  _QWORD *v9;
  uint64_t v10;
  void **v12[2];
  int v13;
  __int128 v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  void **v18;
  int v19;
  __int128 v20;
  uint64_t v21;
  void **v22;
  void **v23;

  v4 = (_QWORD *)((char *)this + 8);
  v5 = (_QWORD *)*((_QWORD *)this + 3);
  if (v5 != (_QWORD *)((char *)this + 8) && (void **)v5[4] == a2)
    return v5 + 5;
  v6 = (_QWORD *)*v4;
  if (*v4)
  {
    v5 = (_QWORD *)((char *)this + 8);
    do
    {
      v7 = v6[4];
      v8 = v7 >= (unint64_t)a2;
      if (v7 >= (unint64_t)a2)
        v9 = v6;
      else
        v9 = v6 + 1;
      if (v8)
        v5 = v6;
      v6 = (_QWORD *)*v9;
    }
    while (*v9);
    if (v5 != v4 && v5[4] <= (unint64_t)a2)
    {
      *((_QWORD *)this + 3) = v5;
      return v5 + 5;
    }
  }
  if (!*((_BYTE *)this + 56) || *((_QWORD *)this + 5) <= (unint64_t)a2)
    return 0;
  v22 = a2;
  v19 = 0;
  v21 = 0;
  v20 = 0uLL;
  v16 = *((_OWORD *)this + 2);
  v17 = *((_QWORD *)this + 6);
  v18 = 0;
  v10 = 0;
  if (llvm::DWARFAbbreviationDeclarationSet::extract((uint64_t)&v18, &v16, (uint64_t *)&v22))
  {
    v12[0] = a2;
    v12[1] = v18;
    v13 = v19;
    v14 = v20;
    v15 = v21;
    v21 = 0;
    v20 = 0uLL;
    *((_QWORD *)this + 3) = sub_1C5490244((uint64_t **)this, (unint64_t *)v12, (uint64_t)v12);
    v23 = (void **)&v14;
    sub_1C548D86C(&v23);
    v10 = *((_QWORD *)this + 3) + 40;
  }
  v12[0] = (void **)&v20;
  sub_1C548D86C(v12);
  return (_QWORD *)v10;
}

char *sub_1C5490244(uint64_t **a1, unint64_t *a2, uint64_t a3)
{
  char *v5;
  uint64_t **v6;
  unint64_t v7;
  char *v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t *v13;

  v6 = a1 + 1;
  v5 = (char *)a1[1];
  if (v5)
  {
    v7 = *a2;
    while (1)
    {
      while (1)
      {
        v8 = v5;
        v9 = *((_QWORD *)v5 + 4);
        if (v7 >= v9)
          break;
        v5 = *(char **)v8;
        v6 = (uint64_t **)v8;
        if (!*(_QWORD *)v8)
          goto LABEL_10;
      }
      if (v9 >= v7)
        break;
      v5 = (char *)*((_QWORD *)v8 + 1);
      if (!v5)
      {
        v6 = (uint64_t **)(v8 + 8);
        goto LABEL_10;
      }
    }
  }
  else
  {
    v8 = (char *)(a1 + 1);
LABEL_10:
    v10 = v8;
    v8 = (char *)operator new(0x50uLL);
    v11 = *(_QWORD *)(a3 + 8);
    *((_QWORD *)v8 + 4) = *(_QWORD *)a3;
    *((_QWORD *)v8 + 5) = v11;
    *((_DWORD *)v8 + 12) = *(_DWORD *)(a3 + 16);
    *(_OWORD *)(v8 + 56) = *(_OWORD *)(a3 + 24);
    *((_QWORD *)v8 + 9) = *(_QWORD *)(a3 + 40);
    *(_QWORD *)(a3 + 24) = 0;
    *(_QWORD *)(a3 + 32) = 0;
    *(_QWORD *)(a3 + 40) = 0;
    *(_QWORD *)v8 = 0;
    *((_QWORD *)v8 + 1) = 0;
    *((_QWORD *)v8 + 2) = v10;
    *v6 = (uint64_t *)v8;
    v12 = (uint64_t *)**a1;
    v13 = (uint64_t *)v8;
    if (v12)
    {
      *a1 = v12;
      v13 = *v6;
    }
    sub_1C4768E74(a1[1], v13);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v8;
}

void llvm::DWARFDebugAddrTable::extractAddresses(llvm::DWARFDebugAddrTable *this@<X0>, const llvm::DWARFDataExtractor *a2@<X1>, unint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  unint64_t v10;
  unsigned int v11;
  const std::error_category *v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  const std::error_category *v16;
  uint64_t v17;
  char v18;
  void **v19;
  uint64_t v20;
  void **v21;
  unint64_t RelocatedValue;
  unint64_t v23;
  unint64_t v24;
  unint64_t *v25;
  _QWORD *v26;
  unint64_t *v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  char *v32;
  unint64_t *v33;
  unint64_t v34;
  void (**v35)(llvm::raw_ostream *__hidden);
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char v40;
  uint64_t v41;
  int v42;
  void **v43;
  void *__p[2];
  uint64_t v45;
  _QWORD v46[4];
  __int16 v47;

  v10 = *a3;
  v11 = *((unsigned __int8 *)this + 26);
  v12 = std::generic_category();
  sub_1C5490600(v11, 45, (uint64_t)v12, (uint64_t)"address table at offset 0x%llx", (uint64_t *)this + 1, a5);
  if (!*a5)
  {
    v13 = a4 - v10;
    v14 = *((unsigned __int8 *)this + 26);
    v15 = v13 / v14;
    if (v13 % v14)
    {
      *((_QWORD *)this + 2) = 0;
      v16 = std::generic_category();
      __p[0] = 0;
      __p[1] = 0;
      v45 = 0;
      v36 = 0;
      v40 = 0;
      v41 = 0;
      v35 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
      v43 = __p;
      v42 = 0;
      v38 = 0;
      v39 = 0;
      v37 = 0;
      v17 = *((_QWORD *)this + 1);
      v18 = *((_BYTE *)this + 26);
      v46[0] = &off_1E8169B88;
      v46[1] = "address table at offset 0x%llx contains data of size 0x%llx which is not a multiple of addr size %hhu";
      v46[2] = v17;
      v46[3] = v13;
      LOBYTE(v47) = v18;
      llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v35, (uint64_t)v46);
      v19 = v43;
      v20 = operator new();
      v47 = 260;
      v46[0] = v19;
      *(_QWORD *)v20 = off_1E81A0C88;
      llvm::Twine::str((llvm::Twine *)v46, (_QWORD *)(v20 + 8));
      *(_QWORD *)(v20 + 32) = 22;
      *(_QWORD *)(v20 + 40) = v16;
      *(_BYTE *)(v20 + 48) = 1;
      *a5 = v20;
      v35 = off_1E81A6E70;
      if (v42 == 1 && v37)
        MEMORY[0x1CAA32F9C](v37, 0x1000C8077774924);
      if (SHIBYTE(v45) < 0)
        operator delete(__p[0]);
    }
    else
    {
      v21 = (void **)((char *)this + 32);
      *((_QWORD *)this + 5) = *((_QWORD *)this + 4);
      sub_1C4DB1D18((uint64_t)this + 32, v13 / v14);
      if (v13 >= v14)
      {
        do
        {
          RelocatedValue = llvm::DWARFDataExtractor::getRelocatedValue((uint64_t)a2, *((unsigned __int8 *)this + 26), a3, 0, 0);
          v23 = RelocatedValue;
          v25 = (unint64_t *)*((_QWORD *)this + 5);
          v24 = *((_QWORD *)this + 6);
          if ((unint64_t)v25 >= v24)
          {
            v27 = (unint64_t *)*v21;
            v28 = ((char *)v25 - (_BYTE *)*v21) >> 3;
            v29 = v28 + 1;
            if ((unint64_t)(v28 + 1) >> 61)
              abort();
            v30 = v24 - (_QWORD)v27;
            if (v30 >> 2 > v29)
              v29 = v30 >> 2;
            if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFF8)
              v31 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v31 = v29;
            if (v31)
            {
              if (v31 >> 61)
                sub_1C4764EE4();
              v32 = (char *)operator new(8 * v31);
            }
            else
            {
              v32 = 0;
            }
            v33 = (unint64_t *)&v32[8 * v28];
            *v33 = v23;
            v26 = v33 + 1;
            while (v25 != v27)
            {
              v34 = *--v25;
              *--v33 = v34;
            }
            *((_QWORD *)this + 4) = v33;
            *((_QWORD *)this + 5) = v26;
            *((_QWORD *)this + 6) = &v32[8 * v31];
            if (v27)
              operator delete(v27);
            v21 = (void **)((char *)this + 32);
          }
          else
          {
            *v25 = RelocatedValue;
            v26 = v25 + 1;
          }
          *((_QWORD *)this + 5) = v26;
          --v15;
        }
        while (v15);
      }
      *a5 = 0;
    }
  }
}

void sub_1C5490600(unsigned int a1@<W0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X4>, uint64_t *a6@<X8>)
{
  uint64_t v12;
  _OWORD *v13;
  llvm::raw_ostream *v14;
  _OWORD *v15;
  char v16;
  uint64_t i;
  unint64_t v18;
  size_t v19;
  const char *v20;
  llvm::raw_ostream *v21;
  _BYTE *v22;
  void **v23;
  uint64_t v24;
  void (**v25)(llvm::raw_ostream *__hidden);
  int v26;
  uint64_t v27;
  unint64_t v28;
  _OWORD *v29;
  char v30;
  uint64_t v31;
  int v32;
  void **v33;
  void *__p[2];
  uint64_t v35;
  void *v36;
  int64x2_t v37;
  __int16 v38;
  char v39;
  __int16 v40;

  if (sub_1C54916D8(a1))
  {
    *a6 = 0;
  }
  else
  {
    __p[0] = 0;
    __p[1] = 0;
    v35 = 0;
    v26 = 0;
    v30 = 0;
    v31 = 0;
    v25 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
    v33 = __p;
    v32 = 0;
    v29 = 0;
    v27 = 0;
    v28 = 0;
    v12 = *a5;
    v36 = &unk_1E8133270;
    v37.i64[0] = a4;
    v37.i64[1] = v12;
    llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v25, (uint64_t)&v36);
    v13 = v29;
    if (v28 - (unint64_t)v29 > 0x1E)
    {
      *v29 = *(_OWORD *)" has unsupported address size: ";
      *(_OWORD *)((char *)v13 + 15) = *(_OWORD *)"d address size: ";
      v29 = (_OWORD *)((char *)v29 + 31);
      v14 = (llvm::raw_ostream *)&v25;
    }
    else
    {
      v14 = llvm::raw_ostream::write((llvm::raw_ostream *)&v25, " has unsupported address size: ", 0x1FuLL);
    }
    sub_1C5E21910(v14, a1, 0, 0, 0);
    v15 = (_OWORD *)*((_QWORD *)v14 + 4);
    if (*((_QWORD *)v14 + 3) - (_QWORD)v15 > 0xFuLL)
    {
      *v15 = *(_OWORD *)" (supported are ";
      *((_QWORD *)v14 + 4) += 16;
    }
    else
    {
      llvm::raw_ostream::write(v14, " (supported are ", 0x10uLL);
    }
    v16 = 0;
    v36 = &v38;
    v38 = 1026;
    v39 = 8;
    v37 = vdupq_n_s64(3uLL);
    for (i = 24; i != 27; ++i)
    {
      v18 = *((unsigned __int8 *)&v36 + i);
      if ((v16 & 1) != 0)
        v19 = 2;
      else
        v19 = 0;
      if (v19 <= v28 - (unint64_t)v29)
      {
        if ((v16 & 1) != 0)
        {
          *(_WORD *)v29 = 8236;
          v29 = (_OWORD *)((char *)v29 + 2);
        }
        v21 = (llvm::raw_ostream *)&v25;
      }
      else
      {
        if ((v16 & 1) != 0)
          v20 = ", ";
        else
          v20 = 0;
        v21 = llvm::raw_ostream::write((llvm::raw_ostream *)&v25, v20, v19);
      }
      sub_1C5E21910(v21, v18, 0, 0, 0);
      v16 = 1;
    }
    if (v36 != &v38)
      free(v36);
    v22 = v29;
    if ((unint64_t)v29 >= v28)
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v25, 41);
    }
    else
    {
      v29 = (_OWORD *)((char *)v29 + 1);
      *v22 = 41;
    }
    v23 = v33;
    v24 = operator new();
    v40 = 260;
    v36 = v23;
    *(_QWORD *)v24 = off_1E81A0C88;
    llvm::Twine::str((llvm::Twine *)&v36, (_QWORD *)(v24 + 8));
    *(_QWORD *)(v24 + 32) = a2;
    *(_QWORD *)(v24 + 40) = a3;
    *(_BYTE *)(v24 + 48) = 1;
    *a6 = v24;
    v25 = off_1E81A6E70;
    if (v32 == 1 && v27)
      MEMORY[0x1CAA32F9C](v27, 0x1000C8077774924);
    if (SHIBYTE(v35) < 0)
      operator delete(__p[0]);
  }
}

char *llvm::DWARFDebugAddrTable::extractV5@<X0>(uint64_t a1@<X0>, const llvm::DWARFDataExtractor *a2@<X1>, unint64_t *a3@<X2>, int a4@<W3>, uint64_t a5@<X4>, uint64_t *a6@<X8>)
{
  unint64_t InitialLength;
  char v13;
  unint64_t v14;
  unint64_t v15;
  const std::error_category *v17;
  uint64_t v18;
  const char *v19;
  void **v20;
  uint64_t v21;
  uint64_t v22;
  char *result;
  const std::error_category *v24;
  std::string *v25;
  uint64_t v26;
  void **v27;
  uint64_t v28;
  unint64_t v29;
  _BOOL4 v30;
  unint64_t v31;
  char v32;
  int v33;
  uint64_t v34;
  char v35;
  const std::error_category *v36;
  uint64_t v37;
  char v38;
  void **v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  __int16 v43;
  void **v44;
  uint64_t v45;
  char *v46;
  std::string v47;
  char *v48;
  void (**v49)(llvm::raw_ostream *__hidden);
  int v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  char v54;
  uint64_t v55;
  int v56;
  void **p_p;
  void *__p;
  uint64_t v59;
  uint64_t v60;
  uint64_t (**v61)(llvm::format_object_base *__hidden);
  const char *v62;
  uint64_t v63;
  std::string *v64;
  __int16 v65;

  *(_QWORD *)(a1 + 8) = *a3;
  v48 = 0;
  InitialLength = llvm::DWARFDataExtractor::getInitialLength((uint64_t)a2, a3, &v48);
  *(_QWORD *)(a1 + 16) = InitialLength;
  *(_BYTE *)a1 = v13;
  if (v48)
  {
    *(_QWORD *)(a1 + 16) = 0;
    v24 = std::generic_category();
    v46 = v48;
    v48 = 0;
    sub_1C61D2548(&v46, &v47);
    if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v25 = &v47;
    else
      v25 = (std::string *)v47.__r_.__value_.__r.__words[0];
    __p = 0;
    v59 = 0;
    v60 = 0;
    v50 = 0;
    v54 = 0;
    v55 = 0;
    v49 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
    p_p = &__p;
    v56 = 0;
    v52 = 0;
    v53 = 0;
    v51 = 0;
    v26 = *(_QWORD *)(a1 + 8);
    v61 = (uint64_t (**)(llvm::format_object_base *__hidden))&unk_1E8169880;
    v62 = "parsing address table at offset 0x%llx: %s";
    v63 = v26;
    v64 = v25;
    llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v49, (uint64_t)&v61);
    v27 = p_p;
    v28 = operator new();
    v65 = 260;
    v61 = (uint64_t (**)(llvm::format_object_base *__hidden))v27;
    *(_QWORD *)v28 = off_1E81A0C88;
    llvm::Twine::str((llvm::Twine *)&v61, (_QWORD *)(v28 + 8));
    *(_QWORD *)(v28 + 32) = 22;
    *(_QWORD *)(v28 + 40) = v24;
    *(_BYTE *)(v28 + 48) = 1;
    *a6 = v28;
    v49 = off_1E81A6E70;
    if (v56 == 1 && v51)
      MEMORY[0x1CAA32F9C](v51, 0x1000C8077774924);
    if (SHIBYTE(v60) < 0)
      operator delete(__p);
    if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v47.__r_.__value_.__l.__data_);
    if (v46)
      (*(void (**)(char *))(*(_QWORD *)v46 + 8))(v46);
    goto LABEL_13;
  }
  v14 = InitialLength;
  v15 = *a3 + InitialLength;
  if (v15 < *a3 || *((_QWORD *)a2 + 1) <= v15 - 1)
  {
    *(_QWORD *)(a1 + 16) = 0;
    v17 = std::generic_category();
    __p = 0;
    v59 = 0;
    v60 = 0;
    v50 = 0;
    v54 = 0;
    v55 = 0;
    v49 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
    p_p = &__p;
    v56 = 0;
    v52 = 0;
    v53 = 0;
    v51 = 0;
    v18 = *(_QWORD *)(a1 + 8);
    v19 = "section is not large enough to contain an address table at offset 0x%llx with a unit_length value of 0x%llx";
LABEL_9:
    v61 = (uint64_t (**)(llvm::format_object_base *__hidden))&unk_1E8169BA8;
    v62 = v19;
    v63 = v18;
    v64 = (std::string *)v14;
    llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v49, (uint64_t)&v61);
    v20 = p_p;
    v21 = operator new();
    v65 = 260;
    v61 = (uint64_t (**)(llvm::format_object_base *__hidden))v20;
    *(_QWORD *)v21 = off_1E81A0C88;
    llvm::Twine::str((llvm::Twine *)&v61, (_QWORD *)(v21 + 8));
    v22 = 22;
    goto LABEL_10;
  }
  if (InitialLength <= 3)
  {
    *(_QWORD *)(a1 + 16) = 0;
    v17 = std::generic_category();
    __p = 0;
    v59 = 0;
    v60 = 0;
    v50 = 0;
    v54 = 0;
    v55 = 0;
    v49 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
    p_p = &__p;
    v56 = 0;
    v52 = 0;
    v53 = 0;
    v51 = 0;
    v18 = *(_QWORD *)(a1 + 8);
    v19 = "address table at offset 0x%llx has a unit_length value of 0x%llx, which is too small to contain a complete header";
    goto LABEL_9;
  }
  *(_WORD *)(a1 + 24) = sub_1C63871E8((uint64_t)a2, a3, 0);
  v29 = *a3;
  v30 = llvm::DataExtractor::prepareRead((uint64_t)a2, *a3, 1, 0);
  v31 = *a3;
  if (v30)
  {
    v32 = *(_BYTE *)(*(_QWORD *)a2 + v29);
    *a3 = ++v31;
  }
  else
  {
    v32 = 0;
  }
  *(_BYTE *)(a1 + 26) = v32;
  if (llvm::DataExtractor::prepareRead((uint64_t)a2, v31, 1, 0))
  {
    v33 = *(unsigned __int8 *)(*(_QWORD *)a2 + v31);
    ++*a3;
    *(_BYTE *)(a1 + 27) = v33;
    if (*(_WORD *)(a1 + 24) == 5)
    {
      if (v33)
      {
        v17 = std::generic_category();
        __p = 0;
        v59 = 0;
        v60 = 0;
        v50 = 0;
        v54 = 0;
        v55 = 0;
        v49 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
        p_p = &__p;
        v56 = 0;
        v52 = 0;
        v53 = 0;
        v51 = 0;
        v34 = *(_QWORD *)(a1 + 8);
        v35 = *(_BYTE *)(a1 + 27);
        v61 = &off_1E8169BE8;
        v62 = "address table at offset 0x%llx has unsupported segment selector size %hhu";
        v63 = v34;
        LOBYTE(v64) = v35;
LABEL_49:
        llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v49, (uint64_t)&v61);
        v44 = p_p;
        v21 = operator new();
        v65 = 260;
        v61 = (uint64_t (**)(llvm::format_object_base *__hidden))v44;
        *(_QWORD *)v21 = off_1E81A0C88;
        llvm::Twine::str((llvm::Twine *)&v61, (_QWORD *)(v21 + 8));
        v22 = 45;
LABEL_10:
        *(_QWORD *)(v21 + 32) = v22;
        *(_QWORD *)(v21 + 40) = v17;
        *(_BYTE *)(v21 + 48) = 1;
        *a6 = v21;
        v49 = off_1E81A6E70;
        if (v56 == 1 && v51)
          MEMORY[0x1CAA32F9C](v51, 0x1000C8077774924);
        if (SHIBYTE(v60) < 0)
          operator delete(__p);
        goto LABEL_13;
      }
      goto LABEL_38;
    }
LABEL_48:
    v17 = std::generic_category();
    __p = 0;
    v59 = 0;
    v60 = 0;
    v50 = 0;
    v54 = 0;
    v55 = 0;
    v49 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
    p_p = &__p;
    v56 = 0;
    v52 = 0;
    v53 = 0;
    v51 = 0;
    v42 = *(_QWORD *)(a1 + 8);
    v43 = *(_WORD *)(a1 + 24);
    v61 = (uint64_t (**)(llvm::format_object_base *__hidden))&unk_1E8169BC8;
    v62 = "address table at offset 0x%llx has unsupported version %hu";
    v63 = v42;
    LOWORD(v64) = v43;
    goto LABEL_49;
  }
  *(_BYTE *)(a1 + 27) = 0;
  if (*(_WORD *)(a1 + 24) != 5)
    goto LABEL_48;
LABEL_38:
  llvm::DWARFDebugAddrTable::extractAddresses((llvm::DWARFDebugAddrTable *)a1, a2, a3, v15, a6);
  if (!*a6)
  {
    if (a4 && *(unsigned __int8 *)(a1 + 26) != a4)
    {
      v36 = std::generic_category();
      __p = 0;
      v59 = 0;
      v60 = 0;
      v50 = 0;
      v54 = 0;
      v55 = 0;
      v49 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
      p_p = &__p;
      v56 = 0;
      v52 = 0;
      v53 = 0;
      v51 = 0;
      v37 = *(_QWORD *)(a1 + 8);
      v38 = *(_BYTE *)(a1 + 26);
      v61 = &off_1E8169C08;
      v62 = "address table at offset 0x%llx has address size %hhu which is different from CU address size %hhu";
      v63 = v37;
      LOBYTE(v64) = v38;
      BYTE1(v64) = a4;
      llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v49, (uint64_t)&v61);
      v39 = p_p;
      v40 = operator new();
      v65 = 260;
      v61 = (uint64_t (**)(llvm::format_object_base *__hidden))v39;
      *(_QWORD *)v40 = off_1E81A0C88;
      llvm::Twine::str((llvm::Twine *)&v61, (_QWORD *)(v40 + 8));
      *(_QWORD *)(v40 + 32) = 22;
      *(_QWORD *)(v40 + 40) = v36;
      *(_BYTE *)(v40 + 48) = 1;
      v45 = v40;
      v49 = off_1E81A6E70;
      if (v56 == 1)
        goto LABEL_51;
      while (1)
      {
        if (SHIBYTE(v60) < 0)
          operator delete(__p);
        v41 = *(_QWORD *)(a5 + 24);
        if (v41)
          break;
        sub_1C485C2F0();
LABEL_51:
        if (v51)
          MEMORY[0x1CAA32F9C](v51, 0x1000C8077774924);
      }
      (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v41 + 48))(v41, &v45);
      if (v45)
        (*(void (**)(uint64_t))(*(_QWORD *)v45 + 8))(v45);
    }
    *a6 = 0;
  }
LABEL_13:
  result = v48;
  if (v48)
    return (char *)(*(uint64_t (**)(char *))(*(_QWORD *)v48 + 8))(v48);
  return result;
}

void llvm::DWARFDebugAddrTable::extractPreStandard(llvm::DWARFDebugAddrTable *this@<X0>, const llvm::DWARFDataExtractor *a2@<X1>, unint64_t *a3@<X2>, __int16 a4@<W3>, char a5@<W4>, uint64_t *a6@<X8>)
{
  *((_QWORD *)this + 1) = *a3;
  *((_QWORD *)this + 2) = 0;
  *((_WORD *)this + 12) = a4;
  *((_BYTE *)this + 26) = a5;
  *((_BYTE *)this + 27) = 0;
  llvm::DWARFDebugAddrTable::extractAddresses(this, a2, a3, *((_QWORD *)a2 + 1), a6);
}

void llvm::DWARFDebugAddrTable::extract(llvm::DWARFDebugAddrTable *this@<X0>, llvm::DWARFDataExtractor *a2@<X1>, unint64_t *a3@<X2>, int a4@<W3>, int a5@<W4>, _QWORD *a6@<X5>, uint64_t *a7@<X8>)
{
  uint64_t v13;
  _QWORD *v14;
  void (*v15)(void);
  int v16;
  llvm::raw_ostream *v17;
  uint64_t v18;
  const char *v19;
  uint64_t v20[2];
  _QWORD v21[3];
  _QWORD *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if ((a4 - 1) <= 3)
  {
    *((_QWORD *)this + 1) = *a3;
    *((_QWORD *)this + 2) = 0;
    *((_WORD *)this + 12) = a4;
    *((_BYTE *)this + 26) = a5;
    *((_BYTE *)this + 27) = 0;
    llvm::DWARFDebugAddrTable::extractAddresses(this, a2, a3, *((_QWORD *)a2 + 1), a7);
    return;
  }
  if (!a4)
  {
    v20[0] = 22;
    v20[1] = (uint64_t)std::generic_category();
    v19 = "DWARF version is not defined in CU, assuming version 5";
    sub_1C5DF1730((_BYTE **)&v19, v20, &v18);
    v13 = a6[3];
    if (!v13)
    {
      sub_1C485C2F0();
      llvm::DWARFDebugAddrTable::dump(v16, v17);
      return;
    }
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v13 + 48))(v13, &v18);
    if (v18)
      (*(void (**)(uint64_t))(*(_QWORD *)v18 + 8))(v18);
  }
  v14 = (_QWORD *)a6[3];
  if (v14)
  {
    if (v14 == a6)
    {
      v22 = v21;
      (*(void (**)(_QWORD *, _QWORD *))(*a6 + 24))(a6, v21);
    }
    else
    {
      v22 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v14 + 16))(v14);
    }
  }
  else
  {
    v22 = 0;
  }
  llvm::DWARFDebugAddrTable::extractV5((uint64_t)this, a2, a3, a5, (uint64_t)v21, a7);
  if (v22 == v21)
  {
    v15 = *(void (**)(void))(v21[0] + 32);
  }
  else
  {
    if (!v22)
      return;
    v15 = *(void (**)(void))(*v22 + 40);
  }
  v15();
}

llvm::raw_ostream *llvm::DWARFDebugAddrTable::dump(llvm::raw_ostream *result, llvm::raw_ostream *this, uint64_t a3)
{
  llvm::raw_ostream *v4;
  uint64_t v5;
  int v6;
  void *v7;
  llvm::raw_ostream *v8;
  uint64_t v9;
  llvm::raw_ostream *v10;
  uint64_t v11;
  const char *v12;
  _DWORD *v13;
  uint64_t v14;
  llvm::raw_ostream *v15;
  uint64_t v16;
  llvm::raw_ostream *v17;
  uint64_t v18;
  _BYTE *v19;
  int v20;
  const char *v21;
  uint64_t v22;
  uint64_t *i;
  uint64_t *v24;
  uint64_t v25;
  _WORD *v26;
  _QWORD v27[3];
  _QWORD v28[3];
  _QWORD v29[3];
  void *v30;
  const char *v31;
  uint64_t v32;
  uint64_t v33;

  v4 = result;
  if (*(_BYTE *)(a3 + 20))
  {
    v5 = *((_QWORD *)result + 1);
    v30 = &unk_1E8133270;
    v31 = "0x%8.8llx: ";
    v32 = v5;
    result = llvm::raw_ostream::operator<<(this, (uint64_t)&v30);
  }
  if (*((_QWORD *)v4 + 2))
  {
    if (*(_BYTE *)v4)
      v6 = 16;
    else
      v6 = 8;
    v7 = (void *)*((_QWORD *)this + 4);
    if (*((_QWORD *)this + 3) - (_QWORD)v7 > 0x15uLL)
    {
      qmemcpy(v7, "Address table header: ", 22);
      *((_QWORD *)this + 4) += 22;
      v8 = this;
    }
    else
    {
      v8 = llvm::raw_ostream::write(this, "Address table header: ", 0x16uLL);
    }
    v9 = *((_QWORD *)v4 + 2);
    v30 = &unk_1E81698E0;
    v31 = "length = 0x%0*llx";
    LODWORD(v32) = v6;
    v33 = v9;
    v10 = llvm::raw_ostream::operator<<(v8, (uint64_t)&v30);
    v11 = *((_QWORD *)v10 + 4);
    if ((unint64_t)(*((_QWORD *)v10 + 3) - v11) > 0xA)
    {
      *(_DWORD *)(v11 + 7) = 540876916;
      *(_QWORD *)v11 = *(_QWORD *)", format = ";
      *((_QWORD *)v10 + 4) += 11;
    }
    else
    {
      v10 = llvm::raw_ostream::write(v10, ", format = ", 0xBuLL);
    }
    if (*(_BYTE *)v4)
    {
      if (*(_BYTE *)v4 != 1)
      {
LABEL_18:
        v14 = *((unsigned __int16 *)v4 + 12);
        v29[0] = &unk_1E8169900;
        v29[1] = ", version = 0x%4.4hx";
        v29[2] = v14;
        v15 = llvm::raw_ostream::operator<<(v10, (uint64_t)v29);
        v16 = *((unsigned __int8 *)v4 + 26);
        v28[0] = &unk_1E8145938;
        v28[1] = ", addr_size = 0x%2.2hhx";
        v28[2] = v16;
        v17 = llvm::raw_ostream::operator<<(v15, (uint64_t)v28);
        v18 = *((unsigned __int8 *)v4 + 27);
        v27[0] = &unk_1E8145938;
        v27[1] = ", seg_size = 0x%2.2hhx";
        v27[2] = v18;
        result = llvm::raw_ostream::operator<<(v17, (uint64_t)v27);
        v19 = (_BYTE *)*((_QWORD *)result + 4);
        if (*((_BYTE **)result + 3) == v19)
        {
          result = llvm::raw_ostream::write(result, "\n", 1uLL);
        }
        else
        {
          *v19 = 10;
          ++*((_QWORD *)result + 4);
        }
        goto LABEL_20;
      }
      v12 = "DWARF64";
    }
    else
    {
      v12 = "DWARF32";
    }
    v13 = (_DWORD *)*((_QWORD *)v10 + 4);
    if (*((_QWORD *)v10 + 3) - (_QWORD)v13 > 6uLL)
    {
      *v13 = *(_DWORD *)v12;
      *(_DWORD *)((char *)v13 + 3) = *(_DWORD *)(v12 + 3);
      *((_QWORD *)v10 + 4) += 7;
    }
    else
    {
      v10 = llvm::raw_ostream::write(v10, v12, 7uLL);
    }
    goto LABEL_18;
  }
LABEL_20:
  if (*((_QWORD *)v4 + 5) != *((_QWORD *)v4 + 4))
  {
    v20 = *((unsigned __int8 *)v4 + 26);
    if (v20 == 2)
    {
      v21 = "0x%4.4llx\n";
    }
    else if (v20 == 8)
    {
      v21 = "0x%16.16llx\n";
    }
    else
    {
      v21 = "0x%8.8llx\n";
    }
    v22 = *((_QWORD *)this + 4);
    if ((unint64_t)(*((_QWORD *)this + 3) - v22) > 8)
    {
      *(_BYTE *)(v22 + 8) = 10;
      *(_QWORD *)v22 = *(_QWORD *)"Addrs: [\n";
      *((_QWORD *)this + 4) += 9;
    }
    else
    {
      result = llvm::raw_ostream::write(this, "Addrs: [\n", 9uLL);
    }
    v24 = (uint64_t *)*((_QWORD *)v4 + 4);
    for (i = (uint64_t *)*((_QWORD *)v4 + 5); v24 != i; result = llvm::raw_ostream::operator<<(this, (uint64_t)&v30))
    {
      v25 = *v24++;
      v30 = &unk_1E8133270;
      v31 = v21;
      v32 = v25;
    }
    v26 = (_WORD *)*((_QWORD *)this + 4);
    if (*((_QWORD *)this + 3) - (_QWORD)v26 > 1uLL)
    {
      *v26 = 2653;
      *((_QWORD *)this + 4) += 2;
    }
    else
    {
      return llvm::raw_ostream::write(this, "]\n", 2uLL);
    }
  }
  return result;
}

void llvm::DWARFDebugAddrTable::getAddrEntry(llvm::DWARFDebugAddrTable *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const std::error_category *v8;
  uint64_t v9;
  void **v10;
  void (**v11)(llvm::raw_ostream *__hidden);
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  int v18;
  void **v19;
  void *__p[2];
  uint64_t v21;
  _QWORD v22[2];
  unsigned int v23;
  uint64_t v24;
  __int16 v25;

  v4 = *((_QWORD *)this + 4);
  if (a2 >= (unint64_t)((*((_QWORD *)this + 5) - v4) >> 3))
  {
    v8 = std::generic_category();
    __p[0] = 0;
    __p[1] = 0;
    v21 = 0;
    v12 = 0;
    v16 = 0;
    v17 = 0;
    v11 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
    v19 = __p;
    v18 = 0;
    v14 = 0;
    v15 = 0;
    v13 = 0;
    v9 = *((_QWORD *)this + 1);
    v22[0] = &unk_1E8169860;
    v22[1] = "Index %u is out of range of the address table at offset 0x%llx";
    v23 = a2;
    v24 = v9;
    llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v11, (uint64_t)v22);
    v10 = v19;
    v5 = operator new();
    v25 = 260;
    v22[0] = v10;
    *(_QWORD *)v5 = off_1E81A0C88;
    llvm::Twine::str((llvm::Twine *)v22, (_QWORD *)(v5 + 8));
    *(_QWORD *)(v5 + 32) = 22;
    *(_QWORD *)(v5 + 40) = v8;
    *(_BYTE *)(v5 + 48) = 1;
    v11 = off_1E81A6E70;
    if (v18 == 1 && v13)
      MEMORY[0x1CAA32F9C](v13, 0x1000C8077774924);
    if (SHIBYTE(v21) < 0)
      operator delete(__p[0]);
    *(_BYTE *)(a3 + 8) |= 1u;
  }
  else
  {
    *(_BYTE *)(a3 + 8) &= ~1u;
    v5 = *(_QWORD *)(v4 + 8 * a2);
  }
  *(_QWORD *)a3 = v5;
}

uint64_t llvm::DWARFDebugAddrTable::getFullLength(llvm::DWARFDebugAddrTable *this)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *((_QWORD *)this + 2);
  if (!v1)
    return 0;
  v2 = 12;
  if (!*(_BYTE *)this)
    v2 = 4;
  return v2 + v1;
}

BOOL sub_1C54916D8(unsigned int a1)
{
  _BYTE *v1;
  _BYTE *v2;
  __int16 v4;
  char v5;
  _BYTE v6[5];

  v4 = 1026;
  v5 = 8;
  v1 = v6;
  if (a1 <= 0xFF)
  {
    v2 = memchr(&v4, (char)a1, 3uLL);
    if (v2)
      v1 = v2;
  }
  return v1 - (_BYTE *)&v4 != 3;
}

uint64_t sub_1C5491740(uint64_t a1, char *__str, size_t __size)
{
  return snprintf(__str, __size, *(const char **)(a1 + 8), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), *(unsigned __int8 *)(a1 + 32));
}

uint64_t sub_1C549177C(uint64_t a1, char *__str, size_t __size)
{
  return snprintf(__str, __size, *(const char **)(a1 + 8), *(_QWORD *)(a1 + 16), *(unsigned __int8 *)(a1 + 24));
}

uint64_t sub_1C54917B0(uint64_t a1, char *__str, size_t __size)
{
  return snprintf(__str, __size, *(const char **)(a1 + 8), *(_QWORD *)(a1 + 16), *(unsigned __int8 *)(a1 + 24), *(unsigned __int8 *)(a1 + 25));
}

llvm::raw_ostream *llvm::DWARFDebugArangeSet::Descriptor::dump(llvm::DWARFDebugArangeSet::Descriptor *this, llvm::raw_ostream *a2, char a3)
{
  _BYTE *v6;
  uint64_t v7;
  char v8;
  _WORD *v9;
  uint64_t v10;
  llvm::raw_ostream *result;
  _BYTE *v12;
  uint64_t (**v13)(llvm::format_object_base *__hidden);
  const char *v14;
  char v15;
  char v16;
  uint64_t v17;

  v6 = (_BYTE *)*((_QWORD *)a2 + 4);
  if ((unint64_t)v6 >= *((_QWORD *)a2 + 3))
  {
    llvm::raw_ostream::write(a2, 91);
  }
  else
  {
    *((_QWORD *)a2 + 4) = v6 + 1;
    *v6 = 91;
  }
  v7 = *(_QWORD *)this;
  v8 = 2 * a3;
  v13 = &off_1E816A1C0;
  v14 = "0x%*.*llx";
  v15 = v8;
  v16 = v8;
  v17 = v7;
  llvm::raw_ostream::operator<<(a2, (uint64_t)&v13);
  v9 = (_WORD *)*((_QWORD *)a2 + 4);
  if (*((_QWORD *)a2 + 3) - (_QWORD)v9 > 1uLL)
  {
    *v9 = 8236;
    *((_QWORD *)a2 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(a2, ", ", 2uLL);
  }
  v10 = *((_QWORD *)this + 1) + *(_QWORD *)this;
  v13 = &off_1E816A1C0;
  v14 = "0x%*.*llx";
  v15 = v8;
  v16 = v8;
  v17 = v10;
  result = llvm::raw_ostream::operator<<(a2, (uint64_t)&v13);
  v12 = (_BYTE *)*((_QWORD *)a2 + 4);
  if ((unint64_t)v12 >= *((_QWORD *)a2 + 3))
    return llvm::raw_ostream::write(a2, 41);
  *((_QWORD *)a2 + 4) = v12 + 1;
  *v12 = 41;
  return result;
}

double llvm::DWARFDebugArangeSet::clear(llvm::DWARFDebugArangeSet *this)
{
  double result;

  *(_QWORD *)this = -1;
  result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((_QWORD *)this + 6) = *((_QWORD *)this + 5);
  return result;
}

char *llvm::DWARFDebugArangeSet::extract@<X0>(unint64_t *a1@<X0>, _QWORD *a2@<X1>, unint64_t *a3@<X2>, void (*a4)(uint64_t, void (***)(llvm::raw_ostream *__hidden this))@<X3>, uint64_t a5@<X4>, uint64_t *a6@<X8>)
{
  char v12;
  int v13;
  uint64_t v14;
  unint64_t v15;
  unsigned int v16;
  const std::error_category *v17;
  const std::error_category *v18;
  uint64_t v19;
  void **v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  void **v25;
  char *result;
  const std::error_category *v27;
  std::string *p_p;
  uint64_t v29;
  void **v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t Unsigned;
  unint64_t v38;
  unint64_t v39;
  const std::error_category *v40;
  uint64_t v41;
  void **v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t *v45;
  _QWORD *v46;
  unint64_t *v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  char *v52;
  unint64_t *v53;
  unint64_t *v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  char *v60;
  std::string __p;
  char *v62;
  void (**v63)(llvm::raw_ostream *__hidden);
  int v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  char v68;
  uint64_t v69;
  int v70;
  void **v71;
  void *v72;
  uint64_t v73;
  uint64_t v74;
  void **v75;
  const char *v76;
  uint64_t v77;
  unint64_t v78;
  __int16 v79;

  a1[6] = a1[5];
  *a1 = *a3;
  v62 = 0;
  a1[1] = llvm::DWARFDataExtractor::getInitialLength((uint64_t)a2, a3, &v62);
  *((_BYTE *)a1 + 16) = v12;
  *((_WORD *)a1 + 16) = sub_1C63871E8((uint64_t)a2, a3, (uint64_t *)&v62);
  if (*((_BYTE *)a1 + 16))
    v13 = 8;
  else
    v13 = 4;
  a1[3] = llvm::DataExtractor::getUnsigned(a2, a3, v13, (uint64_t *)&v62);
  *((_BYTE *)a1 + 34) = sub_1C5DEAEAC(a2, a3, (uint64_t *)&v62);
  *((_BYTE *)a1 + 35) = sub_1C5DEAEAC(a2, a3, (uint64_t *)&v62);
  if (!v62)
  {
    v14 = 12;
    if (!*((_BYTE *)a1 + 16))
      v14 = 4;
    v15 = v14 + a1[1];
    if (__CFADD__(v15, *a1) || a2[1] <= v15 + *a1 - 1)
    {
      v18 = std::generic_category();
      v72 = 0;
      v73 = 0;
      v74 = 0;
      v64 = 0;
      v68 = 0;
      v69 = 0;
      v63 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
      v71 = &v72;
      v70 = 0;
      v66 = 0;
      v67 = 0;
      v65 = 0;
      v23 = *a1;
      v24 = "the length of address range table at offset 0x%llx exceeds section size";
    }
    else
    {
      v16 = *((unsigned __int8 *)a1 + 34);
      v17 = std::generic_category();
      sub_1C5490600(v16, 22, (uint64_t)v17, (uint64_t)"address range table at offset 0x%llx", (uint64_t *)a1, a6);
      if (*a6)
        goto LABEL_17;
      if (*((_BYTE *)a1 + 35))
      {
        v18 = std::generic_category();
        v72 = 0;
        v73 = 0;
        v74 = 0;
        v64 = 0;
        v68 = 0;
        v69 = 0;
        v63 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
        v71 = &v72;
        v70 = 0;
        v66 = 0;
        v67 = 0;
        v65 = 0;
        v19 = *a1;
        v75 = (void **)&unk_1E8133270;
        v76 = "non-zero segment selector size in address range table at offset 0x%llx is not supported";
        v77 = v19;
        llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v63, (uint64_t)&v75);
        v20 = v71;
        v21 = operator new();
        v79 = 260;
        v75 = v20;
        *(_QWORD *)v21 = off_1E81A0C88;
        llvm::Twine::str((llvm::Twine *)&v75, (_QWORD *)(v21 + 8));
        v22 = 45;
        goto LABEL_14;
      }
      v32 = 2 * *((unsigned __int8 *)a1 + 34);
      if (v15 % v32)
      {
        v18 = std::generic_category();
        v72 = 0;
        v73 = 0;
        v74 = 0;
        v64 = 0;
        v68 = 0;
        v69 = 0;
        v63 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
        v71 = &v72;
        v70 = 0;
        v66 = 0;
        v67 = 0;
        v65 = 0;
        v23 = *a1;
        v24 = "address range table at offset 0x%llx has length that is not a multiple of the tuple size";
      }
      else
      {
        v33 = *a1;
        LODWORD(v34) = -2 * *((unsigned __int8 *)a1 + 34);
        do
          v34 = (v34 + v32);
        while (v34 < *(_DWORD *)a3 - *a1);
        if (v15 <= v34)
        {
          v18 = std::generic_category();
          v72 = 0;
          v73 = 0;
          v74 = 0;
          v64 = 0;
          v68 = 0;
          v69 = 0;
          v63 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
          v71 = &v72;
          v70 = 0;
          v66 = 0;
          v67 = 0;
          v65 = 0;
          v23 = *a1;
          v24 = "address range table at offset 0x%llx has an insufficient length to contain any entries";
        }
        else
        {
          v35 = v33 + v34;
          *a3 = v33 + v34;
          v36 = *a1 + v15;
          if (v33 + v34 < v36)
          {
            v56 = v36;
            do
            {
              Unsigned = llvm::DataExtractor::getUnsigned(a2, a3, *((unsigned __int8 *)a1 + 34), 0);
              v38 = llvm::DataExtractor::getUnsigned(a2, a3, *((unsigned __int8 *)a1 + 34), 0);
              v39 = v38;
              v59 = Unsigned;
              if (!(v38 | Unsigned))
              {
                if (*a3 == v36)
                {
                  *a6 = 0;
                  goto LABEL_17;
                }
                v57 = v38;
                v40 = std::generic_category();
                v72 = 0;
                v73 = 0;
                v64 = 0;
                v68 = 0;
                v69 = 0;
                v63 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
                v71 = &v72;
                v70 = 0;
                v66 = 0;
                v67 = 0;
                v65 = 0;
                v41 = *a1;
                v74 = 0;
                v75 = (void **)&unk_1E8169BA8;
                v76 = "address range table at offset 0x%llx has a premature terminator entry at offset 0x%llx";
                v77 = v41;
                v78 = v35;
                llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v63, (uint64_t)&v75);
                v42 = v71;
                v43 = operator new();
                v79 = 260;
                v75 = v42;
                *(_QWORD *)v43 = off_1E81A0C88;
                llvm::Twine::str((llvm::Twine *)&v75, (_QWORD *)(v43 + 8));
                *(_QWORD *)(v43 + 32) = 22;
                *(_QWORD *)(v43 + 40) = v40;
                *(_BYTE *)(v43 + 48) = 1;
                v63 = off_1E81A6E70;
                if (v70 == 1 && v65)
                  MEMORY[0x1CAA32F9C](v65, 0x1000C8077774924);
                if (SHIBYTE(v74) < 0)
                  operator delete(v72);
                v63 = (void (**)(llvm::raw_ostream *__hidden))v43;
                a4(a5, &v63);
                Unsigned = v59;
                if (v63)
                  (*((void (**)(_QWORD))*v63 + 1))(v63);
                v39 = v57;
              }
              v45 = (unint64_t *)a1[6];
              v44 = a1[7];
              if ((unint64_t)v45 >= v44)
              {
                v47 = (unint64_t *)a1[5];
                v48 = ((char *)v45 - (char *)v47) >> 4;
                v49 = v48 + 1;
                if ((unint64_t)(v48 + 1) >> 60)
                  abort();
                v50 = v44 - (_QWORD)v47;
                if (v50 >> 3 > v49)
                  v49 = v50 >> 3;
                if ((unint64_t)v50 >= 0x7FFFFFFFFFFFFFF0)
                  v49 = 0xFFFFFFFFFFFFFFFLL;
                v58 = v49;
                if (v49)
                {
                  if (v49 >> 60)
                    sub_1C4764EE4();
                  v51 = v39;
                  v52 = (char *)operator new(16 * v49);
                  v39 = v51;
                }
                else
                {
                  v52 = 0;
                }
                v53 = (unint64_t *)&v52[16 * v48];
                *v53 = v59;
                v53[1] = v39;
                v54 = v53;
                if (v45 == v47)
                {
                  v36 = v56;
                  v55 = v58;
                }
                else
                {
                  v36 = v56;
                  v55 = v58;
                  do
                  {
                    *((_OWORD *)v54 - 1) = *((_OWORD *)v45 - 1);
                    v54 -= 2;
                    v45 -= 2;
                  }
                  while (v45 != v47);
                  v45 = (unint64_t *)a1[5];
                }
                v46 = v53 + 2;
                a1[5] = (unint64_t)v54;
                a1[6] = (unint64_t)(v53 + 2);
                a1[7] = (unint64_t)&v52[16 * v55];
                if (v45)
                  operator delete(v45);
              }
              else
              {
                *v45 = Unsigned;
                v45[1] = v39;
                v46 = v45 + 2;
              }
              a1[6] = (unint64_t)v46;
              v35 = *a3;
            }
            while (*a3 < v36);
          }
          v18 = std::generic_category();
          v72 = 0;
          v73 = 0;
          v74 = 0;
          v64 = 0;
          v68 = 0;
          v69 = 0;
          v63 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
          v71 = &v72;
          v70 = 0;
          v66 = 0;
          v67 = 0;
          v65 = 0;
          v23 = *a1;
          v24 = "address range table at offset 0x%llx is not terminated by null entry";
        }
      }
    }
    v75 = (void **)&unk_1E8133270;
    v76 = v24;
    v77 = v23;
    llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v63, (uint64_t)&v75);
    v25 = v71;
    v21 = operator new();
    v79 = 260;
    v75 = v25;
    *(_QWORD *)v21 = off_1E81A0C88;
    llvm::Twine::str((llvm::Twine *)&v75, (_QWORD *)(v21 + 8));
    v22 = 22;
LABEL_14:
    *(_QWORD *)(v21 + 32) = v22;
    *(_QWORD *)(v21 + 40) = v18;
    *(_BYTE *)(v21 + 48) = 1;
    *a6 = v21;
    v63 = off_1E81A6E70;
    if (v70 == 1 && v65)
      MEMORY[0x1CAA32F9C](v65, 0x1000C8077774924);
    if (SHIBYTE(v74) < 0)
      operator delete(v72);
    goto LABEL_17;
  }
  v27 = std::generic_category();
  v60 = v62;
  v62 = 0;
  sub_1C61D2548(&v60, &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  v72 = 0;
  v73 = 0;
  v74 = 0;
  v64 = 0;
  v68 = 0;
  v69 = 0;
  v63 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
  v71 = &v72;
  v70 = 0;
  v66 = 0;
  v67 = 0;
  v65 = 0;
  v29 = *a1;
  v75 = (void **)&unk_1E8169880;
  v76 = "parsing address ranges table at offset 0x%llx: %s";
  v77 = v29;
  v78 = (unint64_t)p_p;
  llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v63, (uint64_t)&v75);
  v30 = v71;
  v31 = operator new();
  v79 = 260;
  v75 = v30;
  *(_QWORD *)v31 = off_1E81A0C88;
  llvm::Twine::str((llvm::Twine *)&v75, (_QWORD *)(v31 + 8));
  *(_QWORD *)(v31 + 32) = 22;
  *(_QWORD *)(v31 + 40) = v27;
  *(_BYTE *)(v31 + 48) = 1;
  *a6 = v31;
  v63 = off_1E81A6E70;
  if (v70 == 1 && v65)
    MEMORY[0x1CAA32F9C](v65, 0x1000C8077774924);
  if (SHIBYTE(v74) < 0)
    operator delete(v72);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (v60)
    (*(void (**)(char *))(*(_QWORD *)v60 + 8))(v60);
LABEL_17:
  result = v62;
  if (v62)
    return (char *)(*(uint64_t (**)(char *))(*(_QWORD *)v62 + 8))(v62);
  return result;
}

llvm::raw_ostream *llvm::DWARFDebugArangeSet::dump(llvm::DWARFDebugArangeSet *this, llvm::raw_ostream *a2)
{
  int v4;
  void *v5;
  llvm::raw_ostream *v6;
  uint64_t v7;
  llvm::raw_ostream *v8;
  uint64_t v9;
  const char *v10;
  _DWORD *v11;
  _WORD *v12;
  uint64_t v13;
  llvm::raw_ostream *v14;
  uint64_t v15;
  llvm::raw_ostream *v16;
  uint64_t v17;
  llvm::raw_ostream *v18;
  uint64_t v19;
  llvm::raw_ostream *result;
  llvm::DWARFDebugArangeSet::Descriptor *v21;
  llvm::DWARFDebugArangeSet::Descriptor *i;
  _BYTE *v23;
  _QWORD v24[3];
  _QWORD v25[3];
  _QWORD v26[2];
  int v27;
  uint64_t v28;
  _QWORD v29[3];
  _QWORD v30[2];
  int v31;
  uint64_t v32;

  if (*((_BYTE *)this + 16))
    v4 = 16;
  else
    v4 = 8;
  v5 = (void *)*((_QWORD *)a2 + 4);
  if (*((_QWORD *)a2 + 3) - (_QWORD)v5 > 0x15uLL)
  {
    qmemcpy(v5, "Address Range Header: ", 22);
    *((_QWORD *)a2 + 4) += 22;
    v6 = a2;
  }
  else
  {
    v6 = llvm::raw_ostream::write(a2, "Address Range Header: ", 0x16uLL);
  }
  v7 = *((_QWORD *)this + 1);
  v30[0] = &unk_1E81698E0;
  v30[1] = "length = 0x%0*llx, ";
  v31 = v4;
  v32 = v7;
  v8 = llvm::raw_ostream::operator<<(v6, (uint64_t)v30);
  v9 = *((_QWORD *)v8 + 4);
  if ((unint64_t)(*((_QWORD *)v8 + 3) - v9) > 8)
  {
    *(_BYTE *)(v9 + 8) = 32;
    *(_QWORD *)v9 = *(_QWORD *)"format = ";
    *((_QWORD *)v8 + 4) += 9;
  }
  else
  {
    v8 = llvm::raw_ostream::write(v8, "format = ", 9uLL);
  }
  if (*((_BYTE *)this + 16))
  {
    if (*((_BYTE *)this + 16) != 1)
    {
LABEL_14:
      v12 = (_WORD *)*((_QWORD *)v8 + 4);
      goto LABEL_16;
    }
    v10 = "DWARF64";
  }
  else
  {
    v10 = "DWARF32";
  }
  v11 = (_DWORD *)*((_QWORD *)v8 + 4);
  if (*((_QWORD *)v8 + 3) - (_QWORD)v11 <= 6uLL)
  {
    v8 = llvm::raw_ostream::write(v8, v10, 7uLL);
    goto LABEL_14;
  }
  *v11 = *(_DWORD *)v10;
  *(_DWORD *)((char *)v11 + 3) = *(_DWORD *)(v10 + 3);
  v12 = (_WORD *)(*((_QWORD *)v8 + 4) + 7);
  *((_QWORD *)v8 + 4) = v12;
LABEL_16:
  if (*((_QWORD *)v8 + 3) - (_QWORD)v12 > 1uLL)
  {
    *v12 = 8236;
    *((_QWORD *)v8 + 4) += 2;
  }
  else
  {
    v8 = llvm::raw_ostream::write(v8, ", ", 2uLL);
  }
  v13 = *((unsigned __int16 *)this + 16);
  v29[0] = &unk_1E8169900;
  v29[1] = "version = 0x%4.4x, ";
  v29[2] = v13;
  v14 = llvm::raw_ostream::operator<<(v8, (uint64_t)v29);
  v15 = *((_QWORD *)this + 3);
  v26[0] = &unk_1E81698E0;
  v26[1] = "cu_offset = 0x%0*llx, ";
  v27 = v4;
  v28 = v15;
  v16 = llvm::raw_ostream::operator<<(v14, (uint64_t)v26);
  v17 = *((unsigned __int8 *)this + 34);
  v25[0] = &unk_1E8145938;
  v25[1] = "addr_size = 0x%2.2x, ";
  v25[2] = v17;
  v18 = llvm::raw_ostream::operator<<(v16, (uint64_t)v25);
  v19 = *((unsigned __int8 *)this + 35);
  v24[0] = &unk_1E8145938;
  v24[1] = "seg_size = 0x%2.2x\n";
  v24[2] = v19;
  result = llvm::raw_ostream::operator<<(v18, (uint64_t)v24);
  v21 = (llvm::DWARFDebugArangeSet::Descriptor *)*((_QWORD *)this + 5);
  for (i = (llvm::DWARFDebugArangeSet::Descriptor *)*((_QWORD *)this + 6);
        v21 != i;
        v21 = (llvm::DWARFDebugArangeSet::Descriptor *)((char *)v21 + 16))
  {
    result = llvm::DWARFDebugArangeSet::Descriptor::dump(v21, a2, *((_BYTE *)this + 34));
    v23 = (_BYTE *)*((_QWORD *)a2 + 4);
    if ((unint64_t)v23 >= *((_QWORD *)a2 + 3))
    {
      result = llvm::raw_ostream::write(a2, 10);
    }
    else
    {
      *((_QWORD *)a2 + 4) = v23 + 1;
      *v23 = 10;
    }
  }
  return result;
}

void llvm::DWARFDebugAranges::extract(llvm::DWARFDebugAranges *a1, uint64_t a2, void (*a3)(uint64_t, void (***)(llvm::raw_ostream *__hidden this)), uint64_t a4)
{
  uint64_t v8;
  __int128 v9;
  unint64_t v10;
  unint64_t *v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  _OWORD v15[2];
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  __int128 v19;
  __int128 v20;
  void *__p;
  unint64_t *v22;
  uint64_t v23;
  unint64_t v24;
  _QWORD v25[3];

  if (*(_QWORD *)(a2 + 8))
  {
    v24 = 0;
    __p = 0;
    v22 = 0;
    v23 = 0;
    v18 = -1;
    v19 = 0u;
    v20 = 0u;
    v8 = (uint64_t)a1 + 48;
    while (1)
    {
      v9 = *(_OWORD *)(a2 + 16);
      v15[0] = *(_OWORD *)a2;
      v15[1] = v9;
      v16 = *(_QWORD *)(a2 + 32);
      llvm::DWARFDebugArangeSet::extract(&v18, v15, &v24, a3, a4, (uint64_t *)&v17);
      v10 = v17;
      if (v17)
        break;
      v11 = (unint64_t *)__p;
      v12 = v22;
      v17 = v20;
      while (v11 != v12)
      {
        v13 = *v11;
        v14 = v11[1];
        v11 += 2;
        llvm::DWARFDebugAranges::appendRange(a1, v17, v13, v14 + v13);
      }
      sub_1C61A7854(v8, (uint64_t *)&v17, (uint64_t)v25);
      if (*(_QWORD *)(a2 + 8) <= v24)
        goto LABEL_13;
    }
    v17 = 0;
    v25[0] = v10;
    a3(a4, (void (***)(llvm::raw_ostream *__hidden))v25);
    if (v25[0])
      (*(void (**)(_QWORD))(*(_QWORD *)v25[0] + 8))(v25[0]);
    if (v17)
      (*(void (**)(unint64_t))(*(_QWORD *)v17 + 8))(v17);
LABEL_13:
    if (__p)
    {
      v22 = (unint64_t *)__p;
      operator delete(__p);
    }
  }
}

void llvm::DWARFDebugAranges::appendRange(llvm::DWARFDebugAranges *this, uint64_t a2, unint64_t a3, unint64_t a4)
{
  char *v8;
  char *v9;
  char *v10;
  _BYTE *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  char *v17;
  char *v18;
  __int128 v19;
  char *v20;
  char *v21;
  _BYTE *v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  __int128 v30;
  char *v31;

  if (a3 < a4)
  {
    v9 = (char *)*((_QWORD *)this + 1);
    v8 = (char *)*((_QWORD *)this + 2);
    if (v9 >= v8)
    {
      v11 = *(_BYTE **)this;
      v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v9[-*(_QWORD *)this] >> 3);
      v13 = v12 + 1;
      if (v12 + 1 > 0xAAAAAAAAAAAAAAALL)
        goto LABEL_34;
      v14 = 0xAAAAAAAAAAAAAAABLL * ((v8 - v11) >> 3);
      if (2 * v14 > v13)
        v13 = 2 * v14;
      if (v14 >= 0x555555555555555)
        v15 = 0xAAAAAAAAAAAAAAALL;
      else
        v15 = v13;
      if (v15 > 0xAAAAAAAAAAAAAAALL)
        goto LABEL_35;
      v16 = 3 * v15;
      v17 = (char *)operator new(24 * v15);
      v18 = &v17[24 * v12];
      v8 = &v17[8 * v16];
      *(_QWORD *)v18 = a3;
      *((_QWORD *)v18 + 1) = a2;
      v18[16] = 1;
      v10 = v18 + 24;
      if (v9 == v11)
      {
        v20 = &v17[24 * v12];
      }
      else
      {
        do
        {
          v19 = *(_OWORD *)(v9 - 24);
          v20 = v18 - 24;
          *(v18 - 8) = *(v9 - 8);
          *(_OWORD *)(v18 - 24) = v19;
          v9 -= 24;
          v18 -= 24;
        }
        while (v9 != v11);
      }
      *(_QWORD *)this = v20;
      *((_QWORD *)this + 1) = v10;
      *((_QWORD *)this + 2) = v8;
      if (v11)
      {
        operator delete(v11);
        v8 = (char *)*((_QWORD *)this + 2);
      }
    }
    else
    {
      *(_QWORD *)v9 = a3;
      *((_QWORD *)v9 + 1) = a2;
      v9[16] = 1;
      v10 = v9 + 24;
    }
    *((_QWORD *)this + 1) = v10;
    if (v10 < v8)
    {
      *(_QWORD *)v10 = a4;
      *((_QWORD *)v10 + 1) = a2;
      v21 = v10 + 24;
      v10[16] = 0;
LABEL_32:
      *((_QWORD *)this + 1) = v21;
      return;
    }
    v22 = *(_BYTE **)this;
    v23 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v10[-*(_QWORD *)this] >> 3);
    v24 = v23 + 1;
    if (v23 + 1 <= 0xAAAAAAAAAAAAAAALL)
    {
      v25 = 0xAAAAAAAAAAAAAAABLL * ((v8 - v22) >> 3);
      if (2 * v25 > v24)
        v24 = 2 * v25;
      if (v25 >= 0x555555555555555)
        v26 = 0xAAAAAAAAAAAAAAALL;
      else
        v26 = v24;
      if (v26 <= 0xAAAAAAAAAAAAAAALL)
      {
        v27 = 3 * v26;
        v28 = (char *)operator new(24 * v26);
        v29 = &v28[24 * v23];
        *(_QWORD *)v29 = a4;
        *((_QWORD *)v29 + 1) = a2;
        v29[16] = 0;
        v21 = v29 + 24;
        if (v10 == v22)
        {
          v31 = &v28[24 * v23];
        }
        else
        {
          do
          {
            v30 = *(_OWORD *)(v10 - 24);
            v31 = v29 - 24;
            *(v29 - 8) = *(v10 - 8);
            *(_OWORD *)(v29 - 24) = v30;
            v10 -= 24;
            v29 -= 24;
          }
          while (v10 != v22);
        }
        *(_QWORD *)this = v31;
        *((_QWORD *)this + 1) = v21;
        *((_QWORD *)this + 2) = &v28[8 * v27];
        if (v22)
          operator delete(v22);
        goto LABEL_32;
      }
LABEL_35:
      sub_1C4764EE4();
    }
LABEL_34:
    abort();
  }
}

void llvm::DWARFDebugAranges::generate(llvm::DWARFDebugAranges *this, llvm::DWARFContext *a2)
{
  char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  char *v9;
  llvm::DWARFUnit **v10;
  llvm::DWARFUnit **v11;
  llvm::DWARFUnit **v12;
  unsigned int (*v13)(llvm::DWARFUnit **);
  char v14;
  unint64_t *v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD v20[3];
  llvm::DWARFUnit **v21;
  _QWORD v22[2];
  char v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  void *__p;
  unint64_t *v29;
  char v30;
  char v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 1) = *(_QWORD *)this;
  *((_QWORD *)this + 4) = *((_QWORD *)this + 3);
  v4 = (char *)this + 48;
  sub_1C61A86E8((_QWORD *)this + 6);
  if (a2)
  {
    v5 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)a2 + 65) + 96))(*((_QWORD *)a2 + 65));
    v7 = v6;
    v8 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)a2 + 65) + 40))(*((_QWORD *)a2 + 65));
    v22[0] = v5;
    v22[1] = v7;
    v23 = v8;
    v24 = 0;
    v9 = (char *)a2 + 456;
    v25 = 0;
    v26 = 0;
    llvm::DWARFDebugAranges::extract(this, (uint64_t)v22, (void (*)(uint64_t, void (***)(llvm::raw_ostream *__hidden)))sub_1C624E09C, (uint64_t)a2 + 456);
    sub_1C548BC00((uint64_t)a2, v20);
    v10 = (llvm::DWARFUnit **)v20[0];
    v11 = v21;
    if ((llvm::DWARFUnit **)v20[0] != v21)
    {
      v12 = (llvm::DWARFUnit **)v20[1];
      v13 = (unsigned int (*)(llvm::DWARFUnit **))v20[2];
      while (1)
      {
        v19 = 0;
        v19 = *((_QWORD *)*v10 + 3);
        sub_1C61A7854((uint64_t)v4, (uint64_t *)&v19, (uint64_t)&__p);
        if (!v30)
          goto LABEL_14;
        llvm::DWARFUnit::collectAddressRanges(*v10, (uint64_t)&__p);
        v14 = v31;
        v15 = (unint64_t *)__p;
        if ((v31 & 1) != 0)
          break;
        v16 = v29;
        if (__p != v29)
        {
          do
          {
            v17 = *v15;
            v18 = v15[1];
            v15 += 3;
            llvm::DWARFDebugAranges::appendRange(this, v19, v17, v18);
          }
          while (v15 != v16);
LABEL_8:
          v15 = (unint64_t *)__p;
          v14 = v31;
        }
        if ((v14 & 1) != 0)
        {
          __p = 0;
          if (v15)
            (*(void (**)(unint64_t *))(*v15 + 8))(v15);
        }
        else if (v15)
        {
          v29 = v15;
          operator delete(v15);
        }
LABEL_14:
        while (++v10 != v12)
        {
          if (v13(v10))
            goto LABEL_18;
        }
        v10 = v12;
LABEL_18:
        if (v10 == v11)
          goto LABEL_22;
      }
      v27 = __p;
      __p = 0;
      sub_1C624E09C((uint64_t)v9, &v27);
      if (v27)
        (*(void (**)(void *))(*(_QWORD *)v27 + 8))(v27);
      goto LABEL_8;
    }
LABEL_22:
    llvm::DWARFDebugAranges::construct(this);
  }
}

_QWORD *llvm::DWARFDebugAranges::clear(llvm::DWARFDebugAranges *this)
{
  *((_QWORD *)this + 1) = *(_QWORD *)this;
  *((_QWORD *)this + 4) = *((_QWORD *)this + 3);
  return sub_1C61A86E8((_QWORD *)this + 6);
}

void llvm::DWARFDebugAranges::construct(llvm::DWARFDebugAranges *this)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  char *v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  BOOL v11;
  unint64_t *v12;
  unint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t *v16;
  unint64_t v17;
  uint64_t **v18;
  uint64_t **v19;
  uint64_t *v20;
  unint64_t v21;
  uint64_t **v22;
  uint64_t *v23;
  unint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  unint64_t *v33;
  char *v34;
  __int128 v35;
  char *v36;
  char *v37;
  unint64_t *v38;
  unint64_t v39;
  uint64_t *v40;
  uint64_t **v41;
  uint64_t **v42;
  uint64_t *v43;
  unint64_t v44;
  uint64_t **v45;
  uint64_t *v46;
  void *v47;
  uint64_t *v48;
  unint64_t v49;
  unint64_t v50;
  BOOL v51;
  unint64_t v52;
  char *v53;
  uint64_t **v54;
  uint64_t *v55;
  uint64_t v56;

  v2 = *(_QWORD *)this;
  v3 = *((_QWORD *)this + 1);
  v4 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v3 - v2) >> 3));
  v55 = 0;
  v56 = 0;
  v54 = &v55;
  if (v3 == v2)
    v5 = 0;
  else
    v5 = v4;
  sub_1C5492E20(v2, v3, v5, 1);
  v6 = *(char **)this;
  v7 = (char *)*((_QWORD *)this + 1);
  if (*(char **)this != v7)
  {
    v8 = -1;
    v53 = (char *)*((_QWORD *)this + 1);
    do
    {
      v9 = *(_QWORD *)v6;
      v10 = *(_QWORD *)v6 - v8;
      v11 = *(_QWORD *)v6 <= v8 || v56 == 0;
      if (!v11)
      {
        v12 = (unint64_t *)*((_QWORD *)this + 3);
        v13 = (unint64_t *)*((_QWORD *)this + 4);
        if (v12 == v13)
          goto LABEL_24;
        v14 = *(v13 - 2);
        v15 = v14 ? *(v13 - 3) + v14 : -1;
        if (v15 != v8)
          goto LABEL_24;
        v16 = v55;
        if (!v55)
          goto LABEL_24;
        v17 = *(v13 - 1);
        v18 = &v55;
        do
        {
          v19 = v18;
          v20 = v16;
          v21 = v16[4];
          v22 = (uint64_t **)(v16 + 1);
          if (v21 >= v17)
          {
            v22 = (uint64_t **)v20;
            v18 = (uint64_t **)v20;
          }
          v16 = *v22;
        }
        while (v16);
        if (v18 == &v55)
          goto LABEL_24;
        if (v21 >= v17)
          v19 = (uint64_t **)v20;
        if (v17 >= (unint64_t)v19[4])
        {
          if (v9 != -1 && (v50 = *(v13 - 3), v51 = v9 > v50, v52 = v9 - v50, v51))
            *(v13 - 2) = v52;
          else
            *(v13 - 2) = 0;
        }
        else
        {
LABEL_24:
          v23 = (uint64_t *)v54;
          v24 = *((_QWORD *)this + 5);
          if ((unint64_t)v13 >= v24)
          {
            v27 = 0xAAAAAAAAAAAAAAABLL * (v13 - v12) + 1;
            if (v27 > 0xAAAAAAAAAAAAAAALL)
              abort();
            v28 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - (_QWORD)v12) >> 3);
            if (2 * v28 > v27)
              v27 = 2 * v28;
            if (v28 >= 0x555555555555555)
              v29 = 0xAAAAAAAAAAAAAAALL;
            else
              v29 = v27;
            if (v29 > 0xAAAAAAAAAAAAAAALL)
              sub_1C4764EE4();
            v30 = 3 * v29;
            v31 = (char *)operator new(24 * v29);
            v32 = v23[4];
            v33 = (unint64_t *)&v31[8 * (v13 - v12)];
            *v33 = v8;
            v33[1] = v10;
            v33[2] = v32;
            if (v12 == v13)
            {
              v36 = &v31[8 * (v13 - v12)];
            }
            else
            {
              v34 = &v31[8 * (v13 - v12)];
              do
              {
                v35 = *(_OWORD *)(v13 - 3);
                v36 = v34 - 24;
                *((_QWORD *)v34 - 1) = *(v13 - 1);
                *(_OWORD *)(v34 - 24) = v35;
                v13 -= 3;
                v34 -= 24;
              }
              while (v13 != v12);
            }
            v37 = &v31[8 * v30];
            v26 = v33 + 3;
            *((_QWORD *)this + 3) = v36;
            *((_QWORD *)this + 4) = v33 + 3;
            *((_QWORD *)this + 5) = v37;
            v7 = v53;
            if (v12)
              operator delete(v12);
          }
          else
          {
            v25 = (uint64_t)v54[4];
            *v13 = v8;
            v13[1] = v10;
            v13[2] = v25;
            v26 = v13 + 3;
          }
          *((_QWORD *)this + 4) = v26;
        }
      }
      v38 = (unint64_t *)(v6 + 8);
      if (v6[16])
      {
        sub_1C5493A70((uint64_t **)&v54, v38);
      }
      else
      {
        if (!v55)
          goto LABEL_52;
        v39 = *v38;
        v40 = v55;
        v41 = &v55;
        do
        {
          v42 = v41;
          v43 = v40;
          v44 = v40[4];
          v45 = (uint64_t **)(v40 + 1);
          if (v44 >= v39)
          {
            v45 = (uint64_t **)v43;
            v41 = (uint64_t **)v43;
          }
          v40 = *v45;
        }
        while (v40);
        if (v41 == &v55)
          goto LABEL_52;
        if (v44 >= v39)
          v42 = (uint64_t **)v43;
        if (v39 < (unint64_t)v42[4])
LABEL_52:
          v41 = &v55;
        v46 = v41[1];
        v47 = v41;
        if (v46)
        {
          do
          {
            v48 = v46;
            v46 = (uint64_t *)*v46;
          }
          while (v46);
        }
        else
        {
          do
          {
            v48 = (uint64_t *)*((_QWORD *)v47 + 2);
            v11 = *v48 == (_QWORD)v47;
            v47 = v48;
          }
          while (!v11);
        }
        if (v54 == v41)
          v54 = (uint64_t **)v48;
        --v56;
        sub_1C485B6E0(v55, (uint64_t *)v41);
        operator delete(v41);
      }
      v49 = *(_QWORD *)v6;
      v6 += 24;
      v8 = v49;
    }
    while (v6 != v7);
    v6 = *(char **)this;
  }
  *((_QWORD *)this + 1) = v6;
  if (*((char **)this + 2) != v6)
  {
    *(_QWORD *)this = 0;
    *((_QWORD *)this + 1) = 0;
    *((_QWORD *)this + 2) = 0;
    if (v6)
      operator delete(v6);
  }
  sub_1C47655E8((uint64_t)&v54, v55);
}

unint64_t llvm::DWARFDebugAranges::findAddress(llvm::DWARFDebugAranges *this, unint64_t a2)
{
  unint64_t *v2;
  unint64_t *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t *v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;

  v2 = (unint64_t *)*((_QWORD *)this + 3);
  v3 = (unint64_t *)*((_QWORD *)this + 4);
  if (v3 != v2)
  {
    v4 = 0xAAAAAAAAAAAAAAABLL * (v3 - v2);
    do
    {
      v5 = v4 >> 1;
      v6 = &v2[3 * (v4 >> 1)];
      v8 = *v6;
      v9 = v6[1];
      v7 = v6 + 3;
      v10 = v9 + v8;
      if (!v9)
        v10 = -1;
      v4 += ~(v4 >> 1);
      if (v10 <= a2)
        v2 = v7;
      else
        v4 = v5;
    }
    while (v4);
  }
  if (v2 == v3 || *v2 > a2)
    return -1;
  else
    return v2[2];
}

void sub_1C5492E20(uint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t *v15;
  char v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  __int128 v25;
  unint64_t v26;
  unint64_t v27;
  __int128 v28;
  BOOL v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  __int128 v34;
  unint64_t v35;
  unint64_t v36;
  __int128 v37;
  unint64_t v38;
  unint64_t v39;
  __int128 v40;
  unint64_t v41;
  BOOL v43;
  uint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int64_t v51;
  int64_t v52;
  int64_t v53;
  uint64_t v54;
  unint64_t v55;
  unint64_t v56;
  BOOL v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  __int128 v61;
  uint64_t v62;
  unint64_t v63;
  unint64_t v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  __int128 v70;
  __int128 v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t v74;
  unint64_t v75;
  uint64_t v76;
  __int128 v77;
  uint64_t v79;
  unint64_t v80;
  unint64_t v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;

__int128 *sub_1C5493600(__int128 *result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;
  __int128 v5;
  unint64_t v6;
  char v7;
  __int128 v8;
  unint64_t v9;
  char v10;
  __int128 v11;
  uint64_t v12;
  char v13;
  __int128 v14;
  uint64_t v15;
  char v16;
  char v17;

  v3 = *a2;
  v4 = *a3;
  if (*a2 >= *(_QWORD *)result)
  {
    if (v4 < v3)
    {
      v8 = *(_OWORD *)a2;
      v9 = a2[2];
      v10 = *((_BYTE *)a3 + 16);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((_BYTE *)a2 + 16) = v10;
      *((_BYTE *)a3 + 16) = v9;
      *(_OWORD *)a3 = v8;
      if (*a2 < *(_QWORD *)result)
      {
        v11 = *result;
        v12 = *((_QWORD *)result + 2);
        v13 = *((_BYTE *)a2 + 16);
        *result = *(_OWORD *)a2;
        *((_BYTE *)result + 16) = v13;
        *((_BYTE *)a2 + 16) = v12;
        *(_OWORD *)a2 = v11;
      }
    }
  }
  else
  {
    if (v4 >= v3)
    {
      v14 = *result;
      v15 = *((_QWORD *)result + 2);
      v16 = *((_BYTE *)a2 + 16);
      *result = *(_OWORD *)a2;
      *((_BYTE *)result + 16) = v16;
      *((_BYTE *)a2 + 16) = v15;
      *(_OWORD *)a2 = v14;
      if (*a3 >= *a2)
        return result;
      v5 = *(_OWORD *)a2;
      v6 = a2[2];
      v17 = *((_BYTE *)a3 + 16);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((_BYTE *)a2 + 16) = v17;
    }
    else
    {
      v5 = *result;
      v6 = *((_QWORD *)result + 2);
      v7 = *((_BYTE *)a3 + 16);
      *result = *(_OWORD *)a3;
      *((_BYTE *)result + 16) = v7;
    }
    *((_BYTE *)a3 + 16) = v6;
    *(_OWORD *)a3 = v5;
  }
  return result;
}

BOOL sub_1C54936F0(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  _BOOL8 result;
  __int128 *v6;
  __int128 v7;
  uint64_t v8;
  char v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;

  v4 = 0xAAAAAAAAAAAAAAABLL * ((a2 - a1) >> 3);
  result = 1;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      v6 = (__int128 *)(a2 - 24);
      if (*(_QWORD *)(a2 - 24) < *(_QWORD *)a1)
      {
        v7 = *(_OWORD *)a1;
        v8 = *(_QWORD *)(a1 + 16);
        v9 = *(_BYTE *)(a2 - 8);
        *(_OWORD *)a1 = *v6;
        *(_BYTE *)(a1 + 16) = v9;
        *(_BYTE *)(a2 - 8) = v8;
        *v6 = v7;
      }
      return result;
    case 3uLL:
      sub_1C5493600((__int128 *)a1, (unint64_t *)(a1 + 24), (unint64_t *)(a2 - 24));
      return 1;
    case 4uLL:
      sub_1C549389C(a1, (unint64_t *)(a1 + 24), (unint64_t *)(a1 + 48), a2 - 24);
      return 1;
    case 5uLL:
      sub_1C5493968((__n128 *)a1, (unint64_t *)(a1 + 24), (unint64_t *)(a1 + 48), (__n128 *)(a1 + 72), (__n128 *)(a2 - 24));
      return 1;
    default:
      v10 = (_QWORD *)(a1 + 48);
      sub_1C5493600((__int128 *)a1, (unint64_t *)(a1 + 24), (unint64_t *)(a1 + 48));
      v11 = a1 + 72;
      if (a1 + 72 == a2)
        return 1;
      v12 = 0;
      v13 = 0;
      break;
  }
  while (1)
  {
    v14 = *(_QWORD *)v11;
    if (*(_QWORD *)v11 < *v10)
    {
      v18 = *(_OWORD *)(v11 + 8);
      v15 = v12;
      while (1)
      {
        v16 = a1 + v15;
        *(_OWORD *)(v16 + 72) = *(_OWORD *)(a1 + v15 + 48);
        *(_BYTE *)(v16 + 88) = *(_BYTE *)(a1 + v15 + 64);
        if (v15 == -48)
          break;
        v15 -= 24;
        if (v14 >= *(_QWORD *)(v16 + 24))
        {
          v17 = a1 + v15 + 72;
          goto LABEL_12;
        }
      }
      v17 = a1;
LABEL_12:
      *(_QWORD *)v17 = v14;
      *(_QWORD *)(v17 + 8) = v18;
      *(_BYTE *)(v17 + 16) = BYTE8(v18);
      if (++v13 == 8)
        return v11 + 24 == a2;
    }
    v10 = (_QWORD *)v11;
    v12 += 24;
    v11 += 24;
    if (v11 == a2)
      return 1;
  }
}

__n128 sub_1C549389C(uint64_t a1, unint64_t *a2, unint64_t *a3, uint64_t a4)
{
  __n128 result;
  unint64_t v9;
  char v10;
  unint64_t v11;
  char v12;
  uint64_t v13;
  char v14;

  sub_1C5493600((__int128 *)a1, a2, a3);
  if (*(_QWORD *)a4 < *a3)
  {
    result = *(__n128 *)a3;
    v9 = a3[2];
    v10 = *(_BYTE *)(a4 + 16);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *((_BYTE *)a3 + 16) = v10;
    *(_BYTE *)(a4 + 16) = v9;
    *(__n128 *)a4 = result;
    if (*a3 < *a2)
    {
      result = *(__n128 *)a2;
      v11 = a2[2];
      v12 = *((_BYTE *)a3 + 16);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((_BYTE *)a2 + 16) = v12;
      *((_BYTE *)a3 + 16) = v11;
      *(__n128 *)a3 = result;
      if (*a2 < *(_QWORD *)a1)
      {
        result = *(__n128 *)a1;
        v13 = *(_QWORD *)(a1 + 16);
        v14 = *((_BYTE *)a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_BYTE *)(a1 + 16) = v14;
        *((_BYTE *)a2 + 16) = v13;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

__n128 sub_1C5493968(__n128 *a1, unint64_t *a2, unint64_t *a3, __n128 *a4, __n128 *a5)
{
  __n128 result;
  unint64_t v11;
  unsigned __int8 v12;
  unint64_t v13;
  unsigned __int8 v14;
  unint64_t v15;
  char v16;
  unint64_t v17;
  unsigned __int8 v18;

  result.n128_u64[0] = sub_1C549389C((uint64_t)a1, a2, a3, (uint64_t)a4).n128_u64[0];
  if (a5->n128_u64[0] < a4->n128_u64[0])
  {
    result = *a4;
    v11 = a4[1].n128_u64[0];
    v12 = a5[1].n128_u8[0];
    *a4 = *a5;
    a4[1].n128_u8[0] = v12;
    a5[1].n128_u8[0] = v11;
    *a5 = result;
    if (a4->n128_u64[0] < *a3)
    {
      result = *(__n128 *)a3;
      v13 = a3[2];
      v14 = a4[1].n128_u8[0];
      *(__n128 *)a3 = *a4;
      *((_BYTE *)a3 + 16) = v14;
      a4[1].n128_u8[0] = v13;
      *a4 = result;
      if (*a3 < *a2)
      {
        result = *(__n128 *)a2;
        v15 = a2[2];
        v16 = *((_BYTE *)a3 + 16);
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *((_BYTE *)a2 + 16) = v16;
        *((_BYTE *)a3 + 16) = v15;
        *(__n128 *)a3 = result;
        if (*a2 < a1->n128_u64[0])
        {
          result = *a1;
          v17 = a1[1].n128_u64[0];
          v18 = *((_BYTE *)a2 + 16);
          *a1 = *(__n128 *)a2;
          a1[1].n128_u8[0] = v18;
          *((_BYTE *)a2 + 16) = v17;
          *(__n128 *)a2 = result;
        }
      }
    }
  }
  return result;
}

uint64_t *sub_1C5493A70(uint64_t **a1, unint64_t *a2)
{
  uint64_t *v4;
  uint64_t *v5;
  unint64_t v6;
  uint64_t **v7;
  uint64_t *v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t *v11;

  v4 = (uint64_t *)operator new(0x28uLL);
  v5 = v4;
  v6 = *a2;
  v4[4] = *a2;
  v7 = a1 + 1;
  v8 = a1[1];
  if (v8)
  {
    do
    {
      while (1)
      {
        v7 = (uint64_t **)v8;
        if (v6 >= v8[4])
          break;
        v8 = (uint64_t *)*v8;
        v9 = v7;
        if (!*v7)
          goto LABEL_8;
      }
      v8 = (uint64_t *)v8[1];
    }
    while (v8);
    v9 = v7 + 1;
  }
  else
  {
    v9 = a1 + 1;
  }
LABEL_8:
  *v4 = 0;
  v4[1] = 0;
  v4[2] = (uint64_t)v7;
  *v9 = v4;
  v10 = (uint64_t *)**a1;
  v11 = v4;
  if (v10)
  {
    *a1 = v10;
    v11 = *v9;
  }
  sub_1C4768E74(a1[1], v11);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return v5;
}

double llvm::dwarf::UnwindLocation::createUnspecified@<D0>(uint64_t a1@<X8>)
{
  double result;

  result = NAN;
  *(_QWORD *)a1 = 0xFFFFFFFF00000000;
  *(_DWORD *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 12) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_BYTE *)(a1 + 64) = 0;
  return result;
}

double llvm::dwarf::UnwindLocation::createUndefined@<D0>(uint64_t a1@<X8>)
{
  double result;

  result = NAN;
  *(_QWORD *)a1 = 0xFFFFFFFF00000001;
  *(_DWORD *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 12) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_BYTE *)(a1 + 64) = 0;
  return result;
}

double llvm::dwarf::UnwindLocation::createSame@<D0>(uint64_t a1@<X8>)
{
  double result;

  result = NAN;
  *(_QWORD *)a1 = 0xFFFFFFFF00000002;
  *(_DWORD *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 12) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_BYTE *)(a1 + 64) = 0;
  return result;
}

double llvm::dwarf::UnwindLocation::createIsConstant@<D0>(llvm::dwarf::UnwindLocation *this@<X0>, uint64_t a2@<X8>)
{
  double result;

  result = NAN;
  *(_QWORD *)a2 = -4294967290;
  *(_DWORD *)(a2 + 8) = (_DWORD)this;
  *(_QWORD *)(a2 + 12) = 0;
  *(_BYTE *)(a2 + 24) = 0;
  *(_BYTE *)(a2 + 56) = 0;
  *(_BYTE *)(a2 + 64) = 0;
  return result;
}

double llvm::dwarf::UnwindLocation::createIsCFAPlusOffset@<D0>(llvm::dwarf::UnwindLocation *this@<X0>, uint64_t a2@<X8>)
{
  double result;

  result = NAN;
  *(_QWORD *)a2 = 0xFFFFFFFF00000003;
  *(_DWORD *)(a2 + 8) = (_DWORD)this;
  *(_QWORD *)(a2 + 12) = 0;
  *(_BYTE *)(a2 + 24) = 0;
  *(_BYTE *)(a2 + 56) = 0;
  *(_BYTE *)(a2 + 64) = 0;
  return result;
}

double llvm::dwarf::UnwindLocation::createAtCFAPlusOffset@<D0>(llvm::dwarf::UnwindLocation *this@<X0>, uint64_t a2@<X8>)
{
  double result;

  result = NAN;
  *(_QWORD *)a2 = 0xFFFFFFFF00000003;
  *(_DWORD *)(a2 + 8) = (_DWORD)this;
  *(_QWORD *)(a2 + 12) = 0;
  *(_BYTE *)(a2 + 24) = 0;
  *(_BYTE *)(a2 + 56) = 0;
  *(_BYTE *)(a2 + 64) = 1;
  return result;
}

uint64_t llvm::dwarf::UnwindLocation::createIsRegisterPlusOffset@<X0>(uint64_t result@<X0>, int a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  *(_DWORD *)a4 = 4;
  *(_DWORD *)(a4 + 4) = result;
  *(_DWORD *)(a4 + 8) = a2;
  *(_QWORD *)(a4 + 12) = a3;
  *(_BYTE *)(a4 + 24) = 0;
  *(_BYTE *)(a4 + 56) = 0;
  *(_BYTE *)(a4 + 64) = 0;
  return result;
}

uint64_t llvm::dwarf::UnwindLocation::createAtRegisterPlusOffset@<X0>(uint64_t result@<X0>, int a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  *(_DWORD *)a4 = 4;
  *(_DWORD *)(a4 + 4) = result;
  *(_DWORD *)(a4 + 8) = a2;
  *(_QWORD *)(a4 + 12) = a3;
  *(_BYTE *)(a4 + 24) = 0;
  *(_BYTE *)(a4 + 56) = 0;
  *(_BYTE *)(a4 + 64) = 1;
  return result;
}

double llvm::dwarf::UnwindLocation::createIsDWARFExpression@<D0>(_OWORD *a1@<X0>, uint64_t a2@<X8>)
{
  __int128 v2;
  double result;

  v2 = a1[1];
  *(_OWORD *)(a2 + 24) = *a1;
  *(_OWORD *)(a2 + 40) = v2;
  result = NAN;
  *(_QWORD *)a2 = -4294967291;
  *(_DWORD *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 12) = 0;
  *(_BYTE *)(a2 + 16) = 0;
  *(_BYTE *)(a2 + 56) = 1;
  *(_BYTE *)(a2 + 64) = 0;
  return result;
}

double llvm::dwarf::UnwindLocation::createAtDWARFExpression@<D0>(_OWORD *a1@<X0>, uint64_t a2@<X8>)
{
  __int128 v2;
  double result;

  v2 = a1[1];
  *(_OWORD *)(a2 + 24) = *a1;
  *(_OWORD *)(a2 + 40) = v2;
  result = NAN;
  *(_QWORD *)a2 = -4294967291;
  *(_DWORD *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 12) = 0;
  *(_BYTE *)(a2 + 16) = 0;
  *(_BYTE *)(a2 + 56) = 1;
  *(_BYTE *)(a2 + 64) = 1;
  return result;
}

llvm::raw_ostream *llvm::dwarf::UnwindLocation::dump(llvm::raw_ostream *this, llvm::raw_ostream *a2, const llvm::MCRegisterInfo *a3, int a4)
{
  uint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  const char *v10;
  llvm::raw_ostream *v11;
  size_t v12;
  uint64_t v13;
  _DWORD *v14;
  uint64_t v15;
  unint64_t v16;
  _BYTE *v17;
  llvm::raw_ostream *v18;
  unint64_t v19;
  llvm::raw_ostream *v20;
  int v21;
  _BYTE *v22;
  void *v23;
  int v24;
  _BYTE *v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  _QWORD v29[4];
  _QWORD v30[5];

  v7 = (uint64_t)this;
  v30[4] = *MEMORY[0x1E0C80C00];
  if (*((_BYTE *)this + 64))
  {
    v8 = (_BYTE *)*((_QWORD *)a2 + 4);
    if ((unint64_t)v8 >= *((_QWORD *)a2 + 3))
    {
      this = llvm::raw_ostream::write(a2, 91);
    }
    else
    {
      *((_QWORD *)a2 + 4) = v8 + 1;
      *v8 = 91;
    }
  }
  switch(*(_DWORD *)v7)
  {
    case 0:
      v9 = *((_QWORD *)a2 + 4);
      if ((unint64_t)(*((_QWORD *)a2 + 3) - v9) <= 0xA)
      {
        v10 = "unspecified";
        v11 = a2;
        v12 = 11;
        goto LABEL_12;
      }
      *(_DWORD *)(v9 + 7) = 1684367718;
      *(_QWORD *)v9 = *(_QWORD *)"unspecified";
      v26 = *((_QWORD *)a2 + 4) + 11;
      goto LABEL_45;
    case 1:
      v13 = *((_QWORD *)a2 + 4);
      if ((unint64_t)(*((_QWORD *)a2 + 3) - v13) <= 8)
      {
        v10 = "undefined";
        v11 = a2;
        v12 = 9;
        goto LABEL_12;
      }
      *(_BYTE *)(v13 + 8) = 100;
      *(_QWORD *)v13 = *(_QWORD *)"undefined";
      v26 = *((_QWORD *)a2 + 4) + 9;
      goto LABEL_45;
    case 2:
      v14 = (_DWORD *)*((_QWORD *)a2 + 4);
      if (*((_QWORD *)a2 + 3) - (_QWORD)v14 > 3uLL)
      {
        *v14 = 1701667187;
        v26 = *((_QWORD *)a2 + 4) + 4;
LABEL_45:
        *((_QWORD *)a2 + 4) = v26;
      }
      else
      {
        v10 = "same";
        v11 = a2;
        v12 = 4;
LABEL_12:
        this = llvm::raw_ostream::write(v11, v10, v12);
      }
      goto LABEL_35;
    case 3:
      v15 = *((_QWORD *)a2 + 4);
      if ((unint64_t)(*((_QWORD *)a2 + 3) - v15) > 2)
      {
        *(_BYTE *)(v15 + 2) = 65;
        *(_WORD *)v15 = 17987;
        *((_QWORD *)a2 + 4) += 3;
      }
      else
      {
        this = llvm::raw_ostream::write(a2, "CFA", 3uLL);
      }
      v16 = *(int *)(v7 + 8);
      if (!(_DWORD)v16)
        goto LABEL_35;
      if ((int)v16 > 0)
      {
        v17 = (_BYTE *)*((_QWORD *)a2 + 4);
        if (*((_BYTE **)a2 + 3) == v17)
        {
          llvm::raw_ostream::write(a2, "+", 1uLL);
        }
        else
        {
          *v17 = 43;
          ++*((_QWORD *)a2 + 4);
        }
LABEL_19:
        v16 = *(int *)(v7 + 8);
        if ((v16 & 0x80000000) == 0)
        {
          v18 = a2;
          goto LABEL_33;
        }
      }
      v16 = -(uint64_t)v16;
      v18 = a2;
      v24 = 1;
      goto LABEL_34;
    case 4:
      this = sub_1C54940BC(a2, a3, a4, *(_DWORD *)(v7 + 4));
      v19 = *(int *)(v7 + 8);
      if ((_DWORD)v19)
      {
        if ((v19 & 0x80000000) != 0)
        {
LABEL_23:
          v19 = -(uint64_t)v19;
          v20 = a2;
          v21 = 1;
          goto LABEL_29;
        }
      }
      else if (!*(_BYTE *)(v7 + 16))
      {
        goto LABEL_35;
      }
      v22 = (_BYTE *)*((_QWORD *)a2 + 4);
      if (*((_BYTE **)a2 + 3) == v22)
      {
        llvm::raw_ostream::write(a2, "+", 1uLL);
      }
      else
      {
        *v22 = 43;
        ++*((_QWORD *)a2 + 4);
      }
      v19 = *(int *)(v7 + 8);
      if ((v19 & 0x80000000) != 0)
        goto LABEL_23;
      v20 = a2;
      v21 = 0;
LABEL_29:
      this = sub_1C5E21910(v20, v19, 0, 0, v21);
      if (*(_BYTE *)(v7 + 16))
      {
        v23 = (void *)*((_QWORD *)a2 + 4);
        if (*((_QWORD *)a2 + 3) - (_QWORD)v23 > 0xCuLL)
        {
          qmemcpy(v23, " in addrspace", 13);
          *((_QWORD *)a2 + 4) += 13;
          v18 = a2;
        }
        else
        {
          v18 = llvm::raw_ostream::write(a2, " in addrspace", 0xDuLL);
        }
        v16 = *(unsigned int *)(v7 + 12);
LABEL_33:
        v24 = 0;
LABEL_34:
        this = sub_1C5E21910(v18, v16, 0, 0, v24);
      }
LABEL_35:
      if (*(_BYTE *)(v7 + 64))
      {
        v25 = (_BYTE *)*((_QWORD *)a2 + 4);
        if ((unint64_t)v25 >= *((_QWORD *)a2 + 3))
        {
          return llvm::raw_ostream::write(a2, 93);
        }
        else
        {
          *((_QWORD *)a2 + 4) = v25 + 1;
          *v25 = 93;
        }
      }
      return this;
    case 5:
      v29[2] = 0;
      v30[2] = 0;
      *(_QWORD *)&v27 = -1;
      *((_QWORD *)&v27 + 1) = 0x1040000FFFFFFFFLL;
      v28 = 0;
      v29[0] = &unk_1E8169658;
      v29[1] = llvm::WithColor::defaultErrorHandler;
      v29[3] = v29;
      v30[0] = &unk_1E8169658;
      v30[1] = llvm::WithColor::defaultWarningHandler;
      v30[3] = v30;
      llvm::DWARFExpression::print(v7 + 24, a2, &v27, a3, 0, a4);
      this = (llvm::raw_ostream *)sub_1C624C568(&v27);
      goto LABEL_35;
    case 6:
      goto LABEL_19;
    default:
      goto LABEL_35;
  }
}

llvm::raw_ostream *sub_1C54940BC(llvm::raw_ostream *this, llvm::MCRegisterInfo *a2, int a3, unsigned int a4)
{
  uint64_t v6;
  llvm::raw_ostream *result;
  uint64_t LLVMRegNum;
  uint64_t v10;
  const char *v11;
  unint64_t v12;

  if (a2
    && (LLVMRegNum = llvm::MCRegisterInfo::getLLVMRegNum(a2, a4, a3), (LLVMRegNum & 0xFF00000000) != 0)
    && (v10 = *((_QWORD *)a2 + 8)) != 0)
  {
    v11 = (const char *)(v10 + *(unsigned int *)(*(_QWORD *)a2 + 24 * LLVMRegNum));
    v12 = strlen(v11);
    result = (llvm::raw_ostream *)*((_QWORD *)this + 4);
    if (v12 <= *((_QWORD *)this + 3) - (_QWORD)result)
    {
      if (v12)
      {
        result = (llvm::raw_ostream *)memcpy(result, v11, v12);
        *((_QWORD *)this + 4) += v12;
      }
    }
    else
    {
      return llvm::raw_ostream::write(this, v11, v12);
    }
  }
  else
  {
    v6 = *((_QWORD *)this + 4);
    if ((unint64_t)(*((_QWORD *)this + 3) - v6) > 2)
    {
      *(_BYTE *)(v6 + 2) = 103;
      *(_WORD *)v6 = 25970;
      *((_QWORD *)this + 4) += 3;
    }
    else
    {
      this = llvm::raw_ostream::write(this, "reg", 3uLL);
    }
    return sub_1C5E21910(this, a4, 0, 0, 0);
  }
  return result;
}

llvm::raw_ostream *llvm::dwarf::operator<<(llvm::raw_ostream *a1, llvm::dwarf::UnwindLocation *this)
{
  llvm::dwarf::UnwindLocation::dump(this, a1, 0, 0);
  return a1;
}

BOOL llvm::dwarf::UnwindLocation::operator==(int *a1, uint64_t a2)
{
  int v2;
  _BOOL8 result;
  int v6;
  int v7;

  v2 = *a1;
  if (*a1 != *(_DWORD *)a2)
    return 0;
  result = 1;
  switch(v2)
  {
    case 0:
    case 1:
    case 2:
      return result;
    case 3:
      goto LABEL_4;
    case 4:
      if (a1[1] != *(_DWORD *)(a2 + 4))
        return 0;
LABEL_4:
      if (a1[2] != *(_DWORD *)(a2 + 8))
        return 0;
      goto LABEL_8;
    case 5:
      result = llvm::DWARFExpression::operator==((uint64_t)(a1 + 6), a2 + 24);
      if (!result)
        return result;
LABEL_8:
      v6 = *((unsigned __int8 *)a1 + 64);
      v7 = *(unsigned __int8 *)(a2 + 64);
LABEL_10:
      result = v6 == v7;
      break;
    case 6:
      v6 = a1[2];
      v7 = *(_DWORD *)(a2 + 8);
      goto LABEL_10;
    default:
      return 0;
  }
  return result;
}

llvm::raw_ostream *llvm::dwarf::RegisterLocations::dump(llvm::raw_ostream *this, llvm::raw_ostream *a2, const llvm::MCRegisterInfo *a3, int a4)
{
  _QWORD *v4;
  _QWORD *v5;
  char v9;
  _WORD *v10;
  _BYTE *v11;
  _QWORD *v12;
  _QWORD *v13;
  BOOL v14;

  v4 = (_QWORD *)((char *)this + 8);
  v5 = *(_QWORD **)this;
  if (*(llvm::raw_ostream **)this != (llvm::raw_ostream *)((char *)this + 8))
  {
    v9 = 1;
    do
    {
      if ((v9 & 1) == 0)
      {
        v10 = (_WORD *)*((_QWORD *)a2 + 4);
        if (*((_QWORD *)a2 + 3) - (_QWORD)v10 > 1uLL)
        {
          *v10 = 8236;
          *((_QWORD *)a2 + 4) += 2;
        }
        else
        {
          llvm::raw_ostream::write(a2, ", ", 2uLL);
        }
      }
      sub_1C54940BC(a2, a3, a4, *((_DWORD *)v5 + 8));
      v11 = (_BYTE *)*((_QWORD *)a2 + 4);
      if ((unint64_t)v11 >= *((_QWORD *)a2 + 3))
      {
        llvm::raw_ostream::write(a2, 61);
      }
      else
      {
        *((_QWORD *)a2 + 4) = v11 + 1;
        *v11 = 61;
      }
      this = llvm::dwarf::UnwindLocation::dump((llvm::raw_ostream *)(v5 + 5), a2, a3, a4);
      v12 = (_QWORD *)v5[1];
      if (v12)
      {
        do
        {
          v13 = v12;
          v12 = (_QWORD *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          v13 = (_QWORD *)v5[2];
          v14 = *v13 == (_QWORD)v5;
          v5 = v13;
        }
        while (!v14);
      }
      v9 = 0;
      v5 = v13;
    }
    while (v13 != v4);
  }
  return this;
}

llvm::raw_ostream *llvm::dwarf::operator<<(llvm::raw_ostream *a1, llvm::dwarf::RegisterLocations *this)
{
  llvm::dwarf::RegisterLocations::dump(this, a1, 0, 0);
  return a1;
}

llvm::raw_ostream *llvm::dwarf::UnwindRow::dump(llvm::dwarf::UnwindRow *this, llvm::raw_ostream *a2, const llvm::MCRegisterInfo *a3, int a4, int a5)
{
  uint64_t v9;
  _DWORD *v10;
  llvm::raw_ostream *result;
  llvm::raw_ostream *v12;
  _WORD *v13;
  _BYTE *v14;
  _QWORD v15[3];

  llvm::raw_ostream::indent(a2, 2 * a5);
  if (*((_BYTE *)this + 8))
  {
    v9 = *(_QWORD *)this;
    v15[0] = &unk_1E8133270;
    v15[1] = "0x%llx: ";
    v15[2] = v9;
    llvm::raw_ostream::operator<<(a2, (uint64_t)v15);
  }
  v10 = (_DWORD *)*((_QWORD *)a2 + 4);
  if (*((_QWORD *)a2 + 3) - (_QWORD)v10 > 3uLL)
  {
    *v10 = 1027688003;
    *((_QWORD *)a2 + 4) += 4;
  }
  else
  {
    llvm::raw_ostream::write(a2, "CFA=", 4uLL);
  }
  result = llvm::dwarf::UnwindLocation::dump((llvm::dwarf::UnwindRow *)((char *)this + 16), a2, a3, a4);
  if (*((_QWORD *)this + 13))
  {
    v12 = (llvm::dwarf::UnwindRow *)((char *)this + 88);
    v13 = (_WORD *)*((_QWORD *)a2 + 4);
    if (*((_QWORD *)a2 + 3) - (_QWORD)v13 > 1uLL)
    {
      *v13 = 8250;
      *((_QWORD *)a2 + 4) += 2;
    }
    else
    {
      llvm::raw_ostream::write(a2, ": ", 2uLL);
    }
    result = llvm::dwarf::RegisterLocations::dump(v12, a2, a3, a4);
  }
  v14 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v14)
    return llvm::raw_ostream::write(a2, "\n", 1uLL);
  *v14 = 10;
  ++*((_QWORD *)a2 + 4);
  return result;
}

llvm::raw_ostream *llvm::dwarf::operator<<(llvm::raw_ostream *a1, llvm::dwarf::UnwindRow *this)
{
  llvm::dwarf::UnwindRow::dump(this, a1, 0, 0, 0);
  return a1;
}

llvm::raw_ostream *llvm::dwarf::UnwindTable::dump(llvm::raw_ostream *this, llvm::raw_ostream *a2, const llvm::MCRegisterInfo *a3, int a4, int a5)
{
  llvm::dwarf::UnwindRow *v5;
  llvm::dwarf::UnwindRow *v6;

  v5 = *(llvm::dwarf::UnwindRow **)this;
  v6 = (llvm::dwarf::UnwindRow *)*((_QWORD *)this + 1);
  if (*(llvm::dwarf::UnwindRow **)this != v6)
  {
    do
    {
      this = llvm::dwarf::UnwindRow::dump(v5, a2, a3, a4, a5);
      v5 = (llvm::dwarf::UnwindRow *)((char *)v5 + 112);
    }
    while (v5 != v6);
  }
  return this;
}

llvm::raw_ostream *llvm::dwarf::operator<<(llvm::raw_ostream *a1, llvm::dwarf::UnwindRow **a2)
{
  llvm::dwarf::UnwindRow *v3;
  llvm::dwarf::UnwindRow *v4;

  v3 = *a2;
  v4 = a2[1];
  while (v3 != v4)
  {
    llvm::dwarf::UnwindRow::dump(v3, a1, 0, 0, 0);
    v3 = (llvm::dwarf::UnwindRow *)((char *)v3 + 112);
  }
  return a1;
}

void llvm::dwarf::UnwindTable::create(_QWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  const llvm::dwarf::CFIProgram *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  const std::error_category *v10;
  unint64_t v11;
  __int128 *v12;
  uint64_t v13;
  uint64_t v14;
  void ***v15;
  char *v16;
  unint64_t v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  char v28;
  _QWORD **v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t *v32;
  _QWORD *v33;
  uint64_t v34;
  __int128 *v35;
  char *v36;
  unint64_t v37;
  __int128 v38;

  v4 = a1[13];
  if (v4)
  {
    v6 = *(_QWORD *)(v4 + 32);
    v7 = *(_QWORD *)(v4 + 40);
    v5 = (const llvm::dwarf::CFIProgram *)(v4 + 32);
    if (v6 == v7 && a1[4] == a1[5])
    {
      *((_QWORD *)&v24 + 1) = 0;
      *(_QWORD *)&v25 = 0;
      *(_BYTE *)(a2 + 40) &= ~1u;
      *(_QWORD *)a2 = 0;
      *(_QWORD *)(a2 + 8) = 0;
      *(_QWORD *)&v24 = 0;
      v23 = 0uLL;
      *(_QWORD *)(a2 + 24) = 0;
      *(_QWORD *)(a2 + 32) = 0;
      *(_QWORD *)(a2 + 16) = 0;
      v35 = &v23;
      v15 = (void ***)&v35;
    }
    else
    {
      v35 = 0;
      v36 = 0;
      *(_QWORD *)&v24 = 0xFFFFFFFF00000000;
      DWORD2(v24) = 0;
      BYTE12(v24) = 0;
      LOBYTE(v25) = 0;
      BYTE8(v25) = 0;
      BYTE8(v27) = 0;
      v28 = 0;
      v30 = 0;
      v31 = 0;
      v29 = &v30;
      v8 = a1[12];
      *(_QWORD *)&v23 = a1[11];
      BYTE8(v23) = 1;
      v37 = 0;
      *(_QWORD *)&v38 = v8 + v23;
      BYTE8(v38) = 1;
      llvm::dwarf::UnwindTable::parseRows((llvm::dwarf::UnwindTable *)&v35, v5, (llvm::dwarf::UnwindRow *)&v23, 0, (uint64_t *)&v32);
      v9 = v32;
      if (v32)
      {
        *(_BYTE *)(a2 + 40) |= 1u;
        *(_QWORD *)a2 = v9;
      }
      else
      {
        sub_1C5499E30(&v32, &v29);
        llvm::dwarf::UnwindTable::parseRows((llvm::dwarf::UnwindTable *)&v35, (const llvm::dwarf::CFIProgram *)(a1 + 4), (llvm::dwarf::UnwindRow *)&v23, (const llvm::dwarf::RegisterLocations *)&v32, &v22);
        v14 = v22;
        if (v22)
        {
          *(_BYTE *)(a2 + 40) |= 1u;
          *(_QWORD *)a2 = v14;
        }
        else
        {
          v16 = v36;
          v17 = v37;
          if (v31 || (_DWORD)v24)
          {
            if ((unint64_t)v36 >= v37)
            {
              v16 = sub_1C549A3EC((void **)&v35, (uint64_t)&v23);
              v17 = v37;
            }
            else
            {
              v18 = v24;
              *(_OWORD *)v36 = v23;
              *((_OWORD *)v16 + 1) = v18;
              v19 = v25;
              v20 = v26;
              v21 = v27;
              v16[80] = v28;
              *((_OWORD *)v16 + 3) = v20;
              *((_OWORD *)v16 + 4) = v21;
              *((_OWORD *)v16 + 2) = v19;
              sub_1C5499E30((uint64_t **)v16 + 11, &v29);
              v16 += 112;
            }
            v36 = v16;
          }
          *(_BYTE *)(a2 + 40) &= ~1u;
          *(_QWORD *)a2 = v35;
          *(_QWORD *)(a2 + 8) = v16;
          *(_QWORD *)(a2 + 16) = v17;
          v36 = 0;
          v37 = 0;
          v35 = 0;
          *(_OWORD *)(a2 + 24) = v38;
        }
        sub_1C49F3440(v33);
      }
      sub_1C49F3440(v30);
      *(_QWORD *)&v23 = &v35;
      v15 = (void ***)&v23;
    }
    sub_1C5499DBC(v15);
  }
  else
  {
    v10 = std::generic_category();
    v11 = a1[2];
    v32 = 0;
    v33 = 0;
    v34 = 0;
    DWORD2(v23) = 0;
    BYTE8(v25) = 0;
    *(_QWORD *)&v26 = 0;
    *(_QWORD *)&v23 = &unk_1E81A7208;
    *(_QWORD *)&v27 = &v32;
    DWORD2(v26) = 0;
    *(_QWORD *)&v25 = 0;
    v24 = 0uLL;
    v35 = (__int128 *)&unk_1E8133270;
    v36 = "unable to get CIE for FDE at offset 0x%llx";
    v37 = v11;
    llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v23, (uint64_t)&v35);
    v12 = (__int128 *)v27;
    v13 = operator new();
    WORD4(v38) = 260;
    v35 = v12;
    *(_QWORD *)v13 = off_1E81A0C88;
    llvm::Twine::str((llvm::Twine *)&v35, (_QWORD *)(v13 + 8));
    *(_QWORD *)(v13 + 32) = 22;
    *(_QWORD *)(v13 + 40) = v10;
    *(_BYTE *)(v13 + 48) = 1;
    *(_QWORD *)&v23 = off_1E81A6E70;
    if (DWORD2(v26) == 1 && (_QWORD)v24)
      MEMORY[0x1CAA32F9C](v24, 0x1000C8077774924);
    if (SHIBYTE(v34) < 0)
      operator delete(v32);
    *(_BYTE *)(a2 + 40) |= 1u;
    *(_QWORD *)a2 = v13;
  }
}

void llvm::dwarf::UnwindTable::parseRows(llvm::dwarf::UnwindTable *this@<X0>, const llvm::dwarf::CFIProgram *a2@<X1>, llvm::dwarf::UnwindRow *a3@<X2>, const llvm::dwarf::RegisterLocations *a4@<X3>, uint64_t *a5@<X8>)
{
  _OWORD *v6;
  _OWORD *v7;
  int *v9;
  uint64_t **v10;
  uint64_t **v11;
  uint64_t **v12;
  int v13;
  unint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  llvm::dwarf::UnwindTable *v19;
  char *v20;
  unsigned int v21;
  uint64_t v22;
  _QWORD *v23;
  unsigned int v24;
  BOOL v25;
  uint64_t *v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  uint64_t v32;
  int v33;
  __int128 v34;
  int v35;
  void *v36;
  unint64_t v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  char *v42;
  uint64_t **v43;
  uint64_t **v44;
  uint64_t **v45;
  uint64_t *v46;
  uint64_t v47;
  _QWORD *v48;
  _QWORD *v49;
  unsigned int v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  uint64_t *v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t *v57;
  uint64_t *v58;
  uint64_t **v59;
  BOOL v60;
  uint64_t *v61;
  unsigned int v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  int v66;
  int v67;
  unsigned int i;
  unint64_t v69;
  unint64_t v70;
  char *v71;
  uint64_t v72;
  uint64_t *v73;
  unsigned int v74;
  BOOL v75;
  uint64_t *v76;
  char v77;
  __int128 v78;
  __int128 v79;
  uint64_t **v80;
  uint64_t v81;
  uint64_t **v82;
  uint64_t *v83;
  uint64_t *v84;
  uint64_t v85;
  uint64_t *v86;
  uint64_t **v87;
  _QWORD *v88;
  uint64_t *v89;
  uint64_t *v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  uint64_t **v94;
  uint64_t v95;
  uint64_t **v96;
  uint64_t *v97;
  uint64_t *v98;
  uint64_t **v99;
  uint64_t v100;
  const std::error_category *v101;
  const char *v102;
  unint64_t v103;
  size_t v104;
  const char *v105;
  void **v106;
  const char *v107;
  unint64_t v108;
  size_t v109;
  const char *v110;
  void **v111;
  const std::error_category *v112;
  const std::error_category *v113;
  const char *v114;
  unint64_t v115;
  size_t v116;
  const char *v117;
  void **v118;
  void **v119;
  void **v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  const char *v127;
  uint64_t v128;
  uint64_t v129;
  void **p_dst;
  uint64_t v131;
  uint64_t *v132;
  uint64_t v133;
  unint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  const std::error_category *v138;
  const char *v139;
  unint64_t v140;
  size_t v141;
  const char *v142;
  void **v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t *v146;
  const std::error_category *v147;
  char *ArchTypeName;
  unint64_t v149;
  size_t v150;
  char *v151;
  void **v152;
  void **v153;
  uint64_t v154;
  uint64_t v155;
  char v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t **v159;
  uint64_t **v160;
  uint64_t *v161;
  int *v162;
  int *v163;
  char *v164;
  _OWORD *v165;
  _OWORD *v166;
  uint64_t **v168;
  _QWORD *v169;
  uint64_t *v171;
  void **__dst;
  size_t v173;
  int64_t v174;
  void *v175;
  char v176;
  _BYTE v177[41];
  _BYTE v178[39];
  void *v179;
  uint64_t v180;
  uint64_t v181;
  _BYTE v182[40];
  uint64_t v183;

  v183 = *MEMORY[0x1E0C80C00];
  v6 = *(_OWORD **)a2;
  v7 = (_OWORD *)*((_QWORD *)a2 + 1);
  if (*(_OWORD **)a2 == v7)
  {
    v10 = 0;
    v11 = 0;
LABEL_174:
    *a5 = 0;
    goto LABEL_179;
  }
  v9 = (int *)a2;
  v10 = 0;
  v11 = 0;
  v12 = (uint64_t **)((char *)a3 + 88);
  v168 = 0;
  v171 = (uint64_t *)((char *)a3 + 96);
  v164 = (char *)a3 + 33;
  v169 = (_QWORD *)((char *)a4 + 8);
  while (2)
  {
    v13 = *(unsigned __int8 *)v6;
    switch(*(_BYTE *)v6)
    {
      case 1:
        v159 = v10;
        llvm::dwarf::CFIProgram::Instruction::getOperandAsUnsigned((llvm::dwarf::CFIProgram::Instruction *)v6, (const llvm::dwarf::CFIProgram *)v9, 0, (uint64_t)&v175);
        if ((v176 & 1) != 0)
        {
          *a5 = (uint64_t)v175;
LABEL_246:
          v10 = v159;
          goto LABEL_179;
        }
        v36 = v175;
        if ((unint64_t)v175 > *(_QWORD *)a3)
        {
          v37 = *((_QWORD *)this + 1);
          if (v37 >= *((_QWORD *)this + 2))
          {
            v42 = sub_1C549A3EC((void **)this, (uint64_t)a3);
          }
          else
          {
            v38 = *((_OWORD *)a3 + 1);
            *(_OWORD *)v37 = *(_OWORD *)a3;
            *(_OWORD *)(v37 + 16) = v38;
            v39 = *((_OWORD *)a3 + 2);
            v40 = *((_OWORD *)a3 + 3);
            v41 = *((_OWORD *)a3 + 4);
            *(_BYTE *)(v37 + 80) = *((_BYTE *)a3 + 80);
            *(_OWORD *)(v37 + 48) = v40;
            *(_OWORD *)(v37 + 64) = v41;
            *(_OWORD *)(v37 + 32) = v39;
            sub_1C5499E30((uint64_t **)(v37 + 88), v12);
            v42 = (char *)(v37 + 112);
          }
          *((_QWORD *)this + 1) = v42;
          if (!*((_BYTE *)a3 + 8))
            *((_BYTE *)a3 + 8) = 1;
          *(_QWORD *)a3 = v36;
          v10 = v159;
          goto LABEL_171;
        }
        v113 = std::generic_category();
        v114 = llvm::dwarf::CallFrameString(*(unsigned __int8 *)v6, v9[10]);
        if (!v114)
        {
          __dst = 0;
          v173 = 0;
          p_dst = (void **)&__dst;
          v174 = 0;
LABEL_238:
          v135 = *(_QWORD *)a3;
          v179 = 0;
          v180 = 0;
          v181 = 0;
          *(_DWORD *)&v177[8] = 0;
          *(_QWORD *)&v178[7] = 0;
          *(_QWORD *)v177 = &unk_1E81A7208;
          *(_QWORD *)&v178[23] = &v179;
          *(_DWORD *)&v178[15] = 0;
          memset(&v177[16], 0, 25);
          *(_QWORD *)v182 = &unk_1E8169CC0;
          *(_QWORD *)&v182[8] = "%s with adrress 0x%llx which must be greater than the current row address 0x%llx";
          *(_QWORD *)&v182[16] = p_dst;
          *(_QWORD *)&v182[24] = v36;
          *(_QWORD *)&v182[32] = v135;
          llvm::raw_ostream::operator<<((llvm::raw_ostream *)v177, (uint64_t)v182);
          v136 = *(_QWORD *)&v178[23];
          v137 = operator new();
          *(_WORD *)&v182[32] = 260;
          *(_QWORD *)v182 = v136;
          *(_QWORD *)v137 = off_1E81A0C88;
          llvm::Twine::str((llvm::Twine *)v182, (_QWORD *)(v137 + 8));
          *(_QWORD *)(v137 + 32) = 22;
          *(_QWORD *)(v137 + 40) = v113;
          *(_BYTE *)(v137 + 48) = 1;
          *a5 = v137;
          *(_QWORD *)v177 = off_1E81A6E70;
          if (*(_DWORD *)&v178[15] == 1 && *(_QWORD *)&v177[16])
            MEMORY[0x1CAA32F9C](*(_QWORD *)&v177[16], 0x1000C8077774924);
          if (SHIBYTE(v181) < 0)
            operator delete(v179);
          if (SHIBYTE(v174) < 0)
            operator delete(__dst);
          if ((v176 & 1) != 0 && v36)
            (*(void (**)(void *))(*(_QWORD *)v36 + 8))(v36);
          goto LABEL_246;
        }
        v116 = v115;
        if (v115 > 0x7FFFFFFFFFFFFFF7)
          goto LABEL_273;
        v117 = v114;
        if (v115 >= 0x17)
        {
          v131 = (v115 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v115 | 7) != 0x17)
            v131 = v115 | 7;
          v132 = a5;
          v133 = v131 + 1;
          v118 = (void **)operator new(v131 + 1);
          v134 = v133 | 0x8000000000000000;
          a5 = v132;
          v173 = v116;
          v174 = v134;
          __dst = v118;
        }
        else
        {
          HIBYTE(v174) = v115;
          v118 = (void **)&__dst;
          if (!v115)
          {
LABEL_236:
            *((_BYTE *)v118 + v116) = 0;
            v36 = v175;
            p_dst = (void **)&__dst;
            if (v174 < 0)
              p_dst = __dst;
            goto LABEL_238;
          }
        }
        memmove(v118, v117, v116);
        goto LABEL_236;
      case 2:
      case 3:
      case 4:
      case 0x40:
        v14 = *((_QWORD *)this + 1);
        if (v14 >= *((_QWORD *)this + 2))
        {
          v19 = this;
          v20 = sub_1C549A3EC((void **)this, (uint64_t)a3);
        }
        else
        {
          v15 = *((_OWORD *)a3 + 1);
          *(_OWORD *)v14 = *(_OWORD *)a3;
          *(_OWORD *)(v14 + 16) = v15;
          v16 = *((_OWORD *)a3 + 2);
          v17 = *((_OWORD *)a3 + 3);
          v18 = *((_OWORD *)a3 + 4);
          *(_BYTE *)(v14 + 80) = *((_BYTE *)a3 + 80);
          *(_OWORD *)(v14 + 48) = v17;
          *(_OWORD *)(v14 + 64) = v18;
          *(_OWORD *)(v14 + 32) = v16;
          v19 = this;
          sub_1C5499E30((uint64_t **)(v14 + 88), v12);
          v20 = (char *)(v14 + 112);
        }
        *((_QWORD *)v19 + 1) = v20;
        llvm::dwarf::CFIProgram::Instruction::getOperandAsUnsigned((llvm::dwarf::CFIProgram::Instruction *)v6, (const llvm::dwarf::CFIProgram *)v9, 0, (uint64_t)v177);
        if ((v177[8] & 1) != 0)
          goto LABEL_177;
        *(_QWORD *)a3 += *(_QWORD *)v177;
        goto LABEL_171;
      case 5:
      case 0x11:
        goto LABEL_22;
      case 6:
        goto LABEL_8;
      case 7:
        llvm::dwarf::CFIProgram::Instruction::getOperandAsUnsigned((llvm::dwarf::CFIProgram::Instruction *)v6, (const llvm::dwarf::CFIProgram *)v9, 0, (uint64_t)v182);
        if ((v182[8] & 1) != 0)
          goto LABEL_175;
        v21 = *(_DWORD *)v182;
        sub_1C549A1C4(v12, *(unsigned int *)v182);
        *(_DWORD *)v177 = v21;
        *(_QWORD *)&v177[8] = 0xFFFFFFFF00000001;
        goto LABEL_88;
      case 8:
        llvm::dwarf::CFIProgram::Instruction::getOperandAsUnsigned((llvm::dwarf::CFIProgram::Instruction *)v6, (const llvm::dwarf::CFIProgram *)v9, 0, (uint64_t)v182);
        if ((v182[8] & 1) != 0)
          goto LABEL_175;
        v21 = *(_DWORD *)v182;
        sub_1C549A1C4(v12, *(unsigned int *)v182);
        *(_DWORD *)v177 = v21;
        *(_QWORD *)&v177[8] = 0xFFFFFFFF00000002;
LABEL_88:
        *(_DWORD *)&v177[16] = 0;
        v177[20] = 0;
        v177[24] = 0;
        goto LABEL_89;
      case 9:
        llvm::dwarf::CFIProgram::Instruction::getOperandAsUnsigned((llvm::dwarf::CFIProgram::Instruction *)v6, (const llvm::dwarf::CFIProgram *)v9, 0, (uint64_t)v182);
        if ((v182[8] & 1) != 0)
          goto LABEL_175;
        llvm::dwarf::CFIProgram::Instruction::getOperandAsUnsigned((llvm::dwarf::CFIProgram::Instruction *)v6, (const llvm::dwarf::CFIProgram *)v9, 1u, (uint64_t)&v179);
        if ((v180 & 1) != 0)
          goto LABEL_176;
        v21 = *(_DWORD *)v182;
        v35 = (int)v179;
        sub_1C549A1C4(v12, *(unsigned int *)v182);
        *(_DWORD *)v177 = v21;
        *(_DWORD *)&v177[8] = 4;
        *(_DWORD *)&v177[12] = v35;
        *(_DWORD *)&v177[16] = 0;
        goto LABEL_48;
      case 0xA:
        if (v11 >= v168)
        {
          v163 = v9;
          v69 = 0xAAAAAAAAAAAAAAABLL * (v11 - v10) + 1;
          if (v69 > 0xAAAAAAAAAAAAAAALL)
            goto LABEL_273;
          if (0x5555555555555556 * (v168 - v10) > v69)
            v69 = 0x5555555555555556 * (v168 - v10);
          if (0xAAAAAAAAAAAAAAABLL * (v168 - v10) >= 0x555555555555555)
            v70 = 0xAAAAAAAAAAAAAAALL;
          else
            v70 = v69;
          v166 = v7;
          if (v70)
          {
            if (v70 > 0xAAAAAAAAAAAAAAALL)
              sub_1C4764EE4();
            v71 = (char *)operator new(24 * v70);
          }
          else
          {
            v71 = 0;
          }
          v80 = (uint64_t **)&v71[8 * (v11 - v10)];
          sub_1C5499E30(v80, v12);
          if (v11 == v10)
          {
            v87 = (uint64_t **)&v71[8 * (v11 - v10)];
          }
          else
          {
            v81 = 0;
            do
            {
              v82 = &v80[v81];
              *(v82 - 3) = v11[v81 - 3];
              v83 = (uint64_t *)&v11[v81 - 2];
              v84 = (uint64_t *)*v83;
              v80[v81 - 2] = (uint64_t *)*v83;
              v85 = (uint64_t)&v80[v81 - 2];
              v86 = v11[v81 - 1];
              *(v82 - 1) = v86;
              if (v86)
              {
                v84[2] = v85;
                v11[v81 - 3] = v83;
                *v83 = 0;
                v11[v81 - 1] = 0;
              }
              else
              {
                *(v82 - 3) = (uint64_t *)v85;
              }
              v81 -= 3;
            }
            while (&v11[v81] != v10);
            v87 = &v80[v81];
            do
            {
              sub_1C49F3440(*(v11 - 2));
              v11 -= 3;
            }
            while (v11 != v10);
          }
          v168 = (uint64_t **)&v71[24 * v70];
          v11 = v80 + 3;
          if (v10)
            operator delete(v10);
          v10 = v87;
          v9 = v163;
          v7 = v166;
        }
        else
        {
          sub_1C5499E30(v11, v12);
          v11 += 3;
        }
        goto LABEL_171;
      case 0xB:
        if (v10 == v11)
        {
          v112 = std::generic_category();
          *(_QWORD *)v177 = 22;
          *(_QWORD *)&v177[8] = v112;
          *(_QWORD *)v182 = "DW_CFA_restore_state without a matching previous DW_CFA_remember_state";
          sub_1C5DF1730((_BYTE **)v182, (uint64_t *)v177, a5);
          v11 = v10;
          goto LABEL_179;
        }
        v162 = v9;
        v43 = v11 - 3;
        if (v12 != v11 - 3)
        {
          v161 = a5;
          v44 = (uint64_t **)*(v11 - 3);
          v45 = v11 - 2;
          if (*((_QWORD *)a3 + 13))
          {
            v160 = v10;
            v46 = *v12;
            *v12 = v171;
            *(_QWORD *)(*v171 + 16) = 0;
            *v171 = 0;
            v171[1] = 0;
            if (v46[1])
              v47 = v46[1];
            else
              v47 = (uint64_t)v46;
            if (v47)
            {
              v165 = v7;
              v48 = sub_1C4FCE18C(v47);
              if (v44 == v45)
              {
                v49 = (_QWORD *)v47;
                v59 = v44;
              }
              else
              {
                do
                {
                  v49 = v48;
                  v50 = *((_DWORD *)v44 + 8);
                  *(_DWORD *)(v47 + 32) = v50;
                  *(_OWORD *)(v47 + 40) = *(_OWORD *)(v44 + 5);
                  v51 = *(_OWORD *)(v44 + 7);
                  v52 = *(_OWORD *)(v44 + 9);
                  v53 = *(_OWORD *)(v44 + 11);
                  *(_BYTE *)(v47 + 104) = *((_BYTE *)v44 + 104);
                  *(_OWORD *)(v47 + 88) = v53;
                  *(_OWORD *)(v47 + 72) = v52;
                  *(_OWORD *)(v47 + 56) = v51;
                  v54 = v171;
                  v55 = *v171;
                  v56 = v171;
                  if (*v171)
                  {
                    do
                    {
                      while (1)
                      {
                        v56 = (uint64_t *)v55;
                        if (v50 >= *(_DWORD *)(v55 + 32))
                          break;
                        v55 = *(_QWORD *)v55;
                        v54 = v56;
                        if (!*v56)
                          goto LABEL_69;
                      }
                      v55 = *(_QWORD *)(v55 + 8);
                    }
                    while (v55);
                    v54 = v56 + 1;
                  }
LABEL_69:
                  *(_QWORD *)v47 = 0;
                  *(_QWORD *)(v47 + 8) = 0;
                  *(_QWORD *)(v47 + 16) = v56;
                  *v54 = v47;
                  v57 = (uint64_t *)**v12;
                  if (v57)
                  {
                    *v12 = v57;
                    v47 = *v54;
                  }
                  sub_1C4768E74(*((uint64_t **)a3 + 12), (uint64_t *)v47);
                  ++*((_QWORD *)a3 + 13);
                  if (v48)
                    v48 = sub_1C4FCE18C((uint64_t)v48);
                  else
                    v48 = 0;
                  v58 = v44[1];
                  if (v58)
                  {
                    do
                    {
                      v59 = (uint64_t **)v58;
                      v58 = (uint64_t *)*v58;
                    }
                    while (v58);
                  }
                  else
                  {
                    do
                    {
                      v59 = (uint64_t **)v44[2];
                      v60 = *v59 == (uint64_t *)v44;
                      v44 = v59;
                    }
                    while (!v60);
                  }
                  if (!v49)
                    break;
                  v44 = v59;
                  v47 = (uint64_t)v49;
                }
                while (v59 != v45);
              }
              sub_1C49F3440(v49);
              if (v48)
              {
                v10 = v160;
                a5 = v161;
                v7 = v165;
                do
                {
                  v88 = v48;
                  v48 = (_QWORD *)v48[2];
                }
                while (v48);
                sub_1C49F3440(v88);
              }
              else
              {
                v10 = v160;
                a5 = v161;
                v7 = v165;
              }
              v43 = v11 - 3;
            }
            else
            {
              v59 = v44;
              v10 = v160;
              a5 = v161;
            }
          }
          else
          {
            v59 = (uint64_t **)*(v11 - 3);
            a5 = v161;
          }
          if (v59 != v45)
          {
            do
            {
              v89 = (uint64_t *)operator new(0x70uLL);
              v90 = v89;
              *((_OWORD *)v89 + 2) = *((_OWORD *)v59 + 2);
              v91 = *((_OWORD *)v59 + 6);
              v93 = *((_OWORD *)v59 + 3);
              v92 = *((_OWORD *)v59 + 4);
              *((_OWORD *)v89 + 5) = *((_OWORD *)v59 + 5);
              *((_OWORD *)v89 + 6) = v91;
              *((_OWORD *)v89 + 3) = v93;
              *((_OWORD *)v89 + 4) = v92;
              v94 = (uint64_t **)v171;
              v95 = *v171;
              v96 = (uint64_t **)v171;
              if (*v171)
              {
                do
                {
                  while (1)
                  {
                    v96 = (uint64_t **)v95;
                    if (*((_DWORD *)v89 + 8) >= *(_DWORD *)(v95 + 32))
                      break;
                    v95 = *(_QWORD *)v95;
                    v94 = v96;
                    if (!*v96)
                      goto LABEL_162;
                  }
                  v95 = *(_QWORD *)(v95 + 8);
                }
                while (v95);
                v94 = v96 + 1;
              }
LABEL_162:
              *v89 = 0;
              v89[1] = 0;
              v89[2] = (uint64_t)v96;
              *v94 = v89;
              v97 = (uint64_t *)**v12;
              if (v97)
              {
                *v12 = v97;
                v90 = *v94;
              }
              sub_1C4768E74(*((uint64_t **)a3 + 12), v90);
              ++*((_QWORD *)a3 + 13);
              v98 = v59[1];
              if (v98)
              {
                do
                {
                  v99 = (uint64_t **)v98;
                  v98 = (uint64_t *)*v98;
                }
                while (v98);
              }
              else
              {
                do
                {
                  v99 = (uint64_t **)v59[2];
                  v60 = *v99 == (uint64_t *)v59;
                  v59 = v99;
                }
                while (!v60);
              }
              v59 = v99;
            }
            while (v99 != v45);
          }
        }
        sub_1C49F3440(*(v11 - 2));
        v11 = v43;
        v9 = v162;
        goto LABEL_171;
      case 0xC:
      case 0x12:
        llvm::dwarf::CFIProgram::Instruction::getOperandAsUnsigned((llvm::dwarf::CFIProgram::Instruction *)v6, (const llvm::dwarf::CFIProgram *)v9, 0, (uint64_t)v177);
        if ((v177[8] & 1) != 0)
          goto LABEL_177;
        llvm::dwarf::CFIProgram::Instruction::getOperandAsSigned((llvm::dwarf::CFIProgram::Instruction *)v6, (const llvm::dwarf::CFIProgram *)v9, 1u, (uint64_t)v182);
        if ((v182[8] & 1) != 0)
          goto LABEL_175;
        v28 = *(_DWORD *)v177;
        v29 = *(_DWORD *)v182;
        *((_DWORD *)a3 + 4) = 4;
        *((_DWORD *)a3 + 5) = v28;
        *((_DWORD *)a3 + 6) = v29;
        *(_QWORD *)((char *)a3 + 28) = 0;
        goto LABEL_35;
      case 0xD:
        llvm::dwarf::CFIProgram::Instruction::getOperandAsUnsigned((llvm::dwarf::CFIProgram::Instruction *)v6, (const llvm::dwarf::CFIProgram *)v9, 0, (uint64_t)v177);
        if ((v177[8] & 1) != 0)
          goto LABEL_177;
        if (*((_DWORD *)a3 + 4) != 4)
        {
          *((_DWORD *)a3 + 4) = 4;
          *((_DWORD *)a3 + 6) = 0;
          *(_QWORD *)((char *)a3 + 28) = 0;
          *((_BYTE *)a3 + 40) = 0;
          *((_BYTE *)a3 + 72) = 0;
          *((_BYTE *)a3 + 80) = 0;
        }
        *((_DWORD *)a3 + 5) = *(_DWORD *)v177;
        goto LABEL_171;
      case 0xE:
      case 0x13:
        llvm::dwarf::CFIProgram::Instruction::getOperandAsSigned((llvm::dwarf::CFIProgram::Instruction *)v6, (const llvm::dwarf::CFIProgram *)v9, 0, (uint64_t)&v175);
        if ((v176 & 1) != 0)
        {
          v100 = (uint64_t)v175;
          goto LABEL_178;
        }
        if (*((_DWORD *)a3 + 4) != 4)
        {
          v101 = std::generic_category();
          v102 = llvm::dwarf::CallFrameString(*(unsigned __int8 *)v6, v9[10]);
          if (!v102)
          {
            __dst = 0;
            v173 = 0;
            v119 = (void **)&__dst;
            v174 = 0;
            goto LABEL_210;
          }
          v104 = v103;
          if (v103 <= 0x7FFFFFFFFFFFFFF7)
          {
            v105 = v102;
            if (v103 >= 0x17)
            {
              v121 = (v103 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v103 | 7) != 0x17)
                v121 = v103 | 7;
              v122 = v121 + 1;
              v106 = (void **)operator new(v121 + 1);
              v173 = v104;
              v174 = v122 | 0x8000000000000000;
              __dst = v106;
            }
            else
            {
              HIBYTE(v174) = v103;
              v106 = (void **)&__dst;
              if (!v103)
                goto LABEL_208;
            }
            memmove(v106, v105, v104);
LABEL_208:
            *((_BYTE *)v106 + v104) = 0;
            v119 = (void **)&__dst;
            if (v174 < 0)
              v119 = __dst;
LABEL_210:
            v179 = 0;
            v180 = 0;
            v181 = 0;
            *(_DWORD *)&v177[8] = 0;
            *(_QWORD *)&v178[7] = 0;
            *(_QWORD *)v177 = &unk_1E81A7208;
            *(_QWORD *)&v178[23] = &v179;
            *(_DWORD *)&v178[15] = 0;
            memset(&v177[16], 0, 25);
            *(_QWORD *)v182 = &off_1E8132A78;
            *(_QWORD *)&v182[8] = "%s found when CFA rule was not RegPlusOffset";
            *(_QWORD *)&v182[16] = v119;
            llvm::raw_ostream::operator<<((llvm::raw_ostream *)v177, (uint64_t)v182);
            v123 = *(_QWORD *)&v178[23];
            v124 = operator new();
            *(_WORD *)&v182[32] = 260;
            *(_QWORD *)v182 = v123;
            *(_QWORD *)v124 = off_1E81A0C88;
            llvm::Twine::str((llvm::Twine *)v182, (_QWORD *)(v124 + 8));
            *(_QWORD *)(v124 + 32) = 22;
            *(_QWORD *)(v124 + 40) = v101;
            *(_BYTE *)(v124 + 48) = 1;
            *a5 = v124;
            *(_QWORD *)v177 = off_1E81A6E70;
            if (*(_DWORD *)&v178[15] == 1 && *(_QWORD *)&v177[16])
              MEMORY[0x1CAA32F9C](*(_QWORD *)&v177[16], 0x1000C8077774924);
            if (SHIBYTE(v181) < 0)
              operator delete(v179);
            if (SHIBYTE(v174) < 0)
              operator delete(__dst);
            if ((v176 & 1) != 0 && v175)
              (*(void (**)(void *))(*(_QWORD *)v175 + 8))(v175);
            goto LABEL_179;
          }
LABEL_273:
          abort();
        }
        *((_DWORD *)a3 + 6) = (_DWORD)v175;
        goto LABEL_171;
      case 0xF:
        v63 = v6[4];
        *(_OWORD *)&v177[7] = v6[3];
        *(_OWORD *)&v177[23] = v63;
        *((_QWORD *)a3 + 2) = -4294967291;
        *((_DWORD *)a3 + 6) = 0;
        *((_BYTE *)a3 + 28) = 0;
        *((_BYTE *)a3 + 32) = 0;
        v64 = *(_OWORD *)&v177[16];
        *(_OWORD *)v164 = *(_OWORD *)v177;
        *((_OWORD *)v164 + 1) = v64;
        *(_QWORD *)(v164 + 31) = *(_QWORD *)&v177[31];
        *((_BYTE *)a3 + 72) = 1;
        goto LABEL_96;
      case 0x10:
        llvm::dwarf::CFIProgram::Instruction::getOperandAsUnsigned((llvm::dwarf::CFIProgram::Instruction *)v6, (const llvm::dwarf::CFIProgram *)v9, 0, (uint64_t)&v179);
        if ((v180 & 1) != 0)
          goto LABEL_176;
        v21 = v179;
        v34 = v6[4];
        *(_OWORD *)&v182[7] = v6[3];
        *(_OWORD *)&v182[23] = v34;
        sub_1C549A1C4(v12, v179);
        *(_DWORD *)v177 = v21;
        *(_QWORD *)&v177[8] = -4294967291;
        *(_DWORD *)&v177[16] = 0;
        v177[20] = 0;
        v177[24] = 0;
        *(_OWORD *)&v177[25] = *(_OWORD *)v182;
        *(_OWORD *)v178 = *(_OWORD *)&v182[16];
        *(_QWORD *)&v178[15] = *(_QWORD *)&v182[31];
        v178[23] = 1;
        goto LABEL_44;
      case 0x14:
      case 0x15:
        llvm::dwarf::CFIProgram::Instruction::getOperandAsUnsigned((llvm::dwarf::CFIProgram::Instruction *)v6, (const llvm::dwarf::CFIProgram *)v9, 0, (uint64_t)v182);
        if ((v182[8] & 1) != 0)
          goto LABEL_175;
        llvm::dwarf::CFIProgram::Instruction::getOperandAsSigned((llvm::dwarf::CFIProgram::Instruction *)v6, (const llvm::dwarf::CFIProgram *)v9, 1u, (uint64_t)&v179);
        if ((v180 & 1) != 0)
          goto LABEL_176;
        v21 = *(_DWORD *)v182;
        v33 = (int)v179;
        sub_1C549A1C4(v12, *(unsigned int *)v182);
        *(_DWORD *)v177 = v21;
        *(_QWORD *)&v177[8] = 0xFFFFFFFF00000003;
        *(_DWORD *)&v177[16] = v33;
LABEL_48:
        *(_QWORD *)&v177[20] = 0;
LABEL_89:
        v177[32] = 0;
        v178[23] = 0;
LABEL_90:
        v178[31] = 0;
        goto LABEL_91;
      case 0x16:
        llvm::dwarf::CFIProgram::Instruction::getOperandAsUnsigned((llvm::dwarf::CFIProgram::Instruction *)v6, (const llvm::dwarf::CFIProgram *)v9, 0, (uint64_t)&v179);
        if ((v180 & 1) != 0)
          goto LABEL_176;
        v21 = v179;
        v65 = v6[4];
        *(_OWORD *)&v182[7] = v6[3];
        *(_OWORD *)&v182[23] = v65;
        sub_1C549A1C4(v12, v179);
        *(_DWORD *)v177 = v21;
        *(_QWORD *)&v177[8] = -4294967291;
        *(_DWORD *)&v177[16] = 0;
        v177[20] = 0;
        v177[24] = 0;
        *(_OWORD *)&v177[25] = *(_OWORD *)v182;
        *(_OWORD *)v178 = *(_OWORD *)&v182[16];
        *(_QWORD *)&v178[15] = *(_QWORD *)&v182[31];
        v178[23] = 1;
        goto LABEL_90;
      case 0x17:
      case 0x18:
      case 0x19:
      case 0x1A:
      case 0x1B:
      case 0x1C:
      case 0x1D:
      case 0x1E:
      case 0x1F:
      case 0x20:
      case 0x21:
      case 0x22:
      case 0x23:
      case 0x24:
      case 0x25:
      case 0x26:
      case 0x27:
      case 0x28:
      case 0x29:
      case 0x2A:
      case 0x2B:
      case 0x2C:
      case 0x2E:
      case 0x2F:
      case 0x32:
      case 0x33:
      case 0x34:
      case 0x35:
      case 0x36:
      case 0x37:
      case 0x38:
      case 0x39:
      case 0x3A:
      case 0x3B:
      case 0x3C:
      case 0x3D:
      case 0x3E:
      case 0x3F:
        goto LABEL_171;
      case 0x2D:
        v66 = v9[10];
        if ((v66 - 3) >= 3)
        {
          if ((v66 - 33) <= 2)
          {
            v67 = 0;
            for (i = 16; i != 32; ++i)
            {
              sub_1C549A1C4(v12, i);
              *(_DWORD *)v177 = i;
              *(_QWORD *)&v177[8] = 0xFFFFFFFF00000003;
              *(_DWORD *)&v177[16] = v67;
              *(_QWORD *)&v177[20] = 0;
              v177[32] = 0;
              v178[23] = 0;
              v178[31] = 1;
              sub_1C549A288((uint64_t *)v12, i, (uint64_t)v177);
              v67 += 8;
            }
            goto LABEL_171;
          }
          v146 = a5;
          v147 = std::generic_category();
          ArchTypeName = llvm::Triple::getArchTypeName(v9[10]);
          if (!ArchTypeName)
          {
            __dst = 0;
            v173 = 0;
            v153 = (void **)&__dst;
            v174 = 0;
LABEL_272:
            v179 = 0;
            v180 = 0;
            v181 = 0;
            *(_DWORD *)&v177[8] = 0;
            *(_QWORD *)&v178[7] = 0;
            *(_QWORD *)v177 = &unk_1E81A7208;
            *(_QWORD *)&v178[23] = &v179;
            *(_DWORD *)&v178[15] = 0;
            memset(&v177[16], 0, 25);
            *(_QWORD *)v182 = &off_1E8169CE0;
            v156 = *(_BYTE *)v6;
            *(_QWORD *)&v182[8] = "DW_CFA opcode %#x is not supported for architecture %s";
            v182[16] = v156;
            *(_QWORD *)&v182[24] = v153;
            llvm::raw_ostream::operator<<((llvm::raw_ostream *)v177, (uint64_t)v182);
            v157 = *(_QWORD *)&v178[23];
            v158 = operator new();
            *(_WORD *)&v182[32] = 260;
            *(_QWORD *)v182 = v157;
            *(_QWORD *)v158 = off_1E81A0C88;
            llvm::Twine::str((llvm::Twine *)v182, (_QWORD *)(v158 + 8));
            *(_QWORD *)(v158 + 32) = 45;
            *(_QWORD *)(v158 + 40) = v147;
            *(_BYTE *)(v158 + 48) = 1;
            *v146 = v158;
            goto LABEL_226;
          }
          v150 = v149;
          if (v149 > 0x7FFFFFFFFFFFFFF7)
            goto LABEL_273;
          v151 = ArchTypeName;
          if (v149 >= 0x17)
          {
            v154 = (v149 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v149 | 7) != 0x17)
              v154 = v149 | 7;
            v155 = v154 + 1;
            v152 = (void **)operator new(v154 + 1);
            v173 = v150;
            v174 = v155 | 0x8000000000000000;
            __dst = v152;
          }
          else
          {
            HIBYTE(v174) = v149;
            v152 = (void **)&__dst;
            if (!v149)
            {
LABEL_270:
              *((_BYTE *)v152 + v150) = 0;
              v153 = (void **)&__dst;
              if (v174 < 0)
                v153 = __dst;
              goto LABEL_272;
            }
          }
          memmove(v152, v151, v150);
          goto LABEL_270;
        }
        v72 = *v171;
        if (!*v171)
          goto LABEL_124;
        v73 = v171;
        do
        {
          v74 = *(_DWORD *)(v72 + 32);
          v75 = v74 >= 0x22;
          if (v74 >= 0x22)
            v76 = (uint64_t *)v72;
          else
            v76 = (uint64_t *)(v72 + 8);
          if (v75)
            v73 = (uint64_t *)v72;
          v72 = *v76;
        }
        while (*v76);
        if (v73 == v171 || *((_DWORD *)v73 + 8) > 0x22u)
        {
LABEL_124:
          sub_1C549A1C4(v12, 0x22u);
          *(_DWORD *)v177 = 34;
          *(_QWORD *)&v177[8] = -4294967290;
          *(_DWORD *)&v177[16] = 1;
          *(_QWORD *)&v177[20] = 0;
          v177[32] = 0;
          v178[23] = 0;
          v178[31] = 0;
          v61 = (uint64_t *)v12;
          v62 = 34;
          goto LABEL_92;
        }
        if (*((_DWORD *)v73 + 10) == 6)
          goto LABEL_171;
        v138 = std::generic_category();
        v139 = llvm::dwarf::CallFrameString(*(unsigned __int8 *)v6, v9[10]);
        if (!v139)
        {
          __dst = 0;
          v173 = 0;
          v120 = (void **)&__dst;
          v174 = 0;
          goto LABEL_259;
        }
        v141 = v140;
        if (v140 > 0x7FFFFFFFFFFFFFF7)
          goto LABEL_273;
        v142 = v139;
        if (v140 >= 0x17)
        {
          v144 = (v140 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v140 | 7) != 0x17)
            v144 = v140 | 7;
          v145 = v144 + 1;
          v143 = (void **)operator new(v144 + 1);
          v173 = v141;
          v174 = v145 | 0x8000000000000000;
          __dst = v143;
        }
        else
        {
          HIBYTE(v174) = v140;
          v143 = (void **)&__dst;
          if (!v140)
            goto LABEL_257;
        }
        memmove(v143, v142, v141);
LABEL_257:
        *((_BYTE *)v143 + v141) = 0;
        v120 = (void **)&__dst;
        if (v174 < 0)
          v120 = __dst;
LABEL_259:
        v179 = 0;
        v180 = 0;
        v181 = 0;
        *(_DWORD *)&v177[8] = 0;
        *(_QWORD *)&v178[7] = 0;
        *(_QWORD *)v177 = &unk_1E81A7208;
        *(_QWORD *)&v178[23] = &v179;
        *(_DWORD *)&v178[15] = 0;
        memset(&v177[16], 0, 25);
        v127 = "%s encountered when existing rule for this register is not a constant";
LABEL_225:
        *(_QWORD *)v182 = &off_1E8132A78;
        *(_QWORD *)&v182[8] = v127;
        *(_QWORD *)&v182[16] = v120;
        llvm::raw_ostream::operator<<((llvm::raw_ostream *)v177, (uint64_t)v182);
        v128 = *(_QWORD *)&v178[23];
        v129 = operator new();
        *(_WORD *)&v182[32] = 260;
        *(_QWORD *)v182 = v128;
        *(_QWORD *)v129 = off_1E81A0C88;
        llvm::Twine::str((llvm::Twine *)v182, (_QWORD *)(v129 + 8));
        *(_QWORD *)(v129 + 32) = 22;
        *(_QWORD *)(v129 + 40) = v138;
        *(_BYTE *)(v129 + 48) = 1;
        *a5 = v129;
LABEL_226:
        *(_QWORD *)v177 = off_1E81A6E70;
        if (*(_DWORD *)&v178[15] == 1 && *(_QWORD *)&v177[16])
          MEMORY[0x1CAA32F9C](*(_QWORD *)&v177[16], 0x1000C8077774924);
        if (SHIBYTE(v181) < 0)
          operator delete(v179);
        if (SHIBYTE(v174) < 0)
          operator delete(__dst);
LABEL_179:
        if (v10)
        {
          for (; v11 != v10; v11 -= 3)
            sub_1C49F3440(*(v11 - 2));
          operator delete(v10);
        }
        return;
      case 0x30:
      case 0x31:
        llvm::dwarf::CFIProgram::Instruction::getOperandAsUnsigned((llvm::dwarf::CFIProgram::Instruction *)v6, (const llvm::dwarf::CFIProgram *)v9, 0, (uint64_t)v177);
        if ((v177[8] & 1) != 0)
        {
LABEL_177:
          v100 = *(_QWORD *)v177;
LABEL_178:
          *a5 = v100;
          goto LABEL_179;
        }
        llvm::dwarf::CFIProgram::Instruction::getOperandAsSigned((llvm::dwarf::CFIProgram::Instruction *)v6, (const llvm::dwarf::CFIProgram *)v9, 1u, (uint64_t)v182);
        if ((v182[8] & 1) != 0)
        {
LABEL_175:
          v100 = *(_QWORD *)v182;
          goto LABEL_178;
        }
        llvm::dwarf::CFIProgram::Instruction::getOperandAsUnsigned((llvm::dwarf::CFIProgram::Instruction *)v6, (const llvm::dwarf::CFIProgram *)v9, 2u, (uint64_t)&v179);
        if ((v180 & 1) != 0)
          goto LABEL_176;
        v30 = *(_DWORD *)v177;
        v31 = *(_DWORD *)v182;
        v32 = v179 | 0x100000000;
        *((_DWORD *)a3 + 4) = 4;
        *((_DWORD *)a3 + 5) = v30;
        *((_DWORD *)a3 + 6) = v31;
        *(_QWORD *)((char *)a3 + 28) = v32;
LABEL_35:
        *((_BYTE *)a3 + 40) = 0;
        *((_BYTE *)a3 + 72) = 0;
LABEL_96:
        *((_BYTE *)a3 + 80) = 0;
        goto LABEL_171;
      default:
        if (v13 == 128)
        {
LABEL_22:
          llvm::dwarf::CFIProgram::Instruction::getOperandAsUnsigned((llvm::dwarf::CFIProgram::Instruction *)v6, (const llvm::dwarf::CFIProgram *)v9, 0, (uint64_t)v182);
          if ((v182[8] & 1) != 0)
            goto LABEL_175;
          llvm::dwarf::CFIProgram::Instruction::getOperandAsSigned((llvm::dwarf::CFIProgram::Instruction *)v6, (const llvm::dwarf::CFIProgram *)v9, 1u, (uint64_t)&v179);
          if ((v180 & 1) != 0)
          {
LABEL_176:
            v100 = (uint64_t)v179;
            goto LABEL_178;
          }
          v21 = *(_DWORD *)v182;
          v27 = (int)v179;
          sub_1C549A1C4(v12, *(unsigned int *)v182);
          *(_DWORD *)v177 = v21;
          *(_QWORD *)&v177[8] = 0xFFFFFFFF00000003;
          *(_DWORD *)&v177[16] = v27;
          *(_QWORD *)&v177[20] = 0;
          v177[32] = 0;
          v178[23] = 0;
LABEL_44:
          v178[31] = 1;
LABEL_91:
          v61 = (uint64_t *)v12;
          v62 = v21;
LABEL_92:
          sub_1C549A288(v61, v62, (uint64_t)v177);
          goto LABEL_171;
        }
        if (v13 == 192)
        {
LABEL_8:
          if (!a4)
          {
            v138 = std::generic_category();
            v107 = llvm::dwarf::CallFrameString(*(unsigned __int8 *)v6, v9[10]);
            if (v107)
            {
              v109 = v108;
              if (v108 > 0x7FFFFFFFFFFFFFF7)
                goto LABEL_273;
              v110 = v107;
              if (v108 >= 0x17)
              {
                v125 = (v108 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v108 | 7) != 0x17)
                  v125 = v108 | 7;
                v126 = v125 + 1;
                v111 = (void **)operator new(v125 + 1);
                v173 = v109;
                v174 = v126 | 0x8000000000000000;
                __dst = v111;
              }
              else
              {
                HIBYTE(v174) = v108;
                v111 = (void **)&__dst;
                if (!v108)
                  goto LABEL_222;
              }
              memmove(v111, v110, v109);
LABEL_222:
              *((_BYTE *)v111 + v109) = 0;
              v120 = (void **)&__dst;
              if (v174 < 0)
                v120 = __dst;
            }
            else
            {
              __dst = 0;
              v173 = 0;
              v120 = (void **)&__dst;
              v174 = 0;
            }
            v179 = 0;
            v180 = 0;
            v181 = 0;
            *(_DWORD *)&v177[8] = 0;
            *(_QWORD *)&v178[7] = 0;
            *(_QWORD *)v177 = &unk_1E81A7208;
            *(_QWORD *)&v178[23] = &v179;
            *(_DWORD *)&v178[15] = 0;
            memset(&v177[16], 0, 25);
            v127 = "%s encountered while parsing a CIE";
            goto LABEL_225;
          }
          llvm::dwarf::CFIProgram::Instruction::getOperandAsUnsigned((llvm::dwarf::CFIProgram::Instruction *)v6, (const llvm::dwarf::CFIProgram *)v9, 0, (uint64_t)v182);
          if ((v182[8] & 1) != 0)
            goto LABEL_175;
          v21 = *(_DWORD *)v182;
          v22 = *v169;
          if (*v169)
          {
            v23 = v169;
            do
            {
              v24 = *(_DWORD *)(v22 + 32);
              v25 = v24 >= *(_DWORD *)v182;
              if (v24 >= *(_DWORD *)v182)
                v26 = (uint64_t *)v22;
              else
                v26 = (uint64_t *)(v22 + 8);
              if (v25)
                v23 = (_QWORD *)v22;
              v22 = *v26;
            }
            while (*v26);
            if (v23 != v169 && *((_DWORD *)v23 + 8) <= *(_DWORD *)v182)
            {
              v77 = *((_BYTE *)v23 + 40);
              v78 = *(_OWORD *)((char *)v23 + 57);
              v79 = *(_OWORD *)((char *)v23 + 89);
              *(_OWORD *)v178 = *(_OWORD *)((char *)v23 + 73);
              *(_OWORD *)&v178[16] = v79;
              *(_QWORD *)&v178[31] = v23[13];
              *(_OWORD *)&v177[9] = *(_OWORD *)((char *)v23 + 41);
              *(_OWORD *)&v177[25] = v78;
              sub_1C549A1C4(v12, *(unsigned int *)v182);
              *(_DWORD *)v177 = v21;
              v177[8] = v77;
              goto LABEL_91;
            }
          }
          sub_1C549A1C4(v12, *(unsigned int *)v182);
        }
LABEL_171:
        v6 = (_OWORD *)((char *)v6 + 88);
        if (v6 == v7)
          goto LABEL_174;
        continue;
    }
  }
}

void llvm::dwarf::UnwindTable::create(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  void ***v4;
  char *v5;
  unint64_t v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  char v17;
  _QWORD **v18;
  _QWORD *v19;
  uint64_t v20;
  __int128 *v21;
  char *v22;
  unint64_t v23;
  __int128 v24;

  if (*(_QWORD *)(a1 + 32) == *(_QWORD *)(a1 + 40))
  {
    *((_QWORD *)&v13 + 1) = 0;
    *(_QWORD *)&v14 = 0;
    *(_BYTE *)(a2 + 40) &= ~1u;
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)&v13 = 0;
    v12 = 0uLL;
    *(_QWORD *)(a2 + 24) = 0;
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    v21 = &v12;
    v4 = (void ***)&v21;
  }
  else
  {
    BYTE8(v24) = 0;
    v22 = 0;
    v23 = 0;
    v21 = 0;
    LOBYTE(v24) = 0;
    LOBYTE(v12) = 0;
    BYTE8(v12) = 0;
    *(_QWORD *)&v13 = 0xFFFFFFFF00000000;
    DWORD2(v13) = 0;
    BYTE12(v13) = 0;
    LOBYTE(v14) = 0;
    BYTE8(v14) = 0;
    BYTE8(v16) = 0;
    v17 = 0;
    v19 = 0;
    v20 = 0;
    v18 = &v19;
    llvm::dwarf::UnwindTable::parseRows((llvm::dwarf::UnwindTable *)&v21, (const llvm::dwarf::CFIProgram *)(a1 + 32), (llvm::dwarf::UnwindRow *)&v12, 0, &v11);
    v3 = v11;
    if (v11)
    {
      *(_BYTE *)(a2 + 40) |= 1u;
      *(_QWORD *)a2 = v3;
    }
    else
    {
      v5 = v22;
      v6 = v23;
      if (v20 || (_DWORD)v13)
      {
        if ((unint64_t)v22 >= v23)
        {
          v5 = sub_1C549A3EC((void **)&v21, (uint64_t)&v12);
          v6 = v23;
        }
        else
        {
          v7 = v13;
          *(_OWORD *)v22 = v12;
          *((_OWORD *)v5 + 1) = v7;
          v8 = v14;
          v9 = v15;
          v10 = v16;
          v5[80] = v17;
          *((_OWORD *)v5 + 3) = v9;
          *((_OWORD *)v5 + 4) = v10;
          *((_OWORD *)v5 + 2) = v8;
          sub_1C5499E30((uint64_t **)v5 + 11, &v18);
          v5 += 112;
        }
        v22 = v5;
      }
      *(_BYTE *)(a2 + 40) &= ~1u;
      *(_QWORD *)a2 = v21;
      *(_QWORD *)(a2 + 8) = v5;
      *(_QWORD *)(a2 + 16) = v6;
      v22 = 0;
      v23 = 0;
      v21 = 0;
      *(_OWORD *)(a2 + 24) = v24;
    }
    sub_1C49F3440(v19);
    *(_QWORD *)&v12 = &v21;
    v4 = (void ***)&v12;
  }
  sub_1C5499DBC(v4);
}

void llvm::dwarf::CFIProgram::parse(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X2>, unint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  __int16 *v5;
  unint64_t v8;
  uint64_t *v12;
  unsigned __int8 RelocatedValue;
  uint64_t v14;
  unsigned __int8 v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __int16 *v24;
  unint64_t v25;
  __int128 v26;
  __int128 v27;
  char *v28;
  uint64_t *v29;
  __int16 *v30;
  uint64_t ULEB128;
  uint64_t SLEB128;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  unint64_t v38;
  __int128 v39;
  __int128 v40;
  char *v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  unint64_t Bytes;
  uint64_t v49;
  BOOL v50;
  char v51;
  uint64_t v52;
  const std::error_category *v53;
  void **v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unsigned __int128 v58;
  void *__p[2];
  uint64_t v60;
  _QWORD v61[4];
  __int16 v62;
  void (**v63)(llvm::raw_ostream *__hidden);
  void *v64;
  uint64_t v65;
  _QWORD v66[2];
  char v67;
  uint64_t v68;
  int v69;
  void **v70;
  char v71;
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  v8 = *a3;
  v58 = *a3;
  if (v8 >= a4)
  {
    v14 = 0;
  }
  else
  {
    v12 = &v68;
    while (1)
    {
      RelocatedValue = llvm::DWARFDataExtractor::getRelocatedValue(a2, 1, (unint64_t *)&v58, 0, (uint64_t *)&v58 + 1);
      v14 = *((_QWORD *)&v58 + 1);
      if (*((_QWORD *)&v58 + 1))
        break;
      v15 = RelocatedValue;
      if ((RelocatedValue & 0xC0) == 0)
      {
        switch(RelocatedValue)
        {
          case 0u:
          case 0xAu:
          case 0xBu:
          case 0x2Du:
            v24 = v5;
            LOBYTE(v63) = RelocatedValue;
            v64 = v66;
            v65 = 0x300000000;
            LOBYTE(v68) = 0;
            v71 = 0;
            v25 = *(_QWORD *)(a1 + 8);
            if (v25 >= *(_QWORD *)(a1 + 16))
            {
              v28 = sub_1C5499FC8((char **)a1, (char *)&v63);
            }
            else
            {
              *(_BYTE *)v25 = RelocatedValue;
              *(_QWORD *)(v25 + 8) = v25 + 24;
              *(_QWORD *)(v25 + 16) = 0x300000000;
              if ((_DWORD)v65)
                sub_1C614D378(v25 + 8, (uint64_t)&v64);
              v26 = *(_OWORD *)v12;
              v27 = *((_OWORD *)v12 + 1);
              *(_QWORD *)(v25 + 80) = v12[4];
              *(_OWORD *)(v25 + 48) = v26;
              *(_OWORD *)(v25 + 64) = v27;
              v28 = (char *)(v25 + 88);
            }
            *(_QWORD *)(a1 + 8) = v28;
            v5 = v24;
            if (v64 != v66)
              free(v64);
            goto LABEL_19;
          case 1u:
            v22 = llvm::DWARFDataExtractor::getRelocatedValue(a2, *(unsigned __int8 *)(a2 + 17), (unint64_t *)&v58, 0, (uint64_t *)&v58 + 1);
            v23 = a1;
            LOBYTE(v17) = 1;
            goto LABEL_10;
          case 2u:
            v22 = llvm::DWARFDataExtractor::getRelocatedValue(a2, 1, (unint64_t *)&v58, 0, (uint64_t *)&v58 + 1);
            v23 = a1;
            LOBYTE(v17) = 2;
            goto LABEL_10;
          case 3u:
            v22 = llvm::DWARFDataExtractor::getRelocatedValue(a2, 2, (unint64_t *)&v58, 0, (uint64_t *)&v58 + 1);
            v23 = a1;
            LOBYTE(v17) = 3;
            goto LABEL_10;
          case 4u:
            v22 = llvm::DWARFDataExtractor::getRelocatedValue(a2, 4, (unint64_t *)&v58, 0, (uint64_t *)&v58 + 1);
            v23 = a1;
            LOBYTE(v17) = 4;
            goto LABEL_10;
          case 5u:
          case 9u:
          case 0xCu:
          case 0x14u:
            v29 = v12;
            v30 = v5;
            ULEB128 = llvm::DataExtractor::getULEB128((uint64_t *)a2, (uint64_t *)&v58, (_QWORD *)&v58 + 1);
            SLEB128 = llvm::DataExtractor::getULEB128((uint64_t *)a2, (uint64_t *)&v58, (_QWORD *)&v58 + 1);
            goto LABEL_17;
          case 6u:
          case 7u:
          case 8u:
          case 0xDu:
          case 0xEu:
          case 0x2Eu:
            v22 = llvm::DataExtractor::getULEB128((uint64_t *)a2, (uint64_t *)&v58, (_QWORD *)&v58 + 1);
            LOBYTE(v17) = v15;
            v23 = a1;
            goto LABEL_10;
          case 0xFu:
            v47 = llvm::DataExtractor::getULEB128((uint64_t *)a2, (uint64_t *)&v58, (_QWORD *)&v58 + 1);
            sub_1C54967DC(a1, 15, 0);
            v37 = (_QWORD *)a2;
            v36 = v47;
            goto LABEL_44;
          case 0x10u:
          case 0x16u:
            v35 = llvm::DataExtractor::getULEB128((uint64_t *)a2, (uint64_t *)&v58, (_QWORD *)&v58 + 1);
            sub_1C5496918(a1, v15, v35, 0);
            v36 = llvm::DataExtractor::getULEB128((uint64_t *)a2, (uint64_t *)&v58, (_QWORD *)&v58 + 1);
            v37 = (_QWORD *)a2;
LABEL_44:
            Bytes = llvm::DataExtractor::getBytes(v37, (unint64_t *)&v58, v36, (uint64_t *)&v58 + 1);
            v50 = *(_BYTE *)(a2 + 16) != 0;
            v51 = *(_BYTE *)(a2 + 17);
            v52 = *(_QWORD *)(a1 + 8);
            if (!*(_BYTE *)(v52 - 8))
              *(_BYTE *)(v52 - 8) = 1;
            *(_QWORD *)(v52 - 40) = Bytes;
            *(_QWORD *)(v52 - 32) = v49;
            *(_BYTE *)(v52 - 24) = v50;
            *(_BYTE *)(v52 - 23) = v51;
            *(_BYTE *)(v52 - 16) = v51;
            *(_WORD *)(v52 - 15) = 0;
            goto LABEL_19;
          case 0x11u:
          case 0x12u:
          case 0x15u:
            v29 = v12;
            v30 = v5;
            ULEB128 = llvm::DataExtractor::getULEB128((uint64_t *)a2, (uint64_t *)&v58, (_QWORD *)&v58 + 1);
            SLEB128 = llvm::DataExtractor::getSLEB128((_QWORD *)a2, (uint64_t *)&v58, (_QWORD *)&v58 + 1);
LABEL_17:
            v18 = SLEB128;
            v20 = v15;
            v19 = a1;
            v21 = ULEB128;
            v5 = v30;
            v12 = v29;
            goto LABEL_18;
          case 0x13u:
            v22 = llvm::DataExtractor::getSLEB128((_QWORD *)a2, (uint64_t *)&v58, (_QWORD *)&v58 + 1);
            v23 = a1;
            LOBYTE(v17) = 19;
            goto LABEL_10;
          case 0x30u:
          case 0x31u:
            v33 = llvm::DataExtractor::getULEB128((uint64_t *)a2, (uint64_t *)&v58, (_QWORD *)&v58 + 1);
            if (v15 == 48)
              v34 = llvm::DataExtractor::getULEB128((uint64_t *)a2, (uint64_t *)&v58, (_QWORD *)&v58 + 1);
            else
              v34 = llvm::DataExtractor::getSLEB128((_QWORD *)a2, (uint64_t *)&v58, (_QWORD *)&v58 + 1);
            v57 = v34;
            v56 = llvm::DataExtractor::getULEB128((uint64_t *)a2, (uint64_t *)&v58, (_QWORD *)&v58 + 1);
            LOBYTE(v63) = v15;
            v64 = v66;
            v65 = 0x300000000;
            LOBYTE(v68) = 0;
            v71 = 0;
            v38 = *(_QWORD *)(a1 + 8);
            if (v38 >= *(_QWORD *)(a1 + 16))
            {
              v41 = sub_1C5499FC8((char **)a1, (char *)&v63);
            }
            else
            {
              *(_BYTE *)v38 = v15;
              *(_QWORD *)(v38 + 8) = v38 + 24;
              *(_QWORD *)(v38 + 16) = 0x300000000;
              if ((_DWORD)v65)
                sub_1C614D378(v38 + 8, (uint64_t)&v64);
              v39 = *(_OWORD *)v12;
              v40 = *((_OWORD *)v12 + 1);
              *(_QWORD *)(v38 + 80) = v12[4];
              *(_OWORD *)(v38 + 48) = v39;
              *(_OWORD *)(v38 + 64) = v40;
              v41 = (char *)(v38 + 88);
            }
            *(_QWORD *)(a1 + 8) = v41;
            v5 = &jpt_1C54961DC;
            if (v64 != v66)
            {
              free(v64);
              v41 = *(char **)(a1 + 8);
            }
            v42 = *((unsigned int *)v41 - 18);
            if (v42 >= *((unsigned int *)v41 - 17))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v41 - 80), (uint64_t)(v41 - 64), v42 + 1, 8);
              v42 = *((unsigned int *)v41 - 18);
            }
            *(_QWORD *)(*((_QWORD *)v41 - 10) + 8 * v42) = v33;
            ++*((_DWORD *)v41 - 18);
            v43 = *(_QWORD *)(a1 + 8);
            v44 = *(unsigned int *)(v43 - 72);
            if (v44 >= *(unsigned int *)(v43 - 68))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod(v43 - 80, v43 - 64, v44 + 1, 8);
              v44 = *(unsigned int *)(v43 - 72);
            }
            *(_QWORD *)(*(_QWORD *)(v43 - 80) + 8 * v44) = v57;
            ++*(_DWORD *)(v43 - 72);
            v45 = *(_QWORD *)(a1 + 8);
            v46 = *(unsigned int *)(v45 - 72);
            if (v46 >= *(unsigned int *)(v45 - 68))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod(v45 - 80, v45 - 64, v46 + 1, 8);
              v46 = *(unsigned int *)(v45 - 72);
            }
            *(_QWORD *)(*(_QWORD *)(v45 - 80) + 8 * v46) = v56;
            ++*(_DWORD *)(v45 - 72);
            goto LABEL_19;
          default:
            v53 = std::generic_category();
            __p[0] = 0;
            __p[1] = 0;
            v60 = 0;
            LODWORD(v64) = 0;
            v67 = 0;
            v68 = 0;
            v63 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
            v70 = __p;
            v69 = 0;
            v66[0] = 0;
            v66[1] = 0;
            v65 = 0;
            v61[0] = &unk_1E8145938;
            v61[1] = "invalid extended CFI opcode 0x%hhx";
            v61[2] = v15;
            llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v63, (uint64_t)v61);
            v54 = v70;
            v55 = operator new();
            v62 = 260;
            v61[0] = v54;
            *(_QWORD *)v55 = off_1E81A0C88;
            llvm::Twine::str((llvm::Twine *)v61, (_QWORD *)(v55 + 8));
            *(_QWORD *)(v55 + 32) = 92;
            *(_QWORD *)(v55 + 40) = v53;
            *(_BYTE *)(v55 + 48) = 1;
            *a5 = v55;
            v63 = off_1E81A6E70;
            if (v69 == 1 && v65)
              MEMORY[0x1CAA32F9C](v65, 0x1000C8077774924);
            if (SHIBYTE(v60) < 0)
              operator delete(__p[0]);
            if (*((_QWORD *)&v58 + 1))
              (*(void (**)(_QWORD))(**((_QWORD **)&v58 + 1) + 8))(*((_QWORD *)&v58 + 1));
            return;
        }
      }
      v16 = RelocatedValue & 0x3F;
      v17 = RelocatedValue & 0xC0;
      if (v17 == 128)
      {
        v18 = llvm::DataExtractor::getULEB128((uint64_t *)a2, (uint64_t *)&v58, (_QWORD *)&v58 + 1);
        v19 = a1;
        v20 = 0x80;
        v21 = v16;
LABEL_18:
        sub_1C5496918(v19, v20, v21, v18);
      }
      else
      {
        v23 = a1;
        v22 = v16;
LABEL_10:
        sub_1C54967DC(v23, v17, v22);
      }
LABEL_19:
      v14 = *((_QWORD *)&v58 + 1);
      v8 = v58;
      if (v58 >= a4)
        goto LABEL_52;
    }
    v8 = v58;
  }
LABEL_52:
  *a3 = v8;
  *a5 = v14;
}

void sub_1C54967DC(uint64_t a1, char a2, uint64_t a3)
{
  unint64_t v5;
  __int128 v6;
  __int128 v7;
  char *v8;
  uint64_t v9;
  char v10[8];
  void *v11;
  uint64_t v12;
  _BYTE v13[24];
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v10[0] = a2;
  v11 = v13;
  v12 = 0x300000000;
  LOBYTE(v14) = 0;
  LOBYTE(v16) = 0;
  v5 = *(_QWORD *)(a1 + 8);
  if (v5 >= *(_QWORD *)(a1 + 16))
  {
    v8 = sub_1C5499FC8((char **)a1, v10);
  }
  else
  {
    *(_BYTE *)v5 = a2;
    *(_QWORD *)(v5 + 8) = v5 + 24;
    *(_QWORD *)(v5 + 16) = 0x300000000;
    if ((_DWORD)v12)
      sub_1C614D378(v5 + 8, (uint64_t)&v11);
    v6 = v14;
    v7 = v15;
    *(_QWORD *)(v5 + 80) = v16;
    *(_OWORD *)(v5 + 48) = v6;
    *(_OWORD *)(v5 + 64) = v7;
    v8 = (char *)(v5 + 88);
  }
  *(_QWORD *)(a1 + 8) = v8;
  if (v11 != v13)
  {
    free(v11);
    v8 = *(char **)(a1 + 8);
  }
  v9 = *((unsigned int *)v8 - 18);
  if (v9 >= *((_DWORD *)v8 - 17))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v8 - 80), (uint64_t)(v8 - 64), v9 + 1, 8);
    LODWORD(v9) = *((_DWORD *)v8 - 18);
  }
  *(_QWORD *)(*((_QWORD *)v8 - 10) + 8 * v9) = a3;
  ++*((_DWORD *)v8 - 18);
}

void sub_1C5496918(uint64_t a1, char a2, uint64_t a3, uint64_t a4)
{
  unint64_t v7;
  __int128 v8;
  __int128 v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v14[8];
  void *v15;
  uint64_t v16;
  _BYTE v17[24];
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v14[0] = a2;
  v15 = v17;
  v16 = 0x300000000;
  LOBYTE(v18) = 0;
  LOBYTE(v20) = 0;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7 >= *(_QWORD *)(a1 + 16))
  {
    v10 = sub_1C5499FC8((char **)a1, v14);
  }
  else
  {
    *(_BYTE *)v7 = a2;
    *(_QWORD *)(v7 + 8) = v7 + 24;
    *(_QWORD *)(v7 + 16) = 0x300000000;
    if ((_DWORD)v16)
      sub_1C614D378(v7 + 8, (uint64_t)&v15);
    v8 = v18;
    v9 = v19;
    *(_QWORD *)(v7 + 80) = v20;
    *(_OWORD *)(v7 + 48) = v8;
    *(_OWORD *)(v7 + 64) = v9;
    v10 = (char *)(v7 + 88);
  }
  *(_QWORD *)(a1 + 8) = v10;
  if (v15 != v17)
  {
    free(v15);
    v10 = *(char **)(a1 + 8);
  }
  v11 = *((unsigned int *)v10 - 18);
  if (v11 >= *((_DWORD *)v10 - 17))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v10 - 80), (uint64_t)(v10 - 64), v11 + 1, 8);
    LODWORD(v11) = *((_DWORD *)v10 - 18);
  }
  *(_QWORD *)(*((_QWORD *)v10 - 10) + 8 * v11) = a3;
  ++*((_DWORD *)v10 - 18);
  v12 = *(_QWORD *)(a1 + 8);
  v13 = *(unsigned int *)(v12 - 72);
  if (v13 >= *(_DWORD *)(v12 - 68))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v12 - 80, v12 - 64, v13 + 1, 8);
    LODWORD(v13) = *(_DWORD *)(v12 - 72);
  }
  *(_QWORD *)(*(_QWORD *)(v12 - 80) + 8 * v13) = a4;
  ++*(_DWORD *)(v12 - 72);
}

const char *llvm::dwarf::CFIProgram::callFrameString(llvm::dwarf::CFIProgram *this, int a2)
{
  return llvm::dwarf::CallFrameString(a2, *((_DWORD *)this + 10));
}

const char *llvm::dwarf::CFIProgram::operandTypeString(unsigned int a1)
{
  if (a1 > 9)
    return "<unknown CFIProgram::OperandType>";
  else
    return off_1E8169D30[a1];
}

void llvm::dwarf::CFIProgram::Instruction::getOperandAsUnsigned(llvm::dwarf::CFIProgram::Instruction *this@<X0>, const llvm::dwarf::CFIProgram *a2@<X1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  const std::error_category *v6;
  void **v8;
  uint64_t v9;
  void (**v10)(llvm::raw_ostream *__hidden);
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char v15;
  uint64_t v16;
  int v17;
  void **v18;
  void *__p[2];
  uint64_t v20;
  _QWORD v21[3];
  __int16 v22;

  if (a3 < 3)
  {
    llvm::dwarf::CFIProgram::getOperandTypes(this);
    __asm { BR              X11 }
  }
  v6 = std::generic_category();
  __p[0] = 0;
  __p[1] = 0;
  v20 = 0;
  v11 = 0;
  v15 = 0;
  v16 = 0;
  v10 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
  v18 = __p;
  v17 = 0;
  v13 = 0;
  v14 = 0;
  v12 = 0;
  v21[0] = &off_1E8132728;
  v21[1] = "operand index %u is not valid";
  v21[2] = a3;
  llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v10, (uint64_t)v21);
  v8 = v18;
  v9 = operator new();
  v22 = 260;
  v21[0] = v8;
  *(_QWORD *)v9 = off_1E81A0C88;
  llvm::Twine::str((llvm::Twine *)v21, (_QWORD *)(v9 + 8));
  *(_QWORD *)(v9 + 32) = 22;
  *(_QWORD *)(v9 + 40) = v6;
  *(_BYTE *)(v9 + 48) = 1;
  v10 = off_1E81A6E70;
  if (v17 == 1 && v12)
    MEMORY[0x1CAA32F9C](v12, 0x1000C8077774924);
  if (SHIBYTE(v20) < 0)
    operator delete(__p[0]);
  *(_BYTE *)(a4 + 8) |= 1u;
  *(_QWORD *)a4 = v9;
}

uint64_t *llvm::dwarf::CFIProgram::getOperandTypes(llvm::dwarf::CFIProgram *this)
{
  __int128 v1;

  if ((byte_1ED804ED0 & 1) == 0)
  {
    byte_1ED804ED0 = 1;
    qword_1ED8051D8 = 0x100000004;
    dword_1ED8051E0 = 1;
    unk_1ED804EE4 = xmmword_1C8651980;
    unk_1ED804EF4 = xmmword_1C8651990;
    unk_1ED804F04 = xmmword_1C86519A0;
    qword_1ED805034 = 0x100000004;
    dword_1ED80503C = 1;
    qword_1ED804FB0 = 0x500000007;
    dword_1ED804FB8 = 1;
    unk_1ED804F68 = xmmword_1C86519B0;
    xmmword_1ED805118 = xmmword_1C86519C0;
    qword_1ED805128 = 0x800000005;
    unk_1ED804F78 = xmmword_1C86519D0;
    unk_1ED804FBC = 0x100000005;
    dword_1ED804FC4 = 1;
    unk_1ED804F88 = xmmword_1C86519E0;
    unk_1ED804F2C = xmmword_1C86519F0;
    unk_1ED804F3C = 0x100000001;
    qword_1ED8054D8 = 0x600000007;
    dword_1ED8054E0 = 1;
    unk_1ED804F14 = 0x600000007;
    dword_1ED804F1C = 1;
    qword_1ED804FA8 = 0x100000005;
    unk_1ED804FC8 = xmmword_1C8651A00;
    unk_1ED804F98 = xmmword_1C8651A10;
    xmmword_1ED804FD8 = xmmword_1C8651A20;
    dword_1ED804FE8 = 1;
    qword_1ED8057D8 = 0x100000007;
    dword_1ED8057E0 = 1;
    qword_1ED804F20 = 0x100000007;
    dword_1ED804F28 = 1;
    unk_1ED804F44 = xmmword_1C8651A30;
    *(_QWORD *)&v1 = 0x100000001;
    *((_QWORD *)&v1 + 1) = 0x100000001;
    unk_1ED804F54 = v1;
    dword_1ED804F64 = 1;
    xmmword_1ED8050F4 = xmmword_1C8651A40;
    qword_1ED805104 = 0x100000001;
    qword_1ED804ED8 = 0x100000001;
    dword_1ED804EE0 = 1;
  }
  return &qword_1ED804ED8;
}

void llvm::dwarf::CFIProgram::Instruction::getOperandAsSigned(llvm::dwarf::CFIProgram::Instruction *this@<X0>, const llvm::dwarf::CFIProgram *a2@<X1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  const std::error_category *v6;
  void **v8;
  uint64_t v9;
  void (**v10)(llvm::raw_ostream *__hidden);
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char v15;
  uint64_t v16;
  int v17;
  void **v18;
  void *__p[2];
  uint64_t v20;
  _QWORD v21[3];
  __int16 v22;

  if (a3 < 3)
  {
    llvm::dwarf::CFIProgram::getOperandTypes(this);
    __asm { BR              X11 }
  }
  v6 = std::generic_category();
  __p[0] = 0;
  __p[1] = 0;
  v20 = 0;
  v11 = 0;
  v15 = 0;
  v16 = 0;
  v10 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
  v18 = __p;
  v17 = 0;
  v13 = 0;
  v14 = 0;
  v12 = 0;
  v21[0] = &off_1E8132728;
  v21[1] = "operand index %u is not valid";
  v21[2] = a3;
  llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v10, (uint64_t)v21);
  v8 = v18;
  v9 = operator new();
  v22 = 260;
  v21[0] = v8;
  *(_QWORD *)v9 = off_1E81A0C88;
  llvm::Twine::str((llvm::Twine *)v21, (_QWORD *)(v9 + 8));
  *(_QWORD *)(v9 + 32) = 22;
  *(_QWORD *)(v9 + 40) = v6;
  *(_BYTE *)(v9 + 48) = 1;
  v10 = off_1E81A6E70;
  if (v17 == 1 && v12)
    MEMORY[0x1CAA32F9C](v12, 0x1000C8077774924);
  if (SHIBYTE(v20) < 0)
    operator delete(__p[0]);
  *(_BYTE *)(a4 + 8) |= 1u;
  *(_QWORD *)a4 = v9;
}

llvm::raw_ostream *llvm::dwarf::CFIProgram::printOperand(uint64_t a1, llvm::raw_ostream *a2, __int128 *a3, llvm::MCRegisterInfo *a4, int a5, unsigned __int8 *a6, int a7, uint64_t a8)
{
  uint64_t v16;
  llvm::raw_ostream *result;
  void *v18;
  llvm::raw_ostream *v19;
  void *v20;
  const char *v21;
  size_t v22;
  size_t v23;
  const char *v24;
  size_t v25;
  const char *v26;
  size_t v27;
  _BYTE *v28;
  void *v29;
  void *v30;
  const char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  _BYTE *v36;
  char *v37;
  _BYTE *v38;
  void *v39;
  const char *v40;
  uint64_t v41;
  __int128 v42[5];
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v16 = *a6;
  result = (llvm::raw_ostream *)llvm::dwarf::CFIProgram::getOperandTypes((llvm::dwarf::CFIProgram *)a1);
  switch(*(_DWORD *)&byte_1ED804ED0[12 * v16 + 8 + 4 * a7])
  {
    case 0:
      v18 = (void *)*((_QWORD *)a2 + 4);
      if (*((_QWORD *)a2 + 3) - (_QWORD)v18 > 0xCuLL)
      {
        qmemcpy(v18, " Unsupported ", 13);
        v20 = (void *)(*((_QWORD *)a2 + 4) + 13);
        *((_QWORD *)a2 + 4) = v20;
        v19 = a2;
      }
      else
      {
        v19 = llvm::raw_ostream::write(a2, " Unsupported ", 0xDuLL);
        v20 = (void *)*((_QWORD *)v19 + 4);
      }
      if (a7)
        v21 = "second";
      else
        v21 = "first";
      if (a7)
        v22 = 6;
      else
        v22 = 5;
      if (v22 <= *((_QWORD *)v19 + 3) - (_QWORD)v20)
      {
        memcpy(v20, v21, v22);
        v23 = *((_QWORD *)v19 + 4) + v22;
        *((_QWORD *)v19 + 4) = v23;
      }
      else
      {
        v19 = llvm::raw_ostream::write(v19, v21, v22);
        v23 = *((_QWORD *)v19 + 4);
      }
      if (*((_QWORD *)v19 + 3) - v23 > 0xA)
      {
        *(_DWORD *)(v23 + 7) = 1869881444;
        *(_QWORD *)v23 = *(_QWORD *)" operand to";
        *((_QWORD *)v19 + 4) += 11;
      }
      else
      {
        llvm::raw_ostream::write(v19, " operand to", 0xBuLL);
      }
      v24 = llvm::dwarf::CallFrameString(v16, *(_DWORD *)(a1 + 40));
      if (!v25)
      {
        v39 = &unk_1E8145938;
        v40 = " Opcode %x";
        v41 = v16;
        return llvm::raw_ostream::operator<<(a2, (uint64_t)&v39);
      }
      v26 = v24;
      v27 = v25;
      v28 = (_BYTE *)*((_QWORD *)a2 + 4);
      if (*((_BYTE **)a2 + 3) == v28)
      {
        a2 = llvm::raw_ostream::write(a2, " ", 1uLL);
        v29 = (void *)*((_QWORD *)a2 + 4);
      }
      else
      {
        *v28 = 32;
        v29 = (void *)(*((_QWORD *)a2 + 4) + 1);
        *((_QWORD *)a2 + 4) = v29;
      }
      if (v27 > *((_QWORD *)a2 + 3) - (_QWORD)v29)
        return llvm::raw_ostream::write(a2, v26, v27);
      result = (llvm::raw_ostream *)memcpy(v29, v26, v27);
      *((_QWORD *)a2 + 4) += v27;
      return result;
    case 2:
      v30 = &unk_1E8133270;
      v31 = " %llx";
      goto LABEL_37;
    case 3:
      v30 = &unk_1E8169D20;
      v31 = " %+lld";
      goto LABEL_37;
    case 4:
      v32 = *(_QWORD *)(a1 + 24);
      if (v32)
        goto LABEL_26;
      v30 = &unk_1E8133270;
      v31 = " %lld*code_alignment_factor";
      goto LABEL_37;
    case 5:
      v33 = *(_QWORD *)(a1 + 32);
      if (v33)
      {
        v34 = v33 * a8;
        v35 = (char *)&unk_1E8169D10;
        goto LABEL_27;
      }
      v37 = (char *)&unk_1E8169D10;
      goto LABEL_36;
    case 6:
      v32 = *(_QWORD *)(a1 + 32);
      if (v32)
      {
LABEL_26:
        v34 = v32 * a8;
        v35 = (char *)&unk_1E8133260;
LABEL_27:
        v39 = v35 + 16;
        v40 = " %lld";
        v41 = v34;
      }
      else
      {
        v37 = (char *)&unk_1E8133260;
LABEL_36:
        v30 = v37 + 16;
        v31 = " %lld*data_alignment_factor";
LABEL_37:
        v39 = v30;
        v40 = v31;
        v41 = a8;
      }
      return llvm::raw_ostream::operator<<(a2, (uint64_t)&v39);
    case 7:
      v36 = (_BYTE *)*((_QWORD *)a2 + 4);
      if ((unint64_t)v36 >= *((_QWORD *)a2 + 3))
      {
        llvm::raw_ostream::write(a2, 32);
      }
      else
      {
        *((_QWORD *)a2 + 4) = v36 + 1;
        *v36 = 32;
      }
      return sub_1C54940BC(a2, a4, a5, a8);
    case 8:
      v30 = &unk_1E8133270;
      v31 = " in addrspace%lld";
      goto LABEL_37;
    case 9:
      v38 = (_BYTE *)*((_QWORD *)a2 + 4);
      if (*((_BYTE **)a2 + 3) == v38)
      {
        llvm::raw_ostream::write(a2, " ", 1uLL);
      }
      else
      {
        *v38 = 32;
        ++*((_QWORD *)a2 + 4);
      }
      sub_1C624C4A4((uint64_t)v42, a3);
      llvm::DWARFExpression::print((uint64_t)(a6 + 48), a2, v42, a4, 0, a5);
      return (llvm::raw_ostream *)sub_1C624C568(v42);
    default:
      return result;
  }
}

unsigned __int8 **llvm::dwarf::CFIProgram::dump(unsigned __int8 **result, unsigned __int8 ***this, __int128 *a3, llvm::MCRegisterInfo *a4, int a5, int a6)
{
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  uint64_t v12;
  unsigned int v13;
  int v14;
  size_t v15;
  const char *v16;
  size_t v17;
  llvm::raw_ostream *v18;
  unint64_t v19;
  _BYTE *v20;
  __int128 v21[5];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v6 = *result;
  v7 = result[1];
  if (*result != v7)
  {
    v12 = (uint64_t)result;
    v13 = 2 * a6;
    do
    {
      v14 = *v6;
      llvm::raw_ostream::indent((llvm::raw_ostream *)this, v13);
      v16 = llvm::dwarf::CallFrameString(v14, *(_DWORD *)(v12 + 40));
      v17 = v15;
      result = this[4];
      if (v15 <= (char *)this[3] - (char *)result)
      {
        if (v15)
        {
          memcpy(result, v16, v15);
          result = (unsigned __int8 **)((char *)this[4] + v17);
          this[4] = result;
        }
        v18 = (llvm::raw_ostream *)this;
      }
      else
      {
        v18 = llvm::raw_ostream::write((llvm::raw_ostream *)this, v16, v15);
        result = (unsigned __int8 **)*((_QWORD *)v18 + 4);
      }
      if (*((unsigned __int8 ***)v18 + 3) == result)
      {
        result = (unsigned __int8 **)llvm::raw_ostream::write(v18, ":", 1uLL);
      }
      else
      {
        *(_BYTE *)result = 58;
        ++*((_QWORD *)v18 + 4);
      }
      if (*((_DWORD *)v6 + 4))
      {
        v19 = 0;
        do
        {
          sub_1C624C4A4((uint64_t)v21, a3);
          llvm::dwarf::CFIProgram::printOperand(v12, (llvm::raw_ostream *)this, v21, a4, a5, v6, v19, *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * v19));
          result = (unsigned __int8 **)sub_1C624C568(v21);
          ++v19;
        }
        while (v19 < *((unsigned int *)v6 + 4));
      }
      v20 = this[4];
      if (v20 >= (_BYTE *)this[3])
      {
        result = (unsigned __int8 **)llvm::raw_ostream::write((llvm::raw_ostream *)this, 10);
      }
      else
      {
        this[4] = (unsigned __int8 **)(v20 + 1);
        *v20 = 10;
      }
      v6 += 88;
    }
    while (v6 != v7);
  }
  return result;
}

void llvm::dwarf::CIE::dump(uint64_t a1, llvm::raw_ostream *a2, uint64_t a3, llvm::MCRegisterInfo *a4, int a5)
{
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  llvm::raw_ostream *v13;
  size_t v14;
  _BYTE *v15;
  llvm::raw_ostream *v16;
  int v17;
  uint64_t v18;
  llvm::raw_ostream *v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  llvm::raw_ostream *v24;
  void *v25;
  _DWORD *v26;
  const char *v27;
  _BYTE *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  llvm::raw_ostream *v32;
  llvm::raw_ostream *v33;
  _WORD *v34;
  uint64_t v35;
  llvm::raw_ostream *v36;
  uint64_t v37;
  uint64_t v38;
  llvm::raw_ostream *v39;
  uint64_t v40;
  llvm::raw_ostream *v41;
  uint64_t v42;
  uint64_t v43;
  _BYTE *v44;
  uint64_t v45;
  unsigned __int8 *v46;
  unint64_t v47;
  _BYTE *v48;
  char v49;
  char *v50;
  char v51;
  char *v52;
  _BYTE *v53;
  _BYTE *v54;
  llvm::dwarf::UnwindRow *v55;
  llvm::dwarf::UnwindRow *v56;
  _BYTE *v57;
  uint64_t v58;
  const std::error_category *v59;
  uint64_t v60;
  char *v61;
  char *v62;
  uint64_t v63;
  uint64_t v64;
  const char *v65;
  int v66;
  uint64_t v67;
  _BYTE *v68[3];
  char *v69;
  const char *v70;
  uint64_t v71;
  uint64_t v72;
  char v73;
  __int128 v74[5];
  uint64_t v75;

  v75 = *MEMORY[0x1E0C80C00];
  if (a5 && !*(_QWORD *)(a1 + 24))
  {
    v10 = *(_QWORD *)(a1 + 16);
    v69 = (char *)&unk_1E8133270;
    v70 = "%08llx";
    v71 = v10;
    llvm::raw_ostream::operator<<(a2, (uint64_t)&v69);
    v11 = *((_QWORD *)a2 + 4);
    if ((unint64_t)(*((_QWORD *)a2 + 3) - v11) <= 0x10)
    {
      v12 = " ZERO terminator\n";
      v13 = a2;
      v14 = 17;
LABEL_5:
      llvm::raw_ostream::write(v13, v12, v14);
      return;
    }
    *(_BYTE *)(v11 + 16) = 10;
    *(_OWORD *)v11 = *(_OWORD *)" ZERO terminator\n";
    v58 = *((_QWORD *)a2 + 4) + 17;
LABEL_71:
    *((_QWORD *)a2 + 4) = v58;
    return;
  }
  v15 = *(_BYTE **)(a1 + 16);
  v68[0] = &unk_1E8133270;
  v68[1] = "%08llx";
  v68[2] = v15;
  v16 = llvm::raw_ostream::operator<<(a2, (uint64_t)v68);
  if (*(_BYTE *)(a1 + 12))
    v17 = 16;
  else
    v17 = 8;
  v18 = *(_QWORD *)(a1 + 24);
  v69 = (char *)&unk_1E81698E0;
  v70 = " %0*llx";
  LODWORD(v71) = v17;
  v72 = v18;
  v19 = llvm::raw_ostream::operator<<(v16, (uint64_t)&v69);
  if (*(_BYTE *)(a1 + 12))
    v20 = a5;
  else
    v20 = 1;
  v21 = 0xFFFFFFFFLL;
  if (*(_BYTE *)(a1 + 12))
    v21 = -1;
  if (v20)
    v22 = 8;
  else
    v22 = 16;
  v64 = (uint64_t)&unk_1E81698E0;
  v65 = " %0*llx";
  if (a5)
    v21 = 0;
  v66 = v22;
  v67 = v21;
  llvm::raw_ostream::operator<<(v19, (uint64_t)&v64);
  v23 = *((_QWORD *)a2 + 4);
  if ((unint64_t)(*((_QWORD *)a2 + 3) - v23) > 4)
  {
    *(_BYTE *)(v23 + 4) = 10;
    *(_DWORD *)v23 = 1162429216;
    v25 = (void *)(*((_QWORD *)a2 + 4) + 5);
    *((_QWORD *)a2 + 4) = v25;
    v24 = a2;
  }
  else
  {
    v24 = llvm::raw_ostream::write(a2, " CIE\n", 5uLL);
    v25 = (void *)*((_QWORD *)v24 + 4);
  }
  if (*((_QWORD *)v24 + 3) - (_QWORD)v25 > 0x18uLL)
  {
    qmemcpy(v25, "  Format:                ", 25);
    v26 = (_DWORD *)(*((_QWORD *)v24 + 4) + 25);
    *((_QWORD *)v24 + 4) = v26;
  }
  else
  {
    v24 = llvm::raw_ostream::write(v24, "  Format:                ", 0x19uLL);
    v26 = (_DWORD *)*((_QWORD *)v24 + 4);
  }
  if (*(_BYTE *)(a1 + 12))
    v27 = "DWARF64";
  else
    v27 = "DWARF32";
  if (*((_QWORD *)v24 + 3) - (_QWORD)v26 > 6uLL)
  {
    *v26 = *(_DWORD *)v27;
    *(_DWORD *)((char *)v26 + 3) = *(_DWORD *)(v27 + 3);
    v28 = (_BYTE *)(*((_QWORD *)v24 + 4) + 7);
    *((_QWORD *)v24 + 4) = v28;
  }
  else
  {
    v24 = llvm::raw_ostream::write(v24, v27, 7uLL);
    v28 = (_BYTE *)*((_QWORD *)v24 + 4);
  }
  if (*((_BYTE **)v24 + 3) == v28)
  {
    llvm::raw_ostream::write(v24, "\n", 1uLL);
    if (!a5)
      goto LABEL_34;
  }
  else
  {
    *v28 = 10;
    ++*((_QWORD *)v24 + 4);
    if (!a5)
      goto LABEL_34;
  }
  if (*(_BYTE *)(a1 + 80) != 1)
  {
    v29 = (void *)*((_QWORD *)a2 + 4);
    if (*((_QWORD *)a2 + 3) - (_QWORD)v29 > 0x20uLL)
    {
      qmemcpy(v29, "WARNING: unsupported CIE version\n", 33);
      *((_QWORD *)a2 + 4) += 33;
    }
    else
    {
      llvm::raw_ostream::write(a2, "WARNING: unsupported CIE version\n", 0x21uLL);
    }
  }
LABEL_34:
  v30 = *(unsigned __int8 *)(a1 + 80);
  v69 = (char *)&unk_1E8145938;
  v70 = "  Version:               %d\n";
  v71 = v30;
  llvm::raw_ostream::operator<<(a2, (uint64_t)&v69);
  v31 = (void *)*((_QWORD *)a2 + 4);
  if (*((_QWORD *)a2 + 3) - (_QWORD)v31 > 0x19uLL)
  {
    qmemcpy(v31, "  Augmentation:          \"", 26);
    *((_QWORD *)a2 + 4) += 26;
    v32 = a2;
  }
  else
  {
    v32 = llvm::raw_ostream::write(a2, "  Augmentation:          \"", 0x1AuLL);
  }
  v33 = llvm::raw_ostream::write(v32, *(const char **)(a1 + 88), *(_QWORD *)(a1 + 96));
  v34 = (_WORD *)*((_QWORD *)v33 + 4);
  if (*((_QWORD *)v33 + 3) - (_QWORD)v34 > 1uLL)
  {
    *v34 = 2594;
    *((_QWORD *)v33 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(v33, "\"\n", 2uLL);
  }
  if (*(unsigned __int8 *)(a1 + 80) >= 4u)
  {
    v35 = *(unsigned __int8 *)(a1 + 120);
    v69 = (char *)&off_1E8132728;
    v70 = "  Address size:          %u\n";
    v71 = v35;
    v36 = llvm::raw_ostream::operator<<(a2, (uint64_t)&v69);
    v37 = *(unsigned __int8 *)(a1 + 121);
    v69 = (char *)&off_1E8132728;
    v70 = "  Segment desc size:     %u\n";
    v71 = v37;
    llvm::raw_ostream::operator<<(v36, (uint64_t)&v69);
  }
  v38 = *(unsigned int *)(a1 + 128);
  v69 = (char *)&off_1E8132728;
  v70 = "  Code alignment factor: %u\n";
  v71 = v38;
  v39 = llvm::raw_ostream::operator<<(a2, (uint64_t)&v69);
  v40 = *(unsigned int *)(a1 + 136);
  v69 = (char *)&unk_1E8169D00;
  v70 = "  Data alignment factor: %d\n";
  v71 = v40;
  v41 = llvm::raw_ostream::operator<<(v39, (uint64_t)&v69);
  v42 = *(unsigned int *)(a1 + 144);
  v69 = (char *)&unk_1E8169D00;
  v70 = "  Return address column: %d\n";
  v71 = v42;
  llvm::raw_ostream::operator<<(v41, (uint64_t)&v69);
  if (*(_BYTE *)(a1 + 200))
  {
    v43 = *(_QWORD *)(a1 + 192);
    v69 = (char *)&unk_1E8133270;
    v70 = "  Personality Address: %016llx\n";
    v71 = v43;
    llvm::raw_ostream::operator<<(a2, (uint64_t)&v69);
  }
  v44 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*(_QWORD *)(a1 + 160))
  {
    if (*((_QWORD *)a2 + 3) - (_QWORD)v44 > 0x17uLL)
    {
      qmemcpy(v44, "  Augmentation data:    ", 24);
      *((_QWORD *)a2 + 4) += 24;
    }
    else
    {
      llvm::raw_ostream::write(a2, "  Augmentation data:    ", 0x18uLL);
    }
    v45 = *(_QWORD *)(a1 + 160);
    if (v45)
    {
      v46 = *(unsigned __int8 **)(a1 + 152);
      do
      {
        v47 = *v46;
        v48 = (_BYTE *)*((_QWORD *)a2 + 4);
        if ((unint64_t)v48 >= *((_QWORD *)a2 + 3))
        {
          llvm::raw_ostream::write(a2, 32);
        }
        else
        {
          *((_QWORD *)a2 + 4) = v48 + 1;
          *v48 = 32;
        }
        v49 = a0123456789abcd_6[v47 >> 4];
        v50 = (char *)*((_QWORD *)a2 + 4);
        if ((unint64_t)v50 >= *((_QWORD *)a2 + 3))
        {
          llvm::raw_ostream::write(a2, v49);
        }
        else
        {
          *((_QWORD *)a2 + 4) = v50 + 1;
          *v50 = v49;
        }
        v51 = a0123456789abcd_6[v47 & 0xF];
        v52 = (char *)*((_QWORD *)a2 + 4);
        if ((unint64_t)v52 >= *((_QWORD *)a2 + 3))
        {
          llvm::raw_ostream::write(a2, v51);
        }
        else
        {
          *((_QWORD *)a2 + 4) = v52 + 1;
          *v52 = v51;
        }
        ++v46;
        --v45;
      }
      while (v45);
    }
    v53 = (_BYTE *)*((_QWORD *)a2 + 4);
    if (*((_BYTE **)a2 + 3) == v53)
    {
      llvm::raw_ostream::write(a2, "\n", 1uLL);
      v44 = (_BYTE *)*((_QWORD *)a2 + 4);
    }
    else
    {
      *v53 = 10;
      v44 = (_BYTE *)(*((_QWORD *)a2 + 4) + 1);
      *((_QWORD *)a2 + 4) = v44;
    }
  }
  if (*((_BYTE **)a2 + 3) == v44)
  {
    llvm::raw_ostream::write(a2, "\n", 1uLL);
  }
  else
  {
    *v44 = 10;
    ++*((_QWORD *)a2 + 4);
  }
  sub_1C624C4A4((uint64_t)v74, (__int128 *)a3);
  llvm::dwarf::CFIProgram::dump((unsigned __int8 **)(a1 + 32), (unsigned __int8 ***)a2, v74, a4, a5, 1);
  sub_1C624C568(v74);
  v54 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v54)
  {
    llvm::raw_ostream::write(a2, "\n", 1uLL);
  }
  else
  {
    *v54 = 10;
    ++*((_QWORD *)a2 + 4);
  }
  llvm::dwarf::UnwindTable::create(a1, (uint64_t)&v69);
  if ((v73 & 1) == 0)
  {
    v55 = (llvm::dwarf::UnwindRow *)v69;
    v56 = (llvm::dwarf::UnwindRow *)v70;
    while (v55 != v56)
    {
      llvm::dwarf::UnwindRow::dump(v55, a2, a4, a5, 1);
      v55 = (llvm::dwarf::UnwindRow *)((char *)v55 + 112);
    }
    v64 = (uint64_t)&v69;
    sub_1C5499DBC((void ***)&v64);
LABEL_68:
    v57 = (_BYTE *)*((_QWORD *)a2 + 4);
    if (*((_BYTE **)a2 + 3) == v57)
    {
      v12 = "\n";
      v13 = a2;
      v14 = 1;
      goto LABEL_5;
    }
    *v57 = 10;
    v58 = *((_QWORD *)a2 + 4) + 1;
    goto LABEL_71;
  }
  v59 = std::generic_category();
  v64 = 22;
  v65 = (const char *)v59;
  v68[0] = "decoding the CIE opcodes into rows failed";
  sub_1C5DF1730(v68, &v64, &v62);
  v61 = v69;
  sub_1C624E8DC(&v62, &v61, &v63);
  v60 = *(_QWORD *)(a3 + 48);
  if (v60)
  {
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v60 + 48))(v60, &v63);
    if (v63)
      (*(void (**)(uint64_t))(*(_QWORD *)v63 + 8))(v63);
    if (v61)
      (*(void (**)(char *))(*(_QWORD *)v61 + 8))(v61);
    if (v62)
      (*(void (**)(char *))(*(_QWORD *)v62 + 8))(v62);
    goto LABEL_68;
  }
  sub_1C485C2F0();
  llvm::dwarf::FDE::dump();
}

void llvm::dwarf::FDE::dump(uint64_t a1, llvm::raw_ostream *a2, uint64_t a3, llvm::MCRegisterInfo *a4, int a5)
{
  _BYTE *v10;
  llvm::raw_ostream *v11;
  int v12;
  uint64_t v13;
  llvm::raw_ostream *v14;
  int v15;
  BOOL v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  _OWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _OWORD *v25;
  llvm::raw_ostream *v26;
  _DWORD *v27;
  const char *v28;
  _BYTE *v29;
  uint64_t v30;
  _BYTE *v31;
  llvm::dwarf::UnwindRow *v32;
  llvm::dwarf::UnwindRow *v33;
  _BYTE *v34;
  const std::error_category *v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  char v39;
  uint64_t v40;
  char *v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  const char *v45;
  int v46;
  uint64_t v47;
  _BYTE *v48[3];
  char *v49;
  const char *v50;
  uint64_t v51;
  uint64_t v52;
  char v53;
  __int128 v54[5];
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v10 = *(_BYTE **)(a1 + 16);
  v48[0] = &unk_1E8133270;
  v48[1] = "%08llx";
  v48[2] = v10;
  v11 = llvm::raw_ostream::operator<<(a2, (uint64_t)v48);
  if (*(_BYTE *)(a1 + 12))
    v12 = 16;
  else
    v12 = 8;
  v13 = *(_QWORD *)(a1 + 24);
  v49 = (char *)&unk_1E81698E0;
  v50 = " %0*llx";
  LODWORD(v51) = v12;
  v52 = v13;
  v14 = llvm::raw_ostream::operator<<(v11, (uint64_t)&v49);
  if (*(_BYTE *)(a1 + 12))
    v15 = a5;
  else
    v15 = 1;
  v16 = v15 == 0;
  v17 = *(_QWORD *)(a1 + 80);
  if (v16)
    v18 = 16;
  else
    v18 = 8;
  v44 = (uint64_t)&unk_1E81698E0;
  v45 = " %0*llx";
  v46 = v18;
  v47 = v17;
  llvm::raw_ostream::operator<<(v14, (uint64_t)&v44);
  v19 = *((_QWORD *)a2 + 4);
  if ((unint64_t)(*((_QWORD *)a2 + 3) - v19) > 8)
  {
    *(_BYTE *)(v19 + 8) = 61;
    *(_QWORD *)v19 = *(_QWORD *)" FDE cie=";
    *((_QWORD *)a2 + 4) += 9;
  }
  else
  {
    llvm::raw_ostream::write(a2, " FDE cie=", 9uLL);
  }
  v20 = *(_QWORD *)(a1 + 104);
  if (v20)
  {
    v22 = *(_QWORD *)(v20 + 16);
    v49 = (char *)&unk_1E8133270;
    v50 = "%08llx";
    v51 = v22;
    llvm::raw_ostream::operator<<(a2, (uint64_t)&v49);
  }
  else
  {
    v21 = (_OWORD *)*((_QWORD *)a2 + 4);
    if (*((_QWORD *)a2 + 3) - (_QWORD)v21 > 0xFuLL)
    {
      *v21 = *(_OWORD *)"<invalid offset>";
      *((_QWORD *)a2 + 4) += 16;
    }
    else
    {
      llvm::raw_ostream::write(a2, "<invalid offset>", 0x10uLL);
    }
  }
  v23 = *(_QWORD *)(a1 + 88);
  v24 = *(_QWORD *)(a1 + 96) + v23;
  v49 = (char *)&unk_1E8169BA8;
  v50 = " pc=%08llx...%08llx\n";
  v51 = v23;
  v52 = v24;
  llvm::raw_ostream::operator<<(a2, (uint64_t)&v49);
  v25 = (_OWORD *)*((_QWORD *)a2 + 4);
  if (*((_QWORD *)a2 + 3) - (_QWORD)v25 > 0xFuLL)
  {
    *v25 = *(_OWORD *)"  Format:       ";
    v27 = (_DWORD *)(*((_QWORD *)a2 + 4) + 16);
    *((_QWORD *)a2 + 4) = v27;
    v26 = a2;
  }
  else
  {
    v26 = llvm::raw_ostream::write(a2, "  Format:       ", 0x10uLL);
    v27 = (_DWORD *)*((_QWORD *)v26 + 4);
  }
  if (*(_BYTE *)(a1 + 12))
    v28 = "DWARF64";
  else
    v28 = "DWARF32";
  if (*((_QWORD *)v26 + 3) - (_QWORD)v27 > 6uLL)
  {
    *v27 = *(_DWORD *)v28;
    *(_DWORD *)((char *)v27 + 3) = *(_DWORD *)(v28 + 3);
    v29 = (_BYTE *)(*((_QWORD *)v26 + 4) + 7);
    *((_QWORD *)v26 + 4) = v29;
  }
  else
  {
    v26 = llvm::raw_ostream::write(v26, v28, 7uLL);
    v29 = (_BYTE *)*((_QWORD *)v26 + 4);
  }
  if (*((_BYTE **)v26 + 3) == v29)
  {
    llvm::raw_ostream::write(v26, "\n", 1uLL);
  }
  else
  {
    *v29 = 10;
    ++*((_QWORD *)v26 + 4);
  }
  if (*(_BYTE *)(a1 + 120))
  {
    v30 = *(_QWORD *)(a1 + 112);
    v49 = (char *)&unk_1E8133270;
    v50 = "  LSDA Address: %016llx\n";
    v51 = v30;
    llvm::raw_ostream::operator<<(a2, (uint64_t)&v49);
  }
  sub_1C624C4A4((uint64_t)v54, (__int128 *)a3);
  llvm::dwarf::CFIProgram::dump((unsigned __int8 **)(a1 + 32), (unsigned __int8 ***)a2, v54, a4, a5, 1);
  sub_1C624C568(v54);
  v31 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v31)
  {
    llvm::raw_ostream::write(a2, "\n", 1uLL);
  }
  else
  {
    *v31 = 10;
    ++*((_QWORD *)a2 + 4);
  }
  llvm::dwarf::UnwindTable::create((_QWORD *)a1, (uint64_t)&v49);
  if ((v53 & 1) != 0)
  {
    v35 = std::generic_category();
    v44 = 22;
    v45 = (const char *)v35;
    v48[0] = "decoding the FDE opcodes into rows failed";
    sub_1C5DF1730(v48, &v44, &v42);
    v41 = v49;
    sub_1C624E8DC(&v42, &v41, &v43);
    v36 = *(_QWORD *)(a3 + 48);
    if (!v36)
    {
      sub_1C485C2F0();
      llvm::DWARFDebugFrame::DWARFDebugFrame(v37, v38, v39, v40);
      return;
    }
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v36 + 48))(v36, &v43);
    if (v43)
      (*(void (**)(uint64_t))(*(_QWORD *)v43 + 8))(v43);
    if (v41)
      (*(void (**)(char *))(*(_QWORD *)v41 + 8))(v41);
    if (v42)
      (*(void (**)(char *))(*(_QWORD *)v42 + 8))(v42);
  }
  else
  {
    v32 = (llvm::dwarf::UnwindRow *)v49;
    v33 = (llvm::dwarf::UnwindRow *)v50;
    while (v32 != v33)
    {
      llvm::dwarf::UnwindRow::dump(v32, a2, a4, a5, 1);
      v32 = (llvm::dwarf::UnwindRow *)((char *)v32 + 112);
    }
    v44 = (uint64_t)&v49;
    sub_1C5499DBC((void ***)&v44);
  }
  v34 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v34)
  {
    llvm::raw_ostream::write(a2, "\n", 1uLL);
  }
  else
  {
    *v34 = 10;
    ++*((_QWORD *)a2 + 4);
  }
}

uint64_t llvm::DWARFDebugFrame::DWARFDebugFrame(uint64_t result, int a2, char a3, uint64_t a4)
{
  *(_DWORD *)result = a2;
  *(_BYTE *)(result + 4) = a3;
  *(_QWORD *)(result + 8) = a4;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 32) = 0;
  return result;
}

{
  *(_DWORD *)result = a2;
  *(_BYTE *)(result + 4) = a3;
  *(_QWORD *)(result + 8) = a4;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 32) = 0;
  return result;
}

void llvm::DWARFDebugFrame::~DWARFDebugFrame(llvm::DWARFDebugFrame *this)
{
  void **v1;

  v1 = (void **)((char *)this + 16);
  sub_1C4764BBC(&v1);
}

{
  void **v1;

  v1 = (void **)((char *)this + 16);
  sub_1C4764BBC(&v1);
}

uint64_t llvm::DWARFDebugFrame::parse@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v4;
  void (**v6)(llvm::raw_ostream *__hidden);
  unint64_t v7;
  unint64_t InitialLength;
  unsigned __int8 v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  unint64_t RelocatedValue;
  unint64_t v16;
  int v17;
  uint64_t v18;
  unint64_t v19;
  unsigned int v20;
  const char *CStrRef;
  const char *v22;
  char v23;
  void (**v24)(llvm::raw_ostream *__hidden);
  unsigned int v25;
  void (***v26)(llvm::raw_ostream *__hidden);
  void (**v27)(llvm::raw_ostream *__hidden);
  void (***v28)(llvm::raw_ostream *__hidden);
  int v29;
  BOOL v30;
  unsigned int v31;
  unint64_t v32;
  _BOOL4 v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  int v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  _BOOL4 v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  void (***v53)(llvm::raw_ostream *__hidden);
  void (**v54)(llvm::raw_ostream *__hidden);
  unint64_t EncodedPointer;
  char v56;
  unint64_t v57;
  unint64_t v58;
  char v59;
  size_t v60;
  uint64_t *v61;
  uint64_t ULEB128;
  unint64_t v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  uint64_t v69;
  int v70;
  size_t v71;
  __int128 v72;
  unint64_t v73;
  uint64_t *v74;
  _QWORD *v75;
  const std::error_category *v76;
  const char *v77;
  unint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  unint64_t v85;
  _QWORD *v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t v89;
  unint64_t v90;
  char *v91;
  _QWORD *v92;
  uint64_t v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  char *v97;
  const std::error_category *v98;
  void **v99;
  uint64_t v100;
  const std::error_category *v101;
  void **v102;
  uint64_t v103;
  uint64_t *v104;
  char *v105;
  uint64_t v106;
  uint64_t *v107;
  uint64_t v108;
  uint64_t v109;
  const std::error_category *v110;
  const char *v111;
  void **v112;
  uint64_t v113;
  int v114;
  unint64_t v115;
  unint64_t v116;
  unint64_t v117;
  uint64_t *v118;
  char *v119;
  uint64_t v120;
  uint64_t *v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  __int128 v125;
  char v126;
  void **v127;
  uint64_t v128;
  const std::error_category *v129;
  void **v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  unint64_t v134;
  uint64_t *v135;
  _QWORD *v136;
  _QWORD *v137;
  uint64_t v138;
  unint64_t v139;
  uint64_t v140;
  unint64_t v141;
  char *v142;
  uint64_t *v143;
  char *v144;
  uint64_t v145;
  uint64_t *v146;
  uint64_t v147;
  uint64_t v148;
  const char *__src;
  uint64_t v151;
  uint64_t SLEB128;
  uint64_t v153;
  char v154;
  char v155;
  uint64_t v156;
  int v157;
  unint64_t v158;
  int v159;
  unint64_t v160;
  uint64_t *v161;
  unsigned __int8 v162[8];
  unsigned __int8 v163[8];
  unsigned __int8 v164;
  unint64_t v165;
  unint64_t __n;
  size_t __na;
  uint64_t v168;
  unint64_t v169;
  uint64_t v170;
  unint64_t v171;
  unint64_t v172;
  unint64_t v173;
  void (**v174)(llvm::raw_ostream *__hidden);
  _OWORD v176[2];
  uint64_t v177;
  unint64_t v178;
  _QWORD v179[2];
  int v180;
  unint64_t v181;
  void *v182;
  __int128 v183;
  uint64_t v184;
  uint64_t *v185;
  __int128 v186;
  uint64_t v187;
  void (**v188)(llvm::raw_ostream *__hidden);
  __int128 v189;
  uint64_t v190;
  uint64_t v191;
  char v192;
  uint64_t v193;
  int v194;
  void **v195;
  void **v196;
  __int128 v197;
  uint64_t v198;
  __int16 v199;
  uint64_t v200;

  v4 = a1;
  v200 = *MEMORY[0x1E0C80C00];
  v181 = 0;
  v6 = (void (**)(llvm::raw_ostream *__hidden))&v190;
  v179[0] = 0;
  v179[1] = 0;
  v180 = 0;
LABEL_2:
  v7 = v181;
  if (*(_QWORD *)(a2 + 8) <= v181)
    goto LABEL_240;
  v178 = v181;
  InitialLength = llvm::DWARFDataExtractor::getInitialLength(a2, &v181, 0);
  v10 = v9;
  v11 = v9 == 1;
  if (!InitialLength)
  {
    v187 = 0;
    v185 = &v187;
    v186 = xmmword_1C6464ED0;
    v184 = 0;
    v182 = &v184;
    v183 = xmmword_1C6464ED0;
    v132 = operator new();
    v188 = (void (**)(llvm::raw_ostream *__hidden))&v190;
    v189 = xmmword_1C6464ED0;
    if ((_QWORD)v186)
      sub_1C4FE6ED8((uint64_t)&v188, (uint64_t)&v185);
    v196 = (void **)&v198;
    v197 = xmmword_1C6464ED0;
    if ((_QWORD)v183)
      sub_1C4FE6ED8((uint64_t)&v196, (uint64_t)&v182);
    sub_1C549A634(v132, v10 == 1, v7, 0, 0, (uint64_t)&v188, 0, 0, 0, 0, 0, (uint64_t)&v196, 0, 0, 0, 0, 0, *(_DWORD *)a1);
    if (v196 != (void **)&v198)
      free(v196);
    if (v188 != (void (**)(llvm::raw_ostream *__hidden))&v190)
      free(v188);
    v133 = a1;
    if (v182 != &v184)
      free(v182);
    if (v185 != &v187)
      free(v185);
    sub_1C549A738((uint64_t)v179, (uint64_t *)&v178)[1] = v132;
    v135 = *(uint64_t **)(a1 + 24);
    v134 = *(_QWORD *)(a1 + 32);
    if ((unint64_t)v135 >= v134)
    {
      v137 = *(_QWORD **)(a1 + 16);
      v138 = v135 - v137;
      v139 = v138 + 1;
      if ((unint64_t)(v138 + 1) >> 61)
        goto LABEL_243;
      v140 = v134 - (_QWORD)v137;
      if (v140 >> 2 > v139)
        v139 = v140 >> 2;
      if ((unint64_t)v140 >= 0x7FFFFFFFFFFFFFF8)
        v141 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v141 = v139;
      if (v141)
      {
        if (v141 >> 61)
          goto LABEL_244;
        v142 = (char *)operator new(8 * v141);
      }
      else
      {
        v142 = 0;
      }
      v143 = (uint64_t *)&v142[8 * v138];
      v144 = &v142[8 * v141];
      *v143 = v132;
      v136 = v143 + 1;
      if (v135 == v137)
      {
        v133 = a1;
        *(_QWORD *)(a1 + 16) = v143;
        *(_QWORD *)(a1 + 24) = v136;
        *(_QWORD *)(a1 + 32) = v144;
      }
      else
      {
        v133 = a1;
        do
        {
          v145 = *--v135;
          *v135 = 0;
          *--v143 = v145;
        }
        while (v135 != v137);
        v135 = *(uint64_t **)(a1 + 16);
        v146 = *(uint64_t **)(a1 + 24);
        *(_QWORD *)(a1 + 16) = v143;
        *(_QWORD *)(a1 + 24) = v136;
        *(_QWORD *)(a1 + 32) = v144;
        while (v146 != v135)
        {
          v148 = *--v146;
          v147 = v148;
          *v146 = 0;
          if (v148)
            (*(void (**)(uint64_t))(*(_QWORD *)v147 + 8))(v147);
        }
      }
      if (v135)
        operator delete(v135);
    }
    else
    {
      *v135 = v132;
      v136 = v135 + 1;
    }
    *(_QWORD *)(v133 + 24) = v136;
LABEL_240:
    *a3 = 0;
    return MEMORY[0x1CAA32FB4](v179[0], 8);
  }
  v12 = InitialLength;
  v13 = v181;
  v182 = 0;
  if (v9 == 1)
  {
    if (*(_BYTE *)(v4 + 4))
      v14 = 4;
    else
      v14 = 8;
  }
  else
  {
    v14 = 4;
  }
  RelocatedValue = llvm::DWARFDataExtractor::getRelocatedValue(a2, v14, &v181, 0, (uint64_t *)&v182);
  if (v182)
  {
    *a3 = (uint64_t)v182;
    return MEMORY[0x1CAA32FB4](v179[0], 8);
  }
  v16 = RelocatedValue;
  v17 = *(unsigned __int8 *)(v4 + 4);
  v18 = 0xFFFFFFFFLL;
  if (v10 == 1)
    v18 = -1;
  if (*(_BYTE *)(v4 + 4))
    v18 = 0;
  v174 = v6;
  v171 = v13;
  if (RelocatedValue != v18)
  {
    if (*(_BYTE *)(v4 + 4))
      v24 = (void (**)(llvm::raw_ostream *__hidden))(v13 - RelocatedValue);
    else
      v24 = (void (**)(llvm::raw_ostream *__hidden))RelocatedValue;
    v188 = v24;
    if (v180)
    {
      v25 = (v180 - 1) & (37 * (_DWORD)v24);
      v26 = (void (***)(llvm::raw_ostream *__hidden))(v179[0] + 16 * v25);
      v27 = *v26;
      if (v24 == *v26)
        goto LABEL_75;
      v28 = 0;
      v29 = 1;
      while (v27 != (void (**)(llvm::raw_ostream *__hidden))-1)
      {
        if (v28)
          v30 = 0;
        else
          v30 = v27 == (void (**)(llvm::raw_ostream *__hidden))-2;
        if (v30)
          v28 = v26;
        v31 = v25 + v29++;
        v25 = v31 & (v180 - 1);
        v26 = (void (***)(llvm::raw_ostream *__hidden))(v179[0] + 16 * v25);
        v27 = *v26;
        if (v24 == *v26)
        {
          v4 = a1;
          goto LABEL_75;
        }
      }
      if (v28)
        v53 = v28;
      else
        v53 = v26;
      v4 = a1;
    }
    else
    {
      v53 = 0;
    }
    v26 = (void (***)(llvm::raw_ostream *__hidden))sub_1C548D6F8((uint64_t)v179, (uint64_t *)&v188, v53);
    *v26 = v24;
    v26[1] = 0;
    v17 = *(unsigned __int8 *)(v4 + 4);
LABEL_75:
    v54 = v26[1];
    v168 &= 0xFFFFFFFFFFFFFF00;
    v169 &= 0xFFFFFFFFFFFFFF00;
    if (v17)
    {
      if (!v54)
      {
        v76 = std::generic_category();
        v185 = 0;
        v186 = 0uLL;
        LODWORD(v189) = 0;
        v192 = 0;
        v193 = 0;
        v188 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
        v195 = (void **)&v185;
        v194 = 0;
        v190 = 0;
        v191 = 0;
        *((_QWORD *)&v189 + 1) = 0;
        v196 = (void **)&unk_1E8133270;
        v77 = "parsing FDE data at 0x%llx failed due to missing CIE";
LABEL_170:
        *(_QWORD *)&v197 = v77;
        *((_QWORD *)&v197 + 1) = v7;
        llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v188, (uint64_t)&v196);
        v127 = v195;
        v128 = operator new();
        v199 = 260;
        v196 = v127;
        *(_QWORD *)v128 = off_1E81A0C88;
        llvm::Twine::str((llvm::Twine *)&v196, (_QWORD *)(v128 + 8));
        *(_QWORD *)(v128 + 32) = 22;
        *(_QWORD *)(v128 + 40) = v76;
        *(_BYTE *)(v128 + 48) = 1;
        *a3 = v128;
        v188 = off_1E81A6E70;
        if (v194 == 1 && *((_QWORD *)&v189 + 1))
          MEMORY[0x1CAA32F9C](*((_QWORD *)&v189 + 1), 0x1000C8077774924);
        v114 = SHIBYTE(v186);
LABEL_172:
        v6 = v174;
        if (v114 < 0)
          operator delete(v185);
        v126 = 0;
        goto LABEL_175;
      }
      EncodedPointer = llvm::DWARFDataExtractor::getEncodedPointer((llvm::DWARFDataExtractor *)a2, &v181, *((unsigned __int8 *)v54 + 184), v181 + *(_QWORD *)(v4 + 8));
      if (v56)
        v57 = EncodedPointer;
      else
        v57 = 0;
      v58 = llvm::DWARFDataExtractor::getEncodedPointer((llvm::DWARFDataExtractor *)a2, &v181, *((unsigned __int8 *)v54 + 184), 0);
      if (v59)
        v60 = v58;
      else
        v60 = 0;
      __na = v60;
      if (v54[12])
      {
        v61 = a3;
        ULEB128 = llvm::DataExtractor::getULEB128((uint64_t *)a2, (uint64_t *)&v181, 0);
        v63 = v181;
        v64 = v181;
        if (*((_DWORD *)v54 + 47) != 255)
        {
          v65 = *(_QWORD *)(a1 + 8);
          if (v65)
            v66 = v65 + v181;
          else
            v66 = 0;
          v67 = llvm::DWARFDataExtractor::getEncodedPointer((llvm::DWARFDataExtractor *)a2, &v181, *((_DWORD *)v54 + 47), v66);
          v168 = v68;
          v169 = v67;
          v64 = v181;
        }
        if (v64 != v63 + ULEB128)
        {
          v98 = std::generic_category();
          v185 = 0;
          v186 = 0uLL;
          LODWORD(v189) = 0;
          v192 = 0;
          v193 = 0;
          v188 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
          v195 = (void **)&v185;
          v194 = 0;
          v190 = 0;
          v191 = 0;
          *((_QWORD *)&v189 + 1) = 0;
          v196 = (void **)&unk_1E8133270;
          *(_QWORD *)&v197 = "parsing augmentation data at 0x%llx failed";
          *((_QWORD *)&v197 + 1) = v7;
          llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v188, (uint64_t)&v196);
          v99 = v195;
          v100 = operator new();
          v199 = 260;
          v196 = v99;
          *(_QWORD *)v100 = off_1E81A0C88;
          llvm::Twine::str((llvm::Twine *)&v196, (_QWORD *)(v100 + 8));
          *(_QWORD *)(v100 + 32) = 22;
          *(_QWORD *)(v100 + 40) = v98;
          *(_BYTE *)(v100 + 48) = 1;
          a3 = v61;
          *v61 = v100;
          goto LABEL_142;
        }
        a3 = v61;
        v4 = a1;
      }
      v69 = operator new();
      v70 = *(_DWORD *)v4;
    }
    else
    {
      v165 = llvm::DWARFDataExtractor::getRelocatedValue(a2, *(unsigned __int8 *)(a2 + 17), &v181, 0, 0);
      __na = llvm::DWARFDataExtractor::getRelocatedValue(a2, *(unsigned __int8 *)(a2 + 17), &v181, 0, 0);
      v69 = operator new();
      v70 = *(_DWORD *)v4;
      if (!v54)
      {
        v72 = 0uLL;
        v57 = v165;
        v71 = __na;
LABEL_93:
        *(_DWORD *)(v69 + 8) = 1;
        *(_BYTE *)(v69 + 12) = v11;
        *(_QWORD *)(v69 + 16) = v7;
        *(_QWORD *)(v69 + 24) = v12;
        *(_QWORD *)(v69 + 40) = 0;
        *(_QWORD *)(v69 + 48) = 0;
        *(_QWORD *)(v69 + 32) = 0;
        *(_OWORD *)(v69 + 56) = v72;
        *(_DWORD *)(v69 + 72) = v70;
        *(_QWORD *)v69 = &off_1E8169C50;
        *(_QWORD *)(v69 + 80) = v16;
        *(_QWORD *)(v69 + 88) = v57;
        *(_QWORD *)(v69 + 96) = v71;
        *(_QWORD *)(v69 + 104) = v54;
        *(_QWORD *)(v69 + 112) = v169;
        *(_QWORD *)(v69 + 120) = v168;
        v74 = *(uint64_t **)(v4 + 24);
        v73 = *(_QWORD *)(v4 + 32);
        if ((unint64_t)v74 < v73)
        {
          *v74 = v69;
          v75 = v74 + 1;
          goto LABEL_164;
        }
        v92 = *(_QWORD **)(v4 + 16);
        v93 = v74 - v92;
        v94 = v93 + 1;
        if (!((unint64_t)(v93 + 1) >> 61))
        {
          v95 = v73 - (_QWORD)v92;
          if (v95 >> 2 > v94)
            v94 = v95 >> 2;
          if ((unint64_t)v95 >= 0x7FFFFFFFFFFFFFF8)
            v96 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v96 = v94;
          if (!v96)
          {
            v97 = 0;
LABEL_154:
            v118 = (uint64_t *)&v97[8 * v93];
            v119 = &v97[8 * v96];
            *v118 = v69;
            v75 = v118 + 1;
            if (v74 == v92)
            {
              v4 = a1;
              *(_QWORD *)(a1 + 16) = v118;
              *(_QWORD *)(a1 + 24) = v75;
              *(_QWORD *)(a1 + 32) = v119;
            }
            else
            {
              v4 = a1;
              do
              {
                v120 = *--v74;
                *v74 = 0;
                *--v118 = v120;
              }
              while (v74 != v92);
              v74 = *(uint64_t **)(a1 + 16);
              v121 = *(uint64_t **)(a1 + 24);
              *(_QWORD *)(a1 + 16) = v118;
              *(_QWORD *)(a1 + 24) = v75;
              *(_QWORD *)(a1 + 32) = v119;
              while (v121 != v74)
              {
                v123 = *--v121;
                v122 = v123;
                *v121 = 0;
                if (v123)
                  (*(void (**)(uint64_t))(*(_QWORD *)v122 + 8))(v122);
              }
            }
            goto LABEL_162;
          }
          if (!(v96 >> 61))
          {
            v97 = (char *)operator new(8 * v96);
            goto LABEL_154;
          }
LABEL_244:
          sub_1C4764EE4();
        }
LABEL_243:
        abort();
      }
      v57 = v165;
    }
    v71 = __na;
    v72 = *((_OWORD *)v54 + 8);
    goto LABEL_93;
  }
  v19 = v181;
  if (llvm::DataExtractor::prepareRead(a2, v181, 1, 0))
  {
    v20 = *(unsigned __int8 *)(*(_QWORD *)a2 + v19);
    ++v181;
  }
  else
  {
    v20 = 0;
  }
  CStrRef = (const char *)llvm::DataExtractor::getCStrRef((uint64_t *)a2, &v181, 0);
  if (CStrRef)
    v22 = CStrRef;
  else
    v22 = "";
  __n = strlen(v22);
  if (v20 > 3)
  {
    v32 = v181;
    v33 = llvm::DataExtractor::prepareRead(a2, v181, 1, 0);
    v34 = v181;
    if (v33)
    {
      v23 = *(_BYTE *)(*(_QWORD *)a2 + v32);
      v34 = ++v181;
    }
    else
    {
      v23 = 0;
    }
    *(_BYTE *)(a2 + 17) = v23;
    if (llvm::DataExtractor::prepareRead(a2, v34, 1, 0))
    {
      v154 = *(_BYTE *)(*(_QWORD *)a2 + v34);
      ++v181;
    }
    else
    {
      v154 = 0;
    }
  }
  else
  {
    v154 = 0;
    v23 = *(_BYTE *)(a2 + 17);
  }
  v35 = v172;
  v153 = llvm::DataExtractor::getULEB128((uint64_t *)a2, (uint64_t *)&v181, 0);
  SLEB128 = llvm::DataExtractor::getSLEB128((_QWORD *)a2, (uint64_t *)&v181, 0);
  if (v20 == 1)
  {
    v36 = v181;
    if (llvm::DataExtractor::prepareRead(a2, v181, 1, 0))
    {
      v151 = *(unsigned __int8 *)(*(_QWORD *)a2 + v36);
      ++v181;
    }
    else
    {
      v151 = 0;
    }
    v35 = v172;
  }
  else
  {
    v151 = llvm::DataExtractor::getULEB128((uint64_t *)a2, (uint64_t *)&v181, 0);
  }
  v170 &= 0xFFFFFFFFFFFFFF00;
  v161 = a3;
  v172 = v35 & 0xFFFFFFFFFFFFFF00;
  v155 = v23;
  if (!*(_BYTE *)(a1 + 4) || !(_DWORD)__n)
  {
    v78 = 0;
    v159 = 0;
    v164 = 0;
    v156 = 0;
    v157 = 255;
    __src = "";
    goto LABEL_98;
  }
  v159 = 0;
  v37 = 0;
  v156 = 0;
  v38 = 0;
  v39 = 0;
  v40 = 0;
  v41 = 0;
  v157 = 255;
  while (2)
  {
    while (1)
    {
      v42 = v22[v38];
      if (v42 != 122)
        break;
      if (v38)
      {
        v101 = std::generic_category();
        v185 = 0;
        v186 = 0uLL;
        LODWORD(v189) = 0;
        v192 = 0;
        v193 = 0;
        v188 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
        v195 = (void **)&v185;
        v194 = 0;
        v190 = 0;
        v191 = 0;
        *((_QWORD *)&v189 + 1) = 0;
        v196 = (void **)&unk_1E8133270;
        *(_QWORD *)&v197 = "'z' must be the first character at 0x%llx";
        *((_QWORD *)&v197 + 1) = v7;
        llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v188, (uint64_t)&v196);
        v102 = v195;
        v103 = operator new();
        v199 = 260;
        v196 = v102;
        *(_QWORD *)v103 = off_1E81A0C88;
        llvm::Twine::str((llvm::Twine *)&v196, (_QWORD *)(v103 + 8));
        *(_QWORD *)(v103 + 32) = 22;
        *(_QWORD *)(v103 + 40) = v101;
        *(_BYTE *)(v103 + 48) = 1;
        a3 = v161;
        *v161 = v103;
LABEL_142:
        v188 = off_1E81A6E70;
        if (v194 == 1 && *((_QWORD *)&v189 + 1))
          MEMORY[0x1CAA32F9C](*((_QWORD *)&v189 + 1), 0x1000C8077774924);
        v114 = SHIBYTE(v186);
        v4 = a1;
        goto LABEL_172;
      }
      v43 = v37;
      v44 = llvm::DataExtractor::getULEB128((uint64_t *)a2, (uint64_t *)&v181, 0);
      v37 = v43;
      v39 = v181;
      v40 = v181 + v44;
      v38 = 1;
      v41 = 1;
      if (__n == 1)
      {
        v115 = v181;
        goto LABEL_144;
      }
    }
    switch(v22[v38])
    {
      case 'L':
        *(_QWORD *)v162 = v37;
        v158 = v181;
        if (llvm::DataExtractor::prepareRead(a2, v181, 1, 0))
        {
          v157 = *(unsigned __int8 *)(*(_QWORD *)a2 + v158);
          goto LABEL_59;
        }
        v157 = 0;
        goto LABEL_60;
      case 'M':
      case 'N':
      case 'O':
      case 'Q':
        goto LABEL_140;
      case 'P':
        if ((_BYTE)v172)
        {
          v110 = std::generic_category();
          v185 = 0;
          v186 = 0uLL;
          LODWORD(v189) = 0;
          v192 = 0;
          v193 = 0;
          v188 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
          v195 = (void **)&v185;
          v194 = 0;
          v190 = 0;
          v191 = 0;
          *((_QWORD *)&v189 + 1) = 0;
          v196 = (void **)&unk_1E8133270;
          v111 = "duplicate personality in entry at 0x%llx";
LABEL_141:
          *(_QWORD *)&v197 = v111;
          *((_QWORD *)&v197 + 1) = v7;
          llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v188, (uint64_t)&v196);
          v112 = v195;
          v113 = operator new();
          v199 = 260;
          v196 = v112;
          *(_QWORD *)v113 = off_1E81A0C88;
          llvm::Twine::str((llvm::Twine *)&v196, (_QWORD *)(v113 + 8));
          *(_QWORD *)(v113 + 32) = 22;
          *(_QWORD *)(v113 + 40) = v110;
          *(_BYTE *)(v113 + 48) = 1;
          a3 = v161;
          *v161 = v113;
          goto LABEL_142;
        }
        v173 = v181;
        v45 = llvm::DataExtractor::prepareRead(a2, v181, 1, 0);
        v46 = v181;
        if (v45)
        {
          v47 = *(unsigned __int8 *)(*(_QWORD *)a2 + v173);
          v46 = ++v181;
        }
        else
        {
          v47 = 0;
        }
        *(_QWORD *)v163 = v47;
        v48 = *(_QWORD *)(a1 + 8);
        v49 = v46 + v48;
        if (v48)
          v50 = v49;
        else
          v50 = 0;
        v51 = llvm::DWARFDataExtractor::getEncodedPointer((llvm::DWARFDataExtractor *)a2, &v181, *(unsigned int *)v163, v50);
        v37 = *(_QWORD *)v163;
        v170 = v51;
        v172 = v52;
        v156 = 1;
LABEL_68:
        if (++v38 != __n)
          continue;
        if (!v41)
        {
          v164 = v37;
          v78 = 0;
          __src = "";
          v6 = v174;
          goto LABEL_98;
        }
        v115 = v181;
LABEL_144:
        if (v115 != v40)
        {
          v129 = std::generic_category();
          v185 = 0;
          v186 = 0uLL;
          LODWORD(v189) = 0;
          v192 = 0;
          v193 = 0;
          v188 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
          v195 = (void **)&v185;
          v194 = 0;
          v190 = 0;
          v191 = 0;
          *((_QWORD *)&v189 + 1) = 0;
          v196 = (void **)&unk_1E8133270;
          *(_QWORD *)&v197 = "parsing augmentation data at 0x%llx failed";
          *((_QWORD *)&v197 + 1) = v7;
          llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v188, (uint64_t)&v196);
          v130 = v195;
          v131 = operator new();
          v199 = 260;
          v196 = v130;
          *(_QWORD *)v131 = off_1E81A0C88;
          llvm::Twine::str((llvm::Twine *)&v196, (_QWORD *)(v131 + 8));
          *(_QWORD *)(v131 + 32) = 22;
          *(_QWORD *)(v131 + 40) = v129;
          *(_BYTE *)(v131 + 48) = 1;
          a3 = v161;
          *v161 = v131;
          v188 = off_1E81A6E70;
          if (v194 == 1 && *((_QWORD *)&v189 + 1))
            MEMORY[0x1CAA32F9C](*((_QWORD *)&v189 + 1), 0x1000C8077774924);
          v4 = a1;
          if (SHIBYTE(v186) < 0)
            operator delete(v185);
          goto LABEL_165;
        }
        v164 = v37;
        v116 = *(_QWORD *)(a2 + 8);
        if (v116 >= v39)
          v117 = v39;
        else
          v117 = *(_QWORD *)(a2 + 8);
        if (v117 > v115)
          v115 = v117;
        if (v116 < v115)
          v115 = *(_QWORD *)(a2 + 8);
        __src = (const char *)(*(_QWORD *)a2 + v117);
        v78 = v115 - v117;
        v6 = v174;
LABEL_98:
        v79 = operator new();
        v188 = v6;
        v189 = xmmword_1C6464ED0;
        if (__n >= 9)
        {
          llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v188, v6, __n, 1);
          v80 = v189;
LABEL_100:
          memcpy((char *)v188 + v80, v22, __n);
          v81 = v189;
        }
        else
        {
          v80 = 0;
          v81 = 0;
          if (__n)
            goto LABEL_100;
        }
        *(_QWORD *)&v189 = v81 + __n;
        v196 = (void **)&v198;
        v197 = xmmword_1C6464ED0;
        if (v78 >= 9)
        {
          llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v196, &v198, v78, 1);
          v82 = v197;
          v4 = a1;
          v84 = v153;
LABEL_103:
          memcpy((char *)v196 + v82, __src, v78);
          v83 = v197;
        }
        else
        {
          v82 = 0;
          v83 = 0;
          v4 = a1;
          v84 = v153;
          if (v78)
            goto LABEL_103;
        }
        *(_QWORD *)&v197 = v83 + v78;
        sub_1C549A634(v79, v10 == 1, v7, v12, v20, (uint64_t)&v188, v155, v154, v84, SLEB128, v151, (uint64_t)&v196, v159, v157, v170, v172, v164 | (unint64_t)(v156 << 32), *(_DWORD *)v4);
        if (v196 != (void **)&v198)
          free(v196);
        if (v188 != v6)
          free(v188);
        sub_1C549A738((uint64_t)v179, (uint64_t *)&v178)[1] = v79;
        v74 = *(uint64_t **)(v4 + 24);
        v85 = *(_QWORD *)(v4 + 32);
        if ((unint64_t)v74 < v85)
        {
          *v74 = v79;
          v75 = v74 + 1;
          a3 = v161;
          goto LABEL_164;
        }
        v86 = *(_QWORD **)(v4 + 16);
        v87 = v74 - v86;
        v88 = v87 + 1;
        if ((unint64_t)(v87 + 1) >> 61)
          goto LABEL_243;
        v89 = v85 - (_QWORD)v86;
        if (v89 >> 2 > v88)
          v88 = v89 >> 2;
        if ((unint64_t)v89 >= 0x7FFFFFFFFFFFFFF8)
          v90 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v90 = v88;
        if (!v90)
        {
          v91 = 0;
          goto LABEL_131;
        }
        if (v90 >> 61)
          goto LABEL_244;
        v91 = (char *)operator new(8 * v90);
LABEL_131:
        v104 = (uint64_t *)&v91[8 * v87];
        v105 = &v91[8 * v90];
        *v104 = v79;
        v75 = v104 + 1;
        if (v74 == v86)
        {
          v4 = a1;
          *(_QWORD *)(a1 + 16) = v104;
          *(_QWORD *)(a1 + 24) = v75;
          *(_QWORD *)(a1 + 32) = v105;
          a3 = v161;
        }
        else
        {
          v4 = a1;
          do
          {
            v106 = *--v74;
            *v74 = 0;
            *--v104 = v106;
          }
          while (v74 != v86);
          v74 = *(uint64_t **)(a1 + 16);
          v107 = *(uint64_t **)(a1 + 24);
          *(_QWORD *)(a1 + 16) = v104;
          *(_QWORD *)(a1 + 24) = v75;
          *(_QWORD *)(a1 + 32) = v105;
          a3 = v161;
          while (v107 != v74)
          {
            v109 = *--v107;
            v108 = v109;
            *v107 = 0;
            if (v109)
              (*(void (**)(uint64_t))(*(_QWORD *)v108 + 8))(v108);
          }
        }
LABEL_162:
        if (v74)
          operator delete(v74);
LABEL_164:
        *(_QWORD *)(v4 + 24) = v75;
        v124 = *(v75 - 1) + 32;
        v125 = *(_OWORD *)(a2 + 16);
        v176[0] = *(_OWORD *)a2;
        v176[1] = v125;
        v177 = *(_QWORD *)(a2 + 32);
        llvm::dwarf::CFIProgram::parse(v124, (uint64_t)v176, &v181, v171 + v12, a3);
        if (*a3)
        {
LABEL_165:
          v126 = 0;
          goto LABEL_168;
        }
        if (v181 != v171 + v12)
        {
          v76 = std::generic_category();
          v185 = 0;
          v186 = 0uLL;
          LODWORD(v189) = 0;
          v192 = 0;
          v193 = 0;
          v188 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
          v195 = (void **)&v185;
          v194 = 0;
          v190 = 0;
          v191 = 0;
          *((_QWORD *)&v189 + 1) = 0;
          v196 = (void **)&unk_1E8133270;
          v77 = "parsing entry instructions at 0x%llx failed";
          goto LABEL_170;
        }
        v126 = 1;
LABEL_168:
        v6 = v174;
LABEL_175:
        if (v182)
          (*(void (**)(void *))(*(_QWORD *)v182 + 8))(v182);
        if ((v126 & 1) != 0)
          goto LABEL_2;
        return MEMORY[0x1CAA32FB4](v179[0], 8);
      case 'R':
        *(_QWORD *)v162 = v37;
        v160 = v181;
        if (llvm::DataExtractor::prepareRead(a2, v181, 1, 0))
        {
          v159 = *(unsigned __int8 *)(*(_QWORD *)a2 + v160);
LABEL_59:
          ++v181;
        }
        else
        {
          v159 = 0;
        }
LABEL_60:
        v37 = *(_QWORD *)v162;
        goto LABEL_68;
      case 'S':
        goto LABEL_68;
      default:
        if (v42 == 66)
          goto LABEL_68;
LABEL_140:
        v110 = std::generic_category();
        v185 = 0;
        v186 = 0uLL;
        LODWORD(v189) = 0;
        v192 = 0;
        v193 = 0;
        v188 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
        v195 = (void **)&v185;
        v194 = 0;
        v190 = 0;
        v191 = 0;
        *((_QWORD *)&v189 + 1) = 0;
        v196 = (void **)&unk_1E8133270;
        v111 = "unknown augmentation character in entry at 0x%llx";
        goto LABEL_141;
    }
  }
}

uint64_t llvm::DWARFDebugFrame::getEntryAtOffset(llvm::DWARFDebugFrame *this, unint64_t a2)
{
  uint64_t *v2;
  uint64_t *v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;

  v2 = (uint64_t *)*((_QWORD *)this + 2);
  v3 = (uint64_t *)*((_QWORD *)this + 3);
  if (v3 != v2)
  {
    v4 = v3 - v2;
    do
    {
      v5 = v4 >> 1;
      v6 = &v2[v4 >> 1];
      v8 = *v6;
      v7 = v6 + 1;
      v4 += ~(v4 >> 1);
      if (*(_QWORD *)(v8 + 16) < a2)
        v2 = v7;
      else
        v4 = v5;
    }
    while (v4);
  }
  if (v2 == v3)
    return 0;
  v9 = *v2;
  if (*(_QWORD *)(v9 + 16) == a2)
    return v9;
  else
    return 0;
}

_QWORD *llvm::DWARFDebugFrame::dump(_QWORD *result, llvm::raw_ostream *this, __int128 *a3, uint64_t a4, unint64_t a5, char a6)
{
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t *v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  _BYTE *v18;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t v21;
  _QWORD v22[11];
  _QWORD v23[12];

  v9 = (uint64_t)result;
  v23[11] = *MEMORY[0x1E0C80C00];
  if (a6)
  {
    v10 = (_QWORD *)result[2];
    v11 = (_QWORD *)result[3];
    if (v11 != v10)
    {
      v12 = v11 - v10;
      do
      {
        v13 = v12 >> 1;
        v14 = &v10[v12 >> 1];
        v16 = *v14;
        v15 = v14 + 1;
        v12 += ~(v12 >> 1);
        if (*(_QWORD *)(v16 + 16) < a5)
          v10 = v15;
        else
          v12 = v13;
      }
      while (v12);
    }
    if (v10 != v11)
    {
      v17 = *v10;
      if (*(_QWORD *)(*v10 + 16) == a5)
      {
        sub_1C624C4A4((uint64_t)v23, a3);
        (*(void (**)(uint64_t, llvm::raw_ostream *, _QWORD *, uint64_t, _QWORD))(*(_QWORD *)v17 + 16))(v17, this, v23, a4, *(unsigned __int8 *)(v9 + 4));
        return sub_1C624C568(v23);
      }
    }
  }
  else
  {
    v18 = (_BYTE *)*((_QWORD *)this + 4);
    if (*((_BYTE **)this + 3) == v18)
    {
      result = llvm::raw_ostream::write(this, "\n", 1uLL);
    }
    else
    {
      *v18 = 10;
      ++*((_QWORD *)this + 4);
    }
    v19 = *(uint64_t **)(v9 + 16);
    v20 = *(uint64_t **)(v9 + 24);
    while (v19 != v20)
    {
      v21 = *v19++;
      sub_1C624C4A4((uint64_t)v22, a3);
      (*(void (**)(uint64_t, llvm::raw_ostream *, _QWORD *, uint64_t, _QWORD))(*(_QWORD *)v21 + 16))(v21, this, v22, a4, *(unsigned __int8 *)(v9 + 4));
      result = sub_1C624C568(v22);
    }
  }
  return result;
}

uint64_t sub_1C5499C24(uint64_t a1)
{
  void *v2;
  void *v3;
  void **v5;

  *(_QWORD *)a1 = &off_1E8169C28;
  v2 = *(void **)(a1 + 152);
  if (v2 != (void *)(a1 + 176))
    free(v2);
  v3 = *(void **)(a1 + 88);
  if (v3 != (void *)(a1 + 112))
    free(v3);
  *(_QWORD *)a1 = off_1E8169C78;
  v5 = (void **)(a1 + 32);
  sub_1C549A370(&v5);
  return a1;
}

void sub_1C5499C9C(uint64_t a1)
{
  void *v2;
  void *v3;
  void **v4;

  *(_QWORD *)a1 = &off_1E8169C28;
  v2 = *(void **)(a1 + 152);
  if (v2 != (void *)(a1 + 176))
    free(v2);
  v3 = *(void **)(a1 + 88);
  if (v3 != (void *)(a1 + 112))
    free(v3);
  *(_QWORD *)a1 = off_1E8169C78;
  v4 = (void **)(a1 + 32);
  sub_1C549A370(&v4);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C5499D24(uint64_t a1)
{
  void **v3;

  *(_QWORD *)a1 = off_1E8169C78;
  v3 = (void **)(a1 + 32);
  sub_1C549A370(&v3);
  return a1;
}

void sub_1C5499D68(uint64_t a1)
{
  void **v1;

  *(_QWORD *)a1 = off_1E8169C78;
  v1 = (void **)(a1 + 32);
  sub_1C549A370(&v1);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C5499DBC(void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 112;
        sub_1C49F3440(*((_QWORD **)v4 - 2));
        v4 = v6;
      }
      while (v6 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t **sub_1C5499E30(uint64_t **a1, _QWORD *a2)
{
  uint64_t *v3;
  _QWORD *v4;
  _QWORD *v5;
  unsigned int v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t *v10;
  BOOL v11;
  uint64_t **v12;
  uint64_t **v13;
  unsigned int v14;
  _OWORD *v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t *v19;
  uint64_t *v20;
  _QWORD *v21;
  _QWORD *v22;

  a1[1] = 0;
  v3 = (uint64_t *)(a1 + 1);
  a1[2] = 0;
  *a1 = (uint64_t *)(a1 + 1);
  v4 = a2 + 1;
  v5 = (_QWORD *)*a2;
  if ((_QWORD *)*a2 != a2 + 1)
  {
    do
    {
      v6 = *((_DWORD *)v5 + 8);
      v7 = a1[1];
      v8 = v3;
      if (*a1 == v3)
        goto LABEL_8;
      v9 = a1[1];
      v10 = v3;
      if (v7)
      {
        do
        {
          v8 = v9;
          v9 = (uint64_t *)v9[1];
        }
        while (v9);
      }
      else
      {
        do
        {
          v8 = (uint64_t *)v10[2];
          v11 = *v8 == (_QWORD)v10;
          v10 = v8;
        }
        while (v11);
      }
      if (*((_DWORD *)v8 + 8) < v6)
      {
LABEL_8:
        if (v7)
          v12 = (uint64_t **)v8;
        else
          v12 = (uint64_t **)v3;
        if (v7)
          v13 = (uint64_t **)(v8 + 1);
        else
          v13 = (uint64_t **)v3;
        if (*v13)
          goto LABEL_27;
      }
      else
      {
        v13 = (uint64_t **)v3;
        v12 = (uint64_t **)v3;
        if (v7)
        {
          while (1)
          {
            while (1)
            {
              v12 = (uint64_t **)v7;
              v14 = *((_DWORD *)v7 + 8);
              if (v14 <= v6)
                break;
              v7 = *v12;
              v13 = v12;
              if (!*v12)
                goto LABEL_23;
            }
            if (v14 >= v6)
              goto LABEL_27;
            v7 = v12[1];
            if (!v7)
            {
              v13 = v12 + 1;
              break;
            }
          }
        }
      }
LABEL_23:
      v15 = operator new(0x70uLL);
      v15[2] = *((_OWORD *)v5 + 2);
      v16 = *((_OWORD *)v5 + 3);
      v17 = *((_OWORD *)v5 + 4);
      v18 = *((_OWORD *)v5 + 6);
      v15[5] = *((_OWORD *)v5 + 5);
      v15[6] = v18;
      v15[3] = v16;
      v15[4] = v17;
      *(_QWORD *)v15 = 0;
      *((_QWORD *)v15 + 1) = 0;
      *((_QWORD *)v15 + 2) = v12;
      *v13 = (uint64_t *)v15;
      v19 = (uint64_t *)**a1;
      if (v19)
      {
        *a1 = v19;
        v20 = *v13;
      }
      else
      {
        v20 = (uint64_t *)v15;
      }
      sub_1C4768E74(a1[1], v20);
      a1[2] = (uint64_t *)((char *)a1[2] + 1);
LABEL_27:
      v21 = (_QWORD *)v5[1];
      if (v21)
      {
        do
        {
          v22 = v21;
          v21 = (_QWORD *)*v21;
        }
        while (v21);
      }
      else
      {
        do
        {
          v22 = (_QWORD *)v5[2];
          v11 = *v22 == (_QWORD)v5;
          v5 = v22;
        }
        while (!v11);
      }
      v5 = v22;
    }
    while (v22 != v4);
  }
  return a1;
}

char *sub_1C5499FC8(char **a1, char *a2)
{
  char *v2;
  char *v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  __int128 v13;
  char *v14;
  uint64_t v15;
  char *v16;
  char *v17;
  char v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  char *v22;
  char *v23;

  v2 = *a1;
  v3 = a1[1];
  v4 = 0x2E8BA2E8BA2E8BA3 * ((v3 - *a1) >> 3);
  v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0x2E8BA2E8BA2E8BALL)
    abort();
  if (0x5D1745D1745D1746 * ((a1[2] - v2) >> 3) > v5)
    v5 = 0x5D1745D1745D1746 * ((a1[2] - v2) >> 3);
  if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * ((a1[2] - v2) >> 3)) >= 0x1745D1745D1745DLL)
    v8 = 0x2E8BA2E8BA2E8BALL;
  else
    v8 = v5;
  if (v8)
  {
    if (v8 > 0x2E8BA2E8BA2E8BALL)
      sub_1C4764EE4();
    v9 = (char *)operator new(88 * v8);
  }
  else
  {
    v9 = 0;
  }
  v10 = &v9[88 * v4];
  *v10 = *a2;
  *((_QWORD *)v10 + 1) = v10 + 24;
  *((_QWORD *)v10 + 2) = 0x300000000;
  if (*((_DWORD *)a2 + 4))
  {
    sub_1C614D378((uint64_t)(v10 + 8), (uint64_t)(a2 + 8));
    v2 = *a1;
    v3 = a1[1];
  }
  v11 = &v9[88 * v8];
  v12 = &v9[88 * v4];
  v13 = *((_OWORD *)a2 + 4);
  *((_OWORD *)v12 + 3) = *((_OWORD *)a2 + 3);
  *((_OWORD *)v12 + 4) = v13;
  *((_QWORD *)v12 + 10) = *((_QWORD *)a2 + 10);
  v14 = v10 + 88;
  if (v3 == v2)
  {
    *a1 = v10;
    a1[1] = v14;
    a1[2] = v11;
  }
  else
  {
    v15 = 0;
    do
    {
      v16 = &v10[v15];
      v17 = &v3[v15];
      v18 = v3[v15 - 88];
      *(_QWORD *)&v10[v15 - 80] = &v10[v15 - 64];
      v19 = (uint64_t)&v10[v15 - 80];
      *(_BYTE *)(v19 - 8) = v18;
      *(_QWORD *)(v19 + 8) = 0x300000000;
      if (*(_DWORD *)&v3[v15 - 72])
        sub_1C614D378(v19, (uint64_t)(v17 - 80));
      v20 = *(_OWORD *)(v17 - 40);
      v21 = *(_OWORD *)(v17 - 24);
      *((_QWORD *)v16 - 1) = *((_QWORD *)v17 - 1);
      *(_OWORD *)(v16 - 24) = v21;
      *(_OWORD *)(v16 - 40) = v20;
      v15 -= 88;
    }
    while (&v3[v15] != v2);
    v2 = *a1;
    v22 = a1[1];
    *a1 = &v10[v15];
    a1[1] = v14;
    a1[2] = v11;
    while (v22 != v2)
    {
      v23 = (char *)*((_QWORD *)v22 - 10);
      if (v22 - 64 != v23)
        free(v23);
      v22 -= 88;
    }
  }
  if (v2)
    operator delete(v2);
  return v10 + 88;
}

void sub_1C549A1C4(uint64_t **a1, unsigned int a2)
{
  uint64_t *v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t *v6;
  unsigned int v7;
  BOOL v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t *v12;
  BOOL v13;

  v4 = (uint64_t *)(a1 + 1);
  v3 = a1[1];
  if (v3)
  {
    v5 = v3;
    v6 = v4;
    do
    {
      v7 = *((_DWORD *)v5 + 8);
      v8 = v7 >= a2;
      if (v7 >= a2)
        v9 = (uint64_t **)v5;
      else
        v9 = (uint64_t **)(v5 + 1);
      if (v8)
        v6 = v5;
      v5 = *v9;
    }
    while (*v9);
    if (v6 != v4 && *((_DWORD *)v6 + 8) <= a2)
    {
      v10 = (uint64_t *)v6[1];
      if (v10)
      {
        do
        {
          v11 = v10;
          v10 = (uint64_t *)*v10;
        }
        while (v10);
      }
      else
      {
        v12 = v6;
        do
        {
          v11 = (uint64_t *)v12[2];
          v13 = *v11 == (_QWORD)v12;
          v12 = v11;
        }
        while (!v13);
      }
      if (*a1 == v6)
        *a1 = v11;
      a1[2] = (uint64_t *)((char *)a1[2] - 1);
      sub_1C485B6E0(v3, v6);
      operator delete(v6);
    }
  }
}

uint64_t *sub_1C549A288(uint64_t *result, unsigned int a2, uint64_t a3)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t **v6;
  _QWORD *v7;
  unsigned int v8;
  char *v9;
  uint64_t v10;
  uint64_t *v11;

  v4 = result;
  v6 = (uint64_t **)(result + 1);
  v5 = result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (_QWORD *)v5;
        v8 = *(_DWORD *)(v5 + 32);
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = (uint64_t **)v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = (uint64_t **)(v7 + 1);
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = result + 1;
LABEL_9:
    v9 = (char *)operator new(0x70uLL);
    *((_DWORD *)v9 + 8) = *(_DWORD *)a3;
    *(_OWORD *)(v9 + 56) = *(_OWORD *)(a3 + 24);
    *(_OWORD *)(v9 + 72) = *(_OWORD *)(a3 + 40);
    *(_OWORD *)(v9 + 88) = *(_OWORD *)(a3 + 56);
    *((_QWORD *)v9 + 13) = *(_QWORD *)(a3 + 72);
    *(_OWORD *)(v9 + 40) = *(_OWORD *)(a3 + 8);
    *(_QWORD *)v9 = 0;
    *((_QWORD *)v9 + 1) = 0;
    *((_QWORD *)v9 + 2) = v7;
    *v6 = (uint64_t *)v9;
    v10 = *(_QWORD *)*v4;
    if (v10)
    {
      *v4 = v10;
      v11 = *v6;
    }
    else
    {
      v11 = (uint64_t *)v9;
    }
    result = sub_1C4768E74((uint64_t *)v4[1], v11);
    ++v4[2];
  }
  return result;
}

void sub_1C549A370(void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = (char *)*((_QWORD *)v4 - 10);
        if (v4 - 64 != v6)
          free(v6);
        v4 -= 88;
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

char *sub_1C549A3EC(void **a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v6;
  char *v7;
  __int128 v8;
  char *v9;
  char *v10;
  __int128 v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  char *v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  char *v26;

  v2 = 0x6DB6DB6DB6DB6DB7 * (((_BYTE *)a1[1] - (_BYTE *)*a1) >> 4);
  v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) > 0x249249249249249)
    abort();
  if (0xDB6DB6DB6DB6DB6ELL * (((_BYTE *)a1[2] - (_BYTE *)*a1) >> 4) > v3)
    v3 = 0xDB6DB6DB6DB6DB6ELL * (((_BYTE *)a1[2] - (_BYTE *)*a1) >> 4);
  if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * (((_BYTE *)a1[2] - (_BYTE *)*a1) >> 4)) >= 0x124924924924924)
    v6 = 0x249249249249249;
  else
    v6 = v3;
  if (v6)
  {
    if (v6 > 0x249249249249249)
      sub_1C4764EE4();
    v7 = (char *)operator new(112 * v6);
  }
  else
  {
    v7 = 0;
  }
  v8 = *(_OWORD *)(a2 + 48);
  v9 = &v7[112 * v2];
  v10 = &v7[112 * v6];
  *((_OWORD *)v9 + 2) = *(_OWORD *)(a2 + 32);
  *((_OWORD *)v9 + 3) = v8;
  *((_OWORD *)v9 + 4) = *(_OWORD *)(a2 + 64);
  v9[80] = *(_BYTE *)(a2 + 80);
  v11 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)v9 = *(_OWORD *)a2;
  *((_OWORD *)v9 + 1) = v11;
  sub_1C5499E30((uint64_t **)v9 + 11, (_QWORD *)(a2 + 88));
  v12 = v9 + 112;
  v13 = (char *)*a1;
  v14 = (char *)a1[1];
  if (v14 == *a1)
  {
    *a1 = v9;
    a1[1] = v12;
    a1[2] = v10;
    if (!v14)
      return v9 + 112;
    goto LABEL_20;
  }
  v15 = 0;
  do
  {
    v16 = &v9[v15];
    v17 = *(_OWORD *)&v14[v15 - 96];
    *((_OWORD *)v16 - 7) = *(_OWORD *)&v14[v15 - 112];
    *((_OWORD *)v16 - 6) = v17;
    v18 = *(_OWORD *)&v14[v15 - 80];
    v19 = *(_OWORD *)&v14[v15 - 64];
    v20 = *(_OWORD *)&v14[v15 - 48];
    *(v16 - 32) = v14[v15 - 32];
    *((_OWORD *)v16 - 4) = v19;
    *((_OWORD *)v16 - 3) = v20;
    *((_OWORD *)v16 - 5) = v18;
    *((_QWORD *)v16 - 3) = *(_QWORD *)&v14[v15 - 24];
    v21 = &v14[v15 - 16];
    v22 = *(_QWORD *)v21;
    *(_QWORD *)&v9[v15 - 16] = *(_QWORD *)v21;
    v23 = (uint64_t)&v9[v15 - 16];
    v24 = *(_QWORD *)&v14[v15 - 8];
    *((_QWORD *)v16 - 1) = v24;
    if (v24)
    {
      *(_QWORD *)(v22 + 16) = v23;
      *(_QWORD *)&v14[v15 - 24] = v21;
      *(_QWORD *)v21 = 0;
      *(_QWORD *)&v14[v15 - 8] = 0;
    }
    else
    {
      *((_QWORD *)v16 - 3) = v23;
    }
    v15 -= 112;
  }
  while (&v14[v15] != v13);
  v14 = (char *)*a1;
  v25 = (char *)a1[1];
  *a1 = &v9[v15];
  a1[1] = v12;
  a1[2] = v10;
  if (v25 != v14)
  {
    do
    {
      v26 = v25 - 112;
      sub_1C49F3440(*((_QWORD **)v25 - 2));
      v25 = v26;
    }
    while (v26 != v14);
  }
  if (v14)
LABEL_20:
    operator delete(v14);
  return v9 + 112;
}

uint64_t sub_1C549A5C0(uint64_t a1, char *__str, size_t __size)
{
  return snprintf(__str, __size, *(const char **)(a1 + 8), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32));
}

uint64_t sub_1C549A5FC(uint64_t a1, char *__str, size_t __size)
{
  return snprintf(__str, __size, *(const char **)(a1 + 8), *(unsigned __int8 *)(a1 + 16), *(_QWORD *)(a1 + 24));
}

uint64_t sub_1C549A634(uint64_t a1, char a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, char a7, char a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, int a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18)
{
  uint64_t v19;
  __int128 v20;
  char v21;
  char v22;

  *(_DWORD *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 12) = a2;
  *(_QWORD *)(a1 + 16) = a3;
  *(_QWORD *)(a1 + 24) = a4;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = a9;
  *(_QWORD *)(a1 + 64) = a10;
  *(_DWORD *)(a1 + 72) = a18;
  *(_QWORD *)a1 = &off_1E8169C28;
  *(_BYTE *)(a1 + 80) = a5;
  *(_QWORD *)(a1 + 88) = a1 + 112;
  v19 = a1 + 88;
  v20 = xmmword_1C6464ED0;
  *(_OWORD *)(a1 + 96) = xmmword_1C6464ED0;
  if (*(_QWORD *)(a6 + 8))
  {
    v21 = a8;
    v22 = a7;
    sub_1C4FE6ED8(v19, a6);
    v20 = xmmword_1C6464ED0;
    a7 = v22;
    a8 = v21;
  }
  *(_QWORD *)(a1 + 152) = a1 + 176;
  *(_BYTE *)(a1 + 120) = a7;
  *(_BYTE *)(a1 + 121) = a8;
  *(_QWORD *)(a1 + 128) = a9;
  *(_QWORD *)(a1 + 136) = a10;
  *(_QWORD *)(a1 + 144) = a11;
  *(_OWORD *)(a1 + 160) = v20;
  if (*(_QWORD *)(a12 + 8))
    sub_1C4FE6ED8(a1 + 152, a12);
  *(_DWORD *)(a1 + 184) = a13;
  *(_DWORD *)(a1 + 188) = a14;
  *(_QWORD *)(a1 + 192) = a15;
  *(_QWORD *)(a1 + 200) = a16;
  *(_QWORD *)(a1 + 208) = a17;
  return a1;
}

_QWORD *sub_1C549A738(uint64_t a1, uint64_t *a2)
{
  int v3;
  int v4;
  unsigned int v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  int v9;
  BOOL v10;
  unsigned int v11;
  _QWORD *v12;

  v3 = *(_DWORD *)(a1 + 16);
  if (!v3)
  {
    v12 = 0;
LABEL_13:
    v6 = sub_1C548D6F8(a1, a2, v12);
    *v6 = *a2;
    v6[1] = 0;
    return v6;
  }
  v4 = v3 - 1;
  v5 = (37 * *a2) & (v3 - 1);
  v6 = (_QWORD *)(*(_QWORD *)a1 + 16 * v5);
  v7 = *v6;
  if (*a2 != *v6)
  {
    v8 = 0;
    v9 = 1;
    while (v7 != -1)
    {
      if (v8)
        v10 = 0;
      else
        v10 = v7 == -2;
      if (v10)
        v8 = v6;
      v11 = v5 + v9++;
      v5 = v11 & v4;
      v6 = (_QWORD *)(*(_QWORD *)a1 + 16 * (v11 & v4));
      v7 = *v6;
      if (*a2 == *v6)
        return v6;
    }
    if (v8)
      v12 = v8;
    else
      v12 = v6;
    goto LABEL_13;
  }
  return v6;
}

uint64_t llvm::DWARFDebugInfoEntry::extractFast(llvm::DWARFDebugInfoEntry *this, const llvm::DWARFUnit *a2, unint64_t *a3, const llvm::DWARFDataExtractor *a4, unint64_t a5, int a6)
{
  unint64_t v6;
  unint64_t v9;
  uint64_t ULEB128;
  uint64_t result;
  uint64_t v14;
  const std::error_category *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  void **v20;
  uint64_t v21;
  uint64_t v22;
  llvm::DWARFAbbreviationDeclarationSet *AbbreviationDeclarationSet;
  uint64_t v24;
  const std::error_category *v25;
  uint64_t v26;
  uint64_t v27;
  void **v28;
  uint64_t v29;
  _DWORD *AbbreviationDeclaration;
  uint64_t v31;
  llvm::DWARFAbbreviationDeclaration::AttributeSpec *v32;
  uint64_t v33;
  uint64_t ByteSize;
  char v35;
  unsigned __int16 v36;
  const std::error_category *v37;
  uint64_t v38;
  __int16 v39;
  uint64_t v40;
  void **v41;
  uint64_t v42;
  const std::error_category *v43;
  uint64_t v44;
  void **v45;
  uint64_t v46;
  void **v47;
  uint64_t v48;
  __int128 v49;
  uint64_t v50;
  void *__p[2];
  char v52;
  uint64_t (**v53)(llvm::format_object_base *__hidden);
  const char *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  void **v58;
  void (**v59)(llvm::raw_ostream *__hidden);
  int v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  char v64;
  uint64_t v65;
  int v66;
  void **v67;
  void *v68;
  uint64_t v69;
  uint64_t v70;

  v9 = *a3;
  *(_QWORD *)this = *a3;
  *((_DWORD *)this + 2) = a6;
  if (v9 >= a5)
  {
    v14 = *((_QWORD *)a2 + 1) + 488;
    v15 = std::generic_category();
    v16 = *((_QWORD *)a2 + 3);
    v17 = 12;
    if (!*((_BYTE *)a2 + 35))
      v17 = 4;
    v18 = *((_QWORD *)a2 + 5) + v16 + v17;
    v68 = 0;
    v69 = 0;
    v70 = 0;
    v60 = 0;
    v64 = 0;
    v65 = 0;
    v59 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
    v67 = &v68;
    v66 = 0;
    v62 = 0;
    v63 = 0;
    v61 = 0;
    v19 = *a3;
    v53 = (uint64_t (**)(llvm::format_object_base *__hidden))&unk_1E8169E08;
    v54 = "DWARF unit from offset 0x%8.8llx incl. to offset 0x%8.8llx excl. tries to read DIEs at offset 0x%8.8llx";
    v55 = v16;
    v56 = v18;
    v57 = v19;
    llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v59, (uint64_t)&v53);
    v20 = v67;
    v21 = operator new();
    LOWORD(v57) = 260;
    v53 = (uint64_t (**)(llvm::format_object_base *__hidden))v20;
    *(_QWORD *)v21 = off_1E81A0C88;
    llvm::Twine::str((llvm::Twine *)&v53, (_QWORD *)(v21 + 8));
    *(_QWORD *)(v21 + 32) = 22;
    *(_QWORD *)(v21 + 40) = v15;
    *(_BYTE *)(v21 + 48) = 1;
    v59 = off_1E81A6E70;
    if (v66 == 1 && v61)
      MEMORY[0x1CAA32F9C](v61, 0x1000C8077774924);
    if (SHIBYTE(v70) < 0)
      operator delete(v68);
    v59 = (void (**)(llvm::raw_ostream *__hidden))v21;
    sub_1C624E09C(v14, &v59);
    if (v59)
      (*((void (**)(_QWORD))*v59 + 1))(v59);
    return 0;
  }
  else
  {
    ULEB128 = llvm::DataExtractor::getULEB128((uint64_t *)a4, (uint64_t *)a3, 0);
    if (!ULEB128)
    {
      *((_QWORD *)this + 2) = 0;
      return 1;
    }
    v22 = ULEB128;
    AbbreviationDeclarationSet = (llvm::DWARFAbbreviationDeclarationSet *)*((_QWORD *)a2 + 32);
    if (AbbreviationDeclarationSet
      || (AbbreviationDeclarationSet = (llvm::DWARFAbbreviationDeclarationSet *)llvm::DWARFDebugAbbrev::getAbbreviationDeclarationSet(*((llvm::DWARFDebugAbbrev **)a2 + 13), *((void ***)a2 + 6)), (*((_QWORD *)a2 + 32) = AbbreviationDeclarationSet) != 0))
    {
      AbbreviationDeclaration = llvm::DWARFAbbreviationDeclarationSet::getAbbreviationDeclaration(AbbreviationDeclarationSet, v22);
      *((_QWORD *)this + 2) = AbbreviationDeclaration;
      if (AbbreviationDeclaration)
      {
        if (*((_BYTE *)AbbreviationDeclaration + 158))
        {
          *a3 += llvm::DWARFAbbreviationDeclaration::FixedSizeInfo::getByteSize((llvm::DWARFAbbreviationDeclaration::FixedSizeInfo *)(AbbreviationDeclaration + 38), a2);
        }
        else
        {
          v31 = AbbreviationDeclaration[4];
          if ((_DWORD)v31)
          {
            v32 = (llvm::DWARFAbbreviationDeclaration::AttributeSpec *)*((_QWORD *)AbbreviationDeclaration + 1);
            v33 = 16 * v31;
            while (1)
            {
              ByteSize = llvm::DWARFAbbreviationDeclaration::AttributeSpec::getByteSize(v32, a2);
              if (v35)
              {
                *a3 += ByteSize;
              }
              else
              {
                v36 = *((_WORD *)v32 + 1);
                v49 = *(_OWORD *)a4;
                v50 = *((_QWORD *)a4 + 2);
                v6 = v6 & 0xFFFF000000000000 | *((unsigned int *)a2 + 8) | ((unint64_t)*((unsigned __int16 *)a2
                                                                                                + 18) << 32);
                if ((llvm::DWARFFormValue::skipValue(v36, (uint64_t *)&v49, a3, v6) & 1) == 0)
                {
                  v24 = *((_QWORD *)a2 + 1) + 488;
                  v37 = std::generic_category();
                  v38 = *((_QWORD *)a2 + 3);
                  v68 = 0;
                  v69 = 0;
                  v70 = 0;
                  v60 = 0;
                  v64 = 0;
                  v65 = 0;
                  v59 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
                  v67 = &v68;
                  v66 = 0;
                  v62 = 0;
                  v63 = 0;
                  v61 = 0;
                  v53 = &off_1E8169DE8;
                  v39 = *((_WORD *)v32 + 1);
                  v40 = *a3;
                  v54 = "DWARF unit at offset 0x%8.8llx contains invalid FORM_* 0x%hx at offset 0x%8.8llx";
                  v55 = v38;
                  LOWORD(v56) = v39;
                  v57 = v40;
                  llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v59, (uint64_t)&v53);
                  v41 = v67;
                  v29 = operator new();
                  LOWORD(v57) = 260;
                  v53 = (uint64_t (**)(llvm::format_object_base *__hidden))v41;
                  *(_QWORD *)v29 = off_1E81A0C88;
                  llvm::Twine::str((llvm::Twine *)&v53, (_QWORD *)(v29 + 8));
                  *(_QWORD *)(v29 + 32) = 22;
                  *(_QWORD *)(v29 + 40) = v37;
                  goto LABEL_16;
                }
              }
              v32 = (llvm::DWARFAbbreviationDeclaration::AttributeSpec *)((char *)v32 + 16);
              result = 1;
              v33 -= 16;
              if (!v33)
                return result;
            }
          }
        }
        return 1;
      }
      v42 = *((_QWORD *)a2 + 1) + 488;
      v43 = std::generic_category();
      v44 = *((_QWORD *)a2 + 3);
      llvm::DWARFAbbreviationDeclarationSet::getCodeRange(AbbreviationDeclarationSet, __p);
      if (v52 >= 0)
        v45 = __p;
      else
        v45 = (void **)__p[0];
      v68 = 0;
      v69 = 0;
      v70 = 0;
      v60 = 0;
      v64 = 0;
      v65 = 0;
      v58 = v45;
      v59 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
      v67 = &v68;
      v66 = 0;
      v62 = 0;
      v63 = 0;
      v61 = 0;
      v46 = *a3;
      v53 = &off_1E8169DC8;
      v54 = "DWARF unit at offset 0x%8.8llx contains invalid abbreviation %llu at offset 0x%8.8llx, valid abbreviations are %s";
      v55 = v44;
      v56 = v22;
      v57 = v46;
      llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v59, (uint64_t)&v53);
      v47 = v67;
      v48 = operator new();
      LOWORD(v57) = 260;
      v53 = (uint64_t (**)(llvm::format_object_base *__hidden))v47;
      *(_QWORD *)v48 = off_1E81A0C88;
      llvm::Twine::str((llvm::Twine *)&v53, (_QWORD *)(v48 + 8));
      *(_QWORD *)(v48 + 32) = 22;
      *(_QWORD *)(v48 + 40) = v43;
      *(_BYTE *)(v48 + 48) = 1;
      v59 = off_1E81A6E70;
      if (v66 == 1 && v61)
        MEMORY[0x1CAA32F9C](v61, 0x1000C8077774924);
      if (SHIBYTE(v70) < 0)
        operator delete(v68);
      v59 = (void (**)(llvm::raw_ostream *__hidden))v48;
      sub_1C624E09C(v42, &v59);
      if (v59)
        (*((void (**)(_QWORD))*v59 + 1))(v59);
      if (v52 < 0)
        operator delete(__p[0]);
    }
    else
    {
      v24 = *((_QWORD *)a2 + 1) + 488;
      v25 = std::generic_category();
      v26 = *((_QWORD *)a2 + 3);
      v27 = *((_QWORD *)a2 + 6);
      v68 = 0;
      v69 = 0;
      v70 = 0;
      v60 = 0;
      v64 = 0;
      v65 = 0;
      v59 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
      v67 = &v68;
      v66 = 0;
      v62 = 0;
      v63 = 0;
      v61 = 0;
      v53 = (uint64_t (**)(llvm::format_object_base *__hidden))&unk_1E8169BA8;
      v54 = "DWARF unit at offset 0x%8.8llx contains invalid abbreviation set offset 0x%llx";
      v55 = v26;
      v56 = v27;
      llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v59, (uint64_t)&v53);
      v28 = v67;
      v29 = operator new();
      LOWORD(v57) = 260;
      v53 = (uint64_t (**)(llvm::format_object_base *__hidden))v28;
      *(_QWORD *)v29 = off_1E81A0C88;
      llvm::Twine::str((llvm::Twine *)&v53, (_QWORD *)(v29 + 8));
      *(_QWORD *)(v29 + 32) = 22;
      *(_QWORD *)(v29 + 40) = v25;
LABEL_16:
      *(_BYTE *)(v29 + 48) = 1;
      v59 = off_1E81A6E70;
      if (v66 == 1 && v61)
        MEMORY[0x1CAA32F9C](v61, 0x1000C8077774924);
      if (SHIBYTE(v70) < 0)
        operator delete(v68);
      v59 = (void (**)(llvm::raw_ostream *__hidden))v29;
      sub_1C624E09C(v24, &v59);
      if (v59)
        (*((void (**)(_QWORD))*v59 + 1))(v59);
    }
    result = 0;
    *a3 = *(_QWORD *)this;
  }
  return result;
}

_BYTE *llvm::DWARFDebugLine::ContentTypeTracker::trackContentType(_BYTE *result, int a2)
{
  if (a2 > 4)
  {
    if (a2 == 5)
    {
      result += 2;
    }
    else
    {
      if (a2 != 8193)
        return result;
      result += 3;
    }
  }
  else if (a2 != 3)
  {
    if (a2 != 4)
      return result;
    ++result;
  }
  *result = 1;
  return result;
}

double llvm::DWARFDebugLine::Prologue::Prologue(llvm::DWARFDebugLine::Prologue *this)
{
  double result;

  *(_QWORD *)((char *)this + 5) = 0;
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *(_DWORD *)((char *)this + 31) = 0;
  result = 0.0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *((_QWORD *)this + 13) = 0;
  return result;
}

{
  double result;

  *(_QWORD *)((char *)this + 5) = 0;
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *(_DWORD *)((char *)this + 31) = 0;
  result = 0.0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *((_QWORD *)this + 13) = 0;
  return result;
}

BOOL llvm::DWARFDebugLine::Prologue::hasFileAtIndex(llvm::DWARFDebugLine::Prologue *this, unint64_t a2)
{
  if (*((unsigned __int16 *)this + 4) >= 5u)
    return 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*((_QWORD *)this + 12) - *((_QWORD *)this + 11)) >> 3) > a2;
  if (a2)
    return 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*((_QWORD *)this + 12) - *((_QWORD *)this + 11)) >> 3) >= a2;
  return 0;
}

unint64_t llvm::DWARFDebugLine::Prologue::getLastValidFileIndex(llvm::DWARFDebugLine::Prologue *this)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;

  v1 = *((_QWORD *)this + 11);
  v2 = *((_QWORD *)this + 12);
  if (v1 == v2)
  {
    LOBYTE(v3) = 0;
    v4 = 0;
  }
  else
  {
    v3 = 0xF0F0F0F0F0F0F0F1 * ((v2 - v1) >> 3);
    if (*((unsigned __int16 *)this + 4) >= 5u)
      --v3;
    v4 = v3 & 0xFFFFFFFFFFFFFF00;
  }
  return v4 | v3;
}

uint64_t llvm::DWARFDebugLine::Prologue::getFileNameEntry(llvm::DWARFDebugLine::Prologue *this, uint64_t a2)
{
  return *((_QWORD *)this + 11) + 136 * (a2 - (*((unsigned __int16 *)this + 4) < 5u));
}

BOOL llvm::DWARFDebugLine::Prologue::totalLengthIsValid(llvm::DWARFDebugLine::Prologue *this)
{
  return *(_QWORD *)this != 0;
}

uint64_t llvm::DWARFDebugLine::Prologue::getLength(llvm::DWARFDebugLine::Prologue *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v1 = 4;
  v2 = 12;
  if (*((_BYTE *)this + 11) == 1)
    v1 = 8;
  else
    v2 = 4;
  v3 = *((_QWORD *)this + 2) + v2 + v1;
  v4 = v3 + 2;
  v5 = v3 + 4;
  if (*((unsigned __int16 *)this + 4) <= 4u)
    return v4;
  else
    return v5;
}

char *llvm::DWARFDebugLine::Prologue::parse@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X2>, void (*a4)(uint64_t, __int128 *)@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t *a8@<X8>)
{
  unint64_t *v11;
  unint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t InitialLength;
  char v20;
  uint64_t v21;
  BOOL v22;
  unsigned int v23;
  const std::error_category *v24;
  __int16 v25;
  void **v26;
  uint64_t v27;
  char *result;
  int v29;
  unint64_t RelocatedValue;
  unint64_t v31;
  BOOL v32;
  unsigned int v33;
  const std::error_category *v34;
  void **v35;
  uint64_t v36;
  unsigned int v37;
  char v38;
  char v39;
  unint64_t v40;
  _BYTE *v41;
  _BYTE *v42;
  unint64_t v43;
  _BYTE *v44;
  unint64_t v45;
  unint64_t v46;
  size_t v47;
  char *v48;
  char *v49;
  _BYTE *v50;
  _BYTE *v51;
  char v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  int *v56;
  int v57;
  unsigned __int16 v58;
  unint64_t v59;
  _OWORD *v60;
  __int128 v61;
  __int128 v62;
  _OWORD *v63;
  _OWORD *v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  char *v68;
  char *v69;
  __int128 v70;
  char *v71;
  __int128 v72;
  __int128 v73;
  char *v74;
  uint64_t v75;
  const char *v76;
  int *v77;
  int *v78;
  int v79;
  __int128 *v80;
  unint64_t v81;
  char *v82;
  _WORD *v83;
  char *v84;
  unint64_t v85;
  unint64_t v86;
  unint64_t v87;
  char *v88;
  char *v89;
  char *v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  void *CStrRef;
  uint64_t v98;
  void *v99;
  const std::error_category *v100;
  void *v101;
  unint64_t v102;
  char *v103;
  _WORD *v104;
  char *v105;
  unint64_t v106;
  unint64_t v107;
  unint64_t v108;
  char *v109;
  char *v110;
  char *v111;
  __int128 v112;
  __int128 v113;
  const std::error_category *v114;
  void *v115;
  uint64_t v116;
  BOOL v117;
  void *v118;
  uint64_t ULEB128;
  uint64_t v120;
  uint64_t v121;
  void *v122;
  const std::error_category *v123;
  uint64_t v124;
  unint64_t v125;
  char *v126;
  _WORD *v127;
  char *v128;
  unint64_t v129;
  unint64_t v130;
  unint64_t v131;
  char *v132;
  char *v133;
  char *v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  __int128 v139;
  __int128 v140;
  const std::error_category *v141;
  std::string *v142;
  void **v143;
  uint64_t v144;
  char *v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t *v148;
  const std::error_category *v149;
  unint64_t v150;
  void **v151;
  uint64_t v152;
  char *v153;
  const std::error_category *v154;
  unint64_t *v155;
  const std::error_category *v156;
  unint64_t v157;
  void **v158;
  uint64_t v159;
  const char *v160;
  uint64_t v161;
  uint64_t v162;
  unint64_t AsUnsignedConstant;
  unint64_t v164;
  unint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  void *v169;
  _OWORD *v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  void *v174;
  uint64_t v175;
  _OWORD *v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  void (*v181)(uint64_t, __int128 *);
  uint64_t *v182;
  int *v183;
  uint64_t v184;
  uint64_t v185;
  unint64_t v186;
  uint64_t *v187;
  unint64_t v189;
  char *v190;
  char *v191;
  uint64_t v192;
  char *v193;
  char *v194;
  std::string v195;
  unint64_t v196;
  char *v197;
  void *__p[2];
  _OWORD *v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  int v203;
  char v204;
  int v205;
  char v206;
  const char *v207;
  __int128 v208;
  __int128 v209;
  __int128 v210;
  __int128 v211;
  char v212;
  __int128 v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  char v217;
  uint64_t v218;
  int v219;
  void **v220;
  uint64_t v221;

  v11 = a3;
  v221 = *MEMORY[0x1E0C80C00];
  v15 = *a3;
  v17 = (unint64_t *)(a1 + 40);
  v16 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 5) = 0;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 31) = 0;
  *(_QWORD *)(a1 + 48) = v16;
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a1 + 64);
  *(_QWORD *)(a1 + 96) = *(_QWORD *)(a1 + 88);
  v18 = (unint64_t)&v197;
  v196 = *a3;
  v197 = 0;
  InitialLength = llvm::DWARFDataExtractor::getInitialLength(a2, &v196, &v197);
  *(_QWORD *)a1 = InitialLength;
  *(_BYTE *)(a1 + 11) = v20;
  v21 = v196 + InitialLength;
  if (*(_QWORD *)(a2 + 8) < v196 + InitialLength)
    v21 = *(_QWORD *)(a2 + 8);
  v22 = *(_BYTE *)(a2 + 16) != 0;
  *(_QWORD *)(a2 + 8) = v21;
  *(_BYTE *)(a2 + 16) = v22;
  v23 = sub_1C63871E8(a2, &v196, (uint64_t *)&v197);
  *(_WORD *)(a1 + 8) = v23;
  if (!v197 && v23 - 2 >= 4)
  {
    *v11 = v196;
    v24 = std::generic_category();
    v25 = *(_WORD *)(a1 + 8);
    __p[0] = 0;
    __p[1] = 0;
    v199 = 0;
    DWORD2(v213) = 0;
    v217 = 0;
    v218 = 0;
    *(_QWORD *)&v213 = &unk_1E81A7208;
    v220 = __p;
    v219 = 0;
    v215 = 0;
    v216 = 0;
    v214 = 0;
    *(_QWORD *)&v209 = &unk_1E8169BC8;
    *((_QWORD *)&v209 + 1) = "parsing line table prologue at offset 0x%8.8llx: unsupported version %hu";
    *(_QWORD *)&v210 = v15;
    WORD4(v210) = v25;
    llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v213, (uint64_t)&v209);
    v26 = v220;
    v27 = operator new();
    LOWORD(v211) = 260;
    *(_QWORD *)&v209 = v26;
    *(_QWORD *)v27 = off_1E81A0C88;
    llvm::Twine::str((llvm::Twine *)&v209, (_QWORD *)(v27 + 8));
    *(_QWORD *)(v27 + 32) = 45;
    *(_QWORD *)(v27 + 40) = v24;
    *(_BYTE *)(v27 + 48) = 1;
    *a8 = v27;
    *(_QWORD *)&v213 = off_1E81A6E70;
    if (v219 == 1 && v214)
      MEMORY[0x1CAA32F9C](v214, 0x1000C8077774924);
    if (SHIBYTE(v199) < 0)
      operator delete(__p[0]);
    goto LABEL_8;
  }
  if (v23 >= 5)
  {
    *(_BYTE *)(a1 + 10) = sub_1C5DEAEAC((_QWORD *)a2, &v196, (uint64_t *)&v197);
    *(_BYTE *)(a1 + 24) = sub_1C5DEAEAC((_QWORD *)a2, &v196, (uint64_t *)&v197);
  }
  if (*(_BYTE *)(a1 + 11) == 1)
    v29 = 8;
  else
    v29 = 4;
  RelocatedValue = llvm::DWARFDataExtractor::getRelocatedValue(a2, v29, &v196, 0, (uint64_t *)&v197);
  *(_QWORD *)(a1 + 16) = RelocatedValue;
  v31 = *(_QWORD *)(a2 + 8);
  v179 = v196 + RelocatedValue;
  if (v31 >= v196 + RelocatedValue)
    v31 = v196 + RelocatedValue;
  v32 = *(_BYTE *)(a2 + 16) != 0;
  *(_QWORD *)(a2 + 8) = v31;
  *(_BYTE *)(a2 + 16) = v32;
  *(_BYTE *)(a1 + 25) = sub_1C5DEAEAC((_QWORD *)a2, &v196, (uint64_t *)&v197);
  if (*(unsigned __int16 *)(a1 + 8) >= 4u)
    *(_BYTE *)(a1 + 26) = sub_1C5DEAEAC((_QWORD *)a2, &v196, (uint64_t *)&v197);
  *(_BYTE *)(a1 + 27) = sub_1C5DEAEAC((_QWORD *)a2, &v196, (uint64_t *)&v197);
  *(_BYTE *)(a1 + 28) = sub_1C5DEAEAC((_QWORD *)a2, &v196, (uint64_t *)&v197);
  *(_BYTE *)(a1 + 29) = sub_1C5DEAEAC((_QWORD *)a2, &v196, (uint64_t *)&v197);
  v33 = sub_1C5DEAEAC((_QWORD *)a2, &v196, (uint64_t *)&v197);
  *(_BYTE *)(a1 + 30) = v33;
  v181 = a4;
  v182 = a8;
  v186 = v15;
  v187 = (uint64_t *)v11;
  v180 = a5;
  v185 = a7;
  if (v197 || v33)
  {
    if (v197)
    {
      *v11 = v196;
LABEL_191:
      v141 = std::generic_category();
      v194 = v197;
      v197 = 0;
      sub_1C61D2548(&v194, &v195);
      if ((v195.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v142 = &v195;
      else
        v142 = (std::string *)v195.__r_.__value_.__r.__words[0];
      __p[0] = 0;
      __p[1] = 0;
      v199 = 0;
      DWORD2(v213) = 0;
      v217 = 0;
      v218 = 0;
      *(_QWORD *)&v213 = &unk_1E81A7208;
      v220 = __p;
      v219 = 0;
      v215 = 0;
      v216 = 0;
      v214 = 0;
      *(_QWORD *)&v209 = &unk_1E8169880;
      *((_QWORD *)&v209 + 1) = "parsing line table prologue at offset 0x%8.8llx: %s";
      *(_QWORD *)&v210 = v15;
      *((_QWORD *)&v210 + 1) = v142;
      llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v213, (uint64_t)&v209);
      v143 = v220;
      v144 = operator new();
      LOWORD(v211) = 260;
      *(_QWORD *)&v209 = v143;
      *(_QWORD *)v144 = off_1E81A0C88;
      llvm::Twine::str((llvm::Twine *)&v209, (_QWORD *)(v144 + 8));
      *(_QWORD *)(v144 + 32) = 22;
      *(_QWORD *)(v144 + 40) = v141;
      *(_BYTE *)(v144 + 48) = 1;
      *a8 = v144;
      *(_QWORD *)&v213 = off_1E81A6E70;
      if (v219 == 1 && v214)
        MEMORY[0x1CAA32F9C](v214, 0x1000C8077774924);
      if (SHIBYTE(v199) < 0)
        operator delete(__p[0]);
      if (SHIBYTE(v195.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v195.__r_.__value_.__l.__data_);
      v145 = v194;
      if (v194)
        goto LABEL_221;
      goto LABEL_8;
    }
    sub_1C4D730E0(v17, v33 - 1);
    if (*(unsigned __int8 *)(a1 + 30) >= 2u)
    {
      v37 = 1;
      do
      {
        v38 = sub_1C5DEAEAC((_QWORD *)a2, &v196, (uint64_t *)&v197);
        v39 = v38;
        v41 = *(_BYTE **)(a1 + 48);
        v40 = *(_QWORD *)(a1 + 56);
        if ((unint64_t)v41 >= v40)
        {
          v43 = *v17;
          v44 = &v41[-*v17];
          v45 = (unint64_t)(v44 + 1);
          if ((uint64_t)(v44 + 1) < 0)
LABEL_233:
            abort();
          v46 = v40 - v43;
          if (2 * v46 > v45)
            v45 = 2 * v46;
          if (v46 >= 0x3FFFFFFFFFFFFFFFLL)
            v47 = 0x7FFFFFFFFFFFFFFFLL;
          else
            v47 = v45;
          if (v47)
            v48 = (char *)operator new(v47);
          else
            v48 = 0;
          v49 = &v44[(_QWORD)v48];
          v50 = &v44[(_QWORD)v48];
          *v50 = v39;
          v42 = v50 + 1;
          if (v41 == (_BYTE *)v43)
          {
            v11 = (unint64_t *)v187;
          }
          else
          {
            v51 = &v41[~v43];
            v11 = (unint64_t *)v187;
            do
            {
              v52 = *--v41;
              (v51--)[(_QWORD)v48] = v52;
            }
            while (v41 != (_BYTE *)v43);
            v41 = (_BYTE *)*v17;
            v49 = v48;
          }
          *(_QWORD *)(a1 + 40) = v49;
          *(_QWORD *)(a1 + 48) = v42;
          *(_QWORD *)(a1 + 56) = &v48[v47];
          if (v41)
            operator delete(v41);
          v15 = v186;
        }
        else
        {
          *v41 = v38;
          v42 = v41 + 1;
          v11 = (unint64_t *)v187;
        }
        *(_QWORD *)(a1 + 48) = v42;
        ++v37;
      }
      while (v37 < *(unsigned __int8 *)(a1 + 30));
    }
  }
  else
  {
    v34 = std::generic_category();
    __p[0] = 0;
    __p[1] = 0;
    v199 = 0;
    DWORD2(v213) = 0;
    v217 = 0;
    v218 = 0;
    *(_QWORD *)&v213 = &unk_1E81A7208;
    v220 = __p;
    v219 = 0;
    v215 = 0;
    v216 = 0;
    v214 = 0;
    *(_QWORD *)&v209 = &unk_1E8133270;
    *((_QWORD *)&v209 + 1) = "parsing line table prologue at offset 0x%8.8llx found opcode base of 0. Assuming no standard opcodes";
    *(_QWORD *)&v210 = v15;
    llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v213, (uint64_t)&v209);
    v35 = v220;
    v36 = operator new();
    LOWORD(v211) = 260;
    *(_QWORD *)&v209 = v35;
    *(_QWORD *)v36 = off_1E81A0C88;
    llvm::Twine::str((llvm::Twine *)&v209, (_QWORD *)(v36 + 8));
    *(_QWORD *)(v36 + 32) = 22;
    *(_QWORD *)(v36 + 40) = v34;
    *(_BYTE *)(v36 + 48) = 1;
    *(_QWORD *)&v213 = off_1E81A6E70;
    if (v219 == 1 && v214)
      MEMORY[0x1CAA32F9C](v214, 0x1000C8077774924);
    if (SHIBYTE(v199) < 0)
      operator delete(__p[0]);
    *(_QWORD *)&v213 = v36;
    a4(a5, &v213);
    v15 = v186;
    v11 = (unint64_t *)v187;
    if ((_QWORD)v213)
      (*(void (**)(_QWORD))(*(_QWORD *)v213 + 8))(v213);
  }
  v53 = v197;
  *v11 = v196;
  a8 = v182;
  if (v53)
    goto LABEL_191;
  if (*(unsigned __int16 *)(a1 + 8) < 5u)
  {
    while (1)
    {
      __p[0] = 0;
      CStrRef = llvm::DataExtractor::getCStrRef((uint64_t *)a2, v11, (uint64_t *)__p);
      v99 = __p[0];
      if (__p[0])
      {
        __p[0] = 0;
        *(_QWORD *)&v209 = v99;
        sub_1C4D62BD4((char **)&v209, (char **)&v213);
        if ((_QWORD)v209)
          (*(void (**)(_QWORD))(*(_QWORD *)v209 + 8))(v209);
        v100 = std::generic_category();
        *(_QWORD *)&v213 = 22;
        *((_QWORD *)&v213 + 1) = v100;
        *(_QWORD *)&v209 = "include directories table was not null terminated before the end of the prologue";
        sub_1C5DF1730((_BYTE **)&v209, (uint64_t *)&v213, &v193);
      }
      else
      {
        if (!v98)
        {
          *(_WORD *)(a1 + 31) = 257;
          while (1)
          {
            __p[0] = 0;
            v115 = llvm::DataExtractor::getCStrRef((uint64_t *)a2, v11, (uint64_t *)__p);
            if (__p[0])
              v117 = 0;
            else
              v117 = v116 == 0;
            if (v117)
            {
              v193 = 0;
              goto LABEL_214;
            }
            v118 = v115;
            ULEB128 = llvm::DataExtractor::getULEB128((uint64_t *)a2, (uint64_t *)v11, __p);
            v120 = llvm::DataExtractor::getULEB128((uint64_t *)a2, (uint64_t *)v11, __p);
            v121 = llvm::DataExtractor::getULEB128((uint64_t *)a2, (uint64_t *)v11, __p);
            v122 = __p[0];
            if (__p[0])
            {
              __p[0] = 0;
              *(_QWORD *)&v209 = v122;
              sub_1C4D62BD4((char **)&v209, (char **)&v213);
              if ((_QWORD)v209)
                (*(void (**)(_QWORD))(*(_QWORD *)v209 + 8))(v209);
              v123 = std::generic_category();
              *(_QWORD *)&v213 = 22;
              *((_QWORD *)&v213 + 1) = v123;
              *(_QWORD *)&v209 = "file names table was not null terminated before the end of the prologue";
              sub_1C5DF1730((_BYTE **)&v209, (uint64_t *)&v213, &v193);
            }
            else
            {
              v124 = v121;
              v126 = *(char **)(a1 + 96);
              v125 = *(_QWORD *)(a1 + 104);
              if ((unint64_t)v126 >= v125)
              {
                v128 = *(char **)(a1 + 88);
                v129 = 0xF0F0F0F0F0F0F0F1 * ((v126 - v128) >> 3) + 1;
                if (v129 > 0x1E1E1E1E1E1E1E1)
                  goto LABEL_233;
                v130 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(v125 - (_QWORD)v128) >> 3);
                if (2 * v130 > v129)
                  v129 = 2 * v130;
                if (v130 >= 0xF0F0F0F0F0F0F0)
                  v131 = 0x1E1E1E1E1E1E1E1;
                else
                  v131 = v129;
                v189 = v131;
                if (v131)
                {
                  if (v131 > 0x1E1E1E1E1E1E1E1)
                    goto LABEL_234;
                  v132 = (char *)operator new(136 * v131);
                }
                else
                {
                  v132 = 0;
                }
                v133 = &v132[8 * ((v126 - v128) >> 3)];
                *(_WORD *)v133 = 8;
                v133[2] = 0;
                *((_QWORD *)v133 + 1) = v118;
                *((_QWORD *)v133 + 2) = 0;
                *((_QWORD *)v133 + 4) = 0;
                *((_QWORD *)v133 + 5) = 0;
                *((_QWORD *)v133 + 6) = ULEB128;
                *((_QWORD *)v133 + 7) = v120;
                *((_QWORD *)v133 + 8) = v124;
                *((_WORD *)v133 + 44) = 0;
                v133[90] = 0;
                *((_QWORD *)v133 + 12) = 0;
                *((_QWORD *)v133 + 13) = 0;
                *((_QWORD *)v133 + 15) = 0;
                *((_QWORD *)v133 + 16) = 0;
                v134 = v133;
                if (v126 != v128)
                {
                  do
                  {
                    *(_OWORD *)(v134 - 136) = *(_OWORD *)(v126 - 136);
                    v135 = *(_OWORD *)(v126 - 120);
                    v136 = *(_OWORD *)(v126 - 104);
                    v137 = *(_OWORD *)(v126 - 88);
                    *(_OWORD *)(v134 - 72) = *(_OWORD *)(v126 - 72);
                    *(_OWORD *)(v134 - 88) = v137;
                    *(_OWORD *)(v134 - 104) = v136;
                    *(_OWORD *)(v134 - 120) = v135;
                    v138 = *(_OWORD *)(v126 - 56);
                    v139 = *(_OWORD *)(v126 - 40);
                    v140 = *(_OWORD *)(v126 - 24);
                    *((_QWORD *)v134 - 1) = *((_QWORD *)v126 - 1);
                    *(_OWORD *)(v134 - 24) = v140;
                    *(_OWORD *)(v134 - 40) = v139;
                    *(_OWORD *)(v134 - 56) = v138;
                    v134 -= 136;
                    v126 -= 136;
                  }
                  while (v126 != v128);
                  v126 = *(char **)(a1 + 88);
                }
                v127 = v133 + 136;
                *(_QWORD *)(a1 + 88) = v134;
                *(_QWORD *)(a1 + 96) = v133 + 136;
                *(_QWORD *)(a1 + 104) = &v132[136 * v189];
                if (v126)
                  operator delete(v126);
              }
              else
              {
                *(_WORD *)v126 = 8;
                v126[2] = 0;
                *((_QWORD *)v126 + 1) = v118;
                *((_QWORD *)v126 + 2) = 0;
                *((_QWORD *)v126 + 4) = 0;
                *((_QWORD *)v126 + 5) = 0;
                *((_QWORD *)v126 + 6) = ULEB128;
                *((_QWORD *)v126 + 7) = v120;
                *((_QWORD *)v126 + 8) = v121;
                *((_WORD *)v126 + 44) = 0;
                v126[90] = 0;
                v127 = v126 + 136;
                *((_QWORD *)v126 + 12) = 0;
                *((_QWORD *)v126 + 13) = 0;
                *((_QWORD *)v126 + 15) = 0;
                *((_QWORD *)v126 + 16) = 0;
              }
              *(_QWORD *)(a1 + 96) = v127;
              v11 = (unint64_t *)v187;
            }
            if (__p[0])
              (*(void (**)(void *))(*(_QWORD *)__p[0] + 8))(__p[0]);
            if (v122)
              goto LABEL_213;
          }
        }
        v101 = CStrRef;
        *((_QWORD *)&v213 + 1) = 0;
        v214 = 0;
        v103 = *(char **)(a1 + 72);
        v102 = *(_QWORD *)(a1 + 80);
        if ((unint64_t)v103 >= v102)
        {
          v105 = *(char **)(a1 + 64);
          v106 = 0xAAAAAAAAAAAAAAABLL * ((v103 - v105) >> 4) + 1;
          if (v106 > 0x555555555555555)
            goto LABEL_233;
          v107 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v102 - (_QWORD)v105) >> 4);
          if (2 * v107 > v106)
            v106 = 2 * v107;
          if (v107 >= 0x2AAAAAAAAAAAAAALL)
            v108 = 0x555555555555555;
          else
            v108 = v106;
          if (v108)
          {
            if (v108 > 0x555555555555555)
LABEL_234:
              sub_1C4764EE4();
            v109 = (char *)operator new(48 * v108);
          }
          else
          {
            v109 = 0;
          }
          v110 = &v109[16 * ((v103 - v105) >> 4)];
          *(_WORD *)v110 = 8;
          v110[2] = 0;
          *((_QWORD *)v110 + 1) = v101;
          *((_QWORD *)v110 + 2) = 0;
          *(_OWORD *)(v110 + 24) = v213;
          *((_QWORD *)v110 + 5) = v214;
          v111 = v110;
          if (v103 != v105)
          {
            do
            {
              v112 = *((_OWORD *)v103 - 3);
              v113 = *((_OWORD *)v103 - 1);
              *((_OWORD *)v111 - 2) = *((_OWORD *)v103 - 2);
              *((_OWORD *)v111 - 1) = v113;
              *((_OWORD *)v111 - 3) = v112;
              v111 -= 48;
              v103 -= 48;
            }
            while (v103 != v105);
            v103 = *(char **)(a1 + 64);
          }
          v104 = v110 + 48;
          *(_QWORD *)(a1 + 64) = v111;
          *(_QWORD *)(a1 + 72) = v110 + 48;
          *(_QWORD *)(a1 + 80) = &v109[48 * v108];
          if (v103)
            operator delete(v103);
        }
        else
        {
          *(_WORD *)v103 = 8;
          v103[2] = 0;
          *((_QWORD *)v103 + 1) = CStrRef;
          *((_QWORD *)v103 + 2) = 0;
          *(_OWORD *)(v103 + 24) = v213;
          *((_QWORD *)v103 + 5) = v214;
          v104 = v103 + 48;
        }
        *(_QWORD *)(a1 + 72) = v104;
        v11 = (unint64_t *)v187;
      }
      if (__p[0])
        (*(void (**)(void *))(*(_QWORD *)__p[0] + 8))(__p[0]);
      if (v99)
        goto LABEL_213;
    }
  }
  sub_1C54A0400((uint64_t)&v213, (uint64_t *)a2, v11, 0);
  if ((v218 & 1) != 0)
  {
    v193 = (char *)v213;
    goto LABEL_213;
  }
  v54 = a6;
  v175 = llvm::DataExtractor::getULEB128((uint64_t *)a2, (uint64_t *)v11, 0);
  if (v175)
  {
    v55 = 0;
    do
    {
      v177 = v55;
      if (DWORD2(v213))
      {
        v56 = (int *)v213;
        v183 = (int *)(v213 + 8 * DWORD2(v213));
        do
        {
          v57 = *v56;
          v58 = *((_WORD *)v56 + 2);
          LOWORD(v209) = v58;
          BYTE2(v209) = 0;
          *((_QWORD *)&v209 + 1) = 0;
          *(_QWORD *)&v210 = 0;
          v211 = 0uLL;
          if (v57 == 1)
          {
            v18 = v18 & 0xFFFF000000000000 | *(unsigned int *)(a1 + 8) | ((unint64_t)*(unsigned __int16 *)(a1 + 12) << 32);
            if (!llvm::DWARFFormValue::extractValue((unsigned __int16 *)&v209, (uint64_t *)a2, v187, v18, v54, v185))
            {
              v160 = "failed to parse directory entry because extracting the form value failed";
              goto LABEL_156;
            }
            v60 = *(_OWORD **)(a1 + 72);
            v59 = *(_QWORD *)(a1 + 80);
            if ((unint64_t)v60 >= v59)
            {
              v64 = *(_OWORD **)(a1 + 64);
              v65 = 0xAAAAAAAAAAAAAAABLL * (v60 - v64) + 1;
              if (v65 > 0x555555555555555)
                goto LABEL_233;
              v66 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v59 - (_QWORD)v64) >> 4);
              if (2 * v66 > v65)
                v65 = 2 * v66;
              if (v66 >= 0x2AAAAAAAAAAAAAALL)
                v67 = 0x555555555555555;
              else
                v67 = v65;
              if (v67)
              {
                if (v67 > 0x555555555555555)
                  goto LABEL_234;
                v68 = (char *)operator new(48 * v67);
              }
              else
              {
                v68 = 0;
              }
              v69 = &v68[16 * (v60 - v64)];
              v70 = v210;
              *(_OWORD *)v69 = v209;
              *((_OWORD *)v69 + 1) = v70;
              *((_OWORD *)v69 + 2) = v211;
              v71 = v69;
              if (v60 != v64)
              {
                do
                {
                  v72 = *(v60 - 3);
                  v73 = *(v60 - 1);
                  *((_OWORD *)v71 - 2) = *(v60 - 2);
                  *((_OWORD *)v71 - 1) = v73;
                  *((_OWORD *)v71 - 3) = v72;
                  v71 -= 48;
                  v60 -= 3;
                }
                while (v60 != v64);
                v60 = *(_OWORD **)(a1 + 64);
              }
              v74 = &v68[48 * v67];
              v63 = v69 + 48;
              *(_QWORD *)(a1 + 64) = v71;
              *(_QWORD *)(a1 + 72) = v69 + 48;
              *(_QWORD *)(a1 + 80) = v74;
              v54 = a6;
              if (v60)
                operator delete(v60);
            }
            else
            {
              v61 = v209;
              v62 = v211;
              v60[1] = v210;
              v60[2] = v62;
              *v60 = v61;
              v63 = v60 + 3;
            }
            *(_QWORD *)(a1 + 72) = v63;
          }
          else
          {
            *(_OWORD *)__p = *(_OWORD *)a2;
            v199 = *(_OWORD **)(a2 + 16);
            if (!llvm::DWARFFormValue::skipValue(v58, (uint64_t *)__p, (unint64_t *)v187, *(unsigned int *)(a1 + 8) | ((unint64_t)*(unsigned __int16 *)(a1 + 12) << 32)))
            {
              v160 = "failed to parse directory entry because skipping the form value failed";
LABEL_156:
              v114 = std::generic_category();
              __p[0] = (void *)22;
              __p[1] = (void *)v114;
              v195.__r_.__value_.__r.__words[0] = (std::string::size_type)v160;
              sub_1C5DF1730(&v195.__r_.__value_.__l.__data_, (uint64_t *)__p, &v193);
              v11 = (unint64_t *)v187;
              goto LABEL_208;
            }
          }
          v56 += 2;
        }
        while (v56 != v183);
      }
      v55 = v177 + 1;
    }
    while (v177 + 1 != v175);
  }
  v11 = (unint64_t *)v187;
  sub_1C54A0400((uint64_t)&v209, (uint64_t *)a2, (unint64_t *)v187, (_BYTE *)(a1 + 31));
  if ((v212 & 1) != 0)
  {
    v193 = (char *)v209;
    goto LABEL_208;
  }
  v161 = llvm::DataExtractor::getULEB128((uint64_t *)a2, v187, 0);
  if (!v161)
  {
LABEL_126:
    v193 = 0;
    goto LABEL_203;
  }
  v75 = 0;
  v76 = "failed to parse file entry because extracting the form value failed";
  while (1)
  {
    v162 = v75;
    if (DWORD2(v209))
      break;
    v184 = 0;
    v176 = 0;
    v178 = 0;
    v173 = 0;
    v174 = 0;
    v164 = 0;
    v165 = 0;
    AsUnsignedConstant = 0;
    v171 = 0;
    v172 = 0;
    v169 = 0;
    v170 = 0;
    v168 = 0;
LABEL_107:
    v82 = *(char **)(a1 + 96);
    v81 = *(_QWORD *)(a1 + 104);
    if ((unint64_t)v82 >= v81)
    {
      v84 = *(char **)(a1 + 88);
      v85 = 0xF0F0F0F0F0F0F0F1 * ((v82 - v84) >> 3) + 1;
      if (v85 > 0x1E1E1E1E1E1E1E1)
        goto LABEL_233;
      v86 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(v81 - (_QWORD)v84) >> 3);
      if (2 * v86 > v85)
        v85 = 2 * v86;
      if (v86 >= 0xF0F0F0F0F0F0F0)
        v87 = 0x1E1E1E1E1E1E1E1;
      else
        v87 = v85;
      if (v87)
      {
        if (v87 > 0x1E1E1E1E1E1E1E1)
          goto LABEL_234;
        v88 = (char *)operator new(136 * v87);
      }
      else
      {
        v88 = 0;
      }
      v89 = &v88[8 * ((v82 - v84) >> 3)];
      *(_WORD *)v89 = v168;
      v89[2] = BYTE4(v168);
      *(_DWORD *)(v89 + 3) = v205;
      v89[7] = v206;
      *((_QWORD *)v89 + 1) = v169;
      *((_QWORD *)v89 + 2) = v170;
      *((_QWORD *)v89 + 3) = v166;
      *((_QWORD *)v89 + 4) = v171;
      *((_QWORD *)v89 + 5) = v172;
      *((_QWORD *)v89 + 6) = AsUnsignedConstant;
      *((_QWORD *)v89 + 7) = v164;
      *((_QWORD *)v89 + 8) = v165;
      *(_OWORD *)(v89 + 72) = v208;
      *((_WORD *)v89 + 44) = v173;
      v89[90] = BYTE4(v173);
      v89[95] = v204;
      *(_DWORD *)(v89 + 91) = v203;
      *((_QWORD *)v89 + 12) = v174;
      *((_QWORD *)v89 + 13) = v176;
      *((_QWORD *)v89 + 14) = v167;
      *((_QWORD *)v89 + 15) = v178;
      *((_QWORD *)v89 + 16) = v184;
      v90 = v89;
      if (v82 != v84)
      {
        do
        {
          *(_OWORD *)(v90 - 136) = *(_OWORD *)(v82 - 136);
          v91 = *(_OWORD *)(v82 - 120);
          v92 = *(_OWORD *)(v82 - 104);
          v93 = *(_OWORD *)(v82 - 88);
          *(_OWORD *)(v90 - 72) = *(_OWORD *)(v82 - 72);
          *(_OWORD *)(v90 - 88) = v93;
          *(_OWORD *)(v90 - 104) = v92;
          *(_OWORD *)(v90 - 120) = v91;
          v94 = *(_OWORD *)(v82 - 56);
          v95 = *(_OWORD *)(v82 - 40);
          v96 = *(_OWORD *)(v82 - 24);
          *((_QWORD *)v90 - 1) = *((_QWORD *)v82 - 1);
          *(_OWORD *)(v90 - 24) = v96;
          *(_OWORD *)(v90 - 40) = v95;
          *(_OWORD *)(v90 - 56) = v94;
          v90 -= 136;
          v82 -= 136;
        }
        while (v82 != v84);
        v82 = *(char **)(a1 + 88);
      }
      v83 = v89 + 136;
      *(_QWORD *)(a1 + 88) = v90;
      *(_QWORD *)(a1 + 96) = v89 + 136;
      *(_QWORD *)(a1 + 104) = &v88[136 * v87];
      if (v82)
        operator delete(v82);
      v76 = "failed to parse file entry because extracting the form value failed";
    }
    else
    {
      *(_WORD *)v82 = v168;
      v82[2] = BYTE4(v168);
      *(_DWORD *)(v82 + 3) = v205;
      v82[7] = v206;
      *((_QWORD *)v82 + 1) = v169;
      *((_QWORD *)v82 + 2) = v170;
      *((_QWORD *)v82 + 3) = v166;
      *((_QWORD *)v82 + 4) = v171;
      *((_QWORD *)v82 + 5) = v172;
      *((_QWORD *)v82 + 6) = AsUnsignedConstant;
      *((_QWORD *)v82 + 7) = v164;
      *((_QWORD *)v82 + 8) = v165;
      *(_OWORD *)(v82 + 72) = v208;
      *((_WORD *)v82 + 44) = v173;
      v82[90] = BYTE4(v173);
      v82[95] = v204;
      *(_DWORD *)(v82 + 91) = v203;
      *((_QWORD *)v82 + 12) = v174;
      *((_QWORD *)v82 + 13) = v176;
      *((_QWORD *)v82 + 14) = v167;
      *((_QWORD *)v82 + 15) = v178;
      v83 = v82 + 136;
      *((_QWORD *)v82 + 16) = v184;
    }
    *(_QWORD *)(a1 + 96) = v83;
    v75 = v162 + 1;
    if (v162 + 1 == v161)
      goto LABEL_126;
  }
  v184 = 0;
  v176 = 0;
  v178 = 0;
  v173 = 0;
  v174 = 0;
  v164 = 0;
  v165 = 0;
  AsUnsignedConstant = 0;
  v171 = 0;
  v172 = 0;
  v169 = 0;
  v170 = 0;
  v168 = 0;
  v77 = (int *)v209;
  v78 = (int *)(v209 + 8 * DWORD2(v209));
  while (2)
  {
    v79 = *v77;
    LOWORD(__p[0]) = *((_WORD *)v77 + 2);
    BYTE2(__p[0]) = 0;
    __p[1] = 0;
    v199 = 0;
    v201 = 0;
    v202 = 0;
    v18 = v18 & 0xFFFF000000000000 | *(unsigned int *)(a1 + 8) | ((unint64_t)*(unsigned __int16 *)(a1 + 12) << 32);
    if (!llvm::DWARFFormValue::extractValue((unsigned __int16 *)__p, (uint64_t *)a2, v187, v18, v54, v185))
      goto LABEL_202;
    switch(v79)
    {
      case 1:
        LOWORD(v168) = __p[0];
        BYTE4(v168) = BYTE2(__p[0]);
        v205 = *(_DWORD *)((char *)__p + 3);
        v206 = HIBYTE(__p[0]);
        v169 = __p[1];
        v170 = v199;
        v166 = v200;
        v171 = v201;
        v172 = v202;
        goto LABEL_101;
      case 2:
        AsUnsignedConstant = llvm::DWARFFormValue::getAsUnsignedConstant((llvm::DWARFFormValue *)__p);
        goto LABEL_101;
      case 3:
        v164 = llvm::DWARFFormValue::getAsUnsignedConstant((llvm::DWARFFormValue *)__p);
        goto LABEL_101;
      case 4:
        v165 = llvm::DWARFFormValue::getAsUnsignedConstant((llvm::DWARFFormValue *)__p);
        goto LABEL_101;
      case 5:
        if (LOWORD(__p[0]) > 0x2Du)
          goto LABEL_201;
        if (((0x618uLL >> SLOBYTE(__p[0])) & 1) != 0)
        {
          if (__p[1] != (void *)16)
            goto LABEL_201;
          v80 = v199;
          goto LABEL_100;
        }
        if (LOWORD(__p[0]) == 30 || LOWORD(__p[0]) == 24)
        {
          v80 = v199;
          if (__p[1] == (void *)16)
          {
LABEL_100:
            v208 = *v80;
LABEL_101:
            v77 += 2;
            if (v77 == v78)
              goto LABEL_107;
            continue;
          }
        }
LABEL_201:
        v76 = "failed to parse file entry because the MD5 hash is invalid";
LABEL_202:
        v195.__r_.__value_.__r.__words[0] = 22;
        v195.__r_.__value_.__l.__size_ = (std::string::size_type)std::generic_category();
        v207 = v76;
        sub_1C5DF1730((_BYTE **)&v207, (uint64_t *)&v195, &v193);
LABEL_203:
        v146 = v209;
        if ((v212 & 1) != 0)
        {
          *(_QWORD *)&v209 = 0;
          v11 = (unint64_t *)v187;
          if (v146)
            (*(void (**)(uint64_t))(*(_QWORD *)v146 + 8))(v146);
        }
        else
        {
          v11 = (unint64_t *)v187;
          if ((__int128 *)v209 != &v210)
            free((void *)v209);
        }
LABEL_208:
        v147 = v213;
        if ((v218 & 1) != 0)
        {
          *(_QWORD *)&v213 = 0;
          if (v147)
            (*(void (**)(uint64_t))(*(_QWORD *)v147 + 8))(v147);
        }
        else if ((uint64_t *)v213 != &v214)
        {
          free((void *)v213);
        }
LABEL_213:
        if (v193)
        {
          v154 = std::generic_category();
          v155 = v11;
          v156 = v154;
          __p[0] = 0;
          __p[1] = 0;
          v199 = 0;
          DWORD2(v213) = 0;
          v217 = 0;
          v218 = 0;
          *(_QWORD *)&v213 = &unk_1E81A7208;
          v220 = __p;
          v219 = 0;
          v215 = 0;
          v216 = 0;
          v214 = 0;
          v157 = *v155;
          *(_QWORD *)&v209 = &unk_1E8169BA8;
          *((_QWORD *)&v209 + 1) = "parsing line table prologue at 0x%8.8llx found an invalid directory or file table des"
                                   "cription at 0x%8.8llx";
          *(_QWORD *)&v210 = v186;
          *((_QWORD *)&v210 + 1) = v157;
          llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v213, (uint64_t)&v209);
          v158 = v220;
          v159 = operator new();
          LOWORD(v211) = 260;
          *(_QWORD *)&v209 = v158;
          *(_QWORD *)v159 = off_1E81A0C88;
          llvm::Twine::str((llvm::Twine *)&v209, (_QWORD *)(v159 + 8));
          *(_QWORD *)(v159 + 32) = 22;
          *(_QWORD *)(v159 + 40) = v156;
          *(_BYTE *)(v159 + 48) = 1;
          v191 = (char *)v159;
          *(_QWORD *)&v213 = off_1E81A6E70;
          v148 = v182;
          if (v219 == 1 && v214)
            MEMORY[0x1CAA32F9C](v214, 0x1000C8077774924);
          if (SHIBYTE(v199) < 0)
            operator delete(__p[0]);
          v190 = v193;
          v193 = 0;
          sub_1C624E8DC(&v191, &v190, &v192);
          *(_QWORD *)&v213 = v192;
          v192 = 0;
          v181(v180, &v213);
          if ((_QWORD)v213)
            (*(void (**)(_QWORD))(*(_QWORD *)v213 + 8))(v213);
          if (v192)
            (*(void (**)(uint64_t))(*(_QWORD *)v192 + 8))(v192);
          if (v190)
            (*(void (**)(char *))(*(_QWORD *)v190 + 8))(v190);
          v153 = v191;
          if (v191)
LABEL_219:
            (*(void (**)(char *))(*(_QWORD *)v153 + 8))(v153);
        }
        else
        {
LABEL_214:
          v148 = v182;
          if (*v11 != v179)
          {
            v149 = std::generic_category();
            __p[0] = 0;
            __p[1] = 0;
            v199 = 0;
            DWORD2(v213) = 0;
            v217 = 0;
            v218 = 0;
            *(_QWORD *)&v213 = &unk_1E81A7208;
            v220 = __p;
            v219 = 0;
            v215 = 0;
            v216 = 0;
            v214 = 0;
            v150 = *v11;
            *(_QWORD *)&v209 = &unk_1E8169E08;
            *((_QWORD *)&v209 + 1) = "unknown data in line table prologue at offset 0x%8.8llx: parsing ended (at offset 0"
                                     "x%8.8llx) before reaching the prologue end at offset 0x%8.8llx";
            *(_QWORD *)&v210 = v186;
            *((_QWORD *)&v210 + 1) = v150;
            *(_QWORD *)&v211 = v179;
            llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v213, (uint64_t)&v209);
            v151 = v220;
            v152 = operator new();
            LOWORD(v211) = 260;
            *(_QWORD *)&v209 = v151;
            *(_QWORD *)v152 = off_1E81A0C88;
            llvm::Twine::str((llvm::Twine *)&v209, (_QWORD *)(v152 + 8));
            *(_QWORD *)(v152 + 32) = 22;
            *(_QWORD *)(v152 + 40) = v149;
            *(_BYTE *)(v152 + 48) = 1;
            *(_QWORD *)&v213 = off_1E81A6E70;
            if (v219 == 1 && v214)
              MEMORY[0x1CAA32F9C](v214, 0x1000C8077774924);
            if (SHIBYTE(v199) < 0)
              operator delete(__p[0]);
            *(_QWORD *)&v213 = v152;
            v181(v180, &v213);
            v153 = (char *)v213;
            if ((_QWORD)v213)
              goto LABEL_219;
          }
        }
        *v148 = 0;
        v145 = v193;
        if (v193)
LABEL_221:
          (*(void (**)(char *))(*(_QWORD *)v145 + 8))(v145);
LABEL_8:
        result = v197;
        if (v197)
          return (char *)(*(uint64_t (**)(char *))(*(_QWORD *)v197 + 8))(v197);
        return result;
      default:
        if (v79 == 8193)
        {
          LOWORD(v173) = __p[0];
          BYTE4(v173) = BYTE2(__p[0]);
          v203 = *(_DWORD *)((char *)__p + 3);
          v204 = HIBYTE(__p[0]);
          v174 = __p[1];
          v176 = v199;
          v167 = v200;
          v178 = v201;
          v184 = v202;
        }
        goto LABEL_101;
    }
  }
}

double llvm::DWARFDebugLine::Row::Row(llvm::DWARFDebugLine::Row *this, char a2)
{
  double result;

  result = 0.0;
  *(_OWORD *)this = xmmword_1C640F7C0;
  *((_QWORD *)this + 2) = 0x1000000000001;
  *((_BYTE *)this + 28) = 0;
  *((_DWORD *)this + 6) = 0;
  *((_BYTE *)this + 29) = *((_BYTE *)this + 29) & 0xE0 | a2;
  return result;
}

{
  double result;

  result = 0.0;
  *(_OWORD *)this = xmmword_1C640F7C0;
  *((_QWORD *)this + 2) = 0x1000000000001;
  *((_BYTE *)this + 28) = 0;
  *((_DWORD *)this + 6) = 0;
  *((_BYTE *)this + 29) = *((_BYTE *)this + 29) & 0xE0 | a2;
  return result;
}

double llvm::DWARFDebugLine::Row::reset(llvm::DWARFDebugLine::Row *this, char a2)
{
  double result;

  result = 0.0;
  *(_OWORD *)this = xmmword_1C640F7C0;
  *((_QWORD *)this + 2) = 0x1000000000001;
  *((_BYTE *)this + 28) = 0;
  *((_DWORD *)this + 6) = 0;
  *((_BYTE *)this + 29) = *((_BYTE *)this + 29) & 0xE0 | a2;
  return result;
}

uint64_t llvm::DWARFDebugLine::Row::postAppend(uint64_t this)
{
  *(_DWORD *)(this + 24) = 0;
  *(_BYTE *)(this + 29) &= 0xE5u;
  return this;
}

uint64_t llvm::DWARFDebugLine::Sequence::Sequence(uint64_t this)
{
  *(_QWORD *)this = 0;
  *(_QWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 16) = -1;
  *(_QWORD *)(this + 24) = 0;
  *(_BYTE *)(this + 32) = 1;
  return this;
}

{
  *(_QWORD *)this = 0;
  *(_QWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 16) = -1;
  *(_QWORD *)(this + 24) = 0;
  *(_BYTE *)(this + 32) = 1;
  return this;
}

uint64_t llvm::DWARFDebugLine::Sequence::reset(uint64_t this)
{
  *(_QWORD *)this = 0;
  *(_QWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 16) = -1;
  *(_QWORD *)(this + 24) = 0;
  *(_BYTE *)(this + 32) = 1;
  return this;
}

uint64_t llvm::DWARFDebugLine::LineTable::clear(uint64_t this)
{
  *(_QWORD *)(this + 13) = 0;
  *(_QWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 24) = 0;
  *(_QWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 39) = 0;
  *(_QWORD *)(this + 56) = *(_QWORD *)(this + 48);
  *(_QWORD *)(this + 80) = *(_QWORD *)(this + 72);
  *(_QWORD *)(this + 104) = *(_QWORD *)(this + 96);
  *(_QWORD *)(this + 128) = *(_QWORD *)(this + 120);
  *(_QWORD *)(this + 152) = *(_QWORD *)(this + 144);
  return this;
}

double llvm::DWARFDebugLine::LineTable::LineTable(llvm::DWARFDebugLine::LineTable *this)
{
  double result;

  *(_DWORD *)this = -1;
  *((_QWORD *)this + 1) = 0;
  *(_QWORD *)((char *)this + 13) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *(_DWORD *)((char *)this + 39) = 0;
  result = 0.0;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_QWORD *)this + 20) = 0;
  return result;
}

{
  double result;

  *(_DWORD *)this = -1;
  *((_QWORD *)this + 1) = 0;
  *(_QWORD *)((char *)this + 13) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *(_DWORD *)((char *)this + 39) = 0;
  result = 0.0;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_QWORD *)this + 20) = 0;
  return result;
}

llvm::raw_ostream *llvm::DWARFDebugLine::LineTable::dump(uint64_t a1, llvm::raw_ostream *a2, __int128 *a3)
{
  uint64_t v5;
  llvm::raw_ostream *result;
  _BYTE *v7;
  _BYTE *v8;
  llvm::DWARFDebugLine::Row *v9;
  llvm::DWARFDebugLine::Row *v10;
  __int128 v11[5];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v5 = a1 + 8;
  sub_1C624C4A4((uint64_t)v11, a3);
  llvm::DWARFDebugLine::Prologue::dump(v5, a2, v11);
  result = (llvm::raw_ostream *)sub_1C624C568(v11);
  if (*(_QWORD *)(a1 + 120) != *(_QWORD *)(a1 + 128))
  {
    v8 = (_BYTE *)*((_QWORD *)a2 + 4);
    if ((unint64_t)v8 >= *((_QWORD *)a2 + 3))
    {
      llvm::raw_ostream::write(a2, 10);
    }
    else
    {
      *((_QWORD *)a2 + 4) = v8 + 1;
      *v8 = 10;
    }
    result = llvm::DWARFDebugLine::Row::dumpTableHeader(a2, 0);
    v10 = *(llvm::DWARFDebugLine::Row **)(a1 + 120);
    v9 = *(llvm::DWARFDebugLine::Row **)(a1 + 128);
    while (v10 != v9)
    {
      result = llvm::DWARFDebugLine::Row::dump(v10, a2);
      v10 = (llvm::DWARFDebugLine::Row *)((char *)v10 + 32);
    }
  }
  v7 = (_BYTE *)*((_QWORD *)a2 + 4);
  if ((unint64_t)v7 >= *((_QWORD *)a2 + 3))
    return llvm::raw_ostream::write(a2, 10);
  *((_QWORD *)a2 + 4) = v7 + 1;
  *v7 = 10;
  return result;
}

double llvm::DWARFDebugLine::ParsingState::ParsingState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  char v5;
  BOOL v6;
  double result;

  *(_QWORD *)a1 = a2;
  v5 = *(_BYTE *)(a1 + 37) & 0xE0;
  *(_BYTE *)(a1 + 37) = v5;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 80) = a3;
  *(_WORD *)(a1 + 88) = 257;
  *(_QWORD *)(a1 + 96) = a4;
  *(_QWORD *)(a1 + 104) = a5;
  v6 = *(_BYTE *)(a2 + 35) != 0;
  result = 0.0;
  *(_OWORD *)(a1 + 8) = xmmword_1C640F7C0;
  *(_QWORD *)(a1 + 24) = 0x1000000000001;
  *(_BYTE *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 37) = v5 | v6;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = -1;
  *(_QWORD *)(a1 + 64) = 0;
  *(_BYTE *)(a1 + 72) = 1;
  return result;
}

double llvm::DWARFDebugLine::ParsingState::resetRowAndSequence(llvm::DWARFDebugLine::ParsingState *this)
{
  BOOL v1;
  double result;

  v1 = *(_BYTE *)(*(_QWORD *)this + 35) != 0;
  result = 0.0;
  *(_OWORD *)((char *)this + 8) = xmmword_1C640F7C0;
  *((_QWORD *)this + 3) = 0x1000000000001;
  *((_BYTE *)this + 36) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_BYTE *)this + 37) = *((_BYTE *)this + 37) & 0xE0 | v1;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = -1;
  *((_QWORD *)this + 8) = 0;
  *((_BYTE *)this + 72) = 1;
  return result;
}

void llvm::DWARFDebugLine::ParsingState::appendRowToMatrix(llvm::DWARFDebugLine::ParsingState *this)
{
  _QWORD *v2;
  char *v3;
  char *v4;
  uint64_t v5;
  unint64_t v6;
  _OWORD *v7;
  unint64_t v8;
  __int128 v9;
  _OWORD *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  __int128 v17;
  __int128 v18;
  char v19;
  _QWORD *v20;
  __int128 v21;
  _QWORD *v22;
  unint64_t v23;
  char *v24;
  __int128 v25;
  __int128 v26;
  char *v27;
  _BYTE *v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  char *v32;
  char *v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;

  v2 = *(_QWORD **)this;
  v4 = *(char **)(*(_QWORD *)this + 120);
  v3 = *(char **)(*(_QWORD *)this + 128);
  v5 = v3 - v4;
  v6 = (unint64_t)(v3 - v4) >> 5;
  if (*((_BYTE *)this + 72))
  {
    *((_BYTE *)this + 72) = 0;
    *((_QWORD *)this + 5) = *((_QWORD *)this + 1);
    *((_DWORD *)this + 16) = v6;
  }
  v7 = (_OWORD *)((char *)this + 8);
  v8 = v2[17];
  if ((unint64_t)v3 >= v8)
  {
    v11 = v5 >> 5;
    v12 = (v5 >> 5) + 1;
    if (v12 >> 59)
      goto LABEL_44;
    v13 = v8 - (_QWORD)v4;
    if (v13 >> 4 > v12)
      v12 = v13 >> 4;
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFE0)
      v14 = 0x7FFFFFFFFFFFFFFLL;
    else
      v14 = v12;
    if (v14)
    {
      if (v14 >> 59)
        goto LABEL_45;
      v15 = (char *)operator new(32 * v14);
    }
    else
    {
      v15 = 0;
    }
    v16 = &v15[32 * v11];
    v17 = *(_OWORD *)((char *)this + 24);
    *(_OWORD *)v16 = *v7;
    *((_OWORD *)v16 + 1) = v17;
    v10 = v16 + 32;
    if (v3 != v4)
    {
      do
      {
        v18 = *((_OWORD *)v3 - 2);
        *(_OWORD *)(v16 - 18) = *(_OWORD *)(v3 - 18);
        *((_OWORD *)v16 - 2) = v18;
        v16 -= 32;
        v3 -= 32;
      }
      while (v3 != v4);
      v3 = (char *)v2[15];
    }
    v2[15] = v16;
    v2[16] = v10;
    v2[17] = &v15[32 * v14];
    if (v3)
      operator delete(v3);
  }
  else
  {
    v9 = *(_OWORD *)((char *)this + 24);
    *(_OWORD *)v3 = *v7;
    *((_OWORD *)v3 + 1) = v9;
    v10 = v3 + 32;
  }
  v2[16] = v10;
  v19 = *((_BYTE *)this + 37);
  if ((v19 & 4) != 0)
  {
    v20 = (_QWORD *)((char *)this + 40);
    *((_DWORD *)this + 17) = v6 + 1;
    v21 = *(_OWORD *)((char *)this + 8);
    *((_OWORD *)this + 3) = v21;
    if (*((_BYTE *)this + 72) || *v20 >= (unint64_t)v21 || *((_DWORD *)this + 16) >= (v6 + 1))
      goto LABEL_42;
    v22 = *(_QWORD **)this;
    v24 = *(char **)(*(_QWORD *)this + 152);
    v23 = *(_QWORD *)(*(_QWORD *)this + 160);
    if ((unint64_t)v24 < v23)
    {
      v25 = *(_OWORD *)v20;
      v26 = *(_OWORD *)((char *)this + 56);
      *((_QWORD *)v24 + 4) = *((_QWORD *)this + 9);
      *(_OWORD *)v24 = v25;
      *((_OWORD *)v24 + 1) = v26;
      v27 = v24 + 40;
LABEL_41:
      v22[19] = v27;
      v19 = *((_BYTE *)this + 37);
LABEL_42:
      *v20 = 0;
      *((_QWORD *)this + 6) = 0;
      *((_QWORD *)this + 7) = -1;
      *((_QWORD *)this + 8) = 0;
      *((_BYTE *)this + 72) = 1;
      goto LABEL_43;
    }
    v28 = (_BYTE *)v22[18];
    v29 = 0xCCCCCCCCCCCCCCCDLL * ((v24 - v28) >> 3) + 1;
    if (v29 <= 0x666666666666666)
    {
      v30 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v23 - (_QWORD)v28) >> 3);
      if (2 * v30 > v29)
        v29 = 2 * v30;
      if (v30 >= 0x333333333333333)
        v31 = 0x666666666666666;
      else
        v31 = v29;
      if (!v31)
      {
        v32 = 0;
        goto LABEL_36;
      }
      if (v31 <= 0x666666666666666)
      {
        v32 = (char *)operator new(40 * v31);
LABEL_36:
        v33 = &v32[8 * ((v24 - v28) >> 3)];
        v34 = *(_OWORD *)((char *)this + 56);
        *(_OWORD *)v33 = *(_OWORD *)v20;
        *((_OWORD *)v33 + 1) = v34;
        *((_QWORD *)v33 + 4) = *((_QWORD *)this + 9);
        v27 = v33 + 40;
        if (v24 != v28)
        {
          do
          {
            v35 = *(_OWORD *)(v24 - 40);
            v36 = *(_OWORD *)(v24 - 24);
            *(v33 - 8) = *(v24 - 8);
            *(_OWORD *)(v33 - 24) = v36;
            *(_OWORD *)(v33 - 40) = v35;
            v33 -= 40;
            v24 -= 40;
          }
          while (v24 != v28);
          v24 = (char *)v22[18];
        }
        v22[18] = v33;
        v22[19] = v27;
        v22[20] = &v32[40 * v31];
        if (v24)
          operator delete(v24);
        goto LABEL_41;
      }
LABEL_45:
      sub_1C4764EE4();
    }
LABEL_44:
    abort();
  }
LABEL_43:
  *((_DWORD *)this + 8) = 0;
  *((_BYTE *)this + 37) = v19 & 0xE5;
}

void llvm::DWARFDebugLine::getOrParseLineTable(uint64_t **a1@<X0>, uint64_t a2@<X1>, void (**a3)(llvm::raw_ostream *__hidden this)@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, void (*a6)(uint64_t, __int128 *)@<X5>, uint64_t a7@<X6>, uint64_t a8@<X8>)
{
  const std::error_category *v10;
  void **v11;
  uint64_t v12;
  void (**v19)(llvm::raw_ostream *__hidden);
  uint64_t *v20;
  uint64_t **v21;
  uint64_t **v22;
  unint64_t v23;
  uint64_t *v24;
  uint64_t *v25;
  char v26;
  void (**v27)(llvm::raw_ostream *__hidden);
  uint64_t *v28;
  void **v29;
  __int128 v30;
  uint64_t v31;
  _QWORD v32[2];
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40;
  void (**v41)(llvm::raw_ostream *__hidden);
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char v46;
  uint64_t v47;
  int v48;
  void **v49;
  void (**v50)(llvm::raw_ostream *__hidden);
  void *v51[2];
  uint64_t v52;

  v50 = a3;
  if (*(_QWORD *)(a2 + 8) > (unint64_t)a3)
  {
    LODWORD(v29) = -1;
    *(_QWORD *)&v30 = 0;
    *(_QWORD *)((char *)&v30 + 5) = 0;
    v31 = 0;
    v32[0] = 0;
    *(_DWORD *)((char *)v32 + 7) = 0;
    v33 = 0u;
    v34 = 0u;
    v35 = 0u;
    v36 = 0u;
    v37 = 0u;
    v38 = 0u;
    v39 = 0u;
    v40 = 0;
    v41 = a3;
    sub_1C624F604((uint64_t)&v42, (uint64_t)&v29);
    v19 = v41;
    v21 = a1 + 1;
    v20 = a1[1];
    if (v20)
    {
      while (1)
      {
        while (1)
        {
          v22 = (uint64_t **)v20;
          v23 = v20[4];
          if (v23 <= (unint64_t)v41)
            break;
          v20 = *v22;
          v21 = v22;
          if (!*v22)
            goto LABEL_14;
        }
        if (v23 >= (unint64_t)v41)
          break;
        v20 = v22[1];
        if (!v20)
        {
          v21 = v22 + 1;
          goto LABEL_14;
        }
      }
      v26 = 1;
    }
    else
    {
      v22 = a1 + 1;
LABEL_14:
      v28 = (uint64_t *)v22;
      v22 = (uint64_t **)operator new(0xD0uLL);
      v22[4] = (uint64_t *)v19;
      sub_1C624F604((uint64_t)(v22 + 5), (uint64_t)&v42);
      *v22 = 0;
      v22[1] = 0;
      v22[2] = v28;
      *v21 = (uint64_t *)v22;
      v24 = (uint64_t *)**a1;
      v25 = (uint64_t *)v22;
      if (v24)
      {
        *a1 = v24;
        v25 = *v21;
      }
      sub_1C4768E74(a1[1], v25);
      v26 = 0;
      a1[2] = (uint64_t *)((char *)a1[2] + 1);
    }
    sub_1C624DF80(&v42);
    sub_1C624DF80(&v29);
    if ((v26 & 1) != 0
      || (llvm::DWARFDebugLine::LineTable::parse((uint64_t)(v22 + 5), (__int128 *)a2, (unint64_t *)&v50, a4, a5, a6, a7, 0, (uint64_t *)&v41, 0), (v27 = v41) == 0))
    {
      *(_BYTE *)(a8 + 8) &= ~1u;
      *(_QWORD *)a8 = v22 + 5;
    }
    else
    {
      *(_BYTE *)(a8 + 8) |= 1u;
      *(_QWORD *)a8 = v27;
    }
  }
  else
  {
    v10 = std::generic_category();
    v51[0] = 0;
    v51[1] = 0;
    v52 = 0;
    LODWORD(v42) = 0;
    v46 = 0;
    v47 = 0;
    v41 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
    v49 = v51;
    v48 = 0;
    v44 = 0;
    v45 = 0;
    v43 = 0;
    v29 = (void **)&unk_1E8133270;
    *(_QWORD *)&v30 = "offset 0x%8.8llx is not a valid debug line section offset";
    *((_QWORD *)&v30 + 1) = a3;
    llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v41, (uint64_t)&v29);
    v11 = v49;
    v12 = operator new();
    LOWORD(v32[0]) = 260;
    v29 = v11;
    *(_QWORD *)v12 = off_1E81A0C88;
    llvm::Twine::str((llvm::Twine *)&v29, (_QWORD *)(v12 + 8));
    *(_QWORD *)(v12 + 32) = 22;
    *(_QWORD *)(v12 + 40) = v10;
    *(_BYTE *)(v12 + 48) = 1;
    v41 = off_1E81A6E70;
    if (v48 == 1 && v43)
      MEMORY[0x1CAA32F9C](v43, 0x1000C8077774924);
    if (SHIBYTE(v52) < 0)
      operator delete(v51[0]);
    *(_BYTE *)(a8 + 8) |= 1u;
    *(_QWORD *)a8 = v12;
  }
}

